[ExtensionAttribute]
public static class iTextSharp.LGPLv2.Core.System.Drawing.SkiaSharpExtensions : object {
    [ExtensionAttribute]
public static SKColor ToSKColor(Color color);
    [ExtensionAttribute]
public static int ToArgb(SKColor color);
}
public static class iTextSharp.LGPLv2.Core.System.Encodings.EncodingsRegistry : object {
    private static EncodingsRegistry();
    public static Encoding GetEncoding(int codepage);
    public static Encoding GetEncoding(string name);
}
[ExtensionAttribute]
public static class iTextSharp.LGPLv2.Core.System.NetUtils.WebUtils : object {
    [ExtensionAttribute]
public static Stream GetResponseStream(Uri url);
    [ExtensionAttribute]
public static Stream GetResponseStream(string url);
}
public class iTextSharp.MD5BouncyCastle : HashAlgorithm {
    private MD5Digest _digestInternal;
    public static HashAlgorithm Create();
    public virtual void Initialize();
    protected virtual void HashCore(Byte[] array, int ibStart, int cbSize);
    protected virtual Byte[] HashFinal();
}
public class iTextSharp.text.Anchor : Phrase {
    protected string name;
    protected string reference;
    [CompilerGeneratedAttribute]
private int <Type>k__BackingField;
    public IList`1<Chunk> Chunks { get; }
    public string Name { get; public set; }
    public string Reference { get; public set; }
    public int Type { get; }
    public Uri Url { get; }
    public Anchor(float leading);
    public Anchor(Chunk chunk);
    public Anchor(string str);
    public Anchor(string str, Font font);
    public Anchor(float leading, Chunk chunk);
    public Anchor(float leading, string str);
    public Anchor(float leading, string str, Font font);
    public Anchor(Phrase phrase);
    public virtual IList`1<Chunk> get_Chunks();
    public string get_Name();
    public void set_Name(string value);
    public string get_Reference();
    public void set_Reference(string value);
    [CompilerGeneratedAttribute]
public virtual int get_Type();
    public Uri get_Url();
    public virtual bool Process(IElementListener listener);
}
public class iTextSharp.text.Annotation : object {
    public static string APPLICATION;
    public static string CONTENT;
    public static string DEFAULTDIR;
    public static string DESTINATION;
    public static string FILE;
    public static int FILE_DEST;
    public static int FILE_PAGE;
    public static int LAUNCH;
    public static string LLX;
    public static string LLY;
    public static string MIMETYPE;
    public static string NAMED;
    public static int NAMED_DEST;
    public static string OPERATION;
    public static string PAGE;
    public static string PARAMETERS;
    public static int SCREEN;
    public static int TEXT;
    public static string TITLE;
    public static string URL;
    public static int URL_AS_STRING;
    public static int URL_NET;
    public static string URX;
    public static string URY;
    private float _llx;
    private float _lly;
    private float _urx;
    private float _ury;
    protected INullValueDictionary`2<string, object> AnnotationAttributes;
    [CompilerGeneratedAttribute]
private int <AnnotationType>k__BackingField;
    public int AnnotationType { get; }
    public INullValueDictionary`2<string, object> Attributes { get; }
    public string Content { get; }
    public string Title { get; }
    public IList`1<Chunk> Chunks { get; }
    public int Type { get; }
    public Annotation(Annotation an);
    public Annotation(string title, string text);
    public Annotation(string title, string text, float llx, float lly, float urx, float ury);
    public Annotation(float llx, float lly, float urx, float ury, Uri url);
    public Annotation(float llx, float lly, float urx, float ury, string url);
    public Annotation(float llx, float lly, float urx, float ury, string file, string dest);
    public Annotation(float llx, float lly, float urx, float ury, string moviePath, string mimeType, bool showOnDisplay);
    public Annotation(float llx, float lly, float urx, float ury, string file, int page);
    public Annotation(float llx, float lly, float urx, float ury, int named);
    public Annotation(float llx, float lly, float urx, float ury, string application, string parameters, string operation, string defaultdir);
    private Annotation(float llx, float lly, float urx, float ury);
    [CompilerGeneratedAttribute]
public int get_AnnotationType();
    public INullValueDictionary`2<string, object> get_Attributes();
    public string get_Content();
    public string get_Title();
    public sealed virtual IList`1<Chunk> get_Chunks();
    public sealed virtual int get_Type();
    public sealed virtual bool IsContent();
    public sealed virtual bool IsNestable();
    public sealed virtual bool Process(IElementListener listener);
    public float GetLlx();
    public float GetLlx(float def);
    public float GetLly();
    public float GetLly(float def);
    public float GetUrx();
    public float GetUrx(float def);
    public float GetUry();
    public float GetUry(float def);
    public void SetDimensions(float llx, float lly, float urx, float ury);
}
public class iTextSharp.text.BadElementException : DocumentException {
    public BadElementException(string message);
    public BadElementException(string message, Exception innerException);
}
public class iTextSharp.text.BaseColor : object {
    private static double Factor;
    public static BaseColor Black;
    public static BaseColor Blue;
    public static BaseColor Cyan;
    public static BaseColor DarkGray;
    public static BaseColor Gray;
    public static BaseColor Green;
    public static BaseColor LightGray;
    public static BaseColor Magenta;
    public static BaseColor Orange;
    public static BaseColor Pink;
    public static BaseColor Red;
    public static BaseColor White;
    public static BaseColor Yellow;
    private Color _color;
    public int B { get; }
    public int G { get; }
    public int R { get; }
    public BaseColor(int red, int green, int blue);
    public BaseColor(int red, int green, int blue, int alpha);
    public BaseColor(float red, float green, float blue);
    public BaseColor(float red, float green, float blue, float alpha);
    public BaseColor(int argb);
    public BaseColor(Color color);
    private static BaseColor();
    public int get_B();
    public int get_G();
    public int get_R();
    public BaseColor Brighter();
    public BaseColor Darker();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public int ToArgb();
}
public class iTextSharp.text.Cell : Rectangle {
    private float _leading;
    private string _showTruncation;
    protected IList`1<IElement> ArrayList;
    protected int colspan;
    protected bool groupChange;
    protected bool header;
    protected int horizontalAlignment;
    protected int maxLines;
    protected bool noWrap;
    protected bool Percentage;
    protected int rowspan;
    protected bool useAscender;
    protected bool useBorderPadding;
    protected bool useDescender;
    protected int verticalAlignment;
    protected float width;
    public static Cell DummyCell { get; }
    public float Bottom { get; public set; }
    public int Colspan { get; public set; }
    public IList`1<IElement> Elements { get; }
    public bool GroupChange { get; public set; }
    public bool Header { get; public set; }
    public int HorizontalAlignment { get; public set; }
    public float Leading { get; public set; }
    public float Left { get; public set; }
    public int MaxLines { get; public set; }
    public bool NoWrap { get; public set; }
    public float Right { get; public set; }
    public int Rowspan { get; public set; }
    public string ShowTruncation { get; public set; }
    public int Size { get; }
    public float Top { get; public set; }
    public bool UseAscender { get; public set; }
    public bool UseBorderPadding { get; public set; }
    public bool UseDescender { get; public set; }
    public int VerticalAlignment { get; public set; }
    public float Width { get; public set; }
    public IList`1<Chunk> Chunks { get; }
    public int Type { get; }
    public Cell(bool dummy);
    public Cell(string content);
    public Cell(IElement element);
    public static Cell get_DummyCell();
    public virtual float get_Bottom();
    public virtual void set_Bottom(float value);
    public int get_Colspan();
    public void set_Colspan(int value);
    public IList`1<IElement> get_Elements();
    public bool get_GroupChange();
    public void set_GroupChange(bool value);
    public bool get_Header();
    public void set_Header(bool value);
    public int get_HorizontalAlignment();
    public void set_HorizontalAlignment(int value);
    public float get_Leading();
    public void set_Leading(float value);
    public virtual float get_Left();
    public virtual void set_Left(float value);
    public int get_MaxLines();
    public void set_MaxLines(int value);
    public bool get_NoWrap();
    public void set_NoWrap(bool value);
    public virtual float get_Right();
    public virtual void set_Right(float value);
    public int get_Rowspan();
    public void set_Rowspan(int value);
    public string get_ShowTruncation();
    public void set_ShowTruncation(string value);
    public int get_Size();
    public virtual float get_Top();
    public virtual void set_Top(float value);
    public bool get_UseAscender();
    public void set_UseAscender(bool value);
    public bool get_UseBorderPadding();
    public void set_UseBorderPadding(bool value);
    public bool get_UseDescender();
    public void set_UseDescender(bool value);
    public int get_VerticalAlignment();
    public void set_VerticalAlignment(int value);
    public virtual void set_Width(float value);
    public virtual float get_Width();
    public virtual IList`1<Chunk> get_Chunks();
    public virtual int get_Type();
    public virtual bool Process(IElementListener listener);
    public sealed virtual bool Add(IElement o);
    public static bool IsTag(string tag);
    public void AddElement(IElement element);
    public void Clear();
    public PdfPCell CreatePdfPCell();
    public static float GetBottom(int margin);
    public static float GetLeft(int margin);
    public static float GetRight(int margin);
    public static float GetTop(int margin);
    public string GetWidthAsString();
    public bool IsEmpty();
    public bool IsTable();
    public void SetHorizontalAlignment(string alignment);
    public void SetVerticalAlignment(string alignment);
    public void SetWidth(string value);
    internal void Fill();
}
public class iTextSharp.text.Chapter : Section {
    [CompilerGeneratedAttribute]
private int <Type>k__BackingField;
    public int Type { get; }
    public Chapter(int number);
    public Chapter(Paragraph title, int number);
    public Chapter(string title, int number);
    [CompilerGeneratedAttribute]
public virtual int get_Type();
    public virtual bool IsNestable();
}
public class iTextSharp.text.ChapterAutoNumber : Chapter {
    protected bool NumberSet;
    public ChapterAutoNumber(Paragraph para);
    public ChapterAutoNumber(string title);
    public virtual Section AddSection(string title);
    public virtual Section AddSection(Paragraph title);
    public int SetAutomaticNumber(int number);
}
public class iTextSharp.text.Chunk : object {
    public static string ACTION;
    public static string BACKGROUND;
    public static string COLOR;
    public static string ENCODING;
    public static string GENERICTAG;
    public static string HSCALE;
    public static string HYPHENATION;
    public static string IMAGE;
    public static string LOCALDESTINATION;
    public static string LOCALGOTO;
    public static string NEWPAGE;
    public static string OBJECT_REPLACEMENT_CHARACTER;
    public static string PDFANNOTATION;
    public static string REMOTEGOTO;
    public static string SEPARATOR;
    public static string SKEW;
    public static string SPLITCHARACTER;
    public static string SUBSUPSCRIPT;
    public static string TAB;
    public static string TEXTRENDERMODE;
    public static string UNDERLINE;
    public static Chunk Newline;
    public static Chunk Nextpage;
    protected INullValueDictionary`2<string, object> attributes;
    protected StringBuilder content;
    protected Font font;
    public INullValueDictionary`2<string, object> Attributes { get; public set; }
    public string Content { get; }
    public Font Font { get; public set; }
    public float HorizontalScaling { get; }
    public IList`1<Chunk> Chunks { get; }
    public int Type { get; }
    private static Chunk();
    public Chunk(Chunk ck);
    public Chunk(string content, Font font);
    public Chunk(string content);
    public Chunk(char c, Font font);
    public Chunk(char c);
    public Chunk(Image image, float offsetX, float offsetY);
    public Chunk(IDrawInterface separator);
    public Chunk(IDrawInterface separator, bool vertical);
    public Chunk(IDrawInterface separator, float tabPosition);
    public Chunk(IDrawInterface separator, float tabPosition, bool newline);
    public Chunk(Image image, float offsetX, float offsetY, bool changeLeading);
    public INullValueDictionary`2<string, object> get_Attributes();
    public void set_Attributes(INullValueDictionary`2<string, object> value);
    public virtual string get_Content();
    public virtual Font get_Font();
    public virtual void set_Font(Font value);
    public float get_HorizontalScaling();
    public sealed virtual IList`1<Chunk> get_Chunks();
    public sealed virtual int get_Type();
    public sealed virtual bool IsContent();
    public sealed virtual bool IsNestable();
    public sealed virtual bool Process(IElementListener listener);
    public virtual string ToString();
    public static bool IsTag(string tag);
    public StringBuilder Append(string str);
    public IHyphenationEvent GetHyphenation();
    public Image GetImage();
    public float GetTextRise();
    public float GetWidthPoint();
    public bool HasAttributes();
    public virtual bool IsEmpty();
    public Chunk SetAction(PdfAction action);
    public Chunk SetAnchor(Uri url);
    public Chunk SetAnchor(string url);
    public Chunk SetAnnotation(PdfAnnotation annotation);
    public Chunk SetBackground(BaseColor color);
    public Chunk SetBackground(BaseColor color, float extraLeft, float extraBottom, float extraRight, float extraTop);
    public Chunk SetGenericTag(string text);
    public Chunk SetHorizontalScaling(float scale);
    public Chunk SetHyphenation(IHyphenationEvent hyphenation);
    public Chunk SetLocalDestination(string name);
    public Chunk SetLocalGoto(string name);
    public Chunk SetNewPage();
    public Chunk SetRemoteGoto(string filename, string name);
    public Chunk SetRemoteGoto(string filename, int page);
    public Chunk SetSkew(float alpha, float beta);
    public Chunk SetSplitCharacter(ISplitCharacter splitCharacter);
    public Chunk SetTextRenderMode(int mode, float strokeWidth, BaseColor strokeColor);
    public Chunk SetTextRise(float rise);
    public Chunk SetUnderline(float thickness, float yPosition);
    public Chunk SetUnderline(BaseColor color, float thickness, float thicknessMul, float yPosition, float yPositionMul, int cap);
    private Chunk setAttribute(string name, object obj);
}
public class iTextSharp.text.Document : object {
    public static bool Compress;
    public static float WmfFontCorrection;
    private List`1<IDocListener> _listeners;
    protected int Chapternumber;
    protected HeaderFooter footer;
    protected HeaderFooter header;
    protected bool IsDocumentClose;
    protected bool IsDocumentOpen;
    protected bool MarginMirroring;
    protected bool MarginMirroringTopBottom;
    [CompilerGeneratedAttribute]
private static string <Product>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <Release>k__BackingField;
    [CompilerGeneratedAttribute]
private float <BottomMargin>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HtmlStyleClass>k__BackingField;
    [CompilerGeneratedAttribute]
private string <JavaScriptOnLoad>k__BackingField;
    [CompilerGeneratedAttribute]
private string <JavaScriptOnUnLoad>k__BackingField;
    [CompilerGeneratedAttribute]
private float <LeftMargin>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PageNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private Rectangle <PageSize>k__BackingField;
    [CompilerGeneratedAttribute]
private float <RightMargin>k__BackingField;
    [CompilerGeneratedAttribute]
private float <TopMargin>k__BackingField;
    public static string Product { get; }
    public static string Release { get; }
    public float Bottom { get; }
    public float BottomMargin { get; protected set; }
    public string HtmlStyleClass { get; public set; }
    public string JavaScriptOnLoad { get; public set; }
    public string JavaScriptOnUnLoad { get; public set; }
    public float Left { get; }
    public float LeftMargin { get; protected set; }
    public int PageNumber { get; protected set; }
    public Rectangle PageSize { get; protected set; }
    public float Right { get; }
    public float RightMargin { get; protected set; }
    public float Top { get; }
    public float TopMargin { get; protected set; }
    public static string Version { get; }
    unknown HeaderFooter Footer {public set; }
    unknown HeaderFooter Header {public set; }
    unknown int PageCount {public set; }
    public Document(Rectangle pageSize);
    public Document(Rectangle pageSize, float marginLeft, float marginRight, float marginTop, float marginBottom);
    private static Document();
    [CompilerGeneratedAttribute]
public static string get_Product();
    [CompilerGeneratedAttribute]
public static string get_Release();
    public float get_Bottom();
    [CompilerGeneratedAttribute]
public float get_BottomMargin();
    [CompilerGeneratedAttribute]
protected void set_BottomMargin(float value);
    [CompilerGeneratedAttribute]
public string get_HtmlStyleClass();
    [CompilerGeneratedAttribute]
public void set_HtmlStyleClass(string value);
    [CompilerGeneratedAttribute]
public string get_JavaScriptOnLoad();
    [CompilerGeneratedAttribute]
public void set_JavaScriptOnLoad(string value);
    [CompilerGeneratedAttribute]
public string get_JavaScriptOnUnLoad();
    [CompilerGeneratedAttribute]
public void set_JavaScriptOnUnLoad(string value);
    public float get_Left();
    [CompilerGeneratedAttribute]
public float get_LeftMargin();
    [CompilerGeneratedAttribute]
protected void set_LeftMargin(float value);
    [CompilerGeneratedAttribute]
public int get_PageNumber();
    [CompilerGeneratedAttribute]
protected void set_PageNumber(int value);
    [CompilerGeneratedAttribute]
public Rectangle get_PageSize();
    [CompilerGeneratedAttribute]
protected void set_PageSize(Rectangle value);
    public float get_Right();
    [CompilerGeneratedAttribute]
public float get_RightMargin();
    [CompilerGeneratedAttribute]
protected void set_RightMargin(float value);
    public float get_Top();
    [CompilerGeneratedAttribute]
public float get_TopMargin();
    [CompilerGeneratedAttribute]
protected void set_TopMargin(float value);
    public static string get_Version();
    public virtual void set_Footer(HeaderFooter value);
    public virtual void set_Header(HeaderFooter value);
    public virtual void set_PageCount(int value);
    public virtual bool Add(IElement element);
    public virtual void Close();
    public virtual bool NewPage();
    public virtual void Open();
    public virtual void ResetFooter();
    public virtual void ResetHeader();
    public virtual void ResetPageCount();
    public virtual bool SetMarginMirroring(bool marginMirroring);
    public virtual bool SetMarginMirroringTopBottom(bool marginMirroringTopBottom);
    public virtual bool SetMargins(float marginLeft, float marginRight, float marginTop, float marginBottom);
    public virtual bool SetPageSize(Rectangle pageSize);
    public sealed virtual void Dispose();
    public bool AddAuthor(string author);
    public bool AddCreationDate();
    public bool AddCreator(string creator);
    public void AddDocListener(IDocListener listener);
    public bool AddHeader(string name, string content);
    public bool AddKeywords(string keywords);
    public bool AddProducer();
    public bool AddSubject(string subject);
    public bool AddTitle(string title);
    public float GetBottom(float margin);
    public float GetLeft(float margin);
    public float GetRight(float margin);
    public float GetTop(float margin);
    public bool IsMarginMirroring();
    public bool IsOpen();
    public void RemoveIDocListener(IDocListener listener);
}
public class iTextSharp.text.DocumentException : Exception {
    public DocumentException(string message);
    public DocumentException(string message, Exception innerException);
}
public abstract class iTextSharp.text.DocWriter : object {
    public static byte EQUALS;
    public static byte FORWARD;
    public static byte GT;
    public static byte LT;
    public static byte NEWLINE;
    public static byte QUOTE;
    public static byte SPACE;
    public static byte TAB;
    protected bool closeStream;
    protected Document Document;
    protected bool open;
    public OutputStreamCounter Os;
    protected Rectangle PageSize;
    protected bool pause;
    public bool CloseStream { get; public set; }
    unknown HeaderFooter Footer {public set; }
    unknown HeaderFooter Header {public set; }
    unknown int PageCount {public set; }
    protected DocWriter(Document document, Stream os);
    public virtual bool get_CloseStream();
    public virtual void set_CloseStream(bool value);
    public virtual void set_Footer(HeaderFooter value);
    public virtual void set_Header(HeaderFooter value);
    public virtual void set_PageCount(int value);
    public virtual bool Add(IElement element);
    public virtual void Close();
    public virtual bool NewPage();
    public virtual void Open();
    public virtual void ResetFooter();
    public virtual void ResetHeader();
    public virtual void ResetPageCount();
    public virtual bool SetMarginMirroring(bool marginMirroring);
    public virtual bool SetMarginMirroringTopBottom(bool marginMirroringTopBottom);
    public virtual bool SetMargins(float marginLeft, float marginRight, float marginTop, float marginBottom);
    public virtual bool SetPageSize(Rectangle pageSize);
    public sealed virtual void Dispose();
    public static Byte[] GetIsoBytes(string text);
    public virtual void Flush();
    public bool IsPaused();
    public virtual void Pause();
    public virtual void Resume();
    protected void AddTabs(int indent);
    protected void Write(string str);
    protected void Write(string key, string value);
    protected void WriteEnd(string tag);
    protected void WriteEnd();
    protected bool WriteMarkupAttributes(Properties markup);
    protected void WriteStart(string tag);
}
public abstract class iTextSharp.text.Element : object {
    public static int ALIGN_BASELINE;
    public static int ALIGN_BOTTOM;
    public static int ALIGN_CENTER;
    public static int ALIGN_JUSTIFIED;
    public static int ALIGN_JUSTIFIED_ALL;
    public static int ALIGN_LEFT;
    public static int ALIGN_MIDDLE;
    public static int ALIGN_RIGHT;
    public static int ALIGN_TOP;
    public static int ALIGN_UNDEFINED;
    public static int ANCHOR;
    public static int ANNOTATION;
    public static int AUTHOR;
    public static int CCITT_BLACKIS1;
    public static int CCITT_ENCODEDBYTEALIGN;
    public static int CCITT_ENDOFBLOCK;
    public static int CCITT_ENDOFLINE;
    public static int CCITTG3_1D;
    public static int CCITTG3_2D;
    public static int CCITTG4;
    public static int CELL;
    public static int CHAPTER;
    public static int CHUNK;
    public static int CREATIONDATE;
    public static int CREATOR;
    public static int HEADER;
    public static int IMGRAW;
    public static int IMGTEMPLATE;
    public static int JBIG2;
    public static int JPEG;
    public static int JPEG2000;
    public static int KEYWORDS;
    public static int LIST;
    public static int LISTITEM;
    public static int MARKED;
    public static int MULTI_COLUMN_TEXT;
    public static int PARAGRAPH;
    public static int PHRASE;
    public static int PRODUCER;
    public static int PTABLE;
    public static int RECTANGLE;
    public static int ROW;
    public static int SECTION;
    public static int SUBJECT;
    public static int TABLE;
    public static int TITLE;
    public static int YMARK;
}
public static class iTextSharp.text.ElementTags : object {
    public static string ABSOLUTEX;
    public static string ABSOLUTEY;
    public static string ALIGN;
    public static string ALIGN_BASELINE;
    public static string ALIGN_BOTTOM;
    public static string ALIGN_CENTER;
    public static string ALIGN_INDENTATION_ITEMS;
    public static string ALIGN_JUSTIFIED;
    public static string ALIGN_JUSTIFIED_ALL;
    public static string ALIGN_LEFT;
    public static string ALIGN_MIDDLE;
    public static string ALIGN_RIGHT;
    public static string ALIGN_TOP;
    public static string ALT;
    public static string ANCHOR;
    public static string ANNOTATION;
    public static string APPLICATION;
    public static string AUTHOR;
    public static string AUTO_INDENT_ITEMS;
    public static string BACKGROUNDCOLOR;
    public static string BGBLUE;
    public static string BGGREEN;
    public static string BGRED;
    public static string BLUE;
    public static string BOOKMARKOPEN;
    public static string BORDERCOLOR;
    public static string BORDERWIDTH;
    public static string BOTTOM;
    public static string CELL;
    public static string CELLPADDING;
    public static string CELLSFITPAGE;
    public static string CELLSPACING;
    public static string CHAPTER;
    public static string CHUNK;
    public static string COLOR;
    public static string COLSPAN;
    public static string COLUMNS;
    public static string CONTENT;
    public static string CONVERT2PDFP;
    public static string CREATIONDATE;
    public static string DEFAULT;
    public static string DEFAULTDIR;
    public static string DEPTH;
    public static string DESTINATION;
    public static string EMBEDDED;
    public static string ENCODING;
    public static string ENTITY;
    public static string FACE;
    public static string FILE;
    public static string FIRST;
    public static string FONT;
    public static string FOOTER;
    public static string GRAYFILL;
    public static string GREEN;
    public static string HEADER;
    public static string HORIZONTALALIGN;
    public static string HORIZONTALRULE;
    public static string ID;
    public static string IGNORE;
    public static string IMAGE;
    public static string INDENT;
    public static string INDENTATIONLEFT;
    public static string INDENTATIONRIGHT;
    public static string ITEXT;
    public static string KEEPTOGETHER;
    public static string KEYWORDS;
    public static string LASTHEADERROW;
    public static string LEADING;
    public static string LEFT;
    public static string LETTERED;
    public static string LIST;
    public static string LISTITEM;
    public static string LISTSYMBOL;
    public static string LLX;
    public static string LLY;
    public static string LOWERCASE;
    public static string NAME;
    public static string NAMED;
    public static string NEWLINE;
    public static string NEWPAGE;
    public static string NOWRAP;
    public static string NUMBER;
    public static string NUMBERDEPTH;
    public static string NUMBERED;
    public static string OFFSET;
    public static string OPERATION;
    public static string ORIENTATION;
    public static string PAGE;
    public static string PAGE_SIZE;
    public static string PARAGRAPH;
    public static string PARAMETERS;
    public static string PHRASE;
    public static string PLAINHEIGHT;
    public static string PLAINWIDTH;
    public static string PRODUCER;
    public static string RED;
    public static string REFERENCE;
    public static string RIGHT;
    public static string ROTATION;
    public static string ROW;
    public static string ROWSPAN;
    public static string SCALEDHEIGHT;
    public static string SCALEDWIDTH;
    public static string SECTION;
    public static string SIZE;
    public static string SRC;
    public static string STYLE;
    public static string SUBJECT;
    public static string SYMBOLINDENT;
    public static string TABLE;
    public static string TABLEFITSPAGE;
    public static string TEXTWRAP;
    public static string TITLE;
    public static string TOP;
    public static string UNDERLYING;
    public static string UNKNOWN;
    public static string URL;
    public static string URX;
    public static string URY;
    public static string VERTICALALIGN;
    public static string WIDTH;
    public static string WIDTHS;
    public static string Generictag;
    public static string Localdestination;
    public static string Localgoto;
    public static string Remotegoto;
    public static string Subsupscript;
    private static ElementTags();
    public static int AlignmentValue(string alignment);
    public static string GetAlignment(int alignment);
}
public class iTextSharp.text.exceptions.BadPasswordException : IOException {
    public BadPasswordException(string message);
    public BadPasswordException(string message, Exception innerException);
}
public class iTextSharp.text.exceptions.IllegalPdfSyntaxException : ArgumentException {
    public IllegalPdfSyntaxException(string message);
    public IllegalPdfSyntaxException(string message, Exception innerException);
}
public class iTextSharp.text.exceptions.InvalidPdfException : IOException {
    public InvalidPdfException(string message);
    public InvalidPdfException(string message, Exception innerException);
}
public class iTextSharp.text.exceptions.UnsupportedPdfException : InvalidPdfException {
    public UnsupportedPdfException(string message);
    public UnsupportedPdfException(string message, Exception innerException);
}
public static class iTextSharp.text.factories.ElementFactory : object {
    public static Anchor GetAnchor(Properties attributes);
    public static Annotation GetAnnotation(Properties attributes);
    public static Cell GetCell(Properties attributes);
    public static ChapterAutoNumber GetChapter(Properties attributes);
    public static Chunk GetChunk(Properties attributes);
    public static Image GetImage(Properties attributes);
    public static List GetList(Properties attributes);
    public static ListItem GetListItem(Properties attributes);
    public static Paragraph GetParagraph(Properties attributes);
    public static Phrase GetPhrase(Properties attributes);
    public static Section GetSection(Section parent, Properties attributes);
    public static Table GetTable(Properties attributes);
    private static void setRectangleProperties(Rectangle rect, Properties attributes);
    private static void setSectionParameters(Section section, Properties attributes);
}
public static class iTextSharp.text.factories.GreekAlphabetFactory : object {
    public static string GetString(int index);
    public static string GetLowerCaseString(int index);
    public static string GetUpperCaseString(int index);
    public static string GetString(int index, bool lowercase);
}
public static class iTextSharp.text.factories.RomanAlphabetFactory : object {
    public static string GetLowerCaseString(int index);
    public static string GetString(int index);
    public static string GetString(int index, bool lowercase);
    public static string GetUpperCaseString(int index);
}
public static class iTextSharp.text.factories.RomanNumberFactory : object {
    private static RomanDigit[] _roman;
    private static RomanNumberFactory();
    public static string GetLowerCaseString(int index);
    public static string GetString(int index);
    public static string GetString(int index, bool lowercase);
    public static string GetUpperCaseString(int index);
}
public class iTextSharp.text.Font : object {
    public static int BOLD;
    public static int BOLDITALIC;
    public static int COURIER;
    public static int DEFAULTSIZE;
    public static int HELVETICA;
    public static int ITALIC;
    public static int NORMAL;
    public static int STRIKETHRU;
    public static int SYMBOL;
    public static int TIMES_ROMAN;
    public static int UNDEFINED;
    public static int UNDERLINE;
    public static int ZAPFDINGBATS;
    private BaseFont _baseFont;
    private BaseColor _color;
    private int _family;
    private float _size;
    private int _style;
    public BaseFont BaseFont { get; }
    public float CalculatedSize { get; }
    public int CalculatedStyle { get; }
    public BaseColor Color { get; public set; }
    public int Family { get; }
    public string Familyname { get; }
    public float Size { get; public set; }
    public int Style { get; }
    public Font(Font other);
    public Font(int family, float size, int style, BaseColor color);
    public Font(BaseFont bf, float size, int style, BaseColor color);
    public Font(BaseFont bf, float size, int style);
    public Font(BaseFont bf, float size);
    public Font(BaseFont bf);
    public Font(int family, float size, int style);
    public Font(int family, float size);
    public Font(int family);
    public BaseFont get_BaseFont();
    public float get_CalculatedSize();
    public int get_CalculatedStyle();
    public virtual BaseColor get_Color();
    public virtual void set_Color(BaseColor value);
    public int get_Family();
    public virtual string get_Familyname();
    public virtual float get_Size();
    public virtual void set_Size(float value);
    public int get_Style();
    public virtual int CompareTo(object obj);
    public static int GetFamilyIndex(string family);
    public static int GetStyleValue(string style);
    public virtual Font Difference(Font font);
    public BaseFont GetCalculatedBaseFont(bool specialEncoding);
    public float GetCalculatedLeading(float linespacing);
    public bool IsBold();
    public bool IsItalic();
    public virtual bool IsStandardFont();
    public bool IsStrikethru();
    public bool IsUnderlined();
    public virtual void SetColor(int red, int green, int blue);
    public virtual void SetFamily(string family);
    public virtual void SetStyle(string style);
    public virtual void SetStyle(int style);
}
public static class iTextSharp.text.FontFactory : object {
    public static string COURIER;
    public static string COURIER_BOLD;
    public static string COURIER_BOLDOBLIQUE;
    public static string COURIER_OBLIQUE;
    public static string HELVETICA;
    public static string HELVETICA_BOLD;
    public static string HELVETICA_BOLDOBLIQUE;
    public static string HELVETICA_OBLIQUE;
    public static string SYMBOL;
    public static string TIMES;
    public static string TIMES_BOLD;
    public static string TIMES_BOLDITALIC;
    public static string TIMES_ITALIC;
    public static string TIMES_ROMAN;
    public static string ZAPFDINGBATS;
    [CompilerGeneratedAttribute]
private static bool <DefaultEmbedding>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <DefaultEncoding>k__BackingField;
    [CompilerGeneratedAttribute]
private static FontFactoryImp <FontImp>k__BackingField;
    public static bool DefaultEmbedding { get; }
    public static string DefaultEncoding { get; }
    public static FontFactoryImp FontImp { get; public set; }
    public static ICollection`1<string> RegisteredFamilies { get; }
    public static ICollection`1<string> RegisteredFonts { get; }
    private static FontFactory();
    [CompilerGeneratedAttribute]
public static bool get_DefaultEmbedding();
    [CompilerGeneratedAttribute]
public static string get_DefaultEncoding();
    [CompilerGeneratedAttribute]
public static void set_FontImp(FontFactoryImp value);
    [CompilerGeneratedAttribute]
public static FontFactoryImp get_FontImp();
    public static ICollection`1<string> get_RegisteredFamilies();
    public static ICollection`1<string> get_RegisteredFonts();
    public static bool Contains(string fontname);
    public static Font GetFont(string fontname, string encoding, bool embedded, float size, int style, BaseColor color);
    public static Font GetFont(string fontname, string encoding, bool embedded, float size, int style, BaseColor color, bool cached);
    public static Font GetFont(Properties attributes);
    public static Font GetFont(string fontname, string encoding, bool embedded, float size, int style);
    public static Font GetFont(string fontname, string encoding, bool embedded, float size);
    public static Font GetFont(string fontname, string encoding, bool embedded);
    public static Font GetFont(string fontname, string encoding, float size, int style, BaseColor color);
    public static Font GetFont(string fontname, string encoding, float size, int style);
    public static Font GetFont(string fontname, string encoding, float size);
    public static Font GetFont(string fontname, string encoding);
    public static Font GetFont(string fontname, float size, int style, BaseColor color);
    public static Font GetFont(string fontname, float size, BaseColor color);
    public static Font GetFont(string fontname, float size, int style);
    public static Font GetFont(string fontname, float size);
    public static Font GetFont(string fontname);
    public static bool IsRegistered(string fontname);
    public static void Register(Properties attributes);
    public static void Register(string path);
    public static void Register(string path, string alias);
    public static int RegisterDirectories();
    public static int RegisterDirectory(string dir);
    public static int RegisterDirectory(string dir, bool scanSubdirectories);
    public static void RegisterFamily(string familyName, string fullName, string path);
}
public class iTextSharp.text.FontFactoryImp : object {
    private static Lazy`1<FontFactoryImp> _instance;
    private static String[] _ttFamilyOrder;
    private static ConcurrentDictionary`2<string, List`1<string>> _fontFamilies;
    private static Properties _trueTypeFonts;
    private static object _syncLock;
    [CompilerGeneratedAttribute]
private bool <DefaultEmbedding>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DefaultEncoding>k__BackingField;
    public static FontFactoryImp Instance { get; }
    public bool DefaultEmbedding { get; public set; }
    public string DefaultEncoding { get; public set; }
    public static ICollection`1<string> RegisteredFamilies { get; }
    public static ICollection`1<string> RegisteredFonts { get; }
    private static FontFactoryImp();
    public static FontFactoryImp get_Instance();
    [CompilerGeneratedAttribute]
public void set_DefaultEmbedding(bool value);
    [CompilerGeneratedAttribute]
public bool get_DefaultEmbedding();
    [CompilerGeneratedAttribute]
public void set_DefaultEncoding(string value);
    [CompilerGeneratedAttribute]
public string get_DefaultEncoding();
    public static ICollection`1<string> get_RegisteredFamilies();
    public static ICollection`1<string> get_RegisteredFonts();
    public static Font GetFont(string fontname, string encoding, bool embedded, float size, int style, BaseColor color);
    public static Font GetFont(string fontname, string encoding, bool embedded, float size, int style, BaseColor color, bool cached);
    public Font GetFont(Properties attributes);
    public static Font GetFont(string fontname, string encoding, bool embedded, float size, int style);
    public static Font GetFont(string fontname, string encoding, bool embedded, float size);
    public static Font GetFont(string fontname, string encoding, bool embedded);
    public Font GetFont(string fontname, string encoding, float size, int style, BaseColor color);
    public Font GetFont(string fontname, string encoding, float size, int style);
    public Font GetFont(string fontname, string encoding, float size);
    public Font GetFont(string fontname, string encoding);
    public Font GetFont(string fontname, float size, int style, BaseColor color);
    public Font GetFont(string fontname, float size, BaseColor color);
    public Font GetFont(string fontname, float size, int style);
    public Font GetFont(string fontname, float size);
    public Font GetFont(string fontname);
    public static bool IsRegistered(string fontname);
    public void Register(Properties attributes);
    public void Register(string path);
    public void Register(string path, string alias);
    public int RegisterDirectories();
    public int RegisterDirectory(string dir);
    public int RegisterDirectory(string dir, bool scanSubdirectories);
    public static void RegisterFamily(string familyName, string fullName, string path);
}
public class iTextSharp.text.GreekList : List {
    public GreekList(int symbolIndent);
    public GreekList(bool greeklower, int symbolIndent);
    public virtual bool Add(IElement o);
    protected void SetGreekFont();
}
public class iTextSharp.text.Header : Meta {
    private StringBuilder _name;
    public string Name { get; }
    public Header(string name, string content);
    public virtual string get_Name();
}
public class iTextSharp.text.HeaderFooter : Rectangle {
    private bool _numbered;
    private Phrase _after;
    private int _alignment;
    private Phrase _before;
    private int _pageN;
    public Phrase After { get; public set; }
    public int Alignment { get; public set; }
    public Phrase Before { get; public set; }
    unknown int PageNumber {public set; }
    public Paragraph Paragraph { get; }
    public HeaderFooter(Phrase before, Phrase after);
    public HeaderFooter(Phrase before, bool numbered);
    public HeaderFooter(Properties attributes);
    public Phrase get_After();
    public void set_After(Phrase value);
    public void set_Alignment(int value);
    public int get_Alignment();
    public Phrase get_Before();
    public void set_Before(Phrase value);
    public void set_PageNumber(int value);
    public Paragraph get_Paragraph();
    public bool IsNumbered();
    public void SetAlignment(string alignment);
}
public static class iTextSharp.text.html.HtmlEncoder : object {
    private static String[] _htmlCode;
    private static HtmlEncoder();
    public static string Encode(string str);
    public static string Encode(BaseColor color);
    public static string GetAlignment(int alignment);
}
public class iTextSharp.text.html.HtmlParser : XmlParser {
    public static void Parse(IDocListener document, XmlDocument xDoc);
    public static void Parse(IDocListener document, string file);
    public static void Parse(IDocListener document, XmlReader reader);
    public static void Parse(IDocListener document, XmlDocument xDoc, XmlDocument xTagmap);
    public static void Parse(IDocListener document, string file, string tagmap);
    public static void Parse(IDocListener document, string file, TagMap tagmap);
    public static void Parse(IDocListener document, XmlReader reader, string tagmap);
    public static void Parse(IDocListener document, XmlReader reader, TagMap tagmap);
    public virtual void Go(IDocListener document, XmlDocument xDoc);
    public virtual void Go(IDocListener document, string file);
    public virtual void Go(IDocListener document, XmlReader reader);
    public virtual void Go(IDocListener document, XmlDocument xDoc, XmlDocument xTagmap);
    public virtual void Go(IDocListener document, XmlReader reader, string tagmap);
    public virtual void Go(IDocListener document, string file, string tagmap);
    public virtual void Go(IDocListener document, string file, TagMap tagmap);
    public virtual void Go(IDocListener document, XmlReader reader, TagMap tagmap);
}
public class iTextSharp.text.html.HtmlPeer : XmlPeer {
    public HtmlPeer(string name, string alias);
    public virtual void AddAlias(string name, string attributeAlias);
    public virtual Properties GetAttributes(INullValueDictionary`2<string, string> attrs);
}
public class iTextSharp.text.html.HtmlTagMap : TagMap {
    public static bool IsBody(string tag);
    public static bool IsHead(string tag);
    public static bool IsHtml(string tag);
    public static bool IsLink(string tag);
    public static bool IsMeta(string tag);
    public static bool IsSpecialTag(string tag);
    public static bool IsTitle(string tag);
}
public static class iTextSharp.text.html.HtmlTags : object {
    public static string ALIGN;
    public static string ALIGN_BASELINE;
    public static string ALIGN_BOTTOM;
    public static string ALIGN_CENTER;
    public static string ALIGN_JUSTIFIED;
    public static string ALIGN_LEFT;
    public static string ALIGN_MIDDLE;
    public static string ALIGN_RIGHT;
    public static string ALIGN_TOP;
    public static string ALT;
    public static string ANCHOR;
    public static string AUTHOR;
    public static string B;
    public static string BACKGROUNDCOLOR;
    public static string BODY;
    public static string BORDERCOLOR;
    public static string BORDERWIDTH;
    public static string BOTTOM;
    public static string BOTTOMMARGIN;
    public static string CELL;
    public static string CELLPADDING;
    public static string CELLSPACING;
    public static string CHUNK;
    public static string CODE;
    public static string COLOR;
    public static string COLSPAN;
    public static string COLUMNS;
    public static string CONTENT;
    public static string DEFAULT;
    public static string DIV;
    public static string EM;
    public static string FONT;
    public static string HEAD;
    public static string HEADERCELL;
    public static string HORIZONTALALIGN;
    public static string HORIZONTALRULE;
    public static string HTML;
    public static string I;
    public static string IMAGE;
    public static string JAVASCRIPT;
    public static string JAVASCRIPT_ONLOAD;
    public static string JAVASCRIPT_ONUNLOAD;
    public static string KEYWORDS;
    public static string LANGUAGE;
    public static string LEFT;
    public static string LEFTMARGIN;
    public static string LINK;
    public static string LISTITEM;
    public static string META;
    public static string NAME;
    public static string NEWLINE;
    public static string NOWRAP;
    public static string ORDEREDLIST;
    public static string PARAGRAPH;
    public static string PLAINHEIGHT;
    public static string PLAINWIDTH;
    public static string PRE;
    public static string REFERENCE;
    public static string REL;
    public static string RIGHT;
    public static string RIGHTMARGIN;
    public static string ROW;
    public static string ROWSPAN;
    public static string S;
    public static string SCRIPT;
    public static string SIZE;
    public static string SPAN;
    public static string STRONG;
    public static string STYLE;
    public static string STYLESHEET;
    public static string SUB;
    public static string SUBJECT;
    public static string SUP;
    public static string TABLE;
    public static string TEXT_CSS;
    public static string TITLE;
    public static string TOP;
    public static string TOPMARGIN;
    public static string TYPE;
    public static string U;
    public static string UNORDEREDLIST;
    public static string URL;
    public static string VAR;
    public static string VERTICALALIGN;
    public static string WIDTH;
    public static String[] H;
    private static HtmlTags();
}
public class iTextSharp.text.html.HtmlWriter : DocWriter {
    public static string NBSP;
    public static Byte[] Begincomment;
    public static Byte[] Endcomment;
    protected Stack`1<Font> Currentfont;
    protected HeaderFooter footer;
    protected HeaderFooter header;
    protected string Imagepath;
    protected Properties Markup;
    protected int PageN;
    protected Font Standardfont;
    protected HtmlWriter(Document doc, Stream os);
    private static HtmlWriter();
    public static HtmlWriter GetInstance(Document document, Stream os);
    public virtual bool Add(IElement element);
    public bool Add(string str);
    public virtual void Close();
    public bool IsOtherFont(Font font);
    public virtual bool NewPage();
    public virtual void Open();
    public void ResetImagepath();
    public void SetFooter(HeaderFooter footer);
    public void SetHeader(HeaderFooter header);
    public void SetImagepath(string imagepath);
    public void SetStandardFont(Font standardFont);
    protected void InitFooter();
    protected void InitHeader();
    protected void Write(IElement element, int indent);
    protected void Write(Font font, Properties styleAttributes);
    protected void WriteComment(string comment);
    protected void WriteCssProperty(string prop, string value);
    protected void WriteHeader(Meta meta);
    protected void WriteJavaScript(Header header);
    protected void WriteLink(Header header);
    protected void WriteSection(Section section, int indent);
}
public static class iTextSharp.text.html.Markup : object {
    public static string CSS_KEY_BGCOLOR;
    public static string CSS_KEY_BORDERCOLOR;
    public static string CSS_KEY_BORDERWIDTH;
    public static string CSS_KEY_BORDERWIDTHBOTTOM;
    public static string CSS_KEY_BORDERWIDTHLEFT;
    public static string CSS_KEY_BORDERWIDTHRIGHT;
    public static string CSS_KEY_BORDERWIDTHTOP;
    public static string CSS_KEY_COLOR;
    public static string CSS_KEY_DISPLAY;
    public static string CSS_KEY_FONTFAMILY;
    public static string CSS_KEY_FONTSIZE;
    public static string CSS_KEY_FONTSTYLE;
    public static string CSS_KEY_FONTWEIGHT;
    public static string CSS_KEY_LINEHEIGHT;
    public static string CSS_KEY_MARGIN;
    public static string CSS_KEY_MARGINBOTTOM;
    public static string CSS_KEY_MARGINLEFT;
    public static string CSS_KEY_MARGINRIGHT;
    public static string CSS_KEY_MARGINTOP;
    public static string CSS_KEY_PADDING;
    public static string CSS_KEY_PADDINGBOTTOM;
    public static string CSS_KEY_PADDINGLEFT;
    public static string CSS_KEY_PADDINGRIGHT;
    public static string CSS_KEY_PADDINGTOP;
    public static string CSS_KEY_PAGE_BREAK_AFTER;
    public static string CSS_KEY_PAGE_BREAK_BEFORE;
    public static string CSS_KEY_TEXTALIGN;
    public static string CSS_KEY_TEXTDECORATION;
    public static string CSS_KEY_VERTICALALIGN;
    public static string CSS_KEY_VISIBILITY;
    public static string CSS_VALUE_ALWAYS;
    public static string CSS_VALUE_BLOCK;
    public static string CSS_VALUE_BOLD;
    public static string CSS_VALUE_HIDDEN;
    public static string CSS_VALUE_INLINE;
    public static string CSS_VALUE_ITALIC;
    public static string CSS_VALUE_LINETHROUGH;
    public static string CSS_VALUE_LISTITEM;
    public static string CSS_VALUE_NONE;
    public static string CSS_VALUE_NORMAL;
    public static string CSS_VALUE_OBLIQUE;
    public static string CSS_VALUE_TABLE;
    public static string CSS_VALUE_TABLECELL;
    public static string CSS_VALUE_TABLEROW;
    public static string CSS_VALUE_TEXTALIGNCENTER;
    public static string CSS_VALUE_TEXTALIGNJUSTIFY;
    public static string CSS_VALUE_TEXTALIGNLEFT;
    public static string CSS_VALUE_TEXTALIGNRIGHT;
    public static string CSS_VALUE_UNDERLINE;
    public static float DEFAULT_FONT_SIZE;
    public static string HTML_ATTR_CSS_CLASS;
    public static string HTML_ATTR_CSS_ID;
    public static string HTML_ATTR_HEIGHT;
    public static string HTML_ATTR_HREF;
    public static string HTML_ATTR_REL;
    public static string HTML_ATTR_STYLE;
    public static string HTML_ATTR_STYLESHEET;
    public static string HTML_ATTR_TYPE;
    public static string HTML_ATTR_WIDTH;
    public static string HTML_TAG_BODY;
    public static string HTML_TAG_DIV;
    public static string HTML_TAG_LINK;
    public static string HTML_TAG_SPAN;
    public static string HTML_VALUE_CSS;
    public static string HTML_VALUE_JAVASCRIPT;
    public static string ITEXT_TAG;
    public static BaseColor DecodeColor(string s);
    public static Properties ParseAttributes(string str);
    public static float ParseLength(string str);
    public static float ParseLength(string str, float actualFontSize);
    public static string RemoveComment(string str, string startComment, string endComment);
}
[DefaultMemberAttribute("Item")]
public class iTextSharp.text.html.simpleparser.ChainedProperties : object {
    public static Int32[] FontSizes;
    public IList`1<TagAttributes> Chain;
    public string Item { get; }
    private static ChainedProperties();
    public string get_Item(string key);
    public void AddToChain(string key, INullValueDictionary`2<string, string> prop);
    public bool HasProperty(string key);
    public void RemoveChain(string key);
}
public class iTextSharp.text.html.simpleparser.FactoryProperties : object {
    public static INullValueDictionary`2<string, string> FollowTags;
    [CompilerGeneratedAttribute]
private FontFactoryImp <FontImp>k__BackingField;
    public FontFactoryImp FontImp { get; public set; }
    private static FactoryProperties();
    [CompilerGeneratedAttribute]
public FontFactoryImp get_FontImp();
    [CompilerGeneratedAttribute]
public void set_FontImp(FontFactoryImp value);
    public static ListItem CreateListItem(ChainedProperties props);
    public static void CreateParagraph(Paragraph p, ChainedProperties props);
    public static Paragraph CreateParagraph(ChainedProperties props);
    public static IHyphenationEvent GetHyphenation(ChainedProperties props);
    public static IHyphenationEvent GetHyphenation(INullValueDictionary`2<string, string> props);
    public static IHyphenationEvent GetHyphenation(string s);
    public static void InsertStyle(INullValueDictionary`2<string, string> h);
    public static void InsertStyle(INullValueDictionary`2<string, string> h, ChainedProperties cprops);
    public static Chunk CreateChunk(string text, ChainedProperties props);
    public static Font GetFont(ChainedProperties props);
    private static void setParagraphLeading(Paragraph p, string leading);
}
public class iTextSharp.text.html.simpleparser.HtmlWorker : object {
    public static string tagsSupportedString;
    public static INullValueDictionary`2<string, string> TagsSupported;
    private ChainedProperties _cprops;
    private FactoryProperties _factoryProperties;
    private Stack`1<IElement> _stack;
    private Stack`1<Boolean[]> _tableState;
    private Paragraph _currentParagraph;
    private INullValueDictionary`2<string, object> _interfaceProps;
    private bool _isPre;
    private bool _pendingLi;
    private bool _pendingTd;
    private bool _pendingTr;
    private bool _skipText;
    protected IDocListener Document;
    protected List`1<IElement> ObjectList;
    [CompilerGeneratedAttribute]
private StyleSheet <Style>k__BackingField;
    public INullValueDictionary`2<string, object> InterfaceProps { get; public set; }
    public StyleSheet Style { get; public set; }
    unknown HeaderFooter Footer {public set; }
    unknown HeaderFooter Header {public set; }
    unknown int PageCount {public set; }
    private static HtmlWorker();
    public HtmlWorker(IDocListener document);
    public void set_InterfaceProps(INullValueDictionary`2<string, object> value);
    public INullValueDictionary`2<string, object> get_InterfaceProps();
    [CompilerGeneratedAttribute]
public void set_Style(StyleSheet value);
    [CompilerGeneratedAttribute]
public StyleSheet get_Style();
    public sealed virtual void set_Footer(HeaderFooter value);
    public sealed virtual void set_Header(HeaderFooter value);
    public sealed virtual void set_PageCount(int value);
    public sealed virtual bool Add(IElement element);
    public sealed virtual void Close();
    public sealed virtual bool NewPage();
    public sealed virtual void Open();
    public sealed virtual void ResetFooter();
    public sealed virtual void ResetHeader();
    public sealed virtual void ResetPageCount();
    public sealed virtual bool SetMarginMirroring(bool marginMirroring);
    public sealed virtual bool SetMarginMirroringTopBottom(bool marginMirroringTopBottom);
    public sealed virtual bool SetMargins(float marginLeft, float marginRight, float marginTop, float marginBottom);
    public sealed virtual bool SetPageSize(Rectangle pageSize);
    public sealed virtual void Dispose();
    public virtual void EndDocument();
    public virtual void EndElement(string tag);
    public virtual void StartDocument();
    public virtual void Text(string str);
    public virtual void StartElement(string tag, INullValueDictionary`2<string, string> h);
    public static List`1<IElement> ParseToList(TextReader reader, StyleSheet style);
    public static List`1<IElement> ParseToList(TextReader reader, StyleSheet style, INullValueDictionary`2<string, object> interfaceProps);
    public void Parse(TextReader reader);
}
public interface iTextSharp.text.html.simpleparser.IALink {
    public abstract virtual bool Process(Paragraph current, ChainedProperties cprops);
}
public interface iTextSharp.text.html.simpleparser.IImageProvider {
    public abstract virtual Image GetImage(string src, INullValueDictionary`2<string, string> h, ChainedProperties cprops, IDocListener doc);
}
public interface iTextSharp.text.html.simpleparser.IImg {
    public abstract virtual bool Process(Image img, INullValueDictionary`2<string, string> h, ChainedProperties cprops, IDocListener doc);
}
public class iTextSharp.text.html.simpleparser.IncCell : object {
    [CompilerGeneratedAttribute]
private PdfPCell <Cell>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<Chunk> <Chunks>k__BackingField;
    public PdfPCell Cell { get; }
    public IList`1<Chunk> Chunks { get; }
    public int Type { get; }
    public IncCell(string tag, ChainedProperties props);
    [CompilerGeneratedAttribute]
public PdfPCell get_Cell();
    [CompilerGeneratedAttribute]
public sealed virtual IList`1<Chunk> get_Chunks();
    public sealed virtual int get_Type();
    public sealed virtual bool IsContent();
    public sealed virtual bool IsNestable();
    public sealed virtual bool Process(IElementListener listener);
    public sealed virtual bool Add(IElement o);
}
public class iTextSharp.text.html.simpleparser.IncTable : object {
    private INullValueDictionary`2<string, string> _props;
    private List`1<PdfPCell> _cols;
    [CompilerGeneratedAttribute]
private IList`1<IList`1<PdfPCell>> <Rows>k__BackingField;
    public IList`1<IList`1<PdfPCell>> Rows { get; }
    public int Type { get; }
    public IList`1<Chunk> Chunks { get; }
    public IncTable(INullValueDictionary`2<string, string> props);
    [CompilerGeneratedAttribute]
public IList`1<IList`1<PdfPCell>> get_Rows();
    public virtual bool Process(IElementListener listener);
    public virtual int get_Type();
    public virtual bool IsContent();
    public virtual bool IsNestable();
    public virtual IList`1<Chunk> get_Chunks();
    public void AddCol(PdfPCell cell);
    public void AddCols(IEnumerable`1<PdfPCell> ncols);
    public PdfPTable BuildTable();
    public void EndRow();
}
public class iTextSharp.text.html.simpleparser.StyleSheet : object {
    [CompilerGeneratedAttribute]
private INullValueDictionary`2<string, INullValueDictionary`2<string, string>> <ClassMap>k__BackingField;
    [CompilerGeneratedAttribute]
private INullValueDictionary`2<string, INullValueDictionary`2<string, string>> <TagMap>k__BackingField;
    public INullValueDictionary`2<string, INullValueDictionary`2<string, string>> ClassMap { get; public set; }
    public INullValueDictionary`2<string, INullValueDictionary`2<string, string>> TagMap { get; public set; }
    [CompilerGeneratedAttribute]
public void set_ClassMap(INullValueDictionary`2<string, INullValueDictionary`2<string, string>> value);
    [CompilerGeneratedAttribute]
public INullValueDictionary`2<string, INullValueDictionary`2<string, string>> get_ClassMap();
    [CompilerGeneratedAttribute]
public void set_TagMap(INullValueDictionary`2<string, INullValueDictionary`2<string, string>> value);
    [CompilerGeneratedAttribute]
public INullValueDictionary`2<string, INullValueDictionary`2<string, string>> get_TagMap();
    public void ApplyStyle(string tag, INullValueDictionary`2<string, string> props);
    public void LoadStyle(string style, INullValueDictionary`2<string, string> props);
    public void LoadStyle(string style, string key, string value);
    public void LoadTagStyle(string tag, INullValueDictionary`2<string, string> props);
    public void LoadTagStyle(string tag, string key, string value);
}
public class iTextSharp.text.html.TextmyHtmlHandler : TextHandler {
    private Properties _bodyAttributes;
    private bool _tableBorder;
    public TextmyHtmlHandler(IDocListener document);
    public TextmyHtmlHandler(IDocListener document, BaseFont bf);
    public TextmyHtmlHandler(IDocListener document, HtmlTagMap htmlTags);
    public TextmyHtmlHandler(IDocListener document, NullValueDictionary`2<string, XmlPeer> htmlTags);
    public virtual void EndElement(string uri, string lname, string name);
    public virtual void StartElement(string uri, string lname, string name, INullValueDictionary`2<string, string> attrs);
}
public class iTextSharp.text.html.WebColors : NullValueDictionary`2<string, Int32[]> {
    public static WebColors Names;
    private static WebColors();
    public static BaseColor GetRgbColor(string name);
}
public interface iTextSharp.text.IDocListener {
    unknown HeaderFooter Footer {public set; }
    unknown HeaderFooter Header {public set; }
    unknown int PageCount {public set; }
    public abstract virtual void set_Footer(HeaderFooter value);
    public abstract virtual void set_Header(HeaderFooter value);
    public abstract virtual void set_PageCount(int value);
    public abstract virtual void Close();
    public abstract virtual bool NewPage();
    public abstract virtual void Open();
    public abstract virtual void ResetFooter();
    public abstract virtual void ResetHeader();
    public abstract virtual void ResetPageCount();
    public abstract virtual bool SetMarginMirroring(bool marginMirroring);
    public abstract virtual bool SetMarginMirroringTopBottom(bool marginMirroringTopBottom);
    public abstract virtual bool SetMargins(float marginLeft, float marginRight, float marginTop, float marginBottom);
    public abstract virtual bool SetPageSize(Rectangle pageSize);
}
public interface iTextSharp.text.IElement {
    public IList`1<Chunk> Chunks { get; }
    public int Type { get; }
    public abstract virtual IList`1<Chunk> get_Chunks();
    public abstract virtual int get_Type();
    public abstract virtual bool IsContent();
    public abstract virtual bool IsNestable();
    public abstract virtual bool Process(IElementListener listener);
    public abstract virtual string ToString();
}
public interface iTextSharp.text.IElementListener {
    public abstract virtual bool Add(IElement element);
}
public interface iTextSharp.text.ILargeElement {
    public bool ElementComplete { get; public set; }
    public abstract virtual bool get_ElementComplete();
    public abstract virtual void set_ElementComplete(bool value);
    public abstract virtual void FlushContent();
}
public abstract class iTextSharp.text.Image : Rectangle {
    public static int AX;
    public static int AY;
    public static int BX;
    public static int BY;
    public static int CX;
    public static int CY;
    public static int DEFAULT;
    public static int DX;
    public static int DY;
    public static int LEFT_ALIGN;
    public static int MIDDLE_ALIGN;
    public static int ORIGINAL_BMP;
    public static int ORIGINAL_GIF;
    public static int ORIGINAL_JBIG2;
    public static int ORIGINAL_JPEG;
    public static int ORIGINAL_JPEG2000;
    public static int ORIGINAL_NONE;
    public static int ORIGINAL_PNG;
    public static int ORIGINAL_TIFF;
    public static int ORIGINAL_WMF;
    public static int RIGHT_ALIGN;
    public static int TEXTWRAP;
    public static int UNDERLYING;
    private static object _serialId;
    private static object _mutex;
    private float _initialRotation;
    protected float absoluteX;
    protected float absoluteY;
    protected int alignment;
    protected string alt;
    protected Annotation annotation;
    protected int bpc;
    protected int colorspace;
    protected int compressionLevel;
    protected bool deflated;
    protected int dpiX;
    protected int dpiY;
    protected Image imageMask;
    protected float indentationLeft;
    protected float indentationRight;
    protected bool interpolation;
    protected bool Invert;
    protected IPdfOcg layer;
    protected bool Mask;
    protected long mySerialId;
    protected Byte[] originalData;
    protected int originalType;
    protected float plainHeight;
    protected float plainWidth;
    protected IccProfile Profile;
    protected Byte[] rawData;
    protected float RotationRadians;
    protected float scaledHeight;
    protected float scaledWidth;
    protected float spacingAfter;
    protected float spacingBefore;
    protected PdfTemplate[] Template;
    protected Int32[] transparency;
    protected int type;
    protected Uri url;
    [CompilerGeneratedAttribute]
private PdfDictionary <Additional>k__BackingField;
    [CompilerGeneratedAttribute]
private PdfIndirectReference <DirectReference>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Smask>k__BackingField;
    [CompilerGeneratedAttribute]
private float <WidthPercentage>k__BackingField;
    [CompilerGeneratedAttribute]
private float <XyRatio>k__BackingField;
    public float AbsoluteX { get; }
    public float AbsoluteY { get; }
    public PdfDictionary Additional { get; public set; }
    public int Alignment { get; public set; }
    public string Alt { get; public set; }
    public Annotation Annotation { get; public set; }
    public int Bpc { get; }
    public int Colorspace { get; }
    public int CompressionLevel { get; public set; }
    public bool Deflated { get; public set; }
    public PdfIndirectReference DirectReference { get; public set; }
    public int DpiX { get; }
    public int DpiY { get; }
    public Image ImageMask { get; public set; }
    public float IndentationLeft { get; public set; }
    public float IndentationRight { get; public set; }
    public float InitialRotation { get; public set; }
    public bool Interpolation { get; public set; }
    public bool Inverted { get; public set; }
    public IPdfOcg Layer { get; public set; }
    public Single[] Matrix { get; }
    public long MySerialId { get; }
    public Byte[] OriginalData { get; public set; }
    public int OriginalType { get; public set; }
    public float PlainHeight { get; }
    public float PlainWidth { get; }
    public Byte[] RawData { get; }
    unknown float Rotation {public set; }
    unknown float RotationDegrees {public set; }
    public float ScaledHeight { get; }
    public float ScaledWidth { get; }
    public bool Smask { get; public set; }
    public float SpacingAfter { get; public set; }
    public float SpacingBefore { get; public set; }
    public IccProfile TagIcc { get; public set; }
    public PdfTemplate TemplateData { get; public set; }
    public Int32[] Transparency { get; public set; }
    public int Type { get; }
    public Uri Url { get; public set; }
    public float WidthPercentage { get; public set; }
    public float XyRatio { get; public set; }
    protected Image(Uri url);
    protected Image(Image image);
    private static Image();
    public float get_AbsoluteX();
    public float get_AbsoluteY();
    [CompilerGeneratedAttribute]
public PdfDictionary get_Additional();
    [CompilerGeneratedAttribute]
public void set_Additional(PdfDictionary value);
    public int get_Alignment();
    public void set_Alignment(int value);
    public string get_Alt();
    public void set_Alt(string value);
    public Annotation get_Annotation();
    public void set_Annotation(Annotation value);
    public int get_Bpc();
    public int get_Colorspace();
    public void set_CompressionLevel(int value);
    public int get_CompressionLevel();
    public bool get_Deflated();
    public void set_Deflated(bool value);
    [CompilerGeneratedAttribute]
public void set_DirectReference(PdfIndirectReference value);
    [CompilerGeneratedAttribute]
public PdfIndirectReference get_DirectReference();
    public int get_DpiX();
    public int get_DpiY();
    public Image get_ImageMask();
    public void set_ImageMask(Image value);
    public float get_IndentationLeft();
    public void set_IndentationLeft(float value);
    public float get_IndentationRight();
    public void set_IndentationRight(float value);
    public float get_InitialRotation();
    public void set_InitialRotation(float value);
    public void set_Interpolation(bool value);
    public bool get_Interpolation();
    public void set_Inverted(bool value);
    public bool get_Inverted();
    public IPdfOcg get_Layer();
    public void set_Layer(IPdfOcg value);
    public Single[] get_Matrix();
    public long get_MySerialId();
    public Byte[] get_OriginalData();
    public void set_OriginalData(Byte[] value);
    public int get_OriginalType();
    public void set_OriginalType(int value);
    public float get_PlainHeight();
    public float get_PlainWidth();
    public Byte[] get_RawData();
    public void set_Rotation(float value);
    public void set_RotationDegrees(float value);
    public float get_ScaledHeight();
    public float get_ScaledWidth();
    [CompilerGeneratedAttribute]
public bool get_Smask();
    [CompilerGeneratedAttribute]
public void set_Smask(bool value);
    public float get_SpacingAfter();
    public void set_SpacingAfter(float value);
    public float get_SpacingBefore();
    public void set_SpacingBefore(float value);
    public IccProfile get_TagIcc();
    public void set_TagIcc(IccProfile value);
    public PdfTemplate get_TemplateData();
    public void set_TemplateData(PdfTemplate value);
    public Int32[] get_Transparency();
    public void set_Transparency(Int32[] value);
    public virtual int get_Type();
    public Uri get_Url();
    public void set_Url(Uri value);
    [CompilerGeneratedAttribute]
public float get_WidthPercentage();
    [CompilerGeneratedAttribute]
public void set_WidthPercentage(float value);
    [CompilerGeneratedAttribute]
public float get_XyRatio();
    [CompilerGeneratedAttribute]
public void set_XyRatio(float value);
    public static Image GetInstance(Image image);
    public static Image GetInstance(Uri url);
    private static Image GetBase64EncodedImage(string src);
    private static bool IsBase64EncodedImage(string src);
    public static Image GetInstance(Stream s);
    public static Image GetInstance(int width, int height, Byte[] data, Byte[] globals);
    public static Image GetInstance(Byte[] imgb);
    public static Image GetInstance(SKBitmap image, SKEncodedImageFormat format, int quality);
    public static Image GetInstance(SKBitmap image, BaseColor color, bool forceBw);
    public static Image GetInstance(SKBitmap image, BaseColor color);
    public static Image GetInstance(string filename);
    public static Image GetInstance(int width, int height, int components, int bpc, Byte[] data);
    public static Image GetInstance(PrIndirectReference iref);
    public static Image GetInstance(PdfTemplate template);
    public static Image GetInstance(int width, int height, bool reverseBits, int typeCcitt, int parameters, Byte[] data);
    public static Image GetInstance(int width, int height, bool reverseBits, int typeCcitt, int parameters, Byte[] data, Int32[] transparency);
    public static Image GetInstance(int width, int height, int components, int bpc, Byte[] data, Int32[] transparency);
    public float GetImageRotation();
    public bool HasAbsolutePosition();
    public bool HasAbsoluteX();
    public bool HasIccProfile();
    public bool IsImgRaw();
    public bool IsImgTemplate();
    public bool IsJpeg();
    public bool IsMask();
    public bool IsMaskCandidate();
    public virtual bool IsNestable();
    public void MakeMask();
    public void ScaleAbsolute(float newWidth, float newHeight);
    public void ScaleAbsoluteHeight(float newHeight);
    public void ScaleAbsoluteWidth(float newWidth);
    public void ScalePercent(float percent);
    public void ScalePercent(float percentX, float percentY);
    public void ScaleToFit(float fitWidth, float fitHeight);
    public void SetAbsolutePosition(float absoluteX, float absoluteY);
    public void SetDpi(int dpiX, int dpiY);
    public void SimplifyColorspace();
    protected static long GetSerialId();
    private static PdfObject simplifyColorspace(PdfArray obj);
}
public class iTextSharp.text.ImgCcitt : Image {
    public ImgCcitt(Image image);
    public ImgCcitt(int width, int height, bool reverseBits, int typeCcitt, int parameters, Byte[] data);
}
public class iTextSharp.text.ImgJbig2 : Image {
    private Byte[] _global;
    private Byte[] _globalHash;
    public Byte[] GlobalBytes { get; }
    public Byte[] GlobalHash { get; }
    public ImgJbig2(int width, int height, Byte[] data, Byte[] globals);
    public Byte[] get_GlobalBytes();
    public Byte[] get_GlobalHash();
}
public class iTextSharp.text.ImgRaw : Image {
    public ImgRaw(Image image);
    public ImgRaw(int width, int height, int components, int bpc, Byte[] data);
}
public class iTextSharp.text.ImgTemplate : Image {
    public ImgTemplate(Image image);
    public ImgTemplate(PdfTemplate template);
}
public class iTextSharp.text.ImgWmf : Image {
    public ImgWmf(Image image);
    public ImgWmf(Uri url);
    public ImgWmf(string filename);
    public ImgWmf(Byte[] img);
    public void ReadWmf(PdfTemplate template);
    private void processParameters();
}
public interface iTextSharp.text.IRtfElementInterface {
}
public interface iTextSharp.text.ISplitCharacter {
    public abstract virtual bool IsSplitCharacter(int start, int current, int end, Char[] cc, PdfChunk[] ck);
}
public interface iTextSharp.text.ITextElementArray {
    public abstract virtual bool Add(IElement o);
}
public class iTextSharp.text.Jpeg : Image {
    public static int M_APP0;
    public static int M_APP2;
    public static int M_APPE;
    public static int NOPARAM_MARKER;
    public static int NOT_A_MARKER;
    public static int UNSUPPORTED_MARKER;
    public static int VALID_MARKER;
    public static Byte[] JfifId;
    public static Int32[] NoparamMarkers;
    public static Int32[] UnsupportedMarkers;
    public static Int32[] ValidMarkers;
    private Byte[][] _icc;
    public Jpeg(Image image);
    public Jpeg(Uri uri);
    public Jpeg(Byte[] img);
    public Jpeg(Byte[] img, float width, float height);
    private static Jpeg();
    private static int getShort(Stream istr);
    private static int getShortInverted(Stream istr);
    private static int markerType(int marker);
    private void processParameters();
}
public class iTextSharp.text.Jpeg2000 : Image {
    public static int JP2_BPCC;
    public static int JP2_COLR;
    public static int JP2_DBTL;
    public static int JP2_FTYP;
    public static int JP2_IHDR;
    public static int JP2_JP;
    public static int JP2_JP2;
    public static int JP2_JP2C;
    public static int JP2_JP2H;
    public static int JP2_URL;
    public static int JPIP_JPIP;
    private int _boxLength;
    private int _boxType;
    private Stream _inp;
    public Jpeg2000(Image image);
    public Jpeg2000(Uri url);
    public Jpeg2000(Byte[] img);
    public Jpeg2000(Byte[] img, float width, float height);
    public void Jp2_read_boxhdr();
    private int Cio_read(int n);
    private void processParameters();
}
public class iTextSharp.text.List : object {
    public static bool ALPHABETICAL;
    public static bool LOWERCASE;
    public static bool NUMERICAL;
    public static bool ORDERED;
    public static bool UNORDERED;
    public static bool UPPERCASE;
    protected bool alignindent;
    protected bool autoindent;
    protected int first;
    protected float indentationLeft;
    protected float indentationRight;
    protected bool lettered;
    protected List`1<IElement> list;
    protected bool lowercase;
    protected bool numbered;
    protected string postSymbol;
    protected string preSymbol;
    protected Chunk symbol;
    protected float symbolIndent;
    public bool Alignindent { get; public set; }
    public bool Autoindent { get; public set; }
    public int First { get; public set; }
    public float IndentationLeft { get; public set; }
    public float IndentationRight { get; public set; }
    public IList`1<IElement> Items { get; }
    public bool Lettered { get; public set; }
    unknown Chunk ListSymbol {public set; }
    public bool Lowercase { get; public set; }
    public bool Numbered { get; public set; }
    public string PostSymbol { get; public set; }
    public string PreSymbol { get; public set; }
    public int Size { get; }
    public Chunk Symbol { get; public set; }
    public float SymbolIndent { get; public set; }
    public float TotalLeading { get; }
    public IList`1<Chunk> Chunks { get; }
    public int Type { get; }
    public List(float symbolIndent);
    public List(bool numbered);
    public List(bool numbered, bool lettered);
    public List(bool numbered, float symbolIndent);
    public List(bool numbered, bool lettered, float symbolIndent);
    public void set_Alignindent(bool value);
    public bool get_Alignindent();
    public void set_Autoindent(bool value);
    public bool get_Autoindent();
    public int get_First();
    public void set_First(int value);
    public float get_IndentationLeft();
    public void set_IndentationLeft(float value);
    public float get_IndentationRight();
    public void set_IndentationRight(float value);
    public IList`1<IElement> get_Items();
    public void set_Lettered(bool value);
    public bool get_Lettered();
    public void set_ListSymbol(Chunk value);
    public void set_Lowercase(bool value);
    public bool get_Lowercase();
    public void set_Numbered(bool value);
    public bool get_Numbered();
    public void set_PostSymbol(string value);
    public string get_PostSymbol();
    public void set_PreSymbol(string value);
    public string get_PreSymbol();
    public int get_Size();
    public Chunk get_Symbol();
    public void set_Symbol(Chunk value);
    public void set_SymbolIndent(float value);
    public float get_SymbolIndent();
    public float get_TotalLeading();
    public sealed virtual IList`1<Chunk> get_Chunks();
    public sealed virtual int get_Type();
    public virtual bool Add(IElement o);
    public sealed virtual bool IsContent();
    public sealed virtual bool IsNestable();
    public sealed virtual bool Process(IElementListener listener);
    public string GetPostSymbol();
    public virtual bool IsEmpty();
    public void NormalizeIndentation();
    public void SetListSymbol(string symbol);
}
public class iTextSharp.text.ListItem : Paragraph {
    private Chunk _symbol;
    [CompilerGeneratedAttribute]
private int <Type>k__BackingField;
    public Chunk ListSymbol { get; public set; }
    public int Type { get; }
    public ListItem(float leading);
    public ListItem(Chunk chunk);
    public ListItem(string str);
    public ListItem(string str, Font font);
    public ListItem(float leading, Chunk chunk);
    public ListItem(float leading, string str);
    public ListItem(float leading, string str, Font font);
    public ListItem(Phrase phrase);
    public Chunk get_ListSymbol();
    public void set_ListSymbol(Chunk value);
    [CompilerGeneratedAttribute]
public virtual int get_Type();
    public static bool IsTag(string tag);
    public void SetIndentationLeft(float indentation, bool autoindent);
}
public class iTextSharp.text.MarkedObject : object {
    protected internal IElement Element;
    protected internal Properties markupAttributes;
    public Properties MarkupAttributes { get; }
    public IList`1<Chunk> Chunks { get; }
    public int Type { get; }
    public MarkedObject(IElement element);
    public virtual Properties get_MarkupAttributes();
    public virtual IList`1<Chunk> get_Chunks();
    public virtual int get_Type();
    public sealed virtual bool IsContent();
    public sealed virtual bool IsNestable();
    public virtual bool Process(IElementListener listener);
    public virtual void SetMarkupAttribute(string key, string value);
}
public class iTextSharp.text.MarkedSection : MarkedObject {
    protected MarkedObject title;
    unknown bool BookmarkOpen {public set; }
    unknown string BookmarkTitle {public set; }
    unknown float Indentation {public set; }
    unknown float IndentationLeft {public set; }
    unknown float IndentationRight {public set; }
    unknown int NumberDepth {public set; }
    public MarkedObject Title { get; public set; }
    unknown bool TriggerNewPage {public set; }
    public MarkedSection(Section section);
    public void set_BookmarkOpen(bool value);
    public void set_BookmarkTitle(string value);
    public void set_Indentation(float value);
    public void set_IndentationLeft(float value);
    public void set_IndentationRight(float value);
    public void set_NumberDepth(int value);
    public void set_Title(MarkedObject value);
    public MarkedObject get_Title();
    public void set_TriggerNewPage(bool value);
    public void Add(int index, IElement o);
    public bool Add(IElement o);
    public bool AddAll(ICollection`1<IElement> collection);
    public MarkedSection AddSection(float indentation, int numberDepth);
    public MarkedSection AddSection(float indentation);
    public MarkedSection AddSection(int numberDepth);
    public MarkedSection AddSection();
    public void NewPage();
    public virtual bool Process(IElementListener listener);
}
public class iTextSharp.text.Meta : object {
    private StringBuilder _content;
    private int _type;
    public string Content { get; }
    public string Name { get; }
    public IList`1<Chunk> Chunks { get; }
    public int Type { get; }
    public Meta(int type, string content);
    public Meta(string tag, string content);
    public string get_Content();
    public virtual string get_Name();
    public sealed virtual IList`1<Chunk> get_Chunks();
    public sealed virtual int get_Type();
    public sealed virtual bool IsContent();
    public sealed virtual bool IsNestable();
    public sealed virtual bool Process(IElementListener listener);
    public static int GetType(string tag);
    public StringBuilder Append(string str);
}
public static class iTextSharp.text.PageSize : object {
    public static Rectangle _11X17;
    public static Rectangle A0;
    public static Rectangle A1;
    public static Rectangle A10;
    public static Rectangle A2;
    public static Rectangle A3;
    public static Rectangle A4;
    public static Rectangle A5;
    public static Rectangle A6;
    public static Rectangle A7;
    public static Rectangle A8;
    public static Rectangle A9;
    public static Rectangle ArchA;
    public static Rectangle ArchB;
    public static Rectangle ArchC;
    public static Rectangle ArchD;
    public static Rectangle ArchE;
    public static Rectangle B0;
    public static Rectangle B1;
    public static Rectangle B10;
    public static Rectangle B2;
    public static Rectangle B3;
    public static Rectangle B4;
    public static Rectangle B5;
    public static Rectangle B6;
    public static Rectangle B7;
    public static Rectangle B8;
    public static Rectangle B9;
    public static Rectangle CrownOctavo;
    public static Rectangle CrownQuarto;
    public static Rectangle DemyOctavo;
    public static Rectangle DemyQuarto;
    public static Rectangle Executive;
    public static Rectangle Flsa;
    public static Rectangle Flse;
    public static Rectangle Halfletter;
    public static Rectangle Id1;
    public static Rectangle Id2;
    public static Rectangle Id3;
    public static Rectangle LargeCrownOctavo;
    public static Rectangle LargeCrownQuarto;
    public static Rectangle Ledger;
    public static Rectangle Legal;
    public static Rectangle Letter;
    public static Rectangle Note;
    public static Rectangle PenguinLargePaperback;
    public static Rectangle PenguinSmallPaperback;
    public static Rectangle Postcard;
    public static Rectangle RoyalOctavo;
    public static Rectangle RoyalQuarto;
    public static Rectangle SmallPaperback;
    public static Rectangle Tabloid;
    private static PageSize();
    public static Rectangle GetRectangle(string name);
}
public class iTextSharp.text.Paragraph : Phrase {
    protected int alignment;
    protected float indentationLeft;
    protected float indentationRight;
    protected bool Keeptogether;
    protected float multipliedLeading;
    protected float spacingAfter;
    protected float spacingBefore;
    [CompilerGeneratedAttribute]
private float <ExtraParagraphSpace>k__BackingField;
    [CompilerGeneratedAttribute]
private float <FirstLineIndent>k__BackingField;
    public int Alignment { get; public set; }
    public float ExtraParagraphSpace { get; public set; }
    public float FirstLineIndent { get; public set; }
    public float IndentationLeft { get; public set; }
    public float IndentationRight { get; public set; }
    public bool KeepTogether { get; public set; }
    unknown float Leading {public set; }
    public float MultipliedLeading { get; public set; }
    public float SpacingAfter { get; public set; }
    public float SpacingBefore { get; public set; }
    public float TotalLeading { get; }
    public int Type { get; }
    public Paragraph(float leading);
    public Paragraph(Chunk chunk);
    public Paragraph(float leading, Chunk chunk);
    public Paragraph(string str);
    public Paragraph(string str, Font font);
    public Paragraph(float leading, string str);
    public Paragraph(float leading, string str, Font font);
    public Paragraph(Phrase phrase);
    public int get_Alignment();
    public void set_Alignment(int value);
    [CompilerGeneratedAttribute]
public float get_ExtraParagraphSpace();
    [CompilerGeneratedAttribute]
public void set_ExtraParagraphSpace(float value);
    [CompilerGeneratedAttribute]
public float get_FirstLineIndent();
    [CompilerGeneratedAttribute]
public void set_FirstLineIndent(float value);
    public float get_IndentationLeft();
    public void set_IndentationLeft(float value);
    public float get_IndentationRight();
    public void set_IndentationRight(float value);
    public bool get_KeepTogether();
    public void set_KeepTogether(bool value);
    public virtual void set_Leading(float value);
    public float get_MultipliedLeading();
    public void set_MultipliedLeading(float value);
    public float get_SpacingAfter();
    public void set_SpacingAfter(float value);
    public float get_SpacingBefore();
    public void set_SpacingBefore(float value);
    public float get_TotalLeading();
    public virtual int get_Type();
    public static bool IsTag(string tag);
    public virtual bool Add(IElement o);
    public void SetAlignment(string alignment);
    public void SetLeading(float fixedLeading, float multipliedLeading);
}
public class iTextSharp.text.pdf.AcroFields : object {
    public static int DA_COLOR;
    public static int DA_FONT;
    public static int DA_SIZE;
    public static int FIELD_TYPE_CHECKBOX;
    public static int FIELD_TYPE_COMBO;
    public static int FIELD_TYPE_LIST;
    public static int FIELD_TYPE_NONE;
    public static int FIELD_TYPE_PUSHBUTTON;
    public static int FIELD_TYPE_RADIOBUTTON;
    public static int FIELD_TYPE_SIGNATURE;
    public static int FIELD_TYPE_TEXT;
    private static PdfName[] _buttonRemove;
    private static INullValueDictionary`2<string, String[]> _stdFieldFontNames;
    private bool _append;
    private NullValueDictionary`2<int, BaseFont> _extensionFonts;
    private INullValueDictionary`2<string, BaseFont> _localFonts;
    internal PdfReader Reader;
    internal PdfWriter Writer;
    private float _extraMarginLeft;
    private float _extraMarginTop;
    private INullValueDictionary`2<string, TextField> _fieldCache;
    private bool _generateAppearances;
    private bool _lastWasString;
    private NullValueDictionary`2<string, Int32[]> _sigNames;
    private int _topFirst;
    private int _totalRevisions;
    internal INullValueDictionary`2<string, Item> fields;
    [CompilerGeneratedAttribute]
private IList`1<BaseFont> <SubstitutionFonts>k__BackingField;
    [CompilerGeneratedAttribute]
private XfaForm <Xfa>k__BackingField;
    public INullValueDictionary`2<string, TextField> FieldCache { get; public set; }
    public INullValueDictionary`2<string, Item> Fields { get; }
    public bool GenerateAppearances { get; public set; }
    public IList`1<BaseFont> SubstitutionFonts { get; public set; }
    public int TotalRevisions { get; }
    public XfaForm Xfa { get; }
    private static AcroFields();
    internal AcroFields(PdfReader reader, PdfWriter writer);
    public void set_FieldCache(INullValueDictionary`2<string, TextField> value);
    public INullValueDictionary`2<string, TextField> get_FieldCache();
    public INullValueDictionary`2<string, Item> get_Fields();
    public void set_GenerateAppearances(bool value);
    public bool get_GenerateAppearances();
    [CompilerGeneratedAttribute]
public void set_SubstitutionFonts(IList`1<BaseFont> value);
    [CompilerGeneratedAttribute]
public IList`1<BaseFont> get_SubstitutionFonts();
    public int get_TotalRevisions();
    [CompilerGeneratedAttribute]
public XfaForm get_Xfa();
    public static Object[] SplitDAelements(string da);
    public void AddSubstitutionFont(BaseFont font);
    public void DecodeGenericDictionary(PdfDictionary merged, BaseField tx);
    public void ExportAsFdf(FdfWriter writer);
    public Stream ExtractRevision(string field);
    public String[] GetAppearanceStates(string fieldName);
    public IList`1<string> GetBlankSignatureNames();
    public string GetField(string name);
    public Item GetFieldItem(string name);
    public Single[] GetFieldPositions(string name);
    public int GetFieldType(string fieldName);
    public String[] GetListOptionDisplay(string fieldName);
    public String[] GetListOptionExport(string fieldName);
    public String[] GetListSelection(string name);
    public PushbuttonField GetNewPushbuttonFromField(string field);
    public PushbuttonField GetNewPushbuttonFromField(string field, int order);
    public int GetRevision(string field);
    public PdfDictionary GetSignatureDictionary(string name);
    public IList`1<string> GetSignatureNames();
    public string GetTranslatedFieldName(string name);
    public void MergeXfaData(XmlNode n);
    public List`1<object> GetFieldAndPositions(string name);
    public bool RegenerateField(string name);
    public bool RemoveField(string name, int page);
    public bool RemoveField(string name);
    public bool RemoveFieldsFromPage(int page);
    public bool RenameField(string oldName, string newName);
    public bool ReplacePushbuttonField(string field, PdfFormField button);
    public bool ReplacePushbuttonField(string field, PdfFormField button, int order);
    public void SetExtraMargin(float extraMarginLeft, float extraMarginTop);
    public bool SetField(string name, string value);
    public bool SetField(string name, string value, string display);
    public bool SetFieldProperty(string field, string name, object value, Int32[] inst);
    public bool SetFieldProperty(string field, string name, int value, Int32[] inst);
    public void SetFields(FdfReader fdf);
    public void SetFields(XfdfReader xfdf);
    public bool SetListOption(string fieldName, String[] exportValues, String[] displayValues);
    public bool SetListSelection(string name, String[] value);
    public bool SignatureCoversWholeDocument(string name);
    public PdfPkcs7 VerifySignature(string name);
    internal void Fill();
    internal PdfAppearance GetAppearance(PdfDictionary merged, string text, string fieldName);
    internal static BaseColor GetMkColor(PdfArray ar);
    internal static bool IsInAp(PdfDictionary dic, PdfName check);
    private void findSignatureNames();
    private String[] getListOption(string fieldName, int idx);
    private void markUsed(PdfObject obj);
    private static int removeRefFromArray(PdfArray array, PdfObject refo);
    private void updateByteRange(PdfPkcs7 pkcs7, PdfDictionary v);
}
public static class iTextSharp.text.pdf.ArabicLigaturizer : object {
    public static int ar_composedtashkeel;
    public static int ar_lig;
    public static int ar_nothing;
    public static int ar_novowel;
    public static int DIGIT_TYPE_AN;
    public static int DIGIT_TYPE_AN_EXTENDED;
    public static int DIGIT_TYPE_MASK;
    public static int DIGITS_AN2EN;
    public static int DIGITS_EN2AN;
    public static int DIGITS_EN2AN_INIT_AL;
    public static int DIGITS_EN2AN_INIT_LR;
    public static int DIGITS_MASK;
    private static char Alef;
    private static char Alefhamza;
    private static char Alefhamzabelow;
    private static char Alefmadda;
    private static char Alefmaksura;
    private static char Damma;
    private static int DigitsReserved;
    private static char Farsiyeh;
    private static char Fatha;
    private static char Hamza;
    private static char Hamzaabove;
    private static char Hamzabelow;
    private static char Kasra;
    private static char Lam;
    private static char LamAlef;
    private static char LamAlefhamza;
    private static char LamAlefhamzabelow;
    private static char LamAlefmadda;
    private static char Madda;
    private static char Shadda;
    private static char Tatweel;
    private static char Waw;
    private static char Wawhamza;
    private static char Yeh;
    private static char Yehhamza;
    private static char Zwj;
    private static Char[][] _chartable;
    private static ArabicLigaturizer();
    internal static int Arabic_shape(Char[] src, int srcoffset, int srclength, Char[] dest, int destoffset, int destlength, int level);
    internal static void Doublelig(StringBuilder str, int level);
    internal static void ProcessNumbers(Char[] text, int offset, int length, int options);
    internal static void Shape(Char[] text, StringBuilder str, int level);
    internal static void ShapeToArabicDigitsWithContext(Char[] dest, int start, int length, char digitBase, bool lastStrongWasAl);
    private static char charshape(char s, int which);
    private static bool Connects_to_left(Charstruct a);
    private static void copycstostring(StringBuilder str, Charstruct s, int level);
    private static bool isVowel(char s);
    private static int ligature(char newchar, Charstruct oldchar);
    private static int shapecount(char s);
}
public class iTextSharp.text.pdf.BadPasswordException : IOException {
    public BadPasswordException(string message);
    public BadPasswordException(string message, Exception innerException);
}
public class iTextSharp.text.pdf.BadPdfFormatException : Exception {
    public BadPdfFormatException(string message);
    public BadPdfFormatException(string message, Exception innerException);
}
public abstract class iTextSharp.text.pdf.Barcode : object {
    public static int CODABAR;
    public static int CODE128;
    public static int CODE128_RAW;
    public static int CODE128_UCC;
    public static int EAN13;
    public static int EAN8;
    public static int PLANET;
    public static int POSTNET;
    public static int SUPP2;
    public static int SUPP5;
    public static int UPCA;
    public static int UPCE;
    protected string altText;
    protected float barHeight;
    protected float baseline;
    protected bool checksumText;
    protected string code;
    protected int codeType;
    protected bool extended;
    protected BaseFont font;
    protected bool generateChecksum;
    protected bool guardBars;
    protected float inkSpreading;
    protected float n;
    protected float size;
    protected bool startStopText;
    protected int textAlignment;
    protected float x;
    public string AltText { get; public set; }
    public Rectangle BarcodeSize { get; }
    public float BarHeight { get; public set; }
    public float Baseline { get; public set; }
    public bool ChecksumText { get; public set; }
    public string Code { get; public set; }
    public int CodeType { get; public set; }
    public bool Extended { get; public set; }
    public BaseFont Font { get; public set; }
    public bool GenerateChecksum { get; public set; }
    public bool GuardBars { get; public set; }
    public float InkSpreading { get; public set; }
    public float N { get; public set; }
    public float Size { get; public set; }
    public bool StartStopText { get; public set; }
    public int TextAlignment { get; public set; }
    public float X { get; public set; }
    public void set_AltText(string value);
    public string get_AltText();
    public abstract virtual Rectangle get_BarcodeSize();
    public float get_BarHeight();
    public void set_BarHeight(float value);
    public float get_Baseline();
    public void set_Baseline(float value);
    public void set_ChecksumText(bool value);
    public bool get_ChecksumText();
    public virtual string get_Code();
    public virtual void set_Code(string value);
    public int get_CodeType();
    public void set_CodeType(int value);
    public void set_Extended(bool value);
    public bool get_Extended();
    public BaseFont get_Font();
    public void set_Font(BaseFont value);
    public void set_GenerateChecksum(bool value);
    public bool get_GenerateChecksum();
    public void set_GuardBars(bool value);
    public bool get_GuardBars();
    public void set_InkSpreading(float value);
    public float get_InkSpreading();
    public float get_N();
    public void set_N(float value);
    public float get_Size();
    public void set_Size(float value);
    public void set_StartStopText(bool value);
    public bool get_StartStopText();
    public int get_TextAlignment();
    public void set_TextAlignment(int value);
    public float get_X();
    public void set_X(float value);
    public abstract virtual SKBitmap CreateDrawingImage(Color foreground, Color background);
    public Image CreateImageWithBarcode(PdfContentByte cb, BaseColor barColor, BaseColor textColor);
    public PdfTemplate CreateTemplateWithBarcode(PdfContentByte cb, BaseColor barColor, BaseColor textColor);
    public abstract virtual Rectangle PlaceBarcode(PdfContentByte cb, BaseColor barColor, BaseColor textColor);
}
public class iTextSharp.text.pdf.Barcode128 : Barcode {
    public static char CODE_A;
    public static char CODE_AB_TO_C;
    public static char CODE_AC_TO_B;
    public static char CODE_BC_TO_A;
    public static char CODE_C;
    public static char DEL;
    public static char FNC1;
    public static char FNC1_INDEX;
    public static char FNC2;
    public static char FNC3;
    public static char FNC4;
    public static char SHIFT;
    public static char START_A;
    public static char START_B;
    public static char START_C;
    public static char STARTA;
    public static char STARTB;
    public static char STARTC;
    private static NullValueDictionary`2<int, int> _ais;
    private static Byte[][] _bars;
    private static Byte[] _barsStop;
    public Rectangle BarcodeSize { get; }
    unknown string Code {public set; }
    private static Barcode128();
    public virtual Rectangle get_BarcodeSize();
    public virtual void set_Code(string value);
    public static Byte[] GetBarsCode128Raw(string text);
    public static string GetHumanReadableUccean(string code);
    public static string GetRawText(string text, bool ucc);
    public static string RemoveFnc1(string code);
    public virtual SKBitmap CreateDrawingImage(Color foreground, Color background);
    public virtual Rectangle PlaceBarcode(PdfContentByte cb, BaseColor barColor, BaseColor textColor);
    internal static string GetPackedRawDigits(string text, int textIndex, int numDigits);
    internal static bool IsNextDigits(string text, int textIndex, int numDigits);
}
public class iTextSharp.text.pdf.Barcode39 : Barcode {
    private static string Chars;
    private static string EXTENDED;
    private static Byte[][] _bars;
    public Rectangle BarcodeSize { get; }
    private static Barcode39();
    public virtual Rectangle get_BarcodeSize();
    public static Byte[] GetBarsCode39(string text);
    public static string GetCode39Ex(string text);
    public virtual SKBitmap CreateDrawingImage(Color foreground, Color background);
    public virtual Rectangle PlaceBarcode(PdfContentByte cb, BaseColor barColor, BaseColor textColor);
    internal static char GetChecksum(string text);
}
public class iTextSharp.text.pdf.BarcodeCodabar : Barcode {
    private static string Chars;
    private static int StartStopIdx;
    private static Byte[][] _bars;
    public Rectangle BarcodeSize { get; }
    private static BarcodeCodabar();
    public virtual Rectangle get_BarcodeSize();
    public static string CalculateChecksum(string code);
    public static Byte[] GetBarsCodabar(string text);
    public virtual SKBitmap CreateDrawingImage(Color foreground, Color background);
    public virtual Rectangle PlaceBarcode(PdfContentByte cb, BaseColor barColor, BaseColor textColor);
}
public class iTextSharp.text.pdf.BarcodeDatamatrix : object {
    public static int DM_ASCII;
    public static int DM_AUTO;
    public static int DM_B256;
    public static int DM_C40;
    public static int DM_EDIFACT;
    public static int DM_ERROR_EXTENSION;
    public static int DM_ERROR_INVALID_SQUARE;
    public static int DM_ERROR_TEXT_TOO_BIG;
    public static int DM_EXTENSION;
    public static int DM_NO_ERROR;
    public static int DM_RAW;
    public static int DM_TEST;
    public static int DM_TEXT;
    public static int DM_X21;
    private static string X12;
    private static DmParams[] _dmSizes;
    private int _extOut;
    private Int16[] _place;
    [CompilerGeneratedAttribute]
private Byte[] <BitImage>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Height>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Options>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Width>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Ws>k__BackingField;
    public Byte[] BitImage { get; private set; }
    public int Height { get; public set; }
    public int Options { get; public set; }
    public int Width { get; public set; }
    public int Ws { get; public set; }
    private static BarcodeDatamatrix();
    [CompilerGeneratedAttribute]
public Byte[] get_BitImage();
    [CompilerGeneratedAttribute]
private void set_BitImage(Byte[] value);
    [CompilerGeneratedAttribute]
public int get_Height();
    [CompilerGeneratedAttribute]
public void set_Height(int value);
    [CompilerGeneratedAttribute]
public int get_Options();
    [CompilerGeneratedAttribute]
public void set_Options(int value);
    [CompilerGeneratedAttribute]
public int get_Width();
    [CompilerGeneratedAttribute]
public void set_Width(int value);
    [CompilerGeneratedAttribute]
public int get_Ws();
    [CompilerGeneratedAttribute]
public void set_Ws(int value);
    public virtual SKBitmap CreateDrawingImage(Color foreground, Color background);
    public Image CreateImage();
    public int Generate(string text);
    public int Generate(Byte[] text, int textOffset, int textSize);
    private static int asciiEncodation(Byte[] text, int textOffset, int textLength, Byte[] data, int dataOffset, int dataLength);
    private static int b256Encodation(Byte[] text, int textOffset, int textLength, Byte[] data, int dataOffset, int dataLength);
    private static int c40OrTextEncodation(Byte[] text, int textOffset, int textLength, Byte[] data, int dataOffset, int dataLength, bool c40);
    private static int edifactEncodation(Byte[] text, int textOffset, int textLength, Byte[] data, int dataOffset, int dataLength);
    private static int getEncodation(Byte[] text, int textOffset, int textSize, Byte[] data, int dataOffset, int dataSize, int options, bool firstMatch);
    private static int getNumber(Byte[] text, int ptrIn, int n);
    private static bool isDigit(int c);
    private static void makePadding(Byte[] data, int position, int count);
    private static int x12Encodation(Byte[] text, int textOffset, int textLength, Byte[] data, int dataOffset, int dataLength);
    private void draw(Byte[] data, int dataSize, DmParams dm);
    private int processExtensions(Byte[] text, int textOffset, int textSize, Byte[] data);
    private void setBit(int x, int y, int xByte);
}
public class iTextSharp.text.pdf.BarcodeEan : Barcode {
    private static byte Even;
    private static byte Odd;
    private static int TotalbarsEan13;
    private static int TotalbarsEan8;
    private static int TotalbarsSupp2;
    private static int TotalbarsSupp5;
    private static int TotalbarsUpce;
    private static Byte[][] _bars;
    private static Int32[] _guardEan13;
    private static Int32[] _guardEan8;
    private static Int32[] _guardEmpty;
    private static Int32[] _guardUpca;
    private static Int32[] _guardUpce;
    private static Byte[][] _parity13;
    private static Byte[][] _parity2;
    private static Byte[][] _parity5;
    private static Byte[][] _paritye;
    private static Single[] _textposEan13;
    private static Single[] _textposEan8;
    public Rectangle BarcodeSize { get; }
    private static BarcodeEan();
    public virtual Rectangle get_BarcodeSize();
    public static int CalculateEanParity(string code);
    public static string ConvertUpcAtoUpce(string text);
    public static Byte[] GetBarsEan13(string barCode);
    public static Byte[] GetBarsEan8(string barCode);
    public static Byte[] GetBarsSupplemental2(string barCode);
    public static Byte[] GetBarsSupplemental5(string barCode);
    public static Byte[] GetBarsUpce(string barCode);
    public virtual SKBitmap CreateDrawingImage(Color foreground, Color background);
    public virtual Rectangle PlaceBarcode(PdfContentByte cb, BaseColor barColor, BaseColor textColor);
}
public class iTextSharp.text.pdf.BarcodeEansupp : Barcode {
    protected Barcode Ean;
    protected Barcode Supp;
    public Rectangle BarcodeSize { get; }
    public BarcodeEansupp(Barcode ean, Barcode supp);
    public virtual Rectangle get_BarcodeSize();
    public virtual SKBitmap CreateDrawingImage(Color foreground, Color background);
    public virtual Rectangle PlaceBarcode(PdfContentByte cb, BaseColor barColor, BaseColor textColor);
}
public class iTextSharp.text.pdf.BarcodeInter25 : Barcode {
    private static Byte[][] _bars;
    public Rectangle BarcodeSize { get; }
    private static BarcodeInter25();
    public virtual Rectangle get_BarcodeSize();
    public static Byte[] GetBarsInter25(string text);
    public static char GetChecksum(string text);
    public static string KeepNumbers(string text);
    public virtual SKBitmap CreateDrawingImage(Color foreground, Color background);
    public virtual Rectangle PlaceBarcode(PdfContentByte cb, BaseColor barColor, BaseColor textColor);
}
public class iTextSharp.text.pdf.BarcodePdf417 : object {
    public static int PDF417_AUTO_ERROR_LEVEL;
    public static int PDF417_FIXED_COLUMNS;
    public static int PDF417_FIXED_RECTANGLE;
    public static int PDF417_FIXED_ROWS;
    public static int PDF417_FORCE_BINARY;
    public static int PDF417_INVERT_BITMAP;
    public static int PDF417_USE_ASPECT_RATIO;
    public static int PDF417_USE_ERROR_LEVEL;
    public static int PDF417_USE_MACRO;
    public static int PDF417_USE_RAW_CODEWORDS;
    protected static int ABSOLUTE_MAX_TEXT_SIZE;
    protected static int AL;
    protected static int ALPHA;
    protected static int AS;
    protected static int BYTE_MODE;
    protected static int BYTE_MODE_6;
    protected static int BYTESHIFT;
    protected static int ISBYTE;
    protected static int LL;
    protected static int LOWER;
    protected static int MACRO_LAST_SEGMENT;
    protected static int MACRO_SEGMENT_ID;
    protected static int MAX_DATA_CODEWORDS;
    protected static int MIXED;
    protected static int ML;
    protected static int MOD;
    protected static int NUMERIC_MODE;
    protected static int PAL;
    protected static int PL;
    protected static int PS;
    protected static int PUNCTUATION;
    protected static int SPACE;
    protected static int START_CODE_SIZE;
    protected static int START_PATTERN;
    protected static int STOP_PATTERN;
    protected static int STOP_SIZE;
    protected static int TEXT_MODE;
    private static string MixedSet;
    private static string PunctuationSet;
    private static Int32[][] _clusters;
    private static Int32[][] _errorLevel;
    private Int32[] _codewords;
    private float _aspectRatio;
    private int _bitColumns;
    private int _codeColumns;
    private int _codeRows;
    private int _lenCodewords;
    private string _macroFileId;
    private int _macroIndex;
    private int _macroSegmentCount;
    private int _macroSegmentId;
    private int _options;
    private Byte[] _outBits;
    private Byte[] _text;
    private float _yHeight;
    protected int BitPtr;
    protected int CwPtr;
    protected SegmentList SegmentArrayList;
    [CompilerGeneratedAttribute]
private int <ErrorLevel>k__BackingField;
    public float AspectRatio { get; public set; }
    public int BitColumns { get; }
    public int CodeColumns { get; public set; }
    public int CodeRows { get; public set; }
    public Int32[] Codewords { get; }
    public int ErrorLevel { get; public set; }
    public int LenCodewords { get; public set; }
    unknown string MacroFileId {public set; }
    unknown int MacroSegmentCount {public set; }
    unknown int MacroSegmentId {public set; }
    public int Options { get; public set; }
    public Byte[] OutBits { get; }
    public Byte[] Text { get; public set; }
    public float YHeight { get; public set; }
    private static BarcodePdf417();
    public void set_AspectRatio(float value);
    public float get_AspectRatio();
    public int get_BitColumns();
    public void set_CodeColumns(int value);
    public int get_CodeColumns();
    public void set_CodeRows(int value);
    public int get_CodeRows();
    public Int32[] get_Codewords();
    [CompilerGeneratedAttribute]
public void set_ErrorLevel(int value);
    [CompilerGeneratedAttribute]
public int get_ErrorLevel();
    public void set_LenCodewords(int value);
    public int get_LenCodewords();
    public void set_MacroFileId(string value);
    public void set_MacroSegmentCount(int value);
    public void set_MacroSegmentId(int value);
    public void set_Options(int value);
    public int get_Options();
    public Byte[] get_OutBits();
    public void set_Text(Byte[] value);
    public Byte[] get_Text();
    public void set_YHeight(float value);
    public float get_YHeight();
    public virtual SKBitmap CreateDrawingImage(Color foreground, Color background);
    public Image GetImage();
    public void PaintCode();
    public void SetDefaultParameters();
    public void SetText(string s);
    internal void BreakString();
    internal void ByteCompaction(int start, int length);
    protected static int MaxPossibleErrorLevel(int remain);
    protected void Assemble();
    protected void BasicNumberCompaction(int start, int length);
    protected void ByteCompaction6(int start);
    protected void CalculateErrorCorrection(int dest);
    protected static bool CheckSegmentType(Segment segment, char type);
    protected void DumpList();
    protected int GetMaxSquare();
    protected static int GetSegmentLength(Segment segment);
    protected int GetTextTypeAndValue(int maxLength, int idx);
    protected void NumberCompaction(int start, int length);
    protected void OutCodeword(int codeword);
    protected void OutCodeword17(int codeword);
    protected void OutCodeword18(int codeword);
    protected void OutPaintCode();
    protected void OutStartPattern();
    protected void OutStopPattern();
    protected void TextCompaction(int start, int length);
    private static int getTextTypeAndValue(Byte[] input, int maxLength, int idx);
    private void append(int inp, int len);
    private void append(string s);
    private void basicNumberCompaction(Byte[] input, int start, int length);
    private void macroCodes();
    private void numberCompaction(Byte[] input, int start, int length);
    private void textCompaction(Byte[] input, int start, int length);
}
public class iTextSharp.text.pdf.BarcodePostnet : Barcode {
    private static Byte[][] _bars;
    public Rectangle BarcodeSize { get; }
    private static BarcodePostnet();
    public virtual Rectangle get_BarcodeSize();
    public static Byte[] GetBarsPostnet(string text);
    public virtual SKBitmap CreateDrawingImage(Color foreground, Color background);
    public virtual Rectangle PlaceBarcode(PdfContentByte cb, BaseColor barColor, BaseColor textColor);
}
public abstract class iTextSharp.text.pdf.BaseField : object {
    public static float BORDER_WIDTH_MEDIUM;
    public static float BORDER_WIDTH_THICK;
    public static float BORDER_WIDTH_THIN;
    public static int COMB;
    public static int DO_NOT_SCROLL;
    public static int DO_NOT_SPELL_CHECK;
    public static int EDIT;
    public static int FILE_SELECTION;
    public static int HIDDEN;
    public static int HIDDEN_BUT_PRINTABLE;
    public static int MULTILINE;
    public static int PASSWORD;
    public static int READ_ONLY;
    public static int REQUIRED;
    public static int VISIBLE;
    public static int VISIBLE_BUT_DOES_NOT_PRINT;
    private static NullValueDictionary`2<PdfName, int> _fieldKeys;
    protected int alignment;
    protected BaseColor backgroundColor;
    protected BaseColor borderColor;
    protected int borderStyle;
    protected float borderWidth;
    protected Rectangle box;
    protected string fieldName;
    protected BaseFont font;
    protected float fontSize;
    protected int maxCharacterLength;
    protected int options;
    protected int rotation;
    protected string text;
    protected BaseColor textColor;
    protected int visibility;
    protected PdfWriter writer;
    public int Alignment { get; public set; }
    public BaseColor BackgroundColor { get; public set; }
    public BaseColor BorderColor { get; public set; }
    public int BorderStyle { get; public set; }
    public float BorderWidth { get; public set; }
    public Rectangle Box { get; public set; }
    public string FieldName { get; public set; }
    public BaseFont Font { get; public set; }
    public float FontSize { get; public set; }
    public int MaxCharacterLength { get; public set; }
    public int Options { get; public set; }
    public int Rotation { get; public set; }
    public string Text { get; public set; }
    public BaseColor TextColor { get; public set; }
    public int Visibility { get; public set; }
    public PdfWriter Writer { get; public set; }
    protected BaseFont RealFont { get; }
    private static BaseField();
    protected BaseField(PdfWriter writer, Rectangle box, string fieldName);
    public void set_Alignment(int value);
    public int get_Alignment();
    public void set_BackgroundColor(BaseColor value);
    public BaseColor get_BackgroundColor();
    public void set_BorderColor(BaseColor value);
    public BaseColor get_BorderColor();
    public void set_BorderStyle(int value);
    public int get_BorderStyle();
    public void set_BorderWidth(float value);
    public float get_BorderWidth();
    public void set_Box(Rectangle value);
    public Rectangle get_Box();
    public void set_FieldName(string value);
    public string get_FieldName();
    public void set_Font(BaseFont value);
    public BaseFont get_Font();
    public void set_FontSize(float value);
    public float get_FontSize();
    public void set_MaxCharacterLength(int value);
    public int get_MaxCharacterLength();
    public void set_Options(int value);
    public int get_Options();
    public void set_Rotation(int value);
    public int get_Rotation();
    public void set_Text(string value);
    public string get_Text();
    public void set_TextColor(BaseColor value);
    public BaseColor get_TextColor();
    public void set_Visibility(int value);
    public int get_Visibility();
    public PdfWriter get_Writer();
    public void set_Writer(PdfWriter value);
    protected BaseFont get_RealFont();
    public static void MoveFields(PdfDictionary from, PdfDictionary to);
    public void SetRotationFromPage(Rectangle page);
    protected static IList`1<string> BreakLines(List`1<string> breaks, BaseFont font, float fontSize, float width);
    protected static IList`1<string> GetHardBreaks(string text);
    protected static void TrimRight(StringBuilder buf);
    protected PdfAppearance GetBorderAppearance();
    private void drawBottomFrame(PdfAppearance app);
    private void drawTopFrame(PdfAppearance app);
}
public abstract class iTextSharp.text.pdf.BaseFont : object {
    public static int ASCENT;
    public static int AWT_ASCENT;
    public static int AWT_DESCENT;
    public static int AWT_LEADING;
    public static int AWT_MAXADVANCE;
    public static int BBOXLLX;
    public static int BBOXLLY;
    public static int BBOXURX;
    public static int BBOXURY;
    public static bool CACHED;
    public static int CAPHEIGHT;
    public static char CID_NEWLINE;
    public static string COURIER;
    public static string COURIER_BOLD;
    public static string COURIER_BOLDOBLIQUE;
    public static string COURIER_OBLIQUE;
    public static string CP1250;
    public static string CP1252;
    public static string CP1257;
    public static int DESCENT;
    public static bool EMBEDDED;
    public static int FONT_TYPE_CJK;
    public static int FONT_TYPE_DOCUMENT;
    public static int FONT_TYPE_T1;
    public static int FONT_TYPE_T3;
    public static int FONT_TYPE_TT;
    public static int FONT_TYPE_TTUNI;
    public static string HELVETICA;
    public static string HELVETICA_BOLD;
    public static string HELVETICA_BOLDOBLIQUE;
    public static string HELVETICA_OBLIQUE;
    public static string IDENTITY_H;
    public static string IDENTITY_V;
    public static int ITALICANGLE;
    public static string MACROMAN;
    public static bool NOT_CACHED;
    public static bool NOT_EMBEDDED;
    public static string notdef;
    public static string RESOURCE_PATH;
    public static int STRIKETHROUGH_POSITION;
    public static int STRIKETHROUGH_THICKNESS;
    public static int SUBSCRIPT_OFFSET;
    public static int SUBSCRIPT_SIZE;
    public static int SUPERSCRIPT_OFFSET;
    public static int SUPERSCRIPT_SIZE;
    public static string SYMBOL;
    public static string TIMES_BOLD;
    public static string TIMES_BOLDITALIC;
    public static string TIMES_ITALIC;
    public static string TIMES_ROMAN;
    public static int UNDERLINE_POSITION;
    public static int UNDERLINE_THICKNESS;
    public static string WINANSI;
    public static string ZAPFDINGBATS;
    public static Int32[] CharRangeArabic;
    public static Int32[] CharRangeCyrillic;
    public static Int32[] CharRangeHebrew;
    public static Int32[] CharRangeLatin;
    protected internal static List`1<object> ResourceSearch;
    protected static INullValueDictionary`2<string, PdfName> BuiltinFonts14;
    protected static INullValueDictionary`2<string, BaseFont> FontCache;
    private static Random _random;
    protected Int32[][] CharBBoxes;
    protected int compressionLevel;
    protected String[] differences;
    protected bool directTextToByte;
    protected bool Embedded;
    protected string encoding;
    protected bool FastWinansi;
    protected bool FontSpecific;
    internal int fontType;
    protected bool forceWidthsOutput;
    protected NullValueDictionary`2<int, int> SpecialMap;
    protected bool subset;
    protected List`1<Int32[]> SubsetRanges;
    protected Char[] unicodeDifferences;
    protected Int32[] widths;
    public String[][] AllNameEntries { get; }
    public String[] CodePagesSupported { get; }
    public int CompressionLevel { get; public set; }
    public String[] Differences { get; }
    public bool DirectTextToByte { get; public set; }
    public string Encoding { get; }
    public String[][] FamilyFontName { get; }
    public int FontType { get; public set; }
    public bool ForceWidthsOutput { get; public set; }
    public String[][] FullFontName { get; }
    public string PostscriptFontName { get; public set; }
    public bool Subset { get; public set; }
    public Char[] UnicodeDifferences { get; }
    public Int32[] Widths { get; }
    private static BaseFont();
    public abstract virtual String[][] get_AllNameEntries();
    public virtual String[] get_CodePagesSupported();
    public void set_CompressionLevel(int value);
    public int get_CompressionLevel();
    public String[] get_Differences();
    public void set_DirectTextToByte(bool value);
    public bool get_DirectTextToByte();
    public string get_Encoding();
    public abstract virtual String[][] get_FamilyFontName();
    public int get_FontType();
    public void set_FontType(int value);
    public void set_ForceWidthsOutput(bool value);
    public bool get_ForceWidthsOutput();
    public abstract virtual String[][] get_FullFontName();
    public abstract virtual string get_PostscriptFontName();
    public abstract virtual void set_PostscriptFontName(string value);
    public void set_Subset(bool value);
    public bool get_Subset();
    public Char[] get_UnicodeDifferences();
    public Int32[] get_Widths();
    public static void AddToResourceSearch(object obj);
    public static BaseFont CreateFont();
    public static BaseFont CreateFont(string name, string encoding, bool embedded);
    public static BaseFont CreateFont(string name, string encoding, bool embedded, bool forceRead);
    public static BaseFont CreateFont(string name, string encoding, bool embedded, bool cached, Byte[] ttfAfm, Byte[] pfb);
    public static BaseFont CreateFont(string name, string encoding, bool embedded, bool cached, Byte[] ttfAfm, Byte[] pfb, bool noThrow);
    public static BaseFont CreateFont(string name, string encoding, bool embedded, bool cached, Byte[] ttfAfm, Byte[] pfb, bool noThrow, bool forceRead);
    public static BaseFont CreateFont(PrIndirectReference fontRef);
    public static String[] EnumerateTtcNames(string ttcFile);
    public static String[] EnumerateTtcNames(Byte[] ttcArray);
    public static Object[] GetAllFontNames(string name, string encoding, Byte[] ttfAfm);
    public static String[][] GetAllNameEntries(string name, string encoding, Byte[] ttfAfm);
    public static List`1<Object[]> GetDocumentFonts(PdfReader reader);
    public static List`1<Object[]> GetDocumentFonts(PdfReader reader, int page);
    public static String[][] GetFullFontName(string name, string encoding, Byte[] ttfAfm);
    public static Stream GetResourceStream(string key);
    public void AddSubsetRange(Int32[] range);
    public virtual bool CharExists(int c);
    public void CorrectArabicAdvance();
    public int GetAscent(string text);
    public float GetAscentPoint(string text, float fontSize);
    public virtual Int32[] GetCharBBox(int c);
    public virtual int GetCidCode(int c);
    public int GetDescent(string text);
    public float GetDescentPoint(string text, float fontSize);
    public abstract virtual float GetFontDescriptor(int key, float fontSize);
    public abstract virtual PdfStream GetFullFontStream();
    public abstract virtual int GetKerning(int char1, int char2);
    public virtual int GetUnicodeEquivalent(int c);
    public virtual int GetWidth(int char1);
    public virtual int GetWidth(string text);
    public float GetWidthPoint(string text, float fontSize);
    public float GetWidthPoint(int char1, float fontSize);
    public float GetWidthPointKerned(string text, float fontSize);
    public abstract virtual bool HasKernPairs();
    public bool IsEmbedded();
    public bool IsFontSpecific();
    public virtual bool SetCharAdvance(int c, int advance);
    public abstract virtual bool SetKerning(int char1, int char2, int kern);
    internal static string CreateSubsetPrefix();
    internal virtual Byte[] ConvertToBytes(string text);
    internal virtual Byte[] ConvertToBytes(int char1);
    internal abstract virtual int GetRawWidth(int c, string name);
    internal char GetUnicodeDifferences(int index);
    internal abstract virtual void WriteFont(PdfWriter writer, PdfIndirectReference piRef, Object[] oParams);
    protected static string GetBaseName(string name);
    protected static string NormalizeEncoding(string enc);
    protected void CreateEncoding();
    protected abstract virtual Int32[] GetRawCharBBox(int c, string name);
    private static void addFont(PrIndirectReference fontRef, NullValueDictionary`2<int, int> hits, List`1<Object[]> fonts);
    private static void recourseFonts(PdfDictionary page, NullValueDictionary`2<int, int> hits, List`1<Object[]> fonts, int level);
}
public class iTextSharp.text.pdf.BidiLine : object {
    private static int PieceSizeStart;
    protected static NullValueDictionary`2<int, int> MirrorChars;
    protected int ArabicOptions;
    protected List`1<PdfChunk> Chunks;
    protected int CurrentChar;
    protected PdfChunk[] DetailChunks;
    protected Int32[] IndexChars;
    protected int IndexChunk;
    protected int IndexChunkChar;
    protected Byte[] OrderLevels;
    protected int PieceSize;
    protected int RunDirection;
    protected bool ShortStore;
    protected int StoredCurrentChar;
    protected PdfChunk[] StoredDetailChunks;
    protected Int32[] StoredIndexChars;
    protected int StoredIndexChunk;
    protected int StoredIndexChunkChar;
    protected Byte[] StoredOrderLevels;
    protected int StoredRunDirection;
    protected Char[] StoredText;
    protected int StoredTotalTextLength;
    protected Char[] Text;
    protected int TotalTextLength;
    private static BidiLine();
    public BidiLine(BidiLine org);
    public static bool IsWs(char c);
    public void AddChunk(PdfChunk chunk);
    public void AddChunks(IList`1<PdfChunk> chunks);
    public void AddPiece(char c, PdfChunk chunk);
    public void ClearChunks();
    public IList`1<PdfChunk> CreateArrayOfPdfChunks(int startIdx, int endIdx);
    public IList`1<PdfChunk> CreateArrayOfPdfChunks(int startIdx, int endIdx, PdfChunk extraPdfChunk);
    public void DoArabicShapping();
    public void Flip(int start, int end);
    public bool GetParagraph(int runDirection);
    public float GetWidth(int startIdx, int lastIdx);
    public Int32[] GetWord(int startIdx, int idx);
    public bool IsEmpty();
    public void MirrorGlyphs();
    public PdfLine ProcessLine(float leftX, float width, int alignment, int runDirection, int arabicOptions);
    public void Reorder(int start, int end);
    public void Restore();
    public void Save();
    public int TrimLeft(int startIdx, int endIdx);
    public int TrimLeftEx(int startIdx, int endIdx);
    public int TrimRight(int startIdx, int endIdx);
    public int TrimRightEx(int startIdx, int endIdx);
}
public class iTextSharp.text.pdf.BidiOrder : object {
    public static sbyte AL;
    public static sbyte AN;
    public static sbyte B;
    public static sbyte BN;
    public static sbyte CS;
    public static sbyte EN;
    public static sbyte ES;
    public static sbyte ET;
    public static sbyte L;
    public static sbyte LRE;
    public static sbyte LRO;
    public static sbyte NSM;
    public static sbyte ON;
    public static sbyte PDF;
    public static sbyte R;
    public static sbyte RLE;
    public static sbyte RLO;
    public static sbyte S;
    public static sbyte TYPE_MAX;
    public static sbyte TYPE_MIN;
    public static sbyte WS;
    private static Char[] _baseTypes;
    private static SByte[] _rtypes;
    private SByte[] _initialTypes;
    private SByte[] _embeddings;
    private sbyte _paragraphEmbeddingLevel;
    private SByte[] _resultLevels;
    private SByte[] _resultTypes;
    private int _textLength;
    private static BidiOrder();
    public BidiOrder(SByte[] types);
    public BidiOrder(SByte[] types, sbyte paragraphEmbeddingLevel);
    public BidiOrder(Char[] text, int offset, int length, sbyte paragraphEmbeddingLevel);
    public static sbyte GetDirection(char c);
    public sbyte GetBaseLevel();
    public Byte[] GetLevels();
    public Byte[] GetLevels(Int32[] linebreaks);
    private static Int32[] computeMultilineReordering(SByte[] levels, Int32[] linebreaks);
    private static Int32[] computeReordering(SByte[] levels);
    private static bool isWhitespace(sbyte biditype);
    private static SByte[] processEmbeddings(SByte[] resultTypes, sbyte paragraphEmbeddingLevel);
    private static sbyte typeForLevel(int level);
    private static void validateLineBreaks(Int32[] linebreaks, int textLength);
    private static void validateParagraphEmbeddingLevel(sbyte paragraphEmbeddingLevel);
    private static void validateTypes(SByte[] types);
    private void determineExplicitEmbeddingLevels();
    private void determineParagraphEmbeddingLevel();
    private int findRunLimit(int index, int limit, SByte[] validSet);
    private int findRunStart(int index, SByte[] validSet);
    private int reinsertExplicitCodes(int textLength);
    private int removeExplicitCodes();
    private void resolveImplicitLevels(int start, int limit, sbyte level, sbyte sor, sbyte eor);
    private void resolveNeutralTypes(int start, int limit, sbyte level, sbyte sor, sbyte eor);
    private void resolveWeakTypes(int start, int limit, sbyte level, sbyte sor, sbyte eor);
    private void runAlgorithm();
    private void setLevels(int start, int limit, sbyte newLevel);
    private void setTypes(int start, int limit, sbyte newType);
}
public class iTextSharp.text.pdf.ByteBuffer : Stream {
    public static byte ZERO;
    public static bool HighPrecision;
    private static Byte[] _bytes;
    private static Char[] _chars;
    private static Byte[][] _byteCache;
    private static int _byteCacheSize;
    protected Byte[] Buf;
    protected int Count;
    public Byte[] Buffer { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public int Size { get; public set; }
    private static ByteBuffer();
    public ByteBuffer(int size);
    public Byte[] get_Buffer();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public int get_Size();
    public void set_Size(int value);
    public static void FillCache(int decimals);
    public static string FormatDouble(double d);
    public static string FormatDouble(double d, ByteBuffer buf);
    public static void SetCacheSize(int size);
    public ByteBuffer Append(Byte[] b, int off, int len);
    public ByteBuffer Append(Byte[] b);
    public ByteBuffer Append(string str);
    public ByteBuffer Append(char c);
    public ByteBuffer Append(ByteBuffer buf);
    public ByteBuffer Append(int i);
    public ByteBuffer Append(byte b);
    public ByteBuffer Append(float i);
    public ByteBuffer Append(double d);
    public ByteBuffer Append_i(int b);
    public ByteBuffer AppendHex(byte b);
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public void Reset();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public Byte[] ToByteArray();
    public virtual string ToString();
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte value);
    public void WriteTo(Stream str);
    private static Byte[] convertToBytes(int i);
    private Char[] convertToChar(Byte[] buf);
}
public class iTextSharp.text.pdf.CffFont : object {
    internal static String[] OperatorNames;
    internal static String[] StandardStrings;
    private int _offSize;
    protected int ArgCount;
    protected Object[] Args;
    protected RandomAccessFileOrArray Buf;
    protected Font[] Fonts;
    protected int GsubrIndexOffset;
    protected Int32[] GsubrOffsets;
    protected string Key;
    protected int NameIndexOffset;
    protected Int32[] NameOffsets;
    internal int NextIndexOffset;
    protected int StringIndexOffset;
    protected Int32[] StringOffsets;
    protected int TopdictIndexOffset;
    protected Int32[] TopdictOffsets;
    public CffFont(RandomAccessFileOrArray inputbuffer);
    private static CffFont();
    public bool Exists(string fontName);
    public Byte[] GetCid(string fontName);
    public String[] GetNames();
    public string GetString(char sid);
    public bool IsCid(string fontName);
    internal char GetCard16();
    internal char GetCard8();
    internal Int32[] GetIndex(int nextIndexOffset);
    internal int GetInt();
    internal int GetOffset(int offSize);
    internal int GetPosition();
    internal short GetShort();
    internal void ReadEncoding(int nextIndexOffset);
    internal void Seek(int offset);
    protected void GetDictItem();
    protected virtual RangeItem GetEntireIndexRange(int indexOffset);
}
public class iTextSharp.text.pdf.CffFontSubset : CffFont {
    internal static byte ENDCHAR_OP;
    internal static byte RETURN_OP;
    internal static String[] SubrsEscapeFuncs;
    internal static String[] SubrsFunctions;
    internal INullValueDictionary`2<int, object> FdArrayUsed;
    internal int GBias;
    internal List`1<int> GlyphsInList;
    internal INullValueDictionary`2<int, Int32[]> GlyphsUsed;
    internal INullValueDictionary`2<int, Int32[]> HGSubrsUsed;
    internal INullValueDictionary`2[] HSubrsUsed;
    internal INullValueDictionary`2<int, Int32[]> HSubrsUsedNonCid;
    internal List`1<int> LGSubrsUsed;
    internal List`1[] LSubrsUsed;
    internal List`1<int> LSubrsUsedNonCid;
    internal Byte[] NewCharStringsIndex;
    internal Byte[] NewGSubrsIndex;
    internal Byte[][] NewLSubrsIndex;
    internal Byte[] NewSubrsIndexNonCid;
    internal int NumOfHints;
    internal List`1<Item> OutputList;
    public CffFontSubset(RandomAccessFileOrArray rf, INullValueDictionary`2<int, Int32[]> glyphsUsed);
    private static CffFontSubset();
    public Byte[] Process(string fontName);
    internal int CalcSubrOffsetSize(int offset, int size);
    internal int CountCharset(int offset, int numofGlyphs);
    internal void CreateNonCidPrivate(int font, OffsetItem subr);
    internal void CreateNonCidSubrs(int font, IndexBaseItem privateBase, OffsetItem subrs);
    internal void ReconstructPrivateDict(int font, OffsetItem[] fdPrivate, IndexBaseItem[] fdPrivateBase, OffsetItem[] fdSubrs);
    internal void ReconstructPrivateSubrs(int font, IndexBaseItem[] fdPrivateBase, OffsetItem[] fdSubrs);
    protected static Byte[] AssembleIndex(Int32[] newOffsets, Byte[] newObjects);
    protected void BuildFdArrayUsed(int font);
    protected void BuildFdSubrsOffsets(int font, int fd);
    protected void BuildGSubrsUsed(int font);
    protected void BuildIndexHeader(int count, int offsize, int first);
    protected void BuildNewCharString(int fontIndex);
    protected Byte[] BuildNewFile(int font);
    protected Byte[] BuildNewIndex(Int32[] offsets, INullValueDictionary`2<int, Int32[]> used, byte operatorForUnusedEntries);
    protected void BuildNewLgSubrs(int font);
    protected void BuildSubrUsed(int font, int fd, int subrOffset, Int32[] subrsOffsets, INullValueDictionary`2<int, Int32[]> hSubr, IList`1<int> lSubr);
    protected int CalcBias(int offset, int font);
    protected int CalcHints(int begin, int end, int lBias, int gBias, Int32[] lSubrsOffsets);
    protected void CopyHeader();
    protected int CountEntireIndexRange(int indexOffset);
    protected void CreateCharset(OffsetItem charsetRef, int nglyphs);
    protected void CreateFdArray(OffsetItem fdarrayRef, OffsetItem privateRef, int font);
    protected void CreateFdSelect(OffsetItem fdselectRef, int nglyphs);
    protected void CreateKeys(OffsetItem fdarrayRef, OffsetItem fdselectRef, OffsetItem charsetRef, OffsetItem charstringsRef);
    protected void CreateNewStringIndex(int font);
    protected void EmptyStack();
    protected void HandelStack();
    protected void PopStack();
    protected void PushStack();
    protected void ReadASubr(int begin, int end, int gBias, int lBias, INullValueDictionary`2<int, Int32[]> hSubr, IList`1<int> lSubr, Int32[] lSubrsOffsets);
    protected void ReadCommand();
    protected void ReadFdArray(int font);
    protected void ReadFdSelect(int font);
    protected int StackOpp();
    private int countRange(int numofGlyphs, int type);
    private void reconstruct(int font);
    private void reconstructFdArray(int font, OffsetItem[] fdPrivate);
}
internal class iTextSharp.text.pdf.CjkFont : BaseFont {
    internal static string CJK_ENCODING;
    private static int Bracket;
    private static int First;
    private static int Serial;
    private static int V1Y;
    internal static INullValueDictionary`2<string, Char[]> AllCMaps;
    internal static INullValueDictionary`2<string, INullValueDictionary`2<string, object>> AllFonts;
    internal static Properties CjkEncodings;
    internal static Properties CjkFonts;
    private static bool _propertiesLoaded;
    private bool _cidDirect;
    private string _cMap;
    private INullValueDictionary`2<string, object> _fontDesc;
    private NullValueDictionary`2<int, int> _hMetrics;
    private string _style;
    private Char[] _translationMap;
    private bool _vertical;
    private NullValueDictionary`2<int, int> _vMetrics;
    private string _fontName;
    public String[][] AllNameEntries { get; }
    public String[][] FamilyFontName { get; }
    public String[][] FullFontName { get; }
    public string PostscriptFontName { get; public set; }
    internal CjkFont(string fontName, string enc, bool emb);
    private static CjkFont();
    public virtual String[][] get_AllNameEntries();
    public virtual String[][] get_FamilyFontName();
    public virtual String[][] get_FullFontName();
    public virtual string get_PostscriptFontName();
    public virtual void set_PostscriptFontName(string value);
    public static bool IsCjkFont(string fontName, string enc);
    public virtual bool CharExists(int c);
    public virtual Int32[] GetCharBBox(int c);
    public virtual int GetCidCode(int c);
    public virtual float GetFontDescriptor(int key, float fontSize);
    public virtual PdfStream GetFullFontStream();
    public virtual int GetKerning(int char1, int char2);
    public virtual int GetUnicodeEquivalent(int c);
    public virtual int GetWidth(int char1);
    public virtual int GetWidth(string text);
    public virtual bool HasKernPairs();
    public virtual bool SetCharAdvance(int c, int advance);
    public virtual bool SetKerning(int char1, int char2, int kern);
    internal static string ConvertToHcidMetrics(IList`1<int> keys, NullValueDictionary`2<int, int> h);
    internal static string ConvertToVcidMetrics(IList`1<int> keys, NullValueDictionary`2<int, int> v, NullValueDictionary`2<int, int> h);
    internal static NullValueDictionary`2<int, int> CreateMetric(string s);
    internal static Char[] ReadCMap(string name);
    internal static INullValueDictionary`2<string, object> ReadFontProperties(string name);
    internal virtual int GetRawWidth(int c, string name);
    internal virtual void WriteFont(PdfWriter writer, PdfIndirectReference piref, Object[] parms);
    protected virtual Int32[] GetRawCharBBox(int c, string name);
    private static void loadProperties();
    private float getBBox(int idx);
    private PdfDictionary getCidFont(PdfIndirectReference fontDescriptor, NullValueDictionary`2<int, int> cjkTag);
    private float getDescNumber(string name);
    private PdfDictionary getFontBaseType(PdfIndirectReference cidFont);
    private PdfDictionary getFontDescriptor();
}
public class iTextSharp.text.pdf.CmykColor : ExtendedColor {
    [CompilerGeneratedAttribute]
private float <Black>k__BackingField;
    [CompilerGeneratedAttribute]
private float <Cyan>k__BackingField;
    [CompilerGeneratedAttribute]
private float <Magenta>k__BackingField;
    [CompilerGeneratedAttribute]
private float <Yellow>k__BackingField;
    public float Black { get; }
    public float Cyan { get; }
    public float Magenta { get; }
    public float Yellow { get; }
    public CmykColor(int intCyan, int intMagenta, int intYellow, int intBlack);
    public CmykColor(float floatCyan, float floatMagenta, float floatYellow, float floatBlack);
    [CompilerGeneratedAttribute]
public float get_Black();
    [CompilerGeneratedAttribute]
public float get_Cyan();
    [CompilerGeneratedAttribute]
public float get_Magenta();
    [CompilerGeneratedAttribute]
public float get_Yellow();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class iTextSharp.text.pdf.codec.BmpImage : object {
    private static int BiBitfields;
    private static int BiRgb;
    private static int BiRle4;
    private static int BiRle8;
    private static int LcsCalibratedRgb;
    private static int LcsCmyk;
    private static int Lcs_SRgb;
    private static int Version21Bit;
    private static int Version224Bit;
    private static int Version24Bit;
    private static int Version28Bit;
    private static int Version31Bit;
    private static int Version324Bit;
    private static int Version34Bit;
    private static int Version38Bit;
    private static int Version3Nt16Bit;
    private static int Version3Nt32Bit;
    private static int Version41Bit;
    private static int Version416Bit;
    private static int Version424Bit;
    private static int Version432Bit;
    private static int Version44Bit;
    private static int Version48Bit;
    private long _bitmapFileSize;
    private long _bitmapOffset;
    private int _bitsPerPixel;
    private long _compression;
    private int _height;
    private long _imageSize;
    private int _imageType;
    private Stream _inputStream;
    private bool _isBottomUp;
    private int _numBands;
    private Byte[] _palette;
    private int _redMask;
    private int _greenMask;
    private int _blueMask;
    private int _alphaMask;
    private int _width;
    private long _xPelsPerMeter;
    private long _yPelsPerMeter;
    public INullValueDictionary`2<string, object> Properties;
    internal BmpImage(Stream isp, bool noHeader, int size);
    public static Image GetImage(Uri url);
    public static Image GetImage(Stream isp);
    public static Image GetImage(Stream isp, bool noHeader, int size);
    public static Image GetImage(string file);
    public static Image GetImage(Byte[] data);
    protected void Process(Stream stream, bool noHeader);
    private Byte[] decodeRle(bool is8, Byte[] values);
    private static int findMask(int mask);
    private static int findShift(int mask);
    private Image getImage();
    private Byte[] getPalette(int group);
    private Image indexedModel(Byte[] bdata, int bpc, int paletteEntries);
    private ImgRaw read1632Bit(bool is32);
    private Image read1Bit(int paletteEntries);
    private void read24Bit(Byte[] bdata);
    private Image read4Bit(int paletteEntries);
    private Image read8Bit(int paletteEntries);
    private static long readDWord(Stream stream);
    private static int readInt(Stream stream);
    private static int readLong(Stream stream);
    private void readPalette(int sizeOfPalette);
    private Image readRle4();
    private Image readRle8();
    private static int readShort(Stream stream);
    private static int readUnsignedByte(Stream stream);
    private static long readUnsignedInt(Stream stream);
    private static int readUnsignedShort(Stream stream);
    private static int readWord(Stream stream);
}
public class iTextSharp.text.pdf.codec.Ccittg4Encoder : object {
    private static int Code;
    private static int Eol;
    private static int G3CodeEof;
    private static int G3CodeEol;
    private static int G3CodeIncomp;
    private static int G3CodeInvalid;
    private static int Length;
    private static int Runlen;
    private static Byte[] _oneruns;
    private static Byte[] _zeroruns;
    private Int32[] _horizcode;
    private Int32[] _msbmask;
    private ByteBuffer _outBuf;
    private Int32[] _passcode;
    private Byte[] _refline;
    private int _rowbytes;
    private int _rowpixels;
    private Int32[][] _tiffFaxBlackCodes;
    private Int32[][] _tiffFaxWhiteCodes;
    private Int32[][] _vcodes;
    private int _bit;
    private int _data;
    private Byte[] _dataBp;
    private int _offsetData;
    private int _sizeData;
    public Ccittg4Encoder(int width);
    private static Ccittg4Encoder();
    public static Byte[] Compress(Byte[] data, int width, int height);
    public Byte[] Close();
    public void Fax4Encode(Byte[] data, int offset, int size);
    public void Fax4Encode(Byte[] data, int height);
    private static int find0Span(Byte[] bp, int offset, int bs, int be);
    private static int find1Span(Byte[] bp, int offset, int bs, int be);
    private static int finddiff(Byte[] bp, int offset, int bs, int be, int color);
    private static int finddiff2(Byte[] bp, int offset, int bs, int be, int color);
    private void fax3Encode2DRow();
    private void fax4PostEncode();
    private int pixel(Byte[] data, int offset, int bit);
    private void putBits(int bits, int length);
    private void putcode(Int32[] table);
    private void putspan(int span, Int32[][] tab);
}
public class iTextSharp.text.pdf.codec.GifImage : object {
    protected static int MaxStackSize;
    protected int BgColor;
    protected int BgIndex;
    protected Byte[] Block;
    protected int BlockSize;
    protected int Delay;
    protected int Dispose;
    internal List`1<GifFrame> Frames;
    protected Byte[] FromData;
    protected Uri FromUrl;
    protected bool GctFlag;
    protected int Height;
    protected Stream Inp;
    protected bool Interlace;
    protected int Ix;
    protected int Iy;
    protected int Iw;
    protected int Ih;
    protected bool LctFlag;
    protected int LctSize;
    protected int MBpc;
    protected Byte[] MCurrTable;
    protected int MGbpc;
    protected Byte[] MGlobalTable;
    protected int MLineStride;
    protected Byte[] MLocalTable;
    protected Byte[] MOut;
    protected int PixelAspect;
    protected Byte[] Pixels;
    protected Byte[] PixelStack;
    protected Int16[] Prefix;
    protected Byte[] Suffix;
    protected int TransIndex;
    protected bool Transparency;
    protected int Width;
    public GifImage(Uri url);
    public GifImage(string file);
    public GifImage(Byte[] data);
    public GifImage(Stream isp);
    public int GetFrameCount();
    public Int32[] GetFramePosition(int frame);
    public Image GetImage(int frame);
    public Int32[] GetLogicalScreen();
    internal void Process(Stream isp);
    protected static int NewBpc(int bpc);
    protected bool DecodeImageData();
    protected int ReadBlock();
    protected Byte[] ReadColorTable(int bpc);
    protected void ReadContents();
    protected void ReadGraphicControlExt();
    protected void ReadHeader();
    protected void ReadImage();
    protected void ReadLsd();
    protected int ReadShort();
    protected void SetPixel(int x, int y, int v);
    protected void Skip();
    private void readFully(Byte[] b, int offset, int count);
}
public static class iTextSharp.text.pdf.codec.Jbig2Image : object {
    public static Byte[] GetGlobalSegment(RandomAccessFileOrArray ra);
    public static Image GetJbig2Image(RandomAccessFileOrArray ra, int page);
    public static int GetNumberOfPages(RandomAccessFileOrArray ra);
}
public class iTextSharp.text.pdf.codec.Jbig2SegmentReader : object {
    public static int END_OF_FILE;
    public static int END_OF_PAGE;
    public static int END_OF_STRIPE;
    public static int EXTENSION;
    public static int IMMEDIATE_GENERIC_REFINEMENT_REGION;
    public static int IMMEDIATE_GENERIC_REGION;
    public static int IMMEDIATE_HALFTONE_REGION;
    public static int IMMEDIATE_LOSSLESS_GENERIC_REFINEMENT_REGION;
    public static int IMMEDIATE_LOSSLESS_GENERIC_REGION;
    public static int IMMEDIATE_LOSSLESS_HALFTONE_REGION;
    public static int IMMEDIATE_LOSSLESS_TEXT_REGION;
    public static int IMMEDIATE_TEXT_REGION;
    public static int INTERMEDIATE_GENERIC_REFINEMENT_REGION;
    public static int INTERMEDIATE_GENERIC_REGION;
    public static int INTERMEDIATE_HALFTONE_REGION;
    public static int INTERMEDIATE_TEXT_REGION;
    public static int PAGE_INFORMATION;
    public static int PATTERN_DICTIONARY;
    public static int PROFILES;
    public static int SYMBOL_DICTIONARY;
    public static int TABLES;
    private OrderedTree _globals;
    private OrderedTree _pages;
    private RandomAccessFileOrArray _ra;
    private OrderedTree _segments;
    private int _numberOfPages;
    private bool _numberOfPagesKnown;
    private bool _read;
    private bool _sequential;
    public Jbig2SegmentReader(RandomAccessFileOrArray ra);
    public static Byte[] CopyByteArray(Byte[] b);
    public Byte[] GetGlobal(bool forEmbedding);
    public Jbig2Page GetPage(int page);
    public int GetPageHeight(int i);
    public int GetPageWidth(int i);
    public int NumberOfPages();
    public void Read();
    public virtual string ToString();
    private void readFileHeader();
    private Jbig2Segment readHeader();
    private void readSegment(Jbig2Segment s);
}
public class iTextSharp.text.pdf.codec.PngImage : object {
    public static string cHRM;
    public static string gAMA;
    public static string iCCP;
    public static string IDAT;
    public static string IEND;
    public static string IHDR;
    public static string pHYs;
    public static string PLTE;
    public static string sRGB;
    public static string tRNS;
    private static int PngFilterAverage;
    private static int PngFilterNone;
    private static int PngFilterPaeth;
    private static int PngFilterSub;
    private static int PngFilterUp;
    private static int Transfersize;
    public static Int32[] Pngid;
    private static PdfName[] _intents;
    private PdfDictionary _additional;
    private MemoryStream _idat;
    private Stream _isp;
    private int _bitDepth;
    private int _bytesPerPixel;
    private Byte[] _colorTable;
    private int _colorType;
    private int _compressionMethod;
    private ZInflaterInputStream _dataStream;
    private int _dpiX;
    private int _dpiY;
    private int _filterMethod;
    private float _gamma;
    private bool _genBwMask;
    private bool _hasChrm;
    private int _height;
    private IccProfile _iccProfile;
    private Byte[] _image;
    private int _inputBands;
    private PdfName _intent;
    private int _interlaceMethod;
    private bool _palShades;
    private Byte[] _smask;
    private Byte[] _trans;
    private int _transBlue;
    private int _transGreen;
    private int _transRedGray;
    private int _width;
    private float _xW;
    private float _yW;
    private float _xR;
    private float _yR;
    private float _xG;
    private float _yG;
    private float _xB;
    private float _yB;
    private float _xyRatio;
    private PngImage(Stream isp);
    private static PngImage();
    public static Image GetImage(Uri url);
    public static Image GetImage(Stream isp);
    public static Image GetImage(string file);
    public static Image GetImage(Byte[] data);
    public static int GetInt(Stream isp);
    public static string GetString(Stream isp);
    public static int GetWord(Stream isp);
    private static bool checkMarker(string s);
    private static void decodeAverageFilter(Byte[] curr, Byte[] prev, int count, int bpp);
    private static void decodePaethFilter(Byte[] curr, Byte[] prev, int count, int bpp);
    private static void decodeSubFilter(Byte[] curr, int count, int bpp);
    private static void decodeUpFilter(Byte[] curr, Byte[] prev, int count);
    private static int getPixel(Byte[] image, int x, int y, int bitDepth, int bytesPerRow);
    private static int paethPredictor(int a, int b, int c);
    private static void readFully(ZInflaterInputStream inp, Byte[] b, int offset, int count);
    private static void setPixel(Byte[] image, Int32[] data, int offset, int size, int x, int y, int bitDepth, int bytesPerRow);
    private void decodeIdat();
    private void decodePass(int xOffset, int yOffset, int xStep, int yStep, int passWidth, int passHeight);
    private PdfObject getColorspace();
    private Image getImage();
    private Int32[] getPixel(Byte[] curr);
    private void processPixels(Byte[] curr, int xOffset, int step, int y, int width);
    private void readPng();
}
public static class iTextSharp.text.pdf.codec.TiffConstants : object {
    public static int TIFFTAG_SUBFILETYPE;
    public static int FILETYPE_REDUCEDIMAGE;
    public static int FILETYPE_PAGE;
    public static int FILETYPE_MASK;
    public static int TIFFTAG_OSUBFILETYPE;
    public static int OFILETYPE_IMAGE;
    public static int OFILETYPE_REDUCEDIMAGE;
    public static int OFILETYPE_PAGE;
    public static int TIFFTAG_IMAGEWIDTH;
    public static int TIFFTAG_IMAGELENGTH;
    public static int TIFFTAG_BITSPERSAMPLE;
    public static int TIFFTAG_COMPRESSION;
    public static int COMPRESSION_NONE;
    public static int COMPRESSION_CCITTRLE;
    public static int COMPRESSION_CCITTFAX3;
    public static int COMPRESSION_CCITTFAX4;
    public static int COMPRESSION_LZW;
    public static int COMPRESSION_OJPEG;
    public static int COMPRESSION_JPEG;
    public static int COMPRESSION_NEXT;
    public static int COMPRESSION_CCITTRLEW;
    public static int COMPRESSION_PACKBITS;
    public static int COMPRESSION_THUNDERSCAN;
    public static int COMPRESSION_IT8CTPAD;
    public static int COMPRESSION_IT8LW;
    public static int COMPRESSION_IT8MP;
    public static int COMPRESSION_IT8BL;
    public static int COMPRESSION_PIXARFILM;
    public static int COMPRESSION_PIXARLOG;
    public static int COMPRESSION_DEFLATE;
    public static int COMPRESSION_ADOBE_DEFLATE;
    public static int COMPRESSION_DCS;
    public static int COMPRESSION_JBIG;
    public static int COMPRESSION_SGILOG;
    public static int COMPRESSION_SGILOG24;
    public static int TIFFTAG_PHOTOMETRIC;
    public static int PHOTOMETRIC_MINISWHITE;
    public static int PHOTOMETRIC_MINISBLACK;
    public static int PHOTOMETRIC_RGB;
    public static int PHOTOMETRIC_PALETTE;
    public static int PHOTOMETRIC_MASK;
    public static int PHOTOMETRIC_SEPARATED;
    public static int PHOTOMETRIC_YCBCR;
    public static int PHOTOMETRIC_CIELAB;
    public static int PHOTOMETRIC_LOGL;
    public static int PHOTOMETRIC_LOGLUV;
    public static int TIFFTAG_THRESHHOLDING;
    public static int THRESHHOLD_BILEVEL;
    public static int THRESHHOLD_HALFTONE;
    public static int THRESHHOLD_ERRORDIFFUSE;
    public static int TIFFTAG_CELLWIDTH;
    public static int TIFFTAG_CELLLENGTH;
    public static int TIFFTAG_FILLORDER;
    public static int FILLORDER_MSB2LSB;
    public static int FILLORDER_LSB2MSB;
    public static int TIFFTAG_DOCUMENTNAME;
    public static int TIFFTAG_IMAGEDESCRIPTION;
    public static int TIFFTAG_MAKE;
    public static int TIFFTAG_MODEL;
    public static int TIFFTAG_STRIPOFFSETS;
    public static int TIFFTAG_ORIENTATION;
    public static int ORIENTATION_TOPLEFT;
    public static int ORIENTATION_TOPRIGHT;
    public static int ORIENTATION_BOTRIGHT;
    public static int ORIENTATION_BOTLEFT;
    public static int ORIENTATION_LEFTTOP;
    public static int ORIENTATION_RIGHTTOP;
    public static int ORIENTATION_RIGHTBOT;
    public static int ORIENTATION_LEFTBOT;
    public static int TIFFTAG_SAMPLESPERPIXEL;
    public static int TIFFTAG_ROWSPERSTRIP;
    public static int TIFFTAG_STRIPBYTECOUNTS;
    public static int TIFFTAG_MINSAMPLEVALUE;
    public static int TIFFTAG_MAXSAMPLEVALUE;
    public static int TIFFTAG_XRESOLUTION;
    public static int TIFFTAG_YRESOLUTION;
    public static int TIFFTAG_PLANARCONFIG;
    public static int PLANARCONFIG_CONTIG;
    public static int PLANARCONFIG_SEPARATE;
    public static int TIFFTAG_PAGENAME;
    public static int TIFFTAG_XPOSITION;
    public static int TIFFTAG_YPOSITION;
    public static int TIFFTAG_FREEOFFSETS;
    public static int TIFFTAG_FREEBYTECOUNTS;
    public static int TIFFTAG_GRAYRESPONSEUNIT;
    public static int GRAYRESPONSEUNIT_10S;
    public static int GRAYRESPONSEUNIT_100S;
    public static int GRAYRESPONSEUNIT_1000S;
    public static int GRAYRESPONSEUNIT_10000S;
    public static int GRAYRESPONSEUNIT_100000S;
    public static int TIFFTAG_GRAYRESPONSECURVE;
    public static int TIFFTAG_GROUP3OPTIONS;
    public static int GROUP3OPT_2DENCODING;
    public static int GROUP3OPT_UNCOMPRESSED;
    public static int GROUP3OPT_FILLBITS;
    public static int TIFFTAG_GROUP4OPTIONS;
    public static int GROUP4OPT_UNCOMPRESSED;
    public static int TIFFTAG_RESOLUTIONUNIT;
    public static int RESUNIT_NONE;
    public static int RESUNIT_INCH;
    public static int RESUNIT_CENTIMETER;
    public static int TIFFTAG_PAGENUMBER;
    public static int TIFFTAG_COLORRESPONSEUNIT;
    public static int COLORRESPONSEUNIT_10S;
    public static int COLORRESPONSEUNIT_100S;
    public static int COLORRESPONSEUNIT_1000S;
    public static int COLORRESPONSEUNIT_10000S;
    public static int COLORRESPONSEUNIT_100000S;
    public static int TIFFTAG_TRANSFERFUNCTION;
    public static int TIFFTAG_SOFTWARE;
    public static int TIFFTAG_DATETIME;
    public static int TIFFTAG_ARTIST;
    public static int TIFFTAG_HOSTCOMPUTER;
    public static int TIFFTAG_PREDICTOR;
    public static int TIFFTAG_WHITEPOINT;
    public static int TIFFTAG_PRIMARYCHROMATICITIES;
    public static int TIFFTAG_COLORMAP;
    public static int TIFFTAG_HALFTONEHINTS;
    public static int TIFFTAG_TILEWIDTH;
    public static int TIFFTAG_TILELENGTH;
    public static int TIFFTAG_TILEOFFSETS;
    public static int TIFFTAG_TILEBYTECOUNTS;
    public static int TIFFTAG_BADFAXLINES;
    public static int TIFFTAG_CLEANFAXDATA;
    public static int CLEANFAXDATA_CLEAN;
    public static int CLEANFAXDATA_REGENERATED;
    public static int CLEANFAXDATA_UNCLEAN;
    public static int TIFFTAG_CONSECUTIVEBADFAXLINES;
    public static int TIFFTAG_SUBIFD;
    public static int TIFFTAG_INKSET;
    public static int INKSET_CMYK;
    public static int TIFFTAG_INKNAMES;
    public static int TIFFTAG_NUMBEROFINKS;
    public static int TIFFTAG_DOTRANGE;
    public static int TIFFTAG_TARGETPRINTER;
    public static int TIFFTAG_EXTRASAMPLES;
    public static int EXTRASAMPLE_UNSPECIFIED;
    public static int EXTRASAMPLE_ASSOCALPHA;
    public static int EXTRASAMPLE_UNASSALPHA;
    public static int TIFFTAG_SAMPLEFORMAT;
    public static int SAMPLEFORMAT_UINT;
    public static int SAMPLEFORMAT_INT;
    public static int SAMPLEFORMAT_IEEEFP;
    public static int SAMPLEFORMAT_VOID;
    public static int SAMPLEFORMAT_COMPLEXINT;
    public static int SAMPLEFORMAT_COMPLEXIEEEFP;
    public static int TIFFTAG_SMINSAMPLEVALUE;
    public static int TIFFTAG_SMAXSAMPLEVALUE;
    public static int TIFFTAG_JPEGTABLES;
    public static int TIFFTAG_JPEGPROC;
    public static int JPEGPROC_BASELINE;
    public static int JPEGPROC_LOSSLESS;
    public static int TIFFTAG_JPEGIFOFFSET;
    public static int TIFFTAG_JPEGIFBYTECOUNT;
    public static int TIFFTAG_JPEGRESTARTINTERVAL;
    public static int TIFFTAG_JPEGLOSSLESSPREDICTORS;
    public static int TIFFTAG_JPEGPOINTTRANSFORM;
    public static int TIFFTAG_JPEGQTABLES;
    public static int TIFFTAG_JPEGDCTABLES;
    public static int TIFFTAG_JPEGACTABLES;
    public static int TIFFTAG_YCBCRCOEFFICIENTS;
    public static int TIFFTAG_YCBCRSUBSAMPLING;
    public static int TIFFTAG_YCBCRPOSITIONING;
    public static int YCBCRPOSITION_CENTERED;
    public static int YCBCRPOSITION_COSITED;
    public static int TIFFTAG_REFERENCEBLACKWHITE;
    public static int TIFFTAG_REFPTS;
    public static int TIFFTAG_REGIONTACKPOINT;
    public static int TIFFTAG_REGIONWARPCORNERS;
    public static int TIFFTAG_REGIONAFFINE;
    public static int TIFFTAG_MATTEING;
    public static int TIFFTAG_DATATYPE;
    public static int TIFFTAG_IMAGEDEPTH;
    public static int TIFFTAG_TILEDEPTH;
    public static int TIFFTAG_PIXAR_IMAGEFULLWIDTH;
    public static int TIFFTAG_PIXAR_IMAGEFULLLENGTH;
    public static int TIFFTAG_PIXAR_TEXTUREFORMAT;
    public static int TIFFTAG_PIXAR_WRAPMODES;
    public static int TIFFTAG_PIXAR_FOVCOT;
    public static int TIFFTAG_PIXAR_MATRIX_WORLDTOSCREEN;
    public static int TIFFTAG_PIXAR_MATRIX_WORLDTOCAMERA;
    public static int TIFFTAG_WRITERSERIALNUMBER;
    public static int TIFFTAG_COPYRIGHT;
    public static int TIFFTAG_RICHTIFFIPTC;
    public static int TIFFTAG_IT8SITE;
    public static int TIFFTAG_IT8COLORSEQUENCE;
    public static int TIFFTAG_IT8HEADER;
    public static int TIFFTAG_IT8RASTERPADDING;
    public static int TIFFTAG_IT8BITSPERRUNLENGTH;
    public static int TIFFTAG_IT8BITSPEREXTENDEDRUNLENGTH;
    public static int TIFFTAG_IT8COLORTABLE;
    public static int TIFFTAG_IT8IMAGECOLORINDICATOR;
    public static int TIFFTAG_IT8BKGCOLORINDICATOR;
    public static int TIFFTAG_IT8IMAGECOLORVALUE;
    public static int TIFFTAG_IT8BKGCOLORVALUE;
    public static int TIFFTAG_IT8PIXELINTENSITYRANGE;
    public static int TIFFTAG_IT8TRANSPARENCYINDICATOR;
    public static int TIFFTAG_IT8COLORCHARACTERIZATION;
    public static int TIFFTAG_FRAMECOUNT;
    public static int TIFFTAG_ICCPROFILE;
    public static int TIFFTAG_PHOTOSHOP;
    public static int TIFFTAG_JBIGOPTIONS;
    public static int TIFFTAG_FAXRECVPARAMS;
    public static int TIFFTAG_FAXSUBADDRESS;
    public static int TIFFTAG_FAXRECVTIME;
    public static int TIFFTAG_STONITS;
    public static int TIFFTAG_FEDEX_EDR;
    public static int TIFFTAG_DCSHUESHIFTVALUES;
}
public class iTextSharp.text.pdf.codec.TiffDirectory : object {
    private static Int32[] _sizeOfType;
    private NullValueDictionary`2<int, Nullable`1<int>> _fieldIndex;
    private bool _isBigEndian;
    private TiffField[] _fields;
    private long _ifdOffset;
    private long _nextIfdOffset;
    private int _numEntries;
    public TiffDirectory(RandomAccessFileOrArray stream, int directory);
    public TiffDirectory(RandomAccessFileOrArray stream, long ifdOffset, int directory);
    private static TiffDirectory();
    public static int GetNumDirectories(RandomAccessFileOrArray stream);
    public TiffField GetField(int tag);
    public Nullable`1<byte> GetFieldAsByte(int tag, int index);
    public Nullable`1<byte> GetFieldAsByte(int tag);
    public Nullable`1<double> GetFieldAsDouble(int tag, int index);
    public Nullable`1<double> GetFieldAsDouble(int tag);
    public Nullable`1<float> GetFieldAsFloat(int tag, int index);
    public Nullable`1<float> GetFieldAsFloat(int tag);
    public Nullable`1<long> GetFieldAsLong(int tag, int index);
    public Nullable`1<long> GetFieldAsLong(int tag);
    public TiffField[] GetFields();
    public long GetIfdOffset();
    public long GetNextIfdOffset();
    public int GetNumEntries();
    public Int32[] GetTags();
    public bool IsBigEndian();
    public bool IsTagPresent(int tag);
    private static bool isValidEndianTag(int endian);
    private static long readUnsignedInt(RandomAccessFileOrArray stream, bool isBigEndian);
    private static int readUnsignedShort(RandomAccessFileOrArray stream, bool isBigEndian);
    private void initialize(RandomAccessFileOrArray stream);
    private double readDouble(RandomAccessFileOrArray stream);
    private float readFloat(RandomAccessFileOrArray stream);
    private int readInt(RandomAccessFileOrArray stream);
    private long readLong(RandomAccessFileOrArray stream);
    private short readShort(RandomAccessFileOrArray stream);
    private long readUnsignedInt(RandomAccessFileOrArray stream);
    private int readUnsignedShort(RandomAccessFileOrArray stream);
}
public class iTextSharp.text.pdf.codec.TiffFaxDecoder : object {
    internal static Byte[] FlipTable;
    private static Int16[] _additionalMakeup;
    private static Int16[] _black;
    private static Int16[] _initBlack;
    private static Int32[] _table1;
    private static Int32[] _table2;
    private static Int16[] _twoBitBlack;
    private static Byte[] _twoDCodes;
    private static Int16[] _white;
    private int _fillOrder;
    private int _w;
    private int _bitPointer;
    private int _bytePointer;
    private int _changingElemSize;
    private int _compression;
    private Int32[] _currChangingElems;
    private Byte[] _data;
    private int _fillBits;
    private int _h;
    private int _lastChangingElement;
    private int _oneD;
    private Int32[] _prevChangingElems;
    private int _uncompressedMode;
    public TiffFaxDecoder(int fillOrder, int w, int h);
    private static TiffFaxDecoder();
    public static void ReverseBits(Byte[] b);
    public void Decode1D(Byte[] buffer, Byte[] compData, int startX, int height);
    public void Decode2D(Byte[] buffer, Byte[] compData, int startX, int height, long tiffT4Options);
    public void DecodeNextScanline(Byte[] buffer, int lineOffset, int bitOffset);
    public void DecodeT6(Byte[] buffer, Byte[] compData, int startX, int height, long tiffT6Options);
    private bool advancePointer();
    private int decodeBlackCodeWord();
    private int decodeWhiteCodeWord();
    private void getNextChangingElement(int a0, bool isWhite, Int32[] ret);
    private int nextLesserThan8Bits(int bitsToGet);
    private int nextNBits(int bitsToGet);
    private int readEol(bool isFirstEol);
    private static void setToBlack(Byte[] buffer, int lineOffset, int bitOffset, int numBits);
    private void updatePointer(int bitsToMoveBack);
}
public class iTextSharp.text.pdf.codec.TiffField : object {
    public static int TIFF_ASCII;
    public static int TIFF_BYTE;
    public static int TIFF_DOUBLE;
    public static int TIFF_FLOAT;
    public static int TIFF_LONG;
    public static int TIFF_RATIONAL;
    public static int TIFF_SBYTE;
    public static int TIFF_SHORT;
    public static int TIFF_SLONG;
    public static int TIFF_SRATIONAL;
    public static int TIFF_SSHORT;
    public static int TIFF_UNDEFINED;
    private int _count;
    private object _data;
    private int _tag;
    private int _type;
    public TiffField(int tag, int type, int count, object data);
    public sealed virtual int CompareTo(object obj);
    public Byte[] GetAsBytes();
    public Char[] GetAsChars();
    public double GetAsDouble(int index);
    public Double[] GetAsDoubles();
    public float GetAsFloat(int index);
    public Single[] GetAsFloats();
    public int GetAsInt(int index);
    public Int32[] GetAsInts();
    public long GetAsLong(int index);
    public Int64[] GetAsLongs();
    public Int64[] GetAsRational(int index);
    public Int64[][] GetAsRationals();
    public Int16[] GetAsShorts();
    public Int32[] GetAsSRational(int index);
    public Int32[][] GetAsSRationals();
    public string GetAsString(int index);
    public int GetCount();
    public int GetTag();
    public int GetType();
}
public static class iTextSharp.text.pdf.codec.TiffImage : object {
    public static void DecodePackbits(Byte[] data, Byte[] dst);
    public static int GetNumberOfPages(RandomAccessFileOrArray s);
    public static Image GetTiffImage(RandomAccessFileOrArray s, int page);
    public static Image GetTiffImage(RandomAccessFileOrArray s, int page, bool direct);
    public static void Inflate(Byte[] deflated, Byte[] inflated);
    private static Image GetTiffImageColor(TiffDirectory dir, RandomAccessFileOrArray s);
    private static void processExtraSamples(ZDeflaterOutputStream zip, ZDeflaterOutputStream mzip, Byte[] outBuf, int samplePerPixel, int bitsPerSample, int width, int height);
    private static Int64[] getArrayLongShort(TiffDirectory dir, int tag);
    private static int getDpi(TiffField fd, int resolutionUnit);
}
public class iTextSharp.text.pdf.codec.TifflzwDecoder : object {
    private Int32[] _andTable;
    private int _predictor;
    private int _samplesPerPixel;
    private int _w;
    private int _bytePointer;
    private Byte[] _data;
    private int _dstIndex;
    private int _h;
    private int _nextBits;
    private int _nextData;
    private Byte[][] _stringTable;
    private int _tableIndex;
    private int _bitsToGet;
    private Byte[] _uncompData;
    public TifflzwDecoder(int w, int predictor, int samplesPerPixel);
    public Byte[] Decode(Byte[] data, Byte[] uncompData, int h);
    public void InitializeStringTable();
    public void WriteString(Byte[] strn);
    public void AddStringToTable(Byte[] oldString, byte newString);
    public void AddStringToTable(Byte[] strn);
    public static Byte[] ComposeString(Byte[] oldString, byte newString);
    public int GetNextCode();
}
public class iTextSharp.text.pdf.codec.wmf.InputMeta : object {
    private Stream _sr;
    [CompilerGeneratedAttribute]
private int <Length>k__BackingField;
    public int Length { get; private set; }
    public InputMeta(Stream istr);
    [CompilerGeneratedAttribute]
public int get_Length();
    [CompilerGeneratedAttribute]
private void set_Length(int value);
    public int ReadByte();
    public BaseColor ReadColor();
    public int ReadInt();
    public int ReadShort();
    public int ReadWord();
    public void Skip(int len);
}
public class iTextSharp.text.pdf.codec.wmf.MetaBrush : MetaObject {
    public static int BS_DIBPATTERN;
    public static int BS_HATCHED;
    public static int BS_NULL;
    public static int BS_PATTERN;
    public static int BS_SOLID;
    public static int HS_BDIAGONAL;
    public static int HS_CROSS;
    public static int HS_DIAGCROSS;
    public static int HS_FDIAGONAL;
    public static int HS_HORIZONTAL;
    public static int HS_VERTICAL;
    [CompilerGeneratedAttribute]
private BaseColor <Color>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Hatch>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Style>k__BackingField;
    public BaseColor Color { get; private set; }
    public int Hatch { get; private set; }
    public int Style { get; private set; }
    [CompilerGeneratedAttribute]
public BaseColor get_Color();
    [CompilerGeneratedAttribute]
private void set_Color(BaseColor value);
    [CompilerGeneratedAttribute]
public int get_Hatch();
    [CompilerGeneratedAttribute]
private void set_Hatch(int value);
    [CompilerGeneratedAttribute]
public int get_Style();
    [CompilerGeneratedAttribute]
private void set_Style(int value);
    public void Init(InputMeta meta);
}
public class iTextSharp.text.pdf.codec.wmf.MetaDo : object {
    public static int META_ANIMATEPALETTE;
    public static int META_ARC;
    public static int META_BITBLT;
    public static int META_CHORD;
    public static int META_CREATEBRUSHINDIRECT;
    public static int META_CREATEFONTINDIRECT;
    public static int META_CREATEPALETTE;
    public static int META_CREATEPATTERNBRUSH;
    public static int META_CREATEPENINDIRECT;
    public static int META_CREATEREGION;
    public static int META_DELETEOBJECT;
    public static int META_DIBBITBLT;
    public static int META_DIBCREATEPATTERNBRUSH;
    public static int META_DIBSTRETCHBLT;
    public static int META_ELLIPSE;
    public static int META_ESCAPE;
    public static int META_EXCLUDECLIPRECT;
    public static int META_EXTFLOODFILL;
    public static int META_EXTTEXTOUT;
    public static int META_FILLREGION;
    public static int META_FLOODFILL;
    public static int META_FRAMEREGION;
    public static int META_INTERSECTCLIPRECT;
    public static int META_INVERTREGION;
    public static int META_LINETO;
    public static int META_MOVETO;
    public static int META_OFFSETCLIPRGN;
    public static int META_OFFSETVIEWPORTORG;
    public static int META_OFFSETWINDOWORG;
    public static int META_PAINTREGION;
    public static int META_PATBLT;
    public static int META_PIE;
    public static int META_POLYGON;
    public static int META_POLYLINE;
    public static int META_POLYPOLYGON;
    public static int META_REALIZEPALETTE;
    public static int META_RECTANGLE;
    public static int META_RESIZEPALETTE;
    public static int META_RESTOREDC;
    public static int META_ROUNDRECT;
    public static int META_SAVEDC;
    public static int META_SCALEVIEWPORTEXT;
    public static int META_SCALEWINDOWEXT;
    public static int META_SELECTCLIPREGION;
    public static int META_SELECTOBJECT;
    public static int META_SELECTPALETTE;
    public static int META_SETBKCOLOR;
    public static int META_SETBKMODE;
    public static int META_SETDIBTODEV;
    public static int META_SETMAPMODE;
    public static int META_SETMAPPERFLAGS;
    public static int META_SETPALENTRIES;
    public static int META_SETPIXEL;
    public static int META_SETPOLYFILLMODE;
    public static int META_SETRELABS;
    public static int META_SETROP2;
    public static int META_SETSTRETCHBLTMODE;
    public static int META_SETTEXTALIGN;
    public static int META_SETTEXTCHAREXTRA;
    public static int META_SETTEXTCOLOR;
    public static int META_SETTEXTJUSTIFICATION;
    public static int META_SETVIEWPORTEXT;
    public static int META_SETVIEWPORTORG;
    public static int META_SETWINDOWEXT;
    public static int META_SETWINDOWORG;
    public static int META_STRETCHBLT;
    public static int META_STRETCHDIB;
    public static int META_TEXTOUT;
    private MetaState _state;
    private int _bottom;
    private int _inch;
    private int _left;
    private int _right;
    private int _top;
    public PdfContentByte Cb;
    public InputMeta Meta;
    public MetaDo(Stream meta, PdfContentByte cb);
    public static Byte[] WrapBmp(Image image);
    public static void WriteDWord(Stream os, int v);
    public static void WriteWord(Stream os, int v);
    public bool IsNullStrokeFill(bool isRectangle);
    public void OutputText(int x, int y, int flag, int x1, int y1, int x2, int y2, string text);
    public void ReadAll();
    public void StrokeAndFill();
    internal static float GetArc(float xCenter, float yCenter, float xDot, float yDot);
}
public class iTextSharp.text.pdf.codec.wmf.MetaFont : MetaObject {
    internal static int BOLDTHRESHOLD;
    internal static int DEFAULT_PITCH;
    internal static int ETO_CLIPPED;
    internal static int ETO_OPAQUE;
    internal static int FF_DECORATIVE;
    internal static int FF_DONTCARE;
    internal static int FF_MODERN;
    internal static int FF_ROMAN;
    internal static int FF_SCRIPT;
    internal static int FF_SWISS;
    internal static int FIXED_PITCH;
    internal static int MARKER_BOLD;
    internal static int MARKER_COURIER;
    internal static int MARKER_HELVETICA;
    internal static int MARKER_ITALIC;
    internal static int MARKER_SYMBOL;
    internal static int MARKER_TIMES;
    internal static int nameSize;
    internal static int VARIABLE_PITCH;
    private static String[] _fontNames;
    private int _bold;
    private int _charset;
    private string _faceName;
    private BaseFont _font;
    private int _height;
    private int _italic;
    private int _pitchAndFamily;
    private bool _strikeout;
    private bool _underline;
    [CompilerGeneratedAttribute]
private float <Angle>k__BackingField;
    public float Angle { get; private set; }
    public BaseFont Font { get; }
    private static MetaFont();
    [CompilerGeneratedAttribute]
public float get_Angle();
    [CompilerGeneratedAttribute]
private void set_Angle(float value);
    public BaseFont get_Font();
    public float GetFontSize(MetaState state);
    public void Init(InputMeta meta);
    public bool IsStrikeout();
    public bool IsUnderline();
}
public class iTextSharp.text.pdf.codec.wmf.MetaObject : object {
    public static int META_BRUSH;
    public static int META_FONT;
    public static int META_NOT_SUPPORTED;
    public static int META_PEN;
    [CompilerGeneratedAttribute]
private int <Type>k__BackingField;
    public int Type { get; public set; }
    public MetaObject(int type);
    [CompilerGeneratedAttribute]
public int get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(int value);
}
public class iTextSharp.text.pdf.codec.wmf.MetaPen : MetaObject {
    public static int PS_DASH;
    public static int PS_DASHDOT;
    public static int PS_DASHDOTDOT;
    public static int PS_DOT;
    public static int PS_INSIDEFRAME;
    public static int PS_NULL;
    public static int PS_SOLID;
    [CompilerGeneratedAttribute]
private BaseColor <Color>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PenWidth>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Style>k__BackingField;
    public BaseColor Color { get; private set; }
    public int PenWidth { get; private set; }
    public int Style { get; private set; }
    [CompilerGeneratedAttribute]
public BaseColor get_Color();
    [CompilerGeneratedAttribute]
private void set_Color(BaseColor value);
    [CompilerGeneratedAttribute]
public int get_PenWidth();
    [CompilerGeneratedAttribute]
private void set_PenWidth(int value);
    [CompilerGeneratedAttribute]
public int get_Style();
    [CompilerGeneratedAttribute]
private void set_Style(int value);
    public void Init(InputMeta meta);
}
public class iTextSharp.text.pdf.codec.wmf.MetaState : object {
    public static int Alternate;
    public static int Opaque;
    public static int TaBaseline;
    public static int TaBottom;
    public static int TaCenter;
    public static int TaLeft;
    public static int TaNoupdatecp;
    public static int TaRight;
    public static int TaTop;
    public static int TaUpdatecp;
    public static int Transparent;
    public static int Winding;
    public int backgroundMode;
    public BaseColor currentBackgroundColor;
    public MetaBrush currentBrush;
    public MetaFont currentFont;
    public MetaPen currentPen;
    public Point currentPoint;
    public BaseColor currentTextColor;
    public int extentWx;
    public int extentWy;
    public int LineJoin;
    public List`1<MetaObject> MetaObjects;
    public int offsetWx;
    public int offsetWy;
    public int polyFillMode;
    public Stack`1<MetaState> SavedStates;
    public float scalingX;
    public float scalingY;
    public int textAlign;
    public int BackgroundMode { get; public set; }
    public BaseColor CurrentBackgroundColor { get; public set; }
    public MetaBrush CurrentBrush { get; }
    public MetaFont CurrentFont { get; }
    public MetaPen CurrentPen { get; }
    public Point CurrentPoint { get; public set; }
    public BaseColor CurrentTextColor { get; public set; }
    unknown int ExtentWx {public set; }
    unknown int ExtentWy {public set; }
    unknown PdfContentByte LineJoinPolygon {public set; }
    unknown PdfContentByte LineJoinRectangle {public set; }
    public bool LineNeutral { get; }
    unknown MetaState metaState {public set; }
    unknown int OffsetWx {public set; }
    unknown int OffsetWy {public set; }
    public int PolyFillMode { get; public set; }
    unknown float ScalingX {public set; }
    unknown float ScalingY {public set; }
    public int TextAlign { get; public set; }
    public MetaState(MetaState state);
    private static MetaState();
    public int get_BackgroundMode();
    public void set_BackgroundMode(int value);
    public BaseColor get_CurrentBackgroundColor();
    public void set_CurrentBackgroundColor(BaseColor value);
    public MetaBrush get_CurrentBrush();
    public MetaFont get_CurrentFont();
    public MetaPen get_CurrentPen();
    public Point get_CurrentPoint();
    public void set_CurrentPoint(Point value);
    public BaseColor get_CurrentTextColor();
    public void set_CurrentTextColor(BaseColor value);
    public void set_ExtentWx(int value);
    public void set_ExtentWy(int value);
    public void set_LineJoinPolygon(PdfContentByte value);
    public void set_LineJoinRectangle(PdfContentByte value);
    public bool get_LineNeutral();
    public void set_metaState(MetaState value);
    public void set_OffsetWx(int value);
    public void set_OffsetWy(int value);
    public int get_PolyFillMode();
    public void set_PolyFillMode(int value);
    public void set_ScalingX(float value);
    public void set_ScalingY(float value);
    public int get_TextAlign();
    public void set_TextAlign(int value);
    public void AddMetaObject(MetaObject obj);
    public void Cleanup(PdfContentByte cb);
    public void DeleteMetaObject(int index);
    public void RestoreState(int index, PdfContentByte cb);
    public void SaveState(PdfContentByte cb);
    public void SelectMetaObject(int index, PdfContentByte cb);
    public float TransformAngle(float angle);
    public float TransformX(int x);
    public float TransformY(int y);
}
public class iTextSharp.text.pdf.collection.PdfCollection : PdfDictionary {
    public static int DETAILS;
    public static int HIDDEN;
    public static int TILE;
    unknown string InitialDocument {public set; }
    public PdfCollectionSchema Schema { get; public set; }
    unknown PdfCollectionSort Sort {public set; }
    public PdfCollection(int type);
    public void set_InitialDocument(string value);
    public void set_Schema(PdfCollectionSchema value);
    public PdfCollectionSchema get_Schema();
    public void set_Sort(PdfCollectionSort value);
}
public class iTextSharp.text.pdf.collection.PdfCollectionField : PdfDictionary {
    public static int CREATIONDATE;
    public static int DATE;
    public static int DESC;
    public static int FILENAME;
    public static int MODDATE;
    public static int NUMBER;
    public static int SIZE;
    public static int TEXT;
    protected internal int FieldType;
    unknown bool Editable {public set; }
    unknown int Order {public set; }
    unknown bool Visible {public set; }
    public PdfCollectionField(string name, int type);
    public void set_Editable(bool value);
    public void set_Order(int value);
    public void set_Visible(bool value);
    public PdfObject GetValue(string v);
    public bool IsCollectionItem();
}
public class iTextSharp.text.pdf.collection.PdfCollectionItem : PdfDictionary {
    internal PdfCollectionSchema Schema;
    public PdfCollectionItem(PdfCollectionSchema schema);
    public void AddItem(string key, string value);
    public void AddItem(string key, PdfString value);
    public void AddItem(string key, PdfDate d);
    public void AddItem(string key, PdfNumber n);
    public void AddItem(string key, DateTime c);
    public void AddItem(string key, int i);
    public void AddItem(string key, float f);
    public void AddItem(string key, double d);
    public void SetPrefix(string key, string prefix);
}
public class iTextSharp.text.pdf.collection.PdfCollectionSchema : PdfDictionary {
    public void AddField(string name, PdfCollectionField field);
}
public class iTextSharp.text.pdf.collection.PdfCollectionSort : PdfDictionary {
    public PdfCollectionSort(string key);
    public PdfCollectionSort(String[] keys);
    public void SetSortOrder(bool ascending);
    public void SetSortOrder(Boolean[] ascending);
}
public class iTextSharp.text.pdf.collection.PdfTargetDictionary : PdfDictionary {
    unknown PdfTargetDictionary AdditionalPath {public set; }
    unknown string EmbeddedFileName {public set; }
    unknown int FileAttachmentIndex {public set; }
    unknown string FileAttachmentName {public set; }
    unknown int FileAttachmentPage {public set; }
    unknown string FileAttachmentPagename {public set; }
    public PdfTargetDictionary(PdfTargetDictionary nested);
    public PdfTargetDictionary(bool child);
    public void set_AdditionalPath(PdfTargetDictionary value);
    public void set_EmbeddedFileName(string value);
    public void set_FileAttachmentIndex(int value);
    public void set_FileAttachmentName(string value);
    public void set_FileAttachmentPage(int value);
    public void set_FileAttachmentPagename(string value);
}
public class iTextSharp.text.pdf.ColorDetails : object {
    private PdfName _colorName;
    private PdfIndirectReference _indirectReference;
    private PdfSpotColor _spotcolor;
    internal PdfName ColorName { get; }
    internal PdfIndirectReference IndirectReference { get; }
    internal ColorDetails(PdfName colorName, PdfIndirectReference indirectReference, PdfSpotColor scolor);
    internal PdfName get_ColorName();
    internal PdfIndirectReference get_IndirectReference();
    internal PdfObject GetSpotColor(PdfWriter writer);
}
public class iTextSharp.text.pdf.ColumnText : object {
    public static int AR_COMPOSEDTASHKEEL;
    public static int AR_LIG;
    public static int DIGIT_TYPE_AN;
    public static int DIGIT_TYPE_AN_EXTENDED;
    public static int DIGITS_AN2EN;
    public static int DIGITS_EN2AN;
    public static int DIGITS_EN2AN_INIT_AL;
    public static int DIGITS_EN2AN_INIT_LR;
    public static int NO_MORE_COLUMN;
    public static int NO_MORE_TEXT;
    protected static int LINE_STATUS_NOLINE;
    protected static int LINE_STATUS_OFFLIMITS;
    protected static int LINE_STATUS_OK;
    public static float GlobalSpaceCharRatio;
    private int _arabicOptions;
    private float _filledWidth;
    private float _firstLineY;
    private bool _firstLineYDone;
    private bool _lastWasNewline;
    private int _linesWritten;
    private float _spaceCharRatio;
    private bool _splittedRow;
    private bool _useAscender;
    protected int alignment;
    public int ArNovowel;
    protected BidiLine BidiLine;
    protected PdfContentByte canvas;
    protected PdfContentByte[] canvases;
    protected bool Composite;
    protected ColumnText CompositeColumn;
    protected internal IList`1<IElement> CompositeElements;
    protected float CurrentLeading;
    protected float descender;
    protected float extraParagraphSpace;
    protected float FixedLeading;
    protected float followingIndent;
    protected float indent;
    protected IList`1<Single[]> LeftWall;
    protected float LeftX;
    protected int LineStatus;
    protected int ListIdx;
    protected float MaxY;
    protected float MinY;
    protected float multipliedLeading;
    protected bool RectangularMode;
    protected float RectangularWidth;
    protected float rightIndent;
    protected IList`1<Single[]> RightWall;
    protected float RightX;
    protected int runDirection;
    protected Phrase WaitPhrase;
    protected float yLine;
    [CompilerGeneratedAttribute]
private bool <AdjustFirstLine>k__BackingField;
    public bool AdjustFirstLine { get; public set; }
    public int Alignment { get; public set; }
    public int ArabicOptions { get; public set; }
    public PdfContentByte Canvas { get; public set; }
    public PdfContentByte[] Canvases { get; public set; }
    public float Descender { get; }
    public float ExtraParagraphSpace { get; public set; }
    public float FilledWidth { get; public set; }
    public float FollowingIndent { get; public set; }
    public float Indent { get; public set; }
    public float Leading { get; public set; }
    public int LinesWritten { get; }
    public float MultipliedLeading { get; }
    public float RightIndent { get; public set; }
    public int RunDirection { get; public set; }
    public float SpaceCharRatio { get; public set; }
    public bool UseAscender { get; public set; }
    public float YLine { get; public set; }
    public ColumnText(PdfContentByte canvas);
    [CompilerGeneratedAttribute]
public void set_AdjustFirstLine(bool value);
    [CompilerGeneratedAttribute]
public bool get_AdjustFirstLine();
    public int get_Alignment();
    public void set_Alignment(int value);
    public void set_ArabicOptions(int value);
    public int get_ArabicOptions();
    public void set_Canvas(PdfContentByte value);
    public PdfContentByte get_Canvas();
    public void set_Canvases(PdfContentByte[] value);
    public PdfContentByte[] get_Canvases();
    public float get_Descender();
    public float get_ExtraParagraphSpace();
    public void set_ExtraParagraphSpace(float value);
    public void set_FilledWidth(float value);
    public float get_FilledWidth();
    public float get_FollowingIndent();
    public void set_FollowingIndent(float value);
    public float get_Indent();
    public void set_Indent(float value);
    public float get_Leading();
    public void set_Leading(float value);
    public int get_LinesWritten();
    public float get_MultipliedLeading();
    public float get_RightIndent();
    public void set_RightIndent(float value);
    public int get_RunDirection();
    public void set_RunDirection(int value);
    public float get_SpaceCharRatio();
    public void set_SpaceCharRatio(float value);
    public void set_UseAscender(bool value);
    public bool get_UseAscender();
    public float get_YLine();
    public void set_YLine(float value);
    public static ColumnText Duplicate(ColumnText org);
    public static float GetWidth(Phrase phrase, int runDirection, int arabicOptions);
    public static float GetWidth(Phrase phrase);
    public static bool HasMoreText(int status);
    public static void ShowTextAligned(PdfContentByte canvas, int alignment, Phrase phrase, float x, float y, float rotation, int runDirection, int arabicOptions);
    public static void ShowTextAligned(PdfContentByte canvas, int alignment, Phrase phrase, float x, float y, float rotation);
    public void AddElement(IElement element);
    public void AddText(Phrase phrase);
    public void AddText(Chunk chunk);
    public void ClearChunks();
    public int Go();
    public int Go(bool simulate);
    public ColumnText SetACopy(ColumnText org);
    public void SetColumns(Single[] leftLine, Single[] rightLine);
    public void SetLeading(float fixedLeading, float multipliedLeading);
    public void SetSimpleColumn(Phrase phrase, float llx, float lly, float urx, float ury, float leading, int alignment);
    public void SetSimpleColumn(float llx, float lly, float urx, float ury, float leading, int alignment);
    public void SetSimpleColumn(float llx, float lly, float urx, float ury);
    public void SetText(Phrase phrase);
    public void UpdateFilledWidth(float w);
    public bool ZeroHeightElement();
    protected internal void SetSimpleVars(ColumnText org);
    protected IList`1<Single[]> ConvertColumn(Single[] cLine);
    protected Single[] FindLimitsOneLine();
    protected float FindLimitsPoint(IList`1<Single[]> wall);
    protected Single[] FindLimitsTwoLines();
    protected int GoComposite(bool simulate);
    private void addWaitingPhrase();
}
public static class iTextSharp.text.pdf.crypto.AesCbcNoPadding : object {
    public static Byte[] ProcessBlock(bool forEncryption, Byte[] key, Byte[] inBuf, int inOff, int inLen, Byte[] iv);
}
public class iTextSharp.text.pdf.crypto.AesCipher : object {
    private PaddedBufferedBlockCipher _bp;
    public AesCipher(bool forEncryption, Byte[] key, Byte[] iv);
    public Byte[] Update(Byte[] inp, int inpOff, int inpLen);
    public Byte[] DoFinal();
}
public class iTextSharp.text.pdf.crypto.ArcfourEncryption : object {
    private Byte[] _state;
    private int _x;
    private int _y;
    public void EncryptArcfour(Byte[] dataIn, int off, int len, Byte[] dataOut, int offOut);
    public void EncryptArcfour(Byte[] data, int off, int len);
    public void EncryptArcfour(Byte[] dataIn, Byte[] dataOut);
    public void EncryptArcfour(Byte[] data);
    public void PrepareArcfourKey(Byte[] key);
    public void PrepareArcfourKey(Byte[] key, int off, int len);
}
public static class iTextSharp.text.pdf.crypto.IvGenerator : object {
    private static ArcfourEncryption _rc4;
    private static IvGenerator();
    public static Byte[] GetIv();
    public static Byte[] GetIv(int len);
}
public class iTextSharp.text.pdf.crypto.StandardDecryption : object {
    private static int Aes128;
    private static int AES_256_V3;
    private bool _aes;
    private Byte[] _iv;
    private Byte[] _key;
    private bool _initiated;
    private int _ivptr;
    protected ArcfourEncryption Arcfour;
    protected AesCipher Cipher;
    public StandardDecryption(Byte[] key, int off, int len, int revision);
    public Byte[] Finish();
    public Byte[] Update(Byte[] b, int off, int len);
}
public class iTextSharp.text.pdf.DefaultSplitCharacter : object {
    public static ISplitCharacter Default;
    private static DefaultSplitCharacter();
    public sealed virtual bool IsSplitCharacter(int start, int current, int end, Char[] cc, PdfChunk[] ck);
    protected static char GetCurrentCharacter(int current, Char[] cc, PdfChunk[] ck);
}
public class iTextSharp.text.pdf.DocumentFont : BaseFont {
    private static String[] _cjkEncs;
    private static String[] _cjkEncs2;
    private static String[] _cjkNames;
    private static String[] _cjkNames2;
    private static Int32[] _stdEnc;
    private BaseFont _cjkMirror;
    private PdfDictionary _font;
    private string _fontName;
    private bool _isType0;
    private NullValueDictionary`2<int, Int32[]> _metrics;
    private PrIndirectReference _refFont;
    private float _ascender;
    private float _capHeight;
    private float _descender;
    private NullValueDictionary`2<int, int> _diffmap;
    private float _italicAngle;
    private float _llx;
    private float _lly;
    private float _urx;
    private float _ury;
    [CompilerGeneratedAttribute]
private NullValueDictionary`2<int, int> <Uni2Byte>k__BackingField;
    public String[][] AllNameEntries { get; }
    public String[][] FamilyFontName { get; }
    public String[][] FullFontName { get; }
    public string PostscriptFontName { get; public set; }
    internal PdfIndirectReference IndirectReference { get; }
    internal NullValueDictionary`2<int, int> Uni2Byte { get; }
    internal DocumentFont(PrIndirectReference refFont);
    private static DocumentFont();
    public virtual String[][] get_AllNameEntries();
    public virtual String[][] get_FamilyFontName();
    public virtual String[][] get_FullFontName();
    public virtual string get_PostscriptFontName();
    public virtual void set_PostscriptFontName(string value);
    internal PdfIndirectReference get_IndirectReference();
    [CompilerGeneratedAttribute]
internal NullValueDictionary`2<int, int> get_Uni2Byte();
    public virtual bool CharExists(int c);
    public virtual Int32[] GetCharBBox(int c);
    public virtual float GetFontDescriptor(int key, float fontSize);
    public virtual PdfStream GetFullFontStream();
    public virtual int GetKerning(int char1, int char2);
    public virtual int GetWidth(int char1);
    public virtual int GetWidth(string text);
    public virtual bool HasKernPairs();
    public virtual bool SetKerning(int char1, int char2, int kern);
    internal virtual Byte[] ConvertToBytes(string text);
    internal virtual Byte[] ConvertToBytes(int char1);
    internal virtual int GetRawWidth(int c, string name);
    internal virtual void WriteFont(PdfWriter writer, PdfIndirectReference refi, Object[] param);
    protected virtual Int32[] GetRawCharBBox(int c, string name);
    private static string decodeString(PdfString ps);
    private void doType1Tt();
    private void fillEncoding(PdfName encoding);
    private void fillFontDesc(PdfDictionary fontDesc);
    private void fillMetrics(Byte[] touni, NullValueDictionary`2<int, int> widths, int dw);
    private void processType0(PdfDictionary font);
    private static NullValueDictionary`2<int, int> readWidths(PdfArray ws);
}
public class iTextSharp.text.pdf.draw.DottedLineSeparator : LineSeparator {
    [CompilerGeneratedAttribute]
private float <Gap>k__BackingField;
    public float Gap { get; public set; }
    [CompilerGeneratedAttribute]
public float get_Gap();
    [CompilerGeneratedAttribute]
public void set_Gap(float value);
    public virtual void Draw(PdfContentByte canvas, float llx, float lly, float urx, float ury, float y);
}
public interface iTextSharp.text.pdf.draw.IDrawInterface {
    public abstract virtual void Draw(PdfContentByte canvas, float llx, float lly, float urx, float ury, float y);
}
public class iTextSharp.text.pdf.draw.LineSeparator : VerticalPositionMark {
    [CompilerGeneratedAttribute]
private int <Alignment>k__BackingField;
    [CompilerGeneratedAttribute]
private BaseColor <LineColor>k__BackingField;
    [CompilerGeneratedAttribute]
private float <LineWidth>k__BackingField;
    [CompilerGeneratedAttribute]
private float <Percentage>k__BackingField;
    public int Alignment { get; public set; }
    public BaseColor LineColor { get; public set; }
    public float LineWidth { get; public set; }
    public float Percentage { get; public set; }
    public LineSeparator(float lineWidth, float percentage, BaseColor lineColor, int align, float offset);
    [CompilerGeneratedAttribute]
public int get_Alignment();
    [CompilerGeneratedAttribute]
public void set_Alignment(int value);
    [CompilerGeneratedAttribute]
public BaseColor get_LineColor();
    [CompilerGeneratedAttribute]
public void set_LineColor(BaseColor value);
    [CompilerGeneratedAttribute]
public float get_LineWidth();
    [CompilerGeneratedAttribute]
public void set_LineWidth(float value);
    [CompilerGeneratedAttribute]
public float get_Percentage();
    [CompilerGeneratedAttribute]
public void set_Percentage(float value);
    public virtual void Draw(PdfContentByte canvas, float llx, float lly, float urx, float ury, float y);
    public void DrawLine(PdfContentByte canvas, float leftX, float rightX, float y);
}
public class iTextSharp.text.pdf.draw.VerticalPositionMark : object {
    [CompilerGeneratedAttribute]
private IDrawInterface <DrawInterface>k__BackingField;
    [CompilerGeneratedAttribute]
private float <Offset>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Type>k__BackingField;
    public IDrawInterface DrawInterface { get; public set; }
    public float Offset { get; public set; }
    public IList`1<Chunk> Chunks { get; }
    public int Type { get; }
    public VerticalPositionMark(IDrawInterface drawInterface, float offset);
    [CompilerGeneratedAttribute]
public virtual void set_DrawInterface(IDrawInterface value);
    [CompilerGeneratedAttribute]
public virtual IDrawInterface get_DrawInterface();
    [CompilerGeneratedAttribute]
public virtual void set_Offset(float value);
    [CompilerGeneratedAttribute]
public virtual float get_Offset();
    public virtual void Draw(PdfContentByte canvas, float llx, float lly, float urx, float ury, float y);
    public sealed virtual IList`1<Chunk> get_Chunks();
    [CompilerGeneratedAttribute]
public sealed virtual int get_Type();
    public sealed virtual bool IsContent();
    public sealed virtual bool IsNestable();
    public sealed virtual bool Process(IElementListener listener);
}
internal class iTextSharp.text.pdf.EnumerateTtc : TrueTypeFont {
    protected String[] names;
    internal String[] Names { get; }
    internal EnumerateTtc(string ttcFile);
    internal EnumerateTtc(Byte[] ttcArray);
    internal String[] get_Names();
    internal void FindNames();
}
public class iTextSharp.text.pdf.events.FieldPositioningEvents : PdfPageEventHelper {
    protected PdfFormField CellField;
    protected PdfWriter FieldWriter;
    protected INullValueDictionary`2<string, PdfFormField> GenericChunkFields;
    [CompilerGeneratedAttribute]
private float <Padding>k__BackingField;
    [CompilerGeneratedAttribute]
private PdfFormField <Parent>k__BackingField;
    public float Padding { get; public set; }
    public PdfFormField Parent { get; public set; }
    public FieldPositioningEvents(PdfWriter writer, PdfFormField field);
    public FieldPositioningEvents(PdfFormField parent, PdfFormField field);
    public FieldPositioningEvents(PdfWriter writer, string text);
    public FieldPositioningEvents(PdfWriter writer, PdfFormField parent, string text);
    [CompilerGeneratedAttribute]
public void set_Padding(float value);
    [CompilerGeneratedAttribute]
public float get_Padding();
    [CompilerGeneratedAttribute]
public void set_Parent(PdfFormField value);
    [CompilerGeneratedAttribute]
public PdfFormField get_Parent();
    public sealed virtual void CellLayout(PdfPCell cell, Rectangle position, PdfContentByte[] canvases);
    public void AddField(string text, PdfFormField field);
    public virtual void OnGenericTag(PdfWriter writer, Document document, Rectangle rect, string text);
}
public class iTextSharp.text.pdf.events.IndexEvents : PdfPageEventHelper {
    private List`1<Entry> _indexentry;
    private INullValueDictionary`2<string, int> _indextag;
    private IComparer`1<Entry> _comparator;
    private long _indexcounter;
    public Chunk Create(string text, string in1, string in2, string in3);
    public Chunk Create(string text, string in1);
    public Chunk Create(string text, string in1, string in2);
    public void Create(Chunk text, string in1, string in2, string in3);
    public void Create(Chunk text, string in1);
    public void Create(Chunk text, string in1, string in2);
    public IList`1<Entry> GetSortedEntries();
    public virtual void OnGenericTag(PdfWriter writer, Document document, Rectangle rect, string text);
    public void SetComparator(IComparer`1<Entry> aComparator);
}
public class iTextSharp.text.pdf.events.PdfPageEventForwarder : object {
    protected List`1<IPdfPageEvent> Events;
    public virtual void OnChapter(PdfWriter writer, Document document, float paragraphPosition, Paragraph title);
    public virtual void OnChapterEnd(PdfWriter writer, Document document, float paragraphPosition);
    public virtual void OnCloseDocument(PdfWriter writer, Document document);
    public virtual void OnEndPage(PdfWriter writer, Document document);
    public virtual void OnGenericTag(PdfWriter writer, Document document, Rectangle rect, string text);
    public virtual void OnOpenDocument(PdfWriter writer, Document document);
    public virtual void OnParagraph(PdfWriter writer, Document document, float paragraphPosition);
    public virtual void OnParagraphEnd(PdfWriter writer, Document document, float paragraphPosition);
    public virtual void OnSection(PdfWriter writer, Document document, float paragraphPosition, int depth, Paragraph title);
    public virtual void OnSectionEnd(PdfWriter writer, Document document, float paragraphPosition);
    public virtual void OnStartPage(PdfWriter writer, Document document);
    public void AddPageEvent(IPdfPageEvent eventa);
}
public class iTextSharp.text.pdf.events.PdfPCellEventForwarder : object {
    protected List`1<IPdfPCellEvent> Events;
    public sealed virtual void CellLayout(PdfPCell cell, Rectangle position, PdfContentByte[] canvases);
    public void AddCellEvent(IPdfPCellEvent eventa);
}
public class iTextSharp.text.pdf.events.PdfPTableEventForwarder : object {
    protected List`1<IPdfPTableEvent> Events;
    public sealed virtual void TableLayout(PdfPTable table, Single[][] widths, Single[] heights, int headerRows, int rowStart, PdfContentByte[] canvases);
    public void AddTableEvent(IPdfPTableEvent eventa);
}
public abstract class iTextSharp.text.pdf.ExtendedColor : BaseColor {
    internal static int TYPE_CMYK;
    internal static int TYPE_GRAY;
    internal static int TYPE_PATTERN;
    internal static int TYPE_RGB;
    internal static int TYPE_SEPARATION;
    internal static int TYPE_SHADING;
    protected int type;
    public int Type { get; }
    protected ExtendedColor(int type);
    protected ExtendedColor(int type, float red, float green, float blue);
    public int get_Type();
    public static int GetType(object color);
    internal static float Normalize(float value);
}
public class iTextSharp.text.pdf.FdfReader : PdfReader {
    internal PdfName Encoding;
    internal INullValueDictionary`2<string, PdfDictionary> fields;
    internal string fileSpec;
    public INullValueDictionary`2<string, PdfDictionary> Fields { get; }
    public string FileSpec { get; }
    public FdfReader(string filename);
    public FdfReader(Byte[] pdfIn);
    public FdfReader(Uri url);
    public FdfReader(Stream isp);
    public INullValueDictionary`2<string, PdfDictionary> get_Fields();
    public string get_FileSpec();
    public PdfDictionary GetField(string name);
    public string GetFieldValue(string name);
    protected internal virtual void ReadPdf();
    protected virtual void KidNode(PdfDictionary merged, string name);
    protected virtual void ReadFields();
}
public class iTextSharp.text.pdf.FdfWriter : object {
    private static Byte[] _headerFdf;
    private INullValueDictionary`2<string, object> _fields;
    private string _file;
    public string File { get; public set; }
    private static FdfWriter();
    public string get_File();
    public void set_File(string value);
    public string GetField(string field);
    public INullValueDictionary`2<string, object> GetFields();
    public bool RemoveField(string field);
    public bool SetFieldAsAction(string field, PdfAction action);
    public bool SetFieldAsName(string field, string value);
    public bool SetFieldAsString(string field, string value);
    public void SetFields(FdfReader fdf);
    public void SetFields(PdfReader pdf);
    public void SetFields(AcroFields af);
    public void WriteTo(Stream os);
    internal static void IterateFields(INullValueDictionary`2<string, object> values, INullValueDictionary`2<string, object> map, string name);
    internal bool SetField(string field, PdfObject value);
}
public class iTextSharp.text.pdf.FontDetails : object {
    private BaseFont _baseFont;
    private CjkFont _cjkFont;
    private NullValueDictionary`2<int, int> _cjkTag;
    private PdfName _fontName;
    private int _fontType;
    private PdfIndirectReference _indirectReference;
    private NullValueDictionary`2<int, Int32[]> _longTag;
    private Byte[] _shortTag;
    private bool _symbolic;
    private TrueTypeFontUnicode _ttu;
    protected bool subset;
    public bool Subset { get; public set; }
    public BaseFont BaseFont { get; }
    public PdfName FontName { get; }
    public PdfIndirectReference IndirectReference { get; }
    public FontDetails(PdfName fontName, PdfIndirectReference indirectReference, BaseFont baseFont);
    public void set_Subset(bool value);
    public bool get_Subset();
    public BaseFont get_BaseFont();
    public PdfName get_FontName();
    public PdfIndirectReference get_IndirectReference();
    public Byte[] ConvertToBytes(string text);
    public void WriteFont(PdfWriter writer);
}
public class iTextSharp.text.pdf.FontSelector : object {
    protected List`1<Font> Fonts;
    public void AddFont(Font font);
    public Phrase Process(string text);
}
public static class iTextSharp.text.pdf.GlyphList : object {
    private static INullValueDictionary`2<string, Int32[]> _names2Unicode;
    private static INullValueDictionary`2<int, string> _unicode2Names;
    private static GlyphList();
    public static Int32[] NameToUnicode(string name);
    public static string UnicodeToName(int num);
}
public class iTextSharp.text.pdf.GrayColor : ExtendedColor {
    public static GrayColor Grayblack;
    public static GrayColor Graywhite;
    [CompilerGeneratedAttribute]
private float <Gray>k__BackingField;
    public float Gray { get; }
    public GrayColor(int intGray);
    public GrayColor(float floatGray);
    private static GrayColor();
    [CompilerGeneratedAttribute]
public float get_Gray();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[DefaultMemberAttribute("Item")]
public class iTextSharp.text.pdf.hyphenation.ByteVector : object {
    private static int DEFAULT_BLOCK_SIZE;
    private int _blockSize;
    private int _n;
    [CompilerGeneratedAttribute]
private Byte[] <Arr>k__BackingField;
    public Byte[] Arr { get; private set; }
    public int Capacity { get; }
    public int Length { get; }
    public byte Item { get; public set; }
    public ByteVector(int capacity);
    public ByteVector(Byte[] a);
    public ByteVector(Byte[] a, int capacity);
    [CompilerGeneratedAttribute]
public Byte[] get_Arr();
    [CompilerGeneratedAttribute]
private void set_Arr(Byte[] value);
    public int get_Capacity();
    public int get_Length();
    public byte get_Item(int index);
    public void set_Item(int index, byte value);
    public int Alloc(int size);
    public void TrimToSize();
}
[DefaultMemberAttribute("Item")]
public class iTextSharp.text.pdf.hyphenation.CharVector : object {
    private static int DEFAULT_BLOCK_SIZE;
    private int _blockSize;
    private int _n;
    [CompilerGeneratedAttribute]
private Char[] <Arr>k__BackingField;
    public Char[] Arr { get; private set; }
    public int Capacity { get; }
    public int Length { get; }
    public char Item { get; public set; }
    public CharVector(int capacity);
    public CharVector(Char[] a);
    public CharVector(Char[] a, int capacity);
    [CompilerGeneratedAttribute]
public Char[] get_Arr();
    [CompilerGeneratedAttribute]
private void set_Arr(Char[] value);
    public int get_Capacity();
    public int get_Length();
    public char get_Item(int index);
    public void set_Item(int index, char value);
    public sealed virtual object Clone();
    public int Alloc(int size);
    public void Clear();
    public void TrimToSize();
}
public class iTextSharp.text.pdf.hyphenation.Hyphen : object {
    public string NoBreak;
    public string PostBreak;
    public string PreBreak;
    internal Hyphen(string pre, string no, string post);
    internal Hyphen(string pre);
    public virtual string ToString();
}
public class iTextSharp.text.pdf.hyphenation.Hyphenation : object {
    private int _len;
    private string _word;
    [CompilerGeneratedAttribute]
private Int32[] <HyphenationPoints>k__BackingField;
    public int Length { get; }
    public Int32[] HyphenationPoints { get; }
    internal Hyphenation(string word, Int32[] points);
    public int get_Length();
    [CompilerGeneratedAttribute]
public Int32[] get_HyphenationPoints();
    public string GetPreHyphenText(int index);
    public string GetPostHyphenText(int index);
    public virtual string ToString();
}
public class iTextSharp.text.pdf.hyphenation.HyphenationException : Exception {
    public HyphenationException(string msg);
    public HyphenationException(string message, Exception innerException);
}
public class iTextSharp.text.pdf.hyphenation.HyphenationTree : TernaryTree {
    private TernaryTree _ivalues;
    protected TernaryTree Classmap;
    protected INullValueDictionary`2<string, List`1<object>> Stoplist;
    protected ByteVector Vspace;
    public sealed virtual void AddClass(string chargroup);
    public sealed virtual void AddPattern(string pattern, string values);
    public sealed virtual void AddException(string word, List`1<object> hyphenatedword);
    protected int PackValues(string values);
    protected string UnpackValues(int k);
    public void LoadSimplePatterns(Stream stream);
    public string FindPattern(string pat);
    protected static int Hstrcmp(Char[] s, int si, Char[] t, int ti);
    protected Byte[] GetValues(int k);
    protected void SearchPatterns(Char[] word, int index, Byte[] il);
    public Hyphenation Hyphenate(string word, int remainCharCount, int pushCharCount);
    public Hyphenation Hyphenate(Char[] w, int offset, int len, int remainCharCount, int pushCharCount);
    public virtual void PrintStats();
}
public class iTextSharp.text.pdf.hyphenation.Hyphenator : object {
    private static string DefaultHyphLocation;
    private static NullValueDictionary`2<string, HyphenationTree> _hyphenTrees;
    private HyphenationTree _hyphenTree;
    private int _pushCharCount;
    private int _remainCharCount;
    public Hyphenator(string lang, string country, int leftMin, int rightMin);
    private static Hyphenator();
    public static HyphenationTree GetHyphenationTree(string lang, string country);
    public static HyphenationTree GetResourceHyphenationTree(string key);
    public static Hyphenation Hyphenate(string lang, string country, string word, int leftMin, int rightMin);
    public static Hyphenation Hyphenate(string lang, string country, Char[] word, int offset, int len, int leftMin, int rightMin);
    public Hyphenation Hyphenate(Char[] word, int offset, int len);
    public Hyphenation Hyphenate(string word);
    public void SetLanguage(string lang, string country);
    public void SetMinPushCharCount(int min);
    public void SetMinRemainCharCount(int min);
}
public interface iTextSharp.text.pdf.hyphenation.IPatternConsumer {
    public abstract virtual void AddClass(string chargroup);
    public abstract virtual void AddException(string word, List`1<object> hyphenatedword);
    public abstract virtual void AddPattern(string pattern, string values);
}
public class iTextSharp.text.pdf.hyphenation.SimplePatternParser : object {
    internal static int ELEM_CLASSES;
    internal static int ELEM_EXCEPTIONS;
    internal static int ELEM_HYPHEN;
    internal static int ELEM_PATTERNS;
    internal IPatternConsumer Consumer;
    internal int CurrElement;
    internal List`1<object> Exception;
    internal char HyphenChar;
    internal StringBuilder Token;
    public sealed virtual void EndDocument();
    public sealed virtual void EndElement(string tag);
    public sealed virtual void StartDocument();
    public sealed virtual void Text(string str);
    public sealed virtual void StartElement(string tag, INullValueDictionary`2<string, string> h);
    public void Parse(Stream stream, IPatternConsumer consumer);
    protected static string GetInterletterValues(string pat);
    protected static string GetPattern(string word);
    protected static string GetExceptionWord(List`1<object> ex);
    protected List`1<object> NormalizeException(List`1<object> ex);
}
public class iTextSharp.text.pdf.hyphenation.TernaryTree : object {
    protected static int BlockSize;
    protected Char[] Eq;
    protected char Freenode;
    protected Char[] Hi;
    protected CharVector Kv;
    protected int Length;
    protected Char[] Lo;
    protected char Root;
    protected Char[] Sc;
    public Iterator Keys { get; }
    public int Size { get; }
    private static TernaryTree();
    public Iterator get_Keys();
    public int get_Size();
    public sealed virtual object Clone();
    public static int Strcmp(Char[] a, int startA, Char[] b, int startB);
    public static int Strcmp(string str, Char[] a, int start);
    public static void Strcpy(Char[] dst, int di, Char[] src, int si);
    public static int Strlen(Char[] a, int start);
    public static int Strlen(Char[] a);
    public void Balance();
    public int Find(string key);
    public int Find(Char[] key, int start);
    public void Insert(string key, char val);
    public void Insert(Char[] key, int start, char val);
    public bool Knows(string key);
    public virtual void PrintStats();
    public void TrimToSize();
    protected void Init();
    protected void InsertBalanced(String[] k, Char[] v, int offset, int n);
    private void compact(CharVector kx, TernaryTree map, char p);
    private char insert(char p, Char[] key, int start, char val);
    private void redimNodeArrays(int newsize);
}
public class iTextSharp.text.pdf.HyphenationAuto : object {
    protected Hyphenator Hyphenator;
    protected string Post;
    public string HyphenatedWordPost { get; }
    public string HyphenSymbol { get; }
    public HyphenationAuto(string lang, string country, int leftMin, int rightMin);
    public sealed virtual string get_HyphenatedWordPost();
    public sealed virtual string get_HyphenSymbol();
    public sealed virtual string GetHyphenatedWordPre(string word, BaseFont font, float fontSize, float remainingWidth);
}
public class iTextSharp.text.pdf.IccProfile : object {
    private static INullValueDictionary`2<string, int> _cstags;
    protected Byte[] data;
    protected int numComponents;
    public Byte[] Data { get; }
    public int NumComponents { get; }
    private static IccProfile();
    public Byte[] get_Data();
    public int get_NumComponents();
    public static IccProfile GetInstance(Byte[] data);
    public static IccProfile GetInstance(Stream file);
    public static IccProfile GetInstance(string fname);
}
public interface iTextSharp.text.pdf.IExtraEncoding {
    public abstract virtual string ByteToChar(Byte[] b, string encoding);
    public abstract virtual Byte[] CharToByte(string text, string encoding);
    public abstract virtual Byte[] CharToByte(char char1, string encoding);
}
public interface iTextSharp.text.pdf.IHyphenationEvent {
    public string HyphenatedWordPost { get; }
    public string HyphenSymbol { get; }
    public abstract virtual string get_HyphenatedWordPost();
    public abstract virtual string get_HyphenSymbol();
    public abstract virtual string GetHyphenatedWordPre(string word, BaseFont font, float fontSize, float remainingWidth);
}
public interface iTextSharp.text.pdf.interfaces.IPdfAnnotations {
    public PdfAcroForm AcroForm { get; }
    unknown int SigFlags {public set; }
    public abstract virtual PdfAcroForm get_AcroForm();
    public abstract virtual void set_SigFlags(int value);
    public abstract virtual void AddAnnotation(PdfAnnotation annot);
    public abstract virtual void AddCalculationOrder(PdfFormField annot);
}
public interface iTextSharp.text.pdf.interfaces.IPdfDocumentActions {
    public abstract virtual void SetAdditionalAction(PdfName actionType, PdfAction action);
    public abstract virtual void SetOpenAction(string name);
    public abstract virtual void SetOpenAction(PdfAction action);
}
public interface iTextSharp.text.pdf.interfaces.IPdfEncryptionSettings {
    public abstract virtual void SetEncryption(Byte[] userPassword, Byte[] ownerPassword, int permissions, int encryptionType);
    public abstract virtual void SetEncryption(X509Certificate[] certs, Int32[] permissions, int encryptionType);
}
public interface iTextSharp.text.pdf.interfaces.IPdfPageActions {
    unknown int Duration {public set; }
    unknown PdfTransition Transition {public set; }
    public abstract virtual void set_Duration(int value);
    public abstract virtual void set_Transition(PdfTransition value);
    public abstract virtual void SetPageAction(PdfName actionType, PdfAction action);
}
public interface iTextSharp.text.pdf.interfaces.IPdfRunDirection {
    public int RunDirection { get; public set; }
    public abstract virtual void set_RunDirection(int value);
    public abstract virtual int get_RunDirection();
}
public interface iTextSharp.text.pdf.interfaces.IPdfVersion {
    unknown char PdfVersion {public set; }
    public abstract virtual void set_PdfVersion(char value);
    public abstract virtual void AddDeveloperExtension(PdfDeveloperExtension de);
    public abstract virtual void SetAtLeastPdfVersion(char version);
    public abstract virtual void SetPdfVersion(PdfName version);
}
public interface iTextSharp.text.pdf.interfaces.IPdfViewerPreferences {
    unknown int ViewerPreferences {public set; }
    public abstract virtual void set_ViewerPreferences(int value);
    public abstract virtual void AddViewerPreference(PdfName key, PdfObject value);
}
public interface iTextSharp.text.pdf.interfaces.IPdfXConformance {
    public int PdfxConformance { get; public set; }
    public abstract virtual void set_PdfxConformance(int value);
    public abstract virtual int get_PdfxConformance();
    public abstract virtual bool IsPdfX();
}
public class iTextSharp.text.pdf.intern.PdfAnnotationsImp : object {
    protected internal PdfAcroForm acroForm;
    protected internal List`1<PdfAnnotation> Annotations;
    protected internal List`1<PdfAnnotation> DelayedAnnotations;
    public PdfAcroForm AcroForm { get; }
    unknown int SigFlags {public set; }
    public PdfAnnotationsImp(PdfWriter writer);
    public PdfAcroForm get_AcroForm();
    public void set_SigFlags(int value);
    public static PdfAnnotation ConvertAnnotation(PdfWriter writer, Annotation annot, Rectangle defaultRect);
    public void AddAnnotation(PdfAnnotation annot);
    public void AddCalculationOrder(PdfFormField formField);
    public void AddPlainAnnotation(PdfAnnotation annot);
    public bool HasUnusedAnnotations();
    public bool HasValidAcroForm();
    public void ResetAnnotations();
    public PdfArray RotateAnnotations(PdfWriter writer, Rectangle pageSize);
    private void addFormFieldRaw(PdfFormField field);
}
public class iTextSharp.text.pdf.intern.PdfVersionImp : object {
    public static Byte[][] Header;
    protected bool Appendmode;
    protected PdfName CatalogVersion;
    protected PdfDictionary Extensions;
    protected char HeaderVersion;
    protected bool HeaderWasWritten;
    unknown char PdfVersion {public set; }
    private static PdfVersionImp();
    public sealed virtual void set_PdfVersion(char value);
    public sealed virtual void AddDeveloperExtension(PdfDeveloperExtension de);
    public sealed virtual void SetAtLeastPdfVersion(char version);
    public sealed virtual void SetPdfVersion(PdfName version);
    public void AddToCatalog(PdfDictionary catalog);
    public static Byte[] GetVersionAsByteArray(char version);
    public static PdfName GetVersionAsName(char version);
    public void SetAppendmode(bool appendmode);
    public void WriteHeader(OutputStreamCounter os);
}
public class iTextSharp.text.pdf.intern.PdfViewerPreferencesImp : object {
    private static int ViewerPreferencesMask;
    public static PdfName[] DirectionPreferences;
    public static PdfName[] DuplexPreferences;
    public static PdfName[] NonfullscreenpagemodePreferences;
    public static PdfName[] PageBoundaries;
    public static PdfName[] PrintscalingPreferences;
    public static PdfName[] VIEWER_PREFERENCES;
    private PdfDictionary _viewerPreferences;
    private int _pageLayoutAndMode;
    public int PageLayoutAndMode { get; }
    unknown int ViewerPreferences {public set; }
    private static PdfViewerPreferencesImp();
    public int get_PageLayoutAndMode();
    public sealed virtual void set_ViewerPreferences(int value);
    public virtual void AddViewerPreference(PdfName key, PdfObject value);
    public static PdfViewerPreferencesImp GetViewerPreferences(PdfDictionary catalog);
    public void AddToCatalog(PdfDictionary catalog);
    public PdfDictionary GetViewerPreferences();
    private static int getIndex(PdfName key);
    private static bool isPossibleValue(PdfName value, PdfName[] accepted);
}
public class iTextSharp.text.pdf.intern.PdfXConformanceImp : object {
    public static int PDFXKEY_CMYK;
    public static int PDFXKEY_COLOR;
    public static int PDFXKEY_FONT;
    public static int PDFXKEY_GSTATE;
    public static int PDFXKEY_IMAGE;
    public static int PDFXKEY_LAYER;
    public static int PDFXKEY_RGB;
    [CompilerGeneratedAttribute]
private int <PdfxConformance>k__BackingField;
    public int PdfxConformance { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual void set_PdfxConformance(int value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_PdfxConformance();
    public sealed virtual bool IsPdfX();
    public static void CheckPdfxConformance(PdfWriter writer, int key, object obj1);
    public void CompleteExtraCatalog(PdfDictionary extraCatalog);
    public void CompleteInfoDictionary(PdfDictionary info);
    public bool IsPdfA1();
    public bool IsPdfA1A();
    public bool IsPdfX1A2001();
    public bool IsPdfX32002();
}
public interface iTextSharp.text.pdf.IOcspClient {
    public abstract virtual Byte[] GetEncoded();
}
public interface iTextSharp.text.pdf.IPdfOcg {
    public PdfObject PdfObject { get; }
    public PdfIndirectReference Ref { get; }
    public abstract virtual PdfObject get_PdfObject();
    public abstract virtual PdfIndirectReference get_Ref();
}
public interface iTextSharp.text.pdf.IPdfPageEvent {
    public abstract virtual void OnChapter(PdfWriter writer, Document document, float paragraphPosition, Paragraph title);
    public abstract virtual void OnChapterEnd(PdfWriter writer, Document document, float paragraphPosition);
    public abstract virtual void OnCloseDocument(PdfWriter writer, Document document);
    public abstract virtual void OnEndPage(PdfWriter writer, Document document);
    public abstract virtual void OnGenericTag(PdfWriter writer, Document document, Rectangle rect, string text);
    public abstract virtual void OnOpenDocument(PdfWriter writer, Document document);
    public abstract virtual void OnParagraph(PdfWriter writer, Document document, float paragraphPosition);
    public abstract virtual void OnParagraphEnd(PdfWriter writer, Document document, float paragraphPosition);
    public abstract virtual void OnSection(PdfWriter writer, Document document, float paragraphPosition, int depth, Paragraph title);
    public abstract virtual void OnSectionEnd(PdfWriter writer, Document document, float paragraphPosition);
    public abstract virtual void OnStartPage(PdfWriter writer, Document document);
}
public interface iTextSharp.text.pdf.IPdfPCellEvent {
    public abstract virtual void CellLayout(PdfPCell cell, Rectangle position, PdfContentByte[] canvases);
}
public interface iTextSharp.text.pdf.IPdfPTableEvent {
    public abstract virtual void TableLayout(PdfPTable table, Single[][] widths, Single[] heights, int headerRows, int rowStart, PdfContentByte[] canvases);
}
public interface iTextSharp.text.pdf.ITsaClient {
    public abstract virtual Byte[] GetTimeStampToken(PdfPkcs7 caller, Byte[] imprint);
    public abstract virtual int GetTokenSizeEstimate();
}
public class iTextSharp.text.pdf.LzwDecoder : object {
    private int _bytePointer;
    private Byte[] _data;
    private int _nextBits;
    private int _nextData;
    private Byte[][] _stringTable;
    private int _tableIndex;
    private int _bitsToGet;
    private Stream _uncompData;
    internal Int32[] AndTable;
    public int NextCode { get; }
    public int get_NextCode();
    public void AddStringToTable(Byte[] oldstring, byte newstring);
    public void AddStringToTable(Byte[] str);
    public static Byte[] ComposeString(Byte[] oldstring, byte newstring);
    public void Decode(Byte[] data, Stream uncompData);
    public void InitializeStringTable();
    public void WriteString(Byte[] str);
}
public class iTextSharp.text.pdf.MultiColumnText : object {
    public static float AUTOMATIC;
    private List`1<ColumnDef> _columnDefs;
    private ColumnText _columnText;
    private float _desiredHeight;
    private bool _columnsRightToLeft;
    private int _currentColumn;
    private PdfDocument _document;
    private float _nextY;
    private bool _overflow;
    private bool _simple;
    private float _top;
    private float _totalHeight;
    public int CurrentColumn { get; }
    unknown float SpaceCharRatio {public set; }
    unknown int RunDirection {public set; }
    unknown int ArabicOptions {public set; }
    unknown int Alignment {public set; }
    public int Type { get; }
    public IList`1<Chunk> Chunks { get; }
    public MultiColumnText(float height);
    public MultiColumnText(float top, float height);
    public int get_CurrentColumn();
    public void set_SpaceCharRatio(float value);
    public void set_RunDirection(int value);
    public void set_ArabicOptions(int value);
    public void set_Alignment(int value);
    public sealed virtual bool Process(IElementListener listener);
    public sealed virtual int get_Type();
    public sealed virtual IList`1<Chunk> get_Chunks();
    public sealed virtual bool IsContent();
    public sealed virtual bool IsNestable();
    public bool IsOverflow();
    public void UseColumnParams(ColumnText sourceColumn);
    public void AddColumn(Single[] left, Single[] right);
    public void AddSimpleColumn(float left, float right);
    public void AddRegularColumns(float left, float right, float gutterWidth, int numColumns);
    public void AddText(Phrase phrase);
    public void AddText(Chunk chunk);
    public void AddElement(IElement element);
    public float Write(PdfContentByte canvas, PdfDocument document, float documentY);
    private void newPage();
    private static float getHeight(Single[] left, Single[] right);
    private float getColumnBottom();
    public void NextColumn();
    public void ResetCurrentColumn();
    public bool ShiftCurrentColumn();
    public void SetColumnsRightToLeft(bool direction);
}
public class iTextSharp.text.pdf.OcspClientBouncyCastle : object {
    private X509Certificate _checkCert;
    private X509Certificate _rootCert;
    private string _url;
    public OcspClientBouncyCastle(X509Certificate checkCert, X509Certificate rootCert, string url);
    public sealed virtual Byte[] GetEncoded();
    private static OcspReq generateOcspRequest(X509Certificate issuerCert, BigInteger serialNumber);
}
public class iTextSharp.text.pdf.OutputStreamCounter : Stream {
    protected int counter;
    protected Stream Outc;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public int Counter { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public OutputStreamCounter(Stream _outc);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public int get_Counter();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public void ResetCounter();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
}
public class iTextSharp.text.pdf.OutputStreamEncryption : Stream {
    protected ArcfourEncryption Arcfour;
    protected AesCipher Cipher;
    protected Stream Outc;
    private static int Aes128;
    private static int AES_256_V3;
    private bool _aes;
    private Byte[] _buf;
    private bool _finished;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public OutputStreamEncryption(Stream outc, Byte[] key, int off, int len, int revision);
    public OutputStreamEncryption(Stream outc, Byte[] key, int revision);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Close();
    public void Finish();
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte value);
}
public class iTextSharp.text.pdf.PageResources : object {
    protected PdfDictionary ColorDictionary;
    protected PdfDictionary ExtGStateDictionary;
    protected PdfDictionary FontDictionary;
    protected INullValueDictionary`2<PdfName, object> ForbiddenNames;
    protected Int32[] NamePtr;
    protected PdfDictionary OriginalResources;
    protected PdfDictionary PatternDictionary;
    protected PdfDictionary PropertyDictionary;
    protected PdfDictionary ShadingDictionary;
    protected INullValueDictionary`2<PdfName, PdfName> UsedNames;
    protected PdfDictionary XObjectDictionary;
    internal PdfDictionary Resources { get; }
    internal PdfDictionary get_Resources();
    internal PdfName AddColor(PdfName name, PdfIndirectReference reference);
    internal void AddDefaultColor(PdfName name, PdfObject obj);
    internal void AddDefaultColor(PdfDictionary dic);
    internal void AddDefaultColorDiff(PdfDictionary dic);
    internal PdfName AddExtGState(PdfName name, PdfIndirectReference reference);
    internal PdfName AddFont(PdfName name, PdfIndirectReference reference);
    internal PdfName AddPattern(PdfName name, PdfIndirectReference reference);
    internal PdfName AddProperty(PdfName name, PdfIndirectReference reference);
    internal PdfName AddShading(PdfName name, PdfIndirectReference reference);
    internal PdfName AddXObject(PdfName name, PdfIndirectReference reference);
    internal bool HasResources();
    internal void SetOriginalResources(PdfDictionary resources, Int32[] newNamePtr);
    internal PdfName TranslateName(PdfName name);
}
public class iTextSharp.text.pdf.PatternColor : ExtendedColor {
    private PdfPatternPainter _painter;
    public PdfPatternPainter Painter { get; }
    public PatternColor(PdfPatternPainter painter);
    public PdfPatternPainter get_Painter();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class iTextSharp.text.pdf.PdfAcroForm : PdfDictionary {
    private PdfArray _calculationOrder;
    private PdfArray _documentFields;
    private INullValueDictionary`2<PdfTemplate, object> _fieldTemplates;
    private PdfWriter _writer;
    private int _sigFlags;
    unknown bool NeedAppearances {public set; }
    unknown int SigFlags {public set; }
    public PdfAcroForm(PdfWriter writer);
    public void set_NeedAppearances(bool value);
    public void set_SigFlags(int value);
    public void AddCalculationOrder(PdfFormField formField);
    public PdfFormField AddCheckBox(string name, string value, bool status, float llx, float lly, float urx, float ury);
    public PdfFormField AddComboBox(string name, String[] options, string defaultValue, bool editable, BaseFont font, float fontSize, float llx, float lly, float urx, float ury);
    public PdfFormField AddComboBox(string name, String[0...,0...] options, string defaultValue, bool editable, BaseFont font, float fontSize, float llx, float lly, float urx, float ury);
    public void AddDocumentField(PdfIndirectReference piref);
    public void AddFieldTemplates(INullValueDictionary`2<PdfTemplate, object> ft);
    public void AddFormField(PdfFormField formField);
    public PdfFormField AddHiddenField(string name, string value);
    public PdfFormField AddHtmlPostButton(string name, string caption, string value, string url, BaseFont font, float fontSize, float llx, float lly, float urx, float ury);
    public PdfFormField AddMap(string name, string value, string url, PdfContentByte appearance, float llx, float lly, float urx, float ury);
    public PdfFormField AddMultiLineTextField(string name, string text, BaseFont font, float fontSize, float llx, float lly, float urx, float ury);
    public PdfFormField AddRadioButton(PdfFormField radiogroup, string value, float llx, float lly, float urx, float ury);
    public void AddRadioGroup(PdfFormField radiogroup);
    public PdfFormField AddResetButton(string name, string caption, string value, BaseFont font, float fontSize, float llx, float lly, float urx, float ury);
    public PdfFormField AddSelectList(string name, String[] options, string defaultValue, BaseFont font, float fontSize, float llx, float lly, float urx, float ury);
    public PdfFormField AddSelectList(string name, String[0...,0...] options, string defaultValue, BaseFont font, float fontSize, float llx, float lly, float urx, float ury);
    public PdfFormField AddSignature(string name, float llx, float lly, float urx, float ury);
    public PdfFormField AddSingleLinePasswordField(string name, string text, BaseFont font, float fontSize, float llx, float lly, float urx, float ury);
    public PdfFormField AddSingleLineTextField(string name, string text, BaseFont font, float fontSize, float llx, float lly, float urx, float ury);
    public void DrawButton(PdfFormField button, string caption, BaseFont font, float fontSize, float llx, float lly, float urx, float ury);
    public void DrawCheckBoxAppearences(PdfFormField field, string value, float llx, float lly, float urx, float ury);
    public void DrawMultiLineOfText(PdfFormField field, string text, BaseFont font, float fontSize, float llx, float lly, float urx, float ury);
    public void DrawRadioAppearences(PdfFormField field, string value, float llx, float lly, float urx, float ury);
    public void DrawSignatureAppearences(PdfFormField field, float llx, float lly, float urx, float ury);
    public void DrawSingleLineOfText(PdfFormField field, string text, BaseFont font, float fontSize, float llx, float lly, float urx, float ury);
    public PdfFormField GetRadioGroup(string name, string defaultValue, bool noToggleToOff);
    public bool IsValid();
    public static void SetButtonParams(PdfFormField button, int characteristics, string name, string value);
    public static void SetCheckBoxParams(PdfFormField field, string name, string value, bool status, float llx, float lly, float urx, float ury);
    public static void SetChoiceParams(PdfFormField field, string name, string defaultValue, float llx, float lly, float urx, float ury);
    public static void SetSignatureParams(PdfFormField field, string name, float llx, float lly, float urx, float ury);
    public static void SetTextFieldParams(PdfFormField field, string text, string name, float llx, float lly, float urx, float ury);
}
public class iTextSharp.text.pdf.PdfAction : PdfDictionary {
    public static int FIRSTPAGE;
    public static int LASTPAGE;
    public static int NEXTPAGE;
    public static int PREVPAGE;
    public static int PRINTDIALOG;
    public static int RESET_EXCLUDE;
    public static int SUBMIT_CANONICAL_FORMAT;
    public static int SUBMIT_COORDINATES;
    public static int SUBMIT_EMBED_FORM;
    public static int SUBMIT_EXCL_F_KEY;
    public static int SUBMIT_EXCL_NON_USER_ANNOTS;
    public static int SUBMIT_EXCLUDE;
    public static int SUBMIT_HTML_FORMAT;
    public static int SUBMIT_HTML_GET;
    public static int SUBMIT_INCLUDE_ANNOTATIONS;
    public static int SUBMIT_INCLUDE_APPEND_SAVES;
    public static int SUBMIT_INCLUDE_NO_VALUE_FIELDS;
    public static int SUBMIT_PDF;
    public static int SUBMIT_XFDF;
    public PdfAction(Uri url);
    public PdfAction(Uri url, bool isMap);
    public PdfAction(string url);
    public PdfAction(string url, bool isMap);
    public PdfAction(string filename, string name);
    public PdfAction(string filename, int page);
    public PdfAction(int named);
    public PdfAction(string application, string parameters, string operation, string defaultDir);
    internal PdfAction(PdfIndirectReference destination);
    public static PdfAction CreateHide(PdfAnnotation annot, bool hide);
    public static PdfAction CreateHide(string name, bool hide);
    public static PdfAction CreateHide(Object[] names, bool hide);
    public static PdfAction CreateImportData(string file);
    public static PdfAction CreateLaunch(string application, string parameters, string operation, string defaultDir);
    public static PdfAction CreateResetForm(Object[] names, int flags);
    public static PdfAction CreateSubmitForm(string file, Object[] names, int flags);
    public static PdfAction GotoEmbedded(string filename, PdfTargetDictionary target, string dest, bool isName, bool newWindow);
    public static PdfAction GotoEmbedded(string filename, PdfTargetDictionary target, PdfObject dest, bool newWindow);
    public static PdfAction GotoLocalPage(int page, PdfDestination dest, PdfWriter writer);
    public static PdfAction GotoLocalPage(string dest, bool isName);
    public static PdfAction GotoRemotePage(string filename, string dest, bool isName, bool newWindow);
    public static PdfAction JavaScript(string code, PdfWriter writer, bool unicode);
    public static PdfAction JavaScript(string code, PdfWriter writer);
    public static PdfAction Rendition(string file, PdfFileSpecification fs, string mimeType, PdfIndirectReference refi);
    public static PdfAction SetOcGstate(IList`1<object> state, bool preserveRb);
    public void Next(PdfAction na);
    internal static PdfArray BuildArray(Object[] names);
    internal static PdfAction CreateHide(PdfObject obj, bool hide);
}
public class iTextSharp.text.pdf.PdfAnnotation : PdfDictionary {
    public static int FLAGS_HIDDEN;
    public static int FLAGS_INVISIBLE;
    public static int FLAGS_LOCKED;
    public static int FLAGS_NOROTATE;
    public static int FLAGS_NOVIEW;
    public static int FLAGS_NOZOOM;
    public static int FLAGS_PRINT;
    public static int FLAGS_READONLY;
    public static int FLAGS_TOGGLENOVIEW;
    public static int MARKUP_HIGHLIGHT;
    public static int MARKUP_SQUIGGLY;
    public static int MARKUP_STRIKEOUT;
    public static int MARKUP_UNDERLINE;
    public static PdfName AaBlur;
    public static PdfName AaDown;
    public static PdfName AaEnter;
    public static PdfName AaExit;
    public static PdfName AaFocus;
    public static PdfName AaJsChange;
    public static PdfName AaJsFormat;
    public static PdfName AaJsKey;
    public static PdfName AaJsOtherChange;
    public static PdfName AaUp;
    public static PdfName AppearanceDown;
    public static PdfName AppearanceNormal;
    public static PdfName AppearanceRollover;
    public static PdfName HighlightInvert;
    public static PdfName HighlightNone;
    public static PdfName HighlightOutline;
    public static PdfName HighlightPush;
    public static PdfName HighlightToggle;
    private int _placeInPage;
    protected internal bool Annotation;
    protected internal bool Form;
    protected internal PdfIndirectReference Reference;
    protected internal INullValueDictionary`2<PdfTemplate, object> templates;
    protected internal bool Used;
    protected internal PdfWriter Writer;
    unknown PdfAction Action {public set; }
    unknown string AppearanceState {public set; }
    unknown PdfBorderArray Border {public set; }
    unknown PdfBorderDictionary BorderStyle {public set; }
    unknown BaseColor Color {public set; }
    unknown PdfContentByte DefaultAppearanceString {public set; }
    unknown int Flags {public set; }
    public PdfIndirectReference IndirectReference { get; }
    unknown IPdfOcg Layer {public set; }
    unknown string MkAlternateCaption {public set; }
    unknown PdfTemplate MkAlternateIcon {public set; }
    unknown BaseColor MkBackgroundColor {public set; }
    unknown BaseColor MkBorderColor {public set; }
    unknown string MkNormalCaption {public set; }
    unknown PdfTemplate MkNormalIcon {public set; }
    unknown string MkRolloverCaption {public set; }
    unknown PdfTemplate MkRolloverIcon {public set; }
    unknown int MkRotation {public set; }
    unknown int MkTextPosition {public set; }
    unknown string Name {public set; }
    unknown int Page {public set; }
    public int PlaceInPage { get; public set; }
    unknown PdfAnnotation Popup {public set; }
    unknown int Rotate {public set; }
    public INullValueDictionary`2<PdfTemplate, object> Templates { get; }
    unknown string Title {public set; }
    internal PdfDictionary Mk { get; }
    public PdfAnnotation(PdfWriter writer, Rectangle rect);
    public PdfAnnotation(PdfWriter writer, float llx, float lly, float urx, float ury, PdfString title, PdfString content);
    public PdfAnnotation(PdfWriter writer, float llx, float lly, float urx, float ury, PdfAction action);
    private static PdfAnnotation();
    public void set_Action(PdfAction value);
    public void set_AppearanceState(string value);
    public void set_Border(PdfBorderArray value);
    public void set_BorderStyle(PdfBorderDictionary value);
    public void set_Color(BaseColor value);
    public void set_DefaultAppearanceString(PdfContentByte value);
    public void set_Flags(int value);
    public PdfIndirectReference get_IndirectReference();
    public void set_Layer(IPdfOcg value);
    public void set_MkAlternateCaption(string value);
    public void set_MkAlternateIcon(PdfTemplate value);
    public void set_MkBackgroundColor(BaseColor value);
    public void set_MkBorderColor(BaseColor value);
    public void set_MkNormalCaption(string value);
    public void set_MkNormalIcon(PdfTemplate value);
    public void set_MkRolloverCaption(string value);
    public void set_MkRolloverIcon(PdfTemplate value);
    public void set_MkRotation(int value);
    public void set_MkTextPosition(int value);
    public void set_Name(string value);
    public void set_Page(int value);
    public int get_PlaceInPage();
    public void set_PlaceInPage(int value);
    public void set_Popup(PdfAnnotation value);
    public void set_Rotate(int value);
    public INullValueDictionary`2<PdfTemplate, object> get_Templates();
    public void set_Title(string value);
    internal PdfDictionary get_Mk();
    public static PdfAnnotation CreateFileAttachment(PdfWriter writer, Rectangle rect, string contents, Byte[] fileStore, string file, string fileDisplay);
    public static PdfAnnotation CreateFileAttachment(PdfWriter writer, Rectangle rect, string contents, PdfFileSpecification fs);
    public static PdfAnnotation CreateFreeText(PdfWriter writer, Rectangle rect, string contents, PdfContentByte defaultAppearance);
    public static PdfAnnotation CreateInk(PdfWriter writer, Rectangle rect, string contents, Single[][] inkList);
    public static PdfAnnotation CreateLine(PdfWriter writer, Rectangle rect, string contents, float x1, float y1, float x2, float y2);
    public static PdfAnnotation CreateLink(PdfWriter writer, Rectangle rect, PdfName highlight, PdfAction action);
    public static PdfAnnotation CreateLink(PdfWriter writer, Rectangle rect, PdfName highlight, string namedDestination);
    public static PdfAnnotation CreateLink(PdfWriter writer, Rectangle rect, PdfName highlight, int page, PdfDestination dest);
    public static PdfAnnotation CreateMarkup(PdfWriter writer, Rectangle rect, string contents, int type, Single[] quadPoints);
    public static PdfAnnotation CreatePopup(PdfWriter writer, Rectangle rect, string contents, bool open);
    public static PdfAnnotation CreateScreen(PdfWriter writer, Rectangle rect, string clipTitle, PdfFileSpecification fs, string mimeType, bool playOnDisplay);
    public static PdfAnnotation CreateSquareCircle(PdfWriter writer, Rectangle rect, string contents, bool square);
    public static PdfAnnotation CreateStamp(PdfWriter writer, Rectangle rect, string contents, string name);
    public static PdfAnnotation CreateText(PdfWriter writer, Rectangle rect, string title, string contents, bool open, string icon);
    public static PdfArray GetMkColor(BaseColor color);
    public static PdfAnnotation ShallowDuplicate(PdfAnnotation annot);
    public bool IsAnnotation();
    public bool IsForm();
    public void SetAdditionalActions(PdfName key, PdfAction action);
    public void SetAppearance(PdfName ap, PdfTemplate template);
    public void SetAppearance(PdfName ap, string state, PdfTemplate template);
    public void SetHighlighting(PdfName highlight);
    public void SetMkIconFit(PdfName scale, PdfName scalingType, float leftoverLeft, float leftoverBottom, bool fitInBounds);
    public void SetPage();
    public virtual void SetUsed();
    internal virtual bool IsUsed();
    protected static PdfAnnotation CreateLink(PdfWriter writer, Rectangle rect, PdfName highlight);
}
public class iTextSharp.text.pdf.PdfAppearance : PdfTemplate {
    public static INullValueDictionary`2<string, PdfName> StdFieldFontNames;
    public PdfContentByte Duplicate { get; }
    private static PdfAppearance();
    internal PdfAppearance(PdfIndirectReference iref);
    internal PdfAppearance(PdfWriter wr);
    public virtual PdfContentByte get_Duplicate();
    public static PdfAppearance CreateAppearance(PdfWriter writer, float width, float height);
    public virtual void SetFontAndSize(BaseFont bf, float size);
    internal static PdfAppearance CreateAppearance(PdfWriter writer, float width, float height, PdfName forcedName);
}
[DefaultMemberAttribute("Item")]
public class iTextSharp.text.pdf.PdfArray : PdfObject {
    protected List`1<PdfObject> arrayList;
    public IList`1<PdfObject> ArrayList { get; }
    public int Size { get; }
    public PdfObject Item { get; public set; }
    public PdfArray(PdfObject obj);
    public PdfArray(Single[] values);
    public PdfArray(Int32[] values);
    public PdfArray(IList`1<PdfObject> l);
    public PdfArray(PdfArray array);
    public IList`1<PdfObject> get_ArrayList();
    public int get_Size();
    public PdfObject get_Item(int idx);
    public void set_Item(int idx, PdfObject value);
    public virtual bool Add(PdfObject obj);
    public virtual bool Add(Single[] values);
    public virtual bool Add(Int32[] values);
    public virtual void Add(int index, PdfObject element);
    public virtual void AddFirst(PdfObject obj);
    public bool Contains(PdfObject obj);
    public PdfArray GetAsArray(int idx);
    public PdfBoolean GetAsBoolean(int idx);
    public PdfDictionary GetAsDict(int idx);
    public PdfIndirectReference GetAsIndirectObject(int idx);
    public PdfName GetAsName(int idx);
    public PdfNumber GetAsNumber(int idx);
    public PdfStream GetAsStream(int idx);
    public PdfString GetAsString(int idx);
    public PdfObject GetDirectObject(int idx);
    public ListIterator`1<PdfObject> GetListIterator();
    public bool IsEmpty();
    public PdfObject Remove(int idx);
    public virtual void ToPdf(PdfWriter writer, Stream os);
    public virtual string ToString();
}
public class iTextSharp.text.pdf.PdfBoolean : PdfObject {
    public static string FALSE;
    public static string TRUE;
    public static PdfBoolean Pdffalse;
    public static PdfBoolean Pdftrue;
    private bool _value;
    public bool BooleanValue { get; }
    public PdfBoolean(bool value);
    public PdfBoolean(string value);
    private static PdfBoolean();
    public bool get_BooleanValue();
    public virtual string ToString();
}
public class iTextSharp.text.pdf.PdfBorderArray : PdfArray {
    public PdfBorderArray(float hRadius, float vRadius, float width);
    public PdfBorderArray(float hRadius, float vRadius, float width, PdfDashPattern dash);
}
public class iTextSharp.text.pdf.PdfBorderDictionary : PdfDictionary {
    public static int STYLE_BEVELED;
    public static int STYLE_DASHED;
    public static int STYLE_INSET;
    public static int STYLE_SOLID;
    public static int STYLE_UNDERLINE;
    public PdfBorderDictionary(float borderWidth, int borderStyle, PdfDashPattern dashes);
    public PdfBorderDictionary(float borderWidth, int borderStyle);
}
public class iTextSharp.text.pdf.PdfCell : Rectangle {
    private List`1<Image> _images;
    private int _verticalAlignment;
    private float _contentHeight;
    private PdfLine _firstLine;
    private PdfLine _lastLine;
    private PdfLine _line;
    private List`1<PdfLine> _lines;
    private bool _useAscender;
    private bool _useBorderPadding;
    private bool _useDescender;
    [CompilerGeneratedAttribute]
private float <Cellpadding>k__BackingField;
    [CompilerGeneratedAttribute]
private float <Cellspacing>k__BackingField;
    [CompilerGeneratedAttribute]
private int <GroupNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private float <Leading>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Rownumber>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Rowspan>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Header>k__BackingField;
    public float Bottom { get; public set; }
    public float Cellpadding { get; }
    public float Cellspacing { get; }
    public int GroupNumber { get; public set; }
    public float Leading { get; }
    public float Left { get; }
    public float RemainingHeight { get; }
    public float Right { get; }
    public int Rownumber { get; }
    public int Rowspan { get; }
    public int Size { get; }
    public float Top { get; }
    public bool UseAscender { get; public set; }
    public bool UseBorderPadding { get; public set; }
    public bool UseDescender { get; public set; }
    internal bool Header { get; private set; }
    private float FirstLineRealHeight { get; }
    public PdfCell(Cell cell, int rownumber, float left, float right, float top, float cellspacing, float cellpadding);
    public virtual float get_Bottom();
    public virtual void set_Bottom(float value);
    [CompilerGeneratedAttribute]
public float get_Cellpadding();
    [CompilerGeneratedAttribute]
public float get_Cellspacing();
    [CompilerGeneratedAttribute]
public int get_GroupNumber();
    [CompilerGeneratedAttribute]
public void set_GroupNumber(int value);
    [CompilerGeneratedAttribute]
public float get_Leading();
    public virtual float get_Left();
    public float get_RemainingHeight();
    public virtual float get_Right();
    [CompilerGeneratedAttribute]
public int get_Rownumber();
    [CompilerGeneratedAttribute]
public int get_Rowspan();
    public int get_Size();
    public virtual float get_Top();
    public bool get_UseAscender();
    public void set_UseAscender(bool value);
    public void set_UseBorderPadding(bool value);
    public bool get_UseBorderPadding();
    public bool get_UseDescender();
    public void set_UseDescender(bool value);
    [CompilerGeneratedAttribute]
internal bool get_Header();
    [CompilerGeneratedAttribute]
private void set_Header(bool value);
    private float get_FirstLineRealHeight();
    public IList`1<Image> GetImages(float top, float bottom);
    public IList`1<PdfLine> GetLines(float top, float bottom);
    public Rectangle Rectangle(float top, float bottom);
    internal bool MayBeRemoved();
    internal void SetHeader();
    protected static void ProcessActions(IElement element, PdfAction action, IList`1<PdfAction> allActions);
    private float addImage(Image i, float left, float right, float extraHeight, int alignment);
    private void addLine(PdfLine line);
    private void addList(List list, float left, float right, int alignment);
    private void flushCurrentLine();
    private float getBorderWidthInside(int side);
    private float remainingLinesHeight();
    private PdfLine removeLine(int index);
}
public class iTextSharp.text.pdf.PdfChunk : object {
    private static float ItalicAngle;
    private static NullValueDictionary`2<string, object> _keysAttributes;
    private static NullValueDictionary`2<string, object> _keysNoStroke;
    private static Char[] _singleSpace;
    private static PdfChunk[] _thisChunk;
    protected INullValueDictionary`2<string, object> Attributes;
    protected BaseFont BaseFont;
    protected bool changeLeading;
    protected string encoding;
    protected PdfFont font;
    protected Image image;
    protected bool NewlineSplit;
    protected INullValueDictionary`2<string, object> NoStroke;
    protected float OffsetX;
    protected float OffsetY;
    protected ISplitCharacter SplitCharacter;
    protected string value;
    public bool ChangeLeading { get; }
    public float TextRise { get; }
    public BaseColor Color { get; }
    public string Encoding { get; }
    public PdfFont Font { get; }
    public Image Image { get; }
    public float ImageOffsetX { get; public set; }
    public float ImageOffsetY { get; public set; }
    public int Length { get; }
    public int LengthUtf32 { get; }
    unknown string Value {public set; }
    public float Width { get; }
    private static PdfChunk();
    public PdfChunk(string str, PdfChunk other);
    public PdfChunk(Chunk chunk, PdfAction action);
    public bool get_ChangeLeading();
    public float get_TextRise();
    public BaseColor get_Color();
    public string get_Encoding();
    public PdfFont get_Font();
    public Image get_Image();
    public float get_ImageOffsetX();
    public void set_ImageOffsetX(float value);
    public float get_ImageOffsetY();
    public void set_ImageOffsetY(float value);
    public int get_Length();
    public int get_LengthUtf32();
    public void set_Value(string value);
    public float get_Width();
    public static bool NoPrint(int c);
    public int GetUnicodeEquivalent(int c);
    public float GetWidthCorrected(float charSpacing, float wordSpacing);
    public bool IsNewlineSplit();
    public virtual string ToString();
    public float TrimFirstSpace();
    public float TrimLastSpace();
    public void AdjustLeft(float newValue);
    public object GetAttribute(string name);
    public float GetCharWidth(int c);
    public bool IsAttribute(string name);
    public bool IsExtSplitCharacter(int start, int current, int end, Char[] cc, PdfChunk[] ck);
    public bool IsHorizontalSeparator();
    public bool IsImage();
    public bool IsSeparator();
    public bool IsSpecialEncoding();
    public bool IsStroked();
    public bool IsTab();
    public PdfChunk Split(float width);
    public string Trim(string str);
    public PdfChunk Truncate(float width);
    protected static int GetWord(string text, int start);
}
internal class iTextSharp.text.pdf.PdfColor : PdfArray {
    internal PdfColor(int red, int green, int blue);
    internal PdfColor(BaseColor color);
}
public class iTextSharp.text.pdf.PdfContentByte : object {
    public static int ALIGN_CENTER;
    public static int ALIGN_LEFT;
    public static int ALIGN_RIGHT;
    public static int LINE_CAP_BUTT;
    public static int LINE_CAP_PROJECTING_SQUARE;
    public static int LINE_CAP_ROUND;
    public static int LINE_JOIN_BEVEL;
    public static int LINE_JOIN_MITER;
    public static int LINE_JOIN_ROUND;
    public static int TEXT_RENDER_MODE_CLIP;
    public static int TEXT_RENDER_MODE_FILL;
    public static int TEXT_RENDER_MODE_FILL_CLIP;
    public static int TEXT_RENDER_MODE_FILL_STROKE;
    public static int TEXT_RENDER_MODE_FILL_STROKE_CLIP;
    public static int TEXT_RENDER_MODE_INVISIBLE;
    public static int TEXT_RENDER_MODE_STROKE;
    public static int TEXT_RENDER_MODE_STROKE_CLIP;
    private static INullValueDictionary`2<PdfName, string> _abrev;
    private static Single[] _unitRect;
    private bool _inText;
    private int _mcDepth;
    protected ByteBuffer Content;
    protected List`1<int> LayerDepth;
    protected PdfDocument Pdf;
    protected int Separator;
    protected GraphicState State;
    protected List`1<GraphicState> StateList;
    protected PdfWriter Writer;
    public float CharacterSpacing { get; }
    public PdfContentByte Duplicate { get; }
    public float HorizontalScaling { get; }
    public ByteBuffer InternalBuffer { get; }
    public float Leading { get; }
    public PdfDocument PdfDocument { get; }
    public PdfWriter PdfWriter { get; }
    public PdfOutline RootOutline { get; }
    public float WordSpacing { get; }
    public float Xtlm { get; }
    public float Ytlm { get; }
    internal PageResources PageResources { get; }
    internal int Size { get; }
    private static PdfContentByte();
    public PdfContentByte(PdfWriter wr);
    public float get_CharacterSpacing();
    public virtual PdfContentByte get_Duplicate();
    public float get_HorizontalScaling();
    public ByteBuffer get_InternalBuffer();
    public float get_Leading();
    public PdfDocument get_PdfDocument();
    public PdfWriter get_PdfWriter();
    public PdfOutline get_RootOutline();
    public float get_WordSpacing();
    public float get_Xtlm();
    public float get_Ytlm();
    internal virtual PageResources get_PageResources();
    internal int get_Size();
    public static IList`1<Double[]> BezierArc(float x1, float y1, float x2, float y2, float startAng, float extent);
    public static PdfTextArray GetKernArray(string text, BaseFont font);
    public void Add(PdfContentByte other);
    public virtual void AddImage(Image image);
    public virtual void AddImage(Image image, bool inlineImage);
    public virtual void AddImage(Image image, float a, float b, float c, float d, float e, float f);
    public virtual void AddImage(Image image, float a, float b, float c, float d, float e, float f, bool inlineImage);
    public void AddOutline(PdfOutline outline, string name);
    public void AddPsxObject(PdfPsxObject psobject);
    public virtual void AddTemplate(PdfTemplate pdfTemplate, float a, float b, float c, float d, float e, float f);
    public void AddTemplate(PdfTemplate pdfTemplate, float x, float y);
    public void Arc(float x1, float y1, float x2, float y2, float startAng, float extent);
    public void BeginLayer(IPdfOcg layer);
    public void BeginMarkedContentSequence(PdfStructureElement struc);
    public void BeginMarkedContentSequence(PdfName tag, PdfDictionary property, bool inline);
    public void BeginMarkedContentSequence(PdfName tag);
    public void BeginText();
    public void Circle(float x, float y, float r);
    public void Clip();
    public void ClosePath();
    public void ClosePathEoFillStroke();
    public void ClosePathFillStroke();
    public void ClosePathStroke();
    public void ConcatCtm(float a, float b, float c, float d, float e, float f);
    public PdfAppearance CreateAppearance(float width, float height);
    public PdfPatternPainter CreatePattern(float width, float height, float xstep, float ystep);
    public PdfPatternPainter CreatePattern(float width, float height);
    public PdfPatternPainter CreatePattern(float width, float height, float xstep, float ystep, BaseColor color);
    public PdfPatternPainter CreatePattern(float width, float height, BaseColor color);
    public PdfTemplate CreateTemplate(float width, float height);
    public void CurveFromTo(float x1, float y1, float x3, float y3);
    public void CurveTo(double x1, double y1, double x2, double y2, double x3, double y3);
    public void CurveTo(float x1, float y1, float x2, float y2, float x3, float y3);
    public void CurveTo(float x2, float y2, float x3, float y3);
    public void DrawButton(float llx, float lly, float urx, float ury, string text, BaseFont bf, float size);
    public void DrawRadioField(float llx, float lly, float urx, float ury, bool on);
    public void DrawTextField(float llx, float lly, float urx, float ury);
    public void Ellipse(float x1, float y1, float x2, float y2);
    public void EndLayer();
    public void EndMarkedContentSequence();
    public void EndText();
    public void EoClip();
    public void EoFill();
    public void EoFillStroke();
    public void Fill();
    public void FillStroke();
    public float GetEffectiveStringWidth(string text, bool kerned);
    public void LineTo(double x, double y);
    public void LineTo(float x, float y);
    public bool LocalDestination(string name, PdfDestination destination);
    public void LocalGoto(string name, float llx, float lly, float urx, float ury);
    public void MoveText(float x, float y);
    public void MoveTextWithLeading(float x, float y);
    public void MoveTo(double x, double y);
    public void NewlineShowText(string text);
    public void NewlineShowText(float wordSpacing, float charSpacing, string text);
    public void NewlineText();
    public void NewPath();
    public virtual void PaintShading(PdfShading shading);
    public virtual void PaintShading(PdfShadingPattern shading);
    public void Rectangle(float x, float y, float w, float h);
    public void Rectangle(Rectangle rectangle);
    public static void RemoteGoto(string filename, string name, float llx, float lly, float urx, float ury);
    public void RemoteGoto(string filename, int page, float llx, float lly, float urx, float ury);
    public void Reset();
    public void Reset(bool validateContent);
    public virtual void ResetCmykColorFill();
    public virtual void ResetCmykColorStroke();
    public virtual void ResetGrayFill();
    public virtual void ResetGrayStroke();
    public virtual void ResetRgbColorFill();
    public virtual void ResetRgbColorStroke();
    public void RestoreState();
    public void RoundRectangle(float x, float y, float w, float h, float r);
    public void SanityCheck();
    public void SaveState();
    public virtual void SetAction(PdfAction action, float llx, float lly, float urx, float ury);
    public void SetCharacterSpacing(float value);
    public virtual void SetCmykColorFill(int cyan, int magenta, int yellow, int black);
    public virtual void SetCmykColorFillF(float cyan, float magenta, float yellow, float black);
    public virtual void SetCmykColorStroke(int cyan, int magenta, int yellow, int black);
    public virtual void SetCmykColorStrokeF(float cyan, float magenta, float yellow, float black);
    public virtual void SetColorFill(BaseColor value);
    public virtual void SetColorFill(PdfSpotColor sp, float tint);
    public virtual void SetColorStroke(BaseColor value);
    public virtual void SetColorStroke(PdfSpotColor sp, float tint);
    public virtual void SetDefaultColorspace(PdfName name, PdfObject obj);
    public void SetFlatness(float value);
    public virtual void SetFontAndSize(BaseFont bf, float size);
    public virtual void SetGrayFill(float value);
    public virtual void SetGrayStroke(float value);
    public void SetGState(PdfGState gstate);
    public void SetHorizontalScaling(float value);
    public void SetLeading(float v);
    public void SetLineCap(int value);
    public void SetLineDash(float value);
    public void SetLineDash(float unitsOn, float phase);
    public void SetLineDash(float unitsOn, float unitsOff, float phase);
    public void SetLineDash(Single[] array, float phase);
    public void SetLineJoin(int value);
    public void SetLineWidth(float value);
    public void SetLiteral(string s);
    public void SetLiteral(char c);
    public void SetLiteral(float n);
    public void SetMiterLimit(float value);
    public virtual void SetPatternFill(PdfPatternPainter p);
    public virtual void SetPatternFill(PdfPatternPainter p, BaseColor color);
    public virtual void SetPatternFill(PdfPatternPainter p, BaseColor color, float tint);
    public virtual void SetPatternStroke(PdfPatternPainter p, BaseColor color);
    public virtual void SetPatternStroke(PdfPatternPainter p, BaseColor color, float tint);
    public virtual void SetPatternStroke(PdfPatternPainter p);
    public virtual void SetRgbColorFill(int red, int green, int blue);
    public virtual void SetRgbColorFillF(float red, float green, float blue);
    public virtual void SetRgbColorStroke(int red, int green, int blue);
    public virtual void SetRgbColorStrokeF(float red, float green, float blue);
    public virtual void SetShadingFill(PdfShadingPattern shading);
    public virtual void SetShadingStroke(PdfShadingPattern shading);
    public void SetTextMatrix(float a, float b, float c, float d, float x, float y);
    public void SetTextMatrix(float x, float y);
    public void SetTextRenderingMode(int value);
    public void SetTextRise(float value);
    public void SetWordSpacing(float value);
    public void ShowText(string text);
    public void ShowText(PdfTextArray text);
    public void ShowTextAligned(int alignment, string text, float x, float y, float rotation);
    public void ShowTextAlignedKerned(int alignment, string text, float x, float y, float rotation);
    public void ShowTextKerned(string text);
    public void Stroke();
    public Byte[] ToPdf(PdfWriter writer);
    public virtual string ToString();
    public void VariableRectangle(Rectangle rect);
    internal static Byte[] EscapeString(Byte[] b);
    internal static void EscapeString(Byte[] b, ByteBuffer content);
    internal virtual void AddAnnotation(PdfAnnotation annot);
    internal void AddTemplateReference(PdfIndirectReference template, PdfName name, float a, float b, float c, float d, float e, float f);
    internal static void CheckNoPattern(PdfTemplate t);
    internal PdfAppearance CreateAppearance(float width, float height, PdfName forcedName);
    internal PdfTemplate CreateTemplate(float width, float height, PdfName forcedName);
    internal void OutputColorNumbers(BaseColor color, float tint);
    protected virtual void CheckWriter();
    private void beginLayer2(IPdfOcg layer);
    private static bool compareColors(BaseColor c1, BaseColor c2);
    private void helperCmyk(float cyan, float magenta, float yellow, float black);
    private void helperRgb(float red, float green, float blue);
    private void showText2(string text);
    private void showTextAligned(int alignment, string text, float x, float y, float rotation, bool kerned);
}
public class iTextSharp.text.pdf.PdfContentParser : object {
    public static int COMMAND_TYPE;
    private PrTokeniser _tokeniser;
    public PrTokeniser Tokeniser { get; public set; }
    public PdfContentParser(PrTokeniser tokeniser);
    public void set_Tokeniser(PrTokeniser value);
    public PrTokeniser get_Tokeniser();
    public PrTokeniser GetTokeniser();
    public bool NextValidToken();
    public IList`1<PdfObject> Parse(IList`1<PdfObject> ls);
    public PdfArray ReadArray();
    public PdfDictionary ReadDictionary();
    public PdfObject ReadPrObject();
}
public class iTextSharp.text.pdf.PdfContents : PdfStream {
    internal static Byte[] Savestate;
    internal static Byte[] Restorestate;
    internal static Byte[] Rotate90;
    internal static Byte[] Rotate180;
    internal static Byte[] Rotate270;
    internal static Byte[] Rotatefinal;
    internal PdfContents(PdfContentByte under, PdfContentByte content, PdfContentByte text, PdfContentByte secondContent, Rectangle page);
    private static PdfContents();
}
public class iTextSharp.text.pdf.PdfCopy : PdfWriter {
    private bool _rotateContents;
    protected PdfIndirectReference acroForm;
    protected int CurrentObjectNum;
    protected internal PdfArray FieldArray;
    protected internal INullValueDictionary`2<PdfTemplate, object> FieldTemplates;
    protected INullValueDictionary`2<PdfReader, INullValueDictionary`2<RefKey, IndirectReferences>> IndirectMap;
    protected INullValueDictionary`2<RefKey, IndirectReferences> Indirects;
    protected Int32[] NamePtr;
    protected PdfReader Reader;
    public bool RotateContents { get; public set; }
    public PdfCopy(Document document, Stream os);
    public void set_RotateContents(bool value);
    public bool get_RotateContents();
    public virtual void AddAnnotation(PdfAnnotation annot);
    public void AddPage(PdfImportedPage iPage);
    public void AddPage(Rectangle rect, int rotation);
    public virtual void Close();
    public void CopyAcroForm(PdfReader reader);
    public PageStamp CreatePageStamp(PdfImportedPage iPage);
    public virtual void FreeReader(PdfReader reader);
    public virtual PdfImportedPage GetImportedPage(PdfReader reader, int pageNumber);
    internal virtual PdfIndirectReference Add(PdfPage page, PdfContents contents);
    protected PdfArray CopyArray(PdfArray inp);
    protected PdfDictionary CopyDictionary(PdfDictionary inp);
    protected virtual PdfIndirectReference CopyIndirect(PrIndirectReference inp);
    protected PdfObject CopyObject(PdfObject inp);
    protected PdfStream CopyStream(PrStream inp);
    protected virtual PdfDictionary GetCatalog(PdfIndirectReference rootObj);
    protected int SetFromIPage(PdfImportedPage iPage);
    protected void SetFromReader(PdfReader reader);
    private void addFieldResources(PdfDictionary catalog);
}
public class iTextSharp.text.pdf.PdfCopyFields : object {
    private PdfCopyFieldsImp _fc;
    public bool FullCompression { get; }
    unknown IList`1<INullValueDictionary`2<string, object>> Outlines {public set; }
    public PdfWriter Writer { get; }
    unknown int ViewerPreferences {public set; }
    public PdfCopyFields(Stream os);
    public PdfCopyFields(Stream os, char pdfVersion);
    public bool get_FullCompression();
    public void set_Outlines(IList`1<INullValueDictionary`2<string, object>> value);
    public PdfWriter get_Writer();
    public sealed virtual void SetEncryption(Byte[] userPassword, Byte[] ownerPassword, int permissions, int encryptionType);
    public sealed virtual void SetEncryption(X509Certificate[] certs, Int32[] permissions, int encryptionType);
    public sealed virtual void set_ViewerPreferences(int value);
    public sealed virtual void AddViewerPreference(PdfName key, PdfObject value);
    public void AddDocument(PdfReader reader);
    public void AddDocument(PdfReader reader, ICollection`1<int> pagesToKeep);
    public void AddDocument(PdfReader reader, string ranges);
    public void AddJavaScript(string js);
    public void Close();
    public void Open();
    public void SetEncryption(Byte[] userPassword, Byte[] ownerPassword, int permissions, bool strength128Bits);
    public void SetEncryption(bool strength, string userPassword, string ownerPassword, int permissions);
    public void SetFullCompression();
}
internal class iTextSharp.text.pdf.PdfCopyFieldsImp : PdfWriter {
    private static int _zero;
    protected internal static INullValueDictionary`2<PdfName, int> FieldKeys;
    protected internal static INullValueDictionary`2<PdfName, int> WidgetKeys;
    private static PdfName _iTextTag;
    private List`1<string> _calculationOrder;
    private List`1<object> _calculationOrderRefs;
    private bool _closing;
    private bool _hasSignature;
    private INullValueDictionary`2<PdfArray, List`1<int>> _tabOrder;
    internal List`1<AcroFields> Fields;
    internal INullValueDictionary`2<string, object> FieldTree;
    internal RandomAccessFileOrArray File;
    internal PdfDictionary Form;
    internal Document Nd;
    internal List`1<PdfDictionary> PageDics;
    internal List`1<PdfIndirectReference> PageRefs;
    internal INullValueDictionary`2<PdfReader, NullValueDictionary`2<int, int>> Pages2Intrefs;
    internal List`1<PdfReader> Readers;
    internal INullValueDictionary`2<PdfReader, NullValueDictionary`2<int, int>> Readers2Intrefs;
    internal PdfDictionary Resources;
    internal INullValueDictionary`2<PdfReader, NullValueDictionary`2<int, int>> Visited;
    private static PdfCopyFieldsImp();
    internal PdfCopyFieldsImp(Stream os);
    internal PdfCopyFieldsImp(Stream os, char pdfVersion);
    public virtual void Close();
    public virtual PdfIndirectReference GetPageReference(int page);
    public void OpenDoc();
    internal void AddDocument(PdfReader reader, ICollection`1<int> pagesToKeep);
    internal void AddDocument(PdfReader reader);
    internal static void AddPageOffsetToField(INullValueDictionary`2<string, Item> fd, int pageOffset);
    internal void CreateWidgets(IList`1<object> list, Item item);
    internal virtual RandomAccessFileOrArray GetReaderFile(PdfReader reader);
    internal void MergeField(string name, Item item);
    internal virtual void MergeFields();
    internal void MergeWithMaster(INullValueDictionary`2<string, Item> fd);
    internal void Propagate(PdfObject obj, PdfIndirectReference refo, bool restricted);
    protected internal virtual int GetNewObjectNumber(PdfReader reader, int number, int generation);
    protected internal bool IsPage(PrIndirectReference refi);
    protected internal bool IsVisited(PrIndirectReference refi);
    protected internal bool IsVisited(PdfReader reader, int number, int generation);
    protected internal bool SetVisited(PrIndirectReference refi);
    protected internal void UpdateCalculationOrder(PdfReader reader);
    protected PdfArray BranchForm(INullValueDictionary`2<string, object> level, PdfIndirectReference parent, string fname);
    protected void CloseIt();
    protected void CreateAcroForms();
    protected virtual PdfDictionary GetCatalog(PdfIndirectReference rootObj);
    protected PdfIndirectReference GetNewReference(PrIndirectReference refi);
    private static string getCoName(PdfReader reader, PrIndirectReference refi);
    private void adjustTabOrder(PdfArray annots, PdfIndirectReference ind, PdfNumber nn);
}
public class iTextSharp.text.pdf.PdfCopyForms : object {
    private PdfCopyFormsImp _fc;
    public bool FullCompression { get; }
    unknown IList`1<INullValueDictionary`2<string, object>> Outlines {public set; }
    public PdfWriter Writer { get; }
    unknown int ViewerPreferences {public set; }
    public PdfCopyForms(Stream os);
    public bool get_FullCompression();
    public void set_Outlines(IList`1<INullValueDictionary`2<string, object>> value);
    public PdfWriter get_Writer();
    public sealed virtual void SetEncryption(Byte[] userPassword, Byte[] ownerPassword, int permissions, int encryptionType);
    public sealed virtual void SetEncryption(X509Certificate[] certs, Int32[] permissions, int encryptionType);
    public sealed virtual void set_ViewerPreferences(int value);
    public sealed virtual void AddViewerPreference(PdfName key, PdfObject value);
    public void AddDocument(PdfReader reader);
    public void AddDocument(PdfReader reader, ICollection`1<int> pagesToKeep);
    public void AddDocument(PdfReader reader, string ranges);
    public void AddJavaScript(string js);
    public void Close();
    public void CopyDocumentFields(PdfReader reader);
    public void Open();
    public void SetEncryption(Byte[] userPassword, Byte[] ownerPassword, int permissions, bool strength128Bits);
    public void SetEncryption(bool strength, string userPassword, string ownerPassword, int permissions);
    public void SetFullCompression();
}
internal class iTextSharp.text.pdf.PdfCopyFormsImp : PdfCopyFieldsImp {
    internal PdfCopyFormsImp(Stream os);
    public void CopyDocumentFields(PdfReader reader);
    internal virtual void MergeFields();
}
public class iTextSharp.text.pdf.PdfDashPattern : PdfArray {
    private float _dash;
    private float _gap;
    private float _phase;
    public PdfDashPattern(float dash);
    public PdfDashPattern(float dash, float gap);
    public PdfDashPattern(float dash, float gap, float phase);
    public void Add(float n);
    public virtual void ToPdf(PdfWriter writer, Stream os);
}
public class iTextSharp.text.pdf.PdfDate : PdfString {
    public PdfDate(DateTime d);
    public static DateTime Decode(string date);
    public static string GetW3CDate(string d);
    public string GetW3CDate();
    private static string setLength(int i, int length);
}
public class iTextSharp.text.pdf.PdfDestination : PdfArray {
    public static int FIT;
    public static int FITB;
    public static int FITBH;
    public static int FITBV;
    public static int FITH;
    public static int FITR;
    public static int FITV;
    public static int XYZ;
    private bool _status;
    public PdfDestination(int type);
    public PdfDestination(int type, float parameter);
    public PdfDestination(int type, float left, float top, float zoom);
    public PdfDestination(int type, float left, float bottom, float right, float top);
    public bool AddPage(PdfIndirectReference page);
    public bool HasPage();
}
public class iTextSharp.text.pdf.PdfDeveloperExtension : object {
    public static PdfDeveloperExtension Adobe17Extensionlevel3;
    protected PdfName baseversion;
    protected int extensionLevel;
    protected PdfName prefix;
    public PdfName Baseversion { get; }
    public int ExtensionLevel { get; }
    public PdfName Prefix { get; }
    public PdfDeveloperExtension(PdfName prefix, PdfName baseversion, int extensionLevel);
    private static PdfDeveloperExtension();
    public PdfName get_Baseversion();
    public int get_ExtensionLevel();
    public PdfName get_Prefix();
    public PdfDictionary GetDeveloperExtensions();
}
public class iTextSharp.text.pdf.PdfDictionary : PdfObject {
    public static PdfName Catalog;
    public static PdfName Font;
    public static PdfName Outlines;
    public static PdfName Page;
    public static PdfName Pages;
    private PdfName _dictionaryType;
    protected internal INullValueDictionary`2<PdfName, PdfObject> HashMap;
    public ICollection`1<PdfName> Keys { get; }
    public int Size { get; }
    public PdfDictionary(PdfName type);
    private static PdfDictionary();
    public ICollection`1<PdfName> get_Keys();
    public int get_Size();
    public bool Contains(PdfName key);
    public PdfObject Get(PdfName key);
    public PdfArray GetAsArray(PdfName key);
    public PdfBoolean GetAsBoolean(PdfName key);
    public PdfDictionary GetAsDict(PdfName key);
    public PdfIndirectReference GetAsIndirectObject(PdfName key);
    public PdfName GetAsName(PdfName key);
    public PdfNumber GetAsNumber(PdfName key);
    public PdfStream GetAsStream(PdfName key);
    public PdfString GetAsString(PdfName key);
    public PdfObject GetDirectObject(PdfName key);
    public virtual IEnumerator`1<KeyValuePair`2<PdfName, PdfObject>> GetEnumerator();
    public bool IsCatalog();
    public bool IsFont();
    public bool IsOutlineTree();
    public bool IsPage();
    public bool IsPages();
    public void Merge(PdfDictionary other);
    public void MergeDifferent(PdfDictionary other);
    public void Put(PdfName key, PdfObject value);
    public void PutEx(PdfName key, PdfObject value);
    public void Remove(PdfName key);
    public virtual void ToPdf(PdfWriter writer, Stream os);
    public virtual string ToString();
}
public class iTextSharp.text.pdf.PdfDocument : Document {
    internal static string hangingPunctuation;
    private int _jsCounter;
    protected internal PdfDictionary AdditionalActions;
    protected internal int Alignment;
    protected internal PdfAction AnchorAction;
    internal PdfAnnotationsImp AnnotationsImp;
    protected INullValueDictionary`2<string, PdfRectangle> BoxSize;
    protected internal PdfCollection collection;
    protected internal PdfOutline CurrentOutline;
    protected internal INullValueDictionary`2<string, PdfObject> DocumentFileAttachment;
    protected internal INullValueDictionary`2<string, PdfObject> DocumentLevelJs;
    protected int duration;
    protected internal bool FirstPageEvent;
    protected internal PdfContentByte Graphics;
    protected internal float ImageEnd;
    protected internal Image ImageWait;
    protected internal Indentation indentation;
    protected internal PdfInfo info;
    protected bool IsSectionTitle;
    protected internal int LastElementType;
    protected internal float leading;
    protected int LeadingCount;
    protected internal PdfLine Line;
    protected internal IList`1<PdfLine> Lines;
    protected internal OrderedTree LocalDestinations;
    protected int MarkPoint;
    protected float NextMarginBottom;
    protected float NextMarginLeft;
    protected float NextMarginRight;
    protected float NextMarginTop;
    protected Rectangle NextPageSize;
    protected internal PdfAction OpenActionAction;
    protected internal string OpenActionName;
    protected PdfDictionary PageAa;
    protected internal bool pageEmpty;
    protected internal PdfPageLabels pageLabels;
    protected internal PageResources pageResources;
    protected internal PdfOutline rootOutline;
    protected internal bool strictImageSequence;
    protected internal PdfContentByte Text;
    protected internal int TextEmptySize;
    protected INullValueDictionary`2<string, PdfRectangle> ThisBoxSize;
    protected internal PdfIndirectReference Thumb;
    protected PdfTransition transition;
    protected PdfViewerPreferencesImp viewerPreferences;
    protected internal PdfWriter Writer;
    protected Byte[] xmpMetadata;
    [CompilerGeneratedAttribute]
private float <CurrentHeight>k__BackingField;
    public float CurrentHeight { get; private set; }
    public PdfAcroForm AcroForm { get; }
    unknown PdfCollection Collection {public set; }
    unknown HeaderFooter Footer {public set; }
    unknown HeaderFooter Header {public set; }
    public float Leading { get; public set; }
    unknown int PageCount {public set; }
    public PdfOutline RootOutline { get; }
    unknown Byte[] XmpMetadata {public set; }
    unknown Rectangle CropBoxSize {internal set; }
    unknown int Duration {internal set; }
    internal PdfInfo Info { get; }
    unknown bool PageEmpty {internal set; }
    unknown PdfPageLabels PageLabels {internal set; }
    internal PageResources PageResources { get; }
    unknown int SigFlags {internal set; }
    internal bool StrictImageSequence { get; internal set; }
    unknown Image Thumbnail {internal set; }
    unknown PdfTransition Transition {internal set; }
    unknown int ViewerPreferences {internal set; }
    protected internal float IndentBottom { get; }
    protected internal float IndentLeft { get; }
    protected internal float IndentRight { get; }
    protected internal float IndentTop { get; }
    [CompilerGeneratedAttribute]
public float get_CurrentHeight();
    [CompilerGeneratedAttribute]
private void set_CurrentHeight(float value);
    public PdfAcroForm get_AcroForm();
    public void set_Collection(PdfCollection value);
    public virtual void set_Footer(HeaderFooter value);
    public virtual void set_Header(HeaderFooter value);
    public float get_Leading();
    public void set_Leading(float value);
    public virtual void set_PageCount(int value);
    public PdfOutline get_RootOutline();
    public void set_XmpMetadata(Byte[] value);
    internal void set_CropBoxSize(Rectangle value);
    internal void set_Duration(int value);
    internal PdfInfo get_Info();
    internal void set_PageEmpty(bool value);
    internal void set_PageLabels(PdfPageLabels value);
    internal PageResources get_PageResources();
    internal void set_SigFlags(int value);
    internal void set_StrictImageSequence(bool value);
    internal bool get_StrictImageSequence();
    internal void set_Thumbnail(Image value);
    internal void set_Transition(PdfTransition value);
    internal void set_ViewerPreferences(int value);
    protected internal float get_IndentBottom();
    protected internal float get_IndentLeft();
    protected internal float get_IndentRight();
    protected internal float get_IndentTop();
    public virtual bool Add(IElement element);
    public void ClearTextWrap();
    public virtual void Close();
    public float GetVerticalPosition(bool ensureNewLine);
    public virtual bool NewPage();
    public virtual void Open();
    public virtual void ResetFooter();
    public virtual void ResetHeader();
    public virtual void ResetPageCount();
    public virtual bool SetMarginMirroring(bool marginMirroring);
    public virtual bool SetMarginMirroringTopBottom(bool marginMirroringTopBottom);
    public virtual bool SetMargins(float marginLeft, float marginRight, float marginTop, float marginBottom);
    public virtual bool SetPageSize(Rectangle pageSize);
    internal void AddAdditionalAction(PdfName actionType, PdfAction action);
    internal void AddAnnotation(PdfAnnotation annot);
    internal void AddCalculationOrder(PdfFormField formField);
    internal void AddFileAttachment(string description, PdfFileSpecification fs);
    internal void AddJavaScript(PdfAction js);
    internal void AddJavaScript(string name, PdfAction js);
    internal void AddOutline(PdfOutline outline, string name);
    internal void AddPTable(PdfPTable ptable);
    internal void AddViewerPreference(PdfName key, PdfObject value);
    internal void AddWriter(PdfWriter writer);
    internal void CalculateOutlineCount();
    internal bool FitsPage(PdfPTable table, float margin);
    internal float GetBottom(Table table);
    internal Rectangle GetBoxSize(string boxName);
    internal PdfCatalog GetCatalog(PdfIndirectReference pages);
    internal INullValueDictionary`2<string, PdfObject> GetDocumentFileAttachment();
    internal INullValueDictionary`2<string, PdfObject> GetDocumentLevelJs();
    internal PdfAction GetLocalGotoAction(string name);
    internal int GetMarkPoint();
    internal void IncMarkPoint();
    internal bool LocalDestination(string name, PdfDestination destination);
    internal void LocalGoto(string name, float llx, float lly, float urx, float ury);
    internal void OutlineTree(PdfOutline outline);
    internal void RemoteGoto(string filename, string name, float llx, float lly, float urx, float ury);
    internal void RemoteGoto(string filename, int page, float llx, float lly, float urx, float ury);
    internal void SetAction(PdfAction action, float llx, float lly, float urx, float ury);
    internal void SetBoxSize(string boxName, Rectangle size);
    internal void SetOpenAction(string name);
    internal void SetOpenAction(PdfAction action);
    internal void SetPageAction(PdfName actionType, PdfAction action);
    internal static void TraverseOutlineCount(PdfOutline outline);
    internal void WriteLineToContent(PdfLine line, PdfContentByte text, PdfContentByte graphics, Object[] currentValues, float ratio);
    internal void WriteOutlines();
    protected internal void Add(Image image);
    protected internal void AddSpacing(float extraspace, float oldleading, Font f);
    protected internal void AnalyzeRow(IList`1<IList`1<PdfCell>> rows, RenderingContext ctx);
    protected internal void CarriageReturn();
    protected internal static void ConsumeRowspan(IList`1<PdfCell> row, RenderingContext ctx);
    protected internal void DoFooter();
    protected internal void DoHeader();
    protected internal void EnsureNewLine();
    protected internal static IList`1<IList`1<PdfCell>> ExtractRows(IList`1<PdfCell> cells, RenderingContext ctx);
    protected internal float FlushLines();
    protected internal void InitPage();
    protected internal static bool MayBeRemoved(IList`1<PdfCell> row);
    protected internal void NewLine();
    protected internal void RenderCells(RenderingContext ctx, IList`1<PdfCell> cells, bool hasToFit);
    protected internal void SetNewPageSizeAndMargins();
    private void addPdfTable(Table t);
}
public class iTextSharp.text.pdf.PdfEFStream : PdfStream {
    public PdfEFStream(Stream inp, PdfWriter writer);
    public PdfEFStream(Byte[] fileStore);
    public virtual void ToPdf(PdfWriter writer, Stream os);
}
public static class iTextSharp.text.pdf.PdfEncodings : object {
    private static int CIDCHAR;
    private static int CIDNONE;
    private static int CIDRANGE;
    public static Byte[][] CrlfCidNewline;
    internal static INullValueDictionary`2<string, Char[][]> Cmaps;
    internal static INullValueDictionary`2<string, IExtraEncoding> ExtraEncodings;
    internal static NullValueDictionary`2<int, int> PdfEncoding;
    internal static Char[] PdfEncodingByteToChar;
    internal static NullValueDictionary`2<int, int> Winansi;
    internal static Char[] WinansiByteToChar;
    private static PdfEncodings();
    public static void AddExtraEncoding(string name, IExtraEncoding enc);
    public static void ClearCmap(string name);
    public static string ConvertCmap(string name, Byte[] seq);
    public static string ConvertCmap(string name, Byte[] seq, int start, int length);
    public static Byte[] ConvertToBytes(string text, string encoding);
    public static Byte[] ConvertToBytes(char char1, string encoding);
    public static string ConvertToString(Byte[] bytes, string encoding);
    public static bool IsPdfDocEncoding(string text);
    public static void LoadCmap(string name, Byte[][] newline);
    internal static void BreakLong(long n, int size, Byte[] seqs);
    internal static string DecodeSequence(Byte[] seq, int start, int length, Char[][] planes);
    internal static void EncodeSequence(int size, Byte[] seqs, char cid, IList`1<Char[]> planes);
    internal static void EncodeStream(Stream inp, IList`1<Char[]> planes);
    internal static Char[][] ReadCmap(string name, Byte[][] newline);
    internal static void ReadCmap(string name, IList`1<Char[]> planes);
}
public class iTextSharp.text.pdf.PdfEncryption : object {
    public static int AES_128;
    public static int STANDARD_ENCRYPTION_128;
    public static int AES_256_V3;
    public static int STANDARD_ENCRYPTION_40;
    internal static Byte[] MetadataPad;
    internal static long Seq;
    private static Byte[] _pad;
    private static Byte[] _salt;
    private ArcfourEncryption _rc4;
    private int _cryptoMode;
    private bool _embeddedFilesOnly;
    private bool _encryptMetadata;
    private int _keyLength;
    private Byte[] _oeKey;
    private Byte[] _perms;
    private int _revision;
    private Byte[] _ueKey;
    internal Byte[] DocumentId;
    internal Byte[] Extra;
    internal Byte[] Key;
    internal int KeySize;
    internal Byte[] Mkey;
    internal Byte[] OwnerKey;
    internal int Permissions;
    protected PdfPublicKeySecurityHandler PublicKeyHandler;
    internal Byte[] UserKey;
    public PdfObject FileId { get; }
    public PdfEncryption(PdfEncryption enc);
    private static PdfEncryption();
    public PdfObject get_FileId();
    public static Byte[] CreateDocumentId();
    public static PdfObject CreateInfoId(Byte[] id);
    public void AddRecipient(X509Certificate cert, int permission);
    public int CalculateStreamSize(int n);
    public Byte[] ComputeUserPassword(Byte[] ownerPassword);
    public Byte[] DecryptByteArray(Byte[] b);
    public Byte[] EncryptByteArray(Byte[] b);
    public int GetCryptoMode();
    public StandardDecryption GetDecryptor();
    public PdfDictionary GetEncryptionDictionary();
    public OutputStreamEncryption GetEncryptionStream(Stream os);
    public bool IsEmbeddedFilesOnly();
    public bool IsMetadataEncrypted();
    public void SetCryptoMode(int mode, int kl);
    public void SetHashKey(int number, int generation);
    public void SetupAllKeys(Byte[] userPassword, Byte[] ownerPassword, int permissions);
    public void SetupByEncryptionKey(Byte[] key, int keyLength);
    public void SetupByOwnerPassword(Byte[] documentId, Byte[] ownerPassword, Byte[] userKey, Byte[] ownerKey, int permissions);
    public void SetupByUserPassword(Byte[] documentId, Byte[] userPassword, Byte[] ownerKey, int permissions);
    private Byte[] ComputeOwnerKey(Byte[] userPad, Byte[] ownerPad);
    private static Byte[] PadPassword(Byte[] userPassword);
    private void SetupByOwnerPad(Byte[] documentId, Byte[] ownerPad, Byte[] userKey, Byte[] ownerKey, int permissions);
    private void SetupByUserPad(Byte[] documentId, Byte[] userPad, Byte[] ownerKey, int permissions);
    private void SetupGlobalEncryptionKey(Byte[] documentId, Byte[] userPad, Byte[] ownerKey, int permissions);
    private void SetupUserKey();
    public void SetupByOwnerPassword(Byte[] documentId, Byte[] ownerPassword, Byte[] uValue, Byte[] ueValue, Byte[] oValue, Byte[] oeValue, int permissions);
    public void SetupByUserPassword(Byte[] documentId, Byte[] userPassword, Byte[] uValue, Byte[] ueValue, Byte[] oValue, Byte[] oeValue, int permissions);
    public bool DecryptAndCheckPerms(Byte[] permsValue);
    public static Byte[] HashAlg2B(Byte[] input, Byte[] salt, Byte[] userKey);
    private void ComputeUAndUeAlg8(Byte[] userPassword);
    private void ComputeOAndOeAlg9(Byte[] ownerPassword);
    private void ComputePermsAlg10(int permissions);
}
public static class iTextSharp.text.pdf.PdfEncryptor : object {
    public static void Encrypt(PdfReader reader, Stream os, Byte[] userPassword, Byte[] ownerPassword, int permissions, bool strength128Bits);
    public static void Encrypt(PdfReader reader, Stream os, Byte[] userPassword, Byte[] ownerPassword, int permissions, bool strength128Bits, INullValueDictionary`2<string, string> newInfo);
    public static void Encrypt(PdfReader reader, Stream os, bool strength, string userPassword, string ownerPassword, int permissions);
    public static void Encrypt(PdfReader reader, Stream os, bool strength, string userPassword, string ownerPassword, int permissions, INullValueDictionary`2<string, string> newInfo);
    public static void Encrypt(PdfReader reader, Stream os, int type, string userPassword, string ownerPassword, int permissions, INullValueDictionary`2<string, string> newInfo);
    public static void Encrypt(PdfReader reader, Stream os, int type, string userPassword, string ownerPassword, int permissions);
    public static string GetPermissionsVerbose(int permissions);
    public static bool IsAssemblyAllowed(int permissions);
    public static bool IsCopyAllowed(int permissions);
    public static bool IsDegradedPrintingAllowed(int permissions);
    public static bool IsFillInAllowed(int permissions);
    public static bool IsModifyAnnotationsAllowed(int permissions);
    public static bool IsModifyContentsAllowed(int permissions);
    public static bool IsPrintingAllowed(int permissions);
    public static bool IsScreenReadersAllowed(int permissions);
}
public class iTextSharp.text.pdf.PdfException : DocumentException {
    public PdfException(string message);
    public PdfException(string message, Exception innerException);
}
public class iTextSharp.text.pdf.PdfFileSpecification : PdfDictionary {
    protected PdfIndirectReference Refi;
    protected PdfWriter Writer;
    unknown Byte[] MultiByteFileName {public set; }
    public PdfIndirectReference Reference { get; }
    unknown bool Volatile {public set; }
    public void set_MultiByteFileName(Byte[] value);
    public PdfIndirectReference get_Reference();
    public void set_Volatile(bool value);
    public static PdfFileSpecification FileEmbedded(PdfWriter writer, string filePath, string fileDisplay, Byte[] fileStore);
    public static PdfFileSpecification FileEmbedded(PdfWriter writer, string filePath, string fileDisplay, Byte[] fileStore, int compressionLevel);
    public static PdfFileSpecification FileEmbedded(PdfWriter writer, string filePath, string fileDisplay, Byte[] fileStore, bool compress);
    public static PdfFileSpecification FileEmbedded(PdfWriter writer, string filePath, string fileDisplay, Byte[] fileStore, bool compress, string mimeType, PdfDictionary fileParameter);
    public static PdfFileSpecification FileEmbedded(PdfWriter writer, string filePath, string fileDisplay, Byte[] fileStore, string mimeType, PdfDictionary fileParameter, int compressionLevel);
    public static PdfFileSpecification FileExtern(PdfWriter writer, string filePath);
    public static PdfFileSpecification Url(PdfWriter writer, string url);
    public void AddCollectionItem(PdfCollectionItem ci);
    public void AddDescription(string description, bool unicode);
    public void SetUnicodeFileName(string filename, bool unicode);
}
public class iTextSharp.text.pdf.PdfFont : object {
    private float _size;
    protected float HScale;
    protected Image image;
    [CompilerGeneratedAttribute]
private BaseFont <Font>k__BackingField;
    internal static PdfFont DefaultFont { get; }
    internal BaseFont Font { get; }
    unknown float HorizontalScaling {internal set; }
    unknown Image Image {internal set; }
    internal float Size { get; }
    internal PdfFont(BaseFont bf, float size);
    internal static PdfFont get_DefaultFont();
    [CompilerGeneratedAttribute]
internal BaseFont get_Font();
    internal void set_HorizontalScaling(float value);
    internal void set_Image(Image value);
    internal float get_Size();
    public sealed virtual int CompareTo(object obj);
    internal float Width();
    internal float Width(int character);
    internal float Width(string s);
}
public class iTextSharp.text.pdf.PdfFormField : PdfAnnotation {
    public static int FF_COMB;
    public static int FF_COMBO;
    public static int FF_DONOTSCROLL;
    public static int FF_DONOTSPELLCHECK;
    public static int FF_EDIT;
    public static int FF_FILESELECT;
    public static int FF_MULTILINE;
    public static int FF_MULTISELECT;
    public static int FF_NO_EXPORT;
    public static int FF_NO_TOGGLE_TO_OFF;
    public static int FF_PASSWORD;
    public static int FF_PUSHBUTTON;
    public static int FF_RADIO;
    public static int FF_RADIOSINUNISON;
    public static int FF_READ_ONLY;
    public static int FF_REQUIRED;
    public static int MK_CAPTION_ABOVE;
    public static int MK_CAPTION_BELOW;
    public static int MK_CAPTION_LEFT;
    public static int MK_CAPTION_OVERLAID;
    public static int MK_CAPTION_RIGHT;
    public static int MK_NO_CAPTION;
    public static int MK_NO_ICON;
    public static bool MULTILINE;
    public static bool PASSWORD;
    public static bool PLAINTEXT;
    public static int Q_CENTER;
    public static int Q_LEFT;
    public static int Q_RIGHT;
    public static bool SINGLELINE;
    public static PdfName IfScaleAlways;
    public static PdfName IfScaleAnamorphic;
    public static PdfName IfScaleBigger;
    public static PdfName IfScaleNever;
    public static PdfName IfScaleProportional;
    public static PdfName IfScaleSmaller;
    public static PdfName[] MergeTarget;
    internal List`1<PdfFormField> kids;
    internal PdfFormField parent;
    unknown int Button {public set; }
    unknown string DefaultValueAsName {public set; }
    unknown string DefaultValueAsString {public set; }
    unknown string FieldName {public set; }
    public IList`1<PdfFormField> Kids { get; }
    unknown string MappingName {public set; }
    public PdfFormField Parent { get; }
    unknown int Quadding {public set; }
    unknown string UserName {public set; }
    unknown string ValueAsName {public set; }
    unknown PdfSignature ValueAsSig {public set; }
    unknown string ValueAsString {public set; }
    public PdfFormField(PdfWriter writer, float llx, float lly, float urx, float ury, PdfAction action);
    internal PdfFormField(PdfWriter writer);
    private static PdfFormField();
    public void set_Button(int value);
    public void set_DefaultValueAsName(string value);
    public void set_DefaultValueAsString(string value);
    public void set_FieldName(string value);
    public IList`1<PdfFormField> get_Kids();
    public void set_MappingName(string value);
    public PdfFormField get_Parent();
    public void set_Quadding(int value);
    public void set_UserName(string value);
    public void set_ValueAsName(string value);
    public void set_ValueAsSig(PdfSignature value);
    public void set_ValueAsString(string value);
    public static PdfFormField CreateCheckBox(PdfWriter writer);
    public static PdfFormField CreateCombo(PdfWriter writer, bool edit, String[] options, int topIndex);
    public static PdfFormField CreateCombo(PdfWriter writer, bool edit, String[0...,0...] options, int topIndex);
    public static PdfFormField CreateEmpty(PdfWriter writer);
    public static PdfFormField CreateList(PdfWriter writer, String[] options, int topIndex);
    public static PdfFormField CreateList(PdfWriter writer, String[0...,0...] options, int topIndex);
    public static PdfFormField CreatePushButton(PdfWriter writer);
    public static PdfFormField CreateRadioButton(PdfWriter writer, bool noToggleToOff);
    public static PdfFormField CreateSignature(PdfWriter writer);
    public static PdfFormField CreateTextField(PdfWriter writer, bool multiline, bool password, int maxLen);
    public void AddKid(PdfFormField field);
    public int SetFieldFlags(int flags);
    public virtual void SetUsed();
    public void SetWidget(Rectangle rect, PdfName highlight);
    internal static void MergeResources(PdfDictionary result, PdfDictionary source, PdfStamperImp writer);
    internal static void MergeResources(PdfDictionary result, PdfDictionary source);
    protected static PdfFormField CreateButton(PdfWriter writer, int flags);
    protected static PdfFormField CreateChoice(PdfWriter writer, int flags, PdfArray options, int topIndex);
    protected static PdfArray ProcessOptions(String[] options);
    protected static PdfArray ProcessOptions(String[0...,0...] options);
}
public class iTextSharp.text.pdf.PdfFormXObject : PdfStream {
    public static PdfLiteral Matrix;
    public static PdfNumber One;
    public static PdfNumber Zero;
    internal PdfFormXObject(PdfTemplate template, int compressionLevel);
    private static PdfFormXObject();
}
public class iTextSharp.text.pdf.PdfFunction : object {
    protected PdfDictionary Dictionary;
    protected PdfIndirectReference reference;
    protected PdfWriter Writer;
    internal PdfIndirectReference Reference { get; }
    protected PdfFunction(PdfWriter writer);
    internal PdfIndirectReference get_Reference();
    public static PdfFunction Type0(PdfWriter writer, Single[] domain, Single[] range, Int32[] size, int bitsPerSample, int order, Single[] encode, Single[] decode, Byte[] stream);
    public static PdfFunction Type2(PdfWriter writer, Single[] domain, Single[] range, Single[] c0, Single[] c1, float n);
    public static PdfFunction Type3(PdfWriter writer, Single[] domain, Single[] range, PdfFunction[] functions, Single[] bounds, Single[] encode);
    public static PdfFunction Type4(PdfWriter writer, Single[] domain, Single[] range, string postscript);
}
public class iTextSharp.text.pdf.PdfGState : PdfDictionary {
    public static PdfName BmColorburn;
    public static PdfName BmColordodge;
    public static PdfName BmCompatible;
    public static PdfName BmDarken;
    public static PdfName BmDifference;
    public static PdfName BmExclusion;
    public static PdfName BmHardlight;
    public static PdfName BmLighten;
    public static PdfName BmMultiply;
    public static PdfName BmNormal;
    public static PdfName BmOverlay;
    public static PdfName BmScreen;
    public static PdfName BmSoftlight;
    unknown bool AlphaIsShape {public set; }
    unknown PdfName BlendMode {public set; }
    unknown float FillOpacity {public set; }
    unknown int OverPrintMode {public set; }
    unknown bool OverPrintNonStroking {public set; }
    unknown bool OverPrintStroking {public set; }
    unknown float StrokeOpacity {public set; }
    unknown bool TextKnockout {public set; }
    private static PdfGState();
    public void set_AlphaIsShape(bool value);
    public void set_BlendMode(PdfName value);
    public void set_FillOpacity(float value);
    public void set_OverPrintMode(int value);
    public void set_OverPrintNonStroking(bool value);
    public void set_OverPrintStroking(bool value);
    public void set_StrokeOpacity(float value);
    public void set_TextKnockout(bool value);
}
public class iTextSharp.text.pdf.PdfIccBased : PdfStream {
    public PdfIccBased(IccProfile profile);
    public PdfIccBased(IccProfile profile, int compressionLevel);
}
public class iTextSharp.text.pdf.PdfImage : PdfStream {
    internal static int TRANSFERSIZE;
    protected PdfName name;
    public PdfName Name { get; }
    public PdfImage(Image image, string name, PdfIndirectReference maskRef);
    public PdfName get_Name();
    internal static void TransferBytes(Stream inp, Stream outp, int len);
    protected void ImportAll(PdfImage dup);
}
public class iTextSharp.text.pdf.PdfImportedPage : PdfTemplate {
    internal int pageNumber;
    internal PdfReaderInstance ReaderInstance;
    public PdfContentByte Duplicate { get; }
    public PdfImportedPage FromReader { get; }
    unknown PdfTransparencyGroup Group {public set; }
    public int PageNumber { get; }
    internal PdfReaderInstance PdfReaderInstance { get; }
    internal PdfObject Resources { get; }
    internal PdfImportedPage(PdfReaderInstance readerInstance, PdfWriter writer, int pageNumber);
    public virtual PdfContentByte get_Duplicate();
    public PdfImportedPage get_FromReader();
    public virtual void set_Group(PdfTransparencyGroup value);
    public int get_PageNumber();
    internal PdfReaderInstance get_PdfReaderInstance();
    internal virtual PdfObject get_Resources();
    public virtual void AddImage(Image image, float a, float b, float c, float d, float e, float f);
    public virtual void AddTemplate(PdfTemplate pdfTemplate, float a, float b, float c, float d, float e, float f);
    public virtual void SetColorFill(PdfSpotColor sp, float tint);
    public virtual void SetColorStroke(PdfSpotColor sp, float tint);
    public virtual void SetFontAndSize(BaseFont bf, float size);
    internal virtual PdfStream GetFormXObject(int compressionLevel);
    internal static void ThrowError();
}
public class iTextSharp.text.pdf.PdfIndirectObject : object {
    internal static Byte[] Endobj;
    internal static int Sizeobj;
    internal static Byte[] Startobj;
    protected int Generation;
    protected int Number;
    internal PdfObject Objecti;
    internal PdfWriter Writer;
    public PdfIndirectReference IndirectReference { get; }
    private static PdfIndirectObject();
    internal PdfIndirectObject(int number, PdfObject objecti, PdfWriter writer);
    internal PdfIndirectObject(PdfIndirectReference refi, PdfObject objecti, PdfWriter writer);
    internal PdfIndirectObject(int number, int generation, PdfObject objecti, PdfWriter writer);
    public PdfIndirectReference get_IndirectReference();
    internal void WriteTo(Stream os);
}
public class iTextSharp.text.pdf.PdfIndirectReference : PdfObject {
    protected int generation;
    protected int number;
    public int Generation { get; }
    public int Number { get; }
    internal PdfIndirectReference(int type, int number, int generation);
    internal PdfIndirectReference(int type, int number);
    public int get_Generation();
    public int get_Number();
    public virtual string ToString();
}
public class iTextSharp.text.pdf.PdfLayer : PdfDictionary {
    private bool _on;
    private bool _onPanel;
    protected IList`1<PdfLayer> children;
    protected PdfLayer parent;
    protected PdfIndirectReference Refi;
    protected string title;
    public IList`1<PdfLayer> Children { get; }
    unknown bool Export {public set; }
    unknown string Name {public set; }
    public bool On { get; public set; }
    public bool OnPanel { get; public set; }
    public PdfLayer Parent { get; }
    unknown bool View {public set; }
    internal string Title { get; }
    private PdfDictionary Usage { get; }
    public PdfObject PdfObject { get; }
    public PdfIndirectReference Ref { get; public set; }
    public PdfLayer(string name, PdfWriter writer);
    internal PdfLayer(string title);
    public IList`1<PdfLayer> get_Children();
    public void set_Export(bool value);
    public void set_Name(string value);
    public bool get_On();
    public void set_On(bool value);
    public bool get_OnPanel();
    public void set_OnPanel(bool value);
    public PdfLayer get_Parent();
    public void set_View(bool value);
    internal string get_Title();
    private PdfDictionary get_Usage();
    public sealed virtual PdfObject get_PdfObject();
    public sealed virtual PdfIndirectReference get_Ref();
    public void set_Ref(PdfIndirectReference value);
    public static PdfLayer CreateTitle(string title, PdfWriter writer);
    public void AddChild(PdfLayer child);
    public void SetCreatorInfo(string creator, string subtype);
    public void SetLanguage(string lang, bool preferred);
    public void SetPrint(string subtype, bool printstate);
    public void SetZoom(float min, float max);
}
public class iTextSharp.text.pdf.PdfLayerMembership : PdfDictionary {
    public static PdfName Alloff;
    public static PdfName Allon;
    public static PdfName Anyoff;
    public static PdfName Anyon;
    internal INullValueDictionary`2<PdfLayer, object> layers;
    internal PdfArray Members;
    internal PdfIndirectReference Refi;
    public ICollection`1<PdfLayer> Layers { get; }
    unknown PdfName VisibilityPolicy {public set; }
    public PdfObject PdfObject { get; }
    public PdfIndirectReference Ref { get; }
    public PdfLayerMembership(PdfWriter writer);
    private static PdfLayerMembership();
    public ICollection`1<PdfLayer> get_Layers();
    public void set_VisibilityPolicy(PdfName value);
    public sealed virtual PdfObject get_PdfObject();
    public sealed virtual PdfIndirectReference get_Ref();
    public void AddMember(PdfLayer layer);
}
public class iTextSharp.text.pdf.PdfLine : object {
    protected internal int Alignment;
    protected internal float height;
    protected internal bool IsRtl;
    protected internal float Left;
    protected internal IList`1<PdfChunk> Line;
    protected internal Chunk listSymbol;
    protected internal bool newlineSplit;
    protected internal float originalWidth;
    protected internal float SymbolIndent;
    protected internal float Width;
    public int Size { get; }
    internal float Height { get; }
    internal float IndentLeft { get; }
    internal float WidthLeft { get; }
    internal int NumberOfSpaces { get; }
    unknown ListItem ListItem {public set; }
    public Chunk ListSymbol { get; }
    public float ListIndent { get; }
    public bool NewlineSplit { get; }
    public int LastStrokeChunk { get; }
    public float OriginalWidth { get; }
    internal bool Rtl { get; }
    public float Ascender { get; }
    public float Descender { get; }
    internal PdfLine(float left, float right, int alignment, float height);
    internal PdfLine(float left, float originalWidth, float remainingWidth, int alignment, bool newlineSplit, IList`1<PdfChunk> line, bool isRtl);
    public int get_Size();
    internal float get_Height();
    internal float get_IndentLeft();
    internal float get_WidthLeft();
    internal int get_NumberOfSpaces();
    public void set_ListItem(ListItem value);
    public Chunk get_ListSymbol();
    public float get_ListIndent();
    public bool get_NewlineSplit();
    public int get_LastStrokeChunk();
    public float get_OriginalWidth();
    internal bool get_Rtl();
    public float get_Ascender();
    public float get_Descender();
    internal PdfChunk Add(PdfChunk chunk);
    private void addToLine(PdfChunk chunk);
    public IEnumerator`1<PdfChunk> GetEnumerator();
    public bool HasToBeJustified();
    public void ResetAlignment();
    internal void SetExtraIndent(float extra);
    public virtual string ToString();
    public int GetLineLengthUtf32();
    public PdfChunk GetChunk(int idx);
    internal Single[] GetMaxSize();
    internal int GetSeparatorCount();
    public float GetWidthCorrected(float charSpacing, float wordSpacing);
}
public class iTextSharp.text.pdf.PdfLiteral : PdfObject {
    [CompilerGeneratedAttribute]
private int <Position>k__BackingField;
    public int Position { get; private set; }
    public int PosLength { get; }
    public PdfLiteral(string text);
    public PdfLiteral(Byte[] b);
    public PdfLiteral(int type, string text);
    public PdfLiteral(int type, Byte[] b);
    public PdfLiteral(int size);
    [CompilerGeneratedAttribute]
public int get_Position();
    [CompilerGeneratedAttribute]
private void set_Position(int value);
    public int get_PosLength();
    public virtual void ToPdf(PdfWriter writer, Stream os);
}
public class iTextSharp.text.pdf.PdfMediaClipData : PdfDictionary {
    internal PdfMediaClipData(string file, PdfFileSpecification fs, string mimeType);
}
public class iTextSharp.text.pdf.PdfName : PdfObject {
    public static PdfName _3D;
    public static PdfName A;
    public static PdfName Aa;
    public static PdfName Absolutecolorimetric;
    public static PdfName Ac;
    public static PdfName Acroform;
    public static PdfName Action;
    public static PdfName Activation;
    public static PdfName Adbe;
    public static PdfName Actualtext;
    public static PdfName AdbePkcs7Detached;
    public static PdfName AdbePkcs7S4;
    public static PdfName AdbePkcs7S5;
    public static PdfName AdbePkcs7Sha1;
    public static PdfName AdbeX509RsaSha1;
    public static PdfName AdobePpklite;
    public static PdfName AdobePpkms;
    public static PdfName Aesv2;
    public static PdfName Ais;
    public static PdfName Allpages;
    public static PdfName Alt;
    public static PdfName Alternate;
    public static PdfName Animation;
    public static PdfName Annot;
    public static PdfName Annots;
    public static PdfName Antialias;
    public static PdfName Ap;
    public static PdfName Appdefault;
    public static PdfName Art;
    public static PdfName Artbox;
    public static PdfName Ascent;
    public static PdfName As;
    public static PdfName Ascii85Decode;
    public static PdfName Asciihexdecode;
    public static PdfName Asset;
    public static PdfName Assets;
    public static PdfName Authevent;
    public static PdfName Author;
    public static PdfName B;
    public static PdfName Background;
    public static PdfName Baseencoding;
    public static PdfName Basefont;
    public static PdfName Baseversion;
    public static PdfName Bbox;
    public static PdfName Bc;
    public static PdfName Bg;
    public static PdfName Bibentry;
    public static PdfName Bigfive;
    public static PdfName Binding;
    public static PdfName Bindingmaterialname;
    public static PdfName Bitspercomponent;
    public static PdfName Bitspersample;
    public static PdfName Bl;
    public static PdfName Blackis1;
    public static PdfName Blackpoint;
    public static PdfName Blockquote;
    public static PdfName Bleedbox;
    public static PdfName Blinds;
    public static PdfName Bm;
    public static PdfName Border;
    public static PdfName Bounds;
    public static PdfName Box;
    public static PdfName Bs;
    public static PdfName Btn;
    public static PdfName Byterange;
    public static PdfName C;
    public static PdfName C0;
    public static PdfName C1;
    public static PdfName CA;
    public static PdfName CA_;
    public static PdfName Calgray;
    public static PdfName Calrgb;
    public static PdfName Capheight;
    public static PdfName Caption;
    public static PdfName Catalog;
    public static PdfName Category;
    public static PdfName Ccittfaxdecode;
    public static PdfName Center;
    public static PdfName Centerwindow;
    public static PdfName Cert;
    public static PdfName Cf;
    public static PdfName Cfm;
    public static PdfName Ch;
    public static PdfName Charprocs;
    public static PdfName Ci;
    public static PdfName Cidfonttype0;
    public static PdfName Cidfonttype2;
    public static PdfName Cidset;
    public static PdfName Cidsysteminfo;
    public static PdfName Cidtogidmap;
    public static PdfName Circle;
    public static PdfName Cmd;
    public static PdfName Co;
    public static PdfName Code;
    public static PdfName Colors;
    public static PdfName Colorspace;
    public static PdfName Collection;
    public static PdfName Collectionfield;
    public static PdfName Collectionitem;
    public static PdfName Collectionschema;
    public static PdfName Collectionsort;
    public static PdfName Collectionsubitem;
    public static PdfName Columns;
    public static PdfName Condition;
    public static PdfName Configuration;
    public static PdfName Configurations;
    public static PdfName Contactinfo;
    public static PdfName CONTENT;
    public static PdfName Contents;
    public static PdfName Coords;
    public static PdfName Count;
    public static PdfName Courier;
    public static PdfName CourierBold;
    public static PdfName CourierOblique;
    public static PdfName CourierBoldoblique;
    public static PdfName Creationdate;
    public static PdfName Creator;
    public static PdfName Creatorinfo;
    public static PdfName Cropbox;
    public static PdfName Crypt;
    public static PdfName Cs;
    public static PdfName Cuepoint;
    public static PdfName Cuepoints;
    public static PdfName D;
    public static PdfName Da;
    public static PdfName Data;
    public static PdfName Dc;
    public static PdfName Dctdecode;
    public static PdfName Deactivation;
    public static PdfName Decode;
    public static PdfName Decodeparms;
    public static PdfName Default;
    public static PdfName Defaultcryptfilter;
    public static PdfName Defaultcmyk;
    public static PdfName Defaultgray;
    public static PdfName Defaultrgb;
    public static PdfName Desc;
    public static PdfName Descendantfonts;
    public static PdfName Descent;
    public static PdfName Dest;
    public static PdfName Destoutputprofile;
    public static PdfName Dests;
    public static PdfName Devicegray;
    public static PdfName Devicergb;
    public static PdfName Devicecmyk;
    public static PdfName Di;
    public static PdfName Differences;
    public static PdfName Dissolve;
    public static PdfName Direction;
    public static PdfName Displaydoctitle;
    public static PdfName Div;
    public static PdfName Dm;
    public static PdfName Docmdp;
    public static PdfName Docopen;
    public static PdfName AESV3;
    public static PdfName Document;
    public static PdfName Domain;
    public static PdfName Dp;
    public static PdfName Dr;
    public static PdfName Ds;
    public static PdfName Dur;
    public static PdfName Duplex;
    public static PdfName Duplexflipshortedge;
    public static PdfName Duplexfliplongedge;
    public static PdfName Dv;
    public static PdfName Dw;
    public static PdfName E;
    public static PdfName Earlychange;
    public static PdfName EF;
    public static PdfName Eff;
    public static PdfName Efopen;
    public static PdfName Embedded;
    public static PdfName Embeddedfile;
    public static PdfName Embeddedfiles;
    public static PdfName Encode;
    public static PdfName Encodedbytealign;
    public static PdfName Encoding;
    public static PdfName Encrypt;
    public static PdfName Encryptmetadata;
    public static PdfName Endofblock;
    public static PdfName Endofline;
    public static PdfName Extend;
    public static PdfName Extensions;
    public static PdfName Extensionlevel;
    public static PdfName Extgstate;
    public static PdfName Export;
    public static PdfName Exportstate;
    public static PdfName Event;
    public static PdfName F;
    public static PdfName Far;
    public static PdfName Fb;
    public static PdfName Fdecodeparms;
    public static PdfName Fdf;
    public static PdfName Ff;
    public static PdfName Ffilter;
    public static PdfName Fields;
    public static PdfName Figure;
    public static PdfName Fileattachment;
    public static PdfName Filespec;
    public static PdfName Filter;
    public static PdfName First;
    public static PdfName Firstchar;
    public static PdfName Firstpage;
    public static PdfName Fit;
    public static PdfName Fith;
    public static PdfName Fitv;
    public static PdfName Fitr;
    public static PdfName Fitb;
    public static PdfName Fitbh;
    public static PdfName Fitbv;
    public static PdfName Fitwindow;
    public static PdfName Flags;
    public static PdfName Flash;
    public static PdfName Flashvars;
    public static PdfName Flatedecode;
    public static PdfName Fo;
    public static PdfName Font;
    public static PdfName Fontbbox;
    public static PdfName Fontdescriptor;
    public static PdfName Fontfile;
    public static PdfName Fontfile2;
    public static PdfName Fontfile3;
    public static PdfName Fontmatrix;
    public static PdfName Fontname;
    public static PdfName Foreground;
    public static PdfName Form;
    public static PdfName Formtype;
    public static PdfName Formula;
    public static PdfName Freetext;
    public static PdfName Frm;
    public static PdfName Fs;
    public static PdfName Ft;
    public static PdfName Fullscreen;
    public static PdfName Function;
    public static PdfName Functions;
    public static PdfName Functiontype;
    public static PdfName Gamma;
    public static PdfName Gbk;
    public static PdfName Glitter;
    public static PdfName Goto;
    public static PdfName Gotoe;
    public static PdfName OE;
    public static PdfName UE;
    public static PdfName Gotor;
    public static PdfName Group;
    public static PdfName GtsPdfa1;
    public static PdfName GtsPdfx;
    public static PdfName GtsPdfxversion;
    public static PdfName H;
    public static PdfName H1;
    public static PdfName H2;
    public static PdfName H3;
    public static PdfName H4;
    public static PdfName H5;
    public static PdfName H6;
    public static PdfName Halign;
    public static PdfName Height;
    public static PdfName Helv;
    public static PdfName Helvetica;
    public static PdfName HelveticaBold;
    public static PdfName HelveticaOblique;
    public static PdfName HelveticaBoldoblique;
    public static PdfName Hid;
    public static PdfName Hide;
    public static PdfName Hidemenubar;
    public static PdfName Hidetoolbar;
    public static PdfName Hidewindowui;
    public static PdfName Highlight;
    public static PdfName Hoffset;
    public static PdfName I;
    public static PdfName Iccbased;
    public static PdfName Id;
    public static PdfName Identity;
    public static PdfName If;
    public static PdfName Image;
    public static PdfName Imageb;
    public static PdfName Imagec;
    public static PdfName Imagei;
    public static PdfName Imagemask;
    public static PdfName Index;
    public static PdfName Indexed;
    public static PdfName Info;
    public static PdfName Ink;
    public static PdfName Inklist;
    public static PdfName Instances;
    public static PdfName Importdata;
    public static PdfName Intent;
    public static PdfName Interpolate;
    public static PdfName Ismap;
    public static PdfName Irt;
    public static PdfName Italicangle;
    public static PdfName Itxt;
    public static PdfName Ix;
    public static PdfName Javascript;
    public static PdfName Jbig2Decode;
    public static PdfName Jbig2Globals;
    public static PdfName Jpxdecode;
    public static PdfName Js;
    public static PdfName K;
    public static PdfName Keywords;
    public static PdfName Kids;
    public static PdfName L;
    public static PdfName L2R;
    public static PdfName Lang;
    public static PdfName Language;
    public static PdfName Last;
    public static PdfName Lastchar;
    public static PdfName Lastpage;
    public static PdfName Launch;
    public static PdfName Lbl;
    public static PdfName Lbody;
    public static PdfName LENGTH;
    public static PdfName Length1;
    public static PdfName Li;
    public static PdfName Limits;
    public static PdfName Line;
    public static PdfName Linear;
    public static PdfName Link;
    public static PdfName Listmode;
    public static PdfName Location;
    public static PdfName Lock;
    public static PdfName Locked;
    public static PdfName Lzwdecode;
    public static PdfName M;
    public static PdfName Material;
    public static PdfName Matrix;
    public static PdfName MacExpertEncoding;
    public static PdfName MacRomanEncoding;
    public static PdfName Marked;
    public static PdfName Markinfo;
    public static PdfName Mask;
    public static PdfName MaxLowerCase;
    public static PdfName MaxCamelCase;
    public static PdfName Maxlen;
    public static PdfName Mediabox;
    public static PdfName Mcid;
    public static PdfName Mcr;
    public static PdfName Metadata;
    public static PdfName MinLowerCase;
    public static PdfName MinCamelCase;
    public static PdfName Mk;
    public static PdfName Mmtype1;
    public static PdfName Moddate;
    public static PdfName N;
    public static PdfName N0;
    public static PdfName N1;
    public static PdfName N2;
    public static PdfName N3;
    public static PdfName N4;
    public static PdfName Name;
    public static PdfName Named;
    public static PdfName Names;
    public static PdfName Navigation;
    public static PdfName Navigationpane;
    public static PdfName Near;
    public static PdfName Needappearances;
    public static PdfName Newwindow;
    public static PdfName Next;
    public static PdfName Nextpage;
    public static PdfName Nm;
    public static PdfName None;
    public static PdfName Nonfullscreenpagemode;
    public static PdfName Nonstruct;
    public static PdfName Note;
    public static PdfName Numcopies;
    public static PdfName Nums;
    public static PdfName O;
    public static PdfName Obj;
    public static PdfName Objr;
    public static PdfName Objstm;
    public static PdfName Oc;
    public static PdfName Ocg;
    public static PdfName Ocgs;
    public static PdfName Ocmd;
    public static PdfName Ocproperties;
    public static PdfName Off;
    public static PdfName OFF;
    public static PdfName On;
    public static PdfName Onecolumn;
    public static PdfName Open;
    public static PdfName Openaction;
    public static PdfName Op;
    public static PdfName Op_;
    public static PdfName Opm;
    public static PdfName Opt;
    public static PdfName Order;
    public static PdfName Ordering;
    public static PdfName Oscillating;
    public static PdfName Outlines;
    public static PdfName Outputcondition;
    public static PdfName Outputconditionidentifier;
    public static PdfName Outputintent;
    public static PdfName Outputintents;
    public static PdfName P;
    public static PdfName Page;
    public static PdfName Pagelabels;
    public static PdfName Pagelayout;
    public static PdfName Pagemode;
    public static PdfName Pages;
    public static PdfName Painttype;
    public static PdfName Panose;
    public static PdfName Params;
    public static PdfName Parent;
    public static PdfName Parenttree;
    public static PdfName Parenttreenextkey;
    public static PdfName Part;
    public static PdfName Passcontextclick;
    public static PdfName Pattern;
    public static PdfName Patterntype;
    public static PdfName Pc;
    public static PdfName Pdf;
    public static PdfName Pdfdocencoding;
    public static PdfName Perceptual;
    public static PdfName Perms;
    public static PdfName Pg;
    public static PdfName Pi;
    public static PdfName Picktraybypdfsize;
    public static PdfName Playcount;
    public static PdfName Po;
    public static PdfName Popup;
    public static PdfName Position;
    public static PdfName Predictor;
    public static PdfName Preferred;
    public static PdfName Presentation;
    public static PdfName Preserverb;
    public static PdfName Prev;
    public static PdfName Prevpage;
    public static PdfName Print;
    public static PdfName Printarea;
    public static PdfName Printclip;
    public static PdfName Printpagerange;
    public static PdfName Printscaling;
    public static PdfName Printstate;
    public static PdfName Private;
    public static PdfName Procset;
    public static PdfName Producer;
    public static PdfName Properties;
    public static PdfName Ps;
    public static PdfName Pubsec;
    public static PdfName Pv;
    public static PdfName Q;
    public static PdfName Quadpoints;
    public static PdfName Quote;
    public static PdfName R;
    public static PdfName R2L;
    public static PdfName Range;
    public static PdfName Rc;
    public static PdfName Rbgroups;
    public static PdfName Reason;
    public static PdfName Recipients;
    public static PdfName Rect;
    public static PdfName Reference;
    public static PdfName Registry;
    public static PdfName Registryname;
    public static PdfName Relativecolorimetric;
    public static PdfName Rendition;
    public static PdfName Resetform;
    public static PdfName Resources;
    public static PdfName Ri;
    public static PdfName Richmedia;
    public static PdfName Richmediaactivation;
    public static PdfName Richmediaanimation;
    public static PdfName Richmediacommand;
    public static PdfName Richmediaconfiguration;
    public static PdfName Richmediacontent;
    public static PdfName Richmediadeactivation;
    public static PdfName Richmediaexecute;
    public static PdfName Richmediainstance;
    public static PdfName Richmediaparams;
    public static PdfName Richmediaposition;
    public static PdfName Richmediapresentation;
    public static PdfName Richmediasettings;
    public static PdfName Richmediawindow;
    public static PdfName Rolemap;
    public static PdfName Root;
    public static PdfName Rotate;
    public static PdfName Rows;
    public static PdfName Ruby;
    public static PdfName Runlengthdecode;
    public static PdfName Rv;
    public static PdfName S;
    public static PdfName Saturation;
    public static PdfName Schema;
    public static PdfName Screen;
    public static PdfName Scripts;
    public static PdfName Sect;
    public static PdfName Separation;
    public static PdfName Setocgstate;
    public static PdfName Settings;
    public static PdfName Shading;
    public static PdfName Shadingtype;
    public static PdfName ShiftJis;
    public static PdfName Sig;
    public static PdfName Sigflags;
    public static PdfName Sigref;
    public static PdfName Simplex;
    public static PdfName Singlepage;
    public static PdfName Size;
    public static PdfName Smask;
    public static PdfName Sort;
    public static PdfName Sound;
    public static PdfName Span;
    public static PdfName Speed;
    public static PdfName Split;
    public static PdfName Square;
    public static PdfName Squiggly;
    public static PdfName St;
    public static PdfName Stamp;
    public static PdfName Standard;
    public static PdfName State;
    public static PdfName Stdcf;
    public static PdfName Stemv;
    public static PdfName Stmf;
    public static PdfName Strf;
    public static PdfName Strikeout;
    public static PdfName Structparent;
    public static PdfName Structparents;
    public static PdfName Structtreeroot;
    public static PdfName Style;
    public static PdfName Subfilter;
    public static PdfName Subject;
    public static PdfName Submitform;
    public static PdfName Subtype;
    public static PdfName Supplement;
    public static PdfName Sv;
    public static PdfName Sw;
    public static PdfName Symbol;
    public static PdfName T;
    public static PdfName Ta;
    public static PdfName Table;
    public static PdfName Tabs;
    public static PdfName Tbody;
    public static PdfName Td;
    public static PdfName Text;
    public static PdfName Tfoot;
    public static PdfName Th;
    public static PdfName Thead;
    public static PdfName Thumb;
    public static PdfName Threads;
    public static PdfName Ti;
    public static PdfName Time;
    public static PdfName Tilingtype;
    public static PdfName TimesRoman;
    public static PdfName TimesBold;
    public static PdfName TimesItalic;
    public static PdfName TimesBolditalic;
    public static PdfName Title;
    public static PdfName Tk;
    public static PdfName Tm;
    public static PdfName Toc;
    public static PdfName Toci;
    public static PdfName Toggle;
    public static PdfName Toolbar;
    public static PdfName Tounicode;
    public static PdfName Tp;
    public static PdfName Tablerow;
    public static PdfName Trans;
    public static PdfName Transformparams;
    public static PdfName Transformmethod;
    public static PdfName Transparency;
    public static PdfName Transparent;
    public static PdfName Trapped;
    public static PdfName Trimbox;
    public static PdfName Truetype;
    public static PdfName Tu;
    public static PdfName Twocolumnleft;
    public static PdfName Twocolumnright;
    public static PdfName Twopageleft;
    public static PdfName Twopageright;
    public static PdfName Tx;
    public static PdfName TYPE;
    public static PdfName TYPES;
    public static PdfName Type0;
    public static PdfName Type1;
    public static PdfName Type3;
    public static PdfName U;
    public static PdfName Uf;
    public static PdfName Uhc;
    public static PdfName Underline;
    public static PdfName Ur;
    public static PdfName Ur3;
    public static PdfName Uri;
    public static PdfName Url;
    public static PdfName Usage;
    public static PdfName Useattachments;
    public static PdfName Usenone;
    public static PdfName Useoc;
    public static PdfName Useoutlines;
    public static PdfName User;
    public static PdfName Userproperties;
    public static PdfName Userunit;
    public static PdfName Usethumbs;
    public static PdfName V;
    public static PdfName V2;
    public static PdfName Valign;
    public static PdfName VerisignPpkvs;
    public static PdfName Version;
    public static PdfName Video;
    public static PdfName View;
    public static PdfName Views;
    public static PdfName Viewarea;
    public static PdfName Viewclip;
    public static PdfName Viewerpreferences;
    public static PdfName Viewstate;
    public static PdfName Visiblepages;
    public static PdfName Voffset;
    public static PdfName W;
    public static PdfName W2;
    public static PdfName Warichu;
    public static PdfName Wc;
    public static PdfName Widget;
    public static PdfName Width;
    public static PdfName Widths;
    public static PdfName Win;
    public static PdfName WinAnsiEncoding;
    public static PdfName Window;
    public static PdfName Windowed;
    public static PdfName Wipe;
    public static PdfName Whitepoint;
    public static PdfName Wp;
    public static PdfName Ws;
    public static PdfName X;
    public static PdfName Xa;
    public static PdfName Xd;
    public static PdfName Xfa;
    public static PdfName Xml;
    public static PdfName Xobject;
    public static PdfName Xstep;
    public static PdfName Xref;
    public static PdfName Xrefstm;
    public static PdfName Xyz;
    public static PdfName Ystep;
    public static PdfName Zadb;
    public static PdfName Zapfdingbats;
    public static PdfName Zoom;
    public static INullValueDictionary`2<string, PdfName> StaticNames;
    private static PdfName();
    public PdfName(string name);
    public PdfName(string name, bool lengthCheck);
    public PdfName(Byte[] bytes);
    public sealed virtual int CompareTo(object obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static Byte[] EncodeName(string name);
    public static string DecodeName(string name);
}
public static class iTextSharp.text.pdf.PdfNameTree : object {
    private static int LeafSize;
    public static INullValueDictionary`2<string, PdfObject> ReadTree(PdfDictionary dic);
    public static PdfDictionary WriteTree(INullValueDictionary`2<string, PdfObject> items, PdfWriter writer);
    private static void iterateItems(PdfDictionary dic, INullValueDictionary`2<string, PdfObject> items);
}
public class iTextSharp.text.pdf.PdfNull : PdfObject {
    public static PdfNull Pdfnull;
    private static PdfNull();
    public virtual string ToString();
}
public class iTextSharp.text.pdf.PdfNumber : PdfObject {
    private double _value;
    public double DoubleValue { get; }
    public float FloatValue { get; }
    public int IntValue { get; }
    public PdfNumber(string content);
    public PdfNumber(int value);
    public PdfNumber(double value);
    public PdfNumber(float value);
    public double get_DoubleValue();
    public float get_FloatValue();
    public int get_IntValue();
    public void Increment();
}
public static class iTextSharp.text.pdf.PdfNumberTree : object {
    private static int LeafSize;
    public static INullValueDictionary`2<int, PdfObject> ReadTree(PdfDictionary dic);
    public static PdfDictionary WriteTree(INullValueDictionary`2<int, T> items, PdfWriter writer);
    private static void iterateItems(PdfDictionary dic, INullValueDictionary`2<int, PdfObject> items);
}
public abstract class iTextSharp.text.pdf.PdfObject : object {
    public static int ARRAY;
    public static int BOOLEAN;
    public static int DICTIONARY;
    public static int INDIRECT;
    public static int NAME;
    public static string NOTHING;
    public static int NULL;
    public static int NUMBER;
    public static int STREAM;
    public static int STRING;
    public static string TEXT_PDFDOCENCODING;
    public static string TEXT_UNICODE;
    protected Byte[] Bytes;
    protected PrIndirectReference indRef;
    protected int type;
    public PrIndirectReference IndRef { get; public set; }
    public int Length { get; }
    public int Type { get; }
    unknown string Content {protected set; }
    protected PdfObject(int type);
    protected PdfObject(int type, string content);
    protected PdfObject(int type, Byte[] bytes);
    public PrIndirectReference get_IndRef();
    public void set_IndRef(PrIndirectReference value);
    public int get_Length();
    public int get_Type();
    protected void set_Content(string value);
    public bool CanBeInObjStm();
    public virtual Byte[] GetBytes();
    public bool IsArray();
    public bool IsBoolean();
    public bool IsDictionary();
    public bool IsIndirect();
    public bool IsName();
    public bool IsNull();
    public bool IsNumber();
    public bool IsStream();
    public bool IsString();
    public virtual void ToPdf(PdfWriter writer, Stream os);
    public virtual string ToString();
}
public class iTextSharp.text.pdf.PdfOcProperties : PdfDictionary {
}
public class iTextSharp.text.pdf.PdfOutline : PdfDictionary {
    private PdfAction _action;
    private PdfDestination _destination;
    private BaseColor _color;
    private bool _open;
    private string _tag;
    protected IList`1<PdfOutline> kids;
    protected PdfWriter Writer;
    [CompilerGeneratedAttribute]
private PdfIndirectReference <IndirectReference>k__BackingField;
    [CompilerGeneratedAttribute]
private PdfOutline <Parent>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Style>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Count>k__BackingField;
    public BaseColor Color { get; public set; }
    public PdfIndirectReference IndirectReference { get; public set; }
    public IList`1<PdfOutline> Kids { get; public set; }
    public int Level { get; }
    public bool Open { get; public set; }
    public PdfOutline Parent { get; private set; }
    public PdfDestination PdfDestination { get; }
    public int Style { get; public set; }
    public string Tag { get; public set; }
    public string Title { get; public set; }
    internal int Count { get; internal set; }
    public PdfOutline(PdfOutline parent, PdfAction action, string title);
    public PdfOutline(PdfOutline parent, PdfAction action, string title, bool open);
    public PdfOutline(PdfOutline parent, PdfDestination destination, string title);
    public PdfOutline(PdfOutline parent, PdfDestination destination, string title, bool open);
    public PdfOutline(PdfOutline parent, PdfAction action, PdfString title);
    public PdfOutline(PdfOutline parent, PdfAction action, PdfString title, bool open);
    public PdfOutline(PdfOutline parent, PdfDestination destination, PdfString title);
    public PdfOutline(PdfOutline parent, PdfDestination destination, PdfString title, bool open);
    public PdfOutline(PdfOutline parent, PdfAction action, Paragraph title);
    public PdfOutline(PdfOutline parent, PdfAction action, Paragraph title, bool open);
    public PdfOutline(PdfOutline parent, PdfDestination destination, Paragraph title);
    public PdfOutline(PdfOutline parent, PdfDestination destination, Paragraph title, bool open);
    internal PdfOutline(PdfWriter writer);
    public BaseColor get_Color();
    public void set_Color(BaseColor value);
    [CompilerGeneratedAttribute]
public PdfIndirectReference get_IndirectReference();
    [CompilerGeneratedAttribute]
public void set_IndirectReference(PdfIndirectReference value);
    public IList`1<PdfOutline> get_Kids();
    public void set_Kids(IList`1<PdfOutline> value);
    public int get_Level();
    public void set_Open(bool value);
    public bool get_Open();
    [CompilerGeneratedAttribute]
public PdfOutline get_Parent();
    [CompilerGeneratedAttribute]
private void set_Parent(PdfOutline value);
    public PdfDestination get_PdfDestination();
    [CompilerGeneratedAttribute]
public int get_Style();
    [CompilerGeneratedAttribute]
public void set_Style(int value);
    public string get_Tag();
    public void set_Tag(string value);
    public string get_Title();
    public void set_Title(string value);
    [CompilerGeneratedAttribute]
internal int get_Count();
    [CompilerGeneratedAttribute]
internal void set_Count(int value);
    public void AddKid(PdfOutline outline);
    public bool SetDestinationPage(PdfIndirectReference pageReference);
    public virtual void ToPdf(PdfWriter writer, Stream os);
    internal void InitOutline(PdfOutline parent, string title, bool open);
}
public class iTextSharp.text.pdf.PdfPage : PdfDictionary {
    public static PdfNumber Invertedportrait;
    public static PdfNumber Landscape;
    public static PdfNumber Portrait;
    public static PdfNumber Seascape;
    private static PdfName[] _boxNames;
    private static String[] _boxStrings;
    private PdfRectangle _mediaBox;
    internal PdfRectangle MediaBox { get; }
    internal PdfPage(PdfRectangle mediaBox, INullValueDictionary`2<string, PdfRectangle> boxSize, PdfDictionary resources, int rotate);
    internal PdfPage(PdfRectangle mediaBox, INullValueDictionary`2<string, PdfRectangle> boxSize, PdfDictionary resources);
    private static PdfPage();
    internal PdfRectangle get_MediaBox();
    public static bool IsParent();
    internal void Add(PdfIndirectReference contents);
    internal PdfRectangle RotateMediaBox();
}
public class iTextSharp.text.pdf.PdfPageEventHelper : object {
    public virtual void OnChapter(PdfWriter writer, Document document, float paragraphPosition, Paragraph title);
    public virtual void OnChapterEnd(PdfWriter writer, Document document, float paragraphPosition);
    public virtual void OnCloseDocument(PdfWriter writer, Document document);
    public virtual void OnEndPage(PdfWriter writer, Document document);
    public virtual void OnGenericTag(PdfWriter writer, Document document, Rectangle rect, string text);
    public virtual void OnOpenDocument(PdfWriter writer, Document document);
    public virtual void OnParagraph(PdfWriter writer, Document document, float paragraphPosition);
    public virtual void OnParagraphEnd(PdfWriter writer, Document document, float paragraphPosition);
    public virtual void OnSection(PdfWriter writer, Document document, float paragraphPosition, int depth, Paragraph title);
    public virtual void OnSectionEnd(PdfWriter writer, Document document, float paragraphPosition);
    public virtual void OnStartPage(PdfWriter writer, Document document);
}
public class iTextSharp.text.pdf.PdfPageLabels : object {
    public static int DECIMAL_ARABIC_NUMERALS;
    public static int EMPTY;
    public static int LOWERCASE_LETTERS;
    public static int LOWERCASE_ROMAN_NUMERALS;
    public static int UPPERCASE_LETTERS;
    public static int UPPERCASE_ROMAN_NUMERALS;
    internal static PdfName[] NumberingStyle;
    internal INullValueDictionary`2<int, PdfDictionary> Map;
    private static PdfPageLabels();
    public static PdfPageLabelFormat[] GetPageLabelFormats(PdfReader reader);
    public static String[] GetPageLabels(PdfReader reader);
    public void AddPageLabel(int page, int numberStyle, string text, int firstPage);
    public void AddPageLabel(int page, int numberStyle, string text);
    public void AddPageLabel(int page, int numberStyle);
    public void AddPageLabel(PdfPageLabelFormat format);
    public void RemovePageLabel(int page);
    internal PdfDictionary GetDictionary(PdfWriter writer);
}
public class iTextSharp.text.pdf.PdfPages : object {
    private List`1<PdfIndirectReference> _pages;
    private List`1<PdfIndirectReference> _parents;
    private PdfWriter _writer;
    private int _leafSize;
    [CompilerGeneratedAttribute]
private PdfIndirectReference <TopParent>k__BackingField;
    internal PdfIndirectReference TopParent { get; private set; }
    internal PdfPages(PdfWriter writer);
    [CompilerGeneratedAttribute]
internal PdfIndirectReference get_TopParent();
    [CompilerGeneratedAttribute]
private void set_TopParent(PdfIndirectReference value);
    internal void AddPage(PdfDictionary page);
    internal void AddPage(PdfIndirectReference page);
    internal PdfIndirectReference AddPageRef(PdfIndirectReference pageRef);
    internal int ReorderPages(Int32[] order);
    internal void SetLinearMode(PdfIndirectReference topParent);
    internal PdfIndirectReference WritePageTree();
}
public class iTextSharp.text.pdf.PdfPattern : PdfStream {
    internal PdfPattern(PdfPatternPainter painter);
    internal PdfPattern(PdfPatternPainter painter, int compressionLevel);
}
public class iTextSharp.text.pdf.PdfPatternPainter : PdfTemplate {
    internal BaseColor defaultColor;
    internal bool Stencil;
    internal float Xstep;
    internal float Ystep;
    public BaseColor DefaultColor { get; }
    public PdfContentByte Duplicate { get; }
    public float XStep { get; public set; }
    public float YStep { get; public set; }
    internal PdfPatternPainter(PdfWriter wr);
    internal PdfPatternPainter(PdfWriter wr, BaseColor defaultColor);
    public BaseColor get_DefaultColor();
    public virtual PdfContentByte get_Duplicate();
    public float get_XStep();
    public void set_XStep(float value);
    public float get_YStep();
    public void set_YStep(float value);
    public virtual void AddImage(Image image, float a, float b, float c, float d, float e, float f);
    public bool IsStencil();
    public virtual void ResetCmykColorFill();
    public virtual void ResetCmykColorStroke();
    public virtual void ResetGrayFill();
    public virtual void ResetGrayStroke();
    public virtual void ResetRgbColorFill();
    public virtual void ResetRgbColorStroke();
    public virtual void SetCmykColorFill(int cyan, int magenta, int yellow, int black);
    public virtual void SetCmykColorFillF(float cyan, float magenta, float yellow, float black);
    public virtual void SetCmykColorStroke(int cyan, int magenta, int yellow, int black);
    public virtual void SetCmykColorStrokeF(float cyan, float magenta, float yellow, float black);
    public virtual void SetColorFill(BaseColor value);
    public virtual void SetColorFill(PdfSpotColor sp, float tint);
    public virtual void SetColorStroke(BaseColor value);
    public virtual void SetColorStroke(PdfSpotColor sp, float tint);
    public virtual void SetGrayFill(float value);
    public virtual void SetGrayStroke(float value);
    public virtual void SetPatternFill(PdfPatternPainter p);
    public virtual void SetPatternFill(PdfPatternPainter p, BaseColor color, float tint);
    public void SetPatternMatrix(float a, float b, float c, float d, float e, float f);
    public virtual void SetPatternStroke(PdfPatternPainter p, BaseColor color, float tint);
    public virtual void SetPatternStroke(PdfPatternPainter p);
    public virtual void SetRgbColorFill(int red, int green, int blue);
    public virtual void SetRgbColorFillF(float red, float green, float blue);
    public virtual void SetRgbColorStroke(int red, int green, int blue);
    public virtual void SetRgbColorStrokeF(float red, float green, float blue);
    internal void CheckNoColor();
    internal PdfPattern GetPattern();
    internal PdfPattern GetPattern(int compressionLevel);
}
public class iTextSharp.text.pdf.PdfPCell : Rectangle {
    private IPdfPCellEvent _cellEvent;
    private int _colspan;
    private float _fixedHeight;
    private Image _image;
    private float _minimumHeight;
    private bool _noWrap;
    private float _paddingBottom;
    private float _paddingLeft;
    private float _paddingRight;
    private float _paddingTop;
    private int _rotation;
    private int _rowspan;
    private PdfPTable _table;
    private bool _useBorderPadding;
    private bool _useDescender;
    private int _verticalAlignment;
    protected Phrase phrase;
    [CompilerGeneratedAttribute]
private ColumnText <Column>k__BackingField;
    public int ArabicOptions { get; public set; }
    public IPdfPCellEvent CellEvent { get; public set; }
    public int Colspan { get; public set; }
    public ColumnText Column { get; public set; }
    public IList`1<IElement> CompositeElements { get; }
    public float EffectivePaddingBottom { get; }
    public float EffectivePaddingLeft { get; }
    public float EffectivePaddingRight { get; }
    public float EffectivePaddingTop { get; }
    public float ExtraParagraphSpace { get; public set; }
    public float FixedHeight { get; public set; }
    public float FollowingIndent { get; public set; }
    public int HorizontalAlignment { get; public set; }
    public Image Image { get; public set; }
    public float Indent { get; public set; }
    public float Leading { get; }
    public float MinimumHeight { get; public set; }
    public float MultipliedLeading { get; }
    public bool NoWrap { get; public set; }
    unknown float Padding {public set; }
    public float PaddingBottom { get; public set; }
    public float PaddingLeft { get; public set; }
    public float PaddingRight { get; public set; }
    public float PaddingTop { get; public set; }
    public Phrase Phrase { get; public set; }
    public float RightIndent { get; public set; }
    public int Rotation { get; public set; }
    public int Rowspan { get; public set; }
    public int RunDirection { get; public set; }
    public float SpaceCharRatio { get; public set; }
    public PdfPTable Table { get; public set; }
    public bool UseAscender { get; public set; }
    public bool UseBorderPadding { get; public set; }
    public bool UseDescender { get; public set; }
    public int VerticalAlignment { get; public set; }
    public PdfPCell(Phrase phrase);
    public PdfPCell(Image image);
    public PdfPCell(Image image, bool fit);
    public PdfPCell(PdfPTable table);
    public PdfPCell(PdfPTable table, PdfPCell style);
    public PdfPCell(PdfPCell cell);
    public int get_ArabicOptions();
    public void set_ArabicOptions(int value);
    public IPdfPCellEvent get_CellEvent();
    public void set_CellEvent(IPdfPCellEvent value);
    public int get_Colspan();
    public void set_Colspan(int value);
    [CompilerGeneratedAttribute]
public ColumnText get_Column();
    [CompilerGeneratedAttribute]
public void set_Column(ColumnText value);
    public IList`1<IElement> get_CompositeElements();
    public float get_EffectivePaddingBottom();
    public float get_EffectivePaddingLeft();
    public float get_EffectivePaddingRight();
    public float get_EffectivePaddingTop();
    public float get_ExtraParagraphSpace();
    public void set_ExtraParagraphSpace(float value);
    public float get_FixedHeight();
    public void set_FixedHeight(float value);
    public float get_FollowingIndent();
    public void set_FollowingIndent(float value);
    public int get_HorizontalAlignment();
    public void set_HorizontalAlignment(int value);
    public Image get_Image();
    public void set_Image(Image value);
    public float get_Indent();
    public void set_Indent(float value);
    public float get_Leading();
    public float get_MinimumHeight();
    public void set_MinimumHeight(float value);
    public float get_MultipliedLeading();
    public void set_NoWrap(bool value);
    public bool get_NoWrap();
    public void set_Padding(float value);
    public float get_PaddingBottom();
    public void set_PaddingBottom(float value);
    public float get_PaddingLeft();
    public void set_PaddingLeft(float value);
    public float get_PaddingRight();
    public void set_PaddingRight(float value);
    public float get_PaddingTop();
    public void set_PaddingTop(float value);
    public Phrase get_Phrase();
    public void set_Phrase(Phrase value);
    public float get_RightIndent();
    public void set_RightIndent(float value);
    public void set_Rotation(int value);
    public int get_Rotation();
    public int get_Rowspan();
    public void set_Rowspan(int value);
    public int get_RunDirection();
    public void set_RunDirection(int value);
    public float get_SpaceCharRatio();
    public void set_SpaceCharRatio(float value);
    public PdfPTable get_Table();
    public void set_Table(PdfPTable value);
    public bool get_UseAscender();
    public void set_UseAscender(bool value);
    public void set_UseBorderPadding(bool value);
    public bool get_UseBorderPadding();
    public bool get_UseDescender();
    public void set_UseDescender(bool value);
    public int get_VerticalAlignment();
    public void set_VerticalAlignment(int value);
    public void AddElement(IElement element);
    public float GetMaxHeight();
    public bool HasFixedHeight();
    public bool HasMinimumHeight();
    public void SetLeading(float fixedLeading, float multipliedLeading);
    internal void ConsumeHeight(float height);
}
public class iTextSharp.text.pdf.PdfPkcs7 : object {
    private static string IdAdbeRevocation;
    private static string IdContentType;
    private static string IdDsa;
    private static string IdMessageDigest;
    private static string IdPkcs7Data;
    private static string IdPkcs7SignedData;
    private static string IdRsa;
    private static string IdSigningTime;
    private static INullValueDictionary`2<string, string> _algorithmNames;
    private static INullValueDictionary`2<string, string> _allowedDigests;
    private static INullValueDictionary`2<string, string> _digestNames;
    private List`1<X509Certificate> _certs;
    private string _digestAlgorithm;
    private INullValueDictionary`2<string, object> _digestalgos;
    private Byte[] _digestAttr;
    private IDigest _messageDigest;
    private ICipherParameters _privKey;
    private ISigner _sig;
    private Byte[] _sigAttr;
    private Byte[] _digest;
    private string _digestEncryptionAlgorithm;
    private Byte[] _externalDigest;
    private Byte[] _externalRsAdata;
    private Byte[] _rsAdata;
    private List`1<X509Certificate> _signCerts;
    private bool _verified;
    private bool _verifyResult;
    [CompilerGeneratedAttribute]
private List`1<object> <CrLs>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Location>k__BackingField;
    [CompilerGeneratedAttribute]
private BasicOcspResp <Ocsp>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Reason>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <SignDate>k__BackingField;
    [CompilerGeneratedAttribute]
private X509Certificate <SigningCertificate>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SigningInfoVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SignName>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeStampToken <TimeStampToken>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Version>k__BackingField;
    public X509Certificate[] Certificates { get; }
    public List`1<object> CrLs { get; }
    public string Location { get; public set; }
    public BasicOcspResp Ocsp { get; private set; }
    public string Reason { get; public set; }
    public X509Certificate[] SignCertificateChain { get; }
    public DateTime SignDate { get; public set; }
    public X509Certificate SigningCertificate { get; }
    public int SigningInfoVersion { get; }
    public string SignName { get; public set; }
    public DateTime TimeStampDate { get; }
    public TimeStampToken TimeStampToken { get; }
    public int Version { get; }
    private static PdfPkcs7();
    public PdfPkcs7(Byte[] contentsKey, Byte[] certsKey);
    public PdfPkcs7(Byte[] contentsKey);
    public PdfPkcs7(ICipherParameters privKey, X509Certificate[] certChain, Object[] crlList, string hashAlgorithm, bool hasRsAdata);
    public X509Certificate[] get_Certificates();
    [CompilerGeneratedAttribute]
public List`1<object> get_CrLs();
    [CompilerGeneratedAttribute]
public string get_Location();
    [CompilerGeneratedAttribute]
public void set_Location(string value);
    [CompilerGeneratedAttribute]
public BasicOcspResp get_Ocsp();
    [CompilerGeneratedAttribute]
private void set_Ocsp(BasicOcspResp value);
    [CompilerGeneratedAttribute]
public string get_Reason();
    [CompilerGeneratedAttribute]
public void set_Reason(string value);
    public X509Certificate[] get_SignCertificateChain();
    [CompilerGeneratedAttribute]
public DateTime get_SignDate();
    [CompilerGeneratedAttribute]
public void set_SignDate(DateTime value);
    [CompilerGeneratedAttribute]
public X509Certificate get_SigningCertificate();
    [CompilerGeneratedAttribute]
public int get_SigningInfoVersion();
    [CompilerGeneratedAttribute]
public string get_SignName();
    [CompilerGeneratedAttribute]
public void set_SignName(string value);
    public DateTime get_TimeStampDate();
    [CompilerGeneratedAttribute]
public TimeStampToken get_TimeStampToken();
    [CompilerGeneratedAttribute]
public int get_Version();
    public static string GetAlgorithm(string oid);
    public static string GetDigest(string oid);
    public static X509Name GetIssuerFields(X509Certificate cert);
    public static string GetOcspurl(X509Certificate certificate);
    public static X509Name GetSubjectFields(X509Certificate cert);
    public static string VerifyCertificate(X509Certificate cert, Object[] crls, DateTime calendar);
    public static Object[] VerifyCertificates(X509Certificate[] certs, IList`1<X509Certificate> keystore, Object[] crls, DateTime calendar);
    public static bool VerifyOcspCertificates(BasicOcspResp ocsp, IList`1<X509Certificate> keystore);
    public static bool VerifyTimestampCertificates(TimeStampToken ts, IList`1<X509Certificate> keystore);
    public static Byte[] GetAuthenticatedAttributeBytes(Byte[] secondDigest, DateTime signingTime, Byte[] ocsp);
    public string GetDigestAlgorithm();
    public Byte[] GetEncodedPkcs1();
    public Byte[] GetEncodedPkcs7();
    public Byte[] GetEncodedPkcs7(Byte[] secondDigest, DateTime signingTime);
    public Byte[] GetEncodedPkcs7(Byte[] secondDigest, DateTime signingTime, ITsaClient tsaClient, Byte[] ocsp);
    public string GetHashAlgorithm();
    public bool IsRevocationValid();
    public void SetExternalDigest(Byte[] digest, Byte[] rsAdata, string digestEncryptionAlgorithm);
    public void Update(Byte[] buf, int off, int len);
    public bool Verify();
    public bool VerifyTimestampImprint();
    internal IDigest GetHashClass();
    private static Asn1Object getExtensionValue(X509Certificate cert, string oid);
    private static Asn1Object getIssuer(Byte[] enc);
    private static string getStringFromGeneralName(Asn1Object names);
    private static Asn1Object getSubject(Byte[] enc);
    private static Asn1EncodableVector buildUnauthenticatedAttributes(Byte[] timeStampToken);
    private void calcSignCertificateChain();
    private void findOcsp(Asn1Sequence seq);
    private static DerSet getAuthenticatedAttributeSet(Byte[] secondDigest, DateTime signingTime, Byte[] ocsp);
}
public class iTextSharp.text.pdf.PdfPRow : object {
    public static float BOTTOM_LIMIT;
    public static float RIGHT_LIMIT;
    private Int32[] _canvasesPos;
    protected bool Calculated;
    protected PdfPCell[] Cells;
    protected Single[] ExtraHeights;
    protected float MaxHeight;
    protected Single[] Widths;
    public float MaxHeights { get; public set; }
    public PdfPRow(PdfPCell[] cells);
    public PdfPRow(PdfPRow row);
    public float get_MaxHeights();
    public void set_MaxHeights(float value);
    public static float SetColumn(ColumnText ct, float left, float bottom, float right, float top);
    public float CalculateHeights();
    public PdfPCell[] GetCells();
    public void InitExtraHeights();
    public bool IsCalculated();
    public void SetExtraHeight(int cell, float height);
    public bool SetWidths(Single[] widths);
    public PdfPRow SplitRow(PdfPTable table, int rowIndex, float new_height);
    public static void WriteBorderAndBackground(float xPos, float yPos, float currentMaxHeight, PdfPCell cell, PdfContentByte[] canvases);
    public void WriteCells(int colStart, int colEnd, float xPos, float yPos, PdfContentByte[] canvases);
    internal Single[] GetEventWidth(float xPos);
    protected void RestoreCanvases(PdfContentByte[] canvases);
    protected void SaveAndRotateCanvases(PdfContentByte[] canvases, float a, float b, float c, float d, float e, float f);
}
public class iTextSharp.text.pdf.PdfPsxObject : PdfTemplate {
    public PdfContentByte Duplicate { get; }
    public PdfPsxObject(PdfWriter wr);
    public virtual PdfContentByte get_Duplicate();
    internal virtual PdfStream GetFormXObject(int compressionLevel);
}
public class iTextSharp.text.pdf.PdfPTable : object {
    public static int BACKGROUNDCANVAS;
    public static int BASECANVAS;
    public static int LINECANVAS;
    public static int TEXTCANVAS;
    private int _footerRows;
    private bool _keepTogether;
    private bool _skipLastFooter;
    protected Single[] absoluteWidths;
    protected bool Complete;
    protected PdfPCell[] CurrentRow;
    protected int CurrentRowIdx;
    protected PdfPCell defaultCell;
    protected int headerRows;
    protected bool IsColspan;
    protected bool RowCompleted;
    protected List`1<PdfPRow> rows;
    protected int runDirection;
    protected float spacingAfter;
    protected float spacingBefore;
    protected IPdfPTableEvent tableEvent;
    protected float totalHeight;
    protected float totalWidth;
    protected float widthPercentage;
    [CompilerGeneratedAttribute]
private bool <ExtendLastRow>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HeadersInEvent>k__BackingField;
    [CompilerGeneratedAttribute]
private int <HorizontalAlignment>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <LockedWidth>k__BackingField;
    [CompilerGeneratedAttribute]
private Single[] <RelativeWidths>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SkipFirstHeader>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SplitLate>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SplitRows>k__BackingField;
    public Single[] AbsoluteWidths { get; }
    public PdfPCell DefaultCell { get; }
    public bool ExtendLastRow { get; public set; }
    public float FooterHeight { get; }
    public int FooterRows { get; public set; }
    public float HeaderHeight { get; }
    public int HeaderRows { get; public set; }
    public bool HeadersInEvent { get; public set; }
    public int HorizontalAlignment { get; public set; }
    public bool KeepTogether { get; public set; }
    public bool LockedWidth { get; public set; }
    public int NumberOfColumns { get; }
    public Single[] RelativeWidths { get; private set; }
    public List`1<PdfPRow> Rows { get; }
    public int RunDirection { get; public set; }
    public int Size { get; }
    public bool SkipFirstHeader { get; public set; }
    public bool SkipLastFooter { get; public set; }
    public float SpacingAfter { get; public set; }
    public float SpacingBefore { get; public set; }
    public bool SplitLate { get; public set; }
    public bool SplitRows { get; public set; }
    public IPdfPTableEvent TableEvent { get; public set; }
    public float TotalHeight { get; }
    public float TotalWidth { get; public set; }
    public float WidthPercentage { get; public set; }
    public IList`1<Chunk> Chunks { get; }
    public bool ElementComplete { get; public set; }
    public int Type { get; }
    public PdfPTable(Single[] relativeWidths);
    public PdfPTable(int numColumns);
    public PdfPTable(PdfPTable table);
    public Single[] get_AbsoluteWidths();
    public PdfPCell get_DefaultCell();
    [CompilerGeneratedAttribute]
public bool get_ExtendLastRow();
    [CompilerGeneratedAttribute]
public void set_ExtendLastRow(bool value);
    public float get_FooterHeight();
    public int get_FooterRows();
    public void set_FooterRows(int value);
    public float get_HeaderHeight();
    public int get_HeaderRows();
    public void set_HeaderRows(int value);
    [CompilerGeneratedAttribute]
public bool get_HeadersInEvent();
    [CompilerGeneratedAttribute]
public void set_HeadersInEvent(bool value);
    [CompilerGeneratedAttribute]
public int get_HorizontalAlignment();
    [CompilerGeneratedAttribute]
public void set_HorizontalAlignment(int value);
    public void set_KeepTogether(bool value);
    public bool get_KeepTogether();
    [CompilerGeneratedAttribute]
public bool get_LockedWidth();
    [CompilerGeneratedAttribute]
public void set_LockedWidth(bool value);
    public int get_NumberOfColumns();
    [CompilerGeneratedAttribute]
public Single[] get_RelativeWidths();
    [CompilerGeneratedAttribute]
private void set_RelativeWidths(Single[] value);
    public List`1<PdfPRow> get_Rows();
    public int get_RunDirection();
    public void set_RunDirection(int value);
    public int get_Size();
    [CompilerGeneratedAttribute]
public bool get_SkipFirstHeader();
    [CompilerGeneratedAttribute]
public void set_SkipFirstHeader(bool value);
    public bool get_SkipLastFooter();
    public void set_SkipLastFooter(bool value);
    public float get_SpacingAfter();
    public void set_SpacingAfter(float value);
    public float get_SpacingBefore();
    public void set_SpacingBefore(float value);
    [CompilerGeneratedAttribute]
public bool get_SplitLate();
    [CompilerGeneratedAttribute]
public void set_SplitLate(bool value);
    [CompilerGeneratedAttribute]
public bool get_SplitRows();
    [CompilerGeneratedAttribute]
public void set_SplitRows(bool value);
    public IPdfPTableEvent get_TableEvent();
    public void set_TableEvent(IPdfPTableEvent value);
    public float get_TotalHeight();
    public float get_TotalWidth();
    public void set_TotalWidth(float value);
    public float get_WidthPercentage();
    public void set_WidthPercentage(float value);
    public sealed virtual IList`1<Chunk> get_Chunks();
    public sealed virtual bool get_ElementComplete();
    public sealed virtual void set_ElementComplete(bool value);
    public sealed virtual int get_Type();
    public sealed virtual void FlushContent();
    public sealed virtual bool IsContent();
    public sealed virtual bool IsNestable();
    public sealed virtual bool Process(IElementListener listener);
    public static PdfContentByte[] BeginWritingRows(PdfContentByte canvas);
    public static void EndWritingRows(PdfContentByte[] canvases);
    public static PdfPTable ShallowCopy(PdfPTable table);
    public void AddCell(PdfPCell cell);
    public void AddCell(string text);
    public void AddCell(PdfPTable table);
    public void AddCell(Image image);
    public void AddCell(Phrase phrase);
    public float CalculateHeights(bool firsttime);
    public void CalculateHeightsFast();
    public void CompleteRow();
    public void DeleteBodyRows();
    public bool DeleteLastRow();
    public bool DeleteRow(int rowNumber);
    public PdfPRow GetRow(int idx);
    public float GetRowHeight(int idx);
    public float GetRowHeight(int idx, bool firsttime);
    public IList`1<PdfPRow> GetRows(int start, int end);
    public float GetRowspanHeight(int rowIndex, int cellIndex);
    public void SetTotalWidth(Single[] columnWidth);
    public void SetWidthPercentage(Single[] columnWidth, Rectangle pageSize);
    public void SetWidths(Single[] relativeWidths);
    public void SetWidths(Int32[] relativeWidths);
    public float WriteSelectedRows(int rowStart, int rowEnd, float xPos, float yPos, PdfContentByte[] canvases);
    public float WriteSelectedRows(int colStart, int colEnd, int rowStart, int rowEnd, float xPos, float yPos, PdfContentByte[] canvases);
    public float WriteSelectedRows(int rowStart, int rowEnd, float xPos, float yPos, PdfContentByte canvas);
    public float WriteSelectedRows(int colStart, int colEnd, int rowStart, int rowEnd, float xPos, float yPos, PdfContentByte canvas);
    internal Single[][] GetEventWidths(float xPos, int firstRow, int lastRow, bool includeHeaders);
    private PdfPCell ObtainCell(int row, int col);
    internal bool RowSpanAbove(int currRow, int currCol);
    protected internal void CalculateWidths();
    protected internal void CopyFormat(PdfPTable sourceTable);
    protected PdfPRow AdjustCellsInRow(int start, int end);
    private void skipColsWithRowspanAbove();
}
public class iTextSharp.text.pdf.PdfPublicKeyRecipient : object {
    [CompilerGeneratedAttribute]
private X509Certificate <Certificate>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Permission>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Cms>k__BackingField;
    public X509Certificate Certificate { get; }
    public int Permission { get; }
    protected internal Byte[] Cms { get; protected internal set; }
    public PdfPublicKeyRecipient(X509Certificate certificate, int permission);
    [CompilerGeneratedAttribute]
public X509Certificate get_Certificate();
    [CompilerGeneratedAttribute]
public int get_Permission();
    [CompilerGeneratedAttribute]
protected internal void set_Cms(Byte[] value);
    [CompilerGeneratedAttribute]
protected internal Byte[] get_Cms();
}
public class iTextSharp.text.pdf.PdfPublicKeySecurityHandler : object {
    private static int SeedLength;
    private List`1<PdfPublicKeyRecipient> _recipients;
    private Byte[] _seed;
    public void AddRecipient(PdfPublicKeyRecipient recipient);
    public Byte[] GetEncodedRecipient(int index);
    public PdfArray GetEncodedRecipients();
    public int GetRecipientsSize();
    protected internal Byte[] GetSeed();
    private static KeyTransRecipientInfo computeRecipientInfo(X509Certificate x509Certificate, Byte[] abyte0);
    private static Asn1Object createDerForRecipient(Byte[] inp, X509Certificate cert);
}
public class iTextSharp.text.pdf.PdfReader : object {
    private static Byte[] _endobj;
    private static Byte[] _endstream;
    private static PdfName[] _pageInhCandidates;
    public static bool AllowOpenWithFullPermissions;
    private bool _partial;
    private PdfViewerPreferencesImp _viewerPreferences;
    private bool _appendable;
    private bool _bBailout;
    private PrIndirectReference _cryptoRef;
    private bool _encryptionError;
    private bool _hybridXref;
    private int _iPRObjectDepth;
    private int _lastXrefPartial;
    private int _objGen;
    private int _objNum;
    private bool _ownerPasswordUsed;
    private int _readDepth;
    private PdfDictionary _rootPages;
    private List`1<PdfObject> _xrefObj;
    protected internal PrAcroForm acroForm;
    protected internal bool AcroFormParsed;
    protected internal PdfDictionary catalog;
    protected X509Certificate Certificate;
    protected ICipherParameters CertificateKey;
    protected internal bool consolidateNamedDestinations;
    protected internal PdfEncryption decrypt;
    protected internal bool Encrypted;
    protected internal int eofPos;
    protected internal int FreeXref;
    protected internal int lastXref;
    protected internal bool NewXrefType;
    protected internal INullValueDictionary`2<int, NullValueDictionary`2<int, int>> ObjStmMark;
    protected internal NullValueDictionary`2<int, int> ObjStmToOffset;
    protected internal PageRefs pageRefs;
    protected internal Byte[] Password;
    protected internal char pdfVersion;
    protected internal int PValue;
    protected internal bool Rebuilt;
    protected internal int RValue;
    protected internal bool SharedStreams;
    protected internal List`1<PdfString> Strings;
    protected internal bool tampered;
    protected internal PrTokeniser Tokens;
    protected internal PdfDictionary trailer;
    protected internal Int32[] Xref;
    protected internal List`1<int> xrefByteOffset;
    [CompilerGeneratedAttribute]
private int <FileLength>k__BackingField;
    public AcroFields AcroFields { get; }
    public PrAcroForm AcroForm { get; }
    public bool Appendable { get; public set; }
    public PdfDictionary Catalog { get; }
    public int EofPos { get; }
    public int FileLength { get; private set; }
    public INullValueDictionary`2<string, string> Info { get; }
    public bool IsOpenedWithFullPermissions { get; }
    public string JavaScript { get; }
    public int LastXref { get; }
    public IList`1<int> XrefByteOffset { get; }
    public Byte[] Metadata { get; }
    public int NumberOfPages { get; }
    public char PdfVersion { get; }
    public int Permissions { get; }
    public RandomAccessFileOrArray SafeFile { get; }
    public int SimpleViewerPreferences { get; }
    public bool Tampered { get; public set; }
    public PdfDictionary Trailer { get; }
    public int XrefSize { get; }
    internal PdfEncryption Decrypt { get; }
    unknown int ViewerPreferences {public set; }
    public PdfReader(string filename);
    public PdfReader(string filename, Byte[] ownerPassword);
    public PdfReader(Byte[] pdfIn);
    public PdfReader(Byte[] pdfIn, Byte[] ownerPassword);
    public PdfReader(string filename, X509Certificate certificate, ICipherParameters certificateKey);
    public PdfReader(Uri url);
    public PdfReader(Uri url, Byte[] ownerPassword);
    public PdfReader(Stream isp, Byte[] ownerPassword, bool forceRead);
    public PdfReader(Stream isp, bool forceRead);
    public PdfReader(RandomAccessFileOrArray raf, Byte[] ownerPassword);
    public PdfReader(PdfReader reader);
    public PdfReader(Stream isp, X509Certificate certificate, ICipherParameters certificateKey);
    private static PdfReader();
    public AcroFields get_AcroFields();
    public PrAcroForm get_AcroForm();
    public void set_Appendable(bool value);
    public bool get_Appendable();
    public PdfDictionary get_Catalog();
    public int get_EofPos();
    [CompilerGeneratedAttribute]
public int get_FileLength();
    [CompilerGeneratedAttribute]
private void set_FileLength(int value);
    public INullValueDictionary`2<string, string> get_Info();
    public bool get_IsOpenedWithFullPermissions();
    public string get_JavaScript();
    public int get_LastXref();
    public IList`1<int> get_XrefByteOffset();
    public Byte[] get_Metadata();
    public int get_NumberOfPages();
    public char get_PdfVersion();
    public int get_Permissions();
    public RandomAccessFileOrArray get_SafeFile();
    public virtual int get_SimpleViewerPreferences();
    public bool get_Tampered();
    public void set_Tampered(bool value);
    public PdfDictionary get_Trailer();
    public int get_XrefSize();
    internal PdfEncryption get_Decrypt();
    public sealed virtual void Dispose();
    public virtual void set_ViewerPreferences(int value);
    public virtual void AddViewerPreference(PdfName key, PdfObject value);
    public static Byte[] Ascii85Decode(Byte[] inp);
    public static Byte[] AsciiHexDecode(Byte[] inp);
    public static Byte[] DecodePredictor(Byte[] inp, PdfObject dicPar);
    public static Byte[] FlateDecode(Byte[] inp);
    public static Byte[] FlateDecode(Byte[] inp, bool strict);
    public static Rectangle GetNormalizedRectangle(PdfArray box);
    public static PdfObject GetPdfObject(PdfObject obj);
    public static PdfObject GetPdfObject(PdfObject obj, PdfObject parent);
    public static PdfObject GetPdfObjectRelease(PdfObject obj);
    public static PdfObject GetPdfObjectRelease(PdfObject obj, PdfObject parent);
    public static Byte[] GetStreamBytes(PrStream stream, RandomAccessFileOrArray file);
    public static Byte[] GetStreamBytes(PrStream stream);
    public static Byte[] GetStreamBytesRaw(PrStream stream, RandomAccessFileOrArray file);
    public static Byte[] GetStreamBytesRaw(PrStream stream);
    public static PdfObject KillIndirect(PdfObject obj);
    public static Byte[] LzwDecode(Byte[] inp);
    public static void ReleaseLastXrefPartial(PdfObject obj);
    public PrIndirectReference AddPdfObject(PdfObject obj);
    public void Close();
    public Byte[] ComputeUserPassword();
    public void ConsolidateNamedDestinations();
    public int CreateFakeFontSubsets();
    public double DumpPerc();
    public void EliminateSharedStreams();
    public Rectangle GetBoxSize(int index, string boxName);
    public int GetCertificationLevel();
    public Rectangle GetCropBox(int index);
    public int GetCryptoMode();
    public string GetJavaScript(RandomAccessFileOrArray file);
    public List`1<PdfImportedLink> GetLinks(int page);
    public INullValueDictionary`2<object, PdfObject> GetNamedDestination();
    public INullValueDictionary`2<object, PdfObject> GetNamedDestination(bool keepNames);
    public INullValueDictionary`2<string, PdfObject> GetNamedDestinationFromNames();
    public INullValueDictionary`2<object, PdfObject> GetNamedDestinationFromNames(bool keepNames);
    public INullValueDictionary`2<string, PdfObject> GetNamedDestinationFromStrings();
    public Byte[] GetPageContent(int pageNum, RandomAccessFileOrArray file);
    public Byte[] GetPageContent(int pageNum);
    public PdfDictionary GetPageN(int pageNum);
    public PdfDictionary GetPageNRelease(int pageNum);
    public PrIndirectReference GetPageOrigRef(int pageNum);
    public int GetPageRotation(int index);
    public Rectangle GetPageSize(int index);
    public static Rectangle GetPageSize(PdfDictionary page);
    public Rectangle GetPageSizeWithRotation(int index);
    public static Rectangle GetPageSizeWithRotation(PdfDictionary page);
    public PdfObject GetPdfObject(int idx);
    public PdfObject GetPdfObjectRelease(int idx);
    public bool Is128Key();
    public bool IsEncrypted();
    public bool IsHybridXref();
    public bool IsMetadataEncrypted();
    public bool IsNewXrefType();
    public bool IsRebuilt();
    public void ReleaseLastXrefPartial();
    public void ReleasePage(int pageNum);
    public void RemoveAnnotations();
    public void RemoveFields();
    public int RemoveUnusedObjects();
    public void RemoveUsageRights();
    public void ResetLastXrefPartial();
    public void ResetReleasePage();
    public void SelectPages(string ranges);
    public void SelectPages(ICollection`1<int> pagesToKeep);
    public void SetPageContent(int pageNum, Byte[] content);
    public void SetPageContent(int pageNum, Byte[] content, int compressionLevel);
    public int ShuffleSubsetNames();
    internal static bool Equalsn(Byte[] a1, Byte[] a2);
    internal static bool ExistsName(PdfDictionary dic, PdfName key, PdfName value);
    internal static string GetFontName(PdfDictionary dic);
    internal static string GetSubsetPrefix(PdfDictionary dic);
    internal PdfIndirectReference GetCryptoRef();
    internal static int GetPageRotation(PdfDictionary page);
    internal virtual void SetViewerPreferences(PdfViewerPreferencesImp vp);
    protected internal static PdfDictionary DuplicatePdfDictionary(PdfDictionary original, PdfDictionary copy, PdfReader newReader);
    protected internal static PdfObject DuplicatePdfObject(PdfObject original, PdfReader newReader);
    protected internal PdfReaderInstance GetPdfReaderInstance(PdfWriter writer);
    protected internal void KillXref(PdfObject obj);
    protected internal PdfArray ReadArray();
    protected internal PdfDictionary ReadDictionary();
    protected internal void ReadDocObj();
    protected internal void ReadDocObjPartial();
    protected internal void ReadObjStm(PrStream stream, NullValueDictionary`2<int, int> map);
    protected internal PdfObject ReadOneObjStm(PrStream stream, int idx);
    protected internal void ReadPages();
    private bool HasRootPage();
    protected internal virtual void ReadPdf();
    protected internal void ReadPdfPartial();
    protected internal PdfObject ReadPrObject();
    protected internal PdfObject ReadSingleObject(int k);
    protected internal void ReadXref();
    protected internal PdfDictionary ReadXrefSection();
    protected internal bool ReadXRefStream(int ptr);
    protected internal void RebuildXref();
    protected internal void RemoveUnusedNode(PdfObject obj, Boolean[] hits);
    private static PdfArray getNameArray(PdfObject obj);
    private void checkPrStreamLength(PrStream stream);
    private void ensureXrefSize(int size);
    private static bool equalsArray(Byte[] ar1, Byte[] ar2, int size);
    private void iterateBookmarks(PdfObject outlineRef, INullValueDictionary`2<object, PdfObject> names);
    private void readDecryptedDocObj();
    private bool replaceNamedDestination(PdfObject obj, INullValueDictionary`2<object, PdfObject> names);
    private void setXrefPartialObject(int idx, PdfObject obj);
    public IList`1<string> SignaturesCoverWholeDocument();
}
public class iTextSharp.text.pdf.PdfReaderInstance : object {
    internal static PdfLiteral Identitymatrix;
    internal static PdfNumber One;
    internal RandomAccessFileOrArray File;
    internal INullValueDictionary`2<int, PdfImportedPage> ImportedPages;
    internal Int32[] MyXref;
    internal List`1<int> NextRound;
    internal PdfReader reader;
    internal INullValueDictionary`2<int, object> Visited;
    internal PdfWriter Writer;
    internal PdfReader Reader { get; }
    internal RandomAccessFileOrArray ReaderFile { get; }
    internal PdfReaderInstance(PdfReader reader, PdfWriter writer);
    private static PdfReaderInstance();
    internal PdfReader get_Reader();
    internal RandomAccessFileOrArray get_ReaderFile();
    internal PdfStream GetFormXObject(int pageNumber, int compressionLevel);
    internal PdfImportedPage GetImportedPage(int pageNumber);
    internal int GetNewObjectNumber(int number, int generation);
    internal PdfObject GetResources(int pageNumber);
    internal void WriteAllPages();
    internal void WriteAllVisited();
}
public class iTextSharp.text.pdf.PdfRectangle : PdfArray {
    private float _lly;
    [CompilerGeneratedAttribute]
private float <Left>k__BackingField;
    [CompilerGeneratedAttribute]
private float <Right>k__BackingField;
    [CompilerGeneratedAttribute]
private float <Top>k__BackingField;
    public float Bottom { get; }
    public float Height { get; }
    public float Left { get; }
    public Rectangle Rectangle { get; }
    public float Right { get; }
    public PdfRectangle Rotate { get; }
    public float Top { get; }
    public float Width { get; }
    public PdfRectangle(float llx, float lly, float urx, float ury, int rotation);
    public PdfRectangle(float llx, float lly, float urx, float ury);
    public PdfRectangle(float urx, float ury, int rotation);
    public PdfRectangle(float urx, float ury);
    public PdfRectangle(Rectangle rectangle, int rotation);
    public PdfRectangle(Rectangle rectangle);
    public float get_Bottom();
    public float get_Height();
    [CompilerGeneratedAttribute]
public float get_Left();
    public Rectangle get_Rectangle();
    [CompilerGeneratedAttribute]
public float get_Right();
    public PdfRectangle get_Rotate();
    [CompilerGeneratedAttribute]
public float get_Top();
    public float get_Width();
    public virtual bool Add(PdfObject obj);
    public virtual bool Add(Single[] values);
    public virtual bool Add(Int32[] values);
    public virtual void AddFirst(PdfObject obj);
    public float GetBottom(int margin);
    public float GetLeft(int margin);
    public float GetRight(int margin);
    public float GetTop(int margin);
}
public class iTextSharp.text.pdf.PdfRendition : PdfDictionary {
    public PdfRendition(string file, PdfFileSpecification fs, string mimeType);
}
public static class iTextSharp.text.pdf.PdfResourceFileCache : object {
    private static ConcurrentDictionary`2<string, Byte[]> _cache;
    private static PdfResourceFileCache();
    public static bool Set(string key, Byte[] value);
    public static Byte[] Get(string key);
    public static bool ContainsKey(string key);
}
internal class iTextSharp.text.pdf.PdfResources : PdfDictionary {
    internal void Add(PdfName key, PdfDictionary resource);
}
public class iTextSharp.text.pdf.PdfShading : object {
    protected bool antiAlias;
    protected Single[] bBox;
    protected ColorDetails colorDetails;
    protected PdfDictionary Shading;
    protected PdfName shadingName;
    protected PdfIndirectReference shadingReference;
    protected int ShadingType;
    protected PdfWriter writer;
    [CompilerGeneratedAttribute]
private BaseColor <ColorSpace>k__BackingField;
    public bool AntiAlias { get; public set; }
    public Single[] BBox { get; public set; }
    public BaseColor ColorSpace { get; private set; }
    internal ColorDetails ColorDetails { get; }
    unknown int Name {internal set; }
    internal PdfName ShadingName { get; }
    internal PdfIndirectReference ShadingReference { get; }
    internal PdfWriter Writer { get; }
    protected PdfShading(PdfWriter writer);
    public void set_AntiAlias(bool value);
    public bool get_AntiAlias();
    public Single[] get_BBox();
    public void set_BBox(Single[] value);
    [CompilerGeneratedAttribute]
public BaseColor get_ColorSpace();
    [CompilerGeneratedAttribute]
private void set_ColorSpace(BaseColor value);
    internal ColorDetails get_ColorDetails();
    internal void set_Name(int value);
    internal PdfName get_ShadingName();
    internal PdfIndirectReference get_ShadingReference();
    internal PdfWriter get_Writer();
    public static void CheckCompatibleColors(BaseColor c1, BaseColor c2);
    public static Single[] GetColorArray(BaseColor color);
    public static PdfShading SimpleAxial(PdfWriter writer, float x0, float y0, float x1, float y1, BaseColor startColor, BaseColor endColor, bool extendStart, bool extendEnd);
    public static PdfShading SimpleAxial(PdfWriter writer, float x0, float y0, float x1, float y1, BaseColor startColor, BaseColor endColor);
    public static PdfShading SimpleRadial(PdfWriter writer, float x0, float y0, float r0, float x1, float y1, float r1, BaseColor startColor, BaseColor endColor, bool extendStart, bool extendEnd);
    public static PdfShading SimpleRadial(PdfWriter writer, float x0, float y0, float r0, float x1, float y1, float r1, BaseColor startColor, BaseColor endColor);
    public static void ThrowColorSpaceError();
    public static PdfShading Type1(PdfWriter writer, BaseColor colorSpace, Single[] domain, Single[] tMatrix, PdfFunction function);
    public static PdfShading Type2(PdfWriter writer, BaseColor colorSpace, Single[] coords, Single[] domain, PdfFunction function, Boolean[] extend);
    public static PdfShading Type3(PdfWriter writer, BaseColor colorSpace, Single[] coords, Single[] domain, PdfFunction function, Boolean[] extend);
    internal void AddToBody();
    protected void SetColorSpace(BaseColor color);
}
public class iTextSharp.text.pdf.PdfShadingPattern : PdfDictionary {
    protected Single[] matrix;
    protected PdfName patternName;
    protected PdfIndirectReference patternReference;
    protected PdfShading shading;
    protected PdfWriter Writer;
    public Single[] Matrix { get; public set; }
    public PdfShading Shading { get; }
    internal ColorDetails ColorDetails { get; }
    unknown int Name {internal set; }
    internal PdfName PatternName { get; }
    internal PdfIndirectReference PatternReference { get; }
    internal PdfName ShadingName { get; }
    internal PdfIndirectReference ShadingReference { get; }
    public PdfShadingPattern(PdfShading shading);
    public Single[] get_Matrix();
    public void set_Matrix(Single[] value);
    public PdfShading get_Shading();
    internal ColorDetails get_ColorDetails();
    internal void set_Name(int value);
    internal PdfName get_PatternName();
    internal PdfIndirectReference get_PatternReference();
    internal PdfName get_ShadingName();
    internal PdfIndirectReference get_ShadingReference();
    internal void AddToBody();
}
public abstract class iTextSharp.text.pdf.PdfSigGenericPkcs : PdfSignature {
    private string _digestEncryptionAlgorithm;
    private Byte[] _externalDigest;
    private Byte[] _externalRsAdata;
    protected string HashAlgorithm;
    protected string name;
    protected PdfPkcs7 Pkcs;
    public string Name { get; }
    public PdfPkcs7 Signer { get; }
    public Byte[] SignerContents { get; }
    protected PdfSigGenericPkcs(PdfName filter, PdfName subFilter);
    public string get_Name();
    public PdfPkcs7 get_Signer();
    public Byte[] get_SignerContents();
    public void SetExternalDigest(Byte[] digest, Byte[] rsAdata, string digestEncryptionAlgorithm);
    public void SetSignInfo(ICipherParameters privKey, X509Certificate[] certChain, Object[] crlList);
}
public class iTextSharp.text.pdf.PdfSignature : PdfDictionary {
    unknown Int32[] ByteRange {public set; }
    unknown Byte[] Cert {public set; }
    unknown string Contact {public set; }
    unknown Byte[] Contents {public set; }
    unknown PdfDate Date {public set; }
    unknown string Location {public set; }
    unknown string Name {public set; }
    unknown string Reason {public set; }
    public PdfSignature(PdfName filter, PdfName subFilter);
    public void set_ByteRange(Int32[] value);
    public void set_Cert(Byte[] value);
    public void set_Contact(string value);
    public void set_Contents(Byte[] value);
    public void set_Date(PdfDate value);
    public void set_Location(string value);
    public void set_Name(string value);
    public void set_Reason(string value);
}
public class iTextSharp.text.pdf.PdfSignatureAppearance : object {
    public static int CERTIFIED_FORM_FILLING;
    public static int CERTIFIED_FORM_FILLING_AND_ANNOTATIONS;
    public static int CERTIFIED_NO_CHANGES_ALLOWED;
    public static int NOT_CERTIFIED;
    public static string questionMark;
    private static float Margin;
    private static float TopSection;
    public static PdfName SelfSigned;
    public static PdfName VerisignSigned;
    public static PdfName WincerSigned;
    private PdfTemplate[] _app;
    private PdfStamperImp _writer;
    private bool _acro6Layers;
    private Byte[] _bout;
    private int _boutLen;
    private string _contact;
    private string _digestEncryptionAlgorithm;
    private NullValueDictionary`2<PdfName, PdfLiteral> _exclusionLocations;
    private Byte[] _externalDigest;
    private Byte[] _externalRsAdata;
    private PdfTemplate _frm;
    private Image _image;
    private float _imageScale;
    private Font _layer2Font;
    private string _layer4Text;
    private bool _newField;
    private bool _preClosed;
    private FileStream _raf;
    private Int32[] _range;
    private int _runDirection;
    private ISignatureEvent _signatureEvent;
    [CompilerGeneratedAttribute]
private X509Certificate[] <CertChain>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CertificationLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private Object[] <CrlList>k__BackingField;
    [CompilerGeneratedAttribute]
private PdfDictionary <CryptoDictionary>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FieldName>k__BackingField;
    [CompilerGeneratedAttribute]
private PdfName <Filter>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Layer2Text>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Location>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Page>k__BackingField;
    [CompilerGeneratedAttribute]
private Rectangle <PageRect>k__BackingField;
    [CompilerGeneratedAttribute]
private ICipherParameters <PrivKey>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Reason>k__BackingField;
    [CompilerGeneratedAttribute]
private Rectangle <Rect>k__BackingField;
    [CompilerGeneratedAttribute]
private SignatureRender <Render>k__BackingField;
    [CompilerGeneratedAttribute]
private Image <SignatureGraphic>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <SignDate>k__BackingField;
    [CompilerGeneratedAttribute]
private PdfSigGenericPkcs <SigStandard>k__BackingField;
    [CompilerGeneratedAttribute]
private PdfStamper <Stamper>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TempFile>k__BackingField;
    [CompilerGeneratedAttribute]
private Stream <Originalout>k__BackingField;
    [CompilerGeneratedAttribute]
private ByteBuffer <Sigout>k__BackingField;
    public bool Acro6Layers { get; public set; }
    public X509Certificate[] CertChain { get; private set; }
    public int CertificationLevel { get; public set; }
    public string Contact { get; public set; }
    public Object[] CrlList { get; private set; }
    public PdfDictionary CryptoDictionary { get; public set; }
    public string FieldName { get; private set; }
    public PdfName Filter { get; private set; }
    public Image Image { get; public set; }
    public float ImageScale { get; public set; }
    public Font Layer2Font { get; public set; }
    public string Layer2Text { get; public set; }
    public string Layer4Text { get; public set; }
    public string Location { get; public set; }
    public int Page { get; private set; }
    public Rectangle PageRect { get; private set; }
    public ICipherParameters PrivKey { get; private set; }
    public Stream RangeStream { get; }
    public string Reason { get; public set; }
    public Rectangle Rect { get; private set; }
    public SignatureRender Render { get; public set; }
    public int RunDirection { get; public set; }
    public ISignatureEvent SignatureEvent { get; public set; }
    public Image SignatureGraphic { get; public set; }
    public DateTime SignDate { get; public set; }
    public PdfSigGenericPkcs SigStandard { get; private set; }
    public PdfStamper Stamper { get; private set; }
    public string TempFile { get; private set; }
    internal Stream Originalout { get; internal set; }
    internal ByteBuffer Sigout { get; internal set; }
    internal PdfSignatureAppearance(PdfStamperImp writer);
    private static PdfSignatureAppearance();
    public bool get_Acro6Layers();
    public void set_Acro6Layers(bool value);
    [CompilerGeneratedAttribute]
public X509Certificate[] get_CertChain();
    [CompilerGeneratedAttribute]
private void set_CertChain(X509Certificate[] value);
    [CompilerGeneratedAttribute]
public int get_CertificationLevel();
    [CompilerGeneratedAttribute]
public void set_CertificationLevel(int value);
    public string get_Contact();
    public void set_Contact(string value);
    [CompilerGeneratedAttribute]
public Object[] get_CrlList();
    [CompilerGeneratedAttribute]
private void set_CrlList(Object[] value);
    [CompilerGeneratedAttribute]
public PdfDictionary get_CryptoDictionary();
    [CompilerGeneratedAttribute]
public void set_CryptoDictionary(PdfDictionary value);
    [CompilerGeneratedAttribute]
public string get_FieldName();
    [CompilerGeneratedAttribute]
private void set_FieldName(string value);
    [CompilerGeneratedAttribute]
public PdfName get_Filter();
    [CompilerGeneratedAttribute]
private void set_Filter(PdfName value);
    public Image get_Image();
    public void set_Image(Image value);
    public float get_ImageScale();
    public void set_ImageScale(float value);
    public Font get_Layer2Font();
    public void set_Layer2Font(Font value);
    [CompilerGeneratedAttribute]
public string get_Layer2Text();
    [CompilerGeneratedAttribute]
public void set_Layer2Text(string value);
    public string get_Layer4Text();
    public void set_Layer4Text(string value);
    [CompilerGeneratedAttribute]
public string get_Location();
    [CompilerGeneratedAttribute]
public void set_Location(string value);
    [CompilerGeneratedAttribute]
public int get_Page();
    [CompilerGeneratedAttribute]
private void set_Page(int value);
    [CompilerGeneratedAttribute]
public Rectangle get_PageRect();
    [CompilerGeneratedAttribute]
private void set_PageRect(Rectangle value);
    [CompilerGeneratedAttribute]
public ICipherParameters get_PrivKey();
    [CompilerGeneratedAttribute]
private void set_PrivKey(ICipherParameters value);
    public Stream get_RangeStream();
    [CompilerGeneratedAttribute]
public string get_Reason();
    [CompilerGeneratedAttribute]
public void set_Reason(string value);
    [CompilerGeneratedAttribute]
public Rectangle get_Rect();
    [CompilerGeneratedAttribute]
private void set_Rect(Rectangle value);
    [CompilerGeneratedAttribute]
public SignatureRender get_Render();
    [CompilerGeneratedAttribute]
public void set_Render(SignatureRender value);
    public void set_RunDirection(int value);
    public int get_RunDirection();
    public ISignatureEvent get_SignatureEvent();
    public void set_SignatureEvent(ISignatureEvent value);
    [CompilerGeneratedAttribute]
public Image get_SignatureGraphic();
    [CompilerGeneratedAttribute]
public void set_SignatureGraphic(Image value);
    [CompilerGeneratedAttribute]
public DateTime get_SignDate();
    [CompilerGeneratedAttribute]
public void set_SignDate(DateTime value);
    [CompilerGeneratedAttribute]
public PdfSigGenericPkcs get_SigStandard();
    [CompilerGeneratedAttribute]
private void set_SigStandard(PdfSigGenericPkcs value);
    [CompilerGeneratedAttribute]
public PdfStamper get_Stamper();
    [CompilerGeneratedAttribute]
private void set_Stamper(PdfStamper value);
    [CompilerGeneratedAttribute]
public string get_TempFile();
    [CompilerGeneratedAttribute]
private void set_TempFile(string value);
    [CompilerGeneratedAttribute]
internal Stream get_Originalout();
    [CompilerGeneratedAttribute]
internal void set_Originalout(Stream value);
    [CompilerGeneratedAttribute]
internal ByteBuffer get_Sigout();
    [CompilerGeneratedAttribute]
internal void set_Sigout(ByteBuffer value);
    public static float FitText(Font font, string text, Rectangle rect, float maxFontSize, int runDirection);
    public void Close(PdfDictionary update);
    public PdfTemplate GetAppearance();
    public Image GetImage();
    public PdfTemplate GetLayer(int layer);
    public string GetNewSigName();
    public PdfTemplate GetTopLayer();
    public bool IsInvisible();
    public bool IsNewField();
    public bool IsPreClosed();
    public void PreClose();
    public void PreClose(INullValueDictionary`2<PdfName, int> exclusionSizes);
    public void SetCrypto(ICipherParameters privKey, X509Certificate[] certChain, Object[] crlList, PdfName filter);
    public void SetExternalDigest(Byte[] digest, Byte[] rsAdata, string digestEncryptionAlgorithm);
    public void SetVisibleSignature(Rectangle pageRect, int page, string fieldName);
    public void SetVisibleSignature(string fieldName);
    internal void SetStamper(PdfStamper stamper);
    internal void SetTempFile(string tempFile);
    private void addDocMdp(PdfDictionary crypto);
}
public class iTextSharp.text.pdf.PdfSmartCopy : PdfCopy {
    private INullValueDictionary`2<ByteStore, PdfIndirectReference> _streamMap;
    public PdfSmartCopy(Document document, Stream os);
    protected virtual PdfIndirectReference CopyIndirect(PrIndirectReference inp);
}
public class iTextSharp.text.pdf.PdfSpotColor : object {
    public BaseColor Altcs;
    public PdfName Name;
    protected float tint;
    public BaseColor AlternativeCs { get; }
    public float Tint { get; }
    public PdfSpotColor(string name, float tint, BaseColor altcs);
    public BaseColor get_AlternativeCs();
    public float get_Tint();
    protected internal PdfObject GetSpotObject(PdfWriter writer);
}
public class iTextSharp.text.pdf.PdfStamper : object {
    private bool _hasSignature;
    protected PdfStamperImp Stamper;
    [CompilerGeneratedAttribute]
private INullValueDictionary`2<string, string> <MoreInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private PdfSignatureAppearance <SignatureAppearance>k__BackingField;
    public AcroFields AcroFields { get; }
    unknown bool FormFlattening {public set; }
    unknown bool FreeTextFlattening {public set; }
    public bool FullCompression { get; }
    unknown string JavaScript {public set; }
    public INullValueDictionary`2<string, string> MoreInfo { get; public set; }
    unknown IList`1<INullValueDictionary`2<string, object>> Outlines {public set; }
    public PdfReader Reader { get; }
    public bool RotateContents { get; public set; }
    public PdfSignatureAppearance SignatureAppearance { get; private set; }
    public PdfWriter Writer { get; }
    unknown Byte[] XmpMetadata {public set; }
    unknown int ViewerPreferences {public set; }
    public PdfStamper(PdfReader reader, Stream os);
    public PdfStamper(PdfReader reader, Stream os, char pdfVersion);
    public PdfStamper(PdfReader reader, Stream os, char pdfVersion, bool append);
    public AcroFields get_AcroFields();
    public void set_FormFlattening(bool value);
    public void set_FreeTextFlattening(bool value);
    public bool get_FullCompression();
    public void set_JavaScript(string value);
    [CompilerGeneratedAttribute]
public void set_MoreInfo(INullValueDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public INullValueDictionary`2<string, string> get_MoreInfo();
    public void set_Outlines(IList`1<INullValueDictionary`2<string, object>> value);
    public PdfReader get_Reader();
    public void set_RotateContents(bool value);
    public bool get_RotateContents();
    [CompilerGeneratedAttribute]
public PdfSignatureAppearance get_SignatureAppearance();
    [CompilerGeneratedAttribute]
private void set_SignatureAppearance(PdfSignatureAppearance value);
    public PdfWriter get_Writer();
    public void set_XmpMetadata(Byte[] value);
    public sealed virtual void Dispose();
    public sealed virtual void SetEncryption(Byte[] userPassword, Byte[] ownerPassword, int permissions, int encryptionType);
    public sealed virtual void SetEncryption(X509Certificate[] certs, Int32[] permissions, int encryptionType);
    public virtual void set_ViewerPreferences(int value);
    public virtual void AddViewerPreference(PdfName key, PdfObject value);
    public static PdfStamper CreateSignature(PdfReader reader, Stream os, char pdfVersion, string tempFile, bool append);
    public static PdfStamper CreateSignature(PdfReader reader, Stream os, char pdfVersion);
    public static PdfStamper CreateSignature(PdfReader reader, Stream os, char pdfVersion, string tempFile);
    public void AddAnnotation(PdfAnnotation annot, int page);
    public void AddComments(FdfReader fdf);
    public void AddFileAttachment(string description, Byte[] fileStore, string file, string fileDisplay);
    public void AddFileAttachment(string description, PdfFileSpecification fs);
    public PdfFormField AddSignature(string name, int page, float llx, float lly, float urx, float ury);
    public void Close();
    public PdfImportedPage GetImportedPage(PdfReader reader, int pageNumber);
    public PdfContentByte GetOverContent(int pageNum);
    public INullValueDictionary`2<string, PdfLayer> GetPdfLayers();
    public PdfContentByte GetUnderContent(int pageNum);
    public void InsertPage(int pageNumber, Rectangle mediabox);
    public void MakePackage(PdfName initialView);
    public void MakePackage(PdfCollection collection);
    public bool PartialFormFlattening(string name);
    public void ReplacePage(PdfReader r, int pageImported, int pageReplaced);
    public void SetDuration(int seconds, int page);
    public void SetEncryption(Byte[] userPassword, Byte[] ownerPassword, int permissions, bool strength128Bits);
    public void SetEncryption(bool strength, string userPassword, string ownerPassword, int permissions);
    public void SetEncryption(int encryptionType, string userPassword, string ownerPassword, int permissions);
    public void SetFullCompression();
    public void SetPageAction(PdfName actionType, PdfAction action, int page);
    public void SetThumbnail(Image image, int page);
    public void SetTransition(PdfTransition transition, int page);
}
public class iTextSharp.text.pdf.PdfStamperImp : PdfWriter {
    internal RandomAccessFileOrArray File;
    internal NullValueDictionary`2<int, int> MyXref;
    internal INullValueDictionary`2<PdfDictionary, PageStamp> PagesToContent;
    internal PdfReader Reader;
    internal INullValueDictionary`2<PdfReader, RandomAccessFileOrArray> Readers2File;
    internal INullValueDictionary`2<PdfReader, NullValueDictionary`2<int, int>> Readers2Intrefs;
    protected AcroFields acroFields;
    protected internal bool Append;
    internal bool Closed;
    protected bool FieldsAdded;
    protected INullValueDictionary`2<PdfTemplate, object> FieldTemplates;
    protected bool Flat;
    protected bool FlatFreeText;
    protected int InitialXrefSize;
    protected NullValueDictionary`2<int, int> Marked;
    protected Int32[] NamePtr;
    protected PdfAction OpenAction;
    protected INullValueDictionary`2<string, object> PartialFlattening;
    protected int sigFlags;
    protected bool UseVp;
    protected PdfViewerPreferencesImp viewerPreferences;
    [CompilerGeneratedAttribute]
private bool <RotateContents>k__BackingField;
    public PdfContentByte DirectContent { get; }
    public PdfContentByte DirectContentUnder { get; }
    unknown int Duration {public set; }
    unknown int SigFlags {public set; }
    unknown Image Thumbnail {public set; }
    unknown PdfTransition Transition {public set; }
    unknown int ViewerPreferences {public set; }
    internal AcroFields AcroFields { get; }
    internal bool ContentWritten { get; }
    unknown bool FormFlattening {internal set; }
    unknown bool FreeTextFlattening {internal set; }
    internal bool RotateContents { get; internal set; }
    internal PdfStamperImp(PdfReader reader, Stream os, char pdfVersion, bool append);
    public virtual PdfContentByte get_DirectContent();
    public virtual PdfContentByte get_DirectContentUnder();
    public virtual void set_Duration(int value);
    public virtual void set_SigFlags(int value);
    public virtual void set_Thumbnail(Image value);
    public virtual void set_Transition(PdfTransition value);
    public virtual void set_ViewerPreferences(int value);
    internal AcroFields get_AcroFields();
    internal bool get_ContentWritten();
    internal void set_FormFlattening(bool value);
    internal void set_FreeTextFlattening(bool value);
    [CompilerGeneratedAttribute]
internal void set_RotateContents(bool value);
    [CompilerGeneratedAttribute]
internal bool get_RotateContents();
    public virtual void AddAnnotation(PdfAnnotation annot);
    public void AddComments(FdfReader fdf);
    public virtual void AddViewerPreference(PdfName key, PdfObject value);
    public virtual PdfIndirectReference GetPageReference(int page);
    public INullValueDictionary`2<string, PdfLayer> GetPdfLayers();
    public void RegisterReader(PdfReader reader, bool openFile);
    public virtual void SetAdditionalAction(PdfName actionType, PdfAction action);
    public virtual void SetOpenAction(PdfAction action);
    public virtual void SetOpenAction(string name);
    public virtual void SetPageAction(PdfName actionType, PdfAction action);
    public void UnRegisterReader(PdfReader reader);
    internal static void FindAllObjects(PdfReader reader, PdfObject obj, NullValueDictionary`2<int, int> hits);
    internal void AddAnnotation(PdfAnnotation annot, PdfDictionary pageN);
    internal virtual void AddAnnotation(PdfAnnotation annot, int page);
    internal void AddDocumentField(PdfIndirectReference refP);
    internal void AddFieldResources();
    internal void AlterContents();
    internal static void AlterResources(PageStamp ps);
    internal void ApplyRotation(PdfDictionary pageN, ByteBuffer outP);
    internal void Close(INullValueDictionary`2<string, string> moreInfo);
    internal void CorrectAcroFieldPages(int page);
    internal void DeleteOutlines();
    internal void EliminateAcroformObjects();
    internal static void ExpandFields(PdfFormField field, IList`1<PdfAnnotation> allAnnots);
    internal void FlatFields();
    internal PdfContentByte GetOverContent(int pageNum);
    internal PageStamp GetPageStamp(int pageNum);
    internal virtual RandomAccessFileOrArray GetReaderFile(PdfReader reader);
    internal PdfContentByte GetUnderContent(int pageNum);
    internal void InsertPage(int pageNumber, Rectangle mediabox);
    internal bool IsAppend();
    internal void MakePackage(PdfCollection collection);
    internal bool PartialFormFlattening(string name);
    internal void ReplacePage(PdfReader r, int pageImported, int pageReplaced);
    internal void SetDuration(int seconds, int page);
    internal void SetJavaScript();
    internal void SetOutlines();
    internal void SetPageAction(PdfName actionType, PdfAction action, int page);
    internal void SetThumbnail(Image image, int page);
    internal void SetTransition(PdfTransition transition, int page);
    internal static void SweepKids(PdfObject obj);
    protected internal virtual int GetNewObjectNumber(PdfReader reader, int number, int generation);
    protected internal void MarkUsed(PdfObject obj);
    protected internal void MarkUsed(int num);
    protected void ReadOcProperties();
    private static void moveRectangle(PdfDictionary dic2, PdfReader r, int pageImported, PdfName key, string name);
    private void addFileAttachments();
    private void addOrder(PdfLayer parent, PdfArray arr, INullValueDictionary`2<string, PdfLayer> ocgmap);
    private void flatFreeTextFields();
    private static void outlineTravel(PrIndirectReference outline);
}
public class iTextSharp.text.pdf.PdfStream : PdfDictionary {
    public static int BEST_COMPRESSION;
    public static int BEST_SPEED;
    public static int DEFAULT_COMPRESSION;
    public static int NO_COMPRESSION;
    internal static Byte[] Endstream;
    internal static int Sizestream;
    internal static Byte[] Startstream;
    protected bool Compressed;
    protected int CompressionLevel;
    protected Stream InputStream;
    protected int InputStreamLength;
    protected PdfIndirectReference Iref;
    protected int rawLength;
    protected MemoryStream StreamBytes;
    protected PdfWriter Writer;
    public int RawLength { get; }
    private static PdfStream();
    public PdfStream(Byte[] bytes);
    public PdfStream(Stream inputStream, PdfWriter writer);
    public int get_RawLength();
    public void FlateCompress();
    public void FlateCompress(int compressionLevel);
    public virtual void ToPdf(PdfWriter writer, Stream os);
    public virtual string ToString();
    public void WriteContent(Stream os);
    public void WriteLength();
    protected virtual void SuperToPdf(PdfWriter writer, Stream os);
}
public class iTextSharp.text.pdf.PdfString : PdfObject {
    protected string encoding;
    protected bool HexWriting;
    protected int ObjGen;
    protected int ObjNum;
    protected string OriginalValue;
    protected string Value;
    public string Encoding { get; }
    public PdfString(string value);
    public PdfString(string value, string encoding);
    public PdfString(Byte[] bytes);
    public string get_Encoding();
    public virtual Byte[] GetBytes();
    public Byte[] GetOriginalBytes();
    public bool IsHexWriting();
    public PdfString SetHexWriting(bool hexWriting);
    public virtual void ToPdf(PdfWriter writer, Stream os);
    public virtual string ToString();
    public string ToUnicodeString();
    internal void Decrypt(PdfReader reader);
    internal void SetObjNum(int objNum, int objGen);
}
public class iTextSharp.text.pdf.PdfStructureElement : PdfDictionary {
    private PdfStructureElement _parent;
    private PdfStructureTreeRoot _top;
    private PdfIndirectReference _reference;
    public PdfDictionary Parent { get; }
    public PdfIndirectReference Reference { get; }
    public PdfStructureElement(PdfStructureElement parent, PdfName structureType);
    public PdfStructureElement(PdfStructureTreeRoot parent, PdfName structureType);
    public PdfDictionary get_Parent();
    public PdfIndirectReference get_Reference();
    internal void SetPageMark(int page, int mark);
    private void init(PdfDictionary parent, PdfName structureType);
}
public class iTextSharp.text.pdf.PdfStructureTreeRoot : PdfDictionary {
    private INullValueDictionary`2<int, PdfObject> _parentTree;
    private PdfWriter _writer;
    [CompilerGeneratedAttribute]
private PdfIndirectReference <Reference>k__BackingField;
    public PdfIndirectReference Reference { get; }
    public PdfWriter Writer { get; }
    internal PdfStructureTreeRoot(PdfWriter writer);
    [CompilerGeneratedAttribute]
public PdfIndirectReference get_Reference();
    public PdfWriter get_Writer();
    public void MapRole(PdfName used, PdfName standard);
    internal void BuildTree();
    internal void SetPageMark(int page, PdfIndirectReference struc);
    private void nodeProcess(PdfDictionary struc, PdfIndirectReference reference);
}
public class iTextSharp.text.pdf.PdfTable : Rectangle {
    private List`1<PdfCell> _cells;
    private List`1<PdfCell> _headercells;
    protected Single[] Positions;
    protected Table Table;
    [CompilerGeneratedAttribute]
private int <Columns>k__BackingField;
    public float Offset { get; }
    public int Type { get; }
    internal float Cellpadding { get; }
    internal IList`1<PdfCell> Cells { get; }
    internal float Cellspacing { get; }
    internal int Columns { get; }
    internal IList`1<PdfCell> HeaderCells { get; }
    internal int Rows { get; }
    internal PdfTable(Table table, float left, float right, float top);
    public float get_Offset();
    public virtual int get_Type();
    internal float get_Cellpadding();
    internal IList`1<PdfCell> get_Cells();
    internal float get_Cellspacing();
    [CompilerGeneratedAttribute]
internal int get_Columns();
    internal IList`1<PdfCell> get_HeaderCells();
    internal int get_Rows();
    public bool HasToFitPageCells();
    public bool HasToFitPageTable();
    internal bool HasHeader();
    internal void UpdateRowAdditions();
    private void updateRowAdditionsInternal();
}
public class iTextSharp.text.pdf.PdfTemplate : PdfContentByte {
    public static int TYPE_IMPORTED;
    public static int TYPE_PATTERN;
    public static int TYPE_TEMPLATE;
    protected Rectangle BBox;
    protected PdfTransparencyGroup group;
    protected IPdfOcg layer;
    protected PdfArray matrix;
    protected PageResources pageResources;
    protected PdfIndirectReference ThisReference;
    protected int type;
    public Rectangle BoundingBox { get; public set; }
    public PdfContentByte Duplicate { get; }
    public PdfTransparencyGroup Group { get; public set; }
    public float Height { get; public set; }
    public PdfIndirectReference IndirectReference { get; }
    public IPdfOcg Layer { get; public set; }
    public int Type { get; }
    public float Width { get; public set; }
    internal PdfArray Matrix { get; }
    internal PageResources PageResources { get; }
    internal PdfObject Resources { get; }
    internal PdfTemplate(PdfWriter wr);
    public Rectangle get_BoundingBox();
    public void set_BoundingBox(Rectangle value);
    public virtual PdfContentByte get_Duplicate();
    public virtual PdfTransparencyGroup get_Group();
    public virtual void set_Group(PdfTransparencyGroup value);
    public float get_Height();
    public void set_Height(float value);
    public PdfIndirectReference get_IndirectReference();
    public IPdfOcg get_Layer();
    public void set_Layer(IPdfOcg value);
    public int get_Type();
    public float get_Width();
    public void set_Width(float value);
    internal PdfArray get_Matrix();
    internal virtual PageResources get_PageResources();
    internal virtual PdfObject get_Resources();
    public static PdfTemplate CreateTemplate(PdfWriter writer, float width, float height);
    public void BeginVariableText();
    public void EndVariableText();
    public void SetMatrix(float a, float b, float c, float d, float e, float f);
    internal static PdfTemplate CreateTemplate(PdfWriter writer, float width, float height, PdfName forcedName);
    internal virtual PdfStream GetFormXObject(int compressionLevel);
}
public class iTextSharp.text.pdf.PdfTextArray : object {
    private float _lastNum;
    private string _lastStr;
    [CompilerGeneratedAttribute]
private List`1<object> <ArrayList>k__BackingField;
    internal List`1<object> ArrayList { get; }
    public PdfTextArray(string str);
    [CompilerGeneratedAttribute]
internal List`1<object> get_ArrayList();
    public void Add(PdfNumber number);
    public void Add(float number);
    public void Add(string str);
    private void replaceLast(object obj);
}
public class iTextSharp.text.pdf.PdfTransition : object {
    public static int BLINDH;
    public static int BLINDV;
    public static int BTWIPE;
    public static int DGLITTER;
    public static int DISSOLVE;
    public static int INBOX;
    public static int LRGLITTER;
    public static int LRWIPE;
    public static int OUTBOX;
    public static int RLWIPE;
    public static int SPLITHIN;
    public static int SPLITHOUT;
    public static int SPLITVIN;
    public static int SPLITVOUT;
    public static int TBGLITTER;
    public static int TBWIPE;
    protected int duration;
    protected int type;
    public int Duration { get; }
    public PdfDictionary TransitionDictionary { get; }
    public int Type { get; }
    public PdfTransition(int type);
    public PdfTransition(int type, int duration);
    public int get_Duration();
    public PdfDictionary get_TransitionDictionary();
    public int get_Type();
}
public class iTextSharp.text.pdf.PdfTransparencyGroup : PdfDictionary {
    unknown bool Isolated {public set; }
    unknown bool Knockout {public set; }
    public void set_Isolated(bool value);
    public void set_Knockout(bool value);
}
public class iTextSharp.text.pdf.PdfWriter : DocWriter {
    public static int ALLOW_ASSEMBLY;
    public static int ALLOW_COPY;
    public static int ALLOW_DEGRADED_PRINTING;
    public static int ALLOW_FILL_IN;
    public static int ALLOW_MODIFY_ANNOTATIONS;
    public static int ALLOW_MODIFY_CONTENTS;
    public static int ALLOW_PRINTING;
    public static int ALLOW_SCREENREADERS;
    public static int AllowAssembly;
    public static int AllowCopy;
    public static int AllowDegradedPrinting;
    public static int AllowFillIn;
    public static int AllowModifyAnnotations;
    public static int AllowModifyContents;
    public static int AllowPrinting;
    public static int AllowScreenReaders;
    public static int CenterWindow;
    public static int DirectionL2R;
    public static int DirectionR2L;
    public static int DisplayDocTitle;
    public static int DO_NOT_ENCRYPT_METADATA;
    public static int EMBEDDED_FILES_ONLY;
    public static int ENCRYPTION_AES_128;
    public static int ENCRYPTION_AES_256_V3;
    public static int FitWindow;
    public static int GENERATION_MAX;
    public static int HideMenubar;
    public static int HideToolbar;
    public static int HideWindowUI;
    public static float NO_SPACE_CHAR_RATIO;
    public static int NonFullScreenPageModeUseNone;
    public static int NonFullScreenPageModeUseOC;
    public static int NonFullScreenPageModeUseOutlines;
    public static int NonFullScreenPageModeUseThumbs;
    public static int PageLayoutOneColumn;
    public static int PageLayoutSinglePage;
    public static int PageLayoutTwoColumnLeft;
    public static int PageLayoutTwoColumnRight;
    public static int PageLayoutTwoPageLeft;
    public static int PageLayoutTwoPageRight;
    public static int PageModeFullScreen;
    public static int PageModeUseAttachments;
    public static int PageModeUseNone;
    public static int PageModeUseOC;
    public static int PageModeUseOutlines;
    public static int PageModeUseThumbs;
    public static int PDFA1A;
    public static int PDFA1B;
    public static int PDFX1A2001;
    public static int PDFX32002;
    public static int PDFXNONE;
    public static int PrintScalingNone;
    public static int RUN_DIRECTION_DEFAULT;
    public static int RUN_DIRECTION_LTR;
    public static int RUN_DIRECTION_NO_BIDI;
    public static int RUN_DIRECTION_RTL;
    public static int SIGNATURE_APPEND_ONLY;
    public static int SIGNATURE_EXISTS;
    public static float SPACE_CHAR_RATIO_DEFAULT;
    public static int STANDARD_ENCRYPTION_128;
    public static int STANDARD_ENCRYPTION_40;
    public static bool STRENGTH128BITS;
    public static bool STRENGTH40BITS;
    public static char VERSION_1_2;
    public static char VERSION_1_3;
    public static char VERSION_1_4;
    public static char VERSION_1_5;
    public static char VERSION_1_6;
    public static char VERSION_1_7;
    internal static int ENCRYPTION_MASK;
    public static PdfName PageClose;
    public static PdfName PageOpen;
    public static PdfName PdfVersion12;
    public static PdfName PdfVersion13;
    public static PdfName PdfVersion14;
    public static PdfName PdfVersion15;
    public static PdfName PdfVersion16;
    public static PdfName PdfVersion17;
    public static PdfName DidPrint;
    public static PdfName DidSave;
    public static PdfName DocumentClose;
    public static PdfName WillPrint;
    public static PdfName WillSave;
    private static Single[] _gammaValues;
    private static Single[] _matrixValues;
    private static Single[] _whitepointValues;
    private NullValueDictionary`2<long, PdfName> _images;
    private PdfXConformanceImp _pdfxConformance;
    private IPdfPageEvent _pageEvent;
    private bool _rgbTransparencyBlending;
    private float _spaceCharRatio;
    private bool _userProperties;
    protected internal PdfBody Body;
    protected int ColorNumber;
    protected internal int compressionLevel;
    protected PdfEncryption Crypto;
    protected int currentPageNumber;
    protected PdfReaderInstance CurrentPdfReaderInstance;
    protected PdfDictionary defaultColorspace;
    protected PdfContentByte directContent;
    protected PdfContentByte directContentUnder;
    protected INullValueDictionary`2<PdfSpotColor, ColorDetails> DocumentColors;
    protected INullValueDictionary`2<PdfDictionary, PdfObject[]> DocumentExtGState;
    protected INullValueDictionary`2<BaseFont, FontDetails> DocumentFonts;
    protected INullValueDictionary`2<IPdfOcg, object> DocumentOcg;
    protected List`1<IPdfOcg> DocumentOcGorder;
    protected INullValueDictionary`2<PdfPatternPainter, PdfName> DocumentPatterns;
    protected INullValueDictionary`2<object, PdfObject[]> DocumentProperties;
    protected INullValueDictionary`2<PdfShadingPattern, object> DocumentShadingPatterns;
    protected INullValueDictionary`2<PdfShading, object> DocumentShadings;
    protected INullValueDictionary`2<ColorDetails, ColorDetails> DocumentSpotPatterns;
    protected internal PdfDictionary extraCatalog;
    protected int FontNumber;
    protected INullValueDictionary`2<PdfIndirectReference, Object[]> FormXObjects;
    protected int FormXObjectsCounter;
    protected bool fullCompression;
    protected PdfDictionary group;
    protected PdfDictionary ImageDictionary;
    protected INullValueDictionary`2<PdfReader, PdfReaderInstance> ImportedPages;
    protected INullValueDictionary`2<PdfStream, PdfIndirectReference> Jbig2Globals;
    protected IList`1<INullValueDictionary`2<string, object>> NewBookmarks;
    protected PdfArray OcgLocked;
    protected PdfArray OcgRadioGroup;
    protected List`1<PdfIndirectReference> PageReferences;
    protected ColorDetails PatternColorspaceCmyk;
    protected ColorDetails PatternColorspaceGray;
    protected ColorDetails PatternColorspaceRgb;
    protected int PatternNumber;
    protected internal PdfDocument Pdf;
    protected PdfVersionImp pdf_version;
    protected int Prevxref;
    protected PdfPages Root;
    protected int runDirection;
    protected PdfStructureTreeRoot structureTreeRoot;
    protected PdfName tabs;
    protected bool Tagged;
    protected float userunit;
    protected PdfOcProperties VOcProperties;
    protected Byte[] xmpMetadata;
    [CompilerGeneratedAttribute]
private PdfDictionary <PageDictionary>k__BackingField;
    public float CurrentPageHeight { get; }
    unknown PdfCollection Collection {public set; }
    public int CompressionLevel { get; public set; }
    unknown Rectangle CropBoxSize {public set; }
    public int CurrentDocumentSize { get; }
    public int CurrentPageNumber { get; }
    public PdfDictionary DefaultColorspace { get; }
    public PdfContentByte DirectContent { get; }
    public PdfContentByte DirectContentUnder { get; }
    public PdfDictionary ExtraCatalog { get; }
    public bool FullCompression { get; }
    public PdfDictionary Group { get; public set; }
    public PdfDictionary Info { get; }
    public PdfOcProperties OcProperties { get; }
    unknown IList`1<INullValueDictionary`2<string, object>> Outlines {public set; }
    unknown bool PageEmpty {public set; }
    public IPdfPageEvent PageEvent { get; public set; }
    unknown PdfPageLabels PageLabels {public set; }
    public int PageNumber { get; }
    public Rectangle PageSize { get; }
    unknown Byte[] PageXmpMetadata {public set; }
    public PdfIndirectReference PdfIndirectReference { get; }
    public bool RgbTransparencyBlending { get; public set; }
    public PdfOutline RootOutline { get; }
    public float SpaceCharRatio { get; public set; }
    public bool StrictImageSequence { get; public set; }
    public PdfStructureTreeRoot StructureTreeRoot { get; }
    public PdfName Tabs { get; public set; }
    public PdfDictionary PageDictionary { get; public set; }
    unknown Image Thumbnail {public set; }
    public bool UserProperties { get; public set; }
    public float Userunit { get; public set; }
    public Byte[] XmpMetadata { get; public set; }
    internal PdfIndirectReference CurrentPage { get; }
    internal PdfEncryption Encryption { get; }
    internal int IndirectReferenceNumber { get; }
    internal OutputStreamCounter Os { get; }
    internal PdfDocument PdfDocument { get; }
    public PdfAcroForm AcroForm { get; }
    unknown int SigFlags {public set; }
    unknown int Duration {public set; }
    unknown PdfTransition Transition {public set; }
    public int RunDirection { get; public set; }
    unknown char PdfVersion {public set; }
    unknown int ViewerPreferences {public set; }
    public int PdfxConformance { get; public set; }
    protected PdfWriter(PdfDocument document, Stream os);
    private static PdfWriter();
    public float get_CurrentPageHeight();
    public void set_Collection(PdfCollection value);
    public void set_CompressionLevel(int value);
    public int get_CompressionLevel();
    public virtual void set_CropBoxSize(Rectangle value);
    public int get_CurrentDocumentSize();
    public virtual int get_CurrentPageNumber();
    public PdfDictionary get_DefaultColorspace();
    public virtual PdfContentByte get_DirectContent();
    public virtual PdfContentByte get_DirectContentUnder();
    public PdfDictionary get_ExtraCatalog();
    public bool get_FullCompression();
    public PdfDictionary get_Group();
    public void set_Group(PdfDictionary value);
    public PdfDictionary get_Info();
    public PdfOcProperties get_OcProperties();
    public void set_Outlines(IList`1<INullValueDictionary`2<string, object>> value);
    public void set_PageEmpty(bool value);
    public IPdfPageEvent get_PageEvent();
    public void set_PageEvent(IPdfPageEvent value);
    public virtual void set_PageLabels(PdfPageLabels value);
    public int get_PageNumber();
    public Rectangle get_PageSize();
    public void set_PageXmpMetadata(Byte[] value);
    public PdfIndirectReference get_PdfIndirectReference();
    public bool get_RgbTransparencyBlending();
    public void set_RgbTransparencyBlending(bool value);
    public PdfOutline get_RootOutline();
    public virtual void set_SpaceCharRatio(float value);
    public virtual float get_SpaceCharRatio();
    public void set_StrictImageSequence(bool value);
    public bool get_StrictImageSequence();
    public PdfStructureTreeRoot get_StructureTreeRoot();
    public PdfName get_Tabs();
    public void set_Tabs(PdfName value);
    [CompilerGeneratedAttribute]
public void set_PageDictionary(PdfDictionary value);
    [CompilerGeneratedAttribute]
public PdfDictionary get_PageDictionary();
    public virtual void set_Thumbnail(Image value);
    public void set_UserProperties(bool value);
    public bool get_UserProperties();
    public float get_Userunit();
    public void set_Userunit(float value);
    public void set_XmpMetadata(Byte[] value);
    public Byte[] get_XmpMetadata();
    internal virtual PdfIndirectReference get_CurrentPage();
    internal PdfEncryption get_Encryption();
    internal int get_IndirectReferenceNumber();
    internal OutputStreamCounter get_Os();
    internal PdfDocument get_PdfDocument();
    public sealed virtual PdfAcroForm get_AcroForm();
    public virtual void set_SigFlags(int value);
    public virtual void AddAnnotation(PdfAnnotation annot);
    public virtual void AddCalculationOrder(PdfFormField annot);
    public virtual void SetAdditionalAction(PdfName actionType, PdfAction action);
    public virtual void SetOpenAction(string name);
    public virtual void SetOpenAction(PdfAction action);
    public sealed virtual void SetEncryption(Byte[] userPassword, Byte[] ownerPassword, int permissions, int encryptionType);
    public sealed virtual void SetEncryption(X509Certificate[] certs, Int32[] permissions, int encryptionType);
    public virtual void set_Duration(int value);
    public virtual void set_Transition(PdfTransition value);
    public virtual void SetPageAction(PdfName actionType, PdfAction action);
    public virtual void set_RunDirection(int value);
    public virtual int get_RunDirection();
    public virtual void set_PdfVersion(char value);
    public sealed virtual void AddDeveloperExtension(PdfDeveloperExtension de);
    public sealed virtual void SetAtLeastPdfVersion(char version);
    public sealed virtual void SetPdfVersion(PdfName version);
    public virtual void set_ViewerPreferences(int value);
    public virtual void AddViewerPreference(PdfName key, PdfObject value);
    public sealed virtual void set_PdfxConformance(int value);
    public sealed virtual int get_PdfxConformance();
    public sealed virtual bool IsPdfX();
    public static PdfWriter GetInstance(Document document, Stream os);
    public static PdfWriter GetInstance(Document document, Stream os, IDocListener listener);
    public PdfName AddDirectImageSimple(Image image);
    public PdfName AddDirectImageSimple(Image image, PdfIndirectReference fixedRef);
    public virtual void AddFileAttachment(string description, Byte[] fileStore, string file, string fileDisplay);
    public virtual void AddFileAttachment(string description, PdfFileSpecification fs);
    public void AddFileAttachment(PdfFileSpecification fs);
    public virtual void AddJavaScript(PdfAction js);
    public virtual void AddJavaScript(string code, bool unicode);
    public virtual void AddJavaScript(string code);
    public void AddJavaScript(string name, PdfAction js);
    public void AddJavaScript(string name, string code, bool unicode);
    public void AddJavaScript(string name, string code);
    public void AddOcgRadioGroup(IList`1<PdfLayer> group);
    public PdfIndirectObject AddToBody(PdfObject objecta);
    public PdfIndirectObject AddToBody(PdfObject objecta, bool inObjStm);
    public PdfIndirectObject AddToBody(PdfObject objecta, PdfIndirectReference refa);
    public PdfIndirectObject AddToBody(PdfObject objecta, PdfIndirectReference refa, bool inObjStm);
    public PdfIndirectObject AddToBody(PdfObject objecta, int refNumber);
    public PdfIndirectObject AddToBody(PdfObject objecta, int refNumber, bool inObjStm);
    public void ClearTextWrap();
    public virtual void Close();
    public void CreateXmpMetadata();
    public bool FitsPage(Table table, float margin);
    public bool FitsPage(Table table);
    public virtual void FreeReader(PdfReader reader);
    public Rectangle GetBoxSize(string boxName);
    public virtual PdfImportedPage GetImportedPage(PdfReader reader, int pageNumber);
    public virtual PdfIndirectReference GetPageReference(int page);
    public float GetVerticalPosition(bool ensureNewLine);
    public bool IsTagged();
    public void LockLayer(PdfLayer layer);
    public virtual void Open();
    public void ReleaseTemplate(PdfTemplate tp);
    public int ReorderPages(Int32[] order);
    public void SetBoxSize(string boxName, Rectangle size);
    public void SetDefaultColorspace(PdfName key, PdfObject cs);
    public void SetEncryption(Byte[] userPassword, Byte[] ownerPassword, int permissions, bool strength128Bits);
    public void SetEncryption(bool strength, string userPassword, string ownerPassword, int permissions);
    public void SetEncryption(int encryptionType, string userPassword, string ownerPassword, int permissions);
    public void SetFullCompression();
    public void SetLinearPageMode();
    public void SetOutputIntents(string outputConditionIdentifier, string outputCondition, string registryName, string info, IccProfile colorProfile);
    public void SetOutputIntents(string outputConditionIdentifier, string outputCondition, string registryName, string info, Byte[] destOutputProfile);
    public bool SetOutputIntents(PdfReader reader, bool checkExistence);
    public void SetTagged();
    internal virtual PdfIndirectReference Add(PdfPage page, PdfContents contents);
    internal virtual PdfIndirectReference Add(PdfImage pdfImage, PdfIndirectReference fixedRef);
    internal virtual void AddAnnotation(PdfAnnotation annot, int page);
    internal PdfName AddDirectTemplateSimple(PdfTemplate template, PdfName forcedName);
    internal void AddLocalDestinations(OrderedTree dest);
    internal FontDetails AddSimple(BaseFont bf);
    internal ColorDetails AddSimple(PdfSpotColor spc);
    internal PdfObject[] AddSimpleExtGState(PdfDictionary gstate);
    internal PdfName AddSimplePattern(PdfPatternPainter painter);
    internal ColorDetails AddSimplePatternColorspace(BaseColor color);
    internal PdfObject[] AddSimpleProperty(object prop, PdfIndirectReference refi);
    internal void AddSimpleShading(PdfShading shading);
    internal void AddSimpleShadingPattern(PdfShadingPattern shading);
    internal void EliminateFontSubset(PdfDictionary fonts);
    internal PdfName GetColorspaceName();
    internal virtual PdfIndirectReference GetImageReference(PdfName name);
    internal PdfVersionImp GetPdfVersion();
    internal virtual RandomAccessFileOrArray GetReaderFile(PdfReader reader);
    internal bool PropertyExists(object prop);
    internal void RegisterLayer(IPdfOcg layer);
    internal void ResetContent();
    protected internal virtual int GetNewObjectNumber(PdfReader reader, int number, int generation);
    protected internal PdfIndirectReference GetReferenceJbig2Globals(Byte[] content);
    protected internal void WriteOutlines(PdfDictionary catalog, bool namedAsNames);
    protected virtual PdfIndirectReference Add(PdfIccBased icc);
    protected void AddSharedObjectsToBody();
    protected void FillOcProperties(bool erase);
    protected virtual PdfDictionary GetCatalog(PdfIndirectReference rootObj);
    private static string getNameString(PdfDictionary dic, PdfName key);
    private static void getOcgOrder(PdfArray order, PdfLayer layer);
    private void addAsEvent(PdfName eventa, PdfName category);
    private Byte[] createXmpMetadataBytes();
}
public class iTextSharp.text.pdf.PdfXConformanceException : Exception {
    public PdfXConformanceException(string s);
    public PdfXConformanceException(string message, Exception innerException);
}
public class iTextSharp.text.pdf.Pfm2Afm : object {
    private Encoding _encoding;
    private RandomAccessFileOrArray _inp;
    private StreamWriter _outp;
    private Int32[] _win2PsStd;
    private String[] _winChars;
    private short _ascender;
    private short _ascent;
    private short _avgwidth;
    private int _bitoff;
    private int _bits;
    private byte _brkchar;
    private short _capheight;
    private byte _charset;
    private int _chartab;
    private string _copyright;
    private byte _defchar;
    private short _descender;
    private int _device;
    private short _extleading;
    private short _extlen;
    private int _face;
    private int _firstchar;
    private int _fontname;
    private int _hLen;
    private short _horres;
    private short _intleading;
    private bool _isMono;
    private byte _italic;
    private int _kernpairs;
    private byte _kind;
    private int _lastchar;
    private short _maxwidth;
    private byte _overs;
    private short _pixheight;
    private short _pixwidth;
    private short _points;
    private int _psext;
    private int _res1;
    private int _res2;
    private short _type;
    private byte _uline;
    private short _verres;
    private short _vers;
    private short _weight;
    private short _widthby;
    private Int32[] _winClass;
    private short _xheight;
    private Pfm2Afm(RandomAccessFileOrArray inp, Stream outp);
    public static void Convert(RandomAccessFileOrArray inp, Stream outp);
    private void openpfm();
    private void outchar(int code, int width, string name);
    private void outval(int n);
    private void putchartab();
    private void putheader();
    private void putkerntab();
    private void puttrailer();
    private string readString(int n);
    private string readString();
}
public class iTextSharp.text.pdf.PrAcroForm : PdfDictionary {
    internal INullValueDictionary`2<string, FieldInformation> FieldByName;
    internal List`1<FieldInformation> fields;
    internal PdfReader Reader;
    internal List`1<PdfDictionary> Stack;
    public IList`1<FieldInformation> Fields { get; }
    public int Size { get; }
    public PrAcroForm(PdfReader reader);
    public IList`1<FieldInformation> get_Fields();
    public int get_Size();
    public FieldInformation GetField(string name);
    public PrIndirectReference GetRefByName(string name);
    public void ReadAcroForm(PdfDictionary root);
    protected void IterateFields(PdfArray fieldlist, PrIndirectReference fieldDict, string title);
    protected static PdfDictionary MergeAttrib(PdfDictionary parent, PdfDictionary child);
    protected void PushAttrib(PdfDictionary dict);
}
public class iTextSharp.text.pdf.PrIndirectReference : PdfIndirectReference {
    protected PdfReader reader;
    public PdfReader Reader { get; }
    internal PrIndirectReference(PdfReader reader, int number, int generation);
    internal PrIndirectReference(PdfReader reader, int number);
    public PdfReader get_Reader();
    public void SetNumber(int number, int generation);
    public virtual void ToPdf(PdfWriter writer, Stream os);
}
public class iTextSharp.text.pdf.PrStream : PdfStream {
    protected int length;
    protected int objGen;
    protected int objNum;
    protected int offset;
    protected PdfReader reader;
    public int Length { get; public set; }
    public int ObjGen { get; public set; }
    public int ObjNum { get; public set; }
    public int Offset { get; }
    public PdfReader Reader { get; }
    public PrStream(PrStream stream, PdfDictionary newDic);
    public PrStream(PrStream stream, PdfDictionary newDic, PdfReader reader);
    public PrStream(PdfReader reader, int offset);
    public PrStream(PdfReader reader, Byte[] conts);
    public PrStream(PdfReader reader, Byte[] conts, int compressionLevel);
    public void set_Length(int value);
    public int get_Length();
    public int get_ObjGen();
    public void set_ObjGen(int value);
    public int get_ObjNum();
    public void set_ObjNum(int value);
    public int get_Offset();
    public PdfReader get_Reader();
    public Byte[] GetBytes();
    public void SetData(Byte[] data, bool compress);
    public void SetData(Byte[] data, bool compress, int compressionLevel);
    public void SetData(Byte[] data);
    public virtual void ToPdf(PdfWriter writer, Stream os);
}
public class iTextSharp.text.pdf.PrTokeniser : object {
    public static int TK_COMMENT;
    public static int TK_END_ARRAY;
    public static int TK_END_DIC;
    public static int TK_NAME;
    public static int TK_NUMBER;
    public static int TK_OTHER;
    public static int TK_REF;
    public static int TK_START_ARRAY;
    public static int TK_START_DIC;
    public static int TK_STRING;
    internal static string EMPTY;
    protected RandomAccessFileOrArray file;
    protected int generation;
    protected bool HexString;
    protected int reference;
    protected string stringValue;
    protected int Type;
    public RandomAccessFileOrArray File { get; }
    public int FilePointer { get; }
    public int Generation { get; }
    public int IntValue { get; }
    public int Length { get; }
    public int Reference { get; }
    public RandomAccessFileOrArray SafeFile { get; }
    public long Startxref { get; }
    public string StringValue { get; }
    public int TokenType { get; }
    public PrTokeniser(string filename);
    public PrTokeniser(Byte[] pdfIn);
    public PrTokeniser(RandomAccessFileOrArray file);
    public RandomAccessFileOrArray get_File();
    public int get_FilePointer();
    public int get_Generation();
    public int get_IntValue();
    public int get_Length();
    public int get_Reference();
    public RandomAccessFileOrArray get_SafeFile();
    public long get_Startxref();
    public string get_StringValue();
    public int get_TokenType();
    public static Int32[] CheckObjectStart(Byte[] line);
    public static int GetHex(int v);
    public static bool IsDelimiter(int ch);
    public static bool IsWhitespace(int ch);
    public void BackOnePosition(int ch);
    public void CheckFdfHeader();
    public char CheckPdfHeader();
    public void Close();
    public bool IsHexString();
    public bool NextToken();
    public void NextValidToken();
    public int Read();
    public bool ReadLineSegment(Byte[] input);
    public string ReadString(int size);
    public void Seek(int pos);
    public void ThrowError(string error);
}
public class iTextSharp.text.pdf.PushbuttonField : BaseField {
    public static int LAYOUT_ICON_LEFT_LABEL_RIGHT;
    public static int LAYOUT_ICON_ONLY;
    public static int LAYOUT_ICON_TOP_LABEL_BOTTOM;
    public static int LAYOUT_LABEL_LEFT_ICON_RIGHT;
    public static int LAYOUT_LABEL_ONLY;
    public static int LAYOUT_LABEL_OVER_ICON;
    public static int LAYOUT_LABEL_TOP_ICON_BOTTOM;
    public static int SCALE_ICON_ALWAYS;
    public static int SCALE_ICON_IS_TOO_BIG;
    public static int SCALE_ICON_IS_TOO_SMALL;
    public static int SCALE_ICON_NEVER;
    private bool _iconFitToBounds;
    private float _iconHorizontalAdjustment;
    private PrIndirectReference _iconReference;
    private float _iconVerticalAdjustment;
    private Image _image;
    private int _layout;
    private bool _proportionalIcon;
    private int _scaleIcon;
    private PdfTemplate _template;
    private PdfTemplate _tp;
    public PdfFormField Field { get; }
    public bool IconFitToBounds { get; public set; }
    public float IconHorizontalAdjustment { get; public set; }
    public PrIndirectReference IconReference { get; public set; }
    public float IconVerticalAdjustment { get; public set; }
    public Image Image { get; public set; }
    public int Layout { get; public set; }
    public bool ProportionalIcon { get; public set; }
    public int ScaleIcon { get; public set; }
    public PdfTemplate Template { get; public set; }
    public PushbuttonField(PdfWriter writer, Rectangle box, string fieldName);
    public PdfFormField get_Field();
    public bool get_IconFitToBounds();
    public void set_IconFitToBounds(bool value);
    public float get_IconHorizontalAdjustment();
    public void set_IconHorizontalAdjustment(float value);
    public PrIndirectReference get_IconReference();
    public void set_IconReference(PrIndirectReference value);
    public float get_IconVerticalAdjustment();
    public void set_IconVerticalAdjustment(float value);
    public Image get_Image();
    public void set_Image(Image value);
    public void set_Layout(int value);
    public int get_Layout();
    public bool get_ProportionalIcon();
    public void set_ProportionalIcon(bool value);
    public void set_ScaleIcon(int value);
    public int get_ScaleIcon();
    public void set_Template(PdfTemplate value);
    public PdfTemplate get_Template();
    public PdfAppearance GetAppearance();
    private float calculateFontSize(float w, float h);
}
public class iTextSharp.text.pdf.RadioCheckField : BaseField {
    public static int TYPE_CHECK;
    public static int TYPE_CIRCLE;
    public static int TYPE_CROSS;
    public static int TYPE_DIAMOND;
    public static int TYPE_SQUARE;
    public static int TYPE_STAR;
    private static String[] _typeChars;
    private int _checkType;
    private string _onValue;
    private bool _vchecked;
    public bool Checked { get; public set; }
    public PdfFormField CheckField { get; }
    public int CheckType { get; public set; }
    public string OnValue { get; public set; }
    public PdfFormField RadioField { get; }
    public RadioCheckField(PdfWriter writer, Rectangle box, string fieldName, string onValue);
    private static RadioCheckField();
    public bool get_Checked();
    public void set_Checked(bool value);
    public PdfFormField get_CheckField();
    public int get_CheckType();
    public void set_CheckType(int value);
    public string get_OnValue();
    public void set_OnValue(string value);
    public PdfFormField get_RadioField();
    public PdfAppearance GetAppearance(bool isRadio, bool on);
    public PdfAppearance GetAppearanceRadioCircle(bool on);
    public PdfFormField GetRadioGroup(bool noToggleToOff, bool radiosInUnison);
    protected PdfFormField GetField(bool isRadio);
}
public class iTextSharp.text.pdf.RandomAccessFileOrArray : object {
    internal Byte[] ArrayIn;
    internal int ArrayInPtr;
    internal byte Back;
    internal string Filename;
    internal bool IsBack;
    internal FileStream Rf;
    [CompilerGeneratedAttribute]
private int <StartOffset>k__BackingField;
    public int FilePointer { get; }
    public int Length { get; }
    public int StartOffset { get; public set; }
    public RandomAccessFileOrArray(string filename);
    public RandomAccessFileOrArray(string filename, bool forceRead);
    public RandomAccessFileOrArray(Uri url);
    public RandomAccessFileOrArray(Stream isp, bool forceRead);
    public RandomAccessFileOrArray(Byte[] arrayIn);
    public RandomAccessFileOrArray(RandomAccessFileOrArray file);
    public int get_FilePointer();
    public int get_Length();
    [CompilerGeneratedAttribute]
public int get_StartOffset();
    [CompilerGeneratedAttribute]
public void set_StartOffset(int value);
    public static Byte[] InputStreamToArray(Stream isp);
    public void Close();
    public bool IsOpen();
    public void PushBack(byte b);
    public int Read();
    public int Read(Byte[] b, int off, int len);
    public int Read(Byte[] b);
    public bool ReadBoolean();
    public byte ReadByte();
    public char ReadChar();
    public char ReadCharLe();
    public double ReadDouble();
    public double ReadDoubleLe();
    public float ReadFloat();
    public float ReadFloatLe();
    public void ReadFully(Byte[] b);
    public void ReadFully(Byte[] b, int off, int len);
    public int ReadInt();
    public int ReadIntLe();
    public string ReadLine();
    public long ReadLong();
    public long ReadLongLe();
    public short ReadShort();
    public short ReadShortLe();
    public int ReadUnsignedByte();
    public long ReadUnsignedInt();
    public long ReadUnsignedIntLe();
    public int ReadUnsignedShort();
    public int ReadUnsignedShortLe();
    public void ReOpen();
    public void Seek(int pos);
    public void Seek(long pos);
    public long Skip(long n);
    public int SkipBytes(int n);
    protected void InsureOpen();
}
public class iTextSharp.text.pdf.SequenceList : object {
    protected static int COMMA;
    protected static int END;
    protected static char EOT;
    protected static int MINUS;
    protected static int NOT;
    protected static int NUMBER;
    protected static int TEXT;
    private static int Digit;
    private static int Digit2;
    private static int First;
    private static string NotOther;
    private static int Other;
    protected bool Even;
    protected int High;
    protected bool Inverse;
    protected int Low;
    protected int Number;
    protected bool Odd;
    protected string other;
    protected int Ptr;
    protected Char[] Text;
    protected int Type { get; }
    protected SequenceList(string range);
    protected int get_Type();
    public static ICollection`1<int> Expand(string ranges, int maxNumber);
    protected bool GetAttributes();
    protected char NextChar();
    protected void PutBack();
    private void otherProc();
}
public class iTextSharp.text.pdf.ShadingColor : ExtendedColor {
    [CompilerGeneratedAttribute]
private PdfShadingPattern <PdfShadingPattern>k__BackingField;
    public PdfShadingPattern PdfShadingPattern { get; }
    public ShadingColor(PdfShadingPattern shadingPattern);
    [CompilerGeneratedAttribute]
public PdfShadingPattern get_PdfShadingPattern();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class iTextSharp.text.pdf.SimpleBookmark : object {
    private Stack`1<INullValueDictionary`2<string, object>> _attr;
    private List`1<INullValueDictionary`2<string, object>> _topList;
    public sealed virtual void EndDocument();
    public sealed virtual void EndElement(string tag);
    public sealed virtual void StartDocument();
    public sealed virtual void Text(string str);
    public sealed virtual void StartElement(string tag, INullValueDictionary`2<string, string> h);
    public static void EliminatePages(IList`1<INullValueDictionary`2<string, object>> list, Int32[] pageRange);
    public static string EscapeBinaryString(string s);
    public static void ExportToXml(IList`1<INullValueDictionary`2<string, object>> list, Stream outp, string encoding, bool onlyAscii);
    public static void ExportToXml(IList`1<INullValueDictionary`2<string, object>> list, TextWriter wrt, string encoding, bool onlyAscii);
    public static void ExportToXmlNode(IList`1<INullValueDictionary`2<string, object>> list, TextWriter outp, int indent, bool onlyAscii);
    public static IList`1<INullValueDictionary`2<string, object>> GetBookmark(PdfReader reader);
    public static List`1<INullValueDictionary`2<string, object>> ImportFromXml(Stream inp);
    public static List`1<INullValueDictionary`2<string, object>> ImportFromXml(TextReader inp);
    public static Object[] IterateOutlines(PdfWriter writer, PdfIndirectReference parent, IList`1<INullValueDictionary`2<string, object>> kids, bool namedAsNames);
    public static void ShiftPageNumbers(IList`1<INullValueDictionary`2<string, object>> list, int pageShift, Int32[] pageRange);
    public static string UnEscapeBinaryString(string s);
    internal static void CreateOutlineAction(PdfDictionary outline, INullValueDictionary`2<string, object> map, PdfWriter writer, bool namedAsNames);
    private static List`1<INullValueDictionary`2<string, object>> bookmarkDepth(PdfReader reader, PdfDictionary outline, NullValueDictionary`2<int, int> pages);
    private static int getNumber(PdfIndirectReference indirect);
    private static string makeBookmarkParam(PdfArray dest, NullValueDictionary`2<int, int> pages);
    private static void mapGotoBookmark(INullValueDictionary`2<string, object> map, PdfObject dest, NullValueDictionary`2<int, int> pages);
}
public class iTextSharp.text.pdf.SimpleNamedDestination : object {
    private NullValueDictionary`2<string, string> _xmlLast;
    private INullValueDictionary`2<string, string> _xmlNames;
    public sealed virtual void EndDocument();
    public sealed virtual void EndElement(string tag);
    public sealed virtual void StartDocument();
    public sealed virtual void Text(string str);
    public sealed virtual void StartElement(string tag, INullValueDictionary`2<string, string> h);
    public static string EscapeBinaryString(string s);
    public static void ExportToXml(INullValueDictionary`2<string, string> names, Stream outp, string encoding, bool onlyAscii);
    public static void ExportToXml(INullValueDictionary`2<string, string> names, TextWriter wrt, string encoding, bool onlyAscii);
    public static INullValueDictionary`2<string, string> GetNamedDestination(PdfReader reader, bool fromNames);
    public static INullValueDictionary`2<string, string> ImportFromXml(Stream inp);
    public static INullValueDictionary`2<string, string> ImportFromXml(TextReader inp);
    public static PdfDictionary OutputNamedDestinationAsNames(INullValueDictionary`2<string, string> names, PdfWriter writer);
    public static PdfDictionary OutputNamedDestinationAsStrings(INullValueDictionary`2<string, string> names, PdfWriter writer);
    public static string UnEscapeBinaryString(string s);
    internal static PdfArray CreateDestinationArray(string value, PdfWriter writer);
}
public class iTextSharp.text.pdf.SpotColor : ExtendedColor {
    [CompilerGeneratedAttribute]
private PdfSpotColor <PdfSpotColor>k__BackingField;
    [CompilerGeneratedAttribute]
private float <Tint>k__BackingField;
    public PdfSpotColor PdfSpotColor { get; }
    public float Tint { get; }
    public SpotColor(PdfSpotColor spot, float tint);
    public SpotColor(PdfSpotColor spot);
    [CompilerGeneratedAttribute]
public PdfSpotColor get_PdfSpotColor();
    [CompilerGeneratedAttribute]
public float get_Tint();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class iTextSharp.text.pdf.StampContent : PdfContentByte {
    internal PageResources pageResources;
    internal PageStamp Ps;
    public PdfContentByte Duplicate { get; }
    internal PageResources PageResources { get; }
    internal StampContent(PdfStamperImp stamper, PageStamp ps);
    public virtual PdfContentByte get_Duplicate();
    internal virtual PageResources get_PageResources();
    public virtual void SetAction(PdfAction action, float llx, float lly, float urx, float ury);
    internal virtual void AddAnnotation(PdfAnnotation annot);
}
public class iTextSharp.text.pdf.TextField : BaseField {
    private String[] _choiceExports;
    private String[] _choices;
    private int _choiceSelection;
    private string _defaultText;
    private BaseFont _extensionFont;
    private float _extraMarginLeft;
    private float _extraMarginTop;
    private IList`1<BaseFont> _substitutionFonts;
    [CompilerGeneratedAttribute]
private int <TopFirst>k__BackingField;
    public String[] ChoiceExports { get; public set; }
    public String[] Choices { get; public set; }
    public int ChoiceSelection { get; public set; }
    public string DefaultText { get; public set; }
    public BaseFont ExtensionFont { get; public set; }
    public IList`1<BaseFont> SubstitutionFonts { get; public set; }
    internal int TopFirst { get; private set; }
    public TextField(PdfWriter writer, Rectangle box, string fieldName);
    public String[] get_ChoiceExports();
    public void set_ChoiceExports(String[] value);
    public String[] get_Choices();
    public void set_Choices(String[] value);
    public int get_ChoiceSelection();
    public void set_ChoiceSelection(int value);
    public string get_DefaultText();
    public void set_DefaultText(string value);
    public void set_ExtensionFont(BaseFont value);
    public BaseFont get_ExtensionFont();
    public void set_SubstitutionFonts(IList`1<BaseFont> value);
    public IList`1<BaseFont> get_SubstitutionFonts();
    [CompilerGeneratedAttribute]
internal int get_TopFirst();
    [CompilerGeneratedAttribute]
private void set_TopFirst(int value);
    public static string ObfuscatePassword(string text);
    public static string RemoveCrlf(string text);
    public PdfAppearance GetAppearance();
    public PdfFormField GetComboField();
    public PdfFormField GetListField();
    public PdfFormField GetTextField();
    public void SetExtraMargin(float extraMarginLeft, float extraMarginTop);
    internal PdfAppearance GetListAppearance();
    protected PdfFormField GetChoiceField(bool isList);
    private static void changeFontSize(Phrase p, float size);
    private static bool checkRtl(string text);
    private Phrase composePhrase(string text, BaseFont ufont, BaseColor color, float fontSize);
}
internal class iTextSharp.text.pdf.TrueTypeFont : BaseFont {
    internal static String[] CodePages;
    protected String[][] allNameEntries;
    protected Int32[][] Bboxes;
    protected bool Cff;
    protected int CffLength;
    protected int CffOffset;
    protected INullValueDictionary`2<int, Int32[]> Cmap10;
    protected INullValueDictionary`2<int, Int32[]> Cmap31;
    protected INullValueDictionary`2<int, Int32[]> CmapExt;
    protected int DirectoryOffset;
    protected String[][] FamilyName;
    public string FileName;
    protected string FontName;
    protected String[][] FullName;
    protected Int32[] GlyphWidths;
    protected FontHeader Head;
    protected HorizontalHeader Hhea;
    protected bool IsFixedPitch;
    protected double ItalicAngle;
    protected bool JustNames;
    protected NullValueDictionary`2<int, int> Kerning;
    protected WindowsMetrics Os2;
    protected RandomAccessFileOrArray Rf;
    protected string Style;
    protected INullValueDictionary`2<string, Int32[]> Tables;
    protected string TtcIndex;
    protected int UnderlinePosition;
    protected int UnderlineThickness;
    public String[][] AllNameEntries { get; }
    public String[] CodePagesSupported { get; }
    public String[][] FamilyFontName { get; }
    public String[][] FullFontName { get; }
    public string PostscriptFontName { get; public set; }
    internal string BaseFont { get; }
    internal TrueTypeFont(string ttFile, string enc, bool emb, Byte[] ttfAfm, bool justNames, bool forceRead);
    private static TrueTypeFont();
    public virtual String[][] get_AllNameEntries();
    public virtual String[] get_CodePagesSupported();
    public virtual String[][] get_FamilyFontName();
    public virtual String[][] get_FullFontName();
    public virtual string get_PostscriptFontName();
    public virtual void set_PostscriptFontName(string value);
    internal string get_BaseFont();
    public virtual float GetFontDescriptor(int key, float fontSize);
    public virtual PdfStream GetFullFontStream();
    public virtual int GetKerning(int char1, int char2);
    public virtual Int32[] GetMetricsTt(int c);
    public virtual bool HasKernPairs();
    public virtual bool SetKerning(int char1, int char2, int kern);
    internal void CheckCff();
    internal void FillTables();
    internal String[][] GetAllNames();
    internal String[][] GetNames(int id);
    internal virtual int GetRawWidth(int c, string name);
    internal void Process(Byte[] ttfAfm, bool preload);
    internal void ReadCMaps();
    internal INullValueDictionary`2<int, Int32[]> ReadFormat0();
    internal INullValueDictionary`2<int, Int32[]> ReadFormat12();
    internal INullValueDictionary`2<int, Int32[]> ReadFormat4();
    internal INullValueDictionary`2<int, Int32[]> ReadFormat6();
    internal void ReadKerning();
    internal virtual void WriteFont(PdfWriter writer, PdfIndirectReference piref, Object[] parms);
    protected internal Byte[] ReadCffFont();
    protected static Int32[] CompactRanges(List`1<Int32[]> ranges);
    protected static string GetTtcName(string name);
    protected void AddRangeUni(INullValueDictionary`2<int, Int32[]> longTag, bool includeMetrics, bool subsetp);
    protected PdfDictionary GetFontBaseType(PdfIndirectReference fontDescriptor, string subsetPrefix, int firstChar, int lastChar, Byte[] shortTag);
    protected PdfDictionary GetFontDescriptor(PdfIndirectReference fontStream, string subsetPrefix, PdfIndirectReference cidset);
    protected Byte[] GetFullFont();
    protected int GetGlyphWidth(int glyph);
    protected virtual Int32[] GetRawCharBBox(int c, string name);
    protected void ReadGlyphWidths();
    protected string ReadStandardString(int length);
    protected string ReadUnicodeString(int length);
    private void readBbox();
}
internal class iTextSharp.text.pdf.TrueTypeFontSubSet : object {
    internal static int Arg1And2AreWords;
    internal static int HeadLocaFormatOffset;
    internal static int MoreComponents;
    internal static int TableChecksum;
    internal static int TableLength;
    internal static int TableOffset;
    internal static int WeHaveAnXAndYScale;
    internal static int WeHaveAScale;
    internal static int WeHaveATwoByTwo;
    internal static Int32[] EntrySelectors;
    internal static String[] TableNamesCmap;
    internal static String[] TableNamesExtra;
    internal static String[] TableNamesSimple;
    protected int DirectoryOffset;
    protected string FileName;
    protected int FontPtr;
    protected int GlyfTableRealSize;
    protected List`1<int> GlyphsInList;
    protected INullValueDictionary`2<int, Int32[]> GlyphsUsed;
    protected bool IncludeCmap;
    protected bool IncludeExtras;
    protected bool LocaShortTable;
    protected Int32[] LocaTable;
    protected int LocaTableRealSize;
    protected Byte[] NewGlyfTable;
    protected Int32[] NewLocaTable;
    protected Byte[] NewLocaTableOut;
    protected Byte[] OutFont;
    protected RandomAccessFileOrArray Rf;
    protected INullValueDictionary`2<string, Int32[]> TableDirectory;
    protected int TableGlyphOffset;
    internal TrueTypeFontSubSet(string fileName, RandomAccessFileOrArray rf, INullValueDictionary`2<int, Int32[]> glyphsUsed, int directoryOffset, bool includeCmap, bool includeExtras);
    private static TrueTypeFontSubSet();
    internal Byte[] Process();
    protected void AssembleFont();
    protected static int CalculateChecksum(Byte[] b);
    protected void CheckGlyphComposite(int glyph);
    protected void CreateNewGlyphTables();
    protected void CreateTableDirectory();
    protected void FlatGlyphs();
    protected void LocaTobytes();
    protected void ReadLoca();
    protected string ReadStandardString(int length);
    protected void WriteFontInt(int n);
    protected void WriteFontShort(int n);
    protected void WriteFontString(string s);
}
internal class iTextSharp.text.pdf.TrueTypeFontUnicode : TrueTypeFont {
    private static Byte[] _rotbits;
    private bool _vertical;
    internal TrueTypeFontUnicode(string ttFile, string enc, bool emb, Byte[] ttfAfm, bool forceRead);
    private static TrueTypeFontUnicode();
    public sealed virtual int Compare(Int32[] o1, Int32[] o2);
    public virtual bool CharExists(int c);
    public virtual Int32[] GetCharBBox(int c);
    public virtual PdfStream GetFullFontStream();
    public virtual Int32[] GetMetricsTt(int c);
    public virtual int GetWidth(int char1);
    public virtual int GetWidth(string text);
    public virtual bool SetCharAdvance(int c, int advance);
    internal static string ToHex(int n);
    internal virtual Byte[] ConvertToBytes(string text);
    internal virtual Byte[] ConvertToBytes(int char1);
    internal virtual void WriteFont(PdfWriter writer, PdfIndirectReference piref, Object[] parms);
    private PdfDictionary getCidFontType2(PdfIndirectReference fontDescriptor, string subsetPrefix, Object[] metrics);
    private PdfDictionary getFontBaseType(PdfIndirectReference descendant, string subsetPrefix, PdfIndirectReference toUnicode);
    private PdfStream getToUnicode(Object[] metrics);
}
public class iTextSharp.text.pdf.TsaClientBouncyCastle : object {
    protected int TokSzEstimate;
    protected string TsaPassword;
    protected string TsaUrl;
    protected string TsaUsername;
    public TsaClientBouncyCastle(string url);
    public TsaClientBouncyCastle(string url, string username, string password);
    public TsaClientBouncyCastle(string url, string username, string password, int tokSzEstimate);
    public sealed virtual Byte[] GetTimeStampToken(PdfPkcs7 caller, Byte[] imprint);
    public sealed virtual int GetTokenSizeEstimate();
    protected internal Byte[] GetTimeStampToken(Byte[] imprint);
    protected internal virtual Byte[] GetTsaResponse(Byte[] requestBytes);
}
internal class iTextSharp.text.pdf.Type1Font : BaseFont {
    private static Int32[] _pfbTypes;
    private bool _builtinFont;
    private NullValueDictionary`2<object, Object[]> _charMetrics;
    private string _fileName;
    private INullValueDictionary`2<string, Object[]> _kernPairs;
    protected Byte[] Pfb;
    private int _ascender;
    private int _capHeight;
    private string _characterSet;
    private int _descender;
    private string _encodingScheme;
    private string _familyName;
    private string _fontName;
    private string _fullName;
    private bool _isFixedPitch;
    private float _italicAngle;
    private int _llx;
    private int _lly;
    private int _stdHw;
    private int _stdVw;
    private int _underlinePosition;
    private int _underlineThickness;
    private int _urx;
    private int _ury;
    private string _weight;
    private int _xHeight;
    public String[][] AllNameEntries { get; }
    public String[][] FamilyFontName { get; }
    public String[][] FullFontName { get; }
    public string PostscriptFontName { get; public set; }
    internal Type1Font(string afmFile, string enc, bool emb, Byte[] ttfAfm, Byte[] pfb, bool forceRead);
    private static Type1Font();
    public virtual String[][] get_AllNameEntries();
    public virtual String[][] get_FamilyFontName();
    public virtual String[][] get_FullFontName();
    public virtual string get_PostscriptFontName();
    public virtual void set_PostscriptFontName(string value);
    public PdfDictionary GetFontDescriptor(PdfIndirectReference fontStream);
    public virtual float GetFontDescriptor(int key, float fontSize);
    public virtual PdfStream GetFullFontStream();
    public virtual int GetKerning(int char1, int char2);
    public virtual bool HasKernPairs();
    public void Process(RandomAccessFileOrArray rf);
    public virtual bool SetKerning(int char1, int char2, int kern);
    internal virtual int GetRawWidth(int c, string name);
    internal virtual void WriteFont(PdfWriter writer, PdfIndirectReference piref, Object[] parms);
    protected virtual Int32[] GetRawCharBBox(int c, string name);
    private PdfDictionary getFontBaseType(PdfIndirectReference fontDescriptor, int firstChar, int lastChar, Byte[] shortTag);
}
public class iTextSharp.text.pdf.Type3Font : BaseFont {
    private INullValueDictionary`2<char, Type3Glyph> _char2Glyph;
    private bool _colorized;
    private PageResources _pageResources;
    private Boolean[] _usedSlot;
    private NullValueDictionary`2<int, int> _widths3;
    private PdfWriter _writer;
    private float _llx;
    private float _lly;
    private float _urx;
    private float _ury;
    public String[][] AllNameEntries { get; }
    public String[][] FamilyFontName { get; }
    public String[][] FullFontName { get; }
    public string PostscriptFontName { get; public set; }
    public Type3Font(PdfWriter writer, Char[] chars, bool colorized);
    public Type3Font(PdfWriter writer, bool colorized);
    public virtual String[][] get_AllNameEntries();
    public virtual String[][] get_FamilyFontName();
    public virtual String[][] get_FullFontName();
    public virtual string get_PostscriptFontName();
    public virtual void set_PostscriptFontName(string value);
    public virtual bool CharExists(int c);
    public PdfContentByte DefineGlyph(char c, float wx, float llx, float lly, float urx, float ury);
    public virtual Int32[] GetCharBBox(int c);
    public virtual float GetFontDescriptor(int key, float fontSize);
    public virtual PdfStream GetFullFontStream();
    public virtual int GetKerning(int char1, int char2);
    public virtual int GetWidth(int char1);
    public virtual int GetWidth(string text);
    public virtual bool HasKernPairs();
    public virtual bool SetCharAdvance(int c, int advance);
    public virtual bool SetKerning(int char1, int char2, int kern);
    internal virtual Byte[] ConvertToBytes(string text);
    internal virtual Byte[] ConvertToBytes(int char1);
    internal virtual int GetRawWidth(int c, string name);
    internal virtual void WriteFont(PdfWriter writer, PdfIndirectReference piRef, Object[] oParams);
    protected virtual Int32[] GetRawCharBBox(int c, string name);
}
public class iTextSharp.text.pdf.Type3Glyph : PdfContentByte {
    private bool _colorized;
    private PageResources _pageResources;
    internal PageResources PageResources { get; }
    internal Type3Glyph(PdfWriter writer, PageResources pageResources, float wx, float llx, float lly, float urx, float ury, bool colorized);
    internal virtual PageResources get_PageResources();
    public virtual void AddImage(Image image, float a, float b, float c, float d, float e, float f, bool inlineImage);
    public PdfContentByte GetDuplicate();
}
public class iTextSharp.text.pdf.VerticalText : object {
    public static int NoMoreColumn;
    public static int NoMoreText;
    protected int alignment;
    protected List`1<PdfChunk> Chunks;
    protected int CurrentChunkMarker;
    protected PdfChunk CurrentStandbyChunk;
    protected float height;
    protected float leading;
    protected int maxLines;
    protected string SplittedChunkText;
    protected float StartX;
    protected float StartY;
    protected PdfContentByte Text;
    public int Alignment { get; public set; }
    public float Height { get; public set; }
    public float Leading { get; public set; }
    public int MaxLines { get; public set; }
    public float OriginX { get; }
    public float OriginY { get; }
    public VerticalText(PdfContentByte text);
    private static VerticalText();
    public int get_Alignment();
    public void set_Alignment(int value);
    public float get_Height();
    public void set_Height(float value);
    public float get_Leading();
    public void set_Leading(float value);
    public int get_MaxLines();
    public void set_MaxLines(int value);
    public float get_OriginX();
    public float get_OriginY();
    public void AddText(Phrase phrase);
    public void AddText(Chunk chunk);
    public int Go();
    public int Go(bool simulate);
    public void SetOrigin(float startX, float startY);
    public void SetVerticalLayout(float startX, float startY, float height, int maxLines, float leading);
    internal static void WriteLine(PdfLine line, PdfContentByte text, PdfContentByte graphics);
    protected PdfLine CreateLine(float width);
    protected void ShortenChunkArray();
}
public class iTextSharp.text.pdf.XfaForm : object {
    public static string XFA_DATA_SCHEMA;
    private XmlDocument _domDocument;
    private XmlNode _templateNode;
    [CompilerGeneratedAttribute]
private AcroFieldsSearch <AcroFieldsSom>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Changed>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlNode <DatasetsNode>k__BackingField;
    [CompilerGeneratedAttribute]
private Xml2SomDatasets <DatasetsSom>k__BackingField;
    [CompilerGeneratedAttribute]
private PdfReader <Reader>k__BackingField;
    [CompilerGeneratedAttribute]
private Xml2SomTemplate <TemplateSom>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <XfaPresent>k__BackingField;
    public AcroFieldsSearch AcroFieldsSom { get; public set; }
    public bool Changed { get; public set; }
    public XmlNode DatasetsNode { get; private set; }
    public Xml2SomDatasets DatasetsSom { get; public set; }
    public XmlDocument DomDocument { get; public set; }
    public PdfReader Reader { get; public set; }
    public Xml2SomTemplate TemplateSom { get; public set; }
    public bool XfaPresent { get; public set; }
    public XfaForm(PdfReader reader);
    [CompilerGeneratedAttribute]
public AcroFieldsSearch get_AcroFieldsSom();
    [CompilerGeneratedAttribute]
public void set_AcroFieldsSom(AcroFieldsSearch value);
    [CompilerGeneratedAttribute]
public bool get_Changed();
    [CompilerGeneratedAttribute]
public void set_Changed(bool value);
    [CompilerGeneratedAttribute]
public XmlNode get_DatasetsNode();
    [CompilerGeneratedAttribute]
private void set_DatasetsNode(XmlNode value);
    [CompilerGeneratedAttribute]
public Xml2SomDatasets get_DatasetsSom();
    [CompilerGeneratedAttribute]
public void set_DatasetsSom(Xml2SomDatasets value);
    public XmlDocument get_DomDocument();
    public void set_DomDocument(XmlDocument value);
    [CompilerGeneratedAttribute]
public void set_Reader(PdfReader value);
    [CompilerGeneratedAttribute]
public PdfReader get_Reader();
    [CompilerGeneratedAttribute]
public Xml2SomTemplate get_TemplateSom();
    [CompilerGeneratedAttribute]
public void set_TemplateSom(Xml2SomTemplate value);
    [CompilerGeneratedAttribute]
public bool get_XfaPresent();
    [CompilerGeneratedAttribute]
public void set_XfaPresent(bool value);
    public static string GetNodeText(XmlNode n);
    public static PdfObject GetXfaObject(PdfReader reader);
    public static Byte[] SerializeDoc(XmlNode n);
    public static void SetXfa(XfaForm form, PdfReader reader, PdfWriter writer);
    public string FindDatasetsName(string name);
    public XmlNode FindDatasetsNode(string name);
    public string FindFieldName(string name, AcroFields af);
    public void SetNodeText(XmlNode n, string text);
    public void SetXfa(PdfWriter writer);
    private static string getNodeText(XmlNode n, string name);
    private void extractNodes();
}
public class iTextSharp.text.pdf.XfdfReader : object {
    private Stackr _fieldNames;
    private Stackr _fieldValues;
    private bool _foundRoot;
    internal INullValueDictionary`2<string, string> fields;
    internal string fileSpec;
    protected INullValueDictionary`2<string, List`1<string>> ListFields;
    public INullValueDictionary`2<string, string> Fields { get; }
    public string FileSpec { get; }
    public XfdfReader(string filename);
    public XfdfReader(Byte[] xfdfIn);
    public INullValueDictionary`2<string, string> get_Fields();
    public string get_FileSpec();
    public sealed virtual void EndDocument();
    public sealed virtual void EndElement(string tag);
    public sealed virtual void StartDocument();
    public sealed virtual void StartElement(string tag, INullValueDictionary`2<string, string> h);
    public sealed virtual void Text(string str);
    public string GetField(string name);
    public string GetFieldValue(string name);
    public List`1<string> GetListValues(string name);
}
public class iTextSharp.text.Phrase : List`1<IElement> {
    protected Font font;
    protected IHyphenationEvent hyphenation;
    protected float leading;
    public string Content { get; }
    public Font Font { get; public set; }
    public IHyphenationEvent Hyphenation { get; public set; }
    public float Leading { get; public set; }
    public IList`1<Chunk> Chunks { get; }
    public int Type { get; }
    public Phrase(Phrase phrase);
    public Phrase(float leading);
    public Phrase(Chunk chunk);
    public Phrase(float leading, Chunk chunk);
    public Phrase(string str);
    public Phrase(string str, Font font);
    public Phrase(float leading, string str);
    public Phrase(float leading, string str, Font font);
    private Phrase(bool dummy);
    public string get_Content();
    public Font get_Font();
    public void set_Font(Font value);
    public void set_Hyphenation(IHyphenationEvent value);
    public IHyphenationEvent get_Hyphenation();
    public virtual float get_Leading();
    public virtual void set_Leading(float value);
    public virtual IList`1<Chunk> get_Chunks();
    public virtual int get_Type();
    public sealed virtual bool IsContent();
    public sealed virtual bool IsNestable();
    public virtual bool Process(IElementListener listener);
    public virtual bool Add(IElement o);
    public static Phrase GetInstance(string str);
    public static Phrase GetInstance(int leading, string str);
    public static Phrase GetInstance(int leading, string str, Font font);
    public static bool IsTag(string tag);
    public virtual void Add(int index, object o);
    public bool AddAll(ICollection`1<T> collection);
    public void AddSpecial(IElement obj);
    public bool HasLeading();
    public bool IsEmpty();
    protected bool AddChunk(Chunk chunk);
}
public class iTextSharp.text.Rectangle : Element {
    public static int BOTTOM_BORDER;
    public static int BOX;
    public static int LEFT_BORDER;
    public static int NO_BORDER;
    public static int RIGHT_BORDER;
    public static int TOP_BORDER;
    public static int UNDEFINED;
    protected BaseColor backgroundColor;
    protected int border;
    protected BaseColor borderColor;
    protected BaseColor borderColorBottom;
    protected BaseColor borderColorLeft;
    protected BaseColor borderColorRight;
    protected BaseColor borderColorTop;
    protected float borderWidth;
    protected float borderWidthBottom;
    protected float borderWidthLeft;
    protected float borderWidthRight;
    protected float borderWidthTop;
    protected float Llx;
    protected float Lly;
    protected int rotation;
    protected float Urx;
    protected float Ury;
    protected bool useVariableBorders;
    public BaseColor BackgroundColor { get; public set; }
    public int Border { get; public set; }
    public BaseColor BorderColor { get; public set; }
    public BaseColor BorderColorBottom { get; public set; }
    public BaseColor BorderColorLeft { get; public set; }
    public BaseColor BorderColorRight { get; public set; }
    public BaseColor BorderColorTop { get; public set; }
    public float BorderWidth { get; public set; }
    public float BorderWidthBottom { get; public set; }
    public float BorderWidthLeft { get; public set; }
    public float BorderWidthRight { get; public set; }
    public float BorderWidthTop { get; public set; }
    public float Bottom { get; public set; }
    public float GrayFill { get; public set; }
    public float Height { get; }
    public float Left { get; public set; }
    public float Right { get; public set; }
    public int Rotation { get; }
    public float Top { get; public set; }
    public bool UseVariableBorders { get; public set; }
    public float Width { get; public set; }
    public IList`1<Chunk> Chunks { get; }
    public int Type { get; }
    public Rectangle(float llx, float lly, float urx, float ury);
    public Rectangle(float urx, float ury);
    public Rectangle(Rectangle rect);
    public virtual BaseColor get_BackgroundColor();
    public virtual void set_BackgroundColor(BaseColor value);
    public virtual int get_Border();
    public virtual void set_Border(int value);
    public virtual BaseColor get_BorderColor();
    public virtual void set_BorderColor(BaseColor value);
    public virtual BaseColor get_BorderColorBottom();
    public virtual void set_BorderColorBottom(BaseColor value);
    public virtual BaseColor get_BorderColorLeft();
    public virtual void set_BorderColorLeft(BaseColor value);
    public virtual BaseColor get_BorderColorRight();
    public virtual void set_BorderColorRight(BaseColor value);
    public virtual BaseColor get_BorderColorTop();
    public virtual void set_BorderColorTop(BaseColor value);
    public virtual float get_BorderWidth();
    public virtual void set_BorderWidth(float value);
    public virtual float get_BorderWidthBottom();
    public virtual void set_BorderWidthBottom(float value);
    public virtual float get_BorderWidthLeft();
    public virtual void set_BorderWidthLeft(float value);
    public virtual float get_BorderWidthRight();
    public virtual void set_BorderWidthRight(float value);
    public virtual float get_BorderWidthTop();
    public virtual void set_BorderWidthTop(float value);
    public virtual float get_Bottom();
    public virtual void set_Bottom(float value);
    public virtual float get_GrayFill();
    public virtual void set_GrayFill(float value);
    public float get_Height();
    public virtual float get_Left();
    public virtual void set_Left(float value);
    public virtual float get_Right();
    public virtual void set_Right(float value);
    public int get_Rotation();
    public virtual float get_Top();
    public virtual void set_Top(float value);
    public virtual bool get_UseVariableBorders();
    public virtual void set_UseVariableBorders(bool value);
    public virtual float get_Width();
    public virtual void set_Width(float value);
    public virtual IList`1<Chunk> get_Chunks();
    public virtual int get_Type();
    public sealed virtual bool IsContent();
    public virtual bool IsNestable();
    public virtual bool Process(IElementListener listener);
    public virtual string ToString();
    public virtual void CloneNonPositionParameters(Rectangle rect);
    public virtual void DisableBorderSide(int side);
    public virtual void EnableBorderSide(int side);
    public virtual float GetBottom(float margin);
    public virtual float GetLeft(float margin);
    public Rectangle GetRectangle(float top, float bottom);
    public virtual float GetRight(float margin);
    public virtual float GetTop(float margin);
    public bool HasBorder(int type);
    public bool HasBorders();
    public virtual void Normalize();
    public Rectangle Rotate();
    public virtual void SoftCloneNonPositionParameters(Rectangle rect);
    private float getVariableBorderWidth(float variableWidthValue, int side);
    private void updateBorderBasedOnWidth(float width, int side);
}
public class iTextSharp.text.RectangleReadOnly : Rectangle {
    unknown BaseColor BackgroundColor {public set; }
    unknown int Border {public set; }
    unknown BaseColor BorderColor {public set; }
    unknown BaseColor BorderColorBottom {public set; }
    unknown BaseColor BorderColorLeft {public set; }
    unknown BaseColor BorderColorRight {public set; }
    unknown BaseColor BorderColorTop {public set; }
    unknown float BorderWidth {public set; }
    unknown float BorderWidthBottom {public set; }
    unknown float BorderWidthLeft {public set; }
    unknown float BorderWidthRight {public set; }
    unknown float BorderWidthTop {public set; }
    unknown float Bottom {public set; }
    unknown float GrayFill {public set; }
    unknown float Left {public set; }
    unknown float Right {public set; }
    unknown float Top {public set; }
    unknown bool UseVariableBorders {public set; }
    public RectangleReadOnly(float llx, float lly, float urx, float ury);
    public RectangleReadOnly(float urx, float ury);
    public RectangleReadOnly(Rectangle rect);
    public virtual void set_BackgroundColor(BaseColor value);
    public virtual void set_Border(int value);
    public virtual void set_BorderColor(BaseColor value);
    public virtual void set_BorderColorBottom(BaseColor value);
    public virtual void set_BorderColorLeft(BaseColor value);
    public virtual void set_BorderColorRight(BaseColor value);
    public virtual void set_BorderColorTop(BaseColor value);
    public virtual void set_BorderWidth(float value);
    public virtual void set_BorderWidthBottom(float value);
    public virtual void set_BorderWidthLeft(float value);
    public virtual void set_BorderWidthRight(float value);
    public virtual void set_BorderWidthTop(float value);
    public virtual void set_Bottom(float value);
    public virtual void set_GrayFill(float value);
    public virtual void set_Left(float value);
    public virtual void set_Right(float value);
    public virtual void set_Top(float value);
    public virtual void set_UseVariableBorders(bool value);
    public virtual void CloneNonPositionParameters(Rectangle rect);
    public virtual void DisableBorderSide(int side);
    public virtual void EnableBorderSide(int side);
    public virtual void Normalize();
    public virtual void SoftCloneNonPositionParameters(Rectangle rect);
    public virtual string ToString();
    private static void throwReadOnlyError();
}
public class iTextSharp.text.RomanList : List {
    public RomanList(int symbolIndent);
    public RomanList(bool romanlower, int symbolIndent);
    public virtual bool Add(IElement o);
}
public class iTextSharp.text.Row : object {
    public static int Cell;
    public static int Null;
    public static int Table;
    protected Object[] Cells;
    protected int columns;
    protected int CurrentColumn;
    protected int horizontalAlignment;
    protected Boolean[] Reserved;
    public int Columns { get; }
    public int HorizontalAlignment { get; public set; }
    public IList`1<Chunk> Chunks { get; }
    public int Type { get; }
    internal Row(int columns);
    private static Row();
    public int get_Columns();
    public int get_HorizontalAlignment();
    public void set_HorizontalAlignment(int value);
    public sealed virtual IList`1<Chunk> get_Chunks();
    public sealed virtual int get_Type();
    public sealed virtual bool IsContent();
    public sealed virtual bool IsNestable();
    public sealed virtual bool Process(IElementListener listener);
    public object GetCell(int column);
    public bool IsEmpty();
    internal int AddElement(object element);
    internal int AddElement(object element, int column);
    internal void DeleteColumn(int column);
    internal bool IsReserved(int column);
    internal bool Reserve(int column);
    internal bool Reserve(int column, int size);
    internal void SetElement(object aElement, int column);
    private int getElementId(int column);
    private static int getObjectId(object element);
}
public class iTextSharp.text.rtf.direct.RtfDirectContent : RtfAddableElement {
    public static RtfDirectContent DirectSoftLinebreak;
    private string _directContent;
    public RtfDirectContent(string directContent);
    private static RtfDirectContent();
    public virtual void WriteContent(Stream outp);
}
public interface iTextSharp.text.rtf.document.output.IRtfDataCache {
    public abstract virtual Stream GetOutputStream();
    public abstract virtual void WriteTo(Stream target);
}
public class iTextSharp.text.rtf.document.output.RtfByteArrayBuffer : Stream {
    private List`1<Byte[]> _arrays;
    private Byte[] _buffer;
    private int _pos;
    private int _size;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public RtfByteArrayBuffer(int bufferSize);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public void Append(Byte[] a);
    public void Append(Byte[][] a);
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public void Reset();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public long Size();
    public Byte[] ToArray();
    public Byte[][] ToArrayArray();
    public virtual string ToString();
    public virtual void Write(Byte[] buffer, int offset, int count);
    public long Write(Stream inp);
    public virtual void WriteByte(byte value);
    public void WriteTo(Stream outp);
    private void flushBuffer();
    private void flushBuffer(int reqSize);
    private void writeLoop(Byte[] src, int off, int len);
}
public static class iTextSharp.text.rtf.document.output.RtfDataCache : object {
    public static int CACHE_MEMORY_EFFICIENT;
    public static int CACHE_MEMORY;
    public static int CACHE_DISK;
}
public class iTextSharp.text.rtf.document.output.RtfDiskCache : object {
    private BufferedStream _data;
    private string _tempFile;
    public sealed virtual Stream GetOutputStream();
    public sealed virtual void WriteTo(Stream target);
}
public class iTextSharp.text.rtf.document.output.RtfEfficientMemoryCache : object {
    private RtfByteArrayBuffer _bab;
    public virtual Stream GetOutputStream();
    public virtual void WriteTo(Stream target);
}
public class iTextSharp.text.rtf.document.output.RtfMemoryCache : object {
    private MemoryStream _data;
    public sealed virtual Stream GetOutputStream();
    public sealed virtual void WriteTo(Stream target);
}
public class iTextSharp.text.rtf.document.output.RtfNilOutputStream : Stream {
    private long _size;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Flush();
    public long GetSize();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte value);
}
public class iTextSharp.text.rtf.document.RtfCodePage : RtfElement {
    private static Byte[] _ansi;
    private static Byte[] _ansiCodepage;
    public RtfCodePage(RtfDocument doc);
    private static RtfCodePage();
    public virtual void WriteContent(Stream outp);
    public virtual void WriteDefinition(Stream outp);
}
public class iTextSharp.text.rtf.document.RtfDocument : RtfElement {
    private static Byte[] _fscBackslash;
    private static Byte[] _fscHexPrefix;
    private static Byte[] _fscLine;
    private static Byte[] _fscNewpage;
    private static Byte[] _fscPagePar;
    private static Byte[] _fscPar;
    private static Byte[] _fscTab;
    private static Byte[] _fscUniPrefix;
    private static Random _random;
    private static Byte[] _rtfDocument;
    private RtfDocumentHeader _documentHeader;
    private RtfDocumentSettings _documentSettings;
    private RtfMapper _mapper;
    private List`1<int> _previousRandomInts;
    private bool _autogenerateTocEntries;
    private IRtfDataCache _data;
    private IRtfBasicElement _lastElementWritten;
    private static RtfDocument();
    public void Add(IRtfBasicElement element);
    public void FilterSpecialChar(Stream outp, string str, bool useHex, bool softLineBreaks);
    public bool GetAutogenerateTocEntries();
    public RtfDocumentHeader GetDocumentHeader();
    public RtfDocumentSettings GetDocumentSettings();
    public IRtfBasicElement GetLastElementWritten();
    public RtfMapper GetMapper();
    public int GetRandomInt();
    public void Open();
    public void OutputDebugLinebreak(Stream result);
    public void SetAutogenerateTocEntries(bool autogenerate);
    public virtual void WriteContent(Stream outp);
    public void WriteDocument(Stream outs);
    private static bool subMatch(string str, int soff, Byte[] m);
}
public class iTextSharp.text.rtf.document.RtfDocumentHeader : RtfElement {
    private static Byte[] _facingPages;
    private static Byte[] _titlePage;
    private RtfCodePage _codePage;
    private RtfColorList _colorList;
    private RtfFontList _fontList;
    private HeaderFooter _footer;
    private RtfGenerator _generator;
    private HeaderFooter _header;
    private RtfInfoGroup _infoGroup;
    private RtfListTable _listTable;
    private RtfPageSetting _pageSetting;
    private RtfProtectionSetting _protectionSetting;
    private RtfStylesheetList _stylesheetList;
    protected internal RtfDocumentHeader(RtfDocument doc);
    private static RtfDocumentHeader();
    public void AddInfoElement(RtfInfoElement rtfInfoElement);
    public void FreeListNumber(RtfList list);
    public int GetColorNumber(RtfColor color);
    public int GetFontNumber(RtfFont font);
    public int GetListNumber(RtfList list);
    public RtfListTable GetListTable();
    public RtfPageSetting GetPageSetting();
    public RtfParagraphStyle GetRtfParagraphStyle(string styleName);
    public void RegisterParagraphStyle(RtfParagraphStyle rtfParagraphStyle);
    public void SetFooter(HeaderFooter footer);
    public void SetHeader(HeaderFooter header);
    public virtual void WriteContent(Stream outp);
    public void WriteSectionDefinition(Stream result);
    protected internal void Init();
    private RtfHeaderFooterGroup convertHeaderFooter(HeaderFooter hf, int type);
}
public class iTextSharp.text.rtf.document.RtfDocumentSettings : object {
    private RtfDocument _document;
    private bool _alwaysGenerateSoftLinebreaks;
    private bool _alwaysUseUnicode;
    private int _dataCacheStyle;
    private bool _imagePdfConformance;
    private bool _imageWrittenAsBinary;
    private bool _outputDebugLineBreaks;
    private bool _outputTableRowDefinitionAfter;
    private string _protectionHash;
    private int _protectionLevel;
    private bool _readOnlyRecommended;
    private bool _writeImageScalingInformation;
    public RtfDocumentSettings(RtfDocument document);
    public int GetDataCacheStyle();
    public Byte[] GetProtectionHashBytes();
    public int GetProtectionLevel();
    public Byte[] GetProtectionLevelBytes();
    public int GetProtectionLevelRaw();
    public bool GetReadOnlyRecommended();
    public bool IsAlwaysGenerateSoftLinebreaks();
    public bool IsAlwaysUseUnicode();
    public bool IsDocumentProtected();
    public bool IsImagePdfConformance();
    public bool IsImageWrittenAsBinary();
    public bool IsOutputDebugLineBreaks();
    public bool IsOutputTableRowDefinitionAfter();
    public bool IsWriteImageScalingInformation();
    public void RegisterParagraphStyle(RtfParagraphStyle rtfParagraphStyle);
    public void SetAlwaysGenerateSoftLinebreaks(bool alwaysGenerateSoftLinebreaks);
    public void SetAlwaysUseUnicode(bool alwaysUseUnicode);
    public void SetDataCacheStyle(int dataCacheStyle);
    public void SetImagePdfConformance(bool imagePdfConformance);
    public void SetImageWrittenAsBinary(bool imageWrittenAsBinary);
    public bool SetNewPassword(string oldPwd, string newPwd);
    public void SetOptionsForMsWord2000And97();
    public void SetOptionsForMsWordForMac();
    public void SetOptionsForMsWordXp();
    public void SetOptionsForOpenOfficeOrg();
    public void SetOutputDebugLineBreaks(bool outputDebugLineBreaks);
    public void SetOutputTableRowDefinitionAfter(bool outputTableRowDefinitionAfter);
    public void SetPasswordHash(string pwd);
    public bool SetProtection(int level, string pwd);
    public bool SetProtectionLevel(int level);
    public void SetReadOnlyRecommended(bool value);
    public void SetWriteImageScalingInformation(bool writeImageScalingInformation);
    public bool UnprotectDocument(string pwd);
    private int convertProtectionLevel();
}
public class iTextSharp.text.rtf.document.RtfGenerator : RtfElement {
    private static Byte[] _generator;
    public RtfGenerator(RtfDocument doc);
    private static RtfGenerator();
    public virtual void WriteContent(Stream outp);
}
public class iTextSharp.text.rtf.document.RtfInfoElement : RtfElement {
    private static Byte[] _infoAuthor;
    private static Byte[] _infoCreationDate;
    private static Byte[] _infoKeywords;
    private static Byte[] _infoProducer;
    private static Byte[] _infoSubject;
    private static Byte[] _infoTitle;
    private string _content;
    private int _infoType;
    public RtfInfoElement(RtfDocument doc, Meta meta);
    private static RtfInfoElement();
    public virtual void WriteContent(Stream outp);
    private static string convertDate(string date);
}
public class iTextSharp.text.rtf.document.RtfInfoGroup : RtfElement {
    private static Byte[] _infoGroup;
    private static Byte[] _infoPassword;
    private List`1<RtfInfoElement> _infoElements;
    public RtfInfoGroup(RtfDocument doc);
    private static RtfInfoGroup();
    public void Add(RtfInfoElement infoElement);
    public virtual void WriteContent(Stream outp);
}
public class iTextSharp.text.rtf.document.RtfPageSetting : RtfElement {
    private static Byte[] _landscapeBytes;
    private static Byte[] _marginBottomBytes;
    private static Byte[] _marginLeftBytes;
    private static Byte[] _marginRightBytes;
    private static Byte[] _marginTopBytes;
    private static Byte[] _pageHeightBytes;
    private static Byte[] _pageWidthBytes;
    private static Byte[] _sectionMarginBottomBytes;
    private static Byte[] _sectionMarginLeftBytes;
    private static Byte[] _sectionMarginRightBytes;
    private static Byte[] _sectionMarginTopBytes;
    private static Byte[] _sectionPageHeightBytes;
    private static Byte[] _sectionPageWidthBytes;
    private bool _landscape;
    private int _marginBottom;
    private int _marginLeft;
    private int _marginRight;
    private int _marginTop;
    private int _pageHeight;
    private int _pageWidth;
    public RtfPageSetting(RtfDocument doc);
    private static RtfPageSetting();
    public virtual void WriteContent(Stream outp);
    public virtual void WriteDefinition(Stream outp);
    public int GetMarginBottom();
    public int GetMarginLeft();
    public int GetMarginRight();
    public int GetMarginTop();
    public int GetPageHeight();
    public int GetPageWidth();
    public void SetMarginBottom(int marginBottom);
    public void SetMarginLeft(int marginLeft);
    public void SetMarginRight(int marginRight);
    public void SetMarginTop(int marginTop);
    public void SetPageHeight(int pageHeight);
    public void SetPageSize(Rectangle pageSize);
    public void SetPageWidth(int pageWidth);
    public void WriteSectionDefinition(Stream result);
    private static bool rectEquals(Rectangle rect1, Rectangle rect2);
    private bool guessFormat(Rectangle pageSize, bool rotate);
}
public static class iTextSharp.text.rtf.document.RtfProtection : object {
    public static int LEVEL_NONE;
    public static int LEVEL_REVPROT;
    public static int LEVEL_ANNOTPROT;
    public static int LEVEL_FORMPROT;
    public static int LEVEL_READPROT;
    public static int STYLELOCK;
    public static int STYLELOCKENFORCED;
    public static int STYLELOCKBACKCOMP;
    public static int AUTOFMTOVERRIDE;
    private static Int32[] _initialCodeArray;
    private static Int32[][] _encryptionMatrix;
    private static RtfProtection();
    public static string GenerateHash(string pwd);
}
public class iTextSharp.text.rtf.document.RtfProtectionSetting : RtfElement {
    private static Byte[] _annotprot;
    private static Byte[] _enforceprot;
    private static Byte[] _formprot;
    private static Byte[] _protlevel;
    private static Byte[] _readonlyrecommended;
    private static Byte[] _readprot;
    private static Byte[] _revprot;
    public RtfProtectionSetting(RtfDocument doc);
    private static RtfProtectionSetting();
    public virtual void WriteContent(Stream outp);
    public virtual void WriteDefinition(Stream result);
}
public class iTextSharp.text.rtf.field.RtfAnchor : RtfField {
    private static Byte[] _hyperlink;
    private RtfPhrase _content;
    private string _url;
    public RtfAnchor(RtfDocument doc, Anchor anchor);
    private static RtfAnchor();
    protected virtual void WriteFieldInstContent(Stream oupt);
    protected virtual void WriteFieldResultContent(Stream oupt);
}
public abstract class iTextSharp.text.rtf.field.RtfField : Chunk {
    public static double TWIPS_FACTOR;
    public static Byte[] CloseGroup;
    public static Byte[] CommaDelimiter;
    public static Byte[] Delimiter;
    public static Byte[] OpenGroup;
    private static Byte[] _fieldAltBytes;
    private static Byte[] _fieldBytes;
    private static Byte[] _fieldDirtyBytes;
    private static Byte[] _fieldEditBytes;
    private static Byte[] _fieldInstructionsBytes;
    private static Byte[] _fieldLockedBytes;
    private static Byte[] _fieldPrivateBytes;
    private static Byte[] _fieldResultBytes;
    private bool _fieldAlt;
    private bool _fieldDirty;
    private bool _fieldEdit;
    private bool _fieldLocked;
    private bool _fieldPrivate;
    private RtfFont _font;
    private bool _inHeader;
    private bool _inTable;
    protected RtfDocument Document;
    unknown Font Font {public set; }
    protected RtfField(RtfDocument doc);
    protected RtfField(RtfDocument doc, Font font);
    private static RtfField();
    public virtual void set_Font(Font value);
    public sealed virtual void SetInHeader(bool inHeader);
    public sealed virtual void SetInTable(bool inTable);
    public sealed virtual void SetRtfDocument(RtfDocument doc);
    public virtual void WriteContent(Stream outp);
    public virtual bool IsEmpty();
    public bool IsFieldAlt();
    public bool IsFieldDirty();
    public bool IsFieldEdit();
    public bool IsFieldLocked();
    public bool IsFieldPrivate();
    public bool IsInHeader();
    public bool IsInTable();
    public void SetFieldAlt(bool fieldAlt);
    public void SetFieldDirty(bool fieldDirty);
    public void SetFieldEdit(bool fieldEdit);
    public void SetFieldLocked(bool fieldLocked);
    public void SetFieldPrivate(bool fieldPrivate);
    protected abstract virtual void WriteFieldInstContent(Stream oupt);
    protected abstract virtual void WriteFieldResultContent(Stream oupt);
    private void writeFieldBegin(Stream result);
    private static void writeFieldEnd(Stream result);
    private static void writeFieldInstBegin(Stream result);
    private void writeFieldInstEnd(Stream result);
    private static void writeFieldResultBegin(Stream result);
    private static void writeFieldResultEnd(Stream result);
}
public class iTextSharp.text.rtf.field.RtfPageNumber : RtfField {
    private static Byte[] _pageNumber;
    public RtfPageNumber(Font font);
    public RtfPageNumber(RtfDocument doc);
    public RtfPageNumber(RtfDocument doc, Font font);
    private static RtfPageNumber();
    protected virtual void WriteFieldInstContent(Stream oupt);
    protected virtual void WriteFieldResultContent(Stream oupt);
}
public class iTextSharp.text.rtf.field.RtfTableOfContents : RtfField {
    private static string FieldInst;
    private string _defaultText;
    public RtfTableOfContents(string defaultText);
    protected virtual void WriteFieldInstContent(Stream oupt);
    protected virtual void WriteFieldResultContent(Stream oupt);
}
public class iTextSharp.text.rtf.field.RtfTocEntry : RtfField {
    private static Byte[] _textHiddenOff;
    private static Byte[] _textHiddenOn;
    private static Byte[] _tocEntryNoPageNumber;
    private static Byte[] _tocEntryPageNumber;
    private string _entry;
    private bool _showPageNumber;
    public RtfTocEntry(string entry);
    private static RtfTocEntry();
    public void SetShowPageNumber(bool showPageNumber);
    public virtual void WriteContent(Stream outp);
    protected virtual void WriteFieldInstContent(Stream oupt);
    protected virtual void WriteFieldResultContent(Stream oupt);
}
public class iTextSharp.text.rtf.field.RtfTotalPageNumber : RtfField {
    private static Byte[] _arabicTotalPages;
    public RtfTotalPageNumber(Font font);
    public RtfTotalPageNumber(RtfDocument doc);
    public RtfTotalPageNumber(RtfDocument doc, Font font);
    private static RtfTotalPageNumber();
    protected virtual void WriteFieldInstContent(Stream oupt);
    protected virtual void WriteFieldResultContent(Stream oupt);
}
public class iTextSharp.text.rtf.graphic.RtfImage : RtfElement {
    private static int PixelTwipsFactor;
    public static Byte[] Byte2CharLut;
    private static Byte[] _picture;
    private static Byte[] _pictureBinaryData;
    private static Byte[] _pictureGroup;
    private static Byte[] _pictureHeight;
    private static Byte[] _pictureJpeg;
    private static Byte[] _picturePng;
    private static Byte[] _pictureScaledHeight;
    private static Byte[] _pictureScaledWidth;
    private static Byte[] _pictureScaleX;
    private static Byte[] _pictureScaleY;
    private static Byte[] _pictureWidth;
    private static Byte[] _pictureWmf;
    private float _height;
    private Byte[][] _imageData;
    private int _imageType;
    private float _plainHeight;
    private float _plainWidth;
    private float _width;
    private int _alignment;
    private bool _topLevelElement;
    private static RtfImage();
    public RtfImage(RtfDocument doc, Image image);
    public void SetAlignment(int alignment);
    public void SetTopLevelElement(bool topLevelElement);
    public virtual void WriteContent(Stream outp);
    private Byte[][] getImageData(Image image);
    private int imageDataSize();
    private void writeImageDataHexEncoded(Stream bab);
}
public class iTextSharp.text.rtf.graphic.RtfShape : RtfAddableElement {
    public static int SHAPE_ARC;
    public static int SHAPE_ARROR_THICK;
    public static int SHAPE_ARROW;
    public static int SHAPE_BALLOON;
    public static int SHAPE_CAN;
    public static int SHAPE_CUBE;
    public static int SHAPE_DIAMOND;
    public static int SHAPE_DONUT;
    public static int SHAPE_ELLIPSE;
    public static int SHAPE_FREEFORM;
    public static int SHAPE_HEXAGON;
    public static int SHAPE_HOME_PLATE;
    public static int SHAPE_LINE;
    public static int SHAPE_OCTAGON;
    public static int SHAPE_PARALLELOGRAM;
    public static int SHAPE_PICTURE_FRAME;
    public static int SHAPE_RECTANGLE;
    public static int SHAPE_ROUND_RECTANGLE;
    public static int SHAPE_SEAL;
    public static int SHAPE_STAR;
    public static int SHAPE_TRAPEZOID;
    public static int SHAPE_TRIANGLE_ISOSCELES;
    public static int SHAPE_TRIANGLE_RIGHT;
    public static int SHAPE_WRAP_BOTH;
    public static int SHAPE_WRAP_LARGEST;
    public static int SHAPE_WRAP_LEFT;
    public static int SHAPE_WRAP_NONE;
    public static int SHAPE_WRAP_RIGHT;
    public static int SHAPE_WRAP_THROUGH;
    public static int SHAPE_WRAP_TIGHT_BOTH;
    public static int SHAPE_WRAP_TIGHT_LARGEST;
    public static int SHAPE_WRAP_TIGHT_LEFT;
    public static int SHAPE_WRAP_TIGHT_RIGHT;
    public static int SHAPE_WRAP_TOP_BOTTOM;
    private RtfShapePosition _position;
    private NullValueDictionary`2<string, RtfShapeProperty> _properties;
    private int _type;
    private int _shapeNr;
    private string _shapeText;
    private int _wrapping;
    public RtfShape(int type, RtfShapePosition position);
    public void SetProperty(RtfShapeProperty property);
    public void SetShapeText(string shapeText);
    public void SetWrapping(int wrapping);
    public virtual void WriteContent(Stream outp);
}
public class iTextSharp.text.rtf.graphic.RtfShapePosition : RtfAddableElement {
    public static int POSITION_X_RELATIVE_COLUMN;
    public static int POSITION_X_RELATIVE_MARGIN;
    public static int POSITION_X_RELATIVE_PAGE;
    public static int POSITION_Y_RELATIVE_MARGIN;
    public static int POSITION_Y_RELATIVE_PAGE;
    public static int POSITION_Y_RELATIVE_PARAGRAPH;
    private int _bottom;
    private int _left;
    private int _right;
    private int _top;
    private bool _ignoreXRelative;
    private bool _ignoreYRelative;
    private bool _shapeBelowText;
    private int _xRelativePos;
    private int _yRelativePos;
    private int _zOrder;
    public RtfShapePosition(int top, int left, int right, int bottom);
    public bool IsShapeBelowText();
    public void SetShapeBelowText(bool shapeBelowText);
    public void SetXRelativePos(int relativePos);
    public void SetYRelativePos(int relativePos);
    public void SetZOrder(int order);
    public virtual void WriteContent(Stream outp);
    protected internal void SetIgnoreXRelative(bool ignoreXRelative);
    protected internal void SetIgnoreYRelative(bool ignoreYRelative);
}
public class iTextSharp.text.rtf.graphic.RtfShapeProperty : RtfAddableElement {
    public static string PROPERTY_ADJUST_VALUE;
    public static string PROPERTY_FILL_COLOR;
    public static string PROPERTY_FLIP_H;
    public static string PROPERTY_FLIP_V;
    public static string PROPERTY_GEO_BOTTOM;
    public static string PROPERTY_GEO_LEFT;
    public static string PROPERTY_GEO_RIGHT;
    public static string PROPERTY_GEO_TOP;
    public static string PROPERTY_IMAGE;
    public static string PROPERTY_LAYOUT_IN_CELL;
    public static string PROPERTY_LINE_COLOR;
    public static string PROPERTY_VERTICIES;
    private static int PropertyTypeArray;
    private static int PropertyTypeBoolean;
    private static int PropertyTypeColor;
    private static int PropertyTypeDouble;
    private static int PropertyTypeImage;
    private static int PropertyTypeLong;
    private string _name;
    private int _type;
    private object _value;
    public RtfShapeProperty(string name, long value);
    public RtfShapeProperty(string name, double value);
    public RtfShapeProperty(string name, bool value);
    public RtfShapeProperty(string name, BaseColor value);
    public RtfShapeProperty(string name, Int32[] value);
    public RtfShapeProperty(string name, Point[] value);
    public RtfShapeProperty(string name, Image value);
    private RtfShapeProperty(string name, object value);
    public string GetName();
    public virtual void WriteContent(Stream outp);
}
public class iTextSharp.text.rtf.headerfooter.RtfHeaderFooter : HeaderFooter {
    public static int DISPLAY_ALL_PAGES;
    public static int DISPLAY_FIRST_PAGE;
    public static int DISPLAY_LEFT_PAGES;
    public static int DISPLAY_RIGHT_PAGES;
    public static int TYPE_FOOTER;
    public static int TYPE_HEADER;
    private static Byte[] _footerAll;
    private static Byte[] _footerFirst;
    private static Byte[] _footerLeft;
    private static Byte[] _footerRight;
    private static Byte[] _headerAll;
    private static Byte[] _headerFirst;
    private static Byte[] _headerLeft;
    private static Byte[] _headerRight;
    private Object[] _content;
    private int _displayAt;
    private RtfDocument _document;
    private int _type;
    public RtfHeaderFooter(IElement element);
    public RtfHeaderFooter(IElement[] elements);
    protected internal RtfHeaderFooter(RtfDocument doc, HeaderFooter headerFooter, int type, int displayAt);
    protected internal RtfHeaderFooter(RtfDocument doc, RtfHeaderFooter headerFooter, int displayAt);
    protected internal RtfHeaderFooter(RtfDocument doc, HeaderFooter headerFooter);
    private static RtfHeaderFooter();
    public sealed virtual void SetInHeader(bool inHeader);
    public sealed virtual void SetInTable(bool inTable);
    public sealed virtual void SetRtfDocument(RtfDocument doc);
    public virtual void WriteContent(Stream outp);
    public void SetAlignment(int alignment);
    public void SetDisplayAt(int displayAt);
    public void SetType(int type);
    private Object[] getContent();
}
public class iTextSharp.text.rtf.headerfooter.RtfHeaderFooterGroup : HeaderFooter {
    private static int ModeMultiple;
    private static int ModeNone;
    private static int ModeSingle;
    private RtfDocument _document;
    private RtfHeaderFooter _headerAll;
    private RtfHeaderFooter _headerFirst;
    private RtfHeaderFooter _headerLeft;
    private RtfHeaderFooter _headerRight;
    private int _mode;
    private int _type;
    public RtfHeaderFooterGroup(RtfDocument doc, int type);
    public RtfHeaderFooterGroup(RtfDocument doc, RtfHeaderFooterGroup headerFooter, int type);
    public RtfHeaderFooterGroup(RtfDocument doc, RtfHeaderFooter headerFooter, int type);
    public RtfHeaderFooterGroup(RtfDocument doc, HeaderFooter headerFooter, int type);
    public sealed virtual void SetInHeader(bool inHeader);
    public sealed virtual void SetInTable(bool inTable);
    public sealed virtual void SetRtfDocument(RtfDocument doc);
    public virtual void WriteContent(Stream outp);
    public bool HasFacingPages();
    public bool HasTitlePage();
    public void SetHasFacingPages();
    public void SetHasTitlePage();
    public void SetHeaderFooter(RtfHeaderFooter headerFooter, int displayAt);
    public void SetHeaderFooter(HeaderFooter headerFooter, int displayAt);
    public void SetType(int type);
    protected RtfHeaderFooter GetHeaderAll();
    protected RtfHeaderFooter GetHeaderFirst();
    protected RtfHeaderFooter GetHeaderLeft();
    protected RtfHeaderFooter GetHeaderRight();
    protected int GetMode();
}
public interface iTextSharp.text.rtf.IEventListener {
}
public interface iTextSharp.text.rtf.IRtfBasicElement {
    public abstract virtual void WriteContent(Stream outp);
    public abstract virtual void SetRtfDocument(RtfDocument doc);
    public abstract virtual void SetInTable(bool inTable);
    public abstract virtual void SetInHeader(bool inHeader);
}
public interface iTextSharp.text.rtf.IRtfExtendedElement {
    public abstract virtual void WriteDefinition(Stream outp);
}
public class iTextSharp.text.rtf.list.RtfList : RtfElement {
    public static int LIST_TYPE_HYBRID;
    public static int LIST_TYPE_NORMAL;
    public static int LIST_TYPE_SIMPLE;
    public static Byte[] ListId;
    public static Byte[] ListLevelNumber;
    public static Byte[] ListNumber;
    public static Byte[] ListNumberEnd;
    public static Byte[] ListText;
    public static Byte[] Tab;
    private static Byte[] _list;
    private static Byte[] _listHybrid;
    private static Byte[] _listName;
    private static Byte[] _listRestarthdn;
    private static Byte[] _listSimple;
    private static Byte[] _listStyleid;
    private static Byte[] _listStylename;
    private static Byte[] _listTemplateId;
    private List`1<IRtfBasicElement> _items;
    private int _listId;
    private List`1<RtfListLevel> _listLevels;
    private int _listNumber;
    private int _listType;
    private string _name;
    private RtfList _parentList;
    public RtfList(RtfDocument doc);
    public RtfList(RtfDocument doc, List list);
    private static RtfList();
    public virtual void SetInHeader(bool inHeader);
    public virtual void SetInTable(bool inTable);
    public virtual void WriteContent(Stream outp);
    public sealed virtual void WriteDefinition(Stream outp);
    public int GetId();
    public RtfListLevel GetListLevel(int index);
    public int GetListNumber();
    public int GetListType();
    public string GetName();
    public RtfList GetParentList();
    public void SetDocument(RtfDocument doc);
    public void SetId(int id);
    public void SetListNumber(int listNumber);
    public void SetListType(int listType);
    public void SetName(string name);
    public void SetParentList(RtfList parentList);
    protected internal void CorrectIndentation();
    protected void CreateDefaultLevels();
    protected void WriteListNumbers(Stream result);
    protected void WriteListTextBlock(Stream result, int itemNr, RtfListLevel listLevel);
}
public class iTextSharp.text.rtf.list.RtfListItem : RtfParagraph {
    private bool _containsInnerList;
    private int _level;
    private RtfListLevel _parentList;
    public RtfListItem(RtfDocument doc, ListItem listItem);
    public int GetLevel();
    public RtfListLevel GetParent();
    public void InheritListSettings(int listNumber, int listLevel);
    public bool IsContainsInnerList();
    public void SetLevel(int level);
    public void SetParent(RtfListLevel parentList);
    public virtual void WriteContent(Stream outp);
    public bool WriteDefinition(Stream outp);
    protected internal void CorrectIndentation();
}
public class iTextSharp.text.rtf.list.RtfListLevel : RtfElement {
    public static int LIST_LEVEL_FOLLOW_NOTHING;
    public static int LIST_LEVEL_FOLLOW_SPACE;
    public static int LIST_LEVEL_FOLLOW_TAB;
    public static int LIST_TYPE_ARABIC;
    public static int LIST_TYPE_ARABIC_LEADING_ZERO;
    public static int LIST_TYPE_BASE;
    public static int LIST_TYPE_BULLET;
    public static int LIST_TYPE_CARDINAL_TEXT_NUMBER;
    public static int LIST_TYPE_LOWER_LETTERS;
    public static int LIST_TYPE_LOWER_ROMAN;
    public static int LIST_TYPE_LOWERCASE_LETTER;
    public static int LIST_TYPE_LOWERCASE_ROMAN_NUMERAL;
    public static int LIST_TYPE_NO_NUMBER;
    public static int LIST_TYPE_NUMBERED;
    public static int LIST_TYPE_ORDINAL_NUMBER;
    public static int LIST_TYPE_ORDINAL_TEXT_NUMBER;
    public static int LIST_TYPE_UNKNOWN;
    public static int LIST_TYPE_UPPER_LETTERS;
    public static int LIST_TYPE_UPPER_ROMAN;
    public static int LIST_TYPE_UPPERCASE_LETTER;
    public static int LIST_TYPE_UPPERCASE_ROMAN_NUMERAL;
    private static Byte[] _listLevel;
    private static Byte[] _listLevelAlignment;
    private static Byte[] _listLevelAlignmentNew;
    private static Byte[] _listLevelFirstIndent;
    private static Byte[] _listLevelFolow;
    private static Byte[] _listLevelIndent;
    private static Byte[] _listLevelLegal;
    private static Byte[] _listLevelNoRestart;
    private static Byte[] _listLevelNumbersBegin;
    private static Byte[] _listLevelNumbersEnd;
    private static Byte[] _listLevelNumbersNumbered;
    private static Byte[] _listLevelPicture;
    private static Byte[] _listLevelSpace;
    private static Byte[] _listLevelStartAt;
    private static Byte[] _listLevelStyleBulletedBegin;
    private static Byte[] _listLevelStyleBulletedEnd;
    private static Byte[] _listLevelStyleNumberedBegin;
    private static Byte[] _listLevelStyleNumberedEnd;
    private static Byte[] _listLevelSymbolIndent;
    private static Byte[] _listLevelTemplateId;
    private static Byte[] _listLevelTentative;
    private static Byte[] _listLevelText;
    private static Byte[] _listLevelType;
    private static Byte[] _listLevelTypeNew;
    private int _levelPicture;
    private int _templateId;
    private int _alignment;
    private string _bulletCharacter;
    private Chunk _bulletChunk;
    private int _firstIndent;
    private RtfFont _fontBullet;
    private RtfFont _fontNumber;
    private bool _isLegal;
    private bool _isTentative;
    private int _leftIndent;
    private int _levelFollowValue;
    private int _levelTextNumber;
    private RtfListLevel _listLevelParent;
    private int _listNoRestart;
    private int _listStartAt;
    private int _listType;
    private RtfList _parent;
    private int _rightIndent;
    private int _symbolIndent;
    private int listLevel;
    public RtfListLevel(RtfDocument doc);
    public RtfListLevel(RtfDocument doc, RtfList parent);
    public RtfListLevel(RtfListLevel ll);
    private static RtfListLevel();
    public virtual void WriteContent(Stream outp);
    public sealed virtual void WriteDefinition(Stream outp);
    public int GetAlignment();
    public string GetBulletCharacter();
    public int GetFirstIndent();
    public RtfFont GetFontBullet();
    public RtfFont GetFontNumber();
    public int GetLeftIndent();
    public int GetLevelFollowValue();
    public int GetLevelTextNumber();
    public int GetListLevel();
    public RtfListLevel GetListLevelParent();
    public int GetListNoRestart();
    public int GetListStartAt();
    public int GetListType();
    public RtfList GetParent();
    public int GetRightIndent();
    public int GetSymbolIndent();
    public bool IsLegal();
    public bool IsTentative();
    public void SetAlignment(int alignment);
    public void SetBulletCharacter(string bulletCharacter);
    public void SetBulletChunk(Chunk bulletCharacter);
    public void SetBulletFont(Font f);
    public void SetFirstIndent(int firstIndent);
    public void SetFontBullet(RtfFont fontBullet);
    public void SetFontNumber(RtfFont fontNumber);
    public void SetLeftIndent(int leftIndent);
    public void SetLegal(bool isLegal);
    public void SetLevelFollowValue(int levelFollowValue);
    public void SetLevelTextNumber(int levelTextNumber);
    public void SetListLevel(int listLevel);
    public void SetListLevelParent(RtfListLevel listLevelParent);
    public void SetListNoRestart(int listNoRestart);
    public void SetListStartAt(int listStartAt);
    public void SetListType(int listType);
    public void SetParent(RtfList parent);
    public void SetRightIndent(int rightIndent);
    public void SetSymbolIndent(int symbolIndent);
    public void SetTentative(bool isTentative);
    public void WriteIndentation(Stream result);
    public void WriteListBeginning(Stream result);
    protected internal void CorrectIndentation();
    protected void WriteListNumbers(Stream result);
}
public class iTextSharp.text.rtf.list.RtfListTable : RtfElement {
    private static Byte[] _listOverride;
    private static Byte[] _listOverrideCount;
    private static Byte[] _listOverrideTable;
    private static Byte[] _listTable;
    private List`1<RtfList> _lists;
    private List`1<RtfPictureList> _picturelists;
    public RtfListTable(RtfDocument doc);
    private static RtfListTable();
    public virtual void WriteContent(Stream outp);
    public virtual void WriteDefinition(Stream outp);
    public void FreeListNumber(RtfList list);
    public int GetListNumber(RtfList list);
}
public class iTextSharp.text.rtf.list.RtfPictureList : RtfElement {
    private static Byte[] _listLevelPicture;
    public RtfPictureList(RtfDocument doc);
    private static RtfPictureList();
    public virtual void WriteContent(Stream outp);
    public sealed virtual void WriteDefinition(Stream outp);
}
public interface iTextSharp.text.rtf.parser.ctrlwords.IRtfCtrlWordListener {
    public abstract virtual RtfCtrlWordData BeforeCtrlWord(RtfCtrlWordData ctrlWordData);
    public abstract virtual RtfCtrlWordData OnCtrlWord(RtfCtrlWordData ctrlWordData);
    public abstract virtual RtfCtrlWordData AfterCtrlWord(RtfCtrlWordData ctrlWordData);
}
public class iTextSharp.text.rtf.parser.ctrlwords.RtfCtrlWordData : object {
    public string CtrlWord;
    public int CtrlWordType;
    public bool HasParam;
    public bool IsNeg;
    public bool Modified;
    public bool NewGroup;
    public string Param;
    public string Prefix;
    public string SpecialHandler;
    public string Suffix;
    public int IntValue();
    public long LongValue();
    public virtual string ToString();
}
public class iTextSharp.text.rtf.parser.ctrlwords.RtfCtrlWordHandler : object {
    protected string CtrlWord;
    protected RtfCtrlWordData CtrlWordData;
    protected string CtrlWordPrefix;
    protected string CtrlWordSuffix;
    protected int CtrlWordType;
    protected int DefaultParameterValue;
    protected string GroupPrefix;
    protected bool PassDefaultParameterValue;
    protected RtfParser RtfParser;
    protected float RtfVersionSupported;
    protected string SpecialHandler;
    public RtfCtrlWordHandler(RtfParser rtfParser, string ctrlWord, int defaultParameterValue, bool passDefaultParameterValue, int ctrlWordType, string prefix, string suffix, string specialHandler);
    public bool HandleControlword(RtfCtrlWordData ctrlWordDataIn);
    protected static bool AfterControlWord();
    protected static bool BeforeControlWord();
    protected static bool OnControlWord();
    private void printDebug(string txt);
}
internal class iTextSharp.text.rtf.parser.ctrlwords.RtfCtrlWordMap : object {
    private NullValueDictionary`2<string, RtfCtrlWordHandler> _ctrlWords;
    public RtfCtrlWordMap(RtfParser rtfParser);
    public RtfCtrlWordHandler GetCtrlWordHandler(string ctrlWord);
}
public class iTextSharp.text.rtf.parser.ctrlwords.RtfCtrlWordMgr : object {
    public static bool Debug;
    public static bool DebugFound;
    public static bool DebugNotFound;
    private RtfCtrlWordMap _ctrlWordMap;
    private List`1<IRtfCtrlWordListener> _listeners;
    private PushbackStream _reader;
    private RtfParser _rtfParser;
    public RtfCtrlWordMgr(RtfParser rtfParser, PushbackStream reader);
    private static RtfCtrlWordMgr();
    public void AddRtfCtrlWordListener(IRtfCtrlWordListener listener);
    public int HandleKeyword(RtfCtrlWordData ctrlWordData, int groupLevel);
    public void RemoveRtfCtrlWordListener(IRtfCtrlWordListener listener);
    private bool afterCtrlWord(RtfCtrlWordData ctrlWordData);
    private bool beforeCtrlWord(RtfCtrlWordData ctrlWordData);
    private int dispatchKeyword(RtfCtrlWordData ctrlWordData, int groupLevel);
    private bool onCtrlWord(RtfCtrlWordData ctrlWordData);
}
public class iTextSharp.text.rtf.parser.ctrlwords.RtfCtrlWordType : object {
    public static int DESTINATION;
    public static int DESTINATION_EX;
    public static int FLAG;
    public static int SYMBOL;
    public static int TOGGLE;
    public static int UNIDENTIFIED;
    public static int VALUE;
}
public interface iTextSharp.text.rtf.parser.destinations.IRtfDestinationListener {
    public abstract virtual int AfterCharacter(int ch);
    public abstract virtual RtfCtrlWordData AfterCtrlWord(RtfCtrlWordData ctrlWordData);
    public abstract virtual int BeforeCharacter(int ch);
    public abstract virtual RtfCtrlWordData BeforeCtrlWord(RtfCtrlWordData ctrlWordData);
    public abstract virtual int OnCharacter(int ch);
    public abstract virtual bool OnCloseGroup();
    public abstract virtual RtfCtrlWordData OnCtrlWord(RtfCtrlWordData ctrlWordData);
    public abstract virtual bool OnOpenGroup();
}
public abstract class iTextSharp.text.rtf.parser.destinations.RtfDestination : object {
    private static List`1<IRtfDestinationListener> _listeners;
    protected RtfCtrlWordData LastCtrlWord;
    protected bool Modified;
    protected RtfParser RtfParser;
    protected RtfDestination(RtfParser parser);
    private static RtfDestination();
    public static bool AddListener(IRtfDestinationListener listener);
    public abstract virtual bool CloseDestination();
    public virtual int GetNewTokeniserState();
    public abstract virtual bool HandleCharacter(int ch);
    public abstract virtual bool HandleCloseGroup();
    public abstract virtual bool HandleControlWord(RtfCtrlWordData ctrlWordData);
    public abstract virtual bool HandleOpenGroup();
    public abstract virtual bool HandleOpeningSubGroup();
    public bool IsModified();
    public static bool RemoveListener(IRtfDestinationListener listener);
    public virtual void SetParser(RtfParser parser);
    public abstract virtual void SetToDefaults();
    protected static int AfterCharacter(int ch);
    protected static RtfCtrlWordData AfterCtrlWord(RtfCtrlWordData ctrlWordData);
    protected static int BeforeCharacter(int ch);
    protected static RtfCtrlWordData BeforeCtrlWord(RtfCtrlWordData ctrlWordData);
    protected static int OnCharacter(int ch);
    protected static bool OnCloseGroup();
    protected static RtfCtrlWordData OnCtrlWord(RtfCtrlWordData ctrlWordData);
    protected static bool OnOpenGroup();
}
public class iTextSharp.text.rtf.parser.destinations.RtfDestinationColorTable : RtfDestination {
    private int _blue;
    private INullValueDictionary`2<string, BaseColor> _colorMap;
    private int _colorNr;
    private int _cshade;
    private int _ctint;
    private int _green;
    private RtfImportMgr _importHeader;
    private int _red;
    private int _themeColor;
    public RtfDestinationColorTable(RtfParser parser);
    public virtual bool CloseDestination();
    public BaseColor GetColor(string key);
    public virtual bool HandleCharacter(int ch);
    public virtual bool HandleCloseGroup();
    public virtual bool HandleControlWord(RtfCtrlWordData ctrlWordData);
    public virtual bool HandleOpenGroup();
    public virtual bool HandleOpeningSubGroup();
    public virtual void SetParser(RtfParser parser);
    public virtual void SetToDefaults();
    private void processColor();
    private void setBlue(int value);
    private void setGreen(int value);
    private void setRed(int value);
    private void setShade(int value);
    private void setThemeColor(int value);
    private void setTint(int value);
}
public class iTextSharp.text.rtf.parser.destinations.RtfDestinationDocument : RtfDestination {
    private static List`1<string> _importIgnoredCtrlwords;
    private static List`1<string> _convertIgnoredCtrlwords;
    private StringBuilder _buffer;
    private int _conversionType;
    private Document _doc;
    private Paragraph _iTextParagraph;
    private RtfDocument _rtfDoc;
    private int _tableLevel;
    public RtfDestinationDocument(RtfParser parser);
    private static RtfDestinationDocument();
    public sealed virtual void AfterPropertyChange(string propertyName);
    public sealed virtual void BeforePropertyChange(string propertyName);
    public virtual bool CloseDestination();
    public virtual bool HandleCharacter(int ch);
    public virtual bool HandleCloseGroup();
    public virtual bool HandleControlWord(RtfCtrlWordData ctrlWordData);
    public virtual bool HandleOpenGroup();
    public virtual bool HandleOpeningSubGroup();
    public virtual void SetParser(RtfParser parser);
    public virtual void SetToDefaults();
    private void addParagraphToDocument();
    private void writeBuffer();
    private void writeText(string value);
}
public class iTextSharp.text.rtf.parser.destinations.RtfDestinationFontTable : RtfDestination {
    private static string CharsetDefault;
    private static int SettingAlternate;
    private static int SettingFontEmbed;
    private static int SettingFontFile;
    private static int SettingFontname;
    private static int SettingNormal;
    private static int SettingPanose;
    private string _charset;
    private string _cpg;
    private string _falt;
    private int _fbias;
    private string _fontFamily;
    private INullValueDictionary`2<string, Font> _fontMap;
    private string _fontName;
    private string _fontNr;
    private int _fprq;
    private RtfImportMgr _importHeader;
    private string _panose;
    private int _state;
    private string _themeFont;
    private string _trueType;
    public RtfDestinationFontTable(RtfParser parser);
    public virtual bool CloseDestination();
    public Font GetFont(string key);
    public virtual bool HandleCharacter(int ch);
    public virtual bool HandleCloseGroup();
    public virtual bool HandleControlWord(RtfCtrlWordData ctrlWordData);
    public virtual bool HandleOpenGroup();
    public virtual bool HandleOpeningSubGroup();
    public void SetBias(string value);
    public void SetCharset(string charset);
    public void SetCodePage(string value);
    public void SetFontAlternate(string fontAlternate);
    public void SetFontFamily(string fontFamily);
    public void SetFontName(string fontName);
    public void SetFontNumber(string fontNr);
    public virtual void SetParser(RtfParser parser);
    public void SetPitch(string value);
    public void SetThemeFont(string themeFont);
    public virtual void SetToDefaults();
    public void SetTrueType(string value);
    private static Font createfont(string fontName);
    private static void importSystemFonts();
    private void init(bool importFonts);
    private void processFont();
}
public class iTextSharp.text.rtf.parser.destinations.RtfDestinationInfo : RtfDestination {
    private string _elementName;
    private string _text;
    public RtfDestinationInfo(RtfParser parser, string elementname);
    public virtual bool CloseDestination();
    public virtual bool HandleCharacter(int ch);
    public virtual bool HandleCloseGroup();
    public virtual bool HandleControlWord(RtfCtrlWordData ctrlWordData);
    public virtual bool HandleOpenGroup();
    public virtual bool HandleOpeningSubGroup();
    public void SetElementName(string value);
    public virtual void SetParser(RtfParser parser);
    public virtual void SetToDefaults();
}
public class iTextSharp.text.rtf.parser.destinations.RtfDestinationListTable : RtfDestination {
    private int _currentLevel;
    private RtfListLevel _currentListLevel;
    private int _currentListMappingNumber;
    private int _currentSubGroupCount;
    private RtfImportMgr _importHeader;
    private RtfList _newList;
    public RtfDestinationListTable(RtfParser parser);
    public virtual bool CloseDestination();
    public virtual bool HandleCharacter(int ch);
    public virtual bool HandleCloseGroup();
    public virtual bool HandleControlWord(RtfCtrlWordData ctrlWordData);
    public virtual bool HandleOpenGroup();
    public virtual bool HandleOpeningSubGroup();
    public virtual void SetParser(RtfParser parser);
    public virtual void SetToDefaults();
}
public class iTextSharp.text.rtf.parser.destinations.RtfDestinationMgr : object {
    public static string DESTINATION_DOCUMENT;
    public static string DESTINATION_NULL;
    private static bool _ignoreUnknownDestinations;
    private static NullValueDictionary`2<string, RtfDestination> _destinationObjects;
    private static NullValueDictionary`2<string, RtfDestination> _destinations;
    private static RtfDestinationMgr _instance;
    private static RtfParser _rtfParser;
    private static RtfDestinationMgr();
    public static bool AddDestination(string destination, Object[] args);
    public static bool AddListener(string destination, IRtfDestinationListener listener);
    public static RtfDestination GetDestination(string destination);
    public static RtfDestinationMgr GetInstance();
    public static RtfDestinationMgr GetInstance(RtfParser parser);
    public static bool RemoveListener(string destination, IRtfDestinationListener listener);
    public static void SetParser(RtfParser parser);
}
public class iTextSharp.text.rtf.parser.destinations.RtfDestinationNull : RtfDestination {
    private static RtfDestinationNull _instance;
    private RtfDestinationNull(RtfParser parser);
    private static RtfDestinationNull();
    public static RtfDestinationNull GetInstance();
    public static string GetName();
    public virtual bool CloseDestination();
    public virtual int GetNewTokeniserState();
    public virtual bool HandleCharacter(int ch);
    public virtual bool HandleCloseGroup();
    public virtual bool HandleControlWord(RtfCtrlWordData ctrlWordData);
    public virtual bool HandleOpenGroup();
    public virtual bool HandleOpeningSubGroup();
    public virtual void SetToDefaults();
}
public class iTextSharp.text.rtf.parser.destinations.RtfDestinationShppict : RtfDestination {
    public static int FORMAT_BINARY;
    public static int FORMAT_HEXADECIMAL;
    public static int ORIGINAL_GIF;
    public static int ORIGINAL_NONE;
    public static int ORIGINAL_PS;
    public static int ORIGINAL_TIFF;
    private static int Blipuid;
    private static int Normal;
    private static int PixelTwipsFactor;
    private long _binaryLength;
    private StringBuilder _buffer;
    private int _cropBottom;
    private int _cropLeft;
    private int _cropRight;
    private int _cropTop;
    private ByteBuffer _data;
    private int _dataFormat;
    private MemoryStream _dataOs;
    private long _desiredHeight;
    private long _desiredWidth;
    private long _height;
    private StringBuilder _hexChars;
    private int _scaleX;
    private int _scaleY;
    private long _width;
    [CompilerGeneratedAttribute]
private int <PictureType>k__BackingField;
    public int PictureType { get; private set; }
    public RtfDestinationShppict(RtfParser parser);
    [CompilerGeneratedAttribute]
public int get_PictureType();
    [CompilerGeneratedAttribute]
private void set_PictureType(int value);
    public virtual bool CloseDestination();
    public virtual bool HandleCharacter(int ch);
    public virtual bool HandleCloseGroup();
    public virtual bool HandleControlWord(RtfCtrlWordData ctrlWordData);
    public virtual bool HandleOpenGroup();
    public virtual bool HandleOpeningSubGroup();
    public virtual void SetToDefaults();
    private bool addImage();
    private void writeBuffer();
    private void writeText(string value);
}
public class iTextSharp.text.rtf.parser.destinations.RtfDestinationStylesheetTable : RtfDestination {
    private int _adustRightIndent;
    private int _alignment;
    private int _autoSpaceBetweenDbcEnglish;
    private int _autoSpaceBetweenDbcNumbers;
    private string _elementName;
    private int _firstLineIndent;
    private RtfImportMgr _importHeader;
    private int _justificationPercentage;
    private int _leftIndent;
    private int _mirrorIndent;
    private int _noCharacterWrapping;
    private int _noOverflowPeriodComma;
    private int _noWordWrapping;
    private int _overrideWidowControl;
    private int _rightIndent;
    private string _styleName;
    private int _styleNr;
    private int _styleType;
    private string _type;
    public RtfDestinationStylesheetTable(RtfParser parser, string type);
    public virtual bool CloseDestination();
    public static void CreateNewStyle();
    public int GetAdustRightIndent();
    public int GetAlignment();
    public int GetAutoSpaceBetweenDbcEnglish();
    public int GetAutoSpaceBetweenDbcNumbers();
    public int GetFirstLineIndent();
    public int GetIndent();
    public int GetJustificationPercentage();
    public int GetLeftIndent();
    public int GetMirrorIndent();
    public int GetNoCharacterWrapping();
    public int GetNoOverflowPeriodComma();
    public int GetNoWordWrapping();
    public int GetOverrideWidowControl();
    public int GetRightIndent();
    public int GetStyleNr();
    public int GetStyleType();
    public virtual bool HandleCharacter(int ch);
    public virtual bool HandleCloseGroup();
    public virtual bool HandleControlWord(RtfCtrlWordData ctrlWordData);
    public virtual bool HandleOpenGroup();
    public virtual bool HandleOpeningSubGroup();
    public void SetAdustRightIndent(int adustRightIndent);
    public int SetAlignment(int alignment);
    public void SetAutoSpaceBetweenDbcEnglish(int autoSpaceBetweenDbcEnglish);
    public void SetAutoSpaceBetweenDbcNumbers(int autoSpaceBetweenDbcNumbers);
    public void SetElementName(string value);
    public void SetFirstLineIndent(int firstLineIndent);
    public void SetIndent(int indent);
    public int SetJustificationPercentage(int percent);
    public void SetLeftIndent(int leftIndent);
    public void SetMirrorIndent(int mirrorIndent);
    public void SetNoCharacterWrapping(int noCharacterWrapping);
    public void SetNoOverflowPeriodComma(int noOverflowPeriodComma);
    public void SetNoWordWrapping(int noWordWrapping);
    public void SetOverrideWidowControl(int overrideWidowControl);
    public virtual void SetParser(RtfParser parser);
    public void SetRightIndent(int rightIndent);
    public void SetStyleNr(int styleNr);
    public void SetStyleType(int styleType);
    public virtual void SetToDefaults();
    public void SetType(string value);
}
public class iTextSharp.text.rtf.parser.enumerations.RtfColorThemes : object {
    public static int THEME_UNDEFINED;
    public static int THEME_MAINDARKONE;
    public static int THEME_MAINDARKTWO;
    public static int THEME_MAINLIGHTONE;
    public static int THEME_MAINLIGHTTWO;
    public static int THEME_ACCENTONE;
    public static int THEME_ACCENTTWO;
    public static int THEME_ACCENTTHREE;
    public static int THEME_ACCENTFOUR;
    public static int THEME_ACCENTFIVE;
    public static int THEME_ACCENTSIX;
    public static int THEME_HYPERLINK;
    public static int THEME_FOLLOWEDHYPERLINK;
    public static int THEME_BACKGROUNDONE;
    public static int THEME_TEXTONE;
    public static int THEME_BACKGROUNDTWO;
    public static int THEME_TEXTTWO;
    public static int THEME_MAX;
}
public class iTextSharp.text.rtf.parser.exceptions.RtfParserException : Exception {
    public RtfParserException(Exception ex);
    public RtfParserException(string message);
    public RtfParserException(string message, Exception innerException);
}
public class iTextSharp.text.rtf.parser.exceptions.RtfUnknownCtrlWordException : RtfParserException {
    public RtfUnknownCtrlWordException(string message);
    public RtfUnknownCtrlWordException(string message, Exception innerException);
}
public interface iTextSharp.text.rtf.parser.properties.IRtfPropertyListener {
    public abstract virtual void BeforePropertyChange(string propertyName);
    public abstract virtual void AfterPropertyChange(string propertyName);
}
public static class iTextSharp.text.rtf.parser.properties.RtfCtrlWordPropertyType : object {
    public static int UNIDENTIFIED;
    public static int PROPERTY;
    public static int CHARACTER;
    public static int SPECIAL;
    public static int DESTINATION;
}
public class iTextSharp.text.rtf.parser.properties.RtfProperty : object {
    public static string CHARACTER;
    public static string CHARACTER_BOLD;
    public static string CHARACTER_FONT;
    public static string CHARACTER_ITALIC;
    public static string CHARACTER_SIZE;
    public static string CHARACTER_STYLE;
    public static string CHARACTER_UNDERLINE;
    public static string COLOR;
    public static string COLOR_BG;
    public static string COLOR_FG;
    public static string DOCUMENT;
    public static string DOCUMENT_DEFAULT_FONT_NUMER;
    public static string DOCUMENT_ENABLE_FACING_PAGES;
    public static string DOCUMENT_MARGIN_BOTTOM_TWIPS;
    public static string DOCUMENT_MARGIN_LEFT_TWIPS;
    public static string DOCUMENT_MARGIN_RIGHT_TWIPS;
    public static string DOCUMENT_MARGIN_TOP_TWIPS;
    public static string DOCUMENT_PAGE_HEIGHT_TWIPS;
    public static string DOCUMENT_PAGE_NUMBER_START;
    public static string DOCUMENT_PAGE_ORIENTATION;
    public static string DOCUMENT_PAGE_WIDTH_TWIPS;
    public static int JUSTIFY_CENTER;
    public static int JUSTIFY_FULL;
    public static int JUSTIFY_LEFT;
    public static int JUSTIFY_RIGHT;
    public static int OFF;
    public static int ON;
    public static string PAGE_LANDSCAPE;
    public static string PAGE_PORTRAIT;
    public static string PARAGRAPH;
    public static string PARAGRAPH_BORDER;
    public static int PARAGRAPH_BORDER_BOTTOM;
    public static string PARAGRAPH_BORDER_CELL;
    public static int PARAGRAPH_BORDER_DIAGONAL_UL_LR;
    public static int PARAGRAPH_BORDER_DIAGONAL_UR_LL;
    public static int PARAGRAPH_BORDER_LEFT;
    public static int PARAGRAPH_BORDER_NIL;
    public static int PARAGRAPH_BORDER_RIGHT;
    public static int PARAGRAPH_BORDER_TABLE_HORIZONTAL;
    public static int PARAGRAPH_BORDER_TABLE_VERTICAL;
    public static int PARAGRAPH_BORDER_TOP;
    public static string PARAGRAPH_INDENT_FIRST_LINE;
    public static string PARAGRAPH_INDENT_LEFT;
    public static string PARAGRAPH_INDENT_RIGHT;
    public static string PARAGRAPH_JUSTIFICATION;
    public static int PGN_DECIMAL;
    public static int PGN_LETTER_LOWERCASE;
    public static int PGN_LETTER_UPPERCASE;
    public static int PGN_ROMAN_NUMERAL_LOWERCASE;
    public static int PGN_ROMAN_NUMERAL_UPPERCASE;
    public static int SBK_COLUMN;
    public static int SBK_EVEN;
    public static int SBK_NONE;
    public static int SBK_ODD;
    public static int SBK_PAGE;
    public static string SECTION;
    public static string SECTION_BREAK_TYPE;
    public static string SECTION_NUMBER_OF_COLUMNS;
    public static string SECTION_PAGE_NUMBER_FORMAT;
    public static string SECTION_PAGE_NUMBER_POSITION_X;
    public static string SECTION_PAGE_NUMBER_POSITION_Y;
    private List`1<IRtfPropertyListener> _listeners;
    private bool _modifiedCharacter;
    private bool _modifiedDocument;
    private bool _modifiedParagraph;
    private bool _modifiedSection;
    protected INullValueDictionary`2<string, object> Properties;
    public void AddRtfPropertyListener(IRtfPropertyListener listener);
    public void AfterChange(string propertyName);
    public void BeforeChange(string propertyName);
    public INullValueDictionary`2<string, object> GetProperties(string propertyGroup);
    public object GetProperty(string propertyName);
    public bool IsModified();
    public bool IsModifiedCharacter();
    public bool IsModifiedDocument();
    public bool IsModifiedParagraph();
    public bool IsModifiedSection();
    public void RemoveRtfPropertyListener(IRtfPropertyListener listener);
    public void SetModified(string propertyName, bool modified);
    public void SetModifiedCharacter(bool modifiedCharacter);
    public void SetModifiedDocument(bool modifiedDocument);
    public void SetModifiedParagraph(bool modifiedParagraph);
    public void SetModifiedSection(bool modifiedSection);
    public bool SetProperty(RtfCtrlWordData ctrlWordData);
    public void SetToDefault();
    public void SetToDefault(string propertyGroup);
    public bool ToggleProperty(RtfCtrlWordData ctrlWordData);
    private bool addToProperty(string propertyName, int propertyValue);
    private bool addToProperty(string propertyName, long propertyValue);
    private bool removeProperty(string propertyName);
    private bool setProperty(string propertyName, object propertyValueNew);
    private bool setProperty(string propertyName, int propertyValueNew);
    private bool setProperty(string propertyName, long propertyValueNew);
}
public class iTextSharp.text.rtf.parser.PushbackStream : Stream {
    private Stream _s;
    private int _buf;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public PushbackStream(Stream s);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Unread(int b);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte value);
}
public class iTextSharp.text.rtf.parser.RtfImportMappings : object {
    private INullValueDictionary`2<string, BaseColor> _colorMappings;
    private INullValueDictionary`2<string, string> _fontMappings;
    private INullValueDictionary`2<string, string> _listMappings;
    private INullValueDictionary`2<string, string> _stylesheetListMappings;
    public void AddColor(string colorNr, BaseColor color);
    public void AddFont(string fontNr, string fontName);
    public void AddList(string listNr, string list);
    public void AddStylesheetList(string stylesheetListNr, string list);
    public INullValueDictionary`2<string, BaseColor> GetColorMappings();
    public INullValueDictionary`2<string, string> GetFontMappings();
    public INullValueDictionary`2<string, string> GetListMappings();
    public INullValueDictionary`2<string, string> GetStylesheetListMappings();
}
public class iTextSharp.text.rtf.parser.RtfImportMgr : object {
    private NullValueDictionary`2<string, string> _importColorMapping;
    private NullValueDictionary`2<string, string> _importFontMapping;
    private NullValueDictionary`2<string, string> _importListMapping;
    private NullValueDictionary`2<string, string> _importStylesheetListMapping;
    private RtfDocument _rtfDoc;
    private Document _doc;
    public RtfImportMgr(RtfDocument rtfDoc, Document doc);
    public void ImportColor(string colorNr, BaseColor color);
    public bool ImportFont(string fontNr, string fontName);
    public bool ImportFont(string fontNr, string fontName, int charset);
    public bool ImportFont(string fontNr, string fontName, string fontFamily, int charset);
    public void ImportList(string origListNr, string newListNr);
    public bool ImportStylesheetList(string listNr, List listIn);
    public string MapColorNr(string colorNr);
    public string MapFontNr(string fontNr);
    public string MapListNr(string listNr);
    public string MapStylesheetListNr(string listNr);
}
public class iTextSharp.text.rtf.parser.RtfParser : object {
    public static int DESTINATION_NORMAL;
    public static int DESTINATION_SKIP;
    public static int errAssertion;
    public static int errBadTable;
    public static int errCtrlWordNotFound;
    public static int errEndOfFile;
    public static int errInvalidHex;
    public static int errOK;
    public static int errStackOverflow;
    public static int errStackUnderflow;
    public static int errUnmatchedBrace;
    public static int PARSER_ERROR;
    public static int PARSER_ERROR_EOF;
    public static int PARSER_IN_BLIPUID;
    public static int PARSER_IN_CHARSET;
    public static int PARSER_IN_COLOR_TABLE;
    public static int PARSER_IN_DEFFONT;
    public static int PARSER_IN_DOCUMENT;
    public static int PARSER_IN_FILE_TABLE;
    public static int PARSER_IN_FONT_TABLE;
    public static int PARSER_IN_FONT_TABLE_INFO;
    public static int PARSER_IN_GENERATOR;
    public static int PARSER_IN_HEADER;
    public static int PARSER_IN_INFO_GROUP;
    public static int PARSER_IN_LATENTSTYLES;
    public static int PARSER_IN_LIST_TABLE;
    public static int PARSER_IN_LISTOVERRIDE_TABLE;
    public static int PARSER_IN_OLDCPROPS;
    public static int PARSER_IN_OLDPPROPS;
    public static int PARSER_IN_OLDSPROPS;
    public static int PARSER_IN_OLDTPROPS;
    public static int PARSER_IN_PARAGRAPH_GROUP_PROPERTIES;
    public static int PARSER_IN_PARAGRAPH_TABLE;
    public static int PARSER_IN_PICPROP;
    public static int PARSER_IN_PICT;
    public static int PARSER_IN_PROT_USER_TABLE;
    public static int PARSER_IN_REV_TABLE;
    public static int PARSER_IN_RSID_TABLE;
    public static int PARSER_IN_SHPPICT;
    public static int PARSER_IN_STYLESHEET;
    public static int PARSER_IN_UNKNOWN;
    public static int PARSER_IN_UPR;
    public static int PARSER_STARTSTOP;
    public static int TOKENISER_BINARY;
    public static int TOKENISER_HEX;
    public static int TOKENISER_IGNORE_RESULT;
    public static int TOKENISER_NORMAL;
    public static int TOKENISER_SKIP_BYTES;
    public static int TOKENISER_SKIP_GROUP;
    public static int TOKENISER_STATE_IN_ERROR;
    public static int TOKENISER_STATE_IN_UNKOWN;
    public static int TYPE_CONVERT;
    public static int TYPE_IMPORT_FRAGMENT;
    public static int TYPE_IMPORT_FULL;
    public static int TYPE_IMPORT_INTO_ELEMENT;
    public static int TYPE_UNIDENTIFIED;
    private List`1<IEventListener> _listeners;
    private long _binByteCount;
    private long _binSkipByteCount;
    private long _byteCount;
    private long _characterCount;
    private long _closeGroupCount;
    private int _conversionType;
    private long _ctrlWordCount;
    private long _ctrlWordHandledCount;
    private long _ctrlWordNotHandledCount;
    private long _ctrlWordSkippedCount;
    private RtfParserState _currentState;
    private RtfDestinationMgr _destinationMgr;
    private int _docGroupLevel;
    private Document _document;
    private IElement _elem;
    private DateTime _endDate;
    private long _endTime;
    private int _groupLevel;
    private long _groupSkippedCount;
    private RtfImportMgr _importMgr;
    private RtfCtrlWordData _lastCtrlWordParam;
    private bool _logAppend;
    private string _logFile;
    private bool _logging;
    private long _openGroupCount;
    private PushbackStream _pbReader;
    private RtfDocument _rtfDoc;
    private RtfCtrlWordMgr _rtfKeywordMgr;
    private int _skipGroupLevel;
    private Stack`1<RtfParserState> _stackState;
    private DateTime _startDate;
    private long _startTime;
    public RtfParser(Document doc);
    public static void OutputDebug(object doc, int groupLevel, string str);
    public void AddListener(IEventListener listener);
    public void ConvertRtfDocument(Stream readerIn, Document doc);
    public int GetConversionType();
    public RtfDestination GetCurrentDestination();
    public static RtfDestination GetDestination(string destination);
    public Document GetDocument();
    public bool GetExtendedDestination();
    public RtfImportMgr GetImportManager();
    public int GetLevel();
    public string GetLogFile();
    public int GetParserState();
    public RtfDocument GetRtfDocument();
    public RtfParserState GetState();
    public int GetTokeniserState();
    public int HandleCharacter(int nextChar);
    public int HandleCloseGroup();
    public int HandleCtrlWord(RtfCtrlWordData ctrlWordData);
    public int HandleOpenGroup();
    public void ImportRtfDocument(Stream readerIn, RtfDocument rtfDoc);
    public void ImportRtfDocumentIntoElement(IElement elem, Stream readerIn, RtfDocument rtfDoc);
    public void ImportRtfFragment(Stream readerIn, RtfDocument rtfDoc, RtfImportMappings importMappings);
    public bool IsConvert();
    public bool IsImport();
    public bool IsImportFragment();
    public bool IsImportFull();
    public bool IsLogAppend();
    public bool IsLogging();
    public bool IsNewGroup();
    public void RemoveListener(IEventListener listener);
    public bool SetCurrentDestination(string destination);
    public bool SetExtendedDestination(bool value);
    public void SetLogAppend(bool logAppend);
    public void SetLogFile(string logFile);
    public void SetLogFile(string logFile, bool logAppend);
    public void SetLogging(bool logging);
    public bool SetNewGroup(bool value);
    public int SetParserState(int newState);
    public void SetTokeniserSkipBytes(long numberOfBytesToSkip);
    public int SetTokeniserState(int value);
    public void SetTokeniserStateBinary(int binaryCount);
    public void SetTokeniserStateBinary(long binaryCount);
    public void SetTokeniserStateNormal();
    public void SetTokeniserStateSkipGroup();
    public void Tokenise();
    protected void Init_stats();
    private void handleImportMappings(RtfImportMappings importMappings);
    private void init(int type, RtfDocument rtfDoc, Stream readerIn, Document doc, IElement elem);
    private static PushbackStream Init_Reader(Stream readerIn);
    private int parseChar(int nextChar);
    private int parseCtrlWord(PushbackStream reader);
}
public class iTextSharp.text.rtf.parser.RtfParserState : object {
    public object CtrlWordHandler;
    public Stack`1<object> CtrlWordHandlers;
    public RtfDestination Destination;
    public object GroupHandler;
    public bool IsExtendedDestination;
    public bool NewGroup;
    public int ParserState;
    public RtfProperty Properties;
    public StringBuilder Text;
    public int TokeniserState;
    public RtfParserState(RtfParserState orig);
}
public abstract class iTextSharp.text.rtf.RtfAddableElement : Chunk {
    protected RtfDocument Doc;
    protected bool InHeader;
    protected bool InTable;
    public sealed virtual void SetInHeader(bool inHeader);
    public sealed virtual void SetInTable(bool inTable);
    public sealed virtual void SetRtfDocument(RtfDocument doc);
    public abstract virtual void WriteContent(Stream outp);
    public static Byte[] IntToByteArray(int i);
    public virtual bool IsEmpty();
}
public abstract class iTextSharp.text.rtf.RtfElement : object {
    public static double TWIPS_FACTOR;
    public static Byte[] CloseGroup;
    public static Byte[] CommaDelimiter;
    public static Byte[] Delimiter;
    public static Byte[] OpenGroup;
    protected RtfDocument Document;
    protected bool InHeader;
    public bool InTable;
    protected RtfElement(RtfDocument doc);
    private static RtfElement();
    public virtual void SetInHeader(bool inHeader);
    public virtual void SetInTable(bool inTable);
    public virtual void SetRtfDocument(RtfDocument doc);
    public abstract virtual void WriteContent(Stream outp);
    public static Byte[] IntToByteArray(int i);
    public virtual bool IsInTable();
}
public class iTextSharp.text.rtf.RtfMapper : object {
    private RtfDocument _rtfDoc;
    public RtfMapper(RtfDocument doc);
    public IRtfBasicElement[] MapElement(IElement element);
}
public class iTextSharp.text.rtf.RtfWriter2 : DocWriter {
    private RtfDocument _rtfDoc;
    unknown HeaderFooter Footer {public set; }
    unknown HeaderFooter Header {public set; }
    unknown int PageCount {public set; }
    protected RtfWriter2(Document doc, Stream os);
    public virtual void set_Footer(HeaderFooter value);
    public virtual void set_Header(HeaderFooter value);
    public virtual void set_PageCount(int value);
    public static RtfWriter2 GetInstance(Document doc, Stream os);
    public virtual bool Add(IElement element);
    public virtual void Close();
    public RtfDocumentSettings GetDocumentSettings();
    public void ImportRtfDocument(Stream documentSource);
    public void ImportRtfDocument(Stream documentSource, IEventListener[] events);
    public void ImportRtfDocumentIntoElement(IElement elem, FileStream documentSource);
    public void ImportRtfDocumentIntoElement(IElement elem, FileStream documentSource, IEventListener[] events);
    public void ImportRtfFragment(Stream documentSource, RtfImportMappings mappings);
    public void ImportRtfFragment(Stream documentSource, RtfImportMappings mappings, IEventListener[] events);
    public virtual bool NewPage();
    public virtual void Open();
    public virtual void ResetFooter();
    public virtual void ResetHeader();
    public virtual void ResetPageCount();
    public void SetAutogenerateTocEntries(bool autogenerate);
    public virtual bool SetMargins(float marginLeft, float marginRight, float marginTop, float marginBottom);
    public virtual bool SetPageSize(Rectangle pageSize);
}
public class iTextSharp.text.rtf.style.RtfColor : RtfElement {
    private static byte Colon;
    private static Byte[] _colorBlueBytes;
    private static Byte[] _colorGreenBytes;
    private static Byte[] _colorNumberBytes;
    private static Byte[] _colorRedBytes;
    private int _blue;
    private int _green;
    private int _red;
    private int _colorNumber;
    public RtfColor(RtfDocument doc, RtfColor col);
    public RtfColor(RtfDocument doc, BaseColor col);
    public RtfColor(RtfDocument doc, int red, int green, int blue);
    protected internal RtfColor(RtfDocument doc, int red, int green, int blue, int colorNumber);
    private static RtfColor();
    public virtual void SetRtfDocument(RtfDocument doc);
    public virtual void WriteContent(Stream outp);
    public virtual void WriteDefinition(Stream outp);
    public virtual bool Equals(object obj);
    public int GetBlue();
    public int GetColorNumber();
    public int GetGreen();
    public virtual int GetHashCode();
    public int GetRed();
    public void WriteBegin(Stream result);
    public static void WriteEnd(Stream result);
}
public class iTextSharp.text.rtf.style.RtfColorList : RtfElement {
    private static Byte[] _colorTable;
    private List`1<RtfColor> _colorList;
    public RtfColorList(RtfDocument doc);
    private static RtfColorList();
    public virtual void WriteContent(Stream outp);
    public virtual void WriteDefinition(Stream outp);
    public int GetColorNumber(RtfColor color);
}
public class iTextSharp.text.rtf.style.RtfFont : Font {
    public static int STYLE_BOLD;
    public static int STYLE_DOUBLE_STRIKETHROUGH;
    public static int STYLE_EMBOSSED;
    public static int STYLE_ENGRAVED;
    public static int STYLE_HIDDEN;
    public static int STYLE_ITALIC;
    public static int STYLE_NONE;
    public static int STYLE_OUTLINE;
    public static int STYLE_SHADOW;
    public static int STYLE_STRIKETHROUGH;
    public static int STYLE_UNDERLINE;
    public static Byte[] FontSize;
    private static Byte[] _fontBold;
    private static Byte[] _fontCharset;
    private static Byte[] _fontDoubleStrikethrough;
    private static Byte[] _fontEmbossed;
    private static Byte[] _fontEngraved;
    private static Byte[] _fontFamily;
    private static Byte[] _fontHidden;
    private static Byte[] _fontItalic;
    private static Byte[] _fontOutline;
    private static Byte[] _fontShadow;
    private static Byte[] _fontStrikethrough;
    private static Byte[] _fontUnderline;
    private int _charset;
    private RtfColor _color;
    private string _fontName;
    private int _fontNumber;
    private int _fontSize;
    private int _fontStyle;
    protected RtfDocument Document;
    unknown BaseColor Color {public set; }
    public string Familyname { get; }
    unknown float Size {public set; }
    public RtfFont(string fontName);
    public RtfFont(string fontName, float size);
    public RtfFont(string fontName, float size, int style);
    public RtfFont(string fontName, float size, int style, BaseColor color);
    public RtfFont(string fontName, float size, int style, BaseColor color, int charset);
    public RtfFont(RtfDocument doc, Font font);
    protected internal RtfFont(RtfDocument doc, int fontNumber);
    private static RtfFont();
    public virtual void set_Color(BaseColor value);
    public virtual string get_Familyname();
    public virtual void set_Size(float value);
    public sealed virtual void SetInHeader(bool inHeader);
    public sealed virtual void SetInTable(bool inTable);
    public sealed virtual void SetRtfDocument(RtfDocument doc);
    public virtual void WriteContent(Stream outp);
    public virtual void WriteDefinition(Stream outp);
    public virtual int CompareTo(object obj);
    public virtual Font Difference(Font font);
    public virtual bool Equals(object obj);
    public int GetCharset();
    public string GetFontName();
    public int GetFontNumber();
    public int GetFontSize();
    public int GetFontStyle();
    public virtual int GetHashCode();
    public virtual bool IsStandardFont();
    public void SetCharset(int charset);
    public virtual void SetColor(int red, int green, int blue);
    public virtual void SetFamily(string family);
    public virtual void SetFontName(string fontName);
    public virtual void SetStyle(int style);
    public virtual void SetStyle(string style);
    public virtual void WriteBegin(Stream result);
    public virtual void WriteEnd(Stream result);
    protected static Byte[] IntToByteArray(int i);
    private void setToDefaultFamily(string familyname);
}
public class iTextSharp.text.rtf.style.RtfFontList : RtfElement {
    public static Byte[] FontNumber;
    private static Byte[] _defaultFont;
    private static Byte[] _fontTable;
    private List`1<RtfFont> _fontList;
    public RtfFontList(RtfDocument doc);
    private static RtfFontList();
    public virtual void WriteContent(Stream outp);
    public virtual void WriteDefinition(Stream outp);
    public int GetFontNumber(RtfFont font);
}
public class iTextSharp.text.rtf.style.RtfParagraphStyle : RtfFont {
    private static int ModifiedAlignment;
    private static int ModifiedFontColor;
    private static int ModifiedFontName;
    private static int ModifiedFontSize;
    private static int ModifiedFontStyle;
    private static int ModifiedIndentLeft;
    private static int ModifiedIndentRight;
    private static int ModifiedKeepTogether;
    private static int ModifiedKeepTogetherWithNext;
    private static int ModifiedLineLeading;
    private static int ModifiedNone;
    private static int ModifiedSpacingAfter;
    private static int ModifiedSpacingBefore;
    public static Byte[] AlignCenter;
    public static Byte[] AlignJustify;
    public static Byte[] AlignLeft;
    public static Byte[] AlignRight;
    public static Byte[] FirstLineIndent;
    public static Byte[] IndentLeft;
    public static Byte[] IndentRight;
    public static Byte[] KeepTogether;
    public static Byte[] KeepTogetherWithNext;
    public static Byte[] SpacingAfter;
    public static Byte[] SpacingBefore;
    public static RtfParagraphStyle StyleHeading1;
    public static RtfParagraphStyle StyleHeading2;
    public static RtfParagraphStyle StyleHeading3;
    public static RtfParagraphStyle StyleNormal;
    private string _basedOnName;
    private string _styleName;
    private int _alignment;
    private RtfParagraphStyle _baseStyle;
    private int _firstLineIndent;
    private int _indentLeft;
    private int _indentRight;
    private bool _keepTogether;
    private bool _keepTogetherWithNext;
    private int _lineLeading;
    private int _modified;
    private int _spacingAfter;
    private int _spacingBefore;
    private int _styleNumber;
    unknown float Size {public set; }
    private static RtfParagraphStyle();
    public RtfParagraphStyle(string styleName, string fontName, int fontSize, int fontStyle, BaseColor fontColor);
    public RtfParagraphStyle(string styleName, string basedOnName);
    public RtfParagraphStyle(RtfDocument doc, RtfParagraphStyle style);
    public virtual void set_Size(float value);
    public virtual bool Equals(object obj);
    public int GetAlignment();
    public string GetBasedOnName();
    public int GetFirstLineIndent();
    public virtual int GetHashCode();
    public int GetIndentLeft();
    public int GetIndentRight();
    public bool GetKeepTogether();
    public bool GetKeepTogetherWithNext();
    public int GetLineLeading();
    public int GetSpacingAfter();
    public int GetSpacingBefore();
    public string GetStyleName();
    public void HandleInheritance();
    public void SetAlignment(int alignment);
    public void SetColor(BaseColor color);
    public void SetFirstLineIndent(int firstLineIndent);
    public virtual void SetFontName(string fontName);
    public void SetIndentLeft(int indentLeft);
    public void SetIndentRight(int indentRight);
    public void SetKeepTogether(bool keepTogether);
    public void SetKeepTogetherWithNext(bool keepTogetherWithNext);
    public void SetLineLeading(int lineLeading);
    public void SetSpacingAfter(int spacingAfter);
    public void SetSpacingBefore(int spacingBefore);
    public virtual void SetStyle(int style);
    public virtual void WriteBegin(Stream result);
    public virtual void WriteContent(Stream outp);
    public virtual void WriteDefinition(Stream outp);
    public virtual void WriteEnd(Stream result);
    protected internal void SetStyleNumber(int styleNumber);
    private int getStyleNumber();
    private void writeParagraphSettings(Stream result);
}
public class iTextSharp.text.rtf.style.RtfStylesheetList : RtfElement {
    private NullValueDictionary`2<string, RtfParagraphStyle> _styleMap;
    private bool _defaultsLoaded;
    public RtfStylesheetList(RtfDocument doc);
    public virtual void WriteContent(Stream outp);
    public virtual void WriteDefinition(Stream outp);
    public RtfParagraphStyle GetRtfParagraphStyle(string styleName);
    public void RegisterParagraphStyle(RtfParagraphStyle rtfParagraphStyle);
    private void registerDefaultStyles();
}
public class iTextSharp.text.rtf.style.RtfStyleTypes : object {
    public static int PARAGRAPH;
    public static int CHARACTER;
    public static int SECTION;
    public static int TABLE;
    public static int TABLE_STYLE_DEFINITION;
}
public class iTextSharp.text.rtf.table.RtfBorder : RtfElement {
    public static int BORDER_DASHED;
    public static int BORDER_DOT_DASH;
    public static int BORDER_DOT_DOT_DASH;
    public static int BORDER_DOTTED;
    public static int BORDER_DOUBLE;
    public static int BORDER_DOUBLE_THICK;
    public static int BORDER_DOUBLE_WAVY;
    public static int BORDER_EMBOSS;
    public static int BORDER_ENGRAVE;
    public static int BORDER_HAIRLINE;
    public static int BORDER_NONE;
    public static int BORDER_SHADOWED;
    public static int BORDER_SINGLE;
    public static int BORDER_STRIPED;
    public static int BORDER_THICK_THIN;
    public static int BORDER_THICK_THIN_LARGE;
    public static int BORDER_THICK_THIN_MED;
    public static int BORDER_THIN_THICK;
    public static int BORDER_THIN_THICK_LARGE;
    public static int BORDER_THIN_THICK_MED;
    public static int BORDER_THIN_THICK_THIN;
    public static int BORDER_THIN_THICK_THIN_LARGE;
    public static int BORDER_THIN_THICK_THIN_MED;
    public static int BORDER_TRIPLE;
    public static int BORDER_WAVY;
    protected internal static int BOTTOM_BORDER;
    protected internal static int BOX_BORDER;
    protected internal static int CELL_BORDER;
    protected internal static int HORIZONTAL_BORDER;
    protected internal static int LEFT_BORDER;
    protected internal static int NO_BORDER;
    protected internal static int RIGHT_BORDER;
    protected internal static int ROW_BORDER;
    protected internal static int TOP_BORDER;
    protected internal static int VERTICAL_BORDER;
    protected internal static Byte[] BorderColorNumber;
    protected internal static Byte[] BorderStyleDashed;
    protected internal static Byte[] BorderStyleDotDash;
    protected internal static Byte[] BorderStyleDotDotDash;
    protected internal static Byte[] BorderStyleDotted;
    protected internal static Byte[] BorderStyleDouble;
    protected internal static Byte[] BorderStyleDoubleThick;
    protected internal static Byte[] BorderStyleDoubleWavy;
    protected internal static Byte[] BorderStyleEmboss;
    protected internal static Byte[] BorderStyleEngrave;
    protected internal static Byte[] BorderStyleHairline;
    protected internal static Byte[] BorderStyleShadowed;
    protected internal static Byte[] BorderStyleSingle;
    protected internal static Byte[] BorderStyleStriped;
    protected internal static Byte[] BorderStyleThickThin;
    protected internal static Byte[] BorderStyleThickThinLarge;
    protected internal static Byte[] BorderStyleThickThinMed;
    protected internal static Byte[] BorderStyleThinThick;
    protected internal static Byte[] BorderStyleThinThickLarge;
    protected internal static Byte[] BorderStyleThinThickMed;
    protected internal static Byte[] BorderStyleThinThickThin;
    protected internal static Byte[] BorderStyleThinThickThinLarge;
    protected internal static Byte[] BorderStyleThinThickThinMed;
    protected internal static Byte[] BorderStyleTriple;
    protected internal static Byte[] BorderStyleWavy;
    protected internal static Byte[] BorderWidth;
    protected internal static Byte[] CellBorderBottom;
    protected internal static Byte[] CellBorderLeft;
    protected internal static Byte[] CellBorderRight;
    protected internal static Byte[] CellBorderTop;
    protected internal static Byte[] RowBorderBottom;
    protected internal static Byte[] RowBorderHorizontal;
    protected internal static Byte[] RowBorderLeft;
    protected internal static Byte[] RowBorderRight;
    protected internal static Byte[] RowBorderTop;
    protected internal static Byte[] RowBorderVertical;
    private RtfColor _borderColor;
    private int _borderPosition;
    private int _borderStyle;
    private int _borderType;
    private int _borderWidth;
    protected internal RtfBorder(RtfDocument doc, int borderType, RtfBorder border);
    protected internal RtfBorder(RtfDocument doc, int borderType, int borderPosition, int borderStyle, float borderWidth, BaseColor borderColor);
    private static RtfBorder();
    public virtual void WriteContent(Stream outp);
    protected RtfColor GetBorderColor();
    protected int GetBorderPosition();
    protected int GetBorderStyle();
    protected int GetBorderType();
    protected int GetBorderWidth();
    private Byte[] writeBorderStyle();
}
public class iTextSharp.text.rtf.table.RtfBorderGroup : RtfElement {
    private NullValueDictionary`2<int, RtfBorder> _borders;
    private int _borderType;
    public RtfBorderGroup(int bordersToAdd, int borderStyle, float borderWidth, BaseColor borderColor);
    protected internal RtfBorderGroup(RtfDocument doc, int borderType, RtfBorderGroup borderGroup);
    protected internal RtfBorderGroup(RtfDocument doc, int borderType, int bordersToUse, float borderWidth, BaseColor borderColor);
    public void AddBorder(int bordersToAdd, int borderStyle, float borderWidth, BaseColor borderColor);
    public void RemoveBorder(int bordersToRemove);
    public virtual void WriteContent(Stream outp);
    protected internal INullValueDictionary`2<int, RtfBorder> GetBorders();
    private void setBorder(int borderPosition, int borderStyle, float borderWidth, BaseColor borderColor);
}
public class iTextSharp.text.rtf.table.RtfCell : Cell {
    private static int MergeNone;
    private static int MergeVertChild;
    private static int MergeVertParent;
    private bool _deleted;
    private RtfRow _parentRow;
    private RtfColor _backgroundColor;
    private RtfBorderGroup _borders;
    private int _cellPadding;
    private float _cellPaddingBottom;
    private float _cellPaddingLeft;
    private float _cellPaddingRight;
    private float _cellPaddingTop;
    private int _cellRight;
    private int _cellWidth;
    private List`1<IRtfBasicElement> _content;
    private RtfDocument _document;
    private bool _inHeader;
    private int _mergeType;
    public RtfCell(string content);
    public RtfCell(IElement element);
    protected internal RtfCell(bool deleted);
    protected internal RtfCell(RtfDocument doc, RtfRow row, Cell cell);
    protected internal RtfCell(RtfDocument doc, RtfRow row, PdfPCell cell);
    public sealed virtual void SetInHeader(bool inHeader);
    public sealed virtual void SetInTable(bool inTable);
    public sealed virtual void SetRtfDocument(RtfDocument doc);
    public virtual void WriteContent(Stream outp);
    public virtual void WriteDefinition(Stream outp);
    public bool IsDeleted();
    public bool IsInHeader();
    public void SetBorders(RtfBorderGroup borderGroup);
    protected internal RtfBorderGroup GetBorders();
    protected internal int GetCellpadding();
    protected internal int GetCellRight();
    protected internal int GetCellWidth();
    protected internal RtfColor GetRtfBackgroundColor();
    protected internal void SetCellMergeChild(RtfCell mergeParent);
    protected internal void SetCellRight(int cellRight);
    protected internal void SetCellWidth(int cellWidth);
    private void importCell(Cell cell);
    private void importCell(PdfPCell cell);
    private static Byte[] intToByteArray(int i);
}
public class iTextSharp.text.rtf.table.RtfRow : RtfElement {
    private static Byte[] _rowAlignCenter;
    private static Byte[] _rowAlignJustified;
    private static Byte[] _rowAlignLeft;
    private static Byte[] _rowAlignRight;
    private static Byte[] _rowBegin;
    private static Byte[] _rowCellPaddingLeft;
    private static Byte[] _rowCellPaddingLeftStyle;
    private static Byte[] _rowCellPaddingRight;
    private static Byte[] _rowCellPaddingRightStyle;
    private static Byte[] _rowCellSpacingBottom;
    private static Byte[] _rowCellSpacingBottomStyle;
    private static Byte[] _rowCellSpacingLeft;
    private static Byte[] _rowCellSpacingLeftStyle;
    private static Byte[] _rowCellSpacingRight;
    private static Byte[] _rowCellSpacingRightStyle;
    private static Byte[] _rowCellSpacingTop;
    private static Byte[] _rowCellSpacingTopStyle;
    private static Byte[] _rowEnd;
    private static Byte[] _rowGraph;
    private static Byte[] _rowHeaderRow;
    private static Byte[] _rowKeepTogether;
    private static Byte[] _rowWidth;
    private static Byte[] _rowWidthStyle;
    private RtfTable _parentTable;
    private int _rowNumber;
    private List`1<RtfCell> _cells;
    private int _width;
    protected internal RtfRow(RtfDocument doc, RtfTable rtfTable, Row row, int rowNumber);
    protected internal RtfRow(RtfDocument doc, RtfTable rtfTable, PdfPRow row, int rowNumber);
    private static RtfRow();
    public virtual void WriteContent(Stream outp);
    protected internal void CleanRow();
    protected internal IList`1<RtfCell> GetCells();
    protected internal RtfTable GetParentTable();
    protected internal void HandleCellSpanning();
    private void importRow(Row row);
    private void importRow(PdfPRow row);
    private void writeRowDefinition(Stream result);
}
public class iTextSharp.text.rtf.table.RtfTable : RtfElement {
    private int _alignment;
    private RtfBorderGroup _borders;
    private float _cellPadding;
    private bool _cellsFitToPage;
    private float _cellSpacing;
    private int _headerRows;
    private int _offset;
    private Single[] _proportionalWidths;
    private List`1<RtfElement> _rows;
    private bool _tableFitToPage;
    private float _tableWidthPercent;
    public RtfTable(RtfDocument doc, Table table);
    public RtfTable(RtfDocument doc, PdfPTable table);
    public virtual void WriteContent(Stream outp);
    protected internal int GetAlignment();
    protected internal RtfBorderGroup GetBorders();
    protected internal float GetCellPadding();
    protected internal bool GetCellsFitToPage();
    protected internal float GetCellSpacing();
    protected internal int GetHeaderRows();
    protected internal Single[] GetProportionalWidths();
    protected internal IList`1<RtfElement> GetRows();
    protected internal bool GetTableFitToPage();
    protected internal float GetTableWidthPercent();
    private void importTable(Table table);
    private void importTable(PdfPTable table);
}
public class iTextSharp.text.rtf.text.RtfAnnotation : RtfElement {
    private static Byte[] _annotation;
    private static Byte[] _annotationAuthor;
    private static Byte[] _annotationId;
    private string _content;
    private string _title;
    public RtfAnnotation(RtfDocument doc, Annotation annotation);
    private static RtfAnnotation();
    public virtual void WriteContent(Stream outp);
}
public class iTextSharp.text.rtf.text.RtfChapter : RtfSection {
    public RtfChapter(RtfDocument doc, Chapter chapter);
    public virtual void WriteContent(Stream outp);
}
public class iTextSharp.text.rtf.text.RtfChunk : RtfElement {
    private static Byte[] _fontSubscript;
    private static Byte[] _fontSuperscript;
    private static Byte[] _fontEndSuperSubscript;
    private static Byte[] _backgroundColor;
    private RtfColor _background;
    private string _content;
    private RtfFont _font;
    private float _superSubScript;
    private bool _softLineBreaks;
    public RtfChunk(RtfDocument doc, Chunk chunk);
    private static RtfChunk();
    public virtual void WriteContent(Stream outp);
    public virtual void SetRtfDocument(RtfDocument doc);
    public void SetSoftLineBreaks(bool softLineBreaks);
    public bool GetSoftLineBreaks();
}
public class iTextSharp.text.rtf.text.RtfNewPage : RtfElement {
    public static Byte[] NewPage;
    public RtfNewPage(RtfDocument doc);
    private static RtfNewPage();
    public virtual void WriteContent(Stream outp);
}
public class iTextSharp.text.rtf.text.RtfParagraph : RtfPhrase {
    public static Byte[] Paragraph;
    protected RtfParagraphStyle ParagraphStyle;
    public RtfParagraph(RtfDocument doc, Paragraph paragraph);
    private static RtfParagraph();
    public int GetIndentLeft();
    public int GetIndentRight();
    public void SetIndentLeft(int indentLeft);
    public void SetIndentRight(int indentRight);
    public void SetKeepTogetherWithNext(bool keepTogetherWithNext);
    public virtual void WriteContent(Stream outp);
}
public class iTextSharp.text.rtf.text.RtfPhrase : RtfElement {
    public static Byte[] InTable;
    public static Byte[] LineSpacing;
    public static Byte[] ParagraphDefaults;
    public static Byte[] Plain;
    private int _lineLeading;
    protected List`1<IRtfBasicElement> Chunks;
    public RtfPhrase(RtfDocument doc, Phrase phrase);
    protected internal RtfPhrase(RtfDocument doc);
    private static RtfPhrase();
    public virtual void SetInHeader(bool inHeader);
    public virtual void SetInTable(bool inTable);
    public virtual void SetRtfDocument(RtfDocument doc);
    public virtual void WriteContent(Stream outp);
}
public class iTextSharp.text.rtf.text.RtfSection : RtfElement {
    protected List`1<IRtfBasicElement> Items;
    protected RtfParagraph Title;
    public RtfSection(RtfDocument doc, Section section);
    public virtual void SetInHeader(bool inHeader);
    public virtual void SetInTable(bool inTable);
    public virtual void WriteContent(Stream outp);
    private void updateIndentation(float indentLeft, float indentRight, float indentContent);
}
public class iTextSharp.text.rtf.text.RtfTab : RtfAddableElement {
    public static int TAB_CENTER_ALIGN;
    public static int TAB_DECIMAL_ALIGN;
    public static int TAB_LEFT_ALIGN;
    public static int TAB_RIGHT_ALIGN;
    private int _position;
    private int _type;
    public RtfTab(float position, int type);
    public virtual void WriteContent(Stream outp);
}
public class iTextSharp.text.rtf.text.RtfTabGroup : RtfAddableElement {
    private List`1<RtfTab> _tabs;
    public RtfTabGroup(IList`1<RtfTab> tabs);
    public void Add(RtfTab tab);
    public virtual void WriteContent(Stream outp);
}
public class iTextSharp.text.Section : List`1<IElement> {
    public static int NUMBERSTYLE_DOTTED;
    public static int NUMBERSTYLE_DOTTED_WITHOUT_FINAL_DOT;
    protected bool addedCompletely;
    protected bool bookmarkOpen;
    protected string bookmarkTitle;
    protected bool Complete;
    protected float indentation;
    protected float indentationLeft;
    protected float indentationRight;
    protected bool notAddedYet;
    protected int numberDepth;
    protected internal List`1<int> Numbers;
    protected int numberStyle;
    protected int Subsections;
    protected Paragraph title;
    protected bool triggerNewPage;
    public bool BookmarkOpen { get; public set; }
    unknown string BookmarkTitle {public set; }
    public int Depth { get; }
    public float Indentation { get; public set; }
    public float IndentationLeft { get; public set; }
    public float IndentationRight { get; public set; }
    public bool NotAddedYet { get; public set; }
    public int NumberDepth { get; public set; }
    public int NumberStyle { get; public set; }
    public Paragraph Title { get; public set; }
    public bool TriggerNewPage { get; public set; }
    protected bool AddedCompletely { get; protected set; }
    public bool ElementComplete { get; public set; }
    public IList`1<Chunk> Chunks { get; }
    public int Type { get; }
    protected internal Section(Paragraph title, int numberDepth);
    public bool get_BookmarkOpen();
    public void set_BookmarkOpen(bool value);
    public void set_BookmarkTitle(string value);
    public int get_Depth();
    public float get_Indentation();
    public void set_Indentation(float value);
    public float get_IndentationLeft();
    public void set_IndentationLeft(float value);
    public float get_IndentationRight();
    public void set_IndentationRight(float value);
    public bool get_NotAddedYet();
    public void set_NotAddedYet(bool value);
    public int get_NumberDepth();
    public void set_NumberDepth(int value);
    public void set_NumberStyle(int value);
    public int get_NumberStyle();
    public Paragraph get_Title();
    public void set_Title(Paragraph value);
    public virtual bool get_TriggerNewPage();
    public virtual void set_TriggerNewPage(bool value);
    protected bool get_AddedCompletely();
    protected void set_AddedCompletely(bool value);
    public sealed virtual bool get_ElementComplete();
    public sealed virtual void set_ElementComplete(bool value);
    public sealed virtual void FlushContent();
    public sealed virtual IList`1<Chunk> get_Chunks();
    public virtual int get_Type();
    public sealed virtual bool Add(IElement o);
    public sealed virtual bool IsContent();
    public virtual bool IsNestable();
    public sealed virtual bool Process(IElementListener listener);
    public static Paragraph ConstructTitle(Paragraph title, IList`1<int> numbers, int numberDepth, int numberStyle);
    public static bool IsTag(string tag);
    public static bool IsTitle(string tag);
    public void Add(int index, object o);
    public bool AddAll(ICollection`1<T> collection);
    public MarkedSection AddMarkedSection();
    public virtual Section AddSection(float indentation, Paragraph title, int numberDepth);
    public virtual Section AddSection(float indentation, Paragraph title);
    public virtual Section AddSection(Paragraph title, int numberDepth);
    public virtual Section AddSection(Paragraph title);
    public virtual Section AddSection(float indentation, string title, int numberDepth);
    public virtual Section AddSection(string title, int numberDepth);
    public virtual Section AddSection(float indentation, string title);
    public virtual Section AddSection(string title);
    public Paragraph GetBookmarkTitle();
    public bool IsChapter();
    public bool IsSection();
    public void NewPage();
    public void Set(Properties attributes);
    public void SetChapterNumber(int number);
    private void setNumbers(int number, IList`1<int> numbers);
}
public class iTextSharp.text.SimpleCell : Rectangle {
    public static bool CELL;
    public static bool ROW;
    private List`1<IElement> _content;
    private bool _cellgroup;
    private int _colspan;
    private int _horizontalAlignment;
    private float _paddingBottom;
    private float _width;
    private float _widthpercentage;
    protected bool useAscender;
    protected bool useBorderPadding;
    protected bool useDescender;
    [CompilerGeneratedAttribute]
private float <PaddingLeft>k__BackingField;
    [CompilerGeneratedAttribute]
private float <PaddingRight>k__BackingField;
    [CompilerGeneratedAttribute]
private float <PaddingTop>k__BackingField;
    [CompilerGeneratedAttribute]
private float <SpacingBottom>k__BackingField;
    [CompilerGeneratedAttribute]
private float <SpacingLeft>k__BackingField;
    [CompilerGeneratedAttribute]
private float <SpacingRight>k__BackingField;
    [CompilerGeneratedAttribute]
private float <SpacingTop>k__BackingField;
    [CompilerGeneratedAttribute]
private int <VerticalAlignment>k__BackingField;
    public bool Cellgroup { get; public set; }
    public int Colspan { get; public set; }
    public int HorizontalAlignment { get; public set; }
    unknown float Padding {public set; }
    public float PaddingBottom { get; public set; }
    public float PaddingLeft { get; public set; }
    public float PaddingRight { get; public set; }
    public float PaddingTop { get; public set; }
    unknown float Spacing {public set; }
    public float SpacingBottom { get; public set; }
    public float SpacingLeft { get; public set; }
    public float SpacingRight { get; public set; }
    public float SpacingTop { get; public set; }
    public bool UseAscender { get; public set; }
    public bool UseBorderPadding { get; public set; }
    public bool UseDescender { get; public set; }
    public int VerticalAlignment { get; public set; }
    public float Width { get; public set; }
    public float Widthpercentage { get; public set; }
    internal IList`1<IElement> Content { get; }
    public int Type { get; }
    public SimpleCell(bool row);
    public bool get_Cellgroup();
    public void set_Cellgroup(bool value);
    public int get_Colspan();
    public void set_Colspan(int value);
    public int get_HorizontalAlignment();
    public void set_HorizontalAlignment(int value);
    public void set_Padding(float value);
    public float get_PaddingBottom();
    public void set_PaddingBottom(float value);
    [CompilerGeneratedAttribute]
public float get_PaddingLeft();
    [CompilerGeneratedAttribute]
public void set_PaddingLeft(float value);
    [CompilerGeneratedAttribute]
public float get_PaddingRight();
    [CompilerGeneratedAttribute]
public void set_PaddingRight(float value);
    [CompilerGeneratedAttribute]
public float get_PaddingTop();
    [CompilerGeneratedAttribute]
public void set_PaddingTop(float value);
    public void set_Spacing(float value);
    [CompilerGeneratedAttribute]
public float get_SpacingBottom();
    [CompilerGeneratedAttribute]
public void set_SpacingBottom(float value);
    [CompilerGeneratedAttribute]
public float get_SpacingLeft();
    [CompilerGeneratedAttribute]
public void set_SpacingLeft(float value);
    [CompilerGeneratedAttribute]
public float get_SpacingRight();
    [CompilerGeneratedAttribute]
public void set_SpacingRight(float value);
    [CompilerGeneratedAttribute]
public float get_SpacingTop();
    [CompilerGeneratedAttribute]
public void set_SpacingTop(float value);
    public bool get_UseAscender();
    public void set_UseAscender(bool value);
    public bool get_UseBorderPadding();
    public void set_UseBorderPadding(bool value);
    public bool get_UseDescender();
    public void set_UseDescender(bool value);
    [CompilerGeneratedAttribute]
public int get_VerticalAlignment();
    [CompilerGeneratedAttribute]
public void set_VerticalAlignment(int value);
    public float get_Width();
    public void set_Width(float value);
    public float get_Widthpercentage();
    public void set_Widthpercentage(float value);
    internal IList`1<IElement> get_Content();
    public sealed virtual void CellLayout(PdfPCell cell, Rectangle position, PdfContentByte[] canvases);
    public virtual int get_Type();
    public sealed virtual bool Add(IElement o);
    public void AddElement(IElement element);
    public Cell CreateCell(SimpleCell rowAttributes);
    public PdfPCell CreatePdfPCell(SimpleCell rowAttributes);
}
public class iTextSharp.text.SimpleTable : Rectangle {
    private List`1<IElement> _content;
    private int _alignment;
    private float _cellpadding;
    private float _cellspacing;
    private float _width;
    private float _widthpercentage;
    public int Alignment { get; public set; }
    public float Cellpadding { get; public set; }
    public float Cellspacing { get; public set; }
    public float Width { get; public set; }
    public float Widthpercentage { get; public set; }
    public int Type { get; }
    public int get_Alignment();
    public void set_Alignment(int value);
    public float get_Cellpadding();
    public void set_Cellpadding(float value);
    public float get_Cellspacing();
    public void set_Cellspacing(float value);
    public virtual float get_Width();
    public virtual void set_Width(float value);
    public float get_Widthpercentage();
    public void set_Widthpercentage(float value);
    public sealed virtual void TableLayout(PdfPTable table, Single[][] widths, Single[] heights, int headerRows, int rowStart, PdfContentByte[] canvases);
    public virtual int get_Type();
    public sealed virtual bool Add(IElement o);
    public virtual bool IsNestable();
    public void AddElement(SimpleCell element);
    public PdfPTable CreatePdfPTable();
    public Table CreateTable();
}
public static class iTextSharp.text.SpecialSymbol : object {
    public static Chunk Get(char c, Font font);
    public static char GetCorrespondingSymbol(char c);
    public static int Index(string str);
}
public class iTextSharp.text.Table : Rectangle {
    private int _alignment;
    private float _cellpadding;
    private bool _cellsFitPage;
    private float _cellspacing;
    private int _columns;
    private Point _curPosition;
    private Cell _defaultCell;
    private int _lastHeaderRow;
    private bool _mTableInserted;
    private float _offset;
    private List`1<Row> _rows;
    private bool _tableFitsPage;
    private float _width;
    private Single[] _widths;
    protected internal bool autoFillEmptyCells;
    protected bool complete;
    protected bool notAddedYet;
    [CompilerGeneratedAttribute]
private bool <Convert2Pdfptable>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Locked>k__BackingField;
    public int Alignment { get; public set; }
    unknown bool AutoFillEmptyCells {public set; }
    public float Bottom { get; public set; }
    public float Cellpadding { get; public set; }
    public bool CellsFitPage { get; public set; }
    public float Cellspacing { get; public set; }
    public int Columns { get; }
    public bool Convert2Pdfptable { get; public set; }
    public Cell DefaultCell { get; public set; }
    unknown BaseColor DefaultCellBackgroundColor {public set; }
    unknown int DefaultCellBorder {public set; }
    unknown BaseColor DefaultCellBorderColor {public set; }
    unknown float DefaultCellBorderWidth {public set; }
    unknown float DefaultCellGrayFill {public set; }
    unknown int DefaultColspan {public set; }
    unknown int DefaultHorizontalAlignment {public set; }
    public Cell DefaultLayout { get; public set; }
    unknown int DefaultRowspan {public set; }
    unknown int DefaultVerticalAlignment {public set; }
    public Dimension Dimension { get; }
    public int LastHeaderRow { get; public set; }
    public float Left { get; public set; }
    public bool Locked { get; public set; }
    public int NextColumn { get; }
    public int NextRow { get; }
    public bool NotAddedYet { get; public set; }
    public float Offset { get; public set; }
    unknown float Padding {public set; }
    public Single[] ProportionalWidths { get; }
    public float Right { get; public set; }
    public int Size { get; }
    unknown float Spacing {public set; }
    public bool TableFitsPage { get; public set; }
    public float Top { get; public set; }
    public float Width { get; public set; }
    unknown Single[] Widths {public set; }
    unknown Point CurrentLocationToNextValidPosition {private set; }
    public bool ElementComplete { get; public set; }
    public int Type { get; }
    public Table(int columns);
    public Table(int columns, int rows);
    public int get_Alignment();
    public void set_Alignment(int value);
    public void set_AutoFillEmptyCells(bool value);
    public virtual float get_Bottom();
    public virtual void set_Bottom(float value);
    public float get_Cellpadding();
    public void set_Cellpadding(float value);
    public void set_CellsFitPage(bool value);
    public bool get_CellsFitPage();
    public float get_Cellspacing();
    public void set_Cellspacing(float value);
    public int get_Columns();
    [CompilerGeneratedAttribute]
public void set_Convert2Pdfptable(bool value);
    [CompilerGeneratedAttribute]
public bool get_Convert2Pdfptable();
    public void set_DefaultCell(Cell value);
    public Cell get_DefaultCell();
    public void set_DefaultCellBackgroundColor(BaseColor value);
    public void set_DefaultCellBorder(int value);
    public void set_DefaultCellBorderColor(BaseColor value);
    public void set_DefaultCellBorderWidth(float value);
    public void set_DefaultCellGrayFill(float value);
    public void set_DefaultColspan(int value);
    public void set_DefaultHorizontalAlignment(int value);
    public void set_DefaultLayout(Cell value);
    public Cell get_DefaultLayout();
    public void set_DefaultRowspan(int value);
    public void set_DefaultVerticalAlignment(int value);
    public Dimension get_Dimension();
    public void set_LastHeaderRow(int value);
    public int get_LastHeaderRow();
    public virtual float get_Left();
    public virtual void set_Left(float value);
    [CompilerGeneratedAttribute]
public bool get_Locked();
    [CompilerGeneratedAttribute]
public void set_Locked(bool value);
    public int get_NextColumn();
    public int get_NextRow();
    public bool get_NotAddedYet();
    public void set_NotAddedYet(bool value);
    public float get_Offset();
    public void set_Offset(float value);
    public void set_Padding(float value);
    public Single[] get_ProportionalWidths();
    public virtual float get_Right();
    public virtual void set_Right(float value);
    public int get_Size();
    public void set_Spacing(float value);
    public void set_TableFitsPage(bool value);
    public bool get_TableFitsPage();
    public virtual float get_Top();
    public virtual void set_Top(float value);
    public virtual float get_Width();
    public virtual void set_Width(float value);
    public void set_Widths(Single[] value);
    private void set_CurrentLocationToNextValidPosition(Point value);
    public sealed virtual bool get_ElementComplete();
    public sealed virtual void set_ElementComplete(bool value);
    public virtual int get_Type();
    public sealed virtual void FlushContent();
    public virtual bool IsNestable();
    public virtual bool Process(IElementListener listener);
    public void AddCell(Cell aCell, int row, int column);
    public void AddCell(Cell aCell, object aLocation);
    public void AddCell(Cell cell);
    public void AddCell(Phrase content);
    public void AddCell(Phrase content, Point location);
    public void AddCell(string content);
    public void AddCell(string content, Point location);
    public void AddColumns(int aColumns);
    public void Complete();
    public PdfPTable CreatePdfPTable();
    public void DeleteAllRows();
    public void DeleteColumn(int column);
    public bool DeleteLastRow();
    public bool DeleteRow(int row);
    public int EndHeaders();
    public virtual float GetBottom(float margin);
    public object GetElement(int row, int column);
    public Enumerator<Row> GetEnumerator();
    public virtual float GetLeft(float margin);
    public virtual float GetRight(float margin);
    public virtual float GetTop(float margin);
    public Single[] GetWidths(float left, float totalWidth);
    public void InsertTable(Table aTable);
    public void InsertTable(Table aTable, int row, int column);
    public void InsertTable(Table aTable, Point p);
    public void SetAlignment(string alignment);
    public void SetWidths(Int32[] widths);
    private void assumeTableDefaults(Cell aCell);
    private static void errorDimensions();
    private void fillEmptyMatrixCells();
    private bool isValidLocation(Cell aCell, Point aLocation);
    private void mergeInsertedTables();
    private void placeCell(List`1<Row> someRows, Cell aCell, Point aPosition);
}
public static class iTextSharp.text.Utilities : object {
    private static Byte[] _skipBuffer;
    private static Utilities();
    public static Object[][] AddToArray(Object[][] original, Object[] item);
    public static bool CheckTrueOrFalse(Properties attributes, string key);
    public static string ConvertFromUtf32(int codePoint);
    public static int ConvertToUtf32(char highSurrogate, char lowSurrogate);
    public static int ConvertToUtf32(Char[] text, int idx);
    public static int ConvertToUtf32(string text, int idx);
    public static ICollection`1<string> GetKeySet(Properties table);
    public static float InchesToMillimeters(float value);
    public static float InchesToPoints(float value);
    public static bool IsSurrogateHigh(char c);
    public static bool IsSurrogateLow(char c);
    public static bool IsSurrogatePair(string text, int idx);
    public static bool IsSurrogatePair(Char[] text, int idx);
    public static float MillimetersToInches(float value);
    public static float MillimetersToPoints(float value);
    public static float PointsToInches(float value);
    public static float PointsToMillimeters(float value);
    public static void Skip(Stream istr, int size);
    public static Uri ToUrl(string filename);
    public static string UnEscapeUrl(string src);
}
public abstract class iTextSharp.text.xml.ParserBase : object {
    public abstract virtual void Characters(string content, int start, int length);
    public abstract virtual void EndElement(string uri, string lname, string name);
    public void Parse(XmlDocument xDoc);
    public void Parse(XmlReader reader);
    public void Parse(string url);
    public abstract virtual void StartElement(string uri, string lname, string name, INullValueDictionary`2<string, string> attrs);
}
public static class iTextSharp.text.xml.simpleparser.EntitiesToSymbol : object {
    private static Dictionary`2<string, char> _map;
    private static EntitiesToSymbol();
    public static Chunk Get(string e, Font font);
    public static char GetCorrespondingSymbol(string name);
}
public static class iTextSharp.text.xml.simpleparser.EntitiesToUnicode : object {
    public static INullValueDictionary`2<string, char> Map;
    private static EntitiesToUnicode();
    public static char DecodeEntity(string name);
    public static string DecodeString(string s);
}
public static class iTextSharp.text.xml.simpleparser.IanaEncodings : object {
    private static NullValueDictionary`2<string, int> _map;
    private static IanaEncodings();
    public static int GetEncodingNumber(string name);
    public static Encoding GetEncodingEncoding(string name);
}
public interface iTextSharp.text.xml.simpleparser.ISimpleXmlDocHandler {
    public abstract virtual void StartElement(string tag, INullValueDictionary`2<string, string> h);
    public abstract virtual void EndElement(string tag);
    public abstract virtual void StartDocument();
    public abstract virtual void EndDocument();
    public abstract virtual void Text(string str);
}
public interface iTextSharp.text.xml.simpleparser.ISimpleXmlDocHandlerComment {
    public abstract virtual void Comment(string text);
}
public class iTextSharp.text.xml.simpleparser.SimpleXmlParser : object {
    private static int AttributeEqual;
    private static int AttributeKey;
    private static int AttributeValue;
    private static int Cdata;
    private static int Comment;
    private static int Entity;
    private static int ExaminTag;
    private static int InClosetag;
    private static int Pi;
    private static int Quote;
    private static int SingleTag;
    private static int TagEncountered;
    private static int TagExamined;
    private static int Text;
    private static int Unknown;
    internal string Attributekey;
    internal INullValueDictionary`2<string, string> Attributes;
    internal string Attributevalue;
    internal int Character;
    internal int Columns;
    internal ISimpleXmlDocHandlerComment comment;
    internal ISimpleXmlDocHandler Doc;
    internal StringBuilder entity;
    internal bool Eol;
    internal bool Html;
    internal int Lines;
    internal int Nested;
    internal bool Nowhite;
    internal int PreviousCharacter;
    internal int QuoteCharacter;
    internal Stack`1<int> Stack;
    internal int State;
    internal string Tag;
    internal StringBuilder text;
    private SimpleXmlParser(ISimpleXmlDocHandler doc, ISimpleXmlDocHandlerComment comment, bool html);
    public static string EscapeXml(string s, bool onlyAscii);
    public static void Parse(ISimpleXmlDocHandler doc, ISimpleXmlDocHandlerComment comment, TextReader r, bool html);
    public static void Parse(ISimpleXmlDocHandler doc, Stream inp);
    public static void Parse(ISimpleXmlDocHandler doc, TextReader r);
    private static string getDeclaredEncoding(string decl);
    private static string getEncodingName(Byte[] b4);
    private void doTag();
    private void flush();
    private void go(TextReader reader);
    private void initTag();
    private void processTag(bool start);
    private int restoreState();
    private void saveState(int s);
    private void throwException(string s);
}
public class iTextSharp.text.xml.TagMap : NullValueDictionary`2<string, XmlPeer> {
    public TagMap(string tagfile);
    public TagMap(XmlDocument xTagfile);
    protected void Init(XmlDocument xTagfile);
    protected void Init(string tagfile);
}
public class iTextSharp.text.xml.TextHandler : ParserBase {
    private float _bottomMargin;
    private float _leftMargin;
    private float _rightMargin;
    private float _topMargin;
    protected int Chapters;
    protected bool ControlOpenClose;
    protected Chunk CurrentChunk;
    protected IDocListener Document;
    protected bool Ignore;
    protected NullValueDictionary`2<string, XmlPeer> MyTags;
    protected Stack`1<IElement> Stack;
    [CompilerGeneratedAttribute]
private BaseFont <DefaultFont>k__BackingField;
    public BaseFont DefaultFont { get; public set; }
    public TextHandler(IDocListener document);
    public TextHandler(IDocListener document, TagMap myTags);
    public TextHandler(IDocListener document, NullValueDictionary`2<string, XmlPeer> myTags);
    public TextHandler(IDocListener document, TagMap myTags, BaseFont bf);
    [CompilerGeneratedAttribute]
public void set_DefaultFont(BaseFont value);
    [CompilerGeneratedAttribute]
public BaseFont get_DefaultFont();
    public virtual void Characters(string content, int start, int length);
    public virtual void EndElement(string uri, string lname, string name);
    public void HandleEndingTags(string name);
    public void HandleStartingTags(string name, Properties attributes);
    public static void IgnorableWhitespace(Char[] ch, int start, int length);
    public void SetControlOpenClose(bool controlOpenClose);
    public virtual void StartElement(string uri, string lname, string name, INullValueDictionary`2<string, string> attrs);
    protected internal void AddImage(Image img);
    protected static bool IsDocumentRoot(string tag);
    private static bool isNewline(string tag);
    private static bool isNewpage(string tag);
}
public class iTextSharp.text.xml.TextmyHandler : TextHandler {
    public TextmyHandler(IDocListener document, TagMap myTags);
    public virtual void StartElement(string uri, string lname, string name, INullValueDictionary`2<string, string> attrs);
    public virtual void EndElement(string uri, string lname, string name);
}
public class iTextSharp.text.xml.XmlParser : object {
    protected TextHandler Parser;
    public static void Parse(IDocListener document, XmlDocument xDoc);
    public static void Parse(IDocListener document, string file);
    public static void Parse(IDocListener document, XmlReader reader);
    public static void Parse(IDocListener document, XmlDocument xDoc, XmlDocument xTagmap);
    public static void Parse(IDocListener document, string file, string tagmap);
    public static void Parse(IDocListener document, string file, TagMap tagmap);
    public static void Parse(IDocListener document, XmlReader reader, string tagmap);
    public static void Parse(IDocListener document, XmlReader reader, TagMap tagmap);
    public virtual void Go(IDocListener document, XmlDocument xDoc);
    public virtual void Go(IDocListener document, string file);
    public virtual void Go(IDocListener document, XmlReader reader);
    public virtual void Go(IDocListener document, XmlDocument xDoc, XmlDocument xTagmap);
    public virtual void Go(IDocListener document, XmlReader reader, string tagmap);
    public virtual void Go(IDocListener document, string file, string tagmap);
    public virtual void Go(IDocListener document, string file, TagMap tagmap);
    public virtual void Go(IDocListener document, XmlReader reader, TagMap tagmap);
}
public class iTextSharp.text.xml.XmlPeer : object {
    protected Properties AttributeAliases;
    protected Properties AttributeValues;
    protected string CustomTagname;
    protected string DefaultContent;
    protected string Tagname;
    public string Alias { get; }
    unknown string Content {public set; }
    public Properties DefaultValues { get; }
    public string Tag { get; }
    public XmlPeer(string name, string alias);
    public string get_Alias();
    public void set_Content(string value);
    public Properties get_DefaultValues();
    public string get_Tag();
    public virtual void AddAlias(string name, string attributeAlias);
    public void AddValue(string name, string value);
    public virtual Properties GetAttributes(INullValueDictionary`2<string, string> attrs);
    public string GetName(string name);
}
public class iTextSharp.text.xml.xmp.DublinCoreSchema : XmpSchema {
    public static string CONTRIBUTOR;
    public static string COVERAGE;
    public static string CREATOR;
    public static string DATE;
    public static string DEFAULT_XPATH_ID;
    public static string DEFAULT_XPATH_URI;
    public static string DESCRIPTION;
    public static string FORMAT;
    public static string IDENTIFIER;
    public static string LANGUAGE;
    public static string PUBLISHER;
    public static string RELATION;
    public static string RIGHTS;
    public static string SOURCE;
    public static string SUBJECT;
    public static string TITLE;
    public static string TYPE;
    public void AddAuthor(string author);
    public void AddAuthor(String[] author);
    public void AddDescription(string desc);
    public void AddPublisher(string publisher);
    public void AddPublisher(String[] publisher);
    public void addSubject(String[] subject);
    public void AddSubject(string subject);
    public void AddTitle(string title);
}
public class iTextSharp.text.xml.xmp.EncodingNoPreamble : Encoding {
    private static Byte[] _emptyPreamble;
    private Encoding _encoding;
    public int CodePage { get; }
    public string EncodingName { get; }
    public string WebName { get; }
    public EncodingNoPreamble(Encoding encoding);
    private static EncodingNoPreamble();
    public virtual int get_CodePage();
    public virtual string get_EncodingName();
    public virtual string get_WebName();
    public virtual int GetByteCount(Char[] chars, int index, int count);
    public virtual int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    public virtual int GetCharCount(Byte[] bytes, int index, int count);
    public virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex);
    public virtual Decoder GetDecoder();
    public virtual Encoder GetEncoder();
    public virtual int GetMaxByteCount(int charCount);
    public virtual int GetMaxCharCount(int byteCount);
    public virtual Byte[] GetPreamble();
}
public class iTextSharp.text.xml.xmp.LangAlt : Properties {
    public static string DEFAULT;
    public LangAlt(string defaultValue);
    public void AddLanguage(string language, string value);
    public virtual string ToString();
    protected internal void Process(StringBuilder buf, string lang);
}
public class iTextSharp.text.xml.xmp.PdfA1Schema : XmpSchema {
    public static string CONFORMANCE;
    public static string DEFAULT_XPATH_ID;
    public static string DEFAULT_XPATH_URI;
    public static string PART;
    public void AddConformance(string conformance);
    public void AddPart(string part);
}
public class iTextSharp.text.xml.xmp.PdfSchema : XmpSchema {
    public static string DEFAULT_XPATH_ID;
    public static string DEFAULT_XPATH_URI;
    public static string KEYWORDS;
    public static string PRODUCER;
    public static string VERSION;
    public void AddKeywords(string keywords);
    public void AddProducer(string producer);
    public void AddVersion(string version);
}
public class iTextSharp.text.xml.xmp.XmpArray : List`1<string> {
    public static string ALTERNATIVE;
    public static string ORDERED;
    public static string UNORDERED;
    protected string Type;
    public XmpArray(string type);
    public virtual string ToString();
}
public class iTextSharp.text.xml.xmp.XmpBasicSchema : XmpSchema {
    public static string ADVISORY;
    public static string BASEURL;
    public static string CREATEDATE;
    public static string CREATORTOOL;
    public static string DEFAULT_XPATH_ID;
    public static string DEFAULT_XPATH_URI;
    public static string IDENTIFIER;
    public static string METADATADATE;
    public static string MODIFYDATE;
    public static string NICKNAME;
    public static string THUMBNAILS;
    public void AddCreateDate(string date);
    public void AddCreatorTool(string creator);
    public void AddIdentifiers(String[] id);
    public void AddMetaDataDate(string date);
    public void AddModDate(string date);
    public void AddNickname(string name);
}
public class iTextSharp.text.xml.xmp.XmpMmSchema : XmpSchema {
    public static string DEFAULT_XPATH_ID;
    public static string DEFAULT_XPATH_URI;
    public static string DERIVEDFROM;
    public static string DOCUMENTID;
    public static string HISTORY;
    public static string MANAGEDFROM;
    public static string MANAGER;
    public static string MANAGERVARIANT;
    public static string MANAGETO;
    public static string MANAGEUI;
    public static string RENDITIONCLASS;
    public static string RENDITIONPARAMS;
    public static string VERSIONID;
    public static string VERSIONS;
}
public class iTextSharp.text.xml.xmp.XmpReader : object {
    private XmlDocument _domDocument;
    public XmpReader(Byte[] bytes);
    public bool Add(string parent, string namespaceUri, string localName, string value);
    public bool Replace(string namespaceUri, string localName, string value);
    public Byte[] SerializeDoc();
    public static bool SetNodeText(XmlDocument domDocument, XmlNode n, string value);
}
[DefaultMemberAttribute("Item")]
public abstract class iTextSharp.text.xml.xmp.XmpSchema : Properties {
    protected string xmlns;
    public string Xmlns { get; }
    unknown string Item {public set; }
    protected XmpSchema(string xmlns);
    public string get_Xmlns();
    public virtual void set_Item(string key, string value);
    public static string Escape(string content);
    public void AddProperty(string key, string value);
    public void SetProperty(string key, XmpArray value);
    public void SetProperty(string key, LangAlt value);
    public virtual string ToString();
    protected void Process(StringBuilder buf, object p);
}
public class iTextSharp.text.xml.xmp.XmpWriter : object {
    public static string EXTRASPACE;
    public static string UTF16;
    public static string UTF16BE;
    public static string UTF16LE;
    public static string UTF8;
    public static string XPACKET_PI_BEGIN;
    public static string XPACKET_PI_END_R;
    public static string XPACKET_PI_END_W;
    protected string about;
    protected char End;
    protected int ExtraSpace;
    protected StreamWriter Writer;
    unknown string About {public set; }
    public XmpWriter(Stream os, string utfEncoding, int extraSpace);
    public XmpWriter(Stream os);
    public XmpWriter(Stream os, PdfDictionary info, int pdfXConformance);
    public XmpWriter(Stream os, INullValueDictionary`2<string, string> info);
    public void set_About(string value);
    public void AddRdfDescription(string xmlns, string content);
    public void AddRdfDescription(XmpSchema s);
    public void Close();
    public void SetReadOnly();
}
public class iTextSharp.text.ZapfDingbatsList : List {
    protected int Zn;
    public int CharNumber { get; public set; }
    public ZapfDingbatsList(int zn);
    public ZapfDingbatsList(int zn, int symbolIndent);
    public void set_CharNumber(int value);
    public int get_CharNumber();
    public virtual bool Add(IElement o);
}
public class iTextSharp.text.ZapfDingbatsNumberList : List {
    protected int type;
    public int NumberType { get; public set; }
    public ZapfDingbatsNumberList(int type);
    public ZapfDingbatsNumberList(int type, int symbolIndent);
    public int get_NumberType();
    public void set_NumberType(int value);
    public virtual bool Add(IElement o);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
public class System.Drawing.Dimension : Dimension2D {
    [CompilerGeneratedAttribute]
private int <height>k__BackingField;
    [CompilerGeneratedAttribute]
private int <width>k__BackingField;
    public int height { get; public set; }
    public int width { get; public set; }
    public double Height { get; }
    public Dimension Size { get; public set; }
    public double Width { get; }
    public Dimension(Dimension d);
    public Dimension(int width, int height);
    [CompilerGeneratedAttribute]
public void set_height(int value);
    [CompilerGeneratedAttribute]
public int get_height();
    [CompilerGeneratedAttribute]
public void set_width(int value);
    [CompilerGeneratedAttribute]
public int get_width();
    public virtual double get_Height();
    public Dimension get_Size();
    public void set_Size(Dimension value);
    public virtual double get_Width();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual void SetSize(double width, double height);
    public void SetSize(int width, int height);
    public virtual string ToString();
}
public abstract class System.Drawing.Dimension2D : object {
    public double Height { get; }
    unknown Dimension2D Size {public set; }
    public double Width { get; }
    public abstract virtual double get_Height();
    public void set_Size(Dimension2D value);
    public abstract virtual double get_Width();
    public sealed virtual object Clone();
    public abstract virtual void SetSize(double width, double height);
}
internal static class System.IO.StreamHelpers : object {
    public static void ValidateCopyToArgs(Stream source, Stream destination, int bufferSize);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
[DefaultMemberAttribute("Item")]
public class System.util.collections.OrderedTree : object {
    private OrderedTreeNode _sentinelNode;
    private int _intCount;
    private OrderedTreeNode _lastNodeFound;
    private OrderedTreeNode _rbTree;
    public object Item { get; public set; }
    public OrderedTreeEnumerator Keys { get; }
    public OrderedTreeEnumerator Values { get; }
    public int Count { get; }
    public object get_Item(IComparable key);
    public void set_Item(IComparable key, object value);
    public virtual OrderedTreeEnumerator get_Keys();
    public virtual OrderedTreeEnumerator get_Values();
    public virtual int get_Count();
    public virtual void Add(IComparable key, object data);
    private void RestoreAfterInsert(OrderedTreeNode x);
    public virtual void RotateLeft(OrderedTreeNode x);
    public virtual void RotateRight(OrderedTreeNode x);
    public virtual bool ContainsKey(IComparable key);
    public virtual object GetData(IComparable key);
    public virtual IComparable GetMinKey();
    public virtual IComparable GetMaxKey();
    public virtual object GetMinValue();
    public virtual object GetMaxValue();
    public virtual OrderedTreeEnumerator GetEnumerator();
    public virtual OrderedTreeEnumerator KeyElements(bool ascending);
    public virtual OrderedTreeEnumerator Elements();
    public virtual OrderedTreeEnumerator Elements(bool ascending);
    public virtual bool IsEmpty();
    public virtual void Remove(IComparable key);
    private void Delete(OrderedTreeNode z);
    private void RestoreAfterDelete(OrderedTreeNode x);
    public virtual void RemoveMin();
    public virtual void RemoveMax();
    public virtual void Clear();
}
public class System.util.collections.OrderedTreeEnumerator : object {
    private bool _ascending;
    private bool _keys;
    private OrderedTreeNode _sentinelNode;
    private Stack`1<OrderedTreeNode> _stack;
    private bool _pre;
    private OrderedTreeNode _tNode;
    [CompilerGeneratedAttribute]
private IComparable <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    public IComparable Key { get; public set; }
    public object Value { get; public set; }
    public object Current { get; }
    public OrderedTreeEnumerator(OrderedTreeNode tNode, bool keys, bool ascending, OrderedTreeNode sentinelNode);
    [CompilerGeneratedAttribute]
public virtual IComparable get_Key();
    [CompilerGeneratedAttribute]
public virtual void set_Key(IComparable value);
    [CompilerGeneratedAttribute]
public virtual object get_Value();
    [CompilerGeneratedAttribute]
public virtual void set_Value(object value);
    public virtual void Reset();
    public virtual object get_Current();
    public virtual bool MoveNext();
    public sealed virtual void Dispose();
    public virtual bool HasMoreElements();
    public virtual object NextElement();
    public virtual OrderedTreeEnumerator GetEnumerator();
}
public class System.util.collections.OrderedTreeNode : object {
    public static bool RED;
    public static bool BLACK;
    [CompilerGeneratedAttribute]
private IComparable <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Data>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Color>k__BackingField;
    [CompilerGeneratedAttribute]
private OrderedTreeNode <Left>k__BackingField;
    [CompilerGeneratedAttribute]
private OrderedTreeNode <Right>k__BackingField;
    [CompilerGeneratedAttribute]
private OrderedTreeNode <Parent>k__BackingField;
    public IComparable Key { get; public set; }
    public object Data { get; public set; }
    public bool Color { get; public set; }
    public OrderedTreeNode Left { get; public set; }
    public OrderedTreeNode Right { get; public set; }
    public OrderedTreeNode Parent { get; public set; }
    [CompilerGeneratedAttribute]
public virtual IComparable get_Key();
    [CompilerGeneratedAttribute]
public virtual void set_Key(IComparable value);
    [CompilerGeneratedAttribute]
public virtual object get_Data();
    [CompilerGeneratedAttribute]
public virtual void set_Data(object value);
    [CompilerGeneratedAttribute]
public virtual bool get_Color();
    [CompilerGeneratedAttribute]
public virtual void set_Color(bool value);
    [CompilerGeneratedAttribute]
public virtual OrderedTreeNode get_Left();
    [CompilerGeneratedAttribute]
public virtual void set_Left(OrderedTreeNode value);
    [CompilerGeneratedAttribute]
public virtual OrderedTreeNode get_Right();
    [CompilerGeneratedAttribute]
public virtual void set_Right(OrderedTreeNode value);
    [CompilerGeneratedAttribute]
public virtual OrderedTreeNode get_Parent();
    [CompilerGeneratedAttribute]
public virtual void set_Parent(OrderedTreeNode value);
}
[DefaultMemberAttribute("Item")]
public interface System.util.INullValueDictionary`2 {
    public TValue Item { get; public set; }
    public abstract virtual TValue get_Item(TKey key);
    public abstract virtual void set_Item(TKey key, TValue value);
    public abstract virtual INullValueDictionary`2<TKey, TValue> Clone();
}
public class System.util.ListIterator`1 : object {
    private IList`1<T> _col;
    private int _cursor;
    private int _lastRet;
    public ListIterator`1(IList`1<T> col);
    public bool HasNext();
    public T Next();
    public T Previous();
    public void Remove();
}
[DefaultMemberAttribute("Item")]
public class System.util.NullValueDictionary`2 : Dictionary`2<TKey, TValue> {
    public int Size { get; }
    public TValue Item { get; public set; }
    public NullValueDictionary`2(int capacity);
    public NullValueDictionary`2(IDictionary`2<TKey, TValue> dictionary);
    public int get_Size();
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    public sealed virtual INullValueDictionary`2<TKey, TValue> Clone();
    public IList`1<TKey> ToOrderedKeys();
    public IList`1<TKey> GetKeys();
    public bool IsEmpty();
}
[DefaultMemberAttribute("Item")]
public class System.util.Properties : object {
    private static string KeyValueSeparators;
    private static string StrictKeyValueSeparators;
    private static string WhiteSpaceChars;
    private INullValueDictionary`2<string, string> _col;
    public int Count { get; }
    public ICollection`1<string> Keys { get; }
    public string Item { get; public set; }
    public int get_Count();
    public ICollection`1<string> get_Keys();
    public virtual string get_Item(string key);
    public virtual void set_Item(string key, string value);
    public virtual void Add(string key, string value);
    public void AddAll(Properties col);
    public void Clear();
    public bool ContainsKey(string key);
    public IEnumerator`1<KeyValuePair`2<string, string>> GetEnumerator();
    public void Load(Stream inStream);
    public string Remove(string key);
    private static bool continueLine(string line);
    private static string loadConvert(string theString);
}
[ExtensionAttribute]
public static class System.util.RealExtensions : object {
    private static double Epsilon;
    [ExtensionAttribute]
public static bool ApproxEquals(double d1, double d2);
    [ExtensionAttribute]
public static bool ApproxEquals(float d1, float d2);
    [ExtensionAttribute]
public static bool ApproxGreaterEqual(double a, double b);
    [ExtensionAttribute]
public static bool ApproxGreaterEqual(float a, float b);
    [ExtensionAttribute]
public static bool ApproxGreaterThan(double a, double b);
    [ExtensionAttribute]
public static bool ApproxGreaterThan(float a, float b);
    [ExtensionAttribute]
public static bool ApproxLowerEqual(double a, double b);
    [ExtensionAttribute]
public static bool ApproxLowerEqual(float a, float b);
    [ExtensionAttribute]
public static bool ApproxLowerThan(double a, double b);
    [ExtensionAttribute]
public static bool ApproxLowerThan(float a, float b);
    [ExtensionAttribute]
public static bool ApproxNotEqual(double a, double b);
    [ExtensionAttribute]
public static bool ApproxNotEqual(float a, float b);
}
public class System.util.StringTokenizer : object {
    private int _len;
    private bool _retDelims;
    private string _str;
    private string _delim;
    private int _pos;
    public StringTokenizer(string str);
    public StringTokenizer(string str, string delim);
    public StringTokenizer(string str, string delim, bool retDelims);
    public int CountTokens();
    public bool HasMoreTokens();
    public string NextToken(string delim);
    public string NextToken();
}
[ExtensionAttribute]
public static class System.util.Util : object {
    [ExtensionAttribute]
public static void AddRange(IList`1<T> list, IEnumerable`1<T> items);
    public static int Usr(int op1, int op2);
    public static bool EqualsIgnoreCase(string s1, string s2);
    public static int CompareToIgnoreCase(string s1, string s2);
    [ExtensionAttribute]
public static Byte[] GetIsoBytes(string text);
    [ExtensionAttribute]
public static Byte[] CopyOfRange(Byte[] src, int start, int end);
    [ExtensionAttribute]
public static Byte[] CopyOf(Byte[] src, int newLength);
}
internal class System.util.zlib.Adler32 : object {
    private static int Base;
    private static int Nmax;
    internal static long adler32(long adler, Byte[] buf, int index, int len);
}
public class System.util.zlib.Deflate : object {
    private static int BlCodes;
    private static int BlockDone;
    private static int BufSize;
    private static int BusyState;
    private static int DCodes;
    private static int DefMemLevel;
    private static int DynTrees;
    private static int EndBlock;
    private static int Fast;
    private static int FinishDone;
    private static int FinishStarted;
    private static int FinishState;
    private static int HeapSize;
    private static int InitState;
    private static int LCodes;
    private static int LengthCodes;
    private static int Literals;
    private static int MaxBits;
    private static int MaxMatch;
    private static int MaxMemLevel;
    private static int MaxWbits;
    private static int MinLookahead;
    private static int MinMatch;
    private static int NeedMore;
    private static int PresetDict;
    private static int Rep36;
    private static int Repz11138;
    private static int Repz310;
    private static int Slow;
    private static int StaticTrees;
    private static int Stored;
    private static int StoredBlock;
    private static int ZAscii;
    private static int ZBinary;
    private static int ZBufError;
    private static int ZDataError;
    private static int ZDefaultCompression;
    private static int ZDefaultStrategy;
    private static int ZDeflated;
    private static int ZErrno;
    private static int ZFiltered;
    private static int ZFinish;
    private static int ZFullFlush;
    private static int ZHuffmanOnly;
    private static int ZMemError;
    private static int ZNeedDict;
    private static int ZNoFlush;
    private static int ZOk;
    private static int ZPartialFlush;
    private static int ZStreamEnd;
    private static int ZStreamError;
    private static int ZSyncFlush;
    private static int ZUnknown;
    private static int ZVersionError;
    private static Config[] _configTable;
    private static String[] _zErrmsg;
    internal UInt32 BiBuf;
    internal int BiValid;
    internal Int16[] BlCount;
    internal Tree BlDesc;
    internal int BlockStart;
    internal Int16[] BlTree;
    internal byte DataType;
    internal int DBuf;
    internal Tree DDesc;
    internal Byte[] Depth;
    internal Int16[] DynDtree;
    internal Int16[] DynLtree;
    internal int GoodMatch;
    internal int HashBits;
    internal int HashMask;
    internal int HashShift;
    internal int HashSize;
    internal Int16[] Head;
    internal Int32[] Heap;
    internal int HeapLen;
    internal int HeapMax;
    internal int InsH;
    internal int LastEobLen;
    internal int LastFlush;
    internal int LastLit;
    internal int LBuf;
    internal Tree LDesc;
    internal int Level;
    internal int LitBufsize;
    internal int Lookahead;
    internal int MatchAvailable;
    internal int Matches;
    internal int MatchLength;
    internal int MatchStart;
    internal int MaxChainLength;
    internal int MaxLazyMatch;
    internal byte Method;
    internal int NiceMatch;
    internal int Noheader;
    internal int OptLen;
    internal int Pending;
    internal Byte[] PendingBuf;
    internal int PendingBufSize;
    internal int PendingOut;
    internal Int16[] Prev;
    internal int PrevLength;
    internal int PrevMatch;
    internal int StaticLen;
    internal int Status;
    internal int Strategy;
    internal ZStream Strm;
    internal int Strstart;
    internal int WBits;
    internal Byte[] Window;
    internal int WindowSize;
    internal int WMask;
    internal int WSize;
    private static Deflate();
    internal static bool Smaller(Int16[] tree, int n, int m, Byte[] depth);
    internal void _tr_align();
    internal void _tr_flush_block(int buf, int storedLen, bool eof);
    internal void _tr_stored_block(int buf, int storedLen, bool eof);
    internal bool _tr_tally(int dist, int lc);
    internal void bi_flush();
    internal void bi_windup();
    internal int build_bl_tree();
    internal void compress_block(Int16[] ltree, Int16[] dtree);
    internal void copy_block(int buf, int len, bool header);
    internal int deflate(ZStream strm, int flush);
    internal int deflate_fast(int flush);
    internal int deflate_slow(int flush);
    internal int deflate_stored(int flush);
    internal int DeflateEnd();
    internal int DeflateInit(ZStream strm, int level, int bits);
    internal int DeflateInit(ZStream strm, int level);
    internal int DeflateInit2(ZStream strm, int level, int method, int windowBits, int memLevel, int strategy);
    internal int DeflateParams(ZStream strm, int _level, int _strategy);
    internal int DeflateReset(ZStream strm);
    internal int DeflateSetDictionary(ZStream strm, Byte[] dictionary, int dictLength);
    internal void fill_window();
    internal void flush_block_only(bool eof);
    internal void init_block();
    internal void lm_init();
    internal int longest_match(int curMatch);
    internal void Pqdownheap(Int16[] tree, int k);
    internal void put_byte(Byte[] p, int start, int len);
    internal void put_byte(byte c);
    internal void put_short(int w);
    internal void PutShortMsb(int b);
    internal void scan_tree(Int16[] tree, int maxCode);
    internal void send_all_trees(int lcodes, int dcodes, int blcodes);
    internal void send_bits(int val, int length);
    internal void send_code(int c, Int16[] tree);
    internal void send_tree(Int16[] tree, int maxCode);
    internal void set_data_type();
    internal void tr_init();
}
internal class System.util.zlib.InfBlocks : object {
    private static int Bad;
    private static int Btree;
    private static int Codes;
    private static int Done;
    private static int Dry;
    private static int Dtree;
    private static int Lens;
    private static int Many;
    private static int Stored;
    private static int Table;
    private static int Type;
    private static int ZBufError;
    private static int ZDataError;
    private static int ZErrno;
    private static int ZMemError;
    private static int ZNeedDict;
    private static int ZOk;
    private static int ZStreamEnd;
    private static int ZStreamError;
    private static int ZVersionError;
    private static Int32[] _border;
    private static Int32[] _inflateMask;
    private int _last;
    internal Int32[] Bb;
    internal int Bitb;
    internal int Bitk;
    internal Int32[] Blens;
    internal long Check;
    internal object Checkfn;
    internal InfCodes codes;
    internal int End;
    internal Int32[] Hufts;
    internal int Index;
    internal InfTree Inftree;
    internal int Left;
    internal int Mode;
    internal int Read;
    internal int table;
    internal Int32[] Tb;
    internal Byte[] Window;
    internal int Write;
    internal InfBlocks(ZStream z, object checkfn, int w);
    private static InfBlocks();
    internal void Free(ZStream z);
    internal int inflate_flush(ZStream z, int r);
    internal int Proc(ZStream z, int r);
    internal void Reset(ZStream z, Int64[] c);
    internal void set_dictionary(Byte[] d, int start, int n);
    internal int sync_point();
}
internal class System.util.zlib.InfCodes : object {
    private static int Badcode;
    private static int Copy;
    private static int Dist;
    private static int Distext;
    private static int End;
    private static int Len;
    private static int Lenext;
    private static int Lit;
    private static int Start;
    private static int Wash;
    private static int ZBufError;
    private static int ZDataError;
    private static int ZErrno;
    private static int ZMemError;
    private static int ZNeedDict;
    private static int ZOk;
    private static int ZStreamEnd;
    private static int ZStreamError;
    private static int ZVersionError;
    private static Int32[] _inflateMask;
    private byte _dbits;
    private int _dist;
    private Int32[] _dtree;
    private int _dtreeIndex;
    private int _get;
    private byte _lbits;
    private int _len;
    private int _lit;
    private Int32[] _ltree;
    private int _ltreeIndex;
    private int _mode;
    private int _need;
    private Int32[] _tree;
    private int _treeIndex;
    private static InfCodes();
    internal static void Free(ZStream z);
    internal static int inflate_fast(int bl, int bd, Int32[] tl, int tlIndex, Int32[] td, int tdIndex, InfBlocks s, ZStream z);
    internal void Init(int bl, int bd, Int32[] tl, int tlIndex, Int32[] td, int tdIndex, ZStream z);
    internal int Proc(InfBlocks s, ZStream z, int r);
}
internal class System.util.zlib.Inflate : object {
    internal static int Z_FINISH;
    internal static int Z_FULL_FLUSH;
    internal static int Z_NO_FLUSH;
    internal static int Z_PARTIAL_FLUSH;
    internal static int Z_SYNC_FLUSH;
    private static int Bad;
    private static int Blocks;
    private static int Check1;
    private static int Check2;
    private static int Check3;
    private static int Check4;
    private static int Dict0;
    private static int Dict1;
    private static int Dict2;
    private static int Dict3;
    private static int Dict4;
    private static int Done;
    private static int Flag;
    private static int MaxWbits;
    private static int Method;
    private static int PresetDict;
    private static int ZBufError;
    private static int ZDataError;
    private static int ZDeflated;
    private static int ZErrno;
    private static int ZMemError;
    private static int ZNeedDict;
    private static int ZOk;
    private static int ZStreamEnd;
    private static int ZStreamError;
    private static int ZVersionError;
    private static Byte[] _mark;
    internal InfBlocks blocks;
    internal int Marker;
    internal int method;
    internal int Mode;
    internal long Need;
    internal int Nowrap;
    internal Int64[] Was;
    internal int Wbits;
    private static Inflate();
    internal static int inflate(ZStream z, int f);
    internal int InflateEnd(ZStream z);
    internal int InflateInit(ZStream z, int w);
    internal static int InflateReset(ZStream z);
    internal static int InflateSetDictionary(ZStream z, Byte[] dictionary, int dictLength);
    internal static int InflateSync(ZStream z);
    internal static int InflateSyncPoint(ZStream z);
}
internal class System.util.zlib.InfTree : object {
    private static int Bmax;
    private static int FixedBd;
    private static int FixedBl;
    private static int Many;
    private static int ZBufError;
    private static int ZDataError;
    private static int ZErrno;
    private static int ZMemError;
    private static int ZNeedDict;
    private static int ZOk;
    private static int ZStreamEnd;
    private static int ZStreamError;
    private static int ZVersionError;
    private static Int32[] _cpdext;
    private static Int32[] _cpdist;
    private static Int32[] _cplens;
    private static Int32[] _cplext;
    private static Int32[] _fixedTd;
    private static Int32[] _fixedTl;
    private Int32[] _c;
    private Int32[] _hn;
    private Int32[] _r;
    private Int32[] _u;
    private Int32[] _v;
    private Int32[] _x;
    private static InfTree();
    internal static int inflate_trees_fixed(Int32[] bl, Int32[] bd, Int32[][] tl, Int32[][] td, ZStream z);
    internal int inflate_trees_bits(Int32[] c, Int32[] bb, Int32[] tb, Int32[] hp, ZStream z);
    internal int inflate_trees_dynamic(int nl, int nd, Int32[] c, Int32[] bl, Int32[] bd, Int32[] tl, Int32[] td, Int32[] hp, ZStream z);
    private int huft_build(Int32[] b, int bindex, int n, int s, Int32[] d, Int32[] e, Int32[] t, Int32[] m, Int32[] hp, Int32[] hn, Int32[] v);
    private void initWorkArea(int vsize);
}
public static class System.util.zlib.JZlib : object {
    public static int Z_BEST_COMPRESSION;
    public static int Z_BEST_SPEED;
    public static int Z_BUF_ERROR;
    public static int Z_DATA_ERROR;
    public static int Z_DEFAULT_COMPRESSION;
    public static int Z_DEFAULT_STRATEGY;
    public static int Z_ERRNO;
    public static int Z_FILTERED;
    public static int Z_FINISH;
    public static int Z_FULL_FLUSH;
    public static int Z_HUFFMAN_ONLY;
    public static int Z_MEM_ERROR;
    public static int Z_NEED_DICT;
    public static int Z_NO_COMPRESSION;
    public static int Z_NO_FLUSH;
    public static int Z_OK;
    public static int Z_PARTIAL_FLUSH;
    public static int Z_STREAM_END;
    public static int Z_STREAM_ERROR;
    public static int Z_SYNC_FLUSH;
    public static int Z_VERSION_ERROR;
    private static string version;
    public static string Version();
}
internal class System.util.zlib.StaticTree : object {
    internal static int MAX_BL_BITS;
    private static int BlCodes;
    private static int DCodes;
    private static int LCodes;
    private static int LengthCodes;
    private static int Literals;
    private static int MaxBits;
    internal static StaticTree StaticBlDesc;
    internal static StaticTree StaticDDesc;
    internal static Int16[] StaticDtree;
    internal static StaticTree StaticLDesc;
    internal static Int16[] StaticLtree;
    internal int Elems;
    internal int ExtraBase;
    internal Int32[] ExtraBits;
    internal int MaxLength;
    internal Int16[] static_tree;
    private static StaticTree();
    internal StaticTree(Int16[] staticTree, Int32[] extraBits, int extraBase, int elems, int maxLength);
}
internal class System.util.zlib.Tree : object {
    internal static int Buf_size;
    internal static int DIST_CODE_LEN;
    internal static int END_BLOCK;
    internal static int MAX_BL_BITS;
    internal static int REP_3_6;
    internal static int REPZ_11_138;
    internal static int REPZ_3_10;
    private static int BlCodes;
    private static int DCodes;
    private static int HeapSize;
    private static int LCodes;
    private static int LengthCodes;
    private static int Literals;
    private static int MaxBits;
    internal static Int32[] BaseDist;
    internal static Int32[] BaseLength;
    internal static Byte[] BlOrder;
    internal static Byte[] DistCode;
    internal static Int32[] ExtraBlbits;
    internal static Int32[] ExtraDbits;
    internal static Int32[] ExtraLbits;
    internal static Byte[] LengthCode;
    internal Int16[] DynTree;
    internal int MaxCode;
    internal StaticTree StatDesc;
    private static Tree();
    internal static int bi_reverse(int code, int len);
    internal static int d_code(int dist);
    internal static void gen_codes(Int16[] tree, int maxCode, Int16[] blCount);
    internal void build_tree(Deflate s);
    internal void gen_bitlen(Deflate s);
}
public class System.util.zlib.ZDeflaterOutputStream : Stream {
    protected Byte[] Buf;
    protected int FlushLevel;
    protected Stream Outp;
    protected ZStream Z;
    private static int Bufsize;
    private Byte[] _buf1;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public ZDeflaterOutputStream(Stream outp);
    public ZDeflaterOutputStream(Stream outp, int level);
    public ZDeflaterOutputStream(Stream outp, int level, bool nowrap);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Close();
    public void End();
    public void Finish();
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte value);
}
public class System.util.zlib.ZInflaterInputStream : Stream {
    private static int Bufsize;
    private Byte[] _buf1;
    private bool _nomoreinput;
    protected Byte[] Buf;
    protected int FlushLevel;
    protected Stream Inp;
    protected ZStream Z;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public ZInflaterInputStream(Stream inp);
    public ZInflaterInputStream(Stream inp, bool nowrap);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte value);
}
public class System.util.zlib.ZStream : object {
    private static int DefWbits;
    private static int MaxMemLevel;
    private static int MaxWbits;
    private static int ZBufError;
    private static int ZDataError;
    private static int ZErrno;
    private static int ZFinish;
    private static int ZFullFlush;
    private static int ZMemError;
    private static int ZNeedDict;
    private static int ZNoFlush;
    private static int ZOk;
    private static int ZPartialFlush;
    private static int ZStreamEnd;
    private static int ZStreamError;
    private static int ZSyncFlush;
    private static int ZVersionError;
    internal Adler32 _adler;
    public long Adler;
    public int AvailIn;
    public int AvailOut;
    internal int DataType;
    internal Deflate Dstate;
    internal Inflate Istate;
    public string Msg;
    public Byte[] NextIn;
    public int NextInIndex;
    public Byte[] NextOut;
    public int NextOutIndex;
    public long TotalIn;
    public long TotalOut;
    public int Deflate(int flush);
    public int DeflateEnd();
    public int DeflateInit(int level);
    public int DeflateInit(int level, bool nowrap);
    public int DeflateInit(int level, int bits);
    public int DeflateInit(int level, int bits, bool nowrap);
    public int DeflateParams(int level, int strategy);
    public int DeflateSetDictionary(Byte[] dictionary, int dictLength);
    public void Free();
    public int Inflate(int f);
    public int InflateEnd();
    public int InflateInit();
    public int InflateInit(bool nowrap);
    public int InflateInit(int w);
    public int InflateInit(int w, bool nowrap);
    public int InflateSetDictionary(Byte[] dictionary, int dictLength);
    public int InflateSync();
    internal void flush_pending();
    internal int read_buf(Byte[] buf, int start, int size);
}
