[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class J2N.ArrayExtensions : object {
    [ExtensionAttribute]
public static void Fill(T[] array, T value);
    [ExtensionAttribute]
public static void Fill(T[] array, int startIndex, int length, T value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class J2N.AssemblyExtensions : object {
    private static LurchTable`2<TypeAndResource, string> resourceCache;
    private static AssemblyExtensions();
    [ExtensionAttribute]
public static string GetManifestResourceBaseName(Assembly assembly, string suffix);
    [ExtensionAttribute]
public static Stream FindAndGetManifestResourceStream(Assembly assembly, string name);
    [ExtensionAttribute]
public static Stream FindAndGetManifestResourceStream(Assembly assembly, Type type, string name);
    [ExtensionAttribute]
public static string FindResource(Assembly assembly, string name);
    [ExtensionAttribute]
public static string FindResource(Assembly assembly, Type type, string name);
    private static bool TryFindResource(String[] resourceNames, string prefix, string resourceName, string exactResourceName, String& result);
}
public static class J2N.BitConversion : object {
    public static float Int32BitsToSingle(int value);
    public static int SingleToRawInt32Bits(float value);
    public static int SingleToInt32Bits(float value);
    public static long SingleToInt64Bits(float value);
    public static double Int64BitsToDouble(long value);
    public static long DoubleToInt64Bits(double value);
    public static long DoubleToRawInt64Bits(double value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class J2N.Character : object {
    private static char charNull;
    private static char charZero;
    private static char charA;
    public static int MaxRadix;
    public static int MinRadix;
    public static char MinHighSurrogate;
    public static char MaxHighSurrogate;
    public static char MinLowSurrogate;
    public static char MaxLowSurrogate;
    public static char MinSurrogate;
    public static char MaxSurrogate;
    public static int MinSupplementaryCodePoint;
    public static int MinCodePoint;
    public static int MaxCodePoint;
    private static SByte[] ASCIIDigits;
    private static string digitKeys;
    private static Char[] digitValues;
    private static string numericKeys;
    private static Char[] numericValues;
    private static Character();
    public static bool IsValidCodePoint(int codePoint);
    public static bool IsSupplementaryCodePoint(int codePoint);
    public static int CharCount(int codePoint);
    public static int ToCodePoint(char high, char low);
    [ExtensionAttribute]
public static int CodePointAt(ICharSequence seq, int index);
    [ExtensionAttribute]
public static int CodePointAt(Char[] seq, int index);
    [ExtensionAttribute]
public static int CodePointAt(StringBuilder seq, int index);
    [ExtensionAttribute]
public static int CodePointAt(string seq, int index);
    [ExtensionAttribute]
public static int CodePointAt(Char[] seq, int index, int limit);
    [ExtensionAttribute]
public static int CodePointBefore(ICharSequence seq, int index);
    [ExtensionAttribute]
public static int CodePointBefore(Char[] seq, int index);
    [ExtensionAttribute]
public static int CodePointBefore(StringBuilder seq, int index);
    [ExtensionAttribute]
public static int CodePointBefore(string seq, int index);
    [ExtensionAttribute]
public static int CodePointBefore(Char[] seq, int index, int start);
    public static int ToChars(int codePoint, Char[] destination, int destinationIndex);
    public static Char[] ToChars(int codePoint);
    [ExtensionAttribute]
public static int CodePointCount(ICharSequence seq, int startIndex, int length);
    [ExtensionAttribute]
public static int CodePointCount(Char[] seq, int startIndex, int length);
    [ExtensionAttribute]
public static int CodePointCount(StringBuilder seq, int startIndex, int length);
    [ExtensionAttribute]
public static int CodePointCount(string seq, int startIndex, int length);
    [ExtensionAttribute]
public static int OffsetByCodePoints(ICharSequence seq, int index, int codePointOffset);
    [ExtensionAttribute]
public static int OffsetByCodePoints(Char[] seq, int index, int codePointOffset);
    [ExtensionAttribute]
public static int OffsetByCodePoints(StringBuilder seq, int index, int codePointOffset);
    [ExtensionAttribute]
public static int OffsetByCodePoints(string seq, int index, int codePointOffset);
    [ExtensionAttribute]
public static int OffsetByCodePoints(Char[] seq, int start, int count, int index, int codePointOffset);
    private static int OffsetByCodePointsImpl(Char[] seq, int start, int count, int index, int codePointOffset);
    public static int Digit(char c, int radix);
    public static int Digit(int codePoint, int radix);
    internal static bool IsAsciiHexDigit(int c);
    private static int BinarySearchRange(string data, char c);
    private static int BinarySearchRange(UInt32[] data, int codePoint);
    private static int BinarySearchRange(UInt16[] data, int codePoint);
    public static char ForDigit(int digit, int radix);
    public static int GetNumericValue(char c);
    public static int GetNumericValue(int codePoint);
    public static UnicodeCategory GetType(char c);
    public static UnicodeCategory GetType(int codePoint);
    public static bool IsDefined(char c);
    public static bool IsDefined(int codePoint);
    public static bool IsDigit(char c);
    public static bool IsDigit(int codePoint);
    public static bool IsIdentifierIgnorable(char c);
    public static bool IsIdentifierIgnorable(int codePoint);
    public static bool IsISOControl(char c);
    public static bool IsISOControl(int codePoint);
    public static bool IsLetter(char c);
    public static bool IsLetter(int codePoint);
    public static bool IsLetterOrDigit(char c);
    public static bool IsLetterOrDigit(int codePoint);
    public static bool IsLower(char c);
    public static bool IsLower(int codePoint);
    [ObsoleteAttribute("Use char.IsWhiteSpace()")]
public static bool IsSpace(char ch);
    public static bool IsSpaceChar(char c);
    public static bool IsSpaceChar(int codePoint);
    public static bool IsTitleCase(char c);
    public static bool IsTitleCase(int codePoint);
    public static bool IsUnicodeIdentifierPart(char c);
    public static bool IsUnicodeIdentifierPart(int codePoint);
    public static bool IsUnicodeIdentifierStart(char c);
    public static bool IsUnicodeIdentifierStart(int codePoint);
    public static bool IsUpper(char c);
    public static bool IsUpper(int codePoint);
    public static bool IsWhiteSpace(char c);
    public static bool IsWhiteSpace(int codePoint);
    public static char ReverseBytes(char c);
    public static int ToLower(int codePoint);
    public static int ToLower(int codePoint, CultureInfo culture);
    public static int ToUpper(int codePoint);
    public static int ToUpper(int codePoint, CultureInfo culture);
    public static string ToString(Int32[] codePoints);
    public static string ToString(Int32[] codePoints, int startIndex, int length);
    [NullableContextAttribute("0")]
private static int WriteCodePointsToCharBuffer(Char* buffer, Int32[] codePoints, int startIndex, int length);
    [CompilerGeneratedAttribute]
internal static string <ToString>g__ToStringSlow|92_0(Int32[] codePoints, int startIndex, int length);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class J2N.Collections.AggressiveStructuralEqualityComparer : StructuralEqualityComparer {
    protected virtual int GetUnstructuredHashCode(object obj);
    protected virtual bool UnstructuredEquals(object x, object y);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract class J2N.Collections.ArrayEqualityComparer`1 : EqualityComparer`1<T> {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private static IEqualityComparer`1<T> <Default>k__BackingField;
    [CompilerGeneratedAttribute]
private static IEqualityComparer`1<T[]> <OneDimensional>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[EditorBrowsableAttribute("1")]
public static IEqualityComparer`1<T> Default { get; }
    public static IEqualityComparer`1<T[]> OneDimensional { get; }
    private static ArrayEqualityComparer`1();
    [CompilerGeneratedAttribute]
public static IEqualityComparer`1<T> get_Default();
    [CompilerGeneratedAttribute]
public static IEqualityComparer`1<T[]> get_OneDimensional();
}
internal static class J2N.Collections.ArrayEqualityUtil : object {
    [NullableContextAttribute("1")]
public static IEqualityComparer GetPrimitiveOneDimensionalArrayEqualityComparer(Type elementType);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal static class J2N.Collections.Arrays : object {
    public static bool DeepEquals(T[] arrayA, T[] arrayB);
    public static bool Equals(T[] arrayA, T[] arrayB);
    public static int GetDeepHashCode(T[] array);
    public static int GetHashCode(T[] array);
    [NullableContextAttribute("1")]
public static string ToString(T[] array);
    public static string ToString(T[] array, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static string ToString(Array array);
    public static string ToString(Array array, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static T[] CopyOf(T[] original, int newLength);
    [NullableContextAttribute("1")]
public static T[] Empty();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class J2N.Collections.BitSet : object {
    private static int Offset;
    private static int ElmSize;
    private static int RightBits;
    private static Int64[] TwoNArray;
    internal Int64[] bits;
    private bool needClear;
    private int actualArrayLength;
    private bool isLengthActual;
    public int Capacity { get; }
    [EditorBrowsableAttribute("1")]
public int Count { get; }
    public int Length { get; }
    private int ActualArrayLength { get; }
    public bool IsEmpty { get; }
    public int Cardinality { get; }
    public BitSet(int nbits);
    private BitSet(Int64[] bits, bool needClear, int actualArrayLength, bool isLengthActual);
    private static BitSet();
    public virtual object Clone();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    private void GrowLength(int length);
    public virtual int GetHashCode();
    public virtual bool Get(int position);
    public virtual BitSet Get(int position1, int position2);
    public virtual void Set(int position);
    public virtual void Set(int position, bool value);
    public virtual void Set(int position1, int position2);
    private void NeedClear();
    public virtual void Set(int position1, int position2, bool value);
    public virtual void Clear();
    public virtual void Clear(int position);
    public virtual void Clear(int position1, int position2);
    public virtual void Flip(int position);
    public virtual void Flip(int position1, int position2);
    public virtual bool Intersects(BitSet bitSet);
    public virtual void And(BitSet bitSet);
    public virtual void AndNot(BitSet bitSet);
    public virtual void Or(BitSet bitSet);
    public virtual void Xor(BitSet bitSet);
    public virtual int get_Capacity();
    public virtual int get_Count();
    public virtual int get_Length();
    private int get_ActualArrayLength();
    public virtual string ToString();
    public virtual int NextSetBit(int position);
    public virtual int NextClearBit(int position);
    public virtual bool get_IsEmpty();
    public virtual int get_Cardinality();
    private int Pop(long x);
    [OnDeserializedAttribute]
internal void OnDeserializedMethod(StreamingContext context);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal static class J2N.Collections.CollectionUtil : object {
    [NullableAttribute("1")]
private static string SingleFormatArgument;
    public static bool Equals(IList`1<T> listA, IList`1<T> listB);
    public static bool Equals(ISet`1<T> setA, ISet`1<T> setB);
    public static bool Equals(IDictionary`2<TKey, TValue> dictionaryA, IDictionary`2<TKey, TValue> dictionaryB);
    public static bool Equals(object objA, object objB);
    public static int GetHashCode(IList`1<T> list);
    public static int GetHashCode(ISet`1<T> set);
    public static int GetHashCode(IDictionary`2<TKey, TValue> dictionary);
    public static int GetHashCode(object obj);
    public static string ToString(IFormatProvider provider, string format, ICollection`1<T> collection);
    public static string ToString(ICollection`1<T> collection, IFormatProvider provider);
    public static string ToString(IFormatProvider provider, string format, IDictionary`2<TKey, TValue> dictionary);
    public static string ToString(IDictionary`2<TKey, TValue> dictionary, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static string ToString(object obj);
    public static string ToString(object obj, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static string ToStringImpl(object obj, Type type, IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class J2N.Collections.Concurrent.Add2Info`2 : ValueType {
    private bool _hasAddValue;
    [AllowNullAttribute]
private TValue _addValue;
    [AllowNullAttribute]
public TValue Value;
    [AllowNullAttribute]
public Func`2<TKey, TValue> Create;
    [AllowNullAttribute]
public KeyValueUpdate`2<TKey, TValue> Update;
    public Add2Info`2(TValue addValue);
    public sealed virtual bool CreateValue(TKey key, TValue& value);
    public sealed virtual bool UpdateValue(TKey key, TValue& value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class J2N.Collections.Concurrent.AddInfo`2 : ValueType {
    public bool CanUpdate;
    [AllowNullAttribute]
public TValue Value;
    public sealed virtual bool CreateValue(TKey key, TValue& value);
    public sealed virtual bool UpdateValue(TKey key, TValue& value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class J2N.Collections.Concurrent.DelInfo`2 : ValueType {
    [AllowNullAttribute]
public TValue Value;
    private bool _hasTestValue;
    [AllowNullAttribute]
private TValue _testValue;
    [AllowNullAttribute]
public KeyValuePredicate`2<TKey, TValue> Condition;
    public DelInfo`2(TValue expected);
    public sealed virtual bool RemoveValue(TKey key, TValue value);
}
[NullableContextAttribute("2")]
internal interface J2N.Collections.Concurrent.ICreateOrUpdateValue`2 {
}
[NullableContextAttribute("2")]
internal interface J2N.Collections.Concurrent.ICreateValue`2 {
    [NullableContextAttribute("1")]
public abstract virtual bool CreateValue(TKey key, TValue& value);
}
[NullableContextAttribute("2")]
internal interface J2N.Collections.Concurrent.IRemoveValue`2 {
    [NullableContextAttribute("1")]
public abstract virtual bool RemoveValue(TKey key, TValue value);
}
[NullableContextAttribute("2")]
internal interface J2N.Collections.Concurrent.IUpdateValue`2 {
    [NullableContextAttribute("1")]
public abstract virtual bool UpdateValue(TKey key, TValue& value);
}
public class J2N.Collections.Concurrent.KeyValuePredicate`2 : MulticastDelegate {
    public KeyValuePredicate`2(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual bool Invoke(TKey key, TValue original);
    public virtual IAsyncResult BeginInvoke(TKey key, TValue original, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
public class J2N.Collections.Concurrent.KeyValueUpdate`2 : MulticastDelegate {
    public KeyValueUpdate`2(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual TValue Invoke(TKey key, TValue original);
    public virtual IAsyncResult BeginInvoke(TKey key, TValue original, AsyncCallback callback, object object);
    public virtual TValue EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
[DebuggerTypeProxyAttribute("J2N.Collections.Generic.IDictionaryDebugView`2")]
[DebuggerDisplayAttribute("Count = {Count}")]
public class J2N.Collections.Concurrent.LurchTable`2 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Action`1<KeyValuePair`2<TKey, TValue>> ItemRemoved;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ItemUpdatedMethod<TKey, TValue> ItemUpdated;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Action`1<KeyValuePair`2<TKey, TValue>> ItemAdded;
    private static int OverAlloc;
    private static int FreeSlots;
    private IEqualityComparer`1<TKey> _comparer;
    private int _hsize;
    private int _lsize;
    private int _limit;
    private int _allocSize;
    private int _shift;
    private int _shiftMask;
    private LurchTableOrder _ordering;
    private Object[] _locks;
    private Int32[] _buckets;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private FreeList[] _free;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Entry[][] _entries;
    private int _used;
    private int _count;
    private int _allocNext;
    private int _freeVersion;
    [NullableAttribute("2")]
private object _syncRoot;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private KeyCollection<TKey, TValue> _keyCollection;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ValueCollection<TKey, TValue> _valueCollection;
    public int Count { get; }
    public bool IsEmpty { get; }
    public LurchTableOrder Ordering { get; }
    public IEqualityComparer`1<TKey> EqualityComparer { get; }
    public int Limit { get; public set; }
    private bool System.Collections.IDictionary.IsFixedSize { get; }
    private bool System.Collections.IDictionary.IsReadOnly { get; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private object SyncRoot { get; }
    [NullableAttribute("2")]
private object System.Collections.IDictionary.Item { get; private set; }
    public TValue Item { get; public set; }
    private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.IsReadOnly { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public KeyCollection<TKey, TValue> Keys { get; }
    private ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.Keys { get; }
    private IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Keys { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ValueCollection<TKey, TValue> Values { get; }
    private ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.Values { get; }
    private IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Values { get; }
    public LurchTable`2(int capacity);
    public LurchTable`2(int capacity, LurchTableOrder ordering);
    public LurchTable`2(int capacity, LurchTableOrder ordering, IEqualityComparer`1<TKey> comparer);
    public LurchTable`2(IEqualityComparer`1<TKey> comparer);
    public LurchTable`2(int capacity, IEqualityComparer`1<TKey> comparer);
    public LurchTable`2(LurchTableOrder ordering, int limit);
    public LurchTable`2(LurchTableOrder ordering, int limit, IEqualityComparer`1<TKey> comparer);
    public LurchTable`2(int capacity, LurchTableOrder ordering, int limit, IEqualityComparer`1<TKey> comparer);
    internal LurchTable`2(LurchTableOrder ordering, int limit, int hashSize, int allocSize, int lockSize, IEqualityComparer`1<TKey> comparer);
    private LurchTable`2(int capacity, LurchTableOrder ordering, int limit, int hashSize, int allocSize, int lockSize, IEqualityComparer`1<TKey> comparer);
    public LurchTable`2(IDictionary`2<TKey, TValue> dictionary);
    public LurchTable`2(IDictionary`2<TKey, TValue> dictionary, LurchTableOrder ordering);
    public LurchTable`2(IDictionary`2<TKey, TValue> dictionary, IEqualityComparer`1<TKey> comparer);
    public LurchTable`2(IDictionary`2<TKey, TValue> dictionary, LurchTableOrder ordering, IEqualityComparer`1<TKey> comparer);
    public LurchTable`2(IDictionary`2<TKey, TValue> dictionary, LurchTableOrder ordering, int limit, IEqualityComparer`1<TKey> comparer);
    public LurchTable`2(IEnumerable`1<KeyValuePair`2<TKey, TValue>> collection);
    public LurchTable`2(IEnumerable`1<KeyValuePair`2<TKey, TValue>> collection, LurchTableOrder ordering);
    public LurchTable`2(IEnumerable`1<KeyValuePair`2<TKey, TValue>> collection, IEqualityComparer`1<TKey> comparer);
    public LurchTable`2(IEnumerable`1<KeyValuePair`2<TKey, TValue>> collection, LurchTableOrder ordering, IEqualityComparer`1<TKey> comparer);
    public LurchTable`2(IEnumerable`1<KeyValuePair`2<TKey, TValue>> collection, LurchTableOrder ordering, int limit, IEqualityComparer`1<TKey> comparer);
    [CompilerGeneratedAttribute]
public void add_ItemRemoved(Action`1<KeyValuePair`2<TKey, TValue>> value);
    [CompilerGeneratedAttribute]
public void remove_ItemRemoved(Action`1<KeyValuePair`2<TKey, TValue>> value);
    [CompilerGeneratedAttribute]
public void add_ItemUpdated(ItemUpdatedMethod<TKey, TValue> value);
    [CompilerGeneratedAttribute]
public void remove_ItemUpdated(ItemUpdatedMethod<TKey, TValue> value);
    [CompilerGeneratedAttribute]
public void add_ItemAdded(Action`1<KeyValuePair`2<TKey, TValue>> value);
    [CompilerGeneratedAttribute]
public void remove_ItemAdded(Action`1<KeyValuePair`2<TKey, TValue>> value);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public sealed virtual int get_Count();
    public bool get_IsEmpty();
    public LurchTableOrder get_Ordering();
    public IEqualityComparer`1<TKey> get_EqualityComparer();
    public int get_Limit();
    public void set_Limit(int value);
    public void Initialize();
    public bool ContainsValue(TValue value);
    public bool ContainsValue(TValue value, IEqualityComparer`1<TValue> valueComparer);
    private sealed virtual override bool System.Collections.IDictionary.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IDictionary.get_IsReadOnly();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private object get_SyncRoot();
    private sealed virtual override object System.Collections.IDictionary.get_Item(object key);
    private sealed virtual override void System.Collections.IDictionary.set_Item(object key, object value);
    [NullableContextAttribute("2")]
private sealed virtual override void System.Collections.IDictionary.Add(object key, object value);
    private sealed virtual override bool System.Collections.IDictionary.Contains(object key);
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    private sealed virtual override void System.Collections.IDictionary.Remove(object key);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private static bool IsCompatibleKey(object key);
    public sealed virtual void Clear();
    public sealed virtual bool ContainsKey(TKey key);
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    public sealed virtual void Add(TKey key, TValue value);
    public sealed virtual bool Remove(TKey key);
    public TValue GetOrAdd(TKey key, TValue value);
    public bool TryAdd(TKey key, TValue value);
    public bool TryUpdate(TKey key, TValue value);
    public bool TryUpdate(TKey key, TValue value, TValue comparisonValue);
    public bool TryRemove(TKey key, TValue& value);
    public TValue GetOrAdd(TKey key, Func`2<TKey, TValue> fnCreate);
    public TValue AddOrUpdate(TKey key, TValue addValue, KeyValueUpdate`2<TKey, TValue> fnUpdate);
    public TValue AddOrUpdate(TKey key, Func`2<TKey, TValue> fnCreate, KeyValueUpdate`2<TKey, TValue> fnUpdate);
    public bool TryAdd(TKey key, Func`2<TKey, TValue> fnCreate);
    public bool TryUpdate(TKey key, KeyValueUpdate`2<TKey, TValue> fnUpdate);
    public bool TryRemove(KeyValuePair`2<TKey, TValue> item);
    public bool TryRemove(TKey key, KeyValuePredicate`2<TKey, TValue> fnCondition);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.get_IsReadOnly();
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Add(KeyValuePair`2<TKey, TValue> item);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Contains(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int index);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Remove(KeyValuePair`2<TKey, TValue> item);
    [NullableContextAttribute("0")]
private bool MoveNext(EnumState& state);
    [NullableContextAttribute("0")]
public Enumerator<TKey, TValue> GetEnumerator();
    private sealed virtual override IEnumerator`1<KeyValuePair`2<TKey, TValue>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TValue>>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public KeyCollection<TKey, TValue> get_Keys();
    private sealed virtual override ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.get_Keys();
    private sealed virtual override IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Keys();
    public ValueCollection<TKey, TValue> get_Values();
    private sealed virtual override ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.get_Values();
    private sealed virtual override IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Values();
    public bool Peek(KeyValuePair`2& value);
    public KeyValuePair`2<TKey, TValue> Dequeue();
    public bool TryDequeue(KeyValuePair`2& value);
    public bool TryDequeue(Predicate`1<KeyValuePair`2<TKey, TValue>> predicate, KeyValuePair`2& value);
    private bool InternalGetValue(int hash, TKey key, TValue& value);
    private bool InternalContainsValue(Predicate`1<TValue> matchPredicate);
    private InsertResult<TKey, TValue> Insert(TKey key, T& value);
    private InsertResult<TKey, TValue> InternalInsert(int hash, TKey key, Int32& added, T& value);
    private void CopyConstructorAddRange(IEnumerable`1<KeyValuePair`2<TKey, TValue>> collection);
    private bool Delete(TKey key, T& value);
    private void InternalLink(int index);
    private void InternalUnlink(int index);
    private int AllocSlot();
    private void FreeSlot(Int32& index, int ver);
    private int GetHash(TKey key);
    private bool KeyEquals(TKey key1, TKey key2);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class J2N.Collections.Concurrent.LurchTableCorruptionException : Exception {
    protected LurchTableCorruptionException(SerializationInfo info, StreamingContext context);
    public LurchTableCorruptionException(string message);
    public LurchTableCorruptionException(string message, Exception innerException);
    protected LurchTableCorruptionException(Exception innerException, int hResult, string message);
    [NullableContextAttribute("2")]
public LurchTableCorruptionException(Exception innerException);
    internal static Exception Create(int hResult, string message);
    public static void Assert(bool condition);
}
public enum J2N.Collections.Concurrent.LurchTableOrder : Enum {
    public int value__;
    public static LurchTableOrder None;
    public static LurchTableOrder Insertion;
    public static LurchTableOrder Modified;
    public static LurchTableOrder Access;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class J2N.Collections.Concurrent.UpdateInfo`2 : ValueType {
    [AllowNullAttribute]
public TValue Value;
    private bool _hasTestValue;
    [AllowNullAttribute]
private TValue _testValue;
    public UpdateInfo`2(TValue expected);
    private sealed virtual override bool J2N.Collections.Concurrent.ICreateValue<TKey,TValue>.CreateValue(TKey key, TValue& value);
    public sealed virtual bool UpdateValue(TKey key, TValue& value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class J2N.Collections.DefaultStructuralEqualityComparer : StructuralEqualityComparer {
    protected virtual bool UnstructuredEquals(object x, object y);
    protected virtual int GetUnstructuredHashCode(object obj);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class J2N.Collections.Generic.ArraySortHelper`1 : object {
    internal static int IntrosortSizeThreshold;
    internal static void Sort(Span`1<T> keys, Comparison`1<T> comparer);
    private static void SwapIfGreater(Span`1<T> keys, Comparison`1<T> comparer, int i, int j);
    private static void Swap(Span`1<T> a, int i, int j);
    internal static void IntrospectiveSort(Span`1<T> keys, Comparison`1<T> comparer);
    private static void IntroSort(Span`1<T> keys, int depthLimit, Comparison`1<T> comparer);
    private static int PickPivotAndPartition(Span`1<T> keys, Comparison`1<T> comparer);
    private static void HeapSort(Span`1<T> keys, Comparison`1<T> comparer);
    private static void DownHeap(Span`1<T> keys, int i, int n, int lo, Comparison`1<T> comparer);
    private static void InsertionSort(Span`1<T> keys, Comparison`1<T> comparer);
    internal static void Sort(T[] array, int startIndex, int length, Comparison`1<T> comparer);
    private static void SwapIfGreater(T[] keys, Comparison`1<T> comparer, int i, int j);
    private static void Swap(T[] a, int i, int j);
    internal static void IntrospectiveSort(T[] array, int startIndex, int length, Comparison`1<T> comparer);
    private static void IntroSort(T[] keys, int startIndex, int length, int depthLimit, Comparison`1<T> comparer);
    private static int PickPivotAndPartition(T[] keys, int startIndex, int length, Comparison`1<T> comparer);
    private static void HeapSort(T[] keys, int startIndex, int length, Comparison`1<T> comparer);
    private static void DownHeap(T[] keys, int i, int n, int lo, Comparison`1<T> comparer);
    private static void InsertionSort(T[] keys, int startIndex, int length, Comparison`1<T> comparer);
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
internal class J2N.Collections.Generic.BitHelper : ValueType {
    private static int IntSize;
    private Span`1<int> _span;
    internal BitHelper(Span`1<int> span, bool clear);
    internal void MarkBit(int bitPosition);
    internal bool IsMarked(int bitPosition);
    internal static int ToIntArrayLength(int n);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class J2N.Collections.Generic.Comparer`1 : object {
    [CompilerGeneratedAttribute]
private static IComparer`1<T> <Default>k__BackingField;
    public static IComparer`1<T> Default { get; }
    private static Comparer`1();
    [CompilerGeneratedAttribute]
public static IComparer`1<T> get_Default();
    private static IComparer`1<T> LoadDefault();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
[DebuggerTypeProxyAttribute("J2N.Collections.Generic.IDictionaryDebugView`2")]
[DebuggerDisplayAttribute("Count = {Count}")]
public class J2N.Collections.Generic.Dictionary`2 : object {
    private static bool TKeyIsNullable;
    private IConcreteDictionary`2<TKey, TValue> dictionary;
    private bool hasNullKey;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private KeyValuePair`2<TKey, TValue> nullEntry;
    private int version;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private KeyCollection<TKey, TValue> keys;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ValueCollection<TKey, TValue> values;
    [NullableAttribute("2")]
private SerializationInfo siInfo;
    private static string EqualityComparerName;
    private static string CountName;
    private static string KeyValuePairsName;
    private static string VersionName;
    public IEqualityComparer`1<TKey> EqualityComparer { get; }
    public ICollection`1<TKey> Keys { get; }
    public ICollection`1<TValue> Values { get; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.IsReadOnly { get; }
    public TValue Item { get; public set; }
    private bool System.Collections.IDictionary.IsFixedSize { get; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    private bool System.Collections.IDictionary.IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    [NullableAttribute("2")]
private object System.Collections.IDictionary.Item { get; private set; }
    private IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Keys { get; }
    private IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Values { get; }
    public Dictionary`2(int capacity);
    public Dictionary`2(IEqualityComparer`1<TKey> comparer);
    public Dictionary`2(int capacity, IEqualityComparer`1<TKey> comparer);
    public Dictionary`2(IDictionary`2<TKey, TValue> dictionary);
    public Dictionary`2(IDictionary`2<TKey, TValue> dictionary, IEqualityComparer`1<TKey> comparer);
    public Dictionary`2(IEnumerable`1<KeyValuePair`2<TKey, TValue>> collection);
    public Dictionary`2(IEnumerable`1<KeyValuePair`2<TKey, TValue>> collection, IEqualityComparer`1<TKey> comparer);
    protected Dictionary`2(SerializationInfo info, StreamingContext context);
    private static Dictionary`2();
    public IEqualityComparer`1<TKey> get_EqualityComparer();
    public bool ContainsValue(TValue value);
    public bool ContainsValue(TValue value, IEqualityComparer`1<TValue> valueComparer);
    public int EnsureCapacity(int capacity);
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [NullableContextAttribute("2")]
public virtual void OnDeserialization(object sender);
    public void TrimExcess(int capacity);
    public void TrimExcess();
    public bool TryAdd(TKey key, TValue value);
    public sealed virtual ICollection`1<TKey> get_Keys();
    public sealed virtual ICollection`1<TValue> get_Values();
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.get_IsReadOnly();
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    public sealed virtual void Add(TKey key, TValue value);
    public sealed virtual bool ContainsKey(TKey key);
    public sealed virtual bool Remove(TKey key);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Add(KeyValuePair`2<TKey, TValue> item);
    private void Add(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Contains(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int index);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Remove(KeyValuePair`2<TKey, TValue> item);
    public bool Remove(TKey key, TValue& value);
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override bool System.Collections.IDictionary.get_IsFixedSize();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    private sealed virtual override bool System.Collections.IDictionary.get_IsReadOnly();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    [NullableContextAttribute("2")]
private sealed virtual override object System.Collections.IDictionary.get_Item(object key);
    [NullableContextAttribute("2")]
private sealed virtual override void System.Collections.IDictionary.set_Item(object key, object value);
    [NullableContextAttribute("2")]
private sealed virtual override void System.Collections.IDictionary.Add(object key, object value);
    [NullableContextAttribute("2")]
private sealed virtual override bool System.Collections.IDictionary.Contains(object key);
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    [NullableContextAttribute("2")]
private sealed virtual override void System.Collections.IDictionary.Remove(object key);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    [NullableContextAttribute("2")]
private static bool IsCompatibleKey(object key);
    private sealed virtual override IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Keys();
    private sealed virtual override IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Values();
    public virtual bool Equals(object other, IEqualityComparer comparer);
    public virtual int GetHashCode(IEqualityComparer comparer);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual string ToString(string format, IFormatProvider formatProvider);
    public virtual string ToString();
    public virtual string ToString(IFormatProvider formatProvider);
    public virtual string ToString(string format);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class J2N.Collections.Generic.DictionaryEqualityComparer`2 : object {
    private static bool TKeyIsValueType;
    private static bool TKeyIsObject;
    private static bool TValueIsValueType;
    private static bool TValueIsObject;
    private StructuralEqualityComparer structuralEqualityComparer;
    private Func`2<TKey, int> getKeyHashCode;
    private Func`2<TValue, int> getValueHashCode;
    private Func`3<TValue, TValue, bool> valueEquals;
    [CompilerGeneratedAttribute]
private static DictionaryEqualityComparer`2<TKey, TValue> <Default>k__BackingField;
    [CompilerGeneratedAttribute]
private static DictionaryEqualityComparer`2<TKey, TValue> <Aggressive>k__BackingField;
    public static DictionaryEqualityComparer`2<TKey, TValue> Default { get; }
    public static DictionaryEqualityComparer`2<TKey, TValue> Aggressive { get; }
    internal DictionaryEqualityComparer`2(StructuralEqualityComparer structuralEqualityComparer);
    private static DictionaryEqualityComparer`2();
    [CompilerGeneratedAttribute]
public static DictionaryEqualityComparer`2<TKey, TValue> get_Default();
    [CompilerGeneratedAttribute]
public static DictionaryEqualityComparer`2<TKey, TValue> get_Aggressive();
    private void LoadEqualityDelegates();
    public virtual bool Equals(IDictionary`2<TKey, TValue> dictionaryA, IDictionary`2<TKey, TValue> dictionaryB);
    public virtual int GetHashCode(IDictionary`2<TKey, TValue> dictionary);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(object a, object b);
    [NullableContextAttribute("2")]
public sealed virtual int GetHashCode(object obj);
    public static bool TryGetDictionaryEqualityComparer(IEqualityComparer comparer, DictionaryEqualityComparer`2& equalityComparer);
    public static bool Equals(IDictionary`2<TKey, TValue> dictionary, object other, IEqualityComparer comparer);
    public static int GetHashCode(IDictionary`2<TKey, TValue> dictionary, IEqualityComparer comparer);
    private sealed virtual override bool J2N.Collections.Generic.IDictionaryEqualityComparer.Equals(object dictionary, object other, IEqualityComparer comparer);
    private sealed virtual override int J2N.Collections.Generic.IDictionaryEqualityComparer.GetHashCode(object dictionary, IEqualityComparer comparer);
    [OnDeserializedAttribute]
internal void OnDeserializedMethod(StreamingContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class J2N.Collections.Generic.DictionaryKeyCollectionDebugView`2 : object {
    private ICollection`1<TKey> _collection;
    [DebuggerBrowsableAttribute("3")]
public TKey[] Items { get; }
    public DictionaryKeyCollectionDebugView`2(ICollection`1<TKey> collection);
    public TKey[] get_Items();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class J2N.Collections.Generic.DictionaryValueCollectionDebugView`2 : object {
    private ICollection`1<TValue> _collection;
    [DebuggerBrowsableAttribute("3")]
public TValue[] Items { get; }
    public DictionaryValueCollectionDebugView`2(ICollection`1<TValue> collection);
    public TValue[] get_Items();
}
internal class J2N.Collections.Generic.DoubleComparer : EqualityComparer`1<double> {
    [NullableAttribute("1")]
public static DoubleComparer Default;
    private static DoubleComparer();
    public sealed virtual int Compare(double x, double y);
    public virtual bool Equals(double x, double y);
    public virtual int GetHashCode(double obj);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal static class J2N.Collections.Generic.EnumerableHelpers : object {
    [NullableContextAttribute("1")]
internal static T[] ToArray(IEnumerable`1<T> source, Int32& length);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class J2N.Collections.Generic.EqualityComparer`1 : object {
    [CompilerGeneratedAttribute]
private static IEqualityComparer`1<T> <Default>k__BackingField;
    public static IEqualityComparer`1<T> Default { get; }
    private static EqualityComparer`1();
    [CompilerGeneratedAttribute]
public static IEqualityComparer`1<T> get_Default();
    private static IEqualityComparer`1<T> LoadDefault();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class J2N.Collections.Generic.Extensions.CollectionExtensions : object {
    [ExtensionAttribute]
public static ICollection`1<T> AsReadOnly(ICollection`1<T> collection);
    [ExtensionAttribute]
public static T[] ToArray(ICollection`1<T> source);
}
[ExtensionAttribute]
public static class J2N.Collections.Generic.Extensions.DictionaryExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static ReadOnlyDictionary`2<TKey, TValue> AsReadOnly(IDictionary`2<TKey, TValue> collection);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class J2N.Collections.Generic.Extensions.ListExtensions : object {
    [ExtensionAttribute]
public static ReadOnlyList`1<T> AsReadOnly(IList`1<T> collection);
    [ExtensionAttribute]
public static int BinarySearch(IList`1<T> list, T item);
    [ExtensionAttribute]
public static int BinarySearch(IList`1<T> list, T item, IComparer`1<T> comparer);
    [ExtensionAttribute]
private static int BinarySearchSlow(IList`1<T> list, T item, IComparer`1<T> comparer);
    [ExtensionAttribute]
public static int BinarySearch(IList`1<T> list, int index, int count, T item, IComparer`1<T> comparer);
    [ExtensionAttribute]
private static int BinarySearchSlow(IList`1<T> list, int index, int count, T item, IComparer`1<T> comparer);
    [ExtensionAttribute]
public static void CopyTo(IList`1<T> source, int sourceIndex, IList`1<T> destination, int destinationIndex, int length);
    [ExtensionAttribute]
public static IList`1<T> GetView(IList`1<T> list, int index, int count);
    [ExtensionAttribute]
public static int RemoveAll(IList`1<T> list, Predicate`1<T> match);
    [ExtensionAttribute]
public static int RemoveAll(IList`1<T> list, int startIndex, int count, Predicate`1<T> match);
    [ExtensionAttribute]
private static int RemoveAllSlow(IList`1<T> list, int startIndex, int count, Predicate`1<T> match);
    [ExtensionAttribute]
public static void Shuffle(IList`1<T> list);
    [ExtensionAttribute]
public static void Shuffle(IList`1<T> list, Random random);
    [ExtensionAttribute]
public static void Swap(IList`1<T> list, int index1, int index2);
}
[ExtensionAttribute]
public static class J2N.Collections.Generic.Extensions.SetExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static ReadOnlySet`1<T> AsReadOnly(ISet`1<T> collection);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerTypeProxyAttribute("J2N.Collections.Generic.ICollectionDebugView`1")]
[DebuggerDisplayAttribute("Count = {Count}")]
public class J2N.Collections.Generic.HashSet`1 : object {
    private static int Lower31BitMask;
    private static int StackAllocThreshold;
    private static int ShrinkThreshold;
    [NullableAttribute("2")]
private Int32[] _buckets;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Slot[] _slots;
    private int _count;
    private int _lastIndex;
    private int _freeList;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IEqualityComparer`1<T> _comparer;
    private int _version;
    [NullableAttribute("2")]
private SerializationInfo _siInfo;
    private static string CapacityName;
    private static string ElementsName;
    private static string EqualityComparerName;
    private static string VersionName;
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    public IEqualityComparer`1<T> EqualityComparer { get; }
    public HashSet`1(IEqualityComparer`1<T> comparer);
    public HashSet`1(int capacity);
    public HashSet`1(IEnumerable`1<T> collection);
    public HashSet`1(IEnumerable`1<T> collection, IEqualityComparer`1<T> comparer);
    public HashSet`1(int capacity, IEqualityComparer`1<T> comparer);
    protected HashSet`1(SerializationInfo info, StreamingContext context);
    private void CopyFrom(HashSet`1<T> source);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual bool Remove(T item);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    public IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [NullableContextAttribute("2")]
public virtual void OnDeserialization(object sender);
    public sealed virtual bool Add(T item);
    public bool TryGetValue(T equalValue, T& actualValue);
    public sealed virtual void UnionWith(IEnumerable`1<T> other);
    [SecurityCriticalAttribute]
public sealed virtual void IntersectWith(IEnumerable`1<T> other);
    public sealed virtual void ExceptWith(IEnumerable`1<T> other);
    [SecurityCriticalAttribute]
public sealed virtual void SymmetricExceptWith(IEnumerable`1<T> other);
    [SecurityCriticalAttribute]
public sealed virtual bool IsSubsetOf(IEnumerable`1<T> other);
    [SecurityCriticalAttribute]
public sealed virtual bool IsProperSubsetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsSupersetOf(IEnumerable`1<T> other);
    [SecurityCriticalAttribute]
public sealed virtual bool IsProperSupersetOf(IEnumerable`1<T> other);
    public sealed virtual bool Overlaps(IEnumerable`1<T> other);
    [SecurityCriticalAttribute]
public sealed virtual bool SetEquals(IEnumerable`1<T> other);
    public void CopyTo(T[] array);
    public void CopyTo(T[] array, int arrayIndex, int count);
    public int RemoveWhere(Predicate`1<T> match);
    public IEqualityComparer`1<T> get_EqualityComparer();
    public int EnsureCapacity(int capacity);
    public void TrimExcess();
    public static IEqualityComparer`1<ISet`1<T>> CreateSetComparer();
    private int Initialize(int capacity);
    private void IncreaseCapacity();
    private void SetCapacity(int newSize);
    private bool AddIfNotPresent(T value);
    private void AddValue(int index, int hashCode, T value);
    private bool ContainsAllElements(IEnumerable`1<T> other);
    private bool IsSubsetOfHashSetWithSameEC(ICollection`1<T> other);
    private void IntersectWithHashSetWithSameEC(ICollection`1<T> other);
    private void IntersectWithEnumerable(IEnumerable`1<T> other);
    private int InternalIndexOf(T item);
    private void SymmetricExceptWithUniqueHashSet(IEnumerable`1<T> other);
    private void SymmetricExceptWithEnumerable(IEnumerable`1<T> other);
    private bool AddOrGetLocation(T value, Int32& location);
    [NullableContextAttribute("0")]
private ElementCount<T> CheckUniqueAndUnfoundElements(IEnumerable`1<T> other, bool returnIfUnfound);
    internal static bool HashSetEquals(HashSet`1<T> set1, HashSet`1<T> set2, IEqualityComparer`1<T> comparer);
    private static bool AreEqualityComparersEqual(HashSet`1<T> set1, IEnumerable`1<T> set2);
    private static bool AreEqualityComparersEqual(HashSet`1<T> set1, HashSet`1<T> set2);
    private static int InternalGetHashCode(T item, IEqualityComparer`1<T> comparer);
    private int InternalGetHashCode(int hashCode);
    public virtual bool Equals(object other, IEqualityComparer comparer);
    public virtual int GetHashCode(IEqualityComparer comparer);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual string ToString(string format, IFormatProvider formatProvider);
    public virtual string ToString();
    public virtual string ToString(IFormatProvider formatProvider);
    public virtual string ToString(string format);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class J2N.Collections.Generic.ICollectionDebugView`1 : object {
    private ICollection`1<T> _collection;
    [DebuggerBrowsableAttribute("3")]
public T[] Items { get; }
    public ICollectionDebugView`1(ICollection`1<T> collection);
    public T[] get_Items();
}
[NullableContextAttribute("1")]
internal interface J2N.Collections.Generic.IConcreteDictionary`2 {
    public IEqualityComparer`1<TKey> Comparer { get; }
    public abstract virtual IEqualityComparer`1<TKey> get_Comparer();
    public abstract virtual int EnsureCapacity(int capacity);
    public abstract virtual void TrimExcess(int capacity);
    public abstract virtual void TrimExcess();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class J2N.Collections.Generic.IDictionaryDebugView`2 : object {
    private IDictionary`2<K, V> _dict;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DebuggerBrowsableAttribute("3")]
public KeyValuePair`2[] Items { get; }
    public IDictionaryDebugView`2(IDictionary`2<K, V> dictionary);
    public KeyValuePair`2[] get_Items();
}
[NullableContextAttribute("1")]
internal interface J2N.Collections.Generic.IDictionaryEqualityComparer {
    public abstract virtual bool Equals(object dictionary, object other, IEqualityComparer comparer);
    public abstract virtual int GetHashCode(object dictionary, IEqualityComparer comparer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
[DebuggerTypeProxyAttribute("J2N.Collections.Generic.IDictionaryDebugView`2")]
[DebuggerDisplayAttribute("Count = {Count}")]
public class J2N.Collections.Generic.LinkedDictionary`2 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<TKey, LinkedListNode`1<KeyValuePair`2<TKey, TValue>>> dictionary;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private LinkedList`1<KeyValuePair`2<TKey, TValue>> list;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private KeyCollection<TKey, TValue> keys;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ValueCollection<TKey, TValue> values;
    private int version;
    [NullableAttribute("2")]
private SerializationInfo siInfo;
    private static string EqualityComparerName;
    private static string CountName;
    private static string KeyValuePairsName;
    private static string VersionName;
    public IEqualityComparer`1<TKey> EqualityComparer { get; }
    public ICollection`1<TKey> Keys { get; }
    public ICollection`1<TValue> Values { get; }
    public TValue Item { get; public set; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.IsReadOnly { get; }
    private bool System.Collections.IDictionary.IsFixedSize { get; }
    private bool System.Collections.IDictionary.IsReadOnly { get; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    [NullableAttribute("2")]
private object System.Collections.IDictionary.Item { get; private set; }
    private IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Keys { get; }
    private IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Values { get; }
    public LinkedDictionary`2(IEqualityComparer`1<TKey> comparer);
    public LinkedDictionary`2(int capacity);
    public LinkedDictionary`2(int capacity, IEqualityComparer`1<TKey> comparer);
    public LinkedDictionary`2(IDictionary`2<TKey, TValue> dictionary);
    public LinkedDictionary`2(IDictionary`2<TKey, TValue> dictionary, IEqualityComparer`1<TKey> comparer);
    public LinkedDictionary`2(IEnumerable`1<KeyValuePair`2<TKey, TValue>> collection);
    public LinkedDictionary`2(IEnumerable`1<KeyValuePair`2<TKey, TValue>> collection, IEqualityComparer`1<TKey> comparer);
    protected LinkedDictionary`2(SerializationInfo info, StreamingContext context);
    public IEqualityComparer`1<TKey> get_EqualityComparer();
    public bool ContainsValue(TValue value);
    public bool ContainsValue(TValue value, IEqualityComparer`1<TValue> valueComparer);
    public void CopyTo(KeyValuePair`2[] array, int index);
    public int EnsureCapacity(int capacity);
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [NullableContextAttribute("2")]
public virtual void OnDeserialization(object sender);
    public void TrimExcess(int capacity);
    public void TrimExcess();
    public bool TryAdd(TKey key, TValue value);
    public bool Remove(TKey key, TValue& value);
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual ICollection`1<TKey> get_Keys();
    public sealed virtual ICollection`1<TValue> get_Values();
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    public sealed virtual void Add(TKey key, TValue value);
    public sealed virtual bool ContainsKey(TKey key);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    public sealed virtual bool Remove(TKey key);
    private void DoAdd(TKey key, TValue value);
    private void DoSet(LinkedListNode`1<KeyValuePair`2<TKey, TValue>> node, TKey key, TValue value);
    private void DoRemove(LinkedListNode`1<KeyValuePair`2<TKey, TValue>> node);
    [NullableContextAttribute("2")]
private static bool IsCompatibleKey(object key);
    private bool TryGetNode(TKey key, TValue value, LinkedListNode`1& node);
    public sealed virtual void Clear();
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.get_IsReadOnly();
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Add(KeyValuePair`2<TKey, TValue> item);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Contains(KeyValuePair`2<TKey, TValue> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.CopyTo(KeyValuePair`2[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Remove(KeyValuePair`2<TKey, TValue> item);
    private sealed virtual override bool System.Collections.IDictionary.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IDictionary.get_IsReadOnly();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    [NullableContextAttribute("2")]
private sealed virtual override object System.Collections.IDictionary.get_Item(object key);
    [NullableContextAttribute("2")]
private sealed virtual override void System.Collections.IDictionary.set_Item(object key, object value);
    [NullableContextAttribute("2")]
private sealed virtual override void System.Collections.IDictionary.Add(object key, object value);
    [NullableContextAttribute("2")]
private sealed virtual override bool System.Collections.IDictionary.Contains(object key);
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    [NullableContextAttribute("2")]
private sealed virtual override void System.Collections.IDictionary.Remove(object key);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Keys();
    private sealed virtual override IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Values();
    public virtual bool Equals(object other, IEqualityComparer comparer);
    public virtual int GetHashCode(IEqualityComparer comparer);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual string ToString(string format, IFormatProvider formatProvider);
    public virtual string ToString();
    public virtual string ToString(IFormatProvider formatProvider);
    public virtual string ToString(string format);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerTypeProxyAttribute("J2N.Collections.Generic.ICollectionDebugView`1")]
[DebuggerDisplayAttribute("Count = {Count}")]
public class J2N.Collections.Generic.LinkedHashSet`1 : object {
    private HashSet`1<T> hashSet;
    private bool requiresTrimExcess;
    public IEqualityComparer`1<T> EqualityComparer { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public LinkedHashSet`1(int capacity);
    public LinkedHashSet`1(IEnumerable`1<T> collection);
    public LinkedHashSet`1(IEqualityComparer`1<T> comparer);
    public LinkedHashSet`1(int capacity, IEqualityComparer`1<T> comparer);
    public LinkedHashSet`1(IEnumerable`1<T> collection, IEqualityComparer`1<T> comparer);
    protected LinkedHashSet`1(SerializationInfo info, StreamingContext context);
    public IEqualityComparer`1<T> get_EqualityComparer();
    public void CopyTo(T[] array);
    public void CopyTo(T[] array, int arrayIndex, int count);
    public static IEqualityComparer`1<ISet`1<T>> CreateSetComparer();
    public int EnsureCapacity(int capacity);
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [NullableContextAttribute("2")]
public virtual void OnDeserialization(object sender);
    public int RemoveWhere(Predicate`1<T> match);
    public void TrimExcess();
    public bool TryGetValue(T equalValue, T& actualValue);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual void ExceptWith(IEnumerable`1<T> other);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    [SecurityCriticalAttribute]
public sealed virtual void IntersectWith(IEnumerable`1<T> other);
    [SecurityCriticalAttribute]
public sealed virtual bool IsProperSubsetOf(IEnumerable`1<T> other);
    [SecurityCriticalAttribute]
public sealed virtual bool IsProperSupersetOf(IEnumerable`1<T> other);
    [SecurityCriticalAttribute]
public sealed virtual bool IsSubsetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsSupersetOf(IEnumerable`1<T> other);
    public sealed virtual bool Overlaps(IEnumerable`1<T> other);
    public sealed virtual bool Remove(T item);
    [SecurityCriticalAttribute]
public sealed virtual bool SetEquals(IEnumerable`1<T> other);
    [SecurityCriticalAttribute]
public sealed virtual void SymmetricExceptWith(IEnumerable`1<T> other);
    public sealed virtual void UnionWith(IEnumerable`1<T> other);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual bool Equals(object other, IEqualityComparer comparer);
    public virtual int GetHashCode(IEqualityComparer comparer);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual string ToString(string format, IFormatProvider formatProvider);
    public virtual string ToString();
    public virtual string ToString(IFormatProvider formatProvider);
    public virtual string ToString(string format);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
[DebuggerTypeProxyAttribute("J2N.Collections.Generic.ICollectionDebugView`1")]
[DebuggerDisplayAttribute("Count = {Count}")]
public class J2N.Collections.Generic.List`1 : object {
    private static int MaxArrayLength;
    private static int DefaultCapacity;
    internal T[] _items;
    internal int _size;
    internal int _version;
    private static T[] s_emptyArray;
    [NullableAttribute("2")]
private SerializationInfo siInfo;
    private static string CountName;
    private static string ItemsName;
    private static string VersionName;
    internal int Offset { get; }
    internal int Size { get; }
    internal int AncestralVersion { get; }
    public int Capacity { get; public set; }
    public int Count { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    internal bool IsReadOnly { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public T Item { get; public set; }
    [NullableAttribute("2")]
private object System.Collections.IList.Item { get; private set; }
    public List`1(IEnumerable`1<T> collection);
    public List`1(int capacity);
    protected List`1(SerializationInfo info, StreamingContext context);
    private static List`1();
    internal virtual int get_Offset();
    internal virtual int get_Size();
    internal virtual int get_AncestralVersion();
    internal virtual void CoModificationCheck();
    public virtual List`1<T> GetView(int index, int count);
    public int get_Capacity();
    public void set_Capacity(int value);
    internal virtual bool DoSetCapacity(int value);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    internal virtual bool get_IsReadOnly();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    internal virtual void DoSet(int index, T value);
    [NullableContextAttribute("2")]
private static bool IsCompatibleObject(object value);
    [NullableContextAttribute("2")]
private static bool NullAndNullsAreIllegal(object value);
    [NullableContextAttribute("2")]
private sealed virtual override object System.Collections.IList.get_Item(int index);
    [NullableContextAttribute("2")]
private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public sealed virtual void Add(T item);
    internal virtual void DoAdd(T item);
    private void AddWithResize(T item);
    [NullableContextAttribute("2")]
private sealed virtual override int System.Collections.IList.Add(object item);
    public void AddRange(IEnumerable`1<T> collection);
    public ReadOnlyList`1<T> AsReadOnly();
    public int BinarySearch(int index, int count, T item, IComparer`1<T> comparer);
    public int BinarySearch(T item);
    public int BinarySearch(T item, IComparer`1<T> comparer);
    public sealed virtual void Clear();
    internal virtual void DoClear();
    public sealed virtual bool Contains(T item);
    [NullableContextAttribute("2")]
private sealed virtual override bool System.Collections.IList.Contains(object item);
    public List`1<TOutput> ConvertAll(Converter`2<T, TOutput> converter);
    public void CopyTo(T[] array);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int arrayIndex);
    public void CopyTo(int index, T[] array, int arrayIndex, int count);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    internal void EnsureCapacity(int min);
    public bool Exists(Predicate`1<T> match);
    public T Find(Predicate`1<T> match);
    public List`1<T> FindAll(Predicate`1<T> match);
    public int FindIndex(Predicate`1<T> match);
    public int FindIndex(int startIndex, Predicate`1<T> match);
    public int FindIndex(int startIndex, int count, Predicate`1<T> match);
    public T FindLast(Predicate`1<T> match);
    public int FindLastIndex(Predicate`1<T> match);
    public int FindLastIndex(int startIndex, Predicate`1<T> match);
    public int FindLastIndex(int startIndex, int count, Predicate`1<T> match);
    public void ForEach(Action`1<T> action);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public List`1<T> GetRange(int index, int count);
    public sealed virtual int IndexOf(T item);
    [NullableContextAttribute("2")]
private sealed virtual override int System.Collections.IList.IndexOf(object item);
    public int IndexOf(T item, int index);
    public int IndexOf(T item, int index, int count);
    public sealed virtual void Insert(int index, T item);
    internal virtual void DoInsert(int index, T item);
    [NullableContextAttribute("2")]
private sealed virtual override void System.Collections.IList.Insert(int index, object item);
    public void InsertRange(int index, IEnumerable`1<T> collection);
    internal virtual int DoInsertRange(int index, IEnumerable`1<T> collection);
    public int LastIndexOf(T item);
    public int LastIndexOf(T item, int index);
    public int LastIndexOf(T item, int index, int count);
    public sealed virtual bool Remove(T item);
    internal virtual bool DoRemove(T item);
    [NullableContextAttribute("2")]
private sealed virtual override void System.Collections.IList.Remove(object item);
    public int RemoveAll(Predicate`1<T> match);
    internal virtual int DoRemoveAll(Predicate`1<T> match);
    internal virtual int DoRemoveAll(int startIndex, int count, Predicate`1<T> match);
    public sealed virtual void RemoveAt(int index);
    internal virtual void DoRemoveAt(int index);
    public void RemoveRange(int index, int count);
    internal virtual void DoRemoveRange(int index, int count);
    public void Reverse();
    public void Reverse(int index, int count);
    internal virtual void DoReverse(int index, int count);
    public void Sort();
    public void Sort(IComparer`1<T> comparer);
    public void Sort(int index, int count, IComparer`1<T> comparer);
    internal virtual void DoSort(int index, int count, IComparer`1<T> comparer);
    public void Sort(Comparison`1<T> comparison);
    internal virtual void DoSort(int index, int count, Comparison`1<T> comparison);
    public T[] ToArray();
    public void TrimExcess();
    public bool TrueForAll(Predicate`1<T> match);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    protected virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [NullableContextAttribute("2")]
private sealed virtual override void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
    [NullableContextAttribute("2")]
protected virtual void OnDeserialization(object sender);
    public virtual bool Equals(object other, IEqualityComparer comparer);
    public virtual int GetHashCode(IEqualityComparer comparer);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual string ToString(string format, IFormatProvider formatProvider);
    public virtual string ToString();
    public virtual string ToString(IFormatProvider formatProvider);
    public virtual string ToString(string format);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class J2N.Collections.Generic.ListEqualityComparer`1 : object {
    private static bool TIsValueType;
    private static bool TIsObject;
    private StructuralEqualityComparer structuralEqualityComparer;
    private Func`2<T, int> getHashCode;
    private Func`3<T, T, bool> equals;
    [CompilerGeneratedAttribute]
private static ListEqualityComparer`1<T> <Default>k__BackingField;
    [CompilerGeneratedAttribute]
private static ListEqualityComparer`1<T> <Aggressive>k__BackingField;
    public static ListEqualityComparer`1<T> Default { get; }
    public static ListEqualityComparer`1<T> Aggressive { get; }
    internal ListEqualityComparer`1(StructuralEqualityComparer structuralEqualityComparer);
    private static ListEqualityComparer`1();
    [CompilerGeneratedAttribute]
public static ListEqualityComparer`1<T> get_Default();
    [CompilerGeneratedAttribute]
public static ListEqualityComparer`1<T> get_Aggressive();
    private void LoadEqualityDelegates();
    public virtual bool Equals(IList`1<T> listA, IList`1<T> listB);
    public virtual int GetHashCode(IList`1<T> list);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(object a, object b);
    [NullableContextAttribute("2")]
public sealed virtual int GetHashCode(object obj);
    public static bool TryGetListEqualityComparer(IEqualityComparer comparer, ListEqualityComparer`1& equalityComparer);
    public static bool Equals(IList`1<T> list, object other, IEqualityComparer comparer);
    public static int GetHashCode(IList`1<T> list, IEqualityComparer comparer);
    [OnDeserializedAttribute]
internal void OnDeserializedMethod(StreamingContext context);
}
internal enum J2N.Collections.Generic.NodeColor : Enum {
    public byte value__;
    public static NodeColor Black;
    public static NodeColor Red;
}
internal class J2N.Collections.Generic.NullableDoubleComparer : EqualityComparer`1<Nullable`1<double>> {
    [NullableAttribute("1")]
public static NullableDoubleComparer Default;
    private static NullableDoubleComparer();
    public sealed virtual int Compare(Nullable`1<double> x, Nullable`1<double> y);
    public virtual bool Equals(Nullable`1<double> x, Nullable`1<double> y);
    public virtual int GetHashCode(Nullable`1<double> obj);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class J2N.Collections.Generic.NullableSingleComparer : EqualityComparer`1<Nullable`1<float>> {
    [NullableAttribute("1")]
public static NullableSingleComparer Default;
    private static NullableSingleComparer();
    public sealed virtual int Compare(Nullable`1<float> x, Nullable`1<float> y);
    public virtual bool Equals(Nullable`1<float> x, Nullable`1<float> y);
    public virtual int GetHashCode(Nullable`1<float> obj);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class J2N.Collections.Generic.PriorityQueue`1 : object {
    private static int DefaultCapacity;
    private static double DefaultInitialCapacityRatio;
    private static int DefaultCapacityRatio;
    private int count;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IComparer`1<T> comparer;
    private IEqualityComparer`1<T> equalityComparer;
    private T[] elements;
    public int Count { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IComparer`1<T> Comparer { get; }
    public IEqualityComparer`1<T> EqualityComparer { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    public PriorityQueue`1(int capacity);
    public PriorityQueue`1(int capacity, IComparer`1<T> comparer);
    public PriorityQueue`1(int capacity, IComparer`1<T> comparer, IEqualityComparer`1<T> equalityComparer);
    public PriorityQueue`1(IComparer`1<T> comparer);
    public PriorityQueue`1(IComparer`1<T> comparer, IEqualityComparer`1<T> equalityComparer);
    public PriorityQueue`1(IEnumerable`1<T> collection);
    public PriorityQueue`1(IEnumerable`1<T> collection, IEqualityComparer`1<T> equalityComparer);
    public PriorityQueue`1(IEnumerable`1<T> collection, IComparer`1<T> comparer, IEqualityComparer`1<T> equalityComparer);
    private void InitFrom(PriorityQueue`1<T> collection);
    private void InitFrom(SortedSet`1<T> collection);
    private void InitFrom(IEnumerable`1<T> collection, IComparer`1<T> comparer);
    public virtual IEnumerator`1<T> GetEnumerator();
    public virtual int get_Count();
    public virtual void Clear();
    public virtual bool Enqueue(T item);
    public virtual T Dequeue();
    public virtual bool TryDequeue(T& result);
    public virtual T Peek();
    public virtual bool TryPeek(T& result);
    public virtual IComparer`1<T> get_Comparer();
    public virtual IEqualityComparer`1<T> get_EqualityComparer();
    public virtual bool Remove(T item);
    public virtual bool Add(T item);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    private static T[] NewElementArray(int capacity);
    private void RemoveAt(int index);
    private int Compare(T o1, T o2);
    private void SiftUp(int childIndex);
    private void SiftDown(int rootIndex);
    private void InitSize(ICollection`1<T> collection);
    private void InitSize(IEnumerable`1<T> collection);
    private void GrowToSize(int size);
    private void ThrowForEmptyQueue();
    public virtual bool AddRange(IEnumerable`1<T> collection);
    private int IndexOf(T o);
    public virtual bool Contains(T item);
    public virtual void CopyTo(T[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [NullableContextAttribute("2")]
public virtual string ToString(string format, IFormatProvider formatProvider);
    public virtual string ToString();
    public virtual string ToString(IFormatProvider formatProvider);
    public virtual string ToString(string format);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class J2N.Collections.Generic.SetEqualityComparer`1 : object {
    private static bool TIsValueType;
    private static bool TIsObject;
    private StructuralEqualityComparer structuralEqualityComparer;
    private Func`2<T, int> getHashCode;
    private Func`3<T, T, bool> equals;
    [CompilerGeneratedAttribute]
private static SetEqualityComparer`1<T> <Default>k__BackingField;
    [CompilerGeneratedAttribute]
private static SetEqualityComparer`1<T> <Aggressive>k__BackingField;
    public static SetEqualityComparer`1<T> Default { get; }
    public static SetEqualityComparer`1<T> Aggressive { get; }
    internal SetEqualityComparer`1(StructuralEqualityComparer structuralEqualityComparer);
    private static SetEqualityComparer`1();
    [CompilerGeneratedAttribute]
public static SetEqualityComparer`1<T> get_Default();
    [CompilerGeneratedAttribute]
public static SetEqualityComparer`1<T> get_Aggressive();
    private void LoadEqualityDelegates();
    public virtual bool Equals(ISet`1<T> setA, ISet`1<T> setB);
    public virtual int GetHashCode(ISet`1<T> set);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(object a, object b);
    [NullableContextAttribute("2")]
public sealed virtual int GetHashCode(object obj);
    public static bool TryGetSetEqualityComparer(IEqualityComparer comparer, SetEqualityComparer`1& equalityComparer);
    public static bool Equals(ISet`1<T> set, object other, IEqualityComparer comparer);
    public static int GetHashCode(ISet`1<T> set, IEqualityComparer comparer);
    [OnDeserializedAttribute]
internal void OnDeserializedMethod(StreamingContext context);
}
internal class J2N.Collections.Generic.SingleComparer : EqualityComparer`1<float> {
    [NullableAttribute("1")]
public static SingleComparer Default;
    private static SingleComparer();
    public sealed virtual int Compare(float x, float y);
    public virtual bool Equals(float x, float y);
    public virtual int GetHashCode(float obj);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
[DebuggerTypeProxyAttribute("J2N.Collections.Generic.IDictionaryDebugView`2")]
[DebuggerDisplayAttribute("Count = {Count}")]
public class J2N.Collections.Generic.SortedDictionary`2 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private KeyCollection<TKey, TValue> _keys;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ValueCollection<TKey, TValue> _values;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private TreeSet`1<KeyValuePair`2<TKey, TValue>> _set;
    private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.IsReadOnly { get; }
    public TValue Item { get; public set; }
    public int Count { get; }
    public IComparer`1<TKey> Comparer { get; }
    public ICollection`1<TKey> Keys { get; }
    private ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.Keys { get; }
    private IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Keys { get; }
    public ICollection`1<TValue> Values { get; }
    private ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.Values { get; }
    private IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Values { get; }
    private bool System.Collections.IDictionary.IsFixedSize { get; }
    private bool System.Collections.IDictionary.IsReadOnly { get; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    [NullableAttribute("2")]
private object System.Collections.IDictionary.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public SortedDictionary`2(IDictionary`2<TKey, TValue> dictionary);
    public SortedDictionary`2(IDictionary`2<TKey, TValue> dictionary, IComparer`1<TKey> comparer);
    public SortedDictionary`2(IComparer`1<TKey> comparer);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Add(KeyValuePair`2<TKey, TValue> keyValuePair);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Contains(KeyValuePair`2<TKey, TValue> keyValuePair);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Remove(KeyValuePair`2<TKey, TValue> keyValuePair);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.get_IsReadOnly();
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    public sealed virtual int get_Count();
    public IComparer`1<TKey> get_Comparer();
    public ICollection`1<TKey> get_Keys();
    private sealed virtual override ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.get_Keys();
    private sealed virtual override IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Keys();
    public ICollection`1<TValue> get_Values();
    private sealed virtual override ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.get_Values();
    private sealed virtual override IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Values();
    public sealed virtual void Add(TKey key, TValue value);
    public sealed virtual void Clear();
    public sealed virtual bool ContainsKey(TKey key);
    public bool ContainsValue(TValue value);
    public bool ContainsValue(TValue value, IEqualityComparer`1<TValue> valueComparer);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int index);
    [NullableContextAttribute("0")]
public Enumerator<TKey, TValue> GetEnumerator();
    private sealed virtual override IEnumerator`1<KeyValuePair`2<TKey, TValue>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TValue>>.GetEnumerator();
    public sealed virtual bool Remove(TKey key);
    public bool Remove(TKey key, TValue& value);
    public bool TryAdd(TKey key, TValue value);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.IDictionary.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IDictionary.get_IsReadOnly();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    private sealed virtual override object System.Collections.IDictionary.get_Item(object key);
    private sealed virtual override void System.Collections.IDictionary.set_Item(object key, object value);
    [NullableContextAttribute("2")]
private sealed virtual override void System.Collections.IDictionary.Add(object key, object value);
    [NullableContextAttribute("2")]
private sealed virtual override bool System.Collections.IDictionary.Contains(object key);
    [NullableContextAttribute("2")]
private static bool IsCompatibleKey(object key);
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    [NullableContextAttribute("2")]
private sealed virtual override void System.Collections.IDictionary.Remove(object key);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public bool TryGetPredecessor(TKey key, KeyValuePair`2& result);
    public bool TryGetSuccessor(TKey key, KeyValuePair`2& result);
    public virtual bool Equals(object other, IEqualityComparer comparer);
    public virtual int GetHashCode(IEqualityComparer comparer);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual string ToString(string format, IFormatProvider formatProvider);
    public virtual string ToString();
    public virtual string ToString(IFormatProvider formatProvider);
    public virtual string ToString(string format);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerTypeProxyAttribute("J2N.Collections.Generic.ICollectionDebugView`1")]
[DebuggerDisplayAttribute("Count = {Count}")]
public class J2N.Collections.Generic.SortedSet`1 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Node<T> root;
    private IComparer`1<T> comparer;
    private int count;
    private int version;
    private static string ComparerName;
    private static string CountName;
    private static string ItemsName;
    private static string VersionName;
    private static string TreeName;
    private static string NodeValueName;
    private static string EnumStartName;
    private static string ReverseName;
    private static string EnumVersionName;
    private static string minName;
    private static string maxName;
    private static string lBoundActiveName;
    private static string uBoundActiveName;
    private static string lBoundInclusiveName;
    private static string uBoundInclusiveName;
    [NullableAttribute("2")]
private SerializationInfo siInfo;
    internal static int StackAllocThreshold;
    public int Count { get; }
    public IComparer`1<T> Comparer { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public T Min { get; }
    internal T MinInternal { get; }
    public T Max { get; }
    internal T MaxInternal { get; }
    public SortedSet`1(IComparer`1<T> comparer);
    public SortedSet`1(IEnumerable`1<T> collection);
    public SortedSet`1(IEnumerable`1<T> collection, IComparer`1<T> comparer);
    protected SortedSet`1(SerializationInfo info, StreamingContext context);
    private void AddAllElements(IEnumerable`1<T> collection);
    private void RemoveAllElements(IEnumerable`1<T> collection);
    private bool ContainsAllElements(IEnumerable`1<T> collection);
    internal virtual bool InOrderTreeWalk(TreeWalkPredicate`1<T> action);
    internal virtual bool BreadthFirstTreeWalk(TreeWalkPredicate`1<T> action);
    public sealed virtual int get_Count();
    public IComparer`1<T> get_Comparer();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    internal virtual void VersionCheck(bool updateCount);
    internal virtual int TotalCount();
    internal virtual bool IsWithinRange(T item);
    public bool TryGetPredecessor(T item, T& result);
    public bool TryGetSuccessor(T item, T& result);
    public sealed virtual bool Add(T item);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    internal virtual bool AddIfNotPresent(T item);
    public sealed virtual bool Remove(T item);
    internal virtual bool DoRemove(T item);
    public virtual void Clear();
    public virtual bool Contains(T item);
    public void CopyTo(T[] array);
    public sealed virtual void CopyTo(T[] array, int index);
    public void CopyTo(T[] array, int index, int count);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private void InsertionBalance(Node<T> current, Node& parent, Node<T> grandParent, Node<T> greatGrandParent);
    private void ReplaceChildOrRoot(Node<T> parent, Node<T> child, Node<T> newChild);
    private void ReplaceNode(Node<T> match, Node<T> parentOfMatch, Node<T> successor, Node<T> parentOfSuccessor);
    internal virtual Node<T> FindNode(T item);
    internal virtual int InternalIndexOf(T item);
    internal Node<T> FindRange(T from, T to);
    internal Node<T> FindRange(T from, T to, bool lowerBoundInclusive, bool upperBoundInclusive, bool lowerBoundActive, bool upperBoundActive);
    internal void UpdateVersion();
    public static IEqualityComparer`1<SortedSet`1<T>> CreateSetComparer();
    public static IEqualityComparer`1<SortedSet`1<T>> CreateSetComparer(IEqualityComparer`1<T> memberEqualityComparer);
    internal static bool SortedSetEquals(SortedSet`1<T> set1, SortedSet`1<T> set2, IComparer`1<T> comparer);
    private bool HasEqualComparer(SortedSet`1<T> other);
    public sealed virtual void UnionWith(IEnumerable`1<T> other);
    private static Node<T> ConstructRootFromSortedArray(T[] arr, int startIndex, int endIndex, Node<T> redNode);
    public virtual void IntersectWith(IEnumerable`1<T> other);
    internal virtual void IntersectWithEnumerable(IEnumerable`1<T> other);
    public sealed virtual void ExceptWith(IEnumerable`1<T> other);
    public sealed virtual void SymmetricExceptWith(IEnumerable`1<T> other);
    private void SymmetricExceptWithSameComparer(SortedSet`1<T> other);
    private void SymmetricExceptWithSameComparer(T[] other, int count);
    public sealed virtual bool IsSubsetOf(IEnumerable`1<T> other);
    private bool IsSubsetOfSortedSetWithSameComparer(SortedSet`1<T> asSorted);
    public sealed virtual bool IsProperSubsetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsSupersetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsProperSupersetOf(IEnumerable`1<T> other);
    public sealed virtual bool SetEquals(IEnumerable`1<T> other);
    public sealed virtual bool Overlaps(IEnumerable`1<T> other);
    [NullableContextAttribute("0")]
private ElementCount<T> CheckUniqueAndUnfoundElements(IEnumerable`1<T> other, bool returnIfUnfound);
    public int RemoveWhere(Predicate`1<T> match);
    public T get_Min();
    internal virtual T get_MinInternal();
    public T get_Max();
    internal virtual T get_MaxInternal();
    [IteratorStateMachineAttribute("J2N.Collections.Generic.SortedSet`1/<Reverse>d__97")]
public IEnumerable`1<T> Reverse();
    public virtual SortedSet`1<T> GetViewBetween(T lowerValue, T upperValue);
    public virtual SortedSet`1<T> GetViewBetween(T lowerValue, bool lowerValueInclusive, T upperValue, bool upperValueInclusive);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    protected virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [NullableContextAttribute("2")]
private sealed virtual override void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
    [NullableContextAttribute("2")]
protected virtual void OnDeserialization(object sender);
    public bool TryGetValue(T equalValue, T& actualValue);
    private static int Log2(int value);
    public virtual bool Equals(object other, IEqualityComparer comparer);
    public virtual int GetHashCode(IEqualityComparer comparer);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual string ToString(string format, IFormatProvider formatProvider);
    public virtual string ToString();
    public virtual string ToString(IFormatProvider formatProvider);
    public virtual string ToString(string format);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class J2N.Collections.Generic.SortedSetEqualityComparer`1 : object {
    private IComparer`1<T> _comparer;
    private IEqualityComparer`1<T> _memberEqualityComparer;
    public SortedSetEqualityComparer`1(IEqualityComparer`1<T> memberEqualityComparer);
    private SortedSetEqualityComparer`1(IComparer`1<T> comparer, IEqualityComparer`1<T> memberEqualityComparer);
    public sealed virtual bool Equals(SortedSet`1<T> x, SortedSet`1<T> y);
    public sealed virtual int GetHashCode(SortedSet`1<T> obj);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
[DebuggerTypeProxyAttribute("J2N.Collections.Generic.ICollectionDebugView`1")]
[DebuggerDisplayAttribute("Count = {Count}")]
internal class J2N.Collections.Generic.SubList`1 : object {
    internal IList`1<T> parent;
    private int parentOffset;
    private int size;
    private int version;
    private int parentCount;
    public T Item { get; public set; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public SubList`1(IList`1<T> parent, int index, int count);
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int index);
    [NullableContextAttribute("0")]
public Enumerator<T> GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual int IndexOf(T item);
    private int IndexOfSlow(T item, int startIndex, int count);
    public sealed virtual void Insert(int index, T item);
    public sealed virtual bool Remove(T item);
    public sealed virtual void RemoveAt(int index);
    private void CoModificationCheck();
    public virtual bool Equals(object other, IEqualityComparer comparer);
    public virtual int GetHashCode(IEqualityComparer comparer);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual string ToString(string format, IFormatProvider formatProvider);
    public virtual string ToString();
    public virtual string ToString(IFormatProvider formatProvider);
    public virtual string ToString(string format);
}
internal enum J2N.Collections.Generic.TreeRotation : Enum {
    public byte value__;
    public static TreeRotation Left;
    public static TreeRotation LeftRight;
    public static TreeRotation Right;
    public static TreeRotation RightLeft;
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class J2N.Collections.Generic.TreeSet`1 : SortedSet`1<T> {
    public TreeSet`1(IComparer`1<T> comparer);
    private TreeSet`1(SerializationInfo siInfo, StreamingContext context);
    internal virtual bool AddIfNotPresent(T item);
}
internal class J2N.Collections.Generic.TreeWalkPredicate`1 : MulticastDelegate {
    public TreeWalkPredicate`1(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual bool Invoke(Node<T> node);
    public virtual IAsyncResult BeginInvoke(Node<T> node, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class J2N.Collections.ObjectModel.ReadOnlyCollection`1 : object {
    private static bool TIsValueTypeOrStringOrStructuralEquatable;
    internal ICollection`1<T> collection;
    private StructuralEqualityComparer structuralEqualityComparer;
    private IFormatProvider toStringFormatProvider;
    [NullableAttribute("2")]
private object syncRoot;
    protected ICollection`1<T> Items { get; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    public ReadOnlyCollection`1(ICollection`1<T> collection);
    internal ReadOnlyCollection`1(ICollection`1<T> collection, StructuralEqualityComparer structuralEqualityComparer, IFormatProvider toStringFormatProvider);
    private static ReadOnlyCollection`1();
    protected ICollection`1<T> get_Items();
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int index);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.Remove(T item);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual bool Equals(object other, IEqualityComparer comparer);
    public virtual int GetHashCode(IEqualityComparer comparer);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual string ToString(string format, IFormatProvider formatProvider);
    public virtual string ToString();
    public virtual string ToString(IFormatProvider formatProvider);
    public virtual string ToString(string format);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
[DebuggerTypeProxyAttribute("J2N.Collections.Generic.IDictionaryDebugView`2")]
[DebuggerDisplayAttribute("Count = {Count}")]
public class J2N.Collections.ObjectModel.ReadOnlyDictionary`2 : object {
    private static bool TKeyIsValueTypeOrStringOrStructuralEquatable;
    private static bool TValueIsValueTypeOrStringOrStructuralEquatable;
    private static bool TKeyIsNullable;
    internal IDictionary`2<TKey, TValue> dictionary;
    private DictionaryEqualityComparer`2<TKey, TValue> structuralEqualityComparer;
    private IFormatProvider toStringFormatProvider;
    [NullableAttribute("2")]
private object syncRoot;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private KeyCollection<TKey, TValue> keys;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ValueCollection<TKey, TValue> values;
    protected internal IDictionary`2<TKey, TValue> Dictionary { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public KeyCollection<TKey, TValue> Keys { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ValueCollection<TKey, TValue> Values { get; }
    private ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.Keys { get; }
    private ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.Values { get; }
    public TValue Item { get; }
    private TValue System.Collections.Generic.IDictionary<TKey,TValue>.Item { get; private set; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.IsReadOnly { get; }
    private bool System.Collections.IDictionary.IsFixedSize { get; }
    private bool System.Collections.IDictionary.IsReadOnly { get; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    [NullableAttribute("2")]
private object System.Collections.IDictionary.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Keys { get; }
    private IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Values { get; }
    public ReadOnlyDictionary`2(IDictionary`2<TKey, TValue> dictionary);
    internal ReadOnlyDictionary`2(IDictionary`2<TKey, TValue> dictionary, DictionaryEqualityComparer`2<TKey, TValue> structuralEqualityComparer, IFormatProvider toStringFormatProvider);
    private static ReadOnlyDictionary`2();
    protected internal IDictionary`2<TKey, TValue> get_Dictionary();
    public KeyCollection<TKey, TValue> get_Keys();
    public ValueCollection<TKey, TValue> get_Values();
    public sealed virtual bool ContainsKey(TKey key);
    private sealed virtual override ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.get_Keys();
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    private sealed virtual override ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.get_Values();
    public sealed virtual TValue get_Item(TKey key);
    private sealed virtual override void System.Collections.Generic.IDictionary<TKey,TValue>.Add(TKey key, TValue value);
    private sealed virtual override bool System.Collections.Generic.IDictionary<TKey,TValue>.Remove(TKey key);
    private sealed virtual override TValue System.Collections.Generic.IDictionary<TKey,TValue>.get_Item(TKey key);
    private sealed virtual override void System.Collections.Generic.IDictionary<TKey,TValue>.set_Item(TKey key, TValue value);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Contains(KeyValuePair`2<TKey, TValue> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.CopyTo(KeyValuePair`2[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.get_IsReadOnly();
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Add(KeyValuePair`2<TKey, TValue> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Remove(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [NullableContextAttribute("2")]
private static bool IsCompatibleKey(object key);
    [NullableContextAttribute("2")]
private sealed virtual override void System.Collections.IDictionary.Add(object key, object value);
    private sealed virtual override void System.Collections.IDictionary.Clear();
    private sealed virtual override bool System.Collections.IDictionary.Contains(object key);
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    private sealed virtual override bool System.Collections.IDictionary.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IDictionary.get_IsReadOnly();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    private sealed virtual override void System.Collections.IDictionary.Remove(object key);
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    private sealed virtual override object System.Collections.IDictionary.get_Item(object key);
    private sealed virtual override void System.Collections.IDictionary.set_Item(object key, object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Keys();
    private sealed virtual override IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Values();
    public virtual bool Equals(object other, IEqualityComparer comparer);
    public virtual int GetHashCode(IEqualityComparer comparer);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual string ToString(string format, IFormatProvider formatProvider);
    public virtual string ToString();
    public virtual string ToString(IFormatProvider formatProvider);
    public virtual string ToString(string format);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class J2N.Collections.ObjectModel.ReadOnlyList`1 : ReadOnlyCollection`1<T> {
    private static bool TIsValueTypeOrStringOrStructuralEquatable;
    private ListEqualityComparer`1<T> structuralEqualityComparer;
    private IFormatProvider toStringFormatProvider;
    internal IList`1<T> List { get; }
    public ReadOnlyList`1(IList`1<T> list);
    internal ReadOnlyList`1(IList`1<T> list, ListEqualityComparer`1<T> structuralEqualityComparer, IFormatProvider toStringFormatProvider);
    private static ReadOnlyList`1();
    internal IList`1<T> get_List();
    public virtual bool Equals(object other, IEqualityComparer comparer);
    public virtual int GetHashCode(IEqualityComparer comparer);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual string ToString(string format, IFormatProvider formatProvider);
    public virtual string ToString();
    public virtual string ToString(IFormatProvider formatProvider);
    public virtual string ToString(string format);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class J2N.Collections.ObjectModel.ReadOnlySet`1 : object {
    private static bool TIsValueTypeOrStringOrStructuralEquatable;
    private ISet`1<T> set;
    private SetEqualityComparer`1<T> structuralEqualityComparer;
    private IFormatProvider toStringFormatProvider;
    [NullableAttribute("2")]
private object syncRoot;
    protected internal ISet`1<T> Items { get; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public ReadOnlySet`1(ISet`1<T> set);
    internal ReadOnlySet`1(ISet`1<T> set, SetEqualityComparer`1<T> structuralEqualityComparer, IFormatProvider toStringFormatProvider);
    private static ReadOnlySet`1();
    protected internal ISet`1<T> get_Items();
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int index);
    private sealed virtual override void System.Collections.Generic.ISet<T>.ExceptWith(IEnumerable`1<T> other);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override void System.Collections.Generic.ISet<T>.IntersectWith(IEnumerable`1<T> other);
    [SecurityCriticalAttribute]
public sealed virtual bool IsProperSubsetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsProperSupersetOf(IEnumerable`1<T> other);
    [SecurityCriticalAttribute]
public sealed virtual bool IsSubsetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsSupersetOf(IEnumerable`1<T> other);
    public sealed virtual bool Overlaps(IEnumerable`1<T> other);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.Remove(T item);
    [SecurityCriticalAttribute]
public sealed virtual bool SetEquals(IEnumerable`1<T> other);
    private sealed virtual override void System.Collections.Generic.ISet<T>.SymmetricExceptWith(IEnumerable`1<T> other);
    private sealed virtual override void System.Collections.Generic.ISet<T>.UnionWith(IEnumerable`1<T> other);
    private sealed virtual override bool System.Collections.Generic.ISet<T>.Add(T item);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public virtual bool Equals(object other, IEqualityComparer comparer);
    public virtual int GetHashCode(IEqualityComparer comparer);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual string ToString(string format, IFormatProvider formatProvider);
    public virtual string ToString();
    public virtual string ToString(IFormatProvider formatProvider);
    public virtual string ToString(string format);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class J2N.Collections.OneDimensionalArrayEqualityComparer`1 : object {
    [CompilerGeneratedAttribute]
private static IEqualityComparer`1<T[]> <Default>k__BackingField;
    public static IEqualityComparer`1<T[]> Default { get; }
    private static OneDimensionalArrayEqualityComparer`1();
    [CompilerGeneratedAttribute]
public static IEqualityComparer`1<T[]> get_Default();
    private static IEqualityComparer`1<T[]> LoadDefault();
    public abstract virtual bool Equals(T[] array1, T[] array2);
    public abstract virtual int GetHashCode(T[] array);
    [NullableContextAttribute("2")]
private sealed virtual override int System.Collections.IEqualityComparer.GetHashCode(object array);
    [NullableContextAttribute("2")]
private sealed virtual override bool System.Collections.IEqualityComparer.Equals(object array1, object array2);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class J2N.Collections.StructuralEqualityComparer : object {
    [CompilerGeneratedAttribute]
private static StructuralEqualityComparer <Default>k__BackingField;
    [CompilerGeneratedAttribute]
private static StructuralEqualityComparer <Aggressive>k__BackingField;
    public static StructuralEqualityComparer Default { get; }
    public static StructuralEqualityComparer Aggressive { get; }
    private static StructuralEqualityComparer();
    [CompilerGeneratedAttribute]
public static StructuralEqualityComparer get_Default();
    [CompilerGeneratedAttribute]
public static StructuralEqualityComparer get_Aggressive();
    [NullableContextAttribute("2")]
public virtual bool Equals(object x, object y);
    private bool ArrayEquals(Array arrayX, Array arrayY);
    [NullableContextAttribute("2")]
public virtual int GetHashCode(object obj);
    private int GetArrayHashCode(Array array);
    [NullableContextAttribute("2")]
protected abstract virtual bool UnstructuredEquals(object x, object y);
    [NullableContextAttribute("2")]
protected abstract virtual int GetUnstructuredHashCode(object obj);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class J2N.Collections.StructuralEqualityUtil : object {
    internal static Func`2<T, int> LoadGetHashCodeDelegate(bool isValueType, bool isObject, StructuralEqualityComparer structuralEqualityComparer);
    internal static Func`3<T, T, bool> LoadEqualsDelegate(bool isValueType, bool isObject, StructuralEqualityComparer structuralEqualityComparer);
    internal static bool IsValueType(TElement value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class J2N.DoubleExtensions : object {
    [ExtensionAttribute]
public static bool IsFinite(double d);
    [ExtensionAttribute]
public static bool IsInfinity(double d);
    [ExtensionAttribute]
public static bool IsNaN(double d);
    [ExtensionAttribute]
public static bool IsNegative(double d);
    [ExtensionAttribute]
public static bool IsNegativeInfinity(double d);
    [ExtensionAttribute]
public static bool IsNegativeZero(double d);
    [ExtensionAttribute]
public static bool IsNormal(double d);
    [ExtensionAttribute]
public static bool IsPositiveInfinity(double d);
    [ExtensionAttribute]
public static bool IsSubnormal(double d);
    [ExtensionAttribute]
public static string ToHexString(double value, IFormatProvider provider);
    [ExtensionAttribute]
internal static string ToHexString(double value, NumberFormatInfo info, bool upperCase);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class J2N.Globalization.CultureContext : object {
    private CultureInfo originalCulture;
    private CultureInfo originalUICulture;
    public CultureInfo OriginalCulture { get; }
    public CultureInfo OriginalUICulture { get; }
    public CultureContext(int culture);
    public CultureContext(int culture, int uiCulture);
    public CultureContext(string cultureName);
    public CultureContext(string cultureName, string uiCultureName);
    public CultureContext(CultureInfo culture);
    public CultureContext(CultureInfo culture, CultureInfo uiCulture);
    public CultureInfo get_OriginalCulture();
    public CultureInfo get_OriginalUICulture();
    public void RestoreOriginalCulture();
    public sealed virtual void Dispose();
}
[FlagsAttribute]
public enum J2N.Globalization.NumberStyle : Enum {
    public int value__;
    public static NumberStyle None;
    public static NumberStyle AllowLeadingWhite;
    public static NumberStyle AllowTrailingWhite;
    public static NumberStyle AllowLeadingSign;
    public static NumberStyle AllowTrailingSign;
    public static NumberStyle AllowParentheses;
    public static NumberStyle AllowDecimalPoint;
    public static NumberStyle AllowThousands;
    public static NumberStyle AllowExponent;
    public static NumberStyle AllowCurrencySymbol;
    public static NumberStyle AllowHexSpecifier;
    public static NumberStyle AllowTypeSpecifier;
    public static NumberStyle Integer;
    public static NumberStyle HexNumber;
    public static NumberStyle Number;
    public static NumberStyle Float;
    public static NumberStyle HexFloat;
    public static NumberStyle Currency;
    public static NumberStyle Any;
}
[ExtensionAttribute]
public static class J2N.Globalization.NumberStyleExtensions : object {
    private static NumberStyle ValidNumberStyles;
    private static NumberStyle ValidNumberStyle;
    [ExtensionAttribute]
public static NumberStyles ToNumberStyles(NumberStyle style);
    [ExtensionAttribute]
public static NumberStyle ToNumberStyle(NumberStyles style);
    internal static void ValidateParseStyleInteger(NumberStyle style);
    internal static void ValidateParseStyleFloatingPoint(NumberStyle style);
    [CompilerGeneratedAttribute]
internal static void <ValidateParseStyleInteger>g__throwInvalid|4_0(NumberStyle value);
    [CompilerGeneratedAttribute]
internal static void <ValidateParseStyleFloatingPoint>g__throwInvalid|5_0(NumberStyle value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class J2N.IntegralNumberExtensions : object {
    [ExtensionAttribute]
public static string ToBinaryString(char value);
    [ExtensionAttribute]
public static string ToBinaryString(short value);
    [ExtensionAttribute]
public static string ToBinaryString(int value);
    [ExtensionAttribute]
public static string ToBinaryString(long value);
    [ExtensionAttribute]
public static string ToHexString(char value);
    [ExtensionAttribute]
public static string ToHexString(short value);
    [ExtensionAttribute]
public static string ToHexString(int value);
    [ExtensionAttribute]
public static string ToHexString(long value);
    [ExtensionAttribute]
public static string ToOctalString(char value);
    [ExtensionAttribute]
public static string ToOctalString(short value);
    [ExtensionAttribute]
public static string ToOctalString(int value);
    [ExtensionAttribute]
public static string ToOctalString(long value);
    [ExtensionAttribute]
public static string ToString(int value, int radix);
    [ExtensionAttribute]
public static string ToString(long value, int radix);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class J2N.IO.Buffer : object {
    internal static int UnsetMark;
    internal int capacity;
    internal int limit;
    internal int mark;
    internal int position;
    public int Capacity { get; }
    public bool HasRemaining { get; }
    public bool IsReadOnly { get; }
    public int Limit { get; public set; }
    public int Position { get; public set; }
    public int Remaining { get; }
    internal Buffer(int capacity);
    public int get_Capacity();
    public Buffer Clear();
    public Buffer Flip();
    public bool get_HasRemaining();
    public abstract virtual bool get_IsReadOnly();
    public int get_Limit();
    public void set_Limit(int value);
    public Buffer SetLimit(int newLimit);
    public Buffer Mark();
    public int get_Position();
    public void set_Position(int value);
    public Buffer SetPosition(int newPosition);
    public int get_Remaining();
    public Buffer Reset();
    public Buffer Rewind();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class J2N.IO.BufferOverflowException : Exception {
    public BufferOverflowException(string message);
    public BufferOverflowException(string message, Exception innerException);
    private BufferOverflowException(SerializationInfo info, StreamingContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class J2N.IO.BufferUnderflowException : Exception {
    public BufferUnderflowException(string message);
    public BufferUnderflowException(string message, Exception innerException);
    private BufferUnderflowException(SerializationInfo info, StreamingContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class J2N.IO.ByteBuffer : Buffer {
    internal Endianness order;
    public Byte[] Array { get; }
    public int ArrayOffset { get; }
    public bool HasArray { get; }
    public ByteOrder Order { get; public set; }
    protected Byte[] ProtectedArray { get; }
    protected int ProtectedArrayOffset { get; }
    protected bool ProtectedHasArray { get; }
    internal ByteBuffer(int capacity);
    public static ByteBuffer Allocate(int capacity);
    public static ByteBuffer Wrap(Byte[] array);
    public static ByteBuffer Wrap(Byte[] array, int startIndex, int length);
    public Byte[] get_Array();
    public int get_ArrayOffset();
    public abstract virtual CharBuffer AsCharBuffer();
    public abstract virtual DoubleBuffer AsDoubleBuffer();
    public abstract virtual SingleBuffer AsSingleBuffer();
    public abstract virtual Int32Buffer AsInt32Buffer();
    public abstract virtual Int64Buffer AsInt64Buffer();
    public abstract virtual ByteBuffer AsReadOnlyBuffer();
    public abstract virtual Int16Buffer AsInt16Buffer();
    public abstract virtual ByteBuffer Compact();
    [NullableContextAttribute("2")]
public virtual int CompareTo(ByteBuffer other);
    public abstract virtual ByteBuffer Duplicate();
    [NullableContextAttribute("2")]
public virtual bool Equals(object other);
    public abstract virtual byte Get();
    public virtual ByteBuffer Get(Byte[] destination);
    public virtual ByteBuffer Get(Byte[] destination, int offset, int length);
    public abstract virtual byte Get(int index);
    public abstract virtual char GetChar();
    public abstract virtual char GetChar(int index);
    public abstract virtual double GetDouble();
    public abstract virtual double GetDouble(int index);
    public abstract virtual float GetSingle();
    public abstract virtual float GetSingle(int index);
    public abstract virtual int GetInt32();
    public abstract virtual int GetInt32(int index);
    public abstract virtual long GetInt64();
    public abstract virtual long GetInt64(int index);
    public abstract virtual short GetInt16();
    public abstract virtual short GetInt16(int index);
    public bool get_HasArray();
    public virtual int GetHashCode();
    public ByteOrder get_Order();
    public void set_Order(ByteOrder value);
    public ByteBuffer SetOrder(ByteOrder byteOrder);
    protected abstract virtual Byte[] get_ProtectedArray();
    protected abstract virtual int get_ProtectedArrayOffset();
    protected abstract virtual bool get_ProtectedHasArray();
    public abstract virtual ByteBuffer Put(byte b);
    public ByteBuffer Put(Byte[] source);
    public virtual ByteBuffer Put(Byte[] source, int offset, int length);
    public virtual ByteBuffer Put(ByteBuffer source);
    public abstract virtual ByteBuffer Put(int index, byte value);
    public abstract virtual ByteBuffer PutChar(char value);
    public abstract virtual ByteBuffer PutChar(int index, char value);
    public abstract virtual ByteBuffer PutDouble(double value);
    public abstract virtual ByteBuffer PutDouble(int index, double value);
    public abstract virtual ByteBuffer PutSingle(float value);
    public abstract virtual ByteBuffer PutSingle(int index, float value);
    public abstract virtual ByteBuffer PutInt32(int value);
    public abstract virtual ByteBuffer PutInt32(int index, int value);
    public abstract virtual ByteBuffer PutInt64(long value);
    public abstract virtual ByteBuffer PutInt64(int index, long value);
    public abstract virtual ByteBuffer PutInt16(short value);
    public abstract virtual ByteBuffer PutInt16(int index, short value);
    public abstract virtual ByteBuffer Slice();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class J2N.IO.ByteOrder : object {
    public static ByteOrder BigEndian;
    public static ByteOrder LittleEndian;
    [CompilerGeneratedAttribute]
private static ByteOrder <NativeOrder>k__BackingField;
    private string name;
    public static ByteOrder NativeOrder { get; private set; }
    private ByteOrder(string name);
    private static ByteOrder();
    [CompilerGeneratedAttribute]
public static ByteOrder get_NativeOrder();
    [CompilerGeneratedAttribute]
private static void set_NativeOrder(ByteOrder value);
    private static ByteOrder LoadNativeByteOrder();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class J2N.IO.CharArrayBuffer : CharBuffer {
    protected internal Char[] backingArray;
    protected internal int offset;
    public ByteOrder Order { get; }
    internal CharArrayBuffer(Char[] array);
    internal CharArrayBuffer(int capacity);
    internal CharArrayBuffer(int capacity, Char[] backingArray, int offset);
    public sealed virtual char Get();
    public sealed virtual char Get(int index);
    public sealed virtual CharBuffer Get(Char[] destination, int offset, int length);
    public sealed virtual ByteOrder get_Order();
    public sealed virtual CharBuffer Subsequence(int startIndex, int length);
    public sealed virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public abstract class J2N.IO.CharBuffer : Buffer {
    public Char[] Array { get; }
    public int ArrayOffset { get; }
    public char Item { get; }
    public bool HasArray { get; }
    private bool J2N.Text.ICharSequence.HasValue { get; }
    public int Length { get; }
    public ByteOrder Order { get; }
    protected Char[] ProtectedArray { get; }
    protected int ProtectedArrayOffset { get; }
    protected bool ProtectedHasArray { get; }
    internal CharBuffer(int capacity);
    public static CharBuffer Allocate(int capacity);
    public static CharBuffer Wrap(Char[] array);
    public static CharBuffer Wrap(Char[] array, int startIndex, int length);
    public static CharBuffer Wrap(string characterSequence);
    public static CharBuffer Wrap(string characterSequence, int startIndex, int length);
    public static CharBuffer Wrap(StringBuilder characterSequence);
    public static CharBuffer Wrap(StringBuilder characterSequence, int startIndex, int length);
    public static CharBuffer Wrap(ICharSequence characterSequence);
    public static CharBuffer Wrap(ICharSequence characterSequence, int startIndex, int length);
    public Char[] get_Array();
    public int get_ArrayOffset();
    public abstract virtual CharBuffer AsReadOnlyBuffer();
    public sealed virtual char get_Item(int index);
    public abstract virtual CharBuffer Compact();
    [NullableContextAttribute("2")]
public virtual int CompareTo(CharBuffer other);
    public abstract virtual CharBuffer Duplicate();
    [NullableContextAttribute("2")]
public virtual bool Equals(object other);
    public abstract virtual char Get();
    public virtual CharBuffer Get(Char[] destination);
    public virtual CharBuffer Get(Char[] destination, int offset, int length);
    public abstract virtual char Get(int index);
    public bool get_HasArray();
    private sealed virtual override bool J2N.Text.ICharSequence.get_HasValue();
    public virtual int GetHashCode();
    public sealed virtual int get_Length();
    public abstract virtual ByteOrder get_Order();
    protected abstract virtual Char[] get_ProtectedArray();
    protected abstract virtual int get_ProtectedArrayOffset();
    protected abstract virtual bool get_ProtectedHasArray();
    public abstract virtual CharBuffer Put(char c);
    public CharBuffer Put(Char[] source);
    public virtual CharBuffer Put(Char[] source, int offset, int length);
    public virtual CharBuffer Put(CharBuffer source);
    public abstract virtual CharBuffer Put(int index, char value);
    public CharBuffer Put(string source);
    public virtual CharBuffer Put(string source, int startIndex, int length);
    public abstract virtual CharBuffer Slice();
    public abstract virtual CharBuffer Subsequence(int startIndex, int length);
    private sealed virtual override ICharSequence J2N.Text.ICharSequence.Subsequence(int startIndex, int length);
    public virtual string ToString();
    public virtual CharBuffer Append(char value);
    public virtual CharBuffer Append(Char[] value);
    public virtual CharBuffer Append(Char[] value, int startIndex, int count);
    public virtual CharBuffer Append(StringBuilder value);
    public virtual CharBuffer Append(StringBuilder value, int startIndex, int count);
    public virtual CharBuffer Append(string value);
    public virtual CharBuffer Append(string value, int startIndex, int count);
    public virtual CharBuffer Append(ICharSequence value);
    public virtual CharBuffer Append(ICharSequence value, int startIndex, int count);
    public virtual int Read(CharBuffer target);
    private sealed virtual override IAppendable J2N.Text.IAppendable.Append(char value);
    private sealed virtual override IAppendable J2N.Text.IAppendable.Append(string value);
    private sealed virtual override IAppendable J2N.Text.IAppendable.Append(string value, int startIndex, int count);
    private sealed virtual override IAppendable J2N.Text.IAppendable.Append(StringBuilder value);
    private sealed virtual override IAppendable J2N.Text.IAppendable.Append(StringBuilder value, int startIndex, int count);
    private sealed virtual override IAppendable J2N.Text.IAppendable.Append(Char[] value);
    private sealed virtual override IAppendable J2N.Text.IAppendable.Append(Char[] value, int startIndex, int count);
    private sealed virtual override IAppendable J2N.Text.IAppendable.Append(ICharSequence value);
    private sealed virtual override IAppendable J2N.Text.IAppendable.Append(ICharSequence value, int startIndex, int count);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class J2N.IO.CharSequenceAdapter : CharBuffer {
    internal ICharSequence sequence;
    public bool IsReadOnly { get; }
    public ByteOrder Order { get; }
    protected Char[] ProtectedArray { get; }
    protected int ProtectedArrayOffset { get; }
    protected bool ProtectedHasArray { get; }
    internal CharSequenceAdapter(ICharSequence chseq);
    internal static CharSequenceAdapter Copy(CharSequenceAdapter other);
    public virtual CharBuffer AsReadOnlyBuffer();
    public virtual CharBuffer Compact();
    public virtual CharBuffer Duplicate();
    public virtual char Get();
    public virtual char Get(int index);
    public sealed virtual CharBuffer Get(Char[] destination, int offset, int length);
    public virtual bool get_IsReadOnly();
    public virtual ByteOrder get_Order();
    protected virtual Char[] get_ProtectedArray();
    protected virtual int get_ProtectedArrayOffset();
    protected virtual bool get_ProtectedHasArray();
    public virtual CharBuffer Put(char value);
    public virtual CharBuffer Put(int index, char value);
    public sealed virtual CharBuffer Put(Char[] source, int offset, int length);
    public virtual CharBuffer Put(string source, int startIndex, int length);
    public virtual CharBuffer Slice();
    public virtual CharBuffer Subsequence(int startIndex, int length);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class J2N.IO.CharToByteBufferAdapter : CharBuffer {
    private ByteBuffer byteBuffer;
    public bool IsReadOnly { get; }
    public ByteOrder Order { get; }
    protected Char[] ProtectedArray { get; }
    protected int ProtectedArrayOffset { get; }
    protected bool ProtectedHasArray { get; }
    internal CharToByteBufferAdapter(ByteBuffer byteBuffer);
    internal static CharBuffer Wrap(ByteBuffer byteBuffer);
    public virtual CharBuffer AsReadOnlyBuffer();
    public virtual CharBuffer Compact();
    public virtual CharBuffer Duplicate();
    public virtual char Get();
    public virtual char Get(int index);
    public virtual bool get_IsReadOnly();
    public virtual ByteOrder get_Order();
    protected virtual Char[] get_ProtectedArray();
    protected virtual int get_ProtectedArrayOffset();
    protected virtual bool get_ProtectedHasArray();
    public virtual CharBuffer Put(char value);
    public virtual CharBuffer Put(int index, char value);
    public virtual CharBuffer Slice();
    public virtual CharBuffer Subsequence(int startIndex, int length);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class J2N.IO.DataInputStream : object {
    private Byte[] buff;
    private Stream input;
    [NullableAttribute("2")]
private Char[] lineBuffer;
    private bool leaveOpen;
    public int Available { get; }
    public DataInputStream(Stream input);
    public DataInputStream(Stream input, bool leaveOpen);
    public int get_Available();
    public int Read(Byte[] buffer);
    public int Read(Byte[] buffer, int offset, int length);
    public sealed virtual bool ReadBoolean();
    public sealed virtual int ReadSByte();
    private int ReadToBuff(int count);
    public sealed virtual char ReadChar();
    public sealed virtual double ReadDouble();
    public sealed virtual float ReadSingle();
    public sealed virtual void ReadFully(Byte[] buffer);
    public sealed virtual void ReadFully(Byte[] buffer, int offset, int length);
    public sealed virtual int ReadInt32();
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use BufferedReader")]
public sealed virtual string ReadLine();
    public sealed virtual long ReadInt64();
    public sealed virtual short ReadInt16();
    public sealed virtual int ReadByte();
    public sealed virtual int ReadUInt16();
    public sealed virtual string ReadUTF();
    private string DecodeUTF(int utfSize);
    private static string DecodeUTF(int utfSize, IDataInput in);
    public static string ReadUTF(IDataInput input);
    private static string ConvertUTF8WithBuf(Byte[] buf, Char[] out, int offset, int utfSize);
    public sealed virtual int SkipBytes(int count);
    private static int Skip(Stream stream, int n);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public virtual int Read();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class J2N.IO.DataOutputStream : object {
    private object _lock;
    protected int written;
    private Byte[] buff;
    private bool leaveOpen;
    private Stream output;
    public int Length { get; }
    public DataOutputStream(Stream output);
    public DataOutputStream(Stream output, bool leaveOpen);
    public virtual void Flush();
    public int get_Length();
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void Write(int oneByte);
    public sealed virtual void WriteBoolean(bool value);
    public sealed virtual void WriteByte(int value);
    public sealed virtual void WriteBytes(string value);
    public sealed virtual void WriteChar(int value);
    public sealed virtual void WriteChars(string value);
    public sealed virtual void WriteDouble(double value);
    public sealed virtual void WriteSingle(float value);
    public sealed virtual void WriteInt32(int value);
    public sealed virtual void WriteInt64(long value);
    private int WriteInt64ToBuffer(long value, Byte[] buffer, int offset);
    public sealed virtual void WriteInt16(int value);
    private int WriteInt16ToBuffer(int value, Byte[] buffer, int offset);
    public sealed virtual void WriteUTF(string value);
    private long CountUTFBytes(string value);
    private int WriteUTFBytesToBuffer(string value, long count, Byte[] buffer, int offset);
    public sealed virtual void Write(Byte[] buffer);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class J2N.IO.DoubleArrayBuffer : DoubleBuffer {
    protected internal Double[] backingArray;
    protected internal int offset;
    public ByteOrder Order { get; }
    internal DoubleArrayBuffer(Double[] array);
    internal DoubleArrayBuffer(int capacity);
    internal DoubleArrayBuffer(int capacity, Double[] backingArray, int offset);
    public sealed virtual double Get();
    public sealed virtual double Get(int index);
    public sealed virtual DoubleBuffer Get(Double[] destination, int offset, int length);
    public sealed virtual ByteOrder get_Order();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class J2N.IO.DoubleBuffer : Buffer {
    public Double[] Array { get; }
    public int ArrayOffset { get; }
    public bool HasArray { get; }
    public ByteOrder Order { get; }
    protected Double[] ProtectedArray { get; }
    protected int ProtectedArrayOffset { get; }
    protected bool ProtectedHasArray { get; }
    internal DoubleBuffer(int capacity);
    public static DoubleBuffer Allocate(int capacity);
    public static DoubleBuffer Wrap(Double[] array);
    public static DoubleBuffer Wrap(Double[] array, int startIndex, int length);
    public Double[] get_Array();
    public int get_ArrayOffset();
    public abstract virtual DoubleBuffer AsReadOnlyBuffer();
    public abstract virtual DoubleBuffer Compact();
    [NullableContextAttribute("2")]
public virtual int CompareTo(DoubleBuffer other);
    public abstract virtual DoubleBuffer Duplicate();
    [NullableContextAttribute("2")]
public virtual bool Equals(object other);
    public abstract virtual double Get();
    public virtual DoubleBuffer Get(Double[] destination);
    public virtual DoubleBuffer Get(Double[] destination, int offset, int length);
    public abstract virtual double Get(int index);
    public bool get_HasArray();
    public virtual int GetHashCode();
    public abstract virtual ByteOrder get_Order();
    protected abstract virtual Double[] get_ProtectedArray();
    protected abstract virtual int get_ProtectedArrayOffset();
    protected abstract virtual bool get_ProtectedHasArray();
    public abstract virtual DoubleBuffer Put(double source);
    public DoubleBuffer Put(Double[] source);
    public virtual DoubleBuffer Put(Double[] source, int offset, int length);
    public virtual DoubleBuffer Put(DoubleBuffer source);
    public abstract virtual DoubleBuffer Put(int index, double value);
    public abstract virtual DoubleBuffer Slice();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class J2N.IO.DoubleToByteBufferAdapter : DoubleBuffer {
    private ByteBuffer byteBuffer;
    public bool IsReadOnly { get; }
    public ByteOrder Order { get; }
    protected Double[] ProtectedArray { get; }
    protected int ProtectedArrayOffset { get; }
    protected bool ProtectedHasArray { get; }
    internal DoubleToByteBufferAdapter(ByteBuffer byteBuffer);
    internal static DoubleBuffer Wrap(ByteBuffer byteBuffer);
    public virtual DoubleBuffer AsReadOnlyBuffer();
    public virtual DoubleBuffer Compact();
    public virtual DoubleBuffer Duplicate();
    public virtual double Get();
    public virtual double Get(int index);
    public virtual bool get_IsReadOnly();
    public virtual ByteOrder get_Order();
    protected virtual Double[] get_ProtectedArray();
    protected virtual int get_ProtectedArrayOffset();
    protected virtual bool get_ProtectedHasArray();
    public virtual DoubleBuffer Put(double value);
    public virtual DoubleBuffer Put(int index, double value);
    public virtual DoubleBuffer Slice();
}
public enum J2N.IO.Endianness : Enum {
    public int value__;
    public static Endianness LittleEndian;
    public static Endianness BigEndian;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class J2N.IO.HeapByteBuffer : ByteBuffer {
    protected internal Byte[] backingArray;
    protected internal int offset;
    internal HeapByteBuffer(Byte[] backingArray);
    internal HeapByteBuffer(int capacity);
    internal HeapByteBuffer(Byte[] backingArray, int capacity, int offset);
    public sealed virtual ByteBuffer Get(Byte[] destination, int offset, int length);
    public sealed virtual byte Get();
    public sealed virtual byte Get(int index);
    public sealed virtual double GetDouble();
    public sealed virtual double GetDouble(int index);
    public sealed virtual float GetSingle();
    public sealed virtual float GetSingle(int index);
    public sealed virtual int GetInt32();
    public sealed virtual int GetInt32(int index);
    public sealed virtual long GetInt64();
    public sealed virtual long GetInt64(int index);
    public sealed virtual short GetInt16();
    public sealed virtual short GetInt16(int index);
    protected int LoadInt32(int index);
    protected long LoadInt64(int index);
    protected short LoadInt16(int index);
    protected void Store(int index, int value);
    protected void Store(int index, long value);
    protected void Store(int index, short value);
    public sealed virtual CharBuffer AsCharBuffer();
    public sealed virtual DoubleBuffer AsDoubleBuffer();
    public sealed virtual SingleBuffer AsSingleBuffer();
    public sealed virtual Int32Buffer AsInt32Buffer();
    public sealed virtual Int64Buffer AsInt64Buffer();
    public sealed virtual Int16Buffer AsInt16Buffer();
    public sealed virtual char GetChar();
    public sealed virtual char GetChar(int index);
    public sealed virtual ByteBuffer PutChar(char value);
    public sealed virtual ByteBuffer PutChar(int index, char value);
}
[NullableContextAttribute("1")]
public interface J2N.IO.IDataInput {
    public abstract virtual bool ReadBoolean();
    public abstract virtual int ReadSByte();
    public abstract virtual int ReadByte();
    public abstract virtual char ReadChar();
    public abstract virtual double ReadDouble();
    public abstract virtual float ReadSingle();
    public abstract virtual void ReadFully(Byte[] buffer);
    public abstract virtual void ReadFully(Byte[] buffer, int offset, int count);
    public abstract virtual short ReadInt16();
    public abstract virtual int ReadUInt16();
    public abstract virtual int ReadInt32();
    public abstract virtual long ReadInt64();
    [NullableContextAttribute("2")]
public abstract virtual string ReadLine();
    public abstract virtual string ReadUTF();
    public abstract virtual int SkipBytes(int count);
}
[NullableContextAttribute("1")]
public interface J2N.IO.IDataOutput {
    public abstract virtual void Write(Byte[] buffer);
    public abstract virtual void Write(Byte[] buffer, int offset, int count);
    public abstract virtual void Write(int oneByte);
    public abstract virtual void WriteBoolean(bool value);
    public abstract virtual void WriteByte(int value);
    public abstract virtual void WriteBytes(string value);
    public abstract virtual void WriteChar(int value);
    public abstract virtual void WriteChars(string str);
    public abstract virtual void WriteDouble(double value);
    public abstract virtual void WriteSingle(float value);
    public abstract virtual void WriteInt32(int value);
    public abstract virtual void WriteInt64(long value);
    public abstract virtual void WriteInt16(int value);
    public abstract virtual void WriteUTF(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class J2N.IO.Int16ArrayBuffer : Int16Buffer {
    protected internal Int16[] backingArray;
    protected internal int offset;
    public ByteOrder Order { get; }
    internal Int16ArrayBuffer(Int16[] array);
    internal Int16ArrayBuffer(int capacity);
    internal Int16ArrayBuffer(int capacity, Int16[] backingArray, int offset);
    public sealed virtual short Get();
    public sealed virtual short Get(int index);
    public sealed virtual Int16Buffer Get(Int16[] destination, int offset, int length);
    public sealed virtual ByteOrder get_Order();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class J2N.IO.Int16Buffer : Buffer {
    public Int16[] Array { get; }
    public int ArrayOffset { get; }
    public bool HasArray { get; }
    public ByteOrder Order { get; }
    protected Int16[] ProtectedArray { get; }
    protected int ProtectedArrayOffset { get; }
    protected bool ProtectedHasArray { get; }
    internal Int16Buffer(int capacity);
    public static Int16Buffer Allocate(int capacity);
    public static Int16Buffer Wrap(Int16[] array);
    public static Int16Buffer Wrap(Int16[] array, int startIndex, int length);
    public Int16[] get_Array();
    public int get_ArrayOffset();
    public abstract virtual Int16Buffer AsReadOnlyBuffer();
    public abstract virtual Int16Buffer Compact();
    [NullableContextAttribute("2")]
public virtual int CompareTo(Int16Buffer other);
    public abstract virtual Int16Buffer Duplicate();
    [NullableContextAttribute("2")]
public virtual bool Equals(object other);
    public abstract virtual short Get();
    public virtual Int16Buffer Get(Int16[] destination);
    public virtual Int16Buffer Get(Int16[] destination, int offset, int length);
    public abstract virtual short Get(int index);
    public bool get_HasArray();
    public virtual int GetHashCode();
    public abstract virtual ByteOrder get_Order();
    protected abstract virtual Int16[] get_ProtectedArray();
    protected abstract virtual int get_ProtectedArrayOffset();
    protected abstract virtual bool get_ProtectedHasArray();
    public abstract virtual Int16Buffer Put(short value);
    public Int16Buffer Put(Int16[] source);
    public virtual Int16Buffer Put(Int16[] source, int offset, int length);
    public virtual Int16Buffer Put(Int16Buffer source);
    public abstract virtual Int16Buffer Put(int index, short value);
    public abstract virtual Int16Buffer Slice();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class J2N.IO.Int16ToByteBufferAdapter : Int16Buffer {
    private ByteBuffer byteBuffer;
    public bool IsReadOnly { get; }
    public ByteOrder Order { get; }
    protected Int16[] ProtectedArray { get; }
    protected int ProtectedArrayOffset { get; }
    protected bool ProtectedHasArray { get; }
    internal Int16ToByteBufferAdapter(ByteBuffer byteBuffer);
    internal static Int16Buffer Wrap(ByteBuffer byteBuffer);
    public virtual Int16Buffer AsReadOnlyBuffer();
    public virtual Int16Buffer Compact();
    public virtual Int16Buffer Duplicate();
    public virtual short Get();
    public virtual short Get(int index);
    public virtual bool get_IsReadOnly();
    public virtual ByteOrder get_Order();
    protected virtual Int16[] get_ProtectedArray();
    protected virtual int get_ProtectedArrayOffset();
    protected virtual bool get_ProtectedHasArray();
    public virtual Int16Buffer Put(short value);
    public virtual Int16Buffer Put(int index, short value);
    public virtual Int16Buffer Slice();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class J2N.IO.Int32ArrayBuffer : Int32Buffer {
    protected internal Int32[] backingArray;
    protected internal int offset;
    public ByteOrder Order { get; }
    internal Int32ArrayBuffer(Int32[] array);
    internal Int32ArrayBuffer(int capacity);
    internal Int32ArrayBuffer(int capacity, Int32[] backingArray, int offset);
    public sealed virtual int Get();
    public sealed virtual int Get(int index);
    public sealed virtual Int32Buffer Get(Int32[] destination, int offset, int length);
    public sealed virtual ByteOrder get_Order();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class J2N.IO.Int32Buffer : Buffer {
    public Int32[] Array { get; }
    public int ArrayOffset { get; }
    public bool HasArray { get; }
    public ByteOrder Order { get; }
    protected Int32[] ProtectedArray { get; }
    protected int ProtectedArrayOffset { get; }
    protected bool ProtectedHasArray { get; }
    internal Int32Buffer(int capacity);
    public static Int32Buffer Allocate(int capacity);
    public static Int32Buffer Wrap(Int32[] array);
    public static Int32Buffer Wrap(Int32[] array, int startIndex, int length);
    public Int32[] get_Array();
    public int get_ArrayOffset();
    public abstract virtual Int32Buffer AsReadOnlyBuffer();
    public abstract virtual Int32Buffer Compact();
    [NullableContextAttribute("2")]
public virtual int CompareTo(Int32Buffer other);
    public abstract virtual Int32Buffer Duplicate();
    [NullableContextAttribute("2")]
public virtual bool Equals(object other);
    public abstract virtual int Get();
    public virtual Int32Buffer Get(Int32[] destination);
    public virtual Int32Buffer Get(Int32[] destination, int offset, int length);
    public abstract virtual int Get(int index);
    public bool get_HasArray();
    public virtual int GetHashCode();
    public abstract virtual ByteOrder get_Order();
    protected abstract virtual Int32[] get_ProtectedArray();
    protected abstract virtual int get_ProtectedArrayOffset();
    protected abstract virtual bool get_ProtectedHasArray();
    public abstract virtual Int32Buffer Put(int source);
    public Int32Buffer Put(Int32[] source);
    public virtual Int32Buffer Put(Int32[] source, int offset, int length);
    public virtual Int32Buffer Put(Int32Buffer source);
    public abstract virtual Int32Buffer Put(int index, int value);
    public abstract virtual Int32Buffer Slice();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class J2N.IO.Int32ToByteBufferAdapter : Int32Buffer {
    private ByteBuffer byteBuffer;
    public bool IsReadOnly { get; }
    public ByteOrder Order { get; }
    protected Int32[] ProtectedArray { get; }
    protected int ProtectedArrayOffset { get; }
    protected bool ProtectedHasArray { get; }
    internal Int32ToByteBufferAdapter(ByteBuffer byteBuffer);
    internal static Int32Buffer Wrap(ByteBuffer byteBuffer);
    public virtual Int32Buffer AsReadOnlyBuffer();
    public virtual Int32Buffer Compact();
    public virtual Int32Buffer Duplicate();
    public virtual int Get();
    public virtual int Get(int index);
    public virtual bool get_IsReadOnly();
    public virtual ByteOrder get_Order();
    protected virtual Int32[] get_ProtectedArray();
    protected virtual int get_ProtectedArrayOffset();
    protected virtual bool get_ProtectedHasArray();
    public virtual Int32Buffer Put(int value);
    public virtual Int32Buffer Put(int index, int value);
    public virtual Int32Buffer Slice();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class J2N.IO.Int64ArrayBuffer : Int64Buffer {
    protected internal Int64[] backingArray;
    protected internal int offset;
    public ByteOrder Order { get; }
    internal Int64ArrayBuffer(Int64[] array);
    internal Int64ArrayBuffer(int capacity);
    internal Int64ArrayBuffer(int capacity, Int64[] backingArray, int offset);
    public sealed virtual long Get();
    public sealed virtual long Get(int index);
    public sealed virtual Int64Buffer Get(Int64[] destination, int offset, int length);
    public sealed virtual ByteOrder get_Order();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class J2N.IO.Int64Buffer : Buffer {
    public Int64[] Array { get; }
    public int ArrayOffset { get; }
    public bool HasArray { get; }
    public ByteOrder Order { get; }
    protected Int64[] ProtectedArray { get; }
    protected int ProtectedArrayOffset { get; }
    protected bool ProtectedHasArray { get; }
    internal Int64Buffer(int capacity);
    public static Int64Buffer Allocate(int capacity);
    public static Int64Buffer Wrap(Int64[] array);
    public static Int64Buffer Wrap(Int64[] array, int startIndex, int length);
    public Int64[] get_Array();
    public int get_ArrayOffset();
    public abstract virtual Int64Buffer AsReadOnlyBuffer();
    public abstract virtual Int64Buffer Compact();
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(Int64Buffer other);
    public abstract virtual Int64Buffer Duplicate();
    [NullableContextAttribute("2")]
public virtual bool Equals(object other);
    public abstract virtual long Get();
    public virtual Int64Buffer Get(Int64[] destination);
    public virtual Int64Buffer Get(Int64[] destination, int offset, int length);
    public abstract virtual long Get(int index);
    public bool get_HasArray();
    public virtual int GetHashCode();
    public abstract virtual ByteOrder get_Order();
    protected abstract virtual Int64[] get_ProtectedArray();
    protected abstract virtual int get_ProtectedArrayOffset();
    protected abstract virtual bool get_ProtectedHasArray();
    public abstract virtual Int64Buffer Put(long source);
    public Int64Buffer Put(Int64[] source);
    public virtual Int64Buffer Put(Int64[] source, int offset, int length);
    public virtual Int64Buffer Put(Int64Buffer source);
    public abstract virtual Int64Buffer Put(int index, long value);
    public abstract virtual Int64Buffer Slice();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class J2N.IO.Int64ToByteBufferAdapter : Int64Buffer {
    private ByteBuffer byteBuffer;
    public bool IsReadOnly { get; }
    public ByteOrder Order { get; }
    protected Int64[] ProtectedArray { get; }
    protected int ProtectedArrayOffset { get; }
    protected bool ProtectedHasArray { get; }
    internal Int64ToByteBufferAdapter(ByteBuffer byteBuffer);
    internal static Int64Buffer Wrap(ByteBuffer byteBuffer);
    public virtual Int64Buffer AsReadOnlyBuffer();
    public virtual Int64Buffer Compact();
    public virtual Int64Buffer Duplicate();
    public virtual long Get();
    public virtual long Get(int index);
    public virtual bool get_IsReadOnly();
    public virtual ByteOrder get_Order();
    protected virtual Int64[] get_ProtectedArray();
    protected virtual int get_ProtectedArrayOffset();
    protected virtual bool get_ProtectedHasArray();
    public virtual Int64Buffer Put(long value);
    public virtual Int64Buffer Put(int index, long value);
    public virtual Int64Buffer Slice();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class J2N.IO.InvalidMarkException : Exception {
    public InvalidMarkException(string message);
    public InvalidMarkException(string message, Exception innerException);
    private InvalidMarkException(SerializationInfo info, StreamingContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class J2N.IO.MemoryMappedFiles.MemoryMappedFileExtensions : object {
    [ExtensionAttribute]
public static MemoryMappedViewByteBuffer CreateViewByteBuffer(MemoryMappedFile memoryMappedFile);
    [ExtensionAttribute]
public static MemoryMappedViewByteBuffer CreateViewByteBuffer(MemoryMappedFile memoryMappedFile, long offset, long size);
    [ExtensionAttribute]
public static MemoryMappedViewByteBuffer CreateViewByteBuffer(MemoryMappedFile memoryMappedFile, long offset, long size, MemoryMappedFileAccess access);
    [ExtensionAttribute]
internal static MemoryMappedViewByteBuffer CreateViewByteBuffer(MemoryMappedFile memoryMappedFile, long offset, long size, MemoryMappedFileAccess access, int bufferOffset, int bufferSize);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class J2N.IO.MemoryMappedFiles.MemoryMappedViewByteBuffer : ByteBuffer {
    protected internal MemoryMappedViewAccessor accessor;
    protected internal int offset;
    internal MemoryMappedViewByteBuffer(MemoryMappedViewAccessor accessor, int capacity);
    internal MemoryMappedViewByteBuffer(MemoryMappedViewAccessor accessor, int capacity, int offset);
    public virtual ByteBuffer Get(Byte[] destination, int offset, int length);
    public virtual byte Get();
    public virtual byte Get(int index);
    public sealed virtual double GetDouble();
    public sealed virtual double GetDouble(int index);
    public sealed virtual float GetSingle();
    public sealed virtual float GetSingle(int index);
    public virtual int GetInt32();
    public virtual int GetInt32(int index);
    public virtual long GetInt64();
    public virtual long GetInt64(int index);
    public virtual short GetInt16();
    public virtual short GetInt16(int index);
    protected int LoadInt32(int index);
    protected long LoadInt64(int index);
    protected short LoadInt16(int index);
    protected void Store(int index, int value);
    protected void Store(int index, long value);
    protected void Store(int index, short value);
    public sealed virtual CharBuffer AsCharBuffer();
    public sealed virtual DoubleBuffer AsDoubleBuffer();
    public sealed virtual SingleBuffer AsSingleBuffer();
    public sealed virtual Int32Buffer AsInt32Buffer();
    public sealed virtual Int64Buffer AsInt64Buffer();
    public sealed virtual Int16Buffer AsInt16Buffer();
    public sealed virtual char GetChar();
    public sealed virtual char GetChar(int index);
    public sealed virtual ByteBuffer PutChar(char value);
    public sealed virtual ByteBuffer PutChar(int index, char value);
    public virtual void Flush();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    internal int Ix(int i);
    internal int NextGetIndex();
    internal int NextGetIndex(int numberOfBytes);
    internal int NextPutIndex();
    internal int NextPutIndex(int numberOfBytes);
    internal int CheckIndex(int index);
    internal int CheckIndex(int index, int numberOfBytes);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class J2N.IO.MemoryMappedFiles.ReadOnlyMemoryMappedViewByteBuffer : MemoryMappedViewByteBuffer {
    public bool IsReadOnly { get; }
    protected Byte[] ProtectedArray { get; }
    protected int ProtectedArrayOffset { get; }
    protected bool ProtectedHasArray { get; }
    internal ReadOnlyMemoryMappedViewByteBuffer(MemoryMappedViewAccessor accessor, int capacity, int offset);
    internal static ReadOnlyMemoryMappedViewByteBuffer Copy(MemoryMappedViewByteBuffer other, int markOfOther);
    public virtual ByteBuffer AsReadOnlyBuffer();
    public virtual ByteBuffer Compact();
    public virtual ByteBuffer Duplicate();
    public virtual bool get_IsReadOnly();
    protected virtual Byte[] get_ProtectedArray();
    protected virtual int get_ProtectedArrayOffset();
    protected virtual bool get_ProtectedHasArray();
    public virtual ByteBuffer Put(byte value);
    public virtual ByteBuffer Put(int index, byte value);
    public virtual ByteBuffer Put(Byte[] source, int offset, int length);
    public virtual ByteBuffer PutDouble(double value);
    public virtual ByteBuffer PutDouble(int index, double value);
    public virtual ByteBuffer PutSingle(float value);
    public virtual ByteBuffer PutSingle(int index, float value);
    public virtual ByteBuffer PutInt32(int value);
    public virtual ByteBuffer PutInt32(int index, int value);
    public virtual ByteBuffer PutInt64(int index, long value);
    public virtual ByteBuffer PutInt64(long value);
    public virtual ByteBuffer PutInt16(int index, short value);
    public virtual ByteBuffer PutInt16(short value);
    public virtual ByteBuffer Put(ByteBuffer buffer);
    public virtual ByteBuffer Slice();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class J2N.IO.MemoryMappedFiles.ReadWriteMemoryMappedViewByteBuffer : MemoryMappedViewByteBuffer {
    public bool IsReadOnly { get; }
    protected Byte[] ProtectedArray { get; }
    protected int ProtectedArrayOffset { get; }
    protected bool ProtectedHasArray { get; }
    internal ReadWriteMemoryMappedViewByteBuffer(MemoryMappedViewAccessor accessor, int capacity);
    internal ReadWriteMemoryMappedViewByteBuffer(MemoryMappedViewAccessor accessor, int capacity, int offset);
    internal static ReadWriteMemoryMappedViewByteBuffer Copy(MemoryMappedViewByteBuffer other, int markOfOther);
    public virtual ByteBuffer AsReadOnlyBuffer();
    public virtual ByteBuffer Compact();
    public virtual ByteBuffer Duplicate();
    public virtual bool get_IsReadOnly();
    protected virtual Byte[] get_ProtectedArray();
    protected virtual int get_ProtectedArrayOffset();
    protected virtual bool get_ProtectedHasArray();
    public virtual ByteBuffer Put(byte value);
    public virtual ByteBuffer Put(int index, byte value);
    public virtual ByteBuffer Put(Byte[] source, int offset, int length);
    public virtual ByteBuffer PutDouble(double value);
    public virtual ByteBuffer PutDouble(int index, double value);
    public virtual ByteBuffer PutSingle(float value);
    public virtual ByteBuffer PutSingle(int index, float value);
    public virtual ByteBuffer PutInt32(int value);
    public virtual ByteBuffer PutInt32(int index, int value);
    public virtual ByteBuffer PutInt64(int index, long value);
    public virtual ByteBuffer PutInt64(long value);
    public virtual ByteBuffer PutInt16(int index, short value);
    public virtual ByteBuffer PutInt16(short value);
    public virtual ByteBuffer Slice();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class J2N.IO.ReadOnlyBufferException : NotSupportedException {
    public ReadOnlyBufferException(string message);
    public ReadOnlyBufferException(string message, Exception innerException);
    private ReadOnlyBufferException(SerializationInfo info, StreamingContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class J2N.IO.ReadOnlyCharArrayBuffer : CharArrayBuffer {
    public bool IsReadOnly { get; }
    protected Char[] ProtectedArray { get; }
    protected int ProtectedArrayOffset { get; }
    protected bool ProtectedHasArray { get; }
    internal ReadOnlyCharArrayBuffer(int capacity, Char[] backingArray, int arrayOffset);
    internal static ReadOnlyCharArrayBuffer Copy(CharArrayBuffer other, int markOfOther);
    public virtual CharBuffer AsReadOnlyBuffer();
    public virtual CharBuffer Compact();
    public virtual CharBuffer Duplicate();
    public virtual bool get_IsReadOnly();
    protected virtual Char[] get_ProtectedArray();
    protected virtual int get_ProtectedArrayOffset();
    protected virtual bool get_ProtectedHasArray();
    public virtual CharBuffer Put(char value);
    public virtual CharBuffer Put(int index, char value);
    public sealed virtual CharBuffer Put(Char[] source, int offset, int length);
    public sealed virtual CharBuffer Put(CharBuffer src);
    public virtual CharBuffer Put(string source, int startIndex, int length);
    public virtual CharBuffer Slice();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class J2N.IO.ReadOnlyDoubleArrayBuffer : DoubleArrayBuffer {
    public bool IsReadOnly { get; }
    protected Double[] ProtectedArray { get; }
    protected int ProtectedArrayOffset { get; }
    protected bool ProtectedHasArray { get; }
    internal ReadOnlyDoubleArrayBuffer(int capacity, Double[] backingArray, int arrayOffset);
    internal static ReadOnlyDoubleArrayBuffer Copy(DoubleArrayBuffer other, int markOfOther);
    public virtual DoubleBuffer AsReadOnlyBuffer();
    public virtual DoubleBuffer Compact();
    public virtual DoubleBuffer Duplicate();
    public virtual bool get_IsReadOnly();
    protected virtual Double[] get_ProtectedArray();
    protected virtual int get_ProtectedArrayOffset();
    protected virtual bool get_ProtectedHasArray();
    public virtual DoubleBuffer Put(double value);
    public virtual DoubleBuffer Put(int index, double value);
    public virtual DoubleBuffer Put(DoubleBuffer buffer);
    public sealed virtual DoubleBuffer Put(Double[] source, int offset, int length);
    public virtual DoubleBuffer Slice();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class J2N.IO.ReadOnlyHeapByteBuffer : HeapByteBuffer {
    public bool IsReadOnly { get; }
    protected Byte[] ProtectedArray { get; }
    protected int ProtectedArrayOffset { get; }
    protected bool ProtectedHasArray { get; }
    internal ReadOnlyHeapByteBuffer(Byte[] backingArray, int capacity, int arrayOffset);
    internal static ReadOnlyHeapByteBuffer Copy(HeapByteBuffer other, int markOfOther);
    public virtual ByteBuffer AsReadOnlyBuffer();
    public virtual ByteBuffer Compact();
    public virtual ByteBuffer Duplicate();
    public virtual bool get_IsReadOnly();
    protected virtual Byte[] get_ProtectedArray();
    protected virtual int get_ProtectedArrayOffset();
    protected virtual bool get_ProtectedHasArray();
    public virtual ByteBuffer Put(byte value);
    public virtual ByteBuffer Put(int index, byte value);
    public virtual ByteBuffer Put(Byte[] source, int offset, int length);
    public virtual ByteBuffer PutDouble(double value);
    public virtual ByteBuffer PutDouble(int index, double value);
    public virtual ByteBuffer PutSingle(float value);
    public virtual ByteBuffer PutSingle(int index, float value);
    public virtual ByteBuffer PutInt32(int value);
    public virtual ByteBuffer PutInt32(int index, int value);
    public virtual ByteBuffer PutInt64(int index, long value);
    public virtual ByteBuffer PutInt64(long value);
    public virtual ByteBuffer PutInt16(int index, short value);
    public virtual ByteBuffer PutInt16(short value);
    public virtual ByteBuffer Put(ByteBuffer buffer);
    public virtual ByteBuffer Slice();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class J2N.IO.ReadOnlyInt16ArrayBuffer : Int16ArrayBuffer {
    public bool IsReadOnly { get; }
    protected Int16[] ProtectedArray { get; }
    protected int ProtectedArrayOffset { get; }
    protected bool ProtectedHasArray { get; }
    internal ReadOnlyInt16ArrayBuffer(int capacity, Int16[] backingArray, int arrayOffset);
    internal static ReadOnlyInt16ArrayBuffer Copy(Int16ArrayBuffer other, int markOfOther);
    public virtual Int16Buffer AsReadOnlyBuffer();
    public virtual Int16Buffer Compact();
    public virtual Int16Buffer Duplicate();
    public virtual bool get_IsReadOnly();
    protected virtual Int16[] get_ProtectedArray();
    protected virtual int get_ProtectedArrayOffset();
    protected virtual bool get_ProtectedHasArray();
    public virtual Int16Buffer Put(Int16Buffer buffer);
    public virtual Int16Buffer Put(short value);
    public virtual Int16Buffer Put(int index, short value);
    public sealed virtual Int16Buffer Put(Int16[] source, int offset, int length);
    public virtual Int16Buffer Slice();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class J2N.IO.ReadOnlyInt32ArrayBuffer : Int32ArrayBuffer {
    public bool IsReadOnly { get; }
    protected Int32[] ProtectedArray { get; }
    protected int ProtectedArrayOffset { get; }
    protected bool ProtectedHasArray { get; }
    internal ReadOnlyInt32ArrayBuffer(int capacity, Int32[] backingArray, int arrayOffset);
    internal static ReadOnlyInt32ArrayBuffer Copy(Int32ArrayBuffer other, int markOfOther);
    public virtual Int32Buffer AsReadOnlyBuffer();
    public virtual Int32Buffer Compact();
    public virtual Int32Buffer Duplicate();
    public virtual bool get_IsReadOnly();
    protected virtual Int32[] get_ProtectedArray();
    protected virtual int get_ProtectedArrayOffset();
    protected virtual bool get_ProtectedHasArray();
    public virtual Int32Buffer Put(int value);
    public virtual Int32Buffer Put(int index, int value);
    public virtual Int32Buffer Put(Int32Buffer buffer);
    public sealed virtual Int32Buffer Put(Int32[] source, int offset, int length);
    public virtual Int32Buffer Slice();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class J2N.IO.ReadOnlyInt64ArrayBuffer : Int64ArrayBuffer {
    public bool IsReadOnly { get; }
    protected Int64[] ProtectedArray { get; }
    protected int ProtectedArrayOffset { get; }
    protected bool ProtectedHasArray { get; }
    internal ReadOnlyInt64ArrayBuffer(int capacity, Int64[] backingArray, int arrayOffset);
    internal static ReadOnlyInt64ArrayBuffer Copy(Int64ArrayBuffer other, int markOfOther);
    public virtual Int64Buffer AsReadOnlyBuffer();
    public virtual Int64Buffer Compact();
    public virtual Int64Buffer Duplicate();
    public virtual bool get_IsReadOnly();
    protected virtual Int64[] get_ProtectedArray();
    protected virtual int get_ProtectedArrayOffset();
    protected virtual bool get_ProtectedHasArray();
    public virtual Int64Buffer Put(long value);
    public virtual Int64Buffer Put(int index, long value);
    public virtual Int64Buffer Put(Int64Buffer buffer);
    public sealed virtual Int64Buffer Put(Int64[] source, int offset, int length);
    public virtual Int64Buffer Slice();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class J2N.IO.ReadOnlySingleArrayBuffer : SingleArrayBuffer {
    public bool IsReadOnly { get; }
    protected Single[] ProtectedArray { get; }
    protected int ProtectedArrayOffset { get; }
    protected bool ProtectedHasArray { get; }
    internal ReadOnlySingleArrayBuffer(int capacity, Single[] backingArray, int arrayOffset);
    internal static ReadOnlySingleArrayBuffer Copy(SingleArrayBuffer other, int markOfOther);
    public virtual SingleBuffer AsReadOnlyBuffer();
    public virtual SingleBuffer Compact();
    public virtual SingleBuffer Duplicate();
    public virtual bool get_IsReadOnly();
    protected virtual Single[] get_ProtectedArray();
    protected virtual int get_ProtectedArrayOffset();
    protected virtual bool get_ProtectedHasArray();
    public virtual SingleBuffer Put(float value);
    public virtual SingleBuffer Put(int index, float value);
    public virtual SingleBuffer Put(SingleBuffer buffer);
    public sealed virtual SingleBuffer Put(Single[] source, int offset, int length);
    public virtual SingleBuffer Slice();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class J2N.IO.ReadWriteCharArrayBuffer : CharArrayBuffer {
    public bool IsReadOnly { get; }
    protected Char[] ProtectedArray { get; }
    protected int ProtectedArrayOffset { get; }
    protected bool ProtectedHasArray { get; }
    internal ReadWriteCharArrayBuffer(Char[] array);
    internal ReadWriteCharArrayBuffer(int capacity);
    internal ReadWriteCharArrayBuffer(int capacity, Char[] backingArray, int arrayOffset);
    internal static ReadWriteCharArrayBuffer Copy(CharArrayBuffer other, int markOfOther);
    public virtual CharBuffer AsReadOnlyBuffer();
    public virtual CharBuffer Compact();
    public virtual CharBuffer Duplicate();
    public virtual bool get_IsReadOnly();
    protected virtual Char[] get_ProtectedArray();
    protected virtual int get_ProtectedArrayOffset();
    protected virtual bool get_ProtectedHasArray();
    public virtual CharBuffer Put(char value);
    public virtual CharBuffer Put(int index, char value);
    public virtual CharBuffer Put(Char[] source, int offset, int length);
    public virtual CharBuffer Slice();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class J2N.IO.ReadWriteDoubleArrayBuffer : DoubleArrayBuffer {
    public bool IsReadOnly { get; }
    protected Double[] ProtectedArray { get; }
    protected int ProtectedArrayOffset { get; }
    protected bool ProtectedHasArray { get; }
    internal ReadWriteDoubleArrayBuffer(Double[] array);
    internal ReadWriteDoubleArrayBuffer(int capacity);
    internal ReadWriteDoubleArrayBuffer(int capacity, Double[] backingArray, int arrayOffset);
    internal static ReadWriteDoubleArrayBuffer Copy(DoubleArrayBuffer other, int markOfOther);
    public virtual DoubleBuffer AsReadOnlyBuffer();
    public virtual DoubleBuffer Compact();
    public virtual DoubleBuffer Duplicate();
    public virtual bool get_IsReadOnly();
    protected virtual Double[] get_ProtectedArray();
    protected virtual int get_ProtectedArrayOffset();
    protected virtual bool get_ProtectedHasArray();
    public virtual DoubleBuffer Put(double value);
    public virtual DoubleBuffer Put(int index, double value);
    public virtual DoubleBuffer Put(Double[] source, int offset, int length);
    public virtual DoubleBuffer Slice();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class J2N.IO.ReadWriteHeapByteBuffer : HeapByteBuffer {
    public bool IsReadOnly { get; }
    protected Byte[] ProtectedArray { get; }
    protected int ProtectedArrayOffset { get; }
    protected bool ProtectedHasArray { get; }
    internal ReadWriteHeapByteBuffer(Byte[] backingArray);
    internal ReadWriteHeapByteBuffer(int capacity);
    internal ReadWriteHeapByteBuffer(Byte[] backingArray, int capacity, int arrayOffset);
    internal static ReadWriteHeapByteBuffer Copy(HeapByteBuffer other, int markOfOther);
    public virtual ByteBuffer AsReadOnlyBuffer();
    public virtual ByteBuffer Compact();
    public virtual ByteBuffer Duplicate();
    public virtual bool get_IsReadOnly();
    protected virtual Byte[] get_ProtectedArray();
    protected virtual int get_ProtectedArrayOffset();
    protected virtual bool get_ProtectedHasArray();
    public virtual ByteBuffer Put(byte value);
    public virtual ByteBuffer Put(int index, byte value);
    public virtual ByteBuffer Put(Byte[] source, int offset, int length);
    public virtual ByteBuffer PutDouble(double value);
    public virtual ByteBuffer PutDouble(int index, double value);
    public virtual ByteBuffer PutSingle(float value);
    public virtual ByteBuffer PutSingle(int index, float value);
    public virtual ByteBuffer PutInt32(int value);
    public virtual ByteBuffer PutInt32(int index, int value);
    public virtual ByteBuffer PutInt64(int index, long value);
    public virtual ByteBuffer PutInt64(long value);
    public virtual ByteBuffer PutInt16(int index, short value);
    public virtual ByteBuffer PutInt16(short value);
    public virtual ByteBuffer Slice();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class J2N.IO.ReadWriteInt16ArrayBuffer : Int16ArrayBuffer {
    public bool IsReadOnly { get; }
    protected Int16[] ProtectedArray { get; }
    protected int ProtectedArrayOffset { get; }
    protected bool ProtectedHasArray { get; }
    internal ReadWriteInt16ArrayBuffer(Int16[] array);
    internal ReadWriteInt16ArrayBuffer(int capacity);
    internal ReadWriteInt16ArrayBuffer(int capacity, Int16[] backingArray, int arrayOffset);
    internal static ReadWriteInt16ArrayBuffer Copy(Int16ArrayBuffer other, int markOfOther);
    public virtual Int16Buffer AsReadOnlyBuffer();
    public virtual Int16Buffer Compact();
    public virtual Int16Buffer Duplicate();
    public virtual bool get_IsReadOnly();
    protected virtual Int16[] get_ProtectedArray();
    protected virtual int get_ProtectedArrayOffset();
    protected virtual bool get_ProtectedHasArray();
    public virtual Int16Buffer Put(short value);
    public virtual Int16Buffer Put(int index, short value);
    public virtual Int16Buffer Put(Int16[] source, int offset, int length);
    public virtual Int16Buffer Slice();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class J2N.IO.ReadWriteInt32ArrayBuffer : Int32ArrayBuffer {
    public bool IsReadOnly { get; }
    protected Int32[] ProtectedArray { get; }
    protected int ProtectedArrayOffset { get; }
    protected bool ProtectedHasArray { get; }
    internal ReadWriteInt32ArrayBuffer(Int32[] array);
    internal ReadWriteInt32ArrayBuffer(int capacity);
    internal ReadWriteInt32ArrayBuffer(int capacity, Int32[] backingArray, int arrayOffset);
    internal static ReadWriteInt32ArrayBuffer Copy(Int32ArrayBuffer other, int markOfOther);
    public virtual Int32Buffer AsReadOnlyBuffer();
    public virtual Int32Buffer Compact();
    public virtual Int32Buffer Duplicate();
    public virtual bool get_IsReadOnly();
    protected virtual Int32[] get_ProtectedArray();
    protected virtual int get_ProtectedArrayOffset();
    protected virtual bool get_ProtectedHasArray();
    public virtual Int32Buffer Put(int value);
    public virtual Int32Buffer Put(int index, int value);
    public virtual Int32Buffer Put(Int32[] source, int offset, int length);
    public virtual Int32Buffer Slice();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class J2N.IO.ReadWriteInt64ArrayBuffer : Int64ArrayBuffer {
    public bool IsReadOnly { get; }
    protected Int64[] ProtectedArray { get; }
    protected int ProtectedArrayOffset { get; }
    protected bool ProtectedHasArray { get; }
    internal ReadWriteInt64ArrayBuffer(Int64[] array);
    internal ReadWriteInt64ArrayBuffer(int capacity);
    internal ReadWriteInt64ArrayBuffer(int capacity, Int64[] backingArray, int arrayOffset);
    internal static ReadWriteInt64ArrayBuffer Copy(Int64ArrayBuffer other, int markOfOther);
    public virtual Int64Buffer AsReadOnlyBuffer();
    public virtual Int64Buffer Compact();
    public virtual Int64Buffer Duplicate();
    public virtual bool get_IsReadOnly();
    protected virtual Int64[] get_ProtectedArray();
    protected virtual int get_ProtectedArrayOffset();
    protected virtual bool get_ProtectedHasArray();
    public virtual Int64Buffer Put(long value);
    public virtual Int64Buffer Put(int index, long value);
    public virtual Int64Buffer Put(Int64[] source, int offset, int length);
    public virtual Int64Buffer Slice();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class J2N.IO.ReadWriteSingleArrayBuffer : SingleArrayBuffer {
    public bool IsReadOnly { get; }
    protected Single[] ProtectedArray { get; }
    protected int ProtectedArrayOffset { get; }
    protected bool ProtectedHasArray { get; }
    internal ReadWriteSingleArrayBuffer(Single[] array);
    internal ReadWriteSingleArrayBuffer(int capacity);
    internal ReadWriteSingleArrayBuffer(int capacity, Single[] backingArray, int arrayOffset);
    internal static ReadWriteSingleArrayBuffer Copy(SingleArrayBuffer other, int markOfOther);
    public virtual SingleBuffer AsReadOnlyBuffer();
    public virtual SingleBuffer Compact();
    public virtual SingleBuffer Duplicate();
    public virtual bool get_IsReadOnly();
    protected virtual Single[] get_ProtectedArray();
    protected virtual int get_ProtectedArrayOffset();
    protected virtual bool get_ProtectedHasArray();
    public virtual SingleBuffer Put(float value);
    public virtual SingleBuffer Put(int index, float value);
    public virtual SingleBuffer Put(Single[] source, int offset, int length);
    public virtual SingleBuffer Slice();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class J2N.IO.SingleArrayBuffer : SingleBuffer {
    protected internal Single[] backingArray;
    protected internal int offset;
    public ByteOrder Order { get; }
    internal SingleArrayBuffer(Single[] array);
    internal SingleArrayBuffer(int capacity);
    internal SingleArrayBuffer(int capacity, Single[] backingArray, int offset);
    public sealed virtual float Get();
    public sealed virtual float Get(int index);
    public sealed virtual SingleBuffer Get(Single[] destination, int offset, int length);
    public sealed virtual ByteOrder get_Order();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class J2N.IO.SingleBuffer : Buffer {
    public Single[] Array { get; }
    public int ArrayOffset { get; }
    public bool HasArray { get; }
    public ByteOrder Order { get; }
    protected Single[] ProtectedArray { get; }
    protected int ProtectedArrayOffset { get; }
    protected bool ProtectedHasArray { get; }
    internal SingleBuffer(int capacity);
    public static SingleBuffer Allocate(int capacity);
    public static SingleBuffer Wrap(Single[] array);
    public static SingleBuffer Wrap(Single[] array, int startIndex, int length);
    public Single[] get_Array();
    public int get_ArrayOffset();
    public abstract virtual SingleBuffer AsReadOnlyBuffer();
    public abstract virtual SingleBuffer Compact();
    [NullableContextAttribute("2")]
public virtual int CompareTo(SingleBuffer other);
    public abstract virtual SingleBuffer Duplicate();
    [NullableContextAttribute("2")]
public virtual bool Equals(object other);
    public abstract virtual float Get();
    public virtual SingleBuffer Get(Single[] destination);
    public virtual SingleBuffer Get(Single[] destination, int offset, int length);
    public abstract virtual float Get(int index);
    public bool get_HasArray();
    public virtual int GetHashCode();
    public abstract virtual ByteOrder get_Order();
    protected abstract virtual Single[] get_ProtectedArray();
    protected abstract virtual int get_ProtectedArrayOffset();
    protected abstract virtual bool get_ProtectedHasArray();
    public abstract virtual SingleBuffer Put(float value);
    public SingleBuffer Put(Single[] source);
    public virtual SingleBuffer Put(Single[] source, int offset, int length);
    public virtual SingleBuffer Put(SingleBuffer source);
    public abstract virtual SingleBuffer Put(int index, float value);
    public abstract virtual SingleBuffer Slice();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class J2N.IO.SingleToByteBufferAdapter : SingleBuffer {
    private ByteBuffer byteBuffer;
    public bool IsReadOnly { get; }
    public ByteOrder Order { get; }
    protected Single[] ProtectedArray { get; }
    protected int ProtectedArrayOffset { get; }
    protected bool ProtectedHasArray { get; }
    internal SingleToByteBufferAdapter(ByteBuffer byteBuffer);
    internal static SingleBuffer Wrap(ByteBuffer byteBuffer);
    public virtual SingleBuffer AsReadOnlyBuffer();
    public virtual SingleBuffer Compact();
    public virtual SingleBuffer Duplicate();
    public virtual float Get();
    public virtual float Get(int index);
    public virtual bool get_IsReadOnly();
    public virtual ByteOrder get_Order();
    protected virtual Single[] get_ProtectedArray();
    protected virtual int get_ProtectedArrayOffset();
    protected virtual bool get_ProtectedHasArray();
    public virtual SingleBuffer Put(float value);
    public virtual SingleBuffer Put(int index, float value);
    public virtual SingleBuffer Slice();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class J2N.IO.StreamTokenizer : object {
    [CompilerGeneratedAttribute]
private double <NumberValue>k__BackingField;
    [CompilerGeneratedAttribute]
private string <StringValue>k__BackingField;
    public static int TokenType_EndOfStream;
    public static int TokenType_EndOfLine;
    public static int TokenType_Number;
    public static int TokenType_Word;
    private static int TokenType_Unknown;
    [CompilerGeneratedAttribute]
private int <TokenType>k__BackingField;
    [NullableAttribute("1")]
private Byte[] tokenTypes;
    private static byte Token_Comment;
    private static byte Token_Quote;
    private static byte Token_White;
    private static byte Token_Word;
    private static byte Token_Digit;
    private bool pushBackToken;
    private bool lastCr;
    private Stream inStream;
    private TextReader inReader;
    private int peekChar;
    [CompilerGeneratedAttribute]
private bool <EndOfLineIsSignificant>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LineNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <LowerCaseMode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SlashSlashComments>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SlashStarComments>k__BackingField;
    public double NumberValue { get; public set; }
    public string StringValue { get; public set; }
    public int TokenType { get; private set; }
    public bool EndOfLineIsSignificant { get; public set; }
    public int LineNumber { get; private set; }
    public bool LowerCaseMode { get; public set; }
    public bool SlashSlashComments { get; public set; }
    public bool SlashStarComments { get; public set; }
    [NullableContextAttribute("1")]
[ObsoleteAttribute("Use StreamTokenizer(TextReader)")]
public StreamTokenizer(Stream input);
    [NullableContextAttribute("1")]
public StreamTokenizer(TextReader reader);
    [CompilerGeneratedAttribute]
public double get_NumberValue();
    [CompilerGeneratedAttribute]
public void set_NumberValue(double value);
    [CompilerGeneratedAttribute]
public string get_StringValue();
    [CompilerGeneratedAttribute]
public void set_StringValue(string value);
    [CompilerGeneratedAttribute]
public int get_TokenType();
    [CompilerGeneratedAttribute]
private void set_TokenType(int value);
    public virtual void CommentChar(int ch);
    [CompilerGeneratedAttribute]
public virtual bool get_EndOfLineIsSignificant();
    [CompilerGeneratedAttribute]
public virtual void set_EndOfLineIsSignificant(bool value);
    [CompilerGeneratedAttribute]
public virtual int get_LineNumber();
    [CompilerGeneratedAttribute]
private void set_LineNumber(int value);
    [CompilerGeneratedAttribute]
public virtual bool get_LowerCaseMode();
    [CompilerGeneratedAttribute]
public virtual void set_LowerCaseMode(bool value);
    public virtual int NextToken();
    public virtual void OrdinaryChar(int ch);
    public virtual void OrdinaryChars(int low, int hi);
    public virtual void ParseNumbers();
    public virtual void PushBack();
    public virtual void QuoteChar(int ch);
    private int Read();
    public virtual void ResetSyntax();
    [CompilerGeneratedAttribute]
public virtual bool get_SlashSlashComments();
    [CompilerGeneratedAttribute]
public virtual void set_SlashSlashComments(bool value);
    [CompilerGeneratedAttribute]
public virtual bool get_SlashStarComments();
    [CompilerGeneratedAttribute]
public virtual void set_SlashStarComments(bool value);
    [NullableContextAttribute("1")]
public virtual string ToString();
    public virtual void WhitespaceChars(int low, int hi);
    public virtual void WordChars(int low, int hi);
}
[ExtensionAttribute]
public static class J2N.MathExtensions : object {
    private static int SingleSignBitMask;
    private static long DoubleSignBitMask;
    [ExtensionAttribute]
public static int Signum(int value);
    [ExtensionAttribute]
public static int Signum(long value);
    [ExtensionAttribute]
public static double ToRadians(double degrees);
    [ExtensionAttribute]
public static decimal ToRadians(decimal degrees);
    [ExtensionAttribute]
public static double ToRadians(int degrees);
    [ExtensionAttribute]
public static double ToDegrees(double radians);
    [ExtensionAttribute]
public static decimal ToDegrees(decimal radians);
    [ExtensionAttribute]
public static double ToDegrees(int radians);
    [ExtensionAttribute]
public static double NextAfter(double start, double direction);
    [ExtensionAttribute]
public static float NextAfter(float start, double direction);
    [ExtensionAttribute]
public static double NextUp(double value);
    [ExtensionAttribute]
public static float NextUp(float value);
    [ExtensionAttribute]
public static double NextDown(double value);
    [ExtensionAttribute]
public static float NextDown(float value);
    [ExtensionAttribute]
public static double CopySign(double x, double y);
    internal static UInt32 DivRem(UInt32 a, UInt32 b, UInt32& result);
    internal static ulong DivRem(ulong a, ulong b, UInt64& result);
}
[ExtensionAttribute]
public static class J2N.Numerics.BitOperation : object {
    [ExtensionAttribute]
public static int PopCount(int value);
    [ExtensionAttribute]
public static int PopCount(long value);
    [ExtensionAttribute]
public static int LeadingZeroCount(int value);
    [ExtensionAttribute]
public static int LeadingZeroCount(long value);
    [ExtensionAttribute]
public static int TrailingZeroCount(int value);
    [ExtensionAttribute]
public static int TrailingZeroCount(long value);
    [ExtensionAttribute]
public static int HighestOneBit(int value);
    [ExtensionAttribute]
public static long HighestOneBit(long value);
    [ExtensionAttribute]
internal static int Log2(UInt32 value);
    [ExtensionAttribute]
internal static int Log2(ulong value);
    [ExtensionAttribute]
public static int LowestOneBit(int value);
    [ExtensionAttribute]
public static long LowestOneBit(long value);
    [ExtensionAttribute]
public static int Reverse(int value);
    [ExtensionAttribute]
public static long Reverse(long value);
    [ExtensionAttribute]
public static short ReverseBytes(short value);
    [ExtensionAttribute]
public static int ReverseBytes(int value);
    [ExtensionAttribute]
public static long ReverseBytes(long value);
    [ExtensionAttribute]
public static int RotateLeft(int value, int distance);
    [ExtensionAttribute]
public static long RotateLeft(long value, int distance);
    [ExtensionAttribute]
public static int RotateRight(int value, int distance);
    [ExtensionAttribute]
public static long RotateRight(long value, int distance);
    [ExtensionAttribute]
public static int TripleShift(byte number, int bits);
    [ExtensionAttribute]
[CLSCompliantAttribute("False")]
public static int TripleShift(sbyte number, int bits);
    [ExtensionAttribute]
public static int TripleShift(char number, int bits);
    [ExtensionAttribute]
public static int TripleShift(short number, int bits);
    [ExtensionAttribute]
public static int TripleShift(int number, int bits);
    [ExtensionAttribute]
public static long TripleShift(long number, int bits);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{value}")]
public class J2N.Numerics.Byte : Number {
    private byte value;
    public static int Size;
    private static Byte[] Cache;
    internal Byte(byte value);
    private static Byte();
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(Byte value);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object value);
    public static Byte Decode(string s);
    public static bool TryDecode(string s, Byte& result);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(Byte obj);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("0")]
public static byte Parse(ReadOnlySpan`1<char> s, int startIndex, int length, int radix);
    public static byte Parse(string s, int startIndex, int length, int radix);
    public static byte Parse(Char[] s, int startIndex, int length, int radix);
    public static byte Parse(StringBuilder s, int startIndex, int length, int radix);
    public static byte Parse(ICharSequence s, int startIndex, int length, int radix);
    [NullableContextAttribute("0")]
public static bool TryParse(ReadOnlySpan`1<char> s, int startIndex, int length, int radix, Byte& result);
    public static bool TryParse(string s, int startIndex, int length, int radix, Byte& result);
    public static bool TryParse(Char[] s, int startIndex, int length, int radix, Byte& result);
    public static bool TryParse(StringBuilder s, int startIndex, int length, int radix, Byte& result);
    public static bool TryParse(ICharSequence s, int startIndex, int length, int radix, Byte& result);
    [NullableContextAttribute("2")]
public static byte Parse(string s, int radix);
    [NullableContextAttribute("2")]
public static bool TryParse(string s, int radix, Byte& result);
    public static byte Parse(string s, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string s, Byte& result);
    [NullableContextAttribute("0")]
public static bool TryParse(ReadOnlySpan`1<char> s, Byte& result);
    public static byte Parse(string s, NumberStyle style, IFormatProvider provider);
    [NullableContextAttribute("0")]
public static byte Parse(ReadOnlySpan`1<char> s, NumberStyle style, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string s, NumberStyle style, IFormatProvider provider, Byte& result);
    [NullableContextAttribute("0")]
public static bool TryParse(ReadOnlySpan`1<char> s, NumberStyle style, IFormatProvider provider, Byte& result);
    public virtual string ToString();
    public virtual string ToString(string format);
    public virtual string ToString(IFormatProvider provider);
    [NullableContextAttribute("2")]
public virtual string ToString(string format, IFormatProvider provider);
    public static string ToString(byte value);
    public static string ToString(byte value, string format);
    public static string ToString(byte value, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static string ToString(byte value, string format, IFormatProvider provider);
    public static Byte GetInstance(string s, IFormatProvider provider);
    public static Byte GetInstance(string s, NumberStyle style, IFormatProvider provider);
    public static Byte GetInstance(string s, int radix);
    public static Byte GetInstance(byte value);
    public static byte op_Implicit(Byte value);
    public static Byte op_Implicit(byte value);
    public virtual byte ToByte();
    public virtual double ToDouble();
    public virtual short ToInt16();
    public virtual int ToInt32();
    public virtual long ToInt64();
    [CLSCompliantAttribute("False")]
public virtual sbyte ToSByte();
    public virtual float ToSingle();
    public sealed virtual TypeCode GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class J2N.Numerics.DotNetNumber : object {
    internal static int DecimalPrecision;
    private static int HalfPrecision;
    private static int SinglePrecision;
    private static int DoublePrecision;
    private static int HalfPrecisionCustomFormat;
    private static int SinglePrecisionCustomFormat;
    private static int DoublePrecisionCustomFormat;
    private static int DefaultPrecisionExponentialFormat;
    private static int MaxUInt32DecDigits;
    private static int CharStackBufferSize;
    private static string PosNumberFormat;
    private static String[] s_singleDigitStringCache;
    private static String[] s_posCurrencyFormats;
    private static String[] s_negCurrencyFormats;
    private static String[] s_posPercentFormats;
    private static String[] s_negPercentFormats;
    private static String[] s_negNumberFormats;
    internal static int DecimalNumberBufferLength;
    internal static int DoubleNumberBufferLength;
    internal static int Int32NumberBufferLength;
    internal static int Int64NumberBufferLength;
    internal static int SingleNumberBufferLength;
    internal static int HalfNumberBufferLength;
    internal static int UInt32NumberBufferLength;
    internal static int UInt64NumberBufferLength;
    private static Single[] s_Pow10SingleTable;
    private static Double[] s_Pow10DoubleTable;
    private static int Int32Precision;
    private static int UInt32Precision;
    private static int Int64Precision;
    private static int UInt64Precision;
    private static int DoubleMaxExponent;
    private static int DoubleMinExponent;
    private static int FloatingPointMaxExponent;
    private static int FloatingPointMinExponent;
    private static int SingleMaxExponent;
    private static int SingleMinExponent;
    private static int HalfMaxExponent;
    private static int HalfMinExponent;
    private static DotNetNumber();
    public static void Dragon4Double(double value, int cutoffNumber, bool isSignificantDigits, NumberBuffer& number);
    public static void Dragon4Single(float value, int cutoffNumber, bool isSignificantDigits, NumberBuffer& number);
    private static UInt32 Dragon4(ulong mantissa, int exponent, UInt32 mantissaHighBitIdx, bool hasUnequalMargins, int cutoffNumber, bool isSignificantDigits, Byte[] buffer, Int32& decimalExponent);
    [NullableContextAttribute("2")]
public static string FormatDouble(double value, string format, IFormatProvider provider);
    private static int GetFloatingPointMaxDigitsAndPrecision(char fmt, Int32& precision, NumberFormatInfo info, Boolean& isSignificantDigits);
    private static string FormatDouble(StringBuilder sb, double value, string format, NumberFormatInfo info);
    [NullableContextAttribute("2")]
public static string FormatSingle(float value, string format, IFormatProvider provider);
    private static string FormatSingle(StringBuilder sb, float value, string format, NumberFormatInfo info);
    [NullableContextAttribute("0")]
private static bool TryCopyTo(string source, Span`1<char> destination, Int32& charsWritten);
    private static char GetHexBase(char fmt);
    [NullableContextAttribute("0")]
internal static Char* UInt32ToDecChars(Char* bufferEnd, UInt32 value, int digits);
    [NullableContextAttribute("0")]
internal static char ParseFormatSpecifier(ReadOnlySpan`1<char> format, Int32& digits);
    internal static char ParseFormatSpecifier(string format, Int32& digits);
    internal static void NumberToString(StringBuilder sb, NumberBuffer& number, char format, int nMaxDigits, NumberFormatInfo info);
    internal static void NumberToStringFormat(StringBuilder sb, NumberBuffer& number, string format, NumberFormatInfo info);
    private static void FormatCurrency(StringBuilder sb, NumberBuffer& number, int nMaxDigits, NumberFormatInfo info);
    [NullableContextAttribute("2")]
private static void FormatFixed(StringBuilder sb, NumberBuffer& number, int nMaxDigits, Int32[] groupDigits, string sDecimal, string sGroup);
    private static void FormatNumber(StringBuilder sb, NumberBuffer& number, int nMaxDigits, NumberFormatInfo info);
    private static void FormatScientific(StringBuilder sb, NumberBuffer& number, int nMaxDigits, NumberFormatInfo info, char expChar);
    private static void FormatExponent(StringBuilder sb, NumberFormatInfo info, int value, char expChar, int minDigits, bool positiveSign);
    [NullableContextAttribute("0")]
private static T[] Create(T* ptr, int length);
    private static void FormatGeneral(StringBuilder sb, NumberBuffer& number, int nMaxDigits, NumberFormatInfo info, char expChar, bool bSuppressScientific);
    private static void FormatPercent(StringBuilder sb, NumberBuffer& number, int nMaxDigits, NumberFormatInfo info);
    internal static void RoundNumber(NumberBuffer& number, int pos, bool isCorrectlyRounded);
    [NullableContextAttribute("0")]
private static int FindSection(ReadOnlySpan`1<char> format, int section);
    private static int FindSection(string format, int section);
    private static ulong ExtractFractionAndBiasedExponent(double value, Int32& exponent);
    private static UInt32 ExtractFractionAndBiasedExponent(float value, Int32& exponent);
    private static void AccumulateDecimalDigitsIntoBigInteger(NumberBuffer& number, UInt32 firstIndex, UInt32 lastIndex, BigInteger& result);
    private static ulong AssembleFloatingPointBits(FloatingPointInfo& info, ulong initialMantissa, int initialExponent, bool hasZeroTail);
    private static ulong ConvertBigIntegerToFloatingPointBits(BigInteger& value, FloatingPointInfo& info, UInt32 integerBitsOfPrecision, bool hasNonZeroFractionalPart);
    [NullableContextAttribute("0")]
private static UInt32 DigitsToUInt32(Byte* p, int count);
    private static UInt32 DigitsToUInt32(Byte[] p, int offset, int count);
    [NullableContextAttribute("0")]
private static ulong DigitsToUInt64(Byte* p, int count);
    private static ulong DigitsToUInt64(Byte[] p, int offset, int count);
    private static ulong NumberToFloatingPointBits(NumberBuffer& number, FloatingPointInfo& info);
    private static ulong NumberToFloatingPointBitsSlow(NumberBuffer& number, FloatingPointInfo& info, UInt32 positiveExponent, UInt32 integerDigitsPresent, UInt32 fractionalDigitsPresent);
    private static ulong RightShiftWithRounding(ulong value, int shift, bool hasZeroTail);
    private static bool ShouldRoundUp(bool lsbBit, bool roundBit, bool hasTailBits);
    private static bool TryNumberToInt32(NumberBuffer& number, Int32& value);
    [NullableContextAttribute("0")]
private static bool TryParseNumber(Char*& str, Char* strEnd, NumberStyle styles, NumberBuffer& number, NumberFormatInfo info);
    [NullableContextAttribute("0")]
private static bool TryParseFloatingPointHexNumber(Char*& str, Char* strEnd, NumberStyle styles, FloatingPointHexNumberBuffer number, NumberFormatInfo info);
    [NullableContextAttribute("0")]
internal static ParsingStatus TryParseInt32(ReadOnlySpan`1<char> value, NumberStyle styles, NumberFormatInfo info, Int32& result);
    internal static ParsingStatus TryParseInt32(string value, NumberStyle styles, NumberFormatInfo info, Int32& result);
    [NullableContextAttribute("0")]
private static ParsingStatus TryParseInt32Number(ReadOnlySpan`1<char> value, NumberStyle styles, NumberFormatInfo info, Int32& result);
    private static ParsingStatus TryParseInt32Number(string value, NumberStyle styles, NumberFormatInfo info, Int32& result);
    [NullableContextAttribute("0")]
internal static ParsingStatus TryParseInt32IntegerStyle(ReadOnlySpan`1<char> value, NumberStyle styles, NumberFormatInfo info, Int32& result);
    internal static ParsingStatus TryParseInt32IntegerStyle(string value, NumberStyle styles, NumberFormatInfo info, Int32& result);
    [NullableContextAttribute("0")]
private static ParsingStatus TryParseUInt32HexNumberStyle(ReadOnlySpan`1<char> value, NumberStyle styles, UInt32& result);
    private static ParsingStatus TryParseUInt32HexNumberStyle(string value, NumberStyle styles, UInt32& result);
    [NullableContextAttribute("0")]
internal static double ParseDouble(ReadOnlySpan`1<char> value, NumberStyle styles, NumberFormatInfo info);
    internal static double ParseDouble(string value, NumberStyle styles, NumberFormatInfo info);
    [NullableContextAttribute("0")]
internal static float ParseSingle(ReadOnlySpan`1<char> value, NumberStyle styles, NumberFormatInfo info);
    internal static float ParseSingle(string value, NumberStyle styles, NumberFormatInfo info);
    [NullableContextAttribute("0")]
internal static bool TryParseDouble(ReadOnlySpan`1<char> value, NumberStyle styles, NumberFormatInfo info, Double& result);
    internal static bool TryParseDouble(string value, NumberStyle styles, NumberFormatInfo info, Double& result);
    [NullableContextAttribute("0")]
internal static bool TryParseDoubleFloatStyle(ReadOnlySpan`1<char> value, NumberStyle styles, NumberFormatInfo info, Double& result);
    internal static bool TryParseDoubleFloatStyle(string value, NumberStyle styles, NumberFormatInfo info, Double& result);
    [NullableContextAttribute("0")]
internal static bool TryParseDoubleHexFloatStyle(ReadOnlySpan`1<char> value, NumberStyle styles, NumberFormatInfo info, Double& result);
    internal static bool TryParseDoubleHexFloatStyle(string value, NumberStyle styles, NumberFormatInfo info, Double& result);
    [NullableContextAttribute("0")]
internal static bool TryParseSingle(ReadOnlySpan`1<char> value, NumberStyle styles, NumberFormatInfo info, Single& result);
    internal static bool TryParseSingle(string value, NumberStyle styles, NumberFormatInfo info, Single& result);
    [NullableContextAttribute("0")]
internal static bool TryParseSingleFloatStyle(ReadOnlySpan`1<char> value, NumberStyle styles, NumberFormatInfo info, Single& result);
    internal static bool TryParseSingleFloatStyle(string value, NumberStyle styles, NumberFormatInfo info, Single& result);
    [NullableContextAttribute("0")]
internal static bool TryParseSingleHexFloatStyle(ReadOnlySpan`1<char> value, NumberStyle styles, NumberFormatInfo info, Single& result);
    internal static bool TryParseSingleHexFloatStyle(string value, NumberStyle styles, NumberFormatInfo info, Single& result);
    [NullableContextAttribute("0")]
internal static bool TryStringToNumber(ReadOnlySpan`1<char> value, NumberStyle styles, NumberBuffer& number, NumberFormatInfo info);
    internal static bool TryStringToNumber(string value, NumberStyle styles, NumberBuffer& number, NumberFormatInfo info);
    internal static bool TryStringToFloatingPointHexNumber(ReadOnlySpan`1<char> value, NumberStyle styles, FloatingPointHexNumberBuffer number, NumberFormatInfo info);
    internal static bool TryStringToFloatingPointHexNumber(string value, NumberStyle styles, FloatingPointHexNumberBuffer number, NumberFormatInfo info);
    [NullableContextAttribute("0")]
private static bool TrailingZeros(ReadOnlySpan`1<char> value, int index);
    private static bool TrailingZeros(string value, int index);
    private static bool IsSpaceReplacingChar(char c);
    [NullableContextAttribute("0")]
private static Char* MatchChars(Char* p, Char* pEnd, string value);
    internal static bool IsWhite(int ch);
    private static bool IsDigit(int ch);
    private static bool IsFloatTypeSuffix(int ch);
    private static bool IsIntegralTypeSuffix(int ch);
    private static bool IsUnsignedTypeSuffix(int ch);
    [DoesNotReturnAttribute]
internal static void ThrowFormatException(string value);
    [DoesNotReturnAttribute]
internal static void ThrowOverflowException(TypeCode type);
    private static Exception GetException(TypeCode type);
    internal static double NumberToDouble(NumberBuffer& number);
    internal static float NumberToSingle(NumberBuffer& number);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static string <FormatDouble>g__FormatDoubleSlow|25_0(double value, string format, IFormatProvider provider);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static string <FormatSingle>g__FormatSingleSlow|28_0(float value, string format, IFormatProvider provider);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static bool <RoundNumber>g__ShouldRoundUp|45_0(Byte* dig, int i, NumberBufferKind numberKind, bool isCorrectlyRounded);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{value}")]
public class J2N.Numerics.Double : Number {
    private double value;
    public static int MaxExponent;
    public static int MinExponent;
    public static double MinNormal;
    public static int Size;
    internal Double(double value);
    public sealed virtual int CompareTo(Double value);
    public sealed virtual int CompareTo(object value);
    internal static long DoubleToInt64Bits(double value);
    internal static long DoubleToRawInt64Bits(double value);
    public sealed virtual bool Equals(Double obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public bool IsFinite();
    public bool IsInfinity();
    public bool IsNaN();
    public bool IsNegative();
    public bool IsNegativeInfinity();
    public bool IsNegativeZero();
    public bool IsNormal();
    public bool IsPositiveInfinity();
    public bool IsSubnormal();
    internal static double Int64BitsToDouble(long value);
    [NullableContextAttribute("1")]
public static double Parse(string s, IFormatProvider provider);
    public static bool TryParse(string s, Double& result);
    [NullableContextAttribute("0")]
public static bool TryParse(ReadOnlySpan`1<char> s, Double& result);
    [NullableContextAttribute("1")]
public static double Parse(string s, NumberStyle style, IFormatProvider provider);
    [NullableContextAttribute("0")]
public static double Parse(ReadOnlySpan`1<char> s, NumberStyle style, IFormatProvider provider);
    public static bool TryParse(string s, NumberStyle style, IFormatProvider provider, Double& result);
    [NullableContextAttribute("0")]
public static bool TryParse(ReadOnlySpan`1<char> s, NumberStyle style, IFormatProvider provider, Double& result);
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public virtual string ToString(string format);
    [NullableContextAttribute("1")]
public virtual string ToString(IFormatProvider provider);
    public virtual string ToString(string format, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static string ToString(double value);
    [NullableContextAttribute("1")]
public static string ToString(double value, string format);
    [NullableContextAttribute("1")]
public static string ToString(double value, IFormatProvider provider);
    public static string ToString(double value, string format, IFormatProvider provider);
    public static int Compare(double doubleA, double doubleB);
    [NullableContextAttribute("1")]
public static Double GetInstance(string s, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static Double GetInstance(string s, NumberStyle style, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static Double GetInstance(double value);
    [NullableContextAttribute("1")]
public string ToHexString(IFormatProvider provider);
    [NullableContextAttribute("1")]
public static double op_Implicit(Double value);
    [NullableContextAttribute("1")]
public static Double op_Implicit(double value);
    public virtual byte ToByte();
    public virtual double ToDouble();
    public virtual short ToInt16();
    public virtual int ToInt32();
    public virtual long ToInt64();
    [CLSCompliantAttribute("False")]
public virtual sbyte ToSByte();
    public virtual float ToSingle();
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("1")]
private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{value}")]
public class J2N.Numerics.Int16 : Number {
    private short value;
    public static int Size;
    internal Int16(short value);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(Int16 value);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object value);
    public static Int16 Decode(string s);
    public static bool TryDecode(string s, Int16& result);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(Int16 obj);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("0")]
public static short Parse(ReadOnlySpan`1<char> s, int startIndex, int length, int radix);
    public static short Parse(string s, int startIndex, int length, int radix);
    public static short Parse(Char[] s, int startIndex, int length, int radix);
    public static short Parse(StringBuilder s, int startIndex, int length, int radix);
    public static short Parse(ICharSequence s, int startIndex, int length, int radix);
    [NullableContextAttribute("0")]
public static bool TryParse(ReadOnlySpan`1<char> s, int startIndex, int length, int radix, Int16& result);
    public static bool TryParse(string s, int startIndex, int length, int radix, Int16& result);
    public static bool TryParse(Char[] s, int startIndex, int length, int radix, Int16& result);
    public static bool TryParse(StringBuilder s, int startIndex, int length, int radix, Int16& result);
    public static bool TryParse(ICharSequence s, int startIndex, int length, int radix, Int16& result);
    [NullableContextAttribute("2")]
public static short Parse(string s, int radix);
    [NullableContextAttribute("2")]
public static bool TryParse(string s, int radix, Int16& result);
    public static short Parse(string s, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string s, Int16& result);
    [NullableContextAttribute("0")]
public static bool TryParse(ReadOnlySpan`1<char> s, Int16& result);
    public static short Parse(string s, NumberStyle style, IFormatProvider provider);
    [NullableContextAttribute("0")]
public static short Parse(ReadOnlySpan`1<char> s, NumberStyle style, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string s, NumberStyle style, IFormatProvider provider, Int16& result);
    [NullableContextAttribute("0")]
public static bool TryParse(ReadOnlySpan`1<char> s, NumberStyle style, IFormatProvider provider, Int16& result);
    public virtual string ToString();
    public virtual string ToString(string format);
    public virtual string ToString(IFormatProvider provider);
    [NullableContextAttribute("2")]
public virtual string ToString(string format, IFormatProvider provider);
    public static string ToString(short value);
    public static string ToString(short value, string format);
    public static string ToString(short value, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static string ToString(short value, string format, IFormatProvider provider);
    internal static short ReverseBytes(short value);
    public static Int16 GetInstance(string s, IFormatProvider provider);
    public static Int16 GetInstance(string s, NumberStyle style, IFormatProvider provider);
    public static Int16 GetInstance(string s, int radix);
    public static Int16 GetInstance(short value);
    public static short op_Implicit(Int16 value);
    public static Int16 op_Implicit(short value);
    public virtual byte ToByte();
    public virtual double ToDouble();
    public virtual short ToInt16();
    public virtual int ToInt32();
    public virtual long ToInt64();
    [CLSCompliantAttribute("False")]
public virtual sbyte ToSByte();
    public virtual float ToSingle();
    public sealed virtual TypeCode GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{value}")]
public class J2N.Numerics.Int32 : Number {
    public static int Size;
    private int value;
    internal Int32(int value);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(Int32 value);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object value);
    public static Int32 Decode(string s);
    public static bool TryDecode(string s, Int32& result);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(Int32 obj);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    internal static int ParseUnsigned(string s, int startIndex, int length, int radix);
    [NullableContextAttribute("2")]
internal static int ParseUnsigned(string s, int radix);
    [NullableContextAttribute("0")]
public static int Parse(ReadOnlySpan`1<char> s, int startIndex, int length, int radix);
    public static int Parse(string s, int startIndex, int length, int radix);
    public static int Parse(Char[] s, int startIndex, int length, int radix);
    public static int Parse(StringBuilder s, int startIndex, int length, int radix);
    public static int Parse(ICharSequence s, int startIndex, int length, int radix);
    [NullableContextAttribute("0")]
public static bool TryParse(ReadOnlySpan`1<char> s, int startIndex, int length, int radix, Int32& result);
    public static bool TryParse(string s, int startIndex, int length, int radix, Int32& result);
    public static bool TryParse(Char[] s, int startIndex, int length, int radix, Int32& result);
    public static bool TryParse(StringBuilder s, int startIndex, int length, int radix, Int32& result);
    public static bool TryParse(ICharSequence s, int startIndex, int length, int radix, Int32& result);
    [NullableContextAttribute("2")]
public static int Parse(string s, int radix);
    [NullableContextAttribute("2")]
public static bool TryParse(string s, int radix, Int32& result);
    public static int Parse(string s, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string s, Int32& result);
    [NullableContextAttribute("0")]
public static bool TryParse(ReadOnlySpan`1<char> s, Int32& result);
    public static int Parse(string s, NumberStyle style, IFormatProvider provider);
    [NullableContextAttribute("0")]
public static int Parse(ReadOnlySpan`1<char> s, NumberStyle style, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string s, NumberStyle style, IFormatProvider provider, Int32& result);
    [NullableContextAttribute("0")]
public static bool TryParse(ReadOnlySpan`1<char> s, NumberStyle style, IFormatProvider provider, Int32& result);
    public string ToBinaryString();
    public string ToHexString();
    public string ToOctalString();
    public virtual string ToString();
    public virtual string ToString(string format);
    public virtual string ToString(IFormatProvider provider);
    [NullableContextAttribute("2")]
public virtual string ToString(string format, IFormatProvider provider);
    public static string ToString(int value);
    public static string ToString(int value, string format);
    public static string ToString(int value, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static string ToString(int value, string format, IFormatProvider provider);
    internal static int HighestOneBit(int value);
    internal static int LowestOneBit(int value);
    internal static int LeadingZeroCount(int value);
    internal static int TrailingZeroCount(int value);
    internal static int PopCount(int value);
    internal static int RotateLeft(int value, int distance);
    internal static int RotateRight(int value, int distance);
    internal static int ReverseBytes(int value);
    internal static int Reverse(int value);
    internal static int Signum(int value);
    public static Int32 GetInstance(string s, IFormatProvider provider);
    public static Int32 GetInstance(string s, NumberStyle style, IFormatProvider provider);
    public static Int32 GetInstance(string s, int radix);
    public static Int32 GetInstance(int value);
    public static int op_Implicit(Int32 value);
    public static Int32 op_Implicit(int value);
    public virtual byte ToByte();
    public virtual double ToDouble();
    public virtual short ToInt16();
    public virtual int ToInt32();
    public virtual long ToInt64();
    [CLSCompliantAttribute("False")]
public virtual sbyte ToSByte();
    public virtual float ToSingle();
    public sealed virtual TypeCode GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{value}")]
public class J2N.Numerics.Int64 : Number {
    private long value;
    public static int Size;
    internal Int64(long value);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(Int64 value);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object value);
    public static Int64 Decode(string s);
    public static bool TryDecode(string s, Int64& result);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(Int64 obj);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    internal static long ParseUnsigned(string s, int startIndex, int length, int radix);
    [NullableContextAttribute("2")]
internal static long ParseUnsigned(string s, int radix);
    [NullableContextAttribute("0")]
public static long Parse(ReadOnlySpan`1<char> s, int startIndex, int length, int radix);
    public static long Parse(string s, int startIndex, int length, int radix);
    public static long Parse(Char[] s, int startIndex, int length, int radix);
    public static long Parse(StringBuilder s, int startIndex, int length, int radix);
    public static long Parse(ICharSequence s, int startIndex, int length, int radix);
    [NullableContextAttribute("0")]
public static bool TryParse(ReadOnlySpan`1<char> s, int startIndex, int length, int radix, Int64& result);
    public static bool TryParse(string s, int startIndex, int length, int radix, Int64& result);
    public static bool TryParse(Char[] s, int startIndex, int length, int radix, Int64& result);
    public static bool TryParse(StringBuilder s, int startIndex, int length, int radix, Int64& result);
    public static bool TryParse(ICharSequence s, int startIndex, int length, int radix, Int64& result);
    [NullableContextAttribute("2")]
public static long Parse(string s, int radix);
    [NullableContextAttribute("2")]
public static bool TryParse(string s, int radix, Int64& result);
    public static long Parse(string s, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string s, Int64& result);
    [NullableContextAttribute("0")]
public static bool TryParse(ReadOnlySpan`1<char> s, Int64& result);
    public static long Parse(string s, NumberStyle style, IFormatProvider provider);
    [NullableContextAttribute("0")]
public static long Parse(ReadOnlySpan`1<char> s, NumberStyle style, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string s, NumberStyle style, IFormatProvider provider, Int64& result);
    [NullableContextAttribute("0")]
public static bool TryParse(ReadOnlySpan`1<char> s, NumberStyle style, IFormatProvider provider, Int64& result);
    public string ToBinaryString();
    public string ToHexString();
    public string ToOctalString();
    public virtual string ToString();
    public virtual string ToString(string format);
    public virtual string ToString(IFormatProvider provider);
    [NullableContextAttribute("2")]
public virtual string ToString(string format, IFormatProvider provider);
    public static string ToString(long value);
    public static string ToString(long value, string format);
    public static string ToString(long value, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static string ToString(long value, string format, IFormatProvider provider);
    internal static long HighestOneBit(long value);
    internal static long LowestOneBit(long value);
    internal static int LeadingZeroCount(long value);
    internal static int TrailingZeroCount(long value);
    internal static int PopCount(long value);
    internal static long RotateLeft(long value, int distance);
    internal static long RotateRight(long value, int distance);
    internal static long ReverseBytes(long value);
    internal static long Reverse(long value);
    internal static int Signum(long value);
    public static Int64 GetInstance(string s, IFormatProvider provider);
    public static Int64 GetInstance(string s, NumberStyle style, IFormatProvider provider);
    public static Int64 GetInstance(string s, int radix);
    public static Int64 GetInstance(long value);
    public static long op_Implicit(Int64 value);
    public static Int64 op_Implicit(long value);
    public virtual byte ToByte();
    public virtual double ToDouble();
    public virtual short ToInt16();
    public virtual int ToInt32();
    public virtual long ToInt64();
    [CLSCompliantAttribute("False")]
public virtual sbyte ToSByte();
    public virtual float ToSingle();
    public sealed virtual TypeCode GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
}
[ExtensionAttribute]
internal static class J2N.Numerics.MemoryExtensions : object {
    [ExtensionAttribute]
internal static bool EqualsOrdinalIgnoreCase(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> value);
    internal static bool EqualsIgnoreCase(Char& charA, ReadOnlySpan`1<char> spanA, Char& charB, ReadOnlySpan`1<char> spanB, int length);
    internal static bool AllCharsInUInt32AreAscii(UInt32 value);
    internal static bool UInt32OrdinalIgnoreCaseAscii(UInt32 valueA, UInt32 valueB);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class J2N.Numerics.Number : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Type[] ConvertTypes;
    private static Type EnumType;
    private static Number();
    public virtual byte ToByte();
    [CLSCompliantAttribute("False")]
public virtual sbyte ToSByte();
    public abstract virtual double ToDouble();
    public abstract virtual float ToSingle();
    public abstract virtual int ToInt32();
    public abstract virtual long ToInt64();
    public virtual short ToInt16();
    public virtual string ToString();
    public virtual string ToString(string format);
    public virtual string ToString(IFormatProvider provider);
    [NullableContextAttribute("2")]
public abstract virtual string ToString(string format, IFormatProvider provider);
    internal static object DefaultToType(IConvertible value, Type targetType, IFormatProvider provider);
    [NullableContextAttribute("2")]
internal static string ConvertFormat(string format);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class J2N.Numerics.ParseNumbers : object {
    internal static int LeftAlign;
    internal static int RightAlign;
    internal static int PrefixSpace;
    internal static int PrintSign;
    internal static int PrintBase;
    internal static int PrintAsI1;
    internal static int PrintAsI2;
    internal static int PrintAsI4;
    internal static int TreatAsUnsigned;
    internal static int TreatAsI1;
    internal static int TreatAsI2;
    internal static int IsTight;
    internal static int NoSpace;
    internal static int PrintRadixBase;
    [NullableContextAttribute("0")]
public static long StringToLong(ReadOnlySpan`1<char> s, int radix, int flags);
    [NullableContextAttribute("0")]
public static long StringToLong(ReadOnlySpan`1<char> s, int radix, int flags, int sign, Int32& currPos, int length);
    public static long StringToLong(string s, int radix, int flags);
    public static long StringToLong(string s, int radix, int flags, int sign, Int32& currPos, int length);
    public static long StringToLong(Char[] s, int radix, int flags);
    public static long StringToLong(Char[] s, int radix, int flags, int sign, Int32& currPos, int length);
    public static long StringToLong(ICharSequence s, int radix, int flags);
    public static long StringToLong(ICharSequence s, int radix, int flags, int sign, Int32& currPos, int length);
    [NullableContextAttribute("0")]
public static bool TryStringToLong(ReadOnlySpan`1<char> s, int radix, int flags, Int64& result);
    [NullableContextAttribute("0")]
public static bool TryStringToLong(ReadOnlySpan`1<char> s, int radix, int flags, int sign, Int32& currPos, int length, Int64& result);
    public static bool TryStringToLong(string s, int radix, int flags, Int64& result);
    public static bool TryStringToLong(string s, int radix, int flags, int sign, Int32& currPos, int length, Int64& result);
    public static bool TryStringToLong(Char[] s, int radix, int flags, Int64& result);
    public static bool TryStringToLong(Char[] s, int radix, int flags, int sign, Int32& currPos, int length, Int64& result);
    public static bool TryStringToLong(ICharSequence s, int radix, int flags, Int64& result);
    public static bool TryStringToLong(ICharSequence s, int radix, int flags, int sign, Int32& currPos, int length, Int64& result);
    [NullableContextAttribute("0")]
public static int StringToInt(ReadOnlySpan`1<char> s, int radix, int flags);
    [NullableContextAttribute("0")]
public static int StringToInt(ReadOnlySpan`1<char> s, int radix, int flags, int sign, Int32& currPos, int length);
    public static int StringToInt(string s, int radix, int flags);
    public static int StringToInt(string s, int radix, int flags, int sign, Int32& currPos, int length);
    public static int StringToInt(Char[] s, int radix, int flags);
    public static int StringToInt(Char[] s, int radix, int flags, int sign, Int32& currPos, int length);
    public static int StringToInt(ICharSequence s, int radix, int flags);
    public static int StringToInt(ICharSequence s, int radix, int flags, int sign, Int32& currPos, int length);
    [NullableContextAttribute("0")]
public static bool TryStringToInt(ReadOnlySpan`1<char> s, int radix, int flags, Int32& result);
    [NullableContextAttribute("0")]
public static bool TryStringToInt(ReadOnlySpan`1<char> s, int radix, int flags, int sign, Int32& currPos, int length, Int32& result);
    public static bool TryStringToInt(string s, int radix, int flags, Int32& result);
    public static bool TryStringToInt(string s, int radix, int flags, int sign, Int32& currPos, int length, Int32& result);
    public static bool TryStringToInt(Char[] s, int radix, int flags, Int32& result);
    public static bool TryStringToInt(Char[] s, int radix, int flags, int sign, Int32& currPos, int length, Int32& result);
    public static bool TryStringToInt(ICharSequence s, int radix, int flags, Int32& result);
    public static bool TryStringToInt(ICharSequence s, int radix, int flags, int sign, Int32& currPos, int length, Int32& result);
    [NullableContextAttribute("0")]
private static void EatWhiteSpace(ReadOnlySpan`1<char> s, Int32& i);
    private static void EatWhiteSpace(string s, Int32& i);
    private static void EatWhiteSpace(Char[] s, Int32& i);
    private static void EatWhiteSpace(ICharSequence s, Int32& i);
    [NullableContextAttribute("0")]
private static bool TryGrabLongs(int radix, ReadOnlySpan`1<char> s, Int32& i, int end, bool isUnsigned, Int64& result);
    private static bool TryGrabLongs(int radix, string s, Int32& i, int end, bool isUnsigned, Int64& result);
    private static bool TryGrabLongs(int radix, Char[] s, Int32& i, int end, bool isUnsigned, Int64& result);
    private static bool TryGrabLongs(int radix, ICharSequence s, Int32& i, int end, bool isUnsigned, Int64& result);
    [NullableContextAttribute("0")]
private static bool TryGrabInts(int radix, ReadOnlySpan`1<char> s, Int32& i, int end, bool isUnsigned, Int32& result);
    private static bool TryGrabInts(int radix, string s, Int32& i, int end, bool isUnsigned, Int32& result);
    private static bool TryGrabInts(int radix, Char[] s, Int32& i, int end, bool isUnsigned, Int32& result);
    private static bool TryGrabInts(int radix, ICharSequence s, Int32& i, int end, bool isUnsigned, Int32& result);
    private static bool IsLongOverflow(long value, int radix, int flags, int sign);
    private static bool IsIntOverflow(int value, int radix, int flags, int sign);
    private static TypeCode GetLongOverflowTypeCode(int flags);
    private static TypeCode GetIntOverflowTypeCode(int flags);
    [NullableContextAttribute("0")]
private static bool IsDigit(ReadOnlySpan`1<char> s, int i, int end, int radix, Int32& result, Int32& charCount);
    private static bool IsDigit(string s, int i, int end, int radix, Int32& result, Int32& charCount);
    private static bool IsDigit(Char[] s, int i, int end, int radix, Int32& result, Int32& charCount);
    private static bool IsDigit(ICharSequence s, int i, int end, int radix, Int32& result, Int32& charCount);
}
internal enum J2N.Numerics.RoundingMode : Enum {
    public int value__;
    public static RoundingMode Conservative;
    public static RoundingMode RoundEven;
}
[ExtensionAttribute]
internal static class J2N.Numerics.RoundingModeExtensions : object {
    [ExtensionAttribute]
public static bool AcceptUpperBound(RoundingMode roundingMode, bool even);
    [ExtensionAttribute]
public static bool AcceptLowerBound(RoundingMode roundingMode, bool even);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class J2N.Numerics.RyuDouble : object {
    private static int DOUBLE_MANTISSA_BITS;
    private static long DOUBLE_MANTISSA_MASK;
    private static int DOUBLE_EXPONENT_BITS;
    private static int DOUBLE_EXPONENT_MASK;
    private static int DOUBLE_EXPONENT_BIAS;
    private static int POS_TABLE_SIZE;
    private static int NEG_TABLE_SIZE;
    private static int POW5_BITCOUNT;
    private static Int32[][] POW5_SPLIT;
    private static int POW5_INV_BITCOUNT;
    private static Int32[][] POW5_INV_SPLIT;
    private static RyuDouble();
    public static string ToString(double value, NumberFormatInfo info);
    public static string ToString(double value, NumberFormatInfo info, bool upperCase);
    public static string ToString(double value, NumberFormatInfo info, RoundingMode roundingMode);
    public static string ToString(double value, NumberFormatInfo info, RoundingMode roundingMode, bool upperCase);
    private static void WriteBuffer(Char* result, Int32& index, long output, int olength, bool upperCase, bool sign, int exp, bool scientificNotation, string negSign, int negSignLength, string decimalSeparator, int decimalSeparatorLength);
    private static int Pow5bits(int e);
    private static int DecimalLength(long v);
    private static bool MultipleOfPowerOf5(long value, int q);
    private static int Pow5Factor(long value);
    private static long MulPow5divPow2(long m, int i, int j);
    private static long MulPow5InvDivPow2(long m, int i, int j);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class J2N.Numerics.RyuSingle : object {
    private static int FLOAT_MANTISSA_BITS;
    private static int FLOAT_MANTISSA_MASK;
    private static int FLOAT_EXPONENT_BITS;
    private static int FLOAT_EXPONENT_MASK;
    private static int FLOAT_EXPONENT_BIAS;
    private static long LOG10_2_DENOMINATOR;
    private static long LOG10_2_NUMERATOR;
    private static long LOG10_5_DENOMINATOR;
    private static long LOG10_5_NUMERATOR;
    private static long LOG2_5_DENOMINATOR;
    private static long LOG2_5_NUMERATOR;
    private static int POS_TABLE_SIZE;
    private static int INV_TABLE_SIZE;
    private static int POW5_BITCOUNT;
    private static int POW5_HALF_BITCOUNT;
    private static UInt64[] POW5_SPLIT;
    private static int POW5_INV_BITCOUNT;
    private static int POW5_INV_HALF_BITCOUNT;
    private static UInt64[] POW5_INV_SPLIT;
    private static RyuSingle();
    public static string ToString(float value, NumberFormatInfo info);
    public static string ToString(float value, NumberFormatInfo info, bool upperCase);
    public static string ToString(float value, NumberFormatInfo info, RoundingMode roundingMode);
    public static string ToString(float value, NumberFormatInfo info, RoundingMode roundingMode, bool upperCase);
    private static void WriteBuffer(Char* result, Int32& index, int output, int olength, bool upperCase, bool sign, int exp, bool scientificNotation, string negSign, int negSignLength, string decimalSeparator, int decimalSeparatorLength);
    private static int Pow5Bits(int e);
    private static int Pow5Factor(int value);
    private static ulong MulPow5divPow2(int m, int i, int j);
    private static ulong MulPow5InvDivPow2(int m, int q, int j);
    private static UInt32 MulShift(int m, ulong factor, int shift);
    private static int DecimalLength(int v);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[CLSCompliantAttribute("False")]
[DebuggerDisplayAttribute("{value}")]
public class J2N.Numerics.SByte : Number {
    private sbyte value;
    public static int Size;
    private static SByte[] Cache;
    internal SByte(sbyte value);
    private static SByte();
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(SByte value);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object value);
    public static SByte Decode(string s);
    public static bool TryDecode(string s, SByte& result);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(SByte obj);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("0")]
public static sbyte Parse(ReadOnlySpan`1<char> s, int startIndex, int length, int radix);
    public static sbyte Parse(string s, int startIndex, int length, int radix);
    public static sbyte Parse(Char[] s, int startIndex, int length, int radix);
    public static sbyte Parse(StringBuilder s, int startIndex, int length, int radix);
    public static sbyte Parse(ICharSequence s, int startIndex, int length, int radix);
    [NullableContextAttribute("0")]
public static bool TryParse(ReadOnlySpan`1<char> s, int startIndex, int length, int radix, SByte& result);
    public static bool TryParse(string s, int startIndex, int length, int radix, SByte& result);
    public static bool TryParse(Char[] s, int startIndex, int length, int radix, SByte& result);
    public static bool TryParse(StringBuilder s, int startIndex, int length, int radix, SByte& result);
    public static bool TryParse(ICharSequence s, int startIndex, int length, int radix, SByte& result);
    [NullableContextAttribute("2")]
public static sbyte Parse(string s, int radix);
    [NullableContextAttribute("2")]
public static bool TryParse(string s, int radix, SByte& result);
    public static sbyte Parse(string s, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string s, SByte& result);
    [NullableContextAttribute("0")]
public static bool TryParse(ReadOnlySpan`1<char> s, SByte& result);
    public static sbyte Parse(string s, NumberStyle style, IFormatProvider provider);
    [NullableContextAttribute("0")]
public static sbyte Parse(ReadOnlySpan`1<char> s, NumberStyle style, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string s, NumberStyle style, IFormatProvider provider, SByte& result);
    [NullableContextAttribute("0")]
public static bool TryParse(ReadOnlySpan`1<char> s, NumberStyle style, IFormatProvider provider, SByte& result);
    public virtual string ToString();
    public virtual string ToString(string format);
    public virtual string ToString(IFormatProvider provider);
    [NullableContextAttribute("2")]
public virtual string ToString(string format, IFormatProvider provider);
    public static string ToString(sbyte value);
    public static string ToString(sbyte value, string format);
    public static string ToString(sbyte value, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static string ToString(sbyte value, string format, IFormatProvider provider);
    public static SByte GetInstance(string s, IFormatProvider provider);
    public static SByte GetInstance(string s, NumberStyle style, IFormatProvider provider);
    public static SByte GetInstance(string s, int radix);
    public static SByte GetInstance(sbyte value);
    public static sbyte op_Implicit(SByte value);
    public static SByte op_Implicit(sbyte value);
    public virtual byte ToByte();
    public virtual double ToDouble();
    public virtual short ToInt16();
    public virtual int ToInt32();
    public virtual long ToInt64();
    [CLSCompliantAttribute("False")]
public virtual sbyte ToSByte();
    public virtual float ToSingle();
    public sealed virtual TypeCode GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{value}")]
public class J2N.Numerics.Single : Number {
    private float value;
    public static int MaxExponent;
    public static int MinExponent;
    public static float MinNormal;
    public static int Size;
    internal Single(float value);
    public sealed virtual int CompareTo(Single value);
    public sealed virtual int CompareTo(object value);
    public sealed virtual bool Equals(Single obj);
    public virtual bool Equals(object obj);
    internal static int SingleToInt32Bits(float value);
    internal static int SingleToRawInt32Bits(float value);
    public virtual int GetHashCode();
    internal static float Int32BitsToSingle(int value);
    public bool IsFinite();
    public bool IsInfinity();
    public bool IsNaN();
    public bool IsNegative();
    public bool IsNegativeInfinity();
    public bool IsNegativeZero();
    public bool IsNormal();
    public bool IsPositiveInfinity();
    public bool IsSubnormal();
    [NullableContextAttribute("1")]
public static float Parse(string s, IFormatProvider provider);
    public static bool TryParse(string s, Single& result);
    [NullableContextAttribute("0")]
public static bool TryParse(ReadOnlySpan`1<char> s, Single& result);
    [NullableContextAttribute("1")]
public static float Parse(string s, NumberStyle style, IFormatProvider provider);
    [NullableContextAttribute("0")]
public static float Parse(ReadOnlySpan`1<char> s, NumberStyle style, IFormatProvider provider);
    public static bool TryParse(string s, NumberStyle style, IFormatProvider provider, Single& result);
    [NullableContextAttribute("0")]
public static bool TryParse(ReadOnlySpan`1<char> s, NumberStyle style, IFormatProvider provider, Single& result);
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public virtual string ToString(string format);
    [NullableContextAttribute("1")]
public virtual string ToString(IFormatProvider provider);
    public virtual string ToString(string format, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static string ToString(float value);
    [NullableContextAttribute("1")]
public static string ToString(float value, string format);
    [NullableContextAttribute("1")]
public static string ToString(float value, IFormatProvider provider);
    public static string ToString(float value, string format, IFormatProvider provider);
    public static int Compare(float floatA, float floatB);
    [NullableContextAttribute("1")]
public static Single GetInstance(string s, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static Single GetInstance(string s, NumberStyle style, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static Single GetInstance(float value);
    [NullableContextAttribute("1")]
public string ToHexString(IFormatProvider provider);
    [NullableContextAttribute("1")]
public static float op_Implicit(Single value);
    [NullableContextAttribute("1")]
public static Single op_Implicit(float value);
    public virtual byte ToByte();
    public virtual double ToDouble();
    public virtual short ToInt16();
    public virtual int ToInt32();
    public virtual long ToInt64();
    [CLSCompliantAttribute("False")]
public virtual sbyte ToSByte();
    public virtual float ToSingle();
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("1")]
private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class J2N.PropertyExtensions : object {
    private static Char[] hexDigit;
    private static PropertyExtensions();
    [ExtensionAttribute]
public static bool GetPropertyAsBoolean(IDictionary`2<string, string> properties, string name);
    [ExtensionAttribute]
public static bool GetPropertyAsBoolean(IDictionary`2<string, string> properties, string name, bool defaultValue);
    [ExtensionAttribute]
public static int GetPropertyAsInt32(IDictionary`2<string, string> properties, string name);
    [ExtensionAttribute]
public static int GetPropertyAsInt32(IDictionary`2<string, string> properties, IFormatProvider provider, string name);
    [ExtensionAttribute]
public static int GetPropertyAsInt32(IDictionary`2<string, string> properties, string name, int defaultValue);
    [ExtensionAttribute]
public static int GetPropertyAsInt32(IDictionary`2<string, string> properties, IFormatProvider provider, string name, int defaultValue);
    private static T GetProperty(IDictionary`2<string, string> properties, string key, T defaultValue, Func`2<string, T> conversionFunction);
    [ExtensionAttribute]
public static string GetProperty(IDictionary`2<string, string> properties, string name);
    [ExtensionAttribute]
public static string GetProperty(IDictionary`2<string, string> properties, string name, string defaultValue);
    [ExtensionAttribute]
public static void LoadProperties(IDictionary`2<string, string> properties, Stream input);
    [ExtensionAttribute]
public static void LoadProperties(IDictionary`2<string, string> properties, TextReader reader);
    [ExtensionAttribute]
public static void SaveProperties(IDictionary`2<string, string> properties, Stream output);
    [ExtensionAttribute]
public static void SaveProperties(IDictionary`2<string, string> properties, Stream output, string comments);
    [ExtensionAttribute]
public static void SaveProperties(IDictionary`2<string, string> properties, TextWriter writer);
    [ExtensionAttribute]
public static void SaveProperties(IDictionary`2<string, string> properties, TextWriter writer, string comments);
    [ExtensionAttribute]
private static object GetSyncRoot(IDictionary`2<string, string> dictionary);
    private static void LoadProperties(IDictionary`2<string, string> properties, LineReader lr);
    private static string LoadConvert(Char[] input, int off, int len, Char[] convtBuf);
    private static string SaveConvert(string theString, bool escapeSpace, bool escapeUnicode);
    private static void WriteComments(TextWriter bw, string comments);
    private static void Store0(IDictionary`2<string, string> properties, TextWriter bw, string comments, bool escUnicode);
    private static char ToHex(int nibble);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class J2N.Randomizer : Random {
    private static long multiplier;
    private object syncRoot;
    internal long seed;
    internal bool haveNextNextGaussian;
    internal long internalSeed;
    internal double nextNextGaussian;
    public long Seed { get; public set; }
    public object SyncRoot { get; }
    public Randomizer(long seed);
    protected virtual int NextInt(int bits);
    public virtual bool NextBoolean();
    public virtual void NextBytes(Byte[] buffer);
    public virtual double NextDouble();
    public virtual float NextSingle();
    public virtual double NextGaussian();
    public virtual int Next();
    public virtual int Next(int maxValue);
    public virtual int Next(int minValue, int maxValue);
    public virtual long NextInt64();
    public long get_Seed();
    public void set_Seed(long value);
    public object get_SyncRoot();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "16.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class J2N.Resources.Strings : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string Arg_ArrayLengthsDiffer { get; }
    internal static string Arg_ArrayPlusOffTooSmall { get; }
    internal static string Arg_BitArrayTypeUnsupported { get; }
    internal static string Arg_BogusIComparer { get; }
    internal static string Arg_ExponentRequiredIfTypeSpecifierUsed { get; }
    internal static string Arg_HSCapacityOverflow { get; }
    internal static string Arg_HTCapacityOverflow { get; }
    internal static string Arg_InsufficientSpace { get; }
    internal static string Arg_InvalidANSIString { get; }
    internal static string Arg_InvalidHexFloatStyle { get; }
    internal static string Arg_InvalidHexStyle { get; }
    internal static string Arg_KeyNotFoundWithKey { get; }
    internal static string Arg_MustBeByte { get; }
    internal static string Arg_MustBeDouble { get; }
    internal static string Arg_MustBeInt16 { get; }
    internal static string Arg_MustBeInt32 { get; }
    internal static string Arg_MustBeInt64 { get; }
    internal static string Arg_MustBeSByte { get; }
    internal static string Arg_MustBeSingle { get; }
    internal static string Arg_Need1DArray { get; }
    internal static string Arg_NonZeroLowerBound { get; }
    internal static string Arg_RankMultiDimNotSupported { get; }
    internal static string Arg_TypeSpecifierNotAllowedIfCurrencyUsed { get; }
    internal static string Arg_WrongType { get; }
    internal static string Argument_AddingDuplicate { get; }
    internal static string Argument_ArrayTooLarge { get; }
    internal static string Argument_BadFormatSpecifier { get; }
    internal static string Argument_CollectionMustNotBeThis { get; }
    internal static string Argument_InvalidArgumentForComparison { get; }
    internal static string Argument_InvalidArrayType { get; }
    internal static string Argument_InvalidCodePoint { get; }
    internal static string Argument_InvalidNumberStyle { get; }
    internal static string Argument_InvalidOffLen { get; }
    internal static string Argument_MinMaxValue { get; }
    internal static string Argument_MustBePrimitiveType { get; }
    internal static string Argument_MustNotBeThis { get; }
    internal static string Argument_TypeOfKeyIncorrect { get; }
    internal static string Argument_TypeOfValueIncorrect { get; }
    internal static string ArgumentNull_CollectionDoesntSupportNull { get; }
    internal static string ArgumentOutOfRange_BiggerThanCollection { get; }
    internal static string ArgumentOutOfRange_Count { get; }
    internal static string ArgumentOutOfRange_Index { get; }
    internal static string ArgumentOutOfRange_IndexLength { get; }
    internal static string ArgumentOutOfRange_ListInsert { get; }
    internal static string ArgumentOutOfRange_NeedCapacityAtLeast1 { get; }
    internal static string ArgumentOutOfRange_NeedLimitAtLeast1 { get; }
    internal static string ArgumentOutOfRange_NeedNonNegNum { get; }
    internal static string ArgumentOutOfRange_Radix { get; }
    internal static string ArgumentOutOfRange_SmallCapacity { get; }
    internal static string ConcurrentCollection_SyncRoot_NotSupported { get; }
    internal static string ExternalLinkedListNode { get; }
    internal static string Format_EmptyInputString { get; }
    internal static string Format_ExtraJunkAtEnd { get; }
    internal static string Format_InvalidString { get; }
    internal static string Format_InvalidUTFSpec2ndByte { get; }
    internal static string Format_InvalidUTFSpec2ndOr3rdByte { get; }
    internal static string Format_InvalidUTFSpec3rdByte { get; }
    internal static string Format_InvalidUTFSpecInput { get; }
    internal static string Format_InvalidUTFTooLong { get; }
    internal static string Format_NoParsibleDigits { get; }
    internal static string InvalidCast_DBNull { get; }
    internal static string InvalidCast_Empty { get; }
    internal static string InvalidCast_FromTo { get; }
    internal static string InvalidOperation_CannotEditNullObject { get; }
    internal static string InvalidOperation_CannotIndexNullObject { get; }
    internal static string InvalidOperation_CollectionCorrupted { get; }
    internal static string InvalidOperation_ComparerRequired { get; }
    internal static string InvalidOperation_ConcurrentOperationsNotSupported { get; }
    internal static string InvalidOperation_EmptyQueue { get; }
    internal static string InvalidOperation_EmptyStack { get; }
    internal static string InvalidOperation_EnumEnded { get; }
    internal static string InvalidOperation_EnumFailedVersion { get; }
    internal static string InvalidOperation_EnumNotStarted { get; }
    internal static string InvalidOperation_EnumOpCantHappen { get; }
    internal static string InvalidOperation_IComparerFailed { get; }
    internal static string InvalidOperation_ViewFailedVersion { get; }
    internal static string LinkedListEmpty { get; }
    internal static string LinkedListNodeIsAttached { get; }
    internal static string LurchTable_CorruptedData { get; }
    internal static string LurchTable_NeedLimitIntMaxValue { get; }
    internal static string NotSupported_KeyCollectionSet { get; }
    internal static string NotSupported_ReadOnlyCollection { get; }
    internal static string NotSupported_SortedListNestedWrite { get; }
    internal static string NotSupported_ValueCollectionSet { get; }
    internal static string Overflow_Byte { get; }
    internal static string Overflow_Decimal { get; }
    internal static string Overflow_Int16 { get; }
    internal static string Overflow_Int32 { get; }
    internal static string Overflow_Int64 { get; }
    internal static string Overflow_NegativeUnsigned { get; }
    internal static string Overflow_SByte { get; }
    internal static string Overflow_UInt16 { get; }
    internal static string Overflow_UInt32 { get; }
    internal static string Overflow_UInt64 { get; }
    internal static string Serialization_InvalidOnDeser { get; }
    internal static string Serialization_MismatchedCount { get; }
    internal static string Serialization_MissingKeys { get; }
    internal static string Serialization_MissingValues { get; }
    internal static string SortedSet_LowerValueGreaterThanUpperValue { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_Arg_ArrayLengthsDiffer();
    internal static string get_Arg_ArrayPlusOffTooSmall();
    internal static string get_Arg_BitArrayTypeUnsupported();
    internal static string get_Arg_BogusIComparer();
    internal static string get_Arg_ExponentRequiredIfTypeSpecifierUsed();
    internal static string get_Arg_HSCapacityOverflow();
    internal static string get_Arg_HTCapacityOverflow();
    internal static string get_Arg_InsufficientSpace();
    internal static string get_Arg_InvalidANSIString();
    internal static string get_Arg_InvalidHexFloatStyle();
    internal static string get_Arg_InvalidHexStyle();
    internal static string get_Arg_KeyNotFoundWithKey();
    internal static string get_Arg_MustBeByte();
    internal static string get_Arg_MustBeDouble();
    internal static string get_Arg_MustBeInt16();
    internal static string get_Arg_MustBeInt32();
    internal static string get_Arg_MustBeInt64();
    internal static string get_Arg_MustBeSByte();
    internal static string get_Arg_MustBeSingle();
    internal static string get_Arg_Need1DArray();
    internal static string get_Arg_NonZeroLowerBound();
    internal static string get_Arg_RankMultiDimNotSupported();
    internal static string get_Arg_TypeSpecifierNotAllowedIfCurrencyUsed();
    internal static string get_Arg_WrongType();
    internal static string get_Argument_AddingDuplicate();
    internal static string get_Argument_ArrayTooLarge();
    internal static string get_Argument_BadFormatSpecifier();
    internal static string get_Argument_CollectionMustNotBeThis();
    internal static string get_Argument_InvalidArgumentForComparison();
    internal static string get_Argument_InvalidArrayType();
    internal static string get_Argument_InvalidCodePoint();
    internal static string get_Argument_InvalidNumberStyle();
    internal static string get_Argument_InvalidOffLen();
    internal static string get_Argument_MinMaxValue();
    internal static string get_Argument_MustBePrimitiveType();
    internal static string get_Argument_MustNotBeThis();
    internal static string get_Argument_TypeOfKeyIncorrect();
    internal static string get_Argument_TypeOfValueIncorrect();
    internal static string get_ArgumentNull_CollectionDoesntSupportNull();
    internal static string get_ArgumentOutOfRange_BiggerThanCollection();
    internal static string get_ArgumentOutOfRange_Count();
    internal static string get_ArgumentOutOfRange_Index();
    internal static string get_ArgumentOutOfRange_IndexLength();
    internal static string get_ArgumentOutOfRange_ListInsert();
    internal static string get_ArgumentOutOfRange_NeedCapacityAtLeast1();
    internal static string get_ArgumentOutOfRange_NeedLimitAtLeast1();
    internal static string get_ArgumentOutOfRange_NeedNonNegNum();
    internal static string get_ArgumentOutOfRange_Radix();
    internal static string get_ArgumentOutOfRange_SmallCapacity();
    internal static string get_ConcurrentCollection_SyncRoot_NotSupported();
    internal static string get_ExternalLinkedListNode();
    internal static string get_Format_EmptyInputString();
    internal static string get_Format_ExtraJunkAtEnd();
    internal static string get_Format_InvalidString();
    internal static string get_Format_InvalidUTFSpec2ndByte();
    internal static string get_Format_InvalidUTFSpec2ndOr3rdByte();
    internal static string get_Format_InvalidUTFSpec3rdByte();
    internal static string get_Format_InvalidUTFSpecInput();
    internal static string get_Format_InvalidUTFTooLong();
    internal static string get_Format_NoParsibleDigits();
    internal static string get_InvalidCast_DBNull();
    internal static string get_InvalidCast_Empty();
    internal static string get_InvalidCast_FromTo();
    internal static string get_InvalidOperation_CannotEditNullObject();
    internal static string get_InvalidOperation_CannotIndexNullObject();
    internal static string get_InvalidOperation_CollectionCorrupted();
    internal static string get_InvalidOperation_ComparerRequired();
    internal static string get_InvalidOperation_ConcurrentOperationsNotSupported();
    internal static string get_InvalidOperation_EmptyQueue();
    internal static string get_InvalidOperation_EmptyStack();
    internal static string get_InvalidOperation_EnumEnded();
    internal static string get_InvalidOperation_EnumFailedVersion();
    internal static string get_InvalidOperation_EnumNotStarted();
    internal static string get_InvalidOperation_EnumOpCantHappen();
    internal static string get_InvalidOperation_IComparerFailed();
    internal static string get_InvalidOperation_ViewFailedVersion();
    internal static string get_LinkedListEmpty();
    internal static string get_LinkedListNodeIsAttached();
    internal static string get_LurchTable_CorruptedData();
    internal static string get_LurchTable_NeedLimitIntMaxValue();
    internal static string get_NotSupported_KeyCollectionSet();
    internal static string get_NotSupported_ReadOnlyCollection();
    internal static string get_NotSupported_SortedListNestedWrite();
    internal static string get_NotSupported_ValueCollectionSet();
    internal static string get_Overflow_Byte();
    internal static string get_Overflow_Decimal();
    internal static string get_Overflow_Int16();
    internal static string get_Overflow_Int32();
    internal static string get_Overflow_Int64();
    internal static string get_Overflow_NegativeUnsigned();
    internal static string get_Overflow_SByte();
    internal static string get_Overflow_UInt16();
    internal static string get_Overflow_UInt32();
    internal static string get_Overflow_UInt64();
    internal static string get_Serialization_InvalidOnDeser();
    internal static string get_Serialization_MismatchedCount();
    internal static string get_Serialization_MissingKeys();
    internal static string get_Serialization_MissingValues();
    internal static string get_SortedSet_LowerValueGreaterThanUpperValue();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class J2N.Runtime.CompilerServices.IdentityEqualityComparer`1 : object {
    [CompilerGeneratedAttribute]
private static IdentityEqualityComparer`1<T> <Default>k__BackingField;
    public static IdentityEqualityComparer`1<T> Default { get; }
    private static IdentityEqualityComparer`1();
    [CompilerGeneratedAttribute]
public static IdentityEqualityComparer`1<T> get_Default();
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(T left, T right);
    public sealed virtual int GetHashCode(T value);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(object left, object right);
    public sealed virtual int GetHashCode(object value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class J2N.SingleExtensions : object {
    [ExtensionAttribute]
public static bool IsFinite(float f);
    [ExtensionAttribute]
public static bool IsInfinity(float f);
    [ExtensionAttribute]
public static bool IsNaN(float f);
    [ExtensionAttribute]
public static bool IsNegative(float f);
    [ExtensionAttribute]
public static bool IsNegativeInfinity(float f);
    [ExtensionAttribute]
public static bool IsNegativeZero(float f);
    [ExtensionAttribute]
public static bool IsNormal(float f);
    [ExtensionAttribute]
public static bool IsPositiveInfinity(float f);
    [ExtensionAttribute]
public static bool IsSubnormal(float f);
    [ExtensionAttribute]
public static string ToHexString(float value, IFormatProvider provider);
    [ExtensionAttribute]
internal static string ToHexString(float value, NumberFormatInfo info, bool upperCase);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class J2N.SR : object {
    private static bool UsingResourceKeys();
    [NullableContextAttribute("2")]
internal static string GetResourceString(string resourceKey, string defaultString);
    internal static string Format(string resourceFormat, object p1);
    internal static string Format(string resourceFormat, object p1, object p2);
    [NullableContextAttribute("2")]
internal static string Format(string resourceFormat, object p1, object p2, object p3);
    internal static string Format(string resourceFormat, Object[] args);
    internal static string Format(IFormatProvider provider, string resourceFormat, object p1);
    internal static string Format(IFormatProvider provider, string resourceFormat, object p1, object p2);
    internal static string Format(IFormatProvider provider, string resourceFormat, object p1, object p2, object p3);
    internal static string Format(IFormatProvider provider, string resourceFormat, Object[] args);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class J2N.Text.CharArrayCharSequence : object {
    [CompilerGeneratedAttribute]
private Char[] <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasValue>k__BackingField;
    public Char[] Value { get; }
    public bool HasValue { get; }
    public char Item { get; }
    public int Length { get; }
    public CharArrayCharSequence(Char[] value);
    [CompilerGeneratedAttribute]
public Char[] get_Value();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_HasValue();
    public sealed virtual char get_Item(int index);
    public sealed virtual int get_Length();
    [NullableContextAttribute("1")]
public sealed virtual ICharSequence Subsequence(int startIndex, int length);
    [NullableContextAttribute("1")]
public virtual string ToString();
    public static bool op_Equality(CharArrayCharSequence csq1, CharArrayCharSequence csq2);
    public static bool op_Inequality(CharArrayCharSequence csq1, CharArrayCharSequence csq2);
    public static bool op_Equality(CharArrayCharSequence csq1, Char[] csq2);
    public static bool op_Inequality(CharArrayCharSequence csq1, Char[] csq2);
    public static bool op_Equality(Char[] csq1, CharArrayCharSequence csq2);
    public static bool op_Inequality(Char[] csq1, CharArrayCharSequence csq2);
    public sealed virtual bool Equals(ICharSequence other);
    public sealed virtual bool Equals(CharArrayCharSequence other);
    public sealed virtual bool Equals(StringBuilderCharSequence other);
    public sealed virtual bool Equals(StringCharSequence other);
    public sealed virtual bool Equals(string other);
    public sealed virtual bool Equals(StringBuilder other);
    public sealed virtual bool Equals(Char[] other);
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    public sealed virtual int CompareTo(ICharSequence other);
    public sealed virtual int CompareTo(string other);
    public sealed virtual int CompareTo(StringBuilder other);
    public sealed virtual int CompareTo(Char[] other);
    public sealed virtual int CompareTo(object other);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class J2N.Text.CharArrayExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static ICharSequence AsCharSequence(Char[] text);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static ICharSequence Subsequence(Char[] text, int startIndex, int length);
    [ExtensionAttribute]
public static int CompareToOrdinal(Char[] str, Char[] value);
    [ExtensionAttribute]
public static int CompareToOrdinal(Char[] str, StringBuilder value);
    [ExtensionAttribute]
public static int CompareToOrdinal(Char[] str, string value);
    [ExtensionAttribute]
public static int CompareToOrdinal(Char[] str, ICharSequence value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public abstract class J2N.Text.CharSequenceComparer : object {
    [NullableAttribute("1")]
private static CharSequenceComparer ordinal;
    [NullableAttribute("1")]
public static CharSequenceComparer Ordinal { get; }
    private static CharSequenceComparer();
    [NullableContextAttribute("1")]
public static CharSequenceComparer get_Ordinal();
    public virtual int Compare(object x, object y);
    public abstract virtual int Compare(ICharSequence x, ICharSequence y);
    public abstract virtual int Compare(ICharSequence x, Char[] y);
    public abstract virtual int Compare(ICharSequence x, StringBuilder y);
    public abstract virtual int Compare(ICharSequence x, string y);
    public virtual int Compare(ICharSequence x, CharArrayCharSequence y);
    public virtual int Compare(ICharSequence x, StringBuilderCharSequence y);
    public virtual int Compare(ICharSequence x, StringCharSequence y);
    public virtual bool Equals(object x, object y);
    public abstract virtual bool Equals(ICharSequence x, ICharSequence y);
    public abstract virtual bool Equals(ICharSequence x, Char[] y);
    public abstract virtual bool Equals(ICharSequence x, StringBuilder y);
    public abstract virtual bool Equals(ICharSequence x, string y);
    public virtual int GetHashCode(object obj);
    public abstract virtual int GetHashCode(ICharSequence obj);
    public abstract virtual int GetHashCode(Char[] obj);
    public abstract virtual int GetHashCode(StringBuilder obj);
    public abstract virtual int GetHashCode(string obj);
}
[NullableContextAttribute("1")]
public interface J2N.Text.IAppendable {
    public abstract virtual IAppendable Append(char value);
    public abstract virtual IAppendable Append(string value);
    public abstract virtual IAppendable Append(string value, int startIndex, int count);
    public abstract virtual IAppendable Append(StringBuilder value);
    public abstract virtual IAppendable Append(StringBuilder value, int startIndex, int count);
    public abstract virtual IAppendable Append(Char[] value);
    public abstract virtual IAppendable Append(Char[] value, int startIndex, int count);
    public abstract virtual IAppendable Append(ICharSequence value);
    public abstract virtual IAppendable Append(ICharSequence value, int startIndex, int count);
}
internal interface J2N.Text.ICharacterEnumerator {
    public int StartIndex { get; }
    public int EndIndex { get; }
    public int Length { get; }
    public int Index { get; public set; }
    [NullableContextAttribute("1")]
public abstract virtual object Clone();
    public abstract virtual bool MovePrevious();
    public abstract virtual bool MoveFirst();
    public abstract virtual bool MoveLast();
    public abstract virtual int get_StartIndex();
    public abstract virtual int get_EndIndex();
    public abstract virtual int get_Length();
    public abstract virtual int get_Index();
    public abstract virtual void set_Index(int value);
    public abstract virtual bool TrySetIndex(int value);
}
[NullableContextAttribute("1")]
[DefaultMemberAttribute("Item")]
public interface J2N.Text.ICharSequence {
    public bool HasValue { get; }
    public int Length { get; }
    public char Item { get; }
    public abstract virtual bool get_HasValue();
    public abstract virtual int get_Length();
    public abstract virtual char get_Item(int index);
    public abstract virtual ICharSequence Subsequence(int startIndex, int length);
    public abstract virtual string ToString();
}
internal interface J2N.Text.IStructuralFormattable {
    [NullableContextAttribute("2")]
public abstract virtual string ToString(string format, IFormatProvider formatProvider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class J2N.Text.ParseException : Exception {
    private static string ErrorOffsetName;
    private int errorOffset;
    public int ErrorOffset { get; }
    public ParseException(string message, int errorOffset);
    public ParseException(string message, int errorOffset, Exception innerException);
    internal ParseException(string message);
    internal ParseException(string message, Exception innerException);
    private ParseException(SerializationInfo info, StreamingContext context);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public int get_ErrorOffset();
}
public class J2N.Text.ParsePosition : object {
    [CompilerGeneratedAttribute]
private int <ErrorIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    public int ErrorIndex { get; public set; }
    public int Index { get; public set; }
    public ParsePosition(int index);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public int get_ErrorIndex();
    [CompilerGeneratedAttribute]
public void set_ErrorIndex(int value);
    [CompilerGeneratedAttribute]
public int get_Index();
    [CompilerGeneratedAttribute]
public void set_Index(int value);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
}
[ExtensionAttribute]
public static class J2N.Text.StringArrayExtensions : object {
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static String[] TrimEnd(String[] input);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class J2N.Text.StringBuffer : object {
    private static int DefaultCapacity;
    internal StringBuilder builder;
    private object syncRoot;
    public object SyncRoot { get; }
    public int Length { get; public set; }
    public int MaxCapacity { get; }
    public int Capacity { get; public set; }
    public char Item { get; public set; }
    private char J2N.Text.ICharSequence.Item { get; }
    private bool J2N.Text.ICharSequence.HasValue { get; }
    private int J2N.Text.ICharSequence.Length { get; }
    public StringBuffer(int capacity);
    [NullableContextAttribute("2")]
public StringBuffer(string value);
    [NullableContextAttribute("2")]
public StringBuffer(ICharSequence value);
    [NullableContextAttribute("2")]
public StringBuffer(ICharSequence value, int capacity);
    [NullableContextAttribute("2")]
public StringBuffer(ICharSequence value, int startIndex, int length, int capacity);
    [NullableContextAttribute("2")]
public StringBuffer(StringBuilder value);
    [NullableContextAttribute("2")]
public StringBuffer(StringBuilder value, int capacity);
    [NullableContextAttribute("2")]
public StringBuffer(StringBuilder value, int startIndex, int length, int capacity);
    [NullableContextAttribute("2")]
public StringBuffer(Char[] value);
    [NullableContextAttribute("2")]
public StringBuffer(Char[] value, int capacity);
    [NullableContextAttribute("2")]
public StringBuffer(Char[] value, int startIndex, int length, int capacity);
    public StringBuffer(int capacity, int maxCapacity);
    [NullableContextAttribute("2")]
public StringBuffer(string value, int capacity);
    [NullableContextAttribute("2")]
public StringBuffer(string value, int startIndex, int length, int capacity);
    public object get_SyncRoot();
    public int get_Length();
    public void set_Length(int value);
    public int get_MaxCapacity();
    public int get_Capacity();
    public void set_Capacity(int value);
    public char get_Item(int index);
    public void set_Item(int index, char value);
    public int CodePointAt(int index);
    public int CodePointBefore(int index);
    public int CodePointCount(int startIndex, int length);
    public int OffsetByCodePoints(int index, int codePointOffset);
    [NullableContextAttribute("0")]
public StringBuffer Append(ReadOnlySpan`1<char> value);
    [NullableContextAttribute("0")]
public StringBuffer Append(ReadOnlyMemory`1<char> value);
    public StringBuffer Append(object value);
    public StringBuffer Append(string value);
    public StringBuffer Append(string value, int startIndex, int count);
    public StringBuffer Append(StringBuffer value);
    public StringBuffer Append(StringBuffer charSequence, int startIndex, int charCount);
    public StringBuffer Append(StringBuilder value);
    public StringBuffer Append(StringBuilder charSequence, int startIndex, int charCount);
    public StringBuffer Append(ICharSequence charSequence);
    public StringBuffer Append(ICharSequence charSequence, int startIndex, int charCount);
    public StringBuffer Append(Char[] value);
    public StringBuffer Append(Char[] value, int startIndex, int charCount);
    [NullableContextAttribute("0")]
[CLSCompliantAttribute("False")]
[SecurityCriticalAttribute]
public StringBuffer Append(Char* value, int valueCount);
    public StringBuffer Append(bool value);
    public StringBuffer Append(char value);
    public StringBuffer Append(char value, int repeatCount);
    public StringBuffer Append(int value);
    public StringBuffer Append(long value);
    public StringBuffer Append(float value);
    public StringBuffer Append(double value);
    public StringBuffer Append(decimal value);
    public StringBuffer Append(byte value);
    [CLSCompliantAttribute("False")]
public StringBuffer Append(sbyte value);
    public StringBuffer Append(short value);
    [CLSCompliantAttribute("False")]
public StringBuffer Append(UInt32 value);
    [CLSCompliantAttribute("False")]
public StringBuffer Append(ulong value);
    [CLSCompliantAttribute("False")]
public StringBuffer Append(ushort value);
    public StringBuffer AppendCodePoint(int codePoint);
    public StringBuffer AppendFormat(string format, object arg0);
    public StringBuffer AppendFormat(IFormatProvider provider, string format, object arg0);
    public StringBuffer AppendFormat(string format, object arg0, object arg1);
    [NullableContextAttribute("2")]
public StringBuffer AppendFormat(IFormatProvider provider, string format, object arg0, object arg1);
    [NullableContextAttribute("2")]
public StringBuffer AppendFormat(string format, object arg0, object arg1, object arg2);
    [NullableContextAttribute("2")]
public StringBuffer AppendFormat(IFormatProvider provider, string format, object arg0, object arg1, object arg2);
    public StringBuffer AppendFormat(string format, Object[] args);
    public StringBuffer AppendFormat(IFormatProvider provider, string format, Object[] args);
    public StringBuffer AppendJoin(char separator, Object[] values);
    public StringBuffer AppendJoin(char separator, String[] values);
    public StringBuffer AppendJoin(string separator, Object[] values);
    public StringBuffer AppendJoin(string separator, String[] values);
    public StringBuffer AppendJoin(char separator, IEnumerable`1<T> values);
    public StringBuffer AppendJoin(string separator, IEnumerable`1<T> values);
    public StringBuffer AppendLine();
    public StringBuffer AppendLine(string value);
    public StringBuffer Clear();
    public void CopyTo(int sourceIndex, Char[] destination, int destinationIndex, int count);
    public StringBuffer Delete(int startIndex, int count);
    public int EnsureCapacity(int capacity);
    [NullableContextAttribute("0")]
public bool Equals(ReadOnlySpan`1<char> span);
    [NullableContextAttribute("2")]
public bool Equals(StringBuilderCharSequence other);
    [NullableContextAttribute("2")]
public bool Equals(StringBuilder other);
    [NullableContextAttribute("2")]
public bool Equals(StringBuffer other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("0")]
public StringBuffer Insert(int index, ReadOnlySpan`1<char> value);
    public StringBuffer Insert(int index, bool value);
    public StringBuffer Insert(int index, byte value);
    public StringBuffer Insert(int index, char value);
    public StringBuffer Insert(int index, Char[] value);
    public StringBuffer Insert(int index, Char[] value, int startIndex, int charCount);
    public StringBuffer Insert(int index, ICharSequence charSequence);
    public StringBuffer Insert(int index, ICharSequence charSequence, int startIndex, int charCount);
    public StringBuffer Insert(int index, StringBuilder charSequence);
    public StringBuffer Insert(int index, StringBuilder charSequence, int startIndex, int charCount);
    public StringBuffer Insert(int index, string value);
    public StringBuffer Insert(int index, string value, int startIndex, int charCount);
    public StringBuffer Insert(int index, string value, int count);
    public StringBuffer Insert(int index, object value);
    public StringBuffer Insert(int index, int value);
    public StringBuffer Insert(int index, long value);
    public StringBuffer Insert(int index, short value);
    public StringBuffer Insert(int index, float value);
    public StringBuffer Insert(int index, double value);
    public StringBuffer Insert(int index, decimal value);
    [CLSCompliantAttribute("False")]
public StringBuffer Insert(int index, sbyte value);
    [CLSCompliantAttribute("False")]
public StringBuffer Insert(int index, ushort value);
    [CLSCompliantAttribute("False")]
public StringBuffer Insert(int index, UInt32 value);
    [CLSCompliantAttribute("False")]
public StringBuffer Insert(int index, ulong value);
    public int IndexOf(string value, StringComparison comparisonType);
    public int IndexOf(string value, int startIndex, StringComparison comparisonType);
    public int LastIndexOf(string value, StringComparison comparisonType);
    public int LastIndexOf(string value, int startIndex, StringComparison comparisonType);
    public StringBuffer Remove(int startIndex, int length);
    public StringBuffer Replace(int startIndex, int count, string newValue);
    public StringBuffer Replace(char oldChar, char newChar);
    public StringBuffer Replace(char oldChar, char newChar, int startIndex, int count);
    public StringBuffer Replace(string oldValue, string newValue);
    public StringBuffer Replace(string oldValue, string newValue, int startIndex, int count);
    public StringBuffer Reverse();
    public ICharSequence Subsequence(int startIndex, int length);
    public virtual string ToString();
    public string ToString(int startIndex, int length);
    private sealed virtual override IAppendable J2N.Text.IAppendable.Append(char value);
    private sealed virtual override IAppendable J2N.Text.IAppendable.Append(string value);
    private sealed virtual override IAppendable J2N.Text.IAppendable.Append(string value, int startIndex, int count);
    private sealed virtual override IAppendable J2N.Text.IAppendable.Append(StringBuilder value);
    private sealed virtual override IAppendable J2N.Text.IAppendable.Append(StringBuilder value, int startIndex, int count);
    private sealed virtual override IAppendable J2N.Text.IAppendable.Append(Char[] value);
    private sealed virtual override IAppendable J2N.Text.IAppendable.Append(Char[] value, int startIndex, int count);
    private sealed virtual override IAppendable J2N.Text.IAppendable.Append(ICharSequence value);
    private sealed virtual override IAppendable J2N.Text.IAppendable.Append(ICharSequence value, int startIndex, int count);
    private sealed virtual override char J2N.Text.ICharSequence.get_Item(int index);
    private sealed virtual override bool J2N.Text.ICharSequence.get_HasValue();
    private sealed virtual override int J2N.Text.ICharSequence.get_Length();
    private sealed virtual override ICharSequence J2N.Text.ICharSequence.Subsequence(int startIndex, int length);
    private sealed virtual override string J2N.Text.ICharSequence.ToString();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class J2N.Text.StringBuilderCharSequence : object {
    [CompilerGeneratedAttribute]
private StringBuilder <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasValue>k__BackingField;
    public StringBuilder Value { get; }
    public bool HasValue { get; }
    public char Item { get; }
    public int Length { get; }
    public StringBuilderCharSequence(StringBuilder value);
    [CompilerGeneratedAttribute]
public StringBuilder get_Value();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_HasValue();
    public sealed virtual char get_Item(int index);
    public sealed virtual int get_Length();
    [NullableContextAttribute("1")]
public sealed virtual ICharSequence Subsequence(int startIndex, int length);
    [NullableContextAttribute("1")]
public virtual string ToString();
    public static bool op_Equality(StringBuilderCharSequence csq1, StringBuilderCharSequence csq2);
    public static bool op_Inequality(StringBuilderCharSequence csq1, StringBuilderCharSequence csq2);
    public static bool op_Equality(StringBuilderCharSequence csq1, StringBuilder csq2);
    public static bool op_Inequality(StringBuilderCharSequence csq1, StringBuilder csq2);
    public static bool op_Equality(StringBuilder csq1, StringBuilderCharSequence csq2);
    public static bool op_Inequality(StringBuilder csq1, StringBuilderCharSequence csq2);
    public sealed virtual bool Equals(ICharSequence other);
    public sealed virtual bool Equals(CharArrayCharSequence other);
    public sealed virtual bool Equals(StringBuilderCharSequence other);
    public sealed virtual bool Equals(StringCharSequence other);
    public sealed virtual bool Equals(string other);
    public sealed virtual bool Equals(StringBuilder other);
    public sealed virtual bool Equals(Char[] other);
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    public sealed virtual int CompareTo(ICharSequence other);
    public sealed virtual int CompareTo(string other);
    public sealed virtual int CompareTo(StringBuilder other);
    public sealed virtual int CompareTo(Char[] other);
    public sealed virtual int CompareTo(object other);
    [NullableContextAttribute("1")]
public StringBuilderCharSequence Append(char value);
    [NullableContextAttribute("1")]
public StringBuilderCharSequence Append(string value);
    [NullableContextAttribute("1")]
public StringBuilderCharSequence Append(string value, int startIndex, int count);
    [NullableContextAttribute("1")]
public StringBuilderCharSequence Append(StringBuilder value);
    [NullableContextAttribute("1")]
public StringBuilderCharSequence Append(StringBuilder value, int startIndex, int count);
    [NullableContextAttribute("1")]
public StringBuilderCharSequence Append(Char[] value);
    [NullableContextAttribute("1")]
public StringBuilderCharSequence Append(Char[] value, int startIndex, int count);
    [NullableContextAttribute("1")]
public StringBuilderCharSequence Append(ICharSequence value);
    [NullableContextAttribute("1")]
public StringBuilderCharSequence Append(ICharSequence value, int startIndex, int count);
    [NullableContextAttribute("1")]
private sealed virtual override IAppendable J2N.Text.IAppendable.Append(char value);
    [NullableContextAttribute("1")]
private sealed virtual override IAppendable J2N.Text.IAppendable.Append(string value);
    [NullableContextAttribute("1")]
private sealed virtual override IAppendable J2N.Text.IAppendable.Append(string value, int startIndex, int count);
    [NullableContextAttribute("1")]
private sealed virtual override IAppendable J2N.Text.IAppendable.Append(StringBuilder value);
    [NullableContextAttribute("1")]
private sealed virtual override IAppendable J2N.Text.IAppendable.Append(StringBuilder value, int startIndex, int count);
    [NullableContextAttribute("1")]
private sealed virtual override IAppendable J2N.Text.IAppendable.Append(Char[] value);
    [NullableContextAttribute("1")]
private sealed virtual override IAppendable J2N.Text.IAppendable.Append(Char[] value, int startIndex, int count);
    [NullableContextAttribute("1")]
private sealed virtual override IAppendable J2N.Text.IAppendable.Append(ICharSequence value);
    [NullableContextAttribute("1")]
private sealed virtual override IAppendable J2N.Text.IAppendable.Append(ICharSequence value, int startIndex, int count);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class J2N.Text.StringBuilderExtensions : object {
    [ExtensionAttribute]
public static StringBuilder Append(StringBuilder text, ICharSequence charSequence);
    [ExtensionAttribute]
public static StringBuilder Append(StringBuilder text, ICharSequence charSequence, int startIndex, int charCount);
    [ExtensionAttribute]
public static StringBuilder Append(StringBuilder text, StringBuilder charSequence, int startIndex, int charCount);
    [ExtensionAttribute]
public static StringBuilder AppendCodePoint(StringBuilder text, int codePoint);
    [ExtensionAttribute]
public static ICharSequence AsCharSequence(StringBuilder text);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static int CompareToOrdinal(StringBuilder text, ICharSequence value);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static int CompareToOrdinal(StringBuilder text, Char[] value);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static int CompareToOrdinal(StringBuilder text, StringBuilder value);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static int CompareToOrdinal(StringBuilder text, string value);
    [ExtensionAttribute]
public static StringBuilder Delete(StringBuilder text, int startIndex, int count);
    [ExtensionAttribute]
public static int IndexOf(StringBuilder text, string value, StringComparison comparisonType);
    [ExtensionAttribute]
public static int IndexOf(StringBuilder text, string value, int startIndex, StringComparison comparisonType);
    private static int IndexOfOrdinal(StringBuilder text, string value, int startIndex);
    private static int IndexOfOrdinalIgnoreCase(StringBuilder text, string value, int startIndex);
    [ExtensionAttribute]
public static StringBuilder Insert(StringBuilder text, int index, ICharSequence charSequence);
    [ExtensionAttribute]
public static StringBuilder Insert(StringBuilder text, int index, ICharSequence charSequence, int startIndex, int charCount);
    [ExtensionAttribute]
public static StringBuilder Insert(StringBuilder text, int index, StringBuilder charSequence);
    [ExtensionAttribute]
public static StringBuilder Insert(StringBuilder text, int index, StringBuilder charSequence, int startIndex, int charCount);
    [ExtensionAttribute]
public static StringBuilder Insert(StringBuilder text, int index, string value, int startIndex, int charCount);
    [ExtensionAttribute]
public static int LastIndexOf(StringBuilder text, string value, StringComparison comparisonType);
    [ExtensionAttribute]
public static int LastIndexOf(StringBuilder text, string value, int startIndex, StringComparison comparisonType);
    private static int LastIndexOfOrdinal(StringBuilder text, string value, int startIndex);
    private static int LastIndexOfOrdinalIgnoreCase(StringBuilder text, string value, int startIndex);
    [ExtensionAttribute]
public static StringBuilder Replace(StringBuilder text, int startIndex, int count, string newValue);
    [ExtensionAttribute]
public static StringBuilder Reverse(StringBuilder text);
    [ExtensionAttribute]
public static ICharSequence Subsequence(StringBuilder text, int startIndex, int length);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class J2N.Text.StringCharacterEnumerator : object {
    private string str;
    private int startIndex;
    private int length;
    private int position;
    public int StartIndex { get; }
    public int EndIndex { get; }
    public int Length { get; }
    public int Index { get; public set; }
    public char Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    public StringCharacterEnumerator(string value);
    public StringCharacterEnumerator(string value, int position);
    public StringCharacterEnumerator(string value, int startIndex, int length, int position);
    public sealed virtual int get_StartIndex();
    public sealed virtual int get_EndIndex();
    public sealed virtual int get_Length();
    public sealed virtual int get_Index();
    public sealed virtual void set_Index(int value);
    public sealed virtual bool TrySetIndex(int value);
    public sealed virtual char get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual void Dispose();
    public sealed virtual bool MoveFirst();
    public sealed virtual bool MoveNext();
    public sealed virtual bool MovePrevious();
    public sealed virtual bool MoveLast();
    private sealed virtual override void System.Collections.IEnumerator.Reset();
    public void Reset(string value);
    public void Reset(string value, int position);
    public void Reset(string value, int startIndex, int length, int position);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual object Clone();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class J2N.Text.StringCharSequence : object {
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasValue>k__BackingField;
    public string Value { get; }
    public bool HasValue { get; }
    public char Item { get; }
    public int Length { get; }
    public StringCharSequence(string value);
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_HasValue();
    public sealed virtual char get_Item(int index);
    public sealed virtual int get_Length();
    [NullableContextAttribute("1")]
public sealed virtual ICharSequence Subsequence(int startIndex, int length);
    [NullableContextAttribute("1")]
public virtual string ToString();
    public static bool op_Equality(StringCharSequence csq1, StringCharSequence csq2);
    public static bool op_Inequality(StringCharSequence csq1, StringCharSequence csq2);
    public static bool op_Equality(StringCharSequence csq1, string csq2);
    public static bool op_Inequality(StringCharSequence csq1, string csq2);
    public static bool op_Equality(string csq1, StringCharSequence csq2);
    public static bool op_Inequality(string csq1, StringCharSequence csq2);
    public sealed virtual bool Equals(ICharSequence other);
    public sealed virtual bool Equals(StringCharSequence other);
    public sealed virtual bool Equals(CharArrayCharSequence other);
    public sealed virtual bool Equals(StringBuilderCharSequence other);
    public sealed virtual bool Equals(string other);
    public sealed virtual bool Equals(StringBuilder other);
    public sealed virtual bool Equals(Char[] other);
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    public sealed virtual int CompareTo(ICharSequence other);
    public sealed virtual int CompareTo(string other);
    public sealed virtual int CompareTo(StringBuilder other);
    public sealed virtual int CompareTo(Char[] other);
    public sealed virtual int CompareTo(object other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class J2N.Text.StringExtensions : object {
    [ExtensionAttribute]
public static ICharSequence AsCharSequence(string text);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static int CompareToOrdinal(string str, ICharSequence value);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static int CompareToOrdinal(string str, Char[] value);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static int CompareToOrdinal(string str, StringBuilder value);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static int CompareToOrdinal(string str, string value);
    [ExtensionAttribute]
public static bool Contains(string input, char value);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool ContentEquals(string text, ICharSequence charSequence);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool ContentEquals(string text, Char[] charSequence);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool ContentEquals(string text, StringBuilder charSequence);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool ContentEquals(string text, string charSequence);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool ContentEquals(string text, ICharSequence charSequence, StringComparison comparisonType);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool ContentEquals(string text, Char[] charSequence, StringComparison comparisonType);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool ContentEquals(string text, StringBuilder charSequence, StringComparison comparisonType);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool ContentEquals(string text, string charSequence, StringComparison comparisonType);
    [ExtensionAttribute]
public static Byte[] GetBytes(string text, Encoding encoding);
    [ExtensionAttribute]
public static int IndexOf(string text, int codePoint);
    [ExtensionAttribute]
public static int IndexOf(string text, int codePoint, int startIndex);
    [ExtensionAttribute]
private static int IndexOfSupplementary(string text, int codePoint, int startIndex);
    [ExtensionAttribute]
public static string Intern(string text);
    [ExtensionAttribute]
public static int LastIndexOf(string text, int codePoint);
    [ExtensionAttribute]
public static int LastIndexOf(string text, int codePoint, int startIndex);
    [ExtensionAttribute]
private static int LastIndexOfSupplementary(string text, int codePoint, int startIndex);
    [ExtensionAttribute]
public static bool RegionMatches(string text, int thisStartIndex, ICharSequence other, int otherStartIndex, int length, StringComparison comparisonType);
    [ExtensionAttribute]
public static bool RegionMatches(string text, int thisStartIndex, Char[] other, int otherStartIndex, int length, StringComparison comparisonType);
    [ExtensionAttribute]
public static bool RegionMatches(string text, int thisStartIndex, StringBuilder other, int otherStartIndex, int length, StringComparison comparisonType);
    [ExtensionAttribute]
public static bool RegionMatches(string text, int thisStartIndex, string other, int otherStartIndex, int length, StringComparison comparisonType);
    [ExtensionAttribute]
public static bool StartsWith(string text, string prefix, int startIndex, StringComparison comparisonType);
    [ExtensionAttribute]
public static ICharSequence Subsequence(string text, int startIndex, int length);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class J2N.Text.StringFormatter : object {
    [CompilerGeneratedAttribute]
private static StringFormatter <CurrentCulture>k__BackingField;
    [CompilerGeneratedAttribute]
private static StringFormatter <CurrentUICulture>k__BackingField;
    [CompilerGeneratedAttribute]
private static StringFormatter <InvariantCulture>k__BackingField;
    [NullableAttribute("2")]
private Char[] cultureSymbol;
    [NullableAttribute("2")]
private CultureInfo culture;
    private Nullable`1<CultureType> cultureType;
    [NullableAttribute("2")]
private IFormatProvider formatProvider;
    public static StringFormatter CurrentCulture { get; }
    public static StringFormatter CurrentUICulture { get; }
    public static StringFormatter InvariantCulture { get; }
    [ObsoleteAttribute("Store the CultureInfo in your subclass from the CultureInfo constructor. Note that .NET doesn't provide a reliable way to get from IFormatProvider > CultureInfo, so this will return the current cultue when using the IFormatProvider constructor.")]
protected CultureInfo Culture { get; }
    private IFormatProvider FormatProvider { get; }
    public StringFormatter(CultureInfo culture);
    public StringFormatter(IFormatProvider formatProvider);
    internal StringFormatter(CultureType cultureType);
    private static StringFormatter();
    [CompilerGeneratedAttribute]
public static StringFormatter get_CurrentCulture();
    [CompilerGeneratedAttribute]
public static StringFormatter get_CurrentUICulture();
    [CompilerGeneratedAttribute]
public static StringFormatter get_InvariantCulture();
    protected virtual CultureInfo get_Culture();
    private IFormatProvider get_FormatProvider();
    [NullableContextAttribute("2")]
public virtual object GetFormat(Type formatType);
    [NullableContextAttribute("2")]
public virtual string Format(string format, object arg, IFormatProvider formatProvider);
    private static string FormatBoolean(bool b);
    [OnDeserializedAttribute]
internal void OnDeserializedMethod(StreamingContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class J2N.Text.StringTokenizer : object {
    private string str;
    private string delimiters;
    private bool returnDelimiters;
    private int position;
    private int remainingTokens;
    [CompilerGeneratedAttribute]
private string <Current>k__BackingField;
    public int RemainingTokens { get; }
    public string Current { get; private set; }
    private object System.Collections.IEnumerator.Current { get; }
    public StringTokenizer(string str);
    public StringTokenizer(string str, string delimiters);
    public StringTokenizer(string str, string delimiters, bool returnDelimiters);
    internal int CountTokens();
    internal bool HasMoreTokens();
    private string NextToken();
    public int get_RemainingTokens();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Current();
    [CompilerGeneratedAttribute]
private void set_Current(string value);
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual bool MoveNext();
    public bool MoveNext(string delimiters);
    private sealed virtual override void System.Collections.IEnumerator.Reset();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{Value}")]
public class J2N.Threading.Atomic.AtomicBoolean : object {
    private int value;
    internal static int True;
    internal static int False;
    public bool Value { get; public set; }
    public AtomicBoolean(bool value);
    public bool get_Value();
    public void set_Value(bool value);
    public bool CompareAndSet(bool expect, bool update);
    public bool GetAndSet(bool newValue);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(AtomicBoolean other);
    public sealed virtual bool Equals(bool other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object other);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static bool op_Implicit(AtomicBoolean atomicBoolean);
    public static bool op_Equality(AtomicBoolean a1, AtomicBoolean a2);
    public static bool op_Inequality(AtomicBoolean a1, AtomicBoolean a2);
    public static bool op_Equality(AtomicBoolean a1, bool a2);
    public static bool op_Inequality(AtomicBoolean a1, bool a2);
    public static bool op_Equality(bool a1, AtomicBoolean a2);
    public static bool op_Inequality(bool a1, AtomicBoolean a2);
    public static bool op_Equality(AtomicBoolean a1, Nullable`1<bool> a2);
    public static bool op_Inequality(AtomicBoolean a1, Nullable`1<bool> a2);
    public static bool op_Equality(Nullable`1<bool> a1, AtomicBoolean a2);
    public static bool op_Inequality(Nullable`1<bool> a1, AtomicBoolean a2);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{Value}")]
public class J2N.Threading.Atomic.AtomicInt32 : Number {
    private int value;
    public int Value { get; public set; }
    public AtomicInt32(int value);
    public int get_Value();
    public void set_Value(int value);
    public int GetAndSet(int newValue);
    public bool CompareAndSet(int expect, int update);
    public int GetAndIncrement();
    public int GetAndDecrement();
    public int GetAndAdd(int value);
    public int IncrementAndGet();
    public int DecrementAndGet();
    public int AddAndGet(int value);
    public sealed virtual bool Equals(AtomicInt32 other);
    public sealed virtual bool Equals(int other);
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public virtual string ToString(string format);
    [NullableContextAttribute("1")]
public virtual string ToString(IFormatProvider provider);
    public virtual string ToString(string format, IFormatProvider provider);
    public virtual byte ToByte();
    [CLSCompliantAttribute("False")]
public virtual sbyte ToSByte();
    public virtual double ToDouble();
    public virtual float ToSingle();
    public virtual int ToInt32();
    public virtual long ToInt64();
    public virtual short ToInt16();
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    [NullableContextAttribute("1")]
private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    [NullableContextAttribute("1")]
public static int op_Implicit(AtomicInt32 atomicInt32);
    [NullableContextAttribute("1")]
public static bool op_Equality(AtomicInt32 a1, AtomicInt32 a2);
    [NullableContextAttribute("1")]
public static bool op_Inequality(AtomicInt32 a1, AtomicInt32 a2);
    [NullableContextAttribute("1")]
public static bool op_Equality(AtomicInt32 a1, int a2);
    [NullableContextAttribute("1")]
public static bool op_Inequality(AtomicInt32 a1, int a2);
    [NullableContextAttribute("1")]
public static bool op_Equality(int a1, AtomicInt32 a2);
    [NullableContextAttribute("1")]
public static bool op_Inequality(int a1, AtomicInt32 a2);
    [NullableContextAttribute("1")]
public static bool op_Equality(AtomicInt32 a1, Nullable`1<int> a2);
    [NullableContextAttribute("1")]
public static bool op_Inequality(AtomicInt32 a1, Nullable`1<int> a2);
    [NullableContextAttribute("1")]
public static bool op_Equality(Nullable`1<int> a1, AtomicInt32 a2);
    [NullableContextAttribute("1")]
public static bool op_Inequality(Nullable`1<int> a1, AtomicInt32 a2);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{Value}")]
public class J2N.Threading.Atomic.AtomicInt64 : Number {
    private long value;
    public long Value { get; public set; }
    public AtomicInt64(long value);
    public long get_Value();
    public void set_Value(long value);
    public long GetAndSet(int newValue);
    public bool CompareAndSet(long expect, long update);
    public long GetAndIncrement();
    public long GetAndDecrement();
    public long GetAndAdd(long value);
    public long IncrementAndGet();
    public long DecrementAndGet();
    public long AddAndGet(long value);
    public sealed virtual bool Equals(AtomicInt64 other);
    public sealed virtual bool Equals(long other);
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public virtual string ToString(string format);
    [NullableContextAttribute("1")]
public virtual string ToString(IFormatProvider provider);
    public virtual string ToString(string format, IFormatProvider provider);
    public virtual byte ToByte();
    [CLSCompliantAttribute("False")]
public virtual sbyte ToSByte();
    public virtual double ToDouble();
    public virtual float ToSingle();
    public virtual int ToInt32();
    public virtual long ToInt64();
    public virtual short ToInt16();
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    [NullableContextAttribute("1")]
private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    [NullableContextAttribute("1")]
public static long op_Implicit(AtomicInt64 atomicInt64);
    [NullableContextAttribute("1")]
public static bool op_Equality(AtomicInt64 a1, AtomicInt64 a2);
    [NullableContextAttribute("1")]
public static bool op_Inequality(AtomicInt64 a1, AtomicInt64 a2);
    [NullableContextAttribute("1")]
public static bool op_Equality(AtomicInt64 a1, long a2);
    [NullableContextAttribute("1")]
public static bool op_Inequality(AtomicInt64 a1, long a2);
    [NullableContextAttribute("1")]
public static bool op_Equality(long a1, AtomicInt64 a2);
    [NullableContextAttribute("1")]
public static bool op_Inequality(long a1, AtomicInt64 a2);
    [NullableContextAttribute("1")]
public static bool op_Equality(AtomicInt64 a1, Nullable`1<long> a2);
    [NullableContextAttribute("1")]
public static bool op_Inequality(AtomicInt64 a1, Nullable`1<long> a2);
    [NullableContextAttribute("1")]
public static bool op_Equality(Nullable`1<long> a1, AtomicInt64 a2);
    [NullableContextAttribute("1")]
public static bool op_Inequality(Nullable`1<long> a1, AtomicInt64 a2);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{Value}")]
public class J2N.Threading.Atomic.AtomicReference`1 : object {
    private T value;
    [NullableAttribute("1")]
private static T Comparand;
    public T Value { get; public set; }
    [NullableContextAttribute("1")]
public AtomicReference`1(T value);
    private static AtomicReference`1();
    public T get_Value();
    public void set_Value(T value);
    public bool CompareAndSet(T expect, T update);
    public T GetAndSet(T value);
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public static T op_Implicit(AtomicReference`1<T> atomicReference);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class J2N.Threading.Atomic.AtomicReferenceArray`1 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private T[] array;
    [NullableAttribute("1")]
private static T Comparand;
    public int Length { get; }
    public T Item { get; public set; }
    public AtomicReferenceArray`1(int length);
    public AtomicReferenceArray`1(T[] array);
    private static AtomicReferenceArray`1();
    public int get_Length();
    public T get_Item(int index);
    public void set_Item(int index, T value);
    public T GetAndSet(int index, T newValue);
    public bool CompareAndSet(int index, T expect, T update);
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public virtual string ToString(IFormatProvider provider);
    private sealed virtual override string J2N.Text.IStructuralFormattable.ToString(string format, IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class J2N.Threading.ThreadJob : object {
    private ThreadStart threadStart;
    private Thread thread;
    [NullableAttribute("2")]
private string name;
    [NullableAttribute("2")]
private Exception exception;
    [NullableAttribute("2")]
[ThreadStaticAttribute]
private static ThreadJob thisInstance;
    [CompilerGeneratedAttribute]
private bool <IsDebug>k__BackingField;
    public object SyncRoot { get; }
    public Thread Instance { get; private set; }
    public static ThreadJob CurrentThread { get; }
    [NullableAttribute("2")]
public string Name { get; public set; }
    public ThreadState State { get; }
    public ThreadPriority Priority { get; public set; }
    public bool IsAlive { get; }
    public bool IsBackground { get; public set; }
    [ObsoleteAttribute("This setting no longer has any effect, as we are throwing the exception using ExceptionDispatchInfo so the stack trace is 'always on'.")]
public bool IsDebug { get; public set; }
    public ThreadJob(string threadName);
    public ThreadJob(ThreadStart threadStart);
    public ThreadJob(ThreadStart threadStart, string threadName);
    protected virtual void SafeRun(ThreadStart start);
    private bool IsThreadingException(Exception e);
    public virtual void Run();
    public virtual void Start();
    public virtual void Interrupt();
    public object get_SyncRoot();
    public Thread get_Instance();
    private void set_Instance(Thread value);
    public static ThreadJob get_CurrentThread();
    [NullableContextAttribute("2")]
public string get_Name();
    [NullableContextAttribute("2")]
public void set_Name(string value);
    public ThreadState get_State();
    public ThreadPriority get_Priority();
    public void set_Priority(ThreadPriority value);
    public bool get_IsAlive();
    public bool get_IsBackground();
    public void set_IsBackground(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsDebug();
    [CompilerGeneratedAttribute]
public void set_IsDebug(bool value);
    private void RethrowFirstException();
    public void Join();
    public void Join(long milliSeconds);
    public void Join(long milliSeconds, int nanoSeconds);
    public void Resume();
    public static void Yield();
    public void Suspend();
    public static void Sleep(long milliSeconds);
    public static void Sleep(long milliSeconds, int nanoSeconds);
    public static void Sleep(TimeSpan timeout);
    public static bool Interrupted();
    public static bool op_Equality(ThreadJob t1, object t2);
    public static bool op_Inequality(ThreadJob t1, object t2);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(Thread other);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(ThreadJob other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
private void <.ctor>b__4_0();
    [CompilerGeneratedAttribute]
private void <.ctor>b__5_0();
    [CompilerGeneratedAttribute]
private void <.ctor>b__6_0();
    [CompilerGeneratedAttribute]
private void <.ctor>b__7_0();
}
[ExtensionAttribute]
public static class J2N.Time : object {
    public static long MillisecondsPerNanosecond;
    public static long SecondsPerNanosecond;
    private static long UnixEpochTicks;
    public static DateTime UnixEpoch;
    private static Time();
    public static long NanoTime();
    public static long CurrentTimeMilliseconds();
    [ExtensionAttribute]
public static long GetMillisecondsSinceUnixEpoch(DateTime dateTime);
    [ExtensionAttribute]
public static TimeSpan GetTimeSpanSinceUnixEpoch(DateTime dateTime);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class J2N.TypeExtensions : object {
    [ExtensionAttribute]
public static bool ImplementsGenericInterface(Type target, Type interfaceType);
    [ExtensionAttribute]
public static Stream FindAndGetManifestResourceStream(Type type, string name);
    [ExtensionAttribute]
public static string FindResource(Type type, string name);
    [ExtensionAttribute]
internal static bool IsNullableType(Type type);
}
[ExtensionAttribute]
public static class J2N.TypeInfoExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool ImplementsGenericInterface(TypeInfo target, Type interfaceType);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
internal static class System.Collections.HashHelpers : object {
    public static UInt32 HashCollisionThreshold;
    public static int MaxPrimeArrayLength;
    public static int HashPrime;
    [NullableAttribute("1")]
private static Int32[] s_primes;
    private static HashHelpers();
    public static bool IsPrime(int candidate);
    public static int GetPrime(int min);
    public static int ExpandPrime(int oldSize);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsUnmanagedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
