[ExtensionAttribute]
public static class JasperFx.Core.ArrayTools : object {
    public static T[] Empty();
    [ExtensionAttribute]
public static T[] One(T one);
    [ExtensionAttribute]
public static bool IsNullOrEmpty(T[] source);
    [ExtensionAttribute]
public static T[] EmptyIfNull(T[] source);
    [ExtensionAttribute]
public static T[] ToArrayOrSelf(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static IList`1<T> ToListOrSelf(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static T[] Copy(T[] source);
    [ExtensionAttribute]
public static T[] CopyNonEmpty(T[] source);
    [ExtensionAttribute]
public static T[] Append(T[] source, T[] added);
    [ExtensionAttribute]
public static T[] Append(IEnumerable`1<T> source, IEnumerable`1<T> other);
    [ExtensionAttribute]
public static T[] AppendOrUpdate(T[] source, T value, int index);
    [ExtensionAttribute]
public static T[] UpdateNonEmpty(T[] source, T value, int index);
    [ExtensionAttribute]
public static T[] AppendNonEmpty(T[] source, T[] added);
    [ExtensionAttribute]
public static T[] Append(T[] source, T value);
    [ExtensionAttribute]
public static T[] AppendToNonEmpty(T[] source, T value);
    [ExtensionAttribute]
public static T[] PrependToNonEmpty(T[] source, T value);
    [ExtensionAttribute]
public static int IndexOf(T[] source, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static int IndexOf(T[] source, S state, Func`3<S, T, bool> predicate);
    [ExtensionAttribute]
public static int IndexOf(T[] source, T value);
    [ExtensionAttribute]
public static int IndexOfReference(T[] source, T reference);
    [ExtensionAttribute]
public static T[] RemoveAt(T[] source, int index);
    [ExtensionAttribute]
public static T[] Remove(T[] source, T value);
    [ExtensionAttribute]
public static T FindFirst(T[] source, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static T FindFirst(T[] source, S state, Func`3<S, T, bool> predicate);
    [ExtensionAttribute]
public static T FindFirst(IEnumerable`1<T> source, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static T SingleOrDefaultIfMany(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static void ForEach(T[] source, Action`1<T> action);
    public static T[] AppendTo(T[] source, int sourcePos, int count, T[] results);
    private static R[] AppendTo(T[] source, int sourcePos, int count, Func`2<T, R> map, R[] results);
    private static R[] AppendTo(T[] source, S state, int sourcePos, int count, Func`3<S, T, R> map, R[] results);
    private static R[] AppendTo(T[] source, A a, B b, int sourcePos, int count, Func`4<A, B, T, R> map, R[] results);
    [ExtensionAttribute]
public static T[] Match(T[] source, Func`2<T, bool> condition);
    [ExtensionAttribute]
public static T[] Match(T[] source, S state, Func`3<S, T, bool> condition);
    [ExtensionAttribute]
public static T[] Match(T[] source, A a, B b, Func`4<A, B, T, bool> condition);
    [ExtensionAttribute]
public static R[] Match(T[] source, Func`2<T, bool> condition, Func`2<T, R> map);
    [ExtensionAttribute]
public static R[] Match(T[] source, S state, Func`3<S, T, bool> condition, Func`3<S, T, R> map);
    [ExtensionAttribute]
public static R[] Match(T[] source, A a, B b, Func`4<A, B, T, bool> condition, Func`4<A, B, T, R> map);
    [ExtensionAttribute]
public static R[] Map(T[] source, Func`2<T, R> map);
    [ExtensionAttribute]
public static R[] Map(T[] source, S state, Func`3<S, T, R> map);
    [ExtensionAttribute]
public static R[] Map(T[] source, A a, B b, Func`4<A, B, T, R> map);
    [ExtensionAttribute]
public static IEnumerable`1<R> Map(IEnumerable`1<T> source, Func`2<T, R> map);
    [ExtensionAttribute]
public static IEnumerable`1<T> Match(IEnumerable`1<T> source, Func`2<T, bool> condition);
    [ExtensionAttribute]
public static IEnumerable`1<R> Match(IEnumerable`1<T> source, Func`2<T, bool> condition, Func`2<T, R> map);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class JasperFx.Core.Cache`2 : object {
    private object _locker;
    private ImHashMap`2<TKey, TValue> _values;
    private Action`1<TValue> _onAddition;
    private Func`2<TKey, TValue> _onMissing;
    [CompilerGeneratedAttribute]
private Func`2<TValue, TKey> <GetKey>k__BackingField;
    unknown Action`1<TValue> OnAddition {public set; }
    unknown Func`2<TKey, TValue> OnMissing {public set; }
    public Func`2<TValue, TKey> GetKey { get; public set; }
    public int Count { get; }
    public TValue Item { get; public set; }
    public Cache`2(Func`2<TKey, TValue> onMissing);
    public Cache`2(IDictionary`2<TKey, TValue> dictionary, Func`2<TKey, TValue> onMissing);
    public Cache`2(IDictionary`2<TKey, TValue> dictionary);
    public IEnumerable`1<TKey> Keys();
    public void set_OnAddition(Action`1<TValue> value);
    public void set_OnMissing(Func`2<TKey, TValue> value);
    [CompilerGeneratedAttribute]
public Func`2<TValue, TKey> get_GetKey();
    [CompilerGeneratedAttribute]
public void set_GetKey(Func`2<TValue, TKey> value);
    public int get_Count();
    public TValue get_Item(TKey key);
    public void set_Item(TKey key, TValue value);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IEnumerator`1<TValue> GetEnumerator();
    public void FillDefault(TKey key);
    public void Fill(TKey key, Func`2<TKey, TValue> onMissing);
    public void Fill(TKey key, TValue value);
    public bool TryFind(TKey key, TValue& value);
    public TKey[] GetAllKeys();
    public void Remove(TKey key);
    public void ClearAll();
    public IDictionary`2<TKey, TValue> ToDictionary();
}
public class JasperFx.Core.CombGuidIdGeneration : object {
    public static Guid NewGuid(DateTimeOffset timestamp);
    public static Guid NewGuid();
    private static void WriteDateTime(Span`1<byte> destination, DateTimeOffset timestamp);
    private static DateTimeOffset BytesToDateTime(ReadOnlySpan`1<byte> value);
    public static Guid Create(Guid value, DateTimeOffset timestamp);
    public static DateTimeOffset GetTimestamp(Guid comb);
}
public enum JasperFx.Core.CopyBehavior : Enum {
    public int value__;
    public static CopyBehavior overwrite;
    public static CopyBehavior preserve;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class JasperFx.Core.DisposableExtensions : object {
    [ExtensionAttribute]
public static void SafeDispose(IDisposable disposable);
    [AsyncStateMachineAttribute("JasperFx.Core.DisposableExtensions/<MaybeDisposeAllAsync>d__1`1")]
[ExtensionAttribute]
public static ValueTask MaybeDisposeAllAsync(IEnumerable`1<T> objects);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class JasperFx.Core.EnumerableExtensions : object {
    [ExtensionAttribute]
public static int GetFirstIndex(IEnumerable`1<T> enumerable, Func`2<T, bool> condition);
    [ExtensionAttribute]
public static IEnumerable`1<T> TopologicalSort(IEnumerable`1<T> source, Func`2<T, IEnumerable`1<T>> getDependencies, bool throwOnCycle);
    [ExtensionAttribute]
public static IEnumerable`1<T> TopologicalSort(IEnumerable`1<T> source, Func`2<T, IEnumerator`1<T>> getDependencies, bool throwOnCycle);
    private static void Visit(T root, ISet`1<T> visited, ISet`1<T> visiting, ICollection`1<T> sorted, Stack`1<ValueTuple`2<T, IEnumerator`1<T>>> stack, Func`2<T, IEnumerator`1<T>> getDependencies, bool throwOnCycle);
    [ExtensionAttribute]
public static void Fill(IList`1<T> list, T value);
    [ExtensionAttribute]
public static void Fill(IList`1<T> list, IEnumerable`1<T> values);
    [ExtensionAttribute]
public static void RemoveAll(IList`1<T> list, Func`2<T, bool> whereEvaluator);
    [ExtensionAttribute]
public static IEnumerable`1<T> Each(IEnumerable`1<T> values, Action`2<T, int> eachAction);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static IEnumerable`1<T> Each(IEnumerable`1<T> values, Action`1<T> eachAction);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static IEnumerable Each(IEnumerable values, Action`1<object> eachAction);
    [ExtensionAttribute]
public static TReturn FirstValue(IEnumerable`1<TItem> enumerable, Func`2<TItem, TReturn> func);
    [ExtensionAttribute]
public static IList`1<T> AddMany(IList`1<T> list, T[] items);
    [ExtensionAttribute]
public static IList`1<T> AddRange(IList`1<T> list, IEnumerable`1<T> items);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JasperFx.Core.Exceptions.ExceptionTransform`1 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IList`1<FilterRule<T>> _rules;
    public sealed virtual bool TryTransform(Exception original, Exception& transformed);
    public ExceptionTransform`1<T> TransformTo(Func`2<T, Exception> transform);
    public FilterRule<T> If(Func`2<T, bool> filter);
    [NullableContextAttribute("2")]
public FilterRule<T> IfInnerIs(Func`2<TInner, bool> innerFilter);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class JasperFx.Core.Exceptions.ExceptionTransformer : object {
    public static ExceptionTransforms Transforms;
    private static ExceptionTransformer();
    public static void WrapAndThrow(Exception exception);
}
[ExtensionAttribute]
public static class JasperFx.Core.Exceptions.ExceptionTransformExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static void TransformAndThrow(IEnumerable`1<IExceptionTransform> transforms, Exception ex);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JasperFx.Core.Exceptions.ExceptionTransforms : object {
    private IList`1<IExceptionTransform> _transforms;
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IEnumerator`1<IExceptionTransform> GetEnumerator();
    [NullableContextAttribute("0")]
public void AddTransform();
    public void AddTransform(IExceptionTransform transform);
    public ExceptionTransform`1<T> IfExceptionIs();
    public void TransformAndThrow(Exception ex);
}
[NullableContextAttribute("1")]
public interface JasperFx.Core.Exceptions.IExceptionTransform {
    public abstract virtual bool TryTransform(Exception original, Exception& transformed);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class JasperFx.Core.FileHashingExtensions : object {
    [ExtensionAttribute]
public static string HashByModifiedDate(string filename);
    [ExtensionAttribute]
public static string GetModifiedDateFileText(string filename);
    [ExtensionAttribute]
public static string HashByModifiedDate(IEnumerable`1<string> files);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JasperFx.Core.FileSet : object {
    [CompilerGeneratedAttribute]
private string <Include>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Exclude>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DeepSearch>k__BackingField;
    [XmlAttributeAttribute]
public string Include { get; public set; }
    [NullableAttribute("2")]
[XmlAttributeAttribute]
public string Exclude { get; public set; }
    public bool DeepSearch { get; public set; }
    public static FileSet Deep(string include, string exclude);
    public static FileSet Shallow(string include, string exclude);
    public void AppendInclude(string include);
    [CompilerGeneratedAttribute]
public string get_Include();
    [CompilerGeneratedAttribute]
public void set_Include(string value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Exclude();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Exclude(string value);
    [CompilerGeneratedAttribute]
public bool get_DeepSearch();
    [CompilerGeneratedAttribute]
public void set_DeepSearch(bool value);
    public void AppendExclude(string exclude);
    public IEnumerable`1<string> IncludedFilesFor(string path);
    private IEnumerable`1<string> getAllDistinctFiles(string path, string pattern);
    public IEnumerable`1<string> ExcludedFilesFor(string path);
    public static FileSet ForAssemblyNames(IEnumerable`1<string> assemblyNames);
    public static FileSet ForAssemblyDebugFiles(IEnumerable`1<string> assemblyNames);
    [NullableContextAttribute("2")]
public bool Equals(FileSet other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static FileSet Everything();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class JasperFx.Core.FileSystem : object {
    public static int BufferSize;
    [NullableContextAttribute("2")]
public static void CreateDirectoryIfNotExists(string path);
    public static void Copy(string source, string destination);
    public static void Copy(string source, string destination, CopyBehavior behavior);
    public static bool IsFile(string path);
    public static bool FileExists(string filename);
    public static void WriteStreamToFile(string filename, Stream stream);
    public static void WriteStringToFile(string filename, string text);
    public static void AppendStringToFile(string filename, string text);
    public static void AlterFlatFile(string path, Action`1<List`1<string>> alteration);
    public static void DeleteDirectoryIfExists(string directory);
    public static void CleanDirectory(string directory);
    public static void DeleteFileIfExists(string filename);
    public static void MoveFile(string from, string to);
    public static void MoveFiles(string from, string to);
    public static IEnumerable`1<string> FindFiles(string directory, FileSet searchSpecification);
    public static void ReadTextFile(string path, Action`1<string> callback);
    private static void internalFileCopy(string source, string destination, CopyBehavior behavior);
    private static void internalDirectoryCopy(string source, string destination, CopyBehavior behavior);
    private static bool destinationIsFile(string destination);
    public static string Combine(String[] paths);
    public static void LaunchBrowser(string filename);
    public static IEnumerable`1<string> GetChildDirectories(string directory);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JasperFx.Core.Filters.CompositeFilter`1 : object {
    [CompilerGeneratedAttribute]
private List`1<IFilter`1<T>> <Filters>k__BackingField;
    internal List`1<IFilter`1<T>> Filters { get; }
    [CompilerGeneratedAttribute]
internal List`1<IFilter`1<T>> get_Filters();
    public bool Matches(T item);
    public sealed virtual IEnumerator`1<IFilter`1<T>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public void WithCondition(string description, Func`2<T, bool> filter);
}
[NullableContextAttribute("1")]
public interface JasperFx.Core.Filters.IFilter`1 {
    public string Description { get; }
    public abstract virtual bool Matches(T item);
    public abstract virtual string get_Description();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JasperFx.Core.Filters.LambdaFilter`1 : object {
    [CompilerGeneratedAttribute]
private Func`2<T, bool> <Filter>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    public Func`2<T, bool> Filter { get; }
    public string Description { get; }
    public LambdaFilter`1(string description, Func`2<T, bool> filter);
    [CompilerGeneratedAttribute]
public Func`2<T, bool> get_Filter();
    public sealed virtual bool Matches(T item);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Description();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class JasperFx.Core.FlatFileWriter : object {
    [CompilerGeneratedAttribute]
private List`1<string> <List>k__BackingField;
    public List`1<string> List { get; }
    public FlatFileWriter(List`1<string> list);
    public sealed virtual void WriteProperty(string name, string value);
    public sealed virtual void WriteLine(string line);
    public sealed virtual void Sort();
    [CompilerGeneratedAttribute]
public List`1<string> get_List();
    public virtual string ToString();
}
[ExtensionAttribute]
public static class JasperFx.Core.Fun : object {
    public static bool Always(T _);
    public static T Id(T x);
    [ExtensionAttribute]
public static R To(T x, Func`2<T, R> map);
    [ExtensionAttribute]
public static R To(T x, S state, Func`3<T, S, R> map);
    [ExtensionAttribute]
public static R To(object x);
    [ExtensionAttribute]
public static T Do(T x, Action`1<T> effect);
    [ExtensionAttribute]
public static T Do(T x, S state, Action`2<T, S> effect);
    [ExtensionAttribute]
public static R ToFunc(R result, T ignoredArg);
    public static void Swap(T& a, T& b);
}
public static class JasperFx.Core.GrowingList : object {
    public static int DefaultInitialCapacity;
    public static T& PushSlot(T[]& items, int count);
    public static void Push(T[]& items, int count, T item);
    internal static void Expand(T[]& items);
    public static T[] ResizeToArray(T[] items, int count);
    public static string ToString(T[] items, int count);
}
public class JasperFx.Core.GrowingList`1 : ValueType {
    public static int DefaultInitialCapacity;
    public T[] Items;
    public int Count;
    public GrowingList`1(T[] items, int count);
    public T& PushSlot();
    public void Push(T item);
    public void Pop();
    public T[] ResizeToArray();
    public T PopItem();
    public virtual string ToString();
}
public static class JasperFx.Core.Hasher : object {
    public static int Combine(T1 a, T2 b);
    public static int Combine(int h1, int h2);
}
[NullableContextAttribute("1")]
public interface JasperFx.Core.IFlatFileWriter {
    public abstract virtual void WriteProperty(string name, string value);
    public abstract virtual void WriteLine(string line);
    public abstract virtual void Sort();
}
[ExtensionAttribute]
public static class JasperFx.Core.ImHashMap : object {
    private static object _enumerationB3Tombstone;
    private static ImHashMap();
    [ExtensionAttribute]
public static string ToMermaidString(ImHashMap`2<K, V> map);
    internal static void InsertInOrder(int ph, Entry& p, Entry& e0, Entry& e1);
    internal static void InsertInOrder(int ph, Entry& p, Entry& e0, Entry& e1, Entry& e2);
    internal static void InsertInOrder(int ph, Entry& p, Entry& e0, Entry& e1, Entry& e2, Entry& e3);
    internal static void InsertInOrder(int ph, Entry& p, Entry& e0, Entry& e1, Entry& e2, Entry& e3, Entry& e4);
    internal static void InsertInOrder(int ph, Entry& p, Entry& e0, Entry& e1, Entry& e2, Entry& e3, Entry& e4, Entry& e5);
    internal static void InsertInOrder(int ph, Entry& p, Entry& e0, Entry& e1, Entry& e2, Entry& e3, Entry& e4, Entry& e5, Entry& e6);
    [ExtensionAttribute]
public static Enumerable`1<V> Enumerate(ImHashMap`2<int, V> map);
    [ExtensionAttribute]
public static Enumerable`2<K, V> Enumerate(ImHashMap`2<K, V> map);
    [ExtensionAttribute]
public static S ForEach(ImHashMap`2<K, V> map, S state, Action`3<ImHashMapEntry`2<K, V>, int, S> handler, MapParentStack parents);
    [ExtensionAttribute]
public static S ForEach(ImHashMap`2<int, V> map, S state, Action`3<VEntry`1<V>, int, S> handler, MapParentStack parents);
    [ExtensionAttribute]
public static void ForEach(ImHashMap`2<int, V> map, Action`2<VEntry`1<V>, int> handler, MapParentStack parents);
    [ExtensionAttribute]
public static void ForEach(ImHashMap`2<K, V> map, Action`2<ImHashMapEntry`2<K, V>, int> handler, MapParentStack parents);
    [ExtensionAttribute]
public static S Fold(ImHashMap`2<int, V> map, S state, Func`4<VEntry`1<V>, int, S, S> handler, MapParentStack parents);
    [ExtensionAttribute]
public static S Fold(ImHashMap`2<K, V> map, S state, Func`4<ImHashMapEntry`2<K, V>, int, S, S> handler, MapParentStack parents);
    [ExtensionAttribute]
public static S[] ToArray(ImHashMap`2<int, V> map, Func`2<VEntry`1<V>, S> selector);
    [ExtensionAttribute]
public static S[] ToArray(ImHashMap`2<K, V> map, Func`2<ImHashMapEntry`2<K, V>, S> selector);
    [ExtensionAttribute]
public static VEntry`1[] ToArray(ImHashMap`2<int, V> map);
    [ExtensionAttribute]
public static ImHashMapEntry`2[] ToArray(ImHashMap`2<K, V> map);
    [ExtensionAttribute]
public static Dictionary`2<K, V> ToDictionary(ImHashMap`2<K, V> map);
    [ExtensionAttribute]
public static Dictionary`2<int, V> ToDictionary(ImHashMap`2<int, V> map);
    [ExtensionAttribute]
public static bool Contains(ImHashMap`2<int, V> map, int key);
    [ExtensionAttribute]
public static bool Contains(ImHashMap`2<K, V> map, int hash, K key);
    [ExtensionAttribute]
public static bool Contains(ImHashMap`2<K, V> map, K key);
    [ExtensionAttribute]
public static ImHashMapEntry`2<int, V> GetSurePresent(ImHashMap`2<int, V> map, int hash);
    [ExtensionAttribute]
public static ImHashMapEntry`2<K, V> GetSurePresent(ImHashMap`2<K, V> map, int hash, K key);
    [ExtensionAttribute]
public static ImHashMapEntry`2<K, V> GetSurePresentByReferenceEquals(ImHashMap`2<K, V> map, int hash, K key);
    [ExtensionAttribute]
public static ImHashMapEntry`2<int, V> GetEntryOrDefault(ImHashMap`2<int, V> map, int hash);
    [ExtensionAttribute]
public static ImHashMapEntry`2<K, V> GetEntryOrDefault(ImHashMap`2<K, V> map, int hash, K key);
    [ExtensionAttribute]
public static ImHashMapEntry`2<K, V> GetEntryOrDefault(ImHashMap`2<K, V> map, K key);
    [ExtensionAttribute]
public static ImHashMapEntry`2<K, V> GetEntryOrDefaultByReferenceEquals(ImHashMap`2<K, V> map, int hash, K key);
    [ExtensionAttribute]
public static ImHashMapEntry`2<K, V> GetEntryOrDefaultByReferenceEquals(ImHashMap`2<K, V> map, K key);
    [ExtensionAttribute]
public static V GetValueOrDefault(ImHashMap`2<int, V> map, int hash);
    [ExtensionAttribute]
public static V GetValueOrDefault(ImHashMap`2<int, V> map, int hash, V defaultValue);
    [ExtensionAttribute]
public static V GetValueOrDefault(ImHashMap`2<K, V> map, int hash, K key);
    [ExtensionAttribute]
public static V GetValueOrDefault(ImHashMap`2<K, V> map, int hash, K key, V defaultValue);
    [ExtensionAttribute]
public static V GetValueOrDefault(ImHashMap`2<K, V> map, K key);
    [ExtensionAttribute]
public static V GetValueOrDefault(ImHashMap`2<K, V> map, K key, V defaultValue);
    [ExtensionAttribute]
public static V GetValueOrDefaultByReferenceEquals(ImHashMap`2<K, V> map, int hash, K key);
    [ExtensionAttribute]
public static V GetValueOrDefaultByReferenceEquals(ImHashMap`2<K, V> map, K key);
    [ExtensionAttribute]
public static bool TryFind(ImHashMap`2<int, V> map, int hash, V& value);
    [ExtensionAttribute]
public static bool TryFind(ImHashMap`2<K, V> map, int hash, K key, V& value);
    [ExtensionAttribute]
public static bool TryFind(ImHashMap`2<K, V> map, K key, V& value);
    [ExtensionAttribute]
public static bool TryFindByReferenceEquals(ImHashMap`2<K, V> map, int hash, K key, V& value);
    [ExtensionAttribute]
public static bool TryFindByReferenceEquals(ImHashMap`2<K, V> map, K key, V& value);
    public static ImHashMapEntry`2<int, V> Entry(int key, V value);
    public static ImHashMapEntry`2<int, V> EntryWithDefaultValue(int key);
    [ExtensionAttribute]
public static ImHashMapEntry`2<int, V> WithDefaultValue(ImHashMapEntry`2<int, V> e);
    public static ImHashMapEntry`2<K, V> Entry(int hash, K key, V value);
    public static ImHashMapEntry`2<K, V> EntryWithHash(K key, V value);
    public static ImHashMapEntry`2<K, V> EntryWithDefaultValue(int hash, K key);
    [ExtensionAttribute]
public static ImHashMapEntry`2<K, V> WithDefaultValue(ImHashMapEntry`2<K, V> e);
    [ExtensionAttribute]
public static ImHashMapEntry`2<K, V> SetValue(ImHashMapEntry`2<K, V> e, V value);
    public static ImHashMap`2<K, V> BuildFromDifferent(ImHashMapEntry`2<K, V> e0, ImHashMapEntry`2<K, V> e1);
    public static ImHashMap`2<K, V> BuildFromDifferent(ImHashMapEntry`2<K, V> e0, ImHashMapEntry`2<K, V> e1, ImHashMapEntry`2<K, V> e2);
    public static ImHashMap`2<K, V> BuildFromDifferent(ImHashMapEntry`2<K, V> e0, ImHashMapEntry`2<K, V> e1, ImHashMapEntry`2<K, V> e2, ImHashMapEntry`2<K, V> e3);
    public static ImHashMap`2<K, V> BuildUnchecked(ImHashMapEntry`2<K, V> e0, ImHashMapEntry`2<K, V> e1, ImHashMapEntry`2<K, V> e2, ImHashMapEntry`2<K, V> e3, ImHashMapEntry`2<K, V> e4);
    public static ImHashMap`2<K, V> BuildFromDifferent(ImHashMapEntry`2<K, V> e0, ImHashMapEntry`2<K, V> e1, ImHashMapEntry`2<K, V> e2, ImHashMapEntry`2<K, V> e3, ImHashMapEntry`2<K, V> e4, ImHashMapEntry`2<K, V> e5);
    public static ImHashMap`2<K, V> BuildFromDifferent(ImHashMapEntry`2<K, V> e0, ImHashMapEntry`2<K, V> e1, ImHashMapEntry`2<K, V> e2, ImHashMapEntry`2<K, V> e3, ImHashMapEntry`2<K, V> e4, ImHashMapEntry`2<K, V> e5, ImHashMapEntry`2<K, V> e6);
    public static ImHashMap`2<K, V> BuildFromDifferent(ImHashMapEntry`2<K, V> e0, ImHashMapEntry`2<K, V> e1, ImHashMapEntry`2<K, V> e2, ImHashMapEntry`2<K, V> e3, ImHashMapEntry`2<K, V> e4, ImHashMapEntry`2<K, V> e5, ImHashMapEntry`2<K, V> e6, ImHashMapEntry`2<K, V> e7, ImHashMapEntry`2<K, V> e8, ImHashMapEntry`2<K, V> e9);
    public static ImHashMapEntry`2<K, V> Entry(HKV`2& item);
    public static ImHashMap`2<K, V> BuildUnchecked(E items);
    [ExtensionAttribute]
public static ImHashMap`2<int, V> AddOrGetEntry(ImHashMap`2<int, V> map, ImHashMapEntry`2<int, V> newEntry);
    [ExtensionAttribute]
public static ImHashMap`2<K, V> AddOrGetEntry(ImHashMap`2<K, V> map, ImHashMapEntry`2<K, V> newEntry);
    [ExtensionAttribute]
public static ImHashMap`2<K, V> AddOrGetEntryByReferenceEquals(ImHashMap`2<K, V> map, ImHashMapEntry`2<K, V> newEntry);
    [ExtensionAttribute]
public static ImHashMap`2<K, V> AddOrUpdateEntry(ImHashMap`2<K, V> map, ImHashMapEntry`2<K, V> newEntry);
    [ExtensionAttribute]
public static ImHashMap`2<K, V> AddOrUpdateEntryByReferenceEquals(ImHashMap`2<K, V> map, ImHashMapEntry`2<K, V> newEntry);
    [ExtensionAttribute]
public static ImHashMap`2<int, V> AddOrUpdate(ImHashMap`2<int, V> map, int hash, V value);
    [ExtensionAttribute]
public static ImHashMap`2<int, V> AddSureNotPresent(ImHashMap`2<int, V> map, int hash, V value);
    [ExtensionAttribute]
public static ImHashMap`2<K, V> AddOrUpdate(ImHashMap`2<K, V> map, int hash, K key, V value);
    [ExtensionAttribute]
public static ImHashMap`2<K, V> AddOrUpdateByReferenceEquals(ImHashMap`2<K, V> map, int hash, K key, V value);
    [ExtensionAttribute]
public static ImHashMap`2<K, V> AddOrUpdate(ImHashMap`2<K, V> map, K key, V value);
    [ExtensionAttribute]
public static ImHashMap`2<K, V> AddOrUpdateByReferenceEquals(ImHashMap`2<K, V> map, K key, V value);
    [ExtensionAttribute]
public static ImHashMap`2<K, V> AddSureNotPresentEntry(ImHashMap`2<K, V> map, ImHashMapEntry`2<K, V> newEntry);
    [ExtensionAttribute]
public static ImHashMap`2<K, V> AddSureNotPresent(ImHashMap`2<K, V> map, int hash, K key, V value);
    [ExtensionAttribute]
public static ImHashMap`2<K, V> AddSureNotPresent(ImHashMap`2<K, V> map, K key, V value);
    [ExtensionAttribute]
public static ImHashMap`2<int, V> AddOrUpdate(ImHashMap`2<int, V> map, int hash, V value, Update`2<int, V> update);
    [ExtensionAttribute]
public static ImHashMap`2<K, V> AddOrUpdate(ImHashMap`2<K, V> map, int hash, K key, V value, Update`2<K, V> update);
    [ExtensionAttribute]
public static ImHashMap`2<K, V> AddOrUpdateByReferenceEquals(ImHashMap`2<K, V> map, int hash, K key, V value, Update`2<K, V> update);
    [ExtensionAttribute]
public static ImHashMap`2<K, V> AddOrUpdate(ImHashMap`2<K, V> map, K key, V value, Update`2<K, V> update);
    [ExtensionAttribute]
public static ImHashMap`2<int, V> AddOrKeep(ImHashMap`2<int, V> map, int hash, V value);
    [ExtensionAttribute]
public static ImHashMap`2<K, V> AddOrKeepEntry(ImHashMap`2<K, V> map, ImHashMapEntry`2<K, V> newEntry);
    [ExtensionAttribute]
public static ImHashMap`2<K, V> AddOrKeepEntryByReferenceEquals(ImHashMap`2<K, V> map, ImHashMapEntry`2<K, V> newEntry);
    [ExtensionAttribute]
public static ImHashMap`2<K, V> AddOrKeep(ImHashMap`2<K, V> map, int hash, K key, V value);
    [ExtensionAttribute]
public static ImHashMap`2<K, V> AddOrKeep(ImHashMap`2<K, V> map, K key, V value);
    [ExtensionAttribute]
public static ImHashMap`2<int, V> Update(ImHashMap`2<int, V> map, int hash, V value);
    [ExtensionAttribute]
public static ImHashMap`2<int, V> UpdateToDefault(ImHashMap`2<int, V> map, int hash);
    [ExtensionAttribute]
public static ImHashMap`2<K, V> Update(ImHashMap`2<K, V> map, int hash, K key, V value);
    [ExtensionAttribute]
public static ImHashMap`2<K, V> Update(ImHashMap`2<K, V> map, K key, V value);
    [ExtensionAttribute]
public static ImHashMap`2<K, V> UpdateToDefault(ImHashMap`2<K, V> map, int hash, K key);
    [ExtensionAttribute]
public static ImHashMap`2<K, V> UpdateToDefault(ImHashMap`2<K, V> map, K key);
    [ExtensionAttribute]
public static ImHashMap`2<K, V> Update(ImHashMap`2<K, V> map, int hash, K key, V value, Update`2<K, V> update);
    [ExtensionAttribute]
public static ImHashMap`2<K, V> Update(ImHashMap`2<K, V> map, K key, V value, Update`2<K, V> update);
    [ExtensionAttribute]
public static ImHashMap`2<int, V> Remove(ImHashMap`2<int, V> map, int hash);
    [ExtensionAttribute]
public static ImHashMap`2<K, V> Remove(ImHashMap`2<K, V> map, int hash, K key);
    [ExtensionAttribute]
public static ImHashMap`2<K, V> Remove(ImHashMap`2<K, V> map, K key);
}
public class JasperFx.Core.ImHashMap`2 : object {
    public static ImHashMap`2<K, V> Empty;
    public bool IsEmpty { get; }
    internal bool MayTurnToBranch2 { get; }
    private static ImHashMap`2();
    public virtual string ToString();
    internal virtual StringBuilder ToMermaidNodeId(StringBuilder s);
    internal virtual StringBuilder ToMermaidNodeItem(StringBuilder s);
    internal virtual StringBuilder ToMermaidString(StringBuilder s);
    public bool get_IsEmpty();
    public virtual int Count();
    internal virtual bool get_MayTurnToBranch2();
    internal virtual Entry<K, V> GetMinHashEntryOrDefault();
    internal virtual Entry<K, V> GetMaxHashEntryOrDefault();
    internal virtual Entry<K, V> GetEntryOrNull(int hash);
    internal virtual Entry<K, V> GetSurePresentEntry(int hash);
    internal virtual ImHashMap`2<K, V> AddOrGetEntry(int hash, Entry<K, V> entry);
    internal virtual ImHashMap`2<K, V> AddSureNotPresentEntry(Entry<K, V> entry);
    internal virtual ImHashMap`2<K, V> ReplaceEntry(Entry<K, V> oldEntry, Entry<K, V> newEntry);
    internal virtual ImHashMap`2<K, V> RemoveEntry(Entry<K, V> entry);
    internal virtual ImHashMap`2<K, V> GetMapOrReplaceWithEntry(ImHashMap`2<K, V> oldMap, ImHashMapEntry`2<K, V> newEntry);
    internal virtual ImHashMap`2<K, V> GetMapOrReplaceWithEntryByReferenceEquals(ImHashMap`2<K, V> oldMap, ImHashMapEntry`2<K, V> newEntry);
    internal virtual ImHashMap`2<K, V> GetEntryOrReplacedMapWithTheSameHash(ImHashMap`2<K, V> oldMap, ImHashMapEntry`2<K, V> newEntry);
    internal virtual ImHashMap`2<K, V> GetEntryOrReplacedMapWithTheSameHashByReferenceEquals(ImHashMap`2<K, V> oldMap, ImHashMapEntry`2<K, V> newEntry);
    internal virtual ImHashMap`2<K, V> AddOrKeepWithTheSameHash(ImHashMap`2<K, V> oldMap, ImHashMapEntry`2<K, V> newEntry);
    internal virtual ImHashMap`2<K, V> AddOrKeepWithTheSameHashByReferenceEquals(ImHashMap`2<K, V> oldMap, ImHashMapEntry`2<K, V> newEntry);
}
public abstract class JasperFx.Core.ImHashMapEntry`2 : Entry<K, V> {
    public V Value;
    protected ImHashMapEntry`2(int hash);
    protected ImHashMapEntry`2(int hash, V value);
    public virtual string ToString();
    public sealed virtual int Count();
    internal virtual int ForEach(S state, int startIndex, Action`3<ImHashMapEntry`2<K, V>, int, S> handler);
}
[ExtensionAttribute]
public static class JasperFx.Core.ImList : object {
    [ExtensionAttribute]
public static void Deconstruct(ImList`1<T> list, T& head, ImList`1& tail, Boolean& isEmpty);
    public static ImList`1<T> List(T[] items);
    [ExtensionAttribute]
public static ImList`1<T> ToImList(IList`1<T> source);
    [ExtensionAttribute]
public static ImList`1<T> ToImList(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static ImList`1<T> List(T head);
    [ExtensionAttribute]
public static ImList`1<T> List(T head, ImList`1<T> tail);
    [ExtensionAttribute]
public static void ForEach(ImList`1<T> list, Action`1<T> effect);
    [ExtensionAttribute]
public static S Fold(ImList`1<T> list, S state, Func`3<T, S, S> handler);
    [ExtensionAttribute]
public static S Fold(ImList`1<T> list, S state, Func`4<T, int, S, S> handler);
    [ExtensionAttribute]
public static ImList`1<T> Reverse(ImList`1<T> list);
    [ExtensionAttribute]
public static ImList`1<R> Map(ImList`1<T> list, Func`2<T, R> map);
    [ExtensionAttribute]
public static ImList`1<R> Map(ImList`1<T> list, Func`3<T, int, R> map);
    [ExtensionAttribute]
public static T[] ToArray(ImList`1<T> source);
}
public class JasperFx.Core.ImList`1 : object {
    public static ImList`1<T> Empty;
    public T Head;
    public ImList`1<T> Tail;
    public bool IsEmpty { get; }
    private ImList`1(T head, ImList`1<T> tail);
    private static ImList`1();
    public bool get_IsEmpty();
    public ImList`1<T> Push(T head);
    [IteratorStateMachineAttribute("JasperFx.Core.ImList`1/<Enumerate>d__6")]
public IEnumerable`1<T> Enumerate();
    public virtual string ToString();
}
[ExtensionAttribute]
public static class JasperFx.Core.ImZipper : object {
    public static ImZipper`1<T> Zip(T[] items);
    [ExtensionAttribute]
public static T[] ToArray(ImZipper`1<T> z);
    [ExtensionAttribute]
public static ImZipper`1<T> ShiftTo(ImZipper`1<T> z, int i);
    [ExtensionAttribute]
public static ImZipper`1<T> Update(ImZipper`1<T> z, Func`2<T, T> update);
    [ExtensionAttribute]
public static ImZipper`1<T> UpdateAt(ImZipper`1<T> z, int i, Func`2<T, T> update);
    [ExtensionAttribute]
public static ImZipper`1<T> RemoveAt(ImZipper`1<T> z, int i);
    [ExtensionAttribute]
public static S Fold(ImZipper`1<T> z, S state, Func`3<T, S, S> handler);
    [ExtensionAttribute]
public static S Fold(ImZipper`1<T> z, S state, Func`4<T, int, S, S> handler);
    [ExtensionAttribute]
public static void ForEach(ImZipper`1<T> z, Action`1<T> effect);
}
public class JasperFx.Core.ImZipper`1 : object {
    public static ImZipper`1<T> Empty;
    public int Index;
    public int Count;
    public ImList`1<T> Left;
    public ImList`1<T> Right;
    public T Focus;
    public bool IsEmpty { get; }
    private ImZipper`1(ImList`1<T> left, T focus, int index, ImList`1<T> right, int count);
    private static ImZipper`1();
    public bool get_IsEmpty();
    public virtual string ToString();
    public ImZipper`1<T> Append(T focus);
    public ImZipper`1<T> PushLeft(T focus);
    public ImZipper`1<T> Insert(T focus);
    public ImZipper`1<T> PushRight(T focus);
    public ImZipper`1<T> PopLeft();
    public ImZipper`1<T> PopRight();
    public ImZipper`1<T> ShiftLeft();
    public ImZipper`1<T> ShiftRight();
    public ImZipper`1<T> WithFocus(T focus);
    public ImZipper`1<R> Map(Func`2<T, R> map);
    public ImZipper`1<R> Map(Func`3<T, int, R> map);
}
public static class JasperFx.Core.IoC.AssemblyLoader : object {
    [NullableContextAttribute("1")]
public static Assembly ByName(string assemblyName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[LamarIgnoreAttribute]
public class JasperFx.Core.IoC.AssemblyScanner : object {
    private List`1<Assembly> _assemblies;
    private CompositeFilter`1<Type> _filter;
    private IServiceCollection _parent;
    private bool _hasScanned;
    [CompilerGeneratedAttribute]
private List`1<IRegistrationConvention> <Conventions>k__BackingField;
    [CompilerGeneratedAttribute]
private TypeSet <TypeFinder>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    public List`1<IRegistrationConvention> Conventions { get; }
    public TypeSet TypeFinder { get; private set; }
    public string Description { get; public set; }
    public AssemblyScanner(IServiceCollection parent);
    [CompilerGeneratedAttribute]
public List`1<IRegistrationConvention> get_Conventions();
    [CompilerGeneratedAttribute]
public TypeSet get_TypeFinder();
    [CompilerGeneratedAttribute]
private void set_TypeFinder(TypeSet value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Description();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Description(string value);
    public sealed virtual void Assembly(Assembly assembly);
    public sealed virtual void Assembly(string assemblyName);
    [NullableContextAttribute("0")]
public sealed virtual void Convention();
    [NullableContextAttribute("2")]
public sealed virtual void AssemblyContainingType();
    public sealed virtual void AssemblyContainingType(Type type);
    public sealed virtual FindAllTypesFilter AddAllTypesOf();
    public sealed virtual FindAllTypesFilter AddAllTypesOf(ServiceLifetime lifetime);
    public sealed virtual FindAllTypesFilter AddAllTypesOf(Type pluginType);
    public sealed virtual FindAllTypesFilter AddAllTypesOf(Type pluginType, ServiceLifetime lifetime);
    public sealed virtual void Exclude(Func`2<Type, bool> exclude);
    public sealed virtual void ExcludeNamespace(string nameSpace);
    [NullableContextAttribute("2")]
public sealed virtual void ExcludeNamespaceContainingType();
    public sealed virtual void Include(Func`2<Type, bool> predicate);
    public sealed virtual void IncludeNamespace(string nameSpace);
    [NullableContextAttribute("2")]
public sealed virtual void IncludeNamespaceContainingType();
    [NullableContextAttribute("2")]
public sealed virtual void ExcludeType();
    public sealed virtual void With(IRegistrationConvention convention);
    public sealed virtual void WithDefaultConventions();
    public sealed virtual void WithDefaultConventions(ServiceLifetime lifetime);
    public sealed virtual void WithDefaultConventions(OverwriteBehavior behavior);
    public sealed virtual void WithDefaultConventions(OverwriteBehavior behavior, ServiceLifetime lifetime);
    public sealed virtual void ConnectImplementationsToTypesClosing(Type openGenericType);
    public sealed virtual void ConnectImplementationsToTypesClosing(Type openGenericType, ServiceLifetime lifetime);
    public sealed virtual void ConnectImplementationsToTypesClosing(Type openGenericType, Func`2<Type, ServiceLifetime> lifetimeRule);
    public sealed virtual void RegisterConcreteTypesAgainstTheFirstInterface();
    public sealed virtual void RegisterConcreteTypesAgainstTheFirstInterface(ServiceLifetime lifetime);
    public sealed virtual void SingleImplementationsOfInterface();
    public sealed virtual void SingleImplementationsOfInterface(ServiceLifetime lifetime);
    public sealed virtual void TheCallingAssembly();
    public sealed virtual void AssembliesFromApplicationBaseDirectory();
    public sealed virtual void AssembliesFromApplicationBaseDirectory(Func`2<Assembly, bool> assemblyFilter);
    public sealed virtual void AssembliesAndExecutablesFromApplicationBaseDirectory(Func`2<Assembly, bool> assemblyFilter);
    [ObsoleteAttribute("It is very strongly recommended to use the overload with an Assembly filter to improve performance")]
public sealed virtual void AssembliesAndExecutablesFromPath(string path);
    [ObsoleteAttribute("It is very strongly recommended to use the overload with an Assembly filter to improve performance")]
public sealed virtual void AssembliesFromPath(string path);
    public sealed virtual void AssembliesAndExecutablesFromPath(string path, Func`2<Assembly, bool> assemblyFilter);
    public sealed virtual void AssembliesFromPath(string path, Func`2<Assembly, bool> assemblyFilter);
    public void Describe(StringWriter writer);
    public void Start();
    public void ApplyRegistrations(IServiceCollection services);
    public bool Contains(string assemblyName);
    [CompilerGeneratedAttribute]
private bool <Start>b__53_0(Type type);
}
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[LamarIgnoreAttribute]
public class JasperFx.Core.IoC.ConnectedConcretions : List`1<Type> {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class JasperFx.Core.IoC.DefaultConventionScanner : object {
    private ServiceLifetime _lifetime;
    [CompilerGeneratedAttribute]
private OverwriteBehavior <Overwrites>k__BackingField;
    public OverwriteBehavior Overwrites { get; public set; }
    public DefaultConventionScanner(ServiceLifetime lifetime);
    [CompilerGeneratedAttribute]
public OverwriteBehavior get_Overwrites();
    [CompilerGeneratedAttribute]
public void set_Overwrites(OverwriteBehavior value);
    public sealed virtual void ScanTypes(TypeSet types, IServiceCollection services);
    public bool ShouldAdd(IServiceCollection services, Type serviceType, Type implementationType);
    public virtual Type FindServiceType(Type concreteType);
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JasperFx.Core.IoC.FindAllTypesFilter : object {
    private ServiceLifetime _lifetime;
    private Type _serviceType;
    public FindAllTypesFilter(Type serviceType, ServiceLifetime lifetime);
    private sealed virtual override void JasperFx.Core.IoC.IRegistrationConvention.ScanTypes(TypeSet types, IServiceCollection services);
    private bool Matches(Type type);
    private static Type determineLeastSpecificButValidType(Type pluginType, Type type);
    public virtual string ToString();
}
internal class JasperFx.Core.IoC.FirstInterfaceConvention : object {
    private ServiceLifetime _lifetime;
    public FirstInterfaceConvention(ServiceLifetime lifetime);
    [NullableContextAttribute("1")]
public sealed virtual void ScanTypes(TypeSet types, IServiceCollection services);
    [NullableContextAttribute("1")]
public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class JasperFx.Core.IoC.GenericConnectionScanner : object {
    private IList`1<Type> _concretions;
    private IList`1<Type> _interfaces;
    private Type _openType;
    private Func`2<Type, ServiceLifetime> _lifetimeRule;
    public GenericConnectionScanner(Type openType, Func`2<Type, ServiceLifetime> lifetimeRule);
    public sealed virtual void ScanTypes(TypeSet types, IServiceCollection services);
    public virtual string ToString();
    private void addConcretionsThatCouldBeClosed(Type interface, IServiceCollection services);
}
[NullableContextAttribute("1")]
public interface JasperFx.Core.IoC.IAssemblyScanner {
    public string Description { get; public set; }
    public abstract virtual string get_Description();
    public abstract virtual void set_Description(string value);
    public abstract virtual void Assembly(Assembly assembly);
    public abstract virtual void Assembly(string assemblyName);
    [NullableContextAttribute("2")]
public abstract virtual void AssemblyContainingType();
    public abstract virtual void AssemblyContainingType(Type type);
    public abstract virtual FindAllTypesFilter AddAllTypesOf();
    public abstract virtual FindAllTypesFilter AddAllTypesOf(ServiceLifetime lifetime);
    public abstract virtual FindAllTypesFilter AddAllTypesOf(Type pluginType);
    public abstract virtual FindAllTypesFilter AddAllTypesOf(Type pluginType, ServiceLifetime lifetime);
    public abstract virtual void Exclude(Func`2<Type, bool> exclude);
    public abstract virtual void ExcludeNamespace(string nameSpace);
    [NullableContextAttribute("2")]
public abstract virtual void ExcludeNamespaceContainingType();
    public abstract virtual void Include(Func`2<Type, bool> predicate);
    public abstract virtual void IncludeNamespace(string nameSpace);
    [NullableContextAttribute("2")]
public abstract virtual void IncludeNamespaceContainingType();
    [NullableContextAttribute("2")]
public abstract virtual void ExcludeType();
    [NullableContextAttribute("0")]
public abstract virtual void Convention();
    public abstract virtual void With(IRegistrationConvention convention);
    public abstract virtual void WithDefaultConventions();
    public abstract virtual void WithDefaultConventions(ServiceLifetime lifetime);
    public abstract virtual void WithDefaultConventions(OverwriteBehavior behavior);
    public abstract virtual void WithDefaultConventions(OverwriteBehavior behavior, ServiceLifetime lifetime);
    public abstract virtual void RegisterConcreteTypesAgainstTheFirstInterface();
    public abstract virtual void RegisterConcreteTypesAgainstTheFirstInterface(ServiceLifetime lifetime);
    public abstract virtual void SingleImplementationsOfInterface();
    public abstract virtual void SingleImplementationsOfInterface(ServiceLifetime lifetime);
    public abstract virtual void TheCallingAssembly();
    public abstract virtual void AssembliesFromApplicationBaseDirectory();
    public abstract virtual void AssembliesFromApplicationBaseDirectory(Func`2<Assembly, bool> assemblyFilter);
    public abstract virtual void ConnectImplementationsToTypesClosing(Type openGenericType);
    public abstract virtual void ConnectImplementationsToTypesClosing(Type openGenericType, ServiceLifetime lifetime);
    public abstract virtual void AssembliesAndExecutablesFromApplicationBaseDirectory(Func`2<Assembly, bool> assemblyFilter);
    [ObsoleteAttribute("It is very strongly recommended to use the overload with an Assembly filter to improve performance")]
public abstract virtual void AssembliesAndExecutablesFromPath(string path);
    [ObsoleteAttribute("It is very strongly recommended to use the overload with an Assembly filter to improve performance")]
public abstract virtual void AssembliesFromPath(string path);
    public abstract virtual void AssembliesAndExecutablesFromPath(string path, Func`2<Assembly, bool> assemblyFilter);
    public abstract virtual void AssembliesFromPath(string path, Func`2<Assembly, bool> assemblyFilter);
    public abstract virtual void ConnectImplementationsToTypesClosing(Type openGenericType, Func`2<Type, ServiceLifetime> lifetimeRule);
}
internal class JasperFx.Core.IoC.ImplementationMap : object {
    private ServiceLifetime _lifetime;
    public ImplementationMap(ServiceLifetime lifetime);
    [NullableContextAttribute("1")]
public sealed virtual void ScanTypes(TypeSet types, IServiceCollection services);
    [NullableContextAttribute("1")]
public virtual string ToString();
}
[NullableContextAttribute("1")]
public interface JasperFx.Core.IoC.IRegistrationConvention {
    public abstract virtual void ScanTypes(TypeSet types, IServiceCollection services);
}
public enum JasperFx.Core.IoC.OverwriteBehavior : Enum {
    public int value__;
    public static OverwriteBehavior Always;
    public static OverwriteBehavior NewType;
    public static OverwriteBehavior Never;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class JasperFx.Core.IoC.ScanningExploder : object {
    internal static ValueTuple`2<IServiceCollection, AssemblyScanner[]> ExplodeSynchronously(IServiceCollection services);
    internal static Task`1<ValueTuple`2<IServiceCollection, AssemblyScanner[]>> Explode(IServiceCollection services);
    private static ValueTuple`2<IServiceCollection, List`1<object>> ParseToOperations(IServiceCollection services, List`1<Type> registriesEncountered);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class JasperFx.Core.IoC.ServiceCollectionExtensions : object {
    [NullableContextAttribute("2")]
[ExtensionAttribute]
internal static ServiceDescriptor TryFindDefault(IServiceCollection services);
    [ExtensionAttribute]
public static IServiceCollection Scan(IServiceCollection services, Action`1<IAssemblyScanner> scan);
    [ExtensionAttribute]
public static IServiceCollection ToCollection(IEnumerable`1<ServiceDescriptor> descriptors);
    [ExtensionAttribute]
public static bool HasScanners(IEnumerable`1<ServiceDescriptor> services);
    [ExtensionAttribute]
public static ConnectedConcretions ConnectedConcretions(IServiceCollection services);
    [ExtensionAttribute]
public static bool Matches(ServiceDescriptor descriptor, Type serviceType, Type implementationType);
    [ExtensionAttribute]
public static ServiceDescriptor AddType(IServiceCollection services, Type serviceType, Type implementationType, ServiceLifetime lifetime);
    [ExtensionAttribute]
public static ServiceDescriptor FindDefault(IServiceCollection services);
    [ExtensionAttribute]
public static ServiceDescriptor FindDefault(IServiceCollection services, Type serviceType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class JasperFx.Core.IoC.TypeExtensions : object {
    [ExtensionAttribute]
public static bool CanBeCreated(Type type);
    [ExtensionAttribute]
public static Type FindFirstInterfaceThatCloses(Type implementationType, Type templateType);
    [ExtensionAttribute]
public static IEnumerable`1<Type> FindInterfacesThatClose(Type pluggedType, Type templateType);
    [IteratorStateMachineAttribute("JasperFx.Core.IoC.TypeExtensions/<rawFindInterfacesThatCloses>d__3")]
private static IEnumerable`1<Type> rawFindInterfacesThatCloses(Type TPluggedType, Type templateType);
    [ExtensionAttribute]
public static bool CouldCloseTo(Type openConcretion, Type closedInterface);
}
public interface JasperFx.Core.IPrintable {
    public abstract virtual StringBuilder Print(StringBuilder s, Func`3<StringBuilder, object, StringBuilder> printer);
}
[ExtensionAttribute]
public static class JasperFx.Core.KeyValuePair : object {
    [ExtensionAttribute]
public static KeyValuePair`2<K, V> Pair(K key, V value);
}
[ExtensionAttribute]
public static class JasperFx.Core.KV : object {
    public static KV`2<K, V> Of(K key, V value);
    [ExtensionAttribute]
public static KV`2<K, V> WithValue(KV`2<K, V> kv, V value);
}
public class JasperFx.Core.KV`2 : object {
    public K Key;
    public V Value;
    public KV`2(K key, V value);
    public sealed virtual StringBuilder Print(StringBuilder s, Func`3<StringBuilder, object, StringBuilder> printer);
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class JasperFx.Core.KVEntry`2 : ImHashMapEntry`2<K, V> {
    internal K _key;
    public K Key { get; }
    public KVEntry`2(int hash, K key);
    public KVEntry`2(int hash, K key, V value);
    public virtual K get_Key();
    public virtual string ToString();
    internal virtual StringBuilder ToMermaidNodeItem(StringBuilder s);
    internal virtual ImHashMapEntry`2<K, V> GetOrNullWithTheSameHash(K key);
    internal virtual ImHashMapEntry`2<K, V> GetOrNullWithTheSameHashByReferenceEquals(K key);
    internal virtual V GetValueOrDefaultWithTheSameHashByReferenceEquals(K key);
    internal virtual Entry<K, V> AddOrUpdateWithTheSameHash(ImHashMapEntry`2<K, V> newEntry);
    internal virtual Entry<K, V> AddOrUpdateWithTheSameHashByReferenceEquals(ImHashMapEntry`2<K, V> newEntry);
    internal virtual Entry<K, V> AddOrUpdateWithTheSameHash(ImHashMapEntry`2<K, V> newEntry, Update`2<K, V> update);
    internal virtual Entry<K, V> AddOrUpdateWithTheSameHashByReferenceEquals(ImHashMapEntry`2<K, V> newEntry, Update`2<K, V> update);
    internal virtual ImHashMap`2<K, V> GetMapOrReplaceWithEntry(ImHashMap`2<K, V> oldMap, ImHashMapEntry`2<K, V> newEntry);
    internal virtual ImHashMap`2<K, V> GetMapOrReplaceWithEntryByReferenceEquals(ImHashMap`2<K, V> oldMap, ImHashMapEntry`2<K, V> newEntry);
    internal virtual ImHashMap`2<K, V> GetEntryOrReplacedMapWithTheSameHash(ImHashMap`2<K, V> oldMap, ImHashMapEntry`2<K, V> newEntry);
    internal virtual ImHashMap`2<K, V> GetEntryOrReplacedMapWithTheSameHashByReferenceEquals(ImHashMap`2<K, V> oldMap, ImHashMapEntry`2<K, V> newEntry);
    internal virtual ImHashMap`2<K, V> AddOrKeepWithTheSameHash(ImHashMap`2<K, V> oldMap, ImHashMapEntry`2<K, V> newEntry);
    internal virtual ImHashMap`2<K, V> AddOrKeepWithTheSameHashByReferenceEquals(ImHashMap`2<K, V> oldMap, ImHashMapEntry`2<K, V> newEntry);
    internal virtual Entry<K, V> UpdatedOrNullWithTheSameHash(ImHashMapEntry`2<K, V> newEntry);
    internal virtual Entry<K, V> UpdatedOrNullWithTheSameHash(K key, V value, Update`2<K, V> update);
    internal virtual Entry<K, V> RemovedOrNullWithTheSameHash(K key);
    public virtual Entry<K, V> AppendOrUpdateInPlaceOrKeep(S state, ImHashMapEntry`2<K, V> newEntry, UpdaterInPlaceOrKeeper`1<K, V, S> updateOrKeep);
    public virtual Entry<K, V> AppendOrUpdateInPlaceOrKeepByReferenceEquals(S state, ImHashMapEntry`2<K, V> newEntry, UpdaterInPlaceOrKeeper`1<K, V, S> updateOrKeep);
}
public static class JasperFx.Core.Lazy : object {
    public static Lazy`1<T> Of(Func`1<T> valueFactory);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class JasperFx.Core.LightweightCache`2 : object {
    private ImHashMap`2<TKey, TValue> _values;
    private Func`2<TKey, TValue> _onMissing;
    unknown Func`2<TKey, TValue> OnMissing {public set; }
    public int Count { get; }
    public TValue Item { get; public set; }
    public LightweightCache`2(Func`2<TKey, TValue> onMissing);
    public LightweightCache`2(IDictionary`2<TKey, TValue> dictionary, Func`2<TKey, TValue> onMissing);
    public LightweightCache`2(IDictionary`2<TKey, TValue> dictionary);
    public void set_OnMissing(Func`2<TKey, TValue> value);
    public int get_Count();
    public TValue get_Item(TKey key);
    public void set_Item(TKey key, TValue value);
    public IEnumerable`1<TKey> Keys();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IEnumerator`1<TValue> GetEnumerator();
    public void FillDefault(TKey key);
    public void Fill(TKey key, TValue value);
    public bool TryFind(TKey key, TValue& value);
    public bool Contains(TKey key);
    public void Remove(TKey key);
    public void Clear();
    [ObsoleteAttribute("This will be removed in future versions. Favor TryFind()")]
public void WithValue(TKey key, Action`1<TValue> action);
}
public class JasperFx.Core.MapParentStack : object {
    private static int DefaultInitialCapacity;
    private Object[] _items;
    public void Put(object item, int index);
    public object Get(int index);
    private static Object[] Expand(Object[] items);
}
public class JasperFx.Core.MapParentStack`2 : object {
    private static int DefaultInitialCapacity;
    public Entry[] Items;
    public MapParentStack`2(int capacity);
    public void Put(int index, Entry<K, V> entry, ImHashMap`2<K, V> branch);
    private static Entry[] Expand(Entry[] items);
}
public class JasperFx.Core.Opt`1 : ValueType {
    public T Value;
    public bool HasValue;
    public Opt`1(T value);
    public static Opt`1<T> op_Implicit(T value);
    public T OrDefault(T defaultValue);
}
[ExtensionAttribute]
public static class JasperFx.Core.PartitionedHashMap : object {
    public static int PARTITION_COUNT_POWER_OF_TWO;
    public static int PARTITION_HASH_MASK;
    public static ImHashMap`2[] CreateEmpty(int partitionCountOfPowerOfTwo);
    public static ImHashMap`2[] CreateEmpty(int partitionCountOfPowerOfTwo);
    [ExtensionAttribute]
public static V GetValueOrDefault(ImHashMap`2[] parts, int hash, int partHashMask);
    [ExtensionAttribute]
public static V GetValueOrDefault(ImHashMap`2[] parts, int hash, K key, int partHashMask);
    [ExtensionAttribute]
public static V GetValueOrDefault(ImHashMap`2[] parts, K key, int partHashMask);
    [ExtensionAttribute]
public static V GetValueOrDefaultByReferenceEquals(ImHashMap`2[] parts, int hash, K key, int partHashMask);
    [ExtensionAttribute]
public static V GetValueOrDefaultByReferenceEquals(ImHashMap`2[] parts, K key, int partHashMask);
    [ExtensionAttribute]
public static bool TryFind(ImHashMap`2[] parts, int hash, V& value, int partHashMask);
    [ExtensionAttribute]
public static bool TryFind(ImHashMap`2[] parts, int hash, K key, V& value, int partHashMask);
    [ExtensionAttribute]
public static bool TryFind(ImHashMap`2[] parts, K key, V& value, int partHashMask);
    [ExtensionAttribute]
public static bool TryFindByReferenceEquals(ImHashMap`2[] parts, int hash, K key, V& value, int partHashMask);
    [ExtensionAttribute]
public static bool TryFindByReferenceEquals(ImHashMap`2[] parts, K key, V& value, int partHashMask);
    [ExtensionAttribute]
public static void AddOrUpdate(ImHashMap`2[] parts, int hash, V value, int partHashMask);
    private static void RefAddOrUpdatePart(ImHashMap`2& part, int hash, V value);
    [ExtensionAttribute]
public static void AddOrUpdate(ImHashMap`2[] parts, int hash, K key, V value, int partHashMask);
    [ExtensionAttribute]
public static void AddOrUpdate(ImHashMap`2[] parts, K key, V value, int partHashMask);
    private static void RefAddOrUpdatePart(ImHashMap`2& part, int hash, K key, V value);
    [ExtensionAttribute]
public static void AddOrUpdate(ImHashMap`2[] parts, int hash, V value, Update`2<int, V> update, int partHashMask);
    [ExtensionAttribute]
public static void AddOrUpdate(ImHashMap`2[] parts, int hash, K key, V value, Update`2<K, V> update, int partHashMask);
    [ExtensionAttribute]
public static void AddOrUpdate(ImHashMap`2[] parts, K key, V value, Update`2<K, V> update, int partHashMask);
    [ExtensionAttribute]
public static void AddOrKeep(ImHashMap`2[] parts, int hash, V value, int partHashMask);
    private static void RefAddOrKeepPart(ImHashMap`2& part, int hash, V value);
    [ExtensionAttribute]
public static void AddOrKeep(ImHashMap`2[] parts, int hash, K key, V value, int partHashMask);
    private static void RefAddOrKeepPart(ImHashMap`2& part, int hash, K key, V value);
    [ExtensionAttribute]
public static void Update(ImHashMap`2[] parts, int hash, V value, int partHashMask);
    private static void RefUpdatePart(ImHashMap`2& part, int hash, V value);
    [ExtensionAttribute]
public static Enumerable`1<V> Enumerate(ImHashMap`2[] parts);
    [ExtensionAttribute]
public static Enumerable`2<K, V> Enumerate(ImHashMap`2[] parts);
    [ExtensionAttribute]
public static S ForEach(ImHashMap`2[] parts, S state, Action`3<VEntry`1<V>, int, S> handler, MapParentStack parents);
    [ExtensionAttribute]
public static S ForEach(ImHashMap`2[] parts, S state, Action`3<ImHashMapEntry`2<K, V>, int, S> handler, MapParentStack parents);
}
[ExtensionAttribute]
public static class JasperFx.Core.Ref : object {
    public static int RETRY_COUNT_UNTIL_THROW;
    public static Ref`1<T> Of(T value);
    [ExtensionAttribute]
public static Ref`1<T> NewRef(Ref`1<T> original);
    public static T Swap(T& value, Func`2<T, T> getNewValue, int retryCountUntilThrow);
    private static void ThrowRetryCountExceeded(int retryCountExceeded);
    public static T Swap(T& value, A a, Func`3<T, A, T> getNewValue, int retryCountUntilThrow);
    public static T SwapAndGetNewValue(T& value, Func`2<T, T> getNewValue, int retryCountUntilThrow);
    public static T SwapAndGetNewValue(T& value, A a, Func`3<T, A, T> getNewValue, int retryCountUntilThrow);
    public static T Swap(T& value, A a, B b, Func`4<T, A, B, T> getNewValue, int retryCountUntilThrow);
    public static T Swap(T& value, A a, B b, C c, Func`5<T, A, B, C, T> getNewValue, int retryCountUntilThrow);
    public static T Swap(T& value, A a, B b, C c, D d, Func`6<T, A, B, C, D, T> getNewValue, int retryCountUntilThrow);
}
public class JasperFx.Core.Ref`1 : object {
    private T _value;
    public T Value { get; }
    public Ref`1(T initialValue);
    public T get_Value();
    public T Swap(Func`2<T, T> getNewValue);
    public T Swap(A a, Func`3<T, A, T> getNewValue, int retryCountUntilThrow);
    public T Swap(A a, B b, Func`4<T, A, B, T> getNewValue, int retryCountUntilThrow);
    public T SwapAndGetNewValue(Func`2<T, T> getNewValue, int retryCountUntilThrow);
    public T SwapAndGetNewValue(A a, Func`3<T, A, T> getNewValue, int retryCountUntilThrow);
    public T Swap(T newValue);
    public T SetNonAtomic(T newValue);
    public bool TrySwapIfStillCurrent(T currentValue, T newValue);
    public void UnsafeSet(T newValue);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class JasperFx.Core.Reflection.EnumerableTypeExtensions : object {
    private static List`1<Type> _enumerableTypes;
    private static EnumerableTypeExtensions();
    [ExtensionAttribute]
public static bool IsEnumerable(Type type);
    [ExtensionAttribute]
public static Type DetermineElementType(Type serviceType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerStepThroughAttribute]
[DebuggerNonUserCodeAttribute]
public abstract class JasperFx.Core.Reflection.ExpressionVisitorBase : object {
    public virtual Expression Visit(Expression exp);
    protected virtual MemberBinding VisitBinding(MemberBinding binding);
    protected virtual ElementInit VisitElementInitializer(ElementInit initializer);
    protected virtual Expression VisitUnary(UnaryExpression u);
    protected virtual Expression VisitBinary(BinaryExpression b);
    protected virtual Expression VisitTypeIs(TypeBinaryExpression b);
    protected virtual Expression VisitConstant(ConstantExpression c);
    protected virtual Expression VisitConditional(ConditionalExpression c);
    protected virtual Expression VisitParameter(ParameterExpression p);
    protected virtual Expression VisitMemberAccess(MemberExpression m);
    protected virtual Expression VisitMethodCall(MethodCallExpression m);
    protected virtual ReadOnlyCollection`1<Expression> VisitList(ReadOnlyCollection`1<Expression> original);
    protected virtual MemberAssignment VisitMemberAssignment(MemberAssignment assignment);
    protected virtual MemberMemberBinding VisitMemberMemberBinding(MemberMemberBinding binding);
    protected virtual MemberListBinding VisitMemberListBinding(MemberListBinding binding);
    protected virtual IEnumerable`1<MemberBinding> VisitBindingList(ReadOnlyCollection`1<MemberBinding> original);
    protected virtual IEnumerable`1<ElementInit> VisitElementInitializerList(ReadOnlyCollection`1<ElementInit> original);
    protected virtual Expression VisitLambda(LambdaExpression lambda);
    protected virtual NewExpression VisitNew(NewExpression nex);
    protected virtual Expression VisitMemberInit(MemberInitExpression init);
    protected virtual Expression VisitListInit(ListInitExpression init);
    protected virtual Expression VisitNewArray(NewArrayExpression na);
    protected virtual Expression VisitInvocation(InvocationExpression iv);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JasperFx.Core.Reflection.FindMembers : ExpressionVisitor {
    internal static PropertyInfo ArrayLength;
    public IList`1<MemberInfo> Members;
    private static FindMembers();
    [NullableContextAttribute("2")]
public static MemberInfo Member(Expression`1<Func`2<T, object>> expression);
    protected virtual Expression VisitMember(MemberExpression node);
    protected virtual Expression VisitMethodCall(MethodCallExpression node);
    protected sealed virtual Expression VisitUnary(UnaryExpression node);
    public static MemberInfo[] Determine(Expression expression);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class JasperFx.Core.Reflection.FindMethodVisitor : ExpressionVisitorBase {
    [CompilerGeneratedAttribute]
private MethodInfo <Method>k__BackingField;
    public MethodInfo Method { get; private set; }
    [NullableContextAttribute("1")]
public FindMethodVisitor(Expression expression);
    [CompilerGeneratedAttribute]
public MethodInfo get_Method();
    [CompilerGeneratedAttribute]
private void set_Method(MethodInfo value);
    [NullableContextAttribute("1")]
protected virtual Expression VisitMethodCall(MethodCallExpression m);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class JasperFx.Core.Reflection.LambdaBuilder : object {
    public static Func`2<TTarget, TProperty> GetProperty(PropertyInfo property);
    [NullableContextAttribute("2")]
public static Action`2<TTarget, TProperty> SetProperty(PropertyInfo property);
    public static Func`2<TTarget, TField> GetField(FieldInfo field);
    public static Func`2<TTarget, TMember> Getter(MemberInfo member);
    public static Action`2<TTarget, TField> SetField(FieldInfo field);
    [NullableContextAttribute("2")]
public static Action`2<TTarget, TMember> Setter(MemberInfo member);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class JasperFx.Core.Reflection.ReflectionExtensions : object {
    [ExtensionAttribute]
public static bool TryGetAttribute(ICustomAttributeProvider provider, T& att);
    [ExtensionAttribute]
public static T GetAttribute(MemberInfo provider);
    [ExtensionAttribute]
public static T GetAttribute(Assembly provider);
    [ExtensionAttribute]
public static T GetAttribute(Module provider);
    [ExtensionAttribute]
public static T GetAttribute(ParameterInfo provider);
    [ExtensionAttribute]
public static IEnumerable`1<T> GetAllAttributes(Assembly provider);
    [ExtensionAttribute]
public static IEnumerable`1<T> GetAllAttributes(MemberInfo provider);
    [ExtensionAttribute]
public static IEnumerable`1<T> GetAllAttributes(Module provider);
    [ExtensionAttribute]
public static IEnumerable`1<T> GetAllAttributes(ParameterInfo provider);
    [ExtensionAttribute]
public static bool HasAttribute(Assembly provider);
    [ExtensionAttribute]
public static bool HasAttribute(MemberInfo provider);
    [ExtensionAttribute]
public static bool HasAttribute(Module provider);
    [ExtensionAttribute]
public static bool HasAttribute(ParameterInfo provider);
    [ExtensionAttribute]
public static void ForAttribute(Assembly provider, Action`1<T> action);
    [ExtensionAttribute]
public static void ForAttribute(MemberInfo provider, Action`1<T> action);
    [ExtensionAttribute]
public static void ForAttribute(Module provider, Action`1<T> action);
    [ExtensionAttribute]
public static void ForAttribute(ParameterInfo provider, Action`1<T> action);
    [ExtensionAttribute]
public static void ForAttribute(Assembly provider, Action`1<T> action, Action elseDo);
    [ExtensionAttribute]
public static void ForAttribute(MemberInfo provider, Action`1<T> action, Action elseDo);
    [ExtensionAttribute]
public static void ForAttribute(Module provider, Action`1<T> action, Action elseDo);
    [ExtensionAttribute]
public static void ForAttribute(ParameterInfo provider, Action`1<T> action, Action elseDo);
    [ExtensionAttribute]
public static bool HasDefaultConstructor(Type t);
    [ExtensionAttribute]
public static bool HasConstructorsWithArguments(Type t);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsAnonymousType(object instance);
    [ExtensionAttribute]
public static string GetPrettyName(Type t);
    [ExtensionAttribute]
public static bool IsAsync(MethodInfo method);
    [ExtensionAttribute]
public static bool CanBeOverridden(MethodInfo method);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class JasperFx.Core.Reflection.ReflectionHelper : object {
    public static bool MeetsSpecialGenericConstraints(Type genericArgType, Type proposedSpecificType);
    public static PropertyInfo GetProperty(Expression`1<Func`2<TModel, object>> expression);
    public static PropertyInfo GetProperty(Expression`1<Func`2<TModel, T>> expression);
    public static PropertyInfo GetProperty(LambdaExpression expression);
    private static MemberExpression getMemberExpression(Expression`1<Func`2<TModel, T>> expression);
    [ExtensionAttribute]
public static MemberExpression GetMemberExpression(LambdaExpression expression, bool enforceMemberExpression);
    public static bool IsMemberExpression(Expression`1<Func`2<T, object>> expression);
    [NullableContextAttribute("2")]
public static bool IsMemberExpression(Expression`1<Func`2<T, U>> expression);
    [NullableContextAttribute("2")]
private static bool TryEvaluateExpression(Expression operation, Object& value);
    [NullableContextAttribute("2")]
public static MethodInfo GetMethod(Expression`1<Func`2<T, object>> expression);
    public static MethodInfo GetMethod(Expression`1<Func`1<object>> expression);
    public static MethodInfo GetMethod(Expression expression);
    [NullableContextAttribute("2")]
public static MethodInfo GetMethod(Expression`1<TDelegate> expression);
    [NullableContextAttribute("2")]
public static MethodInfo GetMethod(Expression`1<Func`2<T, U>> expression);
    [NullableContextAttribute("2")]
public static MethodInfo GetMethod(Expression`1<Func`3<T, U, V>> expression);
    [NullableContextAttribute("2")]
public static MethodInfo GetMethod(Expression`1<Action`1<T>> expression);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class JasperFx.Core.Reflection.TypeExtensions : object {
    private static IList`1<Type> _integerTypes;
    private static Type[] _tupleTypes;
    private static TypeExtensions();
    [ExtensionAttribute]
public static bool IsStatic(Type type);
    [ExtensionAttribute]
public static T As(object target);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsNullableOfT(Type theType);
    [ExtensionAttribute]
public static bool IsNullableOf(Type theType, Type otherType);
    [ExtensionAttribute]
public static bool IsTypeOrNullableOf(Type theType);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool CanBeCastTo(Type type);
    [ExtensionAttribute]
public static bool CanBeCastTo(Type type, Type destinationType);
    [ExtensionAttribute]
public static bool IsInNamespace(Type type, string nameSpace);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsOpenGeneric(Type type);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsGenericEnumerable(Type type);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsConcreteTypeOf(Type pluggedType);
    [ExtensionAttribute]
public static bool ImplementsInterfaceTemplate(Type pluggedType, Type templateType);
    [ExtensionAttribute]
public static bool IsConcreteWithDefaultCtor(Type type);
    [ExtensionAttribute]
public static Type FindInterfaceThatCloses(Type type, Type openType);
    [ExtensionAttribute]
public static Type FindParameterTypeTo(Type type, Type openType);
    [ExtensionAttribute]
public static bool IsNullable(Type type);
    [ExtensionAttribute]
public static bool Closes(Type type, Type openType);
    [ExtensionAttribute]
public static Type GetInnerTypeFromNullable(Type nullableType);
    [ExtensionAttribute]
[ObsoleteAttribute("Favor ShortNameInCode(), this is just a passthrough")]
public static string GetName(Type type);
    [ExtensionAttribute]
[ObsoleteAttribute("Favor FullNameInCode(), this is just a passthrough")]
public static string GetFullName(Type type);
    [ExtensionAttribute]
public static bool IsString(Type type);
    [ExtensionAttribute]
public static bool IsPrimitive(Type type);
    [ExtensionAttribute]
public static bool IsSimple(Type type);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsConcrete(Type type);
    [ExtensionAttribute]
public static bool IsNotConcrete(Type type);
    [ExtensionAttribute]
public static bool IsDateTime(Type typeToCheck);
    [ExtensionAttribute]
public static bool IsBoolean(Type typeToCheck);
    [ExtensionAttribute]
public static string PrettyPrint(Type type);
    [ExtensionAttribute]
public static string PrettyPrint(Type type, Func`2<Type, string> selector);
    [ExtensionAttribute]
public static bool IsNumeric(Type type);
    [ExtensionAttribute]
public static bool IsIntegerBased(Type type);
    [ExtensionAttribute]
public static bool IsFloatingPoint(Type type);
    [ExtensionAttribute]
public static T CloseAndBuildAs(Type openType, Type[] parameterTypes);
    [ExtensionAttribute]
public static T CloseAndBuildAs(Type openType, object ctorArgument, Type[] parameterTypes);
    [ExtensionAttribute]
public static T CloseAndBuildAs(Type openType, object ctorArgument1, object ctorArgument2, Type[] parameterTypes);
    [ExtensionAttribute]
public static bool PropertyMatches(PropertyInfo prop1, PropertyInfo prop2);
    [ExtensionAttribute]
public static T Create(Type type);
    [ExtensionAttribute]
public static object Create(Type type);
    [ExtensionAttribute]
public static Type IsAnEnumerationOf(Type type);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsValueTuple(Type type);
    [ExtensionAttribute]
public static Type GetMemberType(MemberInfo member);
    [ExtensionAttribute]
public static Type GetRawMemberType(MemberInfo member);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class JasperFx.Core.Reflection.TypeNameExtensions : object {
    public static Dictionary`2<Type, string> Aliases;
    private static TypeNameExtensions();
    [ExtensionAttribute]
public static string FullNameInCode(Type type);
    [ExtensionAttribute]
public static string NameInCode(Type type);
    [ExtensionAttribute]
public static string NameInCode(Type type, Type[] genericParameterTypes);
    [ExtensionAttribute]
public static string ShortNameInCode(Type type);
    [ExtensionAttribute]
public static string ToSuffixedTypeName(Type type, string suffix);
}
public class JasperFx.Core.SmallArrayPool`1 : ValueType {
    public static byte MaxArrayLength;
    private static T[][] Arrays;
    private static SmallArrayPool`1();
    public static T[] RentOrNew(int requiredLength);
    public static void Return(T[] arr);
}
public static class JasperFx.Core.St : object {
    public static St`1<A> Of(A a);
    public static St`1<A> Rent(A a);
    public static St`2<A, B> Of(A a, B b);
    public static St`2<A, B> Rent(A a, B b);
}
public class JasperFx.Core.St`1 : object {
    public A a;
    internal static St`1<A> Pooled;
    public void Pool();
    public void Reset();
    public A ResetButGetA();
}
public class JasperFx.Core.St`2 : object {
    public A a;
    public B b;
    internal static St`2<A, B> Pooled;
    public St`2<A, B> Pool();
    public void Reset();
    public A ResetButGetA();
    public B ResetButGetB();
}
public class JasperFx.Core.StackPool`1 : object {
    private Stack<T> _s;
    public T RentOrNull();
    public void Return(T x);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class JasperFx.Core.StreamExtensions : object {
    [ExtensionAttribute]
public static string ReadAllText(Stream stream);
    [ExtensionAttribute]
public static Byte[] ReadAllBytes(Stream stream);
    [ExtensionAttribute]
public static Task`1<string> ReadAllTextAsync(Stream stream);
    [AsyncStateMachineAttribute("JasperFx.Core.StreamExtensions/<ReadAllBytesAsync>d__3")]
[ExtensionAttribute]
public static Task`1<Byte[]> ReadAllBytesAsync(Stream stream);
    [AsyncStateMachineAttribute("JasperFx.Core.StreamExtensions/<ReadBytesAsync>d__4")]
[ExtensionAttribute]
public static Task`1<Byte[]> ReadBytesAsync(Stream stream, long length);
    [AsyncStateMachineAttribute("JasperFx.Core.StreamExtensions/<ReadExpectedBufferAsync>d__5")]
[ExtensionAttribute]
public static Task`1<bool> ReadExpectedBufferAsync(Stream stream, Byte[] expected);
    [ExtensionAttribute]
public static Task SendBufferAsync(Stream stream, Byte[] buffer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class JasperFx.Core.StringExtensions : object {
    [ExtensionAttribute]
public static string Elid(string longString, int length);
    [ExtensionAttribute]
public static string CombineToPath(string path, string root);
    [ExtensionAttribute]
public static void IfNotNull(string target, Action`1<string> continuation);
    [ExtensionAttribute]
public static string ToFullPath(string path);
    [ExtensionAttribute]
public static string ParentDirectory(string path);
    [ExtensionAttribute]
public static string AppendPath(string path, String[] parts);
    [ExtensionAttribute]
public static string PathRelativeTo(string path, string root);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsEmpty(string stringValue);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsNotEmpty(string stringValue);
    [ExtensionAttribute]
public static void IsNotEmpty(string stringValue, Action`1<string> action);
    [ExtensionAttribute]
public static bool ToBool(string stringValue);
    [ExtensionAttribute]
[ObsoleteAttribute("Prefer string interpolation")]
public static string ToFormat(string stringFormat, Object[] args);
    [ExtensionAttribute]
public static bool EqualsIgnoreCase(string thisString, string otherString);
    [ExtensionAttribute]
public static bool StartsWithIgnoreCase(string thisString, string prefix);
    [ExtensionAttribute]
public static bool EndsWithIgnoreCase(string thisString, string suffix);
    [ExtensionAttribute]
public static string Capitalize(string stringValue);
    [ExtensionAttribute]
public static string ConvertCRLFToBreaks(string plainText);
    [ExtensionAttribute]
public static DateTime ToDateTime(string dateTimeValue);
    [ExtensionAttribute]
public static string ToGmtFormattedDate(DateTime date);
    [ExtensionAttribute]
public static String[] ToDelimitedArray(string content);
    [ExtensionAttribute]
public static String[] ToDelimitedArray(string content, char delimiter);
    [ExtensionAttribute]
public static bool IsValidNumber(string number);
    [ExtensionAttribute]
public static bool IsValidNumber(string number, CultureInfo culture);
    [ExtensionAttribute]
public static IList`1<string> getPathParts(string path);
    [IteratorStateMachineAttribute("JasperFx.Core.StringExtensions/<ReadLines>d__24")]
[ExtensionAttribute]
public static IEnumerable`1<string> ReadLines(string text);
    [ExtensionAttribute]
public static void ReadLines(string text, Action`1<string> callback);
    [ExtensionAttribute]
public static string ToHash(string text);
    [ExtensionAttribute]
public static string SplitCamelCase(string str);
    [ExtensionAttribute]
public static string SplitPascalCase(string str);
    [ExtensionAttribute]
public static string ToCamelCase(string s);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static TEnum ToEnum(string text);
    [ExtensionAttribute]
public static string FileEscape(string file);
    [ExtensionAttribute]
public static string ReplaceFirst(string text, string search, string replace);
    [ExtensionAttribute]
public static bool ContainsIgnoreCase(string source, string value);
    [ExtensionAttribute]
public static string Join(String[] values, string separator);
    [ExtensionAttribute]
public static string Join(IEnumerable`1<string> values, string separator);
    [ExtensionAttribute]
public static int GetStableHashCode(string str);
    [ExtensionAttribute]
public static Uri ToUri(string uriString);
    [ExtensionAttribute]
public static int GetDeterministicHashCode(string stringValue);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class JasperFx.Core.TaskExtensions : object {
    [ExtensionAttribute]
public static Task TimeoutAfterAsync(Task task, int millisecondsTimeout);
    [ExtensionAttribute]
public static Task`1<T> TimeoutAfterAsync(Task`1<T> task, int millisecondsTimeout);
    internal static void MarshalTaskResults(Task source, TaskCompletionSource`1<TResult> proxy);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class JasperFx.Core.TimeSpanExtensions : object {
    private static string TIMESPAN_PATTERN;
    [ExtensionAttribute]
public static TimeSpan ToTime(int minutes);
    [ExtensionAttribute]
public static TimeSpan ToTime(string timeString);
    public static TimeSpan GetTimeSpan(string timeString);
    [ExtensionAttribute]
public static TimeSpan Minutes(int number);
    [ExtensionAttribute]
public static TimeSpan Hours(int number);
    [ExtensionAttribute]
public static TimeSpan Days(int number);
    [ExtensionAttribute]
public static TimeSpan Seconds(int number);
    [ExtensionAttribute]
public static TimeSpan Milliseconds(int number);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class JasperFx.Core.TypeScanning.AssemblyFinder : object {
    public static IEnumerable`1<Assembly> FindAssemblies(Action`1<string> logFailure, Func`2<Assembly, bool> filter, bool includeExeFiles);
    public static IEnumerable`1<Assembly> FindAssemblies(Func`2<Assembly, bool> filter, string assemblyPath, Action`1<string> logFailure, bool includeExeFiles);
    [IteratorStateMachineAttribute("JasperFx.Core.TypeScanning.AssemblyFinder/<findAssemblies>d__2")]
private static IEnumerable`1<Assembly> findAssemblies(string assemblyPath, Action`1<string> logFailure, bool includeExeFiles);
    public static IEnumerable`1<Assembly> FindAssemblies(Func`2<Assembly, bool> filter, bool includeExeFiles);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class JasperFx.Core.TypeScanning.AssemblyLoadContextWrapper : object {
    private AssemblyLoadContext _ctx;
    public AssemblyLoadContextWrapper(AssemblyLoadContext ctx);
    public sealed virtual Assembly LoadFromStream(Stream assembly);
    public sealed virtual Assembly LoadFromAssemblyName(AssemblyName assemblyName);
    public sealed virtual Assembly LoadFromAssemblyPath(string assemblyName);
}
public static class JasperFx.Core.TypeScanning.AssemblyLoader : object {
    [NullableContextAttribute("1")]
public static Assembly ByName(string assemblyName);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class JasperFx.Core.TypeScanning.AssemblyScanRecord : object {
    public Exception LoadException;
    public string Name;
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JasperFx.Core.TypeScanning.AssemblyShelf : object {
    public IList`1<Type> Abstracts;
    public IList`1<Type> Concretes;
    public IList`1<Type> Interfaces;
    [IteratorStateMachineAttribute("JasperFx.Core.TypeScanning.AssemblyShelf/<SelectLists>d__3")]
public IEnumerable`1<IList`1<Type>> SelectLists(TypeClassification classification);
    public IEnumerable`1<Type> AllTypes();
    public void Add(Type type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JasperFx.Core.TypeScanning.AssemblyTypes : object {
    public AssemblyShelf ClosedTypes;
    public AssemblyShelf OpenTypes;
    [CompilerGeneratedAttribute]
private AssemblyScanRecord <Record>k__BackingField;
    public AssemblyScanRecord Record { get; }
    public AssemblyTypes(Assembly assembly);
    public AssemblyTypes(string name, Func`1<IEnumerable`1<Type>> typeSource);
    [CompilerGeneratedAttribute]
public AssemblyScanRecord get_Record();
    public IEnumerable`1<Type> FindTypes(TypeClassification classification);
    private IEnumerable`1<Type> allTypes(IList`1[] shelves);
    private IEnumerable`1<IList`1<Type>> selectGroups(TypeClassification classification);
    [IteratorStateMachineAttribute("JasperFx.Core.TypeScanning.AssemblyTypes/<selectShelves>d__10")]
private IEnumerable`1<AssemblyShelf> selectShelves(TypeClassification classification);
}
internal static class JasperFx.Core.TypeScanning.BaselineAssemblyContext : object {
    [NullableAttribute("1")]
public static IJasperFxAssemblyLoadContext Loader;
    private static BaselineAssemblyContext();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JasperFx.Core.TypeScanning.CallingAssembly : object {
    private static String[] _prefixesToIgnore;
    private static IList`1<string> _misses;
    private static CallingAssembly();
    private static string GetStackTraceInEnglish();
    [NullableContextAttribute("2")]
public static Assembly Find();
    [NullableContextAttribute("2")]
private static bool isSystemAssembly(Assembly assembly);
    private static bool isSystemAssembly(string assemblyName);
    private static Assembly findAssembly(string stacktraceLine);
    public static Assembly DetermineApplicationAssembly(object registry);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JasperFx.Core.TypeScanning.CanCastToFilter : object {
    private Type _baseType;
    public string Description { get; }
    public CanCastToFilter(Type baseType);
    public sealed virtual bool Matches(Type type);
    public sealed virtual string get_Description();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class JasperFx.Core.TypeScanning.CompositeTypeFilter : CompositeFilter`1<Type> {
    public string Description { get; }
    [NullableContextAttribute("0")]
public void WithAttribute();
    public void WithNameSuffix(string suffix);
    public void InNamespace(string ns);
    [NullableContextAttribute("2")]
public void Implements();
    public void Implements(Type type);
    public void IsPublic();
    public bool Matches(Type type);
    public string get_Description();
    public void IsNotPublic();
    public void IsStatic();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JasperFx.Core.TypeScanning.HasAttributeFilter`1 : object {
    public string Description { get; }
    public sealed virtual bool Matches(Type type);
    public sealed virtual string get_Description();
}
[AttributeUsageAttribute("1")]
public class JasperFx.Core.TypeScanning.IgnoreAssemblyAttribute : Attribute {
}
[NullableContextAttribute("1")]
internal interface JasperFx.Core.TypeScanning.IJasperFxAssemblyLoadContext {
    public abstract virtual Assembly LoadFromStream(Stream assembly);
    public abstract virtual Assembly LoadFromAssemblyName(AssemblyName assemblyName);
    public abstract virtual Assembly LoadFromAssemblyPath(string assemblyName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JasperFx.Core.TypeScanning.NamespaceFilter : object {
    private string _ns;
    public string Description { get; }
    public NamespaceFilter(string namespace);
    public sealed virtual bool Matches(Type type);
    public sealed virtual string get_Description();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JasperFx.Core.TypeScanning.NameSuffixFilter : object {
    private string _suffix;
    public string Description { get; }
    public NameSuffixFilter(string suffix);
    public sealed virtual bool Matches(Type type);
    public sealed virtual string get_Description();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class JasperFx.Core.TypeScanning.TopologicalSortExtensions : object {
    [ExtensionAttribute]
internal static int GetFirstIndex(IEnumerable`1<T> enumerable, Func`2<T, bool> condition);
    [ExtensionAttribute]
internal static IEnumerable`1<T> TopologicalSort(IEnumerable`1<T> source, Func`2<T, IEnumerable`1<T>> getDependencies, bool throwOnCycle);
    [ExtensionAttribute]
internal static IEnumerable`1<T> TopologicalSort(IEnumerable`1<T> source, Func`2<T, IEnumerator`1<T>> getDependencies, bool throwOnCycle);
    private static void Visit(T root, ISet`1<T> visited, ISet`1<T> visiting, ICollection`1<T> sorted, Stack`1<ValueTuple`2<T, IEnumerator`1<T>>> stack, Func`2<T, IEnumerator`1<T>> getDependencies, bool throwOnCycle);
}
[FlagsAttribute]
public enum JasperFx.Core.TypeScanning.TypeClassification : Enum {
    public short value__;
    public static TypeClassification All;
    public static TypeClassification Open;
    public static TypeClassification Closed;
    public static TypeClassification Interfaces;
    public static TypeClassification Abstracts;
    public static TypeClassification Concretes;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JasperFx.Core.TypeScanning.TypeQuery : object {
    private TypeClassification _classification;
    [CompilerGeneratedAttribute]
private CompositeTypeFilter <Includes>k__BackingField;
    [CompilerGeneratedAttribute]
private CompositeTypeFilter <Excludes>k__BackingField;
    public CompositeTypeFilter Includes { get; }
    public CompositeTypeFilter Excludes { get; }
    public TypeQuery(TypeClassification classification);
    public TypeQuery(TypeClassification classification, Func`2<Type, bool> filter);
    [CompilerGeneratedAttribute]
public CompositeTypeFilter get_Includes();
    [CompilerGeneratedAttribute]
public CompositeTypeFilter get_Excludes();
    public IEnumerable`1<Type> Find(AssemblyTypes assembly);
    public IEnumerable`1<Type> Find(IEnumerable`1<Assembly> assemblies);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <Find>b__9_0(Type type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class JasperFx.Core.TypeScanning.TypeRepository : object {
    private static ImHashMap`2<Assembly, AssemblyTypes> _assemblies;
    private static TypeRepository();
    public static void ClearAll();
    public static void AssertNoTypeScanningFailures();
    public static IReadOnlyList`1<AssemblyTypes> FailedAssemblies();
    public static AssemblyTypes ForAssembly(Assembly assembly);
    public static TypeSet FindTypes(IEnumerable`1<Assembly> assemblies, Func`2<Type, bool> filter);
    public static IEnumerable`1<Type> FindTypes(IEnumerable`1<Assembly> assemblies, TypeClassification classification, Func`2<Type, bool> filter);
    public static IEnumerable`1<Type> FindTypes(Assembly assembly, TypeClassification classification, Func`2<Type, bool> filter);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JasperFx.Core.TypeScanning.TypeSet : object {
    private IEnumerable`1<AssemblyTypes> _allTypes;
    private Func`2<Type, bool> _filter;
    public IEnumerable`1<AssemblyScanRecord> Records { get; }
    public TypeSet(IEnumerable`1<AssemblyTypes> allTypes, Func`2<Type, bool> filter);
    public IEnumerable`1<AssemblyScanRecord> get_Records();
    public IEnumerable`1<Type> FindTypes(TypeClassification classification);
    public IEnumerable`1<Type> AllTypes();
}
public class JasperFx.Core.Update`1 : MulticastDelegate {
    public Update`1(object object, IntPtr method);
    public virtual V Invoke(V oldValue, V newValue);
    public virtual IAsyncResult BeginInvoke(V oldValue, V newValue, AsyncCallback callback, object object);
    public virtual V EndInvoke(IAsyncResult result);
}
public class JasperFx.Core.Update`2 : MulticastDelegate {
    public Update`2(object object, IntPtr method);
    public virtual V Invoke(K key, V oldValue, V newValue);
    public virtual IAsyncResult BeginInvoke(K key, V oldValue, V newValue, AsyncCallback callback, object object);
    public virtual V EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class JasperFx.Core.UrlExtensions : object {
    [ExtensionAttribute]
public static string AppendUrl(string url, string part);
    [ExtensionAttribute]
public static string ChildUrl(string url);
    [ExtensionAttribute]
public static string ParentUrl(string url);
    [ExtensionAttribute]
public static string MoveUp(string relativeUrl);
}
public class JasperFx.Core.VEntry`1 : ImHashMapEntry`2<int, V> {
    public int Key { get; }
    public VEntry`1(int hash);
    public VEntry`1(int hash, V value);
    public virtual int get_Key();
    internal virtual StringBuilder ToMermaidNodeItem(StringBuilder s);
    internal virtual ImHashMapEntry`2<int, V> GetOrNullWithTheSameHash(int key);
    internal virtual ImHashMapEntry`2<int, V> GetOrNullWithTheSameHashByReferenceEquals(int key);
    internal virtual V GetValueOrDefaultWithTheSameHashByReferenceEquals(int key);
    internal virtual Entry<int, V> AddOrUpdateWithTheSameHash(ImHashMapEntry`2<int, V> newEntry);
    internal virtual Entry<int, V> AddOrUpdateWithTheSameHashByReferenceEquals(ImHashMapEntry`2<int, V> newEntry);
    internal virtual Entry<int, V> AddOrUpdateWithTheSameHash(ImHashMapEntry`2<int, V> newEntry, Update`2<int, V> update);
    internal virtual Entry<int, V> AddOrUpdateWithTheSameHashByReferenceEquals(ImHashMapEntry`2<int, V> newEntry, Update`2<int, V> update);
    internal virtual ImHashMap`2<int, V> GetMapOrReplaceWithEntry(ImHashMap`2<int, V> oldMap, ImHashMapEntry`2<int, V> newEntry);
    internal virtual ImHashMap`2<int, V> AddOrKeepWithTheSameHash(ImHashMap`2<int, V> oldMap, ImHashMapEntry`2<int, V> newEntry);
    internal virtual Entry<int, V> UpdatedOrNullWithTheSameHash(ImHashMapEntry`2<int, V> newEntry);
    internal virtual Entry<int, V> UpdatedOrNullWithTheSameHash(int key, V value, Update`2<int, V> update);
    internal virtual Entry<int, V> RemovedOrNullWithTheSameHash(int key);
    public virtual Entry<int, V> AppendOrUpdateInPlaceOrKeep(S state, ImHashMapEntry`2<int, V> newEntry, UpdaterInPlaceOrKeeper`1<int, V, S> updateOrKeep);
    public virtual Entry<int, V> AppendOrUpdateInPlaceOrKeepByReferenceEquals(S state, ImHashMapEntry`2<int, V> newEntry, UpdaterInPlaceOrKeeper`1<int, V, S> updateOrKeep);
}
[AttributeUsageAttribute("1028")]
public class Lamar.LamarIgnoreAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
