internal static class JetBrains.Common.BuildScript.CommonNativeFiles : object {
    [NotNullAttribute]
public static RelativePath GetEtwApi(JetRuntimeId runtimeId, bool debug);
    [NotNullAttribute]
public static RelativePath GetMemoryMappedStorage(JetRuntimeId runtimeId, bool debug);
    [NotNullAttribute]
public static RelativePath GetMemoryMappedStorageApi(JetRuntimeId runtimeId, bool debug);
    [NotNullAttribute]
public static RelativePath GetTests(JetRuntimeId runtimeId, bool debug);
}
internal static class JetBrains.Common.BuildScript.CommonNativeNames : object {
    public static string GetEtwApi(JetPlatform platform);
    public static string GetMemoryMappedStorage(JetPlatform platform);
    public static string GetMemoryMappedStorageApi(JetPlatform platform);
    public static string GetMemoryMappedStorageApiV10(JetPlatform platform);
    public static string GetTests(JetPlatform platform);
}
internal static class JetBrains.Common.BuildScript.CommonNativeTargets : object {
    private static string Prefix;
    public static string EtwApi;
    public static string MemoryMappedStorage;
    public static string MemoryMappedStorageApi;
    public static string Tests;
    [ObsoleteAttribute("Use MemoryMappedStorageApi. This version is no longer supported and is distributed as a .nuget package.")]
public static string MemoryMappedStorageApiV10;
}
public static class JetBrains.Common.MemoryMappedStorage.BoundsCheckDelegates : object {
    public static BoundsCheck TakeMaxBoundsCheck();
    public static BoundsCheck TakeBackMaxBoundsCheck();
}
public static class JetBrains.Common.MemoryMappedStorage.Cache.CacheSectionBuilder : object {
    public static ICacheProviderContainer`1<IAccessor`1<IReadonlyMemoryMappedSection>> Create(DataPipeLifetime lifetime, IMemoryMappedStorageManager storageManager, IDataProvider`1<ICacheStorageManager> cacheStorageManager, UInt32 type, IDataProvider`1<TSource> source, Func`2<TSource, long> sourceVersion, Action`4<Lifetime, TSource, IMemoryMappedSection, IExecutionController> fillSection);
    public static ICacheProviderContainer`1<IAccessor`1<IReadonlyMemoryMappedSection>> Create(DataPipeLifetime lifetime, IMemoryMappedStorageManager storageManager, IDataProvider`1<ICacheStorageManager> cacheStorageManager, UInt32 type, IDataProvider`1<ICacheSource`1<TSource>> source, Action`4<Lifetime, TSource, IMemoryMappedSection, IExecutionController> fillSection, bool removeOldVersionStorageImmediately);
}
public static class JetBrains.Common.MemoryMappedStorage.Cache.CacheStorageBuilder : object {
    public static ICacheProviderContainer`1<IAccessor`1<IReadonlyMemoryMappedStorage>> Create(DataPipeLifetime lifetime, IMemoryMappedStorageManager storageManager, IDataProvider`1<ICacheStorageManager> cacheStorageManager, UInt32 type, IDataProvider`1<ICacheSource`1<TSource>> source, Action`4<Lifetime, TSource, IMemoryMappedStorage, IExecutionController> fillSection, bool removeOldVersionStorageImmediately);
}
public interface JetBrains.Common.MemoryMappedStorage.Cache.ICacheStorageManager {
    [CanBeNullAttribute]
public abstract virtual FileSystemPath FindExistingStorage(UInt32 type, long version);
    public abstract virtual void MoveToStorage(FileSystemPath source, UInt32 type, long version);
    [NotNullAttribute]
public abstract virtual FileSystemPath GenerateTempStoragePath();
    public abstract virtual void ClearType(UInt32 type);
    public abstract virtual void Clear();
    public abstract virtual FileSystemPath GetStorageFolder();
}
internal class JetBrains.Common.MemoryMappedStorage.Cache.Impl.CacheSection`1 : object {
    [CompilerGeneratedAttribute]
private IDataProvider`1<ICacheSource`1<IAccessor`1<IReadonlyMemoryMappedSection>>> <Data>k__BackingField;
    public IDataProvider`1<ICacheSource`1<IAccessor`1<IReadonlyMemoryMappedSection>>> Data { get; }
    internal CacheSection`1(DataPipeLifetime lifetime, IMemoryMappedStorageManager storageManager, Lifetime cacheManagerLifetime, ICacheStorageManager cacheManager, UInt32 type, IDataProvider`1<ICacheSource`1<TSource>> cacheSourceProvider, Action`4<Lifetime, TSource, IMemoryMappedSection, IExecutionController> fillSection, bool removeOldVersionStorageImmediately);
    [CompilerGeneratedAttribute]
public sealed virtual IDataProvider`1<ICacheSource`1<IAccessor`1<IReadonlyMemoryMappedSection>>> get_Data();
}
internal class JetBrains.Common.MemoryMappedStorage.Cache.Impl.CacheStorage`1 : object {
    private static ILogger ourLog;
    [CompilerGeneratedAttribute]
private IDataProvider`1<ICacheSource`1<IAccessor`1<IReadonlyMemoryMappedStorage>>> <Data>k__BackingField;
    public IDataProvider`1<ICacheSource`1<IAccessor`1<IReadonlyMemoryMappedStorage>>> Data { get; }
    internal CacheStorage`1(DataPipeLifetime lifetime, IMemoryMappedStorageManager storageManager, Lifetime cacheManagerLifetime, ICacheStorageManager cacheManager, UInt32 type, IDataProvider`1<ICacheSource`1<TSource>> cacheSourceProvider, Action`4<Lifetime, TSource, IMemoryMappedStorage, IExecutionController> fillStorage, bool removeOldVersionStorageImmediately);
    private static CacheStorage`1();
    [CompilerGeneratedAttribute]
public sealed virtual IDataProvider`1<ICacheSource`1<IAccessor`1<IReadonlyMemoryMappedStorage>>> get_Data();
    private static SequentialLifetimes CreateSequentialOnIntermediateLifetime(Lifetime lifetime);
    private static void TryToDeleteIfExist(FileSystemPath path);
    private static bool TryLockStorage(IMemoryMappedStorageManager storageManager, Lifetime lifetime, FileSystemPath storage);
}
public class JetBrains.Common.MemoryMappedStorage.Cache.Impl.SnapshotCacheStorageManager : object {
    private static string CacheFileDotExtension;
    private FileSystemPath mySnapshotRoot;
    private ILogger myLog;
    public SnapshotCacheStorageManager(FileSystemPath root, Guid snapshotGuid);
    public SnapshotCacheStorageManager(FileSystemPath root, string snapshotGuid);
    public sealed virtual FileSystemPath GetStorageFolder();
    public sealed virtual FileSystemPath FindExistingStorage(UInt32 type, long version);
    private FileSystemPath SectionFilePath(UInt32 type, long version);
    [LocalizableAttribute("False")]
private string FileNamePattern(string type, string version);
    public sealed virtual void MoveToStorage(FileSystemPath source, UInt32 type, long version);
    public sealed virtual FileSystemPath GenerateTempStoragePath();
    public sealed virtual void ClearType(UInt32 type);
    public sealed virtual void Clear();
    private void Clear(string type, string version);
}
public interface JetBrains.Common.MemoryMappedStorage.IMemoryMappedHeader {
}
public interface JetBrains.Common.MemoryMappedStorage.IMemoryMappedSection {
    [NotNullAttribute]
public abstract virtual IMemoryMappedHeader CreateHeader(Lifetime lifetime, int headerSize);
    [NotNullAttribute]
public abstract virtual IMemoryMappedHeader CreateHeaderWithData(Lifetime lifetime, int headerSize, IntPtr headerDataPtr);
    [CanBeNullAttribute]
public abstract virtual IMemoryMappedHeader LoadHeader(Lifetime lifetime);
    [NotNullAttribute]
public abstract virtual IMemoryMappedSectionData CreateSectionData(Lifetime lifetime, short elementSize, byte segmentAlignmentBit, int preferredRegionPages);
    [CanBeNullAttribute]
public abstract virtual IMemoryMappedSectionData LoadSectionData(Lifetime lifetime);
}
public interface JetBrains.Common.MemoryMappedStorage.IMemoryMappedSectionData {
    public long FreePosition { get; }
    public abstract virtual long get_FreePosition();
    public abstract virtual bool TrySetFreePosition(Int64& expectedFreePosition, int delta);
    public abstract virtual long SetReadyPosition(long readyPosition);
    [NotNullAttribute]
public abstract virtual IMemoryMappedView MapView(Lifetime lifetime, long position, long maxSize);
}
public interface JetBrains.Common.MemoryMappedStorage.IMemoryMappedStorage {
}
[ZoneDefinitionAttribute]
public interface JetBrains.Common.MemoryMappedStorage.IMemoryMappedStorageZone {
}
public interface JetBrains.Common.MemoryMappedStorage.IMemoryMappedView {
    public abstract virtual bool Flush(bool async);
}
internal abstract class JetBrains.Common.MemoryMappedStorage.Impl.BaseMemoryMappedSectionsEnumerator : object {
    private ReadonlyConfig myConfig;
    private IntPtr myChildHandle;
    [CanBeNullAttribute]
private ISectionsEnumeratorCurrent myCurrent;
    private IntPtr myIteratorHandle;
    private IReadonlySectionsEnumeratorCurrent JetBrains.Common.MemoryMappedStorage.IReadonlySectionsEnumerator.Current { get; }
    private ISectionsEnumeratorCurrent JetBrains.Common.MemoryMappedStorage.ISectionsEnumerator.Current { get; }
    protected BaseMemoryMappedSectionsEnumerator(Lifetime lifetime);
    private sealed virtual override IReadonlySectionsEnumeratorCurrent JetBrains.Common.MemoryMappedStorage.IReadonlySectionsEnumerator.get_Current();
    private sealed virtual override ISectionsEnumeratorCurrent JetBrains.Common.MemoryMappedStorage.ISectionsEnumerator.get_Current();
    private sealed virtual override bool JetBrains.Common.MemoryMappedStorage.IReadonlySectionsEnumerator.MoveNext();
    protected abstract virtual void Check();
    protected abstract virtual IntPtr GetFirst(IntPtr& iteratorHandle, UInt32& currentType, UInt32& currentVersion);
    protected abstract virtual IntPtr GetNext(IntPtr iteratorHandle, UInt32& currentType, UInt32& currentVersion);
    [NotNullAttribute]
private IMemoryMappedSection Create(Lifetime lifetime);
    [CompilerGeneratedAttribute]
private void <.ctor>b__4_0();
}
internal static class JetBrains.Common.MemoryMappedStorage.Impl.Interop.DirectorySectionsCollectionInterop : object {
    private static method ourDirectorySectionsFirst;
    private static method ourDirectorySectionsNext;
    private static method ourDirectorySectionsRelease;
    private static DirectorySectionsCollectionInterop();
    public static IntPtr First(IntPtr storageHandle, IntPtr& firstIteratorHandle, UInt32& sectionType, UInt32& sectionVersion);
    public static IntPtr Next(IntPtr sectionHandle, IntPtr iteratorHandle, UInt32& sectionType, UInt32& sectionVersion);
    public static void Release(IntPtr iteratorHandle);
}
public static class JetBrains.Common.MemoryMappedStorage.Impl.Interop.DllInterop : object {
    private static NativeDll ourDll;
    public static method ErrorInfoRelease;
    private static DllInterop();
    public static IntPtr GetFunctionPointer(string methodName);
}
internal static class JetBrains.Common.MemoryMappedStorage.Impl.Interop.ErrorUtils : object {
    internal static void CheckError(IntPtr err);
}
internal static class JetBrains.Common.MemoryMappedStorage.Impl.Interop.HeaderInterop : object {
    private static method ourHeaderRelease;
    private static HeaderInterop();
    public static void Release(IntPtr headerHandle);
}
internal static class JetBrains.Common.MemoryMappedStorage.Impl.Interop.SectionDataInterop : object {
    private static method ourSectionDataFreeOfs;
    private static method ourSectionDataSetFreeOfs;
    private static method ourSectionDataReadyOfs;
    private static method ourSectionDataSetReadyOfs;
    private static method ourSectionDataMapView;
    private static method ourSectionDataRelease;
    private static SectionDataInterop();
    public static ulong GetFreeOffset(IntPtr sectionDataHandle);
    public static bool TrySetFreeOffset(IntPtr sectionDataHandle, UInt64& expected, ulong delta);
    public static ulong GetReadyOffset(IntPtr sectionDataHandle);
    public static ulong SetReadyOffset(IntPtr sectionDataHandle, ulong newReadyOffset);
    public static IntPtr MapView(IntPtr sectionDataHandle, ulong offset, ulong maxSize, IntPtr& mappedPointer, UInt64& position, UInt64& size);
    public static void Release(IntPtr sectionDataHandle);
}
internal static class JetBrains.Common.MemoryMappedStorage.Impl.Interop.SectionInterop : object {
    private static method ourSectionCreateSection;
    private static method ourSectionCreateHeader;
    private static method ourSectionCreateHeaderWithData;
    private static method ourSectionLoadHeader;
    private static method ourSectionCreateData;
    private static method ourSectionLoadData;
    private static method ourSectionRelease;
    private static SectionInterop();
    public static IntPtr CreateSection(IntPtr sectionHandle, UInt32 sectionType, UInt32 sectionVersion);
    public static IntPtr CreateHeader(IntPtr sectionHandle, UInt32 headerSize, IntPtr& headerDataPtr);
    public static IntPtr CreateHeaderWithData(IntPtr sectionHandle, UInt32 headerSize, IntPtr& outHeaderDataPtr, IntPtr headerDataPtr);
    public static IntPtr LoadHeader(IntPtr sectionHandle, IntPtr& headerDataPtr, UInt32& headerSize);
    public static IntPtr CreateData(IntPtr sectionHandle, ushort elementSize, byte segmentAlignmentBit, UInt32 preferredRegionSize);
    public static IntPtr LoadData(IntPtr sectionHandle, bool readOnly, UInt16& elementSize, Byte& segmentAlignmentBit, UInt32& preferredRegionSize);
    public static void Release(IntPtr sectionHandle);
}
internal static class JetBrains.Common.MemoryMappedStorage.Impl.Interop.SectionSectionsCollectionInterop : object {
    private static method ourSectionSectionsFirst;
    private static method ourSectionSectionsNext;
    private static method ourSectionSectionsRelease;
    private static SectionSectionsCollectionInterop();
    public static IntPtr First(IntPtr sectionHandle, IntPtr& firstIteratorHandle, UInt32& sectionType, UInt32& sectionVersion);
    public static IntPtr Next(IntPtr sectionHandle, IntPtr iteratorHandle, UInt32& sectionType, UInt32& sectionVersion);
    public static void Release(IntPtr iteratorHandle);
}
internal static class JetBrains.Common.MemoryMappedStorage.Impl.Interop.StorageInterop : object {
    private static method ourCreateStorage;
    private static method ourOpenStorage;
    private static method ourStorageRelease;
    private static method ourDirectoryCreateSection;
    private static StorageInterop();
    public static IntPtr CreateStorage(IntPtr fileHandle, long startPos);
    public static IntPtr OpenStorage(IntPtr fileHandle, long startPos, bool readOnly);
    public static void Release(IntPtr storageHandle);
    public static IntPtr CreateSection(IntPtr storageHandle, UInt32 sectionType, UInt32 sectionVersion);
}
internal static class JetBrains.Common.MemoryMappedStorage.Impl.Interop.ViewInterop : object {
    private static method ourViewFlush;
    private static method ourViewRelease;
    private static ViewInterop();
    public static bool Flush(IntPtr viewHandle, bool async);
    public static void Release(IntPtr viewHandle);
}
internal class JetBrains.Common.MemoryMappedStorage.Impl.MemoryMappedDirectorySectionsEnumerator : BaseMemoryMappedSectionsEnumerator {
    private IntPtr myStorageHandle;
    public MemoryMappedDirectorySectionsEnumerator(Lifetime lifetime, IntPtr storageHandle);
    protected virtual void Check();
    protected virtual IntPtr GetFirst(IntPtr& iteratorHandle, UInt32& currentType, UInt32& currentVersion);
    protected virtual IntPtr GetNext(IntPtr iteratorHandle, UInt32& currentType, UInt32& currentVersion);
    [CompilerGeneratedAttribute]
private void <.ctor>b__1_0();
}
internal class JetBrains.Common.MemoryMappedStorage.Impl.MemoryMappedHeader : object {
    private IntPtr myHeaderHandle;
    [CompilerGeneratedAttribute]
private IntPtr <DataPtr>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Size>k__BackingField;
    public IntPtr DataPtr { get; }
    public int Size { get; }
    public MemoryMappedHeader(Lifetime lifetime, IntPtr headerHandle, IntPtr headerDataPtr, int headerSize);
    [CompilerGeneratedAttribute]
public sealed virtual IntPtr get_DataPtr();
    [CompilerGeneratedAttribute]
public sealed virtual int get_Size();
    [CompilerGeneratedAttribute]
private void <.ctor>b__7_0();
}
internal class JetBrains.Common.MemoryMappedStorage.Impl.MemoryMappedSection : object {
    private IntPtr mySectionHandle;
    [CompilerGeneratedAttribute]
private int <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Version>k__BackingField;
    public int Type { get; }
    public int Version { get; }
    public MemoryMappedSection(Lifetime lifetime, IntPtr sectionHandle, int type, int version);
    [CompilerGeneratedAttribute]
public sealed virtual int get_Type();
    [CompilerGeneratedAttribute]
public sealed virtual int get_Version();
    public sealed virtual IMemoryMappedSection CreateSection(Lifetime lifetime, int type, int version);
    private sealed virtual override ISectionsEnumerator JetBrains.Common.MemoryMappedStorage.ISectionsContainer.LoadSections(Lifetime lifetime);
    private sealed virtual override IReadonlySectionsEnumerator JetBrains.Common.MemoryMappedStorage.IReadonlySectionsContainer.LoadSections(Lifetime lifetime);
    public sealed virtual IMemoryMappedHeader CreateHeader(Lifetime lifetime, int headerSize);
    public sealed virtual IMemoryMappedHeader CreateHeaderWithData(Lifetime lifetime, int headerSize, IntPtr headerData);
    private IMemoryMappedHeader LoadHeader(Lifetime lifetime);
    private sealed virtual override IReadonlyMemoryMappedHeader JetBrains.Common.MemoryMappedStorage.IReadonlyMemoryMappedSection.LoadHeader(Lifetime lifetime);
    private sealed virtual override IMemoryMappedHeader JetBrains.Common.MemoryMappedStorage.IMemoryMappedSection.LoadHeader(Lifetime lifetime);
    public sealed virtual IMemoryMappedSectionData CreateSectionData(Lifetime lifetime, short elementSize, byte segmentAlignmentBit, int preferredRegionPages);
    private IMemoryMappedSectionData LoadSectionData(Lifetime lifetime, bool readOnly);
    private sealed virtual override IMemoryMappedSectionData JetBrains.Common.MemoryMappedStorage.IMemoryMappedSection.LoadSectionData(Lifetime lifetime);
    private sealed virtual override IReadonlyMemoryMappedSectionData JetBrains.Common.MemoryMappedStorage.IReadonlyMemoryMappedSection.LoadSectionData(Lifetime lifetime);
    [CompilerGeneratedAttribute]
private void <.ctor>b__7_0();
}
internal class JetBrains.Common.MemoryMappedStorage.Impl.MemoryMappedSectionData : object {
    private static ILogger ourLog;
    private IntPtr mySectionDataHandle;
    [CompilerGeneratedAttribute]
private short <ElementSize>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <SegmentAlignmentBit>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PreferredRegionPages>k__BackingField;
    public short ElementSize { get; }
    public byte SegmentAlignmentBit { get; }
    public int PreferredRegionPages { get; }
    public long FreePosition { get; }
    public long ReadyPosition { get; }
    public MemoryMappedSectionData(Lifetime lifetime, IntPtr sectionDataHandle, short elementSize, byte segmentAlignmentBit, int preferredRegionPages);
    private static MemoryMappedSectionData();
    [CompilerGeneratedAttribute]
public sealed virtual short get_ElementSize();
    [CompilerGeneratedAttribute]
public sealed virtual byte get_SegmentAlignmentBit();
    [CompilerGeneratedAttribute]
public sealed virtual int get_PreferredRegionPages();
    public sealed virtual long get_FreePosition();
    public sealed virtual bool TrySetFreePosition(Int64& expectedFreePosition, int delta);
    public sealed virtual long get_ReadyPosition();
    public sealed virtual long SetReadyPosition(long readyPosition);
    private IMemoryMappedView MapView(Lifetime lifetime, long position, long maxSize);
    private sealed virtual override IMemoryMappedView JetBrains.Common.MemoryMappedStorage.IMemoryMappedSectionData.MapView(Lifetime lifetime, long position, long maxSize);
    private sealed virtual override IReadonlyMemoryMappedView JetBrains.Common.MemoryMappedStorage.IReadonlyMemoryMappedSectionData.MapView(Lifetime lifetime, long position, long maxSize);
    [CompilerGeneratedAttribute]
private void <.ctor>b__11_0();
}
internal class JetBrains.Common.MemoryMappedStorage.Impl.MemoryMappedSectionSectionsEnumerator : BaseMemoryMappedSectionsEnumerator {
    private IntPtr mySectionHandle;
    public MemoryMappedSectionSectionsEnumerator(Lifetime lifetime, IntPtr sectionHandle);
    protected virtual void Check();
    protected virtual IntPtr GetFirst(IntPtr& iteratorHandle, UInt32& currentType, UInt32& currentVersion);
    protected virtual IntPtr GetNext(IntPtr iteratorHandle, UInt32& currentType, UInt32& currentVersion);
    [CompilerGeneratedAttribute]
private void <.ctor>b__1_0();
}
internal class JetBrains.Common.MemoryMappedStorage.Impl.MemoryMappedStorage : object {
    private IntPtr myStorageHandle;
    public MemoryMappedStorage(Lifetime lifetime, IntPtr storageHandle, long startPosition);
    public sealed virtual IMemoryMappedSection CreateSection(Lifetime lifetime, int type, int version);
    private sealed virtual override ISectionsEnumerator JetBrains.Common.MemoryMappedStorage.ISectionsContainer.LoadSections(Lifetime lifetime);
    private sealed virtual override IReadonlySectionsEnumerator JetBrains.Common.MemoryMappedStorage.IReadonlySectionsContainer.LoadSections(Lifetime lifetime);
    [CompilerGeneratedAttribute]
private void <.ctor>b__1_0();
}
internal class JetBrains.Common.MemoryMappedStorage.Impl.MemoryMappedView : object {
    private static ILogger ourLog;
    private IntPtr myViewHandle;
    [CompilerGeneratedAttribute]
private IntPtr <MappedPointer>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Position>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Size>k__BackingField;
    public IntPtr MappedPointer { get; }
    public long Position { get; }
    public long Size { get; }
    public MemoryMappedView(Lifetime lifetime, IntPtr viewHandle, IntPtr mappedPointer, long position, long size);
    private static MemoryMappedView();
    [CompilerGeneratedAttribute]
public sealed virtual IntPtr get_MappedPointer();
    [CompilerGeneratedAttribute]
public sealed virtual long get_Position();
    [CompilerGeneratedAttribute]
public sealed virtual long get_Size();
    public sealed virtual bool Flush(bool async);
}
public interface JetBrains.Common.MemoryMappedStorage.IReadonlyMemoryMappedHeader {
    public IntPtr DataPtr { get; }
    public int Size { get; }
    public abstract virtual IntPtr get_DataPtr();
    public abstract virtual int get_Size();
}
public interface JetBrains.Common.MemoryMappedStorage.IReadonlyMemoryMappedSection {
    [CanBeNullAttribute]
public abstract virtual IReadonlyMemoryMappedHeader LoadHeader(Lifetime lifetime);
    [CanBeNullAttribute]
public abstract virtual IReadonlyMemoryMappedSectionData LoadSectionData(Lifetime lifetime);
}
public interface JetBrains.Common.MemoryMappedStorage.IReadonlyMemoryMappedSectionConfig {
    public int Type { get; }
    public int Version { get; }
    public abstract virtual int get_Type();
    public abstract virtual int get_Version();
}
public interface JetBrains.Common.MemoryMappedStorage.IReadonlyMemoryMappedSectionData {
    public long ReadyPosition { get; }
    public abstract virtual long get_ReadyPosition();
    [NotNullAttribute]
public abstract virtual IReadonlyMemoryMappedView MapView(Lifetime lifetime, long position, long maxSize);
}
public interface JetBrains.Common.MemoryMappedStorage.IReadonlyMemoryMappedSectionDataConfig {
    public short ElementSize { get; }
    public byte SegmentAlignmentBit { get; }
    public int PreferredRegionPages { get; }
    public abstract virtual short get_ElementSize();
    public abstract virtual byte get_SegmentAlignmentBit();
    public abstract virtual int get_PreferredRegionPages();
}
public interface JetBrains.Common.MemoryMappedStorage.IReadonlyMemoryMappedStorage {
}
public interface JetBrains.Common.MemoryMappedStorage.IReadonlyMemoryMappedView {
    public IntPtr MappedPointer { get; }
    public long Position { get; }
    public long Size { get; }
    public abstract virtual IntPtr get_MappedPointer();
    public abstract virtual long get_Position();
    public abstract virtual long get_Size();
}
public interface JetBrains.Common.MemoryMappedStorage.IReadonlySectionsContainer {
    [NotNullAttribute]
public abstract virtual IReadonlySectionsEnumerator LoadSections(Lifetime lifetime);
}
public interface JetBrains.Common.MemoryMappedStorage.IReadonlySectionsEnumerator {
    [NotNullAttribute]
public IReadonlySectionsEnumeratorCurrent Current { get; }
    public abstract virtual IReadonlySectionsEnumeratorCurrent get_Current();
    public abstract virtual bool MoveNext();
}
public interface JetBrains.Common.MemoryMappedStorage.IReadonlySectionsEnumeratorCurrent {
    [NotNullAttribute]
public abstract virtual IReadonlyMemoryMappedSection CreateSection(Lifetime lifetime);
}
public interface JetBrains.Common.MemoryMappedStorage.ISectionsContainer {
    [NotNullAttribute]
public abstract virtual IMemoryMappedSection CreateSection(Lifetime lifetime, int type, int version);
    [NotNullAttribute]
public abstract virtual ISectionsEnumerator LoadSections(Lifetime lifetime);
}
public interface JetBrains.Common.MemoryMappedStorage.ISectionsEnumerator {
    [NotNullAttribute]
public ISectionsEnumeratorCurrent Current { get; }
    public abstract virtual ISectionsEnumeratorCurrent get_Current();
}
public interface JetBrains.Common.MemoryMappedStorage.ISectionsEnumeratorCurrent {
    [NotNullAttribute]
public abstract virtual IMemoryMappedSection CreateSection(Lifetime lifetime);
}
public class JetBrains.Common.MemoryMappedStorage.LongMemoryMappedSection : ReadonlyLongMemoryMappedSection {
    private Func`1<ISectionMemory> myMemoryCreator;
    private IList`1<ISectionMemory> myMemories;
    private MappedRange myPreviousRange;
    public LongMemoryMappedSection(IList`1<ISectionMemory> memories, Func`1<ISectionMemory> memoryCreator, bool linearAccessPattern, UInt32 maxSectionSize);
    public sealed virtual IntPtr TakeOrAllocateMax(long offset, UInt32 size, Int64& allocatedOffset, Int32& allocatedSize);
    public sealed virtual IntPtr Allocate(UInt32 size, Int64& allocatedOffset);
    public sealed virtual void SetReadySize(long offset);
    protected void AddSection(ISectionMemory memory);
    [CompilerGeneratedAttribute]
private void <SetReadySize>b__7_0(int index, UInt32 sectionSize);
}
[ExtensionAttribute]
public static class JetBrains.Common.MemoryMappedStorage.LongMemoryMappedSectionExtensions : object {
    [ExtensionAttribute]
public static ILongMemoryMappedSection AsLongSection(IMemoryMappedSection rootSection, Lifetime lifetime, bool linearAccessPattern, ushort elementSize, UInt32 preferredRegionSize, UInt32 maxSectionSize);
    [ExtensionAttribute]
public static IReadonlyLongMemoryMappedSection AsLongSection(IReadonlyMemoryMappedSection rootSection, Lifetime lifetime, bool linearAccessPattern, UInt32 maxSectionSize);
    [ExtensionAttribute]
public static IEnumerable`1<IReadonlyMemoryMappedSection> GetExtensionSections(IReadonlyMemoryMappedSection rootSection);
    [ExtensionAttribute]
public static bool HasExtensionSections(IReadonlyMemoryMappedSection rootSection);
    [ExtensionAttribute]
public static IEnumerable`1<IMemoryMappedSection> GetExtensionSections(IMemoryMappedSection rootSection);
    [ExtensionAttribute]
public static bool HasExtensionSections(IMemoryMappedSection rootSection);
    [ExtensionAttribute]
public static void FixSize(IMemoryMappedSection section, ushort elementSize, UInt32 preferredRegionSize);
}
internal class JetBrains.Common.MemoryMappedStorage.LongSectionStreamReader : object {
    private IReadonlyLongMemoryMappedSection mySection;
    public long Length { get; }
    public LongSectionStreamReader(IReadonlyLongMemoryMappedSection section);
    public sealed virtual IntPtr TakeMax(long offset, Int32& availableItems);
    public sealed virtual IntPtr TakeBackMax(long offset, Int32& availableItems);
    public virtual long get_Length();
}
internal class JetBrains.Common.MemoryMappedStorage.LongSectionStreamWriter : LongSectionStreamReader {
    private ILongMemoryMappedSection mySection;
    public long Length { get; }
    public LongSectionStreamWriter(ILongMemoryMappedSection section);
    public sealed virtual IntPtr TakeOrAllocateMax(long offset, UInt32 size, Int64& allocatedOffset, Int32& allocatedSize);
    public sealed virtual void SetReadySize(long offset);
    public virtual long get_Length();
}
public static class JetBrains.Common.MemoryMappedStorage.MemoryMappedConstants : object {
    public static int DefaultPageSize;
    public static UInt32 DefaultMaxSectionSize;
}
public class JetBrains.Common.MemoryMappedStorage.MemoryMappedMemoryCache : object {
    private IReadonlySectionMemory myMemory;
    private UInt32 myItemSize;
    private IntPtr myBufferAddress;
    private long myMaxIndex;
    private long myMinIndex;
    public MemoryMappedMemoryCache(IReadonlySectionMemory memory, UInt32 itemSize);
    public PtrAndWindow GetPointerAndWindow(UInt32 offset, bool unmapPreviousRange);
    private void ChangeBuffer(UInt32 offset, bool unmapPreviousRange);
    private IntPtr CreatePointer(UInt32 index);
    public void Invalidate();
}
[ExtensionAttribute]
public static class JetBrains.Common.MemoryMappedStorage.MemoryMappedSectionExtensions : object {
    [ExtensionAttribute]
[NotNullAttribute]
private static IStreamReader GetStreamReader(IReadonlyMemoryMappedSection section, Lifetime lifetime, bool linearAccessPattern);
    [ExtensionAttribute]
[NotNullAttribute]
private static IStreamWriter GetStreamWriter(IMemoryMappedSection section, Lifetime lifetime, bool linearAccessPattern);
    [ExtensionAttribute]
[NotNullAttribute]
public static Stream GetStream(IReadonlyMemoryMappedSection section, Lifetime lifetime, bool linearAccessPattern);
    [ExtensionAttribute]
[NotNullAttribute]
public static Stream GetStream(IMemoryMappedSection section, Lifetime lifetime, bool linearAccessPattern);
    [ExtensionAttribute]
[NotNullAttribute]
public static Stream GetStream(IReadonlyLongMemoryMappedSection section);
    [ExtensionAttribute]
[NotNullAttribute]
private static Stream GetStream(ILongMemoryMappedSection section);
    [ExtensionAttribute]
[NotNullAttribute]
public static Stream GetStreamLong(IMemoryMappedSection section, Lifetime lifetime, bool linearAccessPattern);
    [ExtensionAttribute]
[NotNullAttribute]
public static BinaryReader GetReader(IReadonlyMemoryMappedSection memory, Lifetime lifetime, Encoding encoding);
    [ExtensionAttribute]
[NotNullAttribute]
public static BinaryReader GetReader(IReadonlyMemoryMappedSection memory, Lifetime lifetime);
    [ExtensionAttribute]
[NotNullAttribute]
public static BinaryReader GetReader(IReadonlyLongMemoryMappedSection memory, Lifetime lifetime, Encoding encoding);
    [ExtensionAttribute]
[NotNullAttribute]
public static BinaryReader GetReader(IReadonlyLongMemoryMappedSection memory, Lifetime lifetime);
    [ExtensionAttribute]
[NotNullAttribute]
public static BinaryWriter GetWriter(IMemoryMappedSection memory, Lifetime lifetime);
    [ExtensionAttribute]
[NotNullAttribute]
public static BinaryWriter GetWriter(ILongMemoryMappedSection section, Lifetime lifetime);
    [ExtensionAttribute]
[NotNullAttribute]
public static BinaryWriter GetWriterLong(IMemoryMappedSection memory, Lifetime lifetime);
    [ExtensionAttribute]
[NotNullAttribute]
public static IReadonlyStructuredSectionMemory`1<TItem> GetStructuredMemory(IReadonlyMemoryMappedSection section, Lifetime lifetime);
    [ExtensionAttribute]
[NotNullAttribute]
public static IStructuredSectionMemory`1<TItem> GetOrCreateStructuredMemory(IMemoryMappedSection section, Lifetime lifetime);
    [ExtensionAttribute]
public static void SetHeader(IMemoryMappedSection section, THeader header);
    public static int GetStructureSize();
    [ExtensionAttribute]
public static void MarkWrittenAsReady(ISectionMemory memory);
    [ExtensionAttribute]
public static void MarkWrittenAsReady(ILongMemoryMappedSection memory);
    [ExtensionAttribute]
public static long GetSize(IReadonlyMemoryMappedSection section);
    [ExtensionAttribute]
public static long GetSize(IMemoryMappedSection section, ushort elementSize);
    [ExtensionAttribute]
[NotNullAttribute]
public static IReadonlyMemoryMappedSection GetSectionReadonly(IReadonlyMemoryMappedStorage storage, UInt32 sectionType);
}
internal class JetBrains.Common.MemoryMappedStorage.MemoryMappedSectionStream : ReadonlyMemoryMappedSectionStream {
    private IStreamWriter myMemory;
    public bool CanWrite { get; }
    public long Length { get; }
    public MemoryMappedSectionStream(IStreamWriter memory);
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    private IntPtr TakeOrAllocateMax(int size, Int32& allocatedSize);
    public virtual void Write(Byte[] buffer, int offset, int count);
}
[ZoneMarkerAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ShellComponentAttribute]
public class JetBrains.Common.MemoryMappedStorage.MemoryMappedSnapshotManager : object {
    public static int StorageOffset;
    private IMemoryMappedStorageManager myStorageManagerV10;
    private IMemoryMappedStorageManager myStorageManager;
    public sealed virtual IMemoryMappedStorage Create(Lifetime lifetime, FileSystemPath fileName, UInt32 magic);
    public sealed virtual IReadonlyMemoryMappedStorage OpenReadonly(Lifetime lifetime, FileSystemPath file);
}
public static class JetBrains.Common.MemoryMappedStorage.MemoryMappedStorageFactory : object {
    [NotNullAttribute]
public static IMemoryMappedStorage Create(Lifetime lifetime, FileSystemPath storagePath, long startPosition);
    [NotNullAttribute]
public static IMemoryMappedStorage Create(Lifetime lifetime, SafeFileHandle fileHandle, long startPosition);
    [NotNullAttribute]
public static IReadonlyMemoryMappedStorage OpenRead(Lifetime lifetime, FileSystemPath storagePath, long startPosition);
    [NotNullAttribute]
public static IReadonlyMemoryMappedStorage OpenRead(Lifetime lifetime, SafeFileHandle fileHandle, long startPosition);
    [NotNullAttribute]
public static IMemoryMappedStorage OpenReadWrite(Lifetime lifetime, FileSystemPath storagePath, long startPosition);
    [NotNullAttribute]
public static IMemoryMappedStorage OpenReadWrite(Lifetime lifetime, SafeFileHandle fileHandle, long startPosition);
    [NotNullAttribute]
private static SafeFileHandle GetHandle(FileSystemPath fileName, FileMode fileMode, FileAccess fileAccess);
}
[ExtensionAttribute]
public static class JetBrains.Common.MemoryMappedStorage.MemoryMappedStorageManagerExtensions : object {
    [ExtensionAttribute]
public static IMemoryMappedStorage CreateTemporaryStorage(IMemoryMappedStorageManager manager, Lifetime fileLifetime, Lifetime lifetime);
    [ExtensionAttribute]
public static IMemoryMappedStorage CreateTemporaryStorage(IMemoryMappedStorageManager manager, Lifetime lifetime);
}
public static class JetBrains.Common.MemoryMappedStorage.Pin : object {
    public static void Object(object object, Action`2<IntPtr, TClosure> withHandle, TClosure context);
}
[IsReadOnlyAttribute]
public class JetBrains.Common.MemoryMappedStorage.PtrAndWindow : ValueType {
    public IntPtr Pointer;
    public UInt32 AvailableBefore;
    public UInt32 AvailableAfter;
    public PtrAndWindow(IntPtr pointer, UInt32 availableBefore, UInt32 availableAfter);
}
public class JetBrains.Common.MemoryMappedStorage.ReadonlyLongMemoryMappedSection : object {
    protected bool UnmapPreviousRange;
    private IList`1<MemoryMappedMemoryCache> myCaches;
    private IList`1<IReadonlySectionMemory> myMemories;
    protected SectionOverflowArithmetics Arithmetics;
    public ushort ElementSize { get; }
    public long Size { get; }
    public long ReadySize { get; }
    public ReadonlyLongMemoryMappedSection(IEnumerable`1<IReadonlySectionMemory> memories, bool linearAccessPattern, UInt32 maxSectionSize);
    public sealed virtual ushort get_ElementSize();
    public sealed virtual long get_Size();
    public sealed virtual long get_ReadySize();
    public sealed virtual IntPtr TakeMax(long offset, Int32& availableBytes);
    public sealed virtual IntPtr Take(long offset, int size, Int64& takenOffset);
    protected void AddSection(IReadonlySectionMemory memory);
    [CompilerGeneratedAttribute]
private int <.ctor>b__4_2();
    [CompilerGeneratedAttribute]
private UInt32 <.ctor>b__4_3(int index);
}
internal class JetBrains.Common.MemoryMappedStorage.ReadonlyMemoryMappedSectionStream : Stream {
    private IStreamReader myStreamReader;
    protected long CurrentOffset;
    public bool CanWrite { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public ReadonlyMemoryMappedSectionStream(IStreamReader streamReader);
    public virtual bool get_CanWrite();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void Flush();
    private IntPtr TakeMax(int size, Int32& takenSize);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    private long NormalizeOffset(long startPosition, SeekOrigin origin);
    public sealed virtual IntPtr GetBufferFromPosition(long startPosition, SeekOrigin origin, int needBytes, Int32& availableBytes);
    public sealed virtual IntPtr GetBufferEndAtPosition(long endOffset, SeekOrigin origin, int needBytes, Int32& availableBytes);
}
[DefaultMemberAttribute("Item")]
internal class JetBrains.Common.MemoryMappedStorage.ReadonlyStructuredSectionMemory`1 : object {
    protected int ItemSize;
    private MemoryMappedMemoryCache myCache;
    private IReadonlySectionMemory myMemory;
    private TakeBuffer myTakeMax;
    protected BoundsCheck TakeMaxBoundsCheck;
    private TakeBuffer myTakeBackMax;
    private BoundsCheck myTakeBackMaxBoundsCheck;
    private UnmanagedBufferClosure<TItem> myUnmanagedBufferClosure;
    private Nullable`1<int> myCachedReadySize;
    public int Count { get; }
    public bool IsFixedSized { get; }
    public TItem Item { get; }
    public ReadonlyStructuredSectionMemory`1(IReadonlySectionMemory memory);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsFixedSized();
    public sealed virtual TItem GetItem(int index);
    public sealed virtual TItem get_Item(int index);
    public sealed virtual void GetItems(int index, int count, TItem[] buffer, int offset);
    public sealed virtual void GetItemsBack(int index, int count, TItem[] buffer, int offset);
    public sealed virtual void ReleaseTo(int index);
    public sealed virtual IEnumerator`1<TItem> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private void CopyFromMemoryBack(int index, int count, TItem[] buffer, int offsetItems);
    private void CopyFromMemory(int index, int count, TItem[] buffer, int offsetItems);
    public sealed virtual void GetItemsCore(int index, int count, TClosure closure, BoundsCheck boundsCheck, TakeBuffer takeBuffer, ProcessBatch`1<TClosure> processBatch);
    [LocalizableAttribute("False")]
protected static string PrintState(int index, int count, int currentIndex, int remainingCount, int processedCount);
}
internal class JetBrains.Common.MemoryMappedStorage.SectionMemory : object {
    private ISectionData myMemory;
    public UInt32 Size { get; }
    public UInt32 ReadySize { get; }
    public ushort ElementSize { get; }
    public bool IsFixedSized { get; }
    public SectionMemory(ISectionData memory);
    public sealed virtual UInt32 get_Size();
    public sealed virtual UInt32 get_ReadySize();
    public sealed virtual ushort get_ElementSize();
    public sealed virtual bool get_IsFixedSized();
    public sealed virtual IntPtr Take(UInt32 offset, UInt32 size, UInt32& takenOffset);
    public sealed virtual IntPtr TakeMax(UInt32 offset, UInt32 size, UInt32& takenOffset, UInt32& takenSize);
    public sealed virtual IntPtr TakePage(UInt32 offset, UInt32& takenOffset, UInt32& takenSize);
    public sealed virtual IntPtr TakeBackMax(UInt32 offset, UInt32 size, UInt32& takenOffset, UInt32& takenSize);
    public sealed virtual bool ReleaseTo(UInt32 offset);
    public sealed virtual bool ReleaseRange(UInt32 startOffset, UInt32 endOffset);
    public sealed virtual IntPtr Allocate(UInt32 size, UInt32& offset);
    public sealed virtual IntPtr AllocateMax(UInt32 size, UInt32& allocatedSize, UInt32& allocatedOffset);
    public sealed virtual IntPtr TakeOrAllocateMax(UInt32 offset, UInt32 size, UInt32& allocatedOffset, UInt32& allocatedSize);
    public sealed virtual bool SetReadySize(UInt32 value);
    public sealed virtual void FixSize();
}
[ExtensionAttribute]
public static class JetBrains.Common.MemoryMappedStorage.SectionMemoryEx : object {
    [ExtensionAttribute]
public static void Write(ILongMemoryMappedSection section, Byte[] array);
    [ExtensionAttribute]
public static void Write(ILongMemoryMappedSection memory, T structure, Int64& allocatedOffset);
    [ExtensionAttribute]
private static void Write(ILongMemoryMappedSection memory, T structure, int structureSize, Int64& allocatedOffset);
    [ExtensionAttribute]
private static void Write(ILongMemoryMappedSection section, Byte[] array, Int64& allocatedOffset);
}
public class JetBrains.Common.MemoryMappedStorage.SectionOverflowArithmetics : object {
    private Func`2<int, UInt32> mySectionSize;
    private IList`1<UInt32> mySectionSizesCache;
    private Func`1<int> mySectionsCount;
    private UInt32 myMaxSectionSize;
    public SectionOverflowArithmetics(Func`1<int> sectionsCount, Func`2<int, UInt32> sectionSize, bool isSizesFixed, UInt32 maxSectionSize);
    private UInt32 GetCachedSize(int index);
    public UInt32 GetSectionSize(int index);
    public long GetTotalSize();
    public void WithAllMemoryTillOffsetDo(long offset, Action`2<int, UInt32> withIndexAndOffset);
    public KeyValuePair`2<int, UInt32> GetIndexAndOffset(long offset);
    public long SectionOffsetToOffset(int index, UInt32 offset);
    public UInt32 MaxSectionSize();
}
public class JetBrains.Common.MemoryMappedStorage.SectionWithHeaderOffset : object {
    private IMemoryMappedSection mySection;
    private ushort myHeaderOffset;
    public UInt32 Type { get; }
    public UInt32 Version { get; }
    public bool HasHeader { get; }
    public UInt32 HeaderSize { get; }
    public SectionWithHeaderOffset(IMemoryMappedSection section, ushort headerOffset);
    public sealed virtual UInt32 get_Type();
    public sealed virtual UInt32 get_Version();
    public sealed virtual bool get_HasHeader();
    public sealed virtual UInt32 get_HeaderSize();
    public sealed virtual ISectionMemory GetOrCreateMemory(Lifetime lifetime, ushort elementSize, UInt32 preferredRegionSize);
    public sealed virtual IReadOnlyCollection`1<IMemoryMappedSection> GetChildren();
    public sealed virtual IMemoryMappedSection AddChild(UInt32 type, UInt32 version);
    public sealed virtual void CreateHeader(ushort headerSize);
    public sealed virtual void WithHeader(Action`1<IntPtr> action, ushort offset);
    private sealed virtual override IReadOnlyCollection`1<IReadonlyMemoryMappedSection> JetBrains.Common.MemoryMappedStorage.TimelineApi.IReadonlyMemoryMappedSection.GetChildren();
    public sealed virtual IReadonlySectionMemory GetMemory(Lifetime lifetime);
    public sealed virtual THeader GetHeader(ushort offset);
}
internal class JetBrains.Common.MemoryMappedStorage.ShortSectionStreamReader : object {
    private IReadonlySectionMemory myMemory;
    private MemoryMappedMemoryCache myCache;
    private Nullable`1<long> myFixedLength;
    protected bool UnmapPreviousRange;
    public long Length { get; }
    public ShortSectionStreamReader(IReadonlySectionMemory memory, bool linearAccessPattern);
    public sealed virtual IntPtr TakeMax(long offset, Int32& availableItems);
    public sealed virtual IntPtr TakeBackMax(long offset, Int32& availableItems);
    public virtual long get_Length();
}
internal class JetBrains.Common.MemoryMappedStorage.ShortSectionStreamWriter : ShortSectionStreamReader {
    private ISectionMemory myMemory;
    private MappedRange myPreviousRange;
    public long Length { get; }
    public ShortSectionStreamWriter(ISectionMemory memory, bool linearAccessPattern);
    public sealed virtual IntPtr TakeOrAllocateMax(long offset, UInt32 size, Int64& allocatedOffset, Int32& allocatedSize);
    public sealed virtual void SetReadySize(long offset);
    public virtual long get_Length();
}
[DefaultMemberAttribute("Item")]
internal class JetBrains.Common.MemoryMappedStorage.StructuredSectionMemory`1 : ReadonlyStructuredSectionMemory`1<TItem> {
    private ISectionMemory myMemory;
    private UnmanagedBufferClosure<TItem> myUnmanagedBufferClosure;
    private TakeOrAllocBuffer myTakeOrAllocMax;
    public int Capacity { get; }
    public TItem Item { get; public set; }
    public StructuredSectionMemory`1(ISectionMemory memory);
    public sealed virtual int get_Capacity();
    public sealed virtual int AddItem(TItem item);
    public sealed virtual long ExpandToIndex(int index);
    public sealed virtual void SetItem(int index, TItem item);
    public sealed virtual TItem get_Item(int index);
    public sealed virtual void set_Item(int index, TItem value);
    public sealed virtual void SetItems(int index, int count, TItem fillingValue);
    public sealed virtual void SetItems(int index, int count, TItem[] buffer, int offset);
    private void CopyToMemory(int index, int count, TItem[] buffer, int offsetItems);
    private void FillMemory(int index, int count, TItem fillingValue);
    public void SetItemsCore(int index, int count, TClosure closure, BoundsCheck boundsCheck, TakeOrAllocBuffer takeBuffer, ProcessBatch`1<TClosure> processBatch);
    public sealed virtual void FixSize();
    public sealed virtual bool SetReadyTill(int index);
}
[ExtensionAttribute]
public static class JetBrains.Common.MemoryMappedStorage.StructuredSectionMemoryExtensions : object {
    [ExtensionAttribute]
public static void ExpandAndSetItem(IStructuredSectionMemory`1<TItem> memory, int index, TItem value, Nullable`1<TItem> defaultValue);
    [ExtensionAttribute]
public static void MarkWrittenAsReady(IStructuredSectionMemory`1<TItem> memory);
    [ExtensionAttribute]
public static bool TryGetItem(IReadonlyStructuredSectionMemory`1<TItem> memory, int index, TItem& item);
    [ExtensionAttribute]
public static TItem GetItemSafe(IReadonlyStructuredSectionMemory`1<TItem> memory, int index, TItem defaultValue);
    [ExtensionAttribute]
public static TItem[] GetAllItems(IReadonlyStructuredSectionMemory`1<TItem> memory);
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Common.MemoryMappedStorage.Structures.ListBasedDictionary`2 : ReadonlyListBasedDictionary`2<TKey, TValue> {
    private IStructuredSectionMemory`1<byte> myHasValueMemory;
    private IStructuredSectionMemory`1<TValue> myIndexedMemory;
    private IStructuredSectionMemory`1<KeyValuePair`2<TKey, TValue>> myKeyValueMemory;
    public TValue Item { get; public set; }
    public ListBasedDictionary`2(Lifetime lifetime, IMemoryMappedStorage storage, UInt32 type, Func`2<TKey, int> keyToIndex, Predicate`1<TKey> keyIsIndex, IEqualityComparer`1<TKey> keyComparer);
    public static IStructuredSectionMemory`1<KeyValuePair`2<TKey, TValue>> KeyValueMemory(Lifetime lifetime, IMemoryMappedStorage storage, UInt32 type);
    public static IStructuredSectionMemory`1<byte> HasValueMemory(Lifetime lifetime, IMemoryMappedStorage storage, UInt32 type);
    public static IStructuredSectionMemory`1<TValue> IndexedMemory(Lifetime lifetime, IMemoryMappedStorage storage, UInt32 type);
    private static IStructuredSectionMemory`1<KeyValuePair`2<TKey, TValue>> KeyValueMemory(Lifetime lifetime, IMemoryMappedSection section);
    private static IStructuredSectionMemory`1<byte> HasValueMemory(Lifetime lifetime, IMemoryMappedSection section);
    private static IStructuredSectionMemory`1<TValue> IndexedMemory(Lifetime lifetime, IMemoryMappedSection section);
    private static IMemoryMappedSection IndexedSection(IMemoryMappedStorage storage, UInt32 type);
    private static IMemoryMappedSection KeyValueSection(IMemoryMappedStorage storage, UInt32 type);
    private static IMemoryMappedSection HasValueSection(IMemoryMappedStorage storage, UInt32 type);
    private void AddImpl(TKey key, TValue value, bool throwOnRewrite);
    public TValue get_Item(TKey key);
    public void set_Item(TKey key, TValue value);
    public void Add(TKey key, TValue value);
    [CompilerGeneratedAttribute]
private void <.ctor>b__3_0();
}
public static class JetBrains.Common.MemoryMappedStorage.Structures.OneToMany : object {
    private static ConditionalLog ourLog;
    private static OneToMany();
    public static void Write(IMemoryMappedStorage storage, UInt32 type, IEnumerable`1<KeyValuePair`2<TKey, IEnumerable`1<TValue>>> map, Func`2<TKey, int> keyToIndex, Action`1<IMemoryMappedSection> headersAction);
    public static void Write(IMemoryMappedStorage storage, UInt32 type, IEnumerable`1<KeyValuePair`2<TKey, IEnumerable`1<TValue>>> map, Func`3<Lifetime, TKey, int> keyToIndex, Action`1<IMemoryMappedSection> headersAction);
    public static OneToManyReader`2<TKey, TValue> Read(Lifetime lifetime, IReadonlyMemoryMappedStorage storage, UInt32 type, Func`2<TKey, Nullable`1<int>> keyToIndex);
    public static OneToManyReader`2<TKey, TValue> Read(Lifetime lifetime, IReadonlyMemoryMappedStorage storage, UInt32 type, Func`2<IReadonlyMemoryMappedSection, Func`2<TKey, Nullable`1<int>>> createKeyToIndex);
}
public class JetBrains.Common.MemoryMappedStorage.Structures.OneToManyReader`2 : object {
    private IReadonlyStructuredSectionMemory`1<OffsetAndCount> myKeys;
    private IReadonlyStructuredSectionMemory`1<TValue> myValues;
    private Func`2<TKey, Nullable`1<int>> myKeyToIndex;
    internal OneToManyReader`2(IReadonlyStructuredSectionMemory`1<OffsetAndCount> keys, IReadonlyStructuredSectionMemory`1<TValue> values, Func`2<TKey, Nullable`1<int>> keyToIndex);
    [IteratorStateMachineAttribute("JetBrains.Common.MemoryMappedStorage.Structures.OneToManyReader`2/<GetValuesSafe>d__5")]
public IEnumerable`1<TValue> GetValuesSafe(TKey key);
    public int GetValuesBufferedSafe(TKey key, ReadBuffered<TKey, TValue> readAction);
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Common.MemoryMappedStorage.Structures.ReadonlyListBasedDictionary`2 : object {
    protected Func`2<TKey, int> KeyToIndex;
    protected Predicate`1<TKey> KeyIsIndex;
    private IEqualityComparer`1<TKey> myKeyComparer;
    private IReadonlyStructuredSectionMemory`1<byte> myHasValueMemory;
    private IReadonlyStructuredSectionMemory`1<TValue> myIndexedMemory;
    private IReadonlyStructuredSectionMemory`1<KeyValuePair`2<TKey, TValue>> myKeyValueMemory;
    public TValue Item { get; }
    public ReadonlyListBasedDictionary`2(Lifetime lifetime, IReadonlyMemoryMappedStorage storage, UInt32 type, Func`2<TKey, int> keyToIndex, Predicate`1<TKey> keyIsIndex, IEqualityComparer`1<TKey> keyComparer);
    protected ReadonlyListBasedDictionary`2(IReadonlyStructuredSectionMemory`1<TValue> indexedMemory, IReadonlyStructuredSectionMemory`1<byte> hasValueMemory, IReadonlyStructuredSectionMemory`1<KeyValuePair`2<TKey, TValue>> keyValueMemory, Func`2<TKey, int> keyToIndex, Predicate`1<TKey> keyIsIndex, IEqualityComparer`1<TKey> keyComparer);
    private static IReadonlyMemoryMappedSection KeyValueSection(IReadonlyMemoryMappedStorage storage, UInt32 type);
    private static IReadonlyMemoryMappedSection HasValueSection(IReadonlyMemoryMappedStorage storage, UInt32 type);
    private static IReadonlyMemoryMappedSection IndexedSection(IReadonlyMemoryMappedStorage storage, UInt32 type);
    private static IReadonlyStructuredSectionMemory`1<KeyValuePair`2<TKey, TValue>> KeyValueMemory(Lifetime lifetime, IReadonlyMemoryMappedSection keyValueSection);
    private static IReadonlyStructuredSectionMemory`1<TValue> IndexedMemory(Lifetime lifetime, IReadonlyMemoryMappedSection indexedSection);
    private static IReadonlyStructuredSectionMemory`1<byte> HasValueMemory(Lifetime lifetime, IReadonlyMemoryMappedSection indexedSection);
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    [IteratorStateMachineAttribute("JetBrains.Common.MemoryMappedStorage.Structures.ReadonlyListBasedDictionary`2/<GetEntries>d__17")]
public IEnumerable`1<KeyValuePair`2<TKey, TValue>> GetEntries(Func`2<int, TKey> indexToKey);
}
public static class JetBrains.Common.MemoryMappedStorage.TakeBufferDelegates : object {
    public static TakeBuffer TakeMax();
    public static TakeOrAllocBuffer TakeOrAllocMax();
    public static TakeBuffer TakeBackMax();
}
public class JetBrains.Common.MemoryMappedStorage.TimelineApi.BoundsCheck : MulticastDelegate {
    public BoundsCheck(object object, IntPtr method);
    public virtual void Invoke(int index, int count, UInt32 readySize);
    public virtual IAsyncResult BeginInvoke(int index, int count, UInt32 readySize, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public interface JetBrains.Common.MemoryMappedStorage.TimelineApi.ILongMemoryMappedSection {
    public abstract virtual IntPtr TakeOrAllocateMax(long offset, UInt32 size, Int64& allocatedOffset, Int32& allocatedSize);
    public abstract virtual IntPtr Allocate(UInt32 size, Int64& allocatedOffset);
    public abstract virtual void SetReadySize(long offset);
}
public interface JetBrains.Common.MemoryMappedStorage.TimelineApi.IMemoryMappedSection {
    public abstract virtual ISectionMemory GetOrCreateMemory(Lifetime lifetime, ushort elementSize, UInt32 preferredRegionSize);
    public abstract virtual IReadOnlyCollection`1<IMemoryMappedSection> GetChildren();
    public abstract virtual IMemoryMappedSection AddChild(UInt32 type, UInt32 version);
    public abstract virtual void CreateHeader(ushort headerSize);
}
public interface JetBrains.Common.MemoryMappedStorage.TimelineApi.IMemoryMappedSnapshotManager {
    public abstract virtual IMemoryMappedStorage Create(Lifetime lifetime, FileSystemPath file, UInt32 magic);
    public abstract virtual IReadonlyMemoryMappedStorage OpenReadonly(Lifetime lifetime, FileSystemPath file);
}
public interface JetBrains.Common.MemoryMappedStorage.TimelineApi.IMemoryMappedStorage {
    public IReadOnlyCollection`1<IMemoryMappedSection> Sections { get; }
    public abstract virtual IReadOnlyCollection`1<IMemoryMappedSection> get_Sections();
    public abstract virtual IMemoryMappedSection AddChild(UInt32 type, UInt32 version);
}
public interface JetBrains.Common.MemoryMappedStorage.TimelineApi.IMemoryMappedStorageManager {
    public abstract virtual IMemoryMappedStorage CreateAndOpen(Lifetime lifetime, FileSystemPath file, ulong offset);
    public abstract virtual IMemoryMappedStorage CreateAndOpen(Lifetime lifetime, IntPtr handle, FileSystemPath path, ulong offset);
    public abstract virtual IMemoryMappedStorage Open(Lifetime lifetime, FileSystemPath file, ulong offset);
    public abstract virtual IMemoryMappedStorage Open(Lifetime lifetime, IntPtr handle, FileSystemPath file, ulong offset);
    public abstract virtual IReadonlyMemoryMappedStorage OpenReadonly(Lifetime lifetime, FileSystemPath file, ulong offset);
    public abstract virtual IReadonlyMemoryMappedStorage OpenReadonly(Lifetime lifetime, IntPtr handle, FileSystemPath file, ulong offset);
}
public interface JetBrains.Common.MemoryMappedStorage.TimelineApi.IReadonlyLongMemoryMappedSection {
    public long Size { get; }
    public long ReadySize { get; }
    public ushort ElementSize { get; }
    public abstract virtual long get_Size();
    public abstract virtual long get_ReadySize();
    public abstract virtual ushort get_ElementSize();
    public abstract virtual IntPtr TakeMax(long offset, Int32& takenSize);
    public abstract virtual IntPtr Take(long offset, int size, Int64& takenOffset);
}
public interface JetBrains.Common.MemoryMappedStorage.TimelineApi.IReadonlyMemoryMappedSection {
    public UInt32 Type { get; }
    public UInt32 Version { get; }
    public bool HasHeader { get; }
    public UInt32 HeaderSize { get; }
    public abstract virtual UInt32 get_Type();
    public abstract virtual UInt32 get_Version();
    public abstract virtual bool get_HasHeader();
    public abstract virtual UInt32 get_HeaderSize();
    public abstract virtual IReadOnlyCollection`1<IReadonlyMemoryMappedSection> GetChildren();
    public abstract virtual IReadonlySectionMemory GetMemory(Lifetime lifetime);
    public abstract virtual THeader GetHeader(ushort offset);
    public abstract virtual void WithHeader(Action`1<IntPtr> action, ushort offset);
}
public interface JetBrains.Common.MemoryMappedStorage.TimelineApi.IReadonlyMemoryMappedStorage {
    [CanBeNullAttribute]
public FileSystemPath IndexFile { get; }
    public IReadOnlyCollection`1<IReadonlyMemoryMappedSection> Sections { get; }
    public abstract virtual FileSystemPath get_IndexFile();
    public abstract virtual IReadOnlyCollection`1<IReadonlyMemoryMappedSection> get_Sections();
}
public interface JetBrains.Common.MemoryMappedStorage.TimelineApi.IReadonlySectionMemory {
    public UInt32 Size { get; }
    public UInt32 ReadySize { get; }
    public ushort ElementSize { get; }
    public bool IsFixedSized { get; }
    public abstract virtual UInt32 get_Size();
    public abstract virtual UInt32 get_ReadySize();
    public abstract virtual ushort get_ElementSize();
    public abstract virtual bool get_IsFixedSized();
    public abstract virtual IntPtr Take(UInt32 offset, UInt32 size, UInt32& takenOffset);
    public abstract virtual IntPtr TakeMax(UInt32 offset, UInt32 size, UInt32& takenOffset, UInt32& takenSize);
    public abstract virtual IntPtr TakePage(UInt32 offset, UInt32& takenOffset, UInt32& takenSize);
    public abstract virtual IntPtr TakeBackMax(UInt32 offset, UInt32 size, UInt32& takenOffset, UInt32& takenSize);
    public abstract virtual bool ReleaseTo(UInt32 offset);
    public abstract virtual bool ReleaseRange(UInt32 startOffset, UInt32 endOffset);
}
public interface JetBrains.Common.MemoryMappedStorage.TimelineApi.IReadonlyStructuredSectionMemory`1 {
    public bool IsFixedSized { get; }
    public abstract virtual bool get_IsFixedSized();
    public abstract virtual TItem GetItem(int index);
    public abstract virtual void GetItems(int index, int count, TItem[] buffer, int offset);
    public abstract virtual void GetItemsBack(int index, int count, TItem[] buffer, int offset);
    public abstract virtual void ReleaseTo(int index);
}
public interface JetBrains.Common.MemoryMappedStorage.TimelineApi.IReadonlyStructuredSectionMemoryLowLevel {
    public abstract virtual void GetItemsCore(int index, int count, TClosure closure, BoundsCheck boundsCheck, TakeBuffer takeBuffer, ProcessBatch`1<TClosure> processBatch);
}
public interface JetBrains.Common.MemoryMappedStorage.TimelineApi.ISectionData {
    public bool IsFixedSized { get; }
    public UInt32 Size { get; }
    public UInt32 ReadySize { get; }
    public ushort ElementSize { get; }
    public byte AlignmentBit { get; }
    public abstract virtual bool get_IsFixedSized();
    public abstract virtual void FixSize();
    public abstract virtual IntPtr Alloc(UInt32 count, UInt32& offset);
    public abstract virtual IntPtr AllocMax(UInt32& count, UInt32& offset);
    public abstract virtual IntPtr Take(UInt32& offset, UInt32 count);
    public abstract virtual IntPtr TakeMax(UInt32& offset, UInt32& count);
    public abstract virtual IntPtr TakeAllocMax(UInt32& offset, UInt32& count);
    public abstract virtual IntPtr TakeBackMax(UInt32& offset, UInt32& count);
    public abstract virtual IntPtr TakePage(UInt32& offset, UInt32& count);
    public abstract virtual UInt32 get_Size();
    public abstract virtual UInt32 get_ReadySize();
    public abstract virtual bool SetReady(UInt32 offset);
    public abstract virtual bool UnmapTo(UInt32 offset);
    public abstract virtual bool UnmapRange(UInt32 start, UInt32 end);
    public abstract virtual ushort get_ElementSize();
    public abstract virtual byte get_AlignmentBit();
}
public interface JetBrains.Common.MemoryMappedStorage.TimelineApi.ISectionMemory {
    public abstract virtual IntPtr Allocate(UInt32 size, UInt32& allocatedOffset);
    public abstract virtual IntPtr AllocateMax(UInt32 size, UInt32& allocatedSize, UInt32& allocatedOffset);
    public abstract virtual IntPtr TakeOrAllocateMax(UInt32 offset, UInt32 size, UInt32& allocatedOffset, UInt32& allocatedSize);
    public abstract virtual bool SetReadySize(UInt32 value);
    public abstract virtual void FixSize();
}
internal interface JetBrains.Common.MemoryMappedStorage.TimelineApi.IStreamReader {
    public long Length { get; }
    public abstract virtual IntPtr TakeMax(long offset, Int32& availableItems);
    public abstract virtual IntPtr TakeBackMax(long offset, Int32& availableItems);
    public abstract virtual long get_Length();
}
internal interface JetBrains.Common.MemoryMappedStorage.TimelineApi.IStreamWriter {
    public abstract virtual IntPtr TakeOrAllocateMax(long offset, UInt32 size, Int64& allocatedOffset, Int32& allocatedSize);
    public abstract virtual void SetReadySize(long offset);
}
[DefaultMemberAttribute("Item")]
public interface JetBrains.Common.MemoryMappedStorage.TimelineApi.IStructuredSectionMemory`1 {
    public int Capacity { get; }
    public TItem Item { get; public set; }
    public abstract virtual int get_Capacity();
    public abstract virtual void SetItem(int index, TItem item);
    public abstract virtual TItem get_Item(int index);
    public abstract virtual void set_Item(int index, TItem value);
    public abstract virtual void SetItems(int index, int count, TItem[] buffer, int offset);
    public abstract virtual void SetItems(int index, int count, TItem fillingValue);
    public abstract virtual void FixSize();
    public abstract virtual bool SetReadyTill(int index);
    public abstract virtual int AddItem(TItem item);
    public abstract virtual long ExpandToIndex(int index);
}
public class JetBrains.Common.MemoryMappedStorage.TimelineApi.ProcessBatch`1 : MulticastDelegate {
    public ProcessBatch`1(object object, IntPtr method);
    public virtual void Invoke(TakeResult takeResult, int remainingCount, int processedCount, int itemSize, TClosure closure);
    public virtual IAsyncResult BeginInvoke(TakeResult takeResult, int remainingCount, int processedCount, int itemSize, TClosure closure, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class JetBrains.Common.MemoryMappedStorage.TimelineApi.TakeBuffer : MulticastDelegate {
    public TakeBuffer(object object, IntPtr method);
    public virtual TakeResult Invoke(IReadonlySectionMemory memory, int offset, int count);
    public virtual IAsyncResult BeginInvoke(IReadonlySectionMemory memory, int offset, int count, AsyncCallback callback, object object);
    public virtual TakeResult EndInvoke(IAsyncResult result);
}
public class JetBrains.Common.MemoryMappedStorage.TimelineApi.TakeOrAllocBuffer : MulticastDelegate {
    public TakeOrAllocBuffer(object object, IntPtr method);
    public virtual TakeResult Invoke(ISectionMemory memory, int offset, int count);
    public virtual IAsyncResult BeginInvoke(ISectionMemory memory, int offset, int count, AsyncCallback callback, object object);
    public virtual TakeResult EndInvoke(IAsyncResult result);
}
public class JetBrains.Common.MemoryMappedStorage.TimelineApi.TakeResult : ValueType {
    public IntPtr StartAddress;
    public int TakenOffset;
    public int TakenSize;
    public int NextIndex;
    public TakeResult(IntPtr startAddress, int takenOffset, int takenSize, int nextIndex);
    [LocalizableAttribute("False")]
public virtual string ToString();
}
internal class JetBrains.Common.MemoryMappedStorage.V1V2Adapter.MemoryMappedSection : object {
    private Lifetime myLifetime;
    private MemoryMappedSection mySection;
    public UInt32 Type { get; }
    public UInt32 Version { get; }
    public bool HasHeader { get; }
    public UInt32 HeaderSize { get; }
    public MemoryMappedSection(Lifetime lifetime, MemoryMappedSection section);
    public sealed virtual UInt32 get_Type();
    public sealed virtual UInt32 get_Version();
    public sealed virtual bool get_HasHeader();
    public sealed virtual UInt32 get_HeaderSize();
    public sealed virtual ISectionsEnumerator LoadSections(Lifetime lifetime);
    private sealed virtual override IReadonlySectionsEnumerator JetBrains.Common.MemoryMappedStorage.IReadonlySectionsContainer.LoadSections(Lifetime lifetime);
    public sealed virtual THeader GetHeader(ushort offset);
    public sealed virtual void WithHeader(Action`1<IntPtr> action, ushort offset);
    public sealed virtual ISectionMemory GetOrCreateMemory(Lifetime lifetime, ushort elementSize, UInt32 preferredRegionSize);
    public sealed virtual IReadonlySectionMemory GetMemory(Lifetime lifetime);
    public sealed virtual IReadOnlyCollection`1<IMemoryMappedSection> GetChildren();
    public sealed virtual IMemoryMappedSection AddChild(UInt32 type, UInt32 version);
    public sealed virtual void CreateHeader(ushort headerSize);
    private sealed virtual override IReadOnlyCollection`1<IReadonlyMemoryMappedSection> JetBrains.Common.MemoryMappedStorage.TimelineApi.IReadonlyMemoryMappedSection.GetChildren();
    public sealed virtual IMemoryMappedSection CreateSection(Lifetime lifetime, int type, int version);
}
internal class JetBrains.Common.MemoryMappedStorage.V1V2Adapter.MemoryMappedSectionData : object {
    private MemoryMappedSectionData mySectionData;
    private bool myIsReadOnly;
    private int myPageSizeInElements;
    private object myLock;
    private List`1<RefCountedLifetime> myPageLifetimes;
    private List`1<Page> myPages;
    private LifetimeDefinition myLifetimeDefinition;
    private Lifetime myLifetime;
    [CompilerGeneratedAttribute]
private bool <IsFixedSized>k__BackingField;
    public bool IsFixedSized { get; private set; }
    public UInt32 Size { get; }
    public UInt32 ReadySize { get; }
    public ushort ElementSize { get; }
    public byte AlignmentBit { get; }
    public MemoryMappedSectionData(MemoryMappedSectionData sectionData, bool readOnly);
    private Page GetPage(int pageNo);
    private int GetPageNo(long offset);
    private Page FindOrMapPage(long offset);
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsFixedSized();
    [CompilerGeneratedAttribute]
private void set_IsFixedSized(bool value);
    public sealed virtual void FixSize();
    public sealed virtual IntPtr Alloc(UInt32 count, UInt32& offset);
    public sealed virtual IntPtr AllocMax(UInt32& count, UInt32& offset);
    public sealed virtual IntPtr Take(UInt32& offset, UInt32 count);
    public sealed virtual IntPtr TakeMax(UInt32& offset, UInt32& count);
    public sealed virtual IntPtr TakeAllocMax(UInt32& offset, UInt32& count);
    public sealed virtual IntPtr TakeBackMax(UInt32& offset, UInt32& count);
    public sealed virtual IntPtr TakePage(UInt32& offset, UInt32& count);
    public sealed virtual UInt32 get_Size();
    public sealed virtual UInt32 get_ReadySize();
    public sealed virtual bool SetReady(UInt32 offset);
    public sealed virtual bool UnmapTo(UInt32 offset);
    public sealed virtual bool UnmapRange(UInt32 start, UInt32 end);
    public sealed virtual ushort get_ElementSize();
    public sealed virtual byte get_AlignmentBit();
}
internal class JetBrains.Common.MemoryMappedStorage.V1V2Adapter.MemoryMappedSectionsCollection : object {
    private MemoryMappedStorage myStorage;
    private MemoryMappedSection myParentSection;
    private Lifetime myLifetime;
    public int Count { get; }
    public MemoryMappedSectionsCollection(Lifetime lifetime, MemoryMappedStorage storage, MemoryMappedSection parentSection);
    private sealed virtual override IEnumerator`1<IMemoryMappedSection> System.Collections.Generic.IEnumerable<JetBrains.Common.MemoryMappedStorage.TimelineApi.IMemoryMappedSection>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual int get_Count();
    private sealed virtual override IEnumerator`1<IReadonlyMemoryMappedSection> System.Collections.Generic.IEnumerable<JetBrains.Common.MemoryMappedStorage.TimelineApi.IReadonlyMemoryMappedSection>.GetEnumerator();
    private MemoryMappedSectionsEnumerator GetCommonEnumerator(Lifetime lifetime);
}
internal class JetBrains.Common.MemoryMappedStorage.V1V2Adapter.MemoryMappedSectionsEnumerator : object {
    private ISectionsEnumerator myEnumerator;
    private Lifetime myLifetime;
    private IReadonlyMemoryMappedSection System.Collections.Generic.IEnumerator<JetBrains.Common.MemoryMappedStorage.TimelineApi.IReadonlyMemoryMappedSection>.Current { get; }
    private IMemoryMappedSection System.Collections.Generic.IEnumerator<JetBrains.Common.MemoryMappedStorage.TimelineApi.IMemoryMappedSection>.Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    public MemoryMappedSectionsEnumerator(Lifetime lifetime, ISectionsContainer container);
    public sealed virtual void Dispose();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
    private sealed virtual override IReadonlyMemoryMappedSection System.Collections.Generic.IEnumerator<JetBrains.Common.MemoryMappedStorage.TimelineApi.IReadonlyMemoryMappedSection>.get_Current();
    private sealed virtual override IMemoryMappedSection System.Collections.Generic.IEnumerator<JetBrains.Common.MemoryMappedStorage.TimelineApi.IMemoryMappedSection>.get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
}
internal class JetBrains.Common.MemoryMappedStorage.V1V2Adapter.MemoryMappedStorage : object {
    private Lifetime myLifetime;
    private MemoryMappedStorage myStorage;
    [CompilerGeneratedAttribute]
private FileSystemPath <IndexFile>k__BackingField;
    public FileSystemPath IndexFile { get; }
    public IReadOnlyCollection`1<IMemoryMappedSection> Sections { get; }
    private IReadOnlyCollection`1<IReadonlyMemoryMappedSection> JetBrains.Common.MemoryMappedStorage.TimelineApi.IReadonlyMemoryMappedStorage.Sections { get; }
    public MemoryMappedStorage(Lifetime lifetime, FileSystemPath indexFile, MemoryMappedStorage storage);
    [CompilerGeneratedAttribute]
public sealed virtual FileSystemPath get_IndexFile();
    public sealed virtual IReadOnlyCollection`1<IMemoryMappedSection> get_Sections();
    private sealed virtual override IReadOnlyCollection`1<IReadonlyMemoryMappedSection> JetBrains.Common.MemoryMappedStorage.TimelineApi.IReadonlyMemoryMappedStorage.get_Sections();
    public sealed virtual IMemoryMappedSection AddChild(UInt32 type, UInt32 version);
}
[ZoneMarkerAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ShellComponentAttribute]
public class JetBrains.Common.MemoryMappedStorage.V1V2Adapter.MemoryMappedStorageManager : object {
    public sealed virtual IMemoryMappedStorage CreateAndOpen(Lifetime lifetime, FileSystemPath file, ulong offset);
    public sealed virtual IMemoryMappedStorage CreateAndOpen(Lifetime lifetime, IntPtr handle, FileSystemPath path, ulong offset);
    public sealed virtual IMemoryMappedStorage Open(Lifetime lifetime, FileSystemPath file, ulong offset);
    public sealed virtual IMemoryMappedStorage Open(Lifetime lifetime, IntPtr handle, FileSystemPath file, ulong offset);
    public static IMemoryMappedStorage Open(Lifetime lifetime, IntPtr handle, bool readOnly, FileSystemPath file, ulong offset);
    public sealed virtual IReadonlyMemoryMappedStorage OpenReadonly(Lifetime lifetime, FileSystemPath file, ulong offset);
    public sealed virtual IReadonlyMemoryMappedStorage OpenReadonly(Lifetime lifetime, IntPtr handle, FileSystemPath file, ulong offset);
}
public static class JetBrains.Common.MemoryMappedStorageV10.Impl.Interop.DllInterop : object {
    private static NativeDll ourDll;
    public static MMSReleaseErrorInfoDelegate MMSReleaseErrorInfo;
    private static DllInterop();
    public static TDelegate ImportMethod(string methodName);
}
internal static class JetBrains.Common.MemoryMappedStorageV10.Impl.Interop.ErrorUtils : object {
    internal static void CheckError(IntPtr err);
}
public class JetBrains.Common.MemoryMappedStorageV10.Impl.Interop.Section : object {
    internal static UInt32 NullSectionId;
    public UInt32 Id;
    public UInt32 Type;
    public UInt32 Version;
    public static MMSSectionInfoDelegate MMSSectionInfo;
    public static MMSSectionCreateHeaderDelegate MMSSectionCreateHeader;
    public static MMSSectionGetHeaderDelegate MMSSectionGetHeader;
    public static MMSSectionDataDelegate MMSSectionData;
    public static MMSSectionDataExDelegate MMSSectionDataEx;
    public bool IsValid { get; }
    public Section(UInt32 id, UInt32 type, UInt32 version);
    internal Section(Storage stor, UInt32 id);
    private static Section();
    public bool get_IsValid();
    public Header CreateHeader(Storage stor, UInt32 size);
    public Header GetHeader(Storage stor);
    public ISectionData GetData(Storage stor, bool readOnly);
    public ISectionData GetDataEx(Storage stor, ushort elementSize, byte segmentAlignmentBit, byte alignmentBit, UInt32 preferredRegionSize, bool readOnly);
}
public class JetBrains.Common.MemoryMappedStorageV10.Impl.Interop.SectionData : object {
    private IntPtr myStorHandle;
    private IntPtr myHandle;
    private static MMSSectionDataIsFixedSizedDelegate MMSSectionDataIsFixedSized;
    private static MMSSectionDataFixSizeDelegate MMSSectionDataFixSize;
    private static MMSSectionDataAllocDelegate MMSSectionDataAlloc;
    private static MMSSectionDataAllocMaxDelegate MMSSectionDataAllocMax;
    private static MMSSectionDataTakeDelegate MMSSectionDataTake;
    private static MMSSectionDataTakeMaxDelegate MMSSectionDataTakeMax;
    private static MMSSectionDataTakeAllocMaxDelegate MMSSectionDataTakeAllocMax;
    private static MMSSectionDataTakeBackMaxDelegate MMSSectionDataTakeBackMax;
    private static MMSSectionDataTakePageDelegate MMSSectionDataTakePage;
    private static MMSSectionDataSizeDelegate MMSSectionDataSize;
    private static MMSSectionDataReadySizeDelegate MMSSectionDataReadySize;
    private static MMSSectionDataSetReadyDelegate MMSSectionDataSetReady;
    private static MMSSectionDataUnmapToDelegate MMSSectionDataUnmapTo;
    private static MMSSectionDataUnmapRangeDelegate MMSSectionDataUnmapRange;
    private static MMSSectionDataElementSizeDelegate MMSSectionDataElementSize;
    private static MMSSectionDataAlignmentBitDelegate MMSSectionDataAlignmentBit;
    private static MMSReleaseSectionDataDelegate MMSReleaseSectionData;
    public bool IsFixedSized { get; }
    public UInt32 Size { get; }
    public UInt32 ReadySize { get; }
    public ushort ElementSize { get; }
    public byte AlignmentBit { get; }
    internal SectionData(IntPtr stor, IntPtr handle);
    private static SectionData();
    public sealed virtual void Dispose();
    public sealed virtual bool get_IsFixedSized();
    public sealed virtual void FixSize();
    public sealed virtual IntPtr Alloc(UInt32 count, UInt32& offset);
    public sealed virtual IntPtr AllocMax(UInt32& count, UInt32& offset);
    public sealed virtual IntPtr Take(UInt32& offset, UInt32 count);
    public sealed virtual IntPtr TakeMax(UInt32& offset, UInt32& count);
    public sealed virtual IntPtr TakeAllocMax(UInt32& offset, UInt32& count);
    public sealed virtual IntPtr TakeBackMax(UInt32& offset, UInt32& count);
    public sealed virtual IntPtr TakePage(UInt32& offset, UInt32& count);
    public sealed virtual UInt32 get_Size();
    public sealed virtual UInt32 get_ReadySize();
    public sealed virtual bool SetReady(UInt32 offset);
    public sealed virtual bool UnmapTo(UInt32 offset);
    public sealed virtual bool UnmapRange(UInt32 start, UInt32 end);
    public sealed virtual ushort get_ElementSize();
    public sealed virtual byte get_AlignmentBit();
}
public class JetBrains.Common.MemoryMappedStorageV10.Impl.Interop.SectionsList : object {
    private Storage myStorage;
    private Section myParentSection;
    private static MMSSectionFirstChildDelegate MMSSectionFirstChild;
    private static MMSSectionChildAtDelegate MMSSectionChildAt;
    private static MMSSectionNextDelegate MMSSectionNext;
    private static MMSCreateSectionDelegate MMSCreateSection;
    public SectionsList(Storage stor, Section parentSection);
    private static SectionsList();
    public Section GetAt(UInt32 index);
    public Section CreateSection(UInt32 type, UInt32 ver);
    public sealed virtual IEnumerator`1<Section> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class JetBrains.Common.MemoryMappedStorageV10.Impl.Interop.Storage : object {
    internal ConcurrentDictionary`2<UInt32, int> MemoryRefCounter;
    internal IntPtr Handle;
    private static MMSCreateStorageDelegate MMSCreateStorage;
    private static MMSOpenStorageDelegate MMSOpenStorage;
    private static MMSReleaseStorageDelegate MMSReleaseStorage;
    private static MMSIsStorageReadOnlyDelegate MMSIsStorageReadOnly;
    private Storage(IntPtr handle);
    private static Storage();
    public sealed virtual void Dispose();
    [ConditionalAttribute("JET_TRACE_STORAGE_ACCESS")]
private void TraceCreation();
    [LocalizableAttribute("False")]
public virtual string ToString();
    [LocalizableAttribute("False")]
[ConditionalAttribute("JET_TRACE_STORAGE_ACCESS")]
private void TraceDispose();
    internal int AquiredSectionsCount();
    [LocalizableAttribute("False")]
internal void PrintSectionsBalance(StringBuilder stringBuilder);
    public static Storage Create(IntPtr fileHandle, ulong startPos);
    public static Storage Open(IntPtr fileHandle, ulong startPos, bool readOnly);
    public bool IsReadOnly();
}
internal class JetBrains.Common.MemoryMappedStorageV10.Impl.MemoryMappedSection : object {
    private SectionsList mySectionsList;
    private Section mySection;
    private Storage myStorage;
    private SectionsList SectionsList { get; }
    public UInt32 Type { get; }
    public UInt32 Version { get; }
    public bool HasHeader { get; }
    public UInt32 HeaderSize { get; }
    public MemoryMappedSection(Storage storage, Section section);
    private SectionsList get_SectionsList();
    public sealed virtual UInt32 get_Type();
    public sealed virtual UInt32 get_Version();
    public sealed virtual bool get_HasHeader();
    public sealed virtual UInt32 get_HeaderSize();
    public sealed virtual void WithHeader(Action`1<IntPtr> action, ushort offset);
    public sealed virtual THeader GetHeader(ushort offset);
    public sealed virtual void CreateHeader(ushort headerSize);
    public sealed virtual ISectionMemory GetOrCreateMemory(Lifetime lifetime, ushort elementSize, UInt32 preferredRegionSize);
    private ISectionMemory GetMemoryImpl(Lifetime lifetime, ushort elementSize, bool readOnly, UInt32 preferredRegionSize);
    public sealed virtual IReadonlySectionMemory GetMemory(Lifetime lifetime);
    [ConditionalAttribute("JET_TRACE_STORAGE_ACCESS")]
private void TraceAcquire();
    [ConditionalAttribute("JET_TRACE_STORAGE_ACCESS")]
private void TraceRelease(Lifetime lifetime);
    public sealed virtual IReadOnlyCollection`1<IMemoryMappedSection> GetChildren();
    public sealed virtual IMemoryMappedSection AddChild(UInt32 type, UInt32 version);
    private sealed virtual override IReadOnlyCollection`1<IReadonlyMemoryMappedSection> JetBrains.Common.MemoryMappedStorage.TimelineApi.IReadonlyMemoryMappedSection.GetChildren();
    private MemoryMappedSectionsCollection GetChildrenCommon();
    [LocalizableAttribute("False")]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private void <TraceRelease>b__21_0();
}
internal class JetBrains.Common.MemoryMappedStorageV10.Impl.MemoryMappedSectionsCollection : object {
    private Section myParentSection;
    private Storage myStorage;
    public int Count { get; }
    public MemoryMappedSectionsCollection(Storage storage, Section parentSection);
    private sealed virtual override IEnumerator`1<IMemoryMappedSection> System.Collections.Generic.IEnumerable<JetBrains.Common.MemoryMappedStorage.TimelineApi.IMemoryMappedSection>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual int get_Count();
    private sealed virtual override IEnumerator`1<IReadonlyMemoryMappedSection> System.Collections.Generic.IEnumerable<JetBrains.Common.MemoryMappedStorage.TimelineApi.IReadonlyMemoryMappedSection>.GetEnumerator();
    private MemoryMappedSectionsEnumerator GetCommonEnumerator();
}
internal class JetBrains.Common.MemoryMappedStorageV10.Impl.MemoryMappedSectionsEnumerator : object {
    private SectionEnumerator myEnumerator;
    private Storage myStorage;
    public UInt32 Count { get; }
    public IMemoryMappedSection Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    private IReadonlyMemoryMappedSection System.Collections.Generic.IEnumerator<JetBrains.Common.MemoryMappedStorage.TimelineApi.IReadonlyMemoryMappedSection>.Current { get; }
    public MemoryMappedSectionsEnumerator(Storage storage, SectionEnumerator enumerator);
    public UInt32 get_Count();
    public sealed virtual bool MoveNext();
    public sealed virtual IMemoryMappedSection get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual void Reset();
    public sealed virtual void Dispose();
    private sealed virtual override IReadonlyMemoryMappedSection System.Collections.Generic.IEnumerator<JetBrains.Common.MemoryMappedStorage.TimelineApi.IReadonlyMemoryMappedSection>.get_Current();
    private IMemoryMappedSection CreateCurrent();
}
internal class JetBrains.Common.MemoryMappedStorageV10.Impl.MemoryMappedStorage : object {
    private SectionsList mySectionsList;
    private MemoryMappedSectionsCollection mySections;
    private Storage myStorage;
    [CompilerGeneratedAttribute]
private FileSystemPath <IndexFile>k__BackingField;
    private SectionsList SectionsList { get; }
    public FileSystemPath IndexFile { get; }
    private IReadOnlyCollection`1<IReadonlyMemoryMappedSection> JetBrains.Common.MemoryMappedStorage.TimelineApi.IReadonlyMemoryMappedStorage.Sections { get; }
    private IReadOnlyCollection`1<IMemoryMappedSection> JetBrains.Common.MemoryMappedStorage.TimelineApi.IMemoryMappedStorage.Sections { get; }
    public MemoryMappedStorage(Storage storage, FileSystemPath indexFile);
    private SectionsList get_SectionsList();
    [CompilerGeneratedAttribute]
public sealed virtual FileSystemPath get_IndexFile();
    private sealed virtual override IReadOnlyCollection`1<IReadonlyMemoryMappedSection> JetBrains.Common.MemoryMappedStorage.TimelineApi.IReadonlyMemoryMappedStorage.get_Sections();
    public sealed virtual IMemoryMappedSection AddChild(UInt32 type, UInt32 version);
    private sealed virtual override IReadOnlyCollection`1<IMemoryMappedSection> JetBrains.Common.MemoryMappedStorage.TimelineApi.IMemoryMappedStorage.get_Sections();
}
public class JetBrains.Common.MemoryMappedStorageV10.Impl.MemoryMappedStorageManager : object {
    private static IntPtr GetHandle(Lifetime lifetime, FileSystemPath fileName, FileMode fileMode, FileAccess fileAccess);
    public sealed virtual IMemoryMappedStorage CreateAndOpen(Lifetime lifetime, FileSystemPath file, ulong offset);
    public sealed virtual IMemoryMappedStorage CreateAndOpen(Lifetime lifetime, IntPtr handle, FileSystemPath file, ulong offset);
    public sealed virtual IMemoryMappedStorage Open(Lifetime lifetime, FileSystemPath file, ulong offset);
    public sealed virtual IMemoryMappedStorage Open(Lifetime lifetime, IntPtr handle, FileSystemPath file, ulong offset);
    public sealed virtual IReadonlyMemoryMappedStorage OpenReadonly(Lifetime lifetime, FileSystemPath file, ulong offset);
    public sealed virtual IReadonlyMemoryMappedStorage OpenReadonly(Lifetime lifetime, IntPtr handle, FileSystemPath file, ulong offset);
    public static IMemoryMappedStorage Open(Lifetime lifetime, IntPtr handle, bool readOnly, FileSystemPath path, ulong offset);
    private static IMemoryMappedStorage CreateAndOpenImpl(Lifetime lifetime, IntPtr handle, FileSystemPath path, ulong offset);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
