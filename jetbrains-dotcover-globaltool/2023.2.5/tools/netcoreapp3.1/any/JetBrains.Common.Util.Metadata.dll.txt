public class JetBrains.Common.Util.Metadata.CLRTypeName : ValueType {
    private string myCLRName;
    private String[] myNamespaces;
    private Int32[] myTypeParameterNumbers;
    private String[] myTypes;
    public bool IsInnerType { get; }
    public string ShortName { get; }
    public string ClrName { get; }
    public int NamespaceCount { get; }
    public string NamespaceName { get; }
    public int TypeCount { get; }
    public String[] Types { get; }
    public CLRTypeName(string clrName);
    private CLRTypeName(String[] namespaces, String[] types, Int32[] counts);
    public bool get_IsInnerType();
    public string get_ShortName();
    public string get_ClrName();
    public int get_NamespaceCount();
    public string get_NamespaceName();
    public int get_TypeCount();
    public String[] get_Types();
    public CLRTypeName AppendNestedType(string shortName, int count);
    public CLRTypeName AppendType(string shortName, int count);
    public CLRTypeName Rename(string newName);
    public static CLRTypeName op_Explicit(string s);
    public Nullable`1<CLRTypeName> GetParent();
    public string GetNamespace(int i);
    public string GetType(int i);
    public int GetTypeParameterNumber(int i);
    public bool Equals(CLRTypeName obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(CLRTypeName l, CLRTypeName r);
    public static bool op_Inequality(CLRTypeName l, CLRTypeName r);
}
public static class JetBrains.Common.Util.Metadata.LowLevelMetadata.CustomAttributeSpecBlobDecoder : object {
    private static ILogger ourLogger;
    private static CustomAttributeSpecBlobDecoder();
    public static bool TryDecodeBlob(IBinaryReader reader, IBlob attributeCtorSignatureBlob, ILowLevelMetadata metadata, ICustomAttributeSpecificationBuilder`4<TSpec, TFixedArgsList, TNamedArgsList, TArgValue> builder, TSpec& specification);
    public static TSpec DecodeBlob(IBinaryReader reader, IBlob attributeCtorSignatureBlob, ILowLevelMetadata metadata, ICustomAttributeSpecificationBuilder`4<TSpec, TFixedArgsList, TNamedArgsList, TArgValue> builder);
    private static Pair`2<string, TArgValue> ReadNamedArgument(IBinaryReader reader, ILowLevelMetadata metadata, ICustomAttributeSpecificationBuilder`4<TSpec, TFixedArgsList, TNamedArgsList, TArgValue> builder);
    private static TArgValue ReadArgumentValue(IBinaryReader reader, TypeInfo typeInfo, ILowLevelMetadata metadata, ICustomAttributeSpecificationBuilder`4<TSpec, TFixedArgsList, TNamedArgsList, TArgValue> builder);
    private static TArgValue ReadArrayValue(IBinaryReader reader, BaseTypeInfo itemTypeInfo, ILowLevelMetadata metadata, ICustomAttributeSpecificationBuilder`4<TSpec, TFixedArgsList, TNamedArgsList, TArgValue> builder);
    private static TArgValue ReadScalarValue(IBinaryReader reader, BaseTypeInfo scalarTypeInfo, ILowLevelMetadata metadata, ICustomAttributeSpecificationBuilder`4<TSpec, TFixedArgsList, TNamedArgsList, TArgValue> builder);
    private static TArgValue ReadObjectValue(IBinaryReader reader, ILowLevelMetadata metadata, ICustomAttributeSpecificationBuilder`4<TSpec, TFixedArgsList, TNamedArgsList, TArgValue> builder);
    private static TArgValue ReadElementTypeValue(IBinaryReader reader, ElementType elementType, ICustomAttributeSpecificationBuilder`4<TSpec, TFixedArgsList, TNamedArgsList, TArgValue> builder);
}
public class JetBrains.Common.Util.Metadata.LowLevelMetadata.Hashes.CustomAttributesHashesCalculator : ValueType {
    private ILowLevelMetadata myMetadata;
    public CustomAttributesHashesCalculator(ILowLevelMetadata metadata);
    public long CalculateCustomAttributesHash(MetadataToken ownerToken);
    private Hash GetAttributeHash(MetadataToken customAttributeToken);
}
public class JetBrains.Common.Util.Metadata.LowLevelMetadata.Hashes.HashingCustomAttributeSpecificationBuilder : object {
    public static HashingCustomAttributeSpecificationBuilder Instance;
    private static HashingCustomAttributeSpecificationBuilder();
    public sealed virtual Hash CreateFixedArgumentsList(int argsCount);
    public sealed virtual Hash AddFixedArgument(Hash argsList, Hash arg);
    public sealed virtual Hash CreateNamedArgumentsList(int argsCount);
    public sealed virtual Hash AddNamedArgument(Hash argsList, string name, Hash arg);
    private static Hash BuildArgValue(ElementType elementType, Hash valueHash);
    public sealed virtual Hash BuildArg_Bool(ElementType elementType, bool value);
    public sealed virtual Hash BuildArg_Char(ElementType elementType, char value);
    public sealed virtual Hash BuildArg_I1(ElementType elementType, sbyte value);
    public sealed virtual Hash BuildArg_U1(ElementType elementType, byte value);
    public sealed virtual Hash BuildArg_I2(ElementType elementType, short value);
    public sealed virtual Hash BuildArg_U2(ElementType elementType, ushort value);
    public sealed virtual Hash BuildArg_I4(ElementType elementType, int value);
    public sealed virtual Hash BuildArg_U4(ElementType elementType, UInt32 value);
    public sealed virtual Hash BuildArg_I8(ElementType elementType, long value);
    public sealed virtual Hash BuildArg_U8(ElementType elementType, ulong value);
    public sealed virtual Hash BuildArg_R4(ElementType elementType, float value);
    public sealed virtual Hash BuildArg_R8(ElementType elementType, double value);
    public sealed virtual Hash BuildArg_String(ElementType elementType, string value);
    public sealed virtual Hash BuildArrayArg(UInt32 itemsCount);
    public sealed virtual Hash AddArrayArgItem(Hash array, Hash item);
    public sealed virtual Hash BuildCustomAttributeSpecification(Hash fixedArgs, Hash namedArgs);
}
public class JetBrains.Common.Util.Metadata.LowLevelMetadata.Hashes.HashingMethodBodyBuilder : object {
    private TokenedEntityHashesCalculator myTokenedEntityHashesCalculator;
    public HashingMethodBodyBuilder(TokenedEntityHashesCalculator tokenedEntityHashesCalculator);
    public sealed virtual long CreateInstructionList();
    public sealed virtual long AddInstruction(long instructionsHash, Hash newInstructionHash);
    private static Hash GetInstructionHash(Opcode opcode, Hash operandHash);
    public sealed virtual Hash BuildInstruction_NoOperand(int offset, int size, Opcode opcode);
    public sealed virtual Hash BuildInstruction_Int32Operand(int offset, int size, Opcode opcode, int operand);
    public sealed virtual Hash BuildInstruction_Int64Operand(int offset, int size, Opcode opcode, long operand);
    public sealed virtual Hash BuildInstruction_DoubleOperand(int offset, int size, Opcode opcode, double operand);
    public sealed virtual Hash BuildInstruction_SByteOperand(int offset, int size, Opcode opcode, sbyte operand);
    public sealed virtual Hash BuildInstruction_SingleOperand(int offset, int size, Opcode opcode, float operand);
    public sealed virtual Hash BuildInstruction_SwitchTargetsOperand(int offset, int size, Opcode opcode, Int32[] operand);
    public sealed virtual Hash BuildInstruction_VariableIndexOperand(int offset, int size, Opcode opcode, ushort operand);
    public sealed virtual Hash BuildInstruction_ShortVariableIndexOperand(int offset, int size, Opcode opcode, byte operand);
    public sealed virtual Hash BuildInstruction_TokenOperand(IMetadataAccess metadataAccess, int offset, int size, Opcode opcode, MetadataToken token);
    public sealed virtual long CreateExceptionHandlerList();
    public sealed virtual long AddExceptionHandler(long handlers, ExceptionHandlerType type, int tryOffset, int tryLength, int handlerOffset, int handlerLength);
    public sealed virtual long AddExceptionHandler(long handlers, ExceptionHandlerType type, int tryOffset, int tryLength, int handlerOffset, int handlerLength, int filterOffset);
    public sealed virtual long AddExceptionHandler(long handlers, ExceptionHandlerType type, int tryOffset, int tryLength, int handlerOffset, int handlerLength, MetadataToken catchType);
    public sealed virtual long CreateMethodBody(int codeSize, int maxStack, MetadataToken localVarsToken, long exceptionHandlersHash, long instructionsHash, ILMethodFlags flags);
}
[ThreadUnsafeAttribute]
public class JetBrains.Common.Util.Metadata.LowLevelMetadata.Hashes.MethodBodyHashesCalculator : object {
    private ILogger myLogger;
    private ILowLevelMetadata myMetadata;
    private PEFile myPeFile;
    private IBinaryReader myMethodBodyReader;
    private HashingMethodBodyBuilder myHashingMethodBodyBuilder;
    private JetHashSet`1<MetadataToken> myCompilerGeneratedMethodsInProgress;
    public MethodBodyHashesCalculator(ILowLevelMetadata metadata, PEFile peFile);
    public long CalculateMethodBodyHash(MetadataToken methodToken);
    private Hash GetCompilerGeneratedMethodHash(MetadataToken methodToken);
    private MetadataToken TryGetMethodDefTokenByMemberRefToken(MetadataToken memberRefToken);
    private bool TrySetMethodBodyReaderPosition(MetadataToken methodToken);
}
public class JetBrains.Common.Util.Metadata.LowLevelMetadata.Hashes.TokenedEntityHashesCalculator : object {
    private ILowLevelMetadata myMetadata;
    private Func`2<MetadataToken, Hash> myGetCompilerGeneratedMethodHash;
    private IDictionary`2<MetadataToken, Hash> myTokenedEntityHashesCache;
    private ITypeBuilder`2<Hash, Hash> myHashingTypeBuilder;
    public TokenedEntityHashesCalculator(ILowLevelMetadata metadata, Func`2<MetadataToken, Hash> getCompilerGeneratedMethodHash);
    public Hash GetHashByToken(MetadataToken token);
    private Hash CalculateHashByTypeDefToken(MetadataToken token);
    private Hash CalculateHashByTypeRefToken(MetadataToken token);
    private Hash CalculateHashByTypeSpecToken(MetadataToken token);
    private Hash CalculateHashByFieldToken(MetadataToken token);
    private Hash CalculateHashByStandAloneSigToken(MetadataToken token);
    private Hash CalculateHashByMethodDefToken(MetadataToken token);
    private Hash CalculateHashByMethodSpecToken(MetadataToken token);
    private Hash CalculateHashByMemberRefToken(MetadataToken token);
    private Hash CalculateHashByAssemblyRefToken(MetadataToken token);
    private Hash CalculateHashByModuleRefToken(MetadataToken token);
    private static bool IsCompilerGeneratedName(string name);
}
public interface JetBrains.Common.Util.Metadata.LowLevelMetadata.ICustomAttributeSpecificationBuilder`4 {
    public abstract virtual TFixedArgsList CreateFixedArgumentsList(int argsCount);
    public abstract virtual TFixedArgsList AddFixedArgument(TFixedArgsList argsList, TArgValue arg);
    public abstract virtual TNamedArgsList CreateNamedArgumentsList(int argsCount);
    public abstract virtual TNamedArgsList AddNamedArgument(TNamedArgsList argsList, string name, TArgValue arg);
    public abstract virtual TArgValue BuildArg_Bool(ElementType elementType, bool value);
    public abstract virtual TArgValue BuildArg_Char(ElementType elementType, char value);
    public abstract virtual TArgValue BuildArg_I1(ElementType elementType, sbyte value);
    public abstract virtual TArgValue BuildArg_U1(ElementType elementType, byte value);
    public abstract virtual TArgValue BuildArg_I2(ElementType elementType, short value);
    public abstract virtual TArgValue BuildArg_U2(ElementType elementType, ushort value);
    public abstract virtual TArgValue BuildArg_I4(ElementType elementType, int value);
    public abstract virtual TArgValue BuildArg_U4(ElementType elementType, UInt32 value);
    public abstract virtual TArgValue BuildArg_I8(ElementType elementType, long value);
    public abstract virtual TArgValue BuildArg_U8(ElementType elementType, ulong value);
    public abstract virtual TArgValue BuildArg_R4(ElementType elementType, float value);
    public abstract virtual TArgValue BuildArg_R8(ElementType elementType, double value);
    public abstract virtual TArgValue BuildArg_String(ElementType elementType, string value);
    public abstract virtual TArgValue BuildArrayArg(UInt32 itemsCount);
    public abstract virtual TArgValue AddArrayArgItem(TArgValue array, TArgValue item);
    public abstract virtual TSpec BuildCustomAttributeSpecification(TFixedArgsList fixedArgs, TNamedArgsList namedArgsList);
}
public interface JetBrains.Common.Util.Metadata.LowLevelMetadata.ILowLevelMetadata {
    public Guid Mvid { get; }
    public string ModuleName { get; }
    public AssemblyNameInfo AssemblyName { get; }
    public MetadataToken AssemblyToken { get; }
    public MetadataTokenRange TypeDefs { get; }
    public MetadataTokenRange TypeRefs { get; }
    public MetadataTokenRange TypeSpecs { get; }
    public MetadataTokenRange MethodDefs { get; }
    public MetadataTokenRange Events { get; }
    public MetadataTokenRange Properties { get; }
    public abstract virtual Guid get_Mvid();
    public abstract virtual string get_ModuleName();
    public abstract virtual AssemblyNameInfo get_AssemblyName();
    public abstract virtual MetadataToken get_AssemblyToken();
    public abstract virtual MetadataTokenRange get_TypeDefs();
    public abstract virtual MetadataTokenRange get_TypeRefs();
    public abstract virtual MetadataTokenRange get_TypeSpecs();
    public abstract virtual MetadataTokenRange get_MethodDefs();
    public abstract virtual MetadataTokenRange get_Events();
    public abstract virtual MetadataTokenRange get_Properties();
    public abstract virtual TypeDefProperties GetTypeDefProperties(MetadataToken token);
    public abstract virtual TypeRefProperties GetTypeRefProperties(MetadataToken token);
    public abstract virtual IBlob GetTypeSpecBlob(MetadataToken token);
    public abstract virtual MethodProperties GetMethodProperties(MetadataToken token);
    public abstract virtual FieldProperties GetFieldProperties(MetadataToken token);
    public abstract virtual IBlob GetStandaloneSignatureBlob(MetadataToken token);
    public abstract virtual MethodSpecProperties GetMethodSpecProperties(MetadataToken token);
    public abstract virtual MemberReferenceProperties GetMemberRefProperties(MetadataToken token);
    public abstract virtual string GetModuleRefProperties(MetadataToken token);
    public abstract virtual EventProperties GetEventProperties(MetadataToken token);
    public abstract virtual PropertyProperties GetPropertyProperties(MetadataToken token);
    public abstract virtual MetadataTokenRange GetCustomAttributes(MetadataToken ownerToken);
    public abstract virtual MetadataTypeReference GetCustomAttributeTypeRef(MetadataToken token);
    public abstract virtual CustomAttributeProperties GetCustomAttributeProperties(MetadataToken token);
    public abstract virtual MetadataTokenRange GetGenericParameters(MetadataToken ownerToken);
    public abstract virtual GenericParameterProperties GetGenericParamProperties(MetadataToken token);
    public abstract virtual MetadataTokenRange GetMethodDefs(MetadataToken typeToken);
    public abstract virtual MetadataTokenRange GetEvents(MetadataToken typeToken);
    public abstract virtual MetadataTokenRange GetProperties(MetadataToken typeToken);
    public abstract virtual MetadataTokenRange GetFields(MetadataToken typeToken);
    public abstract virtual IReadOnlyList`1<MetadataToken> GetNestedTypeDefs(MetadataToken typeToken);
    public abstract virtual MetadataToken GetEnclosingType(MetadataToken nestedTypeToken);
    public abstract virtual MetadataTokenRange GetInterfaceImplementations(MetadataToken typeToken);
    public abstract virtual InterfaceImplementationProperties GetInterfaceImplementationProperties(MetadataToken token);
    public abstract virtual MetadataTokenRange GetParameters(MetadataToken methodToken);
    public abstract virtual ParamProperties GetParameterProperties(MetadataToken paramToken);
    public abstract virtual MetadataToken[] GetImplementedMethods(MetadataToken typeToken, MetadataToken methodBodyToken);
    public abstract virtual AssemblyNameInfo GetReferencedAssemblyName(MetadataToken token);
    public abstract virtual string GetUserString(MetadataToken token);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.Metadata.LowLevelMetadata.LowLevelMetadataExtensions : object {
    [ExtensionAttribute]
[CanBeNullAttribute]
public static TargetFrameworkId GetTargetFrameworkId(ILowLevelMetadata metadata);
    [ExtensionAttribute]
public static bool TryGetMethodBodyVirtualAddress(ILowLevelMetadata metadata, MetadataToken methodToken, PEFile peFile, Int32& virtualAddress);
    [ExtensionAttribute]
public static bool IsValidToken(ILowLevelMetadata metadata, MetadataToken metadataToken);
    [ExtensionAttribute]
public static FrugalLocalList`1<MetadataToken> GetNestedTypesChain(ILowLevelMetadata metadata, MetadataToken typeDefToken);
    [ExtensionAttribute]
public static StringDotConcat GetTypeFullName(ILowLevelMetadata metadata, MetadataToken typeDefOrRefToken, char nestedTypeNamesSeparator);
    [ExtensionAttribute]
public static Pair`2<string, string> GetTypeNamespaceAndName(ILowLevelMetadata metadata, MetadataToken typeDefOrRefToken, char nestedTypeNamesSeparator);
    [ExtensionAttribute]
public static bool HasCustomAttribute(MetadataToken entity, string targetAttributeName, ILowLevelMetadata metadata);
    [ExtensionAttribute]
public static bool IsInterface(TypeDefProperties typeDefProperties);
    [ExtensionAttribute]
public static bool IsNested(TypeDefProperties typeDefProperties);
    [ExtensionAttribute]
public static bool IsAbstract(MethodProperties methodProperties);
    [ExtensionAttribute]
public static bool IsPInvoke(MethodProperties methodProperties);
    [ExtensionAttribute]
public static bool IsOverriding(MethodProperties methodProperties);
    [ExtensionAttribute]
public static CodeType GetCodeType(MethodProperties methodProperties);
    [CompilerGeneratedAttribute]
internal static string <GetTargetFrameworkId>g__GetAttributeParameterUtf8ConstantValue|0_0(ILowLevelMetadata m, MetadataToken t);
}
public class JetBrains.Common.Util.Metadata.LowLevelMetadata.LowLevelMetadataTokensMapper : object {
    private ILowLevelMetadata mySourceMetadata;
    private ILowLevelMetadata myTargetMetadata;
    private LowLevelMetadataTypesEqualityComparer myTypesEqualityComparer;
    private OneToListMap`2<int, TargetTypeInfo> myTargetTypesMap;
    private Dictionary`2<MetadataToken, OneToListMap`2<string, TargetMethodInfo>> myTargetMethodsMap;
    public LowLevelMetadataTokensMapper(ILowLevelMetadata sourceMetadata, ILowLevelMetadata targetMetadata);
    public MetadataToken MapToken(MetadataToken sourceToken);
    private MetadataToken MapTypeToken(MetadataToken sourceToken);
    private MetadataToken MapMethodToken(MetadataToken sourceToken);
    private MetadataToken MapPropertyToken(MetadataToken sourceToken);
    private MetadataToken MapEventToken(MetadataToken sourceToken);
    private void EnsureTargetTypesMapCreated();
    private void EnsureTargetMethodsMapCreated(MetadataToken targetTypeDefToken);
    private static int GetTypeHash(TypeDefProperties typeDefProperties);
}
public class JetBrains.Common.Util.Metadata.LowLevelMetadata.LowLevelMetadataTypesEqualityComparer : ValueType {
    private ILowLevelMetadata myLeftMetadata;
    private ILowLevelMetadata myRightMetadata;
    private TokenedEntityHashesCalculator myLeftHashesCalculator;
    private TokenedEntityHashesCalculator myRightHashesCalculator;
    public LowLevelMetadataTypesEqualityComparer(ILowLevelMetadata leftMetadata, ILowLevelMetadata rightMetadata);
    [PureAttribute]
public bool Equals(MetadataToken leftTypeDefToken, TypeDefProperties leftTypeDefProperties, MetadataToken rightTypeDefToken, TypeDefProperties rightTypeDefProperties);
    [PureAttribute]
public sealed virtual bool Equals(MetadataToken left, MetadataToken right);
    public sealed virtual int GetHashCode(MetadataToken metadataToken);
}
public class JetBrains.Common.Util.Metadata.LowLevelMetadata.LowLevelMetadataWithoutCache : object {
    private IMetadataAccess myMetadataAccess;
    public Guid Mvid { get; }
    public string ModuleName { get; }
    public AssemblyNameInfo AssemblyName { get; }
    public MetadataToken AssemblyToken { get; }
    public MetadataTokenRange TypeDefs { get; }
    public MetadataTokenRange TypeRefs { get; }
    public MetadataTokenRange TypeSpecs { get; }
    public MetadataTokenRange MethodDefs { get; }
    public MetadataTokenRange Events { get; }
    public MetadataTokenRange Properties { get; }
    public LowLevelMetadataWithoutCache(IMetadataAccess metadataAccess);
    public sealed virtual Guid get_Mvid();
    public sealed virtual string get_ModuleName();
    public sealed virtual AssemblyNameInfo get_AssemblyName();
    public sealed virtual MetadataToken get_AssemblyToken();
    public sealed virtual MetadataTokenRange get_TypeDefs();
    public sealed virtual MetadataTokenRange get_TypeRefs();
    public sealed virtual MetadataTokenRange get_TypeSpecs();
    public sealed virtual MetadataTokenRange get_MethodDefs();
    public sealed virtual MetadataTokenRange get_Events();
    public sealed virtual MetadataTokenRange get_Properties();
    public sealed virtual TypeDefProperties GetTypeDefProperties(MetadataToken token);
    public sealed virtual TypeRefProperties GetTypeRefProperties(MetadataToken token);
    public sealed virtual IBlob GetTypeSpecBlob(MetadataToken token);
    public sealed virtual MethodProperties GetMethodProperties(MetadataToken token);
    public sealed virtual FieldProperties GetFieldProperties(MetadataToken token);
    public sealed virtual IBlob GetStandaloneSignatureBlob(MetadataToken token);
    public sealed virtual MethodSpecProperties GetMethodSpecProperties(MetadataToken token);
    public sealed virtual MemberReferenceProperties GetMemberRefProperties(MetadataToken token);
    public sealed virtual string GetModuleRefProperties(MetadataToken token);
    public sealed virtual EventProperties GetEventProperties(MetadataToken token);
    public sealed virtual PropertyProperties GetPropertyProperties(MetadataToken token);
    public sealed virtual MetadataTokenRange GetCustomAttributes(MetadataToken ownerToken);
    public sealed virtual MetadataTypeReference GetCustomAttributeTypeRef(MetadataToken token);
    public sealed virtual CustomAttributeProperties GetCustomAttributeProperties(MetadataToken token);
    public sealed virtual MetadataTokenRange GetGenericParameters(MetadataToken ownerToken);
    public sealed virtual GenericParameterProperties GetGenericParamProperties(MetadataToken token);
    public sealed virtual MetadataTokenRange GetMethodDefs(MetadataToken typeToken);
    public sealed virtual MetadataTokenRange GetEvents(MetadataToken typeToken);
    public sealed virtual MetadataTokenRange GetProperties(MetadataToken typeToken);
    public sealed virtual MetadataTokenRange GetFields(MetadataToken typeToken);
    public sealed virtual IReadOnlyList`1<MetadataToken> GetNestedTypeDefs(MetadataToken typeToken);
    public sealed virtual MetadataToken GetEnclosingType(MetadataToken nestedTypeToken);
    public sealed virtual MetadataTokenRange GetInterfaceImplementations(MetadataToken typeToken);
    public sealed virtual InterfaceImplementationProperties GetInterfaceImplementationProperties(MetadataToken token);
    public sealed virtual MetadataTokenRange GetParameters(MetadataToken methodToken);
    public sealed virtual ParamProperties GetParameterProperties(MetadataToken token);
    public sealed virtual MetadataToken[] GetImplementedMethods(MetadataToken typeToken, MetadataToken methodBodyToken);
    public sealed virtual AssemblyNameInfo GetReferencedAssemblyName(MetadataToken token);
    public sealed virtual string GetUserString(MetadataToken token);
}
[IsReadOnlyAttribute]
public class JetBrains.Common.Util.Metadata.LowLevelMetadata.MethodSignatures.ArrayInfo : ValueType {
    [CompilerGeneratedAttribute]
private UInt32 <Rank>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32[] <Sizes>k__BackingField;
    [CompilerGeneratedAttribute]
private Int32[] <LBounds>k__BackingField;
    public UInt32 Rank { get; }
    public UInt32[] Sizes { get; }
    public Int32[] LBounds { get; }
    public ArrayInfo(UInt32 rank, UInt32[] sizes, Int32[] lBounds);
    [CompilerGeneratedAttribute]
public UInt32 get_Rank();
    [CompilerGeneratedAttribute]
public UInt32[] get_Sizes();
    [CompilerGeneratedAttribute]
public Int32[] get_LBounds();
    public sealed virtual bool Equals(ArrayInfo other);
}
[IsReadOnlyAttribute]
public class JetBrains.Common.Util.Metadata.LowLevelMetadata.MethodSignatures.BaseTypeInfo : ValueType {
    [CompilerGeneratedAttribute]
private Nullable`1<ElementType> <WellKnownType>k__BackingField;
    [CompilerGeneratedAttribute]
private MetadataToken <TypeDefOrRefToken>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<GenericArgumentInfo> <GenericArgument>k__BackingField;
    [CompilerGeneratedAttribute]
private object <FunctionSignature>k__BackingField;
    public Nullable`1<ElementType> WellKnownType { get; }
    public MetadataToken TypeDefOrRefToken { get; }
    public Nullable`1<GenericArgumentInfo> GenericArgument { get; }
    public object FunctionSignature { get; }
    public BaseTypeInfo(ElementType wellKnownType);
    public BaseTypeInfo(MetadataToken typeDefOrRefToken);
    public BaseTypeInfo(GenericArgumentInfo genericArgument);
    public BaseTypeInfo(MethodSignatureInfo functionSignature);
    [CompilerGeneratedAttribute]
public Nullable`1<ElementType> get_WellKnownType();
    [CompilerGeneratedAttribute]
public MetadataToken get_TypeDefOrRefToken();
    [CompilerGeneratedAttribute]
public Nullable`1<GenericArgumentInfo> get_GenericArgument();
    [CompilerGeneratedAttribute]
public object get_FunctionSignature();
    public bool Equals(BaseTypeInfo other, IEqualityComparer`1<MetadataToken> typeTokensEqualityComparer);
    public sealed virtual bool Equals(BaseTypeInfo other);
    public int GetHashCode(IEqualityComparer`1<MetadataToken> typeTokensEqualityComparer);
    public virtual string ToString();
}
[IsReadOnlyAttribute]
public class JetBrains.Common.Util.Metadata.LowLevelMetadata.MethodSignatures.GenericArgumentInfo : ValueType {
    [CompilerGeneratedAttribute]
private UInt32 <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private TypeParameterKind <Kind>k__BackingField;
    public UInt32 Index { get; }
    public TypeParameterKind Kind { get; }
    public GenericArgumentInfo(UInt32 index, TypeParameterKind kind);
    [CompilerGeneratedAttribute]
public UInt32 get_Index();
    [CompilerGeneratedAttribute]
public TypeParameterKind get_Kind();
    public sealed virtual bool Equals(GenericArgumentInfo other);
}
public static class JetBrains.Common.Util.Metadata.LowLevelMetadata.MethodSignatures.MetadataSignaturePresenter : object {
    private static string UnresolvedTypeName;
    private static string TypeGenericIndexPrefix;
    private static string MethodGenericIndexPrefix;
    private static string AnonymousTypeName;
    private static IDictionary`2<ElementType, string> ourWellKnownTypesCSharpNames;
    private static MetadataSignaturePresenter();
    public static string GetMethodSignaturePresentation(MetadataToken methodToken, MethodProperties methodProperties, MethodSignatureInfo signature, ILowLevelMetadata metadata, MethodSignatureSettings settings);
    public static string GetPropertySignaturePresentation(PropertyProperties propertyProperties, MethodSignatureInfo signature, ILowLevelMetadata metadata, MethodSignatureSettings settings);
    public static string GetTypePresentation(TypeInfo typeInfo, MetadataToken contextMethodToken, FrugalLocalList`1<MetadataToken> contextTypeTokensChain, ILowLevelMetadata metadata, TypeNamesSettings settings);
    private static string GetTypeNameForSignature(TypeInfo typeInfo, MetadataToken contextMethodToken, FrugalLocalList`1<MetadataToken> contextTypeTokensChain, ILowLevelMetadata metadata, TypeNamesSettings settings);
    private static string GetWellKnownTypeNameForSignature(ElementType type, TypeNamesSettings settings);
    private static string GetTypeDefNameForSignature(MetadataToken typeDefToken, TypeInfo[] genericArgTypes, MetadataToken contextMethodToken, FrugalLocalList`1<MetadataToken> contextTypeTokensChain, ILowLevelMetadata metadata, TypeNamesSettings settings);
    private static string GetTypeRefNameForSignature(MetadataToken typeRefToken, TypeInfo[] genericArgTypes, MetadataToken contextMethodToken, FrugalLocalList`1<MetadataToken> contextTypeTokensChain, ILowLevelMetadata metadata, TypeNamesSettings settings);
    private static string GetGenericArgTypeNameForSignature(GenericArgumentInfo genericArgumentInfo, MetadataToken contextMethodToken, MetadataToken contextTypeToken, ILowLevelMetadata metadata, TypeNamesSettings settings);
    private static string GetFunctionPointerTypeNameForSignature(MethodSignatureInfo functionSignature, MetadataToken contextMethodToken, FrugalLocalList`1<MetadataToken> contextTypeTokensChain, ILowLevelMetadata metadata, TypeNamesSettings settings);
}
[IsReadOnlyAttribute]
public class JetBrains.Common.Util.Metadata.LowLevelMetadata.MethodSignatures.MethodSignatureInfo : ValueType {
    [CompilerGeneratedAttribute]
private Prologs <SignatureFlags>k__BackingField;
    [CompilerGeneratedAttribute]
private TypeInfo <ReturnType>k__BackingField;
    [CompilerGeneratedAttribute]
private TypeInfo[] <ParameterTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private TypeInfo[] <VarargParameterTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <GenericArgumentsCount>k__BackingField;
    public Prologs SignatureFlags { get; }
    public bool IsVararg { get; }
    public bool HasThis { get; }
    public TypeInfo ReturnType { get; }
    public TypeInfo[] ParameterTypes { get; }
    public TypeInfo[] VarargParameterTypes { get; }
    public UInt32 GenericArgumentsCount { get; }
    public MethodSignatureInfo(Prologs signatureFlags, TypeInfo returnType, TypeInfo[] parameterTypes, TypeInfo[] varargParameterTypes, UInt32 genericArgumentsCount);
    [CompilerGeneratedAttribute]
public Prologs get_SignatureFlags();
    public bool get_IsVararg();
    public bool get_HasThis();
    [CompilerGeneratedAttribute]
public TypeInfo get_ReturnType();
    [CompilerGeneratedAttribute]
public TypeInfo[] get_ParameterTypes();
    [CompilerGeneratedAttribute]
public TypeInfo[] get_VarargParameterTypes();
    [CompilerGeneratedAttribute]
public UInt32 get_GenericArgumentsCount();
    public bool Equals(MethodSignatureInfo other, IEqualityComparer`1<MetadataToken> typeTokensEqualityComparer);
    public sealed virtual bool Equals(MethodSignatureInfo other);
    public int GetHashCode(IEqualityComparer`1<MetadataToken> typeTokensEqualityComparer, Int32[] contextTypeGenericArgumentsHashes);
}
public class JetBrains.Common.Util.Metadata.LowLevelMetadata.MethodSignatures.MethodSignatureInfoBuilder : object {
    public static MethodSignatureInfoBuilder Instance;
    public IMethodSignatureBuilder`2<TypeInfo, MethodSignatureInfo> MethodSignatureBuilder { get; }
    public bool IsLightweight { get; }
    private static MethodSignatureInfoBuilder();
    public sealed virtual ITypeBuilder`2<TypeInfo, MethodSignatureInfo> GetTypeBuilder(UInt32 methodGenericArgumentsCount);
    public sealed virtual IMethodSignatureBuilder`2<TypeInfo, MethodSignatureInfo> get_MethodSignatureBuilder();
    public sealed virtual MethodSignatureInfo BuildMethodSignature(Prologs signatureFlags, UInt32 genericArgumentsCount, TypeInfo returnType, TypeInfo[] parameterTypes, TypeInfo[] varargParameterTypes);
    public sealed virtual bool get_IsLightweight();
    public sealed virtual TypeInfo BuildUndecodedType();
    public sealed virtual TypeInfo BuildClassType(MetadataToken typeDefOrRefOrSpecToken);
    public sealed virtual TypeInfo BuildWellKnownType(ElementType type);
    public sealed virtual TypeInfo BuildTypeTypeParameter(UInt32 index);
    public sealed virtual TypeInfo BuildMethodTypeParameter(UInt32 index);
    public sealed virtual TypeInfo BuildFunctionPointer(MethodSignatureInfo signatureInfo);
    public sealed virtual TypeInfo BuildPointerType(TypeInfo type);
    public sealed virtual TypeInfo BuildReferenceType(TypeInfo type);
    public sealed virtual TypeInfo BuildArrayType(TypeInfo elementType, UInt32 rank, UInt32[] sizes, Int32[] lBounds);
    public sealed virtual TypeInfo BuildArrayType(TypeInfo elementType);
    public sealed virtual TypeInfo BuildGenericInst(TypeInfo type, TypeInfo[] args);
    public sealed virtual TypeInfo AddRequiredModifier(TypeInfo type, TypeInfo modifier);
    public sealed virtual TypeInfo AddOptionalModifier(TypeInfo type, TypeInfo modifier);
    public sealed virtual TypeInfo AddPinnedConstraint(TypeInfo type);
}
public class JetBrains.Common.Util.Metadata.LowLevelMetadata.MethodSignatures.TypeInfo : ValueType {
    private FrugalLocalList`1<TypeModifier> myTypeModifiers;
    private FrugalLocalList`1<MetadataToken> myModreqs;
    private FrugalLocalList`1<MetadataToken> myModopts;
    [CompilerGeneratedAttribute]
private BaseTypeInfo <BaseType>k__BackingField;
    [CompilerGeneratedAttribute]
private TypeInfo[] <GenericArgumentTypes>k__BackingField;
    public BaseTypeInfo BaseType { get; }
    public TypeInfo[] GenericArgumentTypes { get; private set; }
    public ReadOnlyFrugalLocalList`1<TypeModifier> TypeModifiers { get; }
    public ReadOnlyFrugalLocalList`1<MetadataToken> Modreqs { get; }
    public ReadOnlyFrugalLocalList`1<MetadataToken> Modopts { get; }
    public TypeInfo(BaseTypeInfo baseType);
    public TypeInfo(ElementType wellKnownType);
    public TypeInfo(MetadataToken typeDefOrRefToken);
    public TypeInfo(UInt32 genericArgumentIndex, TypeParameterKind typeParameterKind);
    public TypeInfo(MethodSignatureInfo functionSignature);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public BaseTypeInfo get_BaseType();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public TypeInfo[] get_GenericArgumentTypes();
    [CompilerGeneratedAttribute]
private void set_GenericArgumentTypes(TypeInfo[] value);
    public ReadOnlyFrugalLocalList`1<TypeModifier> get_TypeModifiers();
    public ReadOnlyFrugalLocalList`1<MetadataToken> get_Modreqs();
    public ReadOnlyFrugalLocalList`1<MetadataToken> get_Modopts();
    internal void SetGenericArgumentTypes(TypeInfo[] genericArgumentTypes);
    public void AddTypeModifier(TypeModifier modifier);
    public void AddRequiredModifier(MetadataToken modifierTypeToken);
    public void AddOptionalModifier(MetadataToken modifierTypeToken);
    public bool Equals(TypeInfo other, IEqualityComparer`1<MetadataToken> typeTokensEqualityComparer);
    public sealed virtual bool Equals(TypeInfo other);
    public int GetHashCode(IEqualityComparer`1<MetadataToken> typeTokensEqualityComparer, Int32[] contextTypeGenericArgumentsHashes);
    public virtual string ToString();
}
[IsReadOnlyAttribute]
public class JetBrains.Common.Util.Metadata.LowLevelMetadata.MethodSignatures.TypeModifier : ValueType {
    [CompilerGeneratedAttribute]
private TypeModifierKind <ModifierKind>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ArrayInfo> <ArrayInfo>k__BackingField;
    public TypeModifierKind ModifierKind { get; }
    public Nullable`1<ArrayInfo> ArrayInfo { get; }
    public TypeModifier(TypeModifierKind modifierKind, Nullable`1<ArrayInfo> arrayInfo);
    [CompilerGeneratedAttribute]
public TypeModifierKind get_ModifierKind();
    [CompilerGeneratedAttribute]
public Nullable`1<ArrayInfo> get_ArrayInfo();
    public sealed virtual bool Equals(TypeModifier other);
    public virtual int GetHashCode();
}
public enum JetBrains.Common.Util.Metadata.LowLevelMetadata.MethodSignatures.TypeModifierKind : Enum {
    public byte value__;
    public static TypeModifierKind Array;
    public static TypeModifierKind Reference;
    public static TypeModifierKind Pointer;
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.Metadata.MetadataAssembly.MetadataAssemblyExtensions : object {
    [ExtensionAttribute]
[CanBeNullAttribute]
public static TargetFrameworkId GetTargetFrameworkId(IMetadataAssembly metadataAssembly);
    [ExtensionAttribute]
public static IMetadataMethod TryGetMethod(IMetadataAssembly metadataAssembly, MetadataToken metadataToken);
    [ExtensionAttribute]
public static IMetadataProperty TryGetProperty(IMetadataAssembly metadataAssembly, MetadataToken metadataToken);
    [ExtensionAttribute]
public static IMetadataEvent TryGetEvent(IMetadataAssembly metadataAssembly, MetadataToken metadataToken);
    [ExtensionAttribute]
public static IMetadataTypeMember TryGetMetadataTypeMember(IMetadataAssembly metadataAssembly, MetadataToken metadataToken);
}
public static class JetBrains.Common.Util.Metadata.MetadataAssembly.MetadataEqualityComparer : object {
    private static ILogger ourLogger;
    private static MetadataEqualityComparer();
    public static bool AreEqualTypes(IMetadataType t1, IMetadataType t2);
    public static bool AreEqualMethods(IMetadataMethod m1, IMetadataMethod m2);
    private static bool AreEqualTypeInfos(IMetadataTypeInfo t1, IMetadataTypeInfo t2);
    private static bool AreEqualArrays(T[] l1, T[] l2, Func`3<T, T, bool> comparer);
    private static bool UintComparer(UInt32 u1, UInt32 u2);
    private static bool IntComparer(int u1, int u2);
    private static bool AreEqualParameters(IMetadataParameter a1, IMetadataParameter a2);
    private static bool AreEqualArrayTypes(IMetadataArrayType t1, IMetadataArrayType t2);
    private static bool AreEqualClassTypes(IMetadataClassType t1, IMetadataClassType t2);
    private static bool AreEqualMethodSignatures(MethodSignature t1, MethodSignature t2);
    private static bool AreEqualTypeParameters(IMetadataTypeParameter a1, IMetadataTypeParameter a2);
}
public static class JetBrains.Common.Util.Metadata.MetadataAssembly.MetadataSignaturesFactory : object {
    private static bool IsAnonymousTypeName(string name);
    [CanBeNullAttribute]
public static TypeInfoSignature CreateTypeInfoSignature(IMetadataTypeInfo typeInfo);
    private static string ExtractShortTypeName(string name);
    [NotNullAttribute]
public static TypeSignature CreateTypeSignature(IMetadataType type);
    [NotNullAttribute]
public static TypeSignature CreateGenericReferenceSignature(IMetadataTypeParameterReferenceType typeParameterReferenceType);
    [NotNullAttribute]
public static ReturnTypeOwnerSignature CreateReturnTypeOwnerSignature(IMetadataProperty property);
    [NotNullAttribute]
public static ReturnTypeOwnerSignature CreateReturnTypeOwnerSignature(IMetadataEvent event);
    [NotNullAttribute]
private static ParameterSignature CreateParameterSignature(IMetadataParameter parameter);
    private static ParameterSignature CreateFunctionParameterSignature(IMetadataType parameterType);
    [NotNullAttribute]
private static FunctionSignature CreateFunctionSignature(MethodSignature signature);
    [NotNullAttribute]
public static MethodSignature CreateMethodSignature(IMetadataMethod method, bool skipCompilerGeneratedParameters);
    [CanBeNullAttribute]
public static ISignature CreateTypeMemberSignature(IMetadataTypeMember metadataTypeMember, bool skipCompilerGeneratedParameters);
}
public static class JetBrains.Common.Util.Metadata.MetadataAssembly.MetadataTokensMapper : object {
    public static MetadataToken MapToken(IMetadataAssembly sourceAssembly, MetadataToken sourceToken, IMetadataAssembly targetAssembly);
    private static MetadataToken MapMethodToken(IMetadataAssembly sourceAssembly, MetadataToken sourceToken, IMetadataAssembly targetAssembly);
    private static MetadataToken MapTypeToken(IMetadataAssembly sourceAssembly, MetadataToken sourceToken, IMetadataAssembly targetAssembly);
    private static MetadataToken MapPropertyToken(IMetadataAssembly sourceAssembly, MetadataToken sourceToken, IMetadataAssembly targetAssembly);
    private static MetadataToken MapEventToken(IMetadataAssembly sourceAssembly, MetadataToken sourceToken, IMetadataAssembly targetAssembly);
    [AssertionMethodAttribute]
private static void AssertTokenTypeIsSupported(MetadataToken token);
}
public static class JetBrains.Common.Util.Metadata.MetadataNamesHelper : object {
    private static ILogger ourLogger;
    private static Regex ourLocalFuncNameRegex;
    private static MetadataNamesHelper();
    public static bool IsAnonymousType(string typeName);
    public static bool IsCompilerGeneratedTypeMemberName(string typeMemberName, String& parentMethodName, String& ownName);
    public static bool TryGetLocalFunctionName(string methodName, String& localFunctionName);
    public static string CutOffTypeGenericArgsInfo(string typeName);
    public static int GetGenericArgsCountByTypeName(string typeName);
}
public class JetBrains.Common.Util.Metadata.MetadataTypeNameParser : AbstractTypeNameParser`1<string> {
    public MetadataTypeNameParser(string typeName);
    protected virtual string CreateUnresolvedType(string typeName, TextRange typeNameRange);
    protected virtual string CreateTypeByNameAndAssembly(string typeName, TextRange typeNameRange, string assemblyName, TextRange assemblyNameRange, TextRange assemblyFullNameRange, String[] genericArguments);
    protected virtual string CreatePointerType(string elementType);
    protected virtual string CreateArrayType(string elementType, UInt32 rank, UInt32[] sizes, Int32[] lBounds);
    protected virtual string CreateArrayType(string elementType);
    protected virtual string CreateReferenceType(string elementType);
}
public class JetBrains.Common.Util.Metadata.ModuleDebugInfo : object {
    public static ModuleDebugInfo NoDebugInfo;
    public static ModuleDebugInfo AbsentDebugInfo;
    public bool NoDebugInfoData;
    [NotNullAttribute]
public IEnumerable`1<DebugInfo> Values;
    private ModuleDebugInfo(bool noDebugInfoData, IEnumerable`1<DebugInfo> debugInfos);
    private static ModuleDebugInfo();
    public static ModuleDebugInfo Build(IEnumerable`1<DebugInfo> debugInfos);
}
public static class JetBrains.Common.Util.Metadata.PdbReader.PdbHelper : object {
    public static FileSystemPath TryGetPdbFilePath(FileSystemPath assemblyPath);
}
public static class JetBrains.Common.Util.Metadata.TargetFrameworkIdHelper : object {
    [ContractAnnotationAttribute("targetFrameworkAttributeValue:null=>null")]
public static TargetFrameworkId CreateFromAssemblyTargetFrameworkAndPlatform(string targetFrameworkAttributeValue, string targetPlatformAttributeValue);
    private static bool IsDigit(char c);
}
public class JetBrains.SourceView.SourceModel.DecompileInfo : object {
    private FileSystemPath myOriginalModulePath;
    private FileSystemPath myLocalModulePath;
    public Guid Mvid;
    public MetadataToken MethodToken;
    public IAssemblyResolver Resolver;
    public string OwnerFullyQualifiedName;
    public FileSystemPath ModulePath { get; }
    public string Hash { get; }
    public DecompileInfo(FileSystemPath originalModulePath, Guid mvid, MetadataToken methodToken, IAssemblyResolver resolver, string ownerFullyQualifiedName);
    public void SetLocalModulePath(FileSystemPath localModulePath);
    public FileSystemPath get_ModulePath();
    public string get_Hash();
    public sealed virtual bool Equals(DecompileInfo other);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public static bool op_Equality(DecompileInfo i1, DecompileInfo i2);
    public static bool op_Inequality(DecompileInfo i1, DecompileInfo i2);
}
public interface JetBrains.SourceView.SourceModel.ISelectedSourceNodeProvider {
    public IDataProvider`1<TreeNodeInfo> CurrentNode { get; }
    public IDataProvider`1<Nullable`1<DateTime>> SnapshotTakenDate { get; }
    public abstract virtual IDataProvider`1<TreeNodeInfo> get_CurrentNode();
    public abstract virtual IDataProvider`1<Nullable`1<DateTime>> get_SnapshotTakenDate();
}
public class JetBrains.SourceView.SourceModel.TreeNodeInfo : object {
    public static TreeNodeInfo Empty;
    public static TreeNodeInfo Thread;
    public static TreeNodeInfo Unmanaged;
    public static TreeNodeInfo Geterogenious;
    public static TreeNodeInfo NoModule;
    public TreeNodeType NodeType;
    public FunctionSignatureInfo Signature;
    [CanBeNullAttribute]
public MeasureNode[] InjectInfo;
    [CanBeNullAttribute]
public DecompileInfo DecompileInfo;
    [NotNullAttribute]
public ModuleDebugInfo DebugInfo;
    private TreeNodeInfo(TreeNodeType nodeType);
    public TreeNodeInfo(FunctionSignatureInfo signature, MeasureNode[] injectInfo, DecompileInfo decompileInfo, ModuleDebugInfo debugInfo);
    private static TreeNodeInfo();
    public virtual int GetHashCode();
    public sealed virtual bool Equals(TreeNodeInfo other);
    public virtual bool Equals(object obj);
    public static bool op_Equality(TreeNodeInfo t1, TreeNodeInfo t2);
    public static bool op_Inequality(TreeNodeInfo t1, TreeNodeInfo t2);
}
public enum JetBrains.SourceView.SourceModel.TreeNodeType : Enum {
    public int value__;
    public static TreeNodeType HasSource;
    public static TreeNodeType Empty;
    public static TreeNodeType Thread;
    public static TreeNodeType Unmanaged;
    public static TreeNodeType Geterogenious;
    public static TreeNodeType NoModule;
}
public class JetBrains.SourceView.SourceServices.Interface.TextEditor.FunctionSignatureInfo : object {
    public string Name;
    public bool IsSetterFunction;
    public bool IsGetterFunction;
    public string PropertyName;
    public bool IsConstructor;
    public bool MayBeDelegate;
    public UInt32 Token;
    public FunctionSignatureInfo(UInt32 token, string name, bool isSetterFunction, bool isGetterFunction, string propertyName, bool isConstructor, bool mayBeDelegate);
    public static bool op_Equality(FunctionSignatureInfo s1, FunctionSignatureInfo s2);
    public static bool op_Inequality(FunctionSignatureInfo s1, FunctionSignatureInfo s2);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(FunctionSignatureInfo other);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
