internal static class JetBrains.Common.BuildScript.CommonNativeNames : object {
    public static string GetEtwApi(JetPlatform platform);
    public static string GetMemoryMappedStorage(JetPlatform platform);
    public static string GetMemoryMappedStorageApi(JetPlatform platform);
    public static string GetMemoryMappedStorageApiV10(JetPlatform platform);
    public static string GetTests(JetPlatform platform);
}
internal static class JetBrains.Common.BuildScript.CommonNativeTargets : object {
    private static string Prefix;
    public static string EtwApi;
    public static string MemoryMappedStorage;
    public static string MemoryMappedStorageApi;
    public static string Tests;
    [ObsoleteAttribute("Use MemoryMappedStorageApi. This version is no longer supported and is distributed as a .nuget package.")]
public static string MemoryMappedStorageApiV10;
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.AbsractTreeExtension : object {
    [IteratorStateMachineAttribute("JetBrains.Common.Util.AbsractTreeExtension/<TraverseTree>d__0`1")]
[ExtensionAttribute]
public static IEnumerable`1<T> TraverseTree(T root, Func`2<T, IEnumerable`1<T>> getChildren, Property`1<bool> isCanceled, bool reverseChildrenOrder);
    [ExtensionAttribute]
public static void Dfs(T treeNode, Func`2<T, IEnumerable`1<T>> getChildren, Action`1<T> handleNode);
    [ExtensionAttribute]
public static void Dfs(T treeNode, Func`2<T, IEnumerable`1<T>> getChildren, Action`2<T, int> handleNodeWithLevel, bool reverseChildrenOrder);
    [ExtensionAttribute]
public static void Dfs(IEnumerable`1<T> roots, Func`2<T, IEnumerable`1<T>> getChildren, Action`2<T, int> handleNodeWithLevel, bool reverseChildrenOrder);
    [IteratorStateMachineAttribute("JetBrains.Common.Util.AbsractTreeExtension/<GenerateTree>d__4`2")]
[ExtensionAttribute]
public static IEnumerable`1<TreeItem`1<TItem>> GenerateTree(IEnumerable`1<TItem> collection, Func`2<TItem, TId> idSelector, Func`2<TItem, TId> parentIDSelector, TId rootID);
    [IteratorStateMachineAttribute("JetBrains.Common.Util.AbsractTreeExtension/<GetPathToRoot>d__5`1")]
public static IEnumerable`1<T> GetPathToRoot(T node, Func`2<T, Nullable`1<T>> tryGetParent);
}
[ObsoleteAttribute("It is recommended to migrate to *TaskScheduler-s and System.Tasks")]
public class JetBrains.Common.Util.ActionTask : AsyncTaskBase {
    private Action`1<IExecutionControllerOld> myAction;
    public ActionTask(Action`1<IExecutionControllerOld> action, string title);
    protected virtual void DoExecute(IExecutionControllerOld executionController);
}
public static class JetBrains.Common.Util.AdjacencyListEx : object {
    public static int GetReferencesCount(int nodeNumber, IReadOnlyList`1<int> referencesIndexOf, int referencesCount);
}
public class JetBrains.Common.Util.AdjacencyListEx`1 : object {
    private IReadOnlyList`1<int> myArcStarts;
    private IReadOnlyList`1<T> myArcEnds;
    public int Count { get; }
    public AdjacencyListEx`1(IReadOnlyList`1<int> arcStart, IReadOnlyList`1<T> arcEnds);
    public int get_Count();
    public int GetReferencesCount(int vertexNumber);
    public ReadonlyListSegment`1<T> GetReferencesOf(int vertexNumber);
}
public static class JetBrains.Common.Util.Are : object {
    public static bool AllNull(Object[] args);
    public static bool AnyNull(Object[] args);
    public static bool AllNotNull(Object[] args);
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Common.Util.ArrayBuffer`1 : object {
    private int mySize;
    private T[] myArray;
    public int Length { get; }
    public T Item { get; }
    public int Count { get; }
    public int get_Length();
    public void SetSize(int size);
    public GCHandle PinObject();
    public sealed virtual T get_Item(int i);
    [IteratorStateMachineAttribute("JetBrains.Common.Util.ArrayBuffer`1/<GetEnumerator>d__8")]
public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual int get_Count();
    public T[] ToArray();
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.AsyncOperationExtensions : object {
    [ExtensionAttribute]
public static IAsyncOperation`1<T> BindToProgressIndicator(IAsyncOperation`1<T> operation, ProgressIndicator progress, Lifetime lifetime);
    [ExtensionAttribute]
public static Lifetime BindToProgressIndicator(IAsyncOperation operation, IProgressIndicator progress, Lifetime lifetime);
    [ExtensionAttribute]
public static void BindToExecutionController(IAsyncOperation operation, IExecutionControllerOld progress);
    [ExtensionAttribute]
public static IDataProvider`1<bool> ToIsCalculatingProvider(IAsyncOperation operation);
    [ExtensionAttribute]
public static ProgressProvider Flatten(IDataProvider`1<ProgressProvider> provider);
}
[ObsoleteAttribute("It is recommended to migrate to *TaskScheduler-s and System.Tasks")]
public class JetBrains.Common.Util.AsyncTask`1 : AsyncTaskBase {
    private Func`2<IExecutionControllerOld, TResult> myFunction;
    private TResult myResult;
    public AsyncTask`1(Func`2<IExecutionControllerOld, TResult> function, string title);
    public sealed virtual TResult GetResult();
    protected virtual void DoExecute(IExecutionControllerOld executionController);
}
[ObsoleteAttribute("It is recommended to migrate to *TaskScheduler-s and System.Tasks")]
public class JetBrains.Common.Util.AsyncTaskBase : object {
    private object myOperationProgressAccess;
    private double myOperationProgress;
    private int myStepsCount;
    private double myFactor;
    private AsyncTaskBase myParent;
    private int myParentStepsCount;
    private double myParentFactor;
    private ObservableCollection`1<IAsyncOperation> mySubOperations;
    private object myTaskFinishedAccess;
    private object myCancelAccess;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) myIsFinished;
    private bool myIsStarted;
    private EventHandler`2<ITask, EventArgs> myTaskFinished;
    private ITaskExecutionEnvironment myExecutionEnvironment;
    private ManualResetEvent myFinishedEvent;
    private string myTitle;
    private IExecutionControllerOld myExecutionController;
    private double myLastSubmitted;
    private bool myIsDisposed;
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsCanceled>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHandler`2<IAsyncOperation, ProgressChangedEventArgs> OperationProgressChanged;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    public bool Completed { get; }
    public Exception Exception { get; private set; }
    public EventWaitHandle FinishedEvent { get; }
    public string Title { get; private set; }
    public bool CanCancel { get; }
    public bool IsCanceled { get; private set; }
    public int OperationProgress { get; }
    public IEnumerable`1<IAsyncOperation> SubOperations { get; }
    protected AsyncTaskBase(string title);
    private AsyncTaskBase(AsyncTaskBase parent, int parentStepsCount);
    private void StartProgress(int stepsCount, string operationName);
    private IExecutionControllerOld CreateSubOperation(int parentStepsCount);
    private void Yield();
    private void AdvanceProgress();
    private void AttachTask(ITask task, int parentStepsCount, bool isShared);
    private void FireTaskAttached(ITask task, bool isShared);
    private void FireWaitForTask(ITask task, bool isShared);
    private void WaitForTask(ITask task, int parentStepsCount, bool isShared);
    private void Dispose();
    private void RaiseOperationProgressChanged();
    public sealed virtual bool get_Completed();
    public sealed virtual void Execute(ITaskExecutionEnvironment executionEnvironment);
    private void OnFinished();
    [CompilerGeneratedAttribute]
public sealed virtual Exception get_Exception();
    [CompilerGeneratedAttribute]
private void set_Exception(Exception value);
    public sealed virtual EventWaitHandle get_FinishedEvent();
    public sealed virtual string get_Title();
    private void set_Title(string value);
    public sealed virtual bool get_CanCancel();
    public sealed virtual void Cancel();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsCanceled();
    [CompilerGeneratedAttribute]
private void set_IsCanceled(bool value);
    public sealed virtual int get_OperationProgress();
    [CompilerGeneratedAttribute]
public sealed virtual void add_OperationProgressChanged(EventHandler`2<IAsyncOperation, ProgressChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_OperationProgressChanged(EventHandler`2<IAsyncOperation, ProgressChangedEventArgs> value);
    public sealed virtual IEnumerable`1<IAsyncOperation> get_SubOperations();
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    public sealed virtual void add_Finished(EventHandler`2<ITask, EventArgs> value);
    public sealed virtual void remove_Finished(EventHandler`2<ITask, EventArgs> value);
    protected virtual void DoExecute(IExecutionControllerOld executionController);
    private void AttachSubOperation(ITask task, int parentStepsCount);
    private void SetProgress(double value, Boolean& fireProgressChanged);
    private void AdvanceOperationProgress(double value);
}
public class JetBrains.Common.Util.BackgroundRoutine : object {
    private Action myRoutineAction;
    private AutoResetEvent myRoutineWakeup;
    private Thread myThread;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) myStopRoutine;
    public BackgroundRoutine(string name, Action routineAction);
    private void Routine();
    public void WakeUp();
    public void Join();
    public sealed virtual void Dispose();
}
public class JetBrains.Common.Util.BinaryHeap`1 : object {
    private List`1<T> myStorage;
    private Comparison`1<T> myComparison;
    public int Count { get; }
    public T Top { get; }
    public Comparison`1<T> Comparison { get; }
    public BinaryHeap`1(IEnumerable`1<T> storage);
    public BinaryHeap`1(Comparison`1<T> comparison);
    public BinaryHeap`1(IEnumerable`1<T> storage, Comparison`1<T> comparison);
    public sealed virtual int get_Count();
    public sealed virtual T get_Top();
    public sealed virtual T Pop();
    public sealed virtual void Push(T value);
    public sealed virtual Comparison`1<T> get_Comparison();
    private void AdjustHeap(int holeIndex, T value);
    private void Push(int holeIndex, int topIndex, T value);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.BlittableHelper : object {
    public static bool IsBlittable();
    [ExtensionAttribute]
private static bool IsBlittable(Type type);
}
public static class JetBrains.Common.Util.BuildScript.RequestDotCommonCleanCompile : object {
    [BuildStepAttribute]
public static ValidateCleanCompilation Yield();
}
public class JetBrains.Common.Util.CacheSource`1 : object {
    [CompilerGeneratedAttribute]
private T <Data>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Version>k__BackingField;
    public T Data { get; private set; }
    public long Version { get; private set; }
    public CacheSource`1(T data, long version);
    [CompilerGeneratedAttribute]
public sealed virtual T get_Data();
    [CompilerGeneratedAttribute]
private void set_Data(T value);
    [CompilerGeneratedAttribute]
public sealed virtual long get_Version();
    [CompilerGeneratedAttribute]
private void set_Version(long value);
    public sealed virtual bool Equals(CacheSource`1<T> other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.CacheSourceEx : object {
    [ExtensionAttribute]
public static IDataProvider`1<ICacheSource`1<T>> AsCacheSource(IDataProvider`1<T> source, Func`2<T, long> version);
    [ExtensionAttribute]
public static IDataProvider`1<ICacheSource`1<T>> AsCacheSource(IDataProvider`1<T> source, long version);
    [ExtensionAttribute]
public static IDataProvider`1<ICacheSource`1<T>> AsCacheSourceSafe(IDataProvider`1<T> source, Func`2<T, long> version);
    [ExtensionAttribute]
public static IDataProvider`1<ICacheSource`1<T>> AsCacheSourceSafe(IDataProvider`1<T> source, long version);
    public static ICacheSource`1<T> Create(T src, long version);
    public static ICacheSource`1<T> Create(T src);
    [ExtensionAttribute]
public static IDataProvider`1<ICacheSource`1<TC>> CombineSafeCache(IDataProvider`1<ICacheSource`1<TA>> src1, IDataProvider`1<ICacheSource`1<TB>> src2, Func`3<TA, TB, TC> converter);
    [ExtensionAttribute]
public static IDataProvider`1<ICacheSource`1<TD>> CombineCache(IDataProvider`1<ICacheSource`1<TA>> src1, IDataProvider`1<ICacheSource`1<TB>> src2, IDataProvider`1<ICacheSource`1<TC>> src3, Func`4<TA, TB, TC, TD> converter);
    [ExtensionAttribute]
public static IDataProvider`1<ICacheSource`1<TD>> CombineSafeCache(IDataProvider`1<ICacheSource`1<TA>> src1, IDataProvider`1<ICacheSource`1<TB>> src2, IDataProvider`1<ICacheSource`1<TC>> src3, Func`4<TA, TB, TC, TD> converter);
    [ExtensionAttribute]
public static IDataProvider`1<ICacheSource`1<TE>> CombineSafeCache(IDataProvider`1<ICacheSource`1<TA>> src1, IDataProvider`1<ICacheSource`1<TB>> src2, IDataProvider`1<ICacheSource`1<TC>> src3, IDataProvider`1<ICacheSource`1<TD>> src4, Func`5<TA, TB, TC, TD, TE> converter);
    [ExtensionAttribute]
public static IDataProvider`1<ICacheSource`1<TF>> CombineSafeCache(IDataProvider`1<ICacheSource`1<TA>> src1, IDataProvider`1<ICacheSource`1<TB>> src2, IDataProvider`1<ICacheSource`1<TC>> src3, IDataProvider`1<ICacheSource`1<TD>> src4, IDataProvider`1<ICacheSource`1<TE>> src5, Func`6<TA, TB, TC, TD, TE, TF> converter);
    [ExtensionAttribute]
public static IDataProvider`1<ICacheSource`1<TF>> CombineCache(IDataProvider`1<ICacheSource`1<TA>> src1, IDataProvider`1<ICacheSource`1<TB>> src2, IDataProvider`1<ICacheSource`1<TC>> src3, IDataProvider`1<ICacheSource`1<TD>> src4, IDataProvider`1<ICacheSource`1<TE>> src5, Func`6<TA, TB, TC, TD, TE, TF> converter);
    [ExtensionAttribute]
public static IDataProvider`1<ICacheSource`1<TG>> CombineSafeCache(IDataProvider`1<ICacheSource`1<TA>> src1, IDataProvider`1<ICacheSource`1<TB>> src2, IDataProvider`1<ICacheSource`1<TC>> src3, IDataProvider`1<ICacheSource`1<TD>> src4, IDataProvider`1<ICacheSource`1<TE>> src5, IDataProvider`1<ICacheSource`1<TF>> src6, Func`7<TA, TB, TC, TD, TE, TF, TG> converter);
    [ExtensionAttribute]
[NotNullAttribute]
public static IDataProvider`1<ICacheSource`1<TB>> TransformCache(IDataProvider`1<ICacheSource`1<TA>> provider, Func`2<TA, TB> converter);
    [ExtensionAttribute]
[NotNullAttribute]
public static IDataProvider`1<ICacheSource`1<TB>> TransformCacheSafe(IDataProvider`1<ICacheSource`1<TA>> provider, Func`2<TA, TB> converter);
    [ExtensionAttribute]
[NotNullAttribute]
public static IAsyncDataProvider`1<ICacheSource`1<TB>> TransformCacheSafe(IAsyncDataProvider`1<ICacheSource`1<TA>> provider, Func`3<TA, IExecutionController, TB> converter);
    [ExtensionAttribute]
[NotNullAttribute]
public static IDataProvider`1<TA> UnpackCache(IDataProvider`1<ICacheSource`1<TA>> provider);
    public static long CombineVersion(long v1, long v2, long v3);
    public static long CombineVersion(long v1, long v2, long v3, long v4);
    public static long CombineVersion(long v1, long v2, long v3, long v4, long v5);
    public static long CombineVersion(long v1, long v2, long v3, long v4, long v5, long v6);
    public static long CombineVersion(long v1, long v2);
}
[ObsoleteAttribute("It is recommended to migrate to *TaskScheduler-s and System.Tasks")]
public class JetBrains.Common.Util.CancellableTaskExecutor : object {
    private static CancellableTaskExecutor ourInstance;
    private static CancellableTaskExecutor Instance { get; }
    public sealed virtual void Cancel(ITask sender);
    public sealed virtual void Yield(ITask sender);
    public sealed virtual void WaitForTask(ITask sender, ITask otherTask, bool isShared);
    public sealed virtual void AttachTask(ITask sender, ITask otherTask, bool isShared);
    private static CancellableTaskExecutor get_Instance();
    public static void Execute(ITask task);
    public static void ExecuteAsync(ITask task);
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Common.Util.ChunkListBasedStorage`2 : object {
    private Func`2<TIndex, int> myIndexConverter;
    private ChunkList`1<TData> myStorage;
    public TData Item { get; public set; }
    public int Count { get; }
    public ChunkListBasedStorage`2(Func`2<TIndex, int> indexConverter, int capacity);
    public TData SafeGet(TIndex indexStructure);
    public TData get_Item(TIndex index);
    public void set_Item(TIndex index, TData value);
    public void Add(TIndex index, TData data);
    public void Clear();
    public int get_Count();
    public sealed virtual IEnumerator`1<TData> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class JetBrains.Common.Util.ChunkQueue`1 : object {
    private ChunkArray`1<T> myArray;
    private int myLength;
    private int myTail;
    private int myHead;
    private int myVersion;
    private int myCount;
    private static int DefaultCapacity;
    public bool IsEmpty { get; }
    public int Count { get; }
    public void Enqueue(T value);
    public T Peek();
    public T Dequeue();
    public bool get_IsEmpty();
    private static void CopyTo(IArray`1<T> src, IArray`1<T> dst, int srcIndex, int dstIndex, int len);
    public int get_Count();
    private void SetCapacity(int len);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public static class JetBrains.Common.Util.Collection : object {
    public static ListEvents`1<T> CreateList(ReadonlyToken readonlyToken);
    public static DictionaryEvents`2<TKey, TValue> CreateDictionary(ReadonlyToken readonlyToken);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.CollectionDataProvidersExtension : object {
    private static string Id;
    private static CollectionDataProvidersExtension();
    [ExtensionAttribute]
public static IDictionaryEvents`2<TTargetKey, TTargetValue> TransformEachItem(IDictionaryEvents`2<TSourceKey, TSourceValue> source, Lifetime lifetime, Func`2<KeyValuePair`2<TSourceKey, TSourceValue>, KeyValuePair`2<TTargetKey, TTargetValue>> transform);
    [ExtensionAttribute]
public static IReadonlyListEvents`1<TTarget> TransformEachItem(IDictionaryEvents`2<TSourceKey, TSourceValue> source, Lifetime lifetime, Func`2<KeyValuePair`2<TSourceKey, TSourceValue>, TTarget> transform);
    [ExtensionAttribute]
public static IReadonlyListEvents`1<TTarget> TransformEachItem(IReadonlyCollectionEvents`1<TSource> source, Lifetime lifetime, Pipeline`2<TSource, TTarget> transformPipeline, Func`2<TSource, bool> filter);
    [ExtensionAttribute]
public static IReadonlyListEvents`1<T> TransformReverse(IReadonlyListEvents`1<T> source, Lifetime lifetime, Func`2<T, bool> filter);
    [ExtensionAttribute]
public static IReadonlyListEvents`1<TTarget> CastEachItem(IReadonlyCollectionEvents`1<TSource> source, Lifetime lifetime);
    [ExtensionAttribute]
public static IReadonlyListEvents`1<TTarget> TransformEachItem(IReadonlyCollectionEvents`1<TSource> source, Lifetime lifetime, Func`2<TSource, TTarget> transform, Func`2<TSource, bool> filter);
    [ExtensionAttribute]
public static IReadonlyListEvents`1<TTarget> TransformEachItem(IReadonlyCollectionEvents`1<TSource> source, Lifetime lifetime, Func`3<Lifetime, TSource, TTarget> transform, Func`2<TSource, bool> filter);
    [ExtensionAttribute]
public static IReadonlyListEvents`1<TSource> CopyEachItemTo(IReadonlyCollectionEvents`1<TSource> source, Lifetime lifetime, IListEvents`1<TSource> target, Func`2<TSource, bool> filter);
    [ExtensionAttribute]
public static ListEvents`1<TSource> TransformFromProviderOrdered(IReadonlyListEvents`1<IDataProvider`1<TSource>> source, Lifetime lifetime, Func`2<TSource, bool> filter);
    [ExtensionAttribute]
public static IReadonlyListEvents`1<T> WhereNotNullLive(IReadonlyCollectionEvents`1<IDataProvider`1<T>> source, Lifetime lifetime);
    [ExtensionAttribute]
public static IReadonlyListEvents`1<TTarget> TransformEachItemWithPrevious(IReadonlyListEvents`1<TSource> source, Lifetime lifetime, Func`3<TSource, TSource, TTarget> transform, Func`3<TSource, TSource, bool> filter);
    [ExtensionAttribute]
public static IDataProvider`1<TA> ToItemDataProvider(IReadonlyCollectionEvents`1<TA> collection, Lifetime lifetime, Predicate`1<TA> itemSelector);
    [ExtensionAttribute]
public static IDataProvider`1<TA> ToLastItemDataProvider(IReadonlyCollectionEvents`1<TA> collection, Lifetime lifetime);
    [ExtensionAttribute]
[NotNullAttribute]
public static IDataProvider`1<int> CreateCountProvider(IReadonlyCollectionEvents`1<T> thіs, Lifetime lifetime);
    [ExtensionAttribute]
public static IReadonlyListEvents`1<T> ToList(IDataProvider`1<T> source, Lifetime lifetime, Predicate`1<T> filter);
    [LocalizableAttribute("False")]
private static string MakeLifetimeId(string name);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.CollectionEventsExtension : object {
    private static string DebugId;
    private static CollectionEventsExtension();
    [ExtensionAttribute]
public static IDictionaryEvents`2<TValue, ListEvents`1<TItem>> GroupByLive(IReadonlyListEvents`1<TItem> source, Lifetime lifetime, Func`2<TItem, IProperty`1<TValue>> getProperty, IEqualityComparer`1<TValue> comparer);
    [ExtensionAttribute]
public static void FlowIntoSortedLive(IReadonlyCollectionEvents`1<TItem> source, Lifetime lifetime, IListEvents`1<TItem> target, Func`2<TItem, IProperty`1<TValue>> getProperty, IComparer`1<TValue> comparerForSorting, object cookie);
    [ExtensionAttribute]
public static void Advise(IReadonlyCollectionEvents`1<TValue> thіs, FullLifetime fullLifetime, Action`2<FullLifetime, TValue> handler);
    [ExtensionAttribute]
public static void Advise(IReadonlyCollectionEvents`1<TValue> thіs, Lifetime lifetime, Action`2<FullLifetime, TValue> handler);
    [ExtensionAttribute]
private static void ForEachItemCore(IReadonlyCollectionEvents`1<TValue> thіs, FullLifetime fullLifetime, Action`2<FullLifetime, TValue> FHandlerA, Action`3<FullLifetime, TValue, object> FHandlerB);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.CollectionExtensions : object {
    [ExtensionAttribute]
public static bool IsEqualTo(IEnumerable`1<T> left, IEnumerable`1<T> right);
    [ExtensionAttribute]
public static bool IsEqualTo(IReadOnlyCollection`1<T> left, IReadOnlyCollection`1<T> right);
    [ExtensionAttribute]
public static int BinarySearch(IList`1<T> list, T item, IComparer`1<T> comparer);
    [ExtensionAttribute]
public static int BinarySearch(T[] array, T item);
    [ExtensionAttribute]
public static int BinarySearch(IList`1<T> list, T item, Comparison`1<T> comparison);
    [ExtensionAttribute]
public static int BinarySearch(IReadOnlyList`1<T> list, T item, Comparison`1<T> comparer);
    [ExtensionAttribute]
public static int BinarySearch(IReadOnlyList`1<T> list, T item);
    [ExtensionAttribute]
public static int BinarySearch(IReadOnlyList`1<T> list, Locator`1<T> locator);
    [ExtensionAttribute]
public static int BinarySearch(IReadOnlyList`1<T> list, int index, int length, Locator`1<T> locator);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static T FindSorted(IReadOnlyList`1<T> collection, Func`2<T, int> comparer);
    [ExtensionAttribute]
[LocalizableAttribute("False")]
public static int InsertSorted(IList`1<T> list, T value, Comparison`1<T> comparison, bool allowDupicates);
    [ExtensionAttribute]
public static int SortedIndexOf(IReadOnlyList`1<T> list, Func`2<T, int> comparer);
    [ExtensionAttribute]
public static int SortedIndexOf(IReadOnlyList`1<T> list, T value);
    [ExtensionAttribute]
public static int SortedIndexOf(IList`1<T> list, Func`2<T, int> comparer);
    [ExtensionAttribute]
public static void Fill(IList`1<T> list, T item);
    [ExtensionAttribute]
public static void Clear(T[] array);
    [ExtensionAttribute]
public static T[] Sort(T[] array);
    [ExtensionAttribute]
public static int IndexWhere(IEnumerable`1<T> array, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static void RemoveWhere(LinkedList`1<T> list, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static bool RemoveFirstWhere(IList`1<T> list, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static void RemoveAll(ICollection`1<T> source, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static void RemoveAll(ICollection`1<T> source, IEnumerable`1<T> toRemove);
    [IteratorStateMachineAttribute("JetBrains.Common.Util.CollectionExtensions/<IndicesWhere>d__22`1")]
[ExtensionAttribute]
public static IEnumerable`1<int> IndicesWhere(IEnumerable`1<T> array, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static IEnumerable`1<T> Extend(IEnumerable`1<T> source, int n, Func`1<T> with);
    [ExtensionAttribute]
public static IEnumerable`1<T> Extend(IEnumerable`1<T> source, int n, T with);
    [ExtensionAttribute]
public static void CopyTo(IEnumerable`1<T> src, IArray`1<T> destination, int fromIndex);
    [ExtensionAttribute]
public static Object[] JoinParameters(Object[] parameters, Object[] toJoin);
    [ExtensionAttribute]
[ContractAnnotationAttribute("source: null => null; source: notnull => notnull")]
public static IReadOnlyCollection`1<T> Filter(IReadOnlyCollection`1<T> source, Func`2<T, bool> includeFilter);
    [ExtensionAttribute]
[NotNullAttribute]
public static IReadOnlyCollection`1<T> ToReadonly(ICollection`1<T> source);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.CollectionSynchronizerEx : object {
    [ExtensionAttribute]
public static void BindToLifetime(ICollectionSynchronizer synchronizer, Lifetime lifetime);
    [ExtensionAttribute]
public static ObservableCollection`1<TTarget> CreateSynchronizedList(IObservableSet`1<TSource> set, Func`2<TSource, TTarget> convert, Func`2<TTarget, TSource> convertBack, Lifetime lifetime);
    [ExtensionAttribute]
public static ObservableCollection`1<TTarget> CreateSynchronizedList(IList`1<TSource> set, Func`2<TSource, TTarget> convert, Func`2<TTarget, TSource> convertBack, Lifetime lifetime);
    [ExtensionAttribute]
public static IObservableSet`1<TTarget> CreateSynchronizedHashSet(IList`1<TSource> list, Func`2<TSource, TTarget> convert, Func`2<TTarget, TSource> convertBack, Lifetime lifetime);
    [ExtensionAttribute]
public static IObservableSet`1<TTarget> CreateSynchronizedSet(IList`1<TSource> list, ICollection`1<TTarget> targetCollection, Func`2<TSource, TTarget> convert, Func`2<TTarget, TSource> convertBack, Lifetime lifetime);
}
public static class JetBrains.Common.Util.CollectionUtils : object {
    public static IEnumerable`1<T> NotNull(T[] values);
}
internal abstract class JetBrains.Common.Util.CommandLine.ArgumentParser : object {
    [CompilerGeneratedAttribute]
private List`1<ParsingError> <PostParsingState>k__BackingField;
    public List`1<ParsingError> PostParsingState { get; }
    public abstract virtual ParserState Parse(IArgumentEnumerator argumentEnumerator, OptionMap map, object options);
    [CompilerGeneratedAttribute]
public List`1<ParsingError> get_PostParsingState();
    protected void DefineOptionThatViolatesFormat(OptionInfo option);
    public static ArgumentParser Create(string argument, bool ignoreUnknownArguments);
    public static bool IsInputValue(string argument);
    protected static IList`1<string> GetNextInputValues(IArgumentEnumerator ae);
    public static bool CompareShort(string argument, string option, bool caseSensitive);
    public static bool CompareLong(string argument, string option, bool caseSensitive);
    protected static ParserState BooleanToParserState(bool value);
    protected static ParserState BooleanToParserState(bool value, bool addMoveNextIfTrue);
    protected static void EnsureOptionAttributeIsArrayCompatible(OptionInfo option);
    protected static void EnsureOptionArrayAttributeIsNotBoundToScalar(OptionInfo option);
}
[AttributeUsageAttribute("1")]
[ComVisibleAttribute("True")]
public class JetBrains.Common.Util.CommandLine.AssemblyLicenseAttribute : MultiLineTextAttribute {
    public AssemblyLicenseAttribute(string line1);
    public AssemblyLicenseAttribute(string line1, string line2);
    public AssemblyLicenseAttribute(string line1, string line2, string line3);
    public AssemblyLicenseAttribute(string line1, string line2, string line3, string line4);
    public AssemblyLicenseAttribute(string line1, string line2, string line3, string line4, string line5);
}
[AttributeUsageAttribute("1")]
[ComVisibleAttribute("True")]
public class JetBrains.Common.Util.CommandLine.AssemblyUsageAttribute : MultiLineTextAttribute {
    public AssemblyUsageAttribute(string line1);
    public AssemblyUsageAttribute(string line1, string line2);
    public AssemblyUsageAttribute(string line1, string line2, string line3);
    public AssemblyUsageAttribute(string line1, string line2, string line3, string line4);
    public AssemblyUsageAttribute(string line1, string line2, string line3, string line4, string line5);
}
internal static class JetBrains.Common.Util.CommandLine.Assumes : object {
    public static void NotNull(T value, string paramName);
    public static void NotNullOrEmpty(string value, string paramName);
    public static void NotZeroLength(T[] array, string paramName);
}
public class JetBrains.Common.Util.CommandLine.BadOptionInfo : object {
    [CompilerGeneratedAttribute]
private string <ShortName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LongName>k__BackingField;
    public string ShortName { get; internal set; }
    public string LongName { get; internal set; }
    internal BadOptionInfo(string shortName, string longName);
    [CompilerGeneratedAttribute]
public string get_ShortName();
    [CompilerGeneratedAttribute]
internal void set_ShortName(string value);
    [CompilerGeneratedAttribute]
public string get_LongName();
    [CompilerGeneratedAttribute]
internal void set_LongName(string value);
}
public abstract class JetBrains.Common.Util.CommandLine.BaseOptionAttribute : Attribute {
    private string _shortName;
    private object _defaultValue;
    private bool _hasDefaultValue;
    [CompilerGeneratedAttribute]
private string <LongName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Required>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HelpText>k__BackingField;
    public string ShortName { get; internal set; }
    public string LongName { get; internal set; }
    public bool Required { get; public set; }
    public object DefaultValue { get; public set; }
    internal bool HasShortName { get; }
    internal bool HasLongName { get; }
    internal bool HasDefaultValue { get; }
    public string HelpText { get; public set; }
    public string get_ShortName();
    internal void set_ShortName(string value);
    [CompilerGeneratedAttribute]
public string get_LongName();
    [CompilerGeneratedAttribute]
internal void set_LongName(string value);
    [CompilerGeneratedAttribute]
public virtual bool get_Required();
    [CompilerGeneratedAttribute]
public virtual void set_Required(bool value);
    public object get_DefaultValue();
    public void set_DefaultValue(object value);
    internal bool get_HasShortName();
    internal bool get_HasLongName();
    internal bool get_HasDefaultValue();
    [CompilerGeneratedAttribute]
public string get_HelpText();
    [CompilerGeneratedAttribute]
public void set_HelpText(string value);
}
public abstract class JetBrains.Common.Util.CommandLine.BaseSentenceBuilder : object {
    public string OptionWord { get; }
    public string AndWord { get; }
    public string RequiredOptionMissingText { get; }
    public string ViolatesFormatText { get; }
    public string ViolatesMutualExclusivenessText { get; }
    public string ErrorsHeadingText { get; }
    public static BaseSentenceBuilder CreateBuiltIn();
    public abstract virtual string get_OptionWord();
    public abstract virtual string get_AndWord();
    public abstract virtual string get_RequiredOptionMissingText();
    public abstract virtual string get_ViolatesFormatText();
    public abstract virtual string get_ViolatesMutualExclusivenessText();
    public abstract virtual string get_ErrorsHeadingText();
}
public abstract class JetBrains.Common.Util.CommandLine.CommandLineOptionsBase : object {
    [CompilerGeneratedAttribute]
private PostParsingState <LastPostParsingState>k__BackingField;
    protected PostParsingState LastPostParsingState { get; }
    internal PostParsingState InternalLastPostParsingState { get; }
    [CompilerGeneratedAttribute]
protected PostParsingState get_LastPostParsingState();
    internal PostParsingState get_InternalLastPostParsingState();
}
public class JetBrains.Common.Util.CommandLine.CommandLineParser : object {
    private static ICommandLineParser DefaultParser;
    private CommandLineParserSettings _settings;
    public static ICommandLineParser Default { get; }
    private CommandLineParser(bool singleton);
    public CommandLineParser(CommandLineParserSettings settings);
    private static CommandLineParser();
    public static ICommandLineParser get_Default();
    public virtual bool ParseArguments(String[] args, object options);
    public virtual bool ParseArguments(String[] args, object options, TextWriter helpWriter);
    private bool DoParseArguments(String[] args, object options);
    private bool ParseHelp(String[] args, HelpOptionAttribute helpOption);
    private static void SetPostParsingStateIfNeeded(object options, IEnumerable`1<ParsingError> state);
}
public class JetBrains.Common.Util.CommandLine.CommandLineParserException : Exception {
    internal CommandLineParserException(string message);
    internal CommandLineParserException(string message, Exception innerException);
    internal CommandLineParserException(SerializationInfo info, StreamingContext context);
}
public class JetBrains.Common.Util.CommandLine.CommandLineParserSettings : object {
    private static bool CaseSensitiveDefault;
    [CompilerGeneratedAttribute]
private bool <CaseSensitive>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <MutuallyExclusive>k__BackingField;
    [CompilerGeneratedAttribute]
private TextWriter <HelpWriter>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreUnknownArguments>k__BackingField;
    internal bool CaseSensitive { get; public set; }
    internal bool MutuallyExclusive { get; public set; }
    internal TextWriter HelpWriter { get; public set; }
    internal bool IgnoreUnknownArguments { get; public set; }
    public CommandLineParserSettings(bool caseSensitive);
    public CommandLineParserSettings(TextWriter helpWriter);
    public CommandLineParserSettings(bool caseSensitive, TextWriter helpWriter);
    public CommandLineParserSettings(bool caseSensitive, bool mutuallyExclusive);
    public CommandLineParserSettings(bool caseSensitive, bool mutuallyExclusive, TextWriter helpWriter);
    public CommandLineParserSettings(bool caseSensitive, bool mutuallyExclusive, bool ignoreUnknownArguments, TextWriter helpWriter);
    [CompilerGeneratedAttribute]
internal bool get_CaseSensitive();
    [CompilerGeneratedAttribute]
public void set_CaseSensitive(bool value);
    [CompilerGeneratedAttribute]
internal bool get_MutuallyExclusive();
    [CompilerGeneratedAttribute]
public void set_MutuallyExclusive(bool value);
    [CompilerGeneratedAttribute]
internal TextWriter get_HelpWriter();
    [CompilerGeneratedAttribute]
public void set_HelpWriter(TextWriter value);
    [CompilerGeneratedAttribute]
internal bool get_IgnoreUnknownArguments();
    [CompilerGeneratedAttribute]
public void set_IgnoreUnknownArguments(bool value);
}
public class JetBrains.Common.Util.CommandLine.CopyrightInfo : object {
    private bool _isSymbolUpper;
    private Int32[] _years;
    private string _author;
    private static string DefaultCopyrightWord;
    private static string SymbolLower;
    private static string SymbolUpper;
    private int _builderSize;
    protected string CopyrightWord { get; }
    public CopyrightInfo(string author, int year);
    public CopyrightInfo(string author, Int32[] years);
    public CopyrightInfo(bool isSymbolUpper, string author, Int32[] years);
    public virtual string ToString();
    public static string op_Implicit(CopyrightInfo info);
    protected virtual string get_CopyrightWord();
    protected virtual string FormatYears(Int32[] years);
}
public class JetBrains.Common.Util.CommandLine.EnglishSentenceBuilder : BaseSentenceBuilder {
    public string OptionWord { get; }
    public string AndWord { get; }
    public string RequiredOptionMissingText { get; }
    public string ViolatesFormatText { get; }
    public string ViolatesMutualExclusivenessText { get; }
    public string ErrorsHeadingText { get; }
    public virtual string get_OptionWord();
    public virtual string get_AndWord();
    public virtual string get_RequiredOptionMissingText();
    public virtual string get_ViolatesFormatText();
    public virtual string get_ViolatesMutualExclusivenessText();
    public virtual string get_ErrorsHeadingText();
}
public class JetBrains.Common.Util.CommandLine.FormatOptionHelpTextEventArgs : EventArgs {
    private BaseOptionAttribute _option;
    public BaseOptionAttribute Option { get; }
    public FormatOptionHelpTextEventArgs(BaseOptionAttribute option);
    public BaseOptionAttribute get_Option();
}
public class JetBrains.Common.Util.CommandLine.HandleParsingErrorsDelegate : MulticastDelegate {
    public HandleParsingErrorsDelegate(object object, IntPtr method);
    public virtual void Invoke(HelpText current);
    public virtual IAsyncResult BeginInvoke(HelpText current, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class JetBrains.Common.Util.CommandLine.HeadingInfo : object {
    private string _programName;
    private string _version;
    public HeadingInfo(string programName);
    public HeadingInfo(string programName, string version);
    public virtual string ToString();
    public static string op_Implicit(HeadingInfo info);
    public void WriteMessage(string message, TextWriter writer);
    public void WriteMessage(string message);
    public void WriteError(string message);
}
[AttributeUsageAttribute("64")]
public class JetBrains.Common.Util.CommandLine.HelpOptionAttribute : BaseOptionAttribute {
    private static string DefaultHelpText;
    public bool Required { get; public set; }
    public HelpOptionAttribute(string shortName, string longName);
    public virtual bool get_Required();
    public virtual void set_Required(bool value);
    internal static void InvokeMethod(object target, Pair`2<MethodInfo, HelpOptionAttribute> pair, String& text);
    private static bool CheckMethodSignature(MethodInfo value);
}
public class JetBrains.Common.Util.CommandLine.HelpText : object {
    private static int BuilderCapacity;
    private static int DefaultMaximumLength;
    private Nullable`1<int> _maximumDisplayWidth;
    private string _heading;
    private string _copyright;
    private bool _additionalNewLineAfterOption;
    private StringBuilder _preOptionsHelp;
    private StringBuilder _optionsHelp;
    private StringBuilder _postOptionsHelp;
    private BaseSentenceBuilder _sentenceBuilder;
    private static string DefaultRequiredWord;
    private bool _addDashesToOption;
    [CompilerGeneratedAttribute]
private EventHandler`1<FormatOptionHelpTextEventArgs> FormatOptionHelpText;
    unknown string Heading {public set; }
    unknown string Copyright {public set; }
    public int MaximumDisplayWidth { get; public set; }
    public bool AddDashesToOption { get; public set; }
    public bool AdditionalNewLineAfterOption { get; public set; }
    public BaseSentenceBuilder SentenceBuilder { get; }
    public HelpText(BaseSentenceBuilder sentenceBuilder);
    public HelpText(string heading);
    public HelpText(BaseSentenceBuilder sentenceBuilder, string heading);
    public HelpText(string heading, string copyright);
    public HelpText(BaseSentenceBuilder sentenceBuilder, string heading, string copyright);
    public HelpText(string heading, string copyright, object options);
    public HelpText(BaseSentenceBuilder sentenceBuilder, string heading, string copyright, object options);
    [CompilerGeneratedAttribute]
public void add_FormatOptionHelpText(EventHandler`1<FormatOptionHelpTextEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_FormatOptionHelpText(EventHandler`1<FormatOptionHelpTextEventArgs> value);
    public static HelpText AutoBuild(object options);
    public static HelpText AutoBuild(object options, HandleParsingErrorsDelegate errDelegate);
    public static void DefaultParsingErrorsHandler(CommandLineOptionsBase options, HelpText current);
    public void set_Heading(string value);
    public void set_Copyright(string value);
    public int get_MaximumDisplayWidth();
    public void set_MaximumDisplayWidth(int value);
    public bool get_AddDashesToOption();
    public void set_AddDashesToOption(bool value);
    public bool get_AdditionalNewLineAfterOption();
    public void set_AdditionalNewLineAfterOption(bool value);
    public BaseSentenceBuilder get_SentenceBuilder();
    public void AddPreOptionsLine(string value);
    private void AddPreOptionsLine(string value, int maximumLength);
    public void AddPostOptionsLine(string value);
    public void AddOptions(object options);
    public void AddOptions(object options, string requiredWord);
    public void AddOptions(object options, string requiredWord, int maximumLength);
    public string RenderParsingErrorsText(CommandLineOptionsBase options, int indent);
    private void AddOption(string requiredWord, int maxLength, BaseOptionAttribute option, int widthOfHelpText);
    public virtual string ToString();
    public static string op_Implicit(HelpText info);
    private void AddLine(StringBuilder builder, string value);
    private static void AddLine(StringBuilder builder, string value, int maximumLength);
    private static int GetLength(string value);
    private static int GetLength(StringBuilder value);
    private int GetMaxLength(IEnumerable`1<BaseOptionAttribute> optionList);
    protected virtual void OnFormatOptionHelpText(FormatOptionHelpTextEventArgs e);
}
internal interface JetBrains.Common.Util.CommandLine.IArgumentEnumerator {
    public string Next { get; }
    public bool IsLast { get; }
    public string Current { get; }
    public abstract virtual string GetRemainingFromNext();
    public abstract virtual string get_Next();
    public abstract virtual bool get_IsLast();
    public abstract virtual bool MoveNext();
    public abstract virtual bool MovePrevious();
    public abstract virtual string get_Current();
}
public interface JetBrains.Common.Util.CommandLine.ICommandLineParser {
    public abstract virtual bool ParseArguments(String[] args, object options);
    public abstract virtual bool ParseArguments(String[] args, object options, TextWriter helpWriter);
}
internal class JetBrains.Common.Util.CommandLine.LongOptionParser : ArgumentParser {
    private bool _ignoreUnkwnownArguments;
    public LongOptionParser(bool ignoreUnkwnownArguments);
    public virtual ParserState Parse(IArgumentEnumerator argumentEnumerator, OptionMap map, object options);
}
public abstract class JetBrains.Common.Util.CommandLine.MultiLineTextAttribute : Attribute {
    private string _line1;
    private string _line2;
    private string _line3;
    private string _line4;
    private string _line5;
    protected MultiLineTextAttribute(string line1);
    protected MultiLineTextAttribute(string line1, string line2);
    protected MultiLineTextAttribute(string line1, string line2, string line3);
    protected MultiLineTextAttribute(string line1, string line2, string line3, string line4);
    protected MultiLineTextAttribute(string line1, string line2, string line3, string line4, string line5);
    internal void AddToHelpText(HelpText helpText, bool before);
}
internal class JetBrains.Common.Util.CommandLine.OneCharStringEnumerator : object {
    private string _currentElement;
    private int _index;
    private string _data;
    public string Current { get; }
    public string Next { get; }
    public bool IsLast { get; }
    public OneCharStringEnumerator(string value);
    public sealed virtual string get_Current();
    public sealed virtual string get_Next();
    public sealed virtual bool get_IsLast();
    public void Reset();
    public sealed virtual bool MoveNext();
    public sealed virtual string GetRemainingFromNext();
    public sealed virtual bool MovePrevious();
    private sealed virtual override void System.IDisposable.Dispose();
}
public class JetBrains.Common.Util.CommandLine.OptionArrayAttribute : OptionAttribute {
    public OptionArrayAttribute(string shortName, string longName);
}
[AttributeUsageAttribute("128")]
public class JetBrains.Common.Util.CommandLine.OptionAttribute : BaseOptionAttribute {
    private string _uniqueName;
    private string _mutuallyExclusiveSet;
    internal static string DefaultMutuallyExclusiveSet;
    internal string UniqueName { get; }
    public string MutuallyExclusiveSet { get; public set; }
    public OptionAttribute(string shortName, string longName);
    internal string get_UniqueName();
    public string get_MutuallyExclusiveSet();
    public void set_MutuallyExclusiveSet(string value);
}
internal class JetBrains.Common.Util.CommandLine.OptionGroupParser : ArgumentParser {
    private bool _ignoreUnkwnownArguments;
    public OptionGroupParser(bool ignoreUnkwnownArguments);
    public virtual ParserState Parse(IArgumentEnumerator argumentEnumerator, OptionMap map, object options);
}
[DebuggerDisplayAttribute("ShortName = {ShortName}, LongName = {LongName}")]
internal class JetBrains.Common.Util.CommandLine.OptionInfo : object {
    private OptionAttribute _attribute;
    private PropertyInfo _property;
    private bool _required;
    private string _helpText;
    private string _shortName;
    private string _longName;
    private string _mutuallyExclusiveSet;
    private object _defaultValue;
    private bool _hasDefaultValue;
    private object _setValueLock;
    [CompilerGeneratedAttribute]
private bool <IsDefined>k__BackingField;
    public string ShortName { get; }
    public string LongName { get; }
    internal string NameWithSwitch { get; }
    public string MutuallyExclusiveSet { get; }
    public bool Required { get; }
    public string HelpText { get; }
    public bool IsBoolean { get; }
    public bool IsArray { get; }
    public bool IsAttributeArrayCompatible { get; }
    public bool IsDefined { get; public set; }
    public bool HasBothNames { get; }
    public OptionInfo(OptionAttribute attribute, PropertyInfo property);
    public static OptionMap CreateMap(object target, CommandLineParserSettings settings);
    public bool SetValue(string value, object options);
    public bool SetValue(IList`1<string> values, object options);
    private bool SetValueScalar(string value, object options);
    private bool SetNullableValue(string value, object options);
    public bool SetValue(bool value, object options);
    private bool SetValueList(string value, object options);
    public void SetDefault(object options);
    public string get_ShortName();
    public string get_LongName();
    internal string get_NameWithSwitch();
    public string get_MutuallyExclusiveSet();
    public bool get_Required();
    public string get_HelpText();
    public bool get_IsBoolean();
    public bool get_IsArray();
    public bool get_IsAttributeArrayCompatible();
    [CompilerGeneratedAttribute]
public bool get_IsDefined();
    [CompilerGeneratedAttribute]
public void set_IsDefined(bool value);
    public bool get_HasBothNames();
}
public class JetBrains.Common.Util.CommandLine.OptionListAttribute : OptionAttribute {
    [CompilerGeneratedAttribute]
private char <Separator>k__BackingField;
    public char Separator { get; public set; }
    public OptionListAttribute(string shortName, string longName);
    public OptionListAttribute(string shortName, string longName, char separator);
    [CompilerGeneratedAttribute]
public char get_Separator();
    [CompilerGeneratedAttribute]
public void set_Separator(char value);
}
[DefaultMemberAttribute("Item")]
internal class JetBrains.Common.Util.CommandLine.OptionMap : object {
    private CommandLineParserSettings _settings;
    private Dictionary`2<string, string> _names;
    private Dictionary`2<string, OptionInfo> _map;
    private Dictionary`2<string, MutuallyExclusiveInfo> _mutuallyExclusiveSetMap;
    [CompilerGeneratedAttribute]
private object <RawOptions>k__BackingField;
    public OptionInfo Item { get; public set; }
    private object RawOptions { get; internal set; }
    public OptionMap(int capacity, CommandLineParserSettings settings);
    public OptionInfo get_Item(string key);
    public void set_Item(string key, OptionInfo value);
    [CompilerGeneratedAttribute]
private object get_RawOptions();
    [CompilerGeneratedAttribute]
internal void set_RawOptions(object value);
    public bool EnforceRules();
    public void SetDefaults();
    private bool EnforceRequiredRule();
    private bool EnforceMutuallyExclusiveMap();
    private void BuildMutuallyExclusiveMap(OptionInfo option);
    private static void BuildAndSetPostParsingStateIfNeeded(object options, OptionInfo option, Nullable`1<bool> required, Nullable`1<bool> mutualExclusiveness);
}
internal class JetBrains.Common.Util.CommandLine.Pair`2 : object {
    private TLeft _left;
    private TRight _right;
    public TLeft Left { get; }
    public TRight Right { get; }
    public Pair`2(TLeft left, TRight right);
    public TLeft get_Left();
    public TRight get_Right();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
[FlagsAttribute]
internal enum JetBrains.Common.Util.CommandLine.ParserState : Enum {
    public ushort value__;
    public static ParserState Success;
    public static ParserState Failure;
    public static ParserState MoveOnNextElement;
}
public class JetBrains.Common.Util.CommandLine.ParsingError : object {
    [CompilerGeneratedAttribute]
private BadOptionInfo <BadOption>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ViolatesRequired>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ViolatesFormat>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ViolatesMutualExclusiveness>k__BackingField;
    public BadOptionInfo BadOption { get; }
    public bool ViolatesRequired { get; public set; }
    public bool ViolatesFormat { get; public set; }
    public bool ViolatesMutualExclusiveness { get; public set; }
    internal ParsingError(string shortName, string longName, bool format);
    [CompilerGeneratedAttribute]
public BadOptionInfo get_BadOption();
    [CompilerGeneratedAttribute]
public bool get_ViolatesRequired();
    [CompilerGeneratedAttribute]
public void set_ViolatesRequired(bool value);
    [CompilerGeneratedAttribute]
public bool get_ViolatesFormat();
    [CompilerGeneratedAttribute]
public void set_ViolatesFormat(bool value);
    [CompilerGeneratedAttribute]
public bool get_ViolatesMutualExclusiveness();
    [CompilerGeneratedAttribute]
public void set_ViolatesMutualExclusiveness(bool value);
}
public class JetBrains.Common.Util.CommandLine.PostParsingState : object {
    [CompilerGeneratedAttribute]
private List`1<ParsingError> <Errors>k__BackingField;
    public List`1<ParsingError> Errors { get; }
    [CompilerGeneratedAttribute]
public List`1<ParsingError> get_Errors();
}
internal static class JetBrains.Common.Util.CommandLine.ReflectionUtil : object {
    public static IList`1<Pair`2<PropertyInfo, TAttribute>> RetrievePropertyList(object target);
    public static Pair`2<MethodInfo, TAttribute> RetrieveMethod(object target);
    public static TAttribute RetrieveMethodAttributeOnly(object target);
    public static IList`1<TAttribute> RetrievePropertyAttributeList(object target);
    public static TAttribute GetAttribute();
    public static bool IsNullableType(Type type);
}
internal class JetBrains.Common.Util.CommandLine.StringArrayEnumerator : object {
    private String[] _data;
    private int _index;
    private int _endIndex;
    public string Current { get; }
    public string Next { get; }
    public bool IsLast { get; }
    public StringArrayEnumerator(String[] value);
    public sealed virtual string get_Current();
    public sealed virtual string get_Next();
    public sealed virtual bool get_IsLast();
    public void Reset();
    public sealed virtual bool MoveNext();
    public sealed virtual string GetRemainingFromNext();
    public sealed virtual bool MovePrevious();
    private sealed virtual override void System.IDisposable.Dispose();
}
internal static class JetBrains.Common.Util.CommandLine.StringUtil : object {
    public static string Spaces(int count);
    public static bool IsNumeric(string value);
}
internal class JetBrains.Common.Util.CommandLine.TargetWrapper : object {
    private object _target;
    private IList`1<string> _valueList;
    private ValueListAttribute _vla;
    public bool IsValueListDefined { get; }
    public TargetWrapper(object target);
    public bool get_IsValueListDefined();
    public bool AddValueItemIfAllowed(string item);
}
[AttributeUsageAttribute("128")]
public class JetBrains.Common.Util.CommandLine.ValueListAttribute : Attribute {
    private Type _concreteType;
    [CompilerGeneratedAttribute]
private int <MaximumElements>k__BackingField;
    public int MaximumElements { get; public set; }
    internal Type ConcreteType { get; }
    public ValueListAttribute(Type concreteType);
    [CompilerGeneratedAttribute]
public int get_MaximumElements();
    [CompilerGeneratedAttribute]
public void set_MaximumElements(int value);
    internal Type get_ConcreteType();
    internal static IList`1<string> GetReference(object target);
    internal static ValueListAttribute GetAttribute(object target);
    private static PropertyInfo GetProperty(object target, Type& concreteType);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.ComparisonExtensions : object {
    [ExtensionAttribute]
public static IComparer`1<T> ToComparer(Comparison`1<T> comparison);
}
public class JetBrains.Common.Util.ComparisonHelper : object {
    public static bool IsEqual(T op1, T op2);
    public static bool IsEqual(T op1, object op2);
    public static bool IsEqualStruct(T op1, T op2);
    public static bool IsEqualStruct(T op1, object op2);
}
public static class JetBrains.Common.Util.Concurrency.Testing.Concurrenzy : object {
    public static string CONCUSIM;
    private static object ourMutex;
    private static HashSet`1<IAsyncActionInterceptor> ourAsyncActionInterceptors;
    [ThreadStaticAttribute]
private static ICheckpointInterceptor ourCheckpointInterceptor;
    [CompilerGeneratedAttribute]
private static bool <IsCheckpointsEnabled>k__BackingField;
    public static bool IsCheckpointsEnabled { get; private set; }
    private static Concurrenzy();
    [ConditionalAttribute("JET_MODE_ASSERT")]
public static void Checkpoint(string name);
    [ConditionalAttribute("JET_MODE_ASSERT")]
public static void Checkpoint(string name);
    [ConditionalAttribute("JET_MODE_ASSERT")]
public static void AsyncActionEntered(string fullName);
    [ConditionalAttribute("JET_MODE_ASSERT")]
public static void AsyncActionEntered(string name);
    [ConditionalAttribute("JET_MODE_ASSERT")]
public static void AsyncActionExited(string fullName, Exception exception);
    [ConditionalAttribute("JET_MODE_ASSERT")]
public static void AsyncActionExited(string name, Exception exception);
    public static IDisposable AsyncAction(string fullName);
    public static IDisposable AsyncAction(string name);
    [CompilerGeneratedAttribute]
public static bool get_IsCheckpointsEnabled();
    [CompilerGeneratedAttribute]
private static void set_IsCheckpointsEnabled(bool value);
    public static void EnableCheckpoints();
    public static void DisableCheckpoints();
    public static void RegisterAsyncActionInterceptor(IAsyncActionInterceptor interceptor);
    public static void UnregisterAsyncActionInterceptor(IAsyncActionInterceptor interceptor);
    public static void RegisterCheckpointInterceptor(ICheckpointInterceptor interceptor);
    public static void UnregisterCheckpointInterceptor();
}
public interface JetBrains.Common.Util.Concurrency.Testing.IAsyncActionInterceptor {
    public abstract virtual void OnEnter(string actionName, Thread thread);
    public abstract virtual void OnExit(string actionName, Thread thread, Exception exception);
}
public interface JetBrains.Common.Util.Concurrency.Testing.ICheckpointInterceptor {
    public abstract virtual void OnCheckpoint(string checkpoint);
}
public class JetBrains.Common.Util.ConditionalLog : object {
    public static string Define;
    private ILogger myLog;
    public ConditionalLog(ILogger logger);
    [ConditionalAttribute("JET_CONDITIONAL_LOG")]
[StringFormatMethodAttribute("message")]
public void Trace(string message);
    [ConditionalAttribute("JET_CONDITIONAL_LOG")]
[StringFormatMethodAttribute("message")]
public void Trace(string message, Object[] args);
    [ConditionalAttribute("JET_CONDITIONAL_LOG")]
[StringFormatMethodAttribute("message")]
public void Info(string message);
    [ConditionalAttribute("JET_CONDITIONAL_LOG")]
[StringFormatMethodAttribute("message")]
public void Info(string message, Object[] args);
}
public class JetBrains.Common.Util.CountableWrapper`1 : ValueType {
    private IEnumerable`1<T> myEnumerable;
    private int myCount;
    public int Count { get; }
    public CountableWrapper`1(ICollection`1<T> collection);
    public CountableWrapper`1(IEnumerable`1<T> enumerable, int count);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual int get_Count();
}
public static class JetBrains.Common.Util.DataContractNamespaces : object {
    public static string DotCommon;
    public static string DotTrace;
    public static string DotMemory;
}
public class JetBrains.Common.Util.DataPipes.AcceptNewValue`1 : MulticastDelegate {
    public AcceptNewValue`1(object object, IntPtr method);
    public virtual bool Invoke(T previousValue, T newValue);
    public virtual IAsyncResult BeginInvoke(T previousValue, T newValue, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
public class JetBrains.Common.Util.DataPipes.AcceptNewValue2`1 : MulticastDelegate {
    public AcceptNewValue2`1(object object, IntPtr method);
    public virtual ValuePassBehavior Invoke(T previousValue, T newValue);
    public virtual IAsyncResult BeginInvoke(T previousValue, T newValue, AsyncCallback callback, object object);
    public virtual ValuePassBehavior EndInvoke(IAsyncResult result);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.DataPipes.AnimationsEx : object {
    private static IDataProvider`1<DateTime> ourAnimationTimer;
    private static AnimationsEx();
    [ExtensionAttribute]
public static IDataProvider`1<T> Animate(IDataProvider`1<T> targetValue, TimeSpan duration, Interpolator`1<T> interpolator);
}
public enum JetBrains.Common.Util.DataPipes.AsyncComputationState : Enum {
    public int value__;
    public static AsyncComputationState WaitForExecution;
    public static AsyncComputationState Executing;
    public static AsyncComputationState Ready;
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.DataPipes.BoolEx : object {
    [ExtensionAttribute]
public static IDataProvider`1<bool> AnyTrue(IEnumerable`1<IDataProvider`1<bool>> provider);
    [ExtensionAttribute]
public static IDataProvider`1<bool> AllTrue(IEnumerable`1<IDataProvider`1<bool>> provider);
    [ExtensionAttribute]
public static IDataProvider`1<bool> And(IDataProvider`1<bool> provider, IDataProvider`1[] providers);
    [ExtensionAttribute]
public static IDataProvider`1<bool> Or(IDataProvider`1<bool> p1, IDataProvider`1<bool> p2);
    [ExtensionAttribute]
public static IDataProvider`1<bool> And(IDataProvider`1<bool> p1, IDataProvider`1<bool> p2);
    [ExtensionAttribute]
public static IDataProvider`1<bool> Or(IDataProvider`1<bool> provider, IDataProvider`1[] providers);
    [ExtensionAttribute]
public static IDataProvider`1<bool> Invert(IDataProvider`1<bool> provider);
    [ExtensionAttribute]
public static void Flip(IDataController`1<bool> contorller);
}
public enum JetBrains.Common.Util.DataPipes.CollectionNotificationMode : Enum {
    public int value__;
    public static CollectionNotificationMode Reset;
    public static CollectionNotificationMode KeepPrefix;
    public static CollectionNotificationMode Move;
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.DataPipes.CombineEx : object {
    [ExtensionAttribute]
public static IDataProvider`1<TA[]> Combine(IEnumerable`1<IDataProvider`1<TA>> providers);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<TA[]> Combine(IEnumerable`1<IAsyncDataProvider`1<TA>> providers);
    [ExtensionAttribute]
public static IDataProvider`1<TA[]> Combine(IDataProvider`1[] providers);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<TA[]> Combine(IAsyncDataProvider`1[] providers);
    [ExtensionAttribute]
public static IRemotableReference`1<IDataProvider`1<TA[]>> Combine(IRemotableReference`1[] providers);
    [ExtensionAttribute]
public static IDataProvider`1<Nullable`1<Pair`2<TA, TB>>> CombineSafe(IDataProvider`1<Nullable`1<TA>> src1, IDataProvider`1<Nullable`1<TB>> src2);
    [ExtensionAttribute]
public static IDataProvider`1<TC> CombineSafe(IDataProvider`1<TA> src1, IDataProvider`1<Nullable`1<TB>> src2, Func`3<TA, TB, TC> converter);
    [ExtensionAttribute]
public static IDataProvider`1<TC> CombineSafe(IDataProvider`1<Nullable`1<TA>> src1, IDataProvider`1<TB> src2, Func`3<TA, TB, TC> converter);
    [ExtensionAttribute]
public static IDataProvider`1<TC> CombineSafe(IDataProvider`1<Nullable`1<TA>> src1, IDataProvider`1<Nullable`1<TB>> src2, Func`3<TA, TB, TC> converter);
    [ExtensionAttribute]
public static IDataProvider`1<TC> CombineSafe(IDataProvider`1<TA> src1, IDataProvider`1<TB> src2, Func`3<TA, TB, TC> converter);
    [ExtensionAttribute]
public static IDataProvider`1<TD> CombineSafe(IDataProvider`1<TA> src1, IDataProvider`1<TB> src2, IDataProvider`1<TC> src3, Func`4<TA, TB, TC, TD> converter);
    [ExtensionAttribute]
public static IDataProvider`1<TE> CombineSafe(IDataProvider`1<TA> src1, IDataProvider`1<TB> src2, IDataProvider`1<TC> src3, IDataProvider`1<TD> src4, Func`5<TA, TB, TC, TD, TE> converter);
    [ExtensionAttribute]
public static IDataProvider`1<TF> CombineSafe(IDataProvider`1<TA> src1, IDataProvider`1<TB> src2, IDataProvider`1<TC> src3, IDataProvider`1<TD> src4, IDataProvider`1<TE> src5, Func`6<TA, TB, TC, TD, TE, TF> converter);
    [ExtensionAttribute]
public static IDataProvider`1<TG> CombineSafe(IDataProvider`1<TA> src1, IDataProvider`1<TB> src2, IDataProvider`1<TC> src3, IDataProvider`1<TD> src4, IDataProvider`1<TE> src5, IDataProvider`1<TF> src6, Func`7<TA, TB, TC, TD, TE, TF, TG> converter);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<Pair`2<TA, TB>> Combine(IAsyncDataProvider`1<TA> source1, IThreadSwitch`1<TB> source2);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<Pair`2<TA, TB>> Combine(IAsyncDataProvider`1<TA> source1, IAsyncDataProvider`1<TB> source2);
    [ExtensionAttribute]
public static IDataProvider`1<Pair`2<TA, TB>> Combine(IDataProvider`1<TA> source1, IDataProvider`1<TB> source2);
    [ExtensionAttribute]
public static IDataProvider`1<TB> Combine(IDataProvider`1<TA> provider, Func`2<IEnumerable`1<TA>, TB> converter, IDataProvider`1[] providers);
    [ExtensionAttribute]
internal static IDataProvider`1<IEnumerable`1<ProgressProvider>> CombineProgresses(IDataProvider`1<IEnumerable`1<ProgressProvider>> source, IDataProvider`1[] other);
    [ExtensionAttribute]
public static IDataProvider`1<TB> CombineNotNull(IDataProvider`1<TA> provider, Func`2<IEnumerable`1<TA>, TB> converter, IDataProvider`1[] providers);
    [ExtensionAttribute]
public static IDataProvider`1<TC> Combine(IDataProvider`1<TA> provider, IDataProvider`1<TB> otherProvider, Func`3<TA, TB, TC> converter);
    [ExtensionAttribute]
public static IRemotableReference`1<IDataProvider`1<TC>> Combine(IRemotableReference`1<IDataProvider`1<TA>> provider, IRemotableReference`1<IDataProvider`1<TB>> otherProvider, Func`3<TA, TB, TC> converter);
    [ExtensionAttribute]
public static IRemotableReference`1<IAsyncDataProvider`1<TC>> Combine(IRemotableReference`1<IAsyncDataProvider`1<TA>> provider, IRemotableReference`1<IAsyncDataProvider`1<TB>> otherProvider, Func`3<TA, TB, TC> converter);
    [ExtensionAttribute]
public static IRemotableReference`1<IDataProvider`1<TD>> Combine(IRemotableReference`1<IDataProvider`1<TA>> provider, IRemotableReference`1<IDataProvider`1<TB>> otherProvider, IRemotableReference`1<IDataProvider`1<TC>> thirdProvider, Func`4<TA, TB, TC, TD> converter);
    [ExtensionAttribute]
public static IRemotableReference`1<IAsyncDataProvider`1<TD>> Combine(IRemotableReference`1<IAsyncDataProvider`1<TA>> provider, IRemotableReference`1<IAsyncDataProvider`1<TB>> otherProvider, IRemotableReference`1<IAsyncDataProvider`1<TC>> thirdProvider, Func`4<TA, TB, TC, TD> converter);
    [ExtensionAttribute]
public static IDataProvider`1<T> Combine(IDataProvider`1<T> provider, IDataSignal signal);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<TC> Combine(IAsyncDataProvider`1<TA> provider, IThreadSwitch`1<TB> otherSwitch, Func`3<TA, TB, TC> converter);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<TD> Combine(IAsyncDataProvider`1<TA> provider, IThreadSwitch`1<TB> otherSwitch1, IThreadSwitch`1<TC> otherSwitch2, Func`4<TA, TB, TC, TD> converter);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<TD> Combine(IAsyncDataProvider`1<TA> provider, IThreadSwitch`1<TB> otherSwitch1, IThreadSwitch`1<TC> otherSwitch2, Func`5<TA, TB, TC, IExecutionController, TD> converter);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<TD> CombineSafe(IAsyncDataProvider`1<TA> provider, IThreadSwitch`1<TB> otherSwitch1, IThreadSwitch`1<TC> otherSwitch2, Func`5<TA, TB, TC, IExecutionController, TD> converter, TD fallback);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<TE> Combine(IAsyncDataProvider`1<TA> provider, IThreadSwitch`1<TB> otherSwitch1, IThreadSwitch`1<TC> otherSwitch2, IThreadSwitch`1<TD> otherSwitch3, Func`6<TA, TB, TC, TD, IExecutionController, TE> converter);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<TE> Combine(IAsyncDataProvider`1<TA> provider, IThreadSwitch`1<TB> otherSwitch1, IThreadSwitch`1<TC> otherSwitch2, IThreadSwitch`1<TD> otherSwitch3, Func`5<TA, TB, TC, TD, TE> converter);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<TF> Combine(IAsyncDataProvider`1<TA> provider, IThreadSwitch`1<TB> otherSwitch1, IThreadSwitch`1<TC> otherSwitch2, IThreadSwitch`1<TD> otherSwitch3, IThreadSwitch`1<TE> otherSwitch4, Func`6<TA, TB, TC, TD, TE, TF> converter);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<TF> Combine(IAsyncDataProvider`1<TA> provider, IThreadSwitch`1<TB> otherSwitch1, IThreadSwitch`1<TC> otherSwitch2, IThreadSwitch`1<TD> otherSwitch3, IThreadSwitch`1<TE> otherSwitch4, Func`7<TA, TB, TC, TD, TE, IExecutionController, TF> converter);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<TJ> Combine(IAsyncDataProvider`1<TA> provider, IThreadSwitch`1<TB> otherSwitch1, IThreadSwitch`1<TC> otherSwitch2, IThreadSwitch`1<TD> otherSwitch3, IThreadSwitch`1<TE> otherSwitch4, IThreadSwitch`1<TF> otherSwitch5, Func`7<TA, TB, TC, TD, TE, TF, TJ> converter);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<TJ> Combine(IAsyncDataProvider`1<TA> provider, IThreadSwitch`1<TB> otherSwitch1, IThreadSwitch`1<TC> otherSwitch2, IThreadSwitch`1<TD> otherSwitch3, IThreadSwitch`1<TE> otherSwitch4, IThreadSwitch`1<TF> otherSwitch5, Func`8<TA, TB, TC, TD, TE, TF, IExecutionController, TJ> converter);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<TR> Combine(IAsyncDataProvider`1<TA> provider, IThreadSwitch`1<TB> otherSwitch1, IThreadSwitch`1<TC> otherSwitch2, IThreadSwitch`1<TD> otherSwitch3, IThreadSwitch`1<TE> otherSwitch4, IThreadSwitch`1<TF> otherSwitch5, IThreadSwitch`1<TJ> otherSwitch6, Func`9<TA, TB, TC, TD, TE, TF, TJ, IExecutionController, TR> converter);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<TJ> Combine(IAsyncDataProvider`1<TA> provider, IThreadSwitch`1<TB> otherSwitch1, IThreadSwitch`1<TC> otherSwitch2, IThreadSwitch`1<TD> otherSwitch3, IThreadSwitch`1<TE> otherSwitch4, IThreadSwitch`1<TF> otherSwitch5, IThreadSwitch`1<TG> otherSwitch6, Func`8<TA, TB, TC, TD, TE, TF, TG, TJ> converter);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<TC> CombineSafe(IAsyncDataProvider`1<TA> provider, IThreadSwitch`1<TB> otherSwitch, Func`4<TA, TB, IExecutionController, TC> converter, TC fallback);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<TC> Combine(IAsyncDataProvider`1<TA> provider, IThreadSwitch`1<TB> otherSwitch, Func`4<TA, TB, IExecutionController, TC> converter);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<TC> Combine(IAsyncDataProvider`1<TA> src1, IAsyncDataProvider`1<TB> src2, Func`3<TA, TB, TC> converter);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<TD> Combine(IAsyncDataProvider`1<TA> src1, IAsyncDataProvider`1<TB> src2, IAsyncDataProvider`1<TC> src3, Func`4<TA, TB, TC, TD> converter);
    [ExtensionAttribute]
public static IDataProvider`1<TD> Combine(IDataProvider`1<TA> provider1, IDataProvider`1<TB> provider2, IDataProvider`1<TC> provider3, Func`4<TA, TB, TC, TD> converter);
    [ExtensionAttribute]
public static IDataProvider`1<TE> Combine(IDataProvider`1<TA> provider1, IDataProvider`1<TB> provider2, IDataProvider`1<TC> provider3, IDataProvider`1<TD> provider4, Func`5<TA, TB, TC, TD, TE> converter);
    [ExtensionAttribute]
public static IDataProvider`1<TF> Combine(IDataProvider`1<TA> provider1, IDataProvider`1<TB> provider2, IDataProvider`1<TC> provider3, IDataProvider`1<TD> provider4, IDataProvider`1<TE> provider5, Func`6<TA, TB, TC, TD, TE, TF> converter);
    [ExtensionAttribute]
public static IDataProvider`1<TJ> Combine(IDataProvider`1<TA> provider1, IDataProvider`1<TB> provider2, IDataProvider`1<TC> provider3, IDataProvider`1<TD> provider4, IDataProvider`1<TE> provider5, IDataProvider`1<TF> provider6, Func`7<TA, TB, TC, TD, TE, TF, TJ> converter);
    [ExtensionAttribute]
public static IDataProvider`1<TR> Combine(IDataProvider`1<TA> provider1, IDataProvider`1<TB> provider2, IDataProvider`1<TC> provider3, IDataProvider`1<TD> provider4, IDataProvider`1<TE> provider5, IDataProvider`1<TF> provider6, IDataProvider`1<TJ> provider7, Func`8<TA, TB, TC, TD, TE, TF, TJ, TR> converter);
    [ExtensionAttribute]
public static IDataProvider`1<TR> Combine(IDataProvider`1<TA> provider1, IDataProvider`1<TB> provider2, IDataProvider`1<TC> provider3, IDataProvider`1<TD> provider4, IDataProvider`1<TE> provider5, IDataProvider`1<TF> provider6, IDataProvider`1<TJ> provider7, IDataProvider`1<TK> provider8, Func`9<TA, TB, TC, TD, TE, TF, TJ, TK, TR> converter);
    [ExtensionAttribute]
public static IDataProvider`1<TR> Combine(IDataProvider`1<TA> provider1, IDataProvider`1<TB> provider2, IDataProvider`1<TC> provider3, IDataProvider`1<TD> provider4, IDataProvider`1<TE> provider5, IDataProvider`1<TF> provider6, IDataProvider`1<TG> provider7, IDataProvider`1<TH> provider8, IDataProvider`1<TI> provider9, Func`10<TA, TB, TC, TD, TE, TF, TG, TH, TI, TR> converter);
    [ExtensionAttribute]
public static IDataProvider`1<TR> Combine(IDataProvider`1<TA> provider1, IDataProvider`1<TB> provider2, IDataProvider`1<TC> provider3, IDataProvider`1<TD> provider4, IDataProvider`1<TE> provider5, IDataProvider`1<TF> provider6, IDataProvider`1<TG> provider7, IDataProvider`1<TH> provider8, IDataProvider`1<TI> provider9, IDataProvider`1<TJ> provider10, Func`11<TA, TB, TC, TD, TE, TF, TG, TH, TI, TJ, TR> converter);
    [ExtensionAttribute]
public static IDataProvider`1<TB> Combine(IDataProvider`1[] providers, Func`2<TA[], TB> converter);
    [ExtensionAttribute]
public static IDataProvider`1<TB> Combine(IDataController`1[] providers, Func`2<TA[], TB> converter);
    [ExtensionAttribute]
private static IDataProvider`1<TB> CombineArray(TProviderType[] providers, Func`2<TA[], TB> converter);
    [ExtensionAttribute]
public static IDataProvider`1<TB> CombineDeferring(IDataProvider`1[] providers, Func`2<TA[], TB> converter);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<TB> Combine(IAsyncDataProvider`1[] providers, Func`2<TA[], TB> converter);
    [ExtensionAttribute]
public static IDataProvider`1<TB> CombineEnumerables(IDataProvider`1[] providers, Func`2<IEnumerable`1<TA>, TB> converter);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<TC> CombineSafe(IAsyncDataProvider`1<TA> provider, IThreadSwitch`1<TB> otherSwitch, Func`3<TA, TB, TC> converter, TC fallback);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.DataPipes.CommandEx : object {
    [ExtensionAttribute]
public static ICommandContainer ToCommand(IDataProvider`1<bool> canExecuteProvider, IDataProvider`1<Action> executeProvider);
    [ExtensionAttribute]
public static ICommandContainer ToCommand(IDataProvider`1<bool> canExecuteProvider, IDataProvider`1<T> data, Action`1<T> execute);
    [ExtensionAttribute]
public static ICommandContainer ToCommand(IDataProvider`1<bool> canExecuteProvider, Action execute);
    [ExtensionAttribute]
public static ICommandContainer ToCommand(IDataProvider`1<Action> executeActionProvider);
    [ExtensionAttribute]
public static ICommandContainer ToCommandIfNotNull(IDataProvider`1<T> provider, Action`1<T> execute);
    [ExtensionAttribute]
public static ICommandContainer ToCommand(IDataProvider`1<T> provider, Predicate`1<T> canExecute, Action`1<T> execute);
    [ExtensionAttribute]
public static ICommandContainer ToCommandContainer(ICommand command);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.DataPipes.ConstructorEx : object {
    [ExtensionAttribute]
public static IDataController`1<T> AsDataController(T o);
    [ExtensionAttribute]
public static IDataProvider`1<T> AsDataProvider(T o);
    [ExtensionAttribute]
public static IDataProvider`1<T> AsDataProvider(T source, Action`2<T, Action> subscribeHandler, Action`2<T, Action> unsubscribeHandler);
    [ExtensionAttribute]
public static IDataProvider`1<TValue> AsDataProvider(TSource source, Func`2<TSource, TValue> getValue, Action`2<TSource, Action> subscribeHandler, Action`2<TSource, Action> unsubscribeHandler);
    [ExtensionAttribute]
public static IDataProvider`1<TValue> AsDataProvider(TSource source, Func`2<TSource, TValue> getValue, Action`2<TSource, Action`1<TArgs>> subscribeHandler, Action`2<TSource, Action`1<TArgs>> unsubscribeHandler);
    [ExtensionAttribute]
public static IDataProvider`1<T> AsDataProviderCollectionChanged(T source);
    [ExtensionAttribute]
public static IDataProvider`1<TResult> AsDataProviderWithEventHandler(TSource source, Func`2<TSource, TResult> getValue, Action`2<TSource, EventHandler`2<THSource, TArgs>> subscribe, Action`2<TSource, EventHandler`2<THSource, TArgs>> unsubscribe);
    [ExtensionAttribute]
public static IDataProvider`1<TResult> AsDataProviderWithEventHandler(TSource source, Func`2<TSource, TResult> getValue, Action`2<TSource, EventHandler`1<TArgs>> subscribe, Action`2<TSource, EventHandler`1<TArgs>> unsubscribe);
    [ExtensionAttribute]
public static IDataProvider`1<TResult> AsDataProviderWithRoutedEventHandler(TSource source, Func`2<TSource, TResult> getValue, Action`2<TSource, RoutedEventHandler> subscribe, Action`2<TSource, RoutedEventHandler> unsubscribe);
    [ExtensionAttribute]
public static IDataProvider`1<TResult> AsDataProviderWithEventHandler(TSource source, Action`2<TSource, EventHandler`1<TResult>> subscribe, Action`2<TSource, EventHandler`1<TResult>> unsubscribe);
    [ExtensionAttribute]
public static IDataProvider`1<TResult> AsDataProviderWithEventHandler(TSource source, Func`2<TSource, TResult> getValue, Action`2<TSource, EventHandler> subscribe, Action`2<TSource, EventHandler> unsubscribe);
    [ExtensionAttribute]
public static IDataProvider`1<TArgs> AsDataProvider(TSource source, Action`2<TSource, Action`1<TArgs>> subscribe, Action`2<TSource, Action`1<TArgs>> unsubscribe);
    [ExtensionAttribute]
public static IDataProvider`1<PipeEventData`1<TArgs>> AsDataEvent(UIElement source, RoutedEvent routedEvent, Func`2<Action`1<TArgs>, Delegate> delegateBuilder);
    [ExtensionAttribute]
public static IDataProvider`1<PipeEventData`1<TArgs>> AsDataEvent(TSource source, Action`2<TSource, Action`1<TArgs>> subscribe, Action`2<TSource, Action`1<TArgs>> unsubscribe);
    [ExtensionAttribute]
public static IDataProvider`1<PipeEventData`1<TArgs>> AsDataEvent(TSource source, Action`2<TSource, EventHandler`1<TArgs>> subscribe, Action`2<TSource, EventHandler`1<TArgs>> unsubscribe);
    [ExtensionAttribute]
public static IDataProvider`1<PipeEventData`1<MouseEventArgs>> AsDataEvent(TSource source, Action`2<TSource, MouseEventHandler> subscribe, Action`2<TSource, MouseEventHandler> unsubscribe);
    [ExtensionAttribute]
public static IDataProvider`1<PipeEventData`1<KeyEventArgs>> AsDataEvent(TSource source, Action`2<TSource, KeyEventHandler> subscribe, Action`2<TSource, KeyEventHandler> unsubscribe);
    [ExtensionAttribute]
public static IDataProvider`1<PipeEventData`1<KeyboardFocusChangedEventArgs>> AsDataEvent(TSource source, Action`2<TSource, KeyboardFocusChangedEventHandler> subscribe, Action`2<TSource, KeyboardFocusChangedEventHandler> unsubscribe);
    [ExtensionAttribute]
public static IDataProvider`1<PipeEventData`1<EventArgs>> AsDataEvent(TSource source, Action`2<TSource, EventHandler> subscribe, Action`2<TSource, EventHandler> unsubscribe);
    [ExtensionAttribute]
public static IDataProvider`1<PipeEventData`1<RoutedEventArgs>> AsDataEventRouted(TSource source, Action`2<TSource, RoutedEventHandler> subscribe, Action`2<TSource, RoutedEventHandler> unsubscribe);
    [ExtensionAttribute]
public static IDataProvider`1<PipeEventData`1<EventArgs>> ToDataEvent(DispatcherTimer timer);
    [ExtensionAttribute]
public static IThreadSwitch`1<T> ToThreadSwitch(IAsyncOperation`1<T> op);
    [ExtensionAttribute]
public static IDataProvider`1<T> CreateDependencyPropertyProvider(DependencyObject o, DependencyProperty property);
}
public static class JetBrains.Common.Util.DataPipes.ControlledTransformArgument : object {
    public static ControlledTransformArgument`1<T> Update(T newValue);
    public static ControlledTransformArgument`1<T> Resurrect(T sourceValue);
    public static ControlledTransformArgument`1<T> Invalidate(InvalidateMode mode);
}
public class JetBrains.Common.Util.DataPipes.ControlledTransformArgument`1 : ValueType {
    public ControlledTransformArgumentType Type;
    public T Value;
    [LocalizableAttribute("False")]
public virtual string ToString();
}
public enum JetBrains.Common.Util.DataPipes.ControlledTransformArgumentType : Enum {
    public int value__;
    public static ControlledTransformArgumentType Update;
    public static ControlledTransformArgumentType Resurrect;
    public static ControlledTransformArgumentType Invalidate;
    public static ControlledTransformArgumentType Cleanup;
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.DataPipes.ControlledTransformEx : object {
    [ExtensionAttribute]
public static IDataProvider`1<T> ControlledTransformWithConsistencyState(IDataProvider`1<T> source, Action`2<ControlledTransformArgument`1<T>, ITransformController`1<T>> handler);
    [ExtensionAttribute]
public static IDataProvider`1<TB> ControlledTransformWithConsistencyState(IDataProvider`1<TA> source, Action`2<ControlledTransformArgument`1<TA>, ITransformController`1<TB>> handler);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<T> ControlledTransformWithConsistencyState(IAsyncDataProvider`1<T> source, Action`3<ControlledTransformArgument`1<T>, IExecutionController, ITransformController`1<T>> handler);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<TB> ControlledTransformWithConsistencyState(IAsyncDataProvider`1<TA> source, Action`3<ControlledTransformArgument`1<TA>, IExecutionController, ITransformController`1<TB>> handler);
    [ExtensionAttribute]
public static IDataProvider`1<T> ControlledTransform(IDataProvider`1<T> source, Action`2<T, ITransformController`1<T>> handler);
    [ExtensionAttribute]
public static IDataProvider`1<TB> ControlledTransform(IDataProvider`1<TA> source, Action`2<TA, ITransformController`1<TB>> handler);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<T> ControlledTransform(IAsyncDataProvider`1<T> source, Action`3<T, IExecutionController, ITransformController`1<T>> handler);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<TB> ControlledTransform(IAsyncDataProvider`1<TA> source, Action`3<TA, IExecutionController, ITransformController`1<TB>> handler);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.DataPipes.ConvertersEx : object {
    [ExtensionAttribute]
public static IDataController`1<T> ToDataController(IProperty`1<T> property, Lifetime lifetime);
    [ExtensionAttribute]
public static IDataProvider`1<T> ToDataProvider(IProperty`1<T> property);
    [ExtensionAttribute]
public static IProperty`1<T> ToPropertyTwoWay(IDataController`1<T> controller, Lifetime lifetime, string id);
    [ExtensionAttribute]
public static IProperty`1<T> ToProperty(IDataProvider`1<T> provider, Lifetime lifetime, string id);
    [ExtensionAttribute]
public static IProperty`1<T> ToProperty(IDataProvider`1<T> provider, Lifetime lifetime, string id, object cookie);
    [ExtensionAttribute]
internal static IThreadSwitch`1<T> ToThreadSwitch(IDataProviderBase`1<Getter`1<T>> provider, bool isStream);
    [ExtensionAttribute]
internal static IThreadSwitch`1<T> AsThreadSwitch(IAsyncDataProvider`1<T> provider, bool isStream);
    [ExtensionAttribute]
public static IAsyncDataSignal ToSignal(IAsyncDataProvider`1<T> provider);
    [ExtensionAttribute]
public static IDataSignal ToSignal(IDataProvider`1<PipeEventData`1<T>> dataEvent);
    [ExtensionAttribute]
public static IDataSignal ToSignal(IDataProvider`1<T> provider);
    [ExtensionAttribute]
public static IDataSignal AsSignal(IDataProvider`1<TVoid> provider);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<TVoid> ToProvider(IAsyncDataSignal signal);
    [ExtensionAttribute]
public static IDataProvider`1<TVoid> ToProvider(IDataSignal signal);
    [ExtensionAttribute]
public static IDataProvider`1<ProgressProvider> ToProgressProvider(IDataProvider`1<IProgressIndicatorModel> progress);
    [ExtensionAttribute]
public static IDataProvider`1<T> ToDataProvider(ISource`1<T> property, Lifetime lifetime);
    [ExtensionAttribute]
public static IDataProvider`1<ICollection`1<T>> ToDataProvider(ICollectionEvents`1<T> listEvents, Lifetime lifetime);
}
public class JetBrains.Common.Util.DataPipes.DataAggregator`1 : object {
    private Func`2<IDataProvider`1<T>, IDataProvider`1<T>> myPrepareProvider;
    private IDataController`1<List`1<KeyValuePair`2<int, IDataProvider`1<T>>>> myProviders;
    [CompilerGeneratedAttribute]
private IDataProvider`1<T> <Provider>k__BackingField;
    public IDataProvider`1<T> Provider { get; }
    public DataAggregator`1(Func`2<IEnumerable`1<T>, T> aggregator, Func`2<IDataProvider`1<T>, IDataProvider`1<T>> prepareProvider);
    [CompilerGeneratedAttribute]
public sealed virtual IDataProvider`1<T> get_Provider();
    public sealed virtual void Register(IDataProvider`1<T> provider, int priority);
    public sealed virtual void Unregister(IDataProvider`1<T> provider);
}
public static class JetBrains.Common.Util.DataPipes.DataAttributeKeys : object {
    public static IDataAttributeKey`1<T> GetTypeKey();
    public static IDataAttributeKey BuildNewAttributeKey();
}
public class JetBrains.Common.Util.DataPipes.DataControllerContainer`1 : object {
    public IDataController`1<T> Controller;
    public IDataProvider`1<T> Provider { get; }
    public T Value { get; public set; }
    public DataControllerContainer`1(IDataController`1<T> controller);
    public DataControllerContainer`1(T initValue);
    public sealed virtual IDataProvider`1<T> get_Provider();
    public sealed virtual T get_Value();
    public sealed virtual void set_Value(T value);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.DataPipes.DataControllerEditorsEx : object {
    [ExtensionAttribute]
public static ValueEditor`2<T, T> CreateDataControllerForEditing(IDataController`1<T> modelController, Lifetime lifetime, IDataSignalController saveSignal, IDataSignalController resetSignal, Func`2<T, string> validator);
    [ExtensionAttribute]
public static ValueEditor`2<T, T> CreateDataControllerForEditing(IDataController`1<T> modelController, Lifetime lifetime, IDataSignalController saveSignal, IDataSignalController resetSignal, IDataProvider`1<TV> extraValidationProvider, Func`3<T, TV, string> validator);
    [ExtensionAttribute]
public static ValueEditor`2<T, T> CreateDataControllerForEditing(IDataController`1<T> modelController, Lifetime lifetime, IDataSignalController saveSignal, IDataSignalController resetSignal, IEqualityComparer`1<T> comparer, Func`2<T, string> validator);
    [ExtensionAttribute]
public static ValueEditor`2<T, T> CreateDataControllerForEditing(IDataController`1<T> modelController, Lifetime lifetime, IDataSignalController saveSignal, IDataSignalController resetSignal, IEqualityComparer`1<T> comparer, IDataProvider`1<TV> extraValidationProvider, Func`3<T, TV, string> validator);
    [ExtensionAttribute]
public static ValueEditor`2<T, T> CreateDataControllerForEditing(IDataController`1<T> modelController, Lifetime lifetime, IDataSignalController saveSignal, IDataSignalController resetSignal, Func`3<T, T, bool> comparator, Func`2<T, string> validator);
    [ExtensionAttribute]
public static ValueEditor`2<T, T> CreateDataControllerForEditing(IDataController`1<T> modelController, Lifetime lifetime, IDataSignalController saveSignal, IDataSignalController resetSignal, Func`3<T, T, bool> comparator, IDataProvider`1<TV> extraValidationProvider, Func`3<T, TV, string> validator);
    [ExtensionAttribute]
public static ValueEditor`2<TO, TI> CreateDataControllerForEditing(IDataController`1<TI> modelController, Lifetime lifetime, IDataSignalController saveSignal, IDataSignalController resetSignal, Func`2<TI, TO> toUi, Func`2<TO, TI> toModel, Func`3<TI, TO, bool> comparator, Func`2<TO, string> validator);
    [ExtensionAttribute]
public static ValueEditor`2<TO, TI> CreateDataControllerForEditing(IDataController`1<TI> modelController, Lifetime lifetime, IDataSignalController saveSignal, IDataSignalController resetSignal, Func`2<TI, TO> toUi, Func`2<TO, TI> toModel, Func`3<TI, TO, bool> comparator, IDataProvider`1<TV> extraValidationProvider, Func`3<TO, TV, string> validator);
    [ExtensionAttribute]
public static IDataProvider`1<ValueEditingState> MergeChanges(IEnumerable`1<IDataProvider`1<ValueEditingState>> changes);
    public static IDataProvider`1<ValueEditingState> MergeChanges(IDataProvider`1[] changes);
    [ExtensionAttribute]
public static IDataProvider`1<bool> ToHaveValidChanges(IDataProvider`1<ValueEditingState> changes);
    [ExtensionAttribute]
public static IDataProvider`1<bool> ToCanSave(IDataProvider`1<ValueEditingState> changes);
    [ExtensionAttribute]
public static IWriteableDataNotifier`1<TIn> PublishWriteable(ValueEditor`2<TIn, TOut> editor);
}
public static class JetBrains.Common.Util.DataPipes.DataNotifiers : object {
    public static IDataNotifier`1<bool> True;
    public static IDataNotifier`1<bool> False;
    private static DataNotifiers();
}
public class JetBrains.Common.Util.DataPipes.DataPipe`2 : ValueType {
    public ISetProvider`1<TA> Input;
    public IDataProvider`1<TB> Output;
    public DataPipe`2(ISetProvider`1<TA> input, IDataProvider`1<TB> output);
}
[ExtensionAttribute]
internal static class JetBrains.Common.Util.DataPipes.DataPipeGraphExtensions : object {
    [ExtensionAttribute]
internal static List`1<IDataProviderInternal> GetLongestPathTo(IEnumerable`1<IDataProviderInternal> providers, IDataPipeNode target);
    public static IDataProviderInternal[] GetSources(IDataProviderInternal n);
}
public class JetBrains.Common.Util.DataPipes.DataPipeLifetime : object {
    private Lifetime myLifetime;
    private AsyncLifetime myAsyncLifetime;
    private IDataProvider`1<PipeLifeState> myProvider;
    public Lifetime Lifetime { get; }
    internal IDataProvider`1<PipeLifeState> TerminationState { get; }
    public DataPipeLifetime(Lifetime lifetime);
    public DataPipeLifetime(Lifetime lifetime, TimeSpan terminationTimeout);
    public Lifetime get_Lifetime();
    internal IDataProvider`1<PipeLifeState> get_TerminationState();
    public AsyncLifetime AsAsyncLifetime();
    public void Add(ITwoStepDisposable disposable, IDataProvider`1<bool> isSubscriptionActive);
    public static Lifetime op_Implicit(DataPipeLifetime lifetime);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.DataPipes.DataPipeLifetimeEx : object {
    [ExtensionAttribute]
public static DataPipeLifetime CreateDataPipeLifetime(Lifetime lifetime);
    [ExtensionAttribute]
public static DataPipeLifetime CreateDataPipeLifetime(Lifetime lifetime, TimeSpan terminationTimeout);
    [ExtensionAttribute]
public static AsyncLifetime AsAsyncLifetimeOrEternal(DataPipeLifetime lifetime);
}
public class JetBrains.Common.Util.DataPipes.DataProviderIfClause`1 : ValueType {
    private IDataProxy`1<T> myElse;
    private IDataProvider`1<T> myResult;
    internal DataProviderIfClause`1(IDataProxy`1<T> else, IDataProvider`1<T> result);
    public IDataProvider`1<T> Else(IDataProvider`1<T> result);
    public IDataProvider`1<T> Else(T value);
    public DataProviderIfClause`1<T> ElseIf(IDataProvider`1<bool> condition, IDataProvider`1<T> result);
    public IDataProvider`1<T> ElseDefault();
}
public class JetBrains.Common.Util.DataPipes.DataProviderProxyMap`2 : object {
    private Dictionary`2<TKey, IDataProxy`1<TValue>> myMap;
    public sealed virtual IDataProvider`1<TValue> GetProvider(TKey key);
    private IDataProxy`1<TValue> GetOrCreate(TKey key);
    public sealed virtual void SetProvider(TKey key, IDataProvider`1<TValue> markersProvider);
}
public static class JetBrains.Common.Util.DataPipes.DataProviders : object {
    public static IDataProvider`1<bool> True;
    public static IDataProvider`1<bool> False;
    internal static bool ClearProxyPipelineOnEmptySourceDefault;
    private static DataProviders();
    public static IDataProvider`1<T> Null();
    public static IDataProvider`1<T> Empty();
    public static IAsyncDataProvider`1<T> NullAsync();
    public static IAsyncDataProvider`1<T> EmptyAsync();
    public static IDataProxy`1<T> CreateProxy(bool clearPipelineOnEmptySource);
    public static IAsyncDataProxy`1<T> CreateAsyncProxy(DataPipeLifetime lifetime, bool isStream, bool clearPipelineOnEmptySource);
    public static IThreadSwitchProxy`1<T> CreateThreadSwitchProxy(DataPipeLifetime lifetime, bool isStream);
    public static IDataSignalProxy CreateSignalProxy();
    [NotNullAttribute]
public static IDataController`1<T> Create(T initialValue, IEqualityComparer`1<T> equalityComparer);
    [NotNullAttribute]
public static IDataController`1<T> CreateWithoutValue(IEqualityComparer`1<T> equalityComparer);
    [NotNullAttribute]
public static IDataProvider`1<T> Create(Func`1<T> createInitialValue);
    public static IDataSignal CreateCustomSignal(Action`1<Action> subscribeHandler, Action`1<Action> unsubscribeHandler);
    public static IDataEvent`1<T> CreateEvent();
    [ObsoleteAttribute("Signal shouldn't fire update on subscribe")]
public static IDataSignalController CreateSignalFireOnSubscribe();
    public static IDataSignalController CreateSignal();
    public static IAsyncDataSignalController CreateAsyncSignal(IAsyncDataControllerGroup asyncGroup);
    [NotNullAttribute]
public static IDataProvider`1<T> CreateConst(T initialValue);
    public static IAsyncDataControllerGroup CreateAsyncGroup();
    public static IAsyncDataController`1<T> CreateAsync(ProgressProvider progressProvider, T initialValue, ActionEvent cancelEvent, IEqualityComparer`1<T> equalityComparer);
    public static IAsyncDataController`1<T> CreateAsync(IDataProvider`1<IEnumerable`1<ProgressProvider>> progressProvider, T initialValue, IEqualityComparer`1<T> equalityComparer, ActionEvent cancelEvent, IAsyncDataControllerGroup group);
    public static IAsyncDataController`1<T> CreateAsyncWithoutValue(IDataProvider`1<IEnumerable`1<ProgressProvider>> progressProvider, IEqualityComparer`1<T> equalityComparer, ActionEvent cancelEvent, IAsyncDataControllerGroup group);
    public static IAsyncDataController`1<T> CreateAsync(T initialValue, IEqualityComparer`1<T> equalityComparer, IAsyncDataControllerGroup group);
    public static IAsyncDataController`1<T> CreateAsync(T initialValue, IAsyncDataControllerGroup group);
    public static IAsyncDataController`1<T> CreateAsync(T initialValue);
    public static IAsyncDataController`1<T> CreateAsync();
    public static IDataSignal CreatePeriodicSignal(TimeSpan fireEvery);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.DataPipes.DataProvidersExtension : object {
    [ExtensionAttribute]
public static IDataNotifier`1<T> PublishAndActivate(IDataProvider`1<T> pipe, Lifetime lifetime);
    [ExtensionAttribute]
public static IWriteableDataNotifier`1<T> PublishAndActivateWriteable(IDataProvider`1<T> source, Lifetime lifetime, Action`1<T> setValue, bool validateSetValue);
    [ExtensionAttribute]
public static IWriteableDataNotifier`1<T> PublishAndActivateWriteable(IDataController`1<T> pipeInput, Lifetime lifetime, IDataProvider`1<string> error);
    [ExtensionAttribute]
public static IDataNotifier`1<T> PublishAndActivate(IDataProvider`1<T> pipe, IDataProvider`1<bool> isActiveProvider);
    [ExtensionAttribute]
public static IWriteableDataNotifier`1<T> PublishAndActivateWriteable(IDataProvider`1<T> source, IDataProvider`1<bool> isActiveProvider, Action`1<T> setValue, bool validateSetValue);
    [ExtensionAttribute]
public static IWriteableDataNotifier`1<T> PublishAndActivateWriteable(IDataController`1<T> pipeInput, IDataProvider`1<bool> isActiveProvider, IDataProvider`1<string> error);
    [ExtensionAttribute]
public static IEnumerable`1<T> PublishCollectionAndActivate(IDataProvider`1<IEnumerable`1<T>> collectionProvider, Lifetime lifetime, CollectionNotificationMode mode);
    [ExtensionAttribute]
private static void Activate(IDataNotifier`1<T> pipeOut, IDataProvider`1<bool> isActiveProvider);
    [ExtensionAttribute]
private static void Activate(IDataNotifier`1<T> pipeOut, Lifetime lifetime);
    [ExtensionAttribute]
public static ICommandContainer Activate(ICommandContainer command, Lifetime lifetime);
    private static void PipeOutOnPropertyChanged(object sender, PropertyChangedEventArgs propertyChangedEventArgs);
    private static void PipeOutOnCanExecuteChanged(object sender, EventArgs args);
    private static void NotifierOnCollectionChanged(object sender, NotifyCollectionChangedEventArgs notifyCollectionChangedEventArgs);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.DataPipes.EnumerableEx : object {
    [ExtensionAttribute]
public static IDataProvider`1<bool> Contains(IDataProvider`1<IReadOnlyCollection`1<T>> src, T value);
    [ExtensionAttribute]
public static IDataProvider`1<IEnumerable`1<TA>> Where(IDataProvider`1<IEnumerable`1<TA>> provider, Func`2<TA, bool> filter);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<IEnumerable`1<TA>> Where(IAsyncDataProvider`1<IEnumerable`1<TA>> provider, Func`2<TA, bool> filter);
    [IteratorStateMachineAttribute("JetBrains.Common.Util.DataPipes.EnumerableEx/<AppendIfNotNull>d__3`1")]
[ExtensionAttribute]
public static IEnumerable`1<T> AppendIfNotNull(IEnumerable`1<T> items, T value);
    [IteratorStateMachineAttribute("JetBrains.Common.Util.DataPipes.EnumerableEx/<AppendIfNotNull>d__4`1")]
[ExtensionAttribute]
public static IEnumerable`1<T> AppendIfNotNull(IEnumerable`1<T> a1, IEnumerable`1<T> a2);
    [ExtensionAttribute]
public static IEnumerable`1<T> NullToDefault(IEnumerable`1<Nullable`1<T>> a);
    [IteratorStateMachineAttribute("JetBrains.Common.Util.DataPipes.EnumerableEx/<AppendIfNotNull>d__6`1")]
[ExtensionAttribute]
public static IEnumerable`1<T> AppendIfNotNull(IEnumerable`1<T> a1, IEnumerable`1<T> a2, IEnumerable`1<T> a3);
    [ExtensionAttribute]
public static IDataProvider`1<IEnumerable`1<T>> AppendIfNotNull(IDataProvider`1<IEnumerable`1<T>> provider, T item);
    [ExtensionAttribute]
public static IDataProvider`1<IReadOnlyCollection`1<T>> ToReadOnlyCollectionProvider(IObservableSet`1<T> set);
    [ExtensionAttribute]
public static IDataProvider`1<IEnumerable`1<T>> AppendIfNotNull(IDataProvider`1<IEnumerable`1<T>> provider, IEnumerable`1<T> items);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<IEnumerable`1<T>> AppendIfNotNull(IAsyncDataProvider`1<IEnumerable`1<T>> provider, IEnumerable`1<T> items);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<IEnumerable`1<T>> AppendIfNotNull(IAsyncDataProvider`1<IEnumerable`1<T>> provider, IAsyncDataProvider`1<T> itemProvider);
    [ExtensionAttribute]
public static IDataProvider`1<IEnumerable`1<T>> AppendIfNotNull(IDataProvider`1<IEnumerable`1<T>> p1, IDataProvider`1<IEnumerable`1<T>> p2);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<IEnumerable`1<T>> AppendIfNotNull(IAsyncDataProvider`1<IEnumerable`1<T>> p1, IAsyncDataProvider`1<IEnumerable`1<T>> p2);
    [ExtensionAttribute]
public static IDataProvider`1<IEnumerable`1<T>> Reverse(IDataProvider`1<IEnumerable`1<T>> src);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<IEnumerable`1<T>> Reverse(IAsyncDataProvider`1<IEnumerable`1<T>> src);
    [ExtensionAttribute]
public static IDataProvider`1<T[]> ToArray(IDataProvider`1<IEnumerable`1<T>> src);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<T[]> ToArray(IAsyncDataProvider`1<IEnumerable`1<T>> src);
    [ExtensionAttribute]
public static IDataProvider`1<T[]> EmptyArrayToNull(IDataProvider`1<T[]> src);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<T[]> EmptyArrayToNull(IAsyncDataProvider`1<T[]> src);
    [ExtensionAttribute]
public static IDataProvider`1<IReadOnlyCollection`1<T>> ToReadonlyCollection(IDataProvider`1<IEnumerable`1<T>> src, bool reuse);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<IReadOnlyCollection`1<T>> ToReadonlyCollection(IAsyncDataProvider`1<IEnumerable`1<T>> src, bool reuse);
    [ExtensionAttribute]
public static IDataProvider`1<IEnumerable`1<T>> AppendIfNotNull(IDataProvider`1<IEnumerable`1<T>> p1, IDataProvider`1<T> p2);
    [ExtensionAttribute]
public static IDataProvider`1<IEnumerable`1<T>> AppendIfNotNull(IDataProvider`1<IEnumerable`1<T>> p1, IDataProvider`1<IEnumerable`1<T>> p2, IDataProvider`1<IEnumerable`1<T>> p3);
    [ExtensionAttribute]
public static IDataProvider`1<IList`1<T>> ToList(IDataProvider`1<IEnumerable`1<T>> provider, bool reuseContainer);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<IList`1<T>> ToList(IAsyncDataProvider`1<IEnumerable`1<T>> provider, bool reuseContainer);
    [ExtensionAttribute]
public static IDataProvider`1<OneToListMap`2<TKey, TValue>> ToOneToListMap(IDataProvider`1<IEnumerable`1<KeyValuePair`2<TKey, TValue>>> provider, bool reuseContainer);
    [ExtensionAttribute]
public static IDataProvider`1<TC> ToCollection(IDataProvider`1<IEnumerable`1<T>> provider, bool reuseCollection);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<TC> ToCollection(IAsyncDataProvider`1<IEnumerable`1<T>> provider, bool reuseCollection);
    [ExtensionAttribute]
public static IDataProvider`1<TC> ToCollection(IDataProvider`1<T> provider, Func`1<TC> createCollection, Action`2<T, TC> fillCollection, bool reuseCollection);
    private static IDataProvider`1<TC> ToCollectionNoReuse(IDataProvider`1<T> provider, Func`1<TC> createCollection, Action`2<T, TC> fillCollection);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<TC> ToCollection(IAsyncDataProvider`1<T> provider, Func`1<TC> createCollection, Action`2<T, TC> fillCollection, bool reuseCollection);
    private static IAsyncDataProvider`1<TC> ToCollectionNoReuse(IAsyncDataProvider`1<T> provider, Func`1<TC> createCollection, Action`2<T, TC> fillCollection);
    [ExtensionAttribute]
public static IDataProvider`1<IEnumerable`1<T>> MergeManyEnumerables(IDataProvider`1<IEnumerable`1<IEnumerable`1<T>>> src);
    [ExtensionAttribute]
public static IDataProvider`1<bool> CheckAny(IEnumerable`1<IDataProvider`1<T>> providers, Func`2<T, bool> condition);
    [ExtensionAttribute]
public static IDataProvider`1<bool> CheckAll(IEnumerable`1<IDataProvider`1<T>> providers, Func`2<T, bool> condition);
    [ExtensionAttribute]
public static IDataProvider`1<bool> IsEmptyOrNull(IDataProvider`1<ICollection`1<T>> source);
    [ExtensionAttribute]
public static IDataProvider`1<bool> IsEmptyOrNull(IDataProvider`1<IReadOnlyCollection`1<T>> source);
    [ExtensionAttribute]
public static IDataProvider`1<bool> IsNotEmpty(IDataProvider`1<IReadOnlyCollection`1<T>> source);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<IEnumerable`1<T>> InjectController(IAsyncDataProvider`1<IEnumerable`1<T>> provider);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.DataPipes.FilterEx : object {
    [ExtensionAttribute]
public static IDataProvider`1<T> OnlyNotNull(IDataProvider`1<T> provider);
    [ExtensionAttribute]
public static IDataProvider`1<T> Filter(IDataProvider`1<T> provider, Func`2<T, bool> acceptValuePredicate);
    [ExtensionAttribute]
public static IDataProvider`1<T> Filter(IDataProvider`1<T> provider, Func`2<T, ValuePassBehavior> acceptValuePredicate);
    [ExtensionAttribute]
public static IDataProvider`1<T> FilterSafe(IDataProvider`1<T> provider, Func`2<T, bool> filter);
    [ExtensionAttribute]
public static IDataProvider`1<T> SkipIfEqualsNull(IDataProvider`1<T> provider);
    [ExtensionAttribute]
public static IDataProvider`1<Nullable`1<T>> SkipIfEqualsNull(IDataProvider`1<Nullable`1<T>> provider);
    [ExtensionAttribute]
public static IDataProvider`1<T> SkipIfEquals(IDataProvider`1<T> provider, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<T> SkipIfEquals(IAsyncDataProvider`1<T> provider, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<T> Filter(IAsyncDataProvider`1<T> provider, Func`2<T, bool> acceptValuePredicate);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<T> Filter(IAsyncDataProvider`1<T> provider, Func`2<T, ValuePassBehavior> acceptValuePredicate);
    [ExtensionAttribute]
[ObsoleteAttribute("This method actually can't guarantee that output provider will never receive 'null' value, because when any provider is activated it is initialized with default value, that is 'null' for any class type. That's why usage of this method can be really misleading and should be avoided")]
public static IDataProvider`1<T> SkipIfNull(IDataProvider`1<T> provider);
    [ExtensionAttribute]
public static IDataProvider`1<Nullable`1<T>> SkipIfNull(IDataProvider`1<Nullable`1<T>> provider);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<T> SkipIfNull(IAsyncDataProvider`1<Nullable`1<T>> provider, T defaultValue);
    [ExtensionAttribute]
public static IDataProvider`1<T> SkipIfNull(IDataProvider`1<Nullable`1<T>> provider, T defaultValue);
    [ExtensionAttribute]
public static IDataProvider`1<T> FilterWithPrev(IDataProvider`1<T> provider, AcceptNewValue`1<T> filter);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<T> FilterWithPrev(IAsyncDataProvider`1<T> provider, AcceptNewValue`1<T> filter);
    [ExtensionAttribute]
private static Func`2<T, ValuePassBehavior> Convert(Func`2<T, bool> source);
    [ExtensionAttribute]
private static AcceptNewValue2`1<T> Convert(AcceptNewValue`1<T> source);
}
internal class JetBrains.Common.Util.DataPipes.FindPathVisitor : object {
    private IDataPipeNode myTarget;
    private Stack`1<IDataProviderInternal> myStack;
    private Dictionary`2<IDataProviderInternal, int> myVisited;
    public List`1<List`1<IDataProviderInternal>> Result;
    public FindPathVisitor(IDataPipeNode target);
    public sealed virtual VisitResult StartNodeProcessing(IDataProviderInternal ptr, TVoid sharedContext);
    public sealed virtual void EndNodeProcessing(IDataProviderInternal ptr, TVoid sharedContext);
    public sealed virtual void AllNodesProcessed();
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.DataPipes.FlowIntoEx : object {
    [ExtensionAttribute]
public static void FlowInto(IDataProvider`1<PipeEventData`1<T>> src, Lifetime lifetime, IDataController`1<T> dst);
    [ExtensionAttribute]
public static void FlowInto(IDataProvider`1<T> src, Lifetime lifetime, IDataController`1<T> dst);
    [ExtensionAttribute]
public static void FlowInto(IDataProvider`1<T> src, Lifetime lifetime, IDataController`1<T> dst, Func`2<T, bool> condition);
    [ExtensionAttribute]
public static void FlowInto(IDataProvider`1<TA> src, Lifetime lifetime, IDataController`1<TB> dst, Func`2<TA, bool> condition, Func`2<TA, TB> converter);
    [ExtensionAttribute]
public static void FlowIntoSafe(IDataProvider`1<TA> src, Lifetime lifetime, IDataController`1<TB> dst, Func`2<TA, TB> converter);
    [ExtensionAttribute]
public static void FlowIntoSafe(IDataProvider`1<Nullable`1<TA>> src, Lifetime lifetime, IDataController`1<TB> dst, Func`2<TA, TB> converter);
    [ExtensionAttribute]
public static void FlowIntoProperty(IDataProvider`1<T> provider, Lifetime lifetime, IProperty`1<T> property);
    [ExtensionAttribute]
public static void FlowIntoProperty(IDataProvider`1<T> provider, Lifetime lifetime, IProperty`1<T> property, object cookie);
    [ExtensionAttribute]
public static void FlowIntoPropertyTwoWay(IDataController`1<T> controller, Lifetime lifetime, IProperty`1<T> property);
    [ExtensionAttribute]
public static void FlowChangesInto(IProperty`1<T> source, Lifetime lifetime, IDataController`1<T> target);
    [ExtensionAttribute]
public static void FlowChangesInto(IProperty`1<TA> source, Lifetime lifetime, IDataController`1<TB> target, Func`2<TA, TB> converter);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.DataPipes.FlowIntoRd : object {
    [ExtensionAttribute]
public static void BindToRd(IDataProvider`1<TI> provider, Lifetime lifetime, IViewableProperty`1<TO> property, Func`3<Lifetime, TI, TO> convertFunc);
    [ExtensionAttribute]
public static void BindToRdSafe(IDataProvider`1<TI> provider, Lifetime lifetime, IViewableProperty`1<TO> property, Func`3<Lifetime, TI, TO> convertFunc);
    [ExtensionAttribute]
public static void BindToRd(IDataProvider`1<TI> provider, Lifetime lifetime, IViewableProperty`1<TO> property, Func`2<TI, TO> transform);
    [ExtensionAttribute]
public static void BindToRd(IDataProvider`1<T> provider, Lifetime lifetime, IViewableProperty`1<T> property, T defaultValue);
    [ExtensionAttribute]
public static void BindToRd(IDataProvider`1<string> provider, Lifetime lifetime, IViewableProperty`1<string> property, Func`2<string, string> transform);
    [ExtensionAttribute]
public static void BindTwoWayRd(IDataProvider`1<T> provider, Lifetime lifetime, IViewableProperty`1<T> property, Action`1<T> protocolPropertyChanged);
    [ExtensionAttribute]
public static void BindTwoWayRd(IDataController`1<T> provider, Lifetime lifetime, IViewableProperty`1<T> property);
    [ExtensionAttribute]
public static void BindToRdMap(IDataProvider`1<IEnumerable`1<T>> provider, Lifetime lifetime, IViewableMap`2<int, T> property);
    [ExtensionAttribute]
public static void BindToRdList(IReadonlyListEvents`1<TI> sourceList, Lifetime lifetime, IList`1<TO> targetList, Func`2<TI, TO> transform);
}
public class JetBrains.Common.Util.DataPipes.Getter`1 : MulticastDelegate {
    public Getter`1(object object, IntPtr method);
    public virtual T Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual T EndInvoke(IAsyncResult result);
}
public class JetBrains.Common.Util.DataPipes.GetterAsync`1 : MulticastDelegate {
    public GetterAsync`1(object object, IntPtr method);
    public virtual T Invoke(IExecutionController controller);
    public virtual IAsyncResult BeginInvoke(IExecutionController controller, AsyncCallback callback, object object);
    public virtual T EndInvoke(IAsyncResult result);
}
public interface JetBrains.Common.Util.DataPipes.IAggregatedDataProvider`1 {
    public IDataProvider`1<T> Provider { get; }
    public abstract virtual IDataProvider`1<T> get_Provider();
}
public interface JetBrains.Common.Util.DataPipes.IAsyncDataController`1 {
}
public interface JetBrains.Common.Util.DataPipes.IAsyncDataControllerGroup {
}
public interface JetBrains.Common.Util.DataPipes.IAsyncDataProvider`1 {
}
public interface JetBrains.Common.Util.DataPipes.IAsyncDataProxy`1 {
}
public interface JetBrains.Common.Util.DataPipes.IAsyncDataSignal {
}
public interface JetBrains.Common.Util.DataPipes.IAsyncDataSignalController {
}
public interface JetBrains.Common.Util.DataPipes.ICollectionNotifier {
}
public interface JetBrains.Common.Util.DataPipes.ICollectionNotifier`1 {
}
public interface JetBrains.Common.Util.DataPipes.IDataAggregator`1 {
    public abstract virtual void Register(IDataProvider`1<T> provider, int priority);
    public abstract virtual void Unregister(IDataProvider`1<T> provider);
}
public interface JetBrains.Common.Util.DataPipes.IDataAttributeKey {
}
public interface JetBrains.Common.Util.DataPipes.IDataAttributeKey`1 {
}
public interface JetBrains.Common.Util.DataPipes.IDataController`1 {
}
public interface JetBrains.Common.Util.DataPipes.IDataControllerBase`1 {
    public T Value { get; public set; }
    public abstract virtual T get_Value();
    public abstract virtual void set_Value(T value);
    public abstract virtual void RaiseChanged();
    public abstract virtual void RaiseChanged(T value);
}
public interface JetBrains.Common.Util.DataPipes.IDataControllerContainer`1 {
    public IDataProvider`1<T> Provider { get; }
    public T Value { get; public set; }
    public abstract virtual IDataProvider`1<T> get_Provider();
    public abstract virtual T get_Value();
    public abstract virtual void set_Value(T value);
}
public interface JetBrains.Common.Util.DataPipes.IDataEvent`1 {
    public abstract virtual void Fire(T data);
}
public interface JetBrains.Common.Util.DataPipes.IDataNotifier`1 {
    [CanBeNullAttribute]
public T Value { get; }
    public abstract virtual T get_Value();
}
public interface JetBrains.Common.Util.DataPipes.IDataPipeNode {
}
public interface JetBrains.Common.Util.DataPipes.IDataProvider`1 {
    [ObsoleteAttribute("DO NOT USE THIS METHOD! It is not reliable and does not return correct value in many use cases. Moreover it could lead to exceptions (DTRC-26269)If you need value, the safest way is to create sink with sink = provider.ToSink(Lifetime) on provider and call sink.Value. The other way is to use PeekValue extension method, to extract current value from activated providerWill be removed soon")]
public abstract virtual T GetValue();
}
public interface JetBrains.Common.Util.DataPipes.IDataProviderBase`1 {
}
public interface JetBrains.Common.Util.DataPipes.IDataProviderProxyMap`2 {
    public abstract virtual void SetProvider(TKey key, IDataProvider`1<TValue> provider);
    public abstract virtual IDataProvider`1<TValue> GetProvider(TKey key);
}
public interface JetBrains.Common.Util.DataPipes.IDataProxy`1 {
}
public interface JetBrains.Common.Util.DataPipes.IDataRequestProcessor`1 {
    public abstract virtual T GetValue(IExecutionController executionController);
}
public interface JetBrains.Common.Util.DataPipes.IDataSignal {
}
public interface JetBrains.Common.Util.DataPipes.IDataSignalBase {
}
public interface JetBrains.Common.Util.DataPipes.IDataSignalController {
}
public interface JetBrains.Common.Util.DataPipes.IDataSignalControllerBase {
    public abstract virtual void Raise();
}
public interface JetBrains.Common.Util.DataPipes.IDataSignalProxy {
    unknown IDataSignal Source {public set; }
    public abstract virtual void set_Source(IDataSignal value);
}
public interface JetBrains.Common.Util.DataPipes.IDataSink`1 {
    public T Value { get; }
    public bool IsActive { get; }
    public IDataProvider`1<T> Provider { get; }
    public abstract virtual T get_Value();
    public abstract virtual bool get_IsActive();
    public abstract virtual IDataProvider`1<T> get_Provider();
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.DataPipes.IfEx : object {
    [ExtensionAttribute]
public static DataProviderIfClause`1<T> ElseIf(DataProviderIfClause`1<T> clause, IDataProvider`1<bool> condition, T result);
    [ExtensionAttribute]
public static IDataProvider`1<T> IfNull(IDataProvider`1<T> src, IDataProvider`1<T> other);
    [ExtensionAttribute]
public static IDataProvider`1<Nullable`1<T>> IfNull(IDataProvider`1<Nullable`1<T>> src, IDataProvider`1<Nullable`1<T>> other);
    [ExtensionAttribute]
public static IDataProvider`1<T> IfNull(IDataProvider`1<T> src, Func`1<T> factory);
    [ExtensionAttribute]
public static IDataProvider`1<T> IfNull(IDataProvider`1<T> src, T value);
    [ExtensionAttribute]
public static IDataProvider`1<T> IfNull(IDataProvider`1<Nullable`1<T>> src, IDataProvider`1<T> other);
    [ExtensionAttribute]
public static IDataProvider`1<T> IfReplace(IDataProvider`1<T> src, Func`2<T, bool> condition, IDataProvider`1<T> replaceTarget);
    [ExtensionAttribute]
public static IDataProvider`1<T> IfNotNull(IDataProvider`1<T> src, IDataProvider`1<T> other);
    [ExtensionAttribute]
public static DataProviderIfClause`1<T> IfTrue(IDataProvider`1<bool> condition, T trueResult);
    [ExtensionAttribute]
public static DataProviderIfClause`1<T> IfTrue(IDataProvider`1<bool> condition, IDataController`1<T> trueResult);
    [ExtensionAttribute]
public static DataProviderIfClause`1<T> IfTrue(IDataProvider`1<bool> condition, IDataProvider`1<T> trueResult);
    [ExtensionAttribute]
public static DataProviderIfClause`1<TB> If(IDataProvider`1<TA> provider, Func`2<TA, bool> condition, IDataProvider`1<TB> conditionTrueResult);
    [ExtensionAttribute]
public static DataProviderIfClause`1<T> IfFalse(IDataProvider`1<bool> condition, IDataProvider`1<T> falseResult);
}
public class JetBrains.Common.Util.DataPipes.Impl.ActionEvent : object {
    [CompilerGeneratedAttribute]
private Action Event;
    public void Raise();
    [CompilerGeneratedAttribute]
public void add_Event(Action value);
    [CompilerGeneratedAttribute]
public void remove_Event(Action value);
}
internal abstract class JetBrains.Common.Util.DataPipes.Impl.ActivatableDataNotifier`1 : ActivateableWithActivationController {
    private T myValue;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler myPropertyChanged;
    protected ActivatableDataNotifier`1(IDataProvider`1<T> provider);
    private void OnSourceUpdated(T value);
    protected void OnPropertyChanged();
    protected bool HasNoPropertyChangedSubscriptions();
    protected T GetLastValue();
    protected virtual void OnCleanup();
    protected abstract virtual IEnumerable`1<string> GetNotifierProperties();
    [CompilerGeneratedAttribute]
private void add_myPropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
private void remove_myPropertyChanged(PropertyChangedEventHandler value);
    public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    [LocalizableAttribute("False")]
public virtual string ToString();
}
public abstract class JetBrains.Common.Util.DataPipes.Impl.Activateable : object {
    private bool myIsActive;
    protected bool IsActive { get; protected set; }
    protected bool get_IsActive();
    [ThreadSafetyAttribute("1")]
protected void set_IsActive(bool value);
    [ThreadSafetyAttribute("1")]
protected virtual void OnDeactivated();
    [ThreadSafetyAttribute("1")]
protected virtual void OnActivated();
}
internal abstract class JetBrains.Common.Util.DataPipes.Impl.ActivateableWithActivationController : Activateable {
    private IDataController`1<bool> myIsSubscriptionActive;
    protected IDataController`1<bool> IsActiveController { get; }
    protected IDataController`1<bool> get_IsActiveController();
    protected virtual void OnDeactivated();
    protected virtual void OnActivated();
}
internal abstract class JetBrains.Common.Util.DataPipes.Impl.ActivateableWithWeakSubscriptionAndActivationController`1 : ActivateableWithActivationController {
    private IStaThreadDispatcher myStaDispatcher;
    protected ActivateableWithWeakSubscriptionAndActivationController`1(IDataProvider`1<T> provider);
    protected abstract virtual void OnSourceUpdated(T value);
    protected virtual override void Finalize();
}
internal class JetBrains.Common.Util.DataPipes.Impl.ActivationTrackerDataProvider`1 : DataProviderWithSource`2<T, T> {
    private IDataController`1<bool> myIsActive;
    public IDataProvider`1<bool> IsActive { get; }
    public ActivationTrackerDataProvider`1(IDataProviderBase`1<T> source);
    public IDataProvider`1<bool> get_IsActive();
    protected virtual void OnSourceUpdated(T newValue, IAttributesBag attributes);
    protected virtual void OnActivated();
    protected virtual void OnDeactivated();
}
internal class JetBrains.Common.Util.DataPipes.Impl.AsyncConstDataProvider`1 : ConstDataProvider`1<T> {
    public IAsyncController Controller { get; }
    public IExecutionController ExecutionController { get; }
    public AsyncConstDataProvider`1(T value, bool hasValue);
    public virtual IAsyncController get_Controller();
    public sealed virtual IExecutionController get_ExecutionController();
    public sealed virtual void Request(Action action);
}
internal class JetBrains.Common.Util.DataPipes.Impl.AsyncDataControllerGroup : object {
    public object LockObject;
    public IExecutionController ExecutionController { get; }
    public sealed virtual IExecutionController get_ExecutionController();
    public sealed virtual void Request(Action action);
}
internal class JetBrains.Common.Util.DataPipes.Impl.AsyncDataProvider`1 : DispatcherDataProviderBase`1<T> {
    private ManualResetEventSlim myContinuationEvent;
    private ISequentialTaskScheduler mySequentialScheduler;
    private UpdateValueLogic myUpdateLogic;
    private IExecutionController modreq(System.Runtime.CompilerServices.IsVolatile) myCurrentExecutionController;
    public IAsyncController Controller { get; }
    public IExecutionController ExecutionController { get; }
    public AsyncDataProvider`1(IDataProvider`1<T> dataProvider, ISequentialTaskScheduler sequentialScheduler, UpdateValueLogic updateLogic);
    public virtual IAsyncController get_Controller();
    protected virtual void OnDeactivated();
    protected virtual void UpdateValue(T newValue, IAttributesBag attributes);
    protected virtual void OnSourceResurrect(IAttributesBag attributes);
    protected virtual void OnSourceUpdated(T newValue, IAttributesBag attributes);
    protected virtual void ClearDispatcherQueue(ICancelArgs args);
    protected virtual void CancelRunningTask();
    protected virtual void BeginInvoke(Action action);
    public sealed virtual IExecutionController get_ExecutionController();
    private void Resume();
    private void Pause();
    private void Schedule(Action action);
}
internal enum JetBrains.Common.Util.DataPipes.Impl.AsyncMixerUpdateType : Enum {
    public int value__;
    public static AsyncMixerUpdateType None;
    public static AsyncMixerUpdateType Attribute;
    public static AsyncMixerUpdateType Value;
    public static AsyncMixerUpdateType Invalidate;
    public static AsyncMixerUpdateType Cleanup;
}
[ExtensionAttribute]
internal static class JetBrains.Common.Util.DataPipes.Impl.AsyncMixerUpdateTypeEx : object {
    [ExtensionAttribute]
public static AsyncMixerUpdateType ToAsyncMixerUpdateType(InvalidateMode mode);
}
internal class JetBrains.Common.Util.DataPipes.Impl.AsyncOperationAdapter`1 : AsyncOperationAdapter`2<T, IAsyncOperation`1<T>> {
    public AsyncOperationAdapter`1(IAsyncOperation`1<T> operation);
    protected virtual T GetResult(IAsyncOperation`1<T> operation);
}
internal abstract class JetBrains.Common.Util.DataPipes.Impl.AsyncOperationAdapter`2 : DataProvider`1<T> {
    private TA modreq(System.Runtime.CompilerServices.IsVolatile) myOperation;
    protected AsyncOperationAdapter`2(TA operation);
    protected virtual void OnActivated();
    protected virtual void OnDeactivated();
    protected abstract virtual T GetResult(TA operation);
    private void OperationOnFinished(ITask sender, EventArgs args);
}
internal class JetBrains.Common.Util.DataPipes.Impl.AsyncProxyController : object {
    private ISequentialTaskScheduler mySequentialScheduler;
    private Func`1<bool> myIsSubscriptionRunning;
    private IExecutionController myExecutionController;
    public IExecutionController ExecutionController { get; }
    public AsyncProxyController(ISequentialTaskScheduler sequentialScheduler, Func`1<bool> isSubscriptionRunning);
    public sealed virtual IExecutionController get_ExecutionController();
    public sealed virtual void Request(Action action);
}
internal class JetBrains.Common.Util.DataPipes.Impl.AsyncStreamDataProvider`1 : DataProviderWithSource`2<T, T> {
    private ISequentialTaskScheduler mySequentialScheduler;
    private IExecutionController modreq(System.Runtime.CompilerServices.IsVolatile) myCurrentExecutionController;
    public IAsyncController Controller { get; }
    public IExecutionController ExecutionController { get; }
    public AsyncStreamDataProvider`1(IDataProvider`1<T> dataProvider, ISequentialTaskScheduler sequentialScheduler);
    public virtual IAsyncController get_Controller();
    private void InvalidateValueFromSources(InvalidateMode mode);
    private void ResurrectValueFromSources(IAttributesBag attributes);
    private void UpdateValueFromSources(T value, IAttributesBag attributes);
    protected virtual void OnSourceUpdated(T newValue, IAttributesBag attributes);
    protected virtual void OnSourceInvalidate(InvalidateMode mode);
    protected virtual void OnSourceResurrect(IAttributesBag attributes);
    public sealed virtual IExecutionController get_ExecutionController();
    public sealed virtual void Request(Action action);
    private void Schedule(Action action);
}
internal class JetBrains.Common.Util.DataPipes.Impl.AsyncStreamUpdateController`1 : object {
    private Action`2<T, IAttributesBag> myUpdateValueFromSources;
    private Action`1<IAttributesBag> myResurrectValueFromSources;
    private Action`1<InvalidateMode> myInvalidateValueFromSources;
    private Action`1<Action> myQueueAction;
    public AsyncStreamUpdateController`1(Action`2<T, IAttributesBag> updateValueFromSources, Action`1<IAttributesBag> resurrectValueFromSources, Action`1<InvalidateMode> invalidateValueFromSources, Action`1<Action> queueAction);
    public sealed virtual void ClearUpdateRequestsQueueAndCancelRunningTask();
    public sealed virtual void InvalidateResurrect();
    public sealed virtual void OnSourceUpdated(T newValue, IAttributesBag attributes);
    public sealed virtual void OnSourceResurrected(IAttributesBag attributes);
    public sealed virtual void OnSourceInvalidated(InvalidateMode mode);
}
internal class JetBrains.Common.Util.DataPipes.Impl.AsyncUpdateController`1 : object {
    private Action`2<T, IAttributesBag> myUpdateValueFromSources;
    private Action`1<IAttributesBag> myResurrectValueFromSources;
    private Action`1<InvalidateMode> myInvalidateValueFromSources;
    private Action`1<Action> myQueueAction;
    [CanBeNullAttribute]
private Action myCancelAction;
    private ResurectController myResurrectController;
    private object myLockObject;
    private T myLastSourceValue;
    private IAttributesBag myLastSourceAttributes;
    private AsyncUpdateControllerUpdateType myUpdateRequested;
    private AsyncUpdateControllerRunningState myCanCancelState;
    public AsyncUpdateController`1(Action`2<T, IAttributesBag> updateValueFromSources, Action`1<IAttributesBag> resurrectValueFromSources, Action`1<InvalidateMode> invalidateValueFromSources, Action`1<Action> queueAction, Action cancelAction);
    public void ClearValue();
    public void DoUpdate();
    private void InvalidateValueFromSources(InvalidateMode mode);
    private void ResurrectValueFromSources(IAttributesBag attributes);
    private void UpdateValueFromSources(T value, IAttributesBag attributes);
    private void QueueAction(Action doUpdate, AsyncUpdateControllerUpdateType value);
    private void RunRequestCore(Action action);
    public sealed virtual void ClearUpdateRequestsQueueAndCancelRunningTask();
    public sealed virtual void OnSourceUpdated(T newValue, IAttributesBag attributes);
    public sealed virtual void OnSourceResurrected(IAttributesBag attributes);
    public sealed virtual void OnSourceInvalidated(InvalidateMode mode);
    public void Request(Action action);
    public sealed virtual void InvalidateResurrect();
}
internal enum JetBrains.Common.Util.DataPipes.Impl.AsyncUpdateControllerRunningState : Enum {
    public int value__;
    public static AsyncUpdateControllerRunningState FinishedOrNotStartedYet;
    public static AsyncUpdateControllerRunningState RunningUserCode;
}
internal enum JetBrains.Common.Util.DataPipes.Impl.AsyncUpdateControllerUpdateType : Enum {
    public int value__;
    public static AsyncUpdateControllerUpdateType None;
    public static AsyncUpdateControllerUpdateType Attribute;
    public static AsyncUpdateControllerUpdateType Value;
    public static AsyncUpdateControllerUpdateType Invalidate;
    public static AsyncUpdateControllerUpdateType Cleanup;
    public static AsyncUpdateControllerUpdateType ValueThenInvalidate;
}
internal class JetBrains.Common.Util.DataPipes.Impl.AttributeExtractorProvider`2 : DataProviderWithSource`2<TSource, ValueWithAttribute`2<TSource, TAttribute>> {
    private IDataAttributeKey myKey;
    private Action myAttributeKeyNotFoundAction;
    private Maybe`1<TAttribute> myLastAttributePayload;
    private Maybe`1<TSource> myLastValue;
    public AttributeExtractorProvider`2(IDataProviderInternal`1<TSource> source, IDataAttributeKey key, Action attributeKeyNotFoundAction);
    protected virtual void ClearValue();
    protected virtual void OnSourceUpdated(TSource newValue, IAttributesBag attributes);
    protected virtual void OnSourceResurrect(IAttributesBag attributes);
    protected virtual void OnSourceInvalidate(InvalidateMode mode);
}
internal class JetBrains.Common.Util.DataPipes.Impl.AttributeProvider`2 : DataProviderWithSource`2<TSource, TSource> {
    private IDataAttributeKey myKey;
    private Func`2<TSource, TAttr> myGetAttribute;
    private Maybe`1<TAttr> myPayload;
    public AttributeProvider`2(IDataProviderInternal`1<TSource> source, IDataAttributeKey key, Func`2<TSource, TAttr> getAttribute);
    protected virtual void ClearValue();
    protected virtual void OnSourceUpdated(TSource newValue, IAttributesBag attributes);
    protected virtual void UpdateValue(TSource newValue, IAttributesBag attributes);
    protected virtual void ResurrectValue(IAttributesBag attributes);
}
internal class JetBrains.Common.Util.DataPipes.Impl.AttributeRemovalProvider`1 : DataProviderWithSource`2<TSource, TSource> {
    [NotNullAttribute]
private IDataAttributeKey myKey;
    public AttributeRemovalProvider`1(IDataProviderBase`1<TSource> source, IDataAttributeKey key);
    protected virtual void OnSourceUpdated(TSource newValue, IAttributesBag attributes);
    protected virtual void OnSourceResurrect(IAttributesBag attributes);
}
internal class JetBrains.Common.Util.DataPipes.Impl.AttributesBag : object {
    private IDictionary`2<IDataAttributeKey, IDataAttributeInternal> myBag;
    private static MergeMarkers ourMergeMarkersIfFailGetFromFirstSource;
    private static MergeMarkers ourMergeMarkersDefault;
    public int Count { get; }
    public AttributesBag(AttributesBag oldBag, IDataAttributeKey key, IDataAttributeInternal attribute);
    private AttributesBag(IDictionary`2<IDataAttributeKey, IDataAttributeInternal> bag);
    private static AttributesBag();
    [LocalizableAttribute("False")]
public virtual string ToString();
    private static bool MergeMarkersDefault(IDataAttributeInternal attribute1, IDataAttributeInternal attribute2, IDataAttributeInternal& mergedAttribute);
    private static bool MergeMarkersIfFailGetFromFirstSource(IDataAttributeInternal attribute1, IDataAttributeInternal attribute2, IDataAttributeInternal& mergedAttribute);
    public sealed virtual IDataAttributeInternal GetAttribute(IDataAttributeKey key);
    public static IAttributesBag RemoveAttribute(IAttributesBag bag, IDataAttributeKey key);
    public static bool TryExtractAttributePayload(IAttributesBag attributes, IDataAttributeKey key, TPayload& payload);
    public static bool MergeBagsIfFailGetFromFirstSource(IAttributesBag bag1, IAttributesBag bag2, IAttributesBag& result);
    public static bool MergeBags(IAttributesBag bag1, IAttributesBag bag2, IAttributesBag& result);
    public int get_Count();
    private static bool MergeBagsCore(IAttributesBag bag1, IAttributesBag bag2, IAttributesBag& result, MergeMarkers mergeDelegate);
    public static bool BagsAreEqual(IAttributesBag bag1, IAttributesBag bag2);
}
public class JetBrains.Common.Util.DataPipes.Impl.AttributesExceptions : Exception {
    public AttributesExceptions(string message);
    [StringFormatMethodAttribute("format")]
public AttributesExceptions(string format, object param1);
    [StringFormatMethodAttribute("format")]
public AttributesExceptions(string format, object param1, object param2);
    [StringFormatMethodAttribute("format")]
public AttributesExceptions(string format, object param1, object param2, object param3);
    [StringFormatMethodAttribute("format")]
public AttributesExceptions(string format, Object[] parameters);
}
internal class JetBrains.Common.Util.DataPipes.Impl.AttributeWithPayload`1 : object {
    private TA myAttributePayload;
    public AttributeWithPayload`1(TA attributePayload);
    public sealed virtual bool MergeMarkers(IDataAttributeInternal secondAttribute, IDataAttributeInternal& result);
    public virtual T ExtractAttribute();
    [LocalizableAttribute("False")]
public virtual string ToString();
}
internal class JetBrains.Common.Util.DataPipes.Impl.AutoIncrementAttributeKey : object {
    private static int ourNextIndex;
    private int myId;
    private AutoIncrementAttributeKey(int id);
    protected AutoIncrementAttributeKey(SerializationInfo info, StreamingContext context);
    public static IDataAttributeKey BuildNewKey();
    private bool Equals(AutoIncrementAttributeKey other);
    public sealed virtual bool Equals(IDataAttributeKey other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [LocalizableAttribute("False")]
public virtual string ToString();
}
internal class JetBrains.Common.Util.DataPipes.Impl.BindDataProvider`1 : ProxyDataProvider`1<TV> {
    private object myLockObject;
    private AsyncUpdateController`1<IDataProviderBase`1<TV>> myUpdateController;
    private IDataProviderInternal`1<IDataProviderBase`1<TV>> mySwitchKeyProvider;
    private DataMixerSubscriptionBase`1<IDataProviderBase`1<TV>> mySubscription;
    private BindState<TV> myState;
    private bool myMainProviderWasInitialized;
    private IAttributesBag myMainProviderLastAttributes;
    private IAttributesBag myOuterProviderAttributes;
    private IAttributesBag myMergedAttributes;
    public IAttributesBag Attributes { get; }
    public IDataProviderInternal[] Sources { get; }
    public BindDataProvider`1(bool isStream, IDataProvider`1<IDataProviderBase`1<TV>> switchKeyProvider, bool clearPipelineOnEmptySource, ISequentialTaskScheduler sequentialScheduler);
    public virtual IAttributesBag get_Attributes();
    public virtual IDataProvider`1<IEnumerable`1<ProgressProvider>> GetProgressProvider();
    protected virtual IDataProvider`1<IEnumerable`1<ProgressProvider>> GetUninitializedProgressProvider();
    private void QueueAction(Action action);
    private void OnSourceInvalidatedCore(InvalidateMode mode);
    private void OnSourceResurrectedCore(IAttributesBag attributes);
    private void OnSourceUpdatedCore(IDataProviderBase`1<TV> value, IAttributesBag attributes);
    private IDataProviderInternal`1<TV> GetNullProvider();
    protected virtual void OnLastSubscriptionInvalidated();
    public virtual IDataProviderInternal[] get_Sources();
    protected virtual void OnActivated();
    protected virtual void ClearValue();
    protected virtual void OnDeactivated();
    protected virtual void UpdateValue(TV newValue, IAttributesBag attributes);
    protected virtual void ResurrectValue(IAttributesBag attributes);
    protected virtual void InvalidateValue(InvalidateMode mode);
}
internal class JetBrains.Common.Util.DataPipes.Impl.BreakPipelineDataProvider`1 : SwitchToMainThreadDataProvider`1<T> {
    private IEqualityComparer`1<T> myComparer;
    public BreakPipelineDataProvider`1(IDataProviderBase`1<T> source, IStaThreadDispatcher dispatcher, IEqualityComparer`1<T> comparer);
    protected virtual void OnActivated();
    protected virtual void UpdateValue(T newValue, IAttributesBag attributes);
    protected virtual void ResurrectValue(IAttributesBag attributes);
    protected virtual void OnDeactivated();
}
internal class JetBrains.Common.Util.DataPipes.Impl.CancelableExecutionControllerProxy : ExecutionControllerProxy {
    private Func`1<bool> myIsCancelled;
    public CancelableExecutionControllerProxy(IExecutionController target, Func`1<bool> isCancelled);
    public virtual IExecutionController CreateSubOperation(int parentStepsCount);
    public virtual void Yield();
}
internal class JetBrains.Common.Util.DataPipes.Impl.CancelArgs : object {
    public static ICancelArgs AbortEverything;
    public static ICancelArgs AbortComputations;
    public static ICancelArgs PauseComputations;
    private CancelType myType;
    public bool IsPause { get; }
    public bool IsAbortEverything { get; }
    private CancelArgs(CancelType cancelType);
    private static CancelArgs();
    public sealed virtual bool get_IsPause();
    public sealed virtual bool get_IsAbortEverything();
    public virtual string ToString();
}
internal class JetBrains.Common.Util.DataPipes.Impl.CancelledExecutionController : object {
    public static IExecutionController Instance;
    public int RecommendedParallelizmDegree { get; }
    private static CancelledExecutionController();
    public sealed virtual void Dispose();
    public sealed virtual IExecutionController StartProgress(int stepsCount, string operationName);
    public sealed virtual IExecutionController CreateSubOperation(int parentStepsCount);
    public sealed virtual IExecutionController AttachSubOperation(Task task, int parentStepsCount);
    public sealed virtual void AdvanceProgress();
    public sealed virtual void Yield();
    public sealed virtual void Wait(IWaitable waitable, TimeSpan timeout);
    public sealed virtual Task`1<T1> Fork(Func`2<IExecutionController, T1> action);
    public sealed virtual int get_RecommendedParallelizmDegree();
}
public enum JetBrains.Common.Util.DataPipes.Impl.CancelType : Enum {
    public int value__;
    public static CancelType PauseAsyncActivities;
    public static CancelType CancelAsyncActivities;
    public static CancelType CancelAllActivities;
}
internal class JetBrains.Common.Util.DataPipes.Impl.CoherentMarker`1 : object {
    private TA myAttributePayload;
    public CoherentMarker`1(TA attributePayload);
    public sealed virtual bool MergeMarkers(IDataAttributeInternal secondAttribute, IDataAttributeInternal& result);
    public virtual T ExtractAttribute();
    [LocalizableAttribute("False")]
public virtual string ToString();
}
internal class JetBrains.Common.Util.DataPipes.Impl.Collections.DataCollectionKeepPrefixNotifier`1 : DataCollectionNotifier`1<T> {
    private IList`1<T> myOldValues;
    private IList`1<T> myNewValues;
    protected IEnumerable`1<T> Value { get; }
    public DataCollectionKeepPrefixNotifier`1(IDataProvider`1<IEnumerable`1<T>> source);
    protected virtual IEnumerable`1<T> get_Value();
    protected virtual void OnSourceUpdated(IEnumerable`1<T> newValue);
}
internal class JetBrains.Common.Util.DataPipes.Impl.Collections.DataCollectionMoveNotifier`1 : DataCollectionNotifier`1<T> {
    private List`1<T> myList;
    protected IEnumerable`1<T> Value { get; }
    public DataCollectionMoveNotifier`1(IDataProvider`1<IEnumerable`1<T>> source);
    protected virtual IEnumerable`1<T> get_Value();
    private void Move(int src, int dst);
    protected virtual void OnSourceUpdated(IEnumerable`1<T> newValue);
}
internal abstract class JetBrains.Common.Util.DataPipes.Impl.Collections.DataCollectionNotifier`1 : ActivateableWithWeakSubscriptionAndActivationController`1<IEnumerable`1<T>> {
    private IDataController`1<bool> myIsSubscriptionActive;
    private NotifyCollectionChangedEventHandler myCollectionChanged;
    protected IEnumerable`1<T> Value { get; }
    protected DataCollectionNotifier`1(IDataProvider`1<IEnumerable`1<T>> source);
    protected abstract virtual IEnumerable`1<T> get_Value();
    protected void RaiseCollectionChanged(NotifyCollectionChangedEventArgs args);
    public sealed virtual void add_CollectionChanged(NotifyCollectionChangedEventHandler value);
    public sealed virtual void remove_CollectionChanged(NotifyCollectionChangedEventHandler value);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class JetBrains.Common.Util.DataPipes.Impl.Collections.DataCollectionResetNotifier`1 : DataCollectionNotifier`1<T> {
    private IEnumerable`1<T> myValue;
    protected IEnumerable`1<T> Value { get; }
    public DataCollectionResetNotifier`1(IDataProvider`1<IEnumerable`1<T>> source);
    protected virtual IEnumerable`1<T> get_Value();
    protected virtual void OnSourceUpdated(IEnumerable`1<T> newValue);
}
public class JetBrains.Common.Util.DataPipes.Impl.ConstDataNotifier`1 : object {
    private T myValue;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    public object UntypedValue { get; }
    public T Value { get; }
    public ConstDataNotifier`1(T value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    public sealed virtual object get_UntypedValue();
    public sealed virtual T get_Value();
}
internal class JetBrains.Common.Util.DataPipes.Impl.ConstDataProvider`1 : object {
    private T myValue;
    private bool myHasValue;
    public IAsyncController Controller { get; }
    public IDataProviderInternal[] Sources { get; }
    public bool HasValue { get; }
    public bool IsActivated { get; }
    public IAttributesBag Attributes { get; }
    public T Value { get; }
    public ConstDataProvider`1(T value, bool hasValue);
    public sealed virtual T GetValue();
    public virtual IAsyncController get_Controller();
    public virtual IDataProvider`1<IEnumerable`1<ProgressProvider>> GetProgressProvider();
    public sealed virtual IDataProviderInternal[] get_Sources();
    public sealed virtual bool get_HasValue();
    public sealed virtual bool get_IsActivated();
    public sealed virtual IDataProvider`1<TOut> TransformToDefault();
    public virtual void Subscribe(IDataProviderSubscription`1<T> handler);
    public sealed virtual void Unsubscribe(IDataProviderSubscription`1<T> handler);
    public sealed virtual IAttributesBag get_Attributes();
    public sealed virtual T get_Value();
    public sealed virtual T GetStateAttributeAndValueAtomic(IAttributesBag& attributes, Boolean& hasValue);
}
internal class JetBrains.Common.Util.DataPipes.Impl.ControlledDataProviderWithSource`2 : DataProviderWithSource`2<TA, TB> {
    [NotNullAttribute]
private Action`2<ControlledTransformArgument`1<TA>, ITransformController`1<TB>> mySourceUpdateController;
    private IAttributesBag myLastAttributes;
    [CompilerGeneratedAttribute]
private TB <LastSuccessfulValue>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <WasInvalidated>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <WasInitialized>k__BackingField;
    public TB LastSuccessfulValue { get; private set; }
    public bool WasInvalidated { get; private set; }
    public bool WasInitialized { get; private set; }
    public ControlledDataProviderWithSource`2(IDataProvider`1<TA> source, Action`2<ControlledTransformArgument`1<TA>, ITransformController`1<TB>> sourceUpdateController);
    protected virtual void ClearValue();
    protected virtual void OnSourceUpdated(TA newValue, IAttributesBag attributes);
    protected virtual void OnSourceResurrect(IAttributesBag attributes);
    protected virtual void OnSourceInvalidate(InvalidateMode mode);
    [CompilerGeneratedAttribute]
public sealed virtual TB get_LastSuccessfulValue();
    [CompilerGeneratedAttribute]
private void set_LastSuccessfulValue(TB value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_WasInvalidated();
    [CompilerGeneratedAttribute]
private void set_WasInvalidated(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_WasInitialized();
    [CompilerGeneratedAttribute]
private void set_WasInitialized(bool value);
    public sealed virtual void RaiseResurrect();
    public sealed virtual void RaiseChanged(TB value);
    public sealed virtual void RaiseInvalidate(InvalidateMode mode);
}
[ExtensionAttribute]
internal static class JetBrains.Common.Util.DataPipes.Impl.DataAttributeHelpers : object {
    [ExtensionAttribute]
public static T CastAttributePayload(TA payload);
}
internal class JetBrains.Common.Util.DataPipes.Impl.DataController`1 : DataProvider`1<T> {
    private IEqualityComparer`1<T> myComparer;
    public IAttributesBag Attributes { get; }
    public T Value { get; public set; }
    public DataController`1(T initialValue, IEqualityComparer`1<T> comparer);
    public DataController`1(IEqualityComparer`1<T> comparer);
    protected virtual void OnActivated();
    protected virtual void OnDeactivated();
    public virtual IAttributesBag get_Attributes();
    public virtual T get_Value();
    public virtual void set_Value(T value);
    public sealed virtual void RaiseChanged();
    public sealed virtual void RaiseChanged(T value);
    public sealed virtual void Raise();
}
internal class JetBrains.Common.Util.DataPipes.Impl.DataControllerWithSourceReference`1 : DataController`1<T> {
    [CompilerGeneratedAttribute]
private IDataProviderInternal <Reference>k__BackingField;
    public IDataProviderInternal Reference { get; }
    public DataControllerWithSourceReference`1(T initialValue, IEqualityComparer`1<T> comparer, IDataProviderInternal reference);
    [CompilerGeneratedAttribute]
public sealed virtual IDataProviderInternal get_Reference();
}
internal class JetBrains.Common.Util.DataPipes.Impl.DataConverter`2 : DataProviderWithSource`2<TA, TB> {
    private Func`2<TA, TB> myConverter;
    public DataConverter`2(Func`2<TA, TB> converter, IDataProvider`1<TA> source);
    protected virtual void OnSourceUpdated(TA newValue, IAttributesBag attributes);
}
internal class JetBrains.Common.Util.DataPipes.Impl.DataConverterWithLifetime`2 : DataProviderWithSource`2<TA, TB> {
    private Func`3<Lifetime, TA, TB> myConverter;
    private Lifetime myParentLifetime;
    private SequentialLifetimes myLifetimeRow;
    public DataConverterWithLifetime`2(Lifetime parentLifetime, Func`3<Lifetime, TA, TB> converter, IDataProvider`1<TA> source);
    protected virtual void OnSourceUpdated(TA newValue, IAttributesBag attributes);
    protected virtual void ClearValue();
}
internal class JetBrains.Common.Util.DataPipes.Impl.DataEvent`1 : DataProvider`1<PipeEventData`1<T>> {
    public sealed virtual void Fire(T data);
    protected virtual void InitializeValueCore(IDataProviderSubscription`1<PipeEventData`1<T>> handler);
}
internal class JetBrains.Common.Util.DataPipes.Impl.DataMixer2`3 : DataMixerBase`1<TC> {
    private Func`3<TA, TB, TC> myConverter;
    private bool myIgnoreSecondSourceState;
    private IDataProviderInternal`1<TA> mySource1;
    private DataMixerSubscriptionWithLastState`1<TA> mySubscription1;
    private IDataProviderInternal`1<TB> mySource2;
    private DataMixerSubscriptionWithLastState`1<TB> mySubscription2;
    public IDataProviderInternal[] Sources { get; }
    public IAsyncController Controller { get; }
    public DataMixer2`3(IDataProvider`1<TA> source1, IDataProvider`1<TB> source2, Func`3<TA, TB, TC> converter, bool ignoreSecondSourceState);
    private void CancelComputations2(ICancelArgs obj);
    private void OnSourceInvalidate2(InvalidateMode mode);
    public virtual IDataProviderInternal[] get_Sources();
    public virtual IDataProvider`1<IEnumerable`1<ProgressProvider>> GetProgressProvider();
    public virtual IAsyncController get_Controller();
    protected virtual void ClearValue();
    protected virtual bool SourcesHasValue();
    protected virtual bool TryMergeAttributes(IAttributesBag& attributes);
    protected virtual TC MergeValues();
    protected virtual void SubscribeSources();
    protected virtual void UnsubscribeSources();
    protected virtual void OnSource2Updated(TB newValue, IAttributesBag attributes);
    protected virtual void OnSource1Updated(TA newValue, IAttributesBag attributes);
}
internal class JetBrains.Common.Util.DataPipes.Impl.DataMixer3`4 : DataMixerBase`1<TD> {
    private Func`4<TA, TB, TC, TD> myConverter;
    private IDataProviderInternal`1<TC> mySource3;
    private DataMixerSubscriptionWithLastState`1<TC> mySubscription3;
    private IDataProviderInternal`1<TB> mySource2;
    private DataMixerSubscriptionWithLastState`1<TB> mySubscription2;
    private IDataProviderInternal`1<TA> mySource1;
    private DataMixerSubscriptionWithLastState`1<TA> mySubscription1;
    public IDataProviderInternal[] Sources { get; }
    public IAsyncController Controller { get; }
    public DataMixer3`4(IDataProvider`1<TA> source1, IDataProvider`1<TB> source2, IDataProvider`1<TC> source3, Func`4<TA, TB, TC, TD> converter);
    public virtual IDataProviderInternal[] get_Sources();
    public virtual IDataProvider`1<IEnumerable`1<ProgressProvider>> GetProgressProvider();
    public virtual IAsyncController get_Controller();
    protected virtual void ClearValue();
    protected virtual bool SourcesHasValue();
    protected virtual TD MergeValues();
    protected virtual bool TryMergeAttributes(IAttributesBag& attributes);
    protected virtual void UnsubscribeSources();
    protected virtual void SubscribeSources();
    [CompilerGeneratedAttribute]
private void <.ctor>b__7_0(TA value, IAttributesBag attributes);
    [CompilerGeneratedAttribute]
private void <.ctor>b__7_1(TB value, IAttributesBag attributes);
    [CompilerGeneratedAttribute]
private void <.ctor>b__7_2(TC value, IAttributesBag attributes);
}
internal class JetBrains.Common.Util.DataPipes.Impl.DataMixer4`5 : DataMixerBase`1<TE> {
    private Func`5<TA, TB, TC, TD, TE> myConverter;
    private IDataProviderInternal`1<TA> mySource1;
    private DataMixerSubscriptionWithLastState`1<TA> mySubscription1;
    private IDataProviderInternal`1<TB> mySource2;
    private DataMixerSubscriptionWithLastState`1<TB> mySubscription2;
    private IDataProviderInternal`1<TC> mySource3;
    private DataMixerSubscriptionWithLastState`1<TC> mySubscription3;
    private IDataProviderInternal`1<TD> mySource4;
    private DataMixerSubscriptionWithLastState`1<TD> mySubscription4;
    public IDataProviderInternal[] Sources { get; }
    public IAsyncController Controller { get; }
    public DataMixer4`5(IDataProvider`1<TA> source1, IDataProvider`1<TB> source2, IDataProvider`1<TC> source3, IDataProvider`1<TD> source4, Func`5<TA, TB, TC, TD, TE> converter);
    public virtual IDataProviderInternal[] get_Sources();
    public virtual IDataProvider`1<IEnumerable`1<ProgressProvider>> GetProgressProvider();
    public virtual IAsyncController get_Controller();
    protected virtual void ClearValue();
    protected virtual bool SourcesHasValue();
    protected virtual TE MergeValues();
    protected virtual bool TryMergeAttributes(IAttributesBag& attributes);
    protected virtual void UnsubscribeSources();
    protected virtual void SubscribeSources();
    [CompilerGeneratedAttribute]
private void <.ctor>b__9_0(TA value, IAttributesBag attributes);
    [CompilerGeneratedAttribute]
private void <.ctor>b__9_1(TB value, IAttributesBag attributes);
    [CompilerGeneratedAttribute]
private void <.ctor>b__9_2(TC value, IAttributesBag attributes);
    [CompilerGeneratedAttribute]
private void <.ctor>b__9_3(TD value, IAttributesBag attributes);
}
internal class JetBrains.Common.Util.DataPipes.Impl.DataMixer5`6 : DataMixerBase`1<TF> {
    private Func`6<TA, TB, TC, TD, TE, TF> myConverter;
    private IDataProviderInternal`1<TA> mySource1;
    private DataMixerSubscriptionWithLastState`1<TA> mySubscription1;
    private IDataProviderInternal`1<TB> mySource2;
    private DataMixerSubscriptionWithLastState`1<TB> mySubscription2;
    private IDataProviderInternal`1<TC> mySource3;
    private DataMixerSubscriptionWithLastState`1<TC> mySubscription3;
    private IDataProviderInternal`1<TD> mySource4;
    private DataMixerSubscriptionWithLastState`1<TD> mySubscription4;
    private IDataProviderInternal`1<TE> mySource5;
    private DataMixerSubscriptionWithLastState`1<TE> mySubscription5;
    public IDataProviderInternal[] Sources { get; }
    public IAsyncController Controller { get; }
    public DataMixer5`6(IDataProvider`1<TA> source1, IDataProvider`1<TB> source2, IDataProvider`1<TC> source3, IDataProvider`1<TD> source4, IDataProvider`1<TE> source5, Func`6<TA, TB, TC, TD, TE, TF> converter);
    public virtual IDataProviderInternal[] get_Sources();
    public virtual IDataProvider`1<IEnumerable`1<ProgressProvider>> GetProgressProvider();
    public virtual IAsyncController get_Controller();
    protected virtual void ClearValue();
    protected virtual bool SourcesHasValue();
    protected virtual TF MergeValues();
    protected virtual bool TryMergeAttributes(IAttributesBag& attributes);
    protected virtual void UnsubscribeSources();
    protected virtual void SubscribeSources();
    [CompilerGeneratedAttribute]
private void <.ctor>b__11_0(TA value, IAttributesBag attributes);
    [CompilerGeneratedAttribute]
private void <.ctor>b__11_1(TB value, IAttributesBag attributes);
    [CompilerGeneratedAttribute]
private void <.ctor>b__11_2(TC value, IAttributesBag attributes);
    [CompilerGeneratedAttribute]
private void <.ctor>b__11_3(TD value, IAttributesBag attributes);
    [CompilerGeneratedAttribute]
private void <.ctor>b__11_4(TE value, IAttributesBag attributes);
}
internal class JetBrains.Common.Util.DataPipes.Impl.DataMixer6`7 : DataMixerBase`1<TJ> {
    private Func`7<TA, TB, TC, TD, TE, TF, TJ> myConverter;
    private IDataProviderInternal`1<TA> mySource1;
    private DataMixerSubscriptionWithLastState`1<TA> mySubscription1;
    private IDataProviderInternal`1<TB> mySource2;
    private DataMixerSubscriptionWithLastState`1<TB> mySubscription2;
    private IDataProviderInternal`1<TC> mySource3;
    private DataMixerSubscriptionWithLastState`1<TC> mySubscription3;
    private IDataProviderInternal`1<TD> mySource4;
    private DataMixerSubscriptionWithLastState`1<TD> mySubscription4;
    private IDataProviderInternal`1<TE> mySource5;
    private DataMixerSubscriptionWithLastState`1<TE> mySubscription5;
    private IDataProviderInternal`1<TF> mySource6;
    private DataMixerSubscriptionWithLastState`1<TF> mySubscription6;
    public IDataProviderInternal[] Sources { get; }
    public IAsyncController Controller { get; }
    public DataMixer6`7(IDataProvider`1<TA> source1, IDataProvider`1<TB> source2, IDataProvider`1<TC> source3, IDataProvider`1<TD> source4, IDataProvider`1<TE> source5, IDataProvider`1<TF> source6, Func`7<TA, TB, TC, TD, TE, TF, TJ> converter);
    public virtual IDataProviderInternal[] get_Sources();
    public virtual IDataProvider`1<IEnumerable`1<ProgressProvider>> GetProgressProvider();
    public virtual IAsyncController get_Controller();
    protected virtual void ClearValue();
    protected virtual bool SourcesHasValue();
    protected virtual TJ MergeValues();
    protected virtual bool TryMergeAttributes(IAttributesBag& attributes);
    protected virtual void UnsubscribeSources();
    protected virtual void SubscribeSources();
    [CompilerGeneratedAttribute]
private void <.ctor>b__13_0(TA value, IAttributesBag attributes);
    [CompilerGeneratedAttribute]
private void <.ctor>b__13_1(TB value, IAttributesBag attributes);
    [CompilerGeneratedAttribute]
private void <.ctor>b__13_2(TC value, IAttributesBag attributes);
    [CompilerGeneratedAttribute]
private void <.ctor>b__13_3(TD value, IAttributesBag attributes);
    [CompilerGeneratedAttribute]
private void <.ctor>b__13_4(TE value, IAttributesBag attributes);
    [CompilerGeneratedAttribute]
private void <.ctor>b__13_5(TF value, IAttributesBag attributes);
}
internal class JetBrains.Common.Util.DataPipes.Impl.DataMixerAsync2`3 : DataProvider`1<TC> {
    private Func`3<TA, TB, TC> myConverter;
    private IDataProviderInternal`1<TA> mySource1;
    private DataMixerSubscriptionBase`1<TA> mySubscription1;
    private IDataProviderInternal`1<TB> mySource2;
    private DataMixerSubscriptionBase`1<TB> mySubscription2;
    private IAsyncController myController;
    private ResurectController myResurrectController;
    private IAttributesBag myAttributes;
    private AsyncMixerUpdateType modreq(System.Runtime.CompilerServices.IsVolatile) myIsPartialUpdateRequested;
    private object mySource2UpdateLockObject;
    private TB myLastSource2Value;
    private IAttributesBag myLastSource2Attributes;
    private bool myLastSource2HasValue;
    private int myState;
    public IDataProviderInternal[] Sources { get; }
    public IAttributesBag Attributes { get; }
    public IAsyncController Controller { get; }
    public IExecutionController ExecutionController { get; }
    public IAsyncController Parent { get; }
    public DataMixerAsync2`3(IAsyncDataProvider`1<TA> source1, IDataProvider`1<TB> source2, Func`3<TA, TB, TC> converter);
    public virtual IDataProviderInternal[] get_Sources();
    protected virtual void ClearValue();
    [ThreadSafetyAttribute("2")]
private void UpdateValueFromSources(TA value1, IAttributesBag attributes1, TB value2, IAttributesBag attributes2);
    [ThreadSafetyAttribute("2")]
private void UpdateAttributesFromSources(IAttributesBag attributes1, IAttributesBag attributes2);
    [ThreadSafetyAttribute("2")]
private void OnAttribute1Updated(IAttributesBag attributes);
    [ThreadSafetyAttribute("4")]
private void OnAttribute2Updated(IAttributesBag attributes);
    [ThreadSafetyAttribute("4")]
private void OnSource2Invalidate(InvalidateMode mode);
    [ThreadSafetyAttribute("2")]
private void OnSource1Invalidate(InvalidateMode mode);
    public virtual IAttributesBag get_Attributes();
    public virtual IAsyncController get_Controller();
    public virtual IDataProvider`1<IEnumerable`1<ProgressProvider>> GetProgressProvider();
    [ThreadSafetyAttribute("1")]
protected virtual void OnActivated();
    [ThreadSafetyAttribute("1")]
protected virtual void OnDeactivated();
    [ThreadSafetyAttribute("4")]
private void OnSource2Updated();
    [ThreadSafetyAttribute("2")]
private void PartialUpdate();
    [ThreadSafetyAttribute("2")]
private void OnSource1Updated();
    public sealed virtual IExecutionController get_ExecutionController();
    [ThreadSafetyAttribute("4294967295")]
public sealed virtual void Request(Action action);
    private bool IsCancelled();
    public sealed virtual IAsyncController get_Parent();
    [CompilerGeneratedAttribute]
private void <.ctor>b__8_0(TA value, IAttributesBag attributes);
    [CompilerGeneratedAttribute]
private void <.ctor>b__8_1(TB value, IAttributesBag attributes);
}
internal abstract class JetBrains.Common.Util.DataPipes.Impl.DataMixerBase`1 : DataProvider`1<T> {
    private bool myResurrectIsPossible;
    private IAttributesBag myAttributes;
    public IAttributesBag Attributes { get; }
    public virtual IAttributesBag get_Attributes();
    protected void OnSourceResurrect(IAttributesBag attributes);
    protected void OnSourceInvalidate(InvalidateMode mode);
    protected void UpdateValueFromSources();
    protected virtual void ClearValue();
    protected virtual void OnActivated();
    protected virtual void OnDeactivated();
    protected abstract virtual bool SourcesHasValue();
    protected abstract virtual T MergeValues();
    protected abstract virtual bool TryMergeAttributes(IAttributesBag& attributes);
    protected abstract virtual void UnsubscribeSources();
    protected abstract virtual void SubscribeSources();
}
internal class JetBrains.Common.Util.DataPipes.Impl.DataMixerN`2 : DataMixerBase`1<TB> {
    private IDataProviderInternal`1[] mySources;
    private DataMixerSubscriptionWithLastState`1[] mySubscription;
    private Func`2<TA[], TB> myConverter;
    private TA[] mySourceValues;
    public IDataProviderInternal[] Sources { get; }
    public IAsyncController Controller { get; }
    public DataMixerN`2(Func`2<TA[], TB> converter, IDataProviderInternal`1[] providers);
    protected virtual void SubscriptionUpdateValueFromSources(TA value, IAttributesBag attributes);
    protected virtual void SubscriptionOnSourceResurrect(IAttributesBag attributes);
    protected virtual void SubscriptionInvalidateValue(InvalidateMode mode);
    public virtual IDataProvider`1<IEnumerable`1<ProgressProvider>> GetProgressProvider();
    public virtual IDataProviderInternal[] get_Sources();
    protected virtual void ClearValue();
    public virtual IAsyncController get_Controller();
    protected virtual bool SourcesHasValue();
    protected virtual TB MergeValues();
    protected virtual bool TryMergeAttributes(IAttributesBag& attributes);
    protected virtual void UnsubscribeSources();
    protected virtual void SubscribeSources();
}
internal class JetBrains.Common.Util.DataPipes.Impl.DataMixerNDeferring`2 : DataMixerN`2<TA, TB> {
    private IStaThreadDispatcher myDispatcher;
    private AsyncUpdateController`1<TA> myUpdateController;
    public DataMixerNDeferring`2(Func`2<TA[], TB> converter, IDataProviderInternal`1[] providers, IStaThreadDispatcher dispatcher);
    protected virtual void OnActivated();
    protected virtual void OnDeactivated();
    protected virtual void ClearValue();
    protected virtual void SubscriptionUpdateValueFromSources(TA value, IAttributesBag attributes);
    protected virtual void SubscriptionOnSourceResurrect(IAttributesBag attributes);
    protected virtual void SubscriptionInvalidateValue(InvalidateMode mode);
    private void CancelAction();
    private void QueueAction(Action action);
}
internal class JetBrains.Common.Util.DataPipes.Impl.DataMixerSubscriptionBase`1 : object {
    private Action`2<T, IAttributesBag> myUpdateAction;
    private Action`1<IAttributesBag> myAttributeUpdateAction;
    private Action`1<ICancelArgs> myCancelAction;
    private Action`1<InvalidateMode> myOnInvalidate;
    public bool NeedInvalidateOnActivation { get; }
    public DataMixerSubscriptionBase`1(Action`2<T, IAttributesBag> updateAction, Action`1<IAttributesBag> attributeUpdateAction, Action`1<InvalidateMode> onInvalidate, Action`1<ICancelArgs> cancelAction);
    protected virtual void Update(T value, IAttributesBag attributes);
    protected virtual void Invalidate(InvalidateMode mode);
    protected virtual void Resurrect(IAttributesBag attributes);
    public sealed virtual bool get_NeedInvalidateOnActivation();
    public sealed virtual void OnValueUpdated(T value, IAttributesBag attributes);
    public sealed virtual void OnInvalidate(InvalidateMode mode);
    public sealed virtual void OnResurrect(IAttributesBag attributes);
    public sealed virtual void OnCancelComputations(ICancelArgs cancelArgs);
}
internal class JetBrains.Common.Util.DataPipes.Impl.DataMixerSubscriptionWithLastState`1 : DataMixerSubscriptionBase`1<T> {
    private bool myHasValue;
    private T myLastValue;
    private IAttributesBag myLastAttributes;
    public bool HasValue { get; }
    public T Value { get; }
    public IAttributesBag Attributes { get; }
    public DataMixerSubscriptionWithLastState`1(Action`2<T, IAttributesBag> updateAction, Action`1<IAttributesBag> attributeUpdateAction, Action`1<InvalidateMode> onInvalidate, Action`1<ICancelArgs> cancelAction);
    public bool get_HasValue();
    public T get_Value();
    public IAttributesBag get_Attributes();
    public void DoCleanup();
    protected virtual void Update(T value, IAttributesBag attributes);
    protected virtual void Invalidate(InvalidateMode mode);
    protected virtual void Resurrect(IAttributesBag attributes);
}
internal abstract class JetBrains.Common.Util.DataPipes.Impl.DataProvider`1 : DataProviderBase {
    private T myValue;
    private HasValueState myHasValue;
    private HandlerListNode modreq(System.Runtime.CompilerServices.IsVolatile) myHandlers;
    private bool myIsCanceling;
    private static int Idle;
    private static int Deactivated;
    private static int Updating;
    private static int Cleaning;
    private int myState;
    public IAsyncController Controller { get; }
    public IDataProviderInternal[] Sources { get; }
    public bool HasValue { get; }
    public IAttributesBag Attributes { get; }
    public T Value { get; }
    public bool IsActivated { get; }
    protected DataProvider`1(T initialValue, bool hasValue, int initialState);
    protected DataProvider`1(T initialValue, bool hasValue);
    public virtual IAsyncController get_Controller();
    public virtual IDataProvider`1<IEnumerable`1<ProgressProvider>> GetProgressProvider();
    public virtual IDataProviderInternal[] get_Sources();
    public sealed virtual bool get_HasValue();
    public sealed virtual IDataProvider`1<TOut> TransformToDefault();
    public sealed virtual void Subscribe(IDataProviderSubscription`1<T> handler);
    private void InitializeValueAsync(IAsyncController controller, HandlerListNode<T> subscription);
    private void InitializeValueSync(HandlerListNode<T> subscription);
    protected virtual void InitializeValueCore(IDataProviderSubscription`1<T> handler);
    public sealed virtual void Unsubscribe(IDataProviderSubscription`1<T> handler);
    public virtual IAttributesBag get_Attributes();
    public sealed virtual T get_Value();
    public sealed virtual T GetStateAttributeAndValueAtomic(IAttributesBag& attributes, Boolean& hasValue);
    public sealed virtual T GetValue();
    protected void RaiseUpdated();
    public sealed virtual bool get_IsActivated();
    private void RemoveHandler(IDataProviderSubscription`1<T> handler);
    protected void UnsubscribeAllHandlers();
    protected virtual bool CheckBeforeAddHandler();
    [ThreadSafetyAttribute("4294967295", "0")]
protected virtual void ClearValue();
    protected virtual void OnDeactivated();
    protected virtual void OnActivated();
    [ThreadSafetyAttribute("4294967295", "0")]
protected virtual void CancelComputations(ICancelArgs cancelArgs);
    protected void UpdateValueAndLogUserExceptions(Func`2<TContext, Pair`2<T, IAttributesBag>> getValue, TContext context);
    protected virtual void ResurrectValue(IAttributesBag attributes);
    private void ResurrectValueCore(IAttributesBag attributes);
    protected virtual void InvalidateValue(InvalidateMode mode);
    private void InvalidateValueCore(InvalidateMode mode);
    protected virtual void UpdateValue(T newValue, IAttributesBag attributes);
    private void UpdateValueCore(T newValue, IAttributesBag attributes);
    private void RunWithCleanup(T value, IAttributesBag attributes, ControlledTransformArgumentType type);
    private bool SwitchToUpdatingState();
    private void SwitchToIdleState();
}
internal abstract class JetBrains.Common.Util.DataPipes.Impl.DataProviderBase : object {
    protected static PipesLogger ourLogger;
    private static DataProviderBase();
    [ConditionalAttribute("JET_MODE_ANNOTATE_DATA_PROVIDERS")]
[ConditionalAttribute("JET_MODE_ANNOTATE_DATA_PROVIDERS_ALLOCATION_CALLSTACKS")]
[ConditionalAttribute("JET_MODE_ANNOTATE_DATA_PROVIDERS_REGISTRATOR")]
internal void LogDebugProvider(string moniker);
}
internal class JetBrains.Common.Util.DataPipes.Impl.DataProviderCommand`1 : ActivateableWithWeakSubscriptionAndActivationController`1<T> {
    private Predicate`1<T> myCanExecute;
    private Action`1<T> myExecute;
    private T myValue;
    private bool myFireCanExecuteChangedOnSubscribe;
    [CompilerGeneratedAttribute]
private EventHandler myCanExecuteChanged;
    public DataProviderCommand`1(IDataProvider`1<T> source, Predicate`1<T> canExecute, Action`1<T> execute);
    public sealed virtual void Execute(object parameter);
    public sealed virtual bool CanExecute(object parameter);
    [CompilerGeneratedAttribute]
private void add_myCanExecuteChanged(EventHandler value);
    [CompilerGeneratedAttribute]
private void remove_myCanExecuteChanged(EventHandler value);
    public sealed virtual void add_CanExecuteChanged(EventHandler value);
    public sealed virtual void remove_CanExecuteChanged(EventHandler value);
    protected virtual void OnSourceUpdated(T value);
}
internal class JetBrains.Common.Util.DataPipes.Impl.DataProviderWithHasValue`1 : DataProviderWithSource`2<T, Initializable`1<T>> {
    public DataProviderWithHasValue`1(IDataProvider`1<T> source);
    protected virtual void OnActivated();
    protected virtual void ResurrectValue(IAttributesBag attributes);
    protected virtual void OnSourceUpdated(T newValue, IAttributesBag attributes);
    protected virtual void InvalidateValue(InvalidateMode mode);
    private void FireUpdateValue(T newValue, IAttributesBag attributes);
    [CompilerGeneratedAttribute]
private void <OnActivated>b__1_0();
    [CompilerGeneratedAttribute]
private void <OnActivated>b__1_1();
}
internal abstract class JetBrains.Common.Util.DataPipes.Impl.DataProviderWithSingleSubscription`2 : DataProviderWithSource`2<TA, TB> {
    protected DataProviderWithSingleSubscription`2(IDataProvider`1<TA> source);
    protected virtual bool CheckBeforeAddHandler();
}
internal abstract class JetBrains.Common.Util.DataPipes.Impl.DataProviderWithSource`2 : DataProvider`1<TOutput> {
    private IDataProviderInternal`1<TInput> mySource;
    private IAttributesBag myAttributes;
    private bool myWasInitialized;
    public IAttributesBag Attributes { get; }
    public IDataProviderInternal[] Sources { get; }
    protected IDataProviderInternal`1<TInput> Source { get; }
    public IAsyncController Controller { get; }
    public bool NeedInvalidateOnActivation { get; }
    protected DataProviderWithSource`2(IDataProviderBase`1<TInput> source);
    public virtual IAttributesBag get_Attributes();
    public virtual IDataProviderInternal[] get_Sources();
    protected virtual void ClearValue();
    public virtual IDataProvider`1<IEnumerable`1<ProgressProvider>> GetProgressProvider();
    protected IDataProviderInternal`1<TInput> get_Source();
    public virtual IAsyncController get_Controller();
    protected virtual void OnActivated();
    protected virtual void OnDeactivated();
    protected abstract virtual void OnSourceUpdated(TInput newValue, IAttributesBag attributes);
    protected virtual void OnSourceResurrect(IAttributesBag attributes);
    protected virtual void OnSourceInvalidate(InvalidateMode mode);
    public virtual bool get_NeedInvalidateOnActivation();
    public sealed virtual void OnValueUpdated(TInput value, IAttributesBag attributes);
    public sealed virtual void OnInvalidate(InvalidateMode mode);
    public sealed virtual void OnResurrect(IAttributesBag attributes);
    public sealed virtual void OnCancelComputations(ICancelArgs cancelArgs);
    protected virtual void UpdateValue(TOutput newValue, IAttributesBag attributes);
    protected virtual void ResurrectValue(IAttributesBag attributes);
    protected virtual void InvalidateValue(InvalidateMode mode);
}
internal class JetBrains.Common.Util.DataPipes.Impl.DataRequestProcessor`1 : DataSubscriptionBase`1<T> {
    private object myLockObject;
    private IDataProviderInternal`1<T> mySource;
    private IDataController`1<bool> myIsActiveProvider;
    private IDataProvider`1<int> myProgress;
    private Maybe`1<T> myLastValue;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) myLastProgress;
    public DataRequestProcessor`1(IDataProviderBase`1<T> source);
    private void ProgressChanged(int value);
    protected virtual void OnActivated();
    protected virtual void OnDeactivated();
    public virtual void OnInvalidate(InvalidateMode mode);
    public virtual void OnResurrect(IAttributesBag attributes);
    public virtual void OnValueUpdated(T value, IAttributesBag attributes);
    public sealed virtual T GetValue(IExecutionController executionController);
}
internal class JetBrains.Common.Util.DataPipes.Impl.DataSignalController`1 : DataController`1<T> {
    private bool myFireOnSubscribe;
    public DataSignalController`1(T initialValue, IEqualityComparer`1<T> comparer, bool fireOnSubscribe);
    protected virtual void InitializeValueCore(IDataProviderSubscription`1<T> handler);
}
internal class JetBrains.Common.Util.DataPipes.Impl.DataSink`1 : DataSubscriptionBase`1<T> {
    private T myValue;
    public T Value { get; }
    private bool JetBrains.Common.Util.DataPipes.IDataSink<T>.IsActive { get; }
    public IDataProvider`1<T> Provider { get; }
    public DataSink`1(IDataProviderBase`1<T> source);
    public sealed virtual T get_Value();
    protected virtual void OnDeactivated();
    public virtual void OnValueUpdated(T value, IAttributesBag attributes);
    public virtual void OnInvalidate(InvalidateMode mode);
    private sealed virtual override bool JetBrains.Common.Util.DataPipes.IDataSink<T>.get_IsActive();
    public sealed virtual IDataProvider`1<T> get_Provider();
}
internal class JetBrains.Common.Util.DataPipes.Impl.DataSubscription`1 : DataSubscriptionBase`1<T> {
    private ValueUpdatedHandler`1<T> myHandler;
    private bool myIgnoreCleanup;
    public DataSubscription`1(ValueUpdatedHandler`1<T> handler, IDataProviderBase`1<T> source, bool ignoreCleanup);
    public virtual void OnValueUpdated(T value, IAttributesBag attributes);
    public virtual void OnInvalidate(InvalidateMode mode);
}
internal abstract class JetBrains.Common.Util.DataPipes.Impl.DataSubscriptionBase`1 : Activateable {
    private IDataProviderInternal`1<T> mySource;
    private IStaThreadDispatcher myDispatcher;
    [ThreadSafetyAttribute("4294967295", "0")]
public bool IsActive { get; public set; }
    protected IDataProvider`1<T> Source { get; }
    public bool NeedInvalidateOnActivation { get; }
    protected DataSubscriptionBase`1(IDataProviderBase`1<T> source);
    public bool get_IsActive();
    public sealed virtual void set_IsActive(bool value);
    private void OnSetIsActive(bool value);
    private void SetActive();
    private void SetInactive();
    protected IDataProvider`1<T> get_Source();
    protected virtual void OnActivated();
    protected virtual void OnDeactivated();
    public sealed virtual bool get_NeedInvalidateOnActivation();
    public abstract virtual void OnValueUpdated(T value, IAttributesBag attributes);
    public virtual void OnInvalidate(InvalidateMode mode);
    public virtual void OnResurrect(IAttributesBag attributes);
    public virtual void OnCancelComputations(ICancelArgs cancelArgs);
}
internal class JetBrains.Common.Util.DataPipes.Impl.DelayedActionsManager : object {
    [ThreadStaticAttribute]
private static DelayedActionsManager ourManager;
    private IList`1<Action> myDelayedActions;
    private int myDepth;
    private static DelayedActionsManager Instance { get; }
    public static void Enqueue(Action action);
    private void AddAction(Action action);
    public static void OnBeforeSubscription();
    public static void OnAfterSubscription();
    private void IncrementDepth();
    private void DecrementDepth();
    private static DelayedActionsManager get_Instance();
}
public class JetBrains.Common.Util.DataPipes.Impl.DelegatedTwoStepDisposable : object {
    private Action myPrepare;
    private Action myDispose;
    public DelegatedTwoStepDisposable(Action prepare, Action dispose);
    public sealed virtual void PrepareForDispose();
    public sealed virtual void Dispose();
}
internal class JetBrains.Common.Util.DataPipes.Impl.DerivedAsyncDataController`1 : DataController`1<T> {
    private IAsyncController myController;
    public IAsyncController Controller { get; }
    public DerivedAsyncDataController`1(IAsyncController controller, T initialValue, IEqualityComparer`1<T> comparer);
    public virtual IAsyncController get_Controller();
}
internal abstract class JetBrains.Common.Util.DataPipes.Impl.DispatcherDataProviderBase`1 : DataProviderWithSource`2<T, T> {
    private Lifetime myPipelineTerminationLifetime;
    private AsyncUpdateController`1<T> myUpdateController;
    private CancellationTokenRegistration myCancellationTokenRegistration;
    protected DispatcherDataProviderBase`1(IDataProviderBase`1<T> source, Lifetime pipelineTerminationLifetime);
    protected virtual void OnDeactivated();
    protected virtual void OnActivated();
    [ThreadSafetyAttribute("4294967295", "0")]
protected sealed virtual void CancelComputations(ICancelArgs args);
    protected virtual void ClearDispatcherQueue(ICancelArgs args);
    protected virtual void ClearValue();
    private void InvalidateValueFromSources(InvalidateMode mode);
    private void ResurrectValueFromSources(IAttributesBag attributes);
    private void UpdateValueFromSources(T value, IAttributesBag attributes);
    private void CancelAction();
    private void QueueAction(Action action);
    protected void DoUpdate();
    protected void ClearUpdateRequestsQueueAndCancelRunningTask();
    public sealed virtual void Request(Action action);
    protected virtual void OnSourceUpdated(T newValue, IAttributesBag attributes);
    protected abstract virtual void CancelRunningTask();
    protected abstract virtual void BeginInvoke(Action action);
    protected virtual void OnSourceResurrect(IAttributesBag attributes);
    protected virtual void OnSourceInvalidate(InvalidateMode mode);
    [CompilerGeneratedAttribute]
private void <OnActivated>b__5_0();
}
public class JetBrains.Common.Util.DataPipes.Impl.DoubleBuffer`2 : object {
    private SlotData[] mySlots;
    private int myReadySlot;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) myReadyFlag;
    private object myLock;
    private TimeSpan myTimeout;
    private int BufferSlot { get; }
    public DoubleBuffer`2(TimeSpan timeout, Func`1<TContainer> createContainer);
    public DoubleBuffer`2(TContainer primary, TContainer secondary, TimeSpan timeout);
    public sealed virtual TContainer LockBufferForWriting();
    public sealed virtual void ReleaseBufferCancel();
    private int get_BufferSlot();
    public sealed virtual void ReleaseBufferReady(TValue value);
    public sealed virtual TValue GrabValue();
}
internal class JetBrains.Common.Util.DataPipes.Impl.DoubleBufferRecyclingProvider`3 : DataProviderWithSingleSubscription`2<TSource, Getter`1<TValue>> {
    private Func`3<TSource, TContainer, TValue> myFillAction;
    private IDoubleBuffer`2<TContainer, TValue> myBuffer;
    public DoubleBufferRecyclingProvider`3(IDataProviderBase`1<TSource> source, Func`1<TContainer> createContainer, Func`3<TSource, TContainer, TValue> fillAction, TimeSpan timeout);
    protected virtual void OnSourceUpdated(TSource newValue, IAttributesBag attributes);
}
internal class JetBrains.Common.Util.DataPipes.Impl.EmptyDataSubscription`1 : object {
    public static EmptyDataSubscription`1<T> Instance;
    public bool NeedInvalidateOnActivation { get; }
    private static EmptyDataSubscription`1();
    public sealed virtual bool get_NeedInvalidateOnActivation();
    public sealed virtual void OnValueUpdated(T value, IAttributesBag attributes);
    public sealed virtual void OnInvalidate(InvalidateMode mode);
    public sealed virtual void OnResurrect(IAttributesBag attributes);
    public sealed virtual void OnCancelComputations(ICancelArgs cancelArgs);
}
internal class JetBrains.Common.Util.DataPipes.Impl.ExternalExecutorDataProvider`1 : DataProviderWithSource`2<T, T> {
    private Action`1<Action> myExecutor;
    public IAsyncController Controller { get; }
    public ExternalExecutorDataProvider`1(IDataProvider`1<T> source, Action`1<Action> executor);
    protected virtual void OnSourceUpdated(T newValue, IAttributesBag attributes);
    protected virtual void OnSourceInvalidate(InvalidateMode mode);
    protected virtual void OnSourceResurrect(IAttributesBag attributes);
    public virtual IAsyncController get_Controller();
}
internal class JetBrains.Common.Util.DataPipes.Impl.FilteringDataProvider`1 : FilteringDataProviderBase`1<T> {
    private Func`2<T, ValuePassBehavior> myFilter;
    public FilteringDataProvider`1(Func`2<T, ValuePassBehavior> filter, IDataProvider`1<T> source);
    protected virtual ValuePassBehavior AcceptNewValue(T newValue);
}
internal abstract class JetBrains.Common.Util.DataPipes.Impl.FilteringDataProviderBase`1 : DataProviderWithSource`2<T, T> {
    private FilteringDataProviderConsistencyState myConsistencyState;
    protected bool WasInitialized { get; }
    protected FilteringDataProviderBase`1(IDataProvider`1<T> source);
    protected bool get_WasInitialized();
    protected virtual void CancelComputations(ICancelArgs cancelArgs);
    protected abstract virtual ValuePassBehavior AcceptNewValue(T newValue);
    protected virtual void OnSourceUpdated(T newValue, IAttributesBag attributes);
    protected virtual void OnSourceResurrect(IAttributesBag attributes);
    protected virtual void ClearValue();
}
internal enum JetBrains.Common.Util.DataPipes.Impl.FilteringDataProviderConsistencyState : Enum {
    public int value__;
    public static FilteringDataProviderConsistencyState NotInitialized;
    public static FilteringDataProviderConsistencyState ResurrectImpossible;
    public static FilteringDataProviderConsistencyState Consistent;
}
internal class JetBrains.Common.Util.DataPipes.Impl.FilteringWithPrevDataProvider`1 : FilteringDataProviderBase`1<T> {
    private AcceptNewValue2`1<T> myFilter;
    public FilteringWithPrevDataProvider`1(IDataProvider`1<T> source, AcceptNewValue2`1<T> filter);
    protected virtual ValuePassBehavior AcceptNewValue(T newValue);
}
internal class JetBrains.Common.Util.DataPipes.Impl.GetterThreadSwitch`1 : object {
    [CompilerGeneratedAttribute]
private IDataProviderInternal`1<Getter`1<T>> <GetterProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsStream>k__BackingField;
    public IDataProviderInternal`1<Getter`1<T>> GetterProvider { get; }
    public IDataProviderInternal`1<T> ValueProvider { get; }
    public bool IsStream { get; }
    public GetterThreadSwitch`1(IDataProviderInternal`1<Getter`1<T>> getterProvider, bool isStream);
    [CompilerGeneratedAttribute]
public sealed virtual IDataProviderInternal`1<Getter`1<T>> get_GetterProvider();
    public sealed virtual IDataProviderInternal`1<T> get_ValueProvider();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsStream();
}
internal interface JetBrains.Common.Util.DataPipes.Impl.IAsyncController {
    [ThreadSafetyAttribute("4294967295", "0")]
public IExecutionController ExecutionController { get; }
    public abstract virtual IExecutionController get_ExecutionController();
    [ThreadSafetyAttribute("4294967295", "0")]
public abstract virtual void Request(Action action);
}
internal interface JetBrains.Common.Util.DataPipes.Impl.IAsyncUpdateController`1 {
    public abstract virtual void ClearUpdateRequestsQueueAndCancelRunningTask();
    public abstract virtual void OnSourceUpdated(T newValue, IAttributesBag attributes);
    public abstract virtual void OnSourceResurrected(IAttributesBag attributes);
    public abstract virtual void OnSourceInvalidated(InvalidateMode mode);
    public abstract virtual void InvalidateResurrect();
}
internal interface JetBrains.Common.Util.DataPipes.Impl.IAttributesBag {
    [CanBeNullAttribute]
public abstract virtual IDataAttributeInternal GetAttribute(IDataAttributeKey key);
}
internal interface JetBrains.Common.Util.DataPipes.Impl.ICancelArgs {
    public bool IsPause { get; }
    public bool IsAbortEverything { get; }
    public abstract virtual bool get_IsPause();
    public abstract virtual bool get_IsAbortEverything();
}
internal interface JetBrains.Common.Util.DataPipes.Impl.IChildAsyncController {
    public IAsyncController Parent { get; }
    public abstract virtual IAsyncController get_Parent();
}
internal interface JetBrains.Common.Util.DataPipes.Impl.IDataAttributeInternal {
    public abstract virtual bool MergeMarkers(IDataAttributeInternal secondAttribute, IDataAttributeInternal& result);
    public abstract virtual T ExtractAttribute();
}
internal interface JetBrains.Common.Util.DataPipes.Impl.IDataControllerWithSourceReference {
    public IDataProviderInternal Reference { get; }
    public abstract virtual IDataProviderInternal get_Reference();
}
internal interface JetBrains.Common.Util.DataPipes.Impl.IDataProviderInternal {
    [CanBeNullAttribute]
public IAsyncController Controller { get; }
    public IDataProviderInternal[] Sources { get; }
    public bool HasValue { get; }
    public bool IsActivated { get; }
    public abstract virtual IAsyncController get_Controller();
    [CanBeNullAttribute]
public abstract virtual IDataProvider`1<IEnumerable`1<ProgressProvider>> GetProgressProvider();
    public abstract virtual IDataProviderInternal[] get_Sources();
    public abstract virtual bool get_HasValue();
    public abstract virtual bool get_IsActivated();
    public abstract virtual IDataProvider`1<TOut> TransformToDefault();
}
internal interface JetBrains.Common.Util.DataPipes.Impl.IDataProviderInternal`1 {
    [CanBeNullAttribute]
public IAttributesBag Attributes { get; }
    [CanBeNullAttribute]
public T Value { get; }
    [ThreadSafetyAttribute("1", "1")]
public abstract virtual void Subscribe(IDataProviderSubscription`1<T> handler);
    [ThreadSafetyAttribute("1", "1")]
public abstract virtual void Unsubscribe(IDataProviderSubscription`1<T> handler);
    public abstract virtual IAttributesBag get_Attributes();
    public abstract virtual T get_Value();
    [ThreadSafetyAttribute("2", "1")]
public abstract virtual T GetStateAttributeAndValueAtomic(IAttributesBag& attributes, Boolean& hasValue);
}
internal interface JetBrains.Common.Util.DataPipes.Impl.IDataProviderSubscription`1 {
    public bool NeedInvalidateOnActivation { get; }
    public abstract virtual bool get_NeedInvalidateOnActivation();
    public abstract virtual void OnValueUpdated(T value, IAttributesBag attributes);
    public abstract virtual void OnInvalidate(InvalidateMode mode);
    public abstract virtual void OnResurrect(IAttributesBag attributes);
    public abstract virtual void OnCancelComputations(ICancelArgs cancelArgs);
}
internal interface JetBrains.Common.Util.DataPipes.Impl.IDataSubscription {
    unknown bool IsActive {public set; }
    public abstract virtual void set_IsActive(bool value);
}
public interface JetBrains.Common.Util.DataPipes.Impl.IDoubleBuffer`2 {
    public abstract virtual TContainer LockBufferForWriting();
    public abstract virtual void ReleaseBufferCancel();
    public abstract virtual void ReleaseBufferReady(TValue value);
    public abstract virtual TValue GrabValue();
}
internal class JetBrains.Common.Util.DataPipes.Impl.ImplicitlyAsyncDataController`1 : DataController`1<T> {
    private IDataProvider`1<IEnumerable`1<ProgressProvider>> myProgressProvider;
    private ActionEvent myCancelEvent;
    private AsyncDataControllerGroup myAsyncGroup;
    public IAsyncController Controller { get; }
    public ImplicitlyAsyncDataController`1(T initialValue, IEqualityComparer`1<T> comparer, IDataProvider`1<IEnumerable`1<ProgressProvider>> progressProvider, ActionEvent cancelEvent, AsyncDataControllerGroup asyncGroup);
    public ImplicitlyAsyncDataController`1(IEqualityComparer`1<T> comparer, IDataProvider`1<IEnumerable`1<ProgressProvider>> progressProvider, ActionEvent cancelEvent, AsyncDataControllerGroup asyncGroup);
    private void CancelEventOnEvent();
    protected virtual void UpdateValue(T newValue, IAttributesBag attributes);
    protected virtual void ResurrectValue(IAttributesBag attributes);
    protected virtual void InvalidateValue(InvalidateMode mode);
    protected virtual void OnActivated();
    protected virtual void OnDeactivated();
    public virtual IDataProvider`1<IEnumerable`1<ProgressProvider>> GetProgressProvider();
    public virtual IAsyncController get_Controller();
}
internal class JetBrains.Common.Util.DataPipes.Impl.ImplicitlyAsyncDataSignalController`1 : ImplicitlyAsyncDataController`1<T> {
    public ImplicitlyAsyncDataSignalController`1(T initialValue, IEqualityComparer`1<T> comparer, IDataProvider`1<IEnumerable`1<ProgressProvider>> progressProvider, ActionEvent cancelEvent, AsyncDataControllerGroup asyncGroup);
    protected virtual void InitializeValueCore(IDataProviderSubscription`1<T> handler);
}
internal class JetBrains.Common.Util.DataPipes.Impl.Initializable`1 : ValueType {
    public bool IsInitialized;
    public T Value;
}
public enum JetBrains.Common.Util.DataPipes.Impl.InvalidateMode : Enum {
    public int value__;
    public static InvalidateMode KeepLastValue;
    public static InvalidateMode Cleanup;
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.DataPipes.Impl.InvalidateModeEx : object {
    [ExtensionAttribute]
public static ControlledTransformArgumentType ToControlledTransformArgumentType(InvalidateMode mode);
}
internal interface JetBrains.Common.Util.DataPipes.Impl.IProgressDataProvider {
    public ProgressProvider Progress { get; }
    public abstract virtual ProgressProvider get_Progress();
}
internal interface JetBrains.Common.Util.DataPipes.Impl.IRemotableReferenceCore`1 {
}
internal interface JetBrains.Common.Util.DataPipes.Impl.IThreadSwitchInternal`1 {
    [CanBeNullAttribute]
public IDataProviderInternal`1<Getter`1<T>> GetterProvider { get; }
    [CanBeNullAttribute]
public IDataProviderInternal`1<T> ValueProvider { get; }
    public abstract virtual IDataProviderInternal`1<Getter`1<T>> get_GetterProvider();
    public abstract virtual IDataProviderInternal`1<T> get_ValueProvider();
}
internal interface JetBrains.Common.Util.DataPipes.Impl.ITripleBuffer`2 {
    public TContainer BackBuffer { get; }
    public abstract virtual TContainer get_BackBuffer();
    public abstract virtual void SetReady(TValue value);
    public abstract virtual TValue GrabValue();
}
internal class JetBrains.Common.Util.DataPipes.Impl.LifetimedDataProvider`1 : DataProviderWithSource`2<T, T> {
    private IDataController`1<bool> myIsLifetimeSubscriptionActive;
    private bool myIsTerminated;
    public LifetimedDataProvider`1(IDataProvider`1<T> source, DataPipeLifetime lifetime);
    protected virtual bool CheckBeforeAddHandler();
    protected virtual void OnDeactivated();
    protected virtual void OnSourceUpdated(T newValue, IAttributesBag attributes);
    public sealed virtual void PrepareForDispose();
    public sealed virtual void Dispose();
}
internal class JetBrains.Common.Util.DataPipes.Impl.LocalReference`1 : object {
    [CompilerGeneratedAttribute]
private T <Value>k__BackingField;
    public T Value { get; public set; }
    public LocalReference`1(T value);
    [CompilerGeneratedAttribute]
public T get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(T value);
}
internal class JetBrains.Common.Util.DataPipes.Impl.PausableExecutionControllerProxy : ExecutionControllerProxy {
    private IWaitable myContinuationEvent;
    public PausableExecutionControllerProxy(IExecutionController target, IWaitable continuationEvent);
    public virtual IExecutionController CreateSubOperation(int parentStepsCount);
    public virtual void Yield();
}
internal class JetBrains.Common.Util.DataPipes.Impl.PeriodicSignalProvider : DataProvider`1<TVoid> {
    private ITimer myTimer;
    public PeriodicSignalProvider(TimeSpan interval);
    protected virtual void OnDeactivated();
    private void TimerOnTick(object sender, EventArgs eventArgs);
    protected virtual void OnActivated();
}
public class JetBrains.Common.Util.DataPipes.Impl.PipesLogger : object {
    private ILogger myLogger;
    [ThreadStaticAttribute]
private static int ourDepth;
    private LoggingLevel myLevel;
    public bool IsEnabled { get; }
    public PipesLogger(string category, LoggingLevel level);
    public void Begin(string message);
    public void Begin(string message, T1 t1);
    public void Begin(string message, T1 t1, T2 t2);
    public void Begin(string message, T1 t1, T2 t2, T3 t3);
    public void Begin(string message, T1 t1, T2 t2, T3 t3, T4 t4);
    public void Begin(string message, Object[] args);
    public bool get_IsEnabled();
    public void Message(string message);
    public void Message(LoggingLevel level, string message);
    public void Message(string message, T1 t1);
    public void Message(LoggingLevel level, string message, T1 t1);
    public void Message(string message, T1 t1, T2 t2);
    public void Message(LoggingLevel level, string message, T1 t1, T2 t2);
    public void Message(string message, T1 t1, T2 t2, T3 t3);
    public void Message(LoggingLevel level, string message, T1 t1, T2 t2, T3 t3);
    public void Message(string message, T1 t1, T2 t2, T3 t3, T4 t4);
    public void Message(LoggingLevel level, string message, T1 t1, T2 t2, T3 t3, T4 t4);
    public void Message(string message, Object[] args);
    public void Message(LoggingLevel level, string message, Object[] args);
    private string AddIdent(string message);
    public void End(string message);
    public void End(string message, T1 t1);
    public void End(string message, T1 t1, T2 t2);
    public void End(string message, T1 t1, T2 t2, T3 t3);
    public void End(string message, T1 t1, T2 t2, T3 t3, T4 t4);
    public void End(string message, Object[] args);
}
internal class JetBrains.Common.Util.DataPipes.Impl.ProgressDataProvider`1 : DataProviderWithSource`2<T, T> {
    private string myDefaultTitle;
    private IAsyncDataController`1<double> myProgressValue;
    private IAsyncDataController`1<string> myTitle;
    private IAsyncDataController`1<AsyncComputationState> myState;
    private ProgressProvider myProgress;
    [NotNullAttribute]
private IAsyncController myAsyncController;
    private ExecutionController<T> myCurrentExecutionController;
    public ProgressProvider Progress { get; }
    public ProgressDataProvider`1(IDataProviderInternal`1<T> source, string defaultTitle);
    protected virtual void OnActivated();
    public void OnExecutionInterrupted();
    public IExecutionController OnExecutionStarted();
    public void OnExecutionCompleted();
    public virtual IDataProvider`1<IEnumerable`1<ProgressProvider>> GetProgressProvider();
    protected virtual void OnSourceResurrect(IAttributesBag attributes);
    protected virtual void OnSourceInvalidate(InvalidateMode mode);
    protected virtual void OnSourceUpdated(T newValue, IAttributesBag attributes);
    public sealed virtual ProgressProvider get_Progress();
    [CompilerGeneratedAttribute]
private IEnumerable`1<ProgressProvider> <GetProgressProvider>b__12_0(IEnumerable`1<ProgressProvider> e);
}
internal class JetBrains.Common.Util.DataPipes.Impl.ProgressIndicatorDataProvider : DataProviderWithSource`2<ProgressProvider, ProgressProvider> {
    private IDataController`1<IEnumerable`1<ProgressProvider>> myController;
    private ProgressProvider[] myReadyProvider;
    public ProgressIndicatorDataProvider(IDataProvider`1<ProgressProvider> source);
    public virtual IDataProvider`1<IEnumerable`1<ProgressProvider>> GetProgressProvider();
    protected virtual void OnSourceUpdated(ProgressProvider newValue, IAttributesBag attributes);
}
internal class JetBrains.Common.Util.DataPipes.Impl.PropertyDataProvider`1 : DataProvider`1<T> {
    private IProperty`1<T> myProperty;
    private LifetimeDefinition mySubscriptionLifetime;
    public PropertyDataProvider`1(IProperty`1<T> property);
    protected virtual void OnActivated();
    protected virtual void OnDeactivated();
    private void Handler(PropertyChangedEventArgs`1<T> args);
}
internal class JetBrains.Common.Util.DataPipes.Impl.ProxyDataProvider`1 : DataProvider`1<T> {
    private ProxySubscription`1<T> mySubscription;
    private IAsyncUpdateController`1<T> myUpdateController;
    private IAsyncController myAsyncController;
    private IDataProviderInternal`1<T> mySource;
    private IStaThreadDispatcher myDispatcher;
    private static int Deactivated;
    private static int Activated;
    private static int CleanupQueued;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) myState;
    private IDataProxy`1<IEnumerable`1<ProgressProvider>> myProgressProvider;
    private bool myClearPipelineOnEmptySource;
    private IAttributesBag myLastAttributes;
    private object myUpdateSourceLock;
    private object myMainProviderUpdateLock;
    private bool IsAsync { get; }
    protected IStaThreadDispatcher Dispatcher { get; }
    public IAsyncController Controller { get; }
    public IAttributesBag Attributes { get; }
    public IDataProviderInternal[] Sources { get; }
    protected IDataProviderInternal`1<T> SourceInternal { get; }
    unknown IDataProvider`1<T> Source {public set; }
    unknown IDataSignal JetBrains.Common.Util.DataPipes.IDataSignalProxy.Source {private set; }
    unknown IAsyncDataProvider`1<T> JetBrains.Common.Util.DataPipes.ISetAsyncProvider<T>.Source {private set; }
    public ProxyDataProvider`1(bool isStream, bool clearPipelineOnEmptySource, ISequentialTaskScheduler sequentialScheduler);
    private bool get_IsAsync();
    protected IStaThreadDispatcher get_Dispatcher();
    public virtual IAsyncController get_Controller();
    public virtual IAttributesBag get_Attributes();
    public virtual IDataProvider`1<IEnumerable`1<ProgressProvider>> GetProgressProvider();
    protected virtual IDataProvider`1<IEnumerable`1<ProgressProvider>> GetUninitializedProgressProvider();
    public virtual IDataProviderInternal[] get_Sources();
    protected void SetSource(IDataProviderInternal`1<T> provider, bool skipIfEquals);
    private bool IsProxyActivated();
    private InvalidateMode EmptyProviderInvalidateMode();
    [ThreadSafetyAttribute("4294967295", "1")]
protected void CleanupProvider();
    [ThreadSafetyAttribute("1", "1")]
private void CleanupProgressProvider();
    protected virtual void OnLastSubscriptionInvalidated();
    protected virtual void ClearValue();
    protected virtual void UpdateValue(T newValue, IAttributesBag attributes);
    protected virtual void ResurrectValue(IAttributesBag attributes);
    protected virtual void InvalidateValue(InvalidateMode mode);
    protected virtual void InitializeValueCore(IDataProviderSubscription`1<T> handler);
    protected IDataProviderInternal`1<T> get_SourceInternal();
    public sealed virtual void set_Source(IDataProvider`1<T> value);
    [ThreadSafetyAttribute("1", "1")]
protected virtual void OnActivated();
    [ThreadSafetyAttribute("1", "1")]
protected virtual void OnDeactivated();
    private sealed virtual override void JetBrains.Common.Util.DataPipes.IDataSignalProxy.set_Source(IDataSignal value);
    private sealed virtual override void JetBrains.Common.Util.DataPipes.ISetAsyncProvider<T>.set_Source(IAsyncDataProvider`1<T> value);
    protected void QueueInvalidate(InvalidateMode mode);
    protected void QueueResurrect(IAttributesBag sourceAttribute);
    [CompilerGeneratedAttribute]
private bool <.ctor>b__14_0();
}
internal class JetBrains.Common.Util.DataPipes.Impl.ProxySubscription`1 : DataMixerSubscriptionBase`1<T> {
    private object myUpdateLockObject;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) myIsRunning;
    public bool IsRunning { get; }
    public ProxySubscription`1(Action`2<T, IAttributesBag> updateAction, Action`1<IAttributesBag> attributeUpdateAction, Action`1<InvalidateMode> onInvalidate, Action`1<ICancelArgs> cancelAction, object updateLockObject);
    public bool get_IsRunning();
    protected virtual void Update(T value, IAttributesBag attributes);
    protected virtual void Resurrect(IAttributesBag attributes);
    protected virtual void Invalidate(InvalidateMode mode);
}
internal class JetBrains.Common.Util.DataPipes.Impl.ReadonlyDataNotifier`1 : ActivatableDataNotifier`1<T> {
    public object UntypedValue { get; }
    public T Value { get; }
    public ReadonlyDataNotifier`1(IDataProvider`1<T> provider);
    public sealed virtual object get_UntypedValue();
    public sealed virtual T get_Value();
    [IteratorStateMachineAttribute("JetBrains.Common.Util.DataPipes.Impl.ReadonlyDataNotifier`1/<GetNotifierProperties>d__5")]
protected virtual IEnumerable`1<string> GetNotifierProperties();
}
internal class JetBrains.Common.Util.DataPipes.Impl.RemotableAttributeWithPayload`1 : AttributeWithPayload`1<IRemotableReference`1<TA>> {
    public RemotableAttributeWithPayload`1(TA attributePayload);
    public virtual T ExtractAttribute();
}
internal class JetBrains.Common.Util.DataPipes.Impl.RemotableCoherentMarker`1 : CoherentMarker`1<IRemotableReference`1<TA>> {
    public RemotableCoherentMarker`1(TA attributePayload);
    public virtual T ExtractAttribute();
}
internal class JetBrains.Common.Util.DataPipes.Impl.ResurectController : object {
    private State myState;
    public void SourceUpdateRequested();
    public void SourceUpdateInProgress();
    public void SourceUpdateProcessed();
    public void ResetState();
    public Snapshot GetCurrentUpdateState();
}
internal static class JetBrains.Common.Util.DataPipes.Impl.StaThreadDispatcherPipeEx : object {
    [ThreadStaticAttribute]
private static IStaThreadDispatcher ourDispatcherStub;
    [NotNullAttribute]
public static IStaThreadDispatcher GetCurrentSafe();
}
internal class JetBrains.Common.Util.DataPipes.Impl.SwitchToMainThreadDataProvider`1 : DispatcherDataProviderBase`1<T> {
    private IStaThreadDispatcher myDispatcher;
    public IAsyncController Controller { get; }
    public SwitchToMainThreadDataProvider`1(IDataProviderBase`1<T> source, IStaThreadDispatcher dispatcher, Lifetime pipelineTerminationLifetime);
    public virtual IAsyncController get_Controller();
    protected virtual void OnActivated();
    protected virtual void OnDeactivated();
    protected virtual void CancelRunningTask();
    protected virtual void BeginInvoke(Action action);
}
internal class JetBrains.Common.Util.DataPipes.Impl.SwitchToMainThreadDataProviderDebug`1 : SwitchToMainThreadDataProvider`1<T> {
    private int myRunId;
    private int Id { get; }
    private string Name { get; }
    public SwitchToMainThreadDataProviderDebug`1(IDataProviderBase`1<T> source, IStaThreadDispatcher dispatcher, Lifetime pipelineTerminationLifetime);
    protected virtual void BeginInvoke(Action action);
    private void Log(string moniker);
    private void Log(string moniker, object param);
    private int get_Id();
    private string get_Name();
}
internal class JetBrains.Common.Util.DataPipes.Impl.ThreadSwitchEx`3 : object {
    private Func`1<TB> myCreateContainer;
    private Func`3<TA, TB, TC> myFillContainer;
    private IDataProviderBase`1<TA> mySource;
    private IDataProviderInternal`1<Getter`1<TC>> myGetterProvider;
    public IDataProviderInternal`1<Getter`1<TC>> GetterProvider { get; }
    public IDataProviderInternal`1<TC> ValueProvider { get; }
    public bool IsStream { get; }
    public ThreadSwitchEx`3(IDataProviderBase`1<TA> source, Func`1<TB> createContainer, Func`3<TA, TB, TC> fillContainer);
    public sealed virtual IDataProviderInternal`1<Getter`1<TC>> get_GetterProvider();
    public sealed virtual IDataProviderInternal`1<TC> get_ValueProvider();
    public sealed virtual bool get_IsStream();
    public sealed virtual IThreadSwitch`1<TC> LockFree();
    public sealed virtual IThreadSwitch`1<TC> WithTimeout(TimeSpan timeout);
    public sealed virtual IDataProvider`1<TC> ExtractProvider();
}
internal class JetBrains.Common.Util.DataPipes.Impl.ThreadSwitchProxy`1 : object {
    private IAsyncDataProxy`1<Getter`1<T>> myProxy;
    private bool myIsStream;
    private ISequentialTaskScheduler mySequentialScheduler;
    public bool IsStream { get; }
    public IDataProviderInternal`1<Getter`1<T>> GetterProvider { get; }
    public IDataProviderInternal`1<T> ValueProvider { get; }
    unknown IThreadSwitch`1<T> Source {public set; }
    public ThreadSwitchProxy`1(bool isStream, ISequentialTaskScheduler sequentialScheduler);
    public sealed virtual bool get_IsStream();
    public sealed virtual IDataProviderInternal`1<Getter`1<T>> get_GetterProvider();
    public sealed virtual IDataProviderInternal`1<T> get_ValueProvider();
    public sealed virtual void set_Source(IThreadSwitch`1<T> value);
}
internal class JetBrains.Common.Util.DataPipes.Impl.TimerDelayedDataProvider`1 : DispatcherDataProviderBase`1<T> {
    private Action myQueuedAction;
    private ITimer myTimer;
    public TimerDelayedDataProvider`1(IDataProvider`1<T> source, TimeSpan interval, Lifetime pipelineTerminationLifetime);
    private void TimerOnTick(object sender, EventArgs eventArgs);
    protected virtual void ClearValue();
    protected virtual void OnSourceUpdated(T newValue, IAttributesBag attributes);
    protected virtual void CancelRunningTask();
    protected virtual void BeginInvoke(Action action);
}
public class JetBrains.Common.Util.DataPipes.Impl.TripleBuffer`2 : object {
    private SlotData[] mySlots;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) myPointersState;
    public TContainer BackBuffer { get; }
    public TripleBuffer`2(Func`1<TContainer> createContainer);
    private static int GetBuffer(int state);
    private static int GetReady(int state);
    private static int GetOutput(int state);
    private static int GetReadyFlag(int state);
    private static int Set(int output, int ready, int buffer, int readyFlag);
    private static int SwapBufferReady(int state);
    private static int SwapReadyOutput(int state);
    public sealed virtual TContainer get_BackBuffer();
    public sealed virtual void SetReady(TValue value);
    public sealed virtual TValue GrabValue();
}
internal class JetBrains.Common.Util.DataPipes.Impl.TripleBufferRecyclingProvider`3 : DataProviderWithSingleSubscription`2<TSource, Getter`1<TValue>> {
    private Func`3<TSource, TContainer, TValue> myFillAction;
    private ITripleBuffer`2<TContainer, TValue> myBuffer;
    public TripleBufferRecyclingProvider`3(IDataProviderBase`1<TSource> sourceProvider, Func`1<TContainer> createContainer, Func`3<TSource, TContainer, TValue> fillAction);
    protected virtual void OnSourceUpdated(TSource newValue, IAttributesBag attributes);
}
internal class JetBrains.Common.Util.DataPipes.Impl.TypeAttributeKey`1 : object {
    public static TypeAttributeKey`1<T> Instance;
    private static TypeAttributeKey`1();
    public sealed virtual bool Equals(IDataAttributeKey other);
    public bool Equals(IDataAttributeKey`1<T> other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [LocalizableAttribute("False")]
public virtual string ToString();
}
internal class JetBrains.Common.Util.DataPipes.Impl.ValueThreadSwitch`1 : object {
    [CompilerGeneratedAttribute]
private IDataProviderInternal`1<T> <ValueProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsStream>k__BackingField;
    public IDataProviderInternal`1<Getter`1<T>> GetterProvider { get; }
    public IDataProviderInternal`1<T> ValueProvider { get; }
    public bool IsStream { get; }
    public ValueThreadSwitch`1(IDataProviderInternal`1<T> valueProvider, bool isStream);
    public sealed virtual IDataProviderInternal`1<Getter`1<T>> get_GetterProvider();
    [CompilerGeneratedAttribute]
public sealed virtual IDataProviderInternal`1<T> get_ValueProvider();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsStream();
}
internal class JetBrains.Common.Util.DataPipes.Impl.ValueWithConsistencyStateProvider`1 : DataProviderWithSource`2<TSource, ValueWithConsistencyState`1<TSource>> {
    private bool myWasInitialized;
    public bool NeedInvalidateOnActivation { get; }
    public ValueWithConsistencyStateProvider`1(IDataProviderBase`1<TSource> source);
    protected virtual void ClearValue();
    public virtual bool get_NeedInvalidateOnActivation();
    protected virtual void OnSourceUpdated(TSource newValue, IAttributesBag attributes);
    protected virtual void OnSourceResurrect(IAttributesBag attributes);
    protected virtual void OnSourceInvalidate(InvalidateMode mode);
}
[ExtensionAttribute]
internal static class JetBrains.Common.Util.DataPipes.Impl.WeakDelegateEx : object {
    [ExtensionAttribute]
public static ValueUpdatedHandler`1<TArg> CreateWeakHandler(T source, TArg _, Action`2<T, TArg> handler);
}
public class JetBrains.Common.Util.DataPipes.Impl.WpfTimer : object {
    private static Dispatcher ourDispatcher;
    private DispatcherTimer myTimer;
    public int Interval { get; public set; }
    public bool Enabled { get; public set; }
    private static WpfTimer();
    public sealed virtual void Dispose();
    public sealed virtual int get_Interval();
    public sealed virtual void set_Interval(int value);
    public sealed virtual void add_Tick(EventHandler value);
    public sealed virtual void remove_Tick(EventHandler value);
    public sealed virtual bool get_Enabled();
    public sealed virtual void set_Enabled(bool value);
    public sealed virtual void Start();
    public sealed virtual void Stop();
}
[DefaultMemberAttribute("Item")]
internal class JetBrains.Common.Util.DataPipes.Impl.WritableDataNotifier`1 : ActivatableDataNotifier`1<T> {
    [NotNullAttribute]
private Action`1<T> mySetValueCallback;
    private bool myValidateSetValue;
    [CompilerGeneratedAttribute]
private EventHandler`1<DataErrorsChangedEventArgs> ErrorsChanged;
    [CompilerGeneratedAttribute]
private string <Error>k__BackingField;
    public object UntypedValue { get; }
    public T Value { get; public set; }
    public string Item { get; }
    public string Error { get; private set; }
    public bool HasErrors { get; }
    public WritableDataNotifier`1(IDataProvider`1<T> provider, Action`1<T> setValueCallback, IDataProvider`1<string> error, bool validateSetValue);
    [IteratorStateMachineAttribute("JetBrains.Common.Util.DataPipes.Impl.WritableDataNotifier`1/<GetNotifierProperties>d__3")]
protected virtual IEnumerable`1<string> GetNotifierProperties();
    protected virtual void OnCleanup();
    private void OnErrorUpdated(string error);
    public sealed virtual object get_UntypedValue();
    public sealed virtual T get_Value();
    public sealed virtual void set_Value(T value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_ErrorsChanged(EventHandler`1<DataErrorsChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_ErrorsChanged(EventHandler`1<DataErrorsChangedEventArgs> value);
    public sealed virtual string get_Item(string columnName);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Error();
    [CompilerGeneratedAttribute]
private void set_Error(string value);
    public sealed virtual bool get_HasErrors();
    public sealed virtual IEnumerable GetErrors(string propertyName);
    private void OnErrorsChanged();
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.DataPipes.InternalEx : object {
    [ExtensionAttribute]
internal static bool AreRunningOnTheSameThread(IDataProviderInternal`1<T1> t1, IDataProviderInternal`1<T2> t2);
    [ExtensionAttribute]
internal static IAsyncController GetRootController(IDataProviderInternal`1<T> provider);
    [ExtensionAttribute]
internal static ProgressDataProvider`1<T> AttachProgress(IAsyncDataProvider`1<T> provider, string title);
    [ExtensionAttribute]
[NotNullAttribute]
internal static IAsyncController GetAsyncController(IAsyncDataProvider`1<T> provider);
    [ExtensionAttribute]
[CanBeNullAttribute]
internal static IExecutionController TryGetExecutionController(IDataProviderInternal`1<T> provider);
    internal static IProgressDataProvider GetLastProgressDataProvider(IDataProviderInternal p);
    [ExtensionAttribute]
internal static ValueUpdatedHandler`1<T> AddCondition(ValueUpdatedHandler`1<T> handler, Func`2<T, bool> condition);
    [ExtensionAttribute]
internal static void Activate(IDataSubscription subscription, Lifetime lifetime);
    [ExtensionAttribute]
internal static void Activate(IDataSubscription subscription, IDataProvider`1<bool> isActive);
    [ExtensionAttribute]
internal static void Activate(IDataSubscription subscription);
    [ExtensionAttribute]
internal static IDataSubscription CreateSubscription(IDataProviderBase`1<T> source, LifetimedValueUpdatedHandler`1<T> handler, Func`2<T, bool> condition);
    [ExtensionAttribute]
internal static IDataSubscription CreateSubscription(IDataProviderBase`1<T> source, Lifetime lifetime, LifetimedValueUpdatedHandler`1<T> handler, Func`2<T, bool> condition);
    [ExtensionAttribute]
[CanBeNullAttribute]
internal static IDataSubscription CreateSubscription(IDataProviderBase`1<T> source, ValueUpdatedHandler`1<T> handler, bool ignoreCleanup);
    [ExtensionAttribute]
[CanBeNullAttribute]
internal static IDataSubscription CreateSubscriptionWithConsistencyState(IDataProviderBase`1<T> source, ValueUpdatedHandler`1<ValueWithConsistencyState`1<T>> handler);
    [ExtensionAttribute]
internal static IDataProvider`1<T> CastToSync(IAsyncDataProvider`1<T> provider);
    [ExtensionAttribute]
internal static IDataSignal CastToSync(IAsyncDataSignal provider);
    [ExtensionAttribute]
[ContractAnnotationAttribute("dataProvider:null => false")]
internal static bool IsAsync(IDataProviderInternal dataProvider);
    [ExtensionAttribute]
[ContractAnnotationAttribute("controller:null => false")]
internal static bool IsAsync(IAsyncController controller);
    [ExtensionAttribute]
public static IAsyncDataSignal CastToAsync(IDataSignal provider);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<T> CastToAsync(IDataProvider`1<T> provider);
    [ExtensionAttribute]
internal static IDataProvider`1<Initializable`1<T>> ForceUpdatesWhenNotInitialized(IDataProvider`1<T> provider);
}
public class JetBrains.Common.Util.DataPipes.Interpolator`1 : MulticastDelegate {
    public Interpolator`1(object object, IntPtr method);
    public virtual T Invoke(T start, T end, double percent);
    public virtual IAsyncResult BeginInvoke(T start, T end, double percent, AsyncCallback callback, object object);
    public virtual T EndInvoke(IAsyncResult result);
}
public interface JetBrains.Common.Util.DataPipes.ISetAsyncProvider`1 {
    unknown IAsyncDataProvider`1<T> Source {public set; }
    public abstract virtual void set_Source(IAsyncDataProvider`1<T> value);
}
public interface JetBrains.Common.Util.DataPipes.ISetProvider`1 {
    unknown IDataProvider`1<T> Source {public set; }
    public abstract virtual void set_Source(IDataProvider`1<T> value);
}
public interface JetBrains.Common.Util.DataPipes.ISetThreadSwitch`1 {
    unknown IThreadSwitch`1<T> Source {public set; }
    public abstract virtual void set_Source(IThreadSwitch`1<T> value);
}
public interface JetBrains.Common.Util.DataPipes.IThreadSwitch`1 {
    public bool IsStream { get; }
    public abstract virtual bool get_IsStream();
}
public interface JetBrains.Common.Util.DataPipes.IThreadSwitchEx`1 {
    public abstract virtual IThreadSwitch`1<T> LockFree();
    public abstract virtual IThreadSwitch`1<T> WithTimeout(TimeSpan timeout);
    public abstract virtual IDataProvider`1<T> ExtractProvider();
}
public interface JetBrains.Common.Util.DataPipes.IThreadSwitchProxy`1 {
}
public interface JetBrains.Common.Util.DataPipes.ITransformController`1 {
    public T LastSuccessfulValue { get; }
    public bool WasInvalidated { get; }
    public bool WasInitialized { get; }
    public abstract virtual T get_LastSuccessfulValue();
    public abstract virtual bool get_WasInvalidated();
    public abstract virtual bool get_WasInitialized();
    public abstract virtual void RaiseResurrect();
    public abstract virtual void RaiseChanged(T value);
    public abstract virtual void RaiseInvalidate(InvalidateMode mode);
}
public interface JetBrains.Common.Util.DataPipes.IUntypedDataNotifier {
    public object UntypedValue { get; }
    public abstract virtual object get_UntypedValue();
}
public interface JetBrains.Common.Util.DataPipes.IWriteableDataNotifier`1 {
    public T Value { get; public set; }
    public abstract virtual T get_Value();
    public abstract virtual void set_Value(T value);
}
public class JetBrains.Common.Util.DataPipes.LifetimedValueUpdatedHandler`1 : MulticastDelegate {
    public LifetimedValueUpdatedHandler`1(object object, IntPtr method);
    public virtual void Invoke(Lifetime lifetime, T newValue);
    public virtual IAsyncResult BeginInvoke(Lifetime lifetime, T newValue, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.DataPipes.MiscEx : object {
    private static int ourLoggedProviderId;
    [ExtensionAttribute]
public static Maybe`1<T> PeekValue(IDataProvider`1<T> provider);
    [ExtensionAttribute]
public static T PeekValueOrDefault(IDataProvider`1<T> provider);
    [ExtensionAttribute]
private static Maybe`1<T> PeekValue(IDataProviderInternal`1<T> provider);
    [ExtensionAttribute]
public static IDataProvider`1<T> LogUpdates(IDataProvider`1<T> provider, string prefix, Func`2<T, bool> logCallStack);
    [ExtensionAttribute]
public static IDataProvider`1<T> LogUpdates(IDataProvider`1<T> provider, ILogger logger, LoggingLevel loggingLevel, string prefix, Func`2<T, bool> logCallStack);
    [ExtensionAttribute]
public static IDataProvider`1<T> Evaluate(IDataProvider`1<Getter`1<T>> provider);
    [ExtensionAttribute]
public static IDataProvider`1<TVoid> Execute(IDataProvider`1<Action> provider, Lifetime lifetime);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<TVoid> Execute(IAsyncDataProvider`1<Action`1<IExecutionController>> provider);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<T> Execute(IAsyncDataProvider`1<Func`2<IExecutionController, T>> provider);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<T> Evaluate(IAsyncDataProvider`1<GetterAsync`1<T>> provider);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<T> Evaluate(IAsyncDataProvider`1<Getter`1<T>> provider);
    [ExtensionAttribute]
public static DataPipe`2<TA, TB> MakePipe(IDataProxy`1<TA> input, Func`2<IDataProvider`1<TA>, IDataProvider`1<TB>> buildPipe);
    [ExtensionAttribute]
internal static IThreadSwitchInternal`1<T> ToInternal(IThreadSwitch`1<T> sw);
    [ExtensionAttribute]
public static IDataProviderBase`1<T> ExtractProvider(IThreadSwitch`1<T> provider);
    [ExtensionAttribute]
internal static IDataProvider`1<Getter`1<T>> GetGetter(IThreadSwitchInternal`1<T> sw);
    [ExtensionAttribute]
public static Getter`1<T> ToGetter(IDataSink`1<Getter`1<T>> sink);
    [ExtensionAttribute]
public static void TickWhile(DispatcherTimer timer, IDataProvider`1<bool> isActive, Action handler);
    [ExtensionAttribute]
public static IDataProvider`1<IEnumerable`1<T>> ToEnumerableWithSingleItem(IDataProvider`1<T> provider, bool reuseCollection);
    [ExtensionAttribute]
public static IDataProvider`1<T> ControlActivation(IDataProvider`1<T> provider, IDataProvider`1<bool> activationController);
    [ExtensionAttribute]
public static IThreadSwitch`1<T> TrackBeforeGetValue(IThreadSwitch`1<T> source, Action handler);
    [ExtensionAttribute]
public static IDataProvider`1<T> TrackBeforeUpdate(IDataProvider`1<T> source, ValueUpdatedHandler`1<T> beforeUpdate);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<T> TrackBeforeUpdate(IAsyncDataProvider`1<T> source, ValueUpdatedHandler`1<T> beforeUpdate);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<T> TrackAfterUpdate(IAsyncDataProvider`1<T> source, ValueUpdatedHandler`1<T> beforeUpdate);
    [ExtensionAttribute]
public static IDataProvider`1<T> TrackAfterUpdate(IDataProvider`1<T> source, ValueUpdatedHandler`1<T> afterUpdate);
    [ExtensionAttribute]
public static IDataProvider`1<TC> CreateCycle(IDataProvider`1<TA> mainInput, IDataProvider`1<TB> cycledInput, Func`3<TA, TB, TC> converter, IEqualityComparer`1<TC> comparer);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<T> TrackBeforeChange(IAsyncDataProvider`1<T> source, ValueUpdatedHandler`1<ControlledTransformArgument`1<T>> beforeUpdate);
    [ExtensionAttribute]
public static IDataProvider`1<T> TrackBeforeChange(IDataProvider`1<T> source, ValueUpdatedHandler`1<ControlledTransformArgument`1<T>> beforeUpdate);
    [ExtensionAttribute]
public static IThreadSwitch`1<T> TrackDeactivation(IThreadSwitch`1<T> source, Action onDeactivated);
    [ExtensionAttribute]
public static IThreadSwitch`1<T> TrackActivation(IThreadSwitch`1<T> source, ValueUpdatedHandler`1<bool> isActiveHandler);
    [ExtensionAttribute]
public static IThreadSwitch`1<T> TrackActivation(IThreadSwitch`1<T> source, ISetProvider`1<bool> setIsActive);
    [ExtensionAttribute]
public static IThreadSwitch`1<T> TrackBeforeUpdate(IThreadSwitch`1<T> source, Action onUpdated);
    [ExtensionAttribute]
public static IThreadSwitch`1<T> TrackBeforeChange(IThreadSwitch`1<T> source, Action`1<ControlledTransformArgumentType> onUpdated);
    [ExtensionAttribute]
public static IThreadSwitch`1<T> TrackActivation(IThreadSwitch`1<T> source, IDataProvider`1& isActive);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<T> TrackActivation(IAsyncDataProvider`1<T> source, ValueUpdatedHandler`1<bool> isActiveHandler);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<T> TrackActivation(IAsyncDataProvider`1<T> source, ISetProvider`1<bool> setIsActive);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<T> TrackActivation(IAsyncDataProvider`1<T> source, IDataProvider`1& isActive);
    [ExtensionAttribute]
public static IDataProvider`1<T> DeactivateSince(IDataProvider`1<T> source, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static IDataProvider`1<T> TrackDeactivation(IDataProvider`1<T> source, Action onDeactivated);
    [ExtensionAttribute]
private static void SubscribeForeverSkipFirstCall(IDataProvider`1<T> source, ValueUpdatedHandler`1<T> handler);
    [ExtensionAttribute]
public static IDataProvider`1<T> DebugPipeState(IDataProvider`1<T> provider, TimeSpan delay, Action`1<IDataProvider`1<T>> handler, Func`2<PipeState`1<T>, bool> check);
    private static void ResetTimer(DispatcherTimer timer, EventHandler eventHandler);
    private static void InitTimer(DispatcherTimer timer, EventHandler eventHandler);
    [ExtensionAttribute]
public static IDataProvider`1<T> DebugPipeState(IDataProvider`1<T> provider, Action`1<IDataProvider`1<T>> handler, Func`2<PipeState`1<T>, bool> check);
    [ExtensionAttribute]
public static IDataProvider`1<T> DebugNoValue(IDataProvider`1<T> provider, TimeSpan delay, Action`1<IDataProvider`1<T>> handler);
    [ExtensionAttribute]
public static IDataProvider`1<T> DebugNoValue(IDataProvider`1<T> provider, Action`1<IDataProvider`1<T>> handler);
    [ExtensionAttribute]
public static IDataProvider`1<T> TrackActivation(IDataProvider`1<T> source, ValueUpdatedHandler`1<bool> isActiveHandler);
    [ExtensionAttribute]
public static IDataProvider`1<T> TrackActivation(IDataProvider`1<T> source, ISetProvider`1<bool> setIsActive);
    [ExtensionAttribute]
public static IDataProvider`1<PipeEventData`1<T>> TrackActivation(IDataEvent`1<T> source, ValueUpdatedHandler`1<bool> isActiveHandler);
    [ExtensionAttribute]
public static IDataProvider`1<PipeEventData`1<T>> TrackActivation(IDataEvent`1<T> source, IDataProvider`1& isActive);
    [ExtensionAttribute]
public static IDataProvider`1<T> TrackActivation(IDataProvider`1<T> source, IDataProvider`1& isActive);
    [ExtensionAttribute]
public static IDataProvider`1<T> EvaluateWithInvalidationTracking(IDataProvider`1<Getter`1<T>> source, Lifetime lifetime);
    [ExtensionAttribute]
public static IDataProvider`1<T> EvaluateAtThreadPoolWithInvalidationTracking(IDataProvider`1<GetterAsync`1<T>> source, DataPipeLifetime lifetime);
    [ExtensionAttribute]
public static IDataProvider`1<T> TrackInvalidationDuringDeactivation(IDataProvider`1<T> source, IDataSignal invalidate, Lifetime lifetime);
    [ExtensionAttribute]
public static IRemotableReference`1<T> CreateRemotableReference(T src);
    [ExtensionAttribute]
[NotNullAttribute]
public static IRemotableReference`1<T> BuildLocalOrRemote(IRemoteCommunicator comm, Func`1<T> create);
    [ExtensionAttribute]
[NotNullAttribute]
public static IRemotableReference`1<TB> BuildLocalOrRemote(IRemoteCommunicator comm, Func`2<TA, TB> create, TA arg);
    [ExtensionAttribute]
[NotNullAttribute]
public static IRemotableReference`1<T> CreateRemoteOrLocal(IRemoteCommunicator comm, T value);
    [ExtensionAttribute]
public static void SetValue(IDataController`1<Union`2<TA, TB>> controller, TA value);
    [ExtensionAttribute]
public static void SetValue(IDataController`1<Union`2<TA, TB>> controller, TB value);
    [ExtensionAttribute]
public static IDataProvider`1<T> Cast(IDataProvider`1<object> provider);
    [ExtensionAttribute]
public static IDataProvider`1<T> SafeCast(IDataProvider`1<object> provider);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<T> EnsureSingleThreaded(IAsyncDataProvider`1<T> p);
    [ExtensionAttribute]
public static IDataProvider`1<ValueWithConsistencyState`1<T>> WithConsistencyState(IDataProvider`1<T> provider);
    [ExtensionAttribute]
public static IDataProviderBase`1<ValueWithConsistencyState`1<T>> WithConsistencyState(IDataProviderBase`1<T> provider);
    [ExtensionAttribute]
private static IDataProviderInternal`1<ValueWithAttribute`2<T, TA>> ExtractAttributeAndValueBase(IDataProviderInternal`1<T> provider, IDataAttributeKey attributeKey);
    [ExtensionAttribute]
private static IDataProviderInternal`1<ValueWithAttribute`2<T, TA>> TryExtractAttributeAndValueBase(IDataProviderInternal`1<T> provider, IDataAttributeKey attributeKey);
    [ExtensionAttribute]
public static IDataProvider`1<ValueWithAttribute`2<T, TA>> ExtractAttributeAndValue(IDataProvider`1<T> provider, IDataAttributeKey`1<TA> attributeKey);
    [ExtensionAttribute]
public static IDataProvider`1<ValueWithAttribute`2<T, TA>> TryExtractAttributeAndValue(IDataProvider`1<T> provider, IDataAttributeKey`1<TA> attributeKey);
    [ExtensionAttribute]
public static IDataProvider`1<ValueWithAttribute`2<T, TA>> ExtractAttributeAndValue(IDataProvider`1<T> provider, IDataAttributeKey attributeKey);
    [ExtensionAttribute]
public static IDataProvider`1<ValueWithAttribute`2<T, TA>> TryExtractAttributeAndValue(IDataProvider`1<T> provider, IDataAttributeKey attributeKey);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<ValueWithAttribute`2<T, TA>> ExtractAttributeAndValue(IAsyncDataProvider`1<T> provider, IDataAttributeKey`1<TA> attributeKey);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<ValueWithAttribute`2<T, TA>> TryExtractAttributeAndValue(IAsyncDataProvider`1<T> provider, IDataAttributeKey`1<TA> attributeKey);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<TA> ExtractAttribute(IAsyncDataProvider`1<T> provider, IDataAttributeKey`1<TA> attributeKey);
    [ExtensionAttribute]
public static IDataProvider`1<TA> ExtractAttribute(IDataProvider`1<T> provider, IDataAttributeKey`1<TA> attributeKey);
    [ExtensionAttribute]
public static IDataProvider`1<TA> TryExtractAttribute(IDataProvider`1<T> provider, IDataAttributeKey`1<TA> attributeKey);
    [ExtensionAttribute]
public static IDataProvider`1<TA> ExtractAttribute(IDataProvider`1<T> provider, IDataAttributeKey attributeKey);
    [ExtensionAttribute]
public static IDataProvider`1<TA> TryExtractAttribute(IDataProvider`1<T> provider, IDataAttributeKey attributeKey);
    [ExtensionAttribute]
private static IDataProviderInternal`1<T> AttachAttributeBase(IDataProviderInternal`1<T> provider, Func`2<T, TA> getAttributeValue, IDataAttributeKey attributeKey);
    [ExtensionAttribute]
public static IDataProvider`1<T> AttachAttributeByAttributeType(IDataProvider`1<T> provider, Func`2<T, TA> getAttributeValue, IDataAttributeKey attributeKey);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<T> AttachAttributeByAttributeType(IAsyncDataProvider`1<T> provider, Func`2<T, TA> getAttributeValue, IDataAttributeKey attributeKey);
    private static bool IsSerializable();
    [ExtensionAttribute]
private static IDataProviderInternal`1<T> AddCoherentMarkerByKeyBase(IDataProviderInternal`1<T> provider, IDataAttributeKey markerKey, Func`2<T, TA> getMarker);
    [ExtensionAttribute]
public static IDataProvider`1<T> AddCoherentMarkerByKey(IDataProvider`1<T> provider, IDataAttributeKey markerKey, Func`2<T, TA> getMarker);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<T> AddCoherentMarkerByKey(IAsyncDataProvider`1<T> provider, IDataAttributeKey markerKey, Func`2<T, TA> getMarker);
    [ExtensionAttribute]
public static IDataProvider`1<T> AddCoherentMarker(IDataProvider`1<T> provider);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<T> AddCoherentMarker(IAsyncDataProvider`1<T> provider);
    [ExtensionAttribute]
public static IDataProvider`1<T> AddCoherentMarker(IDataProvider`1<T> provider, Func`2<T, TA> getMarker);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<T> AddCoherentMarker(IAsyncDataProvider`1<T> provider, Func`2<T, TA> getMarker);
    [ExtensionAttribute]
public static IDataProvider`1<T> AddCoherentMarkerByValueType(IDataProvider`1<T> provider);
    [ExtensionAttribute]
public static IDataProvider`1<T> AddCoherentMarkerByValueType(IDataProvider`1<T> provider, Func`2<T, TA> getMarker);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<T> AddCoherentMarkerByValueType(IAsyncDataProvider`1<T> provider);
    [ExtensionAttribute]
public static IDataProvider`1<T> AddCoherentMarkerByMarkerType(IDataProvider`1<T> provider, Func`2<T, TA> getMarker);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<T> AddCoherentMarkerByMarkerType(IAsyncDataProvider`1<T> provider, Func`2<T, TA> getMarker);
    [ExtensionAttribute]
public static IDataProvider`1<T> AddCoherentMarkerByKey(IDataProvider`1<T> provider, IDataAttributeKey markerKey);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<T> AddCoherentMarkerByKey(IAsyncDataProvider`1<T> provider, IDataAttributeKey markerKey);
    [ExtensionAttribute]
private static IDataProviderInternal`1<T> RemoveAttributeCore(IDataProviderInternal`1<T> provider, IDataAttributeKey markerKey);
    [ExtensionAttribute]
public static IDataProvider`1<T> RemoveAttribute(IDataProvider`1<T> provider, IDataAttributeKey markerKey);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<T> RemoveAttribute(IAsyncDataProvider`1<T> provider, IDataAttributeKey markerKey);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.DataPipes.NullableEx : object {
    [ExtensionAttribute]
public static IDataProvider`1<T> NullToDefault(IDataProvider`1<Nullable`1<T>> provider);
    [ExtensionAttribute]
public static IDataProvider`1<bool> IsNull(IDataProvider`1<T> filter);
    [ExtensionAttribute]
public static IDataProvider`1<bool> IsNotNull(IDataProvider`1<T> src);
    [ExtensionAttribute]
public static IDataProvider`1<bool> IsNotNull(IDataProvider`1<Nullable`1<T>> src);
    [ExtensionAttribute]
public static IDataProvider`1<bool> IsNull(IDataProvider`1<Nullable`1<T>> src);
    [ExtensionAttribute]
public static IDataProvider`1<IEnumerable`1<TA>> WhereNotNull(IDataProvider`1<IEnumerable`1<TA>> provider);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<IEnumerable`1<TA>> WhereNotNull(IAsyncDataProvider`1<IEnumerable`1<TA>> provider);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<IEnumerable`1<TA>> WhereNotNull(IAsyncDataProvider`1<IEnumerable`1<Nullable`1<TA>>> provider);
    [ExtensionAttribute]
public static IDataProvider`1<IEnumerable`1<TA>> WhereNotNull(IDataProvider`1<IEnumerable`1<Nullable`1<TA>>> provider);
}
public static class JetBrains.Common.Util.DataPipes.NullDataNotifier`1 : object {
    public static IDataNotifier`1<T> Instance;
    private static NullDataNotifier`1();
}
public class JetBrains.Common.Util.DataPipes.PipeEventData`1 : ValueType {
    internal bool HasData;
    internal T Data;
    internal PipeEventData`1(T data);
}
internal enum JetBrains.Common.Util.DataPipes.PipeLifeState : Enum {
    public int value__;
    public static PipeLifeState Alive;
    public static PipeLifeState BeginTermination;
    public static PipeLifeState EndTermination;
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.DataPipes.PriorityTaskSchedulerSwitchEx : object {
    [ExtensionAttribute]
public static IAsyncDataProvider`1<T> ToPriorityScheduler(IThreadSwitch`1<T> provider, IPriorityTaskGroup priorityGroup);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.DataPipes.ProgressEx : object {
    [ExtensionAttribute]
public static IDataProvider`1<ProgressProvider[]> GetProgressesProvider(IEnumerable`1<IDataSignal> signals);
    [ExtensionAttribute]
private static IDataPipeNode Combine(IEnumerable`1<IDataSignal> signals);
    [ExtensionAttribute]
public static IDataProvider`1<ProgressProvider[]> GetProgressesProvider(IDataPipeNode provider);
    [ExtensionAttribute]
public static ProgressProvider GetLastProgress(IAsyncDataProvider`1<T> source);
    [ExtensionAttribute]
public static IDataProvider`1<bool> GetIsCompleted(IDataProvider`1<AsyncComputationState> state);
}
public abstract class JetBrains.Common.Util.DataPipes.ProxyContainer`1 : object {
    private IDataProxy`1<T> myProxy;
    public IDataProvider`1<T> Data { get; }
    unknown IDataProvider`1<T> Source {public set; }
    protected ProxyContainer`1(IDataProvider`1<T> source);
    public sealed virtual IDataProvider`1<T> get_Data();
    public sealed virtual void set_Source(IDataProvider`1<T> value);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.DataPipes.PublishEx : object {
    [ExtensionAttribute]
public static IDataNotifier`1<T> AsDataNotifier(T o);
    [ExtensionAttribute]
public static IWriteableDataNotifier`1<T> ToWriteableNotifier(IProperty`1<T> property);
    [ExtensionAttribute]
public static ICollectionNotifier`1<T> PublishCollection(IDataProvider`1<IEnumerable`1<T>> source, Lifetime lifetime, CollectionNotificationMode mode);
    [ExtensionAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null; notnull => notnull")]
public static IDataNotifier`1<T> Publish(IDataProvider`1<T> source);
    [ExtensionAttribute]
public static IWriteableDataNotifier`1<T> PublishWriteable(IDataProvider`1<T> source, Action`1<T> setValue, IDataProvider`1<string> error, bool validateSetValue);
    [ExtensionAttribute]
public static IWriteableDataNotifier`1<T> PublishWriteable(IDataProvider`1<T> source, Action`1<T> setValue, bool validateSetValue);
    [ExtensionAttribute]
public static IWriteableDataNotifier`1<T> PublishWriteable(IDataController`1<T> source, IDataProvider`1<string> error);
    [ExtensionAttribute]
public static IWriteableDataNotifier`1<T> PublishWriteable(IDataControllerContainer`1<T> source, IDataProvider`1<string> error);
    [ExtensionAttribute]
public static IWriteableDataNotifier`1<T> PublishWriteableWithUiState(IDataProvider`1<T> source, Action`1<T> setValue, IDataController`1<T> uiState, bool validateSetValue);
    [ExtensionAttribute]
private static IWriteableDataNotifier`1<T> InjectUiState(IWriteableDataNotifier`1<T> source, IDataProvider`1<T> sourceProvider, IDataController`1<T> uiState, IDataProvider`1<bool> isActive);
    [ExtensionAttribute]
public static IWriteableDataNotifier`1<bool> PublishWriteableContains(IObservableSet`1<T> set, IDataProvider`1<IReadOnlyCollection`1<T>> provider, T key);
    [ExtensionAttribute]
public static IWriteableDataNotifier`1<bool> PublishWriteableContains(IObservableSet`1<T> set, T key);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.DataPipes.RequestProcessorEx : object {
    [ExtensionAttribute]
public static IDataRequestProcessor`1<T> ToRequestProcessor(IDataProviderBase`1<T> source, Lifetime lifetime);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.DataPipes.SelectEx : object {
    [ExtensionAttribute]
private static IDataProvider`1<TB> SelectCore(IDataProvider`1<TA> keyProvider, Func`2<TA, IDataProvider`1<TB>> selector, bool clearPipelineOnEmptySource);
    [ExtensionAttribute]
[NotNullAttribute]
public static IDataProvider`1<TB> Select(IDataProvider`1<TA> keyProvider, Func`2<TA, IDataProvider`1<TB>> selector, bool clearPipelineOnEmptySource);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<TB> SelectSafe(IDataProvider`1<TA> keyProvider, DataPipeLifetime lifetime, Func`2<TA, IAsyncDataProvider`1<TB>> selector);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<TB> Select(IDataProvider`1<TA> keyProvider, DataPipeLifetime lifetime, Func`2<TA, IAsyncDataProvider`1<TB>> selector);
    [ExtensionAttribute]
[NotNullAttribute]
public static IRemotableReference`1<IDataProvider`1<TB>> Select(IRemotableReference`1<IDataProvider`1<TA>> keyProvider, Func`2<TA, IDataProvider`1<TB>> selector);
    [ExtensionAttribute]
public static IThreadSwitch`1<T> Flatten(IDataProvider`1<IThreadSwitch`1<T>> source);
    [ExtensionAttribute]
public static IThreadSwitch`1<TB> Select(IDataProvider`1<bool> keyProvider, IThreadSwitch`1<TB> trueCase, IThreadSwitch`1<TB> falseCase);
    [ExtensionAttribute]
public static IThreadSwitch`1<TB> SelectSafe(IDataProvider`1<TA> source, Func`2<TA, IThreadSwitch`1<TB>> selector);
    [ExtensionAttribute]
public static IThreadSwitch`1<TB> Select(IDataProvider`1<TA> source, Func`2<TA, IThreadSwitch`1<TB>> selector);
    [ExtensionAttribute]
public static IDataProvider`1<TB> SelectSafe(IDataProvider`1<TA> keyProvider, Func`2<TA, IDataProvider`1<TB>> selector);
    [ExtensionAttribute]
public static IRemotableReference`1<IDataProvider`1<TB>> SelectSafe(IRemotableReference`1<IDataProvider`1<TA>> keyProvider, Func`2<TA, IDataProvider`1<TB>> selector);
    [ExtensionAttribute]
public static IDataProvider`1<TB> SelectSafe(IDataProvider`1<Nullable`1<TA>> keyProvider, Func`2<TA, IDataProvider`1<TB>> selector);
    [ExtensionAttribute]
public static IDataProvider`1<TB> SelectSafe(IDataProvider`1<TA> keyProvider, Func`2<TA, IDataProvider`1<TB>> selector, TB fallbackValue);
    [ExtensionAttribute]
public static IDataProvider`1<TB> SelectSafe(IDataProvider`1<TA> keyProvider, Func`2<TA, IDataProvider`1<TB>> selector, IDataProvider`1<TB> fallbackProvider);
    [ExtensionAttribute]
public static IDataProvider`1<TB> SelectSafe(IDataProvider`1<Nullable`1<TA>> keyProvider, Func`2<TA, IDataProvider`1<TB>> selector, IDataProvider`1<TB> fallbackProvider);
    [ExtensionAttribute]
[NotNullAttribute]
public static IDataProvider`1<T> Select(IDataProvider`1<bool> switchKey, IDataProvider`1<T> trueCase, IDataProvider`1<T> falseCase);
    [ExtensionAttribute]
[NotNullAttribute]
public static IDataProvider`1<T> Select(IDataProvider`1<bool> switchKey, IDataProvider`1<T> trueCase);
    [ExtensionAttribute]
[NotNullAttribute]
public static IAsyncDataProvider`1<T> Select(IDataProvider`1<bool> switchKey, DataPipeLifetime lifetime, IAsyncDataProvider`1<T> trueCase, IAsyncDataProvider`1<T> falseCase);
    [ExtensionAttribute]
public static IDataProvider`1<T> SelectValue(IDataProvider`1<bool> switchKey, T trueCase, T falseCase);
    [ExtensionAttribute]
[NotNullAttribute]
private static IDataProvider`1<T> FlattenCore(IDataProvider`1<IDataProvider`1<T>> source, bool clearPipelineOnEmptySource);
    [ExtensionAttribute]
[NotNullAttribute]
private static IAsyncDataProvider`1<T> FlattenCore(IDataProvider`1<IAsyncDataProvider`1<T>> source, bool clearPipelineOnEmptySource, ISequentialTaskScheduler sequentialScheduler);
    [ExtensionAttribute]
[NotNullAttribute]
public static IDataProvider`1<T> Flatten(IDataProvider`1<IDataProvider`1<T>> source, bool clearPipelineOnEmptySource);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<T> Flatten(IDataProvider`1<IAsyncDataProvider`1<T>> source, DataPipeLifetime lifetime, bool clearPipelineOnEmptySource);
    [ExtensionAttribute]
[NotNullAttribute]
public static IRemotableReference`1<IDataProvider`1<T>> Flatten(IRemotableReference`1<IDataProvider`1<IDataProvider`1<T>>> source);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.DataPipes.SettingsStoreEx : object {
    [ExtensionAttribute]
public static IDataController`1<TEntryMemberType> GetValueController(IContextBoundSettingsStore settingsStore, Lifetime lifetime, Expression`1<Func`2<TKeyClass, TEntryMemberType>> lambda);
    [ExtensionAttribute]
public static IDataController`1<TEntryMemberType> GetValueController(IContextBoundSettingsStoreLive settingsStore, Lifetime lifetime, Expression`1<Func`2<TKeyClass, TEntryMemberType>> lambda);
    [ExtensionAttribute]
public static IDataProvider`1<TEntryMemberType> GetValueProvider(IContextBoundSettingsStoreLive settingsStore, Lifetime lifetime, Expression`1<Func`2<TKeyClass, TEntryMemberType>> lambda);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.DataPipes.ShellEx : object {
    [ExtensionAttribute]
public static IDataProvider`1<bool> ToIsAliveProvider(Lifetime lifetime);
    [ExtensionAttribute]
public static IDataProvider`1<T> InjectLifetime(IDataProvider`1<T> src, DataPipeLifetime lifetime);
    [ExtensionAttribute]
public static IDataProvider`1<T> InjectLifetime(IDataProvider`1<T> src, Lifetime lifetime);
    [ExtensionAttribute]
public static Lifetime ToLifetime(IDataProvider`1<bool> src);
    [ExtensionAttribute]
public static IDataProvider`1<T> Guarded(IDataProvider`1<T> src, IThreading threading, string name);
    [ExtensionAttribute]
public static IDataProvider`1<T> Guarded(IDataProvider`1<T> src, ReentrancyGuard guard, string name);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.DataPipes.SinkEx : object {
    [ExtensionAttribute]
public static IDataSink`1<T> ToSink(IDataProviderBase`1<T> source, IDataProvider`1<bool> isListening);
    [ExtensionAttribute]
public static IDataSink`1<T> ToSinkForever(IDataProviderBase`1<T> source);
    [ExtensionAttribute]
public static IDataSink`1<T> ToSink(IDataProviderBase`1<T> source, Lifetime lifetime);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.DataPipes.SubscribeEx : object {
    [ExtensionAttribute]
public static void SubscribeSafe(IDataProviderBase`1<T> provider, Lifetime lifetime, ValueUpdatedHandler`1<T> handler);
    [ExtensionAttribute]
public static void SubscribeSafe(IDataProviderBase`1<Pair`2<TA, TB>> provider, Lifetime lifetime, Action`2<TA, TB> handler);
    [ExtensionAttribute]
public static void SubscribeSafe(IDataProviderBase`1<Pair`2<TA, TB>> provider, Lifetime lifetime, Func`3<TA, TB, bool> isSafe, Action`2<TA, TB> handler);
    [ExtensionAttribute]
public static void SubscribeWithLifetimeSafe(IDataProvider`1<T> provider, Lifetime lifetime, LifetimedValueUpdatedHandler`1<T> handler);
    [ExtensionAttribute]
public static void SubscribeSafe(IDataProviderBase`1<Nullable`1<T>> provider, Lifetime lifetime, ValueUpdatedHandler`1<T> handler);
    [ExtensionAttribute]
public static void SubscribeSafe(IDataProviderBase`1<T> provider, IDataProvider`1<bool> isActive, ValueUpdatedHandler`1<T> handler);
    [ExtensionAttribute]
private static ValueUpdatedHandler`1<Pair`2<TA, TB>> ToValueUpdatedHandler(Action`2<TA, TB> handler);
    [ExtensionAttribute]
private static ValueUpdatedHandler`1<Pair`2<Pair`2<TA, TB>, TC>> ToValueUpdatedHandler(Action`3<TA, TB, TC> handler);
    [ExtensionAttribute]
public static void Subscribe(IDataProviderBase`1<Pair`2<TA, TB>> source, Lifetime lifetime, Action`2<TA, TB> handler);
    [ExtensionAttribute]
public static void Subscribe(IDataProviderBase`1<Pair`2<Pair`2<TA, TB>, TC>> source, Lifetime lifetime, Action`3<TA, TB, TC> handler);
    [ExtensionAttribute]
public static void Subscribe(IDataSignal signal, IDataProvider`1<bool> isActive, Action handler);
    [ExtensionAttribute]
public static void Subscribe(IDataSignal signal, Lifetime lifetime, Action handler);
    [ExtensionAttribute]
public static void SubscribeForever(IDataProviderBase`1<PipeEventData`1<T>> provider, ValueUpdatedHandler`1<T> handler);
    [ExtensionAttribute]
public static void Subscribe(IDataProviderBase`1<PipeEventData`1<T>> provider, Lifetime lifetime, ValueUpdatedHandler`1<T> handler);
    [ExtensionAttribute]
public static void Subscribe(IDataProviderBase`1<PipeEventData`1<T>> provider, IDataProvider`1<bool> isActive, ValueUpdatedHandler`1<T> handler);
    [ExtensionAttribute]
public static void SubscribeForever(IDataEvent`1<T> dataEvent, ValueUpdatedHandler`1<T> handler);
    [ExtensionAttribute]
public static void Subscribe(IDataEvent`1<T> dataEvent, Lifetime lifetime, ValueUpdatedHandler`1<T> handler);
    [ExtensionAttribute]
public static void Subscribe(IDataEvent`1<T> dataEvent, IDataProvider`1<bool> isActive, ValueUpdatedHandler`1<T> handler);
    [ExtensionAttribute]
public static void SubscribeForeverWithConsistencyState(IDataProviderBase`1<T> source, ValueUpdatedHandler`1<ValueWithConsistencyState`1<T>> handler);
    [ExtensionAttribute]
public static void SubscribeForever(IDataProviderBase`1<T> source, ValueUpdatedHandler`1<T> handler, bool ignoreCleanup);
    [ExtensionAttribute]
public static void SubscribeForeverWithConsistencyState(IDataProviderBase`1<T> source, Func`2<ValueWithConsistencyState`1<T>, bool> condition, ValueUpdatedHandler`1<ValueWithConsistencyState`1<T>> handler);
    [ExtensionAttribute]
public static void SubscribeForever(IDataProviderBase`1<T> source, Func`2<T, bool> condition, ValueUpdatedHandler`1<T> handler, bool ignoreCleanup);
    [ExtensionAttribute]
public static void SubscribeForever(IDataProvider`1<T> source, LifetimedValueUpdatedHandler`1<T> handler);
    [ExtensionAttribute]
public static void SubscribeForever(IDataProviderBase`1<T> source, ValueWithPreviousUpdateHandler`1<T> handler);
    [ExtensionAttribute]
public static void SubscribeForever(IDataProvider`1<T> source, Func`2<T, bool> condition, LifetimedValueUpdatedHandler`1<T> handler);
    [ExtensionAttribute]
public static void Subscribe(IDataProviderBase`1<T> source, Lifetime lifetime, Func`2<T, bool> condition, ValueUpdatedHandler`1<T> handler, bool ignoreCleanup);
    [ExtensionAttribute]
public static void SubscribeOnce(IDataProviderBase`1<T> source, Lifetime lifetime, Func`2<T, bool> condition, ValueUpdatedHandler`1<T> handler, bool ignoreCleanup);
    [ExtensionAttribute]
public static IDataProviderBase`1<T> Subscribe(IDataProviderBase`1<T> source, Lifetime lifetime, ValueUpdatedHandler`1<T> handler, bool ignoreCleanup);
    [ExtensionAttribute]
public static void Subscribe(IDataProviderBase`1<T> source, IDataProvider`1<bool> isActiveProvider, ValueUpdatedHandler`1<T> handler);
    [ExtensionAttribute]
public static void SubscribeWithConsistencyState(IDataProviderBase`1<T> source, IDataProvider`1<bool> isActiveProvider, ValueUpdatedHandler`1<ValueWithConsistencyState`1<T>> handler);
    [ExtensionAttribute]
public static void Subscribe(IDataProviderBase`1<T> source, IDataProvider`1<bool> isActiveProvider, Func`2<T, bool> condition, ValueUpdatedHandler`1<T> handler, bool ignoreCleanup);
    [ExtensionAttribute]
public static void SubscribeWithConsistencyState(IDataProviderBase`1<T> source, IDataProvider`1<bool> isActiveProvider, Func`2<ValueWithConsistencyState`1<T>, bool> condition, ValueUpdatedHandler`1<ValueWithConsistencyState`1<T>> handler);
    [ExtensionAttribute]
public static void SubscribeFirst(IDataProviderBase`1<T> source, Lifetime lifetime, Func`2<T, bool> condition, ValueUpdatedHandler`1<T> handler);
    [ExtensionAttribute]
public static void SubscribeSafe(IDataProviderBase`1<T> source, IDataProvider`1<bool> isActiveProvider, LifetimedValueUpdatedHandler`1<T> handler);
    [ExtensionAttribute]
public static void Subscribe(IDataProviderBase`1<T> source, IDataProvider`1<bool> isActiveProvider, LifetimedValueUpdatedHandler`1<T> handler);
    [ExtensionAttribute]
public static IDataProvider`1<T> Subscribe(IDataProvider`1<T> source, Lifetime lifetime, LifetimedValueUpdatedHandler`1<T> handler);
    [ExtensionAttribute]
public static void Subscribe(IDataProviderBase`1<T> source, Lifetime lifetime, ValueWithPreviousUpdateHandler`1<T> handler);
    [ExtensionAttribute]
public static void Subscribe(IDataProviderBase`1<T> source, Lifetime lifetime, Func`2<T, bool> condition, LifetimedValueUpdatedHandler`1<T> handler);
    [ExtensionAttribute]
public static void Subscribe(IDataProviderBase`1<T> source, IDataProvider`1<bool> isActiveProvider, Func`2<T, bool> condition, LifetimedValueUpdatedHandler`1<T> handler);
    [ExtensionAttribute]
public static void SubscribeFirstTrue(IDataProviderBase`1<bool> source, Lifetime lifetime, Action handler);
    [ExtensionAttribute]
public static void SubscribeFirstNotNull(IDataProviderBase`1<T> source, Lifetime lifetime, ValueUpdatedHandler`1<T> handler);
    [ExtensionAttribute]
public static void SubscribeFirstNotNull(IDataProviderBase`1<Nullable`1<T>> source, Lifetime lifetime, ValueUpdatedHandler`1<T> handler);
    [ExtensionAttribute]
public static IDataProvider`1<T> Activate(IDataProvider`1<T> source, Lifetime lifetime);
    [ExtensionAttribute]
public static IDataProvider`1<T> Activate(IDataProvider`1<T> source, IDataProvider`1<bool> activate);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<T> Activate(IAsyncDataProvider`1<T> source, Lifetime lifetime);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.DataPipes.SwitchEx : object {
    [ExtensionAttribute]
public static IAsyncDataProvider`1<T> ToThreadPool(IThreadSwitch`1<T> provider, DataPipeLifetime lifetime, UpdateValueLogic updateLogic);
    [ExtensionAttribute]
public static IRemotableReference`1<IDataProvider`1<T>> ToMainThread(IRemotableReference`1<IThreadSwitch`1<T>> provider, TimeSpan delay);
    [ExtensionAttribute]
public static IRemotableReference`1<IAsyncDataProvider`1<T>> ToThreadPool(IRemotableReference`1<IThreadSwitch`1<T>> provider, IRemotablePair`1<DataPipeLifetime> lifetime);
    [ExtensionAttribute]
public static IRemotableReference`1<IAsyncDataProvider`1<T>> ToThreadPool(IRemotableReference`1<IThreadSwitch`1<T>> provider, IRemotableReference`1<DataPipeLifetime> lifetime);
    [ExtensionAttribute]
public static IDataProvider`1<T> ToMainThread(IThreadSwitch`1<T> provider, bool debug);
    [ExtensionAttribute]
public static IDataProvider`1<T> ToMainThread(IThreadSwitch`1<T> provider, DataPipeLifetime lifetime);
    [ExtensionAttribute]
private static IDataProvider`1<T> ToMainThreadCore(IThreadSwitch`1<T> provider, DataPipeLifetime lifetime, bool debug);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<T> ToThreadDispatcher(IThreadSwitch`1<T> provider, IStaThreadDispatcher dispatcher, DataPipeLifetime lifetime, UpdateValueLogic updateLogic);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<T> SwitchToThreadPool(IDataProviderBase`1<T> provider, DataPipeLifetime lifetime, UpdateValueLogic updateLogic);
    [ExtensionAttribute]
public static IDataProvider`1<IDataProvider`1[]> SplitArray(IDataProvider`1<T[]> provider);
    [ExtensionAttribute]
public static IDataProvider`1<T> SwitchStreamToMainThread(IDataProviderBase`1<T> provider);
    [ExtensionAttribute]
public static IDataProvider`1<T> SwitchToMainThread(IDataProviderBase`1<T> provider, DataPipeLifetime lifetime);
    [ExtensionAttribute]
public static IDataProvider`1<T> SwitchToMainThread(IDataProviderBase`1<T> provider, bool debug);
    [ExtensionAttribute]
public static IThreadSwitchEx`1<List`1<T>> SwitchRecycle(IDataProviderBase`1<IEnumerable`1<T>> provider);
    [ExtensionAttribute]
public static IThreadSwitchEx`1<List`1<T>> SwitchRecycleWithController(IAsyncDataProvider`1<IEnumerable`1<T>> provider);
    [ExtensionAttribute]
public static IThreadSwitchEx`1<C> SwitchRecycleWithController(IAsyncDataProvider`1<IEnumerable`1<T>> provider);
    [ExtensionAttribute]
public static IThreadSwitchEx`1<TC> SwitchRecycle(IDataProviderBase`1<TA> provider, Func`3<TA, TB, TC> fillContainer);
    [ExtensionAttribute]
public static IThreadSwitchEx`1<TC> SwitchRecycle(IAsyncDataProvider`1<TA> provider, Func`4<TA, TB, IExecutionController, TC> fillContainer);
    [ExtensionAttribute]
public static IThreadSwitchEx`1<TOutput> SwitchRecycle(IAsyncDataProvider`1<TInput> provider, Func`1<TContainer> createContainer, Func`4<TInput, TContainer, IExecutionController, TOutput> fillContainer);
    [ExtensionAttribute]
public static IThreadSwitchEx`1<C> SwitchRecycle(IDataProviderBase`1<IEnumerable`1<T>> provider);
    [ExtensionAttribute]
internal static IDataProviderInternal`1<T> ToExternalExecutor(IDataProvider`1<T> src, Action`1<Action> executor);
    [ExtensionAttribute]
public static IThreadSwitch`1<T> Switch(IDataProviderBase`1<T> provider);
    [ExtensionAttribute]
public static IThreadSwitch`1<T> SwitchStream(IDataProviderBase`1<T> provider);
    [ExtensionAttribute]
internal static IThreadSwitch`1<T> SwitchCore(IDataProviderBase`1<T> provider, bool isStream);
    [ExtensionAttribute]
public static IThreadSwitchEx`1<TB> SwitchRecycle(IDataProvider`1<TA> provider, Func`3<TA, TB, TB> fillContainer);
    [ExtensionAttribute]
public static IThreadSwitchEx`1<TC> SwitchRecycle(IDataProviderBase`1<TA> provider, Func`1<TB> createContainer, Func`3<TA, TB, TC> fillContainer);
    [ExtensionAttribute]
private static IDataProvider`1<T> ToDispatcher(IThreadSwitch`1<T> sw, DataPipeLifetime lifetime, bool debug);
    [ExtensionAttribute]
private static IDataProvider`1<T> ToDispatcherStream(IDataProvider`1<T> provider, IStaThreadDispatcher dispatcher);
    [ExtensionAttribute]
internal static IThreadSwitch`1<Getter`1<T>> Elevate(IThreadSwitch`1<T> sw);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<T> ToAsyncExecutor(IThreadSwitch`1<T> sw, ISequentialTaskScheduler sequentialScheduler, UpdateValueLogic updateLogic);
    [ExtensionAttribute]
public static IDataProvider`1<T> WhileNotInitializedUseDefault(IDataProvider`1<T> provider);
    [ExtensionAttribute]
public static IDataProvider`1<T> WhileNotInitializedUse(IDataProvider`1<T> provider, T replacement);
    [ExtensionAttribute]
public static IDataProvider`1<T> WhileNotInitializedUse(IDataProvider`1<T> provider, IDataProvider`1<T> replacement);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.DataPipes.TransformEx : object {
    [ExtensionAttribute]
public static IDataProvider`1<TB> TransformSafe(IDataProvider`1<TA> provider, Func`2<TA, TB> converter, TB fallbackValue);
    [ExtensionAttribute]
public static IDataProvider`1<TB> TransformSafe(IDataProvider`1<TA> provider, Predicate`1<TA> condition, Func`2<TA, TB> converter, TB fallbackValue);
    [ExtensionAttribute]
public static IRemotableReference`1<IDataProvider`1<TB>> TransformSafe(IRemotableReference`1<IDataProvider`1<Nullable`1<TA>>> provider, Func`2<TA, TB> converter, TB fallbackValue);
    [ExtensionAttribute]
public static IRemotableReference`1<IDataProvider`1<TB>> TransformSafe(IRemotableReference`1<IDataProvider`1<TA>> provider, Func`2<TA, TB> converter, TB fallbackValue);
    [ExtensionAttribute]
public static IRemotableReference`1<IDataProvider`1<TB>> TransformSafe(IRemotableReference`1<IDataProvider`1<IntPtr>> provider, Func`2<IntPtr, TB> converter, TB fallbackValue);
    [ExtensionAttribute]
public static IRemotableReference`1<IAsyncDataProvider`1<TB>> TransformSafe(IRemotableReference`1<IAsyncDataProvider`1<IntPtr>> provider, Func`2<IntPtr, TB> converter, TB fallbackValue);
    [ExtensionAttribute]
public static IDataProvider`1<TC> TransformPair(IDataProvider`1<Pair`2<TA, TB>> provider, Func`3<TA, TB, TC> converter);
    [ExtensionAttribute]
public static IDataProvider`1<TR> TransformSafe(IDataProvider`1<Pair`2<TA, TB>> provider, Func`3<TA, TB, bool> isSafe, Func`3<TA, TB, TR> converter, TR fallbackValue);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<TC> TransformSafe(IAsyncDataProvider`1<Pair`2<TA, TB>> provider, Func`3<TA, TB, TC> converter);
    [ExtensionAttribute]
public static IDataProvider`1<TC> TransformSafe(IDataProvider`1<Pair`2<TA, TB>> provider, Func`3<TA, TB, TC> converter);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<TB> TransformWithLifetimeSafe(IAsyncDataProvider`1<TA> provider, Func`3<Lifetime, TA, TB> converter, TB fallbackValue);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<TB> TransformWithLifetime(IAsyncDataProvider`1<TA> provider, Func`3<Lifetime, TA, TB> converter);
    [ExtensionAttribute]
public static IDataProvider`1<TR> TransformWithLifetimeSafe(IDataProvider`1<Pair`2<TA, TB>> provider, Func`4<Lifetime, TA, TB, TR> converter, TR fallbackValue);
    [ExtensionAttribute]
public static IDataProvider`1<TB> TransformWithLifetimeSafe(IDataProvider`1<TA> provider, Func`3<Lifetime, TA, TB> converter, TB fallbackValue);
    [ExtensionAttribute]
public static IDataProvider`1<TB> TransformWithLifetimeSafe(IDataProvider`1<TA> provider, Lifetime parentLifetime, Func`3<Lifetime, TA, TB> converter, TB fallbackValue);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<TR> TransformWithLifetimeSafe(IAsyncDataProvider`1<Pair`2<TA, TB>> provider, Predicate`1<Pair`2<TA, TB>> isSafe, Func`4<Lifetime, Pair`2<TA, TB>, IExecutionController, TR> converter, TR fallbackValue, string operationName);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<TR> TransformWithLifetimeSafe(IAsyncDataProvider`1<TA> provider, Func`4<Lifetime, TA, IExecutionController, TR> converter, TR fallbackValue, string operationName);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<TR> TransformWithLifetime(IAsyncDataProvider`1<TA> provider, Func`4<Lifetime, TA, IExecutionController, TR> converter, string operationName);
    [ExtensionAttribute]
public static IDataProvider`1<TB> TransformWithLifetime(IDataProvider`1<TA> provider, Lifetime parentLifetime, Func`3<Lifetime, TA, TB> converter);
    [ExtensionAttribute]
public static IDataProvider`1<TB> TransformWithLifetime(IDataProvider`1<TA> provider, Func`3<Lifetime, TA, TB> converter);
    [ExtensionAttribute]
public static IDataProvider`1<TB> TransformSafe(IDataProvider`1<IntPtr> provider, Func`2<IntPtr, TB> converter, TB fallback);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<TB> TransformSafe(IAsyncDataProvider`1<IntPtr> provider, Func`2<IntPtr, TB> converter, TB fallback);
    [ExtensionAttribute]
public static IDataProvider`1<TB> TransformSafe(IDataProvider`1<Nullable`1<TA>> provider, Func`2<TA, TB> converter, TB fallbackValue);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<TB> TransformSafe(IAsyncDataProvider`1<TA> provider, Func`3<TA, IExecutionController, TB> converter, string operationTitle, TB fallbackValue);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<TB> TransformSafe(IAsyncDataProvider`1<TA> provider, Func`2<TA, TB> converter, TB fallbackValue);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<TB> TransformSafe(IAsyncDataProvider`1<Nullable`1<TA>> provider, Func`2<TA, TB> converter, TB fallbackValue);
    [ExtensionAttribute]
public static IDataProvider`1<TC> TransformRecycle(IDataProvider`1<TA> provider, TB value, Func`3<TA, TB, TC> fill);
    [ExtensionAttribute]
public static IDataProvider`1<TB> TransformRecycleSafe(IDataProvider`1<TA> provider, TB value, Func`3<TA, TB, TB> fill);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<TB> TransformRecycleSafe(IAsyncDataProvider`1<TA> provider, TB value, Action`3<TA, TB, IExecutionController> fill);
    [ExtensionAttribute]
public static IDataProvider`1<IEnumerable`1<TB>> TransformEnumerables(IDataProvider`1<IEnumerable`1<TA>> provider, Func`2<TA, TB> converter, Func`2<TA, bool> filter);
    [ExtensionAttribute]
public static IDataProvider`1<TB[]> TransformArraySafe(IDataProvider`1<TA[]> provider, Func`2<TA, TB> converter, TB fallbackValue, bool reuseArray);
    [ExtensionAttribute]
public static IDataProvider`1<TB[]> TransformArray(IDataProvider`1<TA[]> provider, Func`2<TA, TB> converter, bool reuseArray);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<IEnumerable`1<TB>> TransformEnumerables(IAsyncDataProvider`1<IEnumerable`1<TA>> provider, Func`2<TA, TB> converter, Func`2<TA, bool> filter);
    [ExtensionAttribute]
public static IDataProvider`1<TB> TransformWithCache(IDataProvider`1<TA> provider, Func`2<TA, TB> createValue);
    [ExtensionAttribute]
public static IDataProvider`1<IDictionary`2<TA, TB>> TransformEnumerablesWithCache(IDataProvider`1<IReadOnlyCollection`1<TA>> provider, Func`2<TA, TB> converter);
    [ExtensionAttribute]
public static IDataProvider`1<TB> TransformWithTaskExecutor(IDataProvider`1<TA> src, ITaskExecutor executor, string name, TaskCancelable cancelable, Func`3<TA, IProgressIndicator, TB> task);
    [ExtensionAttribute]
public static IDataProvider`1<PipeEventData`1<TB>> Transform(IDataProvider`1<PipeEventData`1<TA>> provider, Func`2<TA, TB> converter);
    [ExtensionAttribute]
public static IDataProvider`1<PipeEventData`1<TB>> TransformSafe(IDataProvider`1<PipeEventData`1<TA>> provider, Func`2<TA, TB> converter, TB fallback);
    [ExtensionAttribute]
[NotNullAttribute]
public static IDataProvider`1<TB> Transform(IDataProvider`1<TA> provider, Func`2<TA, TB> converter);
    [ExtensionAttribute]
[NotNullAttribute]
public static IDataProvider`1<TC> Transform(IDataProvider`1<Pair`2<TA, TB>> provider, Func`3<TA, TB, TC> converter);
    [ExtensionAttribute]
[NotNullAttribute]
public static IRemotableReference`1<IDataProvider`1<TB>> Transform(IRemotableReference`1<IDataProvider`1<TA>> provider, Func`2<TA, TB> converter);
    [ExtensionAttribute]
[NotNullAttribute]
public static IRemotableReference`1<IAsyncDataProvider`1<TB>> Transform(IRemotableReference`1<IAsyncDataProvider`1<TA>> provider, Func`2<TA, TB> converter);
    [ExtensionAttribute]
[NotNullAttribute]
public static IDataProvider`1<TTo> TransformWithPrevious(IDataProvider`1<TFrom> source, Func`3<TFrom, TTo, TTo> converter);
    [ExtensionAttribute]
public static IThreadSwitch`1<TB> TransformWithLastValueCache(IThreadSwitch`1<TA> s, Func`2<TA, TB> converter, IEqualityComparer`1<TA> comparer);
    [ExtensionAttribute]
[NotNullAttribute]
public static IThreadSwitch`1<TB> Transform(IThreadSwitch`1<TA> s, Func`2<TA, TB> converter);
    [ExtensionAttribute]
public static IThreadSwitch`1<TB> TransformLocked(IThreadSwitch`1<ILocked`1<TA>> s, Func`2<TA, TB> converter, TB fallback);
    [ExtensionAttribute]
[NotNullAttribute]
public static IThreadSwitch`1<TB> TransformSafe(IThreadSwitch`1<TA> s, Func`2<TA, TB> converter, TB fallback);
    [ExtensionAttribute]
[NotNullAttribute]
public static IThreadSwitch`1<TB> TransformSafe(IThreadSwitch`1<Nullable`1<TA>> s, Func`2<TA, TB> converter, TB fallback);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<TC> Transform(IAsyncDataProvider`1<Pair`2<TA, TB>> provider, Func`4<TA, TB, IExecutionController, TC> converter, string operationName);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<TR> TransformSafe(IAsyncDataProvider`1<Pair`2<TA, TB>> provider, Predicate`1<Pair`2<TA, TB>> isSafePredicate, Func`4<TA, TB, IExecutionController, TR> converter, string operationName, TR fallbackValue);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<TR> TransformSafe(IAsyncDataProvider`1<TA> provider, Predicate`1<TA> isSafePredicate, Func`3<TA, IExecutionController, TR> converter, string operationName, TR fallbackValue);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<TB> Transform(IAsyncDataProvider`1<TA> provider, Func`3<TA, IExecutionController, TB> converter, string operationName);
    [ExtensionAttribute]
public static IRemotableReference`1<IAsyncDataProvider`1<TB>> Transform(IRemotableReference`1<IAsyncDataProvider`1<TA>> provider, Func`3<TA, IExecutionController, TB> converter);
    [ExtensionAttribute]
public static IRemotableReference`1<IAsyncDataProvider`1<TB>> TransformSafe(IRemotableReference`1<IAsyncDataProvider`1<TA>> provider, Func`3<TA, IExecutionController, TB> converter, string operationTitle, TB fallbackValue);
    [ExtensionAttribute]
[NotNullAttribute]
public static IDataProvider`1<Nullable`1<T>> TransformToNullable(IDataProvider`1<T> provider);
    [ExtensionAttribute]
[NotNullAttribute]
public static IAsyncDataProvider`1<TB> Transform(IAsyncDataProvider`1<TA> provider, Func`2<TA, TB> converter);
    [ExtensionAttribute]
public static IDataProvider`1<TB> TransformAsync(IDataProvider`1<TA> provider, DataPipeLifetime lifetime, Func`2<TA, TB> converter);
    [ExtensionAttribute]
public static IDataProvider`1<TB> TransformAsync(IDataProvider`1<TA> provider, DataPipeLifetime lifetime, Func`3<TA, IExecutionController, TB> converter);
    [ExtensionAttribute]
public static IDataProvider`1<TB> TransformSyncOrAsync(IDataProvider`1<TA> provider, DataPipeLifetime lifetime, IDataProvider`1<bool> useAsync, Func`2<TA, TB> converter);
    [ExtensionAttribute]
public static IDataProvider`1<T> Transform(IDataSignal signal, Func`1<T> getValue);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<TA> First(IAsyncDataProvider`1<Pair`2<TA, TB>> provider);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<TB> Second(IAsyncDataProvider`1<Pair`2<TA, TB>> provider);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.DataPipes.UpdateDeferingEx : object {
    [ExtensionAttribute]
public static IRemotableReference`1<IDataProvider`1<T>> DeferUpdate(IRemotableReference`1<IDataProvider`1<T>> provider, TimeSpan delay);
    [ExtensionAttribute]
public static IDataProvider`1<T> DeferUpdate(IDataProvider`1<T> provider, DataPipeLifetime lifetime, TimeSpan delay);
    [ExtensionAttribute]
public static IDataProvider`1<T> DeferUpdate(IDataProvider`1<T> provider, TimeSpan delay);
    [ExtensionAttribute]
private static IDataProvider`1<T> DeferUpdateCore(IDataProvider`1<T> provider, DataPipeLifetime lifetime, TimeSpan delay);
    [ExtensionAttribute]
public static IDataProvider`1<PipeEventData`1<T>> WaitForSignal(IDataProvider`1<T> provider, IDataSignal signal);
    [ExtensionAttribute]
public static IDataProvider`1<T> AddAfterUpdateSignal(IDataProvider`1<T> provider, IDataSignal& signal);
    [ExtensionAttribute]
private static IDataProvider`1<T> AddAfterUpdateSignalCore(IDataProvider`1<T> provider, IDataSignalControllerBase c);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<T> AddAfterUpdateSignal(IAsyncDataProvider`1<T> provider, IAsyncDataSignal& signal);
    internal static IAsyncDataSignalController CreateDerivedAsyncSignal(IAsyncController controller);
}
public enum JetBrains.Common.Util.DataPipes.UpdateValueLogic : Enum {
    public int value__;
    public static UpdateValueLogic CancelRunningUpdate;
    public static UpdateValueLogic WaitForRunningUpdate;
}
public enum JetBrains.Common.Util.DataPipes.ValueConsistencyState : Enum {
    public int value__;
    public static ValueConsistencyState NotInitialized;
    public static ValueConsistencyState Invalidated;
    public static ValueConsistencyState Consistent;
}
public class JetBrains.Common.Util.DataPipes.ValueEditingState : object {
    public bool HasChanges;
    [CanBeNullAttribute]
public string Error;
    public bool HasError { get; }
    public ValueEditingState(bool hasChanges);
    public ValueEditingState(string error);
    public bool get_HasError();
}
public class JetBrains.Common.Util.DataPipes.ValueEditor`2 : object {
    public IDataProvider`1<TOut> Output;
    public IDataController`1<TIn> EditableValue;
    public IDataProvider`1<ValueEditingState> EditingState;
    public ValueEditor`2(IDataController`1<TIn> editableValue, IDataProvider`1<ValueEditingState> editingState, IDataProvider`1<TOut> output);
}
public enum JetBrains.Common.Util.DataPipes.ValuePassBehavior : Enum {
    public int value__;
    public static ValuePassBehavior PassCurrentValue;
    public static ValuePassBehavior UseLastValue;
    public static ValuePassBehavior Invalidate;
    public static ValuePassBehavior Cleanup;
}
public class JetBrains.Common.Util.DataPipes.ValueUpdatedHandler`1 : MulticastDelegate {
    public ValueUpdatedHandler`1(object object, IntPtr method);
    public virtual void Invoke(T newValue);
    public virtual IAsyncResult BeginInvoke(T newValue, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum JetBrains.Common.Util.DataPipes.ValueUpdateType : Enum {
    public int value__;
    public static ValueUpdateType FullUpdate;
    public static ValueUpdateType Resurrect;
}
public class JetBrains.Common.Util.DataPipes.ValueWithAttribute`2 : ValueType {
    public T Value;
    public TAttribute Attribute;
    public ValueUpdateType UpdateType;
    public ValueWithAttribute`2(T value, TAttribute attribute, ValueUpdateType isUpdate);
    [LocalizableAttribute("False")]
public virtual string ToString();
    public sealed virtual bool Equals(ValueWithAttribute`2<T, TAttribute> other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class JetBrains.Common.Util.DataPipes.ValueWithConsistencyState`1 : ValueType {
    public ValueConsistencyState State;
    public T Value;
    public bool HasValue { get; }
    public bool get_HasValue();
    [LocalizableAttribute("False")]
public virtual string ToString();
}
public class JetBrains.Common.Util.DataPipes.ValueWithPreviousUpdateHandler`1 : MulticastDelegate {
    public ValueWithPreviousUpdateHandler`1(object object, IntPtr method);
    public virtual void Invoke(T oldValue, T newValue);
    public virtual IAsyncResult BeginInvoke(T oldValue, T newValue, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.DateTimeEx : object {
    private static DateTime Epoch;
    private static DateTimeEx();
    [ExtensionAttribute]
public static int ToUnixTime(DateTime current);
}
public static class JetBrains.Common.Util.DelayedExecution : object {
    public static void Execute(Lifetime lifetime, TimeSpan delayTime, Action action);
}
public class JetBrains.Common.Util.DelegatedReadOnlyCollection`1 : object {
    [NotNullAttribute]
private IEnumerable`1<TKey> myEnumerable;
    [NotNullAttribute]
private Func`2<TKey, bool> myContains;
    [NotNullAttribute]
private Func`1<int> myGetCount;
    public int Count { get; }
    public DelegatedReadOnlyCollection`1(IEnumerable`1<TKey> enumerable, Func`2<TKey, bool> contains, Func`1<int> getCount);
    public sealed virtual IEnumerator`1<TKey> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual int get_Count();
    public bool Contains(TKey value);
}
public static class JetBrains.Common.Util.DelegatesExecutionTracer : object {
    private static EventTracer ourInstance;
    public static string TracerName;
    public static string Created;
    public static string Execution;
    public static EventTracer Instance { get; }
    public static EventTracer get_Instance();
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.DelegatesExecutionTracingEx : object {
    private static int ourId;
    public static bool IsEnabled;
    private static void TraceExecution(Action& action);
    private static void TraceExecution(Action`1& action);
    private static void TraceExecutionCore(Action& action);
    private static void TraceExecutionCore(Action`1& action);
    [ExtensionAttribute]
public static void BeginInvokeTraced(Action action);
    [ExtensionAttribute]
public static void BeginInvokeTraced(Action`1<T> action, T arg);
    [ExtensionAttribute]
public static void BeginInvokeTraced(Dispatcher dispatcher, Action action);
    [ExtensionAttribute]
public static void BeginInvokeTraced(IStaThreadDispatcher dispatcher, Action action);
    [ExtensionAttribute]
public static void InvokeTraced(Dispatcher dispatcher, Action action);
    [ExtensionAttribute]
public static void InvokeTraced(Dispatcher dispatcher, Action`1<T> action, T arg);
    [ExtensionAttribute]
public static void BeginInvokeTraced(Dispatcher dispatcher, Action`1<T> action, T arg);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.DispatcherEx : object {
    [ExtensionAttribute]
public static void AssertAccess(Dispatcher dispatcher);
    [ExtensionAttribute]
public static void AssertAccess(IStaThreadDispatcher dispatcher);
}
public class JetBrains.Common.Util.DisposingLogic : object {
    private bool myIsDisposed;
    private Action myDisposeAction;
    public bool IsDisposed { get; }
    public DisposingLogic(Action disposeAction);
    public bool get_IsDisposed();
    public void ThrowIfDisposed(string objectName, string message);
    public sealed virtual void Dispose();
}
public static class JetBrains.Common.Util.Empty : object {
    public static string PropertyId;
    public static string DataRuleName;
    public static string ActionName;
    public static Action Action();
    public static Action`1<T> Action();
    public static T[] Array();
    public static IList`1<T> List();
    public static IEnumerable`1<T> Enumerable();
    public static IReadOnlyCollection`1<T> Countable();
    public static IReadOnlyList`1<T> Indexable();
    public static IReadOnlyCollection`1<T> JetReadOnlyCollection();
}
public class JetBrains.Common.Util.EnumerableEqualityComparer`1 : object {
    public sealed virtual bool Equals(T x, T y);
    public sealed virtual int GetHashCode(T obj);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.EnumerableExtension : object {
    [IteratorStateMachineAttribute("JetBrains.Common.Util.EnumerableExtension/<SelectOverlappingPairs>d__0`1")]
[ExtensionAttribute]
public static IEnumerable`1<Pair`2<T, Nullable`1<T>>> SelectOverlappingPairs(IEnumerable`1<T> source);
    [IteratorStateMachineAttribute("JetBrains.Common.Util.EnumerableExtension/<SplitToPairs>d__1`1")]
[ExtensionAttribute]
public static IEnumerable`1<Pair`2<T, Nullable`1<T>>> SplitToPairs(IEnumerable`1<T> source);
    [IteratorStateMachineAttribute("JetBrains.Common.Util.EnumerableExtension/<MergeIfSorted>d__2`1")]
[ExtensionAttribute]
public static IEnumerable`1<T> MergeIfSorted(IEnumerable`1<T> first, IEnumerable`1<T> second, Comparison`1<T> comprison);
    [IteratorStateMachineAttribute("JetBrains.Common.Util.EnumerableExtension/<Intersect>d__3`1")]
[ExtensionAttribute]
public static IEnumerable`1<IntersectionNode`1<T>> Intersect(IEnumerable`1<T> first, IEnumerable`1<T> second, Comparison`1<T> comparison);
    [IteratorStateMachineAttribute("JetBrains.Common.Util.EnumerableExtension/<TakeAllButLast>d__6`1")]
[ExtensionAttribute]
public static IEnumerable`1<T> TakeAllButLast(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static long SumSigned(IEnumerable`1<T> source, Func`2<T, long> selector);
    [ExtensionAttribute]
public static ulong Sum(IEnumerable`1<T> source, Func`2<T, ulong> selector);
    [ExtensionAttribute]
public static IEnumerable`1<T> Replace(IEnumerable`1<T> source, T oldValue, T newValue);
    [ExtensionAttribute]
public static IEnumerable`1<T> Replace(IEnumerable`1<T> source, Predicate`1<T> replaceIf, T newValue);
    [ExtensionAttribute]
public static IEnumerable`1<T> Replace(IEnumerable`1<T> source, Predicate`1<T> replaceIf, Func`2<T, T> newValueFromOldValue);
    [IteratorStateMachineAttribute("JetBrains.Common.Util.EnumerableExtension/<SkipUntil>d__12`1")]
[ExtensionAttribute]
public static IEnumerable`1<T> SkipUntil(IEnumerable`1<T> src, Func`2<T, bool> condition);
    [IteratorStateMachineAttribute("JetBrains.Common.Util.EnumerableExtension/<GenerateFromPair>d__13`1")]
public static IEnumerable`1<T> GenerateFromPair(Pair`2<T, T> pair, Func`2<T, Pair`2<T, bool>> moveNext, IComparer`1<T> comparer);
    [ExtensionAttribute]
public static void BatchProcess(IEnumerable`1<T> enumerable, T[] buffer, Action`3<T[], int, TContext> processBatch, TContext context);
    [ExtensionAttribute]
public static IDictionary`2<TKey, TValue> ToDictionaryFromKeys(IEnumerable`1<TKey> keys, Func`2<TKey, TValue> fGetValue);
    [ExtensionAttribute]
public static int EnumerableGetHashCode(IEnumerable`1<T> obj);
    [ExtensionAttribute]
public static bool AllAreSame(IEnumerable`1<TA> src, Func`2<TA, TB> selector);
    [ExtensionAttribute]
public static bool AllAreSame(IEnumerable`1<TA> src, Func`2<TA, TB> selector, IEqualityComparer`1<TB> comparer);
    [ExtensionAttribute]
public static bool AllAreSame(IEnumerable`1<T> src);
    [ExtensionAttribute]
public static bool AllAreSame(IEnumerable`1<T> src, IEqualityComparer`1<T> comparer);
    [IteratorStateMachineAttribute("JetBrains.Common.Util.EnumerableExtension/<SkipIf>d__21`1")]
[ExtensionAttribute]
public static IEnumerable`1<T> SkipIf(IEnumerable`1<T> enumerable, Func`2<T, bool> predicate, Func`2<int, bool> appearanceNumber);
    [IteratorStateMachineAttribute("JetBrains.Common.Util.EnumerableExtension/<SkipLast>d__22`1")]
[ExtensionAttribute]
public static IEnumerable`1<T> SkipLast(IEnumerable`1<T> source, int count);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.EnumerableExtensions : object {
    [IteratorStateMachineAttribute("JetBrains.Common.Util.EnumerableExtensions/<EnumerateAttachController>d__0`1")]
[ExtensionAttribute]
private static IEnumerable`1<T> EnumerateAttachController(IEnumerable`1<T> source, IExecutionController controller);
    [ExtensionAttribute]
public static IEnumerable`1<T> InjectController(IEnumerable`1<T> source, IExecutionController controller);
    [ExtensionAttribute]
public static int MaxSafe(IEnumerable`1<T> values, Func`2<T, int> getValue, int fallback);
    [IteratorStateMachineAttribute("JetBrains.Common.Util.EnumerableExtensions/<ToggleElement>d__3`1")]
public static IEnumerable`1<T> ToggleElement(IEnumerable`1<T> collection, T toToggle);
    [ExtensionAttribute]
[PureAttribute]
public static bool EqualNullableEnumerables(IEnumerable`1<T> left, IEnumerable`1<T> right);
}
public class JetBrains.Common.Util.EnumerationListeners.CollectionPart`2 : object {
    public ChunkList`1<T> Collection;
    public TCollectionInfo Info;
    public CollectionRange Range;
    public int SourceCount;
    public int Version;
    public CollectionPart`2(ChunkList`1<T> collection, TCollectionInfo info, CollectionRange range, int sourceCount, int version);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.EnumerationListeners.CollectionPartEx : object {
    [ExtensionAttribute]
public static bool Has(CollectionPart`2<T, TCollectionInfo> part, int index);
    [ExtensionAttribute]
public static T Get(CollectionPart`2<T, TCollectionInfo> part, int index);
}
public class JetBrains.Common.Util.EnumerationListeners.EnumerationListener`1 : object {
    [NotNullAttribute]
public Action`1<T> OnYield;
    [NotNullAttribute]
public Action`1<ProgressProvider> OnEnumerationStarted;
    [NotNullAttribute]
public Action OnEnumerationFinished;
    [NotNullAttribute]
public Action OnEnumerationCanceled;
    public EnumerationListener`1(Action`1<ProgressProvider> onStarted, Action`1<T> onYield, Action onFinished, Action onCanceled);
}
public class JetBrains.Common.Util.EnumerationListeners.EnumerationListener`2 : object {
    [NotNullAttribute]
public Action`1<TItem> OnYield;
    [NotNullAttribute]
public Action`2<TArg, ProgressProvider> OnEnumerationStarted;
    [NotNullAttribute]
public Action OnEnumerationFinished;
    [NotNullAttribute]
public Action OnEnumerationCanceled;
    public EnumerationListener`2(Action`2<TArg, ProgressProvider> onStarted, Action`1<TItem> onYield, Action onFinished, Action onCanceled);
}
public class JetBrains.Common.Util.EnumerationListeners.EnumerationListenerRecyclingSwitchActions`3 : ValueType {
    public Action`1<TAccumulator> Initialize;
    public Action`2<TItem, TAccumulator> Accumulate;
    [NotNullAttribute]
public Func`2<TAccumulator, TResult> GetResult;
}
public class JetBrains.Common.Util.EnumerationListeners.EnumerationListenerRecyclingSwitchActions`4 : ValueType {
    public Action`2<TAccumulator, TArg> Initialize;
    public Action`2<TItem, TAccumulator> Accumulate;
    [NotNullAttribute]
public Func`2<TAccumulator, TResult> GetResult;
}
public class JetBrains.Common.Util.EnumerationListeners.EnumerationListenerSimpleSwitchActions`4 : ValueType {
    public Func`2<TArg, TAccumulator> CreateAccumulator;
    public Func`3<TItem, TAccumulator, TAccumulator> Aggregate;
    [NotNullAttribute]
public Func`2<TAccumulator, TResult> GetResult;
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.EnumerationListeners.EnumerationListenerWithThreadSwitch : object {
    public static EnumerationListenerWithThreadSwitch`3<TItem, TArg, TAccumulator> CreateSimple(Func`2<TArg, TAccumulator> createAccumulator, Func`3<TItem, TAccumulator, TAccumulator> aggregate);
    public static EnumerationListenerWithThreadSwitch`3<TItem, TArg, TResult> CreateSimple(Func`2<TArg, TAccumulator> createAccumulator, Func`3<TItem, TAccumulator, TAccumulator> aggregate, Func`2<TAccumulator, TResult> getResult);
    public static EnumerationListenerWithThreadSwitch`3<TItem, TArg, TResult> CreateSimple(EnumerationListenerSimpleSwitchActions`4<TItem, TArg, TAccumulator, TResult> actions);
    public static EnumerationListenerWithThreadSwitch`3<TItem, TArg, TContainer> CreateRecycling(Action`2<TContainer, TArg> onStarted, Action`2<TItem, TContainer> onYield, Func`2<TContainer, TContainer> onFinished);
    [ExtensionAttribute]
private static ProgressProvider Prepare(IDataProvider`1<ProgressProvider> progress);
    public static EnumerationListenerWithThreadSwitch`3<TItem, TArg, TResult> CreateRecycling(EnumerationListenerRecyclingSwitchActions`4<TItem, TArg, TContainer, TResult> actions);
    public static EnumerationListenerWithThreadSwitch`2<TItem, TResult> CreateRecycling(EnumerationListenerRecyclingSwitchActions`3<TItem, TContainer, TResult> actions);
    private static EnumerationListener`2<TItem, TArg> CreateEnumerationListener(EnumerationListenerSimpleSwitchActions`4<TItem, TArg, TIntermediate, TResult> actions, IAsyncDataController`1<TResult> controller, IDataController`1<ProgressProvider> progress, ActionEvent cancel);
    private static EnumerationListener`2<TItem, TArg> CreateEnumerationListener(EnumerationListenerRecyclingSwitchActions`4<TItem, TArg, TContainer, TResult> actions, TripleBuffer`2<TContainer, TResult> buffer, IAsyncDataController`1<Getter`1<TResult>> controller, IDataController`1<ProgressProvider> progress, ActionEvent cancel);
    private static EnumerationListener`1<TItem> CreateEnumerationListener(EnumerationListenerRecyclingSwitchActions`3<TItem, TContainer, TResult> actions, TripleBuffer`2<TContainer, TResult> buffer, IAsyncDataController`1<Getter`1<TResult>> controller, IDataController`1<ProgressProvider> progress, ActionEvent cancel);
}
public class JetBrains.Common.Util.EnumerationListeners.EnumerationListenerWithThreadSwitch`2 : ValueType {
    public EnumerationListener`1<TItem> Listener;
    public IThreadSwitch`1<TResult> Switch;
    public EnumerationListenerWithThreadSwitch`2(EnumerationListener`1<TItem> listener, IThreadSwitch`1<TResult> switch);
}
public class JetBrains.Common.Util.EnumerationListeners.EnumerationListenerWithThreadSwitch`3 : ValueType {
    public EnumerationListener`2<TItem, TArg> Listener;
    public IThreadSwitch`1<TResult> Switch;
    public EnumerationListenerWithThreadSwitch`3(EnumerationListener`2<TItem, TArg> listener, IThreadSwitch`1<TResult> switch);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.EnumerationListeners.Extensions : object {
    [IteratorStateMachineAttribute("JetBrains.Common.Util.EnumerationListeners.Extensions/<AttachListener>d__0`1")]
[ExtensionAttribute]
private static IEnumerable`1<T> AttachListener(IEnumerable`1<T> source, EnumerationListener`1<T> listener);
    [ExtensionAttribute]
public static EnumerationListener`1<T> Combine(EnumerationListener`1<T> l, EnumerationListener`1[] other);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static EnumerationListener`1<T> Combine(IEnumerable`1<EnumerationListener`1<T>> listeners);
    [ExtensionAttribute]
public static EnumerationListener`2<T, TArg> Combine(EnumerationListener`2<T, TArg> l, EnumerationListener`2[] other);
    [ExtensionAttribute]
public static EnumerationListener`2<T, TArg> Combine(IEnumerable`1<EnumerationListener`2<T, TArg>> listeners);
    [ExtensionAttribute]
public static IDataProvider`1<IEnumerable`1<T>> AttachListeners(IDataProvider`1<IEnumerable`1<T>> source, IDataProvider`1<IEnumerable`1<EnumerationListener`1<T>>> listenersProvider);
    [ExtensionAttribute]
public static IEnumerable`1<T> Attach(IEnumerable`1<T> source, EnumerationListener`1[] listeners);
    [ExtensionAttribute]
public static void Enumerate(IEnumerable`1<T> source, EnumerationListener`1[] listeners);
    [ExtensionAttribute]
public static SplittedEnumerationListener`2<T, TArg> Split(EnumerationListener`2<T, TArg> listener);
}
public class JetBrains.Common.Util.EnumerationListeners.SplittedEnumerationListener`2 : object {
    private EnumerationListener`2<T, TArg> myListener;
    private int myStarted;
    public SplittedEnumerationListener`2(EnumerationListener`2<T, TArg> listener);
    public EnumerationListener`2<T, TArg> CreateChild();
}
public class JetBrains.Common.Util.EnumerationListeners.VersionedContainer`1 : ValueType {
    public TContainer Container;
    public int Version;
    public VersionedContainer`1(TContainer container, int version);
}
public class JetBrains.Common.Util.Enumerator`1 : object {
    private IEnumerator`1<T> mySource;
    private bool myHasItems;
    public bool HasItems { get; }
    public Enumerator`1(IEnumerator`1<T> source);
    public bool get_HasItems();
    public T GetNext();
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.EnumExtensions : object {
    [ExtensionAttribute]
public static string GetDescription(Enum singleFlagEnumValue);
    [ExtensionAttribute]
public static IEnumerable`1<T> GetEnabledFlags(Enum value);
    [ExtensionAttribute]
public static TAttribute GetFirstOrDefaultEnumAttribute(TEnum value);
}
public class JetBrains.Common.Util.EternalCollection : object {
    public static Lifetime Lifetime;
    private static EternalCollection();
}
public class JetBrains.Common.Util.EventTracer : object {
    private static EventTracer ourDefaultInstance;
    private static EventProvider ourEventProvider;
    private static EventDescriptor ourPointEventDescriptor;
    private static EventDescriptor ourIntervalEventBeginDescriptor;
    private static EventDescriptor ourIntervalEventEndDescriptor;
    private static Dictionary`2<string, int> ourDomainIds;
    private static bool ourInitFailed;
    private int myNextId;
    private string myName;
    private int myDomainId;
    private WeakToStrongDictionary`2<object, string> myMap;
    private ReaderWriterLock myMapLock;
    [ThreadStaticAttribute]
private static List`1<string> ourDefaultRelatedObjects;
    [ThreadStaticAttribute]
private static Object[] ourBuffer;
    public bool IsEnabled { get; }
    private string DefaultRelatedObject { get; private set; }
    public static EventTracer Default { get; }
    private static EventTracer();
    public EventTracer(string name);
    public bool get_IsEnabled();
    private static void AssureRelatedObjectsInitialized();
    private string get_DefaultRelatedObject();
    private void set_DefaultRelatedObject(string value);
    public void SetDefaultRelatedObject(string id);
    public void ResetDefaultRelatedObject();
    private Object[] FillBuffer(string eventType, string relatedObject);
    public void TraceEvent(string eventType, string relatedObject);
    public void TraceEventBegin(string eventType, string relatedObject);
    public void TraceEventEnd();
    public void SetId(object o, string id);
    public static EventTracer get_Default();
    public string GetId(object o);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.Exceptions.ExceptionExtension : object {
    [ExtensionAttribute]
public static TException AddSimpleData(TException exception, string name, object value);
    [ExtensionAttribute]
public static void Rethrow(Exception exception);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.ExecutionController2Extension : object {
    [ExtensionAttribute]
public static void YieldAndProgress(IExecutionController this);
    [ExtensionAttribute]
public static Task Fork(IExecutionController this, Action`1<IExecutionController> action);
    [ExtensionAttribute]
public static Task`1<T> ForkAndAttach(IExecutionController this, Func`2<IExecutionController, T> action, int parentStepsCount);
    [ExtensionAttribute]
public static Task ForkAndAttach(IExecutionController this, Action`1<IExecutionController> action, int parentStepsCount);
    [ExtensionAttribute]
public static Task`1<T> ForkTo(IExecutionController this, ICanScheduleTask otherScheduler, Func`2<IExecutionController, T> action);
    [ExtensionAttribute]
public static Task ForkTo(IExecutionController this, ICanScheduleTask otherScheduler, Action`1<IExecutionController> action);
    [ExtensionAttribute]
public static void Wait(IExecutionController this, Task task, TimeSpan timeout);
    [ExtensionAttribute]
public static void WaitAll(IExecutionController this, TimeSpan timeout, Task[] tasks);
    [ExtensionAttribute]
public static T Wait(IExecutionController this, Task`1<T> task, TimeSpan timeout);
    [ExtensionAttribute]
public static void Wait(IExecutionController this, ManualResetEventSlim event, TimeSpan timeout);
    [ExtensionAttribute]
public static T Wait(IExecutionController this, Func`1<T> nonInterruptableAction, TimeSpan timeout);
    [ExtensionAttribute]
public static Unlocker Lock(IExecutionController this, object mutex, TimeSpan timeout);
    [ExtensionAttribute]
public static Unlocker Lock(IExecutionController this, object mutex);
    [ExtensionAttribute]
public static JetProgress AsJetProgress(IExecutionController this);
    [ExtensionAttribute]
public static IExecutionController AsJetProgress(IExecutionController this, JetProgress& progress);
    [ExtensionAttribute]
public static IExecutionController AsJetProgress(IExecutionController this, int parentSteps, JetProgress& progress);
    [ExtensionAttribute]
public static JetApproximateProgress StartApproximateProgress(IExecutionController this, long approxSteps, int modulus, string operation);
    [ExtensionAttribute]
public static CancellationToken GetCancellationTokenIfAny(IExecutionController this);
    [ExtensionAttribute]
private static void Wait(IExecutionController this, WaitHandle handle, TimeSpan timeout);
}
[ExtensionAttribute]
[ObsoleteAttribute("It is recommended to migrate to new IExecutionController")]
public static class JetBrains.Common.Util.ExecutionControllerExtensions : object {
    [ExtensionAttribute]
public static void YieldAndProgress(IExecutionControllerOld controller);
    [ExtensionAttribute]
public static T ExecuteAsyncWithYields(IExecutionControllerOld controller, TimeSpan yieldFrequency, Func`1<T> asyncAction);
}
public class JetBrains.Common.Util.FilesEx : object {
    public static bool IsFileLockedForWrite(FileSystemPath fileName);
    private static bool IsFileLocked(FileSystemPath fileName, FileAccess fileAccess);
}
[ThreadSafeAttribute]
public class JetBrains.Common.Util.FixedSizeObjectPool`1 : object {
    [CanBeNullAttribute]
private AllocObjectDelegate<T> myAllocator;
    [NotNullAttribute]
private CreateObjectDelegate<T> myCreator;
    [CanBeNullAttribute]
private DisposeObjectDelegate<T> myDisposer;
    [NotNullAttribute]
private PoolEntry[] myPool;
    public FixedSizeObjectPool`1(int maxObjects, CreateObjectDelegate<T> creator, AllocObjectDelegate<T> allocator, DisposeObjectDelegate<T> disposer);
    public T Alloc();
    public void Dispose(T obj);
}
public class JetBrains.Common.Util.FormattedText.BackgroundColor : EnumPattern {
    public BackgroundColor(string name);
}
public static class JetBrains.Common.Util.FormattedText.BackgroundColors : object {
    public static BackgroundColor Transparent;
    public static BackgroundColor Highlight;
    private static BackgroundColors();
}
public class JetBrains.Common.Util.FormattedText.ForegroundColor : EnumPattern {
    public ForegroundColor(string name);
}
public static class JetBrains.Common.Util.FormattedText.ForegroundColors : object {
    public static ForegroundColor Default;
    public static ForegroundColor Grayed;
    public static ForegroundColor System;
    public static ForegroundColor Keyword;
    public static ForegroundColor Highlight;
    public static ForegroundColor Emphasized;
    public static ForegroundColor Hyperlink;
    private static ForegroundColors();
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Common.Util.FormattedText.FormattedText : object {
    private IList`1<FormattedTextPart> myParts;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    public int Count { get; }
    public FormattedTextPart Item { get; }
    public IEnumerable`1<FormattedTextPart> Parts { get; }
    public FormattedText(IEnumerable`1<FormattedTextPart> parts);
    public FormattedText(FormattedTextPart[] parts);
    private FormattedText(IList`1<FormattedTextPart> parts);
    public FormattedText(String[] parts);
    public void Prepend(string text);
    public void Append(string text);
    public void Prepend(string text, TextFormatting formatting);
    public void Append(string text, TextFormatting formatting);
    public void Prepend(FormattedTextPart part);
    public void Append(FormattedTextPart part);
    public void Clear();
    public int get_Count();
    public FormattedTextPart get_Item(int index);
    public IEnumerable`1<FormattedTextPart> get_Parts();
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    public virtual string ToString();
    public FormattedText Clone();
    public static FormattedText Wrap(IList`1<FormattedTextPart> parts);
}
public class JetBrains.Common.Util.FormattedText.FormattedTextBuffer : ValueType {
    public Char[] Buffer;
    public List`1<TextFormatting> Format;
    public int Length { get; }
    public FormattedTextBuffer(Char[] buffer, List`1<TextFormatting> format);
    public int get_Length();
}
public abstract class JetBrains.Common.Util.FormattedText.FormattedTextBufferBuilder`1 : object {
    private bool myCollapseWhitespaces;
    private bool myLastSymbolIsSpace;
    private List`1<TextFormatting> myFormat;
    private StringBuilder myBuilder;
    private Char[] myBuffer;
    public IList`1<TextFormatting> LastFormat { get; }
    protected FormattedTextBufferBuilder`1(bool collapseWhitespaces);
    protected abstract virtual void Build(T data);
    public IList`1<TextFormatting> get_LastFormat();
    public FormattedTextBuffer GetBuffer(T data);
    protected void Clear();
    protected string GetString();
    protected void Add(string str, int start, int length, TextFormatting formatting);
    protected void Add(string str, TextFormatting formatting);
    protected void AddFilename(string str, TextFormatting formatting);
    private int AppendToBuilder(string str);
    private int AppendToBuilderCollapseWhitespaces(string str);
}
public class JetBrains.Common.Util.FormattedText.FormattedTextBuilder : object {
    private List`1<TextFormatting> myFormat;
    private StringBuilder myBuilder;
    public int Length { get; }
    public FormattedTextBuilder(string str);
    public FormattedTextBuilder(StringBuilder builder, List`1<TextFormatting> format);
    public FormattedTextBuilder Add(string str, int start, int length, TextFormatting formatting);
    public FormattedTextBuilder Insert(int index, string str, TextFormatting formatting);
    public FormattedTextBuilder Add(string str, TextFormatting formatting);
    public void Clear();
    public FormattedTextBuilder AddFormatting(int index, TextFormatting formatting);
    public FormattedText ToFormattedText();
    public virtual string ToString();
    public int get_Length();
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.FormattedText.FormattedTextBuilderEx : object {
    [ExtensionAttribute]
public static FormattedTextBuilder AddFormatting(FormattedTextBuilder builder, Int32[] indices, TextFormatting format);
    [ExtensionAttribute]
public static FormattedTextBuilder AddFormatting(FormattedTextBuilder builder, IReadOnlyList`1<int> indices, TextFormatting format);
    [ExtensionAttribute]
public static FormattedTextBuilder AddFormatting(FormattedTextBuilder builder, TextFormatting format);
}
public class JetBrains.Common.Util.FormattedText.FormattedTextPart : object {
    public string Text;
    public TextFormatting Formatting;
    public FormattedTextPart(string text, TextFormatting formatting);
    public static FormattedTextPart op_Implicit(string text);
    public static FormattedTextPart Bold(string text);
    public static FormattedTextPart Grayed(string text);
    public static FormattedTextPart Emphasised(string text);
    public static FormattedTextPart Italic(string text);
    public static FormattedTextPart NewLine();
    public virtual string ToString();
}
public class JetBrains.Common.Util.FormattedText.FormattedTextVM : AAutomation {
    [CompilerGeneratedAttribute]
private FormattedText <Text>k__BackingField;
    public FormattedText Text { get; }
    public FormattedTextVM(FormattedText text);
    [CompilerGeneratedAttribute]
public FormattedText get_Text();
    public virtual string ToString();
}
public class JetBrains.Common.Util.FormattedText.FormattedURL : FormattedTextPart {
    [CompilerGeneratedAttribute]
private ICommand <ClickCommand>k__BackingField;
    public ICommand ClickCommand { get; private set; }
    public FormattedURL(string text, ICommand clickCommand);
    [CompilerGeneratedAttribute]
public ICommand get_ClickCommand();
    [CompilerGeneratedAttribute]
private void set_ClickCommand(ICommand value);
}
public class JetBrains.Common.Util.FormattedText.SelectableFormattedTextVM : AAutomation {
    [CompilerGeneratedAttribute]
private FormattedText <Text>k__BackingField;
    public FormattedText Text { get; }
    public SelectableFormattedTextVM(FormattedText text);
    [CompilerGeneratedAttribute]
public FormattedText get_Text();
}
public class JetBrains.Common.Util.FormattedText.TextFormatting : ValueType {
    public TextFormattingFlags Flags;
    private TextFormattingWeight myFontWeight;
    public ForegroundColor Foreground;
    public BackgroundColor Background;
    public static TextFormatting None;
    public static TextFormatting Bold;
    public static TextFormatting SemiBold;
    public static TextFormatting Italic;
    public static TextFormatting Grayed;
    public static TextFormatting Highlighted;
    public static TextFormatting Keyword;
    public static TextFormatting Emphasised;
    public TextFormattingWeight FontWeight { get; }
    public bool IsItalic { get; }
    public TextFormatting(TextFormattingFlags flags, ForegroundColor foreground, BackgroundColor background, TextFormattingWeight fontWeight);
    public TextFormatting(ForegroundColor foreground, BackgroundColor background);
    private static TextFormatting();
    [IsReadOnlyAttribute]
public TextFormattingWeight get_FontWeight();
    public bool get_IsItalic();
    public static TextFormatting op_BitwiseOr(TextFormatting f1, TextFormatting f2);
    public TextFormatting Merge(TextFormatting overridenFormatting);
    private TextFormattingWeight MergeFontWeights(TextFormatting overridenFormatting);
    public sealed virtual bool Equals(TextFormatting other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(TextFormatting left, TextFormatting right);
    public static bool op_Inequality(TextFormatting left, TextFormatting right);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.FormattedText.TextFormattingEx : object {
    [ExtensionAttribute]
public static bool IsHighlighted(TextFormatting formatting);
    [ExtensionAttribute]
public static bool IsKeyword(TextFormatting formatting);
    [ExtensionAttribute]
public static bool IsSystem(TextFormatting formatting);
}
[FlagsAttribute]
public enum JetBrains.Common.Util.FormattedText.TextFormattingFlags : Enum {
    public ushort value__;
    public static TextFormattingFlags None;
    public static TextFormattingFlags Italic;
}
public enum JetBrains.Common.Util.FormattedText.TextFormattingWeight : Enum {
    public ushort value__;
    public static TextFormattingWeight Normal;
    public static TextFormattingWeight SemiBold;
    public static TextFormattingWeight Bold;
}
[ContentPropertyAttribute("Formatters")]
public class JetBrains.Common.Util.Formatting.FormatProvider : object {
    [CompilerGeneratedAttribute]
private Collection`1<ITypedCustomFormatter> <Formatters>k__BackingField;
    private IDictionary`2<Type, ITypedCustomFormatter> myFormatters;
    public Collection`1<ITypedCustomFormatter> Formatters { get; public set; }
    public FormatProvider(ITypedCustomFormatter[] formatters);
    [CompilerGeneratedAttribute]
public Collection`1<ITypedCustomFormatter> get_Formatters();
    [CompilerGeneratedAttribute]
public void set_Formatters(Collection`1<ITypedCustomFormatter> value);
    public sealed virtual object GetFormat(Type formatType);
    public sealed virtual void BeginInit();
    public sealed virtual void EndInit();
    public sealed virtual object Convert(object value, Type targetType, object parameter, CultureInfo culture);
    public sealed virtual object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture);
}
public interface JetBrains.Common.Util.Formatting.ITypedCustomFormatter {
    public Type FormattableType { get; }
    public abstract virtual Type get_FormattableType();
}
public class JetBrains.Common.Util.Formatting.TimeFormatter : object {
    private static Dictionary`2<TimeUnits, string> ourLabels;
    public Type FormattableType { get; }
    private static TimeFormatter();
    private static string GetTimePartLabel(TimeUnits timeUnit);
    public static TimeUnits GetUnitsFromLabel(string unit);
    public sealed virtual string Format(string format, object arg, IFormatProvider formatProvider);
    public sealed virtual Type get_FormattableType();
}
public class JetBrains.Common.Util.FullLifetime : object {
    private Lifetime myControlLifetime;
    private Lifetime myRuntimeLifetime;
    private PersistenceLifetime myPersistenceLifetime;
    internal Lifetime ControlLifetime { get; }
    public PersistenceLifetime PersistenceLifetime { get; }
    public Lifetime RuntimeLifetime { get; }
    internal FullLifetime(Lifetime runtimeLifetime, PersistenceLifetime persistenceLifetime, Lifetime controlLifetime);
    internal Lifetime get_ControlLifetime();
    public PersistenceLifetime get_PersistenceLifetime();
    public Lifetime get_RuntimeLifetime();
}
public class JetBrains.Common.Util.FullLifetimeDefinition : object {
    [LocalizableAttribute("False")]
private static string ourLifetimeIdPrefix;
    private LifetimeDefinition myLifetimeDefinition;
    private FullLifetime myFullLifetime;
    private LifetimeDefinition myRuntimeLifetimeDefinition;
    public FullLifetime FullLifetime { get; }
    internal FullLifetimeDefinition(FullLifetime parentFullLifetime, string id);
    internal FullLifetimeDefinition(Lifetime parentRuntimeLifetime, string id);
    private static FullLifetimeDefinition();
    public FullLifetime get_FullLifetime();
    public void TerminateFull();
    public void TerminateRuntime();
    [CompilerGeneratedAttribute]
private void <.ctor>b__4_0();
    [CompilerGeneratedAttribute]
private void <.ctor>b__5_0();
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.FullLifetimeExtension : object {
    [ExtensionAttribute]
public static FullLifetimeDefinition CreateSubLifetimeDefinition(FullLifetime fullLifetime, string id);
    [ExtensionAttribute]
public static FullLifetimeDefinition CreateFullLifetimeDefinition(Lifetime runtimeLifetimeParent, string id);
    [ExtensionAttribute]
public static FullLifetimeDefinition CreateSubLifetimeDefinition(FullLifetime fullLifetime, Lifetime additionalRestriction, string id);
    [ExtensionAttribute]
public static FullLifetime CreateIntersection(FullLifetime fullLifetime, string id, FullLifetime other);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.FuncAccessor : object {
    public static IAccessor`1<T> Create(Func`2<Lifetime, T> getter);
    [ExtensionAttribute]
public static IAccessor`1<T> AsAccessor(T value);
    [ExtensionAttribute]
public static IAccessor`1<TB> TransformAccessor(IAccessor`1<TA> accessor, Func`3<TA, Lifetime, TB> converter);
    [ExtensionAttribute]
public static IAccessor`1<TB> TransformAccessor(IAccessor`1<TA> accessor, Func`2<TA, TB> converter);
    [ExtensionAttribute]
public static IAccessor`1<TB> TransformAccessorSafe(IAccessor`1<TA> accessor, Func`2<TA, TB> converter);
}
public class JetBrains.Common.Util.FuncAccessor`1 : object {
    private Func`2<Lifetime, T> myGetter;
    [ObsoleteAttribute("Use FuncAccessor.Create helper to deduct generic type.")]
public FuncAccessor`1(Func`2<Lifetime, T> getter);
    public sealed virtual T Get(Lifetime lifetime);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.FuncExtensions : object {
    [ExtensionAttribute]
public static Func`2<TA, TC> ApplyPartially(Func`3<TA, TB, TC> src, TB arg);
}
public class JetBrains.Common.Util.GetTopItemsVisitor`1 : object {
    private T myNullValue;
    private IComparer`1<T> myComparer;
    private T[] myTopItems;
    private T myCurrentBottomItem;
    public T[] TopItems { get; }
    public GetTopItemsVisitor`1(int topItemsCount, T nullValue);
    public GetTopItemsVisitor`1(int topItemsCount, IComparer`1<T> comparer, T nullValue);
    public void Visit(T visitItem);
    public T[] get_TopItems();
    [CompilerGeneratedAttribute]
private bool <get_TopItems>b__8_0(T _);
}
public interface JetBrains.Common.Util.IAccessor`1 {
    public abstract virtual T Get(Lifetime lifetime);
}
public interface JetBrains.Common.Util.IAccessorProvider`1 {
}
public interface JetBrains.Common.Util.IAccessorProviderContainer`1 {
}
public interface JetBrains.Common.Util.IAsyncOperation {
    public string Title { get; }
    public int OperationProgress { get; }
    public IEnumerable`1<IAsyncOperation> SubOperations { get; }
    public bool Completed { get; }
    public Exception Exception { get; }
    public bool CanCancel { get; }
    public bool IsCanceled { get; }
    public abstract virtual string get_Title();
    public abstract virtual int get_OperationProgress();
    [CompilerGeneratedAttribute]
public abstract virtual void add_OperationProgressChanged(EventHandler`2<IAsyncOperation, ProgressChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_OperationProgressChanged(EventHandler`2<IAsyncOperation, ProgressChangedEventArgs> value);
    public abstract virtual IEnumerable`1<IAsyncOperation> get_SubOperations();
    public abstract virtual bool get_Completed();
    [CompilerGeneratedAttribute]
public abstract virtual void add_Finished(EventHandler`2<ITask, EventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Finished(EventHandler`2<ITask, EventArgs> value);
    public abstract virtual Exception get_Exception();
    public abstract virtual bool get_CanCancel();
    public abstract virtual void Cancel();
    public abstract virtual bool get_IsCanceled();
}
public interface JetBrains.Common.Util.IAsyncOperation`1 {
    public abstract virtual TResult GetResult();
}
public interface JetBrains.Common.Util.IBackgroundProgressPresenter {
}
public interface JetBrains.Common.Util.IBinaryHeap`1 {
    public int Count { get; }
    public T Top { get; }
    public Comparison`1<T> Comparison { get; }
    public abstract virtual int get_Count();
    public abstract virtual T get_Top();
    public abstract virtual T Pop();
    public abstract virtual void Push(T value);
    public abstract virtual Comparison`1<T> get_Comparison();
}
public interface JetBrains.Common.Util.ICacheProviderContainer`1 {
}
public interface JetBrains.Common.Util.ICacheSource`1 {
}
public interface JetBrains.Common.Util.ICacheVersion {
    public long Version { get; }
    public abstract virtual long get_Version();
}
public interface JetBrains.Common.Util.ICollectionSynchronizer {
    public abstract virtual void StartSynchronizing();
    public abstract virtual void StopSynchronizing();
}
public interface JetBrains.Common.Util.ICommandContainer {
    public ICommand Value { get; }
    public abstract virtual ICommand get_Value();
}
public interface JetBrains.Common.Util.IContextBoundSettingsFileLive {
    public IProperty`1<FileSystemPath> FilePath { get; }
    public abstract virtual IProperty`1<FileSystemPath> get_FilePath();
    public abstract virtual void Flush();
}
public interface JetBrains.Common.Util.IDataContainer`1 {
    public T Data { get; }
    public abstract virtual T get_Data();
}
[DefaultMemberAttribute("Item")]
public interface JetBrains.Common.Util.IDataMapper`2 {
    public TOut Item { get; }
    public abstract virtual TOut get_Item(TIn value);
}
public interface JetBrains.Common.Util.IExecutionController {
    public int RecommendedParallelizmDegree { get; }
    [NotNullAttribute]
public abstract virtual IExecutionController StartProgress(int stepsCount, string operationName);
    [NotNullAttribute]
public abstract virtual IExecutionController CreateSubOperation(int parentStepsCount);
    [NotNullAttribute]
public abstract virtual IExecutionController AttachSubOperation(Task task, int parentStepsCount);
    public abstract virtual void AdvanceProgress();
    public abstract virtual void Yield();
    public abstract virtual void Wait(IWaitable waitable, TimeSpan timeout);
    [NotNullAttribute]
public abstract virtual Task`1<T> Fork(Func`2<IExecutionController, T> action);
    public abstract virtual int get_RecommendedParallelizmDegree();
}
[ObsoleteAttribute("It is recommended to migrate to new IExecutionController")]
public interface JetBrains.Common.Util.IExecutionControllerOld {
    public abstract virtual IExecutionControllerOld StartProgress(int stepsCount, string operationName);
    public abstract virtual IExecutionControllerOld CreateSubOperation(int parentStepsCount);
    public abstract virtual void AdvanceProgress();
}
public interface JetBrains.Common.Util.IForegroundProgressPresenter {
    public abstract virtual void InjectProgressIndicator(Lifetime lifetime, IProgressIndicator progress);
}
public interface JetBrains.Common.Util.IIndexedKey`1 {
    public abstract virtual T GetIndex();
    public abstract virtual void Delete();
}
public interface JetBrains.Common.Util.IKey`1 {
}
public interface JetBrains.Common.Util.IKeyBase`1 {
    public abstract virtual IProperty`1<TProperty> GetProperty(Expression`1<Func`2<TKey, TProperty>> lambda, Lifetime lifetime);
    public abstract virtual void ResetValue(Expression`1<Func`2<TKey, TProperty>> lambda);
    public abstract virtual void SetEntry(TKey key);
    public abstract virtual TKey GetEntry();
    public abstract virtual void SetIndexedValue(Expression`1<Func`2<TKey, IIndexedEntry`2<TEntryIndex, TEntryValue>>> lambda, TEntryIndex entryIndex, TEntryValue value);
    public abstract virtual TEntryValue GetIndexedValue(Expression`1<Func`2<TKey, IIndexedEntry`2<TEntryIndex, TEntryValue>>> lambda, TEntryIndex entryIndex);
    public abstract virtual IEnumerable`1<Pair`2<TEntryIndex, TEntryValue>> EnumerateIndexedValues(Expression`1<Func`2<TKey, IIndexedEntry`2<TEntryIndex, TEntryValue>>> lambda);
    public abstract virtual void RemoveIndexedValue(Expression`1<Func`2<TKey, IIndexedEntry`2<TEntryIndex, TEntryValue>>> lambda, TEntryIndex entryIndex);
}
[ObsoleteAttribute]
public interface JetBrains.Common.Util.ILightExecutionController {
    public abstract virtual void Yield();
}
public interface JetBrains.Common.Util.ILog {
    public abstract virtual void Catch(Action action);
    public abstract virtual T Catch(Func`1<T> func);
    public abstract virtual void LogExceptionSilently(Exception ex);
    public abstract virtual void LogMessage(string message);
    public abstract virtual void LogException(Exception ex);
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Common.Util.IndexableWrapper`1 : ValueType {
    private IList`1<T> myArray;
    public int Count { get; }
    public T Item { get; public set; }
    public IndexableWrapper`1(IList`1<T> array);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual int get_Count();
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
}
public static class JetBrains.Common.Util.Interop.MemoryCopier : object {
    public static void CopyMemory(IntPtr dest, IntPtr src, UInt32 count);
    public static void CopyMemoryUnsafe(Byte* dest, Byte* src, UInt32 count);
}
public static class JetBrains.Common.Util.Interop.NuGetRuntimes : object {
    [LocalizableAttribute("False")]
public static RelativePath Location { get; }
    public static RelativePath NativeLocation { get; }
    public static RelativePath get_Location();
    public static RelativePath get_NativeLocation();
    public static RelativePath GetLocation(JetRuntimeId runtimeId);
    public static RelativePath GetNativeLocation(JetRuntimeId runtimeId);
}
public static class JetBrains.Common.Util.Interop.OsHelpers : object {
    public static string GetOsDisplayName();
    [CanBeNullAttribute]
public static string GetCallerModuleName();
    private static string GetCallerModuleNameWindows();
    private static string GetCallerModuleNameMacLinux();
}
public static class JetBrains.Common.Util.InterruptibleLazy : object {
    public static InterruptibleLazy`1<T> Of(Func`2<IExecutionController, T> valueFactory);
}
public class JetBrains.Common.Util.InterruptibleLazy`1 : object {
    [CanBeNullAttribute]
private Func`2<IExecutionController, T> myValueFactory;
    private SpinWaitLock myLock;
    private T myValue;
    public InterruptibleLazy`1(Func`2<IExecutionController, T> valueFactory);
    public T GetValue(IExecutionController controller);
    [LocalizableAttribute("False")]
public virtual string ToString();
}
public class JetBrains.Common.Util.Interval : ValueType {
    [CompilerGeneratedAttribute]
private UInt32 <Position>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Length>k__BackingField;
    public UInt32 Position { get; public set; }
    public UInt32 Length { get; public set; }
    public Interval(UInt32 position, UInt32 length);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_Position();
    [CompilerGeneratedAttribute]
public void set_Position(UInt32 value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_Length();
    [CompilerGeneratedAttribute]
public void set_Length(UInt32 value);
    public sealed virtual bool Equals(Interval other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(Interval left, Interval right);
    public static bool op_Inequality(Interval left, Interval right);
    [LocalizableAttribute("False")]
public virtual string ToString();
}
public interface JetBrains.Common.Util.IObservableSet`1 {
    public IDataProvider`1<IReadOnlyCollection`1<T>> Provider { get; }
    [CompilerGeneratedAttribute]
public abstract virtual void add_Changed(EventHandler`1<NotifySetChangedEventArgs`1<T>> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Changed(EventHandler`1<NotifySetChangedEventArgs`1<T>> value);
    public abstract virtual IDataProvider`1<IReadOnlyCollection`1<T>> get_Provider();
    public abstract virtual bool SetEquals(IEnumerable`1<T> other);
}
public interface JetBrains.Common.Util.IProgressPresenter {
    public abstract virtual void ShowOperationProgress(IAsyncOperation asyncOperation);
}
public interface JetBrains.Common.Util.IProviderContainer`1 {
}
public interface JetBrains.Common.Util.IProxyContainer`1 {
    unknown IDataProvider`1<T> Source {public set; }
    public abstract virtual void set_Source(IDataProvider`1<T> value);
}
public interface JetBrains.Common.Util.IReadOnlyMapping`2 {
}
public interface JetBrains.Common.Util.IRemotablePairContainer`1 {
}
public interface JetBrains.Common.Util.IRemotableReferenceContainer`1 {
}
public interface JetBrains.Common.Util.IRemoteProviderContainer`1 {
}
public interface JetBrains.Common.Util.ISearchable`1 {
    public abstract virtual int IndexOf(T item);
}
[ObsoleteAttribute("It is recommended to migrate to ISequentalTaskScheduler and System.Tasks")]
public interface JetBrains.Common.Util.ISequentialTaskExecutor {
    public bool HasRunningTask { get; }
    public abstract virtual bool get_HasRunningTask();
    public abstract virtual bool ExecuteExclusively(ITask task, bool cancelRunningTask);
    public abstract virtual void Enqueue(ITask task);
    public abstract virtual bool CancelAllTasks(bool cancelRunningTask);
}
public interface JetBrains.Common.Util.ISettings {
    public abstract virtual void CreateIndexedKey(Type settingKeyType, object indexKey, IDictionary`2<Type, object> parentIndex);
    public abstract virtual void DeleteIndexedKey(Type settingKeyType, object indexKey, IDictionary`2<Type, object> parentIndex);
    public abstract virtual void SetKey(Type settingKeyType, object value, object indexKey, IDictionary`2<Type, object> parentIndexKeys);
    public abstract virtual object GetKey(Type settingKeyType, object indexKey, IDictionary`2<Type, object> parentIndexKeys);
    public abstract virtual void ResetValue(Expression`1<Func`2<TKey, TProperty>> lambda, object indexKey);
    public abstract virtual IProperty`1<TProperty> GetProperty(Expression`1<Func`2<TKey, TProperty>> lambda, object indexKey, Lifetime lifetime, IDictionary`2<Type, object> parentIndexKeys);
    public abstract virtual TEntryValue GetIndexedValue(Expression`1<Func`2<TKey, IIndexedEntry`2<TEntryIndex, TEntryValue>>> lambda, TEntryIndex entryIndex, object indexKey, IDictionary`2<Type, object> parentIndexKeys);
    public abstract virtual void SetIndexedValue(Expression`1<Func`2<TKey, IIndexedEntry`2<TEntryIndex, TEntryValue>>> lambda, TEntryIndex entryIndex, TEntryValue value, object indexKey, IDictionary`2<Type, object> parentIndexKeys);
    public abstract virtual void RemoveIndexedValue(Expression`1<Func`2<TKey, IIndexedEntry`2<TEntryIndex, TEntryValue>>> lambda, TEntryIndex entryIndex, object indexKey, IDictionary`2<Type, object> parentIndexKeys);
    public abstract virtual IEnumerable`1<Pair`2<TEntryIndex, TEntryValue>> EnumerateIndexedValues(Expression`1<Func`2<TKey, IIndexedEntry`2<TEntryIndex, TEntryValue>>> lambda, object indexKey, IDictionary`2<Type, object> parentIndexKeys);
    public abstract virtual IEnumerable`1<object> EnumKeyIndices(Type settingKeyType, IDictionary`2<Type, object> parentIndexKeys);
    public abstract virtual IEnumerable`1<Pair`2<object, object>> EnumerateIndexedKeys(Type settingKeyType, IDictionary`2<Type, object> parentIndexKeys, bool ignoreKeyIsDefined);
    public abstract virtual void AdviseChange(Action callback, Type settingKeyType, Lifetime lifetime);
    public abstract virtual void AdviseChange(Expression`1<Func`2<TKey, TValue>> lambdaexpression, Action callback, Lifetime lifetime);
}
public interface JetBrains.Common.Util.ISettingsFile {
    public IProperty`1<FileSystemPath> SettingsFilePath { get; }
    public abstract virtual IProperty`1<FileSystemPath> get_SettingsFilePath();
    public abstract virtual void Flush();
}
public interface JetBrains.Common.Util.ITask {
    public EventWaitHandle FinishedEvent { get; }
    public abstract virtual void Execute(ITaskExecutionEnvironment environment);
    public abstract virtual EventWaitHandle get_FinishedEvent();
}
public interface JetBrains.Common.Util.ITask`1 {
}
public interface JetBrains.Common.Util.ITaskExecutionEnvironment {
    public abstract virtual void Cancel(ITask sender);
    public abstract virtual void Yield(ITask sender);
    public abstract virtual void WaitForTask(ITask sender, ITask otherTask, bool isShared);
    public abstract virtual void AttachTask(ITask sender, ITask otherTask, bool isShared);
}
public interface JetBrains.Common.Util.ITryFillArray`2 {
    public abstract virtual bool TryFillArray(TKey key, ArrayBuffer`1<TValue> buffer);
}
public interface JetBrains.Common.Util.ITryGetValue`2 {
    public abstract virtual bool TryGetValue(TKey key, TValue& value);
}
public interface JetBrains.Common.Util.ITwoStepDisposable {
    public abstract virtual void PrepareForDispose();
    public abstract virtual void Dispose();
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Common.Util.JetBitArray : object {
    private ChunkArray`1<int> myArray;
    private static int ElementSize;
    private int myElementSizeLog2;
    private int myIndexInElementMask;
    private int myArrayLength;
    public int Length { get; }
    public bool Item { get; public set; }
    public JetBitArray(int bitArrayLength);
    public JetBitArray(IList`1<bool> boolArray);
    public int get_Length();
    public bool get_Item(int index);
    public void set_Item(int index, bool value);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.JetCollectionExtensions : object {
    [ExtensionAttribute]
public static IReadOnlyCollection`1<T> AsReadonlyCollection(ICollection`1<T> collection);
    [ExtensionAttribute]
public static IReadOnlyCollection`1<T> AsReadonlyCollection(IEnumerable`1<T> sequence, int count);
    [ExtensionAttribute]
public static IReadOnlyList`1<T> AsReadonlyList(IList`1<T> list);
    [ExtensionAttribute]
public static IReadOnlyList`1<T> ToReadonlyList(IEnumerable`1<T> sequence);
    [ExtensionAttribute]
public static JetList`1<T> ToJetList(IEnumerable`1<T> enumerable);
}
public class JetBrains.Common.Util.JetList`1 : List`1<T> {
    public JetList`1(int capacity);
    public JetList`1(IEnumerable`1<T> collection);
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Common.Util.JetReadOnlyDictionary`2 : object {
    [NotNullAttribute]
private IDictionary`2<TKey, TValue> mySource;
    [CanBeNullAttribute]
private ReadOnlyCollectionWrapper`1<TKey> myKeys;
    public int Count { get; }
    public TValue Item { get; }
    public IReadOnlyCollection`1<TKey> Keys { get; }
    [NotNullAttribute]
public IEnumerable`1<TValue> Values { get; }
    private IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Keys { get; }
    public JetReadOnlyDictionary`2(IDictionary`2<TKey, TValue> source);
    public sealed virtual int get_Count();
    public sealed virtual TValue get_Item(TKey key);
    public IReadOnlyCollection`1<TKey> get_Keys();
    public sealed virtual IEnumerable`1<TValue> get_Values();
    public sealed virtual bool ContainsKey(TKey key);
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    public TValue GetValueSafe(TKey key, TValue fallbackValue);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Keys();
}
public static class JetBrains.Common.Util.JetThread : object {
    public static bool VolatileRead(Boolean& address);
    public static void VolatileWrite(Boolean& address, bool value);
    public static T VolatileRead(T& address);
    public static void VolatileWrite(T& address, T value);
}
public class JetBrains.Common.Util.LCSResult : ValueType {
    public Pair`2<int, int> MatchIndicies;
    public int Length;
    public LCSResult(int length, Pair`2<int, int> matchIndicies);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.LifetimeExtensions : object {
    [ExtensionAttribute]
public static Lifetime CreateLifetime(IAsyncOperation operation, IThreading threading, Lifetime parentLifetime);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.LifetimesExtension : object {
    private static ILogger Logger;
    private static LifetimesExtension();
    [ExtensionAttribute]
public static LifetimeDefinition CreateSubLifetimeDefinition(Lifetime lifetime, string id, Lifetime[] additionalRestrictions);
    [ExtensionAttribute]
public static LifetimeDefinition CreateSubLifetimeDefinition(Lifetime lifetime, string id);
    [ExtensionAttribute]
public static Lifetime CreateSubLifetime(Lifetime lifetime, string id);
    [ExtensionAttribute]
public static Lifetime CreateSubLifetime(Lifetime lifetime, string id, Lifetime[] additionalRestrictions);
    [ExtensionAttribute]
public static T CreateDisposable(Lifetime lifetime, Func`1<T> createDisposable);
    [ExtensionAttribute]
public static T AddBracket(Lifetime lifetime, Func`1<T> openBracket, Action`1<T> closeBracket);
    [ConditionalAttribute("JET_MODE_ASSERT")]
public static void ReportCreated(string id);
    [ExtensionAttribute]
[ConditionalAttribute("JET_MODE_ASSERT")]
public static void ReportTerminated(Lifetime lifetime, string id);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.ListAddRemoveUtil : object {
    public static void AddConditioned(T item, Action`1<Action`1<IList`1<T>>> changeCollection, Lifetime lifetime, IDataProvider`1<bool> isIncluded, bool addToHead);
    [ExtensionAttribute]
public static void AddConditioned(IList`1<T> list, T item, Lifetime lifetime, IDataProvider`1<bool> isIncluded, bool addToHead);
    [ExtensionAttribute]
public static void InsertRange(IList`1<T> list, int index, IEnumerable`1<T> items);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.ListEventsExtensions : object {
    [ExtensionAttribute]
public static void FlowIntoSorted(ICollectionEvents`1<TSource> source, Lifetime lifetime, IListEvents`1<TTarget> target, IComparer`1<TSource> comparer, Func`3<Lifetime, TSource, TTarget> converter);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.ListExtenstions : object {
    [ExtensionAttribute]
public static void AddAndResize(IList`1<T> list, int index, T element, T defaultValue);
    [ExtensionAttribute]
public static bool RemoveIfContains(IList`1<T> list, T element);
    [ExtensionAttribute]
public static IEnumerable`1<T> Slice(IList`1<T> source, CollectionRange range);
    [IteratorStateMachineAttribute("JetBrains.Common.Util.ListExtenstions/<FindSequentialRanges>d__3`1")]
[ExtensionAttribute]
public static IEnumerable`1<CollectionRange> FindSequentialRanges(IList`1<T> source, Func`3<T, T, bool> cmp);
    [ExtensionAttribute]
public static IEnumerable`1<IEnumerable`1<T>> GroupSameSequential(IList`1<T> source, Func`3<T, T, bool> cmp);
    [ExtensionAttribute]
public static IList`1<T> CopyAndAdd(IList`1<T> source, T[] elements);
}
public static class JetBrains.Common.Util.Logging.LoggingInitializer : object {
    public static string LogFileKey;
    public static string LogLevelKey;
    public static string LogTraceKey;
    public static void Initialize(ICommandLine commandLine, LoggingLevel defaultLogLevel, bool enablePostmortem, String[] verboseCategories, String[] traceCategories);
    public static void Initialize(Lifetime lifetime, LoggingLevel defaultLogLevel, bool enablePostmortem, FileSystemPath logFile, string logLevel, String[] verboseCategories, string traceCategoriesString);
    public static void Initialize(Lifetime lifetime, FileSystemPath logFile, LoggingLevel logLevel, bool enablePostmortem, String[] verboseCategories, String[] traceCategories);
}
public class JetBrains.Common.Util.Logging.UnderInvestigationException : Exception {
    public UnderInvestigationException(Exception originalException, string issueId);
    public UnderInvestigationException(string message, string issueId);
    public UnderInvestigationException(SerializationInfo info, StreamingContext context);
}
public static class JetBrains.Common.Util.LongestCommonSubsequence : object {
    public static LCSResult Calculate(IList`1<T> a, IList`1<T> b, IEqualityComparer`1<T> comparer);
    private static LCSResult CalculateImpl(int startIndex, IList`1<T> a, int aEnd, IList`1<T> b, int bEnd, IEqualityComparer`1<T> comparer);
}
public static class JetBrains.Common.Util.MathConverterParser : object {
    private static Dictionary`2<string, IExpression> ourStoredExpressions;
    private static MathConverterParser();
    public static IExpression Parse(string s);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.MathExtension : object {
    [ExtensionAttribute]
public static int DivUp(int a, int b);
    [ExtensionAttribute]
public static UInt32 DivUp(UInt32 a, UInt32 b);
    [ExtensionAttribute]
public static long DivUp(long a, long b);
    [ExtensionAttribute]
public static ulong DivUp(ulong a, ulong b);
}
public static class JetBrains.Common.Util.MathUtils : object {
    public static byte Log2(ulong value);
    public static int SafeCast(double value);
    public static int SafeRound(double value);
    public static int GetDigits(double value);
}
public class JetBrains.Common.Util.Maybe`1 : ValueType {
    public static Maybe`1<T> Nothing;
    private T myValue;
    private bool myHasValue;
    public T Value { get; }
    public bool HasValue { get; }
    public Maybe`1(T value);
    private static Maybe`1();
    public T get_Value();
    public bool get_HasValue();
    public sealed virtual bool Equals(Maybe`1<T> other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [LocalizableAttribute("False")]
public virtual string ToString();
    public static T op_Explicit(Maybe`1<T> t);
    public static Maybe`1<T> op_Implicit(T t);
    public static bool op_Equality(Maybe`1<T> v1, Maybe`1<T> v2);
    public static bool op_Inequality(Maybe`1<T> v1, Maybe`1<T> v2);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.MaybeExtensions : object {
    [ExtensionAttribute]
public static T ValueOrDefault(Maybe`1<T> maybe);
    [ExtensionAttribute]
public static Maybe`1<T> ToMaybe(T value);
    [ExtensionAttribute]
[ContractAnnotationAttribute("null=>true")]
public static bool IsEmpty(Maybe`1<T> maybe);
}
public class JetBrains.Common.Util.Metadata.FunctionId : ValueType {
    private UInt32 myValue;
    private FunctionId(UInt32 value);
    public static FunctionId Create(UInt32 id);
    public static FunctionId Create(string value);
    public static UInt32 op_Explicit(FunctionId value);
    public static FunctionId op_Explicit(UInt32 value);
    public static bool op_Equality(FunctionId op1, FunctionId op2);
    public static bool op_Inequality(FunctionId op1, FunctionId op2);
    public sealed virtual bool Equals(FunctionId other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [LocalizableAttribute("False")]
public virtual string ToString();
}
public enum JetBrains.Common.Util.Metadata.FunctionType : Enum {
    public int value__;
    public static FunctionType Synthetic;
    public static FunctionType Core;
    public static FunctionType ETWManaged;
    public static FunctionType ETWNative;
    public static FunctionType ETWModuleOnly;
    public static FunctionType Address;
    public static FunctionType ETWCoreIndexed;
    public static FunctionType MatchWithCore;
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.Metadata.FunctionTypeEx : object {
    [ExtensionAttribute]
public static bool IsFunction(FunctionUID fuid);
    [ExtensionAttribute]
public static bool IsFunction(FunctionUIDm fuid);
    [ExtensionAttribute]
public static bool IsCoreRelated(FunctionType type);
    [ExtensionAttribute]
public static bool IsManaged(FunctionType type);
    [ExtensionAttribute]
public static bool ScopeAndMergeDisabled(FunctionUIDm fuid);
    [ExtensionAttribute]
public static bool ScopeAndMergeDisabled(FunctionUID fuid);
}
public class JetBrains.Common.Util.Metadata.FunctionUID : ValueType {
    private static int TotalBitsCount;
    private static int TypeBitsCount;
    public static int TypeOffset;
    public static ulong CoreFunctionUidMask;
    private static int ShiftBitsCount;
    private static int ShortIndexBitsCount;
    private static int ShiftOffset;
    private static ulong TypeMask;
    private static ulong LongIndexMask;
    private static ulong ShortIndexMask;
    private static int ETWSyntheticTypeBitsCount;
    private static int ETWSyntheticTypeOffset;
    private static ulong ETWSyntheticTypeMask;
    private static int SubsystemTypeBitsCount;
    private static int SubsystemTypeOffset;
    private static ulong SubsystemTypeMask;
    private static int GeneratedTypeBitsCount;
    private static int GeneratedTypeOffset;
    private static ulong GeneratedTypeMask;
    private static int SyntheticTypeBitsCount;
    private static ulong SyntheticIndexMask;
    private static ulong ShiftMask;
    public static FunctionUID Invalid;
    public static FunctionUID Unknown;
    public static FunctionUID Unresolved;
    public static FunctionUID NoCallStack;
    public static FunctionUID SkippedDynamic;
    public static FunctionUID Root;
    public static FunctionUID AllCalls;
    public static FunctionUID Continuation;
    public static FunctionUID Awaits;
    public static FunctionUID TaskScheduled;
    public static FunctionUID TaskExecution;
    public static FunctionUID TaskRecursion;
    public static FunctionUID StackTracesWithoutMethods;
    public static FunctionUID Native;
    public static FunctionUID ThreadStoppedByUnknownReason;
    public static FunctionUID Gc;
    public static FunctionUID AppDomainShutdown;
    public static FunctionUID CodePitching;
    public static FunctionUID UnmanagedStackFrame;
    public static FunctionUID UnsafeStackFrame;
    public static FunctionUID Uninitialized;
    private ulong myValue;
    public FunctionType Type { get; }
    public bool IsResolved { get; }
    public ulong Index { get; }
    public bool IsSynthetic { get; }
    public bool IsGloballyUnique { get; }
    public bool IsUserSynthetic { get; }
    private bool IsAsyncRelated { get; }
    private bool IsTaskRelated { get; }
    public bool IsAlwaysSystem { get; }
    public bool IsThreadRoot { get; }
    public bool IsAllCallsOrThreadRoot { get; }
    private FunctionUID(ulong value);
    private static FunctionUID();
    public FunctionType get_Type();
    public bool get_IsResolved();
    public UInt32 Shift();
    private ulong TypeBits();
    public ulong get_Index();
    private ulong IndexBits();
    public bool get_IsSynthetic();
    public bool get_IsGloballyUnique();
    private static bool IsSyntheticType(FunctionType type);
    public sealed virtual bool Equals(FunctionUID other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(FunctionUID left, FunctionUID right);
    public static bool op_Inequality(FunctionUID left, FunctionUID right);
    private ulong GetIndexMask();
    private static ulong GetIndexMask(FunctionType functionType);
    private static void ThrowInvalidFunctionTypeException(FunctionType functionType);
    public FunctionUID IgnoreShift();
    private ulong MeaningfulHeadBits();
    private ulong SyntheticTypeBits();
    public sealed virtual int CompareTo(FunctionUID other);
    [LocalizableAttribute("True")]
public virtual string ToString();
    public static FunctionUID Create(ulong key);
    public static FunctionUID CreateSynthetic(SyntheticType syntheticType);
    public static FunctionUID Create(FunctionType type, ulong index);
    public static FunctionUID Create(FunctionType type, ulong index, int shift);
    public static FunctionUID CreateSubsystem(ulong index);
    private static FunctionUID CreateSyntheticWithMask(ulong mask, ulong index);
    public static FunctionUID CreateGenerated(GeneratedType generatedType, ulong index, ulong mask);
    [PureAttribute]
public ulong AsUlong();
    public FunctionUID CopyShiftFrom(FunctionUID other);
    private ulong ShiftBits();
    public SyntheticType GetSyntheticType();
    public GeneratedType GetGeneratedType();
    [PureAttribute]
public Nullable`1<SubsystemEventType> GetSubsystemEventTypes();
    public bool get_IsUserSynthetic();
    private bool get_IsAsyncRelated();
    private bool get_IsTaskRelated();
    public bool get_IsAlwaysSystem();
    public bool get_IsThreadRoot();
    public bool get_IsAllCallsOrThreadRoot();
}
[DataContractAttribute]
public class JetBrains.Common.Util.Metadata.FunctionUIDm : ValueType {
    [DataMemberAttribute]
private ulong myValue;
    private static int TotalBitsCount;
    private static int TypeBitsCount;
    public static int TypeOffset;
    private static int ShiftBitsCount;
    private static int ShortIndexBitsCount;
    private static int ShiftOffset;
    private static ulong TypeMask;
    private static ulong LongIndexMask;
    private static ulong ShortIndexMask;
    private static int ETWSyntheticTypeBitsCount;
    private static int ETWSyntheticTypeOffset;
    private static ulong ETWSyntheticTypeMask;
    private static int SubsystemTypeBitsCount;
    private static int SubsystemTypeOffset;
    private static ulong SubsystemTypeMask;
    private static int GeneratedTypeBitsCount;
    private static int GeneratedTypeOffset;
    private static ulong GeneratedTypeMask;
    private static int SyntheticTypeBitsCount;
    private static ulong SyntheticIndexMask;
    private static ulong ShiftMask;
    public static FunctionUIDm Invalid;
    public static FunctionUIDm Unknown;
    public static FunctionUIDm Unresolved;
    public static FunctionUIDm NoCallStack;
    public static FunctionUIDm SkippedDynamic;
    public static FunctionUIDm Root;
    public static FunctionUIDm AllCalls;
    public static FunctionUIDm Continuation;
    public static FunctionUIDm Awaits;
    public static FunctionUIDm TaskScheduled;
    public static FunctionUIDm TaskExecution;
    public static FunctionUIDm TaskRecursion;
    public static FunctionUIDm StackTracesWithoutMethods;
    public static FunctionUIDm Native;
    public static FunctionUIDm ThreadStoppedByUnknownReason;
    public static FunctionUIDm Gc;
    public static FunctionUIDm AppDomainShutdown;
    public static FunctionUIDm CodePitching;
    public static FunctionUIDm UnmanagedStackFrame;
    public static FunctionUIDm UnsafeStackFrame;
    public static FunctionUIDm Uninitialized;
    public static FunctionUIDm MultiRootUser;
    public static FunctionUIDm MultiRootSystem;
    public FunctionType Type { get; }
    public bool IsResolved { get; }
    public ulong Index { get; }
    public bool IsSynthetic { get; }
    public bool IsGloballyUnique { get; }
    public bool IsUserSynthetic { get; }
    public bool IsAsyncRelated { get; }
    public bool IsTaskRelated { get; }
    public bool IsAlwaysSystem { get; }
    public bool IsThreadRoot { get; }
    public bool IsAllCallsOrThreadRoot { get; }
    private FunctionUIDm(ulong value);
    private static FunctionUIDm();
    public FunctionType get_Type();
    public bool get_IsResolved();
    public UInt32 Shift();
    private ulong TypeBits();
    public ulong get_Index();
    private ulong IndexBits();
    public bool get_IsSynthetic();
    public bool get_IsGloballyUnique();
    private static bool IsSyntheticType(FunctionType type);
    public sealed virtual bool Equals(FunctionUIDm other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(FunctionUIDm left, FunctionUIDm right);
    public static bool op_Inequality(FunctionUIDm left, FunctionUIDm right);
    private ulong GetIndexMask();
    private static ulong GetIndexMask(FunctionType functionType);
    public FunctionUIDm IgnoreShift();
    private ulong MeaningfulHeadBits();
    private ulong SyntheticTypeBits();
    public sealed virtual int CompareTo(FunctionUIDm other);
    [LocalizableAttribute("True")]
public virtual string ToString();
    public static FunctionUIDm Create(ulong key);
    public static FunctionUIDm CreateSynthetic(SyntheticType syntheticType);
    public static FunctionUIDm Create(FunctionType type, ulong index);
    public static FunctionUIDm Create(FunctionType type, ulong index, int shift);
    public static FunctionUIDm CreateSubsystem(ulong index);
    private static FunctionUIDm CreateSyntheticWithMask(ulong mask, ulong index);
    public static FunctionUIDm CreateGenerated(GeneratedType generatedType, ulong index);
    [PureAttribute]
public ulong AsUlong();
    public FunctionUIDm CopyShiftFrom(FunctionUIDm other);
    private ulong ShiftBits();
    public SyntheticType GetSyntheticType();
    public GeneratedType GetGeneratedType();
    [PureAttribute]
public Nullable`1<SubsystemEventType> GetSubsystemEventTypes();
    public bool get_IsUserSynthetic();
    public bool get_IsAsyncRelated();
    public bool get_IsTaskRelated();
    public bool get_IsAlwaysSystem();
    public bool get_IsThreadRoot();
    public bool get_IsAllCallsOrThreadRoot();
}
public enum JetBrains.Common.Util.Metadata.GeneratedType : Enum {
    public byte value__;
    public static GeneratedType None;
    public static GeneratedType Task;
    public static GeneratedType Thread;
    public static GeneratedType Max;
}
public class JetBrains.Common.Util.Metadata.InvalidFunctionTypeException : Exception {
    public InvalidFunctionTypeException(FunctionType type);
}
public class JetBrains.Common.Util.Metadata.InvalidFunctionUidException : Exception {
    public InvalidFunctionUidException(string message, FunctionType type, ulong index);
}
public class JetBrains.Common.Util.Metadata.MethodViewData : ValueType {
    [CompilerGeneratedAttribute]
private FunctionUIDm <Id>k__BackingField;
    private MethodType myType;
    [CanBeNullAttribute]
public string Namespace;
    [CanBeNullAttribute]
public string ClassName;
    public string MethodName;
    public string AssemblyName;
    public Version AssemblyVersion;
    public bool IsSystem;
    public FunctionUIDm Id { get; }
    public bool IsSpecial { get; }
    public bool IsGc { get; }
    public string FullName { get; }
    public string FullSigName { get; }
    private MethodViewData(MethodType methodType, string ns, string className, string methodName, bool isSystem, FunctionUIDm fuid, string assemblyName, Version assemblyVersion);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public FunctionUIDm get_Id();
    public bool get_IsSpecial();
    public bool get_IsGc();
    public string get_FullName();
    public string get_FullSigName();
    [LocalizableAttribute("False")]
public virtual string ToString();
    public sealed virtual bool Equals(MethodViewData other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static MethodViewData CreateSpecial(string shortMethodName, FunctionUIDm id);
    public static MethodViewData CreateGc(string shortMethodName, FunctionUIDm id);
    public static MethodViewData CreateWithoutAssembly(string ns, string className, string shortMethodName, FunctionUIDm id);
    public static MethodViewData Create(string ns, string className, string shortMethodName, bool isSystemFunction, string assemblyName, Version assemblyVersion, FunctionUIDm id);
    public static MethodViewData CreateClone(MethodType methodType, string ns, string className, string shortMethodName, bool isSystemFunction, string assemblyName, Version assemblyVersion, FunctionUIDm id);
}
public class JetBrains.Common.Util.Metadata.Navigation.CallTreeNavigationInfo : object {
    [CompilerGeneratedAttribute]
private AssemblyNameInfo <AssemblyNameInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NavigationTypeFQN>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TypeMemberName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Signature>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ExplicitlyImplementedInterfaceSignature>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ExplicitlyImplementedMemberName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LambdaEnclosingMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private SignaturePresenter <SignaturePresenter>k__BackingField;
    [CompilerGeneratedAttribute]
private TargetFrameworkId <TargetFrameworkId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TypeFQN>k__BackingField;
    public AssemblyNameInfo AssemblyNameInfo { get; public set; }
    public string NavigationTypeFQN { get; public set; }
    public string TypeMemberName { get; public set; }
    public string Signature { get; public set; }
    public string ExplicitlyImplementedInterfaceSignature { get; public set; }
    [CanBeNullAttribute]
public string ExplicitlyImplementedMemberName { get; public set; }
    [CanBeNullAttribute]
public string LambdaEnclosingMethod { get; public set; }
    public SignaturePresenter SignaturePresenter { get; public set; }
    public TargetFrameworkId TargetFrameworkId { get; public set; }
    public string TypeFQN { get; public set; }
    [CompilerGeneratedAttribute]
public AssemblyNameInfo get_AssemblyNameInfo();
    [CompilerGeneratedAttribute]
public void set_AssemblyNameInfo(AssemblyNameInfo value);
    [CompilerGeneratedAttribute]
public string get_NavigationTypeFQN();
    [CompilerGeneratedAttribute]
public void set_NavigationTypeFQN(string value);
    [CompilerGeneratedAttribute]
public string get_TypeMemberName();
    [CompilerGeneratedAttribute]
public void set_TypeMemberName(string value);
    [CompilerGeneratedAttribute]
public string get_Signature();
    [CompilerGeneratedAttribute]
public void set_Signature(string value);
    [CompilerGeneratedAttribute]
public string get_ExplicitlyImplementedInterfaceSignature();
    [CompilerGeneratedAttribute]
public void set_ExplicitlyImplementedInterfaceSignature(string value);
    [CompilerGeneratedAttribute]
public string get_ExplicitlyImplementedMemberName();
    [CompilerGeneratedAttribute]
public void set_ExplicitlyImplementedMemberName(string value);
    [CompilerGeneratedAttribute]
public string get_LambdaEnclosingMethod();
    [CompilerGeneratedAttribute]
public void set_LambdaEnclosingMethod(string value);
    [CompilerGeneratedAttribute]
public SignaturePresenter get_SignaturePresenter();
    [CompilerGeneratedAttribute]
public void set_SignaturePresenter(SignaturePresenter value);
    [CompilerGeneratedAttribute]
public TargetFrameworkId get_TargetFrameworkId();
    [CompilerGeneratedAttribute]
public void set_TargetFrameworkId(TargetFrameworkId value);
    [CompilerGeneratedAttribute]
public string get_TypeFQN();
    [CompilerGeneratedAttribute]
public void set_TypeFQN(string value);
    [LocalizableAttribute("False")]
public virtual string ToString();
}
public class JetBrains.Common.Util.Metadata.Navigation.ETW.TimelineMethodNavigationInfo : object {
    private ITypeNavigationInfo myDeclaringType;
    private CallTreeNavigationInfo myInfo;
    public TimelineMethodNavigationInfo(CallTreeNavigationInfo info);
    public sealed virtual ITypeNavigationInfo GetDeclaringTypeNavigationInfo();
    public sealed virtual string GetShortTypeMemberName();
    public sealed virtual bool TryGetMethodSignature(String& signature, SignaturePresenter& signaturePresenter);
    public sealed virtual bool TryGetExplicitlyImplementedInterfaceSignature(String& signature, SignaturePresenter& signaturePresenter);
}
public class JetBrains.Common.Util.Metadata.Navigation.ETW.TimelineNestedFunctionNavigationInfo : object {
    private IMethodNavigationInfo myParentMethodNavigationInfo;
    private CallTreeNavigationInfo myInfo;
    public TimelineNestedFunctionNavigationInfo(IMethodNavigationInfo parentMethodNavigationInfo, CallTreeNavigationInfo info);
    public sealed virtual IMethodNavigationInfo GetParentMethodNavigationInfo();
    public sealed virtual SignaturePresenter GetSignaturePresenter();
    public sealed virtual string GetSignature();
    public sealed virtual bool TryGetNestedFunctionsPath(IEnumerable`1& nestedFunctionsPath);
}
public class JetBrains.Common.Util.Metadata.Navigation.ETW.TimelineTypeNavigationInfo : object {
    private string myFullyQualifiedTypeName;
    private AssemblyNameInfo myAssemblyNameInfo;
    private TargetFrameworkId myTargetFrameworkId;
    public TimelineTypeNavigationInfo(string fullyQualifiedTypeName, AssemblyNameInfo assemblyNameInfo, TargetFrameworkId targetFrameworkId);
    public sealed virtual string GetFullyQualifiedTypeName();
    public sealed virtual bool TryGetAssemblyNameInfo(AssemblyNameInfo& assemblyNameInfo);
    public sealed virtual bool TryGetAssemblyName(String& assemblyName);
    public sealed virtual bool TryGetPlatformID(TargetFrameworkId& platformId);
}
public class JetBrains.Common.Util.Metadata.Navigation.NavigationInfoContainerBuilder : object {
    public static NavigationInfoContainer Build(CallTreeNavigationInfo navigationInfo);
}
[FlagsAttribute]
public enum JetBrains.Common.Util.Metadata.SubsystemEventType : Enum {
    public byte value__;
    public static SubsystemEventType None;
    public static SubsystemEventType FileIO;
    public static SubsystemEventType Jit;
    public static SubsystemEventType GC;
    public static SubsystemEventType Contention;
    public static SubsystemEventType Sql;
    public static SubsystemEventType CpuReady;
    public static SubsystemEventType Awaits;
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.Metadata.SubsystemEventTypeEx : object {
    public static string FileIO;
    public static string Jit;
    public static string GcWait;
    public static string LockContention;
    public static string SqlQuery;
    public static string WaitingForCPU;
    public static string AwaitingTime;
    private static SubsystemEventTypeEx();
    [ExtensionAttribute]
private static string GetDisplayName(SubsystemEventType this);
    [ExtensionAttribute]
public static IEnumerable`1<string> EnabledFlagsNames(SubsystemEventType this);
}
public enum JetBrains.Common.Util.Metadata.SyntheticType : Enum {
    public int value__;
    public static SyntheticType GlobalRoot;
    public static SyntheticType TruncatedCallstackRoot;
    public static SyntheticType GluedTruncatedCallstack;
}
[FlagsAttribute]
public enum JetBrains.Common.Util.Multithreading.AllowedThreads : Enum {
    public UInt32 value__;
    public static AllowedThreads MainThread;
    public static AllowedThreads Thread1;
    public static AllowedThreads Thread2;
    public static AllowedThreads Thread3;
    public static AllowedThreads Any;
}
public enum JetBrains.Common.Util.Multithreading.ExpectedSynchronization : Enum {
    public int value__;
    public static ExpectedSynchronization ConcurrentCalls;
    public static ExpectedSynchronization SequentialCalls;
}
public static class JetBrains.Common.Util.Multithreading.InterlockedEx : object {
    public static int CompareExchange(IntPtr ptr, int newVal, int expectedVal);
    public static long CompareExchange(IntPtr ptr, long newVal, long expectedVal);
}
public class JetBrains.Common.Util.Multithreading.MemoryLock : object {
    private IntPtr myPtr;
    public MemoryLock(IntPtr ptr);
    public sealed virtual void Lock();
    public sealed virtual void Unlock();
}
[AttributeUsageAttribute("224")]
public class JetBrains.Common.Util.Multithreading.ThreadSafetyAttribute : Attribute {
    public ExpectedSynchronization Synchronization;
    public AllowedThreads Threads;
    public ThreadSafetyAttribute(AllowedThreads threads, ExpectedSynchronization synchronization);
    public ThreadSafetyAttribute(AllowedThreads threads);
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Common.Util.NativeString : object {
    private IntPtr myStartPtr;
    public static NativeString Empty;
    [CompilerGeneratedAttribute]
private int <ByteCount>k__BackingField;
    public int Length { get; }
    public int ByteCount { get; }
    public char Item { get; }
    public NativeString(IntPtr startPtr, int byteCount);
    private static NativeString();
    public static NativeString ReadUntilNullChar(IntPtr startPtr);
    public virtual string ToString();
    public int get_Length();
    [CompilerGeneratedAttribute]
public int get_ByteCount();
    public NativeString Substring(int startPosition);
    public NativeString Substring(int startPosition, int length);
    public char get_Item(int index);
    public int IndexOf(char c);
    public bool StartsWith(string target);
    public sealed virtual bool Equals(NativeString other);
    public sealed virtual bool Equals(string other);
    public bool Equals(IEnumerable`1<char> other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(NativeString left, NativeString right);
    public static bool op_Inequality(NativeString left, NativeString right);
    public sealed virtual IEnumerator`1<char> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public static class JetBrains.Common.Util.NativeStringFromManagedString : object {
    public static NativeString Create(Lifetime lifetime, string string);
}
public interface JetBrains.Common.Util.Navigation.IMethodNavigationInfo {
    public abstract virtual bool TryGetMethodSignature(String& signature, SignaturePresenter& signaturePresenter);
}
public interface JetBrains.Common.Util.Navigation.INestedFunctionNavigationInfo {
    public abstract virtual IMethodNavigationInfo GetParentMethodNavigationInfo();
    public abstract virtual SignaturePresenter GetSignaturePresenter();
    public abstract virtual string GetSignature();
    public abstract virtual bool TryGetNestedFunctionsPath(IEnumerable`1& nestedFunctionsPath);
}
public interface JetBrains.Common.Util.Navigation.INestedFunctionPathItem {
    public string Signature { get; }
    public abstract virtual string get_Signature();
}
public interface JetBrains.Common.Util.Navigation.IPropertyOrEventNavigationInfo {
}
public interface JetBrains.Common.Util.Navigation.ITypeMemberNavigationInfo {
    public abstract virtual ITypeNavigationInfo GetDeclaringTypeNavigationInfo();
    public abstract virtual string GetShortTypeMemberName();
    public abstract virtual bool TryGetExplicitlyImplementedInterfaceSignature(String& signature, SignaturePresenter& signaturePresenter);
}
public interface JetBrains.Common.Util.Navigation.ITypeNavigationInfo {
    public abstract virtual string GetFullyQualifiedTypeName();
    public abstract virtual bool TryGetAssemblyNameInfo(AssemblyNameInfo& assemblyNameInfo);
    public abstract virtual bool TryGetAssemblyName(String& assemblyName);
    public abstract virtual bool TryGetPlatformID(TargetFrameworkId& platformId);
}
public class JetBrains.Common.Util.Navigation.LambdaPathItem : object {
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Signature>k__BackingField;
    public int Index { get; }
    public string Signature { get; }
    public LambdaPathItem(int index, string signature);
    [CompilerGeneratedAttribute]
public int get_Index();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Signature();
}
public class JetBrains.Common.Util.Navigation.LocalFunctionPathItem : object {
    [CompilerGeneratedAttribute]
private string <ShortName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Signature>k__BackingField;
    public string ShortName { get; }
    public string Signature { get; }
    public LocalFunctionPathItem(string shortName, string signature);
    [CompilerGeneratedAttribute]
public string get_ShortName();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Signature();
}
public abstract class JetBrains.Common.Util.Navigation.NavigationInfoContainer : object {
    public abstract virtual string GetFullyQualifiedTypeName();
    public abstract virtual void ProcessNavigationInfo(Action`1<ITypeNavigationInfo> processTypeNavigationInfo, Action`1<IPropertyOrEventNavigationInfo> processPropertyOrEventNavigationInfo, Action`1<IMethodNavigationInfo> processMethodNavigationInfo, Action`1<INestedFunctionNavigationInfo> processNestedFunctionNavigationInfo);
}
public class JetBrains.Common.Util.Navigation.Parser.AnonymousType : Identifier {
    public virtual void AcceptVisitor(IEtwSignatureVisitor visitor);
}
public class JetBrains.Common.Util.Navigation.Parser.ArrayType : Node {
    public int Rank;
    public bool IsJaggedArray;
    public virtual void AcceptVisitor(IEtwSignatureVisitor visitor);
}
public class JetBrains.Common.Util.Navigation.Parser.AttributeType : Node {
}
public class JetBrains.Common.Util.Navigation.Parser.ClassParameters : Node {
    public virtual void AcceptVisitor(IEtwClassSignatureVisitor visitor);
}
public class JetBrains.Common.Util.Navigation.Parser.ClassSpecification : Node {
    public ClassParameters Parameters;
    public virtual void AcceptVisitor(IEtwClassSignatureVisitor visitor);
}
public static class JetBrains.Common.Util.Navigation.Parser.EtwSignatureParser : object {
    private static ILogger ourLog;
    private static SignaturePresenter ourSignaturePresenter;
    private static EtwSignatureParser();
    [CanBeNullAttribute]
public static Signature ParseSignature(Parser parser, string input, bool replaceHexAddressWithStub);
    [CanBeNullAttribute]
public static ClassSpecification ParseClassSpecification(Parser parser, string input);
    public static string ReplaceGenericParametersWithIndexes(string input);
    public static string GetPresentation(ISignature visitedSignature, bool useFullyQualifiedNames, SignaturePresenter& presenter);
    [CanBeNullAttribute]
public static FunctionSignature ConvertToFunctionSignature(string signature, Boolean& useFullyQualifiedNames, bool replaceHexAddressWithStub);
    private static FunctionSignature VisitSignatureNode(Boolean& useFullyQualifiedNames, Signature parsedSignature);
    private static SignaturePresenter CreateSignaturePresenter(bool useFullyQualifiedNames);
}
public class JetBrains.Common.Util.Navigation.Parser.FunctionPtrType : Node {
    public Signature Signature;
    public virtual void AcceptVisitor(IEtwSignatureVisitor visitor);
}
public class JetBrains.Common.Util.Navigation.Parser.GenericCount : Node {
    public int Value;
    public virtual void AcceptVisitor(IEtwSignatureVisitor visitor);
    public virtual void AcceptVisitor(IEtwClassSignatureVisitor visitor);
}
public class JetBrains.Common.Util.Navigation.Parser.GenericReference : Node {
    public int Value;
    public bool MethodReference;
    public virtual void AcceptVisitor(IEtwSignatureVisitor visitor);
}
[DefaultMemberAttribute("Item")]
public interface JetBrains.Common.Util.Navigation.Parser.ICharReadonlyList {
    public int Length { get; }
    public char Item { get; }
    public abstract virtual int get_Length();
    public abstract virtual char get_Item(int index);
}
public class JetBrains.Common.Util.Navigation.Parser.Identifier : Node {
    public string Value;
    public virtual void AcceptVisitor(IEtwSignatureVisitor visitor);
    public virtual void AcceptVisitor(IEtwClassSignatureVisitor visitor);
}
public interface JetBrains.Common.Util.Navigation.Parser.IEtwClassSignatureVisitor {
    public abstract virtual void VisitClassParameters(ClassParameters classParameters);
    public abstract virtual void VisitClassSpecification(ClassSpecification classSpecification);
    public abstract virtual void VisitGenericCount(GenericCount genericCount);
    public abstract virtual void VisitIdentifier(Identifier identifier);
    public abstract virtual void VisitNamespaceAndClass(NamespaceAndClass namespace);
    public abstract virtual void VisitYieldGen(YieldGen yieldGen);
    public abstract virtual void VisitLambdaGen(LambdaGen lambdaGen);
    public abstract virtual void VisitTypeWithGenerics(TypeWithGenerics typeWithGenerics);
    public abstract virtual void VisitParameters(Parameters parameters);
    public abstract virtual void VisitType(Type type);
}
public interface JetBrains.Common.Util.Navigation.Parser.IEtwSignatureVisitor {
    public abstract virtual void Visit(Signature signature);
    public abstract virtual void VisitType(Type type);
    public abstract virtual void VisitParameters(Parameters parameters);
    public abstract virtual void VisitArrayType(ArrayType jaggedArrayType);
    public abstract virtual void VisitPrimitiveType(PrimitiveType primitiveType);
    public abstract virtual void VisitGenericCount(GenericCount genericCount);
    public abstract virtual void VisitGenericReference(GenericReference reference);
    public abstract virtual void VisitNamespaceAndClass(NamespaceAndClass namespaceAndClass);
    public abstract virtual void VisitTypeWithGenerics(TypeWithGenerics typeWithGenerics);
    public abstract virtual void VisitAnonymousType(AnonymousType anonymousType);
    public abstract virtual void VisitLambdaGen(LambdaGen lambdaGen);
    public abstract virtual void VisitYieldGen(YieldGen yieldGen);
    public abstract virtual void VisitPointer(Pointer pointer);
    public abstract virtual void VisitReference(Reference reference);
    public abstract virtual void VisitIdentifier(Identifier identifier);
    public abstract virtual void VisitFunctionPtrType(FunctionPtrType functionPtr);
}
public class JetBrains.Common.Util.Navigation.Parser.LambdaGen : Identifier {
    public virtual void AcceptVisitor(IEtwSignatureVisitor visitor);
    public virtual void AcceptVisitor(IEtwClassSignatureVisitor visitor);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.Navigation.Parser.LogExtensions : object {
    [ExtensionAttribute]
[CanBeNullAttribute]
public static TValue CatchIgnoreInProduction(ILogger logger, Func`1<TValue> func);
}
public class JetBrains.Common.Util.Navigation.Parser.NamespaceAndClass : Node {
    public virtual void AcceptVisitor(IEtwSignatureVisitor visitor);
    public virtual void AcceptVisitor(IEtwClassSignatureVisitor visitor);
}
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
public class JetBrains.Common.Util.Navigation.Parser.NativeStringReadonlyList : ValueType {
    private NativeString myString;
    public int Length { get; }
    public char Item { get; }
    public NativeStringReadonlyList(NativeString string);
    public sealed virtual int get_Length();
    public sealed virtual char get_Item(int index);
    public virtual string ToString();
}
public class JetBrains.Common.Util.Navigation.Parser.Node : object {
    public Node FirstChild;
    public Node NextSibling;
    public virtual void AcceptVisitor(IEtwSignatureVisitor visitor);
    public virtual void AcceptVisitor(IEtwClassSignatureVisitor visitor);
}
public class JetBrains.Common.Util.Navigation.Parser.Parameters : Node {
    public virtual void AcceptVisitor(IEtwSignatureVisitor visitor);
    public virtual void AcceptVisitor(IEtwClassSignatureVisitor visitor);
}
public class JetBrains.Common.Util.Navigation.Parser.Parser : object {
    private String[] myMonoModifierKeywords;
    private String[] myEtwMethodKeyword;
    private String[] myPrimitiveTypes;
    private string myInput;
    private int myPos;
    private Symbol mySym;
    private StringBuilder myStringBuilder;
    private string myStringValue;
    private int myAngleBracketDepth;
    private bool myAreFullyQualifiedNamesUsed;
    private int myYieldGenDepth;
    private bool myReplaceHexAddressWithStub;
    private void Error(string msg);
    private void NextSym();
    private void ConsumeCharacters();
    private void ConsumeWhitespaces();
    private void SkipWhitespaces();
    private bool Accept(Symbol s);
    private void Expect(Symbol s);
    private void Reset(string input, bool replaceHexAddressWithStub);
    public ClassSpecification ParseClassSpecification(string input);
    public Signature ParseSignature(string input, bool replaceHexAddressWithStub);
    private Signature ParseSignature();
    private ClassSpecification ParseClassSpecification();
    private Parameters ParseParameters();
    private Type ParseTypeWithModifiers();
    private Type ParseType();
    private Pointer ParsePointer();
    private Reference ParseReference();
    private ArrayType ParseArrayType();
    private GenericReference ParseGenericReference();
    private PrimitiveType ParsePrimitiveType();
    private TypeWithGenerics ParseEtwNonPrimitiveType();
    private FunctionPtrType ParseFunctionPtrType();
    private void ParseMonoModifier();
    private TypeWithGenerics ParseMonoNonPrimitiveType();
    private ClassParameters ParseClassParameters();
    private TypeWithGenerics ParseTypeWithGenerics();
    private GenericCount ParseGenericCount();
    private Node ParseMethod();
    private YieldGen ParseYieldGen();
    private AnonymousType ParseAnonymousType();
    private Identifier ParseIdentifier();
    private AttributeType ParseAttributeType();
    private NamespaceAndClass ParseNamespaceAndClass();
    private LambdaGen ParseLambdaGen();
}
public class JetBrains.Common.Util.Navigation.Parser.ParserException : Exception {
    public ParserException(string message, Exception innerException);
}
public class JetBrains.Common.Util.Navigation.Parser.Pointer : Node {
    public int Rank;
    public virtual void AcceptVisitor(IEtwSignatureVisitor visitor);
}
public class JetBrains.Common.Util.Navigation.Parser.PrimitiveType : Identifier {
    public virtual void AcceptVisitor(IEtwSignatureVisitor visitor);
}
public class JetBrains.Common.Util.Navigation.Parser.Reference : Node {
    public virtual void AcceptVisitor(IEtwSignatureVisitor visitor);
}
public class JetBrains.Common.Util.Navigation.Parser.Signature : Node {
    public bool AreFullyQualifiedNamesUsed;
    public virtual void AcceptVisitor(IEtwSignatureVisitor visitor);
}
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
public class JetBrains.Common.Util.Navigation.Parser.StringReadonlyList : ValueType {
    private string myString;
    public int Length { get; }
    public char Item { get; }
    public StringReadonlyList(string string);
    public sealed virtual int get_Length();
    public sealed virtual char get_Item(int index);
    public virtual string ToString();
}
public class JetBrains.Common.Util.Navigation.Parser.Type : Node {
    public virtual void AcceptVisitor(IEtwSignatureVisitor visitor);
    public virtual void AcceptVisitor(IEtwClassSignatureVisitor visitor);
}
public class JetBrains.Common.Util.Navigation.Parser.TypeWithGenerics : Node {
    public Parameters Parameters;
    public virtual void AcceptVisitor(IEtwSignatureVisitor visitor);
    public virtual void AcceptVisitor(IEtwClassSignatureVisitor visitor);
}
public class JetBrains.Common.Util.Navigation.Parser.ValueGetter`1 : object {
    private T myValue;
    public ValueGetter`1(T value);
    public sealed virtual T Get();
}
[ExtensionAttribute]
internal static class JetBrains.Common.Util.Navigation.Parser.Visitors.ArrayEx : object {
    [ExtensionAttribute]
public static T[] SubArray(T[] data, int index, int length);
}
[LocalizableAttribute("False")]
public class JetBrains.Common.Util.Navigation.Parser.Visitors.EtwClassToTypeInfoSignatureVisitor : object {
    private StringBuilder myName;
    private List`1<TypeInfoSignature> myTypeInfoChain;
    private int myCurrentGenericIndex;
    private String[] myCurrentGenericParameterNames;
    private String[] myGlobalGenericParameterNames;
    private int myNamespaceStartIndex;
    private int myNamespaceEndIndex;
    private ClassTypeSignature myRootType;
    public static ClassTypeSignature Process(ClassSpecification classSpecification);
    private void ResetVariables();
    public sealed virtual void VisitClassParameters(ClassParameters classParameters);
    public sealed virtual void VisitClassSpecification(ClassSpecification classSpecification);
    public sealed virtual void VisitGenericCount(GenericCount genericCount);
    public sealed virtual void VisitIdentifier(Identifier identifier);
    public sealed virtual void VisitNamespaceAndClass(NamespaceAndClass namespace);
    public sealed virtual void VisitYieldGen(YieldGen yieldGen);
    public sealed virtual void VisitLambdaGen(LambdaGen lambdaGen);
    public sealed virtual void VisitTypeWithGenerics(TypeWithGenerics typeWithGenerics);
    public sealed virtual void VisitParameters(Parameters parameters);
    public sealed virtual void VisitType(Type type);
}
[LocalizableAttribute("False")]
public class JetBrains.Common.Util.Navigation.Parser.Visitors.SignatureDefinitionVisitor : object {
    private static string SystemNamespace;
    private static Dictionary`2<string, string> EtwToCSharpTypes;
    private Stack`1<TypeProperties> myTypesStack;
    private FunctionSignature myFunctionSignature;
    private static SignatureDefinitionVisitor();
    public sealed virtual void Visit(Signature signature);
    public sealed virtual void VisitType(Type type);
    private void VisitChildren(Node type);
    public sealed virtual void VisitParameters(Parameters parameters);
    public sealed virtual void VisitArrayType(ArrayType arrayType);
    public sealed virtual void VisitPrimitiveType(PrimitiveType primitiveType);
    public sealed virtual void VisitGenericCount(GenericCount genericCount);
    public sealed virtual void VisitGenericReference(GenericReference reference);
    public sealed virtual void VisitNamespaceAndClass(NamespaceAndClass namespace);
    private void FinalizeType(TypeProperties currentTypeProperties);
    public sealed virtual void VisitTypeWithGenerics(TypeWithGenerics typeWithGenerics);
    public sealed virtual void VisitAnonymousType(AnonymousType anonymousType);
    public sealed virtual void VisitLambdaGen(LambdaGen lambdaGen);
    public sealed virtual void VisitYieldGen(YieldGen yieldGen);
    public sealed virtual void VisitPointer(Pointer pointer);
    public sealed virtual void VisitReference(Reference reference);
    public sealed virtual void VisitIdentifier(Identifier identifier);
    public sealed virtual void VisitFunctionPtrType(FunctionPtrType functionPtr);
    public FunctionSignature Process(Signature signature);
}
public class JetBrains.Common.Util.Navigation.Parser.YieldGen : Node {
    public Identifier AfterBrackets;
    public virtual void AcceptVisitor(IEtwSignatureVisitor visitor);
    public virtual void AcceptVisitor(IEtwClassSignatureVisitor visitor);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.NotifyPropertyChangedUtils : object {
    [ExtensionAttribute]
public static void OnChanged(T obj, Lifetime lifetime, Expression`1<Func`2<T, TP>> property, Action action);
}
public enum JetBrains.Common.Util.NotifySetChangeAction : Enum {
    public int value__;
    public static NotifySetChangeAction Reset;
    public static NotifySetChangeAction Add;
    public static NotifySetChangeAction Remove;
}
public class JetBrains.Common.Util.NotifySetChangedEventArgs`1 : EventArgs {
    public NotifySetChangeAction Action;
    public T Item;
    private NotifySetChangedEventArgs`1(NotifySetChangeAction action, T item);
    public static NotifySetChangedEventArgs`1<T> Add(T item);
    public static NotifySetChangedEventArgs`1<T> Remove(T item);
    public static NotifySetChangedEventArgs`1<T> Reset();
}
public class JetBrains.Common.Util.NullExecutionController : object {
    public static IExecutionController Instance;
    public int RecommendedParallelizmDegree { get; }
    private static NullExecutionController();
    public sealed virtual IExecutionController StartProgress(int stepsCount, string operationName);
    public sealed virtual IExecutionController CreateSubOperation(int parentStepsCount);
    public sealed virtual IExecutionController AttachSubOperation(Task task, int parentStepsCount);
    public sealed virtual void Wait(IWaitable waitable, TimeSpan timeout);
    public sealed virtual Task`1<T> Fork(Func`2<IExecutionController, T> action);
    public sealed virtual int get_RecommendedParallelizmDegree();
    public sealed virtual void Yield();
    public sealed virtual void AdvanceProgress();
    public sealed virtual void Dispose();
}
[ObsoleteAttribute("It is recommended to migrate to new NullExecutionController")]
public class JetBrains.Common.Util.NullExecutionControllerOld : object {
    public static IExecutionControllerOld Instance;
    private static NullExecutionControllerOld();
    public sealed virtual void Dispose();
    public sealed virtual IExecutionControllerOld StartProgress(int stepsCount, string operationName);
    public sealed virtual IExecutionControllerOld CreateSubOperation(int parentStepsCount);
    public sealed virtual void Yield();
    public sealed virtual void AdvanceProgress();
    public void AttachTask(ITask task, int parentStepsCount, bool isShared);
    public void WaitForTask(ITask task, int parentStepsCount, bool isShared);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.ObjectEx : object {
    [ExtensionAttribute]
public static int GetHashCodeSafe(T o);
}
public class JetBrains.Common.Util.ObservableSet`1 : object {
    private bool myMinimizeUpdates;
    private ISet`1<T> mySource;
    private IDataProvider`1<IReadOnlyCollection`1<T>> myReadonlyCollectionProvider;
    [CompilerGeneratedAttribute]
private EventHandler`1<NotifySetChangedEventArgs`1<T>> Changed;
    [CompilerGeneratedAttribute]
private NotifyCollectionChangedEventHandler CollectionChanged;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public IDataProvider`1<IReadOnlyCollection`1<T>> Provider { get; }
    public ObservableSet`1(IEnumerable`1<T> source, bool minimizeUpdates);
    public ObservableSet`1(bool minimizeUpdates);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual bool Remove(T item);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    [CompilerGeneratedAttribute]
public sealed virtual void add_Changed(EventHandler`1<NotifySetChangedEventArgs`1<T>> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Changed(EventHandler`1<NotifySetChangedEventArgs`1<T>> value);
    public sealed virtual IDataProvider`1<IReadOnlyCollection`1<T>> get_Provider();
    [CompilerGeneratedAttribute]
public sealed virtual void add_CollectionChanged(NotifyCollectionChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_CollectionChanged(NotifyCollectionChangedEventHandler value);
    [LocalizableAttribute("False")]
public virtual string ToString();
    public sealed virtual bool SetEquals(IEnumerable`1<T> other);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.ObservableSetEx : object {
    [ExtensionAttribute]
public static IDataProvider`1<T> CreateLastAddedItemProvider(IObservableSet`1<T> set);
    [ExtensionAttribute]
public static void ResetToValue(IObservableSet`1<T> set, T newValue);
    [ExtensionAttribute]
public static void ToggleValue(IObservableSet`1<T> set, T newValue);
    [ExtensionAttribute]
public static void SyncWith(IObservableSet`1<T> this, IEnumerable`1<T> other);
}
public class JetBrains.Common.Util.PersistenceLifetime : object {
    public static PersistenceLifetime Eternal;
    private Lifetime myLifetime;
    internal PersistenceLifetime(Lifetime lifetime);
    private static PersistenceLifetime();
    public Lifetime AsLifetime();
}
public static class JetBrains.Common.Util.Pipeline : object {
    public static Pipeline`2<TA, TB> Create(Func`2<IDataProvider`1<TA>, IDataProvider`1<TB>> transform);
    public static Pipeline`2<TA, TB> Create(IDataController`1<TA> pipeInput, IDataProvider`1<TB> dataProvider);
}
public class JetBrains.Common.Util.Pipeline`2 : object {
    private IDataController`1<TA> myPipeInput;
    public IDataProvider`1<TB> Output;
    unknown TA Input {public set; }
    public Pipeline`2(IDataController`1<TA> pipeInput, IDataProvider`1<TB> output);
    public void set_Input(TA value);
}
public class JetBrains.Common.Util.PlatformLog : object {
    public static PlatformLog Instance;
    private static PlatformLog();
    public sealed virtual void Catch(Action action);
    public sealed virtual T Catch(Func`1<T> func);
    public sealed virtual void LogExceptionSilently(Exception ex);
    public sealed virtual void LogMessage(string message);
    public sealed virtual void LogException(Exception ex);
}
[LocalizableAttribute("False")]
public class JetBrains.Common.Util.Pluralizer : object {
    private static String[] ExceptionWordsDirectAddS;
    private static String[] ExceptionWordsIrregularInput;
    private static String[] ExceptionWordsIrregularOutput;
    private static String[] ExceptionWordsNoPlural;
    private static Pluralizer();
    public static string GetPlural(string nounString);
}
public class JetBrains.Common.Util.Primitives.ComparableNullable`1 : ValueType {
    public Nullable`1<T> Value;
    public ComparableNullable`1(Nullable`1<T> value);
    public sealed virtual int CompareTo(ComparableNullable`1<T> other);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.Primitives.ComparableNullableEx : object {
    [ExtensionAttribute]
public static ComparableNullable`1<T> ToComparable(Nullable`1<T> value);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.Primitives.PairEx : object {
    [ExtensionAttribute]
public static KeyValuePair`2<K, V> PairWith(K key, V value);
}
public class JetBrains.Common.Util.Primitives.SafeCommand : object {
    private Func`1<ICommand> myCreateCommand;
    private JetWeakReference`1<ICommand> myCommand;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    public ICommand Value { get; }
    public SafeCommand(Func`1<ICommand> createCommand);
    public sealed virtual ICommand get_Value();
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
}
public class JetBrains.Common.Util.Primitives.UnsafeCommand : object {
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    [CompilerGeneratedAttribute]
private ICommand <Value>k__BackingField;
    public ICommand Value { get; }
    public UnsafeCommand(ICommand value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual ICommand get_Value();
}
public class JetBrains.Common.Util.ProcessMonitor.Implementations.LinuxProcessMonitor : ProcessMonitorBase {
    public LinuxProcessMonitor(int processId);
    protected virtual ValueTuple`2<long, object> GetMemoryUsage(TimeSpan measureInterval, object privateData);
}
public class JetBrains.Common.Util.ProcessMonitor.Implementations.MacMemoryInfo : object {
    public long Rprvt;
    public long Vprvt;
    public long Rshrd;
    public long Empty;
    public long FwPrivate;
    private static ILogger ourLogger;
    public MacMemoryInfo(int processId);
    private static MacMemoryInfo();
    private static int GetCpuType(int processId);
    private static bool IsInSharedRegion(ulong addr, int cpuType);
}
public class JetBrains.Common.Util.ProcessMonitor.Implementations.MacProcessMonitor : ProcessMonitorBase {
    public MacProcessMonitor(int processId);
    protected virtual ValueTuple`2<double, object> GetCpuUsage(TimeSpan measureInterval, object privateData);
    protected virtual ValueTuple`2<long, object> GetMemoryUsage(TimeSpan measureInterval, object privateData);
}
public class JetBrains.Common.Util.ProcessMonitor.Implementations.StubProcessMonitor : ProcessMonitorBase {
    protected virtual ValueTuple`2<double, object> GetCpuUsage(TimeSpan measureInterval, object privateData);
    protected virtual ValueTuple`2<long, object> GetMemoryUsage(TimeSpan measureInterval, object privateData);
}
public class JetBrains.Common.Util.ProcessMonitor.Implementations.WindowsProcessMonitor : ProcessMonitorBase {
    public WindowsProcessMonitor(int processId);
    protected virtual ValueTuple`2<double, object> GetCpuUsage(TimeSpan measureInterval, object privateData);
}
public interface JetBrains.Common.Util.ProcessMonitor.IProcessMonitor {
    public bool IsRunning { get; }
    public double CpuUsage { get; }
    public long PrivateMemory { get; }
    public long WorkingSet { get; }
    public abstract virtual bool get_IsRunning();
    public abstract virtual double get_CpuUsage();
    public abstract virtual long get_PrivateMemory();
    public abstract virtual long get_WorkingSet();
}
public interface JetBrains.Common.Util.ProcessMonitor.IProcessMonitorFactory {
    public abstract virtual IProcessMonitor Create(int processId);
}
public abstract class JetBrains.Common.Util.ProcessMonitor.ProcessMonitorBase : SystemMonitorBase {
    [CompilerGeneratedAttribute]
private int <ProcessId>k__BackingField;
    protected int ProcessId { get; }
    public double CpuUsage { get; }
    public long PrivateMemory { get; }
    public long WorkingSet { get; }
    public bool IsRunning { get; }
    protected ProcessMonitorBase(int processId);
    [CompilerGeneratedAttribute]
protected int get_ProcessId();
    public sealed virtual double get_CpuUsage();
    public sealed virtual long get_PrivateMemory();
    public sealed virtual long get_WorkingSet();
    public sealed virtual bool get_IsRunning();
    protected virtual ValueTuple`2<double, object> GetCpuUsage(TimeSpan measureInterval, object privateData);
    protected virtual ValueTuple`2<long, object> GetMemoryUsage(TimeSpan measureInterval, object privateData);
    protected virtual ValueTuple`2<long, object> GetWorkingSet(TimeSpan measureInterval, object privateData);
    private T UsingProcess(Func`2<Process, T> func);
}
public class JetBrains.Common.Util.ProcessMonitor.ProcessMonitorFactory : object {
    public sealed virtual IProcessMonitor Create(int processId);
}
public class JetBrains.Common.Util.ProcessMonitor.SystemMonitorBase : object {
    private static int MinReadoutInterval;
    private ConcurrentDictionary`2<string, PropertyReadout> myReadouts;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    protected void Update(string property);
    protected T GetValue(Func`3<TimeSpan, object, ValueTuple`2<T, object>> factory, string propertyName);
    private void OnPropertyChanged(string propertyName);
}
public class JetBrains.Common.Util.ProgressChangedEventArgs : EventArgs {
    public int Progress;
    public ProgressChangedEventArgs(int newValue);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.ProgressIndicatorEx : object {
    [ExtensionAttribute]
public static ProgressProvider ToProgressProvider(IProgressIndicatorModel progressIndicator);
    private static int ToFraction(double value);
    private static AsyncComputationState ToState(bool isRunning, int fraction);
}
[ExtensionAttribute]
[ObsoleteAttribute]
public static class JetBrains.Common.Util.ProgressIndicatorExtension : object {
    [ExtensionAttribute]
public static IExecutionController CreateExecutionController(IProgressIndicator progressIndicator);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.ProgressPresenterExtenions : object {
    [ExtensionAttribute]
public static void Associate(IProgressPresenter presenter, IAsyncOperation operation);
}
public class JetBrains.Common.Util.ProgressProvider : object {
    private IDataProvider`1<int> myValue;
    private IDataProvider`1<AsyncComputationState> myState;
    private IDataProvider`1<string> myTitle;
    [NotNullAttribute]
public IDataProvider`1<int> Value { get; }
    [NotNullAttribute]
public IDataProvider`1<AsyncComputationState> State { get; }
    [CanBeNullAttribute]
public IDataProvider`1<string> Title { get; }
    public ProgressProvider(IDataProvider`1<string> title, IDataProvider`1<int> value, IDataProvider`1<AsyncComputationState> state);
    public IDataProvider`1<int> get_Value();
    public IDataProvider`1<AsyncComputationState> get_State();
    public IDataProvider`1<string> get_Title();
}
public class JetBrains.Common.Util.ProgressProviderAdapter : object {
    private IDataSink`1<int> myProgressSink;
    private IDataSink`1<AsyncComputationState> myStateSink;
    private IDataSink`1<string> myTitleSink;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    [CompilerGeneratedAttribute]
private EventHandler`2<IAsyncOperation, ProgressChangedEventArgs> OperationProgressChanged;
    [CompilerGeneratedAttribute]
private EventHandler`2<ITask, EventArgs> Finished;
    public string Title { get; }
    public int OperationProgress { get; }
    public IEnumerable`1<IAsyncOperation> SubOperations { get; }
    public bool Completed { get; }
    public Exception Exception { get; }
    public bool CanCancel { get; }
    public bool IsCanceled { get; }
    public ProgressProviderAdapter(Lifetime lifetime, ProgressProvider progress);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    public sealed virtual string get_Title();
    public sealed virtual int get_OperationProgress();
    [CompilerGeneratedAttribute]
public sealed virtual void add_OperationProgressChanged(EventHandler`2<IAsyncOperation, ProgressChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_OperationProgressChanged(EventHandler`2<IAsyncOperation, ProgressChangedEventArgs> value);
    public sealed virtual IEnumerable`1<IAsyncOperation> get_SubOperations();
    public sealed virtual bool get_Completed();
    [CompilerGeneratedAttribute]
public sealed virtual void add_Finished(EventHandler`2<ITask, EventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Finished(EventHandler`2<ITask, EventArgs> value);
    public sealed virtual Exception get_Exception();
    public sealed virtual bool get_CanCancel();
    public sealed virtual void Cancel();
    public sealed virtual bool get_IsCanceled();
    [CompilerGeneratedAttribute]
private void <.ctor>b__3_1(int step);
    [CompilerGeneratedAttribute]
private void <.ctor>b__3_2(AsyncComputationState s);
    [CompilerGeneratedAttribute]
private void <.ctor>b__3_3(string title);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.ProgressProviderEx : object {
    [ExtensionAttribute]
public static ProgressProvider Single(IDataProvider`1<ProgressProvider[]> progresses);
    [ExtensionAttribute]
public static ProgressProvider Normalize(ProgressProvider provider);
    private static AsyncComputationState MergeStates(AsyncComputationState[] states);
    [ExtensionAttribute]
public static ProgressProvider FirstOrDefault(IDataProvider`1<IEnumerable`1<ProgressProvider>> providers);
    [ExtensionAttribute]
public static ProgressProvider LastOrDefault(IDataProvider`1<IEnumerable`1<ProgressProvider>> providers);
    [ExtensionAttribute]
public static ProgressProvider Merge(IDataProvider`1<ProgressProvider[]> progresses, Func`2<Int32[], int> merger, string title);
    [ExtensionAttribute]
public static ProgressProvider MergeWeighted(IDataProvider`1<ValueTuple`2[]> progresses, string title);
    private static string MergeTitles(Pair`2[] statesWithTitles);
    [ExtensionAttribute]
public static ProgressProvider FlowInto(ProgressProvider progressProvider, IExecutionController executionController, Lifetime lifetime);
    [ExtensionAttribute]
public static ProgressProvider FlowInto(ProgressProvider progressProvider, IProgressIndicator progressIndicator, Lifetime lifetime);
    public static int WeightedProgressMerger(ValueTuple`2[] values);
    public static int EqualProgressMerger(Int32[] values, int index, int count);
    public static int EqualProgressMerger(Int32[] values);
    private static Func`2<Int32[], int> CreateProgressMerger(double firstPart);
    [ExtensionAttribute]
public static ProgressProvider SwitchLocal(IRemotableReference`1<ProgressProvider> progress);
    [ExtensionAttribute]
public static IRemotableReference`1<ProgressProvider> SwitchRemoteIfPossible(ProgressProvider progress, IRemoteCommunicator comm);
    [ExtensionAttribute]
public static IRemotableReference`1<IDataProvider`1<ProgressProvider>> SendToRemote(IDataProvider`1<ProgressProvider> progress, IRemoteCommunicator comm);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.PropertyExtensions : object {
    [ExtensionAttribute]
public static void ExecuteOnValueChangeOnce(IProperty`1<T> property, Lifetime lifetime, T value, Action action);
    [ExtensionAttribute]
public static void ExecuteOnValueChangeOnce(IProperty`1<T> property, Lifetime lifetime, IEnumerable`1<T> values, Action action);
}
public enum JetBrains.Common.Util.PtrSize : Enum {
    public byte value__;
    public static PtrSize X32;
    public static PtrSize X64;
}
public class JetBrains.Common.Util.ReadOnlyCollectionWrapper`1 : object {
    [CompilerGeneratedAttribute]
private ICollection`1<T> <Source>k__BackingField;
    public ICollection`1<T> Source { get; public set; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    public ReadOnlyCollectionWrapper`1(ICollection`1<T> source);
    [CompilerGeneratedAttribute]
public ICollection`1<T> get_Source();
    [CompilerGeneratedAttribute]
public void set_Source(ICollection`1<T> value);
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual int get_Count();
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.Remove(T item);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Common.Util.ReadonlyListSegment`1 : ValueType {
    private IReadOnlyList`1<T> myArray;
    private int myStartIndex;
    private int myLength;
    private int myLastExclusiveIndex;
    public int Count { get; }
    public T Item { get; }
    public ReadonlyListSegment`1(IReadOnlyList`1<T> array, int startIndex, int length);
    public sealed virtual int get_Count();
    [IteratorStateMachineAttribute("JetBrains.Common.Util.ReadonlyListSegment`1/<GetEnumerator>d__7")]
public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual T get_Item(int index);
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Common.Util.ReadOnlyListSlice`1 : object {
    private IReadOnlyList`1<T> myList;
    private int myStartIndex;
    [CompilerGeneratedAttribute]
private int <Count>k__BackingField;
    public int Count { get; }
    public T Item { get; }
    public ReadOnlyListSlice`1(IReadOnlyList`1<T> list, int startIndex, int count);
    [CompilerGeneratedAttribute]
public int get_Count();
    public T get_Item(int index);
    public Enumerator<T> GetEnumerator();
}
public static class JetBrains.Common.Util.ReadString : object {
    public static ReadStringResult AnsiUntilNullTerm(IntPtr ptr, int maxBytesToRead);
    public static ReadStringResult UnicodeUntilNullTerm(IntPtr ptr, int maxBytesToRead);
    public static ReadStringResult UTF8UntilNullTerm(IntPtr ptr, int maxBytesToRead);
    private static ValueTuple`2<int, bool> StrLengthW(IntPtr ptr, int maxLength);
    private static ValueTuple`2<int, bool> StrLengthA(IntPtr ptr, int maxLength);
}
[IsReadOnlyAttribute]
public class JetBrains.Common.Util.ReadStringResult : ValueType {
    public int ReadBytes;
    public string Result;
    public ReadStringResult(string result, int readBytes);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.RecognitionMarks : object {
    [ExtensionAttribute]
public static string TreatAsStacktrace(StringBuilder builder);
}
[ThreadSafeAttribute]
public class JetBrains.Common.Util.RefCountedLifetime : object {
    private static ILogger ourLogger;
    private LifetimeDefinition myLifetimeDefinition;
    private int myRefCount;
    public object Id { get; }
    public Lifetime Instance { get; }
    public bool IsReferenced { get; }
    public RefCountedLifetime(string id);
    public RefCountedLifetime(Lifetime parent, string id);
    private static RefCountedLifetime();
    public object get_Id();
    public Lifetime get_Instance();
    public bool get_IsReferenced();
    public bool TryAddRef();
    public bool TryAddRef(Lifetime lifetime);
    public void Release();
    [LocalizableAttribute("False")]
public virtual string ToString();
    public static Lifetime op_Implicit(RefCountedLifetime lifetime);
}
public class JetBrains.Common.Util.RemotableTree.ActivityToken : object {
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) myRunningActivitiesCount;
    private string myMoniker;
    public bool IsRunning { get; }
    public ActivityToken(string moniker);
    public bool get_IsRunning();
    public IDisposable Run();
}
public class JetBrains.Common.Util.RemotableTree.AsyncTreeRequestProcessor`3 : object {
    private IDataController`1<TreeUpdateRequest`2<TKey, TUserState>> myRequestController;
    [CompilerGeneratedAttribute]
private Action`1<TreeUpdateResponse`2<TKey, TInfo>> ResponseReceived;
    public AsyncTreeRequestProcessor`3(Lifetime lifetime, IDataController`1<TreeUpdateRequest`2<TKey, TUserState>> requestController, IDataProvider`1<TreeUpdateResponse`2<TKey, TInfo>> responseProvider);
    private void OnResponse(TreeUpdateResponse`2<TKey, TInfo> response);
    public sealed virtual void SendRequest(TreeUpdateRequest`2<TKey, TUserState> request);
    [CompilerGeneratedAttribute]
public sealed virtual void add_ResponseReceived(Action`1<TreeUpdateResponse`2<TKey, TInfo>> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_ResponseReceived(Action`1<TreeUpdateResponse`2<TKey, TInfo>> value);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.RemotableTree.Helpers : object {
    public static bool IsChildInterestingNode(double percent, double parentPercent, Nullable`1<double> threshold);
    [ExtensionAttribute]
public static ITreeRequestProcessor`3<TKey, TInfo, TUserState> CreateAsyncRequestProcessor(IDataController`1<TreeUpdateRequest`2<TKey, TUserState>> requestController, Lifetime lifetime, IDataProvider`1<TreeUpdateResponse`2<TKey, TInfo>> responseProvider);
    [ExtensionAttribute]
public static IDataProvider`1<TreeUpdateResponse`2<TKey, TInfo>> BuildTreeRequestProcessorPipeline(ITreeService`3<TKey, TInfo, TUserState> treeService, DataPipeLifetime lifetime, IDataProvider`1<TreeUpdateRequest`2<TKey, TUserState>> requestController);
    [ExtensionAttribute]
public static ITreeRequestProcessor`3<TKey, TInfo, TUserState> CreateSyncRequestProcessor(ITreeService`3<TKey, TInfo, TUserState> builder);
}
public interface JetBrains.Common.Util.RemotableTree.ICallTreeSelection`1 {
    public abstract virtual void UpdateSelection(IEnumerable`1<TKey> path);
    public abstract virtual IEnumerable`1<TKey> GetLastSelection();
}
public interface JetBrains.Common.Util.RemotableTree.ITree`2 {
    [NotNullAttribute]
public ITreeListStructureProvider`1<TNodeModel> StructureProvider { get; }
    public IDataProvider`1<ITreeNode`2<TKey, TNodeModel>> SelectedNode { get; }
    public ITreeNode`2<TKey, TNodeModel> Root { get; }
    [NotNullAttribute]
public TKey[] RootPrefix { get; }
    public IDataProvider`1<bool> IsEmpty { get; }
    public abstract virtual ITreeListStructureProvider`1<TNodeModel> get_StructureProvider();
    public abstract virtual IDataProvider`1<ITreeNode`2<TKey, TNodeModel>> get_SelectedNode();
    public abstract virtual ITreeNode`2<TKey, TNodeModel> get_Root();
    public abstract virtual TKey[] get_RootPrefix();
    public abstract virtual IDataProvider`1<bool> get_IsEmpty();
    public abstract virtual IEnumerable`1<TKey> GetNodePrefix(ITreeNode`2<TKey, TNodeModel> node);
}
public interface JetBrains.Common.Util.RemotableTree.ITreeNode`2 {
    public int ChildrenCount { get; }
    public IEnumerable`1<ITreeNode`2<TKey, TValue>> Children { get; }
    public TValue Value { get; }
    public TKey Key { get; }
    public ITreeNode`2<TKey, TValue> Parent { get; }
    public abstract virtual int get_ChildrenCount();
    public abstract virtual IEnumerable`1<ITreeNode`2<TKey, TValue>> get_Children();
    public abstract virtual TValue get_Value();
    public abstract virtual TKey get_Key();
    public abstract virtual ITreeNode`2<TKey, TValue> get_Parent();
}
public interface JetBrains.Common.Util.RemotableTree.ITreeNodeFactory`3 {
    public abstract virtual TViewModel CreateNodeViewModel(TInfo info, TKey key, object responseData);
    public abstract virtual TViewModel CreateFakeRootNode();
    public abstract virtual TViewModel CreateLoadingRootNode(TKey key);
}
public interface JetBrains.Common.Util.RemotableTree.ITreeNodeInfo {
    public bool IsExpandable { get; }
    public bool IsExpandedByDefault { get; }
    public bool IsTaskRecursionFolded { get; }
    public abstract virtual bool get_IsExpandable();
    public abstract virtual bool get_IsExpandedByDefault();
    public abstract virtual bool get_IsTaskRecursionFolded();
}
public interface JetBrains.Common.Util.RemotableTree.ITreeNodePathItemState {
}
public interface JetBrains.Common.Util.RemotableTree.ITreeNodeUserState {
    public Nullable`1<bool> IsExpanded { get; public set; }
    public bool IsChanged { get; }
    public abstract virtual Nullable`1<bool> get_IsExpanded();
    public abstract virtual void set_IsExpanded(Nullable`1<bool> value);
    public abstract virtual bool get_IsChanged();
}
public interface JetBrains.Common.Util.RemotableTree.ITreeNodeViewModel {
    public bool IsExpanded { get; public set; }
    public bool IsSelected { get; public set; }
    public bool IsExpandable { get; }
    public ITreeNodeViewModel Parent { get; }
    public IEnumerable`1<ITreeNodeViewModel> Children { get; }
    public abstract virtual bool get_IsExpanded();
    public abstract virtual void set_IsExpanded(bool value);
    public abstract virtual bool get_IsSelected();
    public abstract virtual void set_IsSelected(bool value);
    public abstract virtual bool get_IsExpandable();
    public abstract virtual ITreeNodeViewModel get_Parent();
    public abstract virtual IEnumerable`1<ITreeNodeViewModel> get_Children();
}
public interface JetBrains.Common.Util.RemotableTree.ITreeNodeViewModel`1 {
    public ITreeNode`2<TKey, ITreeNodeViewModel> Container { get; }
    public abstract virtual ITreeNode`2<TKey, ITreeNodeViewModel> get_Container();
}
public interface JetBrains.Common.Util.RemotableTree.ITreeNodeViewModel`2 {
    public abstract virtual bool TrySetSelection(UpdateRequestOptions options);
    public abstract virtual void AttachFacade(ITreeNode`2<TKey, ITreeNodeViewModel> container, IUserStateTree`2<TKey, TUserState> treeFacade);
    public abstract virtual void SetState(TUserState state);
}
public interface JetBrains.Common.Util.RemotableTree.ITreeRequestProcessor`3 {
    public abstract virtual void SendRequest(TreeUpdateRequest`2<TKey, TUserState> request);
    [CompilerGeneratedAttribute]
public abstract virtual void add_ResponseReceived(Action`1<TreeUpdateResponse`2<TKey, TInfo>> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ResponseReceived(Action`1<TreeUpdateResponse`2<TKey, TInfo>> value);
}
public interface JetBrains.Common.Util.RemotableTree.ITreeService`3 {
    [NotNullAttribute]
public abstract virtual TreeUpdateResponse`2<TKey, TInfo> ProcessRequest(TreeUpdateRequest`2<TKey, TUserState> request, IExecutionController controller);
}
public interface JetBrains.Common.Util.RemotableTree.IUserStateTree`2 {
    public IDataProvider`1<ITreeNode`2<TKey, ITreeNodeViewModel>> SelectedNode { get; }
    public abstract virtual TUserState AttachState(IEnumerable`1<TKey> keys);
    public abstract virtual void DetachState(IEnumerable`1<TKey> keys);
    public abstract virtual void UpdateSubTreeStructure(ITreeNode`2<TKey, ITreeNodeViewModel> node);
    public abstract virtual void RequestNodeUpdate(ITreeNode`2<TKey, ITreeNodeViewModel> userTreeNode, UpdateRequestOptions options);
    public abstract virtual void SetSelectedNode(ITreeNode`2<TKey, ITreeNodeViewModel> node);
    public abstract virtual IDataProvider`1<ITreeNode`2<TKey, ITreeNodeViewModel>> get_SelectedNode();
    [CompilerGeneratedAttribute]
public abstract virtual void add_UserStateUpdated(EventHandler`1<UserStateUpdatedArgs`2<TKey, TUserState>> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_UserStateUpdated(EventHandler`1<UserStateUpdatedArgs`2<TKey, TUserState>> value);
}
public static class JetBrains.Common.Util.RemotableTree.NodeState : object {
    public static int None;
    public static int Expand;
    public static int SystemFolding;
    public static int RecursiveFolding;
    public static int IsSystem;
    public static bool HasState(int state, int checkState);
    public static void SetState(Int32& location, int state);
    public static void ClearState(Int32& location, int state);
    public static void UpdateState(Int32& location, int state, bool setBits);
}
public class JetBrains.Common.Util.RemotableTree.SyncTreeRequestProcessor`3 : object {
    private ITreeService`3<TKey, TInfo, TUserState> myTreeService;
    [CompilerGeneratedAttribute]
private Action`1<TreeUpdateResponse`2<TKey, TInfo>> ResponseReceived;
    public SyncTreeRequestProcessor`3(ITreeService`3<TKey, TInfo, TUserState> treeService);
    public sealed virtual void SendRequest(TreeUpdateRequest`2<TKey, TUserState> request);
    [CompilerGeneratedAttribute]
public sealed virtual void add_ResponseReceived(Action`1<TreeUpdateResponse`2<TKey, TInfo>> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_ResponseReceived(Action`1<TreeUpdateResponse`2<TKey, TInfo>> value);
}
public class JetBrains.Common.Util.RemotableTree.Tree`4 : object {
    private static ILogger ourLog;
    private TreeNode`2<TKey, TViewModel> myRoot;
    private ITreeRequestProcessor`3<TKey, TInfo, TUserState> myTreeRequestProcessor;
    private Func`2<Lifetime, ITreeNodeFactory`3<TKey, TInfo, TViewModel>> myTreeNodeFactoryAccessor;
    private IDataController`1<ITreeNode`2<TKey, TViewModel>> mySelectedNode;
    [NotNullAttribute]
private ITreeNode`2<TKey, TUserState> myUserChangesRoot;
    [NotNullAttribute]
private Func`2<TKey, TKey> myGetUserStateKey;
    [CanBeNullAttribute]
private ICallTreeSelection`1<TKey> myCallTreeSelection;
    [CanBeNullAttribute]
private TKey[] myTreePrefix;
    private int myTreeVersion;
    private UserStateTreeData`2<TKey, TUserState> myUserChangesTreeData;
    private IDataController`1<bool> myIsEmpty;
    private EventHandlerWithState`1<ItemUpdatedEventArgs`1<TViewModel>> myOnScrollToItem;
    private ActivityToken myRestoreOldSelectionActivityToken;
    [CompilerGeneratedAttribute]
private EventHandler`1<ItemUpdatedEventArgs`1<TViewModel>> ItemUpdated;
    [CompilerGeneratedAttribute]
private EventHandler`1<NodeUpdatedEventArgs`1<TViewModel>> ItemUpdatedV2;
    [CompilerGeneratedAttribute]
private EventHandler`1<UserStateUpdatedArgs`2<TKey, TUserState>> UserStateUpdated;
    public ITreeNode`2<TKey, TViewModel> Root { get; }
    public TKey[] RootPrefix { get; }
    private IEnumerable`1<TKey> PrefixWithoutRoot { get; }
    private bool HasPrefix { get; }
    public IDataProvider`1<bool> IsEmpty { get; }
    public ITreeListStructureProvider`1<TViewModel> StructureProvider { get; }
    public IDataProvider`1<ITreeNode`2<TKey, TViewModel>> SelectedNode { get; }
    private IDataProvider`1<ITreeNode`2<TKey, ITreeNodeViewModel>> JetBrains.Common.Util.RemotableTree.IUserStateTree<TKey,TUserState>.SelectedNode { get; }
    private TViewModel JetBrains.Common.Util.TreeStructure.ITreeListStructureProvider<TViewModel>.Root { get; }
    public IEventHandlerWithState`1<ItemUpdatedEventArgs`1<TViewModel>> OnScrollToItem { get; }
    public Tree`4(Lifetime lifetime, ITreeRequestProcessor`3<TKey, TInfo, TUserState> treeProcessor, Func`2<Lifetime, ITreeNodeFactory`3<TKey, TInfo, TViewModel>> treeNodeFactoryAccessor, Func`2<TKey, TKey> getUserStateKey, UserStateTreeData`2<TKey, TUserState> userChanges, TKey[] prefix, ICallTreeSelection`1<TKey> selection);
    private static Tree`4();
    public sealed virtual ITreeNode`2<TKey, TViewModel> get_Root();
    public sealed virtual TKey[] get_RootPrefix();
    private IEnumerable`1<TKey> get_PrefixWithoutRoot();
    private bool get_HasPrefix();
    public sealed virtual IDataProvider`1<bool> get_IsEmpty();
    private void OnSelectedNodeChanged(ITreeNode`2<TKey, TViewModel> oldNode, ITreeNode`2<TKey, TViewModel> newNode);
    public sealed virtual ITreeListStructureProvider`1<TViewModel> get_StructureProvider();
    private static TreeNode`2<TKey, TViewModel> BuildNode(TreeNode`2<TKey, TInfo> readonlyNode, IUserStateTree`2<TKey, TUserState> userStateTree, object responseData, ITreeNodeFactory`3<TKey, TInfo, TViewModel> factory);
    private static TreeNode`2<TKey, TViewModel> BuildNode(TKey key, TInfo info, IUserStateTree`2<TKey, TUserState> userStateTree, object responseData, ITreeNodeFactory`3<TKey, TInfo, TViewModel> factory);
    public sealed virtual IDataProvider`1<ITreeNode`2<TKey, TViewModel>> get_SelectedNode();
    public sealed virtual IEnumerable`1<TKey> GetNodePrefix(ITreeNode`2<TKey, TViewModel> node);
    private void AttachUserState(ITreeNode`2<TKey, TViewModel> node, ITreeNode`2<TKey, TUserState> userStateNode);
    private TreeNode`2<TKey, TViewModel> BuildTreeNodeCore(TreeNode`2<TKey, TInfo> readonlyNode, object responseData, ITreeNodeFactory`3<TKey, TInfo, TViewModel> factory);
    private void ValidateResponse(TreeUpdateResponse`2<TKey, TInfo> response);
    public void UpdateTree(TreeUpdateResponse`2<TKey, TInfo> response);
    [IteratorStateMachineAttribute("JetBrains.Common.Util.RemotableTree.Tree`4/<GenerateResetEvents>d__38")]
private static IEnumerable`1<NodeUpdatedEventArgs`1<TViewModel>> GenerateResetEvents(TViewModel node, IEnumerable`1<TreeNode`2<TKey, TViewModel>> oldChildren, IEnumerable`1<TreeNode`2<TKey, TViewModel>> newChildren);
    [CanBeNullAttribute]
public TreeUpdateRequest`2<TKey, TUserState> BuildRequest(ITreeNode`2<TKey, TViewModel> node, UpdateRequestOptions options);
    private void FireSubtreeUpdated(ITreeNode`2<TKey, TViewModel> node);
    private void FireSubtreeUpdatedV2(IEnumerable`1<NodeUpdatedEventArgs`1<TViewModel>> events);
    private void FireSubtreeUpdatedV2(NodeUpdatedEventArgs`1<TViewModel> event);
    public sealed virtual void UpdateSubTreeStructure(ITreeNode`2<TKey, ITreeNodeViewModel> node);
    private void RequestFullUpdate();
    public sealed virtual void RequestNodeUpdate(ITreeNode`2<TKey, ITreeNodeViewModel> treeNode, UpdateRequestOptions options);
    private void FireUserStateUpdated();
    public sealed virtual void SetSelectedNode(ITreeNode`2<TKey, ITreeNodeViewModel> node);
    private sealed virtual override IDataProvider`1<ITreeNode`2<TKey, ITreeNodeViewModel>> JetBrains.Common.Util.RemotableTree.IUserStateTree<TKey,TUserState>.get_SelectedNode();
    private sealed virtual override TViewModel JetBrains.Common.Util.TreeStructure.ITreeListStructureProvider<TViewModel>.get_Root();
    public sealed virtual bool HasChildren(TViewModel item);
    public sealed virtual TViewModel GetParent(TViewModel item);
    public sealed virtual bool GetIsExpanded(TViewModel item);
    public sealed virtual void SetIsExpanded(TViewModel item, bool isExpanded);
    public sealed virtual IEnumerable`1<TViewModel> GetChildren(TViewModel item);
    private void ScrollToNodeInternal(TViewModel viewModel);
    [CompilerGeneratedAttribute]
public sealed virtual void add_ItemUpdated(EventHandler`1<ItemUpdatedEventArgs`1<TViewModel>> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_ItemUpdated(EventHandler`1<ItemUpdatedEventArgs`1<TViewModel>> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_ItemUpdatedV2(EventHandler`1<NodeUpdatedEventArgs`1<TViewModel>> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_ItemUpdatedV2(EventHandler`1<NodeUpdatedEventArgs`1<TViewModel>> value);
    public sealed virtual IEventHandlerWithState`1<ItemUpdatedEventArgs`1<TViewModel>> get_OnScrollToItem();
    [CompilerGeneratedAttribute]
public sealed virtual void add_UserStateUpdated(EventHandler`1<UserStateUpdatedArgs`2<TKey, TUserState>> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_UserStateUpdated(EventHandler`1<UserStateUpdatedArgs`2<TKey, TUserState>> value);
    [CanBeNullAttribute]
private ITreeNode`2<TKey, TUserState> FindUserStateNode(IEnumerable`1<TKey> path, bool createIfMissing);
    private ITreeNode`2<TKey, TViewModel> GetResponseRoot(TreeUpdateResponse`2<TKey, TInfo> response);
    public sealed virtual TUserState AttachState(IEnumerable`1<TKey> stack);
    public sealed virtual void DetachState(IEnumerable`1<TKey> path);
    [CompilerGeneratedAttribute]
private ItemUpdatedEventArgs`1<TViewModel> <.ctor>b__24_0();
    [CompilerGeneratedAttribute]
private void <.ctor>b__24_1();
    [CompilerGeneratedAttribute]
private void <.ctor>b__24_2();
}
[DataContractAttribute]
[JsonObjectAttribute]
public class JetBrains.Common.Util.RemotableTree.TreeNode`2 : object {
    [DataMemberAttribute]
[NotNullAttribute]
private TKey myKey;
    [DataMemberAttribute]
private TValue myValue;
    [CanBeNullAttribute]
[JsonIgnoreAttribute]
private TreeNode`2<TKey, TValue> myParent;
    [CanBeNullAttribute]
[DataMemberAttribute]
private TreeNode`2[] myChildren;
    [JsonIgnoreAttribute]
public int ChildrenCount { get; }
    [JsonIgnoreAttribute]
private IEnumerable`1<ITreeNode`2<TKey, TValue>> JetBrains.Common.Util.RemotableTree.ITreeNode<TKey,TValue>.Children { get; }
    [NotNullAttribute]
[JsonIgnoreAttribute]
public IEnumerable`1<TreeNode`2<TKey, TValue>> Children { get; }
    [JsonIgnoreAttribute]
public TValue Value { get; }
    [JsonIgnoreAttribute]
public TKey Key { get; }
    [JsonIgnoreAttribute]
private ITreeNode`2<TKey, TValue> JetBrains.Common.Util.RemotableTree.ITreeNode<TKey,TValue>.Parent { get; }
    [CanBeNullAttribute]
[JsonIgnoreAttribute]
public TreeNode`2<TKey, TValue> Parent { get; }
    public TreeNode`2(TKey key, TValue value, IEnumerable`1<TreeNode`2<TKey, TValue>> children);
    public static TreeNode`2<TKey, TValue> BuildRoot();
    public void UpdateChildren(IEnumerable`1<TreeNode`2<TKey, TValue>> children);
    public sealed virtual int get_ChildrenCount();
    private sealed virtual override IEnumerable`1<ITreeNode`2<TKey, TValue>> JetBrains.Common.Util.RemotableTree.ITreeNode<TKey,TValue>.get_Children();
    public IEnumerable`1<TreeNode`2<TKey, TValue>> get_Children();
    public sealed virtual TValue get_Value();
    public sealed virtual TKey get_Key();
    private sealed virtual override ITreeNode`2<TKey, TValue> JetBrains.Common.Util.RemotableTree.ITreeNode<TKey,TValue>.get_Parent();
    public TreeNode`2<TKey, TValue> get_Parent();
    [LocalizableAttribute("False")]
public virtual string ToString();
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.RemotableTree.TreeNodeEx : object {
    [ExtensionAttribute]
public static void AppendChild(TreeNode`2<TKey, TValue> node, TreeNode`2<TKey, TValue> child);
    [ExtensionAttribute]
public static void RemoveChild(TreeNode`2<TKey, TValue> node, TreeNode`2<TKey, TValue> child);
    [ExtensionAttribute]
public static int ReplaceNode(TreeNode`2<TKey, TValue> node, TreeNode`2<TKey, TValue> source, TreeNode`2<TKey, TValue> newValue);
    [ExtensionAttribute]
public static bool IsDescendantOf(ITreeNode`2<TKey, TValue> descendant, ITreeNode`2<TKey, TValue> ancestor);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static ITreeNode`2<TKey, TValue> GetChildByKey(ITreeNode`2<TKey, TValue> treeRoot, TKey key);
    [ExtensionAttribute]
[NotNullAttribute]
public static ITreeNode`2<TKey, TValue> GetNodeByPathWhileMatching(ITreeNode`2<TKey, TValue> root, IEnumerable`1<TKey> keyPath);
    [ExtensionAttribute]
[NotNullAttribute]
public static ITreeNode`2<TKey, TValue> GetOrCreateNodeByPath(ITreeNode`2<TKey, TValue> root, IEnumerable`1<TKey> keyPath, Func`2<TKey, TValue> createNewNode);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static ITreeNode`2<TKey, TValue> TryGetNodeByPath(ITreeNode`2<TKey, TValue> root, IEnumerable`1<TKey> keyPath);
    [ExtensionAttribute]
private static ITreeNode`2<TKey, TValue> GetNodeByPathCore(ITreeNode`2<TKey, TValue> root, IEnumerable`1<TKey> keyPath, Func`2<TKey, TValue> createNewNode);
    [ExtensionAttribute]
public static IEnumerable`1<TKey> KeyPathFromRoot(ITreeNode`2<TKey, TValue> node);
    [ExtensionAttribute]
public static IEnumerable`1<TreeNodePathItem`2<TKey, TValue>> PathFromRoot(ITreeNode`2<TKey, TValue> node);
    [ExtensionAttribute]
public static TreeNode`2<TKey, TValue> TryGetChild(TreeNode`2<TKey, TValue> node, TKey key);
    [IteratorStateMachineAttribute("JetBrains.Common.Util.RemotableTree.TreeNodeEx/<ReplaceItem>d__12`1")]
[ExtensionAttribute]
private static IEnumerable`1<T> ReplaceItem(IEnumerable`1<T> node, T source, T newValue, Func`3<T, T, bool> predicate, Action`1<int> indexReplaced);
}
public class JetBrains.Common.Util.RemotableTree.TreeNodePathItem`2 : object {
    public TKey Key;
    public TState State;
    public TreeNodePathItem`2(TKey key, TState state);
}
public abstract class JetBrains.Common.Util.RemotableTree.TreeNodeViewModelBase`3 : object {
    private static double RelativeExpandThreshold;
    private UpdateRequestOptions myFindNextInterestingNodeOptions;
    [NotNullAttribute]
protected TNodeInfo NodeInfo;
    private bool myIsSelected;
    [CanBeNullAttribute]
private TUserState myUserState;
    private IUserStateTree`2<TKey, TUserState> myUserStateTree;
    private ITreeNode`2<TKey, ITreeNodeViewModel> myContainer;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    protected bool IsBacktracePassThroughNode { get; }
    protected double PercentsValue { get; }
    protected bool HasChildren { get; }
    public ITreeNode`2<TKey, ITreeNodeViewModel> Container { get; }
    public bool IsExpanded { get; public set; }
    public bool IsPrefixNode { get; }
    public bool IsSelected { get; public set; }
    public bool IsExpandable { get; }
    public ITreeNodeViewModel Parent { get; }
    public IEnumerable`1<ITreeNodeViewModel> Children { get; }
    protected TreeNodeViewModelBase`3(TNodeInfo nodeInfo);
    public void FocusNextImportantCall();
    public sealed virtual bool TrySetSelection(UpdateRequestOptions options);
    protected abstract virtual bool get_IsBacktracePassThroughNode();
    protected abstract virtual double get_PercentsValue();
    private bool TrySetSelectionCore(UpdateRequestOptions options, bool loadSubtreeFromServer);
    private static TreeNodeViewModelBase`3<TKey, TNodeInfo, TUserState> FindNearestSibling(ITreeNodeViewModel currentNode);
    private static ITreeNodeViewModel GetNextNode(IEnumerable`1<ITreeNodeViewModel> children, ITreeNodeViewModel previousNode);
    private TUserState AttachState();
    private void DetachUserState();
    private void IsExpandedChanged();
    protected void OnSelected();
    protected bool get_HasChildren();
    private void RequestNodeUpdate(UpdateRequestOptions options);
    public virtual void AttachFacade(ITreeNode`2<TKey, ITreeNodeViewModel> container, IUserStateTree`2<TKey, TUserState> treeFacade);
    public sealed virtual void SetState(TUserState state);
    public sealed virtual ITreeNode`2<TKey, ITreeNodeViewModel> get_Container();
    protected abstract virtual void BeforeUserStateChange();
    protected abstract virtual bool IsStateChanged();
    protected bool GetState(Func`2<TNodeInfo, bool> getDefaultState, Func`2<TUserState, Nullable`1<bool>> getUserState);
    protected void SetState(Func`2<TNodeInfo, bool> getDefaultState, Action`2<TUserState, Nullable`1<bool>> setUserState, bool value, UpdateRequestOptions options);
    public sealed virtual bool get_IsExpanded();
    public sealed virtual void set_IsExpanded(bool value);
    protected void SetIsExpanded(bool value, UpdateRequestOptions options);
    public bool get_IsPrefixNode();
    public sealed virtual bool get_IsSelected();
    public sealed virtual void set_IsSelected(bool value);
    public sealed virtual bool get_IsExpandable();
    public sealed virtual ITreeNodeViewModel get_Parent();
    public sealed virtual IEnumerable`1<ITreeNodeViewModel> get_Children();
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    protected void UpdateProperty(Expression`1<Func`1<T>> param);
    private void UpdateAllProperties();
}
public class JetBrains.Common.Util.RemotableTree.TreeUpdateRequest`2 : object {
    [CompilerGeneratedAttribute]
private UpdateRequestOptions <Options>k__BackingField;
    [CompilerGeneratedAttribute]
private TKey[] <PathToNode>k__BackingField;
    [CompilerGeneratedAttribute]
private TreeNode`2<TKey, TUserState> <VisualStateRoot>k__BackingField;
    [CanBeNullAttribute]
public UpdateRequestOptions Options { get; }
    [CanBeNullAttribute]
public TKey[] PathToNode { get; }
    [CanBeNullAttribute]
public TreeNode`2<TKey, TUserState> VisualStateRoot { get; }
    [CanBeNullAttribute]
public TKey TargetNode { get; }
    public TreeUpdateRequest`2(TKey[] pathToNode, TreeNode`2<TKey, TUserState> visualStateRoot, UpdateRequestOptions options);
    [CompilerGeneratedAttribute]
public UpdateRequestOptions get_Options();
    [CompilerGeneratedAttribute]
public TKey[] get_PathToNode();
    [CompilerGeneratedAttribute]
public TreeNode`2<TKey, TUserState> get_VisualStateRoot();
    public TKey get_TargetNode();
}
public class JetBrains.Common.Util.RemotableTree.TreeUpdateResponse`2 : object {
    [CanBeNullAttribute]
public TKey[] PathToNode;
    [CanBeNullAttribute]
public TreeNode`2<TKey, TInfo> Root;
    public int TreeVersion;
    public object Data;
    [CanBeNullAttribute]
public UpdateRequestOptions Options;
}
public class JetBrains.Common.Util.RemotableTree.UpdateRequestOptions : object {
    [CompilerGeneratedAttribute]
private Nullable`1<double> <RelativeToParentExpandPercent>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <AbsoluteExpandPercent>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsSystemFoldedByDefault>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ForceExpandFirstNode>k__BackingField;
    public Nullable`1<double> RelativeToParentExpandPercent { get; }
    public Nullable`1<double> AbsoluteExpandPercent { get; }
    public bool IsSystemFoldedByDefault { get; }
    public bool ForceExpandFirstNode { get; }
    public UpdateRequestOptions(Nullable`1<double> absoluteExpandPercent, Nullable`1<double> relativeToParentExpandPercent, bool isSystemFoldedByDefault, bool forceExpandFirstNode);
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_RelativeToParentExpandPercent();
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_AbsoluteExpandPercent();
    [CompilerGeneratedAttribute]
public bool get_IsSystemFoldedByDefault();
    [CompilerGeneratedAttribute]
public bool get_ForceExpandFirstNode();
    [LocalizableAttribute("False")]
public virtual string ToString();
}
[DataContractAttribute]
public class JetBrains.Common.Util.RemotableTree.UserStateTreeData`2 : object {
    [CompilerGeneratedAttribute]
private TreeNode`2<TKey, TUserState> <Root>k__BackingField;
    [DataMemberAttribute]
public TreeNode`2<TKey, TUserState> Root { get; }
    public UserStateTreeData`2(TreeNode`2<TKey, TUserState> root);
    [CompilerGeneratedAttribute]
public TreeNode`2<TKey, TUserState> get_Root();
}
public class JetBrains.Common.Util.RemotableTree.UserStateUpdatedArgs`2 : EventArgs {
    public UserStateTreeData`2<TKey, TUserState> TreeData;
    public UserStateUpdatedArgs`2(UserStateTreeData`2<TKey, TUserState> treeData);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.Remoting.Extensions : object {
    [ExtensionAttribute]
[NotNullAttribute]
public static IRemotableReference`1<TResult> Apply(IRemotableReference`1<T> source, IDataProvider`1<T2> providerToSwitch1, IDataProvider`1<T3> providerToSwitch2, Func`4<T, IRemotableReference`1<IDataProvider`1<T2>>, IRemotableReference`1<IDataProvider`1<T3>>, TResult> builder);
    [ExtensionAttribute]
[NotNullAttribute]
public static IRemotableReference`1<TResult> Apply(IRemotableReference`1<T> source, IDataProvider`1<T2> providerToSwitch, Func`3<T, IRemotableReference`1<IDataProvider`1<T2>>, TResult> builder);
    [ExtensionAttribute]
[NotNullAttribute]
public static IRemotableReference`1<TResult> Apply(IRemotableReference`1<T> source, Func`2<T, TResult> builder);
    [ExtensionAttribute]
public static IRemotableReference`1<TResult> ApplySafe(IRemotableReference`1<T> source, Func`2<T, TResult> builder);
    [ExtensionAttribute]
public static void Execute(IRemotableReference`1<T> source, IDataProvider`1<T2> providerToSwitch1, IDataProvider`1<T3> providerToSwitch2, Action`3<T, IRemotableReference`1<IDataProvider`1<T2>>, IRemotableReference`1<IDataProvider`1<T3>>> action);
    [ExtensionAttribute]
public static void Execute(IRemotableReference`1<T> source, IDataProvider`1<T2> providerToSwitch, Action`2<T, IRemotableReference`1<IDataProvider`1<T2>>> action);
    [ExtensionAttribute]
public static void Do(IRemotableReference`1<T> source, TArg arg, Action`2<T, TArg> action);
    [ExtensionAttribute]
public static void Do(IRemotableReference`1<T> source, Action`1<T> action);
    [ExtensionAttribute]
public static void SetSource(IRemotableReference`1<IDataProxy`1<T>> proxy, IRemotableReference`1<IDataProvider`1<T>> source);
    [ExtensionAttribute]
public static void SetSource(IRemotableReference`1<IThreadSwitchProxy`1<T>> proxy, IRemotableReference`1<IThreadSwitch`1<T>> source);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static IRemoteCommunicator GetComm(IRemotablePair`1<T> o);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static IRemoteCommunicator GetComm(IRemotableReference`1<T> o);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<TResult> Apply(IRemotableReference`1<T> source, Func`2<T, IRemotableReference`1<IAsyncDataProvider`1<TResult>>> builder);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<TResult> ApplySafe(IRemotableReference`1<T> source, Func`2<T, IRemotableReference`1<IAsyncDataProvider`1<TResult>>> builder);
    [ExtensionAttribute]
private static IThreadSwitch`1<TResult> ApplyReturnStream(IRemotableReference`1<T> source, Func`2<T, IRemotableReference`1<IThreadSwitch`1<TResult>>> builder);
    [ExtensionAttribute]
public static IThreadSwitch`1<TResult> BuildReturn(IRemoteCommunicator comm, Func`1<IRemotableReference`1<IThreadSwitch`1<TResult>>> builder);
    [ExtensionAttribute]
private static IThreadSwitch`1<TResult> BuildReturnStream(IRemoteCommunicator comm, Func`1<IRemotableReference`1<IThreadSwitch`1<TResult>>> builder);
    [ExtensionAttribute]
public static IRemotablePair`1<T> CreateRemotablePair(IRemotableReference`1<T> remoteReference, T value);
    [ExtensionAttribute]
[NotNullAttribute]
public static IRemotableReference`1<IThreadSwitch`1<T>> SwitchRemote(IDataProviderBase`1<T> source, IRemoteCommunicator comm);
    [ExtensionAttribute]
[NotNullAttribute]
public static IRemotableReference`1<IThreadSwitch`1<T>> SwitchRemoteIfPossible(IDataProviderBase`1<T> source, IRemoteCommunicator comm);
    [ExtensionAttribute]
public static IRemotableReference`1<IThreadSwitch`1<IReadOnlyCollection`1<T>>> SwitchRemoteCollectionIfPossible(IDataProvider`1<IReadOnlyCollection`1<T>> source, IRemoteCommunicator comm);
    [ExtensionAttribute]
[NotNullAttribute]
public static IRemotableReference`1<IThreadSwitch`1<T>> SwitchStreamRemote(IDataProviderBase`1<T> source, IRemoteCommunicator comm);
    [ExtensionAttribute]
[NotNullAttribute]
public static IRemotableReference`1<IThreadSwitch`1<T>> SwitchStreamRemoteIfPossible(IDataProviderBase`1<T> source, IRemoteCommunicator comm);
    [ExtensionAttribute]
public static IRemotableReference`1<IDataProvider`1<T>> SwitchRemoteToMainThread(IDataProviderBase`1<T> src, IRemoteCommunicator comm);
    [ExtensionAttribute]
public static IRemotableReference`1<IDataProvider`1<T>> SwitchRemoteToMainThreadIfPossible(IDataProvider`1<T> src, IRemoteCommunicator comm);
    [ExtensionAttribute]
public static IDataProvider`1<T> SwitchLocalToMainThreadIfRemote(IRemotableReference`1<IDataProvider`1<T>> source);
    [ExtensionAttribute]
public static IRemotableReference`1<IDataProvider`1<T>> SwitchStreamRemoteToMainThread(IDataProviderBase`1<T> src, IRemoteCommunicator comm);
    [ExtensionAttribute]
[NotNullAttribute]
public static IRemotableReference`1<IAsyncDataProvider`1<T>> SwitchRemoteToCurrentThread(IDataProviderBase`1<T> source, IRemoteCommunicator comm);
    private static IThreadSwitchEx`1<T> SwitchRecycle(IDataProviderBase`1<BinaryReader> readerSwitch, Action`2<T, BinaryReader> restoreAction);
    [ExtensionAttribute]
private static IRemotableReference`1<IThreadSwitch`1<TB>> SwitchRemote(IDataProviderBase`1<TA> source, IRemoteCommunicator comm, Action`2<InterProcessPackage`1<TA>, BinaryWriter> fillAction, Func`2<BinaryReader, InterProcessPackage`1<TB>> restoreAction);
    [ExtensionAttribute]
private static IRemotableReference`1<IAsyncDataProvider`1<TB>> SwitchRemote(IDataProviderBase`1<TA> source, IRemoteCommunicatorInternal comm, Action`3<BinaryWriter, BinaryFormatter, InterProcessPackage`1<TA>> fillAction, Func`3<BinaryReader, BinaryFormatter, InterProcessPackage`1<TB>> readAction);
    [ExtensionAttribute]
public static IRemotableReference`1<IThreadSwitch`1<IReadOnlyCollection`1<T>>> SwitchRemoteCollection(IDataProvider`1<IReadOnlyCollection`1<T>> source, IRemoteCommunicator comm);
    [ExtensionAttribute]
public static IThreadSwitch`1<T> SwitchStreamLocalIfRemote(IRemotableReference`1<IDataProviderBase`1<T>> source);
    [ExtensionAttribute]
public static IThreadSwitch`1<T> SwitchStreamLocal(IRemotableReference`1<IDataProviderBase`1<T>> source);
    [ExtensionAttribute]
public static IThreadSwitch`1<T> SwitchLocal(IRemotableReference`1<IThreadSwitch`1<T>> remoteSwitch);
    [ExtensionAttribute]
public static IThreadSwitch`1<T> SwitchLocal(IRemotableReference`1<IThreadSwitchEx`1<T>> remoteSwitch);
    [ExtensionAttribute]
public static IThreadSwitch`1<T> SwitchLocal(IRemotableReference`1<IDataProviderBase`1<T>> source);
    [ExtensionAttribute]
public static IThreadSwitch`1<T> SwitchLocalIfRemote(IRemotableReference`1<IDataProviderBase`1<T>> source);
    [ExtensionAttribute]
public static IDataProvider`1<T> SwitchLocalToMainThread(IRemotableReference`1<IThreadSwitch`1<T>> remoteSwitch);
    [ExtensionAttribute]
public static IDataProvider`1<T> SwitchLocalToMainThread(IRemotableReference`1<IDataProviderBase`1<T>> source);
    [ExtensionAttribute]
public static IThreadSwitch`1<IRemotableReference`1<T>> SwitchLocalByRef(IRemotableReference`1<IDataProvider`1<T>> source);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<T> SwitchLocalToCommunicationThread(IRemotableReference`1<IDataProviderBase`1<T>> source);
    [ExtensionAttribute]
public static IRemotableReference`1<T> CreateRemoteReference(IRemoteCommunicator comm, T value);
    [ExtensionAttribute]
public static IRemotableReference`1<DataPipeLifetime> SwitchRemote(DataPipeLifetime lifetime, IRemoteCommunicator comm);
    [ExtensionAttribute]
public static IRemotableReference`1<DataPipeLifetime> SwitchRemoteIfPossible(DataPipeLifetime lifetime, IRemoteCommunicator comm);
    [ExtensionAttribute]
public static IRemotableReference`1<DataPipeLifetime> SwitchRemote(DataPipeLifetime lifetime, IRemoteCommunicator comm, TimeSpan terminationTimeout);
    private static Action`1<IThreadSwitch`1<bool>> CreateTerminateRemoteLifetimeAction(IRemotableReference`1<LifetimeDefinition> remoteLifetimeDefinition, IRemotableReference`1<IDataController`1<bool>> remoteIsTerminated);
    [ExtensionAttribute]
[NotNullAttribute]
public static IRemotableReference`1<T> GetLocalOrRemoteReference(IRemotablePair`1<T> pair);
    [ExtensionAttribute]
public static void EnsureSizeAtLeast(IResizeablePointer pointer, int size);
    [ExtensionAttribute]
public static TR Debug(T t, Func`2<T, TR> action);
    [ExtensionAttribute]
public static void SetLocalSource(IRemotableReference`1<IProxyContainer`1<T>> proxy, IProviderContainer`1<T> source);
    [ExtensionAttribute]
public static void SetLocalSource(IRemotableReference`1<IProxyContainer`1<T>> proxy, IDataProvider`1<T> source);
    [ExtensionAttribute]
public static void SetLocalAndRemoteSource(IRemotableReference`1<IProxyContainer`1<T>> remoteProxy, IProxyContainer`1<T> localProxy, IDataProvider`1<T> source);
    [ExtensionAttribute]
public static void SetLocalSource(IRemotableReference`1<IDataProxy`1<T>> proxy, IDataProvider`1<T> source);
    [ExtensionAttribute]
public static void SetLocalCollectionSource(IRemotableReference`1<IDataProxy`1<IReadOnlyCollection`1<T>>> proxy, IDataProvider`1<IReadOnlyCollection`1<T>> source);
    [ExtensionAttribute]
public static IRemotableReference`1<T> AdaptToCommunicator(IRemotableReference`1<T> reference, IRemoteCommunicator comm);
}
public class JetBrains.Common.Util.Remoting.ExternalStorage : object {
    private static ILogger ourLogger;
    private Action`1<Exception> myRemoteExceptionHandler;
    private IRemoteCommunicator myRemoteCommunicator;
    [CompilerGeneratedAttribute]
private WaitHandle <Exited>k__BackingField;
    [CompilerGeneratedAttribute]
private Process <Process>k__BackingField;
    public IRemoteCommunicator RemoteCommunicator { get; }
    public WaitHandle Exited { get; }
    public Process Process { get; }
    private ExternalStorage(Action`1<Exception> remoteExceptionHandler, IRemoteCommunicator remoteCommunicator, WaitHandle exited, Process process);
    private static ExternalStorage();
    public sealed virtual IRemoteCommunicator get_RemoteCommunicator();
    public sealed virtual IRemoteCommunicator CreateCommunicator(Lifetime lifetime);
    [CompilerGeneratedAttribute]
public sealed virtual WaitHandle get_Exited();
    [CompilerGeneratedAttribute]
public sealed virtual Process get_Process();
    [NotNullAttribute]
public static IExternalStorage Create(Lifetime lifetime, Action`1<Exception> remoteExceptionHandler, PlatformKind platform);
    [NotNullAttribute]
public static IExternalStorage Create(Lifetime lifetime, ExternalStorageLogFileOrigin externalStorageLogFile, Action`1<Exception> remoteExceptionHandler, PlatformKind platform);
    private static void AppendLogFileAndLevel(ExternalStorageLogFileOrigin logFileOrigin, CommandLineBuilderJet arguments);
}
public class JetBrains.Common.Util.Remoting.ExternalStorageLogFileOrigin : object {
    public static ExternalStorageLogFileOrigin NoLogFile;
    public FileSystemPath File;
    public Nullable`1<LoggingLevel> Level;
    public bool IsEnabled { get; }
    private ExternalStorageLogFileOrigin(FileSystemPath file, Nullable`1<LoggingLevel> level);
    private static ExternalStorageLogFileOrigin();
    public static ExternalStorageLogFileOrigin BuildDefault();
    public static ExternalStorageLogFileOrigin BuildWithTimestamp();
    private static ExternalStorageLogFileOrigin BuildCore(string suffix);
    public bool get_IsEnabled();
}
internal class JetBrains.Common.Util.Remoting.ExternalStorageProcessRunner : object {
    private static ILogger ourLogger;
    private static string RemoteWorkspacePath;
    private static IDictionary`2<PlatformKind, ExternalStorageProcessRunner> ourProcessRunners;
    private FileSystemPath myExecutable;
    private Nullable`1<MachineId> myMachineId;
    private static ExternalStorageProcessRunner();
    private ExternalStorageProcessRunner(FileSystemPath executable, Nullable`1<MachineId> machineId);
    private static FileSystemPath GetFileName(PlatformKind platform);
    private static FileSystemPath GetDirectoryPathFromCodeBase();
    public static Process RunExternalProcess(PlatformKind platform, string arguments);
    private Process RunExternalProcess(string arguments);
}
public interface JetBrains.Common.Util.Remoting.IExternalStorage {
    public IRemoteCommunicator RemoteCommunicator { get; }
    public WaitHandle Exited { get; }
    public Process Process { get; }
    public abstract virtual IRemoteCommunicator get_RemoteCommunicator();
    public abstract virtual IRemoteCommunicator CreateCommunicator(Lifetime lifetime);
    public abstract virtual WaitHandle get_Exited();
    public abstract virtual Process get_Process();
}
public interface JetBrains.Common.Util.Remoting.ILocked`1 {
    public abstract virtual TResult Apply(Func`2<T, TResult> func);
}
internal class JetBrains.Common.Util.Remoting.Impl.GarbageCollector : object {
    private IGarbageProducer[] myGarbageProducers;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) myRequestCounter;
    private int myLastSeenRequestNumber;
    private int myLastRequestActualGcCount;
    private TimeSpan myPeriod;
    private Timer myTimer;
    private static TimeSpan ourDefaultPeriod;
    public TimeSpan Period { get; public set; }
    public GarbageCollector(Lifetime lifetime, IGarbageProducer[] garbageProducers);
    private static GarbageCollector();
    private void TimerTask(object state);
    public sealed virtual void RequestGC();
    public sealed virtual TimeSpan get_Period();
    public sealed virtual void set_Period(TimeSpan value);
}
internal abstract class JetBrains.Common.Util.Remoting.Impl.HostsAndProxies.InterProcessHostBase`1 : DataProvider`1<T> {
    private RemoteRefId myProxyId;
    private LocalRefId myHostId;
    private ICommunicatorForHost myComm;
    private AsyncDataControllerGroup myAsyncGroup;
    protected InterProcessPackage`1<T> NextPackageToUpdate;
    private IAttributesBag myAttributes;
    public IAsyncController Controller { get; }
    public IAttributesBag Attributes { get; }
    public RemoteRefId RemoteProxyId { get; }
    protected InterProcessHostBase`1(ICommunicatorForHost comm, RemoteRefId proxyId, LocalRefId hostId);
    public virtual IAsyncController get_Controller();
    protected virtual void ClearValue();
    public virtual IAttributesBag get_Attributes();
    protected virtual void OnActivated();
    protected virtual void OnDeactivated();
    public virtual IDataProvider`1<IEnumerable`1<ProgressProvider>> GetProgressProvider();
    public abstract virtual void ReadNextPackage(BinaryReader reader, BinaryFormatter binaryFormatter);
    public sealed virtual void ProcessPackage();
    public sealed virtual void Cancel(ICancelArgs args);
    public sealed virtual RemoteRefId get_RemoteProxyId();
    [LocalizableAttribute("False")]
public virtual string ToString();
}
[ExtensionAttribute]
internal static class JetBrains.Common.Util.Remoting.Impl.HostsAndProxies.InterProcessPackage : object {
    [ExtensionAttribute]
public static InterProcessPackageType ToInterProcessPackageType(InvalidateMode mode);
    public static InterProcessPackage`1<T> Update(T value, IAttributesBag attributes);
    public static InterProcessPackage`1<T> Resurrect(IAttributesBag attributes);
    public static InterProcessPackage`1<T> Invalidate(InvalidateMode mode);
    public static InterProcessPackage`1<T> Empty();
}
internal class JetBrains.Common.Util.Remoting.Impl.HostsAndProxies.InterProcessPackage`1 : ValueType {
    public InterProcessPackageType Type;
    public T Value;
    public IAttributesBag Attributes;
    [LocalizableAttribute("False")]
public virtual string ToString();
}
internal enum JetBrains.Common.Util.Remoting.Impl.HostsAndProxies.InterProcessPackageType : Enum {
    public int value__;
    public static InterProcessPackageType Empty;
    public static InterProcessPackageType Update;
    public static InterProcessPackageType Resurrect;
    public static InterProcessPackageType Invalidate;
    public static InterProcessPackageType Cleanup;
}
internal abstract class JetBrains.Common.Util.Remoting.Impl.HostsAndProxies.InterProcessProxyBase`1 : object {
    [NotNullAttribute]
private IDataProviderInternal`1<T> mySource;
    private ICommunicatorForProxy myComm;
    private RemoteRefId myHostId;
    private LocalRefId myProxyId;
    private bool myIsActive;
    protected ICommunicatorForProxy Comm { get; }
    protected RemoteRefId HostId { get; }
    protected bool IsActive { get; }
    public bool NeedInvalidateOnActivation { get; }
    protected InterProcessProxyBase`1(IDataProviderBase`1<T> source, ICommunicatorForProxy comm, RemoteRefId hostId, LocalRefId proxyId);
    protected ICommunicatorForProxy get_Comm();
    protected RemoteRefId get_HostId();
    public virtual void OnActivated();
    public virtual void OnDeactivated();
    protected bool get_IsActive();
    protected abstract virtual void OnSourceChanged(InterProcessPackage`1<T> newValue);
    public sealed virtual IDataProvider`1<ProgressProvider[]> GetProgressesProvider();
    public sealed virtual bool get_NeedInvalidateOnActivation();
    public sealed virtual void OnValueUpdated(T value, IAttributesBag attributes);
    public sealed virtual void OnInvalidate(InvalidateMode mode);
    public sealed virtual void OnResurrect(IAttributesBag attributes);
    [LocalizableAttribute("False")]
public virtual string ToString();
    public sealed virtual void OnCancelComputations(ICancelArgs cancelArgs);
}
internal static class JetBrains.Common.Util.Remoting.Impl.HostsAndProxies.RemoteProgressLoader : object {
    internal static IDataProvider`1<IEnumerable`1<ProgressProvider>> GetProgress(ICommunicatorForHost comm, RemoteRefId proxyId);
    private static IDataProvider`1<IRemotableReference`1[]> Builder(ICommunicatorForHost comm, LocalRefId proxyId);
}
internal class JetBrains.Common.Util.Remoting.Impl.HostsAndProxies.SimpleHost`1 : InterProcessHostBase`1<T> {
    private Func`3<BinaryReader, BinaryFormatter, InterProcessPackage`1<T>> myReadValue;
    public SimpleHost`1(ICommunicatorForHost remoteComm, RemoteRefId proxyId, Func`3<BinaryReader, BinaryFormatter, InterProcessPackage`1<T>> readValue, LocalRefId hostId);
    public virtual void ReadNextPackage(BinaryReader reader, BinaryFormatter binaryFormatter);
}
internal class JetBrains.Common.Util.Remoting.Impl.HostsAndProxies.SimpleProxy`1 : InterProcessProxyBase`1<T> {
    private Action`3<BinaryWriter, BinaryFormatter, InterProcessPackage`1<T>> myFillAction;
    public SimpleProxy`1(IDataProviderBase`1<T> source, ICommunicatorForProxy comm, RemoteRefId hostId, Action`3<BinaryWriter, BinaryFormatter, InterProcessPackage`1<T>> fillAction, LocalRefId proxyId);
    protected virtual void OnSourceChanged(InterProcessPackage`1<T> newValue);
}
internal interface JetBrains.Common.Util.Remoting.Impl.IRemoteCommunicatorInternal {
    public string Id { get; }
    public abstract virtual string get_Id();
    public abstract virtual IRemotableReference`1<IAsyncDataProvider`1<TB>> SwitchRemote(IDataProviderBase`1<TA> source, Action`3<BinaryWriter, BinaryFormatter, InterProcessPackage`1<TA>> fillAction, Func`3<BinaryReader, BinaryFormatter, InterProcessPackage`1<TB>> readValue);
    public abstract virtual object GetObject(LocalRefId localId);
}
internal interface JetBrains.Common.Util.Remoting.Impl.IRemoteReference`1 {
    public RemoteRefId Id { get; }
    public abstract virtual RemoteRefId get_Id();
}
internal class JetBrains.Common.Util.Remoting.Impl.LocalRefId : ValueType {
    private ulong myValue;
    internal ulong Value { get; }
    internal LocalRefId(ulong id);
    public sealed virtual bool Equals(LocalRefId other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    internal ulong get_Value();
    public static LocalRefId op_Explicit(ulong id);
    public static LocalRefId op_Explicit(RefId r);
    public static bool op_Equality(LocalRefId left, LocalRefId right);
    public static bool op_Inequality(LocalRefId left, LocalRefId right);
    public virtual string ToString();
}
internal class JetBrains.Common.Util.Remoting.Impl.Locked`1 : object {
    private Func`1<T> myGetData;
    private IInterProcessLock myLock;
    private string myId;
    public IInterProcessLock Lock { get; }
    internal Locked`1(IInterProcessLock _lock, Func`1<T> getData, string id);
    public IInterProcessLock get_Lock();
    public sealed virtual TResult Apply(Func`2<T, TResult> func);
}
internal class JetBrains.Common.Util.Remoting.Impl.NamedPipesComm : object {
    private static PipesLogger ourLogger;
    private IRemoteCommandHandler myCommandHandler;
    private ReaderWriterLockSlim myTerminationLock;
    [ThreadStaticAttribute]
private static ThreadBuffer ourThreadBuffer;
    private BinaryReader myBinaryReader;
    private int myWriteOperationsCounter;
    private PipeStream myOutgoingPipe;
    private SerializationContext mySerializationContext;
    private BinaryFormatter myBinaryFormatter;
    private AsyncCallback myPipeEndWriteCallback;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) myIsDisposed;
    private Byte[] myReadBuffer;
    private PipeStream myIncomingPipe;
    private string myPipeName;
    private static TimeSpan ourTimeout;
    private static int ConnectionTimeout;
    public string Id { get; }
    public NamedPipesComm(string pipeName);
    private static NamedPipesComm();
    private void EnterReadLock(T1 t1, T2 t2);
    [UsedImplicitlyAttribute]
private void EnterReadLock(T1 t1);
    private void ExitReadLock(T1 t1, T2 t2);
    private void ExitReadLock(T1 t1);
    private void EnterWriteLock();
    private void ExitWriteLock();
    private static ThreadBuffer GetThreadBuffer();
    public sealed virtual void Cancel(RemoteRefId hostId, ICancelArgs args);
    public sealed virtual void UpdateValue(RemoteRefId hostId, Action`2<BinaryWriter, BinaryFormatter> writeAction);
    public sealed virtual void Init(Lifetime lifetime, IRemoteCommandHandler commandHandler, SerializationContext serializationContext, bool isClient);
    public sealed virtual string get_Id();
    private string GetIncomingPipeName(bool isClient);
    private string GetOutgoingPipeName(bool isClient);
    private void InitServer();
    private void Init();
    private void InitClient();
    private void InterProcessCall(RemoteRefId targetId, Commands cmd, object param);
    private void InterProcessCallCore(RemoteRefId targetId, Commands cmd, Action`2<BinaryWriter, BinaryFormatter> serializeAction);
    private PipeLocksController GetLockController();
    private void BeginReadPipe(T moniker);
    private void ProcessMessage(Commands cmd, LocalRefId target, BinaryReader reader, IPipeLocksController locksController);
    private void CreateHost(CreateHostData data);
    [UsedImplicitlyAttribute]
public void DoCreateHost(RemoteRefId remoteProxyId, LocalRefId localHostId, Func`3<BinaryReader, BinaryFormatter, InterProcessPackage`1<T>> readValue);
    [UsedImplicitlyAttribute]
public void DoResolveProxyProvider(LocalRefId localHostId, LocalRefId localResolveDataProxyId);
    [UsedImplicitlyAttribute]
public void DoBuild(LocalRefId localIdForResult, Func`1<TResult> builder);
    [UsedImplicitlyAttribute]
public void DoBuildReturn(RemoteRefId remoteResolveId, Func`1<IRemotableReference`1<IAsyncDataProvider`1<TResult>>> builder);
    private void OnPipeIsBroken();
    private void SerializeData(BinaryWriter writer, object data);
    private static MethodInfo GetInterProcessGenericMethod(Type className, string methodName, Type[] parametricTypes);
    private object DeserializeData(Stream stream);
    public sealed virtual void CreateSimpleHost(RemoteRefId hostId, LocalRefId proxyId, Func`3<BinaryReader, BinaryFormatter, InterProcessPackage`1<T>> valueReader);
    public sealed virtual void Build(RemoteRefId objectId, Func`1<T> builder);
    public sealed virtual void BuildReturn(LocalRefId resultId, Func`1<IRemotableReference`1<IAsyncDataProvider`1<T>>> builder);
    public sealed virtual void Execute(Action action);
    public sealed virtual void ResolveProxyProvider(RemoteRefId hostId, RemoteRefId proxyProviderId);
    public sealed virtual void OnActivated(RemoteRefId proxyId);
    public sealed virtual void OnDeactivated(RemoteRefId proxyId);
    public sealed virtual void OnRemoteException(Exception e);
    public sealed virtual void RemoveObjectReference(RemoteRefId objectId);
    public sealed virtual void RemoveProxy(RemoteRefId proxyId);
    private void WaitForWriteOperationsCompletion(TimeSpan timeout);
    private void Dispose();
    [CompilerGeneratedAttribute]
private void <EnterWriteLock>b__7_0();
    [CompilerGeneratedAttribute]
private void <Init>b__33_0(IAsyncResult ar);
}
internal class JetBrains.Common.Util.Remoting.Impl.ObjectReferenceProcessor : object {
    private int myNextLocalId;
    private int myNextRemoteId;
    private static PipesLogger myLogger;
    private Dictionary`2<LocalRefId, object> myObjects;
    private Dictionary`2<RemoteRefId, WeakReference> myRemoteReferences;
    private WeakToStrongDictionary`2<object, LocalRefId> myStableObjects;
    private ICommunicatorForObjectTracker myComm;
    public int ObjectRefsCount { get; }
    public ObjectReferenceProcessor(Lifetime lifetime, ICommunicatorForObjectTracker comm);
    private static ObjectReferenceProcessor();
    private void ClearAll();
    public sealed virtual LocalRefId AddObjectRef(object targetObject);
    public sealed virtual LocalRefId GetStableObjectRef(object targetObject);
    private void AddObjectRefCore(LocalRefId id, object targetObject);
    public sealed virtual void AddObjectRef(LocalRefId id, object targetObject);
    public sealed virtual RemoteReference`1<T> GetOrCreateRemoteObjectRef(RemoteRefId id);
    public sealed virtual object GetObject(LocalRefId id);
    public sealed virtual void CollectGarbage();
    public sealed virtual void RemoveObject(LocalRefId id);
    public sealed virtual int get_ObjectRefsCount();
    public sealed virtual int GetObjectsCount();
    public sealed virtual LocalRefId NewLocalId();
    public sealed virtual RemoteRefId NewRemoteId();
}
internal class JetBrains.Common.Util.Remoting.Impl.ReadonlyPointer : object {
    [CompilerGeneratedAttribute]
private IntPtr <Pointer>k__BackingField;
    public IntPtr Pointer { get; }
    public ReadonlyPointer(int size);
    [CompilerGeneratedAttribute]
public sealed virtual IntPtr get_Pointer();
    protected virtual override void Finalize();
}
internal static class JetBrains.Common.Util.Remoting.Impl.ReferenceIdUtils : object {
    private static int VersionBitsCount;
    private static int VersionShift;
    private static ulong MaxId;
    private static ulong MaxVersion;
    private static ulong IdMask;
    public static ulong Null;
    public static LocalRefId LocalNull;
    public static RemoteRefId RemoteNull;
    private static ReferenceIdUtils();
    public static LocalRefId CreateLocal(UInt32 id);
    public static RemoteRefId CreateRemote(UInt32 id);
    public static LocalRefId IncrementVersion(LocalRefId id);
    public static bool AreEqualIgnoreVersion(RemoteRefId id1, RemoteRefId id2);
}
internal class JetBrains.Common.Util.Remoting.Impl.RefId : ValueType {
    private ulong myValue;
    internal ulong Value { get; }
    public static LocalRefId Null { get; }
    internal RefId(ulong id);
    public sealed virtual bool Equals(RefId other);
    public static RefId op_Implicit(LocalRefId r);
    public static RefId op_Explicit(ulong v);
    public static RefId op_Implicit(RemoteRefId r);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    internal ulong get_Value();
    public static bool op_Equality(RefId left, RefId right);
    public static bool op_Inequality(RefId left, RefId right);
    public static LocalRefId get_Null();
    public virtual string ToString();
}
internal class JetBrains.Common.Util.Remoting.Impl.RemotablePair`1 : object {
    [NotNullAttribute]
private IRemotableReference`1<T> myFirst;
    [NotNullAttribute]
private IRemotableReference`1<T> mySecond;
    public T Value { get; }
    public IRemotableReference`1<T> RemoteReference { get; }
    public IRemotableReference`1<T> LocalReference { get; }
    public RemotablePair`1(IRemotableReference`1<T> first, IRemotableReference`1<T> second);
    public sealed virtual T get_Value();
    public sealed virtual IRemotableReference`1<T> get_RemoteReference();
    public sealed virtual IRemotableReference`1<T> get_LocalReference();
}
internal class JetBrains.Common.Util.Remoting.Impl.RemotableReference`1 : object {
    [NotNullAttribute]
protected IRemotableReferenceCore`1<T> Reference;
    [CanBeNullAttribute]
protected IRemoteCommunicator Comm;
    public T Value { get; }
    public bool IsLocal { get; }
    public RemotableReference`1(T value);
    public RemotableReference`1(RemoteReference`1<T> reference, IRemoteCommunicator comm);
    public RemotableReference`1(SerializationInfo info, StreamingContext context);
    public sealed virtual T get_Value();
    public sealed virtual IRemoteCommunicator GetComm();
    public sealed virtual RemoteRefId GetRemoteId();
    public sealed virtual bool get_IsLocal();
    protected virtual LocalRefId GenerateId(T value, IObjectReferenceProcessor referenceProcessor);
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
internal class JetBrains.Common.Util.Remoting.Impl.RemotableReferenceWithHardlink`1 : RemotableReference`1<T> {
    [UsedImplicitlyAttribute]
private object myHardlink;
    public RemotableReferenceWithHardlink`1(RemoteReference`1<T> reference, IRemoteCommunicator comm, object hardlink);
    public RemotableReferenceWithHardlink`1(SerializationInfo info, StreamingContext context);
}
internal class JetBrains.Common.Util.Remoting.Impl.RemoteCommunicator : object {
    private IObjectReferenceProcessor myReferenceProcessor;
    private Action`1<Exception> myRemoteExceptionHandler;
    private Dictionary`2<LocalRefId, HostReference> myHosts;
    private HashSet`1<IInterProcessHost> myActivatedHosts;
    private IStaThreadDispatcher myMainDispatcher;
    private Dictionary`2<LocalRefId, object> myLocalReturnProxies;
    private object myLock;
    private IGarbageCollector myGarbageCollector;
    private Dictionary`2<LocalRefId, IInterProcessProxy> myProxies;
    private static PipesLogger myLogger;
    private IRemoteCommandExecutor myCommandExecutor;
    private bool myIsClient;
    private Signal`1<IRemoteCommunicator> myConnectionBroken;
    private bool myIsAlive;
    private string myId;
    private DataPipeLifetime myDataPipeLifetime;
    private IStaThreadDispatcher Dispatcher { get; }
    public TimeSpan GcPeriod { get; public set; }
    public string Id { get; }
    public bool IsClient { get; }
    public bool IsAlive { get; }
    public ISignal`1<IRemoteCommunicator> ConnectionBroken { get; }
    public int LocalReturnProxiesCount { get; }
    public int ProxiesCount { get; }
    public int HostsCount { get; }
    internal RemoteCommunicator(Lifetime lifetime, Action`1<Exception> remoteExceptionHandler, IRemoteCommandsExecutorInternal commandExecutor, bool isClient);
    private static RemoteCommunicator();
    private string CommunicatorSide();
    private void ClearAll();
    private IStaThreadDispatcher get_Dispatcher();
    public sealed virtual void CollectGarbage();
    public sealed virtual int GetObjectsCount();
    public sealed virtual TimeSpan get_GcPeriod();
    public sealed virtual void set_GcPeriod(TimeSpan value);
    private IAsyncDataProxy`1<TResult> BuildReturnCore(bool isStream, Func`1<IRemotableReference`1<IAsyncDataProvider`1<TResult>>> builder);
    public sealed virtual IAsyncDataProxy`1<TResult> BuildReturn(Func`1<IRemotableReference`1<IAsyncDataProvider`1<TResult>>> builder);
    public sealed virtual IAsyncDataProxy`1<TResult> BuildReturnStream(Func`1<IRemotableReference`1<IAsyncDataProvider`1<TResult>>> builder);
    public sealed virtual IRemotableReference`1<TResult> Build(Func`1<TResult> builder, object hardlink);
    public sealed virtual void ExecuteRemote(Action builder);
    public sealed virtual IRemotableReference`1<IAsyncDataProvider`1<TB>> SwitchRemote(IDataProviderBase`1<TA> source, Action`3<BinaryWriter, BinaryFormatter, InterProcessPackage`1<TA>> fillAction, Func`3<BinaryReader, BinaryFormatter, InterProcessPackage`1<TB>> readValue);
    public sealed virtual string get_Id();
    public sealed virtual object GetObject(LocalRefId localId);
    public sealed virtual bool get_IsClient();
    public sealed virtual bool get_IsAlive();
    public sealed virtual ISignal`1<IRemoteCommunicator> get_ConnectionBroken();
    private void AddProxy(LocalRefId id, IInterProcessProxy proxy);
    [CanBeNullAttribute]
public sealed virtual IInterProcessHost GetHost(LocalRefId id);
    private void AddReturnProxy(LocalRefId localProxyId, IAsyncDataProxy`1<T> proxy);
    private void ResolveProxyOnMainThread(LocalRefId resolveProxyId, IAsyncDataProvider`1<T> hostProvider);
    private void AddHost(LocalRefId id, IInterProcessHost host);
    public sealed virtual void CreateSimpleHost(LocalRefId hostId, RemoteRefId proxyId, Func`3<BinaryReader, BinaryFormatter, InterProcessPackage`1<T>> valueReader);
    public sealed virtual void Build(LocalRefId objectId, Func`1<T> builder);
    private void DoBuildObjectRefDispatcher(LocalRefId localIdForResult, Func`1<TResult> builder);
    public sealed virtual void BuildReturn(RemoteRefId resultId, Func`1<IRemotableReference`1<IAsyncDataProvider`1<T>>> builder);
    private void DoBuildRemoteDispatcher(RemoteRefId remoteResolveId, Func`1<IRemotableReference`1<IAsyncDataProvider`1<T>>> builder);
    public sealed virtual void Execute(Action action);
    public sealed virtual void ResolveProxyProvider(LocalRefId hostId, LocalRefId proxyProviderId);
    [CanBeNullAttribute]
public sealed virtual IInterProcessProxy GetProxy(LocalRefId id);
    public sealed virtual void OnActivated(LocalRefId proxyId);
    public sealed virtual void OnDeactivated(LocalRefId proxyId);
    public sealed virtual void OnRemoteException(Exception e);
    public sealed virtual void RemoveObjectReference(LocalRefId objectId);
    public sealed virtual void OnObjectReferenceRemoved(RemoteRefId id);
    private void DoRemoveProxy(LocalRefId proxyId);
    public sealed virtual void RemoveProxy(LocalRefId proxyId);
    public sealed virtual void ConnectionIsBroken(bool duringDispose);
    public sealed virtual void ActivateHost(IInterProcessHost host);
    public sealed virtual void DeactivateHost(IInterProcessHost host);
    public sealed virtual int get_LocalReturnProxiesCount();
    public sealed virtual int get_ProxiesCount();
    public sealed virtual int get_HostsCount();
    public sealed virtual void OnLogEvent(LogEvent logEvent);
}
public class JetBrains.Common.Util.Remoting.Impl.RemoteCommunicatorException : Exception {
    private string myFullText;
    public RemoteCommunicatorException(string message, string fullText);
    public virtual string ToString();
}
internal class JetBrains.Common.Util.Remoting.Impl.RemoteReference`1 : object {
    [CompilerGeneratedAttribute]
private RemoteRefId <Id>k__BackingField;
    public RemoteRefId Id { get; }
    public RemoteReference`1(RemoteRefId id);
    [CompilerGeneratedAttribute]
public sealed virtual RemoteRefId get_Id();
}
[ExtensionAttribute]
internal static class JetBrains.Common.Util.Remoting.Impl.RemoteReferenceHelpers : object {
    [ExtensionAttribute]
public static IRemotableReference`1<T> ToRemotable(RemoteReference`1<T> r, IRemoteCommunicator comm, object hardlink);
}
internal class JetBrains.Common.Util.Remoting.Impl.RemoteRefId : ValueType {
    private ulong myValue;
    internal ulong Value { get; }
    public static RemoteRefId Null { get; }
    internal RemoteRefId(ulong id);
    public sealed virtual bool Equals(RemoteRefId other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    internal ulong get_Value();
    public static RemoteRefId op_Explicit(ulong id);
    public static RemoteRefId op_Explicit(RefId r);
    public static bool op_Equality(RemoteRefId left, RemoteRefId right);
    public static bool op_Inequality(RemoteRefId left, RemoteRefId right);
    public static RemoteRefId get_Null();
    public virtual string ToString();
}
internal class JetBrains.Common.Util.Remoting.Impl.ResizeablePointer : object {
    [CompilerGeneratedAttribute]
private IntPtr <Pointer>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Size>k__BackingField;
    public IntPtr Pointer { get; private set; }
    public int Size { get; private set; }
    [CompilerGeneratedAttribute]
public sealed virtual IntPtr get_Pointer();
    [CompilerGeneratedAttribute]
private void set_Pointer(IntPtr value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_Size();
    [CompilerGeneratedAttribute]
private void set_Size(int value);
    public sealed virtual void Allocate(int size);
    public sealed virtual void Dispose();
}
internal static class JetBrains.Common.Util.Remoting.Impl.Serialization.PipeSerialization : object {
    public static PipesLogger Logger;
    private static PipeSerialization();
    [NotNullAttribute]
public static object PackIntoSerializable(object value);
    [CanBeNullAttribute]
public static object ExtractFromSerializable(Type type, object data);
}
internal class JetBrains.Common.Util.Remoting.Impl.Serialization.SerializableClass : object {
    public object Obj;
    internal SerializableClass(object bobject);
    internal SerializableClass(SerializationInfo info, StreamingContext context);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
}
internal class JetBrains.Common.Util.Remoting.Impl.Serialization.SerializableComm : object {
    public static SerializableComm Instance;
    public IRemoteCommunicator Comm;
    public SerializableComm(SerializationInfo info, StreamingContext context);
    private static SerializableComm();
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public class JetBrains.Common.Util.Remoting.Impl.Serialization.SerializableDelegate : object {
    [NotNullAttribute]
private Delegate myDelegate;
    public Delegate Delegate { get; }
    internal SerializableDelegate(Delegate delegate_);
    protected SerializableDelegate(SerializationInfo info, StreamingContext context);
    public Delegate get_Delegate();
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    public static SerializableDelegate`1<T> Create(T _delegate);
}
public class JetBrains.Common.Util.Remoting.Impl.Serialization.SerializableDelegate`1 : object {
    [NotNullAttribute]
private SerializableDelegate myDelegate;
    [NotNullAttribute]
public T Delegate { get; }
    public SerializableDelegate`1(T src);
    public T get_Delegate();
}
internal class JetBrains.Common.Util.Remoting.Impl.Serialization.SerializableNull : object {
    public static SerializableNull Instance;
    private static SerializableNull();
}
internal class JetBrains.Common.Util.Remoting.Impl.Serialization.SerializationContext : object {
    public bool IsClient;
    [CompilerGeneratedAttribute]
private bool <IsDisposed>k__BackingField;
    private IObjectReferenceProcessor myObjectReferenceProcessor;
    private IRemoteCommunicator myRemoteComm;
    private Action`1<Exception> myHandleException;
    public IObjectReferenceProcessor ObjectReferenceProcessor { get; }
    public IRemoteCommunicator RemoteComm { get; }
    public Action`1<Exception> HandleException { get; }
    public bool IsDisposed { get; private set; }
    public SerializationContext(Lifetime lifetime, IObjectReferenceProcessor objectReferenceProcessor, IRemoteCommunicator remoteComm, bool isClient, Action`1<Exception> handleException);
    public IObjectReferenceProcessor get_ObjectReferenceProcessor();
    public IRemoteCommunicator get_RemoteComm();
    public Action`1<Exception> get_HandleException();
    [CompilerGeneratedAttribute]
public bool get_IsDisposed();
    [CompilerGeneratedAttribute]
private void set_IsDisposed(bool value);
    [CompilerGeneratedAttribute]
private void <.ctor>b__14_0();
}
public static class JetBrains.Common.Util.Remoting.Impl.Serialization.SerializationStack : object {
    [ThreadStaticAttribute]
private static Stack`1<Type> ourStack;
    private static Stack`1<Type> Stack { get; }
    public static string CurrentStack { get; }
    private static Stack`1<Type> get_Stack();
    public static SerializationToken Start(Type type);
    public static string get_CurrentStack();
}
internal static class JetBrains.Common.Util.Remoting.Impl.Serialization.SerializationUtils : object {
    [LocalizableAttribute("False")]
internal static string GetFieldTypeKey(string fieldName);
    internal static bool IsSimpleDelegate(Delegate _delegate);
}
public class JetBrains.Common.Util.Remoting.Impl.SharedMemoryPointer : ValueType {
    public static int StructureSize;
    public static SharedMemoryPointer Invalid;
    public int Index;
    public int Offset;
    public bool IsValid { get; }
    public SharedMemoryPointer(int index, int offset);
    private static SharedMemoryPointer();
    public bool get_IsValid();
    public sealed virtual bool Equals(SharedMemoryPointer other);
    public void Write(IntPtr ptr, int offset);
    public static SharedMemoryPointer Read(IntPtr ptr, int offset);
    [LocalizableAttribute("False")]
public virtual string ToString();
}
internal class JetBrains.Common.Util.Remoting.Impl.StableRemotableReference`1 : RemotableReference`1<T> {
    public StableRemotableReference`1(T value);
    public StableRemotableReference`1(SerializationInfo info, StreamingContext context);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    protected virtual LocalRefId GenerateId(T value, IObjectReferenceProcessor referenceProcessor);
    public sealed virtual bool Equals(StableRemotableReference`1<T> other);
}
internal interface JetBrains.Common.Util.Remoting.Internal.ICommunicatorForHost {
    public abstract virtual void ActivateHost(IInterProcessHost host);
    public abstract virtual void DeactivateHost(IInterProcessHost host);
    [CanBeNullAttribute]
public abstract virtual IInterProcessProxy GetProxy(LocalRefId id);
}
internal interface JetBrains.Common.Util.Remoting.Internal.ICommunicatorForObjectTracker {
    public abstract virtual void OnObjectReferenceRemoved(RemoteRefId id);
}
internal interface JetBrains.Common.Util.Remoting.Internal.ICommunicatorForProxy {
    public abstract virtual void UpdateValue(RemoteRefId hostId, Action`2<BinaryWriter, BinaryFormatter> writeAction);
    public abstract virtual void Cancel(RemoteRefId hostId, ICancelArgs args);
}
internal interface JetBrains.Common.Util.Remoting.Internal.IGarbageCollector {
    public TimeSpan Period { get; public set; }
    public abstract virtual void RequestGC();
    public abstract virtual TimeSpan get_Period();
    public abstract virtual void set_Period(TimeSpan value);
}
internal interface JetBrains.Common.Util.Remoting.Internal.IGarbageProducer {
    public abstract virtual void CollectGarbage();
}
internal interface JetBrains.Common.Util.Remoting.Internal.IInterProcessHost {
    public RemoteRefId RemoteProxyId { get; }
    public abstract virtual void ReadNextPackage(BinaryReader reader, BinaryFormatter binaryFormatter);
    public abstract virtual void ProcessPackage();
    public abstract virtual void Cancel(ICancelArgs args);
    public abstract virtual RemoteRefId get_RemoteProxyId();
}
internal interface JetBrains.Common.Util.Remoting.Internal.IInterProcessLock {
    public abstract virtual void Lock();
    public abstract virtual void Unlock();
}
public interface JetBrains.Common.Util.Remoting.Internal.IInterProcessProxy {
    public abstract virtual void OnActivated();
    public abstract virtual IDataProvider`1<ProgressProvider[]> GetProgressesProvider();
    public abstract virtual void OnDeactivated();
}
internal interface JetBrains.Common.Util.Remoting.Internal.IObjectReferenceProcessor {
    public int ObjectRefsCount { get; }
    public abstract virtual LocalRefId AddObjectRef(object targetObject);
    public abstract virtual LocalRefId GetStableObjectRef(object targetObject);
    public abstract virtual void AddObjectRef(LocalRefId id, object targetObject);
    public abstract virtual object GetObject(LocalRefId id);
    public abstract virtual void RemoveObject(LocalRefId id);
    public abstract virtual int get_ObjectRefsCount();
    public abstract virtual int GetObjectsCount();
    public abstract virtual LocalRefId NewLocalId();
    public abstract virtual RemoteRefId NewRemoteId();
    public abstract virtual RemoteReference`1<T> GetOrCreateRemoteObjectRef(RemoteRefId id);
}
internal interface JetBrains.Common.Util.Remoting.Internal.IRemotableReferenceInternal`1 {
    [CanBeNullAttribute]
public abstract virtual IRemoteCommunicator GetComm();
    public abstract virtual RemoteRefId GetRemoteId();
}
internal interface JetBrains.Common.Util.Remoting.Internal.IRemoteCommandExecutor {
}
internal interface JetBrains.Common.Util.Remoting.Internal.IRemoteCommandHandler {
    public abstract virtual IInterProcessHost GetHost(LocalRefId id);
    public abstract virtual void ConnectionIsBroken(bool duringDispose);
}
internal interface JetBrains.Common.Util.Remoting.Internal.IRemoteCommands`2 {
    public abstract virtual void CreateSimpleHost(TRef1 hostId, TRef2 proxyId, Func`3<BinaryReader, BinaryFormatter, InterProcessPackage`1<T>> valueReader);
    public abstract virtual void Build(TRef1 objectId, Func`1<T> builder);
    public abstract virtual void BuildReturn(TRef2 resultId, Func`1<IRemotableReference`1<IAsyncDataProvider`1<T>>> builder);
    public abstract virtual void Execute(Action action);
    public abstract virtual void ResolveProxyProvider(TRef1 hostId, TRef1 proxyProviderId);
    public abstract virtual void OnActivated(TRef1 proxyId);
    public abstract virtual void OnDeactivated(TRef1 proxyId);
    public abstract virtual void OnRemoteException(Exception e);
    public abstract virtual void RemoveProxy(TRef1 proxyId);
    public abstract virtual void RemoveObjectReference(TRef1 id);
}
internal interface JetBrains.Common.Util.Remoting.Internal.IRemoteCommandsExecutorInternal {
    public string Id { get; }
    public abstract virtual void Init(Lifetime lifetime, IRemoteCommandHandler commandHandler, SerializationContext serializationContext, bool isClient);
    public abstract virtual string get_Id();
}
internal static class JetBrains.Common.Util.Remoting.Internal.RemoteCommunicators : object {
    private static IDictionary`2<string, IRemoteCommunicatorInternal> ourMap;
    private static RemoteCommunicators();
    [CanBeNullAttribute]
public static IRemoteCommunicatorInternal GetCommunicator(string id);
    public static void RegisterCommunicator(Lifetime lifetime, IRemoteCommunicatorInternal comm);
}
public interface JetBrains.Common.Util.Remoting.IReadonlyPointer {
    public IntPtr Pointer { get; }
    public abstract virtual IntPtr get_Pointer();
}
public interface JetBrains.Common.Util.Remoting.IRemotablePair`1 {
    public T Value { get; }
    [CanBeNullAttribute]
public IRemotableReference`1<T> RemoteReference { get; }
    [NotNullAttribute]
public IRemotableReference`1<T> LocalReference { get; }
    public abstract virtual T get_Value();
    public abstract virtual IRemotableReference`1<T> get_RemoteReference();
    public abstract virtual IRemotableReference`1<T> get_LocalReference();
}
public interface JetBrains.Common.Util.Remoting.IRemotableReference`1 {
    public T Value { get; }
    public bool IsLocal { get; }
    public abstract virtual T get_Value();
    public abstract virtual bool get_IsLocal();
}
public interface JetBrains.Common.Util.Remoting.IRemoteCommunicator {
    public bool IsClient { get; }
    public bool IsAlive { get; }
    public ISignal`1<IRemoteCommunicator> ConnectionBroken { get; }
    public abstract virtual IAsyncDataProxy`1<TResult> BuildReturn(Func`1<IRemotableReference`1<IAsyncDataProvider`1<TResult>>> builder);
    public abstract virtual IAsyncDataProxy`1<TResult> BuildReturnStream(Func`1<IRemotableReference`1<IAsyncDataProvider`1<TResult>>> builder);
    public abstract virtual IRemotableReference`1<TResult> Build(Func`1<TResult> builder, object hardlink);
    public abstract virtual void ExecuteRemote(Action builder);
    public abstract virtual bool get_IsClient();
    public abstract virtual bool get_IsAlive();
    public abstract virtual ISignal`1<IRemoteCommunicator> get_ConnectionBroken();
}
public interface JetBrains.Common.Util.Remoting.IRemoteCommunicatorMonitor {
    public int LocalReturnProxiesCount { get; }
    public int HostsCount { get; }
    public int ProxiesCount { get; }
    public TimeSpan GcPeriod { get; public set; }
    public abstract virtual int get_LocalReturnProxiesCount();
    public abstract virtual int get_HostsCount();
    public abstract virtual int get_ProxiesCount();
    public abstract virtual void CollectGarbage();
    public abstract virtual int GetObjectsCount();
    public abstract virtual TimeSpan get_GcPeriod();
    public abstract virtual void set_GcPeriod(TimeSpan value);
}
public interface JetBrains.Common.Util.Remoting.IResizeablePointer {
    public IntPtr Pointer { get; }
    public int Size { get; }
    public abstract virtual IntPtr get_Pointer();
    public abstract virtual int get_Size();
    public abstract virtual void Allocate(int size);
}
public class JetBrains.Common.Util.Remoting.NotRemotablePair`1 : object {
    private IRemotableReference`1<T> myValue;
    public T Value { get; }
    public IRemotableReference`1<T> RemoteReference { get; }
    public IRemotableReference`1<T> LocalReference { get; }
    public NotRemotablePair`1(T value);
    public sealed virtual T get_Value();
    public sealed virtual IRemotableReference`1<T> get_RemoteReference();
    public sealed virtual IRemotableReference`1<T> get_LocalReference();
}
public enum JetBrains.Common.Util.Remoting.PlatformKind : Enum {
    public int value__;
    public static PlatformKind X86;
    public static PlatformKind Current;
    public static PlatformKind X64Preferred;
}
public static class JetBrains.Common.Util.Remoting.RemoteDataPipesFactory : object {
    public static IRemoteCommunicator Create(Lifetime lifetime, Action`1<Exception> remoteExceptionHandler, string pipeName, bool isClient);
}
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
public static class JetBrains.Common.Util.Resources.Strings : object {
    private static ILogger ourLog;
    private static Lazy`1<JetResourceManager> ourResourceManager;
    [EditorBrowsableAttribute("2")]
public static JetResourceManager ResourceManager { get; }
    public static string PayloadType_Measure_Ms { get; }
    public static string PayloadType_Measure_Event_Plural { get; }
    public static string PayloadType_Measure_Thread_Plural { get; }
    public static string PayloadType_Measure_MB { get; }
    public static string PayloadType_Measure_KB { get; }
    public static string PayloadType_Measure_Call_Plural { get; }
    public static string PayloadType_Measure_Call { get; }
    public static string PayloadType_Measure_Event { get; }
    public static string PayloadType_Measure_Thread { get; }
    public static string Comparison_SnapshotHeader { get; }
    public static string Filters_Range_Tooltip { get; }
    public static string TimeUnits_Labels_Ns { get; }
    public static string TimeUnits_Labels_μs { get; }
    public static string TimeUnits_Labels_Ms { get; }
    public static string TimeUnits_Labels_S { get; }
    public static string TimeUnits_Labels_M { get; }
    public static string TimeUnits_Labels_H { get; }
    public static string TimeUnits_Labels_D { get; }
    public static string SizeUnits_Labels_Bytes { get; }
    public static string SizeUnits_Labels_B { get; }
    public static string SizeUnits_Labels_KB { get; }
    public static string SizeUnits_Labels_MB { get; }
    public static string SizeUnits_Labels_GB { get; }
    public static string SizeSpeedUnits_Labels_B_sec { get; }
    public static string SizeSpeedUnits_Labels_KB_sec { get; }
    public static string SizeSpeedUnits_Labels_MB_sec { get; }
    public static string SizeSpeedUnits_Labels_GB_sec { get; }
    public static string HumanReadableTime_NoDateSpecified { get; }
    public static string HumanReadableTime_Today { get; }
    public static string HumanReadableTime_Yesterday { get; }
    public static string NamespaceTree_BuildingTaskText { get; }
    public static string ThreadTypes_Main { get; }
    public static string ThreadTypes_Finalizer { get; }
    public static string ThreadTypes_ThreadPoolWorker { get; }
    public static string ThreadTypes_GC { get; }
    public static string ThreadTypes_ClrWorker { get; }
    public static string ThreadTypes_Native { get; }
    public static string ThreadTypes_Named { get; }
    public static string IcicleChart_ZoomHint { get; }
    public static string IcicleChat_SelectedStackTrace { get; }
    public static string SizeUnits_Labels_TB { get; }
    public static string FunctionUID_TruncatedCallstack { get; }
    public static string FunctionUID_Unknown { get; }
    public static string FunctionUID_Unresolved { get; }
    public static string FunctionUID_Invalid { get; }
    public static string FunctionUID_NoCallStack { get; }
    public static string FunctionUID_SkippedDynamic { get; }
    public static string FunctionUID_AllCalls { get; }
    public static string FunctionUID_Continuation { get; }
    public static string FunctionUID_Awaits { get; }
    public static string FunctionUID_TaskScheduled { get; }
    public static string FunctionUID_TaskExecution { get; }
    public static string FunctionUID_TaskRecursion { get; }
    public static string FunctionUID_Native { get; }
    public static string FunctionUID_ThreadStoppedByUnknownReason { get; }
    public static string FunctionUID_Gc { get; }
    public static string FunctionUID_AppDomainShutdown { get; }
    public static string FunctionUID_CodePitching { get; }
    public static string FunctionUID_UnmanagedStackFrame { get; }
    public static string FunctionUID_UnsafeStackFrame { get; }
    public static string SnapshotAccessDeniedMessage { get; }
    public static string Subsystems_Events_FileIO { get; }
    public static string Subsystems_Events_Jit { get; }
    public static string Subsystems_Events_GcWait { get; }
    public static string Subsystems_Events_LockContention { get; }
    public static string Subsystems_Events_SqlQuery { get; }
    public static string Subsystems_Events_WaitingForCPU { get; }
    public static string Subsystems_Events_AwaitingTime { get; }
    private static Strings();
    public static JetResourceManager get_ResourceManager();
    public static string get_PayloadType_Measure_Ms();
    public static string get_PayloadType_Measure_Event_Plural();
    public static string get_PayloadType_Measure_Thread_Plural();
    public static string get_PayloadType_Measure_MB();
    public static string get_PayloadType_Measure_KB();
    public static string get_PayloadType_Measure_Call_Plural();
    public static string get_PayloadType_Measure_Call();
    public static string get_PayloadType_Measure_Event();
    public static string get_PayloadType_Measure_Thread();
    public static string get_Comparison_SnapshotHeader();
    public static string get_Filters_Range_Tooltip();
    public static string get_TimeUnits_Labels_Ns();
    public static string get_TimeUnits_Labels_μs();
    public static string get_TimeUnits_Labels_Ms();
    public static string get_TimeUnits_Labels_S();
    public static string get_TimeUnits_Labels_M();
    public static string get_TimeUnits_Labels_H();
    public static string get_TimeUnits_Labels_D();
    public static string get_SizeUnits_Labels_Bytes();
    public static string get_SizeUnits_Labels_B();
    public static string get_SizeUnits_Labels_KB();
    public static string get_SizeUnits_Labels_MB();
    public static string get_SizeUnits_Labels_GB();
    public static string get_SizeSpeedUnits_Labels_B_sec();
    public static string get_SizeSpeedUnits_Labels_KB_sec();
    public static string get_SizeSpeedUnits_Labels_MB_sec();
    public static string get_SizeSpeedUnits_Labels_GB_sec();
    public static string get_HumanReadableTime_NoDateSpecified();
    public static string get_HumanReadableTime_Today();
    public static string get_HumanReadableTime_Yesterday();
    public static string get_NamespaceTree_BuildingTaskText();
    public static string get_ThreadTypes_Main();
    public static string get_ThreadTypes_Finalizer();
    public static string get_ThreadTypes_ThreadPoolWorker();
    public static string get_ThreadTypes_GC();
    public static string get_ThreadTypes_ClrWorker();
    public static string get_ThreadTypes_Native();
    public static string get_ThreadTypes_Named();
    public static string get_IcicleChart_ZoomHint();
    public static string get_IcicleChat_SelectedStackTrace();
    public static string get_SizeUnits_Labels_TB();
    public static string get_FunctionUID_TruncatedCallstack();
    public static string get_FunctionUID_Unknown();
    public static string get_FunctionUID_Unresolved();
    public static string get_FunctionUID_Invalid();
    public static string get_FunctionUID_NoCallStack();
    public static string get_FunctionUID_SkippedDynamic();
    public static string get_FunctionUID_AllCalls();
    public static string get_FunctionUID_Continuation();
    public static string get_FunctionUID_Awaits();
    public static string get_FunctionUID_TaskScheduled();
    public static string get_FunctionUID_TaskExecution();
    public static string get_FunctionUID_TaskRecursion();
    public static string get_FunctionUID_Native();
    public static string get_FunctionUID_ThreadStoppedByUnknownReason();
    public static string get_FunctionUID_Gc();
    public static string get_FunctionUID_AppDomainShutdown();
    public static string get_FunctionUID_CodePitching();
    public static string get_FunctionUID_UnmanagedStackFrame();
    public static string get_FunctionUID_UnsafeStackFrame();
    public static string get_SnapshotAccessDeniedMessage();
    public static string get_Subsystems_Events_FileIO();
    public static string get_Subsystems_Events_Jit();
    public static string get_Subsystems_Events_GcWait();
    public static string get_Subsystems_Events_LockContention();
    public static string get_Subsystems_Events_SqlQuery();
    public static string get_Subsystems_Events_WaitingForCPU();
    public static string get_Subsystems_Events_AwaitingTime();
}
public class JetBrains.Common.Util.ReverseComparer`1 : object {
    private IComparer`1<T> myComparer;
    public ReverseComparer`1(IComparer`1<T> comparer);
    public sealed virtual int Compare(T x, T y);
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Common.Util.RingBuffer`1 : object {
    private int myBufferSize;
    private List`1<T> myList;
    private int myFirstIndex;
    private int myVersion;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public T Item { get; public set; }
    public RingBuffer`1(int bufferSize);
    public sealed virtual int get_Count();
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual bool Remove(T item);
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual int IndexOf(T item);
    public sealed virtual void Insert(int index, T item);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    private int GetPrivateIndex(int index);
}
public static class JetBrains.Common.Util.SequenceUtils : object {
    [IteratorStateMachineAttribute("JetBrains.Common.Util.SequenceUtils/<FindGapIntervals>d__0")]
public static IEnumerable`1<Interval> FindGapIntervals(UInt32 start, IEnumerable`1<UInt32> sequence, UInt32 step);
    public static Interval FindLastLargestSubWordOccurrence(IReadOnlyList`1<T> text, IReadOnlyList`1<T> word, UInt32 minLength, UInt32 maxLength);
    [IteratorStateMachineAttribute("JetBrains.Common.Util.SequenceUtils/<FindSubWordOccurrences>d__2`1")]
public static IEnumerable`1<Interval> FindSubWordOccurrences(IReadOnlyList`1<T> text, IReadOnlyList`1<T> word, UInt32 minLength, UInt32 maxLength);
}
public class JetBrains.Common.Util.SequentialIterators`1 : object {
    private bool myCanMove;
    private bool myFirstIterationStarted;
    private bool myFirstIterationFinished;
    private IEnumerator`1<T> mySourceEnumerator;
    private Func`2<T, bool> myPredF;
    private Func`2<T, bool> myPredS;
    private T myCurrentElement;
    public IEnumerator`1<T> FirstIterator { get; }
    public IEnumerator`1<T> SecondIterator { get; }
    public SequentialIterators`1(IEnumerable`1<T> sourceData, Func`2<T, bool> pred1, Func`2<T, bool> pred2);
    public IEnumerator`1<T> get_FirstIterator();
    public IEnumerator`1<T> get_SecondIterator();
    public void Reset();
    [IteratorStateMachineAttribute("JetBrains.Common.Util.SequentialIterators`1/<FirstEnumerable>d__13")]
public IEnumerable`1<T> FirstEnumerable();
    [IteratorStateMachineAttribute("JetBrains.Common.Util.SequentialIterators`1/<SecondEnumerable>d__14")]
public IEnumerable`1<T> SecondEnumerable();
    private bool MoveWithValueShift();
}
[ObsoleteAttribute("It is recommended to migrate to SequentialTaskScheduler and System.Tasks")]
public class JetBrains.Common.Util.SequentialTaskExecutor : object {
    private ITask modreq(System.Runtime.CompilerServices.IsVolatile) myRunningTask;
    private Queue`1<ITask> myTasks;
    private Action`1<ITask> myExecutor;
    private Action myPrepareToShutdown;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) myIsTerminated;
    private object myLock;
    [ThreadSafeAttribute]
public bool HasRunningTask { get; }
    public SequentialTaskExecutor(Action`1<ITask> executor, Action prepareToShutdown);
    public sealed virtual bool get_HasRunningTask();
    private void WaitForCurrentTask();
    [ThreadSafeAttribute]
private void StartNextTask(bool onlyIfRunningTaskIsNull);
    private bool CancelAllTasksAndQueue(ITask newTask, bool cancelRunningTask);
    private static IList`1<T> DequeueAll(Queue`1<T> queue);
    [ThreadSafetyAttribute("4294967295", "1")]
private void TaskOnFinished(ITask sender, EventArgs args);
    public sealed virtual bool ExecuteExclusively(ITask task, bool cancelRunningTask);
    public sealed virtual void Enqueue(ITask task);
    [ThreadSafeAttribute]
public sealed virtual bool CancelAllTasks(bool cancelRunningTask);
    public static SequentialTaskExecutor CreateWithThreadPool();
    public sealed virtual void PrepareForDispose();
    public sealed virtual void Dispose();
}
public class JetBrains.Common.Util.SetAndListSynchronizer`2 : object {
    private IObservableSet`1<TSet> mySet;
    private Func`2<TSet, TList> mySetToListConverter;
    private Func`2<TList, TSet> myListToSetConverter;
    private IList`1<TList> myList;
    private bool myListIsMaster;
    public SetAndListSynchronizer`2(IObservableSet`1<TSet> set, IList`1<TList> list, Func`2<TSet, TList> setToListConverter, Func`2<TList, TSet> listToSetConverter, bool listIsMaster);
    public sealed virtual void StartSynchronizing();
    public sealed virtual void StopSynchronizing();
    private void StartListenList();
    private void StartListenSet();
    private void StopListenList();
    private void StopListenSet();
    private void OnSetChanged(object sender, NotifySetChangedEventArgs`1<TSet> e);
    private void OnCollectionChanged(object sender, NotifyCollectionChangedEventArgs e);
    private void CopyValues(IEnumerable`1<A> sourceList, ICollection`1<B> targetList, Func`2<A, B> converter);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.SettingsExtension : object {
    [ExtensionAttribute]
public static IIndexedKey`1<TKey> CreateIndexedKey(ISettings settings, object indexKey, IDictionary`2<Type, object> parentIndex);
    [ExtensionAttribute]
public static void DeleteIndexedKey(ISettings settings, object indexKey, IDictionary`2<Type, object> parentIndex);
    [ExtensionAttribute]
public static IIndexedKey`1<TKey> CreateIndexedKey(ISettings settings, object indexKey, Lifetime lifetime, IDictionary`2<Type, object> parentIndex);
    [ExtensionAttribute]
public static IIndexedKey`1<TKey> GetKey(ISettings settings, object indexKey, IDictionary`2<Type, object> parentIndex);
    [ExtensionAttribute]
public static IKey`1<TKey> GetKey(ISettings settings, IDictionary`2<Type, object> parentIndex);
    [ExtensionAttribute]
public static IEnumerable`1<IIndexedKey`1<TKey>> GetAllKeys(ISettings settings, IDictionary`2<Type, object> parentIndex);
    [ExtensionAttribute]
public static IEnumerable`1<TKey> GetAllEntries(ISettings settings, IDictionary`2<Type, object> parentIndex, bool ignoreKeyIsDefined);
    [ExtensionAttribute]
public static IDictionary`2<TIndex, TKey> GetAllEntries(ISettings settings, IDictionary`2<Type, object> parentIndex, bool ignoreKeyIsDefined);
    [ExtensionAttribute]
public static void AdviseChange(ISettings settings, Action callback, Lifetime lifetime);
    [ExtensionAttribute]
public static Dictionary`2<Type, object> ParentIndex(object index);
    [ExtensionAttribute]
public static Dictionary`2<Type, object> ParentIndex(Dictionary`2<Type, object> dictionary, object index);
    [ConditionalAttribute("JET_MODE_ASSERT")]
private static void AssertIndexKey(object indexKey);
}
public class JetBrains.Common.Util.SharedTaskEventArgs : EventArgs {
    public bool IsShared;
    public ITask Task;
    public SharedTaskEventArgs(ITask task, bool isShared);
}
public static class JetBrains.Common.Util.Signal : object {
    public static ISignal`1<T> Create();
}
public class JetBrains.Common.Util.SignatureTree.AdvancedMethodInfoProvider : object {
    private Func`2<FunctionUIDm, string> myPresentableSignaturesMapper;
    public AdvancedMethodInfoProvider(Func`2<FunctionUIDm, string> presentableSignaturesMapper);
    public sealed virtual string GetPresentableSignature(FunctionUIDm fuid);
    public sealed virtual string GetMethodNameWithSignature(MethodViewData data);
}
public interface JetBrains.Common.Util.SignatureTree.IAdvancedMethodInfoProvider {
    [CanBeNullAttribute]
public abstract virtual string GetPresentableSignature(FunctionUIDm fuid);
    [NotNullAttribute]
public abstract virtual string GetMethodNameWithSignature(MethodViewData methodViewData);
}
public interface JetBrains.Common.Util.SignatureTree.INamespaceTreeNode {
    public INamespaceTreeNode Parent { get; }
    public IEnumerable`1<INamespaceTreeNode> Children { get; }
    public bool IsLeaf { get; }
    public string Name { get; }
    public string FullName { get; }
    public bool IsRoot { get; }
    public MethodViewData MethodViewData { get; }
    public bool IsClass { get; }
    public abstract virtual INamespaceTreeNode get_Parent();
    public abstract virtual IEnumerable`1<INamespaceTreeNode> get_Children();
    public abstract virtual bool get_IsLeaf();
    public abstract virtual string get_Name();
    public abstract virtual string get_FullName();
    public abstract virtual bool get_IsRoot();
    public abstract virtual MethodViewData get_MethodViewData();
    public abstract virtual bool get_IsClass();
}
public interface JetBrains.Common.Util.SignatureTree.ISignatureNodeFilter {
    public abstract virtual bool Accept(INamespaceTreeNode sigTreeNode, Property`1<bool> isCancelled);
    public abstract virtual bool AcceptFiltered(INamespaceTreeNode sigTreeNode, Property`1<bool> isCancelled);
}
public interface JetBrains.Common.Util.SignatureTree.ISnapshotNamespaceTree {
    public INamespaceTreeNode Root { get; }
    public UInt32 LeafCount { get; }
    public UInt32 NodeCount { get; }
    public abstract virtual INamespaceTreeNode get_Root();
    public abstract virtual UInt32 get_LeafCount();
    public abstract virtual UInt32 get_NodeCount();
    public abstract virtual INamespaceTreeNode FindMethod(FullMethodName methodName);
    public abstract virtual IEnumerable`1<SearchResult> StagedGetMatches(IdentifierMatcher matcher);
    public abstract virtual IEnumerable`1<SearchResult> GetAllMethodsMatches(IdentifierMatcher matcher);
    [CanBeNullAttribute]
public abstract virtual IEnumerable`1<INamespaceTreeNode> GetNodes(string str);
}
internal class JetBrains.Common.Util.SignatureTree.NamespaceParts.ClassPart : object {
    private string myName;
    public PartType Type { get; }
    public MethodViewData MethodViewData { get; }
    public string Name { get; }
    public ClassPart(string name);
    public sealed virtual PartType get_Type();
    public sealed virtual MethodViewData get_MethodViewData();
    public sealed virtual string get_Name();
}
public class JetBrains.Common.Util.SignatureTree.NamespaceParts.FullMethodName : object {
    public INamespacePart[] Parts;
    public FullMethodName(MethodViewData methodViewData, bool splitNestedClasses);
    public FullMethodName(string ns, string cn);
    [IteratorStateMachineAttribute("JetBrains.Common.Util.SignatureTree.NamespaceParts.FullMethodName/<ConstructFromClass>d__3")]
private static IEnumerable`1<INamespacePart> ConstructFromClass(string ns, string cn);
    [IteratorStateMachineAttribute("JetBrains.Common.Util.SignatureTree.NamespaceParts.FullMethodName/<BuildParts>d__4")]
private static IEnumerable`1<INamespacePart> BuildParts(MethodViewData methodViewData, bool splitNestedClasses);
    public virtual string ToString();
    public sealed virtual int CompareTo(FullMethodName other);
    private static int Compare(INamespacePart namespacePart1, INamespacePart namespacePart2);
}
public interface JetBrains.Common.Util.SignatureTree.NamespaceParts.INamespacePart {
    public PartType Type { get; }
    public MethodViewData MethodViewData { get; }
    public string Name { get; }
    public abstract virtual PartType get_Type();
    public abstract virtual MethodViewData get_MethodViewData();
    public abstract virtual string get_Name();
}
public class JetBrains.Common.Util.SignatureTree.NamespaceParts.MethodPart : object {
    private MethodViewData myMethodViewData;
    public PartType Type { get; }
    public MethodViewData MethodViewData { get; }
    public string Name { get; }
    public MethodPart(MethodViewData methodViewData);
    public sealed virtual PartType get_Type();
    public sealed virtual MethodViewData get_MethodViewData();
    public sealed virtual string get_Name();
}
internal class JetBrains.Common.Util.SignatureTree.NamespaceParts.NamespacePart : object {
    private string myName;
    public PartType Type { get; }
    public MethodViewData MethodViewData { get; }
    public string Name { get; }
    public NamespacePart(string name);
    public sealed virtual PartType get_Type();
    public sealed virtual MethodViewData get_MethodViewData();
    public sealed virtual string get_Name();
}
internal class JetBrains.Common.Util.SignatureTree.NamespaceParts.NamespacePartEqualityComparer : object {
    public static IEqualityComparer`1<INamespacePart> Instance;
    private static NamespacePartEqualityComparer();
    public sealed virtual bool Equals(INamespacePart x, INamespacePart y);
    public sealed virtual int GetHashCode(INamespacePart obj);
}
public enum JetBrains.Common.Util.SignatureTree.NamespaceParts.PartType : Enum {
    public sbyte value__;
    public static PartType Namespace;
    public static PartType ClassName;
    public static PartType MethodName;
}
public class JetBrains.Common.Util.SignatureTree.NamespaceTreeNode : object {
    private IList`1<NamespaceTreeNode> myChildren;
    private INamespaceTreeNode myParent;
    private INamespacePart myPart;
    public INamespaceTreeNode Parent { get; }
    public IEnumerable`1<INamespaceTreeNode> Children { get; }
    public bool IsRoot { get; }
    public bool IsLeaf { get; }
    public bool IsClass { get; }
    public string Name { get; }
    public string FullName { get; }
    public MethodViewData MethodViewData { get; }
    public NamespaceTreeNode(INamespaceTreeNode parent, INamespacePart part);
    public static NamespaceTreeNode BuildRoot(IEnumerable`1<FullMethodName> methodNameList, IExecutionControllerOld executionController);
    private NamespaceTreeNode FindOrCreateChild(INamespacePart namespacePart);
    public sealed virtual INamespaceTreeNode get_Parent();
    public sealed virtual IEnumerable`1<INamespaceTreeNode> get_Children();
    public sealed virtual bool get_IsRoot();
    public sealed virtual bool get_IsLeaf();
    public sealed virtual bool get_IsClass();
    public sealed virtual string get_Name();
    public sealed virtual string get_FullName();
    public sealed virtual MethodViewData get_MethodViewData();
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.SignatureTree.NamespaceTreeSearch : object {
    private static ILogger ourLogger;
    private static NamespaceTreeSearch();
    [ExtensionAttribute]
public static IEnumerable`1<SearchResult> GetStagedMatches(INamespaceTreeNode root, IdentifierMatcher matcher, bool fullMatch);
    private static Optional`1<SearchResult> TestNode(INamespaceTreeNode node, IdentifierMatcher matcher, bool fullMatch, StringBuilder fullName, string name);
    [ExtensionAttribute]
public static IEnumerable`1<SearchResult> GetAllMatches(INamespaceTreeNode root, IdentifierMatcher matcher, bool fullMatch);
    [IteratorStateMachineAttribute("JetBrains.Common.Util.SignatureTree.NamespaceTreeSearch/<GetAllMatches>d__5`1")]
[ExtensionAttribute]
public static IEnumerable`1<T> GetAllMatches(INamespaceTreeNode root, Test`1<T> testNode);
    private static Nullable`1<MatcherScore> TryMatch(IdentifierMatcher matcher, string target);
    public static IdentifierMatcher PatternToIdentifierMatcher(string pattern);
    private static MatcherScore PromoteMiddleMatch(MatcherScore score);
    [CanBeNullAttribute]
private static SearchResult TryMatch(IdentifierMatcher matcher, INamespaceTreeNode node, TContext context, Func`2<TContext, string> target);
    [CanBeNullAttribute]
public static SearchResult TryMatch(IdentifierMatcher matcher, INamespaceTreeNode node, Func`2<INamespaceTreeNode, string> target);
}
public class JetBrains.Common.Util.SignatureTree.SearchResult : object {
    [CompilerGeneratedAttribute]
private INamespaceTreeNode <Node>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Rank>k__BackingField;
    public INamespaceTreeNode Node { get; }
    public int Rank { get; }
    public SearchResult(INamespaceTreeNode node, int rank);
    [CompilerGeneratedAttribute]
public INamespaceTreeNode get_Node();
    [CompilerGeneratedAttribute]
public int get_Rank();
}
public class JetBrains.Common.Util.SignatureTree.SignatureTreeNodeComparer : object {
    private List`1<INamespaceTreeNode> myXPathToParent;
    private List`1<INamespaceTreeNode> myYPathToParent;
    private void ClearPaths();
    public sealed virtual int Compare(INamespaceTreeNode x, INamespaceTreeNode y);
}
public class JetBrains.Common.Util.SignatureTree.SignatureTreeNodePredicate : MulticastDelegate {
    public SignatureTreeNodePredicate(object object, IntPtr method);
    public virtual bool Invoke(INamespaceTreeNode id, Property`1<bool> isCancelled);
    public virtual IAsyncResult BeginInvoke(INamespaceTreeNode id, Property`1<bool> isCancelled, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
public class JetBrains.Common.Util.SignatureTree.SnapshotNamespaceTree : object {
    private static ILogger ourLog;
    private INamespaceTreeNode myRoot;
    private UInt32 myLeafCount;
    private UInt32 myNodeCount;
    public INamespaceTreeNode Root { get; }
    public UInt32 LeafCount { get; }
    public UInt32 NodeCount { get; }
    private SnapshotNamespaceTree(INamespaceTreeNode root, UInt32 leafCount, UInt32 nodeCount);
    private static SnapshotNamespaceTree();
    public static SnapshotNamespaceTree BuildTree(IEnumerable`1<FullMethodName> methodNameList, IExecutionControllerOld executionController);
    private static void CalcStatistics(NamespaceTreeNode root, UInt32& leafCount, UInt32& nodeCount);
    private static void CalcStatisticsCore(INamespaceTreeNode root, UInt32& leafCount, UInt32& nodeCount);
    public sealed virtual INamespaceTreeNode get_Root();
    public sealed virtual UInt32 get_LeafCount();
    public sealed virtual UInt32 get_NodeCount();
    public sealed virtual INamespaceTreeNode FindMethod(FullMethodName methodName);
    public sealed virtual IEnumerable`1<SearchResult> StagedGetMatches(IdentifierMatcher matcher);
    public sealed virtual IEnumerable`1<SearchResult> GetAllMethodsMatches(IdentifierMatcher matcher);
    public sealed virtual IEnumerable`1<INamespaceTreeNode> GetNodes(string str);
}
public class JetBrains.Common.Util.SimpleCacheProviderContainer`1 : object {
    [CompilerGeneratedAttribute]
private IDataProvider`1<ICacheSource`1<T>> <Data>k__BackingField;
    public IDataProvider`1<ICacheSource`1<T>> Data { get; }
    public SimpleCacheProviderContainer`1(IDataProvider`1<ICacheSource`1<T>> data);
    [CompilerGeneratedAttribute]
public sealed virtual IDataProvider`1<ICacheSource`1<T>> get_Data();
}
public class JetBrains.Common.Util.Snapshot.Data.MeasureNode : ValueType {
    private static ushort InvalidFlags;
    public static MeasureNode Invalid;
    public long Calls;
    public long OwnTime;
    public long TotalTime;
    public ushort Flags;
    public bool IsValid { get; }
    public bool MeasurePartly { get; }
    public MeasureNode(long totalTime, long ownTime, long calls, ushort flags);
    private static MeasureNode();
    public bool get_IsValid();
    public bool get_MeasurePartly();
    public static MeasureNode op_Addition(MeasureNode leftOp, MeasureNode rightOp);
    public sealed virtual bool Equals(MeasureNode other);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public static bool op_Equality(MeasureNode n1, MeasureNode n2);
    public static bool op_Inequality(MeasureNode n1, MeasureNode n2);
}
public interface JetBrains.Common.Util.Snapshot.Recent.IRecentSnapshotInfoReader {
    public abstract virtual RecentSnapshotInfo Read(FileSystemPath snapshotPath);
}
public interface JetBrains.Common.Util.Snapshot.Recent.IRecentSnapshotsLightweightStorage {
    public abstract virtual bool ContainsSnapshot(FileSystemPath snapshotPath);
    public abstract virtual void AddOrUpdateSnapshot(FileSystemPath snapshotPath, IRecentSnapshotInfoReader reader, bool isTemporary, string name, Nullable`1<DateTime> creationDate, Nullable`1<DateTime> lasOpenedDate);
}
public class JetBrains.Common.Util.Snapshot.Recent.RecentSnapshotInfo : object {
    [CompilerGeneratedAttribute]
private DateTime <StartTimeUtc>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <EndTimeUtc>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProcessName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CommandLine>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ConfigurationXml>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<FileSystemPath> <Modules>k__BackingField;
    public DateTime StartTimeUtc { get; }
    public DateTime EndTimeUtc { get; }
    public string ProcessName { get; }
    public string CommandLine { get; }
    public string ConfigurationXml { get; }
    public IEnumerable`1<FileSystemPath> Modules { get; }
    public RecentSnapshotInfo(DateTime startTimeUtc, DateTime endTimeUtc, string processName, string commandLine, string configurationXml, IEnumerable`1<FileSystemPath> modules);
    [CompilerGeneratedAttribute]
public DateTime get_StartTimeUtc();
    [CompilerGeneratedAttribute]
public DateTime get_EndTimeUtc();
    [CompilerGeneratedAttribute]
public string get_ProcessName();
    [CompilerGeneratedAttribute]
public string get_CommandLine();
    [CompilerGeneratedAttribute]
public string get_ConfigurationXml();
    [CompilerGeneratedAttribute]
public IEnumerable`1<FileSystemPath> get_Modules();
}
public static class JetBrains.Common.Util.Snapshot.SnapshotAccessUtils : object {
    public static bool CheckAccess(FileSystemPath indexFile, bool throwException);
    public static bool CheckAccessWithMessage(FileSystemPath indexFile);
}
public static class JetBrains.Common.Util.Snapshot.SnapshotStorage : object {
    public static bool IsNettraceSnapshot(FileSystemPath path);
    public static ushort GetSnapShotStorageType(FileSystemPath indexFile);
    public static UInt32 GetSnapshotType(FileSystemPath indexFile);
}
public static class JetBrains.Common.Util.Snapshot.StorageFormat : object {
    public static ushort Default;
    public static ushort MultiFile;
    public static ushort SingleFile;
    public static ushort Zipped;
    public static ushort Indexed;
    public static ushort IndexedZipped;
    public static ushort MemoryMapped;
    public static ushort MemoryMappedV2;
}
public class JetBrains.Common.Util.Snapshot.UnsupportedCpuTypeException : Exception {
    [CompilerGeneratedAttribute]
private string <CurrentArchitecture>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetArchitecture>k__BackingField;
    public string CurrentArchitecture { get; }
    public string TargetArchitecture { get; }
    public UnsupportedCpuTypeException(string currentArchitecture, string targetArchitecture);
    protected UnsupportedCpuTypeException(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public string get_CurrentArchitecture();
    [CompilerGeneratedAttribute]
public string get_TargetArchitecture();
}
public class JetBrains.Common.Util.Snapshot.UnsupportedFormatException : Exception {
    public UnsupportedFormatException(string message);
    protected UnsupportedFormatException(SerializationInfo info, StreamingContext context);
}
public class JetBrains.Common.Util.Snapshot.UnsupportedLinuxLibCException : Exception {
    [CompilerGeneratedAttribute]
private string <CurrentLinuxLibC>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetLinuxLibC>k__BackingField;
    public string CurrentLinuxLibC { get; }
    public string TargetLinuxLibC { get; }
    public UnsupportedLinuxLibCException(string currentLibC, string targetLibC);
    protected UnsupportedLinuxLibCException(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public string get_CurrentLinuxLibC();
    [CompilerGeneratedAttribute]
public string get_TargetLinuxLibC();
}
public static class JetBrains.Common.Util.SortedEnumerable : object {
    [IteratorStateMachineAttribute("JetBrains.Common.Util.SortedEnumerable/<Distinct>d__0`1")]
public static IEnumerable`1<T> Distinct(IEnumerable`1<T> sortedLists, Func`3<T, T, bool> equals);
    public static IEnumerable`1<T> Between(IReadOnlyList`1<T> sortedInputList, T fromIncluded, T toExcluded);
    [IteratorStateMachineAttribute("JetBrains.Common.Util.SortedEnumerable/<Between>d__2`1")]
public static IEnumerable`1<T> Between(IReadOnlyList`1<T> sortedInputList, T fromIncluded, T toExcluded, IComparer`1<T> comparer);
    public static IEnumerable`1<T> Except(IEnumerable`1<T> sortedInputList, IEnumerable`1<T> sortedExceptList);
    [IteratorStateMachineAttribute("JetBrains.Common.Util.SortedEnumerable/<Except>d__4`1")]
public static IEnumerable`1<T> Except(IEnumerable`1<T> sortedInputList, IEnumerable`1<T> sortedExcludeList, IComparer`1<T> comparer);
    public static IEnumerable`1<T> Intersect(IEnumerable`1<T> sortedAList, IEnumerable`1<T> sortedBList);
    [IteratorStateMachineAttribute("JetBrains.Common.Util.SortedEnumerable/<Intersect>d__6`3")]
public static IEnumerable`1<Pair`2<T, U>> Intersect(IEnumerable`1<T> sortedAList, IEnumerable`1<U> sortedBList, Func`2<T, TKey> keyA, Func`2<U, TKey> keyB, IComparer`1<TKey> comparer);
    public static IEnumerable`1<T> Merge(IEnumerable`1<IEnumerable`1<T>> sortedLists);
    public static IEnumerable`1<T> Merge(IEnumerable`1<IEnumerable`1<T>> sortedLists, IComparer`1<T> comparer);
    public static IEnumerable`1<T> Merge(IEnumerable`1<IEnumerable`1<T>> sortedLists, Func`2<T, TOrder> orderBy);
    [IteratorStateMachineAttribute("JetBrains.Common.Util.SortedEnumerable/<Merge>d__10`2")]
public static IEnumerable`1<T> Merge(IEnumerable`1<IEnumerable`1<T>> sortedLists, Func`2<T, TOrder> orderBy, IComparer`1<TOrder> comparer);
    public static bool SkipSortedListToValue(List`1<TValue> list, Int32& currentIndex, TValue value, IComparer`1<TValue> comparer, bool exclude);
    public static bool SkipSortedListToValueReversed(List`1<TValue> list, Int32& currentIndex, TValue value, bool exclude);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.StreamExtensions : object {
    [ExtensionAttribute]
public static ChunkArray`1<byte> ToChunkArray(Stream stream);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.StringBuilderExtension : object {
    [ExtensionAttribute]
public static StringBuilder AppendJoin(StringBuilder builder, string separator, IEnumerable`1<string> list);
    [ExtensionAttribute]
public static StringBuilder AppendJoin(StringBuilder builder, string separator, IEnumerable`1<string> list, string before, string after);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.StringExtensions : object {
    [ExtensionAttribute]
public static string EscapeControlChars(string input);
    [ExtensionAttribute]
[LocalizableAttribute("False")]
public static string ToLiteral(string input);
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Common.Util.StringPointer : ValueType {
    private static int BytesPerUnicodeChar;
    private int myByteCount;
    private Byte[] myBuffer;
    private int myStartIndex;
    public bool IsValid { get; }
    public int Length { get; }
    public char Item { get; }
    public StringPointer(string str);
    public StringPointer(Byte[] buffer, int startIndex, int byteCount);
    public bool get_IsValid();
    public virtual string ToString();
    public int get_Length();
    public StringPointer Prefix(int length);
    public StringPointer Substring(int start);
    public StringPointer Substring(int start, int length);
    public char get_Item(int index);
    public int IndexOf(char c);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.StructEx : object {
    [ExtensionAttribute]
public static bool IsDefault(T value);
}
public class JetBrains.Common.Util.StructWrapper`1 : object {
    public T Data;
    public StructWrapper`1(T data);
    public static StructWrapper`1<T> op_Implicit(T data);
    public static T op_Implicit(StructWrapper`1<T> wrapper);
    public static Nullable`1<T> op_Implicit(StructWrapper`1<T> wrapper);
}
[DefaultMemberAttribute("Item")]
[ObsoleteAttribute("Used in BfsData/DfsData which are also obsolete. To be removed soon. @Ilya.Ivanov")]
public class JetBrains.Common.Util.StubChunkArray`1 : object {
    private int mySize;
    private bool myIsStub;
    private ChunkArray`1<T> myArray;
    public int Count { get; }
    public T Item { get; public set; }
    public StubChunkArray`1(int size, bool isStub);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual int get_Count();
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Common.Util.SubList : object {
    private IList myList;
    private int myStart;
    private int myCount;
    private Func`2<object, object> myConverter;
    private IEnumerable`1<object> CastedItems { get; }
    public int Count { get; }
    public object SyncRoot { get; }
    public bool IsSynchronized { get; }
    public bool IsReadOnly { get; }
    public bool IsFixedSize { get; }
    public object Item { get; public set; }
    public SubList(IList list, int start, int count, Func`2<object, object> converter);
    private IEnumerator GetEnumerator();
    [IteratorStateMachineAttribute("JetBrains.Common.Util.SubList/<Enumerate>d__6")]
private IEnumerable Enumerate();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Clear();
    public sealed virtual int Add(object value);
    public sealed virtual bool Contains(object item);
    private IEnumerable`1<object> get_CastedItems();
    public sealed virtual void CopyTo(Array array, int index);
    public sealed virtual int get_Count();
    public sealed virtual object get_SyncRoot();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual int IndexOf(object item);
    public sealed virtual void Insert(int index, object item);
    public sealed virtual void Remove(object value);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual object get_Item(int index);
    public sealed virtual void set_Item(int index, object value);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.SubListEx : object {
    [ExtensionAttribute]
public static IList SubList(IList list, int index, int count, Func`2<object, object> converter);
    [ExtensionAttribute]
public static IList Convert(IList list, Func`2<object, object> converter);
    [ExtensionAttribute]
public static IList SubList(IList list, int index, Func`2<object, object> converter);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.TaskExtensions : object {
    [ExtensionAttribute]
public static void OnFinishedSynchronized(Task task, Action`1<Task> action);
    [ExtensionAttribute]
public static void OnFinishedSynchronized(Task`1<T> task, Action`1<Task`1<T>> action);
}
public class JetBrains.Common.Util.Tasks.AsyncLifetime : object {
    public static TimeSpan DefaultTerminationTimeout;
    public static AsyncLifetime Eternal;
    private CountdownEvent myTrackedTasksCountdown;
    private CancellationTokenSource myCancellationSource;
    [CompilerGeneratedAttribute]
private TimeSpan <TerminationTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private Lifetime <Instance>k__BackingField;
    [CompilerGeneratedAttribute]
private CancellationToken <Token>k__BackingField;
    [CompilerGeneratedAttribute]
private static Action`1<TimeoutException> OnTerminationTimeout;
    public TimeSpan TerminationTimeout { get; }
    public int TrackedTasksCount { get; }
    public Lifetime Instance { get; }
    public CancellationToken Token { get; }
    public AsyncLifetime(Lifetime lifetime, string id);
    public AsyncLifetime(Lifetime lifetime, string id, TimeSpan terminationTimeout);
    internal AsyncLifetime(Lifetime outerLifetime, Lifetime innerLifetime, TimeSpan terminationTimeout);
    private static AsyncLifetime();
    [CompilerGeneratedAttribute]
public TimeSpan get_TerminationTimeout();
    public int get_TrackedTasksCount();
    [CompilerGeneratedAttribute]
public Lifetime get_Instance();
    [CompilerGeneratedAttribute]
public CancellationToken get_Token();
    [ThreadSafeAttribute]
public void ThrowIfTerminated();
    [ThreadSafeAttribute]
public bool TryTrackTask(Task task);
    [ThreadSafeAttribute]
public Task TrackTask(Func`1<Task> taskFactory);
    [ThreadSafeAttribute]
public Task`1<T> TrackTask(Func`1<Task`1<T>> taskFactory);
    [CompilerGeneratedAttribute]
public static void add_OnTerminationTimeout(Action`1<TimeoutException> value);
    [CompilerGeneratedAttribute]
public static void remove_OnTerminationTimeout(Action`1<TimeoutException> value);
    public static Lifetime op_Implicit(AsyncLifetime lifetime);
    public static CancellationToken op_Implicit(AsyncLifetime lifetime);
    public static CancellationToken op_BitwiseOr(AsyncLifetime lifetime, CancellationToken otherToken);
    private void TrackTaskInternal(Task task);
    private bool IsEternal();
    private void TerminateAndWait();
    [CompilerGeneratedAttribute]
private void <TrackTaskInternal>b__29_0();
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.Tasks.AsyncLifetimeExtension : object {
    [ExtensionAttribute]
[NotNullAttribute]
public static AsyncLifetime ToAsyncLifetime(Lifetime lifetime, string id);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.Tasks.CanScheduleTaskExtension : object {
    [ExtensionAttribute]
public static Task Schedule(ICanScheduleTask this, Action`1<IExecutionController> action);
    [ExtensionAttribute]
public static ICanScheduleTask RestrictedBy(ICanScheduleTask this, AsyncLifetime lifetime);
    [ExtensionAttribute]
public static ICanScheduleTask RestrictedBy(ICanScheduleTask this, Lifetime lifetime, string lifetimeId);
    [ExtensionAttribute]
public static ISequentialTaskScheduler ToSequential(ICanScheduleTask this, AsyncLifetime lifetime);
    [ExtensionAttribute]
public static IExclusiveTaskScheduler ToExclusive(ICanScheduleTask this, AsyncLifetime lifetime);
    [ExtensionAttribute]
public static ICanScheduleTask ToProgressableWith(ICanScheduleTask this, AsyncLifetime lifetime, Maybe`1<ITaskProgressListener> progressListener);
    [ExtensionAttribute]
internal static ICanScheduleTaskInternal AsSchedulerInternal(ICanScheduleTask scheduler);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.Tasks.CanScheduleTaskInternalExtension : object {
    [ExtensionAttribute]
public static Task CreateTask(ICanScheduleTaskInternal this, Action`1<IExecutionController> action, CancellationToken cancellationToken);
}
[ExtensionAttribute]
[ObsoleteAttribute("This is for backward compatibility. It is recommended to migrate to new IExecutionController.")]
public static class JetBrains.Common.Util.Tasks.Compatibility.ExecutionControllerCompatibilityExtension : object {
    [ExtensionAttribute]
public static IExecutionControllerOld ToOld(IExecutionController this);
    [ExtensionAttribute]
public static IExecutionController ToNew(IExecutionControllerOld this);
}
public static class JetBrains.Common.Util.Tasks.Compatibility.ExecutionControllerLegacy : object {
    private static ThreadLocal`1<IExecutionController> ourCurrent;
    private static ExecutionControllerLegacy();
    public static IExecutionController Yielder();
    internal static void SetCurrent(Lifetime lifetime, IExecutionController controller);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.Tasks.Compatibility.TaskCompatibilityExtension : object {
    [ExtensionAttribute]
public static IAsyncOperation ToAsyncOperation(Task this);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.Tasks.DispatcherExtension : object {
    [ExtensionAttribute]
public static void InvokeAsync(IStaThreadDispatcher this, AsyncLifetime lifetime, Action action);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.Tasks.ExecutionControllerParallelEx : object {
    [ExtensionAttribute]
public static ParallelExecutionFlow Parallelize(IExecutionController this, int maxParallelizmDegree);
}
public interface JetBrains.Common.Util.Tasks.ICanReportTaskProgress {
    public abstract virtual void Subscribe(AsyncLifetime lifetime, ITaskProgressListener listener);
}
public interface JetBrains.Common.Util.Tasks.ICanScheduleTask {
    [NotNullAttribute]
public AsyncLifetime Lifetime { get; }
    public abstract virtual AsyncLifetime get_Lifetime();
    [NotNullAttribute]
public abstract virtual Task`1<T> Schedule(Func`2<IExecutionController, T> action);
}
public interface JetBrains.Common.Util.Tasks.ICanScheduleTaskInternal {
    [NotNullAttribute]
public abstract virtual Task`1<T> CreateTask(Func`2<IExecutionController, T> action, CancellationToken cancellationToken);
    public abstract virtual void Schedule(Task task);
}
public interface JetBrains.Common.Util.Tasks.ICanStopWorld {
    public abstract virtual void PauseWorld();
    public abstract virtual void ResumeWorld();
}
public interface JetBrains.Common.Util.Tasks.IDispatcherTaskScheduler {
    public abstract virtual void VerifyAccess();
}
public interface JetBrains.Common.Util.Tasks.IExclusiveTaskScheduler {
    public abstract virtual void Reset(bool awaitFinished);
}
public abstract class JetBrains.Common.Util.Tasks.Impl.AbstractExecutionController : object {
    private TransientLifetime myControllerLifetime;
    private AsyncLifetime myForksLifetime;
    private ProgressCounter myProgressCounter;
    private AsyncLifetime JetBrains.Common.Util.Tasks.Impl.IHaveAsyncLifetime.Lifetime { get; }
    protected AsyncLifetime ForksLifetime { get; }
    public int RecommendedParallelizmDegree { get; }
    private sealed virtual override AsyncLifetime JetBrains.Common.Util.Tasks.Impl.IHaveAsyncLifetime.get_Lifetime();
    protected AsyncLifetime get_ForksLifetime();
    [ConditionalAttribute("JET_MODE_ASSERT")]
private void VerifyAccess();
    protected abstract virtual void ProgressAdvanced(double delta);
    protected abstract virtual void OperationUpdated(string operation);
    protected virtual void SubOperationAttached(Task task);
    protected abstract virtual void YieldCore();
    protected abstract virtual void WaitCore(IWaitable waitable, TimeSpan timeout);
    protected abstract virtual Task`1<T> ForkCore(Func`2<IExecutionController, T> action);
    public void Terminate();
    public sealed virtual void Dispose();
    public sealed virtual IExecutionController StartProgress(int steps, string operationName);
    public sealed virtual IExecutionController CreateSubOperation(int parentSteps);
    public sealed virtual IExecutionController AttachSubOperation(Task task, int parentSteps);
    public sealed virtual void AdvanceProgress();
    public sealed virtual void Yield();
    public sealed virtual void Wait(IWaitable waitable, TimeSpan timeout);
    public sealed virtual Task`1<T> Fork(Func`2<IExecutionController, T> action);
    public abstract virtual int get_RecommendedParallelizmDegree();
    private IExecutionController BuildSubOperationController(ProgressCounter parentProgressCounter, int parentStepsCount);
}
internal static class JetBrains.Common.Util.Tasks.Impl.DispatcherInternalUtils : object {
    public static Task`1<T> CreateTask(Func`2<int, T> action, CancellationToken cancellationToken);
    public static void ScheduleTask(Task task, IStaThreadDispatcher dispatcher, AsyncLifetime lifetime);
    private static Action Wrap(Func`2<int, T> action, CancellationTokenRegistration registration, TaskCompletionSource`1<T> taskSource);
}
public class JetBrains.Common.Util.Tasks.Impl.DispatcherTaskScheduler : object {
    private object myMutex;
    private AsyncLifetime myLifetime;
    private IStaThreadDispatcher myDispatcher;
    private CancellationTokenSource myCancellationSource;
    public AsyncLifetime Lifetime { get; }
    public DispatcherTaskScheduler(AsyncLifetime lifetime, IStaThreadDispatcher dispatcher);
    public sealed virtual AsyncLifetime get_Lifetime();
    public sealed virtual Task`1<T> Schedule(Func`2<IExecutionController, T> action);
    public sealed virtual void Reset(bool awaitFinished);
    public sealed virtual void VerifyAccess();
    private sealed virtual override Task`1<T> JetBrains.Common.Util.Tasks.ICanScheduleTaskInternal.CreateTask(Func`2<IExecutionController, T> action, CancellationToken cancellationToken);
    private sealed virtual override void JetBrains.Common.Util.Tasks.ICanScheduleTaskInternal.Schedule(Task task);
    private static Func`2<int, T> Wrap(Func`2<IExecutionController, T> action, CancellationToken cancellationToken);
}
internal class JetBrains.Common.Util.Tasks.Impl.ExclusiveTaskScheduler : object {
    private SequentialTaskScheduler mySequentialScheduler;
    public AsyncLifetime Lifetime { get; }
    public ExclusiveTaskScheduler(AsyncLifetime lifetime, ICanScheduleTaskInternal targetScheduler);
    public sealed virtual AsyncLifetime get_Lifetime();
    public sealed virtual Task`1<TResult> Schedule(Func`2<IExecutionController, TResult> action);
    public sealed virtual void Reset(bool awaitFinished);
}
public abstract class JetBrains.Common.Util.Tasks.Impl.ExecutionControllerProxy : object {
    protected IExecutionController Target;
    private AsyncLifetime JetBrains.Common.Util.Tasks.Impl.IHaveAsyncLifetime.Lifetime { get; }
    private CancellationToken JetBrains.Common.Util.Tasks.Impl.IHaveCancellationToken.Token { get; }
    public int RecommendedParallelizmDegree { get; }
    protected ExecutionControllerProxy(IExecutionController target);
    public virtual void Dispose();
    private sealed virtual override AsyncLifetime JetBrains.Common.Util.Tasks.Impl.IHaveAsyncLifetime.get_Lifetime();
    private sealed virtual override CancellationToken JetBrains.Common.Util.Tasks.Impl.IHaveCancellationToken.get_Token();
    public abstract virtual IExecutionController CreateSubOperation(int parentStepsCount);
    public virtual IExecutionController StartProgress(int stepsCount, string operationName);
    public virtual IExecutionController AttachSubOperation(Task task, int parentStepsCount);
    public virtual void AdvanceProgress();
    public virtual void Yield();
    public virtual void Wait(IWaitable waitable, TimeSpan timeout);
    public virtual Task`1<T> Fork(Func`2<IExecutionController, T> action);
    public sealed virtual int get_RecommendedParallelizmDegree();
}
public interface JetBrains.Common.Util.Tasks.Impl.IHaveAsyncLifetime {
    [NotNullAttribute]
public AsyncLifetime Lifetime { get; }
    public abstract virtual AsyncLifetime get_Lifetime();
}
public interface JetBrains.Common.Util.Tasks.Impl.IHaveCancellationToken {
    public CancellationToken Token { get; }
    public abstract virtual CancellationToken get_Token();
}
public class JetBrains.Common.Util.Tasks.Impl.InstantTaskScheduler : object {
    public static InstantTaskScheduler Instance;
    public AsyncLifetime Lifetime { get; }
    private static InstantTaskScheduler();
    public sealed virtual AsyncLifetime get_Lifetime();
    public sealed virtual Task`1<TResult> Schedule(Func`2<IExecutionController, TResult> action);
    public sealed virtual Task`1<TResult> CreateTask(Func`2<IExecutionController, TResult> action, CancellationToken cancellationToken);
    public sealed virtual void Schedule(Task task);
}
internal interface JetBrains.Common.Util.Tasks.Impl.IPriorityTaskGroupInternal {
    [NotNullAttribute]
public IPriorityTaskSchedulerInternal Scheduler { get; }
    public int TasksCount { get; }
    public int ThreadsOccupied { get; }
    public abstract virtual IPriorityTaskSchedulerInternal get_Scheduler();
    public abstract virtual int get_TasksCount();
    public abstract virtual int get_ThreadsOccupied();
    [CanBeNullAttribute]
public abstract virtual IPriorityTaskInternal TryFindTask(Task task);
    public abstract virtual void GetRunnableTasks(ISet`1<IPriorityTaskInternal> runnableTasks, int maxCount);
    [NotNullAttribute]
public abstract virtual IPriorityTaskInternal`1<T> CreateTaskInternal(Func`2<IExecutionController, T> action, CancellationToken cancellationToken);
    public abstract virtual void ScheduleInternal(IPriorityTaskInternal task);
}
internal interface JetBrains.Common.Util.Tasks.Impl.IPriorityTaskInternal {
    [NotNullAttribute]
public Task SystemTask { get; }
    [NotNullAttribute]
public IPriorityTaskGroupInternal Group { get; }
    public PriorityTaskState State { get; }
    public bool IsRunnable { get; }
    public bool IsThreadOccupied { get; }
    public CancellationToken Token { get; }
    public abstract virtual Task get_SystemTask();
    public abstract virtual IPriorityTaskGroupInternal get_Group();
    public abstract virtual PriorityTaskState get_State();
    public abstract virtual bool get_IsRunnable();
    public abstract virtual bool get_IsThreadOccupied();
    public abstract virtual CancellationToken get_Token();
    public abstract virtual void Yield();
    public abstract virtual void Wait(IWaitable waitable, TimeSpan timeout);
    public abstract virtual void AdvanceProgress(double progressStep);
    public abstract virtual void UpdateOperation(string operation);
    [NotNullAttribute]
public abstract virtual IReadOnlyList`1<IPriorityTaskInternal> GetAttachedTasks();
    public abstract virtual void AttachTask(IPriorityTaskInternal subTask);
    public abstract virtual bool TryResume();
    public abstract virtual bool TryPause();
    public abstract virtual void Unfreeze();
    public abstract virtual bool TryInline();
    public abstract virtual void RunInline(IPriorityTaskInternal inlinerTask);
    public abstract virtual void OnInlineCompleted();
}
internal interface JetBrains.Common.Util.Tasks.Impl.IPriorityTaskInternal`1 {
    [NotNullAttribute]
public Task`1<T> SystemTask { get; }
    public abstract virtual Task`1<T> get_SystemTask();
}
internal interface JetBrains.Common.Util.Tasks.Impl.IPriorityTaskSchedulerInternal {
    public int ConcurrencyLevel { get; }
    public TaskScheduler SystemScheduler { get; }
    public abstract virtual int get_ConcurrencyLevel();
    [CanBeNullAttribute]
public abstract virtual IPriorityTaskInternal TryFindTask(Task task);
    public abstract virtual void BringToForeground(IPriorityTaskGroupInternal group);
    public abstract virtual void RemoveGroup(IPriorityTaskGroupInternal group);
    public abstract virtual void ReSchedule();
    public abstract virtual TaskScheduler get_SystemScheduler();
}
public class JetBrains.Common.Util.Tasks.Impl.JetApproximateProgress : object {
    private IExecutionController myController;
    private long myApproxSteps;
    private int myModulus;
    private long myActualSteps;
    [CompilerGeneratedAttribute]
private IExecutionController <AsExecutionController>k__BackingField;
    public long ActualSteps { get; }
    public IExecutionController AsExecutionController { get; }
    internal JetApproximateProgress(IExecutionController controller, long approxSteps, int modulus, string operation);
    public long get_ActualSteps();
    [CompilerGeneratedAttribute]
public IExecutionController get_AsExecutionController();
    public void YieldAndAdvance();
    public sealed virtual void Dispose();
}
internal class JetBrains.Common.Util.Tasks.Impl.LifetimedTaskScheduler : object {
    private AsyncLifetime myLifetime;
    private ICanScheduleTaskInternal myTargetScheduler;
    public AsyncLifetime Lifetime { get; }
    public LifetimedTaskScheduler(AsyncLifetime lifetime, ICanScheduleTaskInternal targetScheduler);
    public sealed virtual AsyncLifetime get_Lifetime();
    public sealed virtual Task`1<T> Schedule(Func`2<IExecutionController, T> action);
}
internal class JetBrains.Common.Util.Tasks.Impl.PerThreadTaskSchedulerInternal : TaskScheduler {
    public static TaskScheduler Instance;
    private static ILogger ourLogger;
    private ConcurrentStack`1<Worker> myWorkers;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) myUsedThreads;
    private static int Idle;
    private static int Pending;
    private static int Executing;
    private static int Exiting;
    private static PerThreadTaskSchedulerInternal();
    protected virtual void QueueTask(Task task);
    protected virtual bool TryExecuteTaskInline(Task task, bool taskWasPreviouslyQueued);
    protected virtual IEnumerable`1<Task> GetScheduledTasks();
}
internal class JetBrains.Common.Util.Tasks.Impl.PriorityExecutionController : AbstractExecutionController {
    private IPriorityTaskInternal myTask;
    private CancellationToken JetBrains.Common.Util.Tasks.Impl.IHaveCancellationToken.Token { get; }
    public int RecommendedParallelizmDegree { get; }
    public PriorityExecutionController(IPriorityTaskInternal task);
    private sealed virtual override CancellationToken JetBrains.Common.Util.Tasks.Impl.IHaveCancellationToken.get_Token();
    public virtual int get_RecommendedParallelizmDegree();
    protected virtual void SubOperationAttached(Task task);
    protected virtual void YieldCore();
    protected virtual void WaitCore(IWaitable waitable, TimeSpan timeout);
    protected virtual Task`1<T> ForkCore(Func`2<IExecutionController, T> action);
    protected virtual void ProgressAdvanced(double delta);
    protected virtual void OperationUpdated(string operation);
}
[DebuggerDisplayAttribute("{mySystemTask.Id}: {myState}")]
internal class JetBrains.Common.Util.Tasks.Impl.PriorityTask`1 : object {
    private static ILogger ourLogger;
    private object myMutex;
    private ManualResetEventSlim myContinuationEvent;
    private CancellationToken myCancellationToken;
    private IPriorityTaskGroupInternal myOwnerGroup;
    private HashSet`1<IPriorityTaskInternal> myAttachedTasks;
    private Task`1<T> mySystemTask;
    private PriorityTaskState myState;
    private IPriorityTaskInternal myInlinerTask;
    public Task`1<T> SystemTask { get; }
    private Task JetBrains.Common.Util.Tasks.Impl.IPriorityTaskInternal.SystemTask { get; }
    public IPriorityTaskGroupInternal Group { get; }
    public CancellationToken Token { get; }
    public PriorityTaskState State { get; }
    public bool IsRunnable { get; }
    public bool IsThreadOccupied { get; }
    internal PriorityTask`1(IPriorityTaskGroupInternal group, Func`2<IExecutionController, T> action, CancellationToken cancellationToken);
    private static PriorityTask`1();
    private void TaskFinished();
    [LocalizableAttribute("False")]
public virtual string ToString();
    public sealed virtual Task`1<T> get_SystemTask();
    private sealed virtual override Task JetBrains.Common.Util.Tasks.Impl.IPriorityTaskInternal.get_SystemTask();
    public sealed virtual IPriorityTaskGroupInternal get_Group();
    public sealed virtual CancellationToken get_Token();
    public sealed virtual PriorityTaskState get_State();
    public sealed virtual bool get_IsRunnable();
    public sealed virtual bool get_IsThreadOccupied();
    public sealed virtual void Yield();
    public sealed virtual void Wait(IWaitable waitable, TimeSpan timeout);
    private void RunInlineIfPossible(TaskWaitable taskWaitable);
    private void WaitForResume();
    public sealed virtual void AdvanceProgress(double progressDelta);
    public sealed virtual void UpdateOperation(string operation);
    public sealed virtual IReadOnlyList`1<IPriorityTaskInternal> GetAttachedTasks();
    public sealed virtual void AttachTask(IPriorityTaskInternal subTask);
    public sealed virtual bool TryResume();
    public sealed virtual bool TryPause();
    public sealed virtual bool TryInline();
    public sealed virtual void Unfreeze();
    public sealed virtual void RunInline(IPriorityTaskInternal inlinerTask);
    public sealed virtual void OnInlineCompleted();
    private static void Verify(bool condition, string message);
    private void LogMyState();
}
internal class JetBrains.Common.Util.Tasks.Impl.PriorityTaskGroup : object {
    private static ILogger ourLogger;
    private object myMutex;
    private List`1<IPriorityTaskInternal> myTasks;
    private ProgressReporter myProgressableImpl;
    private AsyncLifetime myLifetime;
    private IPriorityTaskSchedulerInternal myScheduler;
    public AsyncLifetime Lifetime { get; }
    public IPriorityTaskSchedulerInternal Scheduler { get; }
    public int TasksCount { get; }
    public int ThreadsOccupied { get; }
    internal PriorityTaskGroup(AsyncLifetime lifetime, IPriorityTaskSchedulerInternal scheduler);
    private static PriorityTaskGroup();
    public sealed virtual AsyncLifetime get_Lifetime();
    public sealed virtual void BringToForeground();
    public sealed virtual Task`1<T> Schedule(Func`2<IExecutionController, T> action);
    public sealed virtual void Subscribe(AsyncLifetime lifetime, ITaskProgressListener listener);
    [LocalizableAttribute("False")]
public virtual string ToString();
    public sealed virtual Task`1<T> CreateTask(Func`2<IExecutionController, T> action, CancellationToken cancellationToken);
    public sealed virtual void Schedule(Task task);
    public sealed virtual IPriorityTaskSchedulerInternal get_Scheduler();
    public sealed virtual int get_TasksCount();
    public sealed virtual int get_ThreadsOccupied();
    public sealed virtual IPriorityTaskInternal TryFindTask(Task task);
    public sealed virtual void GetRunnableTasks(ISet`1<IPriorityTaskInternal> runnableTasks, int maxCount);
    public sealed virtual IPriorityTaskInternal`1<T> CreateTaskInternal(Func`2<IExecutionController, T> action, CancellationToken cancellationToken);
    public sealed virtual void ScheduleInternal(IPriorityTaskInternal task);
    private void AddTask(IPriorityTaskInternal task);
    private void RemoveTask(IPriorityTaskInternal task);
}
public class JetBrains.Common.Util.Tasks.Impl.PriorityTaskScheduler : object {
    [CompilerGeneratedAttribute]
private TaskScheduler <SystemScheduler>k__BackingField;
    public static int DefaultConcurrencyLevel;
    private static ILogger ourLogger;
    private object myMutex;
    private LinkedList`1<IPriorityTaskGroupInternal> myGroups;
    private HashSet`1<IPriorityTaskInternal> myRunningTasks;
    private StatCounters myStatCounters;
    private AsyncLifetime myLifetime;
    private bool myDoNotPause;
    private int myConcurrencyLevel;
    private int myReScheduleQueuedFlag;
    private int myStopWorldFlag;
    public TaskScheduler SystemScheduler { get; }
    public int ConcurrencyLevel { get; public set; }
    public PriorityTaskScheduler(AsyncLifetime lifetime, int concurrencyLevel, TaskScheduler systemScheduler, bool doNotPause);
    public PriorityTaskScheduler(int concurrencyLevel);
    public PriorityTaskScheduler(AsyncLifetime lifetime);
    private static PriorityTaskScheduler();
    [CompilerGeneratedAttribute]
public sealed virtual TaskScheduler get_SystemScheduler();
    public sealed virtual int get_ConcurrencyLevel();
    public sealed virtual void set_ConcurrencyLevel(int value);
    public sealed virtual void PauseWorld();
    public sealed virtual void ResumeWorld();
    public sealed virtual IPriorityTaskGroup CreateGroup(AsyncLifetime lifetime);
    private sealed virtual override void JetBrains.Common.Util.Tasks.Impl.IPriorityTaskSchedulerInternal.RemoveGroup(IPriorityTaskGroupInternal group);
    private sealed virtual override void JetBrains.Common.Util.Tasks.Impl.IPriorityTaskSchedulerInternal.BringToForeground(IPriorityTaskGroupInternal group);
    private sealed virtual override IPriorityTaskInternal JetBrains.Common.Util.Tasks.Impl.IPriorityTaskSchedulerInternal.TryFindTask(Task task);
    private sealed virtual override void JetBrains.Common.Util.Tasks.Impl.IPriorityTaskSchedulerInternal.ReSchedule();
    private void DoReSchedule();
    private void FlushStatistics();
}
internal enum JetBrains.Common.Util.Tasks.Impl.PriorityTaskState : Enum {
    public int value__;
    public static PriorityTaskState Frozen;
    public static PriorityTaskState Pending;
    public static PriorityTaskState Executing;
    public static PriorityTaskState Pausing;
    public static PriorityTaskState Waiting;
    public static PriorityTaskState Paused;
    public static PriorityTaskState Resuming;
    public static PriorityTaskState Finished;
}
public class JetBrains.Common.Util.Tasks.Impl.ProgressableTaskScheduler : object {
    private ProgressReporter myImpl;
    private ICanScheduleTask myTargetScheduler;
    public AsyncLifetime Lifetime { get; }
    public ProgressableTaskScheduler(ICanScheduleTask targetScheduler);
    public sealed virtual AsyncLifetime get_Lifetime();
    public sealed virtual Task`1<T> Schedule(Func`2<IExecutionController, T> action);
    private sealed virtual override Task`1<T> JetBrains.Common.Util.Tasks.ICanScheduleTaskInternal.CreateTask(Func`2<IExecutionController, T> action, CancellationToken cancellationToken);
    private sealed virtual override void JetBrains.Common.Util.Tasks.ICanScheduleTaskInternal.Schedule(Task task);
    public sealed virtual void Subscribe(AsyncLifetime lifetime, ITaskProgressListener listener);
}
public class JetBrains.Common.Util.Tasks.Impl.ProgressAggregator : object {
    private static ILogger ourLogger;
    private IDictionary`2<int, int> myTasksProgress;
    private double myProgressFactor;
    private double myProgressValue;
    private int myProgressIntValue;
    private string myOperation;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    public bool HasTasks { get; }
    public int Progress { get; }
    public string Operation { get; }
    private static ProgressAggregator();
    public bool get_HasTasks();
    public int get_Progress();
    public string get_Operation();
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    public sealed virtual void OnTaskScheduled(int taskId);
    public sealed virtual void OnTaskFinished(int taskId);
    private void CheckCompleted();
    public sealed virtual void OnTaskOperationChanged(int taskId, string operation);
    public sealed virtual void OnTaskProgressChanged(int taskId, int progress);
    private void RecalcSpeedFactor();
    private void UpdateProgress(int taskId, int progress);
    private void UpdateOperation(string operation);
    private static int ProgressCorrection(int value);
}
public class JetBrains.Common.Util.Tasks.Impl.ProgressCounter : object {
    private Action`1<double> myAdvanceProgress;
    private Action`1<string> myUpdateOperation;
    private double myProgressRange;
    private string myPrevOperation;
    private double myProgressStep;
    private double myProgressLeft;
    private double myProgressDelta;
    private string myCurrentOperation;
    public ProgressCounter(Action`1<double> advanceProgress, Action`1<string> updateOperation);
    private ProgressCounter(ProgressCounter parent, double progressRange, string prevOperation);
    public void StartProgress(int steps, string operationName);
    public ProgressCounter CreateSubOperation(int parentSteps);
    public void AttachSubOperation(Task task, int parentSteps);
    public void AdvanceProgress(int steps);
    public void Finish();
}
internal class JetBrains.Common.Util.Tasks.Impl.ProgressReporter : object {
    private object myMutex;
    private HashSet`1<int> myTaskIds;
    private List`1<ITaskProgressListener> myProgressListeners;
    public sealed virtual void Subscribe(AsyncLifetime lifetime, ITaskProgressListener listener);
    public void AddTask(Task task);
    private void RemoveTask(int taskId);
    private void OnProgressChanged(ProgressChangedEvent evt);
}
internal static class JetBrains.Common.Util.Tasks.Impl.ProgressValue : object {
    public static double Unit;
    public static double Max;
    public static double Eps;
    public static double MaxWithEps;
    public static int Round(double progress);
}
internal class JetBrains.Common.Util.Tasks.Impl.SequentialTaskScheduler : object {
    private AsyncLifetime myLifetime;
    private ICanScheduleTaskInternal myTargetScheduler;
    private object myMutex;
    private Queue`1<Task> myPendingTasks;
    private CancellationTokenSource myCancellationSource;
    private Task myRunningTask;
    public AsyncLifetime Lifetime { get; }
    public SequentialTaskScheduler(AsyncLifetime lifetime, ICanScheduleTaskInternal targetScheduler);
    public sealed virtual AsyncLifetime get_Lifetime();
    public sealed virtual void Reset(bool awaitFinished);
    public sealed virtual Task`1<TResult> Schedule(Func`2<IExecutionController, TResult> action);
    private void OnTaskFinished();
    private void ScheduleInternal(Task task);
    private void OnLifetimeTerminated();
}
public class JetBrains.Common.Util.Tasks.Impl.SynchronizedTaskProgressListener : object {
    private AsyncLifetime myLifetime;
    private IStaThreadDispatcher myDispatcher;
    private ITaskProgressListener myTarget;
    public SynchronizedTaskProgressListener(AsyncLifetime lifetime, IStaThreadDispatcher dispatcher, ITaskProgressListener target);
    public sealed virtual void OnTaskScheduled(int taskId);
    public sealed virtual void OnTaskProgressChanged(int taskId, int progress);
    public sealed virtual void OnTaskOperationChanged(int taskId, string operation);
    public sealed virtual void OnTaskFinished(int taskId);
}
internal static class JetBrains.Common.Util.Tasks.Impl.TaskAnnotation : object {
    public static string ANNOTATE_TASK;
    public static int MaxStackFrames;
    private static ILogger ourLogger;
    private static TaskAnnotation();
    [ConditionalAttribute("JET_MODE_ANNOTATE_TASKS")]
public static void Created(Task task, CancellationToken cancellationToken);
    [ConditionalAttribute("JET_MODE_ANNOTATE_TASKS")]
public static void Started();
    [ConditionalAttribute("JET_MODE_ANNOTATE_TASKS")]
public static void Finished(CancellationToken cancellationToken);
    [ConditionalAttribute("JET_MODE_ANNOTATE_TASKS")]
public static void CancellationRequested(CancellationTokenSource cancellationSource);
    [ConditionalAttribute("JET_MODE_ANNOTATE_TASKS")]
public static void Awaited(Task task, CancellationToken cancellationToken);
    [ConditionalAttribute("JET_MODE_ANNOTATE_TASKS")]
public static void Awaited(Task[] tasks, CancellationToken cancellationToken, TimeSpan timeout);
    [ConditionalAttribute("JET_MODE_ANNOTATE_TASKS")]
public static void Awaited(ManualResetEventSlim event, CancellationToken cancellationToken);
    [ConditionalAttribute("JET_MODE_ANNOTATE_TASKS")]
public static void TokensCombined(CancellationToken tokenA, CancellationToken tokenB, CancellationToken tokenC);
    [ConditionalAttribute("JET_MODE_ANNOTATE_TASKS")]
public static void TokensCombined(CancellationToken tokenA, CancellationToken tokenB, CancellationToken tokenC, CancellationToken tokenD);
    [ConditionalAttribute("JET_MODE_ANNOTATE_TASKS")]
public static void TokenLinked(CancellationToken token, CancellationTokenSource source);
    [ConditionalAttribute("JET_MODE_ANNOTATE_TASKS")]
public static void Comment(string comment);
    private static string GetCurrentId();
    private static string GetWaiter();
    private static string GetCancelledTag(CancellationToken token);
    [LocalizableAttribute("False")]
private static string GetCurrentStack();
}
public class JetBrains.Common.Util.Tasks.Impl.TaskDetailedProgress : object {
    private static string DefaultOperation;
    private static string WaitingOperation;
    private static TimeSpan ourPingTime;
    private static TimeSpan ourMaxIdleTime;
    private object myMutex;
    private HashSet`1<int> myTrackedSubTasks;
    private int myTaskId;
    private int myProgress;
    private string myOperation;
    private int mySubTaskId;
    private int mySubProgress;
    private string mySubOperation;
    private DateTime myLastUpdated;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    public int Progress { get; }
    public string Operation { get; }
    public TaskDetailedProgress(Task task);
    private static TaskDetailedProgress();
    public int get_Progress();
    public string get_Operation();
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    private void OnProgressChanged(ProgressChangedEvent evt);
    private void OnTimerTick(object _);
    private bool TryPickSubTask();
}
[ExtensionAttribute]
internal static class JetBrains.Common.Util.Tasks.Impl.TaskInternalUtils : object {
    public static bool IsOperationCancelled(AggregateException exception);
    public static Exception TryUnwrapException(Task task);
    public static bool TryStart(Task task);
    public static bool TryStart(Task task, TaskScheduler systemScheduler);
    public static bool TryStart(AsyncLifetime lifetime, Task task, TaskScheduler systemScheduler);
    public static bool TryStart(AsyncLifetime lifetime, Task task);
    [ExtensionAttribute]
public static Task WhenAllCallbacks(Task this);
}
public class JetBrains.Common.Util.Tasks.Impl.TaskOperationDetails : object {
    private static int UpdateInterval;
    private static int ThresholdInterval;
    private int myTaskId;
    private int myLastUpdated;
    private bool myDetailedMode;
    private TaskOperationDetails(int taskId);
    [StringFormatMethodAttribute("message")]
public void Format(string message, long processedItems, long totalItems);
    public void Set(string operation);
    public static TaskOperationDetails OfCurrentTask();
}
internal static class JetBrains.Common.Util.Tasks.Impl.TaskProgressMediator : object {
    private static ConcurrentDictionary`2<int, ProgressInfoInternal> ourProgresses;
    private static TaskProgressMediator();
    public static bool TrySubscribe(int taskId, Action`1<ProgressChangedEvent> handler);
    internal static void Register(Task task);
    [CanBeNullAttribute]
public static ProgressInfo TryGetProgress(int taskId);
    [IteratorStateMachineAttribute("JetBrains.Common.Util.Tasks.Impl.TaskProgressMediator/<GetAttachedProgressFlattened>d__7")]
public static IEnumerable`1<ProgressInfo> GetAttachedProgressFlattened(int taskId);
    internal static bool TaskAttached(int taskId, int attachedId);
    internal static bool AdvanceProgress(int taskId, double progressDelta);
    internal static bool UpdateOperation(int taskId, string newOperation);
    private static void NotifyHandlers(int taskId, ProgressInfoInternal info);
    private static void RefreshTimes(ProgressInfoInternal info);
}
public class JetBrains.Common.Util.Tasks.Impl.ThreadPoolTaskScheduler : object {
    public static ThreadPoolTaskScheduler Instance;
    private static int ourMaxParallelizmDegree;
    private AsyncLifetime myLifetime;
    public AsyncLifetime Lifetime { get; }
    public ThreadPoolTaskScheduler(AsyncLifetime lifetime);
    private static ThreadPoolTaskScheduler();
    public sealed virtual AsyncLifetime get_Lifetime();
    public sealed virtual Task`1<T> Schedule(Func`2<IExecutionController, T> action);
    private sealed virtual override Task`1<T> JetBrains.Common.Util.Tasks.ICanScheduleTaskInternal.CreateTask(Func`2<IExecutionController, T> action, CancellationToken cancellationToken);
    private sealed virtual override void JetBrains.Common.Util.Tasks.ICanScheduleTaskInternal.Schedule(Task task);
    private static Task`1<T> CreateTaskInternal(Func`2<IExecutionController, T> action, CancellationToken cancellationToken);
}
public class JetBrains.Common.Util.Tasks.Impl.YieldExecutionController : ExecutionControllerProxy {
    public YieldExecutionController(IExecutionController target);
    public virtual IExecutionController StartProgress(int stepsCount, string operationName);
    public virtual IExecutionController CreateSubOperation(int parentStepsCount);
    public virtual IExecutionController AttachSubOperation(Task task, int parentStepsCount);
    public virtual void AdvanceProgress();
    public virtual void Dispose();
}
public interface JetBrains.Common.Util.Tasks.IPriorityTaskGroup {
    public abstract virtual void BringToForeground();
}
public interface JetBrains.Common.Util.Tasks.IPriorityTaskScheduler {
    public int ConcurrencyLevel { get; public set; }
    public abstract virtual int get_ConcurrencyLevel();
    public abstract virtual void set_ConcurrencyLevel(int value);
    [NotNullAttribute]
public abstract virtual IPriorityTaskGroup CreateGroup(AsyncLifetime lifetime);
}
public interface JetBrains.Common.Util.Tasks.ISequentialTaskScheduler {
    public abstract virtual void Reset(bool awaitFinished);
}
public interface JetBrains.Common.Util.Tasks.IStaThreadDispatcher {
    public abstract virtual void Invoke(Action action);
    public abstract virtual void BeginInvoke(Action action);
    public abstract virtual bool CheckAccess();
    public abstract virtual void VerifyAccess();
}
public interface JetBrains.Common.Util.Tasks.ITaskProgressListener {
    public abstract virtual void OnTaskScheduled(int taskId);
    public abstract virtual void OnTaskProgressChanged(int taskId, int progress);
    public abstract virtual void OnTaskOperationChanged(int taskId, string operation);
    public abstract virtual void OnTaskFinished(int taskId);
}
public interface JetBrains.Common.Util.Tasks.IWaitable {
    public abstract virtual bool TryContinue(CancellationToken cancellationToken);
    public abstract virtual void Wait(TimeSpan timeout, CancellationToken cancellationToken);
}
[IsReadOnlyAttribute]
public class JetBrains.Common.Util.Tasks.ParallelExecutionFlow : ValueType {
    public IExecutionController Controller;
    public int ParallelizmDegree;
    internal ParallelExecutionFlow(IExecutionController controller, int parallelizmDegree);
}
public class JetBrains.Common.Util.Tasks.ParallelExecutionGuard : object {
    private List`1<Task> myTasks;
    public void Track(Task task);
    [NotNullAttribute]
public Task[] Await(IExecutionController controller);
    private sealed virtual override void System.IDisposable.Dispose();
}
public class JetBrains.Common.Util.Tasks.StaThreadDispatcher : object {
    [ThreadStaticAttribute]
private static IStaThreadDispatcher ourCurrentDispatcher;
    private JetDispatcher myDispatcher;
    public StaThreadDispatcher(JetDispatcher dispatcher);
    [NotNullAttribute]
public static IStaThreadDispatcher GetCurrent();
    [CanBeNullAttribute]
public static IStaThreadDispatcher TryGetCurrent();
    public static IDisposable SetCurrent(IStaThreadDispatcher dispatcher);
    public sealed virtual void Invoke(Action action);
    public sealed virtual void BeginInvoke(Action action);
    public sealed virtual bool CheckAccess();
    public sealed virtual void VerifyAccess();
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.Tasks.TaskCallbackExtension : object {
    [ExtensionAttribute]
[ThreadSafetyAttribute("4294967295")]
public static Task OnSuccess(Task this, Action action);
    [ExtensionAttribute]
[ThreadSafetyAttribute("4294967295")]
public static Task OnSuccess(Task this, AsyncLifetime lifetime, Action action);
    [ExtensionAttribute]
[ThreadSafetyAttribute("4294967295")]
public static Task`1<T> OnSuccess(Task`1<T> this, Action`1<T> action);
    [ExtensionAttribute]
[ThreadSafetyAttribute("4294967295")]
public static Task`1<T> OnSuccess(Task`1<T> this, AsyncLifetime lifetime, Action`1<T> action);
    [ExtensionAttribute]
[ThreadSafetyAttribute("1")]
public static Task OnSuccessSynchronized(Task this, Action action);
    [ExtensionAttribute]
[ThreadSafetyAttribute("1")]
public static Task OnSuccessSynchronized(Task this, AsyncLifetime lifetime, Action action);
    [ExtensionAttribute]
[ThreadSafetyAttribute("1")]
public static Task`1<T> OnSuccessSynchronized(Task`1<T> this, Action`1<T> action);
    [ExtensionAttribute]
[ThreadSafetyAttribute("1")]
public static Task`1<T> OnSuccessSynchronized(Task`1<T> this, AsyncLifetime lifetime, Action`1<T> action);
    [ExtensionAttribute]
[ThreadSafetyAttribute("4294967295")]
public static Task OnSuccessSynchronized(Task this, IStaThreadDispatcher dispatcher, Action action);
    [ExtensionAttribute]
[ThreadSafetyAttribute("4294967295")]
public static Task OnSuccessSynchronized(Task this, IStaThreadDispatcher dispatcher, AsyncLifetime lifetime, Action action);
    [ExtensionAttribute]
[ThreadSafetyAttribute("4294967295")]
public static Task`1<T> OnSuccessSynchronized(Task`1<T> this, IStaThreadDispatcher dispatcher, Action`1<T> action);
    [ExtensionAttribute]
[ThreadSafetyAttribute("4294967295")]
public static Task`1<T> OnSuccessSynchronized(Task`1<T> this, IStaThreadDispatcher dispatcher, AsyncLifetime lifetime, Action`1<T> action);
    [ExtensionAttribute]
[ThreadSafetyAttribute("4294967295")]
public static Task OnFinish(Task this, Action action);
    [ExtensionAttribute]
[ThreadSafetyAttribute("4294967295")]
public static Task OnFinish(Task this, AsyncLifetime lifetime, Action action);
    [ExtensionAttribute]
[ThreadSafetyAttribute("1")]
public static Task OnFinishSynchronized(Task this, Action action);
    [ExtensionAttribute]
[ThreadSafetyAttribute("1")]
public static Task OnFinishSynchronized(Task this, AsyncLifetime lifetime, Action action);
    [ExtensionAttribute]
[ThreadSafetyAttribute("4294967295")]
public static Task OnFinishSynchronized(Task this, IStaThreadDispatcher dispatcher, Action action);
    [ExtensionAttribute]
[ThreadSafetyAttribute("4294967295")]
public static Task OnFinishSynchronized(Task this, IStaThreadDispatcher dispatcher, AsyncLifetime lifetime, Action action);
    [ExtensionAttribute]
[ThreadSafetyAttribute("4294967295")]
public static Task OnFailure(Task this, Action`1<Exception> action);
    [ExtensionAttribute]
[ThreadSafetyAttribute("4294967295")]
public static Task OnFailure(Task this, AsyncLifetime lifetime, Action`1<Exception> action);
    [ExtensionAttribute]
[ThreadSafetyAttribute("4294967295")]
public static Task OnCancel(Task this, Action action);
    [ExtensionAttribute]
[ThreadSafetyAttribute("4294967295")]
public static Task OnCancel(Task this, AsyncLifetime lifetime, Action action);
    [ExtensionAttribute]
[ThreadSafetyAttribute("4294967295")]
public static Task`1<T> ContinueWith(Task`1<T> this, AsyncLifetime lifetime, Action`1<Task`1<T>> action);
    [ExtensionAttribute]
public static Task OnFailureLogException(Task this);
    [ExtensionAttribute]
public static Task`1<T> OnFailureLogException(Task`1<T> this);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.Tasks.TaskPipeExtensions : object {
    [ExtensionAttribute]
public static IAsyncDataProvider`1<T> AsDataProvider(Task`1<T> task);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.Tasks.TaskProgressExtension : object {
    [ExtensionAttribute]
public static ProgressProvider ProgressProvider(Task task);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.Tasks.TaskStatusExtension : object {
    [ExtensionAttribute]
public static bool IsSucceededEx(Task task);
    [ExtensionAttribute]
public static bool IsCancelledEx(Task task);
    [ExtensionAttribute]
public static bool IsFailedEx(Task task);
    [ExtensionAttribute]
public static bool IsFinishedEx(Task task);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.Tasks.TaskSyntaxSugar : object {
    [ExtensionAttribute]
public static ForkedFlow`2<TSelfOut, TChildOut> Fork(IExecutionController controller, Func`3<TSelfIn, IExecutionController, TSelfOut> doSelf, TSelfIn selfInput, Func`3<TChildIn, IExecutionController, TChildOut> doChild, TChildIn childInput);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.Tasks.TaskWaitExtension : object {
    [ExtensionAttribute]
public static void Join(Task this, TimeSpan timeout);
    [ExtensionAttribute]
public static void Join(Task this, TimeSpan timeout, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static T Join(Task`1<T> this, TimeSpan timeout);
    [ExtensionAttribute]
public static T Join(Task`1<T> this, TimeSpan timeout, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static void JoinOrThrowCancelled(Task this, TimeSpan timeout);
    [ExtensionAttribute]
public static T JoinOrThrowCancelled(Task`1<T> this, TimeSpan timeout);
    [ExtensionAttribute]
public static bool TryAwaitFinished(Task this, TimeSpan timeout);
    [ExtensionAttribute]
public static void AwaitFinished(Task this, TimeSpan timeout);
}
public static class JetBrains.Common.Util.Tasks.Waitable : object {
    public static TimeSpan InfiniteTimeout;
    public static IWaitable Sleeper;
    private static Waitable();
    public static IWaitable From(Task[] tasks);
    public static IWaitable From(ManualResetEventSlim event);
    private static IWaitable From(WaitHandle handle);
}
public static class JetBrains.Common.Util.Tasks.XTask : object {
    [CompilerGeneratedAttribute]
private static TaskScheduler <Scheduler>k__BackingField;
    public static TaskScheduler Scheduler { get; public set; }
    private static XTask();
    [CompilerGeneratedAttribute]
public static TaskScheduler get_Scheduler();
    [CompilerGeneratedAttribute]
public static void set_Scheduler(TaskScheduler value);
    public static Task Run(Lifetime lifetime, Action action);
    public static Task Run(AsyncLifetime lifetime, Action action);
}
public static class JetBrains.Common.Util.TeamCity.TeamCityDetector : object {
    public static bool IsUnderTeamCity();
}
public class JetBrains.Common.Util.ThreadUnsafetyGuard : object {
    private int myFlag;
    private string myExceptionMessage;
    public ThreadUnsafetyGuard(string exceptionMessage);
    public IDisposable Enter();
    private sealed virtual override void System.IDisposable.Dispose();
}
[DebuggerDisplayAttribute("CollectionRange [{Start}, {Last}]")]
public class JetBrains.Common.Util.Transforms.CollectionRange : ValueType {
    public int Start;
    public int Count;
    public static CollectionRange Empty;
    public int Last { get; }
    public CollectionRange(int start, int count);
    private static CollectionRange();
    public int get_Last();
    public bool Equals(CollectionRange other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(CollectionRange r1, CollectionRange r2);
    public static bool op_Inequality(CollectionRange r1, CollectionRange r2);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.Transforms.CollectionRangeEx : object {
    [ExtensionAttribute]
public static bool Contains(CollectionRange first, CollectionRange second);
    [ExtensionAttribute]
public static bool Contains(CollectionRange range, int index);
    [ExtensionAttribute]
public static CollectionRange Intersect(CollectionRange r1, CollectionRange r2);
    [ExtensionAttribute]
public static bool IsConjugateTo(CollectionRange r1, CollectionRange r2);
    [ExtensionAttribute]
public static bool StartsBefore(CollectionRange r1, CollectionRange r2);
    [ExtensionAttribute]
public static CollectionRange TryDropEnd(CollectionRange r1, CollectionRange r2);
    private static CollectionRange FromStartLast(int start, int last);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.Transforms.Helpers : object {
    [ExtensionAttribute]
public static IObservableSet`1<bool> ToObservableSet(IDataControllerContainer`1<Nullable`1<bool>> value);
    [ExtensionAttribute]
public static IDataProvider`1<IReadOnlyCollection`1<bool>> ToCollection(IDataProvider`1<Nullable`1<bool>> value);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static Predicate`1<T> And(Predicate`1<T> p1, Predicate`1<T> p2);
}
public interface JetBrains.Common.Util.Transforms.ICoordinateConvertor {
    public ModelRangeDouble TotalRange { get; public set; }
    public double ScreenWidth { get; public set; }
    public abstract virtual ModelRangeDouble ScreenToData(ScreenRange range);
    public abstract virtual ScreenRange DataToScreen(ModelRangeDouble range);
    public abstract virtual ModelRangeDouble get_TotalRange();
    public abstract virtual void set_TotalRange(ModelRangeDouble value);
    public abstract virtual double get_ScreenWidth();
    public abstract virtual void set_ScreenWidth(double value);
}
public class JetBrains.Common.Util.Transforms.Impl.CoordinateConvertor : object {
    [CompilerGeneratedAttribute]
private double <ScreenWidth>k__BackingField;
    [CompilerGeneratedAttribute]
private ModelRangeDouble <TotalRange>k__BackingField;
    public double ScreenWidth { get; public set; }
    public ModelRangeDouble TotalRange { get; public set; }
    private double DataToScreen(double x);
    private double ScreenToData(double x);
    [CompilerGeneratedAttribute]
public sealed virtual double get_ScreenWidth();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ScreenWidth(double value);
    public sealed virtual ModelRangeDouble ScreenToData(ScreenRange range);
    public sealed virtual ScreenRange DataToScreen(ModelRangeDouble range);
    [CompilerGeneratedAttribute]
public sealed virtual ModelRangeDouble get_TotalRange();
    [CompilerGeneratedAttribute]
public sealed virtual void set_TotalRange(ModelRangeDouble value);
}
public enum JetBrains.Common.Util.Transforms.LeftRightNone : Enum {
    public int value__;
    public static LeftRightNone None;
    public static LeftRightNone Left;
    public static LeftRightNone Right;
    public static LeftRightNone Both;
}
[IsReadOnlyAttribute]
[ValueSerializerAttribute("JetBrains.Util.Serialization.JsonValueSerializerNewtonsoft`1<JetBrains.Common.Util.Transforms.ModelRange>")]
[DataContractAttribute]
public class JetBrains.Common.Util.Transforms.ModelRange : ValueType {
    [DataMemberAttribute]
public ulong Left;
    [DataMemberAttribute]
public ulong Length;
    public static ModelRange MaxRange { get; }
    public ulong Right { get; }
    public bool IsDefault { get; }
    public ModelRange(ulong left, ulong length);
    public static ModelRange get_MaxRange();
    public ModelRange ExpandLeft(long value);
    public ModelRange ExpandRight(long value);
    public ModelRangeDouble CastToModelDouble();
    public ModelRange Union(ModelRange range);
    public Nullable`1<ModelRange> Intersect(ModelRange range);
    [PureAttribute]
public bool Contains(ModelRange range);
    public bool Contains(ulong position);
    public static ModelRange FromBorders(ulong left, ulong right);
    public static ModelRange FromPoint(ulong x);
    public ulong get_Right();
    public bool get_IsDefault();
    public sealed virtual bool Equals(ModelRange other);
    public static bool op_Equality(ModelRange left, ModelRange right);
    public static bool op_Inequality(ModelRange left, ModelRange right);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [LocalizableAttribute("False")]
public virtual string ToString();
}
[ValueSerializerAttribute("JetBrains.Util.Serialization.JsonValueSerializerNewtonsoft`1<JetBrains.Common.Util.Transforms.ModelRangeDouble>")]
[DataContractAttribute]
public class JetBrains.Common.Util.Transforms.ModelRangeDouble : ValueType {
    [DataMemberAttribute]
private double myLeft;
    [DataMemberAttribute]
private double myLength;
    public static ModelRangeDouble Max;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    public double Left { get; public set; }
    public double Length { get; public set; }
    public double Right { get; public set; }
    public double Center { get; }
    public ModelRangeDouble(double left, double length);
    private static ModelRangeDouble();
    public double get_Left();
    public void set_Left(double value);
    [LocalizableAttribute("False")]
public virtual string ToString();
    public double get_Length();
    public void set_Length(double value);
    public double get_Right();
    public void set_Right(double value);
    public static ModelRangeDouble FromBorders(double left, double right);
    public sealed virtual bool Equals(ModelRangeDouble other);
    public double get_Center();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public ModelRangeDouble SetLength(double length, double center);
    public ModelRangeDouble Expand(double factor);
    public ModelRangeDouble ExpandLength(double addLength);
    public ModelRangeDouble Union(ModelRangeDouble other);
    public ModelRangeDouble Zoom(double center, double zoomRatio);
    public ModelRangeDouble Zoom(double zoomRatio);
    public static bool op_Equality(ModelRangeDouble left, ModelRangeDouble right);
    public static bool op_Inequality(ModelRangeDouble left, ModelRangeDouble right);
    [PureAttribute]
public ModelRange CastToModelInt();
    private static ulong CheckedCast(double val);
    public ModelRange CheckedCastToModelInt();
    public bool Contains(ModelRangeDouble range);
    public bool Contains(double x);
    public ModelRangeDouble IntersectWith(ModelRangeDouble range);
    [CompilerGeneratedAttribute]
public void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_PropertyChanged(PropertyChangedEventHandler value);
}
public class JetBrains.Common.Util.Transforms.MoveResult : ValueType {
    [CompilerGeneratedAttribute]
private ScreenRange <Range>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <BordersInverted>k__BackingField;
    [CompilerGeneratedAttribute]
private LeftRightNone <ChangedBorder>k__BackingField;
    public ScreenRange Range { get; }
    public bool BordersInverted { get; }
    public LeftRightNone ChangedBorder { get; }
    public MoveResult(ScreenRange range, bool bordersInverted, LeftRightNone changedBorder);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ScreenRange get_Range();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_BordersInverted();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public LeftRightNone get_ChangedBorder();
}
public class JetBrains.Common.Util.Transforms.PeriodAndOffset : ValueType {
    public double Period;
    public double Offset;
    public PeriodAndOffset(double period, double offset);
}
public class JetBrains.Common.Util.Transforms.ScreenRange : ValueType {
    private double myLeft;
    private double myLength;
    public static ScreenRange Max;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    public double Left { get; public set; }
    public bool IsDefault { get; }
    public double Length { get; public set; }
    public double Right { get; public set; }
    public double Center { get; }
    public ScreenRange(double left, double length);
    private static ScreenRange();
    public double get_Left();
    public void set_Left(double value);
    [LocalizableAttribute("False")]
public virtual string ToString();
    public bool get_IsDefault();
    public double get_Length();
    public void set_Length(double value);
    public double get_Right();
    public void set_Right(double value);
    public static ScreenRange FromBorders(double left, double right);
    public sealed virtual bool Equals(ScreenRange other);
    public double get_Center();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public ScreenRange Zoom(double center, double zoomRatio);
    public ScreenRange Zoom(double zoomRatio);
    public static bool op_Equality(ScreenRange left, ScreenRange right);
    public static bool op_Inequality(ScreenRange left, ScreenRange right);
    public bool Contains(double x);
    public ScreenRange IntersectWith(ScreenRange range);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.Transforms.ScreenRangeEx : object {
    [ExtensionAttribute]
public static MoveResult MoveLeftBorder(ScreenRange range, double offset);
    [ExtensionAttribute]
public static MoveResult MoveRightBorder(ScreenRange range, double offset);
    [ExtensionAttribute]
public static MoveResult MoveBothBorders(ScreenRange range, double offset);
}
public class JetBrains.Common.Util.TransientLifetime : object {
    private LifetimeDefinition myLifetimeDefinition;
    public Lifetime Instance { get; }
    public TransientLifetime(string id);
    public TransientLifetime(Lifetime parentLifetime, string id);
    public Lifetime get_Instance();
    public static Lifetime op_Implicit(TransientLifetime transientLifetime);
    public void Terminate();
    public sealed virtual void Dispose();
}
public class JetBrains.Common.Util.TreeItem`1 : object {
    [CompilerGeneratedAttribute]
private T <Item>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<TreeItem`1<T>> <Children>k__BackingField;
    public T Item { get; public set; }
    public IEnumerable`1<TreeItem`1<T>> Children { get; public set; }
    [CompilerGeneratedAttribute]
public T get_Item();
    [CompilerGeneratedAttribute]
public void set_Item(T value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<TreeItem`1<T>> get_Children();
    [CompilerGeneratedAttribute]
public void set_Children(IEnumerable`1<TreeItem`1<T>> value);
}
public class JetBrains.Common.Util.TreeStructure.DfsTraverse.CombinedTreeVisitor`2 : VisitorCombiner`1<ITreeVisitor`2<T, TContext>> {
    public CombinedTreeVisitor`2(ITreeVisitor`2[] many);
    public sealed virtual VisitResult StartNodeProcessing(T ptr, TContext context);
    public sealed virtual void EndNodeProcessing(T ptr, TContext context);
    public sealed virtual void AllNodesProcessed();
}
public class JetBrains.Common.Util.TreeStructure.DfsTraverse.FuncTreeVisitor`2 : object {
    private Func`3<T, TContext, VisitResult> myStartNode;
    private Action`2<T, TContext> myEndNode;
    private Action myComplete;
    public FuncTreeVisitor`2(Func`3<T, TContext, VisitResult> startNode, Action`2<T, TContext> endNode, Action complete);
    public sealed virtual VisitResult StartNodeProcessing(T ptr, TContext sharedContext);
    public sealed virtual void EndNodeProcessing(T ptr, TContext sharedContext);
    public sealed virtual void AllNodesProcessed();
}
public interface JetBrains.Common.Util.TreeStructure.DfsTraverse.ITreeVisitor`2 {
    public abstract virtual VisitResult StartNodeProcessing(T ptr, TContext sharedContext);
    public abstract virtual void EndNodeProcessing(T ptr, TContext sharedContext);
    public abstract virtual void AllNodesProcessed();
}
[FlagsAttribute]
internal enum JetBrains.Common.Util.TreeStructure.DfsTraverse.NodeState : Enum {
    public byte value__;
    public static NodeState FirstStage;
    public static NodeState ChildrenTraversed;
}
[ExtensionAttribute]
internal static class JetBrains.Common.Util.TreeStructure.DfsTraverse.NodeStateExtensionMethods : object {
    [ExtensionAttribute]
public static bool IsSet(NodeState flags, NodeState flagToTest);
    [ExtensionAttribute]
public static bool IsClear(NodeState flags, NodeState flagToTest);
    [ExtensionAttribute]
public static NodeState Set(NodeState flags, NodeState setFlags);
    [ExtensionAttribute]
public static NodeState Clear(NodeState flags, NodeState clearFlags);
}
public class JetBrains.Common.Util.TreeStructure.DfsTraverse.NullTreeVisitor`2 : object {
    public static NullTreeVisitor`2<T, TContext> Instance;
    private static NullTreeVisitor`2();
    public sealed virtual VisitResult StartNodeProcessing(T ptr, TContext context);
    public sealed virtual void EndNodeProcessing(T ptr, TContext context);
    public sealed virtual void AllNodesProcessed();
}
public class JetBrains.Common.Util.TreeStructure.DfsTraverse.TreeDfsTraverse`1 : object {
    private Func`1<T> myRootGetter;
    private Func`2<T, IEnumerable`1<T>> myGetChildren;
    public TreeDfsTraverse`1(Func`1<T> rootGetter, Func`1<T> nullNodeGetter, Func`2<T, T> getFirstChild, Func`2<T, T> getNextSibling, IEqualityComparer`1<T> comparer);
    public TreeDfsTraverse`1(Func`1<T> rootGetter, Func`2<T, IEnumerable`1<T>> getChildren);
    [IteratorStateMachineAttribute("JetBrains.Common.Util.TreeStructure.DfsTraverse.TreeDfsTraverse`1/<GetChildren>d__4")]
private static IEnumerable`1<T> GetChildren(T node, Func`1<T> nullNodeGetter, Func`2<T, T> getFirstChild, IEqualityComparer`1<T> equalityComparer, Func`2<T, T> getNextSibling);
    public void Traverse(ITreeVisitor`2<T, TContext> visitor, bool advanceProgressEveryNode, Func`1<T> overriddenGetRoot);
    public void Traverse(ITreeVisitor`2<T, TContext> visitor, IExecutionController controller, bool advanceProgressEveryNode, Func`1<T> overriddenGetRoot);
    private void UpdateParentSnapshot(IEnumerator`1<T> child, bool childNodeExist, Snapshot`1& snapshot);
    private void PushNextChild(Stack`1<Snapshot`1<T, TContext>> stack, IEnumerator`1<T> child);
}
public class JetBrains.Common.Util.TreeStructure.DfsTraverse.VisitorCombiner`1 : object {
    protected List`1<T> List;
    public VisitorCombiner`1(T one);
    public VisitorCombiner`1(T[] many);
    public void Register(T one);
    public void Register(T[] many);
    public bool Deregister(T one);
    public void Deregister(T[] many);
}
public enum JetBrains.Common.Util.TreeStructure.DfsTraverse.VisitResult : Enum {
    public int value__;
    public static VisitResult ProcessChildren;
    public static VisitResult SkipChildren;
}
public class JetBrains.Common.Util.TreeStructure.EventHandlerWithState`1 : object {
    private Func`1<TEventArgs> myRestoreAction;
    [CompilerGeneratedAttribute]
private EventHandler`1<TEventArgs> Event;
    public EventHandlerWithState`1(Func`1<TEventArgs> restoreAction);
    public void Raise(object sender, TEventArgs args);
    public sealed virtual TEventArgs RestoreCurrentEventArgs();
    [CompilerGeneratedAttribute]
public sealed virtual void add_Event(EventHandler`1<TEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Event(EventHandler`1<TEventArgs> value);
}
public interface JetBrains.Common.Util.TreeStructure.IEventHandlerWithState`1 {
    [CanBeNullAttribute]
public abstract virtual TEventArgs RestoreCurrentEventArgs();
    [CompilerGeneratedAttribute]
public abstract virtual void add_Event(EventHandler`1<TEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Event(EventHandler`1<TEventArgs> value);
}
public class JetBrains.Common.Util.TreeStructure.ItemUpdatedEventArgs : EventArgs {
    public object Item;
    public ItemUpdatedEventArgs(object item);
}
public class JetBrains.Common.Util.TreeStructure.ItemUpdatedEventArgs`1 : EventArgs {
    public T Item;
    public ItemUpdatedEventArgs`1(T item);
}
public interface JetBrains.Common.Util.TreeStructure.ITreeListStructureProvider {
    public object Root { get; }
    [NotNullAttribute]
public IEventHandlerWithState`1<ItemUpdatedEventArgs> OnScrollToItem { get; }
    public abstract virtual object get_Root();
    public abstract virtual bool HasChildren(object item);
    public abstract virtual object GetParent(object item);
    public abstract virtual bool GetIsExpanded(object item);
    public abstract virtual void SetIsExpanded(object item, bool isExpanded);
    public abstract virtual IEnumerable GetChildren(object item);
    [CompilerGeneratedAttribute]
public abstract virtual void add_ItemUpdated(EventHandler`1<ItemUpdatedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ItemUpdated(EventHandler`1<ItemUpdatedEventArgs> value);
    public abstract virtual IEventHandlerWithState`1<ItemUpdatedEventArgs> get_OnScrollToItem();
}
public interface JetBrains.Common.Util.TreeStructure.ITreeListStructureProvider`1 {
    public T Root { get; }
    [NotNullAttribute]
public IEventHandlerWithState`1<ItemUpdatedEventArgs`1<T>> OnScrollToItem { get; }
    public abstract virtual T get_Root();
    public abstract virtual bool HasChildren(T item);
    public abstract virtual T GetParent(T item);
    public abstract virtual bool GetIsExpanded(T item);
    public abstract virtual void SetIsExpanded(T item, bool isExpanded);
    public abstract virtual IEnumerable`1<T> GetChildren(T item);
    [CompilerGeneratedAttribute]
public abstract virtual void add_ItemUpdated(EventHandler`1<ItemUpdatedEventArgs`1<T>> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ItemUpdated(EventHandler`1<ItemUpdatedEventArgs`1<T>> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_ItemUpdatedV2(EventHandler`1<NodeUpdatedEventArgs`1<T>> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ItemUpdatedV2(EventHandler`1<NodeUpdatedEventArgs`1<T>> value);
    public abstract virtual IEventHandlerWithState`1<ItemUpdatedEventArgs`1<T>> get_OnScrollToItem();
}
public class JetBrains.Common.Util.TreeStructure.NodeUpdatedEventArgs`1 : EventArgs {
    [CanBeNullAttribute]
public T Node;
    [CanBeNullAttribute]
public T OldChild;
    [CanBeNullAttribute]
public T NewChild;
    public int Index;
    public NodeUpdatedEventArgs`1(T node, T oldChild, T newChild, int index);
}
public class JetBrains.Common.Util.TreeStructure.SteppedTreeListStructureProviderAdapter`1 : object {
    private ITreeListStructureProvider`1<T> mySource;
    [CompilerGeneratedAttribute]
private EventHandler`1<ItemUpdatedEventArgs`1<T>> myItemUpdated;
    [CompilerGeneratedAttribute]
private EventHandler`1<NodeUpdatedEventArgs`1<T>> myItemUpdatedV2;
    private bool myShowRootExpander;
    public T Root { get; }
    public IEventHandlerWithState`1<ItemUpdatedEventArgs`1<T>> OnScrollToItem { get; }
    public SteppedTreeListStructureProviderAdapter`1(ITreeListStructureProvider`1<T> source, bool showRootExpander);
    [CompilerGeneratedAttribute]
private void add_myItemUpdated(EventHandler`1<ItemUpdatedEventArgs`1<T>> value);
    [CompilerGeneratedAttribute]
private void remove_myItemUpdated(EventHandler`1<ItemUpdatedEventArgs`1<T>> value);
    [CompilerGeneratedAttribute]
private void add_myItemUpdatedV2(EventHandler`1<NodeUpdatedEventArgs`1<T>> value);
    [CompilerGeneratedAttribute]
private void remove_myItemUpdatedV2(EventHandler`1<NodeUpdatedEventArgs`1<T>> value);
    private void OnItemUpdated(object sender, ItemUpdatedEventArgs`1<T> itemUpdatedEventArgs);
    private void OnItemUpdatedV2(object sender, NodeUpdatedEventArgs`1<T> originalArgs);
    public sealed virtual T get_Root();
    public sealed virtual bool HasChildren(T item);
    public sealed virtual T GetParent(T item);
    private ValueTuple`2<T, int> GetParentImpl(T item);
    private bool HasSingleChild(T item);
    public sealed virtual bool GetIsExpanded(T item);
    public sealed virtual void SetIsExpanded(T item, bool isExpanded);
    [IteratorStateMachineAttribute("JetBrains.Common.Util.TreeStructure.SteppedTreeListStructureProviderAdapter`1/<GetChildren>d__19")]
public sealed virtual IEnumerable`1<T> GetChildren(T item);
    public sealed virtual void add_ItemUpdated(EventHandler`1<ItemUpdatedEventArgs`1<T>> value);
    public sealed virtual void remove_ItemUpdated(EventHandler`1<ItemUpdatedEventArgs`1<T>> value);
    public sealed virtual void add_ItemUpdatedV2(EventHandler`1<NodeUpdatedEventArgs`1<T>> value);
    public sealed virtual void remove_ItemUpdatedV2(EventHandler`1<NodeUpdatedEventArgs`1<T>> value);
    public sealed virtual IEventHandlerWithState`1<ItemUpdatedEventArgs`1<T>> get_OnScrollToItem();
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.TreeStructure.TreeListStructureProviderEx : object {
    [ExtensionAttribute]
public static IDataProvider`1<PipeEventData`1<NodeUpdatedEventArgs`1<T>>> ToUpdatedNodeProvider(ITreeListStructureProvider`1<T> tsp);
    [ExtensionAttribute]
public static IDataProvider`1<PipeEventData`1<T>> ToUpdatedItemProvider(ITreeListStructureProvider`1<T> tsp);
    [ExtensionAttribute]
public static IDataProvider`1<PipeEventData`1<object>> ToUpdatedItemProvider(ITreeListStructureProvider tsp);
    [ExtensionAttribute]
public static ITreeListStructureProvider ToUntyped(ITreeListStructureProvider`1<T> provider);
    [ExtensionAttribute]
public static ITreeListStructureProvider`1<T2> Cast(ITreeListStructureProvider`1<T1> source);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.TryGetValueEx : object {
    [ExtensionAttribute]
public static TB GetValueSafe(ITryGetValue`2<TA, TB> map, TA key, TB fallback);
    [ExtensionAttribute]
public static TB GetValueSafe(ITryGetValue`2<TA, TB> map, TA key, Func`2<TA, TB> createFallbackValue);
    [ExtensionAttribute]
public static TValue GetValueSafe(IReadOnlyDictionary`2<TKey, TValue> dictionary, TKey key, TValue resultOnFail);
}
public class JetBrains.Common.Util.TVoid : object {
}
public class JetBrains.Common.Util.TwoListSynchronizer : object {
    private IList myMasterList;
    private IList myTargetList;
    public TwoListSynchronizer(IList masterList, IList targetList);
    public sealed virtual void StartSynchronizing();
    public sealed virtual void StopSynchronizing();
    public sealed virtual bool ReceiveWeakEvent(Type managerType, object sender, EventArgs e);
    private void ListenForChangeEvents(IList list);
    private void StopListeningForChangeEvents(IList list);
    private void NotifyCollectionChangedOnCollectionChanged(object sender, NotifyCollectionChangedEventArgs e);
    private static void AddItems(IList list, NotifyCollectionChangedEventArgs e);
    private void HandleCollectionChanged(object sender, NotifyCollectionChangedEventArgs e);
    private static void MoveItems(IList list, NotifyCollectionChangedEventArgs e);
    private void PerformActionOnAllLists(Action`2<IList, NotifyCollectionChangedEventArgs> action, IList sourceList, NotifyCollectionChangedEventArgs collectionChangedArgs);
    private void PerformActionOnList(IList list, Action`2<IList, NotifyCollectionChangedEventArgs> action, NotifyCollectionChangedEventArgs collectionChangedArgs);
    private static void RemoveItems(IList list, NotifyCollectionChangedEventArgs e);
    private static void ReplaceItems(IList list, NotifyCollectionChangedEventArgs e);
    private void SetListValuesFromSource(IList sourceList, IList targetList);
    private bool TargetAndMasterCollectionsAreEqual();
    private void UpdateListsFromSource(IList sourceList);
}
public class JetBrains.Common.Util.TwoListSynchronizer`2 : object {
    private IList`1<TMaster> myMasterList;
    private Func`2<TMaster, TTarget> myMasterToTargetConverter;
    private Func`2<TTarget, TMaster> myTargetToMasterConverter;
    private IList`1<TTarget> myTargetList;
    public TwoListSynchronizer`2(IList`1<TMaster> masterList, IList`1<TTarget> targetList, Func`2<TMaster, TTarget> masterToTargetConverter, Func`2<TTarget, TMaster> targetToMasterConverter);
    public sealed virtual void StartSynchronizing();
    public sealed virtual void StopSynchronizing();
    public sealed virtual bool ReceiveWeakEvent(Type managerType, object sender, EventArgs e);
    private void ListenForChangeEvents(IEnumerable list);
    private void StopListeningForChangeEvents(IEnumerable list);
    private void NotifyCollectionChangedOnCollectionChanged(object sender, NotifyCollectionChangedEventArgs e);
    private void AddItems(IList`1<B> list, NotifyCollectionChangedEventArgs e, Func`2<A, B> converter);
    private void HandleCollectionChanged(object sender, NotifyCollectionChangedEventArgs e);
    private void MoveItems(IList`1<B> list, NotifyCollectionChangedEventArgs e, Func`2<A, B> converter);
    private void RemoveItems(IList`1<B> list, NotifyCollectionChangedEventArgs e);
    private void ReplaceItems(IList`1<B> list, NotifyCollectionChangedEventArgs e, Func`2<A, B> converter);
    private void SetListValuesFromSource(IList`1<A> sourceList, IList`1<B> targetList, Func`2<A, B> converter);
    private bool TargetAndMasterCollectionsAreEqual();
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.TypeLogExtension : object {
    [ExtensionAttribute]
public static LoggableString ToLoggableString(Type type);
    private static string FormatTypeName(Type type, char format);
    [LocalizableAttribute("False")]
private static void FormatNamespace(StringBuilder typeName, Type type);
    [LocalizableAttribute("False")]
private static void FormatTypeName(StringBuilder typeName, Type type, char format);
}
public class JetBrains.Common.Util.Union.Union`2 : object {
    private TA myItem1;
    private TB myItem2;
    private int myTag;
    public Union`2(TA item);
    public Union`2(TB item);
    public T Match(Func`2<TA, T> f, Func`2<TB, T> g);
    public void Match(Action`1<TA> f, Action`1<TB> g);
}
public class JetBrains.Common.Util.Union.Union`3 : object {
    private TA myItem1;
    private TB myItem2;
    private TC myItem3;
    private int myTag;
    public Union`3(TA item);
    public Union`3(TB item);
    public Union`3(TC item);
    public T Match(Func`2<TA, T> f, Func`2<TB, T> g, Func`2<TC, T> h);
    public void Match(Action`1<TA> f, Action`1<TB> g, Action`1<TC> h);
}
public class JetBrains.Common.Util.Union.Union`4 : object {
    private TA myItem1;
    private TB myItem2;
    private TC myItem3;
    private TD myItem4;
    private int myTag;
    public Union`4(TA item);
    public Union`4(TB item);
    public Union`4(TC item);
    public Union`4(TD item);
    public T Match(Func`2<TA, T> f, Func`2<TB, T> g, Func`2<TC, T> h, Func`2<TD, T> j);
    public void Match(Action`1<TA> f, Action`1<TB> g, Action`1<TC> h, Action`1<TD> j);
}
public static class JetBrains.Common.Util.Units.FileSizeToStringConverter : object {
    public static string Convert(long value, CultureInfo culture);
}
public class JetBrains.Common.Util.Units.FormatString : object {
    private string myString;
    private Object[] myArgs;
    public FormatString(string s, Object[] args);
    public sealed virtual string ToString(string format, IFormatProvider formatProvider);
}
public class JetBrains.Common.Util.Units.FormattableLong : ValueType {
    private long myValue;
    private string mySingleUnit;
    private string myMultipleUnits;
    private string myValuePrefix;
    public FormattableLong(long value, string singleUnit, string multipleUnits, string valuePrefix);
    public virtual string ToString();
    public sealed virtual string ToString(string format, IFormatProvider formatProvider);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.Units.FormatUtils : object {
    public static NumberFormatInfo NumberFormat;
    private static long NsPerSec;
    private static FormatUtils();
    [LocalizableAttribute("False")]
public static string PrintNumber(double value, int minMeaningfulDigits, IFormatProvider formatProvider);
    [ExtensionAttribute]
public static UnitValue`1<TimeUnits> FormatTime(ITickTimeConverter converter, double ticks);
    [ExtensionAttribute]
public static UnitValue`1<TimeUnits> FormatToMilliseconds(ITickTimeConverter converter, double ticks);
    [ExtensionAttribute]
public static string PrintTimestamp(UnitValue`1<TimeUnits> time, TimeUnits maxUnit, int secondsPrecision);
    [ExtensionAttribute]
public static UnitValue`1<TimeUnits> FormatTime(ITickTimeConverter converter, double ticks, TimeUnits units);
    [ExtensionAttribute]
public static UnitValue`1<SizeSpeedUnits> FormatByteSpeed(ITickTimeConverter converter, double bytes, double ticks);
    public static UnitValue`1<SizeUnits> FormatByteSize(double bytes);
    public static UnitValue`1<SizeUnits> FormatToMegabytes(double bytes);
    public static UnitValue`1<SizeUnits> FormatToKilobytes(double bytes);
}
public static class JetBrains.Common.Util.Units.HumanReadableTimePresenter : object {
    public static string ConvertToHumanReadableTimespan(TimeSpan timeSpan, string lessThanMomentText, string lessThanSecondText);
    public static string ConvertUtcToHumanReadableDate(DateTime utcTime, bool useRelativeFormatting);
    private static bool IsSameDate(DateTime t1, DateTime t2);
    public static string ConvertUtcToLocalDateTime(DateTime utcDateTime);
    public static string ConvertUtcToHumanReadableDateAndTime(DateTime utcDateTime, bool useRelativeFormatting);
}
public interface JetBrains.Common.Util.Units.ITickTimeConverter {
    public double TicksPerNs { get; }
    public ulong TicksPerSecond { get; }
    public abstract virtual double ToNanoseconds(double tick);
    public abstract virtual double ToTicks(double nanoseconds);
    public abstract virtual double get_TicksPerNs();
    public abstract virtual ulong get_TicksPerSecond();
}
public class JetBrains.Common.Util.Units.PayloadPresenter : object {
    public Func`2<double, string> Print;
    public string DefaultMeasure;
    public PayloadPresenter(Func`2<double, string> print, string defaultMeasure);
    public static PayloadPresenter ForTime(ITickTimeConverter tickTimeConverter);
    public static PayloadPresenter ForTime(ITickTimeConverter tickTimeConverter, string format, IFormatProvider formatProvider);
    public static PayloadPresenter ForNanoseconds(string format, IFormatProvider formatProvider);
    public static PayloadPresenter ForSize();
    public static PayloadPresenter ForSizeKb();
}
public class JetBrains.Common.Util.Units.Percents : ValueType {
    public bool LeftAligned;
    public double Value;
    private static string LessThanMinimum;
    private static string Minimum;
    public Percents(double value, bool leftAligned);
    private static Percents();
    public sealed virtual bool Equals(Percents other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual string ToString(string format, IFormatProvider formatProvider);
    public static Percents op_Division(Percents p, double value);
    public static Percents op_Multiply(Percents p, double value);
    private string ToString(SmallValueDisplayMode smallValueDisplayMode);
    public virtual string ToString();
}
public class JetBrains.Common.Util.Units.Scale : object {
    private UInt64[] myPeriods;
    private double myMinPixelPerPeriod;
    public Scale(double minPixelPerPeriod, UInt64[] periods);
    public ulong GetPeriod(double unitsPerPixel);
}
public class JetBrains.Common.Util.Units.SizeSpeedUnits : UnitsBase {
    public static SizeSpeedUnits[] Values;
    private static int ValuesNum;
    private static String[] Labels;
    public static SizeSpeedUnits BytesPerSec;
    public static SizeSpeedUnits KilobytesPerSec;
    public static SizeSpeedUnits MegabytesPerSec;
    public static SizeSpeedUnits GigabytesPerSec;
    public int SizeInParent { get; }
    public int MaxValue { get; }
    public SizeSpeedUnits(int id);
    private static SizeSpeedUnits();
    public virtual string ToString();
    public virtual int get_SizeInParent();
    public virtual int get_MaxValue();
    internal virtual UnitsBase GetValue(int id);
}
public class JetBrains.Common.Util.Units.SizeUnits : UnitsBase {
    public static SizeUnits[] Values;
    private static Int32[] UnitSizes;
    private static int ValuesNum;
    private static String[] Labels;
    public static SizeUnits Byte;
    public static SizeUnits Kilobyte;
    public static SizeUnits Megabyte;
    public static SizeUnits Gigabyte;
    public int SizeInParent { get; }
    public int MaxValue { get; }
    private SizeUnits(int id);
    private static SizeUnits();
    public virtual string ToString();
    public virtual int get_SizeInParent();
    public virtual int get_MaxValue();
    internal virtual UnitsBase GetValue(int id);
}
public class JetBrains.Common.Util.Units.TickTimeConverter : object {
    private ulong myTicksPerSecond;
    private static ulong NsPerSec;
    public double TicksPerNs { get; }
    public ulong TicksPerSecond { get; }
    public TickTimeConverter(ulong ticksPerSecond);
    public sealed virtual double ToNanoseconds(double tick);
    public sealed virtual double ToTicks(double nanoseconds);
    public sealed virtual double get_TicksPerNs();
    public sealed virtual ulong get_TicksPerSecond();
}
public class JetBrains.Common.Util.Units.TimePresenter : object {
    private ulong myStartTick;
    private IFormatProvider myFormatProvider;
    private ITickTimeConverter myTickTimeConverter;
    public TimePresenter(ulong startTick, IFormatProvider formatProvider, ITickTimeConverter tickTimeConverter);
    [LocalizableAttribute("False")]
public string LogTime(ulong tick);
}
public class JetBrains.Common.Util.Units.TimeUnits : UnitsBase {
    private static TimeUnits[] Values;
    private static Int32[] UnitSizes;
    private static String[] Labels;
    private static int ValuesNum;
    public static TimeUnits Nanosecond;
    public static TimeUnits Microsecond;
    public static TimeUnits Millisecond;
    public static TimeUnits Second;
    public static TimeUnits Minute;
    public static TimeUnits Hour;
    public int SizeInParent { get; }
    public int MaxValue { get; }
    private TimeUnits(int id);
    private static TimeUnits();
    public virtual string ToString();
    public virtual int get_SizeInParent();
    public virtual int get_MaxValue();
    internal virtual UnitsBase GetValue(int id);
}
public abstract class JetBrains.Common.Util.Units.UnitsBase : object {
    private int myID;
    protected int ID { get; }
    public int SizeInParent { get; }
    public UnitsBase MinValue { get; }
    public bool IsMin { get; }
    public bool IsMax { get; }
    public int MaxValue { get; }
    protected UnitsBase(int id);
    private bool Equals(UnitsBase other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    protected int get_ID();
    public abstract virtual int get_SizeInParent();
    public static bool op_LessThan(UnitsBase t1, UnitsBase t2);
    public static bool op_GreaterThan(UnitsBase t1, UnitsBase t2);
    public static bool op_Equality(UnitsBase t1, UnitsBase t2);
    public static bool op_Inequality(UnitsBase t1, UnitsBase t2);
    public UnitsBase get_MinValue();
    public bool get_IsMin();
    public bool get_IsMax();
    public abstract virtual int get_MaxValue();
    internal abstract virtual UnitsBase GetValue(int id);
    public static int op_Implicit(UnitsBase e);
}
public class JetBrains.Common.Util.Units.UnitScale`1 : Scale {
    public UnitScale`1(double minPixelPerPeriod, UnitValue`1[] periods);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.Units.UnitUtils : object {
    [ExtensionAttribute]
public static T Next(T value);
    [ExtensionAttribute]
public static T Previous(T value);
    [ExtensionAttribute]
public static UnitValue`1<T> Convert(UnitValue`1<T> unitValue, int targetUnit);
    [ExtensionAttribute]
public static UnitValue`1<T> Floor(UnitValue`1<T> u);
    [ExtensionAttribute]
public static UnitValue`1<T> Convert(UnitValue`1<T> unitValue, T targetUnit);
    private static bool IsRound(UnitValue`1<T> part);
    private static double Remainder(double value, int divider);
    [ExtensionAttribute]
public static UnitValue`1<T> GetOwnPart(UnitValue`1<T> part);
    [ExtensionAttribute]
public static UnitValue`1<T> ToMinorPart(UnitValue`1<T> part);
    [ExtensionAttribute]
public static UnitValue`1<T> ToMajorPart(UnitValue`1<T> part);
    [ExtensionAttribute]
public static UnitValue`1<T> PreviousPart(UnitValue`1<T> part);
    [ExtensionAttribute]
public static UnitValue`1<T> NextPart(UnitValue`1<T> part);
}
public class JetBrains.Common.Util.Units.UnitValue`1 : ValueType {
    public double Value;
    public T Unit;
    public UnitValue`1(double value, T unit);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_LessThan(UnitValue`1<T> v1, UnitValue`1<T> v2);
    public static bool op_GreaterThan(UnitValue`1<T> v1, UnitValue`1<T> v2);
    public static UnitValue`1<T> op_Addition(UnitValue`1<T> v1, UnitValue`1<T> v2);
    public static UnitValue`1<T> op_Subtraction(UnitValue`1<T> v1, UnitValue`1<T> v2);
    public sealed virtual bool Equals(UnitValue`1<T> other);
    public virtual string ToString();
    [LocalizableAttribute("False")]
public sealed virtual string ToString(string format, IFormatProvider formatProvider);
}
public class JetBrains.Common.Util.Updates.AnonymizerUtil : object {
    public static string Anonymize(string salt, string data);
    public static string Anonymize(Byte[] salt, string data);
    [NotNullAttribute]
private static string ToHexString(Byte[] bytes);
}
public class JetBrains.Common.Util.Updates.ConsoleUpdatesHandler : object {
    private static string ConsoleMessageKey;
    public static IUpdatesHandler Instance;
    private static ConsoleUpdatesHandler();
    public sealed virtual void HandleUpdateInfo(string key, string value);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.Updates.InstantUpdatesTracker : object {
    private static string UpdatesUrl;
    private static ILogger ourLogger;
    public static void CheckForUpdates(ProductDetails productDetails, IUpdatesHandler updatesHandler, bool useBackgroundThread);
    private static void CheckForUpdatesImpl(ProductDetails productDetails, IUpdatesHandler updatesHandler);
    [LocalizableAttribute("False")]
private static string GetXsltContent(ProductDetails productDetails);
    [ExtensionAttribute]
private static Version NormalizeVersion(Version version);
    internal static string GetLocalInfoXmlContent(ProductDetails productDetails);
    internal static string TransformLocalInfoXml(string localInfoXmlContent, string xsltContent);
    private static XmlReader GetXmlReader(string content);
    internal static void HandleUpdatesInfo(string updatesInfoXmlContent, IUpdatesHandler updatesHandler);
    private static Guid GetSessionId();
    private static ILogger GetLogger();
}
public interface JetBrains.Common.Util.Updates.IUpdatesHandler {
    public abstract virtual void HandleUpdateInfo(string key, string value);
}
public class JetBrains.Common.Util.Updates.MachineIdManager : object {
    private static int IOREG_COMMAND_TIMEOUT_MS;
    private static Regex ourMacMachineIdPattern;
    private static List`1<string> ourLinuxMachineIdPaths;
    private static ILogger ourLogger;
    private static MachineIdManager();
    [CanBeNullAttribute]
public static string GetAnonymizedMachineId(string purpose, string salt);
    private static string GetMachineId();
    private static string GetLinuxMachineId();
    [CanBeNullAttribute]
private static string GetMacOsMachineId();
}
public class JetBrains.Common.Util.Updates.ProductDetails : object {
    public static ProductDetails DotMemoryStandalone;
    public static ProductDetails DotMemoryConsole;
    public static ProductDetails DotMemoryConsoleUnderTeamCity;
    public static ProductDetails DotMemoryVisualStudio;
    public static ProductDetails DotCoverStandalone;
    public static ProductDetails DotCoverConsole;
    public static ProductDetails DotCoverConsoleUnderTeamCity;
    public static ProductDetails DotCoverVisualStudio;
    public static ProductDetails DotTraceAppBrowser;
    public static ProductDetails DotTracePerformanceViewer;
    public static ProductDetails DotTraceTimelineViewer;
    public static ProductDetails DotTraceConsoleProfiler;
    public static ProductDetails DotTraceConsoleReporter;
    public static ProductDetails DotTraceVisualStudio;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Mode>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsEap>k__BackingField;
    public string Name { get; }
    public string Mode { get; }
    public Version Version { get; }
    public bool IsEap { get; }
    private ProductDetails(string name, string mode, Version version, bool isEap);
    private static ProductDetails();
    private static ProductDetails CreateDotCover(string mode);
    private static ProductDetails CreateDotTrace(string mode);
    private static ProductDetails CreateDotMemory(string mode);
    public static ProductDetails CreateDotMemoryUnit(string mode, Version verison);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public string get_Mode();
    [CompilerGeneratedAttribute]
public Version get_Version();
    [CompilerGeneratedAttribute]
public bool get_IsEap();
}
public static class JetBrains.Common.Util.ValidFilenameHelper : object {
    private static char SubstSymbol;
    private static JetHashSet`1<char> ourInvalidFileCharacters;
    private static ValidFilenameHelper();
    public static string BuildValidFileName(string dirtyFileName);
}
public class JetBrains.Common.Util.WordMatcher : object {
    private String[] myWords;
    private static int P;
    private Char[] myBuffer;
    private JetList`1<int> myMatchingIndicies;
    private static Char[] ourTrimChars;
    public WordMatcher(string pattern);
    private static WordMatcher();
    public IReadOnlyList`1<int> MatchingIndicies(Char[] buffer, int length);
    public IReadOnlyList`1<int> MatchingIndicies(string str);
    public bool Matches(Char[] buffer, int length);
    public bool Matches(string str);
    private bool MatchesImpl(Char[] buffer, int length);
    private void EnsureHasEnoughBufferCapacity(int length);
    private Char[] GetLowerCaseBuffer(Char[] buffer, int length);
    private Char[] GetLowerCaseBuffer(string str);
    private static int IndexOf(Char[] buffer, int start, int length, string word);
    private static bool AreSame(Char[] buffer, int bufferStart, string word);
    private static int PrimePow(int factor);
    private static int GetHash(string str);
    private static int GetHash(Char[] buffer, int start, int length);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.WordMatcherEx : object {
    [ExtensionAttribute]
public static FormattedTextVM HighlightSearchText(WordMatcher matcher, string str);
    [ExtensionAttribute]
public static SelectableFormattedTextVM HighlightSearchTextSelectable(WordMatcher matcher, string str);
    private static FormattedText GetFormattedText(WordMatcher matcher, string str);
}
public class JetBrains.DotTrace.Dal.Timeline.NewMetadata.Navigation.ETWNavigation : object {
    public static CallTreeNavigationInfo BuildCallTreeNavigationInfoFromETW(string methodName, string namespaceAndType, string signature);
}
[ExtensionAttribute]
public static class JetBrains.DotTrace.Dal.Timeline.NewMetadata.Parser.CharIEnumerableEx : object {
    [IteratorStateMachineAttribute("JetBrains.DotTrace.Dal.Timeline.NewMetadata.Parser.CharIEnumerableEx/<SelectNested>d__0`1")]
[ExtensionAttribute]
public static IEnumerable`1<T> SelectNested(IEnumerable`1<T> collection, T openBracket, T closingBracket, Func`4<int, T, int, T> indexItemDepthToItem);
    [ExtensionAttribute]
public static string AsString(IEnumerable`1<char> charSequence);
    [ExtensionAttribute]
public static void ForEachNested(IEnumerable`1<T> name, T openBracket, T closingBracket, Action`3<int, T, int> indexItemDepthAction);
    [ExtensionAttribute]
public static int LastNested(IEnumerable`1<T> name, T openBracket, T closingBracket, T itemToFind, int searchOnDepth);
}
public static class JetBrains.DotTrace.Dal.Timeline.NewMetadata.Parser.MethodNameParser : object {
    private static IEnumerable`1<char> ChopOffNestedGeneratedClasses(IEnumerable`1<char> name);
    public static IEnumerable`1<char> ClassNameWithoutParameters(IEnumerable`1<char> namespace);
    public static IEnumerable`1<char> GetClassFQN(IEnumerable`1<char> namespaceWithClass);
    public static IEnumerable`1<char> DropBackSlashes(IEnumerable`1<char> namespace);
    public static IEnumerable`1<char> ChopOffGenericParameters(IEnumerable`1<char> name);
    public static string EnclosingMethodName(string name);
    public static IEnumerable`1<char> EnclosingMethodName(IEnumerable`1<char> name);
    public static NamespaceAndIdentifier ExtractNamespaceAndClassName(IEnumerable`1<char> name);
    private static NamespaceAndIdentifier SplitByDot(string string, int lastDotIndex);
    public static NamespaceAndIdentifier ExtractInterfaceAndMemberName(IEnumerable`1<char> name);
    private static int FindLastCharAngleBrackets(IEnumerable`1<char> name, char character);
    private static IEnumerable`1<char> ExtractEnclosingMethod(IEnumerable`1<char> name);
    public static bool IsLambdaMethodName(IEnumerable`1<char> name);
    public static IEnumerable`1<char> SkipEnclosingMethodNamespace(IEnumerable`1<char> methodName);
    public static string PresentableMethodName(IEnumerable`1<char> methodName);
}
public class JetBrains.DotTrace.Dal.Timeline.NewMetadata.Parser.NamespaceAndIdentifier : ValueType {
    public string Identifier;
    public string Namespace;
    public NamespaceAndIdentifier(string ns, string identifier);
    public static string SafeRemoveLast(string sequence, int count);
    [LocalizableAttribute("False")]
public virtual string ToString();
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
