public static class JetBrains.Application.CompanyInfo : object {
    public static string HistoricalDefaultProductName;
    public static string Name;
    public static string NameWithInc;
    public static string NameWithIncNational;
    public static string PlatformProductRegistryKeyName;
    public static string WebsiteUri;
    public static string TwitterUri;
    private static CompanyInfo();
}
[ExtensionAttribute]
public static class JetBrains.Application.I18n.LocalizedStringExtensions : object {
    public static string NewLine;
    private static LocalizedStringExtensions();
    [ExtensionAttribute]
public static string TODO(string self);
    [ExtensionAttribute]
public static string IMPORTANT_TODO(string self);
    [ExtensionAttribute]
public static IProperty`1<string> TODO(IProperty`1<string> self);
    [ExtensionAttribute]
public static IViewableProperty`1<string> TODO(IViewableProperty`1<string> self);
    [ExtensionAttribute]
public static string NON_LOCALIZABLE(string self);
    [ExtensionAttribute]
public static IProperty`1<string> NON_LOCALIZABLE(IProperty`1<string> self);
    [ExtensionAttribute]
public static IViewableProperty`1<string> NON_LOCALIZABLE(IViewableProperty`1<string> self);
    [ExtensionAttribute]
public static string Format(string format, Object[] arguments);
    [ExtensionAttribute]
public static string ForceCapitalization(string text);
    [ExtensionAttribute]
public static string ForceCapitalization(string text, CapitalizationStyle style);
    [ExtensionAttribute]
public static string ForceDecapitalization(string text);
    public static string StrFormatByteSizeSimple(long recordTotalPhysicalBytes);
    public static string StrFormatPercentSimple(UInt32 recordMemoryLoadPercent);
    public static string StrFormatByteSize(long size);
}
public interface JetBrains.Application.IInterruptionSource {
    public bool IsPolling { get; }
    public abstract virtual bool get_IsPolling();
    public abstract virtual void Subscribe(InterruptionHandler handler);
    public abstract virtual void Unsubscribe(InterruptionHandler handler);
    public abstract virtual bool CheckInterrupt();
}
public class JetBrains.Application.InterruptableActivityCookie : object {
    [ObsoleteAttribute("TODO[au]: ensure, that progress indicator is presented in current interrupters and replace it with regular Check&throw")]
public static void CheckAndThrow(IProgressIndicator progress);
}
public class JetBrains.Application.Interruption : object {
    private static ILogger ourLog;
    public static bool GlobalSuspend;
    [ThreadStaticAttribute]
private static InterruptionHandler ourCurrent;
    [NotNullAttribute]
public static InterruptionHandler Current { get; }
    private static Interruption();
    public static InterruptionHandler get_Current();
    public static OverrideCookie Override(InterruptionSet set);
}
public class JetBrains.Application.InterruptionSet : object {
    private FrugalLocalList`1<IInterruptionSource> mySources;
    internal FrugalLocalList`1<IInterruptionSource> Sources { get; }
    public InterruptionSet(IInterruptionSource source);
    public InterruptionSet(IInterruptionSource s1, IInterruptionSource s2);
    public InterruptionSet(IInterruptionSource s1, IInterruptionSource s2, IInterruptionSource s3);
    public InterruptionSet(IEnumerable`1<IInterruptionSource> providers);
    [MustUseReturnValueAttribute]
public InterruptionSet Union(IInterruptionSource interruptionSource);
    [MustUseReturnValueAttribute]
public InterruptionSet Union(InterruptionSet interruptionSource);
    private void TryAdd(IInterruptionSource interruptionSource);
    [MustUseReturnValueAttribute]
public bool CheckSlow();
    internal FrugalLocalList`1<IInterruptionSource> get_Sources();
}
public abstract class JetBrains.Application.InterruptionSourceBase : InterruptionSourceBaseNoLifetime {
    private int myCounter;
    [CanBeNullAttribute]
private LifetimeDefinition myDef;
    public virtual void Subscribe(InterruptionHandler handler);
    public virtual void Unsubscribe(InterruptionHandler handler);
    private void Ref();
    private void Deref();
    protected abstract virtual void InitializeOnce(Lifetime lifetime);
}
public abstract class JetBrains.Application.InterruptionSourceBaseNoLifetime : object {
    [NotNullAttribute]
protected object myLock;
    protected FrugalLocalList`1<InterruptionHandler> mySubscriptions;
    public bool IsPolling { get; }
    public virtual bool get_IsPolling();
    public virtual void Subscribe(InterruptionHandler handler);
    public virtual void Unsubscribe(InterruptionHandler handler);
    public abstract virtual bool CheckInterrupt();
    public void Fire();
}
public class JetBrains.Application.InterruptionSourceByTimer : InterruptionSourceBase {
    private Func`1<bool> myCheckForInterrupt;
    private int myIntervalMs;
    private static ILogger ourLog;
    public InterruptionSourceByTimer(Func`1<bool> checkForInterrupt, int intervalMs);
    private static InterruptionSourceByTimer();
    protected virtual void InitializeOnce(Lifetime lifetime);
    private void OnTimer(object state);
    public virtual bool CheckInterrupt();
}
public class JetBrains.Application.LifetimeInterruptionSource : InterruptionSourceBase {
    private CancellationToken myToken;
    private bool myInterrupt;
    public LifetimeInterruptionSource(CancellationToken token);
    public static LifetimeInterruptionSource Create(Lifetime lifetime);
    private void Terminate();
    public virtual bool CheckInterrupt();
    protected virtual void InitializeOnce(Lifetime lifetime);
}
public class JetBrains.Application.PollingInterruptionSource : object {
    private Func`1<bool> myCheckForInterrupt;
    public bool IsPolling { get; }
    public PollingInterruptionSource(Func`1<bool> checkForInterrupt);
    public sealed virtual bool get_IsPolling();
    public sealed virtual void Subscribe(InterruptionHandler handler);
    public sealed virtual void Unsubscribe(InterruptionHandler handler);
    public sealed virtual bool CheckInterrupt();
}
public interface JetBrains.Application.Progress.ICancellableProgressIndicator {
    public abstract virtual void Cancel();
}
public interface JetBrains.Application.Progress.IProgressIndicator {
    public string CurrentItemText { get; public set; }
    public bool IsCanceled { get; }
    public string TaskName { get; public set; }
    public abstract virtual string get_CurrentItemText();
    public abstract virtual void set_CurrentItemText(string value);
    public abstract virtual bool get_IsCanceled();
    public abstract virtual string get_TaskName();
    public abstract virtual void set_TaskName(string value);
    public abstract virtual void Advance(double units);
    public abstract virtual void Start(int totalWorkUnits);
    public abstract virtual void Stop();
}
public interface JetBrains.Application.Progress.IProgressIndicatorModel {
    [NotNullAttribute]
public IProperty`1<double> Fraction { get; }
    [NotNullAttribute]
public IProperty`1<bool> IsCanceled { get; }
    [NotNullAttribute]
public IProperty`1<bool> IsRunning { get; }
    [NotNullAttribute]
public IProperty`1<string> Name { get; }
    [NotNullAttribute]
public IProperty`1<string> StepName { get; }
    public abstract virtual IProperty`1<double> get_Fraction();
    public abstract virtual IProperty`1<bool> get_IsCanceled();
    public abstract virtual IProperty`1<bool> get_IsRunning();
    public abstract virtual IProperty`1<string> get_Name();
    public abstract virtual IProperty`1<string> get_StepName();
}
public class JetBrains.Application.Progress.ProgressDiagnosticException : ApplicationException {
    public ProgressDiagnosticException(string message);
    public ProgressDiagnosticException(string message, Exception innerException);
}
public class JetBrains.Application.Progress.ProgressIndicator : object {
    [DebuggerBrowsableAttribute("0")]
private double myAdvanceFactor;
    [DebuggerBrowsableAttribute("0")]
private double myEpsilon;
    [CompilerGeneratedAttribute]
private object <ReadonlyToken>k__BackingField;
    [CompilerGeneratedAttribute]
private IProperty`1<double> <Fraction>k__BackingField;
    [CompilerGeneratedAttribute]
private IProperty`1<bool> <IsCanceled>k__BackingField;
    [CompilerGeneratedAttribute]
private IProperty`1<bool> <IsRunning>k__BackingField;
    [CompilerGeneratedAttribute]
private IProperty`1<string> <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private IProperty`1<string> <StepName>k__BackingField;
    [DebuggerBrowsableAttribute("0")]
public object ReadonlyToken { get; public set; }
    [DebuggerBrowsableAttribute("0")]
private string JetBrains.Application.Progress.IProgressIndicator.CurrentItemText { get; private set; }
    [DebuggerBrowsableAttribute("0")]
private bool JetBrains.Application.Progress.IProgressIndicator.IsCanceled { get; }
    [DebuggerBrowsableAttribute("0")]
private string JetBrains.Application.Progress.IProgressIndicator.TaskName { get; private set; }
    public IProperty`1<double> Fraction { get; }
    public IProperty`1<bool> IsCanceled { get; }
    public IProperty`1<bool> IsRunning { get; }
    public IProperty`1<string> Name { get; }
    public IProperty`1<string> StepName { get; }
    public ProgressIndicator(Lifetime lifetime);
    [CompilerGeneratedAttribute]
public object get_ReadonlyToken();
    [CompilerGeneratedAttribute]
public void set_ReadonlyToken(object value);
    private sealed virtual override void JetBrains.Application.Progress.IProgressIndicator.Advance(double units);
    private sealed virtual override void JetBrains.Application.Progress.IProgressIndicator.Start(int range);
    private sealed virtual override void JetBrains.Application.Progress.IProgressIndicator.Stop();
    private sealed virtual override string JetBrains.Application.Progress.IProgressIndicator.get_CurrentItemText();
    private sealed virtual override void JetBrains.Application.Progress.IProgressIndicator.set_CurrentItemText(string value);
    private sealed virtual override bool JetBrains.Application.Progress.IProgressIndicator.get_IsCanceled();
    private sealed virtual override string JetBrains.Application.Progress.IProgressIndicator.get_TaskName();
    private sealed virtual override void JetBrains.Application.Progress.IProgressIndicator.set_TaskName(string value);
    [CompilerGeneratedAttribute]
public sealed virtual IProperty`1<double> get_Fraction();
    [CompilerGeneratedAttribute]
public sealed virtual IProperty`1<bool> get_IsCanceled();
    [CompilerGeneratedAttribute]
public sealed virtual IProperty`1<bool> get_IsRunning();
    [CompilerGeneratedAttribute]
public sealed virtual IProperty`1<string> get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual IProperty`1<string> get_StepName();
    private sealed virtual override void System.IDisposable.Dispose();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
private void <.ctor>b__2_0(BeforePropertyChangedEventArgs`1<string> args);
}
public abstract class JetBrains.Application.Progress.ProgressIndicatorBase : object {
    private static int MinAllowedTotalWorkUnits;
    [DebuggerBrowsableAttribute("0")]
protected bool myIsStartInvoked;
    [DebuggerBrowsableAttribute("0")]
private bool myCanceled;
    public static double DefaultEpsilon;
    [CompilerGeneratedAttribute]
private double <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TotalWorkUnits>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CurrentItemText>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TaskName>k__BackingField;
    public double Units { get; private set; }
    protected int TotalWorkUnits { get; private set; }
    protected double Fraction { get; }
    public string CurrentItemText { get; public set; }
    public bool IsCanceled { get; }
    public string TaskName { get; public set; }
    private static ProgressIndicatorBase();
    [CompilerGeneratedAttribute]
public double get_Units();
    [CompilerGeneratedAttribute]
private void set_Units(double value);
    [CompilerGeneratedAttribute]
protected int get_TotalWorkUnits();
    [CompilerGeneratedAttribute]
private void set_TotalWorkUnits(int value);
    public virtual void Cancel();
    protected double get_Fraction();
    public virtual void Advance(double units);
    private InvalidOperationException WithUnitsData(InvalidOperationException exception, double units);
    public sealed virtual void Dispose();
    public virtual void Start(int totalWorkUnits);
    public virtual void Stop();
    [CompilerGeneratedAttribute]
public virtual string get_CurrentItemText();
    [CompilerGeneratedAttribute]
public virtual void set_CurrentItemText(string value);
    public virtual bool get_IsCanceled();
    [CompilerGeneratedAttribute]
public virtual string get_TaskName();
    [CompilerGeneratedAttribute]
public virtual void set_TaskName(string value);
}
[ExtensionAttribute]
public static class JetBrains.Application.Progress.ProgressIndicatorExtensions : object {
    private static double DefaultProgressFraction;
    [ExtensionAttribute]
public static void Advance(IProgressIndicator progress);
    [ExtensionAttribute]
public static void Advance(IProgressIndicator progressParent, double fUnitsInParentIndicator, Action`1<IProgressIndicator> funcAdvanceSubprogress);
    [ExtensionAttribute]
public static void CheckForInterrupt(IProgressIndicator progress);
    [ExtensionAttribute]
public static Func`1<bool> ToCheckForInterruptFunc(IProgressIndicator progress);
    [ExtensionAttribute]
public static void SafeAdvance(IProgressIndicator progress, double units);
    [ExtensionAttribute]
[ContractAnnotationAttribute("progressParent:null => null; => notnull")]
[PureAttribute]
public static IProgressIndicator CreateSubProgress(IProgressIndicator progressParent, double fUnitsInParentIndicator);
    [ExtensionAttribute]
[PureAttribute]
public static IProgressIndicator CreateSubProgress(IProgressIndicator progressParent);
    [ExtensionAttribute]
[ContractAnnotationAttribute("progressParent:null => null; => notnull")]
[PureAttribute]
public static IProgressIndicator AdvanceNested(IProgressIndicator progressParent, double fUnitsInParentIndicator);
    [ExtensionAttribute]
[ContractAnnotationAttribute("progressParent:null => null; => notnull")]
[PureAttribute]
public static IProgressIndicator AdvanceNested(IProgressIndicator progressParent);
    [ExtensionAttribute]
public static IProgressIndicator CreateSlowIndicator(IProgressIndicator progressIndicator);
    [ExtensionAttribute]
public static IProgressIndicator CreateSlowIndicator(IProgressIndicator progressIndicator, TimeSpan timeSpan);
    [ExtensionAttribute]
private static void ForEachWithProgressImpl(ICollection`1<T> collection, IProgressIndicator progress, string taskName, bool throwOnCancel, Action`2<IProgressIndicator, T> handler);
    [IteratorStateMachineAttribute("JetBrains.Application.Progress.ProgressIndicatorExtensions/<WithProgressImpl>d__13`1")]
[NotNullAttribute]
private static IEnumerable`1<T> WithProgressImpl(IEnumerable`1<T> collection, int totalWorkUnits, IProgressIndicator progress, string taskName, Func`3<T, string, string> currentItemText, bool throwOnCancel);
    [IteratorStateMachineAttribute("JetBrains.Application.Progress.ProgressIndicatorExtensions/<WithProgressForEveryImpl>d__14`1")]
[NotNullAttribute]
private static IEnumerable`1<KeyValuePair`2<T, IProgressIndicator>> WithProgressForEveryImpl(IEnumerable`1<T> collection, int totalWorkUnits, IProgressIndicator progress, string taskName, Func`3<T, string, string> currentItemText, bool throwOnCancel);
    [ExtensionAttribute]
public static void ForEachWithProgress(ICollection`1<T> collection, IProgressIndicator progress, string taskName, bool throwOnCancel, Action`2<T, IProgressIndicator> handler);
    [ExtensionAttribute]
public static void ForEachWithProgress(ICollection`1<T> collection, IProgressIndicator progress, string taskName, Action`2<T, IProgressIndicator> handler);
    [ExtensionAttribute]
public static void ForEachWithProgress(ICollection`1<T> collection, IProgressIndicator progress, string taskName, bool throwOnCancel, Action`1<T> handler);
    [ExtensionAttribute]
public static void ForEachWithProgress(ICollection`1<T> collection, IProgressIndicator progress, string taskName, Action`1<T> handler);
    [ExtensionAttribute]
[NotNullAttribute]
public static IEnumerable`1<T> WithProgress(ICollection`1<T> collection, IProgressIndicator progress, string taskName, Func`3<T, string, string> currentItemText, bool throwOnCancel);
    [ExtensionAttribute]
[NotNullAttribute]
public static IEnumerable`1<T> WithProgress2(IReadOnlyCollection`1<T> collection, IProgressIndicator progress, string taskName, Func`3<T, string, string> currentItemText, bool throwOnCancel);
    [ExtensionAttribute]
[NotNullAttribute]
public static IEnumerable`1<KeyValuePair`2<T, IProgressIndicator>> WithProgressForEvery(ICollection`1<T> collection, IProgressIndicator progress, string taskName, Func`3<T, string, string> currentItemText, bool throwOnCancel);
    [ExtensionAttribute]
[NotNullAttribute]
public static IEnumerable`1<KeyValuePair`2<T, IProgressIndicator>> WithProgressForEvery2(IReadOnlyCollection`1<T> collection, IProgressIndicator progress, string taskName, Func`3<T, string, string> currentItemText, bool throwOnCancel);
    [ExtensionAttribute]
[NotNullAttribute]
public static IEnumerable`1<T> WithSubProgress(ICollection`1<T> collection, IProgressIndicator progress, double fUnitsInParentIndicator, string taskName, bool throwOnCancel);
    [ExtensionAttribute]
[NotNullAttribute]
public static List`1<TResult> SelectWProgress(ICollection`1<TSource> source, IProgressIndicator progress, string taskName, Func`2<TSource, TResult> selector);
    [ExtensionAttribute]
public static void Start(IProgressIndicator progress, int totalWorkUnits, string sTaskName);
    [ExtensionAttribute]
public static IProgressIndicator StartProgress(IProgressIndicator progress, int totalWorkUnits);
    [ExtensionAttribute]
public static void Cancel(IProgressIndicatorModel progress);
    [ExtensionAttribute]
public static IProgressIndicator StartProgress(IProgressIndicator progress, int totalWorkUnits, string taskName);
    [ExtensionAttribute]
public static void StartStop(IProgressIndicator progress, int totalWorkUnits, string taskName, Action action);
    [ExtensionAttribute]
public static void PumpForSingleThreadedTasks(IProgressIndicatorModel progressIndicator, Lifetime lifetime, Func`1<bool> mainThreadCheck, int millisecondsPumpInterval);
    [ExtensionAttribute]
public static IProgressIndicator Total(IProgressIndicator progress, string taskName, int total);
    [ExtensionAttribute]
public static IDisposable SafeTotal(IProgressIndicator progress, int total);
    [ExtensionAttribute]
public static IDisposable SafeTotal(IProgressIndicator progress, string taskName, int total);
    [ExtensionAttribute]
public static LocalDisposable Step(IProgressIndicator progress, int stepSize);
    [ExtensionAttribute]
public static LocalDisposable Step(IProgressIndicator progress, int stepSize, string stepName);
    [ExtensionAttribute]
public static LocalDisposable SafeStep(IProgressIndicator progress, int stepSize);
}
internal class JetBrains.Application.Progress.SlowProgressIndicator : object {
    [NotNullAttribute]
private IProgressIndicator myUnderlying;
    private TimeSpan myDuration;
    public string CurrentItemText { get; public set; }
    public bool IsCanceled { get; }
    public string TaskName { get; public set; }
    public SlowProgressIndicator(IProgressIndicator underlying);
    public SlowProgressIndicator(IProgressIndicator underlying, TimeSpan duration);
    public sealed virtual string get_CurrentItemText();
    public sealed virtual void set_CurrentItemText(string value);
    public sealed virtual bool get_IsCanceled();
    public sealed virtual string get_TaskName();
    public sealed virtual void set_TaskName(string value);
    public sealed virtual void Advance(double units);
    public sealed virtual void Start(int totalWorkUnits);
    public sealed virtual void Stop();
    public sealed virtual void Dispose();
}
public class JetBrains.Application.Progress.SubProgressIndicator : ProgressIndicatorBase {
    [CompilerGeneratedAttribute]
private IProgressIndicator <Parent>k__BackingField;
    [CompilerGeneratedAttribute]
private double <UnitsInParent>k__BackingField;
    [DebuggerBrowsableAttribute("0")]
private bool myAdvanceWhenNotStarted;
    [NotNullAttribute]
public IProgressIndicator Parent { get; }
    public double UnitsInParent { get; }
    unknown string CurrentItemText {public set; }
    public bool IsCanceled { get; }
    public string TaskName { get; public set; }
    public SubProgressIndicator(IProgressIndicator progressParent, double fUnitsInParentIndicator, bool advanceWhenNotStarted);
    [CompilerGeneratedAttribute]
public IProgressIndicator get_Parent();
    [CompilerGeneratedAttribute]
public double get_UnitsInParent();
    public virtual void Advance(double units);
    public virtual void set_CurrentItemText(string value);
    public virtual bool get_IsCanceled();
    public virtual string get_TaskName();
    public virtual void set_TaskName(string value);
    public virtual void Stop();
    public virtual string ToString();
}
public class JetBrains.Application.ProgressIndicatorInterruptionSource : object {
    public static IInterruptionSource Create(IProgressIndicator indicator);
}
public class JetBrains.Application.PropertyInterruptionSource`1 : InterruptionSourceBase {
    private IProperty`1<T> myProperty;
    private Func`2<T, bool> myCheck;
    public PropertyInterruptionSource`1(IProperty`1<T> property, Func`2<T, bool> check);
    public virtual bool CheckInterrupt();
    protected virtual void InitializeOnce(Lifetime lifetime);
}
public class JetBrains.Application.Threading.Tasks.FreeThreadedGroupingEvent : object {
    private ILogger myLogger;
    private Lifetime myLifetime;
    private ITaskHost myTaskHost;
    private bool myBlockLifetimeOnOutgoingSignal;
    private bool myProlongate;
    private Func`1<Task> myAsyncCallback;
    private object myLock;
    private GroupingEventStatus modreq(System.Runtime.CompilerServices.IsVolatile) myStatus;
    private TimeSpan myWaitTime;
    private DateTime myScheduledTime;
    private SequentialLifetimes myQueueLifetimes;
    [NotNullAttribute]
public ISimpleSignal Outgoing;
    private long myRestMillisUtilError;
    private LocalLazy`2<ISimpleSignal, FreeThreadedGroupingEvent> myLazyIncoming;
    private bool AsyncBehaviorProhibited { get; }
    [NotNullAttribute]
public ISimpleSignal Incoming { get; }
    public TimeSpan WaitTime { get; public set; }
    public FreeThreadedGroupingEvent(Lifetime lifetime, ITaskHost taskHost, GroupingEventProlongation prolongation, TimeSpan waitTime, Func`1<Task> asyncCallback, bool blockLifetimeOnOutgoingSignal);
    private bool get_AsyncBehaviorProhibited();
    private void ScheduledFireAction();
    private void FireInternal();
    private void FireOutgoingInternal();
    private void SetWaitTime(TimeSpan newWaitTime);
    public ISimpleSignal get_Incoming();
    public TimeSpan get_WaitTime();
    public void set_WaitTime(TimeSpan value);
    public GroupingEventStatus GetStatus();
    public void FireIncoming();
    public void FireOutgoing(bool waitIfAlreadyFiring, bool fireIfNoIncoming, long timeoutMs);
    public void WaitAndPumpUntilNoIncoming(long timeoutMs);
    public void ClearIncoming();
    [CompilerGeneratedAttribute]
internal static ISimpleSignal <.ctor>g__DelayCreateIncoming|11_0(FreeThreadedGroupingEvent owner);
    [CompilerGeneratedAttribute]
private Task <FireInternal>b__15_0();
    [CompilerGeneratedAttribute]
private void <FireInternal>b__15_1(Task t);
    [CompilerGeneratedAttribute]
private void <FireOutgoingInternal>b__16_0();
}
public enum JetBrains.Application.Threading.Tasks.GroupingEventProlongation : Enum {
    public int value__;
    public static GroupingEventProlongation DontProlongate;
    public static GroupingEventProlongation Prolongate;
}
public enum JetBrains.Application.Threading.Tasks.GroupingEventStatus : Enum {
    public int value__;
    public static GroupingEventStatus NoIncoming;
    public static GroupingEventStatus Scheduled;
    public static GroupingEventStatus Firing;
}
public interface JetBrains.Application.Threading.Tasks.ITaskBarrier {
    public abstract virtual void EnqueueJob(Action action);
    public abstract virtual void EnqueueJob(string name, Action action);
    public abstract virtual void WaitAll();
}
public interface JetBrains.Application.Threading.Tasks.ITaskHost {
    [PublicAPIAttribute]
[NotNullAttribute]
public JetScheduler Scheduler { get; }
    [PublicAPIAttribute]
[NotNullAttribute]
public TaskFactory Factory { get; }
    [PublicAPIAttribute]
[NotNullAttribute]
public JetDispatcherTaskScheduler UnguardedMainThreadScheduler { get; }
    [PublicAPIAttribute]
[NotNullAttribute]
public ReentrancyGuardTaskScheduler GuardedMainThreadScheduler { get; }
    public TaskScheduler WriteLockMainThreadScheduler { get; }
    [PublicAPIAttribute]
[CanBeNullAttribute]
public TaskScheduler UnguardedMainThreadSchedulerIfPresent { get; }
    [PublicAPIAttribute]
[CanBeNullAttribute]
public ReentrancyGuardTaskScheduler GuardedMainThreadSchedulerIfPresent { get; }
    [PublicAPIAttribute]
[NotNullAttribute]
public TaskScheduler SystemThreadPool { get; }
    public abstract virtual JetScheduler get_Scheduler();
    public abstract virtual TaskFactory get_Factory();
    public abstract virtual JetDispatcherTaskScheduler get_UnguardedMainThreadScheduler();
    public abstract virtual ReentrancyGuardTaskScheduler get_GuardedMainThreadScheduler();
    public abstract virtual TaskScheduler get_WriteLockMainThreadScheduler();
    public abstract virtual TaskScheduler get_UnguardedMainThreadSchedulerIfPresent();
    public abstract virtual ReentrancyGuardTaskScheduler get_GuardedMainThreadSchedulerIfPresent();
    public abstract virtual TaskScheduler get_SystemThreadPool();
    [PublicAPIAttribute]
[NotNullAttribute]
public abstract virtual Task Start(Task task);
    [PublicAPIAttribute]
[NotNullAttribute]
[ThreadSafeAttribute]
public abstract virtual Task`1<T> Start(Task`1<T> task);
    [PublicAPIAttribute]
[NotNullAttribute]
[ThreadSafeAttribute]
public abstract virtual Task Queue(Lifetime lifetime, Action action, TaskPriority priority);
    [PublicAPIAttribute]
[NotNullAttribute]
[ThreadSafeAttribute]
public abstract virtual Task QueueAt(Lifetime lifetime, Action action, DateTimeOffset date);
    [PublicAPIAttribute]
[NotNullAttribute]
[ThreadSafeAttribute]
[ObsoleteAttribute("Use an overload with DateTimeOffset.")]
public abstract virtual Task QueueAt(Lifetime lifetime, Action action, DateTime date);
    [PublicAPIAttribute]
[ThreadSafeAttribute]
public abstract virtual void QueueRecurring(Lifetime lifetime, Action action, DateTimeOffset firstTime, TimeSpan interval);
    [PublicAPIAttribute]
[ThreadSafeAttribute]
[ObsoleteAttribute("Use an overload with DateTimeOffset.")]
public abstract virtual void QueueRecurring(Lifetime lifetime, Action action, DateTime firstTime, TimeSpan interval);
    [PublicAPIAttribute]
[NotNullAttribute]
[ThreadSafeAttribute]
public abstract virtual Task Create(Lifetime lifetime, Action action, InterruptionSet checkForInterrupt, TaskCreationOptions options, TaskJetProperties properties);
    [PublicAPIAttribute]
[NotNullAttribute]
[ThreadSafeAttribute]
public abstract virtual Task`1<T> Create(Lifetime lifetime, Func`1<T> action, InterruptionSet checkForInterrupt, TaskCreationOptions options, TaskJetProperties properties);
    [PublicAPIAttribute]
[NotNullAttribute]
[ThreadSafeAttribute]
public abstract virtual TaskBarrier CreateBarrier(Lifetime lifetime, InterruptionSet checkForInterrupt, bool sync, bool takeReadLock, TaskCreationOptions options);
}
[ExtensionAttribute]
public static class JetBrains.Application.Threading.Tasks.ITaskHostEx2 : object {
    [ExtensionAttribute]
[NotNullAttribute]
[ObsoleteAttribute("Use StartNew, as it is named after the MSFT APIs.")]
public static Task Run(ITaskHost thіs, Lifetime lifetime, Scheduling scheduling, Action λ);
    [ExtensionAttribute]
[NotNullAttribute]
[ObsoleteAttribute("Use FromResult or CompletedTask.")]
public static Task RunEmpty(ITaskHost thіs);
    [ExtensionAttribute]
[NotNullAttribute]
[ObsoleteAttribute("Use StartNew, as it is named after the MSFT APIs.")]
public static Task`1<TResult> Run(ITaskHost thіs, Lifetime lifetime, Scheduling scheduling, Func`1<TResult> λ);
    [ExtensionAttribute]
[NotNullAttribute]
public static Task StartNew(ITaskHost thіs, Lifetime lifetime, Scheduling scheduling, Action λ);
    [ExtensionAttribute]
[NotNullAttribute]
public static Task`1<TResult> StartNew(ITaskHost thіs, Lifetime lifetime, Scheduling scheduling, Func`1<TResult> λ);
    [ExtensionAttribute]
[NotNullAttribute]
public static Task`1<TResult> StartNew(ITaskHost thіs, Lifetime lifetime, Scheduling scheduling, Func`1<Task`1<TResult>> λ);
    [ExtensionAttribute]
[NotNullAttribute]
public static Task StartNew(ITaskHost thіs, Lifetime lifetime, Scheduling scheduling, Func`1<Task> λ);
    [ExtensionAttribute]
[NotNullAttribute]
public static Task StartNew(ITaskHost thіs, Lifetime lifetime, Scheduling scheduling, TaskPriority priority, Action λ);
    [ExtensionAttribute]
[NotNullAttribute]
public static Task`1<TResult> StartNew(ITaskHost thіs, Lifetime lifetime, Scheduling scheduling, TaskPriority priority, Func`1<TResult> λ);
    [ExtensionAttribute]
[NotNullAttribute]
public static Task`1<TResult> StartNew(ITaskHost thіs, Lifetime lifetime, Scheduling scheduling, TaskPriority priority, Func`1<Task`1<TResult>> λ);
    [ExtensionAttribute]
[NotNullAttribute]
public static Task StartNew(ITaskHost thіs, Lifetime lifetime, Scheduling scheduling, TaskPriority priority, Func`1<Task> λ);
    [NotNullAttribute]
public static TaskScheduler GetScheduler(Scheduling scheduling, ITaskHost tasks);
    [ExtensionAttribute]
[NotNullAttribute]
public static TTask AttachedToParent(TTask thіs);
    [ExtensionAttribute]
[NotNullAttribute]
public static TTask Started(TTask thіs, TaskScheduler scheduler);
    [ExtensionAttribute]
[NotNullAttribute]
public static TTask Started(TTask thіs, TaskScheduler scheduler);
    [ExtensionAttribute]
[NotNullAttribute]
public static JetDispatcherTaskScheduler GetTaskScheduler(JetDispatcher thіs);
    [ExtensionAttribute]
[ObsoleteAttribute("Use Delay.")]
[NotNullAttribute]
public static Task ContinueWithDelay(ITaskHost thіs, Lifetime lifetime, TimeSpan span);
    [ExtensionAttribute]
[NotNullAttribute]
public static Task Delay(ITaskHost thіs, Lifetime lifetime, TimeSpan span);
    [ExtensionAttribute]
public static Task ContinueWithTask(Task thіs, Lifetime lifetime, Task taskAfter);
    [ExtensionAttribute]
[NotNullAttribute]
[ObsoleteAttribute("Use StartNew, as it is named after the MSFT APIs.")]
public static Task Run(ITaskHost thіs, Lifetime lifetime, Action λ, InterruptionSet checkForInterrupt, TaskCreationOptions options, TaskJetProperties properties, TaskScheduler scheduler);
    [ExtensionAttribute]
[NotNullAttribute]
[ObsoleteAttribute("Use StartNew, as it is named after the MSFT APIs.")]
public static Task`1<TResult> Run(ITaskHost thіs, Lifetime lifetime, Func`1<TResult> λ, InterruptionSet checkForInterrupt, TaskCreationOptions options, TaskJetProperties properties, TaskScheduler scheduler);
    [AsyncStateMachineAttribute("JetBrains.Application.Threading.Tasks.ITaskHostEx2/<While>d__21")]
[ExtensionAttribute]
public static Task`1<bool> While(ITaskHost thіs, Lifetime lifetime, Func`1<bool> condition, Nullable`1<TimeSpan> timeout, OnWaitTimeout ontimeout);
    [AsyncStateMachineAttribute("JetBrains.Application.Threading.Tasks.ITaskHostEx2/<While>d__22")]
[ExtensionAttribute]
public static Task`1<bool> While(ITaskHost thіs, Lifetime lifetime, IProperty`1<bool> condition, Nullable`1<TimeSpan> timeout, OnWaitTimeout ontimeout);
}
public class JetBrains.Application.Threading.Tasks.JetDispatcherTaskScheduler : TaskScheduler {
    public JetDispatcher Dispatcher;
    public bool IsActive { get; }
    public bool OutOfOrderExecution { get; }
    public int MaximumConcurrencyLevel { get; }
    public JetDispatcherTaskScheduler(JetDispatcher dispatcher);
    public sealed virtual bool get_IsActive();
    public sealed virtual bool get_OutOfOrderExecution();
    public virtual int get_MaximumConcurrencyLevel();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    protected virtual IEnumerable`1<Task> GetScheduledTasks();
    protected virtual void QueueTask(Task task);
    protected virtual bool TryExecuteTaskInline(Task task, bool taskWasPreviouslyQueued);
    public sealed virtual void Queue(Action action);
}
public class JetBrains.Application.Threading.Tasks.ReentrancyGuardTaskScheduler : TaskScheduler {
    private static string AfterAwaitId;
    private static string QueueTaskId;
    [CanBeNullAttribute]
private Object modreq(System.Runtime.CompilerServices.IsVolatile) myCurrentObject;
    public IReaderWriterLock RwLocks;
    private bool myAcquireWriteLock;
    private SendOrPostCallback mySendOrPostCallback;
    public ReentrancyGuard ReentrancyGuard;
    public int MaximumConcurrencyLevel { get; }
    public ReentrancyGuardTaskScheduler(ReentrancyGuard guard, IReaderWriterLock rwLocks, bool acquireWriteLock);
    public string TryGetCurrentTaskName(string id);
    public virtual int get_MaximumConcurrencyLevel();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    protected virtual IEnumerable`1<Task> GetScheduledTasks();
    protected virtual void QueueTask(Task task);
    private static string ExtractNameFromTask(Task task, bool advancedDiagnostic, bool captureStackTraces);
    private static string ExtractNameFromAction(object action);
    internal void ExecuteInternal(string name, SendOrPostCallback sendOrPostCallback, object state, object currentObject);
    private void ExecuteWithLock(SendOrPostCallback sendOrPostCallback, object state, object currentObject);
    protected virtual bool TryExecuteTaskInline(Task task, bool taskWasPreviouslyQueued);
    private SyncContextCookie CreateSyncContextCookie(object name);
    public Task ExecuteWithSyncContext(string name, Func`1<Task> func);
    public Task`1<T> ExecuteWithSyncContext(string name, Func`1<Task`1<T>> func);
    [CompilerGeneratedAttribute]
private void <.ctor>b__7_0(object state);
}
public class JetBrains.Application.Threading.Tasks.Scheduler.JetScheduler : TaskScheduler {
    internal Lifetime Lifetime;
    internal static int TaskLimit;
    [ThreadStaticAttribute]
internal static JetScheduler modreq(System.Runtime.CompilerServices.IsVolatile) Scheduler;
    [ThreadStaticAttribute]
internal static JetSchedulerThread modreq(System.Runtime.CompilerServices.IsVolatile) Thread;
    private ILogger myLogger;
    internal AutoResetEvent ManagerEvent;
    private ThreadManagementUnit myShortRunningTasksMU;
    private ThreadManagementUnit myLongRunningTasksMU;
    private long myTaskExecutionIdGenerator;
    internal Thread myManagerThread;
    internal object SyncObject;
    internal static int TerminationTimeMarker;
    internal static int InfiniteWaitTimeConst;
    internal static int MaxWaitTimeConst;
    private static int ShortRunningTaskThreadsInitialCount;
    private bool myStarted;
    [CanBeNullAttribute]
private JetDispatcher myMainDispatcher;
    [CanBeNullAttribute]
private IReaderWriterLock myRwlock;
    public static Task CurrentTask { get; }
    public bool IsActive { get; }
    public bool OutOfOrderExecution { get; }
    public bool ManagesCurrentThread { get; }
    public JetScheduler(Lifetime lifetime, JetDispatcher dispatcherMain, IReaderWriterLock rwlock);
    public static Task get_CurrentTask();
    public sealed virtual bool get_IsActive();
    public sealed virtual bool get_OutOfOrderExecution();
    private void StartThreadPool();
    public bool get_ManagesCurrentThread();
    private ThreadManagementUnit ManagementUnit(Task task);
    internal static int BestMatchTime(int time1, int time2);
    [HandleProcessCorruptedStateExceptionsAttribute]
private void ManagerThreadProc();
    private void AssignExecutionProperties(Task task);
    protected virtual void QueueTask(Task task);
    internal void ExecuteTask(Task task);
    protected virtual bool TryExecuteTaskInline(Task task, bool taskWasPreviouslyQueued);
    protected virtual IEnumerable`1<Task> GetScheduledTasks();
    public void QueueTask(Task task, DateTime scheduledTime);
    private void LazyStart();
    public void ReportThreadIsBlocked(Lifetime blockingLifetime);
    public sealed virtual void Queue(Action action);
    [CompilerGeneratedAttribute]
private void <.ctor>g__OnUnobservedTaskException|17_0(object sender, UnobservedTaskExceptionEventArgs args);
    [CompilerGeneratedAttribute]
private void <.ctor>b__17_1();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class JetBrains.Application.Threading.Tasks.Scheduler.JetSchedulerThread : object {
    private static ILogger ourLogger;
    private ThreadManagementUnit myUnit;
    private object myLock;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) myTerminating;
    internal Func`1<bool> TerminationCondition;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Task <Task>k__BackingField;
    [CompilerGeneratedAttribute]
private Thread <WorkThread>k__BackingField;
    [NullableAttribute("2")]
public Task Task { get; private set; }
    internal bool IsBusy { get; }
    private Thread WorkThread { get; }
    public string Name { get; }
    internal JetSchedulerThread(ThreadManagementUnit unit, Func`1<bool> terminationCondition, string name, ThreadPriority threadPriority);
    private static JetSchedulerThread();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Task get_Task();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_Task(Task value);
    internal bool get_IsBusy();
    [CompilerGeneratedAttribute]
private Thread get_WorkThread();
    public string get_Name();
    private void StartProc();
    [PureAttribute]
internal bool IsWorkThreadCurrent();
    internal void SetTask(Task task);
    internal void Terminate();
    private void ThreadPoolProc();
    private void ResetTask();
    private void EnqueueNextTask();
}
internal class JetBrains.Application.Threading.Tasks.Scheduler.ThreadManagementUnit : object {
    private static int ReservedThreadCreationIntervalMs;
    private static int CreateTempThreadAfterBlockedForMs;
    private static int TempThreadLifespanMs;
    internal List`1<JetSchedulerThread> Executors;
    internal int FreeExecutors;
    internal int ExecutorsCount;
    private IPriorityQueue`1<Task> myReadyToExecuteTasks;
    private IPriorityQueue`1<Task> myScheduledTasks;
    internal JetScheduler Scheduler;
    private ThreadPriority myPriority;
    internal WaitCountSyncContext SyncContext;
    private int myThreadNumberInc;
    private int myLastExecutorAssignedTimestamp;
    private int myReservedThreadSpawnedTimestamp;
    private ILogger myLogger;
    private UInt32 myMaxPermanentExecutorsCount;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; }
    public ThreadManagementUnit(string name, JetScheduler scheduler, ThreadPriority priority);
    public void Signal();
    [CompilerGeneratedAttribute]
public string get_Name();
    public int Dispatch();
    internal void StartReservedThread();
    private void StartTempThread(int startTimestamp);
    private void LogBusyExecutors(LoggingLevel loggingLevel);
    internal void AddTask(Task task);
    private void StartExecutor(Func`1<bool> terminationCondition, string comment);
    public bool TryReportThreadIsBlocked(Lifetime blockingLifetime);
}
internal class JetBrains.Application.Threading.Tasks.Scheduler.WaitCountSyncContext : SynchronizationContext {
    [ThreadStaticAttribute]
private static int ourCurrentThreadBlockedCounter;
    private ThreadManagementUnit myThreadMu;
    private int myLastTakenTimestamp;
    private int myWaitingThreadsCounter;
    internal bool IsBlocked { get; }
    internal int LastBlockedTimestamp { get; }
    public WaitCountSyncContext(ThreadManagementUnit threadMu);
    internal bool get_IsBlocked();
    internal int get_LastBlockedTimestamp();
    internal void UpdateLastBlockedTimestamp(int timestamp);
    public virtual int Wait(IntPtr[] waitHandles, bool waitAll, int millisecondsTimeout);
    internal void ReportThreadIsBlocked(Lifetime lifetime);
    internal void OnResourceTaken();
    internal void OnResourceDisposed();
}
[ExtensionAttribute]
public static class JetBrains.Application.Threading.Tasks.SchedulerAwaiterEx : object {
    [ExtensionAttribute]
[MustUseReturnValueAttribute]
public static SchedulerAwaiter Yield(ITaskHost tasker, Lifetime lifetime);
    [ExtensionAttribute]
[MustUseReturnValueAttribute]
public static SchedulerAwaiter YieldAsLongRunning(ITaskHost tasker, Lifetime lifetime);
    [ExtensionAttribute]
[MustUseReturnValueAttribute]
public static SchedulerAwaiter YieldIfNeeded(ITaskHost tasker, Lifetime lifetime);
    [ExtensionAttribute]
[MustUseReturnValueAttribute]
public static SchedulerAwaiter YieldTo(ITaskHost tasker, Lifetime lifetime, Scheduling scheduling, Nullable`1<TaskPriority> priority);
    [ExtensionAttribute]
[MustUseReturnValueAttribute]
public static SchedulerAwaiter YieldToIfNeeded(ITaskHost tasker, Lifetime lifetime, Scheduling scheduling, Nullable`1<TaskPriority> priority);
}
public enum JetBrains.Application.Threading.Tasks.Scheduling : Enum {
    public int value__;
    public static Scheduling FreeThreaded;
    public static Scheduling MainDispatcher;
    public static Scheduling MainGuard;
}
public class JetBrains.Application.Threading.Tasks.TaskBarrier : SafeDisposable {
    private ITaskHost myTasks;
    private Lifetime myLifetime;
    private InterruptionSet myCheckForInterrupt;
    private bool mySync;
    private bool myTakeReadLock;
    private TaskCreationOptions myOptions;
    private List`1<Task> myTaskList;
    private bool myIsWaitingWithMessagePump;
    private TaskPriority myPriority;
    private bool myFailedOrInterrupted;
    private CancellationTokenSource myCancellationTokenSource;
    [CanBeNullAttribute]
private JetDispatcher myMainDispatcher;
    public Lifetime Lifetime { get; }
    public CancellationToken Cancellation { get; }
    private int TaskCount { get; }
    internal TaskBarrier(ITaskHost tasks, Lifetime lifetime, JetDispatcher dispatcherMain, InterruptionSet checkForInterrupt, bool sync, bool takeReadLock, TaskCreationOptions options);
    private TaskPriority CalcPriority();
    public Lifetime get_Lifetime();
    public CancellationToken get_Cancellation();
    public void EnqueueTask(Task task);
    private bool CheckTaskCanceledOrFaulted(Task task);
    public sealed virtual void EnqueueJob(Action action);
    public sealed virtual void EnqueueJob(string name, Action action);
    private int get_TaskCount();
    public sealed virtual void WaitAll();
    protected virtual void DisposeUnmanagedResources();
}
[ExtensionAttribute]
public static class JetBrains.Application.Threading.Tasks.TaskBarrierExtensions : object {
    [ExtensionAttribute]
public static void EnqueueDependentJobs(ITaskBarrier taskBarrier, IEnumerable`1<Action> actionsEnumerable, OneToSetMap`2<Action, Action> actionToExecuteBefore);
}
internal class JetBrains.Application.Threading.Tasks.TaskByExecutionIdComparer : object {
    public sealed virtual int Compare(Task x, Task y);
}
public class JetBrains.Application.Threading.Tasks.TaskByPriorityComparer : object {
    public sealed virtual int Compare(Task x, Task y);
}
internal class JetBrains.Application.Threading.Tasks.TaskByScheduleTimeComparer : object {
    public sealed virtual int Compare(Task x, Task y);
}
[ExtensionAttribute]
public static class JetBrains.Application.Threading.Tasks.TaskEx : object {
    public static DateTime FakeDateTime;
    private static TaskEx();
    [ExtensionAttribute]
[PublicAPIAttribute]
[NotNullAttribute]
public static Task Start(Task task, ITaskHost host, bool sync);
    [ExtensionAttribute]
[PublicAPIAttribute]
[NotNullAttribute]
public static Task`1<T> Start(Task`1<T> task, ITaskHost host, bool sync);
    [PublicAPIAttribute]
public static void WaitOnMonitor(ITaskHost tasks, object sentry, int timeToWaitMillis);
    [ExtensionAttribute]
public static void ReThrowIfNeeded(Task task);
    [ExtensionAttribute]
internal static bool CantBeJetTask(Task task);
    [ExtensionAttribute]
public static bool IsJetTask(Task task);
    [ExtensionAttribute]
internal static void SetExecutionId(Task task, long executionId);
    [ExtensionAttribute]
internal static long GetExecutionId(Task task);
    [ExtensionAttribute]
public static TaskPriority GetPriority(Task task);
    [ExtensionAttribute]
public static string GetName(Task task);
    [ExtensionAttribute]
internal static void SetScheduledTime(Task task, DateTime date);
    [ExtensionAttribute]
public static DateTime GetScheduledTime(Task task);
    [ExtensionAttribute]
public static UserDataHolderNoLocks GetUserData(Task task);
}
public class JetBrains.Application.Threading.Tasks.TaskHost : object {
    private JetScheduler myScheduler;
    [CanBeNullAttribute]
private IReaderWriterLock myRwlocks;
    private TaskFactory myFactory;
    private static ILogger ourLogger;
    [CanBeNullAttribute]
private JetDispatcherTaskScheduler myUnguardedMainThreadScheduler;
    [CanBeNullAttribute]
private ReentrancyGuardTaskScheduler myGuardedMainThreadScheduler;
    private ReentrancyGuardTaskScheduler myWriteLockMainThreadScheduler;
    [CanBeNullAttribute]
private ReentrancyGuard myMainGuard;
    [PublicAPIAttribute]
public TaskScheduler SystemThreadPool { get; }
    public JetScheduler Scheduler { get; }
    public TaskFactory Factory { get; }
    public JetDispatcherTaskScheduler UnguardedMainThreadScheduler { get; }
    public ReentrancyGuardTaskScheduler GuardedMainThreadScheduler { get; }
    public TaskScheduler WriteLockMainThreadScheduler { get; }
    public TaskScheduler UnguardedMainThreadSchedulerIfPresent { get; }
    public ReentrancyGuardTaskScheduler GuardedMainThreadSchedulerIfPresent { get; }
    [CanBeNullAttribute]
public static TaskJetProperties CurrentTaskProperties { get; }
    public TaskHost(Lifetime lifetime, ReentrancyGuard guardMain);
    public TaskHost(Lifetime lifetime, JetScheduler scheduler, ReentrancyGuard guardMain, IReaderWriterLock rwlocks);
    private static TaskHost();
    public sealed virtual TaskScheduler get_SystemThreadPool();
    public sealed virtual JetScheduler get_Scheduler();
    public sealed virtual TaskFactory get_Factory();
    public sealed virtual JetDispatcherTaskScheduler get_UnguardedMainThreadScheduler();
    public sealed virtual ReentrancyGuardTaskScheduler get_GuardedMainThreadScheduler();
    public sealed virtual TaskScheduler get_WriteLockMainThreadScheduler();
    public sealed virtual TaskScheduler get_UnguardedMainThreadSchedulerIfPresent();
    public sealed virtual ReentrancyGuardTaskScheduler get_GuardedMainThreadSchedulerIfPresent();
    public sealed virtual Task Start(Task task);
    public sealed virtual Task`1<T> Start(Task`1<T> task);
    private Task CreateTaskByAction(Lifetime lifetime, Action action, TaskPriority priority);
    public sealed virtual Task Queue(Lifetime lifetime, Action action, TaskPriority priority);
    public sealed virtual Task QueueAt(Lifetime lifetime, Action action, DateTime date);
    public sealed virtual Task QueueAt(Lifetime lifetime, Action action, DateTimeOffset date);
    public sealed virtual void QueueRecurring(Lifetime lifetime, Action action, DateTime firstTime, TimeSpan interval);
    public sealed virtual void QueueRecurring(Lifetime lifetime, Action action, DateTimeOffset firstTime, TimeSpan interval);
    [HandleProcessCorruptedStateExceptionsAttribute]
private static void AccessViolationCatcher(Action action);
    [HandleProcessCorruptedStateExceptionsAttribute]
private static T AccessViolationCatcher(Func`1<T> action);
    public sealed virtual Task Create(Lifetime lifetime, Action action, InterruptionSet checkForInterrupt, TaskCreationOptions options, TaskJetProperties properties);
    public sealed virtual Task`1<T> Create(Lifetime lifetime, Func`1<T> action, InterruptionSet checkForInterrupt, TaskCreationOptions options, TaskJetProperties properties);
    private Task`1<T> Create(Lifetime lifetime, Func`1<T> func, Action act, InterruptionSet checkForInterrupt, TaskCreationOptions options, TaskJetProperties properties);
    public sealed virtual TaskBarrier CreateBarrier(Lifetime lifetime, InterruptionSet checkForInterrupt, bool sync, bool takeReadLock, TaskCreationOptions options);
    public static TaskJetProperties get_CurrentTaskProperties();
    [CanBeNullAttribute]
public static T GetData(Key`1<T> k);
    public static void PutData(Key`1<T> k, T v);
}
[ExtensionAttribute]
public static class JetBrains.Application.Threading.Tasks.TaskHostEx : object {
    [ExtensionAttribute]
[ObsoleteAttribute("Use StartNew, as it is named after the MSFT APIs.")]
public static Task Run(ITaskHost tasks, Lifetime lifetime, Action action);
    [ExtensionAttribute]
[ObsoleteAttribute("Use StartNew, as it is named after the MSFT APIs.")]
public static Task`1<T> Run(ITaskHost tasks, Lifetime lifetime, Func`1<T> action);
    [ExtensionAttribute]
[ObsoleteAttribute("Use StartNew, as it is named after the MSFT APIs.")]
public static Task RunSafe(ITaskHost tasks, Lifetime lifetime, Action action, TaskPriority priority);
    [ExtensionAttribute]
[PublicAPIAttribute]
[NotNullAttribute]
[ThreadSafeAttribute]
public static Task QueueAt(ITaskHost tasks, Lifetime lifetime, Action action, TimeSpan span);
    [ExtensionAttribute]
[PublicAPIAttribute]
[ThreadSafeAttribute]
public static void QueueRecuring(ITaskHost tasks, Lifetime lifetime, Action action, TimeSpan span);
    [ExtensionAttribute]
[PublicAPIAttribute]
[ThreadSafeAttribute]
public static void PreprocessSingleThreadedAndParallelize(ITaskHost host, Lifetime lifetime, bool sync, IList`1<T> itemsToProcess, Func`2<T, ValueTuple`2<TPreprocessResult, int>> preprocessSingleThreaded, Action`2<T, TPreprocessResult> processMultithreaded, int maxConcurrency, int maxAggregatedPoints);
}
public class JetBrains.Application.Threading.Tasks.TaskJetProperties : object {
    private string myName;
    private static ConcurrentDictionary`2<string, string> ourNamesIntern;
    private static ILogger ourLogger;
    [CompilerGeneratedAttribute]
private TaskPriority <Priority>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TakeReadLock>k__BackingField;
    [CompilerGeneratedAttribute]
private long <ExecutionId>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <ScheduledTime>k__BackingField;
    [CompilerGeneratedAttribute]
private CancellationToken <CancellationToken>k__BackingField;
    [CompilerGeneratedAttribute]
private UserDataHolderNoLocks <UserData>k__BackingField;
    public TaskPriority Priority { get; public set; }
    public bool TakeReadLock { get; public set; }
    internal long ExecutionId { get; internal set; }
    internal string Name { get; internal set; }
    internal DateTime ScheduledTime { get; internal set; }
    public CancellationToken CancellationToken { get; public set; }
    public UserDataHolderNoLocks UserData { get; public set; }
    private static TaskJetProperties();
    [CompilerGeneratedAttribute]
public TaskPriority get_Priority();
    [CompilerGeneratedAttribute]
public void set_Priority(TaskPriority value);
    [CompilerGeneratedAttribute]
public bool get_TakeReadLock();
    [CompilerGeneratedAttribute]
public void set_TakeReadLock(bool value);
    [CompilerGeneratedAttribute]
internal long get_ExecutionId();
    [CompilerGeneratedAttribute]
internal void set_ExecutionId(long value);
    internal string get_Name();
    internal void set_Name(string value);
    [CompilerGeneratedAttribute]
internal DateTime get_ScheduledTime();
    [CompilerGeneratedAttribute]
internal void set_ScheduledTime(DateTime value);
    [CompilerGeneratedAttribute]
public CancellationToken get_CancellationToken();
    [CompilerGeneratedAttribute]
public void set_CancellationToken(CancellationToken value);
    [CompilerGeneratedAttribute]
public UserDataHolderNoLocks get_UserData();
    [CompilerGeneratedAttribute]
public void set_UserData(UserDataHolderNoLocks value);
}
public class JetBrains.Concurrency.Fiber : object {
    public ObsoleteLifetimeAndDefinitionAtTheSameTime Disposables;
    private ICorRuntimeHost _clrhost;
    private bool _isCompleted;
    private bool _isPrimary;
    private Void* _pFiber;
    public bool IsCompleted { get; }
    public bool IsPrimary { get; }
    private Fiber(Void* pFiber, bool isPrimary);
    private Fiber(Action action);
    [NotNullAttribute]
public static IFiber CreateSecondaryFiber(Action action);
    [NotNullAttribute]
public static IFiber GetPrimaryFiber();
    public sealed virtual void Dispose();
    public sealed virtual void YieldTo();
    public sealed virtual bool get_IsCompleted();
    public sealed virtual bool get_IsPrimary();
    [CompilerGeneratedAttribute]
private void <.ctor>b__5_0();
    [CompilerGeneratedAttribute]
private void <.ctor>b__7_1();
}
public class JetBrains.Concurrency.FiberOverThread : object {
    [CanBeNullAttribute]
[ThreadStaticAttribute]
private static FiberOverThread _current;
    public ObsoleteLifetimeAndDefinitionAtTheSameTime Disposables;
    private AutoResetEvent _evtContinue;
    private bool _isCompleted;
    private bool _isDisposed;
    private bool _isPrimary;
    protected bool IsDisposed { get; }
    public bool IsCompleted { get; }
    public bool IsPrimary { get; }
    private FiberOverThread(Action action, ITaskHost tasker);
    [NotNullAttribute]
public static FiberOverThread CreateSecondaryFiber(Action action, ITaskHost tasker);
    [NotNullAttribute]
public static FiberOverThread GetPrimaryFiber();
    protected bool get_IsDisposed();
    private void InitCommon(bool isPrimary);
    public sealed virtual void Dispose();
    public sealed virtual void YieldTo();
    public sealed virtual bool get_IsCompleted();
    public sealed virtual bool get_IsPrimary();
    [CompilerGeneratedAttribute]
private void <.ctor>b__6_0();
    [CompilerGeneratedAttribute]
private void <InitCommon>b__12_0();
}
public interface JetBrains.Concurrency.IFiber {
    public bool IsCompleted { get; }
    public bool IsPrimary { get; }
    public abstract virtual bool get_IsCompleted();
    public abstract virtual bool get_IsPrimary();
    public abstract virtual void YieldTo();
}
[DebuggerStepThroughAttribute]
public class JetBrains.DataFlow.AddRemoveEventArgs`1 : EventArgs`1<TValue> {
    protected bool myIsAcknowledging;
    private AddRemove myAction;
    private ICollectionEvents`1<TValue> myCollection;
    private object myCookie;
    public AddRemove Action { get; }
    public ICollectionEvents`1<TValue> Collection { get; }
    [CanBeNullAttribute]
public object Cookie { get; }
    public bool IsAcknowledging { get; }
    public bool IsAdding { get; }
    public bool IsRemoving { get; }
    public AddRemoveEventArgs`1(ICollectionEvents`1<TValue> collection, AddRemove action, TValue value, object cookie);
    public AddRemove get_Action();
    public ICollectionEvents`1<TValue> get_Collection();
    public object get_Cookie();
    public bool get_IsAcknowledging();
    public bool get_IsAdding();
    public bool get_IsRemoving();
    public static AddRemoveEventArgs`1<TValue> CreateAcknowledgementArgs(ICollectionEvents`1<TValue> collection, AddRemove action, object cookie, Action`1& funcSetValue);
}
[DebuggerStepThroughAttribute]
public class JetBrains.DataFlow.AddRemoveIndexEventArgs`1 : AddRemoveEventArgs`1<TValue> {
    private int myIndex;
    public int Index { get; }
    public AddRemoveIndexEventArgs`1(ICollectionEvents`1<TValue> collection, AddRemove action, TValue value, int index, object cookie);
    public int get_Index();
    public static AddRemoveIndexEventArgs`1<TValue> CreateAcknowledgementArgs(ICollectionEvents`1<TValue> collection, AddRemove action, object cookie, Action`2& funcSetValueAndIndex);
}
[DebuggerStepThroughAttribute]
public class JetBrains.DataFlow.BeforeAddRemoveEventArgs`1 : AddRemoveEventArgs`1<TValue> {
    private bool myCancel;
    public bool Cancel { get; public set; }
    public BeforeAddRemoveEventArgs`1(ICollectionEvents`1<TValue> collection, AddRemove action, TValue value, object cookie);
    public bool get_Cancel();
    public void set_Cancel(bool value);
    public static BeforeAddRemoveEventArgs`1<TValue> CreateAcknowledgementArgs(ICollectionEvents`1<TValue> collection, AddRemove action, object cookie, Action`1& funcSetValue);
}
[DebuggerStepThroughAttribute]
public class JetBrains.DataFlow.BeforeAddRemoveIndexEventArgs`1 : BeforeAddRemoveEventArgs`1<TValue> {
    private int myIndex;
    public int Index { get; }
    public BeforeAddRemoveIndexEventArgs`1(ICollectionEvents`1<TValue> collection, AddRemove action, TValue value, int index, object cookie);
    public int get_Index();
    public static BeforeAddRemoveIndexEventArgs`1<TValue> CreateAcknowledgementArgs(ICollectionEvents`1<TValue> collection, AddRemove action, object cookie, Action`2& funcSetValueAndIndex);
}
[DebuggerStepThroughAttribute]
public class JetBrains.DataFlow.BeforePropertyChangedEventArgs`1 : PropertyChangedEventArgs`1<TValue> {
    private bool myCancel;
    public bool Cancel { get; public set; }
    public BeforePropertyChangedEventArgs`1(IProperty`1<TValue> property, TValue old, bool hasold, TValue new, bool hasnew, object cookie);
    public bool get_Cancel();
    public void set_Cancel(bool value);
    [NotNullAttribute]
[PureAttribute]
public static BeforePropertyChangedEventArgs`1<TValue> CreateBoth(IProperty`1<TValue> property, TValue old, TValue new, object cookie);
    [NotNullAttribute]
[PureAttribute]
public static BeforePropertyChangedEventArgs`1<TValue> CreateNew(IProperty`1<TValue> property, TValue new, object cookie);
    [NotNullAttribute]
[PureAttribute]
public static BeforePropertyChangedEventArgs`1<TValue> CreateOld(IProperty`1<TValue> property, TValue old, object cookie);
}
[DebuggerStepThroughAttribute]
public class JetBrains.DataFlow.CancelEventArgs`1 : EventArgs`1<TValue> {
    private bool myCancel;
    public bool Cancel { get; public set; }
    public CancelEventArgs`1(TValue value);
    public bool get_Cancel();
    public void set_Cancel(bool value);
}
[ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static class JetBrains.DataFlow.CollectionBridge : object {
    [ExtensionAttribute]
public static CollectionBridge`2<TSource, TTarget> BridgeInto(ICollectionEvents`1<TSource> source, Lifetime lifetime, ICollectionEvents`1<TTarget> target, Func`2<TSource, TTarget> funcConverter, object cookie);
}
[DebuggerStepThroughAttribute]
public class JetBrains.DataFlow.CollectionBridge`2 : object {
    private Func`2<TSource, TTarget> myFuncConverter;
    private BidirectionalMapOnDictionary`2<TSource, TTarget> myMapBothWays;
    private MappingInfo myMappingInfo;
    private Dictionary`2<TSource, TTarget> myMapSourceToTarget;
    private ICollectionEvents`1<TSource> mySource;
    private ICollectionEvents`1<TTarget> myTarget;
    private object myTargetModificationCookie;
    [CompilerGeneratedAttribute]
private bool <AllowForeignTargetRemovals>k__BackingField;
    public bool AllowForeignTargetRemovals { get; public set; }
    public MappingInfo MappingInfo { get; }
    [NotNullAttribute]
public IDictionary`2<TSource, TTarget> MapSourceToTarget { get; }
    [NotNullAttribute]
public IDictionary`2<TTarget, TSource> MapTargetToSource { get; }
    [NotNullAttribute]
public ICollectionEvents`1<TSource> Source { get; }
    [NotNullAttribute]
public ICollectionEvents`1<TTarget> Target { get; }
    public CollectionBridge`2(Lifetime lifetime, MappingInfo mappinginfo, ICollectionEvents`1<TSource> source, ICollectionEvents`1<TTarget> target, Func`2<TSource, TTarget> funcConverter, object oTaregtModificationCookie);
    [CompilerGeneratedAttribute]
public bool get_AllowForeignTargetRemovals();
    [CompilerGeneratedAttribute]
public void set_AllowForeignTargetRemovals(bool value);
    public MappingInfo get_MappingInfo();
    public IDictionary`2<TSource, TTarget> get_MapSourceToTarget();
    public IDictionary`2<TTarget, TSource> get_MapTargetToSource();
    public ICollectionEvents`1<TSource> get_Source();
    public ICollectionEvents`1<TTarget> get_Target();
    private void Init(Lifetime lifetime);
    [CompilerGeneratedAttribute]
private void <Init>b__22_0(AddRemoveEventArgs`1<TSource> args);
}
[DebuggerStepThroughAttribute]
public class JetBrains.DataFlow.CollectionEvents`1 : object {
    protected static string ValueNameId;
    protected static string ValueNameIsUniqueItems;
    private static string ValueNameStorage;
    [CanBeNullAttribute]
private Csa<TValue> myCsa;
    protected SpinWaitLock myLock;
    [NotNullAttribute]
private PropertyId`1<TValue> myId;
    private bool myIsNullValuesAllowed;
    private bool myIsUniqueItems;
    private SignalWithDelegates`1<AddRemoveEventArgs`1<TValue>> mySignalAddRemove;
    private SignalWithDelegates`1<BeforeAddRemoveEventArgs`1<TValue>> mySignalBeforeAddRemove;
    [NotNullAttribute]
private ICollection`1<TValue> myStorage;
    [NotNullAttribute]
protected ILogger myLogger;
    [CompilerGeneratedAttribute]
private bool <SuppressItemErrors>k__BackingField;
    [CompilerGeneratedAttribute]
private NotifyCollectionChangedEventHandler CollectionChanged;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    public bool IsNullValuesAllowed { get; }
    public bool IsUniqueItems { get; }
    public bool SuppressItemErrors { get; public set; }
    public ISignal`1<AddRemoveEventArgs`1<TValue>> AddRemove { get; }
    public ISignal`1<BeforeAddRemoveEventArgs`1<TValue>> BeforeAddRemove { get; }
    public int Count { get; }
    [NotNullAttribute]
public PropertyId`1<TValue> Id { get; }
    public bool IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public CollectionEvents`1(PropertyId`1<TValue> id, ICollection`1<TValue> storage, bool bUniqueItems, ILogger logger);
    [ObsoleteAttribute("Use overloads without lifetime.")]
[EditorBrowsableAttribute("1")]
public CollectionEvents`1(Lifetime lifetime, PropertyId`1<TValue> id, ICollection`1<TValue> storage, bool bUniqueItems, ILogger logger);
    public CollectionEvents`1(string id, ICollection`1<TValue> storage, bool bUniqueItems);
    [ObsoleteAttribute("Use overloads without lifetime.")]
[EditorBrowsableAttribute("1")]
public CollectionEvents`1(Lifetime lifetime, string id, ICollection`1<TValue> storage, bool bUniqueItems);
    public CollectionEvents`1(string id);
    [ObsoleteAttribute("Use overloads without lifetime.")]
[EditorBrowsableAttribute("1")]
public CollectionEvents`1(Lifetime lifetime, string id);
    protected CollectionEvents`1(SerializationInfo info, StreamingContext context);
    private static CollectionEvents`1();
    public bool get_IsNullValuesAllowed();
    public bool get_IsUniqueItems();
    [CompilerGeneratedAttribute]
public bool get_SuppressItemErrors();
    [CompilerGeneratedAttribute]
public void set_SuppressItemErrors(bool value);
    protected void FireAddRemove(AddRemove action, TValue value, object cookie);
    protected bool FireBeforeAddRemove(AddRemove action, TValue value, object cookie);
    protected virtual void FireCollectionChanged(TValue value, AddRemove addremove);
    protected virtual void FireCollectionChanged(TValue value, int index, AddRemove addremove);
    protected void FirePropertyChanged(string name);
    [PublicAPIAttribute]
protected virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    protected virtual bool CollectionAddCore(TValue value, object cookie);
    protected virtual bool CollectionRemoveCore(TValue value, object cookie);
    private void OnAcknowledgeSinkAddRemove(Action`1<AddRemoveEventArgs`1<TValue>> handler, AddRemove addremove);
    private bool OnAcknowledgeSinkBeforeAddRemove(Action`1<BeforeAddRemoveEventArgs`1<TValue>> handler);
    protected string GetCsaObjectName();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual void add_CollectionChanged(NotifyCollectionChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_CollectionChanged(NotifyCollectionChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    public sealed virtual bool Add(TValue value, object cookie);
    public sealed virtual void Add(TValue item);
    public sealed virtual void AddRange(IEnumerable`1<TValue> items);
    public sealed virtual void Clear();
    public sealed virtual void Clear(object cookie);
    public sealed virtual bool Contains(TValue item);
    public sealed virtual void CopyTo(TValue[] array, int arrayIndex);
    public sealed virtual IEnumerator`1<TValue> GetEnumerator();
    public sealed virtual bool Modify(AddRemove action, TValue item, object cookie);
    public sealed virtual bool Remove(TValue value, object cookie);
    public sealed virtual bool Remove(TValue item);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual ISignal`1<AddRemoveEventArgs`1<TValue>> get_AddRemove();
    public sealed virtual TValue[] ToArray();
    public sealed virtual List`1<TValue> ToList();
    public sealed virtual ISignal`1<BeforeAddRemoveEventArgs`1<TValue>> get_BeforeAddRemove();
    public sealed virtual int get_Count();
    public sealed virtual PropertyId`1<TValue> get_Id();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    public sealed virtual void View(Lifetime lifetime, Action`2<Lifetime, TValue> viewer);
    [CompilerGeneratedAttribute]
private void <.ctor>b__12_0(Action`1<AddRemoveEventArgs`1<TValue>> handler);
    [CompilerGeneratedAttribute]
private void <.ctor>b__12_1(Action`1<AddRemoveEventArgs`1<TValue>> handler);
}
public class JetBrains.DataFlow.CombinedProperty2`3 : PropertyBoilerplate`1<TTarget> {
    [CanBeNullAttribute]
private LifetimeDefinition myDefSinkOrig;
    [NotNullAttribute]
private Func`3<TSource1, TSource2, TTarget> myFCombine;
    private TTarget myLastSeenTarget2;
    private LockObject myLock;
    [NotNullAttribute]
private Action`1[] mySinks;
    [NotNullAttribute]
private IProperty`1<TSource1> mySource1;
    private IProperty`1<TSource2> mySource2;
    public CombinedProperty2`3(IProperty`1<TSource1> propSource1, IProperty`1<TSource2> propSource2, string operation, Func`3<TSource1, TSource2, TTarget> FCombine);
    protected virtual void AdviseCore(Lifetime lifetime, Action`1<PropertyChangedEventArgs`1<TTarget>> handler);
    protected virtual TTarget GetValueCore(object cookie);
    private void NotifySinks(TTarget was, TTarget value, object cookie);
    protected virtual bool SetValueCore(TTarget value, object cookie);
}
[DebuggerStepThroughAttribute]
public class JetBrains.DataFlow.CompositeProperty`3 : object {
    protected static ReadonlyToken myReadonlyToken;
    private ComposerDelegate<TSourceOne, TSourceTwo, TTarget> myComposer;
    private IProperty`1<TSourceOne> mySourceOne;
    private IProperty`1<TSourceTwo> mySourceTwo;
    private Property`1<TTarget> myTarget;
    public ComposerDelegate<TSourceOne, TSourceTwo, TTarget> Composer { get; }
    public IProperty`1<TSourceOne> SourceOne { get; }
    public IProperty`1<TSourceTwo> SourceTwo { get; }
    protected IProperty`1<TTarget> Target { get; }
    protected CompositeProperty`3(Lifetime lifetime, IProperty`1<TSourceOne> propertySourceOne, IProperty`1<TSourceTwo> propertySourceTwo, ComposerDelegate<TSourceOne, TSourceTwo, TTarget> composer);
    private static CompositeProperty`3();
    protected virtual Property`1<TTarget> DecorateProperty(Lifetime lifetime, Property`1<TTarget> property);
    public ComposerDelegate<TSourceOne, TSourceTwo, TTarget> get_Composer();
    public IProperty`1<TSourceOne> get_SourceOne();
    public IProperty`1<TSourceTwo> get_SourceTwo();
    [ObsoleteAttribute("Use overload with lifetime.")]
public static IProperty`1<TTarget> Create(IProperty`1<TSourceOne> propertySourceOne, IProperty`1<TSourceTwo> propertySourceTwo, ComposerDelegate<TSourceOne, TSourceTwo, TTarget> composer);
    public static IProperty`1<TTarget> Create(Lifetime lifetime, IProperty`1<TSourceOne> propertySourceOne, IProperty`1<TSourceTwo> propertySourceTwo, ComposerDelegate<TSourceOne, TSourceTwo, TTarget> composer);
    private void OnAnySourceChanged();
    protected IProperty`1<TTarget> get_Target();
}
[FlagsAttribute]
public enum JetBrains.DataFlow.DataFlowDirection : Enum {
    public int value__;
    public static DataFlowDirection None;
    public static DataFlowDirection FromSource;
    public static DataFlowDirection FromTarget;
    public static DataFlowDirection BothWays;
}
[ExtensionAttribute]
public static class JetBrains.DataFlow.DataFlowEx : object {
    [ExtensionAttribute]
public static void OnSignal(IPropertyBinding binding, Lifetime lifetime, ISignal`1<TSignal> signal, DataFlowDirection direction);
    [ExtensionAttribute]
public static ISimpleSignal AccumulateChange(IReadonlyCollectionEvents`1<E> col, Lifetime lifetime, Func`2<E, ISignal`1<T>> changeSignal);
    [ExtensionAttribute]
public static void AddLifetime(IContainer thіs, LifetimeDefinition lifetime);
}
[DefaultMemberAttribute("Item")]
[DebuggerStepThroughAttribute]
public class JetBrains.DataFlow.DictionaryEvents`2 : CollectionEvents`1<KeyValuePair`2<TKey, TValue>> {
    private static string ValueNameDictionaryStorage;
    private static string ValueNameNullPairKeysAllowed;
    private static string ValueNameNullPairValuesAllowed;
    private bool myNullPairKeysAllowed;
    private bool myNullPairValuesAllowed;
    [NotNullAttribute]
private IDictionary`2<TKey, TValue> myStorage;
    public bool NullPairKeysAllowed { get; }
    public bool NullPairValuesAllowed { get; }
    public TValue Item { get; public set; }
    public ICollection`1<TKey> Keys { get; }
    private IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Keys { get; }
    public ICollection`1<TValue> Values { get; }
    private IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Values { get; }
    public DictionaryEvents`2(PropertyId`1<KeyValuePair`2<TKey, TValue>> id, IDictionary`2<TKey, TValue> storage, bool bNullKeysAllowed, bool bNullValuesAllowed, ILogger logger);
    [ObsoleteAttribute("Use overloads without lifetime.")]
[EditorBrowsableAttribute("1")]
public DictionaryEvents`2(Lifetime lifetime, PropertyId`1<KeyValuePair`2<TKey, TValue>> id, IDictionary`2<TKey, TValue> storage, bool bNullKeysAllowed, bool bNullValuesAllowed, ILogger logger);
    public DictionaryEvents`2(string id, ILogger logger);
    [ObsoleteAttribute("Use overloads without lifetime.")]
[EditorBrowsableAttribute("1")]
public DictionaryEvents`2(Lifetime lifetime, string id, ILogger logger);
    public DictionaryEvents`2(string id, bool bNullKeysAllowed, bool bNullValuesAllowed, ILogger logger);
    [ObsoleteAttribute("Use overloads without lifetime.")]
[EditorBrowsableAttribute("1")]
public DictionaryEvents`2(Lifetime lifetime, string id, bool bNullKeysAllowed, bool bNullValuesAllowed, ILogger logger);
    protected DictionaryEvents`2(SerializationInfo info, StreamingContext context);
    private static DictionaryEvents`2();
    public bool get_NullPairKeysAllowed();
    public bool get_NullPairValuesAllowed();
    protected virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    protected virtual bool CollectionAddCore(KeyValuePair`2<TKey, TValue> value, object cookie);
    protected virtual bool CollectionRemoveCore(KeyValuePair`2<TKey, TValue> value, object cookie);
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    public sealed virtual void Add(TKey key, TValue value);
    public sealed virtual bool ContainsKey(TKey key);
    public sealed virtual bool Remove(TKey key);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    public sealed virtual TValue TryGetValue(TKey key, Func`1<TValue> funcCreateIfMissing);
    public sealed virtual ICollection`1<TKey> get_Keys();
    private sealed virtual override IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Keys();
    public sealed virtual ICollection`1<TValue> get_Values();
    private sealed virtual override IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Values();
    public void set_Item(TKey key, object cookie, TValue value);
    [CompilerGeneratedAttribute]
internal static ArgumentException <CollectionAddCore>g__ErrorAlreadyPresent|18_0(KeyValuePair`2<TKey, TValue> value, PropertyId`1<KeyValuePair`2<TKey, TValue>> id);
    [CompilerGeneratedAttribute]
internal static ArgumentException <CollectionRemoveCore>g__ErrorMissing|19_0(KeyValuePair`2<TKey, TValue> value, PropertyId`1<KeyValuePair`2<TKey, TValue>> id);
    [CompilerGeneratedAttribute]
internal static InvalidOperationException <CollectionRemoveCore>g__ErrorUnknown|19_1(KeyValuePair`2<TKey, TValue> value, PropertyId`1<KeyValuePair`2<TKey, TValue>> id);
    [CompilerGeneratedAttribute]
internal static ArgumentException <Remove>g__ErrorRemove|25_0(TKey key, PropertyId`1<KeyValuePair`2<TKey, TValue>> id);
}
[DebuggerStepThroughAttribute]
public static class JetBrains.DataFlow.Disposable : object {
    [NotNullAttribute]
public static IDisposable Empty;
    private static Disposable();
    [NotNullAttribute]
public static IDisposable CreateBracket(Action opening, Action closing, bool trapExceptions);
    public static IDisposable CreateCompositeDisposable(Func`1[] disposables);
    [NotNullAttribute]
[PureAttribute]
public static IDisposable CreateAction(Action closing);
    public static LocalDisposable LocalFromAction(Action λ);
    public static LocalDisposable`1<TArg> LocalFromAction(TArg arg, Action`1<TArg> λ);
    [NotNullAttribute]
public static IDisposable CreateAction_FinalizableFreeThreaded(string id, Action closing, string messageFinalization, bool saveCtorCallStack);
    [NotNullAttribute]
public static IDisposable CreateBracket_FinalizableFreeThreaded(string id, Action opening, Action closing, string messageFinalization, bool saveCtorCallStack);
    [NotNullAttribute]
public static IDisposable CreateBracket_FinalizableSingleThreaded(string id, Action opening, Action closing, string messageFinalization, bool saveCtorCallStack);
    [NotNullAttribute]
[PureAttribute]
public static IDisposable Compose(IDisposable first, IDisposable second);
    [NotNullAttribute]
[PureAttribute]
public static IDisposable Compose(IDisposable[] disposables);
}
[DebuggerStepThroughAttribute]
public class JetBrains.DataFlow.EventArgs`1 : EventArgs {
    protected TValue myValue;
    public TValue Value { get; }
    public EventArgs`1(TValue value);
    public TValue get_Value();
}
public interface JetBrains.DataFlow.ICollectionEvents`1 {
    public ISignal`1<BeforeAddRemoveEventArgs`1<TValue>> BeforeAddRemove { get; }
    public int Count { get; }
    public abstract virtual ISignal`1<BeforeAddRemoveEventArgs`1<TValue>> get_BeforeAddRemove();
    public abstract virtual int get_Count();
    public abstract virtual bool Add(TValue value, object cookie);
    public abstract virtual void AddRange(IEnumerable`1<TValue> items);
    public abstract virtual bool Modify(AddRemove action, TValue item, object cookie);
    public abstract virtual bool Remove(TValue value, object cookie);
    public abstract virtual void Clear(object cookie);
}
[ExtensionAttribute]
public static class JetBrains.DataFlow.ICollectionEventsEx : object {
    private static ILogger Logger;
    private static ICollectionEventsEx();
    [ExtensionAttribute]
public static void BeginAdd(ICollectionEvents`1<TValue> thіs, Lifetime lifetimeAsyncOperation, JetDispatcher dispatcher, TValue item);
    [ExtensionAttribute]
[NotNullAttribute]
public static IProperty`1<int> CreateCount(IReadonlyCollectionEvents`1<TItem> thіs, Lifetime lifetime);
    [ExtensionAttribute]
[NotNullAttribute]
public static IProperty`1<int> CreateCount(IReadonlyCollectionEvents`1<TItem> thіs, Lifetime lifetime, Func`2<TItem, bool> filter, ILogger logger);
    [ExtensionAttribute]
[NotNullAttribute]
public static IProperty`1<bool> CreateIsEmpty(IReadonlyCollectionEvents`1<TItem> thіs, Lifetime lifetime);
    [ExtensionAttribute]
[NotNullAttribute]
public static IProperty`1<bool> CreateIsNotEmpty(IReadonlyCollectionEvents`1<TItem> thіs, Lifetime lifetime);
    [ExtensionAttribute]
public static void LogChanges(IReadonlyCollectionEvents`1<TValue> thіs, Lifetime lifetime, string prefix);
    private static void LogChanges_Advise(Lifetime lifetime, IReadonlyCollectionEvents`1<TValue> collection, string prefix, ILogger logger, LoggingLevel level);
    [ExtensionAttribute]
public static void LogChanges(IReadonlyCollectionEvents`1<TValue> thіs, Lifetime lifetime, ILogger logger);
    [ExtensionAttribute]
public static void LogChanges(IReadonlyCollectionEvents`1<TValue> thіs, Lifetime lifetime, object logprefix);
    [ExtensionAttribute]
public static void ForEachItem(IReadonlyCollectionEvents`1<TValue> thіs, Lifetime lifetime, Action`2<Lifetime, TValue> FHandler);
    [ExtensionAttribute]
public static void ForEachItem(IReadonlyCollectionEvents`1<TValue> thіs, Lifetime lifetime, Action`3<Lifetime, TValue, object> FHandler);
    [ExtensionAttribute]
private static void ForEachItemCore(IReadonlyCollectionEvents`1<TValue> thіs, Lifetime lifetime, Action`2<Lifetime, TValue> FHandlerA, Action`3<Lifetime, TValue, object> FHandlerB);
    [ExtensionAttribute]
public static void ForEachItemFreeThreaded(IReadonlyCollectionEvents`1<TValue> thіs, Lifetime lifetime, Action`2<Lifetime, TValue> FHandler);
    [ExtensionAttribute]
public static void ForEachItemFreeThreaded(IReadonlyCollectionEvents`1<TValue> thіs, Lifetime lifetime, Action`3<Lifetime, TValue, object> FHandler);
    [ExtensionAttribute]
private static void ForEachItemFreeThreadedCore(IReadonlyCollectionEvents`1<TValue> thіs, Lifetime lifetimeUnsync, Action`2<Lifetime, TValue> FHandlerA, Action`3<Lifetime, TValue, object> FHandlerB);
    [ExtensionAttribute]
public static void Add(ICollectionEvents`1<TValue> thіs, Lifetime lifetime, TValue value, object cookie);
    [ExtensionAttribute]
public static void Insert(IListEvents`1<TValue> thіs, Lifetime lifetime, int index, TValue value, object cookie);
    [ExtensionAttribute]
public static void FlowInto(IReadonlyCollectionEvents`1<TSource> source, Lifetime lifetime, ICollectionEvents`1<TTarget> target, Func`2<TSource, TTarget> FConvert, Func`2<TSource, bool> FFilter, object cookie);
    [ExtensionAttribute]
public static void FlowInto(IReadonlyCollectionEvents`1<TSource> source, Lifetime lifetime, ICollectionEvents`1<TTarget> target, Func`3<Lifetime, TSource, TTarget> FConvert, Func`2<TSource, bool> FFilter, object cookie);
    private static void FlowIntoCollectionCore(Lifetime lifetime, IReadonlyCollectionEvents`1<TSource> source, ICollectionEvents`1<TTarget> target, Func`2<TSource, TTarget> FConvert, Func`3<Lifetime, TSource, TTarget> FLifeConvert, Func`2<TSource, bool> FFilter, object cookie);
    [ExtensionAttribute]
public static void FlowInto(IReadonlyListEvents`1<TSource> source, Lifetime lifetime, IListEvents`1<TTarget> target, Func`2<TSource, TTarget> FConvert, object cookie);
    [ExtensionAttribute]
public static void FlowInto(IReadonlyListEvents`1<TSource> source, Lifetime lifetime, IListEvents`1<TTarget> target, Func`3<Lifetime, TSource, TTarget> FConvert, object cookie);
    [ExtensionAttribute]
public static void FlowInto(IReadonlyListEvents`1<TSource> source, Lifetime lifetime, IListEvents`1<TTarget> target);
    private static void FlowIntoListCore(Lifetime lifetime, IReadonlyListEvents`1<TSource> source, IListEvents`1<TTarget> target, Func`2<TSource, TTarget> FConvert, Func`3<Lifetime, TSource, TTarget> FLifeConvert, object cookie);
    [ExtensionAttribute]
public static void DisposeEachItem(ICollectionEvents`1<TValue> thіs, Lifetime lifetime);
    [ExtensionAttribute]
public static void FlowIntoGuarded_NoReplay(ICollectionEvents`1<TValue> source, Lifetime lifetime, ICollectionEvents`1<TValue> target, ReentrancyGuard reega, bool bReplicateInitialValuesImmediately, object token);
    [ExtensionAttribute]
public static void FlowIntoGrouped_NoReplay(ICollectionEvents`1<TValue> source, Lifetime lifetime, ICollectionEvents`1<TValue> target, GroupingEventHost gehost, TimeSpan delay, bool bReplicateInitialValuesImmediately, object token);
    [ExtensionAttribute]
public static void FlowIntoGrouped_NoReplay(IReadonlyCollectionEvents`1<TValue> source, Lifetime lifetime, ICollectionEvents`1<TValue> target, Action FAssertCanExecuteNow, Action`1<Action> FExecuteGrouped, bool bReplicateInitialValuesImmediately, object token);
    [ExtensionAttribute]
public static void FlowIntoSorted(IReadonlyCollectionEvents`1<TItem> source, Lifetime lifetime, IListEvents`1<TTargetItem> target, IComparer`1<TTargetItem> comparerForSorting, IEqualityComparer`1<TTargetItem> comparerForDeleting, Func`2<TItem, bool> FFilter, object cookie, bool clearTarget);
    [ExtensionAttribute]
public static Lifetime GetLifetimeOfItem(IReadonlyCollectionEvents`1<TItem> thіs, Lifetime lifetime, TItem item);
    [ExtensionAttribute]
public static TItem AddItemUnderLifetime(ICollectionEvents`1<TItem> thіs, Lifetime lifetimeOuter, Func`3<Lifetime, LifetimeDefinition, TItem> FCreateItem);
    [ExtensionAttribute]
[NotNullAttribute]
public static IDictionaryEvents`2<TKey, ICollectionEvents`1<TValue>> ToMultiValueDictionary(ICollectionEvents`1<TSource> source, Lifetime lifetime, string id, Func`2<TSource, TKey> FGetKey, Func`2<TSource, TValue> FGetValue, IEqualityComparer`1<TKey> keycomparer, IEqualityComparer`1<TValue> valuecomparer);
    [ExtensionAttribute]
public static void SyncOneTime(IListEvents`1<TItem> listEvents, IEnumerable`1<TItem> currentData);
    [CompilerGeneratedAttribute]
internal static void <SyncOneTime>g__AssureItemAt|35_0(TItem item, int index, <>c__DisplayClass35_0`1& );
}
[ExtensionAttribute]
public static class JetBrains.DataFlow.ICollectionEventsEx_ObsoleteWithoutLifetime : object {
    [ExtensionAttribute]
[ObsoleteAttribute("Use overload with lifetime.")]
public static void BeginAdd(ICollectionEvents`1<TValue> coll, JetDispatcher dispatcher, TValue item);
    [ExtensionAttribute]
[NotNullAttribute]
[ObsoleteAttribute("Use overload with lifetime.")]
public static IDisposable BridgeInto_Guarded_Slow(ICollectionEvents`1<TValue> source, ICollectionEvents`1<TValue> target, ReentrancyGuard reega, object token);
    [ExtensionAttribute]
[NotNullAttribute]
[ObsoleteAttribute("Use overload with lifetime.")]
public static IDisposable PushForEachItem(ICollectionEvents`1<TValue> coll, Func`2<TValue, IDisposable> handler);
    [ExtensionAttribute]
[NotNullAttribute]
[ObsoleteAttribute("Use overload with lifetime.")]
private static IDisposable PushForEachItem(ICollectionEvents`1<TValue> coll, Func`2<AddRemoveEventArgs`1<TValue>, IDisposable> handler);
}
[ExtensionAttribute]
public static class JetBrains.DataFlow.ICollectionSignalEx : object {
    [ExtensionAttribute]
public static void Advise_Add(ISignal`1<AddRemoveEventArgs`1<TValue>> thіs, Lifetime lifetime, Action`1<AddRemoveEventArgs`1<TValue>> FHandler);
    [ExtensionAttribute]
public static void Advise_Add(ISignal`1<AddRemoveIndexEventArgs`1<TValue>> thіs, Lifetime lifetime, Action`1<AddRemoveIndexEventArgs`1<TValue>> FHandler);
    [ExtensionAttribute]
public static void Advise_Remove(ISignal`1<AddRemoveEventArgs`1<TValue>> thіs, Lifetime lifetime, Action`1<AddRemoveEventArgs`1<TValue>> FHandler);
    [ExtensionAttribute]
public static void Advise_Remove(ISignal`1<AddRemoveIndexEventArgs`1<TValue>> thіs, Lifetime lifetime, Action`1<AddRemoveIndexEventArgs`1<TValue>> FHandler);
    [ExtensionAttribute]
public static void Advise_NoAcknowledgement(ISignal`1<BeforeAddRemoveEventArgs`1<TValue>> thіs, Lifetime lifetime, Action`1<BeforeAddRemoveEventArgs`1<TValue>> FHandler);
    [ExtensionAttribute]
public static void Advise_NoAcknowledgement(ISignal`1<BeforeAddRemoveEventArgs`1<TValue>> thіs, Lifetime lifetime, Action FHandler);
    [ExtensionAttribute]
public static void Advise_NoAcknowledgement(ISignal`1<AddRemoveEventArgs`1<TValue>> thіs, Lifetime lifetime, Action`1<AddRemoveEventArgs`1<TValue>> FHandler);
    [ExtensionAttribute]
public static void Advise_NoAcknowledgement(ISignal`1<AddRemoveIndexEventArgs`1<TValue>> thіs, Lifetime lifetime, Action`1<AddRemoveEventArgs`1<TValue>> FHandler);
    [ExtensionAttribute]
public static void Advise_NoAcknowledgement(ISignal`1<AddRemoveEventArgs`1<TValue>> thіs, Lifetime lifetime, Action FHandler);
    [ExtensionAttribute]
public static void Advise_NoAcknowledgement(ISignal`1<AddRemoveIndexEventArgs`1<TValue>> thіs, Lifetime lifetime, Action FHandler);
}
[ExtensionAttribute]
public static class JetBrains.DataFlow.ICollectionSignalEx_ObsoleteWithoutLifetime : object {
    [ExtensionAttribute]
[NotNullAttribute]
[ObsoleteAttribute("Use overload with lifetime.")]
public static IDisposable Advise_Add(ISignal`1<AddRemoveIndexEventArgs`1<TValue>> thіs, Action`1<AddRemoveIndexEventArgs`1<TValue>> handler);
    [ExtensionAttribute]
[NotNullAttribute]
[ObsoleteAttribute("Use overload with lifetime.")]
public static IDisposable Advise_Remove(ISignal`1<AddRemoveEventArgs`1<TValue>> signal, Action`1<AddRemoveEventArgs`1<TValue>> handler);
    [ExtensionAttribute]
[NotNullAttribute]
[ObsoleteAttribute("Use overload with lifetime.")]
public static IDisposable Advise_Remove(ISignal`1<AddRemoveIndexEventArgs`1<TValue>> signal, Action`1<AddRemoveIndexEventArgs`1<TValue>> handler);
    [ExtensionAttribute]
[NotNullAttribute]
[ObsoleteAttribute("Use overload with lifetime.")]
public static IDisposable Advise_NoAcknowledgement(ISignal`1<BeforeAddRemoveEventArgs`1<TValue>> signal, Action`1<BeforeAddRemoveEventArgs`1<TValue>> handler);
    [ExtensionAttribute]
[NotNullAttribute]
[ObsoleteAttribute("Use overload with lifetime.")]
public static IDisposable Advise_NoAcknowledgement(ISignal`1<BeforeAddRemoveEventArgs`1<TValue>> signal, Action handler);
    [ExtensionAttribute]
[NotNullAttribute]
[ObsoleteAttribute("Use overload with lifetime.")]
public static IDisposable Advise_NoAcknowledgement(ISignal`1<AddRemoveEventArgs`1<TValue>> signal, Action`1<AddRemoveEventArgs`1<TValue>> handler);
    [ExtensionAttribute]
[NotNullAttribute]
[ObsoleteAttribute("Use overload with lifetime.")]
public static IDisposable Advise_NoAcknowledgement(ISignal`1<AddRemoveEventArgs`1<TValue>> signal, Action handler);
    [ExtensionAttribute]
[NotNullAttribute]
[ObsoleteAttribute("Use overload with lifetime.")]
public static IDisposable Advise_NoAcknowledgement(ISignal`1<AddRemoveIndexEventArgs`1<TValue>> signal, Action handler);
}
[DefaultMemberAttribute("Item")]
public interface JetBrains.DataFlow.IDictionaryEvents`2 {
    [NotNullAttribute]
public ICollection`1<TKey> Keys { get; }
    [NotNullAttribute]
public ICollection`1<TValue> Values { get; }
    public TValue Item { get; public set; }
    public abstract virtual TValue TryGetValue(TKey key, Func`1<TValue> funcCreateIfMissing);
    public abstract virtual ICollection`1<TKey> get_Keys();
    public abstract virtual ICollection`1<TValue> get_Values();
    public abstract virtual bool ContainsKey(TKey key);
    public abstract virtual TValue get_Item(TKey key);
    public abstract virtual void set_Item(TKey key, TValue value);
    public abstract virtual bool TryGetValue(TKey key, TValue& value);
}
public interface JetBrains.DataFlow.IHaveUntypedProperty {
    [NotNullAttribute]
public IUntypedProperty AsUntyped { get; }
    public abstract virtual IUntypedProperty get_AsUntyped();
}
[DefaultMemberAttribute("Item")]
public interface JetBrains.DataFlow.IListEvents`1 {
    public TValue Item { get; public set; }
    public ISignal`1<BeforeAddRemoveIndexEventArgs`1<TValue>> BeforeAddRemove { get; }
    public abstract virtual TValue get_Item(int index);
    public abstract virtual void set_Item(int index, TValue value);
    public abstract virtual ISignal`1<BeforeAddRemoveIndexEventArgs`1<TValue>> get_BeforeAddRemove();
    public abstract virtual bool Modify(AddRemove action, TValue item, int index, object cookie);
    public abstract virtual bool Modify(AddRemove action, Func`1<TValue> funcGetItemIfAdding, int index, object cookie);
}
public class JetBrains.DataFlow.Infra.SignalWithDelegates`1 : Signal`1<TValue> {
    [CompilerGeneratedAttribute]
private Action`1<Action`1<TValue>> <AfterAdviseHandler>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`1<Action`1<TValue>> <AfterUnadviseHandler>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<Action`1<TValue>, bool> <BeforeAdviseHandler>k__BackingField;
    public Action`1<Action`1<TValue>> AfterAdviseHandler { get; public set; }
    public Action`1<Action`1<TValue>> AfterUnadviseHandler { get; public set; }
    public Func`2<Action`1<TValue>, bool> BeforeAdviseHandler { get; public set; }
    public SignalWithDelegates`1(string id, ILogger logger);
    [CompilerGeneratedAttribute]
public Action`1<Action`1<TValue>> get_AfterAdviseHandler();
    [CompilerGeneratedAttribute]
public void set_AfterAdviseHandler(Action`1<Action`1<TValue>> value);
    [CompilerGeneratedAttribute]
public Action`1<Action`1<TValue>> get_AfterUnadviseHandler();
    [CompilerGeneratedAttribute]
public void set_AfterUnadviseHandler(Action`1<Action`1<TValue>> value);
    [CompilerGeneratedAttribute]
public Func`2<Action`1<TValue>, bool> get_BeforeAdviseHandler();
    [CompilerGeneratedAttribute]
public void set_BeforeAdviseHandler(Func`2<Action`1<TValue>, bool> value);
    protected virtual void OnAfterAdvise(Action`1<TValue> handler);
    protected virtual void OnAfterUnadvise(Action`1<TValue> handler);
    protected virtual bool OnBeforeAdvise(Action`1<TValue> handler);
}
public class JetBrains.DataFlow.Infra.SimpleSignalWithDelegates : SimpleSignal {
    [CompilerGeneratedAttribute]
private Action`1<Action`1<bool>> <AfterAdviseHandler>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`1<Action`1<bool>> <AfterUnadviseHandler>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<Action`1<bool>, bool> <BeforeAdviseHandler>k__BackingField;
    public Action`1<Action`1<bool>> AfterAdviseHandler { get; public set; }
    public Action`1<Action`1<bool>> AfterUnadviseHandler { get; public set; }
    public Func`2<Action`1<bool>, bool> BeforeAdviseHandler { get; public set; }
    public SimpleSignalWithDelegates(Lifetime lifetime, string id, ILogger logger);
    [CompilerGeneratedAttribute]
public Action`1<Action`1<bool>> get_AfterAdviseHandler();
    [CompilerGeneratedAttribute]
public void set_AfterAdviseHandler(Action`1<Action`1<bool>> value);
    [CompilerGeneratedAttribute]
public Action`1<Action`1<bool>> get_AfterUnadviseHandler();
    [CompilerGeneratedAttribute]
public void set_AfterUnadviseHandler(Action`1<Action`1<bool>> value);
    [CompilerGeneratedAttribute]
public Func`2<Action`1<bool>, bool> get_BeforeAdviseHandler();
    [CompilerGeneratedAttribute]
public void set_BeforeAdviseHandler(Func`2<Action`1<bool>, bool> value);
    protected virtual void OnAfterAdvise(Action`1<bool> handler);
    protected virtual void OnAfterUnadvise(Action`1<bool> handler);
    protected virtual bool OnBeforeAdvise(Action`1<bool> handler);
}
[DebuggerStepThroughAttribute]
public class JetBrains.DataFlow.InOutEventArgs`2 : EventArgs {
    private TIn myIn;
    [CompilerGeneratedAttribute]
private TOut <Out>k__BackingField;
    public TIn In { get; }
    public TOut Out { get; public set; }
    public InOutEventArgs`2(TIn in, TOut out);
    public InOutEventArgs`2(TIn in);
    public TIn get_In();
    [CompilerGeneratedAttribute]
public TOut get_Out();
    [CompilerGeneratedAttribute]
public void set_Out(TOut value);
}
public interface JetBrains.DataFlow.IProperty`1 {
    public ISignal`1<BeforePropertyChangedEventArgs`1<TValue>> BeforeChange { get; }
    public ISignal`1<PropertyChangedEventArgs`1<TValue>> Change { get; }
    [NotNullAttribute]
public PropertyId`1<TValue> Id { get; }
    public TValue Value { get; public set; }
    public bool IsNullValueAllowed { get; }
    public abstract virtual ISignal`1<BeforePropertyChangedEventArgs`1<TValue>> get_BeforeChange();
    public abstract virtual ISignal`1<PropertyChangedEventArgs`1<TValue>> get_Change();
    public abstract virtual PropertyId`1<TValue> get_Id();
    public abstract virtual TValue get_Value();
    public abstract virtual void set_Value(TValue value);
    public abstract virtual bool get_IsNullValueAllowed();
    public abstract virtual TValue GetValue();
    public abstract virtual TValue GetValue(object cookie);
    public abstract virtual bool SetValue(TValue value);
    public abstract virtual bool SetValue(TValue value, object cookie);
}
public interface JetBrains.DataFlow.IPropertyBag {
    [NotNullAttribute]
public IUntypedPropertyBag AsUntyped { get; }
    [NotNullAttribute]
public IDictionaryEvents`2<PropertyId, IUntypedProperty> Properties { get; }
    public abstract virtual bool Contains(PropertyId`1<T> id);
    public abstract virtual T Get(PropertyId`1<T> id);
    [NotNullAttribute]
public abstract virtual IProperty`1<T> GetOrCreateProperty(PropertyId`1<T> id, T defaultvalue, Nullable`1<bool> isNullValueAllowed);
    [NotNullAttribute]
public abstract virtual IProperty`1<T> GetProperty(PropertyId`1<T> id);
    public abstract virtual bool Remove(PropertyId`1<T> id);
    public abstract virtual void Set(PropertyId`1<T> id, T value);
    public abstract virtual bool TryGet(PropertyId`1<T> id, T& value);
    [CanBeNullAttribute]
public abstract virtual T TryGet(PropertyId`1<T> id);
    public abstract virtual IUntypedPropertyBag get_AsUntyped();
    public abstract virtual IDictionaryEvents`2<PropertyId, IUntypedProperty> get_Properties();
}
[ExtensionAttribute]
public static class JetBrains.DataFlow.IPropertyBagEx : object {
    [ExtensionAttribute]
public static void LogChanges(IPropertyBag thіs, Lifetime lifetime, string prefix);
}
public interface JetBrains.DataFlow.IPropertyBinding {
    public DataFlowDirection Direction { get; }
    public IUntypedProperty Source { get; }
    public IUntypedProperty Target { get; }
    public abstract virtual DataFlowDirection get_Direction();
    public abstract virtual IUntypedProperty get_Source();
    public abstract virtual IUntypedProperty get_Target();
    public abstract virtual void CopySourceToTarget();
    public abstract virtual void CopyTargetToSource();
}
public interface JetBrains.DataFlow.IPropertyBinding`2 {
    public IProperty`1<IProperty`1<TSource>> Source { get; }
    public IProperty`1<IProperty`1<TTarget>> Target { get; }
    [NotNullAttribute]
public IPropertyBinding AsUntyped { get; }
    public DataFlowDirection Direction { get; }
    public abstract virtual IProperty`1<IProperty`1<TSource>> get_Source();
    public abstract virtual IProperty`1<IProperty`1<TTarget>> get_Target();
    public abstract virtual IPropertyBinding get_AsUntyped();
    public abstract virtual DataFlowDirection get_Direction();
    public abstract virtual void CopySourceToTarget();
    public abstract virtual void CopyTargetToSource();
}
public interface JetBrains.DataFlow.IPropertyChangedEventArgs {
    public bool HasNew { get; }
    public bool HasOld { get; }
    public abstract virtual bool get_HasNew();
    public abstract virtual bool get_HasOld();
}
[ExtensionAttribute]
public static class JetBrains.DataFlow.IPropertyEx : object {
    private static ILogger Logger;
    private static IPropertyEx();
    [ExtensionAttribute]
public static void BeginSetValue(IProperty`1<TValue> property, Lifetime lifetime, JetDispatcher dispatcher, TValue value, object cookie);
    [ExtensionAttribute]
[NotNullAttribute]
public static IProperty`1<TTarget> Cast(IUntypedProperty propSource, Lifetime lifetime);
    [ExtensionAttribute]
public static void FlowDeferredInto(IProperty`1<TValue> source, Lifetime lifetime, IProperty`1<TValue> target);
    [ExtensionAttribute]
public static void FlowDeferredInto(IProperty`1<TSource> source, Lifetime lifetime, IProperty`1<TTarget> target, Func`2<TSource, TTarget> FConvert);
    [ExtensionAttribute]
public static void FlowDeferredInto(IProperty`1<TSource> source, Lifetime lifetime, JetDispatcher dispatcher, IProperty`1<TTarget> target, Func`2<TSource, TTarget> FConvert);
    [ExtensionAttribute]
public static void FlowDeferredInto(IProperty`1<TSource> source, Lifetime lifetime, JetDispatcher dispatcher, IProperty`1<TTarget> target, Func`2<TSource, TTarget> FConvert, TaskPriority priority);
    [ExtensionAttribute]
public static void FlowDeferredInto(IProperty`1<TValue> source, Lifetime lifetime, JetDispatcher dispatcher, IProperty`1<TValue> target);
    [ExtensionAttribute]
public static void FlowInto(IProperty`1<TValue> source, Lifetime lifetime, IProperty`1<TValue> target);
    [ExtensionAttribute]
public static void FlowInto(IProperty`1<TSource> source, Lifetime lifetime, IProperty`1<TTarget> target, Func`2<TSource, TTarget> FConverter);
    [ExtensionAttribute]
public static void FlowChangesInto(IProperty`1<TValue> source, Lifetime lifetime, IProperty`1<TValue> target);
    [ExtensionAttribute]
public static void FlowChangesInto(IProperty`1<TSource> source, Lifetime lifetime, IProperty`1<TTarget> target, Func`2<TSource, TTarget> FConverter);
    [ExtensionAttribute]
public static void FlowIntoReadonly(IProperty`1<TSource> source, Lifetime lifetime, IProperty`1<TTarget> target, Func`2<TSource, TTarget> FConverter, ReadonlyToken token);
    [ExtensionAttribute]
public static void FlowIntoReadonly(IProperty`1<TValue> source, Lifetime lifetime, IProperty`1<TValue> target, ReadonlyToken token);
    [ExtensionAttribute]
public static void FlowIntoViaGroupingEvent(IProperty`1<TValue> source, Lifetime lifetime, IProperty`1<TValue> target, GroupingEvent grouper, bool prolongate, ReadonlyToken token);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use FlowIntoViaGroupingEvent instead")]
public static void FlowInto_Grouped(IProperty`1<TValue> source, Lifetime lifetime, IProperty`1<TValue> target, GroupingEvent grouper, ReadonlyToken token);
    [ExtensionAttribute]
[NotNullAttribute]
public static IProperty`1<bool> Invert(IProperty`1<bool> property, Lifetime lifetime);
    [ExtensionAttribute]
public static void LogChanges(IProperty`1<TValue> property, Lifetime lifetime, string prefix);
    private static void LogChanges_Advise(Lifetime lifetime, IProperty`1<TValue> property, string prefix, ILogger logger, LoggingLevel level);
    [ExtensionAttribute]
public static void LogChangesAndStacktraces(IProperty`1<TValue> property, Lifetime lifetime, ILogger logger, Nullable`1<LoggingLevel> loglevel);
    private static void LogChangesAndStacktraces_Advise(Lifetime lifetime, IProperty`1<TValue> property, ILogger loggerChosen, LoggingLevel levelChosen);
    [ExtensionAttribute]
public static void LogChanges(IProperty`1<TValue> property, Lifetime lifetime, object logprefix);
    [ExtensionAttribute]
public static IProperty`1<TValue> LogChanges(IProperty`1<TValue> property, Lifetime lifetime, ILogger logger, string prefix, LoggingLevel level);
    [ExtensionAttribute]
public static IProperty`1<TValue> LogChanges(IProperty`1<TValue> property, Lifetime lifetime, ILogger logger, LoggingLevel level);
    [ExtensionAttribute]
[NotNullAttribute]
public static Property`1<TValue> LogChanges(Property`1<TValue> property, ILogger logger, LoggingLevel level);
    [ExtensionAttribute]
[NotNullAttribute]
[ObsoleteAttribute("Use MakeFlag version without a lifetime.")]
public static IProperty`1<bool> MakeFlag(IProperty`1<TValue> prop, Lifetime lifetime, Func`2<TValue, bool> FCondition, string sConditionName);
    [ExtensionAttribute]
[NotNullAttribute]
public static IProperty`1<bool> MakeFlag(IProperty`1<TValue> prop, string sConditionName, Func`2<TValue, bool> FCondition);
    [ExtensionAttribute]
[NotNullAttribute]
public static IProperty`1<bool> MakeFlag_NotNull(IProperty`1<TValue> prop, Lifetime lifetime);
    [ExtensionAttribute]
[NotNullAttribute]
public static IProperty`1<TTarget> OfType(IUntypedProperty propSource, Lifetime lifetime);
    [ExtensionAttribute]
public static void ForEachValue(IProperty`1<TValue> property, Lifetime lifetime, Action`2<Lifetime, TValue> FHandler);
    [ExtensionAttribute]
public static void ForEachValue(IProperty`1<TValue> property, Lifetime lifetime, Action`3<Lifetime, TValue, object> FHandler);
    [ExtensionAttribute]
public static void ForEachValue(IProperty`1<TValue> property, Lifetime lifetime, Func`2<TValue, bool> FCondition, Action`2<Lifetime, TValue> FHandler);
    [ExtensionAttribute]
public static void ForEachValue(IProperty`1<TValue> property, Lifetime lifetime, Func`2<TValue, bool> FCondition, Action`3<Lifetime, TValue, object> FHandler);
    [ExtensionAttribute]
public static void DisposeEachValue(IProperty`1<TValue> property, Lifetime lifetime);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static void ForEachValue_NotNull(IProperty`1<TValue> property, Lifetime lifetime, Action`2<Lifetime, TValue> FHandler);
    [ExtensionAttribute]
public static void SetValue(IProperty`1<TValue> property, Lifetime lifetime, TValue value, object cookie);
    [ExtensionAttribute]
public static void When(IProperty`1<T> property, Lifetime lifetime, T value, Action`1<Lifetime> FHandler);
    [ExtensionAttribute]
public static void When(IProperty`1<T> property, Lifetime lifetime, Predicate`1<T> predicate, Action`1<Lifetime> FHandler);
    [ExtensionAttribute]
public static void WhenTrue(IProperty`1<bool> property, Lifetime lifetime, Action`1<Lifetime> FHandler);
    [ExtensionAttribute]
public static void WhenTrueOnce(IProperty`1<bool> property, Lifetime lifetime, Action FHandler);
    [ExtensionAttribute]
public static void WhenFalseOnce(IProperty`1<bool> property, Lifetime lifetime, Action FHandler);
    public static void WhenEqualsOnce(IProperty`1<T> property, Lifetime lifetime, Action FHandler, T value);
    [ExtensionAttribute]
public static void WhenFalse(IProperty`1<bool> property, Lifetime lifetime, Action`1<Lifetime> FHandler);
    [ExtensionAttribute]
public static void WhenNotNull(IProperty`1<T> property, Lifetime lifetime, Action`2<Lifetime, T> FHandler);
    [ExtensionAttribute]
public static void WhenNotNull(IProperty`1<T> property, Lifetime lifetime, Action`3<Lifetime, T, object> FHandler);
    [ExtensionAttribute]
public static void WhenNotNullOnce(IProperty`1<T> property, Lifetime lifetime, Action FHandler);
    [ExtensionAttribute]
[NotNullAttribute]
[ObsoleteAttribute("If your Select operation does not use value lifetime, use the lifetimeless overload.")]
public static IProperty`1<TTarget> Select(IProperty`1<TSource> propSource, Lifetime lifetime, string comment, Func`2<TSource, TTarget> FSelect);
    [ExtensionAttribute]
[NotNullAttribute]
public static IProperty`1<TTarget> Select(IProperty`1<TSource> propSource, string comment, Func`2<TSource, TTarget> FSelect);
    [ExtensionAttribute]
[NotNullAttribute]
public static IProperty`1<TTarget> Select(ValueTuple`2<IProperty`1<TSource1>, IProperty`1<TSource2>> sources, string comment, Func`3<TSource1, TSource2, TTarget> FSelect);
    [ExtensionAttribute]
[NotNullAttribute]
public static IProperty`1<TTarget> Select(ValueTuple`3<IProperty`1<TSource1>, IProperty`1<TSource2>, IProperty`1<TSource3>> sources, string comment, Func`4<TSource1, TSource2, TSource3, TTarget> FSelect);
    [ExtensionAttribute]
public static bool WaitForValue(IProperty`1<T> property, OuterLifetime lifetime, Predicate`1<T> valueCondition, int waitIntervalBetweenChecksMillis);
    [ExtensionAttribute]
[NotNullAttribute]
public static IProperty`1<TTarget> Select(IProperty`1<TSource> propSource, Lifetime lifetime, string comment, Func`3<Lifetime, TSource, TTarget> FSelect);
    [CanBeNullAttribute]
public static Type TryGetPropertyType(Type type);
    [ExtensionAttribute]
private static void FlowDeferredIntoCore(IProperty`1<TSource> source, Lifetime lifetime, Func`1<JetDispatcher> FGetDispatcher, IProperty`1<TTarget> target, Func`2<TSource, TTarget> FConvert, TaskPriority priority);
    public static IUntypedProperty CreateUntypedProperty(PropertyId id, object value, Nullable`1<bool> isNullValueAllowed, ILogger logger);
    [ExtensionAttribute]
public static void SetValueUnderLifetime(IProperty`1<TValue> property, Lifetime lifeOuter, Func`2<Lifetime, TValue> FCreateValue);
    [ExtensionAttribute]
[NotNullAttribute]
public static IProperty`1<TCombined> CombineCustom(IProperty`1<TSource1> propSrc1, IProperty`1<TSource2> propSrc2, string operation, Func`3<TSource1, TSource2, TCombined> FCombinator);
    [ExtensionAttribute]
[NotNullAttribute]
public static IProperty`1<ValueTuple`2<TSource1, TSource2>> Combine(IProperty`1<TSource1> propSrc1, IProperty`1<TSource2> propSrc2);
    [ExtensionAttribute]
[NotNullAttribute]
public static IProperty`1<ValueTuple`2<TSource1, TSource2>> Combine(ValueTuple`2<IProperty`1<TSource1>, IProperty`1<TSource2>> tuple);
    [ExtensionAttribute]
[NotNullAttribute]
public static IProperty`1<ValueTuple`3<TSource1, TSource2, TSource3>> Combine(ValueTuple`3<IProperty`1<TSource1>, IProperty`1<TSource2>, IProperty`1<TSource3>> tuple);
    [ExtensionAttribute]
[NotNullAttribute]
public static IProperty`1<ValueTuple`3<TSource1, TSource2, TSource3>> Combine(IProperty`1<ValueTuple`2<TSource1, TSource2>> propSrc12, IProperty`1<TSource3> propSrc3);
    [ExtensionAttribute]
[NotNullAttribute]
public static IProperty`1<ValueTuple`4<TSource1, TSource2, TSource3, TSource4>> Combine(IProperty`1<ValueTuple`3<TSource1, TSource2, TSource3>> propSrc123, IProperty`1<TSource4> propSrc4);
    [ExtensionAttribute]
[NotNullAttribute]
public static IProperty`1<ValueTuple`5<TSource1, TSource2, TSource3, TSource4, TSource5>> Combine(IProperty`1<ValueTuple`4<TSource1, TSource2, TSource3, TSource4>> propSrc1234, IProperty`1<TSource5> propSrc5);
    [ExtensionAttribute]
public static IReadonlyProperty`1<TValue> AsReadOnly(IProperty`1<TValue> source, Lifetime lifetime);
}
[ExtensionAttribute]
public static class JetBrains.DataFlow.IPropertyEx_ObsoleteWithoutLifetime : object {
    [ExtensionAttribute]
[NotNullAttribute]
[ObsoleteAttribute("Use ForEachValue overload with lifetime.")]
public static IDisposable PushForEachValue(IProperty`1<TValue> property, Func`2<TValue, IDisposable> handler);
    [ExtensionAttribute]
[NotNullAttribute]
[ObsoleteAttribute("Use SetValue overload with lifetime.")]
public static IDisposable PushValue(IProperty`1<TValue> property, TValue value, object cookie);
    [ExtensionAttribute]
[NotNullAttribute]
[ObsoleteAttribute("Use SetValue overload with lifetime.")]
public static IDisposable PushValue(IProperty`1<TValue> property, TValue value);
    [ExtensionAttribute]
[NotNullAttribute]
[ObsoleteAttribute("Use overload with lifetime.")]
public static IDisposable FlowInto(IProperty`1<TValue> source, IProperty`1<TValue> target);
    [ExtensionAttribute]
[NotNullAttribute]
[ObsoleteAttribute("Use overload with lifetime.")]
public static IDisposable FlowInto(IProperty`1<TSource> source, IProperty`1<TTarget> target, Func`2<TSource, TTarget> converter);
    [ExtensionAttribute]
[NotNullAttribute]
[ObsoleteAttribute("Use overload with lifetime.")]
public static IDisposable LogChanges(IProperty`1<TValue> property, string prefix);
    [ExtensionAttribute]
[NotNullAttribute]
[ObsoleteAttribute("Use overload with lifetime.")]
public static IDisposable LogChanges(IProperty`1<TValue> property, object logprefix);
}
[ExtensionAttribute]
public static class JetBrains.DataFlow.IPropertySignalEx : object {
    [ExtensionAttribute]
public static void Advise_FallingFront(ISignal`1<PropertyChangedEventArgs`1<TValue>> thіs, Lifetime lifetime, Action FHandler);
    [ExtensionAttribute]
public static void Advise_FallingFront(ISignal`1<PropertyChangedEventArgs`1<TValue>> thіs, Lifetime lifetime, Action`1<PropertyChangedEventArgs`1<TValue>> FHandler);
    [ExtensionAttribute]
public static void Advise_FallingFrontHasNew(ISignal`1<PropertyChangedEventArgs`1<bool>> signal, Lifetime lifetime, Action handler);
    [ExtensionAttribute]
public static void Advise_HasNew(ISignal`1<PropertyChangedEventArgs`1<TValue>> thіs, Lifetime lifetime, Action`1<PropertyChangedEventArgs`1<TValue>> FHandler);
    [ExtensionAttribute]
public static void Advise_HasNew(ISignal`1<PropertyChangedEventArgs`1<TValue>> thіs, Lifetime lifetime, Action FHandler);
    [ExtensionAttribute]
public static void Advise_HasOld(ISignal`1<PropertyChangedEventArgs`1<TValue>> thіs, Lifetime lifetime, Action`1<PropertyChangedEventArgs`1<TValue>> FHandler);
    [ExtensionAttribute]
public static void Advise_HasOld(ISignal`1<PropertyChangedEventArgs`1<TValue>> thіs, Lifetime lifetime, Action FHandler);
    [ExtensionAttribute]
public static void Advise_NewNotNull(ISignal`1<PropertyChangedEventArgs`1<TValue>> thіs, Lifetime lifetime, Action`1<PropertyChangedEventArgs`1<TValue>> FHandler);
    [ExtensionAttribute]
public static void Advise_NewNotNull(ISignal`1<PropertyChangedEventArgs`1<TValue>> thіs, Lifetime lifetime, Action FHandler);
    [ExtensionAttribute]
public static void Advise_NoAcknowledgement(ISignal`1<PropertyChangedEventArgs`1<TValue>> thіs, Lifetime lifetime, Action`1<PropertyChangedEventArgs`1<TValue>> FHandler);
    [ExtensionAttribute]
public static void Advise_NoAcknowledgement(ISignal`1<PropertyChangedEventArgs`1<TValue>> thіs, Lifetime lifetime, Action FHandler);
    [ExtensionAttribute]
public static void Advise_NoAcknowledgement(ISignal`1<BeforePropertyChangedEventArgs`1<TValue>> thіs, Lifetime lifetime, Action`1<BeforePropertyChangedEventArgs`1<TValue>> FHandler);
    [ExtensionAttribute]
public static void Advise_NoAcknowledgement(ISignal`1<BeforePropertyChangedEventArgs`1<TValue>> thіs, Lifetime lifetime, Action FHandler);
    [ExtensionAttribute]
public static void Advise_OldNotNull(ISignal`1<BeforePropertyChangedEventArgs`1<TValue>> thіs, Lifetime lifetime, Action`1<BeforePropertyChangedEventArgs`1<TValue>> FHandler);
    [ExtensionAttribute]
public static void Advise_HasNew(ISignal`1<BeforePropertyChangedEventArgs`1<TValue>> thіs, Lifetime lifetime, Action`1<BeforePropertyChangedEventArgs`1<TValue>> FHandler);
    [ExtensionAttribute]
public static void Advise_RaisingFront(ISignal`1<PropertyChangedEventArgs`1<TValue>> thіs, Lifetime lifetime, Action FHandler);
    [ExtensionAttribute]
public static void Advise_RaisingFront(ISignal`1<PropertyChangedEventArgs`1<TValue>> thіs, Lifetime lifetime, Action`1<PropertyChangedEventArgs`1<TValue>> FHandler);
    [ExtensionAttribute]
public static void Advise_When(ISignal`1<PropertyChangedEventArgs`1<TValue>> thіs, Lifetime lifetime, TValue valueWhen, Action FHandler);
    [ExtensionAttribute]
public static void Advise_When(ISignal`1<PropertyChangedEventArgs`1<TValue>> thіs, Lifetime lifetime, Func`2<TValue, bool> FFilter, Action`1<TValue> FHandler);
}
[ExtensionAttribute]
public static class JetBrains.DataFlow.IPropertySignalEx_ObsoleteWithoutLifetime : object {
    [ExtensionAttribute]
[NotNullAttribute]
[ObsoleteAttribute("Use overload with lifetime.")]
public static IDisposable Advise_FallingFront(ISignal`1<PropertyChangedEventArgs`1<TValue>> signal, Action handler);
    [ExtensionAttribute]
[NotNullAttribute]
[ObsoleteAttribute("Use overload with lifetime.")]
public static IDisposable Advise_FallingFront(ISignal`1<PropertyChangedEventArgs`1<TValue>> signal, Action`1<PropertyChangedEventArgs`1<TValue>> handler);
    [ExtensionAttribute]
[NotNullAttribute]
[ObsoleteAttribute("Use overload with lifetime.")]
public static IDisposable Advise_FallingFrontHasNew(ISignal`1<PropertyChangedEventArgs`1<bool>> signal, Action handler);
    [ExtensionAttribute]
[NotNullAttribute]
[ObsoleteAttribute("Use overload with lifetime.")]
public static IDisposable Advise_HasNew(ISignal`1<PropertyChangedEventArgs`1<TValue>> signal, Action`1<PropertyChangedEventArgs`1<TValue>> handler);
    [ExtensionAttribute]
[NotNullAttribute]
[ObsoleteAttribute("Use overload with lifetime.")]
public static IDisposable Advise_HasNew(ISignal`1<PropertyChangedEventArgs`1<TValue>> signal, Action handler);
    [ExtensionAttribute]
[NotNullAttribute]
[ObsoleteAttribute("Use overload with lifetime.")]
public static IDisposable Advise_NoAcknowledgement(ISignal`1<BeforePropertyChangedEventArgs`1<TValue>> signal, Action`1<BeforePropertyChangedEventArgs`1<TValue>> handler);
    [ExtensionAttribute]
[NotNullAttribute]
[ObsoleteAttribute("Use overload with lifetime.")]
public static IDisposable Advise_NoAcknowledgement(ISignal`1<PropertyChangedEventArgs`1<TValue>> signal, Action`1<PropertyChangedEventArgs`1<TValue>> handler);
    [ExtensionAttribute]
[NotNullAttribute]
[ObsoleteAttribute("Use overload with lifetime.")]
public static IDisposable Advise_NoAcknowledgement(ISignal`1<PropertyChangedEventArgs`1<TValue>> signal, Action handler);
    [ExtensionAttribute]
[NotNullAttribute]
[ObsoleteAttribute("Use overload with lifetime.")]
public static IDisposable Advise_NoAcknowledgement(ISignal`1<BeforePropertyChangedEventArgs`1<TValue>> signal, Action handler);
    [ExtensionAttribute]
[NotNullAttribute]
[ObsoleteAttribute("Use overload with lifetime.")]
public static IDisposable Advise_RaisingFront(ISignal`1<PropertyChangedEventArgs`1<TValue>> signal, Action handler);
    [ExtensionAttribute]
[NotNullAttribute]
[ObsoleteAttribute("Use overload with lifetime.")]
public static IDisposable Advise_RaisingFront(ISignal`1<PropertyChangedEventArgs`1<TValue>> signal, Action`1<PropertyChangedEventArgs`1<TValue>> handler);
    [ExtensionAttribute]
[NotNullAttribute]
[ObsoleteAttribute("Use overload with lifetime.")]
public static IDisposable Advise_When(ISignal`1<PropertyChangedEventArgs`1<TValue>> signal, Func`2<TValue, bool> filter, Action`1<TValue> handler);
}
public interface JetBrains.DataFlow.IReadonlyCollectionEvents`1 {
    public ISignal`1<AddRemoveEventArgs`1<TValue>> AddRemove { get; }
    [NotNullAttribute]
public PropertyId`1<TValue> Id { get; }
    public abstract virtual ISignal`1<AddRemoveEventArgs`1<TValue>> get_AddRemove();
    public abstract virtual PropertyId`1<TValue> get_Id();
    [NotNullAttribute]
public abstract virtual TValue[] ToArray();
    [NotNullAttribute]
public abstract virtual List`1<TValue> ToList();
}
public interface JetBrains.DataFlow.IReadonlyListEvents`1 {
    public ISignal`1<AddRemoveIndexEventArgs`1<TValue>> AddRemove { get; }
    public abstract virtual ISignal`1<AddRemoveIndexEventArgs`1<TValue>> get_AddRemove();
}
public interface JetBrains.DataFlow.ISignal`1 {
    [NotNullAttribute]
public PropertyId`1<TValue> Id { get; }
    [NotNullAttribute]
public IProperty`1<TValue> Property { get; }
    [NotNullAttribute]
public IUntypedSignal AsUntyped { get; }
    public abstract virtual PropertyId`1<TValue> get_Id();
    public abstract virtual IProperty`1<TValue> get_Property();
    public abstract virtual IUntypedSignal get_AsUntyped();
    public abstract virtual void Advise(Lifetime lifetime, Action`1<TValue> handler);
    public abstract virtual void Fire(TValue value);
    public abstract virtual void Fire(TValue value, object cookie);
}
[ExtensionAttribute]
public static class JetBrains.DataFlow.ISignalEx : object {
    private static ILogger Logger;
    private static ISignalEx();
    [ExtensionAttribute]
public static void Advise(ISignal`1<TValue> thіs, Lifetime lifetime, Action handler);
    [ExtensionAttribute]
public static void Advise_InOut(ISignal`1<InOutEventArgs`2<TIn, TOut>> thіs, Lifetime lifetime, Func`2<TIn, TOut> F);
    [ExtensionAttribute]
public static void Advise_Out(ISignal`1<OutEventArgs`1<TOut>> thіs, Lifetime lifetime, Func`1<TOut> F);
    [ExtensionAttribute]
public static TOut FireInOut(ISignal`1<InOutEventArgs`2<TIn, TOut>> thіs, TIn in, TOut outDefault);
    [ExtensionAttribute]
public static void BeginFire(ISimpleSignal thіs, Lifetime lifetime, JetDispatcher dispatcher);
    [ExtensionAttribute]
public static void BeginFire(ISignal`1<TValue> thіs, Lifetime lifetime, JetDispatcher dispatcher, TValue value);
    [ExtensionAttribute]
public static void BeginFire(ISignal`1<TValue> thіs, Lifetime lifetime, JetDispatcher dispatcher, TValue value, object cookie);
    [ExtensionAttribute]
public static TValue Fire(ISignal`1<OutEventArgs`1<TValue>> thіs);
    [ExtensionAttribute]
public static TOut FireInOut(ISignal`1<InOutEventArgs`2<TIn, TOut>> thіs, TIn in);
    [ExtensionAttribute]
public static void FlowDeferredInto(ISignal`1<TSource> source, Lifetime lifetime, ISimpleSignal target);
    [ExtensionAttribute]
public static void FlowInto(ISignal`1<TValue> source, Lifetime lifetime, ISimpleSignal target);
    [ExtensionAttribute]
public static void FlowInto(ISignal`1<TValue> source, Lifetime lifetime, ISignal`1<TValue> target);
    [ExtensionAttribute]
public static void FlowInto(ISignal`1<TSource> source, Lifetime lifetime, ISignal`1<TTarget> target, Func`2<TSource, TTarget> FConvert);
    [ExtensionAttribute]
public static void FlowInto(ISimpleSignal source, Lifetime lifetime, ISimpleSignal target);
    [ExtensionAttribute]
public static void LogFirings(ISignal`1<TValue> thіs, Lifetime lifetime, string prefix);
    private static void LogFirings_Advise(Lifetime lifetime, ISignal`1<TValue> signal, string prefix, ILogger logger, LoggingLevel level);
    [ExtensionAttribute]
public static void LogFirings(ISignal`1<TValue> thіs, Lifetime lifetime, object logprefix);
    [ExtensionAttribute]
public static void LogFirings(ISignal`1<TValue> thіs, Lifetime lifetime, ILogger logger);
    [ExtensionAttribute]
[NotNullAttribute]
public static Signal`1<TValue> LogFirings(Signal`1<TValue> thіs, ILogger logger);
    [ExtensionAttribute]
[NotNullAttribute]
public static SimpleSignal LogFirings(SimpleSignal thіs, ILogger logger);
}
[ExtensionAttribute]
public static class JetBrains.DataFlow.ISignalEx_ObsoleteWithoutLifetime : object {
    [ExtensionAttribute]
[NotNullAttribute]
[ObsoleteAttribute("Use overload with lifetime.")]
public static IDisposable Advise(ISignal`1<TValue> thіs, Action handler);
    [ExtensionAttribute]
[NotNullAttribute]
[ObsoleteAttribute("Use overload with lifetime.")]
public static IDisposable Advise_InOut(ISignal`1<InOutEventArgs`2<TIn, TOut>> signal, Func`2<TIn, TOut> F);
    [ExtensionAttribute]
[NotNullAttribute]
[ObsoleteAttribute("Use overload with lifetime.")]
public static IDisposable Advise(ISignal`1<TValue> thіs, Action`1<TValue> handler);
    [ExtensionAttribute]
[ObsoleteAttribute("Use overload with lifetime.")]
public static void BeginFire(ISimpleSignal signal, JetDispatcher dispatcher);
    [ExtensionAttribute]
[ObsoleteAttribute("Use overload with lifetime.")]
public static void BeginFire(ISignal`1<TValue> signal, JetDispatcher dispatcher, TValue value);
    [ExtensionAttribute]
[ObsoleteAttribute("Use overload with lifetime.")]
public static void BeginFire(ISignal`1<TValue> signal, JetDispatcher dispatcher, TValue value, object cookie);
    [ExtensionAttribute]
[NotNullAttribute]
[ObsoleteAttribute("Use overload with lifetime.")]
public static IDisposable FlowDeferredInto(ISignal`1<TSource> source, ISimpleSignal target);
    [ExtensionAttribute]
[NotNullAttribute]
[ObsoleteAttribute("Use overload with lifetime.")]
public static IDisposable FlowInto(ISignal`1<TValue> source, ISimpleSignal target);
    [ExtensionAttribute]
[NotNullAttribute]
[ObsoleteAttribute("Use overload with lifetime.")]
public static IDisposable FlowInto(ISignal`1<TValue> source, ISignal`1<TValue> target);
    [ExtensionAttribute]
[NotNullAttribute]
[ObsoleteAttribute("Use overload with lifetime.")]
public static IDisposable FlowInto(ISignal`1<TSource> source, ISignal`1<TTarget> target, Func`2<TSource, TTarget> converter);
    [ExtensionAttribute]
[NotNullAttribute]
[ObsoleteAttribute("Use overload with lifetime.")]
public static IDisposable FlowInto(ISimpleSignal source, ISimpleSignal target);
}
public interface JetBrains.DataFlow.ISimpleSignal {
    public abstract virtual void Fire();
}
public interface JetBrains.DataFlow.IUntypedProperty {
    public IUntypedSignal BeforeChange { get; }
    public IUntypedSignal Change { get; }
    [NotNullAttribute]
public PropertyId Id { get; }
    public bool IsNullValueAllowed { get; }
    [NotNullAttribute]
public Type PropertyType { get; }
    public object AsTyped { get; }
    public abstract virtual IUntypedSignal get_BeforeChange();
    public abstract virtual IUntypedSignal get_Change();
    public abstract virtual PropertyId get_Id();
    public abstract virtual bool get_IsNullValueAllowed();
    public abstract virtual Type get_PropertyType();
    public abstract virtual object get_AsTyped();
    public abstract virtual object GetValue(object cookie);
    public abstract virtual bool SetValue(object value, object cookie);
    [CompilerGeneratedAttribute]
public abstract virtual void add_Disposed(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Disposed(EventHandler value);
}
public interface JetBrains.DataFlow.IUntypedPropertyBag {
    [NotNullAttribute]
public IDictionaryEvents`2<PropertyId, IUntypedProperty> Properties { get; }
    public abstract virtual IDictionaryEvents`2<PropertyId, IUntypedProperty> get_Properties();
    public abstract virtual bool Contains(PropertyId id);
    [CanBeNullAttribute]
public abstract virtual object Get(PropertyId id);
    [NotNullAttribute]
public abstract virtual IUntypedProperty GetOrCreateProperty(PropertyId id, object defaultvalue, Nullable`1<bool> isNullValueAllowed);
    public abstract virtual bool Remove(PropertyId id);
    public abstract virtual void Set(PropertyId id, object value);
    public abstract virtual bool TryGet(PropertyId id, Object& value);
    [CanBeNullAttribute]
public abstract virtual object TryGet(PropertyId id);
}
public interface JetBrains.DataFlow.IUntypedSignal {
    [NotNullAttribute]
public PropertyId Id { get; }
    [NotNullAttribute]
public IUntypedProperty Property { get; }
    [NotNullAttribute]
public Type ArgumentType { get; }
    public abstract virtual PropertyId get_Id();
    public abstract virtual IUntypedProperty get_Property();
    public abstract virtual Type get_ArgumentType();
    public abstract virtual void Advise(Lifetime lifetime, Action`1<object> handler);
    public abstract virtual void Fire(object value, object cookie);
}
public interface JetBrains.DataFlow.IViewable`1 {
    public abstract virtual void View(Lifetime lifetime, Action`2<Lifetime, TValue> viewer);
}
[ExtensionAttribute]
public static class JetBrains.DataFlow.LifetimeEx : object {
    public static ILogger Logger;
    private static LifetimeEx();
    [ExtensionAttribute]
public static Lifetime OrIfEternal(Lifetime me, Lifetime other);
    [ExtensionAttribute]
public static Lifetime AddDispose(Lifetime thіs, IDisposable[] items);
    [ExtensionAttribute]
[NotNullAttribute]
public static LifetimeDefinition EnsureEverTerminated_SingleThreaded(LifetimeDefinition thіs, string identity, bool saveCtorCallStack);
    [ExtensionAttribute]
[NotNullAttribute]
public static LifetimeDefinition EnsureEverTerminated_FreeThreaded(LifetimeDefinition def, string identity, bool saveCtorCallStack);
    [ExtensionAttribute]
public static void AssertIsAlive(OuterLifetime thіs);
    [ExtensionAttribute]
public static void LogAssertIsAlive(OuterLifetime thіs);
    [ExtensionAttribute]
public static void AssertIsAlive(Lifetime thіs);
    [ExtensionAttribute]
public static void LogAssertIsAlive(Lifetime thіs);
    [ExtensionAttribute]
public static void AssertIsAlive(LifetimeDefinition thіs);
    [ExtensionAttribute]
public static void LogAssertIsAlive(LifetimeDefinition thіs);
    [ExtensionAttribute]
public static Lifetime EnsureGuarded(Lifetime thіs, ReentrancyGuard guard);
    [ExtensionAttribute]
public static object Id(OuterLifetime thіs);
}
public static class JetBrains.DataFlow.LifetimesObsolete : object {
    [ObsoleteAttribute("Use Define() or Using(), or even better get your lifetime from your owner.")]
public static ObsoleteLifetimeAndDefinitionAtTheSameTime Create(bool finalize);
    [DebuggerStepThroughAttribute]
[ObsoleteAttribute("Specify explicitly whether you'd like to assert that this lifetime is ever terminated. In most cases, this overload was used by mistake. Use Define().")]
public static ObsoleteLifetimeAndDefinitionAtTheSameTime Create(string id);
    [ObsoleteAttribute("Use Define() or Using(), or even better get your lifetime from your owner.")]
public static ObsoleteLifetimeAndDefinitionAtTheSameTime Create();
    [DebuggerStepThroughAttribute]
[ObsoleteAttribute("Use Define(), or even better get your lifetime from your owner. If you would like to assert termination, call EnsureEverTerminated on the lifetime.")]
public static ObsoleteLifetimeAndDefinitionAtTheSameTime Create(string id, bool finalize);
    [NotNullAttribute]
[ObsoleteAttribute("Use Define().")]
public static ObsoleteLifetimeAndDefinitionAtTheSameTime CreateAtomic(Action`1<Lifetime> FAtomic);
}
[ExtensionAttribute]
public static class JetBrains.DataFlow.ListBridge : object {
    [ExtensionAttribute]
public static ListBridge`2<TSource, TTarget> BridgeInto(IListEvents`1<TSource> source, Lifetime lifetime, IListEvents`1<TTarget> target, Func`2<TSource, TTarget> funcConverter, Func`2<TSource, bool> funcFilter, MappingInfo mappinginfo, object cookie);
}
public class JetBrains.DataFlow.ListBridge`2 : object {
    [NotNullAttribute]
private Func`2<TSource, TTarget> myFuncConverter;
    [NotNullAttribute]
private Func`2<TSource, bool> myFuncFilter;
    [NotNullAttribute]
private List`1<int> myIndexMapping;
    private BidirectionalMapOnDictionary`2<TSource, TTarget> myMapItems;
    [NotNullAttribute]
private IListEvents`1<TSource> mySource;
    [NotNullAttribute]
private IListEvents`1<TTarget> myTarget;
    [CanBeNullAttribute]
private object myTargetModificationCookie;
    public bool HaveMappingInfo { get; }
    [NotNullAttribute]
public IDictionary`2<TSource, TTarget> MapSourceToTarget { get; }
    [NotNullAttribute]
public IDictionary`2<TTarget, TSource> MapTargetToSource { get; }
    [NotNullAttribute]
public IListEvents`1<TSource> Source { get; }
    [NotNullAttribute]
public IListEvents`1<TTarget> Target { get; }
    public ListBridge`2(Lifetime lifetime, IListEvents`1<TSource> source, IListEvents`1<TTarget> target, Func`2<TSource, TTarget> funcConverter, Func`2<TSource, bool> funcFilter, MappingInfo mappinginfo, object oTaregtModificationCookie);
    public bool get_HaveMappingInfo();
    public IDictionary`2<TSource, TTarget> get_MapSourceToTarget();
    public IDictionary`2<TTarget, TSource> get_MapTargetToSource();
    public IListEvents`1<TSource> get_Source();
    public IListEvents`1<TTarget> get_Target();
    private void Init(Lifetime lifetime);
    [CompilerGeneratedAttribute]
private void <Init>b__18_2(AddRemoveIndexEventArgs`1<TTarget> args);
    [CompilerGeneratedAttribute]
private void <Init>b__18_3(AddRemoveIndexEventArgs`1<TSource> args);
    [CompilerGeneratedAttribute]
private void <Init>b__18_4(AddRemoveIndexEventArgs`1<TSource> args);
}
[DebuggerStepThroughAttribute]
public static class JetBrains.DataFlow.ManualProperty : object {
    [NotNullAttribute]
public static IProperty`1<TValue> Create(string id, Action`1<TValue> setter);
    [NotNullAttribute]
public static IProperty`1<TValue> Create(Lifetime lifetime, string id, Action`1<TValue> setter);
    [NotNullAttribute]
public static IProperty`1<TValue> Create(string id, TValue initialvalue, Action`1<TValue> setter);
    [NotNullAttribute]
public static IProperty`1<TValue> Create(Lifetime lifetime, string id, TValue initialvalue, Action`1<TValue> setter);
    [NotNullAttribute]
public static IProperty`1<TValue> Create(string id, Func`1<TValue> getter, Action`1<TValue> setter);
    [NotNullAttribute]
public static IProperty`1<TValue> Create(Lifetime lifetime, string id, Func`1<TValue> getter, Action`1<TValue> setter);
}
public enum JetBrains.DataFlow.MarshallingBehaviors : Enum {
    public int value__;
    public static MarshallingBehaviors QueueAlways;
    public static MarshallingBehaviors QueueIfNeeded;
}
[DebuggerStepThroughAttribute]
public class JetBrains.DataFlow.MarshallingPropertyBinding`2 : PropertyBinding`2<TSource, TTarget> {
    [NotNullAttribute]
private JetDispatcher myDispatcher;
    private bool myFreeze;
    private MarshallingBehaviors myMarshallingBehavior;
    [NotNullAttribute]
public JetDispatcher Dispatcher { get; }
    public MarshallingBehaviors MarshallingBehavior { get; public set; }
    public MarshallingPropertyBinding`2(Lifetime lifetime, JetDispatcher dispatcher, IProperty`1<TSource> source, IProperty`1<TTarget> target, DataFlowDirection direction, Func`2<TSource, TTarget> delegateSourceToTarget, Func`2<TTarget, TSource> delegateTargetToSource);
    public MarshallingPropertyBinding`2(Lifetime lifetime, JetDispatcher dispatcher, IProperty`1<TSource> source, IProperty`1<TTarget> target, DataFlowDirection direction);
    public MarshallingPropertyBinding`2(Lifetime lifetime, JetDispatcher dispatcher, IProperty`1<TSource> source, IProperty`1<TTarget> target, Func`2<TSource, TTarget> delegateSourceToTarget, Func`2<TTarget, TSource> delegateTargetToSource);
    public MarshallingPropertyBinding`2(Lifetime lifetime, JetDispatcher dispatcher, IProperty`1<TSource> source, IProperty`1<TTarget> target, Func`2<TSource, TTarget> delegateSourceToTarget);
    public JetDispatcher get_Dispatcher();
    public MarshallingBehaviors get_MarshallingBehavior();
    public void set_MarshallingBehavior(MarshallingBehaviors value);
    public virtual void CopySourceToTarget();
    public virtual void CopyTargetToSource();
}
public class JetBrains.DataFlow.NullProperty`1 : object {
    [NotNullAttribute]
public static IProperty`1<TValue> Instance;
    private static NullProperty`1();
}
[DebuggerStepThroughAttribute]
[ObsoleteAttribute("Lifetime and LifetimeDefinition are now separated.")]
public class JetBrains.DataFlow.ObsoleteLifetimeAndDefinitionAtTheSameTime : object {
    public Lifetime Lifetime;
    public LifetimeDefinition LifetimeDefinition;
    public bool IsEmpty { get; }
    public bool IsTerminated { get; }
    public ObsoleteLifetimeAndDefinitionAtTheSameTime(LifetimeDefinition lifetimeDefinition);
    public bool get_IsEmpty();
    [NotNullAttribute]
public Lifetime AddDispose(IDisposable item);
    [NotNullAttribute]
public Lifetime AddAction(Action action);
    [NotNullAttribute]
public Lifetime AddBracket(Action opening, Action closing);
    public Lifetime AddRef(object object);
    public void Terminate();
    public sealed virtual void Dispose();
    public bool get_IsTerminated();
    public static Lifetime op_Implicit(ObsoleteLifetimeAndDefinitionAtTheSameTime compound);
    public static LifetimeDefinition op_Implicit(ObsoleteLifetimeAndDefinitionAtTheSameTime compound);
    public static ObsoleteLifetimeAndDefinitionAtTheSameTime op_Explicit(LifetimeDefinition definition);
    [ObsoleteAttribute("Pass lifetime to function instead of disposing of its result. If you really have to, use AddDispose().")]
public Lifetime Add(IDisposable[] disposables);
}
[ExtensionAttribute]
public static class JetBrains.DataFlow.ObsoleteLifetimeEx : object {
    [ExtensionAttribute]
[NotNullAttribute]
[ObsoleteAttribute("Use Lifetime.Define passing the outer lifetime as a parent lifetime.")]
public static ObsoleteLifetimeAndDefinitionAtTheSameTime OpenNested(Lifetime thіs);
}
[DebuggerStepThroughAttribute]
public class JetBrains.DataFlow.OutEventArgs`1 : EventArgs {
    [CompilerGeneratedAttribute]
private TOut <Out>k__BackingField;
    public TOut Out { get; public set; }
    public OutEventArgs`1(TOut out);
    [CompilerGeneratedAttribute]
public TOut get_Out();
    [CompilerGeneratedAttribute]
public void set_Out(TOut value);
}
[DebuggerStepThroughAttribute]
[DefaultPropertyAttribute("Value")]
public class JetBrains.DataFlow.Property`1 : object {
    private List`1<EventHandler> myHandlersDisposed;
    [NotNullAttribute]
private PropertyId`1<TValue> myId;
    private bool myIsNullValueAllowed;
    private ILogger myLogger;
    private SpinWaitLock myLock;
    [NotNullAttribute]
private PropertyBeforeChangeSignal<TValue> mySignalBeforeChange;
    [NotNullAttribute]
private PropertyChangeSignal<TValue> mySignalChange;
    private TValue myValue;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Nullable`1<ValueTuple`2<Func`4<Func`3<TValue, object, bool>, TValue, object, bool>, Func`3<TValue, object, bool>>> CallStackAnnotationForSetValue;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    [CompilerGeneratedAttribute]
private PropertyChangingEventHandler PropertyChanging;
    public ISignal`1<BeforePropertyChangedEventArgs`1<TValue>> BeforeChange { get; }
    [NotNullAttribute]
public ISignal`1<PropertyChangedEventArgs`1<TValue>> Change { get; }
    public PropertyId`1<TValue> Id { get; }
    public bool IsNullValueAllowed { get; }
    public TValue Value { get; public set; }
    private IUntypedSignal JetBrains.DataFlow.IUntypedProperty.BeforeChange { get; }
    private IUntypedSignal JetBrains.DataFlow.IUntypedProperty.Change { get; }
    private PropertyId JetBrains.DataFlow.IUntypedProperty.Id { get; }
    private Type JetBrains.DataFlow.IUntypedProperty.PropertyType { get; }
    private IUntypedProperty JetBrains.DataFlow.IHaveUntypedProperty.AsUntyped { get; }
    private object JetBrains.DataFlow.IUntypedProperty.AsTyped { get; }
    [DebuggerStepThroughAttribute]
public Property`1(string id);
    [DebuggerStepThroughAttribute]
[ObsoleteAttribute("Use overloads without lifetime.")]
[EditorBrowsableAttribute("1")]
public Property`1(Lifetime lifetime, string id);
    [DebuggerStepThroughAttribute]
public Property`1(PropertyId`1<TValue> id, TValue value);
    [DebuggerStepThroughAttribute]
public Property`1(string id, TValue value);
    [DebuggerStepThroughAttribute]
[ObsoleteAttribute("Use overloads without lifetime.")]
[EditorBrowsableAttribute("1")]
public Property`1(Lifetime lifetime, string id, TValue value);
    [DebuggerStepThroughAttribute]
[ObsoleteAttribute("Use overloads without lifetime.")]
[EditorBrowsableAttribute("1")]
public Property`1(Lifetime lifetime, PropertyId`1<TValue> id, TValue value, Nullable`1<bool> isNullValueAllowed, ILogger logger);
    [DebuggerStepThroughAttribute]
public Property`1(PropertyId`1<TValue> id, TValue value, Nullable`1<bool> isNullValueAllowed, ILogger logger);
    [DebuggerStepThroughAttribute]
public static TValue op_Explicit(Property`1<TValue> property);
    internal static void ThrowReadonlyFail(BeforePropertyChangedEventArgs`1<TValue> args, object tokenExpected);
    internal static void ThrowThreadAffinityFail(BeforePropertyChangedEventArgs`1<TValue> args, Thread threadExpected);
    [DebuggerStepThroughAttribute]
private bool FireBeforeChange(TValue old, TValue new, object cookie);
    [DebuggerStepThroughAttribute]
private void FireChange(TValue old, TValue new, object cookie);
    [DebuggerStepThroughAttribute]
private void FireDisposed();
    [DebuggerStepThroughAttribute]
private void FirePropertyChanged();
    [DebuggerStepThroughAttribute]
private void FirePropertyChanging();
    [DebuggerStepThroughAttribute]
public virtual string ToString();
    [DebuggerStepThroughAttribute]
public sealed virtual object Clone();
    [DebuggerStepThroughAttribute]
public sealed virtual void add_Disposed(EventHandler value);
    [DebuggerStepThroughAttribute]
public sealed virtual void remove_Disposed(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanging(PropertyChangingEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanging(PropertyChangingEventHandler value);
    [DebuggerStepThroughAttribute]
[ObsoleteAttribute("Pass in a lifetime; will be made non-idisposable.")]
private sealed virtual override void System.IDisposable.Dispose();
    [DebuggerStepThroughAttribute]
public sealed virtual TValue GetValue();
    [DebuggerStepThroughAttribute]
public sealed virtual TValue GetValue(object cookie);
    [DebuggerStepThroughAttribute]
public sealed virtual bool SetValue(TValue value);
    [DebuggerStepThroughAttribute]
public sealed virtual bool SetValue(TValue value, object cookie);
    private ValueTuple`2<Func`4<Func`3<TValue, object, bool>, TValue, object, bool>, Func`3<TValue, object, bool>> InitCallStackAnnotationForSetValue();
    private bool SetValueInternal(TValue value, object cookie);
    [DebuggerStepThroughAttribute]
private sealed virtual override object JetBrains.DataFlow.IUntypedProperty.GetValue(object cookie);
    [DebuggerStepThroughAttribute]
private sealed virtual override bool JetBrains.DataFlow.IUntypedProperty.SetValue(object value, object cookie);
    [DebuggerStepThroughAttribute]
public sealed virtual ISignal`1<BeforePropertyChangedEventArgs`1<TValue>> get_BeforeChange();
    [DebuggerStepThroughAttribute]
public sealed virtual ISignal`1<PropertyChangedEventArgs`1<TValue>> get_Change();
    [DebuggerStepThroughAttribute]
public sealed virtual PropertyId`1<TValue> get_Id();
    [DebuggerStepThroughAttribute]
public sealed virtual bool get_IsNullValueAllowed();
    [DebuggerStepThroughAttribute]
public sealed virtual TValue get_Value();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Value(TValue value);
    [DebuggerStepThroughAttribute]
private sealed virtual override IUntypedSignal JetBrains.DataFlow.IUntypedProperty.get_BeforeChange();
    [DebuggerStepThroughAttribute]
private sealed virtual override IUntypedSignal JetBrains.DataFlow.IUntypedProperty.get_Change();
    [DebuggerStepThroughAttribute]
private sealed virtual override PropertyId JetBrains.DataFlow.IUntypedProperty.get_Id();
    [DebuggerStepThroughAttribute]
private sealed virtual override Type JetBrains.DataFlow.IUntypedProperty.get_PropertyType();
    private sealed virtual override IUntypedProperty JetBrains.DataFlow.IHaveUntypedProperty.get_AsUntyped();
    private sealed virtual override object JetBrains.DataFlow.IUntypedProperty.get_AsTyped();
}
[DebuggerStepThroughAttribute]
public class JetBrains.DataFlow.PropertyBag : object {
    protected IDictionaryEvents`2<PropertyId, IUntypedProperty> myProperties;
    protected ILogger myLogger;
    public IDictionaryEvents`2<PropertyId, IUntypedProperty> Properties { get; }
    private IUntypedPropertyBag JetBrains.DataFlow.IPropertyBag.AsUntyped { get; }
    public PropertyBag(ILogger logger);
    [ObsoleteAttribute("Use overload without lifetime.")]
public PropertyBag(Lifetime lifetime, ILogger logger);
    protected PropertyBag(IDictionaryEvents`2<PropertyId, IUntypedProperty> propstorage, ILogger logger);
    [NotNullAttribute]
protected virtual IUntypedProperty CreatePropertyInstance(PropertyId`1<TValue> id, TValue defaultvalue, Nullable`1<bool> isNullValueAllowed);
    public sealed virtual bool Contains(PropertyId`1<T> id);
    public sealed virtual T Get(PropertyId`1<T> id);
    public sealed virtual IProperty`1<T> GetOrCreateProperty(PropertyId`1<T> id, T defaultvalue, Nullable`1<bool> isNullValueAllowed);
    public sealed virtual IProperty`1<T> GetProperty(PropertyId`1<T> id);
    public sealed virtual bool Remove(PropertyId`1<T> id);
    private sealed virtual override bool JetBrains.DataFlow.IUntypedPropertyBag.Remove(PropertyId id);
    public sealed virtual void Set(PropertyId`1<T> id, T value);
    public sealed virtual bool TryGet(PropertyId`1<T> id, T& value);
    public sealed virtual T TryGet(PropertyId`1<T> id);
    private sealed virtual override bool JetBrains.DataFlow.IUntypedPropertyBag.Contains(PropertyId id);
    private sealed virtual override object JetBrains.DataFlow.IUntypedPropertyBag.Get(PropertyId id);
    private sealed virtual override IUntypedProperty JetBrains.DataFlow.IUntypedPropertyBag.GetOrCreateProperty(PropertyId id, object defaultvalue, Nullable`1<bool> isNullValueAllowed);
    private sealed virtual override void JetBrains.DataFlow.IUntypedPropertyBag.Set(PropertyId id, object value);
    private sealed virtual override object JetBrains.DataFlow.IUntypedPropertyBag.TryGet(PropertyId id);
    private sealed virtual override bool JetBrains.DataFlow.IUntypedPropertyBag.TryGet(PropertyId id, Object& value);
    public sealed virtual IDictionaryEvents`2<PropertyId, IUntypedProperty> get_Properties();
    private sealed virtual override IUntypedPropertyBag JetBrains.DataFlow.IPropertyBag.get_AsUntyped();
}
[ExtensionAttribute]
public static class JetBrains.DataFlow.PropertyBinding : object {
    public static Property`1<bool> False;
    public static Property`1<bool> True;
    public static Property`1<int> Zero;
    private static PropertyBinding();
    [NotNullAttribute]
public static PropertyBinding`2<TSource, TTarget> CreateBidirectional(Lifetime lifetime, IProperty`1<TSource> source, IProperty`1<TTarget> target, Func`2<TSource, TTarget> FConvertSourceToTarget, Func`2<TTarget, TSource> FConvertTargetToSource);
    [NotNullAttribute]
[ObsoleteAttribute("For from-source bindings, use source.FlowInto(target). For others, use overload with lifetime.")]
public static PropertyBinding`2<TSource, TTarget> CreateBidirectional(IProperty`1<TSource> source, IProperty`1<TTarget> target);
    public static PropertyBinding`2<TSource, TTarget> CreateBidirectional(Lifetime lifetime, IProperty`1<TSource> source, IProperty`1<TTarget> target);
    public static void CreateOneWayToSource(Lifetime lifetime, IProperty`1<TSource> source, IProperty`1<TTarget> target, Func`2<TTarget, TSource> FConvertTargetToSource);
    public static void CreateOneWayToSource(Lifetime lifetime, IProperty`1<TSource> source, IProperty`1<TTarget> target);
    public static void Create2(Lifetime lifetime, IProperty`1<TSource1> source1, IProperty`1<TSource2> source2, IProperty`1<TTarget> target, Func`3<TSource1, TSource2, TTarget> FConvert, object token);
    public static void Create3(Lifetime lifetime, IProperty`1<TSource1> source1, IProperty`1<TSource2> source2, IProperty`1<TSource3> source3, IProperty`1<TTarget> target, Func`4<TSource1, TSource2, TSource3, TTarget> FConvert, object token);
    public static void Create4(Lifetime lifetime, IProperty`1<TSource1> source1, IProperty`1<TSource2> source2, IProperty`1<TSource3> source3, IProperty`1<TSource4> source4, IProperty`1<TTarget> target, Func`5<TSource1, TSource2, TSource3, TSource4, TTarget> FConvert, object token);
    [NotNullAttribute]
[ObsoleteAttribute("Use “And” ext method.")]
public static IProperty`1<bool> CreateAnd(IProperty`1<bool> srcA, IProperty`1<bool> srcB);
    [NotNullAttribute]
[ObsoleteAttribute("Can use overload without lifetime, extension method “And”. Lifetimes automatically by the scope of anyone sinking the new property.")]
public static IProperty`1<bool> CreateAnd(Lifetime lifetime, IProperty`1<bool> srcA, IProperty`1<bool> srcB, string name);
    [ExtensionAttribute]
[NotNullAttribute]
public static IProperty`1<bool> And(IProperty`1<bool> srcA, IProperty`1<bool> srcB);
    public static void CreateAndMultibinding(Lifetime lifetime, IProperty`1<bool> srcA, IProperty`1<bool> srcB, IProperty`1<bool> dst);
    public static void CreateCascading(Lifetime lifetime, IProperty`1<TSourceOwner> sourceowner, Func`2<TSourceOwner, IProperty`1<TSource>> FGetSourceFromOwner, IProperty`1<TSource> propSourceWhenNoOwner, IProperty`1<TTarget> target, DataFlowDirection direction);
    [ExtensionAttribute]
[NotNullAttribute]
public static IProperty`1<bool> CreateIsNotNull(IProperty`1<T> source, Lifetime lifetime);
    [ExtensionAttribute]
[NotNullAttribute]
public static IProperty`1<bool> CreateIsNull(IProperty`1<T> source, Lifetime lifetime);
    [ExtensionAttribute]
[NotNullAttribute]
[ObsoleteAttribute("Use “Not”, which has an automatic lifetime.")]
public static IProperty`1<bool> CreateNot(IProperty`1<bool> source, Lifetime lifetime, string name);
    [ExtensionAttribute]
[NotNullAttribute]
public static IProperty`1<bool> Not(IProperty`1<bool> source);
    [NotNullAttribute]
[ObsoleteAttribute("Can use overload without lifetime, extension method “Or”. Lifetimes automatically by the scope of anyone sinking the new property.")]
public static IProperty`1<bool> CreateOr(Lifetime _, IProperty`1<bool> srcA, IProperty`1<bool> srcB);
    [ExtensionAttribute]
[NotNullAttribute]
public static IProperty`1<bool> Or(IProperty`1<bool> srcA, IProperty`1<bool> srcB);
    public static void CreateOrMultibinding(Lifetime lifetime, IProperty`1<bool> srcA, IProperty`1<bool> srcB, IProperty`1<bool> dst);
    [NotNullAttribute]
public static IProperty`1<TValue> Null();
}
[DebuggerStepThroughAttribute]
public class JetBrains.DataFlow.PropertyBinding`2 : object {
    [NotNullAttribute]
protected Func`2<TSource, TTarget> myConverterSourceToTarget;
    [NotNullAttribute]
protected Func`2<TTarget, TSource> myConverterTargetToSource;
    [NotNullAttribute]
protected Property`1<DataFlowDirection> myDirection;
    [NotNullAttribute]
protected Property`1<IProperty`1<TSource>> mySource;
    [CanBeNullAttribute]
protected object mySourceCookie;
    [NotNullAttribute]
protected Property`1<IProperty`1<TTarget>> myTarget;
    [CanBeNullAttribute]
protected object myTargetCookie;
    private int myFreeze;
    [CompilerGeneratedAttribute]
private object <Tag>k__BackingField;
    [CanBeNullAttribute]
public object SourceCookie { get; public set; }
    public object Tag { get; public set; }
    [CanBeNullAttribute]
public object TargetCookie { get; public set; }
    public DataFlowDirection Direction { get; public set; }
    public IProperty`1<IProperty`1<TSource>> Source { get; }
    public IProperty`1<IProperty`1<TTarget>> Target { get; }
    private IUntypedProperty JetBrains.DataFlow.IPropertyBinding.Source { get; }
    private IUntypedProperty JetBrains.DataFlow.IPropertyBinding.Target { get; }
    private IPropertyBinding JetBrains.DataFlow.IPropertyBinding<TSource,TTarget>.AsUntyped { get; }
    public PropertyBinding`2(Lifetime lifetime, IProperty`1<TSource> source, IProperty`1<TTarget> target, Func`2<TSource, TTarget> delegateSourceToTarget);
    public PropertyBinding`2(Lifetime lifetime, IProperty`1<TSource> source, IProperty`1<TTarget> target, Func`2<TSource, TTarget> delegateSourceToTarget, Func`2<TTarget, TSource> delegateTargetToSource);
    public PropertyBinding`2(Lifetime lifetime, IProperty`1<TSource> source, IProperty`1<TTarget> target, DataFlowDirection direction);
    public PropertyBinding`2(Lifetime lifetime, IProperty`1<TSource> source, IProperty`1<TTarget> target, DataFlowDirection direction, Func`2<TSource, TTarget> delegateSourceToTarget, Func`2<TTarget, TSource> delegateTargetToSource);
    public PropertyBinding`2(Lifetime lifetime, IProperty`1<TSource> source, IProperty`1<TTarget> target, DataFlowDirection direction, Func`2<TSource, TTarget> delegateSourceToTarget, Func`2<TTarget, TSource> delegateTargetToSource, object oSourceCookie, object oTargetCookie);
    public object get_SourceCookie();
    public void set_SourceCookie(object value);
    [CompilerGeneratedAttribute]
public object get_Tag();
    [CompilerGeneratedAttribute]
public void set_Tag(object value);
    public object get_TargetCookie();
    public void set_TargetCookie(object value);
    private static TTarget OnConvertSourceToTargetDefault(TSource value);
    private static TSource OnConvertTargetToSourceDefault(TTarget value);
    private void Clear();
    private void InitDataFlow(Lifetime lifetimeGlobal);
    private void OnSourceValueChanged(PropertyChangedEventArgs`1<TSource> args);
    private void OnTargetValueChanged(PropertyChangedEventArgs`1<TTarget> args);
    public virtual void CopySourceToTarget();
    public virtual void CopyTargetToSource();
    public sealed virtual DataFlowDirection get_Direction();
    public void set_Direction(DataFlowDirection value);
    public sealed virtual IProperty`1<IProperty`1<TSource>> get_Source();
    public sealed virtual IProperty`1<IProperty`1<TTarget>> get_Target();
    private sealed virtual override IUntypedProperty JetBrains.DataFlow.IPropertyBinding.get_Source();
    private sealed virtual override IUntypedProperty JetBrains.DataFlow.IPropertyBinding.get_Target();
    private sealed virtual override IPropertyBinding JetBrains.DataFlow.IPropertyBinding<TSource,TTarget>.get_AsUntyped();
    [CompilerGeneratedAttribute]
private void <.ctor>b__12_0();
    [CompilerGeneratedAttribute]
private void <.ctor>b__12_1();
    [CompilerGeneratedAttribute]
private void <InitDataFlow>b__26_0(Lifetime lifetime, IProperty`1<TSource> value);
    [CompilerGeneratedAttribute]
private void <InitDataFlow>b__26_1(Lifetime lifetime, IProperty`1<TTarget> value);
    [CompilerGeneratedAttribute]
private void <InitDataFlow>b__26_2(PropertyChangedEventArgs`1<DataFlowDirection> args);
}
[DebuggerStepThroughAttribute]
public class JetBrains.DataFlow.PropertyBindingDeferred`1 : object {
    private ReadonlyToken myReadonlyCookie;
    private IProperty`1<TValue> mySource;
    private IProperty`1<TValue> myTarget;
    private object myTargetCookie;
    private WeakTimer myTimer;
    public Property`1<TimeSpan> GracePeriod;
    public ISimpleSignal IncomingCommit;
    public Property`1<bool> IsPending;
    public IProperty`1<TValue> Source { get; }
    public IProperty`1<TValue> Target { get; }
    public PropertyBindingDeferred`1(Lifetime lifetime, IProperty`1<TValue> source, IProperty`1<TValue> target, TimeSpan graceperiod, object targetcookie);
    public IProperty`1<TValue> get_Source();
    public IProperty`1<TValue> get_Target();
    private void InitDataFlow(Lifetime lifetime);
}
[DebuggerStepThroughAttribute]
public class JetBrains.DataFlow.PropertyChangedEventArgs`1 : EventArgs {
    private TValue myNew;
    private TValue myOld;
    [CompilerGeneratedAttribute]
private object <Cookie>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasNew>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasOld>k__BackingField;
    [CompilerGeneratedAttribute]
private IProperty`1<TValue> <Property>k__BackingField;
    [CanBeNullAttribute]
public object Cookie { get; }
    public bool HasNew { get; }
    public bool HasOld { get; }
    public bool IsAcknowledging { get; }
    public TValue New { get; }
    public TValue Old { get; }
    [NotNullAttribute]
public IProperty`1<TValue> Property { get; }
    protected PropertyChangedEventArgs`1(IProperty`1<TValue> property, TValue old, bool hasold, TValue new, bool hasnew, object cookie);
    [CompilerGeneratedAttribute]
public object get_Cookie();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_HasNew();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_HasOld();
    public bool get_IsAcknowledging();
    public TValue get_New();
    public TValue get_Old();
    [CompilerGeneratedAttribute]
public IProperty`1<TValue> get_Property();
    [NotNullAttribute]
[PureAttribute]
public static PropertyChangedEventArgs`1<TValue> CreateBoth(IProperty`1<TValue> property, TValue old, TValue new, object cookie);
    [NotNullAttribute]
[PureAttribute]
public static PropertyChangedEventArgs`1<TValue> CreateNew(IProperty`1<TValue> property, TValue new, object cookie);
    [NotNullAttribute]
[PureAttribute]
public static PropertyChangedEventArgs`1<TValue> CreateOld(IProperty`1<TValue> property, TValue old, object cookie);
}
[ExtensionAttribute]
public static class JetBrains.DataFlow.PropertyChangeEventArgsEx : object {
    [ExtensionAttribute]
public static TValue GetNewOrNull(PropertyChangedEventArgs`1<TValue> args);
    [ExtensionAttribute]
public static TValue GetOldOrNull(PropertyChangedEventArgs`1<TValue> args);
    [ExtensionAttribute]
public static bool IsRaising(PropertyChangedEventArgs`1<bool> args);
}
[DebuggerStepThroughAttribute]
public abstract class JetBrains.DataFlow.PropertyId : object {
    [NotNullAttribute]
public string Id { get; }
    public abstract virtual string get_Id();
    public static PropertyId`1<TValue> Create(string id);
}
[DebuggerStepThroughAttribute]
public class JetBrains.DataFlow.PropertyId`1 : PropertyId {
    [NotNullAttribute]
private string myId;
    [NotNullAttribute]
public string Id { get; }
    public PropertyId`1(string id);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public virtual string get_Id();
    public sealed virtual bool Equals(PropertyId`1<TValue> propertyId);
    public static string op_Implicit(PropertyId`1<TValue> propid);
    public static PropertyId`1<TValue> op_Implicit(string text);
}
public class JetBrains.DataFlow.PropertyValidationException : ValidationException {
    private IUntypedProperty myProperty;
    private object myValue;
    [NotNullAttribute]
public IUntypedProperty Property { get; }
    [CanBeNullAttribute]
public object Value { get; }
    public PropertyValidationException(IUntypedProperty property, object value, string message);
    public IUntypedProperty get_Property();
    public object get_Value();
}
[ExtensionAttribute]
public static class JetBrains.DataFlow.PropertyValidator : object {
    [ExtensionAttribute]
public static void CreateEnumValidator(IProperty`1<TValue> thіs, Lifetime lifetime);
    [ExtensionAttribute]
public static void CreateMaximumValidator(IProperty`1<TValue> thіs, Lifetime lifetime, TValue max);
    [ExtensionAttribute]
public static void CreateMinimumValidator(IProperty`1<TValue> thіs, Lifetime lifetime, TValue min);
    [ExtensionAttribute]
public static void CreateNotEmptyValidator(IProperty`1<string> thіs, Lifetime lifetime);
    [ExtensionAttribute]
public static void CreateReadonlyValidator(IProperty`1<TValue> thіs, Lifetime lifetime, ReadonlyToken token);
    [ExtensionAttribute]
public static void CreateThreadAffinityValidator(IProperty`1<TValue> thіs, Lifetime lifetime, Thread thread);
    [ExtensionAttribute]
public static void CreateThreadAffinityValidator(IProperty`1<TValue> thіs, Lifetime lifetime, JetDispatcher dispatcher);
    [ExtensionAttribute]
public static void Freeze(IProperty`1<TValue> thіs, string message);
    [ExtensionAttribute]
public static void Freeze(IProperty`1<TValue> thіs, Lifetime lifetime, string message);
}
[ExtensionAttribute]
public static class JetBrains.DataFlow.PropertyValidatorFluent : object {
    [ExtensionAttribute]
[NotNullAttribute]
public static Property`1<TValue> CoerceToRange(Property`1<TValue> property, TValue min, TValue max);
    [ExtensionAttribute]
[NotNullAttribute]
public static Property`1<TValue> EnsureEnum(Property`1<TValue> property);
    [ExtensionAttribute]
[NotNullAttribute]
public static IProperty`1<TValue> EnsureEnum(IProperty`1<TValue> property);
    [ExtensionAttribute]
[NotNullAttribute]
public static Property`1<TValue> EnsureInitonly(Property`1<TValue> property);
    [ExtensionAttribute]
[NotNullAttribute]
public static Property`1<TValue> EnsureNotAbove(Property`1<TValue> property, TValue max);
    [ExtensionAttribute]
[NotNullAttribute]
public static Property`1<TValue> EnsureNotBelow(Property`1<TValue> property, TValue min);
    [ExtensionAttribute]
[NotNullAttribute]
public static Property`1<TValue> EnsureNotOutside(Property`1<TValue> property, TValue min, TValue max);
    [ExtensionAttribute]
[NotNullAttribute]
public static Property`1<TValue> EnsureReadonly(Property`1<TValue> property, ReadonlyToken token);
    [ExtensionAttribute]
[NotNullAttribute]
public static IProperty`1<TValue> EnsureReadonly(IProperty`1<TValue> property, ReadonlyToken token);
    [ExtensionAttribute]
[NotNullAttribute]
public static Property`1<TValue> EnsureThisThread(Property`1<TValue> property);
    [ExtensionAttribute]
[NotNullAttribute]
public static IProperty`1<TValue> EnsureThisThread(IProperty`1<TValue> property, Lifetime lifetime);
}
[DebuggerStepThroughAttribute]
public class JetBrains.DataFlow.Signal`1 : object {
    private SpinWaitLock myLock;
    [NotNullAttribute]
private PropertyId`1<TValue> myId;
    [CanBeNullAttribute]
private IProperty`1<TValue> myProperty;
    [CanBeNullAttribute]
private ReadonlyToken myReadOnlyLock;
    [NotNullAttribute]
private Action`1[] mySinks;
    [CanBeNullAttribute]
private Thread myThreadAffinedTo;
    private LocalLazy`1<SequentialLifetimes> myUnderlyingPropertyAffineToThread;
    private LocalLazy`1<SequentialLifetimes> myUnderlyingPropertyReadOnlyLock;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Nullable`1<ValueTuple`2<Action`3<Action`2<TValue, object>, TValue, object>, Action`2<TValue, object>>> CallStackAnnotationForFire;
    private ILogger myLogger;
    public PropertyId`1<TValue> Id { get; }
    public IProperty`1<TValue> Property { get; }
    private IUntypedSignal JetBrains.DataFlow.ISignal<TValue>.AsUntyped { get; }
    private PropertyId JetBrains.DataFlow.IUntypedSignal.Id { get; }
    private IUntypedProperty JetBrains.DataFlow.IUntypedSignal.Property { get; }
    private Type JetBrains.DataFlow.IUntypedSignal.ArgumentType { get; }
    public Signal`1(string id);
    [ObsoleteAttribute("Use overloads without lifetime.")]
[EditorBrowsableAttribute("1")]
public Signal`1(Lifetime lifetime, string id);
    [ObsoleteAttribute("Use overloads without lifetime.")]
[EditorBrowsableAttribute("1")]
public Signal`1(Lifetime lifetime, PropertyId`1<TValue> id, ILogger logger);
    public Signal`1(PropertyId`1<TValue> id, ILogger logger);
    protected virtual void OnAfterAdvise(Action`1<TValue> handler);
    protected virtual void OnAfterUnadvise(Action`1<TValue> handler);
    protected virtual bool OnBeforeAdvise(Action`1<TValue> handler);
    private void AdviseCore(Action`1<TValue> handler, Lifetime lifetime);
    [NotNullAttribute]
private IProperty`1<TValue> LazyCreateUnderlyingProperty();
    private void NotifySinks(TValue payload);
    private void OnUnderlyingPropertyChanged(PropertyChangedEventArgs`1<TValue> args);
    public virtual string ToString();
    private sealed virtual override void JetBrains.DataFlow.StandardPreconditions.IReadOnlyPrecondition.LockReadOnly(Lifetime lifetime, ReadonlyToken token);
    public sealed virtual void Advise(Lifetime lifetime, Action`1<TValue> handler);
    [ObsoleteAttribute("Pass in a lifetime; will be made non-idisposable.")]
public sealed virtual void Dispose();
    public sealed virtual void Fire(TValue value);
    public sealed virtual void Fire(TValue value, object cookie);
    private void FireInternal(TValue value, object cookie);
    private ValueTuple`2<Action`3<Action`2<TValue, object>, TValue, object>, Action`2<TValue, object>> InitCallStackAnnotationForFire();
    private ReadOnlyException Fire_ExceptionReadonlyPrecondition(object readOnlyLock, object cookie, TValue value);
    private ThreadAccessException Fire_ExceptionThreadAffinityPrecondition(TValue value, object cookie, Thread threadAffinedTo);
    private ArgumentException Fire_ExceptionCantFireNull();
    public sealed virtual PropertyId`1<TValue> get_Id();
    public sealed virtual IProperty`1<TValue> get_Property();
    private sealed virtual override void JetBrains.DataFlow.StandardPreconditions.IThreadAffinityPrecondition.AffineToThread(Lifetime lifetime, Thread thread);
    private sealed virtual override IUntypedSignal JetBrains.DataFlow.ISignal<TValue>.get_AsUntyped();
    private sealed virtual override PropertyId JetBrains.DataFlow.IUntypedSignal.get_Id();
    private sealed virtual override IUntypedProperty JetBrains.DataFlow.IUntypedSignal.get_Property();
    private sealed virtual override Type JetBrains.DataFlow.IUntypedSignal.get_ArgumentType();
    private sealed virtual override void JetBrains.DataFlow.IUntypedSignal.Advise(Lifetime lifetime, Action`1<object> action);
    private sealed virtual override void JetBrains.DataFlow.IUntypedSignal.Fire(object value, object cookie);
}
[ExtensionAttribute]
public static class JetBrains.DataFlow.SignalValidator : object {
    [ExtensionAttribute]
public static ISignal`1<TValue> EnsureReadonly(ISignal`1<TValue> signal, Lifetime lifetime, ReadonlyToken token);
    [ExtensionAttribute]
[NotNullAttribute]
public static SimpleSignal EnsureReadonly(SimpleSignal signal, Lifetime lifetime, ReadonlyToken token);
    [ExtensionAttribute]
[NotNullAttribute]
public static ISignal`1<TValue> EnsureThisThread(ISignal`1<TValue> signal, Lifetime lifetime);
    [ExtensionAttribute]
public static ISignal`1<TValue> EnsureThread(ISignal`1<TValue> signal, Lifetime lifetime, Thread thread);
    [ExtensionAttribute]
[NotNullAttribute]
public static SimpleSignal EnsureThisThread(SimpleSignal signal, Lifetime lifetime);
    [ExtensionAttribute]
[NotNullAttribute]
public static SimpleSignal EnsureThread(SimpleSignal signal, Lifetime lifetime, Thread thread);
}
[DebuggerStepThroughAttribute]
public class JetBrains.DataFlow.SimpleSignal : Signal`1<bool> {
    public SimpleSignal(PropertyId`1<bool> id, ILogger logger);
    public SimpleSignal(string id);
    [ObsoleteAttribute("Use overloads without lifetime.")]
[EditorBrowsableAttribute("1")]
public SimpleSignal(Lifetime lifetime, string id);
    [ObsoleteAttribute("Use overloads without lifetime.")]
[EditorBrowsableAttribute("1")]
public SimpleSignal(Lifetime lifetime, PropertyId`1<bool> id, ILogger logger);
    public sealed virtual void Fire();
}
[ObsoleteAttribute("Use SequentialLifetimes.")]
public class JetBrains.DataFlow.SingleDisposable : object {
    [NotNullAttribute]
private IDisposable myContainee;
    [NotNullAttribute]
public SingleDisposable Clear();
    [NotNullAttribute]
public SingleDisposable Put(IDisposable new);
    [NotNullAttribute]
public SingleDisposable Put(Func`1<IDisposable> funcNew);
    [NotNullAttribute]
public SingleDisposable PutBracket(Action FEnter, Action FLeave);
    public sealed virtual void Dispose();
}
public static class JetBrains.DataFlow.StackTraceUtil : object {
    private static object ourDeadlockInOldNetFrameworkOnNewStackTraceLock;
    public static bool OptionCaptureStackTraces;
    private static ILogger ourLogger;
    public static string NoStackTraceMessage;
    public static bool IsCaptureStackTraces { get; }
    private static StackTraceUtil();
    private static void StackFrameToString(StackFrame frame, StringBuilder sb);
    public static string StackFramesToString(StackFrame[] frames);
    [CanBeNullAttribute]
public static StackFrame[] CaptureStackTraceConditionally(bool bObeyOptionCaptureStackTraces);
    [NotNullAttribute]
public static StackTrace CaptureStackTrace(int skipFrames, bool fNeedFileInfo, Exception exception);
    public static string GetCallerMethodName();
    public static string CaptureAndFormatStackTrace(bool bObeyOptionCaptureStackTraces);
    public static string CaptureAndFormatStackTrace();
    public static bool get_IsCaptureStackTraces();
}
public interface JetBrains.DataFlow.StandardPreconditions.IReadOnlyPrecondition {
    public abstract virtual void LockReadOnly(Lifetime lifetime, ReadonlyToken token);
}
public interface JetBrains.DataFlow.StandardPreconditions.IStandardPrecondition {
}
public interface JetBrains.DataFlow.StandardPreconditions.IThreadAffinityPrecondition {
    public abstract virtual void AffineToThread(Lifetime lifetime, Thread thread);
}
public class JetBrains.DataFlow.StandardPreconditions.ReadonlyToken : object {
    [NotNullAttribute]
public string Info;
    public ReadonlyToken(string info);
    public virtual string ToString();
}
public static class JetBrains.DataFlow.StandardPreconditions.StandardPreconditionOptions : object {
    public static bool UseStandardPreconditionsInHelperMethods;
    private static StandardPreconditionOptions();
}
[ExtensionAttribute]
public static class JetBrains.DataFlow.Viewable : object {
    [ExtensionAttribute]
public static IEnumerable`1<TValue> ToLiveEnumerable(IViewable`1<TValue> viewable, Lifetime lifetime);
    [ExtensionAttribute]
public static List`1<TValue> ToLiveList(IViewable`1<TValue> viewable, Lifetime lifetime);
    [ExtensionAttribute]
[NotNullAttribute]
public static IList`1<TValue> ToNonLiveList(IViewable`1<TValue> viewable);
    [ExtensionAttribute]
public static ICollection`1<TResult> ToLiveEnumerable(IViewable`1<TValue> viewable, Lifetime lifetime, Func`2<TValue, TResult> projection);
    [ExtensionAttribute]
public static IEnumerable`1<T> ToLiveOrderedEnumerable(IViewable`1<T> viewable, Lifetime lifetime, Comparison`1<T> comparer);
    [ExtensionAttribute]
public static IEnumerable`1<T> ToLiveTopoOrderedEnumerable(IViewable`1<T> viewable, Lifetime lifetime, Func`3<T, T, Nullable`1<int>> comparer);
    [ExtensionAttribute]
public static IEnumerable`1<T> ToLiveOrderedEnumerable(IViewable`1<T> viewable, Lifetime lifetime, Comparison`1<TAttribute> comparer);
    [ExtensionAttribute]
public static IDictionary`2<TKey, TValue> ToLiveDictionary(IViewable`1<TValue> viewable, Lifetime lifetime, Func`2<TValue, TKey> keySelector, IEqualityComparer`1<TKey> keyComparer);
    [ExtensionAttribute]
public static JetHashSet`1<TResult> ToLiveHashSet(IViewable`1<TValue> viewable, Lifetime lifetime, Func`2<TValue, IEnumerable`1<TResult>> keySelector);
    [ExtensionAttribute]
public static JetHashSet`1<TResult> ToLiveHashSet(IViewable`1<TValue> viewable, Lifetime lifetime, Func`2<TValue, TResult> selector);
    [ExtensionAttribute]
public static void MapMany(IViewable`1<TValue> viewable, Lifetime lifetime, Func`2<TValue, IEnumerable`1<TKey>> keySelector, IOneToManyMap`3<TKey, TValue, TCollection> dictionary);
    [ExtensionAttribute]
public static void View(IViewable`1<TValue> viewable, Lifetime lifetime, Action`1<TValue> entered, Action`1<TValue> leaving);
    [ExtensionAttribute]
[NotNullAttribute]
public static IViewable`1<TItem> SelectMany(IViewable`1<TItemsProvider> thіs, Lifetime lifetime, Func`2<TItemsProvider, IViewable`1<TItem>> FGetItemsFromProvider);
    [ExtensionAttribute]
[NotNullAttribute]
public static ICollectionEvents`1<TValue> ToLiveCollection(IViewable`1<TValue> viewable, Lifetime lifetime);
}
public class JetBrains.DataFlow.ViewableCollection`1 : object {
    [NotNullAttribute]
public static ViewableCollection`1<TValue> Empty;
    [NotNullAttribute]
private Lifetime myLifetime;
    [NotNullAttribute]
private ICollection`1<TValue> myCollection;
    [NotNullAttribute]
private Dictionary`2<Action`2<Lifetime, TValue>, Lifetime> myViewers;
    [NotNullAttribute]
private Dictionary`2<TValue, LifetimeDefinition> myValueLifetimes;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public ViewableCollection`1(Lifetime lifetime);
    public ViewableCollection`1(Lifetime lifetime, ICollection`1<TValue> collection);
    private static ViewableCollection`1();
    public sealed virtual void View(Lifetime lifetime, Action`2<Lifetime, TValue> viewer);
    private void View(Lifetime viewLifetime, TValue value, Action`2<Lifetime, TValue> observer);
    private void Unview(TValue value);
    [NotNullAttribute]
private Lifetime GetValueLifetime(TValue value);
    public sealed virtual IEnumerator`1<TValue> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Add(TValue item);
    public void Add(Lifetime lifetime, TValue item);
    public void AddRange(Lifetime lifetime, IEnumerable`1<TValue> items);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(TValue item);
    public sealed virtual void CopyTo(TValue[] array, int arrayIndex);
    public sealed virtual bool Remove(TValue item);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
}
[DebuggerStepThroughAttribute]
public static class JetBrains.DataFlow.WinFormsProperty : object {
    [NotNullAttribute]
public static IProperty`1<TValue> Create(Lifetime lifetime, TSource source, Expression`1<Func`2<TSource, TValue>> propertyExpression, bool sinkEvents);
    [NotNullAttribute]
[ObsoleteAttribute("Use overload with lifetime.")]
public static IProperty`1<TValue> Create(TSource source, Expression`1<Func`2<TSource, TValue>> propertyExpression, bool sinkEvents);
    [NotNullAttribute]
[ObsoleteAttribute("Use strong-typed overload with lifetime.")]
public static IProperty`1<TValue> Create(object source, string propertyName, bool sinkEvents);
    private static IProperty`1<TValue> Create(Lifetime lifetime, object source, PropertyInfo propinfo, bool sinkEvents);
    private static void BindDataFlowToWinForms(Lifetime lifetime, IProperty`1<TValue> property, object source, PropertyInfo propinfo);
    private static void BindWinFormsToDataFlow(Lifetime lifetime, IProperty`1<TValue> property, object source, PropertyInfo propinfo);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class JetBrains.DictionaryEx : object {
    [ExtensionAttribute]
[PureAttribute]
public static TValue GetValueSafe(IDictionary`2<TKey, TValue> dictionary, TKey key, TValue resultOnFail);
    [ExtensionAttribute]
[PureAttribute]
public static TValue GetReadOnlyValueSafe(IReadOnlyDictionary`2<TKey, TValue> dictionary, TKey key, TValue resultOnFail);
    [ExtensionAttribute]
[PureAttribute]
public static TValue GetValueSafe(Dictionary`2<TKey, TValue> dictionary, TKey key, TValue resultOnFail);
    [ExtensionAttribute]
[PureAttribute]
[ObsoleteAttribute("Dangerous method: O(N) lookup, ignores dictionary's own key comparer, possible TKey boxings on Equals() call")]
public static TKey FindKey(IDictionary`2<TKey, TValue> dictionary, TValue value);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static void Add(IDictionary`2<TKey, TValue> dictionary, Lifetime lifetime, TKey key, TValue value);
    [ExtensionAttribute]
[PureAttribute]
public static bool DictionaryEquals(IDictionary`2<TKey, TValue> left, IDictionary`2<TKey, TValue> right);
    [ExtensionAttribute]
[PureAttribute]
public static bool DictionaryEquals(IDictionary`2<TKey, TValue> left, IDictionary`2<TKey, TValue> right, IEqualityComparer`1<TValue> valueComparer);
    [ExtensionAttribute]
[PureAttribute]
public static bool ReadOnlyDictionaryEquals(IReadOnlyDictionary`2<TKey, TValue> left, IReadOnlyDictionary`2<TKey, TValue> right);
    [ExtensionAttribute]
[PureAttribute]
public static bool ReadOnlyDictionaryEquals(IReadOnlyDictionary`2<TKey, TValue> left, IReadOnlyDictionary`2<TKey, TValue> right, IEqualityComparer`1<TValue> valueComparer);
    [ExtensionAttribute]
[PureAttribute]
public static int DictionaryGetHashCode(IDictionary`2<TKey, TValue> dictionary);
    [ExtensionAttribute]
[PureAttribute]
public static int ReadOnlyDictionaryGetHashCode(IReadOnlyDictionary`2<TKey, TValue> dictionary);
    [ExtensionAttribute]
[PureAttribute]
private static int DictionaryGetHashCodeInternal(IEnumerable`1<KeyValuePair`2<TKey, TValue>> dictionary);
}
[ExtensionAttribute]
public static class JetBrains.Extension.ICustomAttributeProviderEx : object {
    [ExtensionAttribute]
public static IEnumerable`1<TAttribute> GetCustomAttributesByType(ICustomAttributeProvider attributeProvider, bool inherit);
    [ExtensionAttribute]
[NotNullAttribute]
public static TAttribute GetCustomAttributeByType(ICustomAttributeProvider attributeProvider, bool inherit);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static TAttribute GetCustomAttributeByTypeSafe(ICustomAttributeProvider attributeProvider, bool inherit);
    [ExtensionAttribute]
public static Pair`2<TAttribute, Type> GetCustomAttributeFromHierarchy(Type type);
    [ExtensionAttribute]
[NotNullAttribute]
public static TAttribute GetCustomAttributeNoInherit(ICustomAttributeProvider attrprovider);
    [ExtensionAttribute]
public static bool HasCustomAttributeNoInherit(ICustomAttributeProvider customAttributeProvider);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static TAttribute TryGetCustomAttributeNoInherit(ICustomAttributeProvider attrprovider);
}
[ExtensionAttribute]
public static class JetBrains.Extension.SerializationInfoEx : object {
    [ExtensionAttribute]
public static TValue GetValue(SerializationInfo this, string name);
}
[ExtensionAttribute]
public static class JetBrains.Extension.StreamEx : object {
    [ExtensionAttribute]
public static int Read(Stream stream, Byte[] buffer);
    [ExtensionAttribute]
[NotNullAttribute]
public static Byte[] ReadAllBytes(Stream stream);
    [ExtensionAttribute]
public static ImmutableArray`1<byte> ReadAllBytesImmutable(Stream stream);
    [ExtensionAttribute]
[NotNullAttribute]
public static MemoryStream ToMemoryStream(Stream stream);
    [ExtensionAttribute]
public static void StreamReader(Stream stream, Action`1<StreamReader> FRead);
    [ExtensionAttribute]
public static void StreamWriter(Stream stream, Action`1<StreamWriter> FWrite);
    [ExtensionAttribute]
public static void Write(Stream stream, Byte[] buffer);
    [ExtensionAttribute]
public static void Write(Stream stream, ImmutableArray`1<byte> bytes);
    [ExtensionAttribute]
public static void DeflateCompress(Stream stream, Action`1<DeflateStream> FWriter);
    [ExtensionAttribute]
public static void DeflateDecompress(Stream stream, Action`1<DeflateStream> FReader);
    [ExtensionAttribute]
[NotNullAttribute]
public static ImmutableByteStream AsImmutable(UnmanagedMemoryStream uman);
    [ExtensionAttribute]
public static void CopyStream(Stream input, Stream output);
    [AsyncStateMachineAttribute("JetBrains.Extension.StreamEx/<CopyStreamAsync>d__12")]
[ExtensionAttribute]
public static Task`1<ulong> CopyStreamAsync(Stream input, OuterLifetime lifetime, Stream output);
    [ExtensionAttribute]
public static int CopyToMemory(Stream input, Void* dstPtr, int size);
    [ExtensionAttribute]
public static void Write(Stream output, Void* pData, int cbSize);
    [ExtensionAttribute]
public static void Write(Stream output, ByteBuffer buffer);
    [ExtensionAttribute]
public static void Write(Stream output, Void* pData, ulong cbSize);
    [ExtensionAttribute]
public static ulong Read(Stream input, Void* pData, ulong cbSize, UInt32 chunksize);
    [ExtensionAttribute]
[NotNullAttribute]
public static Stream Rewind(Stream thіs);
    [ExtensionAttribute]
[NotNullAttribute]
public static Stream EraseAndRewind(Stream thіs);
    [ExtensionAttribute]
public static bool StreamEquals(Stream x, Stream y);
    [MustUseReturnValueAttribute]
private static IDisposable GetBuffer(long length, Span`1& result);
    [ExtensionAttribute]
public static TextAndEncoding ReadTextFromFile(Stream stream);
    [ExtensionAttribute]
public static bool IsDeterministic(DecodedText this, OnError onerror);
    [ExtensionAttribute]
public static DecodedText AssertDeterministic(DecodedText this);
    [ExtensionAttribute]
public static string ReadTextFromStreamDeterministic(Stream stream);
    private static Encoding RemoveBomFromKnownEncodings(Encoding encoding);
    [ExtensionAttribute]
public static string ReadTextFromFile(Stream stream, Encoding& detectedEncoding);
    [ExtensionAttribute]
[NotNullAttribute]
public static DecodedText ReadTextFromBuffer(ReadOnlySpan`1<byte> buffer, Encoding defaultMbcsEncodingOverride);
    private static void ScanForUtf8(Byte* bp, int buflen, Int32& goodUtf8Sequences, Int32& badUtf8Symbols, Int32& definitelyNotCp1252Symbols, Boolean& isUtf8BomInTheMiddle, Boolean& isNonAscii);
    [CanBeNullAttribute]
private static DecodedText TryDetectLeadingBom(Byte* bp, int buflen);
    [CanBeNullAttribute]
private static DecodedText TryDetectXmlHeader(Byte* bp, int buflen);
    private static Nullable`1<bool> CheckIsValidUtf(Byte* bp, int buflen, Encoding detectedEncoding);
    [ExtensionAttribute]
public static DecodedText ReadTextFromStream(Stream stream, Encoding defaultEncodingOverride);
    private static bool IsDefinitelyNotCp1252(byte ch);
    [ExtensionAttribute]
public static void WriteStructure(Stream self, T structure);
    [ExtensionAttribute]
public static void WriteUtf8(Stream stream, string text);
    [ExtensionAttribute]
[NotNullAttribute]
public static Stream AsSeekable(Stream maybeSequential, Nullable`1<long> customlength);
    [ExtensionAttribute]
public static void TransformBlock(ICryptoTransform crypt, Stream stream);
}
[ExtensionAttribute]
public static class JetBrains.Extension.TimeSpanEx : object {
    public static long DayInMilliseconds;
    public static long HourInMilliseconds;
    public static long MinuteInMilliseconds;
    public static long MonthInMilliseconds;
    public static long SecondInMilliseconds;
    [ExtensionAttribute]
public static TimeSpan CoerceInfiniteForWinApi(TimeSpan timeout);
    [ExtensionAttribute]
public static TimeSpan CoerceInfiniteForWinApi(Nullable`1<TimeSpan> timeout);
    [ExtensionAttribute]
public static TimeSpan Div(TimeSpan timespan, double value);
    public static TimeSpan FromMilliseconds(long milliseconds, long maxValue);
    [ExtensionAttribute]
public static bool IsAnyInfinite(TimeSpan timeout);
    public static TimeSpan Max(TimeSpan a, TimeSpan b);
    public static TimeSpan Min(TimeSpan a, TimeSpan b);
    [ExtensionAttribute]
public static TimeSpan Mul(TimeSpan timespan, double value);
}
[ExtensionAttribute]
public static class JetBrains.Extension.TypeEx : object {
    private static Char[] GenericsInTypeNameBeginWith;
    private static TypeEx();
    [ExtensionAttribute]
public static object GetDefaultValue(Type type);
    public static bool IsDefaultValue(object value);
    [ExtensionAttribute]
public static bool IsDefaultValue(Type type, object value);
    [ExtensionAttribute]
public static bool IsDefaultValueOrEmptyString(Type type, object value);
    public static bool IsDefaultValueOrEmptyString(object value);
    public static object CoercePrimitiveValueToType(object primitive, Type typeTarget, ILogger logger);
    public static StringSlice GetLocalNameFromFullTypeName(string fullname, bool isKeepingOuterClasses);
    public static StringSlice GetLocalNameFromFullTypeName(StringSlice fullname, bool isKeepingOuterClasses);
    public static StringSource GetLocalNameFromFullTypeName(StringSource fullname, bool isKeepingOuterClasses);
    public static StringSlice GetTypeNameWithoutGenericArgs(string fullname);
    public static StringSource GetTypeNameWithoutGenericArgs(StringSource fullname);
    public static bool EqualsTypeNameWithoutGenericArgs(StringSource fullname, StringSource nameNoArgs);
    public static StringSlice GetTypeNameWithoutGenericArgs(StringSlice fullname);
    public static StringSlice GetNamespaceFromFullTypeName(StringSlice fullname);
    public static StringSlice GetNamespaceFromFullTypeName(string fullname);
    public static StringSource GetNamespaceFromFullTypeName(StringSource fullname);
    [ExtensionAttribute]
public static bool IsAssignableFrom(Type type);
    [ExtensionAttribute]
public static bool IsAssignableTo(Type type);
}
[ExtensionAttribute]
public static class JetBrains.Extension.TypeEx_NetCore15 : object {
    [ExtensionAttribute]
[NotNullAttribute]
public static string QuoteIfNeeded(Type type);
}
[FlagsAttribute]
public enum JetBrains.Metadata.Access.AssemblyFlags : Enum {
    public int value__;
    public static AssemblyFlags SideBySideCompatible;
    public static AssemblyFlags PublicKey;
    public static AssemblyFlags Retargetable;
    public static AssemblyFlags DisableJITcompileOptimizer;
    public static AssemblyFlags EnableJITcompileTracking;
    public static AssemblyFlags ProcessorArchitectureMask;
    public static AssemblyFlags ProcessorArchitectureNone;
    public static AssemblyFlags ProcessorArchitectureMsil;
    public static AssemblyFlags ProcessorArchitectureX86;
    public static AssemblyFlags ProcessorArchitectureIA64;
    public static AssemblyFlags ProcessorArchitectureAMD64;
    public static AssemblyFlags ProcessorArchitectureARM;
    public static AssemblyFlags ProcessorArchitectureARM64;
    public static AssemblyFlags ProcessorArchitectureFullMask;
    public static AssemblyFlags ProcessorArchitectureSpecified;
    public static AssemblyFlags ProcessorArchitectureNoPlatform;
    public static AssemblyFlags ContentTypeMask;
    public static AssemblyFlags ContentTypeDefault;
    public static AssemblyFlags ContentTypeWindowsRuntime;
}
public enum JetBrains.Metadata.Access.AssemblyHashAlgorithm : Enum {
    public UInt32 value__;
    public static AssemblyHashAlgorithm None;
    public static AssemblyHashAlgorithm MD5;
    public static AssemblyHashAlgorithm SHA1;
    public static AssemblyHashAlgorithm SHA256;
    public static AssemblyHashAlgorithm SHA384;
    public static AssemblyHashAlgorithm SHA512;
    public static AssemblyHashAlgorithm MD2;
    public static AssemblyHashAlgorithm MD4;
    public static AssemblyHashAlgorithm MAC;
    public static AssemblyHashAlgorithm Ssl3ShaMd5;
    public static AssemblyHashAlgorithm HMAC;
    public static AssemblyHashAlgorithm TLS1PRF;
    public static AssemblyHashAlgorithm HashReplaceOwf;
}
public class JetBrains.Metadata.Utils.AssemblyNameAndLocation : ValueType {
    [CanBeNullAttribute]
public VirtualFileSystemPath AssemblyLocation;
    [CanBeNullAttribute]
public AssemblyNameInfo AssemblyName;
    public AssemblyNameAndLocation(AssemblyNameInfo assemblyName, VirtualFileSystemPath assemblyLocation);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(AssemblyNameAndLocation other);
    public virtual int GetHashCode();
    public static bool op_Equality(AssemblyNameAndLocation left, AssemblyNameAndLocation right);
    public static bool op_Inequality(AssemblyNameAndLocation left, AssemblyNameAndLocation right);
    public virtual string ToString();
}
[ExtensionAttribute]
public static class JetBrains.Metadata.Utils.AssemblyNameExtensions : object {
    public static double MAX_DISTANCE;
    public static double BIG_DISTANCE;
    public static long FAVOR_MAJOR_MINOR_DISTANCE;
    private static int MAX_VERSION_COMPONENT_VALUE;
    [NotNullAttribute]
public static String[] AllPossibleExtensionsForModules;
    private static AssemblyNameExtensions();
    [CanBeNullAttribute]
[ObsoleteAttribute("This method might silently return NULL instead of throwing an exception, which is a contract violation for Parse methods. Use either AssemblyNameInfo::Parse or AssemblyNameInfo::TryParse, depending on what you need.")]
public static AssemblyNameInfo ParseAssemblyName(string assemblyFullName);
    [ExtensionAttribute]
public static bool ReferenceMatchesDefinition(AssemblyNameInfo ref, AssemblyNameInfo def);
    [ExtensionAttribute]
public static bool IsMscorlib(AssemblyNameInfo assemblyName);
    [ExtensionAttribute]
public static bool IsSystem(AssemblyNameInfo assemblyName);
    [ExtensionAttribute]
public static bool IsWindowsWinmd(AssemblyNameInfo assemblyName);
    [ExtensionAttribute]
public static bool IsSystemRuntime(AssemblyNameInfo assemblyName);
    [ExtensionAttribute]
public static bool IsSystemPrivateCoreLib(AssemblyNameInfo assemblyName);
    [ExtensionAttribute]
public static bool IsNetstandard(AssemblyNameInfo assemblyName);
    [ExtensionAttribute]
public static bool PossiblyContainsPredefinedTypes(AssemblyNameInfo assemblyName);
    [ExtensionAttribute]
[NotNullAttribute]
public static FileSystemPath EvaluateFileSystemPath(AssemblyNameInfo assemblyName);
    public static bool CompareNameAndVersion(AssemblyNameInfo name1, AssemblyNameInfo name2);
    public static bool CompareName(AssemblyNameInfo name1, AssemblyNameInfo name2);
    private static double ComputeDistanceComponent(int firstVersionComponent, int secondVersionComponent);
    private static double Distance(Version first, Version second);
    public static double Distance(AssemblyNameInfo required, AssemblyNameInfo candidate);
    [NotNullAttribute]
[PureAttribute]
public static Byte[] GetPublicKeyToken(string value);
    [NotNullAttribute]
[PureAttribute]
public static Byte[] GetPublicKey(string value);
    public static void GetPublicKeyTokenString(Byte[] value, StringBuilder sb);
    public static string GetPublicKeyTokenString(Byte[] value);
    [CanBeNullAttribute]
public static AssemblyNameInfo ChooseAssemblyName(AssemblyNameInfo name, IList`1<AssemblyNameInfo> candidates, Int32& index);
    [CanBeNullAttribute]
public static AssemblyNameInfo ChooseAssemblyName(AssemblyNameInfo name, IList`1<AssemblyNameInfo> candidates, Int32& index, Func`3<AssemblyNameInfo, AssemblyNameInfo, bool> assemblyNameInfoComparer);
    public static bool ComparePublicKeyToken(AssemblyName name, Byte[] token);
    public static bool CompareIgnoreCultureAndVersion(AssemblyNameInfo name1, AssemblyNameInfo name2);
    public static Uri GetCodeBase(string fullPath);
    public static bool Matches(AssemblyNameInfo name1, AssemblyNameInfo name2);
    private static bool MatchCultureValue(string o1, string o2);
    private static bool MatchValue(object o1, object o2);
    [ExtensionAttribute]
[NotNullAttribute]
public static AssemblyNameInfo GetNameInfo(Assembly ass);
}
[TypeConverterAttribute("JetBrains.Metadata.Utils.AssemblyNameInfoConverter")]
[ValueSerializerAttribute("JetBrains.Metadata.Utils.AssemblyNameInfoSerializer")]
public class JetBrains.Metadata.Utils.AssemblyNameInfo : object {
    public static string CultureNeutral;
    private static Byte[] ourNeutralPublicKey;
    private static Byte[] ourNeutralPublicKeyToken;
    public static AssemblyNameInfo Empty;
    [CanBeNullAttribute]
private string myFullName;
    private int myCachedHashCode;
    [NotNullAttribute]
private string mySimpleName;
    [CanBeNullAttribute]
private string myCulture;
    [CanBeNullAttribute]
private Version myVersion;
    private PublicKeyToken myPublicKeyToken;
    [CanBeNullAttribute]
private Byte[] myPublicKey;
    private ProcessorArchitecture myProcessorArchitecture;
    private bool myIsRetargetable;
    private AssemblyIdentityContentTypes myContentType;
    private object myCustom;
    [CompilerGeneratedAttribute]
private string <CodeBase>k__BackingField;
    [CompilerGeneratedAttribute]
private AssemblyHashAlgorithm <AssemblyManifestHashAlgorithm>k__BackingField;
    public static StringComparer SimpleNameComparer;
    public static StringComparer CultureComparer;
    public bool IsRetargetable { get; }
    public AssemblyIdentityContentTypes ContentType { get; }
    public bool IsStrongName { get; }
    public string FullName { get; }
    [NotNullAttribute]
public string Name { get; }
    [CanBeNullAttribute]
public Version Version { get; }
    [ObsoleteAttribute("Use Culture property instead. Reason: this is not the CultureInfo object of the CLR AssemblyName type, but only its name.")]
[CanBeNullAttribute]
public string CultureInfo { get; }
    [CanBeNullAttribute]
public string Culture { get; }
    [ObsoleteAttribute("The flags are not in use anymore, and will always have a zero value.")]
public AssemblyNameInfoFlags Flags { get; }
    [CanBeNullAttribute]
public string CodeBase { get; private set; }
    public ProcessorArchitecture ProcessorArchitecture { get; }
    public object Custom { get; }
    public AssemblyHashAlgorithm AssemblyManifestHashAlgorithm { get; private set; }
    [ObsoleteAttribute("Use Parse() factory method, or cast from a string.")]
public AssemblyNameInfo(AssemblyName clr);
    [ObsoleteAttribute("Use Parse() or an explicit cast operator instead.")]
public AssemblyNameInfo(string fullname);
    [ObsoleteAttribute("Use Create() instead, for interning.")]
public AssemblyNameInfo(string simplename, Version version, PublicKeyToken pktoken, string culture, string codeBase, Byte[] publickey, ProcessorArchitecture processor, bool isRetargetable, AssemblyIdentityContentTypes contenttype, object custom, AssemblyHashAlgorithm hashalg);
    public AssemblyNameInfo(BinaryReader reader);
    public AssemblyNameInfo(UnsafeReader reader);
    private static AssemblyNameInfo();
    public bool get_IsRetargetable();
    public AssemblyIdentityContentTypes get_ContentType();
    public bool get_IsStrongName();
    [ContractAnnotationAttribute("culturename:null=>null")]
private static string SubstNeutralForEmptyCultureName(string culturename);
    private static string SubstNeutralForEmptyCultureName(StringSource culturename);
    public string get_FullName();
    private string GetFullNameCold();
    public string get_Name();
    public Version get_Version();
    public string get_CultureInfo();
    public string get_Culture();
    public AssemblyNameInfoFlags get_Flags();
    [CompilerGeneratedAttribute]
public string get_CodeBase();
    [CompilerGeneratedAttribute]
private void set_CodeBase(string value);
    public ProcessorArchitecture get_ProcessorArchitecture();
    public object get_Custom();
    [CompilerGeneratedAttribute]
public AssemblyHashAlgorithm get_AssemblyManifestHashAlgorithm();
    [CompilerGeneratedAttribute]
private void set_AssemblyManifestHashAlgorithm(AssemblyHashAlgorithm value);
    [CanBeNullAttribute]
public static AssemblyNameInfo TryParse(string s);
    [NotNullAttribute]
public static AssemblyNameInfo Parse(string s);
    [NotNullAttribute]
public static AssemblyNameInfo Parse(StringSource text);
    [NotNullAttribute]
public static AssemblyNameInfo Create(string simplename, Version version, PublicKeyToken pktoken, string culture, string codeBase, Byte[] publickey, ProcessorArchitecture processor, bool isRetargetable, AssemblyIdentityContentTypes contenttype, object custom, AssemblyHashAlgorithm hashalg);
    [NotNullAttribute]
private string BuildFullName();
    public void Write(BinaryWriter writer);
    public void Write(UnsafeWriter writer);
    public static AssemblyNameInfo Read(BinaryReader reader);
    public static AssemblyNameInfo Read(UnsafeReader reader);
    [ObsoleteAttribute("Use GetPublicKeyToken2 wherever possible.")]
public Byte[] GetPublicKeyToken();
    public PublicKeyToken GetPublicKeyToken2();
    [CanBeNullAttribute]
public Byte[] GetPublicKey();
    public static PublicKeyToken ComputePublicKeyTokenOnKey(Byte[] key);
    public virtual string ToString();
    public bool Equals(AssemblyNameInfo other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(AssemblyNameInfo left, AssemblyNameInfo right);
    public static bool op_Inequality(AssemblyNameInfo left, AssemblyNameInfo right);
    [ContractAnnotationAttribute("null => null; notnull => notnull")]
public static AssemblyNameInfo op_Explicit(string value);
    [ContractAnnotationAttribute("null => null; notnull => notnull")]
public static string op_Explicit(AssemblyNameInfo value);
    public static Nullable`1<bool> MemberwiseEqual(AssemblyNameInfo x, AssemblyNameInfo y);
    public static bool KeysEqual(AssemblyNameInfo x, AssemblyNameInfo y);
}
public class JetBrains.Metadata.Utils.AssemblyNameInfoConverter : TypeConverterBase`1<AssemblyNameInfo> {
}
[ExtensionAttribute]
public static class JetBrains.Metadata.Utils.AssemblyNameInfoEx : object {
    [ExtensionAttribute]
[ContractAnnotationAttribute("null => true")]
public static bool IsNullOrEmpty(AssemblyNameInfo info);
    [ExtensionAttribute]
public static void Write(UnsafeWriter writer, AssemblyNameInfo info);
    [ExtensionAttribute]
[NotNullAttribute]
public static AssemblyNameInfo ReadAssemblyNameInfo(UnsafeReader reader);
}
[FlagsAttribute]
[ObsoleteAttribute("The flags are not in use anymore, and will always have a zero value.")]
public enum JetBrains.Metadata.Utils.AssemblyNameInfoFlags : Enum {
    public UInt32 value__;
    [ObsoleteAttribute("The flags are not in use anymore, and will always have a zero value.")]
public static AssemblyNameInfoFlags None;
    [ObsoleteAttribute("The flags are not in use anymore, and will always have a zero value.")]
public static AssemblyNameInfoFlags PublicKey;
    [ObsoleteAttribute("The flags are not in use anymore, and will always have a zero value.")]
public static AssemblyNameInfoFlags Retargetable;
    [ObsoleteAttribute("The flags are not in use anymore, and will always have a zero value.")]
public static AssemblyNameInfoFlags WindowsRuntime;
}
public class JetBrains.Metadata.Utils.AssemblyNameInfoSerializer : ValueSerializerBase`1<AssemblyNameInfo> {
}
public static class JetBrains.Metadata.Utils.AssemblyNames : object {
    public static string MicrosoftVisualBasic;
    public static string MicrosoftCSharp;
    public static string Mscorlib;
    public static string Netstandard;
    public static string SystemCore;
    public static string SystemDrawing;
    public static string SystemRuntime;
    public static string SystemPrivateCorLib;
    public static string SystemPrivateDataContractSerialization;
    public static string SystemPrivateUri;
    public static string SystemPrivateXml;
    public static string SystemPrivateXmlLinq;
    public static string System;
    public static string Windows;
}
public class JetBrains.Metadata.Utils.PublicKeyToken : ValueType {
    private static ReadonlyToken myExtra_Deferred;
    private static ReadonlyToken myExtra_NullOrNeutral;
    [CanBeNullAttribute]
private object myExtra;
    private ulong myValue;
    public bool IsNotNull { get; }
    public bool IsNotSet { get; }
    public bool IsNull { get; }
    public static PublicKeyToken Neutral { get; }
    public static PublicKeyToken NotSet { get; }
    public static PublicKeyToken Null { get; }
    private PublicKeyToken(ulong value, object extra);
    private static PublicKeyToken();
    [PureAttribute]
public bool get_IsNotNull();
    [PureAttribute]
public bool get_IsNotSet();
    [PureAttribute]
public bool get_IsNull();
    [PureAttribute]
public static PublicKeyToken get_Neutral();
    [PureAttribute]
public static PublicKeyToken get_NotSet();
    [PureAttribute]
public static PublicKeyToken get_Null();
    [PureAttribute]
public sealed virtual bool Equals(PublicKeyToken other);
    [PureAttribute]
public virtual bool Equals(object obj);
    public static PublicKeyToken FromArray(Byte[] tokenbytes);
    public static PublicKeyToken FromNonNullValue(ulong value);
    public static PublicKeyToken FromValueAndAttrFlags(ulong value, AssemblyIdentityFlags flags);
    public static PublicKeyToken FromPublicKey(Byte[] publickey);
    [CanBeNullAttribute]
public Byte[] GetArray();
    [CanBeNullAttribute]
public Byte[] GetArrayOrNull();
    [PureAttribute]
public AssemblyIdentityFlags GetAttrFlags();
    [PureAttribute]
public virtual int GetHashCode();
    [PureAttribute]
public ulong GetValue();
    [PureAttribute]
public ulong GetValueOrNull();
    [PureAttribute]
public static bool op_Equality(PublicKeyToken left, PublicKeyToken right);
    [PureAttribute]
public static bool op_Inequality(PublicKeyToken left, PublicKeyToken right);
    [PureAttribute]
public virtual string ToString();
    public static PublicKeyToken Parse(string tokentext);
    public static PublicKeyToken TryParse(string tokentext);
    private static PublicKeyToken TryParseCore(string tokentext, OnError onerror);
}
[ExtensionAttribute]
public static class JetBrains.NumberUtil : object {
    private static double Epsilon;
    [NotNullAttribute]
[PureAttribute]
public static string FloatingToStringRoundtrip(T value);
    [ExtensionAttribute]
[PureAttribute]
public static int Kilobytes(int number);
    [ExtensionAttribute]
[PureAttribute]
public static int Megabytes(int number);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsNanOrInf(double number);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsNaN(double number);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsPositiveInfinity(double number);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsNegativeInfinity(double number);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsInfinity(double number);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsPositiveZero(double value);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsNegativeZero(double value);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsNaN(float value);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsNanOrInf(float number);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsPositiveInfinity(float number);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsNegativeInfinity(float number);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsInfinity(float number);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsPositiveZero(float number);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsNegativeZero(float number);
    [ExtensionAttribute]
[PureAttribute]
public static double Clamp(double value, double min, double max);
    [ExtensionAttribute]
[PureAttribute]
public static int Clamp(int value, int min, int max);
    [ExtensionAttribute]
[PureAttribute]
public static bool InRange(TComparable value, TComparable min, TComparable max);
    [ExtensionAttribute]
[PureAttribute]
public static double AtMost(double f, double maxvalue);
    [ExtensionAttribute]
[PureAttribute]
public static double AtLeast(double f, double minvalue);
    [ExtensionAttribute]
[PureAttribute]
public static int AtMost(int f, int maxvalue);
    [ExtensionAttribute]
[PureAttribute]
public static int AtLeast(int f, int minvalue);
    [ExtensionAttribute]
[PureAttribute]
public static UInt32 AtMost(UInt32 n, UInt32 maxvalue);
    [ExtensionAttribute]
[PureAttribute]
public static UInt32 AtLeast(UInt32 n, UInt32 minvalue);
    [PureAttribute]
public static bool IsZero(double value);
    public static bool AreClose(double value1, double value2);
}
public class JetBrains.Platform.RdFramework.Impl.ExceptionEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    public Exception Exception { get; }
    public ExceptionEventArgs(Exception exception);
    [CompilerGeneratedAttribute]
public Exception get_Exception();
}
public class JetBrains.Platform.RdFramework.Impl.SimpleBackgroundThreadDispatcher : object {
    [NotNullAttribute]
private ILog myLogger;
    [NotNullAttribute]
private BlockingPriorityQueue`1<ArtOfAction> myQueue;
    private Thread myThread;
    public IScheduler PriorityScheduler;
    [CompilerGeneratedAttribute]
private EventHandler`1<ExceptionEventArgs> OnActionException;
    [CompilerGeneratedAttribute]
private EventHandler`1<ExceptionEventArgs> OnSchedulerException;
    [CompilerGeneratedAttribute]
private EventHandler OnExit;
    public bool IsActive { get; }
    public bool OutOfOrderExecution { get; }
    public SimpleBackgroundThreadDispatcher(Lifetime lifetime, ILog logger);
    public void StartAsync();
    public void InitSync();
    public void Run();
    [CompilerGeneratedAttribute]
public void add_OnActionException(EventHandler`1<ExceptionEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_OnActionException(EventHandler`1<ExceptionEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_OnSchedulerException(EventHandler`1<ExceptionEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_OnSchedulerException(EventHandler`1<ExceptionEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_OnExit(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_OnExit(EventHandler value);
    public sealed virtual bool get_IsActive();
    public sealed virtual bool get_OutOfOrderExecution();
    internal void Queue0(ArtOfAction action);
    public sealed virtual void Queue(Action action);
    public bool PumpUntil(TimeSpan timeout, Func`1<bool> condition);
}
public class JetBrains.Rd.ClientId : ValueType {
    private static ILogger Log;
    [NotNullAttribute]
public string Value;
    [NotNullAttribute]
private string myDescription;
    public static AbsenceBehavior AbsenceBehaviorValue;
    public static ClientId LocalId;
    public static RdContext`1<string> Context;
    public static CtxReadDelegate`1<ClientId> ReadDelegate;
    public static CtxWriteDelegate`1<ClientId> WriteDelegate;
    public static ClientId Current { get; }
    [CanBeNullAttribute]
public static Nullable`1<ClientId> CurrentOrNull { get; }
    public ClientId(string value);
    private static ClientId();
    public virtual string ToString();
    public static IDisposable CreateCookie(Nullable`1<ClientId> clientId);
    public static ClientId get_Current();
    public static Nullable`1<ClientId> get_CurrentOrNull();
    public sealed virtual bool Equals(ClientId other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(ClientId left, ClientId right);
    public static bool op_Inequality(ClientId left, ClientId right);
}
[ExtensionAttribute]
public static class JetBrains.Rd.ClientIdEx : object {
    [ExtensionAttribute]
public static bool IsLocal(ClientId clientId);
}
public interface JetBrains.Rd.VirtualIndents.IVirtualIndentingHighlighting {
    public int RelativeSpaces { get; }
    public int AbsoluteSpaces { get; }
    public bool OnEmptyBlankLine { get; }
    public bool HasParent { get; }
    public int StartOffset { get; }
    public int ParentStartOffSet { get; }
    public bool OnlyFixForInlayHints { get; }
    public string RealSpaces { get; }
    public abstract virtual int get_RelativeSpaces();
    public abstract virtual int get_AbsoluteSpaces();
    public abstract virtual bool get_OnEmptyBlankLine();
    public abstract virtual bool get_HasParent();
    public abstract virtual int get_StartOffset();
    public abstract virtual int get_ParentStartOffSet();
    public abstract virtual bool get_OnlyFixForInlayHints();
    public abstract virtual string get_RealSpaces();
}
[ExtensionAttribute]
public static class JetBrains.Reflection.ReflectionExtensions : object {
    public static Assembly Mscorlib;
    private static ReflectionExtensions();
    public static object ParseInvariantString(string value, Type type, ILogger logger);
    public static T ParseInvariantString(string value, ILogger logger);
    [NotNullAttribute]
public static string ToInvariantString(object value, ILogger logger);
    [ExtensionAttribute]
public static T GetDynamicField(object obj, string sFieldName, OnError onerror);
    [ExtensionAttribute]
public static object GetDynamicField(object obj, string sFieldName, OnError onerror);
    [ExtensionAttribute]
public static T GetDynamicProperty(object reflectedObject, string propertyName, OnError onerror);
    [ExtensionAttribute]
public static object GetDynamicProperty(object reflectedObject, string propertyName, OnError onerror);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use GetDynamicFieldOrProperty, it has more advanced base types traversing and checks.")]
public static object GetFieldOrPropertyValue(object host, string fieldName);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static PropertyInfo TryGetProperty(Type type, string propertyName, bool isRequireRead, bool isRequireWrite);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static FieldInfo TryGetField(Type type, string sFieldName);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use GetDynamicFieldOrProperty, it has more advanced base types traversing and checks.")]
public static TValue GetFieldOrPropertyValue(object host, string fieldName);
    [ExtensionAttribute]
[ObsoleteAttribute("InvokeDynamicMethodInfo uses more advanced lookup and error handling.")]
public static object InvokeDynamicMethod(object reflectedObject, string sMethodName, Object[] args);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static T InvokeDynamicMethodInfo(object reflectedObject, string sMethodName, OnError onerror, Object[] args);
    [ExtensionAttribute]
public static object InvokeDynamicMethodInfo(object reflectedObject, string sMethodName, OnError onerror, Object[] args);
    [ExtensionAttribute]
public static void SetDynamicProperty(object reflectedObject, string propertyName, object value);
    [ExtensionAttribute]
public static void SetDynamicFieldOrProperty(object thіs, string membername, object value, OnError onerror);
    [ExtensionAttribute]
public static void SetDynamicFieldOrProperty(object thіs, Type type, string membername, object value, OnError onerror);
    [ExtensionAttribute]
public static object GetDynamicFieldOrProperty(object thіs, string membername, OnError onerror);
    [IteratorStateMachineAttribute("JetBrains.Reflection.ReflectionExtensions/<EnumRelatedTypesForReflection>d__18")]
[ExtensionAttribute]
private static IEnumerable`1<Type> EnumRelatedTypesForReflection(Type type, bool isOmitSystemObject);
    [IteratorStateMachineAttribute("JetBrains.Reflection.ReflectionExtensions/<GetBaseClassesAndInterfaces>d__19")]
[ExtensionAttribute]
public static IEnumerable`1<Type> GetBaseClassesAndInterfaces(Type type);
    [ExtensionAttribute]
[NotNullAttribute]
public static IEnumerable`1<Type> GetAllAssignableToTypes(Type type);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static string GetInstanceMemberName(Expression`1<Func`2<TContainingType, object>> lambdaexpression);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static string GetStaticMemberName(Expression`1<Func`1<object>> lambdaexpression);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static MemberInfo GetInstanceMember(Expression`1<Func`2<TContainingType, object>> lambdaexpression);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static MemberInfo GetStaticMember(Expression`1<Func`1<object>> lambdaexpression);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static string GetInstanceMemberName(Expression`1<Func`2<TContainingType, TMemberValue>> lambdaexpression);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static string GetInstanceMemberName(LambdaExpression lambdaexpression);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static MemberInfo GetInstanceMemberInfo(LambdaExpression lambdaexpression);
    [NotNullAttribute]
public static LambdaExpression CreateFieldAccessExpression(string fieldName);
    [NotNullAttribute]
public static Expression`1<Func`2<TContainingType, TResultType>> CreateTypedFieldAccessExpression(string fieldName);
    [ExtensionAttribute]
[NotNullAttribute]
public static MemberInfo GetInstanceMember(Expression`1<Func`2<TContainingType, TMemberValue>> lambdaexpression);
    [NotNullAttribute]
private static MemberInfo GetInstanceMemberCore(Expression expression);
    [IteratorStateMachineAttribute("JetBrains.Reflection.ReflectionExtensions/<GetInstanceMembersChain>d__33")]
[ExtensionAttribute]
[ItemNotNullAttribute]
[NotNullAttribute]
public static IEnumerable`1<MemberInfo> GetInstanceMembersChain(Expression expression);
    [NotNullAttribute]
public static JetHashSet`1<Assembly> AddAssemblyReferencesTransitively(IEnumerable`1<Assembly> assemblies);
    public static void SubscribeToEvent(Lifetime lifetime, object instance, string eventName, Action cal);
    public static void SubscribeToEventHandler(Lifetime lifetime, TEventOwner instanceUnlessStatic, string eventname, EventHandler`1<TEventArgs> handler);
}
[ExtensionAttribute]
public static class JetBrains.Reflection.StringConversion : object {
    [ThreadStaticAttribute]
private static Dictionary`2<Type, TypeConverter> myMapTypeConverters;
    [ThreadStaticAttribute]
private static Dictionary`2<Type, ValueSerializer> myMapValueSerializers;
    [NotNullAttribute]
public static string ToInvariantString(object value, ILogger logger);
    public static object ParseInvariantString(string value, Type type, ILogger logger);
    public static T ParseInvariantString(string value, ILogger logger);
    [ExtensionAttribute]
[NotNullAttribute]
public static ILogger GetSomeLogger(ITypeDescriptorContext thіs);
    [NotNullAttribute]
private static TypeConverter GetTypeConverter(Type type);
    [CanBeNullAttribute]
private static ValueSerializer TryGetValueSerializer(Type typeValue);
}
[ExtensionAttribute]
public static class JetBrains.StringEx : object {
    [ExtensionAttribute]
public static T ToEnum(string s, bool ignoreCase);
    [ExtensionAttribute]
public static T ToEnum(string s, T defaultValue, bool ignoreCase);
    [ExtensionAttribute]
public static T ToEnumSafe(string s, T defaultValue, bool ignoreCase);
    [ExtensionAttribute]
public static Nullable`1<T> ToEnumNullable(string s);
    [ExtensionAttribute]
public static Nullable`1<T> ToEnumNullableSafe(string s, Nullable`1<T> defaultValue, bool ignoreCase);
    [ExtensionAttribute]
[NotNullAttribute]
public static string AppendLine(string s, string line);
    [ExtensionAttribute]
public static bool Contains(string s, char value);
    [ExtensionAttribute]
[NotNullAttribute]
[StringFormatMethodAttribute("format")]
public static string FormatEx(string format, Object[] args);
    [ExtensionAttribute]
[NotNullAttribute]
[StringFormatMethodAttribute("format")]
public static string FormatNoInline(string format, Object[] args);
    [ExtensionAttribute]
public static string SubstringOrEmpty(string s, int start, int length);
    [ExtensionAttribute]
[PureAttribute]
public static string ReplaceRange(string s, int start, int length, string replacement);
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Text.ArrayBuffer : object {
    private static int GapSize;
    private Char[] myBuffer;
    private int myLength;
    private string myText;
    public Char[] Buffer { get; }
    public int Length { get; }
    public char Item { get; }
    public ArrayBuffer(string text);
    public ArrayBuffer(IBuffer buf);
    public ArrayBuffer(Char[] buf);
    public Char[] get_Buffer();
    public sealed virtual int get_Length();
    public sealed virtual string GetText(TextRange range);
    public sealed virtual void AppendTextTo(StringBuilder builder, TextRange range);
    public sealed virtual string GetText();
    public sealed virtual void Insert(int offset, string text);
    public sealed virtual void Remove(int offset, int length);
    public sealed virtual void Replace(int offset, int length, string newText);
    public sealed virtual void Replace(int offset, int length, BufferRange newText);
    public sealed virtual char get_Item(int index);
    public sealed virtual void CopyTo(int sourceIndex, Char[] destinationArray, int destinationIndex, int length);
    private void EnsureCharArray(int capacity);
    [ConditionalAttribute("JET_MODE_ASSERT")]
private void AssertOffsetAndLength(int offset, int length);
    private void ThrowRangeException(int offset, int length);
    private void ThrowLengthException(int offset, int length);
}
public class JetBrains.Text.BufferRange : ValueType {
    private IBuffer myBuffer;
    private TextRange myRange;
    public IBuffer Buffer { get; }
    public TextRange Range { get; }
    public BufferRange(IBuffer buffer, TextRange range);
    public IBuffer get_Buffer();
    public TextRange get_Range();
    [NotNullAttribute]
[PureAttribute]
public string GetText();
    public void CopyTo(Char[] destinationArray, int destinationIndex);
}
public class JetBrains.Text.BufferTextReader : TextReader {
    private IBuffer myBuffer;
    private int myPosition;
    public BufferTextReader(IBuffer buffer);
    public virtual int Peek();
    public virtual int Read();
    public virtual int Read(Char[] buffer, int index, int count);
    public virtual string ReadToEnd();
}
[ExtensionAttribute]
public static class JetBrains.Text.BufferUtil : object {
    [ExtensionAttribute]
public static int IndexOfAny(IBuffer buffer, Char[] chars, int startIndex);
    [ExtensionAttribute]
public static int IndexOf(IBuffer buffer, string pattern, int startIndex, int count);
    [ExtensionAttribute]
public static int LastIndexOfAny(IBuffer buffer, Char[] chars, int startIndex);
    [ExtensionAttribute]
public static int LastIndexOf(IBuffer buffer, string pattern, int startIndex);
    [ExtensionAttribute]
public static bool CompareBufferText(IBuffer buffer, TextRange range, string str, bool caseSensitive);
    [ExtensionAttribute]
public static bool StartsWith(IBuffer buffer, string str, bool caseSensitive);
    [ExtensionAttribute]
public static bool EndsWith(IBuffer buffer, string str, bool caseSensitive);
    [ExtensionAttribute]
public static void Replace(IEditableBuffer this, TextRange range, string newtext);
    [ExtensionAttribute]
public static void Remove(IEditableBuffer this, TextRange range);
}
[DefaultMemberAttribute("Item")]
public interface JetBrains.Text.IBuffer {
    public char Item { get; }
    public int Length { get; }
    public abstract virtual char get_Item(int index);
    public abstract virtual int get_Length();
    [NotNullAttribute]
[PureAttribute]
public abstract virtual string GetText();
    [NotNullAttribute]
[PureAttribute]
public abstract virtual string GetText(TextRange range);
    public abstract virtual void AppendTextTo(StringBuilder builder, TextRange range);
    public abstract virtual void CopyTo(int sourceIndex, Char[] destinationArray, int destinationIndex, int length);
}
public interface JetBrains.Text.IEditableBuffer {
    public abstract virtual void Insert(int offset, string text);
    public abstract virtual void Remove(int offset, int length);
    public abstract virtual void Replace(int offset, int length, string newText);
    public abstract virtual void Replace(int offset, int length, BufferRange newText);
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Text.ProjectedBuffer : object {
    private IBuffer myUnderlyingBuffer;
    private TextRange myRange;
    public int Length { get; }
    public int TextStartOffset { get; }
    public int TextEndOffset { get; }
    public char Item { get; }
    private ProjectedBuffer(IBuffer underlyingBuffer, TextRange range);
    public static IBuffer Create(IBuffer underlyingBuffer, TextRange range);
    public sealed virtual int get_Length();
    public int get_TextStartOffset();
    public int get_TextEndOffset();
    public sealed virtual string GetText();
    public sealed virtual string GetText(TextRange range);
    public sealed virtual void AppendTextTo(StringBuilder builder, TextRange range);
    public sealed virtual char get_Item(int index);
    public sealed virtual void CopyTo(int sourceIndex, Char[] destinationArray, int destinationIndex, int length);
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Text.StringBuffer : object {
    public static StringBuffer Empty;
    private string myString;
    public int Length { get; }
    public char Item { get; }
    public StringBuffer(string string);
    private static StringBuffer();
    public sealed virtual int get_Length();
    public sealed virtual string GetText();
    public sealed virtual string GetText(TextRange range);
    public sealed virtual void AppendTextTo(StringBuilder builder, TextRange range);
    public sealed virtual char get_Item(int index);
    public sealed virtual void CopyTo(int sourceIndex, Char[] destinationArray, int destinationIndex, int length);
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Text.StringBuilderBuffer : object {
    public static StringBuilderBuffer Empty;
    private StringBuilder myString;
    public int Length { get; }
    public char Item { get; }
    public StringBuilderBuffer(StringBuilder string);
    private static StringBuilderBuffer();
    public sealed virtual int get_Length();
    public sealed virtual string GetText();
    public sealed virtual string GetText(TextRange range);
    public sealed virtual void AppendTextTo(StringBuilder builder, TextRange range);
    public sealed virtual char get_Item(int index);
    public sealed virtual void CopyTo(int sourceIndex, Char[] destinationArray, int destinationIndex, int length);
}
public static class JetBrains.Text.WordUtil : object {
    public static Char[] SpaceDelimeters;
    public static String[] StopStrings;
    private static WordUtil();
    public static bool IsDigit(char c);
    public static bool IsLower(char c);
    public static bool IsLowerOrDigit(char c);
    public static bool IsUpper(char c);
    public static bool IsUpperOrDigit(char c);
    public static bool IsLetter(char c);
    public static bool IsWordChar(char c);
    public static bool IsDelimiter(char c);
    public static bool IsHexDigit(char c);
    public static bool IsStopChar(char c);
    public static TextRange FindRange(IBuffer s, int pos, Predicate`1<char> predicate);
    public static TextRange FindWord(IBuffer s, int pos);
    [CanBeNullAttribute]
public static string TryGetStopStringStartingAtPos(IBuffer s, int pos);
    [CanBeNullAttribute]
public static string TryGetStopStringEndingAtPos(IBuffer s, int pos);
    private static bool MatchesStopString(IBuffer s, int pos, string stopString);
    public static TextRange FindWordOrStopCharRight(IBuffer s, int pos);
    public static TextRange FindWordLeft(IBuffer s, int pos);
    public static TextRange FindWordOrStopCharLeft(IBuffer s, int pos);
    public static TextRange GetNextWord(IBuffer s, int pos);
    public static TextRange GetPrevWord(IBuffer buffer, int pos);
}
public class JetBrains.Threading.AsyncBehaviorIsProhibitedException : InvalidOperationException {
    public AsyncBehaviorIsProhibitedException(string message);
}
public enum JetBrains.Threading.DispatcherOperationStatus : Enum {
    public int value__;
    public static DispatcherOperationStatus Pending;
    public static DispatcherOperationStatus Aborted;
    public static DispatcherOperationStatus Completed;
    public static DispatcherOperationStatus Executing;
}
public class JetBrains.Threading.GroupingEvent : object {
    private long myDeadline;
    [CanBeNullAttribute]
private Action myFHandler;
    private GroupingEventHost myHost;
    [CanBeNullAttribute]
private ISimpleSignal myIncoming;
    [CanBeNullAttribute]
private ISimpleSignal myIncomingDontProlongate;
    private TimeSpan myInterval;
    private bool myIsExecuting;
    private IProperty`1<bool> myLazyIsWaiting;
    private SpinWaitLock myLockOutgoingField;
    [NotNullAttribute]
private string myName;
    [CanBeNullAttribute]
private ISimpleSignal modreq(System.Runtime.CompilerServices.IsVolatile) myOutgoing;
    public static TimeSpan MaxInterval;
    private Lifetime myLifetime;
    [NotNullAttribute]
public GroupingEventHost Host { get; }
    [NotNullAttribute]
public ISimpleSignal Incoming { get; }
    [NotNullAttribute]
public ISimpleSignal IncomingDontProlongate { get; }
    public TimeSpan Interval { get; }
    [NotNullAttribute]
public string Name { get; }
    [NotNullAttribute]
public ISimpleSignal Outgoing { get; }
    internal GroupingEvent(Lifetime lifetime, GroupingEventHost host, string name, TimeSpan interval, Action FFirstHandler);
    private static GroupingEvent();
    public GroupingEventHost get_Host();
    public ISimpleSignal get_Incoming();
    public ISimpleSignal get_IncomingDontProlongate();
    public TimeSpan get_Interval();
    public string get_Name();
    public ISimpleSignal get_Outgoing();
    public void CancelIncoming();
    public IProperty`1<bool> CreateIsWaitingProperty();
    public void FireIncoming();
    public void FireIncomingDontProlongate();
    public bool IsWaiting();
    internal void Execute();
    internal bool IsExpired(long datetimeNow);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
private void <.ctor>b__11_0();
    [CompilerGeneratedAttribute]
private void <.ctor>b__11_1();
    [CompilerGeneratedAttribute]
private void <.ctor>b__11_2();
}
public class JetBrains.Threading.GroupingEventHost : object {
    private Lifetime myLifetime;
    [CompilerGeneratedAttribute]
private ILogger <Logger>k__BackingField;
    [NotNullAttribute]
private ClockTimer myClockTimer;
    private int myDebugTotalEvents;
    private int myDebugTotalThroughput;
    private List`1<GroupingEvent> myEvents;
    private LocalReentrancyGuard myExecuteExpiredEventsLocalGuard;
    private bool myIsWaitingOnReentrancyGuard;
    private SpinWaitLock myLock;
    private GroupingEvent myWatchdogEvent;
    [CanBeNullAttribute]
public ReentrancyGuard ReentrancyGuard;
    [NotNullAttribute]
private JetDispatcher Dispatcher;
    [CanBeNullAttribute]
private Traces myTraces;
    public ILogger Logger { get; }
    public GroupingEventHost(Lifetime lifetime, bool isGuarded);
    [CompilerGeneratedAttribute]
public ILogger get_Logger();
    [NotNullAttribute]
public GroupingEvent CreateEvent(Lifetime lifetime, string name, TimeSpan interval, Action FFirstHandler);
    internal void AddEvent(GroupingEvent evt);
    internal void OnDeadlineChanged(GroupingEvent evt);
    internal void RemoveEvent(GroupingEvent evt);
    private void ExecuteExpiredEvents();
    private void OnClockTimerTick();
    [NotNullAttribute]
public Traces EnableDiagnosticTraces(Lifetime lifetime);
    [CompilerGeneratedAttribute]
private void <OnClockTimerTick>b__21_0();
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Threading.GroupingEventHosts : object {
    private Dictionary`2<Rgc, GroupingEventHost> myHosts;
    [NotNullAttribute]
public GroupingEventHost Item { get; }
    public GroupingEventHosts(Lifetime lifetime);
    [NotNullAttribute]
public GroupingEvent CreateEvent(Lifetime lifetime, string name, TimeSpan interval, Rgc guarding, Action FFirstHandler);
    public GroupingEventHost get_Item(Rgc guarding);
}
public class JetBrains.Threading.GuardAttribute : Attribute {
    private Rgc _context;
    public Rgc Context { get; }
    public GuardAttribute(Rgc context);
    public Rgc get_Context();
}
public interface JetBrains.Threading.IPlatformDispatcherImpl {
    public bool IsShutDown { get; }
    public abstract virtual bool get_IsShutDown();
    public abstract virtual void Init(JetDispatcher dispatcher);
    public abstract virtual void ShutDown();
    public abstract virtual DispatcherOperationStatus InvokeAsync(Action action, TaskPriority priority);
    public abstract virtual void Invoke(Action action, TaskPriority priority);
}
public class JetBrains.Threading.JetBarrier : JetBarrier`2<object, object> {
    public JetBarrier(int partiesNumber, Action afterAllPartiesFinishedAction);
}
public class JetBrains.Threading.JetBarrier`1 : JetBarrier`2<TIn, object> {
    public JetBarrier`1(int partiesNumber, Action`1<TIn> afterAllPartiesFinishedAction);
}
public class JetBrains.Threading.JetBarrier`2 : object {
    private int myPartiesNumber;
    private Func`2<TIn, TOut> myAfterAllPartiesFinishedFunction;
    private TIn myCumulativeInput;
    private TOut myOutput;
    private object myLock;
    private int myCurrentPartiesSignaled;
    public TIn CumulativeInput { get; }
    public TOut Output { get; }
    public JetBarrier`2(int partiesNumber, Action afterAllPartiesFinishedAction);
    public JetBarrier`2(int partiesNumber, Action`1<TIn> afterAllPartiesFinishedAction);
    public JetBarrier`2(int partiesNumber, Func`2<TIn, TOut> afterAllPartiesFinishedFunction);
    public TIn get_CumulativeInput();
    public TOut get_Output();
    public void Signal(bool awaitForAllParties, int numberOfSignals, Func`2<TIn, TIn> inputUpdater, int waitTimeoutMilliseconds);
    public bool IsSignaled();
    public void Wait(int waitTimeoutMilliseconds);
    public void Reset(bool releaseWaitingThreads);
}
public class JetBrains.Threading.JetDispatcher : object {
    private static TaskPriority MinPriorityValue;
    private static IJetDispatcherPlatformSpecific PlatformSpecific;
    private static int OptionCallNativeMarshallerEveryItems;
    private static int OptionCallNativeMarshallerForFirstItems;
    private static SpinWaitLock ourQueueLock;
    [NotNullAttribute]
private static Dictionary`2<Thread, JetDispatcher> ourDispatchers;
    private static SpinWaitLock ourDispatchersWriterLock;
    protected static int OptionQueueReasonableSizeLimit;
    protected static ILogger Logger;
    [NotNullAttribute]
private DispatcherPriorityBucket[] myPriorityBuckets;
    [NotNullAttribute]
public Thread Thread;
    private LocalLazy`1<AsyncBehaviors> myAsyncBehaviors;
    private bool myDontRun;
    [CanBeNullAttribute]
private ExternalIdleProcessing myExternalIdleProcessing;
    private UInt32 modreq(System.Runtime.CompilerServices.IsVolatile) myGeneration;
    private long myPendingTasksCount;
    private static bool ourIsPlatformSpecificSubstituted;
    private bool myIsPlatformImplSubstituted;
    [CompilerGeneratedAttribute]
private IPlatformDispatcherImpl <DispatcherImpl>k__BackingField;
    [NotNullAttribute]
public IPlatformDispatcherImpl DispatcherImpl { get; private set; }
    [NotNullAttribute]
public static JetDispatcher CurrentDispatcher { get; }
    public bool IsAsyncBehaviorProhibited { get; }
    [NotNullAttribute]
[ObsoleteAttribute("Use IsAsyncBehaviorAllowed.")]
public IProperty`1<bool> AsyncBehaviorAllowed { get; }
    [NotNullAttribute]
public IProperty`1<bool> IsAsyncBehaviorAllowed { get; }
    public bool IsShutDown { get; }
    private JetDispatcher(IPlatformDispatcherImpl dispatcherImpl);
    private static JetDispatcher();
    [CompilerGeneratedAttribute]
public IPlatformDispatcherImpl get_DispatcherImpl();
    [CompilerGeneratedAttribute]
private void set_DispatcherImpl(IPlatformDispatcherImpl value);
    public static JetDispatcher get_CurrentDispatcher();
    public static ITimer CreateDispatcherTimer();
    public static ITimer CreateDispatcherTimer(int interval);
    public bool get_IsAsyncBehaviorProhibited();
    public IProperty`1<bool> get_AsyncBehaviorAllowed();
    public IProperty`1<bool> get_IsAsyncBehaviorAllowed();
    public bool get_IsShutDown();
    [ConditionalAttribute("NEVER")]
public static void AssertFreeThreaded();
    [NotNullAttribute]
public static JetDispatcher CreateDispatcherThread(Lifetime lifetime, string name);
    [CanBeNullAttribute]
public static JetDispatcher FromThread(Thread thread);
    internal static void ResetForTests();
    public static void SubstitutePlatformSpecific(IJetDispatcherPlatformSpecific platformSpecific);
    public void EnsureSynchronizationContextCaptured();
    private void BeginInvokeSubstitutePlatformSpecific(IJetDispatcherPlatformSpecific platformSpecific);
    private void SubstitutePlatformImpl(IPlatformDispatcherImpl platformDispatcherImpl);
    public static int PumpMessagesOnce();
    public static bool Run(IProperty`1<bool> condition, TimeSpan timeout, bool bThrowOnTimeout);
    public static bool RunOrSleep(IProperty`1<bool> condition, TimeSpan timeout, OnWaitTimeout ontimeout);
    public static bool Run(Func`1<bool> condition, TimeSpan timeout, bool bThrowOnTimeout);
    public static bool RunOrSleep(Func`1<bool> condition, TimeSpan timeout, OnWaitTimeout ontimeout);
    public static bool Run(Task waitUntilDone, TimeSpan timeout, bool bThrowOnTimeout);
    public static bool RunOrSleep(Task waitUntilDone, TimeSpan timeout, OnWaitTimeout ontimeout);
    public static void Run(TimeSpan timeout);
    public static void RunOrSleep(TimeSpan timeout);
    public static void Run();
    private static MessageLoopStatus RunLoopAction(IJetDispatcherPlatformSpecific staticMethods, TimeSpan timeSpan, bool b);
    private static bool RunAndRestartIfNeeded(TimeSpan timeout, bool bThrowOnTimeout, Func`4<IJetDispatcherPlatformSpecific, TimeSpan, bool, MessageLoopStatus> runLoopAction);
    private static bool Sleep(Func`1<bool> condition, TimeSpan timeout, OnWaitTimeout ontimeout);
    public void AssertAccess();
    public void AssertAsyncBehaviorSupported(string context);
    public void BeginInvoke(string name, Action action, TaskPriority priority);
    public void BeginInvoke(Lifetime lifetime, string name, Action action, TaskPriority priority);
    public void BeginOrInvoke(string name, Action action, TaskPriority priority);
    public void BeginOrInvoke(Lifetime lifetime, string name, Action action, TaskPriority priority);
    public void Invoke(string name, Action action, TaskPriority priority);
    public Callbacks SetIdleProcessingExternalDriver(Lifetime lifetime, IDriver driver);
    private Action WrapAndCountDispatcherAction(Action action);
    private void BeginInvokeCore(Closure closure);
    private void BeginInvokeCore_Overflow(int nQueueSize, int nItemsQueuedSinceLastExecution, Queue`1<Closure> queue, TaskPriority priority);
    public void BeginInvokeShutdown();
    private void Shutdown();
    public bool CheckAccess();
    internal static bool CheckAllDispatchersTasksCompletionAndLog(bool throwException);
    public bool CheckTasksCompletionAndLog(bool throwException, bool logAsError);
    public static bool IsSupportedOnThisThread();
    public bool TryEnsureAsyncBehaviorAllowedForever();
    public bool Equals(JetDispatcher jetDispatcher);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    [ConditionalAttribute("JET_MODE_ASSERT")]
private void Ctor_AssertPriorityBucketCount();
    [HandleProcessCorruptedStateExceptionsAttribute]
private bool ProcessQueue(int nMinBucket);
}
public class JetBrains.Threading.JetDispatcherActionException : ApplicationException {
    [NotNullAttribute]
private string myName;
    [NotNullAttribute]
public string Name { get; }
    public JetDispatcherActionException(JetDispatcher dispatcher, string name, Exception ex);
    public string get_Name();
}
[ExtensionAttribute]
public static class JetBrains.Threading.JetDispatcherEx : object {
    [ExtensionAttribute]
public static void ExecuteAsyncIfAllowedOrSync(JetDispatcher dispatcher, Lifetime lifetime, Action`1<Lifetime> asyncAction, Action syncAction, Func`1<bool> extraShouldRunSyncFunc);
    [ExtensionAttribute]
public static void DefineAsyncActionLifetimeOrRunSync(JetDispatcher dispatcher, OuterLifetime outerLifetime, Action`1<LifetimeDefinition> asyncAction, Action syncAction);
    [ExtensionAttribute]
public static TResult DispatcherWaitResult(Task`1<TResult> task, TimeSpan timeout);
    [ExtensionAttribute]
public static void DispatcherWaitResult(Task task, TimeSpan timeout);
    [NotNullAttribute]
public static string GetCallStackAnnotationTypeName(string sActionName);
    [NotNullAttribute]
public static string GetCallStackAnnotationMethodName();
}
public class JetBrains.Threading.JetFastSemiReenterableRWLock : object {
    public static int WriteLockFactorShift;
    public static int ReentrantLockFactorShift;
    public static long WriteLockFactor;
    public static int ReenterLockFactor;
    public static long NoReadLockMask;
    private JetLockState myState;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) myAwaitingWritersCount;
    private static int _processorCount;
    private static int _sleepCount;
    public static int MaxWaitTime;
    public bool IsWriteLockHeld { get; }
    private static JetFastSemiReenterableRWLock();
    public JetFastSemiReenterableRWLockDisposable UsingReadLock();
    public JetFastSemiReenterableRWLockDisposable UsingWriteLock();
    [ConditionalAttribute("JET_MODE_ASSERT")]
private void PushReadLockOwner();
    [ConditionalAttribute("JET_MODE_ASSERT")]
private void AssertReadLockNotTaken(bool needAddReadLock);
    [ConditionalAttribute("JET_MODE_ASSERT")]
private void AssertReadLockTakenAsLastLockAndRelease();
    [ConditionalAttribute("JET_MODE_ASSERT")]
private void AssertThatThreadIsExclusiveOwner(int threadId);
    [ConditionalAttribute("JET_MODE_ASSERT")]
private void AssertLockIsHeld();
    public bool TryAcquireRead();
    public bool TryAcquireWrite();
    public void AcquireRead();
    public void AcquireWrite();
    public void Release();
    private void ReleaseInternal();
    private bool TryEnterReadInternal(long currentThreadId);
    private bool TryEnterWriteInternal(long currentThreadId);
    public bool get_IsWriteLockHeld();
    [ConditionalAttribute("JET_MODE_ASSERT")]
private void WaitTooMuchCheck(Int32& startTime);
    private string StateToString();
    private string StateToString(JetLockState state);
    private static void CalcApprovedProcessorCountAndMaxWaitTime();
    private static void Sleep();
}
public class JetBrains.Threading.MonitorReleaseCookie : ValueType {
    private object myLock;
    private MonitorReleaseCookie(object lock);
    public static MonitorReleaseCookie Create(object lock);
    public sealed virtual void Dispose();
}
public enum JetBrains.Threading.OnWaitTimeout : Enum {
    public int value__;
    public static OnWaitTimeout Fail;
    public static OnWaitTimeout Succeed;
}
public abstract class JetBrains.Threading.PlatformDispatcherImplBase : object {
    protected static UInt32 RunThreadWaitTimeout;
    private JetDispatcher myDispatcher;
    [CompilerGeneratedAttribute]
private bool <IsShutDown>k__BackingField;
    public bool IsShutDown { get; private set; }
    private static PlatformDispatcherImplBase();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsShutDown();
    [CompilerGeneratedAttribute]
private void set_IsShutDown(bool value);
    public virtual void Init(JetDispatcher dispatcher);
    public virtual void ShutDown();
    public abstract virtual DispatcherOperationStatus InvokeAsync(Action action, TaskPriority priority);
    public abstract virtual void Invoke(Action action, TaskPriority priority);
}
public class JetBrains.Threading.ReentracyGuardDiagnosticSettings : object {
    [CompilerGeneratedAttribute]
private bool <CaptureStackTraces>k__BackingField;
    [CompilerGeneratedAttribute]
private PerformanceAssertionSettings <PerformanceAssertions>k__BackingField;
    public static ReentracyGuardDiagnosticSettings Instance;
    public bool CaptureStackTraces { get; private set; }
    public PerformanceAssertionSettings PerformanceAssertions { get; private set; }
    private static ReentracyGuardDiagnosticSettings();
    [CompilerGeneratedAttribute]
public bool get_CaptureStackTraces();
    [CompilerGeneratedAttribute]
private void set_CaptureStackTraces(bool value);
    [CompilerGeneratedAttribute]
public PerformanceAssertionSettings get_PerformanceAssertions();
    [CompilerGeneratedAttribute]
private void set_PerformanceAssertions(PerformanceAssertionSettings value);
    public void SetCaptureStackTraces(Lifetime lifetime, bool value);
    public void SetPerformanceAssertions(Lifetime lifetime, PerformanceAssertionSettings value);
}
public class JetBrains.Threading.ReentrancyGuard : object {
    internal static bool OptionDontSuppressPumping;
    internal static bool OptionTrace;
    private static int myDefaultExternalDriverExecutionLimit;
    public static int OptionQueueReasonableSizeThresholdMask;
    [CanBeNullAttribute]
[ThreadStaticAttribute]
private static ReentrancyGuard myInstance;
    private JetDispatcher myDispatcher;
    [NotNullAttribute]
private ExecutionStack myExecutionStack;
    [NotNullAttribute]
private BlockingPriorityQueue`1<QueuedAction> myQueueActions;
    private bool myIsExecutePendingActionsFromIsExecutingFallingSchedulled;
    [CanBeNullAttribute]
private Traces myTraces;
    private ILogger myLogger;
    [CompilerGeneratedAttribute]
private ISignal`1<string> <NestedExecutionStarted>k__BackingField;
    [CompilerGeneratedAttribute]
private ISignal`1<string> <ActionExecutionCompleted>k__BackingField;
    public ISignal`1<string> NestedExecutionStarted { get; }
    public ISignal`1<string> ActionExecutionCompleted { get; }
    [NotNullAttribute]
public static ReentrancyGuard Current { get; }
    public bool CanExecuteNow { get; }
    [CanBeNullAttribute]
public string CurrentActionName { get; }
    [NotNullAttribute]
public JetDispatcher Dispatcher { get; }
    public bool IsEmpty { get; }
    public bool IsExecuting { get; }
    private static ReentrancyGuard();
    [CompilerGeneratedAttribute]
public ISignal`1<string> get_NestedExecutionStarted();
    [CompilerGeneratedAttribute]
public ISignal`1<string> get_ActionExecutionCompleted();
    public static ReentrancyGuard get_Current();
    public bool get_CanExecuteNow();
    public string get_CurrentActionName();
    public JetDispatcher get_Dispatcher();
    public bool get_IsEmpty();
    public bool get_IsExecuting();
    [HandleProcessCorruptedStateExceptionsAttribute]
public void AllowNestedExecution(string name, Action action);
    public void AssertGuarded();
    [AsyncStateMachineAttribute("JetBrains.Threading.ReentrancyGuard/<CheckPumpingAsync>d__32")]
private Task CheckPumpingAsync(Lifetime checkLifetime, string name, PerformanceAssertionSettings assertionSettings);
    [HandleProcessCorruptedStateExceptionsAttribute]
public void Execute(string name, Action action);
    [CanBeNullAttribute]
[HandleProcessCorruptedStateExceptionsAttribute]
public TResult Execute(string name, TState state, Func`2<TState, TResult> func);
    public bool ExecuteOrQueue(string name, Action action, TaskPriority priority);
    public int PumpQueue(int limit);
    public void Queue(string name, Action action, TaskPriority priority);
    public bool TryExecute(string name, Action action);
    [NotNullAttribute]
public Traces EnableDiagnosticTraces(Lifetime lifetime);
    private void ReportOversizedQueue();
    private void AddExceptionData(Exception ex);
    private void AssertCanExecute(string name);
    private void BeginInvokeExecutePendingActions(bool isCalledFromIsExecutingFalling);
    private void ExecutePendingActions();
    [CompilerGeneratedAttribute]
private void <.ctor>b__11_0();
}
[ExtensionAttribute]
public static class JetBrains.Threading.ReentrancyGuardEx : object {
    [ExtensionAttribute]
public static void Queue(ReentrancyGuard thіs, Lifetime lifetime, string name, Action F, TaskPriority priority);
    [ExtensionAttribute]
public static void Queue(ReentrancyGuard thіs, Lifetime lifetime, string name, Action F);
    [ExtensionAttribute]
public static bool ExecuteOrQueue(ReentrancyGuard thіs, Lifetime lifetime, string name, Action F, TaskPriority priority);
    [ExtensionAttribute]
public static bool ExecuteOrQueue(ReentrancyGuard thіs, Lifetime lifetime, string name, Action F);
    [ExtensionAttribute]
public static bool ExecuteOrQueueOrRunSync(ReentrancyGuard thіs, Lifetime lifetime, string name, Action F, TaskPriority priority);
    [ExtensionAttribute]
public static bool ExecuteOrQueueOrRunSync(ReentrancyGuard thіs, Lifetime lifetime, string name, Action F);
    [ExtensionAttribute]
public static bool ExecuteOrQueueOrRunSync(ReentrancyGuard thіs, string name, Action F, TaskPriority priority);
    [ExtensionAttribute]
public static void QueueOrRunSync(ReentrancyGuard thіs, Lifetime lifetime, string name, Action F, TaskPriority priority);
}
public class JetBrains.Threading.ReentrancyGuardTimer : object {
    [NotNullAttribute]
private Property`1<DateTime> InactiveExecutionTime;
    [NotNullAttribute]
private IProperty`1<bool> IsNotWaitingTimer;
    [NotNullAttribute]
private IProperty`1<bool> IsWinFormsTimerEnabled;
    [NotNullAttribute]
private string myName;
    [NotNullAttribute]
private ReentrancyGuard myReentrancyGuard;
    private ITimer myTimer;
    [NotNullAttribute]
public ObsoleteLifetimeAndDefinitionAtTheSameTime Disposables;
    [NotNullAttribute]
public IProperty`1<TimeSpan> Interval;
    [NotNullAttribute]
public IProperty`1<bool> IsApplicationActive;
    [NotNullAttribute]
public IProperty`1<bool> IsEnabled;
    [NotNullAttribute]
public ISimpleSignal Tick;
    [NotNullAttribute]
public string Name { get; }
    public ReentrancyGuardTimer(string name);
    public string get_Name();
    private void InitDataFlow();
    private void InitLogging();
    private void OnTimerTick();
    private void OnTimerTickReentrantSafe();
    public virtual string ToString();
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
private void <InitDataFlow>b__14_0();
    [CompilerGeneratedAttribute]
private void <InitDataFlow>b__14_2(TimeSpan value);
    [CompilerGeneratedAttribute]
private void <InitDataFlow>b__14_3(bool value);
    [CompilerGeneratedAttribute]
private void <InitDataFlow>b__14_4();
    [CompilerGeneratedAttribute]
private void <InitDataFlow>b__14_5();
    [CompilerGeneratedAttribute]
private void <InitDataFlow>b__14_6(object <p0>, EventArgs <p1>);
}
public enum JetBrains.Threading.Rgc : Enum {
    public int value__;
    public static Rgc NotSpecified;
    public static Rgc Guarded;
    public static Rgc Unguarded;
    public static Rgc Invariant;
    public static Rgc Special;
}
public class JetBrains.Threading.ThreadAccessException : ApplicationException {
    [CanBeNullAttribute]
private Thread myThreadDesired;
    [NotNullAttribute]
private Thread myThreadWrong;
    [CanBeNullAttribute]
public Thread ThreadDesired { get; }
    [NotNullAttribute]
public Thread ThreadWrong { get; }
    public ThreadAccessException(Thread threadDesired);
    public Thread get_ThreadDesired();
    public Thread get_ThreadWrong();
}
public class JetBrains.Threading.ThreadManager : object {
    [CompilerGeneratedAttribute]
private static ThreadManager <Instance>k__BackingField;
    private SynchronizedSet`1<JetDispatcher> myStas;
    public static ThreadManager Instance { get; }
    [CanBeNullAttribute]
public JetDispatcher StaExecutor { get; }
    private static ThreadManager();
    [CompilerGeneratedAttribute]
public static ThreadManager get_Instance();
    public static WaitCountSyncContextCookie WaitingThreadsCookie();
    public JetDispatcher get_StaExecutor();
    public void AllowStaExecutor(Lifetime lifetime);
    [ObsoleteAttribute("Deprecated API, consider usage of myThreading.TaskHost.RunSafe() for CPU-bound tasks and ThreadManager.RunSafe() for IO-bound tasks")]
public void ExecuteTask(Action action, ApartmentState apartmentState);
    public static void RunSafe(Action action);
}
public class JetBrains.Threading.TimedActionsHost : object {
    [NotNullAttribute]
private Lifetime myLifetime;
    private UInt32 myGeneration;
    [NotNullAttribute]
private ReentrancyGuard myReentrancyGuard;
    [NotNullAttribute]
private CollectionEvents`1<TimedAction> myTimedActions;
    [NotNullAttribute]
private ITimer myTimer;
    [NotNullAttribute]
private Property`1<DateTime> NearestDeadline;
    [NotNullAttribute]
private SimpleSignal NearestDeadlineGottenDirty;
    [NotNullAttribute]
public IProperty`1<bool> IsApplicationActive;
    [NotNullAttribute]
private JetDispatcher myDispatcher;
    [NotNullAttribute]
public ReentrancyGuard ReentrancyGuard { get; }
    [NotNullAttribute]
public JetDispatcher Dispatcher { get; }
    [NotNullAttribute]
private IEnumerable`1<TimedAction> EligibleTimedActions { get; }
    public TimedActionsHost(Lifetime lifetime);
    public ReentrancyGuard get_ReentrancyGuard();
    public JetDispatcher get_Dispatcher();
    public void Queue(Lifetime lifetime, string name, Action action, TimeSpan interval, Recurrence recurrence, Rgc guarding);
    private IEnumerable`1<TimedAction> get_EligibleTimedActions();
    private void InitDataFlow();
    private void OnTimerTick();
    [CompilerGeneratedAttribute]
private bool <get_EligibleTimedActions>b__16_0(TimedAction ta);
    [CompilerGeneratedAttribute]
private void <InitDataFlow>b__17_0();
    [CompilerGeneratedAttribute]
private void <InitDataFlow>b__17_1(Lifetime lifetime, bool isAsync);
    [CompilerGeneratedAttribute]
private void <InitDataFlow>b__17_2();
    [CompilerGeneratedAttribute]
private void <InitDataFlow>b__17_3(PropertyChangedEventArgs`1<DateTime> args);
    [CompilerGeneratedAttribute]
private void <InitDataFlow>b__17_4(object <p0>, EventArgs <p1>);
    [CompilerGeneratedAttribute]
private void <InitDataFlow>b__17_5(Lifetime lifetime, bool isAsync);
    [CompilerGeneratedAttribute]
private void <InitDataFlow>b__17_6(Lifetime lifeTa, TimedAction ta);
}
public class JetBrains.Threading.WeakTimer : object {
    private LifetimeDefinition myLifetimeDefinition;
    public IProperty`1<TimeSpan> Interval;
    public IProperty`1<bool> IsEnabled;
    public ISimpleSignal Tick;
    private ITimer myStrongTimer;
    public WeakTimer(Lifetime lifetime);
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
private void <.ctor>b__5_0();
    [CompilerGeneratedAttribute]
private void <.ctor>b__5_1(PropertyChangedEventArgs`1<TimeSpan> args);
    [CompilerGeneratedAttribute]
private void <.ctor>b__5_2(PropertyChangedEventArgs`1<bool> args);
}
public class JetBrains.UI.Application.LocalReentrancyGuard : object {
    private int myHasEntered;
    public bool TryExecute(Action action);
    public void Execute(Action action);
}
public class JetBrains.UI.Application.LogEventListener : object {
    private string myIdentity;
    private Action`1<LogEvent> myFOnEvent;
    private int myNoReentrancy_HasEntered;
    [CompilerGeneratedAttribute]
private EventHandler`1<EventArgs`1<Exception>> OnException;
    [CompilerGeneratedAttribute]
private EventHandler`1<EventArgs`1<Tuple`2<string, LoggingLevel>>> OnMessage;
    [CompilerGeneratedAttribute]
private EventHandler`1<EventArgs`1<LogEvent>> OnLogEvent;
    [CompilerGeneratedAttribute]
private ILayout <Layout>k__BackingField;
    [NotNullAttribute]
public string Identity { get; }
    public ILayout Layout { get; public set; }
    public LogEventListener(string identity, Action`1<LogEvent> FOnEvent);
    public string get_Identity();
    public static bool op_Equality(LogEventListener left, LogEventListener right);
    public static bool op_Inequality(LogEventListener left, LogEventListener right);
    [CompilerGeneratedAttribute]
public void add_OnException(EventHandler`1<EventArgs`1<Exception>> value);
    [CompilerGeneratedAttribute]
public void remove_OnException(EventHandler`1<EventArgs`1<Exception>> value);
    [CompilerGeneratedAttribute]
public void add_OnMessage(EventHandler`1<EventArgs`1<Tuple`2<string, LoggingLevel>>> value);
    [CompilerGeneratedAttribute]
public void remove_OnMessage(EventHandler`1<EventArgs`1<Tuple`2<string, LoggingLevel>>> value);
    [CompilerGeneratedAttribute]
public void add_OnLogEvent(EventHandler`1<EventArgs`1<LogEvent>> value);
    [CompilerGeneratedAttribute]
public void remove_OnLogEvent(EventHandler`1<EventArgs`1<LogEvent>> value);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(LogEventListener other);
    [CompilerGeneratedAttribute]
public ILayout get_Layout();
    [CompilerGeneratedAttribute]
public void set_Layout(ILayout value);
    private sealed virtual override void JetBrains.Util.ILogEventListener.OnLogEvent(LogEvent logEvent);
}
public class JetBrains.Util.AntPatternState : ValueType {
    private Wildcard[] myPatternParts;
    private FrugalLocalList`1<int> myPatternPositions;
    private static FrugalLocalList`1<int> ourEmptyPatternPositions;
    public FrugalLocalList`1<int> PatternPositions { get; }
    public AntPatternState(Wildcard[] patternParts, FrugalLocalList`1<int> patternPositions);
    public AntPatternState(Wildcard[] patternParts);
    private static AntPatternState();
    public FrugalLocalList`1<int> get_PatternPositions();
    public AntPatternState Enter(StringSlice component, MatchResult& match);
}
public class JetBrains.Util.AntPatternUtil : object {
    private static string NormalizePatternString(string pattern);
    public static bool IsFileNameMatch(string pattern, string name);
    public static Wildcard[] ParsePattern(string pattern, bool caseSensitive, bool removeTwoDots);
    private static Wildcard[] ParsePatternSlow(string pattern, bool caseSensitive, bool removeTwoDots);
    private static void RemoveOneDot(List`1<Wildcard> wildcards);
    private static void RemoveTwoDots(List`1<Wildcard> wildcards);
}
[ExtensionAttribute]
public static class JetBrains.Util.ArrayUtil : object {
    private static int hexcharsPerByte;
    public static UInt32 MurmurHashSeed;
    private static ArrayUtil();
    public static int GetHashCode(T[] array);
    public static int StructuralGetHashCode(T[] array);
    public static int StructuralGetHashCode(ImmutableArray`1<T> array);
    public static int GetHashCode(T[] array, IEqualityComparer`1<T> comparer);
    public static int StructuralGetHashCode(T[] array, IEqualityComparer`1<T> comparer);
    public static int StructuralGetHashCode(ImmutableArray`1<T> array, IEqualityComparer`1<T> comparer);
    [ObsoleteAttribute("Use StructuralEquals to signify you're deep-comparing the array contents. Reusing the Equals name is dangerous of switching to shallow-comparing when code is refactored.")]
public static bool Equals(Array array1, Array array2);
    [ObsoleteAttribute("Use StructuralEquals to signify you're deep-comparing the array contents. Reusing the Equals name is dangerous of switching to shallow-comparing when code is refactored.")]
public static bool Equals(Array array1, Array array2, IEqualityComparer`1<object> comparer);
    public static bool StructuralEquals(Array array1, Array array2, IEqualityComparer`1<object> comparer);
    [ObsoleteAttribute("Use StructuralEquals to signify you're deep-comparing the array contents. Reusing the Equals name is dangerous of switching to shallow-comparing when code is refactored.")]
public static bool Equals(T[] array1, T[] array2);
    public static bool StructuralEquals(T[] array1, T[] array2);
    [ObsoleteAttribute("Use StructuralEquals to signify you're deep-comparing the array contents. Reusing the Equals name is dangerous of switching to shallow-comparing when code is refactored.")]
public static bool Equals(T[] array1, T[] array2, IEqualityComparer`1<T> comparer);
    public static bool StructuralEquals(T[] array1, T[] array2, IEqualityComparer`1<T> comparer);
    public static bool StructuralEquals(ImmutableArray`1<T> array1, ImmutableArray`1<T> array2, IEqualityComparer`1<T> comparer);
    [ObsoleteAttribute("Use StructuralEquals to signify you're deep-comparing the array contents. Reusing the Equals name is dangerous of switching to shallow-comparing when code is refactored.")]
public static bool Equals(T[] array1, int offset1, T[] array2, int offset2, int count, IEqualityComparer`1<T> comparer);
    public static bool StructuralEquals(T[] array1, int offset1, T[] array2, int offset2, int count, IEqualityComparer`1<T> comparer);
    public static int GetHashCode(IEnumerable`1<T> array);
    public static int StructuralGetHashCode(IEnumerable`1<T> array);
    public static int GetHashCode(FrugalLocalList`1<T> array);
    public static int StructuralGetHashCode(FrugalLocalList`1<T> array);
    public static int StructuralCompare(T[] x, T[] y, Comparer`1<T> itemcomparer);
    public static int StructuralCompare(ImmutableArray`1<T> x, ImmutableArray`1<T> y, Comparer`1<T> itemcomparer);
    [ExtensionAttribute]
public static int IndexOf(T[] array, T value, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static bool Contains(T[] array, T value, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
[PureAttribute]
public static T[] GrowBy(T[] array, int increment);
    [PureAttribute]
public static T[] Add(T element, T[] array);
    [PureAttribute]
public static T[] Add(T element, T[] array, int start, int length);
    [PureAttribute]
public static T[] Add(T[] array, T element);
    [PureAttribute]
public static T[] AddRange(T[] array, IEnumerable`1<T> items);
    [PureAttribute]
public static T[] AddRange(T[] array, T[] items);
    [PureAttribute]
public static T[] AddRange(T[] array, ICollection`1<T> items);
    [PureAttribute]
public static T[] InsertAt(T[] array, T element, int position);
    [PureAttribute]
public static T[] Add(T[] array1, T[] array2);
    [NotNullAttribute]
[PureAttribute]
public static T[] Remove(T[] array, T element);
    [NotNullAttribute]
[PureAttribute]
public static T[] Remove(T[] array, T element, IEqualityComparer`1<T> equator);
    [NotNullAttribute]
[PureAttribute]
public static T[] RemoveAll(T[] array, T element);
    [NotNullAttribute]
[PureAttribute]
public static T[] RemoveWhere(T[] array, Predicate`1<T> match);
    [PureAttribute]
[NotNullAttribute]
public static T[] RemoveAt(T[] array, int index);
    [PureAttribute]
[NotNullAttribute]
public static Type[] RemoveAt(Type[] typesOfEmittedMethodParams, Index index);
    [ExtensionAttribute]
[PureAttribute]
public static TOuter[] Convert(TInner[] inner, Func`2<TInner, TOuter> converter);
    [ExtensionAttribute]
[PureAttribute]
public static T[] CopySegment(T[] array, int startIndex, int length);
    [ExtensionAttribute]
[PureAttribute]
public static T[] CopySegment(T[] array, int startIndex);
    [ExtensionAttribute]
public static void Sort(T[] array, Comparison`1<T> comparison);
    [NotNullAttribute]
public static string ToHexString(Byte[] buffer);
    [NotNullAttribute]
public static string ToHexString(ImmutableArray`1<byte> buffer);
    [NotNullAttribute]
public static Byte[] FromHexString(string hex);
    public static int MurmurHash3(Byte* pData, int nLen, UInt32 seed);
    public static int BinarySearchGoodBounds(UnsafeIntArray array, int lo, int hi, int val);
    [ExtensionAttribute]
public static int BinarySearch(UnsafeIntArray array, int lo, int hi, int val);
    [ExtensionAttribute]
public static int BinarySearch(UnsafeIntArray array, int val);
    private static void Swap(UnsafeIntArray a, int i, int j);
    private static void Sort0(UnsafeIntArray a, int lo, int hi);
    [ExtensionAttribute]
public static void Sort(UnsafeIntArray array, int lo, int hi);
    [ExtensionAttribute]
public static void Sort(UnsafeIntArray array);
    [ExtensionAttribute]
public static int DistinctSorted(UnsafeIntArray arr);
    [ExtensionAttribute]
[ObsoleteAttribute("This is a very suboptimal impl for an int* array. Branching inside loop, re-reading same item, using get_Item instead of memory access by pointer, etc.")]
public static bool IsSorted(UnsafeIntArray arr, bool strict);
    [ExtensionAttribute]
public static Int32[] Subarray(Int32[] arr, int start, int length);
    public static bool StartsWith(Byte[] master, Byte[] prefix);
    [ExtensionAttribute]
[NotNullAttribute]
public static T[] WhereNotNull(T[] arr);
    [ExtensionAttribute]
[NotNullAttribute]
public static T[] WhereNotNull(Nullable`1[] arr);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static ImmutableArray`1<T> WhereNotNull(ImmutableArray`1<T> arr);
    [ExtensionAttribute]
public static ImmutableArray`1<T> WhereNotNull(ImmutableArray`1<Nullable`1<T>> arr);
    public static void InterlockedAdd(T[]& arr, T item);
    public static void InterlockedRemove(T[]& arr, T item, IEqualityComparer`1<T> equator);
    [ExtensionAttribute]
public static ImmutableArray`1<TItem> MoveOrCopyToImmutableArray(Builder<TItem> builder);
    [ExtensionAttribute]
public static ImmutableArray`1<TItem> Flatten(ImmutableArray`1<ImmutableArray`1<TItem>> nested);
}
public class JetBrains.Util.AssertionModeInitializer : object {
    [ModuleInitializerAttribute]
internal static void Init();
}
public abstract class JetBrains.Util.AsyncLogEventListener : object {
    private LifetimeDefinition myLifetimeDef;
    protected Lifetime Lifetime;
    private ByteBufferAsyncProcessor myAsyncProcessor;
    [CompilerGeneratedAttribute]
private ILayout <Layout>k__BackingField;
    public ILayout Layout { get; public set; }
    protected AsyncLogEventListener(string id);
    [CompilerGeneratedAttribute]
public sealed virtual ILayout get_Layout();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Layout(ILayout value);
    protected virtual void WriteLogEvent(UnsafeWriter writer, LogEvent logEvent);
    protected virtual void ProcessBytes(Byte[] bytes, int offset, int size, Int64& _);
    protected abstract virtual void ProcessChars(Char* chars, int size);
    public sealed virtual void OnLogEvent(LogEvent logEvent);
    public sealed virtual void Dispose();
}
[TypeConverterAttribute("JetBrains.Util.BackSlashSeparatedRelativePathConverter")]
[ValueSerializerAttribute("JetBrains.Util.BackSlashSeparatedRelativePathSerializer")]
[PublicAPIAttribute]
public class JetBrains.Util.BackSlashSeparatedRelativePath : object {
    private static DirectMappedCache`2<string, BackSlashSeparatedRelativePath> ourIntern;
    private int myHashCode;
    private String modreq(System.Runtime.CompilerServices.IsVolatile) myName;
    private String modreq(System.Runtime.CompilerServices.IsVolatile) myNameWithoutExtension;
    [NotNullAttribute]
public static BackSlashSeparatedRelativePath Empty;
    [NotNullAttribute]
public string FullPath;
    private static Func`3<string, bool, BackSlashSeparatedRelativePath> myCachedDelegate1;
    public bool IsValidOnCurrentOS { get; }
    [NotNullAttribute]
public BackSlashSeparatedRelativePath Parent { get; }
    public StringSlicesEnumerable Components { get; }
    public string ExtensionNoDot { get; }
    public string ExtensionWithDot { get; }
    public bool IsAbsolute { get; }
    public bool IsEmpty { get; }
    public string Name { get; }
    public string NameWithoutExtension { get; }
    private IPath JetBrains.Util.IPath.Empty { get; }
    private string JetBrains.Util.IPath.FullPath { get; }
    private IPath JetBrains.Util.IPath.Parent { get; }
    private BackSlashSeparatedRelativePath(string path, bool isPathAlreadyCanonical);
    private static BackSlashSeparatedRelativePath();
    public sealed virtual bool get_IsValidOnCurrentOS();
    public BackSlashSeparatedRelativePath get_Parent();
    public static void AllowIntern(Lifetime lifetime, int maxEntries);
    public static void ClearIntern();
    [NotNullAttribute]
[PureAttribute]
public static BackSlashSeparatedRelativePath Parse(string path);
    [NotNullAttribute]
[PureAttribute]
public static BackSlashSeparatedRelativePath TryParse(string path);
    [NotNullAttribute]
public static BackSlashSeparatedRelativePath op_Division(BackSlashSeparatedRelativePath path, BackSlashSeparatedRelativePath other);
    [NotNullAttribute]
public static BackSlashSeparatedRelativePath op_Division(BackSlashSeparatedRelativePath path, string component);
    public static bool op_Equality(BackSlashSeparatedRelativePath left, BackSlashSeparatedRelativePath right);
    public static string op_Explicit(BackSlashSeparatedRelativePath path);
    public static BackSlashSeparatedRelativePath op_Implicit(string path);
    public static bool op_Inequality(BackSlashSeparatedRelativePath left, BackSlashSeparatedRelativePath right);
    [NotNullAttribute]
public static BackSlashSeparatedRelativePath CreateByCanonicalPath(string path);
    [NotNullAttribute]
[PureAttribute]
public BackSlashSeparatedRelativePath Combine(string component);
    [NotNullAttribute]
[PureAttribute]
public BackSlashSeparatedRelativePath Combine(BackSlashSeparatedRelativePath other);
    [NotNullAttribute]
[PureAttribute]
public BackSlashSeparatedRelativePath Combine(RelativePath other);
    [NotNullAttribute]
[PureAttribute]
public BackSlashSeparatedRelativePath MakeRelativeTo(BackSlashSeparatedRelativePath basePath);
    [NotNullAttribute]
[PureAttribute]
public BackSlashSeparatedRelativePath TryMakeRelativeTo(BackSlashSeparatedRelativePath basePath);
    [NotNullAttribute]
private static BackSlashSeparatedRelativePath Create(string path, bool isPathAlreadyCanonical);
    private static DirectMappedCache`2<string, BackSlashSeparatedRelativePath> CreateIntern(int maxEntries);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public sealed virtual int CompareTo(BackSlashSeparatedRelativePath other);
    public sealed virtual bool Equals(BackSlashSeparatedRelativePath other);
    public sealed virtual StringSlicesEnumerable get_Components();
    public sealed virtual Uri ToDirectoryUri();
    public sealed virtual Uri ToUri();
    private sealed virtual override IPath JetBrains.Util.IPath.Combine(RelativePath other);
    private sealed virtual override IPath JetBrains.Util.IPath.Parse(string text);
    private sealed virtual override IPath JetBrains.Util.IPath.TryCombine(string component);
    public sealed virtual string get_ExtensionNoDot();
    public sealed virtual string get_ExtensionWithDot();
    public sealed virtual bool get_IsAbsolute();
    public sealed virtual bool get_IsEmpty();
    public sealed virtual string get_Name();
    public sealed virtual string get_NameWithoutExtension();
    [NotNullAttribute]
[PureAttribute]
public BackSlashSeparatedRelativePath Clone();
    private sealed virtual override IPath JetBrains.Util.IPath.get_Empty();
    private sealed virtual override string JetBrains.Util.IPath.get_FullPath();
    private sealed virtual override IPath JetBrains.Util.IPath.get_Parent();
    private static BackSlashSeparatedRelativePath Create(PreparedString preparedString, BackSlashSeparatedRelativePath this, BackSlashSeparatedRelativePath other);
    private static BackSlashSeparatedRelativePath Create(PreparedString preparedString, BackSlashSeparatedRelativePath this);
}
public class JetBrains.Util.BackSlashSeparatedRelativePathConverter : TypeConverterBase`1<BackSlashSeparatedRelativePath> {
}
public class JetBrains.Util.BackSlashSeparatedRelativePathSerializer : ValueSerializerBase`1<BackSlashSeparatedRelativePath> {
}
public enum JetBrains.Util.BeforeOrAfter : Enum {
    public int value__;
    public static BeforeOrAfter After;
    public static BeforeOrAfter Before;
}
public class JetBrains.Util.BinarySearchResult`1 : ValueType {
    public IList`1<TItem> Items;
    public int RawResult;
    public TItem SearchTarget;
    public int HitIndex { get; }
    public TItem HitItem { get; }
    public int InsertAtIndex { get; }
    public int InsertAtIndex2 { get; }
    public bool IsHit { get; }
    public int NearestIndexNotAboveTarget { get; }
    public int NearestIndexNotAboveTargetOrFirst { get; }
    public int NearestIndexNotAboveTargetOrMinus1 { get; }
    public int NearestIndexNotBelowTarget { get; }
    public int NearestIndexNotBelowTargetOrCount { get; }
    public int NearestIndexNotBelowTargetOrLast { get; }
    public TItem NearestItemNotAboveTarget { get; }
    public TItem NearestItemNotAboveTargetOrFirst { get; }
    public TItem NearestItemNotBelowTarget { get; }
    public TItem NearestItemNotBelowTargetOrLast { get; }
    public BinarySearchResult`1(List`1<TItem> items, TItem searchTarget);
    public BinarySearchResult`1(IList`1<TItem> items, TItem searchTarget, int rawresult);
    public int get_HitIndex();
    public TItem get_HitItem();
    public int get_InsertAtIndex();
    public int get_InsertAtIndex2();
    public bool get_IsHit();
    public int get_NearestIndexNotAboveTarget();
    public int get_NearestIndexNotAboveTargetOrFirst();
    public int get_NearestIndexNotAboveTargetOrMinus1();
    public int get_NearestIndexNotBelowTarget();
    public int get_NearestIndexNotBelowTargetOrCount();
    public int get_NearestIndexNotBelowTargetOrLast();
    public TItem get_NearestItemNotAboveTarget();
    public TItem get_NearestItemNotAboveTargetOrFirst();
    public TItem get_NearestItemNotBelowTarget();
    public TItem get_NearestItemNotBelowTargetOrLast();
    public int InsertAt(TItem item);
    private void AddExceptionData(Exception ex);
}
[ExtensionAttribute]
public static class JetBrains.Util.BinarySearchUtil : object {
    [ExtensionAttribute]
public static BinarySearchResult`1<TItem> BinarySearch(IList`1<TItem> list, TKey keyLookFor, Func`2<TItem, TKey> FGetKeyOfItem, IComparer`1<TKey> keycomparer, int index, int length, OfEqualItems which);
    [ExtensionAttribute]
public static BinarySearchResult`1<TItem> BinarySearch(IList`1<TItem> list, TItem itemLookFor, IComparer`1<TItem> keycomparer, int index, int length, OfEqualItems which);
    [ExtensionAttribute]
public static int BinarySearch(IList`1<T> list, int index, int length, Locator`1<T> locator);
    [ExtensionAttribute]
public static int BinarySearch(IList`1<T> list, Locator`1<T> locator);
    [ExtensionAttribute]
public static BinarySearchResult`1<TItem> BinarySearchEx(IList`1<TItem> thіs, TItem item);
    [ExtensionAttribute]
public static BinarySearchResult`1<T> BinarySearchEx(IList`1<T> list, Locator`1<T> locator);
    public static TValue GetOrCreateValue(IList`1<TValue> list, TKey key, Func`2<TValue, TKey> FGetKeyOfItem, Func`1<TValue> FCreateIfMissing);
    public static bool RemoveValue(IList`1<TValue> list, TKey key, Func`2<TValue, TKey> FGetKeyOfItem);
    [CanBeNullAttribute]
public static TValue TryGetValue(IList`1<TValue> list, TKey key, Func`2<TValue, TKey> FGetKeyOfItem);
}
[ExtensionAttribute]
public static class JetBrains.Util.BinarySearchUtilReadonlyList : object {
    [ExtensionAttribute]
public static BinarySearchResultRo`1<TItem> BinarySearchRo(IReadOnlyList`1<TItem> list, TKey keyLookFor, Func`2<TItem, TKey> FGetKeyOfItem, IComparer`1<TKey> keycomparer, int index, int length, OfEqualItems which);
}
[ExtensionAttribute]
public static class JetBrains.Util.BinaryStreamEx : object {
    [ExtensionAttribute]
[CanBeNullAttribute]
public static String[] ReadLengthAndStringArray(BinaryReader reader);
}
[ExtensionAttribute]
public static class JetBrains.Util.Caches.CachedValues : object {
    [NotNullAttribute]
public static ICachedValue`1<T> CreateWeakCachedValue(Func`1<T> producer, IWeakRefRetainerCache`1<TCacheItem> cache, T initialValue, int cacheTouchFrequency);
    [NotNullAttribute]
public static IParametrizedCachedValue`2<T, TParam> CreateWeakParametrizedCachedValue(Func`2<TParam, T> producer, IWeakRefRetainerCache`1<TCacheItem> cache, T initialValue, int cacheTouchFrequency);
    [NotNullAttribute]
public static ICachedValue`1<T> CreateStrongCachedValue(T initialValue);
    [NotNullAttribute]
public static IParametrizedCachedValue`2<T, TParam> CreateStrongParametrizedCachedValue(T initialValue);
    [ExtensionAttribute]
[ThreadSafeAttribute]
public static bool HasValue(ICachedValueBase`1<T> cachedValue);
    [ExtensionAttribute]
[ThreadSafeAttribute]
public static void SetIfNull(ICachedValueBase`1<T> cachedValue, Func`1<TInheritor> functor);
    [ExtensionAttribute]
[ThreadSafeAttribute]
public static void SetIfNull(ICachedValueBase`1<T> cachedValue, Func`2<TParam, TInheritor> functor, TParam param);
}
internal static class JetBrains.Util.Caches.CacheStatistics : object {
    internal static string Touch;
    internal static string Hit;
    internal static string Miss;
    internal static string Erosion;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ThreadSafeAttribute]
public class JetBrains.Util.Caches.DirectMappedCache`2 : object {
    private static int LocksCount;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private KeyValuePair`2[] myEntries;
    private IEqualityComparer`1<TKey> myEqualityComparer;
    private Object[] myLocks;
    private BitArray myEntryStates;
    [NullableAttribute("2")]
private ILogger myLogger;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ICacheBackendProvider`2<TKey, TValue> myProvider;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`2<TKey, TValue> myGetValueFunction;
    private int myCount;
    public int Count { get; }
    [NullableContextAttribute("2")]
public DirectMappedCache`2(int approximateSize, IEqualityComparer`1<TKey> comparer, ICacheBackendProvider`2<TKey, TValue> provider, ILogger logger);
    private void Reset();
    private object GetLock(int index);
    private int GetBucket(TKey key);
    private TValue GetOrCreateInternal(TKeyInheritor keyInheritor, TParam param, object provider);
    public sealed virtual bool TryGetFromCache(TKey key, TValue& value);
    public sealed virtual TKey TryGetInternedKey(TKey key);
    public sealed virtual TValue GetOrCreate(TKey key);
    public sealed virtual TValue GetOrCreate(TKeyInheritor key, Func`2<TKeyInheritor, TValue> provider);
    public sealed virtual TValue GetOrCreate(TKeyInheritor key, TParam param, Func`3<TKeyInheritor, TParam, TValue> provider);
    public sealed virtual void AddToCache(TKey key, TValue value);
    public sealed virtual bool RemoveFromCache(TKey key);
    public sealed virtual bool ContainsKeyInCache(TKey key);
    public TValue GetCachedValue(TKey key);
    public sealed virtual void Clear();
    [NullableContextAttribute("0")]
private TakeAllLocksCookie<TKey, TValue> TakeAllLocks();
    public sealed virtual void Add(TKey key, TValue val);
    public sealed virtual void Remove(TKey key);
    public bool TryGetOrCreate(TKey key, TValue& val);
    public sealed virtual void Flush(TKey key);
    public sealed virtual void Flush();
    public sealed virtual int get_Count();
    [PublicAPIAttribute]
public KeyValuePair`2[] ToArray();
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [CompilerGeneratedAttribute]
private TValue <.ctor>b__9_0(TKey key);
}
public class JetBrains.Util.Caches.EmptyCache`2 : object {
    [NotNullAttribute]
public static EmptyCache`2<TKey, TValue> Instance;
    [CompilerGeneratedAttribute]
private int <Count>k__BackingField;
    public int Count { get; private set; }
    private static EmptyCache`2();
    public sealed virtual void AddToCache(TKey key, TValue value);
    public sealed virtual bool RemoveFromCache(TKey key);
    public sealed virtual bool ContainsKeyInCache(TKey key);
    public sealed virtual void Clear();
    public sealed virtual bool TryGetFromCache(TKey key, TValue& value);
    public sealed virtual TKey TryGetInternedKey(TKey key);
    [CompilerGeneratedAttribute]
public sealed virtual int get_Count();
    [CompilerGeneratedAttribute]
private void set_Count(int value);
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
}
[NullableContextAttribute("1")]
public interface JetBrains.Util.Caches.ICacheBackendProvider`2 {
    public abstract virtual bool ContainsKey(TKey key);
    public abstract virtual bool TryGetValue(TKey key, TValue& val);
    public abstract virtual void Put(TKey key, TValue val);
    public abstract virtual void Remove(TKey key);
}
[NullableContextAttribute("1")]
public interface JetBrains.Util.Caches.ICachedBackend`2 {
    public abstract virtual void Add(TKey key, TValue val);
    public abstract virtual void Remove(TKey key);
    public abstract virtual void Flush(TKey key);
    public abstract virtual void Flush();
}
public interface JetBrains.Util.Caches.ICachedValue`1 {
    [NotNullAttribute]
public abstract virtual T GetOrCreate();
}
public interface JetBrains.Util.Caches.ICachedValueBase`1 {
    public abstract virtual void Set(T value);
    public abstract virtual void Clear();
    [CanBeNullAttribute]
public abstract virtual T TryGet();
}
[NullableContextAttribute("1")]
public interface JetBrains.Util.Caches.IDictionaryBasedCache`2 {
    public int Count { get; }
    public abstract virtual void AddToCache(TKey key, TValue value);
    public abstract virtual bool RemoveFromCache(TKey key);
    public abstract virtual bool ContainsKeyInCache(TKey key);
    public abstract virtual void Clear();
    public abstract virtual bool TryGetFromCache(TKey key, TValue& value);
    public abstract virtual TKey TryGetInternedKey(TKey key);
    public abstract virtual int get_Count();
    public abstract virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
}
[NullableContextAttribute("1")]
public interface JetBrains.Util.Caches.IExternalProviderCache`2 {
    public abstract virtual TValue GetOrCreate(TKeyInheritor key, Func`2<TKeyInheritor, TValue> provider);
    public abstract virtual TValue GetOrCreate(TKeyInheritor key, TParam param, Func`3<TKeyInheritor, TParam, TValue> provider);
}
public interface JetBrains.Util.Caches.IParametrizedCachedValue`2 {
    [NotNullAttribute]
public abstract virtual T GetOrCreate(TState state);
    public abstract virtual bool GetOrCreate(TState state, T& result, Action`2<T, TState> afterCreate);
    [CanBeNullAttribute]
public abstract virtual T TryGetSync();
}
[NullableContextAttribute("2")]
public interface JetBrains.Util.Caches.IProviderCache`2 {
    [NullableContextAttribute("1")]
public abstract virtual TValue GetOrCreate(TKey key);
}
public interface JetBrains.Util.Caches.IWeakCachedValue {
    public int CacheTouchFrequency { get; public set; }
    public abstract virtual int get_CacheTouchFrequency();
    public abstract virtual void set_CacheTouchFrequency(int value);
}
public interface JetBrains.Util.Caches.IWeakRefRetainerCache`1 {
    public int Count { get; }
    public abstract virtual bool Touch(T item);
    public abstract virtual bool Remove(T item);
    public abstract virtual void Clear();
    public abstract virtual bool Contains(T item);
    public abstract virtual int get_Count();
    public abstract virtual int Evict();
}
public class JetBrains.Util.Caches.LimitedSingleThreadCache`2 : object {
    private int myFixedCapacity;
    private Dictionary`2<TKey, Bucket<TKey, TValue>> myDictionary;
    private long myItemLifetimeEvictTicks;
    private Thread myThread;
    public static int DefaultItemLifetimeToEvictMs;
    private static ILogger ourLog;
    public int Count { get; }
    public LimitedSingleThreadCache`2(int fixedCapacity, IEqualityComparer`1<TKey> comparer, int itemLifetimeToEvictMs);
    private static LimitedSingleThreadCache`2();
    public sealed virtual void AddToCache(TKey key, TValue value);
    private void Invalidate();
    public sealed virtual bool RemoveFromCache(TKey key);
    public sealed virtual bool ContainsKeyInCache(TKey key);
    public sealed virtual void Clear();
    public sealed virtual bool TryGetFromCache(TKey key, TValue& value);
    public sealed virtual TKey TryGetInternedKey(TKey key);
    public sealed virtual int get_Count();
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    [ConditionalAttribute("JET_MODE_ASSERT")]
private void AssertThread();
}
[ThreadSafeAttribute]
public class JetBrains.Util.Caches.LRUWeakRefRetainerCache`1 : object {
    public static long EvictionTimerIntervalMillis;
    private static int EntryPointerNull;
    private static double LoadFactor;
    private static int SpecialEntriesOffset;
    private static int HeadEntryIdx;
    private static int TailEntryIdx;
    private int myCount;
    private Entry[] myEntries;
    private int myCapacity;
    private IEqualityComparer`1<T> myEqualityComparer;
    private object myLock;
    private int myNextBucketShift;
    private int myInitialCapacity;
    private long myInvalidateTimeMillis;
    private int myInvalidationSurvivalThreshold;
    [UsedImplicitlyAttribute]
private Timer myTimer;
    public int Count { get; }
    public IList`1<T> Items { get; }
    public LRUWeakRefRetainerCache`1(Lifetime lifetime, int capacity, IEqualityComparer`1<T> comparer, long invalidateTimeInMillis, int invalidationSurvivalThreshold);
    private void Reset();
    private int InitBucket(T key);
    private int NextBucket(int prevBucket);
    private bool IsEmptyBucket(int bucket);
    private void LinkEntries(int indexFirst, int indexSecond);
    private bool TouchInternal(T item);
    private void Promote(int bucket);
    private void SetEmpty(int bucket);
    private bool RemoveInternal(T item);
    public void VerifyCorrect();
    private int RemoveFromBucket(int bucket);
    private bool ContainsInternal(T item);
    private void EvictOne();
    private int EvictLeastRecentlyTouchedInternal();
    public sealed virtual bool Touch(T item);
    public sealed virtual bool Remove(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual int Evict();
    public sealed virtual int get_Count();
    public IList`1<T> get_Items();
    [CompilerGeneratedAttribute]
private void <.ctor>b__17_0();
    [CompilerGeneratedAttribute]
private void <.ctor>b__17_2(object _);
    [CompilerGeneratedAttribute]
private void <.ctor>b__17_1();
}
[ThreadSafeAttribute]
internal class JetBrains.Util.Caches.StrongCachedValue`2 : object {
    private T modreq(System.Runtime.CompilerServices.IsVolatile) myValue;
    public StrongCachedValue`2(T value);
    public sealed virtual T GetOrCreate();
    public sealed virtual T GetOrCreate(TState state);
    public sealed virtual T TryGet();
    public sealed virtual T TryGetSync();
    public sealed virtual bool GetOrCreate(TState state, T& result, Action`2<T, TState> afterCreate);
    public sealed virtual void Set(T value);
    public sealed virtual void Clear();
}
public class JetBrains.Util.Caches.UnlimitedCache`2 : object {
    private IEqualityComparer`1<TKey> myEqualityComparer;
    [CompilerGeneratedAttribute]
private ConcurrentDictionary`2<TKey, TValue> <Map>k__BackingField;
    protected ConcurrentDictionary`2<TKey, TValue> Map { get; }
    public int Count { get; }
    public UnlimitedCache`2(IEqualityComparer`1<TKey> equalityComparer);
    [CompilerGeneratedAttribute]
protected ConcurrentDictionary`2<TKey, TValue> get_Map();
    public sealed virtual void AddToCache(TKey key, TValue value);
    public sealed virtual bool RemoveFromCache(TKey key);
    public sealed virtual bool ContainsKeyInCache(TKey key);
    public sealed virtual void Clear();
    public sealed virtual bool TryGetFromCache(TKey key, TValue& value);
    public sealed virtual TKey TryGetInternedKey(TKey key);
    public sealed virtual int get_Count();
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
}
public class JetBrains.Util.Caches.UnlimitedInactiveItemsEvictingCache`2 : object {
    public static int DefaultEvictionAttemptIntervalMs;
    public static int DefaultItemLifetimeToEvictMs;
    private Dictionary`2<TKey, Bucket<TKey, TValue>> myDictionary;
    private long myItemLifetimeToEvictsMs;
    private JetFastSemiReenterableRWLock myLock;
    private Timer myTimer;
    private int myEvictionAttemptIntervalMs;
    private int myEvictionAttemptIntervalAfterFailureMs;
    [CompilerGeneratedAttribute]
private Action`1<TKey> AfterItemEvicted;
    public int Count { get; }
    public UnlimitedInactiveItemsEvictingCache`2(Lifetime lifetime, int evictionAttemptIntervalMs, int itemLifetimeToEvictMs, IEqualityComparer`1<TKey> comparer);
    [CompilerGeneratedAttribute]
public void add_AfterItemEvicted(Action`1<TKey> value);
    [CompilerGeneratedAttribute]
public void remove_AfterItemEvicted(Action`1<TKey> value);
    private void TimerOnElapsed(object sender, ElapsedEventArgs elapsedEventArgs);
    public sealed virtual void AddToCache(TKey key, TValue value);
    public sealed virtual bool RemoveFromCache(TKey key);
    public sealed virtual bool ContainsKeyInCache(TKey key);
    public sealed virtual void Clear();
    public sealed virtual bool TryGetFromCache(TKey key, TValue& value);
    public sealed virtual TKey TryGetInternedKey(TKey key);
    public sealed virtual int get_Count();
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    protected virtual void OnAfterItemEvicted(TKey key);
    [CompilerGeneratedAttribute]
private void <.ctor>b__12_0();
    [CompilerGeneratedAttribute]
private void <.ctor>b__12_1();
}
public class JetBrains.Util.Caches.UnlimitedProviderCache`2 : UnlimitedCache`2<TKey, TValue> {
    [NotNullAttribute]
private Func`2<TKey, TValue> myProvider;
    public UnlimitedProviderCache`2(Func`2<TKey, TValue> provider);
    public sealed virtual TValue GetOrCreate(TKey key);
    [CompilerGeneratedAttribute]
private TValue <GetOrCreate>b__2_0(TKey k);
}
[ThreadSafeAttribute]
internal class JetBrains.Util.Caches.WeakCachedValue`2 : WeakCachedValueBase`2<T, TCacheItem> {
    private Func`1<T> myProducer;
    public WeakCachedValue`2(Func`1<T> producer, IWeakRefRetainerCache`1<T> cache, T initialValue, int cacheTouchFrequency);
    public sealed virtual T GetOrCreate();
}
internal abstract class JetBrains.Util.Caches.WeakCachedValueBase`2 : object {
    [NotNullAttribute]
protected WeakReference`1<T> Ref;
    [NotNullAttribute]
protected IWeakRefRetainerCache`1<T> Cache;
    protected int UsageCount;
    [CompilerGeneratedAttribute]
private int <CacheTouchFrequency>k__BackingField;
    public int CacheTouchFrequency { get; public set; }
    protected WeakCachedValueBase`2(IWeakRefRetainerCache`1<T> cache, T initialValue, int cacheTouchFrequency);
    [CompilerGeneratedAttribute]
public sealed virtual int get_CacheTouchFrequency();
    [CompilerGeneratedAttribute]
public sealed virtual void set_CacheTouchFrequency(int value);
    public sealed virtual void Set(T value);
    public sealed virtual void Clear();
    [CanBeNullAttribute]
public sealed virtual T TryGet();
}
[ThreadSafeAttribute]
internal class JetBrains.Util.Caches.WeakParametrizedCachedValue`3 : WeakCachedValueBase`2<T, TCacheItem> {
    [NotNullAttribute]
private Func`2<TState, T> myProducer;
    public WeakParametrizedCachedValue`3(Func`2<TState, T> producer, IWeakRefRetainerCache`1<T> cache, T initialValue, int cacheTouchFrequency);
    public sealed virtual T GetOrCreate(TState state);
    public sealed virtual bool GetOrCreate(TState state, T& result, Action`2<T, TState> afterCreate);
    public sealed virtual T TryGetSync();
}
public class JetBrains.Util.Caches.WeakRefRetainerMultiCache`1 : object {
    private IList`1<IWeakRefRetainerCache`1<T>> myCaches;
    private Func`2<T, IWeakRefRetainerCache`1<T>> myDispatcher;
    public IList`1<IWeakRefRetainerCache`1<T>> Caches { get; }
    public int Count { get; }
    public WeakRefRetainerMultiCache`1(IList`1<IWeakRefRetainerCache`1<T>> caches, Func`2<T, IWeakRefRetainerCache`1<T>> dispatcher);
    public sealed virtual bool Touch(T item);
    public IList`1<IWeakRefRetainerCache`1<T>> get_Caches();
    public sealed virtual bool Remove(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual int get_Count();
    public sealed virtual int Evict();
}
public class JetBrains.Util.CannotDeleteTempEntityException : ApplicationException {
    public CannotDeleteTempEntityException(Exception inner, string message);
}
[ExtensionAttribute]
public static class JetBrains.Util.CharEx : object {
    [ExtensionAttribute]
[PureAttribute]
public static char ToLowerFast(char c);
    [ExtensionAttribute]
[PureAttribute]
public static char ToUpperFast(char c);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsIdentifierStart(char c);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsIdentifierPart(char c);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsUpperFast(char c);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsLowerFast(char c);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsLetterFast(char c);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsLetterOrDigitFast(char c);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsDigitFast(char c);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsHexDigitFast(char c);
}
public static class JetBrains.Util.CharUtil : object {
    public static Byte[] UriSafeAsciiChars;
    private static CharUtil();
    public static bool IsHexDigit(char c);
    public static byte ParseHexDigit(char c);
    public static bool IsOctDigit(char c);
    public static bool IsUriSafeChar(char ch);
    [NotNullAttribute]
private static Byte[] GetUriSafeAsciiChars();
}
internal class JetBrains.Util.Collections.CollectionUtilSafeOfTypeEnumerable`1 : object {
    private IEnumerable myUnsafeEnumerable;
    public CollectionUtilSafeOfTypeEnumerable`1(IEnumerable unsafeEnumerable);
    [NotNullAttribute]
private IEnumerator`1<TItem> GetTypedEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IEnumerator`1<TItem> GetEnumerator();
}
public static class JetBrains.Util.Collections.Comparer : object {
    [NotNullAttribute]
[PureAttribute]
public static IComparer`1<T> Create(Comparison`1<T> compare);
    [NotNullAttribute]
[PureAttribute]
public static IComparer`1<TSource> Create(Func`2<TSource, TKey> keySelector, IComparer`1<TKey> keyComparer);
    [NotNullAttribute]
[PureAttribute]
public static IComparer`1<T> Invert(IComparer`1<T> comparer);
}
public class JetBrains.Util.Collections.EnumeratorEnumerable : object {
    [NotNullAttribute]
private Func`1<IEnumerator> myΛGetEnumerator;
    public EnumeratorEnumerable(Func`1<IEnumerator> λGetEnumerator);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Util.Collections.HashMap`2 : object {
    private IEqualityComparer`1<TKey> myComparer;
    private Entry[] myEntries;
    private Int32[] myHashToEntryIndex;
    private int myEntriesUsed;
    private int myFirstFreeIndex;
    private int myFreeCount;
    private KeyCollection<TKey, TValue> myKeys;
    private ValueCollection<TKey, TValue> myValues;
    private int myVersion;
    private bool myCheckKeyForNull;
    public IEqualityComparer`1<TKey> Comparer { get; }
    private ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.Keys { get; }
    private ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.Values { get; }
    private IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Keys { get; }
    private IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Values { get; }
    public KeyCollection<TKey, TValue> Keys { get; }
    public ValueCollection<TKey, TValue> Values { get; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.IsReadOnly { get; }
    public TValue Item { get; public set; }
    public HashMap`2(IDictionary`2<TKey, TValue> dictionary);
    public HashMap`2(IEqualityComparer`1<TKey> comparer);
    public HashMap`2(int capacity);
    public HashMap`2(IDictionary`2<TKey, TValue> dictionary, IEqualityComparer`1<TKey> comparer);
    public HashMap`2(int capacity, IEqualityComparer`1<TKey> comparer);
    public IEqualityComparer`1<TKey> get_Comparer();
    private sealed virtual override ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.get_Keys();
    private sealed virtual override ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.get_Values();
    private sealed virtual override IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Keys();
    private sealed virtual override IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Values();
    public KeyCollection<TKey, TValue> get_Keys();
    public ValueCollection<TKey, TValue> get_Values();
    public sealed virtual int get_Count();
    public sealed virtual void Add(TKey key, TValue value);
    public sealed virtual bool Remove(TKey key);
    public sealed virtual void Clear();
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Add(KeyValuePair`2<TKey, TValue> item);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Contains(KeyValuePair`2<TKey, TValue> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.CopyTo(KeyValuePair`2[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Remove(KeyValuePair`2<TKey, TValue> item);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.get_IsReadOnly();
    public sealed virtual bool ContainsKey(TKey key);
    public bool ContainsValue(TValue value);
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    public bool IsEmpty();
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    public bool TryGetKeyAndValue(TKey key, TKey& hashedKey, TValue& value);
    private sealed virtual override IEnumerator`1<KeyValuePair`2<TKey, TValue>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TValue>>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public PairEnumerator<TKey, TValue> GetEnumerator();
    private void RemoveEntry(int entryIndex);
    private bool CompareKey(TKey key, int entryIndex);
    private int GetEntryIndex(TKey key);
    private void Initialize(int capacity);
    private void Insert(TKey key, TValue value, bool add);
    private void Resize();
}
public interface JetBrains.Util.Collections.IFreezable {
    [DesignerSerializationVisibilityAttribute("0")]
public bool IsFrozen { get; }
    public abstract virtual bool get_IsFrozen();
    public abstract virtual void Freeze();
}
public static class JetBrains.Util.Collections.JetComparer : object {
    [NotNullAttribute]
[PureAttribute]
public static IComparer`1<TWrapped> FromAnotherComparer(Func`2<TWrapped, TNested> keySelector, IComparer`1<TNested> nestedComparer);
    [NotNullAttribute]
[PureAttribute]
public static IComparer`1<T> FromFunction(Comparison`1<T> compare);
}
public class JetBrains.Util.Collections.LazyProcessedCollection`1 : object {
    private Func`2<List`1<T>, List`1<T>> myProcessor;
    private List`1<T> myList;
    private bool myProcessed;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public LazyProcessedCollection`1(Func`2<List`1<T>, List`1<T>> processor);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private void EnsureProcessed();
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual bool Remove(T item);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class JetBrains.Util.Collections.OrderedCollection`1 : LazyProcessedCollection`1<T> {
    public OrderedCollection`1(Comparison`1<T> comparer);
}
[ExtensionAttribute]
public static class JetBrains.Util.CollectionUtil : object {
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static string ToStringWithCount(IEnumerable enumerable, bool multiline);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
[CollectionAccessAttribute("1")]
public static T TryPeek(Stack`1<T> stack);
    [ExtensionAttribute]
[CanBeNullAttribute]
[CollectionAccessAttribute("2")]
public static T TryPop(Stack`1<T> stack);
    [ExtensionAttribute]
[PureAttribute]
[CollectionAccessAttribute("1")]
public static T Peek(IList`1<T> list);
    [ExtensionAttribute]
[CollectionAccessAttribute("2")]
public static T Pop(IList`1<T> list);
    [ExtensionAttribute]
[CollectionAccessAttribute("6")]
public static void Push(IList`1<T> list, T item);
    [PureAttribute]
public static bool AreUnique(IEnumerable`1<T> enumerable);
    [ExtensionAttribute]
[PureAttribute]
public static bool EqualEnumerables(IEnumerable`1<T> left, IEnumerable`1<T> right);
    [ExtensionAttribute]
[PureAttribute]
public static bool EqualEnumerables(IEnumerable`1<T> left, IEnumerable`1<T> right, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static void AssertEquivalentTo(IEnumerable thіs, IEnumerable expected, OnError onerror);
    [ExtensionAttribute]
public static bool AssertEquivalentTo(IEnumerable`1<TItem> thіs, IEnumerable`1<TItem> expected, OnError onerror, IEqualityComparer`1<TItem> itemcomparer);
    [PureAttribute]
[CollectionAccessAttribute("1")]
public static int GetHashCode(ICollection`1<T> collection, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsEquivalentTo(IEnumerable`1<T> left, IEnumerable`1<T> right, IEqualityComparer`1<T> comparer);
    [NotNullAttribute]
[PureAttribute]
private static ISet`1<T> GetOrCreateSet(IEnumerable`1<T> source, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
[PureAttribute]
[ObsoleteAttribute("This method has unclear semantic and unpredictable performance. See documentation for details")]
public static bool EqualItemsContainedIn(ICollection`1<T> set1, ICollection`1<T> set2);
    [ExtensionAttribute]
[PureAttribute]
[ObsoleteAttribute("This method has unclear semantic and unpredictable performance. See documentation for details")]
public static bool EqualItemsContainedInReadOnly(IReadOnlyCollection`1<T> set1, IReadOnlyCollection`1<T> set2);
    [ExtensionAttribute]
[PureAttribute]
public static int CompareEnumerables(IEnumerable`1<T> left, IEnumerable`1<T> right, IComparer`1<T> comparer);
    [IteratorStateMachineAttribute("JetBrains.Util.CollectionUtil/<Prepend>d__17`1")]
[ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IEnumerable`1<T> Prepend(IEnumerable`1<T> tail, T[] elements);
    [IteratorStateMachineAttribute("JetBrains.Util.CollectionUtil/<Prepend>d__18`1")]
[ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IEnumerable`1<T> Prepend(IEnumerable`1<T> tail, IEnumerable`1<T> elements);
    [IteratorStateMachineAttribute("JetBrains.Util.CollectionUtil/<Concat>d__19`1")]
[ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IEnumerable`1<T> Concat(IEnumerable`1<T> first, T element);
    [IteratorStateMachineAttribute("JetBrains.Util.CollectionUtil/<Concat>d__20`1")]
[ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IEnumerable`1<T> Concat(IEnumerable`1<T> first, T[] elements);
    [NotNullAttribute]
[PureAttribute]
public static IEnumerable`1<T> EnumerateAll(IEnumerable`1[] enumerables);
    [NotNullAttribute]
[PureAttribute]
public static IEnumerable`1<T> EnumerateAll(IEnumerable`1<IEnumerable`1<T>> enumerables);
    [ExtensionAttribute]
[PureAttribute]
public static int TryGetCountFast(IEnumerable`1<T> enumerable, int defaultValue);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Do not use this method with ICollection<T>, check its Count property.", "True")]
public static int TryGetCountFast(ICollection`1<T> collection);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Do not use this method with ICollection, check its Count property.", "True")]
public static int TryGetCountFast(ICollection collection);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Do not use this method with string, check its Length property.", "True")]
public static int TryGetCountFast(string str);
    [ExtensionAttribute]
[PureAttribute]
public static bool CanBeProvenEmptyFast(IEnumerable`1<T> enumerable);
    [ExtensionAttribute]
[ObsoleteAttribute("Do not use this method with ICollection<T>, check its Count property.", "True")]
public static bool CanBeProvenEmptyFast(ICollection`1<T> collection);
    [ExtensionAttribute]
[ObsoleteAttribute("Do not use this method with ICollection, check its Count property.", "True")]
public static bool CanBeProvenEmptyFast(ICollection collection);
    [ExtensionAttribute]
[ObsoleteAttribute("Do not use this method with string, check its Length property.", "True")]
public static bool CanBeProvenEmptyFast(string collection);
    [ExtensionAttribute]
[PureAttribute]
public static bool CanBeProvenNonEmptyFast(IEnumerable`1<T> enumerable);
    [ExtensionAttribute]
[ObsoleteAttribute("Do not use this method with ICollection<T>, check its Count property.", "True")]
public static bool CanBeProvenNonEmptyFast(ICollection`1<T> collection);
    [ExtensionAttribute]
[ObsoleteAttribute("Do not use this method with ICollection, check its Count property.", "True")]
public static bool CanBeProvenNonEmptyFast(ICollection collection);
    [ExtensionAttribute]
[ObsoleteAttribute("Do not use this method with string, check its Length property.", "True")]
public static bool CanBeProvenNonEmptyFast(string collection);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsEmpty(IEnumerable`1<T> enumerable);
    [ExtensionAttribute]
[PureAttribute]
[EditorBrowsableAttribute("1")]
[CollectionAccessAttribute("1")]
public static bool IsEmpty(ICollection`1<T> collection);
    [ExtensionAttribute]
[PureAttribute]
[EditorBrowsableAttribute("1")]
public static bool IsEmpty(LocalList`1<T> collection);
    [ExtensionAttribute]
[PureAttribute]
[EditorBrowsableAttribute("1")]
[CollectionAccessAttribute("1")]
public static bool IsEmpty(Stack`1<T> collection);
    [ExtensionAttribute]
[PureAttribute]
[EditorBrowsableAttribute("1")]
[CollectionAccessAttribute("1")]
public static bool IsEmpty(Queue`1<T> collection);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => true")]
public static bool IsNullOrEmpty(IEnumerable`1<T> enumerable);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
[PureAttribute]
[ContractAnnotationAttribute("null => true")]
[CollectionAccessAttribute("1")]
public static bool IsNullOrEmpty(ICollection`1<T> collection);
    [ExtensionAttribute]
[PureAttribute]
[EditorBrowsableAttribute("1")]
public static bool IsNullOrEmpty(LocalList`1<T> collection);
    [ExtensionAttribute]
[PureAttribute]
[EditorBrowsableAttribute("1")]
[CollectionAccessAttribute("1")]
public static bool IsNullOrEmpty(Stack`1<T> collection);
    [ExtensionAttribute]
[PureAttribute]
[EditorBrowsableAttribute("1")]
[CollectionAccessAttribute("1")]
public static bool IsNullOrEmpty(Queue`1<T> collection);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsSingle(IEnumerable`1<T> enumerable);
    [ExtensionAttribute]
[PureAttribute]
[EditorBrowsableAttribute("1")]
[CollectionAccessAttribute("1")]
public static bool IsSingle(ICollection`1<T> collection);
    [ExtensionAttribute]
[PureAttribute]
public static bool HasAtLeast(IEnumerable`1<T> enumerable, int minimumCount);
    [ExtensionAttribute]
[PureAttribute]
[EditorBrowsableAttribute("1")]
[CollectionAccessAttribute("1")]
public static bool HasAtLeast(ICollection`1<T> collection, int minimumCount);
    [ExtensionAttribute]
[PureAttribute]
[EditorBrowsableAttribute("1")]
public static bool HasAtLeast(string str, int minimumCount);
    [ExtensionAttribute]
[PureAttribute]
public static bool HasMultiple(IEnumerable`1<T> enumerable);
    [ExtensionAttribute]
[PureAttribute]
[EditorBrowsableAttribute("1")]
[CollectionAccessAttribute("1")]
public static bool HasMultiple(ICollection`1<T> collection);
    [ExtensionAttribute]
[PureAttribute]
[EditorBrowsableAttribute("1")]
public static bool HasMultiple(string str);
    [ExtensionAttribute]
[PureAttribute]
public static bool HasMoreThan(IEnumerable`1<T> enumerable, int exclusiveLowerBound);
    [ExtensionAttribute]
[PureAttribute]
[EditorBrowsableAttribute("1")]
[CollectionAccessAttribute("1")]
public static bool HasMoreThan(ICollection`1<T> collection, int exclusiveLowerBound);
    [ExtensionAttribute]
[PureAttribute]
[EditorBrowsableAttribute("1")]
public static bool HasMoreThan(string str, int exclusiveLowerBound);
    [ExtensionAttribute]
[PureAttribute]
public static bool CountIs(IEnumerable`1<T> enumerable, int exactCount);
    [ExtensionAttribute]
[PureAttribute]
[EditorBrowsableAttribute("1")]
[CollectionAccessAttribute("1")]
public static bool CountIs(ICollection`1<T> collection, int exactCount);
    [ExtensionAttribute]
[PureAttribute]
[EditorBrowsableAttribute("1")]
public static bool CountIs(string str, int exactCount);
    [ExtensionAttribute]
[PureAttribute]
[CollectionAccessAttribute("1")]
public static bool Any(ICollection`1<T> collection);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static T FirstNotNull(IEnumerable`1<T> enumerable);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static Nullable`1<T> FirstNotNull(IEnumerable`1<Nullable`1<T>> enumerable);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static Nullable`1<TSource> FirstOrNull(IEnumerable`1<TSource> enumerable, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
[PureAttribute]
public static TSource FirstOrDefault(IEnumerable`1<TSource> enumerable, TSource defaultValue);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static T SingleItem(IEnumerable`1<T> enumerable, T defaultValue);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
[CollectionAccessAttribute("1")]
public static T SingleItem(IList`1<T> list, T defaultValue);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static T SingleItem(T[] array, T defaultValue);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static T SingleItem(IEnumerable`1<T> enumerable, Func`2<T, bool> predicate);
    [ObsoleteAttribute("O(n) + reference equality, better do not use")]
[CanBeNullAttribute]
[PureAttribute]
public static T GetPrevious(IEnumerable`1<T> enumerable, T anchor);
    [ObsoleteAttribute("O(n) + reference equality, better do not use")]
[CanBeNullAttribute]
[PureAttribute]
public static T GetNext(IEnumerable`1<T> enumerable, T anchor);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static T TakeMax(IEnumerable`1<T> enumerable, Func`2<T, TKey> metric, TKey min);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static T TakeMin(IEnumerable`1<T> enumerable, Func`2<T, TKey> metric);
    [ExtensionAttribute]
[PureAttribute]
[NotNullAttribute]
public static IEnumerable`1<T> WhereNotNull(IEnumerable`1<T> enumerable);
    [ExtensionAttribute]
[PureAttribute]
[NotNullAttribute]
public static IEnumerable`1<Nullable`1<T>> WhereNotNull(IEnumerable`1<Nullable`1<T>> enumerable);
    [ExtensionAttribute]
[PureAttribute]
[NotNullAttribute]
[ItemNotNullAttribute]
public static IEnumerable`1<TResult> SelectNotNull(IEnumerable`1<TSource> enumerable, Func`2<TSource, TResult> selector);
    [IteratorStateMachineAttribute("JetBrains.Util.CollectionUtil/<SelectNotNull>d__75`2")]
[ExtensionAttribute]
[PureAttribute]
[NotNullAttribute]
public static IEnumerable`1<TResult> SelectNotNull(IEnumerable`1<TSource> enumerable, Func`2<TSource, Nullable`1<TResult>> selector);
    [IteratorStateMachineAttribute("JetBrains.Util.CollectionUtil/<Slice>d__76`1")]
[ExtensionAttribute]
[PureAttribute]
[NotNullAttribute]
[CollectionAccessAttribute("1")]
public static IEnumerable`1<TSource> Slice(IList`1<TSource> source, int from, int count);
    [IteratorStateMachineAttribute("JetBrains.Util.CollectionUtil/<DefaultIfEmptyLazy>d__77`1")]
[ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IEnumerable`1<T> DefaultIfEmptyLazy(IEnumerable`1<T> enumerable, Func`1<T> defaultValueFactory);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IEnumerable`1<T> EmptyIfNull(IEnumerable`1<T> enumerable);
    [ExtensionAttribute]
[PureAttribute]
public static ImmutableArray`1<T> EmptyIfNull(ImmutableArray`1<T> immarr);
    [ExtensionAttribute]
[PureAttribute]
public static ImmutableArray`1<T> EmptyIfNull(Nullable`1<ImmutableArray`1<T>> immarr);
    [ExtensionAttribute]
[CollectionAccessAttribute("6")]
public static void AddRange(ICollection`1<TTarget> to, IEnumerable`1<TSource> from);
    [ExtensionAttribute]
[CollectionAccessAttribute("6")]
public static void AddItems(ICollection`1<TTarget> to, TSource[] from);
    [ExtensionAttribute]
[CollectionAccessAttribute("6")]
public static void AddRange(ICollection`1<TTarget> to, IEnumerable`1<TSource> from, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
[NotNullAttribute]
[EditorBrowsableAttribute("1")]
[CollectionAccessAttribute("6")]
public static TCollection AddRangeFluent(TCollection to, IEnumerable`1<TItem> from);
    [ExtensionAttribute]
[CollectionAccessAttribute("2")]
public static void RemoveRange(ICollection`1<TTarget> collection, IEnumerable`1<TSource> items);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static List`1<T> AsList(IEnumerable`1<T> enumerable);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
[ObsoleteAttribute("It is never possible to cast an array to a List. A new List will always be created. Use ToList(), or change the receiving type.")]
public static List`1<T> AsList(T[] array);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IList`1<T> AsIList(IEnumerable`1<T> enumerable);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IReadOnlyList`1<T> AsChunkIReadOnlyList(IEnumerable`1<T> collection);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IReadOnlyList`1<T> AsIReadOnlyList(IEnumerable`1<T> enumerable);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IReadOnlyCollection`1<T> AsIReadOnlyCollection(IEnumerable`1<T> enumerable);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static ISet`1<T> AsSet(IEnumerable`1<T> enumerable);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static T[] AsArray(IEnumerable`1<T> enumerable);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static ICollection`1<T> AsCollection(IEnumerable`1<T> enumerable);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IReadOnlyCollection`1<T> AsReadOnlyCollection(IEnumerable`1<T> enumerable);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static ICollection`1<T> AsReadOnly(ICollection`1<T> collection);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static ISet`1<T> AsReadOnly(ISet`1<T> set);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
[NotNullAttribute]
[PureAttribute]
public static ICollection`1<T> AsReadOnly(JetReadOnlyCollection`1<T> collection);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IDictionary`2<TKey, TValue> AsReadOnly(IDictionary`2<TKey, TValue> dictionary);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
[NotNullAttribute]
[PureAttribute]
public static IDictionary`2<TKey, TValue> AsReadOnly(ReadOnlyDictionary`2<TKey, TValue> dictionary);
    [ExtensionAttribute]
[PureAttribute]
[CollectionAccessAttribute("1")]
public static int IndexOf(IList`1<T> list, T item, IEqualityComparer`1<T> comparer, int startSearchFromElement, int howManyElementsToSearch);
    [ExtensionAttribute]
[PureAttribute]
[CollectionAccessAttribute("1")]
public static int LastIndexOf(IList`1<T> list, T item, IEqualityComparer`1<T> comparer, int startSearchFromElement, int howManyElementsToSearch);
    [ExtensionAttribute]
[PureAttribute]
[CollectionAccessAttribute("1")]
public static int IndexOf(IReadOnlyList`1<T> list, T item);
    [NotNullAttribute]
[MustUseReturnValueAttribute]
public static ICollection`1<T> Sort(ICollection`1<T> collection, IComparer`1<T> comparer);
    [NotNullAttribute]
[MustUseReturnValueAttribute]
public static IList`1<T> Sort(ICollection`1<T> collection, Comparison`1<T> comparer);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsSorted(IEnumerable`1<T> enumerable, IComparer`1<T> comparer);
    [ExtensionAttribute]
public static void SortBy(List`1<T> list, Func`2<T, TKey> keySelector, IComparer`1<TKey> comparer);
    [IteratorStateMachineAttribute("JetBrains.Util.CollectionUtil/<EnumerateRecursivelyDfs>d__108`1")]
[PureAttribute]
[NotNullAttribute]
public static IEnumerable`1<T> EnumerateRecursivelyDfs(T root, Func`2<T, IEnumerable`1<T>> getChildren);
    [IteratorStateMachineAttribute("JetBrains.Util.CollectionUtil/<EnumerateRecursivelyBfs>d__109`1")]
[PureAttribute]
[NotNullAttribute]
public static IEnumerable`1<T> EnumerateRecursivelyBfs(T root, Func`2<T, IEnumerable`1<T>> getChildren);
    [PureAttribute]
[NotNullAttribute]
public static JetHashSet`1<T> EnumerateRecursivelyBfsDistinct(T root, Func`2<T, IEnumerable`1<T>> getChildren);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
[CollectionAccessAttribute("1")]
public static Stack`1<T> Clone(Stack`1<T> stack, Func`2<T, T> copyFunc);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
[CollectionAccessAttribute("1")]
public static JetHashSet`1<T> Clone(JetHashSet`1<T> set);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
[CollectionAccessAttribute("1")]
public static CompactSet`1<T> Clone(CompactSet`1<T> set);
    [ExtensionAttribute]
[PureAttribute]
[CollectionAccessAttribute("1")]
public static TValue TryGetValue(IDictionary`2<TKey, TValue> dictionary, TKey key, TValue defaultValue);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
[CollectionAccessAttribute("1")]
public static TValue TryGetValue(IDictionary`2<TKey, TValue> dictionary, TKey key);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
[CollectionAccessAttribute("1")]
public static Nullable`1<TValue> TryGetValueNullable(IDictionary`2<TKey, TValue> dictionary, TKey key);
    [ExtensionAttribute]
[PureAttribute]
[CollectionAccessAttribute("1")]
public static TValue GetValue(IDictionary`2<TKey, TValue> dictionary, TKey key, string exceptionText);
    [ExtensionAttribute]
[PureAttribute]
[CollectionAccessAttribute("1")]
[StringFormatMethodAttribute("exceptionFormat")]
public static TValue GetValue(IDictionary`2<TKey, TValue> dictionary, TKey key, string exceptionFormat, TArg argument);
    [ExtensionAttribute]
[MustUseReturnValueAttribute]
public static TValue GetOrCreateValue(IDictionary`2<TKey, TValue> dictionary, TKey key, Func`1<TValue> factory);
    [ExtensionAttribute]
[ObsoleteAttribute("Use ConcurrentDictionary API directly.")]
[MustUseReturnValueAttribute]
public static TValue GetOrCreateValue(ConcurrentDictionary`2<TKey, TValue> dictionary, TKey key, Func`1<TValue> factory);
    [ExtensionAttribute]
[MustUseReturnValueAttribute]
public static TValue GetOrCreateValue(IDictionary`2<TKey, TValue> dictionary, TKey key, Func`2<TKey, TValue> factory);
    [ExtensionAttribute]
[ObsoleteAttribute("Use ConcurrentDictionary API directly.")]
[MustUseReturnValueAttribute]
public static TValue GetOrCreateValue(ConcurrentDictionary`2<TKey, TValue> dictionary, TKey key, Func`2<TKey, TValue> factory);
    [ExtensionAttribute]
[MustUseReturnValueAttribute]
public static TValue GetOrCreateValue(IDictionary`2<TKey, TValue> dictionary, TKey key, TValue altValue);
    [ExtensionAttribute]
[ObsoleteAttribute("Use ConcurrentDictionary API directly.")]
[MustUseReturnValueAttribute]
public static TValue GetOrCreateValue(ConcurrentDictionary`2<TKey, TValue> dictionary, TKey key, TValue altValue);
    [ExtensionAttribute]
[PureAttribute]
public static bool EqualDictionaries(IDictionary`2<TKey, TValue> left, IDictionary`2<TKey, TValue> right);
    [ExtensionAttribute]
[PureAttribute]
public static bool EqualDictionaries(IDictionary`2<TKey, TValue> left, IDictionary`2<TKey, TValue> right, IEqualityComparer`1<TValue> comparer);
    [ExtensionAttribute]
[PureAttribute]
public static bool EqualDictionaries(IReadOnlyDictionary`2<TKey, TValue> left, IReadOnlyDictionary`2<TKey, TValue> right);
    [ExtensionAttribute]
[PureAttribute]
public static bool EqualDictionaries(IReadOnlyDictionary`2<TKey, TValue> left, IReadOnlyDictionary`2<TKey, TValue> right, IEqualityComparer`1<TValue> comparer);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static string AggregateString(IEnumerable`1<TSource> source, string separator, Func`3<StringBuilder, TSource, StringBuilder> funcAppend);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static TResult AggregateString(IEnumerable`1<TSource> source, string separator, Func`3<StringBuilder, TSource, StringBuilder> funcAppend, Func`2<StringBuilder, TResult> funcConvert);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static string AggregateString(IEnumerable`1<TSource> source, string seed, string separator, Func`3<StringBuilder, TSource, StringBuilder> funcAppend);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static TResult AggregateString(IEnumerable`1<TSource> source, string seed, string separator, Func`3<StringBuilder, TSource, StringBuilder> funcAppend, Func`2<StringBuilder, TResult> funcConvert);
    [ExtensionAttribute]
[NotNullAttribute]
public static string AggregateString(IEnumerable`1<TSource> source, StringBuilder seed, string separator, Func`3<StringBuilder, TSource, StringBuilder> funcAppend);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static string AggregateString(IEnumerable`1<TSource> source, Func`3<StringBuilder, TSource, StringBuilder> funcAppend);
    [ExtensionAttribute]
[NotNullAttribute]
public static TResult AggregateString(IEnumerable`1<TSource> source, StringBuilder seed, string separator, Func`3<StringBuilder, TSource, StringBuilder> funcAppend, Func`2<StringBuilder, TResult> funcConvert);
    [ExtensionAttribute]
[NotNullAttribute]
public static TAccumulator Aggregate(IEnumerable`1<TSource> source, TAccumulator builder, Action`1<TAccumulator> funcAppendSeparator, Action`2<TAccumulator, TSource> funcAppend);
    [ExtensionAttribute]
public static void SequenceForEach(IEnumerable`1<T1> first, IEnumerable`1<T2> second, Action`2<T1, T2> function);
    [ExtensionAttribute]
[PureAttribute]
public static IEnumerable`1<ValueTuple`2<T1, T2>> SequenceIterate(IEnumerable`1<T1> first, IEnumerable`1<T2> second);
    [IteratorStateMachineAttribute("JetBrains.Util.CollectionUtil/<Zip>d__139`2")]
[ExtensionAttribute]
[PureAttribute]
public static IEnumerable`1<ValueTuple`2<T1, T2>> Zip(IEnumerable`1<T1> first, IEnumerable`1<T2> second);
    [ExtensionAttribute]
[PureAttribute]
public static bool SequenceAny(IEnumerable`1<T1> first, IEnumerable`1<T2> second, Func`3<T1, T2, bool> predicate);
    [ExtensionAttribute]
[PureAttribute]
public static bool SequenceAny(IEnumerable`1<T1> first, IEnumerable`1<T2> second, T3 context, Func`4<T1, T2, T3, bool> predicate);
    [ExtensionAttribute]
[PureAttribute]
public static bool SequenceForAll(IEnumerable`1<T1> first, IEnumerable`1<T2> second, Func`3<T1, T2, bool> predicate);
    [ExtensionAttribute]
[PureAttribute]
public static IEnumerable`1<ValueTuple`2<T, int>> WithIndexes(IEnumerable`1<T> source);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
[CollectionAccessAttribute("1")]
public static T[] ToArray(ICollection`1<T> collection);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
[CollectionAccessAttribute("1")]
public static List`1<TOutput> ConvertAll(IList`1<TInput> list);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
[CollectionAccessAttribute("1")]
public static List`1<TOutput> ConvertAll(IList`1<TInput> list, Func`2<TInput, TOutput> converter);
    [ExtensionAttribute]
[PureAttribute]
[NotNullAttribute]
public static List`1<TResult> ToList(T[] source, Func`2<T, TResult> selector);
    [ExtensionAttribute]
[PureAttribute]
[NotNullAttribute]
[CollectionAccessAttribute("1")]
public static List`1<TResult> ToList(List`1<T> source, Func`2<T, TResult> selector);
    [ExtensionAttribute]
[PureAttribute]
[NotNullAttribute]
public static List`1<TResult> ToList(IEnumerable`1<T> enumerable, Func`2<T, TResult> selector);
    [ExtensionAttribute]
[PureAttribute]
[NotNullAttribute]
public static IList`1<TResult> ToIList(T[] source, Func`2<T, TResult> selector);
    [ExtensionAttribute]
[PureAttribute]
[NotNullAttribute]
[CollectionAccessAttribute("1")]
public static IList`1<TResult> ToIList(List`1<T> source, Func`2<T, TResult> selector);
    [ExtensionAttribute]
[PureAttribute]
[NotNullAttribute]
public static IList`1<TResult> ToIList(IEnumerable`1<T> source, Func`2<T, TResult> selector);
    [ExtensionAttribute]
[PureAttribute]
[NotNullAttribute]
public static IList`1<T> ToIList(T[] source);
    [ExtensionAttribute]
[PureAttribute]
[NotNullAttribute]
public static IList`1<T> ToIList(IEnumerable`1<T> enumerable);
    [ExtensionAttribute]
[PureAttribute]
[NotNullAttribute]
public static IReadOnlyList`1<T> ToIReadOnlyList(T[] source);
    [ExtensionAttribute]
[PureAttribute]
[NotNullAttribute]
public static IReadOnlyList`1<T> ToIReadOnlyList(IEnumerable`1<T> enumerable);
    [ExtensionAttribute]
[PureAttribute]
[NotNullAttribute]
public static IReadOnlyList`1<TResult> ToIReadOnlyList(IEnumerable`1<T> source, Func`2<T, TResult> selector);
    [ExtensionAttribute]
[PureAttribute]
[NotNullAttribute]
public static IReadOnlyList`1<TResult> ToIReadOnlyList(T[] source, Func`2<T, TResult> selector);
    [ExtensionAttribute]
[PureAttribute]
[NotNullAttribute]
[CollectionAccessAttribute("1")]
public static IReadOnlyList`1<TResult> ToIReadOnlyList(List`1<T> source, Func`2<T, TResult> selector);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static T[] ArrayUnion(T[] array, T item);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static T[] ArrayUnion(T[] array, T item, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static T[] ArrayExcept(T[] thіs, T item);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static T[] ArrayExcept(T[] array, T item, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static void Add(ICollection`1<T> collection, Lifetime lifetime, T item);
    [ExtensionAttribute]
public static void AddLocked(ICollection`1<T> collection, Lifetime lifetime, Func`1<IDisposable> lock, T item);
    [ExtensionAttribute]
public static void AddRange(ICollection`1<T> collection, Lifetime lifetime, IEnumerable`1<T> items);
    [ExtensionAttribute]
public static void Deconstruct(IGrouping`2<TKey, TValue> grouping, TKey& key, IEnumerable`1& values);
    [ExtensionAttribute]
public static void CopyTo(IEnumerable`1<TItem> enumerable, TItem[] array, int arrayIndex);
    public static bool SetDifference(HashSet`1<T> oldSet, HashSet`1<T> newSet, HashSet`1<T> addedItems, HashSet`1<T> removedItems);
    public static bool SetDifference(HashSet`1<T> oldSet, HashSet`1<T> newSet, HashSet`1& addedItems, HashSet`1& removedItems);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static HashSet`1<TKey> ToHashSet(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector);
    [ExtensionAttribute]
[PureAttribute]
[NotNullAttribute]
public static T Intern(HashSet`1<T> source, T value);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IEnumerable`1<TTarget> SafeOfType(IEnumerable enumerable);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Please, avoid use of this method. Check the documentation for details")]
public static void ForEach(IEnumerable`1<T> collection, Action`1<T> action);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IList`1<T> Reverse(IList`1<T> list);
    [ExtensionAttribute]
[PureAttribute]
public static bool Contains(IReadOnlyCollection`1<T> list, T item);
    [IteratorStateMachineAttribute("JetBrains.Util.CollectionUtil/<Except>d__177`1")]
[ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IEnumerable`1<T> Except(IEnumerable`1<T> enumerable, T element);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IEnumerable`1<T> Union(IEnumerable`1<T> enumerable, T element);
    [IteratorStateMachineAttribute("JetBrains.Util.CollectionUtil/<Unfold>d__179`1")]
[NotNullAttribute]
public static IEnumerable`1<T> Unfold(T element, Func`2<T, T> next, Func`2<T, bool> include);
    [IteratorStateMachineAttribute("JetBrains.Util.CollectionUtil/<Interleave>d__180`1")]
[ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IEnumerable`1<T> Interleave(IEnumerable`1<T> lhs, IEnumerable`1<T> rhs);
    [ExtensionAttribute]
public static void DisposeAll(IEnumerable`1<TDisposable> enumerable);
}
public static class JetBrains.Util.CommandLineUtil : object {
    private static string ParameterPrefix;
    private static string ParameterToValueSplitter;
    private static Char[] ourQuotableChars;
    private static CommandLineUtil();
    public static string ComposeArgument(string parameterKey, string parameterValue, string keyPrefix, string keyValueDelimiter);
    [NotNullAttribute]
public static string ToString(IEnumerable`1<string> args);
    public static void ToString(StringBuilder builder, string arg, bool addQuote);
    [NotNullAttribute]
public static string Quote(string arg);
    [NotNullAttribute]
public static string QuoteIfNeeded(string arg);
    [CanBeNullAttribute]
private static string ParseFirstArgument(string args, int startIdx, Int32& restIdx);
    [CanBeNullAttribute]
public static FirstArgumentResult ParseFirstArgument(string args);
    [NotNullAttribute]
public static String[] ToArray(string args);
    [IteratorStateMachineAttribute("JetBrains.Util.CommandLineUtil/<Enumerate>d__11")]
[NotNullAttribute]
public static IEnumerable`1<string> Enumerate(string args);
    [NotNullAttribute]
public static String[] ToArrayWinApi(string unsplitArgumentLine);
    private static IntPtr CommandLineToArgvW(string lpCmdLine, Int32& pNumArgs);
    private static IntPtr LocalFree(IntPtr hMem);
}
public static class JetBrains.Util.CommonConstant : object {
    public static string StacktraceMark;
}
public class JetBrains.Util.CompoundException : ApplicationException {
    private LocalLazy`2<OnError, CompoundException> myOnError;
    [CompilerGeneratedAttribute]
private IList`1<Exception> <Exceptions>k__BackingField;
    [NotNullAttribute]
public IList`1<Exception> Exceptions { get; }
    public string Message { get; }
    [NotNullAttribute]
public OnError OnError { get; }
    public CompoundException(Exception[] exceptions);
    protected CompoundException(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public IList`1<Exception> get_Exceptions();
    public virtual string get_Message();
    public OnError get_OnError();
    public void Catch(Action action);
    [CanBeNullAttribute]
public Exception ExtractException();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public void ThrowIfFailed();
    public virtual string ToString();
    [NotNullAttribute]
protected IList`1<Exception> GetDistinctExceptions();
    [CompilerGeneratedAttribute]
internal static Exception <GetDistinctExceptions>g__UnwrapLoggerException|16_0(Exception exception);
}
public class JetBrains.Util.Concurrency.AffinalReaderWriterSlimWrapper : ReaderWriterSlimWrapper {
    public AffinalReaderWriterSlimWrapper(Thread dispatcherThread);
}
public class JetBrains.Util.Concurrency.ConcurrentArray`1 : object {
    [NotNullAttribute]
private ImmutableArray`1<T> myArray;
    public void Add(T item);
    public void AddRange(ICollection`1<T> items);
    public bool Remove(T item);
    public bool RemoveRange(ICollection`1<T> items);
    public void Add(Lifetime lifetime, T item);
    public void AddRange(Lifetime lifetime, ICollection`1<T> items);
    public ImmutableArray`1<T> TakeSnapshot();
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[CompilerFeatureRequiredAttribute("RefStructs")]
[IsReadOnlyAttribute]
public class JetBrains.Util.Concurrency.DisposableReadLock : ValueType {
    private ReaderWriterLockSlim myLock;
    public DisposableReadLock(ReaderWriterLockSlim lock);
    public void Dispose();
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[CompilerFeatureRequiredAttribute("RefStructs")]
[IsReadOnlyAttribute]
public class JetBrains.Util.Concurrency.DisposableWriteLock : ValueType {
    private ReaderWriterLockSlim myLock;
    public DisposableWriteLock(ReaderWriterLockSlim lock);
    public void Dispose();
}
public class JetBrains.Util.Concurrency.Events.BclEventWaitHandle : object {
    private EventWaitHandle myWaitHandle;
    public BclEventWaitHandle(bool initialState, EventResetMode mode, string name);
    public sealed virtual void Dispose();
    public sealed virtual void Set();
    public sealed virtual void Reset();
    public sealed virtual bool IsSet();
    public sealed virtual bool WaitOne(int timeout);
    public sealed virtual Nullable`1<bool> MsgWaitOne(int timeout);
    public sealed virtual void WaitOne();
    public sealed virtual bool MsgWaitOne();
}
public interface JetBrains.Util.Concurrency.Events.IEventWaitHandle {
    public abstract virtual void Set();
    public abstract virtual void Reset();
    public abstract virtual bool IsSet();
    public abstract virtual bool WaitOne(int timeout);
    public abstract virtual Nullable`1<bool> MsgWaitOne(int timeout);
    public abstract virtual void WaitOne();
    public abstract virtual bool MsgWaitOne();
}
public class JetBrains.Util.Concurrency.EventWaitHandleBase : object {
    private IEventWaitHandle myImplementation;
    protected EventWaitHandleBase(IEventWaitHandle implementation);
    public sealed virtual void Dispose();
    public sealed virtual void Set();
    public sealed virtual void Reset();
    public sealed virtual bool IsSet();
    public sealed virtual bool WaitOne(int timeout);
    public sealed virtual Nullable`1<bool> MsgWaitOne(int timeout);
    public sealed virtual void WaitOne();
    public sealed virtual bool MsgWaitOne();
}
[ExtensionAttribute]
public static class JetBrains.Util.Concurrency.ExecutionContextEx : object {
    [ExtensionAttribute]
public static void Run(ExecutionContext context, ContextCallback callback, object state);
    [ExtensionAttribute]
public static void Run(ExecutionContext context, Action action);
}
public class JetBrains.Util.Concurrency.FrugalLocalLazy`1 : ValueType {
    private T myValue;
    public bool IsValueCreated { get; }
    [PureAttribute]
public bool get_IsValueCreated();
    [PureAttribute]
public T GetValue();
    private static T CreateValue();
    public virtual string ToString();
}
[ExtensionAttribute]
public static class JetBrains.Util.Concurrency.GroupingEventHostEx : object {
    [ExtensionAttribute]
public static void QueueAtShort(GroupingEventHost host, Lifetime lifetime, string name, TimeSpan interval, Action F);
}
public interface JetBrains.Util.Concurrency.IJetDispatcherPlatformSpecific {
    public abstract virtual IPlatformDispatcherImpl CreatePlatformDispatcherImpl();
    public abstract virtual ITimer CreateDispatcherTimer();
    public abstract virtual ITimer CreateDispatcherTimer(int interval);
    public abstract virtual int PumpMessagesOnce();
    public abstract virtual MessageLoopStatus Run(IProperty`1<bool> condition, TimeSpan timeout, bool bThrowOnTimeout);
    public abstract virtual MessageLoopStatus Run(Func`1<bool> condition, TimeSpan timeout, bool bThrowOnTimeout);
    public abstract virtual void Run();
}
public class JetBrains.Util.Concurrency.InterlockedUtil : object {
    public static void Increment(Int32& val, int inc);
    public static void Decrement(Int32& val, int dec);
    public static bool SetFlags(Int32& flags, int toSet);
    public static bool ClearFlags(Int32& flags, int toClear);
    public static double Add(Double& location, double value);
}
public class JetBrains.Util.Concurrency.InterruptibleLazy`1 : object {
    [CanBeNullAttribute]
private Func`1<T> myValueFactory;
    private SpinWaitLock myLock;
    private T myValue;
    [DebuggerBrowsableAttribute("0")]
public T Value { get; }
    public InterruptibleLazy`1(Func`1<T> valueFactory);
    public InterruptibleLazy`1(T value);
    public T get_Value();
    public virtual string ToString();
}
public class JetBrains.Util.Concurrency.InterruptibleLazy`2 : object {
    private Func`2<TParam, T> myValueFactory;
    private TParam myParam;
    private T myValue;
    private SpinWaitLock myLock;
    public T Value { get; }
    public InterruptibleLazy`2(TParam param, Func`2<TParam, T> func);
    public T get_Value();
}
public interface JetBrains.Util.Concurrency.ISync {
    public string Name { get; }
    public abstract virtual string get_Name();
    public abstract virtual void Acquire();
    public abstract virtual bool TryAcquire(int timeoutTicks);
    public abstract virtual void Release();
    public abstract virtual bool HasWriteAccess(Thread thread);
    public abstract virtual bool HasReadAccess(Thread thread);
    public abstract virtual bool HasUpgradableReadAccess(Thread thread);
}
[ThreadSafeAttribute]
[ObsoleteAttribute("This class will be removed in 2023.3")]
public class JetBrains.Util.Concurrency.JetConcurrentQueue`1 : object {
    private static long BlockingOperationInProgressMarker;
    private T[] myQueue;
    private long myMask;
    private int mySize;
    private long myHead;
    private long myTail;
    public int Count { get; }
    public object SyncRoot { get; }
    public bool IsSynchronized { get; }
    public bool IsEmpty { get; }
    public JetConcurrentQueue`1(int logMaxSize);
    private bool IsBlocked(long head, long tail);
    public sealed virtual bool TryAdd(T t);
    public bool TryDequeue(T& res);
    public bool TryPeek(T& res);
    public sealed virtual int get_Count();
    public sealed virtual void CopyTo(T[] array, int index);
    public sealed virtual T[] ToArray();
    public sealed virtual void CopyTo(Array array, int index);
    public void Clear();
    private void DoImmutableBlockingOp(Action`2<long, long> op);
    private TParam DoImmutableBlockingOp(Func`3<long, long, TParam> op);
    public sealed virtual object get_SyncRoot();
    public sealed virtual bool get_IsSynchronized();
    public bool get_IsEmpty();
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual bool TryTake(T& res);
    public T Dequeue();
    public T Peek();
    [CompilerGeneratedAttribute]
private T[] <ToArray>b__14_0(long head, long tail);
}
[ExtensionAttribute]
public static class JetBrains.Util.Concurrency.JetThreadApartment : object {
    private static ConcurrentDictionary`2<Thread, bool> ourStaThreads;
    private static JetThreadApartment();
    public static void STAThread();
    [ExtensionAttribute]
public static void SetJetApartmentState(Thread thread, ApartmentState state);
    [ExtensionAttribute]
public static ApartmentState GetJetApartmentState(Thread thread);
    [ExtensionAttribute]
private static void SetJetApartmentStateInternal(Thread thread, ApartmentState state);
    private static void RemoveDeadThreads();
}
public enum JetBrains.Util.Concurrency.LazyExecutionMode : Enum {
    public int value__;
    public static LazyExecutionMode NotThreadSafe;
    public static LazyExecutionMode AllowMultipleThreadSafeExecution;
    public static LazyExecutionMode EnsureSingleThreadSafeExecution;
}
public class JetBrains.Util.Concurrency.LocalLazy`1 : ValueType {
    private int myFlags;
    private SpinWaitLock myLockFlag;
    private TValue myValue;
    private Func`1<TValue> myValueFactory;
    private static int FlagIsValueCreated;
    public bool IsValueCreated { get; }
    public LocalLazy`1(LazyExecutionMode mode);
    public LocalLazy`1(Func`1<TValue> valueFactory, LazyExecutionMode mode);
    public LocalLazy`1(TValue valuePreFactored);
    [PureAttribute]
public bool get_IsValueCreated();
    public TValue GetValue();
    private TValue CreateValue();
    private TValue CreateValueWithMode();
    [PureAttribute]
public virtual string ToString();
}
public class JetBrains.Util.Concurrency.LocalLazy`2 : ValueType {
    private int myFlags;
    private SpinWaitLock myLockFlag;
    private TValue myValue;
    private Func`2<TFactoryParameter, TValue> myFValueFactory;
    private TFactoryParameter myFactoryParameter;
    private static int FlagIsValueCreated;
    public bool IsValueCreated { get; }
    public LocalLazy`2(Func`2<TFactoryParameter, TValue> FFactory, TFactoryParameter parameter);
    public LocalLazy`2(Func`2<TFactoryParameter, TValue> FFactory, TFactoryParameter parameter, LazyExecutionMode mode);
    [PureAttribute]
public bool get_IsValueCreated();
    public TValue GetValue();
    private TValue CreateValue();
    private TValue CreateValueWithMode();
    [PureAttribute]
public virtual string ToString();
}
[IsReadOnlyAttribute]
public class JetBrains.Util.Concurrency.LockableObject`1 : ValueType {
    [NotNullAttribute]
private LockObject myLockObject;
    private TimeSpan myTimeout;
    [NotNullAttribute]
private TValue myValue;
    public LockableObject`1(LockObject lockObject, TValue value, TimeSpan timeout);
    [MustUseReturnValueAttribute]
public ObjectWithLockTaken`1<TValue> UsingLock();
}
public class JetBrains.Util.Concurrency.LockObject : object {
    [PureAttribute]
public LockableObject`1<TValue> MakeLockableObject(TValue value, TimeSpan timeout);
    [MustUseReturnValueAttribute]
public Locked UsingLock(TimeSpan timeout);
    [MustUseReturnValueAttribute]
public ObjectWithLockTaken`1<TValue> UsingLockFor(TValue value, TimeSpan timeout);
}
public enum JetBrains.Util.Concurrency.MessageLoopStatus : Enum {
    public int value__;
    public static MessageLoopStatus DispatcherImplShutdown;
    public static MessageLoopStatus Error;
    public static MessageLoopStatus Condition;
    public static MessageLoopStatus Timeout;
}
public class JetBrains.Util.Concurrency.NativeAutoEvent : EventWaitHandleBase {
    public NativeAutoEvent(bool initialState, string name);
}
internal class JetBrains.Util.Concurrency.NativeEvent : object {
    private static int INFINITE;
    private string myName;
    private IntPtr myNativeHandle;
    internal NativeEvent(bool initialState, EventResetMode mode, string name);
    private static IntPtr CreateEvent(IntPtr lpEventAttributes, bool bManualReset, bool bInitialState, string lpName);
    private static bool SetEvent(IntPtr hEvent);
    private static bool ResetEvent(IntPtr hEvent);
    private static UInt32 WaitForSingleObject(IntPtr hEvent, int timeout);
    private static UInt32 MsgWaitForMultipleObjects(UInt32 nCount, IntPtr[] pHandles, bool fWaitAll, int dwMilliseconds, UInt32 dwWakeMask);
    private static UInt32 CloseHandle(IntPtr hEvent);
    public sealed virtual void Dispose();
    public sealed virtual void Set();
    public sealed virtual void Reset();
    public sealed virtual bool IsSet();
    public sealed virtual bool WaitOne(int timeout);
    public sealed virtual Nullable`1<bool> MsgWaitOne(int timeout);
    public sealed virtual void WaitOne();
    public sealed virtual bool MsgWaitOne();
}
public class JetBrains.Util.Concurrency.NativeManualEvent : EventWaitHandleBase {
    public NativeManualEvent(bool initialState, string name);
}
public class JetBrains.Util.Concurrency.ObjectWithLockTaken`1 : ValueType {
    [CanBeNullAttribute]
private LockObject myLockObject;
    private TValue myValue;
    public TValue Value { get; }
    public ObjectWithLockTaken`1(LockObject lockobject, TValue value, TimeSpan& timeout);
    public TValue get_Value();
    public sealed virtual void Dispose();
}
public class JetBrains.Util.Concurrency.ParamerizedGroupingEvent`1 : object {
    private GroupingEvent myEvent;
    private HashSet`1<TParameter> myRequests;
    public ParamerizedGroupingEvent`1(Lifetime lifetime, GroupingEventHost host, string name, TimeSpan interval, Action`1<IList`1<TParameter>> handler);
    public void FireIncoming(TParameter parameter);
}
[ExtensionAttribute]
public static class JetBrains.Util.Concurrency.ReaderWriterLockSlimEx : object {
    [ExtensionAttribute]
public static void EnterWriteLock(ReaderWriterLockSlim thіs, TimeSpan time);
    [ExtensionAttribute]
[NotNullAttribute]
public static IDisposable UsingWriteLock(ReaderWriterLockSlim thіs, TimeSpan time);
    [ExtensionAttribute]
public static DisposableWriteLock UsingWriteLock(ReaderWriterLockSlim thіs);
    [ExtensionAttribute]
public static void UsingWriteLock(ReaderWriterLockSlim thіs, Action action);
    [ExtensionAttribute]
public static void EnterReadLock(ReaderWriterLockSlim thіs, TimeSpan time);
    [ExtensionAttribute]
public static void EnterReadLock(ReaderWriterLockSlim thіs, int timeoutms);
    [ExtensionAttribute]
[NotNullAttribute]
public static IDisposable UsingReadLock(ReaderWriterLockSlim thіs, TimeSpan time);
    [ExtensionAttribute]
public static DisposableReadLock UsingReadLock(ReaderWriterLockSlim thіs);
    [ExtensionAttribute]
public static void EnterUpgradeableReadLock(ReaderWriterLockSlim thіs, TimeSpan time);
    [ExtensionAttribute]
[NotNullAttribute]
public static IDisposable UsingUpgradeableReadLock(ReaderWriterLockSlim thіs, TimeSpan time);
}
public class JetBrains.Util.Concurrency.ReaderWriterSlimWrapper : object {
    [NotNullAttribute]
protected ReaderWriterLockSlim Lock;
    [CompilerGeneratedAttribute]
private ISync <ReadLock>k__BackingField;
    [CompilerGeneratedAttribute]
private ISync <UpgradableReadLock>k__BackingField;
    [CompilerGeneratedAttribute]
private ISync <WriteLock>k__BackingField;
    public ISync ReadLock { get; protected set; }
    public ISync UpgradableReadLock { get; protected set; }
    public ISync WriteLock { get; protected set; }
    [CompilerGeneratedAttribute]
public sealed virtual ISync get_ReadLock();
    [CompilerGeneratedAttribute]
protected void set_ReadLock(ISync value);
    [CompilerGeneratedAttribute]
public sealed virtual ISync get_UpgradableReadLock();
    [CompilerGeneratedAttribute]
protected void set_UpgradableReadLock(ISync value);
    [CompilerGeneratedAttribute]
public sealed virtual ISync get_WriteLock();
    [CompilerGeneratedAttribute]
protected void set_WriteLock(ISync value);
    public bool HasReadAccess();
    public bool HasUpgradableReadAccess();
    public bool HasWriteAccess();
}
public interface JetBrains.Util.Concurrency.ReadWriteLock {
    [NotNullAttribute]
public ISync ReadLock { get; }
    [NotNullAttribute]
public ISync WriteLock { get; }
    public abstract virtual ISync get_ReadLock();
    public abstract virtual ISync get_WriteLock();
}
public class JetBrains.Util.Concurrency.ReentrantWriterPreferenceReadWriteLock : object {
    private ReaderLock myReaderLock;
    private WriterLock myWriterLock;
    private ThreadToCountMap myReaders;
    private Thread modreq(System.Runtime.CompilerServices.IsVolatile) myActiveWriter;
    private int myWriteKnock;
    private int myWriteHolds;
    private NativeManualEvent myCanReadEvent;
    private NativeManualEvent myCanWriteEvent;
    private NativeManualEvent myCanWriteExceptOneReaderEvent;
    private bool myMeasureUiSmoothness;
    public ISync WriteLock { get; }
    public ISync ReadLock { get; }
    public bool IsWriteLockRequested { get; }
    public bool IsWriteLockAcquiredForCurrentThread { get; }
    public ReentrantWriterPreferenceReadWriteLock(bool measureUiSmoothness);
    public sealed virtual ISync get_WriteLock();
    public sealed virtual ISync get_ReadLock();
    public bool get_IsWriteLockRequested();
    public bool IsReadLockAcquired(Thread thread);
    public bool get_IsWriteLockAcquiredForCurrentThread();
    public bool IsWriteLockAcquired(Thread thread);
}
public class JetBrains.Util.Concurrency.ResourceCounter : object {
    internal int ValueInternal;
    public int Value { get; }
    public ResourceCounterCookie Cookie();
    public int get_Value();
}
public class JetBrains.Util.Concurrency.ResourceCounterCookie : ValueType {
    private ResourceCounter myCounter;
    internal ResourceCounterCookie(ResourceCounter counter);
    public sealed virtual void Dispose();
}
public class JetBrains.Util.Concurrency.SpinWaitLockRef : object {
    private SpinWaitLock myLock;
    public void Enter();
    public void Exit();
    public SpinWaitLockRefDispose Push();
}
[ExtensionAttribute]
public static class JetBrains.Util.Concurrency.SyncExtensions : object {
    [ExtensionAttribute]
[ConditionalAttribute("JET_MODE_ASSERT")]
public static void AssertReadAccess(ISync sync, string message);
    [ExtensionAttribute]
[ConditionalAttribute("JET_MODE_ASSERT")]
public static void AssertWriteAccess(ISync sync, string message);
    [ExtensionAttribute]
public static SyncCookie Using(ISync sync);
    [ExtensionAttribute]
public static SyncCookie Using(ISync sync, TimeSpan relaxedTimeout);
}
public enum JetBrains.Util.Concurrency.TaskAffinity : Enum {
    public int value__;
    public static TaskAffinity ThreadPool;
    public static TaskAffinity CallerThreadSync;
    public static TaskAffinity UiThread;
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[CompilerFeatureRequiredAttribute("RefStructs")]
[IsReadOnlyAttribute]
public class JetBrains.Util.Concurrency.Threading.MonitorInterruptibleCookie : ValueType {
    private object myLocker;
    public bool Success { get; }
    private MonitorInterruptibleCookie(object locker);
    public bool get_Success();
    [MustUseReturnValueAttribute]
public static MonitorInterruptibleCookie TryEnter(object locker);
    [MustUseReturnValueAttribute]
public static MonitorInterruptibleCookie EnterOrThrow(object locker);
    public void Dispose();
}
public class JetBrains.Util.Concurrency.Threading.SequentialScheduler : TaskScheduler {
    private bool myAllowInlining;
    private ThreadLocal`1<UInt32> myExecutionCount;
    private SyncContext mySyncContext;
    private AsyncChannel`1<Task> myChannel;
    private ILog myLog;
    public bool IsActive { get; }
    public bool OutOfOrderExecution { get; }
    [ObsoleteAttribute("Use the overload without lifetime")]
public SequentialScheduler(string id, Lifetime _, TaskScheduler scheduler);
    public SequentialScheduler(string id, TaskScheduler scheduler, bool allowInlining);
    public sealed virtual bool get_IsActive();
    public sealed virtual bool get_OutOfOrderExecution();
    [ObsoleteAttribute("Use the overload without lifetime")]
public static SequentialScheduler FromIScheduler(string id, Lifetime lifetime, IScheduler scheduler);
    public static SequentialScheduler FromIScheduler(string id, IScheduler scheduler, bool allowInlining);
    public sealed virtual void Queue(Action action);
    protected virtual void QueueTask(Task task);
    private bool TryExecuteTaskWithContext(Task task);
    protected virtual bool TryExecuteTaskInline(Task task, bool taskWasPreviouslyQueued);
    protected virtual IEnumerable`1<Task> GetScheduledTasks();
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("JetBrains.Util.Concurrency.Threading.SequentialScheduler/<<-ctor>b__12_0>d")]
[CompilerGeneratedAttribute]
private Task <.ctor>b__12_0();
}
[ObsoleteAttribute("Use JetBrains.Lifetimes.Lifetime.CreateTaskCompletionSource")]
public class JetBrains.Util.Concurrency.Threading.Tasks.LifetimedTaskCompletionSource`1 : TaskCompletionSource`1<T> {
    public LifetimedTaskCompletionSource`1(Lifetime lifetime);
}
[IsReadOnlyAttribute]
public class JetBrains.Util.Concurrency.Threading.Tasks.SchedulerAwaiter : ValueType {
    private bool myIsExecuteInline;
    private OuterLifetime myLifetime;
    private Nullable`1<TaskPriority> myPriority;
    [NotNullAttribute]
private TaskScheduler myScheduler;
    private TaskCreationOptions myTaskCreationOptions;
    public bool IsCompleted { get; }
    public SchedulerAwaiter(OuterLifetime lifetime, TaskScheduler scheduler, Nullable`1<TaskPriority> priority, TaskCreationOptions taskCreationOptions, bool isExecuteInline);
    public bool get_IsCompleted();
    public SchedulerAwaiter GetAwaiter();
    public void GetResult();
    public sealed virtual void OnCompleted(Action continuation);
    private void OnCompleted_Fail(Action continuation, Exception ex, TaskJetProperties properties);
}
public class JetBrains.Util.Concurrency.Threading.Tasks.SyncTaskBarrier : object {
    private ConcurrentQueue`1<Action> myQueue;
    public sealed virtual void EnqueueJob(Action action);
    public sealed virtual void EnqueueJob(string name, Action action);
    public sealed virtual void WaitAll();
    public sealed virtual void Dispose();
}
[ExtensionAttribute]
public static class JetBrains.Util.Concurrency.Threading.Tasks.TaskUtil : object {
    public static Task WaitForInterruptAsync(Lifetime lifetime, bool continueOnCapturedContext, int maxDelay);
    [AsyncStateMachineAttribute("JetBrains.Util.Concurrency.Threading.Tasks.TaskUtil/<WaitForInterruptAsync>d__1")]
public static Task WaitForInterruptAsync(Func`1<bool> checkForInterrupt, bool continueOnCapturedContext, int maxDelay);
    public static Task CheckForInterruptAsync(Lifetime lifetime, bool continueOnCapturedContext, int maxDelay);
    public static Task CheckForInterruptAsync(Func`1<bool> checkForInterrupt, bool continueOnCapturedContext, int maxDelay);
    [AsyncStateMachineAttribute("JetBrains.Util.Concurrency.Threading.Tasks.TaskUtil/<GetFirstOrDefaultResultAsync>d__4`1")]
[ExtensionAttribute]
public static Task`1<T> GetFirstOrDefaultResultAsync(IEnumerable`1<Task`1<T>> tasks, Lifetime lifetime, Func`2<T, bool> predicate);
}
public static class JetBrains.Util.Concurrency.Threading.UnlimitedThreadPool : object {
    private static int ourTimeoutUntilNewThreadMs;
    private static ConcurrentQueue`1<Job> ourJobs;
    private static ParameterizedThreadStart ourThreadDelegate;
    private static WaitCallback ourThreadPoolDelegate;
    private static ILogger ourLogger;
    private static int ourThreadsAliveCount;
    [PublicAPIAttribute]
public static int TimeoutUntilNewThreadMs { get; }
    private static UnlimitedThreadPool();
    private static void ThreadProc();
    [PublicAPIAttribute]
public static void Queue(Action action);
    public static int get_TimeoutUntilNewThreadMs();
    [PublicAPIAttribute]
public static void SetTimeoutUntilNewThreadCreated(Lifetime lifetime, int newTimeoutMs);
}
[PublicAPIAttribute]
public class JetBrains.Util.Concurrency.Threading.UnlimitedThreadPoolScheduler : TaskScheduler {
    public static UnlimitedThreadPoolScheduler Instance;
    public bool IsActive { get; }
    public bool OutOfOrderExecution { get; }
    private static UnlimitedThreadPoolScheduler();
    protected virtual void QueueTask(Task task);
    protected virtual bool TryExecuteTaskInline(Task task, bool taskWasPreviouslyQueued);
    [IteratorStateMachineAttribute("JetBrains.Util.Concurrency.Threading.UnlimitedThreadPoolScheduler/<GetScheduledTasks>d__4")]
protected virtual IEnumerable`1<Task> GetScheduledTasks();
    public sealed virtual void Queue(Action action);
    public sealed virtual bool get_IsActive();
    public sealed virtual bool get_OutOfOrderExecution();
}
public interface JetBrains.Util.Concurrency.Timer.ITimer {
    public int Interval { get; public set; }
    public bool Enabled { get; public set; }
    public abstract virtual int get_Interval();
    public abstract virtual void set_Interval(int value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_Tick(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Tick(EventHandler value);
    public abstract virtual bool get_Enabled();
    public abstract virtual void set_Enabled(bool value);
    public abstract virtual void Start();
    public abstract virtual void Stop();
}
public class JetBrains.Util.Concurrency.Timer.JetTimer : object {
    private int myIntervalMs;
    private Timer myTimer;
    private EventHandler myEventHandler;
    private TimerCallback myCallback;
    private JetDispatcher myDispatcher;
    private int myIsTickMessageQueued;
    private bool myEnabled;
    private bool myDisposed;
    private object myCookie;
    private object myLock;
    public bool Enabled { get; public set; }
    public int Interval { get; public set; }
    public JetTimer(int intervalMs);
    public sealed virtual void add_Tick(EventHandler value);
    public sealed virtual void remove_Tick(EventHandler value);
    public sealed virtual bool get_Enabled();
    public sealed virtual void set_Enabled(bool value);
    private void UpdateTimer();
    public sealed virtual int get_Interval();
    public sealed virtual void set_Interval(int value);
    public sealed virtual void Start();
    public sealed virtual void Stop();
    private void TickCallback(object state);
    private void Close();
    public sealed virtual void Dispose();
}
public class JetBrains.Util.Concurrency.Timer.ThreadPoolTimer : object {
    [NotNullAttribute]
private Lifetime myLifetime;
    [NotNullAttribute]
private Action myOnTick;
    private bool myAllowReentrancy;
    private Timer myTimer;
    private int myIsInCallback;
    public ThreadPoolTimer(Lifetime lifetime, Action onTick, bool allowReentrancy);
    public ThreadPoolTimer(Lifetime lifetime, TimeSpan period, Action onTick, bool allowReentrancy);
    public ThreadPoolTimer(Lifetime lifetime, TimeSpan duetime, TimeSpan period, Action onTick, bool allowReentrancy);
    public void Start(TimeSpan period);
    public void Stop();
    public void Change(TimeSpan duetime, TimeSpan period);
    [HandleProcessCorruptedStateExceptionsAttribute]
private void Callback(object state);
}
public class JetBrains.Util.Concurrency.Timer.WinformTimer : object {
    private Timer myTimer;
    public int Interval { get; public set; }
    public bool Enabled { get; public set; }
    public WinformTimer(int intervalMs);
    public sealed virtual int get_Interval();
    public sealed virtual void set_Interval(int value);
    public sealed virtual void add_Tick(EventHandler value);
    public sealed virtual void remove_Tick(EventHandler value);
    public sealed virtual bool get_Enabled();
    public sealed virtual void set_Enabled(bool value);
    public sealed virtual void Start();
    public sealed virtual void Stop();
    public sealed virtual void Dispose();
}
public class JetBrains.Util.Concurrency.UiSmoothnessToolkit : object {
    private static ILogger ourLogger;
    public static int MillisecondsToWaitWriteLockThreshold;
    public static Thread UiThread;
    private static int ourActionUpdateOnUIThreadCounter;
    private static ConcurrentDictionary`2 modreq(System.Runtime.CompilerServices.IsVolatile) ourThreadFramesMap;
    [CanBeNullAttribute]
private static PlaybackHelper modreq(System.Runtime.CompilerServices.IsVolatile) ourPlaybackHelper;
    private static Boolean modreq(System.Runtime.CompilerServices.IsVolatile) ourCaptureUiSuspensionStacks;
    private static long ourEnableCount;
    private static object ourEnableLock;
    [ThreadStaticAttribute]
private static Nullable`1<LocalStopwatch> ourLastInterruptStopwatch;
    private static Signal`1<Nullable`1<LocalStopwatch>> ourCheckForInterruptCalled;
    private static LoggingLevel ourLoggingLevel;
    public static ISource`1<Nullable`1<LocalStopwatch>> CheckForInterruptCalled { get; }
    private static bool Enabled { get; private set; }
    private static UiSmoothnessToolkit();
    public static ISource`1<Nullable`1<LocalStopwatch>> get_CheckForInterruptCalled();
    private static bool get_Enabled();
    private static void set_Enabled(bool value);
    public static void Enable(Lifetime lifetime);
    public static void EnableForPlayback(Lifetime lifetime);
    [ConditionalAttribute("JET_MODE_ASSERT")]
public static void StartInterruptTimeCheck(bool run);
    public static bool IsInTimeCheckProcess();
    [ConditionalAttribute("JET_MODE_ASSERT")]
public static void FinishInterruptTimeCheck(bool run);
    [ConditionalAttribute("JET_MODE_ASSERT")]
public static void CheckLastInterruptTime();
    public static ActionUpdateOnUIThreadCookie GetActionUpdateCookie();
    [ConditionalAttribute("JET_MODE_ASSERT")]
public static void CheckNotInUIUpdate();
    [ConditionalAttribute("JET_MODE_ASSERT")]
internal static void OnInterruption();
    [ConditionalAttribute("JET_MODE_ASSERT")]
internal static void OnReadLockReleased(bool run);
    [ConditionalAttribute("JET_MODE_ASSERT")]
internal static void ActivateCaptureStacks(bool run);
    [ConditionalAttribute("JET_MODE_ASSERT")]
internal static void OnWriteLockAcquired(bool run, LocalStopwatch stopwatch);
}
public class JetBrains.Util.Concurrency.UnguardedCallbackMerger : object {
    private Lifetime myLifetime;
    private int myActiveExpectations;
    private BehaviorFlags myFlags;
    public ReentrancyGuard ReentrancyGuard;
    [GuardAttribute("-1")]
public bool IsExpectingUnguardedCallback { get; }
    [GuardAttribute("-1")]
public UnguardedCallbackMerger(Lifetime lifetime, ReentrancyGuard guard, BehaviorFlags flags);
    public bool get_IsExpectingUnguardedCallback();
    [GuardAttribute("-2")]
[ObsoleteAttribute("Use overload with lifetime.")]
public void ExecuteOrQueueOrMerge(string name, Action F);
    [GuardAttribute("-2")]
public bool ExecuteOrQueueOrMerge(Lifetime lifetimeQueue, string name, Action F);
    [GuardAttribute("1")]
public void ExpectUnguardedCallback(Action FNested);
}
public class JetBrains.Util.Concurrency.UnixDispatcherImpl : PlatformDispatcherImplBase {
    private static ILogger ourLogger;
    private BlockingPriorityQueue`1<Closure> myPendingInvocationsQueue;
    private static UInt32 FakeGeneration;
    private JetDispatcher myDispatcher;
    public static IJetDispatcherPlatformSpecific PlatformSpecific;
    private static UnixDispatcherImpl();
    public virtual void Init(JetDispatcher dispatcher);
    public virtual DispatcherOperationStatus InvokeAsync(Action action, TaskPriority priority);
    public virtual void Invoke(Action action, TaskPriority priority);
    private void BeginInvokeCore(Closure closure);
}
public interface JetBrains.Util.Concurrency.UpgradableReadWriteLock {
    [NotNullAttribute]
public ISync UpgradableReadLock { get; }
    public abstract virtual ISync get_UpgradableReadLock();
}
[IsReadOnlyAttribute]
public class JetBrains.Util.Concurrency.WaitCountSyncContextCookie : ValueType {
    private WaitCountSyncContext myContext;
    internal WaitCountSyncContextCookie(WaitCountSyncContext context);
    public sealed virtual void Dispose();
}
public class JetBrains.Util.Concurrency.WinDispatcherImpl : PlatformDispatcherImplBase {
    private static ILogger ourLogger;
    private JetDispatcher myJetDispatcher;
    private Dispatcher myWpfDispatcher;
    private Func`2[] myPreTranslates;
    public static IJetDispatcherPlatformSpecific PlatformSpecific;
    private static WinDispatcherImpl();
    public virtual void Init(JetDispatcher dispatcher);
    public virtual DispatcherOperationStatus InvokeAsync(Action action, TaskPriority priority);
    public virtual void Invoke(Action action, TaskPriority priority);
    public virtual void ShutDown();
    private static DispatcherPriority GetNativeMarshallerPriority(TaskPriority taskpriority);
    public void RegisterPreTranslate(Lifetime lifetime, Func`2<MSG, bool> pretranslate);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.Util.ConcurrentUserDataHolder : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ConcurrentDictionary`2<object, object> myDictionary;
    public sealed virtual T GetData(Key`1<T> key);
    public sealed virtual void PutData(Key`1<T> key, T value);
    public sealed virtual T GetOrCreateDataUnderLock(Key`1<T> key, Func`1<T> factory);
    public sealed virtual T GetOrCreateDataUnderLock(Key`1<T> key, TState state, Func`2<TState, T> factory);
    public sealed virtual IEnumerable`1<KeyValuePair`2<object, object>> EnumerateData();
}
public class JetBrains.Util.CountingLogger : LoggerBase {
    private ILogger myLoggerForward;
    private bool myAlwaysEnableErrors;
    private int _nLogException;
    private int _nLogExceptionSilently;
    private int _nLogMessage;
    public int LoggedExceptionsSilent { get; }
    public int LoggedExceptionsLoud { get; }
    public int LoggedExceptionAnyKind { get; }
    public int LoggedMessages { get; }
    public bool IsWithAnyExceptions { get; }
    public bool IsWithLoudExceptions { get; }
    public bool IsWithSilentExceptions { get; }
    public string Category { get; }
    public CountingLogger(ILogger loggerForward, bool alwaysEnableErrors);
    public virtual void Log(LogEvent logEvent);
    public virtual bool IsEnabled(LoggingLevel level);
    public int get_LoggedExceptionsSilent();
    public int get_LoggedExceptionsLoud();
    public int get_LoggedExceptionAnyKind();
    public int get_LoggedMessages();
    public bool get_IsWithAnyExceptions();
    public bool get_IsWithLoudExceptions();
    public bool get_IsWithSilentExceptions();
    public void ResetCounters();
    public virtual string get_Category();
}
[ExtensionAttribute]
public static class JetBrains.Util.CultureUtil : object {
    public static CultureInfo English;
    private static CultureUtil();
    [ExtensionAttribute]
public static IDisposable UseUICulture(CultureInfo cultureInfo);
}
[ExtensionAttribute]
public static class JetBrains.Util.DataFlow.Extension.CollectionValidator : object {
    [ExtensionAttribute]
public static void CreateReadonlyValidator(ICollectionEvents`1<TItem> thіs, Lifetime lifetime, ReadonlyToken token);
    [ExtensionAttribute]
public static void CreateThreadAffinityValidator(ICollectionEvents`1<TItem> thіs, Lifetime lifetime, Thread thread);
    [ExtensionAttribute]
[NotNullAttribute]
public static CollectionEvents`1<TValue> EnsureReadonly(CollectionEvents`1<TValue> thіs, ReadonlyToken token);
    [ExtensionAttribute]
[NotNullAttribute]
public static CollectionEvents`1<TValue> EnsureReadonly(CollectionEvents`1<TValue> thіs, Lifetime lifetime, ReadonlyToken token);
    [ExtensionAttribute]
[NotNullAttribute]
public static ICollectionEvents`1<TValue> EnsureReadonly(ICollectionEvents`1<TValue> thіs, ReadonlyToken token);
    [ExtensionAttribute]
[NotNullAttribute]
public static ICollectionEvents`1<TValue> EnsureReadonly(ICollectionEvents`1<TValue> thіs, Lifetime lifetime, ReadonlyToken token);
    [ExtensionAttribute]
[NotNullAttribute]
public static IListEvents`1<TValue> EnsureReadonly(IListEvents`1<TValue> thіs, ReadonlyToken token);
    [ExtensionAttribute]
[NotNullAttribute]
public static IListEvents`1<TValue> EnsureReadonly(IListEvents`1<TValue> thіs, Lifetime lifetime, ReadonlyToken token);
    [ExtensionAttribute]
[NotNullAttribute]
public static DictionaryEvents`2<TKey, TValue> EnsureReadonly(DictionaryEvents`2<TKey, TValue> thіs, ReadonlyToken token);
    [ExtensionAttribute]
[NotNullAttribute]
public static DictionaryEvents`2<TKey, TValue> EnsureReadonly(DictionaryEvents`2<TKey, TValue> thіs, Lifetime lifetime, ReadonlyToken token);
    [ExtensionAttribute]
[NotNullAttribute]
public static IDictionaryEvents`2<TKey, TValue> EnsureReadonly(IDictionaryEvents`2<TKey, TValue> thіs, ReadonlyToken token);
    [ExtensionAttribute]
[NotNullAttribute]
public static IDictionaryEvents`2<TKey, TValue> EnsureReadonly(IDictionaryEvents`2<TKey, TValue> thіs, Lifetime lifetime, ReadonlyToken token);
    [ExtensionAttribute]
[NotNullAttribute]
public static CollectionEvents`1<TItem> EnsureThisThread(CollectionEvents`1<TItem> thіs);
    [ExtensionAttribute]
[NotNullAttribute]
public static CollectionEvents`1<TItem> EnsureThisThread(CollectionEvents`1<TItem> thіs, Lifetime lifetime);
    [ExtensionAttribute]
[NotNullAttribute]
public static ICollectionEvents`1<TItem> EnsureThisThread(ICollectionEvents`1<TItem> thіs);
    [ExtensionAttribute]
[NotNullAttribute]
public static ICollectionEvents`1<TItem> EnsureThisThread(ICollectionEvents`1<TItem> thіs, Lifetime lifetime);
    [ExtensionAttribute]
[NotNullAttribute]
public static IListEvents`1<TItem> EnsureThisThread(IListEvents`1<TItem> thіs);
    [ExtensionAttribute]
[NotNullAttribute]
public static IListEvents`1<TItem> EnsureThisThread(IListEvents`1<TItem> thіs, Lifetime lifetime);
    [ExtensionAttribute]
[NotNullAttribute]
public static DictionaryEvents`2<TKey, TValue> EnsureThisThread(DictionaryEvents`2<TKey, TValue> thіs);
    [ExtensionAttribute]
[NotNullAttribute]
public static DictionaryEvents`2<TKey, TValue> EnsureThisThread(DictionaryEvents`2<TKey, TValue> thіs, Lifetime lifetime);
    [ExtensionAttribute]
[NotNullAttribute]
public static IDictionaryEvents`2<TKey, TValue> EnsureThisThread(IDictionaryEvents`2<TKey, TValue> thіs);
    [ExtensionAttribute]
[NotNullAttribute]
public static IDictionaryEvents`2<TKey, TValue> EnsureThisThread(IDictionaryEvents`2<TKey, TValue> thіs, Lifetime lifetime);
    [CompilerGeneratedAttribute]
internal static ReadOnlyException <CreateReadonlyValidator>g__ReadonlyFail|0_0(BeforeAddRemoveEventArgs`1<TValue> args, object tokenExpected);
    [CompilerGeneratedAttribute]
internal static ThreadAccessException <CreateThreadAffinityValidator>g__ThreadAffinityFail|1_0(BeforeAddRemoveEventArgs`1<TValue> args, Thread threadExpected);
}
public interface JetBrains.Util.DataFlow.ISignalOptionalFiring`1 {
    public bool IsAnyoneSinking { get; }
    public abstract virtual bool get_IsAnyoneSinking();
}
public class JetBrains.Util.DataFlow.ProjectedProperty`2 : PropertyBoilerplate`1<TValue> {
    [CanBeNullAttribute]
private LifetimeDefinition myDefSinkOrig;
    [CanBeNullAttribute]
private Func`2<TValue, TOrig> myFBack;
    [NotNullAttribute]
private Func`2<TOrig, TValue> myFProject;
    private bool myIsLastSeensValid;
    private TOrig myLastSeenOrig;
    private TValue myLastSeenProjected;
    private LockObject myLock;
    [NotNullAttribute]
private IProperty`1<TOrig> myOriginal;
    [NotNullAttribute]
private Action`1[] mySinks;
    public ProjectedProperty`2(IProperty`1<TOrig> original, string operation, Func`2<TOrig, TValue> FProject, Func`2<TValue, TOrig> FBack);
    protected virtual void AdviseCore(Lifetime lifetime, Action`1<PropertyChangedEventArgs`1<TValue>> handler);
    protected virtual TValue GetValueCore(object cookie);
    private void NotifySinks(TValue was, TValue value, object cookie);
    protected virtual bool SetValueCore(TValue value, object cookie);
}
public abstract class JetBrains.Util.DataFlow.PropertyBoilerplate`1 : object {
    private PropertyId`1<TValue> myId;
    private bool myIsNullValueAllowed;
    private Type JetBrains.DataFlow.IUntypedSignal.ArgumentType { get; }
    private object JetBrains.DataFlow.IUntypedProperty.AsTyped { get; }
    private IUntypedSignal JetBrains.DataFlow.ISignal<JetBrains.DataFlow.PropertyChangedEventArgs<TValue>>.AsUntyped { get; }
    private IUntypedProperty JetBrains.DataFlow.IHaveUntypedProperty.AsUntyped { get; }
    private ISignal`1<BeforePropertyChangedEventArgs`1<TValue>> JetBrains.DataFlow.IProperty<TValue>.BeforeChange { get; }
    private IUntypedSignal JetBrains.DataFlow.IUntypedProperty.BeforeChange { get; }
    private IUntypedSignal JetBrains.DataFlow.IUntypedProperty.Change { get; }
    private ISignal`1<PropertyChangedEventArgs`1<TValue>> JetBrains.DataFlow.IProperty<TValue>.Change { get; }
    private PropertyId`1<TValue> JetBrains.DataFlow.IProperty<TValue>.Id { get; }
    private PropertyId`1<PropertyChangedEventArgs`1<TValue>> JetBrains.DataFlow.ISignal<JetBrains.DataFlow.PropertyChangedEventArgs<TValue>>.Id { get; }
    private PropertyId JetBrains.DataFlow.IUntypedProperty.Id { get; }
    private PropertyId JetBrains.DataFlow.IUntypedSignal.Id { get; }
    private bool JetBrains.DataFlow.IProperty<TValue>.IsNullValueAllowed { get; }
    private bool JetBrains.DataFlow.IUntypedProperty.IsNullValueAllowed { get; }
    private IProperty`1<PropertyChangedEventArgs`1<TValue>> JetBrains.DataFlow.ISignal<JetBrains.DataFlow.PropertyChangedEventArgs<TValue>>.Property { get; }
    private IUntypedProperty JetBrains.DataFlow.IUntypedSignal.Property { get; }
    private Type JetBrains.DataFlow.IUntypedProperty.PropertyType { get; }
    private TValue JetBrains.DataFlow.IProperty<TValue>.Value { get; private set; }
    public TValue Value { get; public set; }
    protected PropertyBoilerplate`1(PropertyId`1<TValue> id, bool isNullValueAllowed);
    private sealed virtual override void JetBrains.DataFlow.ISignal<JetBrains.DataFlow.PropertyChangedEventArgs<TValue>>.Advise(Lifetime lifetime, Action`1<PropertyChangedEventArgs`1<TValue>> handler);
    private sealed virtual override void JetBrains.DataFlow.IUntypedSignal.Advise(Lifetime lifetime, Action`1<object> handler);
    protected abstract virtual void AdviseCore(Lifetime lifetime, Action`1<PropertyChangedEventArgs`1<TValue>> handler);
    private sealed virtual override Type JetBrains.DataFlow.IUntypedSignal.get_ArgumentType();
    private sealed virtual override object JetBrains.DataFlow.IUntypedProperty.get_AsTyped();
    private sealed virtual override IUntypedSignal JetBrains.DataFlow.ISignal<JetBrains.DataFlow.PropertyChangedEventArgs<TValue>>.get_AsUntyped();
    private sealed virtual override IUntypedProperty JetBrains.DataFlow.IHaveUntypedProperty.get_AsUntyped();
    private sealed virtual override ISignal`1<BeforePropertyChangedEventArgs`1<TValue>> JetBrains.DataFlow.IProperty<TValue>.get_BeforeChange();
    private sealed virtual override IUntypedSignal JetBrains.DataFlow.IUntypedProperty.get_BeforeChange();
    private sealed virtual override IUntypedSignal JetBrains.DataFlow.IUntypedProperty.get_Change();
    private sealed virtual override ISignal`1<PropertyChangedEventArgs`1<TValue>> JetBrains.DataFlow.IProperty<TValue>.get_Change();
    private sealed virtual override void System.IDisposable.Dispose();
    private sealed virtual override void JetBrains.DataFlow.IUntypedProperty.add_Disposed(EventHandler value);
    private sealed virtual override void JetBrains.DataFlow.IUntypedProperty.remove_Disposed(EventHandler value);
    private sealed virtual override void JetBrains.DataFlow.ISignal<JetBrains.DataFlow.PropertyChangedEventArgs<TValue>>.Fire(PropertyChangedEventArgs`1<TValue> value);
    private sealed virtual override void JetBrains.DataFlow.ISignal<JetBrains.DataFlow.PropertyChangedEventArgs<TValue>>.Fire(PropertyChangedEventArgs`1<TValue> value, object cookie);
    private sealed virtual override void JetBrains.DataFlow.IUntypedSignal.Fire(object value, object cookie);
    private sealed virtual override TValue JetBrains.DataFlow.IProperty<TValue>.GetValue(object cookie);
    private sealed virtual override TValue JetBrains.DataFlow.IProperty<TValue>.GetValue();
    private sealed virtual override object JetBrains.DataFlow.IUntypedProperty.GetValue(object cookie);
    protected abstract virtual TValue GetValueCore(object cookie);
    private sealed virtual override PropertyId`1<TValue> JetBrains.DataFlow.IProperty<TValue>.get_Id();
    private sealed virtual override PropertyId`1<PropertyChangedEventArgs`1<TValue>> JetBrains.DataFlow.ISignal<JetBrains.DataFlow.PropertyChangedEventArgs<TValue>>.get_Id();
    private sealed virtual override PropertyId JetBrains.DataFlow.IUntypedProperty.get_Id();
    private sealed virtual override PropertyId JetBrains.DataFlow.IUntypedSignal.get_Id();
    private sealed virtual override bool JetBrains.DataFlow.IProperty<TValue>.get_IsNullValueAllowed();
    private sealed virtual override bool JetBrains.DataFlow.IUntypedProperty.get_IsNullValueAllowed();
    private sealed virtual override IProperty`1<PropertyChangedEventArgs`1<TValue>> JetBrains.DataFlow.ISignal<JetBrains.DataFlow.PropertyChangedEventArgs<TValue>>.get_Property();
    private sealed virtual override IUntypedProperty JetBrains.DataFlow.IUntypedSignal.get_Property();
    private sealed virtual override Type JetBrains.DataFlow.IUntypedProperty.get_PropertyType();
    private sealed virtual override bool JetBrains.DataFlow.IProperty<TValue>.SetValue(TValue value, object cookie);
    private sealed virtual override bool JetBrains.DataFlow.IProperty<TValue>.SetValue(TValue value);
    private sealed virtual override bool JetBrains.DataFlow.IUntypedProperty.SetValue(object value, object cookie);
    protected abstract virtual bool SetValueCore(TValue value, object cookie);
    private sealed virtual override TValue JetBrains.DataFlow.IProperty<TValue>.get_Value();
    private sealed virtual override void JetBrains.DataFlow.IProperty<TValue>.set_Value(TValue value);
    public TValue get_Value();
    public void set_Value(TValue value);
}
public class JetBrains.Util.DataFlow.Reasons`1 : object {
    [CanBeNullAttribute]
private ILogger myLogger;
    private bool myUniqueSuppressors;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private IProperty`1<bool> <AreEmpty>k__BackingField;
    [CompilerGeneratedAttribute]
private IProperty`1<T> <FirstReason>k__BackingField;
    private ICollection`1<T> myReasons;
    private Tuple`1 modreq(System.Runtime.CompilerServices.IsVolatile) myFirstReasonToFire;
    private Tuple`1 modreq(System.Runtime.CompilerServices.IsVolatile) myAreEmptyToFire;
    public string Name { get; }
    public IProperty`1<bool> AreEmpty { get; }
    [ItemCanBeNullAttribute]
public IProperty`1<T> FirstReason { get; }
    [ObsoleteAttribute("Use the ctor without Lifetime parameter")]
[UsedImplicitlyAttribute]
public Reasons`1(Lifetime lifetime, string name, ILogger logger, bool uniqueSuppressors);
    public Reasons`1(string name, ILogger logger, bool uniqueSuppressors);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public IProperty`1<bool> get_AreEmpty();
    [CompilerGeneratedAttribute]
public IProperty`1<T> get_FirstReason();
    private void UpdateIsEmpty();
    public void AddReason(Lifetime lifetime, T reason);
    [NotNullAttribute]
public IList`1<T> GetAllReasons();
}
public class JetBrains.Util.DataFlow.SignalOptionalFiring`1 : Signal`1<TValue> {
    private int mySinksCount;
    private bool JetBrains.Util.DataFlow.ISignalOptionalFiring<TValue>.IsAnyoneSinking { get; }
    public SignalOptionalFiring`1(string id);
    public SignalOptionalFiring`1(Lifetime lifetime, string id);
    protected virtual void OnAfterAdvise(Action`1<TValue> handler);
    protected virtual void OnAfterUnadvise(Action`1<TValue> handler);
    private sealed virtual override bool JetBrains.Util.DataFlow.ISignalOptionalFiring<TValue>.get_IsAnyoneSinking();
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Util.DataStructures.ArrayPart`1 : ValueType {
    private int myVersion;
    [CompilerGeneratedAttribute]
private int <Count>k__BackingField;
    [CompilerGeneratedAttribute]
private IArray`1<T> <UnderlyingArray>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StartIndex>k__BackingField;
    public int Count { get; }
    public T Item { get; public set; }
    internal IArray`1<T> UnderlyingArray { get; }
    internal int StartIndex { get; }
    public ArrayPart`1(IArray`1<T> array, int startIndex, int length);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual int get_Count();
    public Enumerator<T> GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
internal IArray`1<T> get_UnderlyingArray();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
internal int get_StartIndex();
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Util.dataStructures.BidirectionalMapOnDictionary`2 : object {
    private Dictionary`2<TLeft, TRight> myLeftToRightMap;
    private Dictionary`2<TRight, TLeft> myRightToLeftMap;
    public int Count { get; }
    public ICollection`1<TLeft> LeftKeys { get; }
    public IDictionary`2<TLeft, TRight> LeftToRight { get; }
    public ICollection`1<TRight> RightKeys { get; }
    public IDictionary`2<TRight, TLeft> RightToLeft { get; }
    public TRight Item { get; }
    public TLeft Item { get; }
    public BidirectionalMapOnDictionary`2(int capacity);
    public BidirectionalMapOnDictionary`2(int capacity, IEqualityComparer`1<TLeft> leftComparer, IEqualityComparer`1<TRight> rightComparer);
    public BidirectionalMapOnDictionary`2(IEqualityComparer`1<TLeft> leftComparer, IEqualityComparer`1<TRight> rightComparer);
    public int get_Count();
    public ICollection`1<TLeft> get_LeftKeys();
    public IDictionary`2<TLeft, TRight> get_LeftToRight();
    public ICollection`1<TRight> get_RightKeys();
    public IDictionary`2<TRight, TLeft> get_RightToLeft();
    public TRight get_Item(TLeft left);
    public TLeft get_Item(TRight right);
    public void Add(TLeft left, TRight right);
    public void Clear();
    public bool ContainsLeft(TLeft left);
    public bool ContainsRight(TRight right);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public TLeft GetLeftByRight(TRight right);
    public TRight GetRightByLeft(TLeft left);
    public void RemoveLeft(TLeft left);
    public void RemoveMapping(TLeft left, TRight right);
    public void RemoveRight(TRight right);
    public bool SetMapping(TLeft left, TRight right, bool bIgnoreConflicts);
    public bool TryGetLeftByRight(TRight right, TLeft& left);
    public bool TryGetRightByLeft(TLeft left, TRight& right);
    public TLeft GetOrCreateLeftByRight(TRight right, Func`2<TRight, TLeft> factory);
    public TRight GetOrCreateRightByLeft(TLeft left, Func`2<TLeft, TRight> factory);
    private static ArgumentException CreateDuplicateLeftKeysException(TLeft left, TRight right, TRight oldRight);
    private static ArgumentException CreateDuplicateRightKeysException(TLeft left, TRight right, TLeft oldLeft);
    public sealed virtual IEnumerator`1<KeyValuePair`2<TLeft, TRight>> GetEnumerator();
}
public class JetBrains.Util.dataStructures.ByteBuffer : ValueType {
    public Byte* Data;
    public UInt32 Length;
    public ByteBuffer(Byte* data, UInt32 length);
    public virtual string ToString();
}
[ExtensionAttribute]
public static class JetBrains.Util.dataStructures.ByteBufferEx : object {
    [ExtensionAttribute]
[NotNullAttribute]
public static Byte[] ToArray(ByteBuffer buffer);
    [ExtensionAttribute]
[NotNullAttribute]
public static UnmanagedMemoryStream ToStream(ByteBuffer buffer);
}
public class JetBrains.Util.DataStructures.Caches.LifetimeAwareCache`2 : object {
    private SpinWaitLock mySpinWailLock;
    [NotNullAttribute]
private Lifetime myCacheLifetime;
    [NotNullAttribute]
protected ViewableMap`2<TKey, ItemDescriptor<TKey, TValue>> StoredItems;
    public LifetimeAwareCache`2(Lifetime cacheLifetime);
    [NotNullAttribute]
public TValue GetOrCreate(Lifetime usageLifetime, TKey key, ItemCreationFunction<TKey, TValue> creationFunction);
    protected virtual void OnItemCreated(Lifetime itemLifetime, TKey key, TValue item);
    private void RemoveItem(TKey key);
    public void View(Lifetime lifetime, Action`3<Lifetime, TKey, TValue> handler);
    private sealed virtual override void JetBrains.Collections.Viewable.ISource<JetBrains.Collections.Viewable.MapEvent<TKey,TValue>>.Advise(Lifetime lifetime, Action`1<MapEvent`2<TKey, TValue>> handler);
}
public class JetBrains.Util.DataStructures.Caches.ProlongableLifetime : object {
    [NotNullAttribute]
private LifetimeDefinition myUnionLifetimeDefinition;
    private int myLifetimesCounter;
    private SpinWaitLock mySpinWaitLock;
    public Lifetime TotalLifetime { get; }
    public ProlongableLifetime(Lifetime sourceLifetime);
    public ProlongableLifetime(Lifetime sourceLifetime, Lifetime[] childLifetimes);
    public Lifetime get_TotalLifetime();
    public IDisposable CreateProlongationCookie();
    public bool Prolongate(Lifetime lifetime);
    private void OnChildLifetimeTerminated();
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Util.DataStructures.ChunkArray`1 : object {
    public static int MaxAntiLohSizeInBytes;
    private static int MaxObjectSize;
    private int myIndexInChunkMask;
    private int myChunkLengthLog2;
    private int myLength;
    private T[][] myArray;
    private ChunkArray`1<T[]> myChunkArray;
    public bool IsReadOnly { get; }
    public int Count { get; }
    public int Length { get; }
    public T Item { get; public set; }
    private int System.Collections.Generic.ICollection<T>.Count { get; }
    private ChunkArray`1(ChunkArray`1<T> source, int newLength, ChunkCollectionMode mode);
    public ChunkArray`1(int length, ChunkCollectionMode mode);
    public ChunkArray`1(ChunkArray`1<T> source);
    public ChunkArray`1(IReadOnlyCollection`1<T> source);
    public ChunkArray`1(IEnumerable`1<T> source);
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual int get_Count();
    public int get_Length();
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    public T& GetByRef(int index);
    public void Fill(T item);
    public sealed virtual int IndexOf(T item);
    public sealed virtual bool Contains(T item);
    public sealed virtual void Clear();
    public static void Resize(ChunkArray`1& source, int newLength, ChunkCollectionMode mode);
    private static int GetChunkLength();
    public Enumerator<T> GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private static bool Contains(T[] chunk, T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual void Add(T item);
    public sealed virtual bool Remove(T item);
    public sealed virtual void Insert(int index, T item);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override int System.Collections.Generic.ICollection<T>.get_Count();
}
public enum JetBrains.Util.DataStructures.ChunkCollectionMode : Enum {
    public int value__;
    public static ChunkCollectionMode AntiLoh;
    public static ChunkCollectionMode Auto;
}
[ExtensionAttribute]
public static class JetBrains.Util.DataStructures.ChunkCollectionsExtension : object {
    [ExtensionAttribute]
public static ChunkList`1<T> ToChunkList(IEnumerable`1<T> enumerable, bool forceCopy);
    [ExtensionAttribute]
public static ChunkArray`1<T> ToChunkArray(IEnumerable`1<T> enumerable, bool forceCopy);
}
public class JetBrains.Util.dataStructures.ChunkedMemoryStream : Stream {
    public static int DefaultChunkSize;
    private ChunkList`1<Byte[]> myBuffers;
    private int myCachedCurrentBuffer_Index;
    private Byte[] myCachedCurrentBuffer_Value;
    private int myCurrentBufferIndex;
    private int myCurrentBufferOffset;
    private static long myCurrentGuid;
    private ulong myGuid;
    private long myLengthIncludingStartOffset;
    private long myPositionIncludingStartOffset;
    private long myStartOffset;
    private StateFlags myStateFlags;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public ulong Guid { get; }
    public long Length { get; }
    public long Position { get; public set; }
    private bool JetBrains.Util.Collections.IFreezable.IsFrozen { get; }
    private ChunkedMemoryStream(ChunkList`1<Byte[]> buffers, long offset, long count, StateFlags stateflags, ulong qwGuid);
    public ChunkedMemoryStream(Stream streamToCopy);
    private static ChunkedMemoryStream();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public ulong get_Guid();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    [NotNullAttribute]
public ImmutableByteStream AsImmutable();
    public static ChunkedMemoryStream CreateOnUserBuffers(IEnumerable`1<Byte[]> buffers, int offset, int count);
    public static ChunkedMemoryStream CreateOnUserBuffers(Byte[][] buffers);
    public static ChunkedMemoryStream CreateOnUserBuffersGuaranteedImmutable(IEnumerable`1<Byte[]> buffers, int offset, int count);
    public static ChunkedMemoryStream CreateOnUserBuffersGuaranteedImmutable(Byte[][] buffers);
    public virtual void Flush();
    [NotNullAttribute]
public ChunkedMemoryStream Freeze();
    public IEnumerable`1<Byte[]> GetBuffers();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    [NotNullAttribute]
public ChunkedMemoryStream ShallowClone();
    [NotNullAttribute]
public Byte[][] ToArray();
    public virtual string ToString();
    public void TrimExcess();
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte value);
    private void AllocateBuffersStrategy(long lCurrentCapacity, long lDesiredCapacity);
    private void AssertWritable();
    private sealed virtual override void JetBrains.Util.Collections.IFreezable.Freeze();
    private void GetBufferAndOffsetOfPosition(long lPositionIncludingStartOffset, Int32& nBufferIndex, Int32& nCurrentBufferOffset);
    private sealed virtual override bool JetBrains.Util.Collections.IFreezable.get_IsFrozen();
    private long SeekCore(long offset, SeekOrigin origin);
    private void SetLengthCore(long value, bool isForWriting);
    private void SetLengthCore_Wipe(int nOldLastUsedBuffer, int nOldCurrentBufferOffset, int nNewLastUsedBuffer, int nNewCurrentBufferOffset);
    private void TruncateBuffersStrategy(int nLastUsedBuffer);
    private long TryGetBufferAndOffsetOfPosition(long lPositionIncludingStartOffset, Int32& nBufferIndex, Int32& nCurrentBufferOffset);
    private void Write_SlowTrack(Byte[] buffer, int offset, int count);
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Util.DataStructures.ChunkList`1 : object {
    private static int MaxChunkSizeInBytes;
    private static int DefaultCapacity;
    public static int OneChunk;
    private int myChunkSize;
    private int myIndexInChunkMask;
    private int myChunkLengthLog2;
    private bool myAllowDangerousOperations;
    private int myCapacity;
    private int myEffectiveCapacity;
    private T[][] myChunks;
    private int myActiveChunkNumber;
    private int myActiveChunkPtr;
    private T[] myActiveChunk;
    [CompilerGeneratedAttribute]
private int <Count>k__BackingField;
    public bool IsReadOnly { get; }
    public int Count { get; private set; }
    public int Capacity { get; public set; }
    public T Item { get; public set; }
    public object SyncRoot { get; }
    public bool IsSynchronized { get; }
    public bool IsFixedSize { get; }
    private object System.Collections.IList.Item { get; private set; }
    public ChunkList`1(int capacity, int maxChunkSizeInBytes);
    public ChunkList`1(bool allowDangerousOperations, int capacity, int maxChunkSizeInBytes);
    public ChunkList`1(ChunkList`1<T> source);
    public ChunkList`1(IReadOnlyCollection`1<T> collection, int capacity);
    public ChunkList`1(IEnumerable`1<T> enumerable, int capacity);
    public sealed virtual bool get_IsReadOnly();
    [CompilerGeneratedAttribute]
public sealed virtual int get_Count();
    [CompilerGeneratedAttribute]
private void set_Count(int value);
    public int get_Capacity();
    public void set_Capacity(int value);
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    public T& GetByRef(int index);
    public int Add(T item);
    public sealed virtual int IndexOf(T item);
    public sealed virtual bool Contains(T item);
    public sealed virtual void Clear();
    public void ClearRange(int index, int count);
    public void AddRange(IEnumerable`1<T> collection);
    public void TrimExcess(bool strict);
    public void Extend(int count);
    public void Shrink(int count);
    private void EnsureCapacity(int count);
    private void EnsureChunksArrayCapacity(int itemsCount);
    private void SetChunksArrayCapacityUnconditional(int capacity, int chunksCount);
    private void SetCapacity(int capacity);
    private static bool Contains(T[] chunk, T item, int length);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public void CopyTo(int index, T[] array, int arrayIndex, int count);
    public sealed virtual bool Remove(T item);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual void Insert(int index, T item);
    private int CalculateChunksCount(int itemsCount);
    public Enumerator<T> GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    public sealed virtual void Insert(int index, object value);
    public sealed virtual void CopyTo(Array array, int index);
    public sealed virtual object get_SyncRoot();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual void Remove(object value);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override int System.Collections.IList.Add(object value);
    public sealed virtual bool Contains(object value);
    public sealed virtual int IndexOf(object value);
}
public class JetBrains.Util.DataStructures.CollectionReadOnlyException : NotSupportedException {
    public CollectionReadOnlyException(SerializationInfo info, StreamingContext context);
    public CollectionReadOnlyException(string message, Exception innerException);
    public CollectionReadOnlyException(string message);
}
public class JetBrains.Util.DataStructures.Collections.ChunkStack`1 : object {
    private static int MaxChunkSizeInBytes;
    private static int DefaultCapacity;
    private ChunkList`1<T> myChunkList;
    [CompilerGeneratedAttribute]
private int <Count>k__BackingField;
    public int Count { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public ChunkStack`1(int minCapacity);
    public ChunkStack`1(int maxChunkSizeInBytes, int minCapacity);
    public ChunkStack`1(bool allowDangerousOperations, int maxChunkSizeInBytes, int minCapacity);
    [CompilerGeneratedAttribute]
public sealed virtual int get_Count();
    [CompilerGeneratedAttribute]
private void set_Count(int value);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public void Clear();
    public bool Contains(T item);
    public void CopyTo(T[] array, int arrayIndex);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int arrayIndex);
    public Enumerator<T> GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public void TrimExcess(bool strict);
    public T Peek();
    public T Pop();
    public void Push(T item);
    public T[] ToArray();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class JetBrains.Util.DataStructures.Collections.FixedList : object {
    [PureAttribute]
public static IReadOnlyList`1<T> Of(T item);
    [PureAttribute]
public static IReadOnlyList`1<T> Of(T first, T second);
    [PureAttribute]
public static IReadOnlyList`1<T> Of(T first, T second, T third);
    [PureAttribute]
public static IReadOnlyList`1<T> Of(T first, T second, T third, T fourth);
    [PureAttribute]
public static IReadOnlyList`1<T> OfNotNull(T first);
    [PureAttribute]
public static IReadOnlyList`1<T> OfNotNull(T first, T second);
    [NullableContextAttribute("2")]
[PureAttribute]
public static IReadOnlyList`1<T> OfNotNull(T first, T second, T third);
    [NullableContextAttribute("2")]
[PureAttribute]
public static IReadOnlyList`1<T> OfNotNull(T first, T second, T third, T fourth);
    [PureAttribute]
public static IList`1<T> ListOf(T item);
    [PureAttribute]
public static IList`1<T> ListOf(T first, T second);
    [PureAttribute]
public static IList`1<T> ListOf(T first, T second, T third);
    [PureAttribute]
public static IList`1<T> ListOf(T first, T second, T third, T fourth);
    [PureAttribute]
public static IReadOnlyList`1<T> FromArray(T[] array, int countUsed);
    [PureAttribute]
public static IReadOnlyList`1<T> Concat(IReadOnlyList`1<T> left, IReadOnlyList`1<T> right);
    [PureAttribute]
public static EnumerablePair`1<T> Enumerate(T& first, T& second);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[PureAttribute]
public static EnumerablePair`1<T> GetEnumerator(ValueTuple`2<T, T> tuple);
    [PureAttribute]
public static EnumerableTriple`1<T> Enumerate(T& first, T& second, T& third);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[PureAttribute]
public static EnumerableTriple`1<T> GetEnumerator(ValueTuple`3<T, T, T> tuple);
}
[IsReadOnlyAttribute]
public class JetBrains.Util.DataStructures.Collections.HashSetReader`1 : ValueType {
    [NotNullAttribute]
private static HashSet`1<T> ourEmptyHashSet;
    [CanBeNullAttribute]
private HashSet`1<T> myHashSet;
    public static HashSetReader`1<T> Empty;
    public int Count { get; }
    public HashSetReader`1(HashSet`1<T> hashSet);
    private static HashSetReader`1();
    public int get_Count();
    public bool Contains(T t);
    public bool IsEmpty();
    public T First();
    public Enumerator<T> GetEnumerator();
    [NotNullAttribute]
public IEnumerable`1<T> AsEnumerable();
    [NotNullAttribute]
public List`1<T> ToList();
}
public interface JetBrains.Util.DataStructures.Collections.ICollectionSizeInfo {
    public bool IsEmpty { get; }
    public abstract virtual bool get_IsEmpty();
}
public interface JetBrains.Util.DataStructures.Collections.IJetReadonlyList`1 {
    public abstract virtual JetReadonlyListEnumerator`1<T> GetEnumerator();
}
[ExtensionAttribute]
public static class JetBrains.Util.DataStructures.Collections.JetImmutableArrayBuilder : object {
    [ExtensionAttribute]
[NotNullAttribute]
public static JetImmutableArrayBuilder`1<T> CreateNewReusingBuilder(ImmutableArray`1<T> array, IEqualityComparer`1<T> comparer);
    [NotNullAttribute]
public static JetImmutableArrayBuilder`1<T> FromArray(ImmutableArray`1<T> array, IEqualityComparer`1<T> comparer);
    [NotNullAttribute]
public static JetImmutableArrayBuilder`1<T> FromCapacity(int capacity, IEqualityComparer`1<T> comparer);
    public static JetImmutableArrayBuilder`1<T> New(IEqualityComparer`1<T> comparer);
}
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("Count = {Count}")]
public class JetBrains.Util.DataStructures.Collections.JetImmutableArrayBuilder`1 : object {
    private int myCapacityForNewBuilder;
    private IEqualityComparer`1<T> myEqualityComparer;
    [CanBeNullAttribute]
private Builder<T> myNewBuilder;
    private ImmutableArray`1<T> myOriginalArray;
    private int myPositionInOriginalArray;
    public int Capacity { get; public set; }
    public int Count { get; public set; }
    public T Item { get; public set; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    internal JetImmutableArrayBuilder`1(ImmutableArray`1<T> existing, IEqualityComparer`1<T> comparer, Nullable`1<int> capacityForNewBuilder);
    public int get_Capacity();
    public void set_Capacity(int value);
    public sealed virtual int get_Count();
    public void set_Count(int value);
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    public sealed virtual void Add(T item);
    public void AddRange(IEnumerable`1<T> items);
    public void AddRange(T[] items);
    public void AddRange(TDerived[] items);
    public void AddRange(T[] items, int length);
    public void AddRange(ImmutableArray`1<T> items);
    public void AddRange(ImmutableArray`1<T> items, int length);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int index);
    public T First();
    public T FirstOrDefault();
    public IEnumerator`1<T> GetEnumerator();
    public sealed virtual int IndexOf(T item);
    public int IndexOf(T item, int startIndex);
    public int IndexOf(T item, int startIndex, int count);
    public int IndexOf(T item, int startIndex, int count, IEqualityComparer`1<T> equalityComparer);
    public sealed virtual void Insert(int index, T item);
    public T& modreq(System.Runtime.InteropServices.InAttribute) ItemRef(int index);
    public T Last();
    public int LastIndexOf(T item);
    public int LastIndexOf(T item, int startIndex);
    public int LastIndexOf(T item, int startIndex, int count);
    public int LastIndexOf(T item, int startIndex, int count, IEqualityComparer`1<T> equalityComparer);
    public T LastOrDefault();
    public ImmutableArray`1<T> MoveOrCopyToImmutable();
    public sealed virtual bool Remove(T element);
    public sealed virtual void RemoveAt(int index);
    public void Reverse();
    public JetImmutableArrayBuilder`1<T> Sort();
    public JetImmutableArrayBuilder`1<T> Sort(Comparison`1<T> comparison);
    public JetImmutableArrayBuilder`1<T> Sort(IComparer`1<T> comparer);
    public T[] ToArray();
    [NotNullAttribute]
public JetImmutableArrayBuilder`1<T> WithCapacityHint(int capacityForNewBuilder);
    [NotNullAttribute]
public JetImmutableArrayBuilder`1<T> WithComparer(IEqualityComparer`1<T> comparer);
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    [NotNullAttribute]
private Builder<T> LazyCreateBuilder(Nullable`1<int> capacityhint);
}
public class JetBrains.Util.DataStructures.Collections.JetReadonlyListEnumerator`1 : ValueType {
    private IJetReadonlyList`1<T> myList;
    private int myIndex;
    public T Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    public JetReadonlyListEnumerator`1(IJetReadonlyList`1<T> list);
    public sealed virtual T get_Current();
    public sealed virtual bool MoveNext();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual void Dispose();
    public sealed virtual void Reset();
}
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("Count = {Count}")]
[DebuggerTypeProxyAttribute("JetBrains.Util.DataStructures.Collections.ListFromArrayAndCountDebugView`1")]
public class JetBrains.Util.DataStructures.Collections.ListFromArrayAndCount`1 : object {
    [NotNullAttribute]
private T[] myArray;
    private int myCount;
    private int myIterator;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public T Item { get; public set; }
    public T Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    public ListFromArrayAndCount`1(T[] array, int count);
    private ListFromArrayAndCount`1(T[] array, int count, int iterator);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual int IndexOf(T item);
    public sealed virtual bool Contains(T item);
    public sealed virtual void Add(T item);
    public sealed virtual void Insert(int index, T item);
    public sealed virtual bool Remove(T item);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual void Clear();
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    private static void ThrowOutOfRange();
    [NotNullAttribute]
[PureAttribute]
public T[] ToArray();
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Dispose();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
    public sealed virtual T get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
}
internal class JetBrains.Util.DataStructures.Collections.ListFromArrayAndCountDebugView`1 : object {
    [CompilerGeneratedAttribute]
private T[] <Items>k__BackingField;
    [NotNullAttribute]
[DebuggerBrowsableAttribute("3")]
public T[] Items { get; }
    public ListFromArrayAndCountDebugView`1(ListFromArrayAndCount`1<T> result);
    [CompilerGeneratedAttribute]
public T[] get_Items();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[CompilerFeatureRequiredAttribute("RefStructs")]
[IsReadOnlyAttribute]
[PublicAPIAttribute]
public class JetBrains.Util.DataStructures.Collections.PooledArray`1 : ValueType {
    public T[] Array;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ConcurrentDictionary`2<int, ArrayPool<T>> ourGlobalPool;
    private PooledArray`1(T[] array);
    private static PooledArray`1();
    [MustUseReturnValueAttribute]
public static PooledArray`1<T> GetInstance(int length);
    public void Dispose();
    [MustUseReturnValueAttribute]
public static PooledArray`1<T> From(T item);
    [MustUseReturnValueAttribute]
public static PooledArray`1<T> From(T first, T second);
    [MustUseReturnValueAttribute]
public static PooledArray`1<T> From(T first, T second, T third);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class JetBrains.Util.DataStructures.Collections.PooledDictionary`2 : Dictionary`2<TKey, TValue> {
    private ObjectPool`1<PooledDictionary`2<TKey, TValue>> myPool;
    private static ObjectPool`1<PooledDictionary`2<TKey, TValue>> ourGlobalPool;
    private PooledDictionary`2(ObjectPool`1<PooledDictionary`2<TKey, TValue>> pool, IEqualityComparer`1<TKey> equalityComparer);
    private static PooledDictionary`2();
    [PureAttribute]
public static PooledDictionary`2<TKey, TValue> GetInstance();
    public sealed virtual void Dispose();
    [PureAttribute]
public static ObjectPool`1<PooledDictionary`2<TKey, TValue>> CreatePool(IEqualityComparer`1<TKey> equalityComparer);
    public static void PooledIntern(Dictionary`2<TKey, TValue> dictionary, Func`2<TKey, TKey> keyInternFunc, Func`2<TValue, TValue> valueInternFunc);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class JetBrains.Util.DataStructures.Collections.PooledHashSet`1 : HashSet`1<T> {
    private ObjectPool`1<PooledHashSet`1<T>> myPool;
    private static ObjectPool`1<PooledHashSet`1<T>> ourGlobalPool;
    [NullableAttribute("2")]
public T SingleItem { get; }
    private PooledHashSet`1(ObjectPool`1<PooledHashSet`1<T>> pool, IEqualityComparer`1<T> equalityComparer);
    private static PooledHashSet`1();
    [PureAttribute]
public static PooledHashSet`1<T> GetInstance();
    [PureAttribute]
public static PooledHashSet`1<T> GetInstance(IEnumerable`1<T> items);
    [NullableContextAttribute("2")]
public T get_SingleItem();
    public void AddRange(IEnumerable`1<T> enumerable);
    [PureAttribute]
public IReadOnlyList`1<T> ToIReadOnlyList();
    public sealed virtual void Dispose();
    [PureAttribute]
public static ObjectPool`1<PooledHashSet`1<T>> CreatePool(IEqualityComparer`1<T> equalityComparer);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class JetBrains.Util.DataStructures.Collections.PooledList`1 : List`1<T> {
    private ObjectPool`1<PooledList`1<T>> myPool;
    private static ObjectPool`1<PooledList`1<T>> ourGlobalPool;
    private PooledList`1(ObjectPool`1<PooledList`1<T>> pool);
    private static PooledList`1();
    [PureAttribute]
public static PooledList`1<T> GetInstance();
    [PureAttribute]
public T[] ToArray();
    public sealed virtual void Dispose();
    [PureAttribute]
public static ObjectPool`1<PooledList`1<T>> CreatePool();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class JetBrains.Util.DataStructures.Collections.PooledQueue`1 : Queue`1<T> {
    private ObjectPool`1<PooledQueue`1<T>> myPool;
    private static ObjectPool`1<PooledQueue`1<T>> ourGlobalPool;
    private PooledQueue`1(ObjectPool`1<PooledQueue`1<T>> pool);
    private static PooledQueue`1();
    [PureAttribute]
public static PooledQueue`1<T> GetInstance();
    [PureAttribute]
public T[] ToArray();
    public sealed virtual void Dispose();
    [PureAttribute]
public static ObjectPool`1<PooledQueue`1<T>> CreatePool();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class JetBrains.Util.DataStructures.Collections.PooledStack`1 : Stack`1<T> {
    private ObjectPool`1<PooledStack`1<T>> myPool;
    private static ObjectPool`1<PooledStack`1<T>> ourGlobalPool;
    private PooledStack`1(ObjectPool`1<PooledStack`1<T>> pool);
    private static PooledStack`1();
    [PureAttribute]
public static PooledStack`1<T> GetInstance();
    [PureAttribute]
public T[] ToArray();
    public sealed virtual void Dispose();
    [PureAttribute]
public static ObjectPool`1<PooledStack`1<T>> CreatePool();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[CompilerFeatureRequiredAttribute("RefStructs")]
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
[PublicAPIAttribute]
public class JetBrains.Util.DataStructures.Collections.PooledStringBuilder : ValueType {
    [CompilerGeneratedAttribute]
private StringBuilder <Builder>k__BackingField;
    private static ObjectPool`1<StringBuilder> ourGlobalPool;
    public StringBuilder Builder { get; }
    public char Item { get; }
    public int Length { get; }
    private PooledStringBuilder(StringBuilder builder);
    private static PooledStringBuilder();
    [CompilerGeneratedAttribute]
public StringBuilder get_Builder();
    [MustUseReturnValueAttribute]
public static PooledStringBuilder GetInstance();
    public void Dispose();
    public char get_Item(int index);
    public int get_Length();
    public PooledStringBuilder Append(byte value);
    public PooledStringBuilder Append(char value);
    public PooledStringBuilder Append(int value);
    public PooledStringBuilder Append(long value);
    [NullableContextAttribute("2")]
public PooledStringBuilder Append(object value);
    public PooledStringBuilder Append(float value);
    public PooledStringBuilder Append(double value);
    [NullableContextAttribute("2")]
public PooledStringBuilder Append(string value);
    public PooledStringBuilder Append(string value, int startIndex, int count);
    public PooledStringBuilder AppendFormat(string format, object arg0);
    [NullableContextAttribute("2")]
[StringFormatMethodAttribute("format")]
public PooledStringBuilder AppendFormat(string format, object arg0, object arg1);
    [NullableContextAttribute("2")]
[StringFormatMethodAttribute("format")]
public PooledStringBuilder AppendFormat(string format, object arg0, object arg1, object arg2);
    [StringFormatMethodAttribute("format")]
public PooledStringBuilder AppendFormat(string format, Object[] args);
    public PooledStringBuilder AppendLine();
    [NullableContextAttribute("2")]
public PooledStringBuilder AppendLine(string value);
    public void Clear();
    [MustUseReturnValueAttribute]
public virtual string ToString();
}
[DebuggerTypeProxyAttribute("JetBrains.Util.DataStructures.Collections.SlimDictionaryDebugView`2")]
[DebuggerDisplayAttribute("Count = {Count}")]
[UsedImplicitlyAttribute("3")]
public class JetBrains.Util.DataStructures.Collections.SlimDictionary`2 : object {
    [NotNullAttribute]
private Int32[] myBuckets;
    [NotNullAttribute]
private Entry[] myEntries;
    private int myFreeList;
    private int myCount;
    [NotNullAttribute]
private static Entry[] ourEmptyEntries;
    [NotNullAttribute]
private static Int32[] ourEmptyBucket;
    public int Count { get; }
    public int Capacity { get; }
    public SlimDictionary`2(int capacity);
    private static SlimDictionary`2();
    public sealed virtual int get_Count();
    public int get_Capacity();
    public bool ContainsKey(TKey key);
    public bool TryGetValue(TKey key, TValue& value);
    public bool Remove(TKey key);
    public TValue& GetOrAddKeyAndGetValueRef(TKey key);
    public void Clear();
    private TValue& AddKey(TKey key, UInt32 bucketIndex);
    [NotNullAttribute]
private Entry[] EnlargeCapacity();
    public void TrimExcess();
    public Enumerator<TKey, TValue> GetEnumerator();
    private sealed virtual override IEnumerator`1<KeyValuePair`2<TKey, TValue>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TValue>>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [ContractAnnotationAttribute("=> halt")]
private static void ThrowConcurrentModification();
}
[UsedImplicitlyAttribute("3")]
internal class JetBrains.Util.DataStructures.Collections.SlimDictionaryDebugView`2 : object {
    [NotNullAttribute]
private SlimDictionary`2<TKey, TValue> mySlimDictionary;
    [DebuggerBrowsableAttribute("3")]
public KeyValuePair`2[] Items { get; }
    public SlimDictionaryDebugView`2(SlimDictionary`2<TKey, TValue> slimDictionary);
    public KeyValuePair`2[] get_Items();
}
[DebuggerTypeProxyAttribute("JetBrains.Util.DataStructures.Collections.SlimDictionaryDebugView`2")]
[DebuggerDisplayAttribute("Count = {Count}")]
[UsedImplicitlyAttribute]
public class JetBrains.Util.DataStructures.Collections.SlimHashSet`1 : object {
    [NotNullAttribute]
private Int32[] myBuckets;
    [NotNullAttribute]
private Entry[] myEntries;
    private int myFreeList;
    private int myCount;
    [NotNullAttribute]
private static Entry[] ourEmptyEntries;
    [NotNullAttribute]
private static Int32[] ourEmptyBucket;
    public int Count { get; }
    public int Capacity { get; }
    public SlimHashSet`1(int capacity);
    private static SlimHashSet`1();
    public sealed virtual int get_Count();
    public int get_Capacity();
    public bool TryGetValue(T value, T& existingValue);
    public bool Contains(T value);
    public bool Remove(T value);
    public bool Add(T value);
    public void Clear();
    private void AddValue(T value, UInt32 bucketIndex);
    [NotNullAttribute]
private Entry[] Resize();
    public void TrimExcess();
    public Enumerator<T> GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [ContractAnnotationAttribute("=> halt")]
private static void ThrowConcurrentModification();
    public void InternAllValues(Func`2<T, T> internFunc);
}
[UsedImplicitlyAttribute("3")]
internal class JetBrains.Util.DataStructures.Collections.SlimHashSetDebugView`1 : object {
    [NotNullAttribute]
private SlimHashSet`1<T> mySlimHashSet;
    [DebuggerBrowsableAttribute("3")]
public T[] Items { get; }
    public SlimHashSetDebugView`1(SlimHashSet`1<T> slimHashSet);
    public T[] get_Items();
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[CompilerFeatureRequiredAttribute("RefStructs")]
[DefaultMemberAttribute("Item")]
[DebuggerTypeProxyAttribute("JetBrains.Util.DataStructures.Collections.StackLocalListDebugView`1")]
[DebuggerDisplayAttribute("Count = {Count}")]
public class JetBrains.Util.DataStructures.Collections.StackLocalList`1 : ValueType {
    private static int MaxInlineCount;
    private T myItem00;
    private T myItem01;
    private T myItem02;
    private T myItem03;
    private T myItem04;
    private T myItem05;
    private T myItem06;
    private T myItem07;
    [CanBeNullAttribute]
private T[] myArray;
    private int myCount;
    private int myVersion;
    public int Count { get; }
    public int Capacity { get; }
    public T Item { get; public set; }
    [CanBeNullAttribute]
public T SingleItem { get; }
    public StackLocalList`1(int capacity);
    public StackLocalList`1(StackLocalList`1& otherList);
    public int get_Count();
    public int get_Capacity();
    public T get_Item(int index);
    public void set_Item(int index, T value);
    private void SetInlineSlot(int index, T& value);
    [PureAttribute]
public T Single();
    public T get_SingleItem();
    [PureAttribute]
[CanBeNullAttribute]
public T FirstOrDefault();
    [PureAttribute]
[CanBeNullAttribute]
public T LastOrDefault();
    public void Add(T item);
    public void EnsureCapacity(int capacity);
    public bool Remove(T item);
    [PureAttribute]
public bool Contains(T item);
    [PureAttribute]
[NotNullAttribute]
public T[] ToArray();
    public void CopyTo(T[] array, int arrayIndex);
    [NotNullAttribute]
[PureAttribute]
internal T[] CopyToArrayImpl();
    private void CopyInlineSlots(T[] array, int arrayIndex);
    public void Clear();
    private void ClearInlineSlots();
    [PureAttribute]
public int IndexOf(T item);
    [PureAttribute]
private int IndexOfInInlineSlots(T item);
    public void RemoveAt(int index);
    private void ShiftItemsFrom(int index);
    [PureAttribute]
public ElementEnumerator<T> GetEnumerator();
    [PureAttribute]
[NotNullAttribute]
public IList`1<T> ResultingList();
    [PureAttribute]
[NotNullAttribute]
public IReadOnlyList`1<T> ReadOnlyList();
    public virtual string ToString();
    private static void ThrowOutOfRange();
    private static void ThrowResultObtained();
    private static void ThrowEmpty();
    private static void ThrowManyItems();
}
internal class JetBrains.Util.DataStructures.Collections.StackLocalListDebugView`1 : object {
    [CompilerGeneratedAttribute]
private T[] <Items>k__BackingField;
    [NotNullAttribute]
[DebuggerBrowsableAttribute("3")]
public T[] Items { get; }
    public StackLocalListDebugView`1(StackLocalList`1<T> localList);
    [CompilerGeneratedAttribute]
public T[] get_Items();
}
public class JetBrains.Util.DataStructures.CompactMap`2 : CompactMapBase`4<TKey, TValue, CompactMapStorage`2<TKey, TValue>, object> {
    public CompactMap`2(IEqualityComparer`1<TKey> equalityComparer);
    public CompactMap`2(int initialSlotCount);
    public CompactMap`2(int initialSlotCount, IEqualityComparer`1<TKey> equalityComparer);
    public CompactMap`2(int intialSlotCount, double maxLoadFactor, IEqualityComparer`1<TKey> equalityComparer);
    public CompactMap`2(IDictionary`2<TKey, TValue> dictionary);
    public CompactMap`2(IDictionary`2<TKey, TValue> dictionary, IEqualityComparer`1<TKey> comparer);
    protected virtual CompactMapStorage`2<TKey, TValue> CreateStorage(int slotCount);
    protected virtual SlotState<TKey, TValue, CompactMapStorage`2<TKey, TValue>, object> GetSlotState(CompactMapStorage`2<TKey, TValue> storage, int index, TKey& key);
    protected virtual object GetSlotData(CompactMapStorage`2<TKey, TValue> storage, int index);
    protected virtual TValue GetValue(CompactMapStorage`2<TKey, TValue> storage, int index, object data);
    protected virtual void SetValue(CompactMapStorage`2<TKey, TValue> storage, int index, TValue value);
    protected virtual void SetKeyAndValue(CompactMapStorage`2<TKey, TValue> storage, int index, TKey key, TValue value);
    protected virtual void RemoveValue(CompactMapStorage`2<TKey, TValue> storage, int index);
    protected virtual void InternKeyInplace(CompactMapStorage`2<TKey, TValue> storage, int index, TKey key);
    protected virtual void ClearStorage(CompactMapStorage`2<TKey, TValue> storage);
}
[DefaultMemberAttribute("Item")]
public abstract class JetBrains.Util.DataStructures.CompactMapBase`4 : object {
    public static double DEFAULT_MAX_LOAD_FACTOR;
    public static int DEFAULT_INITIAL_SLOT_COUNT;
    public static int CLEAR_STORAGE_THRESHOLD;
    private double myMaxLoadFactor;
    private IEqualityComparer`1<TKey> myEqualityComparer;
    private TStorage myStorage;
    private int mySlotCount;
    private int myCount;
    private int myRemovedCount;
    private int myVersion;
    private MyKeyCollection<TKey, TValue, TStorage, TData> myKeyCollection;
    private MyValueCollection<TKey, TValue, TStorage, TData> myValueCollection;
    private bool myShouldValidateKey;
    public IEqualityComparer`1<TKey> EqualityComparer { get; }
    public double MaxLoadFactor { get; }
    public int SlotCount { get; }
    public int Count { get; }
    public TValue Item { get; public set; }
    public ICollection`1<TKey> Keys { get; }
    private IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Keys { get; }
    public ICollection`1<TValue> Values { get; }
    private IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Values { get; }
    private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.IsReadOnly { get; }
    protected CompactMapBase`4(int intialSlotCount, double maxLoadFactor, IEqualityComparer`1<TKey> equalityComparer, bool shouldValidateKey);
    protected void InitStorage();
    private void ValidateKey(TKey key);
    protected virtual void DoValidateKey(TKey key);
    public IEqualityComparer`1<TKey> get_EqualityComparer();
    protected abstract virtual TStorage CreateStorage(int slotCount);
    protected abstract virtual TValue GetValue(TStorage storage, int index, TData data);
    protected abstract virtual void SetValue(TStorage storage, int index, TValue value);
    protected abstract virtual void SetKeyAndValue(TStorage storage, int index, TKey key, TValue value);
    protected abstract virtual void RemoveValue(TStorage storage, int index);
    protected abstract virtual void ClearStorage(TStorage storage);
    protected virtual void InternKeyInplace(TStorage storage, int index, TKey key);
    protected abstract virtual SlotState<TKey, TValue, TStorage, TData> GetSlotState(TStorage storage, int index, TKey& key);
    protected abstract virtual TData GetSlotData(TStorage storage, int index);
    public double get_MaxLoadFactor();
    public int get_SlotCount();
    public sealed virtual int get_Count();
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    public sealed virtual void Add(TKey key, TValue value);
    private void Insert(TKey key, TValue value, bool addNew);
    public sealed virtual bool Remove(TKey key);
    public sealed virtual bool ContainsKey(TKey key);
    public sealed virtual void Clear();
    public sealed virtual ICollection`1<TKey> get_Keys();
    private sealed virtual override IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Keys();
    public sealed virtual ICollection`1<TValue> get_Values();
    private sealed virtual override IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Values();
    private int Index(TKey key);
    private int InsertionIndex(TKey key);
    private int ProbeDistance(int hash);
    private void Grow();
    public void Compact();
    private void Resize(int newSlotCount);
    private bool IsAlmostFull();
    public IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    private sealed virtual override IEnumerator`1<KeyValuePair`2<TKey, TValue>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TValue>>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Contains(KeyValuePair`2<TKey, TValue> item);
    private bool Contains(KeyValuePair`2<TKey, TValue> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Add(KeyValuePair`2<TKey, TValue> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.CopyTo(KeyValuePair`2[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Remove(KeyValuePair`2<TKey, TValue> item);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.get_IsReadOnly();
    private static void CopyTo(IEnumerable`1<T> collection, T[] array, int index);
    public void InternAllKeys(Func`2<TKey, TKey> internFunc);
    public void DumpStatistics();
}
public class JetBrains.Util.DataStructures.CompactMapStorage`2 : ValueType {
    public ChunkArray`1<TKey> Keys;
    public ChunkArray`1<TValue> Values;
    public ChunkArray`1<int> SlotStates;
    public CompactMapStorage`2(int length);
    public int GetSlotState(int index);
    public void SetSlotState(int index, int state);
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Util.DataStructures.CompactOneToListMap`2 : object {
    private static string ValuesInMap;
    private static string ValuesInLists;
    [NotNullAttribute]
private CompactMap`2<TKey, List`1<TValue>> myListMap;
    [NotNullAttribute]
private CompactMap`2<TKey, TValue> myValueMap;
    public int Count { get; }
    [NotNullAttribute]
public ICollection`1<TKey> Keys { get; }
    [NotNullAttribute]
public IList`1<TValue> AllValues { get; }
    [NotNullAttribute]
public IList`1<TValue> Item { get; }
    public CompactOneToListMap`2(IEqualityComparer`1<TKey> equalityComparer);
    public CompactOneToListMap`2(int capacity, IEqualityComparer`1<TKey> equalityComparer);
    public int get_Count();
    public void Clear();
    public ICollection`1<TKey> get_Keys();
    public IList`1<TValue> get_AllValues();
    public IList`1<TValue> get_Item(TKey key);
    [NotNullAttribute]
public IList`1<TValue> GetValuesSafe(TKey key);
    public void InsertValue(TKey key, TValue value, int index);
    public int CountForKey(TKey key);
    public void AddValue(TKey key, TValue value);
    public void AddValueRange(TKey key, IEnumerable`1<TValue> values);
    public void RemoveValue(TKey key, TValue value);
    public void ReplaceValue(TKey key, TValue oldValue, TValue newValue);
    public void RemoveKey(TKey key);
    public bool ContainsKey(TKey key);
    public bool ContainsValue(TValue value);
    public bool ContainsPair(TKey key, TValue value);
    [IteratorStateMachineAttribute("JetBrains.Util.DataStructures.CompactOneToListMap`2/<GetEnumerator>d__26")]
public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, IList`1<TValue>>> GetEnumerator();
    [IteratorStateMachineAttribute("JetBrains.Util.DataStructures.CompactOneToListMap`2/<EnumerateAllValues>d__27")]
[NotNullAttribute]
public IEnumerable`1<TValue> EnumerateAllValues();
    public void ProcessMap(Action`2<TKey, IList`1<TValue>> listProcessor, Action`2<TKey, TValue> singletonsProcessor);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public void Compact();
    public void RemoveValues(TKey key, ICollection`1<TValue> valuesToRemove);
    [IteratorStateMachineAttribute("JetBrains.Util.DataStructures.CompactOneToListMap`2/<EnumerateValues>d__32")]
public IEnumerable`1<TValue> EnumerateValues(TKey key);
    public void InternAllKeys(Func`2<TKey, TKey> internFunc);
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Util.DataStructures.CompactOneToSetMap`2 : object {
    private CompactMap`2<TKey, CompactSet`1<TValue>> myInnerMap;
    public int Count { get; }
    public ICollection`1<TKey> Keys { get; }
    public IList`1<TValue> AllValues { get; }
    public CompactSet`1<TValue> Item { get; }
    public CompactOneToSetMap`2(int count, IEqualityComparer`1<TKey> comparer);
    public int get_Count();
    public void Clear();
    public ICollection`1<TKey> get_Keys();
    public IList`1<TValue> get_AllValues();
    public CompactSet`1<TValue> get_Item(TKey key);
    public CompactSet`1<TValue> GetValuesSafe(TKey key);
    public void Add(TKey key, TValue value);
    public void Remove(TKey key, TValue value);
    public void RemoveKey(TKey key);
    public bool ContainsKey(TKey key);
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, CompactSet`1<TValue>>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class JetBrains.Util.DataStructures.CompactSet`1 : object {
    private NoValueMap<T> myMap;
    public static CompactSet`1<T> Empty;
    public IEqualityComparer`1<T> EqualityComparer { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public CompactSet`1(IEqualityComparer`1<T> comparer);
    public CompactSet`1(int intialSlotCount, double maxLoadFactor, IEqualityComparer`1<T> comparer);
    private static CompactSet`1();
    public IEqualityComparer`1<T> get_EqualityComparer();
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    private static void CopyTo(IEnumerable`1<U> collection, U[] array, int index);
    public sealed virtual bool Remove(T item);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[IsReadOnlyAttribute]
public class JetBrains.Util.dataStructures.EnumerableWithReadWriteLock`1 : ValueType {
    private EnumeratorWithReadWriteLock`1<T> myEnumeratorWithReadWriteLock;
    public EnumerableWithReadWriteLock`1(EnumeratorWithReadWriteLock`1<T> enumeratorWithReadWriteLock);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public static class JetBrains.Util.dataStructures.EnumerableWithReadWriteLockEx : object {
    public static EnumerableWithReadWriteLock`1<T> Create(OnWriteLockRequestedBehavior behavior, IEnumerable`1<T> enumerable, ILogger logger);
}
public class JetBrains.Util.dataStructures.EnumeratorWithReadWriteLock`1 : object {
    private OnWriteLockRequestedBehavior myBehavior;
    private IEnumerator`1<T> myEnumerator;
    [CanBeNullAttribute]
private ILogger myLogger;
    private Action`1<EnumeratorWithReadWriteLock`1<T>> myOnDisposedAction;
    private bool myLastMoveNextResult;
    [CanBeNullAttribute]
private IList`1<T> myList;
    private State<T> myState;
    public T Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    public EnumeratorWithReadWriteLock`1(OnWriteLockRequestedBehavior behavior, IEnumerable`1<T> enumerable, ILogger logger, Action`1<EnumeratorWithReadWriteLock`1<T>> onDisposedAction);
    public EnumeratorWithReadWriteLock`1(OnWriteLockRequestedBehavior behavior, IEnumerator`1<T> enumerator, ILogger logger, Action`1<EnumeratorWithReadWriteLock`1<T>> onDisposedAction);
    public bool IsRunning();
    public void OnWriteLockRequested();
    private void Clear();
    public sealed virtual void Dispose();
    [NotNullAttribute]
private static IList`1<T> EnumeratorToList(IEnumerator`1<T> enumerator, bool lastMoveNextResult);
    private void HandleState();
    private void MaterializeEnumerable();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
    public sealed virtual T get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    [CompilerGeneratedAttribute]
private void <Clear>b__12_0();
    [CompilerGeneratedAttribute]
private void <Dispose>b__13_0();
}
[ExtensionAttribute]
public static class JetBrains.Util.dataStructures.FrugalLocalList : object {
    public static FrugalLocalList`1<T> Create();
    public static FrugalLocalList`1<T> Create(T item);
    public static FrugalLocalList`1<T> Create(T item1, T item2);
    public static FrugalLocalList`1<T> Create(T item1, T item2, T item3);
    public static FrugalLocalList`1<T> Create(T item1, T item2, T item3, T item4);
    public static FrugalLocalList`1<T> CreateRange(IEnumerable`1<T> items);
    public static FrugalLocalList`1<TItem> CreateRange(ReadOnlySpan`1<TItem> items);
    public static FrugalLocalList`1<T> CreateRangeWhere(IEnumerable`1<T> items, Func`2<T, bool> passfilter);
    public static FrugalLocalList`1<T> CreateRangeWhere(ImmutableArray`1<T> items, Func`2<T, bool> passfilter);
    public static FrugalLocalList`1<T> CreateRangeWhere(FrugalLocalList`1<T> items, Func`2<T, bool> passfilter);
    public static FrugalLocalList`1<TResult> CreateRange(FrugalLocalList`1<TSource> items, Func`2<TSource, TResult> selector);
    public static FrugalLocalList`1<TResult> CreateRange(FrugalLocalList`1<TSource> items, TArg arg, Func`3<TSource, TArg, TResult> selector);
    [PureAttribute]
public static FrugalLocalList`1<T> Of(T item);
    [PureAttribute]
public static FrugalLocalList`1<T> Of(T first, T second);
    [ExtensionAttribute]
[PureAttribute]
public static FrugalLocalList`1<TSource> ToFrugalLocalList(IEnumerable`1<TSource> items);
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Util.dataStructures.FrugalLocalList`1 : ValueType {
    public static int LocalItemsCount;
    [NotNullAttribute]
private static EqualityComparer`1<TItem> ItemComparer;
    private TItem myItem0;
    private TItem myItem1;
    private TailList<TItem> myTail;
    public int Count { get; }
    public bool IsEmpty { get; }
    public bool IsSingle { get; }
    public bool HasMultiple { get; }
    public bool IsReadOnly { get; }
    public TItem Item { get; public set; }
    public FrugalLocalList`1(IEnumerable`1<TItem> items);
    public FrugalLocalList`1(TItem[] items);
    public FrugalLocalList`1(ImmutableArray`1<TItem> items);
    public FrugalLocalList`1(FrugalLocalList`1& items);
    public FrugalLocalList`1(FrugalLocalHashSet`1& items);
    public FrugalLocalList`1(int capacity);
    private static FrugalLocalList`1();
    [PureAttribute]
public static FrugalLocalList`1<TItem> Of(TItem singleItem);
    [PureAttribute]
public static FrugalLocalList`1<TItem> Of(TItem first, TItem second);
    [PureAttribute]
internal static FrugalLocalList`1<TItem> Of(TItem first, TItem second, TailList<TItem> tail);
    private void EnsureCapacity(int capacity);
    public int get_Count();
    public bool get_IsEmpty();
    public bool get_IsSingle();
    public bool get_HasMultiple();
    public bool get_IsReadOnly();
    public TItem get_Item(int index);
    public void set_Item(int index, TItem value);
    public void Add(TItem item);
    private void ModifyItemsCount(int newCount);
    public void AddRange(LocalList`1& list);
    public void AddRange(FrugalLocalList`1& list);
    public void AddRange(TItem[] array);
    public void AddRange(IEnumerable`1<TItem> items);
    [PureAttribute]
[NotNullAttribute]
public IList`1<TItem> AsIList();
    [PureAttribute]
[NotNullAttribute]
public IReadOnlyList`1<TItem> AsIReadOnlyList();
    public void Clear();
    [PureAttribute]
public bool Contains(TItem item);
    public void CopyTo(TItem[] array, int arrayIndex);
    [PureAttribute]
public TItem First();
    [PureAttribute]
public TItem Last();
    [PureAttribute]
[CanBeNullAttribute]
public TItem FirstOrDefault();
    [PureAttribute]
[CanBeNullAttribute]
public TItem FirstOrDefault(TItem defaultItem);
    [PureAttribute]
[CanBeNullAttribute]
public TItem LastOrDefault();
    public void Filter(TState state, Func`3<TState, TItem, bool> predicate);
    [PureAttribute]
[CanBeNullAttribute]
public TItem FirstOrDefault(TState state, Func`3<TState, TItem, bool> predicate);
    [PureAttribute]
[CanBeNullAttribute]
public TItem FirstOrDefault(TItem defaultItem, TState state, Func`3<TState, TItem, bool> predicate);
    [PureAttribute]
public FrugalLocalListEnumerator`1<TItem> GetEnumerator();
    [PureAttribute]
public int IndexOf(TItem item);
    public void Insert(int index, TItem item);
    [PureAttribute]
public bool IsNullOrEmpty();
    [PureAttribute]
public int LastIndexOf(TItem item);
    [PureAttribute]
public int LastIndexOf(TItem item, IEqualityComparer`1<TItem> comparer);
    public bool Remove(TItem item);
    public void RemoveAt(int index);
    [PureAttribute]
public bool Any();
    [PureAttribute]
public bool Any(TState state, Func`3<TState, TItem, bool> predicate);
    [PureAttribute]
public TItem Single();
    [PureAttribute]
[CanBeNullAttribute]
public TItem SingleItem();
    [PureAttribute]
[CanBeNullAttribute]
public TItem SingleOrDefault();
    [PureAttribute]
[CanBeNullAttribute]
public TItem SingleOrDefault(TState state, Func`3<TState, TItem, bool> predicate);
    [PureAttribute]
[NotNullAttribute]
public TItem[] ToArray();
    [PureAttribute]
public ImmutableArray`1<TItem> ToImmutableArray();
    [PureAttribute]
[NotNullAttribute]
public List`1<TItem> ToList();
    [PureAttribute]
public ReadOnlyFrugalLocalList`1<TItem> AsReadOnly();
    [PureAttribute]
public FrugalLocalList`1<TConverted> Select(Func`2<TItem, TConverted> converter);
    public void Sort(Comparison`1<TItem> comparison);
    private static void ThrowOutOfRange();
    private static TItem ThrowEmpty();
    private static TItem ThrowManyItems();
    public void ReverseOrder();
}
[DefaultMemberAttribute("Item")]
internal class JetBrains.Util.dataStructures.FrugalLocalListAsIList`1 : object {
    private FrugalLocalList`1<TItem> myList;
    public int Count { get; }
    public bool IsReadOnly { get; }
    [NotNullAttribute]
public TItem Item { get; public set; }
    public FrugalLocalListAsIList`1(FrugalLocalList`1& list);
    public sealed virtual void Add(TItem item);
    public sealed virtual bool Remove(TItem item);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual void Insert(int index, TItem item);
    public sealed virtual void Clear();
    public sealed virtual int IndexOf(TItem item);
    public sealed virtual bool Contains(TItem item);
    public sealed virtual void CopyTo(TItem[] array, int arrayIndex);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual IEnumerator`1<TItem> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual TItem get_Item(int index);
    public sealed virtual void set_Item(int index, TItem value);
}
public class JetBrains.Util.dataStructures.FrugalLocalListEnumerator`1 : ValueType {
    private FrugalLocalList`1<T> myList;
    private int myCount;
    private T myCurrent;
    private int myIndex;
    public T Current { get; }
    internal FrugalLocalListEnumerator`1(FrugalLocalList`1& list);
    public T get_Current();
    public bool MoveNext();
}
[ExtensionAttribute]
public static class JetBrains.Util.dataStructures.FrugalLocalListEx : object {
    private static OnError DefaultOnError;
    private static FrugalLocalListEx();
    [ExtensionAttribute]
public static void AddRange(ICollection`1<TTarget> to, FrugalLocalList`1<TSource> from);
    [ExtensionAttribute]
[PureAttribute]
public static FrugalLocalList`1<TItem> ConcatWith(FrugalLocalList`1<TItem> thіs, TItem item);
    [ExtensionAttribute]
[PureAttribute]
public static bool HasMultiple(FrugalLocalList`1& thіs);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static bool IsEmpty(FrugalLocalList`1& collection);
    [ExtensionAttribute]
[StringFormatMethodAttribute("sContextSentence")]
public static TSource SingleOrFirstErr(FrugalLocalList`1<TSource> source, string sContextSentence, object arg1, object arg2, object arg3, object arg4);
    [ExtensionAttribute]
[StringFormatMethodAttribute("sContextSentence")]
public static TSource SingleOrFirstOrDefaultErr(FrugalLocalList`1<TSource> source, string sContextSentence, object arg1, object arg2, object arg3, object arg4);
    [ExtensionAttribute]
[PureAttribute]
[NotNullAttribute]
public static IList`1<T> ResultingList(FrugalLocalList`1<T> list);
    [ExtensionAttribute]
[PureAttribute]
[NotNullAttribute]
public static IEnumerable`1<T> AsEnumerable(FrugalLocalList`1<T> list);
}
public class JetBrains.Util.DataStructures.FrugalLocalListStructuralComparer`1 : object {
    public static FrugalLocalListStructuralComparer`1<TItem> Default;
    [CanBeNullAttribute]
private IComparer`1<TItem> myComparerForItem;
    [CanBeNullAttribute]
private IEqualityComparer`1<TItem> myEquatorForItem;
    public FrugalLocalListStructuralComparer`1(IEqualityComparer`1<TItem> equatorForItem, IComparer`1<TItem> comparerForItem);
    private static FrugalLocalListStructuralComparer`1();
    public sealed virtual int Compare(FrugalLocalList`1<TItem> x, FrugalLocalList`1<TItem> y);
    public sealed virtual bool Equals(FrugalLocalList`1<TItem> x, FrugalLocalList`1<TItem> y);
    public sealed virtual int GetHashCode(FrugalLocalList`1<TItem> x);
}
[DefaultMemberAttribute("Item")]
public interface JetBrains.Util.DataStructures.IArray`1 {
    public T Item { get; public set; }
    public abstract virtual T get_Item(int index);
    public abstract virtual void set_Item(int index, T value);
}
public interface JetBrains.Util.dataStructures.IImmutableViewOnSequentialStream {
    public long BytesInCache { get; }
    [NotNullAttribute]
public ImmutableByteStream ImmutableView { get; }
    public bool IsFullyCached { get; }
    public Nullable`1<long> LengthIfKnown { get; }
    public abstract virtual long get_BytesInCache();
    public abstract virtual ImmutableByteStream get_ImmutableView();
    public abstract virtual bool get_IsFullyCached();
    public abstract virtual Nullable`1<long> get_LengthIfKnown();
    public abstract virtual long GetOrFullyReadForLength();
    [NotNullAttribute]
public abstract virtual Stream GetSequentialStreamClone(Lifetime lifetime);
}
public abstract class JetBrains.Util.dataStructures.ImmutableByteStream : Stream {
    [NotNullAttribute]
public static ImmutableByteStream Empty;
    private Lazy`1<ImmutableArray`1<byte>> myLazyDigest;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public ImmutableArray`1<byte> Digest { get; }
    protected ImmutableByteStream(ImmutableByteStream clonesource);
    private static ImmutableByteStream();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public ImmutableArray`1<byte> get_Digest();
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public static ImmutableArray`1<byte> ComputeDigest(Stream stream);
    [NotNullAttribute]
public static ImmutableByteStream CreateOnUserBuffersGuaranteedImmutable(Byte[][] buffers);
    [NotNullAttribute]
public static ImmutableByteStream CreateOnUserBuffersGuaranteedImmutable(IEnumerable`1<Byte[]> buffers, int offset, int count);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual void Flush();
    [NotNullAttribute]
public static ImmutableByteStream FromByteArray(ImmutableArray`1<byte> buffer);
    [NotNullAttribute]
public static ImmutableByteStream FromWritingStream(Action`1<Stream> λWriter);
    public virtual void SetLength(long value);
    [NotNullAttribute]
public abstract virtual ImmutableByteStream ShallowClone();
    public virtual string ToString();
    [NotNullAttribute]
public abstract virtual ImmutableByteStream WithNoLifetime();
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual void WriteByte(byte value);
    [CompilerGeneratedAttribute]
private ImmutableArray`1<byte> <.ctor>b__2_0();
}
public class JetBrains.Util.dataStructures.ImmutableByteStreamStructuralComparer : object {
    public static ImmutableByteStreamStructuralComparer Default;
    private static ImmutableByteStreamStructuralComparer();
    public sealed virtual int Compare(ImmutableByteStream x, ImmutableByteStream y);
    public sealed virtual bool Equals(ImmutableByteStream x, ImmutableByteStream y);
    public sealed virtual int GetHashCode(ImmutableByteStream o);
}
public class JetBrains.Util.DataStructures.MergedCollection`1 : object {
    private List`1<ICollection`1<T>> myCollections;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public MergedCollection`1(IEnumerable`1<ICollection`1<T>> collections);
    public MergedCollection`1(ICollection`1<T> collection1, ICollection`1<T> collection2);
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Remove(T item);
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class JetBrains.Util.DataStructures.ObjectPool`1 : object {
    [CanBeNullAttribute]
private T myHead;
    [NotNullAttribute]
private ValueBox[] myTail;
    [NotNullAttribute]
private Func`2<ObjectPool`1<T>, T> myFactory;
    public ObjectPool`1(Func`2<ObjectPool`1<T>, T> factory);
    [NotNullAttribute]
[MustUseReturnValueAttribute]
public T Allocate();
    [NotNullAttribute]
private T AllocateFromTailOrCreateNew();
    public void Return(T obj);
    private void ReturnToTail(T obj);
    [ConditionalAttribute("JET_MODE_ASSERT")]
public void Forget(T obj);
    [ConditionalAttribute("JET_MODE_ASSERT")]
private void Validate(object obj);
}
public enum JetBrains.Util.dataStructures.OfEqualItems : Enum {
    public int value__;
    public static OfEqualItems TakeAny;
    public static OfEqualItems TakeFirst;
    public static OfEqualItems TakeLast;
}
public enum JetBrains.Util.dataStructures.OnWriteLockRequestedBehavior : Enum {
    public int value__;
    public static OnWriteLockRequestedBehavior THROW_OCE;
    public static OnWriteLockRequestedBehavior MATERIALIZE_ENUMERABLE;
    public static OnWriteLockRequestedBehavior IGNORE_WRITE_LOCK_AND_CONTINUE_ENUMERATION;
}
public class JetBrains.Util.DataStructures.PrimeFinder : object {
    private static Int32[] ourPrimeCapacities;
    public static Int32[] Table;
    private static PrimeFinder();
    public static int NextPrime(int desiredCapacity);
    public static int MaxPrime();
}
[ExtensionAttribute]
public static class JetBrains.Util.DataStructures.QuickSorter : object {
    private static int MaxDepth;
    private static ThreadLocal`1<WeakReference`1<ThreadLocalState>> ourThreadLocalState;
    private static QuickSorter();
    [ExtensionAttribute]
[NotNullAttribute]
public static IArray`1<T> QuickSort(IArray`1<T> array, Comparison`1<T> compare, JetProgress progress);
    [ExtensionAttribute]
[NotNullAttribute]
public static IArray`1<T> QuickSort(IArray`1<T> array, int startIndex, int count, Comparison`1<T> compare, JetProgress progress);
    [ExtensionAttribute]
[NotNullAttribute]
public static ChunkArray`1<T> QuickSort(ChunkArray`1<T> array, Comparison`1<T> compare, JetProgress progress);
    [ExtensionAttribute]
[NotNullAttribute]
public static ChunkList`1<T> QuickSort(ChunkList`1<T> array, Comparison`1<T> compare, JetProgress progress);
    [ExtensionAttribute]
[NotNullAttribute]
public static ChunkArray`1<TValue> QuickSortBy(ChunkArray`1<TValue> values, Func`2<TValue, TKey> keySelector, JetProgress progress);
    [ExtensionAttribute]
[NotNullAttribute]
public static ChunkArray`1<TValue> QuickSortBy(ChunkArray`1<TValue> values, ChunkArray`1<TKey> keys, JetProgress progress);
    private static void QuickSortConcreteArrayIfPossible(IArray`1<T> array, Comparison`1<T> compare, int startIndex, int count, JetProgress progress);
    [NotNullAttribute]
private static ThreadLocalState GetLocalState();
    private static void DoQuickSort(IArray`1<T> array, Comparison`1<T> compare, int startIndex, int count, JetProgress progress);
    private static void DoQuickSort(ChunkArray`1<T> array, Comparison`1<T> compare, int startIndex, int count, JetProgress progress);
    private static void DoQuickSort(ChunkList`1<T> array, Comparison`1<T> compare, int startIndex, int count, JetProgress progress);
    private static void DoQuickSortByKeys(ChunkArray`1<TKey> keys, ChunkArray`1<TValue> values, Comparison`1<TKey> compare, JetProgress progress);
    private static void VerifyLevel(int level);
}
public class JetBrains.Util.dataStructures.RandomAccessViewOnSequentialStream : ImmutableByteStream {
    private Clonedata myData;
    private long myPosition;
    public long BytesInCache { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public bool IsFullyCached { get; }
    public long Length { get; }
    public Nullable`1<long> LengthIfKnown { get; }
    public long Position { get; public set; }
    private ImmutableByteStream JetBrains.Util.dataStructures.IImmutableViewOnSequentialStream.ImmutableView { get; }
    public RandomAccessViewOnSequentialStream(Lifetime lifetime, Func`2<Lifetime, Stream> FOpenStream, bool canOpenMultiple, Nullable`1<long> customlength);
    private RandomAccessViewOnSequentialStream(RandomAccessViewOnSequentialStream clonesource);
    public sealed virtual long get_BytesInCache();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public sealed virtual bool get_IsFullyCached();
    public virtual long get_Length();
    public sealed virtual Nullable`1<long> get_LengthIfKnown();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Flush();
    public sealed virtual long GetOrFullyReadForLength();
    public sealed virtual Stream GetSequentialStreamClone(Lifetime lifetime);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual ImmutableByteStream ShallowClone();
    public virtual ImmutableByteStream WithNoLifetime();
    private long GetOrFullyReadForLengthCold();
    private sealed virtual override ImmutableByteStream JetBrains.Util.dataStructures.IImmutableViewOnSequentialStream.get_ImmutableView();
    private long PumpIntoCache(Nullable`1<long> needAfterPos);
}
[ExtensionAttribute]
public static class JetBrains.Util.DataStructures.RandomAccessViewOnSequentialStreamHelpers : object {
    [ExtensionAttribute]
public static TResult ReadSequentialStream(ImmutableByteStream thіs, Func`2<Stream, TResult> FRead);
    [ExtensionAttribute]
public static void ReadSequentialStream(ImmutableByteStream thіs, Action`1<Stream> FRead);
}
public class JetBrains.Util.dataStructures.RawCircularBufferHeader : ValueType {
    public static UInt32 BufferHeaderSize;
    public UsedBlock BlockHead;
    public UsedBlock BlockTail;
    public UInt32 TotalSize;
    public UInt32 FreeSpace { get; }
    public UInt32 MaxDataSize { get; }
    public RawCircularBufferHeader(UInt32 nTotalSize);
    private static RawCircularBufferHeader();
    public UInt32 get_FreeSpace();
    public UInt32 get_MaxDataSize();
    public static bool IsEmpty(RawCircularBufferHeader* pBufferHeader);
    public static bool TryReadMessage(RawCircularBufferHeader* pBufferHeader, Action`1<ByteBuffer> FWithBuffer);
    [CanBeNullAttribute]
public static Byte[] TryReadMessage(RawCircularBufferHeader* pBufferHeader);
    public static bool TryWriteMessage(RawCircularBufferHeader* pBufferHeader, Byte[] data);
    public void AssertValid();
    private UInt32 GetFreeSpaceCore(UInt32 nReallocHeadToHouseThisSize);
}
public class JetBrains.Util.DataStructures.ReadOnlyException : Exception {
    public ReadOnlyException(SerializationInfo info, StreamingContext context);
    public ReadOnlyException(string message, Exception innerException);
    public ReadOnlyException(string message);
}
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
public class JetBrains.Util.dataStructures.ReadOnlyFrugalLocalList`1 : ValueType {
    private FrugalLocalList`1<T> myList;
    public int Count { get; }
    public bool IsEmpty { get; }
    public bool IsSingle { get; }
    public bool HasMultiple { get; }
    public T Item { get; }
    public ReadOnlyFrugalLocalList`1(FrugalLocalList`1& list);
    public int get_Count();
    public bool get_IsEmpty();
    public bool get_IsSingle();
    public bool get_HasMultiple();
    public T get_Item(int index);
    [PureAttribute]
public bool Contains(T item);
    [PureAttribute]
public bool Any();
    [PureAttribute]
public bool Any(TState state, Func`3<TState, T, bool> predicate);
    [PureAttribute]
public FrugalLocalListEnumerator`1<T> GetEnumerator();
    public void CopyTo(T[] array, int arrayIndex);
    [PureAttribute]
public T First();
    [PureAttribute]
public T Last();
    [PureAttribute]
[CanBeNullAttribute]
public T FirstOrDefault();
    [PureAttribute]
[CanBeNullAttribute]
public T FirstOrDefault(TState state, Func`3<TState, T, bool> predicate);
    [PureAttribute]
[CanBeNullAttribute]
public T LastOrDefault();
    [PureAttribute]
public int IndexOf(T item);
    [PureAttribute]
public int LastIndexOf(T item);
    [PureAttribute]
public int LastIndexOf(T item, IEqualityComparer`1<T> comparer);
    [PureAttribute]
public T Single();
    [PureAttribute]
[CanBeNullAttribute]
public T SingleItem();
    [PureAttribute]
[CanBeNullAttribute]
public T SingleOrDefault();
    [PureAttribute]
[CanBeNullAttribute]
public T SingleOrDefault(TState state, Func`3<TState, T, bool> predicate);
    [PureAttribute]
[NotNullAttribute]
public IReadOnlyList`1<T> ReadOnlyList();
    [PureAttribute]
[NotNullAttribute]
public T[] ToArray();
    [PureAttribute]
[NotNullAttribute]
public List`1<T> ToList();
}
public class JetBrains.Util.DataStructures.ReinterpretStreamAsImmutable : ImmutableByteStream {
    [NotNullAttribute]
private Func`1<Stream> myFGetStreamInstance;
    [NotNullAttribute]
private Stream myStream;
    public bool CanTimeout { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public int ReadTimeout { get; public set; }
    public ReinterpretStreamAsImmutable(Func`1<Stream> FGetStreamInstance);
    private ReinterpretStreamAsImmutable(Func`1<Stream> FGetStreamInstance, ReinterpretStreamAsImmutable clonesource);
    public virtual bool get_CanTimeout();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken);
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual int ReadByte();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual ImmutableByteStream ShallowClone();
    public virtual ImmutableByteStream WithNoLifetime();
}
public class JetBrains.Util.dataStructures.Sources.ByteArrayUtf16leStringSourceOwner : object {
    public static IStringSourceOwner Instance;
    private static ByteArrayUtf16leStringSourceOwner();
    public static StringSource Create(Byte[] array, UInt32 cbstart, UInt32 cblength);
    public virtual string ToString();
    private sealed virtual override StringSource JetBrains.Util.dataStructures.Sources.IStringSourceOwner.AsManagedStringSource(StringSource& ss);
    private sealed virtual override ReadOnlySpan`1<char> JetBrains.Util.dataStructures.Sources.IStringSourceOwner.AsSpan(StringSource& modreq(System.Runtime.InteropServices.InAttribute) ss);
    private sealed virtual override TResult JetBrains.Util.dataStructures.Sources.IStringSourceOwner.Fixed(StringSource& ss, TContext context, StringSourceFixedDelegate`2<TContext, TResult> λ);
    private sealed virtual override char JetBrains.Util.dataStructures.Sources.IStringSourceOwner.GetCharAt(StringSource& ss, UInt32 index);
    private sealed virtual override UInt32 JetBrains.Util.dataStructures.Sources.IStringSourceOwner.GetLength(StringSource& ss);
    private sealed virtual override bool JetBrains.Util.dataStructures.Sources.IStringSourceOwner.IsEmpty(StringSource& ss);
    private sealed virtual override StringSource JetBrains.Util.dataStructures.Sources.IStringSourceOwner.Substring(StringSource& ss, UInt32 start, UInt32 length);
    private sealed virtual override string JetBrains.Util.dataStructures.Sources.IStringSourceOwner.ToRuntimeString(StringSource& ss);
}
[DebuggerTypeProxyAttribute("JetBrains.Util.dataStructures.Sources.CollectionSourceDebugView`1")]
public class JetBrains.Util.dataStructures.Sources.CollectionSource`1 : ValueType {
    public static CollectionSource`1<TItem> Empty;
    private ICollectionSourceOwner`1<TItem> myOwner;
    public CollectionSourcePodData DataPod;
    public object DataRefX;
    public int Count { get; }
    public bool IsFastCount { get; }
    public ICollectionSourceOwner`1<TItem> Owner { get; }
    public CollectionSource`1(ICollectionSourceOwner`1<TItem> owner, object dataRefX, object dataRefY, CollectionSourcePodData dataPod);
    private static CollectionSource`1();
    [PureAttribute]
[NotNullAttribute]
public int get_Count();
    [PureAttribute]
[NotNullAttribute]
public bool get_IsFastCount();
    [PureAttribute]
[NotNullAttribute]
public ICollectionSourceOwner`1<TItem> get_Owner();
    public static CollectionSource`1<TItem> FromCollection(ICollection`1<TItem> collection);
    [PureAttribute]
public Enumerator<TItem> GetEnumerator();
    [NotNullAttribute]
[PureAttribute]
public TItem[] ToArray();
    [NotNullAttribute]
[PureAttribute]
public ICollection`1<TItem> ToCollection();
    [NotNullAttribute]
[PureAttribute]
public IEnumerable`1<TItem> ToEnumerable();
    [PureAttribute]
public virtual string ToString();
}
internal class JetBrains.Util.dataStructures.Sources.CollectionSourceDebugView`1 : object {
    private CollectionSource`1<TItem> myTarget;
    [DebuggerBrowsableAttribute("3")]
[NotNullAttribute]
public TItem[] Items { get; }
    public CollectionSourceDebugView`1(CollectionSource`1<TItem> target);
    public TItem[] get_Items();
}
[ExtensionAttribute]
public static class JetBrains.Util.dataStructures.Sources.CollectionSourceEx : object {
    [ExtensionAttribute]
public static void AddRange(ICollection`1<TItem> target, CollectionSource`1<TItem> source);
    [ExtensionAttribute]
public static CollectionSource`1<TItem> AsCollectionSource(ICollection`1<TItem> thіs);
    [ExtensionAttribute]
public static CollectionSource`1<TItem> AsEnumCollectionSource(IEnumerable`1<TItem> thіs);
    [ExtensionAttribute]
public static int Count(CollectionSource`1<TItem> thіs);
    [ExtensionAttribute]
public static TItem First(CollectionSource`1<TItem> thіs);
    [ExtensionAttribute]
public static TItem FirstOrDefault(CollectionSource`1<TItem> thіs);
    [ExtensionAttribute]
public static TItem GetItemAt(CollectionSource`1<TItem> thіs, UInt32 index);
    [ExtensionAttribute]
public static bool HasMultiple(CollectionSource`1<TItem> thіs);
    [ExtensionAttribute]
public static bool IsEmpty(CollectionSource`1<TItem> thіs);
    [ExtensionAttribute]
public static bool IsSingle(CollectionSource`1<TItem> thіs);
    [ExtensionAttribute]
public static bool SequenceEqual(CollectionSource`1<TSource> first, CollectionSource`1<TSource> second, IEqualityComparer`1<TSource> comparer);
    [ExtensionAttribute]
public static bool SequenceEqual(CollectionSource`1<TSource> first, IEnumerable`1<TSource> second, IEqualityComparer`1<TSource> comparer);
    [ExtensionAttribute]
public static TItem Single(CollectionSource`1<TItem> thіs, string errmsg);
    [ExtensionAttribute]
[NotNullAttribute]
public static JetHashSet`1<TItem> ToJetHashSet(CollectionSource`1<TItem> thіs);
    public static int GetHashCode(CollectionSource`1<T> array);
}
public static class JetBrains.Util.dataStructures.Sources.CollectionSourceOwnerHelpers : object {
    public static UInt32 GetCountViaEnumeration(CollectionSource`1& instance);
    [NotNullAttribute]
public static TItem[] ToArrayViaEnumeration(CollectionSource`1& instance);
    [NotNullAttribute]
public static IEnumerable`1<TItem> ToEnumerableViaEnumeration(CollectionSource`1& instance);
    [NotNullAttribute]
public static IList`1<TItem> ToListViaEnumeration(CollectionSource`1& instance);
}
public class JetBrains.Util.dataStructures.Sources.CollectionSourcePodData : ValueType {
}
public class JetBrains.Util.dataStructures.Sources.EmptyCollectionSourceOwner`1 : object {
    public static EmptyCollectionSourceOwner`1<TItem> Instance;
    private static EmptyCollectionSourceOwner`1();
    public sealed virtual IEnumerable`1<TItem> ToEnumerable(CollectionSource`1& instance);
    private sealed virtual override void JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<TItem>.EnumeratorDispose(Enumerator& instance);
    private sealed virtual override TItem JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<TItem>.EnumeratorGetCurrent(Enumerator& instance);
    private sealed virtual override bool JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<TItem>.EnumeratorMoveNext(Enumerator& instance);
    private sealed virtual override UInt32 JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<TItem>.GetCount(CollectionSource`1& instance);
    private sealed virtual override Enumerator<TItem> JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<TItem>.GetEnumerator(CollectionSource`1& instance);
    private sealed virtual override bool JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<TItem>.GetIsFastCount(CollectionSource`1& instance);
    private sealed virtual override TItem[] JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<TItem>.ToArray(CollectionSource`1& instance);
    private sealed virtual override ICollection`1<TItem> JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<TItem>.ToCollection(CollectionSource`1& instance);
    private sealed virtual override string JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<TItem>.ToString(CollectionSource`1& instance);
}
public class JetBrains.Util.dataStructures.Sources.EmptyStringSourceOwner : object {
    public static IStringSourceOwner Instance;
    private static EmptyStringSourceOwner();
    private sealed virtual override StringSource JetBrains.Util.dataStructures.Sources.IStringSourceOwner.AsManagedStringSource(StringSource& ss);
    private sealed virtual override ReadOnlySpan`1<char> JetBrains.Util.dataStructures.Sources.IStringSourceOwner.AsSpan(StringSource& modreq(System.Runtime.InteropServices.InAttribute) ss);
    private sealed virtual override TResult JetBrains.Util.dataStructures.Sources.IStringSourceOwner.Fixed(StringSource& ss, TContext context, StringSourceFixedDelegate`2<TContext, TResult> λ);
    private sealed virtual override char JetBrains.Util.dataStructures.Sources.IStringSourceOwner.GetCharAt(StringSource& ss, UInt32 index);
    private sealed virtual override UInt32 JetBrains.Util.dataStructures.Sources.IStringSourceOwner.GetLength(StringSource& ss);
    private sealed virtual override bool JetBrains.Util.dataStructures.Sources.IStringSourceOwner.IsEmpty(StringSource& ss);
    private sealed virtual override StringSource JetBrains.Util.dataStructures.Sources.IStringSourceOwner.Substring(StringSource& ss, UInt32 start, UInt32 length);
    private sealed virtual override string JetBrains.Util.dataStructures.Sources.IStringSourceOwner.ToRuntimeString(StringSource& ss);
}
public interface JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner`1 {
    public abstract virtual void EnumeratorDispose(Enumerator& instance);
    public abstract virtual TItem EnumeratorGetCurrent(Enumerator& instance);
    public abstract virtual bool EnumeratorMoveNext(Enumerator& instance);
    public abstract virtual UInt32 GetCount(CollectionSource`1& instance);
    public abstract virtual Enumerator<TItem> GetEnumerator(CollectionSource`1& instance);
    public abstract virtual bool GetIsFastCount(CollectionSource`1& instance);
    public abstract virtual TItem[] ToArray(CollectionSource`1& instance);
    public abstract virtual ICollection`1<TItem> ToCollection(CollectionSource`1& instance);
    public abstract virtual IEnumerable`1<TItem> ToEnumerable(CollectionSource`1& instance);
    public abstract virtual string ToString(CollectionSource`1& instance);
}
public interface JetBrains.Util.dataStructures.Sources.IStringSourceOwner {
    public abstract virtual StringSource AsManagedStringSource(StringSource& ss);
    public abstract virtual ReadOnlySpan`1<char> AsSpan(StringSource& modreq(System.Runtime.InteropServices.InAttribute) ss);
    public abstract virtual TResult Fixed(StringSource& ss, TContext context, StringSourceFixedDelegate`2<TContext, TResult> λ);
    public abstract virtual char GetCharAt(StringSource& ss, UInt32 index);
    public abstract virtual UInt32 GetLength(StringSource& ss);
    public abstract virtual bool IsEmpty(StringSource& ss);
    public abstract virtual StringSource Substring(StringSource& ss, UInt32 start, UInt32 length);
    [NotNullAttribute]
public abstract virtual string ToRuntimeString(StringSource& ss);
}
public class JetBrains.Util.dataStructures.Sources.LiveEnumerableCollectionSourceOwner`1 : object {
    public static LiveEnumerableCollectionSourceOwner`1<TItem> Instance;
    private static LiveEnumerableCollectionSourceOwner`1();
    public sealed virtual bool GetIsFastCount(CollectionSource`1& instance);
    public sealed virtual TItem[] ToArray(CollectionSource`1& instance);
    public sealed virtual IEnumerable`1<TItem> ToEnumerable(CollectionSource`1& instance);
    private sealed virtual override void JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<TItem>.EnumeratorDispose(Enumerator& instance);
    private sealed virtual override TItem JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<TItem>.EnumeratorGetCurrent(Enumerator& instance);
    private sealed virtual override bool JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<TItem>.EnumeratorMoveNext(Enumerator& instance);
    private sealed virtual override UInt32 JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<TItem>.GetCount(CollectionSource`1& instance);
    private sealed virtual override Enumerator<TItem> JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<TItem>.GetEnumerator(CollectionSource`1& instance);
    private sealed virtual override ICollection`1<TItem> JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<TItem>.ToCollection(CollectionSource`1& instance);
    private sealed virtual override string JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<TItem>.ToString(CollectionSource`1& instance);
}
public class JetBrains.Util.dataStructures.Sources.NativeStringSourceOwner : object {
    public static IStringSourceOwner Instance;
    private static NativeStringSourceOwner();
    public static StringSource Create(Lifetime lifetime, Char* pch, UInt32 length);
    public static StringSource Create(Lifetime lifetime, UInt16* pch, UInt32 length);
    public static StringSource CreateWithoutLifetime(Char* pch, UInt32 length);
    public static StringSource CreateWithoutLifetime(UInt16* pch, UInt32 length);
    private sealed virtual override StringSource JetBrains.Util.dataStructures.Sources.IStringSourceOwner.AsManagedStringSource(StringSource& ss);
    private sealed virtual override ReadOnlySpan`1<char> JetBrains.Util.dataStructures.Sources.IStringSourceOwner.AsSpan(StringSource& modreq(System.Runtime.InteropServices.InAttribute) ss);
    private sealed virtual override TResult JetBrains.Util.dataStructures.Sources.IStringSourceOwner.Fixed(StringSource& ss, TContext context, StringSourceFixedDelegate`2<TContext, TResult> λ);
    private sealed virtual override char JetBrains.Util.dataStructures.Sources.IStringSourceOwner.GetCharAt(StringSource& ss, UInt32 index);
    private sealed virtual override UInt32 JetBrains.Util.dataStructures.Sources.IStringSourceOwner.GetLength(StringSource& ss);
    private static void GetValidatedData(StringSource& ss, PodData& data);
    private sealed virtual override bool JetBrains.Util.dataStructures.Sources.IStringSourceOwner.IsEmpty(StringSource& ss);
    private sealed virtual override StringSource JetBrains.Util.dataStructures.Sources.IStringSourceOwner.Substring(StringSource& ss, UInt32 start, UInt32 length);
    private sealed virtual override string JetBrains.Util.dataStructures.Sources.IStringSourceOwner.ToRuntimeString(StringSource& ss);
}
public class JetBrains.Util.dataStructures.Sources.RealCollectionSourceOwner`1 : object {
    public static RealCollectionSourceOwner`1<TItem> Instance;
    private static RealCollectionSourceOwner`1();
    public sealed virtual bool GetIsFastCount(CollectionSource`1& instance);
    public sealed virtual TItem[] ToArray(CollectionSource`1& instance);
    public sealed virtual IEnumerable`1<TItem> ToEnumerable(CollectionSource`1& instance);
    private sealed virtual override void JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<TItem>.EnumeratorDispose(Enumerator& instance);
    private sealed virtual override TItem JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<TItem>.EnumeratorGetCurrent(Enumerator& instance);
    private sealed virtual override bool JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<TItem>.EnumeratorMoveNext(Enumerator& instance);
    private sealed virtual override UInt32 JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<TItem>.GetCount(CollectionSource`1& instance);
    private sealed virtual override Enumerator<TItem> JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<TItem>.GetEnumerator(CollectionSource`1& instance);
    private sealed virtual override ICollection`1<TItem> JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<TItem>.ToCollection(CollectionSource`1& instance);
    private sealed virtual override string JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<TItem>.ToString(CollectionSource`1& instance);
}
public class JetBrains.Util.dataStructures.Sources.RuntimeStringSourceOwner : object {
    public static IStringSourceOwner Instance;
    private static RuntimeStringSourceOwner();
    public sealed virtual TResult Fixed(StringSource& ss, TContext context, StringSourceFixedDelegate`2<TContext, TResult> λ);
    public sealed virtual char GetCharAt(StringSource& ss, UInt32 index);
    public sealed virtual UInt32 GetLength(StringSource& ss);
    public sealed virtual bool IsEmpty(StringSource& ss);
    public sealed virtual StringSource Substring(StringSource& ss, UInt32 start, UInt32 length);
    public sealed virtual string ToRuntimeString(StringSource& ss);
    private sealed virtual override StringSource JetBrains.Util.dataStructures.Sources.IStringSourceOwner.AsManagedStringSource(StringSource& ss);
    private sealed virtual override ReadOnlySpan`1<char> JetBrains.Util.dataStructures.Sources.IStringSourceOwner.AsSpan(StringSource& modreq(System.Runtime.InteropServices.InAttribute) ss);
}
public class JetBrains.Util.dataStructures.Sources.RuntimeSubStringSourceOwner : object {
    public static IStringSourceOwner Instance;
    private static RuntimeSubStringSourceOwner();
    public static void FromStringSlice(StringSlice& slice, StringSource& ss);
    public sealed virtual char GetCharAt(StringSource& ss, UInt32 index);
    private sealed virtual override StringSource JetBrains.Util.dataStructures.Sources.IStringSourceOwner.AsManagedStringSource(StringSource& ss);
    private sealed virtual override ReadOnlySpan`1<char> JetBrains.Util.dataStructures.Sources.IStringSourceOwner.AsSpan(StringSource& modreq(System.Runtime.InteropServices.InAttribute) ss);
    private sealed virtual override TResult JetBrains.Util.dataStructures.Sources.IStringSourceOwner.Fixed(StringSource& ss, TContext context, StringSourceFixedDelegate`2<TContext, TResult> λ);
    private sealed virtual override UInt32 JetBrains.Util.dataStructures.Sources.IStringSourceOwner.GetLength(StringSource& ss);
    private static void GetStringSlice(StringSource& ss, StringSlice& slice);
    private static void GetStringSliceData(StringSource& ss, String& wholestring, UInt32& start, UInt32& length);
    private sealed virtual override bool JetBrains.Util.dataStructures.Sources.IStringSourceOwner.IsEmpty(StringSource& ss);
    private sealed virtual override StringSource JetBrains.Util.dataStructures.Sources.IStringSourceOwner.Substring(StringSource& ss, UInt32 start, UInt32 length);
    private sealed virtual override string JetBrains.Util.dataStructures.Sources.IStringSourceOwner.ToRuntimeString(StringSource& ss);
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Util.dataStructures.Sources.StringSource : ValueType {
    public static StringSource Empty;
    private IStringSourceOwner myOwner;
    public StringSourcePodData DataPod;
    public object DataRefX;
    public bool IsEmpty { get; }
    public char Item { get; }
    public UInt32 Length { get; }
    public IStringSourceOwner Owner { get; }
    public StringSource(IStringSourceOwner owner, object dataRefX, StringSourcePodData dataPod);
    [PureAttribute]
public bool get_IsEmpty();
    public char get_Item(UInt32 index);
    public UInt32 get_Length();
    [PureAttribute]
[NotNullAttribute]
public IStringSourceOwner get_Owner();
    public StringSource AsManagedStringSource();
    [PureAttribute]
public ReadOnlySpan`1<char> AsSpan();
    public sealed virtual bool Equals(StringSource other);
    public bool Equals(string other);
    public virtual bool Equals(object other);
    public TResult Fixed(TContext context, StringSourceFixedDelegate`2<TContext, TResult> λ);
    public virtual int GetHashCode();
    public static bool op_Equality(StringSource black, StringSource white);
    public static bool op_Equality(StringSource black, string white);
    public static bool op_Equality(string white, StringSource black);
    public static StringSource op_Implicit(string s);
    public static bool op_Inequality(StringSource black, string white);
    public static bool op_Inequality(string white, StringSource black);
    public static bool op_Inequality(StringSource black, StringSource white);
    public StringSource Substring(UInt32 start, UInt32 length);
    [PureAttribute]
[NotNullAttribute]
public string ToRuntimeString();
    [ObsoleteAttribute("Prefer ToRuntimeString specific operation, otherwise semantic of the ToString call might be silently changed upon changing the instance type.")]
public virtual string ToString();
    private sealed virtual override int System.IComparable.CompareTo(object other);
    private sealed virtual override int System.IComparable<JetBrains.Util.dataStructures.Sources.StringSource>.CompareTo(StringSource other);
}
public class JetBrains.Util.dataStructures.Sources.StringSourceComparerIgnoreCase : object {
    [NotNullAttribute]
public static StringSourceComparerIgnoreCase Instance;
    private static StringSourceComparerIgnoreCase();
    public static int Compare(StringSource& black, StringSource& white);
    public static bool Equals(StringSource& black, StringSource& white);
    public static int GetHashCode(StringSource& ss);
    private sealed virtual override int System.Collections.Generic.IComparer<JetBrains.Util.dataStructures.Sources.StringSource>.Compare(StringSource black, StringSource white);
    private sealed virtual override bool System.Collections.Generic.IEqualityComparer<JetBrains.Util.dataStructures.Sources.StringSource>.Equals(StringSource black, StringSource white);
    private sealed virtual override int System.Collections.Generic.IEqualityComparer<JetBrains.Util.dataStructures.Sources.StringSource>.GetHashCode(StringSource ss);
}
public class JetBrains.Util.dataStructures.Sources.StringSourceComparerOrdinal : object {
    [NotNullAttribute]
public static StringSourceComparerOrdinal Instance;
    private static StringSourceComparerOrdinal();
    public static int Compare(StringSource& black, StringSource& white);
    public static bool Equals(StringSource& black, StringSource& white);
    public static int GetHashCode(StringSource& ss);
    private sealed virtual override int System.Collections.Generic.IComparer<JetBrains.Util.dataStructures.Sources.StringSource>.Compare(StringSource black, StringSource white);
    private sealed virtual override bool System.Collections.Generic.IEqualityComparer<JetBrains.Util.dataStructures.Sources.StringSource>.Equals(StringSource black, StringSource white);
    private sealed virtual override int System.Collections.Generic.IEqualityComparer<JetBrains.Util.dataStructures.Sources.StringSource>.GetHashCode(StringSource ss);
}
[ExtensionAttribute]
public static class JetBrains.Util.dataStructures.Sources.StringSourceEx : object {
    [ExtensionAttribute]
public static StringBuilder AppendLineStringSource(StringBuilder thіs, StringSource text);
    [ExtensionAttribute]
public static StringBuilder AppendStringSource(StringBuilder thіs, StringSource text);
    [ExtensionAttribute]
public static StringBuilder AppendStringSource(StringBuilder thіs, StringSource text, UInt32 index, UInt32 length);
    [ExtensionAttribute]
public static StringSource AsStringSource(StringSlice slice);
    [ExtensionAttribute]
public static bool EndsWith(StringSource thіs, StringSource suffix);
    [ExtensionAttribute]
public static int IndexOf(StringSource thіs, char ch);
    [ExtensionAttribute]
public static int IndexOfAny(StringSource thіs, Char[] chs);
    [ExtensionAttribute]
public static bool IsEmpty(StringSource thіs);
    [ExtensionAttribute]
public static bool IsEmpty(Nullable`1<StringSource> thіs);
    [ExtensionAttribute]
public static int LastIndexOf(StringSource thіs, char ch);
    [ExtensionAttribute]
public static int LastIndexOfAny(StringSource thіs, Char[] chs);
    [ExtensionAttribute]
public static Guid ParseGuid(StringSource thіs, OnError onerror);
    [ExtensionAttribute]
public static StringSource Replace(StringSource thіs, char what, char with);
    [ExtensionAttribute]
public static StringSource[] Split(StringSource thіs, Char[] separators);
    [ExtensionAttribute]
public static StringSource[] Split(StringSource thіs, Char[] separators, StringSplitOptions options);
    [ExtensionAttribute]
public static bool StartsWith(StringSource thіs, StringSource suffix);
    [ExtensionAttribute]
public static StringSource Substring(StringSource thіs, UInt32 start);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static string ToRuntimeString(Nullable`1<StringSource> thіs);
}
public class JetBrains.Util.dataStructures.Sources.StringSourceFixedDelegate`2 : MulticastDelegate {
    public StringSourceFixedDelegate`2(object object, IntPtr method);
    public virtual TResult Invoke(Char* pch, UInt32 length, TContext context);
    public virtual IAsyncResult BeginInvoke(Char* pch, UInt32 length, TContext context, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public class JetBrains.Util.dataStructures.Sources.StringSourcePodData : ValueType {
}
[ExtensionAttribute]
public static class JetBrains.Util.DataStructures.StableSorter : object {
    private static ThreadLocal`1<WeakReference`1<object>> ourThreadLocalState;
    private static StableSorter();
    [ExtensionAttribute]
[NotNullAttribute]
public static IArray`1<T> StableSort(IArray`1<T> array, Comparison`1<T> compare, JetProgress progress);
    [ExtensionAttribute]
[NotNullAttribute]
public static IList`1<T> StableSort(IList`1<T> list, Comparison`1<T> compare, JetProgress progress);
    [ExtensionAttribute]
[NotNullAttribute]
public static ChunkArray`1<T> StableSort(ChunkArray`1<T> this, Comparison`1<T> compare, JetProgress progress);
    [ExtensionAttribute]
[NotNullAttribute]
public static ChunkList`1<T> StableSort(ChunkList`1<T> this, Comparison`1<T> compare, JetProgress progress);
    [ExtensionAttribute]
[NotNullAttribute]
public static List`1<T> StableSort(List`1<T> this, Comparison`1<T> compare, JetProgress progress);
    [ExtensionAttribute]
[NotNullAttribute]
public static ChunkArray`1<TValue> StableSortBy(ChunkArray`1<TValue> values, Func`2<TValue, TKey> keySelector, JetProgress progress);
    [ExtensionAttribute]
[NotNullAttribute]
public static ChunkArray`1<TValue> StableSortBy(ChunkArray`1<TValue> values, ChunkArray`1<TKey> keys, JetProgress progress);
    private static int GetEstimatedStepsCount(int length);
    [NotNullAttribute]
private static ChunkArray`1<T> GetTempArray(int length);
    [NotNullAttribute]
private static ChunkList`1<T> GetTempList(int length);
    public static void SetTemporaryStoreForCurrentThread(object array);
    private static void StableSortConcreteArrayIfPossible(IArray`1<T> array, Comparison`1<T> compare, int startIndex, int count, JetProgress progress);
    private static void StableSortConcreateListIfPossible(IList`1<T> list, Comparison`1<T> compare, int startIndex, int count, JetProgress progress);
    private static void DoStableSort(IArray`1<T> array, Comparison`1<T> compare, int startIndex, int endIndex, JetProgress progress);
    private static void DoStableSort(IList`1<T> array, Comparison`1<T> compare, int startIndex, int endIndex, JetProgress progress);
    private static void DoStableSort(ChunkArray`1<T> array, Comparison`1<T> compare, int startIndex, int endIndex, JetProgress progress);
    private static void DoStableSort(ChunkList`1<T> array, Comparison`1<T> compare, int startIndex, int endIndex, JetProgress progress);
    private static void DoStableSort(List`1<T> array, Comparison`1<T> compare, int startIndex, int endIndex, JetProgress progress);
    private static IArray`1<T> DoStableSort(IArray`1<T> array, IArray`1<T> temp, Comparison`1<T> compare, int startIndex, int endIndex, JetProgress progress);
    private static IList`1<T> DoStableSort(IList`1<T> array, IList`1<T> temp, Comparison`1<T> compare, int startIndex, int endIndex, JetProgress progress);
    private static ChunkArray`1<T> DoStableSort(ChunkArray`1<T> array, ChunkArray`1<T> temp, Comparison`1<T> compare, int startIndex, int endIndex, JetProgress progress);
    private static ChunkList`1<T> DoStableSort(ChunkList`1<T> array, ChunkList`1<T> temp, Comparison`1<T> compare, int startIndex, int endIndex, JetProgress progress);
    private static void DoStableSort(List`1<T> array, ChunkArray`1<T> temp, Comparison`1<T> compare, int startIndex, int endIndex, JetProgress progress);
    private static void DoStableSort(ChunkArray`1<TKey> keys, ChunkArray`1<TValue> values, ChunkArray`1<KeyValuePair`2<TKey, TValue>> temp, Comparison`1<TKey> compare, int startIndex, int endIndex, JetProgress progress);
}
[IsReadOnlyAttribute]
public class JetBrains.Util.DataStructures.UserDataWrapper : ValueType {
    [CanBeNullAttribute]
public object Data;
    public UserDataWrapper(object data);
    public sealed virtual bool Equals(UserDataWrapper other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class JetBrains.Util.DefaultEnvironmentInteraction : object {
    public sealed virtual string GetEnvironmentVariable(string variable);
    public sealed virtual string GetFolderPath(SpecialFolder specialFolder, SpecialFolderOption specialFolderOption);
    public sealed virtual void SetEnvironmentVariable(string key, string value);
    public sealed virtual IDictionary GetEnvironmentVariables();
    public sealed virtual VirtualFileSystemPath GetFolderPath(SpecialFolder specialFolder);
    public sealed virtual string ExpandEnvironmentVariables(string variable);
}
public class JetBrains.Util.DefaultInteractionContextSerializer : object {
    public sealed virtual bool IsContext(string data);
    public sealed virtual string Serialize(IInteractionContext context);
    public sealed virtual IInteractionContext Deserialize(string data);
}
public class JetBrains.Util.DefaultRegistryInteraction : object {
    public sealed virtual RegistryAccess GetInProcessSpecificAccess(string key);
    public sealed virtual RegistryAccess GetInCertaintyAccess(string key, KeyAccessRights keyAccessRights);
    public sealed virtual bool KeyExists(RegistryAccess registryAccess, BackSlashSeparatedRelativePath subkey, OnError onerror);
    public sealed virtual String[] GetSubKeyNames(RegistryAccess registryAccess, BackSlashSeparatedRelativePath subkey, OnError onerror);
    public sealed virtual string GetStringValue(RegistryAccess registryAccess, BackSlashSeparatedRelativePath subkey, string dataname, OnError onerror);
    public sealed virtual Nullable`1<UInt32> GetDwordValue(RegistryAccess registryAccess, BackSlashSeparatedRelativePath subkey, string dataname, OnError onerror);
}
public class JetBrains.Util.DefaultVirtualFileSystemPathInterning : object {
    private IFileSystemPathIntern myNativePathIntern;
    public DefaultVirtualFileSystemPathInterning(IFileSystemPathIntern nativePathIntern);
    public sealed virtual VirtualFileSystemPath TryGet(string path);
    public sealed virtual VirtualFileSystemPath GetOrCreate(string path, IInteractionContext context, bool isPathAlreadyCanonical, Func`4<string, IInteractionContext, bool, VirtualFileSystemPath> createDelegate);
    public sealed virtual void Clear();
}
public class JetBrains.Util.DelegatingExceptionThrowingLogger : LoggerBase {
    public static IExceptionThrowingLogger Default;
    private ILogger myLogger;
    public string Category { get; }
    public DelegatingExceptionThrowingLogger(ILogger logger);
    private static DelegatingExceptionThrowingLogger();
    public virtual void Log(LogEvent logEvent);
    public virtual string get_Category();
    public virtual bool IsEnabled(LoggingLevel level);
    public sealed virtual void LogOrThrowException(Exception ex, ExceptionOrigin origin);
}
[IsReadOnlyAttribute]
public class JetBrains.Util.DirectoryEntryData : ValueType {
    [CompilerGeneratedAttribute]
private FileSystemPath <BaseDir>k__BackingField;
    [CompilerGeneratedAttribute]
private RelativePath <RelativePath>k__BackingField;
    public DateTime FileModificationTimeUtc;
    public DateTime FileCreationTimeUtc;
    public DateTime FileAccessTimeUtc;
    public FileAttributes Attributes;
    public ulong Length;
    public FileSystemPath BaseDir { get; }
    public RelativePath RelativePath { get; }
    public Existence Existence { get; }
    public bool IsFile { get; }
    public bool IsDirectory { get; }
    public DirectoryEntryData(FileSystemPath baseDir, RelativePath relativePath, DateTime fileModificationTimeUtc, DateTime fileCreationTimeUtc, DateTime fileAccessTimeUtc, ulong length, FileAttributes attributes);
    [CompilerGeneratedAttribute]
public sealed virtual FileSystemPath get_BaseDir();
    [CompilerGeneratedAttribute]
public sealed virtual RelativePath get_RelativePath();
    [NotNullAttribute]
public sealed virtual FileSystemPath GetAbsolutePath(FileSystemPathInternStrategy internStrategy);
    public Existence get_Existence();
    public sealed virtual bool get_IsFile();
    public sealed virtual bool get_IsDirectory();
    public virtual string ToString();
    public DirectoryEntryData WithBaseDir(FileSystemPath basedir);
}
[ExtensionAttribute]
public static class JetBrains.Util.DotNetRuntimeIdEx : object {
    private static char Delimiter;
    [ExtensionAttribute]
[NotNullAttribute]
public static string MakeDotNetRuntimeId(JetRuntimeId runtimeId);
    [ExtensionAttribute]
[NotNullAttribute]
private static StringBuilder AppendDotNetRuntimeId(StringBuilder builder, JetRuntimeId runtimeId);
    [ExtensionAttribute]
[NotNullAttribute]
internal static string ToDotNetRuntimeIdName(JetPlatform platform);
    [ExtensionAttribute]
[NotNullAttribute]
internal static string ToDotNetRuntimeIdName(JetLinuxLibC linuxLibC);
    [ExtensionAttribute]
[NotNullAttribute]
internal static string ToDotNetRuntimeIdName(JetArchitecture architecture);
}
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("Count = 0")]
public class JetBrains.Util.EmptyList`1 : object {
    [NotNullAttribute]
public static EmptyList`1<T> Instance;
    [NotNullAttribute]
public static IList`1<T> InstanceList;
    [NotNullAttribute]
public static IReadOnlyList`1<T> ReadOnly;
    [NotNullAttribute]
public static IReadOnlyCollection`1<T> Collection;
    [NotNullAttribute]
public static IEnumerable`1<T> Enumerable;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public T Item { get; public set; }
    private static EmptyList`1();
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Add(T item);
    public sealed virtual bool Remove(T item);
    public sealed virtual void Clear();
    public sealed virtual void Insert(int index, T item);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual bool Contains(T item);
    public sealed virtual int IndexOf(T item);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
}
[DebuggerDisplayAttribute("Count = 0")]
public class JetBrains.Util.EmptySet`1 : object {
    [NotNullAttribute]
public static EmptySet`1<T> Instance;
    [NotNullAttribute]
public static ISet`1<T> InstanceSet;
    [NotNullAttribute]
public static IReadOnlyCollection`1<T> Collection;
    [NotNullAttribute]
public static IEnumerable`1<T> Enumerable;
    private int System.Collections.Generic.ICollection<T>.Count { get; }
    public bool IsReadOnly { get; }
    private int System.Collections.Generic.IReadOnlyCollection<T>.Count { get; }
    private static EmptySet`1();
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual bool Remove(T item);
    private sealed virtual override int System.Collections.Generic.ICollection<T>.get_Count();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override bool System.Collections.Generic.ISet<T>.Add(T item);
    public sealed virtual void UnionWith(IEnumerable`1<T> other);
    public sealed virtual void IntersectWith(IEnumerable`1<T> other);
    public sealed virtual void ExceptWith(IEnumerable`1<T> other);
    public sealed virtual void SymmetricExceptWith(IEnumerable`1<T> other);
    public sealed virtual bool IsSubsetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsSupersetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsProperSupersetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsProperSubsetOf(IEnumerable`1<T> other);
    public sealed virtual bool Overlaps(IEnumerable`1<T> other);
    public sealed virtual bool SetEquals(IEnumerable`1<T> other);
    private sealed virtual override int System.Collections.Generic.IReadOnlyCollection<T>.get_Count();
}
[ExtensionAttribute]
public static class JetBrains.Util.EnumEx : object {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ImmutableDictionary`2<Type, ImmutableArray`1<ValueTuple`2<ulong, object>>> myMapEnumValueToName;
    private static EnumEx();
    [ExtensionAttribute]
public static bool HasAny(Enum enum, T[] flags);
    [ExtensionAttribute]
public static bool HasAll(Enum enum, T[] flags);
    [ExtensionAttribute]
public static bool Has(Enum enum, T flag);
    [ExtensionAttribute]
public static TypeCode GetUnderlyingTypeCode(Enum enum);
    public static T CoerceEnumValueSlow(T value);
    public static FrugalLocalList`1<string> GetNamesOfValue(Type type, object value);
    private static ImmutableArray`1<ValueTuple`2<ulong, object>> GetNamesForAllValues(Type type);
    public static T[] GetValues();
    public static ulong UnboxQWord(object o);
    [ExtensionAttribute]
public static Nullable`1<bool> ToBool(string stringValue);
    [ExtensionAttribute]
public static Nullable`1<TEnum> ToEnum(string stringValue);
    [ExtensionAttribute]
public static TEnum ToEnum(int intValue);
    public static int ToInt(TEnum enumValue);
    [IteratorStateMachineAttribute("JetBrains.Util.EnumEx/<GetBrowsableValues>d__14")]
[PureAttribute]
[NotNullAttribute]
public static IEnumerable`1<object> GetBrowsableValues(Type type);
}
[ExtensionAttribute]
public static class JetBrains.Util.EnvironmentVariablesUtil : object {
    private static ILogger ourLogger;
    private static EnvironmentVariablesUtil();
    [NotNullAttribute]
public static ValueTuple`3[] ParseEnvironmentVariables(string envVarsStr);
    [CanBeNullAttribute]
public static string ValidateEnvironmentVariableName(string key);
    private static bool IsEnvVarNamePart(char c);
    public static FileSystemPath TryFindInLocalPath(string fileName);
    [NotNullAttribute]
public static VirtualFileSystemPath TryFindInPath(string fileName, IInteractionContext context);
    public static void LogEnvironmentVariables(ILogger logger);
    private static bool ShouldSkipLoggingValue(string keyName);
    [ExtensionAttribute]
public static void LogEnvironmentVariables(ILogger logger, ProcessStartInfo info, string prefix);
    public static string Dump(IDictionary`2<string, string> environmentVariables);
    public static string GetEnvironmentVariablePidSpecificName(string sEnvironmentVariableName);
    public static string GetEnvironmentVariableWithRenameToPidSpecificName(string sEnvironmentVariableName);
}
[ExtensionAttribute]
public static class JetBrains.Util.ExceptionEx : object {
    public static string SensitiveDataPrefix;
    public static string AttachmentPrefix;
    [ExtensionAttribute]
public static Pair`2[] GetSensitiveData(Exception ex);
    [ExtensionAttribute]
public static TException WithSensitiveData(TException exception, IEnumerable`1<Pair`2<string, object>> sensitiveData);
    [ExtensionAttribute]
public static TException WithSensitiveData(TException exception, string name, object value);
    [ExtensionAttribute]
public static TException WithSensitiveData(TException exception, string name, Func`1<object> fGetValue);
    [ExtensionAttribute]
[ConditionalAttribute("JET_MODE_REPORT_EXCEPTIONS")]
public static void AddSensitiveData(TException exception, IEnumerable`1<Pair`2<string, object>> sensitiveData);
    [ExtensionAttribute]
[ConditionalAttribute("JET_MODE_REPORT_EXCEPTIONS")]
public static void AddSensitiveData(TException exception, string name, object value);
    [ExtensionAttribute]
[ConditionalAttribute("JET_MODE_REPORT_EXCEPTIONS")]
public static void AddSensitiveData(TException exception, string name, Func`1<object> fGetValue);
    [ExtensionAttribute]
public static TException AddDataUnsafe(TException exception, string name, object value);
    [ExtensionAttribute]
public static TException WithData(TException exception, string name, Func`1<object> FValue);
    [ExtensionAttribute]
[ConditionalAttribute("JET_MODE_REPORT_EXCEPTIONS")]
public static void AddData(TException exception, string name, Func`1<object> FValue);
    [ExtensionAttribute]
[ConditionalAttribute("JET_MODE_REPORT_EXCEPTIONS")]
[ObsoleteAttribute("Either use the conditional AddData overload with a lambda, or the AddDataUnsafe overload without a lamdba which is non-conditional.")]
public static void AddData(TException exception, string name, object value);
    [ExtensionAttribute]
[ConditionalAttribute("JET_MODE_REPORT_EXCEPTIONS")]
public static void AddDataIndirect(TException exception, Action`1<Exception> FAddData);
    private static object FlattenDataValue(object oValue);
    [ExtensionAttribute]
public static bool IsOrContains(Exception exception);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static TException SelfOrFirstInner(Exception exception);
    [ExtensionAttribute]
public static TException WithSensitiveAttachment(TException exception, FileSystemPath path);
    [ExtensionAttribute]
public static TException WithAttachment(TException exception, FileSystemPath path);
    [ExtensionAttribute]
public static IEnumerable`1<FileSystemPath> GetAttachments(Exception exception);
    [IteratorStateMachineAttribute("JetBrains.Util.ExceptionEx/<GetData>d__20")]
[ExtensionAttribute]
private static IEnumerable`1<Pair`2<string, object>> GetData(Exception exception);
}
public enum JetBrains.Util.ExceptionOrigin : Enum {
    public int value__;
    public static ExceptionOrigin Algorithmic;
    public static ExceptionOrigin Assertion;
    public static ExceptionOrigin OuterWorld;
}
[ExtensionAttribute]
public static class JetBrains.Util.ExceptionRenderer : object {
    public static string RenderedExceptionDataKey;
    public static string RenderedExceptionDataWithSensitiveInfoKey;
    public static string RenderedExceptionMessageKey;
    public static string HiddenExceptionDataNameSubstring;
    public static string RenderedExceptionSealedKey;
    public static string RootExceptionPath;
    public static bool ForceRenderSensitiveData;
    [ThreadStaticAttribute]
private static bool IsBusy;
    private static HashSet`1 modreq(System.Runtime.CompilerServices.IsVolatile) NoiseExceptionMessages;
    private static ExceptionRenderer();
    [ExtensionAttribute]
[NotNullAttribute]
public static List`1<Exception> GetAllNestedExceptions(Exception ex);
    [ExtensionAttribute]
[NotNullAttribute]
public static string RenderSensitiveData(Exception ex);
    public static IDisposable WithForceRenderSensitiveData();
    [ExtensionAttribute]
public static ExceptionText RenderException(Exception exception, IDictionary`2<object, IList`1<object>> customData, Nullable`1<bool> renderSensitiveData);
    [NotNullAttribute]
private static string AppendCustomData(IDictionary`2<object, IList`1<object>> customData, bool sensitiveData, string content);
    [PureAttribute]
[NotNullAttribute]
private static string FormatExceptionCaption(string index, string total, string typeName);
    public static string RenderOuterExceptionMessageAndData(Exception ex);
    private static List`1<ExData> CollectExDatas(Exception exception, bool renderSensitiveData);
    private static string CombinePrefix(string one, string two);
    private static string GetExceptionDataCached(Exception ex, string key, Func`1<string> compute);
    private static string PrintExDatas(IList`1<ExData> arExceptionsUnsorted);
    [NotNullAttribute]
private static IList`1<ExData> SortExceptionsForBodyPrinting(ICollection`1<ExData> exceptions);
    [NotNullAttribute]
private static IList`1<ExData> SortExceptionsForMessagePrinting(ICollection`1<ExData> exceptions);
    [NotNullAttribute]
private static string PrintExceptionMessage(ICollection`1<ExData> arExceptionsUnsorted);
    private static void RenderSingleExceptionObject(ExData exd, bool renderSensitiveData);
    private static bool IsExceptionMessageNoise(string message);
    [CompilerGeneratedAttribute]
internal static void <SortExceptionsForBodyPrinting>g__Traverse|20_1(ExData exdNode, <>c__DisplayClass20_0& );
    [CompilerGeneratedAttribute]
internal static void <SortExceptionsForMessagePrinting>g__Traverse|21_1(ExData exdNode, <>c__DisplayClass21_0& );
    [CompilerGeneratedAttribute]
internal static string <PrintExceptionMessage>g__PrepMessage|22_0(string s);
}
public class JetBrains.Util.ExceptionText : object {
    [NotNullAttribute]
public string FullText;
    [NotNullAttribute]
public string Message;
    public ExceptionText(string message, string fullText);
    public virtual string ToString();
}
public static class JetBrains.Util.ExtensionConstants : object {
    public static string Bat;
    public static string Config;
    public static string Cpl;
    public static string Exe;
    public static string Debug;
    public static string Dbg;
    public static string Dll;
    public static string Dmg;
    public static string Msi;
    public static string Ipa;
    public static string DSym;
    public static string DyLib;
    public static string Dwarf;
    public static string So;
    public static string Lib;
    public static string A;
    public static string NetModule;
    public static string WinMd;
    public static string Vsix;
    public static string Xap;
    public static string Yes;
    public static string Pdb;
    public static string Xml;
    public static string Zip;
    public static string Tar;
    public static string Gz;
    public static string Xz;
    public static string Cmd;
    public static string Sh;
    public static string Ps1;
    public static string Sit;
    public static string Sln;
    public static string Slnf;
    public static string Snap;
    public static string CSproj;
    public static string VBproj;
    public static string FSproj;
    public static string JSproj;
    public static string VCXproj;
    public static string CMake;
    public static string Nupkg;
    public static string Nuspec;
    public static string Xproj;
    public static string XprojUser;
    public static string CompressedExe;
    public static string CompressedDll;
    public static string CompressedPdb;
    public static string DepsJson;
    public static string RuntimeConfigJson;
    public static string Resources;
    public static string Resx;
    public static string Xaml;
    public static string Baml;
    public static string Json;
    public static string Md;
    public static string Txt;
    public static string SymRef;
    public static string Lock;
    public static string Htm;
    public static string Html;
    public static string Sarif;
    public static string Sha256;
    public static string Sha384;
    public static string Sha512;
    public static string Asc;
}
[ExtensionAttribute]
public static class JetBrains.Util.Extensions.StringEx : object {
    [ExtensionAttribute]
[ObsoleteAttribute("Use 'Split' extension method from 'JetBrains.Util.Extension.StringExtensions' class")]
public static StringSlicesEnumerable Split(string s, char separator);
    [ExtensionAttribute]
[ObsoleteAttribute("Use 'Split' extension method from 'JetBrains.Util.Extension.StringExtensions' class")]
public static StringSlicesEnumerable Split(string s, char separator, StringSplitOptions options);
    [ExtensionAttribute]
[ObsoleteAttribute("Use 'Split' extension method from 'JetBrains.Util.Extension.StringExtensions' class")]
public static StringSlicesEnumerable Split(string s, Char[] separator);
    [ExtensionAttribute]
[ObsoleteAttribute("Use 'Split' extension method from 'JetBrains.Util.Extension.StringExtensions' class")]
public static StringSlicesEnumerable Split(string s, Char[] separator, StringSplitOptions options);
}
public static class JetBrains.Util.FilesInUse : object {
    public static FilesInUseStatus QueryFilesInUse(FileSystemPath[] files);
    private static FilesInUseStatus ReportCommonFailure(FileSystemPath[] files, string failure);
}
public class JetBrains.Util.FileSystemCompression : object {
    public static bool CompressIfSupported(FileSystemPath pathToDirOrFile, OnError onerror);
    public static bool CompressIfSupported(Void* hFile, OnError onerror);
}
public static class JetBrains.Util.FileSystemDefinition : object {
    public static char DirectorySeparatorChar;
    public static string DirectorySeparatorString;
    public static char AltDirectorySeparatorChar;
    public static string AltDirectorySeparatorString;
    public static Char[] DirectorySeparatorCharArray;
    public static Char[] AltDirectorySeparatorCharArray;
    public static Char[] SeparatorChars;
    public static char VolumeSeparatorChar;
    public static Char[] InvalidFileNameChars;
    public static Char[] InvalidPathChars;
    public static Char[] WindowsInvalidPathChars;
    public static char PathDelimiterChar;
    public static string PathDelimiterString;
    public static StringComparison PathStringComparison;
    public static IEqualityComparer`1<string> PathStringEquality;
    public static IComparer`1<string> PathStringComparer;
    public static bool CaseSensitiveFileNames;
    public static string EnvironmentVariableNameForNoCleanup;
    private static int myIsEnvironmentVariableForNoCleanup;
    public static bool IsEnvironmentVariableForNoCleanup { get; }
    private static FileSystemDefinition();
    public static FileSystemPath[] GetRoots();
    [NotNullAttribute]
public static FileSystemPath GetTempPath();
    [NotNullAttribute]
public static FileSystemPath CreateTemporaryDirectory(FileSystemPath parent, string prefix);
    [NotNullAttribute]
public static FileSystemPath CreateTemporaryDirectory(Lifetime lifetime, FileSystemPath parent, string prefix);
    [NotNullAttribute]
public static FileSystemPath CreateTemporaryFile(FileSystemPath parent, string extensionWithDot, string prefix, Action`1<FileStream> handler);
    [NotNullAttribute]
public static FileSystemPath CreateTemporaryFile(Lifetime lifetime, FileSystemPath parent, string extensionWithDot, string prefix, Action`1<FileStream> handler);
    private static bool CreateNewDirectoryAtomic(FileSystemPath path);
    private static bool TryCreateNewFileAtomic(FileSystemPath path, Action`1<FileStream> handler);
    private static FileSystemPath CreateTempEntity(Func`1<string> randomNameGenerator, Func`2<FileSystemPath, bool> creator, Lifetime lifetime, FileSystemPath parent, string prefix, string extension);
    public static bool get_IsEnvironmentVariableForNoCleanup();
    [NotNullAttribute]
public static IPath TryParse(string path);
    [NotNullAttribute]
public static IPath Parse(string path);
    [NotNullAttribute]
public static IPath TryParseVirtualPath(string path, IInteractionContext context);
    [NotNullAttribute]
public static IPath ParseVirtualPath(string path, IInteractionContext context);
    public static string GetPathSeparator(IInteractionContext local);
}
public class JetBrains.Util.FileSystemEntryInfo : object {
    [CompilerGeneratedAttribute]
private FileSystemPath <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private FileAttributes <Attributes>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <ModificationTimeUtc>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <AccessTimeUtc>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <CreationTimeUtc>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Length>k__BackingField;
    public FileSystemPath Path { get; }
    public FileAttributes Attributes { get; }
    public DateTime ModificationTimeUtc { get; }
    public DateTime AccessTimeUtc { get; }
    public DateTime CreationTimeUtc { get; }
    public long Length { get; }
    public bool IsFile { get; }
    public bool IsDirectory { get; }
    public FileSystemEntryInfo(FileSystemPath path, FileAttributes attributes, DateTime modificationTimeUtc, DateTime accessTimeUtc, DateTime creationTimeUtc, long length);
    [CompilerGeneratedAttribute]
public sealed virtual FileSystemPath get_Path();
    [CompilerGeneratedAttribute]
public sealed virtual FileAttributes get_Attributes();
    [CompilerGeneratedAttribute]
public sealed virtual DateTime get_ModificationTimeUtc();
    [CompilerGeneratedAttribute]
public sealed virtual DateTime get_AccessTimeUtc();
    [CompilerGeneratedAttribute]
public sealed virtual DateTime get_CreationTimeUtc();
    [CompilerGeneratedAttribute]
public sealed virtual long get_Length();
    public sealed virtual bool get_IsFile();
    public sealed virtual bool get_IsDirectory();
}
public class JetBrains.Util.FileSystemEvent : ValueType {
    public JetFileSystemWatcher Watcher;
    public FileSystemEventType Type;
    public string Name;
    public string OldName;
    public string ErrorMessage;
    public VirtualFileSystemPath FullPath { get; }
    public VirtualFileSystemPath OldFullPath { get; }
    private FileSystemEvent(JetFileSystemWatcher watcher, FileSystemEventType type, string name, string oldName, string errorMessage);
    private VirtualFileSystemPath GetFullPath(string name);
    public VirtualFileSystemPath get_FullPath();
    public VirtualFileSystemPath get_OldFullPath();
    public static FileSystemEvent CreateFileChangedEvent(JetFileSystemWatcher watcher, string name);
    public static FileSystemEvent CreateFileCreatedEvent(JetFileSystemWatcher watcher, string name);
    public static FileSystemEvent CreateFileRemovedEvent(JetFileSystemWatcher watcher, string name);
    public static FileSystemEvent CreateFileRenamedEvent(JetFileSystemWatcher watcher, string name, string oldName);
    public static FileSystemEvent CreateWatcherErrorEvent(JetFileSystemWatcher watcher, string errorMessage);
    public static FileSystemEvent CreateWatcherEventsBufferOverflowEvent(JetFileSystemWatcher watcher);
    public static FileSystemEvent CreateWatchedDirectoryDeletedEvent(JetFileSystemWatcher watcher);
    public static FileSystemEvent CreateWatchedDirectoryAbortedEvent(JetFileSystemWatcher watcher);
}
public enum JetBrains.Util.FileSystemEventType : Enum {
    public int value__;
    public static FileSystemEventType None;
    public static FileSystemEventType FileChanged;
    public static FileSystemEventType FileCreated;
    public static FileSystemEventType FileRenamed;
    public static FileSystemEventType FileRemoved;
    public static FileSystemEventType WatcherError;
    public static FileSystemEventType WatcherEventsBufferOverflow;
    public static FileSystemEventType WatchedDirectoryDeleted;
    public static FileSystemEventType WatchedDirectoryAborted;
}
public abstract class JetBrains.Util.FileSystemInteraction : object {
    public abstract virtual void OverrideWriteHandler(Lifetime lifetime, Func`2<IFsWriteHandler, IFsWriteHandler> newHandlerFactory);
    public abstract virtual Existence GetExists(FileSystemPath thіs);
    public abstract virtual FileSystemEntryInfo GetInfo(FileSystemPath thіs);
    public abstract virtual DateTime GetFileModificationTimeUtc(FileSystemPath thіs);
    public abstract virtual void SetFileModificationTimeUtc(FileSystemPath thіs, DateTime time);
    public abstract virtual DateTime GetFileCreationTimeUtc(FileSystemPath thіs);
    public abstract virtual DateTime GetFileLastAccessedTimeUtc(FileSystemPath thіs);
    public abstract virtual string GetFileAccessPath(FileSystemPath thіs);
    public abstract virtual bool IsLocked(FileSystemPath thіs);
    public abstract virtual bool TryUnlock(FileSystemPath thіs);
    public abstract virtual long GetFileLength(FileSystemPath thіs);
    public abstract virtual FileAttributes GetAttributes(FileSystemPath thіs);
    public abstract virtual void SetAttributes(FileSystemPath thіs, FileAttributes fileAttributes);
    public abstract virtual FileAttributes TryGetAttributes(FileSystemPath thіs);
    public abstract virtual FileStream OpenStream(FileSystemPath thіs, FileMode fileMode, FileAccess fileAccess, FileShare fileShare, FileFlagsAndAttributes fileFlagsAndAttributes);
    public abstract virtual SafeFileHandle OpenFileHandle(FileSystemPath thіs, FileMode fileMode, FileAccess fileAccess, FileShare fileShare, FileFlagsAndAttributes fileFlagsAndAttributes);
    public abstract virtual ulong GetFileIndex(FileSystemPath thіs);
    public abstract virtual IEnumerable`1<FileSystemPath> GetDirectoryEntries(FileSystemPath thіs, string mask, Nullable`1<bool> files, FileSystemPathInternStrategy internStrategy);
    public abstract virtual void GetDirectoryEntries(FileSystemPath thіs, RelativePath subdir, string mask, PathSearchFlags flags, ICollection`1& output);
    public abstract virtual void Move(FileSystemPath thіs, FileSystemPath dst);
    public abstract virtual void MoveFile(FileSystemPath thіs, FileSystemPath dst, bool overwrite);
    public abstract virtual void CopyFile(FileSystemPath thіs, FileSystemPath dst, bool overwrite);
    public abstract virtual FileSystemPath CreateDirectory(FileSystemPath thіs);
    public abstract virtual bool TryCreateNewDirectoryAtomic(FileSystemPath thіs);
    public abstract virtual void DeleteFile(FileSystemPath thіs, Boolean& isDirectory, int nAttempts);
    public abstract virtual void DeleteDirectoryNonRecursive(FileSystemPath thіs, int nAttempts, Exception& ex);
    public abstract virtual FileSystemPath GetShortPath(FileSystemPath thіs);
    public abstract virtual FileSystemPath GetLongPath(FileSystemPath thіs);
    public abstract virtual FileSystemPath GetTempPath();
    public virtual Stream GetWriteonlyStream(FileSystemPath fileSystemPath, FileMode fileMode, FileShare fileShare);
    public virtual Stream GetReadonlyStream(FileSystemPath fileSystemPath, FileMode fileMode, FileShare fileShare);
}
[TypeConverterAttribute("JetBrains.Util.FileSystemPathConverter")]
[ValueSerializerAttribute("JetBrains.Util.FileSystemPathSerializer")]
public class JetBrains.Util.FileSystemPath : FileSystemPathBase`3<FileSystemPath, FileSystemEntryInfo, DirectoryEntryData> {
    private static FileSystemInteraction ourNativeFS;
    private int myHashCode;
    public static DateTime NonexistentFileDateTime;
    public static FileSystemPath Empty;
    [CanBeNullAttribute]
private static IFileSystemPathIntern ourIntern;
    private static Func`4<string, IInteractionContext, bool, FileSystemPath> myFactoryForInterningDelegate;
    private VirtualFileSystemPath modreq(System.Runtime.CompilerServices.IsVolatile) myCachedVirtualFileSystemPath;
    public bool IsLocked { get; }
    internal IInteractionContext Context { get; }
    internal VirtualFileSystemPath VirtualPath { get; }
    private FileSystemPath(string path, bool isPathAlreadyCanonical);
    private static FileSystemPath();
    public SafeFileHandle OpenFileHandle(FileMode fileMode, FileAccess fileAccess, FileShare fileShare, FileFlagsAndAttributes fileFlagsAndAttributes);
    public FileStream OpenStream(FileMode fileMode, FileAccess fileAccess);
    public FileStream OpenStream(FileMode fileMode, FileAccess fileAccess, FileShare fileShare);
    public FileStream OpenStream(FileMode fileMode, FileAccess fileAccess, FileShare fileShare, FileFlagsAndAttributes fileFlagsAndAttributes);
    public ulong GetFileIndex();
    public FileSystemPath GetShortPath();
    [ObsoleteAttribute("This method opens file with exclusive write privileges by default. Use OpenStream(FileMode, FileAccess, FileShare) instead.")]
public FileStream OpenStream(FileMode mode);
    public bool TryUnlock();
    public bool get_IsLocked();
    internal virtual IInteractionContext get_Context();
    public virtual FileSystemPath GetEmpty();
    protected virtual IFileSystemInteraction`3<FileSystemPath, FileSystemEntryInfo, DirectoryEntryData> GetInteraction();
    protected virtual FileSystemPath CreatePath(string path, bool isPathAlreadyCanonical, FileSystemPathInternStrategy internStrategy);
    internal virtual FileSystemPath ParsePath(string path, FileSystemPathInternStrategy internStrategy);
    internal virtual FileSystemPath CreateFromCanonicalPath(string path, FileSystemPathInternStrategy internStrategy);
    [NotNullAttribute]
public static FileSystemPath CreateByCanonicalPath(string path, FileSystemPathInternStrategy internStrategy);
    [NotNullAttribute]
[PureAttribute]
public static FileSystemPath TryParse(string path, FileSystemPathInternStrategy internStrategy);
    [NotNullAttribute]
[PureAttribute]
public static FileSystemPath Parse(string path, FileSystemPathInternStrategy internStrategy);
    [NotNullAttribute]
[PureAttribute]
public static FileSystemPath ParseRelativelyTo(string path, FileSystemPath basePathForRelativeStrings);
    private static FileSystemPath Create(string path, bool isPathAlreadyCanonical, FileSystemPathInternStrategy internStrategy);
    [ContractAnnotationAttribute("null => null")]
public static string op_Explicit(FileSystemPath path);
    [ContractAnnotationAttribute("null => null")]
public static FileSystemPath op_Explicit(string path);
    public bool Equals(VirtualFileSystemPath obj);
    protected virtual bool EqualsInner(object obj);
    public sealed virtual bool Equals(FileSystemPath other);
    protected virtual int GetHashCodeInner();
    public virtual string ToString();
    public static void AllowIntern(Lifetime lifetime, IFileSystemPathIntern intern);
    public static void ClearIntern();
    public static FileSystemPath op_Explicit(Uri uri);
    public static Uri op_Explicit(FileSystemPath path);
    internal bool TryCreateNewDirectoryAtomic();
    internal VirtualFileSystemPath get_VirtualPath();
}
public abstract class JetBrains.Util.FileSystemPathBase`3 : object {
    public static ILogger Logger;
    [NotNullAttribute]
public string FullPath;
    private String modreq(System.Runtime.CompilerServices.IsVolatile) myName;
    private String modreq(System.Runtime.CompilerServices.IsVolatile) myNameWithoutExtension;
    public string ExtensionNoDot { get; }
    public string ExtensionWithDot { get; }
    private string JetBrains.Util.IPath.FullPath { get; }
    internal IInteractionContext Context { get; }
    public bool IsAbsolute { get; }
    public bool IsEmpty { get; }
    private bool IsUnixAbsolute { get; }
    private char CurrentSeparatorChar { get; }
    public string Name { get; }
    public string NameWithoutExtension { get; }
    public bool IsValidOnCurrentOS { get; }
    private IPath JetBrains.Util.IPath.Empty { get; }
    private IPath JetBrains.Util.IPath.Parent { get; }
    [NotNullAttribute]
public TSelf Parent { get; }
    public StringSlicesEnumerable Components { get; }
    [NotNullAttribute]
public TSelf Directory { get; }
    public Existence Exists { get; }
    [CanBeNullAttribute]
public TFileInfo Info { get; }
    public bool ExistsDirectory { get; }
    public bool ExistsFile { get; }
    public DateTime FileModificationTimeUtc { get; public set; }
    public DateTime FileCreationTimeUtc { get; }
    public DateTime FileLastAccessedTimeUtc { get; }
    public string FileAccessPath { get; }
    public bool IsWsl { get; }
    public bool IsUnc { get; }
    public bool IsNotEmpty { get; }
    public bool IsHidden { get; }
    public bool IsSystem { get; }
    protected FileSystemPathBase`3(string path, bool isPathAlreadyCanonical, IInteractionContext context);
    private static FileSystemPathBase`3();
    [NotNullAttribute]
private static string GetCanonicalPath(string path, IInteractionContext context);
    public sealed virtual string get_ExtensionNoDot();
    public sealed virtual string get_ExtensionWithDot();
    private sealed virtual override string JetBrains.Util.IPath.get_FullPath();
    internal abstract virtual IInteractionContext get_Context();
    public sealed virtual bool get_IsAbsolute();
    public sealed virtual bool get_IsEmpty();
    private bool get_IsUnixAbsolute();
    private char get_CurrentSeparatorChar();
    private int GetLastSeparatorPosition();
    public sealed virtual string get_Name();
    public sealed virtual string get_NameWithoutExtension();
    internal bool IsValidOnCurrentOsInternal(IInteractionContext context);
    public sealed virtual bool get_IsValidOnCurrentOS();
    public sealed virtual Uri ToDirectoryUri();
    public sealed virtual Uri ToUri();
    private sealed virtual override IPath JetBrains.Util.IPath.TryCombine(string component);
    [NotNullAttribute]
public TSelf TryCombine(string component);
    private sealed virtual override IPath JetBrains.Util.IPath.get_Empty();
    public abstract virtual TSelf GetEmpty();
    protected abstract virtual IFileSystemInteraction`3<TSelf, TFileInfo, TDirectoryData> GetInteraction();
    private bool IsLastSeparatorInLocalRoot(int lastSeparatorPos);
    private sealed virtual override IPath JetBrains.Util.IPath.get_Parent();
    public TSelf get_Parent();
    [NotNullAttribute]
public TSelf GetParent(FileSystemPathInternStrategy internStrategy);
    protected abstract virtual TSelf CreatePath(string path, bool isPathAlreadyCanonical, FileSystemPathInternStrategy internStrategy);
    private sealed virtual override IPath JetBrains.Util.IPath.Combine(RelativePath other);
    [NotNullAttribute]
[PureAttribute]
public TSelf Combine(RelativePath other, FileSystemPathInternStrategy internStrategy);
    [NotNullAttribute]
[PureAttribute]
public TSelf Combine(string component, FileSystemPathInternStrategy internStrategy);
    [NotNullAttribute]
[PureAttribute]
public TSelf CombineWithShortName(string shortName);
    [NotNullAttribute]
[PureAttribute]
[ObsoleteAttribute("Use overloads TryMakeRelativeTo or MakeRelativeTo which return a relative path.")]
public TSelf ConvertToRelativePath(FileSystemPathBase`3<TSelf, TFileInfo, TDirectoryData> basePath, FileSystemPathInternStrategy internStrategy);
    [NotNullAttribute]
[PureAttribute]
public IPath TryMakeRelativeTo(FileSystemPathBase`3<TSelf, TFileInfo, TDirectoryData> basePath);
    [NotNullAttribute]
[PureAttribute]
public RelativePath MakeRelativeTo(FileSystemPathBase`3<TSelf, TFileInfo, TDirectoryData> basePath);
    [ObsoleteAttribute("Seems like this operation is not quite valid for an absolute path.")]
public bool IsSuffixOf(FileSystemPathBase`3<TSelf, TFileInfo, TDirectoryData> otherPath);
    public char GetDriveName();
    [NotNullAttribute]
public string GetRootDir();
    internal abstract virtual TSelf ParsePath(string path, FileSystemPathInternStrategy internStrategy);
    internal abstract virtual TSelf CreateFromCanonicalPath(string path, FileSystemPathInternStrategy internStrategy);
    private sealed virtual override IPath JetBrains.Util.IPath.Parse(string text);
    public sealed virtual StringSlicesEnumerable get_Components();
    public TSelf get_Directory();
    public Existence get_Exists();
    public TFileInfo get_Info();
    public bool get_ExistsDirectory();
    public bool get_ExistsFile();
    public DateTime get_FileModificationTimeUtc();
    public void set_FileModificationTimeUtc(DateTime value);
    public DateTime get_FileCreationTimeUtc();
    public DateTime get_FileLastAccessedTimeUtc();
    public string get_FileAccessPath();
    public StringSlice GetComputerName();
    public bool get_IsWsl();
    public bool get_IsUnc();
    public bool get_IsNotEmpty();
    [NotNullAttribute]
[PureAttribute]
[ObsoleteAttribute("You should not be combining two absolute paths. Combine with a RelativePath instead.")]
public TSelf Combine(TSelf other, FileSystemPathInternStrategy internStrategy);
    public void AssertIsAbsolute();
    public bool LogAssertIsAbsolute();
    public void LogAssertIsOSCompatible();
    public void AssertIsOSCompatible();
    [NotNullAttribute]
[PureAttribute]
public TSelf Clone();
    [NotNullAttribute]
public static TSelf op_Division(FileSystemPathBase`3<TSelf, TFileInfo, TDirectoryData> path, RelativePath other);
    [NotNullAttribute]
public static TSelf op_Division(FileSystemPathBase`3<TSelf, TFileInfo, TDirectoryData> path, string component);
    [NotNullAttribute]
public static TSelf op_Division(FileSystemPathBase`3<TSelf, TFileInfo, TDirectoryData> path, StringSlice component);
    public bool get_IsHidden();
    public bool get_IsSystem();
    public string GetSeperator();
    public virtual string ToString();
    public Stream GetWriteonlyStream(FileMode fileMode, FileShare fileShare);
    public Stream GetReadonlyStream(FileMode fileMode, FileShare fileShare);
    public static bool op_Inequality(FileSystemPathBase`3<TSelf, TFileInfo, TDirectoryData> left, FileSystemPathBase`3<TSelf, TFileInfo, TDirectoryData> right);
    public static bool op_Equality(FileSystemPathBase`3<TSelf, TFileInfo, TDirectoryData> left, FileSystemPathBase`3<TSelf, TFileInfo, TDirectoryData> right);
    public sealed virtual bool Equals(object obj);
    public sealed virtual int GetHashCode();
    protected abstract virtual int GetHashCodeInner();
    protected abstract virtual bool EqualsInner(object o);
    public TSelf CreateDirectory();
    public void DeleteFile();
    internal void DeleteFile(Boolean& isDirectory, int nAttempts);
    public void DeleteDirectoryNonRecursive(int nAttempts);
    internal void DeleteDirectoryNonRecursive(int nAttempts, Exception& ex);
    public void SetAttributes(FileAttributes fileAttributes);
    public FileAttributes GetAttributes();
    public long GetFileLength();
    public TSelf GetLongPath();
    public FileAttributes TryGetAttributes();
    public IEnumerable`1<TSelf> GetDirectoryEntries(string mask, bool files, FileSystemPathInternStrategy internStrategy);
    public IEnumerable`1<TSelf> GetDirectoryEntries(string mask, Nullable`1<bool> files, FileSystemPathInternStrategy internStrategy);
    [NotNullAttribute]
public ICollection`1<TDirectoryData> GetDirectoryEntries(string mask, PathSearchFlags flags);
    public void Move(FileSystemPathBase`3<TSelf, TFileInfo, TDirectoryData> destinationFilePath);
    public void MoveFile(FileSystemPathBase`3<TSelf, TFileInfo, TDirectoryData> destinationFilePath, bool overwrite);
    public void CopyFile(FileSystemPathBase`3<TSelf, TFileInfo, TDirectoryData> destinationFilePath, bool overwrite);
    public sealed virtual int CompareTo(FileSystemPathBase`3<TSelf, TFileInfo, TDirectoryData> other);
}
public class JetBrains.Util.FileSystemPathConverter : TypeConverterBase`1<FileSystemPath> {
}
[ExtensionAttribute]
public static class JetBrains.Util.FileSystemPathEx : object {
    public static ILogger Logger;
    private static Regex FromDataAnonymousAssembly;
    public static string MoveAsideExtWithDot;
    private static Nullable`1<LogWithLevel> Trace { get; }
    private static FileSystemPathEx();
    [IteratorStateMachineAttribute("JetBrains.Util.FileSystemPathEx/<GetParentDirectories>d__1`3")]
[ExtensionAttribute]
[NotNullAttribute]
public static IEnumerable`1<T> GetParentDirectories(FileSystemPathBase`3<T, TFile, TDir> path);
    [IteratorStateMachineAttribute("JetBrains.Util.FileSystemPathEx/<GetThisAndParentDirectories>d__2`3")]
[ExtensionAttribute]
[NotNullAttribute]
public static IEnumerable`1<T> GetThisAndParentDirectories(FileSystemPathBase`3<T, TFile, TDir> path);
    [ExtensionAttribute]
[NotNullAttribute]
public static ICollection`1<T> GetChildDirectories(FileSystemPathBase`3<T, TFile, TDir> path, string mask, PathSearchFlags flags, FileSystemPathInternStrategy internStrategy);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static ICollection`1<TDir> GetChildren(FileSystemPathBase`3<T, TFile, TDir> path, string mask, PathSearchFlags flags);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IList`1<T> GetChildFiles(FileSystemPathBase`3<T, TFile, TDir> path, string mask, PathSearchFlags flags, FileSystemPathInternStrategy internStrategy);
    [AsyncStateMachineAttribute("JetBrains.Util.FileSystemPathEx/<GetChildFilesRecursivelyAsync>d__6`3")]
[ExtensionAttribute]
[PureAttribute]
public static Task`1<ValueTuple`2<IEnumerable`1<T>, int>> GetChildFilesRecursivelyAsync(FileSystemPathBase`3<T, TFile, TDir> path, ITaskHost taskHost, Lifetime lifetime, Func`2<TDir, ValueTuple`2<bool, T>> fileFilter, OnError onError, FileSystemPathInternStrategy internStrategy, Action`1<FileSystemPathBase`3<T, TFile, TDir>> onEachDirectory, bool excludeHidden, Func`1<bool> checkForInterrupt, int degreeOfParallelism, int taskYieldIntervalMs);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IList`1<T> GetChildFiles(FileSystemPathBase`3<T, TFile, TDir> path, int maxDepth, string mask, PathSearchFlags flags, FileSystemPathInternStrategy internStrategy);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("path:null => true")]
public static bool IsNullOrEmpty(FileSystemPath path);
    [ExtensionAttribute]
[ContractAnnotationAttribute("path:null => true")]
public static bool IsNullOrEmpty(RelativePath path);
    [ExtensionAttribute]
[ContractAnnotationAttribute("path:null => true")]
public static bool IsNullOrEmpty(IPath path);
    [ExtensionAttribute]
[ContractAnnotationAttribute("path:null => false")]
public static bool IsRelativeToDriveRoot(IPath path);
    [ExtensionAttribute]
public static RelativePath ConvertToRelative(IPath path);
    [ExtensionAttribute]
public static DeferQuotedObject QuoteIfNeeded(FileSystemPathBase`3<T, TInfo, TDirectoryData> path);
    [ExtensionAttribute]
public static DeferQuotedObject QuoteIfNeeded(RelativePath path);
    [ExtensionAttribute]
public static DeferQuotedObject QuoteIfNeeded(BackSlashSeparatedRelativePath path);
    [NotNullAttribute]
[PureAttribute]
private static string NormalizeSeparators(string path, SeparatorStyle separatorStyle);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static string NormalizeSeparators(VirtualFileSystemPath path, SeparatorStyle separatorStyle);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static string NormalizeSeparators(FileSystemPath path, SeparatorStyle separatorStyle);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static string NormalizeSeparators(RelativePath path, SeparatorStyle separatorStyle);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static string PathWithCurrentPlatformSeparators(RelativePath path);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static string PathWithCurrentPlatformSeparators(FileSystemPath path);
    [NotNullAttribute]
[PureAttribute]
public static string PathWithCurrentPlatformSeparators(string path);
    [ExtensionAttribute]
[NotNullAttribute]
public static FileSystemPath TryGetCaseSensitivePath(FileSystemPath path);
    [ExtensionAttribute]
[NotNullAttribute]
public static FileSystemPath ToFileSystemPath(string s);
    [ExtensionAttribute]
[NotNullAttribute]
public static FileSystemPath ToFileSystemPathNoCache(string s);
    [ExtensionAttribute]
[NotNullAttribute]
public static FileSystemPath ToFileSystemPath(Uri uri);
    [ExtensionAttribute]
[NotNullAttribute]
public static RelativePath ToRelativePath(Uri uri);
    [ExtensionAttribute]
[NotNullAttribute]
public static IPath ToRelativeOrAbsolutePath(Uri uri);
    [ExtensionAttribute]
public static T AddSuffix(FileSystemPathBase`3<T, TFile, TDir> path, string suffix);
    [ExtensionAttribute]
public static T ToAbsolutePath(FileSystemPathBase`3<T, TFile, TDir> this, FileSystemPathBase`3<T, TFile, TDir> pathBaseForRelatives);
    [ExtensionAttribute]
public static T ToAbsolutePath(FileSystemPathBase`3<T, TFile, TDir> this, FileSystemPathBase`3<T, TFile, TDir> pathBaseForRelatives, FileSystemPathInternStrategy internStrategy);
    [ExtensionAttribute]
[NotNullAttribute]
public static FileSystemPath GetPath(Assembly this);
    [ExtensionAttribute]
[NotNullAttribute]
public static FileSystemPath TryGetPath(Assembly this);
    [ExtensionAttribute]
public static void CopyDirectory(FileSystemPathBase`3<T, TFile, TDir> sourceDirectoryPath, FileSystemPathBase`3<T, TFile, TDir> destinationDirectoryPath, bool overwrite, ICollection`1<T> excludes);
    [ExtensionAttribute]
public static void Copy(FileSystemPathBase`3<T, TFile, TDir> source, FileSystemPathBase`3<T, TFile, TDir> destination, bool overwrite, ICollection`1<T> excludes);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static FileSystemPath ToFileSystemPath(SpecialFolder specialFolder);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static VirtualFileSystemPath ToVirtualFileSystemPath(SpecialFolder specialFolder, IInteractionContext context);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static FileSystemPath Combine(SpecialFolder specialFolder, RelativePath other);
    public static bool WriteIfDirtyWithMoveAside(FileSystemPath path, string text, Encoding encoding);
    public static bool WriteIfDirtyWithMoveAside(FileSystemPath path, Byte[] bytes);
    public static bool WriteIfDirtyWithMoveAside(FileSystemPath path, Stream stream);
    public static bool WriteIfDirtyWithMoveAside(FileSystemPath path, Func`2<Lifetime, Stream> streamer);
    [ExtensionAttribute]
public static bool HasWritePermissionOnDir(FileSystemPath fsp);
    [ExtensionAttribute]
public static void EnsureWritable(FileSystemPathBase`3<T, TFile, TDir> fsp);
    [ExtensionAttribute]
public static void Delete(FileSystemPathBase`3<T, TFile, TDir> path, int nAttempts);
    [ExtensionAttribute]
public static void Delete(FileSystemPathBase`3<T, TFile, TDir> path);
    [ExtensionAttribute]
[ObsoleteAttribute("Call just Delete, it will do for all.")]
public static void DeleteDirectory(FileSystemPathBase`3<T, TFile, TDir> path, int nRetryCount);
    private static void IOOperationWithRetry(Action action);
    [ExtensionAttribute]
public static void DeleteChildren(FileSystemPathBase`3<T, TFile, TDir> path);
    [ExtensionAttribute]
public static bool CleanUpChildren(FileSystemPath path, ICollection`1<FileSystemPath> excludes);
    [ExtensionAttribute]
public static bool CleanUpDirectory(FileSystemPath path, ICollection`1<FileSystemPath> excludes);
    [ExtensionAttribute]
public static bool IsSuffixOf(RelativePath thіs, IPath otherPath);
    [ExtensionAttribute]
public static bool IsPrefixOf(FileSystemPathBase`3<T, TFile, TDir> thіs, FileSystemPathBase`3<T, TFile, TDir> otherPath);
    private static bool IsLocalRoot(FileSystemPathBase`3<T, TFile, TDir> fsp);
    [ExtensionAttribute]
public static bool IsPrefixOf(IPath thіs, IPath otherPath);
    [ExtensionAttribute]
public static bool IsPrefixOf(RelativePath thіs, RelativePath otherPath);
    [ExtensionAttribute]
public static bool IsPrefixOf(BackSlashSeparatedRelativePath thіs, BackSlashSeparatedRelativePath otherPath);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
[ObsoleteAttribute("Removing the first component makes a path relative, so use RemoveFirstComponent2.")]
public static T RemoveFirstComponent(FileSystemPathBase`3<T, TFile, TDir> thіs);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static RelativePath RemoveFirstComponent2(FileSystemPathBase`3<T, TFile, TDir> thіs);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static RelativePath RemoveFirstComponent(RelativePath thіs);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static T RemovePrefix(FileSystemPathBase`3<T, TFile, TDir> thіs, FileSystemPathBase`3<T, TFile, TDir> prefix);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static RelativePath RemovePrefix(RelativePath thіs, RelativePath prefix);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static T RemoveSuffix(FileSystemPathBase`3<T, TFile, TDir> path, RelativePath suffix);
    [ExtensionAttribute]
public static bool StartsWith(FileSystemPathBase`3<T, TFile, TDir> thіs, FileSystemPathBase`3<T, TFile, TDir> prefix);
    [ExtensionAttribute]
public static bool StartsWith(RelativePath thіs, RelativePath prefix);
    [ExtensionAttribute]
public static bool StartsWith(BackSlashSeparatedRelativePath thіs, BackSlashSeparatedRelativePath prefix);
    [ExtensionAttribute]
public static bool EndsWith(IPath thіs, RelativePath suffix);
    [ExtensionAttribute]
public static FileSystemPath WithTryValidate(FileSystemPath thіs);
    [ExtensionAttribute]
public static FileSystemPath WithValidate(FileSystemPath thіs);
    [ExtensionAttribute]
public static RelativePath WithTryValidate(RelativePath thіs);
    [ExtensionAttribute]
public static RelativePath WithValidate(RelativePath thіs);
    [NotNullAttribute]
private static string AppendTrailingPathSeparatorIfNeed(string path, string pathSeparator);
    [ExtensionAttribute]
[NotNullAttribute]
public static string FileAccessPathWithTrailingPathSeparator(FileSystemPath path);
    [ExtensionAttribute]
[NotNullAttribute]
public static string FullPathWithTrailingPathSeparator(FileSystemPathBase`3<T, TFile, TDir> path);
    [ExtensionAttribute]
[NotNullAttribute]
public static string FullPathWithTrailingPathSeparator(BackSlashSeparatedRelativePath path);
    [ExtensionAttribute]
[NotNullAttribute]
public static T ExistedFile(FileSystemPathBase`3<T, TFile, TDir> path, string message);
    [ExtensionAttribute]
[NotNullAttribute]
public static T ExistedDirectory(FileSystemPathBase`3<T, TFile, TDir> path, string message);
    [ExtensionAttribute]
[ContractAnnotationAttribute("path:null => false")]
public static bool IsValidAndExistFile(FileSystemPathBase`3<T, TFile, TDir> path, Func`2<FileSystemPathBase`3<T, TFile, TDir>, bool> existFile);
    [ExtensionAttribute]
[ContractAnnotationAttribute("path:null => false")]
public static bool IsValidAndExistDirectory(FileSystemPathBase`3<T, TFile, TDir> path, Func`2<FileSystemPathBase`3<T, TFile, TDir>, bool> existDirectory);
    [ExtensionAttribute]
public static RelativePath Combine(RelativePath path, StringSlice component);
    [ExtensionAttribute]
public static FileSystemPath Combine(FileSystemPath path, StringSlice component);
    [ExtensionAttribute]
public static bool IsUnixExecutable(FileSystemPath path);
    private static Nullable`1<LogWithLevel> get_Trace();
    [ExtensionAttribute]
public static void DeleteWithMoveAside(FileSystemPath path);
    [NotNullAttribute]
public static string GetMoveAsideName(string name, string timestamp);
    public static bool IsMovedAsideFile(FileSystemPath path);
    private static void DeleteDirectoryWithMoveAside(FileSystemPath dirToDelete);
    public static void DeleteFileWithMoveAside(FileSystemPath path, FileSystemPath dirMoveAsideDestination);
    private static void DoMoveAside(FileSystemPath path, FileSystemPath dirMoveAsideDestination);
    [NotNullAttribute]
public static T GetDeepestCommonParent(FileSystemPathBase`3<T, TFile, TDir> first, FileSystemPathBase`3<T, TFile, TDir> second);
    [CompilerGeneratedAttribute]
internal static void <DeleteWithMoveAside>g__CleanupOldMovedAside|88_0(string name, PathSearchFlags flags, <>c__DisplayClass88_0& );
    [CompilerGeneratedAttribute]
internal static void <DeleteDirectoryWithMoveAside>g__DeleteFolderOrMoveFilesAside|91_0(FileSystemPath folder, <>c__DisplayClass91_0& );
}
[ExtensionAttribute]
public static class JetBrains.Util.FileSystemPathExtensions : object {
    [ExtensionAttribute]
public static VirtualFileSystemPath ToVirtualFileSystemPath(FileSystemPath path);
}
public class JetBrains.Util.FileSystemPathInternByConcurrentDictionary : FileSystemPathInternByConcurrentDictionaryBase`3<FileSystemPath, FileSystemEntryInfo, DirectoryEntryData> {
    public FileSystemPathInternByConcurrentDictionary(FileSystemPathInternParameters absoluteParameters, FileSystemPathInternParameters relativeParameters);
    protected FileSystemPathInternByConcurrentDictionary(FileSystemPathInternParameters absoluteParameters, FileSystemPathInternParameters relativeParameters, PathContainerCreator<FileSystemPath, FileSystemEntryInfo, DirectoryEntryData> creator);
}
public class JetBrains.Util.FileSystemPathInternByConcurrentDictionaryBase`3 : object {
    [NotNullAttribute]
private ILogger myLogger;
    protected PathContainer<T, TFile, TDir> myAbsolutePaths;
    protected PathContainer<T, TFile, TDir> myRelativePaths;
    private ConcurrentDictionary`2<string, int> myCallNumbers;
    public FileSystemPathInternByConcurrentDictionaryBase`3(FileSystemPathInternParameters absoluteParameters, FileSystemPathInternParameters relativeParameters);
    protected FileSystemPathInternByConcurrentDictionaryBase`3(FileSystemPathInternParameters absoluteParameters, FileSystemPathInternParameters relativeParameters, PathContainerCreator<T, TFile, TDir> creator);
    public sealed virtual T GetOrCreate(string path, IInteractionContext context, bool isPathAlreadyCanonical, Func`4<string, IInteractionContext, bool, T> createDelegate);
    public sealed virtual T TryGet(string path);
    public sealed virtual void Clear();
    public void Dump(TextWriter writer);
    private void IncrementCallNumbers(string path);
}
public class JetBrains.Util.FileSystemPathInternByDictionaryWithDoubleCheckLocking : object {
    private IDictionary`2<string, FileSystemPath> myDictionary;
    public sealed virtual FileSystemPath GetOrCreate(string path, IInteractionContext context, bool isPathAlreadyCanonical, Func`4<string, IInteractionContext, bool, FileSystemPath> createDelegate);
    public sealed virtual FileSystemPath TryGet(string path);
    public sealed virtual void Clear();
}
public class JetBrains.Util.FileSystemPathInternByDirectMappedCache : object {
    private DirectMappedCache`2<string, FileSystemPath> myIntern;
    public FileSystemPathInternByDirectMappedCache(int maxEntries, ILogger logger);
    public sealed virtual void Clear();
    public sealed virtual FileSystemPath GetOrCreate(string path, IInteractionContext context, bool isPathAlreadyCanonical, Func`4<string, IInteractionContext, bool, FileSystemPath> createDelegate);
    public sealed virtual FileSystemPath TryGet(string path);
}
[IsReadOnlyAttribute]
public class JetBrains.Util.FileSystemPathInternParameters : ValueType {
    public static int DEFAULT_PATH_LENGTH_LIMIT;
    public static int DEFAULT_ABSOLUTE_PATH_COUNT_LIMIT;
    public static int DEFAULT_RELATIVE_PATH_COUNT_LIMIT;
    public static int DEFAULT_INITIAL_POOL_SIZE;
    [CompilerGeneratedAttribute]
private int <PathLengthLimit>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PathCountLimit>k__BackingField;
    [CompilerGeneratedAttribute]
private static FileSystemPathInternParameters <DefaultAbsolute>k__BackingField;
    [CompilerGeneratedAttribute]
private static FileSystemPathInternParameters <DefaultRelative>k__BackingField;
    public int PathLengthLimit { get; }
    public int PathCountLimit { get; }
    public static FileSystemPathInternParameters DefaultAbsolute { get; }
    public static FileSystemPathInternParameters DefaultRelative { get; }
    public FileSystemPathInternParameters(int pathLengthLimit, int pathCountLimit);
    private static FileSystemPathInternParameters();
    [CompilerGeneratedAttribute]
public int get_PathLengthLimit();
    [CompilerGeneratedAttribute]
public int get_PathCountLimit();
    [CompilerGeneratedAttribute]
public static FileSystemPathInternParameters get_DefaultAbsolute();
    [CompilerGeneratedAttribute]
public static FileSystemPathInternParameters get_DefaultRelative();
}
public enum JetBrains.Util.FileSystemPathInternStrategy : Enum {
    public int value__;
    public static FileSystemPathInternStrategy INTERN;
    public static FileSystemPathInternStrategy TRY_GET_INTERNED_BUT_DO_NOT_INTERN;
    public static FileSystemPathInternStrategy DO_NOT_INTERN;
}
public static class JetBrains.Util.FileSystemPathInternUtil : object {
    public static IFileSystemPathIntern CreateDefaultIntern(FileSystemPathInternParameters absoluteParameters, FileSystemPathInternParameters relativeParameters);
}
[ExtensionAttribute]
public static class JetBrains.Util.FileSystemPathOpenEx : object {
    [ExtensionAttribute]
public static Stream OpenFileForAppend(FileSystemPathBase`3<T, TFile, TDir> path);
    [ExtensionAttribute]
public static Stream OpenFileForAppendDenyWrite(FileSystemPathBase`3<T, TFile, TDir> path);
    [ExtensionAttribute]
[ObsoleteAttribute("This is not Exclusive because it still allows Read, use *DenyWrite for this.")]
public static Stream OpenFileForAppendExclusive(FileSystemPathBase`3<T, TFile, TDir> path);
    [ExtensionAttribute]
public static Stream OpenFileForReading(FileSystemPathBase`3<T, TFile, TDir> path);
    [ExtensionAttribute]
public static Stream OpenFileForReadingDenyWrite(FileSystemPathBase`3<T, TFile, TDir> path);
    [ExtensionAttribute]
[ObsoleteAttribute("This is not Exclusive because it still allows Read, use *DenyWrite for this.")]
public static Stream OpenFileForReadingExclusive(FileSystemPath path);
    [ExtensionAttribute]
public static Stream OpenFileForWriting(FileSystemPathBase`3<T, TFile, TDir> path);
    [ExtensionAttribute]
public static Stream OpenFileForWritingDenyWrite(FileSystemPathBase`3<T, TFile, TDir> path);
    [ExtensionAttribute]
public static Stream OpenFileForWritingExclusive(FileSystemPathBase`3<T, TFile, TDir> path);
    [ExtensionAttribute]
[NotNullAttribute]
public static FileStream OpenStreamWithWaitingOnLock(FileSystemPath path, FileMode filemode, FileAccess fileaccess, FileShare fileshare, Nullable`1<TimeSpan> timeToWait);
    [AsyncStateMachineAttribute("JetBrains.Util.FileSystemPathOpenEx/<ExecuteIoOperationWithRetryAsync>d__10`1")]
[NotNullAttribute]
public static Task`1<TResult> ExecuteIoOperationWithRetryAsync(Lifetime lifetime, Nullable`1<TimeSpan> timeToWait, ITaskHost tasker, Func`1<TResult> FTry);
    [ExtensionAttribute]
[NotNullAttribute]
public static Task`1<FileStream> OpenStreamWithWaitingOnLockAsync(FileSystemPath path, Lifetime lifetime, FileMode filemode, FileAccess fileaccess, FileShare fileshare, Nullable`1<TimeSpan> timeToWait, ITaskHost tasker);
    [ExtensionAttribute]
public static Byte[] ReadAllBytes(FileSystemPathBase`3<T, TFile, TDir> file);
    [ExtensionAttribute]
public static ImmutableArray`1<byte> ReadAllBytesImmutable(FileSystemPath file);
    [ExtensionAttribute]
[ObsoleteAttribute("Use ReadAllText2. This method has inconsistent treatment of encodings in automatic mode, see ReadAllText2 for details.")]
public static string ReadAllText(FileSystemPathBase`3<T, TFile, TDir> file, Encoding encoding);
    [ExtensionAttribute]
public static TextAndEncoding ReadAllText2(FileSystemPathBase`3<T, TFile, TDir> file, Encoding encoding);
    [ExtensionAttribute]
[NotNullAttribute]
public static string ReadAllTextDeterministic(FileSystemPathBase`3<T, TFile, TDir> file);
    [ExtensionAttribute]
public static void ReadBinaryStream(FileSystemPathBase`3<T, TFile, TDir> path, Action`1<BinaryReader> λRead);
    [ExtensionAttribute]
public static T ReadBinaryStream(FileSystemPathBase`3<TF, TFile, TDir> path, Func`2<BinaryReader, T> λRead);
    [ExtensionAttribute]
public static void ReadStream(FileSystemPathBase`3<T, TFile, TDir> path, Action`1<Stream> λRead);
    [ExtensionAttribute]
public static T ReadStream(FileSystemPathBase`3<TF, TFile, TDir> path, Func`2<Stream, T> λRead);
    [ExtensionAttribute]
public static void ReadStreamDenyWrite(FileSystemPathBase`3<T, TFile, TDir> path, Action`1<Stream> λRead);
    [ExtensionAttribute]
[ObsoleteAttribute("This is not Exclusive because it still allows Read, use *DenyWrite for this.")]
public static void ReadStreamExclusive(FileSystemPathBase`3<T, TFile, TDir> path, Action`1<Stream> λRead);
    [ExtensionAttribute]
public static void ReadTextStream(FileSystemPathBase`3<T, TFile, TDir> path, Action`1<StreamReader> λRead, Encoding encoding);
    [ExtensionAttribute]
public static T ReadTextStream(FileSystemPathBase`3<TF, TFile, TDir> path, Func`2<StreamReader, T> λRead, Encoding encoding);
    [ExtensionAttribute]
public static void WriteAllBytes(FileSystemPathBase`3<T, TFile, TDir> file, Byte[] bytes);
    [ExtensionAttribute]
public static void WriteAllText(FileSystemPathBase`3<T, TFile, TDir> file, string content, Encoding encoding);
    [ExtensionAttribute]
[ObsoleteAttribute("This method actually bears the DenyWrite semantic, which does not follow from its name. Use the *DenyWrite version explicitly.")]
public static void WriteBinaryStream(FileSystemPath path, Action`1<BinaryWriter> λWrite);
    [ExtensionAttribute]
public static void WriteBinaryStreamDenyWrite(FileSystemPath path, Action`1<BinaryWriter> λWrite);
    [ExtensionAttribute]
public static void WriteStream(FileSystemPathBase`3<T, TFile, TDir> path, Action`1<Stream> λWrite);
    [ExtensionAttribute]
public static void WriteStreamDenyWrite(FileSystemPathBase`3<T, TFile, TDir> path, Action`1<Stream> λWrite);
    [ExtensionAttribute]
public static void WriteStreamExclusive(FileSystemPathBase`3<T, TFile, TDir> path, Action`1<Stream> λWrite);
    [ExtensionAttribute]
[ObsoleteAttribute("This method actually bears the DenyWrite semantic, which does not follow from its name. Use the *DenyWrite version explicitly.")]
public static void WriteTextStream(FileSystemPath path, Action`1<StreamWriter> λWrite);
    [ExtensionAttribute]
[ObsoleteAttribute("This method actually bears the DenyWrite semantic, which does not follow from its name. Use the *DenyWrite version explicitly.")]
public static void WriteTextStream(FileSystemPathBase`3<T, TFile, TDir> path, Encoding encoding, Action`1<StreamWriter> λWrite);
    [ExtensionAttribute]
public static void WriteTextStreamDenyWrite(FileSystemPathBase`3<T, TFile, TDir> path, Action`1<StreamWriter> λWrite);
    [ExtensionAttribute]
public static void WriteTextStreamDenyWrite(FileSystemPathBase`3<T, TFile, TDir> path, Encoding encoding, Action`1<StreamWriter> λWrite);
    [AsyncStateMachineAttribute("JetBrains.Util.FileSystemPathOpenEx/<WriteTextStreamDenyWriteAsync>d__36`3")]
[ExtensionAttribute]
public static Task WriteTextStreamDenyWriteAsync(FileSystemPathBase`3<T, TFile, TDir> path, Encoding encoding, Func`2<StreamWriter, Task> λWrite);
    private static void EnsureFileDirectory(FileSystemPathBase`3<T, TFile, TDir> path);
}
public static class JetBrains.Util.FileSystemPathParser : object {
    public static char DOT;
    public static string LongPathPrefix;
    public static string LongUncPathPrefix;
    private static MyPair InvalidPair;
    private static FileSystemPathParser();
    public static bool CanBeProvenNormalizedFast(string path, IInteractionContext context, bool unrestrictedRelativePath);
    [NotNullAttribute]
public static string Normalize(string path, IInteractionContext context, bool unrestrictedRelativePath);
    public static bool IsPathAbsolute(string path, IInteractionContext context, bool unrestrictedRelativeMode);
    public static bool IsPathRelativeToDriveRoot(string path, IInteractionContext context, bool unrestrictedRelativeMode);
    [CanBeNullAttribute]
public static string TryConvertToRelativePath(string pathToConvert, string basePath, bool isAbsolutePath, char currentSeparator);
}
public class JetBrains.Util.FileSystemPathSerializer : ValueSerializerBase`1<FileSystemPath> {
}
public static class JetBrains.Util.FileSystemUtil : object {
    public static bool DeleteDir(FileSystemPathBase`3<T, TFile, TDir> path);
    public static void CopyFolders(FileSystemPath srcFolder, FileSystemPath dstFolder);
    [NotNullAttribute]
public static FileSystemPath GetSystemDirectory();
    [NotNullAttribute]
public static FileSystemPath GetCurrentDirectory();
    public static IDisposable SetCurrentDirectory(FileSystemPath path);
    public static void SetCurrentDirectory(Lifetime lifetime, FileSystemPath path);
    [NotNullAttribute]
public static FileSystemPath GetDirectoryNameOfFileAbove(FileSystemPath pathStartingPoint, string sMarkerFileName);
    [CanBeNullAttribute]
public static T TryGetDirectoryNameOfFileAbove(FileSystemPathBase`3<T, TFile, TDir> pathStartingPoint, string sMarkerFileName);
    [NotNullAttribute]
public static T GetDirectoryNameOfItemAbove(FileSystemPathBase`3<T, TFile, TDir> pathStartingPoint, RelativePath markerPath);
    [CanBeNullAttribute]
public static T TryGetDirectoryNameOfItemAbove(FileSystemPathBase`3<T, TFile, TDir> pathStartingPoint, RelativePath markerPath);
    [CanBeNullAttribute]
private static T GetPathOnDiskWithCorrectCaseRec(FileSystemPathBase`3<T, TFile, TDir> current, IEnumerable`1<StringSlice> pathComponents);
    [CanBeNullAttribute]
public static T GetPathOnDiskWithCorrectCase(FileSystemPathBase`3<T, TFile, TDir> path);
    [NotNullAttribute]
public static VirtualFileSystemPath GetFinalPathName(VirtualFileSystemPath path, bool isDirectory);
    [NotNullAttribute]
public static FileSystemPath GetFinalPathName(FileSystemPath path, bool isDirectory);
}
public class JetBrains.Util.FirstArgumentResult : object {
    [NotNullAttribute]
public string AnotherArguments;
    [NotNullAttribute]
public string FirstArgument;
    public FirstArgumentResult(string firstArgument, string anotherArguments);
}
public class JetBrains.Util.FrugalLocalHashSet`1 : ValueType {
    private T mySingleElement;
    private JetHashSet`1<T> myHashSet;
    private static T NULL;
    public bool IsEmpty { get; }
    public int Count { get; }
    [CanBeNullAttribute]
public T SingleItem { get; }
    [IsReadOnlyAttribute]
public bool get_IsEmpty();
    [IsReadOnlyAttribute]
[PureAttribute]
public Enumerator<T> GetEnumerator();
    public bool Add(T item);
    public void AddRange(IEnumerable`1<T> enumerable);
    public void Clear();
    [IsReadOnlyAttribute]
public bool Contains(T item);
    public bool Remove(T item);
    [IsReadOnlyAttribute]
public int get_Count();
    [IsReadOnlyAttribute]
public T get_SingleItem();
    [IsReadOnlyAttribute]
[NotNullAttribute]
[PureAttribute]
public T[] ToArray();
    [IsReadOnlyAttribute]
[NotNullAttribute]
[PureAttribute]
public IReadOnlyCollection`1<T> ReadOnlyCollection();
    [IsReadOnlyAttribute]
[PureAttribute]
[CanBeNullAttribute]
public T FirstOrDefault();
    [IsReadOnlyAttribute]
[PureAttribute]
public T First();
    public void UnionWith(IEnumerable`1<T> other);
    public void UnionWith(FrugalLocalHashSet`1& other);
    [IsReadOnlyAttribute]
[PureAttribute]
public bool SetEquals(FrugalLocalHashSet`1& other);
    [IsReadOnlyAttribute]
[NotNullAttribute]
[PureAttribute]
public List`1<T> ToList();
    [CompilerGeneratedAttribute]
internal static bool <SetEquals>g__IsSingleItemHashSet|21_0(JetHashSet`1<T> set, T item);
}
public class JetBrains.Util.Graph.ComplexNode`1 : object {
    private JetHashSet`1<T> myCompositeNodes;
    public IEnumerable`1<T> Constituents { get; }
    public bool IsComposite { get; }
    public T SingleNode { get; }
    public object Element { get; }
    public ComplexNode`1(JetHashSet`1<T> compositeNodes);
    public IEnumerable`1<T> get_Constituents();
    public bool get_IsComposite();
    public T get_SingleNode();
    public object get_Element();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class JetBrains.Util.Graph.DirectedGraph`1 : object {
    private OneToSetMap`2<T, T> myOutgoing;
    private OneToSetMap`2<T, T> myIncoming;
    private JetHashSet`1<T> myNodes;
    private ICollection`1<T> myNodesCollection;
    private IEnumerable`1<T> JetBrains.Util.Graph.IDirectedGraph<T>.Nodes { get; }
    [NotNullAttribute]
public ICollection`1<T> Nodes { get; }
    public DirectedGraph`1(IEqualityComparer`1<T> nodeEqualityComparer);
    public bool AddDependency(T from, T to);
    public virtual void RemoveDependency(T from, T to);
    public bool HasDependency(T from, T to);
    public virtual void RemoveAllIncoming(T to);
    public void RemoveAllIncoming(T to, Predicate`1<T> checkFrom);
    private sealed virtual override IEnumerable`1<T> JetBrains.Util.Graph.IDirectedGraph<T>.get_Nodes();
    public ICollection`1<T> get_Nodes();
    public sealed virtual IEnumerable`1<T> Outgoing(T node);
    public sealed virtual IEnumerable`1<T> Incoming(T node);
    [NotNullAttribute]
public IEnumerable`1<T> TryGetOutgoing(T node);
    [NotNullAttribute]
public IEnumerable`1<T> TryGetIncoming(T node);
    protected virtual bool RemoveNode(T node);
    protected virtual void Clear();
}
public class JetBrains.Util.Graph.DirectedGraphVirtualized`1 : object {
    private Func`2<TNode, IEnumerable`1<TNode>> myIncoming;
    private IEnumerable`1<TNode> myNodes;
    private Func`2<TNode, IEnumerable`1<TNode>> myOutgoing;
    private IEnumerable`1<TNode> JetBrains.Util.Graph.IDirectedGraph<TNode>.Nodes { get; }
    public DirectedGraphVirtualized`1(IEnumerable`1<TNode> allnodes, Func`2<TNode, IEnumerable`1<TNode>> incoming, Func`2<TNode, IEnumerable`1<TNode>> outgoing);
    private sealed virtual override IEnumerable`1<TNode> JetBrains.Util.Graph.IDirectedGraph<TNode>.Incoming(TNode node);
    private sealed virtual override IEnumerable`1<TNode> JetBrains.Util.Graph.IDirectedGraph<TNode>.Outgoing(TNode node);
    private sealed virtual override IEnumerable`1<TNode> JetBrains.Util.Graph.IDirectedGraph<TNode>.get_Nodes();
}
public class JetBrains.Util.Graph.FactorizedGraph`1 : ValueType {
    private IDirectedGraph`1<T> myOriginal;
    private JetHashSet`1<ComplexNode`1<T>> myComplexNodes;
    private Dictionary`2<T, ComplexNode`1<T>> myNodesFactorization;
    public IEnumerable`1<ComplexNode`1<T>> Nodes { get; }
    public FactorizedGraph`1(IDirectedGraph`1<T> original, JetHashSet`1<ComplexNode`1<T>> newNodes);
    public bool IsValid();
    public sealed virtual IEnumerable`1<ComplexNode`1<T>> get_Nodes();
    [IteratorStateMachineAttribute("JetBrains.Util.Graph.FactorizedGraph`1/<Outgoing>d__7")]
public sealed virtual IEnumerable`1<ComplexNode`1<T>> Outgoing(ComplexNode`1<T> complexNode);
    [IteratorStateMachineAttribute("JetBrains.Util.Graph.FactorizedGraph`1/<Incoming>d__8")]
public sealed virtual IEnumerable`1<ComplexNode`1<T>> Incoming(ComplexNode`1<T> complexNode);
}
[ExtensionAttribute]
public static class JetBrains.Util.Graph.GraphAlgorithms : object {
    public static void DoNothing(T node);
    [ExtensionAttribute]
public static void DepthFirstSearch(IDirectedGraph`1<T> graph, DoBeforeProcessing`1<T> preProcessing, DoAfterProcessing`1<T> postProcessing);
    public static void DFS(IDirectedGraph`1<T> graph, T current, JetHashSet`1<T> processed, DoBeforeProcessing`1<T> preProcessing, DoAfterProcessing`1<T> postProcessing);
    [ExtensionAttribute]
public static void DepthFirstSearch(IDirectedGraph`1<TNode> graph, TNode start, PassingOnWayDownDelegate`1<TNode> FEnteringOnWayDown, Action`1<TNode> FPassingOnWayDownSimple, Action`1<TNode> FPassingOnWayUp);
    public static void DepthFirstSearch(IEnumerable`1<TNode> rootcollection, Func`2<TNode, IEnumerable`1<TNode>> FGetLinkedNodes, PassingOnWayDownDelegate`1<TNode> FEnteringOnWayDown, Action`1<TNode> FPassingOnWayDownSimple, Action`1<TNode> FPassingOnWayUp);
    [ExtensionAttribute]
public static IEnumerable`1<T> TopologicalSortedOrder(IDirectedGraph`1<T> graph);
    [ExtensionAttribute]
public static IDirectedGraph`1<T> Transpose(IDirectedGraph`1<T> graph);
    [ExtensionAttribute]
public static IDirectedGraph`1<ComplexNode`1<T>> StronglyConnectedComponentsGraph(IDirectedGraph`1<T> graph);
    [NotNullAttribute]
public static IList`1<TNode> FindShortestPath(IDirectedGraph`1<TNode> graph, TNode from, TNode to, Func`3<TNode, TNode, double> FWeightEdge);
}
public interface JetBrains.Util.Graph.IDirectedGraph`1 {
    [NotNullAttribute]
public IEnumerable`1<T> Nodes { get; }
    public abstract virtual IEnumerable`1<T> get_Nodes();
    [NotNullAttribute]
public abstract virtual IEnumerable`1<T> Outgoing(T node);
    [NotNullAttribute]
public abstract virtual IEnumerable`1<T> Incoming(T node);
}
public class JetBrains.Util.Graph.TransposedGraph`1 : ValueType {
    private IDirectedGraph`1<T> myOriginal;
    public IEnumerable`1<T> Nodes { get; }
    public TransposedGraph`1(IDirectedGraph`1<T> original);
    public sealed virtual IEnumerable`1<T> get_Nodes();
    public sealed virtual IEnumerable`1<T> Outgoing(T node);
    public sealed virtual IEnumerable`1<T> Incoming(T node);
}
[ExtensionAttribute]
public static class JetBrains.Util.Graphs.BiparititeGraphAlgorithms : object {
    private static object ourNilVertex;
    private static BiparititeGraphAlgorithms();
    [ExtensionAttribute]
public static ICollection`1<Pair`2<T1, T2>> MaximalMatching(IBipartiteGraph`2<T1, T2> graph);
    private static bool BFS(IBipartiteGraph`2<T1, T2> graph, Dictionary`2<object, object> pairs, Dictionary`2<object, int> distance);
    private static bool DFS(IBipartiteGraph`2<T1, T2> graph, Dictionary`2<object, object> pairs, Dictionary`2<object, int> distance, object vertex);
    private static IEnumerable`1<object> GetConnectedVertices(IBipartiteGraph`2<T1, T2> graph, object vertex);
}
public class JetBrains.Util.Graphs.BipartiteGraph`2 : object {
    private JetHashSet`1<T1> myFirstPartVertices;
    private JetHashSet`1<T2> mySecondPartVertices;
    private OneToSetMap`2<T1, T2> myEdges1;
    private OneToSetMap`2<T2, T1> myEdges2;
    public IEnumerable`1<T1> FirstPartVertices { get; }
    public IEnumerable`1<T2> SecondPartVertices { get; }
    public void AddEdge(T1 from, T2 to);
    public void RemoveEdge(T1 from, T2 to);
    public void RemoveVertice(T1 vertice);
    public void RemoveVertice(T2 vertice);
    public sealed virtual IEnumerable`1<T1> get_FirstPartVertices();
    public sealed virtual IEnumerable`1<T2> get_SecondPartVertices();
    public sealed virtual IEnumerable`1<T2> ConnectedVertices(T1 vertice);
    public sealed virtual IEnumerable`1<T1> ConnectedVertices(T2 vertice);
    public bool IsEmpty();
}
public interface JetBrains.Util.Graphs.IBipartiteGraph`2 {
    [NotNullAttribute]
public IEnumerable`1<T1> FirstPartVertices { get; }
    [NotNullAttribute]
public IEnumerable`1<T2> SecondPartVertices { get; }
    public abstract virtual IEnumerable`1<T1> get_FirstPartVertices();
    public abstract virtual IEnumerable`1<T2> get_SecondPartVertices();
    [NotNullAttribute]
public abstract virtual IEnumerable`1<T2> ConnectedVertices(T1 vertice);
    [NotNullAttribute]
public abstract virtual IEnumerable`1<T1> ConnectedVertices(T2 vertice);
}
public class JetBrains.Util.GraphvizWriter : object {
    [NotNullAttribute]
private TextWriter myBackend;
    private GraphMode myMode;
    public GraphvizWriter(TextWriter backend, GraphMode mode, string name);
    public void WriteProperty(string name, string value);
    public void WriteProperty(string name, double value);
    public void WriteNode(string nodeName, string style);
    public void WriteEdge(string source, string dest, string style);
    public sealed virtual void Dispose();
}
[ExtensionAttribute]
public static class JetBrains.Util.GuidExtensions : object {
    private static int HexsToChars(Char* guidChars, int offset, int a, int b);
    private static char HexToChar(int a);
    public static Guid TryParseGuid(string value);
    [ExtensionAttribute]
public static string ToUpperString(Guid guid);
    [ExtensionAttribute]
public static string ToUpperCurlyString(Guid guid);
    public static Guid CreateRdProtocolJavaUuidFromString(string stringValue);
}
public class JetBrains.Util.Hash : ValueType {
    public static Hash ZERO;
    public static Hash INVALID;
    private int myValue;
    public int Value { get; }
    public Hash(int value);
    private static Hash();
    public static Hash Create(string val);
    public int get_Value();
    public void PutByte(byte b);
    public void PutChar(char c);
    public void PutString(string s);
    public void PutStringFromStringBuilder(StringBuilder sb);
    public void PutInt(int i);
    public void PutBool(bool b);
    public void PutHash(Hash hash);
    public void Finish();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public virtual string ToString();
    public static Hash op_Addition(Hash hash1, Hash hash2);
    public static Hash op_Subtraction(Hash hash1, Hash hash2);
    public static Hash op_UnaryNegation(Hash hash);
    public static bool op_Equality(Hash hash1, Hash hash2);
    public static bool op_Inequality(Hash hash1, Hash hash2);
    public static Hash CommutativeMix(IEnumerable`1<string> values);
    public static Hash CommutativeMix(IEnumerable`1<Hash> values);
    [PureAttribute]
public void WriteTo(UnsafeWriter writer);
    public static Hash ReadFrom(UnsafeReader reader);
    public static void WriteArray(Hash[] hashes, BinaryWriter writer);
    public static Hash[] ReadArray(BinaryReader reader);
    public sealed virtual bool Equals(Hash other);
    [PureAttribute]
public static int Combine(int newKey, int currentKey);
    [PureAttribute]
public static int Combine(int newKey1, int newKey2, int currentKey);
    [PureAttribute]
public static int CombineValues(IEnumerable`1<T> sequence);
}
public class JetBrains.Util.HashPair : ValueType {
    public Hash Old;
    public Hash New;
    public HashPair(Hash old, Hash new);
    public virtual string ToString();
}
public interface JetBrains.Util.ICloneable`1 {
    [NotNullAttribute]
public abstract virtual T Clone();
}
public interface JetBrains.Util.IConfigurableLogEventListener {
    [CanBeNullAttribute]
[ItemNotNullAttribute]
public IFilter[] Filters { get; public set; }
    public ILayout Layout { get; public set; }
    public abstract virtual IFilter[] get_Filters();
    public abstract virtual void set_Filters(IFilter[] value);
    public abstract virtual ILayout get_Layout();
    public abstract virtual void set_Layout(ILayout value);
}
public static class JetBrains.Util.IdentityFunc`1 : object {
    public static Func`2<T, T> Instance;
    public static Converter`2<T, T> Converter;
    private static IdentityFunc`1();
}
public static class JetBrains.Util.IdentityFunc`2 : object {
    public static Func`2<T1, T2> Instance;
    public static Converter`2<T1, T2> Converter;
    private static IdentityFunc`2();
}
public interface JetBrains.Util.IDirectoryEntryData`1 {
    public T BaseDir { get; }
    public RelativePath RelativePath { get; }
    public bool IsDirectory { get; }
    public bool IsFile { get; }
    public abstract virtual T get_BaseDir();
    public abstract virtual RelativePath get_RelativePath();
    public abstract virtual bool get_IsDirectory();
    public abstract virtual bool get_IsFile();
    [NotNullAttribute]
public abstract virtual T GetAbsolutePath(FileSystemPathInternStrategy internStrategy);
}
public interface JetBrains.Util.IEnvironmentInteraction {
    public abstract virtual string GetEnvironmentVariable(string variable);
    public abstract virtual string GetFolderPath(SpecialFolder specialFolder, SpecialFolderOption specialFolderOption);
    public abstract virtual void SetEnvironmentVariable(string key, string value);
    public abstract virtual IDictionary GetEnvironmentVariables();
    public abstract virtual VirtualFileSystemPath GetFolderPath(SpecialFolder specialFolder);
    public abstract virtual string ExpandEnvironmentVariables(string variable);
}
public interface JetBrains.Util.IExceptionThrowingLogger {
    public abstract virtual void LogOrThrowException(Exception ex, ExceptionOrigin origin);
}
public interface JetBrains.Util.IExecutionInteraction {
    public abstract virtual IExternalProcess Start(ProcessStartInfo processStartInfo);
    public abstract virtual IExternalProcess Create(ProcessStartInfo processStartInfo, bool enableRaisingEvents);
}
public interface JetBrains.Util.IExternalProcess {
    public bool HasExited { get; }
    public int Id { get; }
    public int ExitCode { get; }
    public abstract virtual bool get_HasExited();
    public abstract virtual int get_Id();
    public abstract virtual void Kill();
    public abstract virtual bool WaitForExit(int timeout);
    public abstract virtual void WaitForExit();
    public abstract virtual int get_ExitCode();
    public abstract virtual void SubscribeProcessingOutput(Action`1<string> stdOutProcessor);
    public abstract virtual void SubscribeProcessingErrorOutput(Action`1<string> stdErrProcessor);
    public abstract virtual void StartProcessingOutput();
    public abstract virtual void StartProcessingErrorOutput();
    public abstract virtual void Start();
    public abstract virtual void AddExitListener(Action a);
    public abstract virtual void CancelOutputRead();
    public abstract virtual void CancelErrorRead();
}
public interface JetBrains.Util.IFileInfo`1 {
    public T Path { get; }
    public FileAttributes Attributes { get; }
    public DateTime ModificationTimeUtc { get; }
    public DateTime AccessTimeUtc { get; }
    public DateTime CreationTimeUtc { get; }
    public long Length { get; }
    public bool IsFile { get; }
    public bool IsDirectory { get; }
    public abstract virtual T get_Path();
    public abstract virtual FileAttributes get_Attributes();
    public abstract virtual DateTime get_ModificationTimeUtc();
    public abstract virtual DateTime get_AccessTimeUtc();
    public abstract virtual DateTime get_CreationTimeUtc();
    public abstract virtual long get_Length();
    public abstract virtual bool get_IsFile();
    public abstract virtual bool get_IsDirectory();
}
public interface JetBrains.Util.IFileSystemInteraction`3 {
    public abstract virtual Existence GetExists(T path);
    public abstract virtual Stream GetWriteonlyStream(T path, FileMode fileMode, FileShare fileShare);
    public abstract virtual Stream GetReadonlyStream(T path, FileMode fileMode, FileShare fileShare);
    public abstract virtual DateTime GetFileModificationTimeUtc(T path);
    public abstract virtual void SetFileModificationTimeUtc(T path, DateTime value);
    public abstract virtual DateTime GetFileCreationTimeUtc(T path);
    public abstract virtual DateTime GetFileLastAccessedTimeUtc(T path);
    public abstract virtual FileAttributes GetAttributes(T path);
    public abstract virtual FileAttributes TryGetAttributes(T path);
    public abstract virtual long GetFileLength(T thіs);
    [NotNullAttribute]
public abstract virtual IEnumerable`1<T> GetDirectoryEntries(T path, string mask, Nullable`1<bool> files, FileSystemPathInternStrategy internStrategy);
    public abstract virtual void GetDirectoryEntries(T path, RelativePath subdir, string mask, PathSearchFlags flags, ICollection`1& output);
    public abstract virtual void DeleteFile(T path, Boolean& isDirectory, int nAttempts);
    public abstract virtual void DeleteDirectoryNonRecursive(T path, int retryCount, Exception& exception);
    [NotNullAttribute]
public abstract virtual T CreateDirectory(T path);
    [CanBeNullAttribute]
public abstract virtual TFileInfo GetInfo(T path);
    public abstract virtual void SetAttributes(T path, FileAttributes fileAttributes);
    public abstract virtual void CopyFile(T path, T destinationFilePath, bool overwrite);
    [NotNullAttribute]
public abstract virtual T GetTempPath();
    public abstract virtual void Move(T virtualFileSystemPath, T destinationFilePath);
    public abstract virtual void MoveFile(T thіs, T dst, bool overwrite);
    [NotNullAttribute]
public abstract virtual T GetLongPath(T virtualFileSystemPath);
    public abstract virtual string GetFileAccessPath(T fileSystemPathBase);
}
public interface JetBrains.Util.IFileSystemPathBaseIntern`3 {
    [CanBeNullAttribute]
public abstract virtual T TryGet(string path);
    [NotNullAttribute]
public abstract virtual T GetOrCreate(string path, IInteractionContext context, bool isPathAlreadyCanonical, Func`4<string, IInteractionContext, bool, T> createDelegate);
    public abstract virtual void Clear();
}
public interface JetBrains.Util.IFileSystemPathIntern {
}
public interface JetBrains.Util.IFsWriteHandler {
    [NotNullAttribute]
public abstract virtual FileStream OpenStream(FileSystemPath it, FileMode fileMode, FileAccess fileAccess, FileShare fileShare, FileFlagsAndAttributes fileFlagsAndAttributes);
    public abstract virtual void DeleteDirectoryNonRecursive(FileSystemPath it, int nAttempts, Exception& ex);
    public abstract virtual FileSystemPath CreateDirectory(FileSystemPath it);
    public abstract virtual bool TryCreateNewDirectoryAtomic(FileSystemPath it);
    public abstract virtual void Move(FileSystemPath it, FileSystemPath dst);
    public abstract virtual void MoveFile(FileSystemPath it, FileSystemPath dst, bool overwrite);
    public abstract virtual void CopyFile(FileSystemPath it, FileSystemPath dst, bool overwrite);
    public abstract virtual void SetAttributes(FileSystemPath it, FileAttributes fileAttributes);
    public abstract virtual void SetFileModificationTimeUtc(FileSystemPath it, DateTime t);
    public abstract virtual void DeleteFile(FileSystemPath it, Boolean& isDirectory, int nAttempts);
}
public interface JetBrains.Util.IInteractionContext {
    public IVirtualFileSystemInteraction VirtualFileSystemInteraction { get; }
    public IRegistryInteraction RegistryInteraction { get; }
    public IEnvironmentInteraction EnvironmentInteraction { get; }
    public JetPlatform Platform { get; }
    public bool IsWindowsContext { get; }
    public string ContextId { get; }
    public IVirtualFileSystemPathIntern CurrentIntern { get; }
    public IPlatformApi PlatformApi { get; }
    public IExecutionInteraction ExecutionInteraction { get; }
    public abstract virtual IVirtualFileSystemInteraction get_VirtualFileSystemInteraction();
    public abstract virtual IRegistryInteraction get_RegistryInteraction();
    public abstract virtual IEnvironmentInteraction get_EnvironmentInteraction();
    public abstract virtual JetPlatform get_Platform();
    public abstract virtual bool get_IsWindowsContext();
    public abstract virtual string get_ContextId();
    public abstract virtual void AllowIntern(Lifetime lifetime, IVirtualFileSystemPathIntern intern);
    public abstract virtual IVirtualFileSystemPathIntern get_CurrentIntern();
    public abstract virtual void ClearIntern();
    public abstract virtual IPlatformApi get_PlatformApi();
    public abstract virtual IExecutionInteraction get_ExecutionInteraction();
}
public interface JetBrains.Util.IInteractionContextSerializer {
    public abstract virtual bool IsContext(string data);
    public abstract virtual string Serialize(IInteractionContext context);
    public abstract virtual IInteractionContext Deserialize(string data);
}
public interface JetBrains.Util.ILogEventListener {
    public abstract virtual void OnLogEvent(LogEvent logEvent);
}
public interface JetBrains.Util.ILogger {
    public abstract virtual void Log(LogEvent logEvent);
}
[ExtensionAttribute]
[LocalizableAttribute("False")]
public static class JetBrains.Util.ILoggerEx : object {
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void LogBracket(ILogger thіs, Lifetime lifetime, LoggingLevel level, string message);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void LogBracket(ILogger thіs, Lifetime lifetime, LoggingLevel level, string message, Object[] args);
    [ExtensionAttribute]
public static void LogBracket(ILogger thіs, Lifetime lifetime, LoggingLevel level, Pair`2<string, string> openingclosing);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
[MustUseReturnValueAttribute]
public static LocalDisposable`1<UsingLogBracketContext> UsingLogBracket(ILogger thіs, LoggingLevel level, string message, Object[] args);
    public static LocalDisposable`1<UsingLogBracketContext> UsingLogBracketSlow(ILogger logger, LoggingLevel level, string message, Object[] args);
    [ExtensionAttribute]
public static ILogger GetSublogger(ILogger this, string subcategory);
    [ExtensionAttribute]
public static void LogExceptionSilently(ILogger thіs, Exception ex);
    [ExtensionAttribute]
public static IExceptionThrowingLogger ToExThrower(ILogger logger);
    [ExtensionAttribute]
public static void LogAssertion(ILogger thіs, Exception ex);
    [ExtensionAttribute]
public static void LogAssertion(ILogger thіs, string message);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void LogAssertion(ILogger this, string message, T1 t1);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void LogAssertion(ILogger this, string message, T1 t1, T2 t2);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void LogAssertion(ILogger this, string message, T1 t1, T2 t2, T3 t3);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void LogAssertion(ILogger this, string message, T1 t1, T2 t2, T3 t3, T4 t4);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void LogAssertion(ILogger this, string message, T1 t1, T2 t2, T3 t3, T4 t4, T5 t5);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void LogAssertion(ILogger this, string message, Object[] args);
    [ExtensionAttribute]
public static void LogOuterDataException(ILogger thіs, Exception ex, string comment);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static void Catch(ILogger thіs, Action F, ExceptionOrigin origin);
    [AsyncStateMachineAttribute("JetBrains.Util.ILoggerEx/<CatchAsync>d__19")]
[ExtensionAttribute]
[DebuggerStepThroughAttribute]
[HandleProcessCorruptedStateExceptionsAttribute]
public static Task CatchAsync(ILogger thіs, Func`1<Task> F, ExceptionOrigin origin);
    [AsyncStateMachineAttribute("JetBrains.Util.ILoggerEx/<CatchAsync>d__20`1")]
[ExtensionAttribute]
[DebuggerStepThroughAttribute]
[HandleProcessCorruptedStateExceptionsAttribute]
public static Task`1<TValue> CatchAsync(ILogger thіs, Func`1<Task`1<TValue>> F, ExceptionOrigin origin);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
[HandleProcessCorruptedStateExceptionsAttribute]
public static void Catch(ILogger thіs, Action F, ExceptionOrigin origin, LoggingLevel loggingLevel);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static TValue Catch(ILogger thіs, Func`1<TValue> F, ExceptionOrigin origin);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
[ObsoleteAttribute("Use CatchAsync")]
public static Task Catch(ILogger thіs, Func`1<Task> F, ExceptionOrigin origin);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
[ObsoleteAttribute("Use CatchAsync")]
public static Task`1<TValue> Catch(ILogger thіs, Func`1<Task`1<TValue>> F, ExceptionOrigin origin);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
[HandleProcessCorruptedStateExceptionsAttribute]
public static TValue Catch(ILogger thіs, Func`1<TValue> F, ExceptionOrigin origin, LoggingLevel loggingLevel);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
[HandleProcessCorruptedStateExceptionsAttribute]
public static Nullable`1<TValue> CatchNullable(ILogger thіs, Func`1<TValue> F, ExceptionOrigin origin);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static void CatchAsAlgorithmError(ILogger thіs, Action F);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static TValue CatchAsAlgorithmError(ILogger thіs, Func`1<TValue> F);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static void CatchAsOuterDataError(ILogger thіs, Action F);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static TValue CatchAsOuterDataError(ILogger thіs, Func`1<TValue> F);
    [ExtensionAttribute]
public static bool IsTraceEnabled(ILogger this);
    [ExtensionAttribute]
public static bool IsVerboseEnabled(ILogger this);
    [ExtensionAttribute]
public static bool IsInfoEnabled(ILogger this);
    [ExtensionAttribute]
public static bool IsWarnEnabled(ILogger this);
    [ExtensionAttribute]
public static bool IsErrorEnabled(ILogger this);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static ILogger WhenInfo(ILogger logger);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static ILogger WhenWarn(ILogger logger);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static ILogger WhenError(ILogger logger);
    [ExtensionAttribute]
public static void Error(ILogger logger, JetLogErrorInterpolatedStringHandler& messageHandler);
    [ExtensionAttribute]
public static void Error(ILogger logger, Exception exception, ExceptionOrigin origin, JetLogErrorInterpolatedStringHandler& messageHandler);
    [ExtensionAttribute]
public static void Error(ILogger this, Exception exception, ExceptionOrigin origin, string comment);
    [ExtensionAttribute]
public static void ErrorWithSensitiveData(ILogger this, string message, Pair`2[] sensitiveData);
    [ExtensionAttribute]
public static void Error(ILogger this, string message);
    [ExtensionAttribute]
public static void Error(ILogger this, Exception ex, string message);
    [ExtensionAttribute]
public static void Error(ILogger logger, Exception exception, JetLogErrorInterpolatedStringHandler& messageHandler);
    [ExtensionAttribute]
public static void ErrorOuterWorld(ILogger logger, JetLogErrorInterpolatedStringHandler& messageHandler);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void ErrorOuterWorld(ILogger logger, string message);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void ErrorOuterWorld(ILogger logger, string message, T1 t1);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void ErrorOuterWorld(ILogger logger, string message, T1 t1, T2 t2);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void Error(ILogger this, string message, T1 t1);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void Error(ILogger this, string message, T1 t1, T2 t2);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void Error(ILogger this, string message, T1 t1, T2 t2, T3 t3);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void Error(ILogger this, string message, T1 t1, T2 t2, T3 t3, T4 t4);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void Error(ILogger this, string message, T1 t1, T2 t2, T3 t3, T4 t4, T5 t5);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void Error(ILogger this, string message, Object[] args);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void Error(ILogger this, Exception ex, string message, T1 t1);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void Error(ILogger this, Exception ex, string message, T1 t1, T2 t2);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void Error(ILogger this, Exception ex, string message, T1 t1, T2 t2, T3 t3);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void Error(ILogger this, Exception ex, string message, T1 t1, T2 t2, T3 t3, T4 t4);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void Error(ILogger this, Exception ex, string message, T1 t1, T2 t2, T3 t3, T4 t4, T5 t5);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void Error(ILogger this, Exception ex, string message, Object[] args);
    [ExtensionAttribute]
public static void ErrorIfNotCanceled(ILogger it, Exception ex, string message);
    [ExtensionAttribute]
public static void ErrorThrowCanceled(ILogger it, Exception ex, string message);
    [ExtensionAttribute]
public static void Warn(ILogger logger, JetLogWarnInterpolatedStringHandler& messageHandler);
    [ExtensionAttribute]
public static void Warn(ILogger logger, Exception exception, ExceptionOrigin origin, JetLogWarnInterpolatedStringHandler& messageHandler);
    [ExtensionAttribute]
public static void Warn(ILogger this, Exception exception, ExceptionOrigin origin, string comment);
    [ExtensionAttribute]
public static void Warn(ILogger this, string message);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void Warn(ILogger this, string message, T1 t1);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void Warn(ILogger this, string message, T1 t1, T2 t2);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void Warn(ILogger this, string message, T1 t1, T2 t2, T3 t3);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void Warn(ILogger this, string message, T1 t1, T2 t2, T3 t3, T4 t4);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void Warn(ILogger this, string message, Object[] args);
    [ExtensionAttribute]
public static void Info(ILogger logger, JetLogInfoInterpolatedStringHandler& messageHandler);
    [ExtensionAttribute]
public static void Info(ILogger this, string message);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void Info(ILogger this, string message, Object[] parameters);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void Info(ILogger this, string message, T1 t1);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void Info(ILogger this, string message, T1 t1, T2 t2);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void Info(ILogger this, string message, T1 t1, T2 t2, T3 t3);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void Info(ILogger this, string message, T1 t1, T2 t2, T3 t3, T4 t4);
    [ExtensionAttribute]
public static void Verbose(ILogger logger, JetLogVerboseInterpolatedStringHandler& messageHandler);
    [ExtensionAttribute]
public static void Verbose(ILogger logger, Exception exception, ExceptionOrigin origin, JetLogVerboseInterpolatedStringHandler& messageHandler);
    [ExtensionAttribute]
public static void Verbose(ILogger this, Exception exception, ExceptionOrigin origin, string comment);
    [ExtensionAttribute]
public static void Verbose(ILogger this, string message);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void Verbose(ILogger this, string message, T1 t1);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void Verbose(ILogger this, string message, T1 t1, T2 t2);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void Verbose(ILogger this, string message, T1 t1, T2 t2, T3 t3);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void Verbose(ILogger this, string message, T1 t1, T2 t2, T3 t3, T4 t4);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void Verbose(ILogger this, string message, T1 t1, T2 t2, T3 t3, T4 t4, T5 t5);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void Verbose(ILogger this, string message, T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void Verbose(ILogger this, string message, Object[] args);
    [ExtensionAttribute]
public static void Trace(ILogger this, Exception exception, ExceptionOrigin origin, string comment);
    [ExtensionAttribute]
public static void Trace(ILogger logger, Exception exception, ExceptionOrigin origin, JetLogTraceInterpolatedStringHandler& messageHandler);
    [ExtensionAttribute]
public static void Trace(ILogger logger, Exception exception, JetLogTraceInterpolatedStringHandler& messageHandler);
    [ExtensionAttribute]
public static void Trace(ILogger this, string message);
    [ExtensionAttribute]
public static void Trace(ILogger logger, JetLogTraceInterpolatedStringHandler& messageHandler);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void Trace(ILogger this, string message, T1 t1);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void Trace(ILogger this, string message, T1 t1, T2 t2);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void Trace(ILogger this, string message, T1 t1, T2 t2, T3 t3);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void Trace(ILogger this, string message, T1 t1, T2 t2, T3 t3, T4 t4);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void Trace(ILogger this, string message, T1 t1, T2 t2, T3 t3, T4 t4, T5 t5);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void Trace(ILogger this, string message, T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void Trace(ILogger this, string message, T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void Trace(ILogger this, string message, T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8);
    [ExtensionAttribute]
public static void LogException(ILogger this, Exception exception);
    [ExtensionAttribute]
public static void LogException(ILogger this, LoggingLevel level, Exception exception, ExceptionOrigin exceptionOrigin, string comment);
    [ExtensionAttribute]
public static void LogMessage(ILogger this, LoggingLevel level, string message);
    [ExtensionAttribute]
public static void LogMessageWithSensitiveData(ILogger this, LoggingLevel level, string message, Pair`2[] sensitiveData);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void LogMessage(ILogger this, LoggingLevel level, string message, T1 t1);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void LogMessage(ILogger this, LoggingLevel level, string message, T1 t1, T2 t2);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void LogMessage(ILogger this, LoggingLevel level, string message, T1 t1, T2 t2, T3 t3);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void LogMessage(ILogger this, LoggingLevel level, string message, T1 t1, T2 t2, T3 t3, T4 t4);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void LogMessage(ILogger this, LoggingLevel level, string message, T1 t1, T2 t2, T3 t3, T4 t4, T5 t5);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void LogMessage(ILogger this, LoggingLevel level, string message, T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void LogMessage(ILogger this, LoggingLevel level, string message, Object[] args);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
[HandleProcessCorruptedStateExceptionsAttribute]
public static void CatchSilent(ILogger thіs, Action action);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
[CanBeNullAttribute]
[HandleProcessCorruptedStateExceptionsAttribute]
public static TValue CatchSilent(ILogger thіs, Func`1<TValue> F);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
[HandleProcessCorruptedStateExceptionsAttribute]
public static void CatchIgnore(ILogger thіs, Action action);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
[CanBeNullAttribute]
[HandleProcessCorruptedStateExceptionsAttribute]
public static TValue CatchIgnore(ILogger thіs, Func`1<TValue> F);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static void DropException(ILogger thіs, Exception ex);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static bool LogFailedHResult(int hresult, string message);
    [ExtensionAttribute]
public static bool LogFailedHResult(HResults hresult, string message);
}
public static class JetBrains.Util.InteractionContext : object {
    public static IInteractionContext Local;
    public static IInteractionContextSerializer Serializer;
    private static IInteractionContext ourSolutionContext;
    public static IInteractionContext SolutionContext { get; public set; }
    private static InteractionContext();
    public static IInteractionContext get_SolutionContext();
    public static void set_SolutionContext(IInteractionContext value);
}
[ExtensionAttribute]
public static class JetBrains.Util.InteractionContextExtensions : object {
    [ExtensionAttribute]
public static bool IsLocal(IInteractionContext context);
}
[ExtensionAttribute]
public static class JetBrains.Util.Interop.RegistryEx : object {
    private static KeyAccessRights KEY_32;
    private static KeyAccessRights KEY_64;
    private static RegistryEx();
    [ExtensionAttribute]
public static RegistryHiveAccess InCertainty(RegistryKey keyBase, KeyAccessRights keyArchitectureFlag);
    [ExtensionAttribute]
public static RegistryHiveAccess InProcessSpecific(RegistryKey keyBase);
    [ExtensionAttribute]
public static RegistryHiveAccess InSystemNative(RegistryKey keyBase);
    [ExtensionAttribute]
public static RegistryHiveAccess InWin32(RegistryKey keyBase);
    public static Nullable`1<RegistryHiveAccess> LoadAppHive(Lifetime lifetime, FileSystemPath file, ILogger logger, LoadExclusiveness exclusiveness);
    public static Nullable`1<RegistryHiveAccess> LoadOrReuseAppHive(Lifetime lifetime, FileSystemPath file, ILogger logger);
    private static Void* LoadOrReuseAppHiveCore(Lifetime lifetime, FileSystemPath file, ILogger logger);
    private static Void* LoadAppHiveCore(Lifetime lifetime, FileSystemPath file, ILogger logger, LoadExclusiveness exclusiveness, int nAttempts);
    [NotNullAttribute]
private static Type FindShtType();
    [NotNullAttribute]
private static object CreateSrhInst(Type srhType, IntPtr hKey);
    [NotNullAttribute]
private static string GetHiveName(Void* hkeyRoot);
    private static Void* GetRootHKey(RegistryKey keyBase, bool isCustomRootKey, OnError onerror);
    private static T WithOpenHKey(RegistryKey keyBase, bool isCustomRootKey, BackSlashSeparatedRelativePath subkey, KeyAccessRights accessRights, bool notFoundAsError, OnError onerror, Func`3<IntPtr, string, T> action);
    private static T WithCreateHKey(RegistryKey keyBase, bool isCustomRootKey, BackSlashSeparatedRelativePath subkey, KeyAccessRights accessRights, OnError onerror, Func`3<IntPtr, string, T> action);
}
public class JetBrains.Util.InvalidPathException : Exception {
    public InvalidPathException(string path);
    [StringFormatMethodAttribute("format")]
public InvalidPathException(string format, Object[] args);
    protected InvalidPathException(SerializationInfo info, StreamingContext context);
}
public interface JetBrains.Util.IOneToManyMap`3 {
    public ICollection`1<TKey> Keys { get; }
    public abstract virtual TCollection GetValuesSafe(TKey key);
    public abstract virtual void Add(TKey key, TValue value);
    public abstract virtual bool Remove(TKey key, TValue value);
    public abstract virtual ICollection`1<TKey> get_Keys();
}
[ValueSerializerAttribute("JetBrains.Util.IPathValueSerializer")]
public interface JetBrains.Util.IPath {
    [NotNullAttribute]
public IPath Empty { get; }
    [NotNullAttribute]
public string ExtensionNoDot { get; }
    [NotNullAttribute]
public string ExtensionWithDot { get; }
    [NotNullAttribute]
public string FullPath { get; }
    public bool IsAbsolute { get; }
    public bool IsEmpty { get; }
    [NotNullAttribute]
public string Name { get; }
    [NotNullAttribute]
public string NameWithoutExtension { get; }
    public bool IsValidOnCurrentOS { get; }
    [NotNullAttribute]
public IPath Parent { get; }
    public StringSlicesEnumerable Components { get; }
    public abstract virtual IPath get_Empty();
    public abstract virtual string get_ExtensionNoDot();
    public abstract virtual string get_ExtensionWithDot();
    public abstract virtual string get_FullPath();
    public abstract virtual bool get_IsAbsolute();
    public abstract virtual bool get_IsEmpty();
    public abstract virtual string get_Name();
    public abstract virtual string get_NameWithoutExtension();
    public abstract virtual bool get_IsValidOnCurrentOS();
    public abstract virtual IPath get_Parent();
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IPath Combine(RelativePath other);
    [NotNullAttribute]
public abstract virtual IPath Parse(string text);
    [NotNullAttribute]
public abstract virtual Uri ToDirectoryUri();
    [NotNullAttribute]
public abstract virtual Uri ToUri();
    [NotNullAttribute]
public abstract virtual IPath TryCombine(string component);
    public abstract virtual StringSlicesEnumerable get_Components();
}
[ExtensionAttribute]
public static class JetBrains.Util.IPathEx : object {
    [ExtensionAttribute]
[NotNullAttribute]
[ObsoleteAttribute("Use MakeAbsoluteBasedOn.")]
public static FileSystemPath AsAbsolute(IPath thіs, FileSystemPath pathBaseForRelative);
    [ExtensionAttribute]
[NotNullAttribute]
public static T MakeAbsoluteBasedOn(IPath thіs, FileSystemPathBase`3<T, TFile, TDir> pathBaseForRelative);
    [NotNullAttribute]
public static IPath AddSuffix(IPath path, string suffix);
    [ExtensionAttribute]
[NotNullAttribute]
public static RelativePath AddSuffix(RelativePath path, string suffix);
    [NotNullAttribute]
private static string ChangeExtensionInt(IPath path, string newExtensionNormalized);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static T ChangeExtension(FileSystemPathBase`3<T, TFile, TDir> path, string newExtension, FileSystemPathInternStrategy internStrategy);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
private static T ChangeExtensionInternal(FileSystemPathBase`3<T, TFile, TDir> path, string newExtension, FileSystemPathInternStrategy internStrategy);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static RelativePath ChangeExtension(RelativePath path, string newExtension);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static FileSystemPath AsAbsolute(IPath thіs);
    [ExtensionAttribute]
[NotNullAttribute]
public static FileSystemPath AssertAbsolute(IPath thіs);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static RelativePath AsRelative(IPath thіs);
    [ExtensionAttribute]
[NotNullAttribute]
public static RelativePath AssertRelative(IPath thіs);
    [ExtensionAttribute]
[NotNullAttribute]
public static TPath TryGetTopmostPathWithName(TPath path, string name);
    [ExtensionAttribute]
[NotNullAttribute]
public static TPath TryGetBottommostPathWithName(TPath path, string name);
    private static TPath CreateByCanonicalPath(TPath context, string canonicalPath);
}
public class JetBrains.Util.IPathValueSerializer : ValueSerializerBase`1<IPath> {
}
public interface JetBrains.Util.IRegistryInteraction {
    public abstract virtual RegistryAccess GetInProcessSpecificAccess(string key);
    public abstract virtual RegistryAccess GetInCertaintyAccess(string key, KeyAccessRights keyAccessRights);
    public abstract virtual bool KeyExists(RegistryAccess registryAccess, BackSlashSeparatedRelativePath subkey, OnError onerror);
    public abstract virtual String[] GetSubKeyNames(RegistryAccess registryAccess, BackSlashSeparatedRelativePath subkey, OnError onerror);
    public abstract virtual string GetStringValue(RegistryAccess registryAccess, BackSlashSeparatedRelativePath subkey, string dataname, OnError onerror);
    public abstract virtual Nullable`1<UInt32> GetDwordValue(RegistryAccess registryAccess, BackSlashSeparatedRelativePath subkey, string dataname, OnError onerror);
}
[ExtensionAttribute]
public static class JetBrains.Util.IteratorCatchEnumerator : object {
    [ExtensionAttribute]
public static CatchEnumerable`1<T> Catch(IEnumerable`1<T> collection);
}
[NullableContextAttribute("1")]
public interface JetBrains.Util.IUserDataHolder {
    [PureAttribute]
public abstract virtual T GetData(Key`1<T> key);
    public abstract virtual void PutData(Key`1<T> key, T value);
    [MustUseReturnValueAttribute]
public abstract virtual T GetOrCreateDataUnderLock(Key`1<T> key, Func`1<T> factory);
    [MustUseReturnValueAttribute]
public abstract virtual T GetOrCreateDataUnderLock(Key`1<T> key, TState state, Func`2<TState, T> factory);
    [PureAttribute]
public abstract virtual IEnumerable`1<KeyValuePair`2<object, object>> EnumerateData();
}
public interface JetBrains.Util.IVirtualFileSystemInteraction {
    [NotNullAttribute]
public abstract virtual VirtualFileSystemPath GetFinalPathName(VirtualFileSystemPath path, bool isDirectory);
    [NotNullAttribute]
public abstract virtual JetFileSystemWatcher CreateWatcher(VirtualFileSystemPath path, string filter, NotifyFilters notifyFilter, bool includeSubdirectories, IWatcherEvents watcherEvents);
}
public interface JetBrains.Util.IVirtualFileSystemPathIntern {
}
[ExtensionAttribute]
public static class JetBrains.Util.JetArchitectureEx : object {
    [ExtensionAttribute]
public static JetArchitecture ToArchitecture(MachineId machineId);
    [ExtensionAttribute]
public static JetArchitecture ToArchitecture(ProcessorArchitecture processorArchitecture);
}
public abstract class JetBrains.Util.JetFileSystemWatcher : object {
    public static int DefaultEventsBufferSize32;
    public static int DefaultEventsBufferSize64;
    public static int MaxEventsBufferSize;
    public static int TotalBuffers;
    public static long TotalAllocatedSize;
    [CompilerGeneratedAttribute]
private int <BufferSize>k__BackingField;
    public int BufferSize { get; protected set; }
    public VirtualFileSystemPath Directory { get; }
    public bool IncludeSubdirectories { get; }
    public PathWildcard Filter { get; }
    public NotifyFilters NotifyFilters { get; }
    public bool Disposed { get; }
    [CompilerGeneratedAttribute]
public int get_BufferSize();
    [CompilerGeneratedAttribute]
protected void set_BufferSize(int value);
    public abstract virtual void Dispose();
    [CanBeNullAttribute]
public static JetFileSystemWatcher Create(VirtualFileSystemPath path, string filter, NotifyFilters notifyFilter, bool includeSubdirectories, IWatcherEvents watcherEvents, WinError& rc, int bufferSize);
    public abstract virtual VirtualFileSystemPath get_Directory();
    public abstract virtual bool get_IncludeSubdirectories();
    public abstract virtual PathWildcard get_Filter();
    public abstract virtual NotifyFilters get_NotifyFilters();
    public abstract virtual bool get_Disposed();
}
public static class JetBrains.Util.JetFunc : object {
    [NotNullAttribute]
public static Func`1<bool> True;
    [NotNullAttribute]
public static Func`1<bool> False;
    private static JetFunc();
}
public static class JetBrains.Util.JetFunc`1 : object {
    [NotNullAttribute]
public static Func`2<T, bool> True;
    [NotNullAttribute]
public static Func`2<T, bool> False;
    [NotNullAttribute]
public static Func`2<T, T> Identity;
    [NotNullAttribute]
public static Converter`2<T, T> IdentityConverter;
    private static JetFunc`1();
}
public static class JetBrains.Util.JetFunc`2 : object {
    [NotNullAttribute]
public static Func`3<T1, T2, bool> True;
    [NotNullAttribute]
public static Func`3<T1, T2, bool> False;
    private static JetFunc`2();
}
public static class JetBrains.Util.JetFunc`3 : object {
    [NotNullAttribute]
public static Func`4<T1, T2, T3, bool> True;
    [NotNullAttribute]
public static Func`4<T1, T2, T3, bool> False;
    private static JetFunc`3();
}
[TypeConverterAttribute("JetBrains.Util.JetMsilableRuntimeId/JetMsilableRidConverter")]
[ValueSerializerAttribute("JetBrains.Util.JetMsilableRuntimeId/JetMsilableRidSerializer")]
public class JetBrains.Util.JetMsilableRuntimeId : object {
    private static string MsilId;
    public static JetMsilableRuntimeId Msil;
    [CanBeNullAttribute]
public JetRuntimeId NativeRuntimeId;
    public bool IsMsil { get; }
    public bool IsNative { get; }
    public JetPlatform Platform { get; }
    public JetMsilableRuntimeId(JetRuntimeId nativeRuntimeId);
    private static JetMsilableRuntimeId();
    public bool get_IsMsil();
    public bool get_IsNative();
    public JetPlatform get_Platform();
    public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(JetMsilableRuntimeId other);
    public sealed virtual bool Equals(JetMsilableRuntimeId other);
    public static bool TryParse(string ridString, JetMsilableRuntimeId& msilableRuntimeId);
    public static JetMsilableRuntimeId Parse(string ridString);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(JetMsilableRuntimeId left, JetMsilableRuntimeId right);
    public static bool op_Inequality(JetMsilableRuntimeId left, JetMsilableRuntimeId right);
    public virtual string ToString();
}
[DebuggerDisplayAttribute("Count = {Count}")]
public class JetBrains.Util.JetReadOnlyCollection`1 : object {
    [NotNullAttribute]
private ICollection`1<T> myCollection;
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    public JetReadOnlyCollection`1(ICollection`1<T> collection);
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual int get_Count();
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.Remove(T item);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
}
[DebuggerDisplayAttribute("Count = {Count}")]
public class JetBrains.Util.JetReadOnlySet`1 : object {
    [NotNullAttribute]
private ISet`1<T> mySet;
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    public JetReadOnlySet`1(ISet`1<T> set);
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual int get_Count();
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.Remove(T item);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    public sealed virtual bool Add(T item);
    public sealed virtual void UnionWith(IEnumerable`1<T> other);
    public sealed virtual void IntersectWith(IEnumerable`1<T> other);
    public sealed virtual void ExceptWith(IEnumerable`1<T> other);
    public sealed virtual void SymmetricExceptWith(IEnumerable`1<T> other);
    public sealed virtual bool IsSubsetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsSupersetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsProperSupersetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsProperSubsetOf(IEnumerable`1<T> other);
    public sealed virtual bool Overlaps(IEnumerable`1<T> other);
    public sealed virtual bool SetEquals(IEnumerable`1<T> other);
}
[TypeConverterAttribute("JetBrains.Util.JetRuntimeId/JetRuntimeIdTypeConverter")]
[ValueSerializerAttribute("JetBrains.Util.JetRuntimeId/JetRuntimeIdValueSerializer")]
public class JetBrains.Util.JetRuntimeId : object {
    public static JetRuntimeId ProcessRuntimeId;
    public static JetRuntimeId OSRuntimeId;
    public static JetRuntimeId LinuxGlibcArm;
    public static JetRuntimeId LinuxGlibcArm64;
    public static JetRuntimeId LinuxGlibcX64;
    public static JetRuntimeId LinuxMuslArm;
    public static JetRuntimeId LinuxMuslArm64;
    public static JetRuntimeId LinuxMuslX64;
    public static JetRuntimeId MacOsArm64;
    public static JetRuntimeId MacOsX64;
    public static JetRuntimeId WindowsArm64;
    public static JetRuntimeId WindowsX64;
    public static JetRuntimeId WindowsX86;
    public static IReadOnlyCollection`1<JetArchitecture> AllOrderedArchitectures;
    public static IReadOnlyCollection`1<JetRuntimeId> AllOrderedRuntimeIds;
    public JetArchitecture Architecture;
    public Nullable`1<JetLinuxLibC> LinuxLibC;
    public JetPlatform Platform;
    public JetRuntimeId(JetPlatform platform, JetArchitecture architecture, Nullable`1<JetLinuxLibC> linuxLibC);
    private static JetRuntimeId();
    public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(JetRuntimeId other);
    public sealed virtual bool Equals(JetRuntimeId other);
    public static bool TryParse(string ridString, JetRuntimeId& runtimeId);
    public static JetRuntimeId Parse(string ridString);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(JetRuntimeId left, JetRuntimeId right);
    public static bool op_Inequality(JetRuntimeId left, JetRuntimeId right);
    public virtual string ToString();
}
[ExtensionAttribute]
public static class JetBrains.Util.JetRuntimeIdEx : object {
    [ExtensionAttribute]
[NotNullAttribute]
public static JetArchitecture[] GetAllOrderedArchitecturesForOS(JetRuntimeId osRuntimeId);
    [ExtensionAttribute]
[NotNullAttribute]
public static JetRuntimeId[] GetAllOrderedRuntimeIdsForOS(JetRuntimeId osRuntimeId);
}
public class JetBrains.Util.JetWeakReference`1 : WeakReference {
    private int myHashCode;
    [CanBeNullAttribute]
public T Target { get; public set; }
    public JetWeakReference`1(T target);
    public T get_Target();
    public void set_Target(T value);
    public sealed virtual bool Equals(T other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[DebuggerDisplayAttribute("Key: {ToString()}")]
public class JetBrains.Util.Key : Key`1<object> {
    public Key(string text);
}
[DebuggerDisplayAttribute("Key: {ToString()}")]
public class JetBrains.Util.Key`1 : object {
    private string myText;
    public Key`1(string text);
    public virtual string ToString();
}
public static class JetBrains.Util.Lazy : object {
    [ObsoleteAttribute("Please, use overload with explicit threading mode flag")]
[NotNullAttribute]
[PureAttribute]
public static Lazy`1<T> Of(Func`1<T> valueFactory);
    [NotNullAttribute]
[PureAttribute]
public static Lazy`1<T> Of(Func`1<T> valueFactory, bool isThreadSafe);
    [ObsoleteAttribute("Please, use overload with explicit threading mode flag")]
[NotNullAttribute]
[PureAttribute]
public static Lazy`1<T> Of();
    [NotNullAttribute]
[PureAttribute]
public static Lazy`1<T> Of(bool isThreadSafe);
    [NotNullAttribute]
[PureAttribute]
public static Lazy`1<T> Of(T value);
}
public class JetBrains.Util.LocalExecutionInteraction : object {
    public sealed virtual IExternalProcess Start(ProcessStartInfo processStartInfo);
    public sealed virtual IExternalProcess Create(ProcessStartInfo processStartInfo, bool enableRaisingEvents);
}
public class JetBrains.Util.LocalHashSet`1 : ValueType {
    [CanBeNullAttribute]
private JetHashSet`1<T> myHashSet;
    [CanBeNullAttribute]
public JetHashSet`1<T> HashSet { get; }
    public bool IsEmpty { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public JetHashSet`1<T> get_HashSet();
    public bool get_IsEmpty();
    public void AddRange(IEnumerable`1<T> array);
    public void UnionWith(IEnumerable`1<T> array);
    public void UnionWith(LocalHashSet`1& other);
    public void ExceptWith(IEnumerable`1<T> array);
    public void ExceptWith(LocalHashSet`1<T> array);
    public bool Ovelaps(LocalHashSet`1<T> set);
    [NotNullAttribute]
[PureAttribute]
public T[] ToArray();
    public bool Add(T t);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    public sealed virtual bool Contains(T t);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    public ElementEnumerator<T> GetEnumerator();
    public sealed virtual bool Remove(T element);
    public sealed virtual void Clear();
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
}
public class JetBrains.Util.LocalInteractionContext : ConcurrentUserDataHolder {
    public static IInteractionContext Instance;
    private IRegistryInteraction myRegistryInteraction;
    private IEnvironmentInteraction myEnvironmentInteraction;
    private IVirtualFileSystemInteraction myFileSystemInteraction;
    private IExecutionInteraction myExecutionInteraction;
    [CompilerGeneratedAttribute]
private IVirtualFileSystemPathIntern <CurrentIntern>k__BackingField;
    [CompilerGeneratedAttribute]
private IPlatformApi <PlatformApi>k__BackingField;
    public IVirtualFileSystemInteraction VirtualFileSystemInteraction { get; }
    public IRegistryInteraction RegistryInteraction { get; }
    public IEnvironmentInteraction EnvironmentInteraction { get; }
    public IExecutionInteraction ExecutionInteraction { get; }
    public JetPlatform Platform { get; }
    public bool IsWindowsContext { get; }
    public string ContextId { get; }
    public IVirtualFileSystemPathIntern CurrentIntern { get; private set; }
    public IPlatformApi PlatformApi { get; }
    private static LocalInteractionContext();
    public sealed virtual IVirtualFileSystemInteraction get_VirtualFileSystemInteraction();
    public sealed virtual IRegistryInteraction get_RegistryInteraction();
    public sealed virtual IEnvironmentInteraction get_EnvironmentInteraction();
    public sealed virtual IExecutionInteraction get_ExecutionInteraction();
    public sealed virtual JetPlatform get_Platform();
    public sealed virtual bool get_IsWindowsContext();
    public sealed virtual string get_ContextId();
    public sealed virtual void AllowIntern(Lifetime lifetime, IVirtualFileSystemPathIntern intern);
    [CompilerGeneratedAttribute]
public sealed virtual IVirtualFileSystemPathIntern get_CurrentIntern();
    [CompilerGeneratedAttribute]
private void set_CurrentIntern(IVirtualFileSystemPathIntern value);
    public sealed virtual void ClearIntern();
    [CompilerGeneratedAttribute]
public sealed virtual IPlatformApi get_PlatformApi();
}
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("Count = {Count}")]
[DebuggerTypeProxyAttribute("JetBrains.Util.LocalListDebugView`1")]
public class JetBrains.Util.LocalList`1 : ValueType {
    private static int DefaultFirstSize;
    private T[] myArray;
    private int myCount;
    private int myNextSize;
    private int myVersion;
    public int Count { get; }
    public int Capacity { get; }
    public T Item { get; public set; }
    [CanBeNullAttribute]
public T SingleItem { get; }
    public LocalList`1(int capacity);
    public LocalList`1(IEnumerable`1<T> enumerable);
    public LocalList`1(T[] array, bool copyArray);
    public LocalList`1(LocalList`1& other);
    public int get_Count();
    public int get_Capacity();
    public T get_Item(int index);
    public void set_Item(int index, T value);
    [PureAttribute]
public bool Any();
    [PureAttribute]
public bool Any(Func`2<T, bool> predicate);
    [PureAttribute]
public bool All(Func`2<T, bool> predicate);
    [PureAttribute]
public T Last();
    [PureAttribute]
public T First();
    [PureAttribute]
public T Single();
    public T get_SingleItem();
    [PureAttribute]
[CanBeNullAttribute]
public T FirstOrDefault();
    [PureAttribute]
[CanBeNullAttribute]
public T LastOrDefault();
    public void Add(T item);
    public void AddRange(IEnumerable`1<TSource> items);
    public void AddRange(IEnumerable`1<T> items);
    public void AddRange(LocalList`1& items);
    public void AddRange(FrugalLocalList`1& items);
    public void AddRange(TSource[] items);
    private void AddRange(TSource[] items, int length);
    public void AddRange(ICollection`1<T> items);
    private int CalculateNewAndNextSize(int currentSize, int capacity);
    public void EnsureCapacity(int capacity, bool exact);
    public bool Remove(T item);
    [PureAttribute]
public bool Contains(T item);
    [PureAttribute]
[NotNullAttribute]
public T[] ToArray();
    [PureAttribute]
[NotNullAttribute]
public TResult[] ToArray(Func`2<T, TResult> transform);
    public void CopyTo(T[] array, int arrayIndex);
    public void Clear();
    [PureAttribute]
public int IndexOf(T item);
    public void InsertRange(int index, LocalList`1& items);
    public void InsertRange(int atIndex, TSource[] items, int startingFrom, int length);
    public void Insert(int index, T item);
    public void RemoveAt(int index);
    public void UnstableSortInplace(IComparer`1<T> comparer);
    public void UnstableSortInplace(int index, int length, IComparer`1<T> comparer);
    public void Reverse();
    [PureAttribute]
public ElementEnumerator<T> GetEnumerator();
    [PureAttribute]
[NotNullAttribute]
public IList`1<T> ResultingList();
    [PureAttribute]
[NotNullAttribute]
public IReadOnlyList`1<T> ReadOnlyList();
    public virtual string ToString();
    private static void ThrowOutOfRange();
    private static void ThrowResultObtained();
    private static void ThrowEmpty();
    private static void ThrowManyItems();
}
internal class JetBrains.Util.LocalListDebugView`1 : object {
    private LocalList`1<T> myList;
    [NotNullAttribute]
[DebuggerBrowsableAttribute("3")]
public T[] Items { get; }
    public LocalListDebugView`1(LocalList`1<T> localList);
    public T[] get_Items();
}
public class JetBrains.Util.LocalVirtualFileSystemInteraction : object {
    private FileSystemInteraction myImpl;
    public sealed virtual Existence GetExists(VirtualFileSystemPath path);
    public sealed virtual Stream GetWriteonlyStream(VirtualFileSystemPath path, FileMode fileMode, FileShare fileShare);
    public sealed virtual Stream GetReadonlyStream(VirtualFileSystemPath path, FileMode fileMode, FileShare fileShare);
    public sealed virtual DateTime GetFileModificationTimeUtc(VirtualFileSystemPath path);
    public sealed virtual void SetFileModificationTimeUtc(VirtualFileSystemPath path, DateTime value);
    public sealed virtual DateTime GetFileCreationTimeUtc(VirtualFileSystemPath path);
    public sealed virtual DateTime GetFileLastAccessedTimeUtc(VirtualFileSystemPath path);
    public sealed virtual FileAttributes GetAttributes(VirtualFileSystemPath path);
    public sealed virtual FileAttributes TryGetAttributes(VirtualFileSystemPath path);
    public sealed virtual long GetFileLength(VirtualFileSystemPath thіs);
    public sealed virtual IEnumerable`1<VirtualFileSystemPath> GetDirectoryEntries(VirtualFileSystemPath path, string mask, Nullable`1<bool> files, FileSystemPathInternStrategy internStrategy);
    public sealed virtual void GetDirectoryEntries(VirtualFileSystemPath path, RelativePath subdir, string mask, PathSearchFlags flags, ICollection`1& output);
    public sealed virtual void DeleteFile(VirtualFileSystemPath path, Boolean& isDirectory, int nAttempts);
    public sealed virtual void DeleteDirectoryNonRecursive(VirtualFileSystemPath virtualFileSystemPath, int retryCount, Exception& exception);
    public sealed virtual VirtualFileSystemPath CreateDirectory(VirtualFileSystemPath virtualFileSystemPath);
    public sealed virtual VirtualFileSystemEntryInfo GetInfo(VirtualFileSystemPath path);
    public sealed virtual void SetAttributes(VirtualFileSystemPath path, FileAttributes fileAttributes);
    public sealed virtual void CopyFile(VirtualFileSystemPath path, VirtualFileSystemPath destinationFilePath, bool overwrite);
    public sealed virtual VirtualFileSystemPath GetTempPath();
    public sealed virtual void Move(VirtualFileSystemPath virtualFileSystemPath, VirtualFileSystemPath destinationFilePath);
    public sealed virtual void MoveFile(VirtualFileSystemPath thіs, VirtualFileSystemPath dst, bool overwrite);
    public sealed virtual VirtualFileSystemPath GetFinalPathName(VirtualFileSystemPath path, bool isDirectory);
    public sealed virtual JetFileSystemWatcher CreateWatcher(VirtualFileSystemPath path, string filter, NotifyFilters notifyFilter, bool includeSubdirectories, IWatcherEvents watcherEvents);
    public sealed virtual VirtualFileSystemPath GetLongPath(VirtualFileSystemPath virtualFileSystemPath);
    public sealed virtual string GetFileAccessPath(VirtualFileSystemPath fileSystemPathBase);
}
public class JetBrains.Util.Locator`1 : MulticastDelegate {
    public Locator`1(object object, IntPtr method);
    public virtual int Invoke(T leftside);
    public virtual IAsyncResult BeginInvoke(T leftside, AsyncCallback callback, object object);
    public virtual int EndInvoke(IAsyncResult result);
}
public class JetBrains.Util.LogCookie : ValueType {
    private string myComment;
    public LogCookie(string comment);
    public static void Execute(string comment, Action F);
    public sealed virtual void Dispose();
}
public class JetBrains.Util.LogEvent : object {
    [CompilerGeneratedAttribute]
private LoggingLevel <Level>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Category>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <Timestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private Thread <Thread>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OriginalMessage>k__BackingField;
    [CompilerGeneratedAttribute]
private LoggerException <Exception>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ExceptionOrigin> <ExceptionOrigin>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsStructured>k__BackingField;
    [CanBeNullAttribute]
private string myShortMessage;
    [CanBeNullAttribute]
private string myFullMessage;
    public LoggingLevel Level { get; }
    [NotNullAttribute]
public string Category { get; }
    public DateTime Timestamp { get; }
    [NotNullAttribute]
public Thread Thread { get; }
    [CanBeNullAttribute]
public string OriginalMessage { get; }
    [CanBeNullAttribute]
public LoggerException Exception { get; }
    [CanBeNullAttribute]
public Nullable`1<ExceptionOrigin> ExceptionOrigin { get; }
    public bool IsStructured { get; }
    [CanBeNullAttribute]
public string ShortExceptionText { get; }
    [CanBeNullAttribute]
public string FullExceptionText { get; }
    [CanBeNullAttribute]
public string FullExceptionTextWithSensitiveData { get; }
    [CanBeNullAttribute]
public string ShortMessage { get; }
    [CanBeNullAttribute]
public string FullMessage { get; }
    public string FullMessageWithSensitiveData { get; }
    [CanBeNullAttribute]
public Exception OriginalException { get; }
    private LogEvent(LoggingLevel level, string category, DateTime timestamp, Thread thread, string originalMessage, LoggerException exception, Nullable`1<ExceptionOrigin> exorigin, bool isStructured);
    [CompilerGeneratedAttribute]
public LoggingLevel get_Level();
    [CompilerGeneratedAttribute]
public string get_Category();
    [CompilerGeneratedAttribute]
public DateTime get_Timestamp();
    [CompilerGeneratedAttribute]
public Thread get_Thread();
    [CompilerGeneratedAttribute]
public string get_OriginalMessage();
    [CompilerGeneratedAttribute]
public LoggerException get_Exception();
    [CompilerGeneratedAttribute]
public Nullable`1<ExceptionOrigin> get_ExceptionOrigin();
    [CompilerGeneratedAttribute]
public bool get_IsStructured();
    public static LogEvent CreateWithException(LoggingLevel level, string category, Exception exception, ExceptionOrigin exceptionOrigin, string comment);
    public static LogEvent CreateWithMessage(LoggingLevel level, string category, string message, Nullable`1<ExceptionOrigin> origin);
    public static LogEvent CreateWithMessageAndSensitiveData(LoggingLevel level, string category, string message, Pair`2[] sensitiveData, Nullable`1<ExceptionOrigin> origin);
    public static LogEvent CreateWithMessageAndSensitiveData(LoggingLevel level, string category, string message, Pair`2<string, object> d1, Nullable`1<ExceptionOrigin> origin);
    [ObsoleteAttribute("Use CreateStructuredForPlayback", "True")]
public static LogEvent CreateStructured(string category, LoggingLevel level, string message);
    public static LogEvent CreateStructuredForPlayback(string category, LoggingLevel level, string message);
    public static LogEvent CreateAsIs(string category, LoggingLevel level, string message, Nullable`1<ExceptionOrigin> origin);
    public string get_ShortExceptionText();
    public string get_FullExceptionText();
    public string get_FullExceptionTextWithSensitiveData();
    public string get_ShortMessage();
    public string get_FullMessage();
    public string get_FullMessageWithSensitiveData();
    public Exception get_OriginalException();
}
public abstract class JetBrains.Util.LoggerBase : object {
    [CompilerGeneratedAttribute]
private string <Category>k__BackingField;
    public string Category { get; protected set; }
    public abstract virtual bool IsEnabled(LoggingLevel level);
    public abstract virtual void Log(LogEvent logEvent);
    [CompilerGeneratedAttribute]
public virtual string get_Category();
    [CompilerGeneratedAttribute]
protected virtual void set_Category(string value);
    public sealed virtual void Log(LoggingLevel level, string message, Exception ex);
}
public class JetBrains.Util.LoggerException : ApplicationException {
    private ToStringBehavior myToStringBehavior;
    private string myStackTrace;
    public string StackTrace { get; }
    public LoggerException(string message, Exception innerException, Nullable`1<int> ignoreFrames, ToStringBehavior toStringBehavior, string sOverrideStackTrace);
    [UsedImplicitlyAttribute]
protected LoggerException(SerializationInfo info, StreamingContext context);
    private static string ChooseMessage(string details, Exception innerException);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual string ToString();
    public virtual string get_StackTrace();
    [NotNullAttribute]
[HandleProcessCorruptedStateExceptionsAttribute]
public static LoggerException WrapException(Exception ex, string comment);
}
public class JetBrains.Util.Logging.AnonymousLogger : LoggerBase {
    [NotNullAttribute]
private string myCategory;
    [CanBeNullAttribute]
private Func`2<LoggingLevel, bool> myFIsEnabled;
    [NotNullAttribute]
private Action`1<LogEvent> myLog;
    public string Category { get; }
    public AnonymousLogger(LoggingLevel maxLoggingLevel, string category, Action`1<LogEvent> log);
    public AnonymousLogger(string category, Action`1<LogEvent> log, Func`2<LoggingLevel, bool> FIsEnabled);
    public virtual string get_Category();
    public virtual bool IsEnabled(LoggingLevel level);
    public virtual void Log(LogEvent logEvent);
}
public class JetBrains.Util.Logging.ConfiguredLogger : LoggerBase {
    private object myCategoryProvider;
    private LogConfNode myLogConfNode;
    [ThreadStaticAttribute]
private static int ourReentrancyCount;
    private string myCategory;
    public string Category { get; }
    private ConfiguredLogger(object category);
    internal ConfiguredLogger(Type namespaceTypeProvider);
    internal ConfiguredLogger(string namespaceStringProvider);
    private void OptionallyReconfigure();
    private string CalcCategory();
    private bool FilterchainAccepts(IFilter[] filterchain, LogEvent logEvent);
    [HandleProcessCorruptedStateExceptionsAttribute]
public virtual void Log(LogEvent logEvent);
    private static void BreakOnAllErrors(LogEvent logevent);
    public virtual string get_Category();
    public virtual bool IsEnabled(LoggingLevel level);
}
public class JetBrains.Util.Logging.DebugOutputLogEventListener : object {
    protected string myPrefix;
    public static DebugOutputLogEventListener Instance;
    public static bool OptionDontWriteDebugStream;
    private static object ourLock;
    [CompilerGeneratedAttribute]
private ILayout <Layout>k__BackingField;
    [CompilerGeneratedAttribute]
private IFilter[] <Filters>k__BackingField;
    public ILayout Layout { get; public set; }
    public IFilter[] Filters { get; public set; }
    public DebugOutputLogEventListener(string prefix);
    private static DebugOutputLogEventListener();
    private static void WriteDebugStream(string prefix, string body);
    private static void LogToDebugString(string str);
    private string CombinePrefices(string prefix);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(DebugOutputLogEventListener debugOutputLogEventListener);
    [CompilerGeneratedAttribute]
public sealed virtual ILayout get_Layout();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Layout(ILayout value);
    private sealed virtual override void JetBrains.Util.ILogEventListener.OnLogEvent(LogEvent logEvent);
    [CompilerGeneratedAttribute]
public sealed virtual IFilter[] get_Filters();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Filters(IFilter[] value);
}
public class JetBrains.Util.Logging.DummyLogger : LoggerBase {
    public static ILogger Instance;
    public string Category { get; }
    private static DummyLogger();
    public virtual bool IsEnabled(LoggingLevel level);
    public virtual void Log(LogEvent logEvent);
    public virtual string get_Category();
}
[ExtensionAttribute]
public static class JetBrains.Util.Logging.ExceptionStackTraceHelpers : object {
    private static Regex myRegexParseLine;
    private static ExceptionStackTraceHelpers();
    [ExtensionAttribute]
public static FrameData[] CacheOnException(FrameData[] framedata, Exception ex);
    [NotNullAttribute]
public static string EnrichStackTraceStringWithIlOffsets(string strace, FrameData[] stackFramesSorted, bool isReplaceExistingLineInfo, bool isAddMvid);
    private static void CleanUpNameComponents(List`1<string> components);
    [ExtensionAttribute]
private static string PrintFirstChars(Guid& guid);
    [ExtensionAttribute]
private static TextRange Range(Group this);
    private static string TakeAlphanumeric(string s);
    private static bool TryParseLine(string strace, LineSegment segment, ParsedLine curline);
    private static string UnwrapLambdaName(string component);
}
[UsedImplicitlyAttribute]
public class JetBrains.Util.Logging.FileLogEventListener : AsyncLogEventListener {
    private static int ourSystemStartedTime;
    private static bool DefaultAppend;
    private static Regex ourEnvRegex;
    public FileSystemPath Path;
    private bool myAppend;
    private Rolling myRolling;
    private Stream modreq(System.Runtime.CompilerServices.IsVolatile) myStream;
    public Encoding Encoding;
    private static string ourProcessStartTime;
    private TimeThrottler myThrottler;
    [CompilerGeneratedAttribute]
private IFilter[] <Filters>k__BackingField;
    public IFilter[] Filters { get; public set; }
    private static FileLogEventListener();
    public FileLogEventListener(string parametrizedLogFilePath);
    public FileLogEventListener(string parametrizedLogFilePath, string append);
    public FileLogEventListener(string parametrizedLogFilePath, string append, string rolling);
    public FileLogEventListener(string parametrizedLogFilePath, bool append);
    public FileLogEventListener(FileSystemPath path, bool append, Rolling rolling);
    private static string FormatDate(DateTime dateTime);
    private static string SubstitutedPath(string parametrizedLogFilePath);
    private static bool ParseAppend(string arg);
    private void OpenStream();
    private void CloseStream();
    private FileSystemPath RollingFile(int idx);
    private void TryRollFiles();
    protected virtual void ProcessChars(Char* chars, int size);
    [CompilerGeneratedAttribute]
public sealed virtual IFilter[] get_Filters();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Filters(IFilter[] value);
}
public enum JetBrains.Util.Logging.FilterDecision : Enum {
    public int value__;
    public static FilterDecision Deny;
    public static FilterDecision Neutral;
    public static FilterDecision Accept;
}
public class JetBrains.Util.Logging.FilterModel : object {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<string> <Params>k__BackingField;
    [NotNullAttribute]
public Type Type { get; }
    [NotNullAttribute]
public IReadOnlyCollection`1<string> Params { get; }
    public FilterModel(Type type, IEnumerable`1<string> params);
    private FilterModel(Type type, List`1<string> params);
    [CompilerGeneratedAttribute]
public Type get_Type();
    [CompilerGeneratedAttribute]
public IReadOnlyCollection`1<string> get_Params();
    public IFilter Build();
    public sealed virtual bool Equals(FilterModel other);
    private sealed virtual override object System.ICloneable.Clone();
    public sealed virtual FilterModel Clone();
    public static FilterModel LoadFromXml(XmlElement elt);
    public void StoreToXml(XmlElement parent);
    public void StoreToBinary(BinaryWriter writer);
    public static FilterModel LoadFromBinary(BinaryReader reader);
}
public class JetBrains.Util.Logging.Filters.BurstFilter : object {
    private UInt32 BurstLimitForDistinctExceptions;
    private UInt32 BurstLimitForSimilarExceptions;
    private UInt32 BurstPeriodMs;
    private LoggingLevel myLevel;
    private ConcurrentDictionary`2<StringSlice, UInt32> myRateCounters;
    private UInt32 myTimeCutoff;
    private int PrefixLength;
    public BurstFilter(LoggingLevel level);
    public virtual string ToString();
    private sealed virtual override FilterDecision JetBrains.Util.Logging.IFilter.Filter(LogEvent logEvent);
}
public class JetBrains.Util.Logging.Filters.CategoryFilter : object {
    private string myCategory;
    public CategoryFilter(string category);
    public sealed virtual FilterDecision Filter(LogEvent logEvent);
    public virtual string ToString();
}
public class JetBrains.Util.Logging.Filters.LevelFilter : object {
    private LoggingLevel myMaxLevelToPass;
    public LevelFilter(LoggingLevel maxLevelToPass);
    public sealed virtual FilterDecision Filter(LogEvent logEvent);
}
public class JetBrains.Util.Logging.Filters.StructuredFilter : object {
    public sealed virtual FilterDecision Filter(LogEvent logEvent);
}
public interface JetBrains.Util.Logging.IFilter {
    public abstract virtual FilterDecision Filter(LogEvent logEvent);
}
public interface JetBrains.Util.Logging.ILayout {
    public abstract virtual void Format(TextWriter writer, LogEvent logEvent);
    public abstract virtual void FormatUnsafe(UnsafeWriter writer, LogEvent logEvent);
}
public interface JetBrains.Util.Logging.IOuterWorldException {
}
public abstract class JetBrains.Util.Logging.LayoutBase : object {
    [HandleProcessCorruptedStateExceptionsAttribute]
public sealed virtual void Format(TextWriter textWriter, LogEvent logEvent);
    public abstract virtual void FormatUnsafe(UnsafeWriter writer, LogEvent logEvent);
}
public class JetBrains.Util.Logging.Listeners.TextWriterLogEventListener : object {
    private LifetimeDefinition Disposables;
    private ILayout myLayout;
    private SequentialLifetimes myPushToLogger;
    private bool myWereErrors;
    private TextWriter myWriter;
    [CompilerGeneratedAttribute]
private IFilter[] <Filters>k__BackingField;
    public bool WereErrors { get; }
    public IFilter[] Filters { get; public set; }
    [NotNullAttribute]
private ILayout JetBrains.Util.IConfigurableLogEventListener.Layout { get; private set; }
    public TextWriterLogEventListener(TextWriter writer);
    public bool get_WereErrors();
    public static TextWriterLogEventListener CreateFileLogger(string identity);
    public void PushToLogger(LoggingLevel level);
    public sealed virtual void Dispose();
    private sealed virtual override void JetBrains.Util.ILogEventListener.OnLogEvent(LogEvent logEvent);
    [CompilerGeneratedAttribute]
public sealed virtual IFilter[] get_Filters();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Filters(IFilter[] value);
    private sealed virtual override ILayout JetBrains.Util.IConfigurableLogEventListener.get_Layout();
    private sealed virtual override void JetBrains.Util.IConfigurableLogEventListener.set_Layout(ILayout value);
}
public class JetBrains.Util.Logging.LogConfig : object {
    public static LogConfig Empty;
    public static LogConfig Updating;
    private ImmutableArray`1<LogConfNode> myNodes;
    [CompilerGeneratedAttribute]
private int <Timestamp>k__BackingField;
    public LogConfNode Root { get; }
    public ImmutableArray`1<LogConfNode> Nodes { get; }
    public IEnumerable`1<ILogEventListener> HierarchyAppenders { get; }
    public int Timestamp { get; }
    private LogConfig(ImmutableArray`1<LogConfNode> nodes, int timestamp);
    private static LogConfig();
    public LogConfNode get_Root();
    public ImmutableArray`1<LogConfNode> get_Nodes();
    public IEnumerable`1<ILogEventListener> get_HierarchyAppenders();
    [CompilerGeneratedAttribute]
public int get_Timestamp();
    internal static LogConfig Build(IEnumerable`1<LogConfNode> nodes, int timestamp);
    internal void AdjustTimestamps();
    private static void CloseNodesTransiently(List`1<LogConfNode> nodes);
    [PureAttribute]
public LogConfig WithLevelAtLeast(LoggingLevel level, String[] categories);
    [PureAttribute]
public LogConfig WithListener(IConfigurableLogEventListener listener, string category);
    [PureAttribute]
public LogConfig WithInjectedNode(LogConfNode node);
    [PureAttribute]
public LogConfig WithInjectedNodes(IEnumerable`1<LogConfNode> toInjectNodes);
    public LogConfig WithNodes(IEnumerable`1<LogConfNode> nodes);
    public LogConfig WithTimestamp(int timestamp);
    public sealed virtual void Dispose();
    public LogConfig WithRoot(LogConfNode root);
}
public class JetBrains.Util.Logging.LogConfNode : object {
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) myTimestamp;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<IConfigurableLogEventListener> <HierarchyAppenders>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Namespace>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<LoggingLevel> <Level>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Additivity>k__BackingField;
    public ImmutableArray`1<IConfigurableLogEventListener> HierarchyAppenders { get; }
    public string Namespace { get; }
    public Nullable`1<LoggingLevel> Level { get; public set; }
    public bool Additivity { get; public set; }
    public int Timestamp { get; internal set; }
    public LogConfNode(Nullable`1<LoggingLevel> level, string namespace, ImmutableArray`1<IConfigurableLogEventListener> appenders, bool additivity, int timestamp);
    public LogConfNode(Nullable`1<LoggingLevel> level, string namespace, bool additivity, int timestamp);
    [CompilerGeneratedAttribute]
public ImmutableArray`1<IConfigurableLogEventListener> get_HierarchyAppenders();
    [CompilerGeneratedAttribute]
public string get_Namespace();
    [CompilerGeneratedAttribute]
public Nullable`1<LoggingLevel> get_Level();
    [CompilerGeneratedAttribute]
public void set_Level(Nullable`1<LoggingLevel> value);
    [CompilerGeneratedAttribute]
public bool get_Additivity();
    [CompilerGeneratedAttribute]
public void set_Additivity(bool value);
    public int get_Timestamp();
    internal void set_Timestamp(int value);
    public sealed virtual int CompareTo(LogConfNode other);
    [CanBeNullAttribute]
internal LogConfNode InheritFrom(LogConfNode other, Nullable`1<LoggingLevel> setLevelAtLeast);
    internal LogConfNode WithMerge(LogConfNode other);
    public LogConfNode With(IConfigurableLogEventListener appender);
    public LogConfNode With(Nullable`1<ImmutableArray`1<IConfigurableLogEventListener>> appenders, Nullable`1<LoggingLevel> level, string ns, Nullable`1<bool> additivity, Nullable`1<int> timestamp);
}
public static class JetBrains.Util.Logging.Logger : object {
    public static string LOG_FILENAME_ENV_VARIABLE;
    public static string JETLOGS_DIRECTORY_ENV_VARIABLE;
    private static FileSystemPath ourLogFileName;
    private static bool ourFileLoggingInitialized;
    private static bool ourFileLoggingEnabled;
    [CompilerGeneratedAttribute]
private static int <IndentLevel>k__BackingField;
    private static Nullable`1<LoggingLevel> ourFileLoggingLevel;
    public static string LogFileExt;
    public static string LogFileNamePrefix;
    private static FileSystemPath modreq(System.Runtime.CompilerServices.IsVolatile) ourLogFolderPath;
    public static string LogsSubfolderName;
    [NotNullAttribute]
[ObsoleteAttribute("Please either use Logger.Root or (better) Logger.GetLogger<T>() to get appropriate category")]
public static ILogger Interface;
    public static int IndentLevel { get; public set; }
    public static Nullable`1<LoggingLevel> FileLoggingLevel { get; public set; }
    public static bool IsFileLoggingEnabled { get; public set; }
    public static FileSystemPath LogFileName { get; public set; }
    public static FileSystemPath LogFolderPath { get; public set; }
    [PublicAPIAttribute]
[NotNullAttribute]
public static ILogger Root { get; }
    private static Logger();
    [CompilerGeneratedAttribute]
public static int get_IndentLevel();
    [CompilerGeneratedAttribute]
public static void set_IndentLevel(int value);
    public static Nullable`1<LoggingLevel> get_FileLoggingLevel();
    public static void set_FileLoggingLevel(Nullable`1<LoggingLevel> value);
    public static bool get_IsFileLoggingEnabled();
    public static void set_IsFileLoggingEnabled(bool value);
    public static FileSystemPath get_LogFileName();
    public static void set_LogFileName(FileSystemPath value);
    private static FileSystemPath GetDefaultLogFolderPath();
    public static FileSystemPath get_LogFolderPath();
    public static void set_LogFolderPath(FileSystemPath value);
    [DebuggerStepThroughAttribute]
[HandleProcessCorruptedStateExceptionsAttribute]
public static void Annotate(Action F, Action`1<Exception> FCommentException);
    [ConditionalAttribute("JET_MODE_ASSERT")]
public static void Assert(bool condition, string message);
    [ConditionalAttribute("JET_MODE_ASSERT")]
public static void AssertWithSensitiveData(bool condition, string message, Pair`2[] sensitiveData);
    [ConditionalAttribute("JET_MODE_ASSERT")]
public static void AssertWithSensitiveData(bool condition, string message, Pair`2<string, object> d1, T1 arg1, T2 arg2, T3 arg3);
    [ConditionalAttribute("JET_MODE_ASSERT")]
public static void AssertWithSensitiveData(bool condition, string message, Pair`2<string, object> d1, Pair`2<string, object> d2, T1 arg1, T2 arg2, T3 arg3);
    [ConditionalAttribute("JET_MODE_ASSERT")]
public static void AssertWithSensitiveData(bool condition, string message, Pair`2<string, object> d1, Pair`2<string, object> d2, Pair`2<string, object> d3, T1 arg1, T2 arg2, T3 arg3);
    [ConditionalAttribute("JET_MODE_ASSERT")]
public static void AssertWithSensitiveData(bool condition, string message, Pair`2<string, object> d1, T1 arg1, T2 arg2);
    [ConditionalAttribute("JET_MODE_ASSERT")]
public static void AssertWithSensitiveData(bool condition, string message, Pair`2<string, object> d1, Pair`2<string, object> d2, T1 arg1, T2 arg2);
    [ConditionalAttribute("JET_MODE_ASSERT")]
public static void AssertWithSensitiveData(bool condition, string message, Pair`2<string, object> d1, Pair`2<string, object> d2, Pair`2<string, object> d3, T1 arg1, T2 arg2);
    [ConditionalAttribute("JET_MODE_ASSERT")]
public static void AssertWithSensitiveData(bool condition, string message, Pair`2<string, object> d1, T arg1);
    [ConditionalAttribute("JET_MODE_ASSERT")]
public static void AssertWithSensitiveData(bool condition, string message, Pair`2<string, object> d1, Pair`2<string, object> d2, T arg1);
    [ConditionalAttribute("JET_MODE_ASSERT")]
public static void AssertWithSensitiveData(bool condition, string message, Pair`2<string, object> d1, Pair`2<string, object> d2, Pair`2<string, object> d3, T arg1);
    [ConditionalAttribute("JET_MODE_ASSERT")]
public static void AssertWithSensitiveData(bool condition, string message, Pair`2<string, object> d1);
    [ConditionalAttribute("JET_MODE_ASSERT")]
public static void AssertWithSensitiveData(bool condition, string message, Pair`2<string, object> d1, Pair`2<string, object> d2);
    [ConditionalAttribute("JET_MODE_ASSERT")]
public static void AssertWithSensitiveData(bool condition, string message, Pair`2<string, object> d1, Pair`2<string, object> d2, Pair`2<string, object> d3);
    [StringFormatMethodAttribute("format")]
[ConditionalAttribute("JET_MODE_ASSERT")]
public static void Assert(bool condition, string format, Object[] args);
    [DebuggerStepThroughAttribute]
[HandleProcessCorruptedStateExceptionsAttribute]
public static void Catch(Action action);
    [AsyncStateMachineAttribute("JetBrains.Util.Logging.Logger/<CatchAsync>d__44")]
[DebuggerStepThroughAttribute]
[HandleProcessCorruptedStateExceptionsAttribute]
public static Task CatchAsync(Func`1<Task> action);
    [DebuggerStepThroughAttribute]
[HandleProcessCorruptedStateExceptionsAttribute]
public static void Catch(Action action, Action actionOnException);
    [DebuggerStepThroughAttribute]
[CanBeNullAttribute]
[HandleProcessCorruptedStateExceptionsAttribute]
public static TValue Catch(Func`1<TValue> func);
    [DebuggerStepThroughAttribute]
[CanBeNullAttribute]
[HandleProcessCorruptedStateExceptionsAttribute]
public static TValue Catch(string comment, Func`1<TValue> F);
    [DebuggerStepThroughAttribute]
[HandleProcessCorruptedStateExceptionsAttribute]
public static void Catch(string comment, Action action);
    [DebuggerStepThroughAttribute]
[HandleProcessCorruptedStateExceptionsAttribute]
public static void CatchIgnore(Action action);
    [DebuggerStepThroughAttribute]
[CanBeNullAttribute]
[HandleProcessCorruptedStateExceptionsAttribute]
public static TValue CatchIgnore(Func`1<TValue> F, TValue defaultValue);
    [DebuggerStepThroughAttribute]
[HandleProcessCorruptedStateExceptionsAttribute]
public static void CatchSilent(Action action);
    [DebuggerStepThroughAttribute]
[CanBeNullAttribute]
[HandleProcessCorruptedStateExceptionsAttribute]
public static TValue CatchSilent(Func`1<TValue> func, TValue defaultValue);
    [DebuggerStepThroughAttribute]
[CanBeNullAttribute]
[HandleProcessCorruptedStateExceptionsAttribute]
public static TValue CatchSilent(TState state, Func`2<TState, TValue> func, TValue defaultValue);
    [DebuggerStepThroughAttribute]
[HandleProcessCorruptedStateExceptionsAttribute]
public static TValue CatchIgnoreException(Func`1<TValue> F, TValue defaultValue);
    [DebuggerStepThroughAttribute]
[HandleProcessCorruptedStateExceptionsAttribute]
public static void CatchIgnoreException(Action action);
    [DebuggerStepThroughAttribute]
[HandleProcessCorruptedStateExceptionsAttribute]
[CanBeNullAttribute]
public static TValue CatchButOperationCanceledException(Func`1<TValue> f);
    [DebuggerStepThroughAttribute]
[HandleProcessCorruptedStateExceptionsAttribute]
[CanBeNullAttribute]
public static TValue CatchIgnoreButOperationCanceledException(Func`1<TValue> f);
    [DebuggerStepThroughAttribute]
[HandleProcessCorruptedStateExceptionsAttribute]
public static void CatchIgnoreButOperationCanceledException(Action f);
    [DebuggerStepThroughAttribute]
[HandleProcessCorruptedStateExceptionsAttribute]
public static void CatchButOperationCanceledException(Action action);
    [HandleProcessCorruptedStateExceptionsAttribute]
public static void CleanupOldLogFiles();
    [HandleProcessCorruptedStateExceptionsAttribute]
public static void CleanupOldLogFiles(FileSystemPath logFolder);
    [DebuggerStepThroughAttribute]
public static void DropException(Exception ex);
    public static void Fail(string messageText);
    public static void FailWithSensitiveData(string messageText, Pair`2[] sensitiveData);
    [StringFormatMethodAttribute("format")]
public static void Fail(string format, Object[] args);
    [StringFormatMethodAttribute("format")]
public static string FormatStringSafe(string format, Object[] args);
    public static FileSystemPath GetDefaultLogFile(string identity);
    [HandleProcessCorruptedStateExceptionsAttribute]
public static void Init();
    [HandleProcessCorruptedStateExceptionsAttribute]
public static void Init(Lifetime lifetime, Nullable`1<LoggingLevel> filelogginglevel);
    public static void LogError(string message);
    public static void LogErrorWithSensitiveData(string message, Pair`2[] sensitiveData, Object[] args);
    public static void LogErrorWithSensitiveData(string message, Pair`2[] sensitiveData);
    [StringFormatMethodAttribute("format")]
public static void LogError(string format, Object[] args);
    public static void LogException(Exception ex);
    public static void LogException(string comment, Exception ex);
    public static void LogExceptionSilently(Exception ex);
    public static void LogMessage(LoggingLevel level, string message);
    [StringFormatMethodAttribute("format")]
public static void LogMessage(LoggingLevel level, string format, Object[] args);
    public static void LogMessage(string message);
    [StringFormatMethodAttribute("format")]
public static void LogMessage(string format, Object[] args);
    public static ILogger get_Root();
    [PublicAPIAttribute]
[NotNullAttribute]
public static ILogger GetLogger();
    [PublicAPIAttribute]
[NotNullAttribute]
public static ILogger GetLogger(Type callerType);
    [PublicAPIAttribute]
[NotNullAttribute]
public static ILogger GetLogger(string fullClassName);
    [PublicAPIAttribute]
public static void AttachRootListener(Lifetime lf, ILogEventListener listener, LoggingLevel maxLevelToPass, IFilter[] filters);
    [PublicAPIAttribute]
public static void IncreaseCategoriesLevel(Lifetime lifetime, LoggingLevel level, String[] categories);
    [PublicAPIAttribute]
public static void AttachListener(Lifetime lifetime, Func`1<T> createListener, string category, string comments);
}
public class JetBrains.Util.Logging.LoggerConfigurationParseException : Exception {
    public LoggerConfigurationParseException(string str, Exception cause);
}
public static class JetBrains.Util.Logging.LoggerContext : object {
    public static ConcurrentDictionary`2<string, object> GlobalContext;
    private static LoggerContext();
}
public class JetBrains.Util.Logging.Loggers.IndentedLogger : object {
    private ILogger myLogger;
    [NotNullAttribute]
public string TabString;
    private int myIndent;
    public int Indent { get; public set; }
    public string Category { get; }
    public IndentedLogger(ILogger logger, string tabString);
    public int get_Indent();
    public void set_Indent(int value);
    public sealed virtual bool IsEnabled(LoggingLevel level);
    public sealed virtual void Log(LoggingLevel level, string message, Exception exception);
    public sealed virtual string get_Category();
    public sealed virtual void Log(LogEvent logEvent);
    private string IndentString(string input);
}
[ExtensionAttribute]
public static class JetBrains.Util.Logging.Loggers.IndentLoggerEx : object {
    [ExtensionAttribute]
[MustUseReturnValueAttribute]
public static LocalDisposable`1<ValueTuple`2<IndentedLogger, int>> Indent(IndentedLogger self, int level);
}
[ExtensionAttribute]
public static class JetBrains.Util.Logging.LoggerStructuredEx : object {
    [ExtensionAttribute]
private static void Log(ILog log, LogEvent evt);
    [ExtensionAttribute]
private static void LogMeasuredMetric_Documentation(LogWithLevel logger, string key, string message);
    [ExtensionAttribute]
public static void LogMeasurement(LogWithLevel logger, string key, long value, MetricUnit unit, string message);
    [ExtensionAttribute]
public static void LogMeasurement(ILogger logger, string key, long value, MetricUnit unit, string message, Nullable`1<long> threshold);
    [ExtensionAttribute]
public static void LogMeasuredTime(LogWithLevel logger, string key, long timeMs, string message);
    [ExtensionAttribute]
public static void LogMeasuredTime(ILogger logger, string key, long timeMs, string message, Nullable`1<TimeSpan> threshold);
    [ExtensionAttribute]
public static void LogMeasuredSize(LogWithLevel logger, string key, long bytes, string message);
    [ExtensionAttribute]
public static void LogMeasuredSize(ILogger logger, string key, long bytes, string message, Nullable`1<long> threshold);
    [ExtensionAttribute]
public static void LogMeasuredCount(LogWithLevel logger, string key, long count, string message);
    [ExtensionAttribute]
public static void LogMeasuredCount(ILogger logger, string key, long count, string message, Nullable`1<long> threshold);
    [ExtensionAttribute]
public static void LogMeasuredData(LogWithLevel logger, string key, string data);
    [ExtensionAttribute]
public static void LogMeasuredData(ILogger logger, string key, string message);
    [ExtensionAttribute]
public static void StructuredMarker(LogWithLevel logger, string key, string message);
    [ExtensionAttribute]
public static void StructuredMarker(ILogger logger, string key, string message);
    [ExtensionAttribute]
public static void DoActivity(Nullable`1<LogWithLevel> logger, string key, Action action);
    [ExtensionAttribute]
public static T DoCalculation(Nullable`1<LogWithLevel> logger, string key, Func`1<T> action);
    [ExtensionAttribute]
public static void DoActivity(Nullable`1<LogWithLevel> logger, string key, string message, Action action);
    [ExtensionAttribute]
public static T DoCalculation(Nullable`1<LogWithLevel> logWithLevel, string key, string message, Func`1<T> action, Func`2<T, string> report);
    [ExtensionAttribute]
public static void DoActivity(ILogger logger, string key, string message, Action action);
    [ExtensionAttribute]
public static T DoCalculation(ILogger logger, string key, string message, Func`1<T> action);
    [ExtensionAttribute]
public static IDisposable StopwatchCookie(Nullable`1<LogWithLevel> logger, string key, string message);
    [ExtensionAttribute]
public static IStopwatchCookie StopwatchCookie(ILogger logger, string key, string message, Nullable`1<TimeSpan> threshold);
    [ExtensionAttribute]
public static IDisposable PerformanceCookie(ILogger logger, string performanceMetric);
}
public class JetBrains.Util.Logging.LogManager : object {
    public static string LogConfigurationXmlResource;
    public static string LogConfigurationXsdResource;
    private ActiveXmlLogFile myActiveXmlLogFile;
    [NotNullAttribute]
public static LogManager Instance;
    [ThreadStaticAttribute]
private static bool ourResetReentrancyGuard;
    public static string EnvResharperTrace;
    private JetFileSystemWatcher myWatcher;
    private FileSystemPath myXmlConfigurationLocation;
    private FileSystemPath myBinConfigurationDirectory;
    [CompilerGeneratedAttribute]
private XmlLogConfigModel <Model>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DisableFileAutoUpdates>k__BackingField;
    [CompilerGeneratedAttribute]
private Action ConfigChanged;
    private ImmutableArray`1<Func`2<LogConfig, LogConfig>> myTransformations;
    private static string BinaryExt;
    private LogSubconfiguration mySubconfiguration;
    [NotNullAttribute]
internal OmnipresentLoggers OmnipresentLoggers;
    [CanBeNullAttribute]
private LogConfig myConfig;
    public LogConfig Config { get; }
    public XmlLogConfigModel Model { get; private set; }
    public bool DisableFileAutoUpdates { get; public set; }
    public bool DefaultConfigActive { get; }
    public int Timestamp { get; }
    private static LogManager();
    private void Reset();
    [NotNullAttribute]
private static String[] ParseTraceCategories();
    public LogConfig get_Config();
    [CompilerGeneratedAttribute]
public XmlLogConfigModel get_Model();
    [CompilerGeneratedAttribute]
private void set_Model(XmlLogConfigModel value);
    [CompilerGeneratedAttribute]
public bool get_DisableFileAutoUpdates();
    [CompilerGeneratedAttribute]
public void set_DisableFileAutoUpdates(bool value);
    [CompilerGeneratedAttribute]
public void add_ConfigChanged(Action value);
    [CompilerGeneratedAttribute]
public void remove_ConfigChanged(Action value);
    public void ApplyTransformation(Lifetime lifetime, string description, Func`2<LogConfig, LogConfig> transform);
    public bool get_DefaultConfigActive();
    public static FileSystemPath GetPrimaryXmlConfiguration(FileSystemPath xmlConfLocation, LogSubconfiguration subconfiguration);
    public FileSystemPath GetLogConfigurationFolder();
    public FileSystemPath GetPrimaryXmlConfiguration();
    private FileSystemPath GetPrimaryBinConfiguration();
    public FileSystemPath GetSecondaryXmlConfiguration();
    private FileSystemPath GetSecondaryBinConfiguration();
    public void AddOmnipresentLogger(Lifetime lf, ILogEventListener listener, LoggingLevel level, IFilter[] filters);
    public void Initialize(FileSystemPath xmlConfigurationLocation, LogSubconfiguration subconfiguration);
    private void InitFsw(FileSystemPath dir);
    private sealed virtual override void JetBrains.Util.JetFileSystemWatcher.IWatcherEvents.OnFileSystemChanged(FileSystemEvent[] events);
    private void ReconfigureFromFile();
    public void SetConfig(XmlLogConfigModel model, bool forceSet);
    private static FileSystemPath CalculateBinConfigurationDirectory(FileSystemPath xmlConfigurationLocation);
    public int get_Timestamp();
    internal LogConfNode GetMatchedConfNode(string namespace);
    private sealed virtual override ILog JetBrains.Diagnostics.ILogFactory.GetLog(string category);
    [NotNullAttribute]
public ILogger GetLogger(string category);
    [NotNullAttribute]
public ILogger GetLogger(Type callerType);
    public sealed virtual void Dispose();
    public static void CreateLogConfigXmlFile(FileSystemPath path);
    [CompilerGeneratedAttribute]
private void <InitFsw>b__43_0();
    [CompilerGeneratedAttribute]
internal static Guid <CalculateBinConfigurationDirectory>g__CalculateHash|47_0(Guid mvid, string xmlLocation, string assemblyLocation);
}
public static class JetBrains.Util.Logging.LogSerializer : object {
    [NotNullAttribute]
public static XmlLogConfigModel LoadFromXml(FileSystemPath xml);
    public static void StoreToXml(XmlLogConfigModel logModel, FileSystemPath xml);
    [NotNullAttribute]
public static XmlLogConfigModel LoadFromBinary(FileSystemPath binary);
    public static void StoreToBinary(XmlLogConfigModel logModel, FileSystemPath binary);
}
public enum JetBrains.Util.Logging.LogSubconfiguration : Enum {
    public int value__;
    public static LogSubconfiguration Debug;
    public static LogSubconfiguration Test;
    public static LogSubconfiguration Release;
    public static LogSubconfiguration Cmd;
}
[UsedImplicitlyAttribute]
public class JetBrains.Util.Logging.MessageBoxLogEventListener : object {
    private Regex myRegex;
    [CompilerGeneratedAttribute]
private ILayout <Layout>k__BackingField;
    [CompilerGeneratedAttribute]
private IFilter[] <Filters>k__BackingField;
    public ILayout Layout { get; public set; }
    public IFilter[] Filters { get; public set; }
    public MessageBoxLogEventListener(string pattern);
    private void Show();
    [CompilerGeneratedAttribute]
public sealed virtual ILayout get_Layout();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Layout(ILayout value);
    public sealed virtual void OnLogEvent(LogEvent logEvent);
    [CompilerGeneratedAttribute]
public sealed virtual IFilter[] get_Filters();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Filters(IFilter[] value);
}
public enum JetBrains.Util.Logging.MetricUnit : Enum {
    public int value__;
    public static MetricUnit Milliseconds;
    public static MetricUnit Bytes;
    public static MetricUnit Count;
}
[ExtensionAttribute]
internal static class JetBrains.Util.Logging.MetricUnitExtensions : object {
    [ExtensionAttribute]
public static string GetName(MetricUnit unit);
}
public class JetBrains.Util.Logging.OmnipresentLogger : object {
    [CompilerGeneratedAttribute]
private ILogEventListener <Listener>k__BackingField;
    [CompilerGeneratedAttribute]
private LoggingLevel <Level>k__BackingField;
    [CompilerGeneratedAttribute]
private IFilter[] <Filters>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public ILogEventListener Listener { get; public set; }
    public LoggingLevel Level { get; public set; }
    public IFilter[] Filters { get; public set; }
    public OmnipresentLogger(ILogEventListener Listener, LoggingLevel Level, IFilter[] Filters);
    [CompilerGeneratedAttribute]
protected OmnipresentLogger(OmnipresentLogger original);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public ILogEventListener get_Listener();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Listener(ILogEventListener value);
    [CompilerGeneratedAttribute]
public LoggingLevel get_Level();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Level(LoggingLevel value);
    [CompilerGeneratedAttribute]
public IFilter[] get_Filters();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Filters(IFilter[] value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(OmnipresentLogger left, OmnipresentLogger right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(OmnipresentLogger left, OmnipresentLogger right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(OmnipresentLogger other);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual OmnipresentLogger <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(ILogEventListener& Listener, LoggingLevel& Level, IFilter[]& Filters);
}
public class JetBrains.Util.Logging.OmnipresentLoggers : object {
    [CompilerGeneratedAttribute]
private LoggingLevel <AggregateLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<OmnipresentLogger> <Loggers>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public LoggingLevel AggregateLevel { get; public set; }
    public ImmutableArray`1<OmnipresentLogger> Loggers { get; public set; }
    public OmnipresentLoggers(LoggingLevel AggregateLevel, ImmutableArray`1<OmnipresentLogger> Loggers);
    public OmnipresentLoggers(ImmutableArray`1<OmnipresentLogger> loggers);
    [CompilerGeneratedAttribute]
protected OmnipresentLoggers(OmnipresentLoggers original);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public LoggingLevel get_AggregateLevel();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_AggregateLevel(LoggingLevel value);
    [CompilerGeneratedAttribute]
public ImmutableArray`1<OmnipresentLogger> get_Loggers();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Loggers(ImmutableArray`1<OmnipresentLogger> value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(OmnipresentLoggers left, OmnipresentLoggers right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(OmnipresentLoggers left, OmnipresentLoggers right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(OmnipresentLoggers other);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual OmnipresentLoggers <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(LoggingLevel& AggregateLevel, ImmutableArray`1& Loggers);
}
public class JetBrains.Util.Logging.OuterWorldException : Exception {
    public OuterWorldException(string message);
    public OuterWorldException(string message, Exception innerException);
    protected OuterWorldException(SerializationInfo info, StreamingContext context);
}
public class JetBrains.Util.Logging.PatternLayout : LayoutBase {
    private static long ourOffsetFromUtc;
    private Object[] myPartProducers;
    public static string DefaultLayoutPattern;
    private Object[] myDefaultLayoutPatternPreParsed;
    public static string DefaultLayoutPatternNoTime;
    private Object[] myDefaultLayoutPatternNoTimePreParsed;
    public PatternLayout(string pattern);
    private static PatternLayout();
    private static int ParseIntArg(string str);
    private static string SplitSuffixParts(string str, int nSufixParts, char delimiter);
    private static string GetMainModuleName();
    public static string FormatDateFast(DateTime t);
    private static void FormatInt2(Char[] c, Int32& pos, int x);
    private static void FormatInt3(Char[] c, Int32& pos, int x);
    private static DateTime ToLocalDateTimeFast(DateTime dateTime);
    public virtual void FormatUnsafe(UnsafeWriter writer, LogEvent logEvent);
}
public class JetBrains.Util.Logging.SimpleLayout : LayoutBase {
    public static SimpleLayout Instance;
    private static PatternLayout ourLayout;
    private static SimpleLayout();
    public virtual void FormatUnsafe(UnsafeWriter writer, LogEvent logEvent);
}
public class JetBrains.Util.Logging.XmlAppenderModel : object {
    internal static string AppenderEltName;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<string> <Params>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Pattern>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<FilterModel> <Filters>k__BackingField;
    private Lazy`1<IConfigurableLogEventListener> myBuiltItem;
    [NotNullAttribute]
public string Name { get; }
    [NotNullAttribute]
public Type Type { get; }
    [NotNullAttribute]
public IReadOnlyCollection`1<string> Params { get; }
    [NotNullAttribute]
public string Pattern { get; }
    [NotNullAttribute]
public IReadOnlyCollection`1<FilterModel> Filters { get; }
    [NotNullAttribute]
public IConfigurableLogEventListener BuiltItem { get; }
    public XmlAppenderModel(string name, Type type, List`1<FilterModel> filters, string pattern, IEnumerable`1<string> parameters);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public Type get_Type();
    [CompilerGeneratedAttribute]
public IReadOnlyCollection`1<string> get_Params();
    [CompilerGeneratedAttribute]
public string get_Pattern();
    [CompilerGeneratedAttribute]
public IReadOnlyCollection`1<FilterModel> get_Filters();
    protected virtual IConfigurableLogEventListener Build();
    public IConfigurableLogEventListener get_BuiltItem();
    public sealed virtual bool Equals(XmlAppenderModel other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static XmlAppenderModel LoadFromXml(XmlElement elt);
    public void StoreToXml(XmlElement parent);
    public static XmlAppenderModel LoadFromBinary(BinaryReader reader);
    private static List`1<FilterModel> ReadFilters(BinaryReader reader);
    public void StoreToBinary(BinaryWriter writer);
    private sealed virtual override object System.ICloneable.Clone();
    public sealed virtual XmlAppenderModel Clone();
}
public class JetBrains.Util.Logging.XmlLogConfigModel : object {
    public static string TopElt;
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<XmlAppenderModel> <Appenders>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<XmlLoggerModel> <Loggers>k__BackingField;
    internal static XmlLogConfigModel DefaultModel;
    public IReadOnlyCollection`1<XmlAppenderModel> Appenders { get; }
    public IReadOnlyCollection`1<XmlLoggerModel> Loggers { get; }
    private static XmlLogConfigModel();
    public XmlLogConfigModel(IEnumerable`1<XmlAppenderModel> appenders, IEnumerable`1<XmlLoggerModel> loggers);
    public XmlLogConfigModel(XmlAppenderModel appender, XmlLoggerModel xmlLoggerModel);
    [CompilerGeneratedAttribute]
public IReadOnlyCollection`1<XmlAppenderModel> get_Appenders();
    [CompilerGeneratedAttribute]
public IReadOnlyCollection`1<XmlLoggerModel> get_Loggers();
    public static XmlLogConfigModel LoadFromXml(XmlElement topElt);
    public static XmlLogConfigModel LoadFromBinary(BinaryReader reader);
    public void StoreToXml(XmlDocument doc);
    public void StoreToBinary(BinaryWriter writer);
    public sealed virtual bool Equals(XmlLogConfigModel other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual XmlLogConfigModel Clone();
    private sealed virtual override object System.ICloneable.Clone();
    [NotNullAttribute]
internal LogConfig Build();
    public XmlLogConfigModel WithLoggers(IEnumerable`1<XmlLoggerModel> loggers);
    public XmlLogConfigModel WithAppenders(IEnumerable`1<XmlAppenderModel> appenders);
}
public class JetBrains.Util.Logging.XmlLoggerModel : object {
    public static string LoggerEltName;
    public static string RootEltName;
    [CompilerGeneratedAttribute]
private string <Category>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<LoggingLevel> <Level>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Additivity>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<XmlAppenderModel> <Appenders>k__BackingField;
    [NotNullAttribute]
public string Category { get; }
    public Nullable`1<LoggingLevel> Level { get; }
    public bool Additivity { get; }
    public ImmutableArray`1<XmlAppenderModel> Appenders { get; }
    public XmlLoggerModel(string category, Nullable`1<LoggingLevel> level, IEnumerable`1<XmlAppenderModel> appenders, bool additivity);
    [CompilerGeneratedAttribute]
public string get_Category();
    [CompilerGeneratedAttribute]
public Nullable`1<LoggingLevel> get_Level();
    [CompilerGeneratedAttribute]
public bool get_Additivity();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<XmlAppenderModel> get_Appenders();
    [NotNullAttribute]
public static XmlLoggerModel LoadFromXml(XmlElement elt, Dictionary`2<string, XmlAppenderModel> appMap);
    public void StoreToXml(XmlElement parent);
    public static XmlLoggerModel LoadFromBinary(BinaryReader reader, Dictionary`2<string, XmlAppenderModel> appMap);
    public void StoreToBinary(BinaryWriter writer);
    private static Nullable`1<LoggingLevel> ParseLevel(string strLevel);
    public LogConfNode Build();
    public sealed virtual bool Equals(XmlLoggerModel other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class JetBrains.Util.LoggingLevelStrings : object {
    internal static String[] Short;
    internal static String[] Full;
    private static LoggingLevelStrings();
}
[ExtensionAttribute]
public static class JetBrains.Util.Maths.Hashes : object {
    public static UInt32 MurmurHashSeed;
    private static Hashes();
    public static OWORD MurmurHash3_128_x86(ReadOnlySpan`1<byte> span, UInt32 seed);
    public static OWORD MurmurHash3_128_x86(ReadOnlySpan`1<TItem> span, UInt32 seed);
    public static OWORD MurmurHash3_128_x86(Byte* pData, UInt32 nLen, UInt32 seed);
    public static OWORD MurmurHash3_128_x86(Byte* pData, UInt32 nLen, OWORD seed);
    public static OWORD MurmurHash3_128_x64(ReadOnlySpan`1<byte> span, UInt32 seed);
    public static OWORD MurmurHash3_128_x64(ReadOnlySpan`1<TItem> span, UInt32 seed);
    public static OWORD MurmurHash3_128_x64(Byte* pData, UInt32 nLen, UInt32 seed);
    public static OWORD MurmurHash3_128_x64(Byte* pData, UInt32 nLen, OWORD seed);
    public static OWORD MurmurHash3_128_x86(string text);
    [ExtensionAttribute]
public static int MurmurHash3(string text);
    public static int MurmurHash3_Parts(Byte* pData1, int nLen1, Byte* pData2, int nLen2, UInt32 seed);
    public static int MurmurHash3(Byte* pData, int nLen, UInt32 seed);
}
public static class JetBrains.Util.Maths.MathUtil : object {
    public static bool GetNearestPow2(long number, Int64& lessPow2, Int64& higherPow2);
    public static long GetNearestLessPowOf2(long number);
    public static long GetNearestHigherPowOf2(long number);
    public static long RoundToNearestPowOf2(long number);
    public static long GetBinaryLogBase(long number);
}
public class JetBrains.Util.Maths.OWORD : ValueType {
    public ulong loqword;
    public ulong hiqword;
    public UInt32 dword0;
    public UInt32 dword1;
    public UInt32 dword2;
    public UInt32 dword3;
    public OWORD(ulong loqword, ulong hiqword);
    public OWORD(UInt32 dword0, UInt32 dword1, UInt32 dword2, UInt32 dword3);
    public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(OWORD other);
    public sealed virtual bool Equals(OWORD other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static bool op_Equality(OWORD black, OWORD white);
    public static bool op_Inequality(OWORD black, OWORD white);
    public static OWORD op_Implicit(ulong qw);
    public static OWORD op_Modulus(OWORD black, OWORD white);
    public static OWORD op_BitwiseOr(OWORD black, OWORD white);
    public static OWORD op_BitwiseAnd(OWORD black, OWORD white);
    public static OWORD op_OnesComplement(OWORD black);
}
public static class JetBrains.Util.Memory.MemoryUtil : object {
    public static int CopyMemoryPinvokeThreshold;
    private static UInt32 myBufferCacheTotalAllocatedApprox;
    private static UInt32 myBufferCacheAllocationLimit;
    [NotNullAttribute]
private static ConcurrentQueue`1<Byte[]> myBufferCache;
    public static int ByteBufferUnderlohSize;
    private static ulong myTotalVirtualMemory;
    private static ulong myMachinePhysicalMemory;
    private static MemoryUtil();
    public static void MoveMemory(Void* pSrc, Void* pDst, UInt32 cbLen);
    public static void CopyMemory(Void* pSrc, Void* pDst, UInt32 cbLen);
    public static void CopyMemory(Void* pSrc, Byte[] dst, UInt32 cbDstOffset, UInt32 cbLen);
    public static void CopyMemory(Byte[] src, UInt32 cbSrcOffset, Void* pDst, UInt32 cbLen);
    public static void CopyMemory(Byte[] src, UInt32 cbSrcOffset, Byte[] dst, UInt32 cbDstOffset, UInt32 cbLen);
    public static void CopyMemory(Byte* src, Byte* dest, int len);
    public static void CopyMemoryNormal(Void* pSrc, Void* pDst, UInt32 cbLen);
    public static void CopyMemoryReverse(Void* pSrc, Void* pDst, UInt32 cbLen);
    public static void CopyString(string s, Void* buf);
    public static void ZeroMemory(Void* p, UInt32 cb);
    public static bool memcmp(Byte* src, Byte* dest, int len);
    public static bool memcmp(Void* p1, UInt32 cb1, Void* p2, UInt32 cb2);
    public static Byte* memmem(Byte* haystack, int haystacklen, Byte* needle, int needlelen);
    public static bool IsBlittable();
    public static bool IsBlittable(Type type);
    public static LentBuffer UsingBuffer();
    public static ObjectReference[] GetReachingPath(object obj, Object[] roots);
    public static ulong GetAvailablePhysicalMemory();
    public static ulong GetTotalVirtualMemory();
    public static ulong GetMachinePhysicalMemory();
    public static void FlushMemoryMappedFileDirtyPagesToDisk(FileSystemPath file);
}
public class JetBrains.Util.Memory.ObjectReference : object {
    private object myObject;
    private FieldInfo myFieldInfo;
    public object Object { get; }
    public FieldInfo FieldInfo { get; }
    public ObjectReference(object obj, FieldInfo fieldInfo);
    public ObjectReference(FieldInfo fieldInfo);
    public object get_Object();
    public FieldInfo get_FieldInfo();
    public virtual string ToString();
}
public class JetBrains.Util.Misc.JetProgress : object {
    public static JetProgress Noop;
    private Action myYield;
    private Action myAdvance;
    private Action myFinish;
    private long myStepsCount;
    private long myCurrentStep;
    private int myTicks;
    public JetProgress(Action yield, Action advance);
    public JetProgress(Action yield, Action advance, Action finish);
    private static JetProgress();
    public void Begin(long stepsCount);
    public bool YieldAndAdvance(int yieldPeriod);
    public bool Yield(int period);
    public sealed virtual void Dispose();
    private void DoYield();
    private void DoAdvance();
    public JetProgress AsYielder();
    public static JetProgress FromCancellationToken(CancellationToken token);
}
[PublicAPIAttribute]
[ObsoleteAttribute("Use JetBrains.Diagnostics.ProcessWatchdog instead")]
public static class JetBrains.Util.Misc.ProcessWatchdog : object {
    private static ILog ourLogger;
    private static int DELAY_BEFORE_RETRY;
    private static int ERROR_INVALID_PARAMETER;
    private static ProcessWatchdog();
    public static void StartWatchdogForPidEnvironmentVariable(string envVarName);
    public static void StartWatchdogForPidEnvironmentVariable(string envVarName, Lifetime lifetime);
    public static void StartWatchdogForPid(int pid);
    public static void StartWatchdogForPid(int pid, Lifetime lifetime);
    private static int kill(int pid, int sig);
    public static bool ProcessExists(int pid, Boolean& useWinApi);
    private static bool ProcessExists_Windows(int pid);
    private static bool ProcessExists_SystemDiagnostics(int pid);
}
[ExtensionAttribute]
public static class JetBrains.Util.NativeDllEx : object {
    private static string UnixLibraryPrefix;
    [NotNullAttribute]
public static string MakeExecutableName(string fileName);
    [NotNullAttribute]
public static string MakeExecutableName(JetPlatform platform, string fileName);
    [NotNullAttribute]
public static string MakeSharedLibraryName(string fileName);
    [NotNullAttribute]
public static string MakeSharedLibraryName(JetPlatform platform, string fileName);
    public static bool IsSharedLibraryName(string fileName);
    public static bool IsSharedLibraryName(JetPlatform platform, string fileName);
    [NotNullAttribute]
public static string MakeStaticLibraryName(string fileName);
    [NotNullAttribute]
public static string MakeStaticLibraryName(JetPlatform platform, string fileName);
    [NotNullAttribute]
public static RelativePath GetProductNativeDir(JetRuntimeId runtimeId, bool debug);
    [NotNullAttribute]
public static RelativePath GetNativeDir(Postfix postfix, JetRuntimeId runtimeId, bool debug);
    [ExtensionAttribute]
[NotNullAttribute]
private static string GetFolderName(Postfix postfix);
}
public static class JetBrains.Util.NounUtil : object {
    private static Dictionary`2<string, string> ourPlurals;
    private static Dictionary`2<string, string> ourSingulars;
    private static NounUtil();
    public static string GetPlural(string singular);
    public static string GetSingular(string plural);
    public static bool IsSingular(string noun);
    [NotNullAttribute]
public static string ToPluralOrSingular(string singular, int count);
    [NotNullAttribute]
public static string ToPluralOrSingular(string singular, UInt32 count);
    [NotNullAttribute]
public static string ToPluralOrSingularQuick(int count, string singular, string plural);
    [NotNullAttribute]
public static string IntToStringWithNoun(int count, string singularNoun, string pluralNoun);
    public static string GetCountString(int argumentIndex);
}
public class JetBrains.Util.OnError : object {
    private string myName;
    private Action`1<Exception> myHandler;
    private bool myIsIgnoringMessage;
    public static OnError Ignore;
    public static OnError LogException;
    public static OnError LogExceptionSilently;
    [NotNullAttribute]
public static OnError Throw;
    public bool IsIgnoringMessage { get; }
    public OnError(string name, Action`1<Exception> handler, bool isIgnoringMessage);
    private static OnError();
    public bool get_IsIgnoringMessage();
    [NotNullAttribute]
public static OnError ThrowMessage(string message);
    [NotNullAttribute]
public static OnError LogAssertion(ILogger logger);
    [NotNullAttribute]
public static OnError LogAlgorithmError(ILogger logger);
    [NotNullAttribute]
public static OnError Error(ILogger logger);
    [NotNullAttribute]
public static OnError Warn(ILogger logger);
    [NotNullAttribute]
public static OnError Verbose(ILogger logger, string extmessage, bool isFullException);
    [NotNullAttribute]
public static OnError Info(ILogger logger, string extmessage, bool isFullException);
    [NotNullAttribute]
public static OnError LogForeignException(ILogger logger);
    [NotNullAttribute]
public static OnError Trace(ILogger logger, string extmessage);
    public void Handle(Exception ex);
    public virtual string ToString();
    [NotNullAttribute]
public OnError WithMessage(string message);
    [DebuggerStepThroughAttribute]
[HandleProcessCorruptedStateExceptionsAttribute]
public void Catch(Action action);
    [DebuggerStepThroughAttribute]
[CanBeNullAttribute]
[HandleProcessCorruptedStateExceptionsAttribute]
public TValue Catch(Func`1<TValue> func);
}
[DefaultMemberAttribute("Item")]
[DebuggerTypeProxyAttribute("JetBrains.Util.OneToListMap`2/OneToListMapDebugView")]
[DebuggerDisplayAttribute("Count = {Count}")]
public class JetBrains.Util.OneToListMap`2 : object {
    private IEqualityComparer`1<TValue> myValueComparer;
    private Dictionary`2<TKey, OneToListItems<TKey, TValue>> myMap;
    public int Count { get; }
    [NotNullAttribute]
public ICollection`1<TKey> Keys { get; }
    public ValueCollection<TKey, TValue> Item { get; }
    [NotNullAttribute]
public IEnumerable`1<TValue> Values { get; }
    public OneToListMap`2(IEnumerable`1<KeyValuePair`2<TKey, IList`1<TValue>>> enumerable, IEqualityComparer`1<TKey> comparer);
    public OneToListMap`2(IEnumerable`1<KeyValuePair`2<TKey, IList`1<TValue>>> enumerable, IEqualityComparer`1<TKey> keyComparer, IEqualityComparer`1<TValue> valueComparer);
    public OneToListMap`2(int capacity, IEqualityComparer`1<TKey> comparer);
    public OneToListMap`2(int capacity, IEqualityComparer`1<TKey> keyComparer, IEqualityComparer`1<TValue> valueComparer);
    public OneToListMap`2(IEnumerable`1<KeyValuePair`2<TKey, IList`1<TValue>>> enumerable);
    public OneToListMap`2(IEqualityComparer`1<TKey> comparer);
    public OneToListMap`2(IEqualityComparer`1<TKey> keyComparer, IEqualityComparer`1<TValue> valueComparer);
    public OneToListMap`2(int capacity);
    public OneToListMap`2(OneToListMap`2<TKey, TValue> oneToListMap);
    public int get_Count();
    public void Clear();
    public sealed virtual ICollection`1<TKey> get_Keys();
    public ValueCollection<TKey, TValue> get_Item(TKey key);
    public void AddValue(TKey key, TValue value);
    [NotNullAttribute]
public sealed virtual IList`1<TValue> GetValuesSafe(TKey key);
    public sealed virtual void Add(TKey key, TValue value);
    public void InsertValue(int index, TKey key, TValue value);
    public void AddValueRange(TKey key, IEnumerable`1<TValue> list);
    public bool RemoveValueRange(TKey key, IEnumerable`1<TValue> list);
    public bool RemoveValue(TKey key, TValue value);
    public sealed virtual bool Remove(TKey key, TValue value);
    public bool RemoveKey(TKey key);
    public bool ContainsKey(TKey key);
    public bool TryFindValue(TValue value, TKey& key);
    public bool ContainsValue(TValue value);
    public bool ContainsPair(TKey key, TValue value);
    [CanBeNullAttribute]
private OneToListItems<TKey, TValue> GetValues(TKey key);
    [NotNullAttribute]
public JetReadOnlyCollection`1<TValue> GetValuesCollection(TKey key);
    [IteratorStateMachineAttribute("JetBrains.Util.OneToListMap`2/<GetEnumerator>d__36")]
public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, IList`1<TValue>>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public void ClearKey(TKey key);
    public IEnumerable`1<TValue> get_Values();
    public void TrimExcess();
    public void InternAllKeys(Func`2<TKey, TKey> internFunc);
}
[ExtensionAttribute]
public static class JetBrains.Util.OneToListMapExtensions : object {
    [ExtensionAttribute]
public static void Add(OneToListMap`2<TKey, TValue> map, Lifetime lifetime, TKey key, TValue value);
    [ExtensionAttribute]
public static void InsertValue(OneToListMap`2<TKey, TValue> map, Lifetime lifetime, int index, TKey key, TValue value);
    [ExtensionAttribute]
public static void AddRange(OneToListMap`2<TKey, TValue> map, Lifetime lifetime, TKey key, IEnumerable`1<TValue> values);
    [ExtensionAttribute]
public static void AddRange(OneToListMap`2<TKey, TValue> map, IEnumerable`1<KeyValuePair`2<TKey, IList`1<TValue>>> pairs);
}
[DefaultMemberAttribute("Item")]
[DebuggerTypeProxyAttribute("JetBrains.Util.OneToSetMap`2/OneToSetMapDebugView")]
[DebuggerDisplayAttribute("Count = {Count}")]
public class JetBrains.Util.OneToSetMap`2 : object {
    [NotNullAttribute]
private Dictionary`2<TKey, ItemsSet<TKey, TValue>> myMap;
    [CanBeNullAttribute]
private IEqualityComparer`1<TValue> myValueComparer;
    public int Count { get; }
    [NotNullAttribute]
public ICollection`1<TKey> Keys { get; }
    [NotNullAttribute]
public ValuesCollection<TKey, TValue> Values { get; }
    [NotNullAttribute]
public ISet`1<TValue> Item { get; }
    public OneToSetMap`2(OneToSetMap`2<TKey, TValue> other);
    public OneToSetMap`2(IEqualityComparer`1<TKey> keyComparer);
    public OneToSetMap`2(int capacity, IEqualityComparer`1<TKey> keyComparer, IEqualityComparer`1<TValue> valueComparer);
    public void Clear();
    public int get_Count();
    public sealed virtual ICollection`1<TKey> get_Keys();
    public ValuesCollection<TKey, TValue> get_Values();
    public ISet`1<TValue> get_Item(TKey key);
    [NotNullAttribute]
[PureAttribute]
public IReadOnlyCollection`1<TValue> GetReadOnlyValues(TKey key);
    public bool AddRange(TKey key, IEnumerable`1<TValue> values);
    [NotNullAttribute]
public sealed virtual ISet`1<TValue> GetValuesSafe(TKey key);
    public HashSetReader`1<TValue> GetReadonlyValue(TKey key);
    public bool Add(TKey key, TValue value);
    private sealed virtual override void JetBrains.Util.IOneToManyMap<TKey,TValue,System.Collections.Generic.ISet<TValue>>.Add(TKey key, TValue value);
    public sealed virtual bool Remove(TKey key, TValue value);
    public bool RemoveKey(TKey key);
    [PureAttribute]
public bool ContainsKey(TKey key);
    [PureAttribute]
public bool ContainsPair(TKey key, TValue value);
    [CanBeNullAttribute]
private ItemsSet<TKey, TValue> TryGetValues(TKey key);
    [IteratorStateMachineAttribute("JetBrains.Util.OneToSetMap`2/<GetEnumerator>d__25")]
public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, ISet`1<TValue>>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [NotNullAttribute]
public OneToSetMapDiff`1<TKey> Diff(OneToSetMap`2<TKey, TValue> other);
    public void InternAllKeys(Func`2<TKey, TKey> internFunc);
    public void InternAllKeysAndValues(Func`2<TKey, TKey> keyInternFunc, Func`2<TValue, TValue> valueInternFunc);
}
public class JetBrains.Util.OneToSetMapDiff`1 : object {
    [CompilerGeneratedAttribute]
private JetHashSet`1<TKey> <NewKeys>k__BackingField;
    [CompilerGeneratedAttribute]
private JetHashSet`1<TKey> <ChangedKeys>k__BackingField;
    [CompilerGeneratedAttribute]
private JetHashSet`1<TKey> <RemovedKeys>k__BackingField;
    public JetHashSet`1<TKey> NewKeys { get; }
    public JetHashSet`1<TKey> ChangedKeys { get; }
    public JetHashSet`1<TKey> RemovedKeys { get; }
    public bool IsSomethingChanged { get; }
    public OneToSetMapDiff`1(JetHashSet`1<TKey> newKeys, JetHashSet`1<TKey> changedKeys, JetHashSet`1<TKey> removedKeys);
    [CompilerGeneratedAttribute]
public JetHashSet`1<TKey> get_NewKeys();
    [CompilerGeneratedAttribute]
public JetHashSet`1<TKey> get_ChangedKeys();
    [CompilerGeneratedAttribute]
public JetHashSet`1<TKey> get_RemovedKeys();
    public bool get_IsSomethingChanged();
}
[ExtensionAttribute]
public static class JetBrains.Util.OneToSetMapExtensions : object {
    [ExtensionAttribute]
public static void Add(OneToSetMap`2<TKey, TValue> map, Lifetime lifetime, TKey key, TValue value);
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Util.OrderedHashSet`1 : object {
    private JetHashSet`1<T> myHashSet;
    private List`1<T> myList;
    public T Item { get; public set; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public IEqualityComparer`1<T> Comparer { get; }
    public OrderedHashSet`1(int capacity, IEqualityComparer`1<T> comparer);
    public OrderedHashSet`1(IEqualityComparer`1<T> comparer);
    public OrderedHashSet`1(ICollection`1<T> other, IEqualityComparer`1<T> comparer);
    public OrderedHashSet`1(IEnumerable`1<T> other, IEqualityComparer`1<T> comparer);
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    public sealed virtual void UnionWith(IEnumerable`1<T> other);
    public sealed virtual void IntersectWith(IEnumerable`1<T> other);
    public sealed virtual void ExceptWith(IEnumerable`1<T> other);
    public sealed virtual void SymmetricExceptWith(IEnumerable`1<T> other);
    public sealed virtual bool IsSubsetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsSupersetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsProperSupersetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsProperSubsetOf(IEnumerable`1<T> other);
    public sealed virtual bool Overlaps(IEnumerable`1<T> other);
    public sealed virtual bool SetEquals(IEnumerable`1<T> other);
    public sealed virtual int IndexOf(T item);
    public sealed virtual void Insert(int index, T item);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    public void AddAll(IEnumerable`1<T> other);
    public sealed virtual bool Remove(T item);
    public bool ContainsAll(ICollection`1<T> otherCollection);
    public sealed virtual bool Add(T item);
    public sealed virtual void Clear();
    public void RemoveAll(ICollection`1<T> otherCollection);
    public T[] ToArray();
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public bool get_IsSynchronized();
    public object get_SyncRoot();
    public T ElementAt(int index);
    public void Sort(IComparer`1<T> comparer);
    public sealed virtual IEqualityComparer`1<T> get_Comparer();
}
[ExtensionAttribute]
public static class JetBrains.Util.Pair : object {
    [PureAttribute]
[DebuggerStepThroughAttribute]
public static Pair`2<T1, T2> Of(T1 first, T2 second);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
[DebuggerStepThroughAttribute]
public static IEnumerable`1<T1> GetFirsts(IEnumerable`1<Pair`2<T1, T2>> pairs);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
[DebuggerStepThroughAttribute]
public static IEnumerable`1<T2> GetSeconds(IEnumerable`1<Pair`2<T1, T2>> pairs);
}
public class JetBrains.Util.Pair`2 : ValueType {
    public T1 First;
    public T2 Second;
    [NotNullAttribute]
public static IEqualityComparer`1<Pair`2<T1, T2>> EqualityComparer;
    [NotNullAttribute]
public static IComparer`1<Pair`2<T1, T2>> Comparer;
    public static Pair`2<T1, T2> Empty;
    [DebuggerStepThroughAttribute]
public Pair`2(T1 first, T2 second);
    private static Pair`2();
    public sealed virtual bool Equals(Pair`2<T1, T2> other);
    public virtual bool Equals(object obj);
    [PureAttribute]
[DebuggerStepThroughAttribute]
public virtual int GetHashCode();
    public sealed virtual int CompareTo(Pair`2<T1, T2> other);
    [PureAttribute]
[DebuggerStepThroughAttribute]
public Pair`2<T2, T1> Reverse();
    public virtual string ToString();
    [PureAttribute]
[DebuggerStepThroughAttribute]
public bool IsEmpty();
    public void Deconstruct(T1& first, T2& second);
}
public static class JetBrains.Util.Paths.SoftLinks : object {
    public static void DeleteDirectorySoftLink(FileSystemPath sourcedir);
    public static bool IsDirectorySoftLinkSource(FileSystemPath sourcedir);
    public static bool IsDirectorySupportsSoftLinks(FileSystemPath sourcedir);
    public static void CreateNewSoftLinkForDirectory(FileSystemPath targetDir, FileSystemPath linkDir, bool canRewriteOldLink);
    public static void SetDirectorySoftLink(FileSystemPath sourcedir, FileSystemPath targetdir);
    [CanBeNullAttribute]
public static FileSystemPath TryGetDirectorySoftLinkTarget(FileSystemPath sourcedir);
}
[FlagsAttribute]
public enum JetBrains.Util.PathSearchFlags : Enum {
    public int value__;
    public static PathSearchFlags RecurseIntoSubdirectories;
    public static PathSearchFlags ExcludeHidden;
    public static PathSearchFlags ExcludeFiles;
    public static PathSearchFlags ExcludeDirectories;
}
public class JetBrains.Util.PathWildcard : object {
    public static PathWildcard Empty;
    private Wildcard[] myWildcards;
    public PathWildcard(string pattern, bool caseSensitive, bool removeTwoDots);
    internal PathWildcard(Wildcard[] wildcards);
    private static PathWildcard();
    public bool Matches(string path);
    public MatchResult GetMatchResult(string path);
    private static bool IsDirectorySeparator(char c);
    private static MatchResult GetMatchResult(string path, Wildcard[] wildcards);
    public IEnumerable`1<VirtualFileSystemPath> GetMatchingPathsUnderRoot(VirtualFileSystemPath root, ICollection`1<PathWildcard> skippedPaths, ICollection`1<string> alwaysSkippedParts);
    [IteratorStateMachineAttribute("JetBrains.Util.PathWildcard/<GetMatchingPathsUnderRoot>d__9")]
private static IEnumerable`1<VirtualFileSystemPath> GetMatchingPathsUnderRoot(VirtualFileSystemPath root, Wildcard[] wildcards, ICollection`1<PathWildcard> skippedPaths, ICollection`1<string> alwaysSkippedParts);
    [IteratorStateMachineAttribute("JetBrains.Util.PathWildcard/<GetMatchesForRoot>d__10")]
private static IEnumerable`1<VirtualFileSystemPath> GetMatchesForRoot(VirtualFileSystemPath originalRoot, VirtualFileSystemPath baseDir, VirtualFileSystemPath root, Wildcard[] wildcards, ICollection`1<PathWildcard> skippedPaths, ICollection`1<string> alwaysSkippedParts);
    private static Wildcard[] StripStars(Wildcard[] wildcards);
    private static bool IsToSkip(string subPath, ICollection`1<PathWildcard> skippedPaths);
    public virtual string ToString();
}
public class JetBrains.Util.PersistentMap.ComparableStringMarshaller : object {
    public static ComparableStringMarshaller IgnoreCase;
    public static ComparableStringMarshaller CaseSensitive;
    private bool myIgnoreCase;
    public ComparableStringMarshaller(bool ignoreCase);
    private static ComparableStringMarshaller();
    public sealed virtual void Marshal(UnsafeWriter writer, string value);
    public sealed virtual string Unmarshal(UnsafeReader reader);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.Util.PersistentMap.Intern.InternedStringsMarshallerParameters : object {
    [CompilerGeneratedAttribute]
private int <StringLengthLimit>k__BackingField;
    [CompilerGeneratedAttribute]
private Encoding <Encoding>k__BackingField;
    public static InternedStringsMarshallerParameters Default;
    [CompilerGeneratedAttribute]
private Type EqualityContract { get; }
    public int StringLengthLimit { get; }
    public Encoding Encoding { get; }
    [NullableContextAttribute("2")]
public InternedStringsMarshallerParameters(int stringLengthLimit, Encoding encoding);
    [CompilerGeneratedAttribute]
private InternedStringsMarshallerParameters(InternedStringsMarshallerParameters original);
    private static InternedStringsMarshallerParameters();
    [CompilerGeneratedAttribute]
private Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public int get_StringLengthLimit();
    [CompilerGeneratedAttribute]
public Encoding get_Encoding();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(InternedStringsMarshallerParameters left, InternedStringsMarshallerParameters right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(InternedStringsMarshallerParameters left, InternedStringsMarshallerParameters right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(InternedStringsMarshallerParameters other);
    [CompilerGeneratedAttribute]
public InternedStringsMarshallerParameters <Clone>$();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.Util.PersistentMap.Intern.InternedStringsReaderContext : object {
    [CompilerGeneratedAttribute]
private InternedStringsMarshallerParameters <Parameters>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<string> mySeenStrings;
    public InternedStringsMarshallerParameters Parameters { get; }
    public InternedStringsReaderContext(InternedStringsMarshallerParameters parameters);
    [CompilerGeneratedAttribute]
public InternedStringsMarshallerParameters get_Parameters();
    [MustUseReturnValueAttribute]
public string ReadString(UnsafeReader reader);
    public void Reset();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.Util.PersistentMap.Intern.InternedStringsWriterContext : object {
    private Dictionary`2<string, int> myInternedStrings;
    [CompilerGeneratedAttribute]
private InternedStringsMarshallerParameters <Parameters>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CharsWritten>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CharsInterned>k__BackingField;
    public InternedStringsMarshallerParameters Parameters { get; }
    public int CharsWritten { get; private set; }
    public int CharsInterned { get; private set; }
    public double Efficiency { get; }
    public InternedStringsWriterContext(InternedStringsMarshallerParameters parameters);
    [CompilerGeneratedAttribute]
public InternedStringsMarshallerParameters get_Parameters();
    [CompilerGeneratedAttribute]
public int get_CharsWritten();
    [CompilerGeneratedAttribute]
private void set_CharsWritten(int value);
    [CompilerGeneratedAttribute]
public int get_CharsInterned();
    [CompilerGeneratedAttribute]
private void set_CharsInterned(int value);
    public double get_Efficiency();
    public void WriteString(UnsafeWriter writer, string text);
}
[NullableContextAttribute("2")]
public interface JetBrains.Util.PersistentMap.Intern.IUnsafeMarshallerWithContext`3 {
    [NullableContextAttribute("1")]
public abstract virtual void Marshal(UnsafeWriter writer, TValue value, TWriterContext context);
    [NullableContextAttribute("1")]
public abstract virtual TValue Unmarshal(UnsafeReader reader, TReaderContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.Util.PersistentMap.Intern.UniversalMarshallerWithContext`3 : object {
    private Action`3<UnsafeWriter, TValue, TWriterContext> myWriter;
    private Func`3<UnsafeReader, TReaderContext, TValue> myReader;
    public UniversalMarshallerWithContext`3(Func`3<UnsafeReader, TReaderContext, TValue> reader, Action`3<UnsafeWriter, TValue, TWriterContext> writer);
    public sealed virtual void Marshal(UnsafeWriter writer, TValue value, TWriterContext context);
    public sealed virtual TValue Unmarshal(UnsafeReader reader, TReaderContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class JetBrains.Util.PersistentMap.Intern.UnsafeMarshallerWithContext : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IUnsafeMarshallerWithContext`3<string, InternedStringsReaderContext, InternedStringsWriterContext> InternedUnicodeStringMarshaller;
    private static UnsafeMarshallerWithContext();
    [ExtensionAttribute]
[PureAttribute]
public static IUnsafeMarshaller`1<T> ToTopLevelInterningUnsafeMarshaller(IUnsafeMarshallerWithContext`3<T, InternedStringsReaderContext, InternedStringsWriterContext> unsafeMarshallerWithIntern, InternedStringsMarshallerParameters internedStringsMarshallerParameters);
    [PureAttribute]
public static IUnsafeMarshallerWithContext`3<TCollection, TReaderContext, TWriterContext> GetOneToManyMapMarshaller(IUnsafeMarshallerWithContext`3<TKey, TReaderContext, TWriterContext> keyMarshaller, IUnsafeMarshallerWithContext`3<TValue, TReaderContext, TWriterContext> valueMarshaller, Func`2<int, TCollection> collectionInitializer);
    [PureAttribute]
public static IUnsafeMarshallerWithContext`3<TCollection, TReaderContext, TWriterContext> GetOneToManyMapMarshaller(IUnsafeMarshallerWithContext`3<TKey, TReaderContext, TWriterContext> keyMarshaller, Func`2<TKey, IUnsafeMarshallerWithContext`3<TValue, TReaderContext, TWriterContext>> valueMarshaller, Func`2<int, TCollection> collectionInitializer);
}
[NullableContextAttribute("1")]
public interface JetBrains.Util.PersistentMap.IUnsafeMarshaller`1 {
    public abstract virtual void Marshal(UnsafeWriter writer, T value);
    public abstract virtual T Unmarshal(UnsafeReader reader);
}
public class JetBrains.Util.PersistentMap.RawValue : ValueType {
    [CompilerGeneratedAttribute]
private IntPtr <Ptr>k__BackingField;
    public int BytesLength;
    public IntPtr Ptr { get; }
    public RawValue(int bytesLength, IntPtr ptr);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public IntPtr get_Ptr();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.Util.PersistentMap.UniversalMarshaller`1 : object {
    private ReadDelegate`1<T> myReadDelegate;
    private WriteDelegate`1<T> myWriteDelegate;
    public UniversalMarshaller`1(ReadDelegate`1<T> readDelegate, WriteDelegate`1<T> writeDelegate);
    public sealed virtual void Marshal(UnsafeWriter writer, T value);
    public sealed virtual T Unmarshal(UnsafeReader reader);
}
public class JetBrains.Util.PersistentMap.UnsafeDelegatedMarshaller`2 : object {
    private IUnsafeMarshaller`1<TSrc> myMarshaller;
    private Func`2<TDst, TSrc> myTransformMarshall;
    private Func`2<TSrc, TDst> myTransformUnmarshall;
    public UnsafeDelegatedMarshaller`2(IUnsafeMarshaller`1<TSrc> marshaller, Func`2<TDst, TSrc> transformMarshall, Func`2<TSrc, TDst> transformUnmarshall);
    public sealed virtual void Marshal(UnsafeWriter writer, TDst value);
    public sealed virtual TDst Unmarshal(UnsafeReader reader);
}
public class JetBrains.Util.PersistentMap.UnsafeFilteredCollectionMarshaller`2 : object {
    private IUnsafeMarshaller`1<T> myElemMarshaller;
    private Predicate`1<T> myFilter;
    private Func`2<int, TCol> myEmptyCollectionCreator;
    public UnsafeFilteredCollectionMarshaller`2(IUnsafeMarshaller`1<T> elemMarshaller, Func`2<int, TCol> emptyCollectionCreator, Predicate`1<T> filter);
    public sealed virtual void Marshal(UnsafeWriter writer, TCol value);
    public sealed virtual TCol Unmarshal(UnsafeReader reader);
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Util.PersistentMap.UnsafeIntArray : ValueType {
    public static UnsafeIntArray Null;
    private int myLen;
    private Int32* myStorage;
    public int Count { get; }
    public int Length { get; }
    public bool IsReadOnly { get; }
    public int Item { get; public set; }
    public UnsafeIntArray(Int32* storage);
    public UnsafeIntArray(int len, Int32* storage);
    private static UnsafeIntArray();
    public static UnsafeIntArray SortAndDistinct(int len, Int32* storage);
    public static UnsafeIntArray Sort(int len, Int32* storage);
    public UnsafeIntArrayEnumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<int> System.Collections.Generic.IEnumerable<System.Int32>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Add(int item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(int item);
    public sealed virtual void CopyTo(Int32[] array, int arrayIndex);
    public sealed virtual bool Remove(int item);
    public sealed virtual int get_Count();
    public int get_Length();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual int IndexOf(int item);
    public sealed virtual void Insert(int index, int item);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual int get_Item(int index);
    public sealed virtual void set_Item(int index, int value);
    public Int32[] ToIntArray();
    public UnsafeReader ToUnsafeReader();
    public void Reverse();
    public UnsafeIntArray Slice(int startIndex, int endIndex);
    public UnsafeIntArray SliceLength(int startIndex, int length);
    public void ZeroMemory();
}
public class JetBrains.Util.PersistentMap.UnsafeIntArrayEnumerator : ValueType {
    private UnsafeIntArray myUnsafeIntArray;
    private int myCurrent;
    public int Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    internal UnsafeIntArrayEnumerator(UnsafeIntArray unsafeIntArray);
    public sealed virtual void Dispose();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
    public sealed virtual int get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
}
public class JetBrains.Util.PersistentMap.UnsafeLexicographicalIntMarshaller : object {
    public sealed virtual void Marshal(UnsafeWriter writer, int arg);
    public sealed virtual int Unmarshal(UnsafeReader reader);
    public static int ToLittleEndian(int arg);
    public static int ToBigEndian(int arg);
}
public static class JetBrains.Util.PersistentMap.UnsafeMarshallers : object {
    public static IUnsafeMarshaller`1<VirtualFileSystemPath> VirtualFileSystemPathCurrentSolutionCorrectCaseMarshaller;
    public static IUnsafeMarshaller`1<FileSystemPath> FileSystemPathCorrectCaseMarshaller;
    public static IUnsafeMarshaller`1<RelativePath> RelativePathCorrectCaseMarshaller;
    [ObsoleteAttribute("Using the marshaller will prevent removal when case-insensitive paths are used and path casing differs. Consider using VirtualFileSystemPathCurrentSolutionCorrectCaseMarshaller instead")]
public static IUnsafeMarshaller`1<VirtualFileSystemPath> VirtualFileSystemPathCurrentSolutionMarshaller;
    [ObsoleteAttribute("Using the marshaller will prevent removal when case-insensitive paths are used and path casing differs. Consider using FileSystemPathCorrectCaseMarshaller instead")]
public static IUnsafeMarshaller`1<FileSystemPath> FileSystemPathMarshaller;
    public static IUnsafeMarshaller`1<FileSystemPath> FileSystemPathComparableMarshaller;
    [ObsoleteAttribute("Using the marshaller will prevent removal when case-insensitive paths are used and path casing differs. Consider using RelativePathCorrectCaseMarshaller instead")]
public static IUnsafeMarshaller`1<RelativePath> RelativePathMarshaller;
    public static IUnsafeMarshaller`1<int> LexicographicalIntMarshaller;
    public static IUnsafeMarshaller`1<char> CharMarshaller;
    public static IUnsafeMarshaller`1<DateTime> DateTimeMarshaller;
    public static IUnsafeMarshaller`1<decimal> DecimalMarshaller;
    public static IUnsafeMarshaller`1<double> DoubleMarshaller;
    public static IUnsafeMarshaller`1<float> FloatMarshaller;
    public static IUnsafeMarshaller`1<ushort> UShortMarshaller;
    public static IUnsafeMarshaller`1<UInt32> UIntMarshaller;
    public static IUnsafeMarshaller`1<ulong> ULongMarshaller;
    public static IUnsafeMarshaller`1<short> ShortMarshaller;
    public static IUnsafeMarshaller`1<int> IntMarshaller;
    public static IUnsafeMarshaller`1<byte> ByteMarshaller;
    public static IUnsafeMarshaller`1<long> LongMarshaller;
    public static IUnsafeMarshaller`1<string> UnicodeStringMarshaller;
    public static IUnsafeMarshaller`1<Int32[]> IntArrayMarshaller;
    public static IUnsafeMarshaller`1<String[]> StringArrayMarshaller;
    public static IUnsafeMarshaller`1<Byte[]> ByteArrayMarshaller;
    public static IUnsafeMarshaller`1<Guid> GuidMarshaller;
    public static IUnsafeMarshaller`1<bool> BooleanMarshaller;
    public static Func`2<RawValue, UnsafeIntArray> IntArrayReinterpretCaster;
    private static UnsafeMarshallers();
    public static IUnsafeMarshaller`1<JetHashSet`1<T>> GetNullFilteredSetMarshaller(IUnsafeMarshaller`1<T> elemMarshaller);
    public static IUnsafeMarshaller`1<T[]> GetArrayMarshaller(ReadDelegate`1<T> readDelegate, WriteDelegate`1<T> writeDelegate);
    public static IUnsafeMarshaller`1<TCol> GetCollectionMarshaller(ReadDelegate`1<T> readDelegate, WriteDelegate`1<T> writeDelegate, Func`2<int, TCol> collectionInit);
    public static IUnsafeMarshaller`1<TCol> GetCollectionMarshaller(IUnsafeMarshaller`1<T> elemMarshaller, Func`2<int, TCol> collectionInit);
    public static IUnsafeMarshaller`1<IList`1<T>> GetIListMarshaller(IUnsafeMarshaller`1<T> elemMarshaller, bool isOftenSmall);
    [NotNullAttribute]
public static IUnsafeMarshaller`1<TCollection> GetOneToManyMapMarshaller(IUnsafeMarshaller`1<TKey> keyMarshaller, IUnsafeMarshaller`1<TValue> valueMarshaller, Func`2<int, TCollection> collectionInitializer);
    [NotNullAttribute]
public static IUnsafeMarshaller`1<TCollection> GetOneToManyMapMarshaller(IUnsafeMarshaller`1<TKey> keyMarshaller, Func`2<TKey, IUnsafeMarshaller`1<TValue>> valueMarshaller, Func`2<int, TCollection> collectionInitializer);
    public static IUnsafeMarshaller`1<TEnum> GetEnumMarshaller();
}
public class JetBrains.Util.PersistentMap.UnsafePairMarshaller`2 : object {
    private IUnsafeMarshaller`1<T1> myFirstElementMarshaller;
    private IUnsafeMarshaller`1<T2> mySecondElementMarshaller;
    public UnsafePairMarshaller`2(IUnsafeMarshaller`1<T1> first, IUnsafeMarshaller`1<T2> second);
    public sealed virtual void Marshal(UnsafeWriter writer, Pair`2<T1, T2> value);
    public sealed virtual Pair`2<T1, T2> Unmarshal(UnsafeReader reader);
}
[ExtensionAttribute]
public static class JetBrains.Util.PersistentMap.UnsafeReaderEx : object {
    public static ReadDelegate`1<FileSystemPath> FileSystemPathDelegate;
    public static ReadDelegate`1<VirtualFileSystemPath> VirtualFileSystemPathCurrentSolutionDelegate;
    public static ReadDelegate`1<RelativePath> ReadRelativePathDelegate;
    public static ReadDelegate`1<FileSystemPath> FileSystemPathIgnoreCaseDelegate;
    public static ReadDelegate`1<VirtualFileSystemPath> VirtualFileSystemPathCurrentSolutionIgnoreCaseDelegate;
    public static ReadDelegate`1<RelativePath> ReadRelativePathIgnoreCaseDelegate;
    private static UnsafeReaderEx();
    [ExtensionAttribute]
[CanBeNullAttribute]
public static FileSystemPath ReadFileSystemPath(UnsafeReader reader);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static FileSystemPath ReadFileSystemPathIgnoreCase(UnsafeReader reader);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static VirtualFileSystemPath ReadCurrentSolutionVirtualFileSystemPath(UnsafeReader reader);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static VirtualFileSystemPath ReadCurrentSolutionVirtualFileSystemPathIgnoreCase(UnsafeReader reader);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static RelativePath ReadRelativePath(UnsafeReader reader);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static RelativePath ReadRelativePathIgnoreCase(UnsafeReader reader);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class JetBrains.Util.PersistentMap.UnsafeReaderWriterEx : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ReadDelegate`2<string, IRawStringIntern> StringWithInternDelegate;
    public static string ProtocolGlobalInternRootKey;
    private static UnsafeReaderWriterEx();
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static TBlittable ReadBlittable(UnsafeReader reader);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static ImmutableArray`1<TItem> ReadBlittableArray(UnsafeReader reader);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static FrugalLocalList`1<TItem> ReadBlittableFrugalLocalList(UnsafeReader reader);
    [ExtensionAttribute]
public static TCollection ReadCollection(UnsafeReader reader, TContext context, ReadDelegate`2<T, TContext> readDelegate, Func`2<int, TCollection> constructor);
    [ExtensionAttribute]
public static TDictionary ReadDictionary(UnsafeReader reader, TContext context, ReadDelegate`2<TKey, TContext> readKeyDelegate, ReadDelegate`2<TValue, TContext> readValueDelegate, Func`2<int, TDictionary> constructor);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static Nullable`1<TEnum> ReadEnum(UnsafeReader reader);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static TEnum ReadEnum(UnsafeReader reader, TEnum defaultValue);
    [ExtensionAttribute]
public static string ReadStringInterned(UnsafeReader reader, InternedStringsReaderContext context);
    [ExtensionAttribute]
public static void WriteStringInterned(UnsafeWriter writer, string value, InternedStringsWriterContext context);
    [ExtensionAttribute]
public static bool ReadIfNull(UnsafeReader reader);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static ReadOnlySpan`1<TBlittable> ReadManyBlittable(UnsafeReader reader);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static TValue ReadRd(UnsafeReader reader, SerializationCtx ctx);
    [ExtensionAttribute]
public static void Write(UnsafeWriter writer, WriteDelegate`1<T> writeDelegate, FrugalLocalList`1<T> value);
    [ExtensionAttribute]
public static void Write(UnsafeWriter writer, WriteDelegate`1<T> writeDelegate, CompactList`1<T> value);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static void WriteBlittable(UnsafeWriter writer, TBlittable value);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static void WriteBlittableArray(UnsafeWriter writer, ImmutableArray`1<TItem> array);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static void WriteBlittableFrugalLocalList(UnsafeWriter writer, FrugalLocalList`1<TItem> list);
    [ExtensionAttribute]
public static void WriteBool(UnsafeWriter writer, bool value);
    [ExtensionAttribute]
public static void WriteCollection(UnsafeWriter writer, IReadOnlyCollection`1<T> value, TContext context, WriteDelegate`2<T, TContext> writeDelegate);
    [ExtensionAttribute]
public static void WriteDouble(UnsafeWriter writer, double value);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static void WriteEnum(UnsafeWriter writer, T enumValue);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[ContractAnnotationAttribute("t: null => true")]
public static bool WriteIfNull(UnsafeWriter writer, T t);
    [ExtensionAttribute]
public static void WriteInt32(UnsafeWriter writer, int value);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static void WriteManyBlittable(UnsafeWriter writer, ReadOnlySpan`1<TBlittable> items);
    [ExtensionAttribute]
public static void WriteRd(UnsafeWriter writer, SerializationCtx ctx, TValue value);
    [ExtensionAttribute]
public static void WriteRdId(UnsafeWriter writer, RdId value);
    [ExtensionAttribute]
public static void WriteString(UnsafeWriter writer, string value);
    [ExtensionAttribute]
public static void WriteUInt32(UnsafeWriter writer, UInt32 value);
    [ExtensionAttribute]
public static TValue ReadForceInterned(SerializationCtx ctx, UnsafeReader unreader);
    [ExtensionAttribute]
public static void WriteForceInterned(SerializationCtx ctx, UnsafeWriter unwriter, TValue value);
    [ExtensionAttribute]
[MustUseReturnValueAttribute]
public static int ReadOftenSmallPositiveInt32(UnsafeReader reader);
    [ExtensionAttribute]
public static void WriteOftenSmallPositiveInt32(UnsafeWriter writer, int value);
    [ExtensionAttribute]
[MustUseReturnValueAttribute]
public static int Read7BitEncodedInt(UnsafeReader reader);
    [ExtensionAttribute]
public static void Write7BitEncodedInt(UnsafeWriter writer, int value);
}
[ObsoleteAttribute("Do not use this implementation, for it allocates a managed object for the structure box on every read or write.")]
public class JetBrains.Util.PersistentMap.UnsafeStructAsIsMarshaller`1 : object {
    public static UnsafeStructAsIsMarshaller`1<T> Instance;
    private int myFixedSize;
    private static UnsafeStructAsIsMarshaller`1();
    public sealed virtual void Marshal(UnsafeWriter writer, T value);
    public sealed virtual T Unmarshal(UnsafeReader reader);
}
[ExtensionAttribute]
public static class JetBrains.Util.PersistentMap.UnsafeWriterEx : object {
    public static WriteDelegate`1<RelativePath> RelativePathDelegate;
    public static WriteDelegate`1<FileSystemPath> FileSystemPathDelegate;
    public static WriteDelegate`1<VirtualFileSystemPath> VirtualFileSystemPathCurrentSolutionDelegate;
    public static WriteDelegate`1<RelativePath> RelativePathIgnoreCaseDelegate;
    public static WriteDelegate`1<FileSystemPath> FileSystemPathIgnoreCaseDelegate;
    public static WriteDelegate`1<VirtualFileSystemPath> VirtualFileSystemPathCurrentSolutionIgnoreCaseDelegate;
    private static UnsafeWriterEx();
    [ExtensionAttribute]
public static void Write(UnsafeWriter writer, FileSystemPath value);
    [ExtensionAttribute]
public static void WriteIgnoreCase(UnsafeWriter writer, FileSystemPath value);
    [ExtensionAttribute]
public static void Write(UnsafeWriter writer, VirtualFileSystemPath value);
    [ExtensionAttribute]
public static void WriteIgnoreCase(UnsafeWriter writer, VirtualFileSystemPath value);
    [ExtensionAttribute]
public static void Write(UnsafeWriter writer, RelativePath value);
    [ExtensionAttribute]
public static void WriteIgnoreCase(UnsafeWriter writer, RelativePath value);
    [ExtensionAttribute]
public static ByteBuffer Alloc2(UnsafeWriter writer, UInt32 length);
    [ExtensionAttribute]
public static Span`1<TItem> Alloc2(UnsafeWriter writer);
    [ExtensionAttribute]
public static Span`1<TItem> AllocMany(UnsafeWriter writer, UInt32 lengthInItems);
    [ExtensionAttribute]
public static Span`1<byte> AsSpan(Cookie this);
}
public class JetBrains.Util.PersistentMap.ZipMarshallerWrapper`1 : object {
    private IUnsafeMarshaller`1<T> myInternalMarshaller;
    public ZipMarshallerWrapper`1(IUnsafeMarshaller`1<T> internalMarshaller);
    public sealed virtual void Marshal(UnsafeWriter writer, T value);
    public sealed virtual T Unmarshal(UnsafeReader reader);
    public static void CopyTo(Stream src, Stream dest);
    public static Byte[] Zip(Stream msi);
    public static Byte[] Unzip(Byte[] bytes);
}
public interface JetBrains.Util.Platforms.IKernel32Api {
    public abstract virtual int DeleteFileW(string lpFileName);
}
public interface JetBrains.Util.Platforms.IMacPlatformApi {
}
public interface JetBrains.Util.Platforms.IPlatformApi {
}
public interface JetBrains.Util.Platforms.IUnixPlatformApi {
}
public interface JetBrains.Util.Platforms.IWindowsPlatformApi {
    public IKernel32Api KernelApi { get; }
    public abstract virtual IKernel32Api get_KernelApi();
}
public static class JetBrains.Util.PlatformUtil : object {
    public static bool IsRunningOnCoreOnNonWindows;
    public static bool IsSupportSTA;
    public static bool CaseSensitiveEnvironmentVariables;
    private static Nullable`1<bool> myShouldBeSimilarToUnixExecution;
    public static string ORIGINAL_VARIABLES_NAME_PREFIX;
    private static List`1<string> BACKEND_CONFIGURATION_VARS;
    private static List`1<string> BACKEND_CONFIGURATION_VARS_PREFIXES;
    public static JetClrImplementation RuntimeClrImplementation { get; }
    public static JetPlatform RuntimePlatform { get; }
    public static Nullable`1<JetLinuxLibC> RuntimeLinuxLibC { get; }
    public static bool IsRunningUnderWindows { get; }
    public static bool IsRunningUnderWindowsNanoServer { get; }
    public static bool IsRunningOnCore { get; }
    public static bool IsRunningOnMono { get; }
    public static bool IsSupportRegistry { get; }
    [CanBeNullAttribute]
public static Version CurrentMonoVersion { get; }
    public static bool ShouldBeSimilarToUnixExecution { get; public set; }
    private static PlatformUtil();
    public static JetClrImplementation get_RuntimeClrImplementation();
    public static JetPlatform get_RuntimePlatform();
    public static Nullable`1<JetLinuxLibC> get_RuntimeLinuxLibC();
    public static bool get_IsRunningUnderWindows();
    public static bool get_IsRunningUnderWindowsNanoServer();
    public static bool get_IsRunningOnCore();
    public static bool get_IsRunningOnMono();
    public static bool get_IsSupportRegistry();
    public static Version get_CurrentMonoVersion();
    public static bool get_ShouldBeSimilarToUnixExecution();
    public static void set_ShouldBeSimilarToUnixExecution(bool value);
    public static FileSystemInteraction FileSystemInteraction();
    public static IJetDispatcherPlatformSpecific JetDispatcherPlatformSpecific();
    public static JetFileSystemWatcher CreateFileSystemWatcher(VirtualFileSystemPath path, string filter, NotifyFilters notifyFilter, bool includeSubdirectories, IWatcherEvents watcherEvents, WinError& rc, int bufferSize);
    public static void PrintDebugString(string message);
    public static bool HasGraphicalUserInterface();
    private static void LogEnvironmentVariables(string moniker, IDictionary`2<string, string> env);
    public static IDictionary`2<string, string> GetEnvironmentVariables();
    public static void PrepareEnvironmentVariablesForChildProcess(IDictionary`2<string, string> env);
    public static void ChModToExecute(FileSystemPath path);
    public static void ChModToNormal(FileSystemPath path);
    public static void ChMod(FileSystemPath path, UnixFileModes mode);
}
public static class JetBrains.Util.PlatformUtilLinux : object {
    public static long GetProcStatFieldAsLong(int pid, ProcStatFields field);
    [CanBeNullAttribute]
public static string GetProcPathToExecutable(int pid);
    [NotNullAttribute]
public static string GetProcCmdline(int pid);
    [CanBeNullAttribute]
public static Nullable`1<UInt32> GetProcUid(int pid);
    [NotNullAttribute]
public static ImmutableDictionary`2<string, string> GetProcEnv(int pid);
}
public static class JetBrains.Util.PlatformUtilMacOsX : object {
}
public static class JetBrains.Util.PlatformUtilUnix : object {
    public static int Stat(string path, Stat& stat);
}
public class JetBrains.Util.PreparedString : ValueType {
    public static PreparedString THIS;
    public static PreparedString OTHER;
    public static PreparedString EMPTY;
    public string Value;
    public bool IsPathAlreadyCanonical;
    private Kind myKind;
    public PreparedString(string value, bool isPathAlreadyCanonical);
    private static PreparedString();
    public bool ReturnThis();
    public bool ReturnOther();
    public bool ReturnEmpty();
}
[ExtensionAttribute]
public static class JetBrains.Util.ProcessorUtil : object {
    public static JetArchitecture ProcessArchitecture { get; }
    public static JetArchitecture OSArchitecture { get; }
    public static JetArchitecture get_ProcessArchitecture();
    public static JetArchitecture get_OSArchitecture();
    [ExtensionAttribute]
[NotNullAttribute]
public static string GetFolderName(JetArchitecture architecture);
    [ExtensionAttribute]
[NotNullAttribute]
public static JetRuntimeId MakeCurrentRuntimeId(JetArchitecture architecture);
    public static UInt32 GetProcessorCountWithAffinityMask();
}
public class JetBrains.Util.ProjectedCollection`2 : object {
    [NotNullAttribute]
private ICollection`1<TSrc> myOriginalCollection;
    [NotNullAttribute]
private Func`2<TDst, TSrc> myMapTo;
    [NotNullAttribute]
private Func`2<TSrc, TDst> myMapFrom;
    private Func`2<IEnumerator`1<TSrc>, TDst> myEnumeratorStateMap;
    [NotNullAttribute]
public ICollection`1<TSrc> OriginalCollection { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public ProjectedCollection`2(ICollection`1<TSrc> originalCollection, Func`2<TDst, TSrc> mapTo, Func`2<TSrc, TDst> mapFrom, Func`2<IEnumerator`1<TSrc>, TDst> enumeratorStateStateMap, Lifetime lifetime);
    public ICollection`1<TSrc> get_OriginalCollection();
    public virtual IEnumerator`1<TDst> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual void Add(TDst item);
    public virtual void Clear();
    public virtual bool Contains(TDst item);
    public virtual void CopyTo(TDst[] array, int arrayIndex);
    public virtual bool Remove(TDst item);
    public virtual int get_Count();
    public virtual bool get_IsReadOnly();
    public virtual void Dispose();
    [CompilerGeneratedAttribute]
private TDst <.ctor>b__4_0(IEnumerator`1<TSrc> x);
}
public class JetBrains.Util.ProjectedEnumerator`2 : object {
    [CompilerGeneratedAttribute]
private IEnumerator`1<TSrc> <OriginalEnumerator>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<IEnumerator`1<TSrc>, TDst> <MapFromState>k__BackingField;
    internal IEnumerator`1<TSrc> OriginalEnumerator { get; }
    internal Func`2<IEnumerator`1<TSrc>, TDst> MapFromState { get; }
    public TDst Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    public ProjectedEnumerator`2(IEnumerator`1<TSrc> originalEnumerator, Func`2<IEnumerator`1<TSrc>, TDst> mapFromState);
    [CompilerGeneratedAttribute]
internal IEnumerator`1<TSrc> get_OriginalEnumerator();
    [CompilerGeneratedAttribute]
internal Func`2<IEnumerator`1<TSrc>, TDst> get_MapFromState();
    public sealed virtual void Dispose();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
    public sealed virtual TDst get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
}
public static class JetBrains.Util.Properties.PublicKey : object {
    public static string Product;
    public static string Mocks;
}
public class JetBrains.Util.RangeTranslator : object {
    [NotNullAttribute]
private List`1<RangeMap> myMaps;
    private TextRange mySourceRange;
    private TextRange myResultRange;
    public TextRange SourceRange { get; }
    public TextRange ResultRange { get; }
    public IEnumerable`1<RangeMap> Maps { get; }
    public bool IsValid { get; }
    public TextRange get_SourceRange();
    public TextRange get_ResultRange();
    public IEnumerable`1<RangeMap> get_Maps();
    public bool get_IsValid();
    public void MapCharToChar(int source, int result);
    public void MapTextToChar(int sourceOffset, int sourceLength, int resultOffset);
    public void MapCharToText(int sourceOffset, int resultOffset, int resultLength);
    public void MapTextToText(int sourceOffset, int sourceLength, int resultOffset, int resultLength);
    public void MapTextToText(TextRange source, TextRange result);
    public TextRange GetResultRange(int sourceOffset);
    public TextRange GetResultRange(TextRange sourceRange);
    public TextRange GetSourceRange(int resultOffset);
    public TextRange GetSourceRange(TextRange resultRange);
    public void ShiftSource(int delta);
    public void ShiftResult(int delta);
    public void StartMapping(int length);
    public void StartMapping(TextRange sourceRange);
    public void EndMapping(int length);
    public void EndMapping(TextRange resultRange);
    [PureAttribute]
private static int CompareRangeToStartOffset(TextRange range, int offset);
    [PureAttribute]
private static int CompareRangeToEndOffset(TextRange range, int offset);
}
public static class JetBrains.Util.RawRelativePathOperations : object {
    public static PreparedString GetParent(string path);
    public static bool IsEmpty(string path);
    public static PreparedString CombineWithText(string path, string component, bool unrestrictedRelativeMode);
    public static PreparedString Combine(string path, string other);
    public static PreparedString MakeRelativeTo(string path, string basePath);
    [NotNullAttribute]
public static PreparedString TryMakeRelativeTo(string path, string basePath);
    private static int GetLastSeparatorPosition(string path);
    public static StringSlicesEnumerable GetPathComponents(string path);
    [NotNullAttribute]
public static string GetExtensionNoDot(string name);
    [NotNullAttribute]
public static string GetExtensionWithDot(string name);
    [NotNullAttribute]
public static string GetName(string path);
    [NotNullAttribute]
public static string GetNameWithoutExtension(string path);
    private static DeferQuotedObject QuoteIfNeeded(string path);
}
public class JetBrains.Util.RecordAndThrowLogger : LoggerBase {
    private bool myThreatWarnAsError;
    private IDisposable myMustBeDisposed;
    private CompoundException myCompoundException;
    private SpinWaitLockRef myLock;
    public RecordAndThrowLogger(Lifetime lifetime, bool threatWarnAsError);
    public RecordAndThrowLogger(bool threatWarnAsError);
    public virtual void Log(LogEvent logEvent);
    public virtual bool IsEnabled(LoggingLevel level);
    public sealed virtual void LogOrThrowException(Exception ex, ExceptionOrigin origin);
    private sealed virtual override void System.IDisposable.Dispose();
    private void ThrowUp();
    [CompilerGeneratedAttribute]
private void <.ctor>b__4_0();
}
public class JetBrains.Util.RecordingLogger : LoggerBase {
    private RecordOrPassMessages myRecordOrPassMessages;
    private ILogger myLoggerForwardTo;
    private IList`1<ExceptionOrigin> myTypesExoriginPassOnly;
    private IList`1<ExceptionOrigin> myTypesExoriginRecordOnly;
    private bool myIsReThrowingWhenAllowed;
    private List`1<ExceptionWithOrigin> myExceptions;
    private int myLoudExceptionsCount;
    private SpinWaitLock myLockExceptions;
    private List`1<MessageWithImportance> myMessages;
    private SpinWaitLock myLockMessages;
    public bool IsWithLoudExceptions { get; }
    public string Category { get; }
    public RecordingLogger(LogOrThrowExceptions logOrThrowExceptions, RecordOrPassMessages recordOrPassMessages, ILogger loggerForwardTo, IList`1<ExceptionOrigin> typesExoriginPassOnly, IList`1<ExceptionOrigin> typesExoriginRecordOnly);
    private void LogEventWithException(LogEvent logEvent);
    private sealed virtual override void JetBrains.Util.IExceptionThrowingLogger.LogOrThrowException(Exception ex, ExceptionOrigin origin);
    private void LogEventWithMessage(LogEvent logEvent);
    public virtual void Log(LogEvent logEvent);
    public virtual bool IsEnabled(LoggingLevel level);
    [NotNullAttribute]
public IList`1<ExceptionWithOrigin> CopyExceptions();
    [CanBeNullAttribute]
public CompoundException CopyExceptionsCompound();
    [NotNullAttribute]
public IList`1<ExceptionWithOrigin> CopyExceptionsAndClear();
    [CanBeNullAttribute]
public CompoundException CopyExceptionsAndClearCompound();
    public bool get_IsWithLoudExceptions();
    public virtual string get_Category();
}
public class JetBrains.Util.Reflection.AppDomainAssembliesResolver : object {
    private static ILogger Logger;
    private static Version VersionNone;
    [NotNullAttribute]
private OneToListMap`2<AssemblyKey, AssemblyBinding> AssemblyByIdentity;
    [NotNullAttribute]
public ResolveEventHandler AssemblyResolveDelegate;
    private static AppDomainAssembliesResolver();
    public void AddRemoveAssembly(AssemblyNameInfo assname, AssemblyBinding binder, AddRemove addremove);
    public static void CreateAndInstall(Lifetime lifetime, ICollectionEvents`1<Pair`2<AssemblyNameInfo, Func`1<Assembly>>> assemblies);
    public static void CreateAndInstall(Lifetime lifetime, ICollection`1<AssemblyNameAndLocation> assemblies);
    public void Install(Lifetime lifetime);
    private Assembly AssemblyResolve(object sender, ResolveEventArgs args);
    [CompilerGeneratedAttribute]
private void <Install>b__8_0();
    [CompilerGeneratedAttribute]
private void <Install>b__8_1();
}
public enum JetBrains.Util.Reflection.AssemblyIdentityContentTypes : Enum {
    public byte value__;
    public static AssemblyIdentityContentTypes O;
    public static AssemblyIdentityContentTypes WindowsRuntime;
}
[FlagsAttribute]
public enum JetBrains.Util.Reflection.AssemblyIdentityFlags : Enum {
    public UInt32 value__;
    public static AssemblyIdentityFlags Culture;
    public static AssemblyIdentityFlags Version;
    public static AssemblyIdentityFlags PublicKeyToken;
    public static AssemblyIdentityFlags PublicKey;
    public static AssemblyIdentityFlags PublicKeyTokenNull;
    public static AssemblyIdentityFlags ProcessorArchitecture;
    public static AssemblyIdentityFlags Retargetable;
    public static AssemblyIdentityFlags ContentType;
    public static AssemblyIdentityFlags Custom;
    public static AssemblyIdentityFlags CustomNull;
}
public static class JetBrains.Util.Reflection.AssemblyNameInfoFactory : object {
    private static ConcurrentDictionary`2<string, AssemblyNameInfo> ourInternedAssemblyNameInfos;
    private static ConcurrentDictionary`2<StringSource, AssemblyNameInfo> ourInternedAssemblyNameInfosByStringSource;
    private static Func`2<string, AssemblyNameInfo> ourCachedDelegate;
    private static AssemblyNameInfoFactory();
    [NotNullAttribute]
public static AssemblyNameInfo Create(string assemblyFullName);
    [NotNullAttribute]
internal static AssemblyNameInfo Create(StringSource assemblyFullName);
    [NotNullAttribute]
public static AssemblyNameInfo Create(AssemblyName assemblyName);
    [NotNullAttribute]
public static AssemblyNameInfo Create2(string simplename, Version version, PublicKeyToken pktoken, string culture, string codeBase, Byte[] publickey, ProcessorArchitecture processor, bool isRetargetable, AssemblyIdentityContentTypes contenttype, object custom, AssemblyHashAlgorithm hashalg);
    [NotNullAttribute]
[ObsoleteAttribute("Use another overload. Some of the values passed into this function will be ignored, and others will undergo a lossy conversion.")]
public static AssemblyNameInfo Create(string name, Version version, Byte[] publicKeyToken, string culture, AssemblyNameInfoFlags flags, string codeBase);
    public static void AddEntry(AssemblyNameInfo asm);
    [CanBeNullAttribute]
[ContractAnnotationAttribute("null => null; notnull => notnull")]
public static AssemblyNameInfo Intern(AssemblyNameInfo asm);
}
public class JetBrains.Util.Reflection.AssemblyNameInfoParseException : ArgumentOutOfRangeException {
    public AssemblyNameInfoParseException(Exception exInner);
    protected AssemblyNameInfoParseException(SerializationInfo info, StreamingContext context);
}
public static class JetBrains.Util.Reflection.AssemblyTextualIdentityParser : object {
    private static AttributeName[] AttributeNames;
    public static UInt32 PublicKeyMaxCbLen;
    public static UInt32 PublicKeyMinCbLen;
    public static UInt32 PublicKeyTokenCbLen;
    public static ProcessorArchitectureName[] ProcessorArchitectureNames;
    private static AssemblyTextualIdentityParser();
    public static void EscapeString(string text, StringBuilder sb);
    public static void Parse(string sTextualIdentity, EscapeMode escapemode, Quirks quirks, Parsed& result);
    public static void Parse(StringSource ssTextualIdentity, EscapeMode escapemode, Quirks quirks, Parsed& result);
    private static void Parse(Char* pchTextualIdentity, UInt32 cchLength, EscapeMode escapemode, Quirks quirks, StringSource originalstring, Parsed& result);
    private static void CommitAttributeValue(StringSource& ssTextualIdentity, Char* pch0, Char* pch, Char* pchBufferStart, Char* pchBufferEnd, bool isQuotedString, Attribute attr, Quirks quirks, AssemblyIdentityFlags& seen, Parsed& result);
    private static Byte[] CommitAttributeValue_Custom(StringSource& ssTextualIdentity, Char* pchBufferStart, Char* pchBufferEnd);
    private static ProcessorArchitecture CommitAttributeValue_ProcessorArchitecture(StringSource& ssTextualIdentity, Char* pchBufferStart, Char* pchBufferEnd);
    private static Byte[] CommitAttributeValue_PublicKey(StringSource& ssTextualIdentity, Char* pchBufferStart, Char* pchBufferEnd);
    private static ulong CommitAttributeValue_PublicKeyToken(StringSource& ssTextualIdentity, Char* pchBufferStart, Char* pchBufferEnd);
    private static void CommitAttributeValue_Version(StringSource& ssTextualIdentity, Char* pchBufferStart, Char* pchBufferEnd, Quirks quirks, Parsed& result);
    private static StringSource CommitParsedString(StringSource& ssTextualIdentity, Char* pch0, Char* pch, Char* pchBufferStart, Char* pchBufferCur, bool isQuotedString);
    private static bool EqualsAsciiToLower(Char* pchBufferStart, Char* pchBufferEnd, string target);
    private static Attribute ParseAttribute(StringSource& ssTextualIdentity, Char* pch0, Char* pch, Char* pchBufferStart, Char* pchBufferCur, bool isStringQuoted);
    [PureAttribute]
private static Char* TrimTrailingWhitespace(Char* pchBufferStart, Char* pchBufferCur, bool isStringQuoted);
}
[ExtensionAttribute]
public static class JetBrains.Util.Reflection.CallStackAnnotation : object {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ConcurrentDictionary`2<ValueTuple`3<ValueTuple`2<string, string>, bool, int>, MethodInfo> myCacheGenericWrappers;
    private static Lazy`1<ModuleBuilder> myModule;
    private static LockObject myLockStopTheWorld;
    private static Dictionary`2<string, int> myMapDefinedTypeNames;
    public static TypeChooser TypeNames;
    private static Pair`2<ModuleBuilder, IList> myCachedModuleField;
    private static CallStackAnnotation();
    private static ValueTuple`2<Type, Type> ConstructDelegateType(Type[] typeMethodParamsAndRetval, bool isWithRetval);
    [NotNullAttribute]
private static Type ConstructDelegateType(Type[] typeMethodParams, Type typeRetVal);
    private static TypeBuilder DefineType(string sTypeName);
    [NotNullAttribute]
private static Delegate EmitDynamicAssemblyForAnnotatedDelegate(ValueTuple`2<string, string> sStackFrameText, Type typeofEmittedDelegate, Type typeofRetVal, Type[] typesOfParameters);
    [NotNullAttribute]
private static MethodInfo EmitDynamicAssemblyForGenericWrapper(ValueTuple`2<string, string> sStackFrameText, bool isWithRetVal, int nParams);
    [ExtensionAttribute]
private static void LdargMany(ILGenerator ilgen, int nArgsToLoad);
    [ExtensionAttribute]
[NotNullAttribute]
private static MethodBuilder SetNoInlining(MethodBuilder method);
}
public class JetBrains.Util.Reflection.CodeDomAssemblyReferences : object {
    public JetHashSet`1<AssemblyNameInfo> AssemblyNames;
    public virtual string ToString();
}
public static class JetBrains.Util.Reflection.CodeDomEx : object {
    [NotNullAttribute]
public static CodeConditionStatement ArgumentNullException(string sParameterName);
    [NotNullAttribute]
public static CodeTypeReference MakeSpecializedGenericReference(CodeTypeReference opengeneric, CodeTypeReference[] specializations);
    [NotNullAttribute]
[ObsoleteAttribute("Use an overload which tracks assembly references for this type.")]
public static CodeTypeReference MakeTypeReference(Type type);
    [NotNullAttribute]
[ObsoleteAttribute("Use an overload which tracks assembly references for this type.")]
public static CodeTypeReference MakeTypeReference();
    [NotNullAttribute]
[ObsoleteAttribute("This method won't add an assembly reference for your type. If you're adding a part catalog type, use the CodeDomCatalogEx class.")]
public static CodeTypeReference MakeTypeReference(string sFullyQualifiedName);
    [NotNullAttribute]
public static CodeTypeReference MakeTypeReference(string sFullyQualifiedName, CodeDomAssemblyReferences refs, AssemblyNameInfo[] referencedassembly);
    [NotNullAttribute]
public static CodeTypeReference MakeTypeReference(Type type, CodeDomAssemblyReferences refs);
    [NotNullAttribute]
public static CodeTypeReference MakeTypeReference(CodeDomAssemblyReferences refs);
    public static void WriteCodeToFile(CodeCompileUnit code, FileSystemPath filepath);
    private static void WriteCodeToFile_Stream(CodeCompileUnit code, FileSystemPath filepath, Stream stream);
}
public enum JetBrains.Util.Reflection.ImportDefinitionKind : Enum {
    public int value__;
    public static ImportDefinitionKind ImportNamespace;
    public static ImportDefinitionKind ImportAssemblyNamespace;
    public static ImportDefinitionKind ImportType;
    public static ImportDefinitionKind ImportXmlNamespace;
    public static ImportDefinitionKind ImportAssemblyReferenceAlias;
    public static ImportDefinitionKind AliasAssemblyReference;
    public static ImportDefinitionKind AliasNamespace;
    public static ImportDefinitionKind AliasAssemblyNamespace;
    public static ImportDefinitionKind AliasType;
}
public class JetBrains.Util.Reflection.InterfaceImplementation : object {
    private static ModuleBuilder myModule;
    private static Dictionary`2<string, int> myMapDefinedTypeNames;
    private static InterfaceImplementation();
    private static TypeBuilder DefineType(string sTypeName);
    private static ModuleBuilder GetModule();
    public TInterface CreateDelegatingInterfaceImplementation_Emit(TInterface delegatee);
    private void CreateDelegatingInterfaceImplementation_Emit_Member(TypeBuilder typebuilder, MemberInfo member);
    private void CreateDelegatingInterfaceImplementation_Emit_Member_Method(TypeBuilder typebuilder, MethodInfo method);
    public static void Ldarg(ILGenerator ilgen, int nArgsToLoad, Boolean[] isRefParam);
}
[FlagsAttribute]
public enum JetBrains.Util.Reflection.LocalVariableAttributes : Enum {
    public ushort value__;
    public static LocalVariableAttributes None;
    public static LocalVariableAttributes DebuggerHidden;
}
public class JetBrains.Util.Reflection.PublicKeyTokenInterner : object {
    [NotNullAttribute]
private static Dictionary`2<string, Byte[]> ourPublicKeyTokenIntern;
    [NotNullAttribute]
private static Dictionary`2<string, Byte[]> ourPublicKeyIntern;
    [NotNullAttribute]
private static ReaderWriterLockSlim ourReaderWriterLock;
    private static PublicKeyTokenInterner();
    [NotNullAttribute]
[PureAttribute]
public static Byte[] GetPublicKeyToken(string publicKeyTokenString);
    [NotNullAttribute]
[PureAttribute]
public static Byte[] GetPublicKey(string publicKey);
    [NotNullAttribute]
[PureAttribute]
private static Byte[] GetPublicKeyTokenRaw(string value);
    [NotNullAttribute]
[PureAttribute]
private static Byte[] GetPublicKeyRaw(string publicKey);
}
public class JetBrains.Util.Reflection.SimpleTypeConverter`1 : TypeConverterBase`1<T> {
}
public class JetBrains.Util.Reflection.SimpleValueSerializer`1 : ValueSerializerBase`1<T> {
    internal static T Parse(string text);
    internal static string ToString(T t);
}
public class JetBrains.Util.Reflection.TypeConverterBase`1 : TypeConverter {
    [CanBeNullAttribute]
private Func`4<ITypeDescriptorContext, CultureInfo, string, T> myΛFromString1;
    [CanBeNullAttribute]
private Func`4<CultureInfo, string, ILogger, T> myΛFromString2;
    [CanBeNullAttribute]
private Func`2<string, T> myΛFromString3;
    [CanBeNullAttribute]
private Func`4<ITypeDescriptorContext, CultureInfo, T, string> myΛToString1;
    [CanBeNullAttribute]
private Func`4<CultureInfo, T, ILogger, string> myΛToString2;
    [CanBeNullAttribute]
private Func`2<T, string> myΛToString3;
    [EditorBrowsableAttribute("2")]
public TypeConverterBase`1(Func`4<ITypeDescriptorContext, CultureInfo, T, string> λToString, Func`4<ITypeDescriptorContext, CultureInfo, string, T> λFromString);
    [EditorBrowsableAttribute("2")]
public TypeConverterBase`1(Func`4<CultureInfo, T, ILogger, string> λToString, Func`4<CultureInfo, string, ILogger, T> λFromString);
    public TypeConverterBase`1(Func`2<T, string> λToString, Func`2<string, T> λFromString);
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public static class JetBrains.Util.Reflection.TypeConverterUtil : object {
    public static string ToStringThruXml(Action`1<XmlElement> fillXmlAction, string elementName);
    public static string ToStringThruXmlFormatted(Action`1<XmlElement> fillXmlAction, string elementName);
    public static T FromStringThruXml(string value, Func`2<XmlElement, T> fromXmlFunc);
}
public class JetBrains.Util.Reflection.ValueSerializerBase`1 : ValueSerializer {
    [CanBeNullAttribute]
private Func`3<IValueSerializerContext, string, T> myΛFromString1;
    [CanBeNullAttribute]
private Func`3<string, ILogger, T> myΛFromString2;
    [CanBeNullAttribute]
private Func`2<string, T> myΛFromString3;
    [CanBeNullAttribute]
private Func`3<IValueSerializerContext, T, string> myΛToString1;
    [CanBeNullAttribute]
private Func`3<T, ILogger, string> myΛToString2;
    [CanBeNullAttribute]
private Func`2<T, string> myΛToString3;
    [EditorBrowsableAttribute("2")]
public ValueSerializerBase`1(Func`3<IValueSerializerContext, T, string> λToString, Func`3<IValueSerializerContext, string, T> λFromString);
    [EditorBrowsableAttribute("2")]
public ValueSerializerBase`1(Func`3<T, ILogger, string> λToString, Func`3<string, ILogger, T> λFromString);
    public ValueSerializerBase`1(Func`2<T, string> λToString, Func`2<string, T> λFromString);
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
public class JetBrains.Util.RegistryAccess : object {
    public static string HKLM;
    [CompilerGeneratedAttribute]
private string <HKey>k__BackingField;
    [CompilerGeneratedAttribute]
private KeyAccessRights <AccessRights>k__BackingField;
    public string HKey { get; }
    public KeyAccessRights AccessRights { get; }
    public RegistryAccess(string hkey, KeyAccessRights accessRights);
    [CompilerGeneratedAttribute]
public string get_HKey();
    [CompilerGeneratedAttribute]
public KeyAccessRights get_AccessRights();
}
[ExtensionAttribute]
public static class JetBrains.Util.RegistryInteractionUtil : object {
    [ExtensionAttribute]
public static string ToStringPresentation(RegistryKey key);
    [ExtensionAttribute]
public static RegistryKey ToRegistryKey(string key);
}
[TypeConverterAttribute("JetBrains.Util.RelativePathConverter")]
[ValueSerializerAttribute("JetBrains.Util.RelativePathSerializer")]
[PublicAPIAttribute]
public class JetBrains.Util.RelativePath : object {
    private static DirectMappedCache`2<string, RelativePath> ourIntern;
    private int myHashCode;
    private String modreq(System.Runtime.CompilerServices.IsVolatile) myName;
    private String modreq(System.Runtime.CompilerServices.IsVolatile) myNameWithoutExtension;
    [NotNullAttribute]
public static RelativePath Empty;
    [NotNullAttribute]
public string FullPath;
    private static Func`3<string, bool, RelativePath> myCachedDelegate1;
    public bool IsValidOnCurrentOS { get; }
    [NotNullAttribute]
public RelativePath Parent { get; }
    public StringSlicesEnumerable Components { get; }
    public string ExtensionNoDot { get; }
    public string ExtensionWithDot { get; }
    public bool IsAbsolute { get; }
    public bool IsEmpty { get; }
    public string Name { get; }
    public string NameWithoutExtension { get; }
    private IPath JetBrains.Util.IPath.Empty { get; }
    private string JetBrains.Util.IPath.FullPath { get; }
    private IPath JetBrains.Util.IPath.Parent { get; }
    [ObsoleteAttribute("The constructor is left for backward compatibility only. Use RelativePath.Parse or RelativePath.TryParse instead")]
public RelativePath(string path);
    private RelativePath(string path, bool isPathAlreadyCanonical);
    private static RelativePath();
    public sealed virtual bool get_IsValidOnCurrentOS();
    public RelativePath get_Parent();
    public static void AllowIntern(Lifetime lifetime, int maxEntries);
    public static void ClearIntern();
    [NotNullAttribute]
[PureAttribute]
public static RelativePath Parse(string path);
    [NotNullAttribute]
[PureAttribute]
public static RelativePath TryParse(string path);
    [NotNullAttribute]
public static RelativePath op_Division(RelativePath path, RelativePath other);
    [NotNullAttribute]
public static RelativePath op_Division(RelativePath path, string component);
    [NotNullAttribute]
public static RelativePath op_Division(RelativePath path, StringSlice component);
    public static bool op_Equality(RelativePath left, RelativePath right);
    public static string op_Explicit(RelativePath path);
    public static Uri op_Explicit(RelativePath path);
    public static RelativePath op_Explicit(Uri uri);
    public static RelativePath op_Implicit(string path);
    public static bool op_Inequality(RelativePath left, RelativePath right);
    [NotNullAttribute]
public static RelativePath CreateByCanonicalPath(string path);
    [NotNullAttribute]
[PureAttribute]
public RelativePath Combine(string component);
    [NotNullAttribute]
[PureAttribute]
public RelativePath Combine(RelativePath other);
    [NotNullAttribute]
[PureAttribute]
public RelativePath MakeRelativeTo(RelativePath basePath);
    [NotNullAttribute]
[PureAttribute]
public RelativePath TryMakeRelativeTo(RelativePath basePath);
    [NotNullAttribute]
private static RelativePath Create(string path, bool isPathAlreadyCanonical);
    private static DirectMappedCache`2<string, RelativePath> CreateIntern(int maxEntries);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public sealed virtual int CompareTo(RelativePath other);
    public sealed virtual bool Equals(RelativePath other);
    public sealed virtual StringSlicesEnumerable get_Components();
    [NotNullAttribute]
public sealed virtual Uri ToDirectoryUri();
    [NotNullAttribute]
public sealed virtual Uri ToUri();
    private sealed virtual override IPath JetBrains.Util.IPath.Combine(RelativePath other);
    private sealed virtual override IPath JetBrains.Util.IPath.Parse(string text);
    [NotNullAttribute]
private sealed virtual override IPath JetBrains.Util.IPath.TryCombine(string component);
    public sealed virtual string get_ExtensionNoDot();
    public sealed virtual string get_ExtensionWithDot();
    public sealed virtual bool get_IsAbsolute();
    public sealed virtual bool get_IsEmpty();
    public sealed virtual string get_Name();
    public sealed virtual string get_NameWithoutExtension();
    [NotNullAttribute]
[PureAttribute]
public RelativePath Clone();
    private sealed virtual override IPath JetBrains.Util.IPath.get_Empty();
    private sealed virtual override string JetBrains.Util.IPath.get_FullPath();
    private sealed virtual override IPath JetBrains.Util.IPath.get_Parent();
    public static BackSlashSeparatedRelativePath op_Explicit(RelativePath path);
    private static RelativePath Create(PreparedString preparedString, RelativePath this, RelativePath other);
    private static RelativePath Create(PreparedString preparedString, RelativePath this);
}
public class JetBrains.Util.RelativePathConverter : TypeConverterBase`1<RelativePath> {
}
public class JetBrains.Util.RelativePathSerializer : ValueSerializerBase`1<RelativePath> {
}
public static class JetBrains.Util.ReparsePoints : object {
    private static UInt32 ReparseDataBufferCbSize;
    private static string SubstituteNamePrefix;
    [ThreadStaticAttribute]
private static Byte[] ReparseDataBuffer;
    private static ReparsePoints();
    public static void DeleteDirectoryJunction(FileSystemPath sourcedir);
    public static void DeleteDirectoryJunction(Void* hFile);
    public static UInt32 GetReparseBuffer(Void* hFile, Void* pBuffer, UInt32 cbBuffer);
    public static bool IsDirectoryJunctionByHandle(Void* hFile);
    public static bool IsDirectoryJunctionByPath(FileSystemPath path);
    public static bool IsDirectorySupportsReparsePoints(FileSystemPath dir);
    public static bool IsReparsePoint(Void* hFile);
    public static bool IsReparsePoint(FileSystemPath path);
    public static bool IsVolumeSupportReparsePoints(char drive);
    public static bool IsVolumeSupportReparsePoints(FileSystemPath somepath);
    public static void SetDirectoryJunction(FileSystemPath sourcedir, FileSystemPath targetpath);
    public static void SetDirectoryJunction(Void* hFile, FileSystemPath targetpath);
    [CanBeNullAttribute]
public static FileSystemPath TryGetDirectoryJunctionTarget(FileSystemPath path);
    public static Nullable`1<UInt32> TryGetReparsePointTagByHandle(Void* hFile);
    public static Nullable`1<UInt32> TryGetReparsePointTagByPath(FileSystemPath path);
    private static UInt32 GetReparseTag(Void* hFile);
    [CanBeNullAttribute]
private static FileSystemPath TryGetDirectoryJunctionTarget(Void* hFile);
}
public abstract class JetBrains.Util.SafeDisposable : object {
    protected Boolean modreq(System.Runtime.CompilerServices.IsVolatile) IsDisposing;
    protected Boolean modreq(System.Runtime.CompilerServices.IsVolatile) IsDisposed;
    [CanBeNullAttribute]
protected StackFrame[] ConstructorInvocationStackFrame;
    protected bool WarnOnSecondDispose { get; }
    protected SafeDisposable(bool canCaptureStacktraces);
    protected virtual bool get_WarnOnSecondDispose();
    protected abstract virtual void DisposeUnmanagedResources();
    private void DisposeInternal();
    protected virtual override void Finalize();
    [ThreadUnsafeAttribute]
public sealed virtual void Dispose();
    [ThreadUnsafeAttribute]
public static void DisposeIfNecessary(object o);
}
public static class JetBrains.Util.Sizeof : object {
    [ObsoleteAttribute("Might use System.Runtime.CompilerServices.Unsafe::SizeOf directly.")]
public static int Type();
}
[ExtensionAttribute]
public static class JetBrains.Util.SortUtil : object {
    public static ICollection`1<FileSystemPath> SortFilePaths(ICollection filePaths);
    public static IEnumerable`1<FileSystemPath> SortFilePaths(IEnumerable`1<FileSystemPath> filePaths);
    public static IEnumerable`1<VirtualFileSystemPath> SortFilePaths(IEnumerable`1<VirtualFileSystemPath> filePaths);
    public static ICollection`1<FileSystemPath> SortFilePaths(ICollection`1<FileSystemPath> filePaths);
    public static ICollection`1<VirtualFileSystemPath> SortFilePaths(ICollection`1<VirtualFileSystemPath> filePaths);
    public static ICollection`1<string> SortStrings(ICollection`1<string> strings);
    [ExtensionAttribute]
public static List`1<T> TopoSort(IEnumerable`1<T> items, Func`3<T, T, Nullable`1<int>> comparer, IEqualityComparer`1<T> equalityComparer);
    [ExtensionAttribute]
public static IEnumerable`1<T> TopoSort(IEnumerable`1<T> items, Func`2<T, T> parentSelector, IEqualityComparer`1<T> equalityComparer, bool invert);
    [ExtensionAttribute]
public static IEnumerable`1<T> TopoSort(IEnumerable`1<T> items, Func`2<T, IEnumerable`1<T>> childrenSelector, IEqualityComparer`1<T> equalityComparer, bool invert);
    public static IEnumerable`1<T> SparseTopoSort(IEnumerable`1<T> items, Func`2<T, IEnumerable`1<T>> dependencyProvider, bool invert, IEqualityComparer`1<T> equalityComparer);
    [NotNullAttribute]
[ItemNotNullAttribute]
public static IReadOnlyList`1<T> IterativeTopoSort(IEnumerable`1<T> nodes, Func`2<T, IEnumerable`1<T>> successors);
    [NotNullAttribute]
[ItemNotNullAttribute]
public static IReadOnlyList`1<T> IterativeTopoSort2(IEnumerable`1<T> nodes, Func`2<T, IEnumerable`1<T>> successors, bool checkCycle, IEnumerable`1<T> ready);
    [CanBeNullAttribute]
public static Nullable`1<Pair`2<TNode, TNode>> Check(IEnumerable`1<TNode> sortedNodes, Func`2<TNode, IEnumerable`1<TNode>> successors);
    [CompilerGeneratedAttribute]
internal static void <TopoSort>g__AddWithParent|9_0(T item, <>c__DisplayClass9_0`1& );
}
[ExtensionAttribute]
public static class JetBrains.Util.Special.GeneralUtil : object {
    private static int QuoteIfNeededRecursionLimit;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ConcurrentDictionary`2<Type, Func`2<ValueTuple`2<object, int>, string>> myQuoteIfNeededAutoRenderers;
    private static GeneralUtil();
    [ExtensionAttribute]
public static int EnsureInRange(int value, int lowerBound, int upperBound);
    [DebuggerStepThroughAttribute]
[EditorBrowsableAttribute("1")]
public static void If(bool condition, Action FTrue, Action FFalse);
    [DebuggerStepThroughAttribute]
[EditorBrowsableAttribute("1")]
public static void If(bool condition, Action FTrue);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
[EditorBrowsableAttribute("1")]
public static T If(T control, bool condition, Action`1<T> FTrue, Action`1<T> FFalse);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[DebuggerStepThroughAttribute]
[ContractAnnotationAttribute("object:null => null")]
[EditorBrowsableAttribute("1")]
public static TResult IfNotNull(TInput object, Func`2<TInput, TResult> functor);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
[ContractAnnotationAttribute("object:null => false")]
[ObsoleteAttribute("Do not use IfNotNull() for boolean conditions, it's not clear that it returns false on 'null' input")]
[EditorBrowsableAttribute("1")]
public static bool IfNotNull(TInput object, Func`2<TInput, bool> functor);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
[ContractAnnotationAttribute("object:null => null")]
[EditorBrowsableAttribute("1")]
public static TResult IfNotNull(Nullable`1<TInput> object, Func`2<TInput, TResult> functor);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
[EditorBrowsableAttribute("1")]
public static TResult IfNotNull(TInput object, Func`2<TInput, TResult> functor, TResult default);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
[EditorBrowsableAttribute("1")]
public static TResult IfNotNull(TInput object, Func`2<TInput, TResult> functor, Func`1<TResult> default);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
[EditorBrowsableAttribute("1")]
public static void DoIfNotNull(TInput object, Action`1<TInput> functor);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
[EditorBrowsableAttribute("1")]
public static void DoIfNotNull(Nullable`1<TInput> object, Action`1<Nullable`1<TInput>> functor);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
[EditorBrowsableAttribute("1")]
public static T IfNull(T object, Func`1<T> functor);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
[EditorBrowsableAttribute("1")]
public static bool IsAnyOf(T t, T[] set);
    [DebuggerStepThroughAttribute]
[EditorBrowsableAttribute("1")]
public static bool AllNotNull(Object[] set);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static DeferQuotedObject QuoteIfNeeded(object o);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static DeferQuotedThread QuoteIfNeeded(Thread thread);
    [ExtensionAttribute]
[NotNullAttribute]
[DebuggerStepThroughAttribute]
[EditorBrowsableAttribute("1")]
private static string QuoteIfNeededCore(object o, int depth);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static DeferQuotedList QuoteListIfNeeded(IEnumerable thіs);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static DeferQuotedSet QuoteSetIfNeeded(IEnumerable thіs);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static DeferQuotedCollectionSourceSet`1<TItem> QuoteSetIfNeeded(CollectionSource`1<TItem> thіs);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static DeferQuotedFrugalLocalList`1<TItem> QuoteSetIfNeeded(FrugalLocalList`1<TItem> thіs);
    [ExtensionAttribute]
[NotNullAttribute]
[EditorBrowsableAttribute("1")]
private static string QuoteListIfNeededCore(IEnumerable thіs, int depth);
    [ExtensionAttribute]
[NotNullAttribute]
[EditorBrowsableAttribute("1")]
private static string QuoteSetIfNeededCore(IEnumerable thіs, int depth);
    private static Func`2<ValueTuple`2<object, int>, string> QuoteIfNeededAutoRendererFactory(Type type);
    [DebuggerStepThroughAttribute]
[EditorBrowsableAttribute("1")]
public static T Return(Action`1<Func`2<T, T>> action);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
[EditorBrowsableAttribute("1")]
public static T With(T control, Action`1<T> action);
    [AsyncStateMachineAttribute("JetBrains.Util.Special.GeneralUtil/<WithAsync>d__34`1")]
[ExtensionAttribute]
[DebuggerStepThroughAttribute]
[EditorBrowsableAttribute("1")]
public static Task`1<T> WithAsync(T control, Func`2<T, Task> action);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
[EditorBrowsableAttribute("1")]
public static void WithDispose(T disposable, Action`1<T> action);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
[EditorBrowsableAttribute("1")]
public static R WithDispose(T disposable, Func`2<T, R> F);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
[EditorBrowsableAttribute("1")]
public static void WithDisposeNotNull(T disposable, Action`1<T> F);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
[EditorBrowsableAttribute("1")]
public static T WithNotNull(T item, Action`1<T> F);
    public static IEnumerable`1<T> SelfAndParentReversedPath(T node, Func`2<T, T> getParent);
    [IteratorStateMachineAttribute("JetBrains.Util.Special.GeneralUtil/<ParentReversedPath>d__40`1")]
public static IEnumerable`1<T> ParentReversedPath(T node, Func`2<T, T> getParent);
    public static bool Dfs(T root, Func`2<T, bool> action, Func`2<T, IEnumerable`1<T>> getChildren, Func`2<T, bool> visitChildren);
    [ExtensionAttribute]
[SourceTemplateAttribute]
public static void instring(int index, string s);
    [ExtensionAttribute]
[SourceTemplateAttribute]
public static void ifnempty(string s);
    [CompilerGeneratedAttribute]
internal static MemberInfo[] <QuoteIfNeededAutoRendererFactory>g__GetReadableMembers|31_1(Type type, BindingFlags visibility);
    [CompilerGeneratedAttribute]
internal static bool <QuoteIfNeededAutoRendererFactory>g__IsReadableMember|31_5(MemberInfo mi);
}
public class JetBrains.Util.StandardExternalProcess : object {
    [CompilerGeneratedAttribute]
private Process <Process>k__BackingField;
    private List`1<Action> myExitedListeners;
    public Process Process { get; }
    public bool HasExited { get; }
    public int Id { get; }
    public int ExitCode { get; }
    public StandardExternalProcess(Process process);
    [CompilerGeneratedAttribute]
public Process get_Process();
    public sealed virtual bool get_HasExited();
    public sealed virtual int get_Id();
    public sealed virtual void Kill();
    public sealed virtual bool WaitForExit(int milliseconds);
    public sealed virtual void WaitForExit();
    public sealed virtual int get_ExitCode();
    public sealed virtual void SubscribeProcessingOutput(Action`1<string> stdOutProcessor);
    public sealed virtual void SubscribeProcessingErrorOutput(Action`1<string> stdErrProcessor);
    public sealed virtual void StartProcessingOutput();
    public sealed virtual void StartProcessingErrorOutput();
    public sealed virtual void Start();
    public sealed virtual void AddExitListener(Action a);
    public sealed virtual void CancelOutputRead();
    public sealed virtual void CancelErrorRead();
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
private void <.ctor>b__4_0(object sender, EventArgs args);
}
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
[TypeConverterAttribute("JetBrains.Util.StringSlice/StringSliceConverter")]
[ValueSerializerAttribute("JetBrains.Util.StringSlice/StringSliceSerializer")]
public class JetBrains.Util.StringSlice : ValueType {
    private int myLength;
    private int myStart;
    private string myString;
    public static StringSlice Empty;
    [NotNullAttribute]
public static IEqualityComparer`1<StringSlice> DefaultComparer;
    [NotNullAttribute]
public static IEqualityComparer`1<StringSlice> CaseInsensitiveComparer;
    [NotNullAttribute]
private static CompareInfo myInvariantCultureCompareInfo;
    public int Length { get; }
    public char Item { get; }
    public bool IsEmpty { get; }
    public StringSlice(string s);
    public StringSlice(string s, TextRange range);
    public StringSlice(string s, int start);
    public StringSlice(string s, int start, int length);
    private static StringSlice();
    public int get_Length();
    public char get_Item(int i);
    public bool get_IsEmpty();
    private static void ThrowOutOfRange(string s, int start, int length);
    public int IndexOf(char value);
    public int IndexOf(char value, int startIndex);
    public int IndexOf(char value, int startIndex, int count);
    public int IndexOf(string value);
    public int IndexOf(string value, int startIndex);
    public int IndexOf(string value, int startIndex, int count);
    public int IndexOf(string value, StringComparison comparisonType);
    public int IndexOf(string value, int startIndex, StringComparison comparisonType);
    public int IndexOf(string value, int startIndex, int count, StringComparison comparisonType);
    public int IndexOfAny(Char[] anyOf);
    public int IndexOfAny(Char[] anyOf, int startIndex);
    public int IndexOfAny(Char[] anyOf, int startIndex, int count);
    public int LastIndexOf(char value);
    public int LastIndexOf(char value, int startIndex);
    public int LastIndexOf(char value, int startIndex, int count);
    public int LastIndexOf(string value);
    public int LastIndexOf(string value, int startIndex);
    public int LastIndexOf(string value, int startIndex, int count);
    public int LastIndexOf(string value, StringComparison comparisonType);
    public int LastIndexOf(string value, int startIndex, StringComparison comparisonType);
    public int LastIndexOf(string value, int startIndex, int count, StringComparison comparisonType);
    public int LastIndexOfAny(Char[] anyOf);
    public int LastIndexOfAny(Char[] anyOf, int startIndex);
    public int LastIndexOfAny(Char[] anyOf, int startIndex, int count);
    public StringSlice Substring(int startIndex);
    public StringSlice Substring(int startIndex, int length);
    public bool Contains(string value);
    public bool Contains(char value);
    public bool StartsWith(string value, StringComparison comparisonType);
    public bool StartsWith(StringSlice value, StringComparison comparisonType);
    public bool EndsWith(string value, StringComparison comparisonType);
    public IEnumerable`1<StringSlice> Split(Char[] separator);
    public StringSlice[] Split2(Char[] separator);
    [IteratorStateMachineAttribute("JetBrains.Util.StringSlice/<Split>d__48")]
public IEnumerable`1<StringSlice> Split(Char[] separator, StringSplitOptions options);
    public StringSlice[] Split2(Char[] separator, StringSplitOptions options);
    public StringSlice TrimStart(Char[] trimChars);
    public StringSlice TrimEnd(Char[] trimChars);
    public StringSlice Trim(Char[] trimChars);
    public bool Equals(string otherString);
    public bool Equals(string otherString, StringComparison comparisonRule);
    public bool Equals(StringSlice otherStringSlice, StringComparison comparisonRule);
    public int CompareTo(string otherString);
    public int CompareTo(string otherString, StringComparison comparisonRule);
    public int CompareTo(StringSlice& otherString, StringComparison comparisonRule);
    public bool EqualTo(string s);
    public bool EqualTo(string s, IEqualityComparer`1<StringSlice> comparer);
    public virtual string ToString();
    public void ProcessString(ProcessStringDelegate action);
    public T ProcessString(ProcessStringDelegate`1<T> action);
    public TResult ProcessString(TContext context, ProcessStringDelegate`2<TContext, TResult> λ);
    private sealed virtual override bool System.IEquatable<JetBrains.Util.StringSlice>.Equals(StringSlice other);
    public bool Equals(StringSlice other);
    public bool Equals(StringSlice other, IEqualityComparer`1<StringSlice> comparer);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static StringSlice op_Implicit(string s);
    public void AssertNotNull();
    public static bool op_Equality(StringSlice α, StringSlice β);
    public static bool op_Inequality(StringSlice α, StringSlice β);
    public static bool op_Equality(StringSlice α, string β);
    public static bool op_Inequality(StringSlice α, string β);
    public static bool op_Equality(string α, StringSlice β);
    public static bool op_Inequality(string α, StringSlice β);
    internal void StringBuilderAppend(StringBuilder sb, int index, int length);
}
[ExtensionAttribute]
public static class JetBrains.Util.StringSliceEx : object {
    [ExtensionAttribute]
[ObsoleteAttribute("Use the overload with the word Slice in it, otherwise it's easy to accidentally get it rebound to a native overload with Object that works just the same but makes an allocation with ToString().")]
public static StringBuilder Append(StringBuilder thіs, StringSlice text);
    [ExtensionAttribute]
[ObsoleteAttribute("Use the overload with the word Slice in it, otherwise it's easy to accidentally get it rebound to a native overload with Object that works just the same but makes an allocation with ToString().")]
public static StringBuilder Append(StringBuilder thіs, StringSlice text, int index, int length);
    [ExtensionAttribute]
[ObsoleteAttribute("Use the overload with the word Slice in it, otherwise it's easy to accidentally get it rebound to an overload with Object that works just the same but makes an allocation with ToString().")]
public static StringBuilder AppendLine(StringBuilder thіs, StringSlice text);
    [ExtensionAttribute]
public static StringBuilder AppendSlice(StringBuilder thіs, StringSlice text);
    [ExtensionAttribute]
public static StringBuilder AppendSlice(StringBuilder thіs, StringSlice text, int index, int length);
    [ExtensionAttribute]
public static StringBuilder AppendLineSlice(StringBuilder thіs, StringSlice text);
    [ExtensionAttribute]
public static string Join(IEnumerable`1<StringSlice> stringSlices, string separator);
    [IteratorStateMachineAttribute("JetBrains.Util.StringSliceEx/<ToStrings>d__7")]
[ExtensionAttribute]
public static IEnumerable`1<string> ToStrings(IEnumerable`1<StringSlice> stringSlices);
    [ExtensionAttribute]
public static bool Contains(StringSlice s, char value);
    [ExtensionAttribute]
public static bool TryGetSubstringAfterLast(StringSlice s, char value, StringSlice& subSlice);
    [ExtensionAttribute]
public static bool TryGetSubstringBeforeLast(StringSlice s, char value, StringSlice& subSlice);
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Util.StringSlicesEnumerable : ValueType {
    public static StringSlicesEnumerable Empty;
    private string mySource;
    private char mySeparator;
    private bool mySkipEmptyEntries;
    private Char[] mySeparators;
    public StringSlice FirstOrEmpty { get; }
    public StringSlice LastOrEmpty { get; }
    public StringSlice Item { get; }
    public StringSlicesEnumerable(string source, char separator, bool skipEmptyEntries);
    public StringSlicesEnumerable(string source, Char[] separators, bool skipEmptyEntries);
    private static StringSlicesEnumerable();
    public int IndexOf(string substringToSeek, StringComparison comparison);
    public StringSlice Single();
    public StringSlice Single(string sExceptionMessageEmpty, string sExceptionMessageAmbiguous);
    public bool IsSingle();
    public StringSlice get_FirstOrEmpty();
    public StringSlice get_LastOrEmpty();
    [IteratorStateMachineAttribute("JetBrains.Util.StringSlicesEnumerable/<ToStringEnumerable>d__15")]
public IEnumerable`1<string> ToStringEnumerable();
    public String[] ToStringArray();
    [IteratorStateMachineAttribute("JetBrains.Util.StringSlicesEnumerable/<AsEnumerable>d__17")]
[NotNullAttribute]
[PureAttribute]
public IEnumerable`1<StringSlice> AsEnumerable();
    public StringSlice get_Item(int index);
    [NotNullAttribute]
[PureAttribute]
public IList`1<StringSlice> ToList();
    [NotNullAttribute]
[PureAttribute]
public StringSlice[] ToArray();
    public int Count();
    [IteratorStateMachineAttribute("JetBrains.Util.StringSlicesEnumerable/<Select>d__23`1")]
public IEnumerable`1<TResult> Select(Func`2<StringSlice, TResult> selector);
    public bool Any(Func`2<StringSlice, bool> predicate);
    [IteratorStateMachineAttribute("JetBrains.Util.StringSlicesEnumerable/<Take>d__25")]
public IEnumerable`1<StringSlice> Take(int count);
    [NotNullAttribute]
[PureAttribute]
public string Join(string separator);
    [NotNullAttribute]
[PureAttribute]
public string AggregateString(string separator);
    [NotNullAttribute]
[PureAttribute]
public string AggregateString(string seed, string separator, Func`3<StringBuilder, StringSlice, StringBuilder> funcAppend);
    public bool Contains(string value, StringComparison comparison);
    public bool Contains(StringSlice value, StringComparison comparison);
    [IteratorStateMachineAttribute("JetBrains.Util.StringSlicesEnumerable/<MarkFirstAndLast>d__32")]
public IEnumerable`1<FirstLastItem`1<StringSlice>> MarkFirstAndLast();
    public StringSlicesEnumerator GetEnumerator();
    private static bool IsSeparator(char symbol, char separator, Char[] separators);
}
public class JetBrains.Util.StringTextElementEnumerator : ValueType {
    [NotNullAttribute]
private string myText;
    [NotNullAttribute]
private TextElementEnumerator myEnumerator;
    private int myStartIndex;
    private int myEndIndex;
    public TextRange Current { get; }
    public int StartOffset { get; }
    public int EndOffset { get; }
    public bool IsSingleChar { get; }
    public char SingleCharOrNull { get; }
    public StringTextElementEnumerator(string text, int startIndex);
    public TextRange get_Current();
    public int get_StartOffset();
    public int get_EndOffset();
    public bool get_IsSingleChar();
    public char get_SingleCharOrNull();
    [NotNullAttribute]
[PureAttribute]
public string GetTextElement();
    public bool MoveNext();
    public void SkipToOffset(int offset);
}
[ExtensionAttribute]
public static class JetBrains.Util.StringUtil : object {
    public static char DOT;
    public static char GENERIC_DELIMETER;
    public static char PLUS;
    public static char UNDERLINE;
    public static string SDOT;
    [NotNullAttribute]
private static Random ourRandom;
    [CanBeNullAttribute]
private static Regex ourRegexMacro;
    public static string HexDigitsformatString;
    private static int bytesPerUtf16Char;
    private static int hexcharsPerByte;
    [NotNullAttribute]
public static String[] NEW_LINE_STRINGS;
    [NotNullAttribute]
public static Char[] NEW_LINE_CHARACTERS;
    private static bool IsEqualityComparerGetHashCodeCaseInsensitivelyNative_WinNT0602;
    private static bool IsEqualityComparerGetHashCodeCaseInsensitivelyNative_WinNT0600;
    private static StringUtil();
    [ExtensionAttribute]
public static Nullable`1<T> Convert(string propertyValue, StringComparison stringComparison, Pair`2[] options);
    [ExtensionAttribute]
public static T Convert(string propertyValue, T fallbackValue, StringComparison stringComparison, Pair`2[] options);
    [ExtensionAttribute]
public static T Convert(string propertyValue, Func`1<T> fallbackValueFunc, StringComparison stringComparison, Pair`2[] options);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static Byte[] TryGetBase64Bytes(string payload);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static string DecodeFromBase64(string payload);
    public static string GetBase64String(string s);
    [ContractAnnotationAttribute("what: null => false; withWhat: null => false")]
public static bool StartsWith(string what, string withWhat, StringComparison comparison);
    [ObsoleteAttribute("It was buggy, use arg.SplitByNewLine()")]
[NotNullAttribute]
public static IEnumerable`1<string> GetLines(string text);
    [ContractAnnotationAttribute("str1: notnull, str2: notnull => notnull")]
[PureAttribute]
public static string Combine(string str1, string str2);
    [ContractAnnotationAttribute("null => null; notnull => notnull")]
[PureAttribute]
public static string ShortName(string name);
    [ContractAnnotationAttribute("partial: null => false; full: null => false")]
public static string NextQualification(string partial, string full);
    [ContractAnnotationAttribute("name: null => qualificationPrefix: null, null")]
public static string SplitName(string name, String& qualificationPrefix);
    [ContractAnnotationAttribute("name: null => qualificationPrefix: null, null")]
private static string SplitNameInternal(string name, Char[] splitChars, String& qualificationPrefix);
    [ContractAnnotationAttribute("name: null => qualificationPrefix: null, null")]
public static string SplitCLRName(string name, String& qualificationPrefix);
    [NotNullAttribute]
public static String[] FullySplitFQName(string fqName);
    [NotNullAttribute]
public static String[] SplitFQName(string fqName);
    public static string MakeFQName(String[] parts);
    public static string MakeFQName(string namespaceName, string className);
    [ObsoleteAttribute("Use 'System.String.Split' overload with parameter 'options'")]
[NotNullAttribute]
public static String[] Split(string stringToSplit, string delimChars, bool keepEmpty);
    [ExtensionAttribute]
[NotNullAttribute]
public static string TrimToSingleLineWithMaxLength(string stringToTrim, int maxLength);
    [NotNullAttribute]
public static string GetCommon(string qualified1, string qualified2, Int32& foundIndex);
    [ExtensionAttribute]
[ContractAnnotationAttribute("null => null; notnull => notnull")]
public static string Decapitalize(string s);
    [ExtensionAttribute]
[ContractAnnotationAttribute("null => null; notnull => notnull")]
public static string Capitalize(string s);
    [ExtensionAttribute]
[ContractAnnotationAttribute("from: null => null; what: null => null; => notnull")]
public static string TrimFromEnd(string from, string what);
    [ExtensionAttribute]
[ContractAnnotationAttribute("from: null => null; what: null => null; => notnull")]
public static string TrimFromEnd(string from, string what, StringComparison comparison);
    [ExtensionAttribute]
[ContractAnnotationAttribute("from: null => null; what: null => null; => notnull")]
public static string TrimFromStart(string from, string what);
    [ExtensionAttribute]
[ContractAnnotationAttribute("from: null => null; what: null => null; => notnull")]
public static string TrimFromStart(string from, string what, StringComparison comparison);
    [ContractAnnotationAttribute("from: null => null; what: null => null; => notnull")]
public static string TrimFQFromStart(string from, string what, StringComparison comparison);
    [NotNullAttribute]
public static string Unquote(string s);
    [NotNullAttribute]
public static string Escape(string s);
    [NotNullAttribute]
public static string Unescape(string s);
    [NotNullAttribute]
public static string MakeTitle(string text);
    [NotNullAttribute]
public static string CapitalizeWords(string s);
    [ContractAnnotationAttribute("null => null; notnull => notnull")]
public static string CutSpaces(string s);
    public static void CutSpaces(string s, StringBuilder sb);
    [NotNullAttribute]
public static string ExpandTabs(string s, int startColumn, UInt32 tabsize);
    public static int ExpandTabsAndCountColumns(StringSlice s, int startColumn, int tabsize);
    public static int Count(string s, char ch);
    public static int FindNthPos(string s, char ch, int n);
    [NotNullAttribute]
public static string StringArrayText(String[] array);
    [NotNullAttribute]
public static string NormalizeWhiteSpace(string s);
    [NotNullAttribute]
public static string GetPrefix(string text, char delim, TextRange& prefixRange);
    [NotNullAttribute]
public static string GetSuffix(string text, char delim, TextRange& suffixRange);
    public static bool EqIgnoreCase(string s1, string s2);
    [ExtensionAttribute]
[PureAttribute]
public static bool Equals(string what, string to, int atIndex, StringComparison comparisonType);
    [IteratorStateMachineAttribute("JetBrains.Util.StringUtil/<EnumeratePrefixes>d__52")]
[ItemNotNullAttribute]
[PureAttribute]
public static IEnumerable`1<string> EnumeratePrefixes(string s);
    [NotNullAttribute]
public static string MakeMacro(string name);
    [NotNullAttribute]
public static string SubstituteMacros(string sample, Func`2<string, string> getSubstFunc);
    [NotNullAttribute]
public static string SubstituteMacros(IDictionary`2<string, string> macros, string sample);
    [NotNullAttribute]
public static string GenerateRandomName(string prefix);
    [NotNullAttribute]
public static string GenerateRandomName();
    [NotNullAttribute]
public static string GenerateRandomName(int length);
    [NotNullAttribute]
public static string GenerateRandomName(int length, Random rand);
    [NotNullAttribute]
public static string GenerateRandomNameForObject(object instance);
    public static DeferredRandomNameForObject GenerateRandomNameForObjectDeferred(object instance);
    [ExtensionAttribute]
public static StringBuilder AppendDelimited(StringBuilder builder, IEnumerable`1<T> enumerable, Func`2<T, string> presenter, string delimiter);
    [ExtensionAttribute]
public static StringBuilder AppendDelimited(StringBuilder builder, IEnumerable`1<string> enumerable, string delimiter);
    [ExtensionAttribute]
[NotNullAttribute]
public static string Replace(string s, Func`2<char, char> replacer);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => true")]
public static bool IsNullOrEmpty(string value);
    [ExtensionAttribute]
[ContractAnnotationAttribute("null=>true")]
public static bool IsEmpty(string s);
    [ExtensionAttribute]
[ContractAnnotationAttribute("null=>false")]
public static bool IsNotEmpty(string s);
    [ExtensionAttribute]
public static bool IsEmpty(StringBuilder builder);
    [ExtensionAttribute]
public static bool IsWhiteSpace(StringBuilder builder);
    [ExtensionAttribute]
public static string NotEmptyOrNull(string s);
    [NotNullAttribute]
[StringFormatMethodAttribute("format")]
public static string FormatQuoted(string format, Object[] args);
    [ExtensionAttribute]
[NotNullAttribute]
public static string QuoteIfNeeded(string s);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static string RemoveQuotes(string s);
    [NotNullAttribute]
public static string EncodeStringForSgml(string s);
    [CanBeNullAttribute]
public static string ToStringIfNonDefault(object o);
    [NotNullAttribute]
public static string DropMiddleIfLong(string text, int nMaxLen);
    [ExtensionAttribute]
[NotNullAttribute]
public static string Join(IEnumerable`1<string> strings, string separator);
    [ExtensionAttribute]
[NotNullAttribute]
public static string ToHexString(IntPtr intptr);
    [NotNullAttribute]
public static string ToHexString(Void* intptr);
    [ExtensionAttribute]
[NotNullAttribute]
public static string ToHexString(UIntPtr uintptr);
    [NotNullAttribute]
public static string ToHexString(Byte[] buf);
    [NotNullAttribute]
public static string ToUtf16HexString(string s);
    [NotNullAttribute]
public static string FromUtf16HexString(string hex);
    [NotNullAttribute]
[ObsoleteAttribute("This method does not support culture, so use an overload without it.")]
public static string ToStringWithLeading(int value, int maxvalue, CultureInfo culture);
    [NotNullAttribute]
public static string ToStringWithLeading(int value, int maxvalue);
    [ExtensionAttribute]
[StringFormatMethodAttribute("format")]
[NotNullAttribute]
public static StringBuilder AppendLine(StringBuilder sb, string format, Object[] args);
    [ExtensionAttribute]
[StringFormatMethodAttribute("format")]
[NotNullAttribute]
public static StringBuilder AppendLine(StringBuilder sb, string format, object argA);
    [ExtensionAttribute]
[StringFormatMethodAttribute("format")]
[NotNullAttribute]
public static StringBuilder AppendLine(StringBuilder sb, string format, object argA, object argB);
    [ExtensionAttribute]
[StringFormatMethodAttribute("format")]
[NotNullAttribute]
public static StringBuilder AppendLine(StringBuilder sb, string format, object argA, object argB, object argC);
    [ExtensionAttribute]
[NotNullAttribute]
public static string FullReplace(string input, string oldValue, string newValue);
    [ExtensionAttribute]
[NotNullAttribute]
public static string FullReplace(string input, string oldValue, string newValue, StringComparison stringComparison);
    [ExtensionAttribute]
[NotNullAttribute]
public static String[] SplitByWords(string text);
    [ExtensionAttribute]
[NotNullAttribute]
public static StringBuilder Prepend(StringBuilder builder, char char);
    [ExtensionAttribute]
[NotNullAttribute]
public static StringBuilder Prepend(StringBuilder builder, string text);
    [ExtensionAttribute]
[NotNullAttribute]
public static string Times(int n, string phrase);
    [ExtensionAttribute]
public static bool IsWhitespace(string s);
    [ExtensionAttribute]
public static bool IsPureWhitespace(string s);
    [ExtensionAttribute]
public static bool IsPureWhitespace(char c);
    [ExtensionAttribute]
[ContractAnnotationAttribute("null => true")]
public static bool IsNullOrWhitespace(string s);
    [ExtensionAttribute]
[PureAttribute]
public static char Last(string s);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsNewLine(string s);
    [ExtensionAttribute]
[PureAttribute]
public static bool ContainsNewLine(string s);
    [ExtensionAttribute]
[PureAttribute]
public static bool EndsWithNewLine(string s);
    [ExtensionAttribute]
[PureAttribute]
public static bool StartsWithNewLine(string s);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static String[] SplitByNewLine(string s, int count, StringSplitOptions options);
    [IteratorStateMachineAttribute("JetBrains.Util.StringUtil/<SplitByNewLineRanges>d__112")]
[NotNullAttribute]
[PureAttribute]
public static IEnumerable`1<TextRange> SplitByNewLineRanges(string text, StringSplitOptions options);
    [ExtensionAttribute]
[NotNullAttribute]
public static string ReplaceNewLines(string s, string replaceWith);
    [ExtensionAttribute]
[NotNullAttribute]
public static Char[] ToLowerCharArray(string s);
    [ExtensionAttribute]
[NotNullAttribute]
public static string Multiply(string source, int multiplier);
    [NotNullAttribute]
public static string MakeUpperCamelCaseName(string name);
    [NotNullAttribute]
public static string MakeUnderscoreCaseName(string str);
    [ExtensionAttribute]
public static long GetPlatformIndependentHashCode64(string s);
    [ExtensionAttribute]
[PureAttribute]
public static int GetPlatformIndependentHashCode(string s, bool caseSensitive);
    [ExtensionAttribute]
[PureAttribute]
public static int GetPlatformIndependentHashCode(StringBuilder sb, bool caseSensitive);
    [NotNullAttribute]
public static string UrlEncode(string text);
    [ExtensionAttribute]
[NotNullAttribute]
[ObsoleteAttribute("Use QuoteSet/QuoteList ext methods.")]
public static string ObjectsToString(IEnumerable`1<T> strings, string separator);
    [ExtensionAttribute]
[ObsoleteAttribute("Slow for massive use. Consider using XmlUtil::EscapeXmlString.")]
[ContractAnnotationAttribute("null => null; notnull => notnull")]
public static string HtmlEncode(string text);
    [NotNullAttribute]
public static string GetCommonPrefix(string s1, string s2);
    [NotNullAttribute]
public static string GetCommonPrefix(string s1, string s2, bool ignoreCase);
    private static int GetCommonPrefixLength(string s1, string s2, bool ignoreCase);
    [ExtensionAttribute]
[NotNullAttribute]
public static string ShortenTextWithEllipsis(string text, int maxLength);
    [HandleProcessCorruptedStateExceptionsAttribute]
[NotNullAttribute]
public static string GetStringOrErrorMessage(Func`1<T> getter);
    public static string StrFormatByteSize(long nSize);
    public static string StrFormatByteSizeSimple(long size);
    public static UInt32 StringCchLength(Char* psz, UInt32 cchMax);
    [PureAttribute]
public static int EqualityComparerGetHashCodeCaseInsensitively(Char* pch, UInt32 cch);
    [PureAttribute]
public static int EqualityComparerGetHashCodeCaseInsensitively_WinNT0602(Char* pch, UInt32 cch);
    [PureAttribute]
public static int EqualityComparerGetHashCodeCaseInsensitively_WinNT0600(Char* pch, UInt32 cch);
    [PureAttribute]
public static int EqualityComparerGetHashCodeCaseInsensitively_Msil(Char* pch, UInt32 cch);
    [CompilerGeneratedAttribute]
internal static string <DropMiddleIfLong>g__FormatMoreChars|77_0(int n, <>c__DisplayClass77_0& );
}
public class JetBrains.Util.Tests.ThrowsAccumulatedLoggerExceptions : object {
    private static int MaxExceptionCount;
    private Func`1<CompoundException> myFCreateExceptionContainer;
    private LifetimeDefinition myLifetimeDefinition;
    private SpinWaitLock myLock;
    private CompoundException myLoggedExceptions;
    private bool myDisposeReentrancyGuard;
    [CompilerGeneratedAttribute]
private EventHandler`1<ExceptionEventArgs> ExceptionLogged;
    [NotNullAttribute]
public CompoundException LoggedExceptions { get; }
    protected ThrowsAccumulatedLoggerExceptions(Func`1<CompoundException> FCreateExceptionContainer);
    public CompoundException get_LoggedExceptions();
    public void Dispose(bool captureFinallyExceptions);
    [NotNullAttribute]
public CompoundException RecycleLoggedExceptions();
    public void RunWithoutExceptionLogging(Action action);
    public void ThrowLoggedExceptions();
    [CompilerGeneratedAttribute]
public void add_ExceptionLogged(EventHandler`1<ExceptionEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_ExceptionLogged(EventHandler`1<ExceptionEventArgs> value);
    protected virtual void ThrowLoggedExceptions_ThrowSpecial(CompoundException compound);
    private void OnException(Exception ex);
    public sealed virtual void Dispose();
    private sealed virtual override void JetBrains.Util.ILogEventListener.OnLogEvent(LogEvent logEvent);
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Util.Text.AggregatedBuffer : object {
    private IBuffer[] myBuffers;
    public int Length { get; }
    public char Item { get; }
    public AggregatedBuffer(IBuffer b1, IBuffer b2, IBuffer b3);
    public AggregatedBuffer(IBuffer[] buffers, bool simplify);
    public sealed virtual int get_Length();
    public sealed virtual string GetText();
    public sealed virtual string GetText(TextRange range);
    public sealed virtual void AppendTextTo(StringBuilder builder, TextRange range);
    public sealed virtual char get_Item(int index);
    public sealed virtual void CopyTo(int sourceIndex, Char[] destinationArray, int destinationIndex, int length);
    public IBuffer Project(TextRange range);
}
public class JetBrains.Util.Text.AhoCorasickStateMachine : object {
    private Int32[] myIndexedSymbols;
    private int myChildrenCount;
    private State[] myStates;
    private int myCurrentState;
    [CompilerGeneratedAttribute]
private String[] <Patterns>k__BackingField;
    public String[] Patterns { get; }
    public Int32[] CurrentPatternsIndices { get; }
    public String[] CurrentPatterns { get; }
    public bool Any { get; }
    public AhoCorasickStateMachine(IEnumerable`1<string> patterns);
    [CompilerGeneratedAttribute]
public String[] get_Patterns();
    public Int32[] get_CurrentPatternsIndices();
    public String[] get_CurrentPatterns();
    public bool get_Any();
    public bool Advance(char symbol);
    public bool Match(string text);
    public void Reset();
    private void IndexSymbols(IEnumerable`1<char> allSymbols);
    private TrieNode[] BuildTrie(IReadOnlyList`1<string> patterns);
    private void BuildStateMachine(TrieNode[] trieNodes);
    [CompilerGeneratedAttribute]
private void <BuildTrie>g__AddPattern|18_1(string pattern, int index, <>c__DisplayClass18_0& );
    [CompilerGeneratedAttribute]
private int <BuildTrie>g__AddSymbol|18_2(int node, char symbol, <>c__DisplayClass18_0& );
}
[ExtensionAttribute]
public static class JetBrains.Util.Text.BufferRangeEx : object {
    public static bool CompareBufferText(BufferRange b1, BufferRange b2, bool caseSensitive);
    public static bool CompareBufferText(BufferRange b1, string b2, bool caseSensitive);
    [ExtensionAttribute]
public static bool StringEquals(BufferRange range, string str, bool caseSensitive);
    [ExtensionAttribute]
public static bool StringEquals(BufferRange range, BufferRange other, bool caseSensitive);
}
public static class JetBrains.Util.Text.EncodingUtil : object {
    public static Encoding CP1251;
    public static Encoding CP1252;
    public static Encoding Utf8NoBom;
    public static Encoding Utf8WithBom;
    public static Encoding Utf32LittleEndianNoBom;
    public static Encoding Utf32LittleEndianWithBom;
    public static Encoding Utf32BigEndianWithBom;
    public static Encoding Utf32BigEndianNoBom;
    public static Encoding Utf16LittleEndianNoBom;
    public static Encoding Utf16LittleEndianWithBom;
    public static Encoding Utf16BigEndianWithBom;
    public static Encoding Utf16BigEndianNoBom;
    [CompilerGeneratedAttribute]
private static Encoding <DefaultEncoding>k__BackingField;
    [NotNullAttribute]
public static Encoding DefaultEncoding { get; private set; }
    private static EncodingUtil();
    [CompilerGeneratedAttribute]
public static Encoding get_DefaultEncoding();
    [CompilerGeneratedAttribute]
private static void set_DefaultEncoding(Encoding value);
}
public enum JetBrains.Util.Text.LineEnding : Enum {
    public UInt32 value__;
    public static LineEnding LF;
    public static LineEnding CR;
    public static LineEnding CRLF;
    public static LineEnding LS;
    public static LineEnding PS;
    public static LineEnding VT;
    public static LineEnding FF;
    public static LineEnding NEL;
    public static LineEnding Eof;
}
[ExtensionAttribute]
public static class JetBrains.Util.Text.LineEndings : object {
    [ThreadStaticAttribute]
private static List`1<LineSegment> mySmallBuffer;
    public static int AverageLineLength;
    private static LineEndings();
    public static LineEnding ParseLineEnding(string text, OnError onerror);
    public static LineEnding ParseLineEnding(IBuffer buffer, UInt32 offset, UInt32 length, OnError onerror);
    [ExtensionAttribute]
public static string ToLineEndingString(LineEnding lineending);
    [NotNullAttribute]
public static List`1<LineSegment> DetectLineEndings(TextRange rangeWholeLines, IBuffer buffer);
    public static LineEnding GetFirstLineEnding(IBuffer buffer);
    [ExtensionAttribute]
public static LineEnding GetMostPopularLineEnding(IBuffer buffer);
    public static LineEnding GetMostPopularLineEnding(List`1<LineSegment> lines, IBuffer buffer);
    public static DetectLineEndingsContext DetectLineEndingsCore(TextRange range, IBuffer buffer, Flags flags, Nullable`1<DetectLineEndingsContext> mctx);
    [ExtensionAttribute]
[NotNullAttribute]
public static string UnifyLineSeparators(string str, LineEnding newLineEnding);
    [ExtensionAttribute]
[NotNullAttribute]
public static string UnifyLineSeparators(string str, string newLineEnding);
    [ExtensionAttribute]
[NotNullAttribute]
public static string UnifyLineSeparators(IBuffer buffer, LineEnding newLineEnding);
}
[ExtensionAttribute]
public static class JetBrains.Util.Text.LineEndingUtil : object {
    private static StringBuffer LF_BUFFER;
    private static StringBuffer CR_BUFFER;
    private static StringBuffer CR_LF_BUFFER;
    private static StringBuffer LS_BUFFER;
    private static StringBuffer PS_BUFFER;
    private static StringBuffer VT_BUFFER;
    private static StringBuffer FF_BUFFER;
    private static StringBuffer NEL_BUFFER;
    private static StringBuffer UNKNOWN_BUFFER;
    private static LineEndingUtil();
    [ExtensionAttribute]
public static string GetName(LineEnding nl);
    [ExtensionAttribute]
public static string GetPresentation(LineEnding nl);
    [ExtensionAttribute]
public static StringBuffer GetPresentationAsBuffer(LineEnding nl);
    public static LineEnding DetectLineEnding(string text);
    public static LineEnding DetectLineEnding(IBuffer text, int offset);
    public static int DetectLineStartIndex(IBuffer text, int lineNumber);
    public static bool CanStartComplexLineEnding(char c);
}
public class JetBrains.Util.Text.PooledThinArrayBuffer : ThinArrayBuffer {
    public PooledThinArrayBuffer(ICharBufferAllocator pool, int capacity);
}
public class JetBrains.Util.Text.ProductDefaultLineEndings : object {
    protected static string DefaultLineEndingInternal;
    public static string DefaultLineEnding { get; }
    private static ProductDefaultLineEndings();
    public static string get_DefaultLineEnding();
}
[ExtensionAttribute]
public static class JetBrains.Util.Text.ProductDefaultLineEndingsUtils : object {
    [ExtensionAttribute]
public static StringBuilder AppendLineWithCorrectLineEnding(StringBuilder sb);
    [ExtensionAttribute]
public static StringBuilder AppendLineWithCorrectLineEnding(StringBuilder sb, string value);
}
[ExtensionAttribute]
public static class JetBrains.Util.Text.TextWriterEx : object {
    [ExtensionAttribute]
public static void WriteLinesSorted(TextWriter writer, Action`1<SortedLinesTextWriter> writeAction);
    [ExtensionAttribute]
public static void WriteLinesSorted(TextWriter writer, IComparer`1<string> comparer, Action`1<SortedLinesTextWriter> writeAction);
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Util.Text.ThinArrayBuffer : object {
    private static int DEFAULT_POOLED_CAPACITY;
    private static int DEFAULT_INITIAL_CAPACITY;
    private ICharBufferAllocator myAllocator;
    private Char[] myBuffer;
    private int myLength;
    public int Length { get; }
    public char Item { get; }
    public ThinArrayBuffer(int capacity);
    protected ThinArrayBuffer(ICharBufferAllocator allocator, int capacity, bool hollow);
    protected ThinArrayBuffer(ICharBufferAllocator allocator, Char[] buf);
    public sealed virtual int get_Length();
    public sealed virtual string GetText(TextRange range);
    public sealed virtual void AppendTextTo(StringBuilder builder, TextRange range);
    public sealed virtual string GetText();
    public sealed virtual void Insert(int offset, string text);
    public void Append(string s);
    public void Append(string s, int offset, int length);
    public void Append(IBuffer buf, int offset, int length);
    public sealed virtual void Remove(int offset, int length);
    public sealed virtual void Replace(int offset, int length, string newText);
    public sealed virtual void Replace(int offset, int length, BufferRange newText);
    public sealed virtual char get_Item(int index);
    public sealed virtual void CopyTo(int sourceIndex, Char[] destinationArray, int destinationIndex, int length);
    public void ClearBuffer();
    public void InitBuffer();
    private void EnsureCharArray(int capacity);
    [ConditionalAttribute("JET_MODE_ASSERT")]
private void AssertOffsetAndLength(int offset, int length);
    [ConditionalAttribute("JET_MODE_ASSERT")]
private void AssertOffsetAndLength(IBuffer buf, int offset, int length);
    [ConditionalAttribute("JET_MODE_ASSERT")]
private void AssertOffsetAndLength(string s, int offset, int length);
    private void ThrowRangeException(int offset, int length);
    private void ThrowLengthException(int offset, int length);
}
[ExtensionAttribute]
public static class JetBrains.Util.Text.XDocumentUtil : object {
    [NotNullAttribute]
public static XDocument Load(VirtualFileSystemPath documentPath, LoadOptions options);
    [CanBeNullAttribute]
public static XDocument TryLoad(VirtualFileSystemPath documentPath, LoadOptions options);
    [ExtensionAttribute]
[NotNullAttribute]
public static XElement FindOrCreateSingleElement(XElement element, string name, Position position);
    [ExtensionAttribute]
[NotNullAttribute]
public static Encoding GetEncoding(XDocument document);
}
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{DebugView,nq}")]
public class JetBrains.Util.TextRange : ValueType {
    [DebuggerBrowsableAttribute("0")]
private int myStartOffset;
    [DebuggerBrowsableAttribute("0")]
private int myEndOffset;
    [DebuggerBrowsableAttribute("0")]
public static TextRange InvalidRange;
    public int StartOffset { get; }
    public int EndOffset { get; }
    public int Length { get; }
    public bool IsEmpty { get; }
    [NotNullAttribute]
[DebuggerBrowsableAttribute("0")]
private string DebugView { get; }
    public bool IsValid { get; }
    public bool IsNormalized { get; }
    [DebuggerStepThroughAttribute]
public TextRange(int startOffset, int endOffset);
    [DebuggerStepThroughAttribute]
public TextRange(int offset);
    private static TextRange();
    public int get_StartOffset();
    public int get_EndOffset();
    public int get_Length();
    public bool get_IsEmpty();
    private string get_DebugView();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(TextRange other);
    public virtual int GetHashCode();
    public virtual string ToString();
    [NotNullAttribute]
[PureAttribute]
public string ToString(IFormatProvider formatProvider);
    [NotNullAttribute]
[PureAttribute]
public string ToInvariantString();
    [PureAttribute]
public static TextRange Parse(string s);
    [PureAttribute]
public static TextRange FromLength(int offset, int length);
    [PureAttribute]
public static TextRange FromLength(int length);
    [PureAttribute]
public static TextRange FromUnorderedOffsets(int one, int onemore);
    [PureAttribute]
public int GetMinOffset();
    [PureAttribute]
public int GetMaxOffset();
    [PureAttribute]
public bool ContainedIn(TextRange& textRange);
    [PureAttribute]
public bool StrictContainedIn(TextRange& textRange);
    [PureAttribute]
public bool Contains(TextRange& textRange);
    [PureAttribute]
public bool Contains(int offset);
    [PureAttribute]
public bool ContainsCharIndex(int charindex);
    [PureAttribute]
public TextRange SetStartTo(int offset);
    [PureAttribute]
public TextRange SetEndTo(int offset);
    [PureAttribute]
public TextRange Left(int length);
    [PureAttribute]
public TextRange Right(int length);
    [PureAttribute]
[DebuggerStepThroughAttribute]
public TextRange TrimLeft(int length);
    [PureAttribute]
[DebuggerStepThroughAttribute]
public TextRange TrimRight(int length);
    [PureAttribute]
[DebuggerStepThroughAttribute]
public TextRange ExtendLeft(int length);
    [PureAttribute]
[DebuggerStepThroughAttribute]
public TextRange ExtendRight(int length);
    [PureAttribute]
[DebuggerStepThroughAttribute]
public TextRange Shift(int delta);
    [PureAttribute]
public TextRange Join(TextRange& textRange);
    [PureAttribute]
public TextRange JoinLeft(TextRange& textRange);
    [PureAttribute]
public TextRange JoinRight(TextRange& textRange);
    [PureAttribute]
public bool IntersectsOrContacts(TextRange& textRange);
    [PureAttribute]
public bool StrictIntersects(TextRange& textRange);
    [PureAttribute]
public TextRange Intersect(TextRange& textRange);
    public bool get_IsValid();
    [ConditionalAttribute("JET_MODE_ASSERT")]
public void AssertValid();
    [ConditionalAttribute("JET_MODE_ASSERT")]
public void AssertNormalized();
    [ConditionalAttribute("JET_MODE_ASSERT")]
public void AssertContainedIn(TextRange& rangeContainer);
    public bool get_IsNormalized();
    [PureAttribute]
public TextRange Normalized();
    [PureAttribute]
public TextRange FlipOffsets();
    public static bool op_Equality(TextRange& range1, TextRange& range2);
    public static bool op_Inequality(TextRange& range1, TextRange& range2);
    public void Deconstruct(Int32& startOffset, Int32& endOffset);
    [PureAttribute]
public int DistanceTo(int offset);
    [PureAttribute]
public bool IsLeftTo(int offset);
    [PureAttribute]
public TextRange UpdateRange(int changeStartOffset, int oldLength, int newLength, bool greedyToLeft, bool greedyToRight);
}
public class JetBrains.Util.TextRangeComparer : object {
    [NotNullAttribute]
public static IComparer`1<TextRange> Default;
    private static TextRangeComparer();
    public sealed virtual int Compare(TextRange x, TextRange y);
}
[ExtensionAttribute]
public static class JetBrains.Util.TextRangeEx : object {
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static string Substring(string str, TextRange range);
    [ExtensionAttribute]
[NotNullAttribute]
public static StringBuilder Append(StringBuilder builder, string value, TextRange range);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static string ToString(StringBuilder builder, TextRange range);
    [ExtensionAttribute]
[PureAttribute]
public static bool RangeStartsWith(string str, TextRange range, string value);
    [ExtensionAttribute]
[PureAttribute]
public static bool RangeEndsWith(string str, TextRange range, string value);
    [ExtensionAttribute]
[PureAttribute]
public static bool RangeEquals(string str, TextRange range, string value);
    [ExtensionAttribute]
[PureAttribute]
public static bool RangeStartsWith(string str, TextRange range, string value, StringComparison comparison);
    [ExtensionAttribute]
[PureAttribute]
public static bool RangeEndsWith(string str, TextRange range, string value, StringComparison comparison);
    [ExtensionAttribute]
[PureAttribute]
public static bool RangeEquals(string str, TextRange range, string value, StringComparison comparison);
    [ExtensionAttribute]
[NotNullAttribute]
public static IList`1<TextRange> Merge(IList`1<TextRange> ranges);
}
public class JetBrains.Util.Threading.AsyncPipeReader : object {
    private static bool OptionDeferReleaseNativeResources;
    public static UInt32 ReadBufferSize;
    private ILogger Logger;
    [CanBeNullAttribute]
private Action myFUserOnEof;
    [NotNullAttribute]
private Action`1<ByteBuffer> myFUserOnRead;
    private LockObject myIsBusy;
    private int myIsInCallback;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) myIsReadChainStopped;
    private Lifetime myLifetime;
    private OVERLAPPED* myOverlapped;
    private OverlappedIoOperationTpioControl myOverlappedIoOperationTpioControl;
    private Void* myPipeReadHandle;
    private Void* myReadBuffer;
    public bool IsRunning { get; }
    public AsyncPipeReader(Lifetime lifetime, Void* hPipeRead, Action`1<ByteBuffer> FOnRead, Action FUserOnEof);
    private static AsyncPipeReader();
    public bool get_IsRunning();
    private OperationsChain InitiateOverlappedIoConnectNamedPipe();
    private OperationsChain InitiateOverlappedIoReadFile();
    private void IoCompletionCallback(Void* Instance, Void* Context, Void* Overlapped, UInt32 IoResult, UIntPtr NumberOfBytesTransferred, Void* Io);
    private void OnNoMoreRead();
    private void OnRead(ByteBuffer buffer);
    private void ReadLoop();
    private OperationsChain SwitchIoResult(WinError ioresult, SwitchFlags switchflags, UInt32 dwBytesRead, OperationControlFlags operflags);
    [CompilerGeneratedAttribute]
private void <.ctor>b__13_2();
    [CompilerGeneratedAttribute]
private void <.ctor>b__13_3();
    [CompilerGeneratedAttribute]
private void <.ctor>b__13_4();
}
public class JetBrains.Util.Threading.AsyncPipeTextLineReader : object {
    private static ILogger Logger;
    private static AsyncPipeTextLineReader();
    public static void ReadLinesWithDeferredCallback(Lifetime lifetime, Void* hPipeRead, Encoding encoding, Action`1<string> FOnReadLineDeferred);
    public static void ReadLinesWithDirectCallback(Lifetime lifetime, Void* hPipeRead, Encoding encoding, ReadLineDelegate FOnReadLine);
}
public class JetBrains.Util.Threading.CallerInfo : ValueType {
    public bool IsCallerNameFilePath;
    public string CallerName;
    public string CallerMemberName;
    private string myCallerNamePrepared;
    private static string ourSolutionLocation;
    public string CallerNamePrepared { get; }
    public CallerInfo(string callerName, string callerMemberName, bool isCallerNameFilePath);
    private static CallerInfo();
    [NotNullAttribute]
private static string GetSolutionLocation(string callerFilePath);
    public static CallerInfo Create(string callerFilePath, string callerMemberName);
    public string get_CallerNamePrepared();
    public virtual string ToString();
}
public interface JetBrains.Util.Threading.IReaderWriterLock {
    public bool IsReadAccessAllowed { get; }
    public bool IsReadLockHeld { get; }
    public bool IsWriteAccessAllowed { get; }
    public bool IsWriteLockHeld { get; }
    public bool IsWriteLockRequested { get; }
    public IInterruptionSource Interruption { get; }
    public abstract virtual bool get_IsReadAccessAllowed();
    public abstract virtual bool get_IsReadLockHeld();
    public abstract virtual bool get_IsWriteAccessAllowed();
    public abstract virtual bool get_IsWriteLockHeld();
    public abstract virtual bool get_IsWriteLockRequested();
    public abstract virtual IInterruptionSource get_Interruption();
    public abstract virtual void AcquireReadLock();
    public abstract virtual void AcquireWriteLock(CallerInfo callerInfo);
    public abstract virtual void AcquireWriteLock(string callerFilePath, string callerMemberName);
    public abstract virtual void ReleaseReadLock();
    public abstract virtual void ReleaseWriteLock();
    public abstract virtual bool TryAcquireReadLock(int timeout);
    public abstract virtual bool TryAcquireWriteLock(int timeout, CallerInfo callerInfo);
    public abstract virtual bool TryAcquireWriteLock(int timeout, string callerFilePath, string callerMemberName);
}
[ExtensionAttribute]
public static class JetBrains.Util.Threading.IReaderWriterLockEx : object {
    [ExtensionAttribute]
public static bool TryAcquire(IReaderWriterLock me, Lifetime lifetime, bool acquireWrite);
}
[ExtensionAttribute]
public static class JetBrains.Util.Threading.JetTaskEx : object {
    public static TimeSpan ChunkTimeLimit;
    private static JetTaskEx();
    [ExtensionAttribute]
public static bool IsLongRunning(Task task);
    [ExtensionAttribute]
[PublicAPIAttribute]
public static bool IsProcessCancelled(Task task);
    [PublicAPIAttribute]
public static void ParseAggregateException(Exception& toUpdate, AggregateException possibleAggregateException);
    [ExtensionAttribute]
[PublicAPIAttribute]
[NotNullAttribute]
public static TTask Started(TTask task, TaskScheduler scheduler, bool sync);
    [ExtensionAttribute]
[PublicAPIAttribute]
[NotNullAttribute]
public static WaitHandle WaitHandle(Task task);
    [NotNullAttribute]
[ObsoleteAttribute("Use system Task::Delay where possible. Behavior expected to be the same.")]
public static Task Delay(TimeSpan delay, Nullable`1<CancellationToken> cancellationMaybe);
    [ExtensionAttribute]
[NotNullAttribute]
public static Task`1<TResult[]> ContinueWhenCatchAll(IEnumerable`1<Task`1<TResult>> tasks, ILogger logger);
    [ExtensionAttribute]
[NotNullAttribute]
public static Task ContinueWhenCatchAll(IEnumerable`1<Task> tasks, ILogger logger);
    [AsyncStateMachineAttribute("JetBrains.Util.Threading.JetTaskEx/<While>d__8")]
public static Task`1<bool> While(Func`1<bool> condition, Nullable`1<TimeSpan> timeout, OnWaitTimeout ontimeout);
    [AsyncStateMachineAttribute("JetBrains.Util.Threading.JetTaskEx/<While>d__9")]
public static Task`1<bool> While(Func`1<Task`1<bool>> condition, Nullable`1<TimeSpan> timeout, OnWaitTimeout ontimeout);
    [AsyncStateMachineAttribute("JetBrains.Util.Threading.JetTaskEx/<While>d__10")]
public static Task`1<bool> While(IProperty`1<bool> condition, Nullable`1<TimeSpan> timeout, OnWaitTimeout ontimeout);
    [AsyncStateMachineAttribute("JetBrains.Util.Threading.JetTaskEx/<IgnoreCanceled>d__11")]
[ExtensionAttribute]
[PublicAPIAttribute]
public static Task IgnoreCanceled(Task task);
    [AsyncStateMachineAttribute("JetBrains.Util.Threading.JetTaskEx/<IgnoreCanceled>d__12`1")]
[ExtensionAttribute]
[PublicAPIAttribute]
public static Task`1<T> IgnoreCanceled(Task`1<T> task, T defaultValue);
    [ExtensionAttribute]
[NotNullAttribute]
public static Task AwaitNoLongerThan(Task task, string reason, TimeSpan limit, ILogger logger, LoggingLevel level);
    [ExtensionAttribute]
[NotNullAttribute]
public static Task`1<TResult> AwaitNoLongerThan(Task`1<TResult> task, string reason, TimeSpan limit, ILogger logger, LoggingLevel level);
    [AsyncStateMachineAttribute("JetBrains.Util.Threading.JetTaskEx/<AwaitNoLongerThanCore>d__15")]
[NotNullAttribute]
private static Task AwaitNoLongerThanCore(Task task, string reason, TimeSpan limit, ILogger logger, LoggingLevel level);
    [AsyncStateMachineAttribute("JetBrains.Util.Threading.JetTaskEx/<AwaitNoLongerThanCore>d__16`1")]
[NotNullAttribute]
private static Task`1<TResult> AwaitNoLongerThanCore(Task`1<TResult> task, string reason, TimeSpan limit, ILogger logger, LoggingLevel level);
    [NotNullAttribute]
private static TimeoutException AwaitNoLongerThanCore_TimedOut(string reason, TimeSpan limit, ILogger logger, LoggingLevel level);
    [ExtensionAttribute]
public static Task`1<bool> ToTask(WaitHandle handle, Nullable`1<TimeSpan> timeout, CancellationToken cancellationToken);
    [ExtensionAttribute]
[NotNullAttribute]
public static Task`1<TResult> ContinueAsync(Task`1<TResult> task);
    [ExtensionAttribute]
[NotNullAttribute]
public static Task ContinueAsync(Task task);
    [AsyncStateMachineAttribute("JetBrains.Util.Threading.JetTaskEx/<SelectAsyncOnTaskHostAsync>d__22`2")]
[ExtensionAttribute]
public static Task`1<ImmutableArray`1<TOutput>> SelectAsyncOnTaskHostAsync(IEnumerable`1<TInput> input, Lifetime lifetime, ITaskHost tasker, ILogger logger, Func`2<TInput, ValueTask`1<TOutput>> FSelector);
    [ExtensionAttribute]
public static Task`1<ImmutableArray`1<TOutput>> SelectOnTaskHostAsync(IEnumerable`1<TInput> input, Lifetime lifetime, ITaskHost tasker, ILogger logger, Func`2<TInput, TOutput> FSelector);
}
public class JetBrains.Util.Threading.Mmf.SharedMemoryMessageBase : object {
    protected EventWaitHandle _evtRead;
    protected EventWaitHandle _evtWritten;
    protected Mutex _mutexInterlock;
    protected RawCircularBufferHeader* _pBufferHeader;
    protected TimeSpan _timeoutForWaits;
    protected SynchronizedLifetime myLifetimeSync;
    public UInt32 MaxMessageSize;
    public string UniqueName;
    private UInt32 BufferSize { get; }
    public SharedMemoryMessageBase(Lifetime lifetimeUnsync, string sUniqueName, UInt32 nMaxMessageSize, bool isWriter);
    protected static string DiagDecodeMessage(Byte[] message);
    private UInt32 get_BufferSize();
}
public class JetBrains.Util.Threading.Mmf.SharedMemoryMessageReader : SharedMemoryMessageBase {
    private Action`1<ByteBuffer> myFRead;
    private static ILogger Logger;
    public SharedMemoryMessageReader(Lifetime lifetimeUnsync, string sUniqueName, UInt32 nMaxMessageSize, Action`1<ByteBuffer> FRead);
    private static SharedMemoryMessageReader();
    private void ReadFromRawBuffer();
    private bool ReadFromRawBuffer_Single();
    [CompilerGeneratedAttribute]
private void <.ctor>b__2_0(object <p0>, bool <p1>);
    [CompilerGeneratedAttribute]
private bool <ReadFromRawBuffer_Single>b__4_0();
}
public class JetBrains.Util.Threading.Mmf.SharedMemoryMessageReader`1 : SharedMemoryMessageReader {
    public SharedMemoryMessageReader`1(Lifetime lifetime, string sUniqueName, UInt32 nMaxMessageSize, Func`2<ByteBuffer, TMessage> FDeserializer, Action`1<TMessage> FRead);
    public SharedMemoryMessageReader`1(Lifetime lifetime, string sUniqueName, UInt32 nMaxMessageSize, Action`1<TMessage> FRead);
    private static TMessage BinaryFormatterDeserializer(ByteBuffer buffer);
}
public class JetBrains.Util.Threading.Mmf.SharedMemoryMessageWriter : SharedMemoryMessageBase {
    private Queue`1<Byte[]> myQueueUnsent;
    private SynchronizedLifetime myWriteLifetimeSync;
    private static ILogger Logger;
    public SharedMemoryMessageWriter(Lifetime lifetimeUnsync, string sUniqueName, UInt32 nMaxMessageSize);
    private static SharedMemoryMessageWriter();
    public void SendMessage(Byte[] data);
    private void EnsureSent();
    private void WriteToRawBuffer(Byte[] data);
    private bool WriteToRawBuffer_Single(Byte[] data);
    [CompilerGeneratedAttribute]
private void <.ctor>b__3_0(object <p0>, bool <p1>);
    [CompilerGeneratedAttribute]
private void <.ctor>b__3_2();
}
public class JetBrains.Util.Threading.Mmf.SharedMemoryMessageWriter`1 : SharedMemoryMessageWriter {
    private Func`2<TMessage, Byte[]> myFSerializer;
    public SharedMemoryMessageWriter`1(Lifetime lifetimeUnsync, string sUniqueName, UInt32 nMaxMessageSize, Func`2<TMessage, Byte[]> FSerializer);
    public SharedMemoryMessageWriter`1(Lifetime lifetimeUnsync, string sUniqueName, UInt32 nMaxMessageSize);
    public void SendMessage(TMessage message);
}
[ObsoleteAttribute("Please don't use this class any longer. Contemporary 'Lifetime' class covers all functions of SynchronizedLifetime.")]
public class JetBrains.Util.Threading.SynchronizedLifetime : object {
    [CanBeNullAttribute]
private JetDispatcher myDispatcher;
    private Lifetime myLifeSync;
    private ReaderWriterLockSlim myLockSync;
    [ObsoleteAttribute("Use Lifetime.IsAlive instead")]
public bool IsTerminated { get; }
    [NotNullAttribute]
[ObsoleteAttribute("Use Lifetime class instead")]
public Lifetime Lifetime { get; }
    public SynchronizedLifetime(Lifetime lifetimeUnsync, TerminationThreadAffinity termaffinity);
    public bool get_IsTerminated();
    public Lifetime get_Lifetime();
    [NotNullAttribute]
public static Lifetime op_Implicit(SynchronizedLifetime sync);
    [ObsoleteAttribute("Use Lifetime.TryExecute or Lifetime.Execute instead")]
public bool ExecuteIfNotTerminated(Action λ);
    [ObsoleteAttribute("Use Lifetime.TryExecute or Lifetime.Execute instead")]
public TResult ExecuteIfNotTerminated(Func`1<TResult> λ);
    [ObsoleteAttribute("This method is quite rare and can be expressed by `if (!lifetime.TryExecute(F)) {SpinWait.SpinUntil(() => lifetime.IsTerminated); F();}` .")]
public void ExecuteSynchronizedWithTermination(Action F);
}
public enum JetBrains.Util.Threading.Tasks.TaskPriority : Enum {
    public int value__;
    public static TaskPriority Low;
    public static TaskPriority BelowNormal;
    public static TaskPriority Normal;
    public static TaskPriority AboveNormal;
    public static TaskPriority High;
    public static TaskPriority Realtime;
}
public class JetBrains.Util.Threading.Tasks.TaskSemaphore : object {
    private UInt32 myFreeCount;
    private LockObject myLockObject;
    private Queue`1<TaskCompletionSource`1<Missing>> myWaits;
    public UInt32 MaximumCount;
    public TaskSemaphore(UInt32 maxcount);
    [AsyncStateMachineAttribute("JetBrains.Util.Threading.Tasks.TaskSemaphore/<ExecuteUnderSemaphoreAsync>d__5`1")]
public Task`1<T> ExecuteUnderSemaphoreAsync(Func`1<Task`1<T>> tasker);
    [AsyncStateMachineAttribute("JetBrains.Util.Threading.Tasks.TaskSemaphore/<ExecuteUnderSemaphoreAsync>d__6")]
public Task ExecuteUnderSemaphoreAsync(Func`1<Task> tasker);
    [AsyncStateMachineAttribute("JetBrains.Util.Threading.Tasks.TaskSemaphore/<SemaphoreBracketAsync>d__7")]
public Task SemaphoreBracketAsync(Lifetime lifetime);
    [NotNullAttribute]
public Task`1<IDisposable> UsingSemaphoreAsync();
    private void ReleaseSemaphore();
    private Task WaitForSemaphoreAsync();
    [CompilerGeneratedAttribute]
private IDisposable <UsingSemaphoreAsync>b__8_0(Task task);
}
[AttributeUsageAttribute("460")]
public class JetBrains.Util.ThreadSafeAttribute : Attribute {
}
[AttributeUsageAttribute("460")]
public class JetBrains.Util.ThreadUnsafeAttribute : Attribute {
}
public class JetBrains.Util.ThrowWhatYouCanLogger : LoggerBase {
    private ILogger myLoggerForWhatCannotBeThrown;
    public string Category { get; }
    public ThrowWhatYouCanLogger(ILogger loggerForWhatCannotBeThrown);
    public virtual string get_Category();
    public virtual bool IsEnabled(LoggingLevel level);
    public virtual void Log(LogEvent logEvent);
    public sealed virtual void LogOrThrowException(Exception ex, ExceptionOrigin origin);
}
public static class JetBrains.Util.TimerUtil : object {
    public static ITimer CreateTimer(int intervalMs);
    public static ITimer CreateTimer();
    public static ITimer CreateTimer(Lifetime lifetime, TimeSpan interval, Action onTick);
}
public class JetBrains.Util.TimeThrottler : ValueType {
    private int myIntervalMillis;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) myLastCutoff;
    public TimeThrottler(int intervalMillis);
    public void Reset();
    public bool Cutoff();
}
public static class JetBrains.Util.TypeOf : object {
    public static Type Object;
    public static Type String;
    public static Type Int16;
    public static Type Int32;
    public static Type Int64;
    public static Type UInt16;
    public static Type UInt32;
    public static Type UInt64;
    public static Type Boolean;
    public static Type Double;
    public static Type Decimal;
    public static Type Byte;
    public static Type Missing;
    public static Type Type;
    public static Type Void;
    private static TypeOf();
}
public class JetBrains.Util.UnixFileSystemInteraction : FileSystemInteraction {
    private static ILogger ourLogger;
    public static UnixFileSystemInteraction Instance;
    [CanBeNullAttribute]
[ThreadStaticAttribute]
private static IFsWriteHandler ourWriteHandler;
    private static Lazy`1<FileSystemPath> ourTempDir;
    [NotNullAttribute]
private static IFsWriteHandler WriteHandler { get; }
    private static UnixFileSystemInteraction();
    private static IFsWriteHandler get_WriteHandler();
    public virtual void OverrideWriteHandler(Lifetime lifetime, Func`2<IFsWriteHandler, IFsWriteHandler> newHandlerFactory);
    public virtual IEnumerable`1<FileSystemPath> GetDirectoryEntries(FileSystemPath thіs, string mask, Nullable`1<bool> files, FileSystemPathInternStrategy internStrategy);
    public virtual void GetDirectoryEntries(FileSystemPath thіs, RelativePath subdir, string mask, PathSearchFlags flags, ICollection`1& output);
    public virtual void DeleteFile(FileSystemPath thіs, Boolean& isDirectory, int nAttempts);
    public virtual void DeleteDirectoryNonRecursive(FileSystemPath thіs, int nAttempts, Exception& ex);
    public virtual FileSystemPath CreateDirectory(FileSystemPath thіs);
    public virtual bool TryCreateNewDirectoryAtomic(FileSystemPath thіs);
    public virtual void Move(FileSystemPath thіs, FileSystemPath dst);
    public virtual void MoveFile(FileSystemPath thіs, FileSystemPath dst, bool overwrite);
    public virtual void CopyFile(FileSystemPath thіs, FileSystemPath dst, bool overwrite);
    public virtual void SetAttributes(FileSystemPath thіs, FileAttributes fileAttributes);
    public virtual void SetFileModificationTimeUtc(FileSystemPath thіs, DateTime t);
    public virtual Existence GetExists(FileSystemPath thіs);
    public virtual FileSystemEntryInfo GetInfo(FileSystemPath thіs);
    public virtual DateTime GetFileModificationTimeUtc(FileSystemPath thіs);
    public virtual DateTime GetFileCreationTimeUtc(FileSystemPath thіs);
    public virtual DateTime GetFileLastAccessedTimeUtc(FileSystemPath thіs);
    public virtual string GetFileAccessPath(FileSystemPath thіs);
    public virtual bool IsLocked(FileSystemPath thіs);
    public virtual bool TryUnlock(FileSystemPath thіs);
    public virtual long GetFileLength(FileSystemPath thіs);
    public virtual FileAttributes GetAttributes(FileSystemPath thіs);
    public virtual FileAttributes TryGetAttributes(FileSystemPath thіs);
    public virtual FileStream OpenStream(FileSystemPath thіs, FileMode fileMode, FileAccess fileAccess, FileShare fileShare, FileFlagsAndAttributes fileFlagsAndAttributes);
    public virtual SafeFileHandle OpenFileHandle(FileSystemPath thіs, FileMode fileMode, FileAccess fileAccess, FileShare fileShare, FileFlagsAndAttributes fileFlagsAndAttributes);
    public virtual ulong GetFileIndex(FileSystemPath thіs);
    public virtual FileSystemPath GetShortPath(FileSystemPath thіs);
    public virtual FileSystemPath GetLongPath(FileSystemPath thіs);
    public virtual FileSystemPath GetTempPath();
    private static FileSystemPath CalculateTempDir();
    public static string CalculatePerUserTempDirLinux();
    [NotNullAttribute]
public static string GetFileAccessPathCore(FileSystemPath it);
    [NotNullAttribute]
public static FileStream OpenStreamCore(FileSystemPath it, FileMode fileMode, FileAccess fileAccess, FileShare fileShare, FileFlagsAndAttributes fileFlagsAndAttributes);
}
public static class JetBrains.Util.UnixFileSystemPathUtils : object {
    private static string ProbeFileName;
    private static UnixFileSystemPathUtils();
    public static bool HasWritePermissionOnDir(FileSystemPath fsp);
}
internal class JetBrains.Util.UnixFsWriteHandler : object {
    public sealed virtual FileStream OpenStream(FileSystemPath it, FileMode fileMode, FileAccess fileAccess, FileShare fileShare, FileFlagsAndAttributes fileFlagsAndAttributes);
    public sealed virtual void DeleteDirectoryNonRecursive(FileSystemPath it, int nAttempts, Exception& ex);
    public sealed virtual FileSystemPath CreateDirectory(FileSystemPath it);
    public sealed virtual bool TryCreateNewDirectoryAtomic(FileSystemPath it);
    public sealed virtual void Move(FileSystemPath it, FileSystemPath dst);
    public sealed virtual void MoveFile(FileSystemPath it, FileSystemPath dst, bool overwrite);
    public sealed virtual void CopyFile(FileSystemPath it, FileSystemPath dst, bool overwrite);
    public sealed virtual void SetAttributes(FileSystemPath it, FileAttributes fileAttributes);
    public sealed virtual void SetFileModificationTimeUtc(FileSystemPath it, DateTime t);
    public sealed virtual void DeleteFile(FileSystemPath it, Boolean& isDirectory, int nAttempts);
    public string GetFileAccessPath(FileSystemPath it);
}
public class JetBrains.Util.UnixJetFileSystemWatcher : JetFileSystemWatcher {
    private FileSystemWatcher myNativeFsWatcher;
    private Lazy`1<PathWildcard> myFilter;
    private FileSystemPath myDirectory;
    private bool myDisposed;
    private IWatcherEvents myWatcherEvents;
    public VirtualFileSystemPath Directory { get; }
    public bool IncludeSubdirectories { get; }
    public PathWildcard Filter { get; }
    public NotifyFilters NotifyFilters { get; }
    public bool Disposed { get; }
    private UnixJetFileSystemWatcher(FileSystemPath path, string filter, NotifyFilters notifyFilter, bool includeSubdirectories, IWatcherEvents watcherEvents);
    [CanBeNullAttribute]
public static JetFileSystemWatcher CreateInstance(FileSystemPath path, string filter, NotifyFilters notifyFilter, bool includeSubdirectories, IWatcherEvents watcherEvents, WinError& rc);
    private void OnRenamed(object sender, RenamedEventArgs args);
    private void OnDeleted(object sender, FileSystemEventArgs args);
    private void OnCreated(object sender, FileSystemEventArgs args);
    private void OnChanged(object sender, FileSystemEventArgs args);
    private void OnError(object sender, ErrorEventArgs args);
    public virtual void Dispose();
    public virtual VirtualFileSystemPath get_Directory();
    public virtual bool get_IncludeSubdirectories();
    public virtual PathWildcard get_Filter();
    public virtual NotifyFilters get_NotifyFilters();
    public virtual bool get_Disposed();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
private PathWildcard <.ctor>b__5_0();
}
public class JetBrains.Util.UnmanagedBlock : object {
    private int myLength;
    private UnmanagedBlockHandle myPointer;
    public int Length { get; }
    public IntPtr Pointer { get; }
    public bool IsDisposed { get; }
    private UnmanagedBlock(IntPtr pointer, int length);
    public int get_Length();
    public IntPtr get_Pointer();
    public IntPtr GetPointerToOffset(int offset);
    [ConditionalAttribute("JET_MODE_ASSERT")]
public void AssertNotDisposed();
    public bool get_IsDisposed();
    public sealed virtual void Dispose();
    public static UnmanagedBlock Alloc(int bytes);
    public static UnmanagedBlock FromArray(Byte[] bytes);
    public static UnmanagedBlock CreateFromFile(FileSystemPath path);
    public static UnmanagedBlock CreateFromStream(Stream stream, Func`1<bool> checkForInterrupt);
    public static UnmanagedBlock CreateFromStream(Stream stream, int length, Func`1<bool> checkForInterrupt);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.Util.UserDataHolder : object {
    [NullableAttribute("2")]
[DebuggerBrowsableAttribute("0")]
private Bucket myHead;
    public UserDataHolder(UserDataHolder chained);
    protected void ClearData();
    public sealed virtual IEnumerable`1<KeyValuePair`2<object, object>> EnumerateData();
    public sealed virtual T GetData(Key`1<T> key);
    public sealed virtual void PutData(Key`1<T> key, T val);
    [MustUseReturnValueAttribute]
public sealed virtual T GetOrCreateDataUnderLock(Key`1<T> key, Func`1<T> factory);
    [MustUseReturnValueAttribute]
public sealed virtual T GetOrCreateDataUnderLock(Key`1<T> key, TState state, Func`2<TState, T> factory);
    [PureAttribute]
public bool IsEmpty();
    public static void CopyUserData(UserDataHolder from, UserDataHolder to);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class JetBrains.Util.UserDataHolderExtensions : object {
    [ExtensionAttribute]
public static void PutKey(IUserDataHolder dataHolder, Key`1<object> key);
    [ExtensionAttribute]
[PureAttribute]
public static bool HasKey(IUserDataHolder dataHolder, Key`1<T> key);
    [ExtensionAttribute]
public static void RemoveKey(IUserDataHolder dataHolder, Key`1<T> key);
    [ExtensionAttribute]
[MustUseReturnValueAttribute]
public static T GetOrCreateDataNoLock(IUserDataHolder dataHolder, Key`1<T> key, Func`1<T> factory);
    [ExtensionAttribute]
[MustUseReturnValueAttribute]
public static T GetOrCreateDataNoLock(IUserDataHolder dataHolder, Key`1<T> key, TState state, Func`2<TState, T> factory);
    [ExtensionAttribute]
[MustUseReturnValueAttribute]
public static T GetOrCreateDataNoLock(IUserDataHolder dataHolder, Key`1<T> key, TState1 state1, TState2 state2, Func`3<TState1, TState2, T> factory);
    [ExtensionAttribute]
[MustUseReturnValueAttribute]
public static T GetOrCreateDataNoLock(IUserDataHolder dataHolder, Key`1<T> key, TState1 state1, TState2 state2, TState3 state3, Func`4<TState1, TState2, TState3, T> factory);
    [ExtensionAttribute]
[MustUseReturnValueAttribute]
public static T GetOrCreateDataNoLock(IUserDataHolder dataHolder, Key`1<T> key, TState1 state1, TState2 state2, TState3 state3, TState4 state4, Func`5<TState1, TState2, TState3, TState4, T> factory);
}
public class JetBrains.Util.UserDataHolderNoLocks : object {
    [CanBeNullAttribute]
private Bucket myHead;
    public UserDataHolderNoLocks(UserDataHolderNoLocks chained);
    [CanBeNullAttribute]
private Bucket CopyBucketsChain(Bucket current);
    public virtual object Clone();
    protected void ClearData();
    public IEnumerable`1<KeyValuePair`2<object, object>> EnumerateData();
    public void PutData(Key`1<T> key, T val);
    public T GetData(Key`1<T> key);
    public T GetOrCreateData(Key`1<T> key, Func`1<T> creator);
    public bool IsEmpty();
    public static void CopyUserData(UserDataHolderNoLocks from, UserDataHolderNoLocks to);
}
public static class JetBrains.Util.UserDataObfuscator : object {
    public static string Obfuscate(string text);
    private static IEnumerable`1<Path> Parse(string text);
}
public enum JetBrains.Util.Utils.CapitalizationStyle : Enum {
    public int value__;
    public static CapitalizationStyle SentenceCase;
    public static CapitalizationStyle TitleCase;
}
public class JetBrains.Util.Utils.CapitalizationUtil : object {
    protected static CapitalizationStyle DefaultSectionCapitalizationInternal;
    private static String[] ourPrepositions;
    private static String[] ourProperNames;
    public static CapitalizationStyle DefaultSectionCapitalization { get; }
    private static CapitalizationUtil();
    public static CapitalizationStyle get_DefaultSectionCapitalization();
    [NotNullAttribute]
public static string ForceCapitalization(string str);
    [NotNullAttribute]
public static string ForceCapitalization(string str, CapitalizationStyle style);
    private static bool IsDelimiter(char x);
    [CompilerGeneratedAttribute]
internal static bool <ForceCapitalization>g__ProcessPredefinedWords|6_0(String[] words, bool capitalizeFirstAndLast, <>c__DisplayClass6_0& , <>c__DisplayClass6_1& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class JetBrains.Util.Utils.ClientIdUtils.ClientIdUtil : object {
    [ExtensionAttribute]
[AssertionMethodAttribute]
[ConditionalAttribute("JET_MODE_ASSERT")]
public static void AssertClientIdConsistency(ClientId clientId, string message);
    [ExtensionAttribute]
public static Lifetime BindToClientId(Lifetime lifetime, ClientId clientId);
    [ExtensionAttribute]
public static void Advise_VerifyingClientId(ISource`1<T> source, Lifetime lifetime, ClientId targetClientId, Action`1<T> handler, string expression);
    [ExtensionAttribute]
public static void View_VerifyingClientId(IReadonlyProperty`1<T> me, Lifetime lifetime, ClientId targetClientId, Action`2<Lifetime, T> handler, string expression);
    [ExtensionAttribute]
public static void Advise_VerifyingClientId(ISignal`1<TValue> signal, Lifetime lifetime, ClientId targetClientId, Action`1<TValue> handler, string expression);
}
public class JetBrains.Util.Utils.ClientIdUtils.DataPerClientId`1 : object {
    private Func`1<T> myInitialValueFactory;
    private ConcurrentDictionary`2<ClientId, T> myPerClientData;
    public T Value { get; }
    public DataPerClientId`1(Lifetime lifetime, Func`1<T> initialValueFactory, IViewableSet`1<ClientId> clients);
    public T get_Value();
    [CompilerGeneratedAttribute]
private void <.ctor>b__2_0(Lifetime clientLifetime, ClientId id);
    [CompilerGeneratedAttribute]
private T <get_Value>b__4_0(ClientId id);
}
[ExtensionAttribute]
public static class JetBrains.Util.Utils.Extensions.QueueExtensions : object {
    [ExtensionAttribute]
public static void EnqueueRange(Queue`1<T> queue, IEnumerable`1<T> itemsToQueue);
}
public class JetBrains.Util.Utils.Misc.LifetimedStopwatch : object {
    private Stopwatch myStopwatch;
    private int myCounter;
    public long ElapsedMilliseconds { get; }
    public TimeSpan Elapsed { get; }
    public long get_ElapsedMilliseconds();
    public TimeSpan get_Elapsed();
    public void StartWhen(Lifetime lifetime);
    [CompilerGeneratedAttribute]
private void <StartWhen>b__6_0();
}
internal static class JetBrains.Util.Utils.NounUtilResources : object {
    public static string Plural;
    private static NounUtilResources();
}
public static class JetBrains.Util.Utils.PlatformUtilWindows : object {
    public static bool IsRunningElevated { get; }
    public static bool get_IsRunningElevated();
    public static WindowsVersionInfo GetWindowsVersionInfo();
    [CanBeNullAttribute]
public static string GetProcPathToExecutable(UInt32 pid);
}
public class JetBrains.Util.ValidationException : ApplicationException {
    public ValidationException(string message);
    protected ValidationException(SerializationInfo info, StreamingContext context);
}
[ExtensionAttribute]
public static class JetBrains.Util.ValueTypeEx : object {
    [ExtensionAttribute]
public static bool ToBool(int value);
    [ExtensionAttribute]
public static bool ToBool(UInt32 value);
    [ExtensionAttribute]
public static bool ToBool(byte value);
    [ExtensionAttribute]
public static int ToInt(bool value);
}
[IsReadOnlyAttribute]
public class JetBrains.Util.VirtualDirectoryEntryData : ValueType {
    [CompilerGeneratedAttribute]
private VirtualFileSystemPath <BaseDir>k__BackingField;
    [CompilerGeneratedAttribute]
private RelativePath <RelativePath>k__BackingField;
    public DateTime FileModificationTimeUtc;
    public DateTime FileCreationTimeUtc;
    public DateTime FileAccessTimeUtc;
    public FileAttributes Attributes;
    public ulong Length;
    public VirtualFileSystemPath BaseDir { get; }
    public RelativePath RelativePath { get; }
    public Existence Existence { get; }
    public bool IsFile { get; }
    public bool IsDirectory { get; }
    public VirtualDirectoryEntryData(VirtualFileSystemPath baseDir, RelativePath relativePath, DateTime fileModificationTimeUtc, DateTime fileCreationTimeUtc, DateTime fileAccessTimeUtc, ulong length, FileAttributes attributes);
    [CompilerGeneratedAttribute]
public sealed virtual VirtualFileSystemPath get_BaseDir();
    [CompilerGeneratedAttribute]
public sealed virtual RelativePath get_RelativePath();
    [NotNullAttribute]
public sealed virtual VirtualFileSystemPath GetAbsolutePath(FileSystemPathInternStrategy internStrategy);
    public Existence get_Existence();
    public sealed virtual bool get_IsFile();
    public sealed virtual bool get_IsDirectory();
    public virtual string ToString();
    public VirtualDirectoryEntryData WithBaseDir(VirtualFileSystemPath basedir);
}
public class JetBrains.Util.VirtualFileSystemDefinition : object {
    public static VirtualFileSystemPath GetTempPath(IInteractionContext context);
    public static VirtualFileSystemPath CreateTemporaryFile(IInteractionContext context, VirtualFileSystemPath parent, string extensionWithDot, string prefix);
    [NotNullAttribute]
public static VirtualFileSystemPath CreateTemporaryFile(Lifetime lifetime, IInteractionContext context, VirtualFileSystemPath parent, string extensionWithDot, string prefix, Action`1<Stream> handler);
    private static bool TryCreateNewFileAtomic(VirtualFileSystemPath path, Action`1<Stream> handler);
    private static bool CreateNewDirectoryAtomic(VirtualFileSystemPath path);
    public static VirtualFileSystemPath CreateTemporaryDirectory(Lifetime lifetime, IInteractionContext context, VirtualFileSystemPath parent, string prefix);
    [NotNullAttribute]
public static VirtualFileSystemPath CreateTemporaryDirectory(IInteractionContext context, VirtualFileSystemPath parent, string prefix);
    private static VirtualFileSystemPath CreateTempEntity(Func`1<string> randomNameGenerator, Func`2<VirtualFileSystemPath, bool> creator, Lifetime lifetime, VirtualFileSystemPath parent, string prefix, string extension);
}
public class JetBrains.Util.VirtualFileSystemEntryInfo : object {
    [CompilerGeneratedAttribute]
private VirtualFileSystemPath <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private FileAttributes <Attributes>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <ModificationTimeUtc>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <AccessTimeUtc>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <CreationTimeUtc>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Length>k__BackingField;
    public VirtualFileSystemPath Path { get; }
    public FileAttributes Attributes { get; }
    public DateTime ModificationTimeUtc { get; }
    public DateTime AccessTimeUtc { get; }
    public DateTime CreationTimeUtc { get; }
    public long Length { get; }
    public bool IsFile { get; }
    public bool IsDirectory { get; }
    public VirtualFileSystemEntryInfo(VirtualFileSystemPath path, FileAttributes attributes, DateTime modificationTimeUtc, DateTime accessTimeUtc, DateTime creationTimeUtc, long length);
    [CompilerGeneratedAttribute]
public sealed virtual VirtualFileSystemPath get_Path();
    [CompilerGeneratedAttribute]
public sealed virtual FileAttributes get_Attributes();
    [CompilerGeneratedAttribute]
public sealed virtual DateTime get_ModificationTimeUtc();
    [CompilerGeneratedAttribute]
public sealed virtual DateTime get_AccessTimeUtc();
    [CompilerGeneratedAttribute]
public sealed virtual DateTime get_CreationTimeUtc();
    [CompilerGeneratedAttribute]
public sealed virtual long get_Length();
    public sealed virtual bool get_IsFile();
    public sealed virtual bool get_IsDirectory();
}
[TypeConverterAttribute("JetBrains.Util.VirtualFileSystemPathConverter")]
[ValueSerializerAttribute("JetBrains.Util.VirtualFileSystemPathSerializer")]
public class JetBrains.Util.VirtualFileSystemPath : FileSystemPathBase`3<VirtualFileSystemPath, VirtualFileSystemEntryInfo, VirtualDirectoryEntryData> {
    private int myHashCode;
    private IInteractionContext myContext;
    private static Key`1<VirtualFileSystemPath> ourEmptyKey;
    private static Func`4<string, IInteractionContext, bool, VirtualFileSystemPath> myFactoryForInterningDelegate;
    private FileSystemPath modreq(System.Runtime.CompilerServices.IsVolatile) myCachedNativeFileSystemPath;
    public IInteractionContext InteractionContext { get; }
    internal IInteractionContext Context { get; }
    internal FileSystemPath NativePath { get; }
    private VirtualFileSystemPath(IInteractionContext context, string path, bool isCanonical);
    private static VirtualFileSystemPath();
    public IInteractionContext get_InteractionContext();
    internal virtual IInteractionContext get_Context();
    public static VirtualFileSystemPath GetEmptyPathFor(IInteractionContext context);
    public virtual VirtualFileSystemPath GetEmpty();
    protected virtual IFileSystemInteraction`3<VirtualFileSystemPath, VirtualFileSystemEntryInfo, VirtualDirectoryEntryData> GetInteraction();
    protected virtual VirtualFileSystemPath CreatePath(string path, bool isPathAlreadyCanonical, FileSystemPathInternStrategy internStrategy);
    internal virtual VirtualFileSystemPath ParsePath(string path, FileSystemPathInternStrategy internStrategy);
    internal virtual VirtualFileSystemPath CreateFromCanonicalPath(string path, FileSystemPathInternStrategy internStrategy);
    [NotNullAttribute]
public static VirtualFileSystemPath CreateByCanonicalPath(string path, IInteractionContext context, FileSystemPathInternStrategy internStrategy);
    [NotNullAttribute]
[PureAttribute]
public static VirtualFileSystemPath TryParse(string path, IInteractionContext context, FileSystemPathInternStrategy internStrategy);
    [NotNullAttribute]
[PureAttribute]
public static VirtualFileSystemPath Parse(string path, IInteractionContext context, FileSystemPathInternStrategy internStrategy);
    [NotNullAttribute]
[PureAttribute]
public static VirtualFileSystemPath ParseRelativelyTo(string path, VirtualFileSystemPath basePathForRelativeStrings);
    private static VirtualFileSystemPath Create(string path, bool isPathAlreadyCanonical, IInteractionContext context, FileSystemPathInternStrategy internStrategy);
    public bool Equals(FileSystemPath obj);
    protected virtual bool EqualsInner(object obj);
    public bool Equals(VirtualFileSystemPath right);
    protected virtual int GetHashCodeInner();
    internal FileSystemPath get_NativePath();
    public static VirtualFileSystemPath Read(UnsafeReader reader);
    public void Write(UnsafeWriter writer);
}
public class JetBrains.Util.VirtualFileSystemPathConverter : TypeConverterBase`1<VirtualFileSystemPath> {
}
[ExtensionAttribute]
public static class JetBrains.Util.VirtualFileSystemPathExtensions : object {
    public static ILogger Logger;
    private static VirtualFileSystemPathExtensions();
    [ExtensionAttribute]
public static VirtualFileSystemPath ParseVirtualPath(string path, IInteractionContext context, FileSystemPathInternStrategy internStrategy);
    [ExtensionAttribute]
public static VirtualFileSystemPath ParseVirtualPathSafe(string path, IInteractionContext context, FileSystemPathInternStrategy internStrategy);
    [ExtensionAttribute]
public static IPath ParseVirtualOrRelativePathSafe(string path, IInteractionContext context, FileSystemPathInternStrategy internStrategy);
    [ExtensionAttribute]
public static VirtualFileSystemPath ParseVirtualRelativelyTo(string path, VirtualFileSystemPath relativePath);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static VirtualFileSystemPath RemovePrefix(VirtualFileSystemPath path, VirtualFileSystemPath prefix);
    [ExtensionAttribute]
[NotNullAttribute]
public static string FileAccessPathWithTrailingPathSeparator(VirtualFileSystemPath path);
    [NotNullAttribute]
private static string AppendTrailingPathSeparatorIfNeed(string path, string pathSeparator);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static string PathWithCurrentSolutionSeparators(VirtualFileSystemPath path);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
[ObsoleteAttribute("Removing the first component makes a path relative, so use RemoveFirstComponent2.")]
public static VirtualFileSystemPath RemoveFirstComponent(VirtualFileSystemPath thіs);
    [ExtensionAttribute]
public static VirtualFileSystemPath AddSuffix(VirtualFileSystemPath path, string suffix, FileSystemPathInternStrategy internStrategy);
    [ExtensionAttribute]
public static FileSystemPath ToNativeFileSystemPath(VirtualFileSystemPath path);
}
public class JetBrains.Util.VirtualFileSystemPathInternByConcurrentDictionary : FileSystemPathInternByConcurrentDictionaryBase`3<VirtualFileSystemPath, VirtualFileSystemEntryInfo, VirtualDirectoryEntryData> {
    public VirtualFileSystemPathInternByConcurrentDictionary(FileSystemPathInternParameters absoluteParameters, FileSystemPathInternParameters relativeParameters);
    protected VirtualFileSystemPathInternByConcurrentDictionary(FileSystemPathInternParameters absoluteParameters, FileSystemPathInternParameters relativeParameters, PathContainerCreator<VirtualFileSystemPath, VirtualFileSystemEntryInfo, VirtualDirectoryEntryData> creator);
}
public class JetBrains.Util.VirtualFileSystemPathSerializer : ValueSerializerBase`1<VirtualFileSystemPath> {
}
[DebuggerDisplayAttribute("Target: {(Target) == null ? "<DEAD>" : Target.ToString()}")]
public class JetBrains.Util.WeakHolder`1 : ValueType {
    private GCHandle myHandle;
    public T Target { get; }
    public bool Allocated { get; }
    public WeakHolder`1(T target);
    public WeakHolder`1(T target, bool trackResurrection);
    public T get_Target();
    public bool get_Allocated();
    public sealed virtual bool Equals(T other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual void Dispose();
}
public class JetBrains.Util.Wildcard : object {
    private string myPattern;
    private bool myCaseSensitive;
    private bool myHasWildcardChars;
    public string Pattern { get; }
    public bool HasWildcardChars { get; }
    public Wildcard(string pattern, bool caseSensitive);
    public string get_Pattern();
    public bool get_HasWildcardChars();
    public bool IsMatch(StringSlice str);
    private bool MatchChars(char pat, char c);
    public virtual string ToString();
}
public class JetBrains.Util.Win32FileSystemInteraction : FileSystemInteraction {
    private static ILogger ourLogger;
    public static Win32FileSystemInteraction Instance;
    [CanBeNullAttribute]
[ThreadStaticAttribute]
private static IFsWriteHandler ourWriteHandler;
    private static int OldMaxPath;
    [NotNullAttribute]
private static IFsWriteHandler WriteHandler { get; }
    private static Win32FileSystemInteraction();
    public virtual SafeFileHandle OpenFileHandle(FileSystemPath thіs, FileMode fileMode, FileAccess fileAccess, FileShare fileShare, FileFlagsAndAttributes fileFlagsAndAttributes);
    internal static SafeFileHandle OpenFileHandleInternal(FileSystemPath thіs, FileMode fileMode, FileAccess fileAccess, FileShare fileShare, FileFlagsAndAttributes fileFlagsAndAttributes);
    public virtual FileStream OpenStream(FileSystemPath thіs, FileMode fileMode, FileAccess fileAccess, FileShare fileShare, FileFlagsAndAttributes fileFlagsAndAttributes);
    public virtual IEnumerable`1<FileSystemPath> GetDirectoryEntries(FileSystemPath thіs, string mask, Nullable`1<bool> files, FileSystemPathInternStrategy internStrategy);
    internal static void GetDirectoryEntriesInternal(FileSystemPath thіs, RelativePath subdir, string mask, PathSearchFlags flags, ICollection`1& output);
    public virtual void GetDirectoryEntries(FileSystemPath thіs, RelativePath subdir, string mask, PathSearchFlags flags, ICollection`1& output);
    public virtual void Move(FileSystemPath thіs, FileSystemPath destinationFilePath);
    public virtual void MoveFile(FileSystemPath thіs, FileSystemPath destinationFilePath, bool overwrite);
    public virtual void CopyFile(FileSystemPath thіs, FileSystemPath destinationFilePath, bool overwrite);
    public virtual ulong GetFileIndex(FileSystemPath thіs);
    public virtual FileSystemPath CreateDirectory(FileSystemPath thіs);
    public virtual void DeleteFile(FileSystemPath thіs, Boolean& isDirectory, int nAttempts);
    public virtual void DeleteDirectoryNonRecursive(FileSystemPath thіs, int nAttempts, Exception& ex);
    public virtual void SetAttributes(FileSystemPath thіs, FileAttributes fileAttributes);
    public virtual FileAttributes GetAttributes(FileSystemPath thіs);
    public virtual long GetFileLength(FileSystemPath thіs);
    public virtual FileSystemPath GetLongPath(FileSystemPath thіs);
    public virtual FileSystemPath GetShortPath(FileSystemPath thіs);
    public static string CombinePathAndMask(string path, string mask);
    private static CreationDisposition BuildCreationDisposition(FileMode fileMode);
    private static AccessRights BuildAccessRights(FileAccess fileAccess);
    public static void ThrowByError(WinError errorCode, FileSystemPath path, string additionalData, int retryCount);
    [NotNullAttribute]
public static Exception CreateException(WinError errorCode, FileSystemPath path, string additionalData, int retryCount);
    public virtual FileAttributes TryGetAttributes(FileSystemPath thіs);
    public virtual bool TryCreateNewDirectoryAtomic(FileSystemPath thіs);
    public static FileSystemPath GetFinalPathNameByHandle(SafeFileHandle fileHandle, GetFinalPathNameByHandleFlags flags);
    private static IFsWriteHandler get_WriteHandler();
    public virtual void OverrideWriteHandler(Lifetime lifetime, Func`2<IFsWriteHandler, IFsWriteHandler> newHandlerFactory);
    public virtual Existence GetExists(FileSystemPath thіs);
    [CanBeNullAttribute]
public virtual FileSystemEntryInfo GetInfo(FileSystemPath thіs);
    public virtual DateTime GetFileModificationTimeUtc(FileSystemPath thіs);
    public virtual void SetFileModificationTimeUtc(FileSystemPath thіs, DateTime t);
    public virtual DateTime GetFileCreationTimeUtc(FileSystemPath thіs);
    public virtual DateTime GetFileLastAccessedTimeUtc(FileSystemPath thіs);
    public virtual string GetFileAccessPath(FileSystemPath thіs);
    internal static string GetFileAccessPathInternal(FileSystemPath thіs);
    private static string GetFileAccessPathInternal(string path);
    public virtual bool IsLocked(FileSystemPath thіs);
    public virtual bool TryUnlock(FileSystemPath thіs);
    public virtual FileSystemPath GetTempPath();
    [CompilerGeneratedAttribute]
internal static Exception <CreateException>g__WithData|22_0(Exception ex, <>c__DisplayClass22_0& );
    [CompilerGeneratedAttribute]
internal static Exception <CreateException>g__WithFreeSpace|22_1(Exception ex, <>c__DisplayClass22_0& );
}
public static class JetBrains.Util.Win32FileSystemPathUtils : object {
    public static bool HasWritePermissionOnDir(FileSystemPath fsp);
    public static FileSystemPath GetGuidVolumeRootPath(char drive);
    public static Pair`2<FileSystemPath, string> ParseCommandLineString(string source);
    public static bool UnblockZoneIdentifier(FileSystemPath thіs);
    public static bool UnblockZoneIdentifier(VirtualFileSystemPath thіs);
}
internal class JetBrains.Util.Win32FileSystemWriteHandler : object {
    private static string GetFileAccessPath(FileSystemPath it);
    public sealed virtual FileStream OpenStream(FileSystemPath it, FileMode fileMode, FileAccess fileAccess, FileShare fileShare, FileFlagsAndAttributes fileFlagsAndAttributes);
    private static void ThrowByError(WinError error, FileSystemPath it, string message, int retryCount);
    public sealed virtual void DeleteDirectoryNonRecursive(FileSystemPath it, int nAttempts, Exception& ex);
    public sealed virtual FileSystemPath CreateDirectory(FileSystemPath it);
    public sealed virtual bool TryCreateNewDirectoryAtomic(FileSystemPath it);
    public sealed virtual void Move(FileSystemPath it, FileSystemPath destinationFilePath);
    public sealed virtual void MoveFile(FileSystemPath it, FileSystemPath destinationFilePath, bool overwrite);
    public sealed virtual void CopyFile(FileSystemPath it, FileSystemPath destinationFilePath, bool overwrite);
    public sealed virtual void SetAttributes(FileSystemPath it, FileAttributes fileAttributes);
    public sealed virtual void SetFileModificationTimeUtc(FileSystemPath thіs, DateTime t);
    public sealed virtual void DeleteFile(FileSystemPath it, Boolean& isDirectory, int nAttempts);
}
public class JetBrains.Util.Win32JetFileSystemWatcher : JetFileSystemWatcher {
    private static ILogger ourLogger;
    private static NotifyFilters ourNotifyFiltersValidMask;
    private FileSystemPath myDirectory;
    private SafeFileHandle myDirectoryHandle;
    private UnmanagedBlock myEventsBuffer;
    private PathWildcard myFilter;
    private bool myIncludeSubdirectories;
    private NotifyFilters myNotifyFilters;
    private IWatcherEvents myWatcherEvents;
    private bool myDisposed;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) myEventsBufferDisposed;
    private static HashSet`1<UInt32> ourDirectoryNoLongerAvailableErrorCodes;
    private static HashSet`1<UInt32> ourDirectoryAbortedErrorCodes;
    private IOCompletionCallback myCompletionStatusChanged;
    public VirtualFileSystemPath Directory { get; }
    public bool IncludeSubdirectories { get; }
    public PathWildcard Filter { get; }
    public NotifyFilters NotifyFilters { get; }
    public bool Disposed { get; }
    private static Win32JetFileSystemWatcher();
    private Win32JetFileSystemWatcher(SafeFileHandle directoryHandle, FileSystemPath directory, string filter, bool includeSubdirectories, NotifyFilters notifyFilter, IWatcherEvents watcherEvents, int bufferSize);
    public static JetFileSystemWatcher CreateInstance(FileSystemPath path, string filter, NotifyFilters notifyFilter, bool includeSubdirectories, IWatcherEvents watcherEvents, WinError& rc, int bufferSize);
    private void DisposeInternal(bool disposeEventsBuffer);
    private void DisposeEventsBuffer();
    private WinError Monitor();
    [HandleProcessCorruptedStateExceptionsAttribute]
private void CompletionStatusChanged(UInt32 errorCode, UInt32 numBytes, NativeOverlapped* overlappedPointer);
    private bool MatchPattern(string name);
    public virtual void Dispose();
    public virtual VirtualFileSystemPath get_Directory();
    public virtual bool get_IncludeSubdirectories();
    public virtual PathWildcard get_Filter();
    public virtual NotifyFilters get_NotifyFilters();
    public virtual bool get_Disposed();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
private void <DisposeInternal>b__17_0();
}
public static class JetBrains.Util.XmlHtmlNamedCharacterReferences : object {
    public static Char[] EscapeXmlStandard;
    public static Char[] EscapeXmlStandardAndControlChars;
    private static int ProbeFactor;
    private static XmlHtmlNamedCharacterReferences();
    public static string TryGetNamedReferenceBySingleChar(char ch);
    public static void TryGetValueForCharacterReference(StringSource name, Char& ch1, Char& ch2);
    private static void RenderHashTable_DoTable(Header header, List`1<KeyValuePair`2<string, string>> items, IDictionary`2<string, ushort> mapStringToRva, StringBuilder sb, bool isHashingByName);
    private static void WriteDwordArray(Byte[] table, string name, StringBuilder sb);
}
public static class JetBrains.Util.XmlHtmlNamedCharacterReferencesOriginalDictionary : object {
    internal static UInt32[] Strings;
    internal static UInt32[] HashByName;
    internal static UInt32[] HashByValue;
    private static XmlHtmlNamedCharacterReferencesOriginalDictionary();
    public static IDictionary`2<string, string> CreateXmlHtmlNamedCharacterReferencesDictionary();
}
[ExtensionAttribute]
public static class JetBrains.Util.XmlUtil : object {
    public static BidirectionalMapOnDictionary`2<string, char> XmlPredefinedEntities;
    public static Char[] EscapeXmlStandard;
    public static Char[] EscapeXmlStandardAndControlChars;
    private static ProcessStringDelegate`2<CtxUnescape, StringBuilder> UnescapeXmlStringDelegate;
    private static XmlUtil();
    [ExtensionAttribute]
[NotNullAttribute]
public static IEnumerable`1<XmlElement> ChildElements(XmlElement parent);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static XmlAttribute CreateAttributeWithNonEmptyValue(XmlElement element, string attrName, string value);
    [ExtensionAttribute]
[NotNullAttribute]
public static XmlElement CreateAttributeWithNonEmptyValueFluent(XmlElement element, string attrName, string value);
    [ExtensionAttribute]
[ObsoleteAttribute("Use XmlElement::SetAttribute(string, string).")]
[NotNullAttribute]
public static XmlAttribute CreateAttributeWithValue(XmlElement element, string attrName, string value);
    [ExtensionAttribute]
[NotNullAttribute]
public static XmlElement CreateAttributeWithValueFluent(XmlElement element, string attrName, string value);
    [ExtensionAttribute]
[NotNullAttribute]
public static XmlElement CreateElement(XmlNode parent, string tagName);
    [ExtensionAttribute]
[NotNullAttribute]
public static XmlElement CreateLeafElementWithValue(XmlElement parent, string tagName, string value);
    [ExtensionAttribute]
public static Nullable`1<T> GetAttribute(XmlElement element, string attributeName);
    [ExtensionAttribute]
public static string GetAttribute(XmlElement element, string attributeName);
    [ExtensionAttribute]
public static T GetAttribute(XmlElement element, string attributeName, T defaultValue);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static string GetAttribute(XmlElement element, string attributeName, string defaultValue);
    [ExtensionAttribute]
public static bool GetAttribute(XmlElement element, string attributeName, bool defaultValue);
    [ExtensionAttribute]
public static Guid GetAttribute(XmlElement element, string attributeName, Guid defaultValue);
    [ExtensionAttribute]
public static int GetAttribute(XmlElement element, string attributeName, int defaultValue);
    [ExtensionAttribute]
public static int GetAttribute(XmlElement element, string attributeName, NumberStyles style, NumberFormatInfo numberFormatInfo, int defaultValue);
    [ExtensionAttribute]
public static long GetAttribute(XmlElement element, string attributeName, long defaultValue);
    [ExtensionAttribute]
public static double GetAttribute(XmlElement element, string attributeName, double defaultValue);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static string ReadAttribute(XmlElement element, string attributeName);
    [CanBeNullAttribute]
public static string ReadLeafElementValue(XmlElement parent, string tagName);
    public static string ReadLeafElementValue(XmlElement element);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static XmlElement SelectElement(XmlElement parent, string tagName);
    [IteratorStateMachineAttribute("JetBrains.Util.XmlUtil/<SelectElements>d__24")]
[ExtensionAttribute]
[NotNullAttribute]
public static IEnumerable`1<XmlElement> SelectElements(XmlNode parent, string xpath, XmlNamespaceManager namespaceManager);
    [IteratorStateMachineAttribute("JetBrains.Util.XmlUtil/<SelectElements>d__25")]
[ExtensionAttribute]
[NotNullAttribute]
public static IEnumerable`1<XmlElement> SelectElements(XmlNode parent, string xpath);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static XmlElement SelectSingleElement(XmlNode parent, string xpath);
    [NotNullAttribute]
public static string EscapeXmlString(string text, Char[] charsToEscape);
    [NotNullAttribute]
public static string EscapeXmlString(string text, EscapeChars escapeChars);
    [NotNullAttribute]
public static string EscapeXmlString(string text, RangeTranslator& translator, Char[] charsToEscape);
    [NotNullAttribute]
private static string EscapeXmlString(string text, bool useRangeTranslator, RangeTranslator& translator, EscapeChars escapeChars);
    public static bool ShouldEscape(string text, Char[] charsToEscape);
    public static bool ShouldEscape(string text, EscapeChars escapeChars);
    [NotNullAttribute]
public static string UnescapeXmlString(string xmlText);
    public static StringSlice UnescapeXmlString(StringSlice xmlText);
    [NotNullAttribute]
public static string UnescapeXmlString(string xmlText, RangeTranslator& translator);
    public static void UnescapeXmlString(StringBuilder result, string xmlText, RangeTranslator translator);
    [CanBeNullAttribute]
private static StringBuilder UnescapeXmlString(StringSlice xmlTextOrig, RangeTranslator translator);
    private static StringBuilder UnescapeXmlString(Char* pch0, int length, CtxUnescape ctx);
    [ExtensionAttribute]
[NotNullAttribute]
public static TNode InsertBeforeThat(TNode this, XmlNode xmlReference);
    [ExtensionAttribute]
[NotNullAttribute]
public static TNode InsertAfterThat(TNode this, XmlNode xmlReference);
    private static bool CanSaveAsInnerText(string value);
    [ExtensionAttribute]
[NotNullAttribute]
public static XmlDocument OwnerDocumentNonNull(XmlNode thіs);
    [ExtensionAttribute]
[NotNullAttribute]
public static XmlNode ParentNodeNonNull(XmlNode thіs);
    [NotNullAttribute]
public static string OuterXmlIndented(XmlElement xmlElement);
    [ExtensionAttribute]
public static IEnumerable`1<XmlElement> GetChildElements(XmlNode node);
    [ExtensionAttribute]
public static IEnumerable`1<XmlElement> GetChildElements(XmlNode node, string name);
}
[ExtensionAttribute]
public static class JetBrains.Util.XmlWriterEx : object {
    public static XmlWriterSettings WriterSettings { get; }
    public static XmlWriterSettings get_WriterSettings();
    [ExtensionAttribute]
public static TWriter StartElem(TWriter writer, string name);
    [ExtensionAttribute]
public static TWriter EndElem(TWriter writer);
    [ExtensionAttribute]
public static TWriter Str(TWriter writer, string str);
    [ExtensionAttribute]
public static TWriter Attr(TWriter writer, string name, object value);
    [ExtensionAttribute]
public static TWriter AttrNs(TWriter writer, string name, string xmlns, object value);
    public static XmlWriter CreateWriter(Stream stream);
    [ExtensionAttribute]
public static void Element(XmlWriter writer, string name, string value);
    [ExtensionAttribute]
public static XmlWriter InElement(XmlWriter writer, string name, Action nested, bool writeFullEndElement);
    [ExtensionAttribute]
public static XmlWriter InElementNs(XmlWriter writer, string name, string xmlns, Action nested, bool writeFullEndElement);
    [ExtensionAttribute]
public static IDisposable PushElement(XmlWriter writer, string name, bool writeFullEndElement);
    [ExtensionAttribute]
public static IDisposable PushElementNs(XmlWriter writer, string name, string xmlns, bool writeFullEndElement);
    [ExtensionAttribute]
public static void WriteXml(Stream stream, Action`1<XmlWriter> FWrite);
    [ExtensionAttribute]
public static void WriteXml(Stream stream, XmlWriterSettings settings, Action`1<XmlWriter> FWrite);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
public interface System.Collections.Generic.IJetSet`1 {
    public IEqualityComparer`1<T> Comparer { get; }
    public int Count { get; }
    public abstract virtual IEqualityComparer`1<T> get_Comparer();
    public abstract virtual int get_Count();
}
public interface System.Collections.Generic.IReadOnlySet`1 {
    public abstract virtual bool Contains(T item);
}
[DebuggerTypeProxyAttribute("System.Collections.Generic.JetHashSetDebugView`1")]
[DebuggerDisplayAttribute("Count = {Count}")]
public class System.Collections.Generic.JetHashSet`1 : object {
    private static int HASH_MASK;
    [ObsoleteAttribute("Will be removed soon. Use 'HashSet' type instead")]
public static JetHashSet`1<T> Empty;
    [NotNullAttribute]
private IEqualityComparer`1<T> myComparer;
    private Entry[] myEntries;
    private Int32[] myHashToEntryIndex;
    private int myEntriesUsed;
    private int myFirstFreeIndex;
    private int myFreeCount;
    private int myVersion;
    [NotNullAttribute]
public IEqualityComparer`1<T> Comparer { get; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    public JetHashSet`1(IEqualityComparer`1<T> comparer);
    public JetHashSet`1(IEnumerable`1<T> enumerable, IEqualityComparer`1<T> comparer);
    [EditorBrowsableAttribute("1")]
public JetHashSet`1(ICollection`1<T> collection, IEqualityComparer`1<T> comparer);
    public JetHashSet`1(FrugalLocalList`1<T> collection, IEqualityComparer`1<T> comparer);
    public JetHashSet`1(int capacity, IEqualityComparer`1<T> comparer);
    private static JetHashSet`1();
    public sealed virtual IEqualityComparer`1<T> get_Comparer();
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    public virtual bool Add(T element);
    private bool AddImpl(T element, T& existingElement);
    public virtual bool Remove(T element);
    public virtual void Clear();
    public sealed virtual bool Contains(T element);
    public T GetValue(T key);
    public T Intern(T key);
    public bool TryGetValue(T key, T& value);
    public void CopyTo(T[] array);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public void CopyTo(T[] array, int arrayIndex, int count);
    public sealed virtual void UnionWith(IEnumerable`1<T> other);
    public void UnionWith(T[] other);
    private void IntersectWith(ICollection`1<T> other);
    private bool IsSubsetOf(ICollection`1<T> other);
    public void IntersectWith(KeyCollection<T, TValue> other);
    public sealed virtual void IntersectWith(IEnumerable`1<T> other);
    public sealed virtual bool SetEquals(IEnumerable`1<T> other);
    [EditorBrowsableAttribute("1")]
public bool SetEquals(IJetSet`1<T> other);
    private bool SetEqualsImpl(IEnumerable`1<T> other);
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [NotNullAttribute]
[PureAttribute]
public static JetHashSet`1<T> NewInstance();
    [NotNullAttribute]
[PureAttribute]
public static JetHashSet`1<T> NewInstance(int n);
    public ElementEnumerator<T> GetEnumerator();
    public int RemoveWhere(Func`2<T, bool> predicate);
    [ObsoleteAttribute("throws new NotImplementedException")]
public sealed virtual void SymmetricExceptWith(IEnumerable`1<T> other);
    public sealed virtual bool IsSubsetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsSupersetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsProperSupersetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsProperSubsetOf(IEnumerable`1<T> other);
    [EditorBrowsableAttribute("1")]
public bool IsSupersetOf(ICollection`1<T> other);
    [EditorBrowsableAttribute("1")]
public bool IsSupersetOf(IJetSet`1<T> other);
    private bool IsSupersetOfImpl(IEnumerable`1<T> other);
    private bool IsGreaterSet(IJetSet`1<T> set);
    public sealed virtual bool Overlaps(IEnumerable`1<T> other);
    private static bool CollectionContainsAll(ICollection`1<T> collection, IEnumerable`1<T> other);
    public sealed virtual void ExceptWith(IEnumerable`1<T> other);
    private void RemoveEntry(int entryIndex, int prevIndex);
    private int GetEntryIndex(T key);
    private void Initialize(int capacity);
    private void Resize();
    public T FirstOrDefault();
    public T First();
    [NotNullAttribute]
public T[] ToArray();
    public void InternAllValues(Func`2<T, T> internFunc);
}
internal class System.Collections.Generic.JetHashSetDebugView`1 : object {
    private JetHashSet`1<T> myHashSet;
    [DebuggerBrowsableAttribute("3")]
public T[] Items { get; }
    public JetHashSetDebugView`1(JetHashSet`1<T> set);
    public T[] get_Items();
}
[ExtensionAttribute]
public static class System.Collections.Generic.JetHashSetExtensions : object {
    [ExtensionAttribute]
public static void Add(IJetSet`1<T> set, Lifetime lifetime, T value);
    [ExtensionAttribute]
public static void Compare(IJetSet`1<T> oldSet, IJetSet`1<T> newSet, JetHashSet`1& addedItems, JetHashSet`1& removedItems);
}
public class System.Collections.Generic.JetHashSetSorted`1 : object {
    private JetHashSet`1<TItem> myHashSet;
    private IComparer`1<TItem> myComparer;
    private TItem myLastItem;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public JetHashSetSorted`1(ICollection`1<TItem> collection, IEqualityComparer`1<TItem> equator, IComparer`1<TItem> comparer);
    public JetHashSetSorted`1(IEnumerable`1<TItem> enumerable, IEqualityComparer`1<TItem> equator, IComparer`1<TItem> comparer);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IEnumerator`1<TItem> GetEnumerator();
    private sealed virtual override void System.Collections.Generic.ICollection<TItem>.Add(TItem item);
    public bool Add(TItem item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(TItem item);
    public sealed virtual void CopyTo(TItem[] array, int arrayIndex);
    public sealed virtual bool Remove(TItem item);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
}
[AttributeUsageAttribute("2432")]
public class System.Diagnostics.CodeAnalysis.AllowNullAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
public class System.Diagnostics.CodeAnalysis.DisallowNullAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
public class System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
public class System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ParameterValue>k__BackingField;
    public bool ParameterValue { get; }
    public DoesNotReturnIfAttribute(bool parameterValue);
    [CompilerGeneratedAttribute]
public bool get_ParameterValue();
}
[AttributeUsageAttribute("10624")]
public class System.Diagnostics.CodeAnalysis.MaybeNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
public class System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public MaybeNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("192")]
public class System.Diagnostics.CodeAnalysis.MemberNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public String[] Members { get; }
    public MemberNotNullAttribute(string member);
    public MemberNotNullAttribute(String[] members);
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("192")]
public class System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public bool ReturnValue { get; }
    public String[] Members { get; }
    public MemberNotNullWhenAttribute(bool returnValue, string member);
    public MemberNotNullWhenAttribute(bool returnValue, String[] members);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("10368")]
public class System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; }
    public NotNullIfNotNullAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[AttributeUsageAttribute("2048")]
public class System.Diagnostics.CodeAnalysis.NotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public NotNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[AttributeUsageAttribute("32")]
public class System.Diagnostics.CodeAnalysis.SetsRequiredMembersAttribute : Attribute {
}
[AttributeUsageAttribute("2240")]
public class System.Diagnostics.CodeAnalysis.UnscopedRefAttribute : Attribute {
}
[IsReadOnlyAttribute]
public class System.Index : ValueType {
    private int myValue;
    public static Index Start { get; }
    public static Index End { get; }
    public int Value { get; }
    public bool IsFromEnd { get; }
    public Index(int value, bool fromEnd);
    private Index(int value);
    public static Index get_Start();
    public static Index get_End();
    [PureAttribute]
public static Index FromStart(int value);
    public static Index FromEnd(int value);
    public int get_Value();
    public bool get_IsFromEnd();
    [PureAttribute]
public int GetOffset(int length);
    public virtual bool Equals(object value);
    public sealed virtual bool Equals(Index other);
    public virtual int GetHashCode();
    public static Index op_Implicit(int value);
    public virtual string ToString();
}
[ExtensionAttribute]
public static class System.Linq.EnumerableExJet : object {
    private static ILogger Logger;
    private static EnumerableExJet();
    [ExtensionAttribute]
[NotNullAttribute]
public static IEnumerable`1<TSource> Distinct(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector);
    [ExtensionAttribute]
[NotNullAttribute]
public static IEnumerable`1<TSource> Distinct(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static TSource First(IEnumerable`1<TSource> source, string sExceptionMessageEmpty);
    [IteratorStateMachineAttribute("System.Linq.EnumerableExJet/<JetZip>d__4`3")]
[ExtensionAttribute]
public static IEnumerable`1<TResult> JetZip(IEnumerable`1<TFirst> first, IEnumerable`1<TSecond> second, Func`3<TFirst, TSecond, TResult> resultSelector);
    [ExtensionAttribute]
[NotNullAttribute]
public static IOrderedEnumerable`1<TSource> OrderBy(IEnumerable`1<TSource> source);
    [ExtensionAttribute]
[NotNullAttribute]
public static IOrderedEnumerable`1<TSource> OrderByDescending(IEnumerable`1<TSource> source);
    [ExtensionAttribute]
[StringFormatMethodAttribute("sContextSentence")]
public static TSource SingleOrFirstErr(IEnumerable`1<TSource> source, string sContextSentence, object arg1, object arg2, object arg3, object arg4);
    [ExtensionAttribute]
[StringFormatMethodAttribute("sContextSentence")]
public static TSource SingleOrFirstOrDefaultErr(IEnumerable`1<TSource> source, string sContextSentence, object arg1, object arg2, object arg3, object arg4);
    internal static Exception CreateExceptionNoItems(Type typeItem, string sContextSentence, object arg1, object arg2, object arg3, object arg4);
    internal static Exception CreateExceptionMultipleItems(Type typeItem, object x, object y, string sContextSentence, object arg1, object arg2, object arg3, object arg4);
    internal static StringBuilder FormatMessage(string sMainMessage, Type typeItem, string sContextSentence, object arg1, object arg2, object arg3, object arg4);
    [ExtensionAttribute]
public static TSource Single(IEnumerable`1<TSource> source, string sExceptionMessageEmpty, string sExceptionMessageAmbiguous);
    [ExtensionAttribute]
public static IDictionary`2<TKey, IList`1<TValue>> MapDictionary(IEnumerable`1<TValue> source, Func`2<TValue, TKey> fGetKey);
    [ExtensionAttribute]
[ObsoleteAttribute("Avoid use of excessive lambdas. SingleOr*Err would do better, especially with lazy formatters like QuoteListIfNeeded.")]
public static TSource Single(IEnumerable`1<TSource> source, Func`1<string> fExceptionMessageEmpty, Func`1<string> fExceptionMessageAmbiguous);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static ISet`1<TSource> ToSet(IEnumerable`1<TSource> source);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static ISet`1<TSource> ToSet(IEnumerable`1<TSource> source, IEqualityComparer`1<TSource> comparer);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static JetHashSet`1<TSource> ToJetHashSet(IEnumerable`1<TSource> source);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static JetHashSet`1<TSource> ToJetHashSet(ICollectionEvents`1<TSource> source);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static JetHashSet`1<TSource> ToJetHashSet(IEnumerable`1<TSource> source, IEqualityComparer`1<TSource> comparer);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static JetHashSet`1<TKey> ToJetHashSet(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static JetHashSet`1<TKey> ToJetHashSet(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
[PureAttribute]
public static bool And(IEnumerable`1<bool> source);
    [ExtensionAttribute]
[PureAttribute]
public static bool Or(IEnumerable`1<bool> source);
    [ExtensionAttribute]
[MustUseReturnValueAttribute]
public static OneToSetMap`2<TKey, TValue> ToOneToSetMap(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TValue> valueSelector, IEqualityComparer`1<TKey> keyComparer, IEqualityComparer`1<TValue> valueComparer);
    [ExtensionAttribute]
[MustUseReturnValueAttribute]
public static OneToListMap`2<TKey, TValue> ToOneToListMap(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TValue> valueSelector, IEqualityComparer`1<TKey> keyComparer);
    [ExtensionAttribute]
[MustUseReturnValueAttribute]
public static OneToListMap`2<TKey, TValue> ToOneToListMap(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, IEnumerable`1<TValue>> valuesSelector, IEqualityComparer`1<TKey> keyComparer);
    [ExtensionAttribute]
[MustUseReturnValueAttribute]
public static List`1<TSource> Sort(IEnumerable`1<TSource> source, Func`3<TSource, TSource, int> comparer);
    [ExtensionAttribute]
public static List`1<TSource> Sort(IEnumerable`1<TSource> source, Comparison`1<TAttribute> comparer);
    [ExtensionAttribute]
public static List`1<TSource> Sort(IEnumerable`1<TSource> source);
    [IteratorStateMachineAttribute("System.Linq.EnumerableExJet/<DistinctImpl>d__30`2")]
[ExtensionAttribute]
private static IEnumerable`1<TSource> DistinctImpl(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
private static TSource FirstImpl(IEnumerable`1<TSource> source, Func`2<TSource, bool> predicate, string sExceptionMessageEmpty);
}
[IsReadOnlyAttribute]
public class System.Range : ValueType {
    [CompilerGeneratedAttribute]
private Index <Start>k__BackingField;
    [CompilerGeneratedAttribute]
private Index <End>k__BackingField;
    public Index Start { get; }
    public Index End { get; }
    public static Range All { get; }
    public Range(Index start, Index end);
    [CompilerGeneratedAttribute]
public Index get_Start();
    [CompilerGeneratedAttribute]
public Index get_End();
    public virtual bool Equals(object value);
    public sealed virtual bool Equals(Range other);
    public virtual int GetHashCode();
    public virtual string ToString();
    [PureAttribute]
public static Range StartAt(Index start);
    [PureAttribute]
public static Range EndAt(Index end);
    public static Range get_All();
    [PureAttribute]
public ValueTuple`2<int, int> GetOffsetAndLength(int length);
    [CompilerGeneratedAttribute]
internal static string <ToString>g__GetFromEndSpecifier|10_0(Index index);
    [CompilerGeneratedAttribute]
internal static string <ToString>g__ToStr|10_1(Index index);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("2048")]
public class System.Runtime.CompilerServices.CallerArgumentExpressionAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; }
    public CallerArgumentExpressionAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[AttributeUsageAttribute("32767")]
public class System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <FeatureName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOptional>k__BackingField;
    public static string RefStructs;
    public static string RequiredMembers;
    public string FeatureName { get; }
    public bool IsOptional { get; public set; }
    public CompilerFeatureRequiredAttribute(string featureName);
    [CompilerGeneratedAttribute]
public string get_FeatureName();
    [CompilerGeneratedAttribute]
public bool get_IsOptional();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IsOptional(bool value);
}
[AttributeUsageAttribute("2048")]
public class System.Runtime.CompilerServices.EnumeratorCancellationAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("2048")]
public class System.Runtime.CompilerServices.InterpolatedStringHandlerArgumentAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <Arguments>k__BackingField;
    public String[] Arguments { get; }
    public InterpolatedStringHandlerArgumentAttribute(string argument);
    public InterpolatedStringHandlerArgumentAttribute(String[] arguments);
    [CompilerGeneratedAttribute]
public String[] get_Arguments();
}
[AttributeUsageAttribute("12")]
public class System.Runtime.CompilerServices.InterpolatedStringHandlerAttribute : Attribute {
}
[EditorBrowsableAttribute("1")]
public static class System.Runtime.CompilerServices.IsExternalInit : object {
}
[EditorBrowsableAttribute("1")]
[AttributeUsageAttribute("32767")]
public class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsUnmanagedAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
public class System.Runtime.CompilerServices.ModuleInitializerAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
[AttributeUsageAttribute("396")]
[EditorBrowsableAttribute("1")]
public class System.Runtime.CompilerServices.RequiredMemberAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2048")]
internal class System.Runtime.CompilerServices.ScopedRefAttribute : Attribute {
}
[AttributeUsageAttribute("1774")]
public class System.Runtime.CompilerServices.SkipLocalsInitAttribute : Attribute {
}
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
public class System.Text.Rune : ValueType {
    internal static int MaxUtf16CharsPerRune;
    internal static int MaxUtf8BytesPerRune;
    private static char HighSurrogateStart;
    private static char LowSurrogateStart;
    private static int HighSurrogateRange;
    private static byte IsWhiteSpaceFlag;
    private static byte IsLetterOrDigitFlag;
    private static byte UnicodeCategoryMask;
    private UInt32 _value;
    private static ReadOnlySpan`1<byte> AsciiCharInfo { get; }
    [NullableAttribute("1")]
private string DebuggerDisplay { get; }
    public bool IsAscii { get; }
    public bool IsBmp { get; }
    public int Plane { get; }
    public static Rune ReplacementChar { get; }
    public int Utf16SequenceLength { get; }
    public int Utf8SequenceLength { get; }
    public int Value { get; }
    public Rune(char ch);
    public Rune(char highSurrogate, char lowSurrogate);
    public Rune(int value);
    public Rune(UInt32 value);
    private Rune(UInt32 scalarValue, bool _);
    private static ReadOnlySpan`1<byte> get_AsciiCharInfo();
    public static bool op_Equality(Rune left, Rune right);
    public static bool op_Inequality(Rune left, Rune right);
    public static bool op_LessThan(Rune left, Rune right);
    public static bool op_LessThanOrEqual(Rune left, Rune right);
    public static bool op_GreaterThan(Rune left, Rune right);
    public static bool op_GreaterThanOrEqual(Rune left, Rune right);
    public static Rune op_Explicit(char ch);
    public static Rune op_Explicit(UInt32 value);
    public static Rune op_Explicit(int value);
    [NullableContextAttribute("1")]
private string get_DebuggerDisplay();
    public bool get_IsAscii();
    public bool get_IsBmp();
    public int get_Plane();
    public static Rune get_ReplacementChar();
    public int get_Utf16SequenceLength();
    public int get_Utf8SequenceLength();
    public int get_Value();
    [NullableContextAttribute("1")]
private static Rune ChangeCaseCultureAware(Rune rune, CultureInfo culture, bool toUpper);
    public sealed virtual int CompareTo(Rune other);
    public static OperationStatus DecodeFromUtf16(ReadOnlySpan`1<char> source, Rune& result, Int32& charsConsumed);
    public static OperationStatus DecodeFromUtf8(ReadOnlySpan`1<byte> source, Rune& result, Int32& bytesConsumed);
    public static OperationStatus DecodeLastFromUtf16(ReadOnlySpan`1<char> source, Rune& result, Int32& charsConsumed);
    public static OperationStatus DecodeLastFromUtf8(ReadOnlySpan`1<byte> source, Rune& value, Int32& bytesConsumed);
    public int EncodeToUtf16(Span`1<char> destination);
    public int EncodeToUtf8(Span`1<byte> destination);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Rune other);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public static Rune GetRuneAt(string input, int index);
    public static bool IsValid(int value);
    public static bool IsValid(UInt32 value);
    internal static int ReadFirstRuneFromUtf16Buffer(ReadOnlySpan`1<char> input);
    [NullableContextAttribute("1")]
private static int ReadRuneFromString(string input, int index);
    [NullableContextAttribute("1")]
public virtual string ToString();
    public static bool TryCreate(char ch, Rune& result);
    public static bool TryCreate(char highSurrogate, char lowSurrogate, Rune& result);
    public static bool TryCreate(int value, Rune& result);
    public static bool TryCreate(UInt32 value, Rune& result);
    public bool TryEncodeToUtf16(Span`1<char> destination, Int32& charsWritten);
    private static bool TryEncodeToUtf16(Rune value, Span`1<char> destination, Int32& charsWritten);
    public bool TryEncodeToUtf8(Span`1<byte> destination, Int32& bytesWritten);
    private static bool TryEncodeToUtf8(Rune value, Span`1<byte> destination, Int32& bytesWritten);
    [NullableContextAttribute("1")]
public static bool TryGetRuneAt(string input, int index, Rune& value);
    internal static Rune UnsafeCreate(UInt32 scalarValue);
    public static double GetNumericValue(Rune value);
    public static UnicodeCategory GetUnicodeCategory(Rune value);
    private static UnicodeCategory GetUnicodeCategoryNonAscii(Rune value);
    private static bool IsCategoryLetter(UnicodeCategory category);
    private static bool IsCategoryLetterOrDecimalDigit(UnicodeCategory category);
    private static bool IsCategoryNumber(UnicodeCategory category);
    private static bool IsCategoryPunctuation(UnicodeCategory category);
    private static bool IsCategorySeparator(UnicodeCategory category);
    private static bool IsCategorySymbol(UnicodeCategory category);
    public static bool IsControl(Rune value);
    public static bool IsDigit(Rune value);
    public static bool IsLetter(Rune value);
    public static bool IsLetterOrDigit(Rune value);
    public static bool IsLower(Rune value);
    public static bool IsNumber(Rune value);
    public static bool IsPunctuation(Rune value);
    public static bool IsSeparator(Rune value);
    public static bool IsSymbol(Rune value);
    public static bool IsUpper(Rune value);
    public static bool IsWhiteSpace(Rune value);
    [NullableContextAttribute("1")]
public static Rune ToLower(Rune value, CultureInfo culture);
    public static Rune ToLowerInvariant(Rune value);
    [NullableContextAttribute("1")]
public static Rune ToUpper(Rune value, CultureInfo culture);
    public static Rune ToUpperInvariant(Rune value);
}
public class System.Text.StringRuneEnumerator : ValueType {
    [NullableAttribute("1")]
private string _string;
    private Rune _current;
    private int _nextIndex;
    public Rune Current { get; }
    [NullableAttribute("2")]
private object System.Collections.IEnumerator.Current { get; }
    [NullableContextAttribute("1")]
public StringRuneEnumerator(string value);
    public sealed virtual Rune get_Current();
    public StringRuneEnumerator GetEnumerator();
    public sealed virtual bool MoveNext();
    [NullableContextAttribute("2")]
private sealed virtual override object System.Collections.IEnumerator.get_Current();
    private sealed virtual override void System.IDisposable.Dispose();
    [NullableContextAttribute("1")]
private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [NullableContextAttribute("1")]
private sealed virtual override IEnumerator`1<Rune> System.Collections.Generic.IEnumerable<System.Text.Rune>.GetEnumerator();
    private sealed virtual override void System.Collections.IEnumerator.Reset();
}
internal static class System.Text.Unicode.Utf16Utility : object {
    internal static bool AllCharsInUInt32AreAscii(UInt32 value);
    internal static bool AllCharsInUInt64AreAscii(ulong value);
    internal static UInt32 ConvertAllAsciiCharsInUInt32ToLowercase(UInt32 value);
    internal static UInt32 ConvertAllAsciiCharsInUInt32ToUppercase(UInt32 value);
    internal static bool UInt32ContainsAnyLowercaseAsciiChar(UInt32 value);
    internal static bool UInt32ContainsAnyUppercaseAsciiChar(UInt32 value);
    internal static bool UInt32OrdinalIgnoreCaseAscii(UInt32 valueA, UInt32 valueB);
    internal static bool UInt64OrdinalIgnoreCaseAscii(ulong valueA, ulong valueB);
}
internal static class System.Text.UnicodeDebug : object {
    [ConditionalAttribute("DEBUG")]
internal static void AssertIsBmpCodePoint(UInt32 codePoint);
    [ConditionalAttribute("DEBUG")]
internal static void AssertIsHighSurrogateCodePoint(UInt32 codePoint);
    [ConditionalAttribute("DEBUG")]
internal static void AssertIsLowSurrogateCodePoint(UInt32 codePoint);
    [ConditionalAttribute("DEBUG")]
internal static void AssertIsValidCodePoint(UInt32 codePoint);
    [ConditionalAttribute("DEBUG")]
internal static void AssertIsValidScalar(UInt32 scalarValue);
    [ConditionalAttribute("DEBUG")]
internal static void AssertIsValidSupplementaryPlaneScalar(UInt32 scalarValue);
    private static string ToHexString(UInt32 codePoint);
}
internal static class System.Text.UnicodeUtility : object {
    public static UInt32 ReplacementChar;
    public static int GetPlane(UInt32 codePoint);
    public static UInt32 GetScalarFromUtf16SurrogatePair(UInt32 highSurrogateCodePoint, UInt32 lowSurrogateCodePoint);
    public static int GetUtf16SequenceLength(UInt32 value);
    public static void GetUtf16SurrogatesFromSupplementaryPlaneScalar(UInt32 value, Char& highSurrogateCodePoint, Char& lowSurrogateCodePoint);
    public static int GetUtf8SequenceLength(UInt32 value);
    public static bool IsAsciiCodePoint(UInt32 value);
    public static bool IsBmpCodePoint(UInt32 value);
    public static bool IsHighSurrogateCodePoint(UInt32 value);
    public static bool IsInRangeInclusive(UInt32 value, UInt32 lowerBound, UInt32 upperBound);
    public static bool IsLowSurrogateCodePoint(UInt32 value);
    public static bool IsSurrogateCodePoint(UInt32 value);
    public static bool IsValidCodePoint(UInt32 codePoint);
    public static bool IsValidUnicodeScalar(UInt32 value);
}
