public interface JetBrains.dotCover.Workspace.ContainersFactory.IWorkspaceContainersFactory {
    public abstract virtual ILightContainer CreateWorkspaceContainer(Lifetime lifetime, ILightContainer parentContainer, Object[] componentsToInject);
    public abstract virtual ILightContainer CreateSnapshotContainer(Lifetime lifetime, ILightContainer parentContainer, Object[] componentsToInject);
}
public class JetBrains.dotCover.Workspace.ContainersFactory.ShellBasedWorkspaceContainersFactoryBase`2 : object {
    private ShellPartCatalogSet myPartCatalogSet;
    public ShellBasedWorkspaceContainersFactoryBase`2(ShellPartCatalogSet partCatalogSet);
    public sealed virtual ILightContainer CreateWorkspaceContainer(Lifetime lifetime, ILightContainer parentContainer, Object[] componentsToInject);
    public sealed virtual ILightContainer CreateSnapshotContainer(Lifetime lifetime, ILightContainer parentContainer, Object[] componentsToInject);
    private ILightContainer CreateContainer(Lifetime lifetime, ILightContainer parentContainer, Object[] componentsToInject);
}
public abstract class JetBrains.dotCover.Workspace.ContainersFactory.SimpleWorkspaceContainersFactoryBase : object {
    public sealed virtual ILightContainer CreateWorkspaceContainer(Lifetime lifetime, ILightContainer parentContainer, Object[] componentsToInject);
    public sealed virtual ILightContainer CreateSnapshotContainer(Lifetime lifetime, ILightContainer parentContainer, Object[] componentsToInject);
    protected abstract virtual void AddWorkspaceComponents(IModifiableContainer container);
    protected abstract virtual void AddSnapshotComponents(IModifiableContainer container);
    private static ILightContainer CreateContainer(Lifetime lifetime, ILightContainer parentContainer, Object[] componentsToInject, Action`1<IModifiableContainer> appendContainer);
}
public class JetBrains.dotCover.Workspace.Contract.CoverageAnalysis.CoverageDetails : object {
    [CompilerGeneratedAttribute]
private long <CoveredStatements>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TotalStatements>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CoveragePercent>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOutdated>k__BackingField;
    public long CoveredStatements { get; public set; }
    public long TotalStatements { get; public set; }
    public int CoveragePercent { get; public set; }
    public bool IsOutdated { get; public set; }
    [CompilerGeneratedAttribute]
public long get_CoveredStatements();
    [CompilerGeneratedAttribute]
public void set_CoveredStatements(long value);
    [CompilerGeneratedAttribute]
public long get_TotalStatements();
    [CompilerGeneratedAttribute]
public void set_TotalStatements(long value);
    [CompilerGeneratedAttribute]
public int get_CoveragePercent();
    [CompilerGeneratedAttribute]
public void set_CoveragePercent(int value);
    [CompilerGeneratedAttribute]
public bool get_IsOutdated();
    [CompilerGeneratedAttribute]
public void set_IsOutdated(bool value);
}
[RdRpcAttribute]
[SnapshotModelComponentInterfaceAttribute]
public interface JetBrains.dotCover.Workspace.Contract.CoverageAnalysis.ICoverageDetailsProvider {
    public USignal`1<Unit> DetailsChanged { get; }
    public abstract virtual Task`1<CoverageDetails> GetRootDetails();
    public abstract virtual Task`1<CoverageDetails[]> GetChildDetails(CoverageNodeId nodeId);
    public abstract virtual Task`1<CoverageDetails> GetNodeDetails(CoverageNodeId nodeId);
    public abstract virtual USignal`1<Unit> get_DetailsChanged();
}
public class JetBrains.dotCover.Workspace.Contract.CoverageTree.CoverageNodeId : object {
    [CompilerGeneratedAttribute]
private int <Value>k__BackingField;
    public int Value { get; }
    public CoverageNodeId(int value);
    [CompilerGeneratedAttribute]
public int get_Value();
    public sealed virtual bool Equals(CoverageNodeId other);
    public virtual bool Equals(object obj);
    public static bool op_Equality(CoverageNodeId left, CoverageNodeId right);
    public static bool op_Inequality(CoverageNodeId left, CoverageNodeId right);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[RdRpcAttribute]
[SnapshotModelComponentInterfaceAttribute]
public interface JetBrains.dotCover.Workspace.Contract.CoverageTree.ICoverageTreeStructureProvider {
    public USignal`1<Unit> StructureChanged { get; }
    public abstract virtual Task`1<NodeInfo> GetRootNodeInfo();
    public abstract virtual Task`1<NodeInfo> GetNodeInfo(CoverageNodeId nodeId);
    public abstract virtual Task`1<NodeInfo[]> GetChildInfos(CoverageNodeId nodeId);
    public abstract virtual Task`1<CoverageNodeId[]> GetParentIds(CoverageNodeId nodeId);
    public abstract virtual Task`1<int> GetEstimatedNodesCount();
    public abstract virtual USignal`1<Unit> get_StructureChanged();
    public abstract virtual Task WhenCurrentModificationFinished();
}
[RdRpcAttribute]
[SnapshotModelComponentInterfaceAttribute]
public interface JetBrains.dotCover.Workspace.Contract.CoverageTree.IMethodsGroupingNodesProvider {
    public abstract virtual Task`1<IDictionary`2<CoverageNodeId, CoverageNodeId>> GetGroupingNodes(IEnumerable`1<CoverageNodeId> methodNodeIds);
}
public class JetBrains.dotCover.Workspace.Contract.CoverageTree.NodeInfo : object {
    [CompilerGeneratedAttribute]
private CoverageNodeId <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FullPresentableName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ShortPresentableName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Annotation>k__BackingField;
    [CompilerGeneratedAttribute]
private CoverageNodeKind <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private CoverageNodeModifier <Modifier>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasChildren>k__BackingField;
    [NotNullAttribute]
public CoverageNodeId Id { get; public set; }
    [CanBeNullAttribute]
public string FullPresentableName { get; public set; }
    [CanBeNullAttribute]
public string ShortPresentableName { get; public set; }
    [CanBeNullAttribute]
public string Annotation { get; public set; }
    [CanBeNullAttribute]
public CoverageNodeKind Kind { get; public set; }
    public CoverageNodeModifier Modifier { get; public set; }
    public bool HasChildren { get; public set; }
    [CompilerGeneratedAttribute]
public CoverageNodeId get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(CoverageNodeId value);
    [CompilerGeneratedAttribute]
public string get_FullPresentableName();
    [CompilerGeneratedAttribute]
public void set_FullPresentableName(string value);
    [CompilerGeneratedAttribute]
public string get_ShortPresentableName();
    [CompilerGeneratedAttribute]
public void set_ShortPresentableName(string value);
    [CompilerGeneratedAttribute]
public string get_Annotation();
    [CompilerGeneratedAttribute]
public void set_Annotation(string value);
    [CompilerGeneratedAttribute]
public CoverageNodeKind get_Kind();
    [CompilerGeneratedAttribute]
public void set_Kind(CoverageNodeKind value);
    [CompilerGeneratedAttribute]
public CoverageNodeModifier get_Modifier();
    [CompilerGeneratedAttribute]
public void set_Modifier(CoverageNodeModifier value);
    [CompilerGeneratedAttribute]
public bool get_HasChildren();
    [CompilerGeneratedAttribute]
public void set_HasChildren(bool value);
    public virtual string ToString();
}
[RdRpcAttribute]
[SnapshotModelComponentInterfaceAttribute]
public interface JetBrains.dotCover.Workspace.Contract.CoverageTreeQuickSearch.ICoverageTreeQuickSearchService {
    public abstract virtual Task`1<QuickSearchResult> GetQuickSearchResultAsync(string quickSearchFilter);
}
public class JetBrains.dotCover.Workspace.Contract.CoverageTreeQuickSearch.QuickSearchMatchingNodeInfo : object {
    [CompilerGeneratedAttribute]
private CoverageNodeId <NodeId>k__BackingField;
    [CompilerGeneratedAttribute]
private Int32[] <MatchingSymbolIndices>k__BackingField;
    public CoverageNodeId NodeId { get; public set; }
    public Int32[] MatchingSymbolIndices { get; public set; }
    [CompilerGeneratedAttribute]
public CoverageNodeId get_NodeId();
    [CompilerGeneratedAttribute]
public void set_NodeId(CoverageNodeId value);
    [CompilerGeneratedAttribute]
public Int32[] get_MatchingSymbolIndices();
    [CompilerGeneratedAttribute]
public void set_MatchingSymbolIndices(Int32[] value);
}
public class JetBrains.dotCover.Workspace.Contract.CoverageTreeQuickSearch.QuickSearchResult : object {
    [CompilerGeneratedAttribute]
private IEnumerable`1<QuickSearchMatchingNodeInfo> <MatchingNodes>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<CoverageNodeId> <ParentIds>k__BackingField;
    public IEnumerable`1<QuickSearchMatchingNodeInfo> MatchingNodes { get; public set; }
    public IEnumerable`1<CoverageNodeId> ParentIds { get; public set; }
    [CompilerGeneratedAttribute]
public IEnumerable`1<QuickSearchMatchingNodeInfo> get_MatchingNodes();
    [CompilerGeneratedAttribute]
public void set_MatchingNodes(IEnumerable`1<QuickSearchMatchingNodeInfo> value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<CoverageNodeId> get_ParentIds();
    [CompilerGeneratedAttribute]
public void set_ParentIds(IEnumerable`1<CoverageNodeId> value);
}
[RdRpcAttribute]
[SnapshotModelComponentInterfaceAttribute]
public interface JetBrains.dotCover.Workspace.Contract.CoverageTreeReverseCoverage.ICoverageTreeReverseCoverageProvider {
    public UProperty`1<bool> IsPerTestInfoAvailable { get; }
    public abstract virtual UProperty`1<bool> get_IsPerTestInfoAvailable();
    public abstract virtual Task`1<IEnumerable`1<UnitTestSessionTestId>> GetTestsCoveringNode(CoverageNodeId nodeId);
}
public enum JetBrains.dotCover.Workspace.Contract.DocumentsMarkup.CoverageInfoType : Enum {
    public byte value__;
    public static CoverageInfoType CoveredStatements;
    public static CoverageInfoType UncoveredStatements;
}
public class JetBrains.dotCover.Workspace.Contract.DocumentsMarkup.DocumentChecksum : object {
    [CompilerGeneratedAttribute]
private Guid <AlgorithmId>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Value>k__BackingField;
    public Guid AlgorithmId { get; }
    [NotNullAttribute]
public Byte[] Value { get; }
    public DocumentChecksum(Guid algorithmId, Byte[] value);
    [CompilerGeneratedAttribute]
public Guid get_AlgorithmId();
    [CompilerGeneratedAttribute]
public Byte[] get_Value();
    public sealed virtual bool Equals(DocumentChecksum other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class JetBrains.dotCover.Workspace.Contract.DocumentsMarkup.DocumentContext : object {
    [CompilerGeneratedAttribute]
private string <AssemblyName>k__BackingField;
    [CompilerGeneratedAttribute]
private TargetFrameworkId <TargetFrameworkId>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <PathMap>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public string AssemblyName { get; public set; }
    public TargetFrameworkId TargetFrameworkId { get; public set; }
    public IDictionary`2<string, string> PathMap { get; public set; }
    public DocumentContext(string AssemblyName, TargetFrameworkId TargetFrameworkId, IDictionary`2<string, string> PathMap);
    [CompilerGeneratedAttribute]
protected DocumentContext(DocumentContext original);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public string get_AssemblyName();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_AssemblyName(string value);
    [CompilerGeneratedAttribute]
public TargetFrameworkId get_TargetFrameworkId();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_TargetFrameworkId(TargetFrameworkId value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_PathMap();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PathMap(IDictionary`2<string, string> value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(DocumentContext left, DocumentContext right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(DocumentContext left, DocumentContext right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(DocumentContext other);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual DocumentContext <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(String& AssemblyName, TargetFrameworkId& TargetFrameworkId, IDictionary`2& PathMap);
}
public class JetBrains.dotCover.Workspace.Contract.DocumentsMarkup.DocumentPdbStatementRanges : object {
    [CompilerGeneratedAttribute]
private DocumentChecksum <DocumentChecksum>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<PdbStatementRange> <StatementRanges>k__BackingField;
    [CanBeNullAttribute]
public DocumentChecksum DocumentChecksum { get; }
    public IEnumerable`1<PdbStatementRange> StatementRanges { get; }
    public DocumentPdbStatementRanges(DocumentChecksum documentChecksum, IEnumerable`1<PdbStatementRange> statementRanges);
    [CompilerGeneratedAttribute]
public DocumentChecksum get_DocumentChecksum();
    [CompilerGeneratedAttribute]
public IEnumerable`1<PdbStatementRange> get_StatementRanges();
}
[RdRpcAttribute]
[SnapshotModelComponentInterfaceAttribute]
public interface JetBrains.dotCover.Workspace.Contract.DocumentsMarkup.IDocumentStatementsCoverageProvider {
    public abstract virtual Task`1<IEnumerable`1<MethodCoverageInfo>> GetStatementsCoverage(string documentFilePath, DocumentContext documentContext);
}
[RdRpcAttribute]
[SnapshotModelComponentInterfaceAttribute]
public interface JetBrains.dotCover.Workspace.Contract.DocumentsMarkup.IPdbStatementRangesProvider {
    public USignal`1<Unit> RangesChanged { get; }
    public abstract virtual Task`1<IEnumerable`1<DocumentPdbStatementRanges>> GetRanges(string documentFilePath, DocumentContext documentContext);
    public abstract virtual USignal`1<Unit> get_RangesChanged();
}
public class JetBrains.dotCover.Workspace.Contract.DocumentsMarkup.MethodCoverageInfo : object {
    [CompilerGeneratedAttribute]
private CoverageNodeId <MethodNodeId>k__BackingField;
    [CompilerGeneratedAttribute]
private StatementsCoverageInfo <StatementsCoverageInfo>k__BackingField;
    public CoverageNodeId MethodNodeId { get; }
    public StatementsCoverageInfo StatementsCoverageInfo { get; }
    public MethodCoverageInfo(CoverageNodeId methodNodeId, StatementsCoverageInfo statementsCoverageInfo);
    [CompilerGeneratedAttribute]
public CoverageNodeId get_MethodNodeId();
    [CompilerGeneratedAttribute]
public StatementsCoverageInfo get_StatementsCoverageInfo();
}
[RdRpcAttribute]
[SnapshotModelComponentInterfaceAttribute]
public interface JetBrains.dotCover.Workspace.Contract.DocumentsMarkup.PathMapping.IPathMappingRootConsumer {
    public abstract virtual Task SetPathMappingRoot(string root);
}
public class JetBrains.dotCover.Workspace.Contract.DocumentsMarkup.PdbRange : object {
    [CompilerGeneratedAttribute]
private int <Column>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EndColumn>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Line>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EndLine>k__BackingField;
    public int Column { get; }
    public int EndColumn { get; }
    public int Line { get; }
    public int EndLine { get; }
    public PdbRange(int column, int endColumn, int line, int endLine);
    [CompilerGeneratedAttribute]
public int get_Column();
    [CompilerGeneratedAttribute]
public int get_EndColumn();
    [CompilerGeneratedAttribute]
public int get_Line();
    [CompilerGeneratedAttribute]
public int get_EndLine();
    public bool IsValid();
    public bool Contains(PdbRange range);
}
public class JetBrains.dotCover.Workspace.Contract.DocumentsMarkup.PdbStatementRange : object {
    [CompilerGeneratedAttribute]
private StatementId <StatementId>k__BackingField;
    [CompilerGeneratedAttribute]
private PdbRange <Range>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<PdbStatementRange> <NestedStatements>k__BackingField;
    public StatementId StatementId { get; public set; }
    public PdbRange Range { get; public set; }
    public List`1<PdbStatementRange> NestedStatements { get; private set; }
    public PdbStatementRange(StatementId statementId, PdbRange range);
    [CompilerGeneratedAttribute]
public StatementId get_StatementId();
    [CompilerGeneratedAttribute]
public void set_StatementId(StatementId value);
    [CompilerGeneratedAttribute]
public PdbRange get_Range();
    [CompilerGeneratedAttribute]
public void set_Range(PdbRange value);
    [CompilerGeneratedAttribute]
public List`1<PdbStatementRange> get_NestedStatements();
    [CompilerGeneratedAttribute]
private void set_NestedStatements(List`1<PdbStatementRange> value);
    public void AddNestedStatement(PdbStatementRange statementRange);
}
[RdRpcAttribute]
[SnapshotModelComponentInterfaceAttribute]
public interface JetBrains.dotCover.Workspace.Contract.DocumentsMarkup.ReverseCoverage.IDocumentReverseCoverageProvider {
    public UProperty`1<bool> IsPerTestInfoAvailable { get; }
    public abstract virtual UProperty`1<bool> get_IsPerTestInfoAvailable();
    [NotNullAttribute]
[ItemNotNullAttribute]
public abstract virtual Task`1<TestCoverageInfo[]> GetTestsCoverageInfo(string documentFilePath, DocumentContext documentContext);
}
public class JetBrains.dotCover.Workspace.Contract.DocumentsMarkup.ReverseCoverage.TestCoverageInfo : object {
    [CompilerGeneratedAttribute]
private UnitTestSessionTestId <SessionTestId>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<MethodCoverageInfo> <MethodsCoverageInfo>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public UnitTestSessionTestId SessionTestId { get; public set; }
    public IEnumerable`1<MethodCoverageInfo> MethodsCoverageInfo { get; public set; }
    public TestCoverageInfo(UnitTestSessionTestId SessionTestId, IEnumerable`1<MethodCoverageInfo> MethodsCoverageInfo);
    [CompilerGeneratedAttribute]
protected TestCoverageInfo(TestCoverageInfo original);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public UnitTestSessionTestId get_SessionTestId();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_SessionTestId(UnitTestSessionTestId value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<MethodCoverageInfo> get_MethodsCoverageInfo();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_MethodsCoverageInfo(IEnumerable`1<MethodCoverageInfo> value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(TestCoverageInfo left, TestCoverageInfo right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(TestCoverageInfo left, TestCoverageInfo right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(TestCoverageInfo other);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual TestCoverageInfo <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(UnitTestSessionTestId& SessionTestId, IEnumerable`1& MethodsCoverageInfo);
}
public class JetBrains.dotCover.Workspace.Contract.DocumentsMarkup.StatementId : object {
    [CompilerGeneratedAttribute]
private CoverageNodeId <MethodNodeId>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StatementIndex>k__BackingField;
    public CoverageNodeId MethodNodeId { get; }
    public int StatementIndex { get; }
    public StatementId(CoverageNodeId methodNodeId, int statementIndex);
    [CompilerGeneratedAttribute]
public CoverageNodeId get_MethodNodeId();
    [CompilerGeneratedAttribute]
public int get_StatementIndex();
    public bool IsSynthetic();
    public sealed virtual bool Equals(StatementId other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(StatementId left, StatementId right);
    public static bool op_Inequality(StatementId left, StatementId right);
    public virtual string ToString();
}
[RdScalarAttribute("JetBrains.dotCover.Workspace.Contract.DocumentsMarkup.StatementsCoverageInfoMarshaller")]
public class JetBrains.dotCover.Workspace.Contract.DocumentsMarkup.StatementsCoverageInfo : object {
    [CompilerGeneratedAttribute]
private bool <Outdated>k__BackingField;
    [CompilerGeneratedAttribute]
private CoverageInfoType <InfoType>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<int> <StatementIndices>k__BackingField;
    public bool Outdated { get; internal set; }
    public CoverageInfoType InfoType { get; }
    [NotNullAttribute]
public HashSet`1<int> StatementIndices { get; }
    public StatementsCoverageInfo(bool outdated, CoverageInfoType infoType, HashSet`1<int> statementIndices);
    [CompilerGeneratedAttribute]
public bool get_Outdated();
    [CompilerGeneratedAttribute]
internal void set_Outdated(bool value);
    [CompilerGeneratedAttribute]
public CoverageInfoType get_InfoType();
    [CompilerGeneratedAttribute]
public HashSet`1<int> get_StatementIndices();
    public static StatementsCoverageInfo NothingCovered(bool outdated);
    public static StatementsCoverageInfo AllCovered(bool outdated);
}
[ExtensionAttribute]
public static class JetBrains.dotCover.Workspace.Contract.DocumentsMarkup.StatementsCoverageInfoExtensions : object {
    [ExtensionAttribute]
public static bool StatementIsCovered(StatementsCoverageInfo statementsCoverageInfo, int statementIndex);
    [ExtensionAttribute]
public static bool HasCoveredStatements(StatementsCoverageInfo statementsCoverageInfo);
}
public class JetBrains.dotCover.Workspace.Contract.DocumentsMarkup.StatementsCoverageInfoMarshaller : object {
    public sealed virtual StatementsCoverageInfo Read(SerializationCtx ctx, UnsafeReader reader);
    public sealed virtual void Write(SerializationCtx ctx, UnsafeWriter writer, StatementsCoverageInfo value);
}
public class JetBrains.dotCover.Workspace.Contract.Filtering.AttributeFilter : object {
    [CompilerGeneratedAttribute]
private string <ClassMask>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsEnabled>k__BackingField;
    public string ClassMask { get; }
    public bool IsEnabled { get; }
    public AttributeFilter(string classMask, bool isEnabled);
    [CompilerGeneratedAttribute]
public string get_ClassMask();
    [CompilerGeneratedAttribute]
public bool get_IsEnabled();
    public sealed virtual bool Equals(AttributeFilter other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class JetBrains.dotCover.Workspace.Contract.Filtering.AttributeFilterSet : object {
    [CompilerGeneratedAttribute]
private IEnumerable`1<AttributeFilter> <ExcludeFilters>k__BackingField;
    [NotNullAttribute]
public IEnumerable`1<AttributeFilter> ExcludeFilters { get; }
    public AttributeFilterSet(IEnumerable`1<AttributeFilter> excludeFilters);
    [CompilerGeneratedAttribute]
public IEnumerable`1<AttributeFilter> get_ExcludeFilters();
    public sealed virtual bool Equals(AttributeFilterSet other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class JetBrains.dotCover.Workspace.Contract.Filtering.CoverageFilter : object {
    [CompilerGeneratedAttribute]
private string <ModuleMask>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ModuleVersionMask>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClassMask>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FunctionMask>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsEnabled>k__BackingField;
    public string ModuleMask { get; public set; }
    public string ModuleVersionMask { get; public set; }
    public string ClassMask { get; public set; }
    public string FunctionMask { get; public set; }
    public bool IsEnabled { get; public set; }
    public CoverageFilter(string moduleMask, string moduleVersionMask, string classMask, string functionMask, bool isEnabled);
    public CoverageFilter(string moduleMask);
    [CompilerGeneratedAttribute]
public string get_ModuleMask();
    [CompilerGeneratedAttribute]
public void set_ModuleMask(string value);
    [CompilerGeneratedAttribute]
public string get_ModuleVersionMask();
    [CompilerGeneratedAttribute]
public void set_ModuleVersionMask(string value);
    [CompilerGeneratedAttribute]
public string get_ClassMask();
    [CompilerGeneratedAttribute]
public void set_ClassMask(string value);
    [CompilerGeneratedAttribute]
public string get_FunctionMask();
    [CompilerGeneratedAttribute]
public void set_FunctionMask(string value);
    [CompilerGeneratedAttribute]
public bool get_IsEnabled();
    [CompilerGeneratedAttribute]
public void set_IsEnabled(bool value);
    public sealed virtual bool Equals(CoverageFilter other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class JetBrains.dotCover.Workspace.Contract.Filtering.CoverageFilterSet : object {
    [CompilerGeneratedAttribute]
private IEnumerable`1<CoverageFilter> <IncludeFilters>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<CoverageFilter> <ExcludeFilters>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<CoverageFilter> <AdditionalIncludeFilters>k__BackingField;
    public IEnumerable`1<CoverageFilter> IncludeFilters { get; }
    public IEnumerable`1<CoverageFilter> ExcludeFilters { get; }
    public IEnumerable`1<CoverageFilter> AdditionalIncludeFilters { get; }
    public CoverageFilterSet(IEnumerable`1<CoverageFilter> includeFilters, IEnumerable`1<CoverageFilter> excludeFilters, IEnumerable`1<CoverageFilter> additionalIncludeFilters);
    public sealed virtual bool Equals(CoverageFilterSet other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public IEnumerable`1<CoverageFilter> get_IncludeFilters();
    [CompilerGeneratedAttribute]
public IEnumerable`1<CoverageFilter> get_ExcludeFilters();
    [CompilerGeneratedAttribute]
public IEnumerable`1<CoverageFilter> get_AdditionalIncludeFilters();
}
[DataContractAttribute]
public class JetBrains.dotCover.Workspace.Contract.Filtering.CoverageTreePath : ValueType {
    [CompilerGeneratedAttribute]
private bool <IsMetadataBasedCoverageTreePath>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <PathItems>k__BackingField;
    [DataMemberAttribute]
public bool IsMetadataBasedCoverageTreePath { get; private set; }
    [DataMemberAttribute]
public String[] PathItems { get; private set; }
    public CoverageTreePath(bool isMetadataBasedCoverageTreePath, String[] pathItems);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_IsMetadataBasedCoverageTreePath();
    [CompilerGeneratedAttribute]
private void set_IsMetadataBasedCoverageTreePath(bool value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public String[] get_PathItems();
    [CompilerGeneratedAttribute]
private void set_PathItems(String[] value);
}
[ExtensionAttribute]
public static class JetBrains.dotCover.Workspace.Contract.Filtering.FiltersConverter : object {
    [ExtensionAttribute]
public static PatternFilterInfo[] ToProfilerFilters(CoverageFilterSet filters);
    [ExtensionAttribute]
private static PatternFilterInfo ToProfilerFilter(CoverageFilter filter, FilterType filterType);
    [ExtensionAttribute]
public static AttributeFilterInfo[] ToProfilerFilters(AttributeFilterSet filters);
    [ExtensionAttribute]
public static ProcessFilterArgument[] ToProfilerFilters(ProcessFilterSet filters);
}
[RdRpcAttribute]
[SnapshotModelComponentInterfaceAttribute]
public interface JetBrains.dotCover.Workspace.Contract.Filtering.IAutoPropertiesFilterConfigurator {
    public abstract virtual Task SetHideAutoProperties(bool value);
}
[RdRpcAttribute]
[SnapshotModelComponentInterfaceAttribute]
public interface JetBrains.dotCover.Workspace.Contract.Filtering.ICoverageFiltersFactory {
    public abstract virtual Task`1<IEnumerable`1<CoverageFilter>> TryCreateExcludeFiltersByCoverageNode(CoverageNodeId nodeId);
}
[RdRpcAttribute]
[SnapshotModelComponentInterfaceAttribute]
public interface JetBrains.dotCover.Workspace.Contract.Filtering.IDocumentsFilterConfigurator {
    public abstract virtual Task SetFilteredDocumentMasks(IEnumerable`1<string> masks);
}
public interface JetBrains.dotCover.Workspace.Contract.Filtering.IFilterConfigurator {
    public UProperty`1<bool> HasCurrentlyExcludedNodes { get; }
    public abstract virtual UProperty`1<bool> get_HasCurrentlyExcludedNodes();
}
[RdRpcAttribute]
[SnapshotModelComponentInterfaceAttribute]
public interface JetBrains.dotCover.Workspace.Contract.Filtering.IManualNodesFilterConfigurator {
    public UListEvents`1<CoverageNodeId> NodesForbiddenForExclude { get; }
    public UListEvents`1<CoverageNodeId> NodesForbiddenForExcludeAllExcept { get; }
    public UProperty`1<CoverageTreePath[]> ExcludedPaths { get; }
    public UProperty`1<CoverageTreePath[]> IncludedPaths { get; }
    public abstract virtual UListEvents`1<CoverageNodeId> get_NodesForbiddenForExclude();
    public abstract virtual Task`1<CoverageNodeId[]> GetOptimizedExcludedNodes(CoverageNodeId[] nodeIds, ProgressId progressId);
    public abstract virtual Task ExcludeNodes(CoverageNodeId[] nodeIds, ProgressId progressId);
    public abstract virtual UListEvents`1<CoverageNodeId> get_NodesForbiddenForExcludeAllExcept();
    public abstract virtual Task ExcludeAllNodesExcept(CoverageNodeId[] nodeIds, ProgressId progressId);
    public abstract virtual Task ResetExcludedNodes();
    public abstract virtual Task SetExcludedAndIncludedPaths(CoverageTreePath[] excludedPaths, CoverageTreePath[] includedPaths);
    public abstract virtual UProperty`1<CoverageTreePath[]> get_ExcludedPaths();
    public abstract virtual UProperty`1<CoverageTreePath[]> get_IncludedPaths();
}
public class JetBrains.dotCover.Workspace.Contract.Filtering.ProcessFilterSet : object {
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <IncludeFilters>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <ExcludeFilters>k__BackingField;
    public IEnumerable`1<string> IncludeFilters { get; }
    public IEnumerable`1<string> ExcludeFilters { get; }
    public ProcessFilterSet(IEnumerable`1<string> includeFilters, IEnumerable`1<string> excludeFilters);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_IncludeFilters();
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_ExcludeFilters();
}
[RdRpcAttribute]
[SnapshotModelComponentInterfaceAttribute]
public interface JetBrains.dotCover.Workspace.Contract.Filtering.TargetFrameworkFilter.ITargetFrameworkFilterConfigurator {
    public UProperty`1<TargetFrameworkId[]> AllTargetFrameworks { get; }
    public abstract virtual UProperty`1<TargetFrameworkId[]> get_AllTargetFrameworks();
    public abstract virtual Task ExcludeTargetFramework(TargetFrameworkId targetFrameworkId);
    public abstract virtual Task IncludeTargetFramework(TargetFrameworkId targetFrameworkId);
    public abstract virtual Task Reset(IEnumerable`1<TargetFrameworkId> targetFrameworkIds);
}
[RdRpcAttribute]
[SnapshotModelComponentInterfaceAttribute]
public interface JetBrains.dotCover.Workspace.Contract.Grouping.INamespaceGroupingConfigurator {
    public UProperty`1<bool> GroupingEnabled { get; }
    public abstract virtual UProperty`1<bool> get_GroupingEnabled();
}
[RdRpcAttribute]
[SnapshotModelComponentInterfaceAttribute]
public interface JetBrains.dotCover.Workspace.Contract.HotSpots.IRiskMetricsProvider {
    public UProperty`1<bool> AreMetricsAvailable { get; }
    public USignal`1<Unit> MetricsChanged { get; }
    public abstract virtual UProperty`1<bool> get_AreMetricsAvailable();
    public abstract virtual Task`1<IEnumerable`1<TypeRiskMetricPresentableInfo>> GetTypesRiskMetrics();
    [ItemCanBeNullAttribute]
public abstract virtual Task`1<TypeRiskMetricPresentableDetails> TryGetTypeRiskMetricDetails(CoverageNodeId typeNodeId);
    public abstract virtual USignal`1<Unit> get_MetricsChanged();
}
public class JetBrains.dotCover.Workspace.Contract.HotSpots.TypeRiskMetricPresentableDetails : object {
    [CompilerGeneratedAttribute]
private string <NamespaceName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AssemblyName>k__BackingField;
    [CompilerGeneratedAttribute]
private CoverageNodeId <RiskiestMethodNodeId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RiskiestMethodName>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <RiskiestMethodCyclomaticComplexity>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RiskiestMethodCoveragePercent>k__BackingField;
    public string NamespaceName { get; public set; }
    public string AssemblyName { get; public set; }
    public CoverageNodeId RiskiestMethodNodeId { get; public set; }
    public string RiskiestMethodName { get; public set; }
    public UInt32 RiskiestMethodCyclomaticComplexity { get; public set; }
    public int RiskiestMethodCoveragePercent { get; public set; }
    [CompilerGeneratedAttribute]
public string get_NamespaceName();
    [CompilerGeneratedAttribute]
public void set_NamespaceName(string value);
    [CompilerGeneratedAttribute]
public string get_AssemblyName();
    [CompilerGeneratedAttribute]
public void set_AssemblyName(string value);
    [CompilerGeneratedAttribute]
public CoverageNodeId get_RiskiestMethodNodeId();
    [CompilerGeneratedAttribute]
public void set_RiskiestMethodNodeId(CoverageNodeId value);
    [CompilerGeneratedAttribute]
public string get_RiskiestMethodName();
    [CompilerGeneratedAttribute]
public void set_RiskiestMethodName(string value);
    [CompilerGeneratedAttribute]
public UInt32 get_RiskiestMethodCyclomaticComplexity();
    [CompilerGeneratedAttribute]
public void set_RiskiestMethodCyclomaticComplexity(UInt32 value);
    [CompilerGeneratedAttribute]
public int get_RiskiestMethodCoveragePercent();
    [CompilerGeneratedAttribute]
public void set_RiskiestMethodCoveragePercent(int value);
}
public class JetBrains.dotCover.Workspace.Contract.HotSpots.TypeRiskMetricPresentableInfo : object {
    [CompilerGeneratedAttribute]
private CoverageNodeId <TypeNodeId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ShortTypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RiskMetric>k__BackingField;
    public CoverageNodeId TypeNodeId { get; public set; }
    public string ShortTypeName { get; public set; }
    public int RiskMetric { get; public set; }
    [CompilerGeneratedAttribute]
public CoverageNodeId get_TypeNodeId();
    [CompilerGeneratedAttribute]
public void set_TypeNodeId(CoverageNodeId value);
    [CompilerGeneratedAttribute]
public string get_ShortTypeName();
    [CompilerGeneratedAttribute]
public void set_ShortTypeName(string value);
    [CompilerGeneratedAttribute]
public int get_RiskMetric();
    [CompilerGeneratedAttribute]
public void set_RiskMetric(int value);
}
public class JetBrains.dotCover.Workspace.Contract.Infrastructure.CustomWebProxySettings : object {
    public static CustomWebProxySettings Default;
    [CompilerGeneratedAttribute]
private bool <IsCustomProxy>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Hostname>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Port>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Username>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Password>k__BackingField;
    public bool IsCustomProxy { get; }
    public string Hostname { get; }
    public int Port { get; }
    public string Username { get; }
    public string Password { get; }
    public CustomWebProxySettings(string hostname, int port, string username, string password);
    private static CustomWebProxySettings();
    [CompilerGeneratedAttribute]
public bool get_IsCustomProxy();
    [CompilerGeneratedAttribute]
public string get_Hostname();
    [CompilerGeneratedAttribute]
public int get_Port();
    [CompilerGeneratedAttribute]
public string get_Username();
    [CompilerGeneratedAttribute]
public string get_Password();
}
[RdRpcAttribute]
[WorkspaceModelComponentInterfaceAttribute]
public interface JetBrains.dotCover.Workspace.Contract.Infrastructure.IProgressService {
    public RdMap`2<ProgressId, ProgressInfo> ActiveProgressInfos { get; }
    public abstract virtual RdMap`2<ProgressId, ProgressInfo> get_ActiveProgressInfos();
}
public static class JetBrains.dotCover.Workspace.Contract.Infrastructure.NullProgressId : object {
    public static ProgressId Instance;
    private static NullProgressId();
}
public class JetBrains.dotCover.Workspace.Contract.Infrastructure.ProgressId : object {
    private string myId;
    public ProgressId(string id);
    public static ProgressId NewId();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[RdModelAttribute]
public class JetBrains.dotCover.Workspace.Contract.Infrastructure.ProgressInfo : RdReflectionBindableBase {
    [CompilerGeneratedAttribute]
private UProperty`1<int> <Percent>k__BackingField;
    [CompilerGeneratedAttribute]
private UProperty`1<string> <TaskName>k__BackingField;
    [CompilerGeneratedAttribute]
private UProperty`1<string> <CurrentItemText>k__BackingField;
    [CompilerGeneratedAttribute]
private UProperty`1<bool> <IsCanceled>k__BackingField;
    public UProperty`1<int> Percent { get; }
    public UProperty`1<string> TaskName { get; }
    public UProperty`1<string> CurrentItemText { get; }
    public UProperty`1<bool> IsCanceled { get; }
    [CompilerGeneratedAttribute]
public UProperty`1<int> get_Percent();
    [CompilerGeneratedAttribute]
public UProperty`1<string> get_TaskName();
    [CompilerGeneratedAttribute]
public UProperty`1<string> get_CurrentItemText();
    [CompilerGeneratedAttribute]
public UProperty`1<bool> get_IsCanceled();
}
public class JetBrains.dotCover.Workspace.Contract.InternalToolkit.DocumentRangeSectionExplorer.DocumentRangeChecksum : object {
    [CompilerGeneratedAttribute]
private Guid <Algorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Value>k__BackingField;
    public Guid Algorithm { get; }
    public Byte[] Value { get; }
    public DocumentRangeChecksum(Guid algorithm, Byte[] value);
    [CompilerGeneratedAttribute]
public Guid get_Algorithm();
    [CompilerGeneratedAttribute]
public Byte[] get_Value();
    public virtual string ToString();
}
public class JetBrains.dotCover.Workspace.Contract.InternalToolkit.DocumentRangeSectionExplorer.DocumentRangeEntry : object {
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Url>k__BackingField;
    [CompilerGeneratedAttribute]
private DocumentRangeChecksum <Checksum>k__BackingField;
    public int Index { get; }
    public string Url { get; }
    public DocumentRangeChecksum Checksum { get; }
    public DocumentRangeEntry(int index, string url, DocumentRangeChecksum checksum);
    [CompilerGeneratedAttribute]
public int get_Index();
    [CompilerGeneratedAttribute]
public string get_Url();
    [CompilerGeneratedAttribute]
public DocumentRangeChecksum get_Checksum();
    public virtual string ToString();
}
[RdRpcAttribute]
[SnapshotModelComponentInterfaceAttribute]
public interface JetBrains.dotCover.Workspace.Contract.InternalToolkit.DocumentRangeSectionExplorer.IDocumentRangeSectionExplorerModel {
    public UProperty`1<DocumentRangeEntry[]> Entries { get; }
    public abstract virtual UProperty`1<DocumentRangeEntry[]> get_Entries();
}
public class JetBrains.dotCover.Workspace.Contract.InternalToolkit.EnvironmentSectionExplorer.EnvironmentSectionEntry : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    public string Name { get; }
    public string Value { get; }
    public EnvironmentSectionEntry(string name, string value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public string get_Value();
}
[RdRpcAttribute]
[SnapshotModelComponentInterfaceAttribute]
public interface JetBrains.dotCover.Workspace.Contract.InternalToolkit.EnvironmentSectionExplorer.IEnvironmentSectionExplorerModel {
    public UProperty`1<EnvironmentSectionEntry[]> Entries { get; }
    public abstract virtual UProperty`1<EnvironmentSectionEntry[]> get_Entries();
}
public class JetBrains.dotCover.Workspace.Contract.InternalToolkit.FunctionInfoExplorer.AssemblyData : object {
    [CompilerGeneratedAttribute]
private UInt32 <MetadataIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PresentableName>k__BackingField;
    public UInt32 MetadataIndex { get; }
    public string PresentableName { get; }
    public AssemblyData(UInt32 metadataIndex, string presentableName);
    [CompilerGeneratedAttribute]
public UInt32 get_MetadataIndex();
    [CompilerGeneratedAttribute]
public string get_PresentableName();
    public virtual string ToString();
}
public class JetBrains.dotCover.Workspace.Contract.InternalToolkit.FunctionInfoExplorer.ExtendedFunctionInfo : FunctionInfo {
    [CompilerGeneratedAttribute]
private string <AssemblyName>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<Guid> <AssemblyMvid>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <TotalStatements>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <FilteredStatements>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <CoveredStatements>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<UInt32> <CyclomaticComplexity>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <DefinedIn>k__BackingField;
    [CompilerGeneratedAttribute]
private RangeData[] <Ranges>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <FunctionIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private TestData[] <CoveredBy>k__BackingField;
    public string AssemblyName { get; }
    public Nullable`1<Guid> AssemblyMvid { get; }
    public Nullable`1<int> TotalStatements { get; }
    public Nullable`1<int> FilteredStatements { get; }
    public Nullable`1<int> CoveredStatements { get; }
    public Nullable`1<UInt32> CyclomaticComplexity { get; }
    [NotNullAttribute]
public String[] DefinedIn { get; }
    [NotNullAttribute]
public RangeData[] Ranges { get; }
    public Nullable`1<int> FunctionIndex { get; }
    [NotNullAttribute]
public TestData[] CoveredBy { get; }
    public ExtendedFunctionInfo(string presentableName, MetadataId metadataId, string assemblyName, Nullable`1<Guid> assemblyMvid, Nullable`1<int> totalStatements, Nullable`1<int> filteredStatements, Nullable`1<int> coveredStatements, Nullable`1<UInt32> cyclomaticComplexity, String[] definedIn, RangeData[] ranges, Nullable`1<int> functionIndex, TestData[] coveredBy);
    [CompilerGeneratedAttribute]
public string get_AssemblyName();
    [CompilerGeneratedAttribute]
public Nullable`1<Guid> get_AssemblyMvid();
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_TotalStatements();
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_FilteredStatements();
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_CoveredStatements();
    [CompilerGeneratedAttribute]
public Nullable`1<UInt32> get_CyclomaticComplexity();
    [CompilerGeneratedAttribute]
public String[] get_DefinedIn();
    [CompilerGeneratedAttribute]
public RangeData[] get_Ranges();
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_FunctionIndex();
    [CompilerGeneratedAttribute]
public TestData[] get_CoveredBy();
}
public class JetBrains.dotCover.Workspace.Contract.InternalToolkit.FunctionInfoExplorer.FunctionInfo : object {
    [CompilerGeneratedAttribute]
private string <PresentableName>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <MetadataIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Token>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CoveredStatementsCount>k__BackingField;
    public string PresentableName { get; }
    public UInt32 MetadataIndex { get; }
    public UInt32 Token { get; }
    public int CoveredStatementsCount { get; internal set; }
    public FunctionInfo(string presentableName, MetadataId metadataId);
    [CompilerGeneratedAttribute]
public string get_PresentableName();
    [CompilerGeneratedAttribute]
public UInt32 get_MetadataIndex();
    [CompilerGeneratedAttribute]
public UInt32 get_Token();
    [CompilerGeneratedAttribute]
public int get_CoveredStatementsCount();
    [CompilerGeneratedAttribute]
internal void set_CoveredStatementsCount(int value);
    public virtual string ToString();
}
[RdRpcAttribute]
[SnapshotModelComponentInterfaceAttribute]
public interface JetBrains.dotCover.Workspace.Contract.InternalToolkit.FunctionInfoExplorer.IFunctionInfoExplorerModel {
    public UProperty`1<string> SnapshotPath { get; }
    public abstract virtual UProperty`1<string> get_SnapshotPath();
    public abstract virtual Task`1<int> GetTotalMethodsCount();
    public abstract virtual Task`1<FunctionInfo[]> FilterFunctions(UInt32[] assemblyMetadataIndices, Nullable`1<UInt32> token, string nameFilter);
    public abstract virtual Task`1<ExtendedFunctionInfo> GetExtendedFunctionInfo(FunctionInfo functionData);
    public abstract virtual Task`1<AssemblyData[]> GetAssembliesData();
}
public class JetBrains.dotCover.Workspace.Contract.InternalToolkit.FunctionInfoExplorer.RangeData : object {
    [CompilerGeneratedAttribute]
private string <FilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Line>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EndLine>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Column>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EndColumn>k__BackingField;
    public string FilePath { get; }
    public int Line { get; }
    public int EndLine { get; }
    public int Column { get; }
    public int EndColumn { get; }
    public RangeData(string filePath, int line, int endLine, int column, int endColumn);
    [CompilerGeneratedAttribute]
public string get_FilePath();
    [CompilerGeneratedAttribute]
public int get_Line();
    [CompilerGeneratedAttribute]
public int get_EndLine();
    [CompilerGeneratedAttribute]
public int get_Column();
    [CompilerGeneratedAttribute]
public int get_EndColumn();
}
public class JetBrains.dotCover.Workspace.Contract.InternalToolkit.FunctionInfoExplorer.TestData : object {
    [CompilerGeneratedAttribute]
private string <TestName>k__BackingField;
    [CompilerGeneratedAttribute]
private int <GroupIndex>k__BackingField;
    public string TestName { get; }
    public int GroupIndex { get; }
    public TestData(string testName, int groupIndex);
    [CompilerGeneratedAttribute]
public string get_TestName();
    [CompilerGeneratedAttribute]
public int get_GroupIndex();
}
public class JetBrains.dotCover.Workspace.Contract.InternalToolkit.GroupNameIndexSectionExplorer.GroupNameIndexEntry : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Int32[] <Indices>k__BackingField;
    public string Name { get; }
    public Int32[] Indices { get; }
    public GroupNameIndexEntry(string name, Int32[] indices);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public Int32[] get_Indices();
    public virtual string ToString();
}
[RdRpcAttribute]
[SnapshotModelComponentInterfaceAttribute]
public interface JetBrains.dotCover.Workspace.Contract.InternalToolkit.GroupNameIndexSectionExplorer.IGroupNameIndexSectionExplorerModel {
    public UProperty`1<GroupNameIndexEntry[]> Entries { get; }
    public abstract virtual UProperty`1<GroupNameIndexEntry[]> get_Entries();
}
[RdRpcAttribute]
[SnapshotModelComponentInterfaceAttribute]
public interface JetBrains.dotCover.Workspace.Contract.InternalToolkit.ModuleStatSectionExplorer.IModuleStatSectionExplorerModel {
    public UProperty`1<string> SnapshotPath { get; }
    public UProperty`1<bool> IsModuleStatSectionAvailable { get; }
    public abstract virtual UProperty`1<string> get_SnapshotPath();
    public abstract virtual UProperty`1<bool> get_IsModuleStatSectionAvailable();
    public abstract virtual Task`1<ModuleLoadInfo[]> GetModulesLoadInfo();
}
public class JetBrains.dotCover.Workspace.Contract.InternalToolkit.ModuleStatSectionExplorer.ModuleLoadInfo : object {
    [CompilerGeneratedAttribute]
private UInt32 <MetadataIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Mvid>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsMatch>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasPdb>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ModulePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ModuleName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AssemblyName>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <AssemblyVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetFramework>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetPlatform>k__BackingField;
    public UInt32 MetadataIndex { get; }
    public string Mvid { get; }
    public bool IsMatch { get; }
    public bool HasPdb { get; }
    public string ModulePath { get; }
    public string ModuleName { get; }
    public string AssemblyName { get; }
    public Version AssemblyVersion { get; }
    public string TargetFramework { get; }
    public string TargetPlatform { get; }
    public ModuleLoadInfo(UInt32 metadataIndex, string mvid, bool isMatch, bool hasPdb, string modulePath, string moduleName, string assemblyName, Version assemblyVersion, string targetFramework, string targetPlatform);
    [CompilerGeneratedAttribute]
public UInt32 get_MetadataIndex();
    [CompilerGeneratedAttribute]
public string get_Mvid();
    [CompilerGeneratedAttribute]
public bool get_IsMatch();
    [CompilerGeneratedAttribute]
public bool get_HasPdb();
    [CompilerGeneratedAttribute]
public string get_ModulePath();
    [CompilerGeneratedAttribute]
public string get_ModuleName();
    [CompilerGeneratedAttribute]
public string get_AssemblyName();
    [CompilerGeneratedAttribute]
public Version get_AssemblyVersion();
    [CompilerGeneratedAttribute]
public string get_TargetFramework();
    [CompilerGeneratedAttribute]
public string get_TargetPlatform();
}
public class JetBrains.dotCover.Workspace.Contract.InternalToolkit.StatementCoverageIndexSectionExplorer.GroupIndexEntry : object {
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public int Index { get; }
    public string Name { get; }
    public GroupIndexEntry(int index, string name);
    [CompilerGeneratedAttribute]
public int get_Index();
    [CompilerGeneratedAttribute]
public string get_Name();
    public virtual string ToString();
}
[RdRpcAttribute]
[SnapshotModelComponentInterfaceAttribute]
public interface JetBrains.dotCover.Workspace.Contract.InternalToolkit.StatementCoverageIndexSectionExplorer.IStatementCoverageIndexSectionExplorerModel {
    public UProperty`1<SStatementCoverageIndexEntry[]> TotalEntries { get; }
    public UProperty`1<GroupIndexEntry[]> GroupIndices { get; }
    public abstract virtual UProperty`1<SStatementCoverageIndexEntry[]> get_TotalEntries();
    public abstract virtual UProperty`1<GroupIndexEntry[]> get_GroupIndices();
    public abstract virtual Task`1<SStatementCoverageIndexEntry[]> GetGroupEntries(int groupIndex);
}
public class JetBrains.dotCover.Workspace.Contract.InternalToolkit.StatementCoverageIndexSectionExplorer.SMetadataId : object {
    [CompilerGeneratedAttribute]
private UInt32 <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Token>k__BackingField;
    public UInt32 Index { get; }
    public UInt32 Token { get; }
    public SMetadataId(UInt32 index, UInt32 token);
    [CompilerGeneratedAttribute]
public UInt32 get_Index();
    [CompilerGeneratedAttribute]
public UInt32 get_Token();
    public virtual string ToString();
}
public class JetBrains.dotCover.Workspace.Contract.InternalToolkit.StatementCoverageIndexSectionExplorer.SStatementCoverageIndexEntry : object {
    [CompilerGeneratedAttribute]
private SMetadataId <MetadataId>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CoverageInfoOutdated>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CoveredStatementsCount>k__BackingField;
    [CompilerGeneratedAttribute]
private long <StatementDetailsOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private SStatementDetails[] <Details>k__BackingField;
    public SMetadataId MetadataId { get; }
    public bool CoverageInfoOutdated { get; }
    public int CoveredStatementsCount { get; }
    public long StatementDetailsOffset { get; }
    public SStatementDetails[] Details { get; }
    public SStatementCoverageIndexEntry(SMetadataId metadataId, bool coverageInfoOutdated, int coveredStatementsCount, long statementDetailsOffset, SStatementDetails[] details);
    [CompilerGeneratedAttribute]
public SMetadataId get_MetadataId();
    [CompilerGeneratedAttribute]
public bool get_CoverageInfoOutdated();
    [CompilerGeneratedAttribute]
public int get_CoveredStatementsCount();
    [CompilerGeneratedAttribute]
public long get_StatementDetailsOffset();
    [CompilerGeneratedAttribute]
public SStatementDetails[] get_Details();
    public virtual string ToString();
}
public class JetBrains.dotCover.Workspace.Contract.InternalToolkit.StatementCoverageIndexSectionExplorer.SStatementDetails : object {
    [CompilerGeneratedAttribute]
private bool <IsCovered>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <Count>k__BackingField;
    public bool IsCovered { get; }
    public ulong Count { get; }
    public SStatementDetails(bool isCovered, ulong count);
    [CompilerGeneratedAttribute]
public bool get_IsCovered();
    [CompilerGeneratedAttribute]
public ulong get_Count();
    public virtual string ToString();
}
[RdRpcAttribute]
[SnapshotModelComponentInterfaceAttribute]
public interface JetBrains.dotCover.Workspace.Contract.Reporting.IDetailedFileCoverageJsonReportBuilder {
    public abstract virtual Task BuildReport(string fileName, ProgressId progressId, ReportFeatures reportFeatures);
}
[RdRpcAttribute]
[SnapshotModelComponentInterfaceAttribute]
public interface JetBrains.dotCover.Workspace.Contract.Reporting.IDetailedFileCoverageXmlReportBuilder {
    public abstract virtual Task BuildReport(string fileName, ProgressId progressId, ReportFeatures reportFeatures);
}
[RdRpcAttribute]
[SnapshotModelComponentInterfaceAttribute]
public interface JetBrains.dotCover.Workspace.Contract.Reporting.IDetailedXmlReportBuilder {
    public abstract virtual Task BuildReport(string fileName, ProgressId progressId, ReportFeatures reportFeatures);
}
[RdRpcAttribute]
[SnapshotModelComponentInterfaceAttribute]
public interface JetBrains.dotCover.Workspace.Contract.Reporting.IFileCoverageJsonReportBuilder {
    public abstract virtual Task BuildReport(string fileName, ProgressId progressId, ReportFeatures reportFeatures);
}
[RdRpcAttribute]
[SnapshotModelComponentInterfaceAttribute]
public interface JetBrains.dotCover.Workspace.Contract.Reporting.IFileCoverageXmlReportBuilder {
    public abstract virtual Task BuildReport(string fileName, ProgressId progressId, ReportFeatures reportFeatures);
}
[RdRpcAttribute]
[SnapshotModelComponentInterfaceAttribute]
public interface JetBrains.dotCover.Workspace.Contract.Reporting.IHtmlReportBuilder {
    public abstract virtual Task BuildReport(string fileName, bool includeEnvironmentSpecificInfo, bool allowSourceServersAccess, String[] sourcesSearchPaths, CustomWebProxySettings webProxySettings, ProgressId progressId);
}
[RdRpcAttribute]
[SnapshotModelComponentInterfaceAttribute]
public interface JetBrains.dotCover.Workspace.Contract.Reporting.IJsonReportBuilder {
    public abstract virtual Task BuildReport(string fileName, ProgressId progressId, ReportFeatures reportFeatures);
}
[RdRpcAttribute]
[SnapshotModelComponentInterfaceAttribute]
public interface JetBrains.dotCover.Workspace.Contract.Reporting.INDependReportBuilder {
    public abstract virtual Task BuildReport(string fileName, ProgressId progressId, ReportFeatures reportFeatures);
}
[RdRpcAttribute]
[SnapshotModelComponentInterfaceAttribute]
public interface JetBrains.dotCover.Workspace.Contract.Reporting.ISummaryXmlReportBuilder {
    public abstract virtual Task BuildReport(string fileName, ProgressId progressId, ReportFeatures reportFeatures);
}
[RdRpcAttribute]
[SnapshotModelComponentInterfaceAttribute]
public interface JetBrains.dotCover.Workspace.Contract.Reporting.ITeamCityReportBuilder {
    public abstract virtual Task BuildReport(string fileName, ProgressId progressId, ReportFeatures reportFeatures);
}
[RdRpcAttribute]
[SnapshotModelComponentInterfaceAttribute]
public interface JetBrains.dotCover.Workspace.Contract.Reporting.IUncoveredLinesReportBuilder {
    public abstract virtual Task BuildReport(string fileName, string sourcesRoot, ProgressId progressId);
}
[RdRpcAttribute]
[SnapshotModelComponentInterfaceAttribute]
public interface JetBrains.dotCover.Workspace.Contract.Reporting.IXmlReportBuilder {
    public abstract virtual Task BuildReport(string fileName, ProgressId progressId, ReportFeatures reportFeatures);
}
[FlagsAttribute]
public enum JetBrains.dotCover.Workspace.Contract.Reporting.PerTestInfoKind : Enum {
    public int value__;
    public static PerTestInfoKind None;
    public static PerTestInfoKind Assembly;
    public static PerTestInfoKind Namespace;
    public static PerTestInfoKind Type;
    public static PerTestInfoKind Method;
}
[ExtensionAttribute]
public static class JetBrains.dotCover.Workspace.Contract.Reporting.PerTestInfoKindExtension : object {
    private static IDictionary`2<PerTestInfoKind, Func`2<CoverageNodeKind, bool>> ourAvailableCoverageNodeKindMap;
    private static PerTestInfoKindExtension();
    [ExtensionAttribute]
public static bool IsMatched(PerTestInfoKind perTestInfoKind, CoverageNodeKind nodeKind);
    [ExtensionAttribute]
public static bool IsNotNone(PerTestInfoKind perTestInfoKind);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.dotCover.Workspace.Contract.Reporting.ReportFeatures : object {
    [CompilerGeneratedAttribute]
private PerTestInfoKind <IncludePerTestInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeEnvironmentSpecificInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Detailed>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public PerTestInfoKind IncludePerTestInfo { get; public set; }
    public bool IncludeEnvironmentSpecificInfo { get; public set; }
    public bool Detailed { get; public set; }
    public ReportFeatures(PerTestInfoKind IncludePerTestInfo, bool IncludeEnvironmentSpecificInfo, bool Detailed);
    [CompilerGeneratedAttribute]
protected ReportFeatures(ReportFeatures original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public PerTestInfoKind get_IncludePerTestInfo();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IncludePerTestInfo(PerTestInfoKind value);
    [CompilerGeneratedAttribute]
public bool get_IncludeEnvironmentSpecificInfo();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IncludeEnvironmentSpecificInfo(bool value);
    [CompilerGeneratedAttribute]
public bool get_Detailed();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Detailed(bool value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(ReportFeatures left, ReportFeatures right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(ReportFeatures left, ReportFeatures right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(ReportFeatures other);
    [CompilerGeneratedAttribute]
public virtual ReportFeatures <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(PerTestInfoKind& IncludePerTestInfo, Boolean& IncludeEnvironmentSpecificInfo, Boolean& Detailed);
}
[RdRpcAttribute]
[SnapshotModelComponentInterfaceAttribute]
public interface JetBrains.dotCover.Workspace.Contract.SnapshotCore.ISnapshotLocationProvider {
    public UProperty`1<string> SnapshotLocation { get; }
    public abstract virtual UProperty`1<string> get_SnapshotLocation();
}
[RdRpcAttribute]
[SnapshotModelComponentInterfaceAttribute]
public interface JetBrains.dotCover.Workspace.Contract.SnapshotCore.ISnapshotSaver {
    public UProperty`1<bool> HasUnsavedData { get; }
    public abstract virtual UProperty`1<bool> get_HasUnsavedData();
    public abstract virtual Task SaveSnapshotAsync(string targetFileName, ProgressId progressId);
}
[AttributeUsageAttribute("1024")]
public class JetBrains.dotCover.Workspace.Contract.SnapshotModelComponentInterfaceAttribute : PartAttribute {
}
[RdRpcAttribute]
[WorkspaceModelComponentInterfaceAttribute]
public interface JetBrains.dotCover.Workspace.Contract.SnapshotOperations.IRawSnapshotPostProcessingHelper {
    public abstract virtual Task`1<bool> MergeIsRequired(string indexFileName);
}
[RdRpcAttribute]
[WorkspaceModelComponentInterfaceAttribute]
public interface JetBrains.dotCover.Workspace.Contract.SnapshotOperations.ISnapshotMerger {
    public abstract virtual Task Merge(String[] sourceSnapshots, string targetPath, MergeOptions options, string tempDir, ProgressId progressId);
}
public class JetBrains.dotCover.Workspace.Contract.SnapshotOperations.MergeOptions : object {
    [CompilerGeneratedAttribute]
private MergeType <MergeType>k__BackingField;
    [CompilerGeneratedAttribute]
private MetadataMappingMode <MetadataMappingMode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RemoveSourceSnapshots>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <MergeToSingleFile>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxNumberOfSnapshotsToBeMergedSimultaneously>k__BackingField;
    public MergeType MergeType { get; public set; }
    public MetadataMappingMode MetadataMappingMode { get; public set; }
    public bool RemoveSourceSnapshots { get; public set; }
    public bool MergeToSingleFile { get; public set; }
    public int MaxNumberOfSnapshotsToBeMergedSimultaneously { get; public set; }
    [CompilerGeneratedAttribute]
public MergeType get_MergeType();
    [CompilerGeneratedAttribute]
public void set_MergeType(MergeType value);
    [CompilerGeneratedAttribute]
public MetadataMappingMode get_MetadataMappingMode();
    [CompilerGeneratedAttribute]
public void set_MetadataMappingMode(MetadataMappingMode value);
    [CompilerGeneratedAttribute]
public bool get_RemoveSourceSnapshots();
    [CompilerGeneratedAttribute]
public void set_RemoveSourceSnapshots(bool value);
    [CompilerGeneratedAttribute]
public bool get_MergeToSingleFile();
    [CompilerGeneratedAttribute]
public void set_MergeToSingleFile(bool value);
    [CompilerGeneratedAttribute]
public int get_MaxNumberOfSnapshotsToBeMergedSimultaneously();
    [CompilerGeneratedAttribute]
public void set_MaxNumberOfSnapshotsToBeMergedSimultaneously(int value);
}
public enum JetBrains.dotCover.Workspace.Contract.SnapshotOperations.MergeType : Enum {
    public int value__;
    public static MergeType OrMerge;
    public static MergeType Replace;
}
public enum JetBrains.dotCover.Workspace.Contract.SnapshotOperations.MetadataMappingMode : Enum {
    public int value__;
    public static MetadataMappingMode Mvid;
    public static MetadataMappingMode NameAndVersion;
}
[RdRpcAttribute]
[SnapshotModelComponentInterfaceAttribute]
public interface JetBrains.dotCover.Workspace.Contract.SolutionBasedCoverageTree.ISolutionBasedCoverageTreeBuilder {
    public abstract virtual Task RebuildTree(IEnumerable`1<SolutionFolderNode> solutionFolderNodes, IEnumerable`1<ProjectNode> projectNodes);
    public abstract virtual Task AddOrUpdateSolutionFolderNode(string id, SolutionFolderNode solutionFolderNode);
    public abstract virtual Task AddOrUpdateProjectNode(string id, ProjectNode projectNode);
    public abstract virtual Task RemoveSolutionNode(string id);
    public abstract virtual Task RemoveAllSolutionNodes();
}
[RdRpcAttribute]
[SnapshotModelComponentInterfaceAttribute]
public interface JetBrains.dotCover.Workspace.Contract.SolutionBasedCoverageTree.ISolutionBasedCoverageTreeConfigurator {
    public UProperty`1<bool> SolutionStructureMatchingEnabled { get; }
    public abstract virtual UProperty`1<bool> get_SolutionStructureMatchingEnabled();
}
public class JetBrains.dotCover.Workspace.Contract.SolutionBasedCoverageTree.ProjectNode : SolutionNode {
    [CompilerGeneratedAttribute]
private ProjectOutputAssembly[] <OutputAssemblies>k__BackingField;
    public ProjectOutputAssembly[] OutputAssemblies { get; }
    public ProjectNode(string parentId, string id, string name, ProjectOutputAssembly[] outputAssemblies);
    [CompilerGeneratedAttribute]
public ProjectOutputAssembly[] get_OutputAssemblies();
    public virtual string ToString();
}
public class JetBrains.dotCover.Workspace.Contract.SolutionBasedCoverageTree.ProjectOutputAssembly : object {
    [CompilerGeneratedAttribute]
private TargetFrameworkId <TargetFrameworkId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AssemblyName>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<Guid> <Mvid>k__BackingField;
    public TargetFrameworkId TargetFrameworkId { get; }
    public string AssemblyName { get; }
    public Nullable`1<Guid> Mvid { get; }
    public ProjectOutputAssembly(TargetFrameworkId targetFrameworkId, string assemblyName, Nullable`1<Guid> mvid);
    [CompilerGeneratedAttribute]
public TargetFrameworkId get_TargetFrameworkId();
    [CompilerGeneratedAttribute]
public string get_AssemblyName();
    [CompilerGeneratedAttribute]
public Nullable`1<Guid> get_Mvid();
    public virtual string ToString();
}
public class JetBrains.dotCover.Workspace.Contract.SolutionBasedCoverageTree.SolutionFolderNode : SolutionNode {
    public SolutionFolderNode(string parentId, string id, string name);
}
public abstract class JetBrains.dotCover.Workspace.Contract.SolutionBasedCoverageTree.SolutionNode : object {
    [CompilerGeneratedAttribute]
private string <ParentId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string ParentId { get; }
    public string Id { get; }
    public string Name { get; }
    protected SolutionNode(string parentId, string id, string name);
    [CompilerGeneratedAttribute]
public string get_ParentId();
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public string get_Name();
    public virtual string ToString();
}
[RdRpcAttribute]
[SnapshotModelComponentInterfaceAttribute]
public interface JetBrains.dotCover.Workspace.Contract.SourceCodeMapping.ICoverageNodesSourceCodeInfoProvider {
    public abstract virtual Task`1<SourceCodeInfo> TryGetSourceCodeInfo(CoverageNodeId nodeId);
}
[RdRpcAttribute]
[SnapshotModelComponentInterfaceAttribute]
public interface JetBrains.dotCover.Workspace.Contract.SourceCodeMapping.ISourceCodeToCoverageTreeMapper {
    public abstract virtual Task`1<CoverageNodeId> TryFindCoverageNode(SourceCodeInfo sourceCodeInfo);
}
public class JetBrains.dotCover.Workspace.Contract.SourceCodeMapping.NestedFunctionInfo : object {
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ShortName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Signature>k__BackingField;
    public Nullable`1<int> Index { get; public set; }
    public string ShortName { get; public set; }
    public string Signature { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_Index();
    [CompilerGeneratedAttribute]
public void set_Index(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public string get_ShortName();
    [CompilerGeneratedAttribute]
public void set_ShortName(string value);
    [CompilerGeneratedAttribute]
public string get_Signature();
    [CompilerGeneratedAttribute]
public void set_Signature(string value);
    public sealed virtual bool Equals(NestedFunctionInfo other);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class JetBrains.dotCover.Workspace.Contract.SourceCodeMapping.SourceCodeInfo : object {
    [CompilerGeneratedAttribute]
private string <AssemblyName>k__BackingField;
    [CompilerGeneratedAttribute]
private TargetFrameworkId <TargetFrameworkId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NamespaceName>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <TypeNames>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TypeMemberName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MethodSignature>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ExplicitlyImplementedInterfaceSignature>k__BackingField;
    [CompilerGeneratedAttribute]
private NestedFunctionInfo[] <NestedFunctionsPath>k__BackingField;
    public string AssemblyName { get; public set; }
    public TargetFrameworkId TargetFrameworkId { get; public set; }
    public string NamespaceName { get; public set; }
    public String[] TypeNames { get; public set; }
    public string TypeMemberName { get; public set; }
    public string MethodSignature { get; public set; }
    public string ExplicitlyImplementedInterfaceSignature { get; public set; }
    [CanBeNullAttribute]
public NestedFunctionInfo[] NestedFunctionsPath { get; public set; }
    [CompilerGeneratedAttribute]
public string get_AssemblyName();
    [CompilerGeneratedAttribute]
public void set_AssemblyName(string value);
    [CompilerGeneratedAttribute]
public TargetFrameworkId get_TargetFrameworkId();
    [CompilerGeneratedAttribute]
public void set_TargetFrameworkId(TargetFrameworkId value);
    [CompilerGeneratedAttribute]
public string get_NamespaceName();
    [CompilerGeneratedAttribute]
public void set_NamespaceName(string value);
    [CompilerGeneratedAttribute]
public String[] get_TypeNames();
    [CompilerGeneratedAttribute]
public void set_TypeNames(String[] value);
    [CompilerGeneratedAttribute]
public string get_TypeMemberName();
    [CompilerGeneratedAttribute]
public void set_TypeMemberName(string value);
    [CompilerGeneratedAttribute]
public string get_MethodSignature();
    [CompilerGeneratedAttribute]
public void set_MethodSignature(string value);
    [CompilerGeneratedAttribute]
public string get_ExplicitlyImplementedInterfaceSignature();
    [CompilerGeneratedAttribute]
public void set_ExplicitlyImplementedInterfaceSignature(string value);
    [CompilerGeneratedAttribute]
public NestedFunctionInfo[] get_NestedFunctionsPath();
    [CompilerGeneratedAttribute]
public void set_NestedFunctionsPath(NestedFunctionInfo[] value);
}
public class JetBrains.dotCover.Workspace.Contract.SourceCodeMapping.SourceCodeInfoEqualityComparer : object {
    public static IEqualityComparer`1<SourceCodeInfo> IgnoreTargetFramework;
    public static IEqualityComparer`1<SourceCodeInfo> Full;
    private bool myIgnoreTargetFramework;
    private SourceCodeInfoEqualityComparer(bool ignoreTargetFramework);
    private static SourceCodeInfoEqualityComparer();
    public sealed virtual bool Equals(SourceCodeInfo x, SourceCodeInfo y);
    public sealed virtual int GetHashCode(SourceCodeInfo sci);
}
[RdRpcAttribute]
[WorkspaceModelComponentInterfaceAttribute]
public interface JetBrains.dotCover.Workspace.Contract.UnitTesting.ICumulativeSnapshotUpdater {
    public UProperty`1<bool> IgnoreTargetFrameworksWhenMatchingModules { get; }
    public abstract virtual Task`1<bool> AddDataFromRawSnapshotsAsync(ProgressId progressId, String[] snapshots, string sessionId, IReadOnlyDictionary`2<string, String[]> groupNamesToElementIdsMap, bool mergeModulesInsideRawSnapshots);
    public abstract virtual Task`1<bool> AddDataFromAssembliesAsync(ProgressId progressId, String[] assemblies, CoverageFilterSet coverageFilters, AttributeFilterSet attributeFilters);
    public abstract virtual Task ApplyFiltersAsync(ProgressId progressId, CoverageFilterSet coverageFilters, AttributeFilterSet attributeFilters);
    public abstract virtual Task ClearAsync(ProgressId progressId);
    public abstract virtual Task RemoveSessionDataAsync(ProgressId progressId, string sessionId);
    public abstract virtual Task RemoveElementsDataAsync(ProgressId progressId, string sessionId, String[] elementIds);
    public abstract virtual Task RemoveInvalidSessionsDataAsync(ProgressId progressId, String[] validSessionIds);
    public abstract virtual UProperty`1<bool> get_IgnoreTargetFrameworksWhenMatchingModules();
    public abstract virtual Task WhenIdle();
}
[RdRpcAttribute]
[WorkspaceModelComponentInterfaceAttribute]
public interface JetBrains.dotCover.Workspace.Contract.UnitTesting.IOutdatedTestsProvider {
    public abstract virtual Task`1<IEnumerable`1<UnitTestSessionTestId>> GetOutdatedTestsAsync();
}
[RdRpcAttribute]
[SnapshotModelComponentInterfaceAttribute]
public interface JetBrains.dotCover.Workspace.Contract.UnitTesting.ITestsCoverageDataStatusChecker {
    public USignal`1<Unit> CoverageDataChanged { get; }
    public abstract virtual Task`1<TestsCoverageDataStatus> CheckStatus(string sessionId, String[] elementIds);
    public abstract virtual USignal`1<Unit> get_CoverageDataChanged();
}
[RdRpcAttribute]
[SnapshotModelComponentInterfaceAttribute]
public interface JetBrains.dotCover.Workspace.Contract.UnitTesting.IUnitTestsCoverageTreeConfigurator {
    public abstract virtual Task SetTotalGroupAsActiveAsync();
    public abstract virtual Task SetUnitTestSessionTotalGroupAsActiveAsync(string sessionId);
    public abstract virtual Task SetActiveElementsAsync(string sessionId, String[] elementIds);
}
public class JetBrains.dotCover.Workspace.Contract.UnitTesting.TestsCoverageDataStatus : object {
    [CompilerGeneratedAttribute]
private bool <CoverageDataIsUpToDate>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <ExcludingElementIds>k__BackingField;
    public bool CoverageDataIsUpToDate { get; }
    public String[] ExcludingElementIds { get; }
    public TestsCoverageDataStatus(bool coverageDataIsUpToDate, String[] excludingElementIds);
    [CompilerGeneratedAttribute]
public bool get_CoverageDataIsUpToDate();
    [CompilerGeneratedAttribute]
public String[] get_ExcludingElementIds();
}
[IsReadOnlyAttribute]
public class JetBrains.dotCover.Workspace.Contract.UnitTesting.UnitTestSessionTestId : ValueType {
    [CompilerGeneratedAttribute]
private string <SessionId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ElementId>k__BackingField;
    public string SessionId { get; public set; }
    public string ElementId { get; public set; }
    public UnitTestSessionTestId(string SessionId, string ElementId);
    [CompilerGeneratedAttribute]
public string get_SessionId();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_SessionId(string value);
    [CompilerGeneratedAttribute]
public string get_ElementId();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ElementId(string value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(UnitTestSessionTestId left, UnitTestSessionTestId right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(UnitTestSessionTestId left, UnitTestSessionTestId right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(UnitTestSessionTestId other);
    [CompilerGeneratedAttribute]
public void Deconstruct(String& SessionId, String& ElementId);
}
[RdRpcAttribute]
[WorkspaceModelComponentInterfaceAttribute]
public interface JetBrains.dotCover.Workspace.Contract.WorkspaceCore.IWorkspacePresentableNameManager {
    public UProperty`1<string> PresentableName { get; }
    public abstract virtual UProperty`1<string> get_PresentableName();
}
[RdRpcAttribute]
[WorkspaceModelComponentInterfaceAttribute]
public interface JetBrains.dotCover.Workspace.Contract.WorkspaceCore.IWorkspaceSnapshotManager {
    public UProperty`1<string> OpenedSnapshotId { get; }
    public UProperty`1<SnapshotPersistenceMode> SnapshotPersistenceMode { get; }
    public abstract virtual Task OpenSnapshotAsync(string indexFileName, bool waitForCoverageTreeConstructed, ProgressId progressId);
    public abstract virtual Task OpenOrCreateCumulativeSnapshotAsync(string indexFileName, bool isFinalAttempt, ProgressId progressId);
    public abstract virtual UProperty`1<string> get_OpenedSnapshotId();
    public abstract virtual UProperty`1<SnapshotPersistenceMode> get_SnapshotPersistenceMode();
}
public enum JetBrains.dotCover.Workspace.Contract.WorkspaceCore.SnapshotPersistenceMode : Enum {
    public int value__;
    public static SnapshotPersistenceMode Temporary;
    public static SnapshotPersistenceMode Persistent;
}
[RdRpcAttribute]
[WorkspaceModelComponentInterfaceAttribute]
public interface JetBrains.dotCover.Workspace.Contract.WorkspaceHost.IWorkspaceHostShutdowner {
    public abstract virtual Task Shutdown();
}
[RdRpcAttribute]
[WorkspaceModelComponentInterfaceAttribute]
public interface JetBrains.dotCover.Workspace.Contract.WorkspaceHost.IWorkspaceInitializationAwaiter {
    public abstract virtual Task Wait(int timeoutSeconds);
}
public static class JetBrains.dotCover.Workspace.Contract.WorkspaceHostConstants : object {
    public static string ProductContextArgumentName;
    public static string DebugModeArgumentName;
    public static string LoggingEnabledArgumentName;
    public static string LoggingLevelArgumentName;
    public static string PortArgumentName;
    public static string PARENT_PROCESS_PID_ENV_VARIABLE;
}
[AttributeUsageAttribute("1024")]
public class JetBrains.dotCover.Workspace.Contract.WorkspaceModelComponentInterfaceAttribute : PartAttribute {
}
public enum JetBrains.dotCover.Workspace.Contract.WorkspaceProductContext : Enum {
    public int value__;
    public static WorkspaceProductContext Unknown;
    public static WorkspaceProductContext ConsoleRunner;
    public static WorkspaceProductContext StandaloneRunner;
    public static WorkspaceProductContext Ide;
}
[ZoneDefinitionAttribute]
public interface JetBrains.dotCover.Workspace.IDotCoverWorkspaceImplZone {
}
public interface JetBrains.dotCover.Workspace.IExternalWorkspace {
    public IProperty`1<bool> ExternalProcessAlive { get; }
    public abstract virtual IProperty`1<bool> get_ExternalProcessAlive();
}
[RdExtAttribute]
[SnapshotModelComponentAttribute]
internal class JetBrains.dotCover.Workspace.Impl.CoverageAnalysis.Model.CoverageDetailsProvider : RdExtComponentBase {
    private Lifetime myLifetime;
    private ICoverageTree myCoverageTree;
    private IRealtimeRequestsProcessor myRealtimeRequestsProcessor;
    private ILogger myLogger;
    [CompilerGeneratedAttribute]
private USignal`1<Unit> <DetailsChanged>k__BackingField;
    public USignal`1<Unit> DetailsChanged { get; }
    public CoverageDetailsProvider(Lifetime lifetime, IRdExtComponentsInitializer initializer, ICoverageTree coverageTree, IRealtimeRequestsProcessor realtimeRequestsProcessor, ILoggerProvider loggerProvider);
    public sealed virtual Task`1<CoverageDetails> GetRootDetails();
    public sealed virtual Task`1<CoverageDetails[]> GetChildDetails(CoverageNodeId nodeId);
    public sealed virtual Task`1<CoverageDetails> GetNodeDetails(CoverageNodeId nodeId);
    [CompilerGeneratedAttribute]
public sealed virtual USignal`1<Unit> get_DetailsChanged();
    [CompilerGeneratedAttribute]
private void <.ctor>b__4_0(Task task);
    [CompilerGeneratedAttribute]
private void <.ctor>b__4_1(Task _);
    [CompilerGeneratedAttribute]
private CoverageDetails <GetRootDetails>b__5_0();
}
[ExtensionAttribute]
internal static class JetBrains.dotCover.Workspace.Impl.CoverageAnalysis.Model.CoverageDetailsProviderHelper : object {
    public static CoverageDetails EmptyDetails;
    private static CoverageDetailsProviderHelper();
    public static CoverageDetails GetNodeDetails(ICoverageTreeBase coverageTree, CoverageNodeId nodeId);
    public static CoverageDetails[] GetChildDetails(ICoverageTreeBase coverageTree, CoverageNodeId nodeId);
    [ExtensionAttribute]
private static CoverageDetails Convert(ICoverageNodeDetails details);
}
[SnapshotModelComponentAttribute]
internal class JetBrains.dotCover.Workspace.Impl.CoverageAnalysis.Model.CoveredMethodsInfoBuilder : object {
    private ILogger myLogger;
    private IMetadataBasedCoverageTreeBase myMetadataBasedCoverageTree;
    private IMethodRangeSection myMethodRangeSection;
    private IStatementDataSection myStatementDataSection;
    public CoveredMethodsInfoBuilder(ICoverageSnapshot coverageSnapshot, IModifiableMetadataBasedCoverageTree metadataBasedCoverageTree);
    public sealed virtual void BuildInfo(IReadOnlyCollection`1<ISnapshotSectionCollection> groups, Nullable`1<SectionIndex`1<IMetadataSection>> metadataIndex, IReadOnlySet`1<MetadataId> methods, CreateCoveredMethodInfo`1<TInfo> createInfo, Action`1<TInfo> markInfoAsOutdated, bool coverageDetailsRequired, Dictionary`2<MetadataId, TInfo> result, Func`1<bool> checkForInterrupt);
    [CompilerGeneratedAttribute]
private void <BuildInfo>b__5_0(MetadataId metadataId, int coveredStatementCount, bool isOutdated, SectionOffset`1<IStatementCoverageDetailsSection> detailsOffset, IndexIteratorArgs`1& args);
    [CompilerGeneratedAttribute]
internal static IStatementCoverageDetailsProvider <BuildInfo>g__GetFastestDetailsProvider|5_1(Nullable`1<SectionIndex`1<IMetadataSection>> mi, IStatementCoverageDetailsProvider ds);
}
internal class JetBrains.dotCover.Workspace.Impl.CoverageAnalysis.Model.Interface.CreateCoveredMethodInfo`1 : MulticastDelegate {
    public CreateCoveredMethodInfo`1(object object, IntPtr method);
    public virtual TInfo Invoke(CoverageNodeId nodeId, long coveredStatementsCount, long totalStatementsCount, bool isOutdated, IStatementDetails coverageDetails);
    public virtual IAsyncResult BeginInvoke(CoverageNodeId nodeId, long coveredStatementsCount, long totalStatementsCount, bool isOutdated, IStatementDetails coverageDetails, AsyncCallback callback, object object);
    public virtual TInfo EndInvoke(IAsyncResult result);
}
[SnapshotModelComponentAttribute]
public class JetBrains.dotCover.Workspace.Impl.CoverageAnalysis.Model.Interface.DefaultSnapshotActiveGroupsProvider : object {
    private ICoverageSnapshot mySnapshot;
    public ISnapshotSectionCollection[] ActiveGroups { get; }
    public DefaultSnapshotActiveGroupsProvider(ICoverageSnapshot snapshot);
    public virtual ISnapshotSectionCollection[] get_ActiveGroups();
}
internal interface JetBrains.dotCover.Workspace.Impl.CoverageAnalysis.Model.Interface.ICoveredMethodsInfoBuilder {
    public abstract virtual void BuildInfo(IReadOnlyCollection`1<ISnapshotSectionCollection> groups, Nullable`1<SectionIndex`1<IMetadataSection>> metadataIndex, IReadOnlySet`1<MetadataId> methods, CreateCoveredMethodInfo`1<TInfo> createInfo, Action`1<TInfo> markInfoAsOutdated, bool coverageDetailsRequired, Dictionary`2<MetadataId, TInfo> result, Func`1<bool> checkForInterrupt);
}
public interface JetBrains.dotCover.Workspace.Impl.CoverageAnalysis.Model.Interface.ISnapshotActiveGroupsProvider {
    public ISnapshotSectionCollection[] ActiveGroups { get; }
    public abstract virtual ISnapshotSectionCollection[] get_ActiveGroups();
}
public class JetBrains.dotCover.Workspace.Impl.CoverageTree.Model.Comparers.CoverageDetailsComparer : object {
    private ICoverageTreeBase myCoverageTree;
    private bool myIsAscending;
    public CoverageDetailsComparer(ICoverageTreeBase coverageTree, bool isAscending);
    public sealed virtual int Compare(CoverageNodeId x, CoverageNodeId y);
}
public class JetBrains.dotCover.Workspace.Impl.CoverageTree.Model.Comparers.PresentableNameComparer : object {
    private ICoverageTreeBase myCoverageTree;
    private bool myUseFullNames;
    private bool myIsAscending;
    public PresentableNameComparer(ICoverageTreeBase coverageTree, bool useFullNames, bool isAscending);
    public sealed virtual int Compare(CoverageNodeId x, CoverageNodeId y);
    private static int CompareTypes(CoverageNodeKind x, CoverageNodeKind y);
}
public class JetBrains.dotCover.Workspace.Impl.CoverageTree.Model.Comparers.UncoveredStatementsNumberComparer : object {
    private ICoverageTreeBase myCoverageTree;
    private bool myIsAscending;
    public UncoveredStatementsNumberComparer(ICoverageTreeBase coverageTree, bool isAscending);
    public sealed virtual int Compare(CoverageNodeId x, CoverageNodeId y);
}
[SnapshotModelComponentAttribute]
[ThreadSafeAttribute]
internal class JetBrains.dotCover.Workspace.Impl.CoverageTree.Model.CompoundCoverageTree : CoverageTreeWrapper {
    public CompoundCoverageTree(Lifetime lifetime, ISolutionBasedCoverageTree solutionBasedCoverageTree, IEnumerable`1<IPrioritizedCoverageTreeWrapper> coverageTreeWrappers, IContainerInitializer containerInitializer, ILoggerProvider loggerProvider);
}
[SnapshotModelComponentAttribute]
[ThreadSafeAttribute]
internal class JetBrains.dotCover.Workspace.Impl.CoverageTree.Model.CompoundMetadataBasedCoverageTree : CoverageTreeWrapper {
    private IMetadataBasedCoverageTreeBase myTree;
    [CompilerGeneratedAttribute]
private ISignal`1<Pair`2<CoverageNodeId, Task>> <AssemblyModificationStarted>k__BackingField;
    public int AssemblyNodesCount { get; }
    public ISignal`1<Pair`2<CoverageNodeId, Task>> AssemblyModificationStarted { get; }
    public CompoundMetadataBasedCoverageTree(Lifetime lifetime, IModifiableMetadataBasedCoverageTree modifiableMetadataBasedCoverageTree, IEnumerable`1<IPrioritizedMetadataBasedCoverageTreeWrapper> metadataBasedCoverageTreeWrappers, IContainerInitializer containerInitializer, ILoggerProvider loggerProvider);
    public sealed virtual int get_AssemblyNodesCount();
    public sealed virtual CoverageNodeId[] GetAllAssemblyNodes();
    public sealed virtual CoverageNodeId TryGetAssemblyNodeId(Nullable`1<Guid> mvid, string assemblyName, TargetFrameworkId targetFrameworkId);
    public sealed virtual CoverageNodeId TryGetMetadataEntityNodeId(MetadataId metadataId, bool preferOwnCoverageNode, Boolean& isOwnCoverageNode);
    [CompilerGeneratedAttribute]
public sealed virtual ISignal`1<Pair`2<CoverageNodeId, Task>> get_AssemblyModificationStarted();
}
[WorkspaceModelComponentAttribute]
internal class JetBrains.dotCover.Workspace.Impl.CoverageTree.Model.CoverageTreeBuildConfigurator : object {
    private WorkspaceProductContext myProductContext;
    [CompilerGeneratedAttribute]
private bool <SuppressBuild>k__BackingField;
    [CompilerGeneratedAttribute]
private TypeMembersProcessingMode <TypeMembersProcessingMode>k__BackingField;
    [CompilerGeneratedAttribute]
private MetadataNodesPresentationSettings <NodesPresentationSettings>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PreBuildFullNodeNames>k__BackingField;
    public bool SuppressBuild { get; public set; }
    public UInt32 MaxParallelThreads { get; }
    public TypeMembersProcessingMode TypeMembersProcessingMode { get; public set; }
    public MetadataNodesPresentationSettings NodesPresentationSettings { get; public set; }
    public bool PreBuildFullNodeNames { get; public set; }
    public CoverageTreeBuildConfigurator(WorkspaceProductContext productContext);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_SuppressBuild();
    [CompilerGeneratedAttribute]
public sealed virtual void set_SuppressBuild(bool value);
    public sealed virtual UInt32 get_MaxParallelThreads();
    [CompilerGeneratedAttribute]
public sealed virtual TypeMembersProcessingMode get_TypeMembersProcessingMode();
    [CompilerGeneratedAttribute]
public sealed virtual void set_TypeMembersProcessingMode(TypeMembersProcessingMode value);
    [CompilerGeneratedAttribute]
public sealed virtual MetadataNodesPresentationSettings get_NodesPresentationSettings();
    [CompilerGeneratedAttribute]
public sealed virtual void set_NodesPresentationSettings(MetadataNodesPresentationSettings value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_PreBuildFullNodeNames();
    [CompilerGeneratedAttribute]
public sealed virtual void set_PreBuildFullNodeNames(bool value);
}
[RdExtAttribute]
[SnapshotModelComponentAttribute]
internal class JetBrains.dotCover.Workspace.Impl.CoverageTree.Model.CoverageTreeStructureProvider : RdExtComponentBase {
    private ILogger myLogger;
    private Lifetime myLifetime;
    private ICoverageTree myCoverageTree;
    private IRealtimeRequestsProcessor myRealtimeRequestsProcessor;
    [CompilerGeneratedAttribute]
private USignal`1<Unit> <StructureChanged>k__BackingField;
    public USignal`1<Unit> StructureChanged { get; }
    public CoverageTreeStructureProvider(Lifetime lifetime, IRdExtComponentsInitializer initializer, ICoverageTree coverageTree, IRealtimeRequestsProcessor realtimeRequestsProcessor, ILoggerProvider loggerProvider);
    public sealed virtual Task`1<NodeInfo> GetRootNodeInfo();
    public sealed virtual Task`1<NodeInfo> GetNodeInfo(CoverageNodeId nodeId);
    public sealed virtual Task`1<NodeInfo[]> GetChildInfos(CoverageNodeId nodeId);
    public sealed virtual Task`1<CoverageNodeId[]> GetParentIds(CoverageNodeId nodeId);
    public sealed virtual Task`1<int> GetEstimatedNodesCount();
    [CompilerGeneratedAttribute]
public sealed virtual USignal`1<Unit> get_StructureChanged();
    public sealed virtual Task WhenCurrentModificationFinished();
    private NodeInfo GetNodeInfoInternal(CoverageNodeId nodeId, ICoverageNodeChildrenEnumerator`1<object> childrenEnumerator);
    [CompilerGeneratedAttribute]
private void <.ctor>b__4_0(Task task);
    [CompilerGeneratedAttribute]
private void <.ctor>b__4_1(Task _);
    [CompilerGeneratedAttribute]
private NodeInfo <GetRootNodeInfo>b__5_0();
    [CompilerGeneratedAttribute]
private int <GetEstimatedNodesCount>b__9_0();
}
internal abstract class JetBrains.dotCover.Workspace.Impl.CoverageTree.Model.CoverageTreeWrapper : object {
    private Lifetime myLifetime;
    protected ICoverageTreeBase BaseTree;
    [CompilerGeneratedAttribute]
private ISignal`1<Task> <StructureModificationStarted>k__BackingField;
    [CompilerGeneratedAttribute]
private ISignal`1<Task> <DetailsModificationStarted>k__BackingField;
    public int EstimatedNodesNumber { get; }
    public ISignal`1<Task> StructureModificationStarted { get; }
    public ISignal`1<Task> DetailsModificationStarted { get; }
    protected CoverageTreeWrapper(Lifetime lifetime, ILoggerProvider loggerProvider);
    public virtual void SetBaseTree(ICoverageTreeBase baseTree);
    protected virtual Task OnBaseStructureModificationStarted(Task modificationTask);
    protected virtual Task OnBaseDetailsModificationStarted(Task modificationTask);
    public virtual CoverageNodeId GetRootNodeId();
    public virtual ICoverageNodeChildrenEnumerator`1<T> GetChildrenEnumerator(CoverageNodeChildrenVisitor`1<T> nodeVisitor);
    public virtual ICoverageNodeParentsEnumerator`1<T> GetParentsEnumerator(CoverageNodeParentsVisitor`1<T> nodeVisitor);
    public virtual bool ContainsNode(CoverageNodeId nodeId);
    public virtual ICoverageNodeInfo TryGetNodeInfo(CoverageNodeId nodeId);
    public virtual ICoverageNodeDetails TryGetNodeDetails(CoverageNodeId nodeId);
    public virtual string TryGetShortPresentableName(CoverageNodeId nodeId);
    public virtual string TryGetFullPresentableName(CoverageNodeId nodeId);
    public virtual string TryGetCustomPresentableName(CoverageNodeId nodeId, MetadataNodesPresentationSettings presentationSettings);
    public virtual string TryGetAnnotation(CoverageNodeId nodeId);
    public virtual bool TryPutNodeData(CoverageNodeId nodeId, CoverageNodeDataKey`1<T> key, T value);
    public virtual T TryGetNodeData(CoverageNodeId nodeId, CoverageNodeDataKey`1<T> key);
    public virtual int get_EstimatedNodesNumber();
    [CompilerGeneratedAttribute]
public sealed virtual ISignal`1<Task> get_StructureModificationStarted();
    [CompilerGeneratedAttribute]
public sealed virtual ISignal`1<Task> get_DetailsModificationStarted();
    public virtual Task WhenCurrentModificationFinished();
    [CompilerGeneratedAttribute]
private void <SetBaseTree>b__3_0(Task task);
    [CompilerGeneratedAttribute]
private void <SetBaseTree>b__3_1(Task task);
}
public interface JetBrains.dotCover.Workspace.Impl.CoverageTree.Model.IMetadataNodeNamesProvider {
    public abstract virtual string GetShortName(ILowLevelMetadata metadata, MetadataToken metadataToken, CoverageNodeKind kind, MetadataNodesPresentationSettings settings);
    public abstract virtual string GetFullNameSuffix(ILowLevelMetadata metadata, MetadataToken metadataToken, CoverageNodeKind kind, MetadataNodesPresentationSettings settings);
    public abstract virtual string GetTypeShortName(TypeDefProperties typeDefProperties, MetadataNodesPresentationSettings settings);
    public abstract virtual string GetMethodShortName(ILowLevelMetadata metadata, MethodProperties methodProperties, CoverageNodeKind kind, MetadataNodesPresentationSettings settings);
    public abstract virtual string GetPropertyShortName(PropertyProperties propertyProperties, CoverageNodeKind kind, MetadataNodesPresentationSettings settings);
    public abstract virtual string GetEventShortName(EventProperties eventProperties, MetadataNodesPresentationSettings settings);
}
public interface JetBrains.dotCover.Workspace.Impl.CoverageTree.Model.IModifiableCoverageTree {
    public abstract virtual void OnNodeCreated(CoverageNode node);
    public abstract virtual void OnNodeRemoved(CoverageNode node);
}
public interface JetBrains.dotCover.Workspace.Impl.CoverageTree.Model.IModifiableMetadataBasedCoverageTree {
    public abstract virtual CoverageNode TryGetAssemblyNode(CoverageNodeId assemblyNodeId);
    public abstract virtual void OnAssemblyModificationStarted(CoverageNodeId assemblyNodeId, Task modificationTask);
    public abstract virtual void OnModificationStarted(Task modificationTask);
}
internal interface JetBrains.dotCover.Workspace.Impl.CoverageTree.Model.INotHiddenStatementsCountProvider {
    public abstract virtual bool TryGetStatementsCount(MetadataId metadataId, Int32& count);
}
public class JetBrains.dotCover.Workspace.Impl.CoverageTree.Model.Interface.CoverageNodeChildrenVisitor`1 : MulticastDelegate {
    public CoverageNodeChildrenVisitor`1(object object, IntPtr method);
    public virtual bool Invoke(CoverageNodeId parentNodeId, CoverageNodeId nodeId, T arg, Boolean& stopEnumeration);
    public virtual IAsyncResult BeginInvoke(CoverageNodeId parentNodeId, CoverageNodeId nodeId, T arg, Boolean& stopEnumeration, AsyncCallback callback, object object);
    public virtual bool EndInvoke(Boolean& stopEnumeration, IAsyncResult result);
}
public class JetBrains.dotCover.Workspace.Impl.CoverageTree.Model.Interface.CoverageNodeParentsVisitor`1 : MulticastDelegate {
    public CoverageNodeParentsVisitor`1(object object, IntPtr method);
    public virtual void Invoke(CoverageNodeId nodeId, T arg, Boolean& stopEnumeration);
    public virtual IAsyncResult BeginInvoke(CoverageNodeId nodeId, T arg, Boolean& stopEnumeration, AsyncCallback callback, object object);
    public virtual void EndInvoke(Boolean& stopEnumeration, IAsyncResult result);
}
[ExtensionAttribute]
public static class JetBrains.dotCover.Workspace.Impl.CoverageTree.Model.Interface.CoverageTreeExtensions : object {
    [ExtensionAttribute]
public static ICoverageNodeChildrenEnumerator`1<T> GetSimpleChildrenEnumerator(ICoverageTreeBase coverageTree, SimpleCoverageNodeChildrenVisitor`1<T> nodeVisitor);
    [ExtensionAttribute]
public static ICoverageNodeChildrenEnumerator`1<T> GetRecursiveChildrenEnumerator(ICoverageTreeBase coverageTree, RecursiveCoverageNodeChildrenVisitor`1<T> nodeVisitor);
    [ExtensionAttribute]
public static ICoverageNodeChildrenEnumerator`1<T> GetOrderedChildrenEnumerator(ICoverageTreeBase coverageTree, CoverageNodeChildrenVisitor`1<T> nodeVisitor, Comparison`1<CoverageNodeId> compare);
    [ExtensionAttribute]
public static ICoverageNodeChildrenEnumerator`1<T> GetRecursiveOrderedChildrenEnumerator(ICoverageTreeBase coverageTree, RecursiveCoverageNodeChildrenVisitor`1<T> nodeVisitor, Comparison`1<CoverageNodeId> compare);
    [ExtensionAttribute]
public static void PreOrderDfs(ICoverageTreeBase coverageTree, PreOrderDfsVisitor nodeVisitor);
    [ExtensionAttribute]
public static void PostOrderDfs(ICoverageTreeBase coverageTree, T arg, PostOrderDfsVisitor`1<T> nodeVisitor);
    [ExtensionAttribute]
public static void PostOrderDfs(ICoverageTreeBase coverageTree, CoverageNodeId rootNodeId, T arg, PostOrderDfsVisitor`1<T> nodeVisitor);
    private static void PostOrderDfsRec(CoverageNodeId parentId, CoverageNodeId nodeId, T arg, PostOrderDfsVisitor`1<T> nodeVisitor, ICoverageNodeChildrenEnumerator`1<T> childrenEnumerator);
    [ExtensionAttribute]
public static void PostOrderDfs(ICoverageTreeBase coverageTree, PostOrderDfsVisitor nodeVisitor);
    [ExtensionAttribute]
public static IReadOnlyList`1<CoverageNodeId> GetAllChildren(ICoverageTreeBase coverageTree, CoverageNodeId nodeId);
    [ExtensionAttribute]
public static bool HasChildren(ICoverageTreeBase coverageTree, CoverageNodeId nodeId);
    [ExtensionAttribute]
public static IReadOnlyList`1<CoverageNodeId> GetAllParents(ICoverageTreeBase coverageTree, CoverageNodeId nodeId);
    [ExtensionAttribute]
public static Nullable`1<MetadataId> TryGetNodeMetadataId(ICoverageTreeBase coverageTree, CoverageNodeId nodeId);
    [ExtensionAttribute]
public static Nullable`1<SectionIndex`1<IMetadataSection>> TryGetAssemblyNodeMetadataIndex(ICoverageTreeBase coverageTree, CoverageNodeId nodeId);
}
public interface JetBrains.dotCover.Workspace.Impl.CoverageTree.Model.Interface.ICoverageNodeChildrenEnumerator`1 {
    public abstract virtual void EnumerateChildren(CoverageNodeId nodeId, T arg, Boolean& hasSuccessfullyProcessedChildren);
}
public interface JetBrains.dotCover.Workspace.Impl.CoverageTree.Model.Interface.ICoverageNodeParentsEnumerator`1 {
    public abstract virtual void EnumerateParents(CoverageNodeId nodeId, T arg);
}
public interface JetBrains.dotCover.Workspace.Impl.CoverageTree.Model.Interface.ICoverageTree {
}
public interface JetBrains.dotCover.Workspace.Impl.CoverageTree.Model.Interface.ICoverageTreeBase {
    public int EstimatedNodesNumber { get; }
    public ISignal`1<Task> StructureModificationStarted { get; }
    public ISignal`1<Task> DetailsModificationStarted { get; }
    public abstract virtual CoverageNodeId GetRootNodeId();
    public abstract virtual ICoverageNodeChildrenEnumerator`1<T> GetChildrenEnumerator(CoverageNodeChildrenVisitor`1<T> nodeVisitor);
    public abstract virtual ICoverageNodeParentsEnumerator`1<T> GetParentsEnumerator(CoverageNodeParentsVisitor`1<T> nodeVisitor);
    public abstract virtual bool ContainsNode(CoverageNodeId nodeId);
    [CanBeNullAttribute]
public abstract virtual ICoverageNodeInfo TryGetNodeInfo(CoverageNodeId nodeId);
    [CanBeNullAttribute]
public abstract virtual ICoverageNodeDetails TryGetNodeDetails(CoverageNodeId nodeId);
    [CanBeNullAttribute]
public abstract virtual string TryGetShortPresentableName(CoverageNodeId nodeId);
    [CanBeNullAttribute]
public abstract virtual string TryGetFullPresentableName(CoverageNodeId nodeId);
    [CanBeNullAttribute]
public abstract virtual string TryGetCustomPresentableName(CoverageNodeId nodeId, MetadataNodesPresentationSettings presentationSettings);
    [CanBeNullAttribute]
public abstract virtual string TryGetAnnotation(CoverageNodeId nodeId);
    public abstract virtual bool TryPutNodeData(CoverageNodeId nodeId, CoverageNodeDataKey`1<T> key, T value);
    [CanBeNullAttribute]
public abstract virtual T TryGetNodeData(CoverageNodeId nodeId, CoverageNodeDataKey`1<T> key);
    public abstract virtual int get_EstimatedNodesNumber();
    public abstract virtual ISignal`1<Task> get_StructureModificationStarted();
    public abstract virtual ISignal`1<Task> get_DetailsModificationStarted();
    public abstract virtual Task WhenCurrentModificationFinished();
}
public interface JetBrains.dotCover.Workspace.Impl.CoverageTree.Model.Interface.ICoverageTreeBuildConfigurator {
    public bool SuppressBuild { get; public set; }
    public UInt32 MaxParallelThreads { get; }
    public TypeMembersProcessingMode TypeMembersProcessingMode { get; public set; }
    public MetadataNodesPresentationSettings NodesPresentationSettings { get; public set; }
    public bool PreBuildFullNodeNames { get; public set; }
    public abstract virtual bool get_SuppressBuild();
    public abstract virtual void set_SuppressBuild(bool value);
    public abstract virtual UInt32 get_MaxParallelThreads();
    public abstract virtual TypeMembersProcessingMode get_TypeMembersProcessingMode();
    public abstract virtual void set_TypeMembersProcessingMode(TypeMembersProcessingMode value);
    public abstract virtual MetadataNodesPresentationSettings get_NodesPresentationSettings();
    public abstract virtual void set_NodesPresentationSettings(MetadataNodesPresentationSettings value);
    public abstract virtual bool get_PreBuildFullNodeNames();
    public abstract virtual void set_PreBuildFullNodeNames(bool value);
}
public interface JetBrains.dotCover.Workspace.Impl.CoverageTree.Model.Interface.IMetadataBasedCoverageTree {
}
public interface JetBrains.dotCover.Workspace.Impl.CoverageTree.Model.Interface.IMetadataBasedCoverageTreeBase {
    public int AssemblyNodesCount { get; }
    public ISignal`1<Pair`2<CoverageNodeId, Task>> AssemblyModificationStarted { get; }
    public abstract virtual int get_AssemblyNodesCount();
    public abstract virtual CoverageNodeId[] GetAllAssemblyNodes();
    public abstract virtual CoverageNodeId TryGetAssemblyNodeId(Nullable`1<Guid> mvid, string assemblyName, TargetFrameworkId targetFrameworkId);
    public abstract virtual CoverageNodeId TryGetMetadataEntityNodeId(MetadataId metadataId, bool preferOwnCoverageNode, Boolean& isOwnCoverageNode);
    public abstract virtual ISignal`1<Pair`2<CoverageNodeId, Task>> get_AssemblyModificationStarted();
}
public interface JetBrains.dotCover.Workspace.Impl.CoverageTree.Model.Interface.IPrioritizedCoverageTreeWrapper {
    public int Priority { get; }
    public abstract virtual int get_Priority();
    public abstract virtual void SetBaseTree(ICoverageTreeBase baseTree);
}
public interface JetBrains.dotCover.Workspace.Impl.CoverageTree.Model.Interface.IPrioritizedMetadataBasedCoverageTreeWrapper {
    public int Priority { get; }
    public abstract virtual int get_Priority();
    public abstract virtual void SetBaseTree(IMetadataBasedCoverageTreeBase baseTree);
}
public class JetBrains.dotCover.Workspace.Impl.CoverageTree.Model.Interface.MetadataNodesPresentationSettings : object {
    public static MetadataNodesPresentationSettings Default;
    [CompilerGeneratedAttribute]
private CodeLanguage <Language>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseFullyQualifiedTypeNamesInSignature>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeReturnType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DisplayNamesForSpecialNodeKinds>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeParameterNames>k__BackingField;
    public CodeLanguage Language { get; }
    public bool UseFullyQualifiedTypeNamesInSignature { get; }
    public bool IncludeReturnType { get; }
    public bool DisplayNamesForSpecialNodeKinds { get; }
    public bool IncludeParameterNames { get; }
    public MetadataNodesPresentationSettings(CodeLanguage language, bool useFullyQualifiedTypeNamesInSignature, bool includeReturnType, bool displayNamesForSpecialNodeKinds, bool includeParameterNames);
    private static MetadataNodesPresentationSettings();
    [CompilerGeneratedAttribute]
public CodeLanguage get_Language();
    [CompilerGeneratedAttribute]
public bool get_UseFullyQualifiedTypeNamesInSignature();
    [CompilerGeneratedAttribute]
public bool get_IncludeReturnType();
    [CompilerGeneratedAttribute]
public bool get_DisplayNamesForSpecialNodeKinds();
    [CompilerGeneratedAttribute]
public bool get_IncludeParameterNames();
    public sealed virtual bool Equals(MetadataNodesPresentationSettings other);
    public virtual int GetHashCode();
}
public interface JetBrains.dotCover.Workspace.Impl.CoverageTree.Model.Interface.MetadataTreeBuilder.ICustomMetadataTreeBuilder {
    public abstract virtual Task`1<ICoverageTreeBase> BuildTreeAsync(Lifetime lifetime, Predicate`1<MetadataId> includeMetadataNode, MetadataNodesPresentationSettings nodesPresentationSettings, TypeMembersProcessingMode typeMembersProcessingMode, UInt32 maxParallelThreads, IProgressIndicator progress);
}
public interface JetBrains.dotCover.Workspace.Impl.CoverageTree.Model.Interface.MetadataTreeBuilder.IMetadataNodesDataConstructor {
    public abstract virtual void PutNodeData(ICoverageNodeDataHolder dataHolder, ILowLevelMetadata metadata, MetadataToken token, CoverageNodeKind nodeKind, ICoverageNodeDataHolder parentDataHolder);
}
public class JetBrains.dotCover.Workspace.Impl.CoverageTree.Model.Interface.Nodes.CoverageNodeDataKey`1 : object {
    private string myName;
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    public int Index { get; }
    private CoverageNodeDataKey`1(string name);
    public static CoverageNodeDataKey`1<T> CreateKey(string name);
    [CompilerGeneratedAttribute]
public int get_Index();
    public virtual string ToString();
}
[ExtensionAttribute]
public static class JetBrains.dotCover.Workspace.Impl.CoverageTree.Model.Interface.Nodes.CoverageNodeDetailsExtensions : object {
    [ExtensionAttribute]
public static int GetCoveragePercent(ICoverageNodeDetails details);
}
public interface JetBrains.dotCover.Workspace.Impl.CoverageTree.Model.Interface.Nodes.ICoverageNodeDataHolder {
    [CanBeNullAttribute]
public abstract virtual T GetData(CoverageNodeDataKey`1<T> key);
    public abstract virtual void PutData(CoverageNodeDataKey`1<T> key, T value);
    public abstract virtual void ClearData();
}
public interface JetBrains.dotCover.Workspace.Impl.CoverageTree.Model.Interface.Nodes.ICoverageNodeDetails {
    public long CoveredStatements { get; }
    public long TotalStatements { get; }
    public bool IsOutdated { get; }
    public abstract virtual long get_CoveredStatements();
    public abstract virtual long get_TotalStatements();
    public abstract virtual bool get_IsOutdated();
}
public interface JetBrains.dotCover.Workspace.Impl.CoverageTree.Model.Interface.Nodes.ICoverageNodeIdFactory {
    public abstract virtual CoverageNodeId GetNextId();
    public abstract virtual void ReleaseId(CoverageNodeId id);
}
public interface JetBrains.dotCover.Workspace.Impl.CoverageTree.Model.Interface.Nodes.ICoverageNodeInfo {
    public CoverageNodeKind Kind { get; }
    public CoverageNodeModifier Modifier { get; }
    public abstract virtual CoverageNodeKind get_Kind();
    public abstract virtual CoverageNodeModifier get_Modifier();
}
public static class JetBrains.dotCover.Workspace.Impl.CoverageTree.Model.Interface.Nodes.MaxKnownKeyValueHolder : object {
    public static int Value;
    private static MaxKnownKeyValueHolder();
}
public class JetBrains.dotCover.Workspace.Impl.CoverageTree.Model.Interface.RecursiveCoverageNodeChildrenVisitor`1 : MulticastDelegate {
    public RecursiveCoverageNodeChildrenVisitor`1(object object, IntPtr method);
    public virtual bool Invoke(CoverageNodeId parentId, CoverageNodeId nodeId, T arg, ICoverageNodeChildrenEnumerator`1<T> recursiveChildrenEnumerator, Boolean& stopEnumeration);
    public virtual IAsyncResult BeginInvoke(CoverageNodeId parentId, CoverageNodeId nodeId, T arg, ICoverageNodeChildrenEnumerator`1<T> recursiveChildrenEnumerator, Boolean& stopEnumeration, AsyncCallback callback, object object);
    public virtual bool EndInvoke(Boolean& stopEnumeration, IAsyncResult result);
}
public class JetBrains.dotCover.Workspace.Impl.CoverageTree.Model.Interface.SimpleCoverageNodeChildrenVisitor`1 : MulticastDelegate {
    public SimpleCoverageNodeChildrenVisitor`1(object object, IntPtr method);
    public virtual void Invoke(CoverageNodeId parentId, CoverageNodeId nodeId, T arg);
    public virtual IAsyncResult BeginInvoke(CoverageNodeId parentId, CoverageNodeId nodeId, T arg, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum JetBrains.dotCover.Workspace.Impl.CoverageTree.Model.Interface.TypeMembersProcessingMode : Enum {
    public int value__;
    public static TypeMembersProcessingMode None;
    public static TypeMembersProcessingMode Properties;
    public static TypeMembersProcessingMode Full;
}
[SnapshotModelComponentAttribute]
[ThreadSafeAttribute]
internal class JetBrains.dotCover.Workspace.Impl.CoverageTree.Model.MetadataBasedCoverageTree : object {
    internal static CoverageNodeDataKey`1<string> FullNameSuffixKey;
    private static int MaxTasksInParallel;
    private ILogger myLogger;
    private ILowLevelMetadataProvider myLowLevelMetadataProvider;
    private IMetadataNodeNamesProvider myMetadataNodeNamesProvider;
    private INotHiddenStatementsCountProvider myNotHiddenStatementsCountProvider;
    private IThreading myThreading;
    private MetadataNodesPresentationSettings myNodesPresentationSettings;
    private CoverageNodeId myRootNodeId;
    private CoverageNodeValue myRootNodeInfo;
    private IMetadataSection myMetadataSection;
    private IStatementCoverageIndexSection myTotalStatementCoverageIndexSection;
    private ConcurrentDictionary`2<CoverageNodeId, CoverageNode> myNodes;
    private ConcurrentDictionary`2<MetadataId, CoverageNode> myMetadataEntityNodes;
    private ConcurrentDictionary`2<MetadataId, CoverageNode> myOwnCoverageNodes;
    private ConcurrentDictionary`2<SectionIndex`1<IMetadataSection>, CoverageNode> myAssemblyNodesByMetadataIndex;
    private ConcurrentDictionary`2<Guid, CoverageNode> myAssemblyNodesByMvid;
    private ConcurrentDictionary`2<string, ConcurrentDictionary`2<TargetFrameworkId, CoverageNode>> myAssemblyNodesByNameAndTargetFramework;
    private Dictionary`2<CoverageNodeId, CancellationTokenSource> myUpdateAssemblyCoverageCancellationTokenSources;
    private ConcurrentDictionary`2<CoverageNodeId, Task> myUpdateAssemblyCoverageTasks;
    private TaskGroup myTaskGroup;
    [CompilerGeneratedAttribute]
private ISignal`1<Pair`2<CoverageNodeId, Task>> <AssemblyModificationStarted>k__BackingField;
    [CompilerGeneratedAttribute]
private ISignal`1<Task> <StructureModificationStarted>k__BackingField;
    [CompilerGeneratedAttribute]
private ISignal`1<Task> <DetailsModificationStarted>k__BackingField;
    public int AssemblyNodesCount { get; }
    public ISignal`1<Pair`2<CoverageNodeId, Task>> AssemblyModificationStarted { get; }
    public int EstimatedNodesNumber { get; }
    public ISignal`1<Task> StructureModificationStarted { get; }
    public ISignal`1<Task> DetailsModificationStarted { get; }
    public MetadataBasedCoverageTree(Lifetime lifetime, ICoverageNodeIdFactory coverageNodeIdFactory, ICoverageTreeBuildConfigurator coverageTreeBuildConfigurator, ILowLevelMetadataProvider lowLevelMetadataProvider, IMetadataNodeNamesProvider metadataNodeNamesProvider, INotHiddenStatementsCountProvider notHiddenStatementsCountProvider, ICoverageSnapshot snapshot, IThreading threading, ILogger logger);
    private static MetadataBasedCoverageTree();
    public sealed virtual void OnNodeCreated(CoverageNode node);
    public sealed virtual void OnNodeRemoved(CoverageNode node);
    public sealed virtual CoverageNode TryGetAssemblyNode(CoverageNodeId assemblyNodeId);
    public sealed virtual void OnAssemblyModificationStarted(CoverageNodeId assemblyNodeId, Task modificationTask);
    public sealed virtual void OnModificationStarted(Task modificationTask);
    public sealed virtual int get_AssemblyNodesCount();
    public sealed virtual CoverageNodeId[] GetAllAssemblyNodes();
    public sealed virtual CoverageNodeId TryGetAssemblyNodeId(Nullable`1<Guid> mvid, string assemblyName, TargetFrameworkId targetFrameworkId);
    public sealed virtual CoverageNodeId TryGetMetadataEntityNodeId(MetadataId metadataId, bool preferOwnCoverageNode, Boolean& isOwnCoverageNode);
    [CompilerGeneratedAttribute]
public sealed virtual ISignal`1<Pair`2<CoverageNodeId, Task>> get_AssemblyModificationStarted();
    public sealed virtual CoverageNodeId GetRootNodeId();
    public ICoverageNodeChildrenEnumerator`1<T> GetSortedChildrenEnumerator(CoverageNodeChildrenVisitor`1<T> nodeVisitor, CoverageNodeDataKey`1<TS> sortDataKey, IComparer`1<TS> comparer);
    public sealed virtual ICoverageNodeChildrenEnumerator`1<T> GetChildrenEnumerator(CoverageNodeChildrenVisitor`1<T> nodeVisitor);
    public sealed virtual ICoverageNodeParentsEnumerator`1<T> GetParentsEnumerator(CoverageNodeParentsVisitor`1<T> nodeVisitor);
    public sealed virtual bool ContainsNode(CoverageNodeId nodeId);
    public sealed virtual ICoverageNodeInfo TryGetNodeInfo(CoverageNodeId nodeId);
    public sealed virtual ICoverageNodeDetails TryGetNodeDetails(CoverageNodeId nodeId);
    public sealed virtual string TryGetShortPresentableName(CoverageNodeId nodeId);
    public sealed virtual string TryGetFullPresentableName(CoverageNodeId nodeId);
    public sealed virtual string TryGetCustomPresentableName(CoverageNodeId nodeId, MetadataNodesPresentationSettings presentationSettings);
    public sealed virtual string TryGetAnnotation(CoverageNodeId nodeId);
    public sealed virtual bool TryPutNodeData(CoverageNodeId nodeId, CoverageNodeDataKey`1<T> key, T value);
    public sealed virtual T TryGetNodeData(CoverageNodeId nodeId, CoverageNodeDataKey`1<T> key);
    public sealed virtual int get_EstimatedNodesNumber();
    [CompilerGeneratedAttribute]
public sealed virtual ISignal`1<Task> get_StructureModificationStarted();
    [CompilerGeneratedAttribute]
public sealed virtual ISignal`1<Task> get_DetailsModificationStarted();
    public sealed virtual Task WhenCurrentModificationFinished();
    private void UpdateAssemblySubtreeCoverageData(CoverageNode assemblyNode, CancellationToken cancellationToken);
    private void ProcessChangedCoverageData(IReadOnlySet`1<SectionIndex`1<IMetadataSection>> excludedMetadataIndices);
    private Task StartNewUpdateCoverageTask(CoverageNodeId assemblyNodeId, Task afterTask, bool canBeCancelled);
    [CompilerGeneratedAttribute]
private void <.ctor>b__21_0(CumulativeSnapshotChangedEventArgs args);
    [CompilerGeneratedAttribute]
private Task <OnModificationStarted>b__26_0(Task _);
}
[ExtensionAttribute]
internal static class JetBrains.dotCover.Workspace.Impl.CoverageTree.Model.MetadataBasedCoverageTreeExtensions : object {
    [ExtensionAttribute]
public static CoverageNodeDetails CalculateRootNodeCoverageDetails(IMetadataBasedCoverageTreeBase tree);
    [ExtensionAttribute]
public static CoverageNodeId TryGetMetadataEntityNodeId(IMetadataBasedCoverageTreeBase tree, MetadataId metadataId, bool preferOwnCoverageNode);
}
[SnapshotModelComponentAttribute]
internal class JetBrains.dotCover.Workspace.Impl.CoverageTree.Model.MetadataNodeNamesProvider : object {
    private static IDictionary`2<CoverageNodeKind, string> ourSpecialNodeNames;
    private static MetadataNodeNamesProvider();
    public sealed virtual string GetShortName(ILowLevelMetadata metadata, MetadataToken metadataToken, CoverageNodeKind kind, MetadataNodesPresentationSettings settings);
    public sealed virtual string GetFullNameSuffix(ILowLevelMetadata metadata, MetadataToken metadataToken, CoverageNodeKind kind, MetadataNodesPresentationSettings settings);
    public sealed virtual string GetTypeShortName(TypeDefProperties typeDefProperties, MetadataNodesPresentationSettings settings);
    public sealed virtual string GetMethodShortName(ILowLevelMetadata metadata, MethodProperties methodProperties, CoverageNodeKind kind, MetadataNodesPresentationSettings settings);
    public sealed virtual string GetPropertyShortName(PropertyProperties propertyProperties, CoverageNodeKind kind, MetadataNodesPresentationSettings settings);
    public sealed virtual string GetEventShortName(EventProperties eventProperties, MetadataNodesPresentationSettings settings);
    private static string GetTypeFullNameSuffix(ILowLevelMetadata metadata, TypeDefProperties typeDefProperties, MetadataToken typeDefToken);
    private static string GetMethodFullNameSuffix(ILowLevelMetadata metadata, MethodProperties methodProperties, MetadataToken methodDefToken, CoverageNodeKind kind, MetadataNodesPresentationSettings settings);
    private static string GetPropertyFullNameSuffix(ILowLevelMetadata metadata, PropertyProperties propertyProperties, CoverageNodeKind kind, MetadataNodesPresentationSettings settings);
    private static string GetEventFullNameSuffix(ILowLevelMetadata metadata, EventProperties eventProperties, MetadataNodesPresentationSettings settings);
}
internal static class JetBrains.dotCover.Workspace.Impl.CoverageTree.Model.MetadataTreeBuilder.AssemblyMetadataTreeBuilder : object {
    public static void CreateAssemblyNode(CoverageNodeId assemblyNodeId, ILowLevelMetadata metadata, IAssemblyMetadataTreeBuilderContext context);
    public static void UpdateAssemblyNode(CoverageNode assemblyNode, ILowLevelMetadata metadata, IAssemblyMetadataTreeBuilderContext context);
    private static void PutAssemblyNodeData(ICoverageNodeDataHolder assemblyNodeDataHolder, ILowLevelMetadata metadata, IAssemblyMetadataTreeBuilderContext context);
    private static void UpdateAssemblyTree(CoverageNode assemblyNode, ILowLevelMetadata metadata, IAssemblyMetadataTreeBuilderContext context);
    private static void CreateOrUpdateTypeNode(MetadataToken typeToken, TypeDefProperties typeDefProperties, CoverageNode parentNode, OneToListMap`2<CoverageNodeValue, CoverageNode> parentNodeNewChildren, ILowLevelMetadata metadata, IAssemblyMetadataTreeBuilderContext context);
    private static void UpdateTypeTree(CoverageNode typeNode, ILowLevelMetadata metadata, MetadataToken typeToken, TypeMembersProcessorContext typeMembersProcessorContext);
    private static void UpdateMethodTree(CoverageNode methodNode, MetadataToken methodToken, MethodProperties methodProperties, MetadataId methodMetadataId, TypeMembersProcessorContext typeMembersProcessorContext);
    private static CoverageNodeValue CreateAssemblyNodeValue(ILowLevelMetadata metadata);
    private static CoverageNodeValue CreateTypeNodeValue(MetadataToken token, TypeDefProperties typeDefProperties, TypeMembersProcessorContext typeMembersProcessorContext);
    private static CoverageNodeValue CreateMethodNodeValue(MetadataToken token, MethodProperties methodProperties, TypeMembersProcessorContext typeMembersProcessorContext);
    private static CoverageNodeValue CreatePropertyNodeValue(MetadataToken token, PropertyProperties propertyProperties, TypeMembersProcessorContext typeMembersProcessorContext);
    private static CoverageNodeValue CreateEventNodeValue(MetadataToken token, EventProperties eventProperties, TypeMembersProcessorContext typeMembersProcessorContext);
    private static CoverageNode GetOrCreateNewChildNode(CoverageNode parentNode, OneToListMap`2<CoverageNodeValue, CoverageNode> newChildren, CoverageNodeValue newNodeValue, IAssemblyMetadataTreeBuilderContext context, ILowLevelMetadata metadata, Nullable`1<MetadataId> metadataId);
    private static void SetNewChildren(CoverageNode parentNode, OneToListMap`2<CoverageNodeValue, CoverageNode> newChildren, IAssemblyMetadataTreeBuilderContext context);
    private static void RemoveNodeRec(CoverageNode node, IAssemblyMetadataTreeBuilderContext context);
    private static bool IsAcceptableTopLevelType(ILowLevelMetadata metadata, MetadataToken typeToken, TypeDefProperties typeDefProperties);
    private static bool TypeHasMethodsRec(ILowLevelMetadata metadata, MetadataToken typeToken);
}
internal class JetBrains.dotCover.Workspace.Impl.CoverageTree.Model.MetadataTreeBuilder.AssemblyMetadataTreeBuilderContext : object {
    private IMethodRangeSection myMethodRangeSection;
    private IStatementDataSection myStatementDataSection;
    private TargetFrameworkId myTargetFrameworkId;
    private ISet`1<MetadataToken> myFilteredTypes;
    private ISet`1<MetadataToken> myFilteredMethods;
    private ISet`1<MetadataToken> myFilteredEvents;
    private ISet`1<MetadataToken> myFilteredProperties;
    private Predicate`1<MetadataId> myIncludeMetadataNode;
    [CompilerGeneratedAttribute]
private SectionIndex`1<IMetadataSection> <MetadataIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private IModifiableCoverageTree <CoverageTree>k__BackingField;
    [CompilerGeneratedAttribute]
private ICoverageNodeIdFactory <CoverageNodeIdFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataNodeNamesProvider <MetadataNodeNamesProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private MetadataNodesPresentationSettings <MetadataNodesPresentationSettings>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataNodesDataConstructor[] <MetadataNodesDataConstructors>k__BackingField;
    [CompilerGeneratedAttribute]
private ITypeMembersProcessor[] <TypeMembersProcessors>k__BackingField;
    [CompilerGeneratedAttribute]
private IProgressIndicator <Progress>k__BackingField;
    [CompilerGeneratedAttribute]
private CancellationToken <CancellationToken>k__BackingField;
    public SectionIndex`1<IMetadataSection> MetadataIndex { get; }
    public IModifiableCoverageTree CoverageTree { get; }
    public ICoverageNodeIdFactory CoverageNodeIdFactory { get; }
    public IMetadataNodeNamesProvider MetadataNodeNamesProvider { get; }
    public MetadataNodesPresentationSettings MetadataNodesPresentationSettings { get; }
    public IMetadataNodesDataConstructor[] MetadataNodesDataConstructors { get; }
    public ITypeMembersProcessor[] TypeMembersProcessors { get; }
    public IProgressIndicator Progress { get; }
    public CancellationToken CancellationToken { get; }
    public AssemblyMetadataTreeBuilderContext(ICoverageSnapshot snapshot, SectionIndex`1<IMetadataSection> metadataIndex, IModifiableCoverageTree coverageTree, Predicate`1<MetadataId> includeMetadataNode, ICoverageNodeIdFactory coverageNodeIdFactory, IMetadataNodeNamesProvider metadataNodeNamesProvider, MetadataNodesPresentationSettings metadataNodesPresentationSettings, IMetadataNodesDataConstructor[] metadataNodesDataConstructors, ITypeMembersProcessor[] typeMembersProcessors, IProgressIndicator progress, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
public sealed virtual SectionIndex`1<IMetadataSection> get_MetadataIndex();
    [CompilerGeneratedAttribute]
public sealed virtual IModifiableCoverageTree get_CoverageTree();
    [CompilerGeneratedAttribute]
public sealed virtual ICoverageNodeIdFactory get_CoverageNodeIdFactory();
    [CompilerGeneratedAttribute]
public sealed virtual IMetadataNodeNamesProvider get_MetadataNodeNamesProvider();
    [CompilerGeneratedAttribute]
public sealed virtual MetadataNodesPresentationSettings get_MetadataNodesPresentationSettings();
    [CompilerGeneratedAttribute]
public sealed virtual IMetadataNodesDataConstructor[] get_MetadataNodesDataConstructors();
    [CompilerGeneratedAttribute]
public sealed virtual ITypeMembersProcessor[] get_TypeMembersProcessors();
    [CompilerGeneratedAttribute]
public sealed virtual IProgressIndicator get_Progress();
    [CompilerGeneratedAttribute]
public sealed virtual CancellationToken get_CancellationToken();
    public sealed virtual TargetFrameworkId TryGetTargetFramework();
    public sealed virtual bool MetadataTokenIsFiltered(MetadataToken token);
    public sealed virtual FrugalLocalList`1<Pair`2<int, SourceFileRange>> GetMethodDocumentRanges(MetadataToken token);
    public sealed virtual Pair`2<int, SourceFileRange> GetMethodLastStatementRange(MetadataToken token, Int32& statementIndex);
    public sealed virtual bool MethodHasStatementsWithValidRanges(MetadataToken token);
}
[ExtensionAttribute]
internal static class JetBrains.dotCover.Workspace.Impl.CoverageTree.Model.MetadataTreeBuilder.AssemblyMetadataTreeBuilderHelpers : object {
    [ExtensionAttribute]
public static CoverageNodeModifier GetModifier(TypeDefProperties typeDefProperties);
    [ExtensionAttribute]
public static CoverageNodeModifier GetModifier(MethodProperties methodProperties);
    [ExtensionAttribute]
public static CoverageNodeModifier MergeWith(CoverageNodeModifier modifier1, CoverageNodeModifier modifier2);
}
internal class JetBrains.dotCover.Workspace.Impl.CoverageTree.Model.MetadataTreeBuilder.AsyncMetadataTreeBuilder : object {
    private ICoverageSnapshot mySnapshot;
    private IModifiableMetadataBasedCoverageTree myMetadataBasedCoverageTree;
    private Predicate`1<MetadataId> myIncludeMetadataNode;
    private ICoverageNodeIdFactory myCoverageNodeIdFactory;
    private ICoverageTreeBuildConfigurator myCoverageTreeBuildConfigurator;
    private ILowLevelMetadataProvider myLowLevelMetadataProvider;
    private IMetadataNodeNamesProvider myMetadataNodeNamesProvider;
    private IMetadataNodesDataConstructor[] myMetadataNodesDataConstructors;
    private IThreading myThreading;
    private ILogger myLogger;
    private IMetadataSection myMetadataSection;
    private IModuleStatSection myModuleStatSection;
    private Dictionary`2<SectionIndex`1<IMetadataSection>, CoverageNodeId> myAssemblyNodeIds;
    private Dictionary`2<CoverageNodeId, CancellationTokenSource> myBuildTaskCancellationTokenSources;
    private Dictionary`2<CoverageNodeId, Task> myBuildTasks;
    private TaskGroup myTaskGroup;
    private bool myInitializationStarted;
    private object myAccess;
    public AsyncMetadataTreeBuilder(ICoverageSnapshot snapshot, IModifiableMetadataBasedCoverageTree metadataBasedCoverageTree, Predicate`1<MetadataId> includeMetadataNode, ICoverageNodeIdFactory coverageNodeIdFactory, ICoverageTreeBuildConfigurator coverageTreeBuildConfigurator, ILowLevelMetadataProvider lowLevelMetadataProvider, IMetadataNodeNamesProvider metadataNodeNamesProvider, IMetadataNodesDataConstructor[] metadataNodesDataConstructors, IThreading threading, ILogger logger);
    public Task InitCoverageTreeAsync(IProgressIndicator progress);
    public void ProcessCumulativeSnapshotChange(CumulativeSnapshotChangedEventArgs args);
    private void ProcessAddedMetadataIndicesAsync(IReadOnlyCollection`1<SectionIndex`1<IMetadataSection>> metadataIndices, ICollection`1<Task> buildTasksSink, IProgressIndicator progress);
    private void ProcessRemovedMetadataIndicesAsync(IEnumerable`1<SectionIndex`1<IMetadataSection>> metadataIndices, ICollection`1<Task> buildTasksSink);
    private void ProcessReplacedMetadataIndicesAsync(IReadOnlyDictionary`2<SectionIndex`1<IMetadataSection>, SectionIndex`1<IMetadataSection>> replacedMetadataIndices, ICollection`1<Task> buildTasksSink);
    private bool AssemblyHasCoverageData(SectionIndex`1<IMetadataSection> metadataIndex);
    private Task StartNewBuildTask(string name, Task taskToWait, CoverageNodeId assemblyNodeId, Action`1<CancellationToken> buildAction, CancellationTokenSource cts);
    private void AddOrUpdateAssemblySubtree(SectionIndex`1<IMetadataSection> metadataIndex, CoverageNodeId assemblyNodeId, Guid mvid, Stream metadataStream, IProgressIndicator progress, CancellationToken cancellationToken);
    private void RemoveAssemblySubtree(CoverageNodeId assemblyNodeId);
    private AssemblyMetadataTreeBuilderContext CreateAssemblyMetadataTreeBuilderContext(SectionIndex`1<IMetadataSection> metadataIndex, IProgressIndicator progress, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
private void <RemoveAssemblySubtree>b__27_0(CoverageNode node, bool _);
}
[SnapshotModelComponentAttribute]
internal class JetBrains.dotCover.Workspace.Impl.CoverageTree.Model.MetadataTreeBuilder.AutomaticMetadataTreeBuilder : object {
    public AutomaticMetadataTreeBuilder(Lifetime lifetime, ILoggerProvider loggerProvider, ICoverageSnapshot snapshot, ICoverageNodeIdFactory coverageNodeIdFactory, IMetadataNodeNamesProvider metadataNodeNamesProvider, ILowLevelMetadataProvider lowLevelMetadataProvider, ICoverageTreeBuildConfigurator coverageTreeBuildConfigurator, IEnumerable`1<IMetadataNodesDataConstructor> metadataNodesDataConstructors, IModifiableMetadataBasedCoverageTree metadataBasedCoverageTree, IContainerInitializer containerInitializer, IThreading threading);
}
[SnapshotModelComponentAttribute]
internal class JetBrains.dotCover.Workspace.Impl.CoverageTree.Model.MetadataTreeBuilder.CustomMetadataTreeBuilder : object {
    private ICoverageSnapshot mySnapshot;
    private ILowLevelMetadataProvider myLowLevelMetadataProvider;
    private IMetadataNodeNamesProvider myMetadataNodeNamesProvider;
    private INotHiddenStatementsCountProvider myNotHiddenStatementsCountProvider;
    private IThreading myThreading;
    private ILogger myLogger;
    public CustomMetadataTreeBuilder(ICoverageSnapshot snapshot, ILowLevelMetadataProvider lowLevelMetadataProvider, IMetadataNodeNamesProvider metadataNodeNamesProvider, INotHiddenStatementsCountProvider notHiddenStatementsCountProvider, IThreading threading, ILoggerProvider loggerProvider);
    public sealed virtual Task`1<ICoverageTreeBase> BuildTreeAsync(Lifetime lifetime, Predicate`1<MetadataId> includeMetadataNode, MetadataNodesPresentationSettings nodesPresentationSettings, TypeMembersProcessingMode typeMembersProcessingMode, UInt32 maxParallelThreads, IProgressIndicator progress);
}
public interface JetBrains.dotCover.Workspace.Impl.CoverageTree.Model.MetadataTreeBuilder.IAssemblyMetadataTreeBuilderContext {
    public SectionIndex`1<IMetadataSection> MetadataIndex { get; }
    public IModifiableCoverageTree CoverageTree { get; }
    public ICoverageNodeIdFactory CoverageNodeIdFactory { get; }
    public IMetadataNodeNamesProvider MetadataNodeNamesProvider { get; }
    public MetadataNodesPresentationSettings MetadataNodesPresentationSettings { get; }
    public IMetadataNodesDataConstructor[] MetadataNodesDataConstructors { get; }
    public ITypeMembersProcessor[] TypeMembersProcessors { get; }
    public IProgressIndicator Progress { get; }
    public CancellationToken CancellationToken { get; }
    public abstract virtual SectionIndex`1<IMetadataSection> get_MetadataIndex();
    public abstract virtual IModifiableCoverageTree get_CoverageTree();
    public abstract virtual ICoverageNodeIdFactory get_CoverageNodeIdFactory();
    public abstract virtual IMetadataNodeNamesProvider get_MetadataNodeNamesProvider();
    public abstract virtual MetadataNodesPresentationSettings get_MetadataNodesPresentationSettings();
    public abstract virtual IMetadataNodesDataConstructor[] get_MetadataNodesDataConstructors();
    public abstract virtual ITypeMembersProcessor[] get_TypeMembersProcessors();
    public abstract virtual IProgressIndicator get_Progress();
    public abstract virtual CancellationToken get_CancellationToken();
    public abstract virtual TargetFrameworkId TryGetTargetFramework();
    public abstract virtual bool MetadataTokenIsFiltered(MetadataToken token);
    public abstract virtual FrugalLocalList`1<Pair`2<int, SourceFileRange>> GetMethodDocumentRanges(MetadataToken token);
    public abstract virtual Pair`2<int, SourceFileRange> GetMethodLastStatementRange(MetadataToken token, Int32& statementIndex);
    public abstract virtual bool MethodHasStatementsWithValidRanges(MetadataToken token);
}
[SnapshotModelComponentAttribute]
internal class JetBrains.dotCover.Workspace.Impl.CoverageTree.Model.MetadataTreeBuilder.MetadataNodesFullNamesPreBuilder : object {
    private ICoverageTreeBuildConfigurator myCoverageTreeBuildConfigurator;
    private IMetadataNodeNamesProvider myMetadataNodeNamesProvider;
    public MetadataNodesFullNamesPreBuilder(ICoverageTreeBuildConfigurator coverageTreeBuildConfigurator, IMetadataNodeNamesProvider metadataNodeNamesProvider);
    public sealed virtual void PutNodeData(ICoverageNodeDataHolder dataHolder, ILowLevelMetadata metadata, MetadataToken token, CoverageNodeKind nodeKind, ICoverageNodeDataHolder parentDataHolder);
}
internal static class JetBrains.dotCover.Workspace.Impl.CoverageTree.Model.MetadataTreeBuilder.NestedMethodsHierarchyResolver : object {
    public static void ResolveHierarchyUsingRanges(TypeMembersProcessorContext typeMembersProcessorContext);
    private static void AddMethodStartAndEndPointsToList(MetadataToken method, ResolvingContext context, OneToListMap`2<int, Point> pointListsByDocument, bool isChildCandidate, Func`2<Pair`2<int, SourceFileRange>, bool> childRangePredicate);
    private static List`1<MetadataToken> ResolveHierarchy(OneToListMap`2<int, Point> pointListsByDocument, ResolvingContext context);
    private static int CompareStartEndPoints(Point p1, Point p2);
    private static FrugalLocalList`1<Pair`2<int, SourceFileRange>> TryGetOwnRangesInAllDocuments(MetadataToken method, ResolvingContext context);
    [CanBeNullAttribute]
private static Nullable`1<Pair`2<int, SourceFileRange>> TryGetAggregatedRangeInSingleDocument(MetadataToken method, FrugalLocalList`1<MetadataToken> children, ResolvingContext context);
}
internal class JetBrains.dotCover.Workspace.Impl.CoverageTree.Model.MetadataTreeBuilder.TypeMemberProcessors.CompilerGeneratedNestedTypesProcessor : object {
    public static ITypeMembersProcessor Instance;
    private ILogger myLogger;
    private static CompilerGeneratedNestedTypesProcessor();
    public sealed virtual void Process(TypeMembersProcessorContext context);
    private FrugalLocalList`1<MetadataToken> ProcessNestedTypes(MetadataToken typeToken, IReadOnlyList`1<MetadataToken> nestedTypes, TypeMembersProcessorContext context);
    private static void OnMatchedMethodFound(MetadataToken nestedType, MetadataToken matchedMethod, ICollection`1<MetadataToken> removeMethodFrom, FrugalLocalList`1& addTypeTo, TypeMembersProcessorContext context);
    private static bool TypeShouldBeMatchedWithParentMethod(TypeInfo[] interfaceTypes, TypeMembersProcessorContext context);
    private static bool MethodIsParentCandidate(MetadataToken method, MethodSignatureInfo methodSignatureInfo, int nestedTypeOwnGenericArgsCount, UInt32 nestedTypeOwnGenericArgsStartIndex, TypeInfo[] nestedTypeInterfaceTypes, TypeMembersProcessorContext context);
    private static bool MatchTypeFieldsAndMethodParameters(MetadataToken nestedType, UInt32 nestedTypeOwnGenericArgsStartIndex, MethodSignatureInfo methodSignatureInfo, TypeMembersProcessorContext context);
    private static Nullable`1<TypeInfo> TryFindInterfaceByName(TypeInfo[] interfaces, string name, ILowLevelMetadata metadata);
    private static void ChangeGenericArgumentKindsFromTypeToMethodRec(TypeInfo& type, UInt32 fromIndex);
}
internal class JetBrains.dotCover.Workspace.Impl.CoverageTree.Model.MetadataTreeBuilder.TypeMemberProcessors.ConstructorsProcessor : object {
    public static ITypeMembersProcessor Instance;
    private static ConstructorsProcessor();
    public sealed virtual void Process(TypeMembersProcessorContext context);
    private static bool IsConstructorOrClassConstructor(MethodProperties methodProperties);
}
internal class JetBrains.dotCover.Workspace.Impl.CoverageTree.Model.MetadataTreeBuilder.TypeMemberProcessors.EventsProcessor : object {
    public static ITypeMembersProcessor Instance;
    private static EventsProcessor();
    public sealed virtual void Process(TypeMembersProcessorContext context);
}
public interface JetBrains.dotCover.Workspace.Impl.CoverageTree.Model.MetadataTreeBuilder.TypeMemberProcessors.ITypeMembersProcessor {
    public abstract virtual void Process(TypeMembersProcessorContext context);
}
internal class JetBrains.dotCover.Workspace.Impl.CoverageTree.Model.MetadataTreeBuilder.TypeMemberProcessors.LocalFunctionsAndLambdasProcessor : object {
    public static ITypeMembersProcessor Instance;
    private static LocalFunctionsAndLambdasProcessor();
    public sealed virtual void Process(TypeMembersProcessorContext context);
    private static FrugalLocalList`1<MetadataToken> ExtractLocalFunctionsAndLambdas(MetadataTokenRange methods, IReadOnlyList`1<MetadataToken> nestedTypes, Dictionary`2& localFunctionsAndLambdas, TypeMembersProcessorContext context);
    private static bool IsLambda(string ownName);
    private static bool IsLocalFunction(string ownName);
}
internal class JetBrains.dotCover.Workspace.Impl.CoverageTree.Model.MetadataTreeBuilder.TypeMemberProcessors.PropertiesProcessor : object {
    public static ITypeMembersProcessor Instance;
    private static PropertiesProcessor();
    public sealed virtual void Process(TypeMembersProcessorContext context);
    private static bool IsInitOnlySetter(MethodProperties setterProperties, ILowLevelMetadata metadata);
}
internal class JetBrains.dotCover.Workspace.Impl.CoverageTree.Model.MetadataTreeBuilder.TypeMemberProcessors.RecordTypeMembersProcessor : object {
    private static string RecordCloneMethodName;
    private static string EqualityContractGetterName;
    public static ITypeMembersProcessor Instance;
    private static RecordTypeMembersProcessor();
    public sealed virtual void Process(TypeMembersProcessorContext context);
    private static FrugalLocalList`1<Pair`2<int, SourceFileRange>> GetMethodRanges(MetadataToken methodToken, IAssemblyMetadataTreeBuilderContext context, IDictionary`2& cache);
}
public class JetBrains.dotCover.Workspace.Impl.CoverageTree.Model.MetadataTreeBuilder.TypeMemberProcessors.TypeMembersProcessorContext : object {
    private Dictionary`2<MetadataToken, FrugalLocalList`1<MetadataToken>> myParentToChildrenMap;
    private Dictionary`2<MetadataToken, FrugalLocalList`1<MetadataToken>> myMethodToChildCandidatesMap;
    private JetHashSet`1<MetadataToken> myNonMethodParents;
    private IDictionary`2<MetadataToken, CoverageNodeKind> myCustomPresentationKinds;
    private IDictionary`2<MetadataToken, CoverageNodeModifier> myCustomPresentationModifiers;
    private IDictionary`2<MetadataToken, JetHashSet`1<int>> myHiddenStatements;
    private JetHashSet`1<MetadataToken> myProcessedMethods;
    private JetHashSet`1<MetadataToken> myProcessedNestedTypes;
    [CompilerGeneratedAttribute]
private ILowLevelMetadata <Metadata>k__BackingField;
    [CompilerGeneratedAttribute]
private MetadataToken <TypeToken>k__BackingField;
    [CompilerGeneratedAttribute]
private TypeDefProperties <TypeDefProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private IAssemblyMetadataTreeBuilderContext <BuilderContext>k__BackingField;
    public ILowLevelMetadata Metadata { get; }
    public MetadataToken TypeToken { get; }
    public TypeDefProperties TypeDefProperties { get; }
    public IAssemblyMetadataTreeBuilderContext BuilderContext { get; }
    public TypeMembersProcessorContext(ILowLevelMetadata metadata, MetadataToken typeToken, TypeDefProperties typeDefProperties, IAssemblyMetadataTreeBuilderContext builderContext);
    [CompilerGeneratedAttribute]
public ILowLevelMetadata get_Metadata();
    [CompilerGeneratedAttribute]
public MetadataToken get_TypeToken();
    [CompilerGeneratedAttribute]
public TypeDefProperties get_TypeDefProperties();
    [CompilerGeneratedAttribute]
public IAssemblyMetadataTreeBuilderContext get_BuilderContext();
    public void AddProcessedMethod(MetadataToken methodToken);
    public bool MethodIsProcessed(MetadataToken methodToken);
    public void AddProcessedNestedType(MetadataToken typeToken);
    public bool NestedTypeIsProcessed(MetadataToken typeToken);
    private void RegisterChild(MetadataToken parent, MetadataToken child);
    public void RegisterChildCandidateForMethod(MetadataToken parent, MetadataToken child);
    public void RegisterChildForMethod(MetadataToken parent, MetadataToken child);
    public void RegisterChildForNonMethodParent(MetadataToken parent, MetadataToken child);
    public JetHashSet`1<MetadataToken> GetNonMethodParents();
    public FrugalLocalList`1<MetadataToken> GetChildren(MetadataToken parent);
    [CanBeNullAttribute]
public KeyCollection<MetadataToken, FrugalLocalList`1<MetadataToken>> TryGetAllParentMethodCandidates();
    public FrugalLocalList`1<MetadataToken> GetMethodChildCandidates(MetadataToken method);
    public void SetCustomPresentationKind(MetadataToken member, CoverageNodeKind kind);
    public void SetCustomPresentationModifier(MetadataToken member, CoverageNodeModifier modifier);
    public bool TryGetCustomPresentationKind(MetadataToken member, CoverageNodeKind& kind);
    public bool TryGetCustomPresentationModifier(MetadataToken member, CoverageNodeModifier& modifier);
    public void RegisterHiddenStatementIndex(MetadataToken method, int index);
    public JetHashSet`1<int> GetHiddenStatementIndices(MetadataToken method);
}
[RdExtAttribute]
[SnapshotModelComponentAttribute]
internal class JetBrains.dotCover.Workspace.Impl.CoverageTree.Model.MethodsGroupingNodesProvider : RdExtComponentBase {
    private ILogger myLogger;
    private Lifetime myLifetime;
    private IMetadataBasedCoverageTree myMetadataBasedCoverageTree;
    private ICoverageTreeBuildConfigurator myCoverageTreeBuildConfigurator;
    private IRealtimeRequestsProcessor myRealtimeRequestsProcessor;
    public MethodsGroupingNodesProvider(Lifetime lifetime, IRdExtComponentsInitializer initializer, IMetadataBasedCoverageTree metadataBasedCoverageTree, ICoverageTreeBuildConfigurator coverageTreeBuildConfigurator, IRealtimeRequestsProcessor realtimeRequestsProcessor, ILoggerProvider loggerProvider);
    public sealed virtual Task`1<IDictionary`2<CoverageNodeId, CoverageNodeId>> GetGroupingNodes(IEnumerable`1<CoverageNodeId> methodNodeIds);
    private bool ShouldAddGroupingNode(ICoverageNodeInfo methodNodeInfo);
}
internal class JetBrains.dotCover.Workspace.Impl.CoverageTree.Model.Nodes.AssemblyNodeData : object {
    public static CoverageNodeDataKey`1<AssemblyNodeData> Key;
    [CompilerGeneratedAttribute]
private SectionIndex`1<IMetadataSection> <MetadataIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <Mvid>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private TargetFrameworkId <TargetFrameworkId>k__BackingField;
    public SectionIndex`1<IMetadataSection> MetadataIndex { get; }
    public Guid Mvid { get; }
    [NotNullAttribute]
public Version Version { get; }
    [NotNullAttribute]
public TargetFrameworkId TargetFrameworkId { get; }
    public AssemblyNodeData(SectionIndex`1<IMetadataSection> metadataIndex, Guid mvid, Version version, TargetFrameworkId targetFrameworkId);
    private static AssemblyNodeData();
    [CompilerGeneratedAttribute]
public SectionIndex`1<IMetadataSection> get_MetadataIndex();
    [CompilerGeneratedAttribute]
public Guid get_Mvid();
    [CompilerGeneratedAttribute]
public Version get_Version();
    [CompilerGeneratedAttribute]
public TargetFrameworkId get_TargetFrameworkId();
    public virtual string ToString();
}
[ExtensionAttribute]
internal static class JetBrains.dotCover.Workspace.Impl.CoverageTree.Model.Nodes.AssemblyNodeDataExtension : object {
    [ExtensionAttribute]
public static string GetPresentationName(AssemblyNodeData node);
}
public class JetBrains.dotCover.Workspace.Impl.CoverageTree.Model.Nodes.CoverageNode : object {
    private CoverageNode modreq(System.Runtime.CompilerServices.IsVolatile) myParent;
    private CoverageNodesCollection modreq(System.Runtime.CompilerServices.IsVolatile) myChildren;
    private IList`1<object> myData;
    [CompilerGeneratedAttribute]
private CoverageNodeId <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private CoverageNodeValue <Value>k__BackingField;
    public CoverageNodeId Id { get; }
    public CoverageNodeValue Value { get; }
    public CoverageNode Parent { get; internal set; }
    public CoverageNodesCollection Children { get; internal set; }
    public CoverageNode(CoverageNodeId id, CoverageNodeValue value, CoverageNode parent);
    [CompilerGeneratedAttribute]
public CoverageNodeId get_Id();
    [CompilerGeneratedAttribute]
public CoverageNodeValue get_Value();
    public CoverageNode get_Parent();
    internal void set_Parent(CoverageNode value);
    public CoverageNodesCollection get_Children();
    internal void set_Children(CoverageNodesCollection value);
    public virtual string ToString();
    public sealed virtual T GetData(CoverageNodeDataKey`1<T> key);
    public sealed virtual void PutData(CoverageNodeDataKey`1<T> key, T value);
    public sealed virtual void ClearData();
}
internal class JetBrains.dotCover.Workspace.Impl.CoverageTree.Model.Nodes.CoverageNodeDetails : object {
    public static CoverageNodeDataKey`1<ICoverageNodeDetails> Key;
    public static CoverageNodeDetails Empty;
    [CompilerGeneratedAttribute]
private long <CoveredStatements>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TotalStatements>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOutdated>k__BackingField;
    public long CoveredStatements { get; public set; }
    public long TotalStatements { get; public set; }
    public bool IsOutdated { get; public set; }
    private static CoverageNodeDetails();
    [CompilerGeneratedAttribute]
public sealed virtual long get_CoveredStatements();
    [CompilerGeneratedAttribute]
public void set_CoveredStatements(long value);
    [CompilerGeneratedAttribute]
public sealed virtual long get_TotalStatements();
    [CompilerGeneratedAttribute]
public void set_TotalStatements(long value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsOutdated();
    [CompilerGeneratedAttribute]
public void set_IsOutdated(bool value);
    public virtual string ToString();
}
[ExtensionAttribute]
internal static class JetBrains.dotCover.Workspace.Impl.CoverageTree.Model.Nodes.CoverageNodeDetailsImplExtensions : object {
    [ExtensionAttribute]
public static void Add(CoverageNodeDetails baseDetails, ICoverageNodeDetails addDetails);
}
[ExtensionAttribute]
internal static class JetBrains.dotCover.Workspace.Impl.CoverageTree.Model.Nodes.CoverageNodeExtensions : object {
    [ExtensionAttribute]
public static void PostOrderDfs(CoverageNode rootNode, PostOrderDfsProcessor processor);
    private static void PostOrderDfsRec(CoverageNode node, bool isFirstChild, PostOrderDfsProcessor processor);
    [ExtensionAttribute]
public static void UpdateSubtreeCoverageData(CoverageNode rootNode, CancellationToken cancellationToken, Func`2<CoverageNode, CoverageNodeDetails> getLeafNodeCoverageData);
    [ExtensionAttribute]
[NotNullAttribute]
public static ICoverageNodeDetails GetDetails(CoverageNode node);
    [ExtensionAttribute]
public static void ForeachParentId(CoverageNode node, CoverageNodeParentsVisitor`1<T> nodeVisitor, T arg, Boolean& stopped);
    [ExtensionAttribute]
public static void RemoveChild(CoverageNode parent, CoverageNode removedChild);
    [ExtensionAttribute]
public static void AddChild(CoverageNode parent, CoverageNode addedChild);
}
[SnapshotModelComponentAttribute]
[ThreadSafeAttribute]
internal class JetBrains.dotCover.Workspace.Impl.CoverageTree.Model.Nodes.CoverageNodeIdFactory : object {
    private int myNextId;
    private Queue`1<CoverageNodeId> myReleasedIds;
    public sealed virtual CoverageNodeId GetNextId();
    public sealed virtual void ReleaseId(CoverageNodeId id);
}
public class JetBrains.dotCover.Workspace.Impl.CoverageTree.Model.Nodes.CoverageNodesCollection : object {
    public static CoverageNodesCollection Empty;
    private OneToListMap`2<CoverageNodeValue, CoverageNode> myInternalMap;
    private List`1<CoverageNodeValue> myNodeValues;
    private List`1<IList`1<CoverageNode>> myNodeLists;
    public int Count { get; }
    internal CoverageNodesCollection(OneToListMap`2<CoverageNodeValue, CoverageNode> internalMap);
    private static CoverageNodesCollection();
    public bool TryGetNodes(CoverageNodeValue nodeValue, ValueCollection& nodes);
    public IReadOnlyList`1<CoverageNodeValue> GetNodeValues();
    public NodesEnumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<CoverageNode> System.Collections.Generic.IEnumerable<JetBrains.dotCover.Workspace.Impl.CoverageTree.Model.Nodes.CoverageNode>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual int get_Count();
}
public class JetBrains.dotCover.Workspace.Impl.CoverageTree.Model.Nodes.CoverageNodeValue : object {
    [CompilerGeneratedAttribute]
private string <PresentableName>k__BackingField;
    [CompilerGeneratedAttribute]
private CoverageNodeKind <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private CoverageNodeModifier <Modifier>k__BackingField;
    private int myHashCode;
    public string PresentableName { get; }
    public CoverageNodeKind Kind { get; }
    public CoverageNodeModifier Modifier { get; }
    public CoverageNodeValue(CoverageNodeKind kind, string presentableName, CoverageNodeModifier modifier);
    [CompilerGeneratedAttribute]
public string get_PresentableName();
    [CompilerGeneratedAttribute]
public sealed virtual CoverageNodeKind get_Kind();
    [CompilerGeneratedAttribute]
public sealed virtual CoverageNodeModifier get_Modifier();
    public sealed virtual bool Equals(CoverageNodeValue other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private int CalculateHashCode();
    public virtual string ToString();
}
internal class JetBrains.dotCover.Workspace.Impl.CoverageTree.Model.Nodes.MetadataEntityNodeData : object {
    public static CoverageNodeDataKey`1<MetadataEntityNodeData> Key;
    [CompilerGeneratedAttribute]
private MetadataId <MetadataId>k__BackingField;
    public MetadataId MetadataId { get; }
    public MetadataEntityNodeData(MetadataId metadataId);
    private static MetadataEntityNodeData();
    [CompilerGeneratedAttribute]
public MetadataId get_MetadataId();
    public virtual string ToString();
}
internal class JetBrains.dotCover.Workspace.Impl.CoverageTree.Model.Nodes.MethodHiddenStatementsData : object {
    public static CoverageNodeDataKey`1<MethodHiddenStatementsData> Key;
    [CompilerGeneratedAttribute]
private JetHashSet`1<int> <StatementIndices>k__BackingField;
    public JetHashSet`1<int> StatementIndices { get; }
    public MethodHiddenStatementsData(JetHashSet`1<int> statementIndices);
    private static MethodHiddenStatementsData();
    [CompilerGeneratedAttribute]
public JetHashSet`1<int> get_StatementIndices();
}
[SnapshotModelComponentAttribute]
internal class JetBrains.dotCover.Workspace.Impl.CoverageTree.Model.NotHiddenStatementsCountProvider : object {
    private IMethodRangeSection myMethodRangeSection;
    [CanBeNullAttribute]
private ISyntheticPointsSection mySyntheticPointsSection;
    public NotHiddenStatementsCountProvider(ICoverageSnapshot snapshot);
    public sealed virtual bool TryGetStatementsCount(MetadataId metadataId, Int32& count);
}
[RdExtAttribute]
[SnapshotModelComponentAttribute]
internal class JetBrains.dotCover.Workspace.Impl.CoverageTreeQuickSearch.CoverageTreeQuickSearchService : RdExtComponentBase {
    private ILogger myLogger;
    private ICoverageTree myCoverageTree;
    private IThreading myThreading;
    private CancellationTokenSource myCancellationTokenSource;
    private Task`1<QuickSearchResult> myTask;
    public CoverageTreeQuickSearchService(Lifetime lifetime, IRdExtComponentsInitializer initializer, ICoverageTree coverageTree, IThreading threading, ILoggerProvider loggerProvider);
    public sealed virtual Task`1<QuickSearchResult> GetQuickSearchResultAsync(string quickSearchText);
    private bool FindMatchingNodesInSubtreeRec(CoverageNodeId nodeId, ICoverageNodeChildrenEnumerator`1<QuickSearchState> childrenEnumerator, QuickSearchState searchState);
    private bool CheckNode(CoverageNodeId nodeId, QuickSearchState searchState);
}
[RdExtAttribute]
[SnapshotModelComponentAttribute]
internal class JetBrains.dotCover.Workspace.Impl.CoverageTreeReverseCoverage.Model.CoverageTreeReverseCoverageProvider : RdExtComponentBase {
    private ICumulativeCoverageSnapshot myCumulativeCoverageSnapshot;
    private ICumulativeSnapshotReverseCoverageSection myReverseCoverageSection;
    private Lifetime myLifetime;
    private ICoverageTree myCoverageTree;
    private IUnitTestsCoverageTree myUnitTestsCoverageTree;
    private IRealtimeRequestsProcessor myRealtimeRequestsProcessor;
    private ILogger myLogger;
    [CompilerGeneratedAttribute]
private UProperty`1<bool> <IsPerTestInfoAvailable>k__BackingField;
    public UProperty`1<bool> IsPerTestInfoAvailable { get; }
    public CoverageTreeReverseCoverageProvider(Lifetime lifetime, IRdExtComponentsInitializer initializer, ICoverageSnapshot coverageSnapshot, ICoverageTree coverageTree, IUnitTestsCoverageTree unitTestsCoverageTree, IRealtimeRequestsProcessor realtimeRequestsProcessor, ILoggerProvider loggerProvider);
    [CompilerGeneratedAttribute]
public sealed virtual UProperty`1<bool> get_IsPerTestInfoAvailable();
    public sealed virtual Task`1<IEnumerable`1<UnitTestSessionTestId>> GetTestsCoveringNode(CoverageNodeId nodeId);
    private void MethodIdsCollector(CoverageNodeId parentId, CoverageNodeId nodeId, List`1<MetadataId> result, bool hasChildren);
    [CompilerGeneratedAttribute]
private void <.ctor>g__UpdatePerTestInfoAvailability|7_0();
    [CompilerGeneratedAttribute]
private void <.ctor>b__7_1(CumulativeSnapshotChangedEventArgs _);
}
[ExtensionAttribute]
internal static class JetBrains.dotCover.Workspace.Impl.DocumentsMarkup.Model.DocumentContextHelper : object {
    [ExtensionAttribute]
public static Nullable`1<SectionIndex`1<IMetadataSection>> TryGetMetadataIndexByContext(IMetadataBasedCoverageTree metadataBasedCoverageTree, DocumentContext context);
}
[RdExtAttribute]
[SnapshotModelComponentAttribute]
[ThreadSafeAttribute]
internal class JetBrains.dotCover.Workspace.Impl.DocumentsMarkup.Model.DocumentPaths.SnapshotDocumentsFinder : RdExtComponentBase {
    private Lifetime myLifetime;
    private IRealtimeRequestsProcessor myRealtimeRequestsProcessor;
    private ILogger myLogger;
    private IDocumentRangeSection myDocumentRangeSection;
    private DateTime mySnapshotTimeStamp;
    private OneToListMap`2<string, int> myFileNamesToDocumentIndices;
    private IDictionary`2<string, IEnumerable`1<int>> myMappedPathsCache;
    private FileSystemPath myPathMappingRoot;
    private object mySync;
    private static ISet`1<char> ourInvalidPathChars;
    private static FileSystemPath ourFakeBasePath;
    [CompilerGeneratedAttribute]
private ISimpleSignal <PathsInfoChanged>k__BackingField;
    public ISimpleSignal PathsInfoChanged { get; }
    private static SnapshotDocumentsFinder();
    public SnapshotDocumentsFinder(Lifetime lifetime, IRdExtComponentsInitializer initializer, ICoverageSnapshot coverageSnapshot, IRealtimeRequestsProcessor realtimeRequestsProcessor, ILoggerProvider loggerProvider);
    public sealed virtual IEnumerable`1<int> GetAllDocumentIndices(string documentPath, IDictionary`2<string, string> pathMap);
    [CompilerGeneratedAttribute]
public sealed virtual ISimpleSignal get_PathsInfoChanged();
    public sealed virtual Task SetPathMappingRoot(string root);
    private IEnumerable`1<int> TryGetDocumentIndicesUsingPathMappingRoot(FileSystemPath parsedDocumentPath);
    private OneToListMap`2<string, int> CreateFileNamesMap();
    [CompilerGeneratedAttribute]
private void <.ctor>b__12_0(CumulativeSnapshotChangedEventArgs args);
}
[RdExtAttribute]
[SnapshotModelComponentAttribute]
internal class JetBrains.dotCover.Workspace.Impl.DocumentsMarkup.Model.DocumentStatementsCoverageProvider : RdExtComponentBase {
    private ILogger myLogger;
    private Lifetime myLifetime;
    private ICoverageSnapshot myCoverageSnapshot;
    private IMetadataBasedCoverageTree myMetadataBasedCoverageTree;
    private ISnapshotDocumentsFinder mySnapshotDocumentsFinder;
    private IMethodStatementsCoverageProvider myMethodStatementsCoverageProvider;
    private IRealtimeRequestsProcessor myRealtimeRequestsProcessor;
    private IMethodRangeSection myMethodRangeSection;
    public DocumentStatementsCoverageProvider(Lifetime lifetime, IRdExtComponentsInitializer initializer, ICoverageSnapshot coverageSnapshot, IMetadataBasedCoverageTree metadataBasedCoverageTree, ISnapshotDocumentsFinder snapshotDocumentsFinder, IMethodStatementsCoverageProvider methodStatementsCoverageProvider, IRealtimeRequestsProcessor realtimeRequestsProcessor, ILoggerProvider loggerProvider);
    public sealed virtual Task`1<IEnumerable`1<MethodCoverageInfo>> GetStatementsCoverage(string documentFilePath, DocumentContext documentContext);
}
public interface JetBrains.dotCover.Workspace.Impl.DocumentsMarkup.Model.Interface.DocumentPaths.ISnapshotDocumentsFinder {
    public ISimpleSignal PathsInfoChanged { get; }
    public abstract virtual IEnumerable`1<int> GetAllDocumentIndices(string documentPath, IDictionary`2<string, string> pathMap);
    public abstract virtual ISimpleSignal get_PathsInfoChanged();
}
public interface JetBrains.dotCover.Workspace.Impl.DocumentsMarkup.Model.Interface.IMethodStatementsCoverageProvider {
    [NotNullAttribute]
[ItemNotNullAttribute]
public abstract virtual IReadOnlyCollection`1<MethodCoverageInfo> GetMethodsCoverageInfo(IReadOnlySet`1<MetadataId> methods, Nullable`1<SectionIndex`1<IMetadataSection>> metadataIndex, IReadOnlyCollection`1<ISnapshotSectionCollection> groups, Func`1<bool> checkForInterrupt);
}
public interface JetBrains.dotCover.Workspace.Impl.DocumentsMarkup.Model.Interface.IPdbStatementRangesProviderImpl {
    public abstract virtual IEnumerable`1<PdbStatementRange> GetRanges(int documentIndex, Nullable`1<SectionIndex`1<IMetadataSection>> metadataIndex);
}
[SnapshotModelComponentAttribute]
internal class JetBrains.dotCover.Workspace.Impl.DocumentsMarkup.Model.MethodStatementsCoverageProvider : object {
    private ICoverageSnapshot myCoverageSnapshot;
    private ICoveredMethodsInfoBuilder myCoveredMethodsInfoBuilder;
    public MethodStatementsCoverageProvider(ICoverageSnapshot coverageSnapshot, ICoveredMethodsInfoBuilder coveredMethodsInfoBuilder);
    public sealed virtual IReadOnlyCollection`1<MethodCoverageInfo> GetMethodsCoverageInfo(IReadOnlySet`1<MetadataId> methods, Nullable`1<SectionIndex`1<IMetadataSection>> metadataIndex, IReadOnlyCollection`1<ISnapshotSectionCollection> groups, Func`1<bool> checkForInterrupt);
    private static MethodCoverageInfo CreateMethodCoverageInfo(CoverageNodeId nodeId, long coveredStatementsCount, long totalStatementsCount, bool isOutdated, IStatementDetails coverageDetails);
}
[RdExtAttribute]
[SnapshotModelComponentAttribute]
internal class JetBrains.dotCover.Workspace.Impl.DocumentsMarkup.Model.PdbStatementRangesProvider : RdExtComponentBase {
    private ILogger myLogger;
    private Lifetime myLifetime;
    private ICoverageTree myCoverageTree;
    private IMetadataBasedCoverageTree myMetadataBasedCoverageTree;
    private ISnapshotDocumentsFinder mySnapshotDocumentsFinder;
    private IRealtimeRequestsProcessor myRealtimeRequestsProcessor;
    private IMethodRangeSection myMethodRangeSection;
    private IStatementDataSection myStatementDataSection;
    private IDocumentRangeSection myDocumentRangeSection;
    private ISyntheticPointsSection mySyntheticPointsSection;
    [CompilerGeneratedAttribute]
private USignal`1<Unit> <RangesChanged>k__BackingField;
    public USignal`1<Unit> RangesChanged { get; }
    public PdbStatementRangesProvider(Lifetime lifetime, IRdExtComponentsInitializer initializer, ICoverageSnapshot coverageSnapshot, ICoverageTree coverageTree, IMetadataBasedCoverageTree metadataBasedCoverageTree, ISnapshotDocumentsFinder snapshotDocumentsFinder, IRealtimeRequestsProcessor realtimeRequestsProcessor, IThreading threading, ILoggerProvider loggerProvider);
    public sealed virtual Task`1<IEnumerable`1<DocumentPdbStatementRanges>> GetRanges(string documentFilePath, DocumentContext documentContext);
    [CompilerGeneratedAttribute]
public sealed virtual USignal`1<Unit> get_RangesChanged();
    public sealed virtual IEnumerable`1<PdbStatementRange> GetRanges(int documentIndex, Nullable`1<SectionIndex`1<IMetadataSection>> metadataIndex);
}
[RdExtAttribute]
[SnapshotModelComponentAttribute]
internal class JetBrains.dotCover.Workspace.Impl.DocumentsMarkup.Model.ReverseCoverage.DocumentReverseCoverageProvider : RdExtComponentBase {
    private ICumulativeCoverageSnapshot myCumulativeCoverageSnapshot;
    private Lifetime myLifetime;
    private ISnapshotDocumentsFinder mySnapshotDocumentsFinder;
    private IMetadataBasedCoverageTree myMetadataBasedCoverageTree;
    private IUnitTestsCoverageTree myUnitTestsCoverageTree;
    private IMethodStatementsCoverageProvider myMethodStatementsCoverageProvider;
    private IRealtimeRequestsProcessor myRealtimeRequestsProcessor;
    private IMethodRangeSection myMethodRangeSection;
    private ICumulativeSnapshotReverseCoverageSection myReverseCoverageSection;
    private ILogger myLogger;
    [CompilerGeneratedAttribute]
private UProperty`1<bool> <IsPerTestInfoAvailable>k__BackingField;
    public UProperty`1<bool> IsPerTestInfoAvailable { get; }
    public DocumentReverseCoverageProvider(Lifetime lifetime, IRdExtComponentsInitializer initializer, ICoverageSnapshot coverageSnapshot, ISnapshotDocumentsFinder snapshotDocumentsFinder, IMetadataBasedCoverageTree metadataBasedCoverageTree, IUnitTestsCoverageTree unitTestsCoverageTree, IMethodStatementsCoverageProvider methodStatementsCoverageProvider, IRealtimeRequestsProcessor realtimeRequestsProcessor, ILoggerProvider loggerProvider);
    [CompilerGeneratedAttribute]
public sealed virtual UProperty`1<bool> get_IsPerTestInfoAvailable();
    public sealed virtual Task`1<TestCoverageInfo[]> GetTestsCoverageInfo(string documentFilePath, DocumentContext documentContext);
    [CompilerGeneratedAttribute]
private void <.ctor>g__UpdatePerTestInfoAvailability|10_0();
    [CompilerGeneratedAttribute]
private void <.ctor>b__10_1(CumulativeSnapshotChangedEventArgs _);
}
[RdExtAttribute]
[SnapshotModelComponentAttribute]
internal class JetBrains.dotCover.Workspace.Impl.Filtering.Model.AutoPropertiesFilterConfigurator : FilterConfiguratorBase {
    private IAutoPropertiesFilterProvider myAutoPropertiesFilterProvider;
    public AutoPropertiesFilterConfigurator(Lifetime lifetime, IRdExtComponentsInitializer initializer, IEnumerable`1<IFilterableCoverageTree> filterableCoverageTrees, IAutoPropertiesFilterProvider autoPropertiesFilterProvider, IThreading threading);
    public sealed virtual Task SetHideAutoProperties(bool value);
}
[SnapshotModelComponentAttribute]
internal class JetBrains.dotCover.Workspace.Impl.Filtering.Model.AutoPropertiesFilterProvider : object {
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) myHideAutoProperties;
    [CompilerGeneratedAttribute]
private ISimpleSignal <FilterChanged>k__BackingField;
    public string Id { get; }
    public ISimpleSignal FilterChanged { get; }
    public AutoPropertiesFilterProvider(Lifetime lifetime);
    public sealed virtual string get_Id();
    public sealed virtual bool IsActive(ICoverageTreeBase coverageTree);
    public sealed virtual ICoverageNodesFilter GetFilter(ICoverageTreeBase coverageTree);
    [CompilerGeneratedAttribute]
public sealed virtual ISimpleSignal get_FilterChanged();
    public sealed virtual void SetHideAutoProperties(bool value);
}
[RdExtAttribute]
[SnapshotModelComponentAttribute]
internal class JetBrains.dotCover.Workspace.Impl.Filtering.Model.CoverageFiltersFactory : RdExtComponentBase {
    private Lifetime myLifetime;
    private IMetadataBasedCoverageTree myMetadataBasedCoverageTree;
    private ICoverageTree myCoverageTree;
    private ILowLevelMetadataProvider myLowLevelMetadataProvider;
    private IRealtimeRequestsProcessor myRealtimeRequestsProcessor;
    private ILogger myLogger;
    private IMetadataSection myMetadataSection;
    public CoverageFiltersFactory(Lifetime lifetime, IRdExtComponentsInitializer initializer, IMetadataBasedCoverageTree metadataBasedCoverageTree, ICoverageTree coverageTree, ICoverageSnapshot snapshot, ILowLevelMetadataProvider lowLevelMetadataProvider, IRealtimeRequestsProcessor realtimeRequestsProcessor, ILoggerProvider loggerProvider);
    public sealed virtual Task`1<IEnumerable`1<CoverageFilter>> TryCreateExcludeFiltersByCoverageNode(CoverageNodeId nodeId);
    private string TryGetMetadataNodeName(CoverageNodeId nodeId, ILowLevelMetadata metadata);
}
[RdExtAttribute]
[SnapshotModelComponentAttribute]
internal class JetBrains.dotCover.Workspace.Impl.Filtering.Model.DocumentsFilterConfigurator : FilterConfiguratorBase {
    private IDocumentsFilterProvider myDocumentsFilterProvider;
    public DocumentsFilterConfigurator(Lifetime lifetime, IRdExtComponentsInitializer initializer, IEnumerable`1<IFilterableCoverageTree> filterableCoverageTrees, IDocumentsFilterProvider documentsFilterProvider, IThreading threading);
    public sealed virtual Task SetFilteredDocumentMasks(IEnumerable`1<string> masks);
}
[SnapshotModelComponentAttribute]
internal class JetBrains.dotCover.Workspace.Impl.Filtering.Model.DocumentsFilterProvider : object {
    private IMethodRangeSection myMethodRangeSection;
    private IDocumentRangeSection myDocumentRangeSection;
    private JetHashSet`1 modreq(System.Runtime.CompilerServices.IsVolatile) myFilteredDocumentMasks;
    private ConcurrentDictionary`2 modreq(System.Runtime.CompilerServices.IsVolatile) myFilteredDocumentUrlsCache;
    [CompilerGeneratedAttribute]
private ISimpleSignal <FilterChanged>k__BackingField;
    public string Id { get; }
    public ISimpleSignal FilterChanged { get; }
    public DocumentsFilterProvider(Lifetime lifetime, ICoverageSnapshot snapshot);
    public sealed virtual string get_Id();
    public sealed virtual bool IsActive(ICoverageTreeBase coverageTree);
    public sealed virtual ICoverageNodesFilter GetFilter(ICoverageTreeBase coverageTree);
    [CompilerGeneratedAttribute]
public sealed virtual ISimpleSignal get_FilterChanged();
    public sealed virtual void SetFilteredDocumentMasks(IEnumerable`1<string> masks);
    public sealed virtual IReadOnlySet`1<int> GetExcludedDocumentIndices();
    private static PathWildcard[] ToPathWildcards(IEnumerable`1<string> masks);
}
[SnapshotModelComponentAttribute]
[ThreadSafeAttribute]
internal class JetBrains.dotCover.Workspace.Impl.Filtering.Model.FilterableCoverageTree : FilterableCoverageTreeBase {
    private ILogger myLogger;
    private IMetadataBasedCoverageTree myMetadataBasedCoverageTree;
    private IThreading myThreading;
    private object myTaskAccess;
    private CancellationTokenSource myUpdateExcludedNodesCts;
    private CancellationTokenSource myUpdateCoverageCts;
    private Task myTask;
    public int Priority { get; }
    public FilterableCoverageTree(Lifetime lifetime, IEnumerable`1<ICoverageNodesFilterProvider> coverageNodesFilterProviders, IMetadataBasedCoverageTree metadataBasedCoverageTree, IThreading threading, ILoggerProvider loggerProvider);
    public sealed virtual int get_Priority();
    protected virtual Task OnBaseStructureModificationStarted(Task modificationTask);
    protected virtual Task OnBaseDetailsModificationStarted(Task modificationTask);
    protected virtual void OnFilterChanged(ICoverageNodesFilterProvider filterProvider);
    protected virtual bool ShouldProcessNode(CoverageNodeId nodeId);
    private Task OnFullUpdateRequired(Task afterTask);
    private Task StartNewTask(string name, Task afterTask, Action action);
}
internal abstract class JetBrains.dotCover.Workspace.Impl.Filtering.Model.FilterableCoverageTreeBase : CoverageTreeWrapper {
    private Lifetime myLifetime;
    private ICoverageNodesFilterProvider[] myCoverageNodesFilterProviders;
    private SynchronizedSet`1<CoverageNodeId> myExcludedNodes;
    private SynchronizedSet`1<CoverageNodeId> myParentsWithAllExcludedNodes;
    private ConcurrentDictionary`2<CoverageNodeId, JetHashSet`1<string>> myEffectiveFilterProvidersBySubtree;
    private ConcurrentDictionary`2<CoverageNodeId, CoverageNodeDetails> myOwnCoverageNodeDetails;
    protected FilterableCoverageTreeBase(Lifetime lifetime, IEnumerable`1<ICoverageNodesFilterProvider> coverageNodesFilterProviders, ILoggerProvider loggerProvider);
    public sealed virtual bool HasExcludedNodes(string filterProviderId);
    public virtual ICoverageNodeChildrenEnumerator`1<T> GetChildrenEnumerator(CoverageNodeChildrenVisitor`1<T> nodeVisitor);
    public virtual bool ContainsNode(CoverageNodeId nodeId);
    public virtual ICoverageNodeDetails TryGetNodeDetails(CoverageNodeId nodeId);
    public virtual void SetBaseTree(ICoverageTreeBase baseTree);
    protected abstract virtual void OnFilterChanged(ICoverageNodesFilterProvider filterProvider);
    protected abstract virtual bool ShouldProcessNode(CoverageNodeId nodeId);
    protected void UpdateSubtreeExcludedNodes(CoverageNodeId subtreeParentNodeId, CoverageNodeId subtreeRootNodeId, CancellationToken cancellationToken);
    protected void UpdateSubtreeCoverage(CoverageNodeId rootNodeId, CancellationToken cancellationToken);
}
[SnapshotModelComponentAttribute]
[ThreadSafeAttribute]
internal class JetBrains.dotCover.Workspace.Impl.Filtering.Model.FilterableMetadataBasedCoverageTree : FilterableCoverageTreeBase {
    private ILogger myLogger;
    private Lifetime myLifetime;
    private IThreading myThreading;
    private IMetadataBasedCoverageTreeBase myBaseTree;
    private object myTasksAccess;
    private Dictionary`2<CoverageNodeId, CancellationTokenSource> myUpdateAssemblyFilteringCts;
    private Dictionary`2<CoverageNodeId, CancellationTokenSource> myUpdateAssemblyCoverageCts;
    private Dictionary`2<CoverageNodeId, Task> myUpdateAssemblyTasks;
    [CompilerGeneratedAttribute]
private ISignal`1<Pair`2<CoverageNodeId, Task>> <AssemblyModificationStarted>k__BackingField;
    public int AssemblyNodesCount { get; }
    public ISignal`1<Pair`2<CoverageNodeId, Task>> AssemblyModificationStarted { get; }
    public int Priority { get; }
    public FilterableMetadataBasedCoverageTree(Lifetime lifetime, IEnumerable`1<ICoverageNodesFilterProvider> coverageNodesFilterProviders, IThreading threading, ILoggerProvider loggerProvider);
    public virtual ICoverageNodeDetails TryGetNodeDetails(CoverageNodeId nodeId);
    public sealed virtual int get_AssemblyNodesCount();
    public sealed virtual CoverageNodeId[] GetAllAssemblyNodes();
    public sealed virtual CoverageNodeId TryGetAssemblyNodeId(Nullable`1<Guid> mvid, string assemblyName, TargetFrameworkId targetFrameworkId);
    public sealed virtual CoverageNodeId TryGetMetadataEntityNodeId(MetadataId metadataId, bool preferOwnCoverageNode, Boolean& isOwnCoverageNode);
    [CompilerGeneratedAttribute]
public sealed virtual ISignal`1<Pair`2<CoverageNodeId, Task>> get_AssemblyModificationStarted();
    public sealed virtual int get_Priority();
    public sealed virtual void SetBaseTree(IMetadataBasedCoverageTreeBase baseTree);
    public virtual Task WhenCurrentModificationFinished();
    protected virtual void OnFilterChanged(ICoverageNodesFilterProvider filterProvider);
    protected virtual bool ShouldProcessNode(CoverageNodeId nodeId);
    protected virtual Task OnBaseStructureModificationStarted(Task modificationTask);
    protected virtual Task OnBaseDetailsModificationStarted(Task modificationTask);
    private Task OnFullUpdateRequired(CoverageNodeId assemblyNodeId, Task afterTask);
    private Task StartNewTask(CoverageNodeId assemblyNodeId, string name, Task afterTask, Action action);
    [CompilerGeneratedAttribute]
private void <SetBaseTree>b__20_0(Pair`2<CoverageNodeId, Task> args);
}
[RdExtAttribute]
internal abstract class JetBrains.dotCover.Workspace.Impl.Filtering.Model.FilterConfiguratorBase : RdExtComponentBase {
    [CompilerGeneratedAttribute]
private UProperty`1<bool> <HasCurrentlyExcludedNodes>k__BackingField;
    public UProperty`1<bool> HasCurrentlyExcludedNodes { get; }
    protected FilterConfiguratorBase(Lifetime lifetime, IRdExtComponentsInitializer initializer, IEnumerable`1<IFilterableCoverageTree> filterableCoverageTrees, ICoverageNodesFilterProvider filterProvider, IThreading threading);
    [CompilerGeneratedAttribute]
public sealed virtual UProperty`1<bool> get_HasCurrentlyExcludedNodes();
}
internal interface JetBrains.dotCover.Workspace.Impl.Filtering.Model.IAutoPropertiesFilterProvider {
    public abstract virtual void SetHideAutoProperties(bool value);
}
internal interface JetBrains.dotCover.Workspace.Impl.Filtering.Model.IDocumentsFilterProvider {
    public abstract virtual void SetFilteredDocumentMasks(IEnumerable`1<string> masks);
    public abstract virtual IReadOnlySet`1<int> GetExcludedDocumentIndices();
}
internal interface JetBrains.dotCover.Workspace.Impl.Filtering.Model.IManualNodesFilterProvider {
    public MetadataNodesPresentationSettings PathItemsPresentationSettings { get; }
    public abstract virtual MetadataNodesPresentationSettings get_PathItemsPresentationSettings();
    public abstract virtual void AddExcludedPaths(CoverageTreePath[] paths);
    public abstract virtual void SetIncludedPaths(CoverageTreePath[] paths);
    public abstract virtual void Reset(CoverageTreePath[] includedPaths, CoverageTreePath[] excludedPaths);
    public abstract virtual void Reset();
}
public interface JetBrains.dotCover.Workspace.Impl.Filtering.Model.Interface.ICoverageNodesFilter {
    public abstract virtual bool NodeExcluded(CoverageNodeId parentNodeId, CoverageNodeId nodeId);
}
public interface JetBrains.dotCover.Workspace.Impl.Filtering.Model.Interface.ICoverageNodesFilterProvider {
    public string Id { get; }
    public ISimpleSignal FilterChanged { get; }
    public abstract virtual string get_Id();
    public abstract virtual bool IsActive(ICoverageTreeBase coverageTree);
    public abstract virtual ICoverageNodesFilter GetFilter(ICoverageTreeBase coverageTree);
    public abstract virtual ISimpleSignal get_FilterChanged();
}
public interface JetBrains.dotCover.Workspace.Impl.Filtering.Model.Interface.IFilterableCoverageTree {
    public abstract virtual bool HasExcludedNodes(string filterProviderId);
}
[RdExtAttribute]
[SnapshotModelComponentAttribute]
internal class JetBrains.dotCover.Workspace.Impl.Filtering.Model.ManualNodesFilterConfigurator : FilterConfiguratorBase {
    private Lifetime myLifetime;
    private ICoverageTree myCoverageTree;
    private IMetadataBasedCoverageTree myMetadataBasedCoverageTree;
    private IManualNodesFilterProvider myManualNodesFilterProvider;
    private IRealtimeRequestsProcessor myRealtimeRequestsProcessor;
    private IProgressSubmitter myProgressSubmitter;
    private ILogger myLogger;
    [CompilerGeneratedAttribute]
private UListEvents`1<CoverageNodeId> <NodesForbiddenForExclude>k__BackingField;
    [CompilerGeneratedAttribute]
private UListEvents`1<CoverageNodeId> <NodesForbiddenForExcludeAllExcept>k__BackingField;
    [CompilerGeneratedAttribute]
private UProperty`1<CoverageTreePath[]> <ExcludedPaths>k__BackingField;
    [CompilerGeneratedAttribute]
private UProperty`1<CoverageTreePath[]> <IncludedPaths>k__BackingField;
    public UListEvents`1<CoverageNodeId> NodesForbiddenForExclude { get; }
    public UListEvents`1<CoverageNodeId> NodesForbiddenForExcludeAllExcept { get; }
    public UProperty`1<CoverageTreePath[]> ExcludedPaths { get; }
    public UProperty`1<CoverageTreePath[]> IncludedPaths { get; }
    public ManualNodesFilterConfigurator(Lifetime lifetime, IRdExtComponentsInitializer initializer, ICoverageTree coverageTree, IMetadataBasedCoverageTree metadataBasedCoverageTree, IEnumerable`1<IFilterableCoverageTree> filterableCoverageTrees, IManualNodesFilterProvider manualNodesFilterProvider, IContainerInitializer containerInitializer, IRealtimeRequestsProcessor realtimeRequestsProcessor, IProgressSubmitter progressSubmitter, IThreading threading, ILoggerProvider loggerProvider);
    [CompilerGeneratedAttribute]
public sealed virtual UListEvents`1<CoverageNodeId> get_NodesForbiddenForExclude();
    public sealed virtual Task`1<CoverageNodeId[]> GetOptimizedExcludedNodes(CoverageNodeId[] nodeIds, ProgressId progressId);
    [AsyncStateMachineAttribute("JetBrains.dotCover.Workspace.Impl.Filtering.Model.ManualNodesFilterConfigurator/<ExcludeNodes>d__12")]
public sealed virtual Task ExcludeNodes(CoverageNodeId[] nodeIds, ProgressId progressId);
    [CompilerGeneratedAttribute]
public sealed virtual UListEvents`1<CoverageNodeId> get_NodesForbiddenForExcludeAllExcept();
    [AsyncStateMachineAttribute("JetBrains.dotCover.Workspace.Impl.Filtering.Model.ManualNodesFilterConfigurator/<ExcludeAllNodesExcept>d__16")]
public sealed virtual Task ExcludeAllNodesExcept(CoverageNodeId[] nodeIds, ProgressId progressId);
    public sealed virtual Task ResetExcludedNodes();
    public sealed virtual Task SetExcludedAndIncludedPaths(CoverageTreePath[] excludedPaths, CoverageTreePath[] includedPaths);
    [CompilerGeneratedAttribute]
public sealed virtual UProperty`1<CoverageTreePath[]> get_ExcludedPaths();
    [CompilerGeneratedAttribute]
public sealed virtual UProperty`1<CoverageTreePath[]> get_IncludedPaths();
    private List`1<CoverageNodeId> OptimizeExcludedNodesCollection(CoverageNodeId[] nodeIds, IProgressIndicator progress);
    private List`1<CoverageNodeId> OptimizeIncludedNodesCollection(CoverageNodeId[] nodeIds, IProgressIndicator progress);
    private CoverageTreePath[] BuildNodePaths(List`1<CoverageNodeId> nodeIds, IProgressIndicator progress);
    private String[] BuildPathItems(ICoverageTreeBase coverageTree, CoverageNodeId nodeId);
    private IReadOnlyList`1<CoverageNodeId> GetAssemblyNodesByProjectNode(CoverageNodeId projectNodeId);
    [CompilerGeneratedAttribute]
private CoverageTreePath <BuildNodePaths>b__27_0(CoverageNodeId id);
}
[SnapshotModelComponentAttribute]
internal class JetBrains.dotCover.Workspace.Impl.Filtering.Model.ManualNodesFilterProvider : object {
    private String[][] modreq(System.Runtime.CompilerServices.IsVolatile) myMetadataBasedCoverageTreeIncludedPaths;
    private String[][] modreq(System.Runtime.CompilerServices.IsVolatile) myMetadataBasedCoverageTreeExcludedPaths;
    private String[][] modreq(System.Runtime.CompilerServices.IsVolatile) myCoverageTreeIncludedPaths;
    private String[][] modreq(System.Runtime.CompilerServices.IsVolatile) myCoverageTreeExcludedPaths;
    [CompilerGeneratedAttribute]
private ISimpleSignal <FilterChanged>k__BackingField;
    [CompilerGeneratedAttribute]
private MetadataNodesPresentationSettings <PathItemsPresentationSettings>k__BackingField;
    public string Id { get; }
    public ISimpleSignal FilterChanged { get; }
    public MetadataNodesPresentationSettings PathItemsPresentationSettings { get; }
    public ManualNodesFilterProvider(Lifetime lifetime);
    public sealed virtual string get_Id();
    public sealed virtual bool IsActive(ICoverageTreeBase coverageTree);
    public sealed virtual ICoverageNodesFilter GetFilter(ICoverageTreeBase coverageTree);
    [CompilerGeneratedAttribute]
public sealed virtual ISimpleSignal get_FilterChanged();
    [CompilerGeneratedAttribute]
public sealed virtual MetadataNodesPresentationSettings get_PathItemsPresentationSettings();
    public sealed virtual void AddExcludedPaths(CoverageTreePath[] paths);
    public sealed virtual void SetIncludedPaths(CoverageTreePath[] paths);
    public sealed virtual void Reset(CoverageTreePath[] includedPaths, CoverageTreePath[] excludedPaths);
    public sealed virtual void Reset();
}
[ExtensionAttribute]
internal static class JetBrains.dotCover.Workspace.Impl.Filtering.Model.NodePathItemsBuilder : object {
    [ExtensionAttribute]
public static string GetNodePathItem(ICoverageTreeBase coverageTree, CoverageNodeId nodeId, ICoverageNodeInfo nodeInfo, MetadataNodesPresentationSettings settings);
}
internal interface JetBrains.dotCover.Workspace.Impl.Filtering.Model.TargetFrameworkFilter.ITargetFrameworkFilterProvider {
    public abstract virtual void ExcludeTargetFramework(TargetFrameworkId targetFrameworkId);
    public abstract virtual void IncludeTargetFramework(TargetFrameworkId targetFrameworkId);
    public abstract virtual void Reset(IEnumerable`1<TargetFrameworkId> targetFrameworkIds);
}
internal class JetBrains.dotCover.Workspace.Impl.Filtering.Model.TargetFrameworkFilter.TargetFrameworkFilter : object {
    private ICoverageTreeBase myCoverageTree;
    private IReadOnlySet`1<TargetFrameworkId> myExcludedTargetFrameworks;
    public TargetFrameworkFilter(ICoverageTreeBase coverageTree, IReadOnlySet`1<TargetFrameworkId> targetFrameworks);
    public sealed virtual bool NodeExcluded(CoverageNodeId parentNodeId, CoverageNodeId nodeId);
    public sealed virtual void Dispose();
}
[RdExtAttribute]
[SnapshotModelComponentAttribute]
internal class JetBrains.dotCover.Workspace.Impl.Filtering.Model.TargetFrameworkFilter.TargetFrameworkFilterConfigurator : FilterConfiguratorBase {
    private ITargetFrameworkFilterProvider myTargetFrameworkFilterProvider;
    private IModuleStatSection myModuleStatSection;
    [CompilerGeneratedAttribute]
private UProperty`1<TargetFrameworkId[]> <AllTargetFrameworks>k__BackingField;
    public UProperty`1<TargetFrameworkId[]> AllTargetFrameworks { get; }
    public TargetFrameworkFilterConfigurator(Lifetime lifetime, IRdExtComponentsInitializer initializer, ICoverageSnapshot snapshot, IEnumerable`1<IFilterableCoverageTree> filterableCoverageTrees, ITargetFrameworkFilterProvider targetFrameworkFilterProvider, IThreading threading);
    [CompilerGeneratedAttribute]
public sealed virtual UProperty`1<TargetFrameworkId[]> get_AllTargetFrameworks();
    public sealed virtual Task ExcludeTargetFramework(TargetFrameworkId targetFrameworkId);
    public sealed virtual Task IncludeTargetFramework(TargetFrameworkId targetFrameworkId);
    public sealed virtual Task Reset(IEnumerable`1<TargetFrameworkId> targetFrameworkIds);
    private void UpdateAllTargetFrameworks();
    [CompilerGeneratedAttribute]
private void <.ctor>b__2_0(CumulativeSnapshotChangedEventArgs _);
}
[SnapshotModelComponentAttribute]
internal class JetBrains.dotCover.Workspace.Impl.Filtering.Model.TargetFrameworkFilter.TargetFrameworkFilterProvider : object {
    private JetHashSet`1 modreq(System.Runtime.CompilerServices.IsVolatile) myExcludedTargetFrameworks;
    [CompilerGeneratedAttribute]
private ISimpleSignal <FilterChanged>k__BackingField;
    public string Id { get; }
    public ISimpleSignal FilterChanged { get; }
    public TargetFrameworkFilterProvider(Lifetime lifetime);
    public sealed virtual string get_Id();
    [CompilerGeneratedAttribute]
public sealed virtual ISimpleSignal get_FilterChanged();
    public sealed virtual bool IsActive(ICoverageTreeBase coverageTree);
    public sealed virtual ICoverageNodesFilter GetFilter(ICoverageTreeBase coverageTree);
    public sealed virtual void ExcludeTargetFramework(TargetFrameworkId targetFrameworkId);
    public sealed virtual void IncludeTargetFramework(TargetFrameworkId targetFrameworkId);
    public sealed virtual void Reset(IEnumerable`1<TargetFrameworkId> targetFrameworkIds);
}
[RdExtAttribute]
[SnapshotModelComponentAttribute]
internal class JetBrains.dotCover.Workspace.Impl.Grouping.Model.NamespaceGroupingConfigurator : RdExtComponentBase {
    [CompilerGeneratedAttribute]
private UProperty`1<bool> <GroupingEnabled>k__BackingField;
    public UProperty`1<bool> GroupingEnabled { get; }
    public NamespaceGroupingConfigurator(Lifetime lifetime, IRdExtComponentsInitializer initializer);
    [CompilerGeneratedAttribute]
public sealed virtual UProperty`1<bool> get_GroupingEnabled();
}
[SnapshotModelComponentAttribute]
[ThreadSafeAttribute]
internal class JetBrains.dotCover.Workspace.Impl.Grouping.Model.NamespaceGroupingCoverageTree : CoverageTreeWrapper {
    private ILogger myLogger;
    private Lifetime myLifetime;
    private INamespaceGroupingConfigurator myConfigurator;
    private ICoverageNodeIdFactory myCoverageNodeIdFactory;
    private IThreading myThreading;
    private IMetadataBasedCoverageTreeBase myBaseTree;
    private ConcurrentDictionary`2<CoverageNodeId, CoverageNode> myNamespaceNodes;
    private ConcurrentDictionary`2<CoverageNodeId, List`1<CoverageNodeId>> myGroupingChildren;
    private ConcurrentDictionary`2<CoverageNodeId, CoverageNodeId> myGroupingParents;
    private object myTasksAccess;
    private Dictionary`2<CoverageNodeId, CancellationTokenSource> myUpdateAssemblyGroupingCts;
    private Dictionary`2<CoverageNodeId, CancellationTokenSource> myUpdateAssemblyCoverageCts;
    private Dictionary`2<CoverageNodeId, Task> myUpdateAssemblyTasks;
    private ConcurrentDictionary`2<CoverageNodeId, Dictionary`2<string, CoverageNodeId>> myNamespaceNodeNameToIdMaps;
    [CompilerGeneratedAttribute]
private ISignal`1<Pair`2<CoverageNodeId, Task>> <AssemblyModificationStarted>k__BackingField;
    public int EstimatedNodesNumber { get; }
    public int AssemblyNodesCount { get; }
    public ISignal`1<Pair`2<CoverageNodeId, Task>> AssemblyModificationStarted { get; }
    public int Priority { get; }
    public NamespaceGroupingCoverageTree(Lifetime lifetime, INamespaceGroupingConfigurator configurator, ICoverageNodeIdFactory coverageNodeIdFactory, IThreading threading, ILoggerProvider loggerProvider);
    public virtual ICoverageNodeChildrenEnumerator`1<T> GetChildrenEnumerator(CoverageNodeChildrenVisitor`1<T> nodeVisitor);
    public virtual ICoverageNodeParentsEnumerator`1<T> GetParentsEnumerator(CoverageNodeParentsVisitor`1<T> nodeVisitor);
    public virtual bool ContainsNode(CoverageNodeId nodeId);
    public virtual ICoverageNodeInfo TryGetNodeInfo(CoverageNodeId nodeId);
    public virtual ICoverageNodeDetails TryGetNodeDetails(CoverageNodeId nodeId);
    public virtual string TryGetShortPresentableName(CoverageNodeId nodeId);
    public virtual string TryGetFullPresentableName(CoverageNodeId nodeId);
    public virtual string TryGetCustomPresentableName(CoverageNodeId nodeId, MetadataNodesPresentationSettings presentationSettings);
    public virtual string TryGetAnnotation(CoverageNodeId nodeId);
    public virtual bool TryPutNodeData(CoverageNodeId nodeId, CoverageNodeDataKey`1<T> key, T value);
    public virtual T TryGetNodeData(CoverageNodeId nodeId, CoverageNodeDataKey`1<T> key);
    public virtual int get_EstimatedNodesNumber();
    public virtual Task WhenCurrentModificationFinished();
    public sealed virtual int get_AssemblyNodesCount();
    public sealed virtual CoverageNodeId[] GetAllAssemblyNodes();
    public sealed virtual CoverageNodeId TryGetAssemblyNodeId(Nullable`1<Guid> mvid, string assemblyName, TargetFrameworkId targetFrameworkId);
    public sealed virtual CoverageNodeId TryGetMetadataEntityNodeId(MetadataId metadataId, bool preferOwnCoverageNode, Boolean& isOwnCoverageNode);
    [CompilerGeneratedAttribute]
public sealed virtual ISignal`1<Pair`2<CoverageNodeId, Task>> get_AssemblyModificationStarted();
    public sealed virtual int get_Priority();
    public sealed virtual void SetBaseTree(IMetadataBasedCoverageTreeBase baseTree);
    private Task OnBaseAssemblyModificationStarted(CoverageNodeId assemblyNodeId, Task modificationTask);
    protected virtual Task OnBaseStructureModificationStarted(Task modificationTask);
    protected virtual Task OnBaseDetailsModificationStarted(Task modificationTask);
    private void ClearGroupingNodesInfoRec(CoverageNodeId parentNodeId, CancellationToken cancellationToken);
    private void UpdateAssemblyGrouping(CoverageNodeId assemblyNodeId, CancellationToken cancellationToken);
    private static bool NamespaceGroupingRequired(HierarchicalNamespaceInfo namespaceInfo);
    private void UpdateNodeChildrenGroupingRec(CoverageNodeId nodeId, HierarchicalNamespaceInfo rootNamespaceInfo, Dictionary`2<string, CoverageNodeId> namespaceNodeNameToIdMap, CancellationToken cancellationToken);
    private void UpdateNamespaceNameToIdMapRec(List`1<CoverageNodeId> nodeIds, Dictionary`2<string, CoverageNodeId> map);
    private void UpdateNamespaceNodesCoverageData(CoverageNodeId assemblyNodeId, CancellationToken cancellationToken);
    private void UpdateNamespaceNodesCoverageDataRec(List`1<CoverageNodeId> nodeIds, CancellationToken cancellationToken);
    private Task StartNewTask(CoverageNodeId assemblyNodeId, string name, Task afterTask, Action action);
    [CompilerGeneratedAttribute]
private void <.ctor>b__14_0();
    [CompilerGeneratedAttribute]
private void <SetBaseTree>b__39_0(Pair`2<CoverageNodeId, Task> args);
    [CompilerGeneratedAttribute]
private CoverageNodeDetails <UpdateNamespaceNodesCoverageDataRec>b__49_0(CoverageNodeDetails result, CoverageNodeId childNodeId);
}
[WorkspaceModelComponentAttribute]
internal class JetBrains.dotCover.Workspace.Impl.HotSpots.Model.HotSpotsBuildConfigurator : object {
    [CompilerGeneratedAttribute]
private bool <SuppressBuild>k__BackingField;
    public bool SuppressBuild { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual bool get_SuppressBuild();
    [CompilerGeneratedAttribute]
public sealed virtual void set_SuppressBuild(bool value);
}
public interface JetBrains.dotCover.Workspace.Impl.HotSpots.Model.Interface.IHotSpotsBuildConfigurator {
    public bool SuppressBuild { get; public set; }
    public abstract virtual bool get_SuppressBuild();
    public abstract virtual void set_SuppressBuild(bool value);
}
public interface JetBrains.dotCover.Workspace.Impl.HotSpots.Model.Interface.IRiskMetricsCollector {
    public bool AreMetricsAvailable { get; }
    public ISimpleSignal MetricsChanged { get; }
    public abstract virtual bool get_AreMetricsAvailable();
    [CanBeNullAttribute]
public abstract virtual TypeRiskInfo TryGetTypeRiskInfo(CoverageNodeId typNodeId);
    public abstract virtual ISimpleSignal get_MetricsChanged();
}
public class JetBrains.dotCover.Workspace.Impl.HotSpots.Model.Interface.MethodRiskInfo : object {
    [CompilerGeneratedAttribute]
private CoverageNodeId <MethodNodeId>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CyclomaticComplexity>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RiskMetric>k__BackingField;
    public CoverageNodeId MethodNodeId { get; }
    public int CyclomaticComplexity { get; }
    public int RiskMetric { get; }
    public MethodRiskInfo(CoverageNodeId methodNodeId, int cyclomaticComplexity, int riskMetric);
    [CompilerGeneratedAttribute]
public CoverageNodeId get_MethodNodeId();
    [CompilerGeneratedAttribute]
public int get_CyclomaticComplexity();
    [CompilerGeneratedAttribute]
public int get_RiskMetric();
}
public class JetBrains.dotCover.Workspace.Impl.HotSpots.Model.Interface.TypeRiskInfo : object {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<MethodRiskInfo> <MethodsOrderedByRiskMetric>k__BackingField;
    public IReadOnlyList`1<MethodRiskInfo> MethodsOrderedByRiskMetric { get; }
    public TypeRiskInfo(IReadOnlyList`1<MethodRiskInfo> methodsOrderedByRiskMetric);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<MethodRiskInfo> get_MethodsOrderedByRiskMetric();
}
[SnapshotModelComponentAttribute]
[ThreadSafeAttribute]
internal class JetBrains.dotCover.Workspace.Impl.HotSpots.Model.RiskMetricsCollector : object {
    private ILogger myLogger;
    private IHotSpotsBuildConfigurator myHotSpotsBuildConfigurator;
    private IMetadataBasedCoverageTreeBase myMetadataBasedCoverageTree;
    private IThreading myThreading;
    private ICyclomaticComplexitySection myCyclomaticComplexitySection;
    private ICoverageNodeChildrenEnumerator`1<List`1<MethodRiskInfo>> myMethodsRiskInfoCollector;
    private ConcurrentDictionary`2 modreq(System.Runtime.CompilerServices.IsVolatile) myTypesRiskInfo;
    private object myTaskAccess;
    private CancellationTokenSource myTaskCancellationTokenSources;
    private Task myTask;
    private ReadonlyToken myReadonlyToken;
    [CompilerGeneratedAttribute]
private ISimpleSignal <MetricsChanged>k__BackingField;
    public bool AreMetricsAvailable { get; }
    public ISimpleSignal MetricsChanged { get; }
    public RiskMetricsCollector(Lifetime lifetime, IHotSpotsBuildConfigurator hotSpotsBuildConfigurator, ICoverageSnapshot snapshot, IModifiableMetadataBasedCoverageTree metadataBasedCoverageTree, IContainerInitializer containerInitializer, IThreading threading, ILoggerProvider loggerProvider);
    private void OnUpdateRequired(Task afterTask);
    private void BuildTypesRiskInfo(CancellationToken cancellationToken);
    private bool CollectMethodsRiskInfo(CoverageNodeId parentId, CoverageNodeId nodeId, List`1<MethodRiskInfo> result, ICoverageNodeChildrenEnumerator`1<List`1<MethodRiskInfo>> ce, Boolean& stop);
    internal static int CalculateRiskMetric(UInt32 complexity, int coverage);
    public sealed virtual bool get_AreMetricsAvailable();
    public sealed virtual TypeRiskInfo TryGetTypeRiskInfo(CoverageNodeId typeNodeId);
    [CompilerGeneratedAttribute]
public sealed virtual ISimpleSignal get_MetricsChanged();
    [CompilerGeneratedAttribute]
private Task <.ctor>b__11_0();
}
[RdExtAttribute]
[SnapshotModelComponentAttribute]
internal class JetBrains.dotCover.Workspace.Impl.HotSpots.Model.RiskMetricsProvider : RdExtComponentBase {
    private Lifetime myLifetime;
    private IRiskMetricsCollector myRiskMetricsCollector;
    private IMetadataBasedCoverageTree myMetadataBasedCoverageTree;
    private ICoverageTree myCoverageTree;
    private IRealtimeRequestsProcessor myRealtimeRequestsProcessor;
    private ILogger myLogger;
    [CompilerGeneratedAttribute]
private UProperty`1<bool> <AreMetricsAvailable>k__BackingField;
    [CompilerGeneratedAttribute]
private USignal`1<Unit> <MetricsChanged>k__BackingField;
    public UProperty`1<bool> AreMetricsAvailable { get; }
    public USignal`1<Unit> MetricsChanged { get; }
    public RiskMetricsProvider(Lifetime lifetime, IRdExtComponentsInitializer initializer, IRiskMetricsCollector riskMetricsCollector, IMetadataBasedCoverageTree metadataBasedCoverageTree, ICoverageTree coverageTree, IRealtimeRequestsProcessor realtimeRequestsProcessor, ILoggerProvider loggerProvider);
    [CompilerGeneratedAttribute]
public sealed virtual UProperty`1<bool> get_AreMetricsAvailable();
    public sealed virtual Task`1<IEnumerable`1<TypeRiskMetricPresentableInfo>> GetTypesRiskMetrics();
    public sealed virtual Task`1<TypeRiskMetricPresentableDetails> TryGetTypeRiskMetricDetails(CoverageNodeId typeNodeId);
    private MethodRiskInfo TryGetRiskiestMethodInfo(IReadOnlyList`1<MethodRiskInfo> methodsOrderedByRiskMetric);
    [CompilerGeneratedAttribute]
public sealed virtual USignal`1<Unit> get_MetricsChanged();
    [CompilerGeneratedAttribute]
private void <.ctor>b__6_1(Task task);
    [CompilerGeneratedAttribute]
private void <.ctor>b__6_2(Task _);
    [CompilerGeneratedAttribute]
private IEnumerable`1<TypeRiskMetricPresentableInfo> <GetTypesRiskMetrics>b__10_0();
}
[WorkspaceModelComponentAttribute]
public class JetBrains.dotCover.Workspace.Impl.Infrastructure.Model.Interface.FakeProgressSubmitter : object {
    public sealed virtual IProgressIndicator GetProgressIndicator(ProgressId progressId);
}
[WorkspaceModelComponentAttribute]
public class JetBrains.dotCover.Workspace.Impl.Infrastructure.Model.Interface.FakeRdExtComponentsInitializer : object {
    public sealed virtual void Init(RdExtBase component, Lifetime lifetime);
}
public interface JetBrains.dotCover.Workspace.Impl.Infrastructure.Model.Interface.IProgressSubmitter {
    public abstract virtual IProgressIndicator GetProgressIndicator(ProgressId progressId);
}
public interface JetBrains.dotCover.Workspace.Impl.Infrastructure.Model.Interface.IRdExtComponentsInitializer {
    public abstract virtual void Init(RdExtBase component, Lifetime lifetime);
}
internal interface JetBrains.dotCover.Workspace.Impl.Infrastructure.Model.Interface.IRealtimeRequestsProcessor {
    public abstract virtual Task`1<TRes> Process(Lifetime lifetime, ILogger logger, Func`1<TRes> action);
}
public interface JetBrains.dotCover.Workspace.Impl.Infrastructure.Model.Interface.IWebProxyFactory {
    public abstract virtual IWebProxy CreateProxy(CustomWebProxySettings settings);
}
[WorkspaceModelComponentAttribute]
internal class JetBrains.dotCover.Workspace.Impl.Infrastructure.Model.RealtimeRequestsProcessor : object {
    private IThreading myThreading;
    public RealtimeRequestsProcessor(IThreading threading);
    public sealed virtual Task`1<TRes> Process(Lifetime lifetime, ILogger logger, Func`1<TRes> action);
}
[ShellComponentAttribute]
internal class JetBrains.dotCover.Workspace.Impl.Infrastructure.Model.WebProxyFactory : object {
    private ILogger myLogger;
    public WebProxyFactory(ILoggerProvider loggerProvider);
    public sealed virtual IWebProxy CreateProxy(CustomWebProxySettings settings);
    private static IWebProxy GetSystemWebProxy();
}
[RdExtAttribute]
[SnapshotModelComponentAttribute]
internal class JetBrains.dotCover.Workspace.Impl.InternalToolkit.DocumentRangeSectionExplorer.DocumentRangeSectionExplorerModel : RdExtComponentBase {
    [CompilerGeneratedAttribute]
private UProperty`1<DocumentRangeEntry[]> <Entries>k__BackingField;
    public UProperty`1<DocumentRangeEntry[]> Entries { get; }
    public DocumentRangeSectionExplorerModel(Lifetime lifetime, IRdExtComponentsInitializer initializer, ICoverageSnapshot coverageSnapshot);
    [CompilerGeneratedAttribute]
public sealed virtual UProperty`1<DocumentRangeEntry[]> get_Entries();
}
[RdExtAttribute]
[SnapshotModelComponentAttribute]
internal class JetBrains.dotCover.Workspace.Impl.InternalToolkit.EnvironmentSectionExplorer.EnvironmentSectionExplorerModel : RdExtComponentBase {
    [CompilerGeneratedAttribute]
private UProperty`1<EnvironmentSectionEntry[]> <Entries>k__BackingField;
    public UProperty`1<EnvironmentSectionEntry[]> Entries { get; }
    public EnvironmentSectionExplorerModel(Lifetime lifetime, IRdExtComponentsInitializer initializer, ICoverageSnapshot snapshot);
    [CompilerGeneratedAttribute]
public sealed virtual UProperty`1<EnvironmentSectionEntry[]> get_Entries();
}
[RdExtAttribute]
[SnapshotModelComponentAttribute]
internal class JetBrains.dotCover.Workspace.Impl.InternalToolkit.FunctionInfoExplorer.FunctionInfoExplorerModel : RdExtComponentBase {
    private static string NotResolved;
    private SignaturePresenter mySignaturePresenter;
    private Lifetime myLifetime;
    private ICoverageSnapshot mySnapshot;
    private IThreading myThreading;
    [CompilerGeneratedAttribute]
private UProperty`1<string> <SnapshotPath>k__BackingField;
    public UProperty`1<string> SnapshotPath { get; }
    public FunctionInfoExplorerModel(Lifetime lifetime, IRdExtComponentsInitializer initializer, ICoverageSnapshot snapshot, IThreading threading);
    [CompilerGeneratedAttribute]
public sealed virtual UProperty`1<string> get_SnapshotPath();
    [AsyncStateMachineAttribute("JetBrains.dotCover.Workspace.Impl.InternalToolkit.FunctionInfoExplorer.FunctionInfoExplorerModel/<GetTotalMethodsCount>d__9")]
public sealed virtual Task`1<int> GetTotalMethodsCount();
    [AsyncStateMachineAttribute("JetBrains.dotCover.Workspace.Impl.InternalToolkit.FunctionInfoExplorer.FunctionInfoExplorerModel/<FilterFunctions>d__10")]
public sealed virtual Task`1<FunctionInfo[]> FilterFunctions(UInt32[] assemblyMetadataIndices, Nullable`1<UInt32> token, string nameFilter);
    [AsyncStateMachineAttribute("JetBrains.dotCover.Workspace.Impl.InternalToolkit.FunctionInfoExplorer.FunctionInfoExplorerModel/<GetExtendedFunctionInfo>d__11")]
public sealed virtual Task`1<ExtendedFunctionInfo> GetExtendedFunctionInfo(FunctionInfo functionInfo);
    [AsyncStateMachineAttribute("JetBrains.dotCover.Workspace.Impl.InternalToolkit.FunctionInfoExplorer.FunctionInfoExplorerModel/<GetAssembliesData>d__12")]
public sealed virtual Task`1<AssemblyData[]> GetAssembliesData();
    private MetadataId CreateMetadataId(FunctionInfo functionInfo);
    private static string GetAssemblyName(AssemblyNameInfo data);
    private string GetMethodPresentableName(IMetadataMethod method);
    private static RangeData[] GetRanges(IEnumerable`1<SingleStatementData> singleStatementDatas, Func`2<int, string> documentUrlGetter);
    private static String[] GetDeclaredFileNames(MethodData methodData, Func`2<int, string> documentUrlGetter);
    private static Nullable`1<int> GetFilteredStatements(MethodData methodData);
    private static Nullable`1<int> GetTotalStatements(MethodData methodData);
    private static Nullable`1<Guid> GetMvid(IMetadataMethod method);
    private static string GetAssemblyName(IMetadataMethod method);
    private static Nullable`1<UInt32> GetCyclomaticComplexity(ICoverageSnapshot coverageSnapshot, MetadataId metadataId);
    private static string GetAssemblyName(IMetadataAssembly metadataAssembly);
    [CompilerGeneratedAttribute]
private string <GetExtendedFunctionInfo>g__DocumentUrlGetter|11_0(int i);
}
public static class JetBrains.dotCover.Workspace.Impl.InternalToolkit.FunctionInfoExplorer.RegexFactory : object {
    private static String[] SpecialCharacters;
    private static RegexFactory();
    private static string ConvertFragment(string fragment);
    public static Regex Create(string pattern);
}
[RdExtAttribute]
[SnapshotModelComponentAttribute]
internal class JetBrains.dotCover.Workspace.Impl.InternalToolkit.GroupNameIndexSectionExplorer.GroupNameIndexSectionExplorerModel : RdExtComponentBase {
    [CompilerGeneratedAttribute]
private UProperty`1<GroupNameIndexEntry[]> <Entries>k__BackingField;
    public UProperty`1<GroupNameIndexEntry[]> Entries { get; }
    public GroupNameIndexSectionExplorerModel(Lifetime lifetime, IRdExtComponentsInitializer initializer, ICoverageSnapshot coverageSnapshot);
    [CompilerGeneratedAttribute]
public sealed virtual UProperty`1<GroupNameIndexEntry[]> get_Entries();
}
[RdExtAttribute]
[SnapshotModelComponentAttribute]
internal class JetBrains.dotCover.Workspace.Impl.InternalToolkit.ModuleStatSectionExplorer.ModuleStatSectionExplorerModel : RdExtComponentBase {
    private Lifetime myLifetime;
    private ICoverageSnapshot mySnapshot;
    private IThreading myThreading;
    [CompilerGeneratedAttribute]
private UProperty`1<string> <SnapshotPath>k__BackingField;
    [CompilerGeneratedAttribute]
private UProperty`1<bool> <IsModuleStatSectionAvailable>k__BackingField;
    public UProperty`1<string> SnapshotPath { get; }
    public UProperty`1<bool> IsModuleStatSectionAvailable { get; }
    public ModuleStatSectionExplorerModel(Lifetime lifetime, IRdExtComponentsInitializer initializer, ICoverageSnapshot snapshot, IThreading threading);
    [CompilerGeneratedAttribute]
public sealed virtual UProperty`1<string> get_SnapshotPath();
    [CompilerGeneratedAttribute]
public sealed virtual UProperty`1<bool> get_IsModuleStatSectionAvailable();
    [AsyncStateMachineAttribute("JetBrains.dotCover.Workspace.Impl.InternalToolkit.ModuleStatSectionExplorer.ModuleStatSectionExplorerModel/<GetModulesLoadInfo>d__10")]
public sealed virtual Task`1<ModuleLoadInfo[]> GetModulesLoadInfo();
}
[RdExtAttribute]
[SnapshotModelComponentAttribute]
internal class JetBrains.dotCover.Workspace.Impl.InternalToolkit.StatementCoverageIndexSectionExplorer.StatementCoverageIndexSectionExplorerModel : RdExtComponentBase {
    private IThreading myThreading;
    private Lifetime myLifetime;
    private ICoverageSnapshot myCoverageSnapshot;
    [CompilerGeneratedAttribute]
private UProperty`1<SStatementCoverageIndexEntry[]> <TotalEntries>k__BackingField;
    [CompilerGeneratedAttribute]
private UProperty`1<GroupIndexEntry[]> <GroupIndices>k__BackingField;
    public UProperty`1<SStatementCoverageIndexEntry[]> TotalEntries { get; }
    public UProperty`1<GroupIndexEntry[]> GroupIndices { get; }
    public StatementCoverageIndexSectionExplorerModel(Lifetime lifetime, IRdExtComponentsInitializer initializer, ICoverageSnapshot coverageSnapshot, IThreading threading);
    [CompilerGeneratedAttribute]
public sealed virtual UProperty`1<SStatementCoverageIndexEntry[]> get_TotalEntries();
    [CompilerGeneratedAttribute]
public sealed virtual UProperty`1<GroupIndexEntry[]> get_GroupIndices();
    [AsyncStateMachineAttribute("JetBrains.dotCover.Workspace.Impl.InternalToolkit.StatementCoverageIndexSectionExplorer.StatementCoverageIndexSectionExplorerModel/<GetGroupEntries>d__10")]
public sealed virtual Task`1<SStatementCoverageIndexEntry[]> GetGroupEntries(int groupIndex);
    private static SStatementCoverageIndexEntry[] GetEntries(ISnapshotSectionCollection sectionCollection);
    private static SStatementDetails[] ConvertDetails(IStatementDetails details);
}
internal class JetBrains.dotCover.Workspace.Impl.RdExtComponentBase : RdExtReflectionBindableBase {
    public RdExtComponentBase(Lifetime lifetime, IRdExtComponentsInitializer initializer);
}
[RdExtAttribute]
[SnapshotModelComponentAttribute]
internal class JetBrains.dotCover.Workspace.Impl.Reporting.Model.FileCoverage.DetailedFileCoverageJsonReportBuilder : FileCoverageReportBuilderBase`1<JsonTextWriter> {
    private ICoverageSnapshot myCoverageSnapshot;
    private IDocumentsFilterProvider myDocumentsFilterProvider;
    private IReportReverseCoverageProvider myReverseCoverageProvider;
    protected bool DetailedReport { get; }
    public DetailedFileCoverageJsonReportBuilder(Lifetime lifetime, IRdExtComponentsInitializer initializer, IProgressSubmitter progressSubmitter, IThreading threading, ILoggerProvider loggerProvider, ICoverageSnapshot coverageSnapshot, IDocumentsFilterProvider documentsFilterProvider, IReportReverseCoverageProvider reportReverseCoverageProvider);
    protected virtual bool get_DetailedReport();
    protected virtual FileCoverageWriterBase`1<JsonTextWriter> CreateReportWriter(IProgressSubmitter progressSubmitter);
}
[RdExtAttribute]
[SnapshotModelComponentAttribute]
internal class JetBrains.dotCover.Workspace.Impl.Reporting.Model.FileCoverage.DetailedFileCoverageXmlReportBuilder : FileCoverageReportBuilderBase`1<XmlWriter> {
    private IDocumentsFilterProvider myDocumentsFilterProvider;
    private ICoverageSnapshot myCoverageSnapshot;
    private IReportReverseCoverageProvider myReverseCoverageProvider;
    protected bool DetailedReport { get; }
    public DetailedFileCoverageXmlReportBuilder(Lifetime lifetime, IRdExtComponentsInitializer initializer, IProgressSubmitter progressSubmitter, IThreading threading, ILoggerProvider loggerProvider, ICoverageSnapshot coverageSnapshot, IDocumentsFilterProvider documentsFilterProvider, IReportReverseCoverageProvider reportReverseCoverageProvider);
    protected virtual bool get_DetailedReport();
    protected virtual FileCoverageWriterBase`1<XmlWriter> CreateReportWriter(IProgressSubmitter progressSubmitter);
}
[RdExtAttribute]
[SnapshotModelComponentAttribute]
internal class JetBrains.dotCover.Workspace.Impl.Reporting.Model.FileCoverage.FileCoverageJsonReportBuilder : FileCoverageReportBuilderBase`1<JsonTextWriter> {
    private ICoverageSnapshot myCoverageSnapshot;
    private IDocumentsFilterProvider myDocumentsFilterProvider;
    private IReportReverseCoverageProvider myReverseCoverageProvider;
    protected bool DetailedReport { get; }
    public FileCoverageJsonReportBuilder(Lifetime lifetime, IRdExtComponentsInitializer initializer, IProgressSubmitter progressSubmitter, IThreading threading, ILoggerProvider loggerProvider, ICoverageSnapshot coverageSnapshot, IDocumentsFilterProvider documentsFilterProvider, IReportReverseCoverageProvider reportReverseCoverageProvider);
    protected virtual bool get_DetailedReport();
    protected virtual FileCoverageWriterBase`1<JsonTextWriter> CreateReportWriter(IProgressSubmitter progressSubmitter);
}
internal class JetBrains.dotCover.Workspace.Impl.Reporting.Model.FileCoverage.FileCoverageJsonWriter : FileCoverageWriterBase`1<JsonTextWriter> {
    public FileCoverageJsonWriter(IMethodRangeSection methodRangeSection, IStatementDataSection statementDataSection, IDocumentRangeSection documentRangeSection, IDocumentsFilterProvider documentsFilterProvider, IReportReverseCoverageProvider reverseCoverageProvider, IProgressSubmitter progressSubmitter);
    protected virtual JsonTextWriter CreateWriter(TextWriter writer);
    protected virtual void WriteStartDocument(JsonTextWriter writer);
    protected virtual void WriteEndDocument(JsonTextWriter writer);
    protected virtual void WriteRootAttributes(JsonTextWriter writer, ReportFeatures features);
    protected virtual void WriteDocuments(JsonTextWriter writer, IEnumerable`1<ValueTuple`2<int, DocumentData>> documents, Action`2<JsonTextWriter, int> writeExtraDocumentInfo);
    protected virtual void WriteTestLists(JsonTextWriter writer, IEnumerable`1<KeyValuePair`2<ISet`1<int>, int>> testSets);
    protected virtual void WriteTests(JsonTextWriter writer, IEnumerable`1<ValueTuple`4<string, UnitTestElementId, string, int>> tests);
    protected virtual void WritePerDocumentInfo(JsonTextWriter writer, int testSetIndex);
    protected virtual void WritePerMethodInfo(JsonTextWriter writer, IEnumerable`1<ValueTuple`3<LineAndColumn, LineAndColumn, int>> methodInfo);
}
internal abstract class JetBrains.dotCover.Workspace.Impl.Reporting.Model.FileCoverage.FileCoverageReportBuilderBase`1 : RdExtComponentBase {
    private Lifetime myLifetime;
    private IProgressSubmitter myProgressSubmitter;
    private IThreading myThreading;
    private ILogger myLogger;
    protected bool DetailedReport { get; }
    protected FileCoverageReportBuilderBase`1(Lifetime lifetime, IRdExtComponentsInitializer initializer, IProgressSubmitter progressSubmitter, IThreading threading, ILoggerProvider loggerProvider);
    public sealed virtual Task BuildReport(string fileName, ProgressId progressId, ReportFeatures features);
    protected abstract virtual bool get_DetailedReport();
    protected abstract virtual FileCoverageWriterBase`1<TWriter> CreateReportWriter(IProgressSubmitter progressSubmitter);
}
internal abstract class JetBrains.dotCover.Workspace.Impl.Reporting.Model.FileCoverage.FileCoverageWriterBase`1 : object {
    private static int BufferSize;
    private IMethodRangeSection myMethodRangeSection;
    private IStatementDataSection myStatementDataSection;
    private IReportReverseCoverageProvider myReportReverseCoverageProvider;
    private IDocumentRangeSection myDocumentRangeSection;
    private IDocumentsFilterProvider myDocumentsFilterProvider;
    private IProgressSubmitter myProgressSubmitter;
    protected FileCoverageWriterBase`1(IMethodRangeSection methodRangeSection, IStatementDataSection statementDataSection, IDocumentRangeSection documentRangeSection, IDocumentsFilterProvider documentsFilterProvider, IReportReverseCoverageProvider reportReverseCoverageProvider, IProgressSubmitter progressSubmitter);
    public void Write(string fileName, ReportFeatures reportFeatures, ProgressId progressId);
    protected abstract virtual TWriter CreateWriter(TextWriter textWriter);
    protected abstract virtual void WriteStartDocument(TWriter writer);
    protected abstract virtual void WriteEndDocument(TWriter writer);
    protected abstract virtual void WriteRootAttributes(TWriter writer, ReportFeatures features);
    protected abstract virtual void WriteDocuments(TWriter writer, IEnumerable`1<ValueTuple`2<int, DocumentData>> documents, Action`2<TWriter, int> writeExtraDocumentInfo);
    protected abstract virtual void WriteTestLists(TWriter writer, IEnumerable`1<KeyValuePair`2<ISet`1<int>, int>> testSets);
    protected abstract virtual void WriteTests(TWriter writer, IEnumerable`1<ValueTuple`4<string, UnitTestElementId, string, int>> tests);
    protected abstract virtual void WritePerDocumentInfo(TWriter writer, int testSetIndex);
    protected abstract virtual void WritePerMethodInfo(TWriter writer, IEnumerable`1<ValueTuple`3<LineAndColumn, LineAndColumn, int>> methodInfo);
    [IteratorStateMachineAttribute("JetBrains.dotCover.Workspace.Impl.Reporting.Model.FileCoverage.FileCoverageWriterBase`1/<EnumerateDocuments>d__18")]
private IEnumerable`1<ValueTuple`2<int, DocumentData>> EnumerateDocuments(IProgressIndicator progressIndicator);
    [IteratorStateMachineAttribute("JetBrains.dotCover.Workspace.Impl.Reporting.Model.FileCoverage.FileCoverageWriterBase`1/<EnumerateTestSets>d__19")]
private IEnumerable`1<KeyValuePair`2<ISet`1<int>, int>> EnumerateTestSets(ReportContext context, IProgressIndicator progressIndicator);
    [IteratorStateMachineAttribute("JetBrains.dotCover.Workspace.Impl.Reporting.Model.FileCoverage.FileCoverageWriterBase`1/<EnumerateTests>d__20")]
private IEnumerable`1<ValueTuple`4<string, UnitTestElementId, string, int>> EnumerateTests(ReportContext context, IProgressIndicator progressIndicator);
    [IteratorStateMachineAttribute("JetBrains.dotCover.Workspace.Impl.Reporting.Model.FileCoverage.FileCoverageWriterBase`1/<EnumerateCoveredMethodRanges>d__21")]
protected IEnumerable`1<ValueTuple`3<LineAndColumn, LineAndColumn, int>> EnumerateCoveredMethodRanges(ReportContext context, int documentIndex);
    protected int GetTestListIndexForDocument(ReportContext context, int documentIndex);
    protected bool IsCoveredDocument(int documentIndex);
    [CompilerGeneratedAttribute]
private bool <IsCoveredDocument>b__23_0(MetadataId metadataId);
}
[RdExtAttribute]
[SnapshotModelComponentAttribute]
internal class JetBrains.dotCover.Workspace.Impl.Reporting.Model.FileCoverage.FileCoverageXmlReportBuilder : FileCoverageReportBuilderBase`1<XmlWriter> {
    private ICoverageSnapshot myCoverageSnapshot;
    private IDocumentsFilterProvider myDocumentsFilterProvider;
    private IReportReverseCoverageProvider myReverseCoverageProvider;
    protected bool DetailedReport { get; }
    public FileCoverageXmlReportBuilder(Lifetime lifetime, IRdExtComponentsInitializer initializer, IProgressSubmitter progressSubmitter, IThreading threading, ILoggerProvider loggerProvider, ICoverageSnapshot coverageSnapshot, IDocumentsFilterProvider documentsFilterProvider, IReportReverseCoverageProvider reportReverseCoverageProvider);
    protected virtual bool get_DetailedReport();
    protected virtual FileCoverageWriterBase`1<XmlWriter> CreateReportWriter(IProgressSubmitter progressSubmitter);
}
internal class JetBrains.dotCover.Workspace.Impl.Reporting.Model.FileCoverage.FileCoverageXmlWriter : FileCoverageWriterBase`1<XmlWriter> {
    public FileCoverageXmlWriter(IMethodRangeSection methodRangeSection, IStatementDataSection statementDataSection, IDocumentRangeSection documentRangeSection, IDocumentsFilterProvider documentsFilterProvider, IReportReverseCoverageProvider reportReverseCoverageProvider, IProgressSubmitter progressSubmitter);
    protected virtual XmlWriter CreateWriter(TextWriter writer);
    protected virtual void WriteStartDocument(XmlWriter writer);
    protected virtual void WriteEndDocument(XmlWriter writer);
    protected virtual void WriteRootAttributes(XmlWriter writer, ReportFeatures features);
    protected virtual void WriteDocuments(XmlWriter writer, IEnumerable`1<ValueTuple`2<int, DocumentData>> documents, Action`2<XmlWriter, int> writeExtraDocumentInfo);
    protected virtual void WriteTestLists(XmlWriter writer, IEnumerable`1<KeyValuePair`2<ISet`1<int>, int>> testSets);
    protected virtual void WriteTests(XmlWriter writer, IEnumerable`1<ValueTuple`4<string, UnitTestElementId, string, int>> tests);
    protected virtual void WritePerDocumentInfo(XmlWriter writer, int testSetIndex);
    protected virtual void WritePerMethodInfo(XmlWriter writer, IEnumerable`1<ValueTuple`3<LineAndColumn, LineAndColumn, int>> methodInfo);
}
internal class JetBrains.dotCover.Workspace.Impl.Reporting.Model.FileCoverage.ReportContext : object {
    private Dictionary`2<ISet`1<int>, int> myTestSet;
    private JetHashSet`1<int> myTests;
    public IReadOnlyDictionary`2<ISet`1<int>, int> TestSets { get; }
    public IReadOnlySet`1<int> Tests { get; }
    public IReadOnlyDictionary`2<ISet`1<int>, int> get_TestSets();
    public IReadOnlySet`1<int> get_Tests();
    public int GetIndexOfTestSet(IEnumerable`1<int> indices);
}
internal static class JetBrains.dotCover.Workspace.Impl.Reporting.Model.Html.EmbeddedResources : object {
    public static string DotCoverReportCss;
    public static string JQueryDynatreeCss;
    public static string IndexTemplateHtml;
    public static string NoSourceHtml;
    public static string SourceTemplateHtml;
    public static string DotCoverReportJs;
    public static string DotCoverSourceViewJs;
    public static string JQuery132Js;
    public static string JQueryCookie131Js;
    public static string JQueryDynatree124Js;
    public static string JQuerySplitter151Js;
    public static string JQueryUiCustom187Js;
    public static Byte[] DotCoverIcon;
    public static Byte[] DynatreeIcons;
    public static string PercentBarBackground;
    private static EmbeddedResources();
    private static Stream GetResourceStream(string resourceName);
    private static string GetStringResource(string resourceName);
    private static Byte[] GetStreamResource(string resourceName);
}
internal class JetBrains.dotCover.Workspace.Impl.Reporting.Model.Html.FileChecksumCalculator : object {
    public sealed virtual Byte[] Checksum(FileSystemPath file, Guid algorithmId);
}
internal class JetBrains.dotCover.Workspace.Impl.Reporting.Model.Html.FileDownloader : object {
    private static ILogger ourLogger;
    private IWebProxy myProxySettings;
    public FileDownloader(IWebProxy proxySettings);
    private static FileDownloader();
    public sealed virtual bool TryDownload(Uri fileUri, FileSystemPath targetFile);
    private bool CoreDownload(Uri fileUri, FileSystemPath targetFile);
    private HttpWebRequest CreateRequest(Uri fileUri);
}
internal class JetBrains.dotCover.Workspace.Impl.Reporting.Model.Html.FileExistenceAnalyzer : object {
    private static ILogger ourLogger;
    private List`1<FileSystemPath> myNonexistentPathPrefixes;
    private static FileExistenceAnalyzer();
    public sealed virtual bool FileExists(FileSystemPath filePath);
    private void UpdateNonexistentPathPrefixes(FileSystemPath filePath);
    internal static FileSystemPath GetNonexistentPathPrefix(FileSystemPath filePath);
}
internal class JetBrains.dotCover.Workspace.Impl.Reporting.Model.Html.HtmlNodeDetails : object {
    [CompilerGeneratedAttribute]
private string <PresentableName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasCoveragePercent>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CoveragePercent>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasIconIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private int <IconIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasSourceInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private SectionIndex`1<IMetadataSection> <MetadataIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DocumentIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Line>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Column>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ChildrenNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private int <FirstChildIndex>k__BackingField;
    public string PresentableName { get; public set; }
    public bool HasCoveragePercent { get; public set; }
    public int CoveragePercent { get; public set; }
    public bool HasIconIndex { get; public set; }
    public int IconIndex { get; public set; }
    public bool HasSourceInfo { get; public set; }
    public SectionIndex`1<IMetadataSection> MetadataIndex { get; public set; }
    public int DocumentIndex { get; public set; }
    public int Line { get; public set; }
    public int Column { get; public set; }
    public int ChildrenNumber { get; public set; }
    public int FirstChildIndex { get; public set; }
    [CompilerGeneratedAttribute]
public string get_PresentableName();
    [CompilerGeneratedAttribute]
public void set_PresentableName(string value);
    [CompilerGeneratedAttribute]
public bool get_HasCoveragePercent();
    [CompilerGeneratedAttribute]
public void set_HasCoveragePercent(bool value);
    [CompilerGeneratedAttribute]
public int get_CoveragePercent();
    [CompilerGeneratedAttribute]
public void set_CoveragePercent(int value);
    [CompilerGeneratedAttribute]
public bool get_HasIconIndex();
    [CompilerGeneratedAttribute]
public void set_HasIconIndex(bool value);
    [CompilerGeneratedAttribute]
public int get_IconIndex();
    [CompilerGeneratedAttribute]
public void set_IconIndex(int value);
    [CompilerGeneratedAttribute]
public bool get_HasSourceInfo();
    [CompilerGeneratedAttribute]
public void set_HasSourceInfo(bool value);
    [CompilerGeneratedAttribute]
public SectionIndex`1<IMetadataSection> get_MetadataIndex();
    [CompilerGeneratedAttribute]
public void set_MetadataIndex(SectionIndex`1<IMetadataSection> value);
    [CompilerGeneratedAttribute]
public int get_DocumentIndex();
    [CompilerGeneratedAttribute]
public void set_DocumentIndex(int value);
    [CompilerGeneratedAttribute]
public int get_Line();
    [CompilerGeneratedAttribute]
public void set_Line(int value);
    [CompilerGeneratedAttribute]
public int get_Column();
    [CompilerGeneratedAttribute]
public void set_Column(int value);
    [CompilerGeneratedAttribute]
public int get_ChildrenNumber();
    [CompilerGeneratedAttribute]
public void set_ChildrenNumber(int value);
    [CompilerGeneratedAttribute]
public int get_FirstChildIndex();
    [CompilerGeneratedAttribute]
public void set_FirstChildIndex(int value);
}
[RdExtAttribute]
[SnapshotModelComponentAttribute]
internal class JetBrains.dotCover.Workspace.Impl.Reporting.Model.Html.HtmlReportBuilder : RdExtComponentBase {
    private Lifetime myLifetime;
    private IHtmlReportBuilderSettings mySettings;
    private ICoverageTree myCoverageTree;
    private IPdbStatementRangesProviderImpl myPdbStatementRangesProvider;
    private IMethodStatementsCoverageProvider myMethodStatementsCoverageProvider;
    private ISnapshotActiveGroupsProvider mySnapshotActiveGroupsProvider;
    private ICoverageNodeIconProvider myCoverageNodeIconProvider;
    private IThemedIconManager myThemedIconManager;
    private IWebProxyFactory myWebProxyFactory;
    private IProgressSubmitter myProgressSubmitter;
    private IThreading myThreading;
    private ILogger myLogger;
    private IDocumentRangeSection myDocumentRangeSection;
    private IMethodRangeSection myMethodRangeSection;
    private IStatementDataSection myStatementDataSection;
    private ISourceServerDataSection mySourceServerDataSection;
    private IComparer`1<CoverageNodeId> myCoverageNodeComparer;
    public HtmlReportBuilder(Lifetime lifetime, IRdExtComponentsInitializer initializer, IHtmlReportBuilderSettings settings, ICoverageSnapshot snapshot, ICoverageTree coverageTree, IPdbStatementRangesProviderImpl pdbStatementRangesProvider, IMethodStatementsCoverageProvider methodStatementsCoverageProvider, ISnapshotActiveGroupsProvider snapshotActiveGroupsProvider, ICoverageNodeIconProvider coverageNodeIconProvider, IThemedIconManager themedIconManager, IWebProxyFactory webProxyFactory, IProgressSubmitter progressSubmitter, IThreading threading, ILoggerProvider loggerProvider);
    public sealed virtual Task BuildReport(string fileName, bool includeEnvironmentSpecificInfo, bool allowSourceServersAccess, String[] sourcesSearchPaths, CustomWebProxySettings webProxySettings, ProgressId progressId);
    private IList`1<EnumerationItem> EnumerateNodesInBreadthFirstOrder(ICoverageTreeBase coverageTree, IComparer`1<CoverageNodeId> comparer, IProgressIndicator progress);
    private HtmlNodeDetails GetHtmlNodeDetails(int nodeIndex, IList`1<EnumerationItem> enumeratedItems, ResourcesGenerator resourcesGenerator, SourceFilesGetter sourceFilesGetter);
    private IReadOnlyDictionary`2<CoverageNodeId, StatementsCoverageInfo> BuildMethodsCoverageInfo(SectionIndex`1<IMetadataSection> metadataIndex, IReadOnlyCollection`1<ISnapshotSectionCollection> groups);
    private void CleanUp(FileSystemPath resourceFolder, FileSystemPath reportFilePath);
}
[WorkspaceModelComponentAttribute]
internal class JetBrains.dotCover.Workspace.Impl.Reporting.Model.Html.HtmlReportBuilderSettings : object {
    [CompilerGeneratedAttribute]
private MetadataNodesPresentationSettings <MetadataNodesPresentationSettings>k__BackingField;
    public MetadataNodesPresentationSettings MetadataNodesPresentationSettings { get; }
    [CompilerGeneratedAttribute]
public sealed virtual MetadataNodesPresentationSettings get_MetadataNodesPresentationSettings();
}
public interface JetBrains.dotCover.Workspace.Impl.Reporting.Model.Html.IFileChecksumCalculator {
    public abstract virtual Byte[] Checksum(FileSystemPath file, Guid algorithmId);
}
public interface JetBrains.dotCover.Workspace.Impl.Reporting.Model.Html.IFileDownloader {
    public abstract virtual bool TryDownload(Uri fileUri, FileSystemPath targetFile);
}
public interface JetBrains.dotCover.Workspace.Impl.Reporting.Model.Html.IFileExistenceAnalyzer {
    public abstract virtual bool FileExists(FileSystemPath filePath);
}
internal static class JetBrains.dotCover.Workspace.Impl.Reporting.Model.Html.IndexFileWriter : object {
    private static int BlockSize;
    private static string ProductHomepage;
    private static string CompanyHomepage;
    private static string FeedbackPattern;
    public static void WriteIndexFile(int nodesNumber, Func`2<int, HtmlNodeDetails> getNodeDetails, string reportFileName, string resourceFolderShortName, bool includeEnvironmentSpecificInfo, IProgressIndicator progress);
    private static void WriteNodeDetails(HtmlNodeDetails details, TextWriter writer);
    private static string GetBlockName(int blockIndex);
    private static string GetProductFeedbackUrl(Version productVersion);
}
internal class JetBrains.dotCover.Workspace.Impl.Reporting.Model.Html.ResourcesGenerator : object {
    private static int PercentBarWidth;
    private static int IconSize;
    private static int IconsInRow;
    private static int IconsPadding;
    private static int IconsSvgWidth;
    private static XNamespace ourSvgNS;
    private IThemedIconManager myThemedIconManager;
    private ICoverageNodeIconProvider myCoverageNodeIconProvider;
    private ILogger myLogger;
    private IDictionary`2<Pair`2<CoverageNodeKind, CoverageNodeModifier>, int> myIconIndices;
    public ResourcesGenerator(IThemedIconManager themedIconManager, ICoverageNodeIconProvider coverageNodeIconProvider, ILogger logger);
    private static ResourcesGenerator();
    public bool TryGetIconIndex(CoverageNodeKind kind, CoverageNodeModifier modifier, Int32& iconIndex);
    public void WriteGeneratedResources(FileSystemPath resourcesFolder);
    [CanBeNullAttribute]
private XElement TryGetIconSvgRec(IconId iconId);
    private static void AddSuffixToIdAttributes(XContainer xContainer, string suffix);
}
[ExtensionAttribute]
internal static class JetBrains.dotCover.Workspace.Impl.Reporting.Model.Html.ResourcesWriter : object {
    public static string JavascriptResourceSubFolder;
    public static string CssResourceSubFolder;
    public static string ImagesResourceSubFolder;
    public static string SrcResourceSubFolder;
    public static void WriteResources(FileSystemPath resourcesFolder);
    [ExtensionAttribute]
public static void WriteToFile(Byte[] bytes, FileSystemPath folderPath, string fileName);
    [ExtensionAttribute]
public static void WriteToFile(string content, FileSystemPath folderPath, string fileName);
}
internal class JetBrains.dotCover.Workspace.Impl.Reporting.Model.Html.SourceFilesGetter : object {
    private Lifetime myLifetime;
    private IDocumentRangeSection myDocumentRangeSection;
    private ISourceServerDataSection mySourceServerDataSection;
    private bool myAllowSourceServersAccess;
    private IFileExistenceAnalyzer myFileExistenceAnalyzer;
    private IFileChecksumCalculator myFileChecksumCalculator;
    private IFileDownloader myFileDownloader;
    private ILogger myLogger;
    private FileSystemPath[] mySourcesSearchPaths;
    private IDictionary`2<FileSystemPath, FileSystemPath> myDocumentsRootToSearchPathMap;
    private IDictionary`2<int, FileSystemPath> myFileLocationsDictionary;
    private OneToSetMap`2<SectionIndex`1<IMetadataSection>, int> myDocumentIndicesByMetadataIndex;
    private static ISet`1<char> ourInvalidPathChars;
    public IReadOnlyList`1<ValueTuple`3<SectionIndex`1<IMetadataSection>, int, FileSystemPath>> SourceFilesOrderedByModule { get; }
    private static SourceFilesGetter();
    public SourceFilesGetter(Lifetime lifetime, IDocumentRangeSection documentRangeSection, ISourceServerDataSection sourceServerDataSection, bool allowSourceServersAccess, String[] sourcesSearchPaths, IFileExistenceAnalyzer fileExistenceAnalyzer, IFileChecksumCalculator fileChecksumCalculator, IFileDownloader fileDownloader, ILogger logger);
    public bool TryGetSourceFile(SectionIndex`1<IMetadataSection> metadataIndex, int documentIndex);
    private FileSystemPath TryFindFileBySearchPaths(int documentIndex, DocumentData documentData, FileSystemPath filePath);
    private FileSystemPath TryDownloadFileFromSourceServer(SectionIndex`1<IMetadataSection> metadataIndex, int documentIndex, FileSystemPath filePath);
    private void LogSourceFileMessage(int documentIndex, string fileName, string message);
    public IReadOnlyList`1<ValueTuple`3<SectionIndex`1<IMetadataSection>, int, FileSystemPath>> get_SourceFilesOrderedByModule();
}
internal static class JetBrains.dotCover.Workspace.Impl.Reporting.Model.Html.SourceFilesWriter : object {
    public static void WriteFileContent(SectionIndex`1<IMetadataSection> metadataIndex, int documentIndex, FileSystemPath fileLocation, FileSystemPath resourceFolder, IPdbStatementRangesProviderImpl pdbStatementRangesProvider, IReadOnlyDictionary`2<CoverageNodeId, StatementsCoverageInfo> methodsCoverageInfo, ILogger logger);
    private static string BuildRanges(SectionIndex`1<IMetadataSection> metadataIndex, int documentIndex, IPdbStatementRangesProviderImpl pdbStatementRangesProvider, IReadOnlyDictionary`2<CoverageNodeId, StatementsCoverageInfo> methodsCoverageInfo);
    private static void BuildRangesRecursively(StringBuilder builder, IReadOnlyList`1<PdbStatementRange> statementRangesList, Nullable`1<bool> parentStatementCovered, IReadOnlyDictionary`2<CoverageNodeId, StatementsCoverageInfo> methodsCoverageInfo);
    private static void AppendRange(StringBuilder builder, PdbRange range, bool covered);
    private static int CompareRanges(PdbRange range1, PdbRange range2);
}
public interface JetBrains.dotCover.Workspace.Impl.Reporting.Model.Interface.Html.IHtmlReportBuilderSettings {
}
public interface JetBrains.dotCover.Workspace.Impl.Reporting.Model.Interface.IMetadataTreeBasedReportBuilderSettings {
    public MetadataNodesPresentationSettings MetadataNodesPresentationSettings { get; }
    public abstract virtual MetadataNodesPresentationSettings get_MetadataNodesPresentationSettings();
}
public interface JetBrains.dotCover.Workspace.Impl.Reporting.Model.Interface.Json.IJsonReportBuilderSettings {
}
public interface JetBrains.dotCover.Workspace.Impl.Reporting.Model.Interface.Xml.IDetailedXmlReportBuilderSettings {
}
public interface JetBrains.dotCover.Workspace.Impl.Reporting.Model.Interface.Xml.INDependReportBuilderSettings {
}
public interface JetBrains.dotCover.Workspace.Impl.Reporting.Model.Interface.Xml.ITeamCityReportBuilderSettings {
}
public interface JetBrains.dotCover.Workspace.Impl.Reporting.Model.Interface.Xml.IXmlReportBuilderSettings {
}
public interface JetBrains.dotCover.Workspace.Impl.Reporting.Model.Interface.Xml.IXmlReportBuilderSettingsBase {
    public abstract virtual bool IsSuitableTypeMembersProcessingMode(TypeMembersProcessingMode mode);
    public abstract virtual TypeMembersProcessingMode GetRequiredTypeMembersProcessingMode(bool hideAutoProperties, bool filterTypeMembers);
}
internal interface JetBrains.dotCover.Workspace.Impl.Reporting.Model.IReportReverseCoverageProvider {
    public bool IsPerTestInfoAvailable { get; }
    public abstract virtual bool get_IsPerTestInfoAvailable();
    public abstract virtual IReadOnlyList`1<int> GetCoveringTestIndices(MetadataId methodId);
    public abstract virtual bool TryGetTestIdByIndex(int index, UnitTestSessionTestId& testId);
}
[RdExtAttribute]
[SnapshotModelComponentAttribute]
internal class JetBrains.dotCover.Workspace.Impl.Reporting.Model.Json.JsonReportBuilder : RdExtComponentBase {
    private Lifetime myLifetime;
    private IJsonReportBuilderSettings mySettings;
    private ICoverageTree myCoverageTree;
    private IReportReverseCoverageProvider myReverseCoverageProvider;
    private IProgressSubmitter myProgressSubmitter;
    private IThreading myThreading;
    private ILogger myLogger;
    public JsonReportBuilder(Lifetime lifetime, IRdExtComponentsInitializer initializer, IJsonReportBuilderSettings settings, ICoverageTree coverageTree, IReportReverseCoverageProvider reverseCoverageProvider, IProgressSubmitter progressSubmitter, IThreading threading, ILoggerProvider loggerProvider);
    public sealed virtual Task BuildReport(string fileName, ProgressId progressId, ReportFeatures reportFeatures);
    private void WriteNodeRec(CoverageNodeId nodeId, bool isRoot, ReportBuilderContext context, ICoverageNodeChildrenEnumerator`1<ReportBuilderContext> recursiveChildrenEnumerator);
    private static void WriteCoverageDetailProperties(JsonWriter writer, ICoverageNodeDetails details);
    private bool PerTestInfoShouldBeIncluded(ReportFeatures features);
    private bool NodePerTestInfoShouldBeIncluded(ReportFeatures features, CoverageNodeKind nodeKind, ICoverageNodeDetails nodeDetails);
    private void WriteAllTestsList(ReportBuilderContext context);
    private static void WriteTestObject(JsonWriter writer, UnitTestSessionTestId sessionTestId, int index);
    private IReadOnlyList`1<int> GetCoveringTestIndices(CoverageNodeId nodeId);
    private void WriteCoveringTestIndices(ReportBuilderContext context, CoverageNodeId nodeId, bool nodeHasChildren);
    private void UpdateAncestorNodeCoveringTestIndices(ReportBuilderContext context, CoverageNodeId nodeId);
}
[WorkspaceModelComponentAttribute]
internal class JetBrains.dotCover.Workspace.Impl.Reporting.Model.Json.JsonReportBuilderSettings : object {
    [CompilerGeneratedAttribute]
private MetadataNodesPresentationSettings <MetadataNodesPresentationSettings>k__BackingField;
    public MetadataNodesPresentationSettings MetadataNodesPresentationSettings { get; }
    [CompilerGeneratedAttribute]
public sealed virtual MetadataNodesPresentationSettings get_MetadataNodesPresentationSettings();
}
[ExtensionAttribute]
internal static class JetBrains.dotCover.Workspace.Impl.Reporting.Model.Json.JsonWriterExtension : object {
    [ExtensionAttribute]
public static void WritePropertyIfNotNull(JsonWriter writer, string name, string value);
    [ExtensionAttribute]
public static void WriteProperty(JsonWriter writer, string name, string value);
    [ExtensionAttribute]
public static void WriteProperty(JsonWriter writer, string name, int value);
    [ExtensionAttribute]
public static void WriteProperty(JsonWriter writer, string name, long value);
}
[SnapshotModelComponentAttribute]
internal class JetBrains.dotCover.Workspace.Impl.Reporting.Model.ReportReverseCoverageProvider : object {
    private ICoverageSnapshot myCoverageSnapshot;
    private IGroupNameIndexSection myGroupNameIndexSection;
    [CanBeNullAttribute]
private ICumulativeCoverageSnapshot myCumulativeCoverageSnapshot;
    [CanBeNullAttribute]
private ICumulativeSnapshotReverseCoverageSection myReverseCoverageSection;
    private Lazy`1<IReadOnlyList`1<string>> myGroupNamesList;
    private Lazy`1<IReadOnlyDictionary`2<MetadataId, List`1<int>>> myTestIndicesByMethod;
    public bool IsPerTestInfoAvailable { get; }
    public ReportReverseCoverageProvider(ICoverageSnapshot coverageSnapshot);
    public sealed virtual bool get_IsPerTestInfoAvailable();
    public sealed virtual IReadOnlyList`1<int> GetCoveringTestIndices(MetadataId methodId);
    public sealed virtual bool TryGetTestIdByIndex(int index, UnitTestSessionTestId& testId);
    private IReadOnlyList`1<string> BuildGroupNamesList();
    private IReadOnlyDictionary`2<MetadataId, List`1<int>> BuildReverseCoverageData();
}
[RdExtAttribute]
[SnapshotModelComponentAttribute]
internal class JetBrains.dotCover.Workspace.Impl.Reporting.Model.Summary.SummaryXmlReportBuilder : RdExtComponentBase {
    private ICoverageTree myCoverageTree;
    private Lifetime myLifetime;
    private IProgressSubmitter myProgressSubmitter;
    private IThreading myThreading;
    private ILogger myLogger;
    public SummaryXmlReportBuilder(Lifetime lifetime, IRdExtComponentsInitializer initializer, ICoverageTree coverageTree, IProgressSubmitter progressSubmitter, IThreading threading, ILoggerProvider loggerProvider);
    public sealed virtual Task BuildReport(string fileName, ProgressId progressId, ReportFeatures reportFeatures);
    private void WriteCoverageAttributes(XmlTextWriter writer, CoverageMetric coverageMetric);
    private void WritePercentageElement(XmlTextWriter writer, CoverageMetric coverageMetric);
    private void WriteRootElement(XmlTextWriter writer, bool includeEnvironmentSpecificInfo, Action`1<XmlTextWriter> writeInnerAction);
}
[RdExtAttribute]
[SnapshotModelComponentAttribute]
internal class JetBrains.dotCover.Workspace.Impl.Reporting.Model.UncoveredLines.UncoveredLinesReportBuilder : RdExtComponentBase {
    private Lifetime myLifetime;
    private IProgressSubmitter myProgressSubmitter;
    private IThreading myThreading;
    private IDocumentRangeSection myDocumentRangeSection;
    private IMethodRangeSection myMethodRangeSection;
    private IStatementDataSection myStatementDataSection;
    private IStatementCoverageIndexSection myTotalIndexSection;
    private IStatementCoverageDetailsSection myTotalDetailsSection;
    private ILogger myLogger;
    public UncoveredLinesReportBuilder(Lifetime lifetime, IRdExtComponentsInitializer initializer, ICoverageSnapshot snapshot, IProgressSubmitter progressSubmitter, IThreading threading, ILoggerProvider loggerProvider);
    public sealed virtual Task BuildReport(string fileName, string sourcesRoot, ProgressId progressId);
    private IEnumerable`1<KeyValuePair`2<int, string>> GetDocumentUrls(string sourcesRoot, Int32& documentsCount);
    private IEnumerable`1<int> GetUncoveredLines(int documentIndex, IReadOnlyDictionary`2<MetadataId, SectionOffset`1<IStatementCoverageDetailsSection>> methodCoverageDetailsOffsets, IStatementCoverageDetailsProvider coverageDetailsProvider);
    internal static string GetLinesRepresentation(IEnumerable`1<int> lines);
    private static void AppendLineInfo(StringBuilder builder, int firstLine, int lastLine);
}
internal class JetBrains.dotCover.Workspace.Impl.Reporting.Model.Xml.DetailedReportContextData : object {
    public static Key`1<DetailedReportContextData> Key;
    [CompilerGeneratedAttribute]
private SectionIndex`1<IMetadataSection> <CurrentMetadataIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<MetadataId, SectionOffset`1<IStatementCoverageDetailsSection>> <MethodDetailsOffsets>k__BackingField;
    [CompilerGeneratedAttribute]
private IStatementCoverageDetailsProvider <DetailsProvider>k__BackingField;
    public SectionIndex`1<IMetadataSection> CurrentMetadataIndex { get; private set; }
    public Dictionary`2<MetadataId, SectionOffset`1<IStatementCoverageDetailsSection>> MethodDetailsOffsets { get; private set; }
    public IStatementCoverageDetailsProvider DetailsProvider { get; private set; }
    private static DetailedReportContextData();
    [CompilerGeneratedAttribute]
public SectionIndex`1<IMetadataSection> get_CurrentMetadataIndex();
    [CompilerGeneratedAttribute]
private void set_CurrentMetadataIndex(SectionIndex`1<IMetadataSection> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<MetadataId, SectionOffset`1<IStatementCoverageDetailsSection>> get_MethodDetailsOffsets();
    [CompilerGeneratedAttribute]
private void set_MethodDetailsOffsets(Dictionary`2<MetadataId, SectionOffset`1<IStatementCoverageDetailsSection>> value);
    [CompilerGeneratedAttribute]
public IStatementCoverageDetailsProvider get_DetailsProvider();
    [CompilerGeneratedAttribute]
private void set_DetailsProvider(IStatementCoverageDetailsProvider value);
    public sealed virtual void Dispose();
    public void Init(SectionIndex`1<IMetadataSection> metadataIndex, IStatementCoverageIndexSection indexSection, IStatementCoverageDetailsSection detailsSection, int estimatedMethodsCount);
    private void DisposeDetailsProvider();
}
[RdExtAttribute]
[SnapshotModelComponentAttribute]
internal class JetBrains.dotCover.Workspace.Impl.Reporting.Model.Xml.DetailedXmlReportBuilder : GrouplessXmlReportBuilder {
    private IDocumentRangeSection myDocumentRangeSection;
    private IMethodRangeSection myMethodRangeSection;
    private IStatementDataSection myStatementDataSection;
    private IStatementCoverageIndexSection myTotalIndexSection;
    private IStatementCoverageDetailsSection myTotalDetailsSection;
    private IMetadataBasedCoverageTree myMetadataBasedCoverageTree;
    protected string ReportType { get; }
    public DetailedXmlReportBuilder(Lifetime lifetime, IRdExtComponentsInitializer initializer, IDetailedXmlReportBuilderSettings settings, ICoverageSnapshot snapshot, ICoverageTree coverageTree, IMetadataBasedCoverageTree metadataBasedCoverageTree, ICoverageTreeBuildConfigurator coverageTreeBuildConfigurator, ICustomMetadataTreeBuilder customMetadataTreeBuilder, IReportReverseCoverageProvider reverseCoverageProvider, IProgressSubmitter progressSubmitter, IThreading threading, ILoggerProvider loggerProvider);
    protected virtual string get_ReportType();
    protected virtual Comparison`1<CoverageNodeId> GetCompareNodesFunc(ICoverageTreeBase coverageTree);
    protected virtual string GetNodeElementName(CoverageNodeKind nodeKind);
    protected virtual void WriteCustomRootContentBeforeChildren(ICoverageTreeBase coverageTree, XmlTextWriter writer);
    protected virtual void WriteCustomNodeContentBeforeChildren(ICoverageTreeBase coverageTree, CoverageNodeId nodeId, IUserDataHolder context, XmlTextWriter writer);
    private void WriteFileIndices(XmlTextWriter writer);
    private void WriteMethodData(MetadataId metadataId, SectionOffset`1<IStatementDataSection> methodStatementDataOffset, DetailedReportContextData contextData, XmlTextWriter writer);
    private static void WriteStatementData(int fileNameIndex, SourceFileRange range, bool covered, XmlTextWriter writer);
    private static void WriteFileData(DocumentData fileData, int index, XmlTextWriter writer);
}
[WorkspaceModelComponentAttribute]
internal class JetBrains.dotCover.Workspace.Impl.Reporting.Model.Xml.DetailedXmlReportBuilderSettings : object {
    [CompilerGeneratedAttribute]
private MetadataNodesPresentationSettings <MetadataNodesPresentationSettings>k__BackingField;
    public MetadataNodesPresentationSettings MetadataNodesPresentationSettings { get; }
    public sealed virtual bool IsSuitableTypeMembersProcessingMode(TypeMembersProcessingMode mode);
    public sealed virtual TypeMembersProcessingMode GetRequiredTypeMembersProcessingMode(bool hideAutoProperties, bool filterTypeMembers);
    [CompilerGeneratedAttribute]
public sealed virtual MetadataNodesPresentationSettings get_MetadataNodesPresentationSettings();
}
internal abstract class JetBrains.dotCover.Workspace.Impl.Reporting.Model.Xml.GrouplessXmlReportBuilder : XmlReportBuilderBase {
    protected GrouplessXmlReportBuilder(Lifetime lifetime, IRdExtComponentsInitializer initializer, IXmlReportBuilderSettingsBase settings, ICoverageTreeBase coverageTree, IMetadataBasedCoverageTree metadataBasedCoverageTree, ICoverageTreeBuildConfigurator coverageTreeBuildConfigurator, ICustomMetadataTreeBuilder customMetadataTreeBuilder, IReportReverseCoverageProvider reverseCoverageProvider, IProgressSubmitter progressSubmitter, IThreading threading, ILoggerProvider loggerProvider);
    protected virtual ICoverageNodeChildrenEnumerator`1<T> GetRecursiveOrderedChildrenEnumerator(ICoverageTreeBase coverageTree, RecursiveCoverageNodeChildrenVisitor`1<T> nodeVisitor, Comparison`1<CoverageNodeId> compareNodes);
}
[RdExtAttribute]
[SnapshotModelComponentAttribute]
internal class JetBrains.dotCover.Workspace.Impl.Reporting.Model.Xml.NDependReportBuilder : GrouplessXmlReportBuilder {
    private IMethodRangeSection myMethodRangeSection;
    private IStatementDataSection myStatementDataSection;
    protected string ReportType { get; }
    public NDependReportBuilder(Lifetime lifetime, IRdExtComponentsInitializer initializer, INDependReportBuilderSettings settings, ICoverageSnapshot snapshot, ICoverageTree coverageTree, IMetadataBasedCoverageTree metadataBasedCoverageTree, ICoverageTreeBuildConfigurator coverageTreeBuildConfigurator, ICustomMetadataTreeBuilder customMetadataTreeBuilder, IReportReverseCoverageProvider reverseCoverageProvider, IProgressSubmitter progressSubmitter, IThreading threading, ILoggerProvider loggerProvider);
    protected virtual string get_ReportType();
    protected virtual Comparison`1<CoverageNodeId> GetCompareNodesFunc(ICoverageTreeBase coverageTree);
    protected virtual string GetNodeElementName(CoverageNodeKind nodeKind);
    protected virtual void WriteCustomNodeContentBeforeChildren(ICoverageTreeBase coverageTree, CoverageNodeId nodeId, IUserDataHolder context, XmlTextWriter writer);
}
[WorkspaceModelComponentAttribute]
internal class JetBrains.dotCover.Workspace.Impl.Reporting.Model.Xml.NDependReportBuilderSettings : object {
    [CompilerGeneratedAttribute]
private MetadataNodesPresentationSettings <MetadataNodesPresentationSettings>k__BackingField;
    public MetadataNodesPresentationSettings MetadataNodesPresentationSettings { get; }
    public sealed virtual bool IsSuitableTypeMembersProcessingMode(TypeMembersProcessingMode mode);
    public sealed virtual TypeMembersProcessingMode GetRequiredTypeMembersProcessingMode(bool hideAutoProperties, bool filterTypeMembers);
    [CompilerGeneratedAttribute]
public sealed virtual MetadataNodesPresentationSettings get_MetadataNodesPresentationSettings();
}
[RdExtAttribute]
[SnapshotModelComponentAttribute]
internal class JetBrains.dotCover.Workspace.Impl.Reporting.Model.Xml.TeamCityReportBuilder : GrouplessXmlReportBuilder {
    private static string LeafNodeElementName;
    private IDocumentRangeSection myDocumentRangeSection;
    private IMethodRangeSection myMethodRangeSection;
    private IStatementDataSection myStatementDataSection;
    private IStatementCoverageIndexSection myTotalIndexSection;
    private IStatementCoverageDetailsSection myTotalDetailsSection;
    private IModuleStatSection myModuleStatSection;
    private IMetadataBasedCoverageTree myMetadataBasedCoverageTree;
    protected string ReportType { get; }
    public TeamCityReportBuilder(Lifetime lifetime, IRdExtComponentsInitializer initializer, ITeamCityReportBuilderSettings settings, ICoverageSnapshot snapshot, ICoverageTree coverageTree, IMetadataBasedCoverageTree metadataBasedCoverageTree, ICoverageTreeBuildConfigurator coverageTreeBuildConfigurator, ICustomMetadataTreeBuilder customMetadataTreeBuilder, IReportReverseCoverageProvider reverseCoverageProvider, IProgressSubmitter progressSubmitter, IThreading threading, ILoggerProvider loggerProvider);
    protected virtual string get_ReportType();
    protected virtual string GetNodeElementName(CoverageNodeKind nodeKind);
    protected virtual void WriteCustomNodeContentAfterChildren(ICoverageTreeBase coverageTree, CoverageNodeId nodeId, IUserDataHolder context, XmlTextWriter writer);
    private void WriteAssemblyLoadInfo(SectionIndex`1<IMetadataSection> metadataIndex, XmlTextWriter writer);
    private void WriteMethod(MetadataId metadataId, SectionOffset`1<IStatementDataSection> methodStatementDataOffset, IUserDataHolder context, XmlTextWriter writer);
    private void WriteStatementData(int fileIndex, SourceFileRange range, bool covered, XmlTextWriter writer);
    protected virtual void WriteCustomRootContentAfterChildren(ICoverageTreeBase coverageTree, XmlTextWriter writer);
    private static void WriteFileData(int index, DocumentData fileData, XmlTextWriter writer);
}
[WorkspaceModelComponentAttribute]
internal class JetBrains.dotCover.Workspace.Impl.Reporting.Model.Xml.TeamCityReportBuilderSettings : object {
    [CompilerGeneratedAttribute]
private MetadataNodesPresentationSettings <MetadataNodesPresentationSettings>k__BackingField;
    public MetadataNodesPresentationSettings MetadataNodesPresentationSettings { get; }
    public sealed virtual bool IsSuitableTypeMembersProcessingMode(TypeMembersProcessingMode mode);
    public sealed virtual TypeMembersProcessingMode GetRequiredTypeMembersProcessingMode(bool hideAutoProperties, bool filterTypeMembers);
    [CompilerGeneratedAttribute]
public sealed virtual MetadataNodesPresentationSettings get_MetadataNodesPresentationSettings();
}
[RdExtAttribute]
[SnapshotModelComponentAttribute]
internal class JetBrains.dotCover.Workspace.Impl.Reporting.Model.Xml.XmlReportBuilder : XmlReportBuilderBase {
    protected string ReportType { get; }
    public XmlReportBuilder(Lifetime lifetime, IRdExtComponentsInitializer initializer, IXmlReportBuilderSettings settings, ICoverageTree coverageTree, IMetadataBasedCoverageTree metadataBasedCoverageTree, ICoverageTreeBuildConfigurator coverageTreeBuildConfigurator, ICustomMetadataTreeBuilder customMetadataTreeBuilder, IReportReverseCoverageProvider reverseCoverageProvider, IProgressSubmitter progressSubmitter, IThreading threading, ILoggerProvider loggerProvider);
    protected virtual string get_ReportType();
}
internal abstract class JetBrains.dotCover.Workspace.Impl.Reporting.Model.Xml.XmlReportBuilderBase : RdExtComponentBase {
    private Lifetime myLifetime;
    private IXmlReportBuilderSettingsBase mySettings;
    private ICoverageTreeBase myCoverageTree;
    private IMetadataBasedCoverageTree myMetadataBasedCoverageTree;
    private ICoverageTreeBuildConfigurator myCoverageTreeBuildConfigurator;
    private ICustomMetadataTreeBuilder myCustomMetadataTreeBuilder;
    private IReportReverseCoverageProvider myReverseCoverageProvider;
    private IProgressSubmitter myProgressSubmitter;
    private IThreading myThreading;
    private ILogger myLogger;
    protected string ReportType { get; }
    protected XmlReportBuilderBase(Lifetime lifetime, IRdExtComponentsInitializer initializer, IXmlReportBuilderSettingsBase settings, ICoverageTreeBase coverageTree, IMetadataBasedCoverageTree metadataBasedCoverageTree, ICoverageTreeBuildConfigurator coverageTreeBuildConfigurator, ICustomMetadataTreeBuilder customMetadataTreeBuilder, IReportReverseCoverageProvider reverseCoverageProvider, IProgressSubmitter progressSubmitter, IThreading threading, ILoggerProvider loggerProvider);
    public sealed virtual Task BuildReport(string fileName, ProgressId progressId, ReportFeatures reportFeatures);
    [AsyncStateMachineAttribute("JetBrains.dotCover.Workspace.Impl.Reporting.Model.Xml.XmlReportBuilderBase/<GetReportSpecificCoverageTree>d__12")]
private Task`1<ICoverageTreeBase> GetReportSpecificCoverageTree(Lifetime lifetime, IProgressIndicator progress);
    private void WriteNodeRec(CoverageNodeId nodeId, bool isRoot, ReportBuilderContext context, ICoverageNodeChildrenEnumerator`1<ReportBuilderContext> childrenEnumerator);
    private void WriteNodeAttributes(CoverageNodeId nodeId, ICoverageNodeDetails nodeDetails, ReportBuilderContext context, bool isRoot);
    protected abstract virtual string get_ReportType();
    protected virtual Comparison`1<CoverageNodeId> GetCompareNodesFunc(ICoverageTreeBase coverageTree);
    protected virtual ICoverageNodeChildrenEnumerator`1<T> GetRecursiveOrderedChildrenEnumerator(ICoverageTreeBase coverageTree, RecursiveCoverageNodeChildrenVisitor`1<T> nodeVisitor, Comparison`1<CoverageNodeId> compareNodes);
    protected virtual bool NodeShouldBeIncluded(CoverageNodeKind nodeKind, ICoverageNodeDetails nodeDetails);
    protected virtual string GetNodeElementName(CoverageNodeKind nodeKind);
    protected virtual void WriteCustomNodeAttributes(ICoverageTreeBase coverageTree, CoverageNodeId nodeId, XmlTextWriter writer);
    protected virtual void WriteCustomNodeContentBeforeChildren(ICoverageTreeBase coverageTree, CoverageNodeId nodeId, IUserDataHolder contextData, XmlTextWriter writer);
    protected virtual void WriteCustomRootContentBeforeChildren(ICoverageTreeBase coverageTree, XmlTextWriter writer);
    protected virtual void WriteCustomNodeContentAfterChildren(ICoverageTreeBase coverageTree, CoverageNodeId nodeId, IUserDataHolder contextData, XmlTextWriter writer);
    protected virtual void WriteCustomRootContentAfterChildren(ICoverageTreeBase coverageTree, XmlTextWriter writer);
    private bool PerTestInfoShouldBeIncluded(ReportFeatures features);
    private bool NodePerTestInfoShouldBeIncluded(ReportFeatures features, CoverageNodeKind nodeKind, ICoverageNodeDetails nodeDetails);
    private void WriteAllTestsList(ReportBuilderContext context);
    private IReadOnlyList`1<int> GetCoveringTestIndices(ReportBuilderContext context, CoverageNodeId nodeId);
    private void WriteCoveringTestIndices(ReportBuilderContext context, CoverageNodeId nodeId, bool nodeHasChildren);
    private void UpdateAncestorNodeCoveringTestIndices(ReportBuilderContext context, CoverageNodeId nodeId);
    [CompilerGeneratedAttribute]
private bool <GetReportSpecificCoverageTree>g__IncludeMetadataNode|12_0(MetadataId metadataId);
}
[WorkspaceModelComponentAttribute]
internal class JetBrains.dotCover.Workspace.Impl.Reporting.Model.Xml.XmlReportBuilderSettings : object {
    [CompilerGeneratedAttribute]
private MetadataNodesPresentationSettings <MetadataNodesPresentationSettings>k__BackingField;
    public MetadataNodesPresentationSettings MetadataNodesPresentationSettings { get; }
    public sealed virtual bool IsSuitableTypeMembersProcessingMode(TypeMembersProcessingMode mode);
    public sealed virtual TypeMembersProcessingMode GetRequiredTypeMembersProcessingMode(bool hideAutoProperties, bool filterTypeMembers);
    [CompilerGeneratedAttribute]
public sealed virtual MetadataNodesPresentationSettings get_MetadataNodesPresentationSettings();
}
[ExtensionAttribute]
internal static class JetBrains.dotCover.Workspace.Impl.Reporting.Model.XmlExtension : object {
    private static string InvalidXmlCharRegex;
    [ExtensionAttribute]
public static void WriteAttributeIfNotNull(XmlWriter writer, string name, string value);
    [ExtensionAttribute]
public static string RemoveInvalidXmlChars(string value);
    [ExtensionAttribute]
public static string EscapeInvalidXmlChar(Capture match);
}
public interface JetBrains.dotCover.Workspace.Impl.ReverseCoverage.Model.Interface.IReverseCoverageService {
    public IProperty`1<bool> IsPerTestInfoAvailable { get; }
    public int Count { get; }
    public abstract virtual IProperty`1<bool> get_IsPerTestInfoAvailable();
    public abstract virtual int get_Count();
    public abstract virtual ISet`1<UnitTestSessionTestId> GetTestsByMethod(MetadataId metadataId);
}
[SnapshotModelComponentAttribute]
public class JetBrains.dotCover.Workspace.Impl.ReverseCoverage.Model.ReverseCoverageService : object {
    private ICumulativeSnapshotReverseCoverageSection myReverseCoverageSection;
    private Lazy`1<OneToSetMap`2<MetadataId, UnitTestSessionTestId>> myTestByMethod;
    private IDictionary`2<string, UnitTestSessionTestId> myUnitTestSessionElementIds;
    [CompilerGeneratedAttribute]
private IProperty`1<bool> <IsPerTestInfoAvailable>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Count>k__BackingField;
    public IProperty`1<bool> IsPerTestInfoAvailable { get; }
    public int Count { get; private set; }
    public ReverseCoverageService(Lifetime lifetime, ICoverageSnapshot coverageSnapshot);
    [CompilerGeneratedAttribute]
public sealed virtual IProperty`1<bool> get_IsPerTestInfoAvailable();
    [CompilerGeneratedAttribute]
public sealed virtual int get_Count();
    [CompilerGeneratedAttribute]
private void set_Count(int value);
    public sealed virtual ISet`1<UnitTestSessionTestId> GetTestsByMethod(MetadataId metadataId);
    private void UpdateAvailability(ICoverageSnapshot cumulativeCoverageSnapshot);
    private OneToSetMap`2<MetadataId, UnitTestSessionTestId> BuildIndex(ICoverageSnapshot coverageSnapshot);
}
[RdExtAttribute]
[SnapshotModelComponentAttribute]
internal class JetBrains.dotCover.Workspace.Impl.SnapshotCore.Model.SnapshotLocationProvider : RdExtComponentBase {
    [CompilerGeneratedAttribute]
private UProperty`1<string> <SnapshotLocation>k__BackingField;
    public UProperty`1<string> SnapshotLocation { get; }
    public SnapshotLocationProvider(Lifetime lifetime, IRdExtComponentsInitializer initializer, ICoverageSnapshot snapshot);
    public SnapshotLocationProvider(Lifetime lifetime, IRdExtComponentsInitializer initializer, string fullPath);
    [CompilerGeneratedAttribute]
public sealed virtual UProperty`1<string> get_SnapshotLocation();
}
[RdExtAttribute]
[SnapshotModelComponentAttribute]
internal class JetBrains.dotCover.Workspace.Impl.SnapshotCore.Model.SnapshotSaver : RdExtComponentBase {
    private ILogger myLogger;
    private ICoverageSnapshot mySnapshot;
    private IProgressSubmitter myProgressSubmitter;
    private ICoverageSnapshotManager myCoverageSnapshotManager;
    private ICumulativeCoverageSnapshotManager myCumulativeCoverageSnapshotManager;
    private IThreading myThreading;
    private JetHashSet`1<Task> mySaveTasks;
    [CompilerGeneratedAttribute]
private UProperty`1<bool> <HasUnsavedData>k__BackingField;
    public UProperty`1<bool> HasUnsavedData { get; }
    public SnapshotSaver(Lifetime lifetime, IRdExtComponentsInitializer initializer, ICoverageSnapshot snapshot, IProgressSubmitter progressSubmitter, ICoverageSnapshotManager coverageSnapshotManager, ICumulativeCoverageSnapshotManager cumulativeCoverageSnapshotManager, IWorkspaceSnapshotManager workspaceSnapshotManager, IThreading threading, ILoggerProvider loggerProvider);
    [CompilerGeneratedAttribute]
public sealed virtual UProperty`1<bool> get_HasUnsavedData();
    public sealed virtual Task SaveSnapshotAsync(string targetFileName, ProgressId progressId);
    private void AddSaveTask(Task task);
    private void OnCumulativeSnapshotChanged();
    [CompilerGeneratedAttribute]
private void <.ctor>b__7_0();
    [CompilerGeneratedAttribute]
private bool <OnCumulativeSnapshotChanged>b__13_0(Task _);
}
[RdExtAttribute]
[WorkspaceModelComponentAttribute]
internal class JetBrains.dotCover.Workspace.Impl.SnapshotOperations.RawSnapshotPostProcessingHelper : RdExtComponentBase {
    private Lifetime myLifetime;
    private IDotCoverCommentsInfoReader myDotCoverCommentsInfoReader;
    private ICoverageSnapshotManager myCoverageSnapshotManager;
    private IThreading myThreading;
    private ILogger myLogger;
    public RawSnapshotPostProcessingHelper(Lifetime lifetime, IRdExtComponentsInitializer initializer, IDotCoverCommentsInfoReader dotCoverCommentsInfoReader, ICoverageSnapshotManager coverageSnapshotManager, IThreading threading, ILoggerProvider loggerProvider);
    public sealed virtual Task`1<bool> MergeIsRequired(string indexFileName);
}
[RdExtAttribute]
[WorkspaceModelComponentAttribute]
internal class JetBrains.dotCover.Workspace.Impl.SnapshotOperations.SnapshotMerger : RdExtComponentBase {
    private Lifetime myLifetime;
    private ICoverageSnapshotManager myCoverageSnapshotManager;
    private IProgressSubmitter myProgressSubmitter;
    private IThreading myThreading;
    private ILogger myLogger;
    public SnapshotMerger(Lifetime lifetime, IRdExtComponentsInitializer initializer, ICoverageSnapshotManager coverageSnapshotManager, IProgressSubmitter progressSubmitter, IThreading threading, ILoggerProvider loggerProvider);
    public sealed virtual Task Merge(String[] sourceSnapshots, string targetPath, MergeOptions options, string tempDir, ProgressId progressId);
}
internal interface JetBrains.dotCover.Workspace.Impl.SolutionBasedCoverageTree.Model.IModifiableSolutionBasedCoverageTree {
    public abstract virtual CoverageNode TryGetSolutionNode(string solutionNodeId);
    public abstract virtual void ForeachTopLevelNode(Action`1<CoverageNode> processNode);
    public abstract virtual void OnSolutionStructureModificationStarted(Task modificationTask);
}
public interface JetBrains.dotCover.Workspace.Impl.SolutionBasedCoverageTree.Model.Interface.ISolutionBasedCoverageTree {
    public abstract virtual ProjectOutputAssembly TryGetParentProjectOutputAssembly(CoverageNodeId metadataTreeNodeId);
}
public class JetBrains.dotCover.Workspace.Impl.SolutionBasedCoverageTree.Model.ProjectNodeData : object {
    public static CoverageNodeDataKey`1<ProjectNodeData> Key;
    [CompilerGeneratedAttribute]
private ProjectOutputAssembly[] <OutputAssemblies>k__BackingField;
    public ProjectOutputAssembly[] OutputAssemblies { get; }
    public ProjectNodeData(ProjectOutputAssembly[] outputAssemblies);
    private static ProjectNodeData();
    [CompilerGeneratedAttribute]
public ProjectOutputAssembly[] get_OutputAssemblies();
    public virtual string ToString();
}
[RdExtAttribute]
[SnapshotModelComponentAttribute]
[ThreadSafeAttribute]
internal class JetBrains.dotCover.Workspace.Impl.SolutionBasedCoverageTree.Model.SolutionBasedCoverageTree : RdExtComponentBase {
    private static CoverageNodeDataKey`1<CoverageNodeId[]> ourBoundMetadataNodesKey;
    private static CoverageNodeDataKey`1<BoundSolutionNodeData> ourBoundSolutionNodeDataKey;
    private ILogger myLogger;
    private IMetadataBasedCoverageTree myMetadataBasedCoverageTree;
    private IThreading myThreading;
    private CoverageNodeId myRootNodeId;
    private CoverageNodeValue myRootNodeInfo;
    private ConcurrentDictionary`2<CoverageNodeId, CoverageNode> myNodes;
    private SynchronizedSet`1<CoverageNode> myTopLevelNodes;
    private ConcurrentDictionary`2<string, CoverageNode> myNodesBySolutionNodeId;
    private object myTaskAccess;
    private CancellationTokenSource myBindTreesCancellationTokenSource;
    private CancellationTokenSource myUpdateCoverageDataCancellationTokenSource;
    private Task myTask;
    private bool myMetadataTreeInitialized;
    [CompilerGeneratedAttribute]
private ISignal`1<Task> <StructureModificationStarted>k__BackingField;
    [CompilerGeneratedAttribute]
private ISignal`1<Task> <DetailsModificationStarted>k__BackingField;
    [CompilerGeneratedAttribute]
private UProperty`1<bool> <SolutionStructureMatchingEnabled>k__BackingField;
    public int EstimatedNodesNumber { get; }
    public ISignal`1<Task> StructureModificationStarted { get; }
    public ISignal`1<Task> DetailsModificationStarted { get; }
    public UProperty`1<bool> SolutionStructureMatchingEnabled { get; }
    public SolutionBasedCoverageTree(Lifetime lifetime, IRdExtComponentsInitializer initializer, IMetadataBasedCoverageTree metadataBasedCoverageTree, ICoverageNodeIdFactory coverageNodeIdFactory, IContainerInitializer containerInitializer, IThreading threading, ILoggerProvider loggerProvider);
    private static SolutionBasedCoverageTree();
    public sealed virtual CoverageNode TryGetSolutionNode(string solutionNodeId);
    public sealed virtual void ForeachTopLevelNode(Action`1<CoverageNode> processNode);
    public sealed virtual void OnNodeCreated(CoverageNode node);
    public sealed virtual void OnNodeRemoved(CoverageNode node);
    public sealed virtual void OnSolutionStructureModificationStarted(Task modificationTask);
    private Task OnStructureModificationStarted(Task modificationTask);
    private void OnMetadataTreeDetailsModificationStarted(Task modificationTask);
    public sealed virtual CoverageNodeId GetRootNodeId();
    public sealed virtual ICoverageNodeChildrenEnumerator`1<T> GetChildrenEnumerator(CoverageNodeChildrenVisitor`1<T> nodeVisitor);
    public sealed virtual ICoverageNodeParentsEnumerator`1<T> GetParentsEnumerator(CoverageNodeParentsVisitor`1<T> nodeVisitor);
    public sealed virtual bool ContainsNode(CoverageNodeId nodeId);
    public sealed virtual ICoverageNodeInfo TryGetNodeInfo(CoverageNodeId nodeId);
    public sealed virtual ICoverageNodeDetails TryGetNodeDetails(CoverageNodeId nodeId);
    public sealed virtual string TryGetShortPresentableName(CoverageNodeId nodeId);
    public sealed virtual string TryGetFullPresentableName(CoverageNodeId nodeId);
    public sealed virtual string TryGetCustomPresentableName(CoverageNodeId nodeId, MetadataNodesPresentationSettings presentationSettings);
    public sealed virtual string TryGetAnnotation(CoverageNodeId nodeId);
    public sealed virtual bool TryPutNodeData(CoverageNodeId nodeId, CoverageNodeDataKey`1<T> key, T value);
    public sealed virtual T TryGetNodeData(CoverageNodeId nodeId, CoverageNodeDataKey`1<T> key);
    public sealed virtual int get_EstimatedNodesNumber();
    [CompilerGeneratedAttribute]
public sealed virtual ISignal`1<Task> get_StructureModificationStarted();
    [CompilerGeneratedAttribute]
public sealed virtual ISignal`1<Task> get_DetailsModificationStarted();
    public sealed virtual Task WhenCurrentModificationFinished();
    public sealed virtual ProjectOutputAssembly TryGetParentProjectOutputAssembly(CoverageNodeId metadataTreeNodeId);
    [CompilerGeneratedAttribute]
public sealed virtual UProperty`1<bool> get_SolutionStructureMatchingEnabled();
    private void BindSolutionAndMetadataTrees(CancellationToken cancellationToken);
    private void UpdateSolutionNodesCoverageData(CancellationToken cancellationToken);
    private CoverageNodeDetails CalculateRootNodeCoverageData();
    private bool IsMultiTargetFrameworkSolution();
    private Task StartNewTask(string name, Task afterTask, Action action);
    [CompilerGeneratedAttribute]
private CoverageNodeDetails <UpdateSolutionNodesCoverageData>b__49_0(CoverageNode node);
}
[RdExtAttribute]
[SnapshotModelComponentAttribute]
internal class JetBrains.dotCover.Workspace.Impl.SolutionBasedCoverageTree.Model.SolutionBasedCoverageTreeBuilder : RdExtComponentBase {
    private ILogger myLogger;
    private IModifiableSolutionBasedCoverageTree mySolutionBasedCoverageTree;
    private ICoverageNodeIdFactory myCoverageNodeIdFactory;
    private IThreading myThreading;
    private CancellationTokenSource myCurrentCancellationTokenSource;
    private Task myCurrentBuildTask;
    public SolutionBasedCoverageTreeBuilder(Lifetime lifetime, IRdExtComponentsInitializer initializer, ILoggerProvider loggerProvider, IModifiableSolutionBasedCoverageTree solutionBasedCoverageTree, ICoverageNodeIdFactory coverageNodeIdFactory, IThreading threading);
    public sealed virtual Task RebuildTree(IEnumerable`1<SolutionFolderNode> solutionFolderNodes, IEnumerable`1<ProjectNode> projectNodes);
    public sealed virtual Task AddOrUpdateSolutionFolderNode(string id, SolutionFolderNode solutionFolderNode);
    public sealed virtual Task AddOrUpdateProjectNode(string id, ProjectNode projectNode);
    public sealed virtual Task RemoveSolutionNode(string id);
    public sealed virtual Task RemoveAllSolutionNodes();
    private void DoRemoveAllSolutionNodes();
    private void DoAddOrUpdateSolutionNode(string id, SolutionNode solutionNode);
    private CoverageNode CreateCoverageTreeNodeRec(CoverageNode parent, SolutionNode solutionNode, OneToListMap`2<string, SolutionNode> solutionNodesChildren);
    private static void SetSolutionNodeData(CoverageNode node, SolutionNode solutionNode);
    private Task StartNewBuildTask(string name, CancellationToken cancellationToken, Action buildAction);
    [CompilerGeneratedAttribute]
internal static void <RebuildTree>g__AddNodeToHierarchy|7_1(SolutionNode node, <>c__DisplayClass7_1& );
    [CompilerGeneratedAttribute]
private void <DoRemoveAllSolutionNodes>b__12_0(CoverageNode topLevelNode);
    [CompilerGeneratedAttribute]
private void <DoRemoveAllSolutionNodes>b__12_1(CoverageNode n, bool _);
}
public class JetBrains.dotCover.Workspace.Impl.SolutionBasedCoverageTree.Model.SolutionNodeData : object {
    public static CoverageNodeDataKey`1<SolutionNodeData> Key;
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    public string Id { get; }
    public SolutionNodeData(string id);
    private static SolutionNodeData();
    [CompilerGeneratedAttribute]
public string get_Id();
    public virtual string ToString();
}
[RdExtAttribute]
[SnapshotModelComponentAttribute]
internal class JetBrains.dotCover.Workspace.Impl.SourceCodeMapping.CoverageNodesSourceCodeInfoProvider : RdExtComponentBase {
    private ILogger myLogger;
    private Lifetime myLifetime;
    private ISolutionBasedCoverageTree mySolutionBasedCoverageTree;
    private ILowLevelMetadataProvider myLowLevelMetadataProvider;
    private IRealtimeRequestsProcessor myRealtimeRequestsProcessor;
    private IMetadataSection myMetadataSection;
    public CoverageNodesSourceCodeInfoProvider(Lifetime lifetime, IRdExtComponentsInitializer initializer, ICoverageSnapshot snapshot, ISolutionBasedCoverageTree solutionBasedCoverageTree, ILowLevelMetadataProvider lowLevelMetadataProvider, IRealtimeRequestsProcessor realtimeRequestsProcessor, ILoggerProvider loggerProvider);
    public sealed virtual Task`1<SourceCodeInfo> TryGetSourceCodeInfo(CoverageNodeId nodeId);
}
[SnapshotModelComponentAttribute]
internal class JetBrains.dotCover.Workspace.Impl.SourceCodeMapping.MetadataTreeBuilder.SourceCodeMappedNodeDataConstructor : object {
    public sealed virtual void PutNodeData(ICoverageNodeDataHolder dataHolder, ILowLevelMetadata metadata, MetadataToken token, CoverageNodeKind nodeKind, ICoverageNodeDataHolder parentDataHolder);
    private static bool ShouldPutNodeData(CoverageNodeKind nodeKind);
    private static bool ShouldCopyParentNodeData(CoverageNodeKind nodeKind);
}
internal static class JetBrains.dotCover.Workspace.Impl.SourceCodeMapping.SourceCodeInfoBuilder : object {
    private static MethodSignatureSettings ourSignaturePresenterSettings;
    private static SourceCodeInfoBuilder();
    public static bool TryGetSourceCodeInfoHash(ILowLevelMetadata metadata, MetadataToken token, Hash& hash);
    public static Hash GetSourceCodeInfoHash(SourceCodeInfo sourceCodeInfo);
    public static SourceCodeInfo TryGetSourceCodeInfo(ISolutionBasedCoverageTree solutionBasedCoverageTree, CoverageNodeId nodeId, MetadataToken token, ILowLevelMetadata metadata);
    private static void PutOwnAndEnclosingTypesHashesRec(Hash& hash, MetadataToken typeToken, ILowLevelMetadata metadata);
    private static TypeDefProperties[] GetOwnAndEnclosingTypeDefProperties(ILowLevelMetadata metadata, MetadataToken typeToken);
    private static void GetOwnAndEnclosingTypeDefPropertiesRec(ILowLevelMetadata metadata, MetadataToken typeToken, ICollection`1<TypeDefProperties> result);
    private static string GetExplicitlyImplementedInterfaceName(ILowLevelMetadata metadata, MetadataToken methodToken, MetadataToken typeToken);
    private static string ExcludeInterfaceName(string typeMemberName);
    private static NestedFunctionInfo[] CreateNestedFunctionsPath(ICoverageTreeBase coverageTree, CoverageNodeId nodeId, CoverageNodeKind nodeKind, MetadataToken methodToken, ILowLevelMetadata metadata, MetadataToken& enclosingMethodToken);
    private static NestedFunctionInfo TryProcessAnonymousFunction(ICoverageTreeBase coverageTree, CoverageNodeId nodeId, MetadataToken anonymousMethodToken, ILowLevelMetadata metadata, CoverageNodeId parentNodeId);
}
public class JetBrains.dotCover.Workspace.Impl.SourceCodeMapping.SourceCodeMappedNodeData : object {
    public static CoverageNodeDataKey`1<SourceCodeMappedNodeData> Key;
    [CompilerGeneratedAttribute]
private int <SourceCodeInfoHash>k__BackingField;
    public int SourceCodeInfoHash { get; }
    public SourceCodeMappedNodeData(int sourceCodeInfoHash);
    private static SourceCodeMappedNodeData();
    [CompilerGeneratedAttribute]
public int get_SourceCodeInfoHash();
    public virtual string ToString();
}
[RdExtAttribute]
[SnapshotModelComponentAttribute]
internal class JetBrains.dotCover.Workspace.Impl.SourceCodeMapping.SourceCodeToCoverageTreeMapper : RdExtComponentBase {
    private ILogger myLogger;
    private Lifetime myLifetime;
    private IMetadataBasedCoverageTree myMetadataBasedCoverageTree;
    private ISolutionBasedCoverageTree mySolutionBasedCoverageTree;
    private ICoverageTree myCoverageTree;
    private ILowLevelMetadataProvider myLowLevelMetadataProvider;
    private IRealtimeRequestsProcessor myRealtimeRequestsProcessor;
    private IMetadataSection myMetadataSection;
    private object mySourceCodeInfoHashesMapAccess;
    private OneToListMap`2<int, CoverageNodeId> mySourceCodeInfoHashToNodesMap;
    public SourceCodeToCoverageTreeMapper(Lifetime lifetime, IRdExtComponentsInitializer initializer, ICoverageSnapshot snapshot, IMetadataBasedCoverageTree metadataBasedCoverageTree, ISolutionBasedCoverageTree solutionBasedCoverageTree, ICoverageTree coverageTree, ILowLevelMetadataProvider lowLevelMetadataProvider, IRealtimeRequestsProcessor realtimeRequestsProcessor, ILoggerProvider loggerProvider);
    public sealed virtual Task`1<CoverageNodeId> TryFindCoverageNode(SourceCodeInfo sourceCodeInfo);
    private void EnsureSourceCodeInfoHashesMapCreated();
    [CompilerGeneratedAttribute]
private void <.ctor>b__10_0(Task task);
    [CompilerGeneratedAttribute]
private void <.ctor>b__10_1(Task _);
}
[ExtensionAttribute]
internal static class JetBrains.dotCover.Workspace.Impl.ThreadingExtension : object {
    [ExtensionAttribute]
public static Task`1<T> ReturnToUnguardedMain(IThreading threading, Task`1<T> task);
}
internal class JetBrains.dotCover.Workspace.Impl.UnitTesting.Model.Configuration : object {
    [CompilerGeneratedAttribute]
private bool <TotalGroupIsActive>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ActiveSessionId>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SessionTotalGroupIsActive>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<string> <ActiveElementIds>k__BackingField;
    public static Configuration TotalGroup;
    public bool TotalGroupIsActive { get; }
    public string ActiveSessionId { get; }
    public bool SessionTotalGroupIsActive { get; }
    public ISet`1<string> ActiveElementIds { get; }
    private Configuration(bool totalGroupIsActive, string activeSessionId, bool sessionTotalGroupIsActive, ISet`1<string> activeElementIds);
    private static Configuration();
    [CompilerGeneratedAttribute]
public bool get_TotalGroupIsActive();
    [CompilerGeneratedAttribute]
public string get_ActiveSessionId();
    [CompilerGeneratedAttribute]
public bool get_SessionTotalGroupIsActive();
    [CompilerGeneratedAttribute]
public ISet`1<string> get_ActiveElementIds();
    public static Configuration SessionTotalGroup(string sessionId);
    public static Configuration ActiveElements(string sessionId, ISet`1<string> activeElementIds);
}
[RdExtAttribute]
[WorkspaceModelComponentAttribute]
internal class JetBrains.dotCover.Workspace.Impl.UnitTesting.Model.CumulativeSnapshotUpdater : RdExtComponentBase {
    private ILogger myLogger;
    private IWorkspaceSnapshotManagerImpl myWorkspaceSnapshotManager;
    private IProgressSubmitter myProgressSubmitter;
    private IThreading myThreading;
    private JetHashSet`1<Task> myCurrentUpdateTasks;
    [CompilerGeneratedAttribute]
private UProperty`1<bool> <IgnoreTargetFrameworksWhenMatchingModules>k__BackingField;
    public UProperty`1<bool> IgnoreTargetFrameworksWhenMatchingModules { get; }
    public CumulativeSnapshotUpdater(Lifetime lifetime, IRdExtComponentsInitializer initializer, ILoggerProvider loggerProvider, IWorkspaceSnapshotManagerImpl workspaceSnapshotManager, IProgressSubmitter progressSubmitter, IThreading threading);
    public sealed virtual Task`1<bool> AddDataFromRawSnapshotsAsync(ProgressId progressId, String[] snapshots, string sessionId, IReadOnlyDictionary`2<string, String[]> groupNamesToElementIdsMap, bool mergeModulesInsideRawSnapshots);
    public sealed virtual Task`1<bool> AddDataFromAssembliesAsync(ProgressId progressId, String[] assemblies, CoverageFilterSet coverageFilters, AttributeFilterSet attributeFilters);
    public sealed virtual Task ApplyFiltersAsync(ProgressId progressId, CoverageFilterSet coverageFilters, AttributeFilterSet attributeFilters);
    public sealed virtual Task ClearAsync(ProgressId progressId);
    public sealed virtual Task RemoveSessionDataAsync(ProgressId progressId, string sessionId);
    public sealed virtual Task RemoveElementsDataAsync(ProgressId progressId, string sessionId, String[] elementIds);
    public sealed virtual Task RemoveInvalidSessionsDataAsync(ProgressId progressId, String[] validSessionIds);
    [CompilerGeneratedAttribute]
public sealed virtual UProperty`1<bool> get_IgnoreTargetFrameworksWhenMatchingModules();
    public sealed virtual Task WhenIdle();
    private void AddCurrentTask(Task task);
}
public interface JetBrains.dotCover.Workspace.Impl.UnitTesting.Model.Interface.IUnitTestsCoverageTree {
    public abstract virtual bool ElementIsActive(string sessionId, string elementId);
}
internal interface JetBrains.dotCover.Workspace.Impl.UnitTesting.Model.IUnitTestsCoverageTreeConfiguratorImpl {
    public Configuration CurrentConfiguration { get; }
    public ISignal`1<InOutEventArgs`2<Configuration, Task>> ConfigurationChanged { get; }
    public abstract virtual Configuration get_CurrentConfiguration();
    public abstract virtual ISignal`1<InOutEventArgs`2<Configuration, Task>> get_ConfigurationChanged();
}
[RdExtAttribute]
[WorkspaceModelComponentAttribute]
internal class JetBrains.dotCover.Workspace.Impl.UnitTesting.Model.OutdatedTestsProvider : RdExtComponentBase {
    private ILogger myLogger;
    private IWorkspaceSnapshotManagerImpl myWorkspaceSnapshotManager;
    private ICumulativeSnapshotUpdater myCumulativeSnapshotUpdater;
    private IThreading myThreading;
    public OutdatedTestsProvider(Lifetime lifetime, IRdExtComponentsInitializer initializer, ILoggerProvider loggerProvider, IWorkspaceSnapshotManagerImpl workspaceSnapshotManager, ICumulativeSnapshotUpdater cumulativeSnapshotUpdater, IThreading threading);
    public sealed virtual Task`1<IEnumerable`1<UnitTestSessionTestId>> GetOutdatedTestsAsync();
    [CompilerGeneratedAttribute]
private Task`1<IEnumerable`1<UnitTestSessionTestId>> <GetOutdatedTestsAsync>b__5_0(Task`1<ICoverageSnapshot> t);
}
[RdExtAttribute]
[SnapshotModelComponentAttribute]
internal class JetBrains.dotCover.Workspace.Impl.UnitTesting.Model.TestsCoverageDataStatusChecker : RdExtComponentBase {
    private ILogger myLogger;
    private Lifetime myLifetime;
    private IRealtimeRequestsProcessor myRealtimeRequestsProcessor;
    private ICumulativeSnapshotElementStatusSection myElementStatusSection;
    [CompilerGeneratedAttribute]
private USignal`1<Unit> <CoverageDataChanged>k__BackingField;
    public USignal`1<Unit> CoverageDataChanged { get; }
    public TestsCoverageDataStatusChecker(Lifetime lifetime, IRdExtComponentsInitializer initializer, ICoverageSnapshot coverageSnapshot, IRealtimeRequestsProcessor realtimeRequestsProcessor, ILoggerProvider loggerProvider);
    public sealed virtual Task`1<TestsCoverageDataStatus> CheckStatus(string sessionId, String[] elementIds);
    [CompilerGeneratedAttribute]
public sealed virtual USignal`1<Unit> get_CoverageDataChanged();
    [CompilerGeneratedAttribute]
private void <.ctor>b__4_0(CumulativeSnapshotChangedEventArgs args);
}
[SnapshotModelComponentAttribute]
[ThreadSafeAttribute]
internal class JetBrains.dotCover.Workspace.Impl.UnitTesting.Model.UnitTestsCoverageTree : CoverageTreeWrapper {
    private static int MaxTasksInParallel;
    private ILogger myLogger;
    private Lifetime myLifetime;
    private IUnitTestsCoverageTreeConfiguratorImpl myConfigurator;
    private ICoveredMethodsInfoBuilder myCoveredMethodsInfoBuilder;
    private ICoverageSnapshot mySnapshot;
    private IThreading myThreading;
    private ICumulativeCoverageSnapshot myCumulativeSnapshot;
    private IMetadataBasedCoverageTreeBase myBaseTree;
    private object myTasksAccess;
    private Dictionary`2<CoverageNodeId, CancellationTokenSource> myUpdateAssemblyCoverageCts;
    private Dictionary`2<CoverageNodeId, Task> myUpdateAssemblyTasks;
    private ConcurrentDictionary`2<CoverageNodeId, ICoverageNodeDetails> myOwnCoverageNodeDetails;
    private TaskGroup myTaskGroup;
    [CompilerGeneratedAttribute]
private ISignal`1<Pair`2<CoverageNodeId, Task>> <AssemblyModificationStarted>k__BackingField;
    public ISnapshotSectionCollection[] ActiveGroups { get; }
    public int AssemblyNodesCount { get; }
    public ISignal`1<Pair`2<CoverageNodeId, Task>> AssemblyModificationStarted { get; }
    public int Priority { get; }
    public UnitTestsCoverageTree(Lifetime lifetime, IUnitTestsCoverageTreeConfiguratorImpl configurator, ICoveredMethodsInfoBuilder coveredMethodsInfoBuilder, ICoverageSnapshot snapshot, IThreading threading, ILoggerProvider loggerProvider);
    public virtual ICoverageNodeDetails TryGetNodeDetails(CoverageNodeId nodeId);
    public virtual Task WhenCurrentModificationFinished();
    public sealed virtual bool ElementIsActive(string sessionId, string elementId);
    public sealed virtual ISnapshotSectionCollection[] get_ActiveGroups();
    public sealed virtual int get_AssemblyNodesCount();
    public sealed virtual CoverageNodeId[] GetAllAssemblyNodes();
    public sealed virtual CoverageNodeId TryGetAssemblyNodeId(Nullable`1<Guid> mvid, string assemblyName, TargetFrameworkId targetFrameworkId);
    public sealed virtual CoverageNodeId TryGetMetadataEntityNodeId(MetadataId metadataId, bool preferOwnCoverageNode, Boolean& isOwnCoverageNode);
    [CompilerGeneratedAttribute]
public sealed virtual ISignal`1<Pair`2<CoverageNodeId, Task>> get_AssemblyModificationStarted();
    public sealed virtual int get_Priority();
    public sealed virtual void SetBaseTree(IMetadataBasedCoverageTreeBase baseTree);
    private Task OnBaseAssemblyModificationStarted(CoverageNodeId assemblyNodeId, Task modificationTask);
    protected virtual Task OnBaseStructureModificationStarted(Task modificationTask);
    protected virtual Task OnBaseDetailsModificationStarted(Task modificationTask);
    private Task OnConfigurationChanged(Configuration configuration);
    private ISnapshotSectionCollection[] GetActiveGroups(Configuration configuration);
    private void UpdateCoverageData(CoverageNodeId assemblyNodeId, ISnapshotSectionCollection[] activeGroups, CancellationToken cancellationToken);
    private Task StartNewUpdateAssemblyTask(CoverageNodeId assemblyNodeId, Task afterTask, Action`1<CancellationToken> action);
    private Task StartNewTask(Task afterTask, Task previousTask, Action action);
    [CompilerGeneratedAttribute]
private void <SetBaseTree>b__30_0(InOutEventArgs`2<Configuration, Task> args);
    [CompilerGeneratedAttribute]
private void <SetBaseTree>b__30_1(Pair`2<CoverageNodeId, Task> args);
    [CompilerGeneratedAttribute]
private void <OnConfigurationChanged>b__34_1();
    [CompilerGeneratedAttribute]
private void <OnConfigurationChanged>b__34_0();
    [CompilerGeneratedAttribute]
internal static CoverageNodeDetails <UpdateCoverageData>g__CreateCoverageNodeDetails|36_0(CoverageNodeId nodeId, long coveredStatementsCount, long totalStatementsCount, bool isOutdated, IStatementDetails coverageDetails);
}
[RdExtAttribute]
[SnapshotModelComponentAttribute]
internal class JetBrains.dotCover.Workspace.Impl.UnitTesting.Model.UnitTestsCoverageTreeConfigurator : RdExtComponentBase {
    private ICumulativeCoverageSnapshot myCumulativeSnapshot;
    [CompilerGeneratedAttribute]
private Configuration <CurrentConfiguration>k__BackingField;
    [CompilerGeneratedAttribute]
private ISignal`1<InOutEventArgs`2<Configuration, Task>> <ConfigurationChanged>k__BackingField;
    public Configuration CurrentConfiguration { get; private set; }
    public ISignal`1<InOutEventArgs`2<Configuration, Task>> ConfigurationChanged { get; }
    public UnitTestsCoverageTreeConfigurator(Lifetime lifetime, IRdExtComponentsInitializer initializer, ICoverageSnapshot snapshot);
    [CompilerGeneratedAttribute]
public sealed virtual Configuration get_CurrentConfiguration();
    [CompilerGeneratedAttribute]
private void set_CurrentConfiguration(Configuration value);
    [CompilerGeneratedAttribute]
public sealed virtual ISignal`1<InOutEventArgs`2<Configuration, Task>> get_ConfigurationChanged();
    public sealed virtual Task SetTotalGroupAsActiveAsync();
    public sealed virtual Task SetUnitTestSessionTotalGroupAsActiveAsync(string sessionId);
    public sealed virtual Task SetActiveElementsAsync(string sessionId, String[] elementIds);
}
public class JetBrains.dotCover.Workspace.Impl.WorkspaceCore.Model.DelegatingSnapshotChangeHandler : object {
    private HandlerDelegate myHandler;
    public DelegatingSnapshotChangeHandler(HandlerDelegate handler);
    public sealed virtual Task`1<ILightContainer> HandleSnapshotChanged(ICoverageSnapshot snapshot, LifetimeDefinition snapshotLifetimeDefinition, bool waitForSnapshotContainerInitialization, IProgressIndicator progress);
}
public interface JetBrains.dotCover.Workspace.Impl.WorkspaceCore.Model.Interface.ISnapshotChangeHandler {
    public abstract virtual Task`1<ILightContainer> HandleSnapshotChanged(ICoverageSnapshot snapshot, LifetimeDefinition snapshotLifetimeDefinition, bool waitForSnapshotContainerInitialization, IProgressIndicator progress);
}
internal interface JetBrains.dotCover.Workspace.Impl.WorkspaceCore.Model.Interface.IWorkspaceSnapshotManagerImpl {
    public abstract virtual Task`1<ICoverageSnapshot> WaitForSnapshotOpened();
}
[RdExtAttribute]
[WorkspaceModelComponentAttribute]
internal class JetBrains.dotCover.Workspace.Impl.WorkspaceCore.Model.WorkspacePresentableNameManager : RdExtComponentBase {
    [CompilerGeneratedAttribute]
private UProperty`1<string> <PresentableName>k__BackingField;
    public UProperty`1<string> PresentableName { get; }
    public WorkspacePresentableNameManager(Lifetime lifetime, IRdExtComponentsInitializer initializer, ILoggerProvider loggerProvider);
    [CompilerGeneratedAttribute]
public sealed virtual UProperty`1<string> get_PresentableName();
}
[RdExtAttribute]
[WorkspaceModelComponentAttribute]
internal class JetBrains.dotCover.Workspace.Impl.WorkspaceCore.Model.WorkspaceSnapshotManager : RdExtComponentBase {
    private ILogger myLogger;
    private Lifetime myLifetime;
    private ICoverageSnapshotManager myCoverageSnapshotManager;
    private ICumulativeCoverageSnapshotManager myCumulativeCoverageSnapshotManager;
    private ICumulativeSnapshotFormatUpgrader[] myCumulativeSnapshotFormatUpgraders;
    private ISnapshotChangeHandler mySnapshotChangeHandler;
    private IProgressSubmitter myProgressSubmitter;
    private IThreading myThreading;
    private CancellationTokenSource myOpenSnapshotCts;
    private Task`1<ICoverageSnapshot> myOpenSnapshotTask;
    private TaskCompletionSource`1<ICoverageSnapshot> myWaitForSnapshotOpenedTcs;
    [CompilerGeneratedAttribute]
private UProperty`1<string> <OpenedSnapshotId>k__BackingField;
    [CompilerGeneratedAttribute]
private UProperty`1<SnapshotPersistenceMode> <SnapshotPersistenceMode>k__BackingField;
    public UProperty`1<string> OpenedSnapshotId { get; }
    public UProperty`1<SnapshotPersistenceMode> SnapshotPersistenceMode { get; }
    public WorkspaceSnapshotManager(Lifetime lifetime, IRdExtComponentsInitializer initializer, ILoggerProvider loggerProvider, ICoverageSnapshotManager coverageSnapshotManager, ICumulativeCoverageSnapshotManager cumulativeCoverageSnapshotManager, IEnumerable`1<ICumulativeSnapshotFormatUpgrader> cumulativeSnapshotFormatUpgraders, ISnapshotChangeHandler snapshotChangeHandler, IProgressSubmitter progressSubmitter, IThreading threading);
    public sealed virtual Task OpenSnapshotAsync(string indexFileName, bool waitForCoverageTreeConstructed, ProgressId progressId);
    public sealed virtual Task OpenOrCreateCumulativeSnapshotAsync(string indexFileName, bool isFinalAttempt, ProgressId progressId);
    [CompilerGeneratedAttribute]
public sealed virtual UProperty`1<string> get_OpenedSnapshotId();
    [CompilerGeneratedAttribute]
public sealed virtual UProperty`1<SnapshotPersistenceMode> get_SnapshotPersistenceMode();
    private Task DoOpenSnapshotAsync(string indexFileName, bool waitForCoverageTreeConstructed, bool isFinalAttempt, Func`3<FileSystemPath, Lifetime, ICoverageSnapshot> openAction, Action`1<FileSystemPath> deleteAction, ProgressId progressId);
    private Task DoOpenSnapshotAsync(string indexFileName, bool waitForCoverageTreeConstructed, bool isFinalAttempt, Func`3<IStorageDescriptor, Lifetime, ICoverageSnapshot> openAction, Action`1<IStorageDescriptor> deleteAction, ProgressId progressId);
    public sealed virtual Task`1<ICoverageSnapshot> WaitForSnapshotOpened();
}
[ZoneMarkerAttribute]
public class JetBrains.dotCover.Workspace.Impl.ZoneMarker : object {
}
public interface JetBrains.dotCover.Workspace.IWorkspace {
    public Lifetime Lifetime { get; }
    [NotNullAttribute]
public ILightContainer WorkspaceContainer { get; }
    [NotNullAttribute]
public IProperty`1<ILightContainer> SnapshotContainer { get; }
    public abstract virtual Lifetime get_Lifetime();
    public abstract virtual ILightContainer get_WorkspaceContainer();
    public abstract virtual IProperty`1<ILightContainer> get_SnapshotContainer();
}
internal static class JetBrains.dotCover.Workspace.SimpleContainer.WorkspaceComponentsFactory : object {
    public static void AddShellComponents(IModifiableContainer container);
    public static void AddWorkspaceComponents(IModifiableContainer container);
    public static void AddSnapshotComponents(IModifiableContainer container);
}
public class JetBrains.dotCover.Workspace.SnapshotClientModelComponentAttribute : SnapshotComponentAttribute {
}
[MeansImplicitUseAttribute]
[AttributeUsageAttribute("4")]
public abstract class JetBrains.dotCover.Workspace.SnapshotComponentAttribute : ComponentAttribute {
}
public class JetBrains.dotCover.Workspace.SnapshotModelComponentAttribute : SnapshotComponentAttribute {
}
public class JetBrains.dotCover.Workspace.WorkspaceClientModelComponentAttribute : WorkspaceComponentAttribute {
}
[MeansImplicitUseAttribute]
[AttributeUsageAttribute("4")]
public abstract class JetBrains.dotCover.Workspace.WorkspaceComponentAttribute : ComponentAttribute {
}
public class JetBrains.dotCover.Workspace.WorkspaceId : object {
    private string myId;
    public WorkspaceId(Guid guid);
    public WorkspaceId(string id);
    public static WorkspaceId Generate();
    public sealed virtual bool Equals(WorkspaceId other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static bool op_Equality(WorkspaceId left, WorkspaceId right);
    public static bool op_Inequality(WorkspaceId left, WorkspaceId right);
}
public class JetBrains.dotCover.Workspace.WorkspaceModelComponentAttribute : WorkspaceComponentAttribute {
}
[ZoneMarkerAttribute]
public class JetBrains.dotCover.Workspace.ZoneMarker : object {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
