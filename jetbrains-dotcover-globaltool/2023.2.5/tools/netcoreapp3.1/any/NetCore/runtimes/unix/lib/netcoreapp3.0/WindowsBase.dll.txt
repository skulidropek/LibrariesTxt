internal static class Consts : object {
    public static string MonoVersion;
    public static string MonoCompany;
    public static string MonoProduct;
    public static string MonoCopyright;
    public static string MonoCorlibVersion;
    public static string FxVersion;
    public static string FxFileVersion;
    public static string EnvironmentVersion;
    public static string VsVersion;
    public static string VsFileVersion;
    private static string PublicKeyToken;
    public static string AssemblyI18N;
    public static string AssemblyMicrosoft_JScript;
    public static string AssemblyMicrosoft_VisualStudio;
    public static string AssemblyMicrosoft_VisualStudio_Web;
    public static string AssemblyMicrosoft_VSDesigner;
    public static string AssemblyMono_Http;
    public static string AssemblyMono_Posix;
    public static string AssemblyMono_Security;
    public static string AssemblyMono_Messaging_RabbitMQ;
    public static string AssemblyCorlib;
    public static string AssemblySystem;
    public static string AssemblySystem_Data;
    public static string AssemblySystem_Design;
    public static string AssemblySystem_DirectoryServices;
    public static string AssemblySystem_Drawing;
    public static string AssemblySystem_Drawing_Design;
    public static string AssemblySystem_Messaging;
    public static string AssemblySystem_Security;
    public static string AssemblySystem_ServiceProcess;
    public static string AssemblySystem_Web;
    public static string AssemblySystem_Windows_Forms;
    public static string AssemblySystem_2_0;
    public static string AssemblySystemCore_3_5;
    public static string AssemblySystem_Core;
    public static string WindowsBase_3_0;
    public static string AssemblyWindowsBase;
    public static string AssemblyPresentationCore_3_5;
    public static string AssemblyPresentationCore_4_0;
    public static string AssemblyPresentationFramework_3_5;
    public static string AssemblySystemServiceModel_3_0;
}
public class System.Collections.Specialized.CollectionChangedEventManager : WeakEventManager {
    private static object CurrentManagerLock;
    private static CollectionChangedEventManager CurrentManager { get; }
    private static CollectionChangedEventManager();
    public static void AddListener(INotifyCollectionChanged source, IWeakEventListener listener);
    public static void RemoveListener(INotifyCollectionChanged source, IWeakEventListener listener);
    protected virtual void StartListening(object source);
    protected virtual void StopListening(object source);
    private void OnCollectionChanged(object sender, NotifyCollectionChangedEventArgs e);
    private static CollectionChangedEventManager get_CurrentManager();
}
public class System.ComponentModel.CurrentChangedEventManager : WeakEventManager {
    public static void AddListener(ICollectionView source, IWeakEventListener listener);
    public static void RemoveListener(ICollectionView source, IWeakEventListener listener);
    protected virtual void StartListening(object source);
    protected virtual void StopListening(object source);
}
public class System.ComponentModel.CurrentChangingEventArgs : EventArgs {
    private bool canCancelEvent;
    private bool canceled;
    public bool Cancel { get; public set; }
    public bool IsCancelable { get; }
    public CurrentChangingEventArgs(bool isCancelable);
    public bool get_Cancel();
    public void set_Cancel(bool value);
    public bool get_IsCancelable();
}
public class System.ComponentModel.CurrentChangingEventHandler : MulticastDelegate {
    public CurrentChangingEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, CurrentChangingEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, CurrentChangingEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.ComponentModel.CurrentChangingEventManager : WeakEventManager {
    public static void AddListener(ICollectionView source, IWeakEventListener listener);
    public static void RemoveListener(ICollectionView source, IWeakEventListener listener);
    protected virtual void StartListening(object source);
    protected virtual void StopListening(object source);
}
public class System.ComponentModel.DependencyPropertyDescriptor : PropertyDescriptor {
    public AttributeCollection Attributes { get; }
    public string Category { get; }
    public Type ComponentType { get; }
    public TypeConverter Converter { get; }
    public DependencyProperty DependencyProperty { get; }
    public string Description { get; }
    public bool DesignTimeOnly { get; }
    public string DisplayName { get; }
    public bool IsAttached { get; }
    public bool IsBrowsable { get; }
    public bool IsLocalizable { get; }
    public bool IsReadOnly { get; }
    public PropertyMetadata Metadata { get; }
    public Type PropertyType { get; }
    public bool SupportsChangeEvents { get; }
    public CoerceValueCallback DesignerCoerceValueCallback { get; public set; }
    public virtual AttributeCollection get_Attributes();
    public virtual string get_Category();
    public virtual Type get_ComponentType();
    public virtual TypeConverter get_Converter();
    public DependencyProperty get_DependencyProperty();
    public virtual string get_Description();
    public virtual bool get_DesignTimeOnly();
    public virtual string get_DisplayName();
    public bool get_IsAttached();
    public virtual bool get_IsBrowsable();
    public virtual bool get_IsLocalizable();
    public virtual bool get_IsReadOnly();
    public PropertyMetadata get_Metadata();
    public virtual Type get_PropertyType();
    public virtual bool get_SupportsChangeEvents();
    public virtual void AddValueChanged(object component, EventHandler handler);
    public virtual bool CanResetValue(object component);
    public virtual bool Equals(object obj);
    public virtual PropertyDescriptorCollection GetChildProperties(object instance, Attribute[] filter);
    public virtual object GetEditor(Type editorBaseType);
    public virtual int GetHashCode();
    public virtual object GetValue(object component);
    public virtual void RemoveValueChanged(object component, EventHandler handler);
    public virtual void ResetValue(object component);
    public virtual void SetValue(object component, object value);
    public virtual bool ShouldSerializeValue(object component);
    public virtual string ToString();
    public static DependencyPropertyDescriptor FromName(string name, Type ownerType, Type targetType);
    public static DependencyPropertyDescriptor FromProperty(PropertyDescriptor property);
    public static DependencyPropertyDescriptor FromProperty(DependencyProperty dependencyProperty, Type targetType);
    public CoerceValueCallback get_DesignerCoerceValueCallback();
    public void set_DesignerCoerceValueCallback(CoerceValueCallback value);
}
public abstract class System.ComponentModel.GroupDescription : object {
    private ObservableCollection`1<object> groupNames;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    public ObservableCollection`1<object> GroupNames { get; }
    public ObservableCollection`1<object> get_GroupNames();
    private sealed virtual override void System.ComponentModel.INotifyPropertyChanged.add_PropertyChanged(PropertyChangedEventHandler value);
    private sealed virtual override void System.ComponentModel.INotifyPropertyChanged.remove_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
protected virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
protected virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    public virtual bool NamesMatch(object groupName, object itemName);
    protected virtual void OnPropertyChanged(PropertyChangedEventArgs e);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeGroupNames();
    public abstract virtual object GroupNameFromItem(object item, int level, CultureInfo culture);
}
public interface System.ComponentModel.ICollectionView {
    public bool CanFilter { get; }
    public bool CanGroup { get; }
    public bool CanSort { get; }
    public CultureInfo Culture { get; public set; }
    public object CurrentItem { get; }
    public int CurrentPosition { get; }
    public Predicate`1<object> Filter { get; public set; }
    public ObservableCollection`1<GroupDescription> GroupDescriptions { get; }
    public ReadOnlyObservableCollection`1<object> Groups { get; }
    public bool IsCurrentAfterLast { get; }
    public bool IsCurrentBeforeFirst { get; }
    public bool IsEmpty { get; }
    public SortDescriptionCollection SortDescriptions { get; }
    public IEnumerable SourceCollection { get; }
    public abstract virtual bool get_CanFilter();
    public abstract virtual bool get_CanGroup();
    public abstract virtual bool get_CanSort();
    public abstract virtual CultureInfo get_Culture();
    public abstract virtual void set_Culture(CultureInfo value);
    public abstract virtual object get_CurrentItem();
    public abstract virtual int get_CurrentPosition();
    public abstract virtual Predicate`1<object> get_Filter();
    public abstract virtual void set_Filter(Predicate`1<object> value);
    public abstract virtual ObservableCollection`1<GroupDescription> get_GroupDescriptions();
    public abstract virtual ReadOnlyObservableCollection`1<object> get_Groups();
    public abstract virtual bool get_IsCurrentAfterLast();
    public abstract virtual bool get_IsCurrentBeforeFirst();
    public abstract virtual bool get_IsEmpty();
    public abstract virtual SortDescriptionCollection get_SortDescriptions();
    public abstract virtual IEnumerable get_SourceCollection();
    [CompilerGeneratedAttribute]
public abstract virtual void add_CurrentChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_CurrentChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_CurrentChanging(CurrentChangingEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_CurrentChanging(CurrentChangingEventHandler value);
    public abstract virtual bool Contains(object item);
    public abstract virtual IDisposable DeferRefresh();
    public abstract virtual bool MoveCurrentTo(object item);
    public abstract virtual bool MoveCurrentToFirst();
    public abstract virtual bool MoveCurrentToLast();
    public abstract virtual bool MoveCurrentToNext();
    public abstract virtual bool MoveCurrentToPosition(int position);
    public abstract virtual bool MoveCurrentToPrevious();
    public abstract virtual void Refresh();
}
public interface System.ComponentModel.ICollectionViewFactory {
    public abstract virtual ICollectionView CreateView();
}
public interface System.ComponentModel.IEditableCollectionView {
    public object CurrentAddItem { get; }
    public object CurrentEditItem { get; }
    public bool CanAddNew { get; }
    public bool CanCancelEdit { get; }
    public bool CanRemove { get; }
    public bool IsAddingNew { get; }
    public bool IsEditingItem { get; }
    public NewItemPlaceholderPosition NewItemPlaceholderPosition { get; public set; }
    public abstract virtual void EditItem(object item);
    public abstract virtual object AddNew();
    public abstract virtual void CancelEdit();
    public abstract virtual void CancelNew();
    public abstract virtual void CommitEdit();
    public abstract virtual void CommitNew();
    public abstract virtual void Remove(object item);
    public abstract virtual void RemoveAt(int index);
    public abstract virtual object get_CurrentAddItem();
    public abstract virtual object get_CurrentEditItem();
    public abstract virtual bool get_CanAddNew();
    public abstract virtual bool get_CanCancelEdit();
    public abstract virtual bool get_CanRemove();
    public abstract virtual bool get_IsAddingNew();
    public abstract virtual bool get_IsEditingItem();
    public abstract virtual NewItemPlaceholderPosition get_NewItemPlaceholderPosition();
    public abstract virtual void set_NewItemPlaceholderPosition(NewItemPlaceholderPosition value);
}
public interface System.ComponentModel.IEditableCollectionViewAddNewItem {
    public bool CanAddNewItem { get; }
    public abstract virtual bool get_CanAddNewItem();
    public abstract virtual object AddNewItem(object newItem);
}
public interface System.ComponentModel.IItemProperties {
    public ReadOnlyCollection`1<ItemPropertyInfo> ItemProperties { get; }
    public abstract virtual ReadOnlyCollection`1<ItemPropertyInfo> get_ItemProperties();
}
public class System.ComponentModel.ItemPropertyInfo : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <PropertyType>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Descriptor>k__BackingField;
    public string Name { get; private set; }
    public Type PropertyType { get; private set; }
    public object Descriptor { get; private set; }
    public ItemPropertyInfo(string name, Type type, object descriptor);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public Type get_PropertyType();
    [CompilerGeneratedAttribute]
private void set_PropertyType(Type value);
    [CompilerGeneratedAttribute]
public object get_Descriptor();
    [CompilerGeneratedAttribute]
private void set_Descriptor(object value);
}
public enum System.ComponentModel.NewItemPlaceholderPosition : Enum {
    public int value__;
    public static NewItemPlaceholderPosition None;
    public static NewItemPlaceholderPosition AtBeginning;
    public static NewItemPlaceholderPosition AtEnd;
}
public class System.ComponentModel.PropertyChangedEventManager : WeakEventManager {
    public static void AddListener(INotifyPropertyChanged source, IWeakEventListener listener, string propertyName);
    public static void RemoveListener(INotifyPropertyChanged source, IWeakEventListener listener, string propertyName);
    protected virtual bool Purge(object source, object data, bool purgeAll);
    protected virtual void StartListening(object source);
    protected virtual void StopListening(object source);
}
[AttributeUsageAttribute("192")]
public class System.ComponentModel.PropertyFilterAttribute : Attribute {
    public static PropertyFilterAttribute Default;
    private PropertyFilterOptions options;
    public PropertyFilterOptions Filter { get; }
    public PropertyFilterAttribute(PropertyFilterOptions filter);
    private static PropertyFilterAttribute();
    public PropertyFilterOptions get_Filter();
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
    public virtual bool Match(object value);
}
[FlagsAttribute]
public enum System.ComponentModel.PropertyFilterOptions : Enum {
    public int value__;
    public static PropertyFilterOptions None;
    public static PropertyFilterOptions Invalid;
    public static PropertyFilterOptions SetValues;
    public static PropertyFilterOptions UnsetValues;
    public static PropertyFilterOptions Valid;
    public static PropertyFilterOptions All;
}
public class System.ComponentModel.SortDescription : ValueType {
    private string sortPropertyName;
    private ListSortDirection sortDirection;
    private bool isSealed;
    public ListSortDirection Direction { get; public set; }
    public bool IsSealed { get; }
    public string PropertyName { get; public set; }
    public SortDescription(string propertyName, ListSortDirection direction);
    public static bool op_Inequality(SortDescription sd1, SortDescription sd2);
    public static bool op_Equality(SortDescription sd1, SortDescription sd2);
    public ListSortDirection get_Direction();
    public void set_Direction(ListSortDirection value);
    public bool get_IsSealed();
    public string get_PropertyName();
    public void set_PropertyName(string value);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    internal void Seal();
}
public class System.ComponentModel.SortDescriptionCollection : Collection`1<SortDescription> {
    public static SortDescriptionCollection Empty;
    private bool isReadOnly;
    [CompilerGeneratedAttribute]
private NotifyCollectionChangedEventHandler CollectionChanged;
    private SortDescriptionCollection(bool isReadOnly);
    private static SortDescriptionCollection();
    private sealed virtual override void System.Collections.Specialized.INotifyCollectionChanged.add_CollectionChanged(NotifyCollectionChangedEventHandler value);
    private sealed virtual override void System.Collections.Specialized.INotifyCollectionChanged.remove_CollectionChanged(NotifyCollectionChangedEventHandler value);
    [CompilerGeneratedAttribute]
protected void add_CollectionChanged(NotifyCollectionChangedEventHandler value);
    [CompilerGeneratedAttribute]
protected void remove_CollectionChanged(NotifyCollectionChangedEventHandler value);
    protected virtual void ClearItems();
    protected virtual void InsertItem(int index, SortDescription item);
    protected virtual void RemoveItem(int index);
    protected virtual void SetItem(int index, SortDescription item);
    private void OnCollectionChanged(NotifyCollectionChangedAction action);
    private void OnCollectionChanged(NotifyCollectionChangedAction action, SortDescription item, int index);
}
public enum System.Diagnostics.PresentationTraceLevel : Enum {
    public int value__;
    public static PresentationTraceLevel None;
    public static PresentationTraceLevel Low;
    public static PresentationTraceLevel Medium;
    public static PresentationTraceLevel High;
}
public static class System.Diagnostics.PresentationTraceSources : object {
    public static DependencyProperty TraceLevelProperty;
    public static TraceSource AnimationSource { get; }
    public static TraceSource DataBindingSource { get; }
    public static TraceSource DependencyPropertySource { get; }
    public static TraceSource DocumentsSource { get; }
    public static TraceSource FreezableSource { get; }
    public static TraceSource HwndHostSource { get; }
    public static TraceSource MarkupSource { get; }
    public static TraceSource NameScopeSource { get; }
    public static TraceSource ResourceDictionarySource { get; }
    public static TraceSource RoutedEventSource { get; }
    public static TraceSource get_AnimationSource();
    public static TraceSource get_DataBindingSource();
    public static TraceSource get_DependencyPropertySource();
    public static TraceSource get_DocumentsSource();
    public static TraceSource get_FreezableSource();
    public static TraceSource get_HwndHostSource();
    public static TraceSource get_MarkupSource();
    public static TraceSource get_NameScopeSource();
    public static TraceSource get_ResourceDictionarySource();
    public static TraceSource get_RoutedEventSource();
    public static PresentationTraceLevel GetTraceLevel(object element);
    public static void Refresh();
    public static void SetTraceLevel(object element, PresentationTraceLevel traceLevel);
}
public class System.IO.FileFormatException : FormatException {
    private Uri source_uri;
    public Uri SourceUri { get; }
    public FileFormatException(string message);
    public FileFormatException(Uri sourceUri);
    protected FileFormatException(SerializationInfo info, StreamingContext context);
    public FileFormatException(string message, Exception innerException);
    public FileFormatException(Uri sourceUri, Exception innerException);
    public FileFormatException(Uri sourceUri, string message);
    public FileFormatException(Uri sourceUri, string message, Exception innerException);
    public Uri get_SourceUri();
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public enum System.IO.Packaging.CertificateEmbeddingOption : Enum {
    public int value__;
    public static CertificateEmbeddingOption InCertificatePart;
    public static CertificateEmbeddingOption InSignaturePart;
    public static CertificateEmbeddingOption NotEmbedded;
}
internal static class System.IO.Packaging.Check : object {
    private static void NotNull(object o, string name);
    public static void ContentTypeIsValid(string contentType);
    public static void Id(object id);
    public static void IdIsValid(string id);
    private static bool EmptyOrBlank(string s);
    private static void PartUriDoesntEndWithSlash(Uri uri);
    public static void Package(object package);
    public static void PackageUri(object packageUri);
    public static void PackageUriIsValid(Uri packageUri);
    public static void PackUriIsValid(Uri packUri);
    public static void PartUri(object partUri);
    public static void PartUriIsValid(Uri partUri);
    public static void RelationshipTypeIsValid(string relationshipType);
    public static void PartUri(Uri partUri);
    public static void PackUri(Uri packUri);
    public static void SourcePartUri(Uri sourcePartUri);
    public static void TargetPartUri(Uri targetPartUri);
    public static void SourceUri(Uri sourceUri);
    public static void TargetUri(Uri targetUri);
}
public enum System.IO.Packaging.CompressionOption : Enum {
    public int value__;
    public static CompressionOption NotCompressed;
    public static CompressionOption Normal;
    public static CompressionOption Maximum;
    public static CompressionOption Fast;
    public static CompressionOption SuperFast;
}
public class System.IO.Packaging.EncryptedPackageEnvelope : object {
    public FileAccess FileOpenAccess { get; }
    public PackageProperties PackageProperties { get; }
    public RightsManagementInformation RightsManagementInformation { get; }
    public StorageInfo StorageInfo { get; }
    protected virtual void Dispose(bool disposing);
    public FileAccess get_FileOpenAccess();
    public PackageProperties get_PackageProperties();
    public RightsManagementInformation get_RightsManagementInformation();
    public StorageInfo get_StorageInfo();
    public void Close();
    public sealed virtual void Dispose();
    public void Flush();
    public Package GetPackage();
    public static bool IsEncryptedPackageEnvelope(Stream stream);
    public static bool IsEncryptedPackageEnvelope(string fileName);
    public static EncryptedPackageEnvelope Create(Stream envelopeStream, PublishLicense publishLicense, CryptoProvider cryptoProvider);
    public static EncryptedPackageEnvelope Create(string envelopeFileName, PublishLicense publishLicense, CryptoProvider cryptoProvider);
    public static EncryptedPackageEnvelope CreateFromPackage(Stream envelopeStream, Stream packageStream, PublishLicense publishLicense, CryptoProvider cryptoProvider);
    public static EncryptedPackageEnvelope CreateFromPackage(string envelopeFileName, Stream packageStream, PublishLicense publishLicense, CryptoProvider cryptoProvider);
    public static EncryptedPackageEnvelope Open(Stream envelopeStream);
    public static EncryptedPackageEnvelope Open(string envelopeFileName);
    public static EncryptedPackageEnvelope Open(string envelopeFileName, FileAccess access);
    public static EncryptedPackageEnvelope Open(string envelopeFileName, FileAccess access, FileShare sharing);
}
public enum System.IO.Packaging.EncryptionOption : Enum {
    public int value__;
    public static EncryptionOption None;
    public static EncryptionOption RightsManagement;
}
public class System.IO.Packaging.InvalidSignatureEventHandler : MulticastDelegate {
    public InvalidSignatureEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, SignatureVerificationEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, SignatureVerificationEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public abstract class System.IO.Packaging.Package : object {
    internal static string RelationshipContentType;
    internal static string RelationshipNamespace;
    internal static Uri RelationshipUri;
    private PackageProperties packageProperties;
    private PackagePartCollection partsCollection;
    private Dictionary`2<string, PackageRelationship> relationships;
    private PackageRelationshipCollection relationshipsCollection;
    private Uri Uri;
    [CompilerGeneratedAttribute]
private bool <Disposed>k__BackingField;
    [CompilerGeneratedAttribute]
private FileAccess <FileOpenAccess>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RelationshipId>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Streaming>k__BackingField;
    private bool flushing;
    private bool Disposed { get; private set; }
    public FileAccess FileOpenAccess { get; private set; }
    public PackageProperties PackageProperties { get; }
    private PackagePartCollection PartsCollection { get; }
    private int RelationshipId { get; private set; }
    private Dictionary`2<string, PackageRelationship> Relationships { get; }
    private bool Streaming { get; private set; }
    protected Package(FileAccess openFileAccess);
    protected Package(FileAccess openFileAccess, bool streaming);
    private static Package();
    [CompilerGeneratedAttribute]
private bool get_Disposed();
    [CompilerGeneratedAttribute]
private void set_Disposed(bool value);
    [CompilerGeneratedAttribute]
public FileAccess get_FileOpenAccess();
    [CompilerGeneratedAttribute]
private void set_FileOpenAccess(FileAccess value);
    public PackageProperties get_PackageProperties();
    private PackagePartCollection get_PartsCollection();
    [CompilerGeneratedAttribute]
private int get_RelationshipId();
    [CompilerGeneratedAttribute]
private void set_RelationshipId(int value);
    private Dictionary`2<string, PackageRelationship> get_Relationships();
    [CompilerGeneratedAttribute]
private bool get_Streaming();
    [CompilerGeneratedAttribute]
private void set_Streaming(bool value);
    internal void CheckIsReadOnly();
    public void Close();
    public PackagePart CreatePart(Uri partUri, string contentType);
    public PackagePart CreatePart(Uri partUri, string contentType, CompressionOption compressionOption);
    protected abstract virtual PackagePart CreatePartCore(Uri partUri, string contentType, CompressionOption compressionOption);
    public PackageRelationship CreateRelationship(Uri targetUri, TargetMode targetMode, string relationshipType);
    public PackageRelationship CreateRelationship(Uri targetUri, TargetMode targetMode, string relationshipType, string id);
    internal PackageRelationship CreateRelationship(Uri targetUri, TargetMode targetMode, string relationshipType, string id, bool loading);
    public void DeletePart(Uri partUri);
    protected abstract virtual void DeletePartCore(Uri partUri);
    public void DeleteRelationship(string id);
    private sealed virtual override void System.IDisposable.Dispose();
    protected virtual void Dispose(bool disposing);
    public void Flush();
    protected abstract virtual void FlushCore();
    public PackagePart GetPart(Uri partUri);
    protected abstract virtual PackagePart GetPartCore(Uri partUri);
    public PackagePartCollection GetParts();
    protected abstract virtual PackagePart[] GetPartsCore();
    public PackageRelationship GetRelationship(string id);
    public PackageRelationshipCollection GetRelationships();
    public PackageRelationshipCollection GetRelationshipsByType(string relationshipType);
    private void LoadRelationships();
    private string NextId();
    public static Package Open(Stream stream);
    public static Package Open(string path);
    public static Package Open(Stream stream, FileMode packageMode);
    public static Package Open(string path, FileMode packageMode);
    public static Package Open(Stream stream, FileMode packageMode, FileAccess packageAccess);
    private static Package Open(Stream stream, FileMode packageMode, FileAccess packageAccess, bool ownsStream);
    public static Package Open(string path, FileMode packageMode, FileAccess packageAccess);
    public static Package Open(string path, FileMode packageMode, FileAccess packageAccess, FileShare packageShare);
    private static Package OpenCore(Stream stream, FileMode packageMode, FileAccess packageAccess, bool ownsStream);
    public virtual bool PartExists(Uri partUri);
    public bool RelationshipExists(string id);
    internal static void WriteRelationships(Dictionary`2<string, PackageRelationship> relationships, Stream stream);
}
public class System.IO.Packaging.PackageDigitalSignature : object {
    public CertificateEmbeddingOption CertificateEmbeddingOption { get; }
    public PackagePart SignaturePart { get; }
    public string SignatureType { get; }
    public Byte[] SignatureValue { get; }
    public ReadOnlyCollection`1<Uri> SignedParts { get; }
    public ReadOnlyCollection`1<PackageRelationshipSelector> SignedRelationshipSelectors { get; }
    public X509Certificate Signer { get; }
    public DateTime SigningTime { get; }
    public string TimeFormat { get; }
    public CertificateEmbeddingOption get_CertificateEmbeddingOption();
    public PackagePart get_SignaturePart();
    public string get_SignatureType();
    public Byte[] get_SignatureValue();
    public ReadOnlyCollection`1<Uri> get_SignedParts();
    public ReadOnlyCollection`1<PackageRelationshipSelector> get_SignedRelationshipSelectors();
    public X509Certificate get_Signer();
    public DateTime get_SigningTime();
    public string get_TimeFormat();
    public List`1<string> GetPartTransformList(Uri partName);
    public VerifyResult Verify();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public VerifyResult Verify(X509Certificate signingCertificate);
}
public class System.IO.Packaging.PackageDigitalSignatureManager : object {
    [CompilerGeneratedAttribute]
private InvalidSignatureEventHandler InvalidSignatureEvent;
    public static string DefaultHashAlgorithm { get; }
    public static string SignatureOriginRelationshipType { get; }
    public CertificateEmbeddingOption CertificateOption { get; public set; }
    public string HashAlgorithm { get; public set; }
    public bool IsSigned { get; }
    public IntPtr ParentWindow { get; public set; }
    public Uri SignatureOrigin { get; }
    public ReadOnlyCollection`1<PackageDigitalSignature> Signatures { get; }
    public string TimeFormat { get; public set; }
    public Dictionary`2<string, string> TransformMapping { get; }
    public PackageDigitalSignatureManager(Package package);
    public static string get_DefaultHashAlgorithm();
    public static string get_SignatureOriginRelationshipType();
    public CertificateEmbeddingOption get_CertificateOption();
    public void set_CertificateOption(CertificateEmbeddingOption value);
    public string get_HashAlgorithm();
    public void set_HashAlgorithm(string value);
    public bool get_IsSigned();
    public IntPtr get_ParentWindow();
    public void set_ParentWindow(IntPtr value);
    public Uri get_SignatureOrigin();
    public ReadOnlyCollection`1<PackageDigitalSignature> get_Signatures();
    public string get_TimeFormat();
    public void set_TimeFormat(string value);
    public Dictionary`2<string, string> get_TransformMapping();
    [CompilerGeneratedAttribute]
public void add_InvalidSignatureEvent(InvalidSignatureEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_InvalidSignatureEvent(InvalidSignatureEventHandler value);
    public PackageDigitalSignature Countersign();
    public PackageDigitalSignature Countersign(X509Certificate certificate);
    public PackageDigitalSignature Countersign(X509Certificate certificate, IEnumerable`1<Uri> signatures);
    public PackageDigitalSignature GetSignature(Uri signatureUri);
    public void RemoveSignature(Uri signatureUri);
    public void RemoveAllSignatures();
    public PackageDigitalSignature Sign(IEnumerable`1<Uri> parts);
    public PackageDigitalSignature Sign(IEnumerable`1<Uri> parts, X509Certificate certificate);
    public PackageDigitalSignature Sign(IEnumerable`1<Uri> parts, X509Certificate certificate, IEnumerable`1<PackageRelationshipSelector> relationshipSelectors);
    public PackageDigitalSignature Sign(IEnumerable`1<Uri> parts, X509Certificate certificate, IEnumerable`1<PackageRelationshipSelector> relationshipSelectors, string signatureId);
    [SecurityCriticalAttribute]
public static X509ChainStatusFlags VerifyCertificate(X509Certificate certificate);
    public VerifyResult VerifySignatures(bool exitOnFailure);
}
public abstract class System.IO.Packaging.PackagePart : object {
    private string contentType;
    [CompilerGeneratedAttribute]
private bool <IsRelationship>k__BackingField;
    private int relationshipId;
    private Dictionary`2<string, PackageRelationship> relationships;
    private PackageRelationshipCollection relationshipsCollection;
    [CompilerGeneratedAttribute]
private Stream <PartStream>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <RelationshipsPartUri>k__BackingField;
    [CompilerGeneratedAttribute]
private CompressionOption <CompressionOption>k__BackingField;
    [CompilerGeneratedAttribute]
private Package <Package>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <Uri>k__BackingField;
    internal bool IsRelationship { get; internal set; }
    private Dictionary`2<string, PackageRelationship> Relationships { get; }
    private Stream PartStream { get; private set; }
    internal Uri RelationshipsPartUri { get; internal set; }
    public CompressionOption CompressionOption { get; private set; }
    public string ContentType { get; private set; }
    public Package Package { get; internal set; }
    public Uri Uri { get; private set; }
    protected PackagePart(Package package, Uri partUri);
    protected internal PackagePart(Package package, Uri partUri, string contentType);
    protected internal PackagePart(Package package, Uri partUri, string contentType, CompressionOption compressionOption);
    [CompilerGeneratedAttribute]
internal bool get_IsRelationship();
    [CompilerGeneratedAttribute]
internal void set_IsRelationship(bool value);
    private Dictionary`2<string, PackageRelationship> get_Relationships();
    [CompilerGeneratedAttribute]
private Stream get_PartStream();
    [CompilerGeneratedAttribute]
private void set_PartStream(Stream value);
    [CompilerGeneratedAttribute]
internal Uri get_RelationshipsPartUri();
    [CompilerGeneratedAttribute]
internal void set_RelationshipsPartUri(Uri value);
    [CompilerGeneratedAttribute]
public CompressionOption get_CompressionOption();
    [CompilerGeneratedAttribute]
private void set_CompressionOption(CompressionOption value);
    public string get_ContentType();
    private void set_ContentType(string value);
    [CompilerGeneratedAttribute]
public Package get_Package();
    [CompilerGeneratedAttribute]
internal void set_Package(Package value);
    [CompilerGeneratedAttribute]
public Uri get_Uri();
    [CompilerGeneratedAttribute]
private void set_Uri(Uri value);
    private void CheckIsRelationship();
    public PackageRelationship CreateRelationship(Uri targetUri, TargetMode targetMode, string relationshipType);
    public PackageRelationship CreateRelationship(Uri targetUri, TargetMode targetMode, string relationshipType, string id);
    private PackageRelationship CreateRelationship(Uri targetUri, TargetMode targetMode, string relationshipType, string id, bool loading);
    public void DeleteRelationship(string id);
    private void LoadRelationships(Dictionary`2<string, PackageRelationship> relationships, Stream stream);
    public bool RelationshipExists(string id);
    public PackageRelationship GetRelationship(string id);
    public PackageRelationshipCollection GetRelationships();
    public PackageRelationshipCollection GetRelationshipsByType(string relationshipType);
    public Stream GetStream();
    public Stream GetStream(FileMode mode);
    public Stream GetStream(FileMode mode, FileAccess access);
    protected abstract virtual Stream GetStreamCore(FileMode mode, FileAccess access);
    protected virtual string GetContentTypeCore();
    private string NextId();
    private void WriteRelationships();
}
public class System.IO.Packaging.PackagePartCollection : object {
    [CompilerGeneratedAttribute]
private List`1<PackagePart> <Parts>k__BackingField;
    internal List`1<PackagePart> Parts { get; private set; }
    [CompilerGeneratedAttribute]
internal List`1<PackagePart> get_Parts();
    [CompilerGeneratedAttribute]
private void set_Parts(List`1<PackagePart> value);
    public sealed virtual IEnumerator`1<PackagePart> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public abstract class System.IO.Packaging.PackageProperties : object {
    internal static string NSPackageProperties;
    internal static string NSPackagePropertiesRelation;
    internal static string PackagePropertiesContentType;
    private static int uuid;
    [CompilerGeneratedAttribute]
private Package <Package>k__BackingField;
    [CompilerGeneratedAttribute]
private PackagePart <Part>k__BackingField;
    public string Category { get; public set; }
    public string ContentStatus { get; public set; }
    public string ContentType { get; public set; }
    public Nullable`1<DateTime> Created { get; public set; }
    public string Creator { get; public set; }
    public string Description { get; public set; }
    public string Identifier { get; public set; }
    public string Keywords { get; public set; }
    public string Language { get; public set; }
    public string LastModifiedBy { get; public set; }
    public Nullable`1<DateTime> LastPrinted { get; public set; }
    public Nullable`1<DateTime> Modified { get; public set; }
    internal Package Package { get; internal set; }
    internal PackagePart Part { get; internal set; }
    public string Revision { get; public set; }
    public string Subject { get; public set; }
    public string Title { get; public set; }
    public string Version { get; public set; }
    public abstract virtual string get_Category();
    public abstract virtual void set_Category(string value);
    public abstract virtual string get_ContentStatus();
    public abstract virtual void set_ContentStatus(string value);
    public abstract virtual string get_ContentType();
    public abstract virtual void set_ContentType(string value);
    public abstract virtual Nullable`1<DateTime> get_Created();
    public abstract virtual void set_Created(Nullable`1<DateTime> value);
    public abstract virtual string get_Creator();
    public abstract virtual void set_Creator(string value);
    public abstract virtual string get_Description();
    public abstract virtual void set_Description(string value);
    public abstract virtual string get_Identifier();
    public abstract virtual void set_Identifier(string value);
    public abstract virtual string get_Keywords();
    public abstract virtual void set_Keywords(string value);
    public abstract virtual string get_Language();
    public abstract virtual void set_Language(string value);
    public abstract virtual string get_LastModifiedBy();
    public abstract virtual void set_LastModifiedBy(string value);
    public abstract virtual Nullable`1<DateTime> get_LastPrinted();
    public abstract virtual void set_LastPrinted(Nullable`1<DateTime> value);
    public abstract virtual Nullable`1<DateTime> get_Modified();
    public abstract virtual void set_Modified(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
internal Package get_Package();
    [CompilerGeneratedAttribute]
internal void set_Package(Package value);
    [CompilerGeneratedAttribute]
internal PackagePart get_Part();
    [CompilerGeneratedAttribute]
internal void set_Part(PackagePart value);
    public abstract virtual string get_Revision();
    public abstract virtual void set_Revision(string value);
    public abstract virtual string get_Subject();
    public abstract virtual void set_Subject(string value);
    public abstract virtual string get_Title();
    public abstract virtual void set_Title(string value);
    public abstract virtual string get_Version();
    public abstract virtual void set_Version(string value);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    internal void Flush();
    internal virtual void LoadFrom(Stream stream);
    internal virtual void WriteTo(XmlTextWriter writer);
}
internal class System.IO.Packaging.PackagePropertiesPart : PackageProperties {
    private static string NSDc;
    private static string NSDcTerms;
    private static string NSXsi;
    private string category;
    private string contentStatus;
    private string contentType;
    private Nullable`1<DateTime> created;
    private string creator;
    private string description;
    private string identifier;
    private string keywords;
    private string language;
    private string lastModifiedBy;
    private Nullable`1<DateTime> lastPrinted;
    private Nullable`1<DateTime> modified;
    private string revision;
    private string subject;
    private string title;
    private string version;
    public string Category { get; public set; }
    public string ContentStatus { get; public set; }
    public string ContentType { get; public set; }
    public Nullable`1<DateTime> Created { get; public set; }
    public string Creator { get; public set; }
    public string Description { get; public set; }
    public string Identifier { get; public set; }
    public string Keywords { get; public set; }
    public string Language { get; public set; }
    public string LastModifiedBy { get; public set; }
    public Nullable`1<DateTime> LastPrinted { get; public set; }
    public Nullable`1<DateTime> Modified { get; public set; }
    public string Revision { get; public set; }
    public string Subject { get; public set; }
    public string Title { get; public set; }
    public string Version { get; public set; }
    public virtual string get_Category();
    public virtual void set_Category(string value);
    public virtual string get_ContentStatus();
    public virtual void set_ContentStatus(string value);
    public virtual string get_ContentType();
    public virtual void set_ContentType(string value);
    public virtual Nullable`1<DateTime> get_Created();
    public virtual void set_Created(Nullable`1<DateTime> value);
    public virtual string get_Creator();
    public virtual void set_Creator(string value);
    public virtual string get_Description();
    public virtual void set_Description(string value);
    public virtual string get_Identifier();
    public virtual void set_Identifier(string value);
    public virtual string get_Keywords();
    public virtual void set_Keywords(string value);
    public virtual string get_Language();
    public virtual void set_Language(string value);
    public virtual string get_LastModifiedBy();
    public virtual void set_LastModifiedBy(string value);
    public virtual Nullable`1<DateTime> get_LastPrinted();
    public virtual void set_LastPrinted(Nullable`1<DateTime> value);
    public virtual Nullable`1<DateTime> get_Modified();
    public virtual void set_Modified(Nullable`1<DateTime> value);
    public virtual string get_Revision();
    public virtual void set_Revision(string value);
    public virtual string get_Subject();
    public virtual void set_Subject(string value);
    public virtual string get_Title();
    public virtual void set_Title(string value);
    public virtual string get_Version();
    public virtual void set_Version(string value);
    internal virtual void LoadFrom(Stream stream);
    internal virtual void WriteTo(XmlTextWriter writer);
}
public class System.IO.Packaging.PackageRelationship : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private Package <Package>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RelationshipType>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <SourceUri>k__BackingField;
    [CompilerGeneratedAttribute]
private TargetMode <TargetMode>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <TargetUri>k__BackingField;
    public string Id { get; private set; }
    public Package Package { get; private set; }
    public string RelationshipType { get; private set; }
    public Uri SourceUri { get; private set; }
    public TargetMode TargetMode { get; private set; }
    public Uri TargetUri { get; private set; }
    internal PackageRelationship(string id, Package package, string relationshipType, Uri sourceUri, TargetMode targetMode, Uri targetUri);
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
private void set_Id(string value);
    [CompilerGeneratedAttribute]
public Package get_Package();
    [CompilerGeneratedAttribute]
private void set_Package(Package value);
    [CompilerGeneratedAttribute]
public string get_RelationshipType();
    [CompilerGeneratedAttribute]
private void set_RelationshipType(string value);
    [CompilerGeneratedAttribute]
public Uri get_SourceUri();
    [CompilerGeneratedAttribute]
private void set_SourceUri(Uri value);
    [CompilerGeneratedAttribute]
public TargetMode get_TargetMode();
    [CompilerGeneratedAttribute]
private void set_TargetMode(TargetMode value);
    [CompilerGeneratedAttribute]
public Uri get_TargetUri();
    [CompilerGeneratedAttribute]
private void set_TargetUri(Uri value);
}
public class System.IO.Packaging.PackageRelationshipCollection : object {
    [CompilerGeneratedAttribute]
private List`1<PackageRelationship> <Relationships>k__BackingField;
    internal List`1<PackageRelationship> Relationships { get; private set; }
    [CompilerGeneratedAttribute]
internal List`1<PackageRelationship> get_Relationships();
    [CompilerGeneratedAttribute]
private void set_Relationships(List`1<PackageRelationship> value);
    public sealed virtual IEnumerator`1<PackageRelationship> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class System.IO.Packaging.PackageRelationshipSelector : object {
    public string SelectionCriteria { get; }
    public PackageRelationshipSelectorType SelectorType { get; }
    public Uri SourceUri { get; }
    public PackageRelationshipSelector(Uri sourceUri, PackageRelationshipSelectorType selectorType, string selectionCriteria);
    public string get_SelectionCriteria();
    public PackageRelationshipSelectorType get_SelectorType();
    public Uri get_SourceUri();
    public List`1<PackageRelationship> Select(Package package);
}
public enum System.IO.Packaging.PackageRelationshipSelectorType : Enum {
    public int value__;
    public static PackageRelationshipSelectorType Id;
    public static PackageRelationshipSelectorType Type;
}
public static class System.IO.Packaging.PackUriHelper : object {
    public static string UriSchemePack;
    private static Uri PackSchemeUri;
    private static Char[] _escapedChars;
    private static PackUriHelper();
    public static int ComparePackUri(Uri firstPackUri, Uri secondPackUri);
    public static int ComparePartUri(Uri firstPartUri, Uri secondPartUri);
    public static Uri Create(Uri packageUri);
    public static Uri Create(Uri packageUri, Uri partUri);
    public static Uri Create(Uri packageUri, Uri partUri, string fragment);
    public static Uri CreatePartUri(Uri partUri);
    public static Uri GetNormalizedPartUri(Uri partUri);
    public static Uri GetPackageUri(Uri packUri);
    public static Uri GetPartUri(Uri packUri);
    public static Uri GetRelationshipPartUri(Uri partUri);
    public static Uri GetRelativeUri(Uri sourcePartUri, Uri targetPartUri);
    public static Uri GetSourcePartUriFromRelationshipPartUri(Uri relationshipPartUri);
    public static bool IsRelationshipPartUri(Uri partUri);
    public static Uri ResolvePartUri(Uri sourcePartUri, Uri targetUri);
}
internal class System.IO.Packaging.PackUriParser : GenericUriParser {
    private static string SchemaName;
    private StringBuilder builder;
    protected virtual string GetComponents(Uri uri, UriComponents components, UriFormat format);
    protected virtual void InitializeAndValidate(Uri uri, UriFormatException& parsingError);
    protected virtual UriParser OnNewUri();
}
public class System.IO.Packaging.RightsManagementInformation : object {
    public CryptoProvider CryptoProvider { get; public set; }
    public CryptoProvider get_CryptoProvider();
    public void set_CryptoProvider(CryptoProvider value);
    public void DeleteUseLicense(ContentUser userKey);
    public IDictionary`2<ContentUser, UseLicense> GetEmbeddedUseLicenses();
    public PublishLicense LoadPublishLicense();
    public UseLicense LoadUseLicense(ContentUser userKey);
    public void SavePublishLicense(PublishLicense publishLicense);
    public void SaveUseLicense(ContentUser userKey, UseLicense useLicense);
}
public class System.IO.Packaging.SignatureVerificationEventArgs : EventArgs {
    public PackageDigitalSignature Signature { get; }
    public VerifyResult VerifyResult { get; }
    public PackageDigitalSignature get_Signature();
    public VerifyResult get_VerifyResult();
}
public class System.IO.Packaging.StorageInfo : object {
    public string Name { get; }
    public string get_Name();
    public StreamInfo CreateStream(string name);
    public StreamInfo CreateStream(string name, CompressionOption compressionOption, EncryptionOption encryptionOption);
    public StorageInfo CreateSubStorage(string name);
    public void DeleteStream(string name);
    public void DeleteSubStorage(string name);
    public StreamInfo GetStreamInfo(string name);
    public StreamInfo[] GetStreams();
    public StorageInfo GetSubStorageInfo(string name);
    public StorageInfo[] GetSubStorages();
    public bool StreamExists(string name);
    public bool SubStorageExists(string name);
}
public class System.IO.Packaging.StreamInfo : object {
    public CompressionOption CompressionOption { get; }
    public EncryptionOption EncryptionOption { get; }
    public string Name { get; }
    public CompressionOption get_CompressionOption();
    public EncryptionOption get_EncryptionOption();
    public string get_Name();
    public Stream GetStream();
    public Stream GetStream(FileMode mode);
    public Stream GetStream(FileMode mode, FileAccess access);
}
public enum System.IO.Packaging.TargetMode : Enum {
    public int value__;
    public static TargetMode Internal;
    public static TargetMode External;
}
internal class System.IO.Packaging.UriComparer : object {
    public sealed virtual int GetHashCode(Uri uri);
    public sealed virtual bool Equals(Uri x, Uri y);
}
public enum System.IO.Packaging.VerifyResult : Enum {
    public int value__;
    public static VerifyResult Success;
    public static VerifyResult InvalidSignature;
    public static VerifyResult CertificateRequired;
    public static VerifyResult InvalidCertificate;
    public static VerifyResult ReferenceNotFound;
    public static VerifyResult NotSigned;
}
public class System.IO.Packaging.ZipPackage : Package {
    private static string ContentNamespace;
    private static string ContentUri;
    [CompilerGeneratedAttribute]
private bool <OwnsStream>k__BackingField;
    private Dictionary`2<Uri, ZipPackagePart> parts;
    internal Dictionary`2<Uri, MemoryStream> PartStreams;
    [CompilerGeneratedAttribute]
private Stream <PackageStream>k__BackingField;
    private bool OwnsStream { get; private set; }
    internal Stream PackageStream { get; internal set; }
    private Dictionary`2<Uri, ZipPackagePart> Parts { get; }
    internal ZipPackage(FileAccess access, bool ownsStream, Stream stream);
    internal ZipPackage(FileAccess access, bool ownsStream, Stream stream, bool streaming);
    [CompilerGeneratedAttribute]
private bool get_OwnsStream();
    [CompilerGeneratedAttribute]
private void set_OwnsStream(bool value);
    [CompilerGeneratedAttribute]
internal Stream get_PackageStream();
    [CompilerGeneratedAttribute]
internal void set_PackageStream(Stream value);
    private Dictionary`2<Uri, ZipPackagePart> get_Parts();
    protected virtual void Dispose(bool disposing);
    protected virtual void FlushCore();
    protected virtual PackagePart CreatePartCore(Uri partUri, string contentType, CompressionOption compressionOption);
    protected virtual void DeletePartCore(Uri partUri);
    protected virtual PackagePart GetPartCore(Uri partUri);
    protected virtual PackagePart[] GetPartsCore();
    private void LoadParts();
    private void WriteContentType(Stream s);
}
public class System.IO.Packaging.ZipPackagePart : PackagePart {
    private ZipPackage Package { get; }
    internal ZipPackagePart(Package package, Uri partUri);
    internal ZipPackagePart(Package package, Uri partUri, string contentType);
    internal ZipPackagePart(Package package, Uri partUri, string contentType, CompressionOption compressionOption);
    private ZipPackage get_Package();
    protected virtual Stream GetStreamCore(FileMode mode, FileAccess access);
}
internal class System.IO.Packaging.ZipPartStream : Stream {
    [CompilerGeneratedAttribute]
private MemoryStream <BaseStream>k__BackingField;
    [CompilerGeneratedAttribute]
private ZipPackage <Package>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Position>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Writeable>k__BackingField;
    public MemoryStream BaseStream { get; private set; }
    public ZipPackage Package { get; private set; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanTimeout { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public bool Writeable { get; public set; }
    public int WriteTimeout { get; public set; }
    public int ReadTimeout { get; public set; }
    public ZipPartStream(ZipPackage package, MemoryStream stream, FileAccess access);
    [CompilerGeneratedAttribute]
public MemoryStream get_BaseStream();
    [CompilerGeneratedAttribute]
private void set_BaseStream(MemoryStream value);
    [CompilerGeneratedAttribute]
public ZipPackage get_Package();
    [CompilerGeneratedAttribute]
private void set_Package(ZipPackage value);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanTimeout();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    [CompilerGeneratedAttribute]
public virtual long get_Position();
    [CompilerGeneratedAttribute]
public virtual void set_Position(long value);
    [CompilerGeneratedAttribute]
public bool get_Writeable();
    [CompilerGeneratedAttribute]
public void set_Writeable(bool value);
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
}
[AttributeUsageAttribute("32767")]
internal class System.MonoDocumentationNoteAttribute : MonoTODOAttribute {
    public MonoDocumentationNoteAttribute(string comment);
}
[AttributeUsageAttribute("32767")]
internal class System.MonoExtensionAttribute : MonoTODOAttribute {
    public MonoExtensionAttribute(string comment);
}
[AttributeUsageAttribute("32767")]
internal class System.MonoInternalNoteAttribute : MonoTODOAttribute {
    public MonoInternalNoteAttribute(string comment);
}
[AttributeUsageAttribute("32767")]
internal class System.MonoLimitationAttribute : MonoTODOAttribute {
    public MonoLimitationAttribute(string comment);
}
[AttributeUsageAttribute("32767")]
internal class System.MonoNotSupportedAttribute : MonoTODOAttribute {
    public MonoNotSupportedAttribute(string comment);
}
[AttributeUsageAttribute("32767")]
internal class System.MonoTODOAttribute : Attribute {
    private string comment;
    public string Comment { get; }
    public MonoTODOAttribute(string comment);
    public string get_Comment();
}
public class System.Security.Permissions.MediaPermission : CodeAccessPermission {
    public MediaPermissionAudio Audio { get; }
    public MediaPermissionVideo Video { get; }
    public MediaPermissionImage Image { get; }
    public MediaPermission(MediaPermissionAudio permissionAudio);
    public MediaPermission(MediaPermissionImage permissionImage);
    public MediaPermission(MediaPermissionVideo permissionVideo);
    public MediaPermission(PermissionState state);
    public MediaPermission(MediaPermissionAudio permissionAudio, MediaPermissionVideo permissionVideo, MediaPermissionImage permissionImage);
    public MediaPermissionAudio get_Audio();
    public MediaPermissionVideo get_Video();
    public MediaPermissionImage get_Image();
    public virtual IPermission Copy();
    public virtual void FromXml(SecurityElement securityElement);
    public virtual IPermission Intersect(IPermission target);
    public virtual bool IsSubsetOf(IPermission target);
    public sealed virtual bool IsUnrestricted();
    public virtual SecurityElement ToXml();
    public virtual IPermission Union(IPermission target);
}
[AttributeUsageAttribute("109")]
public class System.Security.Permissions.MediaPermissionAttribute : CodeAccessSecurityAttribute {
    public MediaPermissionAudio Audio { get; public set; }
    public MediaPermissionVideo Video { get; public set; }
    public MediaPermissionImage Image { get; public set; }
    public MediaPermissionAttribute(SecurityAction action);
    public MediaPermissionAudio get_Audio();
    public void set_Audio(MediaPermissionAudio value);
    public MediaPermissionVideo get_Video();
    public void set_Video(MediaPermissionVideo value);
    public MediaPermissionImage get_Image();
    public void set_Image(MediaPermissionImage value);
    public virtual IPermission CreatePermission();
}
public enum System.Security.Permissions.MediaPermissionAudio : Enum {
    public int value__;
    public static MediaPermissionAudio NoAudio;
    public static MediaPermissionAudio SiteOfOriginAudio;
    public static MediaPermissionAudio SafeAudio;
    public static MediaPermissionAudio AllAudio;
}
public enum System.Security.Permissions.MediaPermissionImage : Enum {
    public int value__;
    public static MediaPermissionImage NoImage;
    public static MediaPermissionImage SiteOfOriginImage;
    public static MediaPermissionImage SafeImage;
    public static MediaPermissionImage AllImage;
}
public enum System.Security.Permissions.MediaPermissionVideo : Enum {
    public int value__;
    public static MediaPermissionVideo NoVideo;
    public static MediaPermissionVideo SiteOfOriginVideo;
    public static MediaPermissionVideo SafeVideo;
    public static MediaPermissionVideo AllVideo;
}
public class System.Security.Permissions.WebBrowserPermission : CodeAccessPermission {
    public WebBrowserPermissionLevel Level { get; public set; }
    public WebBrowserPermission(PermissionState state);
    public WebBrowserPermission(WebBrowserPermissionLevel webBrowserPermissionLevel);
    public WebBrowserPermissionLevel get_Level();
    public void set_Level(WebBrowserPermissionLevel value);
    public virtual IPermission Copy();
    public virtual void FromXml(SecurityElement securityElement);
    public virtual IPermission Intersect(IPermission target);
    public virtual bool IsSubsetOf(IPermission target);
    public sealed virtual bool IsUnrestricted();
    public virtual SecurityElement ToXml();
    public virtual IPermission Union(IPermission target);
}
[AttributeUsageAttribute("109")]
public class System.Security.Permissions.WebBrowserPermissionAttribute : CodeAccessSecurityAttribute {
    public WebBrowserPermissionLevel Level { get; public set; }
    public WebBrowserPermissionAttribute(SecurityAction action);
    public WebBrowserPermissionLevel get_Level();
    public void set_Level(WebBrowserPermissionLevel value);
    public virtual IPermission CreatePermission();
}
public enum System.Security.Permissions.WebBrowserPermissionLevel : Enum {
    public int value__;
    public static WebBrowserPermissionLevel None;
    public static WebBrowserPermissionLevel Safe;
    public static WebBrowserPermissionLevel Unrestricted;
}
public enum System.Security.RightsManagement.AuthenticationType : Enum {
    public int value__;
    public static AuthenticationType Windows;
    public static AuthenticationType Passport;
    public static AuthenticationType WindowsPassport;
    public static AuthenticationType Internal;
}
[SecurityCriticalAttribute("1")]
public class System.Security.RightsManagement.ContentGrant : object {
    public ContentRight Right { get; }
    public ContentUser User { get; }
    public DateTime ValidFrom { get; }
    public DateTime ValidUntil { get; }
    public ContentGrant(ContentUser user, ContentRight right);
    public ContentGrant(ContentUser user, ContentRight right, DateTime validFrom, DateTime validUntil);
    public ContentRight get_Right();
    public ContentUser get_User();
    public DateTime get_ValidFrom();
    public DateTime get_ValidUntil();
}
public enum System.Security.RightsManagement.ContentRight : Enum {
    public int value__;
    public static ContentRight View;
    public static ContentRight Edit;
    public static ContentRight Print;
    public static ContentRight Extract;
    public static ContentRight ObjectModel;
    public static ContentRight Owner;
    public static ContentRight ViewRightsData;
    public static ContentRight Forward;
    public static ContentRight Reply;
    public static ContentRight ReplyAll;
    public static ContentRight Sign;
    public static ContentRight DocumentEdit;
    public static ContentRight Export;
}
[SecurityCriticalAttribute("1")]
public class System.Security.RightsManagement.ContentUser : object {
    public static ContentUser AnyoneUser { get; }
    public AuthenticationType AuthenticationType { get; }
    public string Name { get; }
    public static ContentUser OwnerUser { get; }
    public ContentUser(string name, AuthenticationType authenticationType);
    public static ContentUser get_AnyoneUser();
    public AuthenticationType get_AuthenticationType();
    public string get_Name();
    public static ContentUser get_OwnerUser();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public bool IsAuthenticated();
}
[SecurityCriticalAttribute("1")]
public class System.Security.RightsManagement.CryptoProvider : object {
    public int BlockSize { get; }
    public ReadOnlyCollection`1<ContentGrant> BoundGrants { get; }
    public bool CanDecrypt { get; }
    public bool CanEncrypt { get; }
    public bool CanMergeBlocks { get; }
    protected virtual override void Finalize();
    public int get_BlockSize();
    public ReadOnlyCollection`1<ContentGrant> get_BoundGrants();
    public bool get_CanDecrypt();
    public bool get_CanEncrypt();
    public bool get_CanMergeBlocks();
    public Byte[] Decrypt(Byte[] cryptoText);
    public Byte[] Encrypt(Byte[] clearText);
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
}
[SecurityCriticalAttribute("1")]
public class System.Security.RightsManagement.LocalizedNameDescriptionPair : object {
    public string Name { get; }
    public string Description { get; }
    public LocalizedNameDescriptionPair(string name, string description);
    public string get_Name();
    public string get_Description();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[SecurityCriticalAttribute("1")]
public class System.Security.RightsManagement.PublishLicense : object {
    public Guid ContentId { get; }
    public string ReferralInfoName { get; }
    public Uri ReferralInfoUri { get; }
    public Uri UseLicenseAcquisitionUrl { get; }
    public PublishLicense(string signedPublishLicense);
    public Guid get_ContentId();
    public string get_ReferralInfoName();
    public Uri get_ReferralInfoUri();
    public Uri get_UseLicenseAcquisitionUrl();
    public UseLicense AcquireUseLicense(SecureEnvironment secureEnvironment);
    public UseLicense AcquireUseLicenseNoUI(SecureEnvironment secureEnvironment);
    public UnsignedPublishLicense DecryptUnsignedPublishLicense(CryptoProvider cryptoProvider);
    public virtual string ToString();
}
public class System.Security.RightsManagement.RightsManagementException : Exception {
    public RightsManagementFailureCode FailureCode { get; }
    public RightsManagementException(RightsManagementFailureCode failureCode);
    public RightsManagementException(string message);
    public RightsManagementException(RightsManagementFailureCode failureCode, Exception innerException);
    public RightsManagementException(RightsManagementFailureCode failureCode, string message);
    public RightsManagementException(string message, Exception innerException);
    public RightsManagementException(RightsManagementFailureCode failureCode, string message, Exception innerException);
    protected RightsManagementException(SerializationInfo info, StreamingContext context);
    public RightsManagementFailureCode get_FailureCode();
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public enum System.Security.RightsManagement.RightsManagementFailureCode : Enum {
    public int value__;
    public static RightsManagementFailureCode ManifestPolicyViolation;
    public static RightsManagementFailureCode InvalidLicense;
    public static RightsManagementFailureCode InfoNotInLicense;
    public static RightsManagementFailureCode InvalidLicenseSignature;
    public static RightsManagementFailureCode EncryptionNotPermitted;
    public static RightsManagementFailureCode RightNotGranted;
    public static RightsManagementFailureCode InvalidVersion;
    public static RightsManagementFailureCode InvalidEncodingType;
    public static RightsManagementFailureCode InvalidNumericalValue;
    public static RightsManagementFailureCode InvalidAlgorithmType;
    public static RightsManagementFailureCode EnvironmentNotLoaded;
    public static RightsManagementFailureCode EnvironmentCannotLoad;
    public static RightsManagementFailureCode TooManyLoadedEnvironments;
    public static RightsManagementFailureCode IncompatibleObjects;
    public static RightsManagementFailureCode LibraryFail;
    public static RightsManagementFailureCode EnablingPrincipalFailure;
    public static RightsManagementFailureCode InfoNotPresent;
    public static RightsManagementFailureCode BadGetInfoQuery;
    public static RightsManagementFailureCode KeyTypeUnsupported;
    public static RightsManagementFailureCode CryptoOperationUnsupported;
    public static RightsManagementFailureCode ClockRollbackDetected;
    public static RightsManagementFailureCode QueryReportsNoResults;
    public static RightsManagementFailureCode UnexpectedException;
    public static RightsManagementFailureCode BindValidityTimeViolated;
    public static RightsManagementFailureCode BrokenCertChain;
    public static RightsManagementFailureCode BindPolicyViolation;
    public static RightsManagementFailureCode BindRevokedLicense;
    public static RightsManagementFailureCode BindRevokedIssuer;
    public static RightsManagementFailureCode BindRevokedPrincipal;
    public static RightsManagementFailureCode BindRevokedResource;
    public static RightsManagementFailureCode BindRevokedModule;
    public static RightsManagementFailureCode BindContentNotInEndUseLicense;
    public static RightsManagementFailureCode BindAccessPrincipalNotEnabling;
    public static RightsManagementFailureCode BindAccessUnsatisfied;
    public static RightsManagementFailureCode BindIndicatedPrincipalMissing;
    public static RightsManagementFailureCode BindMachineNotFoundInGroupIdentity;
    public static RightsManagementFailureCode LibraryUnsupportedPlugIn;
    public static RightsManagementFailureCode BindRevocationListStale;
    public static RightsManagementFailureCode BindNoApplicableRevocationList;
    public static RightsManagementFailureCode InvalidHandle;
    public static RightsManagementFailureCode BindIntervalTimeViolated;
    public static RightsManagementFailureCode BindNoSatisfiedRightsGroup;
    public static RightsManagementFailureCode BindSpecifiedWorkMissing;
    public static RightsManagementFailureCode NoMoreData;
    public static RightsManagementFailureCode LicenseAcquisitionFailed;
    public static RightsManagementFailureCode IdMismatch;
    public static RightsManagementFailureCode TooManyCertificates;
    public static RightsManagementFailureCode NoDistributionPointUrlFound;
    public static RightsManagementFailureCode AlreadyInProgress;
    public static RightsManagementFailureCode GroupIdentityNotSet;
    public static RightsManagementFailureCode RecordNotFound;
    public static RightsManagementFailureCode NoConnect;
    public static RightsManagementFailureCode NoLicense;
    public static RightsManagementFailureCode NeedsMachineActivation;
    public static RightsManagementFailureCode NeedsGroupIdentityActivation;
    public static RightsManagementFailureCode ActivationFailed;
    public static RightsManagementFailureCode Aborted;
    public static RightsManagementFailureCode OutOfQuota;
    public static RightsManagementFailureCode AuthenticationFailed;
    public static RightsManagementFailureCode ServerError;
    public static RightsManagementFailureCode InstallationFailed;
    public static RightsManagementFailureCode HidCorrupted;
    public static RightsManagementFailureCode InvalidServerResponse;
    public static RightsManagementFailureCode ServiceNotFound;
    public static RightsManagementFailureCode UseDefault;
    public static RightsManagementFailureCode ServerNotFound;
    public static RightsManagementFailureCode InvalidEmail;
    public static RightsManagementFailureCode ValidityTimeViolation;
    public static RightsManagementFailureCode OutdatedModule;
    public static RightsManagementFailureCode NotSet;
    public static RightsManagementFailureCode MetadataNotSet;
    public static RightsManagementFailureCode RevocationInfoNotSet;
    public static RightsManagementFailureCode InvalidTimeInfo;
    public static RightsManagementFailureCode RightNotSet;
    public static RightsManagementFailureCode LicenseBindingToWindowsIdentityFailed;
    public static RightsManagementFailureCode InvalidIssuanceLicenseTemplate;
    public static RightsManagementFailureCode InvalidKeyLength;
    public static RightsManagementFailureCode ExpiredOfficialIssuanceLicenseTemplate;
    public static RightsManagementFailureCode InvalidClientLicensorCertificate;
    public static RightsManagementFailureCode HidInvalid;
    public static RightsManagementFailureCode EmailNotVerified;
    public static RightsManagementFailureCode ServiceMoved;
    public static RightsManagementFailureCode ServiceGone;
    public static RightsManagementFailureCode AdEntryNotFound;
    public static RightsManagementFailureCode NotAChain;
    public static RightsManagementFailureCode RequestDenied;
    public static RightsManagementFailureCode DebuggerDetected;
    public static RightsManagementFailureCode InvalidLockboxType;
    public static RightsManagementFailureCode InvalidLockboxPath;
    public static RightsManagementFailureCode InvalidRegistryPath;
    public static RightsManagementFailureCode NoAesCryptoProvider;
    public static RightsManagementFailureCode GlobalOptionAlreadySet;
    public static RightsManagementFailureCode OwnerLicenseNotFound;
    public static RightsManagementFailureCode Success;
}
[SecurityCriticalAttribute("1")]
public class System.Security.RightsManagement.SecureEnvironment : object {
    public string ApplicationManifest { get; }
    public ContentUser User { get; }
    public string get_ApplicationManifest();
    public ContentUser get_User();
    public static SecureEnvironment Create(string applicationManifest, ContentUser user);
    public static SecureEnvironment Create(string applicationManifest, AuthenticationType authentication, UserActivationMode userActivationMode);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public static ReadOnlyCollection`1<ContentUser> GetActivatedUsers();
    public static bool IsUserActivated(ContentUser user);
    public static void RemoveActivatedUser(ContentUser user);
}
[SecurityCriticalAttribute("1")]
public class System.Security.RightsManagement.UnsignedPublishLicense : object {
    public Guid ContentId { get; public set; }
    public ICollection`1<ContentGrant> Grants { get; }
    public IDictionary`2<int, LocalizedNameDescriptionPair> LocalizedNameDescriptionDictionary { get; }
    public ContentUser Owner { get; public set; }
    public string ReferralInfoName { get; public set; }
    public Uri ReferralInfoUri { get; public set; }
    public UnsignedPublishLicense(string publishLicenseTemplate);
    public Guid get_ContentId();
    public void set_ContentId(Guid value);
    public ICollection`1<ContentGrant> get_Grants();
    public IDictionary`2<int, LocalizedNameDescriptionPair> get_LocalizedNameDescriptionDictionary();
    public ContentUser get_Owner();
    public void set_Owner(ContentUser value);
    public string get_ReferralInfoName();
    public void set_ReferralInfoName(string value);
    public Uri get_ReferralInfoUri();
    public void set_ReferralInfoUri(Uri value);
    public PublishLicense Sign(SecureEnvironment secureEnvironment, UseLicense& authorUseLicense);
    public virtual string ToString();
}
[SecurityCriticalAttribute("1")]
public class System.Security.RightsManagement.UseLicense : object {
    public IDictionary`2<string, string> ApplicationData { get; }
    public Guid ContentId { get; }
    public ContentUser Owner { get; }
    public UseLicense(string useLicense);
    public IDictionary`2<string, string> get_ApplicationData();
    public Guid get_ContentId();
    public ContentUser get_Owner();
    public CryptoProvider Bind(SecureEnvironment secureEnvironment);
    public virtual bool Equals(object x);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public enum System.Security.RightsManagement.UserActivationMode : Enum {
    public int value__;
    public static UserActivationMode Permanent;
    public static UserActivationMode Temporary;
}
public abstract class System.Windows.AttachedPropertyBrowsableAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
public class System.Windows.AttachedPropertyBrowsableForTypeAttribute : AttachedPropertyBrowsableAttribute {
    private Type targetType;
    public Type TargetType { get; }
    public object TypeId { get; }
    public AttachedPropertyBrowsableForTypeAttribute(Type targetType);
    public Type get_TargetType();
    public virtual object get_TypeId();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[AttributeUsageAttribute("64")]
public class System.Windows.AttachedPropertyBrowsableWhenAttributePresentAttribute : AttachedPropertyBrowsableAttribute {
    private Type attributeType;
    public Type AttributeType { get; }
    public AttachedPropertyBrowsableWhenAttributePresentAttribute(Type attributeType);
    public Type get_AttributeType();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class System.Windows.CoerceValueCallback : MulticastDelegate {
    public CoerceValueCallback(object object, IntPtr method);
    public virtual object Invoke(DependencyObject d, object baseValue);
    public virtual IAsyncResult BeginInvoke(DependencyObject d, object baseValue, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
public class System.Windows.Converters.Int32RectValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
public class System.Windows.Converters.PointValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
public class System.Windows.Converters.RectValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
public class System.Windows.Converters.SizeValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
public class System.Windows.Converters.VectorValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
public abstract class System.Windows.Data.DataSourceProvider : object {
    [CompilerGeneratedAttribute]
private EventHandler DataChanged;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    [DesignerSerializationVisibilityAttribute("0")]
public object Data { get; }
    protected Dispatcher Dispatcher { get; protected set; }
    public Exception Error { get; }
    [DefaultValueAttribute("True")]
public bool IsInitialLoadEnabled { get; public set; }
    protected bool IsRefreshDeferred { get; }
    public object get_Data();
    protected Dispatcher get_Dispatcher();
    protected void set_Dispatcher(Dispatcher value);
    public Exception get_Error();
    public bool get_IsInitialLoadEnabled();
    public void set_IsInitialLoadEnabled(bool value);
    protected bool get_IsRefreshDeferred();
    [CompilerGeneratedAttribute]
public void add_DataChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_DataChanged(EventHandler value);
    [CompilerGeneratedAttribute]
protected virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
protected virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    private sealed virtual override void System.ComponentModel.INotifyPropertyChanged.add_PropertyChanged(PropertyChangedEventHandler value);
    private sealed virtual override void System.ComponentModel.INotifyPropertyChanged.remove_PropertyChanged(PropertyChangedEventHandler value);
    protected virtual void BeginInit();
    private sealed virtual override void System.ComponentModel.ISupportInitialize.BeginInit();
    protected virtual void EndInit();
    private sealed virtual override void System.ComponentModel.ISupportInitialize.EndInit();
    protected virtual void BeginQuery();
    public virtual IDisposable DeferRefresh();
    public void InitialLoad();
    protected virtual void OnPropertyChanged(PropertyChangedEventArgs e);
    protected void OnQueryFinished(object newData);
    protected virtual void OnQueryFinished(object newData, Exception error, DispatcherOperationCallback completionWork, object callbackArguments);
    public void Refresh();
}
public class System.Windows.DependencyObject : DispatcherObject {
    private static Dictionary`2<Type, Dictionary`2<string, DependencyProperty>> propertyDeclarations;
    private Dictionary`2<DependencyProperty, object> properties;
    [MonoTODOAttribute]
public bool IsSealed { get; }
    public DependencyObjectType DependencyObjectType { get; }
    private static DependencyObject();
    public bool get_IsSealed();
    public DependencyObjectType get_DependencyObjectType();
    public void ClearValue(DependencyProperty dp);
    public void ClearValue(DependencyPropertyKey key);
    public void CoerceValue(DependencyProperty dp);
    public sealed virtual bool Equals(object obj);
    public sealed virtual int GetHashCode();
    [MonoTODOAttribute]
public LocalValueEnumerator GetLocalValueEnumerator();
    public object GetValue(DependencyProperty dp);
    [MonoTODOAttribute]
public void InvalidateProperty(DependencyProperty dp);
    protected virtual void OnPropertyChanged(DependencyPropertyChangedEventArgs e);
    public object ReadLocalValue(DependencyProperty dp);
    public void SetValue(DependencyProperty dp, object value);
    public void SetValue(DependencyPropertyKey key, object value);
    protected virtual bool ShouldSerializeProperty(DependencyProperty dp);
    internal static void register(Type t, DependencyProperty dp);
}
public class System.Windows.DependencyObjectType : object {
    private static Dictionary`2<Type, DependencyObjectType> typeMap;
    private static int current_id;
    private int id;
    private Type systemType;
    public DependencyObjectType BaseType { get; }
    public int Id { get; }
    public string Name { get; }
    public Type SystemType { get; }
    private DependencyObjectType(int id, Type systemType);
    private static DependencyObjectType();
    public DependencyObjectType get_BaseType();
    public int get_Id();
    public string get_Name();
    public Type get_SystemType();
    public static DependencyObjectType FromSystemType(Type systemType);
    public bool IsInstanceOfType(DependencyObject dependencyObject);
    public bool IsSubclassOf(DependencyObjectType dependencyObjectType);
    public virtual int GetHashCode();
}
public class System.Windows.DependencyProperty : object {
    private Dictionary`2<Type, PropertyMetadata> metadataByType;
    public static object UnsetValue;
    [CompilerGeneratedAttribute]
private bool <IsAttached>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ReadOnly>k__BackingField;
    [CompilerGeneratedAttribute]
private PropertyMetadata <DefaultMetadata>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <OwnerType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <PropertyType>k__BackingField;
    [CompilerGeneratedAttribute]
private ValidateValueCallback <ValidateValueCallback>k__BackingField;
    internal bool IsAttached { get; internal set; }
    public bool ReadOnly { get; private set; }
    public PropertyMetadata DefaultMetadata { get; private set; }
    public string Name { get; private set; }
    public Type OwnerType { get; private set; }
    public Type PropertyType { get; private set; }
    public ValidateValueCallback ValidateValueCallback { get; private set; }
    public int GlobalIndex { get; }
    private DependencyProperty(bool isAttached, string name, Type propertyType, Type ownerType, PropertyMetadata defaultMetadata, ValidateValueCallback validateValueCallback);
    private static DependencyProperty();
    [CompilerGeneratedAttribute]
internal bool get_IsAttached();
    [CompilerGeneratedAttribute]
internal void set_IsAttached(bool value);
    [CompilerGeneratedAttribute]
public bool get_ReadOnly();
    [CompilerGeneratedAttribute]
private void set_ReadOnly(bool value);
    [CompilerGeneratedAttribute]
public PropertyMetadata get_DefaultMetadata();
    [CompilerGeneratedAttribute]
private void set_DefaultMetadata(PropertyMetadata value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public Type get_OwnerType();
    [CompilerGeneratedAttribute]
private void set_OwnerType(Type value);
    [CompilerGeneratedAttribute]
public Type get_PropertyType();
    [CompilerGeneratedAttribute]
private void set_PropertyType(Type value);
    [CompilerGeneratedAttribute]
public ValidateValueCallback get_ValidateValueCallback();
    [CompilerGeneratedAttribute]
private void set_ValidateValueCallback(ValidateValueCallback value);
    public int get_GlobalIndex();
    public DependencyProperty AddOwner(Type ownerType);
    public DependencyProperty AddOwner(Type ownerType, PropertyMetadata typeMetadata);
    public PropertyMetadata GetMetadata(Type forType);
    public PropertyMetadata GetMetadata(DependencyObject dependencyObject);
    public PropertyMetadata GetMetadata(DependencyObjectType dependencyObjectType);
    public bool IsValidType(object value);
    public bool IsValidValue(object value);
    public void OverrideMetadata(Type forType, PropertyMetadata typeMetadata);
    public void OverrideMetadata(Type forType, PropertyMetadata typeMetadata, DependencyPropertyKey key);
    public virtual string ToString();
    public virtual int GetHashCode();
    public static DependencyProperty Register(string name, Type propertyType, Type ownerType);
    public static DependencyProperty Register(string name, Type propertyType, Type ownerType, PropertyMetadata typeMetadata);
    public static DependencyProperty Register(string name, Type propertyType, Type ownerType, PropertyMetadata typeMetadata, ValidateValueCallback validateValueCallback);
    public static DependencyProperty RegisterAttached(string name, Type propertyType, Type ownerType);
    public static DependencyProperty RegisterAttached(string name, Type propertyType, Type ownerType, PropertyMetadata defaultMetadata);
    public static DependencyProperty RegisterAttached(string name, Type propertyType, Type ownerType, PropertyMetadata defaultMetadata, ValidateValueCallback validateValueCallback);
    public static DependencyPropertyKey RegisterAttachedReadOnly(string name, Type propertyType, Type ownerType, PropertyMetadata defaultMetadata);
    public static DependencyPropertyKey RegisterAttachedReadOnly(string name, Type propertyType, Type ownerType, PropertyMetadata defaultMetadata, ValidateValueCallback validateValueCallback);
    public static DependencyPropertyKey RegisterReadOnly(string name, Type propertyType, Type ownerType, PropertyMetadata typeMetadata);
    public static DependencyPropertyKey RegisterReadOnly(string name, Type propertyType, Type ownerType, PropertyMetadata typeMetadata, ValidateValueCallback validateValueCallback);
}
public class System.Windows.DependencyPropertyChangedEventArgs : ValueType {
    [CompilerGeneratedAttribute]
private object <NewValue>k__BackingField;
    [CompilerGeneratedAttribute]
private object <OldValue>k__BackingField;
    [CompilerGeneratedAttribute]
private DependencyProperty <Property>k__BackingField;
    public object NewValue { get; private set; }
    public object OldValue { get; private set; }
    public DependencyProperty Property { get; private set; }
    public DependencyPropertyChangedEventArgs(DependencyProperty property, object oldValue, object newValue);
    [CompilerGeneratedAttribute]
public object get_NewValue();
    [CompilerGeneratedAttribute]
private void set_NewValue(object value);
    [CompilerGeneratedAttribute]
public object get_OldValue();
    [CompilerGeneratedAttribute]
private void set_OldValue(object value);
    [CompilerGeneratedAttribute]
public DependencyProperty get_Property();
    [CompilerGeneratedAttribute]
private void set_Property(DependencyProperty value);
    public virtual bool Equals(object obj);
    public bool Equals(DependencyPropertyChangedEventArgs args);
    public static bool op_Inequality(DependencyPropertyChangedEventArgs left, DependencyPropertyChangedEventArgs right);
    public static bool op_Equality(DependencyPropertyChangedEventArgs left, DependencyPropertyChangedEventArgs right);
    public virtual int GetHashCode();
}
public class System.Windows.DependencyPropertyChangedEventHandler : MulticastDelegate {
    public DependencyPropertyChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, DependencyPropertyChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, DependencyPropertyChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.DependencyPropertyKey : object {
    private DependencyProperty dependencyProperty;
    public DependencyProperty DependencyProperty { get; }
    internal DependencyPropertyKey(DependencyProperty dependencyProperty);
    public DependencyProperty get_DependencyProperty();
    public void OverrideMetadata(Type forType, PropertyMetadata typeMetadata);
}
[TypeConverterAttribute("System.Windows.ExpressionConverter")]
public class System.Windows.Expression : object {
}
public class System.Windows.ExpressionConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public abstract class System.Windows.Freezable : DependencyObject {
    [CompilerGeneratedAttribute]
private EventHandler Changed;
    public bool CanFreeze { get; }
    public bool IsFrozen { get; }
    public Freezable Clone();
    protected virtual void CloneCore(Freezable sourceFreezable);
    public Freezable CloneCurrentValue();
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected Freezable CreateInstance();
    protected abstract virtual Freezable CreateInstanceCore();
    public void Freeze();
    protected static bool Freeze(Freezable freezable, bool isChecking);
    protected virtual bool FreezeCore(bool isChecking);
    public Freezable GetAsFrozen();
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    public Freezable GetCurrentValueAsFrozen();
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    protected virtual void OnChanged();
    protected void OnFreezablePropertyChanged(DependencyObject oldValue, DependencyObject newValue);
    protected void OnFreezablePropertyChanged(DependencyObject oldValue, DependencyObject newValue, DependencyProperty property);
    protected virtual void OnPropertyChanged(DependencyPropertyChangedEventArgs e);
    protected void ReadPreamble();
    protected void WritePostscript();
    protected void WritePreamble();
    public bool get_CanFreeze();
    public bool get_IsFrozen();
    [CompilerGeneratedAttribute]
public void add_Changed(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_Changed(EventHandler value);
}
public enum System.Windows.Input.FocusNavigationDirection : Enum {
    public int value__;
    public static FocusNavigationDirection Next;
    public static FocusNavigationDirection Previous;
    public static FocusNavigationDirection First;
    public static FocusNavigationDirection Last;
    public static FocusNavigationDirection Left;
    public static FocusNavigationDirection Right;
    public static FocusNavigationDirection Up;
    public static FocusNavigationDirection Down;
}
[ValueSerializerAttribute("System.Windows.Input.KeyValueSerializer")]
[TypeConverterAttribute("System.Windows.Input.KeyConverter")]
public enum System.Windows.Input.Key : Enum {
    public int value__;
    public static Key None;
    public static Key Cancel;
    public static Key Back;
    public static Key Tab;
    public static Key LineFeed;
    public static Key Clear;
    public static Key Return;
    public static Key Enter;
    public static Key Pause;
    public static Key CapsLock;
    public static Key Capital;
    public static Key HangulMode;
    public static Key KanaMode;
    public static Key JunjaMode;
    public static Key FinalMode;
    public static Key KanjiMode;
    public static Key HanjaMode;
    public static Key Escape;
    public static Key ImeConvert;
    public static Key ImeNonConvert;
    public static Key ImeAccept;
    public static Key ImeModeChange;
    public static Key Space;
    public static Key PageUp;
    public static Key Prior;
    public static Key PageDown;
    public static Key Next;
    public static Key End;
    public static Key Home;
    public static Key Left;
    public static Key Up;
    public static Key Right;
    public static Key Down;
    public static Key Select;
    public static Key Print;
    public static Key Execute;
    public static Key PrintScreen;
    public static Key Snapshot;
    public static Key Insert;
    public static Key Delete;
    public static Key Help;
    public static Key D0;
    public static Key D1;
    public static Key D2;
    public static Key D3;
    public static Key D4;
    public static Key D5;
    public static Key D6;
    public static Key D7;
    public static Key D8;
    public static Key D9;
    public static Key A;
    public static Key B;
    public static Key C;
    public static Key D;
    public static Key E;
    public static Key F;
    public static Key G;
    public static Key H;
    public static Key I;
    public static Key J;
    public static Key K;
    public static Key L;
    public static Key M;
    public static Key N;
    public static Key O;
    public static Key P;
    public static Key Q;
    public static Key R;
    public static Key S;
    public static Key T;
    public static Key U;
    public static Key V;
    public static Key W;
    public static Key X;
    public static Key Y;
    public static Key Z;
    public static Key LWin;
    public static Key RWin;
    public static Key Apps;
    public static Key Sleep;
    public static Key NumPad0;
    public static Key NumPad1;
    public static Key NumPad2;
    public static Key NumPad3;
    public static Key NumPad4;
    public static Key NumPad5;
    public static Key NumPad6;
    public static Key NumPad7;
    public static Key NumPad8;
    public static Key NumPad9;
    public static Key Multiply;
    public static Key Add;
    public static Key Separator;
    public static Key Subtract;
    public static Key Decimal;
    public static Key Divide;
    public static Key F1;
    public static Key F2;
    public static Key F3;
    public static Key F4;
    public static Key F5;
    public static Key F6;
    public static Key F7;
    public static Key F8;
    public static Key F9;
    public static Key F10;
    public static Key F11;
    public static Key F12;
    public static Key F13;
    public static Key F14;
    public static Key F15;
    public static Key F16;
    public static Key F17;
    public static Key F18;
    public static Key F19;
    public static Key F20;
    public static Key F21;
    public static Key F22;
    public static Key F23;
    public static Key F24;
    public static Key NumLock;
    public static Key Scroll;
    public static Key LeftShift;
    public static Key RightShift;
    public static Key LeftCtrl;
    public static Key RightCtrl;
    public static Key LeftAlt;
    public static Key RightAlt;
    public static Key BrowserBack;
    public static Key BrowserForward;
    public static Key BrowserRefresh;
    public static Key BrowserStop;
    public static Key BrowserSearch;
    public static Key BrowserFavorites;
    public static Key BrowserHome;
    public static Key VolumeMute;
    public static Key VolumeDown;
    public static Key VolumeUp;
    public static Key MediaNextTrack;
    public static Key MediaPreviousTrack;
    public static Key MediaStop;
    public static Key MediaPlayPause;
    public static Key LaunchMail;
    public static Key SelectMedia;
    public static Key LaunchApplication1;
    public static Key LaunchApplication2;
    public static Key Oem1;
    public static Key OemSemicolon;
    public static Key OemPlus;
    public static Key OemComma;
    public static Key OemMinus;
    public static Key OemPeriod;
    public static Key Oem2;
    public static Key OemQuestion;
    public static Key Oem3;
    public static Key OemTilde;
    public static Key AbntC1;
    public static Key AbntC2;
    public static Key Oem4;
    public static Key OemOpenBrackets;
    public static Key Oem5;
    public static Key OemPipe;
    public static Key Oem6;
    public static Key OemCloseBrackets;
    public static Key Oem7;
    public static Key OemQuotes;
    public static Key Oem8;
    public static Key Oem102;
    public static Key OemBackslash;
    public static Key ImeProcessed;
    public static Key System;
    public static Key OemAttn;
    public static Key DbeAlphanumeric;
    public static Key OemFinish;
    public static Key DbeKatakana;
    public static Key OemCopy;
    public static Key DbeHiragana;
    public static Key OemAuto;
    public static Key DbeSbcsChar;
    public static Key OemEnlw;
    public static Key DbeDbcsChar;
    public static Key OemBackTab;
    public static Key DbeRoman;
    public static Key Attn;
    public static Key DbeNoRoman;
    public static Key CrSel;
    public static Key DbeEnterWordRegisterMode;
    public static Key ExSel;
    public static Key DbeEnterImeConfigureMode;
    public static Key EraseEof;
    public static Key DbeFlushString;
    public static Key Play;
    public static Key DbeCodeInput;
    public static Key Zoom;
    public static Key DbeNoCodeInput;
    public static Key NoName;
    public static Key DbeDetermineString;
    public static Key Pa1;
    public static Key DbeEnterDialogConversionMode;
    public static Key OemClear;
    public static Key DeadCharProcessed;
}
public class System.Windows.Input.KeyConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object source);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public static class System.Windows.Input.KeyInterop : object {
    public static Key KeyFromVirtualKey(int virtualKey);
    public static int VirtualKeyFromKey(Key key);
}
public class System.Windows.Input.KeyValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
[FlagsAttribute]
[ValueSerializerAttribute("System.Windows.Input.ModifierKeysValueSerializer")]
[TypeConverterAttribute("System.Windows.Input.ModifierKeysConverter")]
public enum System.Windows.Input.ModifierKeys : Enum {
    public int value__;
    public static ModifierKeys None;
    public static ModifierKeys Alt;
    public static ModifierKeys Control;
    public static ModifierKeys Shift;
    public static ModifierKeys Windows;
}
public class System.Windows.Input.ModifierKeysConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object source);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
    public static bool IsDefinedModifierKeys(ModifierKeys modifierKeys);
}
public class System.Windows.Input.ModifierKeysValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
public class System.Windows.Input.TraversalRequest : object {
    private bool wrapped;
    private FocusNavigationDirection focusNavigationDirection;
    public FocusNavigationDirection FocusNavigationDirection { get; }
    public bool Wrapped { get; public set; }
    public TraversalRequest(FocusNavigationDirection focusNavigationDirection);
    public FocusNavigationDirection get_FocusNavigationDirection();
    public bool get_Wrapped();
    public void set_Wrapped(bool value);
}
[TypeConverterAttribute("System.Windows.Int32RectConverter")]
[ValueSerializerAttribute("System.Windows.Converters.Int32RectValueSerializer")]
public class System.Windows.Int32Rect : ValueType {
    private int _x;
    private int _y;
    private int _width;
    private int _height;
    public static Int32Rect Empty { get; }
    public int Height { get; public set; }
    public bool IsEmpty { get; }
    public int Width { get; public set; }
    public int X { get; public set; }
    public int Y { get; public set; }
    public Int32Rect(int x, int y, int width, int height);
    public static bool op_Inequality(Int32Rect int32Rect1, Int32Rect int32Rect2);
    public static bool op_Equality(Int32Rect int32Rect1, Int32Rect int32Rect2);
    public static Int32Rect get_Empty();
    public int get_Height();
    public void set_Height(int value);
    public bool get_IsEmpty();
    public int get_Width();
    public void set_Width(int value);
    public int get_X();
    public void set_X(int value);
    public int get_Y();
    public void set_Y(int value);
    public bool Equals(Int32Rect value);
    public virtual bool Equals(object o);
    public static bool Equals(Int32Rect int32Rect1, Int32Rect int32Rect2);
    public virtual int GetHashCode();
    public static Int32Rect Parse(string source);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    private string ToString(string format, IFormatProvider provider);
}
public class System.Windows.Int32RectConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public static class System.Windows.Interop.ComponentDispatcher : object {
    [CompilerGeneratedAttribute]
private static EventHandler EnterThreadModal;
    [CompilerGeneratedAttribute]
private static EventHandler LeaveThreadModal;
    [CompilerGeneratedAttribute]
private static ThreadMessageEventHandler ThreadFilterMessage;
    [CompilerGeneratedAttribute]
private static EventHandler ThreadIdle;
    [CompilerGeneratedAttribute]
private static ThreadMessageEventHandler ThreadPreprocessMessage;
    public static MSG CurrentKeyboardMessage { get; }
    public static bool IsThreadModal { get; }
    [SecurityCriticalAttribute]
public static MSG get_CurrentKeyboardMessage();
    [SecurityCriticalAttribute]
public static bool get_IsThreadModal();
    [CompilerGeneratedAttribute]
public static void add_EnterThreadModal(EventHandler value);
    [CompilerGeneratedAttribute]
public static void remove_EnterThreadModal(EventHandler value);
    [CompilerGeneratedAttribute]
public static void add_LeaveThreadModal(EventHandler value);
    [CompilerGeneratedAttribute]
public static void remove_LeaveThreadModal(EventHandler value);
    [CompilerGeneratedAttribute]
public static void add_ThreadFilterMessage(ThreadMessageEventHandler value);
    [CompilerGeneratedAttribute]
public static void remove_ThreadFilterMessage(ThreadMessageEventHandler value);
    [CompilerGeneratedAttribute]
public static void add_ThreadIdle(EventHandler value);
    [CompilerGeneratedAttribute]
public static void remove_ThreadIdle(EventHandler value);
    [CompilerGeneratedAttribute]
public static void add_ThreadPreprocessMessage(ThreadMessageEventHandler value);
    [CompilerGeneratedAttribute]
public static void remove_ThreadPreprocessMessage(ThreadMessageEventHandler value);
    [SecurityCriticalAttribute]
public static void PopModal();
    [SecurityCriticalAttribute]
public static void PushModal();
    [SecurityCriticalAttribute]
public static void RaiseIdle();
    [SecurityCriticalAttribute]
public static bool RaiseThreadMessage(MSG& msg);
}
public interface System.Windows.Interop.IKeyboardInputSink {
    public IKeyboardInputSite KeyboardInputSite { get; public set; }
    public abstract virtual IKeyboardInputSite get_KeyboardInputSite();
    [SecurityCriticalAttribute]
public abstract virtual void set_KeyboardInputSite(IKeyboardInputSite value);
    public abstract virtual bool TabInto(TraversalRequest request);
    public abstract virtual bool HasFocusWithin();
    [SecurityCriticalAttribute]
public abstract virtual bool OnMnemonic(MSG& msg, ModifierKeys modifiers);
    [SecurityCriticalAttribute]
public abstract virtual IKeyboardInputSite RegisterKeyboardInputSink(IKeyboardInputSink sink);
    [SecurityCriticalAttribute]
public abstract virtual bool TranslateAccelerator(MSG& msg, ModifierKeys modifiers);
    [SecurityCriticalAttribute]
public abstract virtual bool TranslateChar(MSG& msg, ModifierKeys modifiers);
}
public interface System.Windows.Interop.IKeyboardInputSite {
    public IKeyboardInputSink Sink { get; }
    public abstract virtual IKeyboardInputSink get_Sink();
    public abstract virtual bool OnNoMoreTabStops(TraversalRequest request);
    [SecurityCriticalAttribute]
public abstract virtual void Unregister();
}
public class System.Windows.Interop.MSG : ValueType {
    public IntPtr hwnd { get; public set; }
    public IntPtr lParam { get; public set; }
    public IntPtr wParam { get; public set; }
    public int message { get; public set; }
    public int pt_x { get; public set; }
    public int pt_y { get; public set; }
    public int time { get; public set; }
    [SecurityCriticalAttribute]
public IntPtr get_hwnd();
    [SecurityCriticalAttribute]
public void set_hwnd(IntPtr value);
    [SecurityCriticalAttribute]
public IntPtr get_lParam();
    [SecurityCriticalAttribute]
public void set_lParam(IntPtr value);
    [SecurityCriticalAttribute]
public IntPtr get_wParam();
    [SecurityCriticalAttribute]
public void set_wParam(IntPtr value);
    [SecurityCriticalAttribute]
public int get_message();
    [SecurityCriticalAttribute]
public void set_message(int value);
    [SecurityCriticalAttribute]
public int get_pt_x();
    [SecurityCriticalAttribute]
public void set_pt_x(int value);
    [SecurityCriticalAttribute]
public int get_pt_y();
    [SecurityCriticalAttribute]
public void set_pt_y(int value);
    [SecurityCriticalAttribute]
public int get_time();
    [SecurityCriticalAttribute]
public void set_time(int value);
}
public class System.Windows.Interop.ThreadMessageEventHandler : MulticastDelegate {
    public ThreadMessageEventHandler(object object, IntPtr method);
    public virtual void Invoke(MSG& msg, Boolean& handled);
    public virtual IAsyncResult BeginInvoke(MSG& msg, Boolean& handled, AsyncCallback callback, object object);
    public virtual void EndInvoke(MSG& msg, Boolean& handled, IAsyncResult result);
}
public interface System.Windows.IWeakEventListener {
    public abstract virtual bool ReceiveWeakEvent(Type managerType, object sender, EventArgs e);
}
public class System.Windows.LocalValueEntry : ValueType {
    private DependencyProperty property;
    private object value;
    public DependencyProperty Property { get; }
    public object Value { get; }
    internal LocalValueEntry(DependencyProperty property, object value);
    public DependencyProperty get_Property();
    public object get_Value();
    public static bool op_Inequality(LocalValueEntry obj1, LocalValueEntry obj2);
    public static bool op_Equality(LocalValueEntry obj1, LocalValueEntry obj2);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class System.Windows.LocalValueEnumerator : ValueType {
    private IDictionaryEnumerator propertyEnumerator;
    private Dictionary`2<DependencyProperty, object> properties;
    private int count;
    public int Count { get; }
    public LocalValueEntry Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    internal LocalValueEnumerator(Dictionary`2<DependencyProperty, object> properties);
    public int get_Count();
    public LocalValueEntry get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
    public static bool op_Inequality(LocalValueEnumerator obj1, LocalValueEnumerator obj2);
    public static bool op_Equality(LocalValueEnumerator obj1, LocalValueEnumerator obj2);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[FlagsAttribute]
public enum System.Windows.Markup.DesignerSerializationOptions : Enum {
    public int value__;
    public static DesignerSerializationOptions SerializeAsAttribute;
}
[AttributeUsageAttribute("448")]
public class System.Windows.Markup.DesignerSerializationOptionsAttribute : Attribute {
    private DesignerSerializationOptions designerSerializationOptions;
    public DesignerSerializationOptions DesignerSerializationOptions { get; }
    public DesignerSerializationOptionsAttribute(DesignerSerializationOptions designerSerializationOptions);
    public DesignerSerializationOptions get_DesignerSerializationOptions();
}
[EditorBrowsableAttribute("1")]
public abstract class System.Windows.Markup.InternalTypeHelper : object {
    protected internal abstract virtual void AddEventHandler(EventInfo eventInfo, object target, Delegate handler);
    protected internal abstract virtual Delegate CreateDelegate(Type delegateType, object target, string handler);
    protected internal abstract virtual object CreateInstance(Type type, CultureInfo culture);
    protected internal abstract virtual object GetPropertyValue(PropertyInfo propertyInfo, object target, CultureInfo culture);
    protected internal abstract virtual void SetPropertyValue(PropertyInfo propertyInfo, object target, object value, CultureInfo culture);
}
public interface System.Windows.Markup.IReceiveMarkupExtension {
    public abstract virtual void ReceiveMarkupExtension(string property, MarkupExtension markupExtension, IServiceProvider serviceProvider);
}
public abstract class System.Windows.Markup.Primitives.MarkupObject : object {
    public AttributeCollection Attributes { get; }
    public object Instance { get; }
    public Type ObjectType { get; }
    public IEnumerable`1<MarkupProperty> Properties { get; }
    public abstract virtual AttributeCollection get_Attributes();
    public abstract virtual object get_Instance();
    public abstract virtual Type get_ObjectType();
    public virtual IEnumerable`1<MarkupProperty> get_Properties();
    public abstract virtual void AssignRootContext(IValueSerializerContext context);
}
public abstract class System.Windows.Markup.Primitives.MarkupProperty : object {
    public AttributeCollection Attributes { get; }
    public IEnumerable`1<MarkupObject> Items { get; }
    public string Name { get; }
    public Type PropertyType { get; }
    public string StringValue { get; }
    public IEnumerable`1<Type> TypeReferences { get; }
    public object Value { get; }
    public DependencyProperty DependencyProperty { get; }
    public bool IsAttached { get; }
    public bool IsComposite { get; }
    public bool IsConstructorArgument { get; }
    public bool IsContent { get; }
    public bool IsKey { get; }
    public bool IsValueAsString { get; }
    public PropertyDescriptor PropertyDescriptor { get; }
    public abstract virtual AttributeCollection get_Attributes();
    public abstract virtual IEnumerable`1<MarkupObject> get_Items();
    public abstract virtual string get_Name();
    public abstract virtual Type get_PropertyType();
    public abstract virtual string get_StringValue();
    public abstract virtual IEnumerable`1<Type> get_TypeReferences();
    public abstract virtual object get_Value();
    public virtual DependencyProperty get_DependencyProperty();
    public virtual bool get_IsAttached();
    public virtual bool get_IsComposite();
    public virtual bool get_IsConstructorArgument();
    public virtual bool get_IsContent();
    public virtual bool get_IsKey();
    public virtual bool get_IsValueAsString();
    public virtual PropertyDescriptor get_PropertyDescriptor();
}
[EditorBrowsableAttribute("1")]
[BrowsableAttribute("False")]
public class System.Windows.Markup.ServiceProviders : object {
    public void AddService(Type serviceType, object service);
    public sealed virtual object GetService(Type serviceType);
}
public class System.Windows.Media.Converters.MatrixValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
[AttributeUsageAttribute("1")]
public class System.Windows.Media.DisableDpiAwarenessAttribute : Attribute {
}
[TypeConverterAttribute("System.Windows.Media.MatrixConverter")]
[ValueSerializerAttribute("System.Windows.Media.Converters.MatrixValueSerializer")]
public class System.Windows.Media.Matrix : ValueType {
    private double _m11;
    private double _m12;
    private double _m21;
    private double _m22;
    private double _offsetX;
    private double _offsetY;
    public double Determinant { get; }
    public bool HasInverse { get; }
    public static Matrix Identity { get; }
    public bool IsIdentity { get; }
    public double M11 { get; public set; }
    public double M12 { get; public set; }
    public double M21 { get; public set; }
    public double M22 { get; public set; }
    public double OffsetX { get; public set; }
    public double OffsetY { get; public set; }
    public Matrix(double m11, double m12, double m21, double m22, double offsetX, double offsetY);
    public void Append(Matrix matrix);
    public bool Equals(Matrix value);
    public virtual bool Equals(object o);
    public static bool Equals(Matrix matrix1, Matrix matrix2);
    public virtual int GetHashCode();
    public void Invert();
    public static Matrix Multiply(Matrix trans1, Matrix trans2);
    public static bool op_Equality(Matrix matrix1, Matrix matrix2);
    public static bool op_Inequality(Matrix matrix1, Matrix matrix2);
    public static Matrix op_Multiply(Matrix trans1, Matrix trans2);
    public static Matrix Parse(string source);
    public void Prepend(Matrix matrix);
    public void Rotate(double angle);
    public void RotateAt(double angle, double centerX, double centerY);
    public void RotateAtPrepend(double angle, double centerX, double centerY);
    public void RotatePrepend(double angle);
    public void Scale(double scaleX, double scaleY);
    public void ScaleAt(double scaleX, double scaleY, double centerX, double centerY);
    public void ScaleAtPrepend(double scaleX, double scaleY, double centerX, double centerY);
    public void ScalePrepend(double scaleX, double scaleY);
    public void SetIdentity();
    public void Skew(double skewX, double skewY);
    public void SkewPrepend(double skewX, double skewY);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    private string ToString(string format, IFormatProvider provider);
    public Point Transform(Point point);
    public void Transform(Point[] points);
    public Vector Transform(Vector vector);
    public void Transform(Vector[] vectors);
    public void Translate(double offsetX, double offsetY);
    public void TranslatePrepend(double offsetX, double offsetY);
    public double get_Determinant();
    public bool get_HasInverse();
    public static Matrix get_Identity();
    public bool get_IsIdentity();
    public double get_M11();
    public void set_M11(double value);
    public double get_M12();
    public void set_M12(double value);
    public double get_M21();
    public void set_M21(double value);
    public double get_M22();
    public void set_M22(double value);
    public double get_OffsetX();
    public void set_OffsetX(double value);
    public double get_OffsetY();
    public void set_OffsetY(double value);
}
public class System.Windows.Media.MatrixConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
internal class System.Windows.NumericListTokenizer : object {
    private string _str;
    private char _separator;
    private int _position;
    public NumericListTokenizer(string str, IFormatProvider formatProvider);
    public static char GetSeparator(IFormatProvider formatProvider);
    private Symbol GetCurrentSymbol();
    private void SkipAllWhitespaces();
    private void SkipNextDelimeter();
    public bool HasNoMoreTokens();
    public string GetNextToken();
}
[TypeConverterAttribute("System.Windows.PointConverter")]
[ValueSerializerAttribute("System.Windows.Converters.PointValueSerializer")]
public class System.Windows.Point : ValueType {
    private double _x;
    private double _y;
    public double X { get; public set; }
    public double Y { get; public set; }
    public Point(double x, double y);
    public double get_X();
    public void set_X(double value);
    public double get_Y();
    public void set_Y(double value);
    public virtual bool Equals(object o);
    public bool Equals(Point value);
    public virtual int GetHashCode();
    public void Offset(double offsetX, double offsetY);
    public static Point Add(Point point, Vector vector);
    public static bool Equals(Point point1, Point point2);
    public static Point Multiply(Point point, Matrix matrix);
    public static Vector Subtract(Point point1, Point point2);
    public static Point Subtract(Point point, Vector vector);
    public static Vector op_Subtraction(Point point1, Point point2);
    public static Point op_Subtraction(Point point, Vector vector);
    public static Point op_Addition(Point point, Vector vector);
    public static Point op_Multiply(Point point, Matrix matrix);
    public static bool op_Inequality(Point point1, Point point2);
    public static bool op_Equality(Point point1, Point point2);
    public static Size op_Explicit(Point point);
    public static Vector op_Explicit(Point point);
    public static Point Parse(string source);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    private string ToString(string format, IFormatProvider formatProvider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider formatProvider);
}
public class System.Windows.PointConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public class System.Windows.PropertyChangedCallback : MulticastDelegate {
    public PropertyChangedCallback(object object, IntPtr method);
    public virtual void Invoke(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(DependencyObject d, DependencyPropertyChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.PropertyMetadata : object {
    private object defaultValue;
    private bool isSealed;
    private PropertyChangedCallback propertyChangedCallback;
    private CoerceValueCallback coerceValueCallback;
    protected bool IsSealed { get; }
    public object DefaultValue { get; public set; }
    public PropertyChangedCallback PropertyChangedCallback { get; public set; }
    public CoerceValueCallback CoerceValueCallback { get; public set; }
    public PropertyMetadata(object defaultValue);
    public PropertyMetadata(PropertyChangedCallback propertyChangedCallback);
    public PropertyMetadata(object defaultValue, PropertyChangedCallback propertyChangedCallback);
    public PropertyMetadata(object defaultValue, PropertyChangedCallback propertyChangedCallback, CoerceValueCallback coerceValueCallback);
    protected bool get_IsSealed();
    public object get_DefaultValue();
    public void set_DefaultValue(object value);
    public PropertyChangedCallback get_PropertyChangedCallback();
    public void set_PropertyChangedCallback(PropertyChangedCallback value);
    public CoerceValueCallback get_CoerceValueCallback();
    public void set_CoerceValueCallback(CoerceValueCallback value);
    protected virtual void Merge(PropertyMetadata baseMetadata, DependencyProperty dp);
    protected virtual void OnApply(DependencyProperty dp, Type targetType);
    internal void DoMerge(PropertyMetadata baseMetadata, DependencyProperty dp, Type targetType);
}
[ValueSerializerAttribute("System.Windows.Converters.RectValueSerializer")]
[TypeConverterAttribute("System.Windows.RectConverter")]
public class System.Windows.Rect : ValueType {
    private double _x;
    private double _y;
    private double _width;
    private double _height;
    public static Rect Empty { get; }
    public bool IsEmpty { get; }
    public Point Location { get; public set; }
    public Size Size { get; public set; }
    public double X { get; public set; }
    public double Y { get; public set; }
    public double Width { get; public set; }
    public double Height { get; public set; }
    public double Left { get; }
    public double Top { get; }
    public double Right { get; }
    public double Bottom { get; }
    public Point TopLeft { get; }
    public Point TopRight { get; }
    public Point BottomLeft { get; }
    public Point BottomRight { get; }
    public Rect(Size size);
    public Rect(Point point, Vector vector);
    public Rect(Point point1, Point point2);
    public Rect(double x, double y, double width, double height);
    public Rect(Point location, Size size);
    public bool Equals(Rect value);
    public static bool op_Inequality(Rect rect1, Rect rect2);
    public static bool op_Equality(Rect rect1, Rect rect2);
    public virtual bool Equals(object o);
    public static bool Equals(Rect rect1, Rect rect2);
    public virtual int GetHashCode();
    public bool Contains(Rect rect);
    public bool Contains(double x, double y);
    public bool Contains(Point point);
    public static Rect Inflate(Rect rect, double width, double height);
    public static Rect Inflate(Rect rect, Size size);
    public void Inflate(double width, double height);
    public void Inflate(Size size);
    public bool IntersectsWith(Rect rect);
    public void Intersect(Rect rect);
    public static Rect Intersect(Rect rect1, Rect rect2);
    public void Offset(double offsetX, double offsetY);
    public static Rect Offset(Rect rect, double offsetX, double offsetY);
    public void Offset(Vector offsetVector);
    public static Rect Offset(Rect rect, Vector offsetVector);
    public void Scale(double scaleX, double scaleY);
    public void Transform(Matrix matrix);
    public static Rect Transform(Rect rect, Matrix matrix);
    public static Rect Union(Rect rect1, Rect rect2);
    public static Rect Union(Rect rect, Point point);
    public void Union(Rect rect);
    public void Union(Point point);
    public static Rect Parse(string source);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    private string ToString(string format, IFormatProvider provider);
    public static Rect get_Empty();
    public bool get_IsEmpty();
    public Point get_Location();
    public void set_Location(Point value);
    public Size get_Size();
    public void set_Size(Size value);
    public double get_X();
    public void set_X(double value);
    public double get_Y();
    public void set_Y(double value);
    public double get_Width();
    public void set_Width(double value);
    public double get_Height();
    public void set_Height(double value);
    public double get_Left();
    public double get_Top();
    public double get_Right();
    public double get_Bottom();
    public Point get_TopLeft();
    public Point get_TopRight();
    public Point get_BottomLeft();
    public Point get_BottomRight();
}
public class System.Windows.RectConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
[ValueSerializerAttribute("System.Windows.Converters.SizeValueSerializer")]
[TypeConverterAttribute("System.Windows.SizeConverter")]
public class System.Windows.Size : ValueType {
    private double _width;
    private double _height;
    public bool IsEmpty { get; }
    public double Height { get; public set; }
    public double Width { get; public set; }
    public static Size Empty { get; }
    public Size(double width, double height);
    public bool Equals(Size value);
    public virtual bool Equals(object o);
    public static bool Equals(Size size1, Size size2);
    public virtual int GetHashCode();
    public static Size Parse(string source);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    private string ConvertToString(string format, IFormatProvider provider);
    public bool get_IsEmpty();
    public double get_Height();
    public void set_Height(double value);
    public double get_Width();
    public void set_Width(double value);
    public static Size get_Empty();
    public static Point op_Explicit(Size size);
    public static Vector op_Explicit(Size size);
    public static bool op_Equality(Size size1, Size size2);
    public static bool op_Inequality(Size size1, Size size2);
}
public class System.Windows.SizeConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public class System.Windows.SplashScreen : object {
    [SecurityCriticalAttribute]
public SplashScreen(Assembly resourceAssembly, string resourceName);
    public SplashScreen(string resourceName);
    [SecurityCriticalAttribute]
public void Show(bool autoClose);
    [SecurityCriticalAttribute]
public void Close(TimeSpan fadeoutDuration);
}
public class System.Windows.Threading.Dispatcher : object {
    private static Dictionary`2<Thread, Dispatcher> dispatchers;
    private static object olock;
    private static DispatcherFrame main_execution_frame;
    private static int TOP_PRIO;
    private Thread base_thread;
    private PokableQueue[] priority_queues;
    private Flags flags;
    private int queue_bits;
    private EventWaitHandle wait;
    private DispatcherHooks hooks;
    private DispatcherFrame current_frame;
    [CompilerGeneratedAttribute]
private EventHandler ShutdownStarted;
    [CompilerGeneratedAttribute]
private EventHandler ShutdownFinished;
    [CompilerGeneratedAttribute]
private DispatcherUnhandledExceptionEventHandler UnhandledException;
    [CompilerGeneratedAttribute]
private DispatcherUnhandledExceptionFilterEventHandler UnhandledExceptionFilter;
    public static Dispatcher CurrentDispatcher { get; }
    public Thread Thread { get; }
    [EditorBrowsableAttribute("2")]
public DispatcherHooks Hooks { get; }
    public bool HasShutdownStarted { get; }
    public bool HasShutdownFinished { get; }
    private Dispatcher(Thread t);
    private static Dispatcher();
    [EditorBrowsableAttribute("1")]
public bool CheckAccess();
    [EditorBrowsableAttribute("1")]
public void VerifyAccess();
    public static void ValidatePriority(DispatcherPriority priority, string parameterName);
    public DispatcherOperation BeginInvoke(Delegate method, Object[] args);
    public DispatcherOperation BeginInvoke(Delegate method, DispatcherPriority priority, Object[] args);
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public DispatcherOperation BeginInvoke(DispatcherPriority priority, Delegate method);
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public DispatcherOperation BeginInvoke(DispatcherPriority priority, Delegate method, object arg);
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public DispatcherOperation BeginInvoke(DispatcherPriority priority, Delegate method, object arg, Object[] args);
    public DispatcherOperation InvokeAsync(Action callback);
    public DispatcherOperation InvokeAsync(Action callback, DispatcherPriority priority);
    public DispatcherOperation InvokeAsync(Action callback, DispatcherPriority priority, CancellationToken cancellationToken);
    public object Invoke(Delegate method, Object[] args);
    public object Invoke(Delegate method, TimeSpan timeout, Object[] args);
    public object Invoke(Delegate method, TimeSpan timeout, DispatcherPriority priority, Object[] args);
    public object Invoke(Delegate method, DispatcherPriority priority, Object[] args);
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public object Invoke(DispatcherPriority priority, Delegate method);
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public object Invoke(DispatcherPriority priority, Delegate method, object arg);
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public object Invoke(DispatcherPriority priority, Delegate method, object arg, Object[] args);
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public object Invoke(DispatcherPriority priority, TimeSpan timeout, Delegate method);
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public object Invoke(DispatcherPriority priority, TimeSpan timeout, Delegate method, object arg);
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public object Invoke(DispatcherPriority priority, TimeSpan timeout, Delegate method, object arg, Object[] args);
    private void Queue(DispatcherPriority priority, DispatcherOperation x);
    internal void Reprioritize(DispatcherOperation op, DispatcherPriority oldpriority);
    public static Dispatcher get_CurrentDispatcher();
    public static Dispatcher FromThread(Thread thread);
    public Thread get_Thread();
    [SecurityCriticalAttribute]
public static void Run();
    [SecurityCriticalAttribute]
public static void PushFrame(DispatcherFrame frame);
    private void PerformShutdown();
    private void RunFrame(DispatcherFrame frame);
    [SecurityCriticalAttribute]
public DispatcherHooks get_Hooks();
    public bool get_HasShutdownStarted();
    public bool get_HasShutdownFinished();
    [SecurityCriticalAttribute]
public void InvokeShutdown();
    [SecurityCriticalAttribute]
public void BeginInvokeShutdown(DispatcherPriority priority);
    [SecurityCriticalAttribute]
public static void ExitAllFrames();
    public DispatcherProcessingDisabled DisableProcessing();
    [CompilerGeneratedAttribute]
public void add_ShutdownStarted(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_ShutdownStarted(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_ShutdownFinished(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_ShutdownFinished(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_UnhandledException(DispatcherUnhandledExceptionEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_UnhandledException(DispatcherUnhandledExceptionEventHandler value);
    [CompilerGeneratedAttribute]
public void add_UnhandledExceptionFilter(DispatcherUnhandledExceptionFilterEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_UnhandledExceptionFilter(DispatcherUnhandledExceptionFilterEventHandler value);
}
public class System.Windows.Threading.DispatcherEventArgs : EventArgs {
    private Dispatcher dispatcher;
    public Dispatcher Dispatcher { get; }
    internal DispatcherEventArgs(Dispatcher dispatcher);
    public Dispatcher get_Dispatcher();
}
public class System.Windows.Threading.DispatcherFrame : DispatcherObject {
    private DispatcherFrame parent_frame;
    internal bool exit_on_request;
    private bool cont;
    internal Dispatcher dispatcher;
    public bool Continue { get; public set; }
    internal DispatcherFrame ParentFrame { get; internal set; }
    public DispatcherFrame(bool exitWhenRequested);
    public bool get_Continue();
    [SecurityCriticalAttribute]
public void set_Continue(bool value);
    internal DispatcherFrame get_ParentFrame();
    internal void set_ParentFrame(DispatcherFrame value);
}
public class System.Windows.Threading.DispatcherHookEventArgs : EventArgs {
    private DispatcherOperation operation;
    public Dispatcher Dispatcher { get; }
    public DispatcherOperation Operation { get; }
    public DispatcherHookEventArgs(DispatcherOperation operation);
    public Dispatcher get_Dispatcher();
    public DispatcherOperation get_Operation();
}
public class System.Windows.Threading.DispatcherHookEventHandler : MulticastDelegate {
    public DispatcherHookEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, DispatcherHookEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, DispatcherHookEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.Threading.DispatcherHooks : object {
    private Dispatcher owner;
    [CompilerGeneratedAttribute]
private EventHandler DispatcherInactive;
    [CompilerGeneratedAttribute]
private DispatcherHookEventHandler OperationAborted;
    [CompilerGeneratedAttribute]
private DispatcherHookEventHandler OperationCompleted;
    [CompilerGeneratedAttribute]
private DispatcherHookEventHandler OperationPosted;
    [CompilerGeneratedAttribute]
private DispatcherHookEventHandler OperationPriorityChanged;
    internal DispatcherHooks(Dispatcher owner);
    [CompilerGeneratedAttribute]
public void add_DispatcherInactive(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_DispatcherInactive(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_OperationAborted(DispatcherHookEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_OperationAborted(DispatcherHookEventHandler value);
    [CompilerGeneratedAttribute]
public void add_OperationCompleted(DispatcherHookEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_OperationCompleted(DispatcherHookEventHandler value);
    [CompilerGeneratedAttribute]
public void add_OperationPosted(DispatcherHookEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_OperationPosted(DispatcherHookEventHandler value);
    [CompilerGeneratedAttribute]
public void add_OperationPriorityChanged(DispatcherHookEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_OperationPriorityChanged(DispatcherHookEventHandler value);
    internal void EmitOperationPosted(DispatcherOperation op);
    internal void EmitOperationCompleted(DispatcherOperation op);
    internal void EmitOperationAborted(DispatcherOperation op);
    internal void EmitOperationPriorityChanged(DispatcherOperation op);
    internal void EmitInactive();
}
public abstract class System.Windows.Threading.DispatcherObject : object {
    private Thread base_thread;
    [EditorBrowsableAttribute("1")]
public Dispatcher Dispatcher { get; }
    [EditorBrowsableAttribute("1")]
public bool CheckAccess();
    [EditorBrowsableAttribute("1")]
public void VerifyAccess();
    public Dispatcher get_Dispatcher();
}
public class System.Windows.Threading.DispatcherOperation : object {
    private DispatcherOperationStatus status;
    private DispatcherPriority priority;
    private Dispatcher dispatcher;
    private object result;
    private Delegate delegate_method;
    private Object[] delegate_args;
    [CompilerGeneratedAttribute]
private EventHandler Aborted;
    [CompilerGeneratedAttribute]
private EventHandler Completed;
    public Task Task { get; }
    public DispatcherOperationStatus Status { get; internal set; }
    public Dispatcher Dispatcher { get; }
    public DispatcherPriority Priority { get; public set; }
    public object Result { get; }
    internal DispatcherOperation(Dispatcher dis, DispatcherPriority prio);
    internal DispatcherOperation(Dispatcher dis, DispatcherPriority prio, Delegate d);
    internal DispatcherOperation(Dispatcher dis, DispatcherPriority prio, Delegate d, object arg);
    internal DispatcherOperation(Dispatcher dis, DispatcherPriority prio, Delegate d, object arg, Object[] args);
    internal void Invoke();
    public bool Abort();
    public Task get_Task();
    public DispatcherOperationStatus get_Status();
    internal void set_Status(DispatcherOperationStatus value);
    public Dispatcher get_Dispatcher();
    public DispatcherPriority get_Priority();
    public void set_Priority(DispatcherPriority value);
    public object get_Result();
    public DispatcherOperationStatus Wait();
    [SecurityCriticalAttribute]
public DispatcherOperationStatus Wait(TimeSpan timeout);
    [CompilerGeneratedAttribute]
public void add_Aborted(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_Aborted(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_Completed(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_Completed(EventHandler value);
}
public class System.Windows.Threading.DispatcherOperationCallback : MulticastDelegate {
    public DispatcherOperationCallback(object object, IntPtr method);
    public virtual object Invoke(object arg);
    public virtual IAsyncResult BeginInvoke(object arg, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
public enum System.Windows.Threading.DispatcherOperationStatus : Enum {
    public int value__;
    public static DispatcherOperationStatus Pending;
    public static DispatcherOperationStatus Aborted;
    public static DispatcherOperationStatus Completed;
    public static DispatcherOperationStatus Executing;
}
public enum System.Windows.Threading.DispatcherPriority : Enum {
    public int value__;
    public static DispatcherPriority Invalid;
    public static DispatcherPriority Inactive;
    public static DispatcherPriority SystemIdle;
    public static DispatcherPriority ApplicationIdle;
    public static DispatcherPriority ContextIdle;
    public static DispatcherPriority Background;
    public static DispatcherPriority Input;
    public static DispatcherPriority Loaded;
    public static DispatcherPriority Render;
    public static DispatcherPriority DataBind;
    public static DispatcherPriority Normal;
    public static DispatcherPriority Send;
}
public class System.Windows.Threading.DispatcherProcessingDisabled : ValueType {
    internal DispatcherProcessingDisabled(int foo);
    public sealed virtual void Dispose();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Inequality(DispatcherProcessingDisabled left, DispatcherProcessingDisabled right);
    public static bool op_Equality(DispatcherProcessingDisabled left, DispatcherProcessingDisabled right);
}
public class System.Windows.Threading.DispatcherSynchronizationContext : SynchronizationContext {
    public DispatcherSynchronizationContext(Dispatcher dispatcher);
    public virtual SynchronizationContext CreateCopy();
    public virtual void Post(SendOrPostCallback d, object state);
    public virtual void Send(SendOrPostCallback d, object state);
    [SecurityCriticalAttribute]
public virtual int Wait(IntPtr[] waitHandles, bool waitAll, int millisecondsTimeout);
}
public class System.Windows.Threading.DispatcherTimer : object {
    private DispatcherPriority priority;
    private Dispatcher target_dispatcher;
    private long interval;
    private EventHandler callback;
    private Timer timer;
    private object tag;
    [CompilerGeneratedAttribute]
private EventHandler Tick;
    public Dispatcher Dispatcher { get; }
    public TimeSpan Interval { get; public set; }
    public bool IsEnabled { get; public set; }
    public object Tag { get; public set; }
    public DispatcherTimer(DispatcherPriority priority);
    public DispatcherTimer(DispatcherPriority priority, Dispatcher dispatcher);
    public DispatcherTimer(TimeSpan interval, DispatcherPriority priority, EventHandler callback, Dispatcher dispatcher);
    public void Start();
    private void timer_tick(object state);
    public void Stop();
    public Dispatcher get_Dispatcher();
    public TimeSpan get_Interval();
    public void set_Interval(TimeSpan value);
    public bool get_IsEnabled();
    public void set_IsEnabled(bool value);
    public object get_Tag();
    public void set_Tag(object value);
    [CompilerGeneratedAttribute]
public void add_Tick(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_Tick(EventHandler value);
    [CompilerGeneratedAttribute]
private void <timer_tick>b__11_0();
}
public class System.Windows.Threading.DispatcherUnhandledExceptionEventArgs : DispatcherEventArgs {
    private Exception exception;
    private bool handled;
    public Exception Exception { get; }
    public bool Handled { get; public set; }
    internal DispatcherUnhandledExceptionEventArgs(Dispatcher dispatcher, Exception exception);
    public Exception get_Exception();
    public bool get_Handled();
    public void set_Handled(bool value);
}
public class System.Windows.Threading.DispatcherUnhandledExceptionEventHandler : MulticastDelegate {
    public DispatcherUnhandledExceptionEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, DispatcherUnhandledExceptionEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, DispatcherUnhandledExceptionEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.Threading.DispatcherUnhandledExceptionFilterEventArgs : DispatcherEventArgs {
    private Exception exception;
    private bool requestCatch;
    public Exception Exception { get; }
    public bool RequestCatch { get; public set; }
    internal DispatcherUnhandledExceptionFilterEventArgs(Dispatcher dispatcher, Exception exception);
    public Exception get_Exception();
    public bool get_RequestCatch();
    public void set_RequestCatch(bool value);
}
public class System.Windows.Threading.DispatcherUnhandledExceptionFilterEventHandler : MulticastDelegate {
    public DispatcherUnhandledExceptionFilterEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, DispatcherUnhandledExceptionFilterEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, DispatcherUnhandledExceptionFilterEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[FlagsAttribute]
internal enum System.Windows.Threading.Flags : Enum {
    public int value__;
    public static Flags ShutdownStarted;
    public static Flags Shutdown;
    public static Flags Disabled;
}
internal class System.Windows.Threading.PokableQueue : object {
    private static int initial_capacity;
    private int size;
    private int head;
    private int tail;
    private Object[] array;
    public int Count { get; }
    internal PokableQueue(int capacity);
    public void Enqueue(object obj);
    public object Dequeue();
    private void Grow();
    public int get_Count();
    public void Remove(object obj);
}
public class System.Windows.ValidateValueCallback : MulticastDelegate {
    public ValidateValueCallback(object object, IntPtr method);
    public virtual bool Invoke(object value);
    public virtual IAsyncResult BeginInvoke(object value, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
[ValueSerializerAttribute("System.Windows.Converters.VectorValueSerializer")]
[TypeConverterAttribute("System.Windows.VectorConverter")]
public class System.Windows.Vector : ValueType {
    private double _x;
    private double _y;
    public double Length { get; }
    public double LengthSquared { get; }
    public double X { get; public set; }
    public double Y { get; public set; }
    public Vector(double x, double y);
    public bool Equals(Vector value);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public static bool Equals(Vector vector1, Vector vector2);
    public static Point Add(Vector vector, Point point);
    public static Vector Add(Vector vector1, Vector vector2);
    public static double AngleBetween(Vector vector1, Vector vector2);
    public static double CrossProduct(Vector vector1, Vector vector2);
    public static double Determinant(Vector vector1, Vector vector2);
    public static Vector Divide(Vector vector, double scalar);
    public static double Multiply(Vector vector1, Vector vector2);
    public static Vector Multiply(Vector vector, Matrix matrix);
    public static Vector Multiply(double scalar, Vector vector);
    public static Vector Multiply(Vector vector, double scalar);
    public void Negate();
    public void Normalize();
    public static Vector Subtract(Vector vector1, Vector vector2);
    public static Vector Parse(string source);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    private string ToString(string format, IFormatProvider formatProvider);
    public double get_Length();
    public double get_LengthSquared();
    public double get_X();
    public void set_X(double value);
    public double get_Y();
    public void set_Y(double value);
    public static Point op_Explicit(Vector vector);
    public static Size op_Explicit(Vector vector);
    public static Vector op_Subtraction(Vector vector1, Vector vector2);
    public static Vector op_UnaryNegation(Vector vector);
    public static bool op_Inequality(Vector vector1, Vector vector2);
    public static bool op_Equality(Vector vector1, Vector vector2);
    public static double op_Multiply(Vector vector1, Vector vector2);
    public static Vector op_Multiply(Vector vector, Matrix matrix);
    public static Vector op_Multiply(double scalar, Vector vector);
    public static Vector op_Multiply(Vector vector, double scalar);
    public static Vector op_Division(Vector vector, double scalar);
    public static Point op_Addition(Vector vector, Point point);
    public static Vector op_Addition(Vector vector1, Vector vector2);
}
public class System.Windows.VectorConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
[DefaultMemberAttribute("Item")]
public abstract class System.Windows.WeakEventManager : DispatcherObject {
    private Hashtable sourceData;
    protected IDisposable ReadLock { get; }
    protected IDisposable WriteLock { get; }
    protected object Item { get; protected set; }
    protected IDisposable get_ReadLock();
    protected IDisposable get_WriteLock();
    protected object get_Item(object source);
    protected void set_Item(object source, object value);
    protected void DeliverEvent(object sender, EventArgs args);
    protected void DeliverEventToList(object sender, EventArgs args, ListenerList list);
    protected void ProtectedAddListener(object source, IWeakEventListener listener);
    protected void ProtectedRemoveListener(object source, IWeakEventListener listener);
    protected virtual bool Purge(object source, object data, bool purgeAll);
    protected void Remove(object source);
    protected void ScheduleCleanup();
    protected abstract virtual void StartListening(object source);
    protected abstract virtual void StopListening(object source);
    protected static WeakEventManager GetCurrentManager(Type managerType);
    protected static void SetCurrentManager(Type managerType, WeakEventManager manager);
}
internal enum zipsharp.Append : Enum {
    public int value__;
    public static Append Create;
    public static Append CreateAfter;
    public static Append AddInZip;
}
[UnmanagedFunctionPointerAttribute("2")]
internal class zipsharp.CloseFileFunc : MulticastDelegate {
    public CloseFileFunc(object object, IntPtr method);
    public virtual int Invoke(IntPtr opaque, IntPtr stream);
    public virtual IAsyncResult BeginInvoke(IntPtr opaque, IntPtr stream, AsyncCallback callback, object object);
    public virtual int EndInvoke(IAsyncResult result);
}
internal static class zipsharp.NativeUnzip : object {
    public static void CloseArchive(UnzipHandle handle);
    public static void CloseCurrentFile(UnzipHandle handle);
    private static CompressionOption ConvertCompression(int compressionLevel);
    public static long CurrentFilePosition(UnzipHandle handle);
    public static long CurrentFileLength32(UnzipHandle handle);
    public static long CurrentFileLength64(UnzipHandle handle);
    private static string GetCurrentFileName32(UnzipHandle handle);
    private static string GetCurrentFileName64(UnzipHandle handle);
    public static String[] GetFiles32(UnzipHandle handle);
    public static String[] GetFiles64(UnzipHandle handle);
    private static String[] GetFiles(UnzipHandle handle, Func`2<UnzipHandle, string> getCurrentFileName);
    private static void GoToFirstFile(UnzipHandle handle);
    private static bool GoToNextFile(UnzipHandle handle);
    public static UnzipHandle OpenArchive32(ZlibFileFuncDef32 fileFuncs);
    public static UnzipHandle OpenArchive64(ZlibFileFuncDef64 fileFuncs);
    public static void OpenFile(UnzipHandle handle, string name, CompressionOption& level);
    public static int Read(UnzipHandle handle, Byte[] buffer, int offset, int count);
    private static int unzCloseCurrentFile(UnzipHandle handle);
    private static IntPtr unztell(UnzipHandle handle);
    private static int unzGoToFirstFile(UnzipHandle handle);
    private static UnzipHandle unzOpen2_32(string path, ZlibFileFuncDef32& pzlib_filefunc_def);
    private static UnzipHandle unzOpen2_64(string path, ZlibFileFuncDef64& pzlib_filefunc_def);
    private static int unzGoToNextFile(UnzipHandle handle);
    private static int unzLocateFile(UnzipHandle handle, string szFileName, int iCaseSensitivity);
    private static int unzOpenCurrentFile2(UnzipHandle handle, Int32& method, Int32& level, int raw);
    private static int unzGetCurrentFileInfo_32(UnzipHandle handle, UnzipFileInfo32& pfile_info, StringBuilder szFileName, UInt32 fileNameBufferSize, IntPtr extraField, UInt32 extraFieldBufferSize, StringBuilder szComment, UInt32 commentBufferSize);
    private static int unzGetCurrentFileInfo_64(UnzipHandle handle, UnzipFileInfo64& pfile_info, StringBuilder szFileName, ulong fileNameBufferSize, IntPtr extraField, ulong extraFieldBufferSize, StringBuilder szComment, ulong commentBufferSize);
    private static int unzReadCurrentFile(UnzipHandle handle, Byte* buf, UInt32 len);
    private static int unzClose(UnzipHandle handle);
}
internal static class zipsharp.NativeVersion : object {
    public static bool Use32Bit;
    private static NativeVersion();
}
internal static class zipsharp.NativeZip : object {
    private static int DEFAULT_COMPRESSION;
    private static int Z_DEFLATED;
    public static void CloseArchive(ZipHandle handle);
    public static void CloseArchive(ZipHandle handle, string comment);
    public static void CloseFile(ZipHandle handle);
    public static ZipHandle OpenArchive32(ZlibFileFuncDef32 funcDef, Append append);
    public static ZipHandle OpenArchive64(ZlibFileFuncDef64 funcDef, Append append);
    public static int OpenFile32(ZipHandle handle, string filename);
    public static int OpenFile32(ZipHandle handle, string filename, int compressionLevel);
    public static int OpenFile64(ZipHandle handle, string filename);
    public static int OpenFile64(ZipHandle handle, string filename, int compressionLevel);
    public static void Write(ZipHandle handle, Byte[] buffer, int offset, UInt32 count);
    private static int zipWriteInFileInZip(ZipHandle handle, Byte* buffer, UInt32 len);
    private static int zipCloseFileInZip(ZipHandle handle);
    private static ZipHandle zipOpen2_32(string pathname, int append, IntPtr globalcomment, ZlibFileFuncDef32& pzlib_filefunc_def);
    private static ZipHandle zipOpen2_64(string pathname, int append, IntPtr globalcomment, ZlibFileFuncDef64& pzlib_filefunc_def);
    private static int zipClose(ZipHandle handle, string globalComment);
    private static int zipOpenNewFileInZip_32(ZipHandle handle, string filename, ZipFileInfo32& zipfi, IntPtr extrafield_local, UInt32 size_extrafield_local, IntPtr extrafield_global, UInt32 size_extrafield_global, string comment, int method, int level);
    private static int zipOpenNewFileInZip_64(ZipHandle handle, string filename, ZipFileInfo64& zipfi, IntPtr extrafield_local, UInt32 size_extrafield_local, IntPtr extrafield_global, UInt32 size_extrafield_global, string comment, int method, int level);
}
[UnmanagedFunctionPointerAttribute("2")]
internal class zipsharp.OpenFileFunc : MulticastDelegate {
    public OpenFileFunc(object object, IntPtr method);
    public virtual IntPtr Invoke(IntPtr opaque, string filename, int mode);
    public virtual IAsyncResult BeginInvoke(IntPtr opaque, string filename, int mode, AsyncCallback callback, object object);
    public virtual IntPtr EndInvoke(IAsyncResult result);
}
[UnmanagedFunctionPointerAttribute("2")]
internal class zipsharp.ReadFileFunc32 : MulticastDelegate {
    public ReadFileFunc32(object object, IntPtr method);
    public virtual UInt32 Invoke(IntPtr opaque, IntPtr stream, IntPtr buffer, UInt32 size);
    public virtual IAsyncResult BeginInvoke(IntPtr opaque, IntPtr stream, IntPtr buffer, UInt32 size, AsyncCallback callback, object object);
    public virtual UInt32 EndInvoke(IAsyncResult result);
}
[UnmanagedFunctionPointerAttribute("2")]
internal class zipsharp.ReadFileFunc64 : MulticastDelegate {
    public ReadFileFunc64(object object, IntPtr method);
    public virtual ulong Invoke(IntPtr opaque, IntPtr stream, IntPtr buffer, ulong size);
    public virtual IAsyncResult BeginInvoke(IntPtr opaque, IntPtr stream, IntPtr buffer, ulong size, AsyncCallback callback, object object);
    public virtual ulong EndInvoke(IAsyncResult result);
}
[UnmanagedFunctionPointerAttribute("2")]
internal class zipsharp.SeekFileFunc32 : MulticastDelegate {
    public SeekFileFunc32(object object, IntPtr method);
    public virtual int Invoke(IntPtr opaque, IntPtr stream, UInt32 offset, int origin);
    public virtual IAsyncResult BeginInvoke(IntPtr opaque, IntPtr stream, UInt32 offset, int origin, AsyncCallback callback, object object);
    public virtual int EndInvoke(IAsyncResult result);
}
[UnmanagedFunctionPointerAttribute("2")]
internal class zipsharp.SeekFileFunc64 : MulticastDelegate {
    public SeekFileFunc64(object object, IntPtr method);
    public virtual long Invoke(IntPtr opaque, IntPtr stream, ulong offset, int origin);
    public virtual IAsyncResult BeginInvoke(IntPtr opaque, IntPtr stream, ulong offset, int origin, AsyncCallback callback, object object);
    public virtual long EndInvoke(IAsyncResult result);
}
[UnmanagedFunctionPointerAttribute("2")]
internal class zipsharp.TellFileFunc32 : MulticastDelegate {
    public TellFileFunc32(object object, IntPtr method);
    public virtual int Invoke(IntPtr opaque, IntPtr stream);
    public virtual IAsyncResult BeginInvoke(IntPtr opaque, IntPtr stream, AsyncCallback callback, object object);
    public virtual int EndInvoke(IAsyncResult result);
}
[UnmanagedFunctionPointerAttribute("2")]
internal class zipsharp.TellFileFunc64 : MulticastDelegate {
    public TellFileFunc64(object object, IntPtr method);
    public virtual long Invoke(IntPtr opaque, IntPtr stream);
    public virtual IAsyncResult BeginInvoke(IntPtr opaque, IntPtr stream, AsyncCallback callback, object object);
    public virtual long EndInvoke(IAsyncResult result);
}
[UnmanagedFunctionPointerAttribute("2")]
internal class zipsharp.TestErrorFileFunc : MulticastDelegate {
    public TestErrorFileFunc(object object, IntPtr method);
    public virtual int Invoke(IntPtr opaque, IntPtr stream);
    public virtual IAsyncResult BeginInvoke(IntPtr opaque, IntPtr stream, AsyncCallback callback, object object);
    public virtual int EndInvoke(IAsyncResult result);
}
internal class zipsharp.UnzipArchive : object {
    private String[] files;
    [CompilerGeneratedAttribute]
private bool <FileActive>k__BackingField;
    [CompilerGeneratedAttribute]
private UnzipHandle <Handle>k__BackingField;
    [CompilerGeneratedAttribute]
private ZipStream <Stream>k__BackingField;
    internal bool FileActive { get; internal set; }
    private String[] Files { get; }
    internal UnzipHandle Handle { get; private set; }
    private ZipStream Stream { get; private set; }
    public UnzipArchive(string filename);
    public UnzipArchive(Stream stream);
    public UnzipArchive(Stream stream, bool ownsStream);
    [CompilerGeneratedAttribute]
internal bool get_FileActive();
    [CompilerGeneratedAttribute]
internal void set_FileActive(bool value);
    private String[] get_Files();
    [CompilerGeneratedAttribute]
internal UnzipHandle get_Handle();
    [CompilerGeneratedAttribute]
private void set_Handle(UnzipHandle value);
    [CompilerGeneratedAttribute]
private ZipStream get_Stream();
    [CompilerGeneratedAttribute]
private void set_Stream(ZipStream value);
    public sealed virtual void Dispose();
    public CompressionOption GetCompressionLevel(string file);
    public String[] GetFiles();
    public Stream GetStream(string name);
}
internal class zipsharp.UnzipFileInfo32 : ValueType {
    public UInt32 version;
    public UInt32 version_needed;
    public UInt32 flag;
    public UInt32 compression_method;
    public UInt32 dosDate;
    public UInt32 crc;
    public UInt32 compressed_size;
    public UInt32 uncompressed_size;
    public UInt32 size_filename;
    public UInt32 size_file_extra;
    public UInt32 size_file_comment;
    public UInt32 disk_num_start;
    public UInt32 internal_fa;
    public UInt32 external_fa;
    private ZipTime tmu_date;
}
internal class zipsharp.UnzipFileInfo64 : ValueType {
    public ulong version;
    public ulong version_needed;
    public ulong flag;
    public ulong compression_method;
    public ulong dosDate;
    public ulong crc;
    public ulong compressed_size;
    public ulong uncompressed_size;
    public ulong size_filename;
    public ulong size_file_extra;
    public ulong size_file_comment;
    public ulong disk_num_start;
    public ulong internal_fa;
    public ulong external_fa;
    private ZipTime tmu_date;
}
internal class zipsharp.UnzipHandle : SafeHandle {
    public bool IsInvalid { get; }
    public virtual bool get_IsInvalid();
    protected virtual bool ReleaseHandle();
}
internal class zipsharp.UnzipReadStream : Stream {
    private long length;
    [CompilerGeneratedAttribute]
private UnzipArchive <Archive>k__BackingField;
    [CompilerGeneratedAttribute]
private CompressionOption <CompressionLevel>k__BackingField;
    private UnzipArchive Archive { get; private set; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public bool CanTimeout { get; }
    public CompressionOption CompressionLevel { get; public set; }
    public long Length { get; }
    public long Position { get; public set; }
    public UnzipReadStream(UnzipArchive archive, CompressionOption compressionLevel);
    [CompilerGeneratedAttribute]
private UnzipArchive get_Archive();
    [CompilerGeneratedAttribute]
private void set_Archive(UnzipArchive value);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual bool get_CanTimeout();
    [CompilerGeneratedAttribute]
public CompressionOption get_CompressionLevel();
    [CompilerGeneratedAttribute]
public void set_CompressionLevel(CompressionOption value);
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Close();
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
}
[UnmanagedFunctionPointerAttribute("2")]
internal class zipsharp.WriteFileFunc32 : MulticastDelegate {
    public WriteFileFunc32(object object, IntPtr method);
    public virtual UInt32 Invoke(IntPtr opaque, IntPtr stream, IntPtr buffer, UInt32 size);
    public virtual IAsyncResult BeginInvoke(IntPtr opaque, IntPtr stream, IntPtr buffer, UInt32 size, AsyncCallback callback, object object);
    public virtual UInt32 EndInvoke(IAsyncResult result);
}
[UnmanagedFunctionPointerAttribute("2")]
internal class zipsharp.WriteFileFunc64 : MulticastDelegate {
    public WriteFileFunc64(object object, IntPtr method);
    public virtual ulong Invoke(IntPtr opaque, IntPtr stream, IntPtr buffer, ulong size);
    public virtual IAsyncResult BeginInvoke(IntPtr opaque, IntPtr stream, IntPtr buffer, ulong size, AsyncCallback callback, object object);
    public virtual ulong EndInvoke(IAsyncResult result);
}
internal class zipsharp.ZipArchive : object {
    [CompilerGeneratedAttribute]
private bool <FileActive>k__BackingField;
    [CompilerGeneratedAttribute]
private ZipHandle <Handle>k__BackingField;
    [CompilerGeneratedAttribute]
private ZipStream <Stream>k__BackingField;
    internal bool FileActive { get; internal set; }
    internal ZipHandle Handle { get; private set; }
    private ZipStream Stream { get; private set; }
    public ZipArchive(string filename, Append append);
    public ZipArchive(Stream stream, Append append);
    public ZipArchive(Stream stream, Append append, bool ownsStream);
    [CompilerGeneratedAttribute]
internal bool get_FileActive();
    [CompilerGeneratedAttribute]
internal void set_FileActive(bool value);
    [CompilerGeneratedAttribute]
internal ZipHandle get_Handle();
    [CompilerGeneratedAttribute]
private void set_Handle(ZipHandle value);
    [CompilerGeneratedAttribute]
private ZipStream get_Stream();
    [CompilerGeneratedAttribute]
private void set_Stream(ZipStream value);
    private static int ConvertCompression(CompressionOption option);
    public Stream GetStream(string filename, CompressionOption option);
    public sealed virtual void Dispose();
}
internal class zipsharp.ZipFileInfo32 : ValueType {
    private ZipTime date;
    private UInt32 dosDate;
    private UInt32 internalFileAttributes;
    private UInt32 externalFileAttributes;
    public ZipFileInfo32(DateTime fileTime);
}
internal class zipsharp.ZipFileInfo64 : ValueType {
    private ZipTime date;
    private ulong dosDate;
    private ulong internalFileAttributes;
    private ulong externalFileAttributes;
    public ZipFileInfo64(DateTime fileTime);
}
internal class zipsharp.ZipHandle : SafeHandle {
    public bool IsInvalid { get; }
    public virtual bool get_IsInvalid();
    protected virtual bool ReleaseHandle();
}
internal class zipsharp.ZipStream : Stream {
    private static int ZLIB_FILEFUNC_SEEK_CUR;
    private static int ZLIB_FILEFUNC_SEEK_END;
    private static int ZLIB_FILEFUNC_SEEK_SET;
    private bool canRead;
    private bool canSeek;
    private bool canWrite;
    [CompilerGeneratedAttribute]
private Stream <DataStream>k__BackingField;
    [CompilerGeneratedAttribute]
private ZlibFileFuncDef32 <IOFunctions32>k__BackingField;
    [CompilerGeneratedAttribute]
private ZlibFileFuncDef64 <IOFunctions64>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <OwnsStream>k__BackingField;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public bool CanTimeout { get; }
    private Stream DataStream { get; private set; }
    public ZlibFileFuncDef32 IOFunctions32 { get; public set; }
    public ZlibFileFuncDef64 IOFunctions64 { get; public set; }
    public long Length { get; }
    private bool OwnsStream { get; private set; }
    public long Position { get; public set; }
    public ZipStream(Stream dataStream, bool ownsStream);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual bool get_CanTimeout();
    [CompilerGeneratedAttribute]
private Stream get_DataStream();
    [CompilerGeneratedAttribute]
private void set_DataStream(Stream value);
    [CompilerGeneratedAttribute]
public ZlibFileFuncDef32 get_IOFunctions32();
    [CompilerGeneratedAttribute]
public void set_IOFunctions32(ZlibFileFuncDef32 value);
    [CompilerGeneratedAttribute]
public ZlibFileFuncDef64 get_IOFunctions64();
    [CompilerGeneratedAttribute]
public void set_IOFunctions64(ZlibFileFuncDef64 value);
    public virtual long get_Length();
    [CompilerGeneratedAttribute]
private bool get_OwnsStream();
    [CompilerGeneratedAttribute]
private void set_OwnsStream(bool value);
    public virtual long get_Position();
    public virtual void set_Position(long value);
    protected virtual void Dispose(bool disposing);
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    private int CloseFile_Native(IntPtr opaque, IntPtr stream);
    private IntPtr OpenFile_Native(IntPtr opaque, string filename, int mode);
    private UInt32 ReadFile_Native32(IntPtr opaque, IntPtr stream, IntPtr buffer, UInt32 size);
    private ulong ReadFile_Native64(IntPtr opaque, IntPtr stream, IntPtr buffer, ulong size);
    private int SeekFile_Native32(IntPtr opaque, IntPtr stream, UInt32 offset, int origin);
    private long SeekFile_Native64(IntPtr opaque, IntPtr stream, ulong offset, int origin);
    private int TellFile_Native32(IntPtr opaque, IntPtr stream);
    private long TellFile_Native64(IntPtr opaque, IntPtr stream);
    private int TestError_Native(IntPtr opaque, IntPtr stream);
    private UInt32 WriteFile_Native32(IntPtr opaque, IntPtr stream, IntPtr buffer, UInt32 size);
    private ulong WriteFile_Native64(IntPtr opaque, IntPtr stream, IntPtr buffer, ulong size);
}
internal class zipsharp.ZipTime : ValueType {
    private UInt32 second;
    private UInt32 minute;
    private UInt32 hour;
    private UInt32 day;
    private UInt32 month;
    private UInt32 year;
    public DateTime Date { get; }
    public ZipTime(DateTime time);
    public DateTime get_Date();
}
internal class zipsharp.ZipWriteStream : Stream {
    [CompilerGeneratedAttribute]
private ZipArchive <Archive>k__BackingField;
    private ZipArchive Archive { get; private set; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public bool CanTimeout { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public ZipWriteStream(ZipArchive archive);
    [CompilerGeneratedAttribute]
private ZipArchive get_Archive();
    [CompilerGeneratedAttribute]
private void set_Archive(ZipArchive value);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual bool get_CanTimeout();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Close();
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
}
internal class zipsharp.ZlibFileFuncDef32 : ValueType {
    public OpenFileFunc zopen_file;
    public ReadFileFunc32 zread_file;
    public WriteFileFunc32 zwrite_file;
    public TellFileFunc32 ztell_file;
    public SeekFileFunc32 zseek_file;
    public CloseFileFunc zclose_file;
    public TestErrorFileFunc zerror_file;
    public IntPtr opaque;
}
internal class zipsharp.ZlibFileFuncDef64 : ValueType {
    public OpenFileFunc zopen_file;
    public ReadFileFunc64 zread_file;
    public WriteFileFunc64 zwrite_file;
    public TellFileFunc64 ztell_file;
    public SeekFileFunc64 zseek_file;
    public CloseFileFunc zclose_file;
    public TestErrorFileFunc zerror_file;
    public IntPtr opaque;
}
