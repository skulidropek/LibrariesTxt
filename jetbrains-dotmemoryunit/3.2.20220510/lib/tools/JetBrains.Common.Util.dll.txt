internal static class JetBrains.Common.BuildScript.CommonNativeNames : object {
    private static string Prefix;
    public static string NativeUtils;
    public static string MemoryMappedStorageApi;
    public static string EtwMemoryTrace;
    public static string EtwDebugOutput;
    public static string BoostTests;
    public static string OsUtils;
    public static string ElevationAgent;
    private static CommonNativeNames();
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.AbsractTreeExtension : object {
    [ExtensionAttribute]
public static IEnumerable`1<T> TraverseTree(T root, Func`2<T, IEnumerable`1<T>> getChildren, Property`1<bool> isCanceled);
    [ExtensionAttribute]
public static void Dfs(T treeNode, Func`2<T, IEnumerable`1<T>> getChildren, Action`1<T> handleNode);
    [ExtensionAttribute]
public static void Dfs(T treeNode, Func`2<T, IEnumerable`1<T>> getChildren, Action`2<T, int> handleNodeWithLevel);
    [ExtensionAttribute]
public static IEnumerable`1<TreeItem`1<TItem>> GenerateTree(IEnumerable`1<TItem> collection, Func`2<TItem, TId> idSelector, Func`2<TItem, TId> parentIDSelector, TId rootID);
}
public class JetBrains.Common.Util.ActionTask : AsyncTaskBase {
    private Action`1<IExecutionController> myAction;
    public ActionTask(Action`1<IExecutionController> action, string title);
    protected virtual void DoExecute(IExecutionController executionController);
}
public static class JetBrains.Common.Util.AdjacencyListEx : object {
    public static int GetReferencesCount(int nodeNumber, IReadOnlyList`1<int> referencesIndexOf, int referencesCount);
}
public class JetBrains.Common.Util.AdjacencyListEx`1 : object {
    private IReadOnlyList`1<int> myArcStarts;
    private IReadOnlyList`1<T> myArcEnds;
    public int Count { get; }
    public AdjacencyListEx`1(IReadOnlyList`1<int> arcStart, IReadOnlyList`1<T> arcEnds);
    public int get_Count();
    public int GetReferencesCount(int vertexNumber);
    public ReadonlyListSegment`1<T> GetReferencesOf(int vertexNumber);
}
public static class JetBrains.Common.Util.Are : object {
    public static bool AllNull(Object[] args);
    public static bool AnyNull(Object[] args);
    public static bool AllNotNull(Object[] args);
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Common.Util.ArrayPart`1 : ValueType {
    private IArray`1<T> myArray;
    private int myStartIndex;
    private int myLength;
    private int myLastExclusiveIndex;
    public int Count { get; }
    public T Item { get; public set; }
    public ArrayPart`1(IArray`1<T> array, int startIndex, int length);
    public sealed virtual int get_Count();
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.AsyncOperationExtensions : object {
    [CompilerGeneratedAttribute]
private static Func`2<IAsyncOperation, bool> CS$<>9__CachedAnonymousMethodDelegate16;
    [CompilerGeneratedAttribute]
private static Action`2<IAsyncOperation, EventHandler`2<ITask, EventArgs>> CS$<>9__CachedAnonymousMethodDelegate17;
    [CompilerGeneratedAttribute]
private static Action`2<IAsyncOperation, EventHandler`2<ITask, EventArgs>> CS$<>9__CachedAnonymousMethodDelegate18;
    [CompilerGeneratedAttribute]
private static Func`2<ProgressProvider, IDataProvider`1<string>> CS$<>9__CachedAnonymousMethodDelegate1c;
    [CompilerGeneratedAttribute]
private static Func`2<ProgressProvider, IDataProvider`1<int>> CS$<>9__CachedAnonymousMethodDelegate1d;
    [CompilerGeneratedAttribute]
private static Func`2<ProgressProvider, IDataProvider`1<AsyncComputationState>> CS$<>9__CachedAnonymousMethodDelegate1e;
    [ExtensionAttribute]
public static IAsyncOperation`1<T> BindToProgressIndicator(IAsyncOperation`1<T> operation, ProgressIndicator progress, Lifetime lifetime);
    [ExtensionAttribute]
public static Lifetime BindToProgressIndicator(IAsyncOperation operation, IProgressIndicator progress, Lifetime lifetime);
    [ExtensionAttribute]
public static void BindToExecutionController(IAsyncOperation operation, IExecutionController progress);
    [ExtensionAttribute]
public static IDataProvider`1<bool> ToIsCalculatingProvider(IAsyncOperation operation);
    [ExtensionAttribute]
public static ProgressProvider Flatten(IDataProvider`1<ProgressProvider> provider);
    [CompilerGeneratedAttribute]
private static bool <ToIsCalculatingProvider>b__13(IAsyncOperation o);
    [CompilerGeneratedAttribute]
private static void <ToIsCalculatingProvider>b__14(IAsyncOperation o, EventHandler`2<ITask, EventArgs> handler);
    [CompilerGeneratedAttribute]
private static void <ToIsCalculatingProvider>b__15(IAsyncOperation o, EventHandler`2<ITask, EventArgs> handler);
    [CompilerGeneratedAttribute]
private static IDataProvider`1<string> <Flatten>b__19(ProgressProvider p);
    [CompilerGeneratedAttribute]
private static IDataProvider`1<int> <Flatten>b__1a(ProgressProvider p);
    [CompilerGeneratedAttribute]
private static IDataProvider`1<AsyncComputationState> <Flatten>b__1b(ProgressProvider p);
}
public class JetBrains.Common.Util.AsyncTask`1 : AsyncTaskBase {
    private Func`2<IExecutionController, TResult> myFunction;
    private TResult myResult;
    public AsyncTask`1(Func`2<IExecutionController, TResult> function, string title);
    public sealed virtual TResult GetResult();
    protected virtual void DoExecute(IExecutionController executionController);
}
public class JetBrains.Common.Util.AsyncTaskBase : object {
    private object myOperationProgressAccess;
    private double myOperationProgress;
    private int myStepsCount;
    private double myFactor;
    private AsyncTaskBase myParent;
    private int myParentStepsCount;
    private double myParentFactor;
    private ObservableCollection`1<IAsyncOperation> mySubOperations;
    private object myTaskFinishedAccess;
    private object myCancelAccess;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) myIsFinished;
    private bool myIsStarted;
    private EventHandler`2<ITask, EventArgs> myTaskFinished;
    private ITaskExecutionEnvironment myExecutionEnvironment;
    private ManualResetEvent myFinishedEvent;
    private string myTitle;
    private IExecutionController myExecutionController;
    private double myLastSubmitted;
    private bool myIsDisposed;
    private EventHandler`2<IAsyncOperation, ProgressChangedEventArgs> OperationProgressChanged;
    private PropertyChangedEventHandler PropertyChanged;
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsCanceled>k__BackingField;
    public bool Completed { get; }
    public Exception Exception { get; private set; }
    public EventWaitHandle FinishedEvent { get; }
    public string Title { get; private set; }
    public bool CanCancel { get; }
    public bool IsCanceled { get; private set; }
    public int OperationProgress { get; }
    public IEnumerable`1<IAsyncOperation> SubOperations { get; }
    protected AsyncTaskBase(string title);
    private AsyncTaskBase(AsyncTaskBase parent, int parentStepsCount);
    private void StartProgress(int stepsCount, string operationName);
    private IExecutionController CreateSubOperation(int parentStepsCount);
    private void Yield();
    private void AdvanceProgress();
    private void AttachTask(ITask task, int parentStepsCount, bool isShared);
    private void FireTaskAttached(ITask task, bool isShared);
    private void FireWaitForTask(ITask task, bool isShared);
    private void WaitForTask(ITask task, int parentStepsCount, bool isShared);
    private void Dispose();
    private void RaiseOperationProgressChanged();
    public sealed virtual bool get_Completed();
    public sealed virtual void Execute(ITaskExecutionEnvironment executionEnvironment);
    private void OnFinished();
    [CompilerGeneratedAttribute]
public sealed virtual Exception get_Exception();
    [CompilerGeneratedAttribute]
private void set_Exception(Exception value);
    public sealed virtual EventWaitHandle get_FinishedEvent();
    public sealed virtual string get_Title();
    private void set_Title(string value);
    public sealed virtual bool get_CanCancel();
    public sealed virtual void Cancel();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsCanceled();
    [CompilerGeneratedAttribute]
private void set_IsCanceled(bool value);
    public sealed virtual int get_OperationProgress();
    public sealed virtual void add_OperationProgressChanged(EventHandler`2<IAsyncOperation, ProgressChangedEventArgs> value);
    public sealed virtual void remove_OperationProgressChanged(EventHandler`2<IAsyncOperation, ProgressChangedEventArgs> value);
    public sealed virtual IEnumerable`1<IAsyncOperation> get_SubOperations();
    public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    public sealed virtual void add_Finished(EventHandler`2<ITask, EventArgs> value);
    public sealed virtual void remove_Finished(EventHandler`2<ITask, EventArgs> value);
    protected virtual void DoExecute(IExecutionController executionController);
    private void AttachSubOperation(ITask task, int parentStepsCount);
    private void SetProgress(double value, Boolean& fireProgressChanged);
    private void AdvanceOperationProgress(double value);
}
public class JetBrains.Common.Util.BackgroundRoutine : object {
    private Action myRoutineAction;
    private AutoResetEvent myRoutineWakeup;
    private Thread myThread;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) myStopRoutine;
    public BackgroundRoutine(string name, Action routineAction);
    private void Routine();
    public void WakeUp();
    public void Join();
    public sealed virtual void Dispose();
}
public class JetBrains.Common.Util.BinaryHeap`1 : object {
    private IList`1<T> myStorage;
    private Comparison`1<T> myComparison;
    [CompilerGeneratedAttribute]
private static Comparison`1<T> CS$<>9__CachedAnonymousMethodDelegate1;
    [CompilerGeneratedAttribute]
private static Comparison`1<T> CS$<>9__CachedAnonymousMethodDelegate3;
    public int Count { get; }
    public T Top { get; }
    public Comparison`1<T> Comparison { get; }
    public BinaryHeap`1(IEnumerable`1<T> storage);
    public BinaryHeap`1(Comparison`1<T> comparison);
    public BinaryHeap`1(IEnumerable`1<T> storage, Comparison`1<T> comparison);
    public sealed virtual int get_Count();
    public sealed virtual T get_Top();
    public sealed virtual T Pop();
    public sealed virtual void Push(T value);
    public sealed virtual Comparison`1<T> get_Comparison();
    private void AdjustHeap(int holeIndex, T value);
    private void Push(int holeIndex, int topIndex, T value);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [CompilerGeneratedAttribute]
private static int <.ctor>b__0(T l, T r);
    [CompilerGeneratedAttribute]
private static int <.ctor>b__2(T l, T r);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.BlittableHelper : object {
    public static bool IsBlittable();
    [ExtensionAttribute]
public static bool IsBlittable(Type type);
}
public static class JetBrains.Common.Util.BuildScript.RequestDotCommonCleanCompile : object {
    [BuildStepAttribute]
public static ValidateCleanCompilation Yield();
}
public class JetBrains.Common.Util.CancellableTaskExecutor : object {
    private static CancellableTaskExecutor ourInstance;
    private static CancellableTaskExecutor Instance { get; }
    public sealed virtual void Cancel(ITask sender);
    public sealed virtual void Yield(ITask sender);
    public sealed virtual void WaitForTask(ITask sender, ITask otherTask, bool isShared);
    public sealed virtual void AttachTask(ITask sender, ITask otherTask, bool isShared);
    private static CancellableTaskExecutor get_Instance();
    public static void Execute(ITask task);
    public static void ExecuteAsync(ITask task);
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Common.Util.ChunkArray`1 : object {
    public static int MaxAntiLohSizeInBytes;
    private static int MaxObjectSize;
    private int myIndexInChunkMask;
    private int myChunkLengthLog2;
    private int myLength;
    private T[][] myArray;
    private ChunkArray`1<T[]> myChunkArray;
    public int Length { get; }
    public T Item { get; public set; }
    private int System.Collections.Generic.ICollection<T>.Count { get; }
    public bool IsReadOnly { get; }
    public int Count { get; }
    public ChunkArray`1(IReadOnlyCollection`1<T> source);
    public ChunkArray`1(int length, ChunkCollectionMode mode);
    public ChunkArray`1(int length, int chunkLength, ChunkCollectionMode mode);
    private static int GetChunkLength();
    public int get_Length();
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    public void Fill(T item);
    private static int GetNearestLessPowOf2(int number);
    private static int GetPowOf2(int number);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override int System.Collections.Generic.ICollection<T>.get_Count();
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual bool Remove(T item);
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual int IndexOf(T item);
    public sealed virtual void Insert(int index, T item);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual int get_Count();
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.ChunkArrayExtension : object {
    [ExtensionAttribute]
public static void StableSort(ChunkArray`1<T> array, Comparison`1<T> comparison);
    [ExtensionAttribute]
public static void QuickSort(ChunkArray`1<T> array, Comparison`1<T> comparison);
    [ExtensionAttribute]
public static void QuickSort(ChunkArray`1<T> array);
    [ExtensionAttribute]
public static ChunkArray`1<BackIndexNode`1<T>> SortWithBackIndex(ChunkArray`1<T> array);
    [ExtensionAttribute]
public static ChunkArray`1<T> ToChunkArray(IReadOnlyCollection`1<T> collection);
    [ExtensionAttribute]
public static ChunkArray`1<T> ToChunkArray(ICollection`1<T> collection);
    [CompilerGeneratedAttribute]
private static int <SortWithBackIndex>b__0(BackIndexNode`1<T> l, BackIndexNode`1<T> r);
}
public static class JetBrains.Common.Util.ChunkArrayQuickSorter : object {
    private static int MaxDepth;
    public static void Sort(ChunkArray`1<T> array, IComparer`1<T> comparer);
    public static void AccordingSort(ChunkArray`1<TKey> keysArray, ChunkArray`1<TValue> valuesArray, IComparer`1<TKey> comparer);
}
public enum JetBrains.Common.Util.ChunkCollectionMode : Enum {
    public int value__;
    public static ChunkCollectionMode AntiLoh;
    public static ChunkCollectionMode Auto;
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Common.Util.ChunkList`1 : object {
    private static int MaxChunkSizeInBytes;
    private int myChunkLength;
    private int myIndexInChunkMask;
    private int myChunkLengthLog2;
    private List`1<List`1<T>> myChunks;
    [NotNullAttribute]
private List`1<T> myLastChunk;
    private int myCount;
    private int myVersion;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public T Item { get; public set; }
    public object SyncRoot { get; }
    public bool IsSynchronized { get; }
    public bool IsFixedSize { get; }
    private object System.Collections.IList.Item { get; private set; }
    public ChunkList`1(IEnumerable`1<T> enumerable);
    public ChunkList`1(int capacity);
    private List`1<T> CreateNewChunk();
    public sealed virtual bool Remove(T item);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual int IndexOf(T item);
    public sealed virtual void Insert(int index, T item);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public void AddRange(IEnumerable`1<T> collection);
    private static int GetNearestLessPowOf2(int number, Int32& pow);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Insert(int index, object value);
    public sealed virtual void CopyTo(Array array, int index);
    public sealed virtual object get_SyncRoot();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual void Remove(object value);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override int System.Collections.IList.Add(object value);
    public sealed virtual bool Contains(object value);
    public sealed virtual int IndexOf(object value);
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Common.Util.ChunkListBasedStorage`2 : object {
    private Func`2<TIndex, int> myIndexConverter;
    private ChunkList`1<TData> myStorage;
    public TData Item { get; public set; }
    public int Count { get; }
    public ChunkListBasedStorage`2(Func`2<TIndex, int> indexConverter, int capacity);
    public TData SafeGet(TIndex indexStructure);
    public TData get_Item(TIndex index);
    public void set_Item(TIndex index, TData value);
    public void Add(TIndex index, TData data);
    public void Clear();
    public int get_Count();
    public sealed virtual IEnumerator`1<TData> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.ChunkListExtension : object {
    [ExtensionAttribute]
public static ChunkList`1<T> ToChunkList(IEnumerable`1<T> collection);
    [ExtensionAttribute]
public static ChunkList`1<T> StableSort(ChunkList`1<T> list, Comparison`1<T> comparison);
    [ExtensionAttribute]
public static ChunkList`1<T> QuickSort(ChunkList`1<T> list, Comparison`1<T> comparison);
}
public static class JetBrains.Common.Util.ChunkListQuickSorter : object {
    private static int MaxDepth;
    public static void Sort(ChunkList`1<T> array, IComparer`1<T> comparer);
    public static void AccordingSort(ChunkList`1<TKey> keysArray, ChunkList`1<TValue> valuesArray, IComparer`1<TKey> comparer);
}
public class JetBrains.Common.Util.ChunkQueue`1 : object {
    private static int DefaultCapacity;
    private ChunkArray`1<T> myArray;
    private int myLength;
    private int myTail;
    private int myHead;
    private int myVersion;
    private int myCount;
    public bool IsEmpty { get; }
    public int Count { get; }
    public void Enqueue(T value);
    public T Peek();
    public T Dequeue();
    public bool get_IsEmpty();
    private static void CopyTo(IArray`1<T> src, IArray`1<T> dst, int srcIndex, int dstIndex, int len);
    public int get_Count();
    private void SetCapacity(int len);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.CollectionExtensions : object {
    [ExtensionAttribute]
public static bool IsEqualTo(IEnumerable`1<T> left, IEnumerable`1<T> right);
    [ExtensionAttribute]
public static bool IsEqualTo(IReadOnlyCollection`1<T> left, IReadOnlyCollection`1<T> right);
    [ExtensionAttribute]
public static int BinarySearch(IList`1<T> list, T item, IComparer`1<T> comparer);
    [ExtensionAttribute]
public static int BinarySearch(T[] array, T item);
    [ExtensionAttribute]
public static int BinarySearch(IList`1<T> list, T item, Comparison`1<T> comparison);
    [ExtensionAttribute]
public static int BinarySearch(IReadOnlyList`1<T> list, T item, Comparison`1<T> comparer);
    [ExtensionAttribute]
public static int BinarySearch(IReadOnlyList`1<T> list, T item);
    [ExtensionAttribute]
public static int BinarySearch(IReadOnlyList`1<T> list, Locator`1<T> locator);
    [ExtensionAttribute]
public static int BinarySearch(IReadOnlyList`1<T> list, int index, int length, Locator`1<T> locator);
    [ExtensionAttribute]
public static void Sort(IList`1<T> list, Comparison`1<T> comparison);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static T FindSorted(IReadOnlyList`1<T> collection, Func`2<T, int> comparer);
    [ExtensionAttribute]
public static int InsertSorted(IList`1<T> list, T value, Comparison`1<T> comparison, bool allowDupicates);
    [ExtensionAttribute]
public static int SortedIndexOf(IReadOnlyList`1<T> list, Func`2<T, int> comparer);
    [ExtensionAttribute]
public static int SortedIndexOf(IReadOnlyList`1<T> list, T value);
    [ExtensionAttribute]
public static int SortedIndexOf(IList`1<T> list, Func`2<T, int> comparer);
    [ExtensionAttribute]
public static void Fill(IList`1<T> list, T item);
    [ExtensionAttribute]
public static void Clear(T[] array);
    [ExtensionAttribute]
public static T[] Sort(T[] array);
    [ExtensionAttribute]
public static int IndexWhere(IEnumerable`1<T> array, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static void RemoveWhere(LinkedList`1<T> list, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static bool RemoveFirstWhere(IList`1<T> list, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static void RemoveAll(ICollection`1<T> source, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static void RemoveAll(ICollection`1<T> source, IEnumerable`1<T> toRemove);
    [ExtensionAttribute]
public static IEnumerable`1<int> IndicesWhere(IEnumerable`1<T> array, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static IEnumerable`1<T> Extend(IEnumerable`1<T> source, int n, Func`1<T> with);
    [ExtensionAttribute]
public static IEnumerable`1<T> Extend(IEnumerable`1<T> source, int n, T with);
    [ExtensionAttribute]
public static void CopyTo(IEnumerable`1<T> src, IArray`1<T> destination, int fromIndex);
    [ExtensionAttribute]
public static Object[] JoinParameters(Object[] parameters, Object[] toJoin);
    [ContractAnnotationAttribute("source: null => null; source: notnull => notnull")]
[ExtensionAttribute]
public static IReadOnlyCollection`1<T> Filter(IReadOnlyCollection`1<T> source, Func`2<T, bool> includeFilter);
    [NotNullAttribute]
[ExtensionAttribute]
public static IReadOnlyCollection`1<T> ToReadonly(ICollection`1<T> source);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.CollectionSynchronizerEx : object {
    [ExtensionAttribute]
public static void BindToLifetime(ICollectionSynchronizer synchronizer, Lifetime lifetime);
    [ExtensionAttribute]
public static ObservableCollection`1<TTarget> CreateSynchronizedList(IObservableSet`1<TSource> set, Func`2<TSource, TTarget> convert, Func`2<TTarget, TSource> convertBack, Lifetime lifetime);
    [ExtensionAttribute]
public static ObservableCollection`1<TTarget> CreateSynchronizedList(IList`1<TSource> set, Func`2<TSource, TTarget> convert, Func`2<TTarget, TSource> convertBack, Lifetime lifetime);
    [ExtensionAttribute]
public static IObservableSet`1<TTarget> CreateSynchronizedHashSet(IList`1<TSource> list, Func`2<TSource, TTarget> convert, Func`2<TTarget, TSource> convertBack, Lifetime lifetime);
    [ExtensionAttribute]
public static IObservableSet`1<TTarget> CreateSynchronizedSet(IList`1<TSource> list, ICollection`1<TTarget> targetCollection, Func`2<TSource, TTarget> convert, Func`2<TTarget, TSource> convertBack, Lifetime lifetime);
}
public static class JetBrains.Common.Util.CollectionUtils : object {
    public static IEnumerable`1<T> NotNull(T[] values);
}
internal abstract class JetBrains.Common.Util.CommandLine.ArgumentParser : object {
    [CompilerGeneratedAttribute]
private List`1<ParsingError> <PostParsingState>k__BackingField;
    public List`1<ParsingError> PostParsingState { get; private set; }
    public abstract virtual ParserState Parse(IArgumentEnumerator argumentEnumerator, OptionMap map, object options);
    [CompilerGeneratedAttribute]
public List`1<ParsingError> get_PostParsingState();
    [CompilerGeneratedAttribute]
private void set_PostParsingState(List`1<ParsingError> value);
    protected void DefineOptionThatViolatesFormat(OptionInfo option);
    public static ArgumentParser Create(string argument, bool ignoreUnknownArguments);
    public static bool IsInputValue(string argument);
    protected static IList`1<string> GetNextInputValues(IArgumentEnumerator ae);
    public static bool CompareShort(string argument, string option, bool caseSensitive);
    public static bool CompareLong(string argument, string option, bool caseSensitive);
    protected static ParserState BooleanToParserState(bool value);
    protected static ParserState BooleanToParserState(bool value, bool addMoveNextIfTrue);
    protected static void EnsureOptionAttributeIsArrayCompatible(OptionInfo option);
    protected static void EnsureOptionArrayAttributeIsNotBoundToScalar(OptionInfo option);
}
[AttributeUsageAttribute("1")]
[ComVisibleAttribute("True")]
public class JetBrains.Common.Util.CommandLine.AssemblyLicenseAttribute : MultiLineTextAttribute {
    public AssemblyLicenseAttribute(string line1);
    public AssemblyLicenseAttribute(string line1, string line2);
    public AssemblyLicenseAttribute(string line1, string line2, string line3);
    public AssemblyLicenseAttribute(string line1, string line2, string line3, string line4);
    public AssemblyLicenseAttribute(string line1, string line2, string line3, string line4, string line5);
}
[AttributeUsageAttribute("1")]
[ComVisibleAttribute("True")]
public class JetBrains.Common.Util.CommandLine.AssemblyUsageAttribute : MultiLineTextAttribute {
    public AssemblyUsageAttribute(string line1);
    public AssemblyUsageAttribute(string line1, string line2);
    public AssemblyUsageAttribute(string line1, string line2, string line3);
    public AssemblyUsageAttribute(string line1, string line2, string line3, string line4);
    public AssemblyUsageAttribute(string line1, string line2, string line3, string line4, string line5);
}
internal static class JetBrains.Common.Util.CommandLine.Assumes : object {
    public static void NotNull(T value, string paramName);
    public static void NotNullOrEmpty(string value, string paramName);
    public static void NotZeroLength(T[] array, string paramName);
}
public class JetBrains.Common.Util.CommandLine.BadOptionInfo : object {
    [CompilerGeneratedAttribute]
private string <ShortName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LongName>k__BackingField;
    public string ShortName { get; internal set; }
    public string LongName { get; internal set; }
    internal BadOptionInfo(string shortName, string longName);
    [CompilerGeneratedAttribute]
public string get_ShortName();
    [CompilerGeneratedAttribute]
internal void set_ShortName(string value);
    [CompilerGeneratedAttribute]
public string get_LongName();
    [CompilerGeneratedAttribute]
internal void set_LongName(string value);
}
public abstract class JetBrains.Common.Util.CommandLine.BaseOptionAttribute : Attribute {
    private string _shortName;
    private object _defaultValue;
    private bool _hasDefaultValue;
    [CompilerGeneratedAttribute]
private string <LongName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Required>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HelpText>k__BackingField;
    public string ShortName { get; internal set; }
    public string LongName { get; internal set; }
    public bool Required { get; public set; }
    public object DefaultValue { get; public set; }
    internal bool HasShortName { get; }
    internal bool HasLongName { get; }
    internal bool HasDefaultValue { get; }
    public string HelpText { get; public set; }
    public string get_ShortName();
    internal void set_ShortName(string value);
    [CompilerGeneratedAttribute]
public string get_LongName();
    [CompilerGeneratedAttribute]
internal void set_LongName(string value);
    [CompilerGeneratedAttribute]
public virtual bool get_Required();
    [CompilerGeneratedAttribute]
public virtual void set_Required(bool value);
    public object get_DefaultValue();
    public void set_DefaultValue(object value);
    internal bool get_HasShortName();
    internal bool get_HasLongName();
    internal bool get_HasDefaultValue();
    [CompilerGeneratedAttribute]
public string get_HelpText();
    [CompilerGeneratedAttribute]
public void set_HelpText(string value);
}
public abstract class JetBrains.Common.Util.CommandLine.BaseSentenceBuilder : object {
    public string OptionWord { get; }
    public string AndWord { get; }
    public string RequiredOptionMissingText { get; }
    public string ViolatesFormatText { get; }
    public string ViolatesMutualExclusivenessText { get; }
    public string ErrorsHeadingText { get; }
    public static BaseSentenceBuilder CreateBuiltIn();
    public abstract virtual string get_OptionWord();
    public abstract virtual string get_AndWord();
    public abstract virtual string get_RequiredOptionMissingText();
    public abstract virtual string get_ViolatesFormatText();
    public abstract virtual string get_ViolatesMutualExclusivenessText();
    public abstract virtual string get_ErrorsHeadingText();
}
public abstract class JetBrains.Common.Util.CommandLine.CommandLineOptionsBase : object {
    [CompilerGeneratedAttribute]
private PostParsingState <LastPostParsingState>k__BackingField;
    protected PostParsingState LastPostParsingState { get; private set; }
    internal PostParsingState InternalLastPostParsingState { get; }
    [CompilerGeneratedAttribute]
protected PostParsingState get_LastPostParsingState();
    [CompilerGeneratedAttribute]
private void set_LastPostParsingState(PostParsingState value);
    internal PostParsingState get_InternalLastPostParsingState();
}
public class JetBrains.Common.Util.CommandLine.CommandLineParser : object {
    private static ICommandLineParser DefaultParser;
    private CommandLineParserSettings _settings;
    public static ICommandLineParser Default { get; }
    private CommandLineParser(bool singleton);
    public CommandLineParser(CommandLineParserSettings settings);
    private static CommandLineParser();
    public static ICommandLineParser get_Default();
    public virtual bool ParseArguments(String[] args, object options);
    public virtual bool ParseArguments(String[] args, object options, TextWriter helpWriter);
    private bool DoParseArguments(String[] args, object options);
    private bool ParseHelp(String[] args, HelpOptionAttribute helpOption);
    private static void SetPostParsingStateIfNeeded(object options, IEnumerable`1<ParsingError> state);
}
public class JetBrains.Common.Util.CommandLine.CommandLineParserException : Exception {
    internal CommandLineParserException(string message);
    internal CommandLineParserException(string message, Exception innerException);
    internal CommandLineParserException(SerializationInfo info, StreamingContext context);
}
public class JetBrains.Common.Util.CommandLine.CommandLineParserSettings : object {
    private static bool CaseSensitiveDefault;
    [CompilerGeneratedAttribute]
private bool <CaseSensitive>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <MutuallyExclusive>k__BackingField;
    [CompilerGeneratedAttribute]
private TextWriter <HelpWriter>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreUnknownArguments>k__BackingField;
    internal bool CaseSensitive { get; public set; }
    internal bool MutuallyExclusive { get; public set; }
    internal TextWriter HelpWriter { get; public set; }
    internal bool IgnoreUnknownArguments { get; public set; }
    public CommandLineParserSettings(bool caseSensitive);
    public CommandLineParserSettings(TextWriter helpWriter);
    public CommandLineParserSettings(bool caseSensitive, TextWriter helpWriter);
    public CommandLineParserSettings(bool caseSensitive, bool mutuallyExclusive);
    public CommandLineParserSettings(bool caseSensitive, bool mutuallyExclusive, TextWriter helpWriter);
    public CommandLineParserSettings(bool caseSensitive, bool mutuallyExclusive, bool ignoreUnknownArguments, TextWriter helpWriter);
    [CompilerGeneratedAttribute]
internal bool get_CaseSensitive();
    [CompilerGeneratedAttribute]
public void set_CaseSensitive(bool value);
    [CompilerGeneratedAttribute]
internal bool get_MutuallyExclusive();
    [CompilerGeneratedAttribute]
public void set_MutuallyExclusive(bool value);
    [CompilerGeneratedAttribute]
internal TextWriter get_HelpWriter();
    [CompilerGeneratedAttribute]
public void set_HelpWriter(TextWriter value);
    [CompilerGeneratedAttribute]
internal bool get_IgnoreUnknownArguments();
    [CompilerGeneratedAttribute]
public void set_IgnoreUnknownArguments(bool value);
}
public class JetBrains.Common.Util.CommandLine.CopyrightInfo : object {
    private static string DefaultCopyrightWord;
    private static string SymbolLower;
    private static string SymbolUpper;
    private bool _isSymbolUpper;
    private Int32[] _years;
    private string _author;
    private int _builderSize;
    protected string CopyrightWord { get; }
    public CopyrightInfo(string author, int year);
    public CopyrightInfo(string author, Int32[] years);
    public CopyrightInfo(bool isSymbolUpper, string author, Int32[] years);
    public virtual string ToString();
    public static string op_Implicit(CopyrightInfo info);
    protected virtual string get_CopyrightWord();
    protected virtual string FormatYears(Int32[] years);
}
public class JetBrains.Common.Util.CommandLine.EnglishSentenceBuilder : BaseSentenceBuilder {
    public string OptionWord { get; }
    public string AndWord { get; }
    public string RequiredOptionMissingText { get; }
    public string ViolatesFormatText { get; }
    public string ViolatesMutualExclusivenessText { get; }
    public string ErrorsHeadingText { get; }
    public virtual string get_OptionWord();
    public virtual string get_AndWord();
    public virtual string get_RequiredOptionMissingText();
    public virtual string get_ViolatesFormatText();
    public virtual string get_ViolatesMutualExclusivenessText();
    public virtual string get_ErrorsHeadingText();
}
public class JetBrains.Common.Util.CommandLine.FormatOptionHelpTextEventArgs : EventArgs {
    private BaseOptionAttribute _option;
    public BaseOptionAttribute Option { get; }
    public FormatOptionHelpTextEventArgs(BaseOptionAttribute option);
    public BaseOptionAttribute get_Option();
}
public class JetBrains.Common.Util.CommandLine.HandleParsingErrorsDelegate : MulticastDelegate {
    public HandleParsingErrorsDelegate(object object, IntPtr method);
    public virtual void Invoke(HelpText current);
    public virtual IAsyncResult BeginInvoke(HelpText current, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class JetBrains.Common.Util.CommandLine.HeadingInfo : object {
    private string _programName;
    private string _version;
    public HeadingInfo(string programName);
    public HeadingInfo(string programName, string version);
    public virtual string ToString();
    public static string op_Implicit(HeadingInfo info);
    public void WriteMessage(string message, TextWriter writer);
    public void WriteMessage(string message);
    public void WriteError(string message);
}
[AttributeUsageAttribute("64")]
public class JetBrains.Common.Util.CommandLine.HelpOptionAttribute : BaseOptionAttribute {
    private static string DefaultHelpText;
    public bool Required { get; public set; }
    public HelpOptionAttribute(string shortName, string longName);
    public virtual bool get_Required();
    public virtual void set_Required(bool value);
    internal static void InvokeMethod(object target, Pair`2<MethodInfo, HelpOptionAttribute> pair, String& text);
    private static bool CheckMethodSignature(MethodInfo value);
}
public class JetBrains.Common.Util.CommandLine.HelpText : object {
    private static int BuilderCapacity;
    private static int DefaultMaximumLength;
    private static string DefaultRequiredWord;
    private Nullable`1<int> _maximumDisplayWidth;
    private string _heading;
    private string _copyright;
    private bool _additionalNewLineAfterOption;
    private StringBuilder _preOptionsHelp;
    private StringBuilder _optionsHelp;
    private StringBuilder _postOptionsHelp;
    private BaseSentenceBuilder _sentenceBuilder;
    private bool _addDashesToOption;
    private EventHandler`1<FormatOptionHelpTextEventArgs> FormatOptionHelpText;
    unknown string Heading {public set; }
    unknown string Copyright {public set; }
    public int MaximumDisplayWidth { get; public set; }
    public bool AddDashesToOption { get; public set; }
    public bool AdditionalNewLineAfterOption { get; public set; }
    public BaseSentenceBuilder SentenceBuilder { get; }
    public HelpText(BaseSentenceBuilder sentenceBuilder);
    public HelpText(string heading);
    public HelpText(BaseSentenceBuilder sentenceBuilder, string heading);
    public HelpText(string heading, string copyright);
    public HelpText(BaseSentenceBuilder sentenceBuilder, string heading, string copyright);
    public HelpText(string heading, string copyright, object options);
    public HelpText(BaseSentenceBuilder sentenceBuilder, string heading, string copyright, object options);
    public void add_FormatOptionHelpText(EventHandler`1<FormatOptionHelpTextEventArgs> value);
    public void remove_FormatOptionHelpText(EventHandler`1<FormatOptionHelpTextEventArgs> value);
    public static HelpText AutoBuild(object options);
    public static HelpText AutoBuild(object options, HandleParsingErrorsDelegate errDelegate);
    public static void DefaultParsingErrorsHandler(CommandLineOptionsBase options, HelpText current);
    public void set_Heading(string value);
    public void set_Copyright(string value);
    public int get_MaximumDisplayWidth();
    public void set_MaximumDisplayWidth(int value);
    public bool get_AddDashesToOption();
    public void set_AddDashesToOption(bool value);
    public bool get_AdditionalNewLineAfterOption();
    public void set_AdditionalNewLineAfterOption(bool value);
    public BaseSentenceBuilder get_SentenceBuilder();
    public void AddPreOptionsLine(string value);
    private void AddPreOptionsLine(string value, int maximumLength);
    public void AddPostOptionsLine(string value);
    public void AddOptions(object options);
    public void AddOptions(object options, string requiredWord);
    public void AddOptions(object options, string requiredWord, int maximumLength);
    public string RenderParsingErrorsText(CommandLineOptionsBase options, int indent);
    private void AddOption(string requiredWord, int maxLength, BaseOptionAttribute option, int widthOfHelpText);
    public virtual string ToString();
    public static string op_Implicit(HelpText info);
    private void AddLine(StringBuilder builder, string value);
    private static void AddLine(StringBuilder builder, string value, int maximumLength);
    private static int GetLength(string value);
    private static int GetLength(StringBuilder value);
    private int GetMaxLength(IEnumerable`1<BaseOptionAttribute> optionList);
    protected virtual void OnFormatOptionHelpText(FormatOptionHelpTextEventArgs e);
}
internal interface JetBrains.Common.Util.CommandLine.IArgumentEnumerator {
    public string Next { get; }
    public bool IsLast { get; }
    public string Current { get; }
    public abstract virtual string GetRemainingFromNext();
    public abstract virtual string get_Next();
    public abstract virtual bool get_IsLast();
    public abstract virtual bool MoveNext();
    public abstract virtual bool MovePrevious();
    public abstract virtual string get_Current();
}
public interface JetBrains.Common.Util.CommandLine.ICommandLineParser {
    public abstract virtual bool ParseArguments(String[] args, object options);
    public abstract virtual bool ParseArguments(String[] args, object options, TextWriter helpWriter);
}
internal class JetBrains.Common.Util.CommandLine.LongOptionParser : ArgumentParser {
    private bool _ignoreUnkwnownArguments;
    public LongOptionParser(bool ignoreUnkwnownArguments);
    public virtual ParserState Parse(IArgumentEnumerator argumentEnumerator, OptionMap map, object options);
}
public abstract class JetBrains.Common.Util.CommandLine.MultiLineTextAttribute : Attribute {
    private string _line1;
    private string _line2;
    private string _line3;
    private string _line4;
    private string _line5;
    protected MultiLineTextAttribute(string line1);
    protected MultiLineTextAttribute(string line1, string line2);
    protected MultiLineTextAttribute(string line1, string line2, string line3);
    protected MultiLineTextAttribute(string line1, string line2, string line3, string line4);
    protected MultiLineTextAttribute(string line1, string line2, string line3, string line4, string line5);
    internal void AddToHelpText(HelpText helpText, bool before);
}
internal class JetBrains.Common.Util.CommandLine.OneCharStringEnumerator : object {
    private string _currentElement;
    private int _index;
    private string _data;
    public string Current { get; }
    public string Next { get; }
    public bool IsLast { get; }
    public OneCharStringEnumerator(string value);
    public sealed virtual string get_Current();
    public sealed virtual string get_Next();
    public sealed virtual bool get_IsLast();
    public void Reset();
    public sealed virtual bool MoveNext();
    public sealed virtual string GetRemainingFromNext();
    public sealed virtual bool MovePrevious();
    private sealed virtual override void System.IDisposable.Dispose();
}
public class JetBrains.Common.Util.CommandLine.OptionArrayAttribute : OptionAttribute {
    public OptionArrayAttribute(string shortName, string longName);
}
[AttributeUsageAttribute("128")]
public class JetBrains.Common.Util.CommandLine.OptionAttribute : BaseOptionAttribute {
    internal static string DefaultMutuallyExclusiveSet;
    private string _uniqueName;
    private string _mutuallyExclusiveSet;
    internal string UniqueName { get; }
    public string MutuallyExclusiveSet { get; public set; }
    public OptionAttribute(string shortName, string longName);
    internal string get_UniqueName();
    public string get_MutuallyExclusiveSet();
    public void set_MutuallyExclusiveSet(string value);
}
internal class JetBrains.Common.Util.CommandLine.OptionGroupParser : ArgumentParser {
    private bool _ignoreUnkwnownArguments;
    public OptionGroupParser(bool ignoreUnkwnownArguments);
    public virtual ParserState Parse(IArgumentEnumerator argumentEnumerator, OptionMap map, object options);
}
[DebuggerDisplayAttribute("ShortName = {ShortName}, LongName = {LongName}")]
internal class JetBrains.Common.Util.CommandLine.OptionInfo : object {
    private OptionAttribute _attribute;
    private PropertyInfo _property;
    private bool _required;
    private string _helpText;
    private string _shortName;
    private string _longName;
    private string _mutuallyExclusiveSet;
    private object _defaultValue;
    private bool _hasDefaultValue;
    private object _setValueLock;
    [CompilerGeneratedAttribute]
private bool <IsDefined>k__BackingField;
    public string ShortName { get; }
    public string LongName { get; }
    internal string NameWithSwitch { get; }
    public string MutuallyExclusiveSet { get; }
    public bool Required { get; }
    public string HelpText { get; }
    public bool IsBoolean { get; }
    public bool IsArray { get; }
    public bool IsAttributeArrayCompatible { get; }
    public bool IsDefined { get; public set; }
    public bool HasBothNames { get; }
    public OptionInfo(OptionAttribute attribute, PropertyInfo property);
    public static OptionMap CreateMap(object target, CommandLineParserSettings settings);
    public bool SetValue(string value, object options);
    public bool SetValue(IList`1<string> values, object options);
    private bool SetValueScalar(string value, object options);
    private bool SetNullableValue(string value, object options);
    public bool SetValue(bool value, object options);
    private bool SetValueList(string value, object options);
    public void SetDefault(object options);
    public string get_ShortName();
    public string get_LongName();
    internal string get_NameWithSwitch();
    public string get_MutuallyExclusiveSet();
    public bool get_Required();
    public string get_HelpText();
    public bool get_IsBoolean();
    public bool get_IsArray();
    public bool get_IsAttributeArrayCompatible();
    [CompilerGeneratedAttribute]
public bool get_IsDefined();
    [CompilerGeneratedAttribute]
public void set_IsDefined(bool value);
    public bool get_HasBothNames();
}
public class JetBrains.Common.Util.CommandLine.OptionListAttribute : OptionAttribute {
    [CompilerGeneratedAttribute]
private char <Separator>k__BackingField;
    public char Separator { get; public set; }
    public OptionListAttribute(string shortName, string longName);
    public OptionListAttribute(string shortName, string longName, char separator);
    [CompilerGeneratedAttribute]
public char get_Separator();
    [CompilerGeneratedAttribute]
public void set_Separator(char value);
}
[DefaultMemberAttribute("Item")]
internal class JetBrains.Common.Util.CommandLine.OptionMap : object {
    private CommandLineParserSettings _settings;
    private Dictionary`2<string, string> _names;
    private Dictionary`2<string, OptionInfo> _map;
    private Dictionary`2<string, MutuallyExclusiveInfo> _mutuallyExclusiveSetMap;
    [CompilerGeneratedAttribute]
private object <RawOptions>k__BackingField;
    public OptionInfo Item { get; public set; }
    private object RawOptions { get; internal set; }
    public OptionMap(int capacity, CommandLineParserSettings settings);
    public OptionInfo get_Item(string key);
    public void set_Item(string key, OptionInfo value);
    [CompilerGeneratedAttribute]
private object get_RawOptions();
    [CompilerGeneratedAttribute]
internal void set_RawOptions(object value);
    public bool EnforceRules();
    public void SetDefaults();
    private bool EnforceRequiredRule();
    private bool EnforceMutuallyExclusiveMap();
    private void BuildMutuallyExclusiveMap(OptionInfo option);
    private static void BuildAndSetPostParsingStateIfNeeded(object options, OptionInfo option, Nullable`1<bool> required, Nullable`1<bool> mutualExclusiveness);
}
internal class JetBrains.Common.Util.CommandLine.Pair`2 : object {
    private TLeft _left;
    private TRight _right;
    public TLeft Left { get; }
    public TRight Right { get; }
    public Pair`2(TLeft left, TRight right);
    public TLeft get_Left();
    public TRight get_Right();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
[FlagsAttribute]
internal enum JetBrains.Common.Util.CommandLine.ParserState : Enum {
    public ushort value__;
    public static ParserState Success;
    public static ParserState Failure;
    public static ParserState MoveOnNextElement;
}
public class JetBrains.Common.Util.CommandLine.ParsingError : object {
    [CompilerGeneratedAttribute]
private BadOptionInfo <BadOption>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ViolatesRequired>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ViolatesFormat>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ViolatesMutualExclusiveness>k__BackingField;
    public BadOptionInfo BadOption { get; private set; }
    public bool ViolatesRequired { get; public set; }
    public bool ViolatesFormat { get; public set; }
    public bool ViolatesMutualExclusiveness { get; public set; }
    internal ParsingError(string shortName, string longName, bool format);
    [CompilerGeneratedAttribute]
public BadOptionInfo get_BadOption();
    [CompilerGeneratedAttribute]
private void set_BadOption(BadOptionInfo value);
    [CompilerGeneratedAttribute]
public bool get_ViolatesRequired();
    [CompilerGeneratedAttribute]
public void set_ViolatesRequired(bool value);
    [CompilerGeneratedAttribute]
public bool get_ViolatesFormat();
    [CompilerGeneratedAttribute]
public void set_ViolatesFormat(bool value);
    [CompilerGeneratedAttribute]
public bool get_ViolatesMutualExclusiveness();
    [CompilerGeneratedAttribute]
public void set_ViolatesMutualExclusiveness(bool value);
}
public class JetBrains.Common.Util.CommandLine.PostParsingState : object {
    [CompilerGeneratedAttribute]
private List`1<ParsingError> <Errors>k__BackingField;
    public List`1<ParsingError> Errors { get; private set; }
    [CompilerGeneratedAttribute]
public List`1<ParsingError> get_Errors();
    [CompilerGeneratedAttribute]
private void set_Errors(List`1<ParsingError> value);
}
internal static class JetBrains.Common.Util.CommandLine.ReflectionUtil : object {
    public static IList`1<Pair`2<PropertyInfo, TAttribute>> RetrievePropertyList(object target);
    public static Pair`2<MethodInfo, TAttribute> RetrieveMethod(object target);
    public static TAttribute RetrieveMethodAttributeOnly(object target);
    public static IList`1<TAttribute> RetrievePropertyAttributeList(object target);
    public static TAttribute GetAttribute();
    public static bool IsNullableType(Type type);
}
internal class JetBrains.Common.Util.CommandLine.StringArrayEnumerator : object {
    private String[] _data;
    private int _index;
    private int _endIndex;
    public string Current { get; }
    public string Next { get; }
    public bool IsLast { get; }
    public StringArrayEnumerator(String[] value);
    public sealed virtual string get_Current();
    public sealed virtual string get_Next();
    public sealed virtual bool get_IsLast();
    public void Reset();
    public sealed virtual bool MoveNext();
    public sealed virtual string GetRemainingFromNext();
    public sealed virtual bool MovePrevious();
    private sealed virtual override void System.IDisposable.Dispose();
}
internal static class JetBrains.Common.Util.CommandLine.StringUtil : object {
    public static string Spaces(int count);
    public static bool IsNumeric(string value);
}
internal class JetBrains.Common.Util.CommandLine.TargetWrapper : object {
    private object _target;
    private IList`1<string> _valueList;
    private ValueListAttribute _vla;
    public bool IsValueListDefined { get; }
    public TargetWrapper(object target);
    public bool get_IsValueListDefined();
    public bool AddValueItemIfAllowed(string item);
}
[AttributeUsageAttribute("128")]
public class JetBrains.Common.Util.CommandLine.ValueListAttribute : Attribute {
    private Type _concreteType;
    [CompilerGeneratedAttribute]
private int <MaximumElements>k__BackingField;
    public int MaximumElements { get; public set; }
    internal Type ConcreteType { get; }
    public ValueListAttribute(Type concreteType);
    [CompilerGeneratedAttribute]
public int get_MaximumElements();
    [CompilerGeneratedAttribute]
public void set_MaximumElements(int value);
    internal Type get_ConcreteType();
    internal static IList`1<string> GetReference(object target);
    internal static ValueListAttribute GetAttribute(object target);
    private static PropertyInfo GetProperty(object target, Type& concreteType);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.ComparisonExtensions : object {
    [ExtensionAttribute]
public static IComparer`1<T> ToComparer(Comparison`1<T> comparison);
}
public class JetBrains.Common.Util.ComparisonHelper : object {
    public static bool IsEqual(T op1, T op2);
    public static bool IsEqual(T op1, object op2);
    public static bool IsEqualStruct(T op1, T op2);
    public static bool IsEqualStruct(T op1, object op2);
}
public class JetBrains.Common.Util.ConditionalLog : object {
    public static string Define;
    private ILogger myLog;
    public ConditionalLog(ILogger logger);
    [ConditionalAttribute("JET_CONDITIONAL_LOG")]
[StringFormatMethodAttribute("message")]
public void Trace(string message);
    [StringFormatMethodAttribute("message")]
[ConditionalAttribute("JET_CONDITIONAL_LOG")]
public void Trace(string message, Object[] args);
    [ConditionalAttribute("JET_CONDITIONAL_LOG")]
[StringFormatMethodAttribute("message")]
public void Info(string message);
    [StringFormatMethodAttribute("message")]
[ConditionalAttribute("JET_CONDITIONAL_LOG")]
public void Info(string message, Object[] args);
}
public class JetBrains.Common.Util.CountableWrapper`1 : ValueType {
    private IEnumerable`1<T> myEnumerable;
    private int myCount;
    public int Count { get; }
    public CountableWrapper`1(ICollection`1<T> collection);
    public CountableWrapper`1(IEnumerable`1<T> enumerable, int count);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual int get_Count();
}
public class JetBrains.Common.Util.DataPipes.AcceptNewValue`1 : MulticastDelegate {
    public AcceptNewValue`1(object object, IntPtr method);
    public virtual bool Invoke(T previousValue, T newValue);
    public virtual IAsyncResult BeginInvoke(T previousValue, T newValue, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.DataPipes.AnimationsEx : object {
    private static IDataProvider`1<DateTime> ourAnimationTimer;
    [CompilerGeneratedAttribute]
private static Func`2<object, DateTime> CS$<>9__CachedAnonymousMethodDelegate3;
    [CompilerGeneratedAttribute]
private static Action`2<object, EventHandler> CS$<>9__CachedAnonymousMethodDelegate4;
    [CompilerGeneratedAttribute]
private static Action`2<object, EventHandler> CS$<>9__CachedAnonymousMethodDelegate5;
    private static AnimationsEx();
    [ExtensionAttribute]
public static IDataProvider`1<T> Animate(IDataProvider`1<T> targetValue, TimeSpan duration, Interpolator`1<T> interpolator);
    [CompilerGeneratedAttribute]
private static DateTime <.cctor>b__0(object _);
    [CompilerGeneratedAttribute]
private static void <.cctor>b__1(object _, EventHandler handler);
    [CompilerGeneratedAttribute]
private static void <.cctor>b__2(object _, EventHandler handler);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.DataPipes.BoolEx : object {
    [CompilerGeneratedAttribute]
private static Func`2<Boolean[], bool> CS$<>9__CachedAnonymousMethodDelegate2;
    [CompilerGeneratedAttribute]
private static Func`2<bool, bool> CS$<>9__CachedAnonymousMethodDelegate3;
    [CompilerGeneratedAttribute]
private static Func`2<Boolean[], bool> CS$<>9__CachedAnonymousMethodDelegate6;
    [CompilerGeneratedAttribute]
private static Func`2<bool, bool> CS$<>9__CachedAnonymousMethodDelegate7;
    [CompilerGeneratedAttribute]
private static Func`2<IEnumerable`1<bool>, bool> CS$<>9__CachedAnonymousMethodDelegatea;
    [CompilerGeneratedAttribute]
private static Func`2<bool, bool> CS$<>9__CachedAnonymousMethodDelegateb;
    [CompilerGeneratedAttribute]
private static Func`3<bool, bool, bool> CS$<>9__CachedAnonymousMethodDelegated;
    [CompilerGeneratedAttribute]
private static Func`3<bool, bool, bool> CS$<>9__CachedAnonymousMethodDelegatef;
    [CompilerGeneratedAttribute]
private static Func`2<IEnumerable`1<bool>, bool> CS$<>9__CachedAnonymousMethodDelegate12;
    [CompilerGeneratedAttribute]
private static Func`2<bool, bool> CS$<>9__CachedAnonymousMethodDelegate13;
    [CompilerGeneratedAttribute]
private static Func`2<bool, bool> CS$<>9__CachedAnonymousMethodDelegate15;
    [ExtensionAttribute]
public static IDataProvider`1<bool> AnyTrue(IEnumerable`1<IDataProvider`1<bool>> provider);
    [ExtensionAttribute]
public static IDataProvider`1<bool> AllTrue(IEnumerable`1<IDataProvider`1<bool>> provider);
    [ExtensionAttribute]
public static IDataProvider`1<bool> And(IDataProvider`1<bool> provider, IDataProvider`1[] providers);
    [ExtensionAttribute]
public static IDataProvider`1<bool> Or(IDataProvider`1<bool> p1, IDataProvider`1<bool> p2);
    [ExtensionAttribute]
public static IDataProvider`1<bool> And(IDataProvider`1<bool> p1, IDataProvider`1<bool> p2);
    [ExtensionAttribute]
public static IDataProvider`1<bool> Or(IDataProvider`1<bool> provider, IDataProvider`1[] providers);
    [ExtensionAttribute]
public static IDataProvider`1<bool> Invert(IDataProvider`1<bool> provider);
    [ExtensionAttribute]
public static void Flip(IDataController`1<bool> contorller);
    [CompilerGeneratedAttribute]
private static bool <AnyTrue>b__0(Boolean[] a);
    [CompilerGeneratedAttribute]
private static bool <AnyTrue>b__1(bool b);
    [CompilerGeneratedAttribute]
private static bool <AllTrue>b__4(Boolean[] a);
    [CompilerGeneratedAttribute]
private static bool <AllTrue>b__5(bool b);
    [CompilerGeneratedAttribute]
private static bool <And>b__8(IEnumerable`1<bool> b);
    [CompilerGeneratedAttribute]
private static bool <And>b__9(bool a);
    [CompilerGeneratedAttribute]
private static bool <Or>b__c(bool a, bool b);
    [CompilerGeneratedAttribute]
private static bool <And>b__e(bool a, bool b);
    [CompilerGeneratedAttribute]
private static bool <Or>b__10(IEnumerable`1<bool> b);
    [CompilerGeneratedAttribute]
private static bool <Or>b__11(bool a);
    [CompilerGeneratedAttribute]
private static bool <Invert>b__14(bool v);
}
public enum JetBrains.Common.Util.DataPipes.CollectionNotificationMode : Enum {
    public int value__;
    public static CollectionNotificationMode Reset;
    public static CollectionNotificationMode KeepPrefix;
    public static CollectionNotificationMode Move;
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.DataPipes.CombineEx : object {
    [CompilerGeneratedAttribute]
private static Func`2<IDataSignal, IDataProvider`1<TVoid>> CS$<>9__CachedAnonymousMethodDelegate1;
    [CompilerGeneratedAttribute]
private static Func`2<IEnumerable`1<IEnumerable`1<ProgressProvider>>, IEnumerable`1<ProgressProvider>> CS$<>9__CachedAnonymousMethodDelegate21;
    [CompilerGeneratedAttribute]
private static Func`2<IEnumerable`1<ProgressProvider>, IEnumerable`1<ProgressProvider>> CS$<>9__CachedAnonymousMethodDelegate22;
    [ExtensionAttribute]
public static IDataProvider`1<TA[]> Combine(IEnumerable`1<IDataProvider`1<TA>> providers);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<TA[]> Combine(IEnumerable`1<IAsyncDataProvider`1<TA>> providers);
    [ExtensionAttribute]
public static IDataSignal Combine(IEnumerable`1<IDataSignal> signals);
    [ExtensionAttribute]
public static IDataProvider`1<TA[]> Combine(IDataProvider`1[] providers);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<TA[]> Combine(IAsyncDataProvider`1[] providers);
    [ExtensionAttribute]
public static IRemotableReference`1<IDataProvider`1<TA[]>> Combine(IRemotableReference`1[] providers);
    [ExtensionAttribute]
public static IDataProvider`1<Nullable`1<Pair`2<TA, TB>>> CombineSafe(IDataProvider`1<Nullable`1<TA>> src1, IDataProvider`1<Nullable`1<TB>> src2);
    [ExtensionAttribute]
public static IDataProvider`1<TC> CombineSafe(IDataProvider`1<TA> src1, IDataProvider`1<Nullable`1<TB>> src2, Func`3<TA, TB, TC> converter);
    [ExtensionAttribute]
public static IDataProvider`1<TC> CombineSafe(IDataProvider`1<Nullable`1<TA>> src1, IDataProvider`1<TB> src2, Func`3<TA, TB, TC> converter);
    [ExtensionAttribute]
public static IDataProvider`1<TC> CombineSafe(IDataProvider`1<Nullable`1<TA>> src1, IDataProvider`1<Nullable`1<TB>> src2, Func`3<TA, TB, TC> converter);
    [ExtensionAttribute]
public static IDataProvider`1<TC> CombineSafe(IDataProvider`1<TA> src1, IDataProvider`1<TB> src2, Func`3<TA, TB, TC> converter);
    [ExtensionAttribute]
public static IDataProvider`1<TD> CombineSafe(IDataProvider`1<TA> src1, IDataProvider`1<TB> src2, IDataProvider`1<TC> src3, Func`4<TA, TB, TC, TD> converter);
    [ExtensionAttribute]
public static IDataProvider`1<TE> CombineSafe(IDataProvider`1<TA> src1, IDataProvider`1<TB> src2, IDataProvider`1<TC> src3, IDataProvider`1<TD> src4, Func`5<TA, TB, TC, TD, TE> converter);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<Pair`2<TA, TB>> Combine(IAsyncDataProvider`1<TA> source1, IThreadSwitch`1<TB> source2);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<Pair`2<TA, TB>> Combine(IAsyncDataProvider`1<TA> source1, IAsyncDataProvider`1<TB> source2);
    [ExtensionAttribute]
public static IDataProvider`1<Pair`2<TA, TB>> Combine(IDataProvider`1<TA> source1, IDataProvider`1<TB> source2);
    [ExtensionAttribute]
public static IDataProvider`1<TB> Combine(IDataProvider`1<TA> provider, Func`2<IEnumerable`1<TA>, TB> converter, IDataProvider`1[] providers);
    [ExtensionAttribute]
internal static IDataProvider`1<IEnumerable`1<ProgressProvider>> CombineProgresses(IDataProvider`1<IEnumerable`1<ProgressProvider>> source, IDataProvider`1[] other);
    [ExtensionAttribute]
public static IDataProvider`1<TB> CombineNotNull(IDataProvider`1<TA> provider, Func`2<IEnumerable`1<TA>, TB> converter, IDataProvider`1[] providers);
    [ExtensionAttribute]
public static IDataSignal Combine(IDataSignal signal, IDataSignal otherSignal);
    [ExtensionAttribute]
public static IDataProvider`1<TC> Combine(IDataProvider`1<TA> provider, IDataProvider`1<TB> otherProvider, Func`3<TA, TB, TC> converter);
    [ExtensionAttribute]
public static IRemotableReference`1<IDataProvider`1<TC>> Combine(IRemotableReference`1<IDataProvider`1<TA>> provider, IRemotableReference`1<IDataProvider`1<TB>> otherProvider, Func`3<TA, TB, TC> converter);
    [ExtensionAttribute]
public static IRemotableReference`1<IAsyncDataProvider`1<TC>> Combine(IRemotableReference`1<IAsyncDataProvider`1<TA>> provider, IRemotableReference`1<IAsyncDataProvider`1<TB>> otherProvider, Func`3<TA, TB, TC> converter);
    [ExtensionAttribute]
public static IRemotableReference`1<IDataProvider`1<TD>> Combine(IRemotableReference`1<IDataProvider`1<TA>> provider, IRemotableReference`1<IDataProvider`1<TB>> otherProvider, IRemotableReference`1<IDataProvider`1<TC>> thirdProvider, Func`4<TA, TB, TC, TD> converter);
    [ExtensionAttribute]
public static IRemotableReference`1<IAsyncDataProvider`1<TD>> Combine(IRemotableReference`1<IAsyncDataProvider`1<TA>> provider, IRemotableReference`1<IAsyncDataProvider`1<TB>> otherProvider, IRemotableReference`1<IAsyncDataProvider`1<TC>> thirdProvider, Func`4<TA, TB, TC, TD> converter);
    [ExtensionAttribute]
public static IDataProvider`1<T> Combine(IDataProvider`1<T> provider, IDataSignal signal);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<TC> Combine(IAsyncDataProvider`1<TA> provider, IThreadSwitch`1<TB> otherSwitch, Func`3<TA, TB, TC> converter);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<TD> Combine(IAsyncDataProvider`1<TA> provider, IThreadSwitch`1<TB> otherSwitch1, IThreadSwitch`1<TC> otherSwitch2, Func`4<TA, TB, TC, TD> converter);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<TD> Combine(IAsyncDataProvider`1<TA> provider, IThreadSwitch`1<TB> otherSwitch1, IThreadSwitch`1<TC> otherSwitch2, Func`5<TA, TB, TC, IExecutionController, TD> converter);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<TD> CombineSafe(IAsyncDataProvider`1<TA> provider, IThreadSwitch`1<TB> otherSwitch1, IThreadSwitch`1<TC> otherSwitch2, Func`5<TA, TB, TC, IExecutionController, TD> converter, TD fallback);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<TE> Combine(IAsyncDataProvider`1<TA> provider, IThreadSwitch`1<TB> otherSwitch1, IThreadSwitch`1<TC> otherSwitch2, IThreadSwitch`1<TD> otherSwitch3, Func`6<TA, TB, TC, TD, IExecutionController, TE> converter);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<TE> Combine(IAsyncDataProvider`1<TA> provider, IThreadSwitch`1<TB> otherSwitch1, IThreadSwitch`1<TC> otherSwitch2, IThreadSwitch`1<TD> otherSwitch3, Func`5<TA, TB, TC, TD, TE> converter);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<TF> Combine(IAsyncDataProvider`1<TA> provider, IThreadSwitch`1<TB> otherSwitch1, IThreadSwitch`1<TC> otherSwitch2, IThreadSwitch`1<TD> otherSwitch3, IThreadSwitch`1<TE> otherSwitch4, Func`6<TA, TB, TC, TD, TE, TF> converter);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<TJ> Combine(IAsyncDataProvider`1<TA> provider, IThreadSwitch`1<TB> otherSwitch1, IThreadSwitch`1<TC> otherSwitch2, IThreadSwitch`1<TD> otherSwitch3, IThreadSwitch`1<TE> otherSwitch4, IThreadSwitch`1<TF> otherSwitch5, Func`7<TA, TB, TC, TD, TE, TF, TJ> converter);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<TC> CombineSafe(IAsyncDataProvider`1<TA> provider, IThreadSwitch`1<TB> otherSwitch, Func`4<TA, TB, IExecutionController, TC> converter, TC fallback);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<TC> Combine(IAsyncDataProvider`1<TA> provider, IThreadSwitch`1<TB> otherSwitch, Func`4<TA, TB, IExecutionController, TC> converter);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<TC> Combine(IAsyncDataProvider`1<TA> src1, IAsyncDataProvider`1<TB> src2, Func`3<TA, TB, TC> converter);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<TD> Combine(IAsyncDataProvider`1<TA> src1, IAsyncDataProvider`1<TB> src2, IAsyncDataProvider`1<TC> src3, Func`4<TA, TB, TC, TD> converter);
    [ExtensionAttribute]
public static IDataProvider`1<TD> Combine(IDataProvider`1<TA> provider1, IDataProvider`1<TB> provider2, IDataProvider`1<TC> provider3, Func`4<TA, TB, TC, TD> converter);
    [ExtensionAttribute]
public static IDataProvider`1<TE> Combine(IDataProvider`1<TA> provider1, IDataProvider`1<TB> provider2, IDataProvider`1<TC> provider3, IDataProvider`1<TD> provider4, Func`5<TA, TB, TC, TD, TE> converter);
    [ExtensionAttribute]
public static IDataProvider`1<TF> Combine(IDataProvider`1<TA> provider1, IDataProvider`1<TB> provider2, IDataProvider`1<TC> provider3, IDataProvider`1<TD> provider4, IDataProvider`1<TE> provider5, Func`6<TA, TB, TC, TD, TE, TF> converter);
    [ExtensionAttribute]
public static IDataProvider`1<TJ> Combine(IDataProvider`1<TA> provider1, IDataProvider`1<TB> provider2, IDataProvider`1<TC> provider3, IDataProvider`1<TD> provider4, IDataProvider`1<TE> provider5, IDataProvider`1<TF> provider6, Func`7<TA, TB, TC, TD, TE, TF, TJ> converter);
    [ExtensionAttribute]
public static IDataProvider`1<TB> Combine(IDataProvider`1[] providers, Func`2<TA[], TB> converter);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<TB> Combine(IAsyncDataProvider`1[] providers, Func`2<TA[], TB> converter);
    [ExtensionAttribute]
public static IDataProvider`1<TB> CombineEnumerables(IDataProvider`1[] providers, Func`2<IEnumerable`1<TA>, TB> converter);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<TC> CombineSafe(IAsyncDataProvider`1<TA> provider, IThreadSwitch`1<TB> otherSwitch, Func`3<TA, TB, TC> converter, TC fallback);
    [CompilerGeneratedAttribute]
private static IDataProvider`1<TVoid> <Combine>b__0(IDataSignal s);
    [CompilerGeneratedAttribute]
private static TA[] <Combine>b__2(TA[] a);
    [CompilerGeneratedAttribute]
private static TA[] <Combine>b__3(TA[] a);
    [CompilerGeneratedAttribute]
private static Nullable`1<Pair`2<TA, TB>> <CombineSafe>b__9(Nullable`1<TA> a, Nullable`1<TB> b);
    [CompilerGeneratedAttribute]
private static Pair`2<TA, TB> <Combine>b__1c(TA a, TB b);
    [CompilerGeneratedAttribute]
private static Pair`2<TA, TB> <Combine>b__1d(TA a, TB b);
    [CompilerGeneratedAttribute]
private static Pair`2<TA, TB> <Combine>b__1e(TA a, TB b);
    [CompilerGeneratedAttribute]
private static IEnumerable`1<ProgressProvider> <CombineProgresses>b__1f(IEnumerable`1<IEnumerable`1<ProgressProvider>> a);
    [CompilerGeneratedAttribute]
private static IEnumerable`1<ProgressProvider> <CombineProgresses>b__20(IEnumerable`1<ProgressProvider> _);
    [CompilerGeneratedAttribute]
private static T <Combine>b__2f(T v, TVoid _);
    [CompilerGeneratedAttribute]
private static Pair`2<TA, TB> <Combine>b__33(TA a, TB b);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType0`3<TA, TB, TC> <Combine>b__37(TA a, TB b, TC c);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.DataPipes.CommandEx : object {
    [CompilerGeneratedAttribute]
private static Action`1<Action> CS$<>9__CachedAnonymousMethodDelegate1;
    [CompilerGeneratedAttribute]
private static Predicate`1<Action> CS$<>9__CachedAnonymousMethodDelegate7;
    [CompilerGeneratedAttribute]
private static Action`1<Action> CS$<>9__CachedAnonymousMethodDelegate8;
    [ExtensionAttribute]
public static ICommandContainer ToCommand(IDataProvider`1<bool> canExecuteProvider, IDataProvider`1<Action> executeProvider);
    [ExtensionAttribute]
public static ICommandContainer ToCommand(IDataProvider`1<bool> canExecuteProvider, IDataProvider`1<T> data, Action`1<T> execute);
    [ExtensionAttribute]
public static ICommandContainer ToCommand(IDataProvider`1<bool> canExecuteProvider, Action execute);
    [ExtensionAttribute]
public static ICommandContainer ToCommand(IDataProvider`1<Action> executeActionProvider);
    [ExtensionAttribute]
public static ICommandContainer ToCommandIfNotNull(IDataProvider`1<T> provider, Action`1<T> execute);
    [ExtensionAttribute]
public static ICommandContainer ToCommand(IDataProvider`1<T> provider, Predicate`1<T> canExecute, Action`1<T> execute);
    [ExtensionAttribute]
public static ICommandContainer ToCommandContainer(ICommand command);
    [CompilerGeneratedAttribute]
private static void <ToCommand>b__0(Action execute);
    [CompilerGeneratedAttribute]
private static bool <ToCommand>b__5(Action a);
    [CompilerGeneratedAttribute]
private static void <ToCommand>b__6(Action a);
    [CompilerGeneratedAttribute]
private static bool <ToCommandIfNotNull>b__9(T v);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.DataPipes.ConstructorEx : object {
    [CompilerGeneratedAttribute]
private static Action`2<DispatcherTimer, EventHandler> CS$<>9__CachedAnonymousMethodDelegate3d;
    [CompilerGeneratedAttribute]
private static Action`2<DispatcherTimer, EventHandler> CS$<>9__CachedAnonymousMethodDelegate3e;
    [ExtensionAttribute]
public static IDataController`1<T> AsDataController(T o);
    [ExtensionAttribute]
public static IDataProvider`1<T> AsDataProvider(T o);
    [ExtensionAttribute]
public static IDataProvider`1<T> AsDataProvider(T source, Action`2<T, Action> subscribeHandler, Action`2<T, Action> unsubscribeHandler);
    [ExtensionAttribute]
public static IDataProvider`1<TValue> AsDataProvider(TSource source, Func`2<TSource, TValue> getValue, Action`2<TSource, Action> subscribeHandler, Action`2<TSource, Action> unsubscribeHandler);
    [ExtensionAttribute]
public static IDataProvider`1<T> AsDataProviderCollectionChanged(T source);
    [ExtensionAttribute]
public static IDataProvider`1<TResult> AsDataProviderWithEventHandler(TSource source, Func`2<TSource, TResult> getValue, Action`2<TSource, EventHandler`2<THSource, TArgs>> subscribe, Action`2<TSource, EventHandler`2<THSource, TArgs>> unsubscribe);
    [ExtensionAttribute]
public static IDataProvider`1<TResult> AsDataProviderWithEventHandler(TSource source, Func`2<TSource, TResult> getValue, Action`2<TSource, EventHandler`1<TArgs>> subscribe, Action`2<TSource, EventHandler`1<TArgs>> unsubscribe);
    [ExtensionAttribute]
public static IDataProvider`1<TResult> AsDataProviderWithRoutedEventHandler(TSource source, Func`2<TSource, TResult> getValue, Action`2<TSource, RoutedEventHandler> subscribe, Action`2<TSource, RoutedEventHandler> unsubscribe);
    [ExtensionAttribute]
public static IDataProvider`1<TResult> AsDataProviderWithEventHandler(TSource source, Func`2<TSource, TResult> getValue, Action`2<TSource, EventHandler> subscribe, Action`2<TSource, EventHandler> unsubscribe);
    [ExtensionAttribute]
public static IDataProvider`1<PipeEventData`1<TArgs>> AsDataEvent(UIElement source, RoutedEvent routedEvent, Func`2<Action`1<TArgs>, Delegate> delegateBuilder);
    [ExtensionAttribute]
public static IDataProvider`1<PipeEventData`1<TArgs>> AsDataEvent(TSource source, Action`2<TSource, Action`1<TArgs>> subscribe, Action`2<TSource, Action`1<TArgs>> unsubscribe);
    [ExtensionAttribute]
public static IDataProvider`1<PipeEventData`1<TArgs>> AsDataEvent(TSource source, Action`2<TSource, EventHandler`1<TArgs>> subscribe, Action`2<TSource, EventHandler`1<TArgs>> unsubscribe);
    [ExtensionAttribute]
public static IDataProvider`1<PipeEventData`1<MouseEventArgs>> AsDataEvent(TSource source, Action`2<TSource, MouseEventHandler> subscribe, Action`2<TSource, MouseEventHandler> unsubscribe);
    [ExtensionAttribute]
public static IDataProvider`1<PipeEventData`1<KeyEventArgs>> AsDataEvent(TSource source, Action`2<TSource, KeyEventHandler> subscribe, Action`2<TSource, KeyEventHandler> unsubscribe);
    [ExtensionAttribute]
public static IDataProvider`1<PipeEventData`1<KeyboardFocusChangedEventArgs>> AsDataEvent(TSource source, Action`2<TSource, KeyboardFocusChangedEventHandler> subscribe, Action`2<TSource, KeyboardFocusChangedEventHandler> unsubscribe);
    [ExtensionAttribute]
public static IDataSignal AsDataSignal(TSource source, Action`2<TSource, Action> subscribe, Action`2<TSource, Action> unsubscribe);
    [ExtensionAttribute]
public static IDataProvider`1<PipeEventData`1<EventArgs>> AsDataEvent(TSource source, Action`2<TSource, EventHandler> subscribe, Action`2<TSource, EventHandler> unsubscribe);
    [ExtensionAttribute]
public static IDataProvider`1<PipeEventData`1<RoutedEventArgs>> AsDataEventRouted(TSource source, Action`2<TSource, RoutedEventHandler> subscribe, Action`2<TSource, RoutedEventHandler> unsubscribe);
    [ExtensionAttribute]
public static IDataProvider`1<PipeEventData`1<EventArgs>> ToDataEvent(DispatcherTimer timer);
    [ExtensionAttribute]
public static IThreadSwitch`1<T> ToThreadSwitch(IAsyncOperation`1<T> op);
    [ExtensionAttribute]
public static IDataProvider`1<T> CreateDependencyPropertyProvider(DependencyObject o, DependencyProperty property);
    [CompilerGeneratedAttribute]
private static T <AsDataProvider>b__0(T o);
    [CompilerGeneratedAttribute]
private static void <ToDataEvent>b__3b(DispatcherTimer t, EventHandler h);
    [CompilerGeneratedAttribute]
private static void <ToDataEvent>b__3c(DispatcherTimer t, EventHandler h);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.DataPipes.ControlledTransformEx : object {
    [ExtensionAttribute]
public static IDataProvider`1<T> ControlledTransform(IDataProvider`1<T> source, Action`2<T, ITransformController`1<T>> handler);
    [ExtensionAttribute]
public static IDataProvider`1<TB> ControlledTransform(IDataProvider`1<TA> source, TB initValue, Action`2<TA, ITransformController`1<TB>> handler);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<T> ControlledTransform(IAsyncDataProvider`1<T> source, Action`3<T, IExecutionController, ITransformController`1<T>> handler);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<TB> ControlledTransform(IAsyncDataProvider`1<TA> source, TB initValue, Action`3<TA, IExecutionController, ITransformController`1<TB>> handler);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.DataPipes.ConvertersEx : object {
    [CompilerGeneratedAttribute]
private static Func`2<IProgressIndicatorModel, ProgressProvider> CS$<>9__CachedAnonymousMethodDelegate6;
    [ExtensionAttribute]
public static IDataController`1<T> ToDataController(IProperty`1<T> property, Lifetime lifetime);
    [ExtensionAttribute]
public static IDataProvider`1<T> ToDataProvider(IProperty`1<T> property);
    [ExtensionAttribute]
public static IProperty`1<T> ToPropertyTwoWay(IDataController`1<T> controller, Lifetime lifetime, string id);
    [ExtensionAttribute]
public static IProperty`1<T> ToProperty(IDataProvider`1<T> provider, Lifetime lifetime, string id);
    [ExtensionAttribute]
internal static IThreadSwitch`1<T> ToThreadSwitch(IDataProviderBase`1<Getter`1<T>> provider, bool isStream);
    [ExtensionAttribute]
internal static IThreadSwitch`1<T> AsThreadSwitch(IDataProvider`1<T> provider, bool isStream);
    [ExtensionAttribute]
public static IAsyncDataSignal ToSignal(IAsyncDataProvider`1<T> provider);
    [ExtensionAttribute]
public static IDataSignal ToSignal(IDataProvider`1<T> provider);
    [ExtensionAttribute]
public static IDataSignal AsSignal(IDataProvider`1<TVoid> provider);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<TVoid> ToProvider(IAsyncDataSignal signal);
    [ExtensionAttribute]
public static IDataProvider`1<TVoid> ToProvider(IDataSignal signal);
    [ExtensionAttribute]
public static IDataProvider`1<ProgressProvider> ToProgressProvider(IDataProvider`1<IProgressIndicatorModel> progress);
    [CompilerGeneratedAttribute]
private static TVoid <ToSignal>b__4(T _);
    [CompilerGeneratedAttribute]
private static ProgressProvider <ToProgressProvider>b__5(IProgressIndicatorModel i);
}
public class JetBrains.Common.Util.DataPipes.DataAggregator`1 : object {
    private IDataController`1<List`1<KeyValuePair`2<int, IDataProvider`1<T>>>> myProviders;
    [CompilerGeneratedAttribute]
private IDataProvider`1<T> <Provider>k__BackingField;
    public IDataProvider`1<T> Provider { get; private set; }
    public DataAggregator`1(Func`2<IEnumerable`1<T>, T> aggregator);
    [CompilerGeneratedAttribute]
public sealed virtual IDataProvider`1<T> get_Provider();
    [CompilerGeneratedAttribute]
private void set_Provider(IDataProvider`1<T> value);
    public sealed virtual void Register(IDataProvider`1<T> provider, int priority);
    public sealed virtual void Unregister(IDataProvider`1<T> provider);
}
public abstract class JetBrains.Common.Util.DataPipes.DataControllerContainer`1 : object {
    public IDataController`1<T> Controller;
    public IDataProvider`1<T> Provider { get; }
    public T Value { get; public set; }
    protected DataControllerContainer`1(T initValue);
    public IDataProvider`1<T> get_Provider();
    public T get_Value();
    public void set_Value(T value);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.DataPipes.DataControllerEditorsEx : object {
    [CompilerGeneratedAttribute]
private static Func`2<ValueEditingState[], ValueEditingState> CS$<>9__CachedAnonymousMethodDelegateb;
    [CompilerGeneratedAttribute]
private static Func`2<ValueEditingState, bool> CS$<>9__CachedAnonymousMethodDelegated;
    [CompilerGeneratedAttribute]
private static Func`2<ValueEditingState, bool> CS$<>9__CachedAnonymousMethodDelegatef;
    [ExtensionAttribute]
public static ValueEditor`2<T, T> CreateDataControllerForEditing(IDataController`1<T> modelController, Lifetime lifetime, IDataSignalController saveSignal, IDataSignalController resetSignal, Func`2<T, string> validator);
    [ExtensionAttribute]
public static ValueEditor`2<T, T> CreateDataControllerForEditing(IDataController`1<T> modelController, Lifetime lifetime, IDataSignalController saveSignal, IDataSignalController resetSignal, IDataProvider`1<TV> extraValidationProvider, Func`3<T, TV, string> validator);
    [ExtensionAttribute]
public static ValueEditor`2<T, T> CreateDataControllerForEditing(IDataController`1<T> modelController, Lifetime lifetime, IDataSignalController saveSignal, IDataSignalController resetSignal, IEqualityComparer`1<T> comparer, Func`2<T, string> validator);
    [ExtensionAttribute]
public static ValueEditor`2<T, T> CreateDataControllerForEditing(IDataController`1<T> modelController, Lifetime lifetime, IDataSignalController saveSignal, IDataSignalController resetSignal, IEqualityComparer`1<T> comparer, IDataProvider`1<TV> extraValidationProvider, Func`3<T, TV, string> validator);
    [ExtensionAttribute]
public static ValueEditor`2<T, T> CreateDataControllerForEditing(IDataController`1<T> modelController, Lifetime lifetime, IDataSignalController saveSignal, IDataSignalController resetSignal, Func`3<T, T, bool> comparator, Func`2<T, string> validator);
    [ExtensionAttribute]
public static ValueEditor`2<T, T> CreateDataControllerForEditing(IDataController`1<T> modelController, Lifetime lifetime, IDataSignalController saveSignal, IDataSignalController resetSignal, Func`3<T, T, bool> comparator, IDataProvider`1<TV> extraValidationProvider, Func`3<T, TV, string> validator);
    [ExtensionAttribute]
public static ValueEditor`2<TO, TI> CreateDataControllerForEditing(IDataController`1<TI> modelController, Lifetime lifetime, IDataSignalController saveSignal, IDataSignalController resetSignal, Func`2<TI, TO> toUi, Func`2<TO, TI> toModel, Func`3<TI, TO, bool> comparator, Func`2<TO, string> validator);
    [ExtensionAttribute]
public static ValueEditor`2<TO, TI> CreateDataControllerForEditing(IDataController`1<TI> modelController, Lifetime lifetime, IDataSignalController saveSignal, IDataSignalController resetSignal, Func`2<TI, TO> toUi, Func`2<TO, TI> toModel, Func`3<TI, TO, bool> comparator, IDataProvider`1<TV> extraValidationProvider, Func`3<TO, TV, string> validator);
    [ExtensionAttribute]
public static IDataProvider`1<ValueEditingState> MergeChanges(IEnumerable`1<IDataProvider`1<ValueEditingState>> changes);
    public static IDataProvider`1<ValueEditingState> MergeChanges(IDataProvider`1[] changes);
    [ExtensionAttribute]
public static IDataProvider`1<bool> ToHaveValidChanges(IDataProvider`1<ValueEditingState> changes);
    [ExtensionAttribute]
public static IDataProvider`1<bool> ToCanSave(IDataProvider`1<ValueEditingState> changes);
    [CompilerGeneratedAttribute]
private static T <CreateDataControllerForEditing>b__0(T t);
    [CompilerGeneratedAttribute]
private static T <CreateDataControllerForEditing>b__1(T t);
    [CompilerGeneratedAttribute]
private static T <CreateDataControllerForEditing>b__2(T t);
    [CompilerGeneratedAttribute]
private static T <CreateDataControllerForEditing>b__3(T t);
    [CompilerGeneratedAttribute]
private static ValueEditingState <MergeChanges>b__a(ValueEditingState[] b);
    [CompilerGeneratedAttribute]
private static bool <ToHaveValidChanges>b__c(ValueEditingState p);
    [CompilerGeneratedAttribute]
private static bool <ToCanSave>b__e(ValueEditingState p);
}
public static class JetBrains.Common.Util.DataPipes.DataNotifiers : object {
    public static IDataNotifier`1<bool> True;
    public static IDataNotifier`1<bool> False;
    private static DataNotifiers();
}
public class JetBrains.Common.Util.DataPipes.DataPipe`2 : ValueType {
    public ISetProvider`1<TA> Input;
    public IDataProvider`1<TB> Output;
    public DataPipe`2(ISetProvider`1<TA> input, IDataProvider`1<TB> output);
}
public class JetBrains.Common.Util.DataPipes.DataPipeLifetime : object {
    private Lifetime myLifetime;
    private IDataProvider`1<PipeLifeState> myProvider;
    public Lifetime Lifetime { get; }
    internal IDataProvider`1<PipeLifeState> TerminationState { get; }
    public DataPipeLifetime(Lifetime lifetime);
    public Lifetime get_Lifetime();
    public static Lifetime op_Implicit(DataPipeLifetime lifetime);
    internal IDataProvider`1<PipeLifeState> get_TerminationState();
    public void Add(ITwoStepDisposable disposable, IDataProvider`1<bool> isSubscriptionActive);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.DataPipes.DataPipeLifetimeEx : object {
    [ExtensionAttribute]
public static DataPipeLifetime CreateDataPipeLifetime(Lifetime lifetime);
}
public class JetBrains.Common.Util.DataPipes.DataProviderIfClause`1 : ValueType {
    private IDataProxy`1<T> myElse;
    private IDataProvider`1<T> myResult;
    internal DataProviderIfClause`1(IDataProxy`1<T> else, IDataProvider`1<T> result);
    public IDataProvider`1<T> Else(IDataProvider`1<T> result);
    public IDataProvider`1<T> Else(T value);
    public DataProviderIfClause`1<T> ElseIf(IDataProvider`1<bool> condition, IDataProvider`1<T> result);
    public IDataProvider`1<T> ElseDefault();
}
public class JetBrains.Common.Util.DataPipes.DataProviderProxyMap`2 : object {
    private Dictionary`2<TKey, IDataProxy`1<TValue>> myMap;
    public sealed virtual IDataProvider`1<TValue> GetProvider(TKey key);
    private IDataProxy`1<TValue> GetOrCreate(TKey key);
    public sealed virtual void SetProvider(TKey key, IDataProvider`1<TValue> markersProvider);
}
public static class JetBrains.Common.Util.DataPipes.DataProviders : object {
    public static IDataProvider`1<bool> True;
    public static IDataProvider`1<bool> False;
    private static DataProviders();
    public static IDataProvider`1<T> Null();
    public static IAsyncDataProvider`1<T> NullAsync();
    public static IDataProxy`1<T> CreateProxy();
    public static IAsyncDataProxy`1<T> CreateAsyncProxy();
    public static IThreadSwitchProxy`1<T> CreateThreadSwitchProxy(bool isStream);
    public static IDataSignalProxy CreateSignalProxy();
    public static IDataProvider`1<T> NotInitializedStub();
    [NotNullAttribute]
public static IDataController`1<T> Create(T initialValue, IEqualityComparer`1<T> equalityComparer);
    [NotNullAttribute]
public static IDataProvider`1<T> Create(Func`1<T> createInitialValue);
    public static IDataSignal CreateCustomSignal(Action`1<Action> subscribeHandler, Action`1<Action> unsubscribeHandler);
    public static IDataEvent`1<T> CreateEvent();
    public static IDataSignalController CreateSignal();
    public static IAsyncDataSignalController CreateAsyncSignal();
    [NotNullAttribute]
public static IDataProvider`1<T> CreateConst(T initialValue);
    public static IAsyncDataController`1<T> CreateAsync(ProgressProvider progressProvider, T initialValue, ActionEvent cancelEvent, Action`1<Action> partialUpdateExecutor, IEqualityComparer`1<T> equalityComparer);
    public static IAsyncDataController`1<T> CreateAsync(IDataProvider`1<IEnumerable`1<ProgressProvider>> progressProvider, T initialValue, Action`1<Action> partialUpdateExecutor, IEqualityComparer`1<T> equalityComparer, ActionEvent cancelEvent);
    public static IAsyncDataController`1<T> CreateAsync(T initialValue, Action`1<Action> partialUpdateExecutor, IEqualityComparer`1<T> equalityComparer);
    public static IDataSignal CreatePeriodicSignal(TimeSpan fireEvery);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.DataPipes.EnumerableEx : object {
    [ExtensionAttribute]
public static IDataProvider`1<bool> Contains(IDataProvider`1<IReadOnlyCollection`1<T>> src, T value);
    [ExtensionAttribute]
public static IDataProvider`1<IEnumerable`1<TA>> Where(IDataProvider`1<IEnumerable`1<TA>> provider, Func`2<TA, bool> filter);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<IEnumerable`1<TA>> Where(IAsyncDataProvider`1<IEnumerable`1<TA>> provider, Func`2<TA, bool> filter);
    [ExtensionAttribute]
public static IEnumerable`1<T> Append(IEnumerable`1<T> items, T value);
    [ExtensionAttribute]
public static IEnumerable`1<T> Append(IEnumerable`1<T> a1, IEnumerable`1<T> a2);
    [ExtensionAttribute]
public static IEnumerable`1<T> NullToDefault(IEnumerable`1<Nullable`1<T>> a);
    [ExtensionAttribute]
public static IEnumerable`1<T> Append(IEnumerable`1<T> a1, IEnumerable`1<T> a2, IEnumerable`1<T> a3);
    [ExtensionAttribute]
public static IDataProvider`1<IEnumerable`1<T>> Append(IDataProvider`1<IEnumerable`1<T>> provider, T item);
    [ExtensionAttribute]
public static IDataProvider`1<IReadOnlyCollection`1<T>> ToReadOnlyCollectionProvider(IObservableSet`1<T> set);
    [ExtensionAttribute]
public static IDataProvider`1<IEnumerable`1<T>> Append(IDataProvider`1<IEnumerable`1<T>> provider, IEnumerable`1<T> items);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<IEnumerable`1<T>> Append(IAsyncDataProvider`1<IEnumerable`1<T>> provider, IEnumerable`1<T> items);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<IEnumerable`1<T>> Append(IAsyncDataProvider`1<IEnumerable`1<T>> provider, IAsyncDataProvider`1<T> itemProvider);
    [ExtensionAttribute]
public static IDataProvider`1<IEnumerable`1<T>> Append(IDataProvider`1<IEnumerable`1<T>> p1, IDataProvider`1<IEnumerable`1<T>> p2);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<IEnumerable`1<T>> Append(IAsyncDataProvider`1<IEnumerable`1<T>> p1, IAsyncDataProvider`1<IEnumerable`1<T>> p2);
    [ExtensionAttribute]
public static IDataProvider`1<IEnumerable`1<T>> Reverse(IDataProvider`1<IEnumerable`1<T>> src);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<IEnumerable`1<T>> Reverse(IAsyncDataProvider`1<IEnumerable`1<T>> src);
    [ExtensionAttribute]
public static IDataProvider`1<T[]> ToArray(IDataProvider`1<IEnumerable`1<T>> src);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<T[]> ToArray(IAsyncDataProvider`1<IEnumerable`1<T>> src);
    [ExtensionAttribute]
public static IDataProvider`1<T[]> EmptyArrayToNull(IDataProvider`1<T[]> src);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<T[]> EmptyArrayToNull(IAsyncDataProvider`1<T[]> src);
    [ExtensionAttribute]
public static IDataProvider`1<IReadOnlyCollection`1<T>> ToReadonlyCollection(IDataProvider`1<IEnumerable`1<T>> src, bool reuse);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<IReadOnlyCollection`1<T>> ToReadonlyCollection(IAsyncDataProvider`1<IEnumerable`1<T>> src, bool reuse);
    [ExtensionAttribute]
public static IDataProvider`1<IEnumerable`1<T>> Append(IDataProvider`1<IEnumerable`1<T>> p1, IDataProvider`1<T> p2);
    [ExtensionAttribute]
public static IDataProvider`1<IEnumerable`1<T>> Append(IDataProvider`1<IEnumerable`1<T>> p1, IDataProvider`1<IEnumerable`1<T>> p2, IDataProvider`1<IEnumerable`1<T>> p3);
    [ExtensionAttribute]
public static IDataProvider`1<IList`1<T>> ToList(IDataProvider`1<IEnumerable`1<T>> provider, bool reuseContainer);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<IList`1<T>> ToList(IAsyncDataProvider`1<IEnumerable`1<T>> provider, bool reuseContainer);
    [ExtensionAttribute]
public static IDataProvider`1<OneToListMap`2<TKey, TValue>> ToOneToListMap(IDataProvider`1<IEnumerable`1<KeyValuePair`2<TKey, TValue>>> provider, bool reuseContainer);
    [ExtensionAttribute]
public static IDataProvider`1<TC> ToCollection(IDataProvider`1<IEnumerable`1<T>> provider, bool reuseCollection);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<TC> ToCollection(IAsyncDataProvider`1<IEnumerable`1<T>> provider, bool reuseCollection);
    [ExtensionAttribute]
public static IDataProvider`1<TC> ToCollection(IDataProvider`1<T> provider, Func`1<TC> createCollection, Action`2<T, TC> fillCollection, bool reuseCollection);
    private static IDataProvider`1<TC> ToCollectionNoReuse(IDataProvider`1<T> provider, Func`1<TC> createCollection, Action`2<T, TC> fillCollection);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<TC> ToCollection(IAsyncDataProvider`1<T> provider, Func`1<TC> createCollection, Action`2<T, TC> fillCollection, bool reuseCollection);
    private static IAsyncDataProvider`1<TC> ToCollectionNoReuse(IAsyncDataProvider`1<T> provider, Func`1<TC> createCollection, Action`2<T, TC> fillCollection);
    [ExtensionAttribute]
public static IDataProvider`1<IEnumerable`1<T>> MergeManyEnumerables(IDataProvider`1<IEnumerable`1<IEnumerable`1<T>>> src);
    [ExtensionAttribute]
public static IDataProvider`1<bool> CheckAny(IEnumerable`1<IDataProvider`1<T>> providers, Func`2<T, bool> condition);
    [ExtensionAttribute]
public static IDataProvider`1<bool> CheckAll(IEnumerable`1<IDataProvider`1<T>> providers, Func`2<T, bool> condition);
    [ExtensionAttribute]
public static IDataProvider`1<bool> IsEmptyOrNull(IDataProvider`1<ICollection`1<T>> source);
    [ExtensionAttribute]
public static IDataProvider`1<bool> IsEmptyOrNull(IDataProvider`1<IReadOnlyCollection`1<T>> source);
    [ExtensionAttribute]
public static IDataProvider`1<bool> IsNotEmpty(IDataProvider`1<IReadOnlyCollection`1<T>> source);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<IEnumerable`1<T>> InjectController(IAsyncDataProvider`1<IEnumerable`1<T>> provider);
    [CompilerGeneratedAttribute]
private static T <NullToDefault>b__15(Nullable`1<T> _);
    [CompilerGeneratedAttribute]
private static void <ToReadOnlyCollectionProvider>b__26(IObservableSet`1<T> s, EventHandler`1<NotifySetChangedEventArgs`1<T>> h);
    [CompilerGeneratedAttribute]
private static void <ToReadOnlyCollectionProvider>b__27(IObservableSet`1<T> s, EventHandler`1<NotifySetChangedEventArgs`1<T>> h);
    [CompilerGeneratedAttribute]
private static IEnumerable`1<T> <Append>b__2d(IEnumerable`1<T> e1, IEnumerable`1<T> e2);
    [CompilerGeneratedAttribute]
private static IEnumerable`1<T> <Reverse>b__2e(IEnumerable`1<T> e);
    [CompilerGeneratedAttribute]
private static T[] <ToArray>b__2f(IEnumerable`1<T> s);
    [CompilerGeneratedAttribute]
private static T[] <ToArray>b__30(IEnumerable`1<T> s);
    [CompilerGeneratedAttribute]
private static T[] <EmptyArrayToNull>b__31(T[] t);
    [CompilerGeneratedAttribute]
private static T[] <EmptyArrayToNull>b__32(T[] t);
    [CompilerGeneratedAttribute]
private static ReadOnlyCollectionWrapper`1<T> <ToReadonlyCollection>b__34(IEnumerable`1<T> s);
    [CompilerGeneratedAttribute]
private static IEnumerable`1<T> <Append>b__37(IEnumerable`1<T> e1, T e2);
    [CompilerGeneratedAttribute]
private static IEnumerable`1<T> <Append>b__38(IEnumerable`1<T> e1, IEnumerable`1<T> e2, IEnumerable`1<T> e3);
    [CompilerGeneratedAttribute]
private static OneToListMap`2<TKey, TValue> <ToOneToListMap>b__39();
    [CompilerGeneratedAttribute]
private static void <ToOneToListMap>b__3a(IEnumerable`1<KeyValuePair`2<TKey, TValue>> items, OneToListMap`2<TKey, TValue> list);
    [CompilerGeneratedAttribute]
private static TC <ToCollection>b__3b();
    [CompilerGeneratedAttribute]
private static void <ToCollection>b__3c(IEnumerable`1<T> values, TC c);
    [CompilerGeneratedAttribute]
private static TC <ToCollection>b__3d();
    [CompilerGeneratedAttribute]
private static void <ToCollection>b__3e(IEnumerable`1<T> values, TC c);
    [CompilerGeneratedAttribute]
private static IEnumerable`1<T> <MergeManyEnumerables>b__4b(IEnumerable`1<IEnumerable`1<T>> e);
    [CompilerGeneratedAttribute]
private static IEnumerable`1<T> <MergeManyEnumerables>b__4c(IEnumerable`1<T> a);
    [CompilerGeneratedAttribute]
private static bool <IsEmptyOrNull>b__53(ICollection`1<T> c);
    [CompilerGeneratedAttribute]
private static bool <IsEmptyOrNull>b__54(IReadOnlyCollection`1<T> c);
    [CompilerGeneratedAttribute]
private static bool <IsNotEmpty>b__55(IReadOnlyCollection`1<T> c);
    [CompilerGeneratedAttribute]
private static IEnumerable`1<T> <InjectController>b__56(IEnumerable`1<T> a, IExecutionController c);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.DataPipes.FilterEx : object {
    [ExtensionAttribute]
public static IDataProvider`1<T> OnlyNotNull(IDataProvider`1<T> provider);
    [ExtensionAttribute]
public static IDataProvider`1<T> Filter(IDataProvider`1<T> provider, Func`2<T, bool> acceptValuePredicate);
    [ExtensionAttribute]
public static IDataProvider`1<T> FilterSafe(IDataProvider`1<T> provider, Func`2<T, bool> filter);
    [ExtensionAttribute]
public static IDataProvider`1<T> SkipIfEqualsNull(IDataProvider`1<T> provider);
    [ExtensionAttribute]
public static IDataProvider`1<Nullable`1<T>> SkipIfEqualsNull(IDataProvider`1<Nullable`1<T>> provider);
    [ExtensionAttribute]
public static IDataProvider`1<T> SkipIfEquals(IDataProvider`1<T> provider, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<T> SkipIfEquals(IAsyncDataProvider`1<T> provider, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<T> Filter(IAsyncDataProvider`1<T> provider, Func`2<T, bool> acceptValuePredicate);
    [ExtensionAttribute]
[ObsoleteAttribute("This method actually can't guarantee that output provider will never receive 'null' value, because when any provider is activated it is initialized with default value, that is 'null' for any class type. That's why usage of this method can be really misleading and should be avoided")]
public static IDataProvider`1<T> SkipIfNull(IDataProvider`1<T> provider);
    [ExtensionAttribute]
public static IDataProvider`1<Nullable`1<T>> SkipIfNull(IDataProvider`1<Nullable`1<T>> provider);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<T> SkipIfNull(IAsyncDataProvider`1<Nullable`1<T>> provider, T defaultValue);
    [ExtensionAttribute]
public static IDataProvider`1<T> SkipIfNull(IDataProvider`1<Nullable`1<T>> provider, T defaultValue);
    [ExtensionAttribute]
public static IDataProvider`1<T> FilterWithPrev(IDataProvider`1<T> provider, AcceptNewValue`1<T> filter);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<T> FilterWithPrev(IAsyncDataProvider`1<T> provider, AcceptNewValue`1<T> filter);
    [CompilerGeneratedAttribute]
private static bool <OnlyNotNull>b__0(T v);
    [CompilerGeneratedAttribute]
private static bool <SkipIfEqualsNull>b__4(T o, T n);
    [CompilerGeneratedAttribute]
private static bool <SkipIfEqualsNull>b__5(Nullable`1<T> o, Nullable`1<T> n);
    [CompilerGeneratedAttribute]
private static bool <SkipIfNull>b__9(T n);
    [CompilerGeneratedAttribute]
private static bool <SkipIfNull>b__a(Nullable`1<T> n);
    [CompilerGeneratedAttribute]
private static bool <SkipIfNull>b__b(Nullable`1<T> n);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.DataPipes.FlowIntoEx : object {
    [ExtensionAttribute]
public static void FlowInto(IDataProvider`1<PipeEventData`1<T>> src, Lifetime lifetime, IDataController`1<T> dst);
    [ExtensionAttribute]
public static void FlowInto(IDataProvider`1<T> src, Lifetime lifetime, IDataController`1<T> dst);
    [ExtensionAttribute]
public static void FlowInto(IDataProvider`1<T> src, Lifetime lifetime, IDataController`1<T> dst, Func`2<T, bool> condition);
    [ExtensionAttribute]
public static void FlowInto(IDataProvider`1<TA> src, Lifetime lifetime, IDataController`1<TB> dst, Func`2<TA, bool> condition, Func`2<TA, TB> converter);
    [ExtensionAttribute]
public static void FlowIntoSafe(IDataProvider`1<TA> src, Lifetime lifetime, IDataController`1<TB> dst, Func`2<TA, TB> converter);
    [ExtensionAttribute]
public static void FlowIntoSafe(IDataProvider`1<Nullable`1<TA>> src, Lifetime lifetime, IDataController`1<TB> dst, Func`2<TA, TB> converter);
    [ExtensionAttribute]
public static void FlowIntoProperty(IDataProvider`1<T> provider, Lifetime lifetime, IProperty`1<T> property, bool initInvoke);
    [ExtensionAttribute]
public static void FlowIntoPropertyTwoWay(IDataController`1<T> controller, Lifetime lifetime, IProperty`1<T> property, bool initInvoke);
    [CompilerGeneratedAttribute]
private static bool <FlowIntoSafe>b__c(TA a);
    [CompilerGeneratedAttribute]
private static bool <FlowIntoSafe>b__10(Nullable`1<TA> a);
}
public class JetBrains.Common.Util.DataPipes.Getter`1 : MulticastDelegate {
    public Getter`1(object object, IntPtr method);
    public virtual T Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual T EndInvoke(IAsyncResult result);
}
public class JetBrains.Common.Util.DataPipes.GetterAsync`1 : MulticastDelegate {
    public GetterAsync`1(object object, IntPtr method);
    public virtual T Invoke(IExecutionController controller);
    public virtual IAsyncResult BeginInvoke(IExecutionController controller, AsyncCallback callback, object object);
    public virtual T EndInvoke(IAsyncResult result);
}
public interface JetBrains.Common.Util.DataPipes.IAggregatedDataProvider`1 {
    public IDataProvider`1<T> Provider { get; }
    public abstract virtual IDataProvider`1<T> get_Provider();
}
public interface JetBrains.Common.Util.DataPipes.IAsyncDataController`1 {
}
public interface JetBrains.Common.Util.DataPipes.IAsyncDataProvider`1 {
}
public interface JetBrains.Common.Util.DataPipes.IAsyncDataProxy`1 {
}
public interface JetBrains.Common.Util.DataPipes.IAsyncDataSignal {
}
public interface JetBrains.Common.Util.DataPipes.IAsyncDataSignalController {
}
public interface JetBrains.Common.Util.DataPipes.ICollectionNotifier {
}
public interface JetBrains.Common.Util.DataPipes.ICollectionNotifier`1 {
}
public interface JetBrains.Common.Util.DataPipes.IDataAggregator`1 {
    public abstract virtual void Register(IDataProvider`1<T> provider, int priority);
    public abstract virtual void Unregister(IDataProvider`1<T> provider);
}
public interface JetBrains.Common.Util.DataPipes.IDataController`1 {
}
public interface JetBrains.Common.Util.DataPipes.IDataControllerBase`1 {
    public T Value { get; public set; }
    public abstract virtual T get_Value();
    public abstract virtual void set_Value(T value);
    public abstract virtual void RaiseChanged();
    public abstract virtual void RaiseChanged(T value);
}
public interface JetBrains.Common.Util.DataPipes.IDataEvent`1 {
    public abstract virtual void Fire(T data);
}
public interface JetBrains.Common.Util.DataPipes.IDataNotifier`1 {
    [CanBeNullAttribute]
public T Value { get; }
    public abstract virtual T get_Value();
}
public interface JetBrains.Common.Util.DataPipes.IDataPipeNode {
}
public interface JetBrains.Common.Util.DataPipes.IDataProvider`1 {
    public abstract virtual T GetValue();
}
public interface JetBrains.Common.Util.DataPipes.IDataProviderBase`1 {
}
public interface JetBrains.Common.Util.DataPipes.IDataProviderProxyMap`2 {
    public abstract virtual void SetProvider(TKey key, IDataProvider`1<TValue> provider);
    public abstract virtual IDataProvider`1<TValue> GetProvider(TKey key);
}
public interface JetBrains.Common.Util.DataPipes.IDataProxy`1 {
}
public interface JetBrains.Common.Util.DataPipes.IDataSignal {
}
public interface JetBrains.Common.Util.DataPipes.IDataSignalBase {
}
public interface JetBrains.Common.Util.DataPipes.IDataSignalController {
}
public interface JetBrains.Common.Util.DataPipes.IDataSignalControllerBase {
    public abstract virtual void Raise();
}
public interface JetBrains.Common.Util.DataPipes.IDataSignalProxy {
    unknown IDataSignal Source {public set; }
    public abstract virtual void set_Source(IDataSignal value);
}
public interface JetBrains.Common.Util.DataPipes.IDataSink`1 {
    public T Value { get; }
    public bool IsActive { get; }
    public IDataProvider`1<T> Provider { get; }
    public abstract virtual T get_Value();
    public abstract virtual bool get_IsActive();
    public abstract virtual IDataProvider`1<T> get_Provider();
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.DataPipes.IfEx : object {
    [ExtensionAttribute]
public static IDataProvider`1<T> IfNull(IDataProvider`1<T> src, IDataProvider`1<T> other);
    [ExtensionAttribute]
public static IDataProvider`1<Nullable`1<T>> IfNull(IDataProvider`1<Nullable`1<T>> src, IDataProvider`1<Nullable`1<T>> other);
    [ExtensionAttribute]
public static IDataProvider`1<T> IfNull(IDataProvider`1<T> src, Func`1<T> factory);
    [ExtensionAttribute]
public static IDataProvider`1<T> IfNull(IDataProvider`1<T> src, T value);
    [ExtensionAttribute]
public static IDataProvider`1<T> IfNull(IDataProvider`1<Nullable`1<T>> src, IDataProvider`1<T> other);
    [ExtensionAttribute]
public static IDataProvider`1<T> IfReplace(IDataProvider`1<T> src, Func`2<T, bool> condition, IDataProvider`1<T> replaceTarget);
    [ExtensionAttribute]
public static IDataProvider`1<T> IfNotNull(IDataProvider`1<T> src, IDataProvider`1<T> other);
    [ExtensionAttribute]
public static DataProviderIfClause`1<T> IfTrue(IDataProvider`1<bool> condition, IDataProvider`1<T> trueResult);
    [ExtensionAttribute]
public static DataProviderIfClause`1<TB> If(IDataProvider`1<TA> provider, Func`2<TA, bool> condition, IDataProvider`1<TB> conditionTrueResult);
    [ExtensionAttribute]
public static DataProviderIfClause`1<T> IfFalse(IDataProvider`1<bool> condition, IDataProvider`1<T> falseResult);
    [CompilerGeneratedAttribute]
private static T <IfNull>b__0(T _);
    [CompilerGeneratedAttribute]
private static T <IfNull>b__1(T _);
    [CompilerGeneratedAttribute]
private static T <IfNull>b__2(Nullable`1<T> t);
}
public interface JetBrains.Common.Util.DataPipes.IGroupingToken {
}
public class JetBrains.Common.Util.DataPipes.Impl.ActionEvent : object {
    private Action Event;
    public void Raise();
    public void add_Event(Action value);
    public void remove_Event(Action value);
}
public abstract class JetBrains.Common.Util.DataPipes.Impl.Activateable : object {
    private bool myIsActive;
    protected bool IsActive { get; protected set; }
    protected bool get_IsActive();
    [ThreadSafetyAttribute("0")]
protected void set_IsActive(bool value);
    [ThreadSafetyAttribute("0")]
protected virtual void OnDeactivated();
    [ThreadSafetyAttribute("0")]
protected virtual void OnActivated();
}
internal abstract class JetBrains.Common.Util.DataPipes.Impl.ActivateableWithActivationController : Activateable {
    private IDataController`1<bool> myIsSubscriptionActive;
    protected IDataController`1<bool> IsActiveController { get; }
    protected IDataController`1<bool> get_IsActiveController();
    protected virtual void OnDeactivated();
    protected virtual void OnActivated();
}
internal abstract class JetBrains.Common.Util.DataPipes.Impl.ActivateableWithWeakSubscriptionAndActivationController`1 : ActivateableWithActivationController {
    private Dispatcher myMainDispatcher;
    [CompilerGeneratedAttribute]
private static Action`2<ActivateableWithWeakSubscriptionAndActivationController`1<T>, T> CS$<>9__CachedAnonymousMethodDelegate1;
    protected ActivateableWithWeakSubscriptionAndActivationController`1(IDataProvider`1<T> provider);
    protected abstract virtual void OnSourceUpdated(T value);
    protected virtual void Finalize();
    [CompilerGeneratedAttribute]
private static void <.ctor>b__0(ActivateableWithWeakSubscriptionAndActivationController`1<T> s, T v);
}
internal class JetBrains.Common.Util.DataPipes.Impl.ActivationTrackerDataProvider`1 : DataProviderWithSource`2<T, T> {
    private IDataController`1<bool> myIsActive;
    public IDataProvider`1<bool> IsActive { get; }
    public ActivationTrackerDataProvider`1(IDataProvider`1<T> source);
    public IDataProvider`1<bool> get_IsActive();
    protected virtual void OnSourceUpdated(T newValue);
    protected virtual bool OnActivated();
    protected virtual void OnDeactivated();
}
public enum JetBrains.Common.Util.DataPipes.Impl.AsyncComputationState : Enum {
    public int value__;
    public static AsyncComputationState WaitForExecution;
    public static AsyncComputationState Executing;
    public static AsyncComputationState Ready;
}
internal class JetBrains.Common.Util.DataPipes.Impl.AsyncConstDataProvider`1 : ConstDataProvider`1<T> {
    public IAsyncController Controller { get; }
    public ILightExecutionController ExecutionController { get; }
    public AsyncConstDataProvider`1(T value);
    public virtual IAsyncController get_Controller();
    public sealed virtual ILightExecutionController get_ExecutionController();
    public sealed virtual void Request(Action task);
}
internal class JetBrains.Common.Util.DataPipes.Impl.AsyncDataProvider`1 : DataProviderWithSource`2<T, T> {
    private ISequentialTaskExecutor myTaskExecutor;
    private bool mySourceIsAsync;
    private bool myCancelOnNewValue;
    private Action`1<ICancelArgs> Cancel;
    private string myTitle;
    private IDataController`1<bool> myIsSubscribedToLifetime;
    private Dispatcher myDispatcher;
    private object myLock;
    private bool myReceivedValue;
    [CompilerGeneratedAttribute]
private ILightExecutionController <ExecutionController>k__BackingField;
    public ILightExecutionController ExecutionController { get; private set; }
    public bool HasValue { get; }
    public IAsyncController Controller { get; }
    public AsyncDataProvider`1(IDataProvider`1<T> dataProvider, Action`1<ITask> execute, DataPipeLifetime lifetime, bool cancelOnNewValue, string title);
    [CompilerGeneratedAttribute]
public sealed virtual ILightExecutionController get_ExecutionController();
    [CompilerGeneratedAttribute]
private void set_ExecutionController(ILightExecutionController value);
    public sealed virtual void Request(Action task);
    public virtual void add_Cancel(Action`1<ICancelArgs> value);
    public virtual void remove_Cancel(Action`1<ICancelArgs> value);
    public virtual bool get_HasValue();
    private void SourceOnCancel(ICancelArgs args);
    private void FireCancel(ICancelArgs args);
    private void OnSomeTaskFinishedSynchronized();
    protected virtual bool OnActivated();
    protected virtual void OnDeactivated();
    [ThreadSafetyAttribute("1")]
protected virtual void OnSourceUpdated(T newValue);
    private ITask CreateTask(Action action);
    private void TaskOnFinished(ITask sender, EventArgs args);
    public virtual string ToString();
    public virtual IAsyncController get_Controller();
}
internal class JetBrains.Common.Util.DataPipes.Impl.AsyncOperationAdapter`1 : AsyncOperationAdapter`2<T, IAsyncOperation`1<T>> {
    public AsyncOperationAdapter`1(IAsyncOperation`1<T> operation);
    protected virtual T GetResult(IAsyncOperation`1<T> operation);
}
internal abstract class JetBrains.Common.Util.DataPipes.Impl.AsyncOperationAdapter`2 : DataProvider`1<T> {
    private TA modreq(System.Runtime.CompilerServices.IsVolatile) myOperation;
    public bool HasValue { get; }
    protected AsyncOperationAdapter`2(TA operation);
    protected virtual bool OnActivated();
    protected virtual void OnDeactivated();
    protected abstract virtual T GetResult(TA operation);
    private void OperationOnFinished(ITask sender, EventArgs args);
    public virtual bool get_HasValue();
}
internal class JetBrains.Common.Util.DataPipes.Impl.BindDataProvider`1 : ProxyDataProvider`1<TV> {
    private IDataProviderInternal`1<IDataProviderBase`1<TV>> mySwitchKeyProvider;
    private bool mySwitchKeyAsyncFired;
    public IDataProviderInternal[] Sources { get; }
    public BindDataProvider`1(IDataProvider`1<IDataProviderBase`1<TV>> switchKeyProvider, bool isAsync);
    public virtual IDataProviderInternal[] get_Sources();
    protected virtual bool OnActivated();
    protected virtual void UpdateValueFromSources();
    protected virtual void OnDeactivated();
    private void SwitchKeyProviderOnUpdated(IDataProviderBase`1<TV> newValue);
}
internal class JetBrains.Common.Util.DataPipes.Impl.CancelArgs : object {
    public static ICancelArgs Empty;
    [CompilerGeneratedAttribute]
private bool <AnyComputationCanceled>k__BackingField;
    public bool AnyComputationCanceled { get; private set; }
    private static CancelArgs();
    [CompilerGeneratedAttribute]
public bool get_AnyComputationCanceled();
    [CompilerGeneratedAttribute]
private void set_AnyComputationCanceled(bool value);
    public sealed virtual void ComputationWasCanceled();
}
internal class JetBrains.Common.Util.DataPipes.Impl.Collections.DataCollectionKeepPrefixNotifier`1 : DataCollectionNotifier`1<T> {
    private IList`1<T> myOldValues;
    private IList`1<T> myNewValues;
    protected IEnumerable`1<T> Value { get; }
    public DataCollectionKeepPrefixNotifier`1(IDataProvider`1<IEnumerable`1<T>> source);
    protected virtual IEnumerable`1<T> get_Value();
    protected virtual void OnSourceUpdated(IEnumerable`1<T> newValue);
}
internal class JetBrains.Common.Util.DataPipes.Impl.Collections.DataCollectionMoveNotifier`1 : DataCollectionNotifier`1<T> {
    private List`1<T> myList;
    protected IEnumerable`1<T> Value { get; }
    public DataCollectionMoveNotifier`1(IDataProvider`1<IEnumerable`1<T>> source);
    protected virtual IEnumerable`1<T> get_Value();
    private void Move(int src, int dst);
    protected virtual void OnSourceUpdated(IEnumerable`1<T> newValue);
}
internal abstract class JetBrains.Common.Util.DataPipes.Impl.Collections.DataCollectionNotifier`1 : ActivateableWithWeakSubscriptionAndActivationController`1<IEnumerable`1<T>> {
    private IDataController`1<bool> myIsSubscriptionActive;
    private NotifyCollectionChangedEventHandler myCollectionChanged;
    [CompilerGeneratedAttribute]
private static Action`2<DataCollectionNotifier`1<T>, IEnumerable`1<T>> CS$<>9__CachedAnonymousMethodDelegate1;
    protected IEnumerable`1<T> Value { get; }
    protected DataCollectionNotifier`1(IDataProvider`1<IEnumerable`1<T>> source);
    protected abstract virtual IEnumerable`1<T> get_Value();
    protected void RaiseCollectionChanged(NotifyCollectionChangedEventArgs args);
    public sealed virtual void add_CollectionChanged(NotifyCollectionChangedEventHandler value);
    public sealed virtual void remove_CollectionChanged(NotifyCollectionChangedEventHandler value);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [CompilerGeneratedAttribute]
private static void <.ctor>b__0(DataCollectionNotifier`1<T> s, IEnumerable`1<T> v);
}
internal class JetBrains.Common.Util.DataPipes.Impl.Collections.DataCollectionResetNotifier`1 : DataCollectionNotifier`1<T> {
    private IEnumerable`1<T> myValue;
    protected IEnumerable`1<T> Value { get; }
    public DataCollectionResetNotifier`1(IDataProvider`1<IEnumerable`1<T>> source);
    protected virtual IEnumerable`1<T> get_Value();
    protected virtual void OnSourceUpdated(IEnumerable`1<T> newValue);
}
public class JetBrains.Common.Util.DataPipes.Impl.ConstDataNotifier`1 : object {
    private T myValue;
    private PropertyChangedEventHandler PropertyChanged;
    public object UntypedValue { get; }
    public T Value { get; }
    public ConstDataNotifier`1(T value);
    public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    public sealed virtual object get_UntypedValue();
    public sealed virtual T get_Value();
}
internal class JetBrains.Common.Util.DataPipes.Impl.ConstDataProvider`1 : object {
    private T myValue;
    public IAsyncController Controller { get; }
    public IDataProviderInternal[] Sources { get; }
    public bool HasValue { get; }
    public T Value { get; }
    public ConstDataProvider`1(T value);
    public sealed virtual T GetValue();
    public virtual IAsyncController get_Controller();
    public virtual IDataProvider`1<IEnumerable`1<ProgressProvider>> GetProgressProvider();
    public sealed virtual void add_Cancel(Action`1<ICancelArgs> value);
    public sealed virtual void remove_Cancel(Action`1<ICancelArgs> value);
    public sealed virtual IDataProviderInternal[] get_Sources();
    public sealed virtual bool get_HasValue();
    public sealed virtual IDataProvider`1<TOut> TransformToDefault();
    public virtual bool Subscribe(ValueUpdatedHandler`1<T> handler);
    public sealed virtual void Unsubscribe(ValueUpdatedHandler`1<T> handler);
    public sealed virtual T get_Value();
    [CompilerGeneratedAttribute]
private static TOut <TransformToDefault>b__0(T _);
}
internal class JetBrains.Common.Util.DataPipes.Impl.ControlledDataProviderWithSource`2 : DataProviderWithSource`2<TA, TB> {
    [NotNullAttribute]
private Action`2<TA, ITransformController`1<TB>> mySourceUpdateController;
    [CompilerGeneratedAttribute]
private TB <LastSuccessfulValue>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsUpdateCausedByActivation>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasLastSuccessfulValue>k__BackingField;
    public TB LastSuccessfulValue { get; private set; }
    public bool IsUpdateCausedByActivation { get; private set; }
    public bool HasLastSuccessfulValue { get; private set; }
    public ControlledDataProviderWithSource`2(IDataProvider`1<TA> source, Action`2<TA, ITransformController`1<TB>> sourceUpdateController, TB initValue);
    protected virtual bool OnActivated();
    public virtual void add_Cancel(Action`1<ICancelArgs> value);
    public virtual void remove_Cancel(Action`1<ICancelArgs> value);
    protected virtual void OnDeactivated();
    protected virtual void UpdateValueFromSources();
    protected virtual void OnSourceUpdated(TA newValue);
    [CompilerGeneratedAttribute]
public sealed virtual TB get_LastSuccessfulValue();
    [CompilerGeneratedAttribute]
private void set_LastSuccessfulValue(TB value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsUpdateCausedByActivation();
    [CompilerGeneratedAttribute]
private void set_IsUpdateCausedByActivation(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_HasLastSuccessfulValue();
    [CompilerGeneratedAttribute]
private void set_HasLastSuccessfulValue(bool value);
    public sealed virtual void RaiseChanged();
    public sealed virtual void RaiseChanged(TB value);
}
internal class JetBrains.Common.Util.DataPipes.Impl.DataController`1 : DataProvider`1<T> {
    private IEqualityComparer`1<T> myComparer;
    public bool HasValue { get; }
    public T Value { get; public set; }
    public DataController`1(T initialValue, IEqualityComparer`1<T> comparer);
    protected virtual void OnDeactivated();
    public virtual bool get_HasValue();
    public virtual T get_Value();
    public virtual void set_Value(T value);
    public sealed virtual void RaiseChanged();
    public sealed virtual void RaiseChanged(T value);
    public sealed virtual void Raise();
}
internal class JetBrains.Common.Util.DataPipes.Impl.DataConverter`2 : DataProviderWithSource`2<TA, TB> {
    private Func`2<TA, TB> myConverter;
    public DataConverter`2(Func`2<TA, TB> converter, IDataProvider`1<TA> source);
    protected virtual void OnSourceUpdated(TA newValue);
}
internal class JetBrains.Common.Util.DataPipes.Impl.DataConverterWithLifetime`2 : DataProviderWithSource`2<TA, TB> {
    private Func`3<Lifetime, TA, TB> myConverter;
    private SequentialLifetimes myLifetimeRow;
    public DataConverterWithLifetime`2(Lifetime parentLifetime, Func`3<Lifetime, TA, TB> converter, IDataProvider`1<TA> source);
    protected virtual void OnSourceUpdated(TA newValue);
    protected virtual void OnDeactivated();
}
internal class JetBrains.Common.Util.DataPipes.Impl.DataEvent`1 : DataProvider`1<PipeEventData`1<T>> {
    public bool HasValue { get; }
    public sealed virtual void Fire(T data);
    public virtual bool get_HasValue();
}
internal class JetBrains.Common.Util.DataPipes.Impl.DataMixer2`3 : DataProvider`1<TC> {
    private Func`3<TA, TB, TC> myConverter;
    private IDataProviderInternal`1<TA> mySource1;
    private IDataProviderInternal`1<TB> mySource2;
    public IDataProviderInternal[] Sources { get; }
    public bool HasValue { get; }
    public IAsyncController Controller { get; }
    public DataMixer2`3(IDataProvider`1<TA> source1, IDataProvider`1<TB> source2, Func`3<TA, TB, TC> converter);
    public virtual IDataProviderInternal[] get_Sources();
    public virtual bool get_HasValue();
    public virtual void add_Cancel(Action`1<ICancelArgs> value);
    public virtual void remove_Cancel(Action`1<ICancelArgs> value);
    public virtual IDataProvider`1<IEnumerable`1<ProgressProvider>> GetProgressProvider();
    public virtual IAsyncController get_Controller();
    protected virtual void UpdateValueFromSources();
    protected virtual bool OnActivated();
    protected virtual void OnDeactivated();
    protected virtual void OnSource2Updated(TB newValue);
    protected virtual void OnSource1Updated(TA newValue);
}
internal class JetBrains.Common.Util.DataPipes.Impl.DataMixer3`4 : DataProvider`1<TD> {
    private Func`4<TA, TB, TC, TD> myConverter;
    private IDataProviderInternal`1<TC> mySource3;
    private IDataProviderInternal`1<TB> mySource2;
    private IDataProviderInternal`1<TA> mySource1;
    public IDataProviderInternal[] Sources { get; }
    public bool HasValue { get; }
    public IAsyncController Controller { get; }
    public DataMixer3`4(IDataProvider`1<TA> source1, IDataProvider`1<TB> source2, IDataProvider`1<TC> source3, Func`4<TA, TB, TC, TD> converter);
    public virtual IDataProviderInternal[] get_Sources();
    public virtual bool get_HasValue();
    public virtual void add_Cancel(Action`1<ICancelArgs> value);
    public virtual void remove_Cancel(Action`1<ICancelArgs> value);
    public virtual IDataProvider`1<IEnumerable`1<ProgressProvider>> GetProgressProvider();
    public virtual IAsyncController get_Controller();
    protected virtual void UpdateValueFromSources();
    protected virtual bool OnActivated();
    protected virtual void OnDeactivated();
    private void OnSource1Updated(TA newValue);
    private void OnSource2Updated(TB newValue);
    private void OnSource3Updated(TC newValue);
}
internal class JetBrains.Common.Util.DataPipes.Impl.DataMixer4`5 : DataProvider`1<TE> {
    private Func`5<TA, TB, TC, TD, TE> myConverter;
    private IDataProviderInternal`1<TA> mySource1;
    private IDataProviderInternal`1<TB> mySource2;
    private IDataProviderInternal`1<TC> mySource3;
    private IDataProviderInternal`1<TD> mySource4;
    public IDataProviderInternal[] Sources { get; }
    public bool HasValue { get; }
    public IAsyncController Controller { get; }
    public DataMixer4`5(IDataProvider`1<TA> source1, IDataProvider`1<TB> source2, IDataProvider`1<TC> source3, IDataProvider`1<TD> source4, Func`5<TA, TB, TC, TD, TE> converter);
    public virtual IDataProviderInternal[] get_Sources();
    public virtual bool get_HasValue();
    public virtual void add_Cancel(Action`1<ICancelArgs> value);
    public virtual void remove_Cancel(Action`1<ICancelArgs> value);
    public virtual IDataProvider`1<IEnumerable`1<ProgressProvider>> GetProgressProvider();
    public virtual IAsyncController get_Controller();
    protected virtual void UpdateValueFromSources();
    protected virtual bool OnActivated();
    private void OnSource4Updated(TD newvalue);
    protected virtual void OnDeactivated();
    private void OnSource1Updated(TA newValue);
    private void OnSource2Updated(TB newValue);
    private void OnSource3Updated(TC newValue);
}
internal class JetBrains.Common.Util.DataPipes.Impl.DataMixer5`6 : DataProvider`1<TF> {
    private Func`6<TA, TB, TC, TD, TE, TF> myConverter;
    private IDataProviderInternal`1<TA> mySource1;
    private IDataProviderInternal`1<TB> mySource2;
    private IDataProviderInternal`1<TC> mySource3;
    private IDataProviderInternal`1<TD> mySource4;
    private IDataProviderInternal`1<TE> mySource5;
    public IDataProviderInternal[] Sources { get; }
    public bool HasValue { get; }
    public IAsyncController Controller { get; }
    public DataMixer5`6(IDataProvider`1<TA> source1, IDataProvider`1<TB> source2, IDataProvider`1<TC> source3, IDataProvider`1<TD> source4, IDataProvider`1<TE> source5, Func`6<TA, TB, TC, TD, TE, TF> converter);
    public virtual IDataProviderInternal[] get_Sources();
    public virtual bool get_HasValue();
    public virtual void add_Cancel(Action`1<ICancelArgs> value);
    public virtual void remove_Cancel(Action`1<ICancelArgs> value);
    public virtual IDataProvider`1<IEnumerable`1<ProgressProvider>> GetProgressProvider();
    public virtual IAsyncController get_Controller();
    protected virtual void UpdateValueFromSources();
    protected virtual bool OnActivated();
    private void OnSource4Updated(TD newvalue);
    private void OnSource5Updated(TE newvalue);
    protected virtual void OnDeactivated();
    private void OnSource1Updated(TA newValue);
    private void OnSource2Updated(TB newValue);
    private void OnSource3Updated(TC newValue);
}
internal class JetBrains.Common.Util.DataPipes.Impl.DataMixer6`7 : DataProvider`1<TJ> {
    private Func`7<TA, TB, TC, TD, TE, TF, TJ> myConverter;
    private IDataProviderInternal`1<TA> mySource1;
    private IDataProviderInternal`1<TB> mySource2;
    private IDataProviderInternal`1<TC> mySource3;
    private IDataProviderInternal`1<TD> mySource4;
    private IDataProviderInternal`1<TE> mySource5;
    private IDataProviderInternal`1<TF> mySource6;
    public IDataProviderInternal[] Sources { get; }
    public bool HasValue { get; }
    public IAsyncController Controller { get; }
    public DataMixer6`7(IDataProvider`1<TA> source1, IDataProvider`1<TB> source2, IDataProvider`1<TC> source3, IDataProvider`1<TD> source4, IDataProvider`1<TE> source5, IDataProvider`1<TF> source6, Func`7<TA, TB, TC, TD, TE, TF, TJ> converter);
    public virtual IDataProviderInternal[] get_Sources();
    public virtual bool get_HasValue();
    public virtual void add_Cancel(Action`1<ICancelArgs> value);
    public virtual void remove_Cancel(Action`1<ICancelArgs> value);
    public virtual IDataProvider`1<IEnumerable`1<ProgressProvider>> GetProgressProvider();
    public virtual IAsyncController get_Controller();
    protected virtual void UpdateValueFromSources();
    protected virtual bool OnActivated();
    private void OnSource4Updated(TD newvalue);
    private void OnSource5Updated(TE newvalue);
    private void OnSource6Updated(TF newvalue);
    protected virtual void OnDeactivated();
    private void OnSource1Updated(TA newValue);
    private void OnSource2Updated(TB newValue);
    private void OnSource3Updated(TC newValue);
}
internal class JetBrains.Common.Util.DataPipes.Impl.DataMixerAsync2`3 : DataProvider`1<TC> {
    private Func`3<TA, TB, TC> myConverter;
    private IDataProviderInternal`1<TA> mySource1;
    private IDataProviderInternal`1<TB> mySource2;
    private IAsyncController myController;
    private Action`1<ICancelArgs> myCancel;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) myIsPartialUpdateRequested;
    private int myState;
    public IAsyncController Controller { get; }
    public bool HasValue { get; }
    public ILightExecutionController ExecutionController { get; }
    public IAsyncController Parent { get; }
    public DataMixerAsync2`3(IAsyncDataProvider`1<TA> source1, IDataProvider`1<TB> source2, Func`3<TA, TB, TC> converter);
    public virtual IAsyncController get_Controller();
    public virtual bool get_HasValue();
    public virtual IDataProvider`1<IEnumerable`1<ProgressProvider>> GetProgressProvider();
    protected virtual void UpdateValueFromSources();
    public virtual void add_Cancel(Action`1<ICancelArgs> value);
    public virtual void remove_Cancel(Action`1<ICancelArgs> value);
    private void OnCancel(ICancelArgs args);
    protected virtual bool OnActivated();
    protected virtual void OnDeactivated();
    private void OnSource2Updated(TB newValue);
    private void PartialUpdate();
    private void OnSource1Updated(TA newValue);
    public sealed virtual ILightExecutionController get_ExecutionController();
    public sealed virtual void Request(Action task);
    public sealed virtual void AttachTask(ITask task, int parentStepsCount, bool isShared);
    public sealed virtual void WaitForTask(ITask task, int parentStepsCount, bool isShared);
    public sealed virtual void Yield();
    public sealed virtual IAsyncController get_Parent();
}
internal class JetBrains.Common.Util.DataPipes.Impl.DataMixerN`2 : DataProvider`1<TB> {
    private IDataProviderInternal`1[] mySources;
    private Func`2<TA[], TB> myConverter;
    private TA[] mySourceValues;
    [CompilerGeneratedAttribute]
private static Func`2<IDataProviderInternal`1<TA>, IDataProvider`1<IEnumerable`1<ProgressProvider>>> CS$<>9__CachedAnonymousMethodDelegate3;
    [CompilerGeneratedAttribute]
private static Func`2<IEnumerable`1[], IEnumerable`1<ProgressProvider>> CS$<>9__CachedAnonymousMethodDelegate4;
    [CompilerGeneratedAttribute]
private static Func`2<IEnumerable`1<ProgressProvider>, IEnumerable`1<ProgressProvider>> CS$<>9__CachedAnonymousMethodDelegate5;
    [CompilerGeneratedAttribute]
private static Func`2<IDataProviderInternal`1<TA>, bool> CS$<>9__CachedAnonymousMethodDelegate7;
    public IDataProviderInternal[] Sources { get; }
    public bool HasValue { get; }
    public IAsyncController Controller { get; }
    public DataMixerN`2(Func`2<TA[], TB> converter, IEnumerable`1<IDataProviderBase`1<TA>> providers);
    public virtual IDataProvider`1<IEnumerable`1<ProgressProvider>> GetProgressProvider();
    public virtual IDataProviderInternal[] get_Sources();
    public virtual bool get_HasValue();
    public virtual IAsyncController get_Controller();
    protected virtual bool OnActivated();
    private void SourceOnUpdated(TA newValue);
    protected virtual void UpdateValueFromSources();
    protected virtual void OnDeactivated();
    [CompilerGeneratedAttribute]
private static IDataProvider`1<IEnumerable`1<ProgressProvider>> <GetProgressProvider>b__0(IDataProviderInternal`1<TA> s);
    [CompilerGeneratedAttribute]
private static IEnumerable`1<ProgressProvider> <GetProgressProvider>b__1(IEnumerable`1[] a);
    [CompilerGeneratedAttribute]
private static IEnumerable`1<ProgressProvider> <GetProgressProvider>b__2(IEnumerable`1<ProgressProvider> _);
    [CompilerGeneratedAttribute]
private static bool <get_HasValue>b__6(IDataProviderInternal`1<TA> v);
    [CompilerGeneratedAttribute]
private bool <OnActivated>b__8(bool current, IDataProviderInternal`1<TA> s);
}
[DefaultMemberAttribute("Item")]
internal class JetBrains.Common.Util.DataPipes.Impl.DataNotifier`1 : ActivateableWithActivationController {
    private Action`1<T> mySetValueCallback;
    private bool myValidateSetValue;
    private T myValue;
    private PropertyChangedEventHandler myPropertyChanged;
    [CompilerGeneratedAttribute]
private string <Error>k__BackingField;
    public object UntypedValue { get; }
    public T Value { get; public set; }
    public string Item { get; }
    public string Error { get; private set; }
    public DataNotifier`1(IDataProvider`1<T> provider, Action`1<T> setValueCallback, IDataProvider`1<string> error, bool validateSetValue);
    private void OnErrorUpdated(string error);
    private void OnPropertyChanged();
    protected void OnSourceUpdated(T value);
    public sealed virtual object get_UntypedValue();
    public sealed virtual T get_Value();
    public sealed virtual void set_Value(T value);
    private void add_myPropertyChanged(PropertyChangedEventHandler value);
    private void remove_myPropertyChanged(PropertyChangedEventHandler value);
    public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    public sealed virtual string get_Item(string columnName);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Error();
    [CompilerGeneratedAttribute]
private void set_Error(string value);
    public virtual string ToString();
}
internal abstract class JetBrains.Common.Util.DataPipes.Impl.DataProvider`1 : DataProviderBase {
    private T myValue;
    private HandlerListNode modreq(System.Runtime.CompilerServices.IsVolatile) myHandlers;
    public IAsyncController Controller { get; }
    protected bool IsAsync { get; }
    public IDataProviderInternal[] Sources { get; }
    public bool HasValue { get; }
    public T Value { get; }
    protected bool IsActivated { get; }
    public DataProvider`1(T initialValue);
    public virtual IAsyncController get_Controller();
    protected bool get_IsAsync();
    public virtual IDataProvider`1<IEnumerable`1<ProgressProvider>> GetProgressProvider();
    public virtual void add_Cancel(Action`1<ICancelArgs> value);
    public virtual void remove_Cancel(Action`1<ICancelArgs> value);
    public virtual IDataProviderInternal[] get_Sources();
    public abstract virtual bool get_HasValue();
    public sealed virtual IDataProvider`1<TOut> TransformToDefault();
    public sealed virtual bool Subscribe(ValueUpdatedHandler`1<T> handler);
    public sealed virtual void Unsubscribe(ValueUpdatedHandler`1<T> handler);
    public sealed virtual T get_Value();
    public sealed virtual T GetValue();
    protected void RaiseUpdated();
    protected bool get_IsActivated();
    protected virtual void UpdateValueFromSources();
    private void RemoveHandler(ValueUpdatedHandler`1<T> handler);
    protected void UnsubscribeAllHandlers();
    protected virtual bool CheckBeforeAddHandler();
    protected virtual void OnDeactivated();
    protected virtual bool OnActivated();
    protected virtual void UpdateValue(T newValue);
    [CompilerGeneratedAttribute]
private static TOut <TransformToDefault>b__0(T _);
}
internal abstract class JetBrains.Common.Util.DataPipes.Impl.DataProviderBase : object {
}
internal class JetBrains.Common.Util.DataPipes.Impl.DataProviderCommand`1 : ActivateableWithWeakSubscriptionAndActivationController`1<T> {
    private Predicate`1<T> myCanExecute;
    private Action`1<T> myExecute;
    private T myValue;
    private EventHandler myCanExecuteChanged;
    public DataProviderCommand`1(IDataProvider`1<T> source, Predicate`1<T> canExecute, Action`1<T> execute);
    public sealed virtual void Execute(object parameter);
    public sealed virtual bool CanExecute(object parameter);
    private void add_myCanExecuteChanged(EventHandler value);
    private void remove_myCanExecuteChanged(EventHandler value);
    public sealed virtual void add_CanExecuteChanged(EventHandler value);
    public sealed virtual void remove_CanExecuteChanged(EventHandler value);
    protected virtual void OnSourceUpdated(T value);
}
internal class JetBrains.Common.Util.DataPipes.Impl.DataProviderWithHasValue`1 : DataProviderWithSource`2<T, Initializable`1<T>> {
    private bool myIsInitialized;
    public bool HasValue { get; }
    public DataProviderWithHasValue`1(IDataProvider`1<T> source);
    protected virtual bool OnActivated();
    protected virtual void OnDeactivated();
    public virtual bool get_HasValue();
    protected virtual void UpdateValueFromSources();
    protected virtual void OnSourceUpdated(T newValue);
    private void FireUpdateValue(T newValue);
}
internal abstract class JetBrains.Common.Util.DataPipes.Impl.DataProviderWithSingleSubscription`2 : DataProviderWithSource`2<TA, TB> {
    protected DataProviderWithSingleSubscription`2(IDataProvider`1<TA> source);
    protected virtual bool CheckBeforeAddHandler();
}
internal abstract class JetBrains.Common.Util.DataPipes.Impl.DataProviderWithSource`2 : DataProvider`1<TB> {
    private IDataProviderInternal`1<TA> mySource;
    public IDataProviderInternal[] Sources { get; }
    public bool HasValue { get; }
    protected IDataProviderInternal`1<TA> Source { get; }
    public IAsyncController Controller { get; }
    protected DataProviderWithSource`2(IDataProvider`1<TA> source);
    public virtual IDataProviderInternal[] get_Sources();
    public virtual IDataProvider`1<IEnumerable`1<ProgressProvider>> GetProgressProvider();
    public virtual void add_Cancel(Action`1<ICancelArgs> value);
    public virtual void remove_Cancel(Action`1<ICancelArgs> value);
    public virtual bool get_HasValue();
    protected IDataProviderInternal`1<TA> get_Source();
    public virtual IAsyncController get_Controller();
    protected virtual bool OnActivated();
    protected virtual void UpdateValueFromSources();
    protected virtual void OnDeactivated();
    protected abstract virtual void OnSourceUpdated(TA newValue);
}
internal class JetBrains.Common.Util.DataPipes.Impl.DataSink`1 : DataSubscriptionBase`1<T> {
    private T myValue;
    public T Value { get; }
    private bool JetBrains.Common.Util.DataPipes.IDataSink<T>.IsActive { get; }
    public IDataProvider`1<T> Provider { get; }
    protected ValueUpdatedHandler`1<T> Handler { get; }
    protected bool InvokeHandlerOnActivation { get; }
    public DataSink`1(IDataProviderBase`1<T> source);
    public sealed virtual T get_Value();
    protected virtual void OnDeactivated();
    private sealed virtual override bool JetBrains.Common.Util.DataPipes.IDataSink<T>.get_IsActive();
    public sealed virtual IDataProvider`1<T> get_Provider();
    private void OnUpdated(T value);
    protected virtual ValueUpdatedHandler`1<T> get_Handler();
    protected virtual bool get_InvokeHandlerOnActivation();
}
internal class JetBrains.Common.Util.DataPipes.Impl.DataSubscription`1 : DataSubscriptionBase`1<T> {
    private ValueUpdatedHandler`1<T> myHandler;
    private bool myInitInvoke;
    protected ValueUpdatedHandler`1<T> Handler { get; }
    protected bool InvokeHandlerOnActivation { get; }
    public DataSubscription`1(ValueUpdatedHandler`1<T> handler, IDataProviderBase`1<T> source, bool initInvoke);
    protected virtual ValueUpdatedHandler`1<T> get_Handler();
    protected virtual bool get_InvokeHandlerOnActivation();
}
public abstract class JetBrains.Common.Util.DataPipes.Impl.DataSubscriptionBase`1 : Activateable {
    private IDataProviderInternal`1<T> mySource;
    private Dispatcher myDispatcher;
    [ThreadSafetyAttribute("2")]
public bool IsActive { get; public set; }
    protected IDataProvider`1<T> Source { get; }
    protected ValueUpdatedHandler`1<T> Handler { get; }
    protected bool InvokeHandlerOnActivation { get; }
    protected DataSubscriptionBase`1(IDataProviderBase`1<T> source);
    public bool get_IsActive();
    public sealed virtual void set_IsActive(bool value);
    private void OnSetIsActive(bool value);
    protected IDataProvider`1<T> get_Source();
    protected abstract virtual ValueUpdatedHandler`1<T> get_Handler();
    protected abstract virtual bool get_InvokeHandlerOnActivation();
    protected virtual void OnActivated();
    protected virtual void OnDeactivated();
}
internal class JetBrains.Common.Util.DataPipes.Impl.DelayedActionsManager : object {
    [ThreadStaticAttribute]
private static DelayedActionsManager ourManager;
    private IList`1<Action> myDelayedActions;
    private int myDepth;
    private static DelayedActionsManager Instance { get; }
    public static void Enqueue(Action action);
    private void AddAction(Action action);
    public static void OnBeforeSubscription();
    public static void OnAfterSubscription();
    private void IncrementDepth();
    private void DecrementDepth();
    private static DelayedActionsManager get_Instance();
}
public class JetBrains.Common.Util.DataPipes.Impl.DelegatedTwoStepDisposable : object {
    private Action myPrepare;
    private Action myDispose;
    public DelegatedTwoStepDisposable(Action prepare, Action dispose);
    public sealed virtual void PrepareForDispose();
    public sealed virtual void Dispose();
}
internal class JetBrains.Common.Util.DataPipes.Impl.DerivedAsyncDataController`1 : DataController`1<T> {
    private IAsyncController myController;
    public IAsyncController Controller { get; }
    public DerivedAsyncDataController`1(IAsyncController controller, T initialValue, IEqualityComparer`1<T> comparer);
    public virtual IAsyncController get_Controller();
}
internal class JetBrains.Common.Util.DataPipes.Impl.DispatcherDataProvider`1 : DataProviderWithSource`2<T, T> {
    private Dispatcher myDispatcher;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) myUpdateRequested;
    private bool myHasValue;
    private T myCalculatedValue;
    public IAsyncController Controller { get; }
    public bool HasValue { get; }
    public DispatcherDataProvider`1(IDataProviderBase`1<T> source, Dispatcher dispatcher);
    public virtual IAsyncController get_Controller();
    protected virtual bool OnActivated();
    public virtual bool get_HasValue();
    protected virtual void OnDeactivated();
    protected virtual void UpdateValueFromSources();
    private void DoUpdate();
    protected virtual void OnSourceUpdated(T newValue);
}
public class JetBrains.Common.Util.DataPipes.Impl.DoubleBuffer`2 : object {
    private SlotData[] mySlots;
    private int myReadySlot;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) myReadyFlag;
    private object myLock;
    private TimeSpan myTimeout;
    private int BufferSlot { get; }
    public DoubleBuffer`2(TimeSpan timeout, Func`1<TContainer> createContainer);
    public DoubleBuffer`2(TContainer primary, TContainer secondary, TimeSpan timeout);
    public sealed virtual TContainer LockBufferForWriting();
    public sealed virtual void ReleaseBufferCancel();
    private int get_BufferSlot();
    public sealed virtual void ReleaseBufferReady(TValue value);
    public sealed virtual TValue GrabValue();
}
internal class JetBrains.Common.Util.DataPipes.Impl.DoubleBufferRecyclingProvider`3 : DataProviderWithSingleSubscription`2<TSource, Getter`1<TValue>> {
    private Func`3<TSource, TContainer, TValue> myFillAction;
    private IDoubleBuffer`2<TContainer, TValue> myBuffer;
    public DoubleBufferRecyclingProvider`3(IDataProviderBase`1<TSource> source, Func`1<TContainer> createContainer, Func`3<TSource, TContainer, TValue> fillAction, TimeSpan timeout);
    protected virtual void OnSourceUpdated(TSource newValue);
}
internal class JetBrains.Common.Util.DataPipes.Impl.ExternalExecutorDataProvider`1 : DataProviderWithSource`2<T, T> {
    private Action`2<Action`1<T>, T> myExecutor;
    public IAsyncController Controller { get; }
    public ExternalExecutorDataProvider`1(IDataProvider`1<T> source, Action`2<Action`1<T>, T> executor);
    protected virtual void OnSourceUpdated(T newValue);
    public virtual IAsyncController get_Controller();
}
internal class JetBrains.Common.Util.DataPipes.Impl.FilteringDataProvider`1 : FilteringDataProviderBase`1<T> {
    private Func`2<T, bool> myFilter;
    public FilteringDataProvider`1(Func`2<T, bool> filter, IDataProvider`1<T> source);
    protected virtual bool AcceptNewValue(T newValue);
}
internal abstract class JetBrains.Common.Util.DataPipes.Impl.FilteringDataProviderBase`1 : DataProviderWithSource`2<T, T> {
    private bool myHasValue;
    private Action`1<ICancelArgs> myCancel;
    public bool HasValue { get; }
    protected FilteringDataProviderBase`1(IDataProvider`1<T> source);
    public virtual bool get_HasValue();
    public virtual void add_Cancel(Action`1<ICancelArgs> value);
    public virtual void remove_Cancel(Action`1<ICancelArgs> value);
    protected virtual bool OnActivated();
    private void OnSourceCancel(ICancelArgs args);
    protected virtual void OnDeactivated();
    protected abstract virtual bool AcceptNewValue(T newValue);
    protected virtual void OnSourceUpdated(T newValue);
}
internal class JetBrains.Common.Util.DataPipes.Impl.FilteringWithPrevDataProvider`1 : FilteringDataProviderBase`1<T> {
    private AcceptNewValue`1<T> myFilter;
    public FilteringWithPrevDataProvider`1(IDataProvider`1<T> source, AcceptNewValue`1<T> filter);
    protected virtual bool AcceptNewValue(T newValue);
}
internal class JetBrains.Common.Util.DataPipes.Impl.GetterThreadSwitch`1 : object {
    [CompilerGeneratedAttribute]
private IDataProviderInternal`1<Getter`1<T>> <GetterProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsStream>k__BackingField;
    public IDataProviderInternal`1<Getter`1<T>> GetterProvider { get; private set; }
    public IDataProviderInternal`1<T> ValueProvider { get; }
    public bool IsStream { get; private set; }
    public GetterThreadSwitch`1(IDataProviderInternal`1<Getter`1<T>> getterProvider, bool isStream);
    [CompilerGeneratedAttribute]
public sealed virtual IDataProviderInternal`1<Getter`1<T>> get_GetterProvider();
    [CompilerGeneratedAttribute]
private void set_GetterProvider(IDataProviderInternal`1<Getter`1<T>> value);
    public sealed virtual IDataProviderInternal`1<T> get_ValueProvider();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsStream();
    [CompilerGeneratedAttribute]
private void set_IsStream(bool value);
}
internal class JetBrains.Common.Util.DataPipes.Impl.GroupingToken : object {
    public IDataSignalBase UpdateFinished;
    [CompilerGeneratedAttribute]
private bool <IsUpdateStarted>k__BackingField;
    public bool IsUpdateStarted { get; public set; }
    public GroupingToken(IDataSignalBase updateFinished);
    [CompilerGeneratedAttribute]
public bool get_IsUpdateStarted();
    [CompilerGeneratedAttribute]
public void set_IsUpdateStarted(bool value);
}
internal interface JetBrains.Common.Util.DataPipes.Impl.IAsyncController {
    [ThreadSafetyAttribute("2")]
public ILightExecutionController ExecutionController { get; }
    public abstract virtual ILightExecutionController get_ExecutionController();
    [ThreadSafetyAttribute("2")]
public abstract virtual void Request(Action task);
}
internal interface JetBrains.Common.Util.DataPipes.Impl.ICancelArgs {
    public abstract virtual void ComputationWasCanceled();
}
internal interface JetBrains.Common.Util.DataPipes.Impl.IChildAsyncController {
    public IAsyncController Parent { get; }
    public abstract virtual IAsyncController get_Parent();
}
internal interface JetBrains.Common.Util.DataPipes.Impl.IDataProviderInternal {
    [CanBeNullAttribute]
public IAsyncController Controller { get; }
    public IDataProviderInternal[] Sources { get; }
    public bool HasValue { get; }
    public abstract virtual IAsyncController get_Controller();
    [CanBeNullAttribute]
public abstract virtual IDataProvider`1<IEnumerable`1<ProgressProvider>> GetProgressProvider();
    public abstract virtual void add_Cancel(Action`1<ICancelArgs> value);
    public abstract virtual void remove_Cancel(Action`1<ICancelArgs> value);
    public abstract virtual IDataProviderInternal[] get_Sources();
    public abstract virtual bool get_HasValue();
    public abstract virtual IDataProvider`1<TOut> TransformToDefault();
}
internal interface JetBrains.Common.Util.DataPipes.Impl.IDataProviderInternal`1 {
    [CanBeNullAttribute]
public T Value { get; }
    public abstract virtual bool Subscribe(ValueUpdatedHandler`1<T> handler);
    public abstract virtual void Unsubscribe(ValueUpdatedHandler`1<T> handler);
    public abstract virtual T get_Value();
}
internal interface JetBrains.Common.Util.DataPipes.Impl.IDataSubscription {
    unknown bool IsActive {public set; }
    public abstract virtual void set_IsActive(bool value);
}
public interface JetBrains.Common.Util.DataPipes.Impl.IDoubleBuffer`2 {
    public abstract virtual TContainer LockBufferForWriting();
    public abstract virtual void ReleaseBufferCancel();
    public abstract virtual void ReleaseBufferReady(TValue value);
    public abstract virtual TValue GrabValue();
}
internal interface JetBrains.Common.Util.DataPipes.Impl.IExecutionControllerInternal {
    public abstract virtual void AdvanceProgress(int steps);
}
internal class JetBrains.Common.Util.DataPipes.Impl.ImplicitlyAsyncDataController`1 : DataController`1<T> {
    private Action`1<Action> myPartialUpdateExecutor;
    private IDataProvider`1<IEnumerable`1<ProgressProvider>> myProgressProvider;
    private ActionEvent myCancelEvent;
    private IDataController`1<AsyncComputationState> myState;
    private Action`1<ICancelArgs> Cancel;
    public IAsyncController Controller { get; }
    public ILightExecutionController ExecutionController { get; }
    public ImplicitlyAsyncDataController`1(Action`1<Action> partialUpdateExecutor, T initialValue, IEqualityComparer`1<T> comparer, IDataProvider`1<IEnumerable`1<ProgressProvider>> progressProvider, ActionEvent cancelEvent);
    private void CancelEventOnEvent();
    protected virtual void UpdateValue(T newValue);
    protected virtual bool OnActivated();
    protected virtual void OnDeactivated();
    public virtual void add_Cancel(Action`1<ICancelArgs> value);
    public virtual void remove_Cancel(Action`1<ICancelArgs> value);
    public virtual IDataProvider`1<IEnumerable`1<ProgressProvider>> GetProgressProvider();
    public virtual IAsyncController get_Controller();
    public sealed virtual ILightExecutionController get_ExecutionController();
    public sealed virtual void Request(Action task);
}
internal class JetBrains.Common.Util.DataPipes.Impl.Initializable`1 : ValueType {
    public bool IsInitialized;
    public T Value;
}
internal interface JetBrains.Common.Util.DataPipes.Impl.IProgressDataProvider {
    public ProgressProvider Progress { get; }
    public abstract virtual ProgressProvider get_Progress();
}
internal interface JetBrains.Common.Util.DataPipes.Impl.IRemotableReferenceCore`1 {
}
internal interface JetBrains.Common.Util.DataPipes.Impl.IThreadSwitchInternal`1 {
    [CanBeNullAttribute]
public IDataProviderInternal`1<Getter`1<T>> GetterProvider { get; }
    [CanBeNullAttribute]
public IDataProviderInternal`1<T> ValueProvider { get; }
    public abstract virtual IDataProviderInternal`1<Getter`1<T>> get_GetterProvider();
    public abstract virtual IDataProviderInternal`1<T> get_ValueProvider();
}
internal interface JetBrains.Common.Util.DataPipes.Impl.ITripleBuffer`2 {
    public TContainer BackBuffer { get; }
    public abstract virtual TContainer get_BackBuffer();
    public abstract virtual void SetReady(TValue value);
    public abstract virtual TValue GrabValue();
}
internal class JetBrains.Common.Util.DataPipes.Impl.LifetimedDataProvider`1 : DataProviderWithSource`2<T, T> {
    private IDataController`1<bool> myIsLifetimeSubscriptionActive;
    private bool myIsTerminated;
    public LifetimedDataProvider`1(IDataProvider`1<T> source, DataPipeLifetime lifetime);
    protected virtual bool CheckBeforeAddHandler();
    protected virtual void OnDeactivated();
    protected virtual void OnSourceUpdated(T newValue);
    public sealed virtual void PrepareForDispose();
    public sealed virtual void Dispose();
}
internal class JetBrains.Common.Util.DataPipes.Impl.LocalReference`1 : object {
    [CompilerGeneratedAttribute]
private T <Value>k__BackingField;
    public T Value { get; public set; }
    public LocalReference`1(T value);
    [CompilerGeneratedAttribute]
public T get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(T value);
}
internal class JetBrains.Common.Util.DataPipes.Impl.PeriodicSignalProvider : DataProvider`1<TVoid> {
    private DispatcherTimer myTimer;
    private bool myHasValue;
    public bool HasValue { get; }
    public PeriodicSignalProvider(TimeSpan interval);
    public virtual bool get_HasValue();
    protected virtual void OnDeactivated();
    private void TimerOnTick(object sender, EventArgs eventArgs);
    protected virtual bool OnActivated();
}
public class JetBrains.Common.Util.DataPipes.Impl.PipesLogger : object {
    private ILogger myLogger;
    [ThreadStaticAttribute]
private static int myDepth;
    private LoggingLevel myLevel;
    public bool IsEnabled { get; }
    public PipesLogger(string category, LoggingLevel level);
    public void Begin(string message, Object[] args);
    public bool get_IsEnabled();
    public void Message(string message, Object[] args);
    public void End(string message, Object[] args);
}
internal class JetBrains.Common.Util.DataPipes.Impl.ProgressDataProvider`1 : DataProviderWithSource`2<T, T> {
    private string myDefaultTitle;
    private IDataController`1<double> myProgressValue;
    private IDataController`1<string> myTitle;
    private IDataController`1<AsyncComputationState> myState;
    private ProgressProvider myProgress;
    [NotNullAttribute]
private IAsyncController myAsyncController;
    [CompilerGeneratedAttribute]
private static Func`2<double, int> CS$<>9__CachedAnonymousMethodDelegate3;
    [CompilerGeneratedAttribute]
private static Func`3<int, AsyncComputationState, int> CS$<>9__CachedAnonymousMethodDelegate4;
    [CompilerGeneratedAttribute]
private static ValueUpdatedHandler`1<bool> CS$<>9__CachedAnonymousMethodDelegate5;
    public ProgressProvider Progress { get; }
    public ProgressDataProvider`1(IDataProviderInternal`1<T> source, string defaultTitle);
    protected virtual bool OnActivated();
    protected virtual void OnDeactivated();
    private void SourceOnCancel(ICancelArgs args);
    public IExecutionController OnExecutionStarted();
    public void OnExecutionCompleted();
    public virtual IDataProvider`1<IEnumerable`1<ProgressProvider>> GetProgressProvider();
    protected virtual void OnSourceUpdated(T newValue);
    public sealed virtual ProgressProvider get_Progress();
    [CompilerGeneratedAttribute]
private static int <.ctor>b__0(double step);
    [CompilerGeneratedAttribute]
private static int <.ctor>b__1(int val, AsyncComputationState state);
    [CompilerGeneratedAttribute]
private static void <.ctor>b__2(bool a);
    [CompilerGeneratedAttribute]
private IEnumerable`1<ProgressProvider> <GetProgressProvider>b__6(IEnumerable`1<ProgressProvider> e);
}
internal class JetBrains.Common.Util.DataPipes.Impl.ProgressIndicatorDataProvider : DataProviderWithSource`2<ProgressProvider, ProgressProvider> {
    private IDataController`1<IEnumerable`1<ProgressProvider>> myController;
    private ProgressProvider[] myReadyProvider;
    public ProgressIndicatorDataProvider(IDataProvider`1<ProgressProvider> source);
    public virtual IDataProvider`1<IEnumerable`1<ProgressProvider>> GetProgressProvider();
    protected virtual void OnSourceUpdated(ProgressProvider newValue);
}
internal class JetBrains.Common.Util.DataPipes.Impl.PropertyDataProvider`1 : DataProvider`1<T> {
    private IProperty`1<T> myProperty;
    private LifetimeDefinition mySubscriptionLifetime;
    public bool HasValue { get; }
    public PropertyDataProvider`1(IProperty`1<T> property);
    protected virtual bool OnActivated();
    public virtual bool get_HasValue();
    protected virtual void OnDeactivated();
    private void Handler(PropertyChangedEventArgs`1<T> args);
}
internal class JetBrains.Common.Util.DataPipes.Impl.ProxyDataProvider`1 : DataProvider`1<T> {
    private IDataProviderInternal`1<T> mySource;
    private Dispatcher myDispatcher;
    private bool myIsActivated;
    private IDataProxy`1<IEnumerable`1<ProgressProvider>> myProgressProvider;
    private Action`1<ICancelArgs> Cancel;
    private bool myIsAsync;
    private bool myHasValue;
    [CompilerGeneratedAttribute]
private static Func`2<TVoid, T> CS$<>9__CachedAnonymousMethodDelegate5;
    public IAsyncController Controller { get; }
    public IDataProviderInternal[] Sources { get; }
    public bool HasValue { get; }
    protected IDataProviderInternal`1<T> SourceInternal { get; protected set; }
    unknown IDataProvider`1<T> Source {public set; }
    unknown IDataSignal JetBrains.Common.Util.DataPipes.IDataSignalProxy.Source {private set; }
    unknown IAsyncDataProvider`1<T> JetBrains.Common.Util.DataPipes.ISetAsyncProvider<T>.Source {private set; }
    public ILightExecutionController ExecutionController { get; }
    public ProxyDataProvider`1(bool isAsync);
    public virtual void add_Cancel(Action`1<ICancelArgs> value);
    public virtual void remove_Cancel(Action`1<ICancelArgs> value);
    public virtual IAsyncController get_Controller();
    public virtual IDataProvider`1<IEnumerable`1<ProgressProvider>> GetProgressProvider();
    public virtual IDataProviderInternal[] get_Sources();
    public virtual bool get_HasValue();
    protected bool SetSource(IDataProviderInternal`1<T> provider, bool skipIfEquals);
    protected IDataProviderInternal`1<T> get_SourceInternal();
    protected void set_SourceInternal(IDataProviderInternal`1<T> value);
    public sealed virtual void set_Source(IDataProvider`1<T> value);
    private void OnCancel(ICancelArgs args);
    private void UpdateValueFromSource();
    protected virtual void UpdateValue(T newValue);
    protected virtual void UpdateValueFromSources();
    protected virtual bool OnActivated();
    private void SourceOnUpdated(T newValue);
    protected virtual void OnDeactivated();
    private sealed virtual override void JetBrains.Common.Util.DataPipes.IDataSignalProxy.set_Source(IDataSignal value);
    private sealed virtual override void JetBrains.Common.Util.DataPipes.ISetAsyncProvider<T>.set_Source(IAsyncDataProvider`1<T> value);
    public sealed virtual ILightExecutionController get_ExecutionController();
    public sealed virtual void Request(Action task);
    [CompilerGeneratedAttribute]
private static T <JetBrains.Common.Util.DataPipes.IDataSignalProxy.set_Source>b__4(TVoid _);
}
internal class JetBrains.Common.Util.DataPipes.Impl.SignalSyncDataProvider`1 : DataMixer2`3<TVoid, T, T> {
    private GroupingToken myToken;
    private bool myNeedUpdate;
    [CompilerGeneratedAttribute]
private static Func`3<TVoid, T, T> CS$<>9__CachedAnonymousMethodDelegate1;
    public SignalSyncDataProvider`1(GroupingToken token, IDataProvider`1<T> source);
    protected virtual void OnSource1Updated(TVoid newValue);
    protected virtual void OnSource2Updated(T newValue);
    [CompilerGeneratedAttribute]
private static T <.ctor>b__0(TVoid _, T v);
}
internal class JetBrains.Common.Util.DataPipes.Impl.ThreadSwitchEx`3 : object {
    private Func`1<TB> myCreateContainer;
    private Func`3<TA, TB, TC> myFillContainer;
    private IDataProviderBase`1<TA> mySource;
    private IDataProviderInternal`1<Getter`1<TC>> myGetterProvider;
    public IDataProviderInternal`1<Getter`1<TC>> GetterProvider { get; }
    public IDataProviderInternal`1<TC> ValueProvider { get; }
    public bool IsStream { get; }
    public ThreadSwitchEx`3(IDataProviderBase`1<TA> source, Func`1<TB> createContainer, Func`3<TA, TB, TC> fillContainer);
    public sealed virtual IDataProviderInternal`1<Getter`1<TC>> get_GetterProvider();
    public sealed virtual IDataProviderInternal`1<TC> get_ValueProvider();
    public sealed virtual bool get_IsStream();
    public sealed virtual IThreadSwitch`1<TC> LockFree();
    public sealed virtual IThreadSwitch`1<TC> WithTimeout(TimeSpan timeout);
    public sealed virtual IDataProviderBase`1<TC> ExtractProvider();
}
internal class JetBrains.Common.Util.DataPipes.Impl.ThreadSwitchProxy`1 : object {
    private IDataProxy`1<Getter`1<T>> myProxy;
    private bool myIsStream;
    public bool IsStream { get; }
    public IDataProviderInternal`1<Getter`1<T>> GetterProvider { get; }
    public IDataProviderInternal`1<T> ValueProvider { get; }
    unknown IThreadSwitch`1<T> Source {public set; }
    public ThreadSwitchProxy`1(bool isStream);
    public sealed virtual bool get_IsStream();
    public sealed virtual IDataProviderInternal`1<Getter`1<T>> get_GetterProvider();
    public sealed virtual IDataProviderInternal`1<T> get_ValueProvider();
    public sealed virtual void set_Source(IThreadSwitch`1<T> value);
}
internal class JetBrains.Common.Util.DataPipes.Impl.TimerDelayedDataProvider`1 : DataProviderWithSource`2<T, T> {
    private DispatcherTimer myTimer;
    private bool myHasValue;
    public bool HasValue { get; }
    public TimerDelayedDataProvider`1(IDataProvider`1<T> source, TimeSpan interval);
    public virtual bool get_HasValue();
    protected virtual void OnDeactivated();
    private void TimerOnTick(object sender, EventArgs eventArgs);
    private void StartTimer();
    protected virtual bool OnActivated();
    protected virtual void OnSourceUpdated(T newValue);
}
public class JetBrains.Common.Util.DataPipes.Impl.TripleBuffer`2 : object {
    private SlotData[] mySlots;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) myPointersState;
    public TContainer BackBuffer { get; }
    public TripleBuffer`2(Func`1<TContainer> createContainer);
    private static int GetBuffer(int state);
    private static int GetReady(int state);
    private static int GetOutput(int state);
    private static int GetReadyFlag(int state);
    private static int Set(int output, int ready, int buffer, int readyFlag);
    private static int SwapBufferReady(int state);
    private static int SwapReadyOutput(int state);
    public sealed virtual TContainer get_BackBuffer();
    public sealed virtual void SetReady(TValue value);
    public sealed virtual TValue GrabValue();
}
internal class JetBrains.Common.Util.DataPipes.Impl.TripleBufferRecyclingProvider`3 : DataProviderWithSingleSubscription`2<TSource, Getter`1<TValue>> {
    private Func`3<TSource, TContainer, TValue> myFillAction;
    private ITripleBuffer`2<TContainer, TValue> myBuffer;
    public TripleBufferRecyclingProvider`3(IDataProviderBase`1<TSource> sourceProvider, Func`1<TContainer> createContainer, Func`3<TSource, TContainer, TValue> fillAction);
    protected virtual void OnSourceUpdated(TSource newValue);
}
internal class JetBrains.Common.Util.DataPipes.Impl.ValueThreadSwitch`1 : object {
    [CompilerGeneratedAttribute]
private IDataProviderInternal`1<T> <ValueProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsStream>k__BackingField;
    public IDataProviderInternal`1<Getter`1<T>> GetterProvider { get; }
    public IDataProviderInternal`1<T> ValueProvider { get; private set; }
    public bool IsStream { get; private set; }
    public ValueThreadSwitch`1(IDataProviderInternal`1<T> valueProvider, bool isStream);
    public sealed virtual IDataProviderInternal`1<Getter`1<T>> get_GetterProvider();
    [CompilerGeneratedAttribute]
public sealed virtual IDataProviderInternal`1<T> get_ValueProvider();
    [CompilerGeneratedAttribute]
private void set_ValueProvider(IDataProviderInternal`1<T> value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsStream();
    [CompilerGeneratedAttribute]
private void set_IsStream(bool value);
}
[ExtensionAttribute]
internal static class JetBrains.Common.Util.DataPipes.Impl.WeakDelegateEx : object {
    [ExtensionAttribute]
public static ValueUpdatedHandler`1<TArg> CreateWeakHandler(T source, TArg _, Action`2<T, TArg> handler);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.DataPipes.InternalEx : object {
    [ExtensionAttribute]
internal static bool AreRunningOnTheSameThread(IDataProviderInternal`1<T1> t1, IDataProviderInternal`1<T2> t2);
    [ExtensionAttribute]
internal static IAsyncController GetRootController(IDataProviderInternal`1<T> provider);
    [ExtensionAttribute]
internal static ProgressDataProvider`1<T> AttachProgress(IAsyncDataProvider`1<T> provider, string title);
    [NotNullAttribute]
[ExtensionAttribute]
internal static IAsyncController GetAsyncController(IAsyncDataProvider`1<T> provider);
    [CanBeNullAttribute]
[ExtensionAttribute]
internal static IAsyncController TryGetAsyncController(IDataProviderBase`1<T> provider);
    [ExtensionAttribute]
[CanBeNullAttribute]
internal static ILightExecutionController TryGetExecutionController(IDataProviderInternal`1<T> provider);
    internal static IProgressDataProvider GetLastProgressDataProvider(IDataProviderInternal p);
    [ExtensionAttribute]
internal static ValueUpdatedHandler`1<T> AddCondition(ValueUpdatedHandler`1<T> handler, Func`2<T, bool> condition);
    [ExtensionAttribute]
internal static void Activate(IDataSubscription subscription, Lifetime lifetime);
    [ExtensionAttribute]
internal static void Activate(IDataSubscription subscription, IDataProvider`1<bool> isActive);
    [ExtensionAttribute]
internal static void Activate(IDataSubscription subscription);
    [ExtensionAttribute]
internal static IDataSubscription CreateSubscription(IDataProviderBase`1<T> source, LifetimedValueUpdatedHandler`1<T> handler, Func`2<T, bool> condition, bool initInvoke);
    [ExtensionAttribute]
internal static IDataSubscription CreateSubscription(IDataProviderBase`1<T> source, Lifetime lifetime, LifetimedValueUpdatedHandler`1<T> handler, Func`2<T, bool> condition, bool initInvoke);
    [ExtensionAttribute]
[CanBeNullAttribute]
internal static IDataSubscription CreateSubscription(IDataProviderBase`1<T> source, ValueUpdatedHandler`1<T> handler, bool initInvoke);
    [ExtensionAttribute]
internal static IDataProvider`1<T> CastToSync(IAsyncDataProvider`1<T> provider);
    [ExtensionAttribute]
internal static IDataSignal CastToSync(IAsyncDataSignal provider);
    [ExtensionAttribute]
public static IAsyncDataSignal CastToAsync(IDataSignal provider);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<T> CastToAsync(IDataProvider`1<T> provider);
    [ExtensionAttribute]
internal static IDataProvider`1<Initializable`1<T>> ForceUpdatesWhenNotInitialized(IDataProvider`1<T> provider);
}
public class JetBrains.Common.Util.DataPipes.Interpolator`1 : MulticastDelegate {
    public Interpolator`1(object object, IntPtr method);
    public virtual T Invoke(T start, T end, double percent);
    public virtual IAsyncResult BeginInvoke(T start, T end, double percent, AsyncCallback callback, object object);
    public virtual T EndInvoke(IAsyncResult result);
}
public interface JetBrains.Common.Util.DataPipes.ISetAsyncProvider`1 {
    unknown IAsyncDataProvider`1<T> Source {public set; }
    public abstract virtual void set_Source(IAsyncDataProvider`1<T> value);
}
public interface JetBrains.Common.Util.DataPipes.ISetProvider`1 {
    unknown IDataProvider`1<T> Source {public set; }
    public abstract virtual void set_Source(IDataProvider`1<T> value);
}
public interface JetBrains.Common.Util.DataPipes.ISetThreadSwitch`1 {
    unknown IThreadSwitch`1<T> Source {public set; }
    public abstract virtual void set_Source(IThreadSwitch`1<T> value);
}
public interface JetBrains.Common.Util.DataPipes.IThreadSwitch`1 {
    public bool IsStream { get; }
    public abstract virtual bool get_IsStream();
}
public interface JetBrains.Common.Util.DataPipes.IThreadSwitchEx`1 {
    public abstract virtual IThreadSwitch`1<T> LockFree();
    public abstract virtual IThreadSwitch`1<T> WithTimeout(TimeSpan timeout);
    public abstract virtual IDataProviderBase`1<T> ExtractProvider();
}
public interface JetBrains.Common.Util.DataPipes.IThreadSwitchProxy`1 {
}
public interface JetBrains.Common.Util.DataPipes.ITransformController`1 {
    public T LastSuccessfulValue { get; }
    public bool IsUpdateCausedByActivation { get; }
    public bool HasLastSuccessfulValue { get; }
    public abstract virtual T get_LastSuccessfulValue();
    public abstract virtual bool get_IsUpdateCausedByActivation();
    public abstract virtual bool get_HasLastSuccessfulValue();
    public abstract virtual void RaiseChanged();
    public abstract virtual void RaiseChanged(T value);
}
public interface JetBrains.Common.Util.DataPipes.IUntypedDataNotifier {
    public object UntypedValue { get; }
    public abstract virtual object get_UntypedValue();
}
public interface JetBrains.Common.Util.DataPipes.IWriteableDataNotifier`1 {
    public T Value { get; public set; }
    public abstract virtual T get_Value();
    public abstract virtual void set_Value(T value);
}
public class JetBrains.Common.Util.DataPipes.LifetimedValueUpdatedHandler`1 : MulticastDelegate {
    public LifetimedValueUpdatedHandler`1(object object, IntPtr method);
    public virtual void Invoke(Lifetime lifetime, T newValue);
    public virtual IAsyncResult BeginInvoke(Lifetime lifetime, T newValue, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.DataPipes.MiscEx : object {
    private static int ourLoggedProviderId;
    [CompilerGeneratedAttribute]
private static Func`2<Action, TVoid> CS$<>9__CachedAnonymousMethodDelegate5;
    [CompilerGeneratedAttribute]
private static Func`3<Action`1<IExecutionController>, IExecutionController, TVoid> CS$<>9__CachedAnonymousMethodDelegate7;
    [ExtensionAttribute]
public static bool HasValue(IDataProvider`1<TA> provider);
    [ExtensionAttribute]
public static IDataProvider`1<T> LogUpdates(IDataProvider`1<T> provider, string message);
    [ExtensionAttribute]
public static IDataProvider`1<T> Evaluate(IDataProvider`1<Getter`1<T>> provider);
    [ExtensionAttribute]
public static IDataProvider`1<TVoid> Execute(IDataProvider`1<Action> provider, Lifetime lifetime);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<TVoid> Execute(IAsyncDataProvider`1<Action`1<IExecutionController>> provider);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<T> Execute(IAsyncDataProvider`1<Func`2<IExecutionController, T>> provider);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<T> Evaluate(IAsyncDataProvider`1<GetterAsync`1<T>> provider);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<T> Evaluate(IAsyncDataProvider`1<Getter`1<T>> provider);
    [ExtensionAttribute]
public static DataPipe`2<TA, TB> MakePipe(IDataProxy`1<TA> input, Func`2<IDataProvider`1<TA>, IDataProvider`1<TB>> buildPipe);
    [ExtensionAttribute]
internal static IThreadSwitchInternal`1<T> ToInternal(IThreadSwitch`1<T> sw);
    [ExtensionAttribute]
public static IDataProviderBase`1<T> ExtractProvider(IThreadSwitch`1<T> provider);
    [ExtensionAttribute]
internal static IDataProvider`1<Getter`1<T>> GetGetter(IThreadSwitchInternal`1<T> sw);
    [ExtensionAttribute]
public static Getter`1<T> ToGetter(IDataSink`1<Getter`1<T>> sink);
    [ExtensionAttribute]
public static void TickWhile(DispatcherTimer timer, IDataProvider`1<bool> isActive, Action handler);
    [ExtensionAttribute]
public static IDataProvider`1<IEnumerable`1<T>> ToEnumerableWithSingleItem(IDataProvider`1<T> provider, bool reuseCollection);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<T> ControlActivation(IAsyncDataProvider`1<T> provider, IDataProvider`1<bool> activationController);
    [ExtensionAttribute]
public static IDataProvider`1<T> ControlActivation(IDataProvider`1<T> provider, IDataProvider`1<bool> activationController);
    [ExtensionAttribute]
public static IDataProvider`1<T> TrackBeforeUpdate(IDataProvider`1<T> source, ValueUpdatedHandler`1<T> beforeUpdate);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<T> TrackBeforeUpdate(IAsyncDataProvider`1<T> source, ValueUpdatedHandler`1<T> beforeUpdate);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<T> TrackAfterUpdate(IAsyncDataProvider`1<T> source, ValueUpdatedHandler`1<T> beforeUpdate);
    [ExtensionAttribute]
public static IDataProvider`1<T> TrackAfterUpdate(IDataProvider`1<T> source, ValueUpdatedHandler`1<T> afterUpdate);
    [ExtensionAttribute]
public static IThreadSwitch`1<T> TrackDeactivation(IThreadSwitch`1<T> source, Action onDeactivated);
    [ExtensionAttribute]
public static IThreadSwitch`1<T> TrackActivation(IThreadSwitch`1<T> source, ValueUpdatedHandler`1<bool> isActiveHandler);
    [ExtensionAttribute]
public static IThreadSwitch`1<T> TrackActivation(IThreadSwitch`1<T> source, ISetProvider`1<bool> setIsActive);
    [ExtensionAttribute]
public static IThreadSwitch`1<T> TrackBeforeUpdate(IThreadSwitch`1<T> source, Action onUpdated);
    [ExtensionAttribute]
public static IThreadSwitch`1<T> TrackActivation(IThreadSwitch`1<T> source, IDataProvider`1& isActive);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<T> TrackActivation(IAsyncDataProvider`1<T> source, ValueUpdatedHandler`1<bool> isActiveHandler);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<T> TrackActivation(IAsyncDataProvider`1<T> source, ISetProvider`1<bool> setIsActive);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<T> TrackActivation(IAsyncDataProvider`1<T> source, IDataProvider`1& isActive);
    [ExtensionAttribute]
public static IDataProvider`1<T> DeactivateSince(IDataProvider`1<T> source, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static IDataProvider`1<T> TrackDeactivation(IDataProvider`1<T> source, Action onDeactivated);
    [ExtensionAttribute]
public static IDataProvider`1<T> TrackActivation(IDataProvider`1<T> source, ValueUpdatedHandler`1<bool> isActiveHandler);
    [ExtensionAttribute]
public static IDataProvider`1<T> TrackActivation(IDataProvider`1<T> source, ISetProvider`1<bool> setIsActive);
    [ExtensionAttribute]
public static IDataProvider`1<T> TrackActivation(IDataProvider`1<T> source, IDataProvider`1& isActive);
    [ExtensionAttribute]
public static IDataProvider`1<T> EvaluateWithInvalidationTracking(IDataProvider`1<Getter`1<T>> source, Lifetime lifetime);
    [ExtensionAttribute]
public static IDataProvider`1<T> EvaluateAtThreadPoolWithInvalidationTracking(IDataProvider`1<GetterAsync`1<T>> source, DataPipeLifetime lifetime);
    [ExtensionAttribute]
public static IDataProvider`1<T> TrackInvalidationDuringDeactivation(IDataProvider`1<T> source, IDataSignal invalidate, Lifetime lifetime);
    [ExtensionAttribute]
public static IRemotableReference`1<T> CreateRemotableReference(T src);
    [NotNullAttribute]
[ExtensionAttribute]
public static IRemotableReference`1<T> BuildRemoteOrLocal(IRemoteCommunicator comm, Func`1<T> create);
    [ExtensionAttribute]
[NotNullAttribute]
public static IRemotableReference`1<T> CreateRemoteOrLocal(IRemoteCommunicator comm, T value);
    [ExtensionAttribute]
public static void SetValue(IDataController`1<Union`2<TA, TB>> controller, TA value);
    [ExtensionAttribute]
public static void SetValue(IDataController`1<Union`2<TA, TB>> controller, TB value);
    [ExtensionAttribute]
public static IDataProvider`1<T> Cast(IDataProvider`1<object> provider);
    [ExtensionAttribute]
public static IDataProvider`1<T> SafeCast(IDataProvider`1<object> provider);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<T> EnsureSingleThreaded(IAsyncDataProvider`1<T> p);
    [CompilerGeneratedAttribute]
private static T <Evaluate>b__3(Getter`1<T> f);
    [CompilerGeneratedAttribute]
private static TVoid <Execute>b__4(Action a);
    [CompilerGeneratedAttribute]
private static TVoid <Execute>b__6(Action`1<IExecutionController> a, IExecutionController e);
    [CompilerGeneratedAttribute]
private static T <Execute>b__8(Func`2<IExecutionController, T> a, IExecutionController e);
    [CompilerGeneratedAttribute]
private static T <Evaluate>b__9(GetterAsync`1<T> a, IExecutionController c);
    [CompilerGeneratedAttribute]
private static T <Evaluate>b__a(Getter`1<T> f);
    [CompilerGeneratedAttribute]
private static Getter`1<T> <GetGetter>b__b(T v);
    [CompilerGeneratedAttribute]
private static T[] <ToEnumerableWithSingleItem>b__15(T a);
    [CompilerGeneratedAttribute]
private static T <Cast>b__35(object v);
    [CompilerGeneratedAttribute]
private static T <SafeCast>b__36(object v);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.DataPipes.NullableEx : object {
    [ExtensionAttribute]
public static IDataProvider`1<T> NullToDefault(IDataProvider`1<Nullable`1<T>> provider);
    [ExtensionAttribute]
public static IDataProvider`1<bool> IsNull(IDataProvider`1<T> filter);
    [ExtensionAttribute]
public static IDataProvider`1<bool> IsNotNull(IDataProvider`1<T> src);
    [ExtensionAttribute]
public static IDataProvider`1<bool> IsNotNull(IDataProvider`1<Nullable`1<T>> src);
    [ExtensionAttribute]
public static IDataProvider`1<bool> IsNull(IDataProvider`1<Nullable`1<T>> src);
    [ExtensionAttribute]
public static IDataProvider`1<IEnumerable`1<TA>> WhereNotNull(IDataProvider`1<IEnumerable`1<TA>> provider);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<IEnumerable`1<TA>> WhereNotNull(IAsyncDataProvider`1<IEnumerable`1<TA>> provider);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<IEnumerable`1<TA>> WhereNotNull(IAsyncDataProvider`1<IEnumerable`1<Nullable`1<TA>>> provider);
    [ExtensionAttribute]
public static IDataProvider`1<IEnumerable`1<TA>> WhereNotNull(IDataProvider`1<IEnumerable`1<Nullable`1<TA>>> provider);
    [CompilerGeneratedAttribute]
private static T <NullToDefault>b__0(Nullable`1<T> a);
    [CompilerGeneratedAttribute]
private static bool <IsNull>b__1(T t);
    [CompilerGeneratedAttribute]
private static bool <IsNotNull>b__2(T t);
    [CompilerGeneratedAttribute]
private static bool <IsNotNull>b__3(Nullable`1<T> t);
    [CompilerGeneratedAttribute]
private static bool <IsNull>b__4(Nullable`1<T> t);
    [CompilerGeneratedAttribute]
private static bool <WhereNotNull>b__5(TA a);
    [CompilerGeneratedAttribute]
private static IEnumerable`1<TA> <WhereNotNull>b__6(IEnumerable`1<Nullable`1<TA>> a);
    [CompilerGeneratedAttribute]
private static TA <WhereNotNull>b__7(Nullable`1<TA> v);
}
public class JetBrains.Common.Util.DataPipes.PipeEventData`1 : ValueType {
    internal bool HasData;
    internal T Data;
    internal PipeEventData`1(T data);
}
internal enum JetBrains.Common.Util.DataPipes.PipeLifeState : Enum {
    public int value__;
    public static PipeLifeState Alive;
    public static PipeLifeState BeginTermination;
    public static PipeLifeState EndTermination;
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.DataPipes.ProgressEx : object {
    [CompilerGeneratedAttribute]
private static Func`2<IEnumerable`1<ProgressProvider>, ProgressProvider[]> CS$<>9__CachedAnonymousMethodDelegate1;
    [CompilerGeneratedAttribute]
private static Func`2<AsyncComputationState, bool> CS$<>9__CachedAnonymousMethodDelegate3;
    [ExtensionAttribute]
public static IDataProvider`1<ProgressProvider[]> GetProgressesProvider(IDataPipeNode provider);
    [ExtensionAttribute]
public static ProgressProvider GetLastProgress(IAsyncDataProvider`1<T> source);
    [ExtensionAttribute]
public static IDataProvider`1<bool> GetIsCompleted(IDataProvider`1<AsyncComputationState> state);
    [CompilerGeneratedAttribute]
private static ProgressProvider[] <GetProgressesProvider>b__0(IEnumerable`1<ProgressProvider> a);
    [CompilerGeneratedAttribute]
private static bool <GetIsCompleted>b__2(AsyncComputationState s);
}
public abstract class JetBrains.Common.Util.DataPipes.ProxyContainer`1 : object {
    private IDataProxy`1<T> myProxy;
    public IDataProvider`1<T> Data { get; }
    unknown IDataProvider`1<T> Source {public set; }
    protected ProxyContainer`1(IDataProvider`1<T> source);
    public sealed virtual IDataProvider`1<T> get_Data();
    public sealed virtual void set_Source(IDataProvider`1<T> value);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.DataPipes.PublishEx : object {
    [ExtensionAttribute]
public static IDataNotifier`1<T> AsDataNotifier(T o);
    [ExtensionAttribute]
public static IWriteableDataNotifier`1<T> ToWriteableNotifier(IProperty`1<T> property);
    [ExtensionAttribute]
public static ICollectionNotifier`1<T> PublishCollection(IDataProvider`1<IEnumerable`1<T>> source, Lifetime lifetime, CollectionNotificationMode mode);
    [ExtensionAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null; notnull => notnull")]
public static IDataNotifier`1<T> Publish(IDataProvider`1<T> source);
    [ExtensionAttribute]
public static IWriteableDataNotifier`1<T> PublishWriteable(IDataProvider`1<T> source, Action`1<T> setValue, IDataProvider`1<string> error, bool validateSetValue);
    [ExtensionAttribute]
public static IWriteableDataNotifier`1<T> PublishWriteable(IDataProvider`1<T> source, Action`1<T> setValue, bool validateSetValue);
    [ExtensionAttribute]
public static IWriteableDataNotifier`1<T> PublishWriteable(IDataController`1<T> source, IDataProvider`1<string> error);
    [ExtensionAttribute]
public static IWriteableDataNotifier`1<bool> PublishWriteableContains(IObservableSet`1<T> set, IDataProvider`1<IReadOnlyCollection`1<T>> provider, T key);
    [ExtensionAttribute]
public static IWriteableDataNotifier`1<bool> PublishWriteableContains(IObservableSet`1<T> set, T key);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.DataPipes.SelectEx : object {
    [NotNullAttribute]
[ExtensionAttribute]
public static IDataProvider`1<TB> Select(IDataProvider`1<TA> keyProvider, Func`2<TA, IDataProvider`1<TB>> selector);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<TB> SelectSafe(IDataProvider`1<TA> keyProvider, Func`2<TA, IAsyncDataProvider`1<TB>> selector);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<TB> Select(IDataProvider`1<TA> keyProvider, Func`2<TA, IAsyncDataProvider`1<TB>> selector);
    [NotNullAttribute]
[ExtensionAttribute]
public static IRemotableReference`1<IDataProvider`1<TB>> Select(IRemotableReference`1<IDataProvider`1<TA>> keyProvider, Func`2<TA, IDataProvider`1<TB>> selector);
    [ExtensionAttribute]
public static IThreadSwitch`1<T> Flatten(IDataProvider`1<IThreadSwitch`1<T>> source);
    [ExtensionAttribute]
public static IThreadSwitch`1<TB> Select(IDataProvider`1<bool> keyProvider, IThreadSwitch`1<TB> trueCase, IThreadSwitch`1<TB> falseCase);
    [ExtensionAttribute]
public static IThreadSwitch`1<TB> SelectSafe(IDataProvider`1<TA> source, Func`2<TA, IThreadSwitch`1<TB>> selector);
    [ExtensionAttribute]
public static IThreadSwitch`1<TB> Select(IDataProvider`1<TA> source, Func`2<TA, IThreadSwitch`1<TB>> selector);
    [ExtensionAttribute]
public static IDataProvider`1<TB> SelectSafe(IDataProvider`1<TA> keyProvider, Func`2<TA, IDataProvider`1<TB>> selector);
    [ExtensionAttribute]
public static IRemotableReference`1<IDataProvider`1<TB>> SelectSafe(IRemotableReference`1<IDataProvider`1<TA>> keyProvider, Func`2<TA, IDataProvider`1<TB>> selector);
    [ExtensionAttribute]
public static IDataProvider`1<TB> SelectSafe(IDataProvider`1<Nullable`1<TA>> keyProvider, Func`2<TA, IDataProvider`1<TB>> selector);
    [ExtensionAttribute]
public static IDataProvider`1<TB> SelectSafe(IDataProvider`1<TA> keyProvider, Func`2<TA, IDataProvider`1<TB>> selector, TB fallbackValue);
    [ExtensionAttribute]
public static IDataProvider`1<TB> SelectSafe(IDataProvider`1<TA> keyProvider, Func`2<TA, IDataProvider`1<TB>> selector, IDataProvider`1<TB> fallbackProvider);
    [ExtensionAttribute]
public static IDataProvider`1<TB> SelectSafe(IDataProvider`1<Nullable`1<TA>> keyProvider, Func`2<TA, IDataProvider`1<TB>> selector, IDataProvider`1<TB> fallbackProvider);
    [ExtensionAttribute]
[NotNullAttribute]
public static IDataProvider`1<T> Select(IDataProvider`1<bool> switchKey, IDataProvider`1<T> trueCase, IDataProvider`1<T> falseCase);
    [ExtensionAttribute]
[NotNullAttribute]
public static IAsyncDataProvider`1<T> Select(IDataProvider`1<bool> switchKey, IAsyncDataProvider`1<T> trueCase, IAsyncDataProvider`1<T> falseCase);
    [ExtensionAttribute]
public static IDataProvider`1<T> SelectValue(IDataProvider`1<bool> switchKey, T trueCase, T falseCase);
    [NotNullAttribute]
[ExtensionAttribute]
public static IDataProvider`1<T> Flatten(IDataProvider`1<IDataProvider`1<T>> source);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<T> Flatten(IDataProvider`1<IAsyncDataProvider`1<T>> source);
    [ExtensionAttribute]
[NotNullAttribute]
public static IRemotableReference`1<IDataProvider`1<T>> Flatten(IRemotableReference`1<IDataProvider`1<IDataProvider`1<T>>> source);
    [CompilerGeneratedAttribute]
private static IThreadSwitch`1<T> <Flatten>b__6(IThreadSwitch`1<T> s);
    [CompilerGeneratedAttribute]
private static IDataProvider`1<T> <Flatten>b__1d(IDataProvider`1<IDataProvider`1<T>> s);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.DataPipes.SettingsStoreEx : object {
    [ExtensionAttribute]
public static IDataController`1<TEntryMemberType> GetValueController(IContextBoundSettingsStore settingsStore, Lifetime lifetime, Expression`1<Func`2<TKeyClass, TEntryMemberType>> lambda);
    [ExtensionAttribute]
public static IDataController`1<TEntryMemberType> GetValueController(IContextBoundSettingsStoreLive settingsStore, Lifetime lifetime, Expression`1<Func`2<TKeyClass, TEntryMemberType>> lambda);
    [ExtensionAttribute]
public static IDataProvider`1<TEntryMemberType> GetValueProvider(IContextBoundSettingsStoreLive settingsStore, Lifetime lifetime, Expression`1<Func`2<TKeyClass, TEntryMemberType>> lambda);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.DataPipes.ShellEx : object {
    [CompilerGeneratedAttribute]
private static Func`2<bool, bool> CS$<>9__CachedAnonymousMethodDelegate6;
    [ExtensionAttribute]
public static IDataProvider`1<bool> ToIsAliveProvider(Lifetime lifetime);
    [ExtensionAttribute]
public static IDataProvider`1<T> InjectLifetime(IDataProvider`1<T> src, DataPipeLifetime lifetime);
    [ExtensionAttribute]
public static IDataProvider`1<T> InjectLifetime(IDataProvider`1<T> src, Lifetime lifetime);
    [ExtensionAttribute]
public static Lifetime ToLifetime(IDataProvider`1<bool> src);
    [ExtensionAttribute]
public static IDataProvider`1<T> Guarded(IDataProvider`1<T> src, IThreading threading, string name);
    [ExtensionAttribute]
public static IDataProvider`1<T> Guarded(IDataProvider`1<T> src, ReentrancyGuard guard, string name);
    [CompilerGeneratedAttribute]
private static bool <ToLifetime>b__4(bool v);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.DataPipes.SinkEx : object {
    [ExtensionAttribute]
public static IDataSink`1<T> ToSink(IDataProviderBase`1<T> source, IDataProvider`1<bool> isListening);
    [ExtensionAttribute]
public static IDataSink`1<T> ToSinkForever(IDataProviderBase`1<T> source);
    [ExtensionAttribute]
public static IDataSink`1<T> ToSink(IDataProviderBase`1<T> source, Lifetime lifetime);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.DataPipes.SubscribeEx : object {
    [CompilerGeneratedAttribute]
private static Func`2<bool, bool> CS$<>9__CachedAnonymousMethodDelegate39;
    [ExtensionAttribute]
public static void SubscribeSafe(IDataProviderBase`1<T> provider, Lifetime lifetime, ValueUpdatedHandler`1<T> handler, bool initInvoke);
    [ExtensionAttribute]
public static void SubscribeSafe(IDataProviderBase`1<Pair`2<TA, TB>> provider, Lifetime lifetime, Action`2<TA, TB> handler, bool initInvoke);
    [ExtensionAttribute]
public static void SubscribeSafe(IDataProviderBase`1<Pair`2<TA, TB>> provider, Lifetime lifetime, Func`3<TA, TB, bool> isSafe, Action`2<TA, TB> handler, bool initInvoke);
    [ExtensionAttribute]
public static void SubscribeWithLifetimeSafe(IDataProvider`1<T> provider, Lifetime lifetime, LifetimedValueUpdatedHandler`1<T> handler, bool initInvoke);
    [ExtensionAttribute]
public static void SubscribeSafe(IDataProviderBase`1<Nullable`1<T>> provider, Lifetime lifetime, ValueUpdatedHandler`1<T> handler, bool initInvoke);
    [ExtensionAttribute]
public static void SubscribeSafe(IDataProviderBase`1<T> provider, IDataProvider`1<bool> isActive, ValueUpdatedHandler`1<T> handler, bool initInvoke);
    [ExtensionAttribute]
private static ValueUpdatedHandler`1<Pair`2<TA, TB>> ToValueUpdatedHandler(Action`2<TA, TB> handler);
    [ExtensionAttribute]
private static ValueUpdatedHandler`1<Pair`2<Pair`2<TA, TB>, TC>> ToValueUpdatedHandler(Action`3<TA, TB, TC> handler);
    [ExtensionAttribute]
public static void Subscribe(IDataProviderBase`1<Pair`2<TA, TB>> source, Lifetime lifetime, Action`2<TA, TB> handler);
    [ExtensionAttribute]
public static void Subscribe(IDataProviderBase`1<Pair`2<Pair`2<TA, TB>, TC>> source, Lifetime lifetime, Action`3<TA, TB, TC> handler);
    [ExtensionAttribute]
public static void Subscribe(IDataSignal signal, IDataProvider`1<bool> isActive, Action handler);
    [ExtensionAttribute]
public static void Subscribe(IDataSignal signal, Lifetime lifetime, Action handler);
    [ExtensionAttribute]
public static void SubscribeForever(IDataProviderBase`1<PipeEventData`1<T>> provider, ValueUpdatedHandler`1<T> handler);
    [ExtensionAttribute]
public static void Subscribe(IDataProviderBase`1<PipeEventData`1<T>> provider, Lifetime lifetime, ValueUpdatedHandler`1<T> handler);
    [ExtensionAttribute]
public static void Subscribe(IDataProviderBase`1<PipeEventData`1<T>> provider, IDataProvider`1<bool> isActive, ValueUpdatedHandler`1<T> handler);
    [ExtensionAttribute]
public static void SubscribeForever(IDataProviderBase`1<T> source, ValueUpdatedHandler`1<T> handler, bool initInvoke);
    [ExtensionAttribute]
public static void SubscribeForever(IDataProviderBase`1<T> source, Func`2<T, bool> condition, ValueUpdatedHandler`1<T> handler, bool initInvoke);
    [ExtensionAttribute]
public static void SubscribeForever(IDataProvider`1<T> source, LifetimedValueUpdatedHandler`1<T> handler, bool initInvoke);
    [ExtensionAttribute]
public static void SubscribeForever(IDataProviderBase`1<T> source, ValueWithPreviousUpdateHandler`1<T> handler);
    [ExtensionAttribute]
public static void SubscribeForever(IDataProvider`1<T> source, Func`2<T, bool> condition, LifetimedValueUpdatedHandler`1<T> handler, bool initInvoke);
    [ExtensionAttribute]
public static void Subscribe(IDataProviderBase`1<T> source, Lifetime lifetime, Func`2<T, bool> condition, ValueUpdatedHandler`1<T> handler, bool initInvoke);
    [ExtensionAttribute]
public static IDataProviderBase`1<T> Subscribe(IDataProviderBase`1<T> source, Lifetime lifetime, ValueUpdatedHandler`1<T> handler, bool initInvoke);
    [ExtensionAttribute]
public static void Subscribe(IDataProviderBase`1<T> source, IDataProvider`1<bool> isActiveProvider, ValueUpdatedHandler`1<T> handler, bool initInvoke);
    [ExtensionAttribute]
public static void Subscribe(IDataProviderBase`1<T> source, IDataProvider`1<bool> isActiveProvider, Func`2<T, bool> condition, ValueUpdatedHandler`1<T> handler, bool initInvoke);
    [ExtensionAttribute]
public static void SubscribeFirst(IDataProviderBase`1<T> source, Lifetime lifetime, Func`2<T, bool> condition, ValueUpdatedHandler`1<T> handler);
    [ExtensionAttribute]
public static void SubscribeSafe(IDataProviderBase`1<T> source, IDataProvider`1<bool> isActiveProvider, LifetimedValueUpdatedHandler`1<T> handler, bool initInvoke);
    [ExtensionAttribute]
public static void Subscribe(IDataProviderBase`1<T> source, IDataProvider`1<bool> isActiveProvider, LifetimedValueUpdatedHandler`1<T> handler, bool initInvoke);
    [ExtensionAttribute]
public static IDataProvider`1<T> Subscribe(IDataProvider`1<T> source, Lifetime lifetime, LifetimedValueUpdatedHandler`1<T> handler, bool initInvoke);
    [ExtensionAttribute]
public static void Subscribe(IDataProviderBase`1<T> source, Lifetime lifetime, ValueWithPreviousUpdateHandler`1<T> handler);
    [ExtensionAttribute]
public static void Subscribe(IDataProviderBase`1<T> source, Lifetime lifetime, Func`2<T, bool> condition, LifetimedValueUpdatedHandler`1<T> handler, bool initInvoke);
    [ExtensionAttribute]
public static void Subscribe(IDataProviderBase`1<T> source, IDataProvider`1<bool> isActiveProvider, Func`2<T, bool> condition, LifetimedValueUpdatedHandler`1<T> handler, bool initInvoke);
    [ExtensionAttribute]
public static void SubscribeFirstTrue(IDataProviderBase`1<bool> source, Lifetime lifetime, Action handler);
    [ExtensionAttribute]
public static void SubscribeFirstNotNull(IDataProviderBase`1<T> source, Lifetime lifetime, ValueUpdatedHandler`1<T> handler);
    [ExtensionAttribute]
public static void SubscribeFirstNotNull(IDataProviderBase`1<Nullable`1<T>> source, Lifetime lifetime, ValueUpdatedHandler`1<T> handler);
    [ExtensionAttribute]
public static IDataProvider`1<T> Activate(IDataProvider`1<T> source, Lifetime lifetime);
    [ExtensionAttribute]
public static IDataProvider`1<T> Activate(IDataProvider`1<T> source, IDataProvider`1<bool> activate);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<T> Activate(IAsyncDataProvider`1<T> source, Lifetime lifetime);
    [CompilerGeneratedAttribute]
private static bool <SubscribeForever>b__1e(PipeEventData`1<T> a);
    [CompilerGeneratedAttribute]
private static bool <Subscribe>b__22(PipeEventData`1<T> a);
    [CompilerGeneratedAttribute]
private static bool <Subscribe>b__26(PipeEventData`1<T> a);
    [CompilerGeneratedAttribute]
private static bool <SubscribeFirstTrue>b__37(bool a);
    [CompilerGeneratedAttribute]
private static bool <SubscribeFirstNotNull>b__3c(T a);
    [CompilerGeneratedAttribute]
private static bool <SubscribeFirstNotNull>b__3d(Nullable`1<T> a);
    [CompilerGeneratedAttribute]
private static void <Activate>b__41(T _);
    [CompilerGeneratedAttribute]
private static void <Activate>b__42(T _);
    [CompilerGeneratedAttribute]
private static void <Activate>b__43(T _);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.DataPipes.SwitchEx : object {
    [ExtensionAttribute]
public static IAsyncDataProvider`1<T> ToThreadPool(IThreadSwitch`1<T> provider, DataPipeLifetime lifetime);
    [ExtensionAttribute]
public static IRemotableReference`1<IDataProvider`1<T>> ToMainThread(IRemotableReference`1<IThreadSwitch`1<T>> provider, TimeSpan delay);
    [ExtensionAttribute]
public static IRemotableReference`1<IAsyncDataProvider`1<T>> ToThreadPool(IRemotableReference`1<IThreadSwitch`1<T>> provider, IRemotablePair`1<DataPipeLifetime> lifetime);
    [ExtensionAttribute]
public static IRemotableReference`1<IAsyncDataProvider`1<T>> ToThreadPool(IRemotableReference`1<IThreadSwitch`1<T>> provider, IRemotableReference`1<DataPipeLifetime> lifetime);
    [ExtensionAttribute]
public static IDataProvider`1<T> ToMainThread(IThreadSwitch`1<T> provider, TimeSpan delay);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<T> SwitchToThreadPool(IDataProviderBase`1<T> provider, DataPipeLifetime lifetime);
    [ExtensionAttribute]
public static IDataProvider`1<IDataProvider`1[]> SplitArray(IDataProvider`1<T[]> provider);
    [ExtensionAttribute]
public static IDataProvider`1<T> SwitchStreamToMainThread(IDataProviderBase`1<T> provider);
    [ExtensionAttribute]
public static IDataProvider`1<T> SwitchToMainThread(IDataProviderBase`1<T> provider);
    [ExtensionAttribute]
public static IThreadSwitchEx`1<List`1<T>> SwitchRecycle(IDataProviderBase`1<IEnumerable`1<T>> provider);
    [ExtensionAttribute]
public static IThreadSwitchEx`1<List`1<T>> SwitchRecycleWithController(IAsyncDataProvider`1<IEnumerable`1<T>> provider);
    [ExtensionAttribute]
public static IThreadSwitchEx`1<C> SwitchRecycleWithController(IAsyncDataProvider`1<IEnumerable`1<T>> provider);
    [ExtensionAttribute]
public static IThreadSwitchEx`1<TC> SwitchRecycle(IDataProviderBase`1<TA> provider, Func`3<TA, TB, TC> fillContainer);
    [ExtensionAttribute]
public static IThreadSwitchEx`1<TC> SwitchRecycle(IAsyncDataProvider`1<TA> provider, Func`4<TA, TB, IExecutionController, TC> fillContainer);
    [ExtensionAttribute]
public static IThreadSwitchEx`1<TOutput> SwitchRecycle(IAsyncDataProvider`1<TInput> provider, Func`1<TContainer> createContainer, Func`4<TInput, TContainer, IExecutionController, TOutput> fillContainer);
    [ExtensionAttribute]
public static IThreadSwitchEx`1<C> SwitchRecycle(IDataProviderBase`1<IEnumerable`1<T>> provider);
    [ExtensionAttribute]
internal static IDataProvider`1<T> ToExternalExecutor(IDataProvider`1<T> src, Action`2<Action`1<T>, T> executor);
    [ExtensionAttribute]
public static IThreadSwitch`1<T> Switch(IDataProviderBase`1<T> provider);
    [ExtensionAttribute]
public static IThreadSwitch`1<T> SwitchStream(IDataProviderBase`1<T> provider);
    [ExtensionAttribute]
private static IThreadSwitch`1<T> SwitchCore(IDataProviderBase`1<T> provider, bool isStream);
    [ExtensionAttribute]
public static IThreadSwitchEx`1<TB> SwitchRecycle(IDataProvider`1<TA> provider, Func`3<TA, TB, TB> fillContainer);
    [ExtensionAttribute]
public static IThreadSwitchEx`1<TC> SwitchRecycle(IDataProviderBase`1<TA> provider, Func`1<TB> createContainer, Func`3<TA, TB, TC> fillContainer);
    [ExtensionAttribute]
private static IDataProvider`1<T> ToDispatcher(IThreadSwitch`1<T> sw, Dispatcher dispatcher);
    [ExtensionAttribute]
private static IDataProvider`1<T> ToDispatcherStream(IDataProvider`1<T> provider, Dispatcher dispatcher);
    [ExtensionAttribute]
internal static IThreadSwitch`1<Getter`1<T>> Elevate(IThreadSwitch`1<T> sw);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<T> ToAsyncExecutor(IThreadSwitch`1<T> sw, Action`1<ITask> execute, DataPipeLifetime lifetime, string title);
    [ExtensionAttribute]
public static IDataProvider`1<T> WhileNotInitializedUseDefault(IDataProvider`1<T> provider);
    [ExtensionAttribute]
public static IDataProvider`1<T> WhileNotInitializedUse(IDataProvider`1<T> provider, T replacement);
    [ExtensionAttribute]
public static IDataProvider`1<T> WhileNotInitializedUse(IDataProvider`1<T> provider, IDataProvider`1<T> replacement);
    [CompilerGeneratedAttribute]
private static IDataProvider`1<T> <ToMainThread>b__0(IThreadSwitch`1<T> p);
    [CompilerGeneratedAttribute]
private static C <SwitchRecycleWithController>b__b(IEnumerable`1<T> values, C collection, IExecutionController controller);
    [CompilerGeneratedAttribute]
private static TB <SwitchRecycle>b__c();
    [CompilerGeneratedAttribute]
private static TB <SwitchRecycle>b__d();
    [CompilerGeneratedAttribute]
private static C <SwitchRecycle>b__11(IEnumerable`1<T> values, C collection);
    [CompilerGeneratedAttribute]
private static Getter`1<T> <Elevate>b__12(T v);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.DataPipes.TransformEx : object {
    [ExtensionAttribute]
public static IDataProvider`1<TB> TransformSafe(IDataProvider`1<TA> provider, Func`2<TA, TB> converter, TB fallbackValue);
    [ExtensionAttribute]
public static IDataProvider`1<TB> TransformSafe(IDataProvider`1<TA> provider, Predicate`1<TA> condition, Func`2<TA, TB> converter, TB fallbackValue);
    [ExtensionAttribute]
public static IRemotableReference`1<IDataProvider`1<TB>> TransformSafe(IRemotableReference`1<IDataProvider`1<Nullable`1<TA>>> provider, Func`2<TA, TB> converter, TB fallbackValue);
    [ExtensionAttribute]
public static IRemotableReference`1<IDataProvider`1<TB>> TransformSafe(IRemotableReference`1<IDataProvider`1<TA>> provider, Func`2<TA, TB> converter, TB fallbackValue);
    [ExtensionAttribute]
public static IRemotableReference`1<IDataProvider`1<TB>> TransformSafe(IRemotableReference`1<IDataProvider`1<IntPtr>> provider, Func`2<IntPtr, TB> converter, TB fallbackValue);
    [ExtensionAttribute]
public static IRemotableReference`1<IAsyncDataProvider`1<TB>> TransformSafe(IRemotableReference`1<IAsyncDataProvider`1<IntPtr>> provider, Func`2<IntPtr, TB> converter, TB fallbackValue);
    [ExtensionAttribute]
public static IDataProvider`1<TC> TransformPair(IDataProvider`1<Pair`2<TA, TB>> provider, Func`3<TA, TB, TC> converter);
    [ExtensionAttribute]
public static IDataProvider`1<TR> TransformSafe(IDataProvider`1<Pair`2<TA, TB>> provider, Func`3<TA, TB, bool> isSafe, Func`3<TA, TB, TR> converter, TR fallbackValue);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<TC> TransformSafe(IAsyncDataProvider`1<Pair`2<TA, TB>> provider, Func`3<TA, TB, TC> converter);
    [ExtensionAttribute]
public static IDataProvider`1<TC> TransformSafe(IDataProvider`1<Pair`2<TA, TB>> provider, Func`3<TA, TB, TC> converter);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<TB> TransformWithLifetimeSafe(IAsyncDataProvider`1<TA> provider, Func`3<Lifetime, TA, TB> converter, TB fallbackValue);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<TB> TransformWithLifetime(IAsyncDataProvider`1<TA> provider, Func`3<Lifetime, TA, TB> converter);
    [ExtensionAttribute]
public static IDataProvider`1<TR> TransformWithLifetimeSafe(IDataProvider`1<Pair`2<TA, TB>> provider, Func`4<Lifetime, TA, TB, TR> converter, TR fallbackValue);
    [ExtensionAttribute]
public static IDataProvider`1<TB> TransformWithLifetimeSafe(IDataProvider`1<TA> provider, Func`3<Lifetime, TA, TB> converter, TB fallbackValue);
    [ExtensionAttribute]
public static IDataProvider`1<TB> TransformWithLifetimeSafe(IDataProvider`1<TA> provider, Lifetime parentLifetime, Func`3<Lifetime, TA, TB> converter, TB fallbackValue);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<TR> TransformWithLifetimeSafe(IAsyncDataProvider`1<Pair`2<TA, TB>> provider, Predicate`1<Pair`2<TA, TB>> isSafe, Func`4<Lifetime, Pair`2<TA, TB>, IExecutionController, TR> converter, TR fallbackValue, string operationName);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<TR> TransformWithLifetimeSafe(IAsyncDataProvider`1<TA> provider, Func`4<Lifetime, TA, IExecutionController, TR> converter, TR fallbackValue, string operationName);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<TR> TransformWithLifetime(IAsyncDataProvider`1<TA> provider, Func`4<Lifetime, TA, IExecutionController, TR> converter, string operationName);
    [ExtensionAttribute]
public static IDataProvider`1<TB> TransformWithLifetime(IDataProvider`1<TA> provider, Lifetime parentLifetime, Func`3<Lifetime, TA, TB> converter);
    [ExtensionAttribute]
public static IDataProvider`1<TB> TransformWithLifetime(IDataProvider`1<TA> provider, Func`3<Lifetime, TA, TB> converter);
    [ExtensionAttribute]
public static IDataProvider`1<TB> TransformSafe(IDataProvider`1<IntPtr> provider, Func`2<IntPtr, TB> converter, TB fallback);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<TB> TransformSafe(IAsyncDataProvider`1<IntPtr> provider, Func`2<IntPtr, TB> converter, TB fallback);
    [ExtensionAttribute]
public static IDataProvider`1<TB> TransformSafe(IDataProvider`1<Nullable`1<TA>> provider, Func`2<TA, TB> converter, TB fallbackValue);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<TB> TransformSafe(IAsyncDataProvider`1<TA> provider, Func`3<TA, IExecutionController, TB> converter, string operationTitle, TB fallbackValue);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<TB> TransformSafe(IAsyncDataProvider`1<TA> provider, Func`2<TA, TB> converter, TB fallbackValue);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<TB> TransformSafe(IAsyncDataProvider`1<Nullable`1<TA>> provider, Func`2<TA, TB> converter, TB fallbackValue);
    [ExtensionAttribute]
public static IDataProvider`1<TC> TransformRecycle(IDataProvider`1<TA> provider, TB value, Func`3<TA, TB, TC> fill);
    [ExtensionAttribute]
public static IDataProvider`1<TB> TransformRecycleSafe(IDataProvider`1<TA> provider, TB value, Func`3<TA, TB, TB> fill);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<TB> TransformRecycleSafe(IAsyncDataProvider`1<TA> provider, TB value, Action`3<TA, TB, IExecutionController> fill);
    [ExtensionAttribute]
public static IDataProvider`1<IEnumerable`1<TB>> TransformEnumerables(IDataProvider`1<IEnumerable`1<TA>> provider, Func`2<TA, TB> converter, Func`2<TA, bool> filter);
    [ExtensionAttribute]
public static IDataProvider`1<TB[]> TransformArraySafe(IDataProvider`1<TA[]> provider, Func`2<TA, TB> converter, TB fallbackValue, bool reuseArray);
    [ExtensionAttribute]
public static IDataProvider`1<TB[]> TransformArray(IDataProvider`1<TA[]> provider, Func`2<TA, TB> converter, bool reuseArray);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<IEnumerable`1<TB>> TransformEnumerables(IAsyncDataProvider`1<IEnumerable`1<TA>> provider, Func`2<TA, TB> converter, Func`2<TA, bool> filter);
    [ExtensionAttribute]
public static IDataProvider`1<TB> TransformWithCache(IDataProvider`1<TA> provider, Func`2<TA, TB> createValue);
    [ExtensionAttribute]
public static IDataProvider`1<IDictionary`2<TA, TB>> TransformEnumerablesWithCache(IDataProvider`1<IReadOnlyCollection`1<TA>> provider, Func`2<TA, TB> converter);
    [ExtensionAttribute]
public static IDataProvider`1<TB> TransformWithTaskExecutor(IDataProvider`1<TA> src, ITaskExecutor executor, string name, TaskCancelable cancelable, Func`3<TA, IProgressIndicator, TB> task);
    [ExtensionAttribute]
public static IDataProvider`1<PipeEventData`1<TB>> Transform(IDataProvider`1<PipeEventData`1<TA>> provider, Func`2<TA, TB> converter);
    [ExtensionAttribute]
public static IDataProvider`1<PipeEventData`1<TB>> TransformSafe(IDataProvider`1<PipeEventData`1<TA>> provider, Func`2<TA, TB> converter, TB fallback);
    [ExtensionAttribute]
[NotNullAttribute]
public static IDataProvider`1<TB> Transform(IDataProvider`1<TA> provider, Func`2<TA, TB> converter);
    [ExtensionAttribute]
[NotNullAttribute]
public static IDataProvider`1<TC> Transform(IDataProvider`1<Pair`2<TA, TB>> provider, Func`3<TA, TB, TC> converter);
    [NotNullAttribute]
[ExtensionAttribute]
public static IRemotableReference`1<IDataProvider`1<TB>> Transform(IRemotableReference`1<IDataProvider`1<TA>> provider, Func`2<TA, TB> converter);
    [NotNullAttribute]
[ExtensionAttribute]
public static IRemotableReference`1<IAsyncDataProvider`1<TB>> Transform(IRemotableReference`1<IAsyncDataProvider`1<TA>> provider, Func`2<TA, TB> converter);
    [NotNullAttribute]
[ExtensionAttribute]
public static IDataProvider`1<TTo> TransformWithPrevious(IDataProvider`1<TFrom> source, Func`3<TFrom, TTo, TTo> converter, TTo initValue);
    [ExtensionAttribute]
[NotNullAttribute]
public static IDataProvider`1<TTo> TransformWithPrevious(IDataProvider`1<TFrom> source, Func`3<TFrom, TTo, TTo> converter, Func`1<TTo> lastValueFunctor);
    [ExtensionAttribute]
public static IThreadSwitch`1<TB> TransformWithLastValueCache(IThreadSwitch`1<TA> s, Func`2<TA, TB> converter, IEqualityComparer`1<TA> comparer);
    [NotNullAttribute]
[ExtensionAttribute]
public static IThreadSwitch`1<TB> Transform(IThreadSwitch`1<TA> s, Func`2<TA, TB> converter);
    [ExtensionAttribute]
public static IThreadSwitch`1<TB> TransformLocked(IThreadSwitch`1<ILocked`1<TA>> s, Func`2<TA, TB> converter, TB fallback);
    [NotNullAttribute]
[ExtensionAttribute]
public static IThreadSwitch`1<TB> TransformSafe(IThreadSwitch`1<TA> s, Func`2<TA, TB> converter, TB fallback);
    [ExtensionAttribute]
[NotNullAttribute]
public static IThreadSwitch`1<TB> TransformSafe(IThreadSwitch`1<Nullable`1<TA>> s, Func`2<TA, TB> converter, TB fallback);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<TC> Transform(IAsyncDataProvider`1<Pair`2<TA, TB>> provider, Func`4<TA, TB, IExecutionController, TC> converter, string operationName);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<TR> TransformSafe(IAsyncDataProvider`1<Pair`2<TA, TB>> provider, Predicate`1<Pair`2<TA, TB>> isSafePredicate, Func`4<TA, TB, IExecutionController, TR> converter, string operationName, TR fallbackValue);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<TR> TransformSafe(IAsyncDataProvider`1<TA> provider, Predicate`1<TA> isSafePredicate, Func`3<TA, IExecutionController, TR> converter, string operationName, TR fallbackValue);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<TB> Transform(IAsyncDataProvider`1<TA> provider, Func`3<TA, IExecutionController, TB> converter, string operationName);
    [ExtensionAttribute]
public static IRemotableReference`1<IAsyncDataProvider`1<TB>> Transform(IRemotableReference`1<IAsyncDataProvider`1<TA>> provider, Func`3<TA, IExecutionController, TB> converter);
    [ExtensionAttribute]
public static IRemotableReference`1<IAsyncDataProvider`1<TB>> TransformSafe(IRemotableReference`1<IAsyncDataProvider`1<TA>> provider, Func`3<TA, IExecutionController, TB> converter, string operationTitle, TB fallbackValue);
    [ExtensionAttribute]
[NotNullAttribute]
public static IDataProvider`1<Nullable`1<T>> TransformToNullable(IDataProvider`1<T> provider);
    [NotNullAttribute]
[ExtensionAttribute]
public static IAsyncDataProvider`1<TB> Transform(IAsyncDataProvider`1<TA> provider, Func`2<TA, TB> converter);
    [ExtensionAttribute]
public static IDataProvider`1<TB> TransformAsync(IDataProvider`1<TA> provider, DataPipeLifetime lifetime, Func`2<TA, TB> converter);
    [ExtensionAttribute]
public static IDataProvider`1<TB> TransformAsync(IDataProvider`1<TA> provider, DataPipeLifetime lifetime, Func`3<TA, IExecutionController, TB> converter);
    [ExtensionAttribute]
public static IDataProvider`1<TB> TransformSyncOrAsync(IDataProvider`1<TA> provider, DataPipeLifetime lifetime, IDataProvider`1<bool> useAsync, Func`2<TA, TB> converter);
    [ExtensionAttribute]
public static IDataProvider`1<T> Transform(IDataSignal signal, Func`1<T> getValue);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<TA> First(IAsyncDataProvider`1<Pair`2<TA, TB>> provider);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<TB> Second(IAsyncDataProvider`1<Pair`2<TA, TB>> provider);
    [CompilerGeneratedAttribute]
private static Getter`1<TA> <Transform>b__74(TA v);
    [CompilerGeneratedAttribute]
private static Nullable`1<T> <TransformToNullable>b__99(T t);
    [CompilerGeneratedAttribute]
private static TA <First>b__9d(Pair`2<TA, TB> p);
    [CompilerGeneratedAttribute]
private static TB <Second>b__9e(Pair`2<TA, TB> p);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.DataPipes.UpdateDeferingEx : object {
    [ExtensionAttribute]
public static IRemotableReference`1<IDataProvider`1<T>> DeferUpdate(IRemotableReference`1<IDataProvider`1<T>> provider, TimeSpan delay);
    [ExtensionAttribute]
public static IDataProvider`1<T> DeferUpdate(IDataProvider`1<T> provider, TimeSpan delay);
    [ExtensionAttribute]
public static IDataProvider`1<PipeEventData`1<T>> WaitForSignal(IDataProvider`1<T> provider, IDataSignal signal);
    [ExtensionAttribute]
public static IDataProvider`1<T> GroupBySignal(IDataProvider`1<T> provider, IDataSignal signal);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<T> GroupBySignal(IAsyncDataProvider`1<T> provider, IAsyncDataSignal signal);
    [ExtensionAttribute]
public static IDataProvider`1<T> AddAfterUpdateSignal(IDataProvider`1<T> provider, IDataSignal& signal);
    [ExtensionAttribute]
private static IDataProvider`1<T> AddAfterUpdateSignalCore(IDataProvider`1<T> provider, IDataSignalControllerBase c);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<T> GroupUpdates(IAsyncDataProvider`1<T> provider, IGroupingToken token);
    [ExtensionAttribute]
public static IDataProvider`1<T> GroupUpdates(IDataProvider`1<T> provider, IGroupingToken token);
    [ExtensionAttribute]
public static IDataProvider`1<T> GetGroupingToken(IDataProvider`1<T> provider, IGroupingToken& token);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<T> GetGroupingToken(IAsyncDataProvider`1<T> provider, IGroupingToken& token);
    [ExtensionAttribute]
private static IDataProvider`1<T> GetGroupingTokenCore(IDataProvider`1<T> provider, IDataSignalControllerBase signal, IGroupingToken& token);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<T> AddAfterUpdateSignal(IAsyncDataProvider`1<T> provider, IAsyncDataSignal& signal);
    internal static IAsyncDataSignalController CreateDerivedAsyncSignal(IAsyncController controller);
    [CompilerGeneratedAttribute]
private static void <WaitForSignal>b__4(PipeEventData`1<T> v, ITransformController`1<PipeEventData`1<T>> c);
}
public class JetBrains.Common.Util.DataPipes.ValueEditingState : object {
    public bool HasChanges;
    [CanBeNullAttribute]
public string Error;
    public bool HasError { get; }
    public ValueEditingState(bool hasChanges);
    public ValueEditingState(string error);
    public bool get_HasError();
}
public class JetBrains.Common.Util.DataPipes.ValueEditor`2 : object {
    public IDataProvider`1<TOut> Output;
    public IDataController`1<TIn> EditableValue;
    public IDataProvider`1<ValueEditingState> EditingState;
    public ValueEditor`2(IDataController`1<TIn> editableValue, IDataProvider`1<ValueEditingState> editingState, IDataProvider`1<TOut> output);
}
public class JetBrains.Common.Util.DataPipes.ValueUpdatedHandler`1 : MulticastDelegate {
    public ValueUpdatedHandler`1(object object, IntPtr method);
    public virtual void Invoke(T newValue);
    public virtual IAsyncResult BeginInvoke(T newValue, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class JetBrains.Common.Util.DataPipes.ValueWithPreviousUpdateHandler`1 : MulticastDelegate {
    public ValueWithPreviousUpdateHandler`1(object object, IntPtr method);
    public virtual void Invoke(T oldValue, T newValue);
    public virtual IAsyncResult BeginInvoke(T oldValue, T newValue, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.DateTimeEx : object {
    private static DateTime Epoch;
    private static DateTimeEx();
    [ExtensionAttribute]
public static int ToUnixTime(DateTime current);
}
public static class JetBrains.Common.Util.DelayedExecution : object {
    public static void Execute(Lifetime lifetime, TimeSpan delayTime, Action action);
}
public class JetBrains.Common.Util.DelegatedReadOnlyCollection`1 : object {
    [NotNullAttribute]
private IEnumerable`1<TKey> myEnumerable;
    [NotNullAttribute]
private Func`2<TKey, bool> myContains;
    [NotNullAttribute]
private Func`1<int> myGetCount;
    public int Count { get; }
    public DelegatedReadOnlyCollection`1(IEnumerable`1<TKey> enumerable, Func`2<TKey, bool> contains, Func`1<int> getCount);
    public sealed virtual IEnumerator`1<TKey> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual int get_Count();
    public bool Contains(TKey value);
}
public static class JetBrains.Common.Util.DelegatesExecutionTracer : object {
    public static string TracerName;
    public static string Created;
    public static string Execution;
    private static EventTracer ourInstance;
    public static EventTracer Instance { get; }
    public static EventTracer get_Instance();
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.DelegatesExecutionTracingEx : object {
    private static int ourId;
    public static bool IsEnabled;
    private static DelegatesExecutionTracingEx();
    private static void TraceExecution(Action& action);
    private static void TraceExecution(Action`1& action);
    [ExtensionAttribute]
public static void BeginInvokeTraced(Action action);
    [ExtensionAttribute]
public static void BeginInvokeTraced(Action`1<T> action, T arg);
    [ExtensionAttribute]
public static void BeginInvokeTraced(Dispatcher dispatcher, Action action);
    [ExtensionAttribute]
public static void InvokeTraced(Dispatcher dispatcher, Action action);
    [ExtensionAttribute]
public static void InvokeTraced(Dispatcher dispatcher, Action`1<T> action, T arg);
    [ExtensionAttribute]
public static void BeginInvokeTraced(Dispatcher dispatcher, Action`1<T> action, T arg);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.DispatcherEx : object {
    [ExtensionAttribute]
public static void AssertAccess(Dispatcher dispatcher);
}
public class JetBrains.Common.Util.DisposingLogic : object {
    private bool myIsDisposed;
    private Action myDisposeAction;
    public bool IsDisposed { get; }
    public DisposingLogic(Action disposeAction);
    public bool get_IsDisposed();
    public void ThrowIfDisposed(string objectName, string message);
    public sealed virtual void Dispose();
}
public static class JetBrains.Common.Util.Empty : object {
    public static string PropertyId;
    public static string DataRuleName;
    public static string ActionName;
    public static Action Action();
    public static Action`1<T> Action();
    public static T[] Array();
    public static IList`1<T> List();
    public static IEnumerable`1<T> Enumerable();
    public static IReadOnlyCollection`1<T> Countable();
    public static IReadOnlyList`1<T> Indexable();
    public static IReadOnlyCollection`1<T> JetReadOnlyCollection();
}
public class JetBrains.Common.Util.EnumerableEqualityComparer`1 : object {
    public sealed virtual bool Equals(T x, T y);
    public sealed virtual int GetHashCode(T obj);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.EnumerableExtension : object {
    [ExtensionAttribute]
public static IEnumerable`1<Pair`2<T, Nullable`1<T>>> SelectOverlappingPairs(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static IEnumerable`1<Pair`2<T, Nullable`1<T>>> SplitToPairs(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static IEnumerable`1<T> MergeIfSorted(IEnumerable`1<T> first, IEnumerable`1<T> second, Comparison`1<T> comprison);
    [ExtensionAttribute]
public static IEnumerable`1<IntersectionNode`1<T>> Intersect(IEnumerable`1<T> first, IEnumerable`1<T> second, Comparison`1<T> comparison);
    [ExtensionAttribute]
public static IEnumerable`1<T> TakeAllButLast(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static long SumSigned(IEnumerable`1<T> source, Func`2<T, long> selector);
    [ExtensionAttribute]
public static ulong Sum(IEnumerable`1<T> source, Func`2<T, ulong> selector);
    [ExtensionAttribute]
public static IEnumerable`1<T> Replace(IEnumerable`1<T> source, T oldValue, T newValue);
    [ExtensionAttribute]
public static IEnumerable`1<T> Replace(IEnumerable`1<T> source, Predicate`1<T> replaceIf, T newValue);
    [ExtensionAttribute]
public static IEnumerable`1<T> Replace(IEnumerable`1<T> source, Predicate`1<T> replaceIf, Func`2<T, T> newValueFromOldValue);
    [ExtensionAttribute]
public static IEnumerable`1<T> SkipUntil(IEnumerable`1<T> src, Func`2<T, bool> condition);
    public static IEnumerable`1<T> GenerateFromPair(Pair`2<T, T> pair, Func`2<T, Pair`2<T, bool>> moveNext, IComparer`1<T> comparer);
    [ExtensionAttribute]
public static void BatchProcess(IEnumerable`1<T> enumerable, T[] buffer, Action`3<T[], int, TContext> processBatch, TContext context);
    [ExtensionAttribute]
public static IDictionary`2<TKey, TValue> ToDictionaryFromKeys(IEnumerable`1<TKey> keys, Func`2<TKey, TValue> fGetValue);
    [ExtensionAttribute]
public static int EnumerableGetHashCode(IEnumerable`1<T> obj);
    [ExtensionAttribute]
public static bool AllAreSame(IEnumerable`1<TA> src, Func`2<TA, TB> selector);
    [ExtensionAttribute]
public static bool AllAreSame(IEnumerable`1<TA> src, Func`2<TA, TB> selector, IEqualityComparer`1<TB> comparer);
    [ExtensionAttribute]
public static bool AllAreSame(IEnumerable`1<T> src);
    [ExtensionAttribute]
public static bool AllAreSame(IEnumerable`1<T> src, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static IEnumerable`1<T> SkipIf(IEnumerable`1<T> enumerable, Func`2<T, bool> predicate, Func`2<int, bool> appearanceNumber);
    [CompilerGeneratedAttribute]
private static T <AllAreSame>b__43(T a);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.EnumerableExtensions : object {
    [ExtensionAttribute]
private static IEnumerable`1<T> EnumerateAttachController(IEnumerable`1<T> source, IExecutionController controller);
    [ExtensionAttribute]
public static IEnumerable`1<T> InjectController(IEnumerable`1<T> source, IExecutionController controller);
    [ExtensionAttribute]
public static int MaxSafe(IEnumerable`1<T> values, Func`2<T, int> getValue, int fallback);
    public static IEnumerable`1<T> ToggleElement(IEnumerable`1<T> collection, T toToggle);
    [PureAttribute]
[ExtensionAttribute]
public static bool EqualNullableEnumerables(IEnumerable`1<T> left, IEnumerable`1<T> right);
}
public class JetBrains.Common.Util.EnumerationListeners.CollectionPart`2 : object {
    public ChunkList`1<T> Collection;
    public TCollectionInfo Info;
    public CollectionRange Range;
    public int SourceCount;
    public int Version;
    public CollectionPart`2(ChunkList`1<T> collection, TCollectionInfo info, CollectionRange range, int sourceCount, int version);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.EnumerationListeners.CollectionPartEx : object {
    [ExtensionAttribute]
public static bool Has(CollectionPart`2<T, TCollectionInfo> part, int index);
    [ExtensionAttribute]
public static T Get(CollectionPart`2<T, TCollectionInfo> part, int index);
}
public class JetBrains.Common.Util.EnumerationListeners.EnumerationListener`1 : object {
    [NotNullAttribute]
public Action`1<T> OnYield;
    [NotNullAttribute]
public Action`1<ProgressProvider> OnEnumerationStarted;
    [NotNullAttribute]
public Action OnEnumerationFinished;
    [NotNullAttribute]
public Action OnEnumerationCanceled;
    public EnumerationListener`1(Action`1<ProgressProvider> onStarted, Action`1<T> onYield, Action onFinished, Action onCanceled);
}
public class JetBrains.Common.Util.EnumerationListeners.EnumerationListener`2 : object {
    [NotNullAttribute]
public Action`1<TItem> OnYield;
    [NotNullAttribute]
public Action`2<TArg, ProgressProvider> OnEnumerationStarted;
    [NotNullAttribute]
public Action OnEnumerationFinished;
    [NotNullAttribute]
public Action OnEnumerationCanceled;
    public EnumerationListener`2(Action`2<TArg, ProgressProvider> onStarted, Action`1<TItem> onYield, Action onFinished, Action onCanceled);
}
public class JetBrains.Common.Util.EnumerationListeners.EnumerationListenerRecyclingSwitchActions`3 : ValueType {
    public Action`1<TAccumulator> Initialize;
    public Action`2<TItem, TAccumulator> Accumulate;
    [NotNullAttribute]
public Func`2<TAccumulator, TResult> GetResult;
}
public class JetBrains.Common.Util.EnumerationListeners.EnumerationListenerRecyclingSwitchActions`4 : ValueType {
    public Action`2<TAccumulator, TArg> Initialize;
    public Action`2<TItem, TAccumulator> Accumulate;
    [NotNullAttribute]
public Func`2<TAccumulator, TResult> GetResult;
}
public class JetBrains.Common.Util.EnumerationListeners.EnumerationListenerSimpleSwitchActions`4 : ValueType {
    public Func`2<TArg, TAccumulator> CreateAccumulator;
    public Func`3<TItem, TAccumulator, TAccumulator> Aggregate;
    [NotNullAttribute]
public Func`2<TAccumulator, TResult> GetResult;
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.EnumerationListeners.EnumerationListenerWithThreadSwitch : object {
    [CompilerGeneratedAttribute]
private static Func`2<ProgressProvider, ProgressProvider> CS$<>9__CachedAnonymousMethodDelegate5;
    public static EnumerationListenerWithThreadSwitch`3<TItem, TArg, TAccumulator> CreateSimple(Func`2<TArg, TAccumulator> createAccumulator, Func`3<TItem, TAccumulator, TAccumulator> aggregate);
    public static EnumerationListenerWithThreadSwitch`3<TItem, TArg, TResult> CreateSimple(Func`2<TArg, TAccumulator> createAccumulator, Func`3<TItem, TAccumulator, TAccumulator> aggregate, Func`2<TAccumulator, TResult> getResult);
    public static EnumerationListenerWithThreadSwitch`3<TItem, TArg, TResult> CreateSimple(EnumerationListenerSimpleSwitchActions`4<TItem, TArg, TAccumulator, TResult> actions);
    public static EnumerationListenerWithThreadSwitch`3<TItem, TArg, TContainer> CreateRecycling(Action`2<TContainer, TArg> onStarted, Action`2<TItem, TContainer> onYield, Func`2<TContainer, TContainer> onFinished);
    [ExtensionAttribute]
private static ProgressProvider Prepare(IDataProvider`1<ProgressProvider> progress);
    public static EnumerationListenerWithThreadSwitch`3<TItem, TArg, TResult> CreateRecycling(EnumerationListenerRecyclingSwitchActions`4<TItem, TArg, TContainer, TResult> actions);
    public static EnumerationListenerWithThreadSwitch`2<TItem, TResult> CreateRecycling(EnumerationListenerRecyclingSwitchActions`3<TItem, TContainer, TResult> actions);
    private static EnumerationListener`2<TItem, TArg> CreateEnumerationListener(EnumerationListenerSimpleSwitchActions`4<TItem, TArg, TIntermediate, TResult> actions, IAsyncDataController`1<TResult> controller, IDataController`1<ProgressProvider> progress, ActionEvent cancel);
    private static EnumerationListener`2<TItem, TArg> CreateEnumerationListener(EnumerationListenerRecyclingSwitchActions`4<TItem, TArg, TContainer, TResult> actions, TripleBuffer`2<TContainer, TResult> buffer, IAsyncDataController`1<Getter`1<TResult>> controller, IDataController`1<ProgressProvider> progress, ActionEvent cancel);
    private static EnumerationListener`1<TItem> CreateEnumerationListener(EnumerationListenerRecyclingSwitchActions`3<TItem, TContainer, TResult> actions, TripleBuffer`2<TContainer, TResult> buffer, IAsyncDataController`1<Getter`1<TResult>> controller, IDataController`1<ProgressProvider> progress, ActionEvent cancel);
    [CompilerGeneratedAttribute]
private static TAccumulator <CreateSimple>b__0(TAccumulator v);
    [CompilerGeneratedAttribute]
private static TContainer <CreateRecycling>b__3(TContainer c);
    [CompilerGeneratedAttribute]
private static ProgressProvider <Prepare>b__4(ProgressProvider p);
    [CompilerGeneratedAttribute]
private static TContainer <CreateRecycling>b__6();
    [CompilerGeneratedAttribute]
private static TContainer <CreateRecycling>b__7();
}
public class JetBrains.Common.Util.EnumerationListeners.EnumerationListenerWithThreadSwitch`2 : ValueType {
    public EnumerationListener`1<TItem> Listener;
    public IThreadSwitch`1<TResult> Switch;
    public EnumerationListenerWithThreadSwitch`2(EnumerationListener`1<TItem> listener, IThreadSwitch`1<TResult> switch);
}
public class JetBrains.Common.Util.EnumerationListeners.EnumerationListenerWithThreadSwitch`3 : ValueType {
    public EnumerationListener`2<TItem, TArg> Listener;
    public IThreadSwitch`1<TResult> Switch;
    public EnumerationListenerWithThreadSwitch`3(EnumerationListener`2<TItem, TArg> listener, IThreadSwitch`1<TResult> switch);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.EnumerationListeners.Extensions : object {
    [ExtensionAttribute]
private static IEnumerable`1<T> AttachListener(IEnumerable`1<T> source, EnumerationListener`1<T> listener);
    [ExtensionAttribute]
public static EnumerationListener`1<T> Combine(EnumerationListener`1<T> l, EnumerationListener`1[] other);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static EnumerationListener`1<T> Combine(IEnumerable`1<EnumerationListener`1<T>> listeners);
    [ExtensionAttribute]
public static EnumerationListener`2<T, TArg> Combine(EnumerationListener`2<T, TArg> l, EnumerationListener`2[] other);
    [ExtensionAttribute]
public static EnumerationListener`2<T, TArg> Combine(IEnumerable`1<EnumerationListener`2<T, TArg>> listeners);
    [ExtensionAttribute]
public static IDataProvider`1<IEnumerable`1<T>> AttachListeners(IDataProvider`1<IEnumerable`1<T>> source, IDataProvider`1<IEnumerable`1<EnumerationListener`1<T>>> listenersProvider);
    [ExtensionAttribute]
public static IEnumerable`1<T> Attach(IEnumerable`1<T> source, EnumerationListener`1[] listeners);
    [ExtensionAttribute]
public static void Enumerate(IEnumerable`1<T> source, EnumerationListener`1[] listeners);
    [ExtensionAttribute]
public static SplittedEnumerationListener`2<T, TArg> Split(EnumerationListener`2<T, TArg> listener);
}
public class JetBrains.Common.Util.EnumerationListeners.SplittedEnumerationListener`2 : object {
    private EnumerationListener`2<T, TArg> myListener;
    private int myStarted;
    public SplittedEnumerationListener`2(EnumerationListener`2<T, TArg> listener);
    public EnumerationListener`2<T, TArg> CreateChild();
}
public class JetBrains.Common.Util.EnumerationListeners.VersionedContainer`1 : ValueType {
    public TContainer Container;
    public int Version;
    public VersionedContainer`1(TContainer container, int version);
}
public class JetBrains.Common.Util.Enumerator`1 : object {
    private IEnumerator`1<T> mySource;
    private bool myHasItems;
    public bool HasItems { get; }
    public Enumerator`1(IEnumerator`1<T> source);
    public bool get_HasItems();
    public T GetNext();
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.EnumExtensions : object {
    [ExtensionAttribute]
public static string GetDescription(Enum singleFlagEnumValue);
    [ExtensionAttribute]
public static IEnumerable`1<Enum> GetEnabledFlags(Enum value);
    [ExtensionAttribute]
public static TAttribute GetFirstOrDefaultEnumAttribute(TEnum value);
}
public class JetBrains.Common.Util.EventTracer : object {
    private static EventTracer ourDefaultInstance;
    private static EventProvider ourEventProvider;
    private static EventDescriptor ourPointEventDescriptor;
    private static EventDescriptor ourIntervalEventBeginDescriptor;
    private static EventDescriptor ourIntervalEventEndDescriptor;
    private static Dictionary`2<string, int> ourDomainIds;
    private static bool ourInitFailed;
    private int myNextId;
    private string myName;
    private int myDomainId;
    private WeakToStrongDictionary`2<object, string> myMap;
    private ReaderWriterLock myMapLock;
    [ThreadStaticAttribute]
private static List`1<string> ourDefaultRelatedObjects;
    [ThreadStaticAttribute]
private static Object[] ourBuffer;
    public bool IsEnabled { get; }
    private string DefaultRelatedObject { get; private set; }
    public static EventTracer Default { get; }
    private static EventTracer();
    public EventTracer(string name);
    public bool get_IsEnabled();
    private static void AssureRelatedObjectsInitialized();
    private string get_DefaultRelatedObject();
    private void set_DefaultRelatedObject(string value);
    public void SetDefaultRelatedObject(string id);
    public void ResetDefaultRelatedObject();
    private Object[] FillBuffer(string eventType, string relatedObject);
    public void TraceEvent(string eventType, string relatedObject);
    public void TraceEventBegin(string eventType, string relatedObject);
    public void TraceEventEnd();
    public void SetId(object o, string id);
    public static EventTracer get_Default();
    public string GetId(object o);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.Exceptions.ExceptionExtension : object {
    [ExtensionAttribute]
public static TException AddSimpleData(TException exception, string name, object value);
    [ExtensionAttribute]
public static void Rethrow(Exception exception);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.ExecutionControllerExtensions : object {
    [ExtensionAttribute]
public static void YieldAndProgress(IExecutionController controller);
    [ExtensionAttribute]
public static T WaitForResult(IExecutionController controller, ITask`1<T> task, int parentStepsCount, bool isShared);
    [ExtensionAttribute]
public static T ExecuteAsyncWithYields(IExecutionController controller, TimeSpan yieldFrequency, Func`1<T> asyncAction);
}
public class JetBrains.Common.Util.FilesEx : object {
    public static bool IsFileLocked(string fileName);
}
[ThreadSafeAttribute]
public class JetBrains.Common.Util.FixedSizeObjectPool`1 : object {
    [CanBeNullAttribute]
private AllocObjectDelegate<T> myAllocator;
    [NotNullAttribute]
private CreateObjectDelegate<T> myCreator;
    [CanBeNullAttribute]
private DisposeObjectDelegate<T> myDisposer;
    [NotNullAttribute]
private PoolEntry[] myPool;
    public FixedSizeObjectPool`1(int maxObjects, CreateObjectDelegate<T> creator, AllocObjectDelegate<T> allocator, DisposeObjectDelegate<T> disposer);
    public T Alloc();
    public void Dispose(T obj);
}
public class JetBrains.Common.Util.FormattedText.BackgroundColor : EnumPattern {
    public BackgroundColor(string name);
}
public static class JetBrains.Common.Util.FormattedText.BackgroundColors : object {
    public static BackgroundColor Transparent;
    public static BackgroundColor Highlight;
    private static BackgroundColors();
}
public class JetBrains.Common.Util.FormattedText.ForegroundColor : EnumPattern {
    public ForegroundColor(string name);
}
public static class JetBrains.Common.Util.FormattedText.ForegroundColors : object {
    public static ForegroundColor Default;
    public static ForegroundColor Grayed;
    public static ForegroundColor System;
    public static ForegroundColor Keyword;
    public static ForegroundColor Highlight;
    public static ForegroundColor Emphasized;
    public static ForegroundColor Hyperlink;
    private static ForegroundColors();
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Common.Util.FormattedText.FormattedText : object {
    private IList`1<FormattedTextPart> myParts;
    private PropertyChangedEventHandler PropertyChanged;
    public int Count { get; }
    public FormattedTextPart Item { get; }
    public IEnumerable`1<FormattedTextPart> Parts { get; }
    public FormattedText(FormattedTextPart[] parts);
    public FormattedText(IList`1<FormattedTextPart> parts);
    public void Append(string text);
    public void Append(string text, TextFormatting formatting);
    public void Append(FormattedTextPart part);
    public void Clear();
    public int get_Count();
    public FormattedTextPart get_Item(int index);
    public IEnumerable`1<FormattedTextPart> get_Parts();
    public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    public virtual string ToString();
}
public class JetBrains.Common.Util.FormattedText.FormattedTextBulder : object {
    private string myStr;
    private IList`1<TextFormatting> myFormattings;
    public FormattedTextBulder(string str, IList`1<TextFormatting> formattings);
    public FormattedTextBulder(string str);
    public void AddFormatting(int index, TextFormatting formatting);
    public FormattedText GetFormattedText();
    private FormattedText GetFormattedTextImp();
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.FormattedText.FormattedTextBulderEx : object {
    [ExtensionAttribute]
public static void AddFormatting(FormattedTextBulder builder, IEnumerable`1<int> indices, TextFormatting format);
}
public class JetBrains.Common.Util.FormattedText.FormattedTextPart : object {
    public string Text;
    public TextFormatting Formatting;
    public FormattedTextPart(string text);
    public static FormattedTextPart op_Implicit(string text);
    public static FormattedTextPart Bold(string text);
    public static FormattedTextPart Grayed(string text);
    public static FormattedTextPart Emphasised(string text);
    public static FormattedTextPart Italic(string text);
    public static FormattedTextPart NewLine();
}
public class JetBrains.Common.Util.FormattedText.FormattedTextVM : AAutomation {
    [CompilerGeneratedAttribute]
private FormattedText <Text>k__BackingField;
    public FormattedText Text { get; private set; }
    public FormattedTextVM(FormattedText text);
    [CompilerGeneratedAttribute]
public FormattedText get_Text();
    [CompilerGeneratedAttribute]
private void set_Text(FormattedText value);
}
public class JetBrains.Common.Util.FormattedText.FormattedURL : FormattedTextPart {
    [CompilerGeneratedAttribute]
private ICommand <ClickCommand>k__BackingField;
    public ICommand ClickCommand { get; private set; }
    public FormattedURL(string text, ICommand clickCommand);
    [CompilerGeneratedAttribute]
public ICommand get_ClickCommand();
    [CompilerGeneratedAttribute]
private void set_ClickCommand(ICommand value);
}
public class JetBrains.Common.Util.FormattedText.SelectableFormattedTextVM : AAutomation {
    [CompilerGeneratedAttribute]
private FormattedText <Text>k__BackingField;
    public FormattedText Text { get; private set; }
    public SelectableFormattedTextVM(FormattedText text);
    [CompilerGeneratedAttribute]
public FormattedText get_Text();
    [CompilerGeneratedAttribute]
private void set_Text(FormattedText value);
}
public class JetBrains.Common.Util.FormattedText.TextFormatting : ValueType {
    public TextFormattingFlags Flags;
    public ForegroundColor Foreground;
    public BackgroundColor Background;
    public static TextFormatting None;
    public static TextFormatting Bold;
    public static TextFormatting Italic;
    public static TextFormatting Grayed;
    public static TextFormatting Highlighted;
    public static TextFormatting Keyword;
    public static TextFormatting Emphasised;
    public bool IsBold { get; }
    public bool IsItalic { get; }
    public TextFormatting(TextFormattingFlags flags, ForegroundColor foreground, BackgroundColor background);
    public TextFormatting(ForegroundColor foreground, BackgroundColor background);
    private static TextFormatting();
    public bool get_IsBold();
    public bool get_IsItalic();
    public static TextFormatting op_BitwiseOr(TextFormatting f1, TextFormatting f2);
    public TextFormatting Merge(TextFormatting overridenFormatting);
}
[FlagsAttribute]
public enum JetBrains.Common.Util.FormattedText.TextFormattingFlags : Enum {
    public int value__;
    public static TextFormattingFlags None;
    public static TextFormattingFlags Bold;
    public static TextFormattingFlags Italic;
}
public class JetBrains.Common.Util.FullLifetime : object {
    private Lifetime myControlLifetime;
    private Lifetime myRuntimeLifetime;
    private PersistenceLifetime myPersistenceLifetime;
    internal Lifetime ControlLifetime { get; }
    public PersistenceLifetime PersistenceLifetime { get; }
    public Lifetime RuntimeLifetime { get; }
    internal FullLifetime(Lifetime runtimeLifetime, PersistenceLifetime persistenceLifetime, Lifetime controlLifetime);
    internal Lifetime get_ControlLifetime();
    public PersistenceLifetime get_PersistenceLifetime();
    public Lifetime get_RuntimeLifetime();
}
public class JetBrains.Common.Util.FullLifetimeDefinition : object {
    private static string ourLifetimeIdPrefix;
    private LifetimeDefinition myLifetimeDefinition;
    private FullLifetime myFullLifetime;
    private LifetimeDefinition myRuntimeLifetimeDefinition;
    public FullLifetime FullLifetime { get; }
    internal FullLifetimeDefinition(FullLifetime parentFullLifetime, string id);
    internal FullLifetimeDefinition(Lifetime parentRuntimeLifetime, string id);
    private static FullLifetimeDefinition();
    public FullLifetime get_FullLifetime();
    public void TerminateFull();
    public void TerminateRuntime();
    [CompilerGeneratedAttribute]
private void <.ctor>b__0();
    [CompilerGeneratedAttribute]
private void <.ctor>b__2();
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.FullLifetimeExtension : object {
    [ExtensionAttribute]
public static FullLifetimeDefinition CreateSubLifetimeDefinition(FullLifetime fullLifetime, string id);
    [ExtensionAttribute]
public static FullLifetimeDefinition CreateFullLifetimeDefinition(Lifetime runtimeLifetimeParent, string id);
    [ExtensionAttribute]
public static FullLifetimeDefinition CreateSubLifetimeDefinition(FullLifetime fullLifetime, Lifetime additionalRestriction, string id);
    [ExtensionAttribute]
public static FullLifetime CreateIntersection(FullLifetime fullLifetime, string id, FullLifetime other);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.FuncAccessor : object {
    public static IAccessor`1<T> Create(Func`2<Lifetime, T> getter);
    [ExtensionAttribute]
public static IAccessor`1<T> AsAccessor(T value);
    [ExtensionAttribute]
public static IAccessor`1<TB> TransformAccessor(IAccessor`1<TA> accessor, Func`3<TA, Lifetime, TB> converter);
    [ExtensionAttribute]
public static IAccessor`1<TB> TransformAccessor(IAccessor`1<TA> accessor, Func`2<TA, TB> converter);
    [ExtensionAttribute]
public static IAccessor`1<TB> TransformAccessorSafe(IAccessor`1<TA> accessor, Func`2<TA, TB> converter);
}
public class JetBrains.Common.Util.FuncAccessor`1 : object {
    private Func`2<Lifetime, T> myGetter;
    [ObsoleteAttribute("Use FuncAccessor.Create helper to deduct generic type.")]
public FuncAccessor`1(Func`2<Lifetime, T> getter);
    public sealed virtual T Get(Lifetime lifetime);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.FuncExtensions : object {
    [ExtensionAttribute]
public static Func`2<TA, TC> ApplyPartially(Func`3<TA, TB, TC> src, TB arg);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.Functional.FunctionalExtensions : object {
    [ExtensionAttribute]
public static T Apply(T it, Action`1<T> action);
}
public class JetBrains.Common.Util.GenericQuickSorter : object {
    private static int MaxDepth;
    public static void Sort(IArray`1<T> array, IComparer`1<T> comparer);
    public static void AccordingSort(IArray`1<TKey> keysArray, IArray`1<TValue> valuesArray, IComparer`1<TKey> comparer);
}
public class JetBrains.Common.Util.GenericStableSorter : object {
    public static void Sort(IList`1<T> list, IList`1<T> temp, IComparer`1<T> comparer);
    private static void SortList(IList`1<T> list, IList`1<T> temp, int startIndex, int endIndex, IComparer`1<T> comparer);
    private static void Merge(IList`1<T> list, IList`1<T> temp, int startIndex, int mediumIndex, int endIndex, IComparer`1<T> comparer);
    public static void Sort(IArray`1<T> list, IArray`1<T> temp, IComparer`1<T> comparer);
    private static void SortList(IArray`1<T> list, IArray`1<T> temp, int startIndex, int endIndex, IComparer`1<T> comparer);
    private static void Merge(IArray`1<T> list, IArray`1<T> temp, int startIndex, int mediumIndex, int endIndex, IComparer`1<T> comparer);
}
public class JetBrains.Common.Util.GetTopItemsVisitor`1 : object {
    private T myNullValue;
    private IComparer`1<T> myComparer;
    private T[] myTopItems;
    private T myMinItem;
    public T[] TopItems { get; }
    public GetTopItemsVisitor`1(int topItemsCount, T nullValue);
    public GetTopItemsVisitor`1(int topItemsCount, IComparer`1<T> comparer, T nullValue);
    public void Visit(T item);
    public T[] get_TopItems();
    [CompilerGeneratedAttribute]
private bool <get_TopItems>b__0(T _);
}
public interface JetBrains.Common.Util.IAccessor`1 {
    public abstract virtual T Get(Lifetime lifetime);
}
public interface JetBrains.Common.Util.IAccessorProvider`1 {
}
public interface JetBrains.Common.Util.IAccessorProviderContainer`1 {
}
[DefaultMemberAttribute("Item")]
public interface JetBrains.Common.Util.IArray`1 {
    public T Item { get; public set; }
    public abstract virtual T get_Item(int index);
    public abstract virtual void set_Item(int index, T value);
}
public interface JetBrains.Common.Util.IAsyncOperation {
    public string Title { get; }
    public int OperationProgress { get; }
    public IEnumerable`1<IAsyncOperation> SubOperations { get; }
    public bool Completed { get; }
    public Exception Exception { get; }
    public bool CanCancel { get; }
    public bool IsCanceled { get; }
    public abstract virtual string get_Title();
    public abstract virtual int get_OperationProgress();
    public abstract virtual void add_OperationProgressChanged(EventHandler`2<IAsyncOperation, ProgressChangedEventArgs> value);
    public abstract virtual void remove_OperationProgressChanged(EventHandler`2<IAsyncOperation, ProgressChangedEventArgs> value);
    public abstract virtual IEnumerable`1<IAsyncOperation> get_SubOperations();
    public abstract virtual bool get_Completed();
    public abstract virtual void add_Finished(EventHandler`2<ITask, EventArgs> value);
    public abstract virtual void remove_Finished(EventHandler`2<ITask, EventArgs> value);
    public abstract virtual Exception get_Exception();
    public abstract virtual bool get_CanCancel();
    public abstract virtual void Cancel();
    public abstract virtual bool get_IsCanceled();
}
public interface JetBrains.Common.Util.IAsyncOperation`1 {
    public abstract virtual TResult GetResult();
}
public interface JetBrains.Common.Util.IBackgroundProgressPresenter {
}
public interface JetBrains.Common.Util.IBinaryHeap`1 {
    public int Count { get; }
    public T Top { get; }
    public Comparison`1<T> Comparison { get; }
    public abstract virtual int get_Count();
    public abstract virtual T get_Top();
    public abstract virtual T Pop();
    public abstract virtual void Push(T value);
    public abstract virtual Comparison`1<T> get_Comparison();
}
public interface JetBrains.Common.Util.ICollectionSynchronizer {
    public abstract virtual void StartSynchronizing();
    public abstract virtual void StopSynchronizing();
}
public interface JetBrains.Common.Util.ICommandContainer {
    public ICommand Value { get; }
    public abstract virtual ICommand get_Value();
}
public interface JetBrains.Common.Util.IContextBoundSettingsFileLive {
    public IProperty`1<FileSystemPath> FilePath { get; }
    public abstract virtual IProperty`1<FileSystemPath> get_FilePath();
    public abstract virtual void Flush();
}
public interface JetBrains.Common.Util.IDataContainer`1 {
    public T Data { get; }
    public abstract virtual T get_Data();
}
[DefaultMemberAttribute("Item")]
public interface JetBrains.Common.Util.IDataMapper`2 {
    public TOut Item { get; }
    public abstract virtual TOut get_Item(TIn value);
}
public interface JetBrains.Common.Util.IExecutionController {
    public abstract virtual IExecutionController StartProgress(int stepsCount, string operationName);
    public abstract virtual IExecutionController CreateSubOperation(int parentStepsCount);
    public abstract virtual void AdvanceProgress();
}
public interface JetBrains.Common.Util.IForegroundProgressPresenter {
    public abstract virtual void InjectProgressIndicator(Lifetime lifetime, IProgressIndicator progress);
}
public interface JetBrains.Common.Util.IIndexedKey`1 {
    public abstract virtual T GetIndex();
    public abstract virtual void Delete();
}
public interface JetBrains.Common.Util.IKey`1 {
}
public interface JetBrains.Common.Util.IKeyBase`1 {
    public abstract virtual IProperty`1<TProperty> GetProperty(Expression`1<Func`2<TKey, TProperty>> lambda, Lifetime lifetime);
    public abstract virtual void ResetValue(Expression`1<Func`2<TKey, TProperty>> lambda);
    public abstract virtual void SetEntry(TKey key);
    public abstract virtual TKey GetEntry();
    public abstract virtual void SetIndexedValue(Expression`1<Func`2<TKey, IIndexedEntry`2<TEntryIndex, TEntryValue>>> lambda, TEntryIndex entryIndex, TEntryValue value);
    public abstract virtual TEntryValue GetIndexedValue(Expression`1<Func`2<TKey, IIndexedEntry`2<TEntryIndex, TEntryValue>>> lambda, TEntryIndex entryIndex);
    public abstract virtual IEnumerable`1<Pair`2<TEntryIndex, TEntryValue>> EnumerateIndexedValues(Expression`1<Func`2<TKey, IIndexedEntry`2<TEntryIndex, TEntryValue>>> lambda);
    public abstract virtual void RemoveIndexedValue(Expression`1<Func`2<TKey, IIndexedEntry`2<TEntryIndex, TEntryValue>>> lambda, TEntryIndex entryIndex);
}
public interface JetBrains.Common.Util.ILightExecutionController {
    public abstract virtual void AttachTask(ITask task, int parentStepsCount, bool isShared);
    public abstract virtual void WaitForTask(ITask task, int parentStepsCount, bool isShared);
    public abstract virtual void Yield();
}
public interface JetBrains.Common.Util.ILog {
    public abstract virtual void Catch(Action action);
    public abstract virtual T Catch(Func`1<T> func);
    public abstract virtual void LogExceptionSilently(Exception ex);
    public abstract virtual void LogMessage(string message);
    public abstract virtual void LogException(Exception ex);
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Common.Util.IndexableWrapper`1 : ValueType {
    private IList`1<T> myArray;
    public int Count { get; }
    public T Item { get; public set; }
    public IndexableWrapper`1(IList`1<T> array);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual int get_Count();
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
}
public static class JetBrains.Common.Util.Interop.Kernel32 : object {
    public static void CopyMemory(IntPtr dest, IntPtr src, UInt32 count);
    public static void CopyMemoryUnsafe(Byte* dest, Byte* src, UInt32 count);
}
public static class JetBrains.Common.Util.InterruptibleLazy : object {
    public static InterruptibleLazy`1<T> Of(Func`2<IExecutionController, T> valueFactory);
}
public class JetBrains.Common.Util.InterruptibleLazy`1 : object {
    [CanBeNullAttribute]
private Func`2<IExecutionController, T> myValueFactory;
    private SpinWaitLock myLock;
    private T myValue;
    public InterruptibleLazy`1(Func`2<IExecutionController, T> valueFactory);
    public T GetValue(IExecutionController controller);
    public virtual string ToString();
}
public class JetBrains.Common.Util.Interval : ValueType {
    [CompilerGeneratedAttribute]
private UInt32 <Position>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Length>k__BackingField;
    public UInt32 Position { get; public set; }
    public UInt32 Length { get; public set; }
    public Interval(UInt32 position, UInt32 length);
    [CompilerGeneratedAttribute]
public UInt32 get_Position();
    [CompilerGeneratedAttribute]
public void set_Position(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_Length();
    [CompilerGeneratedAttribute]
public void set_Length(UInt32 value);
    public sealed virtual bool Equals(Interval other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(Interval left, Interval right);
    public static bool op_Inequality(Interval left, Interval right);
    public virtual string ToString();
}
public interface JetBrains.Common.Util.IObservableSet`1 {
    public IDataProvider`1<IReadOnlyCollection`1<T>> Provider { get; }
    public abstract virtual void add_Changed(EventHandler`1<NotifySetChangedEventArgs`1<T>> value);
    public abstract virtual void remove_Changed(EventHandler`1<NotifySetChangedEventArgs`1<T>> value);
    public abstract virtual IDataProvider`1<IReadOnlyCollection`1<T>> get_Provider();
    public abstract virtual bool SetEquals(IEnumerable`1<T> other);
}
public interface JetBrains.Common.Util.IProgressPresenter {
    public abstract virtual void ShowOperationProgress(IAsyncOperation asyncOperation);
}
public interface JetBrains.Common.Util.IProviderContainer`1 {
}
public interface JetBrains.Common.Util.IProxyContainer`1 {
    unknown IDataProvider`1<T> Source {public set; }
    public abstract virtual void set_Source(IDataProvider`1<T> value);
}
public interface JetBrains.Common.Util.IReadOnlyMapping`2 {
}
public interface JetBrains.Common.Util.IRemotablePairContainer`1 {
}
public interface JetBrains.Common.Util.IRemotableReferenceContainer`1 {
}
public interface JetBrains.Common.Util.IRemoteProviderContainer`1 {
}
public interface JetBrains.Common.Util.ISearchable`1 {
    public abstract virtual int IndexOf(T item);
}
public interface JetBrains.Common.Util.ISequentialTaskExecutor {
    public bool HasRunningTask { get; }
    public abstract virtual bool get_HasRunningTask();
    public abstract virtual bool ExecuteExclusively(ITask task);
    public abstract virtual void Enqueue(ITask task);
    public abstract virtual bool CancelAllTasks();
}
public interface JetBrains.Common.Util.ISettings {
    public abstract virtual void CreateIndexedKey(Type settingKeyType, object indexKey, IDictionary`2<Type, object> parentIndex);
    public abstract virtual void DeleteIndexedKey(Type settingKeyType, object indexKey, IDictionary`2<Type, object> parentIndex);
    public abstract virtual void SetKey(Type settingKeyType, object value, object indexKey, IDictionary`2<Type, object> parentIndexKeys);
    public abstract virtual object GetKey(Type settingKeyType, object indexKey, IDictionary`2<Type, object> parentIndexKeys);
    public abstract virtual void ResetValue(Expression`1<Func`2<TKey, TProperty>> lambda, object indexKey);
    public abstract virtual IProperty`1<TProperty> GetProperty(Expression`1<Func`2<TKey, TProperty>> lambda, object indexKey, Lifetime lifetime, IDictionary`2<Type, object> parentIndexKeys);
    public abstract virtual TEntryValue GetIndexedValue(Expression`1<Func`2<TKey, IIndexedEntry`2<TEntryIndex, TEntryValue>>> lambda, TEntryIndex entryIndex, object indexKey, IDictionary`2<Type, object> parentIndexKeys);
    public abstract virtual void SetIndexedValue(Expression`1<Func`2<TKey, IIndexedEntry`2<TEntryIndex, TEntryValue>>> lambda, TEntryIndex entryIndex, TEntryValue value, object indexKey, IDictionary`2<Type, object> parentIndexKeys);
    public abstract virtual void RemoveIndexedValue(Expression`1<Func`2<TKey, IIndexedEntry`2<TEntryIndex, TEntryValue>>> lambda, TEntryIndex entryIndex, object indexKey, IDictionary`2<Type, object> parentIndexKeys);
    public abstract virtual IEnumerable`1<Pair`2<TEntryIndex, TEntryValue>> EnumerateIndexedValues(Expression`1<Func`2<TKey, IIndexedEntry`2<TEntryIndex, TEntryValue>>> lambda, object indexKey, IDictionary`2<Type, object> parentIndexKeys);
    public abstract virtual IEnumerable`1<object> EnumKeyIndices(Type settingKeyType, IDictionary`2<Type, object> parentIndexKeys);
    public abstract virtual IEnumerable`1<Pair`2<object, object>> EnumerateIndexedKeys(Type settingKeyType, IDictionary`2<Type, object> parentIndexKeys, bool ignoreKeyIsDefined);
    public abstract virtual void AdviseChange(Action callback, Type settingKeyType, Lifetime lifetime);
    public abstract virtual void AdviseChange(Expression`1<Func`2<TKey, TValue>> lambdaexpression, Action callback, Lifetime lifetime);
}
public interface JetBrains.Common.Util.ISettingsFile {
    public IProperty`1<FileSystemPath> SettingsFilePath { get; }
    public abstract virtual IProperty`1<FileSystemPath> get_SettingsFilePath();
    public abstract virtual void Flush();
}
public interface JetBrains.Common.Util.ITask {
    public EventWaitHandle FinishedEvent { get; }
    public abstract virtual void Execute(ITaskExecutionEnvironment environment);
    public abstract virtual EventWaitHandle get_FinishedEvent();
}
public interface JetBrains.Common.Util.ITask`1 {
}
public interface JetBrains.Common.Util.ITaskExecutionEnvironment {
    public abstract virtual void Cancel(ITask sender);
    public abstract virtual void Yield(ITask sender);
    public abstract virtual void WaitForTask(ITask sender, ITask otherTask, bool isShared);
    public abstract virtual void AttachTask(ITask sender, ITask otherTask, bool isShared);
}
public interface JetBrains.Common.Util.ITryGetValue`2 {
    public abstract virtual bool TryGetValue(TKey key, TValue& value);
}
public interface JetBrains.Common.Util.ITwoStepDisposable {
    public abstract virtual void PrepareForDispose();
    public abstract virtual void Dispose();
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Common.Util.JetBitArray : object {
    private static int ElementSize;
    private ChunkArray`1<int> myArray;
    private int myElementSizeLog2;
    private int myIndexInElementMask;
    private int myArrayLength;
    public int Length { get; }
    public bool Item { get; public set; }
    public JetBitArray(int bitArrayLength);
    public JetBitArray(IList`1<bool> boolArray);
    public int get_Length();
    public bool get_Item(int index);
    public void set_Item(int index, bool value);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.JetCollectionExtensions : object {
    [ExtensionAttribute]
public static IReadOnlyCollection`1<T> AsReadonlyCollection(ICollection`1<T> collection);
    [ExtensionAttribute]
public static IReadOnlyCollection`1<T> AsReadonlyCollection(IEnumerable`1<T> sequence, int count);
    [ExtensionAttribute]
public static IReadOnlyList`1<T> AsReadonlyList(IList`1<T> list);
    [ExtensionAttribute]
public static IReadOnlyList`1<T> ToReadonlyList(IEnumerable`1<T> sequence);
    [ExtensionAttribute]
public static JetList`1<T> ToJetList(IEnumerable`1<T> enumerable);
}
public class JetBrains.Common.Util.JetList`1 : List`1<T> {
    public JetList`1(int capacity);
    public JetList`1(IEnumerable`1<T> collection);
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Common.Util.JetReadOnlyDictionary`2 : object {
    [NotNullAttribute]
private IDictionary`2<TKey, TValue> mySource;
    [CanBeNullAttribute]
private ReadOnlyCollectionWrapper`1<TKey> myKeys;
    public int Count { get; }
    public TValue Item { get; }
    public IReadOnlyCollection`1<TKey> Keys { get; }
    [NotNullAttribute]
public IEnumerable`1<TValue> Values { get; }
    private IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Keys { get; }
    public JetReadOnlyDictionary`2(IDictionary`2<TKey, TValue> source);
    public sealed virtual int get_Count();
    public sealed virtual TValue get_Item(TKey key);
    public IReadOnlyCollection`1<TKey> get_Keys();
    public sealed virtual IEnumerable`1<TValue> get_Values();
    public sealed virtual bool ContainsKey(TKey key);
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    public TValue GetValueSafe(TKey key, TValue fallbackValue);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Keys();
}
public static class JetBrains.Common.Util.JetThread : object {
    public static bool VolatileRead(Boolean& address);
    public static void VolatileWrite(Boolean& address, bool value);
    public static T VolatileRead(T& address);
    public static void VolatileWrite(T& address, T value);
}
public class JetBrains.Common.Util.LCSResult : ValueType {
    public Pair`2<int, int> MatchIndicies;
    public int Length;
    public LCSResult(int length, Pair`2<int, int> matchIndicies);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.LifetimeExtension : object {
    [ExtensionAttribute]
public static LifetimeDefinition CreateSubLifetimeDefinition(Lifetime lifetime, string id, Lifetime[] additionalRestrictions);
    [ExtensionAttribute]
public static LifetimeDefinition CreateSubLifetimeDefinition(Lifetime lifetime, string id);
    [ExtensionAttribute]
public static Lifetime CreateSubLifetime(Lifetime lifetime, string id);
    [ExtensionAttribute]
public static Lifetime CreateSubLifetime(Lifetime lifetime, string id, Lifetime[] additionalRestrictions);
    [ExtensionAttribute]
public static T CreateDisposable(Lifetime lifetime, Func`1<T> createDisposable);
    [ExtensionAttribute]
public static T AddBracket(Lifetime lifetime, Func`1<T> openBracket, Action`1<T> closeBracket);
    [ConditionalAttribute("JET_MODE_ASSERT")]
public static void ReportCreated(string id);
    [ExtensionAttribute]
[ConditionalAttribute("JET_MODE_ASSERT")]
public static void ReportTerminated(Lifetime lifetime, string id);
    [CompilerGeneratedAttribute]
private static void <CreateDisposable>b__0(T _);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.LifetimeExtensions : object {
    [ExtensionAttribute]
public static Lifetime CreateLifetime(IAsyncOperation operation, IThreading threading, Lifetime parentLifetime);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.LightEventExtensions : object {
    [ExtensionAttribute]
public static void Raise(LightEventHandler`1<T> event, T arg);
    [ExtensionAttribute]
public static void Raise(LightEventHandler event);
}
public class JetBrains.Common.Util.LightEventHandler : MulticastDelegate {
    public LightEventHandler(object object, IntPtr method);
    public virtual void Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class JetBrains.Common.Util.LightEventHandler`1 : MulticastDelegate {
    public LightEventHandler`1(object object, IntPtr method);
    public virtual void Invoke(TArgs args);
    public virtual IAsyncResult BeginInvoke(TArgs args, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.ListEventsExtensions : object {
    [ExtensionAttribute]
public static void FlowIntoSorted(ICollectionEvents`1<TSource> source, Lifetime lifetime, IListEvents`1<TTarget> target, IComparer`1<TSource> comparer, Func`3<Lifetime, TSource, TTarget> converter);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.ListExtenstions : object {
    [ExtensionAttribute]
public static void StableSort(IList`1<T> array, Comparison`1<T> comparison);
    [ExtensionAttribute]
public static void StableSort(IList`1<T> array);
    [ExtensionAttribute]
public static void AddAndResize(IList`1<T> list, int index, T element, T defaultValue);
    [ExtensionAttribute]
public static bool RemoveIfContains(IList`1<T> list, T element);
    [ExtensionAttribute]
public static IEnumerable`1<T> Slice(IList`1<T> source, CollectionRange range);
    [ExtensionAttribute]
public static IEnumerable`1<CollectionRange> FindSequentialRanges(IList`1<T> source, Func`3<T, T, bool> cmp);
    [ExtensionAttribute]
public static IEnumerable`1<IEnumerable`1<T>> GroupSameSequential(IList`1<T> source, Func`3<T, T, bool> cmp);
    [ExtensionAttribute]
public static IList`1<T> CopyAndAdd(IList`1<T> source, T[] elements);
    [CompilerGeneratedAttribute]
private static bool <FindSequentialRanges>b__0(T arg1, T arg2);
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Common.Util.ListSlice`1 : object {
    private List`1<T> myList;
    private int myStartIndex;
    private int myLength;
    private int myLastExclusiveIndex;
    public int Count { get; }
    public T Item { get; }
    public ListSlice`1(List`1<T> list, int startIndex, int length);
    public int get_Count();
    public T get_Item(int index);
    public Enumerator<T> GetEnumerator();
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.LOHSafeSortingExtensions : object {
    [ExtensionAttribute]
public static IReadOnlyList`1<TSource> LOHSafeOrderBy(IEnumerable`1<TSource> source);
    [ExtensionAttribute]
public static IReadOnlyList`1<TSource> LOHSafeOrderBy(IEnumerable`1<TSource> source, IComparer`1<TSource> comparer);
    [ExtensionAttribute]
public static IReadOnlyList`1<TSource> LOHSafeOrderBy(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector);
    [ExtensionAttribute]
public static IReadOnlyList`1<TSource> LOHSafeOrderBy(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static IReadOnlyList`1<TSource> LOHSafeOrderBy(IReadOnlyCollection`1<TSource> source, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static IReadOnlyList`1<TSource> LOHSafeOrderBy(IReadOnlyCollection`1<TSource> source);
    [ExtensionAttribute]
public static IReadOnlyList`1<TSource> LOHSafeOrderBy(IReadOnlyCollection`1<TSource> source, Func`2<TSource, TKey> keySelector);
    [ExtensionAttribute]
public static IReadOnlyList`1<TSource> LOHSafeOrderBy(IReadOnlyCollection`1<TSource> source, IComparer`1<TSource> comparer);
    [ExtensionAttribute]
public static IReadOnlyList`1<TSource> LOHSafeOrderBy(TSource[] source, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static IReadOnlyList`1<TSource> LOHSafeOrderBy(TSource[] source);
    [ExtensionAttribute]
public static IReadOnlyList`1<TSource> LOHSafeOrderBy(TSource[] source, IComparer`1<TSource> comparer);
    [ExtensionAttribute]
public static IReadOnlyList`1<TSource> LOHSafeOrderBy(TSource[] source, Func`2<TSource, TKey> keySelector);
    [ExtensionAttribute]
public static IReadOnlyList`1<TSource> LOHSafeOrderBy(ICollection`1<TSource> source, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> comparer);
    [CompilerGeneratedAttribute]
private static TSource <LOHSafeOrderBy>b__0(TSource _);
    [CompilerGeneratedAttribute]
private static TSource <LOHSafeOrderBy>b__1(TSource _);
    [CompilerGeneratedAttribute]
private static TSource <LOHSafeOrderBy>b__2(TSource _);
    [CompilerGeneratedAttribute]
private static TSource <LOHSafeOrderBy>b__3(TSource _);
    [CompilerGeneratedAttribute]
private static TSource <LOHSafeOrderBy>b__4(TSource _);
    [CompilerGeneratedAttribute]
private static TSource <LOHSafeOrderBy>b__5(TSource _);
}
public static class JetBrains.Common.Util.LongestCommonSubsequence : object {
    public static LCSResult Calculate(IList`1<T> a, IList`1<T> b, IEqualityComparer`1<T> comparer);
    private static LCSResult CalculateImpl(int startIndex, IList`1<T> a, int aEnd, IList`1<T> b, int bEnd, IEqualityComparer`1<T> comparer);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.MathExtension : object {
    [ExtensionAttribute]
public static int DivUp(int a, int b);
    [ExtensionAttribute]
public static UInt32 DivUp(UInt32 a, UInt32 b);
    [ExtensionAttribute]
public static long DivUp(long a, long b);
    [ExtensionAttribute]
public static ulong DivUp(ulong a, ulong b);
}
public static class JetBrains.Common.Util.MathUtils : object {
    public static byte Log2(ulong value);
    public static int SafeCast(double value);
    public static int SafeRound(double value);
    public static int GetDigits(double value);
}
public class JetBrains.Common.Util.Maybe`1 : object {
    public static Maybe`1<T> Nothing;
    private T myValue;
    private bool myHasValue;
    public T Value { get; }
    public bool HasValue { get; }
    public Maybe`1(T value);
    private static Maybe`1();
    public T get_Value();
    public bool get_HasValue();
    public sealed virtual bool Equals(Maybe`1<T> other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.MaybeExtensions : object {
    [ExtensionAttribute]
public static Maybe`1<T> ToMaybe(T value);
    [ExtensionAttribute]
[ContractAnnotationAttribute("null=>true")]
public static bool IsEmpty(Maybe`1<T> maybe);
}
public class JetBrains.Common.Util.Metadata.FunctionId : ValueType {
    private UInt32 myValue;
    private FunctionId(UInt32 value);
    public static FunctionId Create(UInt32 id);
    public static FunctionId Create(string value);
    public static UInt32 op_Explicit(FunctionId value);
    public static FunctionId op_Explicit(UInt32 value);
    public static bool op_Equality(FunctionId op1, FunctionId op2);
    public static bool op_Inequality(FunctionId op1, FunctionId op2);
    public sealed virtual bool Equals(FunctionId other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public enum JetBrains.Common.Util.Metadata.FunctionType : Enum {
    public int value__;
    public static FunctionType Synthetic;
    public static FunctionType Core;
    public static FunctionType ETWManaged;
    public static FunctionType ETWNative;
    public static FunctionType ETWModuleOnly;
    public static FunctionType Address;
    public static FunctionType CoreIndexed;
    public static FunctionType MatchWithCore;
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.Metadata.FunctionTypeEx : object {
    [ExtensionAttribute]
public static bool IsFunction(FunctionUID fuid);
    [ExtensionAttribute]
public static bool IsCoreRelated(FunctionType type);
    [ExtensionAttribute]
public static bool IsManaged(FunctionType type);
    [ExtensionAttribute]
public static bool ScopeAndMergeDisabled(FunctionUID fuid);
}
public class JetBrains.Common.Util.Metadata.FunctionUID : ValueType {
    private static int TotalBitsCount;
    private static int TypeBitsCount;
    public static int TypeOffset;
    private static int ShiftBitsCount;
    private static int ShortIndexBitsCount;
    private static int ShiftOffset;
    private static ulong TypeMask;
    private static ulong LongIndexMask;
    private static ulong ShortIndexMask;
    private static int ETWSyntheticTypeBitsCount;
    private static int ETWSyntheticTypeOffset;
    private static ulong ETWSyntheticTypeMask;
    private static int SubsystemTypeBitsCount;
    private static int SubsystemTypeOffset;
    private static ulong SubsystemTypeMask;
    private static int GeneratedTypeBitsCount;
    private static int GeneratedTypeOffset;
    private static ulong GeneratedTypeMask;
    private static int SyntheticTypeBitsCount;
    private static ulong SyntheticIndexMask;
    private static ulong ShiftMask;
    public static FunctionUID Invalid;
    public static FunctionUID Unknown;
    public static FunctionUID Unresolved;
    public static FunctionUID NoCallStack;
    public static FunctionUID SkippedDynamic;
    public static FunctionUID Root;
    public static FunctionUID AllCalls;
    public static FunctionUID Continuation;
    public static FunctionUID Awaits;
    public static FunctionUID TaskScheduled;
    public static FunctionUID TaskExecution;
    public static FunctionUID TaskRecursion;
    public static FunctionUID StackTracesWithoutMethods;
    public static FunctionUID Uninitialized;
    private ulong myValue;
    public FunctionType Type { get; }
    public bool IsResolved { get; }
    public ulong Index { get; }
    public bool IsSynthetic { get; }
    public bool IsAsyncRelated { get; }
    public bool IsTaskRelated { get; }
    public bool IsAlwaysSystem { get; }
    private FunctionUID(ulong value);
    private static FunctionUID();
    public FunctionType get_Type();
    public bool get_IsResolved();
    public UInt32 Shift();
    private ulong TypeBits();
    public ulong get_Index();
    private ulong IndexBits();
    public bool get_IsSynthetic();
    private static bool IsSyntheticType(FunctionType type);
    public sealed virtual bool Equals(FunctionUID other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(FunctionUID left, FunctionUID right);
    public static bool op_Inequality(FunctionUID left, FunctionUID right);
    private ulong GetIndexMask();
    private static ulong GetIndexMask(FunctionType functionType);
    public FunctionUID IgnoreShift();
    private ulong MeaningfulHeadBits();
    private ulong SyntheticTypeBits();
    public sealed virtual int CompareTo(FunctionUID other);
    public virtual string ToString();
    public static FunctionUID Create(ulong key);
    public static FunctionUID CreateSynthetic(SyntheticType syntheticType);
    public static FunctionUID Create(FunctionType type, ulong index);
    public static FunctionUID Create(FunctionType type, ulong index, int shift);
    public static FunctionUID CreateSubsystem(ulong index);
    private static FunctionUID CreateSyntheticWithMask(ulong mask, ulong index);
    public static FunctionUID CreateGenerated(GeneratedType generatedType, ulong index);
    [PureAttribute]
public ulong AsUlong();
    public FunctionUID CopyShiftFrom(FunctionUID other);
    private ulong ShiftBits();
    public SyntheticType GetSyntheticType();
    public GeneratedType GetGeneratedType();
    [PureAttribute]
public Nullable`1<SubsystemEventType> GetSubsystemEventTypes();
    public bool get_IsAsyncRelated();
    public bool get_IsTaskRelated();
    public bool get_IsAlwaysSystem();
}
public enum JetBrains.Common.Util.Metadata.GeneratedType : Enum {
    public byte value__;
    public static GeneratedType None;
    public static GeneratedType Task;
    public static GeneratedType Max;
}
public class JetBrains.Common.Util.Metadata.InvalidFunctionTypeException : Exception {
    public InvalidFunctionTypeException(FunctionType type);
}
public class JetBrains.Common.Util.Metadata.InvalidFunctionUidException : Exception {
    public InvalidFunctionUidException(string message, FunctionType type, ulong index);
}
public class JetBrains.Common.Util.Metadata.MethodViewData : ValueType {
    public FunctionUID Id;
    private MethodType Type;
    public string Namespace;
    public string ClassName;
    public string MethodName;
    public string AssemblyName;
    public Version AssemblyVersion;
    public bool IsSystem;
    public bool IsSpecial { get; }
    public bool IsGc { get; }
    public string FullName { get; }
    private MethodViewData(MethodType methodType, string ns, string className, string methodName, bool isSystem, FunctionUID functionId, string assemblyName, Version assemblyVersion);
    public bool get_IsSpecial();
    public bool get_IsGc();
    public string get_FullName();
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(MethodViewData other);
    public virtual int GetHashCode();
    public static MethodViewData CreateSpecial(string shortMethodName, FunctionUID id);
    public static MethodViewData CreateGc(string shortMethodName, FunctionUID id);
    public static MethodViewData CreateWithoutAssembly(string ns, string className, string shortMethodName, FunctionUID id);
    public static MethodViewData Create(string ns, string className, string shortMethodName, bool isSystemFunction, string assemblyName, Version assemblyVersion, FunctionUID id);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.Metadata.Parser.CharIEnumerableEx : object {
    [CompilerGeneratedAttribute]
private static Func`3<StringBuilder, char, StringBuilder> CS$<>9__CachedAnonymousMethodDelegate1;
    [ExtensionAttribute]
public static string AsString(IEnumerable`1<char> charSequence);
    [CompilerGeneratedAttribute]
private static StringBuilder <AsString>b__0(StringBuilder builder, char c);
}
public static class JetBrains.Common.Util.Metadata.Parser.MethodNameParser : object {
    [CompilerGeneratedAttribute]
private static Func`2<char, bool> CS$<>9__CachedAnonymousMethodDelegate1;
    [CompilerGeneratedAttribute]
private static Func`2<char, bool> CS$<>9__CachedAnonymousMethodDelegate3;
    private static IEnumerable`1<char> ChopOffNestedGeneratedClasses(IEnumerable`1<char> name);
    public static IEnumerable`1<char> ClassNameWithoutParameters(IEnumerable`1<char> namespace);
    public static IEnumerable`1<char> GetClassFQN(IEnumerable`1<char> namespaceWithClass);
    public static IEnumerable`1<char> DropBackSlashes(IEnumerable`1<char> namespace);
    public static IEnumerable`1<char> ChopOffGenericParameters(IEnumerable`1<char> name);
    public static string EnclosingMethodName(string name);
    public static IEnumerable`1<char> EnclosingMethodName(IEnumerable`1<char> name);
    public static NamespaceAndIdentifier ExtractNamespaceAndClassName(IEnumerable`1<char> name);
    private static NamespaceAndIdentifier SplitByDot(string string, int lastDotIndex);
    public static NamespaceAndIdentifier ExtractInterfaceAndMemberName(IEnumerable`1<char> name);
    private static int FindLastCharAngleBrackets(IEnumerable`1<char> name, char character);
    private static IEnumerable`1<char> ExtractEnclosingMethod(IEnumerable`1<char> name);
    public static bool IsLambdaMethodName(IEnumerable`1<char> name);
    public static IEnumerable`1<char> SkipEnclosingMethodNamespace(IEnumerable`1<char> methodName);
    public static string PresentableMethodName(IEnumerable`1<char> methodName);
    [CompilerGeneratedAttribute]
private static bool <DropBackSlashes>b__0(char c);
    [CompilerGeneratedAttribute]
private static bool <ChopOffGenericParameters>b__2(char c);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.Metadata.Parser.MyParsingExtensions : object {
    [ExtensionAttribute]
public static IEnumerable`1<T> SkipLast(IEnumerable`1<T> source, int count);
    [ExtensionAttribute]
public static string StringConcatenate(IEnumerable`1<string> source);
    [ExtensionAttribute]
public static IEnumerable`1<T> SelectNested(IEnumerable`1<T> collection, T openBracket, T closingBracket, Func`4<int, T, int, T> indexItemDepthToItem);
    [ExtensionAttribute]
public static void ForEachNested(IEnumerable`1<T> name, T openBracket, T closingBracket, Action`3<int, T, int> indexItemDepthAction);
    [ExtensionAttribute]
public static int LastNested(IEnumerable`1<T> name, T openBracket, T closingBracket, T itemToFind, int searchOnDepth);
}
public class JetBrains.Common.Util.Metadata.Parser.NamespaceAndIdentifier : ValueType {
    public string Identifier;
    public string Namespace;
    public NamespaceAndIdentifier(string ns, string identifier);
    public static string SafeRemoveLast(string sequence, int count);
    public virtual string ToString();
}
[FlagsAttribute]
public enum JetBrains.Common.Util.Metadata.SubsystemEventType : Enum {
    public byte value__;
    public static SubsystemEventType None;
    [DescriptionAttribute("File I/O")]
public static SubsystemEventType FileIO;
    [DescriptionAttribute("JIT")]
public static SubsystemEventType Jit;
    [DescriptionAttribute("GC Wait")]
public static SubsystemEventType GC;
    [DescriptionAttribute("Lock contention")]
public static SubsystemEventType Contention;
    [DescriptionAttribute("SQL query")]
public static SubsystemEventType Sql;
    [DescriptionAttribute("Waiting for CPU")]
public static SubsystemEventType CpuReady;
    [DescriptionAttribute("Awaiting Time")]
public static SubsystemEventType Awaits;
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.Metadata.SubsystemEventTypeEx : object {
    public static string FileIO;
    public static string Jit;
    public static string GcWait;
    public static string LockContention;
    public static string SqlQuery;
    public static string WaitingForCPU;
    public static string AwaitingTime;
    [CompilerGeneratedAttribute]
private static Func`2<Enum, string> CS$<>9__CachedAnonymousMethodDelegate1;
    [ExtensionAttribute]
public static IEnumerable`1<string> FlagDescriptions(SubsystemEventType this);
    [CompilerGeneratedAttribute]
private static string <FlagDescriptions>b__0(Enum f);
}
public enum JetBrains.Common.Util.Metadata.SyntheticType : Enum {
    public int value__;
    public static SyntheticType GlobalRoot;
    public static SyntheticType TruncatedCallstackRoot;
    public static SyntheticType GluedTruncatedCallstack;
}
public static class JetBrains.Common.Util.Multithreading.InterlockedEx : object {
    public static int CompareExchange(IntPtr ptr, int newVal, int expectedVal);
    public static long CompareExchange(IntPtr ptr, long newVal, long expectedVal);
}
public class JetBrains.Common.Util.Multithreading.MemoryLock : object {
    private IntPtr myPtr;
    public MemoryLock(IntPtr ptr);
    public sealed virtual void Lock();
    public sealed virtual void Unlock();
}
[AttributeUsageAttribute("192")]
public class JetBrains.Common.Util.Multithreading.ThreadSafetyAttribute : Attribute {
    public ThreadSafetyType Type;
    public ThreadSafetyAttribute(ThreadSafetyType type);
}
public enum JetBrains.Common.Util.Multithreading.ThreadSafetyType : Enum {
    public int value__;
    public static ThreadSafetyType MainThread;
    public static ThreadSafetyType Sequential;
    public static ThreadSafetyType Multithreaded;
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Common.Util.NativeString : object {
    private IntPtr myStartPtr;
    private int myByteCount;
    private bool myIsFinalizable;
    public static NativeString Empty;
    public int Length { get; }
    public int ByteCount { get; }
    public char Item { get; }
    public NativeString(IntPtr startPtr, int byteCount);
    private NativeString(IntPtr startPtr, int byteCount, bool isFinalizable);
    private static NativeString();
    public static NativeString FromString(string string);
    public static NativeString ReadUntilNullChar(IntPtr startPtr);
    public virtual string ToString();
    public int get_Length();
    public int get_ByteCount();
    public NativeString Substring(int startPosition);
    public NativeString Substring(int startPosition, int length);
    public char get_Item(int index);
    public int IndexOf(char c);
    public bool StartsWith(string target);
    protected virtual void Finalize();
    public sealed virtual bool Equals(NativeString other);
    public sealed virtual bool Equals(string other);
    public bool Equals(IEnumerable`1<char> other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(NativeString left, NativeString right);
    public static bool op_Inequality(NativeString left, NativeString right);
    public sealed virtual IEnumerator`1<char> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.NotifyPropertyChangedUtils : object {
    [ExtensionAttribute]
public static void OnChanged(T obj, Lifetime lifetime, Expression`1<Func`2<T, TP>> property, Action action);
}
public enum JetBrains.Common.Util.NotifySetChangeAction : Enum {
    public int value__;
    public static NotifySetChangeAction Reset;
    public static NotifySetChangeAction Add;
    public static NotifySetChangeAction Remove;
}
public class JetBrains.Common.Util.NotifySetChangedEventArgs`1 : EventArgs {
    public NotifySetChangeAction Action;
    public T Item;
    private NotifySetChangedEventArgs`1(NotifySetChangeAction action, T item);
    public static NotifySetChangedEventArgs`1<T> Add(T item);
    public static NotifySetChangedEventArgs`1<T> Remove(T item);
    public static NotifySetChangedEventArgs`1<T> Reset();
}
public class JetBrains.Common.Util.NullExecutionController : object {
    public static IExecutionController Instance;
    private static NullExecutionController();
    public sealed virtual void Dispose();
    public sealed virtual IExecutionController StartProgress(int stepsCount, string operationName);
    public sealed virtual IExecutionController CreateSubOperation(int parentStepsCount);
    public sealed virtual void Yield();
    public sealed virtual void AdvanceProgress();
    public sealed virtual void AttachTask(ITask task, int parentStepsCount, bool isShared);
    public sealed virtual void WaitForTask(ITask task, int parentStepsCount, bool isShared);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.ObjectEx : object {
    [ExtensionAttribute]
public static int GetHashCodeSafe(T o);
}
public class JetBrains.Common.Util.ObservableSet`1 : object {
    private ISet`1<T> mySource;
    private IDataProvider`1<IReadOnlyCollection`1<T>> myReadonlyCollectionProvider;
    private EventHandler`1<NotifySetChangedEventArgs`1<T>> Changed;
    private NotifyCollectionChangedEventHandler CollectionChanged;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public IDataProvider`1<IReadOnlyCollection`1<T>> Provider { get; }
    public ObservableSet`1(IEnumerable`1<T> source);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual bool Remove(T item);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual void add_Changed(EventHandler`1<NotifySetChangedEventArgs`1<T>> value);
    public sealed virtual void remove_Changed(EventHandler`1<NotifySetChangedEventArgs`1<T>> value);
    public sealed virtual IDataProvider`1<IReadOnlyCollection`1<T>> get_Provider();
    public sealed virtual void add_CollectionChanged(NotifyCollectionChangedEventHandler value);
    public sealed virtual void remove_CollectionChanged(NotifyCollectionChangedEventHandler value);
    public virtual string ToString();
    public sealed virtual bool SetEquals(IEnumerable`1<T> other);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.ObservableSetEx : object {
    [ExtensionAttribute]
public static IDataProvider`1<T> CreateLastAddedItemProvider(IObservableSet`1<T> set);
    [ExtensionAttribute]
public static void ResetToValue(IObservableSet`1<T> set, T newValue);
    [ExtensionAttribute]
public static void ToggleValue(IObservableSet`1<T> set, T newValue);
    [ExtensionAttribute]
public static void SyncWith(IObservableSet`1<T> this, IEnumerable`1<T> other);
}
[UsedImplicitlyAttribute]
public class JetBrains.Common.Util.PerformanceCounters.AsyncPerformanceCountersStateNotifier : object {
    private static int TimeForTimelineInitializationAttemptsInMilliseconds;
    private static int TimeBetweenInitializationAttemptsInMilliseconds;
    private static int AttemptsCounts;
    private IList`1<ISingleCategoryPerformanceCounterFactory> myFactories;
    private Lifetime myLifetime;
    private int myProcessId;
    private IThreading myThreading;
    [CompilerGeneratedAttribute]
private IProperty`1<PerformanceCountersState> <State>k__BackingField;
    [CompilerGeneratedAttribute]
private static Func`2<string, bool> CS$<>9__CachedAnonymousMethodDelegate3;
    public IProperty`1<PerformanceCountersState> State { get; private set; }
    public AsyncPerformanceCountersStateNotifier(IList`1<ISingleCategoryPerformanceCounterFactory> factories, IThreading threading, int processId, Lifetime lifetime);
    [CompilerGeneratedAttribute]
public IProperty`1<PerformanceCountersState> get_State();
    [CompilerGeneratedAttribute]
private void set_State(IProperty`1<PerformanceCountersState> value);
    private bool ProcessInstanceNamesCanBeResolved();
    private void CheckIfCountersAvailable(object o);
    private void NotifyCountersAvailability(bool isAvailable);
    [CompilerGeneratedAttribute]
private string <ProcessInstanceNamesCanBeResolved>b__0(ISingleCategoryPerformanceCounterFactory f);
    [CompilerGeneratedAttribute]
private static bool <ProcessInstanceNamesCanBeResolved>b__1(string name);
}
public class JetBrains.Common.Util.PerformanceCounters.CompositionPerformanceCounter`1 : object {
    private Func`1<T> myLambda;
    public T NextValue { get; }
    public CompositionPerformanceCounter`1(Func`1<T> lambda);
    public sealed virtual T get_NextValue();
}
[UsedImplicitlyAttribute]
public class JetBrains.Common.Util.PerformanceCounters.DotNetLocksAntThreadsPerformanceCountersFactory : SingleCategoryPerformanceCountersFactoryBase {
    public PerformanceCountersCategoryId Id { get; }
    public sealed virtual IPerformanceCounter`1<double> CreateQueueLengthPerSec(string instanceName, Lifetime lifetime);
    public virtual PerformanceCountersCategoryId get_Id();
}
[UsedImplicitlyAttribute]
public class JetBrains.Common.Util.PerformanceCounters.DotNetMemoryPerformanceCountersFactory : SingleCategoryPerformanceCountersFactoryBase {
    public PerformanceCountersCategoryId Id { get; }
    public sealed virtual IPerformanceCounter`1<double> CreateGen0(string instanceName, Lifetime lifetime);
    public sealed virtual IPerformanceCounter`1<double> CreateGen1(string instanceName, Lifetime lifetime);
    public sealed virtual IPerformanceCounter`1<double> CreateGen2(string instanceName, Lifetime lifetime);
    public sealed virtual IPerformanceCounter`1<double> CreateLOH(string instanceName, Lifetime lifetime);
    public virtual PerformanceCountersCategoryId get_Id();
}
public interface JetBrains.Common.Util.PerformanceCounters.IDotNetLocksAntThreadsPerformanceCountersFactory {
    public abstract virtual IPerformanceCounter`1<double> CreateQueueLengthPerSec(string instanceName, Lifetime lifetime);
}
public interface JetBrains.Common.Util.PerformanceCounters.IDotNetMemoryPerformanceCountersFactory {
    public abstract virtual IPerformanceCounter`1<double> CreateGen0(string instanceName, Lifetime lifetime);
    public abstract virtual IPerformanceCounter`1<double> CreateGen1(string instanceName, Lifetime lifetime);
    public abstract virtual IPerformanceCounter`1<double> CreateGen2(string instanceName, Lifetime lifetime);
    public abstract virtual IPerformanceCounter`1<double> CreateLOH(string instanceName, Lifetime lifetime);
}
public interface JetBrains.Common.Util.PerformanceCounters.IPerformanceCounter`1 {
    public T NextValue { get; }
    public abstract virtual T get_NextValue();
}
public interface JetBrains.Common.Util.PerformanceCounters.IPerformanceCountersFactory {
    public int ProcessId { get; }
    public abstract virtual PerformanceCountersHolder CreateCountersHolder(IEnumerable`1<PerformanceCounterId> counterIds, Lifetime lifetime);
    public abstract virtual IPerformanceCounter`1<long> CreatePIDCounter(PerformanceCountersCategoryId categoryId, Lifetime lifetime);
    public abstract virtual IPerformanceCounter`1<double> CreateCounter(PerformanceCounterId counterId, Lifetime lifetime);
    public abstract virtual int get_ProcessId();
}
public interface JetBrains.Common.Util.PerformanceCounters.IProcessPerformanceCountersFactory {
    public abstract virtual IPerformanceCounter`1<double> CreatePrivateBytes(string instanceName, Lifetime lifetime);
    public abstract virtual IPerformanceCounter`1<double> CreateCPU(string instanceName, Lifetime lifetime);
    public abstract virtual IPerformanceCounter`1<double> CreateIODataBytesPerSec(string instanceName, Lifetime lifetime);
}
public interface JetBrains.Common.Util.PerformanceCounters.ISingleCategoryPerformanceCounterFactory {
    public PerformanceCountersCategoryId Id { get; }
    public abstract virtual string ResolveInstanceName(int pid);
    public abstract virtual IPerformanceCounter`1<long> CreatePIDPerformanceCounter(string instanceName, Lifetime lifetime);
    public abstract virtual PerformanceCountersCategoryChecker CreateCategoryChecker(int pid, string instanceName, Lifetime lifetime);
    public abstract virtual PerformanceCountersCategoryId get_Id();
}
public enum JetBrains.Common.Util.PerformanceCounters.PerformanceCounterId : Enum {
    public int value__;
    public static PerformanceCounterId UnusedIdStub;
    public static PerformanceCounterId Gen0HeapSize;
    public static PerformanceCounterId Gen1HeapSize;
    public static PerformanceCounterId Gen2HeapSize;
    public static PerformanceCounterId LOHSize;
    public static PerformanceCounterId PrivateBytes;
    public static PerformanceCounterId CPU;
    public static PerformanceCounterId IODataBytesPerSec;
    public static PerformanceCounterId BlockedThreads;
}
public class JetBrains.Common.Util.PerformanceCounters.PerformanceCountersCategoryChecker : object {
    private int myPID;
    private IPerformanceCounter`1<long> myPidCounter;
    public PerformanceCountersCategoryChecker(IPerformanceCounter`1<long> pidCounter, int pid);
    public bool IsAvailable();
}
public enum JetBrains.Common.Util.PerformanceCounters.PerformanceCountersCategoryId : Enum {
    public int value__;
    public static PerformanceCountersCategoryId DotNetMemory;
    public static PerformanceCountersCategoryId Process;
    public static PerformanceCountersCategoryId DotNetLocksAndThreads;
}
[UsedImplicitlyAttribute]
public class JetBrains.Common.Util.PerformanceCounters.PerformanceCountersFactory : object {
    private IDotNetMemoryPerformanceCountersFactory myDotNetMemoryFactory;
    private int myPID;
    private IProcessPerformanceCountersFactory myProcessFactory;
    private IDotNetLocksAntThreadsPerformanceCountersFactory myLocksAndThreadsFactory;
    public int ProcessId { get; }
    public PerformanceCountersFactory(int pid, IDotNetMemoryPerformanceCountersFactory dotNetMemoryFactory, IProcessPerformanceCountersFactory processFactory, IDotNetLocksAntThreadsPerformanceCountersFactory locksAndThreadsFactory);
    public sealed virtual PerformanceCountersHolder CreateCountersHolder(IEnumerable`1<PerformanceCounterId> counterIds, Lifetime lifetime);
    public sealed virtual IPerformanceCounter`1<long> CreatePIDCounter(PerformanceCountersCategoryId categoryId, Lifetime lifetime);
    public sealed virtual IPerformanceCounter`1<double> CreateCounter(PerformanceCounterId counterId, Lifetime lifetime);
    public sealed virtual int get_ProcessId();
    private PerformanceCountersCategoryChecker CreateChecker(KeyValuePair`2<PerformanceCountersCategoryId, string> categoryNamePair, Lifetime lifetime);
    private ISingleCategoryPerformanceCounterFactory GetFactory(PerformanceCountersCategoryId categoryId);
    private IPerformanceCounter`1<double> CreateCounter(PerformanceCounterId counterId, IDictionary`2<PerformanceCountersCategoryId, string> cache, Lifetime lifetime);
    private string GetInstanceName(IDictionary`2<PerformanceCountersCategoryId, string> cache, ISingleCategoryPerformanceCounterFactory factory);
}
public class JetBrains.Common.Util.PerformanceCounters.PerformanceCountersHolder : object {
    private IList`1<PerformanceCountersCategoryChecker> myCategoryCheckers;
    private IList`1<IPerformanceCounter`1<double>> myCounters;
    [CompilerGeneratedAttribute]
private static Func`2<PerformanceCountersCategoryChecker, bool> CS$<>9__CachedAnonymousMethodDelegate1;
    public PerformanceCountersHolder(IList`1<IPerformanceCounter`1<double>> counters, IList`1<PerformanceCountersCategoryChecker> categoryCheckers);
    private void TryFillDataImpl(Double[] data);
    private bool CategoriesAreAvailable();
    public bool TryFillData(Double[] data);
    [CompilerGeneratedAttribute]
private static bool <CategoriesAreAvailable>b__0(PerformanceCountersCategoryChecker checker);
}
public enum JetBrains.Common.Util.PerformanceCounters.PerformanceCountersState : Enum {
    public int value__;
    public static PerformanceCountersState NotAvailable;
    public static PerformanceCountersState Initializing;
    public static PerformanceCountersState Ready;
}
public class JetBrains.Common.Util.PerformanceCounters.PerformanceCounterWrapper : object {
    private PerformanceCounter myCounter;
    public double NextValue { get; }
    public PerformanceCounterWrapper(PerformanceCounter counter);
    public sealed virtual double get_NextValue();
}
[UsedImplicitlyAttribute]
public class JetBrains.Common.Util.PerformanceCounters.ProcessPerformanceCountersFactory : SingleCategoryPerformanceCountersFactoryBase {
    public PerformanceCountersCategoryId Id { get; }
    public sealed virtual IPerformanceCounter`1<double> CreatePrivateBytes(string instanceName, Lifetime lifetime);
    public sealed virtual IPerformanceCounter`1<double> CreateCPU(string instanceName, Lifetime lifetime);
    public sealed virtual IPerformanceCounter`1<double> CreateIODataBytesPerSec(string instanceName, Lifetime lifetime);
    public virtual PerformanceCountersCategoryId get_Id();
}
public class JetBrains.Common.Util.PerformanceCounters.ProcessSwitchingPerformanceCountersFactory : object {
    private DotNetLocksAntThreadsPerformanceCountersFactory myDotNetLocksAntThreads;
    private DotNetMemoryPerformanceCountersFactory myDotNetMemory;
    private object myLock;
    private ProcessPerformanceCountersFactory myProcess;
    private PerformanceCountersFactory myFactory;
    public int ProcessId { get; }
    public ProcessSwitchingPerformanceCountersFactory(int processId);
    public sealed virtual PerformanceCountersHolder CreateCountersHolder(IEnumerable`1<PerformanceCounterId> counterIds, Lifetime lifetime);
    public sealed virtual IPerformanceCounter`1<long> CreatePIDCounter(PerformanceCountersCategoryId categoryId, Lifetime lifetime);
    public sealed virtual IPerformanceCounter`1<double> CreateCounter(PerformanceCounterId counterId, Lifetime lifetime);
    public sealed virtual int get_ProcessId();
    public void SwitchProcess(int processId);
}
public abstract class JetBrains.Common.Util.PerformanceCounters.SingleCategoryPerformanceCountersFactoryBase : object {
    private static int MaxAttemptsForProcessPidResolving;
    private static int MaxProcessIndexToTry;
    private static int PidResolvingAttemptSpan;
    private string myCategoryName;
    private string myPidCounterName;
    private string myPidResolvingCategoryName;
    public PerformanceCountersCategoryId Id { get; }
    public SingleCategoryPerformanceCountersFactoryBase(string categoryName, string pidCounterName);
    public SingleCategoryPerformanceCountersFactoryBase(string categoryName, string pidCounterName, string pidResolvingCategoryName);
    public sealed virtual string ResolveInstanceName(int pid);
    private static string ProcessExecutablePath(int pid);
    private static string Get64BitProcessExecutablePathFrom32(Process process);
    private void FillInstanceResolveFailException(int pid, InvalidOperationException ex);
    public sealed virtual IPerformanceCounter`1<long> CreatePIDPerformanceCounter(string instanceName, Lifetime lifetime);
    public sealed virtual PerformanceCountersCategoryChecker CreateCategoryChecker(int pid, string instanceName, Lifetime lifetime);
    public abstract virtual PerformanceCountersCategoryId get_Id();
    protected IPerformanceCounter`1<double> CreatePerformanceCounter(string counterName, string instanceName, Lifetime lifetime);
    private PerformanceCounter CreatePerformanceCounterImpl(string categoryName, string counterName, string instanceName, Lifetime lifetime);
    private string GetInstanceNameForProcess(int instanceCount, string instanceNameWithoutNumber, int pid);
    private string GetInstanceNameForProcess(string instanceName, int pid);
    [CompilerGeneratedAttribute]
private object <FillInstanceResolveFailException>b__1();
    [CompilerGeneratedAttribute]
private object <FillInstanceResolveFailException>b__2();
    [CompilerGeneratedAttribute]
private object <CreatePerformanceCounterImpl>b__8();
}
public class JetBrains.Common.Util.PersistenceLifetime : object {
    public static PersistenceLifetime Eternal;
    private Lifetime myLifetime;
    internal PersistenceLifetime(Lifetime lifetime);
    private static PersistenceLifetime();
    public Lifetime AsLifetime();
}
public class JetBrains.Common.Util.PlatformLog : object {
    public static PlatformLog Instance;
    private static PlatformLog();
    public sealed virtual void Catch(Action action);
    public sealed virtual T Catch(Func`1<T> func);
    public sealed virtual void LogExceptionSilently(Exception ex);
    public sealed virtual void LogMessage(string message);
    public sealed virtual void LogException(Exception ex);
}
public class JetBrains.Common.Util.Pluralizer : object {
    private static String[] ExceptionWordsDirectAddS;
    private static String[] ExceptionWordsIrregularInput;
    private static String[] ExceptionWordsIrregularOutput;
    private static String[] ExceptionWordsNoPlural;
    private static Pluralizer();
    public static string GetPlural(string nounString);
}
public class JetBrains.Common.Util.Primitives.ComparableNullable`1 : ValueType {
    public Nullable`1<T> Value;
    public ComparableNullable`1(Nullable`1<T> value);
    public sealed virtual int CompareTo(ComparableNullable`1<T> other);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.Primitives.ComparableNullableEx : object {
    [ExtensionAttribute]
public static ComparableNullable`1<T> ToComparable(Nullable`1<T> value);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.Primitives.PairEx : object {
    [ExtensionAttribute]
public static KeyValuePair`2<K, V> PairWith(K key, V value);
}
public class JetBrains.Common.Util.Primitives.SafeCommand : object {
    private Func`1<ICommand> myCreateCommand;
    private JetWeakReference`1<ICommand> myCommand;
    private PropertyChangedEventHandler PropertyChanged;
    public ICommand Value { get; }
    public SafeCommand(Func`1<ICommand> createCommand);
    public sealed virtual ICommand get_Value();
    public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
}
public class JetBrains.Common.Util.Primitives.UnsafeCommand : object {
    private PropertyChangedEventHandler PropertyChanged;
    [CompilerGeneratedAttribute]
private ICommand <Value>k__BackingField;
    public ICommand Value { get; private set; }
    public UnsafeCommand(ICommand value);
    public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual ICommand get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(ICommand value);
}
public class JetBrains.Common.Util.ProgressChangedEventArgs : EventArgs {
    public int Progress;
    public ProgressChangedEventArgs(int newValue);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.ProgressIndicatorEx : object {
    [ExtensionAttribute]
public static ProgressProvider ToProgressProvider(IProgressIndicatorModel progressIndicator);
    private static int ToFraction(double value);
    private static AsyncComputationState ToState(bool isRunning, int fraction);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.ProgressIndicatorExtension : object {
    [ExtensionAttribute]
public static IExecutionController CreateBridge(IExecutionController executionController, IProgressIndicator progressIndicator);
    [ExtensionAttribute]
public static IExecutionController CreateExecutionController(IProgressIndicator progressIndicator);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.ProgressPresenterExtenions : object {
    [ExtensionAttribute]
public static void Associate(IProgressPresenter presenter, IAsyncOperation operation);
}
public class JetBrains.Common.Util.ProgressProvider : object {
    private IDataProvider`1<int> myValue;
    private IDataProvider`1<AsyncComputationState> myState;
    private IDataProvider`1<string> myTitle;
    [NotNullAttribute]
public IDataProvider`1<int> Value { get; }
    [NotNullAttribute]
public IDataProvider`1<AsyncComputationState> State { get; }
    [CanBeNullAttribute]
public IDataProvider`1<string> Title { get; }
    public ProgressProvider(IDataProvider`1<string> title, IDataProvider`1<int> value, IDataProvider`1<AsyncComputationState> state);
    public IDataProvider`1<int> get_Value();
    public IDataProvider`1<AsyncComputationState> get_State();
    public IDataProvider`1<string> get_Title();
}
public class JetBrains.Common.Util.ProgressProviderAdapter : object {
    private IDataSink`1<int> myProgressSink;
    private IDataSink`1<AsyncComputationState> myStateSink;
    private IDataSink`1<string> myTitleSink;
    private PropertyChangedEventHandler PropertyChanged;
    private EventHandler`2<IAsyncOperation, ProgressChangedEventArgs> OperationProgressChanged;
    private EventHandler`2<ITask, EventArgs> Finished;
    public string Title { get; }
    public int OperationProgress { get; }
    public IEnumerable`1<IAsyncOperation> SubOperations { get; }
    public bool Completed { get; }
    public Exception Exception { get; }
    public bool CanCancel { get; }
    public bool IsCanceled { get; }
    public ProgressProviderAdapter(Lifetime lifetime, ProgressProvider progress);
    public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    public sealed virtual string get_Title();
    public sealed virtual int get_OperationProgress();
    public sealed virtual void add_OperationProgressChanged(EventHandler`2<IAsyncOperation, ProgressChangedEventArgs> value);
    public sealed virtual void remove_OperationProgressChanged(EventHandler`2<IAsyncOperation, ProgressChangedEventArgs> value);
    public sealed virtual IEnumerable`1<IAsyncOperation> get_SubOperations();
    public sealed virtual bool get_Completed();
    public sealed virtual void add_Finished(EventHandler`2<ITask, EventArgs> value);
    public sealed virtual void remove_Finished(EventHandler`2<ITask, EventArgs> value);
    public sealed virtual Exception get_Exception();
    public sealed virtual bool get_CanCancel();
    public sealed virtual void Cancel();
    public sealed virtual bool get_IsCanceled();
    [CompilerGeneratedAttribute]
private void <.ctor>b__0(int step);
    [CompilerGeneratedAttribute]
private void <.ctor>b__1(AsyncComputationState state);
    [CompilerGeneratedAttribute]
private void <.ctor>b__2(string title);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.ProgressProviderEx : object {
    [CompilerGeneratedAttribute]
private static Action`1<ProgressProvider[]> CS$<>9__CachedAnonymousMethodDelegate4;
    [CompilerGeneratedAttribute]
private static Func`2<IEnumerable`1<ProgressProvider>, ProgressProvider> CS$<>9__CachedAnonymousMethodDelegatec;
    [CompilerGeneratedAttribute]
private static Func`2<IEnumerable`1<ProgressProvider>, ProgressProvider> CS$<>9__CachedAnonymousMethodDelegatee;
    [CompilerGeneratedAttribute]
private static Func`2<ProgressProvider, IDataProvider`1<Pair`2<AsyncComputationState, string>>> CS$<>9__CachedAnonymousMethodDelegate15;
    [CompilerGeneratedAttribute]
private static Func`2<IDataProvider`1[], IDataProvider`1<string>> CS$<>9__CachedAnonymousMethodDelegate16;
    [CompilerGeneratedAttribute]
private static Func`2<ProgressProvider, IDataProvider`1<int>> CS$<>9__CachedAnonymousMethodDelegate17;
    [CompilerGeneratedAttribute]
private static Func`2<IDataProvider`1[], IDataProvider`1<Int32[]>> CS$<>9__CachedAnonymousMethodDelegate18;
    [CompilerGeneratedAttribute]
private static Func`2<ProgressProvider, IDataProvider`1<AsyncComputationState>> CS$<>9__CachedAnonymousMethodDelegate19;
    [CompilerGeneratedAttribute]
private static Func`2<IDataProvider`1[], IDataProvider`1<AsyncComputationState>> CS$<>9__CachedAnonymousMethodDelegate1a;
    [CompilerGeneratedAttribute]
private static Func`2<Pair`2<AsyncComputationState, string>, bool> CS$<>9__CachedAnonymousMethodDelegate1d;
    [CompilerGeneratedAttribute]
private static Func`2<Pair`2<AsyncComputationState, string>, string> CS$<>9__CachedAnonymousMethodDelegate1e;
    [CompilerGeneratedAttribute]
private static Func`2<Int32[], int> CS$<>9__CachedAnonymousMethodDelegate29;
    [CompilerGeneratedAttribute]
private static Func`2<ProgressProvider, IDataProvider`1<int>> CS$<>9__CachedAnonymousMethodDelegate30;
    [CompilerGeneratedAttribute]
private static Func`2<ProgressProvider, IDataProvider`1<string>> CS$<>9__CachedAnonymousMethodDelegate31;
    [CompilerGeneratedAttribute]
private static Func`2<ProgressProvider, IDataProvider`1<AsyncComputationState>> CS$<>9__CachedAnonymousMethodDelegate32;
    [CompilerGeneratedAttribute]
private static Func`2<ProgressProvider, IDataProvider`1<int>> CS$<>9__CachedAnonymousMethodDelegate3a;
    [CompilerGeneratedAttribute]
private static Func`2<ProgressProvider, IDataProvider`1<AsyncComputationState>> CS$<>9__CachedAnonymousMethodDelegate3b;
    [CompilerGeneratedAttribute]
private static Func`2<ProgressProvider, IDataProvider`1<string>> CS$<>9__CachedAnonymousMethodDelegate3c;
    [ExtensionAttribute]
public static ProgressProvider Single(IDataProvider`1<ProgressProvider[]> progresses);
    [ExtensionAttribute]
public static ProgressProvider Normalize(ProgressProvider provider);
    private static AsyncComputationState MergeStates(AsyncComputationState[] states);
    [ExtensionAttribute]
public static ProgressProvider FirstOrDefault(IDataProvider`1<IEnumerable`1<ProgressProvider>> providers);
    [ExtensionAttribute]
public static ProgressProvider LastOrDefault(IDataProvider`1<IEnumerable`1<ProgressProvider>> providers);
    [ExtensionAttribute]
public static ProgressProvider Merge(IDataProvider`1<ProgressProvider[]> progresses, Func`2<Int32[], int> merger, string title);
    private static string MergeTitles(Pair`2[] statesWithTitles);
    [ExtensionAttribute]
public static ProgressProvider FlowInto(ProgressProvider progressProvider, IExecutionController executionController, Lifetime lifetime);
    [ExtensionAttribute]
public static ProgressProvider FlowInto(ProgressProvider progressProvider, IProgressIndicator progressIndicator, Lifetime lifetime);
    private static Func`2<Int32[], int> CreateEqualProgressMerger();
    private static Func`2<Int32[], int> CreateProgressMerger(double firstPart);
    [ExtensionAttribute]
public static ProgressProvider SwitchLocal(IRemotableReference`1<ProgressProvider> progress);
    [ExtensionAttribute]
public static IRemotableReference`1<ProgressProvider> SendToRemote(ProgressProvider progress, IRemoteCommunicator comm);
    [ExtensionAttribute]
public static IRemotableReference`1<IDataProvider`1<ProgressProvider>> SendToRemote(IDataProvider`1<ProgressProvider> progress, IRemoteCommunicator comm);
    [CompilerGeneratedAttribute]
private static void <Single>b__0(ProgressProvider[] p);
    [CompilerGeneratedAttribute]
private static ProgressProvider <FirstOrDefault>b__b(IEnumerable`1<ProgressProvider> e);
    [CompilerGeneratedAttribute]
private static ProgressProvider <LastOrDefault>b__d(IEnumerable`1<ProgressProvider> e);
    [CompilerGeneratedAttribute]
private static IDataProvider`1<Pair`2<AsyncComputationState, string>> <Merge>b__f(ProgressProvider p);
    [CompilerGeneratedAttribute]
private static IDataProvider`1<string> <Merge>b__10(IDataProvider`1[] p);
    [CompilerGeneratedAttribute]
private static IDataProvider`1<int> <Merge>b__11(ProgressProvider p);
    [CompilerGeneratedAttribute]
private static IDataProvider`1<Int32[]> <Merge>b__12(IDataProvider`1[] p);
    [CompilerGeneratedAttribute]
private static IDataProvider`1<AsyncComputationState> <Merge>b__13(ProgressProvider p);
    [CompilerGeneratedAttribute]
private static IDataProvider`1<AsyncComputationState> <Merge>b__14(IDataProvider`1[] p);
    [CompilerGeneratedAttribute]
private static bool <MergeTitles>b__1b(Pair`2<AsyncComputationState, string> p);
    [CompilerGeneratedAttribute]
private static string <MergeTitles>b__1c(Pair`2<AsyncComputationState, string> p);
    [CompilerGeneratedAttribute]
private static int <CreateEqualProgressMerger>b__28(Int32[] values);
    [CompilerGeneratedAttribute]
private static IDataProvider`1<int> <SwitchLocal>b__2d(ProgressProvider p);
    [CompilerGeneratedAttribute]
private static IDataProvider`1<string> <SwitchLocal>b__2e(ProgressProvider p);
    [CompilerGeneratedAttribute]
private static IDataProvider`1<AsyncComputationState> <SwitchLocal>b__2f(ProgressProvider p);
    [CompilerGeneratedAttribute]
private static IDataProvider`1<int> <SendToRemote>b__36(ProgressProvider p);
    [CompilerGeneratedAttribute]
private static IDataProvider`1<AsyncComputationState> <SendToRemote>b__37(ProgressProvider p);
    [CompilerGeneratedAttribute]
private static IDataProvider`1<string> <SendToRemote>b__38(ProgressProvider p);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.PropertyExtensions : object {
    [ExtensionAttribute]
public static void ExecuteOnValueChangeOnce(IProperty`1<T> property, Lifetime lifetime, T value, Action action);
    [ExtensionAttribute]
public static void ExecuteOnValueChangeOnce(IProperty`1<T> property, Lifetime lifetime, IEnumerable`1<T> values, Action action);
}
public static class JetBrains.Common.Util.PtrToStructure`1 : object {
    private static CastSingleDelegate<T> ourCastSingleDelegate;
    private static Nullable`1<bool> ourCanCast;
    [CompilerGeneratedAttribute]
private static Func`2<IntPtr, T> CS$<>9__CachedAnonymousMethodDelegate1;
    public static bool CanCast { get; }
    private static PtrToStructure`1();
    public static bool get_CanCast();
    public static T Cast(IntPtr ptr);
    public static T Convert(IntPtr ptr);
    private static bool IsBlittable();
    public static T Cast(Byte* ptr);
    public static T Convert(Byte* ptr);
    private static CastSingleDelegate<T> CreateCastSingleDelegate();
    public static Func`2<IntPtr, T> CreateConverter();
    [CompilerGeneratedAttribute]
private static T <CreateConverter>b__0(IntPtr ptr);
}
public class JetBrains.Common.Util.ReadOnlyCollectionWrapper`1 : object {
    [CompilerGeneratedAttribute]
private ICollection`1<T> <Source>k__BackingField;
    public ICollection`1<T> Source { get; public set; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    public ReadOnlyCollectionWrapper`1(ICollection`1<T> source);
    [CompilerGeneratedAttribute]
public ICollection`1<T> get_Source();
    [CompilerGeneratedAttribute]
public void set_Source(ICollection`1<T> value);
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual int get_Count();
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.Remove(T item);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Common.Util.ReadonlyListSegment`1 : ValueType {
    private IReadOnlyList`1<T> myArray;
    private int myStartIndex;
    private int myLength;
    private int myLastExclusiveIndex;
    public int Count { get; }
    public T Item { get; }
    public ReadonlyListSegment`1(IReadOnlyList`1<T> array, int startIndex, int length);
    public sealed virtual int get_Count();
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual T get_Item(int index);
}
public class JetBrains.Common.Util.RemotableTree.AsyncTreeRequestProcessor`3 : object {
    private IDataController`1<TreeUpdateRequest`2<TKey, TUserState>> myRequestController;
    private Action`1<TreeUpdateResponse`2<TKey, TInfo>> ResponseReceived;
    public AsyncTreeRequestProcessor`3(DataPipeLifetime lifetime, ITreeService`3<TKey, TInfo, TUserState> treeService);
    private void OnResponse(TreeUpdateResponse`2<TKey, TInfo> response);
    public sealed virtual void SendRequest(TreeUpdateRequest`2<TKey, TUserState> request);
    public sealed virtual void add_ResponseReceived(Action`1<TreeUpdateResponse`2<TKey, TInfo>> value);
    public sealed virtual void remove_ResponseReceived(Action`1<TreeUpdateResponse`2<TKey, TInfo>> value);
    public sealed virtual void add_TreeUpdated(Action value);
    public sealed virtual void remove_TreeUpdated(Action value);
}
public class JetBrains.Common.Util.RemotableTree.ChangeableTreeRequestProcessor`3 : object {
    private ITreeRequestProcessor`3<TKey, TInfo, TUserState> myCurrentProcessor;
    private Queue`1<TreeUpdateRequest`2<TKey, TUserState>> myPendingRequests;
    private IDataController`1<bool> myIsActive;
    private Action`1<TreeUpdateResponse`2<TKey, TInfo>> myResponseReceived;
    private Action myTreeUpdated;
    public ChangeableTreeRequestProcessor`3(IDataProvider`1<ITreeRequestProcessor`3<TKey, TInfo, TUserState>> provider);
    private void OnTreeUpdated();
    public sealed virtual void SendRequest(TreeUpdateRequest`2<TKey, TUserState> request);
    private void add_myResponseReceived(Action`1<TreeUpdateResponse`2<TKey, TInfo>> value);
    private void remove_myResponseReceived(Action`1<TreeUpdateResponse`2<TKey, TInfo>> value);
    private void add_myTreeUpdated(Action value);
    private void remove_myTreeUpdated(Action value);
    public sealed virtual void add_ResponseReceived(Action`1<TreeUpdateResponse`2<TKey, TInfo>> value);
    public sealed virtual void remove_ResponseReceived(Action`1<TreeUpdateResponse`2<TKey, TInfo>> value);
    public sealed virtual void add_TreeUpdated(Action value);
    public sealed virtual void remove_TreeUpdated(Action value);
    protected virtual void OnResponseReceived(TreeUpdateResponse`2<TKey, TInfo> obj);
    [CompilerGeneratedAttribute]
private void <.ctor>b__0(Lifetime lt, ITreeRequestProcessor`3<TKey, TInfo, TUserState> value);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.RemotableTree.Helpers : object {
    [ExtensionAttribute]
public static ITreeRequestProcessor`3<TKey, TInfo, TUserState> CreateSyncRequestProcessor(ITreeService`3<TKey, TInfo, TUserState> builder);
    [ExtensionAttribute]
public static ITreeRequestProcessor`3<TKey, TInfo, TUserState> CreateAsyncRequestProcessor(ITreeService`3<TKey, TInfo, TUserState> builder, DataPipeLifetime lifetime);
    [ExtensionAttribute]
public static ITreeRequestProcessor`3<TKey, TInfo, TUserState> CreateRemoteRequestProcessor(IRemotableReference`1<IDataProvider`1<ITreeService`3<TKey, TInfo, TUserState>>> builderProvider, IRemotablePair`1<DataPipeLifetime> lifetime);
    [ExtensionAttribute]
public static ITreeRequestProcessor`3<TKey, TInfo, TUserState> Flatten(IDataProvider`1<ITreeRequestProcessor`3<TKey, TInfo, TUserState>> provider);
}
public interface JetBrains.Common.Util.RemotableTree.ITree`1 {
    [NotNullAttribute]
public ITreeListStructureProvider`1<ITreeNodeViewModel> StructureProvider { get; }
    public IDataController`1<TreeNode`2<TKey, ITreeNodeViewModel>> SelectedNode { get; }
    public TreeNode`2<TKey, ITreeNodeViewModel> Root { get; }
    [NotNullAttribute]
public TKey[] RootPrefix { get; }
    public abstract virtual ITreeListStructureProvider`1<ITreeNodeViewModel> get_StructureProvider();
    public abstract virtual IDataController`1<TreeNode`2<TKey, ITreeNodeViewModel>> get_SelectedNode();
    public abstract virtual TreeNode`2<TKey, ITreeNodeViewModel> get_Root();
    public abstract virtual TKey[] get_RootPrefix();
    public abstract virtual IEnumerable`1<TKey> GetNodePrefix(TreeNode`2<TKey, ITreeNodeViewModel> node);
}
public interface JetBrains.Common.Util.RemotableTree.ITreeNodeFactory`3 {
    public abstract virtual TViewModel CreateNodeViewModel(TInfo info, TKey key, object responseData);
    public abstract virtual TViewModel CreateFakeRootNode();
    public abstract virtual TViewModel CreateLoadingRootNode(TKey key);
}
public interface JetBrains.Common.Util.RemotableTree.ITreeNodeInfo {
    public bool IsExpandable { get; }
    public bool IsExpandedByDefault { get; }
    public bool IsTaskRecursionFolded { get; }
    public abstract virtual bool get_IsExpandable();
    public abstract virtual bool get_IsExpandedByDefault();
    public abstract virtual bool get_IsTaskRecursionFolded();
}
public interface JetBrains.Common.Util.RemotableTree.ITreeNodePathItemState {
}
public interface JetBrains.Common.Util.RemotableTree.ITreeNodeUserState {
    public Nullable`1<bool> IsExpanded { get; public set; }
    public bool IsChanged { get; }
    public abstract virtual Nullable`1<bool> get_IsExpanded();
    public abstract virtual void set_IsExpanded(Nullable`1<bool> value);
    public abstract virtual bool get_IsChanged();
}
public interface JetBrains.Common.Util.RemotableTree.ITreeNodeViewModel {
    public bool IsExpanded { get; public set; }
    public bool IsPrefixNode { get; }
    public bool IsSelected { get; public set; }
    public bool IsExpandable { get; }
    public ITreeNodeViewModel Parent { get; }
    public IEnumerable`1<ITreeNodeViewModel> Children { get; }
    public abstract virtual bool get_IsExpanded();
    public abstract virtual void set_IsExpanded(bool value);
    public abstract virtual bool get_IsPrefixNode();
    public abstract virtual bool get_IsSelected();
    public abstract virtual void set_IsSelected(bool value);
    public abstract virtual bool get_IsExpandable();
    public abstract virtual ITreeNodeViewModel get_Parent();
    public abstract virtual IEnumerable`1<ITreeNodeViewModel> get_Children();
}
public interface JetBrains.Common.Util.RemotableTree.ITreeNodeViewModel`1 {
    public TreeNode`2<TKey, ITreeNodeViewModel> Container { get; }
    public abstract virtual TreeNode`2<TKey, ITreeNodeViewModel> get_Container();
}
public interface JetBrains.Common.Util.RemotableTree.ITreeNodeViewModel`2 {
    public abstract virtual void AttachFacade(TreeNode`2<TKey, ITreeNodeViewModel> container, IUserStateTree`2<TKey, TUserState> treeFacade);
    public abstract virtual void SetState(TUserState state);
}
public interface JetBrains.Common.Util.RemotableTree.ITreeRequestProcessor`3 {
    public abstract virtual void SendRequest(TreeUpdateRequest`2<TKey, TUserState> request);
    public abstract virtual void add_ResponseReceived(Action`1<TreeUpdateResponse`2<TKey, TInfo>> value);
    public abstract virtual void remove_ResponseReceived(Action`1<TreeUpdateResponse`2<TKey, TInfo>> value);
    public abstract virtual void add_TreeUpdated(Action value);
    public abstract virtual void remove_TreeUpdated(Action value);
}
public interface JetBrains.Common.Util.RemotableTree.ITreeService`3 {
    [NotNullAttribute]
public abstract virtual TreeUpdateResponse`2<TKey, TInfo> ProcessRequest(TreeUpdateRequest`2<TKey, TUserState> request, IExecutionController controller);
}
public interface JetBrains.Common.Util.RemotableTree.IUserStateTree`2 {
    public IDataProvider`1<TreeNode`2<TKey, ITreeNodeViewModel>> SelectedNode { get; }
    public abstract virtual TUserState AttachState(IEnumerable`1<TKey> keys);
    public abstract virtual void DetachState(IEnumerable`1<TKey> keys);
    public abstract virtual void UpdateSubTreeStructure(TreeNode`2<TKey, ITreeNodeViewModel> node);
    public abstract virtual void RequestNodeUpdate(TreeNode`2<TKey, ITreeNodeViewModel> userTreeNode);
    public abstract virtual void SetSelectedNode(TreeNode`2<TKey, ITreeNodeViewModel> node);
    public abstract virtual IDataProvider`1<TreeNode`2<TKey, ITreeNodeViewModel>> get_SelectedNode();
}
public static class JetBrains.Common.Util.RemotableTree.NodeState : object {
    public static int None;
    public static int Expand;
    public static int SystemFolding;
    public static int RecursiveFolding;
    public static int IsSystem;
    public static bool HasState(int state, int checkState);
    public static void SetState(Int32& location, int state);
    public static void ClearState(Int32& location, int state);
    public static void UpdateState(Int32& location, int state, bool setBits);
}
public class JetBrains.Common.Util.RemotableTree.RemoteTreeRequestProcessor`3 : object {
    private IDataController`1<TreeUpdateRequest`2<TKey, TUserState>> myRequestController;
    private Action`1<TreeUpdateResponse`2<TKey, TInfo>> ResponseReceived;
    private Action TreeUpdated;
    [CompilerGeneratedAttribute]
private static Func`3<Pair`2<TreeUpdateRequest`2<TKey, TUserState>, ITreeService`3<TKey, TInfo, TUserState>>, IExecutionController, TreeUpdateResponse`2<TKey, TInfo>> CS$<>9__CachedAnonymousMethodDelegate6;
    public RemoteTreeRequestProcessor`3(IRemotablePair`1<DataPipeLifetime> lifetime, IRemotableReference`1<IDataProvider`1<ITreeService`3<TKey, TInfo, TUserState>>> builderProvider);
    private IDataProvider`1<TreeUpdateResponse`2<TKey, TInfo>> BuildRemotePipeline(IDataProvider`1<TreeUpdateRequest`2<TKey, TUserState>> requestProvider, IRemotablePair`1<DataPipeLifetime> lifetime, IRemotableReference`1<IDataProvider`1<ITreeService`3<TKey, TInfo, TUserState>>> builderProvider);
    private void OnResponse(TreeUpdateResponse`2<TKey, TInfo> response);
    public sealed virtual void SendRequest(TreeUpdateRequest`2<TKey, TUserState> request);
    public sealed virtual void add_ResponseReceived(Action`1<TreeUpdateResponse`2<TKey, TInfo>> value);
    public sealed virtual void remove_ResponseReceived(Action`1<TreeUpdateResponse`2<TKey, TInfo>> value);
    public sealed virtual void add_TreeUpdated(Action value);
    public sealed virtual void remove_TreeUpdated(Action value);
    [CompilerGeneratedAttribute]
private void <.ctor>b__0(ITreeService`3<TKey, TInfo, TUserState> _);
    [CompilerGeneratedAttribute]
private void <.ctor>b__1(IRemotableReference`1<ITreeService`3<TKey, TInfo, TUserState>> _);
    [CompilerGeneratedAttribute]
private static TreeUpdateResponse`2<TKey, TInfo> <BuildRemotePipeline>b__5(Pair`2<TreeUpdateRequest`2<TKey, TUserState>, ITreeService`3<TKey, TInfo, TUserState>> requestAndTree, IExecutionController controller);
}
public class JetBrains.Common.Util.RemotableTree.SyncTreeRequestProcessor`3 : object {
    private ITreeService`3<TKey, TInfo, TUserState> myTreeService;
    private Action`1<TreeUpdateResponse`2<TKey, TInfo>> ResponseReceived;
    public SyncTreeRequestProcessor`3(ITreeService`3<TKey, TInfo, TUserState> treeService);
    public sealed virtual void SendRequest(TreeUpdateRequest`2<TKey, TUserState> request);
    public sealed virtual void add_ResponseReceived(Action`1<TreeUpdateResponse`2<TKey, TInfo>> value);
    public sealed virtual void remove_ResponseReceived(Action`1<TreeUpdateResponse`2<TKey, TInfo>> value);
    public sealed virtual void add_TreeUpdated(Action value);
    public sealed virtual void remove_TreeUpdated(Action value);
}
public class JetBrains.Common.Util.RemotableTree.Tree`4 : object {
    private TreeNode`2<TKey, ITreeNodeViewModel> myRoot;
    private ITreeRequestProcessor`3<TKey, TInfo, TUserState> myTreeRequestProcessor;
    private Func`2<Lifetime, ITreeNodeFactory`3<TKey, TInfo, TViewModel>> myTreeNodeFactoryAccessor;
    private IDataController`1<TreeNode`2<TKey, ITreeNodeViewModel>> mySelectedNode;
    [NotNullAttribute]
private TreeNode`2<TKey, TUserState> myUserChangesRoot;
    [NotNullAttribute]
private Func`2<TKey, TKey> myGetUserStateKey;
    private TKey[] mySelectedNodePathToRestore;
    [CanBeNullAttribute]
private TKey[] myTreePrefix;
    private int myTreeVersion;
    private EventHandler`1<ItemUpdatedEventArgs`1<ITreeNodeViewModel>> ItemUpdated;
    private EventHandler`1<ItemUpdatedEventArgs`1<ITreeNodeViewModel>> OnScrollToItem;
    [CompilerGeneratedAttribute]
private static Func`2<TKey, TUserState> CS$<>9__CachedAnonymousMethodDelegate5;
    [CompilerGeneratedAttribute]
private static Func`2<TreeNodePathItem`2<TKey, ITreeNodeViewModel>, TKey> CS$<>9__CachedAnonymousMethodDelegatec;
    [CompilerGeneratedAttribute]
private static Func`2<TKey, TUserState> CS$<>9__CachedAnonymousMethodDelegate11;
    public TreeNode`2<TKey, ITreeNodeViewModel> Root { get; }
    public TKey[] RootPrefix { get; }
    private IEnumerable`1<TKey> PrefixWithoutRoot { get; }
    private bool HasPrefix { get; }
    public ITreeListStructureProvider`1<ITreeNodeViewModel> StructureProvider { get; }
    public IDataController`1<TreeNode`2<TKey, ITreeNodeViewModel>> SelectedNode { get; }
    private IDataProvider`1<TreeNode`2<TKey, ITreeNodeViewModel>> JetBrains.Common.Util.RemotableTree.IUserStateTree<TKey,TUserState>.SelectedNode { get; }
    private ITreeNodeViewModel JetBrains.Common.Util.TreeStructure.ITreeListStructureProvider<JetBrains.Common.Util.RemotableTree.ITreeNodeViewModel>.Root { get; }
    public Tree`4(Lifetime lifetime, ITreeRequestProcessor`3<TKey, TInfo, TUserState> treeProcessor, Func`2<Lifetime, ITreeNodeFactory`3<TKey, TInfo, TViewModel>> treeNodeFactoryAccessor, Func`2<TKey, TKey> getUserStateKey, UserStateTreeData`2<TKey, TUserState> userChanges, TKey[] prefix);
    public sealed virtual TreeNode`2<TKey, ITreeNodeViewModel> get_Root();
    public sealed virtual TKey[] get_RootPrefix();
    private IEnumerable`1<TKey> get_PrefixWithoutRoot();
    private bool get_HasPrefix();
    private void OnSelectedNodeChanged(TreeNode`2<TKey, ITreeNodeViewModel> oldNode, TreeNode`2<TKey, ITreeNodeViewModel> newNode);
    public sealed virtual ITreeListStructureProvider`1<ITreeNodeViewModel> get_StructureProvider();
    private static TreeNode`2<TKey, ITreeNodeViewModel> BuildNode(TKey key, TInfo info, IUserStateTree`2<TKey, TUserState> userStateTree, object responseData, ITreeNodeFactory`3<TKey, TInfo, TViewModel> factory);
    public sealed virtual IDataController`1<TreeNode`2<TKey, ITreeNodeViewModel>> get_SelectedNode();
    public sealed virtual IEnumerable`1<TKey> GetNodePrefix(TreeNode`2<TKey, ITreeNodeViewModel> node);
    private void AttachUserState(TreeNode`2<TKey, ITreeNodeViewModel> node, TreeNode`2<TKey, TUserState> userStateNode);
    private TreeNode`2<TKey, ITreeNodeViewModel> BuildTreeNodeCore(TreeNode`2<TKey, TInfo> readonlyNode, object responseData, ITreeNodeFactory`3<TKey, TInfo, TViewModel> factory);
    private void ValidateResponse(TreeUpdateResponse`2<TKey, TInfo> response);
    public void UpdateTree(TreeUpdateResponse`2<TKey, TInfo> response);
    [CanBeNullAttribute]
public TreeUpdateRequest`2<TKey, TUserState> BuildRequest(TreeNode`2<TKey, ITreeNodeViewModel> node);
    private void FireSubtreeUpdated(TreeNode`2<TKey, ITreeNodeViewModel> node);
    public sealed virtual void UpdateSubTreeStructure(TreeNode`2<TKey, ITreeNodeViewModel> node);
    private void RequestFullUpdate();
    public sealed virtual void RequestNodeUpdate(TreeNode`2<TKey, ITreeNodeViewModel> treeNode);
    public sealed virtual void SetSelectedNode(TreeNode`2<TKey, ITreeNodeViewModel> node);
    private sealed virtual override IDataProvider`1<TreeNode`2<TKey, ITreeNodeViewModel>> JetBrains.Common.Util.RemotableTree.IUserStateTree<TKey,TUserState>.get_SelectedNode();
    private sealed virtual override ITreeNodeViewModel JetBrains.Common.Util.TreeStructure.ITreeListStructureProvider<JetBrains.Common.Util.RemotableTree.ITreeNodeViewModel>.get_Root();
    public sealed virtual bool HasChildren(ITreeNodeViewModel item);
    public sealed virtual ITreeNodeViewModel GetParent(ITreeNodeViewModel item);
    public sealed virtual bool GetIsExpanded(ITreeNodeViewModel item);
    public sealed virtual void SetIsExpanded(ITreeNodeViewModel item, bool isExpanded);
    public sealed virtual IEnumerable`1<ITreeNodeViewModel> GetChildren(ITreeNodeViewModel item);
    public sealed virtual ITreeNodeViewModel FindNearestItemAfterUpdate(ITreeNodeViewModel oldItem);
    public void ScrollToNode(TreeNode`2<TKey, ITreeNodeViewModel> item);
    public sealed virtual void add_ItemUpdated(EventHandler`1<ItemUpdatedEventArgs`1<ITreeNodeViewModel>> value);
    public sealed virtual void remove_ItemUpdated(EventHandler`1<ItemUpdatedEventArgs`1<ITreeNodeViewModel>> value);
    public sealed virtual void add_OnScrollToItem(EventHandler`1<ItemUpdatedEventArgs`1<ITreeNodeViewModel>> value);
    public sealed virtual void remove_OnScrollToItem(EventHandler`1<ItemUpdatedEventArgs`1<ITreeNodeViewModel>> value);
    private TreeNode`2<TKey, ITreeNodeViewModel> FindNearestExistingAncestor(TreeNode`2<TKey, ITreeNodeViewModel> oldItem);
    [CanBeNullAttribute]
private TreeNode`2<TKey, TUserState> FindUserStateNode(IEnumerable`1<TKey> path, bool createIfMissing);
    private TreeNode`2<TKey, ITreeNodeViewModel> GetResponseRoot(TreeUpdateResponse`2<TKey, TInfo> response);
    public sealed virtual TUserState AttachState(IEnumerable`1<TKey> stack);
    public sealed virtual void DetachState(IEnumerable`1<TKey> path);
    [CompilerGeneratedAttribute]
private static TUserState <.ctor>b__0(TKey _);
    [CompilerGeneratedAttribute]
private void <.ctor>b__1();
    [CompilerGeneratedAttribute]
private void <.ctor>b__2();
    [CompilerGeneratedAttribute]
private void <.ctor>b__3();
    [CompilerGeneratedAttribute]
private void <.ctor>b__4();
    [CompilerGeneratedAttribute]
private static TKey <UpdateTree>b__a(TreeNodePathItem`2<TKey, ITreeNodeViewModel> p);
    [CompilerGeneratedAttribute]
private static TUserState <FindUserStateNode>b__10(TKey _);
}
public class JetBrains.Common.Util.RemotableTree.TreeNode`2 : object {
    [NotNullAttribute]
private TKey myKey;
    private TValue myValue;
    [CanBeNullAttribute]
private TreeNode`2<TKey, TValue> myParent;
    [CanBeNullAttribute]
private TreeNode`2[] myChildren;
    public int ChildrenCount { get; }
    public IEnumerable`1<TreeNode`2<TKey, TValue>> Children { get; }
    public TValue Value { get; }
    public TKey Key { get; }
    [CanBeNullAttribute]
public TreeNode`2<TKey, TValue> Parent { get; }
    public TreeNode`2(TKey key, TValue value, IEnumerable`1<TreeNode`2<TKey, TValue>> children);
    public static TreeNode`2<TKey, TValue> BuildRoot();
    public void UpdateChildren(IEnumerable`1<TreeNode`2<TKey, TValue>> children);
    public int get_ChildrenCount();
    public IEnumerable`1<TreeNode`2<TKey, TValue>> get_Children();
    public TValue get_Value();
    public TKey get_Key();
    public TreeNode`2<TKey, TValue> get_Parent();
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.RemotableTree.TreeNodeEx : object {
    [ExtensionAttribute]
public static void AppendChild(TreeNode`2<TKey, TValue> node, TreeNode`2<TKey, TValue> child);
    [ExtensionAttribute]
public static void RemoveChild(TreeNode`2<TKey, TValue> node, TreeNode`2<TKey, TValue> child);
    [ExtensionAttribute]
public static void ReplaceNode(TreeNode`2<TKey, TValue> node, TreeNode`2<TKey, TValue> source, TreeNode`2<TKey, TValue> newValue);
    [ExtensionAttribute]
public static bool IsDescendantOf(TreeNode`2<TKey, TValue> descendant, TreeNode`2<TKey, TValue> ancestor);
    [CanBeNullAttribute]
[ExtensionAttribute]
public static TreeNode`2<TKey, TValue> GetChildByKey(TreeNode`2<TKey, TValue> treeRoot, TKey key);
    [NotNullAttribute]
[ExtensionAttribute]
public static TreeNode`2<TKey, TValue> GetNodeByPathWhileMatching(TreeNode`2<TKey, TValue> root, IEnumerable`1<TKey> keyPath);
    [NotNullAttribute]
[ExtensionAttribute]
public static TreeNode`2<TKey, TValue> GetOrCreateNodeByPath(TreeNode`2<TKey, TValue> root, IEnumerable`1<TKey> keyPath, Func`2<TKey, TValue> createNewNode);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static TreeNode`2<TKey, TValue> TryGetNodeByPath(TreeNode`2<TKey, TValue> root, IEnumerable`1<TKey> keyPath);
    [ExtensionAttribute]
public static TreeNode`2<TKey, TValue> GetNodeByPath(TreeNode`2<TKey, TValue> root, IEnumerable`1<TKey> keyPath, Func`2<TKey, TValue> createNewNode);
    [ExtensionAttribute]
public static IEnumerable`1<TKey> KeyPathFromRoot(TreeNode`2<TKey, TValue> node);
    [ExtensionAttribute]
public static IEnumerable`1<TreeNodePathItem`2<TKey, TValue>> PathFromRoot(TreeNode`2<TKey, TValue> node);
    [ExtensionAttribute]
public static TreeNode`2<TKey, TValue> TryGetChild(TreeNode`2<TKey, TValue> node, TKey key);
    [ExtensionAttribute]
private static IEnumerable`1<T> ReplaceItem(IEnumerable`1<T> node, T source, T newValue, Func`3<T, T, bool> preducate);
    [CompilerGeneratedAttribute]
private static bool <ReplaceNode>b__3(TreeNode`2<TKey, TValue> c1, TreeNode`2<TKey, TValue> c2);
}
public class JetBrains.Common.Util.RemotableTree.TreeNodePathItem`2 : object {
    public TKey Key;
    public TState State;
    public TreeNodePathItem`2(TKey key, TState state);
}
public abstract class JetBrains.Common.Util.RemotableTree.TreeNodeViewModelBase`3 : object {
    [NotNullAttribute]
protected TNodeInfo NodeInfo;
    private bool myIsSelected;
    [CanBeNullAttribute]
private TUserState myUserState;
    private IUserStateTree`2<TKey, TUserState> myUserStateTree;
    private TreeNode`2<TKey, ITreeNodeViewModel> myContainer;
    private PropertyChangedEventHandler PropertyChanged;
    [CompilerGeneratedAttribute]
private static Func`2<TNodeInfo, bool> CS$<>9__CachedAnonymousMethodDelegate4;
    [CompilerGeneratedAttribute]
private static Func`2<TUserState, Nullable`1<bool>> CS$<>9__CachedAnonymousMethodDelegate5;
    [CompilerGeneratedAttribute]
private static Func`2<TNodeInfo, bool> CS$<>9__CachedAnonymousMethodDelegate6;
    [CompilerGeneratedAttribute]
private static Func`2<TUserState, Nullable`1<bool>> CS$<>9__CachedAnonymousMethodDelegate7;
    [CompilerGeneratedAttribute]
private static Func`2<TNodeInfo, bool> CS$<>9__CachedAnonymousMethodDelegatea;
    [CompilerGeneratedAttribute]
private static Func`2<TUserState, Nullable`1<bool>> CS$<>9__CachedAnonymousMethodDelegateb;
    [CompilerGeneratedAttribute]
private static Func`2<TNodeInfo, bool> CS$<>9__CachedAnonymousMethodDelegatee;
    [CompilerGeneratedAttribute]
private static Action`2<TUserState, Nullable`1<bool>> CS$<>9__CachedAnonymousMethodDelegatef;
    [CompilerGeneratedAttribute]
private static Func`2<TreeNode`2<TKey, ITreeNodeViewModel>, ITreeNodeViewModel> CS$<>9__CachedAnonymousMethodDelegate11;
    protected bool HasChildren { get; }
    public TreeNode`2<TKey, ITreeNodeViewModel> Container { get; }
    public bool IsExpanded { get; public set; }
    public bool IsPrefixNode { get; }
    public bool IsSelected { get; public set; }
    public bool IsExpandable { get; }
    public ITreeNodeViewModel Parent { get; }
    public IEnumerable`1<ITreeNodeViewModel> Children { get; }
    protected TreeNodeViewModelBase`3(TNodeInfo nodeInfo);
    private TUserState AttachState();
    private void DetachUserState();
    private void IsExpandedChanged();
    private void OnSelected();
    protected bool get_HasChildren();
    private void RequestNodeUpdate();
    public virtual void AttachFacade(TreeNode`2<TKey, ITreeNodeViewModel> container, IUserStateTree`2<TKey, TUserState> treeFacade);
    public sealed virtual void SetState(TUserState state);
    public sealed virtual TreeNode`2<TKey, ITreeNodeViewModel> get_Container();
    protected abstract virtual void BeforeUserStateChange();
    protected abstract virtual bool IsStateChanged();
    protected bool GetState(Func`2<TNodeInfo, bool> getDefaultState, Func`2<TUserState, Nullable`1<bool>> getUserState);
    protected void SetState(Func`2<TNodeInfo, bool> getDefaultState, Action`2<TUserState, Nullable`1<bool>> setUserState, bool value);
    public sealed virtual bool get_IsExpanded();
    public sealed virtual void set_IsExpanded(bool value);
    public sealed virtual bool get_IsPrefixNode();
    public sealed virtual bool get_IsSelected();
    public sealed virtual void set_IsSelected(bool value);
    public sealed virtual bool get_IsExpandable();
    public sealed virtual ITreeNodeViewModel get_Parent();
    public sealed virtual IEnumerable`1<ITreeNodeViewModel> get_Children();
    public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    protected void UpdateProperty(Expression`1<Func`1<T>> param);
    private void UpdateAllProperties();
    [CompilerGeneratedAttribute]
private static bool <SetState>b__0(TNodeInfo d);
    [CompilerGeneratedAttribute]
private static Nullable`1<bool> <SetState>b__1(TUserState u);
    [CompilerGeneratedAttribute]
private static bool <SetState>b__2(TNodeInfo d);
    [CompilerGeneratedAttribute]
private static Nullable`1<bool> <SetState>b__3(TUserState u);
    [CompilerGeneratedAttribute]
private static bool <get_IsExpanded>b__8(TNodeInfo d);
    [CompilerGeneratedAttribute]
private static Nullable`1<bool> <get_IsExpanded>b__9(TUserState u);
    [CompilerGeneratedAttribute]
private static bool <set_IsExpanded>b__c(TNodeInfo d);
    [CompilerGeneratedAttribute]
private static void <set_IsExpanded>b__d(TUserState u, Nullable`1<bool> v);
    [CompilerGeneratedAttribute]
private static ITreeNodeViewModel <get_Children>b__10(TreeNode`2<TKey, ITreeNodeViewModel> c);
}
public class JetBrains.Common.Util.RemotableTree.TreeUpdateRequest`2 : object {
    [CompilerGeneratedAttribute]
private TKey[] <PathToNode>k__BackingField;
    [CompilerGeneratedAttribute]
private TreeNode`2<TKey, TUserState> <VisualStateRoot>k__BackingField;
    [CanBeNullAttribute]
public TKey[] PathToNode { get; private set; }
    [CanBeNullAttribute]
public TreeNode`2<TKey, TUserState> VisualStateRoot { get; private set; }
    [CanBeNullAttribute]
public TKey TargetNode { get; }
    public TreeUpdateRequest`2(TKey[] pathToNode, TreeNode`2<TKey, TUserState> visualStateRoot);
    [CompilerGeneratedAttribute]
public TKey[] get_PathToNode();
    [CompilerGeneratedAttribute]
private void set_PathToNode(TKey[] value);
    [CompilerGeneratedAttribute]
public TreeNode`2<TKey, TUserState> get_VisualStateRoot();
    [CompilerGeneratedAttribute]
private void set_VisualStateRoot(TreeNode`2<TKey, TUserState> value);
    public TKey get_TargetNode();
}
public class JetBrains.Common.Util.RemotableTree.TreeUpdateResponse`2 : object {
    [CanBeNullAttribute]
public TKey[] PathToNode;
    [CanBeNullAttribute]
public TreeNode`2<TKey, TInfo> Root;
    public int TreeVersion;
    public object Data;
}
public class JetBrains.Common.Util.RemotableTree.UserStateTreeData`2 : object {
    private TreeNode`2<TKey, TUserState> myRoot;
    public TreeNode`2<TKey, TUserState> Root { get; }
    public TreeNode`2<TKey, TUserState> get_Root();
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.Remoting.Extensions : object {
    [CompilerGeneratedAttribute]
private static Func`1<LifetimeDefinition> CS$<>9__CachedAnonymousMethodDelegate80;
    [CompilerGeneratedAttribute]
private static Func`1<IDataController`1<bool>> CS$<>9__CachedAnonymousMethodDelegate81;
    [CompilerGeneratedAttribute]
private static Func`2<PipeLifeState, bool> CS$<>9__CachedAnonymousMethodDelegate82;
    [CompilerGeneratedAttribute]
private static Func`2<PipeLifeState, bool> CS$<>9__CachedAnonymousMethodDelegate83;
    [CompilerGeneratedAttribute]
private static Func`2<LifetimeDefinition, DataPipeLifetime> CS$<>9__CachedAnonymousMethodDelegate84;
    [ExtensionAttribute]
[NotNullAttribute]
public static IRemotableReference`1<TResult> Apply(IRemotableReference`1<T> source, IDataProvider`1<T2> providerToSwitch, Func`3<T, IRemotableReference`1<IDataProvider`1<T2>>, TResult> builder);
    [ExtensionAttribute]
[NotNullAttribute]
public static IRemotableReference`1<TResult> Apply(IRemotableReference`1<T> source, Func`2<T, TResult> builder);
    [ExtensionAttribute]
public static IRemotableReference`1<TResult> ApplySafe(IRemotableReference`1<T> source, Func`2<T, TResult> builder);
    [ExtensionAttribute]
public static void Execute(IRemotableReference`1<T> source, IDataProvider`1<T2> providerToSwitch1, IDataProvider`1<T3> providerToSwitch2, Action`3<T, IRemotableReference`1<IDataProvider`1<T2>>, IRemotableReference`1<IDataProvider`1<T3>>> action);
    [ExtensionAttribute]
public static void Execute(IRemotableReference`1<T> source, IDataProvider`1<T2> providerToSwitch, Action`2<T, IRemotableReference`1<IDataProvider`1<T2>>> action);
    [ExtensionAttribute]
public static void Do(IRemotableReference`1<T> source, TArg arg, Action`2<T, TArg> action);
    [ExtensionAttribute]
public static void Do(IRemotableReference`1<T> source, Action`1<T> action);
    [ExtensionAttribute]
public static void SetSource(IRemotableReference`1<IDataProxy`1<T>> proxy, IRemotableReference`1<IDataProvider`1<T>> source);
    [ExtensionAttribute]
public static void SetSource(IRemotableReference`1<IThreadSwitchProxy`1<T>> proxy, IRemotableReference`1<IThreadSwitch`1<T>> source);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static IRemoteCommunicator GetComm(IRemotablePair`1<T> o);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static IRemoteCommunicator GetComm(IRemotableReference`1<T> o);
    [ExtensionAttribute]
public static IThreadSwitch`1<TResult> Apply(IRemotableReference`1<T> source, Func`2<T, IRemotableReference`1<IThreadSwitch`1<TResult>>> builder);
    [ExtensionAttribute]
public static IThreadSwitch`1<TResult> ApplySafe(IRemotableReference`1<T> source, Func`2<T, IRemotableReference`1<IThreadSwitch`1<TResult>>> builder);
    [ExtensionAttribute]
private static IThreadSwitch`1<TResult> ApplyReturnStream(IRemotableReference`1<T> source, Func`2<T, IRemotableReference`1<IThreadSwitch`1<TResult>>> builder);
    [ExtensionAttribute]
public static IThreadSwitch`1<TResult> BuildReturn(IRemoteCommunicator comm, Func`1<IRemotableReference`1<IThreadSwitch`1<TResult>>> builder);
    [ExtensionAttribute]
private static IThreadSwitch`1<TResult> BuildReturnStream(IRemoteCommunicator comm, Func`1<IRemotableReference`1<IThreadSwitch`1<TResult>>> builder);
    [ExtensionAttribute]
public static IRemotablePair`1<T> CreateRemotablePair(IRemotableReference`1<T> remoteReference, T value);
    [NotNullAttribute]
[ExtensionAttribute]
public static IRemotableReference`1<IThreadSwitch`1<T>> SwitchRemote(IDataProviderBase`1<T> source, IRemoteCommunicator comm);
    [NotNullAttribute]
[ExtensionAttribute]
public static IRemotableReference`1<IThreadSwitch`1<T>> SwitchRemoteIfPossible(IDataProviderBase`1<T> source, IRemoteCommunicator comm);
    [ExtensionAttribute]
public static IRemotableReference`1<IThreadSwitch`1<IReadOnlyCollection`1<T>>> SwitchRemoteCollectionIfPossible(IDataProvider`1<IReadOnlyCollection`1<T>> source, IRemoteCommunicator comm);
    [ExtensionAttribute]
public static IRemotableReference`1<T> BuildLocalOrRemote(IRemoteCommunicator comm, Func`1<T> func);
    [ExtensionAttribute]
public static IRemotableReference`1<TB> BuildLocalOrRemote(IRemoteCommunicator comm, Func`2<TA, TB> func, TA arg);
    [ExtensionAttribute]
[NotNullAttribute]
public static IRemotableReference`1<IThreadSwitch`1<T>> SwitchStreamRemote(IDataProviderBase`1<T> source, IRemoteCommunicator comm);
    [NotNullAttribute]
[ExtensionAttribute]
public static IRemotableReference`1<IThreadSwitch`1<T>> SwitchStreamRemoteIfPossible(IDataProviderBase`1<T> source, IRemoteCommunicator comm);
    [ExtensionAttribute]
public static IRemotableReference`1<IDataProvider`1<T>> SwitchRemoteToMainThread(IDataProviderBase`1<T> src, IRemoteCommunicator comm);
    [ExtensionAttribute]
public static IRemotableReference`1<IDataProvider`1<T>> SwitchRemoteToMainThreadIfPossible(IDataProvider`1<T> src, IRemoteCommunicator comm);
    [ExtensionAttribute]
public static IDataProvider`1<T> SwitchLocalToMainThreadIfRemote(IRemotableReference`1<IDataProvider`1<T>> source);
    [ExtensionAttribute]
public static IRemotableReference`1<IDataProvider`1<T>> SwitchStreamRemoteToMainThread(IDataProviderBase`1<T> src, IRemoteCommunicator comm);
    [NotNullAttribute]
[ExtensionAttribute]
public static IRemotableReference`1<IDataProvider`1<T>> SwitchRemoteToCurrentThread(IDataProviderBase`1<T> source, IRemoteCommunicator comm);
    [ExtensionAttribute]
public static IRemotableReference`1<IThreadSwitch`1<T>> SwitchRemoteToStream(IDataProviderBase`1<T> source, IRemoteCommunicator comm);
    private static IThreadSwitchEx`1<T> SwitchRecycle(IDataProviderBase`1<BinaryReader> readerSwitch, Action`2<T, BinaryReader> restoreAction);
    [ExtensionAttribute]
public static IRemotableReference`1<IThreadSwitch`1<TB>> SwitchRemote(IDataProviderBase`1<TA> source, IRemoteCommunicator comm, Action`2<TA, BinaryWriter> fillAction, Action`2<TB, BinaryReader> restoreAction);
    [ExtensionAttribute]
[NotNullAttribute]
public static IRemotableReference`1<IDataProvider`1<IReadonlyPointer>> SwitchRemote(IDataProviderBase`1<T> source, IRemoteCommunicator comm, Action`2<T, IResizeablePointer> fillAction);
    [ExtensionAttribute]
public static IRemotableReference`1<IDataProvider`1<TB>> SwitchRemote(IDataProviderBase`1<TA> source, IRemoteCommunicator comm, Action`3<BinaryWriter, BinaryFormatter, TA> fillAction, Func`3<BinaryReader, BinaryFormatter, TB> readAction);
    [ExtensionAttribute]
public static IRemotableReference`1<IThreadSwitch`1<T>> SwitchRemoteDeferring(IDataProviderBase`1<T> source, IRemoteCommunicator comm);
    [ExtensionAttribute]
public static IRemotableReference`1<IThreadSwitch`1<T>> SwitchRemoteRecycling(IDataProviderBase`1<T> source, IRemoteCommunicator comm);
    [ExtensionAttribute]
public static IRemotableReference`1<IThreadSwitch`1<ILocked`1<IntPtr>>> SwitchRemoteDeferring(IDataProviderBase`1<T> source, IRemoteCommunicator comm, Action`2<T, IResizeablePointer> fillAction);
    [ExtensionAttribute]
public static IRemotableReference`1<IThreadSwitch`1<IntPtr>> SwitchRemoteRecycling(IDataProviderBase`1<T> source, IRemoteCommunicator comm, Action`2<T, IResizeablePointer> fillAction);
    [ExtensionAttribute]
public static IRemotableReference`1<IThreadSwitch`1<IReadOnlyCollection`1<T>>> SwitchRemoteCollection(IDataProvider`1<IReadOnlyCollection`1<T>> source, IRemoteCommunicator comm);
    [ExtensionAttribute]
public static IRemotableReference`1<IThreadSwitch`1<T>> SwitchRemote(IDataProviderBase`1<T> src, IRemoteCommunicator comm, InterProcessTransferMode type);
    [ExtensionAttribute]
public static IThreadSwitch`1<T> SwitchStreamLocalIfRemote(IRemotableReference`1<IDataProviderBase`1<T>> source);
    [ExtensionAttribute]
public static IThreadSwitch`1<T> SwitchStreamLocal(IRemotableReference`1<IDataProviderBase`1<T>> source);
    [ExtensionAttribute]
public static IThreadSwitch`1<T> SwitchLocal(IRemotableReference`1<IThreadSwitch`1<T>> remoteSwitch);
    [ExtensionAttribute]
public static IThreadSwitch`1<T> SwitchLocal(IRemotableReference`1<IThreadSwitchEx`1<T>> remoteSwitch);
    [ExtensionAttribute]
public static IThreadSwitch`1<T> SwitchLocal(IRemotableReference`1<IDataProviderBase`1<T>> source);
    [ExtensionAttribute]
public static IThreadSwitch`1<T> SwitchLocalIfRemote(IRemotableReference`1<IDataProviderBase`1<T>> source);
    [ExtensionAttribute]
public static IDataProvider`1<T> SwitchLocalToMainThread(IRemotableReference`1<IThreadSwitch`1<T>> remoteSwitch);
    [ExtensionAttribute]
public static IDataProvider`1<T> SwitchLocalToMainThread(IRemotableReference`1<IDataProviderBase`1<T>> source);
    [ExtensionAttribute]
public static IThreadSwitch`1<IRemotableReference`1<T>> SwitchLocalByRef(IRemotableReference`1<IDataProvider`1<T>> source);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<T> SwitchLocalToCommunicationThread(IRemotableReference`1<IDataProviderBase`1<T>> source);
    [ExtensionAttribute]
public static IThreadSwitch`1<T> SwitchLocalDeferring(IRemotableReference`1<IDataProviderBase`1<T>> source);
    [ExtensionAttribute]
public static IThreadSwitch`1<IntPtr> SwitchLocalRecycling(IRemotableReference`1<IDataProviderBase`1<T>> source, Action`2<T, IResizeablePointer> fillAction);
    [ExtensionAttribute]
public static IThreadSwitch`1<IntPtr> SwitchLocalRecycling(IRemotableReference`1<IAsyncDataProvider`1<T>> source, Action`3<T, IResizeablePointer, IExecutionController> fillAction);
    [ExtensionAttribute]
public static IThreadSwitch`1<T> SwitchLocal(IRemotableReference`1<IDataProviderBase`1<T>> remoteProvider, InterProcessTransferMode type);
    [ExtensionAttribute]
public static IRemotableReference`1<T> CreateRemoteReference(IRemoteCommunicator comm, T value);
    [ExtensionAttribute]
public static IRemotableReference`1<DataPipeLifetime> SwitchRemote(DataPipeLifetime lifetime, IRemoteCommunicator comm);
    [ExtensionAttribute]
public static IRemotableReference`1<DataPipeLifetime> SwitchRemote(DataPipeLifetime lifetime, IRemoteCommunicator comm, TimeSpan terminationTimeout);
    private static Action`1<IThreadSwitch`1<bool>> CreateTerminateRemoteLifetimeAction(IRemotableReference`1<LifetimeDefinition> remoteLifetimeDefinition, IRemotableReference`1<IDataController`1<bool>> remoteIsTerminated);
    [NotNullAttribute]
[ExtensionAttribute]
public static IRemotableReference`1<T> GetLocalOrRemoteReference(IRemotablePair`1<T> pair);
    [ExtensionAttribute]
public static void EnsureSizeAtLeast(IResizeablePointer pointer, int size);
    [ExtensionAttribute]
public static TR Debug(T t, Func`2<T, TR> action);
    [ExtensionAttribute]
public static void SetLocalSource(IRemotableReference`1<IProxyContainer`1<T>> proxy, IProviderContainer`1<T> source);
    [ExtensionAttribute]
public static void SetLocalSource(IRemotableReference`1<IProxyContainer`1<T>> proxy, IDataProvider`1<T> source);
    [ExtensionAttribute]
public static void SetLocalSource(IRemotableReference`1<IDataProxy`1<T>> proxy, IDataProvider`1<T> source);
    [ExtensionAttribute]
public static void SetLocalCollectionSource(IRemotableReference`1<IDataProxy`1<IReadOnlyCollection`1<T>>> proxy, IDataProvider`1<IReadOnlyCollection`1<T>> source);
    [ExtensionAttribute]
public static IRemotableReference`1<T> AdaptToCommunicator(IRemotableReference`1<T> reference, IRemoteCommunicator comm);
    [CompilerGeneratedAttribute]
private static IThreadSwitch`1<T> <SwitchRemote>b__2e(IDataProvider`1<T> s);
    [CompilerGeneratedAttribute]
private static IThreadSwitch`1<T> <SwitchStreamRemote>b__32(IDataProvider`1<T> s);
    [CompilerGeneratedAttribute]
private static IThreadSwitch`1<T> <SwitchStreamRemoteIfPossible>b__33(IDataProvider`1<T> s);
    [CompilerGeneratedAttribute]
private static void <SwitchRemoteToCurrentThread>b__34(BinaryWriter writer, BinaryFormatter formatter, T value);
    [CompilerGeneratedAttribute]
private static T <SwitchRemoteToCurrentThread>b__35(BinaryReader reader, BinaryFormatter formatter);
    [CompilerGeneratedAttribute]
private static void <SwitchRemoteToStream>b__36(T value, BinaryWriter writer);
    [CompilerGeneratedAttribute]
private static void <SwitchRemoteToStream>b__37(T value, BinaryReader reader);
    [CompilerGeneratedAttribute]
private static T <SwitchRecycle>b__38();
    [CompilerGeneratedAttribute]
private static BinaryReader <SwitchRemote>b__3d(BinaryReader reader, BinaryFormatter formatter);
    [CompilerGeneratedAttribute]
private static ReadonlyPointer <SwitchRemote>b__41(BinaryReader reader, BinaryFormatter formatter);
    [CompilerGeneratedAttribute]
private static IThreadSwitch`1<T> <SwitchRemoteDeferring>b__45(IThreadSwitch`1<ILocked`1<IntPtr>> a);
    [CompilerGeneratedAttribute]
private static IThreadSwitch`1<T> <SwitchRemoteRecycling>b__49(IThreadSwitch`1<IntPtr> a);
    [CompilerGeneratedAttribute]
private static T <SwitchRemoteRecycling>b__4a(IntPtr ptr);
    [CompilerGeneratedAttribute]
private static IThreadSwitch`1<ILocked`1<IntPtr>> <SwitchRemoteDeferring>b__4d(IDataProvider`1<Getter`1<ILocked`1<IntPtr>>> a);
    [CompilerGeneratedAttribute]
private static IThreadSwitch`1<IntPtr> <SwitchRemoteRecycling>b__4e(IDataProvider`1<Getter`1<IntPtr>> a);
    [CompilerGeneratedAttribute]
private static IThreadSwitch`1<JetReadOnlyCollection`1<T>> <SwitchRemoteCollection>b__4f(IThreadSwitch`1<T[]> a);
    [CompilerGeneratedAttribute]
private static IRemotableReference`1<T> <SwitchLocalByRef>b__65(T v);
    [CompilerGeneratedAttribute]
private static ProgressDataProvider`1<T> <SwitchLocalRecycling>b__6f(IAsyncDataProvider`1<T> s);
    [CompilerGeneratedAttribute]
private static LifetimeDefinition <SwitchRemote>b__79();
    [CompilerGeneratedAttribute]
private static IDataController`1<bool> <SwitchRemote>b__7a();
    [CompilerGeneratedAttribute]
private static bool <SwitchRemote>b__7b(PipeLifeState state);
    [CompilerGeneratedAttribute]
private static bool <SwitchRemote>b__7c(PipeLifeState state);
    [CompilerGeneratedAttribute]
private static DataPipeLifetime <SwitchRemote>b__7f(LifetimeDefinition def);
}
public class JetBrains.Common.Util.Remoting.ExternalStorage : object {
    private static string RemoteWorkspacePath;
    private static FileSystemPath StorageExecutableFilePath;
    private static FileSystemPath StorageExecutableFilePathX86;
    private Action`1<Exception> myRemoteExceptionHandler;
    private IRemoteCommunicator myRemoteCommunicator;
    private WaitHandle myExited;
    private Process myProcess;
    [CompilerGeneratedAttribute]
private static Func`2<DataPipeLifetime, Lifetime> CS$<>9__CachedAnonymousMethodDelegate2;
    [CompilerGeneratedAttribute]
private static Action`1<Exception> CS$<>9__CachedAnonymousMethodDelegate9;
    [CompilerGeneratedAttribute]
private static Action`1<IRemoteCommunicator> CS$<>9__CachedAnonymousMethodDelegatea;
    public IRemoteCommunicator RemoteCommunicator { get; }
    public WaitHandle Exited { get; }
    public Process Process { get; }
    private static ExternalStorage();
    private ExternalStorage(Action`1<Exception> remoteExceptionHandler, IRemoteCommunicator remoteCommunicator, WaitHandle exited, Process process);
    private static FileSystemPath GetFileName(PlatformKind platform);
    public sealed virtual IRemoteCommunicator get_RemoteCommunicator();
    public sealed virtual IRemoteCommunicator CreateCommunicator(Lifetime lifetime);
    public sealed virtual WaitHandle get_Exited();
    public sealed virtual Process get_Process();
    public void Kill();
    private static string GetClrPrefix();
    [NotNullAttribute]
public static IExternalStorage Create(Lifetime lifetime, Action`1<Exception> remoteExceptionHandler, PlatformKind platform);
    private static void EnableLogging(IRemoteCommunicator comm);
    private static FileSystemPath GetDirectoryPathFromCodeBase();
    [CompilerGeneratedAttribute]
private static Lifetime <CreateCommunicator>b__0(DataPipeLifetime c);
    [CompilerGeneratedAttribute]
private static void <Create>b__6(Exception e);
    [CompilerGeneratedAttribute]
private static void <Create>b__8(IRemoteCommunicator _);
}
public interface JetBrains.Common.Util.Remoting.IExternalStorage {
    public IRemoteCommunicator RemoteCommunicator { get; }
    public WaitHandle Exited { get; }
    public Process Process { get; }
    public abstract virtual IRemoteCommunicator get_RemoteCommunicator();
    public abstract virtual IRemoteCommunicator CreateCommunicator(Lifetime lifetime);
    public abstract virtual WaitHandle get_Exited();
    public abstract virtual Process get_Process();
}
public interface JetBrains.Common.Util.Remoting.ILocked`1 {
    public abstract virtual TResult Apply(Func`2<T, TResult> func);
}
internal class JetBrains.Common.Util.Remoting.Impl.GarbageCollector : object {
    private IGarbageProducer[] myGarbageProducers;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) myRequestCounter;
    private int myLastSeenRequestNumber;
    private int myLastRequestActualGcCount;
    private TimeSpan myPeriod;
    private Timer myTimer;
    private static TimeSpan ourDefaultPeriod;
    public TimeSpan Period { get; public set; }
    public GarbageCollector(Lifetime lifetime, IGarbageProducer[] garbageProducers);
    private static GarbageCollector();
    private void TimerTask(object state);
    public sealed virtual void RequestGC();
    public sealed virtual TimeSpan get_Period();
    public sealed virtual void set_Period(TimeSpan value);
}
internal class JetBrains.Common.Util.Remoting.Impl.HostsAndProxies.DeferringHost : InterProcessHostBase`1<Getter`1<ILocked`1<IntPtr>>> {
    private ISharedMemoryManager myManager;
    private SharedMemoryPointer mySharedMemoryPointer;
    private IntPtr myViewPtr;
    private ILocked`1<IntPtr> myLocked;
    private IntPtr ReadyFlagAddress { get; }
    private IntPtr PointerAddress { get; }
    public DeferringHost(ICommunicatorForHost remoteComm, int proxyId);
    private IntPtr get_ReadyFlagAddress();
    private IntPtr get_PointerAddress();
    private IntPtr GetPointer();
    public virtual void InterProcessGetOffset(SharedMemoryPointer pointer);
    public virtual void ReadNextValue(BinaryReader reader, BinaryFormatter binaryFormatter);
    public virtual void InterProcessUpdateValue();
    private ILocked`1<IntPtr> Get();
}
internal class JetBrains.Common.Util.Remoting.Impl.HostsAndProxies.DeferringProxy`1 : InterProcessProxyBase`1<T> {
    private ISharedMemoryManager myManager;
    private SharedMemoryPointer mySharedMemoryPointer;
    private IntPtr myViewPtr;
    private IInterProcessLock myLock;
    private SharedResizeablePointer myResizeablePointer;
    private Action`2<T, IResizeablePointer> myFillAction;
    private IntPtr ReadyFlagAddress { get; }
    private bool ReadyFlag { get; private set; }
    public DeferringProxy`1(IDataProviderBase`1<T> source, ICommunicatorForProxy comm, int hostId, Action`2<T, IResizeablePointer> fillAction);
    public virtual void OnActivated();
    private IntPtr get_ReadyFlagAddress();
    private void Lock();
    private void Unlock();
    private bool get_ReadyFlag();
    private void set_ReadyFlag(bool value);
    public virtual void OnDeactivated();
    protected virtual void OnSourceUpdated(T newValue);
}
internal abstract class JetBrains.Common.Util.Remoting.Impl.HostsAndProxies.InterProcessHostBase`1 : DataProvider`1<T> {
    private int myProxyId;
    private ICommunicatorForHost myComm;
    public bool HasValue { get; }
    public int RemoteProxyId { get; }
    public InterProcessHostBase`1(ICommunicatorForHost comm, int proxyId);
    protected virtual bool OnActivated();
    private void ActivateHost();
    protected virtual void OnDeactivated();
    public virtual IDataProvider`1<IEnumerable`1<ProgressProvider>> GetProgressProvider();
    public virtual bool get_HasValue();
    public abstract virtual void ReadNextValue(BinaryReader reader, BinaryFormatter binaryFormatter);
    public abstract virtual void InterProcessUpdateValue();
    public abstract virtual void InterProcessGetOffset(SharedMemoryPointer pointer);
    public sealed virtual int get_RemoteProxyId();
}
internal abstract class JetBrains.Common.Util.Remoting.Impl.HostsAndProxies.InterProcessProxyBase`1 : object {
    [NotNullAttribute]
private IDataProviderInternal`1<T> mySource;
    private ICommunicatorForProxy myComm;
    private int myHostId;
    private bool myIsActive;
    protected ICommunicatorForProxy Comm { get; }
    protected int HostId { get; }
    protected bool IsActive { get; }
    public InterProcessProxyBase`1(IDataProviderBase`1<T> source, ICommunicatorForProxy comm, int hostId);
    protected ICommunicatorForProxy get_Comm();
    protected int get_HostId();
    public virtual void OnActivated();
    protected void UpdateValueFromSources();
    public virtual void OnDeactivated();
    protected bool get_IsActive();
    protected abstract virtual void OnSourceUpdated(T newValue);
    public sealed virtual IDataProvider`1<ProgressProvider[]> GetProgressesProvider();
}
internal class JetBrains.Common.Util.Remoting.Impl.HostsAndProxies.RecyclingHost : InterProcessHostBase`1<Getter`1<IntPtr>> {
    private ISharedMemoryManager myManager;
    private SharedMemoryPointer mySharedMemoryPointer;
    private IntPtr myViewPtr;
    private object mySharedPointerLock;
    public RecyclingHost(ICommunicatorForHost remoteComm, int proxyId);
    private RecyclingPointersState GetPointersState();
    public virtual void ReadNextValue(BinaryReader reader, BinaryFormatter binaryFormatter);
    public virtual void InterProcessUpdateValue();
    protected virtual void OnDeactivated();
    public virtual void InterProcessGetOffset(SharedMemoryPointer pointer);
    private IntPtr GrabValue();
}
internal class JetBrains.Common.Util.Remoting.Impl.HostsAndProxies.RecyclingPointersState : ValueType {
    public byte Buffer;
    public byte Ready;
    public byte Output;
    public bool ReadyFlag;
    public int Packed { get; }
    public RecyclingPointersState(int packed);
    public int get_Packed();
    public RecyclingPointersState SwapBufferReady();
    public RecyclingPointersState SwapReadyOutput();
}
internal class JetBrains.Common.Util.Remoting.Impl.HostsAndProxies.RecyclingProxy`1 : InterProcessProxyBase`1<T> {
    private Action`2<T, IResizeablePointer> myFillAction;
    private ISharedMemoryManager myManager;
    private Timer myTimer;
    private SharedMemoryPointer mySharedMemoryPointer;
    private IntPtr myViewPtr;
    private object myBackbufferDisposeLock;
    private SharedResizeablePointer[] myResizeablePointers;
    private static TimeSpan DisposeLockTimeout;
    public RecyclingProxy`1(IDataProviderBase`1<T> source, ICommunicatorForProxy comm, Action`2<T, IResizeablePointer> fillAction, int hostId);
    private static RecyclingProxy`1();
    private bool TryDisposeSharedMemory();
    private void OnTimedEvent(object source, ElapsedEventArgs e);
    private RecyclingPointersState GetPointersState();
    public virtual void OnActivated();
    public virtual void OnDeactivated();
    protected virtual void OnSourceUpdated(T newValue);
    private bool SetReady();
}
internal static class JetBrains.Common.Util.Remoting.Impl.HostsAndProxies.RecyclingUtils : object {
    public static int GetBufferOffsetForRecycling(int index);
}
internal static class JetBrains.Common.Util.Remoting.Impl.HostsAndProxies.RemoteProgressLoader : object {
    [CompilerGeneratedAttribute]
private static Func`2<IRemotableReference`1[], IDataProvider`1<IEnumerable`1<ProgressProvider>>> CS$<>9__CachedAnonymousMethodDelegate3;
    [CompilerGeneratedAttribute]
private static Func`2<IRemotableReference`1<IDataProvider`1<ProgressProvider>>, IDataProvider`1<ProgressProvider>> CS$<>9__CachedAnonymousMethodDelegate6;
    [CompilerGeneratedAttribute]
private static AcceptNewValue`1<<>f__AnonymousType1`2<List`1<ProgressProxyPair>, int>> CS$<>9__CachedAnonymousMethodDelegatec;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType1`2<List`1<ProgressProxyPair>, int>, List`1<ProgressProxyPair>> CS$<>9__CachedAnonymousMethodDelegated;
    [CompilerGeneratedAttribute]
private static Func`2<ProgressProxyPair, IRemotableReference`1<IDataProvider`1<ProgressProvider>>> CS$<>9__CachedAnonymousMethodDelegatee;
    internal static IDataProvider`1<IEnumerable`1<ProgressProvider>> GetProgress(ICommunicatorForHost comm, int proxyId);
    private static IDataProvider`1<IRemotableReference`1[]> Builder(ICommunicatorForHost comm, int proxyId);
    [CompilerGeneratedAttribute]
private static IDataProvider`1<IEnumerable`1<ProgressProvider>> <GetProgress>b__1(IRemotableReference`1[] array);
    [CompilerGeneratedAttribute]
private static IDataProvider`1<ProgressProvider> <GetProgress>b__2(IRemotableReference`1<IDataProvider`1<ProgressProvider>> a);
    [CompilerGeneratedAttribute]
private static bool <Builder>b__9(<>f__AnonymousType1`2<List`1<ProgressProxyPair>, int> o, <>f__AnonymousType1`2<List`1<ProgressProxyPair>, int> n);
    [CompilerGeneratedAttribute]
private static List`1<ProgressProxyPair> <Builder>b__a(<>f__AnonymousType1`2<List`1<ProgressProxyPair>, int> l);
    [CompilerGeneratedAttribute]
private static IRemotableReference`1<IDataProvider`1<ProgressProvider>> <Builder>b__b(ProgressProxyPair p);
}
internal class JetBrains.Common.Util.Remoting.Impl.HostsAndProxies.SimpleHost`1 : InterProcessHostBase`1<T> {
    private Func`3<BinaryReader, BinaryFormatter, T> myReadValue;
    private T myNextValueToUpdate;
    public SimpleHost`1(ICommunicatorForHost remoteComm, int proxyId, Func`3<BinaryReader, BinaryFormatter, T> readValue);
    public virtual void ReadNextValue(BinaryReader reader, BinaryFormatter binaryFormatter);
    public virtual void InterProcessUpdateValue();
    public virtual void InterProcessGetOffset(SharedMemoryPointer pointer);
}
internal class JetBrains.Common.Util.Remoting.Impl.HostsAndProxies.SimpleProxy`1 : InterProcessProxyBase`1<T> {
    private Action`3<BinaryWriter, BinaryFormatter, T> myFillAction;
    public SimpleProxy`1(IDataProviderBase`1<T> source, ICommunicatorForProxy comm, int hostId, Action`3<BinaryWriter, BinaryFormatter, T> fillAction);
    protected virtual void OnSourceUpdated(T newValue);
}
internal interface JetBrains.Common.Util.Remoting.Impl.IRemoteCommunicatorInternal {
    public string Id { get; }
    public abstract virtual string get_Id();
    public abstract virtual object GetObject(int localId);
}
internal interface JetBrains.Common.Util.Remoting.Impl.IRemoteReference`1 {
    public int Id { get; }
    public abstract virtual int get_Id();
}
internal class JetBrains.Common.Util.Remoting.Impl.Locked`1 : object {
    private Func`1<T> myGetData;
    private IInterProcessLock myLock;
    private string myId;
    public IInterProcessLock Lock { get; }
    internal Locked`1(IInterProcessLock _lock, Func`1<T> getData, string id);
    public IInterProcessLock get_Lock();
    public sealed virtual TResult Apply(Func`2<T, TResult> func);
}
internal class JetBrains.Common.Util.Remoting.Impl.NamedPipesComm : object {
    private static int DefaultMemorySize;
    private static int ConnectionTimeout;
    private static PipesLogger myLogger;
    private IRemoteCommandHandler myCommandHandler;
    private ReaderWriterLockSlim myTerminationLock;
    [ThreadStaticAttribute]
private static ThreadBuffer myThreadBuffer;
    private BinaryReader myBinaryReader;
    private int myWriteOperationsCounter;
    private PipeStream myOutgoingPipe;
    private SerializationContext mySerializationContext;
    private ISharedMemoryManager myMemoryManager;
    private BinaryFormatter myBinaryFormatter;
    private AsyncCallback myPipeEndWriteCallback;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) myIsDisposed;
    private Byte[] myReadBuffer;
    private PipeStream myIncomingPipe;
    private Lifetime myLifetime;
    private string myPipeName;
    private static TimeSpan ourTimeout;
    public ISharedMemoryManager MemoryManager { get; }
    public string Id { get; }
    public NamedPipesComm(string pipeName);
    private static NamedPipesComm();
    private static ThreadBuffer GetThreadBuffer();
    public sealed virtual void AddMemoryNode(int index, int size);
    public sealed virtual ISharedMemoryManager get_MemoryManager();
    public sealed virtual void SendMemoryPointer(int hostId, SharedMemoryPointer pointer);
    public sealed virtual void UpdateValue(int hostId, Action`2<BinaryWriter, BinaryFormatter> writeAction);
    public sealed virtual void Init(Lifetime lifetime, IRemoteCommandHandler commandHandler, SerializationContext serializationContext, bool isClient);
    public sealed virtual string get_Id();
    public void InitServer();
    private void Init();
    public void InitClient();
    private void InterProcessCall(int targetId, Commands cmd, object param);
    private void InterProcessCallCore(int targetId, Commands cmd, Action`2<BinaryWriter, BinaryFormatter> serializeAction);
    private PipeLocksController GetLockController();
    private void BeginReadPipe();
    private void ProcessMessage(Commands cmd, int target, BinaryReader reader, IPipeLocksController locksController);
    private void CreateHost(int remoteProxyId, BuildMessageData buildMsg);
    [UsedImplicitlyAttribute]
public void DoCreateHost(int remoteProxyId, int localHostId, Func`3<BinaryReader, BinaryFormatter, T> readValue);
    [UsedImplicitlyAttribute]
public void DoResolveProxyProvider(int localHostId, int localResolveDataProxyId);
    [UsedImplicitlyAttribute]
public void DoBuild(int localIdForResult, Func`1<TResult> builder);
    [UsedImplicitlyAttribute]
public void DoBuildReturn(int remoteResolveId, Func`1<IRemotableReference`1<IDataProvider`1<TResult>>> builder);
    private void OnPipeIsBroken();
    private void SerializeData(BinaryWriter writer, object data);
    private static MethodInfo GetInterProcessGenericMethod(Type className, string methodName, Type[] parametricTypes);
    private object DeserializeData(Stream stream);
    public sealed virtual void CreateRecyclingHost(int hostId, int proxyId);
    public sealed virtual void CreateDeferringHost(int hostId, int proxyId);
    public sealed virtual void CreateSimpleHost(int hostId, int proxyId, Func`3<BinaryReader, BinaryFormatter, T> valueReader);
    public sealed virtual void Build(int objectId, Func`1<T> builder);
    public sealed virtual void BuildReturn(int remoteResolveId, Func`1<IRemotableReference`1<IDataProvider`1<T>>> builder);
    public sealed virtual void Execute(Action action);
    public sealed virtual void ResolveProxyProvider(int hostId, int dataProxyId);
    public sealed virtual void OnActivated(int proxyId);
    public sealed virtual void OnDeactivated(int proxyId);
    public sealed virtual void OnRemoteException(Exception e);
    public sealed virtual void RemoveObjectReference(int objectId);
    private sealed virtual override void JetBrains.Common.Util.Remoting.Internal.IRemoteCommands.RemoveProxy(int proxyId);
    private void WaitForWriteOperationsCompletion(TimeSpan timeout);
    private void Dispose();
    [CompilerGeneratedAttribute]
private void <Init>b__4(IAsyncResult ar);
    [CompilerGeneratedAttribute]
private void <BeginReadPipe>b__b(IAsyncResult ar);
    [CompilerGeneratedAttribute]
private void <Dispose>b__1a();
}
internal static class JetBrains.Common.Util.Remoting.Impl.NativeUtilsApi : object {
    public static SimpleSharedMemoryAllocDelegate SimpleSharedMemoryAlloc;
    public static SimpleSharedMemoryBlockSizeDelegate SimpleSharedMemoryBlockSize;
    public static SimpleSharedMemoryFreeDelegate SimpleSharedMemoryFree;
    public static SimpleSharedMemoryInitDelegate SimpleSharedMemoryInit;
    public static SimpleSharedMemoryToOffsetDelegate SimpleSharedMemoryToOffset;
    public static SimpleSharedMemoryToPointerDelegate SimpleSharedMemoryToPointer;
    private static NativeUtilsApi();
}
internal class JetBrains.Common.Util.Remoting.Impl.NotInitializedDataProviderStub`1 : ConstDataProvider`1<T> {
    public virtual IDataProvider`1<IEnumerable`1<ProgressProvider>> GetProgressProvider();
    public virtual bool Subscribe(ValueUpdatedHandler`1<T> handler);
}
internal class JetBrains.Common.Util.Remoting.Impl.ObjectReferenceProcessor : object {
    private int myNextLocalId;
    private int myNextRemoteId;
    private static PipesLogger myLogger;
    private Dictionary`2<int, object> myObjects;
    private Dictionary`2<int, WeakReference> myRemoteReferences;
    private ICommunicatorForObjectTracker myComm;
    [CompilerGeneratedAttribute]
private static Func`2<KeyValuePair`2<int, WeakReference>, bool> CS$<>9__CachedAnonymousMethodDelegate7;
    public int ObjectRefsCount { get; }
    public ObjectReferenceProcessor(Lifetime lifetime, ICommunicatorForObjectTracker comm);
    private static ObjectReferenceProcessor();
    private void ClearAll();
    public sealed virtual int AddObjectRef(object targetObject);
    private void AddObjectRefCore(int id, object targetObject);
    public sealed virtual void AddObjectRef(int id, object targetObject);
    public sealed virtual RemoteReference`1<T> GetOrCreateRemoteObjectRef(int id);
    public sealed virtual object GetObject(int id);
    public sealed virtual void CollectGarbage();
    public sealed virtual void RemoveObject(int id);
    public sealed virtual int get_ObjectRefsCount();
    public sealed virtual int GetObjectsCount();
    public sealed virtual int NewLocalId();
    public sealed virtual int NewRemoteId();
    [CompilerGeneratedAttribute]
private static bool <CollectGarbage>b__6(KeyValuePair`2<int, WeakReference> p);
}
internal class JetBrains.Common.Util.Remoting.Impl.ReadonlyPointer : object {
    [CompilerGeneratedAttribute]
private IntPtr <Pointer>k__BackingField;
    public IntPtr Pointer { get; private set; }
    public ReadonlyPointer(int size);
    [CompilerGeneratedAttribute]
public sealed virtual IntPtr get_Pointer();
    [CompilerGeneratedAttribute]
private void set_Pointer(IntPtr value);
    protected virtual void Finalize();
}
internal class JetBrains.Common.Util.Remoting.Impl.RemotablePair`1 : object {
    [NotNullAttribute]
private IRemotableReference`1<T> myFirst;
    [NotNullAttribute]
private IRemotableReference`1<T> mySecond;
    public T Value { get; }
    public IRemotableReference`1<T> RemoteReference { get; }
    public IRemotableReference`1<T> LocalReference { get; }
    public RemotablePair`1(IRemotableReference`1<T> first, IRemotableReference`1<T> second);
    public sealed virtual T get_Value();
    public sealed virtual IRemotableReference`1<T> get_RemoteReference();
    public sealed virtual IRemotableReference`1<T> get_LocalReference();
}
internal class JetBrains.Common.Util.Remoting.Impl.RemotableReference`1 : object {
    [NotNullAttribute]
internal IRemotableReferenceCore`1<T> Reference;
    [CanBeNullAttribute]
private IRemoteCommunicator myComm;
    public T Value { get; }
    public bool IsLocal { get; }
    public RemotableReference`1(T value);
    public RemotableReference`1(RemoteReference`1<T> reference, IRemoteCommunicator comm);
    public RemotableReference`1(SerializationInfo info, StreamingContext context);
    public sealed virtual T get_Value();
    public sealed virtual IRemoteCommunicator GetComm();
    public sealed virtual int GetRemoteId();
    public sealed virtual bool get_IsLocal();
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
internal class JetBrains.Common.Util.Remoting.Impl.RemoteCommunicator : object {
    private IObjectReferenceProcessor myReferenceProcessor;
    private Action`1<Exception> myRemoteExceptionHandler;
    private Dictionary`2<int, HostReference> myHosts;
    private HashSet`1<IInterProcessHost> myActivatedHosts;
    private Dispatcher myMainDispatcher;
    private Dictionary`2<int, object> myLocalReturnProxies;
    private object myLock;
    private IGarbageCollector myGarbageCollector;
    private Dictionary`2<int, IInterProcessProxy> myProxies;
    private static PipesLogger myLogger;
    private IRemoteCommandExecutor myCommandExecutor;
    private bool myIsClient;
    private Signal`1<IRemoteCommunicator> myConnectionBroken;
    private bool myIsAlive;
    private string myId;
    [CompilerGeneratedAttribute]
private static Func`2<KeyValuePair`2<int, HostReference>, bool> CS$<>9__CachedAnonymousMethodDelegate3;
    private Dispatcher Dispatcher { get; }
    public TimeSpan GcPeriod { get; public set; }
    public string Id { get; }
    public bool IsClient { get; }
    public bool IsAlive { get; }
    public ISignal`1<IRemoteCommunicator> ConnectionBroken { get; }
    public IRemoteCommunicator Communicator { get; }
    public ISharedMemoryManager MemoryManager { get; }
    public int LocalReturnProxiesCount { get; }
    public int ProxiesCount { get; }
    public int HostsCount { get; }
    public ILayout Layout { get; public set; }
    internal RemoteCommunicator(Lifetime lifetime, Action`1<Exception> remoteExceptionHandler, IRemoteCommandsExecutorInternal commandExecutor, bool isClient);
    private static RemoteCommunicator();
    private void ClearAll();
    private Dispatcher get_Dispatcher();
    public sealed virtual void CollectGarbage();
    public sealed virtual int GetObjectsCount();
    public sealed virtual TimeSpan get_GcPeriod();
    public sealed virtual void set_GcPeriod(TimeSpan value);
    public sealed virtual IDataProvider`1<TResult> BuildReturn(Func`1<IRemotableReference`1<IDataProvider`1<TResult>>> builder);
    public sealed virtual IRemotableReference`1<TResult> Build(Func`1<TResult> builder);
    public sealed virtual void ExecuteRemote(Action builder);
    public sealed virtual IRemotableReference`1<IDataProvider`1<TB>> SwitchRemote(IDataProviderBase`1<TA> source, Action`3<BinaryWriter, BinaryFormatter, TA> fillAction, Func`3<BinaryReader, BinaryFormatter, TB> readValue);
    public sealed virtual IRemotableReference`1<IDataProvider`1<Getter`1<ILocked`1<IntPtr>>>> SwitchRemoteDeferring(IDataProviderBase`1<T> source, Action`2<T, IResizeablePointer> fillAction);
    public sealed virtual IRemotableReference`1<IDataProvider`1<Getter`1<IntPtr>>> SwitchRemoteRecycling(IDataProviderBase`1<T> source, Action`2<T, IResizeablePointer> fillAction);
    public sealed virtual string get_Id();
    public sealed virtual object GetObject(int localId);
    public sealed virtual bool get_IsClient();
    public sealed virtual bool get_IsAlive();
    public sealed virtual ISignal`1<IRemoteCommunicator> get_ConnectionBroken();
    internal void AddProxy(int id, IInterProcessProxy proxy);
    [CanBeNullAttribute]
public sealed virtual IInterProcessHost GetHost(int id);
    private void AddReturnProxy(int localProxyId, IDataProxy`1<T> proxy);
    private void ResolveProxyOnMainThread(int resolveProxyId, IDataProvider`1<T> hostProvider);
    internal void AddHost(int id, IInterProcessHost host);
    public sealed virtual void CreateRecyclingHost(int hostId, int proxyId);
    public sealed virtual void CreateDeferringHost(int hostId, int proxyId);
    public sealed virtual void CreateSimpleHost(int hostId, int proxyId, Func`3<BinaryReader, BinaryFormatter, T> valueReader);
    public sealed virtual void ReceiveMemoryPointer(int hostId, SharedMemoryPointer pointer);
    public sealed virtual void Build(int objectId, Func`1<T> builder);
    private void DoBuildObjectRefDispatcher(int localIdForResult, Func`1<TResult> builder);
    public sealed virtual void BuildReturn(int remoteResolveId, Func`1<IRemotableReference`1<IDataProvider`1<T>>> builder);
    private void DoBuildRemoteDispatcher(int remoteResolveId, Func`1<IRemotableReference`1<IDataProvider`1<T>>> builder);
    public sealed virtual void Execute(Action action);
    public sealed virtual void ResolveProxyProvider(int hostId, int dataProxyId);
    [CanBeNullAttribute]
public sealed virtual IInterProcessProxy GetProxy(int id);
    public sealed virtual void OnActivated(int proxyId);
    public sealed virtual void OnDeactivated(int proxyId);
    public sealed virtual void OnRemoteException(Exception e);
    public sealed virtual void RemoveObjectReference(int objectId);
    public sealed virtual void OnObjectReferenceRemoved(int id);
    public sealed virtual IRemoteCommunicator get_Communicator();
    private void DoRemoveProxy(int proxyId);
    public sealed virtual void RemoveProxy(int proxyId);
    public sealed virtual void ConnectionIsBroken(bool duringDispose);
    public sealed virtual void ActivateHost(IInterProcessHost host);
    public sealed virtual void DeactivateHost(IInterProcessHost host);
    public sealed virtual ISharedMemoryManager get_MemoryManager();
    public sealed virtual int get_LocalReturnProxiesCount();
    public int get_ProxiesCount();
    public sealed virtual int get_HostsCount();
    public sealed virtual ILayout get_Layout();
    public sealed virtual void set_Layout(ILayout value);
    public sealed virtual void OnLogEvent(LogEvent logEvent);
    [CompilerGeneratedAttribute]
private static bool <CollectGarbage>b__2(KeyValuePair`2<int, HostReference> p);
    [CompilerGeneratedAttribute]
private void <OnActivated>b__6(int id);
    [CompilerGeneratedAttribute]
private void <OnDeactivated>b__7(int id);
}
internal class JetBrains.Common.Util.Remoting.Impl.RemoteReference`1 : object {
    [CompilerGeneratedAttribute]
private int <Id>k__BackingField;
    public int Id { get; private set; }
    public RemoteReference`1(int id);
    [CompilerGeneratedAttribute]
public sealed virtual int get_Id();
    [CompilerGeneratedAttribute]
private void set_Id(int value);
}
[ExtensionAttribute]
internal static class JetBrains.Common.Util.Remoting.Impl.RemoteReferenceHelpers : object {
    [ExtensionAttribute]
public static IRemotableReference`1<T> ToRemotable(RemoteReference`1<T> r, IRemoteCommunicator comm);
}
internal class JetBrains.Common.Util.Remoting.Impl.ResizeablePointer : object {
    [CompilerGeneratedAttribute]
private IntPtr <Pointer>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Size>k__BackingField;
    public IntPtr Pointer { get; private set; }
    public int Size { get; private set; }
    [CompilerGeneratedAttribute]
public sealed virtual IntPtr get_Pointer();
    [CompilerGeneratedAttribute]
private void set_Pointer(IntPtr value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_Size();
    [CompilerGeneratedAttribute]
private void set_Size(int value);
    public sealed virtual void Allocate(int size);
    public sealed virtual void Dispose();
}
internal static class JetBrains.Common.Util.Remoting.Impl.Serialization.PipeSerialization : object {
    public static PipesLogger Logger;
    [CompilerGeneratedAttribute]
private static Func`1<object> CS$<>9__CachedAnonymousMethodDelegate1;
    private static PipeSerialization();
    [NotNullAttribute]
public static object PackIntoSerializable(object value);
    [CanBeNullAttribute]
public static object ExtractFromSerializable(Type type, object data);
    [CompilerGeneratedAttribute]
private static object <PackIntoSerializable>b__0();
}
internal class JetBrains.Common.Util.Remoting.Impl.Serialization.SerializableClass : object {
    public object Obj;
    internal SerializableClass(object bobject);
    internal SerializableClass(SerializationInfo info, StreamingContext context);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
}
internal class JetBrains.Common.Util.Remoting.Impl.Serialization.SerializableComm : object {
    public static SerializableComm Instance;
    public IRemoteCommunicator Comm;
    public SerializableComm(SerializationInfo info, StreamingContext context);
    private static SerializableComm();
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public class JetBrains.Common.Util.Remoting.Impl.Serialization.SerializableDelegate : object {
    [NotNullAttribute]
private Delegate myDelegate;
    public Delegate Delegate { get; }
    internal SerializableDelegate(Delegate delegate_);
    protected SerializableDelegate(SerializationInfo info, StreamingContext context);
    public Delegate get_Delegate();
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    public static SerializableDelegate`1<T> Create(T _delegate);
}
public class JetBrains.Common.Util.Remoting.Impl.Serialization.SerializableDelegate`1 : object {
    [NotNullAttribute]
private SerializableDelegate myDelegate;
    [NotNullAttribute]
public T Delegate { get; }
    public SerializableDelegate`1(T src);
    public T get_Delegate();
}
internal class JetBrains.Common.Util.Remoting.Impl.Serialization.SerializableNull : object {
    public static SerializableNull Instance;
    private static SerializableNull();
}
internal class JetBrains.Common.Util.Remoting.Impl.Serialization.SerializationContext : object {
    public bool IsClient;
    private IObjectReferenceProcessor myObjectReferenceProcessor;
    private IRemoteCommunicator myRemoteComm;
    private Action`1<Exception> myHandleException;
    [CompilerGeneratedAttribute]
private bool <IsDisposed>k__BackingField;
    public IObjectReferenceProcessor ObjectReferenceProcessor { get; }
    public IRemoteCommunicator RemoteComm { get; }
    public Action`1<Exception> HandleException { get; }
    public bool IsDisposed { get; private set; }
    public SerializationContext(Lifetime lifetime, IObjectReferenceProcessor objectReferenceProcessor, IRemoteCommunicator remoteComm, bool isClient, Action`1<Exception> handleException);
    public IObjectReferenceProcessor get_ObjectReferenceProcessor();
    public IRemoteCommunicator get_RemoteComm();
    public Action`1<Exception> get_HandleException();
    [CompilerGeneratedAttribute]
public bool get_IsDisposed();
    [CompilerGeneratedAttribute]
private void set_IsDisposed(bool value);
    [CompilerGeneratedAttribute]
private void <.ctor>b__0();
}
public static class JetBrains.Common.Util.Remoting.Impl.Serialization.SerializationStack : object {
    [ThreadStaticAttribute]
private static Stack`1<Type> ourStack;
    private static Stack`1<Type> Stack { get; }
    public static string CurrentStack { get; }
    private static Stack`1<Type> get_Stack();
    public static SerializationToken Start(Type type);
    public static string get_CurrentStack();
}
internal static class JetBrains.Common.Util.Remoting.Impl.Serialization.SerializationUtils : object {
    internal static string GetFieldTypeKey(string fieldName);
    internal static bool IsSimpleDelegate(Delegate _delegate);
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Common.Util.Remoting.Impl.SharedMemoryList`1 : object {
    private static int DefaultFirstSize;
    private ISharedMemoryManager myManager;
    private List`1<SharedMemoryPointer> myPointers;
    private int myStructureSize;
    private int myVersion;
    private Func`2<IntPtr, T> myRead;
    [CompilerGeneratedAttribute]
private int <Count>k__BackingField;
    public int Capacity { get; }
    public int Count { get; private set; }
    public bool IsReadOnly { get; }
    public T Item { get; public set; }
    public SharedMemoryList`1(ISharedMemoryManager manager);
    public int get_Capacity();
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual bool Remove(T item);
    [CompilerGeneratedAttribute]
public sealed virtual int get_Count();
    [CompilerGeneratedAttribute]
private void set_Count(int value);
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual int IndexOf(T item);
    public sealed virtual void Insert(int index, T item);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    private void EnsureCapacity();
    public void TrimExcess();
    [CompilerGeneratedAttribute]
private T <CopyTo>b__0(SharedMemoryPointer x);
}
internal static class JetBrains.Common.Util.Remoting.Impl.SharedMemoryLogger : object {
    private static PipesLogger Logger;
    private static SharedMemoryLogger();
    public static void Message(string message, Object[] args);
}
public class JetBrains.Common.Util.Remoting.Impl.SharedMemoryManager : object {
    private List`1<SharedMemoryBlock> myBlocks;
    private ICommunicatorForMemoryManager myComm;
    private int myDefaultSize;
    private Lifetime myLifetime;
    private object myLock;
    private int myNextSize;
    public int NodesCount { get; }
    public SharedMemoryManager(Lifetime lifetime, int defaultSize);
    internal SharedMemoryManager(Lifetime lifetime, int defaultSize, ICommunicatorForMemoryManager comm);
    public int get_NodesCount();
    public sealed virtual void CreateNewNode(int index, int size);
    public sealed virtual SharedMemoryPointer Allocate(int size);
    public sealed virtual void Free(SharedMemoryPointer ptr);
    public sealed virtual IntPtr GetPointer(SharedMemoryPointer ptr);
    public sealed virtual int GetAllocatedSize(SharedMemoryPointer ptr);
    private SharedMemoryBlock InitMemoryBlock(int index, int size);
}
public class JetBrains.Common.Util.Remoting.Impl.SharedMemoryPointer : ValueType {
    public static int StructureSize;
    public static SharedMemoryPointer Invalid;
    public int Index;
    public int Offset;
    public bool IsValid { get; }
    public SharedMemoryPointer(int index, int offset);
    private static SharedMemoryPointer();
    public bool get_IsValid();
    public sealed virtual bool Equals(SharedMemoryPointer other);
    public void Write(IntPtr ptr, int offset);
    public static SharedMemoryPointer Read(IntPtr ptr, int offset);
    public virtual string ToString();
}
internal class JetBrains.Common.Util.Remoting.Impl.SharedResizeablePointer : object {
    private ISharedMemoryManager myManager;
    private IntPtr myPointerAddress;
    private SharedMemoryPointer mySharedPointer;
    [CompilerGeneratedAttribute]
private IntPtr <Pointer>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Size>k__BackingField;
    public IntPtr Pointer { get; private set; }
    public int Size { get; private set; }
    public SharedMemoryPointer SharedPointer { get; public set; }
    public SharedResizeablePointer(ISharedMemoryManager memoryManager, IntPtr pointerAddress);
    private void UpdatePointerAndSize();
    [CompilerGeneratedAttribute]
public sealed virtual IntPtr get_Pointer();
    [CompilerGeneratedAttribute]
private void set_Pointer(IntPtr value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_Size();
    [CompilerGeneratedAttribute]
private void set_Size(int value);
    public void Free();
    public SharedMemoryPointer get_SharedPointer();
    public void set_SharedPointer(SharedMemoryPointer value);
    public sealed virtual void Allocate(int size);
}
internal interface JetBrains.Common.Util.Remoting.Internal.ICommunicatorForHost {
    public ISharedMemoryManager MemoryManager { get; }
    public abstract virtual void ActivateHost(IInterProcessHost host);
    public abstract virtual void DeactivateHost(IInterProcessHost host);
    public abstract virtual ISharedMemoryManager get_MemoryManager();
    [CanBeNullAttribute]
public abstract virtual IInterProcessProxy GetProxy(int id);
}
internal interface JetBrains.Common.Util.Remoting.Internal.ICommunicatorForMemoryManager {
    public abstract virtual void AddMemoryNode(int index, int size);
}
internal interface JetBrains.Common.Util.Remoting.Internal.ICommunicatorForObjectTracker {
    public IRemoteCommunicator Communicator { get; }
    public abstract virtual void OnObjectReferenceRemoved(int id);
    public abstract virtual IRemoteCommunicator get_Communicator();
}
internal interface JetBrains.Common.Util.Remoting.Internal.ICommunicatorForProxy {
    public ISharedMemoryManager MemoryManager { get; }
    public abstract virtual void SendMemoryPointer(int hostId, SharedMemoryPointer pointer);
    public abstract virtual void UpdateValue(int hostId, Action`2<BinaryWriter, BinaryFormatter> writeAction);
    public abstract virtual ISharedMemoryManager get_MemoryManager();
}
internal interface JetBrains.Common.Util.Remoting.Internal.IGarbageCollector {
    public TimeSpan Period { get; public set; }
    public abstract virtual void RequestGC();
    public abstract virtual TimeSpan get_Period();
    public abstract virtual void set_Period(TimeSpan value);
}
internal interface JetBrains.Common.Util.Remoting.Internal.IGarbageProducer {
    public abstract virtual void CollectGarbage();
}
public interface JetBrains.Common.Util.Remoting.Internal.IInterProcessHost {
    public int RemoteProxyId { get; }
    public abstract virtual void ReadNextValue(BinaryReader reader, BinaryFormatter binaryFormatter);
    public abstract virtual void InterProcessUpdateValue();
    public abstract virtual void InterProcessGetOffset(SharedMemoryPointer pointer);
    public abstract virtual int get_RemoteProxyId();
}
internal interface JetBrains.Common.Util.Remoting.Internal.IInterProcessLock {
    public abstract virtual void Lock();
    public abstract virtual void Unlock();
}
public interface JetBrains.Common.Util.Remoting.Internal.IInterProcessProxy {
    public abstract virtual void OnActivated();
    public abstract virtual IDataProvider`1<ProgressProvider[]> GetProgressesProvider();
    public abstract virtual void OnDeactivated();
}
internal interface JetBrains.Common.Util.Remoting.Internal.IObjectReferenceProcessor {
    public int ObjectRefsCount { get; }
    public abstract virtual int AddObjectRef(object targetObject);
    public abstract virtual void AddObjectRef(int id, object targetObject);
    public abstract virtual object GetObject(int id);
    public abstract virtual void RemoveObject(int id);
    public abstract virtual int get_ObjectRefsCount();
    public abstract virtual int GetObjectsCount();
    public abstract virtual int NewLocalId();
    public abstract virtual int NewRemoteId();
    public abstract virtual RemoteReference`1<T> GetOrCreateRemoteObjectRef(int id);
}
internal interface JetBrains.Common.Util.Remoting.Internal.IRemotableReferenceInternal`1 {
    [CanBeNullAttribute]
public abstract virtual IRemoteCommunicator GetComm();
    public abstract virtual int GetRemoteId();
}
internal interface JetBrains.Common.Util.Remoting.Internal.IRemoteCommandExecutor {
}
internal interface JetBrains.Common.Util.Remoting.Internal.IRemoteCommandHandler {
    public abstract virtual IInterProcessHost GetHost(int id);
    public abstract virtual void ReceiveMemoryPointer(int hostId, SharedMemoryPointer pointer);
    public abstract virtual void ConnectionIsBroken(bool duringDispose);
}
internal interface JetBrains.Common.Util.Remoting.Internal.IRemoteCommands {
    public abstract virtual void CreateRecyclingHost(int hostId, int proxyId);
    public abstract virtual void CreateDeferringHost(int hostId, int proxyId);
    public abstract virtual void CreateSimpleHost(int hostId, int proxyId, Func`3<BinaryReader, BinaryFormatter, T> valueReader);
    public abstract virtual void Build(int objectId, Func`1<T> builder);
    public abstract virtual void BuildReturn(int remoteResolveId, Func`1<IRemotableReference`1<IDataProvider`1<T>>> builder);
    public abstract virtual void Execute(Action action);
    public abstract virtual void ResolveProxyProvider(int hostId, int dataProxyId);
    public abstract virtual void OnActivated(int proxyId);
    public abstract virtual void OnDeactivated(int proxyId);
    public abstract virtual void OnRemoteException(Exception e);
    public abstract virtual void RemoveProxy(int proxyId);
    public abstract virtual void RemoveObjectReference(int id);
}
internal interface JetBrains.Common.Util.Remoting.Internal.IRemoteCommandsExecutorInternal {
    public string Id { get; }
    public abstract virtual void Init(Lifetime lifetime, IRemoteCommandHandler commandHandler, SerializationContext serializationContext, bool isClient);
    public abstract virtual string get_Id();
}
public interface JetBrains.Common.Util.Remoting.Internal.ISharedMemoryManager {
    public abstract virtual void CreateNewNode(int index, int size);
    public abstract virtual SharedMemoryPointer Allocate(int size);
    public abstract virtual void Free(SharedMemoryPointer ptr);
    public abstract virtual IntPtr GetPointer(SharedMemoryPointer ptr);
    public abstract virtual int GetAllocatedSize(SharedMemoryPointer ptr);
}
internal static class JetBrains.Common.Util.Remoting.Internal.RemoteCommunicators : object {
    private static IDictionary`2<string, IRemoteCommunicatorInternal> ourMap;
    private static RemoteCommunicators();
    [CanBeNullAttribute]
public static IRemoteCommunicatorInternal GetCommunicator(string id);
    public static void RegisterCommunicator(Lifetime lifetime, IRemoteCommunicatorInternal comm);
}
public enum JetBrains.Common.Util.Remoting.InterProcessTransferMode : Enum {
    public byte value__;
    public static InterProcessTransferMode Simple;
    public static InterProcessTransferMode Deferring;
    public static InterProcessTransferMode Recycling;
}
public interface JetBrains.Common.Util.Remoting.IReadonlyPointer {
    public IntPtr Pointer { get; }
    public abstract virtual IntPtr get_Pointer();
}
public interface JetBrains.Common.Util.Remoting.IRemotablePair`1 {
    public T Value { get; }
    [CanBeNullAttribute]
public IRemotableReference`1<T> RemoteReference { get; }
    [NotNullAttribute]
public IRemotableReference`1<T> LocalReference { get; }
    public abstract virtual T get_Value();
    public abstract virtual IRemotableReference`1<T> get_RemoteReference();
    public abstract virtual IRemotableReference`1<T> get_LocalReference();
}
public interface JetBrains.Common.Util.Remoting.IRemotableReference`1 {
    public T Value { get; }
    public bool IsLocal { get; }
    public abstract virtual T get_Value();
    public abstract virtual bool get_IsLocal();
}
public interface JetBrains.Common.Util.Remoting.IRemoteCommunicator {
    public bool IsClient { get; }
    public bool IsAlive { get; }
    public ISignal`1<IRemoteCommunicator> ConnectionBroken { get; }
    public abstract virtual IDataProvider`1<TResult> BuildReturn(Func`1<IRemotableReference`1<IDataProvider`1<TResult>>> builder);
    public abstract virtual IRemotableReference`1<TResult> Build(Func`1<TResult> builder);
    public abstract virtual void ExecuteRemote(Action builder);
    public abstract virtual IRemotableReference`1<IDataProvider`1<TB>> SwitchRemote(IDataProviderBase`1<TA> source, Action`3<BinaryWriter, BinaryFormatter, TA> fillAction, Func`3<BinaryReader, BinaryFormatter, TB> readValue);
    public abstract virtual IRemotableReference`1<IDataProvider`1<Getter`1<ILocked`1<IntPtr>>>> SwitchRemoteDeferring(IDataProviderBase`1<T> source, Action`2<T, IResizeablePointer> fillAction);
    public abstract virtual IRemotableReference`1<IDataProvider`1<Getter`1<IntPtr>>> SwitchRemoteRecycling(IDataProviderBase`1<T> source, Action`2<T, IResizeablePointer> fillAction);
    public abstract virtual bool get_IsClient();
    public abstract virtual bool get_IsAlive();
    public abstract virtual ISignal`1<IRemoteCommunicator> get_ConnectionBroken();
}
public interface JetBrains.Common.Util.Remoting.IRemoteCommunicatorMonitor {
    public int LocalReturnProxiesCount { get; }
    public int HostsCount { get; }
    public TimeSpan GcPeriod { get; public set; }
    public abstract virtual int get_LocalReturnProxiesCount();
    public abstract virtual int get_HostsCount();
    public abstract virtual void CollectGarbage();
    public abstract virtual int GetObjectsCount();
    public abstract virtual TimeSpan get_GcPeriod();
    public abstract virtual void set_GcPeriod(TimeSpan value);
}
public interface JetBrains.Common.Util.Remoting.IResizeablePointer {
    public IntPtr Pointer { get; }
    public int Size { get; }
    public abstract virtual IntPtr get_Pointer();
    public abstract virtual int get_Size();
    public abstract virtual void Allocate(int size);
}
public interface JetBrains.Common.Util.Remoting.IStreamSerializable {
    public abstract virtual void Serialize(BinaryWriter writer);
    public abstract virtual void Restore(BinaryReader reader);
}
public class JetBrains.Common.Util.Remoting.NotRemotablePair`1 : object {
    private IRemotableReference`1<T> myValue;
    public T Value { get; }
    public IRemotableReference`1<T> RemoteReference { get; }
    public IRemotableReference`1<T> LocalReference { get; }
    public NotRemotablePair`1(T value);
    public sealed virtual T get_Value();
    public sealed virtual IRemotableReference`1<T> get_RemoteReference();
    public sealed virtual IRemotableReference`1<T> get_LocalReference();
}
public enum JetBrains.Common.Util.Remoting.PlatformKind : Enum {
    public int value__;
    public static PlatformKind X86;
    public static PlatformKind Current;
    public static PlatformKind X64Preferred;
}
public static class JetBrains.Common.Util.Remoting.RemoteDataPipesFactory : object {
    public static IRemoteCommunicator Create(Lifetime lifetime, Action`1<Exception> remoteExceptionHandler, string pipeName, bool isClient);
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Common.Util.RingBuffer`1 : object {
    private int myBufferSize;
    private List`1<T> myList;
    private int myFirstIndex;
    private int myVersion;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public T Item { get; public set; }
    public RingBuffer`1(int bufferSize);
    public sealed virtual int get_Count();
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual bool Remove(T item);
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual int IndexOf(T item);
    public sealed virtual void Insert(int index, T item);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    private int GetPrivateIndex(int index);
}
public static class JetBrains.Common.Util.SequenceUtils : object {
    public static IEnumerable`1<Interval> FindGapIntervals(UInt32 start, IEnumerable`1<UInt32> sequence, UInt32 step);
    public static Interval FindLastLargestSubWordOccurrence(IReadOnlyList`1<T> text, IReadOnlyList`1<T> word, UInt32 minLength, UInt32 maxLength);
    public static IEnumerable`1<Interval> FindSubWordOccurrences(IReadOnlyList`1<T> text, IReadOnlyList`1<T> word, UInt32 minLength, UInt32 maxLength);
    [CompilerGeneratedAttribute]
private static UInt32 <FindLastLargestSubWordOccurrence>b__8(Interval x);
    [CompilerGeneratedAttribute]
private static UInt32 <FindLastLargestSubWordOccurrence>b__9(Interval x);
}
public class JetBrains.Common.Util.SequentialIterators`1 : object {
    private bool myCanMove;
    private bool myFirstIterationStarted;
    private bool myFirstIterationFinished;
    private IEnumerator`1<T> mySourceEnumerator;
    private Func`2<T, bool> myPredF;
    private Func`2<T, bool> myPredS;
    private T myCurrentElement;
    public IEnumerator`1<T> FirstIterator { get; }
    public IEnumerator`1<T> SecondIterator { get; }
    public SequentialIterators`1(IEnumerable`1<T> sourceData, Func`2<T, bool> pred1, Func`2<T, bool> pred2);
    public IEnumerator`1<T> get_FirstIterator();
    public IEnumerator`1<T> get_SecondIterator();
    public void Reset();
    public IEnumerable`1<T> FirstEnumerable();
    public IEnumerable`1<T> SecondEnumerable();
    private bool MoveWithValueShift();
}
public class JetBrains.Common.Util.SequentialTaskExecutor : object {
    private ITask modreq(System.Runtime.CompilerServices.IsVolatile) myRunningTask;
    private Queue`1<ITask> myTasks;
    private Action`1<ITask> myExecutor;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) myIsTerminated;
    private object myLock;
    [ThreadSafeAttribute]
public bool HasRunningTask { get; }
    public SequentialTaskExecutor(Action`1<ITask> executor);
    public sealed virtual bool get_HasRunningTask();
    private void WaitForCurrentTask();
    [ThreadSafeAttribute]
private void StartNextTask(bool onlyIfRunningTaskIsNull);
    private bool CancelAllTasksAndQueue(ITask newTask);
    private static IList`1<T> DequeueAll(Queue`1<T> queue);
    [ThreadSafetyAttribute("1")]
private void TaskOnFinished(ITask sender, EventArgs args);
    public sealed virtual bool ExecuteExclusively(ITask task);
    public sealed virtual void Enqueue(ITask task);
    [ThreadSafeAttribute]
public sealed virtual bool CancelAllTasks();
    public static SequentialTaskExecutor CreateWithThreadPool();
    public sealed virtual void PrepareForDispose();
    public sealed virtual void Dispose();
}
public class JetBrains.Common.Util.SetAndListSynchronizer`2 : object {
    private IObservableSet`1<TSet> mySet;
    private Func`2<TSet, TList> mySetToListConverter;
    private Func`2<TList, TSet> myListToSetConverter;
    private IList`1<TList> myList;
    private bool myListIsMaster;
    public SetAndListSynchronizer`2(IObservableSet`1<TSet> set, IList`1<TList> list, Func`2<TSet, TList> setToListConverter, Func`2<TList, TSet> listToSetConverter, bool listIsMaster);
    public sealed virtual void StartSynchronizing();
    public sealed virtual void StopSynchronizing();
    private void StartListenList();
    private void StartListenSet();
    private void StopListenList();
    private void StopListenSet();
    private void OnSetChanged(object sender, NotifySetChangedEventArgs`1<TSet> e);
    private void OnCollectionChanged(object sender, NotifyCollectionChangedEventArgs e);
    private void CopyValues(IEnumerable`1<A> sourceList, ICollection`1<B> targetList, Func`2<A, B> converter);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.SettingsExtension : object {
    [ExtensionAttribute]
public static IIndexedKey`1<TKey> CreateIndexedKey(ISettings settings, object indexKey, IDictionary`2<Type, object> parentIndex);
    [ExtensionAttribute]
public static void DeleteIndexedKey(ISettings settings, object indexKey, IDictionary`2<Type, object> parentIndex);
    [ExtensionAttribute]
public static IIndexedKey`1<TKey> CreateIndexedKey(ISettings settings, object indexKey, Lifetime lifetime, IDictionary`2<Type, object> parentIndex);
    [ExtensionAttribute]
public static IIndexedKey`1<TKey> GetKey(ISettings settings, object indexKey, IDictionary`2<Type, object> parentIndex);
    [ExtensionAttribute]
public static IKey`1<TKey> GetKey(ISettings settings, IDictionary`2<Type, object> parentIndex);
    [ExtensionAttribute]
public static IEnumerable`1<IIndexedKey`1<TKey>> GetAllKeys(ISettings settings, IDictionary`2<Type, object> parentIndex);
    [ExtensionAttribute]
public static IEnumerable`1<TKey> GetAllEntries(ISettings settings, IDictionary`2<Type, object> parentIndex, bool ignoreKeyIsDefined);
    [ExtensionAttribute]
public static IDictionary`2<TIndex, TKey> GetAllEntries(ISettings settings, IDictionary`2<Type, object> parentIndex, bool ignoreKeyIsDefined);
    [ExtensionAttribute]
public static void AdviseChange(ISettings settings, Action callback, Lifetime lifetime);
    [ExtensionAttribute]
public static Dictionary`2<Type, object> ParentIndex(object index);
    [ExtensionAttribute]
public static Dictionary`2<Type, object> ParentIndex(Dictionary`2<Type, object> dictionary, object index);
    [ConditionalAttribute("JET_MODE_ASSERT")]
private static void AssertIndexKey(object indexKey);
    [CompilerGeneratedAttribute]
private static TKey <GetAllEntries>b__7(Pair`2<object, object> pair);
    [CompilerGeneratedAttribute]
private static TIndex <GetAllEntries>b__8(Pair`2<object, object> pair);
    [CompilerGeneratedAttribute]
private static TKey <GetAllEntries>b__9(Pair`2<object, object> pair);
}
public class JetBrains.Common.Util.SharedTaskEventArgs : EventArgs {
    public bool IsShared;
    public ITask Task;
    public SharedTaskEventArgs(ITask task, bool isShared);
}
public interface JetBrains.Common.Util.SignatureTree.IAdvancedMethodInfoProvider {
    [CanBeNullAttribute]
public abstract virtual string GetPresentableSignature(FunctionUID fuid);
    [NotNullAttribute]
public abstract virtual string GetMethodNameWithSignature(MethodViewData methodViewData);
}
public interface JetBrains.Common.Util.SignatureTree.IAdvancedMethodInfoResolver {
    public abstract virtual TRes ExecuteWithAdvancedMethodInfoProvider(Func`3<IAdvancedMethodInfoProvider, TParam, TRes> func, TParam param);
}
public interface JetBrains.Common.Util.SignatureTree.INamespaceTreeNode {
    public INamespaceTreeNode Parent { get; }
    public IEnumerable`1<INamespaceTreeNode> Children { get; }
    public bool IsLeaf { get; }
    public string Name { get; }
    public string FullName { get; }
    public bool IsRoot { get; }
    public MethodViewData MethodViewData { get; }
    public bool IsClass { get; }
    public abstract virtual INamespaceTreeNode get_Parent();
    public abstract virtual IEnumerable`1<INamespaceTreeNode> get_Children();
    public abstract virtual bool get_IsLeaf();
    public abstract virtual string get_Name();
    public abstract virtual string get_FullName();
    public abstract virtual bool get_IsRoot();
    public abstract virtual MethodViewData get_MethodViewData();
    public abstract virtual bool get_IsClass();
}
public interface JetBrains.Common.Util.SignatureTree.ISignatureNodeFilter {
    public abstract virtual bool Accept(INamespaceTreeNode sigTreeNode, Property`1<bool> isCancelled);
    public abstract virtual bool AcceptFiltered(INamespaceTreeNode sigTreeNode, Property`1<bool> isCancelled);
}
public interface JetBrains.Common.Util.SignatureTree.ISnapshotNamespaceTree {
    public INamespaceTreeNode Root { get; }
    public UInt32 LeafCount { get; }
    public UInt32 NodeCount { get; }
    public abstract virtual INamespaceTreeNode get_Root();
    public abstract virtual UInt32 get_LeafCount();
    public abstract virtual UInt32 get_NodeCount();
    public abstract virtual INamespaceTreeNode FindMethod(FullMethodName methodName);
    public abstract virtual IEnumerable`1<Pair`2<INamespaceTreeNode, MatcherScore>> GetMatches(IdentifierMatcher matcher);
    [CanBeNullAttribute]
public abstract virtual IEnumerable`1<INamespaceTreeNode> GetNodes(string str);
}
internal class JetBrains.Common.Util.SignatureTree.NamespaceParts.ClassPart : object {
    private string myName;
    public PartType Type { get; }
    public MethodViewData MethodViewData { get; }
    public string Name { get; }
    public ClassPart(string name);
    public sealed virtual PartType get_Type();
    public sealed virtual MethodViewData get_MethodViewData();
    public sealed virtual string get_Name();
}
public class JetBrains.Common.Util.SignatureTree.NamespaceParts.FullMethodName : object {
    public INamespacePart[] Parts;
    public FullMethodName(MethodViewData methodViewData);
    public FullMethodName(string ns, string cn);
    private static IEnumerable`1<INamespacePart> ConstructFromClass(string ns, string cn);
    private static IEnumerable`1<INamespacePart> BuildParts(MethodViewData methodViewData);
    public virtual string ToString();
    public sealed virtual int CompareTo(FullMethodName other);
    private static int Compare(INamespacePart namespacePart1, INamespacePart namespacePart2);
}
public interface JetBrains.Common.Util.SignatureTree.NamespaceParts.INamespacePart {
    public PartType Type { get; }
    public MethodViewData MethodViewData { get; }
    public string Name { get; }
    public abstract virtual PartType get_Type();
    public abstract virtual MethodViewData get_MethodViewData();
    public abstract virtual string get_Name();
}
internal class JetBrains.Common.Util.SignatureTree.NamespaceParts.MethodPart : object {
    private MethodViewData myMethodViewData;
    public PartType Type { get; }
    public MethodViewData MethodViewData { get; }
    public string Name { get; }
    public MethodPart(MethodViewData methodViewData);
    public sealed virtual PartType get_Type();
    public sealed virtual MethodViewData get_MethodViewData();
    public sealed virtual string get_Name();
}
internal class JetBrains.Common.Util.SignatureTree.NamespaceParts.NamespacePart : object {
    private string myName;
    public PartType Type { get; }
    public MethodViewData MethodViewData { get; }
    public string Name { get; }
    public NamespacePart(string name);
    public sealed virtual PartType get_Type();
    public sealed virtual MethodViewData get_MethodViewData();
    public sealed virtual string get_Name();
}
internal class JetBrains.Common.Util.SignatureTree.NamespaceParts.NamespacePartEqualityComparer : object {
    public static IEqualityComparer`1<INamespacePart> Instance;
    private static NamespacePartEqualityComparer();
    public sealed virtual bool Equals(INamespacePart x, INamespacePart y);
    public sealed virtual int GetHashCode(INamespacePart obj);
}
public enum JetBrains.Common.Util.SignatureTree.NamespaceParts.PartType : Enum {
    public sbyte value__;
    public static PartType Namespace;
    public static PartType ClassName;
    public static PartType MethodName;
}
internal class JetBrains.Common.Util.SignatureTree.NamespaceTreeNode : object {
    private IList`1<NamespaceTreeNode> myChildren;
    private INamespaceTreeNode myParent;
    private INamespacePart myPart;
    public INamespaceTreeNode Parent { get; }
    public IEnumerable`1<INamespaceTreeNode> Children { get; }
    public bool IsRoot { get; }
    public bool IsLeaf { get; }
    public bool IsClass { get; }
    public string Name { get; }
    public string FullName { get; }
    public MethodViewData MethodViewData { get; }
    private NamespaceTreeNode(INamespaceTreeNode parent, INamespacePart part);
    public static NamespaceTreeNode BuildRoot(IEnumerable`1<FullMethodName> methodNameList, IExecutionController executionController);
    private NamespaceTreeNode FindOrCreateChild(INamespacePart namespacePart);
    public sealed virtual INamespaceTreeNode get_Parent();
    public sealed virtual IEnumerable`1<INamespaceTreeNode> get_Children();
    public sealed virtual bool get_IsRoot();
    public sealed virtual bool get_IsLeaf();
    public sealed virtual bool get_IsClass();
    public sealed virtual string get_Name();
    public sealed virtual string get_FullName();
    public sealed virtual MethodViewData get_MethodViewData();
}
public class JetBrains.Common.Util.SignatureTree.SignatureTreeNodeComparer : object {
    private List`1<INamespaceTreeNode> myXPathToParent;
    private List`1<INamespaceTreeNode> myYPathToParent;
    private void ClearPaths();
    public sealed virtual int Compare(INamespaceTreeNode x, INamespaceTreeNode y);
}
public class JetBrains.Common.Util.SignatureTree.SignatureTreeNodePredicate : MulticastDelegate {
    public SignatureTreeNodePredicate(object object, IntPtr method);
    public virtual bool Invoke(INamespaceTreeNode id, Property`1<bool> isCancelled);
    public virtual IAsyncResult BeginInvoke(INamespaceTreeNode id, Property`1<bool> isCancelled, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
public class JetBrains.Common.Util.SignatureTree.SnapshotNamespaceTree : object {
    private INamespaceTreeNode myRoot;
    private UInt32 myLeafCount;
    private UInt32 myNodeCount;
    public INamespaceTreeNode Root { get; }
    public UInt32 LeafCount { get; }
    public UInt32 NodeCount { get; }
    private SnapshotNamespaceTree(INamespaceTreeNode root, UInt32 leafCount, UInt32 nodeCount);
    public static SnapshotNamespaceTree BuildTree(IEnumerable`1<FullMethodName> methodNameList, IExecutionController executionController);
    private static void CalcStatistics(NamespaceTreeNode root, UInt32& leafCount, UInt32& nodeCount);
    private static void CalcStatisticsCore(INamespaceTreeNode root, UInt32& leafCount, UInt32& nodeCount);
    public sealed virtual INamespaceTreeNode get_Root();
    public sealed virtual UInt32 get_LeafCount();
    public sealed virtual UInt32 get_NodeCount();
    public sealed virtual INamespaceTreeNode FindMethod(FullMethodName methodName);
    public sealed virtual IEnumerable`1<Pair`2<INamespaceTreeNode, MatcherScore>> GetMatches(IdentifierMatcher matcher);
    public sealed virtual IEnumerable`1<INamespaceTreeNode> GetNodes(string str);
    private static IEnumerable`1<Pair`2<INamespaceTreeNode, MatcherScore>> GetMatchesCore(IdentifierMatcher matcher, INamespaceTreeNode mainRoot, bool fullMatch);
    private static Nullable`1<MatcherScore> TestNode(IdentifierMatcher matcher, string fullName);
}
public class JetBrains.Common.Util.Snapshot.Data.MeasureNode : ValueType {
    public static MeasureNode Invalid;
    public UInt32 Calls;
    public ulong OwnTime;
    public ulong TotalTime;
    public byte Flags;
    public bool IsValid { get; }
    public bool MeasurePartly { get; }
    public MeasureNode(ulong totalTime, ulong ownTime, UInt32 calls, byte flags);
    private static MeasureNode();
    public bool get_IsValid();
    public bool get_MeasurePartly();
    public static MeasureNode op_Addition(MeasureNode leftOp, MeasureNode rightOp);
    public sealed virtual bool Equals(MeasureNode other);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public static bool op_Equality(MeasureNode n1, MeasureNode n2);
    public static bool op_Inequality(MeasureNode n1, MeasureNode n2);
}
public static class JetBrains.Common.Util.Snapshot.SnapshotStorage : object {
    public static ushort GetSnapShotStorageType(FileSystemPath indexFile);
    public static UInt32 GetSnapshotType(FileSystemPath indexFile);
}
public static class JetBrains.Common.Util.Snapshot.StorageFormat : object {
    public static ushort Default;
    public static ushort MultiFile;
    public static ushort SingleFile;
    public static ushort Zipped;
    public static ushort Indexed;
    public static ushort IndexedZipped;
    public static ushort MemoryMapped;
}
public static class JetBrains.Common.Util.Snapshot.TimelineSnapshotMagics : object {
    public static UInt32 RawTimelineSnapshotMagic;
    public static UInt32 ConvertedTimelineSnapshotMagic;
    public static TimelineSnapshotType GetSnapshotType(FileSystemPath snapshotPath);
}
public enum JetBrains.Common.Util.Snapshot.TimelineSnapshotType : Enum {
    public int value__;
    public static TimelineSnapshotType Invalid;
    public static TimelineSnapshotType Raw;
    public static TimelineSnapshotType Converted;
}
public class JetBrains.Common.Util.Snapshot.UnsupportedFormatException : Exception {
    public UnsupportedFormatException(string message);
    protected UnsupportedFormatException(SerializationInfo info, StreamingContext context);
}
public static class JetBrains.Common.Util.SortedEnumerable : object {
    public static IEnumerable`1<T> Between(IReadOnlyList`1<T> sortedInputList, T fromIncluded, T toExcluded);
    public static IEnumerable`1<T> Between(IReadOnlyList`1<T> sortedInputList, T fromIncluded, T toExcluded, IComparer`1<T> comparer);
    public static IEnumerable`1<T> Except(IEnumerable`1<T> sortedInputList, IEnumerable`1<T> sortedExceptList);
    public static IEnumerable`1<T> Except(IEnumerable`1<T> sortedInputList, IEnumerable`1<T> sortedExcludeList, IComparer`1<T> comparer);
    public static IEnumerable`1<T> Merge(IEnumerable`1<IEnumerable`1<T>> sortedLists);
    public static IEnumerable`1<T> Merge(IEnumerable`1<IEnumerable`1<T>> sortedLists, IComparer`1<T> comparer);
    public static IEnumerable`1<T> Merge(IEnumerable`1<IEnumerable`1<T>> sortedLists, Func`2<T, TOrder> orderBy);
    public static IEnumerable`1<T> Merge(IEnumerable`1<IEnumerable`1<T>> sortedLists, Func`2<T, TOrder> orderBy, IComparer`1<TOrder> comparer);
    public static bool SkipSortedListToValue(List`1<TValue> list, Int32& currentIndex, TValue value, IComparer`1<TValue> comparer, bool exclude);
    public static bool SkipSortedListToValueReversed(List`1<TValue> list, Int32& currentIndex, TValue value, IComparer`1<TValue> comparer, bool exclude);
    [CompilerGeneratedAttribute]
private static IEnumerator`1<T> <Merge>b__d(IEnumerable`1<T> x);
    [CompilerGeneratedAttribute]
private static bool <Merge>b__e(IEnumerator`1<T> e);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.StreamExtensions : object {
    [ExtensionAttribute]
public static ChunkArray`1<byte> ToChunkArray(Stream stream);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.StringBuilderExtension : object {
    [ExtensionAttribute]
public static StringBuilder AppendJoin(StringBuilder builder, string separator, IEnumerable`1<string> list);
    [ExtensionAttribute]
public static StringBuilder AppendJoin(StringBuilder builder, string separator, IEnumerable`1<string> list, string before, string after);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.StringExtensions : object {
    [ExtensionAttribute]
public static string EscapeControlChars(string input);
    [ExtensionAttribute]
public static string ToLiteral(string input);
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Common.Util.StringPointer : ValueType {
    private static int BytesPerUnicodeChar;
    private int myByteCount;
    private Byte[] myBuffer;
    private int myStartIndex;
    public bool IsValid { get; }
    public int Length { get; }
    public char Item { get; }
    public StringPointer(string str);
    public StringPointer(Byte[] buffer, int startIndex, int byteCount);
    public bool get_IsValid();
    public virtual string ToString();
    public int get_Length();
    public StringPointer Prefix(int length);
    public StringPointer Substring(int start);
    public StringPointer Substring(int start, int length);
    public char get_Item(int index);
    public int IndexOf(char c);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.StructEx : object {
    [ExtensionAttribute]
public static bool IsDefault(T value);
}
public class JetBrains.Common.Util.StructWrapper`1 : object {
    public T Data;
    public StructWrapper`1(T data);
    public static StructWrapper`1<T> op_Implicit(T data);
    public static T op_Implicit(StructWrapper`1<T> wrapper);
    public static Nullable`1<T> op_Implicit(StructWrapper`1<T> wrapper);
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Common.Util.StubChunkArray`1 : object {
    private int mySize;
    private bool myIsStub;
    private ChunkArray`1<T> myArray;
    public int Count { get; }
    public T Item { get; public set; }
    public StubChunkArray`1(int size, bool isStub);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual int get_Count();
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Common.Util.SubList : object {
    private IList myList;
    private int myStart;
    private int myCount;
    private Func`2<object, object> myConverter;
    private IEnumerable`1<object> CastedItems { get; }
    public int Count { get; }
    public object SyncRoot { get; }
    public bool IsSynchronized { get; }
    public bool IsReadOnly { get; }
    public bool IsFixedSize { get; }
    public object Item { get; public set; }
    public SubList(IList list, int start, int count, Func`2<object, object> converter);
    private IEnumerator GetEnumerator();
    private IEnumerable Enumerate();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Clear();
    public sealed virtual int Add(object value);
    public sealed virtual bool Contains(object item);
    private IEnumerable`1<object> get_CastedItems();
    public sealed virtual void CopyTo(Array array, int index);
    public sealed virtual int get_Count();
    public sealed virtual object get_SyncRoot();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual int IndexOf(object item);
    public sealed virtual void Insert(int index, object item);
    public sealed virtual void Remove(object value);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual object get_Item(int index);
    public sealed virtual void set_Item(int index, object value);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.SubListEx : object {
    [ExtensionAttribute]
public static IList SubList(IList list, int index, int count, Func`2<object, object> converter);
    [ExtensionAttribute]
public static IList Convert(IList list, Func`2<object, object> converter);
    [ExtensionAttribute]
public static IList SubList(IList list, int index, Func`2<object, object> converter);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.TaskExtensions : object {
    [ExtensionAttribute]
public static void OnFinishedSynchronized(Task task, Action`1<Task> action);
    [ExtensionAttribute]
public static void OnFinishedSynchronized(Task`1<T> task, Action`1<Task`1<T>> action);
}
public class JetBrains.Common.Util.ThreadUnsafetyGuard : object {
    private int myFlag;
    private string myExceptionMessage;
    public ThreadUnsafetyGuard(string exceptionMessage);
    public IDisposable Enter();
    private sealed virtual override void System.IDisposable.Dispose();
}
[DebuggerDisplayAttribute("CollectionRange [{Start}, {Last}]")]
public class JetBrains.Common.Util.Transforms.CollectionRange : ValueType {
    public int Start;
    public int Count;
    public static CollectionRange Empty;
    public int Last { get; }
    public CollectionRange(int start, int count);
    private static CollectionRange();
    public int get_Last();
    public bool Equals(CollectionRange other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(CollectionRange r1, CollectionRange r2);
    public static bool op_Inequality(CollectionRange r1, CollectionRange r2);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.Transforms.CollectionRangeEx : object {
    [ExtensionAttribute]
public static bool Contains(CollectionRange first, CollectionRange second);
    [ExtensionAttribute]
public static bool Contains(CollectionRange range, int index);
    [ExtensionAttribute]
public static CollectionRange Intersect(CollectionRange r1, CollectionRange r2);
    [ExtensionAttribute]
public static bool IsConjugateTo(CollectionRange r1, CollectionRange r2);
    [ExtensionAttribute]
public static bool StartsBefore(CollectionRange r1, CollectionRange r2);
    [ExtensionAttribute]
public static CollectionRange TryDropEnd(CollectionRange r1, CollectionRange r2);
    private static CollectionRange FromStartLast(int start, int last);
}
public enum JetBrains.Common.Util.Transforms.LeftRightNone : Enum {
    public int value__;
    public static LeftRightNone None;
    public static LeftRightNone Left;
    public static LeftRightNone Right;
    public static LeftRightNone Both;
}
public class JetBrains.Common.Util.Transforms.ModelRange : ValueType {
    public ulong Left;
    public ulong Length;
    public static ModelRange MaxRange { get; }
    public ulong Right { get; }
    public bool IsDefault { get; }
    public ModelRange(ulong left, ulong length);
    public static ModelRange get_MaxRange();
    public ModelRange ExpandLeft(long value);
    public ModelRange ExpandRight(long value);
    public ModelRangeDouble CastToModelDouble();
    public ModelRange Union(ModelRange range);
    public Nullable`1<ModelRange> Intersect(ModelRange range);
    public bool Contains(ModelRange range);
    public bool Contains(ulong position);
    public static ModelRange FromBorders(ulong left, ulong right);
    public static ModelRange FromPoint(ulong x);
    public ulong get_Right();
    public bool get_IsDefault();
    public sealed virtual bool Equals(ModelRange other);
    public static bool op_Equality(ModelRange left, ModelRange right);
    public static bool op_Inequality(ModelRange left, ModelRange right);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class JetBrains.Common.Util.Transforms.ModelRangeDouble : ValueType {
    private double myLeft;
    private double myLength;
    public static ModelRangeDouble Max;
    private PropertyChangedEventHandler PropertyChanged;
    public double Left { get; public set; }
    public double Length { get; public set; }
    public double Right { get; public set; }
    public double Center { get; }
    public ModelRangeDouble(double left, double length);
    private static ModelRangeDouble();
    public double get_Left();
    public void set_Left(double value);
    public virtual string ToString();
    public double get_Length();
    public void set_Length(double value);
    public double get_Right();
    public void set_Right(double value);
    public static ModelRangeDouble FromBorders(double left, double right);
    public sealed virtual bool Equals(ModelRangeDouble other);
    public double get_Center();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public ModelRangeDouble SetLength(double length, double center);
    public ModelRangeDouble Expand(double factor);
    public ModelRangeDouble ExpandLength(double addLength);
    public ModelRangeDouble Union(ModelRangeDouble other);
    public ModelRangeDouble Zoom(double center, double zoomRatio);
    public ModelRangeDouble Zoom(double zoomRatio);
    public static bool op_Equality(ModelRangeDouble left, ModelRangeDouble right);
    public static bool op_Inequality(ModelRangeDouble left, ModelRangeDouble right);
    public ModelRange CastToModelInt();
    private static ulong CheckedCast(double val);
    public ModelRange CheckedCastToModelInt();
    public bool Contains(ModelRangeDouble range);
    public bool Contains(double x);
    public ModelRangeDouble IntersectWith(ModelRangeDouble range);
    public void add_PropertyChanged(PropertyChangedEventHandler value);
    public void remove_PropertyChanged(PropertyChangedEventHandler value);
}
public class JetBrains.Common.Util.Transforms.MoveResult : ValueType {
    [CompilerGeneratedAttribute]
private ScreenRange <Range>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <BordersInverted>k__BackingField;
    [CompilerGeneratedAttribute]
private LeftRightNone <ChangedBorder>k__BackingField;
    public ScreenRange Range { get; private set; }
    public bool BordersInverted { get; private set; }
    public LeftRightNone ChangedBorder { get; private set; }
    public MoveResult(ScreenRange range, bool bordersInverted, LeftRightNone changedBorder);
    [CompilerGeneratedAttribute]
public ScreenRange get_Range();
    [CompilerGeneratedAttribute]
private void set_Range(ScreenRange value);
    [CompilerGeneratedAttribute]
public bool get_BordersInverted();
    [CompilerGeneratedAttribute]
private void set_BordersInverted(bool value);
    [CompilerGeneratedAttribute]
public LeftRightNone get_ChangedBorder();
    [CompilerGeneratedAttribute]
private void set_ChangedBorder(LeftRightNone value);
}
public class JetBrains.Common.Util.Transforms.PeriodAndOffset : ValueType {
    public double Period;
    public double Offset;
    public PeriodAndOffset(double period, double offset);
}
public class JetBrains.Common.Util.Transforms.ScreenRange : ValueType {
    private double myLeft;
    private double myLength;
    public static ScreenRange Max;
    private PropertyChangedEventHandler PropertyChanged;
    public double Left { get; public set; }
    public bool IsDefault { get; }
    public double Length { get; public set; }
    public double Right { get; public set; }
    public double Center { get; }
    public ScreenRange(double left, double length);
    private static ScreenRange();
    public double get_Left();
    public void set_Left(double value);
    public virtual string ToString();
    public bool get_IsDefault();
    public double get_Length();
    public void set_Length(double value);
    public double get_Right();
    public void set_Right(double value);
    public static ScreenRange FromBorders(double left, double right);
    public sealed virtual bool Equals(ScreenRange other);
    public double get_Center();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public ScreenRange Zoom(double center, double zoomRatio);
    public ScreenRange Zoom(double zoomRatio);
    public static bool op_Equality(ScreenRange left, ScreenRange right);
    public static bool op_Inequality(ScreenRange left, ScreenRange right);
    public bool Contains(double x);
    public ScreenRange IntersectWith(ScreenRange range);
    public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.Transforms.ScreenRangeEx : object {
    [ExtensionAttribute]
public static MoveResult MoveLeftBorder(ScreenRange range, double offset);
    [ExtensionAttribute]
public static MoveResult MoveRightBorder(ScreenRange range, double offset);
    [ExtensionAttribute]
public static MoveResult MoveBothBorders(ScreenRange range, double offset);
}
public class JetBrains.Common.Util.TransientLifetime : object {
    private LifetimeDefinition myLifetimeDefinition;
    public Lifetime Instance { get; }
    public TransientLifetime(string id);
    public TransientLifetime(Lifetime parentLifetime, string id);
    public Lifetime get_Instance();
    public static Lifetime op_Implicit(TransientLifetime transientLifetime);
    public void Terminate();
    public sealed virtual void Dispose();
}
public class JetBrains.Common.Util.TreeItem`1 : object {
    [CompilerGeneratedAttribute]
private T <Item>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<TreeItem`1<T>> <Children>k__BackingField;
    public T Item { get; public set; }
    public IEnumerable`1<TreeItem`1<T>> Children { get; public set; }
    [CompilerGeneratedAttribute]
public T get_Item();
    [CompilerGeneratedAttribute]
public void set_Item(T value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<TreeItem`1<T>> get_Children();
    [CompilerGeneratedAttribute]
public void set_Children(IEnumerable`1<TreeItem`1<T>> value);
}
public class JetBrains.Common.Util.TreeStructure.ItemUpdatedEventArgs : EventArgs {
    public object Item;
    public ItemUpdatedEventArgs(object item);
}
public class JetBrains.Common.Util.TreeStructure.ItemUpdatedEventArgs`1 : EventArgs {
    public T Item;
    public ItemUpdatedEventArgs`1(T item);
}
public interface JetBrains.Common.Util.TreeStructure.ITreeListStructureProvider {
    public object Root { get; }
    public abstract virtual object get_Root();
    public abstract virtual bool HasChildren(object item);
    public abstract virtual bool GetIsExpanded(object item);
    public abstract virtual void SetIsExpanded(object item, bool isExpanded);
    public abstract virtual IEnumerable GetChildren(object item);
    public abstract virtual object FindNearestItemAfterUpdate(object oldItem);
    public abstract virtual void add_ItemUpdated(EventHandler`1<ItemUpdatedEventArgs> value);
    public abstract virtual void remove_ItemUpdated(EventHandler`1<ItemUpdatedEventArgs> value);
    public abstract virtual void add_OnScrollToItem(EventHandler`1<ItemUpdatedEventArgs> value);
    public abstract virtual void remove_OnScrollToItem(EventHandler`1<ItemUpdatedEventArgs> value);
}
public interface JetBrains.Common.Util.TreeStructure.ITreeListStructureProvider`1 {
    public T Root { get; }
    public abstract virtual T get_Root();
    public abstract virtual bool HasChildren(T item);
    public abstract virtual T GetParent(T item);
    public abstract virtual bool GetIsExpanded(T item);
    public abstract virtual void SetIsExpanded(T item, bool isExpanded);
    public abstract virtual IEnumerable`1<T> GetChildren(T item);
    public abstract virtual T FindNearestItemAfterUpdate(T oldItem);
    public abstract virtual void add_ItemUpdated(EventHandler`1<ItemUpdatedEventArgs`1<T>> value);
    public abstract virtual void remove_ItemUpdated(EventHandler`1<ItemUpdatedEventArgs`1<T>> value);
    public abstract virtual void add_OnScrollToItem(EventHandler`1<ItemUpdatedEventArgs`1<T>> value);
    public abstract virtual void remove_OnScrollToItem(EventHandler`1<ItemUpdatedEventArgs`1<T>> value);
}
public class JetBrains.Common.Util.TreeStructure.SteppedTreeListStructureProviderAdapter`1 : object {
    private ITreeListStructureProvider`1<T> mySource;
    private EventHandler`1<ItemUpdatedEventArgs`1<T>> myItemUpdated;
    private bool myShowRootExpander;
    public T Root { get; }
    public SteppedTreeListStructureProviderAdapter`1(ITreeListStructureProvider`1<T> source, bool showRootExpander);
    private void add_myItemUpdated(EventHandler`1<ItemUpdatedEventArgs`1<T>> value);
    private void remove_myItemUpdated(EventHandler`1<ItemUpdatedEventArgs`1<T>> value);
    private void OnItemUpdated(object sender, ItemUpdatedEventArgs`1<T> itemUpdatedEventArgs);
    public sealed virtual T get_Root();
    public sealed virtual bool HasChildren(T item);
    public sealed virtual T GetParent(T item);
    private bool HasSingleChild(T item);
    public sealed virtual bool GetIsExpanded(T item);
    public sealed virtual void SetIsExpanded(T item, bool isExpanded);
    public sealed virtual IEnumerable`1<T> GetChildren(T item);
    public sealed virtual T FindNearestItemAfterUpdate(T oldItem);
    public sealed virtual void add_ItemUpdated(EventHandler`1<ItemUpdatedEventArgs`1<T>> value);
    public sealed virtual void remove_ItemUpdated(EventHandler`1<ItemUpdatedEventArgs`1<T>> value);
    public sealed virtual void add_OnScrollToItem(EventHandler`1<ItemUpdatedEventArgs`1<T>> value);
    public sealed virtual void remove_OnScrollToItem(EventHandler`1<ItemUpdatedEventArgs`1<T>> value);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.TreeStructure.TreeListStructureProviderEx : object {
    [CompilerGeneratedAttribute]
private static Action`2<ITreeListStructureProvider, EventHandler`1<ItemUpdatedEventArgs>> CS$<>9__CachedAnonymousMethodDelegate3;
    [CompilerGeneratedAttribute]
private static Action`2<ITreeListStructureProvider, EventHandler`1<ItemUpdatedEventArgs>> CS$<>9__CachedAnonymousMethodDelegate4;
    [CompilerGeneratedAttribute]
private static Func`2<ItemUpdatedEventArgs, object> CS$<>9__CachedAnonymousMethodDelegate5;
    [ExtensionAttribute]
public static IDataProvider`1<PipeEventData`1<object>> ToUpdatedItemProvider(ITreeListStructureProvider tsp);
    [ExtensionAttribute]
public static ITreeListStructureProvider ToUntyped(ITreeListStructureProvider`1<T> provider);
    [CompilerGeneratedAttribute]
private static void <ToUpdatedItemProvider>b__0(ITreeListStructureProvider p, EventHandler`1<ItemUpdatedEventArgs> h);
    [CompilerGeneratedAttribute]
private static void <ToUpdatedItemProvider>b__1(ITreeListStructureProvider p, EventHandler`1<ItemUpdatedEventArgs> h);
    [CompilerGeneratedAttribute]
private static object <ToUpdatedItemProvider>b__2(ItemUpdatedEventArgs i);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.TryGetValueEx : object {
    [ExtensionAttribute]
public static TB GetValueSafe(ITryGetValue`2<TA, TB> map, TA key, TB fallback);
    [ExtensionAttribute]
public static TB GetValueSafe(ITryGetValue`2<TA, TB> map, TA key, Func`2<TA, TB> createFallbackValue);
    [ExtensionAttribute]
public static TValue GetValueSafe(IReadOnlyDictionary`2<TKey, TValue> dictionary, TKey key, TValue resultOnFail);
}
public class JetBrains.Common.Util.TVoid : object {
}
public class JetBrains.Common.Util.TwoListSynchronizer : object {
    private IList myMasterList;
    private IList myTargetList;
    public TwoListSynchronizer(IList masterList, IList targetList);
    public sealed virtual void StartSynchronizing();
    public sealed virtual void StopSynchronizing();
    public sealed virtual bool ReceiveWeakEvent(Type managerType, object sender, EventArgs e);
    private void ListenForChangeEvents(IList list);
    private void StopListeningForChangeEvents(IList list);
    private static void AddItems(IList list, NotifyCollectionChangedEventArgs e);
    private void HandleCollectionChanged(object sender, NotifyCollectionChangedEventArgs e);
    private static void MoveItems(IList list, NotifyCollectionChangedEventArgs e);
    private void PerformActionOnAllLists(Action`2<IList, NotifyCollectionChangedEventArgs> action, IList sourceList, NotifyCollectionChangedEventArgs collectionChangedArgs);
    private void PerformActionOnList(IList list, Action`2<IList, NotifyCollectionChangedEventArgs> action, NotifyCollectionChangedEventArgs collectionChangedArgs);
    private static void RemoveItems(IList list, NotifyCollectionChangedEventArgs e);
    private static void ReplaceItems(IList list, NotifyCollectionChangedEventArgs e);
    private void SetListValuesFromSource(IList sourceList, IList targetList);
    private bool TargetAndMasterCollectionsAreEqual();
    private void UpdateListsFromSource(IList sourceList);
}
public class JetBrains.Common.Util.TwoListSynchronizer`2 : object {
    private IList`1<TMaster> myMasterList;
    private Func`2<TMaster, TTarget> myMasterToTargetConverter;
    private Func`2<TTarget, TMaster> myTargetToMasterConverter;
    private IList`1<TTarget> myTargetList;
    public TwoListSynchronizer`2(IList`1<TMaster> masterList, IList`1<TTarget> targetList, Func`2<TMaster, TTarget> masterToTargetConverter, Func`2<TTarget, TMaster> targetToMasterConverter);
    public sealed virtual void StartSynchronizing();
    public sealed virtual void StopSynchronizing();
    public sealed virtual bool ReceiveWeakEvent(Type managerType, object sender, EventArgs e);
    private void ListenForChangeEvents(IEnumerable list);
    private void StopListeningForChangeEvents(IEnumerable list);
    private void AddItems(IList`1<B> list, NotifyCollectionChangedEventArgs e, Func`2<A, B> converter);
    private void HandleCollectionChanged(object sender, NotifyCollectionChangedEventArgs e);
    private void MoveItems(IList`1<B> list, NotifyCollectionChangedEventArgs e, Func`2<A, B> converter);
    private void RemoveItems(IList`1<B> list, NotifyCollectionChangedEventArgs e);
    private void ReplaceItems(IList`1<B> list, NotifyCollectionChangedEventArgs e, Func`2<A, B> converter);
    private void SetListValuesFromSource(IList`1<A> sourceList, IList`1<B> targetList, Func`2<A, B> converter);
    private bool TargetAndMasterCollectionsAreEqual();
}
public class JetBrains.Common.Util.Union.Union`2 : object {
    private TA myItem1;
    private TB myItem2;
    private int myTag;
    public Union`2(TA item);
    public Union`2(TB item);
    public T Match(Func`2<TA, T> f, Func`2<TB, T> g);
    public void Match(Action`1<TA> f, Action`1<TB> g);
}
public class JetBrains.Common.Util.Union.Union`3 : object {
    private TA myItem1;
    private TB myItem2;
    private TC myItem3;
    private int myTag;
    public Union`3(TA item);
    public Union`3(TB item);
    public Union`3(TC item);
    public T Match(Func`2<TA, T> f, Func`2<TB, T> g, Func`2<TC, T> h);
    public void Match(Action`1<TA> f, Action`1<TB> g, Action`1<TC> h);
}
public class JetBrains.Common.Util.Union.Union`4 : object {
    private TA myItem1;
    private TB myItem2;
    private TC myItem3;
    private TD myItem4;
    private int myTag;
    public Union`4(TA item);
    public Union`4(TB item);
    public Union`4(TC item);
    public Union`4(TD item);
    public T Match(Func`2<TA, T> f, Func`2<TB, T> g, Func`2<TC, T> h, Func`2<TD, T> j);
    public void Match(Action`1<TA> f, Action`1<TB> g, Action`1<TC> h, Action`1<TD> j);
}
public class JetBrains.Common.Util.Units.FormatString : object {
    private string myString;
    private Object[] myArgs;
    public FormatString(string s, Object[] args);
    public sealed virtual string ToString(string format, IFormatProvider formatProvider);
}
public class JetBrains.Common.Util.Units.FormattableInt : ValueType {
    public int Value;
    public string SingleUnit;
    public FormattableInt(int value, string singleUnit);
    public virtual string ToString();
    public sealed virtual string ToString(string format, IFormatProvider formatProvider);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.Units.FormatUtils : object {
    private static long NsPerSec;
    public static NumberFormatInfo NumberFormat;
    private static FormatUtils();
    public static string PrintNumber(double value, int minMeaningfulDigits, IFormatProvider formatProvider);
    [ExtensionAttribute]
public static UnitValue`1<TimeUnits> FormatTime(ITickTimeConverter converter, double ticks);
    [ExtensionAttribute]
public static UnitValue`1<TimeUnits> FormatToMilliseconds(ITickTimeConverter converter, double ticks);
    [ExtensionAttribute]
public static string PrintTimestamp(UnitValue`1<TimeUnits> time, TimeUnits maxUnit, int secondsPrecision);
    [ExtensionAttribute]
public static UnitValue`1<TimeUnits> FormatTime(ITickTimeConverter converter, double ticks, TimeUnits units);
    [ExtensionAttribute]
public static UnitValue`1<SizeSpeedUnits> FormatByteSpeed(ITickTimeConverter converter, double bytes, double ticks);
    public static UnitValue`1<SizeUnits> FormatByteSize(double bytes);
    public static UnitValue`1<SizeUnits> FormatToMegabytes(double bytes);
    public static UnitValue`1<SizeUnits> FormatToKilobytes(double bytes);
}
public interface JetBrains.Common.Util.Units.ITickTimeConverter {
    public double TicksPerNs { get; }
    public ulong TicksPerSecond { get; }
    public abstract virtual double ToNanoseconds(double tick);
    public abstract virtual double ToTicks(double nanoseconds);
    public abstract virtual double get_TicksPerNs();
    public abstract virtual ulong get_TicksPerSecond();
}
public class JetBrains.Common.Util.Units.PayloadPresenter : object {
    public Func`2<double, object> Print;
    public string DefaultMeasure;
    [CompilerGeneratedAttribute]
private static Func`2<double, object> CS$<>9__CachedAnonymousMethodDelegate4;
    [CompilerGeneratedAttribute]
private static Func`2<double, object> CS$<>9__CachedAnonymousMethodDelegate6;
    public PayloadPresenter(Func`2<double, object> print, string defaultMeasure);
    public static PayloadPresenter ForTime(ITickTimeConverter tickTimeConverter);
    public static PayloadPresenter ForSize();
    public static PayloadPresenter ForSizeKb();
    [CompilerGeneratedAttribute]
private static object <ForSize>b__3(double p);
    [CompilerGeneratedAttribute]
private static object <ForSizeKb>b__5(double p);
}
public class JetBrains.Common.Util.Units.Percents : ValueType {
    public bool LeftAligned;
    public double Value;
    private static string LessThanMinimum;
    private static string Minimum;
    public Percents(double value, bool leftAligned);
    private static Percents();
    public sealed virtual bool Equals(Percents other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static Percents op_Division(Percents p, double value);
    public static Percents op_Multiply(Percents p, double value);
    public virtual string ToString();
}
public class JetBrains.Common.Util.Units.Scale : object {
    private UInt64[] myPeriods;
    private double myMinPixelPerPeriod;
    public Scale(double minPixelPerPeriod, UInt64[] periods);
    public ulong GetPeriod(double unitsPerPixel);
}
public class JetBrains.Common.Util.Units.SizeSpeedUnits : UnitsBase {
    private static int ValuesNum;
    public static SizeSpeedUnits[] Values;
    private static String[] Labels;
    public static SizeSpeedUnits BytesPerSec;
    public static SizeSpeedUnits KilobytesPerSec;
    public static SizeSpeedUnits MegabytesPerSec;
    public static SizeSpeedUnits GigabytesPerSec;
    public int SizeInParent { get; }
    public int MaxValue { get; }
    public SizeSpeedUnits(int id);
    private static SizeSpeedUnits();
    public virtual string ToString();
    public virtual int get_SizeInParent();
    public virtual int get_MaxValue();
    internal virtual UnitsBase GetValue(int id);
}
public class JetBrains.Common.Util.Units.SizeUnits : UnitsBase {
    private static int ValuesNum;
    public static SizeUnits[] Values;
    private static Int32[] UnitSizes;
    private static String[] Labels;
    public static SizeUnits Byte;
    public static SizeUnits Kilobyte;
    public static SizeUnits Megabyte;
    public static SizeUnits Gigabyte;
    public int SizeInParent { get; }
    public int MaxValue { get; }
    private SizeUnits(int id);
    private static SizeUnits();
    public virtual string ToString();
    public virtual int get_SizeInParent();
    public virtual int get_MaxValue();
    internal virtual UnitsBase GetValue(int id);
}
public class JetBrains.Common.Util.Units.TickTimeConverter : object {
    private static ulong NsPerSec;
    private ulong myTicksPerSecond;
    public double TicksPerNs { get; }
    public ulong TicksPerSecond { get; }
    public TickTimeConverter(ulong ticksPerSecond);
    public sealed virtual double ToNanoseconds(double tick);
    public sealed virtual double ToTicks(double nanoseconds);
    public sealed virtual double get_TicksPerNs();
    public sealed virtual ulong get_TicksPerSecond();
}
public class JetBrains.Common.Util.Units.TimeUnits : UnitsBase {
    private static int ValuesNum;
    private static TimeUnits[] Values;
    private static Int32[] UnitSizes;
    private static String[] Labels;
    public static TimeUnits Nanosecond;
    public static TimeUnits Microsecond;
    public static TimeUnits Millisecond;
    public static TimeUnits Second;
    public static TimeUnits Minute;
    public static TimeUnits Hour;
    public int SizeInParent { get; }
    public int MaxValue { get; }
    private TimeUnits(int id);
    private static TimeUnits();
    public virtual string ToString();
    public virtual int get_SizeInParent();
    public virtual int get_MaxValue();
    internal virtual UnitsBase GetValue(int id);
}
public abstract class JetBrains.Common.Util.Units.UnitsBase : object {
    private int myID;
    protected int ID { get; }
    public int SizeInParent { get; }
    public UnitsBase MinValue { get; }
    public bool IsMin { get; }
    public bool IsMax { get; }
    public int MaxValue { get; }
    protected UnitsBase(int id);
    private bool Equals(UnitsBase other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    protected int get_ID();
    public abstract virtual int get_SizeInParent();
    public static bool op_LessThan(UnitsBase t1, UnitsBase t2);
    public static bool op_GreaterThan(UnitsBase t1, UnitsBase t2);
    public static bool op_Equality(UnitsBase t1, UnitsBase t2);
    public static bool op_Inequality(UnitsBase t1, UnitsBase t2);
    public UnitsBase get_MinValue();
    public bool get_IsMin();
    public bool get_IsMax();
    public abstract virtual int get_MaxValue();
    internal abstract virtual UnitsBase GetValue(int id);
    public static int op_Implicit(UnitsBase e);
}
public class JetBrains.Common.Util.Units.UnitScale`1 : Scale {
    [CompilerGeneratedAttribute]
private static Func`2<UnitValue`1<T>, ulong> CS$<>9__CachedAnonymousMethodDelegate1;
    public UnitScale`1(double minPixelPerPeriod, UnitValue`1[] periods);
    [CompilerGeneratedAttribute]
private static ulong <.ctor>b__0(UnitValue`1<T> p);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.Units.UnitUtils : object {
    [ExtensionAttribute]
public static T Next(T value);
    [ExtensionAttribute]
public static T Previous(T value);
    [ExtensionAttribute]
public static UnitValue`1<T> Convert(UnitValue`1<T> unitValue, int targetUnit);
    [ExtensionAttribute]
public static UnitValue`1<T> Floor(UnitValue`1<T> u);
    [ExtensionAttribute]
public static UnitValue`1<T> Convert(UnitValue`1<T> unitValue, T targetUnit);
    private static bool IsRound(UnitValue`1<T> part);
    private static double Remainder(double value, int divider);
    [ExtensionAttribute]
public static UnitValue`1<T> GetOwnPart(UnitValue`1<T> part);
    [ExtensionAttribute]
public static UnitValue`1<T> ToMinorPart(UnitValue`1<T> part);
    [ExtensionAttribute]
public static UnitValue`1<T> ToMajorPart(UnitValue`1<T> part);
    [ExtensionAttribute]
public static UnitValue`1<T> PreviousPart(UnitValue`1<T> part);
    [ExtensionAttribute]
public static UnitValue`1<T> NextPart(UnitValue`1<T> part);
}
public class JetBrains.Common.Util.Units.UnitValue`1 : ValueType {
    public double Value;
    public T Unit;
    public UnitValue`1(double value, T unit);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_LessThan(UnitValue`1<T> v1, UnitValue`1<T> v2);
    public static bool op_GreaterThan(UnitValue`1<T> v1, UnitValue`1<T> v2);
    public static UnitValue`1<T> op_Addition(UnitValue`1<T> v1, UnitValue`1<T> v2);
    public static UnitValue`1<T> op_Subtraction(UnitValue`1<T> v1, UnitValue`1<T> v2);
    public sealed virtual bool Equals(UnitValue`1<T> other);
    public virtual string ToString();
    public sealed virtual string ToString(string format, IFormatProvider formatProvider);
}
public static class JetBrains.Common.Util.ValidFilenameHelper : object {
    private static char SubstSymbol;
    private static JetHashSet`1<char> InvalidFileCharacters;
    [CompilerGeneratedAttribute]
private static Func`2<char, char> CS$<>9__CachedAnonymousMethodDelegate1;
    private static ValidFilenameHelper();
    public static string BuildValidFileName(string dirtyFileName);
    [CompilerGeneratedAttribute]
private static char <BuildValidFileName>b__0(char c);
}
public class JetBrains.Common.Util.WordMatcher : object {
    private static int P;
    private String[] myWords;
    private Char[] myBuffer;
    private JetList`1<int> myMatchingIndicies;
    public WordMatcher(string pattern);
    public IReadOnlyList`1<int> MatchingIndicies(Char[] buffer, int length);
    public IReadOnlyList`1<int> MatchingIndicies(string str);
    public bool Matches(Char[] buffer, int length);
    public bool Matches(string str);
    private bool MatchesImpl(Char[] buffer, int length);
    private void EnsureHasEnoughBufferCapacity(int length);
    private Char[] GetLowerCaseBuffer(Char[] buffer, int length);
    private Char[] GetLowerCaseBuffer(string str);
    private int IndexOf(Char[] buffer, int start, int length, string word);
    private static bool AreSame(Char[] buffer, int bufferStart, string word);
    private static int PrimePow(int factor);
    private static int GetHash(string str);
    private static int GetHash(Char[] buffer, int start, int length);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.WordMatcherEx : object {
    [ExtensionAttribute]
public static FormattedTextVM HighlightSearchText(WordMatcher matcher, string str);
    [ExtensionAttribute]
public static SelectableFormattedTextVM HighlightSearchTextSelectable(WordMatcher matcher, string str);
    private static FormattedText GetFormattedText(WordMatcher matcher, string str);
}
