public class JetBrains.Application.AssemblyReferenceClass_ComponentModel : object {
}
[ExtensionAttribute]
public static class JetBrains.Application.Bindings.AssemblyBinderExtensions : object {
    private static OnError OnErrorForAssemblyBinderErrors;
    private static OnError OnErrorForAssemblyBinderExpectedFailures;
    [CompilerGeneratedAttribute]
private static Action`1<IncompleteAttributeArgs> CS$<>9__CachedAnonymousMethodDelegate6;
    [CompilerGeneratedAttribute]
private static Action`1<UndeclaredAssemblyReferenceArgs> CS$<>9__CachedAnonymousMethodDelegate7;
    private static AssemblyBinderExtensions();
    [ExtensionAttribute]
public static IMetadataAssembly BindToMetadataAssembly(IAssemblyMasterBinder thіs, AssemblyNameInfo assembly, MetadataLoader loader, OnError onerror);
    [NotNullAttribute]
[ExtensionAttribute]
public static AssemblyItem CreateAssemblyItem(IAssemblyBinder thіs);
    [ExtensionAttribute]
[NotNullAttribute]
public static MetadataLoader CreateMetadataLoader(IAssemblyMasterBinder thіs, Lifetime lifetime);
    [ExtensionAttribute]
public static IAssemblyBinder GetBinder(IAssemblyMasterBinder thіs, AssemblyNameInfo assembly);
    [ExtensionAttribute]
public static void InstallAppDomainAssemblyResolver(IAssemblyMasterBinder masterbinder, Lifetime lifetime);
    [ExtensionAttribute]
public static void InstallAppDomainAssemblyResolverByList(AssemblyMasterBinderOnAssemblyItems masterbinder, Lifetime lifetime);
    [CompilerGeneratedAttribute]
private static void <CreateMetadataLoader>b__3(IncompleteAttributeArgs args);
    [CompilerGeneratedAttribute]
private static void <CreateMetadataLoader>b__4(UndeclaredAssemblyReferenceArgs args);
}
public class JetBrains.Application.Bindings.AssemblyMasterBinderOnAssemblyItems : object {
    [NotNullAttribute]
private static ILogger Logger;
    private static string UnresolvedAssemblyMessage;
    private FrugalLocalLazy`1<ConcurrentDictionary`2<AssemblyNameInfo, Assembly>> myCacheRuntimeAssemblies;
    private Lifetime myLifetime;
    private Dictionary`2<AssemblyNameInfo, IAssemblyItem> myMapAssemblyItems;
    [CanBeNullAttribute]
private JetHashSet`1<AssemblyNameInfo> myPossiblyMissingAssemblies;
    private static LocalLazy`1<IFolderBasedAssemblyResolver> myRuntimeAssemblyResolver;
    private IRealizedAssemblyItemUnification myUnification;
    [CompilerGeneratedAttribute]
private static Func`1<IFolderBasedAssemblyResolver> CS$<>9__CachedAnonymousMethodDelegate6;
    public JetHashSet`1<AssemblyNameInfo> AssembilesWhitelistedToBeMissing { get; }
    [NotNullAttribute]
public IDictionary`2<AssemblyNameInfo, IAssemblyItem> AssemblyItems { get; }
    [NotNullAttribute]
public IRealizedAssemblyItemUnification RealizedAssemblyItemUnification { get; }
    public AssemblyMasterBinderOnAssemblyItems(Lifetime lifetime, ICollection`1<IAssemblyItem> assemblyitems, IRealizedAssemblyItemUnification unification, IEnumerable`1<AssemblyNameInfo> possiblymissings);
    private static AssemblyMasterBinderOnAssemblyItems();
    public sealed virtual JetHashSet`1<AssemblyNameInfo> get_AssembilesWhitelistedToBeMissing();
    public IDictionary`2<AssemblyNameInfo, IAssemblyItem> get_AssemblyItems();
    public IRealizedAssemblyItemUnification get_RealizedAssemblyItemUnification();
    private sealed virtual override FileSystemPath JetBrains.Application.Bindings.IAssemblyMasterBinder.BindToDiskPath(AssemblyNameInfo assembly, OnError onerror);
    private sealed virtual override IMetadataAccess JetBrains.Application.Bindings.IAssemblyMasterBinder.BindToMetadataAccess(AssemblyNameInfo assembly, IModuleReferenceResolveContext ctx, OnError onerror);
    private sealed virtual override Assembly JetBrains.Application.Bindings.IAssemblyMasterBinder.BindToRuntimeAssembly(AssemblyNameInfo assembly, OnError onerror);
    private sealed virtual override Stream JetBrains.Application.Bindings.IAssemblyMasterBinder.BindToStream(Lifetime lifetime, AssemblyNameInfo assembly, OnError onerror);
    [CompilerGeneratedAttribute]
private static IFolderBasedAssemblyResolver <.cctor>b__5();
}
public class JetBrains.Application.Bindings.AssemblyMasterBinderOnDiskFiles : object {
    [NotNullAttribute]
private static ILogger Logger;
    private static string UnresolvedAssemblyMessage;
    private ConcurrentDictionary`2<AssemblyNameInfo, FoundPath> myMapNameToPath;
    private ConcurrentDictionary`2<FileSystemPath, FoundName> myMapPathToName;
    private Queue`1<FileSystemPath> myPathsNotReadForNames;
    [CanBeNullAttribute]
private JetHashSet`1<AssemblyNameInfo> myPossiblyMissingAssemblies;
    private static LocalLazy`1<IFolderBasedAssemblyResolver> myRuntimeAssemblyResolver;
    private IDictionary`2<AssemblyNameInfo, Assembly> myBoundToRuntimeAssemblies;
    [CompilerGeneratedAttribute]
private static Func`1<IFolderBasedAssemblyResolver> CS$<>9__CachedAnonymousMethodDelegate12;
    public JetHashSet`1<AssemblyNameInfo> AssembilesWhitelistedToBeMissing { get; }
    public AssemblyMasterBinderOnDiskFiles(Lifetime lifetime, IEnumerable`1<AssemblyNameAndLocation> items, IEnumerable`1<AssemblyNameInfo> possiblymissings);
    private static AssemblyMasterBinderOnDiskFiles();
    public sealed virtual JetHashSet`1<AssemblyNameInfo> get_AssembilesWhitelistedToBeMissing();
    public AssemblyNameInfo GetNameByPath(FileSystemPath path, OnError onerror);
    public FileSystemPath GetPathByName(AssemblyNameInfo name, OnError onerror);
    private sealed virtual override FileSystemPath JetBrains.Application.Bindings.IAssemblyMasterBinder.BindToDiskPath(AssemblyNameInfo assembly, OnError onerror);
    private sealed virtual override IMetadataAccess JetBrains.Application.Bindings.IAssemblyMasterBinder.BindToMetadataAccess(AssemblyNameInfo assembly, IModuleReferenceResolveContext ctx, OnError onerror);
    private sealed virtual override Assembly JetBrains.Application.Bindings.IAssemblyMasterBinder.BindToRuntimeAssembly(AssemblyNameInfo name, OnError onerror);
    private sealed virtual override Stream JetBrains.Application.Bindings.IAssemblyMasterBinder.BindToStream(Lifetime lifetime, AssemblyNameInfo assembly, OnError onerror);
    private FoundName GetNameByPathCore(FileSystemPath path, OnError onerror);
    private void GetPathByName_ReportError(AssemblyNameInfo name, OnError onerror, IModuleReferenceResolveContext ctx);
    private FoundPath GetPathByNameCore(AssemblyNameInfo name, OnError onerror, IModuleReferenceResolveContext ctx);
    [CompilerGeneratedAttribute]
private static IFolderBasedAssemblyResolver <.cctor>b__11();
}
public class JetBrains.Application.Bindings.AssemblyMasterBinderOnRuntimeAssemblies : object {
    private static IComparer`1<AssemblyNameAndLocation> ComparerByAssemblyName;
    [NotNullAttribute]
private static ILogger Logger;
    private IAssemblyMasterBinder myDiskFileBinder;
    public IDictionary`2<AssemblyNameInfo, Assembly> OriginalAssemblies;
    [CompilerGeneratedAttribute]
private static Func`2<AssemblyNameAndLocation, string> CS$<>9__CachedAnonymousMethodDelegate1;
    private JetHashSet`1<AssemblyNameInfo> JetBrains.Application.Bindings.IAssemblyMasterBinder.AssembilesWhitelistedToBeMissing { get; }
    public AssemblyMasterBinderOnRuntimeAssemblies(Lifetime lifetime, IEnumerable`1<Assembly> assemblies, bool isAddingReferencesTransitively);
    private static AssemblyMasterBinderOnRuntimeAssemblies();
    private sealed virtual override JetHashSet`1<AssemblyNameInfo> JetBrains.Application.Bindings.IAssemblyMasterBinder.get_AssembilesWhitelistedToBeMissing();
    private sealed virtual override FileSystemPath JetBrains.Application.Bindings.IAssemblyMasterBinder.BindToDiskPath(AssemblyNameInfo assembly, OnError onerror);
    private sealed virtual override IMetadataAccess JetBrains.Application.Bindings.IAssemblyMasterBinder.BindToMetadataAccess(AssemblyNameInfo assembly, IModuleReferenceResolveContext ctx, OnError onerror);
    private sealed virtual override Assembly JetBrains.Application.Bindings.IAssemblyMasterBinder.BindToRuntimeAssembly(AssemblyNameInfo assembly, OnError onerror);
    private sealed virtual override Stream JetBrains.Application.Bindings.IAssemblyMasterBinder.BindToStream(Lifetime lifetime, AssemblyNameInfo assembly, OnError onerror);
    [CompilerGeneratedAttribute]
private static string <.cctor>b__0(AssemblyNameAndLocation anal);
}
public interface JetBrains.Application.Bindings.AssemblyUnification.IRealizedAssemblyItemUnification {
    [NotNullAttribute]
public abstract virtual FileSystemPath RealizeAssemblyItem(Lifetime lifetime, IAssemblyItem item);
    public abstract virtual FileSystemPath RealizeAssemblyItemNew(Lifetime lifetime, IAssemblyItem item, RelativePath pathManualSubfolder);
    public abstract virtual FileSystemPath RealizeAssemblyItemNew(Lifetime lifetime, AssemblyNameInfo assemblyname, Func`1<FileSystemPath[]> λWrite);
}
public interface JetBrains.Application.Bindings.AssemblyUnification.IRealizedAssemblyItemUnificationMaster {
    public abstract virtual void MasterExportForReuseInSlave(IStructuredStorage sstg);
    public abstract virtual void MasterImportForReleaseFromSlave(IStructuredStorage sstg);
}
public interface JetBrains.Application.Bindings.AssemblyUnification.IRealizedAssemblyItemUnificationSlave {
}
public class JetBrains.Application.Bindings.AssemblyUnification.RealizedAssemblyItemData : object {
    [DesignerSerializationVisibilityAttribute("0")]
public IList`1<object> Locks;
    [CompilerGeneratedAttribute]
private AssemblyNameInfo <AssemblyName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContentHashBase64>k__BackingField;
    [CompilerGeneratedAttribute]
private FileSystemPath[] <Paths>k__BackingField;
    [NotNullAttribute]
public AssemblyNameInfo AssemblyName { get; private set; }
    public string ContentHashBase64 { get; public set; }
    public FileSystemPath DllPath { get; }
    [NotNullAttribute]
public FileSystemPath[] Paths { get; private set; }
    public RealizedAssemblyItemData(AssemblyNameInfo assname, FileSystemPath[] paths);
    [CompilerGeneratedAttribute]
public AssemblyNameInfo get_AssemblyName();
    [CompilerGeneratedAttribute]
private void set_AssemblyName(AssemblyNameInfo value);
    [CompilerGeneratedAttribute]
public string get_ContentHashBase64();
    [CompilerGeneratedAttribute]
public void set_ContentHashBase64(string value);
    public FileSystemPath get_DllPath();
    [CompilerGeneratedAttribute]
public FileSystemPath[] get_Paths();
    [CompilerGeneratedAttribute]
private void set_Paths(FileSystemPath[] value);
    public virtual string ToString();
}
public abstract class JetBrains.Application.Bindings.AssemblyUnification.RealizedAssemblyItemUnification : object {
    private static ILogger Logger;
    private static string StreamName_MasterToSlave;
    private static string StreamName_SlaveToMaster;
    private RelativePath ManualFolderName;
    private Lifetime myLifetimeCommon;
    private LockObject myLockObject;
    private IDictionary`2<AssemblyNameInfo, RealizedAssemblyItemData> myMapAssemblies;
    private Role myRole;
    private string myTokenImportedFromMaster;
    private IWorkingDirectory myWorkdir;
    private string StreamName_WorkDir;
    [CompilerGeneratedAttribute]
private static Func`2<FileSystemPath, bool> CS$<>9__CachedAnonymousMethodDelegate16;
    [CompilerGeneratedAttribute]
private static Func`2<string, FileSystemPath> CS$<>9__CachedAnonymousMethodDelegate1b;
    [CompilerGeneratedAttribute]
private static Func`2<FileSystemPath, string> CS$<>9__CachedAnonymousMethodDelegate30;
    protected RealizedAssemblyItemUnification(Lifetime lifetimeCommon, IWorkingDirectory workdir, Role role);
    private static RealizedAssemblyItemUnification();
    public void InstallAssemblyResolver(Lifetime lifetime);
    [NotNullAttribute]
public sealed virtual FileSystemPath RealizeAssemblyItem(Lifetime lifetime, IAssemblyItem item);
    public sealed virtual FileSystemPath RealizeAssemblyItemNew(Lifetime lifetime, IAssemblyItem item, RelativePath pathManualSubfolder);
    public sealed virtual FileSystemPath RealizeAssemblyItemNew(Lifetime lifetime, AssemblyNameInfo assemblyname, Func`1<FileSystemPath[]> λWrite);
    private void MasterEnsureReleaseOnShutdown();
    protected void MasterExportForReuseInSlave(IStructuredStorage sstg);
    protected void MasterImportForReleaseFromSlave(IStructuredStorage sstg);
    [NotNullAttribute]
private static IEnumerable`1<Pair`2<AssemblyNameInfo, FileSystemPath[]>> ReadSerializedLines(IStructuredStorage sstg, string sStreamName);
    [NotNullAttribute]
private RealizedAssemblyItemData RealizeCore(Lifetime lifetime, AssemblyNameInfo assemblyname, Func`1<FileSystemPath[]> λWrite);
    [NotNullAttribute]
private static FileSystemPath RealizeSingleFile(SimpleFileItem file, FileSystemPath targetdir);
    private void SerializeItemData(RealizedAssemblyItemData data, StringBuilder sb);
    protected void SlaveExportForReleaseByMaster(IStructuredStorage sstg);
    protected void SlaveImportForReuseFromMaster(Lifetime lifetime, IStructuredStorage sstg);
    private static bool UnrealizeAssemblyItem(RealizedAssemblyItemData data, FilesInUse filesinuse);
    [CompilerGeneratedAttribute]
private Assembly <InstallAssemblyResolver>b__0(object sender, ResolveEventArgs args);
    [CompilerGeneratedAttribute]
private bool <MasterEnsureReleaseOnShutdown>b__10(ReadonlyToken lck);
    [CompilerGeneratedAttribute]
private static bool <MasterImportForReleaseFromSlave>b__14(FileSystemPath path);
    [CompilerGeneratedAttribute]
private static FileSystemPath <ReadSerializedLines>b__1a(string part);
    [CompilerGeneratedAttribute]
private static string <SerializeItemData>b__2f(FileSystemPath path);
    [CompilerGeneratedAttribute]
private bool <SlaveExportForReleaseByMaster>b__32(ReadonlyToken lck);
}
[ExtensionAttribute]
public static class JetBrains.Application.Bindings.AssemblyUnification.RealizedAssemblyItemUnificationEx : object {
    private static ILogger Logger;
    [CompilerGeneratedAttribute]
private static Func`2<AssemblyItem, AssemblyNameInfo> CS$<>9__CachedAnonymousMethodDelegate7;
    [CompilerGeneratedAttribute]
private static Func`2<IGrouping`2<AssemblyNameInfo, AssemblyItem>, bool> CS$<>9__CachedAnonymousMethodDelegate8;
    [CompilerGeneratedAttribute]
private static Action`1<IGrouping`2<AssemblyNameInfo, AssemblyItem>> CS$<>9__CachedAnonymousMethodDelegate9;
    [CompilerGeneratedAttribute]
private static Func`2<IGrouping`2<AssemblyNameInfo, AssemblyItem>, AssemblyNameInfo> CS$<>9__CachedAnonymousMethodDelegatea;
    private static RealizedAssemblyItemUnificationEx();
    [ExtensionAttribute]
public static void RealizeOnAssemblyResolveDemand(IRealizedAssemblyItemUnification unification, Lifetime lifetime, ICollection`1<AssemblyItem> assemblies);
    [CompilerGeneratedAttribute]
private static AssemblyNameInfo <RealizeOnAssemblyResolveDemand>b__0(AssemblyItem ai);
    [CompilerGeneratedAttribute]
private static bool <RealizeOnAssemblyResolveDemand>b__1(IGrouping`2<AssemblyNameInfo, AssemblyItem> g);
    [CompilerGeneratedAttribute]
private static void <RealizeOnAssemblyResolveDemand>b__2(IGrouping`2<AssemblyNameInfo, AssemblyItem> g);
    [CompilerGeneratedAttribute]
private static AssemblyNameInfo <RealizeOnAssemblyResolveDemand>b__6(IGrouping`2<AssemblyNameInfo, AssemblyItem> g);
}
public class JetBrains.Application.Bindings.AssemblyUnification.RealizedAssemblyItemUnificationMaster : RealizedAssemblyItemUnification {
    public RealizedAssemblyItemUnificationMaster(Lifetime lifetimeCommon, IWorkingDirectory workdir);
    private sealed virtual override void JetBrains.Application.Bindings.AssemblyUnification.IRealizedAssemblyItemUnificationMaster.MasterExportForReuseInSlave(IStructuredStorage sstg);
    private sealed virtual override void JetBrains.Application.Bindings.AssemblyUnification.IRealizedAssemblyItemUnificationMaster.MasterImportForReleaseFromSlave(IStructuredStorage sstg);
}
public class JetBrains.Application.Bindings.AssemblyUnification.RealizedAssemblyItemUnificationSlave : RealizedAssemblyItemUnification {
    public RealizedAssemblyItemUnificationSlave(Lifetime lifetimeCommon, IStructuredStorage storageImportFromMaster, Func`2<Lifetime, IStructuredStorage> λStorageExportToMaster);
}
public interface JetBrains.Application.Bindings.IAssemblyBinder {
    [NotNullAttribute]
public AssemblyNameInfo AssemblyName { get; }
    public abstract virtual AssemblyNameInfo get_AssemblyName();
    public abstract virtual FileSystemPath BindToDiskPath(OnError onerror);
    public abstract virtual IMetadataAssembly BindToMetadataAssembly(Lifetime lifetime, OnError onerror);
    public abstract virtual Assembly BindToRuntimeAssembly(OnError onerror);
    public abstract virtual Stream BindToStream(Lifetime lifetime, OnError onerror);
}
public interface JetBrains.Application.Bindings.IAssemblyMasterBinder {
    [NotNullAttribute]
public JetHashSet`1<AssemblyNameInfo> AssembilesWhitelistedToBeMissing { get; }
    public abstract virtual JetHashSet`1<AssemblyNameInfo> get_AssembilesWhitelistedToBeMissing();
    public abstract virtual FileSystemPath BindToDiskPath(AssemblyNameInfo assembly, OnError onerror);
    public abstract virtual IMetadataAccess BindToMetadataAccess(AssemblyNameInfo assembly, IModuleReferenceResolveContext ctx, OnError onerror);
    public abstract virtual Assembly BindToRuntimeAssembly(AssemblyNameInfo assembly, OnError onerror);
    public abstract virtual Stream BindToStream(Lifetime lifetime, AssemblyNameInfo assembly, OnError onerror);
}
public class JetBrains.Application.Bindings.MetadataLoaderAssemblyResolverOnMasterBinder : object {
    [NotNullAttribute]
public IAssemblyMasterBinder MasterBinder;
    public MetadataLoaderAssemblyResolverOnMasterBinder(IAssemblyMasterBinder masterbinder);
    private sealed virtual override void JetBrains.Metadata.Reader.API.IAssemblyResolver.DumpDebugInformation(IndentedTextWriter textWriter);
    private sealed virtual override IMetadataAccess JetBrains.Metadata.Reader.API.IAssemblyResolver.ResolveAssembly(AssemblyNameInfo name, FileSystemPath& assemblyLocation, IModuleReferenceResolveContext ctx);
}
public static class JetBrains.Application.Bindings.PartCatalogAttributeBinding : object {
    public static object CreateInstance(PartCatalogAttribute attribute, OnError onerror);
    public static object CreateInstance(PartCatalogType typeAttr, Nullable`1<CollectionSource`1<PartCatalogType>> constructorFormalParameterTypes, CollectionSource`1<PartCatalogAttributeArgument> arguments, OnError onerror);
}
public static class JetBrains.Application.Bindings.PartCatalogTypeBinding : object {
    [NotNullAttribute]
public static Type BindToRuntimeType(PartCatalogType pctype);
}
public static class JetBrains.Application.Bindings.PartCatalogTypeMemberBinding : object {
    [NotNullAttribute]
public static MemberInfo BindToRuntimeMember(PartCatalogTypeMember member);
    private static MemberInfo BindToCtor(PartCatalogTypeMember member);
    private static MemberInfo BindToField(PartCatalogTypeMember member);
    private static MemberInfo BindToMethod(PartCatalogTypeMember member);
    private static MemberInfo BindToProperty(PartCatalogTypeMember member);
}
public class JetBrains.Application.Catalogs.CatalogAssemblyToken : ValueType {
}
public class JetBrains.Application.Catalogs.CatalogAttributeArgumentToken : ValueType {
}
public class JetBrains.Application.Catalogs.CatalogAttributeToken : ValueType {
}
public class JetBrains.Application.Catalogs.CatalogMemberToken : ValueType {
}
public class JetBrains.Application.Catalogs.CatalogTypeToken : ValueType {
}
public class JetBrains.Application.Catalogs.Filtering.AllPartSelector : object {
    public sealed virtual IEnumerable`1<PartCatalogType> SelectParts(IEnumerable`1<PartCatalogType> parts);
}
public class JetBrains.Application.Catalogs.Filtering.CatalogAttributeFilter : object {
    private Type myAttributeType;
    private PartCatalogTraitOperations myTraits;
    private PartCatalogTraitOperations JetBrains.Application.Catalogs.Filtering.IPartCatalogFilterRequiresTraits.Traits { get; }
    public CatalogAttributeFilter(Type attributeType);
    public sealed virtual CollectionSource`1<PartCatalogType> GetParts(CollectionSource`1<PartCatalogType> parts);
    private IEnumerable`1<PartCatalogType> GetPartsCore(CollectionSource`1<PartCatalogType> parts);
    private sealed virtual override bool JetBrains.Application.Catalogs.Filtering.IPartCatalogFilter.IsPassing(PartCatalogType part);
    private sealed virtual override PartCatalogTraitOperations JetBrains.Application.Catalogs.Filtering.IPartCatalogFilterRequiresTraits.get_Traits();
}
public class JetBrains.Application.Catalogs.Filtering.CatalogAttributeFilter`1 : CatalogAttributeFilter {
    public static CatalogAttributeFilter`1<TAttribute> Instance;
    private static CatalogAttributeFilter`1();
}
[ExtensionAttribute]
public static class JetBrains.Application.Catalogs.Filtering.CatalogAttributePartsEx : object {
    [ExtensionAttribute]
public static CollectionSource`1<PartCatalogType> GetPartsWithAttribute(PartCatalog thіs);
    [ExtensionAttribute]
public static PartCatalogAttribute GetSingleAttribute(PartCatalogType thіs, Type typeAttribute);
}
[ExtensionAttribute]
public static class JetBrains.Application.Catalogs.Filtering.CatalogIntersectFilterEx : object {
    [NotNullAttribute]
[ExtensionAttribute]
public static IPartCatalogFilter Intersect(IEnumerable`1<IPartCatalogFilter> thіs);
    [NotNullAttribute]
[ExtensionAttribute]
public static IPartCatalogFilter IntersectIfNotNull(IPartCatalogFilter thіs, IPartCatalogFilter other);
    [ExtensionAttribute]
[NotNullAttribute]
public static PartCatalogFilterGroup IntersectWith(IPartCatalogFilter thіs, IPartCatalogFilter other);
}
public interface JetBrains.Application.Catalogs.Filtering.IPartCatalogFilter {
    public abstract virtual CollectionSource`1<PartCatalogType> GetParts(CollectionSource`1<PartCatalogType> parts);
    public abstract virtual bool IsPassing(PartCatalogType part);
}
public interface JetBrains.Application.Catalogs.Filtering.IPartCatalogFilterRequiresTraits {
    public PartCatalogTraitOperations Traits { get; }
    public abstract virtual PartCatalogTraitOperations get_Traits();
}
public interface JetBrains.Application.Catalogs.Filtering.IPartSelector {
    [NotNullAttribute]
public abstract virtual IEnumerable`1<PartCatalogType> SelectParts(IEnumerable`1<PartCatalogType> parts);
}
public class JetBrains.Application.Catalogs.Filtering.LeafAndHidePartSelector : object {
    private static StringSource SsHidesName;
    private static LeafAndHidePartSelector();
    public sealed virtual IEnumerable`1<PartCatalogType> SelectParts(IEnumerable`1<PartCatalogType> parts);
}
public class JetBrains.Application.Catalogs.Filtering.LeafPartSelector : object {
    [CompilerGeneratedAttribute]
private static Func`2<KeyValuePair`2<PartCatalogType, ISet`1<PartCatalogType>>, PartCatalogType> CS$<>9__CachedAnonymousMethodDelegate7;
    public sealed virtual IEnumerable`1<PartCatalogType> SelectParts(IEnumerable`1<PartCatalogType> parts);
    [CompilerGeneratedAttribute]
private static PartCatalogType <SelectParts>b__4(KeyValuePair`2<PartCatalogType, ISet`1<PartCatalogType>> pair);
}
public class JetBrains.Application.Catalogs.Filtering.PartCatalogFilterGroup : object {
    protected ICollection`1<IPartCatalogFilter> myFilters;
    [CanBeNullAttribute]
private ICollection`1<IPartCatalogFilter> myNonTraitRequiringFilters;
    [CanBeNullAttribute]
private Nullable`1<PartCatalogTraitOperations> myRequiredTraits;
    [NotNullAttribute]
public ICollection`1<IPartCatalogFilter> AllFilters { get; }
    [NotNullAttribute]
public ICollection`1<IPartCatalogFilter> NonTraitRequiringFilters { get; }
    public PartCatalogTraitOperations RequiredTraits { get; }
    private PartCatalogFilterGroup(ICollection`1<IPartCatalogFilter> filters);
    public ICollection`1<IPartCatalogFilter> get_AllFilters();
    public ICollection`1<IPartCatalogFilter> get_NonTraitRequiringFilters();
    public PartCatalogTraitOperations get_RequiredTraits();
    [NotNullAttribute]
public static IPartCatalogFilter CreateIntersection(IEnumerable`1<IPartCatalogFilter> filters);
    [NotNullAttribute]
public static PartCatalogFilterGroup CreateIntersection(IPartCatalogFilter black, IPartCatalogFilter white);
    public sealed virtual CollectionSource`1<PartCatalogType> GetParts(CollectionSource`1<PartCatalogType> parts);
    private sealed virtual override bool JetBrains.Application.Catalogs.Filtering.IPartCatalogFilter.IsPassing(PartCatalogType part);
}
public class JetBrains.Application.Catalogs.Filtering.PartCatalogTrait : ValueType {
    public string LocalName;
    public string Namespace;
    public sealed virtual bool Equals(PartCatalogTrait other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(PartCatalogTrait left, PartCatalogTrait right);
    public static bool op_Inequality(PartCatalogTrait left, PartCatalogTrait right);
    public virtual string ToString();
}
public class JetBrains.Application.Catalogs.Filtering.PartCatalogTraitOperations : ValueType {
    public FrugalLocalList`1<Operation> Operations;
    [CompilerGeneratedAttribute]
private static Func`2<Operation, string> CS$<>9__CachedAnonymousMethodDelegate3;
    public UInt32 TotalTraitsCount { get; }
    public UInt32 get_TotalTraitsCount();
    public sealed virtual bool Equals(PartCatalogTraitOperations other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static PartCatalogTraitOperations HasAtLeast(PartCatalogTrait trait);
    public bool IsEmpty();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
private static string <ToString>b__2(Operation o);
}
public static class JetBrains.Application.Catalogs.Filtering.PartSelector : object {
    public static IPartSelector All;
    public static IPartSelector Default;
    public static IPartSelector Leafs;
    public static IPartSelector LeafsAndHides;
    private static PartSelector();
}
public interface JetBrains.Application.Catalogs.IPartCatalogSet {
    [NotNullAttribute]
public ICollectionEvents`1<PartCatalog> Catalogs { get; }
    public abstract virtual ICollectionEvents`1<PartCatalog> get_Catalogs();
}
public interface JetBrains.Application.Catalogs.IPartCatalogStorage {
    [NotNullAttribute]
public abstract virtual IPartCatalogStorage ApplyFilter(IPartCatalogFilter filter);
    [NotNullAttribute]
public abstract virtual IAssemblyBinder AssemblyGetBinder(Int32`1<CatalogAssemblyToken> token);
    public abstract virtual StringSource AssemblyGetFullName(Int32`1<CatalogAssemblyToken> token);
    public abstract virtual int AssemblyGetHashCode(Int32`1<CatalogAssemblyToken> token);
    [NotNullAttribute]
public abstract virtual AssemblyNameInfo AssemblyGetNameInfo(Int32`1<CatalogAssemblyToken> token);
    public abstract virtual CollectionSource`1<PartCatalogAttribute> AssemblyGetPartAttributes(Int32`1<CatalogAssemblyToken> token, Type typeFilter);
    public abstract virtual CollectionSource`1<PartCatalogType> AssemblyGetPartTypes(Int32`1<CatalogAssemblyToken> token);
    public abstract virtual CollectionSource`1<PartCatalogAssembly> AssemblyGetReferencedAssemblies(Int32`1<CatalogAssemblyToken> token);
    public abstract virtual StringSource AssemblyGetSimpleName(Int32`1<CatalogAssemblyToken> token);
    public abstract virtual bool AssemblyIsCataloged(Int32`1<CatalogAssemblyToken> token);
    [CanBeNullAttribute]
public abstract virtual object AttributeArgumentGetBoxedValue(Int32`1<CatalogAttributeArgumentToken> token);
    public abstract virtual PartCatalogAttributeArgumentDisposition AttributeArgumentGetDisposition(Int32`1<CatalogAttributeArgumentToken> token);
    public abstract virtual StringSource AttributeArgumentGetName(Int32`1<CatalogAttributeArgumentToken> token);
    public abstract virtual ulong AttributeArgumentGetPrimitiveValue(Int32`1<CatalogAttributeArgumentToken> token, Nullable`1<AttributeArgumentValueElementType> typeExpected);
    public abstract virtual StringSource AttributeArgumentGetStringValue(Int32`1<CatalogAttributeArgumentToken> token);
    public abstract virtual PartCatalogType AttributeArgumentGetTypeValue(Int32`1<CatalogAttributeArgumentToken> token);
    public abstract virtual AttributeArgumentValueElementType AttributeArgumentGetValueElementType(Int32`1<CatalogAttributeArgumentToken> token);
    public abstract virtual CollectionSource`1<PartCatalogAttributeArgument> AttributeGetArguments(Int32`1<CatalogAttributeToken> token);
    public abstract virtual object AttributeGetInstance(Int32`1<CatalogAttributeToken> token, OnError onerror);
    public abstract virtual PartCatalogType AttributeGetType(Int32`1<CatalogAttributeToken> token);
    public abstract virtual Nullable`1<PartCatalogAttributeArgument> AttributeTryGetArgumentByName(Int32`1<CatalogAttributeToken> token, string name);
    public abstract virtual Nullable`1<CollectionSource`1<PartCatalogType>> AttributeTryGetConstructorFormalParameterTypes(Int32`1<CatalogAttributeToken> token);
    public abstract virtual StringSource GetTypeLocalName(Int32`1<CatalogTypeToken> token);
    public abstract virtual CollectionSource`1<PartCatalogType> GlobalGetAllPartTypes();
    public abstract virtual CollectionSource`1<PartCatalogAssembly> GlobalGetCatalogedAssemblies();
    [NotNullAttribute]
public abstract virtual MemberInfo MemberBind(Int32`1<CatalogMemberToken> token);
    public abstract virtual PartCatalogType MemberGetDeclaringType(Int32`1<CatalogMemberToken> token);
    public abstract virtual int MemberGetHashCode(Int32`1<CatalogMemberToken> token);
    public abstract virtual PartCatalogTypeMemberKind MemberGetKind(Int32`1<CatalogMemberToken> token);
    public abstract virtual StringSource MemberGetName(Int32`1<CatalogMemberToken> token);
    public abstract virtual CollectionSource`1<PartCatalogType> MemberGetParameterTypes(Int32`1<CatalogMemberToken> token);
    public abstract virtual CollectionSource`1<PartCatalogAttribute> MemberGetPartAttributes(Int32`1<CatalogMemberToken> token, Type typeFilter);
    public abstract virtual PartCatalogType MemberGetValueType(Int32`1<CatalogMemberToken> token);
    [NotNullAttribute]
public abstract virtual Type TypeBind(Int32`1<CatalogTypeToken> token);
    public abstract virtual bool TypeEqualsRuntimeType(Int32`1<CatalogTypeToken> token, Type typeRuntime);
    public abstract virtual PartCatalogAssembly TypeGetAssembly(Int32`1<CatalogTypeToken> token);
    public abstract virtual StringSource TypeGetAssemblyQualifiedName(Int32`1<CatalogTypeToken> token);
    public abstract virtual CollectionSource`1<PartCatalogType> TypeGetBaseTypes(Int32`1<CatalogTypeToken> token);
    public abstract virtual CollectionSource`1<PartCatalogType> TypeGetExtraTypes(Int32`1<CatalogTypeToken> token);
    public abstract virtual StringSource TypeGetFullName(Int32`1<CatalogTypeToken> token);
    public abstract virtual int TypeGetHashCode(Int32`1<CatalogTypeToken> token);
    public abstract virtual PartCatalogTypeKind TypeGetKind(Int32`1<CatalogTypeToken> token);
    public abstract virtual CollectionSource`1<PartCatalogAttribute> TypeGetPartAttributes(Int32`1<CatalogTypeToken> token, Type typeFilter);
    public abstract virtual CollectionSource`1<PartCatalogTypeMember> TypeGetPartMembers(Int32`1<CatalogTypeToken> token);
    [CanBeNullAttribute]
public abstract virtual Type TypeTryGetBoundType(Int32`1<CatalogTypeToken> token);
}
public class JetBrains.Application.Catalogs.LegacyPartCatalogStorage : object {
    private IPartCatalogFilter myFilter;
    private IPartsCatalogue myLegacy;
    private BidirectionalMap`2<Int32`1<CatalogAttributeArgumentToken>, PartCatalogueAttributeProperty> myMapArguments;
    private BidirectionalMap`2<Int32`1<CatalogAssemblyToken>, PartCatalogueAssembly> myMapAssemblies;
    private BidirectionalMap`2<Int32`1<CatalogAttributeToken>, PartCatalogueAttribute> myMapAttributes;
    private BidirectionalMap`2<Int32`1<CatalogMemberToken>, PartCatalogueTypeMember> myMapMembers;
    private BidirectionalMap`2<Int32`1<CatalogTypeToken>, PartCatalogueType> myMapTypes;
    private int myNextToken;
    public LegacyPartCatalogStorage(IPartsCatalogue legacy, IPartCatalogFilter filter);
    private sealed virtual override IPartCatalogStorage JetBrains.Application.Catalogs.IPartCatalogStorage.ApplyFilter(IPartCatalogFilter filter);
    private sealed virtual override IAssemblyBinder JetBrains.Application.Catalogs.IPartCatalogStorage.AssemblyGetBinder(Int32`1<CatalogAssemblyToken> token);
    private sealed virtual override StringSource JetBrains.Application.Catalogs.IPartCatalogStorage.AssemblyGetFullName(Int32`1<CatalogAssemblyToken> token);
    private sealed virtual override int JetBrains.Application.Catalogs.IPartCatalogStorage.AssemblyGetHashCode(Int32`1<CatalogAssemblyToken> token);
    private sealed virtual override AssemblyNameInfo JetBrains.Application.Catalogs.IPartCatalogStorage.AssemblyGetNameInfo(Int32`1<CatalogAssemblyToken> token);
    private sealed virtual override CollectionSource`1<PartCatalogAttribute> JetBrains.Application.Catalogs.IPartCatalogStorage.AssemblyGetPartAttributes(Int32`1<CatalogAssemblyToken> token, Type typeFilter);
    private sealed virtual override CollectionSource`1<PartCatalogType> JetBrains.Application.Catalogs.IPartCatalogStorage.AssemblyGetPartTypes(Int32`1<CatalogAssemblyToken> token);
    private sealed virtual override CollectionSource`1<PartCatalogAssembly> JetBrains.Application.Catalogs.IPartCatalogStorage.AssemblyGetReferencedAssemblies(Int32`1<CatalogAssemblyToken> token);
    private sealed virtual override StringSource JetBrains.Application.Catalogs.IPartCatalogStorage.AssemblyGetSimpleName(Int32`1<CatalogAssemblyToken> token);
    private sealed virtual override bool JetBrains.Application.Catalogs.IPartCatalogStorage.AssemblyIsCataloged(Int32`1<CatalogAssemblyToken> token);
    private sealed virtual override object JetBrains.Application.Catalogs.IPartCatalogStorage.AttributeArgumentGetBoxedValue(Int32`1<CatalogAttributeArgumentToken> token);
    private sealed virtual override PartCatalogAttributeArgumentDisposition JetBrains.Application.Catalogs.IPartCatalogStorage.AttributeArgumentGetDisposition(Int32`1<CatalogAttributeArgumentToken> token);
    private sealed virtual override StringSource JetBrains.Application.Catalogs.IPartCatalogStorage.AttributeArgumentGetName(Int32`1<CatalogAttributeArgumentToken> token);
    private sealed virtual override ulong JetBrains.Application.Catalogs.IPartCatalogStorage.AttributeArgumentGetPrimitiveValue(Int32`1<CatalogAttributeArgumentToken> token, Nullable`1<AttributeArgumentValueElementType> typeExpected);
    private sealed virtual override StringSource JetBrains.Application.Catalogs.IPartCatalogStorage.AttributeArgumentGetStringValue(Int32`1<CatalogAttributeArgumentToken> token);
    private sealed virtual override PartCatalogType JetBrains.Application.Catalogs.IPartCatalogStorage.AttributeArgumentGetTypeValue(Int32`1<CatalogAttributeArgumentToken> token);
    private sealed virtual override AttributeArgumentValueElementType JetBrains.Application.Catalogs.IPartCatalogStorage.AttributeArgumentGetValueElementType(Int32`1<CatalogAttributeArgumentToken> token);
    private sealed virtual override CollectionSource`1<PartCatalogAttributeArgument> JetBrains.Application.Catalogs.IPartCatalogStorage.AttributeGetArguments(Int32`1<CatalogAttributeToken> token);
    private sealed virtual override object JetBrains.Application.Catalogs.IPartCatalogStorage.AttributeGetInstance(Int32`1<CatalogAttributeToken> token, OnError onerror);
    private sealed virtual override PartCatalogType JetBrains.Application.Catalogs.IPartCatalogStorage.AttributeGetType(Int32`1<CatalogAttributeToken> token);
    private sealed virtual override Nullable`1<PartCatalogAttributeArgument> JetBrains.Application.Catalogs.IPartCatalogStorage.AttributeTryGetArgumentByName(Int32`1<CatalogAttributeToken> token, string name);
    private sealed virtual override Nullable`1<CollectionSource`1<PartCatalogType>> JetBrains.Application.Catalogs.IPartCatalogStorage.AttributeTryGetConstructorFormalParameterTypes(Int32`1<CatalogAttributeToken> token);
    private sealed virtual override StringSource JetBrains.Application.Catalogs.IPartCatalogStorage.GetTypeLocalName(Int32`1<CatalogTypeToken> token);
    private sealed virtual override CollectionSource`1<PartCatalogType> JetBrains.Application.Catalogs.IPartCatalogStorage.GlobalGetAllPartTypes();
    private sealed virtual override CollectionSource`1<PartCatalogAssembly> JetBrains.Application.Catalogs.IPartCatalogStorage.GlobalGetCatalogedAssemblies();
    private sealed virtual override MemberInfo JetBrains.Application.Catalogs.IPartCatalogStorage.MemberBind(Int32`1<CatalogMemberToken> token);
    private sealed virtual override PartCatalogType JetBrains.Application.Catalogs.IPartCatalogStorage.MemberGetDeclaringType(Int32`1<CatalogMemberToken> token);
    private sealed virtual override int JetBrains.Application.Catalogs.IPartCatalogStorage.MemberGetHashCode(Int32`1<CatalogMemberToken> token);
    private sealed virtual override PartCatalogTypeMemberKind JetBrains.Application.Catalogs.IPartCatalogStorage.MemberGetKind(Int32`1<CatalogMemberToken> token);
    private sealed virtual override StringSource JetBrains.Application.Catalogs.IPartCatalogStorage.MemberGetName(Int32`1<CatalogMemberToken> token);
    private sealed virtual override CollectionSource`1<PartCatalogType> JetBrains.Application.Catalogs.IPartCatalogStorage.MemberGetParameterTypes(Int32`1<CatalogMemberToken> token);
    private sealed virtual override CollectionSource`1<PartCatalogAttribute> JetBrains.Application.Catalogs.IPartCatalogStorage.MemberGetPartAttributes(Int32`1<CatalogMemberToken> token, Type typeFilter);
    private sealed virtual override PartCatalogType JetBrains.Application.Catalogs.IPartCatalogStorage.MemberGetValueType(Int32`1<CatalogMemberToken> token);
    private sealed virtual override Type JetBrains.Application.Catalogs.IPartCatalogStorage.TypeBind(Int32`1<CatalogTypeToken> token);
    private sealed virtual override bool JetBrains.Application.Catalogs.IPartCatalogStorage.TypeEqualsRuntimeType(Int32`1<CatalogTypeToken> token, Type typeRuntime);
    private sealed virtual override PartCatalogAssembly JetBrains.Application.Catalogs.IPartCatalogStorage.TypeGetAssembly(Int32`1<CatalogTypeToken> token);
    private sealed virtual override StringSource JetBrains.Application.Catalogs.IPartCatalogStorage.TypeGetAssemblyQualifiedName(Int32`1<CatalogTypeToken> token);
    private sealed virtual override CollectionSource`1<PartCatalogType> JetBrains.Application.Catalogs.IPartCatalogStorage.TypeGetBaseTypes(Int32`1<CatalogTypeToken> token);
    private sealed virtual override CollectionSource`1<PartCatalogType> JetBrains.Application.Catalogs.IPartCatalogStorage.TypeGetExtraTypes(Int32`1<CatalogTypeToken> token);
    private sealed virtual override StringSource JetBrains.Application.Catalogs.IPartCatalogStorage.TypeGetFullName(Int32`1<CatalogTypeToken> token);
    private sealed virtual override int JetBrains.Application.Catalogs.IPartCatalogStorage.TypeGetHashCode(Int32`1<CatalogTypeToken> token);
    private sealed virtual override PartCatalogTypeKind JetBrains.Application.Catalogs.IPartCatalogStorage.TypeGetKind(Int32`1<CatalogTypeToken> token);
    private sealed virtual override CollectionSource`1<PartCatalogAttribute> JetBrains.Application.Catalogs.IPartCatalogStorage.TypeGetPartAttributes(Int32`1<CatalogTypeToken> token, Type typeFilter);
    private sealed virtual override CollectionSource`1<PartCatalogTypeMember> JetBrains.Application.Catalogs.IPartCatalogStorage.TypeGetPartMembers(Int32`1<CatalogTypeToken> token);
    private sealed virtual override Type JetBrains.Application.Catalogs.IPartCatalogStorage.TypeTryGetBoundType(Int32`1<CatalogTypeToken> token);
    [CanBeNullAttribute]
private object WrapArgumentValue(object value);
    private PartCatalogAssembly WrapAssembly(PartCatalogueAssembly pcass);
    private IList`1<PartCatalogAttribute> WrapAttributes(IEnumerable`1<PartCatalogueAttribute> pattrs);
    private PartCatalogType WrapType(PartCatalogueType pctype);
    [CompilerGeneratedAttribute]
private PartCatalogAttributeArgument <JetBrains.Application.Catalogs.IPartCatalogStorage.AttributeGetArguments>b__3(PartCatalogueAttributeProperty property);
    [CompilerGeneratedAttribute]
private Int32`1<CatalogAttributeArgumentToken> <JetBrains.Application.Catalogs.IPartCatalogStorage.AttributeGetArguments>b__4(PartCatalogueAttributeProperty p);
    [CompilerGeneratedAttribute]
private PartCatalogTypeMember <JetBrains.Application.Catalogs.IPartCatalogStorage.TypeGetPartMembers>b__5(PartCatalogueTypeMember pctm);
    [CompilerGeneratedAttribute]
private Int32`1<CatalogMemberToken> <JetBrains.Application.Catalogs.IPartCatalogStorage.TypeGetPartMembers>b__6(PartCatalogueTypeMember member);
    [CompilerGeneratedAttribute]
private object <WrapArgumentValue>b__7(object o);
    [CompilerGeneratedAttribute]
private Int32`1<CatalogAssemblyToken> <WrapAssembly>b__8(PartCatalogueAssembly type);
    [CompilerGeneratedAttribute]
private PartCatalogAttribute <WrapAttributes>b__9(PartCatalogueAttribute pattr);
    [CompilerGeneratedAttribute]
private Int32`1<CatalogAttributeToken> <WrapAttributes>b__a(PartCatalogueAttribute attribute);
    [CompilerGeneratedAttribute]
private Int32`1<CatalogTypeToken> <WrapType>b__b(PartCatalogueType type);
}
[ExtensionAttribute]
public static class JetBrains.Application.Catalogs.LegacyWrappedPartCatalogs : object {
    [NotNullAttribute]
public static PartCatalog Create(IList`1<PartCatalogAssembly> assemblies);
    [NotNullAttribute]
public static PartCatalog CreateFromRuntimeAssemblies(IEnumerable`1<Assembly> assemblies, IPartCatalogueFactory typeFactory, RuntimePartsPassFilter filter);
    [NotNullAttribute]
public static PartCatalog CreateFromRuntimeAssembly(Assembly assembly, IPartCatalogueFactory typeFactory, RuntimePartsPassFilter filter);
    public static PartCatalog CreateFromRuntimeTypes(IEnumerable`1<Type> types);
    public static PartCatalog CreateFromRuntimeTypes(Type[] types);
    [NotNullAttribute]
public static PartCatalog CreateWithMetadataReader(IEnumerable`1<AssemblyNameInfo> assemblies, IAssemblyMasterBinder masterbinder, IPartCatalogueFactory typeFactory, IMetadataPartsPassFilter filter);
    [NotNullAttribute]
public static PartCatalog CreateWithMetadataReaderFromAssemblyFiles(IList`1<FileSystemPath> assemblyLocations, IPartCatalogueFactory typeFactory, Func`2<Lifetime, IAssemblyResolver> FCreateAdditionalResolvers, IMetadataPartsPassFilter filter);
    [NotNullAttribute]
public static PartCatalog CreateWithMetadataReaderFromAssemblyFiles(IList`1<FileSystemPath> assemblyLocations, IList`1<FileSystemPath> filesAdditionalAssemblyReferences, IPartCatalogueFactory typeFactory, Func`2<Lifetime, IAssemblyResolver> FCreateAdditionalResolvers, IMetadataPartsPassFilter filter);
    [ExtensionAttribute]
public static PartCatalog WrapLegacy(IPartsCatalogue legacy);
    [ExtensionAttribute]
public static PartCatalogSet WrapLegacy(IPartsCatalogueSet legacy);
}
public class JetBrains.Application.Catalogs.PartCatalog : ValueType {
    private IPartCatalogStorage myStorage;
    public CollectionSource`1<PartCatalogType> AllPartTypes { get; }
    public CollectionSource`1<PartCatalogAssembly> CatalogedAssemblies { get; }
    public PartCatalog(IPartCatalogStorage storage);
    public CollectionSource`1<PartCatalogType> get_AllPartTypes();
    [PureAttribute]
public CollectionSource`1<PartCatalogAssembly> get_CatalogedAssemblies();
    [PureAttribute]
public PartCatalog ApplyFilter(IPartCatalogFilter filter);
}
public class JetBrains.Application.Catalogs.PartCatalogAssembly : ValueType {
    private IPartCatalogStorage myStorage;
    internal Int32`1<CatalogAssemblyToken> Token;
    [NotNullAttribute]
public IAssemblyBinder Binder { get; }
    public StringSource FullName { get; }
    public bool IsCataloged { get; }
    public CollectionSource`1<PartCatalogType> PartTypes { get; }
    public CollectionSource`1<PartCatalogAssembly> ReferencedAssemblies { get; }
    public StringSource SimpleName { get; }
    internal PartCatalogAssembly(Int32`1<CatalogAssemblyToken> token, IPartCatalogStorage storage);
    [PureAttribute]
public IAssemblyBinder get_Binder();
    [PureAttribute]
public StringSource get_FullName();
    [PureAttribute]
public bool get_IsCataloged();
    [PureAttribute]
public CollectionSource`1<PartCatalogType> get_PartTypes();
    [PureAttribute]
public CollectionSource`1<PartCatalogAssembly> get_ReferencedAssemblies();
    [PureAttribute]
public StringSource get_SimpleName();
    [NotNullAttribute]
[PureAttribute]
public AssemblyNameInfo CreateAssemblyName();
    [PureAttribute]
public sealed virtual bool Equals(PartCatalogAssembly other);
    [PureAttribute]
public virtual bool Equals(object obj);
    [PureAttribute]
public virtual int GetHashCode();
    [PureAttribute]
public CollectionSource`1<PartCatalogAttribute> GetPartAttributes();
    [PureAttribute]
public CollectionSource`1<PartCatalogAttribute> GetPartAttributes(Type typeAttrBase);
    [PureAttribute]
public static bool op_Equality(PartCatalogAssembly left, PartCatalogAssembly right);
    [PureAttribute]
public static bool op_Inequality(PartCatalogAssembly left, PartCatalogAssembly right);
    [PureAttribute]
public virtual string ToString();
    [PureAttribute]
private sealed virtual override int System.IComparable<JetBrains.Application.Catalogs.PartCatalogAssembly>.CompareTo(PartCatalogAssembly other);
}
[ExtensionAttribute]
public static class JetBrains.Application.Catalogs.PartCatalogAssemblyEx : object {
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static Assembly Bind(PartCatalogAssembly thіs);
    [PureAttribute]
[ExtensionAttribute]
public static CollectionSource`1<PartCatalogAttribute> GetPartAttributes(PartCatalogAssembly thіs);
}
public class JetBrains.Application.Catalogs.PartCatalogAttribute : ValueType {
    internal IPartCatalogStorage myStorage;
    internal Int32`1<CatalogAttributeToken> Token;
    public PartCatalogAttributeArguments Arguments { get; }
    public PartCatalogAttributeArgumentsNullable ArgumentsOptional { get; }
    public bool IsConstructorKnown { get; }
    public PartCatalogType Type { get; }
    public PartCatalogAttribute(Int32`1<CatalogAttributeToken> token, IPartCatalogStorage storage);
    [PureAttribute]
public PartCatalogAttributeArguments get_Arguments();
    [PureAttribute]
public PartCatalogAttributeArgumentsNullable get_ArgumentsOptional();
    [PureAttribute]
public bool get_IsConstructorKnown();
    [PureAttribute]
public PartCatalogType get_Type();
    [PureAttribute]
public CollectionSource`1<PartCatalogAttributeArgument> GetArguments();
    [PureAttribute]
public CollectionSource`1<PartCatalogType> GetConstructorFormalParameterTypes();
    [PureAttribute]
public object GetInstance(OnError onerror);
    public virtual string ToString();
    [PureAttribute]
public Nullable`1<PartCatalogAttributeArgument> TryFindArgument(string name);
}
public class JetBrains.Application.Catalogs.PartCatalogAttributeArgument : ValueType {
    private IPartCatalogStorage myStorage;
    internal Int32`1<CatalogAttributeArgumentToken> Token;
    public PartCatalogAttributeArgumentDisposition Disposition { get; }
    public StringSource Name { get; }
    public PartCatalogAttributeArgument(Int32`1<CatalogAttributeArgumentToken> token, IPartCatalogStorage storage);
    [PureAttribute]
public PartCatalogAttributeArgumentDisposition get_Disposition();
    public StringSource get_Name();
    [NotNullAttribute]
[PureAttribute]
public Object[] GetArrayValue();
    [PureAttribute]
public bool GetBooleanValue();
    [CanBeNullAttribute]
[PureAttribute]
public object GetBoxedValue();
    [PureAttribute]
public byte GetByteValue();
    [PureAttribute]
public char GetCharValue();
    [PureAttribute]
public double GetDoubleValue();
    [PureAttribute]
public short GetInt16Value();
    [PureAttribute]
public int GetInt32Value();
    [PureAttribute]
public long GetInt64Value();
    [PureAttribute]
public bool GetIsNullValue();
    [PureAttribute]
public ulong GetRawPrimitiveValue();
    [PureAttribute]
public sbyte GetSByteValue();
    [PureAttribute]
public float GetSingleValue();
    [PureAttribute]
public StringSource GetStringValue();
    [PureAttribute]
public PartCatalogType GetTypeValue();
    [PureAttribute]
public ushort GetUInt16Value();
    [PureAttribute]
public UInt32 GetUInt32Value();
    [PureAttribute]
public ulong GetUInt64Value();
    [PureAttribute]
public AttributeArgumentValueElementType GetValueElementType();
    [PureAttribute]
public virtual string ToString();
}
public class JetBrains.Application.Catalogs.PartCatalogAttributeArgumentDisposition : ValueType {
    private static int FieldValue;
    public static PartCatalogAttributeArgumentDisposition Field;
    private static int PropertyValue;
    public static PartCatalogAttributeArgumentDisposition Property;
    private int myValue;
    public int CtorParameterIndex { get; }
    public bool IsCtorParameter { get; }
    public bool IsField { get; }
    public bool IsProperty { get; }
    private PartCatalogAttributeArgumentDisposition(int value);
    private static PartCatalogAttributeArgumentDisposition();
    public int get_CtorParameterIndex();
    public bool get_IsCtorParameter();
    public bool get_IsField();
    public bool get_IsProperty();
    public static PartCatalogAttributeArgumentDisposition CtorParameter(int index);
    public static int op_Explicit(PartCatalogAttributeArgumentDisposition disposition);
    public static PartCatalogAttributeArgumentDisposition op_Explicit(int value);
}
[ExtensionAttribute]
public static class JetBrains.Application.Catalogs.PartCatalogAttributeArgumentEx : object {
    private static Type TypeOfNullableOfPartCatalogType;
    private static Type TypeOfNullableOfStringSource;
    private static Type TypeOfObjectArray;
    private static Type TypeOfPartCatalogType;
    private static Type TypeOfStringSource;
    private static PartCatalogAttributeArgumentEx();
    [PureAttribute]
[ExtensionAttribute]
[CanBeNullAttribute]
public static Object[] GetArrayValueOrNull(PartCatalogAttributeArgument thіs);
    [PureAttribute]
[ExtensionAttribute]
public static Nullable`1<StringSource> GetStringValueOrNull(PartCatalogAttributeArgument thіs);
    [ExtensionAttribute]
[PureAttribute]
public static Nullable`1<PartCatalogType> GetTypeValueOrNull(PartCatalogAttributeArgument thіs);
    [PureAttribute]
[ExtensionAttribute]
public static TValue GetValue(PartCatalogAttributeArgument argument);
}
public static class JetBrains.Application.Catalogs.PartCatalogAttributeArgumentHelpers : object {
    public static AttributeArgumentValueElementType GetElementTypeFromBoxedValue(object oValue);
    public static bool IsPrimitiveTypeCoercible(AttributeArgumentValueElementType typeActual, Nullable`1<AttributeArgumentValueElementType> typeCoerceTo, OnError onerror);
    public static Nullable`1<AttributeArgumentValueElementType> TryGetElementTypeFromTypeCode(TypeCode tc, bool isPrimitiveTypesOnly);
}
[ExtensionAttribute]
public static class JetBrains.Application.Catalogs.PartCatalogAttributeArgumentNullableEx : object {
    [CanBeNullAttribute]
[PureAttribute]
[ExtensionAttribute]
public static Object[] GetArrayValueIfDefined(Nullable`1<PartCatalogAttributeArgument> thіs);
    [PureAttribute]
[ExtensionAttribute]
public static Nullable`1<bool> GetBooleanValueIfDefined(Nullable`1<PartCatalogAttributeArgument> thіs);
    [CanBeNullAttribute]
[PureAttribute]
[ExtensionAttribute]
public static object GetBoxedValueIfDefined(Nullable`1<PartCatalogAttributeArgument> thіs);
    [PureAttribute]
[ExtensionAttribute]
public static Nullable`1<byte> GetByteValueIfDefined(Nullable`1<PartCatalogAttributeArgument> thіs);
    [ExtensionAttribute]
[PureAttribute]
public static Nullable`1<char> GetCharValueIfDefined(Nullable`1<PartCatalogAttributeArgument> thіs);
    [ExtensionAttribute]
[PureAttribute]
public static Nullable`1<double> GetDoubleValueIfDefined(Nullable`1<PartCatalogAttributeArgument> thіs);
    [ExtensionAttribute]
[PureAttribute]
public static Nullable`1<short> GetInt16ValueIfDefined(Nullable`1<PartCatalogAttributeArgument> thіs);
    [PureAttribute]
[ExtensionAttribute]
public static Nullable`1<int> GetInt32ValueIfDefined(Nullable`1<PartCatalogAttributeArgument> thіs);
    [ExtensionAttribute]
[PureAttribute]
public static Nullable`1<long> GetInt64ValueIfDefined(Nullable`1<PartCatalogAttributeArgument> thіs);
    [ExtensionAttribute]
[PureAttribute]
public static Nullable`1<bool> GetIsNullValueIfDefined(Nullable`1<PartCatalogAttributeArgument> thіs);
    [ExtensionAttribute]
[PureAttribute]
public static Nullable`1<ulong> GetRawPrimitiveValueIfDefined(Nullable`1<PartCatalogAttributeArgument> thіs);
    [PureAttribute]
[ExtensionAttribute]
public static Nullable`1<sbyte> GetSByteValueIfDefined(Nullable`1<PartCatalogAttributeArgument> thіs);
    [PureAttribute]
[ExtensionAttribute]
public static Nullable`1<float> GetSingleValueIfDefined(Nullable`1<PartCatalogAttributeArgument> thіs);
    [PureAttribute]
[ExtensionAttribute]
public static Nullable`1<StringSource> GetStringValueIfDefined(Nullable`1<PartCatalogAttributeArgument> thіs);
    [PureAttribute]
[ExtensionAttribute]
public static Nullable`1<PartCatalogType> GetTypeValueIfDefined(Nullable`1<PartCatalogAttributeArgument> thіs);
    [ExtensionAttribute]
[PureAttribute]
public static Nullable`1<ushort> GetUInt16ValueIfDefined(Nullable`1<PartCatalogAttributeArgument> thіs);
    [PureAttribute]
[ExtensionAttribute]
public static Nullable`1<UInt32> GetUInt32ValueIfDefined(Nullable`1<PartCatalogAttributeArgument> thіs);
    [ExtensionAttribute]
[PureAttribute]
public static Nullable`1<ulong> GetUInt64ValueIfDefined(Nullable`1<PartCatalogAttributeArgument> thіs);
    [PureAttribute]
[ExtensionAttribute]
public static Nullable`1<AttributeArgumentValueElementType> GetValueElementTypeIfDefined(Nullable`1<PartCatalogAttributeArgument> thіs);
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Application.Catalogs.PartCatalogAttributeArguments : ValueType {
    internal PartCatalogAttribute myParent;
    public CollectionSource`1<PartCatalogAttributeArgument> All { get; }
    public PartCatalogAttributeArgument Item { get; }
    public PartCatalogAttribute Parent { get; }
    [PureAttribute]
public CollectionSource`1<PartCatalogAttributeArgument> get_All();
    [PureAttribute]
public PartCatalogAttributeArgument get_Item(string name);
    [PureAttribute]
public PartCatalogAttribute get_Parent();
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Application.Catalogs.PartCatalogAttributeArgumentsNullable : ValueType {
    internal PartCatalogAttribute myParent;
    public CollectionSource`1<PartCatalogAttributeArgument> All { get; }
    public Nullable`1<PartCatalogAttributeArgument> Item { get; }
    public PartCatalogAttribute Parent { get; }
    [PureAttribute]
public CollectionSource`1<PartCatalogAttributeArgument> get_All();
    [PureAttribute]
public Nullable`1<PartCatalogAttributeArgument> get_Item(string name);
    [PureAttribute]
public PartCatalogAttribute get_Parent();
}
[ExtensionAttribute]
public static class JetBrains.Application.Catalogs.PartCatalogAttributeEx : object {
    [PureAttribute]
[ExtensionAttribute]
public static PartCatalogAttributeArgument Find(PartCatalogAttributeArguments thіs, Expression`1<Func`2<TAttribute, TArgument>> expression);
    [ExtensionAttribute]
[PureAttribute]
public static PartCatalogAttributeArgument Find(PartCatalogAttributeArguments thіs, AttributeArgumentValueElementType type);
    [PureAttribute]
[ExtensionAttribute]
public static PartCatalogAttributeArgument FindArgument(PartCatalogAttribute thіs, string name);
    [ExtensionAttribute]
[PureAttribute]
public static PartCatalogAttributeArgument FindArgument(PartCatalogAttribute thіs, Expression`1<Func`2<TAttribute, TArgument>> expression);
    [ExtensionAttribute]
[ObsoleteAttribute("This method either boxes some primitive values, or uses nontrivial hacks to avoid that boxing. So the recommended way is to get the argument with Arguments[] or ArgumentsOptional[], and then take its value of a specific type (enum types must be cast manually due to boxing issues). Also this would have better handling and understanding for missing values.")]
public static TValue GetArgumentValueOrDefault(PartCatalogAttribute thіs, string argumentname, TValue default);
    [ExtensionAttribute]
[CanBeNullAttribute]
[ObsoleteAttribute("This method either boxes some primitive values, or uses nontrivial hacks to avoid that boxing. So the recommended way is to get the argument with Arguments[] or ArgumentsOptional[], and then take its value of a specific type (enum types must be cast manually due to boxing issues). Also this would have better handling and understanding for missing values.")]
public static TValue TryGetArgumentValue(PartCatalogAttribute thіs, string argumentname);
    [ExtensionAttribute]
[ObsoleteAttribute("This method either boxes some primitive values, or uses nontrivial hacks to avoid that boxing. So the recommended way is to get the argument with Arguments[] or ArgumentsOptional[], and then take its value of a specific type (enum types must be cast manually due to boxing issues). Also this would have better handling and understanding for missing values.")]
public static bool TryGetArgumentValue(PartCatalogAttribute thіs, string argumentname, TValue& value);
}
[ObsoleteAttribute("These methods box all values, get the argument then get its value of the specific type.")]
[ExtensionAttribute]
public static class JetBrains.Application.Catalogs.PartCatalogAttributeEx_Obsolete : object {
    [ObsoleteAttribute("This method boxes all values, get the argument then get its value of the specific type.")]
[ExtensionAttribute]
public static TConvertedValue GetProperty(PartCatalogAttribute thіs, Expression`1<Func`2<TSource, TValue>> expression);
    [ObsoleteAttribute("This method boxes all values, get the argument then get its value of the specific type.")]
[ExtensionAttribute]
public static TValue GetProperty(PartCatalogAttribute thіs, Expression`1<Func`2<TSource, TValue>> expression);
    [ObsoleteAttribute("This method boxes all values, get the argument then get its value of the specific type.")]
[ExtensionAttribute]
public static T GetProperty(PartCatalogAttribute thіs, string propname);
    [ObsoleteAttribute("This method boxes all values, get the argument then get its value of the specific type.")]
[ExtensionAttribute]
public static T TryGetProperty(PartCatalogAttribute thіs, string propname, T defaultValue);
    [ExtensionAttribute]
[CanBeNullAttribute]
[ObsoleteAttribute("This method boxes all values, get the argument then get its value of the specific type.")]
public static TValue TryGetProperty(PartCatalogAttribute thіs, string propname);
    [ExtensionAttribute]
[ObsoleteAttribute("This method boxes all values, get the argument then get its value of the specific type.")]
public static TValue TryGetProperty(PartCatalogAttribute thіs, Expression`1<Func`2<TSource, TValue>> expression, TValue defaultValue);
    [ObsoleteAttribute("This method boxes all values, get the argument then get its value of the specific type.")]
[ExtensionAttribute]
public static TValue TryGetProperty(PartCatalogAttribute thіs, Expression`1<Func`2<TSource, TValue>> expression);
    [ExtensionAttribute]
[ObsoleteAttribute("This method boxes all values, get the argument then get its value of the specific type.")]
public static TConvertedValue TryGetProperty(PartCatalogAttribute thіs, Expression`1<Func`2<TSource, TValue>> expression, TConvertedValue defaultValue);
    [ExtensionAttribute]
[ObsoleteAttribute("This method boxes all values, get the argument then get its value of the specific type.")]
public static bool TryGetProperty(PartCatalogAttribute thіs, string propname, T& value);
}
[ExtensionAttribute]
public static class JetBrains.Application.Catalogs.PartCatalogEx : object {
    [EditorBrowsableAttribute("1")]
[ExtensionAttribute]
public static void DiagnosticsDumpCatalogToExcel(PartCatalog thіs);
    [ExtensionAttribute]
[ObsoleteAttribute("Use PartCatalog::AllPartTypes.")]
public static CollectionSource`1<PartCatalogType> GetTypesFromAllAssemblies(PartCatalog thіs);
}
public class JetBrains.Application.Catalogs.PartCatalogSet : object {
    private CollectionEvents`1<PartCatalog> myCatalogs;
    public ICollectionEvents`1<PartCatalog> Catalogs { get; }
    public PartCatalogSet(IEnumerable`1<PartCatalog> initial);
    public PartCatalogSet(PartCatalog initial);
    public sealed virtual ICollectionEvents`1<PartCatalog> get_Catalogs();
}
public static class JetBrains.Application.Catalogs.PartCatalogStorageHelpers : object {
    public static int TypeGetHashCode(PartCatalogTypeKind typekind, StringSource fullname, StringSource assemblyname);
}
public class JetBrains.Application.Catalogs.PartCatalogType : ValueType {
    internal IPartCatalogStorage myStorage;
    internal Int32`1<CatalogTypeToken> Token;
    public PartCatalogAssembly Assembly { get; }
    public StringSource AssemblyQualifiedName { get; }
    public CollectionSource`1<PartCatalogType> BaseTypes { get; }
    public CollectionSource`1<PartCatalogType> ExtraTypes { get; }
    public StringSource FullName { get; }
    public bool IsArray { get; }
    public bool IsGenericTypeDeclaraion { get; }
    public bool IsGenericTypeSpecialization { get; }
    public bool IsReference { get; }
    public PartCatalogTypeKind Kind { get; }
    public StringSource LocalName { get; }
    public CollectionSource`1<PartCatalogTypeMember> PartMembers { get; }
    internal PartCatalogType(Int32`1<CatalogTypeToken> token, IPartCatalogStorage storage);
    [PureAttribute]
public PartCatalogAssembly get_Assembly();
    [PureAttribute]
public StringSource get_AssemblyQualifiedName();
    [PureAttribute]
public CollectionSource`1<PartCatalogType> get_BaseTypes();
    [PureAttribute]
public CollectionSource`1<PartCatalogType> get_ExtraTypes();
    [PureAttribute]
public StringSource get_FullName();
    [PureAttribute]
public bool get_IsArray();
    [PureAttribute]
public bool get_IsGenericTypeDeclaraion();
    [PureAttribute]
public bool get_IsGenericTypeSpecialization();
    [PureAttribute]
public bool get_IsReference();
    [PureAttribute]
public PartCatalogTypeKind get_Kind();
    [PureAttribute]
public StringSource get_LocalName();
    [PureAttribute]
public CollectionSource`1<PartCatalogTypeMember> get_PartMembers();
    [PureAttribute]
[NotNullAttribute]
public Type Bind();
    [PureAttribute]
public sealed virtual bool Equals(PartCatalogType other);
    [PureAttribute]
public bool Equals();
    [PureAttribute]
public bool Equals(Type typeRuntime);
    [PureAttribute]
public virtual bool Equals(object obj);
    [PureAttribute]
public PartCatalogType GenericTypeParameterOwner();
    [PureAttribute]
public PartCatalogType GetArrayItemType();
    [PureAttribute]
public CollectionSource`1<PartCatalogType> GetGenericActualParameters();
    [PureAttribute]
public StringSource GetGenericTypeDeclarationFullName();
    [PureAttribute]
public virtual int GetHashCode();
    [PureAttribute]
public CollectionSource`1<PartCatalogAttribute> GetPartAttributes();
    [PureAttribute]
public CollectionSource`1<PartCatalogAttribute> GetPartAttributes(Type typeAttrBase);
    [PureAttribute]
public PartCatalogType GetReferenceTargetType();
    [PureAttribute]
public static bool op_Equality(PartCatalogType left, PartCatalogType right);
    [PureAttribute]
public static bool op_Inequality(PartCatalogType left, PartCatalogType right);
    public virtual string ToString();
    [CanBeNullAttribute]
[PureAttribute]
public Type TryGetBoundType();
    private sealed virtual override int System.IComparable<JetBrains.Application.Catalogs.PartCatalogType>.CompareTo(PartCatalogType other);
}
[ExtensionAttribute]
public static class JetBrains.Application.Catalogs.PartCatalogTypeEx : object {
    [ExtensionAttribute]
public static CollectionSource`1<PartCatalogAttribute> GetPartAttributes(PartCatalogType thіs);
    [ExtensionAttribute]
public static bool IsEnum(PartCatalogType type);
}
public class JetBrains.Application.Catalogs.PartCatalogTypeIdentityComparer : object {
    public static IEqualityComparer`1<PartCatalogType> Instance;
    private static PartCatalogTypeIdentityComparer();
    private sealed virtual override bool System.Collections.Generic.IEqualityComparer<JetBrains.Application.Catalogs.PartCatalogType>.Equals(PartCatalogType black, PartCatalogType white);
    private sealed virtual override int System.Collections.Generic.IEqualityComparer<JetBrains.Application.Catalogs.PartCatalogType>.GetHashCode(PartCatalogType item);
}
public enum JetBrains.Application.Catalogs.PartCatalogTypeKind : Enum {
    public byte value__;
    public static PartCatalogTypeKind Regular;
    public static PartCatalogTypeKind GenericDeclaration;
    public static PartCatalogTypeKind GenericSpecialization;
    public static PartCatalogTypeKind Array;
    public static PartCatalogTypeKind Reference;
    public static PartCatalogTypeKind GenericTypeParameterReference;
    public static PartCatalogTypeKind GenericMethodParameterReference;
}
public class JetBrains.Application.Catalogs.PartCatalogTypeMember : ValueType {
    private IPartCatalogStorage myStorage;
    internal Int32`1<CatalogMemberToken> Token;
    public PartCatalogType DeclaringType { get; }
    public StringSource FullName { get; }
    public PartCatalogTypeMemberKind Kind { get; }
    public StringSource Name { get; }
    public CollectionSource`1<PartCatalogType> ParameterTypes { get; }
    public PartCatalogType ValueType { get; }
    public PartCatalogTypeMember(Int32`1<CatalogMemberToken> token, IPartCatalogStorage storage);
    [PureAttribute]
public PartCatalogType get_DeclaringType();
    [PureAttribute]
public StringSource get_FullName();
    [PureAttribute]
public PartCatalogTypeMemberKind get_Kind();
    [PureAttribute]
public StringSource get_Name();
    [PureAttribute]
public CollectionSource`1<PartCatalogType> get_ParameterTypes();
    [PureAttribute]
public PartCatalogType get_ValueType();
    [PureAttribute]
[NotNullAttribute]
public MemberInfo Bind();
    public sealed virtual bool Equals(PartCatalogTypeMember other);
    public virtual bool Equals(object obj);
    [PureAttribute]
public virtual int GetHashCode();
    [PureAttribute]
public CollectionSource`1<PartCatalogAttribute> GetPartAttributes();
    [PureAttribute]
public CollectionSource`1<PartCatalogAttribute> GetPartAttributes(Type typeAttrBase);
    [PureAttribute]
public static bool op_Equality(PartCatalogTypeMember left, PartCatalogTypeMember right);
    [PureAttribute]
public static bool op_Inequality(PartCatalogTypeMember left, PartCatalogTypeMember right);
    public virtual string ToString();
    private sealed virtual override int System.IComparable<JetBrains.Application.Catalogs.PartCatalogTypeMember>.CompareTo(PartCatalogTypeMember other);
}
[ExtensionAttribute]
public static class JetBrains.Application.Catalogs.PartCatalogTypeMemberEx : object {
    [ExtensionAttribute]
public static CollectionSource`1<PartCatalogAttribute> GetPartAttributes(PartCatalogTypeMember thіs);
}
public enum JetBrains.Application.Catalogs.PartCatalogTypeMemberKind : Enum {
    public byte value__;
    public static PartCatalogTypeMemberKind Method;
    public static PartCatalogTypeMemberKind Property;
    public static PartCatalogTypeMemberKind Field;
    public static PartCatalogTypeMemberKind Constructor;
}
internal enum JetBrains.Application.Components.ComponentAccessCardinality : Enum {
    public int value__;
    public static ComponentAccessCardinality Unaccessed;
    public static ComponentAccessCardinality Single;
    public static ComponentAccessCardinality Multiple;
}
public class JetBrains.Application.Components.ComponentContainer : object {
    private Lifetime myLifetime;
    private string myId;
    private IValueResolveContext myUnknownContext;
    private ComponentStorage myComponentStorage;
    private List`1<KeyValuePair`2<int, IValueResolver>> myLinkedResolvers;
    private List`1<KeyValuePair`2<int, IValueResolver>> myExtraResolvers;
    private EnumerableValueResolver myEnumerableResolver;
    private ViewableValueResolver myViewableResolver;
    private static int myRegisteredResolverPriority;
    private static Func`2<KeyValuePair`2<int, IValueResolver>, int> myGetKeyOfPair;
    [CompilerGeneratedAttribute]
private static Func`2<KeyValuePair`2<int, IValueResolver>, int> CS$<>9__CachedAnonymousMethodDelegate7;
    private IValueResolveContext UnknownContext { get; }
    public ComponentContainer(Lifetime lifetime, string id, IInitializationStrategy initializationStrategy, IComponentAccessPolicy accesspolicy);
    private static ComponentContainer();
    public sealed virtual IValueResolveContext CreateResolveContext(IValueDescriptor requestingDescriptor);
    private IValueResolveContext get_UnknownContext();
    public ComponentContainer Compose();
    public ComponentContainer RegisterResolver(IValueResolver resolver);
    public ComponentContainer RegisterSource(IViewable`1<IEnumerable`1<IComponentDescriptor>> componentSource);
    public ComponentContainer RegisterDescriptors(IList`1<IComponentDescriptor> descriptors);
    public ComponentContainer RegisterDescriptors(Lifetime lifetime, IList`1<IComponentDescriptor> descriptors);
    public IValueDescriptor Resolve(TRequest request, IValueResolveContext context);
    private static IValueDescriptor ResolveFirstOrDefault(List`1<KeyValuePair`2<int, IValueResolver>> resolvers, TRequest request, IValueResolveContext context);
    public virtual string ToString();
    private sealed virtual override IMemoryGrave JetBrains.Util.Memory.IMemoryGraveProvider.GetOrCreateMemoryGrave();
    [CompilerGeneratedAttribute]
private void <.ctor>b__0();
    [CompilerGeneratedAttribute]
private void <RegisterSource>b__2(Lifetime lifetime, IEnumerable`1<IComponentDescriptor> descriptors);
    [CompilerGeneratedAttribute]
private static int <.cctor>b__6(KeyValuePair`2<int, IValueResolver> pair);
}
[ExtensionAttribute]
public static class JetBrains.Application.Components.ComponentContainerEx : object {
    [ExtensionAttribute]
[NotNullAttribute]
public static IViewable`1<TInterface> GetViewable(IComponentContainer container);
    [NotNullAttribute]
[ExtensionAttribute]
public static IEnumerable`1<TInterface> GetComponents(IComponentContainer container);
    [NotNullAttribute]
[ExtensionAttribute]
public static TInterface GetComponent(IComponentContainer container);
    [CanBeNullAttribute]
[ExtensionAttribute]
public static TInterface TryGetComponent(IComponentContainer container);
    [ExtensionAttribute]
public static bool HasComponent(IComponentContainer container);
    [ExtensionAttribute]
public static ComponentContainer Register(ComponentContainer container, Type type);
    [ExtensionAttribute]
public static ComponentContainer Register(ComponentContainer container, object instance);
    [ExtensionAttribute]
public static IComponentContainer Register(ComponentContainer container, Func`2<IValueResolveContext, T> factory);
    [ExtensionAttribute]
public static ComponentContainer Register(ComponentContainer container);
    [ExtensionAttribute]
public static IComponentContainer Register(ComponentContainer container, Lifetime lifetime);
    [CompilerGeneratedAttribute]
private static object <GetComponent>b__0();
}
public enum JetBrains.Application.Components.ComponentInstantiation : Enum {
    public int value__;
    public static ComponentInstantiation Default;
    public static ComponentInstantiation WithEnvironment;
    public static ComponentInstantiation OnDemand;
}
internal class JetBrains.Application.Components.ComponentRegister : object {
    private HashMap`2<object, ComponentRegisterEntry> myRegistrationMap;
    private static OneToListMap`2<IValueRegistration, IComponentDescriptor> BuildRegistrationMap(IList`1<IComponentDescriptor> descriptors);
    public OneToListMap`2<IValueRegistration, IComponentDescriptor> AddDescriptors(IList`1<IComponentDescriptor> descriptors);
    public void RemoveDescriptors(IList`1<IComponentDescriptor> descriptors);
    public bool TryGetValue(TRequest request, ComponentRegisterEntry& entry);
}
internal class JetBrains.Application.Components.ComponentRegisterEntry : object {
    private object myDescriptors;
    private ComponentAccessCardinality myCardinality;
    private object myCardinalityContext;
    public ComponentRegisterEntry(ComponentRegisterEntry value, object registration);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IEnumerator`1<IComponentDescriptor> GetEnumerator();
    public IComponentDescriptor SingleOrDefault();
    private IEnumerator`1<IComponentDescriptor> GetSingleEnumerator(IComponentDescriptor singleDescriptor);
    public void VerifyCardinality(ComponentAccessCardinality value, object registration, object context);
    public void AddRange(IList`1<IComponentDescriptor> descriptors);
    public void RemoveRange(IList`1<IComponentDescriptor> descriptors);
    public virtual string ToString();
}
public class JetBrains.Application.Components.ComponentRegistrationEqualityComparer : object {
    public static ComponentRegistrationEqualityComparer Instance;
    private static ComponentRegistrationEqualityComparer();
    public sealed virtual int GetHashCode(object obj);
    private sealed virtual override bool System.Collections.Generic.IEqualityComparer<System.Object>.Equals(object x, object y);
}
internal class JetBrains.Application.Components.ComponentResolveContext : object {
    [NotNullAttribute]
private ComponentContainer myContainer;
    [NotNullAttribute]
private IValueDescriptor myRequestingDescriptor;
    [NotNullAttribute]
public IValueDescriptor RequestingDescriptor { get; }
    [NotNullAttribute]
public IComponentContainer Container { get; }
    public ComponentResolveContext(ComponentContainer container, IValueDescriptor requestingDescriptor);
    public IValueDescriptor get_RequestingDescriptor();
    public IComponentContainer get_Container();
    public virtual string ToString();
    public sealed virtual IValueDescriptor Resolve(TRequest request);
}
public class JetBrains.Application.Components.ComponentStorage : object {
    private string myId;
    private IInitializationStrategy myInitializationStrategy;
    private CompositeAccessPolicy myAccessPolicy;
    private ComponentStorageState myState;
    private LifetimeDefinition myComposeDescriptorsLifetimeDefinition;
    private Dictionary`2<IComponentDescriptor, Lifetime> myDescriptors;
    private OneToListMap`2<Lifetime, IComponentDescriptor> myRegistrations;
    private ComponentRegister myComponentRegister;
    private OneToListMap`2<object, Pair`2<Lifetime, Action`2<Lifetime, IComponentDescriptor>>> myViewers;
    private OneToSetMap`2<IComponentDescriptor, object> myTypeDependencies;
    private ILogger myLogger;
    public ComponentStorage(string id, IInitializationStrategy initializationStrategy);
    public ComponentStorage AttachPolicy(IComponentAccessPolicy accessPolicy);
    private IValueDescriptor ResolveImpl(TRequest request, IValueResolveContext context);
    internal void RegisterDependency(TRequest request, IValueResolveContext context);
    private IEnumerable`1<IValueDescriptor> ResolveMultipleImpl(TRequest request, IValueResolveContext context);
    private IEnumerable`1<IValueDescriptor> EnumerateDescriptors(TRequest request, IValueResolveContext context);
    public ComponentStorage RegisterDescriptors(Lifetime lifetime, IList`1<IComponentDescriptor> descriptors);
    public void Compose();
    public sealed virtual void Dispose();
    internal void View(Lifetime lifetime, Action`2<Lifetime, IComponentDescriptor> viewer);
    private void NotifyViewers(Lifetime lifetime, OneToListMap`2<IValueRegistration, IComponentDescriptor> typeMap);
    private void ComposeDescriptors(ICollection`1<IComponentDescriptor> descriptors);
    private void InstantiateDescriptors(ICollection`1<IComponentDescriptor> descriptors);
    private IEnumerable`1<IComponentDescriptor> EnumerateDescriptorsInDisposeOrder(ICollection`1<IComponentDescriptor> descriptors);
    private void DisposeDescriptor(IComponentDescriptor descriptor);
    private void AddExceptionData(Exception ex);
    public sealed virtual IValueDescriptor Resolve(TRequest request, IValueResolveContext context);
    public IEnumerable`1<IValueDescriptor> ResolveMultiple(TRequest request, IValueResolveContext context);
    public virtual string ToString();
    [ConditionalAttribute("JET_MODE_ASSERT")]
private void CheckCircularDependencies(IComponentDescriptor rootDescriptor, IComponentDescriptor lastDescriptor, object request, Stack`1<Pair`2<IComponentDescriptor, object>> currentTypes, HashSet`1<object> visited);
    [CompilerGeneratedAttribute]
private static string <ResolveImpl>b__5(IComponentDescriptor x);
    [CompilerGeneratedAttribute]
private Lifetime <ComposeDescriptors>b__15(IComponentDescriptor descriptor);
    [CompilerGeneratedAttribute]
private object <AddExceptionData>b__19();
    [CompilerGeneratedAttribute]
private object <AddExceptionData>b__1a();
}
public enum JetBrains.Application.Components.ComponentStorageState : Enum {
    public int value__;
    public static ComponentStorageState Initial;
    public static ComponentStorageState Initialized;
    public static ComponentStorageState Disposing;
    public static ComponentStorageState Disposed;
}
public class JetBrains.Application.Components.CompositeAccessPolicy : object {
    private List`1<IComponentAccessPolicy> myAccessControls;
    public sealed virtual void AssertModification();
    public void Add(IComponentAccessPolicy accessPolicy);
}
public class JetBrains.Application.Components.DelayedInitializationStrategy : object {
    private static ILogger Logger;
    private Queue`1<ScheduledComponent> myActions;
    private Queue`1<Pair`2<Lifetime, Action>> myActionsLast;
    private Lifetime myLifetime;
    private ReentrancyGuard myGuard;
    public DelayedInitializationStrategy(Lifetime lifetime, ReentrancyGuard guard);
    private static DelayedInitializationStrategy();
    public sealed virtual void Schedule(Lifetime lifetime, ICollection`1<IComponentDescriptor> dscs);
    public sealed virtual void Wait(Action whenDone, Lifetime lifetime);
    private void Dispatch();
    [CompilerGeneratedAttribute]
private void <Dispatch>b__2();
}
public class JetBrains.Application.Components.DelegatingComponentContainer : object {
    private IValueResolveContext myContext;
    private IValueResolveContext myDynamicContext;
    public IValueResolveContext Context { get; }
    public DelegatingComponentContainer(IValueResolveContext context, IValueResolveContext dynamicContext);
    public IValueResolveContext get_Context();
    public sealed virtual IValueResolveContext CreateResolveContext(IValueDescriptor requestingDescriptor);
    public sealed virtual object GetValue();
    public virtual string ToString();
    public sealed virtual IValueDescriptor Resolve(TRequest request, IValueResolveContext context);
}
[ExtensionAttribute]
public static class JetBrains.Application.Components.DelegatingContainer : object {
    [ExtensionAttribute]
public static ComponentContainer ChainTo(ComponentContainer container, IComponentContainer dynamicContainer);
}
public class JetBrains.Application.Components.DelegatingContainerValueResolver : object {
    public sealed virtual IValueDescriptor Resolve(TRequest request, IValueResolveContext context);
}
public class JetBrains.Application.Components.DispatcherAccessPolicy : object {
    private JetDispatcher myDispatcher;
    public static DispatcherAccessPolicy Default { get; }
    public DispatcherAccessPolicy(JetDispatcher dispatcher);
    public static DispatcherAccessPolicy get_Default();
    public sealed virtual void AssertModification();
}
public class JetBrains.Application.Components.DynamicComponentDescriptor : object {
    [NotNullAttribute]
public static DynamicComponentDescriptor Instance;
    private static DynamicComponentDescriptor();
    public sealed virtual object GetValue();
    public sealed virtual IEnumerable`1<IValueRegistration> GetRegistrations();
    public virtual string ToString();
}
internal class JetBrains.Application.Components.DynamicContext : ValueType {
    [ThreadStaticAttribute]
private static Stack`1<IValueResolveContext> ThreadContext;
    private IValueResolveContext myContext;
    private DynamicContext(IValueResolveContext context);
    public static IValueResolveContext PeekOrCreate(IComponentContainer container);
    public static DynamicContext Push(IValueResolveContext context);
    public sealed virtual void Dispose();
}
public class JetBrains.Application.Components.EnumerableValueResolver : object {
    private ResolveMultipleDelegate myComponentStorageResolveMultiple;
    private IList`1<KeyValuePair`2<int, IValueResolver>> myLinkedResolvers;
    private bool myIsResolvingNullWhenNoValues;
    private Dictionary`2<Type, IValueDescriptor> myEnumerablesCache;
    [NotNullAttribute]
private static Type ourIEnumerableType;
    public EnumerableValueResolver(ResolveMultipleDelegate componentStorageResolveMultiple, IList`1<KeyValuePair`2<int, IValueResolver>> linkedResolvers, bool isResolvingNullWhenNoValues);
    private static EnumerableValueResolver();
    public sealed virtual IValueDescriptor Resolve(TRequest request, IValueResolveContext context);
}
public static class JetBrains.Application.Components.FactoryComponentContainer : object {
    [NotNullAttribute]
public static TInstance CreateInstance(Lifetime lifetime, IComponentContainer parent, Object[] args);
    [NotNullAttribute]
public static object CreateInstance(Lifetime lifetime, Type objecttype, IComponentContainer parent, Object[] args);
    [NotNullAttribute]
public static object CreateInstanceWithoutContainer(Lifetime lifetime, Type objecttype, Object[] args);
    [NotNullAttribute]
private static object CreateInstanceCore(Lifetime lifetime, Type type, IComponentContainer parent, Object[] args);
    public static void InvokeTransient(IComponentContainer parent, Expression`1<Action> expr);
    public static void InvokeLive(Lifetime lifetime, IComponentContainer parent, Expression`1<Action> expr, Object[] args);
    [NotNullAttribute]
private static List`1<IComponentDescriptor> GetExplicitArgumentDescriptors(Object[] args);
}
public class JetBrains.Application.Components.FreeComponentAccessPolicy : object {
    public static IComponentAccessPolicy Default;
    private static FreeComponentAccessPolicy();
    private sealed virtual override void JetBrains.Application.Components.IComponentAccessPolicy.AssertModification();
}
public interface JetBrains.Application.Components.IComponentAccessPolicy {
    public abstract virtual void AssertModification();
}
public interface JetBrains.Application.Components.IComponentContainer {
    [NotNullAttribute]
public abstract virtual IValueResolveContext CreateResolveContext(IValueDescriptor requestingDescriptor);
}
public interface JetBrains.Application.Components.IComponentDescriptor {
    public abstract virtual IEnumerable`1<IValueRegistration> GetRegistrations();
}
public interface JetBrains.Application.Components.IComponentDescriptorWithRequirement {
    public InstantiationRequirement Requirement { get; }
    public abstract virtual InstantiationRequirement get_Requirement();
}
public interface JetBrains.Application.Components.IHideImplementation`1 {
}
public interface JetBrains.Application.Components.IInitializationStrategy {
    public abstract virtual void Schedule(Lifetime lifetime, ICollection`1<IComponentDescriptor> action);
    public abstract virtual void Wait(Action whenDone, Lifetime lifetime);
}
public interface JetBrains.Application.Components.IInitializationStrategyProvider {
    public abstract virtual IInitializationStrategy InitializationStrategy(Lifetime lifetime);
}
public class JetBrains.Application.Components.InitializationStrategyDefault : object {
    public sealed virtual void Schedule(Lifetime lifetime, ICollection`1<IComponentDescriptor> dscs);
    public sealed virtual void Wait(Action whenDone, Lifetime lifetime);
}
public interface JetBrains.Application.Components.IValueDescriptor {
    [NotNullAttribute]
public abstract virtual object GetValue();
}
public interface JetBrains.Application.Components.IValueRegistration {
    public abstract virtual bool Accepts(object request);
}
public interface JetBrains.Application.Components.IValueResolveContext {
    public abstract virtual IValueDescriptor Resolve(TRequest registration);
}
public interface JetBrains.Application.Components.IValueResolver {
    public abstract virtual IValueDescriptor Resolve(TRequest request, IValueResolveContext context);
}
public class JetBrains.Application.Components.LazyValueResolver : object {
    public sealed virtual IValueDescriptor Resolve(TRequest request, IValueResolveContext context);
    [CanBeNullAttribute]
public static Type TryExtractTypeUnderLazy(Type typePossiblyLazy);
    [NotNullAttribute]
public static IValueDescriptor Create(Type typeUnderLazy, IValueDescriptor descriptorUnderLazy);
}
public class JetBrains.Application.Components.LifetimeValueResolver : object {
    public sealed virtual IValueDescriptor Resolve(TRequest request, IValueResolveContext context);
}
public class JetBrains.Application.Components.LoggerValueResolver : object {
    public sealed virtual IValueDescriptor Resolve(TRequest request, IValueResolveContext context);
}
public class JetBrains.Application.Components.ObjectComponentDescriptor : object {
    private object myInstance;
    [CompilerGeneratedAttribute]
private static Func`2<Type, IValueRegistration> CS$<>9__CachedAnonymousMethodDelegate1;
    public ObjectComponentDescriptor(object instance);
    public sealed virtual IEnumerable`1<IValueRegistration> GetRegistrations();
    public sealed virtual object GetValue();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
private static IValueRegistration <GetRegistrations>b__0(Type type);
}
public class JetBrains.Application.Components.Optional`1 : object {
    public static Optional`1<T> Null;
    [CanBeNullAttribute]
private T myValue;
    [CanBeNullAttribute]
public T CanBeNull { get; }
    public bool IsNotNull { get; }
    public bool IsNull { get; }
    [NotNullAttribute]
public T NotNull { get; }
    public Optional`1(T value);
    private static Optional`1();
    public T get_CanBeNull();
    public bool get_IsNotNull();
    public bool get_IsNull();
    public T get_NotNull();
    public virtual string ToString();
}
[ExtensionAttribute]
public static class JetBrains.Application.Components.OptionalEx : object {
    [NotNullAttribute]
[ExtensionAttribute]
public static T ValueNotNull(Optional`1<T> thіs, string message);
}
public class JetBrains.Application.Components.OptionalValueResolver : object {
    [NotNullAttribute]
public static IValueDescriptor Create(Type typeUnderOptional, IValueDescriptor descriptorUnderOptional);
    [CanBeNullAttribute]
public static Type TryExtractTypeUnderOptional(Type typePossiblyOptional);
    public sealed virtual IValueDescriptor Resolve(TRequest request, IValueResolveContext context);
}
public static class JetBrains.Application.Components.PartCatalogueTypeEqualityUtil : object {
    public static int GetHashCode(StringSource assemblyFullName, StringSource typeFullName);
    public static bool TypesEquals(Type type, PartCatalogueType partCatalogueType);
    [ObsoleteAttribute("PCType got Equals for runtime types.")]
public static bool TypesEquals(Type type, PartCatalogType partCatalogueType);
    public static bool GenericTypesTypesEquals(Type type, PartCatalogueType partCatalogueType);
}
[ExtensionAttribute]
public static class JetBrains.Application.Components.SignatureResolution : object {
    [CompilerGeneratedAttribute]
private static MemberFilter CS$<>9__CachedAnonymousMethodDelegate2;
    [CompilerGeneratedAttribute]
private static Func`2<MemberInfo, MethodBase> CS$<>9__CachedAnonymousMethodDelegate3;
    [CompilerGeneratedAttribute]
private static Func`2<Pair`2<int, Binding>, int> CS$<>9__CachedAnonymousMethodDelegate5;
    [ExtensionAttribute]
public static object CreateInstance(IComponentContainer container);
    [ExtensionAttribute]
public static object CreateInstance(IComponentContainer container, Type type);
    [ExtensionAttribute]
public static object DynamicInvoke(IComponentContainer container, Delegate function);
    [ExtensionAttribute]
public static void DynamicInvoke(IComponentContainer container, Action action);
    [ExtensionAttribute]
public static void DynamicInvoke(IComponentContainer container, Action`1<T1> action);
    [ExtensionAttribute]
public static void DynamicInvoke(IComponentContainer container, Action`2<T1, T2> action);
    [ExtensionAttribute]
public static TResult DynamicInvoke(IComponentContainer container, Func`1<TResult> action);
    [ExtensionAttribute]
public static TResult DynamicInvoke(IComponentContainer container, Func`2<T1, TResult> action);
    [ExtensionAttribute]
public static TResult DynamicInvoke(IComponentContainer container, Func`3<T1, T2, TResult> action);
    [ExtensionAttribute]
public static TResult DynamicInvoke(IComponentContainer container, Func`4<T1, T2, T3, TResult> action);
    [ExtensionAttribute]
public static TResult DynamicInvoke(IComponentContainer container, Func`5<T1, T2, T3, T4, TResult> action);
    [ExtensionAttribute]
public static object CreateInstance(Binding binding);
    [ExtensionAttribute]
private static object CreateInstance(ConstructorInfo constructor, List`1<IValueDescriptor> argumentDescriptors);
    [ExtensionAttribute]
public static Binding BindToConstructor(Type type, IValueResolveContext context);
    [ExtensionAttribute]
public static Binding BindToMethod(Type type, string name, IValueResolveContext context);
    public static Binding BindToMethod(MethodBase[] candidates, IValueResolveContext context, object origin);
    public static Object[] BindArguments(List`1<IValueDescriptor> argumentDescriptors, object origin);
    [NotNullAttribute]
private static InvalidOperationException MakeDiagnosticException(string descriptor, List`1<Binding> bound, List`1<KeyValuePair`2<MethodBase, List`1<Type>>> rejected);
    private static void AddRejectedConstructorsData(Exception ex, IEnumerable`1<KeyValuePair`2<MethodBase, List`1<Type>>> constructorsRejected);
    [NotNullAttribute]
public static Object[] BindMethodParameters(MethodInfo method, IComponentContainer container);
    [CompilerGeneratedAttribute]
private static bool <BindToMethod>b__0(MemberInfo info, object criteria);
    [CompilerGeneratedAttribute]
private static MethodBase <BindToMethod>b__1(MemberInfo m);
    [CompilerGeneratedAttribute]
private static int <BindToMethod>b__4(Pair`2<int, Binding> bnd);
}
public abstract class JetBrains.Application.Components.SingletonComponentDescriptor : SingletonDescriptor {
    [NotNullAttribute]
private Type myType;
    [CompilerGeneratedAttribute]
private static Func`2<Type, IValueRegistration> CS$<>9__CachedAnonymousMethodDelegateb;
    [NotNullAttribute]
public Type Type { get; }
    protected SingletonComponentDescriptor(IComponentContainer container, Type type);
    public virtual IEnumerable`1<IValueRegistration> GetRegistrations();
    public Type get_Type();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
private static IValueRegistration <GetRegistrations>b__a(Type type);
}
public abstract class JetBrains.Application.Components.SingletonDescriptor : object {
    [CanBeNullAttribute]
private object myInstance;
    [NotNullAttribute]
private IComponentContainer myContainer;
    private ComponentState myState;
    [CanBeNullAttribute]
private List`1<IDisposable> myOwnedObjects;
    protected SingletonDescriptor(IComponentContainer container);
    public sealed virtual object GetValue();
    public abstract virtual IEnumerable`1<IValueRegistration> GetRegistrations();
    protected void SetState(ComponentState state);
    protected void RegisterOwnedObject(IDisposable ownedObject);
    protected abstract virtual object CreateInstance(IValueResolveContext context);
    private void CreateInstanceChecked(OnError onError, IComponentContainer container);
    private void DisposeImpl();
    [ConditionalAttribute("JET_MODE_ASSERT")]
private void ZeroFields(object instance);
    [ConditionalAttribute("JET_MODE_ASSERT")]
private void RegisterInstanceWithLeakWatchdog();
    private sealed virtual override void System.IDisposable.Dispose();
    public void AddExceptionData(Exception ex);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
private object <AddExceptionData>b__0();
    [CompilerGeneratedAttribute]
private object <AddExceptionData>b__1();
    [CompilerGeneratedAttribute]
private object <AddExceptionData>b__2();
}
public class JetBrains.Application.Components.SingletonFactoryComponentDescriptor`1 : SingletonComponentDescriptor {
    [NotNullAttribute]
private Func`2<IValueResolveContext, T> myFactory;
    public SingletonFactoryComponentDescriptor`1(IComponentContainer container, Func`2<IValueResolveContext, T> factory);
    protected virtual object CreateInstance(IValueResolveContext context);
}
public class JetBrains.Application.Components.SingletonTypeComponentDescriptor : SingletonComponentDescriptor {
    public SingletonTypeComponentDescriptor(IComponentContainer container, Type type);
    private object CreateInstanceOf(Type type, IValueResolveContext context);
    protected virtual object CreateInstance(IValueResolveContext context);
}
public class JetBrains.Application.Components.TaggedRegistration : object {
    [NotNullAttribute]
private IValueRegistration myRegistration;
    [NotNullAttribute]
private object myTag;
    [NotNullAttribute]
public IValueRegistration Registration { get; }
    [NotNullAttribute]
public object Tag { get; }
    public TaggedRegistration(IValueRegistration registration, object tag);
    public IValueRegistration get_Registration();
    public object get_Tag();
    public sealed virtual bool Accepts(object request);
    private bool Equals(TaggedRegistration other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class JetBrains.Application.Components.TaggedRequest : object {
    private object myRequest;
    private object myTag;
    public object Request { get; }
    public object Tag { get; }
    public TaggedRequest(object request, object tag);
    public object get_Request();
    public object get_Tag();
}
internal class JetBrains.Application.Components.TaggedResolveContext : object {
    private IValueResolveContext myResolveContext;
    private object myTag;
    public TaggedResolveContext(IValueResolveContext resolveContext, object tag);
    public sealed virtual IValueDescriptor Resolve(TRequest request);
}
public class JetBrains.Application.Components.TypeRegistration : object {
    [NotNullAttribute]
private Type myType;
    public Type Type { get; }
    public TypeRegistration(Type type);
    public Type get_Type();
    private bool Equals(TypeRegistration other);
    public virtual int GetHashCode();
    public sealed virtual bool Accepts(object request);
    public virtual string ToString();
    public virtual bool Equals(object obj);
}
public class JetBrains.Application.Components.UnidentifiedComponentDescriptor : object {
    public static UnidentifiedComponentDescriptor Instance;
    private static UnidentifiedComponentDescriptor();
    public sealed virtual object GetValue();
    public sealed virtual IEnumerable`1<IValueRegistration> GetRegistrations();
    public virtual string ToString();
}
public class JetBrains.Application.Components.ViewableValueResolver : object {
    private ComponentStorage myComponentStorage;
    private List`1<KeyValuePair`2<int, IValueResolver>> myLinkedResolvers;
    public ViewableValueResolver(ComponentStorage componentStorage, List`1<KeyValuePair`2<int, IValueResolver>> linkedResolvers);
    public sealed virtual IValueDescriptor Resolve(TRequest request, IValueResolveContext context);
}
public static class JetBrains.Application.Extensibility.AppDomainPartCatalogAssembliesResolver : object {
    public static void Install(Lifetime lifetime, PartCatalog singlecatalog);
    public static void Install(Lifetime lifetime, IPartCatalogSet catalogset);
}
[ExtensionAttribute]
public static class JetBrains.Application.Extensibility.CatalogComponents : object {
    [ExtensionAttribute]
public static ComponentContainer RegisterCatalog(ComponentContainer container, IPartCatalogSet catalogSet, IPartSelector selector, IPartCatalogFilter[] filters);
    [ExtensionAttribute]
public static IComponentContainer RegisterCatalog(ComponentContainer container, IPartCatalogSet catalogSet);
    [ExtensionAttribute]
public static ComponentContainer RegisterCatalog(ComponentContainer container, IPartCatalogSet catalogSet, IPartCatalogFilter[] filters);
    [ExtensionAttribute]
public static ComponentContainer RegisterCatalog(ComponentContainer container, IPartCatalogSet catalogSet, IPartSelector selector, IPartCatalogFilter[] filters);
}
public class JetBrains.Application.Extensibility.CatalogComponentSource : object {
    private IPartCatalogSet myCatalogSet;
    private IComponentContainer myContainer;
    private IPartCatalogFilter myPartsFilter;
    private IPartSelector mySelector;
    [CompilerGeneratedAttribute]
private static Func`2<PartCatalog, IEnumerable`1<PartCatalogType>> CS$<>9__CachedAnonymousMethodDelegate4;
    public IPartCatalogFilter PartsFilter { get; }
    public CatalogComponentSource(IComponentContainer container, IPartCatalogSet catalogSet, IPartSelector selector, IEnumerable`1<IPartCatalogFilter> filters);
    public IPartCatalogFilter get_PartsFilter();
    private sealed virtual override void JetBrains.DataFlow.IViewable<System.Collections.Generic.IEnumerable<JetBrains.Application.Components.IComponentDescriptor>>.View(Lifetime lifetime, Action`2<Lifetime, IEnumerable`1<IComponentDescriptor>> viewer);
    private static void TraceComponentSourceInitialParts(IComponentContainer container, IPartCatalogSet catalogset);
    [CompilerGeneratedAttribute]
private static IEnumerable`1<PartCatalogType> <TraceComponentSourceInitialParts>b__3(PartCatalog pc);
}
[ExtensionAttribute]
public static class JetBrains.Application.Extensibility.CatalogueComponents : object {
    [ExtensionAttribute]
public static ComponentContainer RegisterCatalogue(ComponentContainer container, IPartsCatalogueSet catalogueSet, IPartsSelector selector, IPartsCatalogueFilter[] filters);
    [ExtensionAttribute]
public static IComponentContainer RegisterCatalogue(ComponentContainer container, IPartsCatalogueSet catalogueSet);
    [ExtensionAttribute]
public static ComponentContainer RegisterCatalogue(ComponentContainer container, IPartsCatalogueSet catalogueSet, IPartsCatalogueFilter[] filters);
    [ExtensionAttribute]
public static ComponentContainer RegisterCatalogue(ComponentContainer container, IPartsCatalogueSet catalogueSet, IPartsSelector selector, IPartsCatalogueFilter[] filters);
}
public class JetBrains.Application.Extensibility.CatalogueComponentSource : object {
    private IComponentContainer myContainer;
    private IPartsCatalogueSet myCatalogueSet;
    private IPartsSelector mySelector;
    private IPartsCatalogueFilter myPartsFilter;
    public IPartsCatalogueFilter PartsFilter { get; }
    public CatalogueComponentSource(IComponentContainer container, IPartsCatalogueSet catalogueSet, IPartsSelector selector, IEnumerable`1<IPartsCatalogueFilter> filters);
    public IPartsCatalogueFilter get_PartsFilter();
    public sealed virtual void View(Lifetime lifetime, Action`2<Lifetime, IEnumerable`1<IComponentDescriptor>> viewer);
    [CompilerGeneratedAttribute]
private List`1<IPartsCatalogue> <View>b__0(Lifetime lt);
}
[ExtensionAttribute]
public static class JetBrains.Application.Extensibility.FeaturePartsExtensions : object {
    [ExtensionAttribute]
[NotNullAttribute]
public static IEnumerable`1<TFeaturePart> FilterOverriddenComponents(IList`1<TFeaturePart> components);
    [ExtensionAttribute]
public static IEnumerable`1<TObj> FilterOverriddenComponents(IList`1<TObj> components, Func`2<TObj, TFactory> getFactory, Func`3<TObj, TObj, bool> applyFilterCondition);
    [ExtensionAttribute]
public static IEnumerable`1<TResultPart> FilterFactoryPattern(IEnumerable`1<TFeatureFactory> componentsEnumerable, Func`2<TFeatureFactory, TResultPart> creator);
    private static Nullable`1<int> TestInherits(TFeatureFactory f1, TFeatureFactory f2, Dictionary`2<Type, TFeatureFactory> map);
}
public class JetBrains.Application.Extensibility.PartCatalogTypeComponentDescriptor : SingletonDescriptor {
    private PartCatalogType myPart;
    [CompilerGeneratedAttribute]
private InstantiationRequirement <Requirement>k__BackingField;
    public PartCatalogType Part { get; }
    public InstantiationRequirement Requirement { get; private set; }
    public PartCatalogTypeComponentDescriptor(IComponentContainer container, PartCatalogType part);
    public PartCatalogType get_Part();
    [CompilerGeneratedAttribute]
public sealed virtual InstantiationRequirement get_Requirement();
    [CompilerGeneratedAttribute]
private void set_Requirement(InstantiationRequirement value);
    public virtual IEnumerable`1<IValueRegistration> GetRegistrations();
    public virtual string ToString();
    protected virtual object CreateInstance(IValueResolveContext context);
    private object CreateInstanceOf(Type type, IValueResolveContext context);
}
internal class JetBrains.Application.Extensibility.PartCatalogTypeComponentRegistration : object {
    private int myHashCode;
    private PartCatalogType myType;
    public PartCatalogTypeComponentRegistration(PartCatalogType type);
    public sealed virtual bool Accepts(object request);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private bool Equals(PartCatalogTypeComponentRegistration other);
    public virtual string ToString();
}
public class JetBrains.Application.Extensibility.PartCatalogTypeMemberComponentDescriptor : SingletonDescriptor {
    private PartCatalogTypeMember myMember;
    [NotNullAttribute]
public PartCatalogTypeMember Member { get; }
    [NotNullAttribute]
public PartCatalogType Part { get; }
    public PartCatalogTypeMemberComponentDescriptor(IComponentContainer container, PartCatalogTypeMember member);
    public PartCatalogTypeMember get_Member();
    public PartCatalogType get_Part();
    public virtual IEnumerable`1<IValueRegistration> GetRegistrations();
    public virtual string ToString();
    protected virtual object CreateInstance(IValueResolveContext context);
}
public class JetBrains.Application.Extensibility.PartComponentDescriptor : SingletonDescriptor {
    private PartCatalogueType myPart;
    [CompilerGeneratedAttribute]
private InstantiationRequirement <Requirement>k__BackingField;
    public InstantiationRequirement Requirement { get; private set; }
    public PartCatalogueType Part { get; }
    public PartComponentDescriptor(IComponentContainer container, PartCatalogueType part);
    [CompilerGeneratedAttribute]
public sealed virtual InstantiationRequirement get_Requirement();
    [CompilerGeneratedAttribute]
private void set_Requirement(InstantiationRequirement value);
    public PartCatalogueType get_Part();
    private object CreateInstanceOf(Type type, IValueResolveContext context);
    public virtual string ToString();
    protected virtual object CreateInstance(IValueResolveContext context);
    public virtual IEnumerable`1<IValueRegistration> GetRegistrations();
}
internal class JetBrains.Application.Extensibility.PartComponentRegistration : object {
    [NotNullAttribute]
private PartCatalogueType myType;
    private int myHashCode;
    public PartComponentRegistration(PartCatalogueType type);
    private bool Equals(PartComponentRegistration other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Accepts(object request);
}
public class JetBrains.Application.Extensibility.PartMemberComponentDescriptor : SingletonDescriptor {
    private PartCatalogueType myPart;
    private PartCatalogueTypeMember myMember;
    [NotNullAttribute]
public PartCatalogueType Part { get; }
    [NotNullAttribute]
public PartCatalogueTypeMember Member { get; }
    public PartMemberComponentDescriptor(IComponentContainer container, PartCatalogueType part, PartCatalogueTypeMember member);
    public PartCatalogueType get_Part();
    public PartCatalogueTypeMember get_Member();
    public virtual IEnumerable`1<IValueRegistration> GetRegistrations();
    public virtual string ToString();
    protected virtual object CreateInstance(IValueResolveContext context);
}
public static class JetBrains.Application.Extensibility.Reflection.CodeDomCatalogEx : object {
    [CompilerGeneratedAttribute]
private static Func`2<PartCatalogType, AssemblyNameInfo> CS$<>9__CachedAnonymousMethodDelegate1;
    [NotNullAttribute]
public static CodeTypeReference MakeTypeReference(PartCatalogType type, CodeDomAssemblyReferences refs);
    [CompilerGeneratedAttribute]
private static AssemblyNameInfo <MakeTypeReference>b__0(PartCatalogType t);
}
public class JetBrains.Application.Extensibility.SplittedComponentContainer`2 : object {
    private string myAttributeArgumentName;
    private Dictionary`2<TDefinition, IComponentContainer> myContainers;
    private Dictionary`2<Type, IComponentContainer> myContainersByType;
    private OneToListMap`2<PartCatalog, Tuple`2<PartCatalogType, Type>> myDefinitionsToParts;
    private ViewableCollection`1<TDefinition> myDefinitions;
    public ViewableCollection`1<TDefinition> Definitions { get; }
    public SplittedComponentContainer`2(Lifetime lifetime, IPartCatalogSet catalogSet, IComponentContainer parentContainer, IViewable`1<TDefinition> definitions, Expression`1<Func`2<TDefinitionAttribute, Type>> propertyExpression);
    public ViewableCollection`1<TDefinition> get_Definitions();
    private IEnumerable`1<Tuple`2<PartCatalogType, Type>> GetPartTuples(PartCatalog catalog);
    protected virtual void InitializeDefinition(Lifetime lifetime, TDefinition definition, IPartCatalogSet catalogSet, IComponentContainer parentContainer);
    private IComponentContainer GetContainer();
    public T GetService();
    public T TryGetService();
    private IComponentContainer GetContainer(TDefinition definition);
    [NotNullAttribute]
[PureAttribute]
public T GetService(TDefinition definition);
    [CanBeNullAttribute]
[PureAttribute]
public T TryGetService(TDefinition definition);
    [NotNullAttribute]
[PureAttribute]
public IEnumerable`1<Pair`2<TDefinition, T>> GetServices();
    [NotNullAttribute]
[PureAttribute]
public IEnumerable`1<T> GetServices(TDefinition definition);
    [NotNullAttribute]
[PureAttribute]
public IEnumerable`1<T> GetServicesFromAll();
    [NotNullAttribute]
[PureAttribute]
public IEnumerable`1<Pair`2<TDefinition, IEnumerable`1<T>>> GetMultipleServices();
    [PureAttribute]
[NotNullAttribute]
public IEnumerable`1<T> GetMultipleServicesFromAll();
    [PureAttribute]
public bool HasService(TDefinition definition);
    [CompilerGeneratedAttribute]
private void <.ctor>b__0(Lifetime catalogLifeTime, PartCatalog catalog);
    [CompilerGeneratedAttribute]
private Pair`2<TDefinition, T> <GetServices>b__15(TDefinition definition);
    [CompilerGeneratedAttribute]
private static bool <GetServices>b__16(Pair`2<TDefinition, T> pair);
    [CompilerGeneratedAttribute]
private Pair`2<TDefinition, IEnumerable`1<T>> <GetMultipleServices>b__17(TDefinition definition);
}
public class JetBrains.Application.Extensibility.TypesInstantiator`2 : object {
    private Dictionary`2<T, Type> myTypeMap;
    private Dictionary`2<T, IEnumerable`1<TAttribute>> myAttrsCache;
    private ISorter`1<T> mySorter;
    private ViewableCollection`1<T> myInstances;
    private ICollection`1<T> mySortedInstances;
    private IEnumerable`1<T> SortedInstances { get; }
    public TypesInstantiator`2(Lifetime lifetime, IPartCatalogSet catalogueSet, ISorter`1<T> sorter);
    public sealed virtual void View(Lifetime lifetime, Action`2<Lifetime, T> viewer);
    public void View(Lifetime lifetime, Action`3<Lifetime, T, TAttribute> viewer);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private void AddParts(Lifetime lifetime, PartCatalog catalogue);
    private IEnumerable`1<T> get_SortedInstances();
    private IEnumerable`1<TAttribute> GetAttributes(T instance);
    [NotNullAttribute]
private TAttribute GetAttribute(T instance);
}
public class JetBrains.Application.Extensibility.TypeView`1 : object {
    [NotNullAttribute]
private ViewableCollection`1<Type> myTypes;
    [NotNullAttribute]
private Dictionary`2<Type, TAttribute> myAttrsCache;
    [CompilerGeneratedAttribute]
private static Func`2<Type, TAttribute> CS$<>9__CachedAnonymousMethodDelegate1;
    public TypeView`1(Lifetime lifetime, IPartCatalogSet catalogueSet);
    private void ViewAction(Lifetime lifeCatalog, PartCatalog catalog);
    public sealed virtual void View(Lifetime lifetime, Action`2<Lifetime, Type> viewer);
    [NotNullAttribute]
public TAttribute GetAttribute(Type type);
    [CompilerGeneratedAttribute]
private static TAttribute <GetAttribute>b__0(Type t);
}
public class JetBrains.Application.Parts.AllPartsSelector : object {
    public sealed virtual IEnumerable`1<PartCatalogueType> SelectParts(IEnumerable`1<PartCatalogueType> parts);
}
public class JetBrains.Application.Parts.AssemblyBinderOnMaster : object {
    [NotNullAttribute]
public AssemblyNameInfo Assembly;
    [NotNullAttribute]
public IAssemblyMasterBinder Master;
    private AssemblyNameInfo JetBrains.Application.Bindings.IAssemblyBinder.AssemblyName { get; }
    public AssemblyBinderOnMaster(AssemblyNameInfo assembly, IAssemblyMasterBinder master);
    private sealed virtual override AssemblyNameInfo JetBrains.Application.Bindings.IAssemblyBinder.get_AssemblyName();
    private sealed virtual override IMetadataAssembly JetBrains.Application.Bindings.IAssemblyBinder.BindToMetadataAssembly(Lifetime lifetime, OnError onerror);
    private sealed virtual override Assembly JetBrains.Application.Bindings.IAssemblyBinder.BindToRuntimeAssembly(OnError onerror);
    private sealed virtual override Stream JetBrains.Application.Bindings.IAssemblyBinder.BindToStream(Lifetime lifetime, OnError onerror);
    private sealed virtual override FileSystemPath JetBrains.Application.Bindings.IAssemblyBinder.BindToDiskPath(OnError onerror);
}
[ObsoleteAttribute("Use factory methods in PartsCatalogues and the base IPartsCatalogue interface.")]
public static class JetBrains.Application.Parts.AssemblyPartsCatalogue : object {
}
public class JetBrains.Application.Parts.AttributeIndexedPartsCatalogue : UserDataHolder {
    private IPartsCatalogue myCatalogue;
    private OneToListMap`2<string, PartCatalogueType> myIndex;
    public AttributeIndexedPartsCatalogue(IPartsCatalogue catalogue);
    public sealed virtual IEnumerable`1<PartCatalogueAssembly> GetAssemblies();
    public sealed virtual IEnumerable`1<PartCatalogueType> GetParts();
    private void EnsurePartsIndex();
    public sealed virtual IEnumerable`1<PartCatalogueType> GetParts(Type attributeType);
}
public static class JetBrains.Application.Parts.CachedPartCatalogueUtil : object {
    private static string CacheName;
    [CompilerGeneratedAttribute]
private static Func`3<StringBuilder, FileSystemPath, StringBuilder> CS$<>9__CachedAnonymousMethodDelegatea;
    [CompilerGeneratedAttribute]
private static Func`2<FileSystemPath, string> CS$<>9__CachedAnonymousMethodDelegatec;
    public static IPartsCatalogue CreateMetadataPartsCatalogueCached(IList`1<FileSystemPath> locations);
    private static IPartsCatalogue CreateFromCache(IList`1<FileSystemPath> locations);
    private static void WriteCache(IList`1<FileSystemPath> locations, IPartsCatalogue partsCatalogue);
    private static FileSystemPath GetCacheLocation(IEnumerable`1<FileSystemPath> locations);
    private static string GetAssemblyLocationsHash(IEnumerable`1<FileSystemPath> assemblylocations);
    private static string GetAssemblyTimestampHash(IEnumerable`1<FileSystemPath> assemblylocations);
    private static IEnumerable`1<FileSystemPath> OrderLocations(IEnumerable`1<FileSystemPath> locations);
    [CompilerGeneratedAttribute]
private static StringBuilder <GetAssemblyTimestampHash>b__9(StringBuilder sb, FileSystemPath fsp);
    [CompilerGeneratedAttribute]
private static string <OrderLocations>b__b(FileSystemPath x);
}
public class JetBrains.Application.Parts.CatalogueAttributeFilter : object {
    private Type myAttributeType;
    public CatalogueAttributeFilter(Type attributeType);
    public virtual IEnumerable`1<PartCatalogueType> GetParts(IPartsCatalogue catalogue);
    public sealed virtual IEnumerable`1<PartCatalogueType> GetParts(IEnumerable`1<PartCatalogueType> parts, IPartsCatalogue catalogue);
    [CompilerGeneratedAttribute]
private bool <GetParts>b__0(PartCatalogueType catalogueType);
    [CompilerGeneratedAttribute]
private bool <GetParts>b__1(PartCatalogueType catalogueType);
}
public class JetBrains.Application.Parts.CatalogueAttributeFilter`1 : CatalogueAttributeFilter {
}
[ExtensionAttribute]
public static class JetBrains.Application.Parts.CatalogueAttributePartsEx : object {
    [ExtensionAttribute]
[NotNullAttribute]
public static IEnumerable`1<PartCatalogueType> GetPartsWithAttribute(IPartsCatalogue thіs);
    [NotNullAttribute]
[ExtensionAttribute]
public static PartCatalogueAttribute GetSingleAttribute(PartCatalogueType thіs, Type typeAttribute);
}
public class JetBrains.Application.Parts.CatalogueIntersectFilter : object {
    private IEnumerable`1<IPartsCatalogueFilter> myFilters;
    public CatalogueIntersectFilter(IEnumerable`1<IPartsCatalogueFilter> filters);
    public sealed virtual IEnumerable`1<PartCatalogueType> GetParts(IPartsCatalogue catalogue);
    public sealed virtual IEnumerable`1<PartCatalogueType> GetParts(IEnumerable`1<PartCatalogueType> parts, IPartsCatalogue catalogue);
}
public class JetBrains.Application.Parts.CataloguePredicateFilter : object {
    private Func`2<PartCatalogueType, bool> myPredicate;
    public CataloguePredicateFilter(Func`2<PartCatalogueType, bool> predicate);
    public sealed virtual IEnumerable`1<PartCatalogueType> GetParts(IPartsCatalogue catalogue);
    public sealed virtual IEnumerable`1<PartCatalogueType> GetParts(IEnumerable`1<PartCatalogueType> parts, IPartsCatalogue catalogue);
}
public class JetBrains.Application.Parts.CataloguesChanged : object {
    private IPartsCatalogueSet myCatalogueSet;
    private IEnumerable`1<IPartsCatalogue> myAddedCatalogues;
    private IEnumerable`1<IPartsCatalogue> myRemovingCatalogues;
    public IPartsCatalogueSet CatalogueSet { get; }
    public IEnumerable`1<IPartsCatalogue> AddedCatalogues { get; }
    public IEnumerable`1<IPartsCatalogue> RemovingCatalogues { get; }
    public CataloguesChanged(IPartsCatalogueSet catalogueSet, IEnumerable`1<IPartsCatalogue> addedCatalogues, IEnumerable`1<IPartsCatalogue> removingCatalogues);
    public IPartsCatalogueSet get_CatalogueSet();
    public IEnumerable`1<IPartsCatalogue> get_AddedCatalogues();
    public IEnumerable`1<IPartsCatalogue> get_RemovingCatalogues();
}
public class JetBrains.Application.Parts.ClassOrMemberWithPartAttributePassFilter : object {
    private sealed virtual override bool JetBrains.Application.Parts.IMetadataPartsPassFilter.IsPart(IMetadataTypeInfo typedecl);
}
public class JetBrains.Application.Parts.ClassWithPartAttributePassFilter : object {
    private sealed virtual override bool JetBrains.Application.Parts.IMetadataPartsPassFilter.IsPart(IMetadataTypeInfo typedecl);
}
[AttributeUsageAttribute("4")]
[MeansImplicitUseAttribute("8")]
public class JetBrains.Application.Parts.ComponentAttribute : PartAttribute {
    public InstantiationRequirement Requirement;
    public static string RequirementName;
    private static ComponentAttribute();
}
public class JetBrains.Application.Parts.CompositePartsCatalogue : object {
    private IList`1<IPartsCatalogue> myCatalogues;
    [CompilerGeneratedAttribute]
private static Func`2<IPartsCatalogue, IEnumerable`1<PartCatalogueAssembly>> CS$<>9__CachedAnonymousMethodDelegate1;
    [CompilerGeneratedAttribute]
private static Func`2<IPartsCatalogue, IEnumerable`1<PartCatalogueType>> CS$<>9__CachedAnonymousMethodDelegate3;
    public CompositePartsCatalogue(IEnumerable`1<IPartsCatalogue> catalogues);
    public sealed virtual IEnumerable`1<PartCatalogueAssembly> GetAssemblies();
    public virtual IEnumerable`1<PartCatalogueType> GetParts();
    [CompilerGeneratedAttribute]
private static IEnumerable`1<PartCatalogueAssembly> <GetAssemblies>b__0(IPartsCatalogue catalogue);
    [CompilerGeneratedAttribute]
private static IEnumerable`1<PartCatalogueType> <GetParts>b__2(IPartsCatalogue catalogue);
}
[ObsoleteAttribute("Use a master binder.")]
public class JetBrains.Application.Parts.FileBasedAssemblyBinder : object {
    [NotNullAttribute]
private IList`1<FileSystemPath> myAdditionalPaths;
    private AssemblyNameInfo myAssemblyName;
    [CanBeNullAttribute]
private Func`2<Lifetime, IAssemblyResolver> myFCreateAdditionalResolvers;
    [NotNullAttribute]
public FileSystemPath Location;
    [CompilerGeneratedAttribute]
private static Action`1<IncompleteAttributeArgs> CS$<>9__CachedAnonymousMethodDelegate1;
    private AssemblyNameInfo JetBrains.Application.Bindings.IAssemblyBinder.AssemblyName { get; }
    public FileBasedAssemblyBinder(FileSystemPath location, IList`1<FileSystemPath> additionalPaths, Func`2<Lifetime, IAssemblyResolver> FCreateAdditionalResolvers, AssemblyNameInfo assemblynameIfKnown);
    private sealed virtual override AssemblyNameInfo JetBrains.Application.Bindings.IAssemblyBinder.get_AssemblyName();
    private sealed virtual override IMetadataAssembly JetBrains.Application.Bindings.IAssemblyBinder.BindToMetadataAssembly(Lifetime lifetime, OnError onerror);
    private sealed virtual override Assembly JetBrains.Application.Bindings.IAssemblyBinder.BindToRuntimeAssembly(OnError onerror);
    private sealed virtual override Stream JetBrains.Application.Bindings.IAssemblyBinder.BindToStream(Lifetime lifetime, OnError onerror);
    private sealed virtual override FileSystemPath JetBrains.Application.Bindings.IAssemblyBinder.BindToDiskPath(OnError onerror);
    [CompilerGeneratedAttribute]
private static void <JetBrains.Application.Bindings.IAssemblyBinder.BindToMetadataAssembly>b__0(IncompleteAttributeArgs args);
}
public class JetBrains.Application.Parts.FilteredCatalogue : UserDataHolder {
    private IPartsCatalogue myCatalogue;
    private IPartsCatalogueFilter myFilter;
    [CompilerGeneratedAttribute]
private static Func`2<PartCatalogueType, PartCatalogueAssembly> CS$<>9__CachedAnonymousMethodDelegate1;
    public FilteredCatalogue(IPartsCatalogue catalogue, IPartsCatalogueFilter filter);
    public sealed virtual IEnumerable`1<PartCatalogueAssembly> GetAssemblies();
    public sealed virtual IEnumerable`1<PartCatalogueType> GetParts();
    public sealed virtual IEnumerable`1<PartCatalogueType> GetParts(Type attributeType);
    [CompilerGeneratedAttribute]
private static PartCatalogueAssembly <GetAssemblies>b__0(PartCatalogueType type);
}
public class JetBrains.Application.Parts.FlyweightPartFactory : object {
    private Dictionary`2<Pair`2<string, PartCatalogueAssembly>, PartCatalogueType> myTypes;
    private Dictionary`2<Pair`2<AssemblyNameInfo, FileSystemPath>, PartCatalogueAssembly> myAssemblies;
    private DataIntern`1<string> myStrings;
    private sealed virtual override PartCatalogueAttribute JetBrains.Application.Parts.IPartCatalogueFactory.CreateAttribute(PartCatalogueType type, IEnumerable`1<PartCatalogueAttributeProperty> properties, PartCatalogueType[] ctorparams);
    private sealed virtual override bool JetBrains.Application.Parts.IPartCatalogueFactory.GetOrCreateAssembly(AssemblyNameInfo assemblyName, FileSystemPath location, PartCatalogueAssembly& assembly);
    private sealed virtual override bool JetBrains.Application.Parts.IPartCatalogueFactory.GetOrCreateType(string fullName, PartCatalogTypeKind kind, PartCatalogueAssembly assembly, PartCatalogueType& type);
    [CompilerGeneratedAttribute]
private PartCatalogueAttributeProperty <JetBrains.Application.Parts.IPartCatalogueFactory.CreateAttribute>b__0(PartCatalogueAttributeProperty property);
}
public interface JetBrains.Application.Parts.IAttributedPartsCatalogue {
    public abstract virtual IEnumerable`1<PartCatalogueType> GetParts(Type attributeType);
}
public interface JetBrains.Application.Parts.IMetadataPartsPassFilter {
    public abstract virtual bool IsPart(IMetadataTypeInfo typedecl);
}
public enum JetBrains.Application.Parts.InstantiationRequirement : Enum {
    public int value__;
    public static InstantiationRequirement None;
    public static InstantiationRequirement Instant;
}
public interface JetBrains.Application.Parts.IPartCatalogueFactory {
    [NotNullAttribute]
public abstract virtual PartCatalogueAttribute CreateAttribute(PartCatalogueType type, IEnumerable`1<PartCatalogueAttributeProperty> properties, PartCatalogueType[] ctorparams);
    public abstract virtual bool GetOrCreateAssembly(AssemblyNameInfo assemblyName, FileSystemPath location, PartCatalogueAssembly& assembly);
    public abstract virtual bool GetOrCreateType(string fullName, PartCatalogTypeKind kind, PartCatalogueAssembly assembly, PartCatalogueType& type);
}
public interface JetBrains.Application.Parts.IPartsCatalogue {
    public abstract virtual IEnumerable`1<PartCatalogueAssembly> GetAssemblies();
    public abstract virtual IEnumerable`1<PartCatalogueType> GetParts();
}
public interface JetBrains.Application.Parts.IPartsCatalogueFilter {
    public abstract virtual IEnumerable`1<PartCatalogueType> GetParts(IPartsCatalogue catalogue);
    public abstract virtual IEnumerable`1<PartCatalogueType> GetParts(IEnumerable`1<PartCatalogueType> parts, IPartsCatalogue catalogue);
}
public interface JetBrains.Application.Parts.IPartsCatalogueSet {
    [NotNullAttribute]
public IViewable`1<IPartsCatalogue> Catalogues { get; }
    [NotNullAttribute]
public IViewable`1<IPartsCatalogue> CataloguesPreview { get; }
    public abstract virtual IViewable`1<IPartsCatalogue> get_Catalogues();
    public abstract virtual IViewable`1<IPartsCatalogue> get_CataloguesPreview();
}
public interface JetBrains.Application.Parts.IPartsSelector {
    public abstract virtual IEnumerable`1<PartCatalogueType> SelectParts(IEnumerable`1<PartCatalogueType> parts);
}
public class JetBrains.Application.Parts.LeafAndHidePartsSelector : object {
    public sealed virtual IEnumerable`1<PartCatalogueType> SelectParts(IEnumerable`1<PartCatalogueType> parts);
}
public class JetBrains.Application.Parts.LeafPartsSelector : object {
    [CompilerGeneratedAttribute]
private static Func`2<KeyValuePair`2<PartCatalogueType, ISet`1<PartCatalogueType>>, PartCatalogueType> CS$<>9__CachedAnonymousMethodDelegate7;
    public sealed virtual IEnumerable`1<PartCatalogueType> SelectParts(IEnumerable`1<PartCatalogueType> parts);
    [CompilerGeneratedAttribute]
private static PartCatalogueType <SelectParts>b__4(KeyValuePair`2<PartCatalogueType, ISet`1<PartCatalogueType>> pair);
}
[ObsoleteAttribute("Use factory methods in PartsCatalogues and the base IPartsCatalogue interface.")]
public static class JetBrains.Application.Parts.MetadataPartsCatalogue : object {
}
[AttributeUsageAttribute("32767")]
[MeansImplicitUseAttribute]
public abstract class JetBrains.Application.Parts.PartAttribute : Attribute {
}
[ExtensionAttribute]
public static class JetBrains.Application.Parts.PartCatalogEx : object {
    [ExtensionAttribute]
[NotNullAttribute]
public static IEnumerable`1<TAttributeType> GetPartAttributeInstancesFromAllAssemblies(PartCatalog thіs);
    [NotNullAttribute]
[ExtensionAttribute]
public static IEnumerable`1<AssemblyAttribute`1<TAttributeType>> GetPartAttributesFromAllAssemblies(PartCatalog thіs);
    [NotNullAttribute]
[ExtensionAttribute]
public static IEnumerable`1<TypeAttribute`1<TAttributeType>> GetPartsWithSingleAttribute(IEnumerable`1<PartCatalog> thіs);
    [NotNullAttribute]
[ExtensionAttribute]
public static IEnumerable`1<TypeAttribute`1<TAttributeType>> GetPartsWithSingleAttribute(IPartCatalogSet thіs);
    [ExtensionAttribute]
public static IEnumerable`1<TypeAttribute`1<TAttributeType>> GetPartsWithSingleAttribute(PartCatalog thіs);
    [CompilerGeneratedAttribute]
private static IEnumerable`1<TAttributeType> <GetPartAttributeInstancesFromAllAssemblies>b__0(PartCatalogAssembly ass);
    [CompilerGeneratedAttribute]
private static TAttributeType <GetPartAttributeInstancesFromAllAssemblies>b__1(PartCatalogAttribute attr);
    [CompilerGeneratedAttribute]
private static IEnumerable`1<AssemblyAttribute`1<TAttributeType>> <GetPartAttributesFromAllAssemblies>b__2(PartCatalogAssembly ass);
    [CompilerGeneratedAttribute]
private static Nullable`1<TypeAttribute`1<TAttributeType>> <GetPartsWithSingleAttribute>b__6(PartCatalogType part);
}
public class JetBrains.Application.Parts.PartCatalogueAssembly : object {
    [NotNullAttribute]
private AssemblyNameInfo myAssemblyName;
    [CanBeNullAttribute]
private FileSystemPath myLocation;
    private List`1<PartCatalogueAttribute> myAttributes;
    private Assembly myLoadedAssembly;
    [CompilerGeneratedAttribute]
private IAssemblyBinder <Binder>k__BackingField;
    [CanBeNullAttribute]
public IAssemblyBinder Binder { get; public set; }
    [NotNullAttribute]
public AssemblyNameInfo AssemblyName { get; }
    [CanBeNullAttribute]
public FileSystemPath Location { get; }
    public PartCatalogueAssembly(AssemblyNameInfo assemblyName, FileSystemPath location);
    [CompilerGeneratedAttribute]
public IAssemblyBinder get_Binder();
    [CompilerGeneratedAttribute]
public void set_Binder(IAssemblyBinder value);
    public AssemblyNameInfo get_AssemblyName();
    public FileSystemPath get_Location();
    [NotNullAttribute]
public Assembly Bind();
    public void AssignAttributes(IEnumerable`1<PartCatalogueAttribute> attributes);
    public IEnumerable`1<PartCatalogueAttribute> GetAttributes(Type attributeType);
    public IEnumerable`1<PartCatalogueAttribute> GetAttributes();
    public IEnumerable`1<PartCatalogueAttribute> GetAttributes();
    public sealed virtual bool Equals(PartCatalogueAssembly other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(PartCatalogueAssembly left, PartCatalogueAssembly right);
    public static bool op_Inequality(PartCatalogueAssembly left, PartCatalogueAssembly right);
    public virtual string ToString();
}
public class JetBrains.Application.Parts.PartCatalogueAttribute : object {
    [NotNullAttribute]
public PartCatalogueType Type;
    [CanBeNullAttribute]
public PartCatalogueType[] ConstructorFormalParameterTypes;
    private Dictionary`2<string, PartCatalogueAttributeProperty> myProperties;
    public PartCatalogueAttribute(PartCatalogueType type, IEnumerable`1<PartCatalogueAttributeProperty> properties, PartCatalogueType[] ctorparams);
    private static string GetMemberName(Expression`1<Func`2<TSource, TValue>> expression);
    [CanBeNullAttribute]
public TValue TryGetProperty(string name);
    public bool TryGetProperty(string name, T& value);
    public bool TryGetProperty(Expression`1<Func`2<TSource, TValue>> expression, TConvertedValue& value);
    public bool TryGetProperty(Expression`1<Func`2<TSource, TValue>> expression, TValue& value);
    [CanBeNullAttribute]
public TValue TryGetProperty(Expression`1<Func`2<TSource, TValue>> expression);
    public T GetProperty(string name);
    public TConvertedValue GetProperty(Expression`1<Func`2<TSource, TValue>> expression);
    public TValue GetProperty(Expression`1<Func`2<TSource, TValue>> expression);
    public T GetPropertyOrDefault(string name, T defaultValue);
    public TConvertedValue GetPropertyOrDefault(Expression`1<Func`2<TSource, TValue>> expression, TConvertedValue defaultValue);
    public TValue GetPropertyOrDefault(Expression`1<Func`2<TSource, TValue>> expression, TValue defaultValue);
    public object GetProperty(string name);
    public ICollection`1<PartCatalogueAttributeProperty> GetProperties();
    public object GetInstance(OnError onerror);
    public bool Equals(PartCatalogueAttribute other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public static class JetBrains.Application.Parts.PartCatalogueAttributeInstanceFactory : object {
    private static ConcurrentDictionary`2<AttributeCtorInvocationKey, AttributeCtorInvocation> myCacheInvocations;
    [CompilerGeneratedAttribute]
private static Func`2<KeyValuePair`2<string, PartCatalogueAttributeProperty>, bool> CS$<>9__CachedAnonymousMethodDelegate2;
    [CompilerGeneratedAttribute]
private static Func`2<AttributeCtorInvocationKey, AttributeCtorInvocation> CS$<>9__CachedAnonymousMethodDelegate3;
    private static PartCatalogueAttributeInstanceFactory();
    public static object CreateInstance(PartCatalogueType typeAttr, PartCatalogueType[] constructorFormalParameterTypes, IDictionary`2<string, PartCatalogueAttributeProperty> properties, OnError onerror);
    [CompilerGeneratedAttribute]
private static bool <CreateInstance>b__0(KeyValuePair`2<string, PartCatalogueAttributeProperty> prop);
    [CompilerGeneratedAttribute]
private static AttributeCtorInvocation <CreateInstance>b__1(AttributeCtorInvocationKey key);
}
public class JetBrains.Application.Parts.PartCatalogueAttributeProperty : object {
    [CompilerGeneratedAttribute]
private PartCatalogAttributeArgumentDisposition <Disposition>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    public PartCatalogAttributeArgumentDisposition Disposition { get; private set; }
    [NotNullAttribute]
public string Name { get; private set; }
    [CanBeNullAttribute]
public object Value { get; private set; }
    public PartCatalogueAttributeProperty(string name, object value, PartCatalogAttributeArgumentDisposition disposition);
    [CompilerGeneratedAttribute]
public PartCatalogAttributeArgumentDisposition get_Disposition();
    [CompilerGeneratedAttribute]
private void set_Disposition(PartCatalogAttributeArgumentDisposition value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public object get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(object value);
    public bool Equals(PartCatalogueAttributeProperty other);
    public void Intern(DataIntern`1<string> strings);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class JetBrains.Application.Parts.PartCatalogueType : object {
    private Pair`2<string, string> myNamePieces;
    private PartCatalogueAssembly myAssembly;
    private PartCatalogueTypesCollection myBaseTypes;
    private PartCatalogueTypesCollection myExtraTypes;
    private PartCatalogueAttribute[] myAttributes;
    private PartCatalogueTypeMember[] myMembers;
    private Type myBoundType;
    private string myCachedLocalName;
    private PartCatalogTypeKind myKind;
    public PartCatalogueTypesCollection BaseTypes { get; }
    public Pair`2<string, string> NamePieces { get; }
    public string FullName { get; }
    public string LocalName { get; }
    public string AssemblyQualifiedName { get; }
    public PartCatalogueAssembly Assembly { get; }
    public bool IsGenericTypeSpecialization { get; }
    public bool IsGenericTypeDeclaraion { get; }
    public bool IsArray { get; }
    public bool IsReference { get; }
    public PartCatalogTypeKind Kind { get; }
    public PartCatalogueTypesCollection ExtraTypes { get; }
    public PartCatalogueType(Pair`2<string, string> pairOfNamePieces, PartCatalogTypeKind kind, PartCatalogueAssembly assembly);
    public PartCatalogueTypesCollection get_BaseTypes();
    public PartCatalogueTypesCollection GetGenericActualParameters();
    public Pair`2<string, string> get_NamePieces();
    public string get_FullName();
    public string get_LocalName();
    public string get_AssemblyQualifiedName();
    public PartCatalogueAssembly get_Assembly();
    public bool get_IsGenericTypeSpecialization();
    public bool get_IsGenericTypeDeclaraion();
    public bool get_IsArray();
    public bool get_IsReference();
    public PartCatalogTypeKind get_Kind();
    public PartCatalogueTypesCollection get_ExtraTypes();
    [NotNullAttribute]
public string GetGenericTypeDeclarationFullName();
    public void AssignRecursiveTypes(RecursiveData data);
    public IEnumerable`1<PartCatalogueAttribute> GetAttributes(Type attributeType);
    public IEnumerable`1<PartCatalogueAttribute> GetAttributes();
    public IList`1<PartCatalogueAttribute> GetAttributes();
    public IList`1<PartCatalogueTypeMember> GetMembers();
    [CanBeNullAttribute]
public Type TryGetBoundType();
    [NotNullAttribute]
public Type Bind();
    internal void BindTo(Type type);
    public sealed virtual bool Equals(PartCatalogueType other);
    public bool Equals();
    public bool Equals(Type typeRuntime);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(PartCatalogueType left, PartCatalogueType right);
    public virtual string ToString();
    public static bool op_Inequality(PartCatalogueType left, PartCatalogueType right);
    public void AddExceptionData(Exception obj);
    private sealed virtual override int System.IComparable<JetBrains.Application.Parts.PartCatalogueType>.CompareTo(PartCatalogueType other);
    [NotNullAttribute]
public PartCatalogueType GetArrayItemType();
    [NotNullAttribute]
public PartCatalogueType GetReferenceTargetType();
    [NotNullAttribute]
public PartCatalogueType GenericTypeParameterOwner();
    [CompilerGeneratedAttribute]
private object <Bind>b__3();
    [CompilerGeneratedAttribute]
private object <Bind>b__4();
    [CompilerGeneratedAttribute]
private object <AddExceptionData>b__7();
}
public class JetBrains.Application.Parts.PartCatalogueTypeEqualityComparer : object {
    public static PartCatalogueTypeEqualityComparer Instance;
    private static PartCatalogueTypeEqualityComparer();
    private sealed virtual override bool System.Collections.Generic.IEqualityComparer<System.Object>.Equals(object x, object y);
    private sealed virtual override int System.Collections.Generic.IEqualityComparer<System.Object>.GetHashCode(object obj);
}
public class JetBrains.Application.Parts.PartCatalogueTypeMember : object {
    private PartCatalogueType myOwner;
    private string myName;
    private PartCatalogTypeMemberKind myKind;
    private IList`1<PartCatalogueType> myParameterTypes;
    private PartCatalogueType myValueType;
    private PartCatalogueAttribute[] myAttributes;
    [CanBeNullAttribute]
private MemberInfo myBoundMember;
    public string Name { get; }
    public string FullName { get; }
    public IList`1<PartCatalogueType> ParameterTypes { get; }
    public PartCatalogueType ValueType { get; }
    public PartCatalogTypeMemberKind Kind { get; }
    [NotNullAttribute]
public PartCatalogueType DeclaringType { get; }
    public PartCatalogueTypeMember(PartCatalogueType owner, string name, PartCatalogTypeMemberKind kind, IList`1<PartCatalogueType> parameterTypes, PartCatalogueType valueType);
    public string get_Name();
    public string get_FullName();
    public IList`1<PartCatalogueType> get_ParameterTypes();
    public PartCatalogueType get_ValueType();
    public PartCatalogTypeMemberKind get_Kind();
    public PartCatalogueType get_DeclaringType();
    public void AssignAttributes(ICollection`1<PartCatalogueAttribute> attributes);
    public IEnumerable`1<PartCatalogueAttribute> GetAttributes(Type attributeType);
    public IEnumerable`1<PartCatalogueAttribute> GetAttributes();
    public PartCatalogueAttribute[] GetAttributes();
    public virtual string ToString();
    [NotNullAttribute]
public MemberInfo Bind();
    [NotNullAttribute]
private MemberInfo BindCore();
    internal void BindTo(MemberInfo member);
}
public static class JetBrains.Application.Parts.PartHelpers : object {
    private static IList`1<string> ourIgnoredAttributes;
    private static Type ourPartAttributeType;
    private static MemberFilter ourAllMembersFilter;
    [CompilerGeneratedAttribute]
private static Func`2<FileSystemPath, FileSystemPath> CS$<>9__CachedAnonymousMethodDelegate5;
    [CompilerGeneratedAttribute]
private static MemberFilter CS$<>9__CachedAnonymousMethodDelegate11;
    private static PartHelpers();
    public static bool HasAttributeOrDerivedAttribute(IMetadataEntity entity, string attributeClrName);
    private static bool IsAttributeOrDerivedAttribute(IMetadataCustomAttribute attribute, string attributeClrName);
    private static bool HasAttributeOrDerivedAttribute(ICustomAttributeProvider type, Type attributeType);
    private static bool IsAttributeOrDerivedAttribute(object attribute, Type attributeType);
    public static bool IsPartAttribute(object attributeInstance);
    public static bool IsPartAttribute(IMetadataCustomAttribute attributeMetadata);
    public static bool HasPartAttribute(IMetadataEntity metadata);
    public static bool HasPartAttribute(ICustomAttributeProvider type);
    public static bool HasPartAttributeOnSelfOrMembers(Type type);
    private static object NormalizePropertyValue(object value, IPartCatalogueFactory typeFactory);
    private static object CreateTypeIfNeeded(object value, IPartCatalogueFactory typeFactory);
    public static PartCatalogueAttribute CreatePartAttribute(object attributeInstance, IPartCatalogueFactory typeFactory);
    public static PartCatalogueAttribute CreatePartAttribute(IMetadataCustomAttribute attribute, IPartCatalogueFactory typeFactory);
    private static object ExpandMetadataValue(MetadataAttributeValue metavalue);
    private static ICollection`1<PartCatalogueAttribute> CreateAttributes(IMetadataEntity entity, IPartCatalogueFactory typeFactory);
    private static ICollection`1<PartCatalogueAttribute> CreateAttributes(ICustomAttributeProvider attrowner, IPartCatalogueFactory typeFactory);
    public static bool IsAttributeOfType(PartCatalogueAttribute attribute, Type attributeType);
    public static bool IsAttributeOfType(PartCatalogAttribute attribute, Type attributeType);
    [ObsoleteAttribute("As it has a lifetime, you can always create the resolvers beforehand.")]
public static CombiningAssemblyResolver CreateFileResolver(Lifetime lifetime, IEnumerable`1<FileSystemPath> assembliesCurrent, Func`2<Lifetime, IAssemblyResolver> FCreateAdditionalResolvers, OnError resolveerrors, Nullable`1<GacResolvePreferences> gacpreferences);
    public static CombiningAssemblyResolver CreateFileResolver(Lifetime lifetime, IEnumerable`1<FileSystemPath> assembliesCurrent, IAssemblyResolver customresolver, OnError resolveerrors, Nullable`1<GacResolvePreferences> gacpreferences);
    public static CombiningAssemblyResolver CreateStreamResolver(Lifetime lifetime, IDictionary`2<AssemblyNameInfo, Func`2<Lifetime, Stream>> assembliesCurrent, Func`2<Lifetime, IAssemblyResolver> FCreateAdditionalResolvers, OnError resolveerrors, Nullable`1<GacResolvePreferences> gacpreferences);
    [CompilerGeneratedAttribute]
private static FileSystemPath <CreateFileResolver>b__1(FileSystemPath path);
    [CompilerGeneratedAttribute]
private static bool <.cctor>b__10(MemberInfo param0, object param1);
}
public class JetBrains.Application.Parts.PartsCatalogue : UserDataHolder {
    private IList`1<PartCatalogueAssembly> myAssemblies;
    private IList`1<PartCatalogueType> myParts;
    public PartsCatalogue(IList`1<PartCatalogueType> parts, IList`1<PartCatalogueAssembly> assemblies);
    public virtual string ToString();
    private sealed virtual override IEnumerable`1<PartCatalogueAssembly> JetBrains.Application.Parts.IPartsCatalogue.GetAssemblies();
    private sealed virtual override IEnumerable`1<PartCatalogueType> JetBrains.Application.Parts.IPartsCatalogue.GetParts();
}
public static class JetBrains.Application.Parts.PartsCatalogueMetadataKeys : object {
    public static Key`1<object> SingleAndNotLiveComposition;
    private static PartsCatalogueMetadataKeys();
}
public static class JetBrains.Application.Parts.PartsCatalogues : object {
    private static IMetadataPartsPassFilter DefaultMetadataPartsPassFilter;
    private static ILogger Logger;
    [CompilerGeneratedAttribute]
private static Func`2<Assembly, IEnumerable`1<Type>> CS$<>9__CachedAnonymousMethodDelegate3;
    [CompilerGeneratedAttribute]
private static Func`2<PartCatalogueType, string> CS$<>9__CachedAnonymousMethodDelegated;
    [CompilerGeneratedAttribute]
private static Func`2<Stream, AssemblyNameInfo> CS$<>9__CachedAnonymousMethodDelegate2a;
    [CompilerGeneratedAttribute]
private static Func`2<Stream, Func`2<Lifetime, Stream>> CS$<>9__CachedAnonymousMethodDelegate2b;
    private static PartsCatalogues();
    [NotNullAttribute]
public static IPartsCatalogue Create(IList`1<PartCatalogueType> parts, IList`1<PartCatalogueAssembly> assemblies);
    [NotNullAttribute]
public static IPartsCatalogue CreateFromRuntimeAssemblies(IEnumerable`1<Assembly> assemblies, IPartCatalogueFactory typeFactory, RuntimePartsPassFilter filter);
    [NotNullAttribute]
public static IPartsCatalogue CreateFromRuntimeAssembly(Assembly assembly, IPartCatalogueFactory typeFactory, RuntimePartsPassFilter filter);
    [NotNullAttribute]
public static IPartsCatalogue CreateFromRuntimeTypes(IEnumerable`1<Type> types);
    [NotNullAttribute]
public static IPartsCatalogue CreateFromRuntimeTypes(Type[] types);
    [NotNullAttribute]
public static IPartsCatalogue CreateWithMetadataReader(IEnumerable`1<AssemblyNameInfo> assemblies, IAssemblyMasterBinder masterbinder, IPartCatalogueFactory typeFactory, IMetadataPartsPassFilter filter);
    [NotNullAttribute]
public static IPartsCatalogue CreateWithMetadataReaderFromAssemblyFiles(IList`1<FileSystemPath> assemblyLocations, IPartCatalogueFactory typeFactory, Func`2<Lifetime, IAssemblyResolver> FCreateAdditionalResolvers, IMetadataPartsPassFilter filter);
    [NotNullAttribute]
public static IPartsCatalogue CreateWithMetadataReaderFromAssemblyFiles(IList`1<FileSystemPath> assemblyLocations, IList`1<FileSystemPath> filesAdditionalAssemblyReferences, IPartCatalogueFactory typeFactory, Func`2<Lifetime, IAssemblyResolver> FCreateAdditionalResolvers, IMetadataPartsPassFilter filter);
    [NotNullAttribute]
public static IPartsCatalogue CreateWithMetadataReaderFromAssemblyStreams(ICollection`1<Stream> assemblies, IPartCatalogueFactory typeFactory, Func`2<Lifetime, IAssemblyResolver> FCreateAdditionalResolvers, IMetadataPartsPassFilter filter);
    [ObsoleteAttribute("Should use the overload with master binder.")]
[NotNullAttribute]
public static IPartsCatalogue CreateWithMetadataReaderFromAssemblyStreams(IEnumerable`1<AssemblyNameInfo> assemblies, IDictionary`2<AssemblyNameInfo, Func`2<Lifetime, Stream>> mapResolver, IPartCatalogueFactory typeFactory, Func`2<Lifetime, IAssemblyResolver> FCreateAdditionalResolvers, IMetadataPartsPassFilter filter);
    [NotNullAttribute]
public static IPartsCatalogue CreateWithReflectionFromAssemblyFiles(IList`1<FileSystemPath> assemblyLocations, IPartCatalogueFactory typeFactory);
    private static void CheckLoadedAssemblyName(PartCatalogueAssembly partassembly, AssemblyNameInfo assname);
    [CompilerGeneratedAttribute]
private static IEnumerable`1<Type> <CreateFromRuntimeAssemblies>b__0(Assembly assembly);
    [CompilerGeneratedAttribute]
private static string <CreateFromRuntimeTypes>b__c(PartCatalogueType type);
    [CompilerGeneratedAttribute]
private static AssemblyNameInfo <CreateWithMetadataReaderFromAssemblyStreams>b__27(Stream stream);
    [CompilerGeneratedAttribute]
private static Func`2<Lifetime, Stream> <CreateWithMetadataReaderFromAssemblyStreams>b__28(Stream stream);
}
public static class JetBrains.Application.Parts.PartsCatalogueSerializer : object {
    public static void SerializeCatalogue(IPartsCatalogue partsCatalogue, Stream stream);
    [NotNullAttribute]
public static IPartsCatalogue ReadCatalogue(Stream stream);
}
public class JetBrains.Application.Parts.PartsCatalogueSet : object {
    private CollectionEvents`1<IPartsCatalogue> myCatalogues;
    private CollectionEvents`1<IPartsCatalogue> myCataloguesPreview;
    public IViewable`1<IPartsCatalogue> CataloguesPreview { get; }
    public IViewable`1<IPartsCatalogue> Catalogues { get; }
    public PartsCatalogueSet(Lifetime lifetime);
    public void Add(IPartsCatalogue[] catalogues);
    public void Add(Lifetime lifetime, IPartsCatalogue[] catalogues);
    public void Remove(IPartsCatalogue[] catalogues);
    public void AddCatalogues(IEnumerable`1<IPartsCatalogue> catalogues);
    public void RemoveCatalogues(IEnumerable`1<IPartsCatalogue> catalogues);
    public sealed virtual IViewable`1<IPartsCatalogue> get_CataloguesPreview();
    public sealed virtual IViewable`1<IPartsCatalogue> get_Catalogues();
    public sealed virtual IEnumerator`1<IPartsCatalogue> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public static class JetBrains.Application.Parts.PartsSelector : object {
    public static IPartsSelector Default;
    public static IPartsSelector Leafs;
    public static IPartsSelector LeafsAndHides;
    public static IPartsSelector All;
    private static PartsSelector();
}
[ObsoleteAttribute("Use factory methods in PartsCatalogues and the base IPartsCatalogue interface.")]
public static class JetBrains.Application.Parts.ReflectionPartsCatalogue : object {
}
public class JetBrains.Application.Parts.RuntimeBasedAssemblyBinder : object {
    [NotNullAttribute]
public Assembly Assembly;
    private AssemblyNameInfo JetBrains.Application.Bindings.IAssemblyBinder.AssemblyName { get; }
    public RuntimeBasedAssemblyBinder(Assembly assembly);
    private sealed virtual override AssemblyNameInfo JetBrains.Application.Bindings.IAssemblyBinder.get_AssemblyName();
    private sealed virtual override IMetadataAssembly JetBrains.Application.Bindings.IAssemblyBinder.BindToMetadataAssembly(Lifetime lifetime, OnError onerror);
    private sealed virtual override Assembly JetBrains.Application.Bindings.IAssemblyBinder.BindToRuntimeAssembly(OnError onerror);
    private sealed virtual override Stream JetBrains.Application.Bindings.IAssemblyBinder.BindToStream(Lifetime lifetime, OnError onerror);
    private sealed virtual override FileSystemPath JetBrains.Application.Bindings.IAssemblyBinder.BindToDiskPath(OnError onerror);
}
[ObsoleteAttribute("Use factory methods in PartsCatalogues and the base IPartsCatalogue interface.")]
public static class JetBrains.Application.Parts.SerializedCatalogue : object {
}
public static class JetBrains.Application.Parts.SerializedCatalogueConstants : object {
    public static UInt32 VERSION;
}
public enum JetBrains.Application.Parts.SerializedCatalogueEntryKind : Enum {
    public int value__;
    public static SerializedCatalogueEntryKind Eof;
    public static SerializedCatalogueEntryKind Assembly;
    public static SerializedCatalogueEntryKind TypeDeclaration;
    public static SerializedCatalogueEntryKind TypeRecursiveMembers;
    public static SerializedCatalogueEntryKind Attribute;
    public static SerializedCatalogueEntryKind Member;
    public static SerializedCatalogueEntryKind Constructor;
    public static SerializedCatalogueEntryKind Catalogue;
    public static SerializedCatalogueEntryKind AssemblyAttributes;
}
public class JetBrains.Application.Parts.SerializedCatalogueReader : object {
    private BinaryReader myReader;
    private List`1<PartCatalogueAssembly> myAssemblies;
    private List`1<PartCatalogueType> myTypes;
    private List`1<PartCatalogueAttribute> myAttributes;
    private List`1<PartCatalogueTypeMember> myMembers;
    private DataIntern`1<string> myStrings;
    private IPartsCatalogue myCatalogue;
    public SerializedCatalogueReader(BinaryReader reader);
    [NotNullAttribute]
public IPartsCatalogue ReadCatalogueFile();
    private void ReadCatalogue();
    private void ReadAssemblyAttributes();
    private void ReadMember();
    private void ReadAttribute();
    private void ReadTypeDeclaration();
    private void ReadTypeRecursiveMembers();
    public IList`1<PartCatalogueAssembly> ReadAssemblyList();
    public PartCatalogueType[] ReadTypeRefList();
    public IList`1<PartCatalogueAttributeProperty> ReadPropertyList();
    private object ReadConstant();
    private Object[] ReadArrayConstant();
    public PartCatalogueTypeMember[] ReadMembersArray();
    public PartCatalogueAttribute[] ReadAttributeArray();
    private PartCatalogueAssembly ReadAssemblyRef();
    private PartCatalogueType ReadTypeRef();
    private PartCatalogueAttribute ReadAttributeRef();
    private PartCatalogueTypeMember ReadMemberRef();
    private void ReadAssembly();
    private bool ReadHeader();
}
public class JetBrains.Application.Parts.SerializedCatalogueWriter : object {
    private static Type TypeOfPartCatalogueType;
    private UInt32 myNextAssemblyIndex;
    private UInt32 myNextTypeIndex;
    private UInt32 myNextAttributeIndex;
    private UInt32 myNextMemberIndex;
    private Dictionary`2<PartCatalogueAssembly, UInt32> myAssemblies;
    private Dictionary`2<PartCatalogueType, UInt32> myTypes;
    private Dictionary`2<PartCatalogueAttribute, UInt32> myAttributes;
    private Dictionary`2<PartCatalogueTypeMember, UInt32> myMembers;
    private BinaryWriter myWriter;
    public SerializedCatalogueWriter(BinaryWriter writer);
    private static SerializedCatalogueWriter();
    public void WriteHeader();
    public void WriteEntryKind(SerializedCatalogueEntryKind entryKind);
    public void WriteTypeRef(PartCatalogueType type);
    public void WriteAttributeRef(PartCatalogueAttribute attribute);
    public void WriteMemberRef(PartCatalogueTypeMember member);
    public void WriteAssemblyRef(PartCatalogueAssembly assembly);
    public void WriteAssembly(PartCatalogueAssembly assembly);
    public void WriteAssemblyAttributes(PartCatalogueAssembly assembly);
    private void WriteAttribute(PartCatalogueAttribute attribute);
    private void WriteMember(PartCatalogueTypeMember member);
    private void SerializeTypesFromConstant(object value);
    private void WriteElementType(ElementType elementType);
    private void WriteConstant(object value);
    private void WriteArray(Object[] value);
    public void WritePartsCatalogue(IPartsCatalogue catalogue);
    public void WriteList(IEnumerable`1<T> items, Action`1<T> itemWriter);
    public void WriteEOF();
    public void SerializeType(PartCatalogueType type);
    private bool SerializeType_WriteTypeDeclarationIfNew(PartCatalogueType type);
    private void SerializeType_EnsureRecursiveStuffDeclared(PartCatalogueType type);
    private void SerializeType_WriteRecursiveStuffRefs(PartCatalogueType type);
    public void SerializePartsCatalogue(IPartsCatalogue partsCatalogue);
    private void SerializeAssemblyAttributes(PartCatalogueAssembly assembly);
    private void SerializeMember(PartCatalogueTypeMember member);
    private void SerializeAttribute(PartCatalogueAttribute attribute);
    private void SerializeAssembly(PartCatalogueAssembly assembly);
    [CompilerGeneratedAttribute]
private void <WriteAttribute>b__0(PartCatalogueAttributeProperty property);
    [CompilerGeneratedAttribute]
private void <WriteMember>b__1(PartCatalogueType parameterType);
    [CompilerGeneratedAttribute]
private void <WriteMember>b__2(PartCatalogueAttribute attribute);
}
public class JetBrains.Application.Parts.StreamBasedAssemblyBinder : object {
    [NotNullAttribute]
private AssemblyNameInfo myAssemblyNameInfo;
    [CanBeNullAttribute]
private Func`2<Lifetime, IAssemblyResolver> myFCreateAdditionalResolvers;
    [NotNullAttribute]
private Func`2<Lifetime, Stream> myFStream;
    [NotNullAttribute]
private IDictionary`2<AssemblyNameInfo, Func`2<Lifetime, Stream>> myOtherAssembliesForResolveAssemblies;
    [CompilerGeneratedAttribute]
private static Action`1<IncompleteAttributeArgs> CS$<>9__CachedAnonymousMethodDelegate4;
    private AssemblyNameInfo JetBrains.Application.Bindings.IAssemblyBinder.AssemblyName { get; }
    public StreamBasedAssemblyBinder(AssemblyNameInfo assemblyNameInfo, Func`2<Lifetime, Stream> FStream, IDictionary`2<AssemblyNameInfo, Func`2<Lifetime, Stream>> otherAssembliesForResolveAssemblies, Func`2<Lifetime, IAssemblyResolver> FCreateAdditionalResolvers);
    public IMetadataAssembly BindToMetadataAssemblyOnMyLoader(Lifetime lifetime, MetadataLoader loader);
    public static MetadataLoader CreateMetadataLoader(Lifetime lifetime, IDictionary`2<AssemblyNameInfo, Func`2<Lifetime, Stream>> otherAssembliesForResolveAssemblies, Func`2<Lifetime, IAssemblyResolver> FCreateAdditionalResolvers);
    private sealed virtual override AssemblyNameInfo JetBrains.Application.Bindings.IAssemblyBinder.get_AssemblyName();
    private sealed virtual override IMetadataAssembly JetBrains.Application.Bindings.IAssemblyBinder.BindToMetadataAssembly(Lifetime lifetime, OnError onerror);
    private sealed virtual override Assembly JetBrains.Application.Bindings.IAssemblyBinder.BindToRuntimeAssembly(OnError onerror);
    private sealed virtual override Stream JetBrains.Application.Bindings.IAssemblyBinder.BindToStream(Lifetime lifetime, OnError onerror);
    private sealed virtual override FileSystemPath JetBrains.Application.Bindings.IAssemblyBinder.BindToDiskPath(OnError onerror);
    [CompilerGeneratedAttribute]
private static void <CreateMetadataLoader>b__3(IncompleteAttributeArgs args);
    [CompilerGeneratedAttribute]
private bool <JetBrains.Application.Bindings.IAssemblyBinder.BindToRuntimeAssembly>b__5(Assembly ass);
    [CompilerGeneratedAttribute]
private Assembly <JetBrains.Application.Bindings.IAssemblyBinder.BindToRuntimeAssembly>b__6(Lifetime lifetime);
}
[ObsoleteAttribute("Use factory methods in PartsCatalogues and the base IPartsCatalogue interface.")]
public class JetBrains.Application.Parts.TypesPartsCatalogue : object {
}
public class JetBrains.Application.Table.AssemblyBinderWithMvidValidation : object {
    private IAssemblyBinder myBinderRaw;
    private Guid myMvid;
    private AssemblyNameInfo JetBrains.Application.Bindings.IAssemblyBinder.AssemblyName { get; }
    public AssemblyBinderWithMvidValidation(Guid mvid, IAssemblyBinder binderRaw);
    private sealed virtual override AssemblyNameInfo JetBrains.Application.Bindings.IAssemblyBinder.get_AssemblyName();
    private sealed virtual override FileSystemPath JetBrains.Application.Bindings.IAssemblyBinder.BindToDiskPath(OnError onerror);
    private sealed virtual override IMetadataAssembly JetBrains.Application.Bindings.IAssemblyBinder.BindToMetadataAssembly(Lifetime lifetime, OnError onerror);
    private void BindToMetadataAssembly_BadMvid(IMetadataAssembly metass);
    private sealed virtual override Assembly JetBrains.Application.Bindings.IAssemblyBinder.BindToRuntimeAssembly(OnError onerror);
    private void BindToRuntimeAssembly_BadMvid(Assembly assembly);
    private sealed virtual override Stream JetBrains.Application.Bindings.IAssemblyBinder.BindToStream(Lifetime lifetime, OnError onerror);
}
public class JetBrains.Application.Table.CatalogTables : object {
    public UInt32 CbFile;
    public CatalogTablesFileHeader* File;
    public TableHeader* HeaderAssembly;
    public TableHeader* HeaderAssemblyList;
    public TableHeader* HeaderBlob;
    public TableHeader* HeaderString;
    public TableHeader* HeaderTraitName;
    public TableHeader* HeaderType;
    public TableHeader* HeaderTypeList;
    public TableHeader* HeaderTypeTraitBank;
    public Lifetime Lifetime;
    public AssemblyRecord* TableAssembly;
    public AssemblyListRecord* TableAssemblyList;
    public AttributeRecord* TableAttribute;
    public AttributeArgumentRecord* TableAttributeArgument;
    public BlobTableHeader* TableBlob;
    public MemberRecord* TableMember;
    public Byte* TableString;
    public TraitNameRecord* TableTraitName;
    public TypeRecord* TableType;
    public TypeListRecord* TableTypeList;
    public TypeTraitBankRecord* TableTypeTraitBank;
    private CatalogTables(Lifetime lifetime, Void* pCatalogTablesFile, UInt32 cbCatalogTablesFile);
    public static CatalogTables Open(Lifetime lifetime, Void* pCatalogTablesFile, UInt32 cbCatalogTablesFile, OnError onerror);
    public static CatalogTables OpenCopiedFromStream(Lifetime lifetime, Stream stream, OnError onerror);
    private void AssertValidFast();
    private void AssertValidFast_TableNotNull(Void* pTable, string tablename);
}
public class JetBrains.Application.Table.Emit.CalculateAttributeTypeTraitsForPartCatalogTables : object {
    public static string TraitNamespace;
    private string JetBrains.Application.Table.Emit.ICalculateTraitsForPartCatalogTables.TraitNamespace { get; }
    private static CalculateAttributeTypeTraitsForPartCatalogTables();
    public static PartCatalogTrait GetAttributeTypeTraitName(Type typeAttr);
    public static PartCatalogTrait GetAttributeTypeTraitName(string sTypeFullName);
    private sealed virtual override void JetBrains.Application.Table.Emit.ICalculateTraitsForPartCatalogTables.CalculateTraits(EmitTimeTables tables, OneToSetMap`2<TypeRef, TraitNameRecord> typetraits);
    private static TraitNameRecord MakeAttributeTypeTrait(TypeRecord typeAttr, EmitTimeTables tables);
    private sealed virtual override string JetBrains.Application.Table.Emit.ICalculateTraitsForPartCatalogTables.get_TraitNamespace();
}
public static class JetBrains.Application.Table.Emit.CatalogTablesMerger : object {
    private static ILogger Logger;
    [CompilerGeneratedAttribute]
private static Func`2<AssemblyCataloged, AssemblyRef> CS$<>9__CachedAnonymousMethodDelegate1;
    private static CatalogTablesMerger();
    public static void MergeCatalogTables(CatalogTables[] olds, Stream output);
    private static AttributeArgumentRangeRef CopyArgumentRange(AttributeArgumentRangeRef oldrangeTopLevel, CatalogTables oldtables, EmitTimeTables newtables);
    private static AssemblyListRangeRef CopyAssemblyRangeShallow(AssemblyListRangeRef rangeOldAssemblies, CatalogTables oldtables, EmitTimeTables newtables, IDictionary`2<StringRef, AssemblyRef> cachePreCreatedAssemblies);
    private static AssemblyRef CopyAssemblyShallow(AssemblyRef refOldAssembly, CatalogTables oldtables, EmitTimeTables newtables, IDictionary`2<StringRef, AssemblyRef> cachePreCreatedAssemblies);
    private static AssemblyRef CopyAssemblyShallow(TableAndRef`1<AssemblyRef> refOriginalAssembly, EmitTimeTables newtables, IDictionary`2<StringRef, AssemblyRef> cachePreCreatedAssemblies);
    private static AttributeRangeRef CopyAttributeRange(AttributeRangeRef oldattrrange, CatalogTables oldtables, EmitTimeTables newtables);
    private static MemberRangeRef CopyMembersRange(MemberRangeRef oldrange, CatalogTables oldtables, EmitTimeTables newtables);
    private static StringRef CopyString(StringRef oldref, CatalogTables oldtables, EmitTimeTables newtables);
    private static TypeListRangeRef CopyTypeListShallow(TypeListRangeRef oldrange, CatalogTables oldtables, EmitTimeTables newtables, RecordsOrder order);
    private static TypeRef CopyTypeShallow(TableAndRef`1<TypeRef> refOldType, EmitTimeTables newtables);
    private static TypeRef CopyTypeShallow(TypeRef oldtyperef, CatalogTables oldtables, EmitTimeTables newtables);
    private static void FillPreCreatedShallowAssemblies_AllButPartTypes(IEnumerable`1<AssemblyCataloged> assemblies, EmitTimeTables newtables, IDictionary`2<StringRef, AssemblyRef> cachePreCreatedAssemblies);
    private static void FillPreCreatedShallowAssemblies_FlagMvidParts(IEnumerable`1<AssemblyCataloged> assemblies, EmitTimeTables newtables);
    private static void FillPreCreatedShallowPartAssemblies(List`1<AssemblyCataloged> assemblies, EmitTimeTables newtables, IDictionary`2<StringRef, AssemblyRef> cachePreCreatedAssemblies);
    private static void FillPreCreatedShallowTypes(EmitTimeTables newtables, OneToSetMap`2& mapTypeToTraitNames, IDictionary`2<StringRef, AssemblyRef> cachePreCreatedAssemblies);
    private static void FillPreCreatedShallowTypes_Traits(TypeRef refNewType, TableAndRef`1<TypeRef> refOldType, EmitTimeTables newtables, OneToSetMap`2<TypeRef, TraitNameRecord> mapTypeToTraitNames);
    private static void FillPreCreatedShallowTypes_Type(TypeRef refNewType, TableAndRef`1<TypeRef> refOldType, EmitTimeTables newtables, IDictionary`2<StringRef, AssemblyRef> cachePreCreatedAssemblies);
    private static void MergeTraitNamespaceAvailability(OneToSetMap`2<TypeRef, TraitNameRecord> mapTypeToTraitNames, EmitTimeTables newtables, CatalogTables[] olds);
    private static AssemblyCataloged PreCreateAssemblyForCataloging(TableAndRef`1<AssemblyRef> refOriginalAssembly, EmitTimeTables newtables, IDictionary`2<StringRef, AssemblyRef> cachePreCreatedAssemblies);
    [CompilerGeneratedAttribute]
private static AssemblyRef <MergeCatalogTables>b__0(AssemblyCataloged catass);
}
public static class JetBrains.Application.Table.Emit.EmitCatalogTables : object {
    private static ILogger Logger;
    [CompilerGeneratedAttribute]
private static Func`2<AssemblyRefAndInfo, AssemblyRef> CS$<>9__CachedAnonymousMethodDelegate2;
    private static EmitCatalogTables();
    public static void CreateCatalogTablesWithMetadataReader(IEnumerable`1<AssemblyNameInfo> assemblies, IAssemblyMasterBinder masterbinder, ICollection`1<ICalculateTraitsForPartCatalogTables> traitcalc, Stream output);
    [CompilerGeneratedAttribute]
private static AssemblyRef <CreateCatalogTablesWithMetadataReader>b__1(AssemblyRefAndInfo catass);
}
public static class JetBrains.Application.Table.Emit.EmitTablesFileWriter : object {
    public static void WriteCatalogTablesFile(EmitTimeTables tables, Stream output);
    public static void WritePodTable(EmitPodTable`1<TRecord> table, CatalogTablesFileWriteSession writesession);
    public static void WritePodTableRecords(IList`1<TRecord> records, CatalogTablesFileWriteSession writesession);
}
public class JetBrains.Application.Table.Emit.EmitTimeTables : object {
    public EmitPodTable`1<AssemblyRecord> TableAssembly;
    public EmitPodTable`1<AssemblyListRecord> TableAssemblyList;
    public EmitAttributeTable TableAttribute;
    public EmitPodTable`1<AttributeArgumentRecord> TableAttributeArgument;
    public EmitBlobTable TableBlob;
    public EmitPodTable`1<MemberRecord> TableMember;
    public EmitStringTable TableStrings;
    public EmitPodTable`1<TraitNameRecord> TableTraitName;
    public EmitTypeTable TableType;
    public EmitPodTable`1<TypeListRecord> TableTypeList;
    public EmitPodTable`1<TypeTraitBankRecord> TableTypeTraitBank;
}
public class JetBrains.Application.Table.Emit.EmitTimeTablesPartCatalogStorageEmulation : object {
    private EmitTimeTables Tables;
    public EmitTimeTablesPartCatalogStorageEmulation(EmitTimeTables tables);
    public sealed virtual StringSource AssemblyGetSimpleName(Int32`1<CatalogAssemblyToken> token);
    public sealed virtual object AttributeArgumentGetBoxedValue(Int32`1<CatalogAttributeArgumentToken> token);
    public sealed virtual ulong AttributeArgumentGetPrimitiveValue(Int32`1<CatalogAttributeArgumentToken> token, Nullable`1<AttributeArgumentValueElementType> typeExpected);
    public sealed virtual StringSource AttributeArgumentGetStringValue(Int32`1<CatalogAttributeArgumentToken> token);
    public sealed virtual PartCatalogType AttributeArgumentGetTypeValue(Int32`1<CatalogAttributeArgumentToken> token);
    public sealed virtual AttributeArgumentValueElementType AttributeArgumentGetValueElementType(Int32`1<CatalogAttributeArgumentToken> token);
    public sealed virtual Nullable`1<PartCatalogAttributeArgument> AttributeTryGetArgumentByName(Int32`1<CatalogAttributeToken> token, string name);
    public TypeRef GetTypeRef(PartCatalogType type);
    private sealed virtual override IPartCatalogStorage JetBrains.Application.Catalogs.IPartCatalogStorage.ApplyFilter(IPartCatalogFilter filter);
    private sealed virtual override IAssemblyBinder JetBrains.Application.Catalogs.IPartCatalogStorage.AssemblyGetBinder(Int32`1<CatalogAssemblyToken> token);
    private sealed virtual override StringSource JetBrains.Application.Catalogs.IPartCatalogStorage.AssemblyGetFullName(Int32`1<CatalogAssemblyToken> token);
    private sealed virtual override int JetBrains.Application.Catalogs.IPartCatalogStorage.AssemblyGetHashCode(Int32`1<CatalogAssemblyToken> token);
    private sealed virtual override AssemblyNameInfo JetBrains.Application.Catalogs.IPartCatalogStorage.AssemblyGetNameInfo(Int32`1<CatalogAssemblyToken> token);
    private sealed virtual override CollectionSource`1<PartCatalogAttribute> JetBrains.Application.Catalogs.IPartCatalogStorage.AssemblyGetPartAttributes(Int32`1<CatalogAssemblyToken> token, Type typeFilter);
    private sealed virtual override CollectionSource`1<PartCatalogType> JetBrains.Application.Catalogs.IPartCatalogStorage.AssemblyGetPartTypes(Int32`1<CatalogAssemblyToken> token);
    private sealed virtual override CollectionSource`1<PartCatalogAssembly> JetBrains.Application.Catalogs.IPartCatalogStorage.AssemblyGetReferencedAssemblies(Int32`1<CatalogAssemblyToken> token);
    private sealed virtual override bool JetBrains.Application.Catalogs.IPartCatalogStorage.AssemblyIsCataloged(Int32`1<CatalogAssemblyToken> token);
    private sealed virtual override PartCatalogAttributeArgumentDisposition JetBrains.Application.Catalogs.IPartCatalogStorage.AttributeArgumentGetDisposition(Int32`1<CatalogAttributeArgumentToken> token);
    private sealed virtual override StringSource JetBrains.Application.Catalogs.IPartCatalogStorage.AttributeArgumentGetName(Int32`1<CatalogAttributeArgumentToken> token);
    private sealed virtual override CollectionSource`1<PartCatalogAttributeArgument> JetBrains.Application.Catalogs.IPartCatalogStorage.AttributeGetArguments(Int32`1<CatalogAttributeToken> token);
    private sealed virtual override object JetBrains.Application.Catalogs.IPartCatalogStorage.AttributeGetInstance(Int32`1<CatalogAttributeToken> token, OnError onerror);
    private sealed virtual override PartCatalogType JetBrains.Application.Catalogs.IPartCatalogStorage.AttributeGetType(Int32`1<CatalogAttributeToken> token);
    private sealed virtual override Nullable`1<CollectionSource`1<PartCatalogType>> JetBrains.Application.Catalogs.IPartCatalogStorage.AttributeTryGetConstructorFormalParameterTypes(Int32`1<CatalogAttributeToken> token);
    private CollectionSource`1<PartCatalogAttribute> GetAttributesCore(AttributeRangeRef range, Type typeFilter);
    [NotNullAttribute]
private string GetString(StringRef sref);
    private sealed virtual override StringSource JetBrains.Application.Catalogs.IPartCatalogStorage.GetTypeLocalName(Int32`1<CatalogTypeToken> token);
    private sealed virtual override CollectionSource`1<PartCatalogType> JetBrains.Application.Catalogs.IPartCatalogStorage.GlobalGetAllPartTypes();
    [NotNullAttribute]
private IEnumerable`1<PartCatalogType> GlobalGetAllPartTypesEnum();
    private sealed virtual override CollectionSource`1<PartCatalogAssembly> JetBrains.Application.Catalogs.IPartCatalogStorage.GlobalGetCatalogedAssemblies();
    private sealed virtual override MemberInfo JetBrains.Application.Catalogs.IPartCatalogStorage.MemberBind(Int32`1<CatalogMemberToken> token);
    private sealed virtual override PartCatalogType JetBrains.Application.Catalogs.IPartCatalogStorage.MemberGetDeclaringType(Int32`1<CatalogMemberToken> token);
    private sealed virtual override int JetBrains.Application.Catalogs.IPartCatalogStorage.MemberGetHashCode(Int32`1<CatalogMemberToken> token);
    private sealed virtual override PartCatalogTypeMemberKind JetBrains.Application.Catalogs.IPartCatalogStorage.MemberGetKind(Int32`1<CatalogMemberToken> token);
    private sealed virtual override StringSource JetBrains.Application.Catalogs.IPartCatalogStorage.MemberGetName(Int32`1<CatalogMemberToken> token);
    private sealed virtual override CollectionSource`1<PartCatalogType> JetBrains.Application.Catalogs.IPartCatalogStorage.MemberGetParameterTypes(Int32`1<CatalogMemberToken> token);
    private sealed virtual override CollectionSource`1<PartCatalogAttribute> JetBrains.Application.Catalogs.IPartCatalogStorage.MemberGetPartAttributes(Int32`1<CatalogMemberToken> token, Type typeFilter);
    private sealed virtual override PartCatalogType JetBrains.Application.Catalogs.IPartCatalogStorage.MemberGetValueType(Int32`1<CatalogMemberToken> token);
    [NotNullAttribute]
private static IEnumerable`1<int> RangeToEnumerableSlow(IRecordRangeRef rangeable);
    private sealed virtual override Type JetBrains.Application.Catalogs.IPartCatalogStorage.TypeBind(Int32`1<CatalogTypeToken> token);
    private sealed virtual override bool JetBrains.Application.Catalogs.IPartCatalogStorage.TypeEqualsRuntimeType(Int32`1<CatalogTypeToken> token, Type typeRuntime);
    private sealed virtual override PartCatalogAssembly JetBrains.Application.Catalogs.IPartCatalogStorage.TypeGetAssembly(Int32`1<CatalogTypeToken> token);
    private sealed virtual override StringSource JetBrains.Application.Catalogs.IPartCatalogStorage.TypeGetAssemblyQualifiedName(Int32`1<CatalogTypeToken> token);
    private sealed virtual override CollectionSource`1<PartCatalogType> JetBrains.Application.Catalogs.IPartCatalogStorage.TypeGetBaseTypes(Int32`1<CatalogTypeToken> token);
    private sealed virtual override CollectionSource`1<PartCatalogType> JetBrains.Application.Catalogs.IPartCatalogStorage.TypeGetExtraTypes(Int32`1<CatalogTypeToken> token);
    private sealed virtual override StringSource JetBrains.Application.Catalogs.IPartCatalogStorage.TypeGetFullName(Int32`1<CatalogTypeToken> token);
    private sealed virtual override int JetBrains.Application.Catalogs.IPartCatalogStorage.TypeGetHashCode(Int32`1<CatalogTypeToken> token);
    private sealed virtual override PartCatalogTypeKind JetBrains.Application.Catalogs.IPartCatalogStorage.TypeGetKind(Int32`1<CatalogTypeToken> token);
    private sealed virtual override CollectionSource`1<PartCatalogAttribute> JetBrains.Application.Catalogs.IPartCatalogStorage.TypeGetPartAttributes(Int32`1<CatalogTypeToken> token, Type typeFilter);
    private sealed virtual override CollectionSource`1<PartCatalogTypeMember> JetBrains.Application.Catalogs.IPartCatalogStorage.TypeGetPartMembers(Int32`1<CatalogTypeToken> token);
    private sealed virtual override Type JetBrains.Application.Catalogs.IPartCatalogStorage.TypeTryGetBoundType(Int32`1<CatalogTypeToken> token);
    [CompilerGeneratedAttribute]
private PartCatalogType <JetBrains.Application.Catalogs.IPartCatalogStorage.AssemblyGetPartTypes>b__0(int index);
    [CompilerGeneratedAttribute]
private PartCatalogAssembly <JetBrains.Application.Catalogs.IPartCatalogStorage.AssemblyGetReferencedAssemblies>b__1(int index);
    [CompilerGeneratedAttribute]
private PartCatalogAttributeArgument <JetBrains.Application.Catalogs.IPartCatalogStorage.AttributeGetArguments>b__2(int index);
    [CompilerGeneratedAttribute]
private PartCatalogType <JetBrains.Application.Catalogs.IPartCatalogStorage.AttributeTryGetConstructorFormalParameterTypes>b__3(int index);
    [CompilerGeneratedAttribute]
private PartCatalogAttribute <GetAttributesCore>b__4(int index);
    [CompilerGeneratedAttribute]
private PartCatalogAssembly <JetBrains.Application.Catalogs.IPartCatalogStorage.GlobalGetCatalogedAssemblies>b__12(int index);
    [CompilerGeneratedAttribute]
private PartCatalogType <JetBrains.Application.Catalogs.IPartCatalogStorage.MemberGetParameterTypes>b__13(int index);
    [CompilerGeneratedAttribute]
private PartCatalogType <JetBrains.Application.Catalogs.IPartCatalogStorage.TypeGetBaseTypes>b__14(int index);
    [CompilerGeneratedAttribute]
private PartCatalogType <JetBrains.Application.Catalogs.IPartCatalogStorage.TypeGetExtraTypes>b__15(int index);
    [CompilerGeneratedAttribute]
private PartCatalogTypeMember <JetBrains.Application.Catalogs.IPartCatalogStorage.TypeGetPartMembers>b__16(int index);
}
public interface JetBrains.Application.Table.Emit.ICalculateTraitsForPartCatalogTables {
    [NotNullAttribute]
public string TraitNamespace { get; }
    public abstract virtual string get_TraitNamespace();
    public abstract virtual void CalculateTraits(EmitTimeTables tables, OneToSetMap`2<TypeRef, TraitNameRecord> typetraits);
}
public enum JetBrains.Application.Table.Emit.RecordsOrder : Enum {
    public int value__;
    public static RecordsOrder Keep;
    public static RecordsOrder CanSort;
}
public static class JetBrains.Application.Table.Emit.TraitsInCatalogTables : object {
    public static string SupportedTraitNamespacesNamespace;
    [CompilerGeneratedAttribute]
private static Func`2<ICalculateTraitsForPartCatalogTables, string> CS$<>9__CachedAnonymousMethodDelegate1;
    private static TraitsInCatalogTables();
    public static void CalculateTraits(EmitTimeTables tables, ICollection`1<ICalculateTraitsForPartCatalogTables> calculators);
    public static TraitNameRecord CreateTraitNameRecord(PartCatalogTrait trait, EmitTimeTables tables);
    public static void WriteTraits(EmitTimeTables tables, OneToSetMap`2<TypeRef, TraitNameRecord> typetraits);
    private static void RegisterTraitNamespace(string sTraitNamespace, OneToSetMap`2<TypeRef, TraitNameRecord> typetraits, EmitTimeTables tables);
    [CompilerGeneratedAttribute]
private static string <CalculateTraits>b__0(ICalculateTraitsForPartCatalogTables calc);
}
public static class JetBrains.Application.Table.PrintCatalogTables : object {
    public static ILogger Logger;
    private static string StyleHeader;
    private static string StyleHyperlink;
    public static string XmlnsExcel;
    public static string XmlnsSpreadsheet;
    [CompilerGeneratedAttribute]
private static Func`2<KeyValuePair`2<string, TableHeader>, string> CS$<>9__CachedAnonymousMethodDelegatec;
    [CompilerGeneratedAttribute]
private static Func`2<KeyValuePair`2<string, TableHeader>, TableHeader> CS$<>9__CachedAnonymousMethodDelegated;
    [CompilerGeneratedAttribute]
private static Func`2<TableHeader, bool> CS$<>9__CachedAnonymousMethodDelegatee;
    [CompilerGeneratedAttribute]
private static Func`2<PodRecordRef, string> CS$<>9__CachedAnonymousMethodDelegate20;
    [CompilerGeneratedAttribute]
private static Func`2<FieldInfo, string> CS$<>9__CachedAnonymousMethodDelegate29;
    [CompilerGeneratedAttribute]
private static Func`2<FieldInfo, bool> CS$<>9__CachedAnonymousMethodDelegate41;
    [CompilerGeneratedAttribute]
private static Func`2<FieldInfo, int> CS$<>9__CachedAnonymousMethodDelegate42;
    private static PrintCatalogTables();
    public static SimpleFileItem Render(CatalogTables tables);
    private static void CollectBackreferences(StringTable stringtable, IList`1<PodTable> podtables);
    private static Dictionary`2<string, TableHeader> CreateTablesMap(CatalogTables tables);
    [NotNullAttribute]
private static string FormatHyperlink(string sTableName, TextRange columns, int indexFirst, Nullable`1<int> maybeLastIndex);
    private static StringTable LoadStringTable(CatalogTables tables, Dictionary`2<string, TableHeader> mapTablesByName);
    private static void RenderIncomingReferencesCell(IList`1<PodRecordRef> froms, XmlWriter writer);
    private static void RenderPodTable(PodTable table, XmlWriter writer, StringTable stringtable, IList`1<PodTable> podtables);
    private static void RenderStringTable(StringTable stringtable, XmlWriter writer);
    [CanBeNullAttribute]
private static PodTable TryLoadPodTable(TableHeader tr, CatalogTables tables);
    [CanBeNullAttribute]
private static PodRecord[] TryResolveRecordRangeReference(IRecordRangeRef rrref, StringTable stringtable, IList`1<PodTable> podtables);
    [CanBeNullAttribute]
private static PodRecord TryResolveRecordReference(IRecordRef recordref, StringTable stringtable, IList`1<PodTable> podtables);
    private static void UpdateDisplayNames(StringTable stringtable, IList`1<PodTable> podtables);
    [CompilerGeneratedAttribute]
private static string <Render>b__0(KeyValuePair`2<string, TableHeader> pair);
    [CompilerGeneratedAttribute]
private static TableHeader <Render>b__1(KeyValuePair`2<string, TableHeader> pair);
    [CompilerGeneratedAttribute]
private static bool <Render>b__2(TableHeader table);
    [CompilerGeneratedAttribute]
private static string <RenderIncomingReferencesCell>b__1f(PodRecordRef from);
    [CompilerGeneratedAttribute]
private static string <RenderPodTable>b__25(FieldInfo f);
    [CompilerGeneratedAttribute]
private static bool <UpdateDisplayNames>b__3f(FieldInfo f);
    [CompilerGeneratedAttribute]
private static int <UpdateDisplayNames>b__40(FieldInfo f);
}
[NoReorderAttribute]
public class JetBrains.Application.Table.Record.AssemblyListRecord : ValueType {
    public AssemblyRef Item;
    public static string CatalogedAssembliesListRangeBlobName;
    private ARef JetBrains.Application.Table.Record.Ref.IRecordRef.Ref { get; }
    private Type JetBrains.Application.Table.Record.Ref.IRecordRef.TargetRecordType { get; }
    private static AssemblyListRecord();
    private sealed virtual override ARef JetBrains.Application.Table.Record.Ref.IRecordRef.get_Ref();
    private sealed virtual override Type JetBrains.Application.Table.Record.Ref.IRecordRef.get_TargetRecordType();
    public virtual string ToString();
    public sealed virtual bool Equals(AssemblyListRecord other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(AssemblyListRecord left, AssemblyListRecord right);
    public static bool op_Inequality(AssemblyListRecord left, AssemblyListRecord right);
    private sealed virtual override int System.IComparable<JetBrains.Application.Table.Record.AssemblyListRecord>.CompareTo(AssemblyListRecord other);
}
[NoReorderAttribute]
public class JetBrains.Application.Table.Record.AssemblyRecord : ValueType {
    public StringRef FullName;
    public AttributeRangeRef Attributes;
    public TypeListRangeRef Types;
    public AssemblyListRangeRef ReferencedAssemblies;
    public Guid Mvid;
    public AssemblyRecordFlags Flags;
    public sealed virtual bool Equals(AssemblyRecord other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(AssemblyRecord left, AssemblyRecord right);
    public static bool op_Inequality(AssemblyRecord left, AssemblyRecord right);
}
[FlagsAttribute]
public enum JetBrains.Application.Table.Record.AssemblyRecordFlags : Enum {
    public UInt32 value__;
    public static AssemblyRecordFlags IsCatalogedAssembly;
}
[NoReorderAttribute]
public class JetBrains.Application.Table.Record.AttributeArgumentRecord : ValueType {
    public StringRef Name;
    public short Disposition;
    public AttributeArgumentValueElementType ElementType;
    public StringRef StringValue;
    public TypeRef TypeValue;
    public ulong PrimitiveValue;
    public AttributeArgumentRangeRef ArrayItemsValue;
    public sealed virtual bool Equals(AttributeArgumentRecord other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(AttributeArgumentRecord left, AttributeArgumentRecord right);
    public static bool op_Inequality(AttributeArgumentRecord left, AttributeArgumentRecord right);
    private sealed virtual override int System.IComparable<JetBrains.Application.Table.Record.AttributeArgumentRecord>.CompareTo(AttributeArgumentRecord other);
}
public enum JetBrains.Application.Table.Record.AttributeArgumentValueElementType : Enum {
    public ushort value__;
    public static AttributeArgumentValueElementType Null;
    public static AttributeArgumentValueElementType Bool;
    public static AttributeArgumentValueElementType Char;
    public static AttributeArgumentValueElementType I1;
    public static AttributeArgumentValueElementType U1;
    public static AttributeArgumentValueElementType I2;
    public static AttributeArgumentValueElementType U2;
    public static AttributeArgumentValueElementType I4;
    public static AttributeArgumentValueElementType U4;
    public static AttributeArgumentValueElementType I8;
    public static AttributeArgumentValueElementType U8;
    public static AttributeArgumentValueElementType R4;
    public static AttributeArgumentValueElementType R8;
    public static AttributeArgumentValueElementType String;
    public static AttributeArgumentValueElementType Type;
    public static AttributeArgumentValueElementType SzArray;
}
[NoReorderAttribute]
public class JetBrains.Application.Table.Record.AttributeRecord : ValueType {
    public TypeRef DeclaringType;
    public TypeListRangeRef ConstructorFormalParameterTypes;
    public AttributeArgumentRangeRef Arguments;
    public sealed virtual bool Equals(AttributeRecord other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(AttributeRecord left, AttributeRecord right);
    public static bool op_Inequality(AttributeRecord left, AttributeRecord right);
    private sealed virtual override int System.IComparable<JetBrains.Application.Table.Record.AttributeRecord>.CompareTo(AttributeRecord other);
}
public class JetBrains.Application.Table.Record.Bitmask64 : ValueType {
    public ulong Value;
    public Bitmask64(ulong value);
    public sealed virtual bool Equals(Bitmask64 other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(Bitmask64 left, Bitmask64 right);
    public static ulong op_Implicit(Bitmask64 value);
    public static Bitmask64 op_Implicit(ulong value);
    public static bool op_Inequality(Bitmask64 left, Bitmask64 right);
    public static bool op_GreaterThan(Bitmask64 left, Bitmask64 right);
    public static bool op_LessThan(Bitmask64 left, Bitmask64 right);
    public virtual string ToString();
    private sealed virtual override int System.IComparable<JetBrains.Application.Table.Record.Bitmask64>.CompareTo(Bitmask64 other);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
}
public class JetBrains.Application.Table.Record.BlobTableHeader : ValueType {
    public ulong IndexRva;
    public byte IndexHashHighestSetBit;
}
public class JetBrains.Application.Table.Record.BlobTableIndexRecord : ValueType {
    public OWORD Identity;
    public BlobTableIndexRecordFlags Flags;
    public StringRef Note;
    public ulong BodyRva;
    public ulong BodyCbSize;
}
[FlagsAttribute]
public enum JetBrains.Application.Table.Record.BlobTableIndexRecordFlags : Enum {
    public int value__;
    public static BlobTableIndexRecordFlags IsDefined;
}
[NoReorderAttribute]
public class JetBrains.Application.Table.Record.CatalogTablesFileHeader : ValueType {
    public static int cbFormatMark;
    public static string CurrentFormatMark;
    public static Guid CurrentFormatRevision;
    [FixedBufferAttribute("System.Byte", "32")]
public <szFormatMark>e__FixedBuffer0 szFormatMark;
    public Guid FormatRevision;
    public ushort TableRefsCount;
    public TableHeader FirstTableHeader;
    private static CatalogTablesFileHeader();
    [PureAttribute]
public CatalogTablesFileHeader WithFormat();
    public static bool AssertFormat(CatalogTablesFileHeader* thіs, OnError onerror);
}
[NoReorderAttribute]
public class JetBrains.Application.Table.Record.MemberRecord : ValueType {
    public StringRef LocalName;
    public TypeRef DeclaringType;
    public AttributeRangeRef Attributes;
    public TypeRef ValueType;
    public TypeListRangeRef ParameterTypes;
    public PartCatalogTypeMemberKind Kind;
    public sealed virtual bool Equals(MemberRecord other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(MemberRecord left, MemberRecord right);
    public static bool op_Inequality(MemberRecord left, MemberRecord right);
    private sealed virtual override int System.IComparable<JetBrains.Application.Table.Record.MemberRecord>.CompareTo(MemberRecord other);
}
[NoReorderAttribute]
public class JetBrains.Application.Table.Record.RangeRef.ARangeRef : ValueType {
    public UInt32 FirstIndex;
    public ushort Count;
    public ARangeRef(int firstindex, int count);
    public RangeEnumerator GetEnumerator();
    public sealed virtual bool Equals(ARangeRef other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static bool op_Equality(ARangeRef left, ARangeRef right);
    public static bool op_Inequality(ARangeRef left, ARangeRef right);
    public static ARangeRef CreateNullIfEmpty(int firstindex, int count);
    private sealed virtual override int System.IComparable<JetBrains.Application.Table.Record.RangeRef.ARangeRef>.CompareTo(ARangeRef other);
}
public class JetBrains.Application.Table.Record.RangeRef.AssemblyListRangeRef : ValueType {
    public ARangeRef Range;
    private ARangeRef JetBrains.Application.Table.Record.RangeRef.IRecordRangeRef.Range { get; }
    public Type TargetRecordType { get; }
    public AssemblyListRangeRef(ARangeRef range);
    private sealed virtual override ARangeRef JetBrains.Application.Table.Record.RangeRef.IRecordRangeRef.get_Range();
    public sealed virtual Type get_TargetRecordType();
    public sealed virtual RangeEnumerator GetEnumerator();
    public virtual string ToString();
    public sealed virtual bool Equals(AssemblyListRangeRef other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(AssemblyListRangeRef left, AssemblyListRangeRef right);
    public static bool op_Inequality(AssemblyListRangeRef left, AssemblyListRangeRef right);
    private sealed virtual override int System.IComparable<JetBrains.Application.Table.Record.RangeRef.AssemblyListRangeRef>.CompareTo(AssemblyListRangeRef other);
}
public class JetBrains.Application.Table.Record.RangeRef.AttributeArgumentRangeRef : ValueType {
    public ARangeRef Range;
    private ARangeRef JetBrains.Application.Table.Record.RangeRef.IRecordRangeRef.Range { get; }
    public Type TargetRecordType { get; }
    public AttributeArgumentRangeRef(ARangeRef range);
    private sealed virtual override ARangeRef JetBrains.Application.Table.Record.RangeRef.IRecordRangeRef.get_Range();
    public sealed virtual Type get_TargetRecordType();
    public sealed virtual RangeEnumerator GetEnumerator();
    public virtual string ToString();
    public sealed virtual bool Equals(AttributeArgumentRangeRef other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(AttributeArgumentRangeRef left, AttributeArgumentRangeRef right);
    public static bool op_Inequality(AttributeArgumentRangeRef left, AttributeArgumentRangeRef right);
    private sealed virtual override int System.IComparable<JetBrains.Application.Table.Record.RangeRef.AttributeArgumentRangeRef>.CompareTo(AttributeArgumentRangeRef other);
}
public class JetBrains.Application.Table.Record.RangeRef.AttributeRangeRef : ValueType {
    public ARangeRef Range;
    private ARangeRef JetBrains.Application.Table.Record.RangeRef.IRecordRangeRef.Range { get; }
    public Type TargetRecordType { get; }
    public AttributeRangeRef(ARangeRef range);
    private sealed virtual override ARangeRef JetBrains.Application.Table.Record.RangeRef.IRecordRangeRef.get_Range();
    public sealed virtual Type get_TargetRecordType();
    public sealed virtual RangeEnumerator GetEnumerator();
    public virtual string ToString();
    public sealed virtual bool Equals(AttributeRangeRef other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(AttributeRangeRef left, AttributeRangeRef right);
    public static bool op_Inequality(AttributeRangeRef left, AttributeRangeRef right);
    private sealed virtual override int System.IComparable<JetBrains.Application.Table.Record.RangeRef.AttributeRangeRef>.CompareTo(AttributeRangeRef other);
}
public interface JetBrains.Application.Table.Record.RangeRef.IRecordRangeRef {
    public ARangeRef Range { get; }
    public Type TargetRecordType { get; }
    public abstract virtual ARangeRef get_Range();
    public abstract virtual Type get_TargetRecordType();
    public abstract virtual RangeEnumerator GetEnumerator();
}
public class JetBrains.Application.Table.Record.RangeRef.MemberRangeRef : ValueType {
    public ARangeRef Range;
    private ARangeRef JetBrains.Application.Table.Record.RangeRef.IRecordRangeRef.Range { get; }
    public Type TargetRecordType { get; }
    public MemberRangeRef(ARangeRef range);
    private sealed virtual override ARangeRef JetBrains.Application.Table.Record.RangeRef.IRecordRangeRef.get_Range();
    public sealed virtual Type get_TargetRecordType();
    public sealed virtual RangeEnumerator GetEnumerator();
    public virtual string ToString();
    public sealed virtual bool Equals(MemberRangeRef other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(MemberRangeRef left, MemberRangeRef right);
    public static bool op_Inequality(MemberRangeRef left, MemberRangeRef right);
    private sealed virtual override int System.IComparable<JetBrains.Application.Table.Record.RangeRef.MemberRangeRef>.CompareTo(MemberRangeRef other);
}
public class JetBrains.Application.Table.Record.RangeRef.RangeEnumerator : ValueType {
    private UInt32 myCurrent;
    private ARangeRef myRange;
    public int Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    public RangeEnumerator(ARangeRef range);
    [PureAttribute]
public sealed virtual int get_Current();
    public sealed virtual void Dispose();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
}
public class JetBrains.Application.Table.Record.RangeRef.TypeListRangeRef : ValueType {
    public ARangeRef Range;
    private ARangeRef JetBrains.Application.Table.Record.RangeRef.IRecordRangeRef.Range { get; }
    public Type TargetRecordType { get; }
    public TypeListRangeRef(ARangeRef range);
    private sealed virtual override ARangeRef JetBrains.Application.Table.Record.RangeRef.IRecordRangeRef.get_Range();
    public sealed virtual Type get_TargetRecordType();
    public sealed virtual RangeEnumerator GetEnumerator();
    public virtual string ToString();
    public sealed virtual bool Equals(TypeListRangeRef other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(TypeListRangeRef left, TypeListRangeRef right);
    public static bool op_Inequality(TypeListRangeRef left, TypeListRangeRef right);
    private sealed virtual override int System.IComparable<JetBrains.Application.Table.Record.RangeRef.TypeListRangeRef>.CompareTo(TypeListRangeRef other);
}
[NoReorderAttribute]
public class JetBrains.Application.Table.Record.Ref.ARef : ValueType {
    public UInt32 Index;
    public ARef(UInt32 index);
    public sealed virtual bool Equals(ARef other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(ARef left, ARef right);
    public static bool op_Inequality(ARef left, ARef right);
    public virtual string ToString();
    private sealed virtual override int System.IComparable<JetBrains.Application.Table.Record.Ref.ARef>.CompareTo(ARef other);
}
public class JetBrains.Application.Table.Record.Ref.AssemblyRef : ValueType {
    public ARef Ref;
    private ARef JetBrains.Application.Table.Record.Ref.IRecordRef.Ref { get; }
    private Type JetBrains.Application.Table.Record.Ref.IRecordRef.TargetRecordType { get; }
    public AssemblyRef(UInt32 index);
    public AssemblyRef(ARef aref);
    private sealed virtual override ARef JetBrains.Application.Table.Record.Ref.IRecordRef.get_Ref();
    private sealed virtual override Type JetBrains.Application.Table.Record.Ref.IRecordRef.get_TargetRecordType();
    public virtual string ToString();
    public sealed virtual bool Equals(AssemblyRef other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(AssemblyRef left, AssemblyRef right);
    public static bool op_Inequality(AssemblyRef left, AssemblyRef right);
    private sealed virtual override int System.IComparable<JetBrains.Application.Table.Record.Ref.AssemblyRef>.CompareTo(AssemblyRef other);
}
public class JetBrains.Application.Table.Record.Ref.AttributeArgumentRef : ValueType {
    public ARef Ref;
    private ARef JetBrains.Application.Table.Record.Ref.IRecordRef.Ref { get; }
    private Type JetBrains.Application.Table.Record.Ref.IRecordRef.TargetRecordType { get; }
    public AttributeArgumentRef(UInt32 index);
    private sealed virtual override ARef JetBrains.Application.Table.Record.Ref.IRecordRef.get_Ref();
    private sealed virtual override Type JetBrains.Application.Table.Record.Ref.IRecordRef.get_TargetRecordType();
    public virtual string ToString();
    public sealed virtual bool Equals(AttributeArgumentRef other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(AttributeArgumentRef left, AttributeArgumentRef right);
    public static bool op_Inequality(AttributeArgumentRef left, AttributeArgumentRef right);
    private sealed virtual override int System.IComparable<JetBrains.Application.Table.Record.Ref.AttributeArgumentRef>.CompareTo(AttributeArgumentRef other);
}
public class JetBrains.Application.Table.Record.Ref.AttributeRef : ValueType {
    public ARef Ref;
    private ARef JetBrains.Application.Table.Record.Ref.IRecordRef.Ref { get; }
    private Type JetBrains.Application.Table.Record.Ref.IRecordRef.TargetRecordType { get; }
    public AttributeRef(UInt32 index);
    private sealed virtual override ARef JetBrains.Application.Table.Record.Ref.IRecordRef.get_Ref();
    private sealed virtual override Type JetBrains.Application.Table.Record.Ref.IRecordRef.get_TargetRecordType();
    public virtual string ToString();
    public sealed virtual bool Equals(AttributeRef other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(AttributeRef left, AttributeRef right);
    public static bool op_Inequality(AttributeRef left, AttributeRef right);
    private sealed virtual override int System.IComparable<JetBrains.Application.Table.Record.Ref.AttributeRef>.CompareTo(AttributeRef other);
}
public interface JetBrains.Application.Table.Record.Ref.IRecordRef {
    public ARef Ref { get; }
    public Type TargetRecordType { get; }
    public abstract virtual ARef get_Ref();
    public abstract virtual Type get_TargetRecordType();
}
public class JetBrains.Application.Table.Record.Ref.StringRef : ValueType {
    public UInt32 Rva;
    public StringRef(UInt32 rva);
    public virtual string ToString();
    public sealed virtual bool Equals(StringRef other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(StringRef left, StringRef right);
    public static bool op_Inequality(StringRef left, StringRef right);
    private sealed virtual override int System.IComparable<JetBrains.Application.Table.Record.Ref.StringRef>.CompareTo(StringRef other);
}
public class JetBrains.Application.Table.Record.Ref.TypeRef : ValueType {
    public ARef Ref;
    private ARef JetBrains.Application.Table.Record.Ref.IRecordRef.Ref { get; }
    private Type JetBrains.Application.Table.Record.Ref.IRecordRef.TargetRecordType { get; }
    public TypeRef(UInt32 index);
    private sealed virtual override ARef JetBrains.Application.Table.Record.Ref.IRecordRef.get_Ref();
    private sealed virtual override Type JetBrains.Application.Table.Record.Ref.IRecordRef.get_TargetRecordType();
    public virtual string ToString();
    public sealed virtual bool Equals(TypeRef other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(TypeRef left, TypeRef right);
    public static bool op_Inequality(TypeRef left, TypeRef right);
    private sealed virtual override int System.IComparable<JetBrains.Application.Table.Record.Ref.TypeRef>.CompareTo(TypeRef other);
}
[NoReorderAttribute]
public class JetBrains.Application.Table.Record.StringRecordHeader : ValueType {
    public OWORD Hash;
    public UInt32 CchLength;
    public UInt32 MagicBom;
    [FixedBufferAttribute("System.Char", "1")]
public <wsz>e__FixedBuffer1 wsz;
    public static UInt32 MagicBomValue;
    public StringRecordHeader(OWORD hash, UInt32 cchLength);
    public StringRecordHeader(string s);
    private static StringRecordHeader();
    public static OWORD CalculateHash(string text);
    public sealed virtual bool Equals(StringRecordHeader other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(StringRecordHeader left, StringRecordHeader right);
    public static bool op_Inequality(StringRecordHeader left, StringRecordHeader right);
}
public class JetBrains.Application.Table.Record.TableHeader : ValueType {
    public static int cchTableName;
    public static int cchPodTableRecordTypeAqn;
    public UInt32 rva;
    public UInt32 cbSize;
    [FixedBufferAttribute("System.Char", "32")]
public <wszTableName>e__FixedBuffer2 wszTableName;
    [FixedBufferAttribute("System.Char", "256")]
public <wszPodTableRecordTypeAqn>e__FixedBuffer3 wszPodTableRecordTypeAqn;
    public ushort cbPodTableRecordSize;
    public static void SetCustomTable(TableHeader* thіs, long rva, long cbSize, string name);
    public static void SetPodTable(TableHeader* thіs, long rva, long cbSize, string name, string sPodTableRecordTypeAqn, int cbPodTableRecordSize);
    public bool TableNameEquals(string candidate);
    [NotNullAttribute]
public string CreateTableNameString();
    [NotNullAttribute]
public string CreatePodTableRecordTypeAqn();
    [NotNullAttribute]
public static string GetPodTableNameFromRecordType();
    [NotNullAttribute]
public static string GetPodTableNameFromRecordType(Type type);
}
[NoReorderAttribute]
public class JetBrains.Application.Table.Record.TraitNameRecord : ValueType {
    public StringRef Namespace;
    public StringRef LocalName;
    public sealed virtual bool Equals(TraitNameRecord other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(TraitNameRecord left, TraitNameRecord right);
    public static bool op_Inequality(TraitNameRecord left, TraitNameRecord right);
    public virtual string ToString();
}
[NoReorderAttribute]
public class JetBrains.Application.Table.Record.TypeListRecord : ValueType {
    public TypeRef Item;
    public static string AllPartTypesListRangeBlobName;
    private ARef JetBrains.Application.Table.Record.Ref.IRecordRef.Ref { get; }
    private Type JetBrains.Application.Table.Record.Ref.IRecordRef.TargetRecordType { get; }
    public TypeListRecord(TypeRef item);
    private static TypeListRecord();
    public sealed virtual bool Equals(TypeListRecord other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(TypeListRecord left, TypeListRecord right);
    public static bool op_Inequality(TypeListRecord left, TypeListRecord right);
    private sealed virtual override ARef JetBrains.Application.Table.Record.Ref.IRecordRef.get_Ref();
    private sealed virtual override Type JetBrains.Application.Table.Record.Ref.IRecordRef.get_TargetRecordType();
    public virtual string ToString();
    private sealed virtual override int System.IComparable<JetBrains.Application.Table.Record.TypeListRecord>.CompareTo(TypeListRecord other);
}
[NoReorderAttribute]
public class JetBrains.Application.Table.Record.TypeRecord : ValueType {
    public StringRef FullName;
    public AssemblyRef Assembly;
    public AttributeRangeRef Attributes;
    public TypeListRangeRef BaseTypes;
    public TypeListRangeRef ExtraTypes;
    public UInt32 MetadataToken;
    public MemberRangeRef Members;
    public PartCatalogTypeKind TypeKind;
    public sealed virtual bool Equals(TypeRecord other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(TypeRecord left, TypeRecord right);
    public static bool op_Inequality(TypeRecord left, TypeRecord right);
}
[NoReorderAttribute]
public class JetBrains.Application.Table.Record.TypeTraitBankRecord : ValueType {
    public Bitmask64 Bitmask;
    public sealed virtual bool Equals(TypeTraitBankRecord other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(TypeTraitBankRecord left, TypeTraitBankRecord right);
    public static bool op_Inequality(TypeTraitBankRecord left, TypeTraitBankRecord right);
    public virtual string ToString();
}
public class JetBrains.Application.Table.TablePartCatalogCollectionSourceOwner : object {
    private Int32[] myAttributeTypeSkipList;
    [CanBeNullAttribute]
private IPartCatalogFilter myFilter;
    private FilterStatus myFilterStatus;
    [CanBeNullAttribute]
private IPartCatalogFilter myNonTraitFilter;
    private TablePartCatalogStorage myStorage;
    private TraitMaskBanksAndOperations myTraitMasks;
    [NotNullAttribute]
private CatalogTables Tables;
    private static TablePartCatalogCollectionSourceOwner();
    public TablePartCatalogCollectionSourceOwner(TablePartCatalogStorage storage, IPartCatalogFilter filter);
    public CollectionSource`1<PartCatalogAssembly> CreateAssemblies(ARangeRef range);
    public CollectionSource`1<PartCatalogAttributeArgument> CreateAttributeArguments(ARangeRef range);
    public CollectionSource`1<PartCatalogAttribute> CreateAttributes(ARangeRef range, Type typeFilter);
    public CollectionSource`1<PartCatalogTypeMember> CreateTypeMembers(ARangeRef range);
    public CollectionSource`1<PartCatalogType> CreateTypes(TypeListRangeRef range, bool isFiltering, bool isOwnTypesOnly);
    private static FilterStatus AssessFilterStatus(CatalogTables tables, IPartCatalogFilter originalfilter, IPartCatalogFilter& nontraitfilter, TraitMaskBanksAndOperations& traitmasks);
    private sealed virtual override void JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<JetBrains.Application.Catalogs.PartCatalogType>.EnumeratorDispose(Enumerator& instance);
    private sealed virtual override void JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<JetBrains.Application.Catalogs.PartCatalogTypeMember>.EnumeratorDispose(Enumerator& instance);
    private sealed virtual override void JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<JetBrains.Application.Catalogs.PartCatalogAttribute>.EnumeratorDispose(Enumerator& instance);
    private sealed virtual override void JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<JetBrains.Application.Catalogs.PartCatalogAssembly>.EnumeratorDispose(Enumerator& instance);
    private sealed virtual override void JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<JetBrains.Application.Catalogs.PartCatalogAttributeArgument>.EnumeratorDispose(Enumerator& instance);
    private sealed virtual override PartCatalogType JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<JetBrains.Application.Catalogs.PartCatalogType>.EnumeratorGetCurrent(Enumerator& instance);
    private sealed virtual override PartCatalogTypeMember JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<JetBrains.Application.Catalogs.PartCatalogTypeMember>.EnumeratorGetCurrent(Enumerator& instance);
    private sealed virtual override PartCatalogAttribute JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<JetBrains.Application.Catalogs.PartCatalogAttribute>.EnumeratorGetCurrent(Enumerator& instance);
    private sealed virtual override PartCatalogAssembly JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<JetBrains.Application.Catalogs.PartCatalogAssembly>.EnumeratorGetCurrent(Enumerator& instance);
    private sealed virtual override PartCatalogAttributeArgument JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<JetBrains.Application.Catalogs.PartCatalogAttributeArgument>.EnumeratorGetCurrent(Enumerator& instance);
    private static int EnumeratorGetValidIndex(CollectionSourcePodData& collectionSourcePodData);
    private sealed virtual override bool JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<JetBrains.Application.Catalogs.PartCatalogType>.EnumeratorMoveNext(Enumerator& instance);
    private sealed virtual override bool JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<JetBrains.Application.Catalogs.PartCatalogTypeMember>.EnumeratorMoveNext(Enumerator& instance);
    private sealed virtual override bool JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<JetBrains.Application.Catalogs.PartCatalogAttribute>.EnumeratorMoveNext(Enumerator& instance);
    private sealed virtual override bool JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<JetBrains.Application.Catalogs.PartCatalogAssembly>.EnumeratorMoveNext(Enumerator& instance);
    private sealed virtual override bool JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<JetBrains.Application.Catalogs.PartCatalogAttributeArgument>.EnumeratorMoveNext(Enumerator& instance);
    private static bool EnumeratorMoveNextSimple(CollectionSourcePodData& data);
    [NotNullAttribute]
private Int32[] GetAttributeTypeSkipList(PartCatalogType pctypeSomeAttr);
    private sealed virtual override UInt32 JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<JetBrains.Application.Catalogs.PartCatalogType>.GetCount(CollectionSource`1& instance);
    private sealed virtual override UInt32 JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<JetBrains.Application.Catalogs.PartCatalogTypeMember>.GetCount(CollectionSource`1& instance);
    private sealed virtual override UInt32 JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<JetBrains.Application.Catalogs.PartCatalogAttribute>.GetCount(CollectionSource`1& instance);
    private sealed virtual override UInt32 JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<JetBrains.Application.Catalogs.PartCatalogAssembly>.GetCount(CollectionSource`1& instance);
    private sealed virtual override UInt32 JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<JetBrains.Application.Catalogs.PartCatalogAttributeArgument>.GetCount(CollectionSource`1& instance);
    private static UInt32 GetCountSimple(CollectionSourcePodData& data);
    private sealed virtual override Enumerator<PartCatalogType> JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<JetBrains.Application.Catalogs.PartCatalogType>.GetEnumerator(CollectionSource`1& instance);
    private sealed virtual override Enumerator<PartCatalogTypeMember> JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<JetBrains.Application.Catalogs.PartCatalogTypeMember>.GetEnumerator(CollectionSource`1& instance);
    private sealed virtual override Enumerator<PartCatalogAttribute> JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<JetBrains.Application.Catalogs.PartCatalogAttribute>.GetEnumerator(CollectionSource`1& instance);
    private sealed virtual override Enumerator<PartCatalogAssembly> JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<JetBrains.Application.Catalogs.PartCatalogAssembly>.GetEnumerator(CollectionSource`1& instance);
    private sealed virtual override Enumerator<PartCatalogAttributeArgument> JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<JetBrains.Application.Catalogs.PartCatalogAttributeArgument>.GetEnumerator(CollectionSource`1& instance);
    private static CollectionSourcePodData GetEnumeratorSimple(CollectionSourcePodData& dpColl);
    private sealed virtual override bool JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<JetBrains.Application.Catalogs.PartCatalogType>.GetIsFastCount(CollectionSource`1& instance);
    private sealed virtual override bool JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<JetBrains.Application.Catalogs.PartCatalogTypeMember>.GetIsFastCount(CollectionSource`1& instance);
    private sealed virtual override bool JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<JetBrains.Application.Catalogs.PartCatalogAttribute>.GetIsFastCount(CollectionSource`1& instance);
    private sealed virtual override bool JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<JetBrains.Application.Catalogs.PartCatalogAssembly>.GetIsFastCount(CollectionSource`1& instance);
    private sealed virtual override bool JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<JetBrains.Application.Catalogs.PartCatalogAttributeArgument>.GetIsFastCount(CollectionSource`1& instance);
    private static bool IsFilteringByTypeTraits(CollectionSource`1& instance);
    private sealed virtual override PartCatalogType[] JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<JetBrains.Application.Catalogs.PartCatalogType>.ToArray(CollectionSource`1& instance);
    private sealed virtual override PartCatalogTypeMember[] JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<JetBrains.Application.Catalogs.PartCatalogTypeMember>.ToArray(CollectionSource`1& instance);
    private sealed virtual override PartCatalogAttribute[] JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<JetBrains.Application.Catalogs.PartCatalogAttribute>.ToArray(CollectionSource`1& instance);
    private sealed virtual override PartCatalogAssembly[] JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<JetBrains.Application.Catalogs.PartCatalogAssembly>.ToArray(CollectionSource`1& instance);
    private sealed virtual override PartCatalogAttributeArgument[] JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<JetBrains.Application.Catalogs.PartCatalogAttributeArgument>.ToArray(CollectionSource`1& instance);
    private sealed virtual override ICollection`1<PartCatalogType> JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<JetBrains.Application.Catalogs.PartCatalogType>.ToCollection(CollectionSource`1& instance);
    private sealed virtual override ICollection`1<PartCatalogTypeMember> JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<JetBrains.Application.Catalogs.PartCatalogTypeMember>.ToCollection(CollectionSource`1& instance);
    private sealed virtual override ICollection`1<PartCatalogAttribute> JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<JetBrains.Application.Catalogs.PartCatalogAttribute>.ToCollection(CollectionSource`1& instance);
    private sealed virtual override ICollection`1<PartCatalogAssembly> JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<JetBrains.Application.Catalogs.PartCatalogAssembly>.ToCollection(CollectionSource`1& instance);
    private sealed virtual override ICollection`1<PartCatalogAttributeArgument> JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<JetBrains.Application.Catalogs.PartCatalogAttributeArgument>.ToCollection(CollectionSource`1& instance);
    private sealed virtual override IEnumerable`1<PartCatalogType> JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<JetBrains.Application.Catalogs.PartCatalogType>.ToEnumerable(CollectionSource`1& instance);
    private sealed virtual override IEnumerable`1<PartCatalogTypeMember> JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<JetBrains.Application.Catalogs.PartCatalogTypeMember>.ToEnumerable(CollectionSource`1& instance);
    private sealed virtual override IEnumerable`1<PartCatalogAttribute> JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<JetBrains.Application.Catalogs.PartCatalogAttribute>.ToEnumerable(CollectionSource`1& instance);
    private sealed virtual override IEnumerable`1<PartCatalogAssembly> JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<JetBrains.Application.Catalogs.PartCatalogAssembly>.ToEnumerable(CollectionSource`1& instance);
    private sealed virtual override IEnumerable`1<PartCatalogAttributeArgument> JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<JetBrains.Application.Catalogs.PartCatalogAttributeArgument>.ToEnumerable(CollectionSource`1& instance);
    private sealed virtual override string JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<JetBrains.Application.Catalogs.PartCatalogType>.ToString(CollectionSource`1& instance);
    private sealed virtual override string JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<JetBrains.Application.Catalogs.PartCatalogTypeMember>.ToString(CollectionSource`1& instance);
    private sealed virtual override string JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<JetBrains.Application.Catalogs.PartCatalogAssembly>.ToString(CollectionSource`1& instance);
    private sealed virtual override string JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<JetBrains.Application.Catalogs.PartCatalogAttribute>.ToString(CollectionSource`1& instance);
    private sealed virtual override string JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<JetBrains.Application.Catalogs.PartCatalogAttributeArgument>.ToString(CollectionSource`1& instance);
}
public class JetBrains.Application.Table.TablePartCatalogGroupStorage : object {
    private static Func`2<Struct1, TablePartCatalogStorage[]> myDelegate1;
    private static Func`2<TablePartCatalogStorage, IDictionary`2<Pair`2<StringSource, StringSource>, Int32`1<CatalogTypeToken>>> myDelegate2;
    [CanBeNullAttribute]
private IDictionary`2<AssemblyNameInfo, Pair`2<PartCatalogAssembly, TablePartCatalogStorage>> myMapPrimaryAssemblyByName;
    private ConcurrentDictionary`2<TablePartCatalogStorage, IDictionary`2<Pair`2<StringSource, StringSource>, Int32`1<CatalogTypeToken>>> myMapStorageTypeNames;
    [CanBeNullAttribute]
public IPartCatalogFilter Filter;
    [NotNullAttribute]
public IAssemblyMasterBinder MasterBinder;
    public LocalLazy`2<TablePartCatalogStorage[], Struct1> Storages;
    [NotNullAttribute]
public CatalogTables[] Tables;
    [CompilerGeneratedAttribute]
private static Func`2<Struct1, TablePartCatalogStorage[]> CS$<>9__CachedAnonymousMethodDelegate17;
    [CompilerGeneratedAttribute]
private static Func`2<TablePartCatalogStorage, IDictionary`2<Pair`2<StringSource, StringSource>, Int32`1<CatalogTypeToken>>> CS$<>9__CachedAnonymousMethodDelegate18;
    public TablePartCatalogGroupStorage(CatalogTables[] tables, IPartCatalogFilter filter, IAssemblyMasterBinder masterbinder);
    private static TablePartCatalogGroupStorage();
    public sealed virtual StringSource AssemblyGetSimpleName(Int32`1<CatalogAssemblyToken> token);
    public sealed virtual CollectionSource`1<PartCatalogType> GlobalGetAllPartTypes();
    private sealed virtual override IPartCatalogStorage JetBrains.Application.Catalogs.IPartCatalogStorage.ApplyFilter(IPartCatalogFilter filter);
    private sealed virtual override IAssemblyBinder JetBrains.Application.Catalogs.IPartCatalogStorage.AssemblyGetBinder(Int32`1<CatalogAssemblyToken> token);
    private sealed virtual override StringSource JetBrains.Application.Catalogs.IPartCatalogStorage.AssemblyGetFullName(Int32`1<CatalogAssemblyToken> token);
    private sealed virtual override int JetBrains.Application.Catalogs.IPartCatalogStorage.AssemblyGetHashCode(Int32`1<CatalogAssemblyToken> token);
    private sealed virtual override AssemblyNameInfo JetBrains.Application.Catalogs.IPartCatalogStorage.AssemblyGetNameInfo(Int32`1<CatalogAssemblyToken> token);
    private sealed virtual override CollectionSource`1<PartCatalogAttribute> JetBrains.Application.Catalogs.IPartCatalogStorage.AssemblyGetPartAttributes(Int32`1<CatalogAssemblyToken> token, Type typeFilter);
    private sealed virtual override CollectionSource`1<PartCatalogType> JetBrains.Application.Catalogs.IPartCatalogStorage.AssemblyGetPartTypes(Int32`1<CatalogAssemblyToken> token);
    private sealed virtual override CollectionSource`1<PartCatalogAssembly> JetBrains.Application.Catalogs.IPartCatalogStorage.AssemblyGetReferencedAssemblies(Int32`1<CatalogAssemblyToken> token);
    private sealed virtual override bool JetBrains.Application.Catalogs.IPartCatalogStorage.AssemblyIsCataloged(Int32`1<CatalogAssemblyToken> int32);
    private sealed virtual override object JetBrains.Application.Catalogs.IPartCatalogStorage.AttributeArgumentGetBoxedValue(Int32`1<CatalogAttributeArgumentToken> token);
    private sealed virtual override PartCatalogAttributeArgumentDisposition JetBrains.Application.Catalogs.IPartCatalogStorage.AttributeArgumentGetDisposition(Int32`1<CatalogAttributeArgumentToken> token);
    private sealed virtual override StringSource JetBrains.Application.Catalogs.IPartCatalogStorage.AttributeArgumentGetName(Int32`1<CatalogAttributeArgumentToken> token);
    private sealed virtual override ulong JetBrains.Application.Catalogs.IPartCatalogStorage.AttributeArgumentGetPrimitiveValue(Int32`1<CatalogAttributeArgumentToken> token, Nullable`1<AttributeArgumentValueElementType> typeExpected);
    private sealed virtual override StringSource JetBrains.Application.Catalogs.IPartCatalogStorage.AttributeArgumentGetStringValue(Int32`1<CatalogAttributeArgumentToken> token);
    private sealed virtual override PartCatalogType JetBrains.Application.Catalogs.IPartCatalogStorage.AttributeArgumentGetTypeValue(Int32`1<CatalogAttributeArgumentToken> token);
    private sealed virtual override AttributeArgumentValueElementType JetBrains.Application.Catalogs.IPartCatalogStorage.AttributeArgumentGetValueElementType(Int32`1<CatalogAttributeArgumentToken> token);
    private sealed virtual override CollectionSource`1<PartCatalogAttributeArgument> JetBrains.Application.Catalogs.IPartCatalogStorage.AttributeGetArguments(Int32`1<CatalogAttributeToken> token);
    private sealed virtual override object JetBrains.Application.Catalogs.IPartCatalogStorage.AttributeGetInstance(Int32`1<CatalogAttributeToken> token, OnError onerror);
    private sealed virtual override PartCatalogType JetBrains.Application.Catalogs.IPartCatalogStorage.AttributeGetType(Int32`1<CatalogAttributeToken> token);
    private sealed virtual override Nullable`1<PartCatalogAttributeArgument> JetBrains.Application.Catalogs.IPartCatalogStorage.AttributeTryGetArgumentByName(Int32`1<CatalogAttributeToken> token, string name);
    private sealed virtual override Nullable`1<CollectionSource`1<PartCatalogType>> JetBrains.Application.Catalogs.IPartCatalogStorage.AttributeTryGetConstructorFormalParameterTypes(Int32`1<CatalogAttributeToken> token);
    [NotNullAttribute]
private IDictionary`2<AssemblyNameInfo, Pair`2<PartCatalogAssembly, TablePartCatalogStorage>> GetMapAssemblyToStorage();
    internal PartCatalogAssembly GetPrimaryPartCatalogAssembly(PartCatalogAssembly pcass);
    internal PartCatalogType GetPrimaryPartCatalogType(PartCatalogType pctype);
    private sealed virtual override StringSource JetBrains.Application.Catalogs.IPartCatalogStorage.GetTypeLocalName(Int32`1<CatalogTypeToken> token);
    [NotNullAttribute]
private IEnumerable`1<PartCatalogType> GlobalGetAllPartTypesEnum();
    private sealed virtual override CollectionSource`1<PartCatalogAssembly> JetBrains.Application.Catalogs.IPartCatalogStorage.GlobalGetCatalogedAssemblies();
    [NotNullAttribute]
private IEnumerable`1<PartCatalogAssembly> GlobalGetCatalogedAssembliesEnum();
    private sealed virtual override MemberInfo JetBrains.Application.Catalogs.IPartCatalogStorage.MemberBind(Int32`1<CatalogMemberToken> token);
    private sealed virtual override PartCatalogType JetBrains.Application.Catalogs.IPartCatalogStorage.MemberGetDeclaringType(Int32`1<CatalogMemberToken> token);
    private sealed virtual override int JetBrains.Application.Catalogs.IPartCatalogStorage.MemberGetHashCode(Int32`1<CatalogMemberToken> token);
    private sealed virtual override PartCatalogTypeMemberKind JetBrains.Application.Catalogs.IPartCatalogStorage.MemberGetKind(Int32`1<CatalogMemberToken> token);
    private sealed virtual override StringSource JetBrains.Application.Catalogs.IPartCatalogStorage.MemberGetName(Int32`1<CatalogMemberToken> token);
    private sealed virtual override CollectionSource`1<PartCatalogType> JetBrains.Application.Catalogs.IPartCatalogStorage.MemberGetParameterTypes(Int32`1<CatalogMemberToken> token);
    private sealed virtual override CollectionSource`1<PartCatalogAttribute> JetBrains.Application.Catalogs.IPartCatalogStorage.MemberGetPartAttributes(Int32`1<CatalogMemberToken> token, Type typeFilter);
    private sealed virtual override PartCatalogType JetBrains.Application.Catalogs.IPartCatalogStorage.MemberGetValueType(Int32`1<CatalogMemberToken> token);
    private sealed virtual override Type JetBrains.Application.Catalogs.IPartCatalogStorage.TypeBind(Int32`1<CatalogTypeToken> token);
    private sealed virtual override bool JetBrains.Application.Catalogs.IPartCatalogStorage.TypeEqualsRuntimeType(Int32`1<CatalogTypeToken> token, Type typeRuntime);
    private sealed virtual override PartCatalogAssembly JetBrains.Application.Catalogs.IPartCatalogStorage.TypeGetAssembly(Int32`1<CatalogTypeToken> token);
    private sealed virtual override StringSource JetBrains.Application.Catalogs.IPartCatalogStorage.TypeGetAssemblyQualifiedName(Int32`1<CatalogTypeToken> token);
    private sealed virtual override CollectionSource`1<PartCatalogType> JetBrains.Application.Catalogs.IPartCatalogStorage.TypeGetBaseTypes(Int32`1<CatalogTypeToken> token);
    private sealed virtual override CollectionSource`1<PartCatalogType> JetBrains.Application.Catalogs.IPartCatalogStorage.TypeGetExtraTypes(Int32`1<CatalogTypeToken> token);
    private sealed virtual override StringSource JetBrains.Application.Catalogs.IPartCatalogStorage.TypeGetFullName(Int32`1<CatalogTypeToken> token);
    private sealed virtual override int JetBrains.Application.Catalogs.IPartCatalogStorage.TypeGetHashCode(Int32`1<CatalogTypeToken> token);
    private sealed virtual override PartCatalogTypeKind JetBrains.Application.Catalogs.IPartCatalogStorage.TypeGetKind(Int32`1<CatalogTypeToken> token);
    private sealed virtual override CollectionSource`1<PartCatalogAttribute> JetBrains.Application.Catalogs.IPartCatalogStorage.TypeGetPartAttributes(Int32`1<CatalogTypeToken> token, Type typeFilter);
    private sealed virtual override CollectionSource`1<PartCatalogTypeMember> JetBrains.Application.Catalogs.IPartCatalogStorage.TypeGetPartMembers(Int32`1<CatalogTypeToken> token);
    private sealed virtual override Type JetBrains.Application.Catalogs.IPartCatalogStorage.TypeTryGetBoundType(Int32`1<CatalogTypeToken> token);
    [CompilerGeneratedAttribute]
private static TablePartCatalogStorage[] <.cctor>b__15(Struct1 data);
    [CompilerGeneratedAttribute]
private static IDictionary`2<Pair`2<StringSource, StringSource>, Int32`1<CatalogTypeToken>> <.cctor>b__16(TablePartCatalogStorage storage);
}
public class JetBrains.Application.Table.TablePartCatalogStorage : object {
    private static Func`2<TablePartCatalogStorage, Func`2<Int32`1<CatalogAssemblyToken>, IAssemblyBinder>> myDelegateABs;
    private static Func`2<TablePartCatalogStorage, Func`2<Int32`1<CatalogTypeToken>, Type>> myDelegateTBs;
    private FrugalLocalLazy`1<ConcurrentDictionary`2<Int32`1<CatalogAssemblyToken>, IAssemblyBinder>> myCacheAssemblyBinders;
    private FrugalLocalLazy`1<ConcurrentDictionary`2<Int32`1<CatalogTypeToken>, Type>> myCacheBoundTypes;
    [CanBeNullAttribute]
private TablePartCatalogCollectionSourceOwner myCollectionSourceOwner;
    private LocalLazy`2<Func`2<Int32`1<CatalogAssemblyToken>, IAssemblyBinder>, TablePartCatalogStorage> myDelegateAB;
    private LocalLazy`2<Func`2<Int32`1<CatalogTypeToken>, Type>, TablePartCatalogStorage> myDelegateTB;
    [CanBeNullAttribute]
private IPartCatalogFilter myFilter;
    [CanBeNullAttribute]
private TablePartCatalogGroupStorage myGroup;
    [NotNullAttribute]
public IAssemblyMasterBinder MasterBinder;
    [NotNullAttribute]
public CatalogTables Tables;
    [CompilerGeneratedAttribute]
private static Func`2<TablePartCatalogStorage, Func`2<Int32`1<CatalogAssemblyToken>, IAssemblyBinder>> CS$<>9__CachedAnonymousMethodDelegate4;
    [CompilerGeneratedAttribute]
private static Func`2<TablePartCatalogStorage, Func`2<Int32`1<CatalogTypeToken>, Type>> CS$<>9__CachedAnonymousMethodDelegate5;
    [NotNullAttribute]
private TablePartCatalogCollectionSourceOwner CollectionSourceOwner { get; }
    public TablePartCatalogStorage(CatalogTables tables, IPartCatalogFilter filter, IAssemblyMasterBinder masterbinder);
    internal TablePartCatalogStorage(CatalogTables tables, IPartCatalogFilter filter, IAssemblyMasterBinder masterbinder, TablePartCatalogGroupStorage group);
    private static TablePartCatalogStorage();
    public sealed virtual IPartCatalogStorage ApplyFilter(IPartCatalogFilter filter);
    public sealed virtual IAssemblyBinder AssemblyGetBinder(Int32`1<CatalogAssemblyToken> token);
    public sealed virtual StringSource AssemblyGetFullName(Int32`1<CatalogAssemblyToken> token);
    public sealed virtual int AssemblyGetHashCode(Int32`1<CatalogAssemblyToken> token);
    public sealed virtual AssemblyNameInfo AssemblyGetNameInfo(Int32`1<CatalogAssemblyToken> token);
    public sealed virtual CollectionSource`1<PartCatalogAttribute> AssemblyGetPartAttributes(Int32`1<CatalogAssemblyToken> token, Type typeFilter);
    public sealed virtual CollectionSource`1<PartCatalogType> AssemblyGetPartTypes(Int32`1<CatalogAssemblyToken> token);
    public sealed virtual StringSource AssemblyGetSimpleName(Int32`1<CatalogAssemblyToken> token);
    public sealed virtual object AttributeArgumentGetBoxedValue(Int32`1<CatalogAttributeArgumentToken> token);
    public sealed virtual PartCatalogAttributeArgumentDisposition AttributeArgumentGetDisposition(Int32`1<CatalogAttributeArgumentToken> token);
    public sealed virtual StringSource AttributeArgumentGetName(Int32`1<CatalogAttributeArgumentToken> token);
    public sealed virtual ulong AttributeArgumentGetPrimitiveValue(Int32`1<CatalogAttributeArgumentToken> token, Nullable`1<AttributeArgumentValueElementType> typeExpected);
    public sealed virtual StringSource AttributeArgumentGetStringValue(Int32`1<CatalogAttributeArgumentToken> token);
    public sealed virtual PartCatalogType AttributeArgumentGetTypeValue(Int32`1<CatalogAttributeArgumentToken> token);
    public sealed virtual AttributeArgumentValueElementType AttributeArgumentGetValueElementType(Int32`1<CatalogAttributeArgumentToken> token);
    public sealed virtual CollectionSource`1<PartCatalogAttributeArgument> AttributeGetArguments(Int32`1<CatalogAttributeToken> token);
    public sealed virtual object AttributeGetInstance(Int32`1<CatalogAttributeToken> token, OnError onerror);
    public sealed virtual PartCatalogType AttributeGetType(Int32`1<CatalogAttributeToken> token);
    public sealed virtual Nullable`1<PartCatalogAttributeArgument> AttributeTryGetArgumentByName(Int32`1<CatalogAttributeToken> token, string name);
    public sealed virtual Nullable`1<CollectionSource`1<PartCatalogType>> AttributeTryGetConstructorFormalParameterTypes(Int32`1<CatalogAttributeToken> token);
    public sealed virtual StringSource GetTypeLocalName(Int32`1<CatalogTypeToken> token);
    public sealed virtual CollectionSource`1<PartCatalogType> GlobalGetAllPartTypes();
    public sealed virtual CollectionSource`1<PartCatalogAssembly> GlobalGetCatalogedAssemblies();
    public sealed virtual MemberInfo MemberBind(Int32`1<CatalogMemberToken> token);
    public sealed virtual PartCatalogType MemberGetDeclaringType(Int32`1<CatalogMemberToken> token);
    public sealed virtual int MemberGetHashCode(Int32`1<CatalogMemberToken> token);
    public sealed virtual PartCatalogTypeMemberKind MemberGetKind(Int32`1<CatalogMemberToken> token);
    public sealed virtual StringSource MemberGetName(Int32`1<CatalogMemberToken> token);
    public sealed virtual CollectionSource`1<PartCatalogType> MemberGetParameterTypes(Int32`1<CatalogMemberToken> token);
    public sealed virtual CollectionSource`1<PartCatalogAttribute> MemberGetPartAttributes(Int32`1<CatalogMemberToken> token, Type typeFilter);
    public sealed virtual PartCatalogType MemberGetValueType(Int32`1<CatalogMemberToken> token);
    public sealed virtual Type TypeBind(Int32`1<CatalogTypeToken> token);
    public sealed virtual bool TypeEqualsRuntimeType(Int32`1<CatalogTypeToken> token, Type typeRuntime);
    public sealed virtual PartCatalogAssembly TypeGetAssembly(Int32`1<CatalogTypeToken> token);
    public sealed virtual StringSource TypeGetAssemblyQualifiedName(Int32`1<CatalogTypeToken> token);
    public sealed virtual CollectionSource`1<PartCatalogType> TypeGetBaseTypes(Int32`1<CatalogTypeToken> token);
    public sealed virtual CollectionSource`1<PartCatalogType> TypeGetExtraTypes(Int32`1<CatalogTypeToken> token);
    public sealed virtual StringSource TypeGetFullName(Int32`1<CatalogTypeToken> token);
    public sealed virtual int TypeGetHashCode(Int32`1<CatalogTypeToken> token);
    public sealed virtual PartCatalogTypeKind TypeGetKind(Int32`1<CatalogTypeToken> token);
    public sealed virtual CollectionSource`1<PartCatalogAttribute> TypeGetPartAttributes(Int32`1<CatalogTypeToken> token, Type typeFilter);
    public sealed virtual CollectionSource`1<PartCatalogTypeMember> TypeGetPartMembers(Int32`1<CatalogTypeToken> token);
    public sealed virtual Type TypeTryGetBoundType(Int32`1<CatalogTypeToken> token);
    private sealed virtual override CollectionSource`1<PartCatalogAssembly> JetBrains.Application.Catalogs.IPartCatalogStorage.AssemblyGetReferencedAssemblies(Int32`1<CatalogAssemblyToken> token);
    private static CollectionSource`1<PartCatalogType> AssemblyGetTypesWithTraits(Int32`1<CatalogAssemblyToken> token, TraitMaskBanksAndOperations traitmasks, CatalogTables tables, IPartCatalogStorage storage);
    private sealed virtual override bool JetBrains.Application.Catalogs.IPartCatalogStorage.AssemblyIsCataloged(Int32`1<CatalogAssemblyToken> token);
    private static bool CollectionSourceEquals(CollectionSource`1<TItem> p, CollectionSource`1<TItem> q);
    private TablePartCatalogCollectionSourceOwner get_CollectionSourceOwner();
    private static int EnumerableCompareTo(IEnumerable`1<TItem> p, IEnumerable`1<TItem> q);
    private CollectionSource`1<PartCatalogAttribute> GetAttributesCore(AttributeRangeRef range, Type typeFilter);
    private PartCatalogAssembly GetPartAssembly(Int32`1<CatalogAssemblyToken> token);
    internal PartCatalogType GetPartType(Int32`1<CatalogTypeToken> token);
    private StringSource GetStringSource(StringRef aref);
    private bool TypeEqualsRuntimeType_NamesCheck(Int32`1<CatalogTypeToken> token, Type typeRuntime);
    [CompilerGeneratedAttribute]
private static Func`2<Int32`1<CatalogAssemblyToken>, IAssemblyBinder> <.cctor>b__0(TablePartCatalogStorage thіs);
    [CompilerGeneratedAttribute]
private static Func`2<Int32`1<CatalogTypeToken>, Type> <.cctor>b__2(TablePartCatalogStorage thіs);
}
