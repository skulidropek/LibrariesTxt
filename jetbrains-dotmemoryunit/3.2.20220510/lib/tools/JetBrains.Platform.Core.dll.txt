public static class JetBrains.Application.CompanyInfo : object {
    public static string Name;
    public static string NameWithInc;
    public static string NameWithIncNational;
    public static string PlatformProductRegistryKeyName;
    public static string WebsiteUri;
    public static string TwitterUri;
    public static string HistoricalDefaultProductName;
    private static CompanyInfo();
}
public class JetBrains.Application.InterruptableActivityCookie : object {
    public static int MaxTimeBetweenInterruptsMs;
    [ThreadStaticAttribute]
private static Stack`1<Func`1<bool>> ourInterrupts;
    [ThreadStaticAttribute]
private static int ourInterruptSuspend;
    [ThreadStaticAttribute]
private static int ourSuspendUntil;
    private static Func`1<bool> ourReentrancyMarker;
    private Func`1<bool> myInterrupt;
    [CompilerGeneratedAttribute]
private static Func`1<bool> CS$<>9__CachedAnonymousMethodDelegate7;
    public InterruptableActivityCookie(Func`1<bool> interrupt);
    private static InterruptableActivityCookie();
    public static InterruptableActivityCookie UsingReentrancyPoint();
    public static void CheckAndThrow(IProgressIndicator progress);
    public static bool IsSuspended();
    [CanBeNullAttribute]
public static Func`1<bool> GetCheck();
    public static IDisposable Suspend();
    public static IDisposable SuspendTemporary();
    private static IDisposable Suspend(int suspendUntil);
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
private static bool <.cctor>b__6();
}
public interface JetBrains.Application.Progress.IProgressIndicator {
    unknown string CurrentItemText {public set; }
    public bool IsCanceled { get; }
    public string TaskName { get; public set; }
    public abstract virtual void set_CurrentItemText(string value);
    public abstract virtual bool get_IsCanceled();
    public abstract virtual void set_TaskName(string value);
    public abstract virtual string get_TaskName();
    public abstract virtual void Advance(double units);
    public abstract virtual void Start(int totalWorkUnits);
    public abstract virtual void Stop();
}
public interface JetBrains.Application.Progress.IProgressIndicatorModel {
    [NotNullAttribute]
public IProperty`1<double> Fraction { get; }
    [NotNullAttribute]
public IProperty`1<bool> IsCanceled { get; }
    [NotNullAttribute]
public IProperty`1<bool> IsRunning { get; }
    [NotNullAttribute]
public IProperty`1<string> Name { get; }
    [NotNullAttribute]
public IProperty`1<string> StepName { get; }
    public abstract virtual IProperty`1<double> get_Fraction();
    public abstract virtual IProperty`1<bool> get_IsCanceled();
    public abstract virtual IProperty`1<bool> get_IsRunning();
    public abstract virtual IProperty`1<string> get_Name();
    public abstract virtual IProperty`1<string> get_StepName();
}
public class JetBrains.Application.Progress.ProcessCancelledException : Exception {
    protected ProcessCancelledException(SerializationInfo info, StreamingContext context);
    public ProcessCancelledException(Exception innerException);
}
[ExtensionAttribute]
public static class JetBrains.Application.Progress.ProcessCancelledExceptionExtension : object {
    [ExtensionAttribute]
public static bool ContainsProcessCancelledException(Exception ex);
}
public class JetBrains.Application.Progress.ProgressDiagnosticException : ApplicationException {
    public ProgressDiagnosticException(string message);
    public ProgressDiagnosticException(string message, Exception innerException);
}
public class JetBrains.Application.Progress.ProgressIndicator : object {
    private double myAdvanceFactor;
    private double myEpsilon;
    private IProperty`1<double> myFraction;
    private IProperty`1<bool> myIsCanceled;
    private IProperty`1<bool> myIsRunning;
    private IProperty`1<string> myName;
    private IProperty`1<string> myStepName;
    [CompilerGeneratedAttribute]
private object <ReadonlyToken>k__BackingField;
    public object ReadonlyToken { get; public set; }
    unknown string JetBrains.Application.Progress.IProgressIndicator.CurrentItemText {private set; }
    private bool JetBrains.Application.Progress.IProgressIndicator.IsCanceled { get; }
    private string JetBrains.Application.Progress.IProgressIndicator.TaskName { get; private set; }
    public IProperty`1<double> Fraction { get; }
    public IProperty`1<bool> IsCanceled { get; }
    public IProperty`1<bool> IsRunning { get; }
    public IProperty`1<string> Name { get; }
    public IProperty`1<string> StepName { get; }
    public ProgressIndicator(Lifetime lifetime);
    [CompilerGeneratedAttribute]
public object get_ReadonlyToken();
    [CompilerGeneratedAttribute]
public void set_ReadonlyToken(object value);
    private sealed virtual override void JetBrains.Application.Progress.IProgressIndicator.Advance(double units);
    private sealed virtual override void JetBrains.Application.Progress.IProgressIndicator.Start(int range);
    private sealed virtual override void JetBrains.Application.Progress.IProgressIndicator.Stop();
    private sealed virtual override void JetBrains.Application.Progress.IProgressIndicator.set_CurrentItemText(string value);
    private sealed virtual override bool JetBrains.Application.Progress.IProgressIndicator.get_IsCanceled();
    private sealed virtual override void JetBrains.Application.Progress.IProgressIndicator.set_TaskName(string value);
    private sealed virtual override string JetBrains.Application.Progress.IProgressIndicator.get_TaskName();
    public sealed virtual IProperty`1<double> get_Fraction();
    public sealed virtual IProperty`1<bool> get_IsCanceled();
    public sealed virtual IProperty`1<bool> get_IsRunning();
    public sealed virtual IProperty`1<string> get_Name();
    public sealed virtual IProperty`1<string> get_StepName();
    private sealed virtual override void System.IDisposable.Dispose();
    [CompilerGeneratedAttribute]
private void <.ctor>b__0(BeforePropertyChangedEventArgs`1<string> args);
    [CompilerGeneratedAttribute]
private object <JetBrains.Application.Progress.IProgressIndicator.Advance>b__4();
    [CompilerGeneratedAttribute]
private object <JetBrains.Application.Progress.IProgressIndicator.Advance>b__7();
}
public abstract class JetBrains.Application.Progress.ProgressIndicatorBase : object {
    private static int MinAllowedTotalWorkUnits;
    private bool myCanceled;
    protected bool myIsStartInvoked;
    private int myTotalWorkUnits;
    private double myUnits;
    public static double DefaultEpsilon;
    [CompilerGeneratedAttribute]
private string <CurrentItemText>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TaskName>k__BackingField;
    [CompilerGeneratedAttribute]
private static Func`1<object> CS$<>9__CachedAnonymousMethodDelegate6;
    public double Units { get; }
    protected double Fraction { get; }
    protected int TotalWorkUnits { get; }
    public string CurrentItemText { get; public set; }
    public bool IsCanceled { get; }
    public string TaskName { get; public set; }
    protected ProgressIndicatorBase(string taskName);
    private static ProgressIndicatorBase();
    public double get_Units();
    public virtual void Cancel();
    protected double get_Fraction();
    protected int get_TotalWorkUnits();
    public virtual void Advance(double units);
    private static InvalidOperationException WithUnitsData(InvalidOperationException exception, double units);
    public sealed virtual void Dispose();
    public virtual void Start(int totalWorkUnits);
    public virtual void Stop();
    [CompilerGeneratedAttribute]
public virtual string get_CurrentItemText();
    [CompilerGeneratedAttribute]
public virtual void set_CurrentItemText(string value);
    public virtual bool get_IsCanceled();
    [CompilerGeneratedAttribute]
public virtual string get_TaskName();
    [CompilerGeneratedAttribute]
public virtual void set_TaskName(string value);
    [CompilerGeneratedAttribute]
private static object <Start>b__4();
}
[ExtensionAttribute]
public static class JetBrains.Application.Progress.ProgressIndicatorExtensions : object {
    private static double DefaultProgressFraction;
    [ExtensionAttribute]
public static void Advance(IProgressIndicator progress);
    [ExtensionAttribute]
public static void Advance(IProgressIndicator progressParent, double fUnitsInParentIndicator, Action`1<IProgressIndicator> funcAdvanceSubprogress);
    [ExtensionAttribute]
public static void CheckForInterrupt(IProgressIndicator progress);
    [ExtensionAttribute]
public static void SafeAdvance(IProgressIndicator progress, double units);
    [ContractAnnotationAttribute("progressParent:null => null; => notnull")]
[ExtensionAttribute]
public static IProgressIndicator CreateSubProgress(IProgressIndicator progressParent, double fUnitsInParentIndicator);
    [ExtensionAttribute]
public static IProgressIndicator CreateSubProgress(IProgressIndicator progressParent);
    [ExtensionAttribute]
public static IProgressIndicator CreateSlowIndicator(IProgressIndicator progressIndicator);
    [ExtensionAttribute]
public static IProgressIndicator CreateSlowIndicator(IProgressIndicator progressIndicator, TimeSpan timeSpan);
    [ExtensionAttribute]
private static void ForEachWithProgressImpl(ICollection`1<T> collection, IProgressIndicator progress, string taskname, bool throwOnCancel, Action`2<IProgressIndicator, T> handler);
    [NotNullAttribute]
private static IEnumerable`1<T> WithProgressImpl(ICollection`1<T> collection, IProgressIndicator progress, string taskname, bool throwOnCancel);
    [NotNullAttribute]
private static IEnumerable`1<KeyValuePair`2<T, IProgressIndicator>> WithProgressForEveryImpl(ICollection`1<T> collection, IProgressIndicator progress, string taskname, bool throwOnCancel);
    [ExtensionAttribute]
public static void ForEachWithProgress(ICollection`1<T> collection, IProgressIndicator progress, string taskname, bool throwOnCancel, Action`2<T, IProgressIndicator> handler);
    [ExtensionAttribute]
public static void ForEachWithProgress(ICollection`1<T> collection, IProgressIndicator progress, string taskname, Action`2<T, IProgressIndicator> handler);
    [ExtensionAttribute]
public static void ForEachWithProgress(ICollection`1<T> collection, IProgressIndicator progress, string taskname, bool throwOnCancel, Action`1<T> handler);
    [ExtensionAttribute]
public static void ForEachWithProgress(ICollection`1<T> collection, IProgressIndicator progress, string taskname, Action`1<T> handler);
    [NotNullAttribute]
[ExtensionAttribute]
public static IEnumerable`1<T> WithProgress(ICollection`1<T> collection, IProgressIndicator progress, string taskname, bool throwOnCancel);
    [NotNullAttribute]
[ExtensionAttribute]
public static IEnumerable`1<KeyValuePair`2<T, IProgressIndicator>> WithProgressForEvery(ICollection`1<T> collection, IProgressIndicator progress, string taskname, bool throwOnCancel);
    [NotNullAttribute]
[ExtensionAttribute]
public static IEnumerable`1<T> WithSubProgress(ICollection`1<T> collection, IProgressIndicator progress, double fUnitsInParentIndicator, string taskname, bool throwOnCancel);
    [NotNullAttribute]
[ExtensionAttribute]
public static List`1<TResult> SelectWProgress(ICollection`1<TSource> source, IProgressIndicator progress, string taskname, Func`2<TSource, TResult> selector);
    [ExtensionAttribute]
public static void Start(IProgressIndicator progress, int totalWorkUnits, string sTaskName);
    [ExtensionAttribute]
public static IProgressIndicator StartProgress(IProgressIndicator progress, int totalWorkUnits);
    [ExtensionAttribute]
public static void Cancel(IProgressIndicatorModel progress);
    [ExtensionAttribute]
public static IProgressIndicator StartProgress(IProgressIndicator progress, int totalWorkUnits, string taskName);
    [ExtensionAttribute]
public static void StartStop(IProgressIndicator progress, int totalWorkUnits, string taskName, Action action);
    [ExtensionAttribute]
public static IProgressIndicator Total(IProgressIndicator progress, string taskName, int total);
    [ExtensionAttribute]
public static IDisposable SafeTotal(IProgressIndicator progress, int total);
    [ExtensionAttribute]
public static IDisposable SafeTotal(IProgressIndicator progress, string taskName, int total);
    [ExtensionAttribute]
public static IDisposable Step(IProgressIndicator progress, int stepSize);
    [ExtensionAttribute]
public static IDisposable SafeStep(IProgressIndicator progress, int stepSize);
}
internal class JetBrains.Application.Progress.SlowProgressIndicator : object {
    [NotNullAttribute]
private IProgressIndicator myUnderlying;
    private TimeSpan myDuration;
    unknown string CurrentItemText {public set; }
    public bool IsCanceled { get; }
    public string TaskName { get; public set; }
    public SlowProgressIndicator(IProgressIndicator underlying);
    public SlowProgressIndicator(IProgressIndicator underlying, TimeSpan duration);
    public sealed virtual void set_CurrentItemText(string value);
    public sealed virtual bool get_IsCanceled();
    public sealed virtual string get_TaskName();
    public sealed virtual void set_TaskName(string value);
    public sealed virtual void Advance(double units);
    public sealed virtual void Start(int totalWorkUnits);
    public sealed virtual void Stop();
    public sealed virtual void Dispose();
}
public class JetBrains.Application.Progress.SubProgressIndicator : ProgressIndicatorBase {
    private IProgressIndicator myParentProgress;
    private double myUnitsInParent;
    unknown string CurrentItemText {public set; }
    public bool IsCanceled { get; }
    public string TaskName { get; public set; }
    public SubProgressIndicator(IProgressIndicator progressParent, double fUnitsInParentIndicator);
    public virtual void Advance(double units);
    public virtual void set_CurrentItemText(string value);
    public virtual bool get_IsCanceled();
    public virtual void set_TaskName(string value);
    public virtual string get_TaskName();
    [CompilerGeneratedAttribute]
private object <Advance>b__1();
    [CompilerGeneratedAttribute]
private object <Advance>b__2();
    [CompilerGeneratedAttribute]
private object <Advance>b__3();
}
public static class JetBrains.Application.Threading.Tasks.CompletedTask : object {
    [ObsoleteAttribute("Use CompletedTask.")]
[NotNullAttribute]
public static Task Instance;
    private static CompletedTask();
    [ObsoleteAttribute("Use FromResult.")]
[NotNullAttribute]
public static Task`1<T> From(T result);
}
public class JetBrains.Application.Threading.Tasks.FreeThreadedGroupingEvent : object {
    private Lifetime myLifetime;
    private ITaskHost myTaskHost;
    private bool myProlongate;
    private Func`1<Task> myAsyncCallback;
    private ISimpleSignal myOutgoing;
    private ILogger myLogger;
    private object myLock;
    private GroupingEventStatus modreq(System.Runtime.CompilerServices.IsVolatile) myStatus;
    private DateTime myScheduledTime;
    [CompilerGeneratedAttribute]
private TimeSpan <WaitTime>k__BackingField;
    public TimeSpan WaitTime { get; public set; }
    public ISimpleSignal Outgoing { get; }
    public TimeSpan Interval { get; }
    public FreeThreadedGroupingEvent(Lifetime lifetime, ITaskHost taskHost, GroupingEventProlongation prolongation, TimeSpan waitTime, Func`1<Task> asyncCallback);
    [CompilerGeneratedAttribute]
public TimeSpan get_WaitTime();
    [CompilerGeneratedAttribute]
public void set_WaitTime(TimeSpan value);
    private void ScheduledFireAction();
    private void FireInternal();
    private void FireInternal0();
    public ISimpleSignal get_Outgoing();
    public void FireIncoming();
    public void FireOutgoing(bool waitIfAlreadyFiring, bool fireIfNoIncoming);
    public void WaitAndPumpUntilNoIncoming();
    public GroupingEventStatus GetStatus();
    public TimeSpan get_Interval();
    public void ClearIncoming();
    [CompilerGeneratedAttribute]
private void <FireInternal>b__1(Task t);
}
public enum JetBrains.Application.Threading.Tasks.GroupingEventProlongation : Enum {
    public int value__;
    public static GroupingEventProlongation DontProlongate;
    public static GroupingEventProlongation Prolongate;
}
public enum JetBrains.Application.Threading.Tasks.GroupingEventStatus : Enum {
    public int value__;
    public static GroupingEventStatus NoIncoming;
    public static GroupingEventStatus Scheduled;
    public static GroupingEventStatus Firing;
}
public interface JetBrains.Application.Threading.Tasks.ITaskHost {
    [NotNullAttribute]
[PublicAPIAttribute]
public JetScheduler Scheduler { get; }
    [NotNullAttribute]
[PublicAPIAttribute]
public TaskFactory Factory { get; }
    [PublicAPIAttribute]
[NotNullAttribute]
public TaskScheduler UnguardedMainThreadScheduler { get; }
    [NotNullAttribute]
[PublicAPIAttribute]
public TaskScheduler GuardedMainThreadScheduler { get; }
    [NotNullAttribute]
[PublicAPIAttribute]
public TaskScheduler SystemThreadPool { get; }
    public abstract virtual JetScheduler get_Scheduler();
    public abstract virtual TaskFactory get_Factory();
    public abstract virtual TaskScheduler get_UnguardedMainThreadScheduler();
    public abstract virtual TaskScheduler get_GuardedMainThreadScheduler();
    public abstract virtual TaskScheduler get_SystemThreadPool();
    [PublicAPIAttribute]
[NotNullAttribute]
public abstract virtual Task Start(Task task);
    [ThreadSafeAttribute]
[PublicAPIAttribute]
[NotNullAttribute]
public abstract virtual Task`1<T> Start(Task`1<T> task);
    [PublicAPIAttribute]
[ThreadSafeAttribute]
[NotNullAttribute]
public abstract virtual Task Queue(Lifetime lifetime, Action action, TaskPriority priority);
    [PublicAPIAttribute]
[ThreadSafeAttribute]
[NotNullAttribute]
public abstract virtual Task QueueAt(Lifetime lifetime, Action action, DateTime date);
    [PublicAPIAttribute]
[ThreadSafeAttribute]
public abstract virtual void QueueRecurring(Lifetime lifetime, Action action, DateTime firstTime, TimeSpan interval);
    [NotNullAttribute]
[ThreadSafeAttribute]
[PublicAPIAttribute]
public abstract virtual Task Create(Lifetime lifetime, Action action, Func`1<bool> checkForInterrupt, TaskCreationOptions options, TaskJetProperties properties);
    [ThreadSafeAttribute]
[PublicAPIAttribute]
[NotNullAttribute]
public abstract virtual Task`1<T> Create(Lifetime lifetime, Func`1<T> action, Func`1<bool> checkForInterrupt, TaskCreationOptions options, TaskJetProperties properties);
    [NotNullAttribute]
[PublicAPIAttribute]
[ThreadSafeAttribute]
public abstract virtual TaskBarrier CreateBarrier(Lifetime lifetime, Func`1<bool> checkForInterrupt, bool sync, bool takeReadLock, TaskCreationOptions options);
}
[ExtensionAttribute]
public static class JetBrains.Application.Threading.Tasks.ITaskHostEx2 : object {
    [CompilerGeneratedAttribute]
private static Action CS$<>9__CachedAnonymousMethodDelegate6;
    [ExtensionAttribute]
[ObsoleteAttribute("Use StartNew, as it is named after the MSFT APIs.")]
[NotNullAttribute]
public static Task Run(ITaskHost thіs, Lifetime lifetime, Scheduling scheduling, Action λ);
    [ObsoleteAttribute("Use FromResult or CompletedTask.")]
[ExtensionAttribute]
[NotNullAttribute]
public static Task RunEmpty(ITaskHost thіs);
    [ExtensionAttribute]
[ObsoleteAttribute("Use StartNew, as it is named after the MSFT APIs.")]
[NotNullAttribute]
public static Task`1<TResult> Run(ITaskHost thіs, Lifetime lifetime, Scheduling scheduling, Func`1<TResult> λ);
    [ExtensionAttribute]
[NotNullAttribute]
public static Task StartNew(ITaskHost thіs, Lifetime lifetime, Scheduling scheduling, Action λ);
    [ExtensionAttribute]
[NotNullAttribute]
public static Task`1<TResult> StartNew(ITaskHost thіs, Lifetime lifetime, Scheduling scheduling, Func`1<TResult> λ);
    [ExtensionAttribute]
[NotNullAttribute]
public static Task`1<TResult> StartNew(ITaskHost thіs, Lifetime lifetime, Scheduling scheduling, Func`1<Task`1<TResult>> λ);
    [NotNullAttribute]
[ExtensionAttribute]
public static Task StartNew(ITaskHost thіs, Lifetime lifetime, Scheduling scheduling, Func`1<Task> λ);
    [NotNullAttribute]
[ExtensionAttribute]
public static Task StartNew(ITaskHost thіs, Lifetime lifetime, Scheduling scheduling, TaskPriority priority, Action λ);
    [NotNullAttribute]
[ExtensionAttribute]
public static Task`1<TResult> StartNew(ITaskHost thіs, Lifetime lifetime, Scheduling scheduling, TaskPriority priority, Func`1<TResult> λ);
    [ExtensionAttribute]
[NotNullAttribute]
public static Task`1<TResult> StartNew(ITaskHost thіs, Lifetime lifetime, Scheduling scheduling, TaskPriority priority, Func`1<Task`1<TResult>> λ);
    [NotNullAttribute]
[ExtensionAttribute]
public static Task StartNew(ITaskHost thіs, Lifetime lifetime, Scheduling scheduling, TaskPriority priority, Func`1<Task> λ);
    [NotNullAttribute]
public static TaskScheduler GetScheduler(Scheduling scheduling, ITaskHost tasks);
    [NotNullAttribute]
[ExtensionAttribute]
public static TTask AttachedToParent(TTask thіs);
    [NotNullAttribute]
[ExtensionAttribute]
public static TTask Started(TTask thіs, TaskScheduler scheduler);
    [NotNullAttribute]
[ExtensionAttribute]
public static JetDispatcherTaskScheduler GetTaskScheduler(JetDispatcher thіs);
    [ObsoleteAttribute("Use Delay.")]
[ExtensionAttribute]
[NotNullAttribute]
public static Task ContinueWithDelay(ITaskHost thіs, Lifetime lifetime, TimeSpan span);
    [NotNullAttribute]
[ExtensionAttribute]
public static Task Delay(ITaskHost thіs, Lifetime lifetime, TimeSpan span);
    [ExtensionAttribute]
public static Task ContinueWithTask(Task thіs, Lifetime lifetime, Task taskAfter);
    [NotNullAttribute]
[ObsoleteAttribute("Use StartNew, as it is named after the MSFT APIs.")]
[ExtensionAttribute]
public static Task Run(ITaskHost thіs, Lifetime lifetime, Action λ, Func`1<bool> checkForInterrupt, TaskCreationOptions options, TaskJetProperties properties, TaskScheduler scheduler);
    [NotNullAttribute]
[ObsoleteAttribute("Use StartNew, as it is named after the MSFT APIs.")]
[ExtensionAttribute]
public static Task`1<TResult> Run(ITaskHost thіs, Lifetime lifetime, Func`1<TResult> λ, Func`1<bool> checkForInterrupt, TaskCreationOptions options, TaskJetProperties properties, TaskScheduler scheduler);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
[AsyncStateMachineAttribute("JetBrains.Application.Threading.Tasks.ITaskHostEx2/<While>d__c")]
public static Task`1<bool> While(ITaskHost thіs, Lifetime lifetime, Func`1<bool> condition, Nullable`1<TimeSpan> timeout, OnWaitTimeout ontimeout);
    [DebuggerStepThroughAttribute]
[ExtensionAttribute]
[AsyncStateMachineAttribute("JetBrains.Application.Threading.Tasks.ITaskHostEx2/<While>d__15")]
public static Task`1<bool> While(ITaskHost thіs, Lifetime lifetime, IProperty`1<bool> condition, Nullable`1<TimeSpan> timeout, OnWaitTimeout ontimeout);
    [ExtensionAttribute]
public static SchedulerAwaiter Yield(ITaskHost tasker, Lifetime lifetime);
    [ExtensionAttribute]
public static SchedulerAwaiter YieldTo(ITaskHost tasker, Lifetime lifetime, Scheduling scheduling, Nullable`1<TaskPriority> priority);
    [CompilerGeneratedAttribute]
private static void <AttachedToParent>b__4(Task task);
    [CompilerGeneratedAttribute]
private static void <Delay>b__5();
}
public class JetBrains.Application.Threading.Tasks.JetDispatcherTaskScheduler : TaskScheduler {
    public JetDispatcher Dispatcher;
    public int MaximumConcurrencyLevel { get; }
    public JetDispatcherTaskScheduler(JetDispatcher dispatcher);
    public virtual int get_MaximumConcurrencyLevel();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    protected virtual IEnumerable`1<Task> GetScheduledTasks();
    protected virtual void QueueTask(Task task);
    protected virtual bool TryExecuteTaskInline(Task task, bool taskWasPreviouslyQueued);
}
public class JetBrains.Application.Threading.Tasks.ReentrancyGuardTaskScheduler : TaskScheduler {
    private IReaderWriterLock myRwlocks;
    public ReentrancyGuard ReentrancyGuard;
    public int MaximumConcurrencyLevel { get; }
    public ReentrancyGuardTaskScheduler(ReentrancyGuard guard, IReaderWriterLock rwlocks);
    public virtual int get_MaximumConcurrencyLevel();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    protected virtual IEnumerable`1<Task> GetScheduledTasks();
    protected virtual void QueueTask(Task task);
    private void ExecuteInternal(Task task);
    protected virtual bool TryExecuteTaskInline(Task task, bool taskWasPreviouslyQueued);
}
public class JetBrains.Application.Threading.Tasks.Scheduler.JetScheduler : TaskScheduler {
    internal static int TaskLimit;
    internal static int TerminationTimeMarker;
    internal static int InfiniteWaitTimeConst;
    internal static int MaxWaitTimeConst;
    internal Lifetime Lifetime;
    [ThreadStaticAttribute]
internal static JetScheduler modreq(System.Runtime.CompilerServices.IsVolatile) Scheduler;
    [ThreadStaticAttribute]
internal static JetSchedulerThread modreq(System.Runtime.CompilerServices.IsVolatile) Thread;
    internal ILogger Logger;
    internal AutoResetEvent ManagerEvent;
    private ThreadManagementUnit myShortRunningTasksMU;
    private ThreadManagementUnit myLongRunningTasksMU;
    private long myTaskExecutionIdGenerator;
    internal Thread myManagerThread;
    public object SyncObject;
    private bool myStarted;
    [CanBeNullAttribute]
private JetDispatcher myMainDispatcher;
    [CanBeNullAttribute]
private IReaderWriterLock myRwlock;
    public static Task CurrentTask { get; }
    public bool ManagesCurrentThread { get; }
    public JetScheduler(Lifetime lifetime, JetDispatcher dispatcherMain, IReaderWriterLock rwlock);
    public static Task get_CurrentTask();
    private void StartThreadPool();
    public bool get_ManagesCurrentThread();
    private ThreadManagementUnit ManagementUnit(Task task);
    internal static int BestMatchTime(int time1, int time2);
    private void ManagerThreadProc();
    private void AssignExecutionProperties(Task task);
    protected virtual void QueueTask(Task task);
    internal void ExecuteTask(Task task);
    protected virtual bool TryExecuteTaskInline(Task task, bool taskWasPreviouslyQueued);
    protected virtual IEnumerable`1<Task> GetScheduledTasks();
    public void QueueTask(Task task, DateTime scheduledTime);
    internal JetSchedulerThread CreateTaskPumpOnCurrentThread(Func`1<bool> interrupted, bool pumpLongTasks, Task firstTaskOrNull);
    private void LazyStart();
    internal void Pump(JetSchedulerThread executor);
    [CompilerGeneratedAttribute]
private void <.ctor>b__1();
    [CompilerGeneratedAttribute]
private bool <StartThreadPool>b__3();
}
internal class JetBrains.Application.Threading.Tasks.Scheduler.JetSchedulerThread : object {
    private static ILogger ourLogger;
    private JetScheduler myScheduler;
    private ThreadManagementUnit myUnit;
    private string myName;
    private SchedulerThreadMode myMode;
    private object myLock;
    internal Func`1<bool> TerminationCondition;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) myTerminating;
    [CompilerGeneratedAttribute]
private Task <Task>k__BackingField;
    [CompilerGeneratedAttribute]
private Thread <WorkThread>k__BackingField;
    public Task Task { get; private set; }
    internal bool IsBusy { get; }
    internal Thread WorkThread { get; private set; }
    internal JetSchedulerThread(ThreadManagementUnit unit, Func`1<bool> terminationCondition, string name, SchedulerThreadMode mode);
    private static JetSchedulerThread();
    [CompilerGeneratedAttribute]
public Task get_Task();
    [CompilerGeneratedAttribute]
private void set_Task(Task value);
    internal bool get_IsBusy();
    [CompilerGeneratedAttribute]
internal Thread get_WorkThread();
    [CompilerGeneratedAttribute]
private void set_WorkThread(Thread value);
    public void Start();
    internal void SetTask(Task task);
    internal void Terminate();
    private void ThreadPoolProc();
    private void ResetTask();
    private void EnqueueNextTask();
}
internal enum JetBrains.Application.Threading.Tasks.Scheduler.SchedulerThreadMode : Enum {
    public int value__;
    public static SchedulerThreadMode PumpOnCurrent;
    public static SchedulerThreadMode StartNew;
}
internal class JetBrains.Application.Threading.Tasks.Scheduler.ThreadManagementUnit : object {
    private static int NewThreadCreationInterval;
    private static int TempThreadLifecycleInterval;
    private string myName;
    internal List`1<JetSchedulerThread> Executors;
    internal List`1<JetSchedulerThread> DedicatedExecutors;
    internal int FreeExecutors;
    internal int ExecutorsCount;
    internal JetConcurrentQueue`1<Task> DedicatedTasks;
    private IPriorityQueue`1<Task> myReadyToExecuteTasks;
    private IPriorityQueue`1<Task> myScheduledTasks;
    internal JetScheduler Scheduler;
    internal WaitCountSyncContext SyncContext;
    internal static Task TerminateTask;
    private int myThreadNumberInc;
    [CompilerGeneratedAttribute]
private static Action CS$<>9__CachedAnonymousMethodDelegatea;
    public string Name { get; }
    public ThreadManagementUnit(string name, JetScheduler scheduler);
    private static ThreadManagementUnit();
    public void Signal();
    public string get_Name();
    public int Dispatch();
    private static string StatPrefix(TaskPriority priority);
    internal void AddTask(Task task);
    internal JetSchedulerThread CreateExecutor(Func`1<bool> terminationCondition, SchedulerThreadMode mode, string comment);
    [CompilerGeneratedAttribute]
private static void <.cctor>b__9();
}
internal class JetBrains.Application.Threading.Tasks.Scheduler.WaitCountSyncContext : SynchronizationContext {
    private ThreadManagementUnit myThreadMu;
    internal Int32 modreq(System.Runtime.CompilerServices.IsVolatile) LastBlockedTimestamp;
    internal ResourceCounter WaitingThreadsCounter;
    internal bool IsBlocked { get; }
    public WaitCountSyncContext(ThreadManagementUnit threadMu);
    internal bool get_IsBlocked();
    public virtual int Wait(IntPtr[] waitHandles, bool waitAll, int millisecondsTimeout);
}
public enum JetBrains.Application.Threading.Tasks.Scheduling : Enum {
    public int value__;
    public static Scheduling FreeThreaded;
    public static Scheduling MainDispatcher;
    public static Scheduling MainGuard;
}
public class JetBrains.Application.Threading.Tasks.TaskBarrier : SafeDisposable {
    private ITaskHost myTasks;
    private Lifetime myLifetime;
    private Func`1<bool> myCheckForInterrupt;
    private bool mySync;
    private bool myTakeReadLock;
    private TaskCreationOptions myOptions;
    private List`1<Task> myTaskList;
    private bool myIsWaitingWithMessagePump;
    private TaskPriority myPriority;
    private int myActiveTasks;
    private bool myFailedOrInterrupted;
    private CancellationTokenSource myCancellationTokenSource;
    private JetDispatcher myMainDispatcher;
    [CompilerGeneratedAttribute]
private static Func`2<Action, Action> CS$<>9__CachedAnonymousMethodDelegate13;
    public Lifetime Lifetime { get; }
    public Func`1<bool> CheckForInterrupt { get; }
    private int TaskCount { get; }
    internal TaskBarrier(ITaskHost tasks, Lifetime lifetime, JetDispatcher dispatcherMain, Func`1<bool> checkForInterrupt, bool sync, bool takeReadLock, TaskCreationOptions options);
    private TaskPriority CalcPriority();
    public Lifetime get_Lifetime();
    public Func`1<bool> get_CheckForInterrupt();
    public void EnqueueTask(Task task);
    public void EnqueueJob(Action action);
    public void EnqueueJob(string name, Action action);
    public void EnqueueDependentJobs(IEnumerable`1<Action> actionsEnumerable, OneToSetMap`2<Action, Action> actionToExecuteBefore);
    private int get_TaskCount();
    protected virtual void DisposeUnmanagedResources();
    [CompilerGeneratedAttribute]
private bool <.ctor>b__0();
    [CompilerGeneratedAttribute]
private void <EnqueueTask>b__c(Task _);
    [CompilerGeneratedAttribute]
private static Action <EnqueueDependentJobs>b__10(Action _);
}
internal class JetBrains.Application.Threading.Tasks.TaskByExecutionIdComparer : object {
    public sealed virtual int Compare(Task x, Task y);
}
internal class JetBrains.Application.Threading.Tasks.TaskByPriorityComparer : object {
    public sealed virtual int Compare(Task x, Task y);
}
internal class JetBrains.Application.Threading.Tasks.TaskByScheduleTimeComparer : object {
    public sealed virtual int Compare(Task x, Task y);
}
[ExtensionAttribute]
public static class JetBrains.Application.Threading.Tasks.TaskEx : object {
    public static DateTime FakeDateTime;
    private static Task False;
    [NotNullAttribute]
public static Task CompletedTask { get; }
    private static TaskEx();
    [NotNullAttribute]
[ExtensionAttribute]
[PublicAPIAttribute]
public static Task Start(Task task, ITaskHost host, bool sync);
    [PublicAPIAttribute]
[ExtensionAttribute]
[NotNullAttribute]
public static Task`1<T> Start(Task`1<T> task, ITaskHost host, bool sync);
    [PublicAPIAttribute]
public static void WaitOnMonitor(ITaskHost tasks, object sentry, int timeToWaitMillis);
    [ExtensionAttribute]
internal static bool CantBeJetTask(Task task);
    [ExtensionAttribute]
public static bool IsJetTask(Task task);
    [ExtensionAttribute]
internal static void SetExecutionId(Task task, long executionId);
    [ExtensionAttribute]
internal static long GetExecutionId(Task task);
    [ExtensionAttribute]
public static TaskPriority GetPriority(Task task);
    [ExtensionAttribute]
internal static JetSchedulerThread GetAssignedToExecutor(Task task);
    [ExtensionAttribute]
internal static void SetAssignedToExecutor(Task task, JetSchedulerThread thread);
    [ExtensionAttribute]
public static string GetName(Task task);
    [ExtensionAttribute]
internal static void SetScheduledTime(Task task, DateTime date);
    [ExtensionAttribute]
public static DateTime GetScheduledTime(Task task);
    [ExtensionAttribute]
public static UserDataHolderNoLocks GetUserData(Task task);
    [NotNullAttribute]
public static Task`1<TResult> FromResult(TResult result);
    [NotNullAttribute]
public static Task Delay(TimeSpan delay, Nullable`1<CancellationToken> cancellationMaybe);
    public static Task get_CompletedTask();
    [ObsoleteAttribute("Use from JetTaskEx directly.")]
public static Task`1<bool> While(Func`1<bool> condition, Nullable`1<TimeSpan> timeout, OnWaitTimeout ontimeout);
    [ObsoleteAttribute("Use from JetTaskEx directly.")]
public static Task`1<bool> While(Func`1<Task`1<bool>> condition, Nullable`1<TimeSpan> timeout, OnWaitTimeout ontimeout);
    [ObsoleteAttribute("Use from JetTaskEx directly.")]
public static Task`1<bool> While(IProperty`1<bool> condition, Nullable`1<TimeSpan> timeout, OnWaitTimeout ontimeout);
}
public class JetBrains.Application.Threading.Tasks.TaskHost : object {
    private JetScheduler myScheduler;
    [CanBeNullAttribute]
private IReaderWriterLock myRwlocks;
    private TaskFactory myFactory;
    private static ILogger ourLogger;
    private TaskScheduler myUnguardedMainThreadScheduler;
    private TaskScheduler myGuardedMainThreadScheduler;
    private ReentrancyGuard myMainGuard;
    [CompilerGeneratedAttribute]
private static Func`1<bool> CS$<>9__CachedAnonymousMethodDelegated;
    [PublicAPIAttribute]
public TaskScheduler SystemThreadPool { get; }
    public JetScheduler Scheduler { get; }
    public TaskFactory Factory { get; }
    public TaskScheduler UnguardedMainThreadScheduler { get; }
    public TaskScheduler GuardedMainThreadScheduler { get; }
    public static TaskJetProperties CurrentTaskProperties { get; }
    public TaskHost(Lifetime lifetime, ReentrancyGuard guardMain);
    public TaskHost(Lifetime lifetime, JetScheduler scheduler, ReentrancyGuard guardMain, IReaderWriterLock rwlocks);
    private static TaskHost();
    public sealed virtual TaskScheduler get_SystemThreadPool();
    public sealed virtual JetScheduler get_Scheduler();
    public sealed virtual TaskFactory get_Factory();
    public sealed virtual TaskScheduler get_UnguardedMainThreadScheduler();
    public sealed virtual TaskScheduler get_GuardedMainThreadScheduler();
    public sealed virtual Task Start(Task task);
    public sealed virtual Task`1<T> Start(Task`1<T> task);
    private Task CreateTaskByAction(Lifetime lifetime, Action action, TaskPriority priority);
    public sealed virtual Task Queue(Lifetime lifetime, Action action, TaskPriority priority);
    public sealed virtual Task QueueAt(Lifetime lifetime, Action action, DateTime date);
    public sealed virtual void QueueRecurring(Lifetime lifetime, Action action, DateTime firstTime, TimeSpan interval);
    [HandleProcessCorruptedStateExceptionsAttribute]
private static void AccessViolationCatcher(Action action);
    [HandleProcessCorruptedStateExceptionsAttribute]
private static T AccessViolationCatcher(Func`1<T> action);
    public sealed virtual Task Create(Lifetime lifetime, Action action, Func`1<bool> checkForInterrupt, TaskCreationOptions options, TaskJetProperties properties);
    public sealed virtual Task`1<T> Create(Lifetime lifetime, Func`1<T> action, Func`1<bool> checkForInterrupt, TaskCreationOptions options, TaskJetProperties properties);
    public sealed virtual TaskBarrier CreateBarrier(Lifetime lifetime, Func`1<bool> checkForInterrupt, bool sync, bool takeReadLock, TaskCreationOptions options);
    public static TaskJetProperties get_CurrentTaskProperties();
    [CanBeNullAttribute]
public static T GetData(Key`1<T> k);
    public static void PutData(Key`1<T> k, T v);
    public static void OnUnobservedTaskException(object sender, UnobservedTaskExceptionEventArgs args);
    [CompilerGeneratedAttribute]
private static bool <Create>b__9();
    [CompilerGeneratedAttribute]
private static bool <Create>b__13();
}
[ExtensionAttribute]
public static class JetBrains.Application.Threading.Tasks.TaskHostEx : object {
    [ObsoleteAttribute("Use StartNew, as it is named after the MSFT APIs.")]
[ExtensionAttribute]
public static Task Run(ITaskHost tasks, Lifetime lifetime, Action action);
    [ObsoleteAttribute("Use StartNew, as it is named after the MSFT APIs.")]
[ExtensionAttribute]
public static Task`1<T> Run(ITaskHost tasks, Lifetime lifetime, Func`1<T> action);
    [ExtensionAttribute]
[ObsoleteAttribute("Use StartNew, as it is named after the MSFT APIs.")]
public static Task RunSafe(ITaskHost tasks, Lifetime lifetime, Action action, TaskPriority priority);
    [ExtensionAttribute]
[PublicAPIAttribute]
[ThreadSafeAttribute]
[NotNullAttribute]
public static Task QueueAt(ITaskHost tasks, Lifetime lifetime, Action action, TimeSpan span);
    [ThreadSafeAttribute]
[PublicAPIAttribute]
[ExtensionAttribute]
public static void QueueRecuring(ITaskHost tasks, Lifetime lifetime, Action action, TimeSpan span);
    [PublicAPIAttribute]
[ExtensionAttribute]
[ThreadSafeAttribute]
public static void PreprocessSingleThreadedAndParallelize(ITaskHost host, Lifetime lifetime, bool sync, IList`1<T> itemsToProcess, Func`2<T, TPreprocessResult> preprocessSingleThreaded, Action`2<T, TPreprocessResult> processMultithreaded, int maxConcurrency, int maxPreprocessedSize);
}
public class JetBrains.Application.Threading.Tasks.TaskJetProperties : object {
    [CompilerGeneratedAttribute]
private TaskPriority <Priority>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TakeReadLock>k__BackingField;
    [CompilerGeneratedAttribute]
private long <ExecutionId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <ScheduledTime>k__BackingField;
    [CompilerGeneratedAttribute]
private JetSchedulerThread <AssignedToExecutor>k__BackingField;
    [CompilerGeneratedAttribute]
private CancellationToken <CancellationToken>k__BackingField;
    [CompilerGeneratedAttribute]
private UserDataHolderNoLocks <UserData>k__BackingField;
    public TaskPriority Priority { get; public set; }
    public bool TakeReadLock { get; public set; }
    internal long ExecutionId { get; internal set; }
    internal string Name { get; internal set; }
    internal DateTime ScheduledTime { get; internal set; }
    internal JetSchedulerThread AssignedToExecutor { get; internal set; }
    public CancellationToken CancellationToken { get; public set; }
    public UserDataHolderNoLocks UserData { get; public set; }
    [CompilerGeneratedAttribute]
public TaskPriority get_Priority();
    [CompilerGeneratedAttribute]
public void set_Priority(TaskPriority value);
    [CompilerGeneratedAttribute]
public bool get_TakeReadLock();
    [CompilerGeneratedAttribute]
public void set_TakeReadLock(bool value);
    [CompilerGeneratedAttribute]
internal long get_ExecutionId();
    [CompilerGeneratedAttribute]
internal void set_ExecutionId(long value);
    [CompilerGeneratedAttribute]
internal string get_Name();
    [CompilerGeneratedAttribute]
internal void set_Name(string value);
    [CompilerGeneratedAttribute]
internal DateTime get_ScheduledTime();
    [CompilerGeneratedAttribute]
internal void set_ScheduledTime(DateTime value);
    [CompilerGeneratedAttribute]
internal JetSchedulerThread get_AssignedToExecutor();
    [CompilerGeneratedAttribute]
internal void set_AssignedToExecutor(JetSchedulerThread value);
    [CompilerGeneratedAttribute]
public CancellationToken get_CancellationToken();
    [CompilerGeneratedAttribute]
public void set_CancellationToken(CancellationToken value);
    [CompilerGeneratedAttribute]
public UserDataHolderNoLocks get_UserData();
    [CompilerGeneratedAttribute]
public void set_UserData(UserDataHolderNoLocks value);
}
public class JetBrains.Concurrency.Fiber : object {
    public ObsoleteLifetimeAndDefinitionAtTheSameTime Disposables;
    private ICorRuntimeHost _clrhost;
    private bool _isCompleted;
    private bool _isPrimary;
    private Void* _pFiber;
    public bool IsCompleted { get; }
    public bool IsPrimary { get; }
    private Fiber(Void* pFiber, bool isPrimary);
    private Fiber(Action action);
    [NotNullAttribute]
public static IFiber CreateSecondaryFiber(Action action);
    [NotNullAttribute]
public static IFiber GetPrimaryFiber();
    public sealed virtual void Dispose();
    public sealed virtual void YieldTo();
    public sealed virtual bool get_IsCompleted();
    public sealed virtual bool get_IsPrimary();
    [CompilerGeneratedAttribute]
private void <.ctor>b__0();
    [CompilerGeneratedAttribute]
private void <.ctor>b__8();
    [CompilerGeneratedAttribute]
private void <.ctor>b__12();
}
public class JetBrains.Concurrency.FiberOverThread : object {
    [ThreadStaticAttribute]
[CanBeNullAttribute]
private static FiberOverThread _current;
    public ObsoleteLifetimeAndDefinitionAtTheSameTime Disposables;
    private AutoResetEvent _evtContinue;
    private bool _isCompleted;
    private bool _isDisposed;
    private bool _isPrimary;
    [CompilerGeneratedAttribute]
private static Action CS$<>9__CachedAnonymousMethodDelegate3;
    protected bool IsDisposed { get; }
    public bool IsCompleted { get; }
    public bool IsPrimary { get; }
    private FiberOverThread(Action action, ITaskHost tasker);
    [NotNullAttribute]
public static FiberOverThread CreateSecondaryFiber(Action action, ITaskHost tasker);
    [NotNullAttribute]
public static FiberOverThread GetPrimaryFiber();
    protected bool get_IsDisposed();
    private void InitCommon(bool isPrimary);
    public sealed virtual void Dispose();
    public sealed virtual void YieldTo();
    public sealed virtual bool get_IsCompleted();
    public sealed virtual bool get_IsPrimary();
    [CompilerGeneratedAttribute]
private void <.ctor>b__0();
    [CompilerGeneratedAttribute]
private static void <.ctor>b__1();
    [CompilerGeneratedAttribute]
private void <InitCommon>b__10();
}
public interface JetBrains.Concurrency.IFiber {
    public bool IsCompleted { get; }
    public bool IsPrimary { get; }
    public abstract virtual bool get_IsCompleted();
    public abstract virtual bool get_IsPrimary();
    public abstract virtual void YieldTo();
}
[DebuggerStepThroughAttribute]
public class JetBrains.DataFlow.AddRemoveEventArgs`1 : EventArgs`1<TValue> {
    protected bool myIsAcknowledging;
    private AddRemove myAction;
    private ICollectionEvents`1<TValue> myCollection;
    private object myCookie;
    public AddRemove Action { get; }
    public ICollectionEvents`1<TValue> Collection { get; }
    [CanBeNullAttribute]
public object Cookie { get; }
    public bool IsAcknowledging { get; }
    public bool IsAdding { get; }
    public bool IsRemoving { get; }
    public AddRemoveEventArgs`1(ICollectionEvents`1<TValue> collection, AddRemove action, TValue value, object cookie);
    public AddRemove get_Action();
    public ICollectionEvents`1<TValue> get_Collection();
    public object get_Cookie();
    public bool get_IsAcknowledging();
    public bool get_IsAdding();
    public bool get_IsRemoving();
    public static AddRemoveEventArgs`1<TValue> CreateAcknowledgementArgs(ICollectionEvents`1<TValue> collection, AddRemove action, object cookie, Action`1& funcSetValue);
}
[DebuggerStepThroughAttribute]
public class JetBrains.DataFlow.AddRemoveIndexEventArgs`1 : AddRemoveEventArgs`1<TValue> {
    private int myIndex;
    public int Index { get; }
    public AddRemoveIndexEventArgs`1(ICollectionEvents`1<TValue> collection, AddRemove action, TValue value, int index, object cookie);
    public int get_Index();
    public static AddRemoveIndexEventArgs`1<TValue> CreateAcknowledgementArgs(ICollectionEvents`1<TValue> collection, AddRemove action, object cookie, Action`2& funcSetValueAndIndex);
}
[DebuggerStepThroughAttribute]
public class JetBrains.DataFlow.BeforeAddRemoveEventArgs`1 : AddRemoveEventArgs`1<TValue> {
    private bool myCancel;
    [CompilerGeneratedAttribute]
private static Func`1<object> CS$<>9__CachedAnonymousMethodDelegate3;
    public bool Cancel { get; public set; }
    public BeforeAddRemoveEventArgs`1(ICollectionEvents`1<TValue> collection, AddRemove action, TValue value, object cookie);
    public bool get_Cancel();
    public void set_Cancel(bool value);
    public static BeforeAddRemoveEventArgs`1<TValue> CreateAcknowledgementArgs(ICollectionEvents`1<TValue> collection, AddRemove action, object cookie, Action`1& funcSetValue);
    [CompilerGeneratedAttribute]
private object <set_Cancel>b__0();
    [CompilerGeneratedAttribute]
private static object <set_Cancel>b__1();
}
[DebuggerStepThroughAttribute]
public class JetBrains.DataFlow.BeforeAddRemoveIndexEventArgs`1 : BeforeAddRemoveEventArgs`1<TValue> {
    private int myIndex;
    public int Index { get; }
    public BeforeAddRemoveIndexEventArgs`1(ICollectionEvents`1<TValue> collection, AddRemove action, TValue value, int index, object cookie);
    public int get_Index();
    public static BeforeAddRemoveIndexEventArgs`1<TValue> CreateAcknowledgementArgs(ICollectionEvents`1<TValue> collection, AddRemove action, object cookie, Action`2& funcSetValueAndIndex);
}
[DebuggerStepThroughAttribute]
public class JetBrains.DataFlow.BeforePropertyChangedEventArgs`1 : PropertyChangedEventArgs`1<TValue> {
    private bool myCancel;
    [CompilerGeneratedAttribute]
private static Func`1<object> CS$<>9__CachedAnonymousMethodDelegate1;
    public bool Cancel { get; public set; }
    public BeforePropertyChangedEventArgs`1(Property`1<TValue> property, TValue old, bool hasold, TValue new, bool hasnew, object cookie);
    public bool get_Cancel();
    public void set_Cancel(bool value);
    [NotNullAttribute]
[PureAttribute]
public static BeforePropertyChangedEventArgs`1<TValue> CreateBoth(Property`1<TValue> property, TValue old, TValue new, object cookie);
    [PureAttribute]
[NotNullAttribute]
public static BeforePropertyChangedEventArgs`1<TValue> CreateNew(Property`1<TValue> property, TValue new, object cookie);
    [PureAttribute]
[NotNullAttribute]
public static BeforePropertyChangedEventArgs`1<TValue> CreateOld(Property`1<TValue> property, TValue old, object cookie);
    [CompilerGeneratedAttribute]
private static object <set_Cancel>b__0();
}
[DebuggerStepThroughAttribute]
public class JetBrains.DataFlow.CancelEventArgs`1 : EventArgs`1<TValue> {
    private bool myCancel;
    [CompilerGeneratedAttribute]
private static Func`1<object> CS$<>9__CachedAnonymousMethodDelegate1;
    public bool Cancel { get; public set; }
    public CancelEventArgs`1(TValue value);
    public bool get_Cancel();
    public void set_Cancel(bool value);
    [CompilerGeneratedAttribute]
private static object <set_Cancel>b__0();
}
[ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static class JetBrains.DataFlow.CollectionBridge : object {
    [ExtensionAttribute]
public static CollectionBridge`2<TSource, TTarget> BridgeInto(ICollectionEvents`1<TSource> source, Lifetime lifetime, ICollectionEvents`1<TTarget> target, Func`2<TSource, TTarget> funcConverter, object cookie);
    [CompilerGeneratedAttribute]
private static TTarget <BridgeInto>b__0(TSource arg);
}
[DebuggerStepThroughAttribute]
public class JetBrains.DataFlow.CollectionBridge`2 : object {
    private Func`2<TSource, TTarget> myFuncConverter;
    private BidirectionalMapOnDictionary`2<TSource, TTarget> myMapBothWays;
    private MappingInfo myMappingInfo;
    private Dictionary`2<TSource, TTarget> myMapSourceToTarget;
    private ICollectionEvents`1<TSource> mySource;
    private ICollectionEvents`1<TTarget> myTarget;
    private object myTargetModificationCookie;
    [CompilerGeneratedAttribute]
private bool <AllowForeignTargetRemovals>k__BackingField;
    public bool AllowForeignTargetRemovals { get; public set; }
    public MappingInfo MappingInfo { get; }
    [NotNullAttribute]
public IDictionary`2<TSource, TTarget> MapSourceToTarget { get; }
    [NotNullAttribute]
public IDictionary`2<TTarget, TSource> MapTargetToSource { get; }
    [NotNullAttribute]
public ICollectionEvents`1<TSource> Source { get; }
    [NotNullAttribute]
public ICollectionEvents`1<TTarget> Target { get; }
    public CollectionBridge`2(Lifetime lifetime, MappingInfo mappinginfo, ICollectionEvents`1<TSource> source, ICollectionEvents`1<TTarget> target, Func`2<TSource, TTarget> funcConverter, object oTaregtModificationCookie);
    [CompilerGeneratedAttribute]
public bool get_AllowForeignTargetRemovals();
    [CompilerGeneratedAttribute]
public void set_AllowForeignTargetRemovals(bool value);
    public MappingInfo get_MappingInfo();
    public IDictionary`2<TSource, TTarget> get_MapSourceToTarget();
    public IDictionary`2<TTarget, TSource> get_MapTargetToSource();
    public ICollectionEvents`1<TSource> get_Source();
    public ICollectionEvents`1<TTarget> get_Target();
    private void Init(Lifetime lifetime);
    [CompilerGeneratedAttribute]
private void <Init>b__0(AddRemoveEventArgs`1<TSource> args);
}
[DebuggerStepThroughAttribute]
public class JetBrains.DataFlow.CollectionEvents`1 : object {
    protected static string ValueNameId;
    protected static string ValueNameIsUniqueItems;
    private static string ValueNameStorage;
    protected SpinWaitLock myLock;
    [NotNullAttribute]
private PropertyId`1<TValue> myId;
    private bool myIsNullValuesAllowed;
    private bool myIsUniqueItems;
    private SignalWithDelegates`1<AddRemoveEventArgs`1<TValue>> mySignalAddRemove;
    private SignalWithDelegates`1<BeforeAddRemoveEventArgs`1<TValue>> mySignalBeforeAddRemove;
    [NotNullAttribute]
private ICollection`1<TValue> myStorage;
    protected ILogger myLogger;
    public Lifetime myLifetime;
    private NotifyCollectionChangedEventHandler CollectionChanged;
    private PropertyChangedEventHandler PropertyChanged;
    [CompilerGeneratedAttribute]
private bool <SuppressItemErrors>k__BackingField;
    public bool IsNullValuesAllowed { get; }
    public bool IsUniqueItems { get; }
    public bool SuppressItemErrors { get; public set; }
    public ISignal`1<AddRemoveEventArgs`1<TValue>> AddRemove { get; }
    public ISignal`1<BeforeAddRemoveEventArgs`1<TValue>> BeforeAddRemove { get; }
    public int Count { get; }
    [NotNullAttribute]
public PropertyId`1<TValue> Id { get; }
    public bool IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public CollectionEvents`1(Lifetime lifetime, PropertyId`1<TValue> id, ICollection`1<TValue> storage, bool bUniqueItems, ILogger logger);
    [ObsoleteAttribute("Use overload with lifetime.")]
public CollectionEvents`1(string id, ICollection`1<TValue> storage, bool bUniqueItems);
    public CollectionEvents`1(Lifetime lifetime, string id, ICollection`1<TValue> storage, bool bUniqueItems);
    [ObsoleteAttribute("Use overload with lifetime.")]
public CollectionEvents`1(string id);
    public CollectionEvents`1(Lifetime lifetime, string id);
    protected CollectionEvents`1(SerializationInfo info, StreamingContext context);
    private static CollectionEvents`1();
    public bool get_IsNullValuesAllowed();
    public bool get_IsUniqueItems();
    [CompilerGeneratedAttribute]
public bool get_SuppressItemErrors();
    [CompilerGeneratedAttribute]
public void set_SuppressItemErrors(bool value);
    internal static void ThrowReadonlyFail(BeforeAddRemoveEventArgs`1<TValue> args, object tokenExpected);
    internal static void ThrowThreadAffinityFail(BeforeAddRemoveEventArgs`1<TValue> args, Thread threadExpected);
    protected void FireAddRemove(AddRemove action, TValue value, object cookie);
    protected bool FireBeforeAddRemove(AddRemove action, TValue value, object cookie);
    protected virtual void FireCollectionChanged(TValue value, AddRemove addremove);
    protected virtual void FireCollectionChanged(TValue value, int index, AddRemove addremove);
    protected void FirePropertyChanged(string name);
    protected virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [UsedImplicitlyAttribute]
protected virtual bool InternalAdd(TValue value, object cookie);
    [UsedImplicitlyAttribute]
protected virtual bool InternalRemove(TValue value, object cookie);
    private void InternalClear(object cookie);
    private void OnAcknowledgeSinkAddRemove(Action`1<AddRemoveEventArgs`1<TValue>> handler, AddRemove addremove);
    private bool OnAcknowledgeSinkBeforeAddRemove(Action`1<BeforeAddRemoveEventArgs`1<TValue>> handler);
    public virtual string ToString();
    public sealed virtual void add_CollectionChanged(NotifyCollectionChangedEventHandler value);
    public sealed virtual void remove_CollectionChanged(NotifyCollectionChangedEventHandler value);
    public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    public sealed virtual bool Add(TValue value, object cookie);
    public sealed virtual void Add(TValue item);
    public sealed virtual void AddRange(IEnumerable`1<TValue> items);
    public sealed virtual void Clear();
    public sealed virtual void Clear(object cookie);
    public sealed virtual bool Contains(TValue item);
    public sealed virtual void CopyTo(TValue[] array, int arrayIndex);
    public sealed virtual IEnumerator`1<TValue> GetEnumerator();
    public sealed virtual bool Modify(AddRemove action, TValue item, object cookie);
    public sealed virtual bool Remove(TValue value, object cookie);
    public sealed virtual bool Remove(TValue item);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual ISignal`1<AddRemoveEventArgs`1<TValue>> get_AddRemove();
    public sealed virtual TValue[] ToArray();
    public sealed virtual List`1<TValue> ToList();
    public sealed virtual ISignal`1<BeforeAddRemoveEventArgs`1<TValue>> get_BeforeAddRemove();
    public sealed virtual int get_Count();
    public sealed virtual PropertyId`1<TValue> get_Id();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    public sealed virtual void View(Lifetime lifetime, Action`2<Lifetime, TValue> viewer);
    [CompilerGeneratedAttribute]
private void <.ctor>b__0(Action`1<AddRemoveEventArgs`1<TValue>> handler);
    [CompilerGeneratedAttribute]
private void <.ctor>b__1(Action`1<AddRemoveEventArgs`1<TValue>> handler);
}
[DebuggerStepThroughAttribute]
public class JetBrains.DataFlow.CompositeProperty`3 : object {
    protected static ReadonlyToken myReadonlyToken;
    private ComposerDelegate<TSourceOne, TSourceTwo, TTarget> myComposer;
    private IProperty`1<TSourceOne> mySourceOne;
    private IProperty`1<TSourceTwo> mySourceTwo;
    private Property`1<TTarget> myTarget;
    public ComposerDelegate<TSourceOne, TSourceTwo, TTarget> Composer { get; }
    public IProperty`1<TSourceOne> SourceOne { get; }
    public IProperty`1<TSourceTwo> SourceTwo { get; }
    protected IProperty`1<TTarget> Target { get; }
    protected CompositeProperty`3(Lifetime lifetime, IProperty`1<TSourceOne> propertySourceOne, IProperty`1<TSourceTwo> propertySourceTwo, ComposerDelegate<TSourceOne, TSourceTwo, TTarget> composer);
    private static CompositeProperty`3();
    protected virtual Property`1<TTarget> DecorateProperty(Lifetime lifetime, Property`1<TTarget> property);
    public ComposerDelegate<TSourceOne, TSourceTwo, TTarget> get_Composer();
    public IProperty`1<TSourceOne> get_SourceOne();
    public IProperty`1<TSourceTwo> get_SourceTwo();
    [ObsoleteAttribute("Use overload with lifetime.")]
public static IProperty`1<TTarget> Create(IProperty`1<TSourceOne> propertySourceOne, IProperty`1<TSourceTwo> propertySourceTwo, ComposerDelegate<TSourceOne, TSourceTwo, TTarget> composer);
    public static IProperty`1<TTarget> Create(Lifetime lifetime, IProperty`1<TSourceOne> propertySourceOne, IProperty`1<TSourceTwo> propertySourceTwo, ComposerDelegate<TSourceOne, TSourceTwo, TTarget> composer);
    private void OnAnySourceChanged();
    protected IProperty`1<TTarget> get_Target();
}
[FlagsAttribute]
public enum JetBrains.DataFlow.DataFlowDirection : Enum {
    public int value__;
    public static DataFlowDirection None;
    public static DataFlowDirection FromSource;
    public static DataFlowDirection FromTarget;
    public static DataFlowDirection BothWays;
}
[ExtensionAttribute]
public static class JetBrains.DataFlow.DataFlowEx : object {
    [ExtensionAttribute]
public static void OnSignal(IPropertyBinding binding, Lifetime lifetime, ISignal`1<TSignal> signal, DataFlowDirection direction);
    [ExtensionAttribute]
public static ISimpleSignal AccumulateChange(IReadonlyCollectionEvents`1<E> col, Lifetime lifetime, Func`2<E, ISignal`1<T>> changeSignal);
    [ExtensionAttribute]
public static void AddLifetime(IContainer thіs, LifetimeDefinition lifetime);
}
[DefaultMemberAttribute("Item")]
[DebuggerStepThroughAttribute]
public class JetBrains.DataFlow.DictionaryEvents`2 : CollectionEvents`1<KeyValuePair`2<TKey, TValue>> {
    private static string ValueNameDictionaryStorage;
    private static string ValueNameNullPairKeysAllowed;
    private static string ValueNameNullPairValuesAllowed;
    private bool myNullPairKeysAllowed;
    private bool myNullPairValuesAllowed;
    [NotNullAttribute]
private IDictionary`2<TKey, TValue> myStorage;
    public bool NullPairKeysAllowed { get; }
    public bool NullPairValuesAllowed { get; }
    public TValue Item { get; public set; }
    public ICollection`1<TKey> Keys { get; }
    private IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Keys { get; }
    public ICollection`1<TValue> Values { get; }
    private IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Values { get; }
    public DictionaryEvents`2(Lifetime lifetime, PropertyId`1<KeyValuePair`2<TKey, TValue>> id, IDictionary`2<TKey, TValue> storage, bool bNullKeysAllowed, bool bNullValuesAllowed, ILogger logger);
    [ObsoleteAttribute("Should be lifetimed, or explicitly passed an eternal lifetime.")]
public DictionaryEvents`2(string id, ILogger logger);
    public DictionaryEvents`2(Lifetime lifetime, string id, ILogger logger);
    public DictionaryEvents`2(string id, bool bNullKeysAllowed, bool bNullValuesAllowed, ILogger logger);
    public DictionaryEvents`2(Lifetime lifetime, string id, bool bNullKeysAllowed, bool bNullValuesAllowed, ILogger logger);
    protected DictionaryEvents`2(SerializationInfo info, StreamingContext context);
    private static DictionaryEvents`2();
    public bool get_NullPairKeysAllowed();
    public bool get_NullPairValuesAllowed();
    protected virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    protected virtual bool InternalAdd(KeyValuePair`2<TKey, TValue> value, object cookie);
    protected virtual bool InternalRemove(KeyValuePair`2<TKey, TValue> value, object cookie);
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    public sealed virtual void Add(TKey key, TValue value);
    public sealed virtual bool ContainsKey(TKey key);
    public sealed virtual bool Remove(TKey key);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    public sealed virtual TValue TryGetValue(TKey key, Func`1<TValue> funcCreateIfMissing);
    public sealed virtual ICollection`1<TKey> get_Keys();
    private sealed virtual override IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Keys();
    public sealed virtual ICollection`1<TValue> get_Values();
    private sealed virtual override IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Values();
    public void set_Item(TKey key, object cookie, TValue value);
}
[DebuggerStepThroughAttribute]
public static class JetBrains.DataFlow.Disposable : object {
    [NotNullAttribute]
public static IDisposable Empty;
    private static Disposable();
    [NotNullAttribute]
public static IDisposable CreateBracket(Action opening, Action closing, bool trapExceptions);
    public static IDisposable CreateCompositeDisposable(Func`1[] disposables);
    [NotNullAttribute]
public static IDisposable CreateAction(Action closing);
    [NotNullAttribute]
public static IDisposable CreateAction_FinalizableFreeThreaded(string id, Action closing, string messageFinalization, bool saveCtorCallStack);
    [NotNullAttribute]
public static IDisposable CreateBracket_FinalizableFreeThreaded(string id, Action opening, Action closing, string messageFinalization, bool saveCtorCallStack);
    [NotNullAttribute]
public static IDisposable CreateBracket_FinalizableSingleThreaded(string id, Action opening, Action closing, string messageFinalization, bool saveCtorCallStack);
}
[DebuggerStepThroughAttribute]
public class JetBrains.DataFlow.EventArgs`1 : EventArgs {
    protected TValue myValue;
    public TValue Value { get; }
    public EventArgs`1(TValue value);
    public TValue get_Value();
}
public interface JetBrains.DataFlow.ICollectionEvents`1 {
    public ISignal`1<BeforeAddRemoveEventArgs`1<TValue>> BeforeAddRemove { get; }
    public int Count { get; }
    public abstract virtual ISignal`1<BeforeAddRemoveEventArgs`1<TValue>> get_BeforeAddRemove();
    public abstract virtual int get_Count();
    public abstract virtual bool Add(TValue value, object cookie);
    public abstract virtual void AddRange(IEnumerable`1<TValue> items);
    public abstract virtual bool Modify(AddRemove action, TValue item, object cookie);
    public abstract virtual bool Remove(TValue value, object cookie);
    public abstract virtual void Clear(object cookie);
}
[ExtensionAttribute]
public static class JetBrains.DataFlow.ICollectionEventsEx : object {
    [ExtensionAttribute]
public static void BeginAdd(ICollectionEvents`1<TValue> thіs, Lifetime lifetimeAsyncOperation, JetDispatcher dispatcher, TValue item);
    [NotNullAttribute]
[ExtensionAttribute]
public static IProperty`1<int> CreateCount(IReadonlyCollectionEvents`1<TItem> thіs, Lifetime lifetime);
    [NotNullAttribute]
[ExtensionAttribute]
public static IProperty`1<bool> CreateIsEmpty(IReadonlyCollectionEvents`1<TItem> thіs, Lifetime lifetime);
    [ExtensionAttribute]
[NotNullAttribute]
public static IProperty`1<bool> CreateIsNotEmpty(IReadonlyCollectionEvents`1<TItem> thіs, Lifetime lifetime);
    [ExtensionAttribute]
public static void LogChanges(IReadonlyCollectionEvents`1<TValue> thіs, Lifetime lifetime, string prefix);
    [ExtensionAttribute]
public static void LogChanges(IReadonlyCollectionEvents`1<TValue> thіs, Lifetime lifetime, ILogger logger);
    [ExtensionAttribute]
public static void LogChanges(IReadonlyCollectionEvents`1<TValue> thіs, Lifetime lifetime, object logprefix);
    [ExtensionAttribute]
public static void ForEachItem(IReadonlyCollectionEvents`1<TValue> thіs, Lifetime lifetime, Action`2<Lifetime, TValue> FHandler);
    [ExtensionAttribute]
public static void ForEachItem(IReadonlyCollectionEvents`1<TValue> thіs, Lifetime lifetime, Action`3<Lifetime, TValue, object> FHandler);
    [ExtensionAttribute]
private static void ForEachItemCore(IReadonlyCollectionEvents`1<TValue> thіs, Lifetime lifetime, Action`2<Lifetime, TValue> FHandlerA, Action`3<Lifetime, TValue, object> FHandlerB);
    [ExtensionAttribute]
public static void ForEachItemFreeThreaded(IReadonlyCollectionEvents`1<TValue> thіs, Lifetime lifetime, Action`2<Lifetime, TValue> FHandler);
    [ExtensionAttribute]
public static void ForEachItemFreeThreaded(IReadonlyCollectionEvents`1<TValue> thіs, Lifetime lifetime, Action`3<Lifetime, TValue, object> FHandler);
    [ExtensionAttribute]
private static void ForEachItemFreeThreadedCore(IReadonlyCollectionEvents`1<TValue> thіs, Lifetime lifetimeUnsync, Action`2<Lifetime, TValue> FHandlerA, Action`3<Lifetime, TValue, object> FHandlerB);
    [ExtensionAttribute]
public static void Add(ICollectionEvents`1<TValue> thіs, Lifetime lifetime, TValue value, object cookie);
    [ExtensionAttribute]
public static void Insert(IListEvents`1<TValue> thіs, Lifetime lifetime, int index, TValue value, object cookie);
    [ExtensionAttribute]
public static void FlowInto(IReadonlyCollectionEvents`1<TSource> source, Lifetime lifetime, ICollectionEvents`1<TTarget> target, Func`2<TSource, TTarget> FConvert, Func`2<TSource, bool> FFilter, object cookie);
    [ExtensionAttribute]
public static void FlowInto(IReadonlyCollectionEvents`1<TSource> source, Lifetime lifetime, ICollectionEvents`1<TTarget> target, Func`3<Lifetime, TSource, TTarget> FConvert, Func`2<TSource, bool> FFilter, object cookie);
    private static void FlowIntoCollectionCore(Lifetime lifetime, IReadonlyCollectionEvents`1<TSource> source, ICollectionEvents`1<TTarget> target, Func`2<TSource, TTarget> FConvert, Func`3<Lifetime, TSource, TTarget> FLifeConvert, Func`2<TSource, bool> FFilter, object cookie);
    [ExtensionAttribute]
public static void FlowInto(IReadonlyListEvents`1<TSource> source, Lifetime lifetime, IListEvents`1<TTarget> target, Func`2<TSource, TTarget> FConvert, object cookie);
    [ExtensionAttribute]
public static void FlowInto(IReadonlyListEvents`1<TSource> source, Lifetime lifetime, IListEvents`1<TTarget> target, Func`3<Lifetime, TSource, TTarget> FConvert, object cookie);
    [ExtensionAttribute]
public static void FlowInto(IReadonlyListEvents`1<TSource> source, Lifetime lifetime, IListEvents`1<TTarget> target);
    private static void FlowIntoListCore(Lifetime lifetime, IReadonlyListEvents`1<TSource> source, IListEvents`1<TTarget> target, Func`2<TSource, TTarget> FConvert, Func`3<Lifetime, TSource, TTarget> FLifeConvert, object cookie);
    [ExtensionAttribute]
public static void DisposeEachItem(ICollectionEvents`1<TValue> thіs, Lifetime lifetime);
    [ExtensionAttribute]
public static void FlowIntoGuarded_NoReplay(ICollectionEvents`1<TValue> source, Lifetime lifetime, ICollectionEvents`1<TValue> target, ReentrancyGuard reega, bool bReplicateInitialValuesImmediately, object token);
    [ExtensionAttribute]
public static void FlowIntoGrouped_NoReplay(ICollectionEvents`1<TValue> source, Lifetime lifetime, ICollectionEvents`1<TValue> target, GroupingEventHost gehost, TimeSpan delay, bool bReplicateInitialValuesImmediately, object token);
    [ExtensionAttribute]
public static void FlowIntoGrouped_NoReplay(IReadonlyCollectionEvents`1<TValue> source, Lifetime lifetime, ICollectionEvents`1<TValue> target, Action FAssertCanExecuteNow, Action`1<Action> FExecuteGrouped, bool bReplicateInitialValuesImmediately, object token);
    [ExtensionAttribute]
public static void FlowIntoSorted(IReadonlyCollectionEvents`1<TItem> source, Lifetime lifetime, IListEvents`1<TItem> target, IComparer`1<TItem> comparerForSorting, IEqualityComparer`1<TItem> comparerForDeleting, Func`2<TItem, bool> FFilter, object cookie);
    [NotNullAttribute]
[ExtensionAttribute]
public static Lifetime GetLifetimeOfItem(IReadonlyCollectionEvents`1<TItem> thіs, Lifetime lifetime, TItem item);
    [ExtensionAttribute]
public static void AddItemUnderLifetime(ICollectionEvents`1<TItem> thіs, Lifetime lifetimeOuter, Func`3<Lifetime, LifetimeDefinition, TItem> FCreateItem);
    [CompilerGeneratedAttribute]
private static void <DisposeEachItem>b__6d(Lifetime lifetimeValue, TValue item);
}
[ExtensionAttribute]
public static class JetBrains.DataFlow.ICollectionEventsEx_ObsoleteWithoutLifetime : object {
    [ExtensionAttribute]
[ObsoleteAttribute("Use overload with lifetime.")]
public static void BeginAdd(ICollectionEvents`1<TValue> coll, JetDispatcher dispatcher, TValue item);
    [NotNullAttribute]
[ExtensionAttribute]
[ObsoleteAttribute("Use overload with lifetime.")]
public static IDisposable BridgeInto_Guarded_Slow(ICollectionEvents`1<TValue> source, ICollectionEvents`1<TValue> target, ReentrancyGuard reega, object token);
    [ExtensionAttribute]
[NotNullAttribute]
[ObsoleteAttribute("Use overload with lifetime.")]
public static IDisposable PushForEachItem(ICollectionEvents`1<TValue> coll, Func`2<TValue, IDisposable> handler);
    [ExtensionAttribute]
[NotNullAttribute]
[ObsoleteAttribute("Use overload with lifetime.")]
private static IDisposable PushForEachItem(ICollectionEvents`1<TValue> coll, Func`2<AddRemoveEventArgs`1<TValue>, IDisposable> handler);
}
[ExtensionAttribute]
public static class JetBrains.DataFlow.ICollectionSignalEx : object {
    [ExtensionAttribute]
public static void Advise_Add(ISignal`1<AddRemoveEventArgs`1<TValue>> thіs, Lifetime lifetime, Action`1<AddRemoveEventArgs`1<TValue>> FHandler);
    [ExtensionAttribute]
public static void Advise_Add(ISignal`1<AddRemoveIndexEventArgs`1<TValue>> thіs, Lifetime lifetime, Action`1<AddRemoveIndexEventArgs`1<TValue>> FHandler);
    [ExtensionAttribute]
public static void Advise_Remove(ISignal`1<AddRemoveEventArgs`1<TValue>> thіs, Lifetime lifetime, Action`1<AddRemoveEventArgs`1<TValue>> FHandler);
    [ExtensionAttribute]
public static void Advise_Remove(ISignal`1<AddRemoveIndexEventArgs`1<TValue>> thіs, Lifetime lifetime, Action`1<AddRemoveIndexEventArgs`1<TValue>> FHandler);
    [ExtensionAttribute]
public static void Advise_NoAcknowledgement(ISignal`1<BeforeAddRemoveEventArgs`1<TValue>> thіs, Lifetime lifetime, Action`1<BeforeAddRemoveEventArgs`1<TValue>> FHandler);
    [ExtensionAttribute]
public static void Advise_NoAcknowledgement(ISignal`1<BeforeAddRemoveEventArgs`1<TValue>> thіs, Lifetime lifetime, Action FHandler);
    [ExtensionAttribute]
public static void Advise_NoAcknowledgement(ISignal`1<AddRemoveEventArgs`1<TValue>> thіs, Lifetime lifetime, Action`1<AddRemoveEventArgs`1<TValue>> FHandler);
    [ExtensionAttribute]
public static void Advise_NoAcknowledgement(ISignal`1<AddRemoveIndexEventArgs`1<TValue>> thіs, Lifetime lifetime, Action`1<AddRemoveEventArgs`1<TValue>> FHandler);
    [ExtensionAttribute]
public static void Advise_NoAcknowledgement(ISignal`1<AddRemoveEventArgs`1<TValue>> thіs, Lifetime lifetime, Action FHandler);
    [ExtensionAttribute]
public static void Advise_NoAcknowledgement(ISignal`1<AddRemoveIndexEventArgs`1<TValue>> thіs, Lifetime lifetime, Action FHandler);
}
[ExtensionAttribute]
public static class JetBrains.DataFlow.ICollectionSignalEx_ObsoleteWithoutLifetime : object {
    [NotNullAttribute]
[ExtensionAttribute]
[ObsoleteAttribute("Use overload with lifetime.")]
public static IDisposable Advise_Add(ISignal`1<AddRemoveIndexEventArgs`1<TValue>> thіs, Action`1<AddRemoveIndexEventArgs`1<TValue>> handler);
    [NotNullAttribute]
[ObsoleteAttribute("Use overload with lifetime.")]
[ExtensionAttribute]
public static IDisposable Advise_Remove(ISignal`1<AddRemoveEventArgs`1<TValue>> signal, Action`1<AddRemoveEventArgs`1<TValue>> handler);
    [ExtensionAttribute]
[ObsoleteAttribute("Use overload with lifetime.")]
[NotNullAttribute]
public static IDisposable Advise_Remove(ISignal`1<AddRemoveIndexEventArgs`1<TValue>> signal, Action`1<AddRemoveIndexEventArgs`1<TValue>> handler);
    [ObsoleteAttribute("Use overload with lifetime.")]
[ExtensionAttribute]
[NotNullAttribute]
public static IDisposable Advise_NoAcknowledgement(ISignal`1<BeforeAddRemoveEventArgs`1<TValue>> signal, Action`1<BeforeAddRemoveEventArgs`1<TValue>> handler);
    [ExtensionAttribute]
[NotNullAttribute]
[ObsoleteAttribute("Use overload with lifetime.")]
public static IDisposable Advise_NoAcknowledgement(ISignal`1<BeforeAddRemoveEventArgs`1<TValue>> signal, Action handler);
    [NotNullAttribute]
[ExtensionAttribute]
[ObsoleteAttribute("Use overload with lifetime.")]
public static IDisposable Advise_NoAcknowledgement(ISignal`1<AddRemoveEventArgs`1<TValue>> signal, Action`1<AddRemoveEventArgs`1<TValue>> handler);
    [NotNullAttribute]
[ObsoleteAttribute("Use overload with lifetime.")]
[ExtensionAttribute]
public static IDisposable Advise_NoAcknowledgement(ISignal`1<AddRemoveEventArgs`1<TValue>> signal, Action handler);
    [ObsoleteAttribute("Use overload with lifetime.")]
[NotNullAttribute]
[ExtensionAttribute]
public static IDisposable Advise_NoAcknowledgement(ISignal`1<AddRemoveIndexEventArgs`1<TValue>> signal, Action handler);
}
[DefaultMemberAttribute("Item")]
public interface JetBrains.DataFlow.IDictionaryEvents`2 {
    [NotNullAttribute]
public ICollection`1<TKey> Keys { get; }
    [NotNullAttribute]
public ICollection`1<TValue> Values { get; }
    public TValue Item { get; public set; }
    public abstract virtual TValue TryGetValue(TKey key, Func`1<TValue> funcCreateIfMissing);
    public abstract virtual ICollection`1<TKey> get_Keys();
    public abstract virtual ICollection`1<TValue> get_Values();
    public abstract virtual bool ContainsKey(TKey key);
    public abstract virtual TValue get_Item(TKey key);
    public abstract virtual void set_Item(TKey key, TValue value);
    public abstract virtual bool TryGetValue(TKey key, TValue& value);
}
public interface JetBrains.DataFlow.IHaveUntypedProperty {
    [NotNullAttribute]
public IUntypedProperty AsUntyped { get; }
    public abstract virtual IUntypedProperty get_AsUntyped();
}
[DefaultMemberAttribute("Item")]
public interface JetBrains.DataFlow.IListEvents`1 {
    public TValue Item { get; public set; }
    public ISignal`1<BeforeAddRemoveIndexEventArgs`1<TValue>> BeforeAddRemove { get; }
    public abstract virtual TValue get_Item(int index);
    public abstract virtual void set_Item(int index, TValue value);
    public abstract virtual ISignal`1<BeforeAddRemoveIndexEventArgs`1<TValue>> get_BeforeAddRemove();
    public abstract virtual bool Modify(AddRemove action, TValue item, int index, object cookie);
    public abstract virtual bool Modify(AddRemove action, Func`1<TValue> funcGetItemIfAdding, int index, object cookie);
}
public class JetBrains.DataFlow.Infra.SignalWithDelegates`1 : Signal`1<TValue> {
    [CompilerGeneratedAttribute]
private Action`1<Action`1<TValue>> <AfterAdviseHandler>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`1<Action`1<TValue>> <AfterUnadviseHandler>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<Action`1<TValue>, bool> <BeforeAdviseHandler>k__BackingField;
    public Action`1<Action`1<TValue>> AfterAdviseHandler { get; public set; }
    public Action`1<Action`1<TValue>> AfterUnadviseHandler { get; public set; }
    public Func`2<Action`1<TValue>, bool> BeforeAdviseHandler { get; public set; }
    public SignalWithDelegates`1(Lifetime lifetime, string id, ILogger logger);
    [CompilerGeneratedAttribute]
public Action`1<Action`1<TValue>> get_AfterAdviseHandler();
    [CompilerGeneratedAttribute]
public void set_AfterAdviseHandler(Action`1<Action`1<TValue>> value);
    [CompilerGeneratedAttribute]
public Action`1<Action`1<TValue>> get_AfterUnadviseHandler();
    [CompilerGeneratedAttribute]
public void set_AfterUnadviseHandler(Action`1<Action`1<TValue>> value);
    [CompilerGeneratedAttribute]
public Func`2<Action`1<TValue>, bool> get_BeforeAdviseHandler();
    [CompilerGeneratedAttribute]
public void set_BeforeAdviseHandler(Func`2<Action`1<TValue>, bool> value);
    protected virtual void OnAfterAdvise(Action`1<TValue> handler);
    protected virtual void OnAfterUnadvise(Action`1<TValue> handler);
    protected virtual bool OnBeforeAdvise(Action`1<TValue> handler);
}
public class JetBrains.DataFlow.Infra.SimpleSignalWithDelegates : SimpleSignal {
    [CompilerGeneratedAttribute]
private Action`1<Action`1<bool>> <AfterAdviseHandler>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`1<Action`1<bool>> <AfterUnadviseHandler>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<Action`1<bool>, bool> <BeforeAdviseHandler>k__BackingField;
    public Action`1<Action`1<bool>> AfterAdviseHandler { get; public set; }
    public Action`1<Action`1<bool>> AfterUnadviseHandler { get; public set; }
    public Func`2<Action`1<bool>, bool> BeforeAdviseHandler { get; public set; }
    public SimpleSignalWithDelegates(Lifetime lifetime, string id, ILogger logger);
    [CompilerGeneratedAttribute]
public Action`1<Action`1<bool>> get_AfterAdviseHandler();
    [CompilerGeneratedAttribute]
public void set_AfterAdviseHandler(Action`1<Action`1<bool>> value);
    [CompilerGeneratedAttribute]
public Action`1<Action`1<bool>> get_AfterUnadviseHandler();
    [CompilerGeneratedAttribute]
public void set_AfterUnadviseHandler(Action`1<Action`1<bool>> value);
    [CompilerGeneratedAttribute]
public Func`2<Action`1<bool>, bool> get_BeforeAdviseHandler();
    [CompilerGeneratedAttribute]
public void set_BeforeAdviseHandler(Func`2<Action`1<bool>, bool> value);
    protected virtual void OnAfterAdvise(Action`1<bool> handler);
    protected virtual void OnAfterUnadvise(Action`1<bool> handler);
    protected virtual bool OnBeforeAdvise(Action`1<bool> handler);
}
[DebuggerStepThroughAttribute]
public class JetBrains.DataFlow.InOutEventArgs`2 : EventArgs {
    private TIn myIn;
    [CompilerGeneratedAttribute]
private TOut <Out>k__BackingField;
    public TIn In { get; }
    public TOut Out { get; public set; }
    public InOutEventArgs`2(TIn in, TOut out);
    public InOutEventArgs`2(TIn in);
    public TIn get_In();
    [CompilerGeneratedAttribute]
public TOut get_Out();
    [CompilerGeneratedAttribute]
public void set_Out(TOut value);
}
public interface JetBrains.DataFlow.IProperty`1 {
    public ISignal`1<BeforePropertyChangedEventArgs`1<TValue>> BeforeChange { get; }
    public ISignal`1<PropertyChangedEventArgs`1<TValue>> Change { get; }
    [NotNullAttribute]
public PropertyId`1<TValue> Id { get; }
    public TValue Value { get; public set; }
    public bool IsNullValueAllowed { get; }
    public abstract virtual ISignal`1<BeforePropertyChangedEventArgs`1<TValue>> get_BeforeChange();
    public abstract virtual ISignal`1<PropertyChangedEventArgs`1<TValue>> get_Change();
    public abstract virtual PropertyId`1<TValue> get_Id();
    public abstract virtual TValue get_Value();
    public abstract virtual void set_Value(TValue value);
    public abstract virtual bool get_IsNullValueAllowed();
    public abstract virtual TValue GetValue();
    public abstract virtual TValue GetValue(object cookie);
    public abstract virtual bool SetValue(TValue value);
    public abstract virtual bool SetValue(TValue value, object cookie);
}
public interface JetBrains.DataFlow.IPropertyBag {
    [NotNullAttribute]
public IUntypedPropertyBag AsUntyped { get; }
    [NotNullAttribute]
public IDictionaryEvents`2<PropertyId, IUntypedProperty> Properties { get; }
    public abstract virtual bool Contains(PropertyId`1<T> id);
    public abstract virtual T Get(PropertyId`1<T> id);
    [NotNullAttribute]
public abstract virtual IProperty`1<T> GetOrCreateProperty(PropertyId`1<T> id, T defaultvalue, Nullable`1<bool> isNullValueAllowed);
    [NotNullAttribute]
public abstract virtual IProperty`1<T> GetProperty(PropertyId`1<T> id);
    public abstract virtual bool Remove(PropertyId`1<T> id);
    public abstract virtual void Set(PropertyId`1<T> id, T value);
    public abstract virtual bool TryGet(PropertyId`1<T> id, T& value);
    [CanBeNullAttribute]
public abstract virtual T TryGet(PropertyId`1<T> id);
    public abstract virtual IUntypedPropertyBag get_AsUntyped();
    public abstract virtual IDictionaryEvents`2<PropertyId, IUntypedProperty> get_Properties();
}
[ExtensionAttribute]
public static class JetBrains.DataFlow.IPropertyBagEx : object {
    [CompilerGeneratedAttribute]
private static Func`2<MethodInfo, bool> CS$<>9__CachedAnonymousMethodDelegate4;
    [CompilerGeneratedAttribute]
private static Func`2<MethodInfo, bool> CS$<>9__CachedAnonymousMethodDelegate5;
    [CompilerGeneratedAttribute]
private static Func`2<MethodInfo, bool> CS$<>9__CachedAnonymousMethodDelegate6;
    [ExtensionAttribute]
public static void LogChanges(IPropertyBag thіs, Lifetime lifetime, string prefix);
    [CompilerGeneratedAttribute]
private static bool <LogChanges>b__0(MethodInfo mt);
    [CompilerGeneratedAttribute]
private static bool <LogChanges>b__1(MethodInfo mt);
    [CompilerGeneratedAttribute]
private static bool <LogChanges>b__2(MethodInfo mt);
}
public interface JetBrains.DataFlow.IPropertyBinding {
    public DataFlowDirection Direction { get; }
    public IUntypedProperty Source { get; }
    public IUntypedProperty Target { get; }
    public abstract virtual DataFlowDirection get_Direction();
    public abstract virtual IUntypedProperty get_Source();
    public abstract virtual IUntypedProperty get_Target();
    public abstract virtual void CopySourceToTarget();
    public abstract virtual void CopyTargetToSource();
}
public interface JetBrains.DataFlow.IPropertyBinding`2 {
    public IProperty`1<IProperty`1<TSource>> Source { get; }
    public IProperty`1<IProperty`1<TTarget>> Target { get; }
    [NotNullAttribute]
public IPropertyBinding AsUntyped { get; }
    public DataFlowDirection Direction { get; }
    public abstract virtual IProperty`1<IProperty`1<TSource>> get_Source();
    public abstract virtual IProperty`1<IProperty`1<TTarget>> get_Target();
    public abstract virtual IPropertyBinding get_AsUntyped();
    public abstract virtual DataFlowDirection get_Direction();
    public abstract virtual void CopySourceToTarget();
    public abstract virtual void CopyTargetToSource();
}
public interface JetBrains.DataFlow.IPropertyChangedEventArgs {
    public bool HasNew { get; }
    public bool HasOld { get; }
    public abstract virtual bool get_HasNew();
    public abstract virtual bool get_HasOld();
}
[ExtensionAttribute]
public static class JetBrains.DataFlow.IPropertyEx : object {
    private static ILogger ourLogger;
    [CompilerGeneratedAttribute]
private static Func`2<Type, Type> CS$<>9__CachedAnonymousMethodDelegate64;
    private static IPropertyEx();
    [ExtensionAttribute]
public static void BeginSetValue(IProperty`1<TValue> property, Lifetime lifetime, JetDispatcher dispatcher, TValue value, object cookie);
    [NotNullAttribute]
[ExtensionAttribute]
public static IProperty`1<TTarget> Cast(IUntypedProperty propSource, Lifetime lifetime);
    [ExtensionAttribute]
public static void FlowDeferredInto(IProperty`1<TValue> source, Lifetime lifetime, IProperty`1<TValue> target);
    [ExtensionAttribute]
public static void FlowDeferredInto(IProperty`1<TSource> source, Lifetime lifetime, IProperty`1<TTarget> target, Func`2<TSource, TTarget> FConvert);
    [ExtensionAttribute]
public static void FlowDeferredInto(IProperty`1<TSource> source, Lifetime lifetime, JetDispatcher dispatcher, IProperty`1<TTarget> target, Func`2<TSource, TTarget> FConvert);
    [ExtensionAttribute]
public static void FlowDeferredInto(IProperty`1<TValue> source, Lifetime lifetime, JetDispatcher dispatcher, IProperty`1<TValue> target);
    [ExtensionAttribute]
public static void FlowInto(IProperty`1<TValue> source, Lifetime lifetime, IProperty`1<TValue> target);
    [ExtensionAttribute]
public static void FlowInto(IProperty`1<TSource> source, Lifetime lifetime, IProperty`1<TTarget> target, Func`2<TSource, TTarget> FConverter);
    [ExtensionAttribute]
public static void FlowChangesInto(IProperty`1<TValue> source, Lifetime lifetime, IProperty`1<TValue> target);
    [ExtensionAttribute]
public static void FlowChangesInto(IProperty`1<TSource> source, Lifetime lifetime, IProperty`1<TTarget> target, Func`2<TSource, TTarget> FConverter);
    [ExtensionAttribute]
public static void FlowIntoReadonly(IProperty`1<TSource> source, Lifetime lifetime, IProperty`1<TTarget> target, Func`2<TSource, TTarget> FConverter, ReadonlyToken token);
    [ExtensionAttribute]
public static void FlowIntoReadonly(IProperty`1<TValue> source, Lifetime lifetime, IProperty`1<TValue> target, ReadonlyToken token);
    [ExtensionAttribute]
public static void FlowIntoViaGroupingEvent(IProperty`1<TValue> source, Lifetime lifetime, IProperty`1<TValue> target, GroupingEvent grouper, bool prolongate, ReadonlyToken token);
    [ObsoleteAttribute("Please use FlowIntoViaGroupingEvent instead")]
[ExtensionAttribute]
public static void FlowInto_Grouped(IProperty`1<TValue> source, Lifetime lifetime, IProperty`1<TValue> target, GroupingEvent grouper, ReadonlyToken token);
    [NotNullAttribute]
[ExtensionAttribute]
public static IProperty`1<bool> Invert(IProperty`1<bool> property, Lifetime lifetime);
    [ExtensionAttribute]
public static void LogChanges(IProperty`1<TValue> property, Lifetime lifetime, string prefix);
    [ExtensionAttribute]
public static void LogChangesAndStacktraces(IProperty`1<TValue> property, Lifetime lifetime);
    [ExtensionAttribute]
public static void LogChanges(IProperty`1<TValue> property, Lifetime lifetime, object logprefix);
    [ExtensionAttribute]
public static IProperty`1<TValue> LogChanges(IProperty`1<TValue> property, Lifetime lifetime, ILogger logger);
    [ExtensionAttribute]
[NotNullAttribute]
public static Property`1<TValue> LogChanges(Property`1<TValue> property, ILogger logger);
    [ExtensionAttribute]
[NotNullAttribute]
public static IProperty`1<bool> MakeFlag(IProperty`1<TValue> prop, Lifetime lifetime, Func`2<TValue, bool> FCondition, string sConditionName);
    [ExtensionAttribute]
[NotNullAttribute]
public static IProperty`1<bool> MakeFlag_NotNull(IProperty`1<TValue> prop, Lifetime lifetime);
    [ExtensionAttribute]
[NotNullAttribute]
public static IProperty`1<TTarget> OfType(IUntypedProperty propSource, Lifetime lifetime);
    [ExtensionAttribute]
public static void ForEachValue(IProperty`1<TValue> property, Lifetime lifetime, Action`2<Lifetime, TValue> FHandler);
    [ExtensionAttribute]
public static void ForEachValue(IProperty`1<TValue> property, Lifetime lifetime, Action`3<Lifetime, TValue, object> FHandler);
    [ExtensionAttribute]
public static void ForEachValue(IProperty`1<TValue> property, Lifetime lifetime, Func`2<TValue, bool> FCondition, Action`2<Lifetime, TValue> FHandler);
    [ExtensionAttribute]
public static void ForEachValue(IProperty`1<TValue> property, Lifetime lifetime, Func`2<TValue, bool> FCondition, Action`3<Lifetime, TValue, object> FHandler);
    [ExtensionAttribute]
public static void DisposeEachValue(IProperty`1<TValue> property, Lifetime lifetime);
    [ExtensionAttribute]
public static void ForEachValue_NotNull(IProperty`1<TValue> property, Lifetime lifetime, Action`2<Lifetime, TValue> FHandler);
    [ExtensionAttribute]
public static void SetValue(IProperty`1<TValue> property, Lifetime lifetime, TValue value, object cookie);
    [ExtensionAttribute]
public static void When(IProperty`1<T> property, Lifetime lifetime, T value, Action`1<Lifetime> FHandler);
    [ExtensionAttribute]
public static void WhenTrue(IProperty`1<bool> property, Lifetime lifetime, Action`1<Lifetime> FHandler);
    [ExtensionAttribute]
public static void WhenTrueOnce(IProperty`1<bool> property, Lifetime lifetime, Action FHandler);
    [ExtensionAttribute]
public static void WhenFalseOnce(IProperty`1<bool> property, Lifetime lifetime, Action FHandler);
    [ExtensionAttribute]
public static void WhenFalse(IProperty`1<bool> property, Lifetime lifetime, Action`1<Lifetime> FHandler);
    [ExtensionAttribute]
public static void WhenNotNull(IProperty`1<T> property, Lifetime lifetime, Action`2<Lifetime, T> FHandler);
    [ExtensionAttribute]
public static void WhenNotNull(IProperty`1<T> property, Lifetime lifetime, Action`3<Lifetime, T, object> FHandler);
    [ExtensionAttribute]
[NotNullAttribute]
public static IProperty`1<TTarget> Select(IProperty`1<TSource> propSource, Lifetime lifetime, string comment, Func`2<TSource, TTarget> FSelect);
    [ExtensionAttribute]
public static bool WaitForValue(IProperty`1<T> property, OuterLifetime lifetime, Predicate`1<T> valueCondition, int waitIntervalBetweenChecksMillis);
    [NotNullAttribute]
[ExtensionAttribute]
public static IProperty`1<TTarget> Select(IProperty`1<TSource> propSource, Lifetime lifetime, string comment, Func`3<Lifetime, TSource, TTarget> FSelect);
    [CanBeNullAttribute]
public static Type TryGetPropertyType(Type type);
    [ExtensionAttribute]
private static void FlowDeferredIntoCore(IProperty`1<TSource> source, Lifetime lifetime, Func`1<JetDispatcher> FGetDispatcher, IProperty`1<TTarget> target, Func`2<TSource, TTarget> FConvert);
    public static IUntypedProperty CreateUntypedProperty(Lifetime lifetime, PropertyId id, object value, Nullable`1<bool> isNullValueAllowed, ILogger logger);
    [ExtensionAttribute]
public static void SetValueUnderLifetime(IProperty`1<TValue> property, Lifetime lifeOuter, Func`2<Lifetime, TValue> FCreateValue);
    [CompilerGeneratedAttribute]
private static JetDispatcher <FlowDeferredInto>b__e();
    [CompilerGeneratedAttribute]
private static TValue <FlowDeferredInto>b__f(TValue x);
    [CompilerGeneratedAttribute]
private static JetDispatcher <FlowDeferredInto>b__10();
    [CompilerGeneratedAttribute]
private static TValue <FlowDeferredInto>b__15(TValue x);
    [CompilerGeneratedAttribute]
private static void <LogChangesAndStacktraces>b__30(PropertyChangedEventArgs`1<TValue> args);
    [CompilerGeneratedAttribute]
private static bool <MakeFlag_NotNull>b__34(TValue value);
    [CompilerGeneratedAttribute]
private static bool <DisposeEachValue>b__41(TValue value);
    [CompilerGeneratedAttribute]
private static void <DisposeEachValue>b__42(Lifetime lifetimeValue, TValue value);
    [CompilerGeneratedAttribute]
private static bool <ForEachValue_NotNull>b__43(TValue value);
    [CompilerGeneratedAttribute]
private static Type <TryGetPropertyType>b__63(Type intf);
}
[ExtensionAttribute]
public static class JetBrains.DataFlow.IPropertyEx_ObsoleteWithoutLifetime : object {
    [ObsoleteAttribute("Use ForEachValue overload with lifetime.")]
[ExtensionAttribute]
[NotNullAttribute]
public static IDisposable PushForEachValue(IProperty`1<TValue> property, Func`2<TValue, IDisposable> handler);
    [ExtensionAttribute]
[NotNullAttribute]
[ObsoleteAttribute("Use SetValue overload with lifetime.")]
public static IDisposable PushValue(IProperty`1<TValue> property, TValue value, object cookie);
    [NotNullAttribute]
[ExtensionAttribute]
[ObsoleteAttribute("Use SetValue overload with lifetime.")]
public static IDisposable PushValue(IProperty`1<TValue> property, TValue value);
    [NotNullAttribute]
[ObsoleteAttribute("Use overload with lifetime.")]
[ExtensionAttribute]
public static IDisposable FlowInto(IProperty`1<TValue> source, IProperty`1<TValue> target);
    [ExtensionAttribute]
[ObsoleteAttribute("Use overload with lifetime.")]
[NotNullAttribute]
public static IDisposable FlowInto(IProperty`1<TSource> source, IProperty`1<TTarget> target, Func`2<TSource, TTarget> converter);
    [ExtensionAttribute]
[NotNullAttribute]
[ObsoleteAttribute("Use overload with lifetime.")]
public static IDisposable LogChanges(IProperty`1<TValue> property, string prefix);
    [ExtensionAttribute]
[NotNullAttribute]
[ObsoleteAttribute("Use overload with lifetime.")]
public static IDisposable LogChanges(IProperty`1<TValue> property, object logprefix);
}
[ExtensionAttribute]
public static class JetBrains.DataFlow.IPropertySignalEx : object {
    [ExtensionAttribute]
public static void Advise_FallingFront(ISignal`1<PropertyChangedEventArgs`1<TValue>> thіs, Lifetime lifetime, Action FHandler);
    [ExtensionAttribute]
public static void Advise_FallingFront(ISignal`1<PropertyChangedEventArgs`1<TValue>> thіs, Lifetime lifetime, Action`1<PropertyChangedEventArgs`1<TValue>> FHandler);
    [ExtensionAttribute]
public static void Advise_FallingFrontHasNew(ISignal`1<PropertyChangedEventArgs`1<bool>> signal, Lifetime lifetime, Action handler);
    [ExtensionAttribute]
public static void Advise_HasNew(ISignal`1<PropertyChangedEventArgs`1<TValue>> thіs, Lifetime lifetime, Action`1<PropertyChangedEventArgs`1<TValue>> FHandler);
    [ExtensionAttribute]
public static void Advise_HasNew(ISignal`1<PropertyChangedEventArgs`1<TValue>> thіs, Lifetime lifetime, Action FHandler);
    [ExtensionAttribute]
public static void Advise_HasOld(ISignal`1<PropertyChangedEventArgs`1<TValue>> thіs, Lifetime lifetime, Action`1<PropertyChangedEventArgs`1<TValue>> FHandler);
    [ExtensionAttribute]
public static void Advise_HasOld(ISignal`1<PropertyChangedEventArgs`1<TValue>> thіs, Lifetime lifetime, Action FHandler);
    [ExtensionAttribute]
public static void Advise_NewNotNull(ISignal`1<PropertyChangedEventArgs`1<TValue>> thіs, Lifetime lifetime, Action`1<PropertyChangedEventArgs`1<TValue>> FHandler);
    [ExtensionAttribute]
public static void Advise_NewNotNull(ISignal`1<PropertyChangedEventArgs`1<TValue>> thіs, Lifetime lifetime, Action FHandler);
    [ExtensionAttribute]
public static void Advise_NoAcknowledgement(ISignal`1<PropertyChangedEventArgs`1<TValue>> thіs, Lifetime lifetime, Action`1<PropertyChangedEventArgs`1<TValue>> FHandler);
    [ExtensionAttribute]
public static void Advise_NoAcknowledgement(ISignal`1<PropertyChangedEventArgs`1<TValue>> thіs, Lifetime lifetime, Action FHandler);
    [ExtensionAttribute]
public static void Advise_NoAcknowledgement(ISignal`1<BeforePropertyChangedEventArgs`1<TValue>> thіs, Lifetime lifetime, Action`1<BeforePropertyChangedEventArgs`1<TValue>> FHandler);
    [ExtensionAttribute]
public static void Advise_NoAcknowledgement(ISignal`1<BeforePropertyChangedEventArgs`1<TValue>> thіs, Lifetime lifetime, Action FHandler);
    [ExtensionAttribute]
public static void Advise_OldNotNull(ISignal`1<BeforePropertyChangedEventArgs`1<TValue>> thіs, Lifetime lifetime, Action`1<BeforePropertyChangedEventArgs`1<TValue>> FHandler);
    [ExtensionAttribute]
public static void Advise_HasNew(ISignal`1<BeforePropertyChangedEventArgs`1<TValue>> thіs, Lifetime lifetime, Action`1<BeforePropertyChangedEventArgs`1<TValue>> FHandler);
    [ExtensionAttribute]
public static void Advise_RaisingFront(ISignal`1<PropertyChangedEventArgs`1<TValue>> thіs, Lifetime lifetime, Action FHandler);
    [ExtensionAttribute]
public static void Advise_RaisingFront(ISignal`1<PropertyChangedEventArgs`1<TValue>> thіs, Lifetime lifetime, Action`1<PropertyChangedEventArgs`1<TValue>> FHandler);
    [ExtensionAttribute]
public static void Advise_When(ISignal`1<PropertyChangedEventArgs`1<TValue>> thіs, Lifetime lifetime, TValue valueWhen, Action FHandler);
    [ExtensionAttribute]
public static void Advise_When(ISignal`1<PropertyChangedEventArgs`1<TValue>> thіs, Lifetime lifetime, Func`2<TValue, bool> FFilter, Action`1<TValue> FHandler);
}
[ExtensionAttribute]
public static class JetBrains.DataFlow.IPropertySignalEx_ObsoleteWithoutLifetime : object {
    [ExtensionAttribute]
[ObsoleteAttribute("Use overload with lifetime.")]
[NotNullAttribute]
public static IDisposable Advise_FallingFront(ISignal`1<PropertyChangedEventArgs`1<TValue>> signal, Action handler);
    [ExtensionAttribute]
[NotNullAttribute]
[ObsoleteAttribute("Use overload with lifetime.")]
public static IDisposable Advise_FallingFront(ISignal`1<PropertyChangedEventArgs`1<TValue>> signal, Action`1<PropertyChangedEventArgs`1<TValue>> handler);
    [ExtensionAttribute]
[ObsoleteAttribute("Use overload with lifetime.")]
[NotNullAttribute]
public static IDisposable Advise_FallingFrontHasNew(ISignal`1<PropertyChangedEventArgs`1<bool>> signal, Action handler);
    [NotNullAttribute]
[ObsoleteAttribute("Use overload with lifetime.")]
[ExtensionAttribute]
public static IDisposable Advise_HasNew(ISignal`1<PropertyChangedEventArgs`1<TValue>> signal, Action`1<PropertyChangedEventArgs`1<TValue>> handler);
    [NotNullAttribute]
[ExtensionAttribute]
[ObsoleteAttribute("Use overload with lifetime.")]
public static IDisposable Advise_HasNew(ISignal`1<PropertyChangedEventArgs`1<TValue>> signal, Action handler);
    [ObsoleteAttribute("Use overload with lifetime.")]
[NotNullAttribute]
[ExtensionAttribute]
public static IDisposable Advise_NoAcknowledgement(ISignal`1<BeforePropertyChangedEventArgs`1<TValue>> signal, Action`1<BeforePropertyChangedEventArgs`1<TValue>> handler);
    [ExtensionAttribute]
[NotNullAttribute]
[ObsoleteAttribute("Use overload with lifetime.")]
public static IDisposable Advise_NoAcknowledgement(ISignal`1<PropertyChangedEventArgs`1<TValue>> signal, Action`1<PropertyChangedEventArgs`1<TValue>> handler);
    [NotNullAttribute]
[ExtensionAttribute]
[ObsoleteAttribute("Use overload with lifetime.")]
public static IDisposable Advise_NoAcknowledgement(ISignal`1<PropertyChangedEventArgs`1<TValue>> signal, Action handler);
    [ObsoleteAttribute("Use overload with lifetime.")]
[ExtensionAttribute]
[NotNullAttribute]
public static IDisposable Advise_NoAcknowledgement(ISignal`1<BeforePropertyChangedEventArgs`1<TValue>> signal, Action handler);
    [NotNullAttribute]
[ObsoleteAttribute("Use overload with lifetime.")]
[ExtensionAttribute]
public static IDisposable Advise_RaisingFront(ISignal`1<PropertyChangedEventArgs`1<TValue>> signal, Action handler);
    [ExtensionAttribute]
[NotNullAttribute]
[ObsoleteAttribute("Use overload with lifetime.")]
public static IDisposable Advise_RaisingFront(ISignal`1<PropertyChangedEventArgs`1<TValue>> signal, Action`1<PropertyChangedEventArgs`1<TValue>> handler);
    [NotNullAttribute]
[ExtensionAttribute]
[ObsoleteAttribute("Use overload with lifetime.")]
public static IDisposable Advise_When(ISignal`1<PropertyChangedEventArgs`1<TValue>> signal, Func`2<TValue, bool> filter, Action`1<TValue> handler);
}
public interface JetBrains.DataFlow.IReadonlyCollectionEvents`1 {
    public ISignal`1<AddRemoveEventArgs`1<TValue>> AddRemove { get; }
    [NotNullAttribute]
public PropertyId`1<TValue> Id { get; }
    public abstract virtual ISignal`1<AddRemoveEventArgs`1<TValue>> get_AddRemove();
    public abstract virtual PropertyId`1<TValue> get_Id();
    [NotNullAttribute]
public abstract virtual TValue[] ToArray();
    [NotNullAttribute]
public abstract virtual List`1<TValue> ToList();
}
public interface JetBrains.DataFlow.IReadonlyListEvents`1 {
    public ISignal`1<AddRemoveIndexEventArgs`1<TValue>> AddRemove { get; }
    public abstract virtual ISignal`1<AddRemoveIndexEventArgs`1<TValue>> get_AddRemove();
}
public interface JetBrains.DataFlow.ISignal`1 {
    [NotNullAttribute]
public PropertyId`1<TValue> Id { get; }
    [NotNullAttribute]
public IProperty`1<TValue> Property { get; }
    [NotNullAttribute]
public IUntypedSignal AsUntyped { get; }
    public abstract virtual PropertyId`1<TValue> get_Id();
    public abstract virtual IProperty`1<TValue> get_Property();
    public abstract virtual IUntypedSignal get_AsUntyped();
    public abstract virtual void Advise(Lifetime lifetime, Action`1<TValue> handler);
    public abstract virtual void Fire(TValue value);
    public abstract virtual void Fire(TValue value, object cookie);
}
[ExtensionAttribute]
public static class JetBrains.DataFlow.ISignalEx : object {
    [ExtensionAttribute]
public static void Advise(ISignal`1<TValue> thіs, Lifetime lifetime, Action handler);
    [ExtensionAttribute]
public static void Advise_InOut(ISignal`1<InOutEventArgs`2<TIn, TOut>> thіs, Lifetime lifetime, Func`2<TIn, TOut> F);
    [ExtensionAttribute]
public static void Advise_Out(ISignal`1<OutEventArgs`1<TOut>> thіs, Lifetime lifetime, Func`1<TOut> F);
    [ExtensionAttribute]
public static TOut FireInOut(ISignal`1<InOutEventArgs`2<TIn, TOut>> thіs, TIn in, TOut outDefault);
    [ExtensionAttribute]
public static void BeginFire(ISimpleSignal thіs, Lifetime lifetime, JetDispatcher dispatcher);
    [ExtensionAttribute]
public static void BeginFire(ISignal`1<TValue> thіs, Lifetime lifetime, JetDispatcher dispatcher, TValue value);
    [ExtensionAttribute]
public static void BeginFire(ISignal`1<TValue> thіs, Lifetime lifetime, JetDispatcher dispatcher, TValue value, object cookie);
    [ExtensionAttribute]
public static TValue Fire(ISignal`1<OutEventArgs`1<TValue>> thіs);
    [ExtensionAttribute]
public static TOut FireInOut(ISignal`1<InOutEventArgs`2<TIn, TOut>> thіs, TIn in);
    [ExtensionAttribute]
public static void FlowDeferredInto(ISignal`1<TSource> source, Lifetime lifetime, ISimpleSignal target);
    [ExtensionAttribute]
public static void FlowInto(ISignal`1<TValue> source, Lifetime lifetime, ISimpleSignal target);
    [ExtensionAttribute]
public static void FlowInto(ISignal`1<TValue> source, Lifetime lifetime, ISignal`1<TValue> target);
    [ExtensionAttribute]
public static void FlowInto(ISignal`1<TSource> source, Lifetime lifetime, ISignal`1<TTarget> target, Func`2<TSource, TTarget> FConvert);
    [ExtensionAttribute]
public static void FlowInto(ISimpleSignal source, Lifetime lifetime, ISimpleSignal target);
    [ExtensionAttribute]
public static void LogFirings(ISignal`1<TValue> thіs, Lifetime lifetime, string prefix);
    [ExtensionAttribute]
public static void LogFirings(ISignal`1<TValue> thіs, Lifetime lifetime, object logprefix);
    [ExtensionAttribute]
public static void LogFirings(ISignal`1<TValue> thіs, Lifetime lifetime, ILogger logger);
    [NotNullAttribute]
[ExtensionAttribute]
public static Signal`1<TValue> LogFirings(Signal`1<TValue> thіs, ILogger logger);
    [NotNullAttribute]
[ExtensionAttribute]
public static SimpleSignal LogFirings(SimpleSignal thіs, ILogger logger);
}
[ExtensionAttribute]
public static class JetBrains.DataFlow.ISignalEx_ObsoleteWithoutLifetime : object {
    [ExtensionAttribute]
[ObsoleteAttribute("Use overload with lifetime.")]
[NotNullAttribute]
public static IDisposable Advise(ISignal`1<TValue> thіs, Action handler);
    [ObsoleteAttribute("Use overload with lifetime.")]
[ExtensionAttribute]
[NotNullAttribute]
public static IDisposable Advise_InOut(ISignal`1<InOutEventArgs`2<TIn, TOut>> signal, Func`2<TIn, TOut> F);
    [ObsoleteAttribute("Use overload with lifetime.")]
[ExtensionAttribute]
[NotNullAttribute]
public static IDisposable Advise(ISignal`1<TValue> thіs, Action`1<TValue> handler);
    [ObsoleteAttribute("Use overload with lifetime.")]
[ExtensionAttribute]
public static void BeginFire(ISimpleSignal signal, JetDispatcher dispatcher);
    [ExtensionAttribute]
[ObsoleteAttribute("Use overload with lifetime.")]
public static void BeginFire(ISignal`1<TValue> signal, JetDispatcher dispatcher, TValue value);
    [ObsoleteAttribute("Use overload with lifetime.")]
[ExtensionAttribute]
public static void BeginFire(ISignal`1<TValue> signal, JetDispatcher dispatcher, TValue value, object cookie);
    [NotNullAttribute]
[ObsoleteAttribute("Use overload with lifetime.")]
[ExtensionAttribute]
public static IDisposable FlowDeferredInto(ISignal`1<TSource> source, ISimpleSignal target);
    [NotNullAttribute]
[ObsoleteAttribute("Use overload with lifetime.")]
[ExtensionAttribute]
public static IDisposable FlowInto(ISignal`1<TValue> source, ISimpleSignal target);
    [ExtensionAttribute]
[NotNullAttribute]
[ObsoleteAttribute("Use overload with lifetime.")]
public static IDisposable FlowInto(ISignal`1<TValue> source, ISignal`1<TValue> target);
    [NotNullAttribute]
[ObsoleteAttribute("Use overload with lifetime.")]
[ExtensionAttribute]
public static IDisposable FlowInto(ISignal`1<TSource> source, ISignal`1<TTarget> target, Func`2<TSource, TTarget> converter);
    [ObsoleteAttribute("Use overload with lifetime.")]
[NotNullAttribute]
[ExtensionAttribute]
public static IDisposable FlowInto(ISimpleSignal source, ISimpleSignal target);
}
public interface JetBrains.DataFlow.ISimpleSignal {
    public abstract virtual void Fire();
}
public interface JetBrains.DataFlow.IUntypedProperty {
    public IUntypedSignal BeforeChange { get; }
    public IUntypedSignal Change { get; }
    [NotNullAttribute]
public PropertyId Id { get; }
    public bool IsNullValueAllowed { get; }
    [NotNullAttribute]
public Type PropertyType { get; }
    public object AsTyped { get; }
    public abstract virtual IUntypedSignal get_BeforeChange();
    public abstract virtual IUntypedSignal get_Change();
    public abstract virtual PropertyId get_Id();
    public abstract virtual bool get_IsNullValueAllowed();
    public abstract virtual Type get_PropertyType();
    public abstract virtual object get_AsTyped();
    public abstract virtual object GetValue(object cookie);
    public abstract virtual bool SetValue(object value, object cookie);
    public abstract virtual void add_Disposed(EventHandler value);
    public abstract virtual void remove_Disposed(EventHandler value);
}
public interface JetBrains.DataFlow.IUntypedPropertyBag {
    [NotNullAttribute]
public IDictionaryEvents`2<PropertyId, IUntypedProperty> Properties { get; }
    public abstract virtual IDictionaryEvents`2<PropertyId, IUntypedProperty> get_Properties();
    public abstract virtual bool Contains(PropertyId id);
    [CanBeNullAttribute]
public abstract virtual object Get(PropertyId id);
    [NotNullAttribute]
public abstract virtual IUntypedProperty GetOrCreateProperty(PropertyId id, object defaultvalue, Nullable`1<bool> isNullValueAllowed);
    public abstract virtual bool Remove(PropertyId id);
    public abstract virtual void Set(PropertyId id, object value);
    public abstract virtual bool TryGet(PropertyId id, Object& value);
    [CanBeNullAttribute]
public abstract virtual object TryGet(PropertyId id);
}
public interface JetBrains.DataFlow.IUntypedSignal {
    [NotNullAttribute]
public PropertyId Id { get; }
    [NotNullAttribute]
public IUntypedProperty Property { get; }
    [NotNullAttribute]
public Type ArgumentType { get; }
    public abstract virtual PropertyId get_Id();
    public abstract virtual IUntypedProperty get_Property();
    public abstract virtual Type get_ArgumentType();
    public abstract virtual void Advise(Action`1<object> handler, Lifetime lifetime);
    public abstract virtual void Fire(object value, object cookie);
}
public interface JetBrains.DataFlow.IViewable`1 {
    public abstract virtual void View(Lifetime lifetime, Action`2<Lifetime, TValue> viewer);
}
[ExtensionAttribute]
public static class JetBrains.DataFlow.LifetimeEx : object {
    [NotNullAttribute]
[ExtensionAttribute]
[ObsoleteAttribute("Pass lifetime to function instead of disposing of its result. If you really have to, use AddDispose().")]
public static Lifetime Add(Lifetime thіs, IDisposable item);
    [NotNullAttribute]
[ExtensionAttribute]
[ObsoleteAttribute("Pass lifetime to function instead of disposing of its result. If you really have to, use AddDispose().")]
public static Lifetime Add(Lifetime thіs, IDisposable[] items);
    [NotNullAttribute]
[ExtensionAttribute]
public static Lifetime AddDispose(Lifetime thіs, IDisposable[] items);
    [NotNullAttribute]
[ExtensionAttribute]
public static Lifetime AssertEverTerminated(Lifetime thіs, string identity);
    [ExtensionAttribute]
[NotNullAttribute]
public static LifetimeDefinition EnsureEverTerminated_SingleThreaded(LifetimeDefinition thіs, string identity, bool saveCtorCallStack);
    [ExtensionAttribute]
[NotNullAttribute]
public static LifetimeDefinition EnsureEverTerminated_FreeThreaded(LifetimeDefinition def, string identity, bool saveCtorCallStack);
    [ExtensionAttribute]
public static void AssertIsAlive(OuterLifetime thіs);
    [ExtensionAttribute]
public static void LogAssertIsAlive(OuterLifetime thіs);
    [ExtensionAttribute]
public static void AssertIsAlive(Lifetime thіs);
    [ExtensionAttribute]
public static void LogAssertIsAlive(Lifetime thіs);
    [ExtensionAttribute]
public static void AssertIsAlive(LifetimeDefinition thіs);
    [ExtensionAttribute]
public static void LogAssertIsAlive(LifetimeDefinition thіs);
}
public static class JetBrains.DataFlow.LifetimesObsolete : object {
    [ObsoleteAttribute("Use Define() or Using(), or even better get your lifetime from your owner.")]
public static ObsoleteLifetimeAndDefinitionAtTheSameTime Create(bool finalize);
    [ObsoleteAttribute("Specify explicitly whether you'd like to assert that this lifetime is ever terminated. In most cases, this overload was used by mistake. Use Define().")]
[DebuggerStepThroughAttribute]
public static ObsoleteLifetimeAndDefinitionAtTheSameTime Create(string id);
    [ObsoleteAttribute("Use Define() or Using(), or even better get your lifetime from your owner.")]
public static ObsoleteLifetimeAndDefinitionAtTheSameTime Create();
    [DebuggerStepThroughAttribute]
[ObsoleteAttribute("Use Define(), or even better get your lifetime from your owner. If you would like to assert termination, call EnsureEverTerminated on the lifetime.")]
public static ObsoleteLifetimeAndDefinitionAtTheSameTime Create(string id, bool finalize);
    [NotNullAttribute]
[ObsoleteAttribute("Use Define().")]
public static ObsoleteLifetimeAndDefinitionAtTheSameTime CreateAtomic(Action`1<Lifetime> FAtomic);
}
[ExtensionAttribute]
public static class JetBrains.DataFlow.ListBridge : object {
    [ExtensionAttribute]
public static ListBridge`2<TSource, TTarget> BridgeInto(IListEvents`1<TSource> source, Lifetime lifetime, IListEvents`1<TTarget> target, Func`2<TSource, TTarget> funcConverter, Func`2<TSource, bool> funcFilter, MappingInfo mappinginfo, object cookie);
    [CompilerGeneratedAttribute]
private static TTarget <BridgeInto>b__0(TSource arg);
}
public class JetBrains.DataFlow.ListBridge`2 : object {
    [NotNullAttribute]
private Func`2<TSource, TTarget> myFuncConverter;
    [NotNullAttribute]
private Func`2<TSource, bool> myFuncFilter;
    [NotNullAttribute]
private List`1<int> myIndexMapping;
    private BidirectionalMapOnDictionary`2<TSource, TTarget> myMapItems;
    [NotNullAttribute]
private IListEvents`1<TSource> mySource;
    [NotNullAttribute]
private IListEvents`1<TTarget> myTarget;
    [CanBeNullAttribute]
private object myTargetModificationCookie;
    public bool HaveMappingInfo { get; }
    [NotNullAttribute]
public IDictionary`2<TSource, TTarget> MapSourceToTarget { get; }
    [NotNullAttribute]
public IDictionary`2<TTarget, TSource> MapTargetToSource { get; }
    [NotNullAttribute]
public IListEvents`1<TSource> Source { get; }
    [NotNullAttribute]
public IListEvents`1<TTarget> Target { get; }
    public ListBridge`2(Lifetime lifetime, IListEvents`1<TSource> source, IListEvents`1<TTarget> target, Func`2<TSource, TTarget> funcConverter, Func`2<TSource, bool> funcFilter, MappingInfo mappinginfo, object oTaregtModificationCookie);
    public bool get_HaveMappingInfo();
    public IDictionary`2<TSource, TTarget> get_MapSourceToTarget();
    public IDictionary`2<TTarget, TSource> get_MapTargetToSource();
    public IListEvents`1<TSource> get_Source();
    public IListEvents`1<TTarget> get_Target();
    private void Init(Lifetime lifetime);
    [CompilerGeneratedAttribute]
private void <Init>b__0();
    [CompilerGeneratedAttribute]
private void <Init>b__1();
    [CompilerGeneratedAttribute]
private void <Init>b__2(AddRemoveIndexEventArgs`1<TTarget> args);
    [CompilerGeneratedAttribute]
private void <Init>b__4(AddRemoveIndexEventArgs`1<TSource> args);
    [CompilerGeneratedAttribute]
private void <Init>b__5(AddRemoveIndexEventArgs`1<TSource> args);
}
[DebuggerStepThroughAttribute]
public static class JetBrains.DataFlow.ManualProperty : object {
    [NotNullAttribute]
public static IProperty`1<TValue> Create(string id, Action`1<TValue> setter);
    [NotNullAttribute]
public static IProperty`1<TValue> Create(Lifetime lifetime, string id, Action`1<TValue> setter);
    [NotNullAttribute]
public static IProperty`1<TValue> Create(string id, TValue initialvalue, Action`1<TValue> setter);
    [NotNullAttribute]
public static IProperty`1<TValue> Create(Lifetime lifetime, string id, TValue initialvalue, Action`1<TValue> setter);
    [NotNullAttribute]
public static IProperty`1<TValue> Create(string id, Func`1<TValue> getter, Action`1<TValue> setter);
    [NotNullAttribute]
public static IProperty`1<TValue> Create(Lifetime lifetime, string id, Func`1<TValue> getter, Action`1<TValue> setter);
}
public enum JetBrains.DataFlow.MarshallingBehaviors : Enum {
    public int value__;
    public static MarshallingBehaviors QueueAlways;
    public static MarshallingBehaviors QueueIfNeeded;
}
[DebuggerStepThroughAttribute]
public class JetBrains.DataFlow.MarshallingPropertyBinding`2 : PropertyBinding`2<TSource, TTarget> {
    [NotNullAttribute]
private JetDispatcher myDispatcher;
    private bool myFreeze;
    private MarshallingBehaviors myMarshallingBehavior;
    [NotNullAttribute]
public JetDispatcher Dispatcher { get; }
    public MarshallingBehaviors MarshallingBehavior { get; public set; }
    public MarshallingPropertyBinding`2(Lifetime lifetime, JetDispatcher dispatcher, IProperty`1<TSource> source, IProperty`1<TTarget> target, DataFlowDirection direction, Func`2<TSource, TTarget> delegateSourceToTarget, Func`2<TTarget, TSource> delegateTargetToSource);
    public MarshallingPropertyBinding`2(Lifetime lifetime, JetDispatcher dispatcher, IProperty`1<TSource> source, IProperty`1<TTarget> target, DataFlowDirection direction);
    public MarshallingPropertyBinding`2(Lifetime lifetime, JetDispatcher dispatcher, IProperty`1<TSource> source, IProperty`1<TTarget> target, Func`2<TSource, TTarget> delegateSourceToTarget, Func`2<TTarget, TSource> delegateTargetToSource);
    public MarshallingPropertyBinding`2(Lifetime lifetime, JetDispatcher dispatcher, IProperty`1<TSource> source, IProperty`1<TTarget> target, Func`2<TSource, TTarget> delegateSourceToTarget);
    public JetDispatcher get_Dispatcher();
    public MarshallingBehaviors get_MarshallingBehavior();
    public void set_MarshallingBehavior(MarshallingBehaviors value);
    public virtual void CopySourceToTarget();
    public virtual void CopyTargetToSource();
}
public class JetBrains.DataFlow.NullProperty`1 : object {
    [NotNullAttribute]
public static IProperty`1<TValue> Instance;
    private static NullProperty`1();
}
[DebuggerStepThroughAttribute]
[ObsoleteAttribute("Lifetime and LifetimeDefinition are now separated.")]
public class JetBrains.DataFlow.ObsoleteLifetimeAndDefinitionAtTheSameTime : object {
    public Lifetime Lifetime;
    public LifetimeDefinition LifetimeDefinition;
    public bool IsEmpty { get; }
    public bool IsTerminated { get; }
    public ObsoleteLifetimeAndDefinitionAtTheSameTime(LifetimeDefinition lifetimeDefinition);
    public bool get_IsEmpty();
    [NotNullAttribute]
public Lifetime AddDispose(IDisposable item);
    [NotNullAttribute]
public Lifetime AddAction(Action action);
    [NotNullAttribute]
public Lifetime AddBracket(Action opening, Action closing);
    public Lifetime AddRef(object object);
    public void Terminate();
    public sealed virtual void Dispose();
    public bool get_IsTerminated();
    public static Lifetime op_Implicit(ObsoleteLifetimeAndDefinitionAtTheSameTime compound);
    public static LifetimeDefinition op_Implicit(ObsoleteLifetimeAndDefinitionAtTheSameTime compound);
    public static ObsoleteLifetimeAndDefinitionAtTheSameTime op_Explicit(LifetimeDefinition definition);
    [ObsoleteAttribute("Pass lifetime to function instead of disposing of its result. If you really have to, use AddDispose().")]
public Lifetime Add(IDisposable[] disposables);
}
[ExtensionAttribute]
public static class JetBrains.DataFlow.ObsoleteLifetimeEx : object {
    [ExtensionAttribute]
[NotNullAttribute]
[ObsoleteAttribute("Use Lifetimes.Define passing the outer lifetime as a parent lifetime.")]
public static ObsoleteLifetimeAndDefinitionAtTheSameTime OpenNested(Lifetime thіs);
}
[DebuggerStepThroughAttribute]
public class JetBrains.DataFlow.OutEventArgs`1 : EventArgs {
    [CompilerGeneratedAttribute]
private TOut <Out>k__BackingField;
    public TOut Out { get; public set; }
    public OutEventArgs`1(TOut out);
    [CompilerGeneratedAttribute]
public TOut get_Out();
    [CompilerGeneratedAttribute]
public void set_Out(TOut value);
}
[DebuggerStepThroughAttribute]
[DefaultPropertyAttribute("Value")]
public class JetBrains.DataFlow.Property`1 : object {
    public static string LoggerPrefix;
    private List`1<EventHandler> myHandlersDisposed;
    [NotNullAttribute]
private PropertyId`1<TValue> myId;
    private bool myIsNullValueAllowed;
    private ILogger myLogger;
    private SpinWaitLock myLock;
    [NotNullAttribute]
private PropertyBeforeChangeSignal<TValue> mySignalBeforeChange;
    [NotNullAttribute]
private PropertyChangeSignal<TValue> mySignalChange;
    private TValue myValue;
    private LifetimeDefinition myLifetimeDefinition;
    private PropertyChangedEventHandler PropertyChanged;
    private PropertyChangingEventHandler PropertyChanging;
    public ISignal`1<BeforePropertyChangedEventArgs`1<TValue>> BeforeChange { get; }
    public ISignal`1<PropertyChangedEventArgs`1<TValue>> Change { get; }
    public PropertyId`1<TValue> Id { get; }
    public bool IsNullValueAllowed { get; }
    public TValue Value { get; public set; }
    private IUntypedSignal JetBrains.DataFlow.IUntypedProperty.BeforeChange { get; }
    private IUntypedSignal JetBrains.DataFlow.IUntypedProperty.Change { get; }
    private PropertyId JetBrains.DataFlow.IUntypedProperty.Id { get; }
    private Type JetBrains.DataFlow.IUntypedProperty.PropertyType { get; }
    private IUntypedProperty JetBrains.DataFlow.IHaveUntypedProperty.AsUntyped { get; }
    private object JetBrains.DataFlow.IUntypedProperty.AsTyped { get; }
    [DebuggerStepThroughAttribute]
public Property`1(string id);
    [DebuggerStepThroughAttribute]
public Property`1(Lifetime lifetime, string id);
    [DebuggerStepThroughAttribute]
public Property`1(PropertyId`1<TValue> id, TValue value);
    [DebuggerStepThroughAttribute]
public Property`1(string id, TValue value);
    [DebuggerStepThroughAttribute]
public Property`1(Lifetime lifetime, string id, TValue value);
    [DebuggerStepThroughAttribute]
public Property`1(Lifetime lifetime, PropertyId`1<TValue> id, TValue value, Nullable`1<bool> isNullValueAllowed, ILogger logger);
    [DebuggerStepThroughAttribute]
public static TValue op_Explicit(Property`1<TValue> property);
    internal static void ThrowReadonlyFail(BeforePropertyChangedEventArgs`1<TValue> args, object tokenExpected);
    internal static void ThrowThreadAffinityFail(BeforePropertyChangedEventArgs`1<TValue> args, Thread threadExpected);
    [DebuggerStepThroughAttribute]
private bool FireBeforeChange(TValue old, TValue new, object cookie);
    [DebuggerStepThroughAttribute]
private void FireChange(TValue old, TValue new, object cookie);
    [DebuggerStepThroughAttribute]
private void FireDisposed();
    [DebuggerStepThroughAttribute]
private void FirePropertyChanged();
    [DebuggerStepThroughAttribute]
private void FirePropertyChanging();
    [DebuggerStepThroughAttribute]
public virtual string ToString();
    [DebuggerStepThroughAttribute]
public sealed virtual object Clone();
    [DebuggerStepThroughAttribute]
public sealed virtual void add_Disposed(EventHandler value);
    [DebuggerStepThroughAttribute]
public sealed virtual void remove_Disposed(EventHandler value);
    public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    public sealed virtual void add_PropertyChanging(PropertyChangingEventHandler value);
    public sealed virtual void remove_PropertyChanging(PropertyChangingEventHandler value);
    [ObsoleteAttribute("Pass in a lifetime; will be made non-idisposable.")]
[DebuggerStepThroughAttribute]
private sealed virtual override void System.IDisposable.Dispose();
    [DebuggerStepThroughAttribute]
public sealed virtual TValue GetValue();
    [DebuggerStepThroughAttribute]
public sealed virtual TValue GetValue(object cookie);
    [DebuggerStepThroughAttribute]
public sealed virtual bool SetValue(TValue value);
    [DebuggerStepThroughAttribute]
public sealed virtual bool SetValue(TValue value, object cookie);
    [DebuggerStepThroughAttribute]
private sealed virtual override object JetBrains.DataFlow.IUntypedProperty.GetValue(object cookie);
    [DebuggerStepThroughAttribute]
private sealed virtual override bool JetBrains.DataFlow.IUntypedProperty.SetValue(object value, object cookie);
    [DebuggerStepThroughAttribute]
public sealed virtual ISignal`1<BeforePropertyChangedEventArgs`1<TValue>> get_BeforeChange();
    [DebuggerStepThroughAttribute]
public sealed virtual ISignal`1<PropertyChangedEventArgs`1<TValue>> get_Change();
    [DebuggerStepThroughAttribute]
public sealed virtual PropertyId`1<TValue> get_Id();
    [DebuggerStepThroughAttribute]
public sealed virtual bool get_IsNullValueAllowed();
    [DebuggerStepThroughAttribute]
public sealed virtual TValue get_Value();
    [DebuggerStepThroughAttribute]
public sealed virtual void set_Value(TValue value);
    [DebuggerStepThroughAttribute]
private sealed virtual override IUntypedSignal JetBrains.DataFlow.IUntypedProperty.get_BeforeChange();
    [DebuggerStepThroughAttribute]
private sealed virtual override IUntypedSignal JetBrains.DataFlow.IUntypedProperty.get_Change();
    [DebuggerStepThroughAttribute]
private sealed virtual override PropertyId JetBrains.DataFlow.IUntypedProperty.get_Id();
    [DebuggerStepThroughAttribute]
private sealed virtual override Type JetBrains.DataFlow.IUntypedProperty.get_PropertyType();
    private sealed virtual override IUntypedProperty JetBrains.DataFlow.IHaveUntypedProperty.get_AsUntyped();
    private sealed virtual override object JetBrains.DataFlow.IUntypedProperty.get_AsTyped();
}
[DebuggerStepThroughAttribute]
public class JetBrains.DataFlow.PropertyBag : object {
    private Lifetime myLifetime;
    private DictionaryEvents`2<PropertyId, IUntypedProperty> myProperties;
    private ILogger myLogger;
    public IDictionaryEvents`2<PropertyId, IUntypedProperty> Properties { get; }
    private IUntypedPropertyBag JetBrains.DataFlow.IPropertyBag.AsUntyped { get; }
    public PropertyBag(Lifetime lifetime, ILogger logger);
    public sealed virtual bool Contains(PropertyId`1<T> id);
    public sealed virtual T Get(PropertyId`1<T> id);
    public sealed virtual IProperty`1<T> GetOrCreateProperty(PropertyId`1<T> id, T defaultvalue, Nullable`1<bool> isNullValueAllowed);
    public sealed virtual IProperty`1<T> GetProperty(PropertyId`1<T> id);
    public sealed virtual bool Remove(PropertyId`1<T> id);
    private sealed virtual override bool JetBrains.DataFlow.IUntypedPropertyBag.Remove(PropertyId id);
    public sealed virtual void Set(PropertyId`1<T> id, T value);
    public sealed virtual bool TryGet(PropertyId`1<T> id, T& value);
    public sealed virtual T TryGet(PropertyId`1<T> id);
    private sealed virtual override bool JetBrains.DataFlow.IUntypedPropertyBag.Contains(PropertyId id);
    private sealed virtual override object JetBrains.DataFlow.IUntypedPropertyBag.Get(PropertyId id);
    private sealed virtual override IUntypedProperty JetBrains.DataFlow.IUntypedPropertyBag.GetOrCreateProperty(PropertyId id, object defaultvalue, Nullable`1<bool> isNullValueAllowed);
    private sealed virtual override void JetBrains.DataFlow.IUntypedPropertyBag.Set(PropertyId id, object value);
    private sealed virtual override object JetBrains.DataFlow.IUntypedPropertyBag.TryGet(PropertyId id);
    private sealed virtual override bool JetBrains.DataFlow.IUntypedPropertyBag.TryGet(PropertyId id, Object& value);
    public sealed virtual IDictionaryEvents`2<PropertyId, IUntypedProperty> get_Properties();
    private sealed virtual override IUntypedPropertyBag JetBrains.DataFlow.IPropertyBag.get_AsUntyped();
}
[ExtensionAttribute]
public static class JetBrains.DataFlow.PropertyBinding : object {
    public static Property`1<bool> False;
    public static Property`1<bool> True;
    public static Property`1<int> Zero;
    [CompilerGeneratedAttribute]
private static ComposerDelegate<bool, bool, bool> CS$<>9__CachedAnonymousMethodDelegate11;
    [CompilerGeneratedAttribute]
private static Func`2<bool, bool> CS$<>9__CachedAnonymousMethodDelegate18;
    [CompilerGeneratedAttribute]
private static ComposerDelegate<bool, bool, bool> CS$<>9__CachedAnonymousMethodDelegate1a;
    private static PropertyBinding();
    [NotNullAttribute]
public static PropertyBinding`2<TSource, TTarget> CreateBidirectional(Lifetime lifetime, IProperty`1<TSource> source, IProperty`1<TTarget> target, Func`2<TSource, TTarget> FConvertSourceToTarget, Func`2<TTarget, TSource> FConvertTargetToSource);
    [NotNullAttribute]
[ObsoleteAttribute("For from-source bindings, use source.FlowInto(target). For others, use overload with lifetime.")]
public static PropertyBinding`2<TSource, TTarget> CreateBidirectional(IProperty`1<TSource> source, IProperty`1<TTarget> target);
    public static PropertyBinding`2<TSource, TTarget> CreateBidirectional(Lifetime lifetime, IProperty`1<TSource> source, IProperty`1<TTarget> target);
    public static void CreateOneWayToSource(Lifetime lifetime, IProperty`1<TSource> source, IProperty`1<TTarget> target, Func`2<TTarget, TSource> FConvertTargetToSource);
    public static void CreateOneWayToSource(Lifetime lifetime, IProperty`1<TSource> source, IProperty`1<TTarget> target);
    public static void Create2(Lifetime lifetime, IProperty`1<TSource1> source1, IProperty`1<TSource2> source2, IProperty`1<TTarget> target, Func`3<TSource1, TSource2, TTarget> FConvert, object token);
    public static void Create3(Lifetime lifetime, IProperty`1<TSource1> source1, IProperty`1<TSource2> source2, IProperty`1<TSource3> source3, IProperty`1<TTarget> target, Func`4<TSource1, TSource2, TSource3, TTarget> FConvert, object token);
    public static void Create4(Lifetime lifetime, IProperty`1<TSource1> source1, IProperty`1<TSource2> source2, IProperty`1<TSource3> source3, IProperty`1<TSource4> source4, IProperty`1<TTarget> target, Func`5<TSource1, TSource2, TSource3, TSource4, TTarget> FConvert, object token);
    [ObsoleteAttribute("Use overload with lifetime.")]
[NotNullAttribute]
public static IProperty`1<bool> CreateAnd(IProperty`1<bool> srcA, IProperty`1<bool> srcB);
    [NotNullAttribute]
public static IProperty`1<bool> CreateAnd(Lifetime lifetime, IProperty`1<bool> srcA, IProperty`1<bool> srcB, string name);
    public static void CreateAndMultibinding(Lifetime lifetime, IProperty`1<bool> srcA, IProperty`1<bool> srcB, IProperty`1<bool> dst);
    public static void CreateCascading(Lifetime lifetime, IProperty`1<TSourceOwner> sourceowner, Func`2<TSourceOwner, IProperty`1<TSource>> FGetSourceFromOwner, IProperty`1<TSource> propSourceWhenNoOwner, IProperty`1<TTarget> target, DataFlowDirection direction);
    [ExtensionAttribute]
[NotNullAttribute]
public static IProperty`1<bool> CreateIsNotNull(IProperty`1<T> source, Lifetime lifetime);
    [ExtensionAttribute]
[NotNullAttribute]
public static IProperty`1<bool> CreateIsNull(IProperty`1<T> source, Lifetime lifetime);
    [ExtensionAttribute]
[NotNullAttribute]
public static IProperty`1<bool> CreateNot(IProperty`1<bool> source, Lifetime lifetime);
    [NotNullAttribute]
public static IProperty`1<bool> CreateOr(Lifetime lifetime, IProperty`1<bool> srcA, IProperty`1<bool> srcB);
    public static void CreateOrMultibinding(Lifetime lifetime, IProperty`1<bool> srcA, IProperty`1<bool> srcB, IProperty`1<bool> dst);
    [NotNullAttribute]
public static IProperty`1<TValue> Null();
    [CompilerGeneratedAttribute]
private static TTarget <CreateOneWayToSource>b__0(TSource s);
    [CompilerGeneratedAttribute]
private static bool <CreateAndMultibinding>b__10(bool α, bool β);
    [CompilerGeneratedAttribute]
private static bool <CreateIsNotNull>b__15(T arg);
    [CompilerGeneratedAttribute]
private static bool <CreateIsNull>b__16(T arg);
    [CompilerGeneratedAttribute]
private static bool <CreateNot>b__17(bool arg);
    [CompilerGeneratedAttribute]
private static bool <CreateOrMultibinding>b__19(bool α, bool β);
}
[DebuggerStepThroughAttribute]
public class JetBrains.DataFlow.PropertyBinding`2 : object {
    [NotNullAttribute]
protected Func`2<TSource, TTarget> myConverterSourceToTarget;
    [NotNullAttribute]
protected Func`2<TTarget, TSource> myConverterTargetToSource;
    [NotNullAttribute]
protected Property`1<DataFlowDirection> myDirection;
    [NotNullAttribute]
protected Property`1<IProperty`1<TSource>> mySource;
    [CanBeNullAttribute]
protected object mySourceCookie;
    [NotNullAttribute]
protected Property`1<IProperty`1<TTarget>> myTarget;
    [CanBeNullAttribute]
protected object myTargetCookie;
    private int myFreeze;
    [CompilerGeneratedAttribute]
private object <Tag>k__BackingField;
    [CanBeNullAttribute]
public object SourceCookie { get; public set; }
    public object Tag { get; public set; }
    [CanBeNullAttribute]
public object TargetCookie { get; public set; }
    public DataFlowDirection Direction { get; public set; }
    public IProperty`1<IProperty`1<TSource>> Source { get; }
    public IProperty`1<IProperty`1<TTarget>> Target { get; }
    private IUntypedProperty JetBrains.DataFlow.IPropertyBinding.Source { get; }
    private IUntypedProperty JetBrains.DataFlow.IPropertyBinding.Target { get; }
    private IPropertyBinding JetBrains.DataFlow.IPropertyBinding<TSource,TTarget>.AsUntyped { get; }
    public PropertyBinding`2(Lifetime lifetime, IProperty`1<TSource> source, IProperty`1<TTarget> target, Func`2<TSource, TTarget> delegateSourceToTarget);
    public PropertyBinding`2(Lifetime lifetime, IProperty`1<TSource> source, IProperty`1<TTarget> target, Func`2<TSource, TTarget> delegateSourceToTarget, Func`2<TTarget, TSource> delegateTargetToSource);
    public PropertyBinding`2(Lifetime lifetime, IProperty`1<TSource> source, IProperty`1<TTarget> target, DataFlowDirection direction);
    public PropertyBinding`2(Lifetime lifetime, IProperty`1<TSource> source, IProperty`1<TTarget> target, DataFlowDirection direction, Func`2<TSource, TTarget> delegateSourceToTarget, Func`2<TTarget, TSource> delegateTargetToSource);
    public PropertyBinding`2(Lifetime lifetime, IProperty`1<TSource> source, IProperty`1<TTarget> target, DataFlowDirection direction, Func`2<TSource, TTarget> delegateSourceToTarget, Func`2<TTarget, TSource> delegateTargetToSource, object oSourceCookie, object oTargetCookie);
    public object get_SourceCookie();
    public void set_SourceCookie(object value);
    [CompilerGeneratedAttribute]
public object get_Tag();
    [CompilerGeneratedAttribute]
public void set_Tag(object value);
    public object get_TargetCookie();
    public void set_TargetCookie(object value);
    private static TTarget OnConvertSourceToTargetDefault(TSource value);
    private static TSource OnConvertTargetToSourceDefault(TTarget value);
    private void Clear();
    private void InitDataFlow(Lifetime lifetimeGlobal);
    private void OnSourceValueChanged(PropertyChangedEventArgs`1<TSource> args);
    private void OnTargetValueChanged(PropertyChangedEventArgs`1<TTarget> args);
    public virtual void CopySourceToTarget();
    public virtual void CopyTargetToSource();
    public sealed virtual DataFlowDirection get_Direction();
    public void set_Direction(DataFlowDirection value);
    public sealed virtual IProperty`1<IProperty`1<TSource>> get_Source();
    public sealed virtual IProperty`1<IProperty`1<TTarget>> get_Target();
    private sealed virtual override IUntypedProperty JetBrains.DataFlow.IPropertyBinding.get_Source();
    private sealed virtual override IUntypedProperty JetBrains.DataFlow.IPropertyBinding.get_Target();
    private sealed virtual override IPropertyBinding JetBrains.DataFlow.IPropertyBinding<TSource,TTarget>.get_AsUntyped();
    [CompilerGeneratedAttribute]
private void <.ctor>b__0();
    [CompilerGeneratedAttribute]
private void <.ctor>b__1();
    [CompilerGeneratedAttribute]
private void <InitDataFlow>b__4(Lifetime lifetime, IProperty`1<TSource> value);
    [CompilerGeneratedAttribute]
private void <InitDataFlow>b__7(Lifetime lifetime, IProperty`1<TTarget> value);
    [CompilerGeneratedAttribute]
private void <InitDataFlow>b__a(PropertyChangedEventArgs`1<DataFlowDirection> args);
    [CompilerGeneratedAttribute]
private object <CopySourceToTarget>b__f();
    [CompilerGeneratedAttribute]
private object <CopySourceToTarget>b__10();
    [CompilerGeneratedAttribute]
private object <CopyTargetToSource>b__13();
    [CompilerGeneratedAttribute]
private object <CopyTargetToSource>b__14();
}
[DebuggerStepThroughAttribute]
public class JetBrains.DataFlow.PropertyBindingDeferred`1 : object {
    private ReadonlyToken myReadonlyCookie;
    private IProperty`1<TValue> mySource;
    private IProperty`1<TValue> myTarget;
    private object myTargetCookie;
    private WeakTimer myTimer;
    public Property`1<TimeSpan> GracePeriod;
    public ISimpleSignal IncomingCommit;
    public Property`1<bool> IsPending;
    public IProperty`1<TValue> Source { get; }
    public IProperty`1<TValue> Target { get; }
    public PropertyBindingDeferred`1(Lifetime lifetime, IProperty`1<TValue> source, IProperty`1<TValue> target, TimeSpan graceperiod, object targetcookie);
    public IProperty`1<TValue> get_Source();
    public IProperty`1<TValue> get_Target();
    private void InitDataFlow(Lifetime lifetime);
    [CompilerGeneratedAttribute]
private void <InitDataFlow>b__0();
    [CompilerGeneratedAttribute]
private void <InitDataFlow>b__1();
    [CompilerGeneratedAttribute]
private void <InitDataFlow>b__2();
}
[DebuggerStepThroughAttribute]
public class JetBrains.DataFlow.PropertyChangedEventArgs`1 : EventArgs {
    private TValue myNew;
    private TValue myOld;
    [CompilerGeneratedAttribute]
private object <Cookie>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasNew>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasOld>k__BackingField;
    [CompilerGeneratedAttribute]
private Property`1<TValue> <Property>k__BackingField;
    [CanBeNullAttribute]
public object Cookie { get; private set; }
    public bool HasNew { get; private set; }
    public bool HasOld { get; private set; }
    public bool IsAcknowledging { get; }
    public TValue New { get; }
    public TValue Old { get; }
    [NotNullAttribute]
public Property`1<TValue> Property { get; private set; }
    protected PropertyChangedEventArgs`1(Property`1<TValue> property, TValue old, bool hasold, TValue new, bool hasnew, object cookie);
    [CompilerGeneratedAttribute]
public object get_Cookie();
    [CompilerGeneratedAttribute]
private void set_Cookie(object value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_HasNew();
    [CompilerGeneratedAttribute]
private void set_HasNew(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_HasOld();
    [CompilerGeneratedAttribute]
private void set_HasOld(bool value);
    public bool get_IsAcknowledging();
    public TValue get_New();
    public TValue get_Old();
    [CompilerGeneratedAttribute]
public Property`1<TValue> get_Property();
    [CompilerGeneratedAttribute]
private void set_Property(Property`1<TValue> value);
    [PureAttribute]
[NotNullAttribute]
public static PropertyChangedEventArgs`1<TValue> CreateBoth(Property`1<TValue> property, TValue old, TValue new, object cookie);
    [NotNullAttribute]
[PureAttribute]
public static PropertyChangedEventArgs`1<TValue> CreateNew(Property`1<TValue> property, TValue new, object cookie);
    [PureAttribute]
[NotNullAttribute]
public static PropertyChangedEventArgs`1<TValue> CreateOld(Property`1<TValue> property, TValue old, object cookie);
}
[ExtensionAttribute]
public static class JetBrains.DataFlow.PropertyChangeEventArgsEx : object {
    [ExtensionAttribute]
public static TValue GetNewOrNull(PropertyChangedEventArgs`1<TValue> args);
    [ExtensionAttribute]
public static TValue GetOldOrNull(PropertyChangedEventArgs`1<TValue> args);
    [ExtensionAttribute]
public static bool IsRaising(PropertyChangedEventArgs`1<bool> args);
}
[DebuggerStepThroughAttribute]
public abstract class JetBrains.DataFlow.PropertyId : object {
    [NotNullAttribute]
public string Id { get; }
    public abstract virtual string get_Id();
    public static PropertyId`1<TValue> Create(string id);
}
[DebuggerStepThroughAttribute]
public class JetBrains.DataFlow.PropertyId`1 : PropertyId {
    [NotNullAttribute]
private string myId;
    [NotNullAttribute]
public string Id { get; }
    public PropertyId`1(string id);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public virtual string get_Id();
    public sealed virtual bool Equals(PropertyId`1<TValue> propertyId);
    public static string op_Implicit(PropertyId`1<TValue> propid);
    public static PropertyId`1<TValue> op_Implicit(string text);
}
public class JetBrains.DataFlow.PropertyValidationException : ValidationException {
    private IUntypedProperty myProperty;
    private object myValue;
    [NotNullAttribute]
public IUntypedProperty Property { get; }
    [CanBeNullAttribute]
public object Value { get; }
    public PropertyValidationException(IUntypedProperty property, object value, string message);
    public IUntypedProperty get_Property();
    public object get_Value();
    [CompilerGeneratedAttribute]
private object <.ctor>b__0();
    [CompilerGeneratedAttribute]
private object <.ctor>b__1();
    [CompilerGeneratedAttribute]
private object <.ctor>b__2();
}
[ExtensionAttribute]
public static class JetBrains.DataFlow.PropertyValidator : object {
    [ExtensionAttribute]
public static void CreateEnumValidator(IProperty`1<TValue> thіs, Lifetime lifetime);
    [ExtensionAttribute]
public static void CreateMaximumValidator(IProperty`1<TValue> thіs, Lifetime lifetime, TValue max);
    [ExtensionAttribute]
public static void CreateMinimumValidator(IProperty`1<TValue> thіs, Lifetime lifetime, TValue min);
    [ExtensionAttribute]
public static void CreateNotEmptyValidator(IProperty`1<string> thіs, Lifetime lifetime);
    [ExtensionAttribute]
public static void CreateReadonlyValidator(IProperty`1<TValue> thіs, Lifetime lifetime, ReadonlyToken token);
    [ExtensionAttribute]
public static void CreateThreadAffinityValidator(IProperty`1<TValue> thіs, Lifetime lifetime, Thread thread);
    [ExtensionAttribute]
public static void CreateThreadAffinityValidator(IProperty`1<TValue> thіs, Lifetime lifetime, JetDispatcher dispatcher);
    [ExtensionAttribute]
public static void Freeze(IProperty`1<TValue> thіs, string message);
    [ExtensionAttribute]
public static void Freeze(IProperty`1<TValue> thіs, Lifetime lifetime, string message);
}
[ExtensionAttribute]
public static class JetBrains.DataFlow.PropertyValidatorFluent : object {
    [ExtensionAttribute]
[NotNullAttribute]
public static Property`1<TValue> CoerceToRange(Property`1<TValue> property, TValue min, TValue max);
    [NotNullAttribute]
[ExtensionAttribute]
public static Property`1<TValue> EnsureEnum(Property`1<TValue> property);
    [NotNullAttribute]
[ExtensionAttribute]
public static IProperty`1<TValue> EnsureEnum(IProperty`1<TValue> property);
    [ExtensionAttribute]
[NotNullAttribute]
public static Property`1<TValue> EnsureInitonly(Property`1<TValue> property);
    [NotNullAttribute]
[ExtensionAttribute]
public static Property`1<TValue> EnsureNotAbove(Property`1<TValue> property, TValue max);
    [NotNullAttribute]
[ExtensionAttribute]
public static Property`1<TValue> EnsureNotBelow(Property`1<TValue> property, TValue min);
    [NotNullAttribute]
[ExtensionAttribute]
public static Property`1<TValue> EnsureNotOutside(Property`1<TValue> property, TValue min, TValue max);
    [NotNullAttribute]
[ExtensionAttribute]
public static Property`1<TValue> EnsureReadonly(Property`1<TValue> property, ReadonlyToken token);
    [NotNullAttribute]
[ExtensionAttribute]
public static IProperty`1<TValue> EnsureReadonly(IProperty`1<TValue> property, ReadonlyToken token);
    [NotNullAttribute]
[ExtensionAttribute]
public static Property`1<TValue> EnsureThisThread(Property`1<TValue> property);
    [NotNullAttribute]
[ExtensionAttribute]
public static IProperty`1<TValue> EnsureThisThread(IProperty`1<TValue> property, Lifetime lifetime);
}
[DebuggerStepThroughAttribute]
public class JetBrains.DataFlow.Signal`1 : object {
    protected SpinWaitLock myLock;
    [NotNullAttribute]
private PropertyId`1<TValue> myId;
    [CanBeNullAttribute]
private IProperty`1<TValue> myProperty;
    [CanBeNullAttribute]
private ReadonlyToken myReadOnlyLock;
    [NotNullAttribute]
private Action`1[] mySinks;
    [CanBeNullAttribute]
private Thread myThreadAffinedTo;
    private LocalLazy`2<SequentialLifetimes, Lifetime> myUnderlyingPropertyAffineToThread;
    private LocalLazy`2<SequentialLifetimes, Lifetime> myUnderlyingPropertyReadOnlyLock;
    private ILogger myLogger;
    private Lifetime myLifetime;
    private LifetimeDefinition myLifetimeDefinition;
    public PropertyId`1<TValue> Id { get; }
    public IProperty`1<TValue> Property { get; }
    private IUntypedSignal JetBrains.DataFlow.ISignal<TValue>.AsUntyped { get; }
    private PropertyId JetBrains.DataFlow.IUntypedSignal.Id { get; }
    private IUntypedProperty JetBrains.DataFlow.IUntypedSignal.Property { get; }
    private Type JetBrains.DataFlow.IUntypedSignal.ArgumentType { get; }
    public Signal`1(string id);
    public Signal`1(Lifetime lifetime, string id);
    public Signal`1(Lifetime lifetime, PropertyId`1<TValue> id, ILogger logger);
    [ObsoleteAttribute("Support for signals-over-properties will be dropped.")]
public Signal`1(Lifetime lifetime, IProperty`1<TValue> property);
    private static void AssertValid();
    protected virtual void OnAfterAdvise(Action`1<TValue> handler);
    protected virtual void OnAfterUnadvise(Action`1<TValue> handler);
    protected virtual bool OnBeforeAdvise(Action`1<TValue> handler);
    private void AdviseCore(Action`1<TValue> handler, Lifetime lifetime);
    private void AttachToProperty(IProperty`1<TValue> property);
    private void Init(Lifetime lifetime, PropertyId`1<TValue> id);
    private void NotifySinks(TValue payload);
    private void OnUnderlyingPropertyChanged(PropertyChangedEventArgs`1<TValue> args);
    public virtual string ToString();
    private sealed virtual override void JetBrains.DataFlow.StandardPreconditions.IReadOnlyPrecondition.LockReadOnly(Lifetime lifetime, ReadonlyToken token);
    public sealed virtual void Advise(Lifetime lifetime, Action`1<TValue> handler);
    [ObsoleteAttribute("Pass in a lifetime; will be made non-idisposable.")]
public sealed virtual void Dispose();
    public sealed virtual void Fire(TValue value);
    public sealed virtual void Fire(TValue value, object cookie);
    private static ReadOnlyException Fire_ExceptionReadonlyPrecondition(object readOnlyLock, object cookie, Signal`1<TValue> this, TValue value);
    private static ThreadAccessException Fire_ExceptionThreadAffinityPrecondition(TValue value, object cookie, Thread threadAffinedTo, Signal`1<TValue> this);
    private static ArgumentException Fire_ExceptionCantFireNull(Signal`1<TValue> this);
    public sealed virtual PropertyId`1<TValue> get_Id();
    public sealed virtual IProperty`1<TValue> get_Property();
    private sealed virtual override void JetBrains.DataFlow.StandardPreconditions.IThreadAffinityPrecondition.AffineToThread(Lifetime lifetime, Thread thread);
    private sealed virtual override IUntypedSignal JetBrains.DataFlow.ISignal<TValue>.get_AsUntyped();
    private sealed virtual override PropertyId JetBrains.DataFlow.IUntypedSignal.get_Id();
    private sealed virtual override IUntypedProperty JetBrains.DataFlow.IUntypedSignal.get_Property();
    private sealed virtual override Type JetBrains.DataFlow.IUntypedSignal.get_ArgumentType();
    private sealed virtual override void JetBrains.DataFlow.IUntypedSignal.Advise(Action`1<object> action, Lifetime lifetime);
    private sealed virtual override void JetBrains.DataFlow.IUntypedSignal.Fire(object value, object cookie);
    [CompilerGeneratedAttribute]
private void <AttachToProperty>b__4();
    [CompilerGeneratedAttribute]
private void <Init>b__9();
    [CompilerGeneratedAttribute]
private object <JetBrains.DataFlow.StandardPreconditions.IReadOnlyPrecondition.LockReadOnly>b__a();
    [CompilerGeneratedAttribute]
private object <JetBrains.DataFlow.StandardPreconditions.IReadOnlyPrecondition.LockReadOnly>b__b();
    [CompilerGeneratedAttribute]
private void <JetBrains.DataFlow.StandardPreconditions.IReadOnlyPrecondition.LockReadOnly>b__f();
    [CompilerGeneratedAttribute]
private object <JetBrains.DataFlow.StandardPreconditions.IThreadAffinityPrecondition.AffineToThread>b__23();
    [CompilerGeneratedAttribute]
private object <JetBrains.DataFlow.StandardPreconditions.IThreadAffinityPrecondition.AffineToThread>b__24();
    [CompilerGeneratedAttribute]
private void <JetBrains.DataFlow.StandardPreconditions.IThreadAffinityPrecondition.AffineToThread>b__28();
}
internal class JetBrains.DataFlow.SignalStatics : object {
    internal static Func`2<Lifetime, SequentialLifetimes> SequentialLifetimesFactory;
    [CompilerGeneratedAttribute]
private static Func`2<Lifetime, SequentialLifetimes> CS$<>9__CachedAnonymousMethodDelegate1;
    private static SignalStatics();
    [CompilerGeneratedAttribute]
private static SequentialLifetimes <.cctor>b__0(Lifetime lifetime);
}
[ExtensionAttribute]
public static class JetBrains.DataFlow.SignalValidator : object {
    [ExtensionAttribute]
public static ISignal`1<TValue> EnsureReadonly(ISignal`1<TValue> signal, Lifetime lifetime, ReadonlyToken token);
    [NotNullAttribute]
[ExtensionAttribute]
public static SimpleSignal EnsureReadonly(SimpleSignal signal, Lifetime lifetime, ReadonlyToken token);
    [ExtensionAttribute]
public static ISignal`1<TValue> EnsureThisThread(ISignal`1<TValue> signal, Lifetime lifetime);
    [NotNullAttribute]
[ExtensionAttribute]
public static SimpleSignal EnsureThisThread(SimpleSignal signal, Lifetime lifetime);
}
[DebuggerStepThroughAttribute]
public class JetBrains.DataFlow.SimpleSignal : Signal`1<bool> {
    public SimpleSignal(string id);
    public SimpleSignal(Lifetime lifetime, string id);
    public SimpleSignal(Lifetime lifetime, PropertyId`1<bool> id, ILogger logger);
    public sealed virtual void Fire();
}
[ObsoleteAttribute("Use SequentialLifetimes.")]
public class JetBrains.DataFlow.SingleDisposable : object {
    [NotNullAttribute]
private IDisposable myContainee;
    [NotNullAttribute]
public SingleDisposable Clear();
    [NotNullAttribute]
public SingleDisposable Put(IDisposable new);
    [NotNullAttribute]
public SingleDisposable Put(Func`1<IDisposable> funcNew);
    [NotNullAttribute]
public SingleDisposable PutBracket(Action FEnter, Action FLeave);
    public sealed virtual void Dispose();
}
public static class JetBrains.DataFlow.StackTraceUtil : object {
    public static bool OptionCaptureStackTraces;
    public static string NoStackTraceMessage;
    private static StackTraceUtil();
    private static void StackFrameToString(StackFrame frame, StringBuilder sb);
    public static string StackFramesToString(StackFrame[] frames);
    public static StackFrame[] CaptureStackTrace(bool bObeyOptionCaptureStackTraces);
    public static string GetCallerMethodName();
    public static string CaptureAndFormatStackTrace(bool bObeyOptionCaptureStackTraces);
    public static string CaptureAndFormatStackTrace();
}
public interface JetBrains.DataFlow.StandardPreconditions.IReadOnlyPrecondition {
    public abstract virtual void LockReadOnly(Lifetime lifetime, ReadonlyToken token);
}
public interface JetBrains.DataFlow.StandardPreconditions.IStandardPrecondition {
}
public interface JetBrains.DataFlow.StandardPreconditions.IThreadAffinityPrecondition {
    public abstract virtual void AffineToThread(Lifetime lifetime, Thread thread);
}
public class JetBrains.DataFlow.StandardPreconditions.ReadonlyToken : object {
    [NotNullAttribute]
public string Info;
    public ReadonlyToken(string info);
    public virtual string ToString();
}
public static class JetBrains.DataFlow.StandardPreconditions.StandardPreconditionOptions : object {
    public static bool UseStandardPreconditionsInHelperMethods;
    private static StandardPreconditionOptions();
}
[ExtensionAttribute]
public static class JetBrains.DataFlow.Viewable : object {
    [ExtensionAttribute]
public static IEnumerable`1<TValue> ToLiveEnumerable(IViewable`1<TValue> viewable, Lifetime lifetime);
    [ExtensionAttribute]
public static List`1<TValue> ToLiveList(IViewable`1<TValue> viewable, Lifetime lifetime);
    [NotNullAttribute]
[ExtensionAttribute]
public static IList`1<TValue> ToNonLiveList(IViewable`1<TValue> viewable);
    [ExtensionAttribute]
public static ICollection`1<TResult> ToLiveEnumerable(IViewable`1<TValue> viewable, Lifetime lifetime, Func`2<TValue, TResult> projection);
    [ExtensionAttribute]
public static IEnumerable`1<T> ToLiveOrderedEnumerable(IViewable`1<T> viewable, Lifetime lifetime, Comparison`1<T> comparer);
    [ExtensionAttribute]
public static IEnumerable`1<T> ToLiveTopoOrderedEnumerable(IViewable`1<T> viewable, Lifetime lifetime, Func`3<T, T, Nullable`1<int>> comparer);
    [ExtensionAttribute]
public static IEnumerable`1<T> ToLiveOrderedEnumerable(IViewable`1<T> viewable, Lifetime lifetime, Comparison`1<TAttribute> comparer);
    [ExtensionAttribute]
public static IDictionary`2<TKey, TValue> ToLiveDictionary(IViewable`1<TValue> viewable, Lifetime lifetime, Func`2<TValue, TKey> keySelector, IEqualityComparer`1<TKey> keyComparer);
    [ExtensionAttribute]
public static JetHashSet`1<TResult> ToLiveHashSet(IViewable`1<TValue> viewable, Lifetime lifetime, Func`2<TValue, IEnumerable`1<TResult>> keySelector);
    [ExtensionAttribute]
public static JetHashSet`1<TResult> ToLiveHashSet(IViewable`1<TValue> viewable, Lifetime lifetime, Func`2<TValue, TResult> selector);
    [ExtensionAttribute]
public static void MapMany(IViewable`1<TValue> viewable, Lifetime lifetime, Func`2<TValue, IEnumerable`1<TKey>> keySelector, IOneToManyMap`3<TKey, TValue, TCollection> dictionary);
    [ExtensionAttribute]
public static void View(IViewable`1<TValue> viewable, Lifetime lifetime, Action`1<TValue> entered, Action`1<TValue> leaving);
    [ExtensionAttribute]
[NotNullAttribute]
public static IViewable`1<TItem> SelectMany(IViewable`1<TItemsProvider> thіs, Lifetime lifetime, Func`2<TItemsProvider, IViewable`1<TItem>> FGetItemsFromProvider);
    [NotNullAttribute]
[ExtensionAttribute]
public static ICollectionEvents`1<TValue> ToLiveCollection(IViewable`1<TValue> viewable, Lifetime lifetime);
}
public class JetBrains.DataFlow.ViewableCollection`1 : object {
    [NotNullAttribute]
public static ViewableCollection`1<TValue> Empty;
    [NotNullAttribute]
private Lifetime myLifetime;
    [NotNullAttribute]
private ICollection`1<TValue> myCollection;
    [NotNullAttribute]
private Dictionary`2<Action`2<Lifetime, TValue>, Lifetime> myViewers;
    [NotNullAttribute]
private Dictionary`2<TValue, LifetimeDefinition> myValueLifetimes;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public ViewableCollection`1(Lifetime lifetime);
    public ViewableCollection`1(Lifetime lifetime, ICollection`1<TValue> collection);
    private static ViewableCollection`1();
    public sealed virtual void View(Lifetime lifetime, Action`2<Lifetime, TValue> viewer);
    private void View(Lifetime viewLifetime, TValue value, Action`2<Lifetime, TValue> observer);
    private void Unview(TValue value);
    [NotNullAttribute]
private Lifetime GetValueLifetime(TValue value);
    public sealed virtual IEnumerator`1<TValue> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Add(TValue item);
    public void Add(Lifetime lifetime, TValue item);
    public void AddRange(Lifetime lifetime, IEnumerable`1<TValue> items);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(TValue item);
    public sealed virtual void CopyTo(TValue[] array, int arrayIndex);
    public sealed virtual bool Remove(TValue item);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
}
[DebuggerStepThroughAttribute]
public static class JetBrains.DataFlow.WinFormsProperty : object {
    [NotNullAttribute]
public static IProperty`1<TValue> Create(Lifetime lifetime, TSource source, Expression`1<Func`2<TSource, TValue>> propertyExpression, bool sinkEvents);
    [ObsoleteAttribute("Use overload with lifetime.")]
[NotNullAttribute]
public static IProperty`1<TValue> Create(TSource source, Expression`1<Func`2<TSource, TValue>> propertyExpression, bool sinkEvents);
    [ObsoleteAttribute("Use strong-typed overload with lifetime.")]
[NotNullAttribute]
public static IProperty`1<TValue> Create(object source, string propertyName, bool sinkEvents);
    private static IProperty`1<TValue> Create(Lifetime lifetime, object source, PropertyInfo propinfo, bool sinkEvents);
    private static void BindDataFlowToWinForms(Lifetime lifetime, IProperty`1<TValue> property, object source, PropertyInfo propinfo);
    private static void BindWinFormsToDataFlow(Lifetime lifetime, IProperty`1<TValue> property, object source, PropertyInfo propinfo);
}
[ExtensionAttribute]
public static class JetBrains.DictionaryEx : object {
    [ExtensionAttribute]
[PureAttribute]
public static TValue GetValueSafe(IDictionary`2<TKey, TValue> dictionary, TKey key, TValue resultOnFail);
    [ExtensionAttribute]
[PureAttribute]
public static TValue GetReadOnlyValueSafe(IReadOnlyDictionary`2<TKey, TValue> dictionary, TKey key, TValue resultOnFail);
    [PureAttribute]
[ExtensionAttribute]
public static TValue GetValueSafe(Dictionary`2<TKey, TValue> dictionary, TKey key, TValue resultOnFail);
    [PureAttribute]
[ExtensionAttribute]
[CanBeNullAttribute]
public static TKey FindKey(IDictionary`2<TKey, TValue> dictionary, TValue value);
    [ExtensionAttribute]
public static void Add(IDictionary`2<TKey, TValue> dictionary, Lifetime lifetime, TKey key, TValue value);
    [PureAttribute]
[ExtensionAttribute]
public static bool DictionaryEquals(IDictionary`2<TKey, TValue> left, IDictionary`2<TKey, TValue> right);
    [ExtensionAttribute]
[PureAttribute]
public static bool DictionaryEquals(IDictionary`2<TKey, TValue> left, IDictionary`2<TKey, TValue> right, IEqualityComparer`1<TValue> valueComparer);
    [ExtensionAttribute]
[PureAttribute]
public static int DictionaryGetHashCode(IDictionary`2<TKey, TValue> dictionary);
}
[ExtensionAttribute]
public static class JetBrains.Extension.ICustomAttributeProviderEx : object {
    [ExtensionAttribute]
public static IEnumerable`1<TAttribute> GetCustomAttributesByType(ICustomAttributeProvider attributeProvider, bool inherit);
    [NotNullAttribute]
[ExtensionAttribute]
public static TAttribute GetCustomAttributeByType(ICustomAttributeProvider attributeProvider, bool inherit);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static TAttribute GetCustomAttributeByTypeSafe(ICustomAttributeProvider attributeProvider, bool inherit);
    [ExtensionAttribute]
public static Pair`2<TAttribute, Type> GetCustomAttributeFromHierarchy(Type type);
    [NotNullAttribute]
[ExtensionAttribute]
public static TAttribute GetCustomAttributeNoInherit(ICustomAttributeProvider attrprovider);
    [ExtensionAttribute]
public static bool HasCustomAttributeNoInherit(ICustomAttributeProvider attrprovider);
    [CanBeNullAttribute]
[ExtensionAttribute]
public static TAttribute TryGetCustomAttributeNoInherit(ICustomAttributeProvider attrprovider);
}
[ExtensionAttribute]
public static class JetBrains.Extension.SerializationInfoEx : object {
    [ExtensionAttribute]
public static TValue GetValue(SerializationInfo this, string name);
}
[ExtensionAttribute]
public static class JetBrains.Extension.StreamEx : object {
    private static int BufferSize;
    private static BufferSlot[] ourBuffers;
    private static StreamEx();
    [ExtensionAttribute]
public static int Read(Stream stream, Byte[] buffer);
    [NotNullAttribute]
[ExtensionAttribute]
public static Byte[] ReadAllBytes(Stream stream);
    [NotNullAttribute]
[ExtensionAttribute]
public static MemoryStream ToMemoryStream(Stream stream);
    [ExtensionAttribute]
public static void StreamReader(Stream stream, Action`1<StreamReader> FRead);
    [ExtensionAttribute]
public static void StreamWriter(Stream stream, Action`1<StreamWriter> FWrite);
    [ExtensionAttribute]
public static void Write(Stream stream, Byte[] buffer);
    [ExtensionAttribute]
public static void DeflateCompress(Stream stream, Action`1<DeflateStream> FWriter);
    [ExtensionAttribute]
public static void DeflateDecompress(Stream stream, Action`1<DeflateStream> FReader);
    [ExtensionAttribute]
public static void CopyStream(Stream input, Stream output, int chunksize);
    [ExtensionAttribute]
public static int CopyToMemory(Stream input, Void* dstPtr, int size, int chunksize);
    [ExtensionAttribute]
public static void Write(Stream output, Void* pData, int cbSize, int chunksize);
    [ExtensionAttribute]
public static void Write(Stream output, ByteBuffer buffer, UInt32 chunksize);
    [ExtensionAttribute]
public static void Write(Stream output, Void* pData, ulong cbSize, UInt32 chunksize);
    [ExtensionAttribute]
public static ulong Read(Stream input, Void* pData, ulong cbSize, UInt32 chunksize);
    [NotNullAttribute]
[ExtensionAttribute]
public static Stream Rewind(Stream thіs);
    [NotNullAttribute]
[ExtensionAttribute]
public static Stream EraseAndRewind(Stream thіs);
    public static bool StreamEquals(Stream x, Stream y, UInt32 cdwChunkSize);
    private static Pair`2<int, Byte[]> GetBuffer(long length);
    [ExtensionAttribute]
public static TextAndEncoding ReadTextFromFile(Stream stream);
    private static Encoding RemoveBomFromKnownEncodings(Encoding encoding);
    [ExtensionAttribute]
public static string ReadTextFromFile(Stream stream, Encoding& detectedEncoding);
    private static string GetText(Byte[] bytes, int length, int bomStart, int bomLength, Encoding encoding);
    private static void ReleaseBuffer(int index);
    [ExtensionAttribute]
public static void WriteStructure(Stream self, T structure);
    [ExtensionAttribute]
public static void WriteUtf8(Stream stream, string text);
    [ExtensionAttribute]
[NotNullAttribute]
public static Stream AsSeekable(Stream maybeSequential);
    [ExtensionAttribute]
public static void TransformBlock(ICryptoTransform crypt, Stream stream);
}
[ExtensionAttribute]
public static class JetBrains.Extension.TimeSpanEx : object {
    public static long SecondInMilliseconds;
    public static long MinuteInMilliseconds;
    public static long HourInMilliseconds;
    public static long DayInMilliseconds;
    public static long MonthInMilliseconds;
    [ExtensionAttribute]
public static TimeSpan CoerceInfiniteForWinApi(TimeSpan timeout);
    [ExtensionAttribute]
public static TimeSpan Div(TimeSpan timespan, double value);
    [ExtensionAttribute]
public static bool IsAnyInfinite(TimeSpan timeout);
    public static TimeSpan Max(TimeSpan a, TimeSpan b);
    public static TimeSpan Min(TimeSpan a, TimeSpan b);
    [ExtensionAttribute]
public static TimeSpan Mul(TimeSpan timespan, double value);
    public static TimeSpan FromMilliseconds(long milliseconds, long maxValue);
}
[ExtensionAttribute]
public static class JetBrains.Extension.TypeEx : object {
    private static Char[] GenericsInTypeNameBeginWith;
    [CompilerGeneratedAttribute]
private static StringSourceFixedDelegate`2<StringSource, StringSource> CS$<>9__CachedAnonymousMethodDelegate9;
    private static TypeEx();
    [ExtensionAttribute]
public static object GetDefaultValue(Type type);
    public static bool IsDefaultValue(object value);
    [ExtensionAttribute]
public static bool IsDefaultValue(Type type, object value);
    [ExtensionAttribute]
public static bool IsDefaultValueOrEmptyString(Type type, object value);
    public static bool IsDefaultValueOrEmptyString(object value);
    public static object CoercePrimitiveValueToType(object primitive, Type typeTarget, ILogger logger);
    public static StringSlice GetLocalNameFromFullTypeName(string fullname, bool isKeepingOuterClasses);
    public static StringSlice GetLocalNameFromFullTypeName(StringSlice fullname, bool isKeepingOuterClasses);
    public static StringSource GetLocalNameFromFullTypeName(StringSource fullname, bool isKeepingOuterClasses);
    public static StringSlice GetTypeNameWithoutGenericArgs(string fullname);
    public static StringSource GetTypeNameWithoutGenericArgs(StringSource fullname);
    public static bool EqualsTypeNameWithoutGenericArgs(StringSource fullname, StringSource nameNoArgs);
    public static StringSlice GetTypeNameWithoutGenericArgs(StringSlice fullname);
    public static StringSlice GetNamespaceFromFullTypeName(StringSlice fullname);
    public static StringSlice GetNamespaceFromFullTypeName(string fullname);
    public static StringSource GetNamespaceFromFullTypeName(StringSource fullname);
    [CompilerGeneratedAttribute]
private static StringSource <GetTypeNameWithoutGenericArgs>b__8(Char* pch, UInt32 cchLength, StringSource fullnameClosure);
}
[ExtensionAttribute]
public static class JetBrains.Extension.TypeEx_NetCore15 : object {
    [ExtensionAttribute]
[NotNullAttribute]
public static string QuoteIfNeeded(Type type);
}
[FlagsAttribute]
public enum JetBrains.Metadata.Access.AssemblyFlags : Enum {
    public int value__;
    public static AssemblyFlags SideBySideCompatible;
    public static AssemblyFlags PublicKey;
    public static AssemblyFlags Retargetable;
    public static AssemblyFlags DisableJITcompileOptimizer;
    public static AssemblyFlags EnableJITcompileTracking;
    public static AssemblyFlags ProcessorArchitectureMask;
    public static AssemblyFlags ProcessorArchitectureNone;
    public static AssemblyFlags ProcessorArchitectureMsil;
    public static AssemblyFlags ProcessorArchitectureX86;
    public static AssemblyFlags ProcessorArchitectureIA64;
    public static AssemblyFlags ProcessorArchitectureAMD64;
    public static AssemblyFlags ProcessorArchitectureFullMask;
    public static AssemblyFlags ProcessorArchitectureSpecified;
    public static AssemblyFlags ContentTypeMask;
    public static AssemblyFlags ContentTypeDefault;
    public static AssemblyFlags ContentTypeWindowsRuntime;
}
public enum JetBrains.Metadata.Access.AssemblyHashAlgorithm : Enum {
    public UInt32 value__;
    public static AssemblyHashAlgorithm None;
    public static AssemblyHashAlgorithm MD5;
    public static AssemblyHashAlgorithm SHA1;
    public static AssemblyHashAlgorithm SHA256;
    public static AssemblyHashAlgorithm SHA384;
    public static AssemblyHashAlgorithm SHA512;
    public static AssemblyHashAlgorithm MD2;
    public static AssemblyHashAlgorithm MD4;
    public static AssemblyHashAlgorithm MAC;
    public static AssemblyHashAlgorithm Ssl3ShaMd5;
    public static AssemblyHashAlgorithm HMAC;
    public static AssemblyHashAlgorithm TLS1PRF;
    public static AssemblyHashAlgorithm HashReplaceOwf;
}
public class JetBrains.Metadata.Utils.AssemblyNameAndLocation : ValueType {
    [CanBeNullAttribute]
public FileSystemPath AssemblyLocation;
    [CanBeNullAttribute]
public AssemblyNameInfo AssemblyName;
    public AssemblyNameAndLocation(AssemblyNameInfo assemblyName, FileSystemPath assemblyLocation);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(AssemblyNameAndLocation other);
    public virtual int GetHashCode();
    public static bool op_Equality(AssemblyNameAndLocation left, AssemblyNameAndLocation right);
    public static bool op_Inequality(AssemblyNameAndLocation left, AssemblyNameAndLocation right);
    public virtual string ToString();
}
[ExtensionAttribute]
public static class JetBrains.Metadata.Utils.AssemblyNameExtensions : object {
    public static double MAX_DISTANCE;
    public static double BIG_DISTANCE;
    private static int MAX_VERSION_COMPONENT_VALUE;
    public static long FAVOR_MAJOR_MINOR_DISTANCE;
    [NotNullAttribute]
public static String[] AllPossibleExtensionsForModules;
    private static AssemblyNameExtensions();
    [CanBeNullAttribute]
[ObsoleteAttribute("This method might silently return NULL instead of throwing an exception, which is a contract violation for Parse methods. Use either AssemblyName::Parse or AssemblyName::TryParse, depending on what you need.")]
public static AssemblyNameInfo ParseAssemblyName(string assemblyFullName);
    [ExtensionAttribute]
public static bool ReferenceMatchesDefinition(AssemblyNameInfo ref, AssemblyNameInfo def);
    [ExtensionAttribute]
public static bool IsMscorlib(AssemblyNameInfo assemblyName);
    [ExtensionAttribute]
public static bool IsWindowsWinmd(AssemblyNameInfo assemblyName);
    [ExtensionAttribute]
public static bool IsSystemRuntime(AssemblyNameInfo assemblyName);
    [ExtensionAttribute]
public static bool IsNetstandard(AssemblyNameInfo assemblyName);
    [ExtensionAttribute]
public static bool PossiblyContainsPredefinedTypes(AssemblyNameInfo assemblyName);
    [NotNullAttribute]
[ExtensionAttribute]
public static FileSystemPath EvaluateFileSystemPath(AssemblyNameInfo assemblyName);
    public static bool CompareNameAndVersion(AssemblyNameInfo name1, AssemblyNameInfo name2);
    public static bool CompareName(AssemblyNameInfo name1, AssemblyNameInfo name2);
    private static double ComputeDistanceComponent(int firstVersionComponent, int secondVersionComponent);
    private static double Distance(Version first, Version second);
    public static double Distance(AssemblyNameInfo required, AssemblyNameInfo candidate);
    public static Byte[] GetPublicKeyToken(string value);
    public static Byte[] GetPublicKey(string value);
    public static void GetPublicKeyTokenString(Byte[] value, StringBuilder sb);
    public static string GetPublicKeyTokenString(Byte[] value);
    [CanBeNullAttribute]
public static AssemblyNameInfo ChooseAssemblyName(AssemblyNameInfo name, IList`1<AssemblyNameInfo> candidates, Int32& index);
    [CanBeNullAttribute]
public static AssemblyNameInfo ChooseAssemblyName(AssemblyNameInfo name, IList`1<AssemblyNameInfo> candidates, Int32& index, Func`3<AssemblyNameInfo, AssemblyNameInfo, bool> assemblyNameInfoComparer);
    public static bool ComparePublicKeyToken(AssemblyName name, Byte[] token);
    public static bool CompareIgnoreCultureAndVersion(AssemblyNameInfo name1, AssemblyNameInfo name2);
    public static Uri GetCodeBase(string fullPath);
    public static bool Matches(AssemblyNameInfo name1, AssemblyNameInfo name2);
    private static bool MatchCultureValue(string o1, string o2);
    private static bool MatchValue(object o1, object o2);
    [NotNullAttribute]
[ExtensionAttribute]
public static AssemblyNameInfo GetNameInfo(Assembly ass);
}
[TypeConverterAttribute("JetBrains.Metadata.Utils.AssemblyNameInfoConverter")]
[ValueSerializerAttribute("JetBrains.Metadata.Utils.AssemblyNameInfoSerializer")]
public class JetBrains.Metadata.Utils.AssemblyNameInfo : object {
    public static string CultureNeutral;
    private static Byte[] ourNeutralPublicKey;
    private static Byte[] ourNeutralPublicKeyToken;
    public static AssemblyNameInfo Empty;
    [CanBeNullAttribute]
private string myFullName;
    private int myCachedHashCode;
    [NotNullAttribute]
private string mySimpleName;
    [CanBeNullAttribute]
private string myCulture;
    [CanBeNullAttribute]
private Version myVersion;
    private PublicKeyToken myPublicKeyToken;
    [CanBeNullAttribute]
private Byte[] myPublicKey;
    private ProcessorArchitecture myProcessorArchitecture;
    private bool myIsRetargetable;
    private AssemblyIdentityContentTypes myContentType;
    private object myCustom;
    public static StringComparer SimpleNameComparer;
    public static StringComparer CultureComparer;
    [CompilerGeneratedAttribute]
private string <CodeBase>k__BackingField;
    [CompilerGeneratedAttribute]
private AssemblyHashAlgorithm <PublicKeyTokenHashAlgorithm>k__BackingField;
    public bool IsRetargetable { get; }
    public AssemblyIdentityContentTypes ContentType { get; }
    public bool IsStrongName { get; }
    public string FullName { get; }
    [NotNullAttribute]
public string Name { get; }
    [CanBeNullAttribute]
public Version Version { get; }
    [ObsoleteAttribute("Use Culture property instead. Reason: this is not the CultureInfo object of the CLR AssemblyName type, but only its name.")]
[CanBeNullAttribute]
public string CultureInfo { get; }
    [CanBeNullAttribute]
public string Culture { get; }
    [ObsoleteAttribute("The flags are not in use anymore, and will always have a zero value.")]
public AssemblyNameInfoFlags Flags { get; }
    [CanBeNullAttribute]
public string CodeBase { get; private set; }
    public ProcessorArchitecture ProcessorArchitecture { get; }
    public object Custom { get; }
    public AssemblyHashAlgorithm PublicKeyTokenHashAlgorithm { get; private set; }
    [ObsoleteAttribute("Use Parse() factory method, or cast from a string.")]
public AssemblyNameInfo(AssemblyName clr);
    [ObsoleteAttribute("Use Parse() or an explicit cast operator instead.")]
public AssemblyNameInfo(string fullname);
    [ObsoleteAttribute("Use Create() instead, for interning.")]
public AssemblyNameInfo(string simplename, Version version, PublicKeyToken pktoken, string culture, string codeBase, Byte[] publickey, ProcessorArchitecture processor, bool isRetargetable, AssemblyIdentityContentTypes contenttype, object custom, AssemblyHashAlgorithm hashalg);
    public AssemblyNameInfo(BinaryReader reader);
    public AssemblyNameInfo(UnsafeReader reader);
    private static AssemblyNameInfo();
    public bool get_IsRetargetable();
    public AssemblyIdentityContentTypes get_ContentType();
    public bool get_IsStrongName();
    [ContractAnnotationAttribute("culturename:null=>null")]
private static string SubstNeutralForEmptyCultureName(string culturename);
    private static string SubstNeutralForEmptyCultureName(StringSource culturename);
    public string get_FullName();
    private string GetFullNameCold();
    public string get_Name();
    public Version get_Version();
    public string get_CultureInfo();
    public string get_Culture();
    public AssemblyNameInfoFlags get_Flags();
    [CompilerGeneratedAttribute]
public string get_CodeBase();
    [CompilerGeneratedAttribute]
private void set_CodeBase(string value);
    public ProcessorArchitecture get_ProcessorArchitecture();
    public object get_Custom();
    [CompilerGeneratedAttribute]
public AssemblyHashAlgorithm get_PublicKeyTokenHashAlgorithm();
    [CompilerGeneratedAttribute]
private void set_PublicKeyTokenHashAlgorithm(AssemblyHashAlgorithm value);
    [CanBeNullAttribute]
public static AssemblyNameInfo TryParse(string s);
    [NotNullAttribute]
public static AssemblyNameInfo Parse(string s);
    [NotNullAttribute]
public static AssemblyNameInfo Parse(StringSource text);
    [NotNullAttribute]
public static AssemblyNameInfo Create(string simplename, Version version, PublicKeyToken pktoken, string culture, string codeBase, Byte[] publickey, ProcessorArchitecture processor, bool isRetargetable, AssemblyIdentityContentTypes contenttype, object custom, AssemblyHashAlgorithm hashalg);
    [NotNullAttribute]
private string BuildFullName();
    public void Write(BinaryWriter writer);
    public void Write(UnsafeWriter writer);
    public static AssemblyNameInfo Read(BinaryReader reader);
    public static AssemblyNameInfo Read(UnsafeReader reader);
    [ObsoleteAttribute("Use GetPublicKeyToken2 wherever possible.")]
public Byte[] GetPublicKeyToken();
    public PublicKeyToken GetPublicKeyToken2();
    public Byte[] GetPublicKey();
    public static PublicKeyToken ComputePublicKeyTokenOnKey(Byte[] key, AssemblyHashAlgorithm algId);
    public virtual string ToString();
    public bool Equals(AssemblyNameInfo other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(AssemblyNameInfo left, AssemblyNameInfo right);
    public static bool op_Inequality(AssemblyNameInfo left, AssemblyNameInfo right);
    [ContractAnnotationAttribute("null => null; notnull => notnull")]
public static AssemblyNameInfo op_Explicit(string value);
    [ContractAnnotationAttribute("null => null; notnull => notnull")]
public static string op_Explicit(AssemblyNameInfo value);
    public static Nullable`1<bool> MemberwiseEqual(AssemblyNameInfo x, AssemblyNameInfo y);
    public static bool KeysEqual(AssemblyNameInfo x, AssemblyNameInfo y);
    [CompilerGeneratedAttribute]
private object <.ctor>b__0();
    [CompilerGeneratedAttribute]
private object <.ctor>b__1();
    [CompilerGeneratedAttribute]
private object <.ctor>b__3();
}
public class JetBrains.Metadata.Utils.AssemblyNameInfoConverter : TypeConverterBase`1<AssemblyNameInfo> {
    [CompilerGeneratedAttribute]
private static Func`4<ITypeDescriptorContext, CultureInfo, AssemblyNameInfo, string> CS$<>9__CachedAnonymousMethodDelegate2;
    [CompilerGeneratedAttribute]
private static Func`4<ITypeDescriptorContext, CultureInfo, string, AssemblyNameInfo> CS$<>9__CachedAnonymousMethodDelegate3;
    [CompilerGeneratedAttribute]
private static string <.ctor>b__0(ITypeDescriptorContext context, CultureInfo arg3, AssemblyNameInfo assname);
    [CompilerGeneratedAttribute]
private static AssemblyNameInfo <.ctor>b__1(ITypeDescriptorContext context, CultureInfo info, string text);
}
[ExtensionAttribute]
public static class JetBrains.Metadata.Utils.AssemblyNameInfoEx : object {
    [ExtensionAttribute]
[ContractAnnotationAttribute("null => true")]
public static bool IsNullOrEmpty(AssemblyNameInfo info);
}
[FlagsAttribute]
[ObsoleteAttribute("The flags are not in use anymore, and will always have a zero value.")]
public enum JetBrains.Metadata.Utils.AssemblyNameInfoFlags : Enum {
    public UInt32 value__;
    [ObsoleteAttribute("The flags are not in use anymore, and will always have a zero value.")]
public static AssemblyNameInfoFlags None;
    [ObsoleteAttribute("The flags are not in use anymore, and will always have a zero value.")]
public static AssemblyNameInfoFlags PublicKey;
    [ObsoleteAttribute("The flags are not in use anymore, and will always have a zero value.")]
public static AssemblyNameInfoFlags Retargetable;
    [ObsoleteAttribute("The flags are not in use anymore, and will always have a zero value.")]
public static AssemblyNameInfoFlags WindowsRuntime;
}
public class JetBrains.Metadata.Utils.AssemblyNameInfoSerializer : ValueSerializerBase`1<AssemblyNameInfo> {
    [CompilerGeneratedAttribute]
private static Func`3<IValueSerializerContext, AssemblyNameInfo, string> CS$<>9__CachedAnonymousMethodDelegate2;
    [CompilerGeneratedAttribute]
private static Func`3<IValueSerializerContext, string, AssemblyNameInfo> CS$<>9__CachedAnonymousMethodDelegate3;
    [CompilerGeneratedAttribute]
private static string <.ctor>b__0(IValueSerializerContext context, AssemblyNameInfo info);
    [CompilerGeneratedAttribute]
private static AssemblyNameInfo <.ctor>b__1(IValueSerializerContext context, string s);
}
public static class JetBrains.Metadata.Utils.AssemblyNames : object {
    public static string MicrosoftVisualBasic;
    public static string MicrosoftCSharp;
    public static string Mscorlib;
    public static string Netstandard;
    public static string SystemCore;
    public static string SystemRuntime;
    public static string System;
    public static string Windows;
}
public class JetBrains.Metadata.Utils.PublicKeyToken : ValueType {
    private static ReadonlyToken myExtra_Deferred;
    private static ReadonlyToken myExtra_NullOrNeutral;
    [CanBeNullAttribute]
private object myExtra;
    private ulong myValue;
    public bool IsNotNull { get; }
    public bool IsNotSet { get; }
    public bool IsNull { get; }
    public static PublicKeyToken Neutral { get; }
    public static PublicKeyToken NotSet { get; }
    public static PublicKeyToken Null { get; }
    private PublicKeyToken(ulong value, object extra);
    private static PublicKeyToken();
    [PureAttribute]
public bool get_IsNotNull();
    [PureAttribute]
public bool get_IsNotSet();
    [PureAttribute]
public bool get_IsNull();
    [PureAttribute]
public static PublicKeyToken get_Neutral();
    [PureAttribute]
public static PublicKeyToken get_NotSet();
    [PureAttribute]
public static PublicKeyToken get_Null();
    [PureAttribute]
public sealed virtual bool Equals(PublicKeyToken other);
    [PureAttribute]
public virtual bool Equals(object obj);
    public static PublicKeyToken FromArray(Byte[] tokenbytes);
    public static PublicKeyToken FromNonNullValue(ulong value);
    public static PublicKeyToken FromValueAndAttrFlags(ulong value, AssemblyIdentityFlags flags);
    [CanBeNullAttribute]
public Byte[] GetArray();
    [CanBeNullAttribute]
public Byte[] GetArrayOrNull();
    [PureAttribute]
public AssemblyIdentityFlags GetAttrFlags();
    [PureAttribute]
public virtual int GetHashCode();
    [PureAttribute]
public ulong GetValue();
    [PureAttribute]
public ulong GetValueOrNull();
    [PureAttribute]
public static bool op_Equality(PublicKeyToken left, PublicKeyToken right);
    [PureAttribute]
public static bool op_Inequality(PublicKeyToken left, PublicKeyToken right);
    [PureAttribute]
public virtual string ToString();
    public static PublicKeyToken Parse(string tokentext);
    public static PublicKeyToken TryParse(string tokentext);
    private static PublicKeyToken TryParseCore(string tokentext, OnError onerror);
}
[ExtensionAttribute]
public static class JetBrains.NumberUtil : object {
    public static string FloatingToStringRoundtrip(T value);
    [ExtensionAttribute]
public static int Kilobytes(int number);
    [ExtensionAttribute]
public static int Megabytes(int number);
    [ExtensionAttribute]
public static bool IsNanOrInf(double number);
    [ExtensionAttribute]
public static bool IsNaN(double number);
    [ExtensionAttribute]
public static bool IsPositiveInfinity(double number);
    [ExtensionAttribute]
public static bool IsNegativeInfinity(double number);
    [ExtensionAttribute]
public static bool IsInfinity(double number);
    [ExtensionAttribute]
public static bool IsPositiveZero(double value);
    [ExtensionAttribute]
public static bool IsNegativeZero(double value);
    [ExtensionAttribute]
public static bool IsNaN(float value);
    [ExtensionAttribute]
public static bool IsNanOrInf(float number);
    [ExtensionAttribute]
public static bool IsPositiveInfinity(float number);
    [ExtensionAttribute]
public static bool IsNegativeInfinity(float number);
    [ExtensionAttribute]
public static bool IsInfinity(float number);
    [ExtensionAttribute]
public static bool IsPositiveZero(float number);
    [ExtensionAttribute]
public static bool IsNegativeZero(float number);
    [ExtensionAttribute]
public static double Clamp(double value, double min, double max);
    [ExtensionAttribute]
public static int Clamp(int value, int min, int max);
    [ExtensionAttribute]
public static bool InRange(T value, T min, T max);
}
public class JetBrains.Platform.RdFramework.Impl.ExceptionEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    public Exception Exception { get; private set; }
    public ExceptionEventArgs(Exception exception);
    [CompilerGeneratedAttribute]
public Exception get_Exception();
    [CompilerGeneratedAttribute]
private void set_Exception(Exception value);
}
public class JetBrains.Platform.RdFramework.Impl.SimpleBackgroundThreadDispatcher : object {
    [NotNullAttribute]
private ILog myLogger;
    [NotNullAttribute]
private BlockingPriorityQueue`1<ArtOfAction> myQueue;
    private Thread myThread;
    public IScheduler PriorityScheduler;
    private EventHandler`1<ExceptionEventArgs> OnActionException;
    private EventHandler`1<ExceptionEventArgs> OnSchedulerException;
    private EventHandler OnExit;
    [CompilerGeneratedAttribute]
private static EventHandler`1<ExceptionEventArgs> CS$<>9__CachedAnonymousMethodDelegate3;
    [CompilerGeneratedAttribute]
private static EventHandler`1<ExceptionEventArgs> CS$<>9__CachedAnonymousMethodDelegate4;
    [CompilerGeneratedAttribute]
private static EventHandler CS$<>9__CachedAnonymousMethodDelegate5;
    public bool IsActive { get; }
    public bool OutOfOrderExecution { get; }
    public SimpleBackgroundThreadDispatcher(Lifetime lifetime, ILog logger);
    public void StartAsync();
    public void InitSync();
    public void Run();
    public void add_OnActionException(EventHandler`1<ExceptionEventArgs> value);
    public void remove_OnActionException(EventHandler`1<ExceptionEventArgs> value);
    public void add_OnSchedulerException(EventHandler`1<ExceptionEventArgs> value);
    public void remove_OnSchedulerException(EventHandler`1<ExceptionEventArgs> value);
    public void add_OnExit(EventHandler value);
    public void remove_OnExit(EventHandler value);
    public sealed virtual bool get_IsActive();
    public sealed virtual bool get_OutOfOrderExecution();
    internal void Queue0(ArtOfAction action);
    public sealed virtual void Queue(Action action);
    [CompilerGeneratedAttribute]
private static void <.ctor>b__0(object param0, ExceptionEventArgs param1);
    [CompilerGeneratedAttribute]
private static void <.ctor>b__1(object param0, ExceptionEventArgs param1);
    [CompilerGeneratedAttribute]
private static void <.ctor>b__2(object param0, EventArgs param1);
}
[ExtensionAttribute]
public static class JetBrains.Reflection.ReflectionExtensions : object {
    public static Assembly Mscorlib;
    [CompilerGeneratedAttribute]
private static Func`2<ConstantExpression, object> CS$<>9__CachedAnonymousMethodDelegate12;
    private static ReflectionExtensions();
    public static object ParseInvariantString(string value, Type type, ILogger logger);
    public static T ParseInvariantString(string value, ILogger logger);
    [NotNullAttribute]
public static string ToInvariantString(object value, ILogger logger);
    [ExtensionAttribute]
public static T GetDynamicField(object obj, string sFieldName);
    [ExtensionAttribute]
public static object GetDynamicField(object obj, string sFieldName, OnError onerror);
    [ExtensionAttribute]
public static T GetDynamicProperty(object reflectedObject, string propertyName, OnError onerror);
    [ExtensionAttribute]
public static object GetDynamicProperty(object reflectedObject, string propertyName, OnError onerror);
    [EditorBrowsableAttribute("1")]
[ExtensionAttribute]
public static object GetFieldOrPropertyValue(object host, string fieldName);
    [ExtensionAttribute]
private static PropertyInfo TryGetProperty(Type type, string propertyName);
    [ExtensionAttribute]
private static FieldInfo TryGetField(Type type, string sFieldName);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static TValue GetFieldOrPropertyValue(object host, string fieldName);
    [ExtensionAttribute]
public static object InvokeDynamicMethod(object reflectedObject, string sMethodName, Object[] args);
    [ExtensionAttribute]
public static T InvokeDynamicMethodInfo(object reflectedObject, string sMethodName, OnError onerror, Object[] args);
    [ExtensionAttribute]
public static object InvokeDynamicMethodInfo(object reflectedObject, string sMethodName, OnError onerror, Object[] args);
    [ExtensionAttribute]
public static void SetDynamicProperty(object reflectedObject, string propertyName, object value);
    [ExtensionAttribute]
public static void SetDynamicFieldOrProperty(object thіs, string membername, object value);
    [ExtensionAttribute]
public static object GetDynamicFieldOrProperty(object thіs, string membername);
    [ExtensionAttribute]
public static IEnumerable`1<Type> GetBaseClassesAndInterfaces(Type type);
    [ExtensionAttribute]
public static IEnumerable`1<Type> GetAllAssignableToTypes(Type type);
    [ExtensionAttribute]
[NotNullAttribute]
public static string GetInstanceMemberName(Expression`1<Func`2<TContainingType, object>> lambdaexpression);
    [NotNullAttribute]
[ExtensionAttribute]
public static string GetStaticMemberName(Expression`1<Func`1<object>> lambdaexpression);
    [ExtensionAttribute]
[NotNullAttribute]
public static MemberInfo GetInstanceMember(Expression`1<Func`2<TContainingType, object>> lambdaexpression);
    [NotNullAttribute]
[ExtensionAttribute]
public static MemberInfo GetStaticMember(Expression`1<Func`1<object>> lambdaexpression);
    [NotNullAttribute]
[ExtensionAttribute]
public static string GetInstanceMemberName(Expression`1<Func`2<TContainingType, TMemberValue>> lambdaexpression);
    [NotNullAttribute]
[ExtensionAttribute]
public static string GetInstanceMemberName(LambdaExpression lambdaexpression);
    [NotNullAttribute]
public static LambdaExpression CreateFieldAccessExpression(string fieldName);
    [NotNullAttribute]
public static Expression`1<Func`2<TContainingType, TResultType>> CreateTypedFieldAccessExpression(string fieldName);
    [ExtensionAttribute]
[NotNullAttribute]
public static MemberInfo GetInstanceMember(Expression`1<Func`2<TContainingType, TMemberValue>> lambdaexpression);
    [NotNullAttribute]
private static MemberInfo GetInstanceMemberCore(Expression expression);
    [NotNullAttribute]
[ExtensionAttribute]
[ItemNotNullAttribute]
public static IEnumerable`1<MemberInfo> GetInstanceMembersChain(Expression expression);
    [NotNullAttribute]
public static JetHashSet`1<Assembly> AddAssemblyReferencesTransitively(IEnumerable`1<Assembly> assemblies);
    [CompilerGeneratedAttribute]
private static object <GetInstanceMemberCore>b__11(ConstantExpression constexpr);
}
[ExtensionAttribute]
public static class JetBrains.Reflection.StringConversion : object {
    [ThreadStaticAttribute]
private static Dictionary`2<Type, TypeConverter> myMapTypeConverters;
    [ThreadStaticAttribute]
private static Dictionary`2<Type, ValueSerializer> myMapValueSerializers;
    [NotNullAttribute]
public static string ToInvariantString(object value, ILogger logger);
    public static object ParseInvariantString(string value, Type type, ILogger logger);
    public static T ParseInvariantString(string value, ILogger logger);
    [NotNullAttribute]
[ExtensionAttribute]
public static ILogger GetSomeLogger(ITypeDescriptorContext thіs);
    [NotNullAttribute]
private static TypeConverter GetTypeConverter(Type type);
    [CanBeNullAttribute]
private static ValueSerializer TryGetValueSerializer(Type typeValue);
}
[ExtensionAttribute]
public static class JetBrains.StringEx : object {
    [ExtensionAttribute]
public static T ToEnum(string s, bool ignoreCase);
    [ExtensionAttribute]
public static T ToEnum(string s, T defaultValue, bool ignoreCase);
    [ExtensionAttribute]
public static T ToEnumSafe(string s, T defaultValue, bool ignoreCase);
    [ExtensionAttribute]
public static Nullable`1<T> ToEnumNullable(string s);
    [ExtensionAttribute]
public static Nullable`1<T> ToEnumNullableSafe(string s, Nullable`1<T> defaultValue, bool ignoreCase);
    [NotNullAttribute]
[ExtensionAttribute]
public static string AppendLine(string s, string line);
    [ExtensionAttribute]
public static bool Contains(string s, char value);
    [StringFormatMethodAttribute("format")]
[ExtensionAttribute]
[NotNullAttribute]
public static string FormatEx(string format, Object[] args);
    [NotNullAttribute]
[StringFormatMethodAttribute("format")]
[ExtensionAttribute]
public static string FormatNoInline(string format, Object[] args);
    [CompilerGeneratedAttribute]
private static object <ToEnum>b__0();
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Text.ArrayBuffer : object {
    private static int GapSize;
    private Char[] myBuffer;
    private int myLength;
    private string myText;
    public Char[] Buffer { get; }
    public int Length { get; }
    public char Item { get; }
    public ArrayBuffer(string text);
    public ArrayBuffer(IBuffer buf);
    public ArrayBuffer(Char[] buf);
    public Char[] get_Buffer();
    public sealed virtual int get_Length();
    public sealed virtual string GetText(TextRange range);
    public sealed virtual void AppendTextTo(StringBuilder builder, TextRange range);
    public sealed virtual string GetText();
    public sealed virtual void Insert(int offset, string text);
    public sealed virtual void Remove(int offset, int length);
    public sealed virtual void Replace(int offset, int length, string newText);
    public sealed virtual void Replace(int offset, int length, BufferRange newText);
    public sealed virtual char get_Item(int index);
    public sealed virtual void CopyTo(int sourceIndex, Char[] destinationArray, int destinationIndex, int length);
    private void EnsureCharArray(int capacity);
    [ConditionalAttribute("JET_MODE_ASSERT")]
private void AssertOffsetAndLength(int offset, int length);
    private void ThrowRangeException(int offset, int length);
    private void ThrowLengthException(int offset, int length);
    [CompilerGeneratedAttribute]
private object <ThrowRangeException>b__2();
    [CompilerGeneratedAttribute]
private object <ThrowLengthException>b__7();
}
public class JetBrains.Text.BufferRange : ValueType {
    private IBuffer myBuffer;
    private TextRange myRange;
    public IBuffer Buffer { get; }
    public TextRange Range { get; }
    public BufferRange(IBuffer buffer, TextRange range);
    public IBuffer get_Buffer();
    public TextRange get_Range();
    [PureAttribute]
[NotNullAttribute]
public string GetText();
    public void CopyTo(Char[] destinationArray, int destinationIndex);
}
public class JetBrains.Text.BufferTextReader : TextReader {
    private IBuffer myBuffer;
    private int myPosition;
    public BufferTextReader(IBuffer buffer);
    public virtual int Peek();
    public virtual int Read();
    public virtual int Read(Char[] buffer, int index, int count);
    public virtual string ReadToEnd();
}
[ExtensionAttribute]
public static class JetBrains.Text.BufferUtil : object {
    [ExtensionAttribute]
public static int IndexOfAny(IBuffer buffer, Char[] chars, int startIndex);
    [ExtensionAttribute]
public static int IndexOf(IBuffer buffer, string pattern, int startIndex, int count);
    [ExtensionAttribute]
public static int LastIndexOfAny(IBuffer buffer, Char[] chars, int startIndex);
    [ExtensionAttribute]
public static int LastIndexOf(IBuffer buffer, string pattern, int startIndex);
    [ExtensionAttribute]
public static bool CompareBufferText(IBuffer buffer, TextRange range, string str, bool caseSensitive);
    [ExtensionAttribute]
public static bool StartsWith(IBuffer buffer, string str, bool caseSensitive);
    [ExtensionAttribute]
public static bool EndsWith(IBuffer buffer, string str, bool caseSensitive);
}
[DefaultMemberAttribute("Item")]
public interface JetBrains.Text.IBuffer {
    public char Item { get; }
    public int Length { get; }
    public abstract virtual char get_Item(int index);
    public abstract virtual int get_Length();
    [NotNullAttribute]
[PureAttribute]
public abstract virtual string GetText();
    [NotNullAttribute]
[PureAttribute]
public abstract virtual string GetText(TextRange range);
    public abstract virtual void AppendTextTo(StringBuilder builder, TextRange range);
    public abstract virtual void CopyTo(int sourceIndex, Char[] destinationArray, int destinationIndex, int length);
}
public interface JetBrains.Text.IEditableBuffer {
    public abstract virtual void Insert(int offset, string text);
    public abstract virtual void Remove(int offset, int length);
    public abstract virtual void Replace(int offset, int length, string newText);
    public abstract virtual void Replace(int offset, int length, BufferRange newText);
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Text.ProjectedBuffer : object {
    private IBuffer myUnderlyingBuffer;
    private TextRange myRange;
    public int Length { get; }
    public int TextStartOffset { get; }
    public int TextEndOffset { get; }
    public char Item { get; }
    private ProjectedBuffer(IBuffer underlyingBuffer, TextRange range);
    public static IBuffer Create(IBuffer underlyingBuffer, TextRange range);
    public sealed virtual int get_Length();
    public int get_TextStartOffset();
    public int get_TextEndOffset();
    public sealed virtual string GetText();
    public sealed virtual string GetText(TextRange range);
    public sealed virtual void AppendTextTo(StringBuilder builder, TextRange range);
    public sealed virtual char get_Item(int index);
    public sealed virtual void CopyTo(int sourceIndex, Char[] destinationArray, int destinationIndex, int length);
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Text.StringBuffer : object {
    public static StringBuffer Empty;
    private string myString;
    public int Length { get; }
    public char Item { get; }
    public StringBuffer(string string);
    private static StringBuffer();
    public sealed virtual int get_Length();
    public sealed virtual string GetText();
    public sealed virtual string GetText(TextRange range);
    public sealed virtual void AppendTextTo(StringBuilder builder, TextRange range);
    public sealed virtual char get_Item(int index);
    public sealed virtual void CopyTo(int sourceIndex, Char[] destinationArray, int destinationIndex, int length);
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Text.StringBuilderBuffer : object {
    public static StringBuilderBuffer Empty;
    private StringBuilder myString;
    public int Length { get; }
    public char Item { get; }
    public StringBuilderBuffer(StringBuilder string);
    private static StringBuilderBuffer();
    public sealed virtual int get_Length();
    public sealed virtual string GetText();
    public sealed virtual string GetText(TextRange range);
    public sealed virtual void AppendTextTo(StringBuilder builder, TextRange range);
    public sealed virtual char get_Item(int index);
    public sealed virtual void CopyTo(int sourceIndex, Char[] destinationArray, int destinationIndex, int length);
}
public static class JetBrains.Text.WordUtil : object {
    public static Char[] SpaceDelimeters;
    private static WordUtil();
    public static bool IsDigit(char c);
    public static bool IsLower(char c);
    public static bool IsLowerOrDigit(char c);
    public static bool IsUpper(char c);
    public static bool IsUpperOrDigit(char c);
    public static bool IsLetter(char c);
    public static bool IsWordChar(char c);
    public static bool IsDelimiter(char c);
    public static bool IsHexDigit(char c);
    public static bool IsStopChar(char c);
    public static TextRange FindRange(IBuffer s, int pos, Predicate`1<char> predicate);
    public static TextRange FindWord(IBuffer s, int pos);
    public static TextRange FindWordOrStopCharRight(IBuffer s, int pos);
    public static TextRange FindWordLeft(IBuffer s, int pos);
    public static TextRange FindWordOrStopCharLeft(IBuffer s, int pos);
}
public class JetBrains.Threading.GroupingEvent : object {
    private long myDeadline;
    [CanBeNullAttribute]
private Action myFHandler;
    private GroupingEventHost myHost;
    [CanBeNullAttribute]
private ISimpleSignal myIncoming;
    [CanBeNullAttribute]
private ISimpleSignal myIncomingDontProlongate;
    private TimeSpan myInterval;
    private bool myIsExecuting;
    private IProperty`1<bool> myLazyIsWaiting;
    private SpinWaitLock myLockOutgoingField;
    [NotNullAttribute]
private string myName;
    [CanBeNullAttribute]
private ISimpleSignal modreq(System.Runtime.CompilerServices.IsVolatile) myOutgoing;
    public static TimeSpan MaxInterval;
    private Lifetime myLifetime;
    [NotNullAttribute]
public GroupingEventHost Host { get; }
    [NotNullAttribute]
public ISimpleSignal Incoming { get; }
    [NotNullAttribute]
public ISimpleSignal IncomingDontProlongate { get; }
    public TimeSpan Interval { get; }
    [NotNullAttribute]
public string Name { get; }
    [NotNullAttribute]
public ISimpleSignal Outgoing { get; }
    internal GroupingEvent(Lifetime lifetime, GroupingEventHost host, string name, TimeSpan interval, Action FFirstHandler);
    private static GroupingEvent();
    public GroupingEventHost get_Host();
    public ISimpleSignal get_Incoming();
    public ISimpleSignal get_IncomingDontProlongate();
    public TimeSpan get_Interval();
    public string get_Name();
    public ISimpleSignal get_Outgoing();
    public void CancelIncoming();
    public IProperty`1<bool> CreateIsWaitingProperty();
    public void FireIncoming();
    public void FireIncomingDontProlongate();
    public bool IsWaiting();
    internal void Execute();
    internal bool IsExpired(long datetimeNow);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
private void <.ctor>b__0();
    [CompilerGeneratedAttribute]
private void <.ctor>b__1();
    [CompilerGeneratedAttribute]
private void <.ctor>b__2();
}
public class JetBrains.Threading.GroupingEventHost : object {
    private Lifetime myLifetime;
    [NotNullAttribute]
private ClockTimer myClockTimer;
    private int myDebugTotalEvents;
    private int myDebugTotalThroughput;
    private List`1<GroupingEvent> myEvents;
    private LocalReentrancyGuard myExecuteExpiredEventsLocalGuard;
    private bool myIsWaitingOnReentrancyGuard;
    private SpinWaitLock myLock;
    private GroupingEvent myWatchdogEvent;
    [CanBeNullAttribute]
public ReentrancyGuard ReentrancyGuard;
    [NotNullAttribute]
private JetDispatcher Dispatcher;
    [CanBeNullAttribute]
private Traces myTraces;
    [CompilerGeneratedAttribute]
private ILogger <Logger>k__BackingField;
    public ILogger Logger { get; private set; }
    public GroupingEventHost(Lifetime lifetime, bool isGuarded);
    [CompilerGeneratedAttribute]
public ILogger get_Logger();
    [CompilerGeneratedAttribute]
private void set_Logger(ILogger value);
    [NotNullAttribute]
public GroupingEvent CreateEvent(Lifetime lifetime, string name, TimeSpan interval, Action FFirstHandler);
    internal void AddEvent(GroupingEvent evt);
    internal void OnDeadlineChanged(GroupingEvent evt);
    internal void RemoveEvent(GroupingEvent evt);
    private void ExecuteExpiredEvents();
    private void OnClockTimerTick();
    [NotNullAttribute]
public Traces EnableDiagnosticTraces(Lifetime lifetime);
    [CompilerGeneratedAttribute]
private void <OnClockTimerTick>b__4();
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Threading.GroupingEventHosts : object {
    private Dictionary`2<Rgc, GroupingEventHost> myHosts;
    [NotNullAttribute]
public GroupingEventHost Item { get; }
    public GroupingEventHosts(Lifetime lifetime);
    [NotNullAttribute]
public GroupingEvent CreateEvent(Lifetime lifetime, string name, TimeSpan interval, Rgc guarding, Action FFirstHandler);
    public GroupingEventHost get_Item(Rgc guarding);
}
public class JetBrains.Threading.GuardAttribute : Attribute {
    private Rgc _context;
    public Rgc Context { get; }
    public GuardAttribute(Rgc context);
    public Rgc get_Context();
}
public class JetBrains.Threading.JetBarrier : JetBarrier`2<object, object> {
    public JetBarrier(int partiesNumber, Action afterAllPartiesFinishedAction);
}
public class JetBrains.Threading.JetBarrier`1 : JetBarrier`2<TIn, object> {
    public JetBarrier`1(int partiesNumber, Action`1<TIn> afterAllPartiesFinishedAction);
}
public class JetBrains.Threading.JetBarrier`2 : object {
    private int myPartiesNumber;
    private Func`2<TIn, TOut> myAfterAllPartiesFinishedFunction;
    private TIn myCumulativeInput;
    private TOut myOutput;
    private object myLock;
    private int myCurrentPartiesSignaled;
    public TIn CumulativeInput { get; }
    public TOut Output { get; }
    public JetBarrier`2(int partiesNumber, Action afterAllPartiesFinishedAction);
    public JetBarrier`2(int partiesNumber, Action`1<TIn> afterAllPartiesFinishedAction);
    public JetBarrier`2(int partiesNumber, Func`2<TIn, TOut> afterAllPartiesFinishedFunction);
    public TIn get_CumulativeInput();
    public TOut get_Output();
    public void Signal(bool awaitForAllParties, int numberOfSignals, Func`2<TIn, TIn> inputUpdater, int waitTimeoutMilliseconds);
    public bool IsSignaled();
    public void Wait(int waitTimeoutMilliseconds);
    public void Reset(bool releaseWaitingThreads);
}
public abstract class JetBrains.Threading.JetDispatcher : object {
    private static IJetDispatcherStaticMethods StaticMethods;
    protected static UInt32 RunThreadWaitTimeout;
    [NotNullAttribute]
private static Dictionary`2<Thread, JetDispatcher> myDispatchers;
    private static SpinWaitLock myDispatchersWriterLock;
    private bool myDontRun;
    protected static int OptionQueueReasonableSizeLimit;
    protected static ILogger Logger;
    [NotNullAttribute]
public Thread Thread;
    [CompilerGeneratedAttribute]
private bool <IsAsyncBehaviorProhibited>k__BackingField;
    [NotNullAttribute]
public static JetDispatcher CurrentDispatcher { get; }
    public bool IsAsyncBehaviorProhibited { get; public set; }
    public bool IsShutDown { get; }
    private static JetDispatcher();
    public static JetDispatcher get_CurrentDispatcher();
    public abstract virtual IUserDataHolder GetThreadStaticData();
    [CompilerGeneratedAttribute]
public bool get_IsAsyncBehaviorProhibited();
    [CompilerGeneratedAttribute]
public void set_IsAsyncBehaviorProhibited(bool value);
    public bool get_IsShutDown();
    [ConditionalAttribute("NEVER")]
public static void AssertFreeThreaded();
    [NotNullAttribute]
public static JetDispatcher CreateDispatcherThread(Lifetime lifetime, string name);
    [CanBeNullAttribute]
public static JetDispatcher FromThread(Thread thread);
    public static int PumpMessagesOnce();
    public static bool Run(IProperty`1<bool> condition, TimeSpan timeout, bool bThrowOnTimeout);
    public static bool RunOrSleep(IProperty`1<bool> condition, TimeSpan timeout, OnWaitTimeout ontimeout);
    public static bool Run(Func`1<bool> condition, TimeSpan timeout, bool bThrowOnTimeout);
    public static bool RunOrSleep(Func`1<bool> condition, TimeSpan timeout, OnWaitTimeout ontimeout);
    public static bool Run(Task waitUntilDone, TimeSpan timeout, bool bThrowOnTimeout);
    public static bool RunOrSleep(Task waitUntilDone, TimeSpan timeout, OnWaitTimeout ontimeout);
    public static void Run(TimeSpan timeout);
    public static void RunOrSleep(TimeSpan timeout);
    public static void Run();
    private static bool Sleep(Func`1<bool> condition, TimeSpan timeout, OnWaitTimeout ontimeout);
    private void Shutdown();
    public void AssertAccess();
    public void AssertAsyncBehaviorSupported(string context);
    public abstract virtual void Invoke(string name, Action action, TaskPriority priority);
    public abstract virtual void BeginInvoke(string name, Action action, TaskPriority priority);
    public abstract virtual void BeginInvoke(Lifetime lifetime, string name, Action action, TaskPriority priority);
    public void BeginInvokeShutdown();
    public abstract virtual void BeginOrInvoke(string name, Action action, TaskPriority priority);
    public abstract virtual void BeginOrInvoke(Lifetime lifetime, string name, Action action, TaskPriority priority);
    public bool CheckAccess();
    public static bool IsSupportedOnThisThread();
    public bool Equals(JetDispatcher jetDispatcher);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
private void <BeginInvokeShutdown>b__10();
}
public class JetBrains.Threading.JetDispatcherActionException : ApplicationException {
    [NotNullAttribute]
private JetDispatcher myDispatcher;
    [NotNullAttribute]
private string myName;
    [NotNullAttribute]
public JetDispatcher Dispatcher { get; }
    [NotNullAttribute]
public string Name { get; }
    public JetDispatcherActionException(JetDispatcher dispatcher, string name, Exception ex);
    public JetDispatcher get_Dispatcher();
    public string get_Name();
}
public class JetBrains.Threading.JetFastSemiReenterableRWLock : object {
    private static int MaxReadLockStackSize;
    public static int MaxWaitTime;
    public static int WriteLockFactorShift;
    public static int ReentrantLockFactorShift;
    public static long WriteLockFactor;
    public static int ReenterLockFactor;
    public static long NoReadLockMask;
    private static int _nxtId;
    private int myId;
    [ThreadStaticAttribute]
private static int _curReadLockStackSize;
    [ThreadStaticAttribute]
private static Int32[] _readlockOwners;
    private JetLockState myState;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) myAwaitingWritersCount;
    private static int _processorCount;
    private static int _sleepCount;
    private static Int32[] ReadLockOwners { get; }
    public bool IsWriteLockHeld { get; }
    private static JetFastSemiReenterableRWLock();
    public JetFastSemiReenterableRWLockDisposable UsingReadLock();
    public JetFastSemiReenterableRWLockDisposable UsingWriteLock();
    private static Int32[] get_ReadLockOwners();
    [ConditionalAttribute("JET_MODE_ASSERT")]
private void PushReadLockOwner();
    [ConditionalAttribute("JET_MODE_ASSERT")]
private void AssertReadLockNotTaken(bool needAddReadLock);
    [ConditionalAttribute("JET_MODE_ASSERT")]
private void AssertReadLockTakenAsLastLockAndRelease();
    [ConditionalAttribute("JET_MODE_ASSERT")]
private void AssertThatThreadIsExclusiveOwner(int threadId);
    [ConditionalAttribute("JET_MODE_ASSERT")]
private void AssertLockIsHeld();
    public bool TryAcquireRead();
    public bool TryAcquireWrite();
    public void AcquireRead();
    public void AcquireWrite();
    public void Release();
    private void ReleaseInternal();
    private bool TryEnterReadInternal(long currentThreadId);
    private bool TryEnterWriteInternal(long currentThreadId);
    public bool get_IsWriteLockHeld();
    [ConditionalAttribute("JET_MODE_ASSERT")]
private void WaitTooMuchCheck(Int32& startTime);
    private string StateToString();
    private string StateToString(JetLockState state);
    private static void CalcApprovedProcessorCountAndMaxWaitTime();
    private static void Sleep();
}
public class JetBrains.Threading.MonitorReleaseCookie : ValueType {
    private object myLock;
    private MonitorReleaseCookie(object lock);
    public static MonitorReleaseCookie Create(object lock);
    public sealed virtual void Dispose();
}
public enum JetBrains.Threading.OnWaitTimeout : Enum {
    public int value__;
    public static OnWaitTimeout Fail;
    public static OnWaitTimeout Succeed;
}
public class JetBrains.Threading.ReentracyGuardDiagnosticSettings : object {
    public static ReentracyGuardDiagnosticSettings Instance;
    [CompilerGeneratedAttribute]
private bool <CaptureStackTraces>k__BackingField;
    public bool CaptureStackTraces { get; private set; }
    private static ReentracyGuardDiagnosticSettings();
    [CompilerGeneratedAttribute]
public bool get_CaptureStackTraces();
    [CompilerGeneratedAttribute]
private void set_CaptureStackTraces(bool value);
    public void SetCaptureStackTraces(Lifetime lifetime, bool value);
}
public class JetBrains.Threading.ReentrancyGuard : object {
    internal static bool OptionDontSuppressPumping;
    internal static bool OptionTrace;
    private static int myDefaultExternalDriverExecutionLimit;
    public static int OptionQueueReasonableSizeThresholdMask;
    [CanBeNullAttribute]
[ThreadStaticAttribute]
private static ReentrancyGuard myInstance;
    private JetDispatcher myDispatcher;
    [NotNullAttribute]
private ExecutionStack myExecutionStack;
    [NotNullAttribute]
private BlockingPriorityQueue`1<QueuedAction> myQueueActions;
    private bool myIsExecutePendingActionsFromIsExecutingFallingSchedulled;
    [CanBeNullAttribute]
private Traces myTraces;
    private ILogger myLogger;
    [CompilerGeneratedAttribute]
private static Func`1<object> CS$<>9__CachedAnonymousMethodDelegateb;
    [NotNullAttribute]
public static ReentrancyGuard Current { get; }
    public bool CanExecuteNow { get; }
    [CanBeNullAttribute]
public string CurrentActionName { get; }
    [NotNullAttribute]
public JetDispatcher Dispatcher { get; }
    public bool IsEmpty { get; }
    public bool IsExecuting { get; }
    private static ReentrancyGuard();
    public static ReentrancyGuard get_Current();
    public bool get_CanExecuteNow();
    public string get_CurrentActionName();
    public JetDispatcher get_Dispatcher();
    public bool get_IsEmpty();
    public bool get_IsExecuting();
    [HandleProcessCorruptedStateExceptionsAttribute]
public void AllowNestedExecution(string name, Action action);
    public void AssertGuarded();
    [HandleProcessCorruptedStateExceptionsAttribute]
public void Execute(string name, Action action);
    [CanBeNullAttribute]
[HandleProcessCorruptedStateExceptionsAttribute]
public TResult Execute(string name, TState state, Func`2<TState, TResult> func);
    public bool ExecuteOrQueue(string name, Action action, TaskPriority priority);
    public int PumpQueue(int limit);
    public void Queue(string name, Action action, TaskPriority priority);
    public bool TryExecute(string name, Action action);
    [NotNullAttribute]
public Traces EnableDiagnosticTraces(Lifetime lifetime);
    private void ReportOversizedQueue();
    private void AddExceptionData(Exception ex);
    private void AssertCanExecute(string name);
    private void BeginInvokeExecutePendingActions(bool isCalledFromIsExecutingFalling);
    private void ExecutePendingActions();
    [CompilerGeneratedAttribute]
private void <.ctor>b__0();
    [CompilerGeneratedAttribute]
private static object <ReportOversizedQueue>b__5();
    [CompilerGeneratedAttribute]
private object <AddExceptionData>b__11();
    [CompilerGeneratedAttribute]
private object <AddExceptionData>b__12();
    [CompilerGeneratedAttribute]
private object <AddExceptionData>b__13();
    [CompilerGeneratedAttribute]
private object <AddExceptionData>b__14();
}
[ExtensionAttribute]
public static class JetBrains.Threading.ReentrancyGuardEx : object {
    [ExtensionAttribute]
public static void Queue(ReentrancyGuard thіs, Lifetime lifetime, string name, Action F);
    [ExtensionAttribute]
public static bool ExecuteOrQueue(ReentrancyGuard thіs, Lifetime lifetime, string name, Action F, TaskPriority priority);
    [ExtensionAttribute]
public static bool ExecuteOrQueueEx(ReentrancyGuard thіs, Lifetime lifetime, string name, Action F);
    [ExtensionAttribute]
public static bool ExecuteOrQueueEx(ReentrancyGuard thіs, string name, Action F, TaskPriority priority);
}
public class JetBrains.Threading.ReentrancyGuardTimer : object {
    [NotNullAttribute]
private Property`1<DateTime> InactiveExecutionTime;
    [NotNullAttribute]
private IProperty`1<bool> IsNotWaitingTimer;
    [NotNullAttribute]
private IProperty`1<bool> IsWinFormsTimerEnabled;
    [NotNullAttribute]
private string myName;
    [NotNullAttribute]
private ReentrancyGuard myReentrancyGuard;
    private ITimer myTimer;
    [NotNullAttribute]
public ObsoleteLifetimeAndDefinitionAtTheSameTime Disposables;
    [NotNullAttribute]
public IProperty`1<TimeSpan> Interval;
    [NotNullAttribute]
public IProperty`1<bool> IsApplicationActive;
    [NotNullAttribute]
public IProperty`1<bool> IsEnabled;
    [NotNullAttribute]
public ISimpleSignal Tick;
    [CompilerGeneratedAttribute]
private static Func`4<bool, bool, DateTime, bool> CS$<>9__CachedAnonymousMethodDelegate7;
    [NotNullAttribute]
public string Name { get; }
    public ReentrancyGuardTimer(string name);
    public string get_Name();
    private void InitDataFlow();
    private void InitLogging();
    private void OnTimerTick();
    private void OnTimerTickReentrantSafe();
    public virtual string ToString();
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
private void <InitDataFlow>b__0();
    [CompilerGeneratedAttribute]
private static bool <InitDataFlow>b__1(bool enabled, bool active, DateTime execinactive);
    [CompilerGeneratedAttribute]
private void <InitDataFlow>b__2(TimeSpan value);
    [CompilerGeneratedAttribute]
private void <InitDataFlow>b__3(bool value);
    [CompilerGeneratedAttribute]
private void <InitDataFlow>b__4();
    [CompilerGeneratedAttribute]
private void <InitDataFlow>b__5();
    [CompilerGeneratedAttribute]
private void <InitDataFlow>b__6(object param0, EventArgs param1);
}
public enum JetBrains.Threading.Rgc : Enum {
    public int value__;
    public static Rgc NotSpecified;
    public static Rgc Guarded;
    public static Rgc Unguarded;
    public static Rgc Invariant;
    public static Rgc Special;
}
public class JetBrains.Threading.ThreadAccessException : ApplicationException {
    [CanBeNullAttribute]
private Thread myThreadDesired;
    [NotNullAttribute]
private Thread myThreadWrong;
    [CanBeNullAttribute]
public Thread ThreadDesired { get; }
    [NotNullAttribute]
public Thread ThreadWrong { get; }
    public ThreadAccessException(Thread threadDesired);
    public Thread get_ThreadDesired();
    public Thread get_ThreadWrong();
    [CompilerGeneratedAttribute]
private object <.ctor>b__0();
    [CompilerGeneratedAttribute]
private object <.ctor>b__2();
    [CompilerGeneratedAttribute]
private object <.ctor>b__3();
}
public class JetBrains.Threading.ThreadManager : object {
    private static ThreadManager ourInstance;
    [ThreadStaticAttribute]
private static ResourceCounter ourWaitingThreadsCounter;
    private ConcurrentSet`1<JetDispatcher> myStas;
    public static ThreadManager Instance { get; }
    public static ResourceCounter _WaitingThreadsCounter { get; public set; }
    [CanBeNullAttribute]
public JetDispatcher StaExecutor { get; }
    private static ThreadManager();
    public static ThreadManager get_Instance();
    public static ResourceCounterCookie WaitingThreadsCookie();
    public static ResourceCounter get__WaitingThreadsCounter();
    public static void set__WaitingThreadsCounter(ResourceCounter value);
    public JetDispatcher get_StaExecutor();
    public void AllowStaExecutor(Lifetime lifetime);
    [ObsoleteAttribute("Deprecated API, consider usage of myThreading.TaskHost.RunSafe() for CPU-bound tasks and ThreadManager.RunSafe() for IO-bound tasks")]
public void ExecuteTask(Action action, ApartmentState apartmentState);
    public static void RunSafe(Action action);
}
public class JetBrains.Threading.TimedActionsHost : object {
    [NotNullAttribute]
private Lifetime myLifetime;
    private UInt32 myGeneration;
    [NotNullAttribute]
private ReentrancyGuard myReentrancyGuard;
    [NotNullAttribute]
private CollectionEvents`1<TimedAction> myTimedActions;
    [NotNullAttribute]
private ITimer myTimer;
    [NotNullAttribute]
private Property`1<DateTime> NearestDeadline;
    [NotNullAttribute]
private SimpleSignal NearestDeadlineGottenDirty;
    [NotNullAttribute]
public IProperty`1<bool> IsApplicationActive;
    [NotNullAttribute]
private JetDispatcher myDispatcher;
    [CompilerGeneratedAttribute]
private static Func`2<TimedAction, Nullable`1<DateTime>> CS$<>9__CachedAnonymousMethodDelegateb;
    [NotNullAttribute]
public ReentrancyGuard ReentrancyGuard { get; }
    [NotNullAttribute]
public JetDispatcher Dispatcher { get; }
    [NotNullAttribute]
private IEnumerable`1<TimedAction> EligibleTimedActions { get; }
    public TimedActionsHost(Lifetime lifetime);
    public ReentrancyGuard get_ReentrancyGuard();
    public JetDispatcher get_Dispatcher();
    public void Queue(Lifetime lifetime, string name, Action action, TimeSpan interval, Recurrence recurrence, Rgc guarding);
    private IEnumerable`1<TimedAction> get_EligibleTimedActions();
    private void InitDataFlow();
    private void OnTimerTick();
    [CompilerGeneratedAttribute]
private bool <get_EligibleTimedActions>b__4(TimedAction ta);
    [CompilerGeneratedAttribute]
private void <InitDataFlow>b__5();
    [CompilerGeneratedAttribute]
private void <InitDataFlow>b__6();
    [CompilerGeneratedAttribute]
private void <InitDataFlow>b__8(PropertyChangedEventArgs`1<DateTime> args);
    [CompilerGeneratedAttribute]
private void <InitDataFlow>b__9(object param0, EventArgs param1);
    [CompilerGeneratedAttribute]
private void <InitDataFlow>b__a(Lifetime lifeTa, TimedAction ta);
    [CompilerGeneratedAttribute]
private static Nullable`1<DateTime> <InitDataFlow>b__7(TimedAction ta);
}
public class JetBrains.Threading.WeakTimer : object {
    private LifetimeDefinition myLifetimeDefinition;
    public IProperty`1<TimeSpan> Interval;
    public IProperty`1<bool> IsEnabled;
    public ISimpleSignal Tick;
    private ITimer myStrongTimer;
    public WeakTimer(Lifetime lifetime);
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
private void <.ctor>b__0();
    [CompilerGeneratedAttribute]
private void <.ctor>b__1(PropertyChangedEventArgs`1<TimeSpan> args);
    [CompilerGeneratedAttribute]
private void <.ctor>b__2(PropertyChangedEventArgs`1<bool> args);
}
public class JetBrains.UI.Application.LocalReentrancyGuard : object {
    private int myHasEntered;
    public bool TryExecute(Action action);
    public void Execute(Action action);
}
public class JetBrains.UI.Application.LogEventListener : object {
    private string myIdentity;
    private Action`1<LogEvent> myFOnEvent;
    private int myNoReentrancy_HasEntered;
    private EventHandler`1<EventArgs`1<Exception>> OnException;
    private EventHandler`1<EventArgs`1<Tuple`2<string, LoggingLevel>>> OnMessage;
    private EventHandler`1<EventArgs`1<LogEvent>> OnLogEvent;
    [CompilerGeneratedAttribute]
private ILayout <Layout>k__BackingField;
    [NotNullAttribute]
public string Identity { get; }
    public ILayout Layout { get; public set; }
    public LogEventListener(string identity, Action`1<LogEvent> FOnEvent);
    public string get_Identity();
    public static bool op_Equality(LogEventListener left, LogEventListener right);
    public static bool op_Inequality(LogEventListener left, LogEventListener right);
    public void add_OnException(EventHandler`1<EventArgs`1<Exception>> value);
    public void remove_OnException(EventHandler`1<EventArgs`1<Exception>> value);
    public void add_OnMessage(EventHandler`1<EventArgs`1<Tuple`2<string, LoggingLevel>>> value);
    public void remove_OnMessage(EventHandler`1<EventArgs`1<Tuple`2<string, LoggingLevel>>> value);
    public void add_OnLogEvent(EventHandler`1<EventArgs`1<LogEvent>> value);
    public void remove_OnLogEvent(EventHandler`1<EventArgs`1<LogEvent>> value);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(LogEventListener other);
    [CompilerGeneratedAttribute]
public sealed virtual ILayout get_Layout();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Layout(ILayout value);
    private sealed virtual override void JetBrains.Util.ILogEventListener.OnLogEvent(LogEvent logEvent);
}
public class JetBrains.Util.AntPatternState : object {
    private Wildcard[] myPatternParts;
    private Int32[] myPatternPositions;
    public Int32[] PatternPositions { get; }
    public AntPatternState(Wildcard[] patternParts, Int32[] patternPositions);
    public AntPatternState(Wildcard[] patternParts);
    public Int32[] get_PatternPositions();
    public AntPatternState Enter(string component, MatchResult& match);
}
public class JetBrains.Util.AntPatternUtil : object {
    private static string NormalizePatternString(string pattern);
    public static bool IsFileNameMatch(string pattern, string name);
    public static Wildcard[] ParsePattern(string pattern, bool caseSensitive, bool removeTwoDots);
    private static void RemoveOneDot(List`1<Wildcard> wildcards);
    private static void RemoveTwoDots(List`1<Wildcard> wildcards);
}
[ExtensionAttribute]
public static class JetBrains.Util.ArrayUtil : object {
    private static int hexcharsPerByte;
    public static UInt32 MurmurHashSeed;
    private static ArrayUtil();
    public static int GetHashCode(T[] array);
    public static bool Equals(Array array1, Array array2);
    public static bool Equals(Array array1, Array array2, IEqualityComparer`1<object> comparer);
    public static bool Equals(T[] array1, T[] array2);
    public static bool Equals(T[] array1, T[] array2, IEqualityComparer`1<T> comparer);
    public static bool Equals(T[] array1, int offset1, T[] array2, int offset2, int count, IEqualityComparer`1<T> comparer);
    public static int GetHashCode(IEnumerable`1<T> array);
    public static int GetHashCode(FrugalLocalList`1<T> array);
    [ExtensionAttribute]
public static int IndexOf(T[] array, T value, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static bool Contains(T[] array, T value, IEqualityComparer`1<T> comparer);
    [PureAttribute]
public static T[] Add(T element, T[] array);
    [PureAttribute]
public static T[] Add(T element, T[] array, int start, int length);
    [PureAttribute]
public static T[] Add(T[] array, T element);
    [PureAttribute]
public static T[] AddRange(T[] array, IEnumerable`1<T> items);
    [PureAttribute]
public static T[] AddRange(T[] array, T[] items);
    [PureAttribute]
public static T[] AddRange(T[] array, ICollection`1<T> items);
    [PureAttribute]
public static T[] InsertAt(T[] array, T element, int position);
    [PureAttribute]
public static T[] Add(T[] array1, T[] array2);
    [PureAttribute]
[NotNullAttribute]
public static T[] Remove(T[] array, T element);
    [PureAttribute]
[NotNullAttribute]
public static T[] RemoveAll(T[] array, T element);
    [PureAttribute]
[NotNullAttribute]
public static T[] RemoveWhere(T[] array, Predicate`1<T> match);
    [PureAttribute]
public static T[] RemoveAt(T[] array, int index);
    [ExtensionAttribute]
[PureAttribute]
public static TOuter[] Convert(TInner[] inner, Func`2<TInner, TOuter> converter);
    [PureAttribute]
[ExtensionAttribute]
public static T[] CopySegment(T[] array, int startIndex, int length);
    [PureAttribute]
[ExtensionAttribute]
public static T[] CopySegment(T[] array, int startIndex);
    [ExtensionAttribute]
public static void Sort(T[] array, Comparison`1<T> comparison);
    [NotNullAttribute]
public static string ToHexString(Byte[] buffer);
    [NotNullAttribute]
public static Byte[] FromHexString(string hex);
    public static int MurmurHash3(Byte* pData, int nLen, UInt32 seed);
    public static int BinarySearchGoodBounds(UnsafeIntArray array, int lo, int hi, int val);
    public static int BinarySearch(UnsafeIntArray array, int lo, int hi, int val);
    public static int BinarySearch(UnsafeIntArray array, int val);
    private static void Swap(UnsafeIntArray a, int i, int j);
    private static void Sort0(UnsafeIntArray a, int lo, int hi);
    [ExtensionAttribute]
public static void Sort(UnsafeIntArray array, int lo, int hi);
    [ExtensionAttribute]
public static void Sort(UnsafeIntArray array);
    [ExtensionAttribute]
public static int DistinctSorted(UnsafeIntArray arr);
    [ExtensionAttribute]
[ObsoleteAttribute("This is a very suboptimal impl for an int* array. Branching inside loop, re-reading same item, using get_Item instead of memory access by pointer, etc.")]
public static bool IsSorted(UnsafeIntArray arr, bool strict);
    [ExtensionAttribute]
public static Int32[] Subarray(Int32[] arr, int start, int length);
    public static bool StartsWith(Byte[] master, Byte[] prefix);
}
public abstract class JetBrains.Util.AsyncLogEventListener : object {
    private LifetimeDefinition myLifetimeDef;
    protected Lifetime Lifetime;
    private ByteBufferAsyncProcessor myAsyncProcessor;
    [CompilerGeneratedAttribute]
private ILayout <Layout>k__BackingField;
    public ILayout Layout { get; public set; }
    protected AsyncLogEventListener(string id);
    [CompilerGeneratedAttribute]
public sealed virtual ILayout get_Layout();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Layout(ILayout value);
    protected virtual void WriteLogEvent(UnsafeWriter writer, LogEvent logEvent);
    protected virtual void ProcessBytes(Byte[] bytes, int offset, int size);
    protected abstract virtual void ProcessChars(Char* chars, int size);
    public sealed virtual void OnLogEvent(LogEvent logEvent);
    public sealed virtual void Dispose();
}
[PublicAPIAttribute]
[ValueSerializerAttribute("JetBrains.Util.BackSlashSeparatedRelativePathSerializer")]
[TypeConverterAttribute("JetBrains.Util.BackSlashSeparatedRelativePathConverter")]
public class JetBrains.Util.BackSlashSeparatedRelativePath : object {
    private static DirectMappedCache`2<string, BackSlashSeparatedRelativePath> ourIntern;
    private Nullable`1<int> myHashCode;
    private String modreq(System.Runtime.CompilerServices.IsVolatile) myName;
    private String modreq(System.Runtime.CompilerServices.IsVolatile) myNameWithoutExtension;
    [NotNullAttribute]
public static BackSlashSeparatedRelativePath Empty;
    [NotNullAttribute]
public string FullPath;
    private static Func`3<string, bool, BackSlashSeparatedRelativePath> myCachedDelegate1;
    [CompilerGeneratedAttribute]
private static Action CS$<>9__CachedAnonymousMethodDelegate2;
    [CompilerGeneratedAttribute]
private static Func`3<string, bool, BackSlashSeparatedRelativePath> CS$<>9__CachedAnonymousMethodDelegate8;
    public bool IsValidOnCurrentOS { get; }
    [NotNullAttribute]
public BackSlashSeparatedRelativePath Parent { get; }
    public string ExtensionNoDot { get; }
    public string ExtensionWithDot { get; }
    public string FirstComponent { get; }
    public bool IsAbsolute { get; }
    public bool IsEmpty { get; }
    public string Name { get; }
    public string NameWithoutExtension { get; }
    private IPath JetBrains.Util.IPath.Empty { get; }
    private string JetBrains.Util.IPath.FullPath { get; }
    private IPath JetBrains.Util.IPath.Parent { get; }
    private BackSlashSeparatedRelativePath(string path, bool isPathAlreadyCanonical);
    private static BackSlashSeparatedRelativePath();
    public sealed virtual bool get_IsValidOnCurrentOS();
    public BackSlashSeparatedRelativePath get_Parent();
    public static void AllowIntern(Lifetime lifetime, int maxEntries);
    public static void ClearIntern();
    [NotNullAttribute]
[PureAttribute]
public static BackSlashSeparatedRelativePath Parse(string path);
    [PureAttribute]
[NotNullAttribute]
public static BackSlashSeparatedRelativePath TryParse(string path);
    [NotNullAttribute]
public static BackSlashSeparatedRelativePath op_Division(BackSlashSeparatedRelativePath path, BackSlashSeparatedRelativePath other);
    [NotNullAttribute]
public static BackSlashSeparatedRelativePath op_Division(BackSlashSeparatedRelativePath path, string component);
    public static bool op_Equality(BackSlashSeparatedRelativePath left, BackSlashSeparatedRelativePath right);
    public static string op_Explicit(BackSlashSeparatedRelativePath path);
    public static BackSlashSeparatedRelativePath op_Implicit(string path);
    public static bool op_Inequality(BackSlashSeparatedRelativePath left, BackSlashSeparatedRelativePath right);
    [NotNullAttribute]
public static BackSlashSeparatedRelativePath CreateByCanonicalPath(string path);
    [NotNullAttribute]
[PureAttribute]
public BackSlashSeparatedRelativePath Combine(string component);
    [NotNullAttribute]
[PureAttribute]
public BackSlashSeparatedRelativePath Combine(BackSlashSeparatedRelativePath other);
    [PureAttribute]
[NotNullAttribute]
public BackSlashSeparatedRelativePath Combine(RelativePath other);
    [NotNullAttribute]
[PureAttribute]
public BackSlashSeparatedRelativePath MakeRelativeTo(BackSlashSeparatedRelativePath basePath);
    [PureAttribute]
[NotNullAttribute]
public BackSlashSeparatedRelativePath TryMakeRelativeTo(BackSlashSeparatedRelativePath basePath);
    [NotNullAttribute]
private static BackSlashSeparatedRelativePath Create(string path, bool isPathAlreadyCanonical);
    private static DirectMappedCache`2<string, BackSlashSeparatedRelativePath> CreateIntern(int maxEntries);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public sealed virtual int CompareTo(BackSlashSeparatedRelativePath other);
    public sealed virtual bool Equals(BackSlashSeparatedRelativePath other);
    [NotNullAttribute]
public sealed virtual String[] GetPathComponents();
    public sealed virtual Uri ToDirectoryUri();
    public sealed virtual Uri ToUri();
    private sealed virtual override IPath JetBrains.Util.IPath.Combine(RelativePath other);
    private sealed virtual override IPath JetBrains.Util.IPath.Parse(string text);
    private sealed virtual override IPath JetBrains.Util.IPath.TryCombine(string component);
    public sealed virtual string get_ExtensionNoDot();
    public sealed virtual string get_ExtensionWithDot();
    public sealed virtual string get_FirstComponent();
    public sealed virtual bool get_IsAbsolute();
    public sealed virtual bool get_IsEmpty();
    public sealed virtual string get_Name();
    public sealed virtual string get_NameWithoutExtension();
    [PureAttribute]
[NotNullAttribute]
public BackSlashSeparatedRelativePath Clone();
    private sealed virtual override IPath JetBrains.Util.IPath.get_Empty();
    private sealed virtual override string JetBrains.Util.IPath.get_FullPath();
    private sealed virtual override IPath JetBrains.Util.IPath.get_Parent();
    private static BackSlashSeparatedRelativePath Create(PreparedString preparedString, BackSlashSeparatedRelativePath this, BackSlashSeparatedRelativePath other);
    private static BackSlashSeparatedRelativePath Create(PreparedString preparedString, BackSlashSeparatedRelativePath this);
    [CompilerGeneratedAttribute]
private static void <AllowIntern>b__1();
    [CompilerGeneratedAttribute]
private static BackSlashSeparatedRelativePath <.cctor>b__7(string key, bool canonical);
}
public class JetBrains.Util.BackSlashSeparatedRelativePathConverter : TypeConverterBase`1<BackSlashSeparatedRelativePath> {
    [CompilerGeneratedAttribute]
private static Func`4<ITypeDescriptorContext, CultureInfo, BackSlashSeparatedRelativePath, string> CS$<>9__CachedAnonymousMethodDelegate2;
    [CompilerGeneratedAttribute]
private static Func`4<ITypeDescriptorContext, CultureInfo, string, BackSlashSeparatedRelativePath> CS$<>9__CachedAnonymousMethodDelegate3;
    [CompilerGeneratedAttribute]
private static string <.ctor>b__0(ITypeDescriptorContext context, CultureInfo info, BackSlashSeparatedRelativePath value);
    [CompilerGeneratedAttribute]
private static BackSlashSeparatedRelativePath <.ctor>b__1(ITypeDescriptorContext descriptorContext, CultureInfo cultureInfo, string value);
}
public class JetBrains.Util.BackSlashSeparatedRelativePathSerializer : ValueSerializerBase`1<BackSlashSeparatedRelativePath> {
    [CompilerGeneratedAttribute]
private static Func`3<IValueSerializerContext, BackSlashSeparatedRelativePath, string> CS$<>9__CachedAnonymousMethodDelegate2;
    [CompilerGeneratedAttribute]
private static Func`3<IValueSerializerContext, string, BackSlashSeparatedRelativePath> CS$<>9__CachedAnonymousMethodDelegate3;
    [CompilerGeneratedAttribute]
private static string <.ctor>b__0(IValueSerializerContext context, BackSlashSeparatedRelativePath value);
    [CompilerGeneratedAttribute]
private static BackSlashSeparatedRelativePath <.ctor>b__1(IValueSerializerContext descriptorContext, string value);
}
public enum JetBrains.Util.BeforeOrAfter : Enum {
    public int value__;
    public static BeforeOrAfter After;
    public static BeforeOrAfter Before;
}
public class JetBrains.Util.BinarySearchResult`1 : ValueType {
    public IList`1<TItem> Items;
    public int RawResult;
    public TItem SearchTarget;
    public int HitIndex { get; }
    public TItem HitItem { get; }
    public int InsertAtIndex { get; }
    public int InsertAtIndex2 { get; }
    public bool IsHit { get; }
    public int NearestIndexNotAboveTarget { get; }
    public int NearestIndexNotAboveTargetOrFirst { get; }
    public int NearestIndexNotAboveTargetOrMinus1 { get; }
    public int NearestIndexNotBelowTarget { get; }
    public int NearestIndexNotBelowTargetOrCount { get; }
    public int NearestIndexNotBelowTargetOrLast { get; }
    public TItem NearestItemNotAboveTarget { get; }
    public TItem NearestItemNotAboveTargetOrFirst { get; }
    public TItem NearestItemNotBelowTarget { get; }
    public TItem NearestItemNotBelowTargetOrLast { get; }
    public BinarySearchResult`1(List`1<TItem> items, TItem searchTarget);
    public BinarySearchResult`1(IList`1<TItem> items, TItem searchTarget, int rawresult);
    public int get_HitIndex();
    public TItem get_HitItem();
    public int get_InsertAtIndex();
    public int get_InsertAtIndex2();
    public bool get_IsHit();
    public int get_NearestIndexNotAboveTarget();
    public int get_NearestIndexNotAboveTargetOrFirst();
    public int get_NearestIndexNotAboveTargetOrMinus1();
    public int get_NearestIndexNotBelowTarget();
    public int get_NearestIndexNotBelowTargetOrCount();
    public int get_NearestIndexNotBelowTargetOrLast();
    public TItem get_NearestItemNotAboveTarget();
    public TItem get_NearestItemNotAboveTargetOrFirst();
    public TItem get_NearestItemNotBelowTarget();
    public TItem get_NearestItemNotBelowTargetOrLast();
    public int InsertAt(TItem item);
    private void AddExceptionData(Exception ex);
}
[ExtensionAttribute]
public static class JetBrains.Util.BinarySearchUtil : object {
    [ExtensionAttribute]
public static BinarySearchResult`1<TItem> BinarySearch(IList`1<TItem> list, TKey keyLookFor, Func`2<TItem, TKey> FGetKeyOfItem, IComparer`1<TKey> keycomparer, int index, int length, OfEqualItems which);
    [ExtensionAttribute]
public static BinarySearchResult`1<TItem> BinarySearch(IList`1<TItem> list, TItem itemLookFor, IComparer`1<TItem> keycomparer, int index, int length, OfEqualItems which);
    public static TValue GetOrCreateValue(IList`1<TValue> list, TKey key, Func`2<TValue, TKey> FGetKeyOfItem, Func`1<TValue> FCreateIfMissing);
    [CanBeNullAttribute]
public static TValue TryGetValue(IList`1<TValue> list, TKey key, Func`2<TValue, TKey> FGetKeyOfItem);
    public static bool RemoveValue(IList`1<TValue> list, TKey key, Func`2<TValue, TKey> FGetKeyOfItem);
    [ExtensionAttribute]
public static BinarySearchResult`1<TItem> BinarySearchEx(IList`1<TItem> thіs, TItem item);
    [ExtensionAttribute]
public static BinarySearchResult`1<T> BinarySearchEx(IList`1<T> list, Locator`1<T> locator);
    [ExtensionAttribute]
public static int BinarySearch(IList`1<T> list, int index, int length, Locator`1<T> locator);
    [ExtensionAttribute]
public static int BinarySearch(IList`1<T> list, Locator`1<T> locator);
}
[ExtensionAttribute]
public static class JetBrains.Util.BinaryStreamEx : object {
    [ExtensionAttribute]
[CanBeNullAttribute]
public static String[] ReadLengthAndStringArray(BinaryReader reader);
}
[ExtensionAttribute]
public static class JetBrains.Util.Caches.CachedValues : object {
    [NotNullAttribute]
public static ICachedValue`1<T> CreateWeakCachedValue(Func`1<T> producer, IWeakRefRetainerCache`1<TCacheItem> cache, T initialValue, int cacheTouchFrequency);
    [NotNullAttribute]
public static IParametrizedCachedValue`2<T, TParam> CreateWeakParametrizedCachedValue(Func`2<TParam, T> producer, IWeakRefRetainerCache`1<TCacheItem> cache, T initialValue, int cacheTouchFrequency);
    [NotNullAttribute]
public static ICachedValue`1<T> CreateStrongCachedValue(T initialValue);
    [NotNullAttribute]
public static IParametrizedCachedValue`2<T, TParam> CreateStrongParametrizedCachedValue(T initialValue);
    [ThreadSafeAttribute]
[ExtensionAttribute]
public static bool HasValue(ICachedValueBase`1<T> cachedValue);
    [ThreadSafeAttribute]
[ExtensionAttribute]
public static void SetIfNull(ICachedValueBase`1<T> cachedValue, Func`1<TInheritor> functor);
    [ExtensionAttribute]
[ThreadSafeAttribute]
public static void SetIfNull(ICachedValueBase`1<T> cachedValue, Func`2<TParam, TInheritor> functor, TParam param);
}
internal static class JetBrains.Util.Caches.CacheStatistics : object {
    internal static string Touch;
    internal static string Hit;
    internal static string Miss;
    internal static string Erosion;
}
[ExtensionAttribute]
public static class JetBrains.Util.Caches.DictionaryBasedCacheEx : object {
    [ExtensionAttribute]
public static TValue GetValueSafe(IDictionaryBasedCache`2<TKey, TValue> cache, TKey key, TValue defaultValue);
}
[ThreadSafeAttribute]
public class JetBrains.Util.Caches.DirectMappedCache`2 : object {
    private static int LocksCount;
    private KeyValuePair`2[] myEntries;
    private IEqualityComparer`1<TKey> myEqualityComparer;
    private Object[] myLocks;
    private BitArray myEntryStates;
    private ILogger myLogger;
    private ICacheBackendProvider`2<TKey, TValue> myProvider;
    private Func`2<TKey, TValue> myGetValueFunction;
    private int myCount;
    public int Count { get; }
    public DirectMappedCache`2(int approximateSize, IEqualityComparer`1<TKey> comparer, ICacheBackendProvider`2<TKey, TValue> provider, ILogger logger);
    private void Reset();
    private object GetLock(int index);
    private int GetBucket(TKey key);
    [ConditionalAttribute("JET_MODE_STATISTICS")]
private void StatisticsErosion(int idx);
    private TValue GetOrCreateInternal(TKeyInheritor key, TParam param, object provider);
    public sealed virtual bool TryGetFromCache(TKey key, TValue& value);
    public sealed virtual TKey TryGetInternedKey(TKey key);
    public sealed virtual TValue GetOrCreate(TKey key);
    public sealed virtual TValue GetOrCreate(TKeyInheritor key, Func`2<TKeyInheritor, TValue> provider);
    public sealed virtual TValue GetOrCreate(TKeyInheritor key, TParam param, Func`3<TKeyInheritor, TParam, TValue> provider);
    public sealed virtual void AddToCache(TKey key, TValue value);
    public sealed virtual bool RemoveFromCache(TKey key);
    public sealed virtual bool ContainsKeyInCache(TKey key);
    public TValue GetCachedValue(TKey key);
    public sealed virtual void Clear();
    private TakeAllLocksCookie<TKey, TValue> TakeAllLocks();
    public sealed virtual void Add(TKey key, TValue val);
    public sealed virtual void Remove(TKey key);
    public bool TryGetOrCreate(TKey key, TValue& val);
    public sealed virtual void Flush(TKey key);
    public sealed virtual void Flush();
    public sealed virtual int get_Count();
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [CompilerGeneratedAttribute]
private TValue <.ctor>b__0(TKey key);
}
public class JetBrains.Util.Caches.EmptyCache`2 : object {
    [NotNullAttribute]
public static EmptyCache`2<TKey, TValue> Instance;
    [CompilerGeneratedAttribute]
private int <Count>k__BackingField;
    public int Count { get; private set; }
    private static EmptyCache`2();
    public sealed virtual void AddToCache(TKey key, TValue value);
    public sealed virtual bool RemoveFromCache(TKey key);
    public sealed virtual bool ContainsKeyInCache(TKey key);
    public sealed virtual void Clear();
    public sealed virtual bool TryGetFromCache(TKey key, TValue& value);
    public sealed virtual TKey TryGetInternedKey(TKey key);
    [CompilerGeneratedAttribute]
public sealed virtual int get_Count();
    [CompilerGeneratedAttribute]
private void set_Count(int value);
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
}
public interface JetBrains.Util.Caches.ICacheBackendProvider`2 {
    public abstract virtual bool ContainsKey(TKey key);
    public abstract virtual bool TryGetValue(TKey key, TValue& val);
    public abstract virtual void Put(TKey key, TValue val);
    public abstract virtual void Remove(TKey key);
}
public interface JetBrains.Util.Caches.ICachedBackend`2 {
    public abstract virtual void Add(TKey key, TValue val);
    public abstract virtual void Remove(TKey key);
    public abstract virtual void Flush(TKey key);
    public abstract virtual void Flush();
}
public interface JetBrains.Util.Caches.ICachedValue`1 {
    [NotNullAttribute]
public abstract virtual T GetOrCreate();
}
public interface JetBrains.Util.Caches.ICachedValueBase`1 {
    public abstract virtual void Set(T value);
    public abstract virtual void Clear();
    [CanBeNullAttribute]
public abstract virtual T TryGet();
}
public interface JetBrains.Util.Caches.IDictionaryBasedCache`2 {
    public int Count { get; }
    public abstract virtual void AddToCache(TKey key, TValue value);
    public abstract virtual bool RemoveFromCache(TKey key);
    public abstract virtual bool ContainsKeyInCache(TKey key);
    public abstract virtual void Clear();
    public abstract virtual bool TryGetFromCache(TKey key, TValue& value);
    public abstract virtual TKey TryGetInternedKey(TKey key);
    public abstract virtual int get_Count();
    public abstract virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
}
public interface JetBrains.Util.Caches.IExternalProviderCache`2 {
    public abstract virtual TValue GetOrCreate(TKeyInheritor key, Func`2<TKeyInheritor, TValue> provider);
    public abstract virtual TValue GetOrCreate(TKeyInheritor key, TParam param, Func`3<TKeyInheritor, TParam, TValue> provider);
}
public interface JetBrains.Util.Caches.IParametrizedCachedValue`2 {
    [NotNullAttribute]
public abstract virtual T GetOrCreate(TFunctorParameter parameter);
    public abstract virtual bool GetOrCreate(TFunctorParameter parameter, T& result, Action`1<T> afterCreate);
    [CanBeNullAttribute]
public abstract virtual T TryGetSync();
}
public interface JetBrains.Util.Caches.IProviderCache`2 {
    public abstract virtual TValue GetOrCreate(TKey key);
}
public interface JetBrains.Util.Caches.IWeakCachedValue {
    public int CacheTouchFrequency { get; public set; }
    public abstract virtual int get_CacheTouchFrequency();
    public abstract virtual void set_CacheTouchFrequency(int value);
}
public interface JetBrains.Util.Caches.IWeakRefRetainerCache`1 {
    public int Count { get; }
    public abstract virtual bool Touch(T item);
    public abstract virtual bool Remove(T item);
    public abstract virtual void Clear();
    public abstract virtual bool Contains(T item);
    public abstract virtual int get_Count();
    public abstract virtual int Evict();
}
[ThreadSafeAttribute]
public class JetBrains.Util.Caches.LRUWeakRefRetainerCache`1 : object {
    public static long EvictionTimerIntervalMillis;
    private static int EntryPointerNull;
    private static double LoadFactor;
    private static int SpecialEntriesOffset;
    private static int HeadEntryIdx;
    private static int TailEntryIdx;
    private int myCount;
    private Entry[] myEntries;
    private int myCapacity;
    private IEqualityComparer`1<T> myEqualityComparer;
    private object myLock;
    private int myNextBucketShift;
    private int myInitialCapacity;
    private long myInvalidateTimeMillis;
    private int myInvalidationSurvivalThreshold;
    [UsedImplicitlyAttribute]
private Timer myTimer;
    public int Count { get; }
    public IList`1<T> Items { get; }
    public LRUWeakRefRetainerCache`1(Lifetime lifetime, int capacity, IEqualityComparer`1<T> comparer, long invalidateTimeInMillis, int invalidationSurvivalThreshold);
    private void Reset();
    private int InitBucket(T key);
    private int NextBucket(int prevBucket);
    private bool IsEmptyBucket(int bucket);
    private void LinkEntries(int indexFirst, int indexSecond);
    private bool TouchInternal(T item);
    private void Promote(int bucket);
    private void SetEmpty(int bucket);
    private bool RemoveInternal(T item);
    public void VerifyCorrect();
    private int RemoveFromBucket(int bucket);
    private bool ContainsInternal(T item);
    private void EvictOne();
    private int EvictLeastRecentlyTouchedInternal();
    public sealed virtual bool Touch(T item);
    public sealed virtual bool Remove(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual int Evict();
    public sealed virtual int get_Count();
    public IList`1<T> get_Items();
    [CompilerGeneratedAttribute]
private void <.ctor>b__0();
    [CompilerGeneratedAttribute]
private void <.ctor>b__2();
    [CompilerGeneratedAttribute]
private void <.ctor>b__1(object _);
}
[ThreadSafeAttribute]
internal class JetBrains.Util.Caches.StrongCachedValue`2 : object {
    private T modreq(System.Runtime.CompilerServices.IsVolatile) myValue;
    public StrongCachedValue`2(T value);
    public sealed virtual T GetOrCreate();
    public sealed virtual T GetOrCreate(TParam parameter);
    public sealed virtual bool GetOrCreate(TParam parameter, T& result, Action`1<T> afterCreate);
    public sealed virtual void Set(T value);
    public sealed virtual void Clear();
    public sealed virtual T TryGet();
    public sealed virtual T TryGetSync();
}
public class JetBrains.Util.Caches.UnlimitedCache`2 : object {
    private IEqualityComparer`1<TKey> myEqualityComparer;
    [CompilerGeneratedAttribute]
private ConcurrentDictionary`2<TKey, TValue> <Map>k__BackingField;
    protected ConcurrentDictionary`2<TKey, TValue> Map { get; private set; }
    public int Count { get; }
    public UnlimitedCache`2(IEqualityComparer`1<TKey> equalityComparer);
    [CompilerGeneratedAttribute]
protected ConcurrentDictionary`2<TKey, TValue> get_Map();
    [CompilerGeneratedAttribute]
private void set_Map(ConcurrentDictionary`2<TKey, TValue> value);
    public sealed virtual void AddToCache(TKey key, TValue value);
    public sealed virtual bool RemoveFromCache(TKey key);
    public sealed virtual bool ContainsKeyInCache(TKey key);
    public sealed virtual void Clear();
    public sealed virtual bool TryGetFromCache(TKey key, TValue& value);
    public sealed virtual TKey TryGetInternedKey(TKey key);
    public sealed virtual int get_Count();
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
}
public class JetBrains.Util.Caches.UnlimitedInactiveItemsEvictingCache`2 : object {
    public static int DefaultEvictionAttemptIntervalMs;
    public static int DefaultItemLifetimeToEvictMs;
    private Dictionary`2<TKey, Bucket<TKey, TValue>> myDictionary;
    private long myItemLifetimeToEvictsMs;
    private JetFastSemiReenterableRWLock myLock;
    private Timer myTimer;
    private int myEvictionAttemptIntervalMs;
    private int myEvictionAttemptIntervalAfterFailureMs;
    private Action`1<TKey> AfterItemEvicted;
    [CompilerGeneratedAttribute]
private static Func`2<IEnumerator`1<KeyValuePair`2<TKey, Bucket<TKey, TValue>>>, KeyValuePair`2<TKey, TValue>> CS$<>9__CachedAnonymousMethodDelegate9;
    public int Count { get; }
    public UnlimitedInactiveItemsEvictingCache`2(Lifetime lifetime, int evictionAttemptIntervalMs, int itemLifetimeToEvictMs, IEqualityComparer`1<TKey> comparer);
    public void add_AfterItemEvicted(Action`1<TKey> value);
    public void remove_AfterItemEvicted(Action`1<TKey> value);
    private void TimerOnElapsed(object sender, ElapsedEventArgs elapsedEventArgs);
    public sealed virtual void AddToCache(TKey key, TValue value);
    public sealed virtual bool RemoveFromCache(TKey key);
    public sealed virtual bool ContainsKeyInCache(TKey key);
    public sealed virtual void Clear();
    public sealed virtual bool TryGetFromCache(TKey key, TValue& value);
    public sealed virtual TKey TryGetInternedKey(TKey key);
    public sealed virtual int get_Count();
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    protected virtual void OnAfterItemEvicted(TKey key);
    [CompilerGeneratedAttribute]
private void <.ctor>b__0();
    [CompilerGeneratedAttribute]
private void <.ctor>b__1();
    [CompilerGeneratedAttribute]
private static KeyValuePair`2<TKey, TValue> <GetEnumerator>b__8(IEnumerator`1<KeyValuePair`2<TKey, Bucket<TKey, TValue>>> en);
}
public class JetBrains.Util.Caches.UnlimitedProviderCache`2 : UnlimitedCache`2<TKey, TValue> {
    [NotNullAttribute]
private Func`2<TKey, TValue> myProvider;
    public UnlimitedProviderCache`2(Func`2<TKey, TValue> provider);
    public sealed virtual TValue GetOrCreate(TKey key);
    [CompilerGeneratedAttribute]
private TValue <GetOrCreate>b__3(TKey k);
}
[ThreadSafeAttribute]
internal class JetBrains.Util.Caches.WeakCachedValue`2 : WeakCachedValueBase`2<T, TCacheItem> {
    private Func`1<T> myProducer;
    public WeakCachedValue`2(Func`1<T> producer, IWeakRefRetainerCache`1<T> cache, T initialValue, int cacheTouchFrequency);
    public sealed virtual T GetOrCreate();
}
internal abstract class JetBrains.Util.Caches.WeakCachedValueBase`2 : object {
    protected JetWeakReference`1<T> Ref;
    protected IWeakRefRetainerCache`1<T> Cache;
    protected int UsageCount;
    [CompilerGeneratedAttribute]
private int <CacheTouchFrequency>k__BackingField;
    public int CacheTouchFrequency { get; public set; }
    protected WeakCachedValueBase`2(IWeakRefRetainerCache`1<T> cache, T initialValue, int cacheTouchFrequency);
    [CompilerGeneratedAttribute]
public sealed virtual int get_CacheTouchFrequency();
    [CompilerGeneratedAttribute]
public sealed virtual void set_CacheTouchFrequency(int value);
    public sealed virtual void Set(T value);
    public sealed virtual void Clear();
    public sealed virtual T TryGet();
}
[ThreadSafeAttribute]
internal class JetBrains.Util.Caches.WeakParametrizedCachedValue`3 : WeakCachedValueBase`2<T, TCacheItem> {
    private Func`2<TParameter, T> myProducer;
    public WeakParametrizedCachedValue`3(Func`2<TParameter, T> producer, IWeakRefRetainerCache`1<T> cache, T initialValue, int cacheTouchFrequency);
    public sealed virtual T GetOrCreate(TParameter parameter);
    public sealed virtual bool GetOrCreate(TParameter parameter, T& result, Action`1<T> afterCreate);
    public sealed virtual T TryGetSync();
}
public class JetBrains.Util.Caches.WeakRefRetainerMultiCache`1 : object {
    private IList`1<IWeakRefRetainerCache`1<T>> myCaches;
    private Func`2<T, IWeakRefRetainerCache`1<T>> myDispatcher;
    [CompilerGeneratedAttribute]
private static Action`1<IWeakRefRetainerCache`1<T>> CS$<>9__CachedAnonymousMethodDelegate4;
    [CompilerGeneratedAttribute]
private static Func`3<int, IWeakRefRetainerCache`1<T>, int> CS$<>9__CachedAnonymousMethodDelegate9;
    [CompilerGeneratedAttribute]
private static Func`3<int, IWeakRefRetainerCache`1<T>, int> CS$<>9__CachedAnonymousMethodDelegateb;
    public IList`1<IWeakRefRetainerCache`1<T>> Caches { get; }
    public int Count { get; }
    public WeakRefRetainerMultiCache`1(IList`1<IWeakRefRetainerCache`1<T>> caches, Func`2<T, IWeakRefRetainerCache`1<T>> dispatcher);
    public sealed virtual bool Touch(T item);
    public IList`1<IWeakRefRetainerCache`1<T>> get_Caches();
    public sealed virtual bool Remove(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual int get_Count();
    public sealed virtual int Evict();
    [CompilerGeneratedAttribute]
private static void <Clear>b__3(IWeakRefRetainerCache`1<T> _);
    [CompilerGeneratedAttribute]
private static int <get_Count>b__8(int acc, IWeakRefRetainerCache`1<T> cache);
    [CompilerGeneratedAttribute]
private static int <Evict>b__a(int acc, IWeakRefRetainerCache`1<T> cache);
}
[ExtensionAttribute]
public static class JetBrains.Util.CharEx : object {
    [ExtensionAttribute]
public static char ToLowerFast(char c);
    [ExtensionAttribute]
public static char ToUpperFast(char c);
    [ExtensionAttribute]
public static bool IsIdentifierStart(char c);
    [ExtensionAttribute]
public static bool IsIdentifierPart(char c);
    [ExtensionAttribute]
public static bool IsUpperFast(char c);
    [ExtensionAttribute]
public static bool IsLetterFast(char c);
    [ExtensionAttribute]
public static bool IsLetterOrDigitFast(char c);
    [ExtensionAttribute]
public static bool IsHexDigitFast(char c);
}
public static class JetBrains.Util.CharUtil : object {
    public static Byte[] UriSafeAsciiChars;
    private static CharUtil();
    public static bool IsHexDigit(char c);
    public static byte ParseHexDigit(char c);
    public static bool IsOctDigit(char c);
    public static bool IsUriSafeChar(char ch);
    private static Byte[] GetUriSafeAsciiChars();
}
internal class JetBrains.Util.Collections.CollectionUtilSafeOfTypeEnumerable`1 : object {
    private IEnumerable myUnsafeEnumerable;
    public CollectionUtilSafeOfTypeEnumerable`1(IEnumerable unsafeEnumerable);
    [NotNullAttribute]
private IEnumerator`1<TItem> GetTypedEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IEnumerator`1<TItem> GetEnumerator();
}
public static class JetBrains.Util.Collections.Comparer : object {
    [PureAttribute]
[NotNullAttribute]
public static IComparer`1<T> Create(Comparison`1<T> compare);
    [NotNullAttribute]
[PureAttribute]
public static IComparer`1<TSource> Create(Func`2<TSource, TKey> keySelector, IComparer`1<TKey> keyComparer);
}
public class JetBrains.Util.Collections.EnumeratorEnumerable : object {
    [NotNullAttribute]
private Func`1<IEnumerator> myΛGetEnumerator;
    public EnumeratorEnumerable(Func`1<IEnumerator> λGetEnumerator);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Util.Collections.HashMap`2 : object {
    private IEqualityComparer`1<TKey> myComparer;
    private Entry[] myEntries;
    private Int32[] myHashToEntryIndex;
    private int myEntriesUsed;
    private int myFirstFreeIndex;
    private int myFreeCount;
    private KeyCollection<TKey, TValue> myKeys;
    private ValueCollection<TKey, TValue> myValues;
    private int myVersion;
    private bool myCheckKeyForNull;
    public IEqualityComparer`1<TKey> Comparer { get; }
    private ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.Keys { get; }
    private ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.Values { get; }
    private IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Keys { get; }
    private IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Values { get; }
    public KeyCollection<TKey, TValue> Keys { get; }
    public ValueCollection<TKey, TValue> Values { get; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.IsReadOnly { get; }
    public TValue Item { get; public set; }
    public HashMap`2(IDictionary`2<TKey, TValue> dictionary);
    public HashMap`2(IEqualityComparer`1<TKey> comparer);
    public HashMap`2(int capacity);
    public HashMap`2(IDictionary`2<TKey, TValue> dictionary, IEqualityComparer`1<TKey> comparer);
    public HashMap`2(int capacity, IEqualityComparer`1<TKey> comparer);
    public IEqualityComparer`1<TKey> get_Comparer();
    private sealed virtual override ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.get_Keys();
    private sealed virtual override ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.get_Values();
    private sealed virtual override IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Keys();
    private sealed virtual override IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Values();
    public KeyCollection<TKey, TValue> get_Keys();
    public ValueCollection<TKey, TValue> get_Values();
    public sealed virtual int get_Count();
    public sealed virtual void Add(TKey key, TValue value);
    public sealed virtual bool Remove(TKey key);
    public sealed virtual void Clear();
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Add(KeyValuePair`2<TKey, TValue> item);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Contains(KeyValuePair`2<TKey, TValue> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.CopyTo(KeyValuePair`2[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Remove(KeyValuePair`2<TKey, TValue> item);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.get_IsReadOnly();
    public sealed virtual bool ContainsKey(TKey key);
    public bool ContainsValue(TValue value);
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    public bool IsEmpty();
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    public bool TryGetKeyAndValue(TKey key, TKey& hashedKey, TValue& value);
    private sealed virtual override IEnumerator`1<KeyValuePair`2<TKey, TValue>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TValue>>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public PairEnumerator<TKey, TValue> GetEnumerator();
    private void RemoveEntry(int entryIndex);
    private bool CompareKey(TKey key, int entryIndex);
    private int GetEntryIndex(TKey key);
    private void Initialize(int capacity);
    private void Insert(TKey key, TValue value, bool add);
    private void Resize();
}
public interface JetBrains.Util.Collections.IFreezable {
    [DesignerSerializationVisibilityAttribute("0")]
public bool IsFrozen { get; }
    public abstract virtual bool get_IsFrozen();
    public abstract virtual void Freeze();
}
public class JetBrains.Util.Collections.LazyProcessedCollection`1 : object {
    private Func`2<List`1<T>, List`1<T>> myProcessor;
    private List`1<T> myList;
    private bool myProcessed;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public LazyProcessedCollection`1(Func`2<List`1<T>, List`1<T>> processor);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private void EnsureProcessed();
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual bool Remove(T item);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class JetBrains.Util.Collections.OrderedCollection`1 : LazyProcessedCollection`1<T> {
    public OrderedCollection`1(Comparison`1<T> comparer);
}
[ExtensionAttribute]
public static class JetBrains.Util.CollectionUtil : object {
    [ExtensionAttribute]
[SourceTemplateAttribute]
public static void enumerateWith(IEnumerable`1<T1> c1, IEnumerable`1<T2> c2);
    [NotNullAttribute]
[ExtensionAttribute]
[PureAttribute]
public static string ToStringWithCount(IEnumerable enumerable, bool multiline);
    [NotNullAttribute]
[PureAttribute]
public static string ToString(IEnumerable`1<T> enumerable, string separator);
    [ExtensionAttribute]
[PureAttribute]
[CollectionAccessAttribute("1")]
[CanBeNullAttribute]
public static T TryPeek(Stack`1<T> stack);
    [CollectionAccessAttribute("2")]
[CanBeNullAttribute]
[ExtensionAttribute]
public static T TryPop(Stack`1<T> stack);
    [PureAttribute]
[CollectionAccessAttribute("1")]
[ExtensionAttribute]
public static T Peek(IList`1<T> list);
    [CollectionAccessAttribute("2")]
[ExtensionAttribute]
public static T Pop(IList`1<T> list);
    [CollectionAccessAttribute("6")]
[ExtensionAttribute]
public static void Push(IList`1<T> list, T item);
    [PureAttribute]
public static bool AreUnique(IEnumerable`1<T> enumerable);
    [ExtensionAttribute]
[PureAttribute]
public static bool EqualEnumerables(IEnumerable`1<T> left, IEnumerable`1<T> right);
    [PureAttribute]
[ExtensionAttribute]
public static bool EqualEnumerables(IEnumerable`1<T> left, IEnumerable`1<T> right, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static void AssertEquivalentTo(IEnumerable thіs, IEnumerable expected, OnError onerror);
    [ExtensionAttribute]
public static bool AssertEquivalentTo(IEnumerable`1<TItem> thіs, IEnumerable`1<TItem> expected, OnError onerror, IEqualityComparer`1<TItem> itemcomparer);
    [PureAttribute]
[CollectionAccessAttribute("1")]
public static int GetHashCode(ICollection`1<T> collection);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsEquivalentTo(IEnumerable`1<T> left, IEnumerable`1<T> right, IEqualityComparer`1<T> comparer);
    [NotNullAttribute]
[PureAttribute]
private static ISet`1<T> GetOrCreateSet(IEnumerable`1<T> source, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
[ObsoleteAttribute("This method has unclear semantic and unpredictable performance. See documentation for details")]
[PureAttribute]
public static bool EqualItemsContainedIn(ICollection`1<T> set1, ICollection`1<T> set2);
    [ExtensionAttribute]
[ObsoleteAttribute("This method has unclear semantic and unpredictable performance. See documentation for details")]
[PureAttribute]
public static bool EqualItemsContainedInReadOnly(IReadOnlyCollection`1<T> set1, IReadOnlyCollection`1<T> set2);
    [ExtensionAttribute]
[PureAttribute]
public static int CompareEnumerables(IEnumerable`1<T> left, IEnumerable`1<T> right, IComparer`1<T> comparer);
    [NotNullAttribute]
[PureAttribute]
[ExtensionAttribute]
public static IEnumerable`1<T> Prepend(IEnumerable`1<T> tail, T[] elements);
    [NotNullAttribute]
[PureAttribute]
[ExtensionAttribute]
public static IEnumerable`1<T> Prepend(IEnumerable`1<T> tail, IEnumerable`1<T> elements);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IEnumerable`1<T> Concat(IEnumerable`1<T> first, T element);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IEnumerable`1<T> Concat(IEnumerable`1<T> first, T[] elements);
    [NotNullAttribute]
[PureAttribute]
public static IEnumerable`1<T> EnumerateAll(IEnumerable`1[] enumerables);
    [NotNullAttribute]
[PureAttribute]
public static IEnumerable`1<T> EnumerateAll(IEnumerable`1<IEnumerable`1<T>> enumerables);
    [PureAttribute]
[ExtensionAttribute]
public static int TryGetCountFast(IEnumerable`1<T> enumerable);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Do not use this method with ICollection<T>, check its Count property.", "True")]
[ExtensionAttribute]
public static int TryGetCountFast(ICollection`1<T> collection);
    [ObsoleteAttribute("Do not use this method with ICollection, check its Count property.", "True")]
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static int TryGetCountFast(ICollection collection);
    [ObsoleteAttribute("Do not use this method with string, check its Length property.", "True")]
[EditorBrowsableAttribute("1")]
[ExtensionAttribute]
public static int TryGetCountFast(string str);
    [PureAttribute]
[ExtensionAttribute]
public static bool CanBeProvenEmptyFast(IEnumerable`1<T> enumerable);
    [ObsoleteAttribute("Do not use this method with ICollection<T>, check its Count property.", "True")]
[ExtensionAttribute]
public static bool CanBeProvenEmptyFast(ICollection`1<T> collection);
    [ObsoleteAttribute("Do not use this method with ICollection, check its Count property.", "True")]
[ExtensionAttribute]
public static bool CanBeProvenEmptyFast(ICollection collection);
    [ObsoleteAttribute("Do not use this method with string, check its Length property.", "True")]
[ExtensionAttribute]
public static bool CanBeProvenEmptyFast(string collection);
    [PureAttribute]
[ExtensionAttribute]
public static bool CanBeProvenNonEmptyFast(IEnumerable`1<T> enumerable);
    [ObsoleteAttribute("Do not use this method with ICollection<T>, check its Count property.", "True")]
[ExtensionAttribute]
public static bool CanBeProvenNonEmptyFast(ICollection`1<T> collection);
    [ExtensionAttribute]
[ObsoleteAttribute("Do not use this method with ICollection, check its Count property.", "True")]
public static bool CanBeProvenNonEmptyFast(ICollection collection);
    [ExtensionAttribute]
[ObsoleteAttribute("Do not use this method with string, check its Length property.", "True")]
public static bool CanBeProvenNonEmptyFast(string collection);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsEmpty(IEnumerable`1<T> enumerable);
    [ExtensionAttribute]
[PureAttribute]
[EditorBrowsableAttribute("1")]
[CollectionAccessAttribute("1")]
public static bool IsEmpty(ICollection`1<T> collection);
    [EditorBrowsableAttribute("1")]
[PureAttribute]
[ExtensionAttribute]
public static bool IsEmpty(LocalList`1<T> collection);
    [CollectionAccessAttribute("1")]
[PureAttribute]
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static bool IsEmpty(Stack`1<T> collection);
    [PureAttribute]
[EditorBrowsableAttribute("1")]
[CollectionAccessAttribute("1")]
[ExtensionAttribute]
public static bool IsEmpty(Queue`1<T> collection);
    [ExtensionAttribute]
[ContractAnnotationAttribute("null => true")]
[PureAttribute]
public static bool IsNullOrEmpty(IEnumerable`1<T> enumerable);
    [ContractAnnotationAttribute("null => true")]
[PureAttribute]
[EditorBrowsableAttribute("1")]
[CollectionAccessAttribute("1")]
[ExtensionAttribute]
public static bool IsNullOrEmpty(ICollection`1<T> collection);
    [EditorBrowsableAttribute("1")]
[PureAttribute]
[ExtensionAttribute]
public static bool IsNullOrEmpty(LocalList`1<T> collection);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
[CollectionAccessAttribute("1")]
[PureAttribute]
public static bool IsNullOrEmpty(Stack`1<T> collection);
    [ExtensionAttribute]
[PureAttribute]
[EditorBrowsableAttribute("1")]
[CollectionAccessAttribute("1")]
public static bool IsNullOrEmpty(Queue`1<T> collection);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsSingle(IEnumerable`1<T> enumerable);
    [PureAttribute]
[EditorBrowsableAttribute("1")]
[CollectionAccessAttribute("1")]
[ExtensionAttribute]
public static bool IsSingle(ICollection`1<T> collection);
    [PureAttribute]
[ExtensionAttribute]
public static bool HasAtLeast(IEnumerable`1<T> enumerable, int minimumCount);
    [PureAttribute]
[CollectionAccessAttribute("1")]
[EditorBrowsableAttribute("1")]
[ExtensionAttribute]
public static bool HasAtLeast(ICollection`1<T> collection, int minimumCount);
    [ExtensionAttribute]
[PureAttribute]
[EditorBrowsableAttribute("1")]
public static bool HasAtLeast(string str, int minimumCount);
    [PureAttribute]
[ExtensionAttribute]
public static bool HasMultiple(IEnumerable`1<T> enumerable);
    [EditorBrowsableAttribute("1")]
[ExtensionAttribute]
[PureAttribute]
[CollectionAccessAttribute("1")]
public static bool HasMultiple(ICollection`1<T> collection);
    [PureAttribute]
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static bool HasMultiple(string str);
    [PureAttribute]
[ExtensionAttribute]
public static bool HasMoreThan(IEnumerable`1<T> enumerable, int exclusiveLowerBound);
    [ExtensionAttribute]
[CollectionAccessAttribute("1")]
[PureAttribute]
[EditorBrowsableAttribute("1")]
public static bool HasMoreThan(ICollection`1<T> collection, int exclusiveLowerBound);
    [EditorBrowsableAttribute("1")]
[ExtensionAttribute]
[PureAttribute]
public static bool HasMoreThan(string str, int exclusiveLowerBound);
    [PureAttribute]
[ExtensionAttribute]
public static bool CountIs(IEnumerable`1<T> enumerable, int exactCount);
    [PureAttribute]
[CollectionAccessAttribute("1")]
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static bool CountIs(ICollection`1<T> collection, int exactCount);
    [PureAttribute]
[EditorBrowsableAttribute("1")]
[ExtensionAttribute]
public static bool CountIs(string str, int exactCount);
    [ExtensionAttribute]
[PureAttribute]
[CollectionAccessAttribute("1")]
public static bool Any(ICollection`1<T> collection);
    [CanBeNullAttribute]
[PureAttribute]
[ExtensionAttribute]
public static T FirstNotNull(IEnumerable`1<T> enumerable);
    [PureAttribute]
[ExtensionAttribute]
[CanBeNullAttribute]
public static Nullable`1<T> FirstNotNull(IEnumerable`1<Nullable`1<T>> enumerable);
    [CanBeNullAttribute]
[PureAttribute]
[ExtensionAttribute]
public static Nullable`1<TSource> FirstOrNull(IEnumerable`1<TSource> enumerable, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
[PureAttribute]
public static TSource FirstOrDefault(IEnumerable`1<TSource> enumerable, TSource defaultValue);
    [PureAttribute]
[ExtensionAttribute]
[CanBeNullAttribute]
public static T SingleItem(IEnumerable`1<T> enumerable, T defaultValue);
    [CanBeNullAttribute]
[ExtensionAttribute]
[CollectionAccessAttribute("1")]
[PureAttribute]
public static T SingleItem(IList`1<T> list);
    [CanBeNullAttribute]
[PureAttribute]
[ExtensionAttribute]
public static T SingleItem(T[] array);
    [PureAttribute]
[ExtensionAttribute]
[CanBeNullAttribute]
public static T SingleItem(IEnumerable`1<T> enumerable, Func`2<T, bool> predicate);
    [PureAttribute]
[CanBeNullAttribute]
public static T GetPrevious(IEnumerable`1<T> enumerable, T anchor);
    [PureAttribute]
[CanBeNullAttribute]
public static T GetNext(IEnumerable`1<T> enumerable, T anchor);
    [CanBeNullAttribute]
[PureAttribute]
[ExtensionAttribute]
public static T TakeMax(IEnumerable`1<T> enumerable, Func`2<T, TKey> metric, TKey min);
    [PureAttribute]
[ExtensionAttribute]
[CanBeNullAttribute]
public static T TakeMin(IEnumerable`1<T> enumerable, Func`2<T, TKey> metric);
    [NotNullAttribute]
[ExtensionAttribute]
[PureAttribute]
public static IEnumerable`1<T> WhereNotNull(IEnumerable`1<T> enumerable);
    [ExtensionAttribute]
[PureAttribute]
[NotNullAttribute]
public static IEnumerable`1<Nullable`1<T>> WhereNotNull(IEnumerable`1<Nullable`1<T>> enumerable);
    [NotNullAttribute]
[PureAttribute]
[ExtensionAttribute]
public static IEnumerable`1<TResult> SelectNotNull(IEnumerable`1<TSource> enumerable, Func`2<TSource, TResult> selector);
    [ExtensionAttribute]
[PureAttribute]
[NotNullAttribute]
public static IEnumerable`1<TResult> SelectNotNull(IEnumerable`1<TSource> enumerable, Func`2<TSource, Nullable`1<TResult>> selector);
    [NotNullAttribute]
[PureAttribute]
[ExtensionAttribute]
[CollectionAccessAttribute("1")]
public static IEnumerable`1<TSource> Slice(IList`1<TSource> source, int from, int count);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IEnumerable`1<T> DefaultIfEmptyLazy(IEnumerable`1<T> enumerable, Func`1<T> defaultValueFactory);
    [PureAttribute]
[ExtensionAttribute]
[NotNullAttribute]
public static IEnumerable`1<T> EmptyIfNull(IEnumerable`1<T> enumerable);
    [CollectionAccessAttribute("6")]
[ExtensionAttribute]
public static void AddRange(ICollection`1<TTarget> to, IEnumerable`1<TSource> from);
    [ExtensionAttribute]
[CollectionAccessAttribute("6")]
public static void AddRange(ICollection`1<TTarget> to, IEnumerable`1<TSource> from, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
[CollectionAccessAttribute("6")]
[NotNullAttribute]
public static TCollection AddRangeFluent(TCollection to, IEnumerable`1<TItem> from);
    [ExtensionAttribute]
[CollectionAccessAttribute("2")]
public static void RemoveRange(ICollection`1<TTarget> collection, IEnumerable`1<TSource> items);
    [PureAttribute]
[ExtensionAttribute]
[NotNullAttribute]
public static List`1<T> AsList(IEnumerable`1<T> enumerable);
    [PureAttribute]
[ExtensionAttribute]
[NotNullAttribute]
public static IList`1<T> AsIList(IEnumerable`1<T> enumerable);
    [NotNullAttribute]
[PureAttribute]
[ExtensionAttribute]
public static IReadOnlyList`1<T> AsChunkIReadOnlyList(IEnumerable`1<T> collection);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IReadOnlyList`1<T> AsIReadOnlyList(IEnumerable`1<T> enumerable);
    [NotNullAttribute]
[PureAttribute]
[ExtensionAttribute]
public static ISet`1<T> AsSet(IEnumerable`1<T> enumerable);
    [NotNullAttribute]
[ExtensionAttribute]
[PureAttribute]
public static T[] AsArray(IEnumerable`1<T> enumerable);
    [NotNullAttribute]
[PureAttribute]
[ExtensionAttribute]
public static ICollection`1<T> AsCollection(IEnumerable`1<T> enumerable);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IReadOnlyCollection`1<T> AsReadOnlyCollection(IEnumerable`1<T> enumerable);
    [ExtensionAttribute]
[PureAttribute]
[NotNullAttribute]
public static ICollection`1<T> AsReadOnly(ICollection`1<T> collection);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static ISet`1<T> AsReadOnly(ISet`1<T> set);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
[NotNullAttribute]
[PureAttribute]
public static ICollection`1<T> AsReadOnly(JetReadOnlyCollection`1<T> collection);
    [NotNullAttribute]
[PureAttribute]
[ExtensionAttribute]
public static IDictionary`2<TKey, TValue> AsReadOnly(IDictionary`2<TKey, TValue> dictionary);
    [EditorBrowsableAttribute("1")]
[ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IDictionary`2<TKey, TValue> AsReadOnly(ReadOnlyDictionary`2<TKey, TValue> dictionary);
    [PureAttribute]
[ExtensionAttribute]
[CollectionAccessAttribute("1")]
public static int IndexOf(IList`1<T> list, T item, IEqualityComparer`1<T> comparer, int startSearchFromElement, int howManyElementsToSearch);
    [ExtensionAttribute]
[PureAttribute]
[CollectionAccessAttribute("1")]
public static int LastIndexOf(IList`1<T> list, T item, IEqualityComparer`1<T> comparer, int startSearchFromElement, int howManyElementsToSearch);
    [PureAttribute]
[CollectionAccessAttribute("1")]
[ExtensionAttribute]
public static int IndexOf(IReadOnlyList`1<T> list, T item);
    [MustUseReturnValueAttribute]
[NotNullAttribute]
public static ICollection`1<T> Sort(ICollection`1<T> collection, IComparer`1<T> comparer);
    [MustUseReturnValueAttribute]
[NotNullAttribute]
public static IList`1<T> Sort(ICollection`1<T> collection, Comparison`1<T> comparer);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsSorted(IEnumerable`1<T> enumerable, IComparer`1<T> comparer);
    [PureAttribute]
[NotNullAttribute]
public static IEnumerable`1<T> EnumerateRecursivelyDfs(T root, Func`2<T, IEnumerable`1<T>> getChildren);
    [PureAttribute]
[NotNullAttribute]
public static IEnumerable`1<T> EnumerateRecursivelyBfs(T root, Func`2<T, IEnumerable`1<T>> getChildren);
    [NotNullAttribute]
[PureAttribute]
public static JetHashSet`1<T> EnumerateRecursivelyBfsDistinct(T root, Func`2<T, IEnumerable`1<T>> getChildren);
    [PureAttribute]
[CollectionAccessAttribute("1")]
[ExtensionAttribute]
[NotNullAttribute]
public static Stack`1<T> Clone(Stack`1<T> stack, Func`2<T, T> copyFunc);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
[CollectionAccessAttribute("1")]
public static JetHashSet`1<T> Clone(JetHashSet`1<T> set);
    [PureAttribute]
[ExtensionAttribute]
[NotNullAttribute]
[CollectionAccessAttribute("1")]
public static CompactSet`1<T> Clone(CompactSet`1<T> set);
    [ExtensionAttribute]
[CollectionAccessAttribute("1")]
[PureAttribute]
public static TValue TryGetValue(IDictionary`2<TKey, TValue> dictionary, TKey key, TValue defaultValue);
    [PureAttribute]
[ExtensionAttribute]
[CollectionAccessAttribute("1")]
[CanBeNullAttribute]
public static TValue TryGetValue(IDictionary`2<TKey, TValue> dictionary, TKey key);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
[CollectionAccessAttribute("1")]
public static Nullable`1<TValue> TryGetValueNullable(IDictionary`2<TKey, TValue> dictionary, TKey key);
    [ExtensionAttribute]
[PureAttribute]
[CollectionAccessAttribute("1")]
public static TValue GetValue(IDictionary`2<TKey, TValue> dictionary, TKey key, string exceptionText);
    [StringFormatMethodAttribute("exceptionFormat")]
[CollectionAccessAttribute("1")]
[ExtensionAttribute]
[PureAttribute]
public static TValue GetValue(IDictionary`2<TKey, TValue> dictionary, TKey key, string exceptionFormat, TArg argument);
    [MustUseReturnValueAttribute]
[ExtensionAttribute]
public static TValue GetOrCreateValue(IDictionary`2<TKey, TValue> dictionary, TKey key, Func`1<TValue> factory);
    [MustUseReturnValueAttribute]
[ExtensionAttribute]
public static TValue GetOrCreateValue(IDictionary`2<TKey, TValue> dictionary, TKey key, Func`2<TKey, TValue> factory);
    [MustUseReturnValueAttribute]
[ExtensionAttribute]
public static TValue GetOrCreateValue(IDictionary`2<TKey, TValue> dictionary, TKey key, TValue altValue);
    [PureAttribute]
[ExtensionAttribute]
public static bool EqualDictionaries(IDictionary`2<TKey, TValue> left, IDictionary`2<TKey, TValue> right);
    [ExtensionAttribute]
[PureAttribute]
public static bool EqualDictionaries(IDictionary`2<TKey, TValue> left, IDictionary`2<TKey, TValue> right, IEqualityComparer`1<TValue> comparer);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static string AggregateString(IEnumerable`1<TSource> source, string separator, Func`3<StringBuilder, TSource, StringBuilder> funcAppend);
    [PureAttribute]
[NotNullAttribute]
[ExtensionAttribute]
public static TResult AggregateString(IEnumerable`1<TSource> source, string separator, Func`3<StringBuilder, TSource, StringBuilder> funcAppend, Func`2<StringBuilder, TResult> funcConvert);
    [NotNullAttribute]
[PureAttribute]
[ExtensionAttribute]
public static string AggregateString(IEnumerable`1<TSource> source, string seed, string separator, Func`3<StringBuilder, TSource, StringBuilder> funcAppend);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static TResult AggregateString(IEnumerable`1<TSource> source, string seed, string separator, Func`3<StringBuilder, TSource, StringBuilder> funcAppend, Func`2<StringBuilder, TResult> funcConvert);
    [NotNullAttribute]
[PureAttribute]
[ExtensionAttribute]
public static string AggregateString(IEnumerable`1<TSource> source, StringBuilder seed, string separator, Func`3<StringBuilder, TSource, StringBuilder> funcAppend);
    [PureAttribute]
[NotNullAttribute]
[ExtensionAttribute]
public static string AggregateString(IEnumerable`1<TSource> source, Func`3<StringBuilder, TSource, StringBuilder> funcAppend);
    [PureAttribute]
[NotNullAttribute]
[ExtensionAttribute]
public static TResult AggregateString(IEnumerable`1<TSource> source, StringBuilder seed, string separator, Func`3<StringBuilder, TSource, StringBuilder> funcAppend, Func`2<StringBuilder, TResult> funcConvert);
    [ExtensionAttribute]
public static void SequenceForEach(IEnumerable`1<T1> first, IEnumerable`1<T2> second, Action`2<T1, T2> function);
    [PureAttribute]
[ExtensionAttribute]
public static IEnumerable`1<Pair`2<T1, T2>> SequenceIterate(IEnumerable`1<T1> first, IEnumerable`1<T2> second);
    [PureAttribute]
[ExtensionAttribute]
public static bool SequenceAny(IEnumerable`1<T1> first, IEnumerable`1<T2> second, Func`3<T1, T2, bool> predicate);
    [PureAttribute]
[ExtensionAttribute]
public static bool SequenceAny(IEnumerable`1<T1> first, IEnumerable`1<T2> second, T3 context, Func`4<T1, T2, T3, bool> predicate);
    [ExtensionAttribute]
[PureAttribute]
public static bool SequenceForAll(IEnumerable`1<T1> first, IEnumerable`1<T2> second, Func`3<T1, T2, bool> predicate);
    [CollectionAccessAttribute("1")]
[NotNullAttribute]
[PureAttribute]
[ExtensionAttribute]
public static T[] ToArray(ICollection`1<T> collection);
    [PureAttribute]
[NotNullAttribute]
[ExtensionAttribute]
[CollectionAccessAttribute("1")]
public static List`1<TOutput> ConvertAll(IList`1<TInput> list);
    [NotNullAttribute]
[ExtensionAttribute]
[PureAttribute]
[CollectionAccessAttribute("1")]
public static List`1<TOutput> ConvertAll(IList`1<TInput> list, Func`2<TInput, TOutput> converter);
    [NotNullAttribute]
[ExtensionAttribute]
[PureAttribute]
public static List`1<TResult> ToList(T[] source, Func`2<T, TResult> selector);
    [NotNullAttribute]
[PureAttribute]
[ExtensionAttribute]
[CollectionAccessAttribute("1")]
public static List`1<TResult> ToList(List`1<T> source, Func`2<T, TResult> selector);
    [ExtensionAttribute]
[PureAttribute]
[NotNullAttribute]
public static List`1<TResult> ToList(IEnumerable`1<T> enumerable, Func`2<T, TResult> selector);
    [PureAttribute]
[ExtensionAttribute]
[NotNullAttribute]
public static IList`1<TResult> ToIList(T[] source, Func`2<T, TResult> selector);
    [CollectionAccessAttribute("1")]
[PureAttribute]
[NotNullAttribute]
[ExtensionAttribute]
public static IList`1<TResult> ToIList(List`1<T> source, Func`2<T, TResult> selector);
    [PureAttribute]
[ExtensionAttribute]
[NotNullAttribute]
public static IList`1<TResult> ToIList(IEnumerable`1<T> source, Func`2<T, TResult> selector);
    [ExtensionAttribute]
[PureAttribute]
[NotNullAttribute]
public static IList`1<T> ToIList(T[] source);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IList`1<T> ToIList(IEnumerable`1<T> enumerable);
    [ExtensionAttribute]
[PureAttribute]
[NotNullAttribute]
public static IReadOnlyList`1<T> ToIReadOnlyList(T[] source);
    [PureAttribute]
[ExtensionAttribute]
[NotNullAttribute]
public static IReadOnlyList`1<T> ToIReadOnlyList(IEnumerable`1<T> enumerable);
    [ExtensionAttribute]
[PureAttribute]
[NotNullAttribute]
public static IReadOnlyList`1<TResult> ToIReaonlyList(IEnumerable`1<T> source, Func`2<T, TResult> selector);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IReadOnlyList`1<TResult> ToIReadOnlyList(T[] source, Func`2<T, TResult> selector);
    [PureAttribute]
[ExtensionAttribute]
[NotNullAttribute]
[CollectionAccessAttribute("1")]
public static IReadOnlyList`1<TResult> ToIReadOnlyList(List`1<T> source, Func`2<T, TResult> selector);
    [PureAttribute]
[ExtensionAttribute]
[NotNullAttribute]
public static T[] ArrayUnion(T[] array, T item);
    [PureAttribute]
[ExtensionAttribute]
[NotNullAttribute]
public static T[] ArrayUnion(T[] array, T item, IEqualityComparer`1<T> comparer);
    [NotNullAttribute]
[PureAttribute]
[ExtensionAttribute]
public static T[] ArrayExcept(T[] thіs, T item);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static T[] ArrayExcept(T[] array, T item, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static void Add(ICollection`1<T> collection, Lifetime lifetime, T item);
    [ExtensionAttribute]
public static void AddLocked(ICollection`1<T> collection, Lifetime lifetime, Func`1<IDisposable> lock, T item);
    [ExtensionAttribute]
public static void AddRange(ICollection`1<T> collection, Lifetime lifetime, IEnumerable`1<T> items);
    [ExtensionAttribute]
public static void CopyTo(IEnumerable`1<TItem> enumerable, TItem[] array, int arrayIndex);
    public static void SetDifference(JetHashSet`1<T> oldSet, JetHashSet`1<T> newSet, JetHashSet`1<T> addedItems, JetHashSet`1<T> removedItems);
    public static bool SetDifference(ISet`1<T> oldSet, ISet`1<T> newSet, ISet`1& addedItems, ISet`1& removedItems, IEqualityComparer`1<T> equalityComparer);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IEnumerable`1<TTarget> SafeOfType(IEnumerable enumerable);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Please, avoid use of this method. Check the documentation for details")]
public static void ForEach(IEnumerable`1<T> collection, Action`1<T> action);
    [NotNullAttribute]
[PureAttribute]
[ExtensionAttribute]
public static IList`1<T> Reverse(IList`1<T> list);
    [PureAttribute]
[ExtensionAttribute]
public static bool Contains(IReadOnlyCollection`1<T> list, T item);
    [NotNullAttribute]
[ExtensionAttribute]
[PureAttribute]
public static IEnumerable`1<T> Except(IEnumerable`1<T> enumerable, T element);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IEnumerable`1<T> Union(IEnumerable`1<T> enumerable, T element);
    [NotNullAttribute]
public static IEnumerable`1<T> Unfold(T element, Func`2<T, T> next, Func`2<T, bool> include);
    [ExtensionAttribute]
[PureAttribute]
[NotNullAttribute]
public static IEnumerable`1<T> Interleave(IEnumerable`1<T> lhs, IEnumerable`1<T> rhs);
    [ExtensionAttribute]
public static void DisposeAll(IEnumerable`1<TDisposable> enumerable);
}
[ExtensionAttribute]
public static class JetBrains.Util.CollectionValidator : object {
    [ExtensionAttribute]
public static void CreateReadonlyValidator(ICollectionEvents`1<TItem> thіs, Lifetime lifetime, ReadonlyToken token);
    [ExtensionAttribute]
public static void CreateThreadAffinityValidator(ICollectionEvents`1<TItem> thіs, Lifetime lifetime, Thread thread);
    [ExtensionAttribute]
[NotNullAttribute]
public static CollectionEvents`1<TValue> EnsureReadonly(CollectionEvents`1<TValue> thіs, ReadonlyToken token);
    [ExtensionAttribute]
[NotNullAttribute]
public static CollectionEvents`1<TValue> EnsureReadonly(CollectionEvents`1<TValue> thіs, Lifetime lifetime, ReadonlyToken token);
    [NotNullAttribute]
[ExtensionAttribute]
public static ICollectionEvents`1<TValue> EnsureReadonly(ICollectionEvents`1<TValue> thіs, ReadonlyToken token);
    [ExtensionAttribute]
[NotNullAttribute]
public static ICollectionEvents`1<TValue> EnsureReadonly(ICollectionEvents`1<TValue> thіs, Lifetime lifetime, ReadonlyToken token);
    [NotNullAttribute]
[ExtensionAttribute]
public static IListEvents`1<TValue> EnsureReadonly(IListEvents`1<TValue> thіs, ReadonlyToken token);
    [NotNullAttribute]
[ExtensionAttribute]
public static IListEvents`1<TValue> EnsureReadonly(IListEvents`1<TValue> thіs, Lifetime lifetime, ReadonlyToken token);
    [NotNullAttribute]
[ExtensionAttribute]
public static DictionaryEvents`2<TKey, TValue> EnsureReadonly(DictionaryEvents`2<TKey, TValue> thіs, ReadonlyToken token);
    [NotNullAttribute]
[ExtensionAttribute]
public static DictionaryEvents`2<TKey, TValue> EnsureReadonly(DictionaryEvents`2<TKey, TValue> thіs, Lifetime lifetime, ReadonlyToken token);
    [NotNullAttribute]
[ExtensionAttribute]
public static IDictionaryEvents`2<TKey, TValue> EnsureReadonly(IDictionaryEvents`2<TKey, TValue> thіs, ReadonlyToken token);
    [ExtensionAttribute]
[NotNullAttribute]
public static IDictionaryEvents`2<TKey, TValue> EnsureReadonly(IDictionaryEvents`2<TKey, TValue> thіs, Lifetime lifetime, ReadonlyToken token);
    [ExtensionAttribute]
[NotNullAttribute]
public static CollectionEvents`1<TItem> EnsureThisThread(CollectionEvents`1<TItem> thіs);
    [ExtensionAttribute]
[NotNullAttribute]
public static CollectionEvents`1<TItem> EnsureThisThread(CollectionEvents`1<TItem> thіs, Lifetime lifetime);
    [NotNullAttribute]
[ExtensionAttribute]
public static ICollectionEvents`1<TItem> EnsureThisThread(ICollectionEvents`1<TItem> thіs);
    [ExtensionAttribute]
[NotNullAttribute]
public static ICollectionEvents`1<TItem> EnsureThisThread(ICollectionEvents`1<TItem> thіs, Lifetime lifetime);
    [NotNullAttribute]
[ExtensionAttribute]
public static IListEvents`1<TItem> EnsureThisThread(IListEvents`1<TItem> thіs);
    [NotNullAttribute]
[ExtensionAttribute]
public static IListEvents`1<TItem> EnsureThisThread(IListEvents`1<TItem> thіs, Lifetime lifetime);
    [NotNullAttribute]
[ExtensionAttribute]
public static DictionaryEvents`2<TKey, TValue> EnsureThisThread(DictionaryEvents`2<TKey, TValue> thіs);
    [NotNullAttribute]
[ExtensionAttribute]
public static DictionaryEvents`2<TKey, TValue> EnsureThisThread(DictionaryEvents`2<TKey, TValue> thіs, Lifetime lifetime);
    [ExtensionAttribute]
[NotNullAttribute]
public static IDictionaryEvents`2<TKey, TValue> EnsureThisThread(IDictionaryEvents`2<TKey, TValue> thіs);
    [NotNullAttribute]
[ExtensionAttribute]
public static IDictionaryEvents`2<TKey, TValue> EnsureThisThread(IDictionaryEvents`2<TKey, TValue> thіs, Lifetime lifetime);
}
public static class JetBrains.Util.CommandLineUtil : object {
    private static string ParameterPrefix;
    private static string ParameterToValueSplitter;
    public static string ComposeArgument(string argumentName, string value);
    [NotNullAttribute]
public static string ToString(IEnumerable`1<string> args);
    public static void ToString(StringBuilder builder, string arg, bool addQuote);
    [NotNullAttribute]
public static string Quote(string arg);
    [NotNullAttribute]
public static string QuoteIfNeeded(string arg);
    [CanBeNullAttribute]
public static FirstArgumentResult ParseFirstArgument(string args);
    [NotNullAttribute]
public static String[] ToArray(string args);
    [NotNullAttribute]
public static String[] ToArrayWinApi(string unsplitArgumentLine);
    private static IntPtr CommandLineToArgvW(string lpCmdLine, Int32& pNumArgs);
    private static IntPtr LocalFree(IntPtr hMem);
}
public class JetBrains.Util.CompoundException : ApplicationException {
    [CompilerGeneratedAttribute]
private IList`1<Exception> <Exceptions>k__BackingField;
    [CompilerGeneratedAttribute]
private static Func`2<Exception, string> CS$<>9__CachedAnonymousMethodDelegate1;
    public IList`1<Exception> Exceptions { get; private set; }
    public string Message { get; }
    public CompoundException(Exception[] exceptions);
    protected CompoundException(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public IList`1<Exception> get_Exceptions();
    [CompilerGeneratedAttribute]
private void set_Exceptions(IList`1<Exception> value);
    public void Catch(Action action);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual string ToString();
    [NotNullAttribute]
protected IList`1<Exception> GetDistinctExceptions();
    public virtual string get_Message();
    [CompilerGeneratedAttribute]
private static string <GetObjectData>b__0(Exception ex);
}
public class JetBrains.Util.Concurrency.ConcurrentArray`1 : object {
    private T[] modreq(System.Runtime.CompilerServices.IsVolatile) myArray;
    public void Add(T item);
    public bool Remove(T item);
    public void Add(Lifetime lifetime, T item);
    public T[] TakeSnapshot();
}
public class JetBrains.Util.Concurrency.ConcurrentSet`1 : object {
    private JetFastSemiReenterableRWLock myLock;
    private JetHashSet`1<T> mySet;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public ConcurrentSet`1(IEnumerable`1<T> values, IEqualityComparer`1<T> comparer, int capacity);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual bool Remove(T item);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override bool System.Collections.Generic.ISet<T>.Add(T item);
    public sealed virtual void UnionWith(IEnumerable`1<T> other);
    public sealed virtual void IntersectWith(IEnumerable`1<T> other);
    public sealed virtual void ExceptWith(IEnumerable`1<T> other);
    public sealed virtual void SymmetricExceptWith(IEnumerable`1<T> other);
    public sealed virtual bool IsSubsetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsSupersetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsProperSupersetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsProperSubsetOf(IEnumerable`1<T> other);
    public sealed virtual bool Overlaps(IEnumerable`1<T> other);
    public sealed virtual bool SetEquals(IEnumerable`1<T> other);
}
public class JetBrains.Util.Concurrency.DisposableReadLock : ValueType {
    private ReaderWriterLockSlim myLock;
    public DisposableReadLock(ReaderWriterLockSlim lock);
    public sealed virtual void Dispose();
}
public class JetBrains.Util.Concurrency.DisposableWriteLock : ValueType {
    private ReaderWriterLockSlim myLock;
    public DisposableWriteLock(ReaderWriterLockSlim lock);
    public sealed virtual void Dispose();
}
public class JetBrains.Util.Concurrency.Events.BclEventWaitHandle : object {
    private EventWaitHandle myWaitHandle;
    public BclEventWaitHandle(bool initialState, EventResetMode mode, string name);
    public sealed virtual void Dispose();
    public sealed virtual void Set();
    public sealed virtual void Reset();
    public sealed virtual bool IsSet();
    public sealed virtual bool WaitOne(int timeout);
    public sealed virtual Nullable`1<bool> MsgWaitOne(int timeout);
    public sealed virtual void WaitOne();
    public sealed virtual bool MsgWaitOne();
}
public interface JetBrains.Util.Concurrency.Events.IEventWaitHandle {
    public abstract virtual void Set();
    public abstract virtual void Reset();
    public abstract virtual bool IsSet();
    public abstract virtual bool WaitOne(int timeout);
    public abstract virtual Nullable`1<bool> MsgWaitOne(int timeout);
    public abstract virtual void WaitOne();
    public abstract virtual bool MsgWaitOne();
}
public class JetBrains.Util.Concurrency.EventWaitHandleBase : object {
    private IEventWaitHandle myImplementation;
    protected EventWaitHandleBase(IEventWaitHandle implementation);
    public sealed virtual void Dispose();
    public sealed virtual void Set();
    public sealed virtual void Reset();
    public sealed virtual bool IsSet();
    public sealed virtual bool WaitOne(int timeout);
    public sealed virtual Nullable`1<bool> MsgWaitOne(int timeout);
    public sealed virtual void WaitOne();
    public sealed virtual bool MsgWaitOne();
}
public class JetBrains.Util.Concurrency.FrugalLocalLazy`1 : ValueType {
    private T myValue;
    public bool IsValueCreated { get; }
    [PureAttribute]
public bool get_IsValueCreated();
    [PureAttribute]
public T GetValue();
    private static T CreateValue();
    public virtual string ToString();
}
[ExtensionAttribute]
public static class JetBrains.Util.Concurrency.GroupingEventHostEx : object {
    [ExtensionAttribute]
public static void QueueAtShort(GroupingEventHost host, Lifetime lifetime, string name, TimeSpan interval, Action F);
}
public interface JetBrains.Util.Concurrency.IJetDispatcherStaticMethods {
    public abstract virtual JetDispatcher CreatePerThreadInstance();
    public abstract virtual int PumpMessagesOnce();
    public abstract virtual bool Run(IProperty`1<bool> condition, TimeSpan timeout, bool bThrowOnTimeout);
    public abstract virtual bool Run(Func`1<bool> condition, TimeSpan timeout, bool bThrowOnTimeout);
    public abstract virtual void Run(TimeSpan timeout);
    public abstract virtual void Run();
}
public class JetBrains.Util.Concurrency.InterlockedUtil : object {
    public static void Increment(Int32& val, int inc);
    public static void Decrement(Int32& val, int dec);
}
public class JetBrains.Util.Concurrency.InterruptibleLazy`1 : object {
    [CanBeNullAttribute]
private Func`1<T> myValueFactory;
    private SpinWaitLock myLock;
    private T myValue;
    [DebuggerBrowsableAttribute("0")]
public T Value { get; }
    public InterruptibleLazy`1(Func`1<T> valueFactory);
    public T get_Value();
    public virtual string ToString();
}
public class JetBrains.Util.Concurrency.InterruptibleLazy`2 : object {
    private Func`2<TParam, T> myValueFactory;
    private TParam myParam;
    private T myValue;
    private SpinWaitLock myLock;
    public T Value { get; }
    public InterruptibleLazy`2(TParam param, Func`2<TParam, T> func);
    public T get_Value();
}
public interface JetBrains.Util.Concurrency.ISync {
    public abstract virtual void Acquire();
    public abstract virtual bool TryAcquire(int timeout);
    public abstract virtual void Release();
    public abstract virtual bool HasWriteAccess(Thread thread);
    public abstract virtual bool HasReadAccess(Thread thread);
}
[ThreadSafeAttribute]
public class JetBrains.Util.Concurrency.JetConcurrentQueue`1 : object {
    private static long BlockingOperationInProgressMarker;
    private T[] myQueue;
    private long myMask;
    private int mySize;
    private long myHead;
    private long myTail;
    [CompilerGeneratedAttribute]
private static Func`3<long, long, int> CS$<>9__CachedAnonymousMethodDelegate1;
    public int Count { get; }
    public object SyncRoot { get; }
    public bool IsSynchronized { get; }
    public bool IsEmpty { get; }
    public JetConcurrentQueue`1(int logMaxSize);
    private bool IsBlocked(long head, long tail);
    public sealed virtual bool TryAdd(T t);
    public bool TryDequeue(T& res);
    public bool TryPeek(T& res);
    public sealed virtual int get_Count();
    public sealed virtual void CopyTo(T[] array, int index);
    public sealed virtual T[] ToArray();
    public sealed virtual void CopyTo(Array array, int index);
    public void Clear();
    private void DoImmutableBlockingOp(Action`2<long, long> op);
    private TParam DoImmutableBlockingOp(Func`3<long, long, TParam> op);
    public sealed virtual object get_SyncRoot();
    public sealed virtual bool get_IsSynchronized();
    public bool get_IsEmpty();
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual bool TryTake(T& res);
    public T Dequeue();
    public T Peek();
    [CompilerGeneratedAttribute]
private static int <get_Count>b__0(long head, long tail);
    [CompilerGeneratedAttribute]
private T[] <ToArray>b__5(long head, long tail);
}
public enum JetBrains.Util.Concurrency.LazyExecutionMode : Enum {
    public int value__;
    public static LazyExecutionMode NotThreadSafe;
    public static LazyExecutionMode AllowMultipleThreadSafeExecution;
    public static LazyExecutionMode EnsureSingleThreadSafeExecution;
}
public class JetBrains.Util.Concurrency.LocalLazy`1 : ValueType {
    private static int FlagIsValueCreated;
    private int myFlags;
    private SpinWaitLock myLockFlag;
    private TValue myValue;
    private Func`1<TValue> myValueFactory;
    public bool IsValueCreated { get; }
    public LocalLazy`1(LazyExecutionMode mode);
    public LocalLazy`1(Func`1<TValue> valueFactory, LazyExecutionMode mode);
    [PureAttribute]
public bool get_IsValueCreated();
    public TValue GetValue();
    private TValue CreateValue();
    private TValue CreateValueWithMode();
    [PureAttribute]
public virtual string ToString();
}
public class JetBrains.Util.Concurrency.LocalLazy`2 : ValueType {
    private static int FlagIsValueCreated;
    private int myFlags;
    private SpinWaitLock myLockFlag;
    private TValue myValue;
    private Func`2<TFactoryParameter, TValue> myFValueFactory;
    private TFactoryParameter myFactoryParameter;
    public bool IsValueCreated { get; }
    public LocalLazy`2(Func`2<TFactoryParameter, TValue> FFactory, TFactoryParameter parameter);
    public LocalLazy`2(Func`2<TFactoryParameter, TValue> FFactory, TFactoryParameter parameter, LazyExecutionMode mode);
    [PureAttribute]
public bool get_IsValueCreated();
    public TValue GetValue();
    private TValue CreateValue();
    private TValue CreateValueWithMode();
    [PureAttribute]
public virtual string ToString();
}
public class JetBrains.Util.Concurrency.LockObject : object {
    [NotNullAttribute]
public IDisposable UsingLock(TimeSpan timeout);
    [CompilerGeneratedAttribute]
private void <UsingLock>b__0();
}
public class JetBrains.Util.Concurrency.NativeAutoEvent : EventWaitHandleBase {
    public NativeAutoEvent(bool initialState, string name);
}
internal class JetBrains.Util.Concurrency.NativeEvent : object {
    private static int INFINITE;
    private string myName;
    private IntPtr myNativeHandle;
    internal NativeEvent(bool initialState, EventResetMode mode, string name);
    private static IntPtr CreateEvent(IntPtr lpEventAttributes, bool bManualReset, bool bInitialState, string lpName);
    private static bool SetEvent(IntPtr hEvent);
    private static bool ResetEvent(IntPtr hEvent);
    private static UInt32 WaitForSingleObject(IntPtr hEvent, int timeout);
    private static UInt32 MsgWaitForMultipleObjects(UInt32 nCount, IntPtr[] pHandles, bool fWaitAll, int dwMilliseconds, UInt32 dwWakeMask);
    private static UInt32 CloseHandle(IntPtr hEvent);
    public sealed virtual void Dispose();
    public sealed virtual void Set();
    public sealed virtual void Reset();
    public sealed virtual bool IsSet();
    public sealed virtual bool WaitOne(int timeout);
    public sealed virtual Nullable`1<bool> MsgWaitOne(int timeout);
    public sealed virtual void WaitOne();
    public sealed virtual bool MsgWaitOne();
}
public class JetBrains.Util.Concurrency.NativeManualEvent : EventWaitHandleBase {
    public NativeManualEvent(bool initialState, string name);
}
public class JetBrains.Util.Concurrency.ParamerizedGroupingEvent`1 : object {
    private GroupingEvent myEvent;
    private HashSet`1<TParameter> myRequests;
    public ParamerizedGroupingEvent`1(Lifetime lifetime, GroupingEventHost host, string name, TimeSpan interval, Action`1<IList`1<TParameter>> handler);
    public void FireIncoming(TParameter parameter);
}
[ExtensionAttribute]
public static class JetBrains.Util.Concurrency.ReaderWriterLockSlimEx : object {
    [ExtensionAttribute]
public static void EnterWriteLock(ReaderWriterLockSlim thіs, TimeSpan time);
    [NotNullAttribute]
[ExtensionAttribute]
public static IDisposable UsingWriteLock(ReaderWriterLockSlim thіs, TimeSpan time);
    [ExtensionAttribute]
public static DisposableWriteLock UsingWriteLock(ReaderWriterLockSlim thіs);
    [ExtensionAttribute]
public static void EnterReadLock(ReaderWriterLockSlim thіs, TimeSpan time);
    [ExtensionAttribute]
public static void EnterReadLock(ReaderWriterLockSlim thіs, int timeoutms);
    [NotNullAttribute]
[ExtensionAttribute]
public static IDisposable UsingReadLock(ReaderWriterLockSlim thіs, TimeSpan time);
    [ExtensionAttribute]
public static DisposableReadLock UsingReadLock(ReaderWriterLockSlim thіs);
    [ExtensionAttribute]
public static void EnterUpgradeableReadLock(ReaderWriterLockSlim thіs, TimeSpan time);
    [NotNullAttribute]
[ExtensionAttribute]
public static IDisposable UsingUpgradeableReadLock(ReaderWriterLockSlim thіs, TimeSpan time);
}
public interface JetBrains.Util.Concurrency.ReadWriteLock {
    [NotNullAttribute]
public ISync ReadLock { get; }
    [NotNullAttribute]
public ISync WriteLock { get; }
    public abstract virtual ISync get_ReadLock();
    public abstract virtual ISync get_WriteLock();
}
public class JetBrains.Util.Concurrency.ReentrantWriterPreferenceReadWriteLock : object {
    private ReaderLock myReaderLock;
    private WriterLock myWriterLock;
    private Thread myActiveWriter;
    private int myWriteKnock;
    private int myWriteHolds;
    private ThreadToCountMap myReaders;
    private NativeManualEvent myCanReadEvent;
    private NativeManualEvent myCanWriteEvent;
    private NativeManualEvent myCanWriteExceptOneReaderEvent;
    private WriteLockTransferCookie myWriteLockTransfer;
    private NativeManualEvent myWriteLockNotTransferredEvent;
    public ISync WriteLock { get; }
    public ISync ReadLock { get; }
    public bool IsWriteLockRequested { get; }
    public sealed virtual ISync get_WriteLock();
    public sealed virtual ISync get_ReadLock();
    public bool get_IsWriteLockRequested();
    public bool IsReadLockAcquired(Thread thread);
    public bool IsWriteLockAcquired(Thread thread);
    public void TransferWriteLock(Thread anotherThread);
    public void RestoreWriteLock();
}
public class JetBrains.Util.Concurrency.ResourceCounter : object {
    internal int ValueInternal;
    public int Value { get; }
    public ResourceCounterCookie Cookie();
    public int get_Value();
}
public class JetBrains.Util.Concurrency.ResourceCounterCookie : ValueType {
    private ResourceCounter myCounter;
    internal ResourceCounterCookie(ResourceCounter counter);
    public sealed virtual void Dispose();
}
public class JetBrains.Util.Concurrency.SpinWaitLockRef : object {
    private SpinWaitLock myLock;
    public void Enter();
    public void Exit();
    public SpinWaitLockRefDispose Push();
}
[ExtensionAttribute]
public static class JetBrains.Util.Concurrency.SyncExtensions : object {
    [ExtensionAttribute]
public static void AssertReadAccess(ISync sync, string message);
    [ExtensionAttribute]
public static void AssertWriteAccess(ISync sync, string message);
    [ExtensionAttribute]
public static SyncCookie Using(ISync sync);
}
public enum JetBrains.Util.Concurrency.TaskAffinity : Enum {
    public int value__;
    public static TaskAffinity ThreadPool;
    public static TaskAffinity CallerThreadSync;
    public static TaskAffinity UiThread;
}
public interface JetBrains.Util.Concurrency.Timer.ITimer {
    public int Interval { get; public set; }
    public bool Enabled { get; public set; }
    public abstract virtual int get_Interval();
    public abstract virtual void set_Interval(int value);
    public abstract virtual void add_Tick(EventHandler value);
    public abstract virtual void remove_Tick(EventHandler value);
    public abstract virtual bool get_Enabled();
    public abstract virtual void set_Enabled(bool value);
    public abstract virtual void Start();
    public abstract virtual void Stop();
}
public class JetBrains.Util.Concurrency.Timer.JetTimer : object {
    private int myIntervalMs;
    private Timer myTimer;
    private EventHandler myEventHandler;
    private TimerCallback myCallback;
    private JetDispatcher myDispatcher;
    private int myIsTickMessageQueued;
    private bool myEnabled;
    private bool myDisposed;
    private object myCookie;
    private object myLock;
    public bool Enabled { get; public set; }
    public int Interval { get; public set; }
    public JetTimer(int intervalMs);
    public sealed virtual void add_Tick(EventHandler value);
    public sealed virtual void remove_Tick(EventHandler value);
    public sealed virtual bool get_Enabled();
    public sealed virtual void set_Enabled(bool value);
    private void UpdateTimer();
    public sealed virtual int get_Interval();
    public sealed virtual void set_Interval(int value);
    public sealed virtual void Start();
    public sealed virtual void Stop();
    private void TickCallback(object state);
    private void Close();
    public sealed virtual void Dispose();
}
public class JetBrains.Util.Concurrency.Timer.ThreadPoolTimer : object {
    [NotNullAttribute]
private Lifetime myLifetime;
    [NotNullAttribute]
private Action myOnTick;
    private bool myAllowReentrancy;
    private Timer myTimer;
    private int myIsInCallback;
    public ThreadPoolTimer(Lifetime lifetime, Action onTick, bool allowReentrancy);
    public ThreadPoolTimer(Lifetime lifetime, TimeSpan period, Action onTick, bool allowReentrancy);
    public ThreadPoolTimer(Lifetime lifetime, TimeSpan duetime, TimeSpan period, Action onTick, bool allowReentrancy);
    public void Start(TimeSpan period);
    public void Stop();
    public void Change(TimeSpan duetime, TimeSpan period);
    [HandleProcessCorruptedStateExceptionsAttribute]
private void Callback(object state);
}
public class JetBrains.Util.Concurrency.Timer.WinformTimer : object {
    private Timer myTimer;
    public int Interval { get; public set; }
    public bool Enabled { get; public set; }
    public WinformTimer(int intervalMs);
    public sealed virtual int get_Interval();
    public sealed virtual void set_Interval(int value);
    public sealed virtual void add_Tick(EventHandler value);
    public sealed virtual void remove_Tick(EventHandler value);
    public sealed virtual bool get_Enabled();
    public sealed virtual void set_Enabled(bool value);
    public sealed virtual void Start();
    public sealed virtual void Stop();
    public sealed virtual void Dispose();
}
public class JetBrains.Util.Concurrency.UiSmoothnessToolkit : object {
    internal static int TicksToWaitWriteLockThreshold;
    private static ILogger ourLogger;
    public static Thread UiThread;
    private static int ourActionUpdateOnUIThreadCounter;
    private static ConcurrentDictionary`2 modreq(System.Runtime.CompilerServices.IsVolatile) ourThreadFramesMap;
    private static Boolean modreq(System.Runtime.CompilerServices.IsVolatile) ourCaptureUiSuspensionStacks;
    [ThreadStaticAttribute]
public static Nullable`1<int> LastInterruptTime;
    public static bool Enabled { get; public set; }
    private static UiSmoothnessToolkit();
    public static bool get_Enabled();
    public static void set_Enabled(bool value);
    [ConditionalAttribute("JET_MODE_ASSERT")]
public static void StartInterruptTimeCheck();
    public static bool IsInTimeCheckProcess();
    [ConditionalAttribute("JET_MODE_ASSERT")]
public static void FinishInterruptTimeCheck();
    [ConditionalAttribute("JET_MODE_ASSERT")]
public static void CheckLastInterruptTime();
    [ConditionalAttribute("JET_MODE_ASSERT")]
public static void BeginActionUpdateOnUIThread();
    [ConditionalAttribute("JET_MODE_ASSERT")]
public static void EndActionUpdateOnUIThread();
    [ConditionalAttribute("JET_MODE_ASSERT")]
public static void CheckNotInUIUpdate();
    [ConditionalAttribute("JET_MODE_ASSERT")]
internal static void OnInterruption();
    [ConditionalAttribute("JET_MODE_ASSERT")]
internal static void OnReadLockReleased();
    [ConditionalAttribute("JET_MODE_ASSERT")]
internal static void ActivateCaptureStacks();
    [ConditionalAttribute("JET_MODE_ASSERT")]
internal static void OnWriteLockAcquired(UInt32 startTime);
}
public class JetBrains.Util.Concurrency.UnguardedCallbackMerger : object {
    private Lifetime myLifetime;
    private int myActiveExpectations;
    private BehaviorFlags myFlags;
    public ReentrancyGuard ReentrancyGuard;
    [GuardAttribute("-1")]
public bool IsExpectingUnguardedCallback { get; }
    [GuardAttribute("-1")]
public UnguardedCallbackMerger(Lifetime lifetime, ReentrancyGuard guard, BehaviorFlags flags);
    public bool get_IsExpectingUnguardedCallback();
    [GuardAttribute("-2")]
[ObsoleteAttribute("Use overload with lifetime.")]
public void ExecuteOrQueueOrMerge(string name, Action F);
    [GuardAttribute("-2")]
public bool ExecuteOrQueueOrMerge(Lifetime lifetimeQueue, string name, Action F);
    [GuardAttribute("1")]
public void ExpectUnguardedCallback(Action FNested);
}
internal class JetBrains.Util.Concurrency.UnixJetDispatcher : JetDispatcher {
    private static UInt32 FakeGeneration;
    private BlockingPriorityQueue`1<Closure> myPendingInvocationsQueue;
    private static Key`1<BlockingPriorityQueue`1<Closure>> QueueKey;
    [CompilerGeneratedAttribute]
private static Func`1<object> CS$<>9__CachedAnonymousMethodDelegate7;
    private static UnixJetDispatcher();
    public virtual IUserDataHolder GetThreadStaticData();
    public virtual void BeginInvoke(string name, Action action, TaskPriority priority);
    public virtual void BeginInvoke(Lifetime lifetime, string name, Action action, TaskPriority priority);
    public virtual void BeginOrInvoke(string name, Action action, TaskPriority priority);
    public virtual void BeginOrInvoke(Lifetime lifetime, string name, Action action, TaskPriority priority);
    public virtual void Invoke(string name, Action action, TaskPriority priority);
    private void BeginInvokeCore(Closure closure);
    [CompilerGeneratedAttribute]
private static object <BeginInvokeCore>b__5();
}
public class JetBrains.Util.Concurrency.WinJetDispatcher : JetDispatcher {
    private static TaskPriority MinPriorityValue;
    private static int OptionCallNativeMarshallerEveryItems;
    private static int OptionCallNativeMarshallerForFirstItems;
    private static Control myControlInstanceForStaticMethods;
    [CanBeNullAttribute]
private ExternalIdleProcessing myExternalIdleProcessing;
    private UInt32 modreq(System.Runtime.CompilerServices.IsVolatile) myGeneration;
    [NotNullAttribute]
private Dispatcher myMarshaller;
    private Func`2[] myPreTranslates;
    [NotNullAttribute]
private DispatcherPriorityBucket[] myPriorityBuckets;
    private static SpinWaitLock myQueueLock;
    [CompilerGeneratedAttribute]
private static Func`1<object> CS$<>9__CachedAnonymousMethodDelegate12;
    [CompilerGeneratedAttribute]
private static Func`2<TaskPriority, int> CS$<>9__CachedAnonymousMethodDelegate1d;
    [CompilerGeneratedAttribute]
private static Func`2<TaskPriority, int> CS$<>9__CachedAnonymousMethodDelegate1e;
    private static WinJetDispatcher();
    public virtual void BeginInvoke(string name, Action action, TaskPriority priority);
    public virtual void BeginInvoke(Lifetime lifetime, string name, Action action, TaskPriority priority);
    public virtual void BeginOrInvoke(string name, Action action, TaskPriority priority);
    public virtual void BeginOrInvoke(Lifetime lifetime, string name, Action action, TaskPriority priority);
    public virtual void Invoke(string name, Action action, TaskPriority priority);
    public void RegisterPreTranslate(Lifetime lifetime, Func`2<MSG, bool> pretranslate);
    [NotNullAttribute]
public OnIdle SetIdleProcessingExternalDriver(Lifetime lifetime, IDriver driver);
    private void BeginInvokeCore(Closure closure, bool isProbing);
    private void BeginInvokeCore_Overflow(int nQueueSize, int nItemsQueuedSinceLastExecution, Queue`1<Closure> queue, TaskPriority priority);
    [ConditionalAttribute("JET_MODE_ASSERT")]
private void Ctor_AssertPriorityBucketCount();
    private static DispatcherPriority GetNativeMarshallerPriority(TaskPriority taskpriority);
    public virtual IUserDataHolder GetThreadStaticData();
    private void Init();
    [HandleProcessCorruptedStateExceptionsAttribute]
private bool ProcessQueue(int nMinBucket);
    [CompilerGeneratedAttribute]
private static object <BeginInvokeCore_Overflow>b__7();
    [CompilerGeneratedAttribute]
private static int <Ctor_AssertPriorityBucketCount>b__1b(TaskPriority x);
    [CompilerGeneratedAttribute]
private static int <Ctor_AssertPriorityBucketCount>b__1c(TaskPriority x);
}
public class JetBrains.Util.CountingLogger : LoggerBase {
    private ILogger myLoggerForward;
    private int _nLogException;
    private int _nLogExceptionSilently;
    private int _nLogMessage;
    public int LoggedExceptionsSilent { get; }
    public int LoggedExceptionsLoud { get; }
    public int LoggedExceptionAnyKind { get; }
    public int LoggedMessages { get; }
    public bool IsWithAnyExceptions { get; }
    public bool IsWithLoudExceptions { get; }
    public bool IsWithSilentExceptions { get; }
    public CountingLogger(ILogger loggerForward);
    public virtual void Log(LogEvent logEvent);
    public virtual bool IsEnabled(LoggingLevel level);
    public int get_LoggedExceptionsSilent();
    public int get_LoggedExceptionsLoud();
    public int get_LoggedExceptionAnyKind();
    public int get_LoggedMessages();
    public bool get_IsWithAnyExceptions();
    public bool get_IsWithLoudExceptions();
    public bool get_IsWithSilentExceptions();
    public void ResetCounters();
}
public interface JetBrains.Util.DataFlow.ISignalOptionalFiring`1 {
    public bool IsAnyoneSinking { get; }
    public abstract virtual bool get_IsAnyoneSinking();
}
public class JetBrains.Util.DataFlow.Reasons`1 : object {
    private ICollectionEvents`1<T> myReasons;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private IProperty`1<bool> <AreEmpty>k__BackingField;
    public string Name { get; private set; }
    public IProperty`1<bool> AreEmpty { get; private set; }
    public Reasons`1(Lifetime lifetime, string name, ILogger logger, bool uniqueSuppressors);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public IProperty`1<bool> get_AreEmpty();
    [CompilerGeneratedAttribute]
private void set_AreEmpty(IProperty`1<bool> value);
    public void AddReason(Lifetime lifetime, T reason);
    [NotNullAttribute]
public IList`1<T> GetAllReasons();
}
public class JetBrains.Util.DataFlow.SignalOptionalFiring`1 : Signal`1<TValue> {
    private int mySinksCount;
    private bool JetBrains.Util.DataFlow.ISignalOptionalFiring<TValue>.IsAnyoneSinking { get; }
    public SignalOptionalFiring`1(string id);
    public SignalOptionalFiring`1(Lifetime lifetime, string id);
    protected virtual void OnAfterAdvise(Action`1<TValue> handler);
    protected virtual void OnAfterUnadvise(Action`1<TValue> handler);
    private sealed virtual override bool JetBrains.Util.DataFlow.ISignalOptionalFiring<TValue>.get_IsAnyoneSinking();
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Util.dataStructures.BidirectionalMapOnDictionary`2 : object {
    private Dictionary`2<TLeft, TRight> myLeftToRightMap;
    private Dictionary`2<TRight, TLeft> myRightToLeftMap;
    public int Count { get; }
    public ICollection`1<TLeft> LeftKeys { get; }
    public IDictionary`2<TLeft, TRight> LeftToRight { get; }
    public ICollection`1<TRight> RightKeys { get; }
    public IDictionary`2<TRight, TLeft> RightToLeft { get; }
    public TRight Item { get; }
    public TLeft Item { get; }
    public BidirectionalMapOnDictionary`2(int capacity);
    public BidirectionalMapOnDictionary`2(int capacity, IEqualityComparer`1<TLeft> leftComparer, IEqualityComparer`1<TRight> rightComparer);
    public BidirectionalMapOnDictionary`2(IEqualityComparer`1<TLeft> leftComparer, IEqualityComparer`1<TRight> rightComparer);
    public int get_Count();
    public ICollection`1<TLeft> get_LeftKeys();
    public IDictionary`2<TLeft, TRight> get_LeftToRight();
    public ICollection`1<TRight> get_RightKeys();
    public IDictionary`2<TRight, TLeft> get_RightToLeft();
    public TRight get_Item(TLeft left);
    public TLeft get_Item(TRight right);
    public void Add(TLeft left, TRight right);
    public void Clear();
    public bool ContainsLeft(TLeft left);
    public bool ContainsRight(TRight right);
    public sealed virtual IEnumerator GetEnumerator();
    public TLeft GetLeftByRight(TRight right);
    public TRight GetRightByLeft(TLeft left);
    public void RemoveLeft(TLeft left);
    public void RemoveMapping(TLeft left, TRight right);
    public void RemoveRight(TRight right);
    public bool SetMapping(TLeft left, TRight right, bool bIgnoreConflicts);
    public bool TryGetLeftByRight(TRight right, TLeft& left);
    public bool TryGetRightByLeft(TLeft left, TRight& right);
    public TLeft GetOrCreateLeftByRight(TRight right, Func`2<TRight, TLeft> factory);
    public TRight GetOrCreateRightByLeft(TLeft left, Func`2<TLeft, TRight> factory);
    private static ArgumentException CreateDuplicateLeftKeysException(TLeft left, TRight right, TRight oldRight);
    private static ArgumentException CreateDuplicateRightKeysException(TLeft left, TRight right, TLeft oldLeft);
    private sealed virtual override IEnumerator`1<KeyValuePair`2<TLeft, TRight>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TLeft,TRight>>.GetEnumerator();
}
public class JetBrains.Util.dataStructures.ByteBuffer : ValueType {
    public Byte* Data;
    public UInt32 Length;
    public ByteBuffer(Byte* data, UInt32 length);
    public virtual string ToString();
}
[ExtensionAttribute]
public static class JetBrains.Util.dataStructures.ByteBufferEx : object {
    [NotNullAttribute]
[ExtensionAttribute]
public static Byte[] ToArray(ByteBuffer buffer);
    [ExtensionAttribute]
[NotNullAttribute]
public static UnmanagedMemoryStream ToStream(ByteBuffer buffer);
}
public class JetBrains.Util.dataStructures.ChunkedMemoryStream : Stream {
    public static int DefaultChunkSize;
    private ChunkList`1<Byte[]> myBuffers;
    private int myCachedCurrentBuffer_Index;
    private Byte[] myCachedCurrentBuffer_Value;
    private int myCurrentBufferIndex;
    private int myCurrentBufferOffset;
    private static long myCurrentGuid;
    private ulong myGuid;
    private long myLengthIncludingStartOffset;
    private long myPositionIncludingStartOffset;
    private long myStartOffset;
    private StateFlags myStateFlags;
    [CompilerGeneratedAttribute]
private static Func`3<long, Byte[], long> CS$<>9__CachedAnonymousMethodDelegate5;
    [CompilerGeneratedAttribute]
private static Func`2<Byte[], bool> CS$<>9__CachedAnonymousMethodDelegatef;
    [CompilerGeneratedAttribute]
private static Func`2<Byte[], bool> CS$<>9__CachedAnonymousMethodDelegate11;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public ulong Guid { get; }
    public long Length { get; }
    public long Position { get; public set; }
    private bool JetBrains.Util.Collections.IFreezable.IsFrozen { get; }
    private ChunkedMemoryStream(ChunkList`1<Byte[]> buffers, long offset, long count, StateFlags stateflags, ulong qwGuid);
    public ChunkedMemoryStream(Stream streamToCopy);
    private static ChunkedMemoryStream();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public ulong get_Guid();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public static ChunkedMemoryStream CreateOnUserBuffers(IEnumerable`1<Byte[]> buffers, int offset, int count);
    public static ChunkedMemoryStream CreateOnUserBuffers(Byte[][] buffers);
    public static ChunkedMemoryStream CreateOnUserBuffersGuaranteedImmutable(IEnumerable`1<Byte[]> buffers, int offset, int count);
    public static ChunkedMemoryStream CreateOnUserBuffersGuaranteedImmutable(Byte[][] buffers);
    public virtual void Flush();
    [NotNullAttribute]
public ChunkedMemoryStream Freeze();
    public IEnumerable`1<Byte[]> GetBuffers();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    [NotNullAttribute]
public ChunkedMemoryStream ShallowClone();
    [NotNullAttribute]
public Byte[][] ToArray();
    public void TrimExcess();
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte value);
    private void AllocateBuffersStrategy(long lCurrentCapacity, long lDesiredCapacity);
    private void AssertWritable();
    private sealed virtual override void JetBrains.Util.Collections.IFreezable.Freeze();
    private void GetBufferAndOffsetOfPosition(long lPositionIncludingStartOffset, Int32& nBufferIndex, Int32& nCurrentBufferOffset);
    private sealed virtual override bool JetBrains.Util.Collections.IFreezable.get_IsFrozen();
    private long SeekCore(long offset, SeekOrigin origin);
    private void SetLengthCore(long value, bool isForWriting);
    private void SetLengthCore_Wipe(int nOldLastUsedBuffer, int nOldCurrentBufferOffset, int nNewLastUsedBuffer, int nNewCurrentBufferOffset);
    private void TruncateBuffersStrategy(int nLastUsedBuffer);
    private long TryGetBufferAndOffsetOfPosition(long lPositionIncludingStartOffset, Int32& nBufferIndex, Int32& nCurrentBufferOffset);
    private void Write_SlowTrack(Byte[] buffer, int offset, int count);
    [CompilerGeneratedAttribute]
private static long <.ctor>b__0(long acc, Byte[] buffer);
    [CompilerGeneratedAttribute]
private static bool <CreateOnUserBuffers>b__e(Byte[] buffer);
    [CompilerGeneratedAttribute]
private static bool <CreateOnUserBuffersGuaranteedImmutable>b__10(Byte[] buffer);
    [CompilerGeneratedAttribute]
private object <SeekCore>b__1f();
    [CompilerGeneratedAttribute]
private object <SeekCore>b__20();
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Util.DataStructures.ChunkList`1 : object {
    public static int InitialCapacity;
    private int myChunkSize;
    private int myCount;
    private T[][] myChunks;
    public int ChunkSize { get; }
    public T Item { get; public set; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public int Capacity { get; }
    public ChunkList`1(IEnumerable`1<T> items);
    public ChunkList`1(ChunkList`1<T> items);
    private ChunkList`1(IEnumerable`1<T> items, int chunkSize);
    public ChunkList`1(int initialSize);
    public static ChunkList`1<T> CreateWithChunkSize(int chunkSize);
    public virtual int get_ChunkSize();
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    public void Compact();
    public sealed virtual void Clear();
    public void ClearDontCompact();
    public int Add(T item);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    public void CopyTo(int srcIndex, T[] dst, int dstIndex, int length);
    private void ProvideSpaceFor(int nItems);
    public int BinarySearch(Func`2<T, int> comparer);
    public void Sort(Func`3<T, T, int> comparer);
    private void QuickSort(int left, int right, Func`3<T, T, int> comparer);
    private void Swap(int i, int j);
    public Enumerator<T> GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual bool Remove(T item);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public void RemoveRange(ICollection`1<T> toRemove);
    public sealed virtual int IndexOf(T item);
    public sealed virtual void Insert(int index, T item);
    public sealed virtual void RemoveAt(int index);
    public void RemoveRange(int index, int count);
    public int get_Capacity();
}
public class JetBrains.Util.DataStructures.CollectionReadOnlyException : NotSupportedException {
    public CollectionReadOnlyException(SerializationInfo info, StreamingContext context);
    public CollectionReadOnlyException(string message, Exception innerException);
    public CollectionReadOnlyException(string message);
}
public class JetBrains.Util.DataStructures.CompactMap`2 : CompactMapBase`4<TKey, TValue, CompactMapStorage`2<TKey, TValue>, object> {
    public CompactMap`2(IEqualityComparer`1<TKey> equalityComparer);
    public CompactMap`2(int initialSlotCount);
    public CompactMap`2(int initialSlotCount, IEqualityComparer`1<TKey> equalityComparer);
    public CompactMap`2(int intialSlotCount, double maxLoadFactor, IEqualityComparer`1<TKey> equalityComparer);
    public CompactMap`2(IDictionary`2<TKey, TValue> dictionary);
    public CompactMap`2(IDictionary`2<TKey, TValue> dictionary, IEqualityComparer`1<TKey> comparer);
    protected virtual CompactMapStorage`2<TKey, TValue> CreateStorage(int slotCount);
    protected virtual SlotState<TKey, TValue, CompactMapStorage`2<TKey, TValue>, object> GetSlotState(CompactMapStorage`2<TKey, TValue> storage, int index, TKey& key);
    protected virtual object GetSlotData(CompactMapStorage`2<TKey, TValue> storage, int index);
    protected virtual TValue GetValue(CompactMapStorage`2<TKey, TValue> storage, int index, object data);
    protected virtual void SetValue(CompactMapStorage`2<TKey, TValue> storage, int index, TValue value);
    protected virtual void SetKeyAndValue(CompactMapStorage`2<TKey, TValue> storage, int index, TKey key, TValue value);
    protected virtual void RemoveValue(CompactMapStorage`2<TKey, TValue> storage, int index);
    protected virtual void ClearStorage(CompactMapStorage`2<TKey, TValue> storage);
}
[DefaultMemberAttribute("Item")]
public abstract class JetBrains.Util.DataStructures.CompactMapBase`4 : object {
    public static double DEFAULT_MAX_LOAD_FACTOR;
    public static int DEFAULT_INITIAL_SLOT_COUNT;
    public static int CLEAR_STORAGE_THRESHOLD;
    private double myMaxLoadFactor;
    private IEqualityComparer`1<TKey> myEqualityComparer;
    private TStorage myStorage;
    private int mySlotCount;
    private int myCount;
    private int myRemovedCount;
    private int myVersion;
    private MyKeyCollection<TKey, TValue, TStorage, TData> myKeyCollection;
    private MyValueCollection<TKey, TValue, TStorage, TData> myValueCollection;
    private bool myShouldValidateKey;
    public IEqualityComparer`1<TKey> EqualityComparer { get; }
    public double MaxLoadFactor { get; }
    public int SlotCount { get; }
    public int Count { get; }
    public TValue Item { get; public set; }
    public ICollection`1<TKey> Keys { get; }
    private IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Keys { get; }
    public ICollection`1<TValue> Values { get; }
    private IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Values { get; }
    private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.IsReadOnly { get; }
    protected CompactMapBase`4(int intialSlotCount, double maxLoadFactor, IEqualityComparer`1<TKey> equalityComparer, bool shouldValidateKey);
    protected void InitStorage();
    private void ValidateKey(TKey key);
    protected virtual void DoValidateKey(TKey key);
    public IEqualityComparer`1<TKey> get_EqualityComparer();
    protected abstract virtual TStorage CreateStorage(int slotCount);
    protected abstract virtual TValue GetValue(TStorage storage, int index, TData data);
    protected abstract virtual void SetValue(TStorage storage, int index, TValue value);
    protected abstract virtual void SetKeyAndValue(TStorage storage, int index, TKey key, TValue value);
    protected abstract virtual void RemoveValue(TStorage storage, int index);
    protected abstract virtual void ClearStorage(TStorage storage);
    protected abstract virtual SlotState<TKey, TValue, TStorage, TData> GetSlotState(TStorage storage, int index, TKey& key);
    protected abstract virtual TData GetSlotData(TStorage storage, int index);
    public double get_MaxLoadFactor();
    public int get_SlotCount();
    public sealed virtual int get_Count();
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    public sealed virtual void Add(TKey key, TValue value);
    private void Insert(TKey key, TValue value, bool addNew);
    public sealed virtual bool Remove(TKey key);
    public sealed virtual bool ContainsKey(TKey key);
    public sealed virtual void Clear();
    public sealed virtual ICollection`1<TKey> get_Keys();
    private sealed virtual override IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Keys();
    public sealed virtual ICollection`1<TValue> get_Values();
    private sealed virtual override IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Values();
    private int Index(TKey key);
    private int InsertionIndex(TKey key);
    private int ProbeDistance(int hash);
    private void Grow();
    public void Compact();
    private void Resize(int newSlotCount);
    private bool IsAlmostFull();
    public IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    private sealed virtual override IEnumerator`1<KeyValuePair`2<TKey, TValue>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TValue>>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Contains(KeyValuePair`2<TKey, TValue> item);
    private bool Contains(KeyValuePair`2<TKey, TValue> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Add(KeyValuePair`2<TKey, TValue> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.CopyTo(KeyValuePair`2[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Remove(KeyValuePair`2<TKey, TValue> item);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.get_IsReadOnly();
    private static void CopyTo(IEnumerable`1<T> collection, T[] array, int index);
    public void DumpStatistics();
}
public class JetBrains.Util.DataStructures.CompactMapStorage`2 : ValueType {
    public ChunkList`1<TKey> Keys;
    public ChunkList`1<TValue> Values;
    public ChunkList`1<int> SlotStates;
    public CompactMapStorage`2(int length);
    public int GetSlotState(int index);
    public void SetSlotState(int index, int state);
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Util.DataStructures.CompactOneToListMap`2 : object {
    private static string ValuesInMap;
    private static string ValuesInLists;
    private CompactMap`2<TKey, IList`1<TValue>> myListMap;
    private CompactMap`2<TKey, TValue> myValueMap;
    public int Count { get; }
    public ICollection`1<TKey> Keys { get; }
    public IList`1<TValue> AllValues { get; }
    public IList`1<TValue> Item { get; }
    public CompactOneToListMap`2(IEqualityComparer`1<TKey> equalityComparer);
    public CompactOneToListMap`2(int capacity, IEqualityComparer`1<TKey> equalityComparer);
    public int get_Count();
    public void Clear();
    public ICollection`1<TKey> get_Keys();
    public IList`1<TValue> get_AllValues();
    public IList`1<TValue> get_Item(TKey key);
    public IList`1<TValue> GetValuesSafe(TKey key);
    public void InsertValue(TKey key, TValue value, int index);
    public int CountForKey(TKey key);
    public void AddValue(TKey key, TValue value);
    public void AddValueRange(TKey key, IEnumerable`1<TValue> values);
    public void RemoveValue(TKey key, TValue value);
    public void ReplaceValue(TKey key, TValue oldValue, TValue newValue);
    public void RemoveKey(TKey key);
    public bool ContainsKey(TKey key);
    public bool ContainsValue(TValue value);
    public bool ContainsPair(TKey key, TValue value);
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, IList`1<TValue>>> GetEnumerator();
    public void ProcessMap(Action`2<TKey, IList`1<TValue>> listProcessor, Action`2<TKey, TValue> singletonsProcessor);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public void Compact();
    public void RemoveValues(TKey key, ICollection`1<TValue> valuesToRemove);
    public IEnumerable`1<TValue> EnumerateValues(TKey key);
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Util.DataStructures.CompactOneToSetMap`2 : object {
    private CompactMap`2<TKey, CompactSet`1<TValue>> myInnerMap;
    public int Count { get; }
    public ICollection`1<TKey> Keys { get; }
    public IList`1<TValue> AllValues { get; }
    public CompactSet`1<TValue> Item { get; }
    public CompactOneToSetMap`2(int count, IEqualityComparer`1<TKey> comparer);
    public int get_Count();
    public void Clear();
    public ICollection`1<TKey> get_Keys();
    public IList`1<TValue> get_AllValues();
    public CompactSet`1<TValue> get_Item(TKey key);
    public CompactSet`1<TValue> GetValuesSafe(TKey key);
    public void Add(TKey key, TValue value);
    public void Remove(TKey key, TValue value);
    public void RemoveKey(TKey key);
    public bool ContainsKey(TKey key);
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, CompactSet`1<TValue>>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class JetBrains.Util.DataStructures.CompactSet`1 : object {
    private NoValueMap<T> myMap;
    public static CompactSet`1<T> Empty;
    public IEqualityComparer`1<T> EqualityComparer { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public CompactSet`1(IEqualityComparer`1<T> comparer);
    public CompactSet`1(int intialSlotCount, double maxLoadFactor, IEqualityComparer`1<T> comparer);
    private static CompactSet`1();
    public IEqualityComparer`1<T> get_EqualityComparer();
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    private static void CopyTo(IEnumerable`1<U> collection, U[] array, int index);
    public sealed virtual bool Remove(T item);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Util.dataStructures.FrugalLocalList`1 : ValueType {
    public static int LocalItemsCount;
    internal static TItem NULL;
    private static IEqualityComparer`1<TItem> ourComparer;
    private TItem myItem0;
    private TItem myItem1;
    private List`1<TItem> myItemsTail;
    public int Count { get; }
    public int Length { get; }
    public bool HasMultiple { get; }
    public bool IsEmpty { get; }
    public bool IsReadOnly { get; }
    public bool IsSingle { get; }
    [NotNullAttribute]
public TItem Item { get; public set; }
    public FrugalLocalList`1(FrugalLocalList`1<TItem> items);
    public FrugalLocalList`1(IEnumerable`1<TItem> items);
    public FrugalLocalList`1(ICollection`1<TItem> items);
    public FrugalLocalList`1(FrugalLocalHashSet`1<TItem> items);
    public FrugalLocalList`1(int capacity);
    private static FrugalLocalList`1();
    [PureAttribute]
public int get_Count();
    [PureAttribute]
public int get_Length();
    [PureAttribute]
public bool get_HasMultiple();
    [PureAttribute]
public bool get_IsEmpty();
    [PureAttribute]
public bool get_IsReadOnly();
    [PureAttribute]
public bool get_IsSingle();
    [PureAttribute]
public TItem get_Item(int index);
    public void set_Item(int index, TItem value);
    public void Add(TItem item);
    public void PrependRange(FrugalLocalList`1<TItem> list);
    public void AddRange(FrugalLocalList`1<TItem> list);
    public void AddRange(LocalList`1<TItem> list);
    public void AddRange(TItem[] list);
    public void AddRange(IEnumerable`1<TItem> list);
    [PureAttribute]
[NotNullAttribute]
public IEnumerable`1<TItem> AsEnumerable();
    [NotNullAttribute]
[PureAttribute]
public IList`1<TItem> AsIList();
    [PureAttribute]
[NotNullAttribute]
public IReadOnlyList`1<TItem> AsIReadonlyList();
    public void Clear();
    public void ClearKeepingTail();
    [PureAttribute]
public FrugalLocalList`1<TItem> Clone();
    [PureAttribute]
public bool Contains(TItem item);
    [PureAttribute]
public void CopyTo(TItem[] array, int arrayIndex);
    [PureAttribute]
public TItem First();
    [PureAttribute]
public TItem Last();
    [PureAttribute]
public TItem FirstOrDefault();
    [PureAttribute]
public TItem LastOrDefault();
    [PureAttribute]
[NotNullAttribute]
public TItem FirstOrDefault(TClosure closure, Func`3<TClosure, TItem, bool> predicate);
    [PureAttribute]
public FrugalLocalListEnumerator`1<TItem> GetEnumerator();
    [PureAttribute]
public int IndexOf(TItem item);
    public static FrugalLocalList`1<TItem> Init(TItem item);
    public void Insert(int index, TItem item);
    [PureAttribute]
public bool IsNullOrEmpty();
    [PureAttribute]
public int LastIndexOf(TItem item);
    [PureAttribute]
public int LastIndexOf(TItem item, IEqualityComparer`1<TItem> comparer);
    public bool Remove(TItem item);
    public void RemoveAt(int index);
    [PureAttribute]
[NotNullAttribute]
public TItem Single();
    [PureAttribute]
[NotNullAttribute]
public TItem[] ToArray();
    [NotNullAttribute]
[PureAttribute]
public List`1<TItem> ToList();
}
[DefaultMemberAttribute("Item")]
internal class JetBrains.Util.dataStructures.FrugalLocalListAsIList`1 : object {
    private FrugalLocalList`1<TItem> myList;
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<TItem>.IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    public TItem Item { get; public set; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public FrugalLocalListAsIList`1(FrugalLocalList`1& list);
    private sealed virtual override void System.Collections.Generic.ICollection<TItem>.Add(TItem item);
    private sealed virtual override void System.Collections.Generic.ICollection<TItem>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<TItem>.Contains(TItem item);
    private sealed virtual override void System.Collections.Generic.ICollection<TItem>.CopyTo(TItem[] array, int arrayIndex);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public sealed virtual int get_Count();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IEnumerator`1<TItem> System.Collections.Generic.IEnumerable<TItem>.GetEnumerator();
    private sealed virtual override int System.Collections.Generic.IList<TItem>.IndexOf(TItem item);
    private sealed virtual override void System.Collections.Generic.IList<TItem>.Insert(int index, TItem item);
    private sealed virtual override bool System.Collections.Generic.ICollection<TItem>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    public sealed virtual TItem get_Item(int index);
    public sealed virtual void set_Item(int index, TItem value);
    private sealed virtual override bool System.Collections.Generic.ICollection<TItem>.Remove(TItem item);
    private sealed virtual override void System.Collections.Generic.IList<TItem>.RemoveAt(int index);
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
}
public class JetBrains.Util.dataStructures.FrugalLocalListEnumerator`1 : ValueType {
    private int myCount;
    private TItem myCurrent;
    private int myIndex;
    private FrugalLocalList`1<TItem> myList;
    public TItem Current { get; }
    internal FrugalLocalListEnumerator`1(FrugalLocalList`1& list);
    public TItem get_Current();
    public bool MoveNext();
}
[ExtensionAttribute]
public static class JetBrains.Util.dataStructures.FrugalLocalListEx : object {
    private static OnError DefaultOnError;
    private static FrugalLocalListEx();
    [ExtensionAttribute]
public static void AddRange(ICollection`1<TTarget> to, FrugalLocalList`1<TSource> from);
    [PureAttribute]
[ExtensionAttribute]
public static FrugalLocalList`1<TItem> ConcatWith(FrugalLocalList`1<TItem> thіs, TItem item);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void ForEach(FrugalLocalList`1<TItem> thіs, TClosure closure, Action`2<TClosure, TItem> action);
    [PureAttribute]
[ExtensionAttribute]
public static bool HasMultiple(FrugalLocalList`1<TItem> thіs);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static bool IsEmpty(FrugalLocalList`1<T> collection);
    [StringFormatMethodAttribute("sContextSentence")]
[ExtensionAttribute]
public static TSource SingleOrFirstErr(FrugalLocalList`1<TSource> source, string sContextSentence, object arg1, object arg2, object arg3, object arg4);
    [StringFormatMethodAttribute("sContextSentence")]
[ExtensionAttribute]
public static TSource SingleOrFirstOrDefaultErr(FrugalLocalList`1<TSource> source, string sContextSentence, object arg1, object arg2, object arg3, object arg4);
}
public class JetBrains.Util.DataStructures.MergedCollection`1 : object {
    private List`1<ICollection`1<T>> myCollections;
    [CompilerGeneratedAttribute]
private static Func`3<int, ICollection`1<T>, int> CS$<>9__CachedAnonymousMethodDelegate5;
    [CompilerGeneratedAttribute]
private static Func`2<ICollection`1<T>, IEnumerable`1<T>> CS$<>9__CachedAnonymousMethodDelegate7;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public MergedCollection`1(IEnumerable`1<ICollection`1<T>> collections);
    public MergedCollection`1(ICollection`1<T> collection1, ICollection`1<T> collection2);
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Remove(T item);
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [CompilerGeneratedAttribute]
private static int <get_Count>b__4(int x, ICollection`1<T> collection);
    [CompilerGeneratedAttribute]
private static IEnumerable`1<T> <GetEnumerator>b__6(ICollection`1<T> collection);
}
public enum JetBrains.Util.dataStructures.OfEqualItems : Enum {
    public int value__;
    public static OfEqualItems TakeAny;
    public static OfEqualItems TakeFirst;
    public static OfEqualItems TakeLast;
}
public class JetBrains.Util.DataStructures.PrimeFinder : object {
    private static Int32[] ourPrimeCapacities;
    public static Int32[] Table;
    private static PrimeFinder();
    public static int NextPrime(int desiredCapacity);
    public static int MaxPrime();
}
public class JetBrains.Util.dataStructures.RandomAccessViewOnSequentialStream : Stream {
    private ChunkedMemoryStream myCache;
    private Byte[] myCopyBuffer;
    private Nullable`1<long> myCustomLength;
    private long myPosition;
    private Stream mySequentialStream;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public RandomAccessViewOnSequentialStream(Stream sequentialstream, Nullable`1<long> customlength);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    private void PumpIntoCache(Int32& count);
}
public class JetBrains.Util.dataStructures.RawCircularBufferHeader : ValueType {
    public static UInt32 BufferHeaderSize;
    public UsedBlock BlockHead;
    public UsedBlock BlockTail;
    public UInt32 TotalSize;
    public UInt32 FreeSpace { get; }
    public UInt32 MaxDataSize { get; }
    public RawCircularBufferHeader(UInt32 nTotalSize);
    private static RawCircularBufferHeader();
    public UInt32 get_FreeSpace();
    public UInt32 get_MaxDataSize();
    public static bool IsEmpty(RawCircularBufferHeader* pBufferHeader);
    public static bool TryReadMessage(RawCircularBufferHeader* pBufferHeader, Action`1<ByteBuffer> FWithBuffer);
    [CanBeNullAttribute]
public static Byte[] TryReadMessage(RawCircularBufferHeader* pBufferHeader);
    public static bool TryWriteMessage(RawCircularBufferHeader* pBufferHeader, Byte[] data);
    public void AssertValid();
    private UInt32 GetFreeSpaceCore(UInt32 nReallocHeadToHouseThisSize);
}
public class JetBrains.Util.DataStructures.ReadOnlyException : Exception {
    public ReadOnlyException(SerializationInfo info, StreamingContext context);
    public ReadOnlyException(string message, Exception innerException);
    public ReadOnlyException(string message);
}
public class JetBrains.Util.dataStructures.Sources.ByteArrayUtf16leStringSourceOwner : object {
    public static IStringSourceOwner Instance;
    private static ByteArrayUtf16leStringSourceOwner();
    public static StringSource Create(Byte[] array, UInt32 cbstart, UInt32 cblength);
    public virtual string ToString();
    private sealed virtual override StringSource JetBrains.Util.dataStructures.Sources.IStringSourceOwner.AsManagedStringSource(StringSource& ss);
    private sealed virtual override TResult JetBrains.Util.dataStructures.Sources.IStringSourceOwner.Fixed(StringSource& ss, TContext context, StringSourceFixedDelegate`2<TContext, TResult> λ);
    private sealed virtual override char JetBrains.Util.dataStructures.Sources.IStringSourceOwner.GetCharAt(StringSource& ss, UInt32 index);
    private sealed virtual override UInt32 JetBrains.Util.dataStructures.Sources.IStringSourceOwner.GetLength(StringSource& ss);
    private sealed virtual override bool JetBrains.Util.dataStructures.Sources.IStringSourceOwner.IsEmpty(StringSource& ss);
    private sealed virtual override StringSource JetBrains.Util.dataStructures.Sources.IStringSourceOwner.Substring(StringSource& ss, UInt32 start, UInt32 length);
    private sealed virtual override string JetBrains.Util.dataStructures.Sources.IStringSourceOwner.ToRuntimeString(StringSource& ss);
}
[DebuggerTypeProxyAttribute("JetBrains.Util.dataStructures.Sources.CollectionSourceDebugView`1")]
public class JetBrains.Util.dataStructures.Sources.CollectionSource`1 : ValueType {
    public static CollectionSource`1<TItem> Empty;
    private ICollectionSourceOwner`1<TItem> myOwner;
    public CollectionSourcePodData DataPod;
    public object DataRefX;
    public int Count { get; }
    public bool IsFastCount { get; }
    public ICollectionSourceOwner`1<TItem> Owner { get; }
    public CollectionSource`1(ICollectionSourceOwner`1<TItem> owner, object dataRefX, object dataRefY, CollectionSourcePodData dataPod);
    private static CollectionSource`1();
    [PureAttribute]
[NotNullAttribute]
public int get_Count();
    [NotNullAttribute]
[PureAttribute]
public bool get_IsFastCount();
    [PureAttribute]
[NotNullAttribute]
public ICollectionSourceOwner`1<TItem> get_Owner();
    public static CollectionSource`1<TItem> FromCollection(ICollection`1<TItem> collection);
    [PureAttribute]
public Enumerator<TItem> GetEnumerator();
    [NotNullAttribute]
[PureAttribute]
public TItem[] ToArray();
    [PureAttribute]
[NotNullAttribute]
public ICollection`1<TItem> ToCollection();
    [NotNullAttribute]
[PureAttribute]
public IEnumerable`1<TItem> ToEnumerable();
    [PureAttribute]
public virtual string ToString();
}
internal class JetBrains.Util.dataStructures.Sources.CollectionSourceDebugView`1 : object {
    private CollectionSource`1<TItem> myTarget;
    [NotNullAttribute]
[DebuggerBrowsableAttribute("3")]
public TItem[] Items { get; }
    public CollectionSourceDebugView`1(CollectionSource`1<TItem> target);
    public TItem[] get_Items();
}
[ExtensionAttribute]
public static class JetBrains.Util.dataStructures.Sources.CollectionSourceEx : object {
    [ExtensionAttribute]
public static void AddRange(ICollection`1<TItem> target, CollectionSource`1<TItem> source);
    [ExtensionAttribute]
public static CollectionSource`1<TItem> AsCollectionSource(ICollection`1<TItem> thіs);
    [ExtensionAttribute]
public static CollectionSource`1<TItem> AsEnumCollectionSource(IEnumerable`1<TItem> thіs);
    [ExtensionAttribute]
public static int Count(CollectionSource`1<TItem> thіs);
    [ExtensionAttribute]
public static TItem First(CollectionSource`1<TItem> thіs);
    [ExtensionAttribute]
public static TItem FirstOrDefault(CollectionSource`1<TItem> thіs);
    [ExtensionAttribute]
public static TItem GetItemAt(CollectionSource`1<TItem> thіs, UInt32 index);
    [ExtensionAttribute]
public static bool HasMultiple(CollectionSource`1<TItem> thіs);
    [ExtensionAttribute]
public static bool IsEmpty(CollectionSource`1<TItem> thіs);
    [ExtensionAttribute]
public static bool IsSingle(CollectionSource`1<TItem> thіs);
    [ExtensionAttribute]
public static bool SequenceEqual(CollectionSource`1<TSource> first, CollectionSource`1<TSource> second, IEqualityComparer`1<TSource> comparer);
    [ExtensionAttribute]
public static bool SequenceEqual(CollectionSource`1<TSource> first, IEnumerable`1<TSource> second, IEqualityComparer`1<TSource> comparer);
    [ExtensionAttribute]
public static TItem Single(CollectionSource`1<TItem> thіs, string errmsg);
    [NotNullAttribute]
[ExtensionAttribute]
public static JetHashSet`1<TItem> ToJetHashSet(CollectionSource`1<TItem> thіs);
    public static int GetHashCode(CollectionSource`1<T> array);
}
public static class JetBrains.Util.dataStructures.Sources.CollectionSourceOwnerHelpers : object {
    public static UInt32 GetCountViaEnumeration(CollectionSource`1& instance);
    [NotNullAttribute]
public static TItem[] ToArrayViaEnumeration(CollectionSource`1& instance);
    [NotNullAttribute]
public static IEnumerable`1<TItem> ToEnumerableViaEnumeration(CollectionSource`1& instance);
    [NotNullAttribute]
public static IList`1<TItem> ToListViaEnumeration(CollectionSource`1& instance);
}
public class JetBrains.Util.dataStructures.Sources.CollectionSourcePodData : ValueType {
}
public class JetBrains.Util.dataStructures.Sources.EmptyCollectionSourceOwner`1 : object {
    public static EmptyCollectionSourceOwner`1<TItem> Instance;
    private static EmptyCollectionSourceOwner`1();
    public sealed virtual IEnumerable`1<TItem> ToEnumerable(CollectionSource`1& instance);
    private sealed virtual override void JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<TItem>.EnumeratorDispose(Enumerator& instance);
    private sealed virtual override TItem JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<TItem>.EnumeratorGetCurrent(Enumerator& instance);
    private sealed virtual override bool JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<TItem>.EnumeratorMoveNext(Enumerator& instance);
    private sealed virtual override UInt32 JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<TItem>.GetCount(CollectionSource`1& instance);
    private sealed virtual override Enumerator<TItem> JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<TItem>.GetEnumerator(CollectionSource`1& instance);
    private sealed virtual override bool JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<TItem>.GetIsFastCount(CollectionSource`1& instance);
    private sealed virtual override TItem[] JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<TItem>.ToArray(CollectionSource`1& instance);
    private sealed virtual override ICollection`1<TItem> JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<TItem>.ToCollection(CollectionSource`1& instance);
    private sealed virtual override string JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<TItem>.ToString(CollectionSource`1& instance);
}
public class JetBrains.Util.dataStructures.Sources.EmptyStringSourceOwner : object {
    public static IStringSourceOwner Instance;
    private static EmptyStringSourceOwner();
    public sealed virtual TResult Fixed(StringSource& ss, TContext context, StringSourceFixedDelegate`2<TContext, TResult> λ);
    public sealed virtual char GetCharAt(StringSource& ss, UInt32 index);
    public sealed virtual UInt32 GetLength(StringSource& ss);
    public sealed virtual bool IsEmpty(StringSource& ss);
    public sealed virtual StringSource Substring(StringSource& ss, UInt32 start, UInt32 length);
    public sealed virtual string ToRuntimeString(StringSource& ss);
    private sealed virtual override StringSource JetBrains.Util.dataStructures.Sources.IStringSourceOwner.AsManagedStringSource(StringSource& ss);
}
public interface JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner`1 {
    public abstract virtual void EnumeratorDispose(Enumerator& instance);
    public abstract virtual TItem EnumeratorGetCurrent(Enumerator& instance);
    public abstract virtual bool EnumeratorMoveNext(Enumerator& instance);
    public abstract virtual UInt32 GetCount(CollectionSource`1& instance);
    public abstract virtual Enumerator<TItem> GetEnumerator(CollectionSource`1& instance);
    public abstract virtual bool GetIsFastCount(CollectionSource`1& instance);
    public abstract virtual TItem[] ToArray(CollectionSource`1& instance);
    public abstract virtual ICollection`1<TItem> ToCollection(CollectionSource`1& instance);
    public abstract virtual IEnumerable`1<TItem> ToEnumerable(CollectionSource`1& instance);
    public abstract virtual string ToString(CollectionSource`1& instance);
}
public interface JetBrains.Util.dataStructures.Sources.IStringSourceOwner {
    public abstract virtual StringSource AsManagedStringSource(StringSource& ss);
    public abstract virtual TResult Fixed(StringSource& ss, TContext context, StringSourceFixedDelegate`2<TContext, TResult> λ);
    public abstract virtual char GetCharAt(StringSource& ss, UInt32 index);
    public abstract virtual UInt32 GetLength(StringSource& ss);
    public abstract virtual bool IsEmpty(StringSource& ss);
    public abstract virtual StringSource Substring(StringSource& ss, UInt32 start, UInt32 length);
    [NotNullAttribute]
public abstract virtual string ToRuntimeString(StringSource& ss);
}
public class JetBrains.Util.dataStructures.Sources.LiveEnumerableCollectionSourceOwner`1 : object {
    public static LiveEnumerableCollectionSourceOwner`1<TItem> Instance;
    private static LiveEnumerableCollectionSourceOwner`1();
    public sealed virtual bool GetIsFastCount(CollectionSource`1& instance);
    public sealed virtual TItem[] ToArray(CollectionSource`1& instance);
    public sealed virtual IEnumerable`1<TItem> ToEnumerable(CollectionSource`1& instance);
    private sealed virtual override void JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<TItem>.EnumeratorDispose(Enumerator& instance);
    private sealed virtual override TItem JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<TItem>.EnumeratorGetCurrent(Enumerator& instance);
    private sealed virtual override bool JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<TItem>.EnumeratorMoveNext(Enumerator& instance);
    private sealed virtual override UInt32 JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<TItem>.GetCount(CollectionSource`1& instance);
    private sealed virtual override Enumerator<TItem> JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<TItem>.GetEnumerator(CollectionSource`1& instance);
    private sealed virtual override ICollection`1<TItem> JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<TItem>.ToCollection(CollectionSource`1& instance);
    private sealed virtual override string JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<TItem>.ToString(CollectionSource`1& instance);
}
public class JetBrains.Util.dataStructures.Sources.NativeStringSourceOwner : object {
    public static IStringSourceOwner Instance;
    private static NativeStringSourceOwner();
    public static StringSource Create(Lifetime lifetime, Char* pch, UInt32 length);
    public static StringSource CreateWithoutLifetime(Char* pch, UInt32 length);
    private sealed virtual override StringSource JetBrains.Util.dataStructures.Sources.IStringSourceOwner.AsManagedStringSource(StringSource& ss);
    private sealed virtual override TResult JetBrains.Util.dataStructures.Sources.IStringSourceOwner.Fixed(StringSource& ss, TContext context, StringSourceFixedDelegate`2<TContext, TResult> λ);
    private sealed virtual override char JetBrains.Util.dataStructures.Sources.IStringSourceOwner.GetCharAt(StringSource& ss, UInt32 index);
    private sealed virtual override UInt32 JetBrains.Util.dataStructures.Sources.IStringSourceOwner.GetLength(StringSource& ss);
    private static void GetValidatedData(StringSource& ss, PodData& data);
    private sealed virtual override bool JetBrains.Util.dataStructures.Sources.IStringSourceOwner.IsEmpty(StringSource& ss);
    private sealed virtual override StringSource JetBrains.Util.dataStructures.Sources.IStringSourceOwner.Substring(StringSource& ss, UInt32 start, UInt32 length);
    private sealed virtual override string JetBrains.Util.dataStructures.Sources.IStringSourceOwner.ToRuntimeString(StringSource& ss);
}
public class JetBrains.Util.dataStructures.Sources.RealCollectionSourceOwner`1 : object {
    public static RealCollectionSourceOwner`1<TItem> Instance;
    private static RealCollectionSourceOwner`1();
    public sealed virtual bool GetIsFastCount(CollectionSource`1& instance);
    public sealed virtual TItem[] ToArray(CollectionSource`1& instance);
    public sealed virtual IEnumerable`1<TItem> ToEnumerable(CollectionSource`1& instance);
    private sealed virtual override void JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<TItem>.EnumeratorDispose(Enumerator& instance);
    private sealed virtual override TItem JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<TItem>.EnumeratorGetCurrent(Enumerator& instance);
    private sealed virtual override bool JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<TItem>.EnumeratorMoveNext(Enumerator& instance);
    private sealed virtual override UInt32 JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<TItem>.GetCount(CollectionSource`1& instance);
    private sealed virtual override Enumerator<TItem> JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<TItem>.GetEnumerator(CollectionSource`1& instance);
    private sealed virtual override ICollection`1<TItem> JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<TItem>.ToCollection(CollectionSource`1& instance);
    private sealed virtual override string JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner<TItem>.ToString(CollectionSource`1& instance);
}
public class JetBrains.Util.dataStructures.Sources.RuntimeStringSourceOwner : object {
    public static IStringSourceOwner Instance;
    private static RuntimeStringSourceOwner();
    public sealed virtual TResult Fixed(StringSource& ss, TContext context, StringSourceFixedDelegate`2<TContext, TResult> λ);
    public sealed virtual char GetCharAt(StringSource& ss, UInt32 index);
    public sealed virtual UInt32 GetLength(StringSource& ss);
    public sealed virtual bool IsEmpty(StringSource& ss);
    public sealed virtual StringSource Substring(StringSource& ss, UInt32 start, UInt32 length);
    public sealed virtual string ToRuntimeString(StringSource& ss);
    private sealed virtual override StringSource JetBrains.Util.dataStructures.Sources.IStringSourceOwner.AsManagedStringSource(StringSource& ss);
}
public class JetBrains.Util.dataStructures.Sources.RuntimeSubStringSourceOwner : object {
    public static IStringSourceOwner Instance;
    private static RuntimeSubStringSourceOwner();
    public static void FromStringSlice(StringSlice& slice, StringSource& ss);
    public sealed virtual char GetCharAt(StringSource& ss, UInt32 index);
    private sealed virtual override StringSource JetBrains.Util.dataStructures.Sources.IStringSourceOwner.AsManagedStringSource(StringSource& ss);
    private sealed virtual override TResult JetBrains.Util.dataStructures.Sources.IStringSourceOwner.Fixed(StringSource& ss, TContext context, StringSourceFixedDelegate`2<TContext, TResult> λ);
    private sealed virtual override UInt32 JetBrains.Util.dataStructures.Sources.IStringSourceOwner.GetLength(StringSource& ss);
    private static void GetStringSlice(StringSource& ss, StringSlice& slice);
    private sealed virtual override bool JetBrains.Util.dataStructures.Sources.IStringSourceOwner.IsEmpty(StringSource& ss);
    private sealed virtual override StringSource JetBrains.Util.dataStructures.Sources.IStringSourceOwner.Substring(StringSource& ss, UInt32 start, UInt32 length);
    private sealed virtual override string JetBrains.Util.dataStructures.Sources.IStringSourceOwner.ToRuntimeString(StringSource& ss);
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Util.dataStructures.Sources.StringSource : ValueType {
    public static StringSource Empty;
    private IStringSourceOwner myOwner;
    public StringSourcePodData DataPod;
    public object DataRefX;
    public bool IsEmpty { get; }
    public char Item { get; }
    public UInt32 Length { get; }
    public IStringSourceOwner Owner { get; }
    public StringSource(IStringSourceOwner owner, object dataRefX, StringSourcePodData dataPod);
    [PureAttribute]
public bool get_IsEmpty();
    public char get_Item(UInt32 index);
    public UInt32 get_Length();
    [NotNullAttribute]
[PureAttribute]
public IStringSourceOwner get_Owner();
    public StringSource AsManagedStringSource();
    public sealed virtual bool Equals(StringSource other);
    public bool Equals(string other);
    public virtual bool Equals(object other);
    public TResult Fixed(TContext context, StringSourceFixedDelegate`2<TContext, TResult> λ);
    public virtual int GetHashCode();
    public static bool op_Equality(StringSource black, StringSource white);
    public static bool op_Equality(StringSource black, string white);
    public static bool op_Equality(string white, StringSource black);
    public static StringSource op_Implicit(string s);
    public static bool op_Inequality(StringSource black, string white);
    public static bool op_Inequality(string white, StringSource black);
    public static bool op_Inequality(StringSource black, StringSource white);
    public StringSource Substring(UInt32 start, UInt32 length);
    [NotNullAttribute]
[PureAttribute]
public string ToRuntimeString();
    [ObsoleteAttribute("Prefer ToRuntimeString specific operation, otherwise semantic of the ToString call might be silently changed upon changing the instance type.")]
public virtual string ToString();
    private sealed virtual override int System.IComparable.CompareTo(object other);
    private sealed virtual override int System.IComparable<JetBrains.Util.dataStructures.Sources.StringSource>.CompareTo(StringSource other);
}
public class JetBrains.Util.dataStructures.Sources.StringSourceComparerIgnoreCase : object {
    private static StringSourceFixedDelegate`2<FixedCtxOuter, int> FixedCompareInnerDelegate;
    private static StringSourceFixedDelegate`2<StringSource, int> FixedCompareOuterDelegate;
    private static StringSourceFixedDelegate`2<Missing, int> FixedGetHashCodeDelegate;
    [NotNullAttribute]
public static StringSourceComparerIgnoreCase Instance;
    [CompilerGeneratedAttribute]
private static StringSourceFixedDelegate`2<FixedCtxOuter, int> CS$<>9__CachedAnonymousMethodDelegate4;
    [CompilerGeneratedAttribute]
private static StringSourceFixedDelegate`2<StringSource, int> CS$<>9__CachedAnonymousMethodDelegate5;
    [CompilerGeneratedAttribute]
private static StringSourceFixedDelegate`2<Missing, int> CS$<>9__CachedAnonymousMethodDelegate6;
    private static StringSourceComparerIgnoreCase();
    public static int Compare(StringSource& black, StringSource& white);
    public static bool Equals(StringSource& black, StringSource& white);
    public static int GetHashCode(StringSource& ss);
    private sealed virtual override int System.Collections.Generic.IComparer<JetBrains.Util.dataStructures.Sources.StringSource>.Compare(StringSource black, StringSource white);
    private sealed virtual override bool System.Collections.Generic.IEqualityComparer<JetBrains.Util.dataStructures.Sources.StringSource>.Equals(StringSource black, StringSource white);
    private sealed virtual override int System.Collections.Generic.IEqualityComparer<JetBrains.Util.dataStructures.Sources.StringSource>.GetHashCode(StringSource ss);
    [CompilerGeneratedAttribute]
private static int <.cctor>b__1(Char* pchWhite, UInt32 cchWhite, FixedCtxOuter ctxBlack);
    [CompilerGeneratedAttribute]
private static int <.cctor>b__2(Char* pch, UInt32 cch, StringSource other);
    [CompilerGeneratedAttribute]
private static int <.cctor>b__3(Char* pch, UInt32 length, Missing context);
}
public class JetBrains.Util.dataStructures.Sources.StringSourceComparerOrdinal : object {
    private static StringSourceFixedDelegate`2<FixedCtxOuter, int> FixedCompareInnerDelegate;
    private static StringSourceFixedDelegate`2<StringSource, int> FixedCompareOuterDelegate;
    private static StringSourceFixedDelegate`2<FixedCtxOuter, bool> FixedEqualsInnerDelegate;
    private static StringSourceFixedDelegate`2<StringSource, bool> FixedEqualsOuterDelegate;
    private static StringSourceFixedDelegate`2<Missing, int> FixedGetHashCodeDelegate;
    [NotNullAttribute]
public static StringSourceComparerOrdinal Instance;
    [CompilerGeneratedAttribute]
private static StringSourceFixedDelegate`2<FixedCtxOuter, int> CS$<>9__CachedAnonymousMethodDelegate7;
    [CompilerGeneratedAttribute]
private static StringSourceFixedDelegate`2<StringSource, int> CS$<>9__CachedAnonymousMethodDelegate8;
    [CompilerGeneratedAttribute]
private static StringSourceFixedDelegate`2<FixedCtxOuter, bool> CS$<>9__CachedAnonymousMethodDelegate9;
    [CompilerGeneratedAttribute]
private static StringSourceFixedDelegate`2<StringSource, bool> CS$<>9__CachedAnonymousMethodDelegatea;
    [CompilerGeneratedAttribute]
private static StringSourceFixedDelegate`2<Missing, int> CS$<>9__CachedAnonymousMethodDelegateb;
    private static StringSourceComparerOrdinal();
    public static int Compare(StringSource& black, StringSource& white);
    public static bool Equals(StringSource& black, StringSource& white);
    public static int GetHashCode(StringSource& ss);
    private sealed virtual override int System.Collections.Generic.IComparer<JetBrains.Util.dataStructures.Sources.StringSource>.Compare(StringSource black, StringSource white);
    private sealed virtual override bool System.Collections.Generic.IEqualityComparer<JetBrains.Util.dataStructures.Sources.StringSource>.Equals(StringSource black, StringSource white);
    private sealed virtual override int System.Collections.Generic.IEqualityComparer<JetBrains.Util.dataStructures.Sources.StringSource>.GetHashCode(StringSource ss);
    [CompilerGeneratedAttribute]
private static int <.cctor>b__2(Char* pchWhite, UInt32 cchWhite, FixedCtxOuter ctxBlack);
    [CompilerGeneratedAttribute]
private static int <.cctor>b__3(Char* pch, UInt32 cch, StringSource other);
    [CompilerGeneratedAttribute]
private static bool <.cctor>b__4(Char* pchWhite, UInt32 cchWhite, FixedCtxOuter ctxBlack);
    [CompilerGeneratedAttribute]
private static bool <.cctor>b__5(Char* pch, UInt32 cch, StringSource other);
    [CompilerGeneratedAttribute]
private static int <.cctor>b__6(Char* pch, UInt32 length, Missing context);
}
[ExtensionAttribute]
public static class JetBrains.Util.dataStructures.Sources.StringSourceEx : object {
    private static StringSourceFixedDelegate`2<char, int> myλIndexOf;
    private static StringSourceFixedDelegate`2<Char[], int> myλIndexOfAny;
    private static StringSourceFixedDelegate`2<char, int> myλLastIndexOf;
    private static StringSourceFixedDelegate`2<Char[], int> myλLastIndexOfAny;
    private static StringSourceFixedDelegate`2<Pair`2<char, char>, string> myλReplaceChar;
    private static StringSourceFixedDelegate`2<CtxSplit, StringSource[]> myλSplit;
    [CompilerGeneratedAttribute]
private static StringSourceFixedDelegate`2<char, int> CS$<>9__CachedAnonymousMethodDelegate7;
    [CompilerGeneratedAttribute]
private static StringSourceFixedDelegate`2<Char[], int> CS$<>9__CachedAnonymousMethodDelegate8;
    [CompilerGeneratedAttribute]
private static StringSourceFixedDelegate`2<char, int> CS$<>9__CachedAnonymousMethodDelegate9;
    [CompilerGeneratedAttribute]
private static StringSourceFixedDelegate`2<Char[], int> CS$<>9__CachedAnonymousMethodDelegatea;
    [CompilerGeneratedAttribute]
private static StringSourceFixedDelegate`2<Pair`2<char, char>, string> CS$<>9__CachedAnonymousMethodDelegateb;
    [CompilerGeneratedAttribute]
private static StringSourceFixedDelegate`2<CtxSplit, StringSource[]> CS$<>9__CachedAnonymousMethodDelegatec;
    private static StringSourceEx();
    [ExtensionAttribute]
public static StringBuilder AppendLineStringSource(StringBuilder thіs, StringSource text);
    [ExtensionAttribute]
public static StringBuilder AppendStringSource(StringBuilder thіs, StringSource text);
    [ExtensionAttribute]
public static StringBuilder AppendStringSource(StringBuilder thіs, StringSource text, UInt32 index, UInt32 length);
    [ExtensionAttribute]
public static StringSource AsStringSource(StringSlice slice);
    [ExtensionAttribute]
public static bool EndsWith(StringSource thіs, StringSource suffix);
    [ExtensionAttribute]
public static int IndexOf(StringSource thіs, char ch);
    [ExtensionAttribute]
public static int IndexOfAny(StringSource thіs, Char[] chs);
    [ExtensionAttribute]
public static bool IsEmpty(StringSource thіs);
    [ExtensionAttribute]
public static bool IsEmpty(Nullable`1<StringSource> thіs);
    [ExtensionAttribute]
public static int LastIndexOf(StringSource thіs, char ch);
    [ExtensionAttribute]
public static int LastIndexOfAny(StringSource thіs, Char[] chs);
    [ExtensionAttribute]
public static Guid ParseGuid(StringSource thіs, OnError onerror);
    [ExtensionAttribute]
public static StringSource Replace(StringSource thіs, char what, char with);
    [ExtensionAttribute]
public static StringSource[] Split(StringSource thіs, Char[] separators);
    [ExtensionAttribute]
public static StringSource[] Split(StringSource thіs, Char[] separators, StringSplitOptions options);
    [ExtensionAttribute]
public static bool StartsWith(StringSource thіs, StringSource suffix);
    [ExtensionAttribute]
public static StringSource Substring(StringSource thіs, UInt32 start);
    [CanBeNullAttribute]
[ExtensionAttribute]
public static string ToRuntimeString(Nullable`1<StringSource> thіs);
    [CompilerGeneratedAttribute]
private static int <.cctor>b__1(Char* pch, UInt32 length, char ch);
    [CompilerGeneratedAttribute]
private static int <.cctor>b__2(Char* pch, UInt32 length, Char[] chs);
    [CompilerGeneratedAttribute]
private static int <.cctor>b__3(Char* pchOrig, UInt32 length, char ch);
    [CompilerGeneratedAttribute]
private static int <.cctor>b__4(Char* pchOrig, UInt32 length, Char[] chs);
    [CompilerGeneratedAttribute]
private static string <.cctor>b__5(Char* pchOrig, UInt32 length, Pair`2<char, char> context);
    [CompilerGeneratedAttribute]
private static StringSource[] <.cctor>b__6(Char* pch, UInt32 length, CtxSplit ctx);
}
public class JetBrains.Util.dataStructures.Sources.StringSourceFixedDelegate`2 : MulticastDelegate {
    public StringSourceFixedDelegate`2(object object, IntPtr method);
    public virtual TResult Invoke(Char* pch, UInt32 length, TContext context);
    public virtual IAsyncResult BeginInvoke(Char* pch, UInt32 length, TContext context, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public class JetBrains.Util.dataStructures.Sources.StringSourcePodData : ValueType {
}
public class JetBrains.Util.DelegatingExceptionThrowingLogger : LoggerBase {
    public static IExceptionThrowingLogger Default;
    private ILogger myLogger;
    public string Category { get; }
    public DelegatingExceptionThrowingLogger(ILogger logger);
    private static DelegatingExceptionThrowingLogger();
    public virtual void Log(LogEvent logEvent);
    public virtual string get_Category();
    public virtual bool IsEnabled(LoggingLevel level);
    public sealed virtual void LogOrThrowException(Exception ex, ExceptionOrigin origin);
}
public class JetBrains.Util.DirectoryEntryData : ValueType {
    public FileSystemPath BaseDir;
    public RelativePath RelativePath;
    public DateTime FileModificationTimeUtc;
    public DateTime FileCreationTimeUtc;
    public DateTime FileAccessTimeUtc;
    public FileAttributes Attributes;
    public ulong Length;
    public Existence Existence { get; }
    public bool IsFile { get; }
    public bool IsDirectory { get; }
    [NotNullAttribute]
public FileSystemPath GetAbsolutePath();
    public Existence get_Existence();
    public bool get_IsFile();
    public bool get_IsDirectory();
    public virtual string ToString();
}
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("Count = 0")]
public class JetBrains.Util.EmptyList`1 : object {
    [NotNullAttribute]
public static EmptyList`1<T> Instance;
    [NotNullAttribute]
public static IList`1<T> InstanceList;
    [NotNullAttribute]
public static IReadOnlyList`1<T> ReadOnly;
    [NotNullAttribute]
public static IReadOnlyCollection`1<T> Collection;
    [NotNullAttribute]
public static IEnumerable`1<T> Enumerable;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public T Item { get; public set; }
    private static EmptyList`1();
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual bool Remove(T item);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual int IndexOf(T item);
    public sealed virtual void Insert(int index, T item);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
}
[DebuggerDisplayAttribute("Count = 0")]
public class JetBrains.Util.EmptySet`1 : object {
    [NotNullAttribute]
public static EmptySet`1<T> Instance;
    [NotNullAttribute]
public static ISet`1<T> InstanceSet;
    [NotNullAttribute]
public static IReadOnlyCollection`1<T> Collection;
    [NotNullAttribute]
public static IEnumerable`1<T> Enumerable;
    private int System.Collections.Generic.ICollection<T>.Count { get; }
    public bool IsReadOnly { get; }
    private int System.Collections.Generic.IReadOnlyCollection<T>.Count { get; }
    private static EmptySet`1();
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual bool Remove(T item);
    private sealed virtual override int System.Collections.Generic.ICollection<T>.get_Count();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override bool System.Collections.Generic.ISet<T>.Add(T item);
    public sealed virtual void UnionWith(IEnumerable`1<T> other);
    public sealed virtual void IntersectWith(IEnumerable`1<T> other);
    public sealed virtual void ExceptWith(IEnumerable`1<T> other);
    public sealed virtual void SymmetricExceptWith(IEnumerable`1<T> other);
    public sealed virtual bool IsSubsetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsSupersetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsProperSupersetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsProperSubsetOf(IEnumerable`1<T> other);
    public sealed virtual bool Overlaps(IEnumerable`1<T> other);
    public sealed virtual bool SetEquals(IEnumerable`1<T> other);
    private sealed virtual override int System.Collections.Generic.IReadOnlyCollection<T>.get_Count();
}
[ExtensionAttribute]
public static class JetBrains.Util.EnumEx : object {
    private static char LineSeparator;
    private static Dictionary`2<Type, Dictionary`2<ulong, string>> myMapEnumValueToName;
    [CompilerGeneratedAttribute]
private static Func`2<FieldInfo, <>f__AnonymousType1`2<string, ulong>> CS$<>9__CachedAnonymousMethodDelegate9;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType1`2<string, ulong>, ulong> CS$<>9__CachedAnonymousMethodDelegatea;
    [CompilerGeneratedAttribute]
private static Func`3<ulong, IEnumerable`1<<>f__AnonymousType1`2<string, ulong>>, <>f__AnonymousType2`2<ulong, string>> CS$<>9__CachedAnonymousMethodDelegateb;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType2`2<ulong, string>, ulong> CS$<>9__CachedAnonymousMethodDelegatec;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType2`2<ulong, string>, string> CS$<>9__CachedAnonymousMethodDelegated;
    [CompilerGeneratedAttribute]
private static Func`2<string, bool> CS$<>9__CachedAnonymousMethodDelegatee;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType1`2<string, ulong>, string> CS$<>9__CachedAnonymousMethodDelegate11;
    [CompilerGeneratedAttribute]
private static Func`1<object> CS$<>9__CachedAnonymousMethodDelegate15;
    private static EnumEx();
    [ExtensionAttribute]
public static bool HasAny(Enum enum, T[] flags);
    [ExtensionAttribute]
public static bool HasAll(Enum enum, T[] flags);
    [ExtensionAttribute]
public static bool Has(Enum enum, T flag);
    [ExtensionAttribute]
public static TypeCode GetUnderlyingTypeCode(Enum enum);
    public static T CoerceEnumValueSlow(T value);
    public static IEnumerable`1<string> GetNamesOfValue(Type type, object value);
    public static T[] GetValues();
    public static ulong UnboxQWord(object o);
    [ExtensionAttribute]
public static Nullable`1<bool> ToBool(string stringValue);
    [ExtensionAttribute]
public static Nullable`1<TEnum> ToEnum(string stringValue);
    [ExtensionAttribute]
public static TEnum ToEnum(int intValue);
    public static int ToInt(TEnum enumValue);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType1`2<string, ulong> <GetNamesOfValue>b__1(FieldInfo field);
    [CompilerGeneratedAttribute]
private static ulong <GetNamesOfValue>b__2(<>f__AnonymousType1`2<string, ulong> tuple);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType2`2<ulong, string> <GetNamesOfValue>b__3(ulong val, IEnumerable`1<<>f__AnonymousType1`2<string, ulong>> tuples);
    [CompilerGeneratedAttribute]
private static ulong <GetNamesOfValue>b__5(<>f__AnonymousType2`2<ulong, string> tuple);
    [CompilerGeneratedAttribute]
private static string <GetNamesOfValue>b__6(<>f__AnonymousType2`2<ulong, string> tuple);
    [CompilerGeneratedAttribute]
private static bool <GetNamesOfValue>b__7(string name);
    [CompilerGeneratedAttribute]
private static string <GetNamesOfValue>b__4(<>f__AnonymousType1`2<string, ulong> tuple);
    [CompilerGeneratedAttribute]
private static object <UnboxQWord>b__13();
}
[ExtensionAttribute]
public static class JetBrains.Util.ExceptionEx : object {
    public static string SensitiveDataPrefix;
    public static string AttachmentPrefix;
    [CompilerGeneratedAttribute]
private static Func`2<object, object> CS$<>9__CachedAnonymousMethodDelegated;
    [CompilerGeneratedAttribute]
private static Func`2<Pair`2<string, object>, bool> CS$<>9__CachedAnonymousMethodDelegate10;
    [CompilerGeneratedAttribute]
private static Func`2<Pair`2<string, object>, object> CS$<>9__CachedAnonymousMethodDelegate11;
    [ExtensionAttribute]
public static Pair`2[] GetSensitiveData(Exception ex);
    [ExtensionAttribute]
public static TException WithSensitiveData(TException exception, IEnumerable`1<Pair`2<string, object>> sensitiveData);
    [ExtensionAttribute]
public static TException WithSensitiveData(TException exception, string name, object value);
    [ExtensionAttribute]
public static TException WithSensitiveData(TException exception, string name, Func`1<object> fGetValue);
    [ExtensionAttribute]
[ConditionalAttribute("JET_MODE_REPORT_EXCEPTIONS")]
public static void AddSensitiveData(TException exception, IEnumerable`1<Pair`2<string, object>> sensitiveData);
    [ConditionalAttribute("JET_MODE_REPORT_EXCEPTIONS")]
[ExtensionAttribute]
public static void AddSensitiveData(TException exception, string name, object value);
    [ExtensionAttribute]
[ConditionalAttribute("JET_MODE_REPORT_EXCEPTIONS")]
public static void AddSensitiveData(TException exception, string name, Func`1<object> fGetValue);
    [ExtensionAttribute]
public static TException AddDataUnsafe(TException exception, string name, object value);
    [ConditionalAttribute("JET_MODE_REPORT_EXCEPTIONS")]
[ExtensionAttribute]
public static void AddData(TException exception, string name, Func`1<object> FValue);
    [ObsoleteAttribute("Either use the conditional AddData overload with a lambda, or the AddDataUnsafe overload without a lamdba which is non-conditional.")]
[ExtensionAttribute]
[ConditionalAttribute("JET_MODE_REPORT_EXCEPTIONS")]
public static void AddData(TException exception, string name, object value);
    [ConditionalAttribute("JET_MODE_REPORT_EXCEPTIONS")]
[ExtensionAttribute]
public static void AddDataIndirect(TException exception, Action`1<Exception> FAddData);
    private static object FlattenDataValue(object oValue);
    [ExtensionAttribute]
public static TException WithSensitiveAttachment(TException exception, FileSystemPath path);
    [ExtensionAttribute]
public static TException WithAttachment(TException exception, FileSystemPath path);
    [ExtensionAttribute]
public static IEnumerable`1<FileSystemPath> GetAttachments(Exception exception);
    [ExtensionAttribute]
private static IEnumerable`1<Pair`2<string, object>> GetData(Exception exception);
    [CompilerGeneratedAttribute]
private static object <AddDataUnsafe>b__2();
    [CompilerGeneratedAttribute]
private static object <FlattenDataValue>b__c(object nested);
    [CompilerGeneratedAttribute]
private static bool <GetAttachments>b__e(Pair`2<string, object> x);
    [CompilerGeneratedAttribute]
private static object <GetAttachments>b__f(Pair`2<string, object> x);
}
public enum JetBrains.Util.ExceptionOrigin : Enum {
    public int value__;
    public static ExceptionOrigin Algorithmic;
    public static ExceptionOrigin Assertion;
    public static ExceptionOrigin OuterWorld;
}
[ExtensionAttribute]
public static class JetBrains.Util.ExceptionRenderer : object {
    private static Func`4<object, object, object, string> FExceptionCaptionFormat;
    public static string RenderedExceptionDataKey;
    public static string RenderedExceptionDataWithSensitiveInfoKey;
    public static string RenderedExceptionMessageKey;
    public static string RootExceptionPath;
    public static bool ForceRenderSensitiveData;
    [ThreadStaticAttribute]
private static bool IsBusy;
    [CompilerGeneratedAttribute]
private static Func`2<ExData, Exception> CS$<>9__CachedAnonymousMethodDelegate1;
    [CompilerGeneratedAttribute]
private static Action CS$<>9__CachedAnonymousMethodDelegate4;
    [CompilerGeneratedAttribute]
private static Func`2<ExData, Guid> CS$<>9__CachedAnonymousMethodDelegate15;
    [CompilerGeneratedAttribute]
private static Func`3<ExData, int, <>f__AnonymousType0`2<ExData, int>> CS$<>9__CachedAnonymousMethodDelegate16;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType0`2<ExData, int>, ExData> CS$<>9__CachedAnonymousMethodDelegate17;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType0`2<ExData, int>, int> CS$<>9__CachedAnonymousMethodDelegate18;
    [CompilerGeneratedAttribute]
private static Func`2<char, bool> CS$<>9__CachedAnonymousMethodDelegate19;
    [CompilerGeneratedAttribute]
private static Func`2<ExData, Guid> CS$<>9__CachedAnonymousMethodDelegate1f;
    [CompilerGeneratedAttribute]
private static Func`2<ExData, Guid> CS$<>9__CachedAnonymousMethodDelegate25;
    [CompilerGeneratedAttribute]
private static Func`2<string, string> CS$<>9__CachedAnonymousMethodDelegate2a;
    [CompilerGeneratedAttribute]
private static Func`2<ExData, string> CS$<>9__CachedAnonymousMethodDelegate2b;
    [CompilerGeneratedAttribute]
private static Func`2<HierarchicalDataEntry, IEnumerable`1<HierarchicalDataEntry>> CS$<>9__CachedAnonymousMethodDelegate2e;
    [CompilerGeneratedAttribute]
private static Func`4<object, object, object, string> CS$<>9__CachedAnonymousMethodDelegate32;
    private static ExceptionRenderer();
    [ExtensionAttribute]
[NotNullAttribute]
public static List`1<Exception> GetAllNestedExceptions(Exception ex);
    [NotNullAttribute]
[ExtensionAttribute]
public static string RenderSensitiveData(Exception ex);
    public static IDisposable WithForceRenderSensitiveData();
    [ExtensionAttribute]
public static ExceptionText RenderException(Exception ex, IDictionary`2<object, IList`1<object>> customData, Nullable`1<bool> renderSensitiveData);
    public static string RenderOuterExceptionMessageAndData(Exception ex);
    private static List`1<ExData> CollectExDatas(Exception ex, bool renderSensitiveData);
    private static string CombinePrefix(string one, string two);
    private static string GetExceptionDataCached(Exception ex, string key, Func`1<string> FProduce);
    private static string PrintExDatas(IList`1<ExData> arExceptionsUnsorted);
    [NotNullAttribute]
private static IList`1<ExData> SortExceptionsForBodyPrinting(ICollection`1<ExData> exceptions);
    [NotNullAttribute]
private static IList`1<ExData> SortExceptionsForMessagePrinting(ICollection`1<ExData> exceptions);
    [NotNullAttribute]
private static string PrintExMessage(ICollection`1<ExData> arExceptionsUnsorted);
    private static void RenderSingleExceptionObject(ExData exd, bool renderSensitiveData);
    [CompilerGeneratedAttribute]
private static Exception <GetAllNestedExceptions>b__0(ExData exdata);
    [CompilerGeneratedAttribute]
private static void <WithForceRenderSensitiveData>b__2();
    [CompilerGeneratedAttribute]
private static Guid <PrintExDatas>b__e(ExData exd);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType0`2<ExData, int> <PrintExDatas>b__f(ExData data, int index);
    [CompilerGeneratedAttribute]
private static ExData <PrintExDatas>b__10(<>f__AnonymousType0`2<ExData, int> tuple);
    [CompilerGeneratedAttribute]
private static int <PrintExDatas>b__11(<>f__AnonymousType0`2<ExData, int> tuple);
    [CompilerGeneratedAttribute]
private static bool <PrintExDatas>b__14(char c);
    [CompilerGeneratedAttribute]
private static Guid <SortExceptionsForBodyPrinting>b__1c(ExData exd);
    [CompilerGeneratedAttribute]
private static Guid <SortExceptionsForMessagePrinting>b__22(ExData exd);
    [CompilerGeneratedAttribute]
private static string <PrintExMessage>b__28(string s);
    [CompilerGeneratedAttribute]
private static string <PrintExMessage>b__29(ExData exdata);
    [CompilerGeneratedAttribute]
private static IEnumerable`1<HierarchicalDataEntry> <RenderSingleExceptionObject>b__2c(HierarchicalDataEntry entry);
    [CompilerGeneratedAttribute]
private static string <.cctor>b__31(object index, object total, object typename);
}
public class JetBrains.Util.ExceptionText : object {
    [NotNullAttribute]
public string FullText;
    [NotNullAttribute]
public string Message;
    public ExceptionText(string message, string fullText);
    public virtual string ToString();
}
public static class JetBrains.Util.ExtensionConstants : object {
    public static string Config;
    public static string Exe;
    public static string Dll;
    public static string DyLib;
    public static string So;
    public static string Lib;
    public static string A;
    public static string NetModule;
    public static string WinMd;
    public static string Yes;
    public static string Pdb;
    public static string Xml;
    public static string Zip;
    public static string Cmd;
    public static string Sh;
    public static string Ps1;
    public static string Sln;
    public static string CMake;
    public static string Nupkg;
    public static string Nuspec;
    public static string Xproj;
    public static string XprojUser;
    public static string CompressedExe;
    public static string CompressedDll;
    public static string CompressedPdb;
}
[ExtensionAttribute]
public static class JetBrains.Util.Extensions.StringEx : object {
    [ObsoleteAttribute("Use 'Split' extension method from 'JetBrains.Util.Extension.StringExtensions' class")]
[ExtensionAttribute]
public static StringSlicesEnumerable Split(string s, char separator);
    [ObsoleteAttribute("Use 'Split' extension method from 'JetBrains.Util.Extension.StringExtensions' class")]
[ExtensionAttribute]
public static StringSlicesEnumerable Split(string s, char separator, StringSplitOptions options);
    [ExtensionAttribute]
[ObsoleteAttribute("Use 'Split' extension method from 'JetBrains.Util.Extension.StringExtensions' class")]
public static StringSlicesEnumerable Split(string s, Char[] separator);
    [ObsoleteAttribute("Use 'Split' extension method from 'JetBrains.Util.Extension.StringExtensions' class")]
[ExtensionAttribute]
public static StringSlicesEnumerable Split(string s, Char[] separator, StringSplitOptions options);
}
public static class JetBrains.Util.FilesInUse : object {
    [CompilerGeneratedAttribute]
private static Func`2<FileSystemPath, string> CS$<>9__CachedAnonymousMethodDelegate3;
    public static FilesInUseStatus QueryFilesInUse(FileSystemPath[] files);
    private static FilesInUseStatus ReportCommonFailure(FileSystemPath[] files, string failure);
    [CompilerGeneratedAttribute]
private static string <QueryFilesInUse>b__2(FileSystemPath x);
}
public class JetBrains.Util.FileStreamWrapper : FileStream {
    private LocalList`1<Action> myActions;
    public FileStreamWrapper(string path, FileMode mode, FileAccess access, FileShare share);
    public FileStreamWrapper(SafeFileHandle handle, FileAccess access);
    public void DoAfterClose(Action action);
    public virtual void Close();
}
public class JetBrains.Util.FileSystemCompression : object {
    public static bool CompressIfSupported(FileSystemPath pathToDirOrFile, OnError onerror);
    public static bool CompressIfSupported(Void* hFile, OnError onerror);
}
public static class JetBrains.Util.FileSystemDefinition : object {
    public static char DirectorySeparatorChar;
    public static string DirectorySeparatorString;
    public static char AltDirectorySeparatorChar;
    public static string AltDirectorySeparatorString;
    public static Char[] DirectorySeparatorCharArray;
    public static Char[] AltDirectorySeparatorCharArray;
    public static Char[] SeparatorChars;
    public static char VolumeSeparatorChar;
    public static Char[] InvalidFileNameChars;
    public static Char[] InvalidPathChars;
    public static Char[] WindowsInvalidPathChars;
    public static char PathDelimiterChar;
    public static string PathDelimiterString;
    public static StringComparison PathStringComparison;
    public static IEqualityComparer`1<string> PathStringEquality;
    public static IComparer`1<string> PathStringComparer;
    public static bool CaseSensitiveFileNames;
    public static string EnvironmentVariableNameForNoCleanup;
    private static int myIsEnvironmentVariableForNoCleanup;
    [CompilerGeneratedAttribute]
private static Func`2<string, FileSystemPath> CS$<>9__CachedAnonymousMethodDelegate1;
    public static bool IsEnvironmentVariableForNoCleanup { get; }
    private static FileSystemDefinition();
    public static FileSystemPath[] GetRoots();
    [NotNullAttribute]
public static FileSystemPath GetTempPath();
    [NotNullAttribute]
public static FileSystemPath CreateTemporaryDirectory(FileSystemPath parent, string prefix);
    [NotNullAttribute]
public static FileSystemPath CreateTemporaryDirectory(Lifetime lifetime, FileSystemPath parent, string prefix);
    [NotNullAttribute]
public static FileSystemPath CreateTemporaryFile(FileSystemPath parent, string extensionWithDot, string prefix, Action`1<FileStream> handler);
    [NotNullAttribute]
public static FileSystemPath CreateTemporaryFile(Lifetime lifetime, FileSystemPath parent, string extensionWithDot, string prefix, Action`1<FileStream> handler);
    private static bool CreateNewDirectoryAtomic(FileSystemPath path);
    private static bool TryCreateNewFileAtomic(FileSystemPath path, Action`1<FileStream> handler);
    private static FileSystemPath CreateTempEntity(Func`1<string> randomNameGenerator, Func`2<FileSystemPath, bool> creator, Lifetime lifetime, FileSystemPath parent, string prefix, string extension);
    public static bool get_IsEnvironmentVariableForNoCleanup();
    [NotNullAttribute]
public static IPath TryParse(string path);
    [NotNullAttribute]
public static IPath Parse(string path);
    [CompilerGeneratedAttribute]
private static FileSystemPath <GetRoots>b__0(string x);
}
public class JetBrains.Util.FileSystemEntryInfo : object {
    public FileSystemPath Path;
    public FileAttributes Attributes;
    public DateTime ModificationTimeUtc;
    public DateTime AccessTimeUtc;
    public DateTime CreationTimeUtc;
    public long Length;
    public bool IsFile { get; }
    public bool IsDirectory { get; }
    public FileSystemEntryInfo(FileSystemPath path, FileAttributes attributes, DateTime modificationTimeUtc, DateTime accessTimeUtc, DateTime creationTimeUtc, long length);
    public bool get_IsFile();
    public bool get_IsDirectory();
}
public class JetBrains.Util.FileSystemEvent : ValueType {
    public JetFileSystemWatcher Watcher;
    public FileSystemEventType Type;
    public string Name;
    public string OldName;
    public string ErrorMessage;
    public FileSystemPath FullPath { get; }
    public FileSystemPath OldFullPath { get; }
    private FileSystemEvent(JetFileSystemWatcher watcher, FileSystemEventType type, string name, string oldName, string errorMessage);
    private FileSystemPath GetFullPath(string name);
    public FileSystemPath get_FullPath();
    public FileSystemPath get_OldFullPath();
    public static FileSystemEvent CreateFileChangedEvent(JetFileSystemWatcher watcher, string name);
    public static FileSystemEvent CreateFileCreatedEvent(JetFileSystemWatcher watcher, string name);
    public static FileSystemEvent CreateFileRemovedEvent(JetFileSystemWatcher watcher, string name);
    public static FileSystemEvent CreateFileRenamedEvent(JetFileSystemWatcher watcher, string name, string oldName);
    public static FileSystemEvent CreateWatcherErrorEvent(JetFileSystemWatcher watcher, string errorMessage);
    public static FileSystemEvent CreateWatcherEventsBufferOverflowEvent(JetFileSystemWatcher watcher);
    public static FileSystemEvent CreateWatchedDirectoryDeletedEvent(JetFileSystemWatcher watcher);
    public static FileSystemEvent CreateWatchedDirectoryAbortedEvent(JetFileSystemWatcher watcher);
}
public enum JetBrains.Util.FileSystemEventType : Enum {
    public int value__;
    public static FileSystemEventType None;
    public static FileSystemEventType FileChanged;
    public static FileSystemEventType FileCreated;
    public static FileSystemEventType FileRenamed;
    public static FileSystemEventType FileRemoved;
    public static FileSystemEventType WatcherError;
    public static FileSystemEventType WatcherEventsBufferOverflow;
    public static FileSystemEventType WatchedDirectoryDeleted;
    public static FileSystemEventType WatchedDirectoryAborted;
}
public abstract class JetBrains.Util.FileSystemInteraction : object {
    public abstract virtual void OverrideWriteHandler(Lifetime lifetime, Func`2<IFsWriteHandler, IFsWriteHandler> newHandlerFactory);
    public abstract virtual Existence GetExists(FileSystemPath thіs);
    public abstract virtual FileSystemEntryInfo GetInfo(FileSystemPath thіs);
    public abstract virtual DateTime GetFileModificationTimeUtc(FileSystemPath thіs);
    public abstract virtual void SetFileModificationTimeUtc(FileSystemPath thіs, DateTime time);
    public abstract virtual DateTime GetFileCreationTimeUtc(FileSystemPath thіs);
    public abstract virtual DateTime GetFileLastAccessedTimeUtc(FileSystemPath thіs);
    public abstract virtual string GetFileAccessPath(FileSystemPath thіs);
    public abstract virtual bool IsLocked(FileSystemPath thіs);
    public abstract virtual long GetFileLength(FileSystemPath thіs);
    public abstract virtual FileAttributes GetAttributes(FileSystemPath thіs);
    public abstract virtual void SetAttributes(FileSystemPath thіs, FileAttributes fileAttributes);
    public abstract virtual FileAttributes TryGetAttributes(FileSystemPath thіs);
    public abstract virtual FileStream OpenStream(FileSystemPath thіs, FileMode fileMode, FileAccess fileAccess, FileShare fileShare);
    public abstract virtual SafeFileHandle OpenFileHandle(FileSystemPath thіs, FileMode fileMode, FileAccess fileAccess, FileShare fileShare, FileFlagsAndAttributes fileFlagsAndAttributes);
    public abstract virtual ulong GetFileIndex(FileSystemPath thіs);
    public abstract virtual IEnumerable`1<FileSystemPath> GetDirectoryEntries(FileSystemPath thіs, string mask, Nullable`1<bool> files, FileSystemPathInternStrategy internStrategy);
    public abstract virtual void GetDirectoryEntries(FileSystemPath thіs, RelativePath subdir, string mask, PathSearchFlags flags, ICollection`1& output);
    public abstract virtual void Move(FileSystemPath thіs, FileSystemPath dst);
    public abstract virtual void MoveFile(FileSystemPath thіs, FileSystemPath dst, bool overwrite);
    public abstract virtual void CopyFile(FileSystemPath thіs, FileSystemPath dst, bool overwrite);
    public abstract virtual FileSystemPath CreateDirectory(FileSystemPath thіs);
    public abstract virtual bool TryCreateNewDirectoryAtomic(FileSystemPath thіs);
    public abstract virtual void DeleteFile(FileSystemPath thіs);
    public abstract virtual void DeleteFile(FileSystemPath thіs, Boolean& isDirectory, int nAttempts);
    public abstract virtual void DeleteDirectoryNonRecursive(FileSystemPath thіs, int nAttempts, Exception& ex);
    public abstract virtual FileSystemPath GetShortPath(FileSystemPath thіs);
    public abstract virtual FileSystemPath GetLongPath(FileSystemPath thіs);
    public abstract virtual FileSystemPath GetTempPath();
}
[TypeConverterAttribute("JetBrains.Util.FileSystemPathConverter")]
[ValueSerializerAttribute("JetBrains.Util.FileSystemPathSerializer")]
public class JetBrains.Util.FileSystemPath : object {
    public static string LongPathPrefix;
    public static string LongUncPathPrefix;
    public static string PathSeparatorChar;
    private static FileSystemInteraction FS;
    private Nullable`1<int> myHashCode;
    private String modreq(System.Runtime.CompilerServices.IsVolatile) myName;
    private String modreq(System.Runtime.CompilerServices.IsVolatile) myNameWithoutExtension;
    [NotNullAttribute]
public static FileSystemPath Empty;
    public static DateTime NonexistentFileDateTime;
    public static ILogger Logger;
    [NotNullAttribute]
public string FullPath;
    private static IFileSystemPathIntern ourIntern;
    private static Func`3<string, bool, FileSystemPath> myCachedDelegate1;
    [CompilerGeneratedAttribute]
private static Action CS$<>9__CachedAnonymousMethodDelegate4;
    [CompilerGeneratedAttribute]
private static Func`3<string, bool, FileSystemPath> CS$<>9__CachedAnonymousMethodDelegate8;
    [NotNullAttribute]
public FileSystemPath Directory { get; }
    [NotNullAttribute]
public FileSystemPath Parent { get; }
    public Existence Exists { get; }
    [CanBeNullAttribute]
public FileSystemEntryInfo Info { get; }
    public bool ExistsDirectory { get; }
    public bool ExistsFile { get; }
    public string ExtensionNoDot { get; }
    public string ExtensionWithDot { get; }
    public DateTime FileModificationTimeUtc { get; public set; }
    public DateTime FileCreationTimeUtc { get; }
    public DateTime FileLastAccessedTimeUtc { get; }
    public string FileAccessPath { get; }
    public bool IsAbsolute { get; }
    private bool IsUnixAbsolute { get; }
    public bool IsEmpty { get; }
    public bool IsLocked { get; }
    public string Name { get; }
    public string NameWithoutExtension { get; }
    private char CurrentSeparatorChar { get; }
    private IPath JetBrains.Util.IPath.Parent { get; }
    private string JetBrains.Util.IPath.FullPath { get; }
    public bool IsValidOnCurrentOS { get; }
    private IPath JetBrains.Util.IPath.Empty { get; }
    public bool IsUnc { get; }
    public bool IsHidden { get; }
    public bool IsSystem { get; }
    public string FirstComponent { get; }
    private FileSystemPath(string path, bool isPathAlreadyCanonical);
    private static FileSystemPath();
    public SafeFileHandle OpenFileHandle(FileMode fileMode, FileAccess fileAccess, FileShare fileShare, FileFlagsAndAttributes fileFlagsAndAttributes);
    public FileStream OpenStream(FileMode fileMode, FileAccess fileAccess, FileShare fileShare);
    public IEnumerable`1<FileSystemPath> GetDirectoryEntries(string mask, Nullable`1<bool> files, FileSystemPathInternStrategy internStrategy);
    [NotNullAttribute]
public ICollection`1<DirectoryEntryData> GetDirectoryEntries(string mask, PathSearchFlags flags);
    public void Move(FileSystemPath destinationFilePath);
    public void MoveFile(FileSystemPath destinationFilePath, bool overwrite);
    public void CopyFile(FileSystemPath destinationFilePath, bool overwrite);
    public ulong GetFileIndex();
    public FileSystemPath CreateDirectory();
    public void DeleteFile();
    internal void DeleteFile(Boolean& isDirectory, int nAttempts);
    public void DeleteDirectoryNonRecursive();
    internal void DeleteDirectoryNonRecursive(int nAttempts, Exception& ex);
    public void SetAttributes(FileAttributes fileAttributes);
    public FileAttributes GetAttributes();
    public long GetFileLength();
    public FileSystemPath GetLongPath();
    public FileSystemPath GetShortPath();
    public FileAttributes TryGetAttributes();
    public FileStream OpenStream(FileMode mode);
    public IEnumerable`1<FileSystemPath> GetDirectoryEntries(string mask, bool files, FileSystemPathInternStrategy internStrategy);
    public FileSystemPath get_Directory();
    public FileSystemPath get_Parent();
    [NotNullAttribute]
public FileSystemPath GetParent(FileSystemPathInternStrategy internStrategy);
    private bool IsLastSeparatorInLocalRoot(int lastSeparatorPos);
    public Existence get_Exists();
    public FileSystemEntryInfo get_Info();
    public bool get_ExistsDirectory();
    public bool get_ExistsFile();
    public sealed virtual string get_ExtensionNoDot();
    public sealed virtual string get_ExtensionWithDot();
    public DateTime get_FileModificationTimeUtc();
    public void set_FileModificationTimeUtc(DateTime value);
    public DateTime get_FileCreationTimeUtc();
    public DateTime get_FileLastAccessedTimeUtc();
    public string get_FileAccessPath();
    public sealed virtual bool get_IsAbsolute();
    private bool get_IsUnixAbsolute();
    public StringSlice GetComputerName();
    public sealed virtual bool get_IsEmpty();
    public bool get_IsLocked();
    public sealed virtual string get_Name();
    public sealed virtual string get_NameWithoutExtension();
    [NotNullAttribute]
public static FileSystemPath CreateByCanonicalPath(string path, FileSystemPathInternStrategy internStrategy);
    [NotNullAttribute]
public static FileSystemPath GetDeepestCommonParent(FileSystemPath first, FileSystemPath second);
    [PureAttribute]
[NotNullAttribute]
public static FileSystemPath TryParse(string path, FileSystemPathInternStrategy internStrategy);
    [NotNullAttribute]
[PureAttribute]
public static FileSystemPath Parse(string path, FileSystemPathInternStrategy internStrategy);
    [PureAttribute]
[NotNullAttribute]
public static FileSystemPath ParseRelativelyTo(string path, FileSystemPath basePathForRelativeStrings);
    private static FileSystemPath Create(string path, bool isPathAlreadyCanonical, FileSystemPathInternStrategy internStrategy);
    [ContractAnnotationAttribute("null => null")]
public static string op_Explicit(FileSystemPath path);
    [ContractAnnotationAttribute("null => null")]
public static FileSystemPath op_Explicit(string path);
    [PureAttribute]
[NotNullAttribute]
public FileSystemPath Clone();
    [NotNullAttribute]
[PureAttribute]
public FileSystemPath Combine(RelativePath other, FileSystemPathInternStrategy internStrategy);
    [NotNullAttribute]
[PureAttribute]
[ObsoleteAttribute("You should not be combining two absolute paths. Combine with a RelativePath instead.")]
public FileSystemPath Combine(FileSystemPath other, FileSystemPathInternStrategy internStrategy);
    [PureAttribute]
[NotNullAttribute]
public FileSystemPath Combine(string component, FileSystemPathInternStrategy internStrategy);
    [PureAttribute]
[NotNullAttribute]
public FileSystemPath CombineWithShortName(string shortName);
    [ObsoleteAttribute("Use overloads TryMakeRelativeTo or MakeRelativeTo which return a relative path.")]
[NotNullAttribute]
[PureAttribute]
public FileSystemPath ConvertToRelativePath(FileSystemPath basePath, FileSystemPathInternStrategy internStrategy);
    [PureAttribute]
[NotNullAttribute]
public IPath TryMakeRelativeTo(FileSystemPath basePath);
    private char get_CurrentSeparatorChar();
    [NotNullAttribute]
[PureAttribute]
public RelativePath MakeRelativeTo(FileSystemPath basePath);
    [ObsoleteAttribute("Seems like this operation is not quite valid for an absolute path.")]
public bool IsSuffixOf(FileSystemPath otherPath);
    [NotNullAttribute]
public sealed virtual Uri ToDirectoryUri();
    [NotNullAttribute]
public sealed virtual Uri ToUri();
    private sealed virtual override IPath JetBrains.Util.IPath.TryCombine(string component);
    [NotNullAttribute]
public FileSystemPath TryCombine(string component);
    [NotNullAttribute]
private static string GetCanonicalPath(string path);
    private int GetLastSeparatorPosition();
    public static bool op_Inequality(FileSystemPath left, FileSystemPath right);
    public static bool op_Equality(FileSystemPath left, FileSystemPath right);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(FileSystemPath other);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static void AllowIntern(Lifetime lifetime, int maxEntries);
    private static IFileSystemPathIntern CreateIntern(int maxEntries);
    public static void ClearIntern();
    private sealed virtual override IPath JetBrains.Util.IPath.get_Parent();
    private sealed virtual override IPath JetBrains.Util.IPath.Combine(RelativePath other);
    private sealed virtual override string JetBrains.Util.IPath.get_FullPath();
    [NotNullAttribute]
public static FileSystemPath op_Division(FileSystemPath path, RelativePath other);
    [NotNullAttribute]
public static FileSystemPath op_Division(FileSystemPath path, string component);
    public void AssertIsAbsolute();
    public bool LogAssertIsAbsolute();
    public void LogAssertIsOSCompatible();
    public void AssertIsOSCompatible();
    public sealed virtual bool get_IsValidOnCurrentOS();
    private sealed virtual override IPath JetBrains.Util.IPath.get_Empty();
    public bool get_IsUnc();
    public bool get_IsHidden();
    public bool get_IsSystem();
    public sealed virtual string get_FirstComponent();
    private sealed virtual override IPath JetBrains.Util.IPath.Parse(string text);
    public static FileSystemPath op_Explicit(Uri uri);
    public static Uri op_Explicit(FileSystemPath path);
    internal bool TryCreateNewDirectoryAtomic();
    public char GetDriveName();
    [NotNullAttribute]
public sealed virtual String[] GetPathComponents();
    [NotNullAttribute]
public string GetRootDir();
    [CompilerGeneratedAttribute]
private static void <AllowIntern>b__3();
    [CompilerGeneratedAttribute]
private static FileSystemPath <.cctor>b__7(string key, bool canonical);
}
public class JetBrains.Util.FileSystemPathConverter : TypeConverterBase`1<FileSystemPath> {
    [CompilerGeneratedAttribute]
private static Func`4<ITypeDescriptorContext, CultureInfo, FileSystemPath, string> CS$<>9__CachedAnonymousMethodDelegate2;
    [CompilerGeneratedAttribute]
private static Func`4<ITypeDescriptorContext, CultureInfo, string, FileSystemPath> CS$<>9__CachedAnonymousMethodDelegate3;
    [CompilerGeneratedAttribute]
private static string <.ctor>b__0(ITypeDescriptorContext context, CultureInfo info, FileSystemPath value);
    [CompilerGeneratedAttribute]
private static FileSystemPath <.ctor>b__1(ITypeDescriptorContext descriptorContext, CultureInfo cultureInfo, string value);
}
[ExtensionAttribute]
public static class JetBrains.Util.FileSystemPathEx : object {
    public static ILogger Logger;
    private static Regex FromDataAnonymousAssembly;
    [CompilerGeneratedAttribute]
private static Func`2<Stream, string> CS$<>9__CachedAnonymousMethodDelegatef;
    [CompilerGeneratedAttribute]
private static Action`1<FileSystemPath> CS$<>9__CachedAnonymousMethodDelegate19;
    [CompilerGeneratedAttribute]
private static Func`3<bool, FileSystemPath, bool> CS$<>9__CachedAnonymousMethodDelegate22;
    [CompilerGeneratedAttribute]
private static Func`3<bool, FileSystemPath, bool> CS$<>9__CachedAnonymousMethodDelegate28;
    private static FileSystemPathEx();
    [ExtensionAttribute]
[NotNullAttribute]
public static IEnumerable`1<FileSystemPath> GetParentDirectories(FileSystemPath path);
    [ExtensionAttribute]
[NotNullAttribute]
public static ICollection`1<FileSystemPath> GetChildDirectories(FileSystemPath path, string mask, PathSearchFlags flags, FileSystemPathInternStrategy internStrategy);
    [ExtensionAttribute]
[PureAttribute]
[NotNullAttribute]
public static ICollection`1<DirectoryEntryData> GetChildren(FileSystemPath path, string mask, PathSearchFlags flags);
    [NotNullAttribute]
[PureAttribute]
[ExtensionAttribute]
public static IList`1<FileSystemPath> GetChildFiles(FileSystemPath path, string mask, PathSearchFlags flags, FileSystemPathInternStrategy internStrategy);
    [ExtensionAttribute]
[ContractAnnotationAttribute("path:null => true")]
public static bool IsNullOrEmpty(FileSystemPath path);
    [ExtensionAttribute]
[ContractAnnotationAttribute("path:null => true")]
public static bool IsNullOrEmpty(RelativePath path);
    [ExtensionAttribute]
[ContractAnnotationAttribute("path:null => true")]
public static bool IsNullOrEmpty(IPath path);
    [ContractAnnotationAttribute("path:null => false")]
[ExtensionAttribute]
public static bool IsRelativeToDriveRoot(IPath path);
    [ExtensionAttribute]
public static RelativePath ConvertToRelative(IPath path);
    [ExtensionAttribute]
public static DeferQuotedObject QuoteIfNeeded(FileSystemPath path);
    [ExtensionAttribute]
public static DeferQuotedObject QuoteIfNeeded(RelativePath path);
    [ExtensionAttribute]
public static DeferQuotedObject QuoteIfNeeded(BackSlashSeparatedRelativePath path);
    [NotNullAttribute]
[PureAttribute]
private static string NormalizeSeparators(string path, SeparatorStyle separatorStyle);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static string NormalizeSeparators(FileSystemPath path, SeparatorStyle separatorStyle);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static string NormalizeSeparators(RelativePath path, SeparatorStyle separatorStyle);
    [PureAttribute]
[NotNullAttribute]
[ExtensionAttribute]
public static string PathWithCurrentPlatformSeparators(RelativePath path);
    [NotNullAttribute]
[PureAttribute]
[ExtensionAttribute]
public static string PathWithCurrentPlatformSeparators(FileSystemPath path);
    [PureAttribute]
[NotNullAttribute]
public static string PathWithCurrentPlatformSeparators(string path);
    [NotNullAttribute]
[ExtensionAttribute]
public static FileSystemPath TryGetCaseSensitivePath(FileSystemPath path);
    [ExtensionAttribute]
[NotNullAttribute]
public static FileSystemPath ToFileSystemPath(Uri uri);
    [NotNullAttribute]
[ExtensionAttribute]
public static RelativePath ToRelativePath(Uri uri);
    [NotNullAttribute]
[ExtensionAttribute]
public static IPath ToRelativeOrAbsolutePath(Uri uri);
    [ExtensionAttribute]
public static FileSystemPath AddSuffix(FileSystemPath path, string suffix);
    [ExtensionAttribute]
public static FileSystemPath ToAbsolutePath(FileSystemPath this, FileSystemPath pathBaseForRelatives);
    [NotNullAttribute]
[ExtensionAttribute]
public static FileSystemPath GetPath(Assembly this);
    [NotNullAttribute]
[ExtensionAttribute]
public static FileSystemPath TryGetPath(Assembly this);
    [ExtensionAttribute]
public static void CopyDirectory(FileSystemPath sourceDirectoryPath, FileSystemPath destinationDirectoryPath, bool overwrite, ICollection`1<FileSystemPath> excludes);
    [ExtensionAttribute]
public static void Copy(FileSystemPath sourceDirectoryPath, FileSystemPath destinationDirectoryPath, bool overwrite, ICollection`1<FileSystemPath> excludes);
    [NotNullAttribute]
[ExtensionAttribute]
[PureAttribute]
public static FileSystemPath ToFileSystemPath(SpecialFolder specialFolder);
    [NotNullAttribute]
[ExtensionAttribute]
[PureAttribute]
public static FileSystemPath Combine(SpecialFolder specialFolder, RelativePath other);
    public static bool WriteIfDirtyWithMoveAside(FileSystemPath path, string text, Encoding encoding);
    public static bool WriteIfDirtyWithMoveAside(FileSystemPath path, Byte[] bytes);
    public static bool WriteIfDirtyWithMoveAside(FileSystemPath path, Stream stream);
    [ExtensionAttribute]
public static bool HasWritePermissionOnDir(FileSystemPath fsp);
    [ExtensionAttribute]
public static void EnsureWritable(FileSystemPath fsp);
    [ExtensionAttribute]
public static void Delete(FileSystemPath path);
    [ExtensionAttribute]
public static void DeleteWithMoveAside(FileSystemPath path);
    private static void DeleteDirectoryWithMoveAside(FileSystemPath dirToDelete, FileSystemPath dirMoveAsideDestination, FileSystemPath& pathWithErrors);
    public static void DeleteFileWithMoveAside(FileSystemPath path, FileSystemPath dirMoveAsideDestination);
    private static void DoMoveAside(FileSystemPath path, FileSystemPath dirMoveAsideDestination);
    [ObsoleteAttribute("Call just Delete, it will do for all.")]
[ExtensionAttribute]
public static void DeleteDirectory(FileSystemPath path, int nRetryCount);
    private static void IOOperationWithRetry(Action action);
    [ExtensionAttribute]
public static void DeleteChildren(FileSystemPath path);
    [ExtensionAttribute]
public static bool CleanUpChildren(FileSystemPath path, ICollection`1<FileSystemPath> excludes);
    [ExtensionAttribute]
public static bool CleanUpDirectory(FileSystemPath path, ICollection`1<FileSystemPath> excludes);
    [ExtensionAttribute]
public static bool IsSuffixOf(RelativePath thіs, IPath otherPath);
    [ExtensionAttribute]
public static bool IsPrefixOf(FileSystemPath thіs, FileSystemPath otherPath);
    private static bool IsLocalRoot(FileSystemPath fsp);
    [ExtensionAttribute]
public static bool IsPrefixOf(RelativePath thіs, RelativePath otherPath);
    [ExtensionAttribute]
public static bool IsPrefixOf(BackSlashSeparatedRelativePath thіs, BackSlashSeparatedRelativePath otherPath);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
[ObsoleteAttribute("Removing the first component makes a path relative, so use RemoveFirstComponent2.")]
public static FileSystemPath RemoveFirstComponent(FileSystemPath thіs);
    [NotNullAttribute]
[ExtensionAttribute]
[PureAttribute]
public static RelativePath RemoveFirstComponent2(FileSystemPath thіs);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static RelativePath RemoveFirstComponent(RelativePath thіs);
    [NotNullAttribute]
[ExtensionAttribute]
[PureAttribute]
public static FileSystemPath RemovePrefix(FileSystemPath thіs, FileSystemPath prefix);
    [NotNullAttribute]
[PureAttribute]
[ExtensionAttribute]
public static RelativePath RemovePrefix(RelativePath thіs, RelativePath prefix);
    [ExtensionAttribute]
public static bool StartsWith(FileSystemPath thіs, FileSystemPath prefix);
    [ExtensionAttribute]
public static bool StartsWith(RelativePath thіs, RelativePath prefix);
    [ExtensionAttribute]
public static bool StartsWith(BackSlashSeparatedRelativePath thіs, BackSlashSeparatedRelativePath prefix);
    [ExtensionAttribute]
public static bool EndsWith(IPath thіs, RelativePath suffix);
    [ExtensionAttribute]
public static FileSystemPath WithTryValidate(FileSystemPath thіs);
    [ExtensionAttribute]
public static FileSystemPath WithValidate(FileSystemPath thіs);
    [ExtensionAttribute]
public static RelativePath WithTryValidate(RelativePath thіs);
    [ExtensionAttribute]
public static RelativePath WithValidate(RelativePath thіs);
    [NotNullAttribute]
private static string AppendTrailingPathSeparatorIfNeed(string path, string pathSeparator);
    [ExtensionAttribute]
[NotNullAttribute]
public static string FileAccessPathWithTrailingPathSeparator(FileSystemPath path);
    [ExtensionAttribute]
[NotNullAttribute]
public static string FullPathWithTrailingPathSeparator(FileSystemPath path);
    [NotNullAttribute]
[ExtensionAttribute]
public static string FullPathWithTrailingPathSeparator(RelativePath path);
    [NotNullAttribute]
[ExtensionAttribute]
public static string FullPathWithTrailingPathSeparator(BackSlashSeparatedRelativePath path);
    [ExtensionAttribute]
[NotNullAttribute]
public static FileSystemPath ExistedFile(FileSystemPath path, string message);
    [ExtensionAttribute]
[NotNullAttribute]
public static FileSystemPath ExistedDirectory(FileSystemPath path, string message);
    [CompilerGeneratedAttribute]
private static string <WriteIfDirtyWithMoveAside>b__e(Stream stream);
    [CompilerGeneratedAttribute]
private static void <DoMoveAside>b__17(FileSystemPath leftover);
    [CompilerGeneratedAttribute]
private static bool <CleanUpChildren>b__21(bool current, FileSystemPath childDirectory);
    [CompilerGeneratedAttribute]
private static bool <CleanUpDirectory>b__26(bool current, FileSystemPath childDirectory);
}
public class JetBrains.Util.FileSystemPathInternByConcurrentDictionary : object {
    private ConcurrentDictionary`2<string, FileSystemPath> myDictionary;
    public sealed virtual FileSystemPath GetOrCreate(string path, bool isPathAlreadyCanonical, Func`3<string, bool, FileSystemPath> createDelegate);
    public sealed virtual FileSystemPath TryGet(string path);
    public sealed virtual void Clear();
}
public class JetBrains.Util.FileSystemPathInternByDictionaryWithDoubleCheckLocking : object {
    private IDictionary`2<string, FileSystemPath> myDictionary;
    public sealed virtual FileSystemPath GetOrCreate(string path, bool isPathAlreadyCanonical, Func`3<string, bool, FileSystemPath> createDelegate);
    public sealed virtual FileSystemPath TryGet(string path);
    public sealed virtual void Clear();
}
public class JetBrains.Util.FileSystemPathInternByDirectMappedCache : object {
    private DirectMappedCache`2<string, FileSystemPath> myIntern;
    public FileSystemPathInternByDirectMappedCache(int maxEntries, ILogger logger);
    public sealed virtual void Clear();
    public sealed virtual FileSystemPath GetOrCreate(string path, bool isPathAlreadyCanonical, Func`3<string, bool, FileSystemPath> createDelegate);
    public sealed virtual FileSystemPath TryGet(string path);
}
public enum JetBrains.Util.FileSystemPathInternStrategy : Enum {
    public int value__;
    public static FileSystemPathInternStrategy INTERN;
    public static FileSystemPathInternStrategy TRY_GET_INTERNED_BUT_DO_NOT_INTERN;
    public static FileSystemPathInternStrategy DO_NOT_INTERN;
}
[ExtensionAttribute]
public static class JetBrains.Util.FileSystemPathOpenEx : object {
    [CompilerGeneratedAttribute]
private static Func`2<StreamReader, string> CS$<>9__CachedAnonymousMethodDelegate8;
    [CompilerGeneratedAttribute]
private static Func`2<StreamReader, string> CS$<>9__CachedAnonymousMethodDelegatec;
    [CompilerGeneratedAttribute]
private static Func`2<Stream, TextAndEncoding> CS$<>9__CachedAnonymousMethodDelegated;
    [ExtensionAttribute]
public static Stream OpenFileForAppend(FileSystemPath path);
    [ExtensionAttribute]
public static Stream OpenFileForAppendDenyWrite(FileSystemPath path);
    [ObsoleteAttribute("This is not Exclusive because it still allows Read, use *DenyWrite for this.")]
[ExtensionAttribute]
public static Stream OpenFileForAppendExclusive(FileSystemPath path);
    [ExtensionAttribute]
public static Stream OpenFileForReading(FileSystemPath path);
    [ExtensionAttribute]
public static Stream OpenFileForReadingDenyWrite(FileSystemPath path);
    [ExtensionAttribute]
[ObsoleteAttribute("This is not Exclusive because it still allows Read, use *DenyWrite for this.")]
public static Stream OpenFileForReadingExclusive(FileSystemPath path);
    [ExtensionAttribute]
public static Stream OpenFileForWriting(FileSystemPath path);
    [ExtensionAttribute]
public static Stream OpenFileForWritingDenyWrite(FileSystemPath path);
    [ExtensionAttribute]
public static Stream OpenFileForWritingExclusive(FileSystemPath path);
    [NotNullAttribute]
[ExtensionAttribute]
public static FileStream OpenStreamWithWaitingOnLock(FileSystemPath path, FileMode filemode, FileAccess fileaccess, FileShare fileshare, Nullable`1<TimeSpan> timeToWait);
    [ExtensionAttribute]
public static Byte[] ReadAllBytes(FileSystemPath file);
    [ExtensionAttribute]
[ObsoleteAttribute("Use ReadAllText2. This method has inconsistent treatment of encodings in automatic mode, see ReadAllText2 for details.")]
public static string ReadAllText(FileSystemPath file, Encoding encoding);
    [ExtensionAttribute]
public static TextAndEncoding ReadAllText2(FileSystemPath file, Encoding encoding);
    [ExtensionAttribute]
public static void ReadBinaryStream(FileSystemPath path, Action`1<BinaryReader> λRead);
    [ExtensionAttribute]
public static T ReadBinaryStream(FileSystemPath path, Func`2<BinaryReader, T> λRead);
    [ExtensionAttribute]
public static void ReadStream(FileSystemPath path, Action`1<Stream> λRead);
    [ExtensionAttribute]
public static T ReadStream(FileSystemPath path, Func`2<Stream, T> λRead);
    [ExtensionAttribute]
public static void ReadStreamDenyWrite(FileSystemPath path, Action`1<Stream> λRead);
    [ExtensionAttribute]
[ObsoleteAttribute("This is not Exclusive because it still allows Read, use *DenyWrite for this.")]
public static void ReadStreamExclusive(FileSystemPath path, Action`1<Stream> λRead);
    [ExtensionAttribute]
public static void ReadTextStream(FileSystemPath path, Action`1<StreamReader> λRead, Encoding encoding);
    [ExtensionAttribute]
public static T ReadTextStream(FileSystemPath path, Func`2<StreamReader, T> λRead, Encoding encoding);
    [ExtensionAttribute]
public static void WriteAllBytes(FileSystemPath file, Byte[] bytes);
    [ExtensionAttribute]
public static void WriteAllText(FileSystemPath file, string content, Encoding encoding);
    [ObsoleteAttribute("This method actually bears the DenyWrite semantic, which does not follow from its name. Use the *DenyWrite version explicitly.")]
[ExtensionAttribute]
public static void WriteBinaryStream(FileSystemPath path, Action`1<BinaryWriter> λWrite);
    [ExtensionAttribute]
public static void WriteBinaryStreamDenyWrite(FileSystemPath path, Action`1<BinaryWriter> λWrite);
    [ExtensionAttribute]
public static void WriteStream(FileSystemPath path, Action`1<Stream> λWrite);
    [ExtensionAttribute]
public static void WriteStreamDenyWrite(FileSystemPath path, Action`1<Stream> λWrite);
    [ExtensionAttribute]
public static void WriteStreamExclusive(FileSystemPath path, Action`1<Stream> λWrite);
    [ExtensionAttribute]
[ObsoleteAttribute("This method actually bears the DenyWrite semantic, which does not follow from its name. Use the *DenyWrite version explicitly.")]
public static void WriteTextStream(FileSystemPath path, Action`1<StreamWriter> λWrite);
    [ExtensionAttribute]
[ObsoleteAttribute("This method actually bears the DenyWrite semantic, which does not follow from its name. Use the *DenyWrite version explicitly.")]
public static void WriteTextStream(FileSystemPath path, Encoding encoding, Action`1<StreamWriter> λWrite);
    [ExtensionAttribute]
public static void WriteTextStreamDenyWrite(FileSystemPath path, Action`1<StreamWriter> λWrite);
    [ExtensionAttribute]
public static void WriteTextStreamDenyWrite(FileSystemPath path, Encoding encoding, Action`1<StreamWriter> λWrite);
    private static void EnsureFileDirectory(FileSystemPath path);
    [CompilerGeneratedAttribute]
private static string <ReadAllText>b__7(StreamReader r);
    [CompilerGeneratedAttribute]
private static string <ReadAllText2>b__a(StreamReader r);
    [CompilerGeneratedAttribute]
private static TextAndEncoding <ReadAllText2>b__b(Stream stream);
}
public static class JetBrains.Util.FileSystemPathParser : object {
    public static char DOT;
    private static MyPair InvalidPair;
    private static FileSystemPathParser();
    public static bool CanBeProvenNormalizedFast(string path, bool unrestrictedRelativePath);
    [NotNullAttribute]
public static string Normalize(string path, bool unrestrictedRelativePath);
    public static bool IsPathAbsolute(string path, bool unrestrictedRelativeMode);
    public static bool IsPathRelativeToDriveRoot(string path, bool unrestrictedRelativeMode);
    [CanBeNullAttribute]
public static string TryConvertToRelativePath(string pathToConvert, string basePath, bool isAbsolutePath, char currentSeparator);
}
public class JetBrains.Util.FileSystemPathSerializer : ValueSerializerBase`1<FileSystemPath> {
    [CompilerGeneratedAttribute]
private static Func`3<IValueSerializerContext, FileSystemPath, string> CS$<>9__CachedAnonymousMethodDelegate2;
    [CompilerGeneratedAttribute]
private static Func`3<IValueSerializerContext, string, FileSystemPath> CS$<>9__CachedAnonymousMethodDelegate3;
    [CompilerGeneratedAttribute]
private static string <.ctor>b__0(IValueSerializerContext context, FileSystemPath value);
    [CompilerGeneratedAttribute]
private static FileSystemPath <.ctor>b__1(IValueSerializerContext descriptorContext, string value);
}
public static class JetBrains.Util.FileSystemUtil : object {
    [CompilerGeneratedAttribute]
private static Func`3<StringBuilder, FileSystemPath, StringBuilder> CS$<>9__CachedAnonymousMethodDelegatef;
    public static bool DeleteDir(FileSystemPath path);
    public static void CopyFolders(FileSystemPath srcFolder, FileSystemPath dstFolder);
    [NotNullAttribute]
public static FileSystemPath GetSystemDirectory();
    [NotNullAttribute]
public static FileSystemPath GetCurrentDirectory();
    public static IDisposable SetCurrentDirectory(FileSystemPath path);
    public static void SetCurrentDirectory(Lifetime lifetime, FileSystemPath path);
    [NotNullAttribute]
public static FileSystemPath GetDirectoryNameOfFileAbove(FileSystemPath pathStartingPoint, string sMarkerFileName);
    [CanBeNullAttribute]
public static FileSystemPath TryGetDirectoryNameOfFileAbove(FileSystemPath pathStartingPoint, string sMarkerFileName);
    [NotNullAttribute]
public static FileSystemPath GetDirectoryNameOfItemAbove(FileSystemPath pathStartingPoint, RelativePath markerPath);
    [CanBeNullAttribute]
public static FileSystemPath TryGetDirectoryNameOfItemAbove(FileSystemPath pathStartingPoint, RelativePath markerPath);
    [CanBeNullAttribute]
private static FileSystemPath GetPathOnDiskWithCorrectCaseRec(FileSystemPath current, List`1<string> pathComponents);
    [CanBeNullAttribute]
public static FileSystemPath GetPathOnDiskWithCorrectCase(FileSystemPath path);
    [NotNullAttribute]
public static FileSystemPath GetFinalPathName(FileSystemPath path);
    [CompilerGeneratedAttribute]
private static StringBuilder <GetPathOnDiskWithCorrectCaseRec>b__e(StringBuilder sb, FileSystemPath fsp);
}
public class JetBrains.Util.FirstArgumentResult : object {
    [NotNullAttribute]
public string AnotherArguments;
    [NotNullAttribute]
public string FirstArgument;
    public FirstArgumentResult(string firstArgument, string anotherArguments);
}
public class JetBrains.Util.FrugalLocalHashSet`1 : ValueType {
    private T mySingleElement;
    private JetHashSet`1<T> myHashSet;
    private static T NULL;
    public bool IsEmpty { get; }
    public int Count { get; }
    public object SyncRoot { get; }
    public bool IsSynchronized { get; }
    public bool IsReadOnly { get; }
    private static FrugalLocalHashSet`1();
    public bool get_IsEmpty();
    public ElementEnumerator<T> GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    public bool Add(T item);
    public void AddRange(IEnumerable`1<T> array);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual bool Remove(T item);
    public void CopyTo(Array array, int index);
    public sealed virtual int get_Count();
    public object get_SyncRoot();
    public bool get_IsSynchronized();
    public sealed virtual bool get_IsReadOnly();
    public T[] ToArray();
    public T FirstOrDefault();
    public T First();
    public void UnionWith(IEnumerable`1<T> other);
    public void UnionWith(FrugalLocalHashSet`1<T> other);
}
public class JetBrains.Util.Graph.ComplexNode`1 : object {
    private JetHashSet`1<T> myCompositeNodes;
    public IEnumerable`1<T> Constituents { get; }
    public bool IsComposite { get; }
    public T SingleNode { get; }
    public object Element { get; }
    public ComplexNode`1(JetHashSet`1<T> compositeNodes);
    public IEnumerable`1<T> get_Constituents();
    public bool get_IsComposite();
    public T get_SingleNode();
    public object get_Element();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class JetBrains.Util.Graph.DirectedGraph`1 : object {
    private OneToSetMap`2<T, T> myOutgoing;
    private OneToSetMap`2<T, T> myIncoming;
    private JetHashSet`1<T> myNodes;
    private ICollection`1<T> myNodesCollection;
    private IEnumerable`1<T> JetBrains.Util.Graph.IDirectedGraph<T>.Nodes { get; }
    [NotNullAttribute]
public ICollection`1<T> Nodes { get; }
    public bool AddDependency(T from, T to);
    public virtual void RemoveDependency(T from, T to);
    public bool HasDependency(T from, T to);
    public virtual void RemoveAllIncoming(T to);
    public void RemoveAllIncoming(T to, Predicate`1<T> checkFrom);
    private sealed virtual override IEnumerable`1<T> JetBrains.Util.Graph.IDirectedGraph<T>.get_Nodes();
    public ICollection`1<T> get_Nodes();
    public sealed virtual IEnumerable`1<T> Outgoing(T node);
    public sealed virtual IEnumerable`1<T> Incoming(T node);
    [NotNullAttribute]
public IEnumerable`1<T> TryGetOutgoing(T node);
    [NotNullAttribute]
public IEnumerable`1<T> TryGetIncoming(T node);
    protected virtual bool RemoveNode(T node);
    protected virtual void Clear();
}
public class JetBrains.Util.Graph.DirectedGraphVirtualized`1 : object {
    private Func`2<TNode, IEnumerable`1<TNode>> myIncoming;
    private IEnumerable`1<TNode> myNodes;
    private Func`2<TNode, IEnumerable`1<TNode>> myOutgoing;
    private IEnumerable`1<TNode> JetBrains.Util.Graph.IDirectedGraph<TNode>.Nodes { get; }
    public DirectedGraphVirtualized`1(IEnumerable`1<TNode> allnodes, Func`2<TNode, IEnumerable`1<TNode>> incoming, Func`2<TNode, IEnumerable`1<TNode>> outgoing);
    private sealed virtual override IEnumerable`1<TNode> JetBrains.Util.Graph.IDirectedGraph<TNode>.Incoming(TNode node);
    private sealed virtual override IEnumerable`1<TNode> JetBrains.Util.Graph.IDirectedGraph<TNode>.Outgoing(TNode node);
    private sealed virtual override IEnumerable`1<TNode> JetBrains.Util.Graph.IDirectedGraph<TNode>.get_Nodes();
}
public class JetBrains.Util.Graph.FactorizedGraph`1 : ValueType {
    private IDirectedGraph`1<T> myOriginal;
    private JetHashSet`1<ComplexNode`1<T>> myComplexNodes;
    private Dictionary`2<T, ComplexNode`1<T>> myNodesFactorization;
    public IEnumerable`1<ComplexNode`1<T>> Nodes { get; }
    public FactorizedGraph`1(IDirectedGraph`1<T> original, JetHashSet`1<ComplexNode`1<T>> newNodes);
    public bool IsValid();
    public sealed virtual IEnumerable`1<ComplexNode`1<T>> get_Nodes();
    public sealed virtual IEnumerable`1<ComplexNode`1<T>> Outgoing(ComplexNode`1<T> complexNode);
    public sealed virtual IEnumerable`1<ComplexNode`1<T>> Incoming(ComplexNode`1<T> complexNode);
}
[ExtensionAttribute]
public static class JetBrains.Util.Graph.GraphAlgorithms : object {
    public static void DoNothing(T node);
    [ExtensionAttribute]
public static void DepthFirstSearch(IDirectedGraph`1<T> graph, DoBeforeProcessing`1<T> preProcessing, DoAfterProcessing`1<T> postProcessing);
    public static void DFS(IDirectedGraph`1<T> graph, T current, JetHashSet`1<T> processed, DoBeforeProcessing`1<T> preProcessing, DoAfterProcessing`1<T> postProcessing);
    [ExtensionAttribute]
public static void DepthFirstSearch(IDirectedGraph`1<TNode> graph, TNode start, PassingOnWayDownDelegate`1<TNode> FEnteringOnWayDown, Action`1<TNode> FPassingOnWayDownSimple, Action`1<TNode> FPassingOnWayUp);
    public static void DepthFirstSearch(IEnumerable`1<TNode> rootcollection, Func`2<TNode, IEnumerable`1<TNode>> FGetLinkedNodes, PassingOnWayDownDelegate`1<TNode> FEnteringOnWayDown, Action`1<TNode> FPassingOnWayDownSimple, Action`1<TNode> FPassingOnWayUp);
    [ExtensionAttribute]
public static IEnumerable`1<T> TopologicalSortedOrder(IDirectedGraph`1<T> graph);
    [ExtensionAttribute]
public static IDirectedGraph`1<T> Transpose(IDirectedGraph`1<T> graph);
    [ExtensionAttribute]
public static IDirectedGraph`1<ComplexNode`1<T>> StronglyConnectedComponentsGraph(IDirectedGraph`1<T> graph);
    [NotNullAttribute]
public static IList`1<TNode> FindShortestPath(IDirectedGraph`1<TNode> graph, TNode from, TNode to, Func`3<TNode, TNode, double> FWeightEdge);
}
public interface JetBrains.Util.Graph.IDirectedGraph`1 {
    [NotNullAttribute]
public IEnumerable`1<T> Nodes { get; }
    public abstract virtual IEnumerable`1<T> get_Nodes();
    [NotNullAttribute]
public abstract virtual IEnumerable`1<T> Outgoing(T node);
    [NotNullAttribute]
public abstract virtual IEnumerable`1<T> Incoming(T node);
}
public class JetBrains.Util.Graph.TransposedGraph`1 : ValueType {
    private IDirectedGraph`1<T> myOriginal;
    public IEnumerable`1<T> Nodes { get; }
    public TransposedGraph`1(IDirectedGraph`1<T> original);
    public sealed virtual IEnumerable`1<T> get_Nodes();
    public sealed virtual IEnumerable`1<T> Outgoing(T node);
    public sealed virtual IEnumerable`1<T> Incoming(T node);
}
[ExtensionAttribute]
public static class JetBrains.Util.Graphs.BiparititeGraphAlgorithms : object {
    private static object ourNilVertex;
    private static BiparititeGraphAlgorithms();
    [ExtensionAttribute]
public static ICollection`1<Pair`2<T1, T2>> MaximalMatching(IBipartiteGraph`2<T1, T2> graph);
    private static bool BFS(IBipartiteGraph`2<T1, T2> graph, Dictionary`2<object, object> pairs, Dictionary`2<object, int> distance);
    private static bool DFS(IBipartiteGraph`2<T1, T2> graph, Dictionary`2<object, object> pairs, Dictionary`2<object, int> distance, object vertex);
    private static IEnumerable`1<object> GetConnectedVertices(IBipartiteGraph`2<T1, T2> graph, object vertex);
}
public class JetBrains.Util.Graphs.BipartiteGraph`2 : object {
    private JetHashSet`1<T1> myFirstPartVertices;
    private JetHashSet`1<T2> mySecondPartVertices;
    private OneToSetMap`2<T1, T2> myEdges1;
    private OneToSetMap`2<T2, T1> myEdges2;
    public IEnumerable`1<T1> FirstPartVertices { get; }
    public IEnumerable`1<T2> SecondPartVertices { get; }
    public void AddEdge(T1 from, T2 to);
    public void RemoveEdge(T1 from, T2 to);
    public void RemoveVertice(T1 vertice);
    public void RemoveVertice(T2 vertice);
    public sealed virtual IEnumerable`1<T1> get_FirstPartVertices();
    public sealed virtual IEnumerable`1<T2> get_SecondPartVertices();
    public sealed virtual IEnumerable`1<T2> ConnectedVertices(T1 vertice);
    public sealed virtual IEnumerable`1<T1> ConnectedVertices(T2 vertice);
    public bool IsEmpty();
}
public interface JetBrains.Util.Graphs.IBipartiteGraph`2 {
    [NotNullAttribute]
public IEnumerable`1<T1> FirstPartVertices { get; }
    [NotNullAttribute]
public IEnumerable`1<T2> SecondPartVertices { get; }
    public abstract virtual IEnumerable`1<T1> get_FirstPartVertices();
    public abstract virtual IEnumerable`1<T2> get_SecondPartVertices();
    [NotNullAttribute]
public abstract virtual IEnumerable`1<T2> ConnectedVertices(T1 vertice);
    [NotNullAttribute]
public abstract virtual IEnumerable`1<T1> ConnectedVertices(T2 vertice);
}
[ExtensionAttribute]
public static class JetBrains.Util.GuidExtensions : object {
    private static int HexsToChars(Char* guidChars, int offset, int a, int b);
    private static char HexToChar(int a);
    public static Guid TryParseGuid(string value);
    [ExtensionAttribute]
public static string ToUpperString(Guid guid);
    [ExtensionAttribute]
public static string ToUpperCurlyString(Guid guid);
}
public interface JetBrains.Util.ICloneable`1 {
    [NotNullAttribute]
public abstract virtual T Clone();
}
public static class JetBrains.Util.IdentityFunc`1 : object {
    public static Func`2<T, T> Instance;
    public static Converter`2<T, T> Converter;
    [CompilerGeneratedAttribute]
private static Func`2<T, T> CS$<>9__CachedAnonymousMethodDelegate2;
    [CompilerGeneratedAttribute]
private static Converter`2<T, T> CS$<>9__CachedAnonymousMethodDelegate3;
    private static IdentityFunc`1();
    [CompilerGeneratedAttribute]
private static T <.cctor>b__0(T t);
    [CompilerGeneratedAttribute]
private static T <.cctor>b__1(T t);
}
public static class JetBrains.Util.IdentityFunc`2 : object {
    public static Func`2<T1, T2> Instance;
    public static Converter`2<T1, T2> Converter;
    [CompilerGeneratedAttribute]
private static Func`2<T1, T2> CS$<>9__CachedAnonymousMethodDelegate2;
    [CompilerGeneratedAttribute]
private static Converter`2<T1, T2> CS$<>9__CachedAnonymousMethodDelegate3;
    private static IdentityFunc`2();
    [CompilerGeneratedAttribute]
private static T2 <.cctor>b__0(T1 t);
    [CompilerGeneratedAttribute]
private static T2 <.cctor>b__1(T1 t);
}
public interface JetBrains.Util.IExceptionThrowingLogger {
    public abstract virtual void LogOrThrowException(Exception ex, ExceptionOrigin origin);
}
public interface JetBrains.Util.IFileSystemPathIntern {
    [CanBeNullAttribute]
public abstract virtual FileSystemPath TryGet(string path);
    [NotNullAttribute]
public abstract virtual FileSystemPath GetOrCreate(string path, bool isPathAlreadyCanonical, Func`3<string, bool, FileSystemPath> createDelegate);
    public abstract virtual void Clear();
}
public interface JetBrains.Util.IFsWriteHandler {
    public abstract virtual FileStreamWrapper OpenStream(FileSystemPath it, FileMode fileMode, FileAccess fileAccess, FileShare fileShare);
    public abstract virtual void DeleteDirectoryNonRecursive(FileSystemPath it, int nAttempts, Exception& ex);
    public abstract virtual FileSystemPath CreateDirectory(FileSystemPath it);
    public abstract virtual bool TryCreateNewDirectoryAtomic(FileSystemPath it);
    public abstract virtual void Move(FileSystemPath it, FileSystemPath dst);
    public abstract virtual void MoveFile(FileSystemPath it, FileSystemPath dst, bool overwrite);
    public abstract virtual void CopyFile(FileSystemPath it, FileSystemPath dst, bool overwrite);
    public abstract virtual void SetAttributes(FileSystemPath it, FileAttributes fileAttributes);
    public abstract virtual void SetFileModificationTimeUtc(FileSystemPath it, DateTime t);
    public abstract virtual void DeleteFile(FileSystemPath it);
    public abstract virtual void DeleteFile(FileSystemPath it, Boolean& isDirectory, int nAttempts);
}
public interface JetBrains.Util.ILogEventListener {
    public ILayout Layout { get; public set; }
    public abstract virtual ILayout get_Layout();
    public abstract virtual void set_Layout(ILayout value);
    public abstract virtual void OnLogEvent(LogEvent logEvent);
}
public interface JetBrains.Util.ILogger {
    public abstract virtual void Log(LogEvent logEvent);
}
[ExtensionAttribute]
public static class JetBrains.Util.ILoggerEx : object {
    [CompilerGeneratedAttribute]
private static Action CS$<>9__CachedAnonymousMethodDelegate12;
    [CompilerGeneratedAttribute]
private static Action CS$<>9__CachedAnonymousMethodDelegate18;
    [CompilerGeneratedAttribute]
private static Action CS$<>9__CachedAnonymousMethodDelegate1c;
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void LogBracket(ILogger thіs, Lifetime lifetime, LoggingLevel level, string message);
    [StringFormatMethodAttribute("message")]
[ExtensionAttribute]
public static void LogBracket(ILogger thіs, Lifetime lifetime, LoggingLevel level, string message, Object[] args);
    [ExtensionAttribute]
public static void LogBracket(ILogger thіs, Lifetime lifetime, LoggingLevel level, Pair`2<string, string> openingclosing);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static IDisposable LogBracket(ILogger thіs, LoggingLevel level, string message, Object[] args);
    [ExtensionAttribute]
public static ILogger GetSublogger(ILogger this, string subcategory);
    [ExtensionAttribute]
public static void LogExceptionSilently(ILogger thіs, Exception ex);
    [ExtensionAttribute]
public static IExceptionThrowingLogger ToExThrower(ILogger logger);
    [ExtensionAttribute]
public static void LogAssertion(ILogger thіs, Exception ex);
    [ExtensionAttribute]
public static void LogAssertion(ILogger thіs, string message);
    [StringFormatMethodAttribute("message")]
[ExtensionAttribute]
public static void LogAssertion(ILogger this, string message, T1 t1);
    [StringFormatMethodAttribute("message")]
[ExtensionAttribute]
public static void LogAssertion(ILogger this, string message, T1 t1, T2 t2);
    [StringFormatMethodAttribute("message")]
[ExtensionAttribute]
public static void LogAssertion(ILogger this, string message, T1 t1, T2 t2, T3 t3);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void LogAssertion(ILogger this, string message, T1 t1, T2 t2, T3 t3, T4 t4);
    [StringFormatMethodAttribute("message")]
[ExtensionAttribute]
public static void LogAssertion(ILogger this, string message, T1 t1, T2 t2, T3 t3, T4 t4, T5 t5);
    [StringFormatMethodAttribute("message")]
[ExtensionAttribute]
public static void LogAssertion(ILogger this, string message, Object[] args);
    [ExtensionAttribute]
public static void LogOuterDataException(ILogger thіs, Exception ex, string comment);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static void Catch(ILogger thіs, Action F, ExceptionOrigin origin);
    [HandleProcessCorruptedStateExceptionsAttribute]
[ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static void Catch(ILogger thіs, Action F, ExceptionOrigin origin, LoggingLevel loggingLevel);
    [DebuggerStepThroughAttribute]
[ExtensionAttribute]
public static TValue Catch(ILogger thіs, Func`1<TValue> F, ExceptionOrigin origin);
    [DebuggerStepThroughAttribute]
[HandleProcessCorruptedStateExceptionsAttribute]
[ExtensionAttribute]
public static TValue Catch(ILogger thіs, Func`1<TValue> F, ExceptionOrigin origin, LoggingLevel loggingLevel);
    [ExtensionAttribute]
[HandleProcessCorruptedStateExceptionsAttribute]
[DebuggerStepThroughAttribute]
public static Nullable`1<TValue> CatchNullable(ILogger thіs, Func`1<TValue> F, ExceptionOrigin origin);
    [DebuggerStepThroughAttribute]
[ExtensionAttribute]
public static void CatchAsAlgorithmError(ILogger thіs, Action F);
    [DebuggerStepThroughAttribute]
[ExtensionAttribute]
public static TValue CatchAsAlgorithmError(ILogger thіs, Func`1<TValue> F);
    [DebuggerStepThroughAttribute]
[ExtensionAttribute]
public static void CatchAsOuterDataError(ILogger thіs, Action F);
    [DebuggerStepThroughAttribute]
[ExtensionAttribute]
public static TValue CatchAsOuterDataError(ILogger thіs, Func`1<TValue> F);
    [ExtensionAttribute]
public static bool IsTraceEnabled(ILogger this);
    [ExtensionAttribute]
public static bool IsVersboseEnabled(ILogger this);
    [ExtensionAttribute]
public static bool IsInfoEnabled(ILogger this);
    [ExtensionAttribute]
public static bool IsWarnEnabled(ILogger this);
    [ExtensionAttribute]
public static bool IsErrorEnabled(ILogger this);
    [ExtensionAttribute]
public static void Error(ILogger this, Exception exception, ExceptionOrigin origin, string comment);
    [ExtensionAttribute]
public static void ErrorWithSensitiveData(ILogger this, string message, Pair`2[] sensitiveData);
    [ExtensionAttribute]
public static void Error(ILogger this, string message);
    [ExtensionAttribute]
public static void Error(ILogger this, Exception ex, string message);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void ErrorOuterWorld(ILogger logger, string message);
    [StringFormatMethodAttribute("message")]
[ExtensionAttribute]
public static void ErrorOuterWorld(ILogger logger, string message, T1 t1);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void ErrorOuterWorld(ILogger logger, string message, T1 t1, T2 t2);
    [StringFormatMethodAttribute("message")]
[ExtensionAttribute]
public static void Error(ILogger this, string message, T1 t1);
    [StringFormatMethodAttribute("message")]
[ExtensionAttribute]
public static void Error(ILogger this, string message, T1 t1, T2 t2);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void Error(ILogger this, string message, T1 t1, T2 t2, T3 t3);
    [StringFormatMethodAttribute("message")]
[ExtensionAttribute]
public static void Error(ILogger this, string message, T1 t1, T2 t2, T3 t3, T4 t4);
    [StringFormatMethodAttribute("message")]
[ExtensionAttribute]
public static void Error(ILogger this, string message, T1 t1, T2 t2, T3 t3, T4 t4, T5 t5);
    [StringFormatMethodAttribute("message")]
[ExtensionAttribute]
public static void Error(ILogger this, string message, Object[] args);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void Error(ILogger this, Exception ex, string message, T1 t1);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void Error(ILogger this, Exception ex, string message, T1 t1, T2 t2);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void Error(ILogger this, Exception ex, string message, T1 t1, T2 t2, T3 t3);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void Error(ILogger this, Exception ex, string message, T1 t1, T2 t2, T3 t3, T4 t4);
    [StringFormatMethodAttribute("message")]
[ExtensionAttribute]
public static void Error(ILogger this, Exception ex, string message, T1 t1, T2 t2, T3 t3, T4 t4, T5 t5);
    [StringFormatMethodAttribute("message")]
[ExtensionAttribute]
public static void Error(ILogger this, Exception ex, string message, Object[] args);
    [ExtensionAttribute]
public static void Warn(ILogger this, Exception exception, ExceptionOrigin origin, string comment);
    [StringFormatMethodAttribute("message")]
[ExtensionAttribute]
public static void Warn(ILogger this, string message);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void Warn(ILogger this, string message, T1 t1);
    [StringFormatMethodAttribute("message")]
[ExtensionAttribute]
public static void Warn(ILogger this, string message, T1 t1, T2 t2);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void Warn(ILogger this, string message, T1 t1, T2 t2, T3 t3);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void Warn(ILogger this, string message, T1 t1, T2 t2, T3 t3, T4 t4);
    [StringFormatMethodAttribute("message")]
[ExtensionAttribute]
public static void Warn(ILogger this, string message, Object[] args);
    [ExtensionAttribute]
public static void Info(ILogger this, string message);
    [StringFormatMethodAttribute("message")]
[ExtensionAttribute]
public static void Info(ILogger this, string message, Object[] parameters);
    [StringFormatMethodAttribute("message")]
[ExtensionAttribute]
public static void Info(ILogger this, string message, T1 t1);
    [StringFormatMethodAttribute("message")]
[ExtensionAttribute]
public static void Info(ILogger this, string message, T1 t1, T2 t2);
    [StringFormatMethodAttribute("message")]
[ExtensionAttribute]
public static void Info(ILogger this, string message, T1 t1, T2 t2, T3 t3);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void Info(ILogger this, string message, T1 t1, T2 t2, T3 t3, T4 t4);
    [ExtensionAttribute]
public static void Verbose(ILogger this, Exception exception, ExceptionOrigin origin, string comment);
    [ExtensionAttribute]
public static void Verbose(ILogger this, string message);
    [StringFormatMethodAttribute("message")]
[ExtensionAttribute]
public static void Verbose(ILogger this, string message, T1 t1);
    [StringFormatMethodAttribute("message")]
[ExtensionAttribute]
public static void Verbose(ILogger this, string message, T1 t1, T2 t2);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void Verbose(ILogger this, string message, T1 t1, T2 t2, T3 t3);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void Verbose(ILogger this, string message, T1 t1, T2 t2, T3 t3, T4 t4);
    [StringFormatMethodAttribute("message")]
[ExtensionAttribute]
public static void Verbose(ILogger this, string message, T1 t1, T2 t2, T3 t3, T4 t4, T5 t5);
    [StringFormatMethodAttribute("message")]
[ExtensionAttribute]
public static void Verbose(ILogger this, string message, T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6);
    [StringFormatMethodAttribute("message")]
[ExtensionAttribute]
public static void Verbose(ILogger this, string message, Object[] args);
    [ExtensionAttribute]
public static void Trace(ILogger this, Exception exception, ExceptionOrigin origin, string comment);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void Trace(ILogger this, string message);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void Trace(ILogger this, string message, T1 t1);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void Trace(ILogger this, string message, T1 t1, T2 t2);
    [StringFormatMethodAttribute("message")]
[ExtensionAttribute]
public static void Trace(ILogger this, string message, T1 t1, T2 t2, T3 t3);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void Trace(ILogger this, string message, T1 t1, T2 t2, T3 t3, T4 t4);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void Trace(ILogger this, string message, T1 t1, T2 t2, T3 t3, T4 t4, T5 t5);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void Trace(ILogger this, string message, T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6);
    [ExtensionAttribute]
public static void LogException(ILogger this, LoggingLevel level, Exception exception, ExceptionOrigin exceptionOrigin, string comment);
    [ExtensionAttribute]
public static void LogMessage(ILogger this, LoggingLevel level, string message);
    [ExtensionAttribute]
public static void LogMessageWithSensitiveData(ILogger this, LoggingLevel level, string message, Pair`2[] sensitiveData);
    [StringFormatMethodAttribute("message")]
[ExtensionAttribute]
public static void LogMessage(ILogger this, LoggingLevel level, string message, T1 t1);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void LogMessage(ILogger this, LoggingLevel level, string message, T1 t1, T2 t2);
    [StringFormatMethodAttribute("message")]
[ExtensionAttribute]
public static void LogMessage(ILogger this, LoggingLevel level, string message, T1 t1, T2 t2, T3 t3);
    [StringFormatMethodAttribute("message")]
[ExtensionAttribute]
public static void LogMessage(ILogger this, LoggingLevel level, string message, T1 t1, T2 t2, T3 t3, T4 t4);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void LogMessage(ILogger this, LoggingLevel level, string message, Object[] args);
    [HandleProcessCorruptedStateExceptionsAttribute]
[DebuggerStepThroughAttribute]
[ExtensionAttribute]
public static void CatchSilent(ILogger thіs, Action action);
    [HandleProcessCorruptedStateExceptionsAttribute]
[ExtensionAttribute]
[DebuggerStepThroughAttribute]
[CanBeNullAttribute]
public static TValue CatchSilent(ILogger thіs, Func`1<TValue> F);
    [DebuggerStepThroughAttribute]
[ExtensionAttribute]
[HandleProcessCorruptedStateExceptionsAttribute]
public static void CatchIgnore(ILogger thіs, Action action);
    [CanBeNullAttribute]
[DebuggerStepThroughAttribute]
[HandleProcessCorruptedStateExceptionsAttribute]
[ExtensionAttribute]
public static TValue CatchIgnore(ILogger thіs, Func`1<TValue> F);
    [DebuggerStepThroughAttribute]
[ExtensionAttribute]
public static void DropException(ILogger thіs, Exception ex);
    [EditorBrowsableAttribute("1")]
[ExtensionAttribute]
public static bool LogFailedHResult(int hresult, string message);
    [ExtensionAttribute]
public static bool LogFailedHResult(HResults hresult, string message);
    [CompilerGeneratedAttribute]
private static void <Catch>b__11();
    [CompilerGeneratedAttribute]
private static TValue <Catch>b__13();
    [CompilerGeneratedAttribute]
private static TValue <CatchNullable>b__15();
    [CompilerGeneratedAttribute]
private static void <CatchSilent>b__17();
    [CompilerGeneratedAttribute]
private static TValue <CatchSilent>b__19();
    [CompilerGeneratedAttribute]
private static void <CatchIgnore>b__1b();
    [CompilerGeneratedAttribute]
private static TValue <CatchIgnore>b__1d();
}
public class JetBrains.Util.InvalidPathException : Exception {
    public InvalidPathException(string path);
    [StringFormatMethodAttribute("format")]
public InvalidPathException(string format, Object[] args);
    protected InvalidPathException(SerializationInfo info, StreamingContext context);
}
public interface JetBrains.Util.IOneToManyMap`3 {
    public ICollection`1<TKey> Keys { get; }
    public abstract virtual TCollection GetValuesSafe(TKey key);
    public abstract virtual void Add(TKey key, TValue value);
    public abstract virtual bool Remove(TKey key, TValue value);
    public abstract virtual ICollection`1<TKey> get_Keys();
}
public interface JetBrains.Util.IPath {
    [NotNullAttribute]
public IPath Empty { get; }
    [NotNullAttribute]
public string ExtensionNoDot { get; }
    [NotNullAttribute]
public string ExtensionWithDot { get; }
    [NotNullAttribute]
public string FirstComponent { get; }
    [NotNullAttribute]
public string FullPath { get; }
    public bool IsAbsolute { get; }
    public bool IsEmpty { get; }
    [NotNullAttribute]
public string Name { get; }
    [NotNullAttribute]
public string NameWithoutExtension { get; }
    public bool IsValidOnCurrentOS { get; }
    [NotNullAttribute]
public IPath Parent { get; }
    public abstract virtual IPath get_Empty();
    public abstract virtual string get_ExtensionNoDot();
    public abstract virtual string get_ExtensionWithDot();
    public abstract virtual string get_FirstComponent();
    public abstract virtual string get_FullPath();
    public abstract virtual bool get_IsAbsolute();
    public abstract virtual bool get_IsEmpty();
    public abstract virtual string get_Name();
    public abstract virtual string get_NameWithoutExtension();
    public abstract virtual bool get_IsValidOnCurrentOS();
    public abstract virtual IPath get_Parent();
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IPath Combine(RelativePath other);
    [NotNullAttribute]
public abstract virtual IPath Parse(string text);
    [NotNullAttribute]
public abstract virtual Uri ToDirectoryUri();
    [NotNullAttribute]
public abstract virtual Uri ToUri();
    [NotNullAttribute]
public abstract virtual IPath TryCombine(string component);
    [NotNullAttribute]
public abstract virtual String[] GetPathComponents();
}
[ExtensionAttribute]
public static class JetBrains.Util.IPathEx : object {
    [ObsoleteAttribute("Use MakeAbsoluteBasedOn.")]
[NotNullAttribute]
[ExtensionAttribute]
public static FileSystemPath AsAbsolute(IPath thіs, FileSystemPath pathBaseForRelative);
    [ExtensionAttribute]
[NotNullAttribute]
public static FileSystemPath MakeAbsoluteBasedOn(IPath thіs, FileSystemPath pathBaseForRelative);
    [NotNullAttribute]
public static IPath AddSuffix(IPath path, string suffix);
    [NotNullAttribute]
private static string ChangeExtensionInt(IPath path, string newExtensionNormalized);
    [NotNullAttribute]
[ExtensionAttribute]
[PureAttribute]
public static FileSystemPath ChangeExtension(FileSystemPath path, string newExtension, FileSystemPathInternStrategy internStrategy);
    [PureAttribute]
[NotNullAttribute]
[ExtensionAttribute]
public static RelativePath ChangeExtension(RelativePath path, string newExtension);
    [CanBeNullAttribute]
[ExtensionAttribute]
public static FileSystemPath AsAbsolute(IPath thіs);
    [NotNullAttribute]
[ExtensionAttribute]
public static FileSystemPath AssertAbsolute(IPath thіs);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static RelativePath AsRelative(IPath thіs);
    [ExtensionAttribute]
[NotNullAttribute]
public static RelativePath AssertRelative(IPath thіs);
}
public interface JetBrains.Util.IUserDataHolder {
    [PureAttribute]
[CanBeNullAttribute]
public abstract virtual T GetData(Key`1<T> key);
    public abstract virtual void PutData(Key`1<T> key, T value);
    [MustUseReturnValueAttribute]
public abstract virtual T GetOrCreateDataUnderLock(Key`1<T> key, Func`1<T> factory);
    [MustUseReturnValueAttribute]
public abstract virtual T GetOrCreateDataUnderLock(Key`1<T> key, TState state, Func`2<TState, T> factory);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IEnumerable`1<KeyValuePair`2<object, object>> EnumerateData();
}
public abstract class JetBrains.Util.JetFileSystemWatcher : object {
    public static int TotalBuffers;
    public FileSystemPath Directory { get; }
    public bool IncludeSubdirectories { get; }
    public PathWildcard Filter { get; }
    public NotifyFilters NotifyFilters { get; }
    public bool Disposed { get; }
    public abstract virtual void Dispose();
    [CanBeNullAttribute]
public static JetFileSystemWatcher Create(FileSystemPath path, string filter, NotifyFilters notifyFilter, bool includeSubdirectories, IWatcherEvents watcherEvents, WinError& rc);
    public abstract virtual FileSystemPath get_Directory();
    public abstract virtual bool get_IncludeSubdirectories();
    public abstract virtual PathWildcard get_Filter();
    public abstract virtual NotifyFilters get_NotifyFilters();
    public abstract virtual bool get_Disposed();
}
public static class JetBrains.Util.JetFunc : object {
    [NotNullAttribute]
public static Func`1<bool> True;
    [NotNullAttribute]
public static Func`1<bool> False;
    [CompilerGeneratedAttribute]
private static Func`1<bool> CS$<>9__CachedAnonymousMethodDelegate2;
    [CompilerGeneratedAttribute]
private static Func`1<bool> CS$<>9__CachedAnonymousMethodDelegate3;
    private static JetFunc();
    [CompilerGeneratedAttribute]
private static bool <.cctor>b__0();
    [CompilerGeneratedAttribute]
private static bool <.cctor>b__1();
}
public static class JetBrains.Util.JetFunc`1 : object {
    [NotNullAttribute]
public static Func`2<T, bool> True;
    [NotNullAttribute]
public static Func`2<T, bool> False;
    [NotNullAttribute]
public static Func`2<T, T> Identity;
    [NotNullAttribute]
public static Converter`2<T, T> IdentityConverter;
    [CompilerGeneratedAttribute]
private static Func`2<T, bool> CS$<>9__CachedAnonymousMethodDelegate4;
    [CompilerGeneratedAttribute]
private static Func`2<T, bool> CS$<>9__CachedAnonymousMethodDelegate5;
    [CompilerGeneratedAttribute]
private static Func`2<T, T> CS$<>9__CachedAnonymousMethodDelegate6;
    [CompilerGeneratedAttribute]
private static Converter`2<T, T> CS$<>9__CachedAnonymousMethodDelegate7;
    private static JetFunc`1();
    [CompilerGeneratedAttribute]
private static bool <.cctor>b__0(T t);
    [CompilerGeneratedAttribute]
private static bool <.cctor>b__1(T t);
    [CompilerGeneratedAttribute]
private static T <.cctor>b__2(T t);
    [CompilerGeneratedAttribute]
private static T <.cctor>b__3(T t);
}
public static class JetBrains.Util.JetFunc`2 : object {
    [NotNullAttribute]
public static Func`3<T1, T2, bool> True;
    [NotNullAttribute]
public static Func`3<T1, T2, bool> False;
    [CompilerGeneratedAttribute]
private static Func`3<T1, T2, bool> CS$<>9__CachedAnonymousMethodDelegate2;
    [CompilerGeneratedAttribute]
private static Func`3<T1, T2, bool> CS$<>9__CachedAnonymousMethodDelegate3;
    private static JetFunc`2();
    [CompilerGeneratedAttribute]
private static bool <.cctor>b__0(T1 t1, T2 t2);
    [CompilerGeneratedAttribute]
private static bool <.cctor>b__1(T1 t1, T2 t2);
}
[DebuggerDisplayAttribute("Count = {Count}")]
public class JetBrains.Util.JetReadOnlyCollection`1 : object {
    [NotNullAttribute]
private ICollection`1<T> myCollection;
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    public JetReadOnlyCollection`1(ICollection`1<T> collection);
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual int get_Count();
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.Remove(T item);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
}
[DebuggerDisplayAttribute("Count = {Count}")]
public class JetBrains.Util.JetReadOnlySet`1 : object {
    [NotNullAttribute]
private ISet`1<T> mySet;
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    public JetReadOnlySet`1(ISet`1<T> set);
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual int get_Count();
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.Remove(T item);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    public sealed virtual bool Add(T item);
    public sealed virtual void UnionWith(IEnumerable`1<T> other);
    public sealed virtual void IntersectWith(IEnumerable`1<T> other);
    public sealed virtual void ExceptWith(IEnumerable`1<T> other);
    public sealed virtual void SymmetricExceptWith(IEnumerable`1<T> other);
    public sealed virtual bool IsSubsetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsSupersetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsProperSupersetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsProperSubsetOf(IEnumerable`1<T> other);
    public sealed virtual bool Overlaps(IEnumerable`1<T> other);
    public sealed virtual bool SetEquals(IEnumerable`1<T> other);
}
public class JetBrains.Util.JetWeakReference`1 : WeakReference {
    private int myHashCode;
    [CanBeNullAttribute]
public T Target { get; public set; }
    public JetWeakReference`1(T target);
    public T get_Target();
    public void set_Target(T value);
    public sealed virtual bool Equals(T other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[DebuggerDisplayAttribute("Key: {ToString()}")]
public class JetBrains.Util.Key : Key`1<object> {
    public Key(string text);
}
[DebuggerDisplayAttribute("Key: {ToString()}")]
public class JetBrains.Util.Key`1 : object {
    private string myText;
    public Key`1(string text);
    public virtual string ToString();
}
public static class JetBrains.Util.Lazy : object {
    [PureAttribute]
[NotNullAttribute]
[ObsoleteAttribute("Please, use overload with explicit threading mode flag")]
public static Lazy`1<T> Of(Func`1<T> valueFactory);
    [NotNullAttribute]
[PureAttribute]
public static Lazy`1<T> Of(Func`1<T> valueFactory, bool isThreadSafe);
    [ObsoleteAttribute("Please, use overload with explicit threading mode flag")]
[NotNullAttribute]
[PureAttribute]
public static Lazy`1<T> Of();
    [PureAttribute]
[NotNullAttribute]
public static Lazy`1<T> Of(bool isThreadSafe);
    [PureAttribute]
[NotNullAttribute]
public static Lazy`1<T> Of(T value);
}
internal static class JetBrains.Util.LibcNativeInterop : object {
    public static UInt32 geteuid();
    public static int mkdir(string pathname, UnixFileModes mode);
    public static int chmod(string pathname, UnixFileModes mode);
    public static int access(string pathname, LibcAccessModes mode);
    public static IntPtr realpath(string path, StringBuilder resolved_path);
    public static int uname(IntPtr buf);
    public static int kill(int pid, int sig);
}
public class JetBrains.Util.LocalHashSet`1 : ValueType {
    private JetHashSet`1<T> myHashSet;
    [CanBeNullAttribute]
public JetHashSet`1<T> HashSet { get; }
    public bool IsEmpty { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public JetHashSet`1<T> get_HashSet();
    public bool get_IsEmpty();
    public void AddRange(IEnumerable`1<T> array);
    public void UnionWith(IEnumerable`1<T> array);
    public void ExceptWith(IEnumerable`1<T> array);
    public void ExceptWith(LocalHashSet`1<T> array);
    public T[] ToArray();
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    public bool Add(T t);
    public sealed virtual bool Contains(T t);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    public ElementEnumerator<T> GetEnumerator();
    public sealed virtual bool Remove(T element);
    public sealed virtual void Clear();
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
}
[DebuggerTypeProxyAttribute("JetBrains.Util.LocalListDebugView`1")]
[DebuggerDisplayAttribute("Count = {Count}")]
[DefaultMemberAttribute("Item")]
public class JetBrains.Util.LocalList`1 : ValueType {
    private static int DefaultFirstSize;
    private T[] myArray;
    private int myCount;
    private int myNextSize;
    private int myVersion;
    public int Count { get; }
    public int Capacity { get; }
    public T Item { get; public set; }
    [CanBeNullAttribute]
public T SingleItem { get; }
    public LocalList`1(int size);
    public LocalList`1(IEnumerable`1<T> enumerable);
    public LocalList`1(T[] array, bool copyArray);
    public int get_Count();
    public int get_Capacity();
    public T get_Item(int index);
    public void set_Item(int index, T value);
    [PureAttribute]
public bool Any();
    [PureAttribute]
public bool Any(Func`2<T, bool> predicate);
    [PureAttribute]
public T Last();
    [PureAttribute]
public T First();
    [PureAttribute]
public T Single();
    public T get_SingleItem();
    [PureAttribute]
public T FirstOrDefault();
    [PureAttribute]
public T LastOrDefault();
    public void Add(T item);
    public void AddRange(IEnumerable`1<TSource> items);
    public void AddRange(IEnumerable`1<T> items);
    public void AddRange(LocalList`1<T> items);
    public void AddRange(FrugalLocalList`1<T> items);
    public void AddRange(TSource[] items);
    private void AddRange(TSource[] items, int length);
    public void AddRange(ICollection`1<T> items);
    private int CalculateNewAndNextSize(int currentSize, int capacity);
    public void EnsureCapacity(int capacity, bool exact);
    public bool Remove(T item);
    [PureAttribute]
public bool Contains(T item);
    [NotNullAttribute]
[PureAttribute]
public T[] ToArray();
    [PureAttribute]
[NotNullAttribute]
public TResult[] ToArray(Func`2<T, TResult> transform);
    public void CopyTo(T[] array, int arrayIndex);
    public void Clear();
    [PureAttribute]
public int IndexOf(T item);
    public void InsertRange(int index, LocalList`1<T> items);
    public void InsertRange(int atIndex, TSource[] items, int startingFrom, int length);
    public void Insert(int index, T item);
    public void RemoveAt(int index);
    public void UnstableSortInplace(IComparer`1<T> comparer);
    public void UnstableSortInplace(int index, int length, IComparer`1<T> comparer);
    [PureAttribute]
public ElementEnumerator<T> GetEnumerator();
    [PureAttribute]
[NotNullAttribute]
public IList`1<T> ResultingList();
    [NotNullAttribute]
[PureAttribute]
public IReadOnlyList`1<T> ReadOnlyList();
    public virtual string ToString();
}
internal class JetBrains.Util.LocalListDebugView`1 : object {
    private LocalList`1<T> myList;
    [DebuggerBrowsableAttribute("3")]
[NotNullAttribute]
public T[] Items { get; }
    public LocalListDebugView`1(LocalList`1<T> set);
    public T[] get_Items();
}
public class JetBrains.Util.Locator`1 : MulticastDelegate {
    public Locator`1(object object, IntPtr method);
    public virtual int Invoke(T leftside);
    public virtual IAsyncResult BeginInvoke(T leftside, AsyncCallback callback, object object);
    public virtual int EndInvoke(IAsyncResult result);
}
public class JetBrains.Util.LogCookie : ValueType {
    private string myComment;
    public LogCookie(string comment);
    public static void Execute(string comment, Action F);
    public sealed virtual void Dispose();
}
public class JetBrains.Util.LogEvent : object {
    [CanBeNullAttribute]
private string myShortMessage;
    [CanBeNullAttribute]
private string myFullMessage;
    [CompilerGeneratedAttribute]
private LoggingLevel <Level>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Category>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <Timestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private Thread <Thread>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OriginalMessage>k__BackingField;
    [CompilerGeneratedAttribute]
private LoggerException <Exception>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ExceptionOrigin> <ExceptionOrigin>k__BackingField;
    public LoggingLevel Level { get; private set; }
    [NotNullAttribute]
public string Category { get; private set; }
    public DateTime Timestamp { get; private set; }
    [NotNullAttribute]
public Thread Thread { get; private set; }
    [CanBeNullAttribute]
public string OriginalMessage { get; private set; }
    [CanBeNullAttribute]
public LoggerException Exception { get; private set; }
    [CanBeNullAttribute]
public Nullable`1<ExceptionOrigin> ExceptionOrigin { get; private set; }
    [CanBeNullAttribute]
public string ShortExceptionText { get; }
    [CanBeNullAttribute]
public string FullExceptionText { get; }
    [CanBeNullAttribute]
public string FullExceptionTextWithSensitiveData { get; }
    [CanBeNullAttribute]
public string ShortMessage { get; }
    [CanBeNullAttribute]
public string FullMessage { get; }
    public string FullMessageWithSensitiveData { get; }
    [CanBeNullAttribute]
public Exception OriginalException { get; }
    private LogEvent(LoggingLevel level, string category, DateTime timestamp, Thread thread, string originalMessage, LoggerException exception, Nullable`1<ExceptionOrigin> exorigin);
    [CompilerGeneratedAttribute]
public LoggingLevel get_Level();
    [CompilerGeneratedAttribute]
private void set_Level(LoggingLevel value);
    [CompilerGeneratedAttribute]
public string get_Category();
    [CompilerGeneratedAttribute]
private void set_Category(string value);
    [CompilerGeneratedAttribute]
public DateTime get_Timestamp();
    [CompilerGeneratedAttribute]
private void set_Timestamp(DateTime value);
    [CompilerGeneratedAttribute]
public Thread get_Thread();
    [CompilerGeneratedAttribute]
private void set_Thread(Thread value);
    [CompilerGeneratedAttribute]
public string get_OriginalMessage();
    [CompilerGeneratedAttribute]
private void set_OriginalMessage(string value);
    [CompilerGeneratedAttribute]
public LoggerException get_Exception();
    [CompilerGeneratedAttribute]
private void set_Exception(LoggerException value);
    [CompilerGeneratedAttribute]
public Nullable`1<ExceptionOrigin> get_ExceptionOrigin();
    [CompilerGeneratedAttribute]
private void set_ExceptionOrigin(Nullable`1<ExceptionOrigin> value);
    public static LogEvent CreateWithException(LoggingLevel level, string category, Exception exception, ExceptionOrigin exceptionOrigin, string comment);
    public static LogEvent CreateWithMessage(LoggingLevel level, string category, string message, Nullable`1<ExceptionOrigin> origin);
    public static LogEvent CreateWithMessageAndSensitiveData(LoggingLevel level, string category, string message, Pair`2[] sensitiveData, Nullable`1<ExceptionOrigin> origin);
    public static LogEvent CreateWithMessageAndSensitiveData(LoggingLevel level, string category, string message, Pair`2<string, object> d1, Nullable`1<ExceptionOrigin> origin);
    public string get_ShortExceptionText();
    public string get_FullExceptionText();
    public string get_FullExceptionTextWithSensitiveData();
    public string get_ShortMessage();
    public string get_FullMessage();
    public string get_FullMessageWithSensitiveData();
    public Exception get_OriginalException();
}
public abstract class JetBrains.Util.LoggerBase : object {
    [CompilerGeneratedAttribute]
private string <Category>k__BackingField;
    public string Category { get; protected set; }
    public abstract virtual bool IsEnabled(LoggingLevel level);
    public abstract virtual void Log(LogEvent logEvent);
    [CompilerGeneratedAttribute]
public virtual string get_Category();
    [CompilerGeneratedAttribute]
protected virtual void set_Category(string value);
    public sealed virtual void Log(LoggingLevel level, string message, Exception ex);
}
public class JetBrains.Util.LoggerException : ApplicationException {
    private ToStringBehavior myToStringBehavior;
    private string myStackTrace;
    public string StackTrace { get; }
    public LoggerException(string message, Exception innerException, Nullable`1<int> ignoreFrames, ToStringBehavior toStringBehavior, string sOverrideStackTrace);
    [UsedImplicitlyAttribute]
protected LoggerException(SerializationInfo info, StreamingContext context);
    private static string ChooseMessage(string details, Exception innerException);
    private void CaptureStackTrace(int ignoreFrames);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual string ToString();
    public virtual string get_StackTrace();
    [NotNullAttribute]
public static LoggerException WrapException(Exception ex, string comment);
}
public class JetBrains.Util.Logging.AnonymousLogger : LoggerBase {
    [NotNullAttribute]
private string myCategory;
    [NotNullAttribute]
private Action`1<LogEvent> myLog;
    private LoggingLevel myMaxLoggingLevel;
    public string Category { get; }
    public AnonymousLogger(LoggingLevel maxLoggingLevel, string category, Action`1<LogEvent> log);
    public virtual void Log(LogEvent logEvent);
    public virtual string get_Category();
    public virtual bool IsEnabled(LoggingLevel level);
}
public class JetBrains.Util.Logging.AppenderModel : object {
    internal static string AppenderEltName;
    [CanBeNullAttribute]
private ILogEventListener myBuildedItem;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <Params>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Pattern>k__BackingField;
    [CompilerGeneratedAttribute]
private static Func`2<XmlElement, bool> CS$<>9__CachedAnonymousMethodDelegate2;
    [CompilerGeneratedAttribute]
private static Func`2<XmlElement, string> CS$<>9__CachedAnonymousMethodDelegate3;
    [NotNullAttribute]
public string Name { get; private set; }
    [NotNullAttribute]
public Type Type { get; private set; }
    [NotNullAttribute]
public List`1<string> Params { get; private set; }
    [NotNullAttribute]
public string Pattern { get; private set; }
    [NotNullAttribute]
public ILogEventListener BuildedItem { get; }
    public AppenderModel(string name, Type type, string pattern, IEnumerable`1<string> parameters);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public Type get_Type();
    [CompilerGeneratedAttribute]
private void set_Type(Type value);
    [CompilerGeneratedAttribute]
public List`1<string> get_Params();
    [CompilerGeneratedAttribute]
private void set_Params(List`1<string> value);
    [CompilerGeneratedAttribute]
public string get_Pattern();
    [CompilerGeneratedAttribute]
private void set_Pattern(string value);
    public virtual ILogEventListener get_BuildedItem();
    public sealed virtual bool Equals(AppenderModel other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static AppenderModel LoadFromXml(XmlElement elt);
    public void StoreToXml(XmlElement parent);
    public static AppenderModel LoadFromBinary(BinaryReader reader);
    public void StoreToBinary(BinaryWriter writer);
    private sealed virtual override object System.ICloneable.Clone();
    public sealed virtual AppenderModel Clone();
    [CompilerGeneratedAttribute]
private static bool <LoadFromXml>b__0(XmlElement _);
    [CompilerGeneratedAttribute]
private static string <LoadFromXml>b__1(XmlElement _);
}
public class JetBrains.Util.Logging.ConfiguredLogger : LoggerBase {
    private object myCategoryProvider;
    private LogConfNode myLogConfNode;
    private string myCategory;
    public string Category { get; }
    private ConfiguredLogger(object category);
    internal ConfiguredLogger(Type namespaceTypeProvider);
    internal ConfiguredLogger(string namespaceStringProvider);
    private void OptionallyReconfigure();
    private string CalcCategory();
    private bool FilterchainAccepts(IFilter[] filterchain, LogEvent logEvent);
    [HandleProcessCorruptedStateExceptionsAttribute]
public virtual void Log(LogEvent logEvent);
    public virtual string get_Category();
    public virtual bool IsEnabled(LoggingLevel level);
}
public class JetBrains.Util.Logging.DebugOutputLogEventListener : object {
    protected string myPrefix;
    public static DebugOutputLogEventListener Instance;
    public static bool OptionDontWriteDebugStream;
    private static object ourLock;
    [CompilerGeneratedAttribute]
private ILayout <Layout>k__BackingField;
    public ILayout Layout { get; public set; }
    public DebugOutputLogEventListener(string prefix);
    private static DebugOutputLogEventListener();
    private static void WriteDebugStream(string prefix, string body);
    private static void LogToDebugString(string str);
    private string CombinePrefices(string prefix);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(DebugOutputLogEventListener debugOutputLogEventListener);
    [CompilerGeneratedAttribute]
public sealed virtual ILayout get_Layout();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Layout(ILayout value);
    private sealed virtual override void JetBrains.Util.ILogEventListener.OnLogEvent(LogEvent logEvent);
}
public class JetBrains.Util.Logging.DummyLogger : LoggerBase {
    public static ILogger Instance;
    public string Category { get; }
    private static DummyLogger();
    public virtual bool IsEnabled(LoggingLevel level);
    public virtual void Log(LogEvent logEvent);
    public virtual string get_Category();
}
[UsedImplicitlyAttribute]
public class JetBrains.Util.Logging.FileLogEventListener : AsyncLogEventListener {
    private static bool DefaultAppend;
    private static int ourSystemStartedTime;
    private static Regex ourEnvRegex;
    public FileSystemPath Path;
    private bool myAppend;
    private Rolling myRolling;
    private Stream modreq(System.Runtime.CompilerServices.IsVolatile) myStream;
    public Encoding Encoding;
    private TimeThrottler myThrottler;
    [CompilerGeneratedAttribute]
private static MatchEvaluator CS$<>9__CachedAnonymousMethodDelegate1;
    public FileLogEventListener(string parametrizedLogFilePath);
    public FileLogEventListener(string parametrizedLogFilePath, string append);
    public FileLogEventListener(string parametrizedLogFilePath, string append, string rolling);
    public FileLogEventListener(string parametrizedLogFilePath, bool append);
    public FileLogEventListener(FileSystemPath path, bool append, Rolling rolling);
    private static FileLogEventListener();
    private static string SubstitutedPath(string parametrizedLogFilePath);
    private static bool ParseAppend(string arg);
    private void OpenStream();
    private void CloseStream();
    private FileSystemPath RollingFile(int idx);
    private void TryRollFiles();
    protected virtual void ProcessChars(Char* chars, int size);
    [CompilerGeneratedAttribute]
private static string <SubstitutedPath>b__0(Match match);
    [CompilerGeneratedAttribute]
private void <.ctor>b__e();
}
public enum JetBrains.Util.Logging.FilterDecision : Enum {
    public int value__;
    public static FilterDecision Deny;
    public static FilterDecision Neutral;
    public static FilterDecision Accept;
}
public class JetBrains.Util.Logging.Filters.BurstFilter : object {
    private LoggingLevel myLevel;
    private int myRate;
    private int myEventsSinceLastCutoff;
    private int myTimeСutoff;
    public BurstFilter(LoggingLevel level, int rate);
    public sealed virtual FilterDecision Filter(LogEvent logEvent);
    public virtual string ToString();
}
public class JetBrains.Util.Logging.Filters.CategoryFilter : object {
    private string myCategory;
    public CategoryFilter(string category);
    public sealed virtual FilterDecision Filter(LogEvent logEvent);
    public virtual string ToString();
}
public interface JetBrains.Util.Logging.IFilter {
    public abstract virtual FilterDecision Filter(LogEvent logEvent);
}
public interface JetBrains.Util.Logging.ILayout {
    public abstract virtual void Format(TextWriter writer, LogEvent logEvent);
    public abstract virtual void FormatUnsafe(UnsafeWriter writer, LogEvent logEvent);
}
public abstract class JetBrains.Util.Logging.LayoutBase : object {
    public sealed virtual void Format(TextWriter textWriter, LogEvent logEvent);
    public abstract virtual void FormatUnsafe(UnsafeWriter writer, LogEvent logEvent);
}
public class JetBrains.Util.Logging.Listeners.TextWriterLogEventListener : object {
    private LifetimeDefinition Disposables;
    private ILayout myLayout;
    private SequentialLifetimes myPushToLogger;
    private bool myWereErrors;
    private TextWriter myWriter;
    public bool WereErrors { get; }
    [NotNullAttribute]
private ILayout JetBrains.Util.ILogEventListener.Layout { get; private set; }
    public TextWriterLogEventListener(TextWriter writer);
    public bool get_WereErrors();
    public static TextWriterLogEventListener CreateFileLogger(string identity);
    public void PushToLogger(LoggingLevel level);
    public sealed virtual void Dispose();
    private sealed virtual override void JetBrains.Util.ILogEventListener.OnLogEvent(LogEvent logEvent);
    private sealed virtual override ILayout JetBrains.Util.ILogEventListener.get_Layout();
    private sealed virtual override void JetBrains.Util.ILogEventListener.set_Layout(ILayout value);
}
public class JetBrains.Util.Logging.LogConfig : object {
    private List`1<LogConfNode> myNodes;
    [CompilerGeneratedAttribute]
private static Predicate`1<LogConfNode> CS$<>9__CachedAnonymousMethodDelegate1;
    [CompilerGeneratedAttribute]
private static Func`2<LogConfNode, IEnumerable`1<ILogEventListener>> CS$<>9__CachedAnonymousMethodDelegate3;
    public LogConfNode Root { get; }
    public List`1<LogConfNode> Nodes { get; }
    public IEnumerable`1<ILogEventListener> HierarchyAppenders { get; }
    internal LogConfig(IEnumerable`1<LogConfNode> handledLoggers);
    internal void AdjustTimestamps(int timestamp);
    private void CloseNodesTransiently(List`1<LogConfNode> nodes);
    public void InjectNode(LogConfNode node);
    public LogConfNode get_Root();
    public List`1<LogConfNode> get_Nodes();
    public IEnumerable`1<ILogEventListener> get_HierarchyAppenders();
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
private static bool <CloseNodesTransiently>b__0(LogConfNode node);
    [CompilerGeneratedAttribute]
private static IEnumerable`1<ILogEventListener> <get_HierarchyAppenders>b__2(LogConfNode _);
}
public class JetBrains.Util.Logging.LogConfigModel : object {
    public static string TopElt;
    public static LogConfigModel DefaultModel;
    [CompilerGeneratedAttribute]
private HashSet`1<AppenderModel> <Appenders>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<LoggerModel> <Loggers>k__BackingField;
    [CompilerGeneratedAttribute]
private static Func`2<XmlElement, bool> CS$<>9__CachedAnonymousMethodDelegate4;
    [CompilerGeneratedAttribute]
private static Func`2<XmlElement, bool> CS$<>9__CachedAnonymousMethodDelegate5;
    [CompilerGeneratedAttribute]
private static Func`2<XmlElement, bool> CS$<>9__CachedAnonymousMethodDelegate6;
    [CompilerGeneratedAttribute]
private static Func`2<LoggerModel, LogConfNode> CS$<>9__CachedAnonymousMethodDelegatec;
    public HashSet`1<AppenderModel> Appenders { get; private set; }
    public List`1<LoggerModel> Loggers { get; private set; }
    private static LogConfigModel();
    [CompilerGeneratedAttribute]
public HashSet`1<AppenderModel> get_Appenders();
    [CompilerGeneratedAttribute]
private void set_Appenders(HashSet`1<AppenderModel> value);
    [CompilerGeneratedAttribute]
public List`1<LoggerModel> get_Loggers();
    [CompilerGeneratedAttribute]
private void set_Loggers(List`1<LoggerModel> value);
    public static LogConfigModel LoadFromXml(XmlElement topElt);
    public static LogConfigModel LoadFromBinary(BinaryReader reader);
    public void StoreToXml(XmlDocument doc);
    public void StoreToBinary(BinaryWriter writer);
    public sealed virtual bool Equals(LogConfigModel other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual LogConfigModel Clone();
    private sealed virtual override object System.ICloneable.Clone();
    internal LogConfig Build(IEnumerable`1<LoggerModel> predefinedLoggers);
    public void AddAppender(AppenderModel appender, LoggerModel[] loggers);
    [CompilerGeneratedAttribute]
private static bool <LoadFromXml>b__1(XmlElement _);
    [CompilerGeneratedAttribute]
private static bool <LoadFromXml>b__2(XmlElement _);
    [CompilerGeneratedAttribute]
private static bool <LoadFromXml>b__3(XmlElement _);
    [CompilerGeneratedAttribute]
private static LogConfNode <Build>b__b(LoggerModel _);
}
public class JetBrains.Util.Logging.LogConfNode : object {
    private string myNamespace;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) myTimestamp;
    public ISet`1<ILogEventListener> HierarchyAppenders;
    [CompilerGeneratedAttribute]
private Nullable`1<LoggingLevel> <Level>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Additivity>k__BackingField;
    public string Namespace { get; }
    public Nullable`1<LoggingLevel> Level { get; public set; }
    public bool Additivity { get; public set; }
    public int Timestamp { get; internal set; }
    public LogConfNode(Nullable`1<LoggingLevel> level, string namespace, bool additivity, int timestamp);
    public string get_Namespace();
    [CompilerGeneratedAttribute]
public Nullable`1<LoggingLevel> get_Level();
    [CompilerGeneratedAttribute]
public void set_Level(Nullable`1<LoggingLevel> value);
    [CompilerGeneratedAttribute]
public bool get_Additivity();
    [CompilerGeneratedAttribute]
public void set_Additivity(bool value);
    public int get_Timestamp();
    internal void set_Timestamp(int value);
    public sealed virtual int CompareTo(LogConfNode other);
    internal bool TryInheritFrom(LogConfNode other);
    internal void MergeWith(LogConfNode other);
}
public static class JetBrains.Util.Logging.Logger : object {
    public static string LOG_FILENAME_ENV_VARIABLE;
    public static string JETLOGS_DIRECTORY_ENV_VARIABLE;
    private static FileSystemPath ourLogFileName;
    private static bool ourFileLoggingInitialized;
    private static bool ourFileLoggingEnabled;
    private static LoggingLevel ourFileLoggingLevel;
    public static string LogFileExt;
    public static string LogFileNamePrefix;
    private static FileSystemPath modreq(System.Runtime.CompilerServices.IsVolatile) ourLogFolderPath;
    public static string LogsSubfolderName;
    [NotNullAttribute]
public static ILogger Interface;
    [CompilerGeneratedAttribute]
private static int <IndentLevel>k__BackingField;
    public static int IndentLevel { get; public set; }
    public static LoggingLevel FileLoggingLevel { get; public set; }
    public static bool IsFileLoggingEnabled { get; public set; }
    public static FileSystemPath LogFileName { get; public set; }
    public static FileSystemPath LogFolderPath { get; public set; }
    private static Logger();
    [CompilerGeneratedAttribute]
public static int get_IndentLevel();
    [CompilerGeneratedAttribute]
public static void set_IndentLevel(int value);
    public static LoggingLevel get_FileLoggingLevel();
    public static void set_FileLoggingLevel(LoggingLevel value);
    public static bool get_IsFileLoggingEnabled();
    public static void set_IsFileLoggingEnabled(bool value);
    public static FileSystemPath get_LogFileName();
    public static void set_LogFileName(FileSystemPath value);
    private static FileSystemPath GetDefaultLogFolderPath();
    public static FileSystemPath get_LogFolderPath();
    public static void set_LogFolderPath(FileSystemPath value);
    [HandleProcessCorruptedStateExceptionsAttribute]
[DebuggerStepThroughAttribute]
public static void Annotate(Action F, Action`1<Exception> FCommentException);
    [ConditionalAttribute("JET_MODE_ASSERT")]
public static void Assert(bool condition, string message);
    [ConditionalAttribute("JET_MODE_ASSERT")]
public static void AssertWithSensitiveData(bool condition, string message, Pair`2[] sensitiveData);
    [ConditionalAttribute("JET_MODE_ASSERT")]
public static void AssertWithSensitiveData(bool condition, string message, Pair`2<string, object> d1, T1 arg1, T2 arg2, T3 arg3);
    [ConditionalAttribute("JET_MODE_ASSERT")]
public static void AssertWithSensitiveData(bool condition, string message, Pair`2<string, object> d1, Pair`2<string, object> d2, T1 arg1, T2 arg2, T3 arg3);
    [ConditionalAttribute("JET_MODE_ASSERT")]
public static void AssertWithSensitiveData(bool condition, string message, Pair`2<string, object> d1, Pair`2<string, object> d2, Pair`2<string, object> d3, T1 arg1, T2 arg2, T3 arg3);
    [ConditionalAttribute("JET_MODE_ASSERT")]
public static void AssertWithSensitiveData(bool condition, string message, Pair`2<string, object> d1, T1 arg1, T2 arg2);
    [ConditionalAttribute("JET_MODE_ASSERT")]
public static void AssertWithSensitiveData(bool condition, string message, Pair`2<string, object> d1, Pair`2<string, object> d2, T1 arg1, T2 arg2);
    [ConditionalAttribute("JET_MODE_ASSERT")]
public static void AssertWithSensitiveData(bool condition, string message, Pair`2<string, object> d1, Pair`2<string, object> d2, Pair`2<string, object> d3, T1 arg1, T2 arg2);
    [ConditionalAttribute("JET_MODE_ASSERT")]
public static void AssertWithSensitiveData(bool condition, string message, Pair`2<string, object> d1, T arg1);
    [ConditionalAttribute("JET_MODE_ASSERT")]
public static void AssertWithSensitiveData(bool condition, string message, Pair`2<string, object> d1, Pair`2<string, object> d2, T arg1);
    [ConditionalAttribute("JET_MODE_ASSERT")]
public static void AssertWithSensitiveData(bool condition, string message, Pair`2<string, object> d1, Pair`2<string, object> d2, Pair`2<string, object> d3, T arg1);
    [ConditionalAttribute("JET_MODE_ASSERT")]
public static void AssertWithSensitiveData(bool condition, string message, Pair`2<string, object> d1);
    [ConditionalAttribute("JET_MODE_ASSERT")]
public static void AssertWithSensitiveData(bool condition, string message, Pair`2<string, object> d1, Pair`2<string, object> d2);
    [ConditionalAttribute("JET_MODE_ASSERT")]
public static void AssertWithSensitiveData(bool condition, string message, Pair`2<string, object> d1, Pair`2<string, object> d2, Pair`2<string, object> d3);
    [ConditionalAttribute("JET_MODE_ASSERT")]
[StringFormatMethodAttribute("format")]
public static void Assert(bool condition, string format, Object[] args);
    [HandleProcessCorruptedStateExceptionsAttribute]
[DebuggerStepThroughAttribute]
public static void Catch(Action action);
    [DebuggerStepThroughAttribute]
[HandleProcessCorruptedStateExceptionsAttribute]
public static void Catch(Action action, Action actionOnException);
    [HandleProcessCorruptedStateExceptionsAttribute]
[DebuggerStepThroughAttribute]
[CanBeNullAttribute]
public static TValue Catch(Func`1<TValue> func);
    [CanBeNullAttribute]
[DebuggerStepThroughAttribute]
[HandleProcessCorruptedStateExceptionsAttribute]
public static TValue Catch(string comment, Func`1<TValue> F);
    [DebuggerStepThroughAttribute]
[HandleProcessCorruptedStateExceptionsAttribute]
public static void Catch(string comment, Action action);
    [HandleProcessCorruptedStateExceptionsAttribute]
[DebuggerStepThroughAttribute]
public static void CatchIgnore(Action action);
    [DebuggerStepThroughAttribute]
[HandleProcessCorruptedStateExceptionsAttribute]
[CanBeNullAttribute]
public static TValue CatchIgnore(Func`1<TValue> F, TValue defaultValue);
    [DebuggerStepThroughAttribute]
[HandleProcessCorruptedStateExceptionsAttribute]
public static void CatchSilent(Action action);
    [DebuggerStepThroughAttribute]
[CanBeNullAttribute]
[HandleProcessCorruptedStateExceptionsAttribute]
public static TValue CatchSilent(Func`1<TValue> func, TValue defaultValue);
    [DebuggerStepThroughAttribute]
[HandleProcessCorruptedStateExceptionsAttribute]
[CanBeNullAttribute]
public static TValue CatchSilent(TState state, Func`2<TState, TValue> func, TValue defaultValue);
    [DebuggerStepThroughAttribute]
[HandleProcessCorruptedStateExceptionsAttribute]
public static TValue CatchIgnoreException(Func`1<TValue> F, TValue defaultValue);
    [DebuggerStepThroughAttribute]
[HandleProcessCorruptedStateExceptionsAttribute]
public static void CatchIgnoreException(Action action);
    [CanBeNullAttribute]
[DebuggerStepThroughAttribute]
[HandleProcessCorruptedStateExceptionsAttribute]
public static TValue CatchButProcessCancelledException(Func`1<TValue> f);
    [DebuggerStepThroughAttribute]
[HandleProcessCorruptedStateExceptionsAttribute]
[CanBeNullAttribute]
public static TValue CatchIgnoreButProcessCancelledException(Func`1<TValue> f);
    [HandleProcessCorruptedStateExceptionsAttribute]
[DebuggerStepThroughAttribute]
public static void CatchIgnoreButProcessCancelledException(Action f);
    [HandleProcessCorruptedStateExceptionsAttribute]
[DebuggerStepThroughAttribute]
public static void CatchButProcessCancelledException(Action action);
    [HandleProcessCorruptedStateExceptionsAttribute]
public static void CleanupOldLogFiles();
    [HandleProcessCorruptedStateExceptionsAttribute]
public static void CleanupOldLogFiles(FileSystemPath logFolder);
    [DebuggerStepThroughAttribute]
public static void DropException(Exception ex);
    [AssertionMethodAttribute]
public static void Fail(string messageText);
    [AssertionMethodAttribute]
public static void FailWithSensitiveData(string messageText, Pair`2[] sensitiveData);
    [StringFormatMethodAttribute("format")]
[AssertionMethodAttribute]
public static void Fail(string format, Object[] args);
    [StringFormatMethodAttribute("format")]
public static string FormatStringSafe(string format, Object[] args);
    public static FileSystemPath GetDefaultLogFile(string identity);
    [HandleProcessCorruptedStateExceptionsAttribute]
public static void Init();
    [HandleProcessCorruptedStateExceptionsAttribute]
public static void Init(Lifetime lifetime);
    public static void LogError(string message);
    public static void LogErrorWithSensitiveData(string message, Pair`2[] sensitiveData, Object[] args);
    public static void LogErrorWithSensitiveData(string message, Pair`2[] sensitiveData);
    [StringFormatMethodAttribute("format")]
public static void LogError(string format, Object[] args);
    public static void LogException(Exception ex);
    public static void LogException(string comment, Exception ex);
    public static void LogExceptionSilently(Exception ex);
    public static void LogMessage(LoggingLevel level, string message);
    [StringFormatMethodAttribute("format")]
public static void LogMessage(LoggingLevel level, string format, Object[] args);
    public static void LogMessage(string message);
    [StringFormatMethodAttribute("format")]
public static void LogMessage(string format, Object[] args);
    public static ILogger GetLogger();
    public static ILogger GetLogger(Type callerType);
    public static ILogger GetLogger(string fullClassName);
}
public class JetBrains.Util.Logging.LoggerConfigurationParseException : Exception {
    public LoggerConfigurationParseException(string str, Exception cause);
}
public class JetBrains.Util.Logging.LoggerModel : object {
    public static string LoggerEltName;
    public static string RootEltName;
    private LogConfNode myBuildedItem;
    [CompilerGeneratedAttribute]
private string <Category>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<LoggingLevel> <Level>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Additivity>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<AppenderModel> <Appenders>k__BackingField;
    [CompilerGeneratedAttribute]
private static Func`2<XmlElement, bool> CS$<>9__CachedAnonymousMethodDelegate2;
    [CompilerGeneratedAttribute]
private static Func`2<AppenderModel, ILogEventListener> CS$<>9__CachedAnonymousMethodDelegate9;
    [NotNullAttribute]
public string Category { get; private set; }
    public Nullable`1<LoggingLevel> Level { get; public set; }
    public bool Additivity { get; private set; }
    [NotNullAttribute]
public List`1<AppenderModel> Appenders { get; private set; }
    public LogConfNode BuildedItem { get; }
    public LoggerModel(string category, Nullable`1<LoggingLevel> level, IEnumerable`1<AppenderModel> appenders, bool additivity);
    [CompilerGeneratedAttribute]
public string get_Category();
    [CompilerGeneratedAttribute]
private void set_Category(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<LoggingLevel> get_Level();
    [CompilerGeneratedAttribute]
public void set_Level(Nullable`1<LoggingLevel> value);
    [CompilerGeneratedAttribute]
public bool get_Additivity();
    [CompilerGeneratedAttribute]
private void set_Additivity(bool value);
    [CompilerGeneratedAttribute]
public List`1<AppenderModel> get_Appenders();
    [CompilerGeneratedAttribute]
private void set_Appenders(List`1<AppenderModel> value);
    [NotNullAttribute]
public static LoggerModel LoadFromXml(XmlElement elt, Dictionary`2<string, AppenderModel> appMap);
    public void StoreToXml(XmlElement parent);
    public static LoggerModel LoadFromBinary(BinaryReader reader, Dictionary`2<string, AppenderModel> appMap);
    public void StoreToBinary(BinaryWriter writer);
    private static Nullable`1<LoggingLevel> ParseLevel(string strLevel);
    public LogConfNode get_BuildedItem();
    public sealed virtual bool Equals(LoggerModel other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
private static bool <LoadFromXml>b__0(XmlElement _);
    [CompilerGeneratedAttribute]
private static ILogEventListener <get_BuildedItem>b__8(AppenderModel appender);
}
public class JetBrains.Util.Logging.LogManager : object {
    public static string LogConfigurationXmlResource;
    public static string LogConfigurationXsdResource;
    private static string EnvResharperTrace;
    private static string BinaryExt;
    public static LogManager Instance;
    private IList`1<LoggerModel> myPredefinedTraceCategories;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) myTimestamp;
    private ActiveLogConf myActiveConfig;
    private JetFileSystemWatcher myWatcher;
    private FileSystemPath myXmlConfigurationLocation;
    private Action ConfigChanged;
    private List`1<Action`1<LogConfig>> myTransformations;
    internal ReaderWriterLockSlim Lock;
    private DateTime myLastXmlFileModificationTimestamp;
    private LogSubconfiguration mySubconfiguration;
    internal List`1<OmnipresentLogger> OmnipresentLoggers;
    internal LoggingLevel OmnipresentAggregateLevel;
    [CompilerGeneratedAttribute]
private LogConfig <Config>k__BackingField;
    [CompilerGeneratedAttribute]
private LogConfigModel <Model>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DisableFileAutoUpdates>k__BackingField;
    [CompilerGeneratedAttribute]
private static Action`1<LogLogRecord> CS$<>9__CachedAnonymousMethodDelegate1;
    [CompilerGeneratedAttribute]
private static Func`2<string, bool> CS$<>9__CachedAnonymousMethodDelegate4;
    [CompilerGeneratedAttribute]
private static Func`2<string, LoggerModel> CS$<>9__CachedAnonymousMethodDelegate5;
    [CompilerGeneratedAttribute]
private static Func`3<LoggingLevel, OmnipresentLogger, LoggingLevel> CS$<>9__CachedAnonymousMethodDelegate10;
    public LogConfig Config { get; private set; }
    public LogConfigModel Model { get; private set; }
    public bool DisableFileAutoUpdates { get; public set; }
    public bool DefaultConfigActive { get; }
    public int Timestamp { get; }
    private static LogManager();
    private void Reset();
    private static IList`1<LoggerModel> ParseTraceCategories();
    [CompilerGeneratedAttribute]
public LogConfig get_Config();
    [CompilerGeneratedAttribute]
private void set_Config(LogConfig value);
    [CompilerGeneratedAttribute]
public LogConfigModel get_Model();
    [CompilerGeneratedAttribute]
private void set_Model(LogConfigModel value);
    [CompilerGeneratedAttribute]
public bool get_DisableFileAutoUpdates();
    [CompilerGeneratedAttribute]
public void set_DisableFileAutoUpdates(bool value);
    public void add_ConfigChanged(Action value);
    public void remove_ConfigChanged(Action value);
    public void ApplyTransformation(Lifetime lifetime, Action`1<LogConfig> transform);
    public bool get_DefaultConfigActive();
    public static FileSystemPath GetPrimaryXmlConfiguration(FileSystemPath xmlConfLocation, LogSubconfiguration subconfiguration);
    public FileSystemPath GetLogConfigurationFolder();
    public FileSystemPath GetPrimaryXmlConfiguration();
    private FileSystemPath GetPrimaryBinConfiguration();
    public FileSystemPath GetSecondaryXmlConfiguration();
    private FileSystemPath GetSecondaryBinConfiguration();
    public void AddOmnipresentLogger(Lifetime lf, ILogEventListener listener, LoggingLevel level, IFilter[] filters);
    private void CalcOmnipresentLevel();
    public void Initialize(FileSystemPath xmlConfigurationLocation, LogSubconfiguration subconfiguration);
    private sealed virtual override void JetBrains.Util.JetFileSystemWatcher.IWatcherEvents.OnFileSystemChanged(FileSystemEvent[] events);
    private void ReconfigureFromFile();
    public void SetConfig(LogConfigModel model, bool forceSet);
    public int get_Timestamp();
    internal LogConfNode GetMatchedConfNode(string namespace);
    private sealed virtual override ILog JetBrains.Util.Logging.ILogFactory.GetLog(string category);
    public ILogger GetLogger(string category);
    public ILogger GetLogger(Type callerType);
    public sealed virtual void Dispose();
    public static void CreateLogConfigXmlFile(FileSystemPath path);
    [CompilerGeneratedAttribute]
private static void <.ctor>b__0(LogLogRecord record);
    [CompilerGeneratedAttribute]
private static bool <ParseTraceCategories>b__2(string category);
    [CompilerGeneratedAttribute]
private static LoggerModel <ParseTraceCategories>b__3(string category);
    [CompilerGeneratedAttribute]
private void <ApplyTransformation>b__6();
    [CompilerGeneratedAttribute]
private IDisposable <ApplyTransformation>b__7();
    [CompilerGeneratedAttribute]
private static LoggingLevel <CalcOmnipresentLevel>b__f(LoggingLevel level, OmnipresentLogger logger);
}
public static class JetBrains.Util.Logging.LogSerializer : object {
    [CompilerGeneratedAttribute]
private static ValidationEventHandler CS$<>9__CachedAnonymousMethodDelegate1;
    [NotNullAttribute]
public static LogConfigModel LoadFromXml(FileSystemPath xml);
    public static void StoreToXml(LogConfigModel logModel, FileSystemPath xml);
    [NotNullAttribute]
public static LogConfigModel LoadFromBinary(FileSystemPath binary);
    public static void StoreToBinary(LogConfigModel logModel, FileSystemPath binary);
    [CompilerGeneratedAttribute]
private static void <LoadFromXml>b__0(object obj, ValidationEventArgs args);
}
public enum JetBrains.Util.Logging.LogSubconfiguration : Enum {
    public int value__;
    public static LogSubconfiguration Debug;
    public static LogSubconfiguration Test;
    public static LogSubconfiguration Release;
    public static LogSubconfiguration Cmd;
}
[UsedImplicitlyAttribute]
public class JetBrains.Util.Logging.MessageBoxLogEventListener : object {
    private Regex myRegex;
    [CompilerGeneratedAttribute]
private ILayout <Layout>k__BackingField;
    public ILayout Layout { get; public set; }
    public MessageBoxLogEventListener(string pattern);
    private void Show();
    [CompilerGeneratedAttribute]
public sealed virtual ILayout get_Layout();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Layout(ILayout value);
    public sealed virtual void OnLogEvent(LogEvent logEvent);
}
public class JetBrains.Util.Logging.OmnipresentLogger : object {
    private ILogEventListener myListener;
    private LoggingLevel myLevel;
    private IFilter[] myFilters;
    public ILogEventListener Listener { get; }
    public LoggingLevel Level { get; }
    public IFilter[] Filters { get; }
    public OmnipresentLogger(ILogEventListener logEventListener, LoggingLevel level, IFilter[] filters);
    public ILogEventListener get_Listener();
    public LoggingLevel get_Level();
    public IFilter[] get_Filters();
}
public class JetBrains.Util.Logging.PatternLayout : LayoutBase {
    private static IDictionary`2<char, Func`2<string, Func`2<LogEvent, string>>> ourPartFunctors;
    private static Regex ourFunctorRegex;
    private static long ourOffsetFromUtc;
    private Object[] myPartProducers;
    [CompilerGeneratedAttribute]
private static Func`2<string, Func`2<LogEvent, string>> CS$<>9__CachedAnonymousMethodDelegate1a;
    [CompilerGeneratedAttribute]
private static Func`2<string, Func`2<LogEvent, string>> CS$<>9__CachedAnonymousMethodDelegate1b;
    [CompilerGeneratedAttribute]
private static Func`2<string, Func`2<LogEvent, string>> CS$<>9__CachedAnonymousMethodDelegate1c;
    [CompilerGeneratedAttribute]
private static Func`2<string, Func`2<LogEvent, string>> CS$<>9__CachedAnonymousMethodDelegate1d;
    [CompilerGeneratedAttribute]
private static Func`2<string, Func`2<LogEvent, string>> CS$<>9__CachedAnonymousMethodDelegate1e;
    [CompilerGeneratedAttribute]
private static Func`2<string, Func`2<LogEvent, string>> CS$<>9__CachedAnonymousMethodDelegate1f;
    [CompilerGeneratedAttribute]
private static Func`2<string, Func`2<LogEvent, string>> CS$<>9__CachedAnonymousMethodDelegate20;
    [CompilerGeneratedAttribute]
private static Func`2<string, Func`2<LogEvent, string>> CS$<>9__CachedAnonymousMethodDelegate21;
    [CompilerGeneratedAttribute]
private static Func`2<string, Func`2<LogEvent, string>> CS$<>9__CachedAnonymousMethodDelegate22;
    [CompilerGeneratedAttribute]
private static Func`2<string, Func`2<LogEvent, string>> CS$<>9__CachedAnonymousMethodDelegate23;
    [CompilerGeneratedAttribute]
private static Func`2<string, Func`2<LogEvent, string>> CS$<>9__CachedAnonymousMethodDelegate24;
    [CompilerGeneratedAttribute]
private static Func`2<LogEvent, string> CS$<>9__CachedAnonymousMethodDelegate2b;
    [CompilerGeneratedAttribute]
private static Func`2<LogEvent, string> CS$<>9__CachedAnonymousMethodDelegate2c;
    [CompilerGeneratedAttribute]
private static Func`2<LogEvent, string> CS$<>9__CachedAnonymousMethodDelegate2d;
    [CompilerGeneratedAttribute]
private static Func`2<LogEvent, string> CS$<>9__CachedAnonymousMethodDelegate2e;
    [CompilerGeneratedAttribute]
private static Func`2<LogEvent, string> CS$<>9__CachedAnonymousMethodDelegate2f;
    [CompilerGeneratedAttribute]
private static Func`2<LogEvent, string> CS$<>9__CachedAnonymousMethodDelegate30;
    [CompilerGeneratedAttribute]
private static Func`2<LogEvent, string> CS$<>9__CachedAnonymousMethodDelegate31;
    [CompilerGeneratedAttribute]
private static Func`2<LogEvent, string> CS$<>9__CachedAnonymousMethodDelegate32;
    [CompilerGeneratedAttribute]
private static Func`2<LogEvent, string> CS$<>9__CachedAnonymousMethodDelegate33;
    private static PatternLayout();
    public PatternLayout(string pattern);
    private static int ParseIntArg(string str);
    private static string SplitSuffixParts(string str, int nSufixParts, char delimiter);
    public static string FormatDateFast(DateTime t);
    private static void FormatInt2(Char[] c, Int32& pos, int x);
    private static void FormatInt3(Char[] c, Int32& pos, int x);
    private static DateTime ToLocalDateTimeFast(DateTime dateTime);
    public virtual void FormatUnsafe(UnsafeWriter writer, LogEvent logEvent);
    [CompilerGeneratedAttribute]
private static Func`2<LogEvent, string> <.cctor>b__0(string arg);
    [CompilerGeneratedAttribute]
private static Func`2<LogEvent, string> <.cctor>b__2(string arg);
    [CompilerGeneratedAttribute]
private static Func`2<LogEvent, string> <.cctor>b__4(string arg);
    [CompilerGeneratedAttribute]
private static Func`2<LogEvent, string> <.cctor>b__6(string arg);
    [CompilerGeneratedAttribute]
private static Func`2<LogEvent, string> <.cctor>b__8(string arg);
    [CompilerGeneratedAttribute]
private static Func`2<LogEvent, string> <.cctor>b__a(string arg);
    [CompilerGeneratedAttribute]
private static Func`2<LogEvent, string> <.cctor>b__c(string arg);
    [CompilerGeneratedAttribute]
private static Func`2<LogEvent, string> <.cctor>b__e(string arg);
    [CompilerGeneratedAttribute]
private static Func`2<LogEvent, string> <.cctor>b__10(string arg);
    [CompilerGeneratedAttribute]
private static Func`2<LogEvent, string> <.cctor>b__12(string arg);
    [CompilerGeneratedAttribute]
private static Func`2<LogEvent, string> <.cctor>b__14(string arg);
    [CompilerGeneratedAttribute]
private static string <.cctor>b__5(LogEvent logEvent);
    [CompilerGeneratedAttribute]
private static string <.cctor>b__7(LogEvent logEvent);
    [CompilerGeneratedAttribute]
private static string <.cctor>b__9(LogEvent logEvent);
    [CompilerGeneratedAttribute]
private static string <.cctor>b__b(LogEvent logEvent);
    [CompilerGeneratedAttribute]
private static string <.cctor>b__d(LogEvent _);
    [CompilerGeneratedAttribute]
private static string <.cctor>b__f(LogEvent logEvent);
    [CompilerGeneratedAttribute]
private static string <.cctor>b__11(LogEvent logEvent);
    [CompilerGeneratedAttribute]
private static string <.cctor>b__13(LogEvent logEvent);
    [CompilerGeneratedAttribute]
private static string <.cctor>b__15(LogEvent logEvent);
}
public class JetBrains.Util.Logging.SimpleLayout : LayoutBase {
    public static SimpleLayout Instance;
    private static PatternLayout ourLayout;
    private static SimpleLayout();
    public virtual void FormatUnsafe(UnsafeWriter writer, LogEvent logEvent);
}
internal class JetBrains.Util.LoggingLevelStrings : object {
    internal static String[] Short;
    internal static String[] Full;
    private static LoggingLevelStrings();
}
[ExtensionAttribute]
public static class JetBrains.Util.Maths.Hashes : object {
    public static UInt32 MurmurHashSeed;
    private static Hashes();
    public static OWORD MurmurHash3_128_x86(Byte* pData, UInt32 nLen, UInt32 seed);
    public static OWORD MurmurHash3_128_x86(Byte* pData, UInt32 nLen, OWORD seed);
    public static OWORD MurmurHash3_128_x64(Byte* pData, UInt32 nLen, UInt32 seed);
    public static OWORD MurmurHash3_128_x64(Byte* pData, UInt32 nLen, OWORD seed);
    public static OWORD MurmurHash3_128_x86(string text);
    [ExtensionAttribute]
public static int MurmurHash3(string text);
    public static int MurmurHash3_Parts(Byte* pData1, int nLen1, Byte* pData2, int nLen2, UInt32 seed);
    public static int MurmurHash3(Byte* pData, int nLen, UInt32 seed);
}
public class JetBrains.Util.Maths.OWORD : ValueType {
    public ulong loqword;
    public ulong hiqword;
    public UInt32 dword0;
    public UInt32 dword1;
    public UInt32 dword2;
    public UInt32 dword3;
    public OWORD(ulong loqword, ulong hiqword);
    public OWORD(UInt32 dword0, UInt32 dword1, UInt32 dword2, UInt32 dword3);
    public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(OWORD other);
    public sealed virtual bool Equals(OWORD other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static bool op_Equality(OWORD black, OWORD white);
    public static bool op_Inequality(OWORD black, OWORD white);
    public static OWORD op_Implicit(ulong qw);
    public static OWORD op_Modulus(OWORD black, OWORD white);
    public static OWORD op_BitwiseOr(OWORD black, OWORD white);
    public static OWORD op_BitwiseAnd(OWORD black, OWORD white);
    public static OWORD op_OnesComplement(OWORD black);
}
public static class JetBrains.Util.Memory.MemoryUtil : object {
    public static int ByteBufferUnderlohSize;
    public static int CopyMemoryPinvokeThreshold;
    private static ulong myTotalVirtualMemory;
    private static ulong myMachinePhysicalMemory;
    public static ObjectReference[] GetReachingPath(object obj, Object[] roots);
    public static ulong GetAvailablePhysicalMemory();
    public static ulong GetTotalVirtualMemory();
    public static ulong GetMachinePhysicalMemory();
    public static void MoveMemory(Void* pSrc, Void* pDst, UInt32 cbLen);
    public static void CopyMemory(Void* pSrc, Void* pDst, UInt32 cbLen);
    public static void CopyMemory(Void* pSrc, Byte[] dst, UInt32 cbDstOffset, UInt32 cbLen);
    public static void CopyMemory(Byte[] src, UInt32 cbSrcOffset, Void* pDst, UInt32 cbLen);
    public static void CopyMemory(Byte[] src, UInt32 cbSrcOffset, Byte[] dst, UInt32 cbDstOffset, UInt32 cbLen);
    public static void CopyMemory(Byte* src, Byte* dest, int len);
    public static void CopyMemoryReverse(Void* pSrc, Void* pDst, UInt32 cbLen);
    public static void ZeroMemory(Void* p, UInt32 cb);
    public static bool memcmp(Byte* src, Byte* dest, int len);
    public static bool memcmp(Void* p1, UInt32 cb1, Void* p2, UInt32 cb2);
}
public class JetBrains.Util.Memory.ObjectReference : object {
    private object myObject;
    private FieldInfo myFieldInfo;
    public object Object { get; }
    public FieldInfo FieldInfo { get; }
    public ObjectReference(object obj, FieldInfo fieldInfo);
    public ObjectReference(FieldInfo fieldInfo);
    public object get_Object();
    public FieldInfo get_FieldInfo();
    public virtual string ToString();
}
public static class JetBrains.Util.NativeDllEx : object {
    private static string ourExecutableExtension;
    private static string ourSharedLibraryExtension;
    private static string ourStaticLibraryExtension;
    private static string ourSharedLibraryPrefix;
    private static string ourStaticLibraryPrefix;
    private static NativeDllEx();
    [NotNullAttribute]
public static string MakeExecutableName(string name);
    [NotNullAttribute]
public static string MakeSharedLibraryName(string name);
    [NotNullAttribute]
public static string MakeStaticLibraryName(string name);
    [NotNullAttribute]
public static RelativePath GetNativeDir(ProcessorArchitecture architecture, bool debug, string name);
    [NotNullAttribute]
private static string GetPlatformPart();
}
public static class JetBrains.Util.NounUtil : object {
    private static IDictionary`2<string, string> ourPlurals;
    private static IDictionary`2<string, string> ourSingulars;
    private static NounUtil();
    public static string GetPlural(string singular);
    public static string GetSingular(string plural);
    [NotNullAttribute]
public static string ToPluralOrSingular(string singular, int count);
    public static string GetCountString(int argumentIndex);
}
public class JetBrains.Util.OnError : object {
    private string myName;
    private Action`1<Exception> myHandler;
    private bool myIsIgnoringMessage;
    public static OnError Ignore;
    public static OnError LogException;
    public static OnError LogExceptionSilently;
    [NotNullAttribute]
public static OnError Throw;
    [CompilerGeneratedAttribute]
private static Action`1<Exception> CS$<>9__CachedAnonymousMethodDelegate19;
    public bool IsIgnoringMessage { get; }
    public OnError(string name, Action`1<Exception> handler, bool isIgnoringMessage);
    private static OnError();
    public bool get_IsIgnoringMessage();
    [NotNullAttribute]
public static OnError ThrowMessage(string message);
    [NotNullAttribute]
public static OnError LogAssertion(ILogger logger);
    [NotNullAttribute]
public static OnError LogAlgorithmError(ILogger logger);
    [NotNullAttribute]
public static OnError Error(ILogger logger);
    [NotNullAttribute]
public static OnError Warn(ILogger logger);
    [NotNullAttribute]
public static OnError Verbose(ILogger logger, string extmessage);
    [NotNullAttribute]
public static OnError LogForeignException(ILogger logger);
    public void Handle(Exception ex);
    public virtual string ToString();
    [NotNullAttribute]
public OnError WithMessage(string message);
    [DebuggerStepThroughAttribute]
[HandleProcessCorruptedStateExceptionsAttribute]
public void Catch(Action action);
    [DebuggerStepThroughAttribute]
[HandleProcessCorruptedStateExceptionsAttribute]
[CanBeNullAttribute]
public TValue Catch(Func`1<TValue> func);
    [CompilerGeneratedAttribute]
private static void <.cctor>b__18(Exception ex);
}
[DebuggerDisplayAttribute("Count = {Count}")]
[DebuggerTypeProxyAttribute("JetBrains.Util.OneToListMap`2/OneToListMapDebugView")]
[DefaultMemberAttribute("Item")]
public class JetBrains.Util.OneToListMap`2 : object {
    private IEqualityComparer`1<TValue> myValueComparer;
    private Dictionary`2<TKey, OneToListItems<TKey, TValue>> myMap;
    [CompilerGeneratedAttribute]
private static Func`2<OneToListItems<TKey, TValue>, IEnumerable`1<TValue>> CS$<>9__CachedAnonymousMethodDelegate6;
    public int Count { get; }
    [NotNullAttribute]
public ICollection`1<TKey> Keys { get; }
    public ValueCollection<TKey, TValue> Item { get; }
    [NotNullAttribute]
public IEnumerable`1<TValue> Values { get; }
    public OneToListMap`2(IEnumerable`1<KeyValuePair`2<TKey, IList`1<TValue>>> enumerable, IEqualityComparer`1<TKey> comparer);
    public OneToListMap`2(IEnumerable`1<KeyValuePair`2<TKey, IList`1<TValue>>> enumerable, IEqualityComparer`1<TKey> keyComparer, IEqualityComparer`1<TValue> valueComparer);
    public OneToListMap`2(int capacity, IEqualityComparer`1<TKey> comparer);
    public OneToListMap`2(int capacity, IEqualityComparer`1<TKey> keyComparer, IEqualityComparer`1<TValue> valueComparer);
    public OneToListMap`2(IEnumerable`1<KeyValuePair`2<TKey, IList`1<TValue>>> enumerable);
    public OneToListMap`2(IEqualityComparer`1<TKey> comparer);
    public OneToListMap`2(IEqualityComparer`1<TKey> keyComparer, IEqualityComparer`1<TValue> valueComparer);
    public OneToListMap`2(int capacity);
    public int get_Count();
    public void Clear();
    public sealed virtual ICollection`1<TKey> get_Keys();
    public ValueCollection<TKey, TValue> get_Item(TKey key);
    public void AddValue(TKey key, TValue value);
    [NotNullAttribute]
public sealed virtual IList`1<TValue> GetValuesSafe(TKey key);
    public sealed virtual void Add(TKey key, TValue value);
    public void InsertValue(int index, TKey key, TValue value);
    public void AddValueRange(TKey key, IEnumerable`1<TValue> list);
    public bool RemoveValueRange(TKey key, IEnumerable`1<TValue> list);
    public bool RemoveValue(TKey key, TValue value);
    public sealed virtual bool Remove(TKey key, TValue value);
    public bool RemoveKey(TKey key);
    public bool ContainsKey(TKey key);
    public bool ContainsValue(TValue value);
    public bool ContainsPair(TKey key, TValue value);
    [CanBeNullAttribute]
private OneToListItems<TKey, TValue> GetValues(TKey key);
    [NotNullAttribute]
public JetReadOnlyCollection`1<TValue> GetValuesCollection(TKey key);
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, IList`1<TValue>>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public void ClearKey(TKey key);
    public IEnumerable`1<TValue> get_Values();
    public void TrimExcess();
    [CompilerGeneratedAttribute]
private static IEnumerable`1<TValue> <get_Values>b__5(OneToListItems<TKey, TValue> list);
}
[ExtensionAttribute]
public static class JetBrains.Util.OneToListMapExtensions : object {
    [ExtensionAttribute]
public static void Add(OneToListMap`2<TKey, TValue> map, Lifetime lifetime, TKey key, TValue value);
    [ExtensionAttribute]
public static void InsertValue(OneToListMap`2<TKey, TValue> map, Lifetime lifetime, int index, TKey key, TValue value);
    [ExtensionAttribute]
public static void AddRange(OneToListMap`2<TKey, TValue> map, Lifetime lifetime, TKey key, IEnumerable`1<TValue> values);
    [ExtensionAttribute]
public static void AddRange(OneToListMap`2<TKey, TValue> map, IEnumerable`1<KeyValuePair`2<TKey, IList`1<TValue>>> pairs);
}
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("Count = {Count}")]
[DebuggerTypeProxyAttribute("JetBrains.Util.OneToSetMap`2/OneToSetMapDebugView")]
public class JetBrains.Util.OneToSetMap`2 : object {
    private Dictionary`2<TKey, OneToSetItems<TKey, TValue>> myMap;
    private IEqualityComparer`1<TValue> myValueComparer;
    public int Count { get; }
    [NotNullAttribute]
public ICollection`1<TKey> Keys { get; }
    [NotNullAttribute]
public ValuesCollection<TKey, TValue> Values { get; }
    [NotNullAttribute]
public ISet`1<TValue> Item { get; }
    public OneToSetMap`2(OneToSetMap`2<TKey, TValue> other);
    public OneToSetMap`2(IEqualityComparer`1<TKey> keyComparer);
    public OneToSetMap`2(int capacity, IEqualityComparer`1<TKey> keyComparer, IEqualityComparer`1<TValue> valueComparer);
    public void Clear();
    public int get_Count();
    public sealed virtual ICollection`1<TKey> get_Keys();
    public ValuesCollection<TKey, TValue> get_Values();
    public ISet`1<TValue> get_Item(TKey key);
    public bool AddRange(TKey key, IEnumerable`1<TValue> values);
    public void AddRangeFast(TKey key, IEnumerable`1<TValue> values);
    public sealed virtual ISet`1<TValue> GetValuesSafe(TKey key);
    public bool Add(TKey key, TValue value);
    private sealed virtual override void JetBrains.Util.IOneToManyMap<TKey,TValue,System.Collections.Generic.ISet<TValue>>.Add(TKey key, TValue value);
    public sealed virtual bool Remove(TKey key, TValue value);
    public void RemoveKey(TKey key);
    public bool ContainsKey(TKey key);
    public bool ContainsPair(TKey key, TValue value);
    private OneToSetItems<TKey, TValue> TryGetValues(TKey key);
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, ISet`1<TValue>>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public OneToSetMapDiff`1<TKey> Diff(OneToSetMap`2<TKey, TValue> other);
}
public class JetBrains.Util.OneToSetMapDiff`1 : object {
    private JetHashSet`1<TKey> myNewKeys;
    private JetHashSet`1<TKey> myChangedKeys;
    private JetHashSet`1<TKey> myRemovedKeys;
    public JetHashSet`1<TKey> NewKeys { get; }
    public JetHashSet`1<TKey> ChangedKeys { get; }
    public JetHashSet`1<TKey> RemovedKeys { get; }
    public bool IsSomethingChanged { get; }
    public OneToSetMapDiff`1(JetHashSet`1<TKey> newKeys, JetHashSet`1<TKey> changedKeys, JetHashSet`1<TKey> removedKeys);
    public JetHashSet`1<TKey> get_NewKeys();
    public JetHashSet`1<TKey> get_ChangedKeys();
    public JetHashSet`1<TKey> get_RemovedKeys();
    public bool get_IsSomethingChanged();
}
[ExtensionAttribute]
public static class JetBrains.Util.OneToSetMapExtensions : object {
    [ExtensionAttribute]
public static void Add(OneToSetMap`2<TKey, TValue> map, Lifetime lifetime, TKey key, TValue value);
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Util.OrderedHashSet`1 : object {
    private JetHashSet`1<T> myHashSet;
    private List`1<T> myList;
    public T Item { get; public set; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public IEqualityComparer`1<T> Comparer { get; }
    public OrderedHashSet`1(int capacity, IEqualityComparer`1<T> comparer);
    public OrderedHashSet`1(IEqualityComparer`1<T> comparer);
    public OrderedHashSet`1(ICollection`1<T> other, IEqualityComparer`1<T> comparer);
    public OrderedHashSet`1(IEnumerable`1<T> other, IEqualityComparer`1<T> comparer);
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    public sealed virtual void UnionWith(IEnumerable`1<T> other);
    public sealed virtual void IntersectWith(IEnumerable`1<T> other);
    public sealed virtual void ExceptWith(IEnumerable`1<T> other);
    public sealed virtual void SymmetricExceptWith(IEnumerable`1<T> other);
    public sealed virtual bool IsSubsetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsSupersetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsProperSupersetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsProperSubsetOf(IEnumerable`1<T> other);
    public sealed virtual bool Overlaps(IEnumerable`1<T> other);
    public sealed virtual bool SetEquals(IEnumerable`1<T> other);
    public sealed virtual int IndexOf(T item);
    public sealed virtual void Insert(int index, T item);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    public void AddAll(IEnumerable`1<T> other);
    public sealed virtual bool Remove(T item);
    public bool ContainsAll(ICollection`1<T> otherCollection);
    public sealed virtual bool Add(T item);
    public sealed virtual void Clear();
    public void RemoveAll(ICollection`1<T> otherCollection);
    public T[] ToArray();
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public bool get_IsSynchronized();
    public object get_SyncRoot();
    public T ElementAt(int index);
    public void Sort(IComparer`1<T> comparer);
    public sealed virtual IEqualityComparer`1<T> get_Comparer();
}
[ExtensionAttribute]
public static class JetBrains.Util.Pair : object {
    [DebuggerStepThroughAttribute]
[PureAttribute]
public static Pair`2<T1, T2> Of(T1 first, T2 second);
    [PureAttribute]
[ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static IEnumerable`1<T1> GetFirsts(IEnumerable`1<Pair`2<T1, T2>> pairs);
    [PureAttribute]
[DebuggerStepThroughAttribute]
[ExtensionAttribute]
public static IEnumerable`1<T2> GetSeconds(IEnumerable`1<Pair`2<T1, T2>> pairs);
}
public class JetBrains.Util.Pair`2 : ValueType {
    public T1 First;
    public T2 Second;
    [NotNullAttribute]
public static IEqualityComparer`1<Pair`2<T1, T2>> EqualityComparer;
    [NotNullAttribute]
public static IComparer`1<Pair`2<T1, T2>> Comparer;
    public static Pair`2<T1, T2> Empty;
    [DebuggerStepThroughAttribute]
public Pair`2(T1 first, T2 second);
    private static Pair`2();
    public sealed virtual bool Equals(Pair`2<T1, T2> other);
    public virtual bool Equals(object obj);
    [DebuggerStepThroughAttribute]
[PureAttribute]
public virtual int GetHashCode();
    public sealed virtual int CompareTo(Pair`2<T1, T2> other);
    [PureAttribute]
[DebuggerStepThroughAttribute]
public Pair`2<T2, T1> Reverse();
    public virtual string ToString();
    [PureAttribute]
[DebuggerStepThroughAttribute]
public bool IsEmpty();
}
[FlagsAttribute]
public enum JetBrains.Util.PathSearchFlags : Enum {
    public int value__;
    public static PathSearchFlags RecurseIntoSubdirectories;
    public static PathSearchFlags ExcludeHidden;
    public static PathSearchFlags ExcludeFiles;
    public static PathSearchFlags ExcludeDirectories;
}
public class JetBrains.Util.PathWildcard : object {
    private Wildcard[] myWildcards;
    public PathWildcard(string pattern, bool caseSensitive, bool removeTwoDots);
    internal PathWildcard(Wildcard[] wildcards);
    public bool Matches(string path);
    public MatchResult GetMatchResult(string path);
    private static MatchResult GetMatchResult(string path, Wildcard[] wildcards);
    public IEnumerable`1<FileSystemPath> GetMatchingPathsUnderRoot(FileSystemPath root, ICollection`1<PathWildcard> skippedPaths, ICollection`1<string> alwaysSkippedParts);
    private static IEnumerable`1<FileSystemPath> GetMatchingPathsUnderRoot(FileSystemPath root, Wildcard[] wildcards, ICollection`1<PathWildcard> skippedPaths, ICollection`1<string> alwaysSkippedParts);
    private static IEnumerable`1<FileSystemPath> GetMatchesForRoot(FileSystemPath originalRoot, FileSystemPath baseDir, FileSystemPath root, Wildcard[] wildcards, ICollection`1<PathWildcard> skippedPaths, ICollection`1<string> alwaysSkippedParts);
    private static Wildcard[] StripStars(Wildcard[] wildcards);
    private static bool IsToSkip(string subPath, ICollection`1<PathWildcard> skippedPaths);
    public virtual string ToString();
}
public interface JetBrains.Util.PersistentMap.IUnsafeMarshaller`1 {
    public abstract virtual void Marshal(UnsafeWriter writer, T value);
    public abstract virtual T Unmarshal(UnsafeReader reader);
}
public class JetBrains.Util.PersistentMap.RawValue : ValueType {
    public int BytesLength;
    [CompilerGeneratedAttribute]
private IntPtr <Ptr>k__BackingField;
    public IntPtr Ptr { get; private set; }
    public RawValue(int bytesLength, IntPtr ptr);
    [CompilerGeneratedAttribute]
public IntPtr get_Ptr();
    [CompilerGeneratedAttribute]
private void set_Ptr(IntPtr value);
    public virtual string ToString();
}
public class JetBrains.Util.PersistentMap.UniversalMarshaller`1 : object {
    private ReadDelegate`1<T> myReadDelegate;
    private WriteDelegate`1<T> myWriteDelegate;
    public UniversalMarshaller`1(ReadDelegate`1<T> readDelegate, WriteDelegate`1<T> writeDelegate);
    public sealed virtual void Marshal(UnsafeWriter writer, T value);
    public sealed virtual T Unmarshal(UnsafeReader reader);
}
public class JetBrains.Util.PersistentMap.UnsafeDelegatedMarshaller`2 : object {
    private IUnsafeMarshaller`1<TSrc> myMarshaller;
    private Func`2<TDst, TSrc> myTransformMarshall;
    private Func`2<TSrc, TDst> myTransformUnmarshall;
    public UnsafeDelegatedMarshaller`2(IUnsafeMarshaller`1<TSrc> marshaller, Func`2<TDst, TSrc> transformMarshall, Func`2<TSrc, TDst> transformUnmarshall);
    public sealed virtual void Marshal(UnsafeWriter writer, TDst value);
    public sealed virtual TDst Unmarshal(UnsafeReader reader);
}
public class JetBrains.Util.PersistentMap.UnsafeFilteredCollectionMarshaller`2 : object {
    private IUnsafeMarshaller`1<T> myElemMarshaller;
    private Predicate`1<T> myFilter;
    private Func`2<int, TCol> myEmptyCollectionCreator;
    public UnsafeFilteredCollectionMarshaller`2(IUnsafeMarshaller`1<T> elemMarshaller, Func`2<int, TCol> emptyCollectionCreator, Predicate`1<T> filter);
    public sealed virtual void Marshal(UnsafeWriter writer, TCol value);
    public sealed virtual TCol Unmarshal(UnsafeReader reader);
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Util.PersistentMap.UnsafeIntArray : ValueType {
    public static UnsafeIntArray Null;
    private int myLen;
    private Int32* myStorage;
    public int Count { get; }
    public int Length { get; }
    public bool IsReadOnly { get; }
    public int Item { get; public set; }
    public UnsafeIntArray(Int32* storage);
    public UnsafeIntArray(int len, Int32* storage);
    private static UnsafeIntArray();
    public static UnsafeIntArray SortAndDistinct(int len, Int32* storage);
    public static UnsafeIntArray Sort(int len, Int32* storage);
    public UnsafeIntArrayEnumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<int> System.Collections.Generic.IEnumerable<System.Int32>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Add(int item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(int item);
    public sealed virtual void CopyTo(Int32[] array, int arrayIndex);
    public sealed virtual bool Remove(int item);
    public sealed virtual int get_Count();
    public int get_Length();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual int IndexOf(int item);
    public sealed virtual void Insert(int index, int item);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual int get_Item(int index);
    public sealed virtual void set_Item(int index, int value);
    public Int32[] ToIntArray();
    public void Reverse();
    public UnsafeIntArray Slice(int startIndex, int endIndex);
    public UnsafeIntArray SliceLength(int startIndex, int length);
    public void ZeroMemory();
}
public class JetBrains.Util.PersistentMap.UnsafeIntArrayEnumerator : ValueType {
    private UnsafeIntArray myUnsafeIntArray;
    private int myCurrent;
    public int Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    internal UnsafeIntArrayEnumerator(UnsafeIntArray unsafeIntArray);
    public sealed virtual void Dispose();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
    public sealed virtual int get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
}
public class JetBrains.Util.PersistentMap.UnsafeLexicographicalIntMarshaller : object {
    public sealed virtual void Marshal(UnsafeWriter writer, int arg);
    public sealed virtual int Unmarshal(UnsafeReader reader);
    public static int ToLittleEndian(int arg);
    public static int ToBigEndian(int arg);
}
public static class JetBrains.Util.PersistentMap.UnsafeMarshallers : object {
    public static IUnsafeMarshaller`1<FileSystemPath> FileSystemPathMarshaller;
    public static IUnsafeMarshaller`1<int> LexicographicalIntMarshaller;
    public static IUnsafeMarshaller`1<UInt32> UIntMarshaller;
    public static IUnsafeMarshaller`1<int> IntMarshaller;
    public static IUnsafeMarshaller`1<long> LongMarshaller;
    public static IUnsafeMarshaller`1<string> UnicodeStringMarshaller;
    public static IUnsafeMarshaller`1<Int32[]> IntArrayMarshaller;
    public static IUnsafeMarshaller`1<String[]> StringArrayMarshaller;
    public static IUnsafeMarshaller`1<Byte[]> ByteArrayMarshaller;
    public static IUnsafeMarshaller`1<Guid> GuidMarshaller;
    public static IUnsafeMarshaller`1<bool> BooleanMarshaller;
    public static Func`2<RawValue, UnsafeIntArray> IntArrayReinterpretCaster;
    [CompilerGeneratedAttribute]
private static Func`2<RawValue, UnsafeIntArray> CS$<>9__CachedAnonymousMethodDelegate10;
    private static UnsafeMarshallers();
    public static IUnsafeMarshaller`1<JetHashSet`1<T>> GetNullFilteredSetMarshaller(IUnsafeMarshaller`1<T> elemMarshaller);
    public static IUnsafeMarshaller`1<T[]> GetArrayMarshaller(ReadDelegate`1<T> readDelegate, WriteDelegate`1<T> writeDelegate);
    public static IUnsafeMarshaller`1<TCol> GetCollectionMarshaller(ReadDelegate`1<T> readDelegate, WriteDelegate`1<T> writeDelegate, Func`2<int, TCol> collectionInit);
    public static IUnsafeMarshaller`1<TCol> GetCollectionMarshaller(IUnsafeMarshaller`1<T> elemMarshaller, Func`2<int, TCol> collectionInit);
    public static IUnsafeMarshaller`1<TCol> GetOneToManyMapMarshaller(IUnsafeMarshaller`1<TKey> keyMarshaller, IUnsafeMarshaller`1<TValue> valueMarshaller, Func`2<int, TCol> collectionInitializer);
    public static IUnsafeMarshaller`1<TEnum> GetEnumMarshaller();
    public static int Compare(Byte* arg1, int size1, Byte* arg2, int size2);
    [CompilerGeneratedAttribute]
private static bool <GetNullFilteredSetMarshaller>b__0(T _);
    [CompilerGeneratedAttribute]
private static TEnum <GetEnumMarshaller>b__d(UnsafeReader reader);
    [CompilerGeneratedAttribute]
private static void <GetEnumMarshaller>b__e(UnsafeWriter writer, TEnum value);
    [CompilerGeneratedAttribute]
private static UnsafeIntArray <.cctor>b__f(RawValue rawValue);
}
public class JetBrains.Util.PersistentMap.UnsafePairMarshaller`2 : object {
    private IUnsafeMarshaller`1<T1> myFirstElementMarshaller;
    private IUnsafeMarshaller`1<T2> mySecondElementMarshaller;
    public UnsafePairMarshaller`2(IUnsafeMarshaller`1<T1> first, IUnsafeMarshaller`1<T2> second);
    public sealed virtual void Marshal(UnsafeWriter writer, Pair`2<T1, T2> value);
    public sealed virtual Pair`2<T1, T2> Unmarshal(UnsafeReader reader);
}
[ExtensionAttribute]
public static class JetBrains.Util.PersistentMap.UnsafeReaderEx : object {
    public static ReadDelegate`1<FileSystemPath> FileSystemPathDelegate;
    [CompilerGeneratedAttribute]
private static ReadDelegate`1<FileSystemPath> CS$<>9__CachedAnonymousMethodDelegate1;
    private static UnsafeReaderEx();
    [ExtensionAttribute]
public static FileSystemPath ReadFileSystemPath(UnsafeReader reader);
    [CompilerGeneratedAttribute]
private static FileSystemPath <.cctor>b__0(UnsafeReader reader);
}
[ObsoleteAttribute("Do not use this implementation, for it allocates a managed object for the structure box on every read or write.")]
public class JetBrains.Util.PersistentMap.UnsafeStructAsIsMarshaller`1 : object {
    public static UnsafeStructAsIsMarshaller`1<T> Instance;
    private int myFixedSize;
    private static UnsafeStructAsIsMarshaller`1();
    public sealed virtual void Marshal(UnsafeWriter writer, T value);
    public sealed virtual T Unmarshal(UnsafeReader reader);
}
[ExtensionAttribute]
public static class JetBrains.Util.PersistentMap.UnsafeWriterEx : object {
    public static WriteDelegate`1<FileSystemPath> FileSystemPathDelegate;
    [CompilerGeneratedAttribute]
private static WriteDelegate`1<FileSystemPath> CS$<>9__CachedAnonymousMethodDelegate1;
    private static UnsafeWriterEx();
    [ExtensionAttribute]
public static void Write(UnsafeWriter writer, FileSystemPath value);
    [CompilerGeneratedAttribute]
private static void <.cctor>b__0(UnsafeWriter writer, FileSystemPath x);
}
public static class JetBrains.Util.PlatformUtil : object {
    public static string ORIGINAL_VARIABLES_NAME_PREFIX;
    public static Platform RuntimePlatform;
    public static bool IsRunningUnderWindows;
    public static bool IsRunningOnMono;
    [CanBeNullAttribute]
public static Version CurrentMonoVersion;
    public static bool CaseSensitiveEnvironmentVariables;
    private static PlatformUtil();
    public static FileSystemInteraction FileSystemIteraction();
    internal static IJetDispatcherStaticMethods JetDispatcherEngineStatic();
    public static JetFileSystemWatcher CreateFileSystemWatcher(FileSystemPath path, string filter, NotifyFilters notifyFilter, bool includeSubdirectories, IWatcherEvents watcherEvents, WinError& rc);
    [NotNullAttribute]
public static FileSystemPath GetCurrentMonoRootDir();
    public static void PrintDebugString(string message);
    public static bool HasGraphicalUserInterface();
    [ObsoleteAttribute("Use ProcessorUtil::Architecture.")]
public static ProcessorArchitecture GetProcessorArchitectureOfCurrentProcess();
    private static void LogEnvironmentVariables(string moniker, IDictionary`2<string, string> env);
    private static IDictionary`2<string, string> ConvertToGenericDictionary(StringDictionary source);
    public static void PrepareEnvironmentVariablesForChildProcess(StringDictionary env);
    public static bool ProcessExists(int pid);
    public static void ChMod(FileSystemPath path, UnixFileModes mode);
}
internal static class JetBrains.Util.PlatformUtilUnix : object {
    private static string GetSysnameFromUname();
    internal static Platform GetUnixPlatform();
    public static bool ProcessExists(int pid);
}
public class JetBrains.Util.PreparedString : ValueType {
    public static PreparedString THIS;
    public static PreparedString OTHER;
    public static PreparedString EMPTY;
    public string Value;
    public bool IsPathAlreadyCanonical;
    private Kind myKind;
    public PreparedString(string value, bool isPathAlreadyCanonical);
    private static PreparedString();
    public bool ReturnThis();
    public bool ReturnOther();
    public bool ReturnEmpty();
}
public static class JetBrains.Util.ProcessWatchdog : object {
    public static void KillSelfIfOtherProcessExits(string pidEnvVariable, int exitCodeOnProcessDeath, ILogger logger, int timeoutMs);
}
public class JetBrains.Util.ProjectedCollection`2 : object {
    [NotNullAttribute]
private ICollection`1<TSrc> myOriginalCollection;
    [NotNullAttribute]
private Func`2<TDst, TSrc> myMapTo;
    [NotNullAttribute]
private Func`2<TSrc, TDst> myMapFrom;
    private Func`2<IEnumerator`1<TSrc>, TDst> myEnumeratorStateMap;
    [NotNullAttribute]
public ICollection`1<TSrc> OriginalCollection { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public ProjectedCollection`2(ICollection`1<TSrc> originalCollection, Func`2<TDst, TSrc> mapTo, Func`2<TSrc, TDst> mapFrom, Func`2<IEnumerator`1<TSrc>, TDst> enumeratorStateStateMap, Lifetime lifetime);
    public ICollection`1<TSrc> get_OriginalCollection();
    public virtual IEnumerator`1<TDst> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual void Add(TDst item);
    public virtual void Clear();
    public virtual bool Contains(TDst item);
    public virtual void CopyTo(TDst[] array, int arrayIndex);
    public virtual bool Remove(TDst item);
    public virtual int get_Count();
    public virtual bool get_IsReadOnly();
    public virtual void Dispose();
    [CompilerGeneratedAttribute]
private TDst <.ctor>b__0(IEnumerator`1<TSrc> x);
}
public class JetBrains.Util.ProjectedEnumerator`2 : object {
    [CompilerGeneratedAttribute]
private IEnumerator`1<TSrc> <OriginalEnumerator>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<IEnumerator`1<TSrc>, TDst> <MapFromState>k__BackingField;
    internal IEnumerator`1<TSrc> OriginalEnumerator { get; private set; }
    internal Func`2<IEnumerator`1<TSrc>, TDst> MapFromState { get; private set; }
    public TDst Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    public ProjectedEnumerator`2(IEnumerator`1<TSrc> originalEnumerator, Func`2<IEnumerator`1<TSrc>, TDst> mapFromState);
    [CompilerGeneratedAttribute]
internal IEnumerator`1<TSrc> get_OriginalEnumerator();
    [CompilerGeneratedAttribute]
private void set_OriginalEnumerator(IEnumerator`1<TSrc> value);
    [CompilerGeneratedAttribute]
internal Func`2<IEnumerator`1<TSrc>, TDst> get_MapFromState();
    [CompilerGeneratedAttribute]
private void set_MapFromState(Func`2<IEnumerator`1<TSrc>, TDst> value);
    public sealed virtual void Dispose();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
    public sealed virtual TDst get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
}
public class JetBrains.Util.RangeTranslator : object {
    private List`1<RangeMap> myMaps;
    private TextRange mySourceRange;
    private TextRange myResultRange;
    public TextRange SourceRange { get; }
    public TextRange ResultRange { get; }
    public IEnumerable`1<RangeMap> Maps { get; }
    public bool IsValid { get; }
    public TextRange get_SourceRange();
    public TextRange get_ResultRange();
    public IEnumerable`1<RangeMap> get_Maps();
    public bool get_IsValid();
    public void MapCharToChar(int source, int result);
    public void MapTextToChar(int sourceOffset, int sourceLength, int resultOffset);
    public void MapCharToText(int sourceOffset, int resultOffset, int resultLength);
    public void MapTextToText(int sourceOffset, int sourceLength, int resultOffset, int resultLength);
    public void MapTextToText(TextRange source, TextRange result);
    public TextRange GetResultRange(int sourceOffset);
    public TextRange GetResultRange(TextRange sourceRange);
    public TextRange GetSourceRange(int resultOffset);
    public TextRange GetSourceRange(TextRange resultRange);
    public void ShiftSource(int delta);
    public void ShiftResult(int delta);
    public void StartMapping(int length);
    public void StartMapping(TextRange sourceRange);
    public void EndMapping(int length);
    public void EndMapping(TextRange resultRange);
    private static int CompareRangeToStartOffset(TextRange range, int offset);
    private static int CompareRangeToEndOffset(TextRange range, int offset);
}
public static class JetBrains.Util.RawRelativePathOperations : object {
    public static PreparedString GetParent(string path);
    public static bool IsEmpty(string path);
    public static PreparedString CombineWithText(string path, string component, bool unrestrictedRelativeMode);
    public static PreparedString Combine(string path, string other);
    public static PreparedString MakeRelativeTo(string path, string basePath);
    [NotNullAttribute]
public static PreparedString TryMakeRelativeTo(string path, string basePath);
    private static int GetLastSeparatorPosition(string path);
    [NotNullAttribute]
public static String[] GetPathComponents(string path);
    [NotNullAttribute]
public static String[] GetPathComponents(string path, int count);
    [NotNullAttribute]
public static string GetExtensionNoDot(string name);
    [NotNullAttribute]
public static string GetExtensionWithDot(string name);
    public static string GetFirstComponent(string path);
    [NotNullAttribute]
public static string GetName(string path);
    [NotNullAttribute]
public static string GetNameWithoutExtension(string path);
    private static DeferQuotedObject QuoteIfNeeded(string path);
}
public class JetBrains.Util.RecordAndThrowLogger : LoggerBase {
    private bool myThreatWarnAsError;
    private IDisposable myMustBeDisposed;
    private CompoundException myCompoundException;
    private SpinWaitLockRef myLock;
    public RecordAndThrowLogger(Lifetime lifetime, bool threatWarnAsError);
    public RecordAndThrowLogger(bool threatWarnAsError);
    public virtual void Log(LogEvent logEvent);
    public virtual bool IsEnabled(LoggingLevel level);
    public sealed virtual void LogOrThrowException(Exception ex, ExceptionOrigin origin);
    private sealed virtual override void System.IDisposable.Dispose();
    private void ThrowUp();
    [CompilerGeneratedAttribute]
private void <.ctor>b__0();
}
public class JetBrains.Util.RecordingLogger : LoggerBase {
    private RecordOrPassMessages myRecordOrPassMessages;
    private ILogger myLoggerForwardTo;
    private IList`1<ExceptionOrigin> myTypesExoriginPassOnly;
    private IList`1<ExceptionOrigin> myTypesExoriginRecordOnly;
    private bool myIsReThrowingWhenAllowed;
    private List`1<ExceptionWithOrigin> myExceptions;
    private int myLoudExceptionsCount;
    private SpinWaitLock myLockExceptions;
    private List`1<MessageWithImportance> myMessages;
    private SpinWaitLock myLockMessages;
    [CompilerGeneratedAttribute]
private static Func`2<ExceptionWithOrigin, Exception> CS$<>9__CachedAnonymousMethodDelegate3;
    [CompilerGeneratedAttribute]
private static Func`2<ExceptionWithOrigin, Exception> CS$<>9__CachedAnonymousMethodDelegate5;
    public bool IsWithLoudExceptions { get; }
    public RecordingLogger(LogOrThrowExceptions logOrThrowExceptions, RecordOrPassMessages recordOrPassMessages, ILogger loggerForwardTo, IList`1<ExceptionOrigin> typesExoriginPassOnly, IList`1<ExceptionOrigin> typesExoriginRecordOnly);
    private void LogEventWithException(LogEvent logEvent);
    private sealed virtual override void JetBrains.Util.IExceptionThrowingLogger.LogOrThrowException(Exception ex, ExceptionOrigin origin);
    private void LogEventWithMessage(LogEvent logEvent);
    public virtual void Log(LogEvent logEvent);
    public virtual bool IsEnabled(LoggingLevel level);
    [NotNullAttribute]
public IList`1<ExceptionWithOrigin> CopyExceptions();
    [CanBeNullAttribute]
public CompoundException CopyExceptionsCompound();
    [NotNullAttribute]
public IList`1<ExceptionWithOrigin> CopyExceptionsAndClear();
    [CanBeNullAttribute]
public CompoundException CopyExceptionsAndClearCompound();
    public bool get_IsWithLoudExceptions();
    [CompilerGeneratedAttribute]
private static Exception <CopyExceptionsCompound>b__2(ExceptionWithOrigin exo);
    [CompilerGeneratedAttribute]
private static Exception <CopyExceptionsAndClearCompound>b__4(ExceptionWithOrigin exo);
}
public class JetBrains.Util.Reflection.AppDomainAssembliesResolver : object {
    private static ILogger Logger;
    private static Version VersionNone;
    [NotNullAttribute]
private OneToListMap`2<AssemblyKey, AssemblyBinding> AssemblyByIdentity;
    [NotNullAttribute]
public ResolveEventHandler AssemblyResolveDelegate;
    private static AppDomainAssembliesResolver();
    public void AddRemoveAssembly(AssemblyNameInfo assname, AssemblyBinding binder, AddRemove addremove);
    public static void CreateAndInstall(Lifetime lifetime, ICollectionEvents`1<Pair`2<AssemblyNameInfo, Func`1<Assembly>>> assemblies);
    public static void CreateAndInstall(Lifetime lifetime, ICollection`1<AssemblyNameAndLocation> assemblies);
    public void Install(Lifetime lifetime);
    private Assembly AssemblyResolve(object sender, ResolveEventArgs args);
    [CompilerGeneratedAttribute]
private void <Install>b__7();
    [CompilerGeneratedAttribute]
private void <Install>b__8();
}
public enum JetBrains.Util.Reflection.AssemblyIdentityContentTypes : Enum {
    public byte value__;
    public static AssemblyIdentityContentTypes O;
    public static AssemblyIdentityContentTypes WindowsRuntime;
}
[FlagsAttribute]
public enum JetBrains.Util.Reflection.AssemblyIdentityFlags : Enum {
    public UInt32 value__;
    public static AssemblyIdentityFlags Culture;
    public static AssemblyIdentityFlags Version;
    public static AssemblyIdentityFlags PublicKeyToken;
    public static AssemblyIdentityFlags PublicKey;
    public static AssemblyIdentityFlags PublicKeyTokenNull;
    public static AssemblyIdentityFlags ProcessorArchitecture;
    public static AssemblyIdentityFlags Retargetable;
    public static AssemblyIdentityFlags ContentType;
    public static AssemblyIdentityFlags Custom;
    public static AssemblyIdentityFlags CustomNull;
}
public static class JetBrains.Util.Reflection.AssemblyNameInfoFactory : object {
    private static ConcurrentDictionary`2<string, AssemblyNameInfo> ourInternedAssemblyNameInfos;
    private static ConcurrentDictionary`2<StringSource, AssemblyNameInfo> ourInternedAssemblyNameInfosByStringSource;
    private static Func`2<string, AssemblyNameInfo> myCachedDelegate1;
    [CompilerGeneratedAttribute]
private static Func`2<string, AssemblyNameInfo> CS$<>9__CachedAnonymousMethodDelegate1;
    private static AssemblyNameInfoFactory();
    [NotNullAttribute]
public static AssemblyNameInfo Create(string assemblyFullName);
    [NotNullAttribute]
internal static AssemblyNameInfo Create(StringSource assemblyFullName);
    [NotNullAttribute]
public static AssemblyNameInfo Create(AssemblyName assemblyName);
    [NotNullAttribute]
public static AssemblyNameInfo Create2(string simplename, Version version, PublicKeyToken pktoken, string culture, string codeBase, Byte[] publickey, ProcessorArchitecture processor, bool isRetargetable, AssemblyIdentityContentTypes contenttype, object custom, AssemblyHashAlgorithm hashalg);
    [NotNullAttribute]
[ObsoleteAttribute("Use another overload. Some of the values passed into this function will be ignored, and others will undergo a lossy conversion.")]
public static AssemblyNameInfo Create(string name, Version version, Byte[] publicKeyToken, string culture, AssemblyNameInfoFlags flags, string codeBase);
    public static void AddEntry(AssemblyNameInfo asm);
    [ContractAnnotationAttribute("null => null; notnull => notnull")]
[CanBeNullAttribute]
public static AssemblyNameInfo Intern(AssemblyNameInfo asm);
    [CompilerGeneratedAttribute]
private static AssemblyNameInfo <.cctor>b__0(string s);
}
public class JetBrains.Util.Reflection.AssemblyNameInfoParseException : ArgumentOutOfRangeException {
    public AssemblyNameInfoParseException(Exception exInner);
    protected AssemblyNameInfoParseException(SerializationInfo info, StreamingContext context);
}
public static class JetBrains.Util.Reflection.AssemblyTextualIdentityParser : object {
    public static UInt32 PublicKeyMaxCbLen;
    public static UInt32 PublicKeyMinCbLen;
    public static UInt32 PublicKeyTokenCbLen;
    private static AttributeName[] AttributeNames;
    public static ProcessorArchitectureName[] ProcessorArchitectureNames;
    private static AssemblyTextualIdentityParser();
    public static void EscapeString(string text, StringBuilder sb);
    public static void Parse(string sTextualIdentity, EscapeMode escapemode, Quirks quirks, Parsed& result);
    public static void Parse(StringSource ssTextualIdentity, EscapeMode escapemode, Quirks quirks, Parsed& result);
    private static void Parse(Char* pchTextualIdentity, UInt32 cchLength, EscapeMode escapemode, Quirks quirks, StringSource originalstring, Parsed& result);
    private static void CommitAttributeValue(StringSource& ssTextualIdentity, Char* pch0, Char* pch, Char* pchBufferStart, Char* pchBufferEnd, bool isQuotedString, Attribute attr, Quirks quirks, AssemblyIdentityFlags& seen, Parsed& result);
    private static Byte[] CommitAttributeValue_Custom(StringSource& ssTextualIdentity, Char* pchBufferStart, Char* pchBufferEnd);
    private static ProcessorArchitecture CommitAttributeValue_ProcessorArchitecture(StringSource& ssTextualIdentity, Char* pchBufferStart, Char* pchBufferEnd);
    private static Byte[] CommitAttributeValue_PublicKey(StringSource& ssTextualIdentity, Char* pchBufferStart, Char* pchBufferEnd);
    private static ulong CommitAttributeValue_PublicKeyToken(StringSource& ssTextualIdentity, Char* pchBufferStart, Char* pchBufferEnd);
    private static void CommitAttributeValue_Version(StringSource& ssTextualIdentity, Char* pchBufferStart, Char* pchBufferEnd, Quirks quirks, Parsed& result);
    private static StringSource CommitParsedString(StringSource& ssTextualIdentity, Char* pch0, Char* pch, Char* pchBufferStart, Char* pchBufferCur, bool isQuotedString);
    private static bool EqualsAsciiToLower(Char* pchBufferStart, Char* pchBufferEnd, string target);
    private static Attribute ParseAttribute(StringSource& ssTextualIdentity, Char* pch0, Char* pch, Char* pchBufferStart, Char* pchBufferCur, bool isStringQuoted);
    [PureAttribute]
private static Char* TrimTrailingWhitespace(Char* pchBufferStart, Char* pchBufferCur, bool isStringQuoted);
}
public static class JetBrains.Util.Reflection.CallStackAnnotation : object {
    private static Dictionary`2<InstanceMethodKey, Delegate> myMapInstanceMethods;
    private static ModuleBuilder myModule;
    private static Dictionary`2<Pair`2<string, string>, Action`1<Action>> myMapActions;
    private static Dictionary`2<DelegateKey, Delegate> myMapDelegates;
    private static MethodInfo myActionInvoke;
    private static Dictionary`2<string, int> myMapDefinedTypeNames;
    private static string MethodNameInvoke;
    private static Pair`2<ModuleBuilder, IList> myCachedModuleField;
    [CompilerGeneratedAttribute]
private static Func`2<int, string> CS$<>9__CachedAnonymousMethodDelegate9;
    private static CallStackAnnotation();
    public static Delegate AnnotateInstanceMethod(Type typeTargetMethodOwner, string sTargetMethodName, Pair`2<string, string> sStackFrameText, Type[] typeParamsExceptThis, Type typeRetVal);
    public static Action`1<Action> AnnotateAction(Pair`2<string, string> stackFrameText);
    public static Delegate AnnotateDelegate(Pair`2<string, string> sStackFrameText, bool isWithReturnValue, Type[] typeGenericParamsForDelegateInstantiation, Func`2<Type[], Type[]> FCreateParamsAndRetVal);
    private static Delegate AnnotateInstanceMethod_Emit(Type typeTargetMethodOwner, string sTargetMethodName, string sStackFrameText, Type[] typeParamsExceptThis, Type typeRetVal);
    private static Delegate AnnotateInstanceMethod_EmitDynamicAssembly(Type typeTargetMethodOwner, string sTargetMethodName, Pair`2<string, string> sStackFrameText, Type[] typeParamsExceptThis, Type typeRetVal);
    public static void Ldarg(ILGenerator ilgen, int nArgsToLoad);
    private static Action`1<Action> AnnotateAction_EmitDynamicAssembly(Pair`2<string, string> sStackFrameText);
    private static Delegate AnnotateDelegate_EmitDynamicAssembly(Pair`2<string, string> sStackFrameText, Type[] typeGenericParamsForDelegateInstantiation, bool isWithReturnValue, Func`2<Type[], Type[]> fCreateParamsAndRetVal);
    private static MethodInfo GetActionInvoke();
    private static TypeBuilder DefineType(string sTypeName);
    private static ModuleBuilder GetModule();
    [NotNullAttribute]
private static Type ConstructDelegateType(Type[] typeMethodParamsAndRetval, bool isWithRetval);
    [NotNullAttribute]
private static Type ConstructDelegateType(Type[] typeMethodParams, Type typeRetVal);
    [CompilerGeneratedAttribute]
private static string <AnnotateDelegate_EmitDynamicAssembly>b__8(int n);
}
public class JetBrains.Util.Reflection.CodeDomAssemblyReferences : object {
    public JetHashSet`1<AssemblyNameInfo> AssemblyNames;
    public virtual string ToString();
}
public static class JetBrains.Util.Reflection.CodeDomEx : object {
    [CompilerGeneratedAttribute]
private static Func`2<Type, AssemblyNameInfo> CS$<>9__CachedAnonymousMethodDelegate5;
    [NotNullAttribute]
public static CodeConditionStatement ArgumentNullException(string sParameterName);
    [NotNullAttribute]
public static CodeTypeReference MakeSpecializedGenericReference(CodeTypeReference opengeneric, CodeTypeReference[] specializations);
    [ObsoleteAttribute("Use an overload which tracks assembly references for this type.")]
[NotNullAttribute]
public static CodeTypeReference MakeTypeReference(Type type);
    [ObsoleteAttribute("Use an overload which tracks assembly references for this type.")]
[NotNullAttribute]
public static CodeTypeReference MakeTypeReference();
    [NotNullAttribute]
[ObsoleteAttribute("This method won't add an assembly reference for your type. If you're adding a part catalog type, use the CodeDomCatalogEx class.")]
public static CodeTypeReference MakeTypeReference(string sFullyQualifiedName);
    [NotNullAttribute]
public static CodeTypeReference MakeTypeReference(string sFullyQualifiedName, CodeDomAssemblyReferences refs, AssemblyNameInfo[] referencedassembly);
    [NotNullAttribute]
public static CodeTypeReference MakeTypeReference(Type type, CodeDomAssemblyReferences refs);
    [NotNullAttribute]
public static CodeTypeReference MakeTypeReference(CodeDomAssemblyReferences refs);
    public static void WriteCodeToFile(CodeCompileUnit code, FileSystemPath filepath);
    private static void WriteCodeToFile_Stream(CodeCompileUnit code, FileSystemPath filepath, Stream stream);
    [CompilerGeneratedAttribute]
private static AssemblyNameInfo <MakeTypeReference>b__4(Type t);
}
public enum JetBrains.Util.Reflection.ImportDefinitionKind : Enum {
    public int value__;
    public static ImportDefinitionKind ImportNamespace;
    public static ImportDefinitionKind ImportAssemblyNamespace;
    public static ImportDefinitionKind ImportType;
    public static ImportDefinitionKind ImportXmlNamespace;
    public static ImportDefinitionKind ImportAssemblyReferenceAlias;
    public static ImportDefinitionKind AliasAssemblyReference;
    public static ImportDefinitionKind AliasNamespace;
    public static ImportDefinitionKind AliasAssemblyNamespace;
    public static ImportDefinitionKind AliasType;
}
public class JetBrains.Util.Reflection.InterfaceImplementation : object {
    private static ModuleBuilder myModule;
    private static Dictionary`2<string, int> myMapDefinedTypeNames;
    private static InterfaceImplementation();
    private static TypeBuilder DefineType(string sTypeName);
    private static ModuleBuilder GetModule();
    public TInterface CreateDelegatingInterfaceImplementation_Emit(TInterface delegatee);
    private void CreateDelegatingInterfaceImplementation_Emit_Member(TypeBuilder typebuilder, MemberInfo member);
    private void CreateDelegatingInterfaceImplementation_Emit_Member_Method(TypeBuilder typebuilder, MethodInfo method);
    public static void Ldarg(ILGenerator ilgen, int nArgsToLoad, Boolean[] isRefParam);
    [CompilerGeneratedAttribute]
private static Type <CreateDelegatingInterfaceImplementation_Emit_Member_Method>b__5(ParameterInfo param);
    [CompilerGeneratedAttribute]
private static Type[] <CreateDelegatingInterfaceImplementation_Emit_Member_Method>b__6(ParameterInfo param);
    [CompilerGeneratedAttribute]
private static Type[] <CreateDelegatingInterfaceImplementation_Emit_Member_Method>b__7(ParameterInfo param);
    [CompilerGeneratedAttribute]
private static bool <CreateDelegatingInterfaceImplementation_Emit_Member_Method>b__8(ParameterInfo param);
}
[FlagsAttribute]
public enum JetBrains.Util.Reflection.LocalVariableAttributes : Enum {
    public ushort value__;
    public static LocalVariableAttributes None;
    public static LocalVariableAttributes DebuggerHidden;
}
public class JetBrains.Util.Reflection.PublicKeyTokenInterner : object {
    private static Dictionary`2<string, Byte[]> ourPublicKeyTokenIntern;
    private static Dictionary`2<string, Byte[]> ourPublicKeyIntern;
    private static ReaderWriterLockSlim ourReaderWriterLock;
    private static PublicKeyTokenInterner();
    public static Byte[] GetPublicKeyToken(string publicKeyTokenString);
    public static Byte[] GetPublicKey(string publicKey);
    private static Byte[] GetPublicKeyTokenRaw(string value);
    private static Byte[] GetPublicKeyRaw(string publicKey);
}
public class JetBrains.Util.Reflection.SimpleValueSerializer`1 : ValueSerializerBase`1<T> {
    [CompilerGeneratedAttribute]
private static Func`2<T, string> CS$<>9__CachedAnonymousMethodDelegate2;
    [CompilerGeneratedAttribute]
private static Func`2<string, T> CS$<>9__CachedAnonymousMethodDelegate3;
    [CompilerGeneratedAttribute]
private static string <.ctor>b__0(T o);
    [CompilerGeneratedAttribute]
private static T <.ctor>b__1(string s);
}
public class JetBrains.Util.Reflection.TypeConverterBase`1 : TypeConverter {
    [CanBeNullAttribute]
private Func`4<ITypeDescriptorContext, CultureInfo, string, T> myΛFromString1;
    [CanBeNullAttribute]
private Func`4<CultureInfo, string, ILogger, T> myΛFromString2;
    [CanBeNullAttribute]
private Func`2<string, T> myΛFromString3;
    [CanBeNullAttribute]
private Func`4<ITypeDescriptorContext, CultureInfo, T, string> myΛToString1;
    [CanBeNullAttribute]
private Func`4<CultureInfo, T, ILogger, string> myΛToString2;
    [CanBeNullAttribute]
private Func`2<T, string> myΛToString3;
    [EditorBrowsableAttribute("2")]
public TypeConverterBase`1(Func`4<ITypeDescriptorContext, CultureInfo, T, string> λToString, Func`4<ITypeDescriptorContext, CultureInfo, string, T> λFromString);
    [EditorBrowsableAttribute("2")]
public TypeConverterBase`1(Func`4<CultureInfo, T, ILogger, string> λToString, Func`4<CultureInfo, string, ILogger, T> λFromString);
    public TypeConverterBase`1(Func`2<T, string> λToString, Func`2<string, T> λFromString);
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public static class JetBrains.Util.Reflection.TypeConverterUtil : object {
    public static string ToStringThruXml(Action`1<XmlElement> fillXmlAction, string elementName);
    public static string ToStringThruXmlFormatted(Action`1<XmlElement> fillXmlAction, string elementName);
    public static T FromStringThruXml(string value, Func`2<XmlElement, T> fromXmlFunc);
}
public class JetBrains.Util.Reflection.ValueSerializerBase`1 : ValueSerializer {
    [CanBeNullAttribute]
private Func`3<IValueSerializerContext, string, T> myΛFromString1;
    [CanBeNullAttribute]
private Func`3<string, ILogger, T> myΛFromString2;
    [CanBeNullAttribute]
private Func`2<string, T> myΛFromString3;
    [CanBeNullAttribute]
private Func`3<IValueSerializerContext, T, string> myΛToString1;
    [CanBeNullAttribute]
private Func`3<T, ILogger, string> myΛToString2;
    [CanBeNullAttribute]
private Func`2<T, string> myΛToString3;
    [EditorBrowsableAttribute("2")]
public ValueSerializerBase`1(Func`3<IValueSerializerContext, T, string> λToString, Func`3<IValueSerializerContext, string, T> λFromString);
    [EditorBrowsableAttribute("2")]
public ValueSerializerBase`1(Func`3<T, ILogger, string> λToString, Func`3<string, ILogger, T> λFromString);
    public ValueSerializerBase`1(Func`2<T, string> λToString, Func`2<string, T> λFromString);
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
[ValueSerializerAttribute("JetBrains.Util.RelativePathSerializer")]
[TypeConverterAttribute("JetBrains.Util.RelativePathConverter")]
[PublicAPIAttribute]
public class JetBrains.Util.RelativePath : object {
    private static DirectMappedCache`2<string, RelativePath> ourIntern;
    private Nullable`1<int> myHashCode;
    private String modreq(System.Runtime.CompilerServices.IsVolatile) myName;
    private String modreq(System.Runtime.CompilerServices.IsVolatile) myNameWithoutExtension;
    [NotNullAttribute]
public static RelativePath Empty;
    [NotNullAttribute]
public string FullPath;
    private static Func`3<string, bool, RelativePath> myCachedDelegate1;
    [CompilerGeneratedAttribute]
private static Action CS$<>9__CachedAnonymousMethodDelegate2;
    [CompilerGeneratedAttribute]
private static Func`3<string, bool, RelativePath> CS$<>9__CachedAnonymousMethodDelegate8;
    public bool IsValidOnCurrentOS { get; }
    [NotNullAttribute]
public RelativePath Parent { get; }
    public string ExtensionNoDot { get; }
    public string ExtensionWithDot { get; }
    public string FirstComponent { get; }
    public bool IsAbsolute { get; }
    public bool IsEmpty { get; }
    public string Name { get; }
    public string NameWithoutExtension { get; }
    private IPath JetBrains.Util.IPath.Empty { get; }
    private string JetBrains.Util.IPath.FullPath { get; }
    private IPath JetBrains.Util.IPath.Parent { get; }
    [ObsoleteAttribute("The constructor is left for backward compatibility only. Use RelativePath.Parse or RelativePath.TryParse instead")]
public RelativePath(string path);
    private RelativePath(string path, bool isPathAlreadyCanonical);
    private static RelativePath();
    public sealed virtual bool get_IsValidOnCurrentOS();
    public RelativePath get_Parent();
    public static void AllowIntern(Lifetime lifetime, int maxEntries);
    public static void ClearIntern();
    [PureAttribute]
[NotNullAttribute]
public static RelativePath Parse(string path);
    [PureAttribute]
[NotNullAttribute]
public static RelativePath TryParse(string path);
    [NotNullAttribute]
public static RelativePath op_Division(RelativePath path, RelativePath other);
    [NotNullAttribute]
public static RelativePath op_Division(RelativePath path, string component);
    public static bool op_Equality(RelativePath left, RelativePath right);
    public static string op_Explicit(RelativePath path);
    public static Uri op_Explicit(RelativePath path);
    public static RelativePath op_Explicit(Uri uri);
    public static RelativePath op_Implicit(string path);
    public static bool op_Inequality(RelativePath left, RelativePath right);
    [NotNullAttribute]
public static RelativePath CreateByCanonicalPath(string path);
    [NotNullAttribute]
[PureAttribute]
public RelativePath Combine(string component);
    [PureAttribute]
[NotNullAttribute]
public RelativePath Combine(RelativePath other);
    [NotNullAttribute]
[PureAttribute]
public RelativePath MakeRelativeTo(RelativePath basePath);
    [NotNullAttribute]
[PureAttribute]
public RelativePath TryMakeRelativeTo(RelativePath basePath);
    [NotNullAttribute]
private static RelativePath Create(string path, bool isPathAlreadyCanonical);
    private static DirectMappedCache`2<string, RelativePath> CreateIntern(int maxEntries);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public sealed virtual int CompareTo(RelativePath other);
    public sealed virtual bool Equals(RelativePath other);
    [NotNullAttribute]
public sealed virtual String[] GetPathComponents();
    [NotNullAttribute]
public String[] GetPathComponents(int count);
    [NotNullAttribute]
public sealed virtual Uri ToDirectoryUri();
    [NotNullAttribute]
public sealed virtual Uri ToUri();
    private sealed virtual override IPath JetBrains.Util.IPath.Combine(RelativePath other);
    private sealed virtual override IPath JetBrains.Util.IPath.Parse(string text);
    [NotNullAttribute]
private sealed virtual override IPath JetBrains.Util.IPath.TryCombine(string component);
    public sealed virtual string get_ExtensionNoDot();
    public sealed virtual string get_ExtensionWithDot();
    public sealed virtual string get_FirstComponent();
    public sealed virtual bool get_IsAbsolute();
    public sealed virtual bool get_IsEmpty();
    public sealed virtual string get_Name();
    public sealed virtual string get_NameWithoutExtension();
    [NotNullAttribute]
[PureAttribute]
public RelativePath Clone();
    private sealed virtual override IPath JetBrains.Util.IPath.get_Empty();
    private sealed virtual override string JetBrains.Util.IPath.get_FullPath();
    private sealed virtual override IPath JetBrains.Util.IPath.get_Parent();
    public static BackSlashSeparatedRelativePath op_Explicit(RelativePath path);
    private static RelativePath Create(PreparedString preparedString, RelativePath this, RelativePath other);
    private static RelativePath Create(PreparedString preparedString, RelativePath this);
    [CompilerGeneratedAttribute]
private static void <AllowIntern>b__1();
    [CompilerGeneratedAttribute]
private static RelativePath <.cctor>b__7(string key, bool canonical);
}
public class JetBrains.Util.RelativePathConverter : TypeConverterBase`1<RelativePath> {
    [CompilerGeneratedAttribute]
private static Func`4<ITypeDescriptorContext, CultureInfo, RelativePath, string> CS$<>9__CachedAnonymousMethodDelegate2;
    [CompilerGeneratedAttribute]
private static Func`4<ITypeDescriptorContext, CultureInfo, string, RelativePath> CS$<>9__CachedAnonymousMethodDelegate3;
    [CompilerGeneratedAttribute]
private static string <.ctor>b__0(ITypeDescriptorContext context, CultureInfo info, RelativePath value);
    [CompilerGeneratedAttribute]
private static RelativePath <.ctor>b__1(ITypeDescriptorContext descriptorContext, CultureInfo cultureInfo, string value);
}
public class JetBrains.Util.RelativePathSerializer : ValueSerializerBase`1<RelativePath> {
    [CompilerGeneratedAttribute]
private static Func`3<IValueSerializerContext, RelativePath, string> CS$<>9__CachedAnonymousMethodDelegate2;
    [CompilerGeneratedAttribute]
private static Func`3<IValueSerializerContext, string, RelativePath> CS$<>9__CachedAnonymousMethodDelegate3;
    [CompilerGeneratedAttribute]
private static string <.ctor>b__0(IValueSerializerContext context, RelativePath value);
    [CompilerGeneratedAttribute]
private static RelativePath <.ctor>b__1(IValueSerializerContext descriptorContext, string value);
}
public static class JetBrains.Util.ReparsePoints : object {
    private static UInt32 ReparseDataBufferCbSize;
    private static string SubstituteNamePrefix;
    [ThreadStaticAttribute]
private static Byte[] ReparseDataBuffer;
    private static ReparsePoints();
    public static void DeleteDirectoryJunction(FileSystemPath sourcedir);
    public static void DeleteDirectoryJunction(Void* hFile);
    public static UInt32 GetReparseBuffer(Void* hFile, Void* pBuffer, UInt32 cbBuffer);
    public static bool IsDirectoryJunctionByHandle(Void* hFile);
    public static bool IsDirectoryJunctionByPath(FileSystemPath path);
    public static bool IsReparsePoint(Void* hFile);
    public static bool IsReparsePoint(FileSystemPath path);
    public static bool IsVolumeSupportReparsePoints(char drive);
    public static bool IsVolumeSupportReparsePoints(FileSystemPath somepath);
    public static void SetDirectoryJunction(FileSystemPath sourcedir, FileSystemPath targetpath);
    public static void SetDirectoryJunction(Void* hFile, FileSystemPath targetpath);
    [CanBeNullAttribute]
public static FileSystemPath TryGetDirectoryJunctionTarget(FileSystemPath path);
    public static Nullable`1<UInt32> TryGetReparsePointTagByHandle(Void* hFile);
    public static Nullable`1<UInt32> TryGetReparsePointTagByPath(FileSystemPath path);
    private static UInt32 GetReparseTag(Void* hFile);
    [CanBeNullAttribute]
private static FileSystemPath TryGetDirectoryJunctionTarget(Void* hFile);
}
internal class JetBrains.Util.ResultListDebugView`1 : object {
    [NotNullAttribute]
private T[] myArray;
    [NotNullAttribute]
[DebuggerBrowsableAttribute("3")]
public T[] Items { get; }
    public ResultListDebugView`1(ResultList<T> result);
    public T[] get_Items();
}
public abstract class JetBrains.Util.SafeDisposable : object {
    protected Boolean modreq(System.Runtime.CompilerServices.IsVolatile) IsDisposing;
    protected Boolean modreq(System.Runtime.CompilerServices.IsVolatile) IsDisposed;
    [CanBeNullAttribute]
protected StackFrame[] ConstructorInvocationStackFrame;
    protected bool WarnOnSecondDispose { get; }
    protected SafeDisposable(bool canCaptureStacktraces);
    protected virtual bool get_WarnOnSecondDispose();
    protected abstract virtual void DisposeUnmanagedResources();
    private void DisposeInternal();
    protected virtual void Finalize();
    [ThreadUnsafeAttribute]
public sealed virtual void Dispose();
    [ThreadUnsafeAttribute]
public static void DisposeIfNecessary(object o);
}
[ExtensionAttribute]
public static class JetBrains.Util.SortUtil : object {
    public static ICollection`1<FileSystemPath> SortFilePaths(ICollection filePaths);
    public static IEnumerable`1<FileSystemPath> SortFilePaths(IEnumerable`1<FileSystemPath> filePaths);
    public static ICollection`1<FileSystemPath> SortFilePaths(ICollection`1<FileSystemPath> filePaths);
    public static ICollection`1<string> SortStrings(ICollection`1<string> strings);
    [ExtensionAttribute]
public static List`1<T> TopoSort(IEnumerable`1<T> items, Func`3<T, T, Nullable`1<int>> comparer, IEqualityComparer`1<T> equalityComparer);
    public static List`1<T> SparseTopoSort(IEnumerable`1<T> items, Func`2<T, IEnumerable`1<T>> dependencyProvider);
    [CompilerGeneratedAttribute]
private static bool <TopoSort>b__1(Nullable`1<int> compareResult);
}
[ExtensionAttribute]
public static class JetBrains.Util.Special.GeneralUtil : object {
    [ExtensionAttribute]
public static int EnsureInRange(int value, int lowerBound, int upperBound);
    [DebuggerStepThroughAttribute]
[EditorBrowsableAttribute("1")]
public static void If(bool condition, Action FTrue, Action FFalse);
    [DebuggerStepThroughAttribute]
[EditorBrowsableAttribute("1")]
public static void If(bool condition, Action FTrue);
    [EditorBrowsableAttribute("1")]
[DebuggerStepThroughAttribute]
[ContractAnnotationAttribute("object:null => null")]
[ExtensionAttribute]
public static TResult IfNotNull(TInput object, Func`2<TInput, TResult> functor);
    [ExtensionAttribute]
[ContractAnnotationAttribute("object:null => null")]
[EditorBrowsableAttribute("1")]
[DebuggerStepThroughAttribute]
public static TResult IfNotNull(Nullable`1<TInput> object, Func`2<Nullable`1<TInput>, TResult> functor);
    [EditorBrowsableAttribute("1")]
[DebuggerStepThroughAttribute]
[ExtensionAttribute]
public static TResult IfNotNull(TInput object, Func`2<TInput, TResult> functor, TResult default);
    [EditorBrowsableAttribute("1")]
[DebuggerStepThroughAttribute]
[ExtensionAttribute]
public static TResult IfNotNull(TInput object, Func`2<TInput, TResult> functor, Func`1<TResult> default);
    [DebuggerStepThroughAttribute]
[EditorBrowsableAttribute("1")]
[ExtensionAttribute]
public static void DoIfNotNull(TInput object, Action`1<TInput> functor);
    [DebuggerStepThroughAttribute]
[EditorBrowsableAttribute("1")]
[ExtensionAttribute]
public static void DoIfNotNull(Nullable`1<TInput> object, Action`1<Nullable`1<TInput>> functor);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
[EditorBrowsableAttribute("1")]
public static T IfNull(T object, Func`1<T> functor);
    [EditorBrowsableAttribute("1")]
[ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static bool IsAnyOf(T t, T[] set);
    [DebuggerStepThroughAttribute]
[EditorBrowsableAttribute("1")]
public static bool AllNotNull(Object[] set);
    [EditorBrowsableAttribute("1")]
[ExtensionAttribute]
public static DeferQuotedObject QuoteIfNeeded(object o);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static DeferQuotedThread QuoteIfNeeded(Thread thread);
    [EditorBrowsableAttribute("1")]
[DebuggerStepThroughAttribute]
[NotNullAttribute]
[ExtensionAttribute]
private static string QuoteIfNeededCore(object o);
    [EditorBrowsableAttribute("1")]
[ExtensionAttribute]
public static DeferQuotedList QuoteListIfNeeded(IEnumerable thіs);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static DeferQuotedSet QuoteSetIfNeeded(IEnumerable thіs);
    [EditorBrowsableAttribute("1")]
[ExtensionAttribute]
public static DeferQuotedCollectionSourceSet`1<TItem> QuoteSetIfNeeded(CollectionSource`1<TItem> thіs);
    [EditorBrowsableAttribute("1")]
[ExtensionAttribute]
public static DeferQuotedFrugalLocalList`1<TItem> QuoteSetIfNeeded(FrugalLocalList`1<TItem> thіs);
    [EditorBrowsableAttribute("1")]
[NotNullAttribute]
[ExtensionAttribute]
private static string QuoteListIfNeededCore(IEnumerable thіs);
    [NotNullAttribute]
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
private static string QuoteSetIfNeededCore(IEnumerable thіs);
    [DebuggerStepThroughAttribute]
[EditorBrowsableAttribute("1")]
public static T Return(Action`1<Func`2<T, T>> action);
    [EditorBrowsableAttribute("1")]
[DebuggerStepThroughAttribute]
[ExtensionAttribute]
public static T With(T control, Action`1<T> action);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
[DebuggerStepThroughAttribute]
public static void WithDispose(T disposable, Action`1<T> action);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
[EditorBrowsableAttribute("1")]
public static R WithDispose(T disposable, Func`2<T, R> F);
    [DebuggerStepThroughAttribute]
[EditorBrowsableAttribute("1")]
[ExtensionAttribute]
public static void WithDisposeNotNull(T disposable, Action`1<T> F);
    [EditorBrowsableAttribute("1")]
[DebuggerStepThroughAttribute]
[ExtensionAttribute]
public static T WithNotNull(T item, Action`1<T> F);
    public static IEnumerable`1<T> SelfAndParentReversedPath(T node, Func`2<T, T> getParent);
    public static IEnumerable`1<T> ParentReversedPath(T node, Func`2<T, T> getParent);
    public static bool Dfs(T root, Func`2<T, bool> action, Func`2<T, IEnumerable`1<T>> getChildren, Func`2<T, bool> visitChildren);
    [ExtensionAttribute]
[SourceTemplateAttribute]
public static void instring(int index, string s);
    [SourceTemplateAttribute]
[ExtensionAttribute]
public static void ifnempty(string s);
}
public class JetBrains.Util.src.dataStructures.BlockingPriorityQueue`1 : object {
    private Lifetime myLifetime;
    private JetPriorityQueue`1<T> myQueue;
    private object mySentry;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public BlockingPriorityQueue`1(Lifetime lifetime, int initialCapacity, IComparer`1<T> comparer);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual bool Remove(T item);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool TryExtract(T& res);
    public sealed virtual bool TryPeek(T& res);
    public bool TryExtract(T& res, int intervalMs);
    public bool TryPeek(T& res, int intervalMs);
    public T ExtractOrBlock();
    public int Enqueue(T item);
    public T[] ToArray();
    [CompilerGeneratedAttribute]
private void <.ctor>b__1();
}
public interface JetBrains.Util.src.dataStructures.IPriorityQueue`1 {
    public int Count { get; }
    public abstract virtual int get_Count();
    public abstract virtual bool TryExtract(T& res);
    public abstract virtual bool TryPeek(T& res);
}
public class JetBrains.Util.src.dataStructures.JetPriorityQueue`1 : object {
    private static int DefaultCapacity;
    private List`1<T> myStorage;
    private IComparer`1<T> myComparer;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public JetPriorityQueue`1(int initialCapacity, IComparer`1<T> comparer);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual bool Remove(T item);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool TryExtract(T& res);
    public sealed virtual bool TryPeek(T& res);
    private void Swap(Int32& i, int j);
    private void HeapDown(int idx);
    private void HeapUp(int idx);
}
[ExtensionAttribute]
public static class JetBrains.Util.src.dataStructures.PriorityQueueEx : object {
    [ExtensionAttribute]
public static void Enqueue(IPriorityQueue`1<T> queue, T val);
    [ExtensionAttribute]
public static T ExtractOrDefault(IPriorityQueue`1<T> queue);
    [ExtensionAttribute]
public static T Extract(IPriorityQueue`1<T> queue);
    [ExtensionAttribute]
public static T Peek(IPriorityQueue`1<T> queue);
}
[TypeConverterAttribute("JetBrains.Util.StringSlice/StringSliceConverter")]
[DefaultMemberAttribute("Item")]
[ValueSerializerAttribute("JetBrains.Util.StringSlice/StringSliceSerializer")]
public class JetBrains.Util.StringSlice : ValueType {
    private int myLength;
    private int myStart;
    private string myString;
    public static StringSlice Empty;
    [NotNullAttribute]
public static IEqualityComparer`1<StringSlice> DefaultComparer;
    [NotNullAttribute]
public static IEqualityComparer`1<StringSlice> CaseInsensitiveComparer;
    [NotNullAttribute]
private static CompareInfo myInvariantCultureCompareInfo;
    public int Length { get; }
    public char Item { get; }
    public bool IsEmpty { get; }
    public StringSlice(string s);
    public StringSlice(string s, TextRange range);
    public StringSlice(string s, int start);
    public StringSlice(string s, int start, int length);
    private static StringSlice();
    public int get_Length();
    public char get_Item(int i);
    public bool get_IsEmpty();
    private static void ThrowOutOfRange(string s, int start, int length);
    public int IndexOf(char value);
    public int IndexOf(char value, int startIndex);
    public int IndexOf(char value, int startIndex, int count);
    public int IndexOf(string value);
    public int IndexOf(string value, int startIndex);
    public int IndexOf(string value, int startIndex, int count);
    public int IndexOf(string value, StringComparison comparisonType);
    public int IndexOf(string value, int startIndex, StringComparison comparisonType);
    public int IndexOf(string value, int startIndex, int count, StringComparison comparisonType);
    public int IndexOfAny(Char[] anyOf);
    public int IndexOfAny(Char[] anyOf, int startIndex);
    public int IndexOfAny(Char[] anyOf, int startIndex, int count);
    public int LastIndexOf(char value);
    public int LastIndexOf(char value, int startIndex);
    public int LastIndexOf(char value, int startIndex, int count);
    public int LastIndexOf(string value);
    public int LastIndexOf(string value, int startIndex);
    public int LastIndexOf(string value, int startIndex, int count);
    public int LastIndexOf(string value, StringComparison comparisonType);
    public int LastIndexOf(string value, int startIndex, StringComparison comparisonType);
    public int LastIndexOf(string value, int startIndex, int count, StringComparison comparisonType);
    public int LastIndexOfAny(Char[] anyOf);
    public int LastIndexOfAny(Char[] anyOf, int startIndex);
    public int LastIndexOfAny(Char[] anyOf, int startIndex, int count);
    public StringSlice Substring(int startIndex);
    public StringSlice Substring(int startIndex, int length);
    public bool Contains(string value);
    public IEnumerable`1<StringSlice> Split(Char[] separator);
    public StringSlice[] Split2(Char[] separator);
    public IEnumerable`1<StringSlice> Split(Char[] separator, StringSplitOptions options);
    public StringSlice[] Split2(Char[] separator, StringSplitOptions options);
    public StringSlice TrimStart();
    public StringSlice TrimEnd();
    public StringSlice Trim();
    public bool Equals(string otherString);
    public bool Equals(string otherString, StringComparison comparisonRule);
    public bool Equals(StringSlice otherStringSlice, StringComparison comparisonRule);
    public int CompareTo(string otherString);
    public int CompareTo(string otherString, StringComparison comparisonRule);
    public bool EqualTo(string s);
    public bool EqualTo(string s, IEqualityComparer`1<StringSlice> comparer);
    public virtual string ToString();
    public void ProcessString(ProcessStringDelegate action);
    public T ProcessString(ProcessStringDelegate`1<T> action);
    public TResult ProcessString(TContext context, ProcessStringDelegate`2<TContext, TResult> λ);
    private sealed virtual override bool System.IEquatable<JetBrains.Util.StringSlice>.Equals(StringSlice other);
    public bool Equals(StringSlice other);
    public bool Equals(StringSlice other, IEqualityComparer`1<StringSlice> comparer);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static StringSlice op_Implicit(string s);
    public void AssertNotNull();
    public static bool op_Equality(StringSlice α, StringSlice β);
    public static bool op_Inequality(StringSlice α, StringSlice β);
    internal void StringBuilderAppend(StringBuilder sb, int index, int length);
}
[ExtensionAttribute]
public static class JetBrains.Util.StringSliceEx : object {
    [ObsoleteAttribute("Use the overload with the word Slice in it, otherwise it's easy to accidentally get it rebound to a native overload with Object that works just the same but makes an allocation with ToString().")]
[ExtensionAttribute]
public static StringBuilder Append(StringBuilder thіs, StringSlice text);
    [ObsoleteAttribute("Use the overload with the word Slice in it, otherwise it's easy to accidentally get it rebound to a native overload with Object that works just the same but makes an allocation with ToString().")]
[ExtensionAttribute]
public static StringBuilder Append(StringBuilder thіs, StringSlice text, int index, int length);
    [ObsoleteAttribute("Use the overload with the word Slice in it, otherwise it's easy to accidentally get it rebound to an overload with Object that works just the same but makes an allocation with ToString().")]
[ExtensionAttribute]
public static StringBuilder AppendLine(StringBuilder thіs, StringSlice text);
    [ExtensionAttribute]
public static StringBuilder AppendSlice(StringBuilder thіs, StringSlice text);
    [ExtensionAttribute]
public static StringBuilder AppendSlice(StringBuilder thіs, StringSlice text, int index, int length);
    [ExtensionAttribute]
public static StringBuilder AppendLineSlice(StringBuilder thіs, StringSlice text);
}
public class JetBrains.Util.StringSlicesEnumerable : ValueType {
    private string mySource;
    private char mySeparator;
    private bool mySkipEmptyEntries;
    private Char[] mySeparators;
    public StringSlicesEnumerable(string source, char separator, bool skipEmptyEntries);
    public StringSlicesEnumerable(string source, Char[] separators, bool skipEmptyEntries);
    public int IndexOf(string substringToSeek, StringComparison comparison);
    private sealed virtual override IEnumerator`1<StringSlice> System.Collections.Generic.IEnumerable<JetBrains.Util.StringSlice>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public StringSlicesEnumerator GetEnumerator();
}
[ExtensionAttribute]
public static class JetBrains.Util.StringUtil : object {
    public static char DOT;
    public static char GENERIC_DELIMETER;
    public static char PLUS;
    public static char UNDERLINE;
    public static string SDOT;
    private static int bytesPerUtf16Char;
    private static int hexcharsPerByte;
    [NotNullAttribute]
private static Random ourRandom;
    private static String[] ourPrepositions;
    private static Regex ourRegexMacro;
    public static string HexDigitsformatString;
    [NotNullAttribute]
public static Char[] NEW_LINE_CHARACTERS;
    [NotNullAttribute]
public static String[] NEW_LINE_STRINGS;
    private static bool IsEqualityComparerGetHashCodeCaseInsensitivelyNative_WinNT0602;
    private static bool IsEqualityComparerGetHashCodeCaseInsensitivelyNative_WinNT0600;
    [CompilerGeneratedAttribute]
private static MatchEvaluator CS$<>9__CachedAnonymousMethodDelegate13;
    private static StringUtil();
    public static bool StartsWith(string what, string withWhat, StringComparison comparison);
    public static IEnumerable`1<string> GetLines(string text);
    public static string Combine(string str1, string str2);
    public static string ShortName(string name);
    public static string NextQualification(string partial, string full);
    public static string SplitName(string name, String& qualificationPrefix);
    private static string SplitNameInternal(string name, Char[] splitChars, String& qualificationPrefix);
    public static string SplitCLRName(string name, String& qualificationPrefix);
    public static String[] FullySplitFQName(string fqName);
    public static String[] SplitFQName(string fqName);
    public static string MakeFQName(String[] parts);
    public static string MakeFQName(string namespaceName, string className);
    [ObsoleteAttribute("Use 'System.String.Split' overload with parameter 'options'")]
public static String[] Split(string stringToSplit, string delimChars, bool keepEmpty);
    [ExtensionAttribute]
public static string TrimToSingleLineWithMaxLength(string stringToTrim, int maxLength);
    public static string GetCommon(string qualified1, string qualified2, Int32& foundIndex);
    [ExtensionAttribute]
public static string Decapitalize(string s);
    [ExtensionAttribute]
public static string Capitalize(string s);
    [ExtensionAttribute]
public static string TrimFromEnd(string from, string what);
    [ExtensionAttribute]
public static string TrimFromEnd(string from, string what, StringComparison comparison);
    [ExtensionAttribute]
public static string TrimFromStart(string from, string what);
    [ExtensionAttribute]
public static string TrimFromStart(string from, string what, StringComparison comparison);
    public static string TrimFQFromStart(string from, string what, StringComparison comparison);
    public static string Unquote(string s);
    public static string Escape(string s);
    public static string Unescape(string s);
    public static string MakeTitle(string text);
    public static string CapitalizeWords(string s);
    public static string CutSpaces(string s);
    public static void CutSpaces(string s, StringBuilder sb);
    public static string ExpandTabs(string s, int startOffset, UInt32 tabsize);
    public static int Count(string s, char ch);
    public static int FindNthPos(string s, char ch, int n);
    public static string StringArrayText(String[] array);
    public static string NormalizeWhiteSpace(string s);
    public static string GetPrefix(string text, char delim, TextRange& prefixRange);
    public static string GetSuffix(string text, char delim, TextRange& suffixRange);
    public static bool EqIgnoreCase(string s1, string s2);
    [ItemNotNullAttribute]
public static IEnumerable`1<string> EnumeratePrefixes(string s);
    [NotNullAttribute]
public static string SubstituteMacros(IDictionary`2<string, string> macros, string sample);
    public static string GenerateRandomName(string prefix);
    public static string GenerateRandomName();
    public static string GenerateRandomName(int length);
    public static string GenerateRandomName(int length, Random rand);
    public static string GenerateRandomNameForObject(object instance);
    [ExtensionAttribute]
public static StringBuilder AppendDelimited(StringBuilder builder, IEnumerable`1<T> enumerable, Func`2<T, string> presenter, string delimiter);
    [ExtensionAttribute]
public static StringBuilder AppendDelimited(StringBuilder builder, IEnumerable`1<string> enumerable, string delimiter);
    [ExtensionAttribute]
public static string Replace(string s, Func`2<char, char> replacer);
    [ExtensionAttribute]
[ContractAnnotationAttribute("null=>true")]
public static bool IsEmpty(string s);
    [ExtensionAttribute]
[ContractAnnotationAttribute("null=>false")]
public static bool IsNotEmpty(string s);
    [ExtensionAttribute]
public static bool IsEmpty(StringBuilder builder);
    [ExtensionAttribute]
public static string ToThreadString(Thread thread);
    [StringFormatMethodAttribute("format")]
[NotNullAttribute]
public static string FormatQuoted(string format, Object[] args);
    [ExtensionAttribute]
[NotNullAttribute]
public static string QuoteIfNeeded(string s);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static string RemoveQuotes(string s);
    public static string EncodeStringForSgml(string s);
    [CanBeNullAttribute]
public static string ToStringIfNonDefault(object o);
    [NotNullAttribute]
public static string DropMiddleIfLong(string text, int nMaxLen);
    [NotNullAttribute]
[ExtensionAttribute]
public static string Join(IEnumerable`1<string> strings, string separator);
    [NotNullAttribute]
[ExtensionAttribute]
public static string ToHexString(IntPtr intptr);
    [NotNullAttribute]
public static string ToHexString(Void* intptr);
    [NotNullAttribute]
[ExtensionAttribute]
public static string ToHexString(UIntPtr uintptr);
    [NotNullAttribute]
public static string ToHexString(Byte[] buf);
    [NotNullAttribute]
public static string ToUtf16HexString(string s);
    [NotNullAttribute]
public static string FromUtf16HexString(string hex);
    [ObsoleteAttribute("This method does not support culture, so use an overload without it.")]
[NotNullAttribute]
public static string ToStringWithLeading(int value, int maxvalue, CultureInfo culture);
    [NotNullAttribute]
public static string ToStringWithLeading(int value, int maxvalue);
    [ExtensionAttribute]
public static StringBuilder AppendLine(StringBuilder sb, string format, Object[] args);
    [StringFormatMethodAttribute("format")]
[ExtensionAttribute]
public static StringBuilder AppendLine(StringBuilder sb, string format, object argA);
    [ExtensionAttribute]
[StringFormatMethodAttribute("format")]
public static StringBuilder AppendLine(StringBuilder sb, string format, object argA, object argB);
    [StringFormatMethodAttribute("format")]
[ExtensionAttribute]
public static StringBuilder AppendLine(StringBuilder sb, string format, object argA, object argB, object argC);
    [ExtensionAttribute]
public static string FullReplace(string input, string oldValue, string newValue);
    [ExtensionAttribute]
public static string FullReplace(string input, string oldValue, string newValue, StringComparison stringComparison);
    [ExtensionAttribute]
[NotNullAttribute]
public static String[] SplitByWords(string text);
    [NotNullAttribute]
[ExtensionAttribute]
public static StringBuilder Prepend(StringBuilder builder, char char);
    [ExtensionAttribute]
[NotNullAttribute]
public static StringBuilder Prepend(StringBuilder builder, string text);
    [NotNullAttribute]
[ExtensionAttribute]
public static string Times(int n, string phrase);
    [ExtensionAttribute]
public static bool IsWhitespace(string s);
    [ExtensionAttribute]
[ContractAnnotationAttribute("null=>true")]
public static bool IsNullOrWhitespace(string s);
    [ExtensionAttribute]
public static char Last(string s);
    [ExtensionAttribute]
public static bool IsNewLine(string s);
    [ExtensionAttribute]
public static bool ContainsNewLine(string s);
    [ExtensionAttribute]
public static bool EndsWithNewLine(string s);
    [ExtensionAttribute]
public static bool StartsWithNewLine(string s);
    [ExtensionAttribute]
[NotNullAttribute]
public static String[] SplitByNewLine(string s, int count, StringSplitOptions options);
    [ExtensionAttribute]
[NotNullAttribute]
public static string ReplaceNewLines(string s, string replaceWith);
    [ExtensionAttribute]
public static Char[] ToLowerCharArray(string s);
    [ExtensionAttribute]
public static string Multiply(string source, int multiplier);
    [NotNullAttribute]
public static string MakeUpperCamelCaseName(string name);
    [ExtensionAttribute]
public static int GetPlatformIndependentHashCode(string s, bool caseSensitive);
    [ExtensionAttribute]
public static int GetPlatformIndependentHashCode(StringBuilder sb, bool caseSensitive);
    public static string UrlEncode(string text);
    [ObsoleteAttribute("Use QuoteSet/QuoteList ext methods.")]
[ExtensionAttribute]
[NotNullAttribute]
public static string ObjectsToString(IEnumerable`1<T> strings, string separator);
    [ObsoleteAttribute("Slow for massive use. Consider using XmlUtil::EscapeXmlString.")]
[ExtensionAttribute]
public static string HtmlEncode(string text);
    public static string StrFormatByteSize(long nSize);
    public static UInt32 StringCchLength(Char* psz, UInt32 cchMax);
    [PureAttribute]
public static int EqualityComparerGetHashCodeCaseInsensitively(Char* pch, UInt32 cch);
    [PureAttribute]
public static int EqualityComparerGetHashCodeCaseInsensitively_WinNT0602(Char* pch, UInt32 cch);
    [PureAttribute]
public static int EqualityComparerGetHashCodeCaseInsensitively_WinNT0600(Char* pch, UInt32 cch);
    [PureAttribute]
public static int EqualityComparerGetHashCodeCaseInsensitively_Msil(Char* pch, UInt32 cch);
    [CompilerGeneratedAttribute]
private static string <MakeUpperCamelCaseName>b__12(Match match);
}
[ExtensionAttribute]
public static class JetBrains.Util.SwitchUtil : object {
    [ExtensionAttribute]
public static object Switch(object o, Action`1<T> action);
    [ExtensionAttribute]
public static object Switch(object o, Action action);
    [ExtensionAttribute]
public static object Switch(object o, Func`2<T, TRes> action);
}
public class JetBrains.Util.Tests.ThrowsAccumulatedLoggerExceptions : object {
    private Func`1<CompoundException> myFCreateExceptionContainer;
    private LifetimeDefinition myLifetimeDefinition;
    private SpinWaitLock myLock;
    private CompoundException myLoggedExceptions;
    private EventHandler`1<ExceptionEventArgs> ExceptionLogged;
    [CompilerGeneratedAttribute]
private static EventHandler`1<ExceptionEventArgs> CS$<>9__CachedAnonymousMethodDelegate2;
    [CompilerGeneratedAttribute]
private static Func`1<CompoundException> CS$<>9__CachedAnonymousMethodDelegate3;
    [NotNullAttribute]
public CompoundException LoggedExceptions { get; }
    private ILayout JetBrains.Util.ILogEventListener.Layout { get; private set; }
    protected ThrowsAccumulatedLoggerExceptions(Func`1<CompoundException> FCreateExceptionContainer);
    public CompoundException get_LoggedExceptions();
    public void Dispose(bool captureFinallyExceptions);
    [NotNullAttribute]
public CompoundException RecycleLoggedExceptions();
    public void ThrowLoggedExceptions();
    public void add_ExceptionLogged(EventHandler`1<ExceptionEventArgs> value);
    public void remove_ExceptionLogged(EventHandler`1<ExceptionEventArgs> value);
    protected virtual void ThrowLoggedExceptions_ThrowSpecial(CompoundException compound);
    private void OnException(Exception ex);
    public sealed virtual void Dispose();
    private sealed virtual override void JetBrains.Util.ILogEventListener.OnLogEvent(LogEvent logEvent);
    private sealed virtual override ILayout JetBrains.Util.ILogEventListener.get_Layout();
    private sealed virtual override void JetBrains.Util.ILogEventListener.set_Layout(ILayout value);
    [CompilerGeneratedAttribute]
private static void <.ctor>b__0(object param0, ExceptionEventArgs param1);
    [CompilerGeneratedAttribute]
private static CompoundException <.ctor>b__1();
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Util.Text.AggregatedBuffer : object {
    private IBuffer[] myBuffers;
    public int Length { get; }
    public char Item { get; }
    public AggregatedBuffer(IBuffer b1, IBuffer b2, IBuffer b3);
    public AggregatedBuffer(IBuffer[] buffers, bool simplify);
    public sealed virtual int get_Length();
    public sealed virtual string GetText();
    public sealed virtual string GetText(TextRange range);
    public sealed virtual void AppendTextTo(StringBuilder builder, TextRange range);
    public sealed virtual char get_Item(int index);
    public sealed virtual void CopyTo(int sourceIndex, Char[] destinationArray, int destinationIndex, int length);
    public IBuffer Project(TextRange range);
}
[ExtensionAttribute]
public static class JetBrains.Util.Text.BufferRangeEx : object {
    public static bool CompareBufferText(BufferRange b1, BufferRange b2, bool caseSensitive);
    public static bool CompareBufferText(BufferRange b1, string b2, bool caseSensitive);
    [ExtensionAttribute]
public static bool StringEquals(BufferRange range, string str, bool caseSensitive);
    [ExtensionAttribute]
public static bool StringEquals(BufferRange range, BufferRange other, bool caseSensitive);
}
public class JetBrains.Util.Text.EncodingUtil : object {
    public static Encoding DefaultEncoding;
    public static Encoding CP1251;
    private static EncodingUtil();
}
public enum JetBrains.Util.Text.LineEnding : Enum {
    public UInt32 value__;
    public static LineEnding LF;
    public static LineEnding CR;
    public static LineEnding CRLF;
    public static LineEnding LS;
    public static LineEnding PS;
    public static LineEnding VT;
    public static LineEnding FF;
    public static LineEnding NEL;
    public static LineEnding Eof;
}
[ExtensionAttribute]
public static class JetBrains.Util.Text.LineEndings : object {
    [ThreadStaticAttribute]
private static List`1<LineSegment> mySmallBuffer;
    public static int AverageLineLength;
    [CompilerGeneratedAttribute]
private static Func`2<Pair`2<LineEnding, UInt32>, UInt32> CS$<>9__CachedAnonymousMethodDelegate1;
    private static LineEndings();
    public static LineEnding ParseLineEnding(string text, OnError onerror);
    public static LineEnding ParseLineEnding(IBuffer buffer, UInt32 offset, UInt32 length, OnError onerror);
    [ExtensionAttribute]
public static string ToLineEndingString(LineEnding lineending);
    [NotNullAttribute]
public static List`1<LineSegment> DetectLineEndings(TextRange rangeWholeLines, IBuffer buffer);
    public static LineEnding GetFirstLineEnding(IBuffer buffer);
    [ExtensionAttribute]
public static LineEnding GetMostPopularLineEnding(IBuffer buffer);
    public static LineEnding GetMostPopularLineEnding(List`1<LineSegment> lines, IBuffer buffer);
    public static DetectLineEndingsContext DetectLineEndingsCore(TextRange range, IBuffer buffer, Flags flags, Nullable`1<DetectLineEndingsContext> mctx);
    [ExtensionAttribute]
[NotNullAttribute]
public static string UnifyLineSeparators(IBuffer buffer, LineEnding newLineEnding);
    [CompilerGeneratedAttribute]
private static UInt32 <GetMostPopularLineEnding>b__0(Pair`2<LineEnding, UInt32> pair);
}
[ExtensionAttribute]
public static class JetBrains.Util.Text.LineEndingUtil : object {
    private static StringBuffer LF_BUFFER;
    private static StringBuffer CR_BUFFER;
    private static StringBuffer CR_LF_BUFFER;
    private static StringBuffer LS_BUFFER;
    private static StringBuffer PS_BUFFER;
    private static StringBuffer VT_BUFFER;
    private static StringBuffer FF_BUFFER;
    private static StringBuffer NEL_BUFFER;
    private static StringBuffer UNKNOWN_BUFFER;
    private static LineEndingUtil();
    [ExtensionAttribute]
public static string GetName(LineEnding nl);
    [ExtensionAttribute]
public static string GetPresentation(LineEnding nl);
    [ExtensionAttribute]
public static StringBuffer GetPresentationAsBuffer(LineEnding nl);
    public static LineEnding DetectLineEnding(IBuffer text, int offset);
    public static int DetectLineStartIndex(IBuffer text, int lineNumber);
    public static bool CanStartComplexLineEnding(char c);
}
public class JetBrains.Util.Text.PooledThinArrayBuffer : ThinArrayBuffer {
    public PooledThinArrayBuffer(ICharBufferAllocator pool, int capacity);
}
[ExtensionAttribute]
public static class JetBrains.Util.Text.TextWriterEx : object {
    [ExtensionAttribute]
public static void WriteLinesSorted(TextWriter writer, Action`1<SortedLinesTextWriter> writeAction);
    [ExtensionAttribute]
public static void WriteLinesSorted(TextWriter writer, IComparer`1<string> comparer, Action`1<SortedLinesTextWriter> writeAction);
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Util.Text.ThinArrayBuffer : object {
    private static int DEFAULT_POOLED_CAPACITY;
    private static int DEFAULT_INITIAL_CAPACITY;
    private ICharBufferAllocator myAllocator;
    private Char[] myBuffer;
    private int myLength;
    public int Length { get; }
    public char Item { get; }
    public ThinArrayBuffer(int capacity);
    protected ThinArrayBuffer(ICharBufferAllocator allocator, int capacity, bool hollow);
    protected ThinArrayBuffer(ICharBufferAllocator allocator, Char[] buf);
    public sealed virtual int get_Length();
    public sealed virtual string GetText(TextRange range);
    public sealed virtual void AppendTextTo(StringBuilder builder, TextRange range);
    public sealed virtual string GetText();
    public sealed virtual void Insert(int offset, string text);
    public void Append(string s);
    public void Append(string s, int offset, int length);
    public void Append(IBuffer buf, int offset, int length);
    public sealed virtual void Remove(int offset, int length);
    public sealed virtual void Replace(int offset, int length, string newText);
    public sealed virtual void Replace(int offset, int length, BufferRange newText);
    public sealed virtual char get_Item(int index);
    public sealed virtual void CopyTo(int sourceIndex, Char[] destinationArray, int destinationIndex, int length);
    public void ClearBuffer();
    public void InitBuffer();
    private void EnsureCharArray(int capacity);
    [ConditionalAttribute("JET_MODE_ASSERT")]
private void AssertOffsetAndLength(int offset, int length);
    [ConditionalAttribute("JET_MODE_ASSERT")]
private void AssertOffsetAndLength(IBuffer buf, int offset, int length);
    [ConditionalAttribute("JET_MODE_ASSERT")]
private void AssertOffsetAndLength(string s, int offset, int length);
    private void ThrowRangeException(int offset, int length);
    private void ThrowLengthException(int offset, int length);
    [CompilerGeneratedAttribute]
private object <ThrowRangeException>b__2();
    [CompilerGeneratedAttribute]
private object <ThrowLengthException>b__7();
}
[DebuggerDisplayAttribute("{DebugView,nq}")]
public class JetBrains.Util.TextRange : ValueType {
    [DebuggerBrowsableAttribute("0")]
private int myStartOffset;
    [DebuggerBrowsableAttribute("0")]
private int myEndOffset;
    [DebuggerBrowsableAttribute("0")]
public static TextRange InvalidRange;
    public int StartOffset { get; }
    public int EndOffset { get; }
    public int Length { get; }
    public bool IsEmpty { get; }
    [NotNullAttribute]
[DebuggerBrowsableAttribute("0")]
private string DebugView { get; }
    public bool IsValid { get; }
    public bool IsNormalized { get; }
    [DebuggerStepThroughAttribute]
public TextRange(int startOffset, int endOffset);
    [DebuggerStepThroughAttribute]
public TextRange(int offset);
    private static TextRange();
    public int get_StartOffset();
    public int get_EndOffset();
    public int get_Length();
    public bool get_IsEmpty();
    private string get_DebugView();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(TextRange other);
    public virtual int GetHashCode();
    public virtual string ToString();
    [PureAttribute]
[NotNullAttribute]
public string ToString(IFormatProvider formatProvider);
    [PureAttribute]
[NotNullAttribute]
public string ToInvariantString();
    public static TextRange Parse(string s);
    [PureAttribute]
public static TextRange FromLength(int offset, int length);
    [PureAttribute]
public static TextRange FromLength(int length);
    [PureAttribute]
public static TextRange FromUnorderedOffsets(int one, int onemore);
    [PureAttribute]
public int GetMinOffset();
    [PureAttribute]
public int GetMaxOffset();
    [PureAttribute]
public bool ContainedIn(TextRange textRange);
    [PureAttribute]
public bool StrictContainedIn(TextRange textRange);
    [PureAttribute]
public bool Contains(TextRange textRange);
    [PureAttribute]
public bool Contains(int offset);
    [PureAttribute]
public bool ContainsCharIndex(int charindex);
    [PureAttribute]
public TextRange SetStartTo(int offset);
    [PureAttribute]
public TextRange SetEndTo(int offset);
    [PureAttribute]
public TextRange Left(int length);
    [PureAttribute]
public TextRange Right(int length);
    [PureAttribute]
public TextRange TrimLeft(int length);
    [PureAttribute]
public TextRange TrimRight(int length);
    [DebuggerStepThroughAttribute]
[PureAttribute]
public TextRange ExtendLeft(int length);
    [PureAttribute]
[DebuggerStepThroughAttribute]
public TextRange ExtendRight(int length);
    [DebuggerStepThroughAttribute]
[PureAttribute]
public TextRange Shift(int delta);
    [PureAttribute]
public TextRange Join(TextRange textRange);
    [PureAttribute]
public TextRange JoinLeft(TextRange textRange);
    [PureAttribute]
public TextRange JoinRight(TextRange textRange);
    [PureAttribute]
public bool Intersects(TextRange textRange);
    [PureAttribute]
public bool StrictIntersects(TextRange textRange);
    [PureAttribute]
public TextRange Intersect(TextRange textRange);
    public bool get_IsValid();
    [ConditionalAttribute("JET_MODE_ASSERT")]
public void AssertValid();
    [ConditionalAttribute("JET_MODE_ASSERT")]
public void AssertNormalized();
    [ConditionalAttribute("JET_MODE_ASSERT")]
public void AssertContainedIn(TextRange rangeContainer);
    public bool get_IsNormalized();
    [PureAttribute]
public TextRange Normalized();
    public static bool op_Equality(TextRange range1, TextRange range2);
    public static bool op_Inequality(TextRange range1, TextRange range2);
    [PureAttribute]
public int DistanceTo(int offset);
    [PureAttribute]
public bool IsLeftTo(int offset);
    [PureAttribute]
public TextRange UpdateRange(int changeStartOffset, int oldLength, int newLength, bool greedyToLeft, bool greedyToRight);
}
public class JetBrains.Util.TextRangeComparer : object {
    [NotNullAttribute]
public static IComparer`1<TextRange> Default;
    private static TextRangeComparer();
    public sealed virtual int Compare(TextRange x, TextRange y);
}
[ExtensionAttribute]
public static class JetBrains.Util.TextRangeEx : object {
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static string Substring(string str, TextRange range);
    [NotNullAttribute]
[ExtensionAttribute]
[PureAttribute]
public static string ToString(StringBuilder builder, TextRange range);
    [PureAttribute]
[ExtensionAttribute]
public static bool RangeStartsWith(string str, TextRange range, string value);
    [PureAttribute]
[ExtensionAttribute]
public static bool RangeEndsWith(string str, TextRange range, string value);
    [PureAttribute]
[ExtensionAttribute]
public static bool RangeEquals(string str, TextRange range, string value);
    [PureAttribute]
[ExtensionAttribute]
public static bool RangeStartsWith(string str, TextRange range, string value, StringComparison comparison);
    [ExtensionAttribute]
[PureAttribute]
public static bool RangeEndsWith(string str, TextRange range, string value, StringComparison comparison);
    [ExtensionAttribute]
[PureAttribute]
public static bool RangeEquals(string str, TextRange range, string value, StringComparison comparison);
    [NotNullAttribute]
[ExtensionAttribute]
public static IList`1<TextRange> Merge(IList`1<TextRange> ranges);
}
public class JetBrains.Util.Threading.AsyncPipeReader : object {
    private static bool OptionDeferReleaseNativeResources;
    public static UInt32 ReadBufferSize;
    private ILogger Logger;
    [CanBeNullAttribute]
private Action myFUserOnEof;
    [NotNullAttribute]
private Action`1<ByteBuffer> myFUserOnRead;
    private IntPtr myHandleWaitForConnect;
    private LockObject myIsBusy;
    private int myIsInCallback;
    private int myIsPendingConnectPipe;
    private int myIsPendingRead;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) myIsReadChainStopped;
    private Lifetime myLifetime;
    private OVERLAPPED* myOverlapped;
    private Void* myPipeReadHandle;
    private Void* myReadBuffer;
    private Void* myTpIo;
    public bool IsRunning { get; }
    public AsyncPipeReader(Lifetime lifetime, Void* hPipeRead, Action`1<ByteBuffer> FOnRead, Action FUserOnEof);
    private static AsyncPipeReader();
    public bool get_IsRunning();
    private void IoCompletionCallback(Void* Instance, Void* Context, Void* Overlapped, UInt32 IoResult, UIntPtr NumberOfBytesTransferred, Void* Io);
    private void OnNoMoreRead();
    private void OnRead(ByteBuffer buffer);
    private void ReadLoop();
    private bool ReadLoopStep();
    private void WaitCallbackConnectNamedPipe(Void* lpparameter, byte timerorwaitfired);
    [CompilerGeneratedAttribute]
private void <.ctor>b__4();
    [CompilerGeneratedAttribute]
private void <.ctor>b__5();
    [CompilerGeneratedAttribute]
private void <.ctor>b__6();
    [CompilerGeneratedAttribute]
private void <.ctor>b__7();
    [CompilerGeneratedAttribute]
private void <ReadLoopStep>b__13();
}
public class JetBrains.Util.Threading.AsyncPipeTextLineReader : object {
    private static ILogger Logger;
    private static AsyncPipeTextLineReader();
    public static void ReadLinesWithDeferredCallback(Lifetime lifetime, Void* hPipeRead, Encoding encoding, Action`1<string> FOnReadLineDeferred);
    public static void ReadLinesWithDirectCallback(Lifetime lifetime, Void* hPipeRead, Encoding encoding, ReadLineDelegate FOnReadLine);
}
public interface JetBrains.Util.Threading.IReaderWriterLock {
    public bool IsReadAccessAllowed { get; }
    public bool IsReadLockHeld { get; }
    public bool IsWriteAccessAllowed { get; }
    public bool IsWriteLockHeld { get; }
    public bool IsWriteLockRequested { get; }
    public abstract virtual bool get_IsReadAccessAllowed();
    public abstract virtual bool get_IsReadLockHeld();
    public abstract virtual bool get_IsWriteAccessAllowed();
    public abstract virtual bool get_IsWriteLockHeld();
    public abstract virtual bool get_IsWriteLockRequested();
    public abstract virtual void AcquireReadLock();
    public abstract virtual void AcquireWriteLock();
    public abstract virtual void ReleaseReadLock();
    public abstract virtual void ReleaseWriteLock();
    public abstract virtual bool TryAcquireReadLock(int timeout);
    public abstract virtual bool TryAcquireWriteLock(int timeout);
}
[ExtensionAttribute]
public static class JetBrains.Util.Threading.JetTaskEx : object {
    public static DateTime FakeDateTime;
    private static Task`1<Missing> myCompletedTask;
    [CompilerGeneratedAttribute]
private static Action CS$<>9__CachedAnonymousMethodDelegate3;
    [NotNullAttribute]
public static Task`1<Missing> CompletedTask { get; }
    private static JetTaskEx();
    public static Task`1<Missing> get_CompletedTask();
    [NotNullAttribute]
public static Task`1<TResult> FromResult(TResult result);
    [ExtensionAttribute]
public static bool IsLongRunning(Task task);
    [PublicAPIAttribute]
[ExtensionAttribute]
public static bool IsProcessCancelled(Task task);
    [PublicAPIAttribute]
public static void ParseAggregateException(Exception& toUpdate, AggregateException possibleAggregateException);
    [PublicAPIAttribute]
[ExtensionAttribute]
[NotNullAttribute]
public static TTask Started(TTask task, TaskScheduler scheduler, bool sync);
    [PublicAPIAttribute]
[NotNullAttribute]
[ExtensionAttribute]
public static WaitHandle WaitHandle(Task task);
    [NotNullAttribute]
public static Task Delay(TimeSpan delay, Nullable`1<CancellationToken> cancellationMaybe);
    [NotNullAttribute]
[ExtensionAttribute]
public static Task`1<TResult[]> ContinueWhenAll(IEnumerable`1<Task`1<TResult>> tasks);
    [NotNullAttribute]
[ExtensionAttribute]
public static Task`1<TResult[]> ContinueWhenAll(IEnumerable`1<Task`1<TResult[]>> tasks);
    [DebuggerStepThroughAttribute]
[AsyncStateMachineAttribute("JetBrains.Util.Threading.JetTaskEx/<While>d__b")]
public static Task`1<bool> While(Func`1<bool> condition, Nullable`1<TimeSpan> timeout, OnWaitTimeout ontimeout);
    [AsyncStateMachineAttribute("JetBrains.Util.Threading.JetTaskEx/<While>d__10")]
[DebuggerStepThroughAttribute]
public static Task`1<bool> While(Func`1<Task`1<bool>> condition, Nullable`1<TimeSpan> timeout, OnWaitTimeout ontimeout);
    [AsyncStateMachineAttribute("JetBrains.Util.Threading.JetTaskEx/<While>d__20")]
[DebuggerStepThroughAttribute]
public static Task`1<bool> While(IProperty`1<bool> condition, Nullable`1<TimeSpan> timeout, OnWaitTimeout ontimeout);
    [CompilerGeneratedAttribute]
private static void <Delay>b__0();
    [CompilerGeneratedAttribute]
private static TResult[] <ContinueWhenAll>b__7(Task`1[] completed);
    [CompilerGeneratedAttribute]
private static TResult <ContinueWhenAll>b__8(Task`1<TResult> t);
    [CompilerGeneratedAttribute]
private static TResult[] <ContinueWhenAll>b__9(Task`1[] completed);
    [CompilerGeneratedAttribute]
private static IEnumerable`1<TResult> <ContinueWhenAll>b__a(Task`1<TResult[]> t);
}
public class JetBrains.Util.Threading.Mmf.SharedMemoryMessageBase : object {
    protected EventWaitHandle _evtRead;
    protected EventWaitHandle _evtWritten;
    protected Mutex _mutexInterlock;
    protected RawCircularBufferHeader* _pBufferHeader;
    protected TimeSpan _timeoutForWaits;
    protected SynchronizedLifetime myLifetimeSync;
    public UInt32 MaxMessageSize;
    public string UniqueName;
    private UInt32 BufferSize { get; }
    public SharedMemoryMessageBase(Lifetime lifetimeUnsync, string sUniqueName, UInt32 nMaxMessageSize, bool isWriter);
    protected static string DiagDecodeMessage(Byte[] message);
    private UInt32 get_BufferSize();
    [CompilerGeneratedAttribute]
private object <.ctor>b__2();
    [CompilerGeneratedAttribute]
private object <.ctor>b__3();
}
public class JetBrains.Util.Threading.Mmf.SharedMemoryMessageReader : SharedMemoryMessageBase {
    private Action`1<ByteBuffer> myFRead;
    private static ILogger Logger;
    public SharedMemoryMessageReader(Lifetime lifetimeUnsync, string sUniqueName, UInt32 nMaxMessageSize, Action`1<ByteBuffer> FRead);
    private static SharedMemoryMessageReader();
    private void ReadFromRawBuffer();
    private bool ReadFromRawBuffer_Single();
    [CompilerGeneratedAttribute]
private void <.ctor>b__0(object param0, bool param1);
    [CompilerGeneratedAttribute]
private bool <ReadFromRawBuffer_Single>b__5();
}
public class JetBrains.Util.Threading.Mmf.SharedMemoryMessageReader`1 : SharedMemoryMessageReader {
    public SharedMemoryMessageReader`1(Lifetime lifetime, string sUniqueName, UInt32 nMaxMessageSize, Func`2<ByteBuffer, TMessage> FDeserializer, Action`1<TMessage> FRead);
    public SharedMemoryMessageReader`1(Lifetime lifetime, string sUniqueName, UInt32 nMaxMessageSize, Action`1<TMessage> FRead);
    private static TMessage BinaryFormatterDeserializer(ByteBuffer buffer);
}
public class JetBrains.Util.Threading.Mmf.SharedMemoryMessageWriter : SharedMemoryMessageBase {
    private Queue`1<Byte[]> myQueueUnsent;
    private static ILogger Logger;
    public SharedMemoryMessageWriter(Lifetime lifetimeUnsync, string sUniqueName, UInt32 nMaxMessageSize);
    private static SharedMemoryMessageWriter();
    public void SendMessage(Byte[] data);
    private void EnsureSent();
    private void WriteToRawBuffer(Byte[] data);
    private bool WriteToRawBuffer_Single(Byte[] data);
    [CompilerGeneratedAttribute]
private void <.ctor>b__0(object param0, bool param1);
    [CompilerGeneratedAttribute]
private void <.ctor>b__1();
}
public class JetBrains.Util.Threading.Mmf.SharedMemoryMessageWriter`1 : SharedMemoryMessageWriter {
    private Func`2<TMessage, Byte[]> myFSerializer;
    [CompilerGeneratedAttribute]
private static Func`2<TMessage, Byte[]> CS$<>9__CachedAnonymousMethodDelegatea;
    public SharedMemoryMessageWriter`1(Lifetime lifetimeUnsync, string sUniqueName, UInt32 nMaxMessageSize, Func`2<TMessage, Byte[]> FSerializer);
    public SharedMemoryMessageWriter`1(Lifetime lifetimeUnsync, string sUniqueName, UInt32 nMaxMessageSize);
    public void SendMessage(TMessage message);
    [CompilerGeneratedAttribute]
private static Byte[] <.ctor>b__9(TMessage message);
}
public class JetBrains.Util.Threading.SynchronizedLifetime : object {
    [CanBeNullAttribute]
private JetDispatcher myDispatcher;
    private Lifetime myLifeSync;
    private ReaderWriterLockSlim myLockSync;
    public bool IsTerminated { get; }
    [NotNullAttribute]
public Lifetime Lifetime { get; }
    public SynchronizedLifetime(Lifetime lifetimeUnsync, TerminationThreadAffinity termaffinity);
    public bool get_IsTerminated();
    public Lifetime get_Lifetime();
    [NotNullAttribute]
public static Lifetime op_Implicit(SynchronizedLifetime sync);
    public bool ExecuteIfNotTerminated(Action λ);
    public TResult ExecuteIfNotTerminated(Func`1<TResult> λ);
    public void ExecuteSynchronizedWithTermination(Action F);
}
public enum JetBrains.Util.Threading.Tasks.TaskPriority : Enum {
    public int value__;
    public static TaskPriority Low;
    public static TaskPriority BelowNormal;
    public static TaskPriority Normal;
    public static TaskPriority AboveNormal;
    public static TaskPriority High;
    public static TaskPriority Realtime;
}
public class JetBrains.Util.Threading.Tasks.TaskSemaphore : object {
    private UInt32 myFreeCount;
    private LockObject myLockObject;
    private Queue`1<TaskCompletionSource`1<Missing>> myWaits;
    public UInt32 MaximumCount;
    public TaskSemaphore(UInt32 maxcount);
    [DebuggerStepThroughAttribute]
[AsyncStateMachineAttribute("JetBrains.Util.Threading.Tasks.TaskSemaphore/<ExecuteUnderSemaphoreAsync>d__0`1")]
public Task`1<T> ExecuteUnderSemaphoreAsync(Func`1<Task`1<T>> tasker);
    [NotNullAttribute]
public Task`1<IDisposable> UsingSemaphoreAsync();
    private void ReleaseSemaphore();
    private Task`1<Missing> WaitForSemaphoreAsync();
    [CompilerGeneratedAttribute]
private IDisposable <UsingSemaphoreAsync>b__4(Task`1<Missing> o);
}
[AttributeUsageAttribute("460")]
public class JetBrains.Util.ThreadSafeAttribute : Attribute {
}
[AttributeUsageAttribute("460")]
public class JetBrains.Util.ThreadUnsafeAttribute : Attribute {
}
public class JetBrains.Util.ThrowWhatYouCanLogger : LoggerBase {
    private ILogger myLoggerForWhatCannotBeThrown;
    public ThrowWhatYouCanLogger(ILogger loggerForWhatCannotBeThrown);
    public virtual void Log(LogEvent logEvent);
    public virtual bool IsEnabled(LoggingLevel level);
    public sealed virtual void LogOrThrowException(Exception ex, ExceptionOrigin origin);
}
public static class JetBrains.Util.TimerUtil : object {
    public static ITimer CreateTimer(int intervalMs);
    public static ITimer CreateTimer();
    public static ITimer CreateTimer(Lifetime lifetime, TimeSpan interval, Action onTick);
}
public class JetBrains.Util.TimeThrottler : ValueType {
    private int myIntervalMillis;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) myLastCutoff;
    public TimeThrottler(int intervalMillis);
    public void Reset();
    public bool Cutoff();
}
public static class JetBrains.Util.TypeOf : object {
    public static Type Object;
    public static Type String;
    public static Type Int16;
    public static Type Int32;
    public static Type Int64;
    public static Type UInt16;
    public static Type UInt32;
    public static Type UInt64;
    public static Type Boolean;
    public static Type Double;
    public static Type Decimal;
    public static Type Byte;
    public static Type Missing;
    public static Type Type;
    public static Type Void;
    private static TypeOf();
}
[FlagsAttribute]
public enum JetBrains.Util.UnixFileModes : Enum {
    public UInt32 value__;
    public static UnixFileModes S_ISUID;
    public static UnixFileModes S_ISGID;
    public static UnixFileModes S_ISVTX;
    public static UnixFileModes S_IRUSR;
    public static UnixFileModes S_IWUSR;
    public static UnixFileModes S_IXUSR;
    public static UnixFileModes S_IRGRP;
    public static UnixFileModes S_IWGRP;
    public static UnixFileModes S_IXGRP;
    public static UnixFileModes S_IROTH;
    public static UnixFileModes S_IWOTH;
    public static UnixFileModes S_IXOTH;
    public static UnixFileModes S_IRWXG;
    public static UnixFileModes S_IRWXU;
    public static UnixFileModes S_IRWXO;
    public static UnixFileModes ACCESSPERMS;
    public static UnixFileModes ALLPERMS;
    public static UnixFileModes DEFFILEMODE;
    public static UnixFileModes S_IFMT;
    public static UnixFileModes S_IFDIR;
    public static UnixFileModes S_IFCHR;
    public static UnixFileModes S_IFBLK;
    public static UnixFileModes S_IFREG;
    public static UnixFileModes S_IFIFO;
    public static UnixFileModes S_IFLNK;
    public static UnixFileModes S_IFSOCK;
}
public class JetBrains.Util.UnixFileSystemInteraction : FileSystemInteraction {
    private static ILogger ourLogger;
    public static UnixFileSystemInteraction Instance;
    [ThreadStaticAttribute]
[CanBeNullAttribute]
private static IFsWriteHandler ourWriteHandler;
    private static Lazy`1<FileSystemPath> ourTempDir;
    [CompilerGeneratedAttribute]
private static Func`2<string, string> CS$<>9__CachedAnonymousMethodDelegate6;
    [NotNullAttribute]
private static IFsWriteHandler WriteHandler { get; }
    private static UnixFileSystemInteraction();
    private static IFsWriteHandler get_WriteHandler();
    public virtual void OverrideWriteHandler(Lifetime lifetime, Func`2<IFsWriteHandler, IFsWriteHandler> newHandlerFactory);
    public virtual IEnumerable`1<FileSystemPath> GetDirectoryEntries(FileSystemPath thіs, string mask, Nullable`1<bool> files, FileSystemPathInternStrategy internStrategy);
    public virtual void GetDirectoryEntries(FileSystemPath thіs, RelativePath subdir, string mask, PathSearchFlags flags, ICollection`1& output);
    public virtual void DeleteFile(FileSystemPath thіs);
    public virtual void DeleteFile(FileSystemPath thіs, Boolean& isDirectory, int nAttempts);
    public virtual void DeleteDirectoryNonRecursive(FileSystemPath thіs, int nAttempts, Exception& ex);
    public virtual FileSystemPath CreateDirectory(FileSystemPath thіs);
    public virtual bool TryCreateNewDirectoryAtomic(FileSystemPath thіs);
    public virtual void Move(FileSystemPath thіs, FileSystemPath dst);
    public virtual void MoveFile(FileSystemPath thіs, FileSystemPath dst, bool overwrite);
    public virtual void CopyFile(FileSystemPath thіs, FileSystemPath dst, bool overwrite);
    public virtual void SetAttributes(FileSystemPath thіs, FileAttributes fileAttributes);
    public virtual void SetFileModificationTimeUtc(FileSystemPath thіs, DateTime t);
    public virtual Existence GetExists(FileSystemPath thіs);
    public virtual FileSystemEntryInfo GetInfo(FileSystemPath thіs);
    public virtual DateTime GetFileModificationTimeUtc(FileSystemPath thіs);
    public virtual DateTime GetFileCreationTimeUtc(FileSystemPath thіs);
    public virtual DateTime GetFileLastAccessedTimeUtc(FileSystemPath thіs);
    public virtual string GetFileAccessPath(FileSystemPath thіs);
    public virtual bool IsLocked(FileSystemPath thіs);
    public virtual long GetFileLength(FileSystemPath thіs);
    public virtual FileAttributes GetAttributes(FileSystemPath thіs);
    public virtual FileAttributes TryGetAttributes(FileSystemPath thіs);
    public virtual FileStream OpenStream(FileSystemPath thіs, FileMode fileMode, FileAccess fileAccess, FileShare fileShare);
    public virtual SafeFileHandle OpenFileHandle(FileSystemPath thіs, FileMode fileMode, FileAccess fileAccess, FileShare fileShare, FileFlagsAndAttributes fileFlagsAndAttributes);
    public virtual ulong GetFileIndex(FileSystemPath thіs);
    public virtual FileSystemPath GetShortPath(FileSystemPath thіs);
    public virtual FileSystemPath GetLongPath(FileSystemPath thіs);
    public virtual FileSystemPath GetTempPath();
    private static FileSystemPath CalculateTempDir();
    public static string CalculatePerUserTempDir();
    private static StatResult StatFile(string path);
    [CompilerGeneratedAttribute]
private static string <StatFile>b__5(string x);
}
public static class JetBrains.Util.UnixFileSystemPathUtils : object {
    private static string ProbeFileName;
    private static UnixFileSystemPathUtils();
    public static bool HasWritePermissionOnDir(FileSystemPath fsp);
}
internal class JetBrains.Util.UnixFsWriteHandler : object {
    public sealed virtual FileStreamWrapper OpenStream(FileSystemPath it, FileMode fileMode, FileAccess fileAccess, FileShare fileShare);
    public sealed virtual void DeleteDirectoryNonRecursive(FileSystemPath it, int nAttempts, Exception& ex);
    public sealed virtual FileSystemPath CreateDirectory(FileSystemPath it);
    public sealed virtual bool TryCreateNewDirectoryAtomic(FileSystemPath it);
    public sealed virtual void Move(FileSystemPath it, FileSystemPath dst);
    public sealed virtual void MoveFile(FileSystemPath it, FileSystemPath dst, bool overwrite);
    public sealed virtual void CopyFile(FileSystemPath it, FileSystemPath dst, bool overwrite);
    public sealed virtual void SetAttributes(FileSystemPath it, FileAttributes fileAttributes);
    public sealed virtual void SetFileModificationTimeUtc(FileSystemPath it, DateTime t);
    public sealed virtual void DeleteFile(FileSystemPath it);
    public sealed virtual void DeleteFile(FileSystemPath it, Boolean& isDirectory, int nAttempts);
    public string GetFileAccessPath(FileSystemPath it);
}
public class JetBrains.Util.UnixJetFileSystemWatcher : JetFileSystemWatcher {
    private FileSystemWatcher myNativeFsWatcher;
    private Lazy`1<PathWildcard> myFilter;
    private FileSystemPath myDirectory;
    private bool myDisposed;
    private IWatcherEvents myWatcherEvents;
    public FileSystemPath Directory { get; }
    public bool IncludeSubdirectories { get; }
    public PathWildcard Filter { get; }
    public NotifyFilters NotifyFilters { get; }
    public bool Disposed { get; }
    private UnixJetFileSystemWatcher(FileSystemPath path, string filter, NotifyFilters notifyFilter, bool includeSubdirectories, IWatcherEvents watcherEvents);
    [CanBeNullAttribute]
public static JetFileSystemWatcher CreateInstance(FileSystemPath path, string filter, NotifyFilters notifyFilter, bool includeSubdirectories, IWatcherEvents watcherEvents, WinError& rc);
    private void OnRenamed(object sender, RenamedEventArgs args);
    private void OnDeleted(object sender, FileSystemEventArgs args);
    private void OnCreated(object sender, FileSystemEventArgs args);
    private void OnChanged(object sender, FileSystemEventArgs args);
    private void OnError(object sender, ErrorEventArgs args);
    public virtual void Dispose();
    public virtual FileSystemPath get_Directory();
    public virtual bool get_IncludeSubdirectories();
    public virtual PathWildcard get_Filter();
    public virtual NotifyFilters get_NotifyFilters();
    public virtual bool get_Disposed();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
private PathWildcard <.ctor>b__1();
}
public class JetBrains.Util.UnmanagedBlock : object {
    private int myLength;
    private UnmanagedBlockHandle myPointer;
    public int Length { get; }
    public IntPtr Pointer { get; }
    public bool IsDisposed { get; }
    private UnmanagedBlock(IntPtr pointer, int length);
    public int get_Length();
    public IntPtr get_Pointer();
    public IntPtr GetPointerToOffset(int offset);
    [ConditionalAttribute("JET_MODE_ASSERT")]
public void AssertNotDisposed();
    public bool get_IsDisposed();
    public sealed virtual void Dispose();
    public static UnmanagedBlock Alloc(int bytes);
    public static UnmanagedBlock FromArray(Byte[] bytes);
    public static UnmanagedBlock CreateFromFile(FileSystemPath path);
    public static UnmanagedBlock CreateFromStream(Stream stream);
    public static UnmanagedBlock CreateFromStream(Stream stream, int length);
}
public class JetBrains.Util.UserDataHolder : object {
    [CanBeNullAttribute]
private Bucket myHead;
    public UserDataHolder(UserDataHolder chained);
    protected void ClearData();
    public sealed virtual IEnumerable`1<KeyValuePair`2<object, object>> EnumerateData();
    public sealed virtual T GetData(Key`1<T> key);
    public sealed virtual void PutData(Key`1<T> key, T val);
    [MustUseReturnValueAttribute]
public sealed virtual T GetOrCreateDataUnderLock(Key`1<T> key, Func`1<T> factory);
    [MustUseReturnValueAttribute]
public sealed virtual T GetOrCreateDataUnderLock(Key`1<T> key, TState state, Func`2<TState, T> factory);
    [PureAttribute]
public bool IsEmpty();
    public static void CopyUserData(UserDataHolder from, UserDataHolder to);
}
[ExtensionAttribute]
public static class JetBrains.Util.UserDataHolderExtensions : object {
    [ExtensionAttribute]
public static void PutKey(IUserDataHolder dataHolder, Key`1<object> key);
    [ExtensionAttribute]
[PureAttribute]
public static bool HasKey(IUserDataHolder dataHolder, Key`1<T> key);
    [ExtensionAttribute]
public static void RemoveKey(IUserDataHolder dataHolder, Key`1<T> key);
    [MustUseReturnValueAttribute]
[ExtensionAttribute]
public static T GetOrCreateDataNoLock(IUserDataHolder dataHolder, Key`1<T> key, Func`1<T> creator);
    [ExtensionAttribute]
[MustUseReturnValueAttribute]
public static T GetOrCreateDataNoLock(IUserDataHolder dataHolder, Key`1<T> key, TState state, Func`2<TState, T> creator);
    [ExtensionAttribute]
[MustUseReturnValueAttribute]
public static T GetOrCreateDataNoLock(IUserDataHolder dataHolder, Key`1<T> key, TState1 state1, TState2 state2, Func`3<TState1, TState2, T> creator);
    [ExtensionAttribute]
[MustUseReturnValueAttribute]
public static T GetOrCreateDataNoLock(IUserDataHolder dataHolder, Key`1<T> key, TState1 state1, TState2 state2, TState3 state3, Func`4<TState1, TState2, TState3, T> creator);
}
public class JetBrains.Util.UserDataHolderNoLocks : object {
    [CanBeNullAttribute]
private Bucket myHead;
    public UserDataHolderNoLocks(UserDataHolderNoLocks chained);
    private Bucket CopyBucketsChain(Bucket current);
    public virtual object Clone();
    protected void ClearData();
    public IEnumerable`1<KeyValuePair`2<object, object>> EnumerateData();
    public void PutData(Key`1<T> key, T val);
    public T GetData(Key`1<T> key);
    public T GetOrCreateData(Key`1<T> key, Func`1<T> creator);
    public bool IsEmpty();
    public static void CopyUserData(UserDataHolderNoLocks from, UserDataHolderNoLocks to);
}
public static class JetBrains.Util.UserDataObfuscator : object {
    public static string Obfuscate(string text);
    private static IEnumerable`1<Path> Parse(string text);
}
public class JetBrains.Util.Util.Src.Concurrency.ConcurrentFlag : object {
    private bool myValue;
    public ConcurrentFlag(bool isUp);
    public void Up();
    public void Wait();
}
internal static class JetBrains.Util.Utils.NounUtilResources : object {
    public static string Plural;
    private static NounUtilResources();
}
public class JetBrains.Util.ValidationException : ApplicationException {
    public ValidationException(string message);
    protected ValidationException(SerializationInfo info, StreamingContext context);
}
[ExtensionAttribute]
public static class JetBrains.Util.ValueTypeEx : object {
    [ExtensionAttribute]
public static bool ToBool(int value);
    [ExtensionAttribute]
public static bool ToBool(UInt32 value);
    [ExtensionAttribute]
public static bool ToBool(byte value);
    [ExtensionAttribute]
public static int ToInt(bool value);
}
[DebuggerDisplayAttribute("Target: {(Target) == null ? "<DEAD>" : Target.ToString()}")]
public class JetBrains.Util.WeakHolder`1 : ValueType {
    private GCHandle myHandle;
    public T Target { get; }
    public bool Allocated { get; }
    public WeakHolder`1(T target);
    public WeakHolder`1(T target, bool trackResurrection);
    public T get_Target();
    public bool get_Allocated();
    public sealed virtual bool Equals(T other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual void Dispose();
}
public class JetBrains.Util.Wildcard : object {
    private string myPattern;
    private bool myCaseSensitive;
    private bool myHasWildcardChars;
    public string Pattern { get; }
    public bool HasWildcardChars { get; }
    public Wildcard(string pattern, bool caseSensitive);
    public string get_Pattern();
    public bool get_HasWildcardChars();
    public bool IsMatch(string str);
    private bool MatchChars(char pat, char c);
    public virtual string ToString();
}
public class JetBrains.Util.Win32FileSystemInteraction : FileSystemInteraction {
    private static int OldMaxPath;
    public static Win32FileSystemInteraction Instance;
    [ThreadStaticAttribute]
[CanBeNullAttribute]
private static IFsWriteHandler ourWriteHandler;
    [NotNullAttribute]
private static IFsWriteHandler WriteHandler { get; }
    private static Win32FileSystemInteraction();
    public virtual SafeFileHandle OpenFileHandle(FileSystemPath thіs, FileMode fileMode, FileAccess fileAccess, FileShare fileShare, FileFlagsAndAttributes fileFlagsAndAttributes);
    internal static SafeFileHandle OpenFileHandleInternal(FileSystemPath thіs, FileMode fileMode, FileAccess fileAccess, FileShare fileShare, FileFlagsAndAttributes fileFlagsAndAttributes);
    public virtual FileStream OpenStream(FileSystemPath thіs, FileMode fileMode, FileAccess fileAccess, FileShare fileShare);
    public virtual IEnumerable`1<FileSystemPath> GetDirectoryEntries(FileSystemPath thіs, string mask, Nullable`1<bool> files, FileSystemPathInternStrategy internStrategy);
    internal static void GetDirectoryEntriesInternal(FileSystemPath thіs, RelativePath subdir, string mask, PathSearchFlags flags, ICollection`1& output);
    public virtual void GetDirectoryEntries(FileSystemPath thіs, RelativePath subdir, string mask, PathSearchFlags flags, ICollection`1& output);
    public virtual void Move(FileSystemPath thіs, FileSystemPath destinationFilePath);
    public virtual void MoveFile(FileSystemPath thіs, FileSystemPath destinationFilePath, bool overwrite);
    public virtual void CopyFile(FileSystemPath thіs, FileSystemPath destinationFilePath, bool overwrite);
    public virtual ulong GetFileIndex(FileSystemPath thіs);
    public virtual FileSystemPath CreateDirectory(FileSystemPath thіs);
    public virtual void DeleteFile(FileSystemPath thіs);
    public virtual void DeleteFile(FileSystemPath thіs, Boolean& isDirectory, int nAttempts);
    public virtual void DeleteDirectoryNonRecursive(FileSystemPath thіs, int nAttempts, Exception& ex);
    public virtual void SetAttributes(FileSystemPath thіs, FileAttributes fileAttributes);
    public virtual FileAttributes GetAttributes(FileSystemPath thіs);
    public virtual long GetFileLength(FileSystemPath thіs);
    public virtual FileSystemPath GetLongPath(FileSystemPath thіs);
    public virtual FileSystemPath GetShortPath(FileSystemPath thіs);
    public static string CombinePathAndMask(string path, string mask);
    private static CreationDisposition BuildCreationDisposition(FileMode fileMode);
    private static AccessRights BuildAccessRights(FileAccess fileAccess);
    internal static void ThrowByError(WinError errorCode, string moniker, string additionalData);
    [NotNullAttribute]
internal static Exception CreateException(WinError errorCode, string moniker, string additionalData);
    public virtual FileAttributes TryGetAttributes(FileSystemPath thіs);
    public virtual bool TryCreateNewDirectoryAtomic(FileSystemPath thіs);
    public static FileSystemPath GetFinalPathNameByHandle(SafeFileHandle fileHandle, GetFinalPathNameByHandleFlags flags);
    private static IFsWriteHandler get_WriteHandler();
    public virtual void OverrideWriteHandler(Lifetime lifetime, Func`2<IFsWriteHandler, IFsWriteHandler> newHandlerFactory);
    public virtual Existence GetExists(FileSystemPath thіs);
    [CanBeNullAttribute]
public virtual FileSystemEntryInfo GetInfo(FileSystemPath thіs);
    public virtual DateTime GetFileModificationTimeUtc(FileSystemPath thіs);
    public virtual void SetFileModificationTimeUtc(FileSystemPath thіs, DateTime t);
    public virtual DateTime GetFileCreationTimeUtc(FileSystemPath thіs);
    public virtual DateTime GetFileLastAccessedTimeUtc(FileSystemPath thіs);
    public virtual string GetFileAccessPath(FileSystemPath thіs);
    internal static string GetFileAccessPathInternal(FileSystemPath thіs);
    public virtual bool IsLocked(FileSystemPath thіs);
    public virtual FileSystemPath GetTempPath();
}
public static class JetBrains.Util.Win32FileSystemPathUtils : object {
    public static bool HasWritePermissionOnDir(FileSystemPath fsp);
    public static FileSystemPath GetGuidVolumeRootPath(char drive);
    public static Pair`2<FileSystemPath, string> ParseCommandLineString(string source);
    public static bool UnblockZoneIdentifier(FileSystemPath thіs);
}
internal class JetBrains.Util.Win32FileSystemWriteHandler : object {
    private static string GetFileAccessPath(FileSystemPath it);
    public sealed virtual FileStreamWrapper OpenStream(FileSystemPath it, FileMode fileMode, FileAccess fileAccess, FileShare fileShare);
    private static void ThrowByError(WinError error, FileSystemPath it, string message);
    private static void ThrowByError(WinError error, string fspFullPath, string message);
    public sealed virtual void DeleteDirectoryNonRecursive(FileSystemPath it, int nAttempts, Exception& ex);
    public sealed virtual FileSystemPath CreateDirectory(FileSystemPath it);
    public sealed virtual bool TryCreateNewDirectoryAtomic(FileSystemPath it);
    public sealed virtual void Move(FileSystemPath it, FileSystemPath destinationFilePath);
    public sealed virtual void MoveFile(FileSystemPath it, FileSystemPath destinationFilePath, bool overwrite);
    public sealed virtual void CopyFile(FileSystemPath it, FileSystemPath destinationFilePath, bool overwrite);
    public sealed virtual void SetAttributes(FileSystemPath it, FileAttributes fileAttributes);
    public sealed virtual void SetFileModificationTimeUtc(FileSystemPath thіs, DateTime t);
    public sealed virtual void DeleteFile(FileSystemPath it);
    public sealed virtual void DeleteFile(FileSystemPath it, Boolean& isDirectory, int nAttempts);
}
public class JetBrains.Util.Win32JetFileSystemWatcher : JetFileSystemWatcher {
    private static int EventsBufferSize;
    private static ILogger ourLogger;
    private static NotifyFilters ourNotifyFiltersValidMask;
    private FileSystemPath myDirectory;
    private SafeFileHandle myDirectoryHandle;
    private UnmanagedBlock myEventsBuffer;
    private PathWildcard myFilter;
    private bool myIncludeSubdirectories;
    private NotifyFilters myNotifyFilters;
    private IWatcherEvents myWatcherEvents;
    private bool myDisposed;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) myEventsBufferDisposed;
    private static HashSet`1<UInt32> ourDirectoryNoLongerAvailableErrorCodes;
    private static HashSet`1<UInt32> ourDirectoryAbortedErrorCodes;
    private IOCompletionCallback myCompletionStatusChanged;
    public FileSystemPath Directory { get; }
    public bool IncludeSubdirectories { get; }
    public PathWildcard Filter { get; }
    public NotifyFilters NotifyFilters { get; }
    public bool Disposed { get; }
    private static Win32JetFileSystemWatcher();
    private Win32JetFileSystemWatcher(SafeFileHandle directoryHandle, FileSystemPath directory, string filter, bool includeSubdirectories, NotifyFilters notifyFilter, IWatcherEvents watcherEvents);
    public static JetFileSystemWatcher CreateInstance(FileSystemPath path, string filter, NotifyFilters notifyFilter, bool includeSubdirectories, IWatcherEvents watcherEvents, WinError& rc);
    private void DisposeInternal(bool disposeEventsBuffer);
    private void DisposeEventsBuffer();
    private WinError Monitor();
    [HandleProcessCorruptedStateExceptionsAttribute]
private void CompletionStatusChanged(UInt32 errorCode, UInt32 numBytes, NativeOverlapped* overlappedPointer);
    private bool MatchPattern(string name);
    public virtual void Dispose();
    public virtual FileSystemPath get_Directory();
    public virtual bool get_IncludeSubdirectories();
    public virtual PathWildcard get_Filter();
    public virtual NotifyFilters get_NotifyFilters();
    public virtual bool get_Disposed();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
private void <DisposeInternal>b__3();
}
public static class JetBrains.Util.XmlHtmlNamedCharacterReferences : object {
    private static int ProbeFactor;
    public static Char[] EscapeXmlStandard;
    public static Char[] EscapeXmlStandardAndControlChars;
    [CompilerGeneratedAttribute]
private static StringSourceFixedDelegate`2<Missing, Pair`2<char, char>> CS$<>9__CachedAnonymousMethodDelegate1;
    private static XmlHtmlNamedCharacterReferences();
    public static string TryGetNamedReferenceBySingleChar(char ch);
    public static void TryGetValueForCharacterReference(StringSource name, Char& ch1, Char& ch2);
    private static void RenderHashTable_DoTable(Header header, List`1<KeyValuePair`2<string, string>> items, IDictionary`2<string, ushort> mapStringToRva, StringBuilder sb, bool isHashingByName);
    private static void WriteDwordArray(Byte[] table, string name, StringBuilder sb);
    [CompilerGeneratedAttribute]
private static Pair`2<char, char> <TryGetValueForCharacterReference>b__0(Char* pch, UInt32 length, Missing context);
}
public static class JetBrains.Util.XmlHtmlNamedCharacterReferencesOriginalDictionary : object {
    internal static UInt32[] Strings;
    internal static UInt32[] HashByName;
    internal static UInt32[] HashByValue;
    private static XmlHtmlNamedCharacterReferencesOriginalDictionary();
    public static IDictionary`2<string, string> CreateXmlHtmlNamedCharacterReferencesDictionary();
}
[ExtensionAttribute]
public static class JetBrains.Util.XmlUtil : object {
    public static BidirectionalMapOnDictionary`2<string, char> XmlPredefinedEntities;
    public static Char[] EscapeXmlStandard;
    public static Char[] EscapeXmlStandardAndControlChars;
    private static ProcessStringDelegate`2<CtxUnescape, StringBuilder> UnescapeXmlStringDelegate;
    private static XmlUtil();
    [NotNullAttribute]
[ExtensionAttribute]
public static IEnumerable`1<XmlElement> ChildElements(XmlElement parent);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static XmlAttribute CreateAttributeWithNonEmptyValue(XmlElement element, string attrName, string value);
    [NotNullAttribute]
[ExtensionAttribute]
public static XmlElement CreateAttributeWithNonEmptyValueFluent(XmlElement element, string attrName, string value);
    [NotNullAttribute]
[ExtensionAttribute]
[ObsoleteAttribute("Use XmlElement::SetAttribute(string, string).")]
public static XmlAttribute CreateAttributeWithValue(XmlElement element, string attrName, string value);
    [NotNullAttribute]
[ExtensionAttribute]
public static XmlElement CreateAttributeWithValueFluent(XmlElement element, string attrName, string value);
    [NotNullAttribute]
[ExtensionAttribute]
public static XmlElement CreateElement(XmlNode parent, string tagName);
    [NotNullAttribute]
[ExtensionAttribute]
public static XmlElement CreateLeafElementWithValue(XmlElement parent, string tagName, string value);
    [ExtensionAttribute]
public static Nullable`1<T> GetAttribute(XmlElement element, string attributeName);
    [ExtensionAttribute]
public static string GetAttribute(XmlElement element, string attributeName);
    [ExtensionAttribute]
public static T GetAttribute(XmlElement element, string attributeName, T defaultValue);
    [CanBeNullAttribute]
[ExtensionAttribute]
public static string GetAttribute(XmlElement element, string attributeName, string defaultValue);
    [ExtensionAttribute]
public static bool GetAttribute(XmlElement element, string attributeName, bool defaultValue);
    [ExtensionAttribute]
public static Guid GetAttribute(XmlElement element, string attributeName, Guid defaultValue);
    [ExtensionAttribute]
public static int GetAttribute(XmlElement element, string attributeName, int defaultValue);
    [ExtensionAttribute]
public static int GetAttribute(XmlElement element, string attributeName, NumberStyles style, NumberFormatInfo numberFormatInfo, int defaultValue);
    [ExtensionAttribute]
public static long GetAttribute(XmlElement element, string attributeName, long defaultValue);
    [ExtensionAttribute]
public static double GetAttribute(XmlElement element, string attributeName, double defaultValue);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static string ReadAttribute(XmlElement element, string attributeName);
    [CanBeNullAttribute]
public static string ReadLeafElementValue(XmlElement parent, string tagName);
    public static string ReadLeafElementValue(XmlElement element);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static XmlElement SelectElement(XmlElement parent, string tagName);
    [NotNullAttribute]
[ExtensionAttribute]
public static IEnumerable`1<XmlElement> SelectElements(XmlNode parent, string xpath, XmlNamespaceManager namespaceManager);
    [ExtensionAttribute]
[NotNullAttribute]
public static IEnumerable`1<XmlElement> SelectElements(XmlNode parent, string xpath);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static XmlElement SelectSingleElement(XmlNode parent, string xpath);
    [NotNullAttribute]
public static string EscapeXmlString(string text, Char[] charsToEscape);
    [NotNullAttribute]
public static string EscapeXmlString(string text, EscapeChars escapeChars);
    [NotNullAttribute]
public static string EscapeXmlString(string text, RangeTranslator& translator, Char[] charsToEscape);
    [NotNullAttribute]
private static string EscapeXmlString(string text, bool useRangeTranslator, RangeTranslator& translator, EscapeChars escapeChars);
    public static bool ShouldEscape(string text, Char[] charsToEscape);
    public static bool ShouldEscape(string text, EscapeChars escapeChars);
    [NotNullAttribute]
public static string UnescapeXmlString(string xmlText);
    public static StringSlice UnescapeXmlString(StringSlice xmlText);
    [NotNullAttribute]
public static string UnescapeXmlString(string xmlText, RangeTranslator& translator);
    public static void UnescapeXmlString(StringBuilder result, string xmlText, RangeTranslator translator);
    [CanBeNullAttribute]
private static StringBuilder UnescapeXmlString(StringSlice xmlTextOrig, RangeTranslator translator);
    private static StringBuilder UnescapeXmlString(Char* pch0, int length, CtxUnescape ctx);
    [NotNullAttribute]
[ExtensionAttribute]
public static TNode InsertBeforeThat(TNode this, XmlNode xmlReference);
    [NotNullAttribute]
[ExtensionAttribute]
public static TNode InsertAfterThat(TNode this, XmlNode xmlReference);
    private static bool CanSaveAsInnerText(string value);
    [ExtensionAttribute]
[NotNullAttribute]
public static XmlDocument OwnerDocumentNonNull(XmlNode thіs);
    [NotNullAttribute]
[ExtensionAttribute]
public static XmlNode ParentNodeNonNull(XmlNode thіs);
    [NotNullAttribute]
public static string OuterXmlIndented(XmlElement xmlElement);
    [ExtensionAttribute]
public static IEnumerable`1<XmlElement> GetChildElements(XmlNode node);
    [ExtensionAttribute]
public static IEnumerable`1<XmlElement> GetChildElements(XmlNode node, string name);
}
[ExtensionAttribute]
public static class JetBrains.Util.XmlWriterEx : object {
    public static XmlWriterSettings WriterSettings { get; }
    public static XmlWriterSettings get_WriterSettings();
    [ExtensionAttribute]
public static TWriter StartElem(TWriter writer, string name);
    [ExtensionAttribute]
public static TWriter EndElem(TWriter writer);
    [ExtensionAttribute]
public static TWriter Str(TWriter writer, string str);
    [ExtensionAttribute]
public static TWriter Attr(TWriter writer, string name, object value);
    [ExtensionAttribute]
public static TWriter AttrNs(TWriter writer, string name, string xmlns, object value);
    public static XmlWriter CreateWriter(Stream stream);
    [ExtensionAttribute]
public static void Element(XmlWriter writer, string name, string value);
    [ExtensionAttribute]
public static XmlWriter InElement(XmlWriter writer, string name, Action nested, bool writeFullEndElement);
    [ExtensionAttribute]
public static XmlWriter InElementNs(XmlWriter writer, string name, string xmlns, Action nested, bool writeFullEndElement);
    [ExtensionAttribute]
public static IDisposable PushElement(XmlWriter writer, string name, bool writeFullEndElement);
    [ExtensionAttribute]
public static IDisposable PushElementNs(XmlWriter writer, string name, string xmlns, bool writeFullEndElement);
    [ExtensionAttribute]
public static void WriteXml(Stream stream, Action`1<XmlWriter> FWrite);
    [ExtensionAttribute]
public static void WriteXml(Stream stream, XmlWriterSettings settings, Action`1<XmlWriter> FWrite);
}
public interface System.Collections.Generic.IJetSet`1 {
    public IEqualityComparer`1<T> Comparer { get; }
    public abstract virtual IEqualityComparer`1<T> get_Comparer();
}
public interface System.Collections.Generic.IReadOnlySet`1 {
    public abstract virtual bool Contains(T item);
}
[DebuggerTypeProxyAttribute("System.Collections.Generic.JetHashSetDebugView`1")]
[DebuggerDisplayAttribute("Count = {Count}")]
public class System.Collections.Generic.JetHashSet`1 : object {
    private static int HASH_MASK;
    public static JetHashSet`1<T> Empty;
    [NotNullAttribute]
private IEqualityComparer`1<T> myComparer;
    private Entry[] myEntries;
    private Int32[] myHashToEntryIndex;
    private int myEntriesUsed;
    private int myFirstFreeIndex;
    private int myFreeCount;
    private int myVersion;
    [NotNullAttribute]
public IEqualityComparer`1<T> Comparer { get; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    public JetHashSet`1(IEqualityComparer`1<T> comparer);
    public JetHashSet`1(IEnumerable`1<T> enumerable, IEqualityComparer`1<T> comparer);
    [EditorBrowsableAttribute("1")]
public JetHashSet`1(ICollection`1<T> collection, IEqualityComparer`1<T> comparer);
    public JetHashSet`1(FrugalLocalList`1<T> collection, IEqualityComparer`1<T> comparer);
    public JetHashSet`1(int capacity, IEqualityComparer`1<T> comparer);
    private static JetHashSet`1();
    public sealed virtual IEqualityComparer`1<T> get_Comparer();
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    public virtual bool Add(T element);
    private bool AddImpl(T element, T& existingElement);
    public virtual bool Remove(T element);
    public virtual void Clear();
    public sealed virtual bool Contains(T element);
    public T GetValue(T key);
    public T Intern(T key);
    public bool TryGetValue(T key, T& value);
    public void CopyTo(T[] array);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public void CopyTo(T[] array, int arrayIndex, int count);
    public sealed virtual void UnionWith(IEnumerable`1<T> other);
    public void UnionWith(T[] other);
    private void IntersectWith(ICollection`1<T> other);
    private bool IsSubsetOf(ICollection`1<T> other);
    public sealed virtual void IntersectWith(IEnumerable`1<T> other);
    public sealed virtual bool SetEquals(IEnumerable`1<T> other);
    [EditorBrowsableAttribute("1")]
public bool SetEquals(IJetSet`1<T> other);
    private bool SetEqualsImpl(IEnumerable`1<T> other);
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public static JetHashSet`1<T> NewInstance();
    public static JetHashSet`1<T> NewInstance(int n);
    public ElementEnumerator<T> GetEnumerator();
    public int RemoveWhere(Func`2<T, bool> predicate);
    public sealed virtual void SymmetricExceptWith(IEnumerable`1<T> other);
    public sealed virtual bool IsSubsetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsSupersetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsProperSupersetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsProperSubsetOf(IEnumerable`1<T> other);
    [EditorBrowsableAttribute("1")]
public bool IsSupersetOf(ICollection`1<T> other);
    [EditorBrowsableAttribute("1")]
public bool IsSupersetOf(IJetSet`1<T> other);
    private bool IsSupersetOfImpl(IEnumerable`1<T> other);
    private bool IsGreaterSet(IJetSet`1<T> set);
    public sealed virtual bool Overlaps(IEnumerable`1<T> other);
    private static bool CollectionContainsAll(ICollection`1<T> collection, IEnumerable`1<T> other);
    public sealed virtual void ExceptWith(IEnumerable`1<T> other);
    private void RemoveEntry(int entryIndex, int prevIndex);
    private int GetEntryIndex(T key);
    private void Initialize(int capacity);
    private void Resize();
    public T FirstOrDefault();
    public T First();
    [NotNullAttribute]
public T[] ToArray();
}
internal class System.Collections.Generic.JetHashSetDebugView`1 : object {
    private JetHashSet`1<T> myHashSet;
    [DebuggerBrowsableAttribute("3")]
public T[] Items { get; }
    public JetHashSetDebugView`1(JetHashSet`1<T> set);
    public T[] get_Items();
}
[ExtensionAttribute]
public static class System.Collections.Generic.JetHashSetExtensions : object {
    [ExtensionAttribute]
public static void Add(IJetSet`1<T> set, Lifetime lifetime, T value);
    [ExtensionAttribute]
public static void Compare(IJetSet`1<T> oldSet, IJetSet`1<T> newSet, JetHashSet`1& addedItems, JetHashSet`1& removedItems);
}
public class System.Collections.Generic.JetHashSetSorted`1 : object {
    private JetHashSet`1<TItem> myHashSet;
    private IComparer`1<TItem> myComparer;
    private TItem myLastItem;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public JetHashSetSorted`1(ICollection`1<TItem> collection, IEqualityComparer`1<TItem> equator, IComparer`1<TItem> comparer);
    public JetHashSetSorted`1(IEnumerable`1<TItem> enumerable, IEqualityComparer`1<TItem> equator, IComparer`1<TItem> comparer);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IEnumerator`1<TItem> GetEnumerator();
    private sealed virtual override void System.Collections.Generic.ICollection<TItem>.Add(TItem item);
    public bool Add(TItem item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(TItem item);
    public sealed virtual void CopyTo(TItem[] array, int arrayIndex);
    public sealed virtual bool Remove(TItem item);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
}
[ExtensionAttribute]
public static class System.Linq.EnumerableExJet : object {
    private static ILogger Logger;
    private static EnumerableExJet();
    [NotNullAttribute]
[ExtensionAttribute]
public static IEnumerable`1<TSource> Distinct(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector);
    [NotNullAttribute]
[ExtensionAttribute]
public static IEnumerable`1<TSource> Distinct(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static TSource First(IEnumerable`1<TSource> source, string sExceptionMessageEmpty);
    [ExtensionAttribute]
public static IEnumerable`1<TResult> JetZip(IEnumerable`1<TFirst> first, IEnumerable`1<TSecond> second, Func`3<TFirst, TSecond, TResult> resultSelector);
    [NotNullAttribute]
[ExtensionAttribute]
public static IOrderedEnumerable`1<TSource> OrderBy(IEnumerable`1<TSource> source);
    [NotNullAttribute]
[ExtensionAttribute]
public static IOrderedEnumerable`1<TSource> OrderByDescending(IEnumerable`1<TSource> source);
    [ExtensionAttribute]
[StringFormatMethodAttribute("sContextSentence")]
public static TSource SingleOrFirstErr(IEnumerable`1<TSource> source, string sContextSentence, object arg1, object arg2, object arg3, object arg4);
    [ExtensionAttribute]
[StringFormatMethodAttribute("sContextSentence")]
public static TSource SingleOrFirstOrDefaultErr(IEnumerable`1<TSource> source, string sContextSentence, object arg1, object arg2, object arg3, object arg4);
    internal static Exception CreateExceptionNoItems(Type typeItem, string sContextSentence, object arg1, object arg2, object arg3, object arg4);
    internal static Exception CreateExceptionMultipleItems(Type typeItem, object x, object y, string sContextSentence, object arg1, object arg2, object arg3, object arg4);
    internal static StringBuilder FormatMessage(string sMainMessage, Type typeItem, string sContextSentence, object arg1, object arg2, object arg3, object arg4);
    [ExtensionAttribute]
public static TSource Single(IEnumerable`1<TSource> source, string sExceptionMessageEmpty, string sExceptionMessageAmbiguous);
    [ExtensionAttribute]
public static IDictionary`2<TKey, IList`1<TValue>> MapDictionary(IEnumerable`1<TValue> source, Func`2<TValue, TKey> fGetKey);
    [ObsoleteAttribute("Avoid use of excessive lambdas. SingleOr*Err would do better, especially with lazy formatters like QuoteListIfNeeded.")]
[ExtensionAttribute]
public static TSource Single(IEnumerable`1<TSource> source, Func`1<string> fExceptionMessageEmpty, Func`1<string> fExceptionMessageAmbiguous);
    [ExtensionAttribute]
[NotNullAttribute]
public static ISet`1<TSource> ToSet(IEnumerable`1<TSource> source);
    [ExtensionAttribute]
[NotNullAttribute]
public static JetHashSet`1<TSource> ToJetHashSet(IEnumerable`1<TSource> source);
    [ExtensionAttribute]
[NotNullAttribute]
public static JetHashSet`1<TSource> ToJetHashSet(ICollectionEvents`1<TSource> source);
    [NotNullAttribute]
[ExtensionAttribute]
public static JetHashSet`1<TSource> ToJetHashSet(IEnumerable`1<TSource> source, IEqualityComparer`1<TSource> comparer);
    [NotNullAttribute]
[ExtensionAttribute]
public static JetHashSet`1<TKey> ToJetHashSet(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector);
    [NotNullAttribute]
[ExtensionAttribute]
public static JetHashSet`1<TKey> ToJetHashSet(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static bool And(IEnumerable`1<bool> source);
    [ExtensionAttribute]
public static bool Or(IEnumerable`1<bool> source);
    [ExtensionAttribute]
private static IEnumerable`1<TSource> DistinctImpl(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
private static TSource FirstImpl(IEnumerable`1<TSource> source, Func`2<TSource, bool> predicate, string sExceptionMessageEmpty);
}
