public class JetBrains.Metadata.Access.AssemblyReference : ValueType {
    private MetadataToken myAssemblyReferenceToken;
    private AssemblyNameInfo myAssemblyName;
    public MetadataToken AssemblyReferenceToken { get; }
    public AssemblyNameInfo AssemblyName { get; }
    public AssemblyReference(MetadataToken assemblyReferenceToken, AssemblyNameInfo assemblyName);
    public MetadataToken get_AssemblyReferenceToken();
    public AssemblyNameInfo get_AssemblyName();
}
public class JetBrains.Metadata.Access.ClassLayout : object {
    public static ClassLayout Empty;
    private int myPackingSize;
    private int myClassSize;
    private ReadOnlyDictionary`2<MetadataToken, int> myFieldOffsets;
    public ReadOnlyDictionary`2<MetadataToken, int> FieldOffsets { get; }
    public int PackingSize { get; }
    public int ClassSize { get; }
    public ClassLayout(int packingSize, int classSize, IDictionary`2<MetadataToken, int> fieldOffsets);
    private static ClassLayout();
    public ReadOnlyDictionary`2<MetadataToken, int> get_FieldOffsets();
    public int get_PackingSize();
    public int get_ClassSize();
}
[FlagsAttribute]
public enum JetBrains.Metadata.Access.CorEventAttr : Enum {
    public int value__;
    public static CorEventAttr evSpecialName;
    public static CorEventAttr evReservedMask;
    public static CorEventAttr evRTSpecialName;
}
[FlagsAttribute]
public enum JetBrains.Metadata.Access.CorFieldAttr : Enum {
    public int value__;
    public static CorFieldAttr fdFieldAccessMask;
    public static CorFieldAttr fdCompilerControlled;
    public static CorFieldAttr fdPrivate;
    public static CorFieldAttr fdFamANDAssem;
    public static CorFieldAttr fdAssembly;
    public static CorFieldAttr fdFamily;
    public static CorFieldAttr fdFamORAssem;
    public static CorFieldAttr fdPublic;
    public static CorFieldAttr fdStatic;
    public static CorFieldAttr fdInitOnly;
    public static CorFieldAttr fdLiteral;
    public static CorFieldAttr fdNotSerialized;
    public static CorFieldAttr fdSpecialName;
    public static CorFieldAttr fdPInvokeImpl;
    public static CorFieldAttr fdReservedMask;
    public static CorFieldAttr fdRTSpecialName;
    public static CorFieldAttr fdHasFieldMarshal;
    public static CorFieldAttr fdHasDefault;
    public static CorFieldAttr fdHasFieldRVA;
}
[FlagsAttribute]
public enum JetBrains.Metadata.Access.CorFileFlags : Enum {
    public int value__;
    public static CorFileFlags ffContainsMetaData;
    public static CorFileFlags ffContainsNoMetaData;
}
[FlagsAttribute]
public enum JetBrains.Metadata.Access.CorGenericParamAttr : Enum {
    public int value__;
    public static CorGenericParamAttr gpVarianceMask;
    public static CorGenericParamAttr gpNonVariant;
    public static CorGenericParamAttr gpCovariant;
    public static CorGenericParamAttr gpContravariant;
    public static CorGenericParamAttr gpSpecialConstraintMask;
    public static CorGenericParamAttr gpNoSpecialConstraint;
    public static CorGenericParamAttr gpReferenceTypeConstraint;
    public static CorGenericParamAttr gpValueTypeConstraint;
    public static CorGenericParamAttr gpDefaultConstructorConstraint;
}
[FlagsAttribute]
public enum JetBrains.Metadata.Access.CorMethodAttr : Enum {
    public int value__;
    public static CorMethodAttr mdMemberAccessMask;
    public static CorMethodAttr mdCompilerControlled;
    public static CorMethodAttr mdPrivate;
    public static CorMethodAttr mdFamANDAssem;
    public static CorMethodAttr mdAssem;
    public static CorMethodAttr mdFamily;
    public static CorMethodAttr mdFamORAssem;
    public static CorMethodAttr mdPublic;
    public static CorMethodAttr mdStatic;
    public static CorMethodAttr mdFinal;
    public static CorMethodAttr mdVirtual;
    public static CorMethodAttr mdHideBySig;
    public static CorMethodAttr mdVtableLayoutMask;
    public static CorMethodAttr mdReuseSlot;
    public static CorMethodAttr mdNewSlot;
    public static CorMethodAttr mdStrict;
    public static CorMethodAttr mdAbstract;
    public static CorMethodAttr mdSpecialName;
    public static CorMethodAttr mdPInvokeImpl;
    public static CorMethodAttr mdUnmanagedExport;
    public static CorMethodAttr mdReservedMask;
    public static CorMethodAttr mdRTSpecialName;
    public static CorMethodAttr mdHasSecurity;
    public static CorMethodAttr mdRequireSecObject;
}
[FlagsAttribute]
public enum JetBrains.Metadata.Access.CorMethodImpl : Enum {
    public int value__;
    public static CorMethodImpl miCodeTypeMask;
    public static CorMethodImpl miIL;
    public static CorMethodImpl miNative;
    public static CorMethodImpl miOPTIL;
    public static CorMethodImpl miRuntime;
    public static CorMethodImpl miManagedMask;
    public static CorMethodImpl miUnmanaged;
    public static CorMethodImpl miManaged;
    public static CorMethodImpl miForwardRef;
    public static CorMethodImpl miPreserveSig;
    public static CorMethodImpl miInternalCall;
    public static CorMethodImpl miSynchronized;
    public static CorMethodImpl miNoOptimization;
    public static CorMethodImpl miNoInlining;
    public static CorMethodImpl miAggressiveInlining;
    public static CorMethodImpl miMaxMethodImplVal;
}
[FlagsAttribute]
public enum JetBrains.Metadata.Access.CorMethodSemanticsAttr : Enum {
    public int value__;
    public static CorMethodSemanticsAttr msSetter;
    public static CorMethodSemanticsAttr msGetter;
    public static CorMethodSemanticsAttr msOther;
    public static CorMethodSemanticsAttr msAddOn;
    public static CorMethodSemanticsAttr msRemoveOn;
    public static CorMethodSemanticsAttr msFire;
}
[FlagsAttribute]
public enum JetBrains.Metadata.Access.CorOpenFlags : Enum {
    public UInt32 value__;
    public static CorOpenFlags ofRead;
    public static CorOpenFlags ofWrite;
    public static CorOpenFlags ofReadWriteMask;
    public static CorOpenFlags ofCopyMemory;
    public static CorOpenFlags ofManifestMetadata;
    public static CorOpenFlags ofReadOnly;
    public static CorOpenFlags ofTakeOwnership;
    public static CorOpenFlags ofCacheImage;
    public static CorOpenFlags ofNoTypeLib;
    public static CorOpenFlags ofNoTransform;
    public static CorOpenFlags ofReserved1;
    public static CorOpenFlags ofReserved2;
    public static CorOpenFlags ofReserved;
}
[FlagsAttribute]
public enum JetBrains.Metadata.Access.CorParamAttr : Enum {
    public int value__;
    public static CorParamAttr pdIn;
    public static CorParamAttr pdOut;
    public static CorParamAttr pdOptional;
    public static CorParamAttr pdReservedMask;
    public static CorParamAttr pdHasDefault;
    public static CorParamAttr pdHasFieldMarshal;
    public static CorParamAttr pdUnused;
}
[FlagsAttribute]
public enum JetBrains.Metadata.Access.CorPInvokeMap : Enum {
    public int value__;
    public static CorPInvokeMap pmNoMangle;
    public static CorPInvokeMap pmCharSetMask;
    public static CorPInvokeMap pmCharSetNotSpec;
    public static CorPInvokeMap pmCharSetAnsi;
    public static CorPInvokeMap pmCharSetUnicode;
    public static CorPInvokeMap pmCharSetAuto;
    public static CorPInvokeMap pmBestFitUseAssem;
    public static CorPInvokeMap pmBestFitEnabled;
    public static CorPInvokeMap pmBestFitDisabled;
    public static CorPInvokeMap pmBestFitMask;
    public static CorPInvokeMap pmThrowOnUnmappableCharUseAssem;
    public static CorPInvokeMap pmThrowOnUnmappableCharEnabled;
    public static CorPInvokeMap pmThrowOnUnmappableCharDisabled;
    public static CorPInvokeMap pmThrowOnUnmappableCharMask;
    public static CorPInvokeMap pmSupportsLastError;
    public static CorPInvokeMap pmCallConvMask;
    public static CorPInvokeMap pmCallConvWinapi;
    public static CorPInvokeMap pmCallConvCdecl;
    public static CorPInvokeMap pmCallConvStdcall;
    public static CorPInvokeMap pmCallConvThiscall;
    public static CorPInvokeMap pmCallConvFastcall;
    public static CorPInvokeMap pmMaxValue;
}
[FlagsAttribute]
public enum JetBrains.Metadata.Access.CorPropertyAttr : Enum {
    public int value__;
    public static CorPropertyAttr prSpecialName;
    public static CorPropertyAttr prReservedMask;
    public static CorPropertyAttr prRTSpecialName;
    public static CorPropertyAttr prHasDefault;
    public static CorPropertyAttr prUnused;
}
[FlagsAttribute]
public enum JetBrains.Metadata.Access.CorThreadSafetyOptions : Enum {
    public int value__;
    public static CorThreadSafetyOptions MDThreadSafetyDefault;
    public static CorThreadSafetyOptions MDThreadSafetyOff;
    public static CorThreadSafetyOptions MDThreadSafetyOn;
}
[FlagsAttribute]
public enum JetBrains.Metadata.Access.CorTypeAttr : Enum {
    public int value__;
    public static CorTypeAttr tdVisibilityMask;
    public static CorTypeAttr tdNestedMask;
    public static CorTypeAttr tdNotPublic;
    public static CorTypeAttr tdPublic;
    public static CorTypeAttr tdNestedPublic;
    public static CorTypeAttr tdNestedPrivate;
    public static CorTypeAttr tdNestedFamily;
    public static CorTypeAttr tdNestedAssembly;
    public static CorTypeAttr tdNestedFamANDAssem;
    public static CorTypeAttr tdNestedFamORAssem;
    public static CorTypeAttr tdLayoutMask;
    public static CorTypeAttr tdAutoLayout;
    public static CorTypeAttr tdSequentialLayout;
    public static CorTypeAttr tdExplicitLayout;
    public static CorTypeAttr tdClassSemanticsMask;
    public static CorTypeAttr tdClass;
    public static CorTypeAttr tdInterface;
    public static CorTypeAttr tdAbstract;
    public static CorTypeAttr tdSealed;
    public static CorTypeAttr tdSpecialName;
    public static CorTypeAttr tdImport;
    public static CorTypeAttr tdSerializable;
    public static CorTypeAttr tdWindowsRuntime;
    public static CorTypeAttr tdStringFormatMask;
    public static CorTypeAttr tdAnsiClass;
    public static CorTypeAttr tdUnicodeClass;
    public static CorTypeAttr tdAutoClass;
    public static CorTypeAttr tdCustomFormatClass;
    public static CorTypeAttr tdCustomStringFormatMask;
    public static CorTypeAttr tdBeforeFieldInit;
    public static CorTypeAttr tdForwarder;
    public static CorTypeAttr tdReservedMask;
    public static CorTypeAttr tdRTSpecialName;
    public static CorTypeAttr tdHasSecurity;
}
public class JetBrains.Metadata.Access.CustomAttributeProperties : ValueType {
    private IBlob myValue;
    private MetadataToken myType;
    private MetadataToken myParent;
    public MetadataToken Parent { get; }
    public MetadataToken Type { get; }
    public IBlob Value { get; }
    public CustomAttributeProperties(MetadataToken parent, MetadataToken type, IBlob value);
    public MetadataToken get_Parent();
    public MetadataToken get_Type();
    public IBlob get_Value();
}
public class JetBrains.Metadata.Access.CustomDebugInformationProperties : ValueType {
    private MetadataToken myParent;
    private Guid myKind;
    private IBlob myValue;
    public MetadataToken Parent { get; }
    public Guid Kind { get; }
    public IBlob Value { get; }
    public CustomDebugInformationProperties(MetadataToken parent, Guid kind, IBlob value);
    public MetadataToken get_Parent();
    public Guid get_Kind();
    public IBlob get_Value();
}
public class JetBrains.Metadata.Access.DeclSecurityProperties : ValueType {
    private ushort myAction;
    private IBlob myPermissionSetBlob;
    public ushort Action { get; }
    public IBlob PermissionSetBlob { get; }
    public DeclSecurityProperties(ushort action, IBlob permissionSetBlob);
    public ushort get_Action();
    public IBlob get_PermissionSetBlob();
}
public class JetBrains.Metadata.Access.DocumentProperties : ValueType {
    private string myName;
    private Guid myHashAlgorithm;
    private IBlob myHash;
    private Guid myLanguage;
    public string Name { get; }
    public Guid HashAlgorithm { get; }
    public IBlob Hash { get; }
    public Guid Language { get; }
    public DocumentProperties(string name, Guid hashAlgorithm, IBlob hash, Guid language);
    public string get_Name();
    public Guid get_HashAlgorithm();
    public IBlob get_Hash();
    public Guid get_Language();
}
public class JetBrains.Metadata.Access.EncLogProperties : ValueType {
    private UInt32 myToken;
    private UInt32 myFuncCode;
    public UInt32 Token { get; }
    public UInt32 FuncCode { get; }
    public EncLogProperties(UInt32 token, UInt32 funcCode);
    public UInt32 get_Token();
    public UInt32 get_FuncCode();
}
public class JetBrains.Metadata.Access.EncMapProperties : ValueType {
    private UInt32 myToken;
    public UInt32 Token { get; }
    public EncMapProperties(UInt32 token);
    public UInt32 get_Token();
}
public class JetBrains.Metadata.Access.EventProperties : ValueType {
    private MetadataToken myAdder;
    private MetadataToken myDeclaringType;
    private CorEventAttr myEventFlags;
    private MetadataToken myEventType;
    private string myName;
    private MetadataToken[] myOtherMethods;
    private MetadataToken myRaiser;
    private MetadataToken myRemover;
    public string Name { get; }
    public MetadataToken DeclaringType { get; }
    public CorEventAttr EventFlags { get; }
    public MetadataToken EventType { get; }
    public MetadataToken Adder { get; }
    public MetadataToken Remover { get; }
    public MetadataToken Raiser { get; }
    public MetadataToken[] OtherMethods { get; }
    public EventProperties(string name, MetadataToken declaringType, CorEventAttr eventFlags, MetadataToken eventType, MetadataToken adder, MetadataToken remover, MetadataToken raiser, MetadataToken[] otherMethods);
    public string get_Name();
    public MetadataToken get_DeclaringType();
    public CorEventAttr get_EventFlags();
    public MetadataToken get_EventType();
    public MetadataToken get_Adder();
    public MetadataToken get_Remover();
    public MetadataToken get_Raiser();
    public MetadataToken[] get_OtherMethods();
}
public class JetBrains.Metadata.Access.ExportedTypeProperty : ValueType {
    private MetadataToken myToken;
    private string myClrName;
    private MetadataToken myImplementation;
    private MetadataToken myTypeDef;
    private CorTypeAttr myExportedTypeFlags;
    public MetadataToken Token { get; }
    public string ClrName { get; }
    public MetadataToken Implementation { get; }
    public MetadataToken TypeDef { get; }
    public CorTypeAttr ExportedTypeFlags { get; }
    public ExportedTypeProperty(MetadataToken token, string clrName, MetadataToken implementation, MetadataToken typeDef, CorTypeAttr exportedTypeFlags);
    public MetadataToken get_Token();
    public string get_ClrName();
    public MetadataToken get_Implementation();
    public MetadataToken get_TypeDef();
    public CorTypeAttr get_ExportedTypeFlags();
}
public class JetBrains.Metadata.Access.FieldProperties : ValueType {
    private ElementType myConstantValueElementType;
    private MetadataToken myDeclaringType;
    private CorFieldAttr myFieldFlags;
    private string myName;
    private IBlob mySignatureBlob;
    private IBlob myValue;
    private int myValueLength;
    private UInt32 myRva;
    public string Name { get; }
    public MetadataToken DeclaringType { get; }
    public CorFieldAttr FieldFlags { get; }
    public IBlob SignatureBlob { get; }
    public ElementType ConstantValueElementType { get; }
    public IBlob Value { get; }
    public int ValueLength { get; }
    public UInt32 Rva { get; }
    public FieldProperties(string name, MetadataToken declaringType, CorFieldAttr fieldFlags, IBlob signatureBlob, ElementType constantValueElementType, IBlob value, int valueChars, UInt32 rva);
    public string get_Name();
    public MetadataToken get_DeclaringType();
    public CorFieldAttr get_FieldFlags();
    public IBlob get_SignatureBlob();
    public ElementType get_ConstantValueElementType();
    public IBlob get_Value();
    public int get_ValueLength();
    public UInt32 get_Rva();
}
public class JetBrains.Metadata.Access.FileReference : ValueType {
    private string myName;
    private MetadataToken myToken;
    private CorFileFlags myFileFlags;
    public string Name { get; }
    public MetadataToken Token { get; }
    public CorFileFlags FileFlags { get; }
    public FileReference(string name, MetadataToken token, CorFileFlags fileFlags);
    public string get_Name();
    public MetadataToken get_Token();
    public CorFileFlags get_FileFlags();
}
public class JetBrains.Metadata.Access.GenericParamProperties : ValueType {
    private MetadataToken[] myConstraints;
    private CorGenericParamAttr myGenericParamAttributes;
    private string myName;
    private MetadataToken myOwner;
    private UInt32 myParamIndex;
    public string Name { get; }
    public UInt32 ParamIndex { get; }
    public MetadataToken Owner { get; }
    public CorGenericParamAttr GenericParamAttributes { get; }
    public MetadataToken[] Constraints { get; }
    public GenericParamProperties(string name, UInt32 paramIndex, MetadataToken owner, CorGenericParamAttr attributes, MetadataToken[] constraints);
    public string get_Name();
    public UInt32 get_ParamIndex();
    public MetadataToken get_Owner();
    public CorGenericParamAttr get_GenericParamAttributes();
    public MetadataToken[] get_Constraints();
}
public static class JetBrains.Metadata.Access.ILReader.CodedTokenTables : object {
    private static MetadataTableId[] ourCustomAttributeType;
    private static MetadataTableId[] ourHasConstant;
    private static MetadataTableId[] ourHasCustomAttribute;
    private static MetadataTableId[] ourHasDeclSecurity;
    private static MetadataTableId[] ourHasFieldMarshal;
    private static MetadataTableId[] ourHasSemantic;
    private static MetadataTableId[] ourImplementation;
    private static MetadataTableId[] ourMemberForwarded;
    private static MetadataTableId[] ourMemberReferenceParent;
    private static MetadataTableId[] ourMethodOrMethodReference;
    private static MetadataTableId[] ourResolutionScope;
    private static MetadataTableId[] ourTypeOrMethodDef;
    private static MetadataTableId[] ourTypeOrTypeReference;
    private static MetadataTableId[] ourHasCustomDebugInformation;
    private static CodedTokenTables();
    public static int GetCodedTableId(EncodedTokenType type, MetadataTableId tableId);
    public static MetadataTableId[] CodedTokenList(EncodedTokenType type);
}
public enum JetBrains.Metadata.Access.ILReader.EncodedTokenType : Enum {
    public int value__;
    public static EncodedTokenType TypeDefOrRef;
    public static EncodedTokenType HasConstant;
    public static EncodedTokenType CustomAttributeType;
    public static EncodedTokenType HasSemantics;
    public static EncodedTokenType ResolutionScope;
    public static EncodedTokenType HasFieldMarshal;
    public static EncodedTokenType HasDeclSecurity;
    public static EncodedTokenType MemberRefParent;
    public static EncodedTokenType MethodDefOrRef;
    public static EncodedTokenType MemberForwarded;
    public static EncodedTokenType Implementation;
    public static EncodedTokenType HasCustomAttribute;
    public static EncodedTokenType TypeOrMethodDef;
    public static EncodedTokenType HasCustomDebugInformation;
    public static EncodedTokenType Max;
}
[ExtensionAttribute]
public static class JetBrains.Metadata.Access.ILReader.ExtensionMethods : object {
    [ExtensionAttribute]
public static MetadataToken ToMetadataToken(UInt32 value);
    [ExtensionAttribute]
public static EntityHandle ToEntityHandle(MetadataToken metadataToken);
    [ExtensionAttribute]
public static MethodDefinitionHandle ToMethodDefinitionHandle(MetadataToken methodDefToken);
    [ExtensionAttribute]
public static SymbolToken ToSymbolToken(MetadataToken metadataToken);
}
[FlagsAttribute]
public enum JetBrains.Metadata.Access.ILReader.HeapOffsetSizes : Enum {
    public byte value__;
    public static HeapOffsetSizes HeapString4;
    public static HeapOffsetSizes HeapGuid4;
    public static HeapOffsetSizes HeapBlob4;
    public static HeapOffsetSizes Padding;
    public static HeapOffsetSizes DeltaOnly;
    public static HeapOffsetSizes ExtraData;
    public static HeapOffsetSizes HasDelete;
}
public class JetBrains.Metadata.Access.ILReader.ILReaderMetadataAccess : object {
    private int myFieldsListOffsetInTypeDefTable;
    private UnmanagedBlob myImage;
    private int myMethodsListOffsetInTypeDefTable;
    private int myParamListOffsetInMethodDefTable;
    private int myVariableListInLocalScopeTable;
    private int myConstantListInLocalScopeTable;
    private TableManager myTables;
    [CanBeNullAttribute]
private FileSystemPath myImageFile;
    private TargetPlatform myTargetPlatform;
    private DateTime myImageFileTimestamp;
    private AssemblyNameReader myNameReader;
    private long myResourcesDirectoryOffset;
    private IMetadataAssemblyInfo myMetadataAssemblyInfo;
    private OneToSetMap`2 modreq(System.Runtime.CompilerServices.IsVolatile) myNestedTypeMap;
    private ReadOnlyDictionary`2 modreq(System.Runtime.CompilerServices.IsVolatile) myTypeName2TokenMap;
    private static TablesOrderingState SortedByPrimaryKeyTables;
    private TablesOrderingState myTablesOrdering;
    private int myPeFileEndOffset;
    private int myMetadataStartOffset;
    private PEFile myPEFile;
    [CompilerGeneratedAttribute]
private StreamsManager <Streams>k__BackingField;
    public StreamsManager Streams { get; private set; }
    [CanBeNullAttribute]
public FileSystemPath ImageFile { get; }
    internal DateTime ImageFileTimestamp { get; }
    public IMetadataProvider MetadataProvider { get; }
    public Guid Mvid { get; }
    public string ModuleName { get; }
    public TargetPlatform TargetPlatform { get; }
    public OneToSetMap`2<MetadataToken, MetadataToken> NestedTypeMap { get; }
    public ReadOnlyDictionary`2<string, MetadataToken> TypeName2TokenMapping { get; }
    public TableManager Tables { get; }
    internal int PeFileEndOffset { get; }
    public UnmanagedBlob Image { get; }
    public int MetadataStartOffset { get; }
    [CanBeNullAttribute]
public PEFile PeFile { get; }
    public ILReaderMetadataAccess(Stream stream, FileSystemPath imageFile, DateTime imageFileTimestamp);
    private static ILReaderMetadataAccess();
    [CompilerGeneratedAttribute]
public StreamsManager get_Streams();
    [CompilerGeneratedAttribute]
private void set_Streams(StreamsManager value);
    public FileSystemPath get_ImageFile();
    internal void DisposeMemory();
    internal DateTime get_ImageFileTimestamp();
    private static long GetResourcesDirectoryOffset(PEFile file);
    public sealed virtual IMetadataProvider get_MetadataProvider();
    public sealed virtual IMetadataAssemblyInfo GetAssemblyInfo();
    public sealed virtual Guid get_Mvid();
    public sealed virtual string get_ModuleName();
    public sealed virtual TargetPlatform get_TargetPlatform();
    public sealed virtual MetadataTokenRange GetModuleRefs();
    public sealed virtual MetadataTokenRange GetTypeDefs();
    public sealed virtual TypeDefProperties GetTypeDefProperties(MetadataToken typeDef);
    public sealed virtual TypeRefProperties GetTypeRefProperties(MetadataToken typeRef);
    public sealed virtual IBlob GetTypeSpecBlob(MetadataToken typeSpec);
    public sealed virtual IBlob GetStandaloneSignatureBlob(MetadataToken standAloneSig);
    public sealed virtual MethodSpecProperties GetMethodSpecProperties(MetadataToken methodSpec);
    public sealed virtual MetadataToken[] FindMethodSpecs(MetadataToken methodDefOrRef);
    public sealed virtual MetadataTokenRange GetGenericParameters(MetadataToken ownerToken);
    public sealed virtual GenericParamProperties GetGenericParamProperties(MetadataToken gpToken);
    public sealed virtual MetadataToken[] GetInterfaceImplementations(MetadataToken typeToken);
    public sealed virtual string GetMemberName(MetadataToken memberToken);
    public sealed virtual MetadataTokenRange GetFields(MetadataToken typeToken);
    public sealed virtual FieldProperties GetFieldProperties(MetadataToken fieldToken);
    public sealed virtual MetadataTokenRange GetMethods(MetadataToken typeToken);
    public int ReadString(int offset);
    private int ReadGuid(int offset);
    private int ReadBlob(int offset);
    public sealed virtual MethodProperties GetMethodProperties(MetadataToken methodToken);
    private MetadataToken GetMethodDefDeclaringType(MetadataToken methodToken);
    public sealed virtual MetadataTokenRange GetParameters(MetadataToken methodToken);
    public sealed virtual MetadataToken GetParameterByIndex(MetadataToken methodToken, UInt32 paramIndex);
    public sealed virtual ParamProperties GetParameterProperties(MetadataToken paramToken);
    public sealed virtual MetadataTokenRange GetProperties(MetadataToken typeToken);
    public sealed virtual PropertyProperties GetPropertyProperties(MetadataToken propertyToken);
    public sealed virtual MetadataTokenRange GetEvents(MetadataToken typeToken);
    public sealed virtual EventProperties GetEventProperties(MetadataToken eventToken);
    public sealed virtual MetadataToken GetEnclosingType(MetadataToken typeToken);
    public sealed virtual MetadataTokenRange GetCustomAttributes(MetadataToken parentToken);
    public sealed virtual CustomAttributeProperties GetCustomAttributeProperties(MetadataToken customAttributeToken);
    public sealed virtual MetadataTypeReference GetCustomAttributeTypeName(MetadataToken customAttributeToken);
    public sealed virtual string GetModuleRefProperties(MetadataToken token);
    public sealed virtual MemberReferenceProperties GetMemberReferenceProperties(MetadataToken memberReferenceToken);
    public sealed virtual ManifestResourceProperties GetManifestResourceProperties(MetadataToken manifestResourceToken);
    public sealed virtual MethodImplementationProperties[] GetMethodImplementationProperties(MetadataToken typeToken);
    public sealed virtual PInvokeProperties GetPInvokeProperties(MetadataToken methodToken);
    public sealed virtual ImplMapProperties GetImplMapProperties(MetadataToken implMapToken);
    public sealed virtual EncLogProperties GetEncLogProperties(MetadataToken encLogToken);
    public sealed virtual EncMapProperties GetEncMapProperties(MetadataToken encMapToken);
    public sealed virtual IBlob GetMarshalSpec(MetadataToken token);
    public sealed virtual MetadataTokenRange GetTypeRefs();
    public sealed virtual ClassLayout GetClassLayout(MetadataToken typeToken);
    public sealed virtual string GetUserString(MetadataToken pointer);
    public sealed virtual MetadataTokenRange GetDeclSecurity(MetadataToken owner);
    public sealed virtual DeclSecurityProperties GetDeclSecurityProperties(MetadataToken token);
    public sealed virtual String[] GetDeclSecurityTypeNames(MetadataToken token);
    public sealed virtual MetadataToken FindTypeRef(MetadataToken resolutionScope, string qualifiedName);
    public sealed virtual MetadataToken[] FindTypeRefs(string qualifiedName);
    public sealed virtual MetadataTokenRange GetTypeSpecs();
    public sealed virtual MetadataTokenRange GetMethodSpecs();
    public sealed virtual MetadataTokenRange GetStandAloneSigs();
    public sealed virtual MetadataTokenRange GetMethods();
    public sealed virtual MetadataTokenRange GetFields();
    public sealed virtual MetadataTokenRange GetImplMaps();
    public sealed virtual MetadataTokenRange GetEncLogs();
    public sealed virtual MetadataTokenRange GetEncMaps();
    public sealed virtual MetadataTokenRange GetManifestResources();
    public sealed virtual MetadataTokenRange GetDocuments();
    public sealed virtual string GetDocumentName(MetadataToken documentToken);
    public sealed virtual DocumentProperties GetDocumentProperties(MetadataToken documentToken);
    public sealed virtual DebugDocument GetDocument(MetadataToken documentToken);
    public sealed virtual MetadataTokenRange GetMethodDebugInformations();
    public sealed virtual IList`1<SequencePoint> GetMethodDebugInformation(MetadataToken mdiToken);
    public sealed virtual IList`1<SequencePoint> GetMethodDebugInformation(MetadataToken mdiToken, MetadataToken& localVariablesSignatureToken);
    public sealed virtual MetadataTokenRange GetLocalScopes();
    public sealed virtual LocalScopeProperties GetLocalScopeProperties(MetadataToken localScopeToken);
    public sealed virtual MetadataTokenRange GetScopeVariables(MetadataToken localScopeToken);
    public sealed virtual MetadataTokenRange GetScopeConstants(MetadataToken localScopeToken);
    public sealed virtual LocalVariableProperties GetLocalVariableProperties(MetadataToken localVariableToken);
    public sealed virtual MetadataTokenRange GetImportScopes();
    public sealed virtual ImportScopeProperties GetImportScopeProperties(MetadataToken importScopeToken);
    public sealed virtual MetadataTokenRange GetCustomDebugInformations();
    public sealed virtual CustomDebugInformationProperties GetCustomDebugInformationProperties(MetadataToken customDebugInformationToken);
    public sealed virtual MetadataTokenRange GetStateMachineMethods();
    public sealed virtual StateMachineMethodProperties GetStateMachineMethodProperties(MetadataToken stateMachineMethodToken);
    public sealed virtual MetadataToken[] FindMemberRefs(MetadataToken typeToken);
    public sealed virtual OneToSetMap`2<MetadataToken, MetadataToken> get_NestedTypeMap();
    public sealed virtual ReadOnlyDictionary`2<string, MetadataToken> get_TypeName2TokenMapping();
    public TableManager get_Tables();
    internal int get_PeFileEndOffset();
    public UnmanagedBlob get_Image();
    public int get_MetadataStartOffset();
    public PEFile get_PeFile();
    public sealed virtual JetReadOnlyList`1<UInt32> GetMethodRvaMap();
    public sealed virtual long GetEmbeddedResourceOffset(long resourceOffset);
    private OneToSetMap`2<MetadataToken, MetadataToken> LoadNestedTypeMap();
    private string GetTypeFullyQualifiedName(MetadataToken typeToken);
    private ReadOnlyDictionary`2<string, MetadataToken> LoadTypeNamesMap();
    private MetadataToken[] GetGenericParamContstraints(MetadataToken genericParamToken);
    private IntInterval ReadRIDInterval(MetadataToken owner, int tokenOffset, MetadataTableId tokenType);
    private MetadataTokenRange ReadTokenInterval(MetadataToken owner, int tokenOffset, MetadataTableId tokenType);
    private MetadataToken EntityToOwnerIntervalLookup(MetadataToken entityToken, int entityStartOffsetInOwnerRow, MetadataTableId ownerTable);
    private static UInt32 TokenToRawToken(MetadataToken token, MetadataTokenType target);
    private MetadataToken SearchInTable(MetadataTableId table, int targetOffsetInRow, MetadataTokenType targetStorageFormat, MetadataToken targetToken);
    internal MetadataToken[] ReadTokensFromTable(MetadataTableId table, int tokenOffset, MetadataTokenType tokenType, IntInterval interval);
    private IntInterval FindTokensClusterInTable(MetadataToken aroundToken, int tokenOffset, MetadataTokenType tokenType);
    private UInt32 ReadRawToken(int index, int tableStart, int tableRowSize, MetadataTokenType tokenType, int tokenOffset);
    private IntInterval FindValuesCluster(int len, int aroundInd, int tableStart, int tableRowSize, MetadataTokenType tokenType, int tokenOffset);
    private MethodSemanticsProperties[] GetAssocSemantics(MetadataToken associationToken);
    private MetadataToken GetEventDeclaringType(MetadataToken eventToken);
    private MetadataToken GetPropertyDeclaringType(MetadataToken propertyToken);
    private void ReadConstant(MetadataToken objectToken, IBlob& value, UInt16& type);
    public IEnumerable`1<Pair`2<string, MetadataToken>> GetAllStringConstantsWithParentTokens();
    public IEnumerable`1<Pair`2<string, MetadataToken>> GetAllPInvokeStringsWithTokens();
    private Guid GetGuid(int index);
    [NotNullAttribute]
public string GetString(int offset);
    [NotNullAttribute]
private IBlob GetBlob(int offset);
    public UInt32 ReadToken(int offset, MetadataTokenType type);
    private UInt32 ReadRawToken(int offset, MetadataTokenType type);
    private UInt32 InternalReadCodedToken(int offset, EncodedTokenType type);
    private static string MakeTypeFqn(string namespace, string name);
    internal void LoadAllTables();
}
public class JetBrains.Metadata.Access.ILReader.ILReaderMetadataProvider : object {
    private static TimeSpan ourCacheMetadataEntryTtl;
    private static TimeSpan ourCacheMetadataExpirationCheck;
    public static IMetadataProvider Instance;
    private IDictionary`2<string, CacheEntry> myCache;
    [UsedImplicitlyAttribute]
private Timer myExpirationTimer;
    private IDictionary`2<string, object> myPerFileOrIdLock;
    [CompilerGeneratedAttribute]
private static Func`2<KeyValuePair`2<string, CacheEntry>, bool> CS$<>9__CachedAnonymousMethodDelegate16;
    public int CacheEntryCountInUse { get; }
    public int TotalUsageCounter { get; }
    private static ILReaderMetadataProvider();
    public sealed virtual IMetadataAccess TryGetFromFile(FileSystemPath fsp);
    private static string FileSystemPathToId(FileSystemPath fsp);
    private IMetadataAccess GetMetadataAccess(string id, DateTime currentFileModificationTime, Func`1<CacheEntry> getMetadataAccess);
    public sealed virtual IMetadataAccess GetFromFile(FileSystemPath fsp);
    public sealed virtual IMetadataAccess GetFromStream(string id, DateTime fileModificationTimeUtc, Func`1<Stream> getStream);
    public sealed virtual IMetadataAccess TryGetFromStream(string id, DateTime fileModificationTimeUtc, Func`1<Stream> getData);
    public sealed virtual void DisposeMetadataAccess(IMetadataAccess access);
    private void ExpireCaches();
    public void ClearCaches();
    public int get_CacheEntryCountInUse();
    public int get_TotalUsageCounter();
    public void DumpDebugInfo(TextWriter sw);
    [CompilerGeneratedAttribute]
private void <.ctor>b__0(object _);
    [CompilerGeneratedAttribute]
private static bool <get_CacheEntryCountInUse>b__15(KeyValuePair`2<string, CacheEntry> entry);
}
public interface JetBrains.Metadata.Access.ILReader.ITableReader {
    public abstract virtual byte ReadByte();
    public abstract virtual ushort ReadUInt16();
    public abstract virtual UInt32 ReadUInt32();
    public abstract virtual int ReadString();
    public abstract virtual int ReadGuid();
    public abstract virtual int ReadBlob();
    public abstract virtual UInt32 ReadToken(MetadataTokenType type);
}
[FlagsAttribute]
public enum JetBrains.Metadata.Access.ILReader.MetadataTableFlags : Enum {
    public ulong value__;
    public static MetadataTableFlags Module;
    public static MetadataTableFlags TypeRef;
    public static MetadataTableFlags TypeDef;
    public static MetadataTableFlags FieldPointer;
    public static MetadataTableFlags Field;
    public static MetadataTableFlags MethodPointer;
    public static MetadataTableFlags MethodDef;
    public static MetadataTableFlags ParamPointer;
    public static MetadataTableFlags Param;
    public static MetadataTableFlags InterfaceImpl;
    public static MetadataTableFlags MemberRef;
    public static MetadataTableFlags Constant;
    public static MetadataTableFlags CustomAttribute;
    public static MetadataTableFlags FieldMarshal;
    public static MetadataTableFlags DeclSecurity;
    public static MetadataTableFlags ClassLayout;
    public static MetadataTableFlags FieldLayout;
    public static MetadataTableFlags StandAloneSig;
    public static MetadataTableFlags EventMap;
    public static MetadataTableFlags EventPointer;
    public static MetadataTableFlags Event;
    public static MetadataTableFlags PropertyMap;
    public static MetadataTableFlags PropertyPointer;
    public static MetadataTableFlags Property;
    public static MetadataTableFlags MethodSemantics;
    public static MetadataTableFlags MethodImpl;
    public static MetadataTableFlags ModuleRef;
    public static MetadataTableFlags TypeSpec;
    public static MetadataTableFlags ImplMap;
    public static MetadataTableFlags FieldRva;
    public static MetadataTableFlags EncLog;
    public static MetadataTableFlags EncMap;
    public static MetadataTableFlags Assembly;
    public static MetadataTableFlags AssemblyProcessor;
    public static MetadataTableFlags AssemblyOS;
    public static MetadataTableFlags AssemblyRef;
    public static MetadataTableFlags AssemblyRefProcessor;
    public static MetadataTableFlags AssemblyRefOS;
    public static MetadataTableFlags File;
    public static MetadataTableFlags ExportedType;
    public static MetadataTableFlags ManifestResource;
    public static MetadataTableFlags NestedClass;
    public static MetadataTableFlags GenericParam;
    public static MetadataTableFlags MethodSpec;
    public static MetadataTableFlags GenericParamConstraint;
    public static MetadataTableFlags Document;
    public static MetadataTableFlags MethodDebugInformation;
    public static MetadataTableFlags LocalScope;
    public static MetadataTableFlags LocalVariable;
    public static MetadataTableFlags LocalConstant;
    public static MetadataTableFlags ImportScope;
    public static MetadataTableFlags StateMachineMethod;
    public static MetadataTableFlags CustomDebugInformation;
}
public enum JetBrains.Metadata.Access.ILReader.MethodSemanticsAttributes : Enum {
    public short value__;
    public static MethodSemanticsAttributes Setter;
    public static MethodSemanticsAttributes Getter;
    public static MethodSemanticsAttributes Other;
    public static MethodSemanticsAttributes AddOn;
    public static MethodSemanticsAttributes RemoveOn;
    public static MethodSemanticsAttributes Fire;
}
public class JetBrains.Metadata.Access.ILReader.PdbStream : object {
    [CompilerGeneratedAttribute]
private Guid <Signature>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <TimeDateStamp>k__BackingField;
    [CompilerGeneratedAttribute]
private MetadataToken <EntryPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <ReferencedTypeSystemTables>k__BackingField;
    [CompilerGeneratedAttribute]
private Int32[] <TypeSystemTableRows>k__BackingField;
    public Guid Signature { get; private set; }
    public UInt32 TimeDateStamp { get; private set; }
    public MetadataToken EntryPoint { get; private set; }
    public ulong ReferencedTypeSystemTables { get; private set; }
    public Int32[] TypeSystemTableRows { get; private set; }
    public PdbStream(IBinaryReader reader);
    [CompilerGeneratedAttribute]
public Guid get_Signature();
    [CompilerGeneratedAttribute]
private void set_Signature(Guid value);
    [CompilerGeneratedAttribute]
public UInt32 get_TimeDateStamp();
    [CompilerGeneratedAttribute]
private void set_TimeDateStamp(UInt32 value);
    [CompilerGeneratedAttribute]
public MetadataToken get_EntryPoint();
    [CompilerGeneratedAttribute]
private void set_EntryPoint(MetadataToken value);
    [CompilerGeneratedAttribute]
public ulong get_ReferencedTypeSystemTables();
    [CompilerGeneratedAttribute]
private void set_ReferencedTypeSystemTables(ulong value);
    [CompilerGeneratedAttribute]
public Int32[] get_TypeSystemTableRows();
    [CompilerGeneratedAttribute]
private void set_TypeSystemTableRows(Int32[] value);
}
public class JetBrains.Metadata.Access.ILReader.StreamsManager : object {
    public static string PdbHeap;
    public static string StringHeap;
    public static string GuidHeap;
    public static string BlobHeap;
    public static string UserStringHeap;
    public static string TablesHeap;
    public static string TablesHeapNonOptimized;
    private static int GuidSize;
    private static string InvalidUserStringMessage;
    private StreamHeader myBlobHeapHdr;
    private StreamHeader myGuidHeapHdr;
    private string myImageMoniker;
    private StreamHeader myStringHeapHdr;
    private TableManager myTables;
    private PdbStream myPdbStream;
    private StreamHeader myUserstringHeapHdr;
    private int myUserstringEndOffset;
    private IBlob myImage;
    private Dictionary`2<int, string> myBlobOffsetToString;
    public TableManager Tables { get; }
    public PdbStream PdbStream { get; }
    public StreamsManager(IBlob metadataBlob, string imageMoniker);
    public Guid GetGuid(int index);
    [NotNullAttribute]
public Guid[] GetAllGuids();
    public IEnumerable`1<string> GetAllStrings();
    public IEnumerable`1<Pair`2<string, int>> GetAllStringsWithOffsets();
    [NotNullAttribute]
public string GetString(int offset);
    [NotNullAttribute]
public IBlob GetBlob(int offset);
    public IEnumerable`1<int> GetAllBlobOffsets();
    public TableManager get_Tables();
    public PdbStream get_PdbStream();
    public IEnumerable`1<string> GetAllUserStrings();
    public IEnumerable`1<Pair`2<string, int>> GetAllUserStringsWithOffsets();
    public string GetUserString(MetadataToken pointer);
    private string ReadUserString(int offset, Int32& stringSize);
    public int GetAbsoluteStringsTableOffset(int metadataOffset);
    public string GetUtf8String(int blobOffset);
    public string GetUtf8String(IBinaryReader reader, IDictionary`2<UInt32, object> blobs);
}
public class JetBrains.Metadata.Access.ILReader.TableManager : object {
    private string myImageMoniker;
    public static Int32[] CODED_TOKEN_BITS;
    public int BlobIdxSize;
    public int GuidIdxSize;
    private IBinaryReader myReader;
    public int StringIdxSize;
    public Int32[] TableOffsets;
    public Int32[] TableRows;
    public Int32[] TableRowSize;
    public Int32[] TokenSize;
    [CompilerGeneratedAttribute]
private TablesHeader <TablesHeader>k__BackingField;
    public TablesHeader TablesHeader { get; private set; }
    private int SizeString { get; }
    private int SizeGuid { get; }
    private int SizeByteArray { get; }
    public TableManager(IBinaryReader reader, PdbStream pdbStream, string imageMoniker);
    private static TableManager();
    [CompilerGeneratedAttribute]
public TablesHeader get_TablesHeader();
    [CompilerGeneratedAttribute]
private void set_TablesHeader(TablesHeader value);
    private int get_SizeString();
    private int get_SizeGuid();
    private int get_SizeByteArray();
    private int SizeToken(MetadataTokenType tokenType);
    private int SizeDebugMethodDefToken();
    public ITableReader GetTableRow(MetadataTableId table, int rid);
    public ITableReader GetTableRow(MetadataToken token);
    public int GetRowOffset(MetadataToken token);
    public int GetRowOffset(MetadataTableId table, int rid);
}
public enum JetBrains.Metadata.Access.ILReader.TableOrderingState : Enum {
    public int value__;
    public static TableOrderingState UNKNOWN;
    public static TableOrderingState SORTED;
    public static TableOrderingState UNSORTED;
}
public class JetBrains.Metadata.Access.ILReader.TablesHeader : object {
    [CompilerGeneratedAttribute]
private UInt32 <Reserved>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <MajorVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <MinorVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private HeapOffsetSizes <HeapOffsetSizes>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <RowId>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <MaskValid>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <MaskSorted>k__BackingField;
    public UInt32 Reserved { get; private set; }
    public byte MajorVersion { get; private set; }
    public byte MinorVersion { get; private set; }
    public HeapOffsetSizes HeapOffsetSizes { get; private set; }
    public byte RowId { get; private set; }
    public ulong MaskValid { get; private set; }
    public ulong MaskSorted { get; private set; }
    public TablesHeader(IBinaryReader reader);
    [CompilerGeneratedAttribute]
public UInt32 get_Reserved();
    [CompilerGeneratedAttribute]
private void set_Reserved(UInt32 value);
    [CompilerGeneratedAttribute]
public byte get_MajorVersion();
    [CompilerGeneratedAttribute]
private void set_MajorVersion(byte value);
    [CompilerGeneratedAttribute]
public byte get_MinorVersion();
    [CompilerGeneratedAttribute]
private void set_MinorVersion(byte value);
    [CompilerGeneratedAttribute]
public HeapOffsetSizes get_HeapOffsetSizes();
    [CompilerGeneratedAttribute]
private void set_HeapOffsetSizes(HeapOffsetSizes value);
    [CompilerGeneratedAttribute]
public byte get_RowId();
    [CompilerGeneratedAttribute]
private void set_RowId(byte value);
    [CompilerGeneratedAttribute]
public ulong get_MaskValid();
    [CompilerGeneratedAttribute]
private void set_MaskValid(ulong value);
    [CompilerGeneratedAttribute]
public ulong get_MaskSorted();
    [CompilerGeneratedAttribute]
private void set_MaskSorted(ulong value);
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Metadata.Access.ILReader.TablesOrderingState : object {
    private TableOrderingState[] myState;
    public TableOrderingState Item { get; private set; }
    private TablesOrderingState(TablesOrderingState other);
    public TableOrderingState get_Item(MetadataTableId tableId);
    private void set_Item(MetadataTableId tableId, TableOrderingState value);
    public TablesOrderingState SetState(MetadataTableId tableId, TableOrderingState newState);
    public static TablesOrderingState CreateFromSortedTablesList(MetadataTableId[] sortedTables);
}
public interface JetBrains.Metadata.Access.IMetadataAccess {
    public IMetadataProvider MetadataProvider { get; }
    public Guid Mvid { get; }
    public string ModuleName { get; }
    public TargetPlatform TargetPlatform { get; }
    public OneToSetMap`2<MetadataToken, MetadataToken> NestedTypeMap { get; }
    public ReadOnlyDictionary`2<string, MetadataToken> TypeName2TokenMapping { get; }
    public abstract virtual IMetadataProvider get_MetadataProvider();
    public abstract virtual IMetadataAssemblyInfo GetAssemblyInfo();
    public abstract virtual Guid get_Mvid();
    public abstract virtual string get_ModuleName();
    public abstract virtual TargetPlatform get_TargetPlatform();
    public abstract virtual MetadataTokenRange GetModuleRefs();
    public abstract virtual MetadataTokenRange GetTypeDefs();
    public abstract virtual TypeDefProperties GetTypeDefProperties(MetadataToken typeDef);
    public abstract virtual TypeRefProperties GetTypeRefProperties(MetadataToken typeRef);
    [NotNullAttribute]
public abstract virtual IBlob GetTypeSpecBlob(MetadataToken typeSpec);
    [NotNullAttribute]
public abstract virtual IBlob GetStandaloneSignatureBlob(MetadataToken standAloneSig);
    public abstract virtual MethodSpecProperties GetMethodSpecProperties(MetadataToken methodSpec);
    public abstract virtual MetadataToken[] FindMethodSpecs(MetadataToken methodDefOrRef);
    public abstract virtual MetadataTokenRange GetGenericParameters(MetadataToken ownerToken);
    public abstract virtual GenericParamProperties GetGenericParamProperties(MetadataToken gpToken);
    public abstract virtual MetadataToken[] GetInterfaceImplementations(MetadataToken typeToken);
    public abstract virtual string GetMemberName(MetadataToken memberToken);
    public abstract virtual MetadataTokenRange GetFields(MetadataToken typeToken);
    public abstract virtual FieldProperties GetFieldProperties(MetadataToken fieldToken);
    public abstract virtual MetadataTokenRange GetMethods(MetadataToken typeToken);
    public abstract virtual MethodProperties GetMethodProperties(MetadataToken methodToken);
    public abstract virtual MetadataTokenRange GetParameters(MetadataToken methodToken);
    public abstract virtual MetadataToken GetParameterByIndex(MetadataToken methodToken, UInt32 paramIndex);
    public abstract virtual ParamProperties GetParameterProperties(MetadataToken paramToken);
    public abstract virtual MetadataTokenRange GetProperties(MetadataToken typeToken);
    public abstract virtual PropertyProperties GetPropertyProperties(MetadataToken propertyToken);
    public abstract virtual MetadataTokenRange GetEvents(MetadataToken typeToken);
    public abstract virtual EventProperties GetEventProperties(MetadataToken eventToken);
    public abstract virtual MetadataToken GetEnclosingType(MetadataToken typeToken);
    public abstract virtual MetadataTokenRange GetCustomAttributes(MetadataToken ownerToken);
    public abstract virtual CustomAttributeProperties GetCustomAttributeProperties(MetadataToken customAttributeToken);
    public abstract virtual MetadataTypeReference GetCustomAttributeTypeName(MetadataToken customAttributeToken);
    public abstract virtual string GetModuleRefProperties(MetadataToken token);
    public abstract virtual MemberReferenceProperties GetMemberReferenceProperties(MetadataToken memberReferenceToken);
    public abstract virtual ManifestResourceProperties GetManifestResourceProperties(MetadataToken manifestResourceToken);
    public abstract virtual MethodImplementationProperties[] GetMethodImplementationProperties(MetadataToken typeToken);
    [CanBeNullAttribute]
public abstract virtual PInvokeProperties GetPInvokeProperties(MetadataToken methodToken);
    public abstract virtual ImplMapProperties GetImplMapProperties(MetadataToken implMapToken);
    public abstract virtual EncLogProperties GetEncLogProperties(MetadataToken encLogToken);
    public abstract virtual EncMapProperties GetEncMapProperties(MetadataToken encMapToken);
    [CanBeNullAttribute]
public abstract virtual IBlob GetMarshalSpec(MetadataToken token);
    public abstract virtual MetadataTokenRange GetTypeRefs();
    [CanBeNullAttribute]
public abstract virtual ClassLayout GetClassLayout(MetadataToken typeToken);
    [CanBeNullAttribute]
public abstract virtual string GetUserString(MetadataToken pointer);
    public abstract virtual MetadataTokenRange GetDeclSecurity(MetadataToken owner);
    public abstract virtual DeclSecurityProperties GetDeclSecurityProperties(MetadataToken token);
    public abstract virtual String[] GetDeclSecurityTypeNames(MetadataToken token);
    public abstract virtual MetadataToken FindTypeRef(MetadataToken resolutionScope, string qualifiedName);
    public abstract virtual MetadataToken[] FindTypeRefs(string qualifiedName);
    public abstract virtual MetadataTokenRange GetTypeSpecs();
    public abstract virtual MetadataTokenRange GetMethodSpecs();
    public abstract virtual MetadataTokenRange GetStandAloneSigs();
    public abstract virtual MetadataTokenRange GetMethods();
    public abstract virtual MetadataTokenRange GetManifestResources();
    public abstract virtual MetadataToken[] FindMemberRefs(MetadataToken typeToken);
    public abstract virtual OneToSetMap`2<MetadataToken, MetadataToken> get_NestedTypeMap();
    public abstract virtual ReadOnlyDictionary`2<string, MetadataToken> get_TypeName2TokenMapping();
    public abstract virtual JetReadOnlyList`1<UInt32> GetMethodRvaMap();
    public abstract virtual long GetEmbeddedResourceOffset(long resourceOffset);
    public abstract virtual MetadataTokenRange GetFields();
    public abstract virtual MetadataTokenRange GetImplMaps();
    public abstract virtual MetadataTokenRange GetEncLogs();
    public abstract virtual MetadataTokenRange GetEncMaps();
    public abstract virtual MetadataTokenRange GetDocuments();
    public abstract virtual string GetDocumentName(MetadataToken documentToken);
    public abstract virtual DocumentProperties GetDocumentProperties(MetadataToken documentToken);
    public abstract virtual DebugDocument GetDocument(MetadataToken documentToken);
    public abstract virtual MetadataTokenRange GetMethodDebugInformations();
    public abstract virtual IList`1<SequencePoint> GetMethodDebugInformation(MetadataToken mdiToken, MetadataToken& localVariablesSignatureToken);
    public abstract virtual IList`1<SequencePoint> GetMethodDebugInformation(MetadataToken mdiToken);
    public abstract virtual MetadataTokenRange GetLocalScopes();
    public abstract virtual LocalScopeProperties GetLocalScopeProperties(MetadataToken localScopeToken);
    public abstract virtual MetadataTokenRange GetScopeVariables(MetadataToken localScopeToken);
    public abstract virtual MetadataTokenRange GetScopeConstants(MetadataToken localScopeToken);
    public abstract virtual LocalVariableProperties GetLocalVariableProperties(MetadataToken localVariableToken);
    public abstract virtual MetadataTokenRange GetImportScopes();
    public abstract virtual ImportScopeProperties GetImportScopeProperties(MetadataToken importScopeToken);
    public abstract virtual MetadataTokenRange GetCustomDebugInformations();
    public abstract virtual CustomDebugInformationProperties GetCustomDebugInformationProperties(MetadataToken customDebugInformationToken);
    public abstract virtual MetadataTokenRange GetStateMachineMethods();
    public abstract virtual StateMachineMethodProperties GetStateMachineMethodProperties(MetadataToken stateMachineMethodToken);
}
public interface JetBrains.Metadata.Access.IMetadataAssemblyInfo {
    [CanBeNullAttribute]
public abstract virtual AssemblyNameInfo GetAssemblyName();
    public abstract virtual Dictionary`2<MetadataToken, AssemblyReference> GetReferencedAssembliesNames();
    public abstract virtual Dictionary`2<MetadataToken, string> GetReferencedModulesNames();
    public abstract virtual ExportedTypeProperty[] GetExportedTypes();
    public abstract virtual FileReference[] GetReferencedFiles();
    public abstract virtual MetadataToken GetToken();
}
public interface JetBrains.Metadata.Access.IMetadataProvider {
    [CanBeNullAttribute]
public abstract virtual IMetadataAccess TryGetFromFile(FileSystemPath path);
    [NotNullAttribute]
public abstract virtual IMetadataAccess GetFromFile(FileSystemPath path);
    [CanBeNullAttribute]
public abstract virtual IMetadataAccess TryGetFromStream(string id, DateTime fileModificationTimeUtc, Func`1<Stream> getData);
    public abstract virtual void DisposeMetadataAccess(IMetadataAccess access);
    [NotNullAttribute]
public abstract virtual IMetadataAccess GetFromStream(string id, DateTime fileModificationTimeUtc, Func`1<Stream> getStream);
}
public class JetBrains.Metadata.Access.ImplMapProperties : ValueType {
    private CorPInvokeMap myFlags;
    private MetadataToken myMemberForwarded;
    private MetadataToken myImportScope;
    private string myImportName;
    public CorPInvokeMap Flags { get; }
    public MetadataToken MemberForwarded { get; }
    public MetadataToken ImportScope { get; }
    public string ImportName { get; }
    public ImplMapProperties(CorPInvokeMap flags, MetadataToken memberForwarded, string importName, MetadataToken importScope);
    public CorPInvokeMap get_Flags();
    public MetadataToken get_MemberForwarded();
    public MetadataToken get_ImportScope();
    public string get_ImportName();
}
public class JetBrains.Metadata.Access.ImportScopeProperties : ValueType {
    private MetadataToken myParent;
    [CanBeNullAttribute]
private IList`1<Import> myImports;
    public MetadataToken Parent { get; }
    [CanBeNullAttribute]
public IList`1<Import> Imports { get; }
    public ImportScopeProperties(MetadataToken parent, IList`1<Import> imports);
    public MetadataToken get_Parent();
    public IList`1<Import> get_Imports();
}
public class JetBrains.Metadata.Access.LocalScopeProperties : ValueType {
    private MetadataToken myMethodDebugInformation;
    private MetadataToken myImportScope;
    private UInt32 myStartOffset;
    private UInt32 myLength;
    public MetadataToken MethodDebugInformation { get; }
    public MetadataToken ImportScope { get; }
    public UInt32 StartOffset { get; }
    public UInt32 Length { get; }
    public LocalScopeProperties(MetadataToken methodDebugInformation, MetadataToken importScope, UInt32 startOffset, UInt32 length);
    public MetadataToken get_MethodDebugInformation();
    public MetadataToken get_ImportScope();
    public UInt32 get_StartOffset();
    public UInt32 get_Length();
}
public class JetBrains.Metadata.Access.LocalVariableProperties : ValueType {
    private LocalVariableAttributes myAttributes;
    private ushort myIndex;
    private string myName;
    public LocalVariableAttributes Attributes { get; }
    public ushort Index { get; }
    public string Name { get; }
    public LocalVariableProperties(LocalVariableAttributes attributes, ushort index, string name);
    public LocalVariableAttributes get_Attributes();
    public ushort get_Index();
    public string get_Name();
}
[FlagsAttribute]
public enum JetBrains.Metadata.Access.ManifestResourceAttributes : Enum {
    public UInt32 value__;
    public static ManifestResourceAttributes Public;
    public static ManifestResourceAttributes Private;
    public static ManifestResourceAttributes VisibilityMask;
}
public class JetBrains.Metadata.Access.ManifestResourceProperties : ValueType {
    private UInt32 myOffset;
    private string myName;
    private ManifestResourceAttributes myFlags;
    private MetadataToken myImplementation;
    public UInt32 Offset { get; }
    public string Name { get; }
    public ManifestResourceAttributes Flags { get; }
    public MetadataToken Implementation { get; }
    public ManifestResourceProperties(UInt32 offset, string name, ManifestResourceAttributes flags, MetadataToken implementation);
    public UInt32 get_Offset();
    public string get_Name();
    public ManifestResourceAttributes get_Flags();
    public MetadataToken get_Implementation();
}
public class JetBrains.Metadata.Access.MemberProperties : ValueType {
    [NotNullAttribute]
private string myName;
    private int myAttributes;
    [NotNullAttribute]
public string Name { get; }
    public int Attributes { get; }
    public MemberProperties(string name, int attributes);
    public string get_Name();
    public int get_Attributes();
}
public class JetBrains.Metadata.Access.MemberReferenceProperties : ValueType {
    private string myName;
    private MetadataToken myOwner;
    private IBlob mySignatureBlob;
    public MetadataToken Owner { get; }
    public string Name { get; }
    public IBlob SignatureBlob { get; }
    public MemberReferenceProperties(MetadataToken owner, string name, IBlob signatureBlob);
    public MetadataToken get_Owner();
    public string get_Name();
    public IBlob get_SignatureBlob();
}
public class JetBrains.Metadata.Access.MetadataAccessCookie : object {
    private IMetadataAccess myMetadataAccess;
    [CanBeNullAttribute]
public IMetadataAccess MetadataAccess { get; }
    internal MetadataAccessCookie(IMetadataAccess metadataAccess);
    public IMetadataAccess get_MetadataAccess();
    public sealed virtual void Dispose();
}
[ExtensionAttribute]
public static class JetBrains.Metadata.Access.MetadataProviderEx : object {
    [NotNullAttribute]
[ExtensionAttribute]
public static MetadataAccessCookie GetFromFileDisposable(IMetadataProvider provider, FileSystemPath path);
}
public static class JetBrains.Metadata.Access.MetadataProviderFactory : object {
    public static IMetadataProvider modreq(System.Runtime.CompilerServices.IsVolatile) DefaultProvider;
    private static MetadataProviderFactory();
}
public enum JetBrains.Metadata.Access.MetadataTableId : Enum {
    public int value__;
    public static MetadataTableId Module;
    public static MetadataTableId TypeRef;
    public static MetadataTableId TypeDef;
    public static MetadataTableId FieldPointer;
    public static MetadataTableId Field;
    public static MetadataTableId MethodPointer;
    public static MetadataTableId MethodDef;
    public static MetadataTableId ParamPointer;
    public static MetadataTableId Param;
    public static MetadataTableId InterfaceImpl;
    public static MetadataTableId MemberRef;
    public static MetadataTableId Constant;
    public static MetadataTableId CustomAttribute;
    public static MetadataTableId FieldMarshal;
    public static MetadataTableId DeclSecurity;
    public static MetadataTableId ClassLayout;
    public static MetadataTableId FieldLayout;
    public static MetadataTableId StandAloneSig;
    public static MetadataTableId EventMap;
    public static MetadataTableId EventPointer;
    public static MetadataTableId Event;
    public static MetadataTableId PropertyMap;
    public static MetadataTableId PropertyPointer;
    public static MetadataTableId Property;
    public static MetadataTableId MethodSemantics;
    public static MetadataTableId MethodImpl;
    public static MetadataTableId ModuleRef;
    public static MetadataTableId TypeSpec;
    public static MetadataTableId ImplMap;
    public static MetadataTableId FieldRva;
    public static MetadataTableId EncLog;
    public static MetadataTableId EncMap;
    public static MetadataTableId Assembly;
    public static MetadataTableId AssemblyProcessor;
    public static MetadataTableId AssemblyOS;
    public static MetadataTableId AssemblyRef;
    public static MetadataTableId AssemblyRefProcessor;
    public static MetadataTableId AssemblyRefOS;
    public static MetadataTableId File;
    public static MetadataTableId ExportedType;
    public static MetadataTableId ManifestResource;
    public static MetadataTableId NestedClass;
    public static MetadataTableId GenericParam;
    public static MetadataTableId MethodSpec;
    public static MetadataTableId GenericParamConstraint;
    public static MetadataTableId Document;
    public static MetadataTableId MethodDebugInformation;
    public static MetadataTableId LocalScope;
    public static MetadataTableId LocalVariable;
    public static MetadataTableId LocalConstant;
    public static MetadataTableId ImportScope;
    public static MetadataTableId StateMachineMethod;
    public static MetadataTableId CustomDebugInformation;
    public static MetadataTableId GapStart;
    public static MetadataTableId GapEnd;
    public static MetadataTableId MaxTable;
}
public class JetBrains.Metadata.Access.MetadataToken : ValueType {
    private static UInt32 RidMask;
    private static UInt32 TypeMask;
    private static int TableIdShift;
    private static UInt32 TtAssembly;
    private static UInt32 TtAssemblyRef;
    private static UInt32 TtConstant;
    private static UInt32 TtCustomAttribute;
    private static UInt32 TtEvent;
    private static UInt32 TtExportedType;
    private static UInt32 TtField;
    private static UInt32 TtFile;
    private static UInt32 TtGenericParam;
    private static UInt32 TtGenericParamConstraint;
    private static UInt32 TtInterfaceImpl;
    private static UInt32 TtManifestResource;
    private static UInt32 TtMemberRef;
    private static UInt32 TtMethodDef;
    private static UInt32 TtMethodSpec;
    private static UInt32 TtMethodImpl;
    private static UInt32 TtModule;
    private static UInt32 TtModuleRef;
    private static UInt32 TtParam;
    private static UInt32 TtDeclSecurity;
    private static UInt32 TtProperty;
    private static UInt32 TtStandAloneSig;
    private static UInt32 TtTypeDef;
    private static UInt32 TtTypeRef;
    private static UInt32 TtTypeSpec;
    private static UInt32 TtImplMap;
    private static UInt32 TtDocument;
    private static UInt32 TtMethodDebugInformation;
    private static UInt32 TtLocalVariable;
    private static UInt32 TtLocalConstant;
    private static UInt32 TtImportScope;
    private static UInt32 TtCustomDebugInformation;
    public static MetadataToken Nil;
    private UInt32 myToken;
    public static IEqualityComparer`1<MetadataToken> EqualityComparer;
    public UInt32 Value { get; }
    public bool IsNil { get; }
    public UInt32 RID { get; }
    internal UInt32 Type { get; }
    public MetadataTableId TableId { get; }
    public bool IsAssembly { get; }
    public bool IsAssemblyRef { get; }
    public bool IsConstant { get; }
    public bool IsCustomAttribute { get; }
    public bool IsEvent { get; }
    public bool IsExportedType { get; }
    public bool IsField { get; }
    public bool IsFile { get; }
    public bool IsGenericParam { get; }
    public bool IsGenericParamConstraint { get; }
    public bool IsInterfaceImpl { get; }
    public bool IsManifestResource { get; }
    public bool IsMemberRef { get; }
    public bool IsMethodDef { get; }
    public bool IsMethodSpec { get; }
    public bool IsMethodImpl { get; }
    public bool IsModule { get; }
    public bool IsModuleRef { get; }
    public bool IsParam { get; }
    public bool IsDeclSecurity { get; }
    public bool IsProperty { get; }
    public bool IsStandAloneSig { get; }
    public bool IsTypeDef { get; }
    public bool IsTypeRef { get; }
    public bool IsTypeSpec { get; }
    public bool IsImplMap { get; }
    public bool IsDocument { get; }
    public bool IsMethodDebugInformation { get; }
    public bool IsLocalVariable { get; }
    public bool IsLocalConstant { get; }
    public bool IsImportScope { get; }
    public bool IsCustomDebugInformation { get; }
    public MetadataToken(UInt32 token);
    public MetadataToken(MetadataTableId tableId, int rid);
    private static MetadataToken();
    public static UInt32 MakeToken(MetadataTableId tableId, int rid);
    public UInt32 get_Value();
    public bool get_IsNil();
    public UInt32 get_RID();
    public static UInt32 GetRID(UInt32 token);
    internal UInt32 get_Type();
    public MetadataTableId get_TableId();
    public bool get_IsAssembly();
    public bool get_IsAssemblyRef();
    public bool get_IsConstant();
    public bool get_IsCustomAttribute();
    public bool get_IsEvent();
    public bool get_IsExportedType();
    public bool get_IsField();
    public bool get_IsFile();
    public bool get_IsGenericParam();
    public bool get_IsGenericParamConstraint();
    public bool get_IsInterfaceImpl();
    public bool get_IsManifestResource();
    public bool get_IsMemberRef();
    public bool get_IsMethodDef();
    public bool get_IsMethodSpec();
    public bool get_IsMethodImpl();
    public bool get_IsModule();
    public bool get_IsModuleRef();
    public bool get_IsParam();
    public bool get_IsDeclSecurity();
    public bool get_IsProperty();
    public bool get_IsStandAloneSig();
    public bool get_IsTypeDef();
    public bool get_IsTypeRef();
    public bool get_IsTypeSpec();
    public bool get_IsImplMap();
    public bool get_IsDocument();
    public bool get_IsMethodDebugInformation();
    public bool get_IsLocalVariable();
    public bool get_IsLocalConstant();
    public bool get_IsImportScope();
    public bool get_IsCustomDebugInformation();
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(MetadataToken token1, MetadataToken token2);
    public static bool op_Inequality(MetadataToken token1, MetadataToken token2);
    public static MetadataToken MakeTypedNil(MetadataTableId table);
    public bool IsInRange(MetadataTokenRange range);
}
public class JetBrains.Metadata.Access.MetadataTokenRange : ValueType {
    public static MetadataTokenRange Empty;
    private int myEndRid;
    private int myStartRid;
    private MetadataTableId myTableId;
    public int EndRid { get; }
    public int StartRid { get; }
    public MetadataTableId TableId { get; }
    public int Length { get; }
    public MetadataTokenRange(MetadataTableId tableId, int startRid, int endRid);
    private static MetadataTokenRange();
    public int get_EndRid();
    public int get_StartRid();
    public MetadataTableId get_TableId();
    public int get_Length();
    public bool Contains(MetadataToken token);
    public Enumerator GetEnumerator();
    public static MetadataTokenRange CreateEmptyRange(MetadataTableId tableId);
}
public enum JetBrains.Metadata.Access.MetadataTokenType : Enum {
    public int value__;
    public static MetadataTokenType Module;
    public static MetadataTokenType TypeRef;
    public static MetadataTokenType TypeDef;
    public static MetadataTokenType FieldPointer;
    public static MetadataTokenType Field;
    public static MetadataTokenType MethodPointer;
    public static MetadataTokenType MethodDef;
    public static MetadataTokenType ParamPointer;
    public static MetadataTokenType Param;
    public static MetadataTokenType InterfaceImpl;
    public static MetadataTokenType MemberRef;
    public static MetadataTokenType Constant;
    public static MetadataTokenType CustomAttribute;
    public static MetadataTokenType FieldMarshal;
    public static MetadataTokenType DeclSecurity;
    public static MetadataTokenType ClassLayout;
    public static MetadataTokenType FieldLayout;
    public static MetadataTokenType StandAloneSig;
    public static MetadataTokenType EventMap;
    public static MetadataTokenType EventPointer;
    public static MetadataTokenType Event;
    public static MetadataTokenType PropertyMap;
    public static MetadataTokenType PropertyPointer;
    public static MetadataTokenType Property;
    public static MetadataTokenType MethodSemantics;
    public static MetadataTokenType MethodImpl;
    public static MetadataTokenType ModuleRef;
    public static MetadataTokenType TypeSpec;
    public static MetadataTokenType ImplMap;
    public static MetadataTokenType FieldRva;
    public static MetadataTokenType EncLog;
    public static MetadataTokenType EncMap;
    public static MetadataTokenType Assembly;
    public static MetadataTokenType AssemblyProcessor;
    public static MetadataTokenType AssemblyOS;
    public static MetadataTokenType AssemblyRef;
    public static MetadataTokenType AssemblyRefProcessor;
    public static MetadataTokenType AssemblyRefOS;
    public static MetadataTokenType File;
    public static MetadataTokenType ExportedType;
    public static MetadataTokenType ManifestResource;
    public static MetadataTokenType NestedClass;
    public static MetadataTokenType GenericParam;
    public static MetadataTokenType MethodSpec;
    public static MetadataTokenType GenericParamConstraint;
    public static MetadataTokenType Document;
    public static MetadataTokenType MethodDebugInformation;
    public static MetadataTokenType LocalScope;
    public static MetadataTokenType LocalVariable;
    public static MetadataTokenType LocalConstant;
    public static MetadataTokenType ImportScope;
    public static MetadataTokenType StateMachineMethod;
    public static MetadataTokenType CustomDebugInformation;
    public static MetadataTokenType MaxTableTokenType;
    public static MetadataTokenType TypeDefOrRef;
    public static MetadataTokenType HasConstant;
    public static MetadataTokenType CustomAttributeType;
    public static MetadataTokenType HasSemantics;
    public static MetadataTokenType ResolutionScope;
    public static MetadataTokenType HasFieldMarshal;
    public static MetadataTokenType HasDeclSecurity;
    public static MetadataTokenType MemberRefParent;
    public static MetadataTokenType MethodDefOrRef;
    public static MetadataTokenType MemberForwarded;
    public static MetadataTokenType Implementation;
    public static MetadataTokenType HasCustomAttribute;
    public static MetadataTokenType TypeOrMethodDef;
    public static MetadataTokenType HasCustomDebugInformation;
    public static MetadataTokenType MaxCodedTokenType;
}
public class JetBrains.Metadata.Access.MethodImplementationProperties : ValueType {
    private MetadataToken myType;
    private MetadataToken myMethodBody;
    private MetadataToken myMethodDeclaration;
    public MetadataToken Type { get; }
    public MetadataToken MethodBody { get; }
    public MetadataToken MethodDeclaration { get; }
    public MethodImplementationProperties(MetadataToken type, MetadataToken methodBody, MetadataToken methodDeclaration);
    public MetadataToken get_Type();
    public MetadataToken get_MethodBody();
    public MetadataToken get_MethodDeclaration();
}
public class JetBrains.Metadata.Access.MethodProperties : ValueType {
    private UInt32 myCodeRVA;
    private MetadataToken myDeclaringType;
    private CorMethodImpl myImplFlags;
    private CorMethodAttr myMethodFlags;
    private string myName;
    private IBlob mySignature;
    public string Name { get; }
    public MetadataToken DeclaringType { get; }
    public IBlob Signature { get; }
    public UInt32 CodeRVA { get; }
    public CorMethodAttr MethodFlags { get; }
    public CorMethodImpl ImplFlags { get; }
    public MethodProperties(string name, MetadataToken declaringType, IBlob signature, UInt32 codeRVA, CorMethodAttr methodFlags, CorMethodImpl implFlags);
    public string get_Name();
    public MetadataToken get_DeclaringType();
    public IBlob get_Signature();
    public UInt32 get_CodeRVA();
    public CorMethodAttr get_MethodFlags();
    public CorMethodImpl get_ImplFlags();
}
public class JetBrains.Metadata.Access.MethodSpecProperties : ValueType {
    private MetadataToken myMethod;
    private IBlob myInstantiation;
    public MetadataToken Method { get; }
    public IBlob Instantiation { get; }
    public MethodSpecProperties(MetadataToken method, IBlob instantiation);
    public MetadataToken get_Method();
    public IBlob get_Instantiation();
}
public class JetBrains.Metadata.Access.ParamProperties : ValueType {
    private UInt32 myIndex;
    private MetadataToken myMethod;
    private string myName;
    private CorParamAttr myParamFlags;
    private ElementType myValueElementType;
    private IBlob myValue;
    public string Name { get; }
    public UInt32 Index { get; }
    public MetadataToken Method { get; }
    public CorParamAttr ParamFlags { get; }
    public ElementType ValueElementType { get; }
    public IBlob Value { get; }
    public ParamProperties(string name, UInt32 index, MetadataToken method, CorParamAttr paramFlags, ElementType valueElementType, IBlob value);
    public string get_Name();
    public UInt32 get_Index();
    public MetadataToken get_Method();
    public CorParamAttr get_ParamFlags();
    public ElementType get_ValueElementType();
    public IBlob get_Value();
}
public class JetBrains.Metadata.Access.PInvokeProperties : object {
    private CorPInvokeMap myFlags;
    private MetadataToken myImportScope;
    private string myImportName;
    public CorPInvokeMap Flags { get; }
    public MetadataToken ImportScope { get; }
    public string ImportName { get; }
    public PInvokeProperties(CorPInvokeMap flags, string importName, MetadataToken importScope);
    public CorPInvokeMap get_Flags();
    public MetadataToken get_ImportScope();
    public string get_ImportName();
}
[FlagsAttribute]
public enum JetBrains.Metadata.Access.Prologs : Enum {
    public byte value__;
    public static Prologs VarArg;
    public static Prologs FieldSig;
    public static Prologs LocalSig;
    public static Prologs PropertySig;
    public static Prologs Generic;
    public static Prologs GenricInst;
    public static Prologs HasThis;
    public static Prologs ExplicitThis;
    public static Prologs PermissionSetBlob20;
}
public class JetBrains.Metadata.Access.PropertyProperties : ValueType {
    private MetadataToken myDeclaringType;
    private MetadataToken myGetter;
    private string myName;
    private MetadataToken[] myOtherMethods;
    private CorPropertyAttr myPropertyFlags;
    private MetadataToken mySetter;
    private IBlob mySignature;
    public string Name { get; }
    public MetadataToken DeclaringType { get; }
    public CorPropertyAttr PropertyFlags { get; }
    public IBlob Signature { get; }
    public MetadataToken Getter { get; }
    public MetadataToken Setter { get; }
    public MetadataToken[] OtherMethods { get; }
    public PropertyProperties(string name, MetadataToken declaringType, CorPropertyAttr propertyFlags, IBlob signature, MetadataToken getter, MetadataToken setter, MetadataToken[] otherMethods);
    public string get_Name();
    public MetadataToken get_DeclaringType();
    public CorPropertyAttr get_PropertyFlags();
    public IBlob get_Signature();
    public MetadataToken get_Getter();
    public MetadataToken get_Setter();
    public MetadataToken[] get_OtherMethods();
}
public class JetBrains.Metadata.Access.StateMachineMethodProperties : ValueType {
    private MetadataToken myMoveNextMethod;
    private MetadataToken myKickoffMethod;
    public MetadataToken MoveNextMethod { get; }
    public MetadataToken KickoffMethod { get; }
    public StateMachineMethodProperties(MetadataToken moveNextMethod, MetadataToken kickoffMethod);
    public MetadataToken get_MoveNextMethod();
    public MetadataToken get_KickoffMethod();
}
public enum JetBrains.Metadata.Access.TargetPlatform : Enum {
    public int value__;
    public static TargetPlatform Unknown;
    public static TargetPlatform MSIL;
    public static TargetPlatform X86;
    public static TargetPlatform X64;
}
public static class JetBrains.Metadata.Access.TargetPlatformUtil : object {
    private static string targetPlatformMsil;
    private static string targetPlatformX86;
    private static string targetPlatformX64;
    private static TargetPlatformUtil();
    public static TargetPlatform GetTargetPlatform(CLIFlags cliFlags, MachineId machineId);
    public static TargetPlatform GetTargetPlatform(FileSystemPath path, bool detectNative);
    public static string GetTargetPlatformString(TargetPlatform targetPlatform);
}
public class JetBrains.Metadata.Access.TypeDefProperties : ValueType {
    private MetadataToken myBase;
    private string myTypeName;
    private string myNamespaceName;
    private CorTypeAttr myTypeDefFlags;
    public string FullName { get; }
    public MetadataToken Base { get; }
    public CorTypeAttr TypeDefFlags { get; }
    [NotNullAttribute]
public string NamespaceName { get; }
    [NotNullAttribute]
public string TypeName { get; }
    public TypeDefProperties(MetadataToken base, CorTypeAttr typeDefFlags, string namespaceName, string typeName);
    public string get_FullName();
    public MetadataToken get_Base();
    public CorTypeAttr get_TypeDefFlags();
    public string get_NamespaceName();
    public string get_TypeName();
}
public class JetBrains.Metadata.Access.TypeRefProperties : ValueType {
    private string myNamespaceName;
    private string myTypeName;
    private MetadataToken myResolutionScope;
    public MetadataToken ResolutionScope { get; }
    public string NamespaceName { get; }
    public string TypeName { get; }
    public string FullName { get; }
    public TypeRefProperties(MetadataToken resolutionScope, string namespaceName, string typeName);
    public MetadataToken get_ResolutionScope();
    public string get_NamespaceName();
    public string get_TypeName();
    public string get_FullName();
}
internal abstract class JetBrains.Metadata.Debug.CodeTextWriter.BaseTextAndDebugDataWriter : BaseCodeTextWriter {
    private bool myShowSequencePointInfoInComments;
    [CompilerGeneratedAttribute]
private SequencePointCollection <SequencePoints>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <WriteDebugData>k__BackingField;
    [CompilerGeneratedAttribute]
private IDebugDataCollector <DebugDataCollector>k__BackingField;
    public SequencePointCollection SequencePoints { get; private set; }
    public bool WriteDebugData { get; private set; }
    public IDebugDataCollector DebugDataCollector { get; private set; }
    protected BaseTextAndDebugDataWriter(DebugData debugData, bool showSequencePointInfoInComments, int documentIndex, int startLinesCount);
    private static ICursorPositionStringBuilder CreateCursorPositionStringBuilder(DebugData debugData, int documentIndex, int startLinesCount);
    [CompilerGeneratedAttribute]
public SequencePointCollection get_SequencePoints();
    [CompilerGeneratedAttribute]
private void set_SequencePoints(SequencePointCollection value);
    public virtual void WriteTypeName(string namespaceName, string typeName);
    public virtual void WriteMarker(ICodeMarker marker);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_WriteDebugData();
    [CompilerGeneratedAttribute]
private void set_WriteDebugData(bool value);
    public abstract virtual void WriteTypeName(ClrTypeName clrTypeName);
    [CompilerGeneratedAttribute]
public sealed virtual IDebugDataCollector get_DebugDataCollector();
    [CompilerGeneratedAttribute]
private void set_DebugDataCollector(IDebugDataCollector value);
}
public interface JetBrains.Metadata.Debug.CodeTextWriter.InstructionReference.IInstructionReference {
    [NotNullAttribute]
public IMethodBody MethodBody { get; }
    [NotNullAttribute]
public Instruction Instruction { get; }
    [NotNullAttribute]
public Instruction SequencePointInstruction { get; }
    public abstract virtual IMethodBody get_MethodBody();
    public abstract virtual Instruction get_Instruction();
    public abstract virtual Instruction get_SequencePointInstruction();
}
internal class JetBrains.Metadata.Debug.CodeTextWriter.InstructionReference.InstructionReference : object {
    [CompilerGeneratedAttribute]
private IMethodBody <MethodBody>k__BackingField;
    [CompilerGeneratedAttribute]
private Instruction <Instruction>k__BackingField;
    [CompilerGeneratedAttribute]
private Instruction <SequencePointInstruction>k__BackingField;
    public IMethodBody MethodBody { get; private set; }
    public Instruction Instruction { get; private set; }
    public Instruction SequencePointInstruction { get; private set; }
    public InstructionReference(Instruction instruction, Instruction sequencePointInstruction, IMethodBody methodBody);
    [CompilerGeneratedAttribute]
public sealed virtual IMethodBody get_MethodBody();
    [CompilerGeneratedAttribute]
private void set_MethodBody(IMethodBody value);
    [CompilerGeneratedAttribute]
public sealed virtual Instruction get_Instruction();
    [CompilerGeneratedAttribute]
private void set_Instruction(Instruction value);
    [CompilerGeneratedAttribute]
public sealed virtual Instruction get_SequencePointInstruction();
    [CompilerGeneratedAttribute]
private void set_SequencePointInstruction(Instruction value);
    public virtual bool Equals(object obj);
    public bool Equals(InstructionReference other);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[ExtensionAttribute]
public static class JetBrains.Metadata.Debug.CodeTextWriter.InstructionReference.InstructionReferenceUtil : object {
    [ExtensionAttribute]
public static IInstructionReference CreateInstructionReference(Instruction instruction, IMethodBody methodBody, IInstructionRedirector sequencePointInstructionRedirector);
    [CanBeNullAttribute]
public static IInstructionReference ChooseFirstSequencePoint(IInstructionReference ir1, IInstructionReference ir2);
    public static int GetInstructionIndex(IInstructionReference ir);
    [CanBeNullAttribute]
public static Instruction GetPreviousInstruction(IInstructionReference ir, Func`2<Instruction, bool> condition);
    [CanBeNullAttribute]
public static Instruction GetNextInstruction(IInstructionReference ir, Func`2<Instruction, bool> condition);
    [CanBeNullAttribute]
public static Instruction GetNextInstructionExcept(IInstructionReference ir, Func`2<Instruction, bool> skipCondition);
}
public interface JetBrains.Metadata.Debug.CodeTextWriter.ISequencePointMarker {
    [NotNullAttribute]
public IInstructionReference InstructionReference { get; }
    public SequencePointMarkerType MarkerType { get; }
    public abstract virtual IInstructionReference get_InstructionReference();
    public abstract virtual SequencePointMarkerType get_MarkerType();
}
public interface JetBrains.Metadata.Debug.CodeTextWriter.ITextAndDebugDataWriter {
    public bool WriteDebugData { get; }
    [NotNullAttribute]
public IDebugDataCollector DebugDataCollector { get; }
    public abstract virtual bool get_WriteDebugData();
    public abstract virtual void WriteTypeName(ClrTypeName clrTypeName);
    public abstract virtual IDebugDataCollector get_DebugDataCollector();
}
public class JetBrains.Metadata.Debug.CodeTextWriter.MetadataRenderOrchestrationOptions : object {
    public int IndentSize;
    public bool IndentEmptyLines;
    [CompilerGeneratedAttribute]
private DebugData <DebugData>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShowSequencePointInfoInComments>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DocumentIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StartLinesCount>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ImportFormat>k__BackingField;
    [CompilerGeneratedAttribute]
private IPreRenderOptimizations <PreRenderOptimizations>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OwnNamespace>k__BackingField;
    [CanBeNullAttribute]
public DebugData DebugData { get; public set; }
    public bool ShowSequencePointInfoInComments { get; public set; }
    public int DocumentIndex { get; public set; }
    public int StartLinesCount { get; public set; }
    public string ImportFormat { get; private set; }
    public IPreRenderOptimizations PreRenderOptimizations { get; private set; }
    [CanBeNullAttribute]
public string OwnNamespace { get; private set; }
    public MetadataRenderOrchestrationOptions(string importFormat, IPreRenderOptimizations preRenderOptimizations, string ownNamespace);
    [CompilerGeneratedAttribute]
public DebugData get_DebugData();
    [CompilerGeneratedAttribute]
public void set_DebugData(DebugData value);
    [CompilerGeneratedAttribute]
public bool get_ShowSequencePointInfoInComments();
    [CompilerGeneratedAttribute]
public void set_ShowSequencePointInfoInComments(bool value);
    [CompilerGeneratedAttribute]
public int get_DocumentIndex();
    [CompilerGeneratedAttribute]
public void set_DocumentIndex(int value);
    [CompilerGeneratedAttribute]
public int get_StartLinesCount();
    [CompilerGeneratedAttribute]
public void set_StartLinesCount(int value);
    [CompilerGeneratedAttribute]
public string get_ImportFormat();
    [CompilerGeneratedAttribute]
private void set_ImportFormat(string value);
    [CompilerGeneratedAttribute]
public IPreRenderOptimizations get_PreRenderOptimizations();
    [CompilerGeneratedAttribute]
private void set_PreRenderOptimizations(IPreRenderOptimizations value);
    [CompilerGeneratedAttribute]
public string get_OwnNamespace();
    [CompilerGeneratedAttribute]
private void set_OwnNamespace(string value);
}
public class JetBrains.Metadata.Debug.CodeTextWriter.MetadataRenderOrchestrator`1 : object {
    private SwitchableTextAndDebugDataWriter<TRenderer> mySwitchableTextAndDebugDataWriter;
    private TRenderer myRenderer;
    private MetadataRenderOrchestrationOptions myOptions;
    [CompilerGeneratedAttribute]
private static Func`2<char, bool> CS$<>9__CachedAnonymousMethodDelegate5;
    private MetadataRenderOrchestrator`1(SwitchableTextAndDebugDataWriter<TRenderer> switchableTextAndDebugDataWriter, TRenderer renderer, MetadataRenderOrchestrationOptions options);
    public static MetadataRenderOrchestrator`1<TRenderer> CreateForMetadataView(MetadataRenderOrchestrationOptions options, Func`2<ITextAndDebugDataWriter, TRenderer> rendererFactory);
    public static MetadataRenderOrchestrator`1<TRenderer> CreateForDecompiler(MetadataRenderOrchestrationOptions options, Func`2<ITextAndDebugDataWriter, TRenderer> rendererFactory);
    private static MetadataRenderOrchestrator`1<TRenderer> Create(MetadataRenderOrchestrationOptions options, Func`2<ITextAndDebugDataWriter, TRenderer> rendererFactory, IDebugDataCollector debugDataCollector);
    public string DoRender(Action`1<TRenderer> render);
    public string DoRender(Action`2<TRenderer, IProgressIndicator> render, IProgressIndicator indicator);
    private HashSet`1<IClrTypeName> CollectTypeNames(Action`2<TRenderer, IProgressIndicator> render, IProgressIndicator indicator);
    private OptimizeImportsResult PreRenderOptimizations(ICollection`1<IClrTypeName> typeNames);
    private Tuple`2<string, SequencePointCollection> RenderOptimized(Action`2<TRenderer, IProgressIndicator> render, OptimizeImportsResult imports);
    private void RenderImportedNamespaces(String[] importedNamespaces);
    private void AddToDebugData(SequencePointCollection sequencePoints, String[] importedNamespaces);
    [CompilerGeneratedAttribute]
private static bool <AddToDebugData>b__4(char c);
}
internal class JetBrains.Metadata.Debug.CodeTextWriter.OptimizingTypeNameTextAndDebugDataWriter : BaseTextAndDebugDataWriter {
    private IDictionary`2<string, string> myQualifiedTypeNameToPresentation;
    public OptimizingTypeNameTextAndDebugDataWriter(DebugData debugData, bool showSequencePointInfoInComments, int documentIndex, int startLinesCount, IDictionary`2<string, string> qualifiedTypeNameToPresentation);
    public virtual void WriteTypeName(ClrTypeName clrTypeName);
}
public class JetBrains.Metadata.Debug.CodeTextWriter.SequencePointBeginStatementMarker : object {
    [CompilerGeneratedAttribute]
private IInstructionReference <InstructionReference>k__BackingField;
    public IInstructionReference InstructionReference { get; private set; }
    public SequencePointMarkerType MarkerType { get; }
    public SequencePointBeginStatementMarker(IInstructionReference instructionReference);
    [CompilerGeneratedAttribute]
public sealed virtual IInstructionReference get_InstructionReference();
    [CompilerGeneratedAttribute]
private void set_InstructionReference(IInstructionReference value);
    public sealed virtual SequencePointMarkerType get_MarkerType();
}
internal class JetBrains.Metadata.Debug.CodeTextWriter.SequencePointCollection : object {
    private Dictionary`2<MetadataToken, Dictionary`2<int, CursorPosition>> myStart;
    private Dictionary`2<MetadataToken, List`1<SequencePoint>> mySequencePoints;
    private Dictionary`2<MetadataToken, HashSet`1<int>> mySpIlOffsets;
    private Dictionary`2<MetadataToken, HashSet`1<int>> myDuplicatedSpOffsets;
    private Dictionary`2<MetadataToken, IMethodBody> myMethodBodies;
    private int myDocumentIndex;
    public SequencePointCollection(int documentIndex);
    public IEnumerable`1<SequencePoint> GetSequencePointsForMethod(MetadataToken methodToken);
    public IEnumerable`1<MetadataToken> GetMethods();
    public void AddSequencePointStart(IInstructionReference instructionReference, int cursorLine, int cursorColumn);
    public void AddSequencePointEnd(IInstructionReference instructionReference, int cursorLine, int cursorColumn);
    private void AddSequencePoint(IInstructionReference instructionReference, int startLine, int startColumn, int endLine, int endColumn);
}
public class JetBrains.Metadata.Debug.CodeTextWriter.SequencePointEndStatementMarker : object {
    [CompilerGeneratedAttribute]
private IInstructionReference <InstructionReference>k__BackingField;
    public IInstructionReference InstructionReference { get; private set; }
    public SequencePointMarkerType MarkerType { get; }
    public SequencePointEndStatementMarker(IInstructionReference instructionReference);
    [CompilerGeneratedAttribute]
public sealed virtual IInstructionReference get_InstructionReference();
    [CompilerGeneratedAttribute]
private void set_InstructionReference(IInstructionReference value);
    public sealed virtual SequencePointMarkerType get_MarkerType();
}
public enum JetBrains.Metadata.Debug.CodeTextWriter.SequencePointMarkerType : Enum {
    public int value__;
    public static SequencePointMarkerType BeginStatementMarker;
    public static SequencePointMarkerType EndStatementMarker;
}
internal class JetBrains.Metadata.Debug.CodeTextWriter.SimpleStringBuilder : object {
    private StringBuilder myStringBuilder;
    public sealed virtual void Append(string s);
    public sealed virtual string GetText();
    public sealed virtual int GetCurrentLine();
    public sealed virtual int GetCurrentColumn();
}
internal class JetBrains.Metadata.Debug.CodeTextWriter.TypeNameCollectingTextWriter : object {
    [CompilerGeneratedAttribute]
private HashSet`1<IClrTypeName> <TypeNames>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Indent>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <WriteDebugData>k__BackingField;
    [CompilerGeneratedAttribute]
private IDebugDataCollector <DebugDataCollector>k__BackingField;
    public HashSet`1<IClrTypeName> TypeNames { get; private set; }
    public int Indent { get; public set; }
    public bool WriteDebugData { get; private set; }
    public IDebugDataCollector DebugDataCollector { get; private set; }
    [CompilerGeneratedAttribute]
public HashSet`1<IClrTypeName> get_TypeNames();
    [CompilerGeneratedAttribute]
private void set_TypeNames(HashSet`1<IClrTypeName> value);
    public sealed virtual void WriteTypeName(ClrTypeName clrTypeName);
    public sealed virtual void WriteTypeName(string namespaceName, string typeName);
    [CompilerGeneratedAttribute]
public sealed virtual int get_Indent();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Indent(int value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_WriteDebugData();
    [CompilerGeneratedAttribute]
private void set_WriteDebugData(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual IDebugDataCollector get_DebugDataCollector();
    [CompilerGeneratedAttribute]
private void set_DebugDataCollector(IDebugDataCollector value);
    public sealed virtual void WriteText(string text);
    public sealed virtual void WriteNewLine();
    public sealed virtual void WriteMarker(ICodeMarker marker);
}
public static class JetBrains.Metadata.Debug.CustomDebugInformationKinds : object {
    public static Guid StateMachineHoistedLocalScopes;
    public static Guid DynamicLocalVariables;
    public static Guid DefaultNamespace;
    public static Guid EditAndContinueLocalSlotMap;
    public static Guid EditAndContinueLambdaAndClosureMap;
    public static Guid EmbeddedSource;
    public static Guid SourceLink;
    public static Guid AsyncMethodSteppingInformation;
    public static Guid TupleElementNames;
    private static CustomDebugInformationKinds();
}
public class JetBrains.Metadata.Debug.DebugData : object {
    private int myMaxDocumentIndex;
    private object myMaxDocumentIndexLockObject;
    private object myDocumentsLockObject;
    private Dictionary`2<int, DebugDocument> myDocumentIndexToDocument;
    private Dictionary`2<string, DebugDocument> myDocumentUrlToDocument;
    private Dictionary`2<MetadataToken, DebugMethod> myMethods;
    private int myMaxImportScopeIndex;
    private Dictionary`2<ImportScope, int> myImportScopeIndices;
    private FileSystemPath myRootFolder;
    [CompilerGeneratedAttribute]
private Nullable`1<MetadataToken> <UserEntryPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private ImportScope <ModuleImportScope>k__BackingField;
    [CompilerGeneratedAttribute]
private FileSystemPath <OriginalPdbFilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private static Comparison`1<KeyValuePair`2<ImportScope, int>> CS$<>9__CachedAnonymousMethodDelegatef;
    public Nullable`1<MetadataToken> UserEntryPoint { get; private set; }
    public DebugDocument[] Documents { get; }
    public DebugMethod[] Methods { get; }
    [NotNullAttribute]
public ImportScope ModuleImportScope { get; private set; }
    [CanBeNullAttribute]
public FileSystemPath OriginalPdbFilePath { get; private set; }
    public bool IsEmpty { get; }
    public DebugData(IEnumerable`1<DebugDocument> documents, IEnumerable`1<DebugMethod> methods, Nullable`1<MetadataToken> userEntryPoint, ImportScope moduleImportScope, FileSystemPath rootFolder, FileSystemPath originalPdbFilePath, bool detachMethods);
    [CompilerGeneratedAttribute]
public Nullable`1<MetadataToken> get_UserEntryPoint();
    [CompilerGeneratedAttribute]
private void set_UserEntryPoint(Nullable`1<MetadataToken> value);
    public DebugDocument[] get_Documents();
    public DebugMethod[] get_Methods();
    [CompilerGeneratedAttribute]
public ImportScope get_ModuleImportScope();
    [CompilerGeneratedAttribute]
private void set_ModuleImportScope(ImportScope value);
    [CompilerGeneratedAttribute]
public FileSystemPath get_OriginalPdbFilePath();
    [CompilerGeneratedAttribute]
private void set_OriginalPdbFilePath(FileSystemPath value);
    public bool get_IsEmpty();
    [NotNullAttribute]
public DebugDocument CreateDocument(string url);
    [NotNullAttribute]
private DebugDocument CreateDocument(DebugDocument baseDocument);
    private string GetFullUrl(string url);
    [NotNullAttribute]
public DebugDocument GetOrCreateDocument(string url);
    public DebugDocument GetOrCreateDocument(DebugDocument baseDocument);
    [CanBeNullAttribute]
public DebugDocument TryGetDocument(string url);
    [CanBeNullAttribute]
public DebugDocument TryGetDocument(int index);
    [NotNullAttribute]
public DebugMethod CreateMethod(MetadataToken methodToken, MetadataToken localVariablesSignatureToken, int codeLength, ImportScope importScope, IEnumerable`1<SequencePoint> sequencePoints, MethodCustomDebugInformation methodCustomDebugInformation);
    [CanBeNullAttribute]
public DebugMethod TryGetMethod(MetadataToken methodToken);
    [NotNullAttribute]
public DebugMethod GetMethod(MetadataToken methodToken);
    private void AddDocument(DebugDocument document);
    private void AddMethod(DebugMethod method);
    private int GetNextDocumentIndex();
    private void TestDocumentIndex(int index);
    internal void ProcessImportScope(ImportScope importScope);
    internal int GetImportScopeIndex(ImportScope importScope);
    internal ICollection`1<KeyValuePair`2<ImportScope, int>> GetImportScopesSortedByIndex();
    public static DebugData CreateEmptyDebugData();
    [CompilerGeneratedAttribute]
private static int <GetImportScopesSortedByIndex>b__e(KeyValuePair`2<ImportScope, int> x, KeyValuePair`2<ImportScope, int> y);
}
public class JetBrains.Metadata.Debug.DebugDataCollector : object {
    private DebugData myDebugData;
    public DebugDataCollector(DebugData debugData);
    public sealed virtual void AddMethod(IMethodBody methodBody);
    public sealed virtual void AddLocalVariable(IMethodBodyLocalVariable localVariable, string name, LocalVariableAttributes attributes, TupleElementNamesData tupleElementNames);
    public sealed virtual void AddLocalVariable(IMethodBodyLocalVariable localVariable, string name, LocalVariableAttributes attributes, int scopeStartOffset, int scopeEndOffset, TupleElementNamesData tupleElementNames);
    public sealed virtual void AddStateMachineHoistedLocalScopes(MetadataToken method, StateMachineHoistedLocalScopesData stateMachineHoistedLocalScopes);
    public sealed virtual void AddAsyncMethodSteppingInformation(MetadataToken method, AsyncMethodSteppingInformationData asyncMethodSteppingInformation);
    public sealed virtual void AddKickoffMethod(MetadataToken moveNextMethod, MetadataToken kickoffMethod);
    public sealed virtual void AddStateMachineTypeName(string stateMachineTypeName, MetadataToken kickoffMethod);
}
public class JetBrains.Metadata.Debug.DebugDataCollectorStub : object {
    public sealed virtual void AddMethod(IMethodBody methodBody);
    public sealed virtual void AddLocalVariable(IMethodBodyLocalVariable localVariable, string name, LocalVariableAttributes attributes, TupleElementNamesData tupleElementNames);
    public sealed virtual void AddLocalVariable(IMethodBodyLocalVariable localVariable, string name, LocalVariableAttributes attributes, int scopeStartOffset, int scopeEndOffset, TupleElementNamesData tupleElementNames);
    public sealed virtual void AddStateMachineHoistedLocalScopes(MetadataToken method, StateMachineHoistedLocalScopesData stateMachineHoistedLocalScopes);
    public sealed virtual void AddAsyncMethodSteppingInformation(MetadataToken method, AsyncMethodSteppingInformationData asyncMethodSteppingInformation);
    public sealed virtual void AddKickoffMethod(MetadataToken moveNextMethod, MetadataToken kickoffMethod);
    public sealed virtual void AddStateMachineTypeName(string stateMachineTypeName, MetadataToken kickoffMethod);
}
[ExtensionAttribute]
public static class JetBrains.Metadata.Debug.DebugDataExtensions : object {
    [CompilerGeneratedAttribute]
private static Comparison`1<DebugDocument> CS$<>9__CachedAnonymousMethodDelegate1;
    [CompilerGeneratedAttribute]
private static Comparison`1<DebugMethod> CS$<>9__CachedAnonymousMethodDelegate3;
    [ExtensionAttribute]
public static int SingleDocumentIndex(DebugData debugData);
    [ExtensionAttribute]
public static int SingleDocumentIndex(DebugMethod method);
    [ExtensionAttribute]
public static DebugDocument[] SortedDocuments(DebugData debugData);
    [ExtensionAttribute]
public static DebugMethod[] SortedMethods(DebugData debugData);
    [ExtensionAttribute]
[NotNullAttribute]
public static DebugMethod CreateMethod(DebugData debugData, PdbFunction pdbFunction);
    [ExtensionAttribute]
private static void ProcessScopes(DebugMethod method, PdbScope scope, ImportScope importScope, PdbFunction pdbFunction);
    [NotNullAttribute]
private static DebugLocalVariable CreateLocalVariable(int index, string name, LocalVariableAttributes attributes, MetadataToken localSignatureToken, DebugMethod method, TupleElementNamesData tupleElementNames);
    [ExtensionAttribute]
public static void AddLocalVariable(DebugMethod method, int index, string name, LocalVariableAttributes attributes, MetadataToken localSignatureToken, TupleElementNamesData tupleElementNames);
    [ExtensionAttribute]
internal static void AddLocalVariable(DebugMethod method, int index, string name, LocalVariableAttributes attributes, MetadataToken localSignatureToken, TupleElementNamesData tupleElementNames, int scopeStartOffset, int scopeEndOffset, ImportScope importScope);
    [ExtensionAttribute]
internal static void AddLocalVariables(DebugMethod method, DebugLocalVariable[] localVariables, int scopeStartOffset, int scopeEndOffset, ImportScope importScope);
    [CanBeNullAttribute]
private static DebugLocalVariable TryGetLocalVariable(LocalScope localScope, int variableIndex, int offset);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static DebugLocalVariable TryGetLocalVariable(DebugMethod debugMethod, int variableIndex, int offset);
    [CanBeNullAttribute]
[ExtensionAttribute]
public static string TryGetLocalVariableName(DebugData debugData, MetadataToken methodToken, int variableIndex, int offset);
    [NotNullAttribute]
[ExtensionAttribute]
public static ICollection`1<LocalVariableInLocalScope> GetLocalVariables(DebugData debugData, MetadataToken methodToken, int variableIndex);
    private static void CollectLocalVariables(LocalScope scope, int variableIndex, List`1<LocalVariableInLocalScope> result);
    [ExtensionAttribute]
internal static void CollectLocalScopes(LocalScope localScope, List`1<LocalScope> localScopes);
    [ExtensionAttribute]
[NotNullAttribute]
public static ICollection`1<DebugLocalVariable> GetLocalVariables(DebugData debugData, MetadataToken methodToken);
    private static void CollectLocalVariables(LocalScope scope, List`1<DebugLocalVariable> result);
    [ExtensionAttribute]
[NotNullAttribute]
public static IEnumerable`1<SequencePointInMethod> GetSequencePoints(DebugData debugData, int documentIndex, int line, int column);
    [CanBeNullAttribute]
[ExtensionAttribute]
public static SequencePointInMethod TryGetInnerSequencePoint(DebugData debugData, int documentIndex, int line, int column);
    [ExtensionAttribute]
private static bool Contains(SequencePoint sequencePoint, int line, int column);
    [ExtensionAttribute]
public static SequencePoint ToSequencePoint(PdbSequencePoint sequencePoint, int documentIndex);
    [NotNullAttribute]
[ExtensionAttribute]
public static DebugData CreateDocumentSection(DebugData debugData, int documentIndex, string newDocumentUrl);
    [NotNullAttribute]
[ExtensionAttribute]
private static DebugMethod CreateDetachedDocumentSection(DebugMethod method, int documentIndex, Dictionary`2<int, ImportScope> indexToClonedImportScope);
    [CanBeNullAttribute]
private static ImportScope GetClonedImportScope(ImportScope importScope, DebugData debugData, Dictionary`2<int, ImportScope> indexToClonedImportScope);
    [NotNullAttribute]
[ExtensionAttribute]
private static DebugDocument Clone(DebugDocument debugDocument, string newDocumentUrl);
    [NotNullAttribute]
[ExtensionAttribute]
private static SequencePoint Clone(SequencePoint sequencePoint);
    [NotNullAttribute]
[ExtensionAttribute]
private static DebugLocalVariable[] Clone(ICollection`1<DebugLocalVariable> localVariables);
    [ExtensionAttribute]
[NotNullAttribute]
private static DebugLocalVariable Clone(DebugLocalVariable localVariable);
    [ExtensionAttribute]
[CanBeNullAttribute]
private static MethodCustomDebugInformation Clone(MethodCustomDebugInformation methodCustomDebugInformation);
    [ExtensionAttribute]
[CanBeNullAttribute]
private static StateMachineHoistedLocalScopesData Clone(StateMachineHoistedLocalScopesData stateMachineHoistedLocalScopes);
    [CanBeNullAttribute]
[ExtensionAttribute]
private static AsyncMethodSteppingInformationData Clone(AsyncMethodSteppingInformationData asyncMethodSteppingInformation);
    [CompilerGeneratedAttribute]
private static int <SortedDocuments>b__0(DebugDocument d1, DebugDocument d2);
    [CompilerGeneratedAttribute]
private static int <SortedMethods>b__2(DebugMethod m1, DebugMethod m2);
}
public static class JetBrains.Metadata.Debug.DebugDataLogger : object {
    [StringFormatMethodAttribute("format")]
public static void LogError(string format, Object[] args);
    public static void LogError(string message);
}
[ExtensionAttribute]
public static class JetBrains.Metadata.Debug.DebugDataSerializer : object {
    private static int GuidLength;
    [ExtensionAttribute]
public static void WriteDebugData(DebugData debugData, FileSystemPath serializedDebugDataLocation);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static DebugData ReadDebugData(FileSystemPath serializedDebugDataLocation);
    [NotNullAttribute]
public static Byte[] Serialize(DebugData debugData);
    [NotNullAttribute]
public static DebugData Deserialize(Byte[] bytes);
    public static void WriteDebugData(BinaryWriter writer, DebugData debugData);
    [NotNullAttribute]
public static DebugData ReadDebugData(BinaryReader reader);
    private static void WriteImportScopes(BinaryWriter writer, DebugData debugData);
    private static Dictionary`2<int, ImportScope> ReadImportScopes(BinaryReader reader, ImportScope& moduleImportScope, ICollection`1& orderedImportScopes);
    private static void WriteMethods(BinaryWriter writer, DebugData debugData);
    private static void WriteMethod(BinaryWriter writer, DebugMethod debugMethod);
    private static void ReadMethods(BinaryReader reader, DebugData debugData, Dictionary`2<int, ImportScope> indexToImportScope);
    private static void ReadMethod(BinaryReader reader, DebugData debugData, Dictionary`2<int, ImportScope> indexToImportScope);
    private static LocalScopeProperties ReadLocalScopeProperties(BinaryReader reader);
    private static void WriteDocument(BinaryWriter writer, DebugDocument document);
    [NotNullAttribute]
private static DebugDocument ReadDocument(BinaryReader reader);
    private static void WriteSequencePoint(BinaryWriter writer, SequencePoint sequencePoint);
    [NotNullAttribute]
private static SequencePoint ReadSequencePoint(BinaryReader reader);
    private static void WriteImport(BinaryWriter writer, Import import);
    [NotNullAttribute]
private static Import ReadImport(BinaryReader reader);
    private static void WriteLocalVariable(BinaryWriter writer, DebugLocalVariable variable);
    [NotNullAttribute]
private static DebugLocalVariable ReadLocalVariable(BinaryReader reader);
    private static void WriteTupleElementNamesData(BinaryWriter writer, TupleElementNamesData tupleElementNames);
    [NotNullAttribute]
private static TupleElementNamesData ReadTupleElementNamesData(BinaryReader reader);
    private static void WriteAsyncMethodSteppingInformationData(BinaryWriter writer, AsyncMethodSteppingInformationData asyncMethodSteppingInformation);
    [NotNullAttribute]
private static AsyncMethodSteppingInformationData ReadAsyncMethodSteppingInformationData(BinaryReader reader);
    private static void WriteStateMachineHoistedLocalScopesData(BinaryWriter writer, StateMachineHoistedLocalScopesData stateMachineHoistedLocalScopes);
    [NotNullAttribute]
private static StateMachineHoistedLocalScopesData ReadStateMachineHoistedLocalScopesData(BinaryReader reader);
    private static void WriteStateMachineHoistedLocalScope(BinaryWriter writer, StateMachineHoistedLocalScope stateMachineHoistedLocalScope);
    private static StateMachineHoistedLocalScope ReadStateMachineHoistedLocalScope(BinaryReader reader);
    private static void WriteMethodCustomDebugInformation(BinaryWriter writer, MethodCustomDebugInformation methodCustomDebugInformation);
    [NotNullAttribute]
private static MethodCustomDebugInformation ReadMethodCustomDebugInformation(BinaryReader reader);
    private static void WriteMetadataToken(BinaryWriter writer, MetadataToken token);
    private static MetadataToken ReadMetadataToken(BinaryReader reader);
    private static void WriteNMetadataToken(BinaryWriter writer, Nullable`1<MetadataToken> token);
    [CanBeNullAttribute]
private static Nullable`1<MetadataToken> ReadNMetadataToken(BinaryReader reader);
    private static void WriteGuid(BinaryWriter writer, Guid guid);
    private static Guid ReadGuid(BinaryReader reader);
    private static void WriteFileSystemPath(BinaryWriter writer, FileSystemPath path);
    [NotNullAttribute]
private static FileSystemPath ReadFileSystemPath(BinaryReader reader);
    private static void WriteNString(BinaryWriter writer, string s);
    [CanBeNullAttribute]
private static string ReadNString(BinaryReader reader);
    private static void WriteN(BinaryWriter writer, Action`2<BinaryWriter, T> writeT, T data);
    [CanBeNullAttribute]
private static T ReadN(BinaryReader reader, Func`2<BinaryReader, T> readT);
    private static void WriteArray(BinaryWriter writer, Action`2<BinaryWriter, T> writeElement, ICollection`1<T> array);
    [NotNullAttribute]
private static T[] ReadArray(BinaryReader reader, Func`2<BinaryReader, T> readElement);
    private static void WriteUint(BinaryWriter writer, int value);
    private static int ReadUint(BinaryReader reader);
}
public class JetBrains.Metadata.Debug.DebugDocument : object {
    public static int InvalidDocumentIndex;
    public static int NullDocumentIndex;
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private string <URL>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <DocumentType>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <Language>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <LanguageVendor>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <ChecksumAlgorithmId>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Checksum>k__BackingField;
    public int Index { get; private set; }
    public string URL { get; private set; }
    public Guid DocumentType { get; private set; }
    public Guid Language { get; private set; }
    public Guid LanguageVendor { get; private set; }
    public Guid ChecksumAlgorithmId { get; private set; }
    [CanBeNullAttribute]
public Byte[] Checksum { get; private set; }
    public DebugDocument(int index, string url, Guid documentType, Guid language, Guid languageVendor, Guid checksumAlgorithmId, Byte[] checksum);
    public DebugDocument(int index, string url);
    [CompilerGeneratedAttribute]
public int get_Index();
    [CompilerGeneratedAttribute]
private void set_Index(int value);
    [CompilerGeneratedAttribute]
public string get_URL();
    [CompilerGeneratedAttribute]
private void set_URL(string value);
    [CompilerGeneratedAttribute]
public Guid get_DocumentType();
    [CompilerGeneratedAttribute]
private void set_DocumentType(Guid value);
    [CompilerGeneratedAttribute]
public Guid get_Language();
    [CompilerGeneratedAttribute]
private void set_Language(Guid value);
    [CompilerGeneratedAttribute]
public Guid get_LanguageVendor();
    [CompilerGeneratedAttribute]
private void set_LanguageVendor(Guid value);
    [CompilerGeneratedAttribute]
public Guid get_ChecksumAlgorithmId();
    [CompilerGeneratedAttribute]
private void set_ChecksumAlgorithmId(Guid value);
    [CompilerGeneratedAttribute]
public Byte[] get_Checksum();
    [CompilerGeneratedAttribute]
private void set_Checksum(Byte[] value);
    public virtual string ToString();
}
public static class JetBrains.Metadata.Debug.DebugDumpUtils : object {
    private static Dictionary`2<Guid, string> ourGuidPresentation;
    private static DebugDumpUtils();
    public static string PresentIlOffsetRange(int startOffset, int endOffset);
    [CanBeNullAttribute]
public static string TryPresentGuid(Guid guid);
    public static string PresentGuid(Guid guid);
}
public class JetBrains.Metadata.Debug.DebugLocalVariable : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private MetadataToken <LocalVariablesSignatureToken>k__BackingField;
    [CompilerGeneratedAttribute]
private LocalVariableAttributes <Attributes>k__BackingField;
    [CompilerGeneratedAttribute]
private TupleElementNamesData <TupleElementNames>k__BackingField;
    [CompilerGeneratedAttribute]
private int <IlIndex>k__BackingField;
    public string Name { get; private set; }
    public MetadataToken LocalVariablesSignatureToken { get; private set; }
    public LocalVariableAttributes Attributes { get; private set; }
    [CanBeNullAttribute]
public TupleElementNamesData TupleElementNames { get; private set; }
    public int IlIndex { get; private set; }
    public DebugLocalVariable(int ilIndex, string name, LocalVariableAttributes attributes, MetadataToken localVariablesSignatureToken, TupleElementNamesData tupleElementNames);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public MetadataToken get_LocalVariablesSignatureToken();
    [CompilerGeneratedAttribute]
private void set_LocalVariablesSignatureToken(MetadataToken value);
    [CompilerGeneratedAttribute]
public LocalVariableAttributes get_Attributes();
    [CompilerGeneratedAttribute]
private void set_Attributes(LocalVariableAttributes value);
    [CompilerGeneratedAttribute]
public TupleElementNamesData get_TupleElementNames();
    [CompilerGeneratedAttribute]
private void set_TupleElementNames(TupleElementNamesData value);
    [CompilerGeneratedAttribute]
public int get_IlIndex();
    [CompilerGeneratedAttribute]
private void set_IlIndex(int value);
    public virtual string ToString();
}
public class JetBrains.Metadata.Debug.DebugMethod : object {
    [CanBeNullAttribute]
private DebugData myDebugData;
    private SequencePointComparer mySequencePointComparer;
    private List`1<SequencePoint> mySequencePoints;
    private Dictionary`2<int, List`1<SequencePoint>> myDocumentIndexToSequencePoints;
    private HashSet`1<int> myIlOffsets;
    [CompilerGeneratedAttribute]
private MetadataToken <Token>k__BackingField;
    [CompilerGeneratedAttribute]
private MetadataToken <LocalVariablesSignatureToken>k__BackingField;
    [CompilerGeneratedAttribute]
private LocalScope <RootScope>k__BackingField;
    [CompilerGeneratedAttribute]
private MethodCustomDebugInformation <MethodCustomDebugInformation>k__BackingField;
    public MetadataToken Token { get; private set; }
    public MetadataToken LocalVariablesSignatureToken { get; private set; }
    [NotNullAttribute]
public LocalScope RootScope { get; private set; }
    [CanBeNullAttribute]
internal DebugData DebugData { get; internal set; }
    public bool IsEmpty { get; }
    [NotNullAttribute]
public ICollection`1<SequencePoint> SequencePoints { get; }
    [CanBeNullAttribute]
public StateMachineHoistedLocalScopesData StateMachineHoistedLocalScopes { get; public set; }
    [CanBeNullAttribute]
public AsyncMethodSteppingInformationData AsyncMethodSteppingInformation { get; public set; }
    [CanBeNullAttribute]
public Nullable`1<MetadataToken> KickoffMethod { get; public set; }
    [CanBeNullAttribute]
public string StateMachineTypeName { get; public set; }
    [CanBeNullAttribute]
internal MethodCustomDebugInformation MethodCustomDebugInformation { get; internal set; }
    [NotNullAttribute]
public ICollection`1<int> SequencePointsDocumentIndices { get; }
    public DebugMethod(MetadataToken token, MetadataToken localVariablesSignatureToken, int codeLength, ImportScope importScope, IEnumerable`1<SequencePoint> sequencePoints, MethodCustomDebugInformation methodCustomDebugInformation);
    [CompilerGeneratedAttribute]
public MetadataToken get_Token();
    [CompilerGeneratedAttribute]
private void set_Token(MetadataToken value);
    [CompilerGeneratedAttribute]
public MetadataToken get_LocalVariablesSignatureToken();
    [CompilerGeneratedAttribute]
private void set_LocalVariablesSignatureToken(MetadataToken value);
    [CompilerGeneratedAttribute]
public LocalScope get_RootScope();
    [CompilerGeneratedAttribute]
private void set_RootScope(LocalScope value);
    internal void SetImportScope(ImportScope importScope);
    private static void SetImportScope(LocalScope localScope, ImportScope importScope);
    internal DebugData get_DebugData();
    internal void set_DebugData(DebugData value);
    internal DebugMethod Detach();
    private void ProcessImportScopes(LocalScope localScope);
    public bool get_IsEmpty();
    public ICollection`1<SequencePoint> get_SequencePoints();
    public StateMachineHoistedLocalScopesData get_StateMachineHoistedLocalScopes();
    public void set_StateMachineHoistedLocalScopes(StateMachineHoistedLocalScopesData value);
    public AsyncMethodSteppingInformationData get_AsyncMethodSteppingInformation();
    public void set_AsyncMethodSteppingInformation(AsyncMethodSteppingInformationData value);
    public Nullable`1<MetadataToken> get_KickoffMethod();
    public void set_KickoffMethod(Nullable`1<MetadataToken> value);
    public string get_StateMachineTypeName();
    public void set_StateMachineTypeName(string value);
    [CompilerGeneratedAttribute]
internal MethodCustomDebugInformation get_MethodCustomDebugInformation();
    [CompilerGeneratedAttribute]
internal void set_MethodCustomDebugInformation(MethodCustomDebugInformation value);
    [NotNullAttribute]
public IEnumerable`1<SequencePoint> GetSequencePointsForDocument(int documentIndex);
    public ICollection`1<int> get_SequencePointsDocumentIndices();
    public bool HasSequencePointsForSource(int documentIndex);
    public void AddSequencePoint(SequencePoint sequencePoint);
    [CanBeNullAttribute]
private SequencePoint GetSequencePointByIlOffset(int ilOffset);
    public virtual string ToString();
}
public static class JetBrains.Metadata.Debug.DocumentTypes : object {
    public static Guid Text;
    public static Guid MC;
    private static DocumentTypes();
}
public class JetBrains.Metadata.Debug.ExtendedDebugData : object {
    public static IEqualityComparer`1<ExtendedDebugData> EqualityComparer;
    [CompilerGeneratedAttribute]
private DebugData <DebugData>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <Mvid>k__BackingField;
    [CompilerGeneratedAttribute]
private FileSystemPath <AssemblyPath>k__BackingField;
    [NotNullAttribute]
public DebugData DebugData { get; private set; }
    public Guid Mvid { get; private set; }
    public FileSystemPath AssemblyPath { get; private set; }
    private ExtendedDebugData(DebugData debugData, Guid mvid, FileSystemPath assemblyPath);
    private static ExtendedDebugData();
    [CompilerGeneratedAttribute]
public DebugData get_DebugData();
    [CompilerGeneratedAttribute]
private void set_DebugData(DebugData value);
    [CompilerGeneratedAttribute]
public Guid get_Mvid();
    [CompilerGeneratedAttribute]
private void set_Mvid(Guid value);
    [CompilerGeneratedAttribute]
public FileSystemPath get_AssemblyPath();
    [CompilerGeneratedAttribute]
private void set_AssemblyPath(FileSystemPath value);
    public static ExtendedDebugData Create(DebugData debugData, Guid mvid, FileSystemPath assemblyPath);
    public static ExtendedDebugData Create(DebugData debugData, string mvid, FileSystemPath assemblyPath);
    public static ExtendedDebugData Create(DebugData debugData, Guid mvid, string assemblyPath);
    public static ExtendedDebugData Create(DebugData debugData, string mvid, string assemblyPath);
}
public static class JetBrains.Metadata.Debug.HashAlgorithms : object {
    public static Guid Sha1;
    public static Guid Sha256;
    public static Guid Md5;
    private static HashAlgorithms();
}
public interface JetBrains.Metadata.Debug.IDebugDataCollector {
    public abstract virtual void AddMethod(IMethodBody methodBody);
    public abstract virtual void AddLocalVariable(IMethodBodyLocalVariable localVariable, string name, LocalVariableAttributes attributes, TupleElementNamesData tupleElementNames);
    public abstract virtual void AddLocalVariable(IMethodBodyLocalVariable localVariable, string name, LocalVariableAttributes attributes, int scopeStartOffset, int scopeEndOffset, TupleElementNamesData tupleElementNames);
    public abstract virtual void AddStateMachineHoistedLocalScopes(MetadataToken method, StateMachineHoistedLocalScopesData stateMachineHoistedLocalScopes);
    public abstract virtual void AddAsyncMethodSteppingInformation(MetadataToken method, AsyncMethodSteppingInformationData asyncMethodSteppingInformation);
    public abstract virtual void AddKickoffMethod(MetadataToken moveNextMethod, MetadataToken kickoffMethod);
    public abstract virtual void AddStateMachineTypeName(string stateMachineTypeName, MetadataToken kickoffMethod);
}
public class JetBrains.Metadata.Debug.Import : object {
    [CompilerGeneratedAttribute]
private ImportDefinitionKind <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Alias>k__BackingField;
    [CompilerGeneratedAttribute]
private MetadataToken <TargetAssembly>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetNamespace>k__BackingField;
    [CompilerGeneratedAttribute]
private MetadataToken <TargetType>k__BackingField;
    public ImportDefinitionKind Kind { get; private set; }
    [CanBeNullAttribute]
public string Alias { get; private set; }
    public MetadataToken TargetAssembly { get; private set; }
    [CanBeNullAttribute]
public string TargetNamespace { get; private set; }
    public MetadataToken TargetType { get; private set; }
    public Import(ImportDefinitionKind kind, string alias, MetadataToken targetAssembly, string targetNamespace, MetadataToken targetType);
    [CompilerGeneratedAttribute]
public ImportDefinitionKind get_Kind();
    [CompilerGeneratedAttribute]
private void set_Kind(ImportDefinitionKind value);
    [CompilerGeneratedAttribute]
public string get_Alias();
    [CompilerGeneratedAttribute]
private void set_Alias(string value);
    [CompilerGeneratedAttribute]
public MetadataToken get_TargetAssembly();
    [CompilerGeneratedAttribute]
private void set_TargetAssembly(MetadataToken value);
    [CompilerGeneratedAttribute]
public string get_TargetNamespace();
    [CompilerGeneratedAttribute]
private void set_TargetNamespace(string value);
    [CompilerGeneratedAttribute]
public MetadataToken get_TargetType();
    [CompilerGeneratedAttribute]
private void set_TargetType(MetadataToken value);
    public static Import CreateImportNamespace(string namespace);
    public virtual string ToString();
}
public class JetBrains.Metadata.Debug.ImportScope : object {
    [CanBeNullAttribute]
private ImportScope myParent;
    [CompilerGeneratedAttribute]
private IList`1<Import> <Imports>k__BackingField;
    [CanBeNullAttribute]
public ImportScope Parent { get; internal set; }
    [NotNullAttribute]
public IList`1<Import> Imports { get; private set; }
    public ImportScope(ImportScope parent, IList`1<Import> imports);
    public ImportScope get_Parent();
    internal void set_Parent(ImportScope value);
    [CompilerGeneratedAttribute]
public IList`1<Import> get_Imports();
    [CompilerGeneratedAttribute]
private void set_Imports(IList`1<Import> value);
}
public static class JetBrains.Metadata.Debug.Languages : object {
    public static Guid CSharp;
    public static Guid IL;
    public static Guid VB;
    public static Guid FSharp;
    private static Languages();
    public static bool IsKnownLanguage(Guid language);
}
public static class JetBrains.Metadata.Debug.LanguageVendors : object {
    public static Guid Microsoft;
    private static LanguageVendors();
}
public class JetBrains.Metadata.Debug.LocalScope : object {
    private ImportScope myImportScope;
    private LinkedList`1<LocalScope> mySortedChildScopes;
    private Dictionary`2<int, DebugLocalVariable> myLocalVariables;
    private HashSet`1<int> myLocalVariablesForbiddenIndices;
    [CompilerGeneratedAttribute]
private DebugMethod <Method>k__BackingField;
    [CompilerGeneratedAttribute]
private LocalScope <Parent>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StartOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EndOffset>k__BackingField;
    [NotNullAttribute]
public DebugMethod Method { get; private set; }
    [CanBeNullAttribute]
public LocalScope Parent { get; private set; }
    public int StartOffset { get; private set; }
    public int EndOffset { get; private set; }
    public IEnumerable`1<LocalScope> SortedChildScopes { get; }
    [NotNullAttribute]
public ICollection`1<DebugLocalVariable> LocalVariables { get; }
    [CanBeNullAttribute]
public ImportScope ImportScope { get; internal set; }
    public bool IsRoot { get; }
    protected LocalScope(DebugMethod method, LocalScope parent, ImportScope importScope, int startOffset, int endOffset, IEnumerable`1<LocalScope> sortedChildren);
    [CompilerGeneratedAttribute]
public DebugMethod get_Method();
    [CompilerGeneratedAttribute]
private void set_Method(DebugMethod value);
    [CompilerGeneratedAttribute]
public LocalScope get_Parent();
    [CompilerGeneratedAttribute]
private void set_Parent(LocalScope value);
    [CompilerGeneratedAttribute]
public int get_StartOffset();
    [CompilerGeneratedAttribute]
private void set_StartOffset(int value);
    [CompilerGeneratedAttribute]
public int get_EndOffset();
    [CompilerGeneratedAttribute]
private void set_EndOffset(int value);
    public IEnumerable`1<LocalScope> get_SortedChildScopes();
    public ICollection`1<DebugLocalVariable> get_LocalVariables();
    [CanBeNullAttribute]
internal DebugLocalVariable TryGetLocalVariable(int variableIndex);
    [CanBeNullAttribute]
private DebugLocalVariable TryGetLocalVariableFromParentScopes(int variableIndex);
    public ImportScope get_ImportScope();
    internal void set_ImportScope(ImportScope value);
    public bool get_IsRoot();
    public bool TryAddLocalVariable(DebugLocalVariable localVariable);
    public void GetOrCreateInnerScopes(int startOffset, int endOffset, ICollection`1<LocalScope> scopes, ImportScope importScope);
    [NotNullAttribute]
public static LocalScope CreateRootScope(DebugMethod method, int startOffset, int endOffset, ImportScope importScope);
    private bool LocalVariableIndexIsForbidden(int index);
    private void PropagateForbiddenIndicesToParent();
    private void SetNewForbiddenIndexAndPropagateItToParent(int index);
    public virtual string ToString();
}
public class JetBrains.Metadata.Debug.LocalVariableInLocalScope : object {
    [CompilerGeneratedAttribute]
private DebugLocalVariable <LocalVariable>k__BackingField;
    [CompilerGeneratedAttribute]
private LocalScope <Scope>k__BackingField;
    [NotNullAttribute]
public DebugLocalVariable LocalVariable { get; private set; }
    [NotNullAttribute]
public LocalScope Scope { get; private set; }
    public LocalVariableInLocalScope(DebugLocalVariable localVariable, LocalScope scope);
    [CompilerGeneratedAttribute]
public DebugLocalVariable get_LocalVariable();
    [CompilerGeneratedAttribute]
private void set_LocalVariable(DebugLocalVariable value);
    [CompilerGeneratedAttribute]
public LocalScope get_Scope();
    [CompilerGeneratedAttribute]
private void set_Scope(LocalScope value);
}
public class JetBrains.Metadata.Debug.MethodCustomDebugInformation : object {
    [CompilerGeneratedAttribute]
private StateMachineHoistedLocalScopesData <StateMachineHoistedLocalScopes>k__BackingField;
    [CompilerGeneratedAttribute]
private AsyncMethodSteppingInformationData <AsyncMethodSteppingInformation>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<MetadataToken> <KickoffMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private string <StateMachineTypeName>k__BackingField;
    [CanBeNullAttribute]
public StateMachineHoistedLocalScopesData StateMachineHoistedLocalScopes { get; public set; }
    [CanBeNullAttribute]
public AsyncMethodSteppingInformationData AsyncMethodSteppingInformation { get; public set; }
    [CanBeNullAttribute]
public Nullable`1<MetadataToken> KickoffMethod { get; public set; }
    [CanBeNullAttribute]
public string StateMachineTypeName { get; public set; }
    [CompilerGeneratedAttribute]
public StateMachineHoistedLocalScopesData get_StateMachineHoistedLocalScopes();
    [CompilerGeneratedAttribute]
public void set_StateMachineHoistedLocalScopes(StateMachineHoistedLocalScopesData value);
    [CompilerGeneratedAttribute]
public AsyncMethodSteppingInformationData get_AsyncMethodSteppingInformation();
    [CompilerGeneratedAttribute]
public void set_AsyncMethodSteppingInformation(AsyncMethodSteppingInformationData value);
    [CompilerGeneratedAttribute]
public Nullable`1<MetadataToken> get_KickoffMethod();
    [CompilerGeneratedAttribute]
public void set_KickoffMethod(Nullable`1<MetadataToken> value);
    [CompilerGeneratedAttribute]
public string get_StateMachineTypeName();
    [CompilerGeneratedAttribute]
public void set_StateMachineTypeName(string value);
}
public class JetBrains.Metadata.Debug.Pdb.Common.PackedBitSet : object {
    private static int MaxDataItems;
    private ChunkList`1<UInt32> myData;
    private int mySize;
    public PackedBitSet(IBinaryReader reader);
    public PackedBitSet(int num);
    public PackedBitSet(IEnumerable`1<int> indices, int maxIndex);
    public PackedBitSet(IList`1<int> sortedIndices);
    public void Write(BinaryWriter writer);
    private void SetBitAt(int index);
    public bool IsSet(int index);
    private static UInt32 GetBitMask(int index);
    public bool IsEmpty();
}
public class JetBrains.Metadata.Debug.Pdb.Common.PdbException : Exception {
    public PdbException(string message);
}
public class JetBrains.Metadata.Debug.Pdb.Common.PdbStream : ValueType {
    private UInt32[] myBlocks;
    private UInt32 mySize;
    public UInt32 Size { get; }
    public UInt32[] Blocks { get; }
    public PdbStream(UInt32 size, UInt32[] blocks);
    public UInt32 get_Size();
    public UInt32[] get_Blocks();
}
public class JetBrains.Metadata.Debug.Pdb.Common.PdbStreamInfo : ValueType {
    private UInt32 mySize;
    public UInt32 Size { get; }
    public PdbStreamInfo(BinaryReader reader);
    public UInt32 get_Size();
}
internal class JetBrains.Metadata.Debug.Pdb.Common.PdbSubStream : Stream {
    private UInt32[] myBlocks;
    private UInt32 myBlockSize;
    private long mySize;
    private Stream myUnderlayStream;
    private long myPosition;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public PdbSubStream(Stream underlayStream, UInt32[] blocks, UInt32 blockSize, long size);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Flush();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Write(Byte[] buffer, int offset, int count);
}
internal enum JetBrains.Metadata.Debug.Pdb.CustomDebugInfoKind : Enum {
    public byte value__;
    public static CustomDebugInfoKind UsingGroups;
    public static CustomDebugInfoKind ForwardMethodInfo;
    public static CustomDebugInfoKind ForwardModuleInfo;
    public static CustomDebugInfoKind StateMachineHoistedLocalScopes;
    public static CustomDebugInfoKind StateMachineTypeName;
    public static CustomDebugInfoKind DynamicLocals;
    public static CustomDebugInfoKind EditAndContinueLocalSlotMap;
    public static CustomDebugInfoKind EditAndContinueLambdaMap;
    public static CustomDebugInfoKind TupleElementNames;
}
internal class JetBrains.Metadata.Debug.Pdb.CvStruct.AttrSlotSym : ValueType {
    public UInt32 SlotIndex;
    public UInt32 Typind;
    public UInt32 OffCod;
    public ushort SegCod;
    public ushort Flags;
    public string Name;
    public static AttrSlotSym ReadFromStream(IBinaryReader moduleStream);
}
internal class JetBrains.Metadata.Debug.Pdb.CvStruct.BlockSym32 : ValueType {
    public UInt32 Parent;
    public UInt32 End;
    public UInt32 Len;
    public UInt32 Off;
    public ushort Seg;
    public string Name;
    public static BlockSym32 ReadFromStream(IBinaryReader moduleStream);
}
internal class JetBrains.Metadata.Debug.Pdb.CvStruct.CV_Column : ValueType {
    public ushort OffColumnStart;
    public ushort OffColumnEnd;
    public static CV_Column ReadFromStream(IBinaryReader moduleStream);
}
internal class JetBrains.Metadata.Debug.Pdb.CvStruct.CV_FileCheckSum : ValueType {
    public int Name;
    public byte Len;
    public byte Type;
    public static CV_FileCheckSum ReadFromStream(IBinaryReader moduleStream);
}
internal class JetBrains.Metadata.Debug.Pdb.CvStruct.CV_Line : ValueType {
    public UInt32 Offset;
    public UInt32 Flags;
    public UInt32 LineBegin { get; }
    public UInt32 Delta { get; }
    public UInt32 LineEnd { get; }
    public bool Statement { get; }
    public UInt32 get_LineBegin();
    public UInt32 get_Delta();
    public UInt32 get_LineEnd();
    public bool get_Statement();
    public static CV_Line ReadFromStream(IBinaryReader moduleStream);
}
[FlagsAttribute]
internal enum JetBrains.Metadata.Debug.Pdb.CvStruct.CV_Line_Flags : Enum {
    public UInt32 value__;
    public static CV_Line_Flags LinenumStart;
    public static CV_Line_Flags DeltaLineEnd;
    public static CV_Line_Flags FStatement;
}
internal class JetBrains.Metadata.Debug.Pdb.CvStruct.CV_LineSection : ValueType {
    public UInt32 Off;
    public ushort Sec;
    public ushort Flags;
    public UInt32 Cod;
    public static CV_LineSection ReadFromStream(IBinaryReader moduleStream);
}
internal class JetBrains.Metadata.Debug.Pdb.CvStruct.CV_SourceFile : ValueType {
    public UInt32 Index;
    public UInt32 Count;
    public UInt32 Linsiz;
    public static CV_SourceFile ReadFromStream(IBinaryReader moduleStream);
}
internal class JetBrains.Metadata.Debug.Pdb.CvStruct.DatasSym32 : ValueType {
    internal UInt32 Typind;
    internal UInt32 Off;
    internal ushort Seg;
    internal string Name;
    public static DatasSym32 ReadFromStream(IBinaryReader moduleStream);
}
internal class JetBrains.Metadata.Debug.Pdb.CvStruct.FrameProcSym : ValueType {
    public UInt32 CbFrame;
    public UInt32 CbPad;
    public UInt32 OffPad;
    public UInt32 CbSaveRegs;
    public UInt32 OffExHdlr;
    public ushort SecExHdlr;
    public UInt32 Flags;
    public static FrameProcSym ReadFromStream(IBinaryReader moduleStream);
}
internal class JetBrains.Metadata.Debug.Pdb.CvStruct.LabelSym32 : ValueType {
    internal UInt32 Off;
    internal ushort Seg;
    internal byte Flags;
    internal string Name;
    public static LabelSym32 ReadFromStream(IBinaryReader moduleStream);
}
internal class JetBrains.Metadata.Debug.Pdb.CvStruct.ManProcSym : ValueType {
    public UInt32 Parent;
    public UInt32 End;
    public UInt32 Next;
    public UInt32 Len;
    public UInt32 DbgStart;
    public UInt32 DbgEnd;
    public MetadataToken Token;
    public UInt32 Off;
    public ushort Seg;
    public byte Flags;
    public ushort RetReg;
    public string Name;
    public static ManProcSym ReadFromStream(IBinaryReader moduleStream);
}
public class JetBrains.Metadata.Debug.Pdb.CvStruct.PdbConstant : ValueType {
    public string Name;
    public MetadataToken Token;
    public object Value;
    public static PdbConstant ReadFromStream(IBinaryReader moduleStream);
}
internal class JetBrains.Metadata.Debug.Pdb.CvStruct.ProcSym32 : ValueType {
    internal UInt32 Parent;
    internal UInt32 End;
    internal UInt32 Next;
    internal UInt32 Len;
    internal UInt32 DbgStart;
    internal UInt32 DbgEnd;
    internal UInt32 Typind;
    internal UInt32 Off;
    internal ushort Seg;
    internal byte Flags;
    internal string Name;
    public static ProcSym32 ReadFromStream(IBinaryReader moduleStream);
}
internal class JetBrains.Metadata.Debug.Pdb.CvStruct.ThunkSym32 : ValueType {
    public UInt32 Parent;
    public UInt32 End;
    public UInt32 Next;
    public UInt32 Off;
    public ushort Seg;
    public ushort Len;
    public byte Ord;
    public string Name;
    public static ThunkSym32 ReadFromStream(IBinaryReader moduleStream);
}
public class JetBrains.Metadata.Debug.Pdb.Dbi.DbiDbgHeader : object {
    public static int HeaderSize;
    [CompilerGeneratedAttribute]
private ushort <Fpo>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <Exception>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <Fixup>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <OmapToSrc>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <OmapFromSrc>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <SectionHeader>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <TokenRidMap>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <Xdata>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <Pdata>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <NewFpo>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <SectionHeaderOrigin>k__BackingField;
    public ushort Fpo { get; private set; }
    public ushort Exception { get; private set; }
    public ushort Fixup { get; private set; }
    public ushort OmapToSrc { get; private set; }
    public ushort OmapFromSrc { get; private set; }
    public ushort SectionHeader { get; private set; }
    public ushort TokenRidMap { get; private set; }
    public ushort Xdata { get; private set; }
    public ushort Pdata { get; private set; }
    public ushort NewFpo { get; private set; }
    public ushort SectionHeaderOrigin { get; private set; }
    public DbiDbgHeader(IBinaryReader reader);
    public DbiDbgHeader(ushort fpo, ushort exception, ushort fixup, ushort omapToSrc, ushort omapFromSrc, ushort sectionHeader, ushort tokenRidMap, ushort xData, ushort pData, ushort newFpo, ushort sectionHeaderOrigin);
    internal void Write(BinaryWriter writer);
    [CompilerGeneratedAttribute]
public ushort get_Fpo();
    [CompilerGeneratedAttribute]
private void set_Fpo(ushort value);
    [CompilerGeneratedAttribute]
public ushort get_Exception();
    [CompilerGeneratedAttribute]
private void set_Exception(ushort value);
    [CompilerGeneratedAttribute]
public ushort get_Fixup();
    [CompilerGeneratedAttribute]
private void set_Fixup(ushort value);
    [CompilerGeneratedAttribute]
public ushort get_OmapToSrc();
    [CompilerGeneratedAttribute]
private void set_OmapToSrc(ushort value);
    [CompilerGeneratedAttribute]
public ushort get_OmapFromSrc();
    [CompilerGeneratedAttribute]
private void set_OmapFromSrc(ushort value);
    [CompilerGeneratedAttribute]
public ushort get_SectionHeader();
    [CompilerGeneratedAttribute]
private void set_SectionHeader(ushort value);
    [CompilerGeneratedAttribute]
public ushort get_TokenRidMap();
    [CompilerGeneratedAttribute]
private void set_TokenRidMap(ushort value);
    [CompilerGeneratedAttribute]
public ushort get_Xdata();
    [CompilerGeneratedAttribute]
private void set_Xdata(ushort value);
    [CompilerGeneratedAttribute]
public ushort get_Pdata();
    [CompilerGeneratedAttribute]
private void set_Pdata(ushort value);
    [CompilerGeneratedAttribute]
public ushort get_NewFpo();
    [CompilerGeneratedAttribute]
private void set_NewFpo(ushort value);
    [CompilerGeneratedAttribute]
public ushort get_SectionHeaderOrigin();
    [CompilerGeneratedAttribute]
private void set_SectionHeaderOrigin(ushort value);
}
public class JetBrains.Metadata.Debug.Pdb.Dbi.DbiFileInfo : object {
    private OneToListMap`2<DbiModuleInfo, string> myFileNames;
    private JetReadOnlyList`1<DbiModuleInfo> myModules;
    private bool myFileInfoSizeUndefined;
    private int myFileInfoSize;
    private Dictionary`2<string, int> myFileNameToOffset;
    private List`1<string> myNameTable;
    [CompilerGeneratedAttribute]
private static Func`2<DbiModuleInfo, int> CS$<>9__CachedAnonymousMethodDelegate1;
    [CompilerGeneratedAttribute]
private static Func`2<DbiModuleInfo, int> CS$<>9__CachedAnonymousMethodDelegate5;
    [CompilerGeneratedAttribute]
private static Func`2<DbiModuleInfo, int> CS$<>9__CachedAnonymousMethodDelegate7;
    public OneToListMap`2<DbiModuleInfo, string> FileNames { get; }
    public DbiFileInfo(IBinaryReader reader, JetReadOnlyList`1<DbiModuleInfo> modules);
    public DbiFileInfo(JetReadOnlyList`1<DbiModuleInfo> modules, OneToListMap`2<DbiModuleInfo, string> fileNames);
    private void CreateNameTableAndCalculateSize();
    internal void Write(BinaryWriter writer);
    internal int GetFileInfoSize();
    public OneToListMap`2<DbiModuleInfo, string> get_FileNames();
    [CompilerGeneratedAttribute]
private static int <.ctor>b__0(DbiModuleInfo module);
    [CompilerGeneratedAttribute]
private void <.ctor>b__2(DbiModuleInfo module);
    [CompilerGeneratedAttribute]
private static int <CreateNameTableAndCalculateSize>b__4(DbiModuleInfo module);
    [CompilerGeneratedAttribute]
private static int <Write>b__6(DbiModuleInfo module);
}
public class JetBrains.Metadata.Debug.Pdb.Dbi.DbiHeader : object {
    public static int HeaderSize;
    private static int DefaultDbiSignature;
    private static int DefaultHeaderVersion;
    private static int DefaultPdbAge;
    private static int DefaultMachine;
    [CompilerGeneratedAttribute]
private int <DbiSignature>k__BackingField;
    [CompilerGeneratedAttribute]
private int <HeaderVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PdbAge>k__BackingField;
    [CompilerGeneratedAttribute]
private short <GlobalSymbolInfoStreamIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private short <PublicSymbolInfoStreamIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private short <SymbolRecordStreamIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <VersionMajorMinor>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <BuildMajor>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <BuildMinor>k__BackingField;
    [CompilerGeneratedAttribute]
private int <GpModuleInformationsSectionSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SectionContributionSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SectionMapSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <FileInfoSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TsMapSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MfcIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DbiDbgHeaderSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EcInfoSize>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <Flags>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <Machine>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Reserved>k__BackingField;
    public int DbiSignature { get; private set; }
    public int HeaderVersion { get; private set; }
    public int PdbAge { get; private set; }
    public short GlobalSymbolInfoStreamIndex { get; private set; }
    public short PublicSymbolInfoStreamIndex { get; private set; }
    public short SymbolRecordStreamIndex { get; private set; }
    public ushort VersionMajorMinor { get; private set; }
    public ushort BuildMajor { get; private set; }
    public ushort BuildMinor { get; private set; }
    public int GpModuleInformationsSectionSize { get; private set; }
    public int SectionContributionSize { get; private set; }
    public int SectionMapSize { get; private set; }
    public int FileInfoSize { get; private set; }
    public int TsMapSize { get; private set; }
    public int MfcIndex { get; private set; }
    public int DbiDbgHeaderSize { get; private set; }
    public int EcInfoSize { get; private set; }
    public ushort Flags { get; private set; }
    public ushort Machine { get; private set; }
    public int Reserved { get; private set; }
    public DbiHeader(IBinaryReader reader);
    public DbiHeader(ushort versionMajorMinor, ushort versionBuildNumber, short globalSymbolInfoStreamIndex, short publicSymbolInfoStreamIndex, short symbolRecordStreamIndex, int gpModuleInformationsSectionSize, int sectionContributionSize, int sectionMapSize, int fileInfoSize, int ecInfoSize);
    internal void Write(BinaryWriter writer);
    [CompilerGeneratedAttribute]
public int get_DbiSignature();
    [CompilerGeneratedAttribute]
private void set_DbiSignature(int value);
    [CompilerGeneratedAttribute]
public int get_HeaderVersion();
    [CompilerGeneratedAttribute]
private void set_HeaderVersion(int value);
    [CompilerGeneratedAttribute]
public int get_PdbAge();
    [CompilerGeneratedAttribute]
private void set_PdbAge(int value);
    [CompilerGeneratedAttribute]
public short get_GlobalSymbolInfoStreamIndex();
    [CompilerGeneratedAttribute]
private void set_GlobalSymbolInfoStreamIndex(short value);
    [CompilerGeneratedAttribute]
public short get_PublicSymbolInfoStreamIndex();
    [CompilerGeneratedAttribute]
private void set_PublicSymbolInfoStreamIndex(short value);
    [CompilerGeneratedAttribute]
public short get_SymbolRecordStreamIndex();
    [CompilerGeneratedAttribute]
private void set_SymbolRecordStreamIndex(short value);
    [CompilerGeneratedAttribute]
public ushort get_VersionMajorMinor();
    [CompilerGeneratedAttribute]
private void set_VersionMajorMinor(ushort value);
    [CompilerGeneratedAttribute]
public ushort get_BuildMajor();
    [CompilerGeneratedAttribute]
private void set_BuildMajor(ushort value);
    [CompilerGeneratedAttribute]
public ushort get_BuildMinor();
    [CompilerGeneratedAttribute]
private void set_BuildMinor(ushort value);
    [CompilerGeneratedAttribute]
public int get_GpModuleInformationsSectionSize();
    [CompilerGeneratedAttribute]
private void set_GpModuleInformationsSectionSize(int value);
    [CompilerGeneratedAttribute]
public int get_SectionContributionSize();
    [CompilerGeneratedAttribute]
private void set_SectionContributionSize(int value);
    [CompilerGeneratedAttribute]
public int get_SectionMapSize();
    [CompilerGeneratedAttribute]
private void set_SectionMapSize(int value);
    [CompilerGeneratedAttribute]
public int get_FileInfoSize();
    [CompilerGeneratedAttribute]
private void set_FileInfoSize(int value);
    [CompilerGeneratedAttribute]
public int get_TsMapSize();
    [CompilerGeneratedAttribute]
private void set_TsMapSize(int value);
    [CompilerGeneratedAttribute]
public int get_MfcIndex();
    [CompilerGeneratedAttribute]
private void set_MfcIndex(int value);
    [CompilerGeneratedAttribute]
public int get_DbiDbgHeaderSize();
    [CompilerGeneratedAttribute]
private void set_DbiDbgHeaderSize(int value);
    [CompilerGeneratedAttribute]
public int get_EcInfoSize();
    [CompilerGeneratedAttribute]
private void set_EcInfoSize(int value);
    [CompilerGeneratedAttribute]
public ushort get_Flags();
    [CompilerGeneratedAttribute]
private void set_Flags(ushort value);
    [CompilerGeneratedAttribute]
public ushort get_Machine();
    [CompilerGeneratedAttribute]
private void set_Machine(ushort value);
    [CompilerGeneratedAttribute]
public int get_Reserved();
    [CompilerGeneratedAttribute]
private void set_Reserved(int value);
}
[DebuggerDisplayAttribute("{ModuleName} {ObjectName}")]
public class JetBrains.Metadata.Debug.Pdb.Dbi.DbiModuleInfo : object {
    private static int mySizeWithoutStringsAndAlign;
    private int mySizeWithoutAlign;
    [CompilerGeneratedAttribute]
private int <Opened>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <Flags>k__BackingField;
    [CompilerGeneratedAttribute]
private short <StreamIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CbSyms>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CbOldLines>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CbLines>k__BackingField;
    [CompilerGeneratedAttribute]
private short <FilesCount>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Offsets>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NiSource>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NiCompiler>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ModuleName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ObjectName>k__BackingField;
    [CompilerGeneratedAttribute]
private DbiSectionContribution <SectionContribution>k__BackingField;
    public int Opened { get; private set; }
    public ushort Flags { get; private set; }
    public short StreamIndex { get; private set; }
    public int CbSyms { get; private set; }
    public int CbOldLines { get; private set; }
    public int CbLines { get; private set; }
    public short FilesCount { get; private set; }
    public UInt32 Offsets { get; private set; }
    public int NiSource { get; private set; }
    public int NiCompiler { get; private set; }
    public string ModuleName { get; private set; }
    public string ObjectName { get; private set; }
    public DbiSectionContribution SectionContribution { get; private set; }
    public DbiModuleInfo(IBinaryReader reader);
    private DbiModuleInfo(DbiSectionContribution sectionContribution, ushort flags, short streamIndex, int cbSyms, int cbOldLines, int cbLines, short filesCount, UInt32 offsets, int niSource, int niCompiler, string moduleName, string objectName);
    private static DbiModuleInfo();
    internal void Write(BinaryWriter writer);
    private int GetModuleInfoSizeWithoutAlign();
    internal int GetModuleInfoSize();
    [CompilerGeneratedAttribute]
public int get_Opened();
    [CompilerGeneratedAttribute]
private void set_Opened(int value);
    [CompilerGeneratedAttribute]
public ushort get_Flags();
    [CompilerGeneratedAttribute]
private void set_Flags(ushort value);
    [CompilerGeneratedAttribute]
public short get_StreamIndex();
    [CompilerGeneratedAttribute]
private void set_StreamIndex(short value);
    [CompilerGeneratedAttribute]
public int get_CbSyms();
    [CompilerGeneratedAttribute]
private void set_CbSyms(int value);
    [CompilerGeneratedAttribute]
public int get_CbOldLines();
    [CompilerGeneratedAttribute]
private void set_CbOldLines(int value);
    [CompilerGeneratedAttribute]
public int get_CbLines();
    [CompilerGeneratedAttribute]
private void set_CbLines(int value);
    [CompilerGeneratedAttribute]
public short get_FilesCount();
    [CompilerGeneratedAttribute]
private void set_FilesCount(short value);
    [CompilerGeneratedAttribute]
public UInt32 get_Offsets();
    [CompilerGeneratedAttribute]
private void set_Offsets(UInt32 value);
    [CompilerGeneratedAttribute]
public int get_NiSource();
    [CompilerGeneratedAttribute]
private void set_NiSource(int value);
    [CompilerGeneratedAttribute]
public int get_NiCompiler();
    [CompilerGeneratedAttribute]
private void set_NiCompiler(int value);
    [CompilerGeneratedAttribute]
public string get_ModuleName();
    [CompilerGeneratedAttribute]
private void set_ModuleName(string value);
    [CompilerGeneratedAttribute]
public string get_ObjectName();
    [CompilerGeneratedAttribute]
private void set_ObjectName(string value);
    [CompilerGeneratedAttribute]
public DbiSectionContribution get_SectionContribution();
    [CompilerGeneratedAttribute]
private void set_SectionContribution(DbiSectionContribution value);
}
public class JetBrains.Metadata.Debug.Pdb.Dbi.DbiSectionContribution : object {
    public static int SectionContributionSize;
    [CompilerGeneratedAttribute]
private short <Section>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Offset>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Size>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Flags>k__BackingField;
    [CompilerGeneratedAttribute]
private short <Module>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <DataCrc>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <RelocCrc>k__BackingField;
    public short Section { get; private set; }
    public int Offset { get; private set; }
    public int Size { get; private set; }
    public UInt32 Flags { get; private set; }
    public short Module { get; private set; }
    public UInt32 DataCrc { get; private set; }
    public UInt32 RelocCrc { get; private set; }
    public DbiSectionContribution(IBinaryReader reader);
    public DbiSectionContribution(short section, int offset, int size, UInt32 flags, short module, UInt32 dataCrc, UInt32 relocCrc);
    internal void Write(BinaryWriter writer);
    [CompilerGeneratedAttribute]
public short get_Section();
    [CompilerGeneratedAttribute]
private void set_Section(short value);
    [CompilerGeneratedAttribute]
public int get_Offset();
    [CompilerGeneratedAttribute]
private void set_Offset(int value);
    [CompilerGeneratedAttribute]
public int get_Size();
    [CompilerGeneratedAttribute]
private void set_Size(int value);
    [CompilerGeneratedAttribute]
public UInt32 get_Flags();
    [CompilerGeneratedAttribute]
private void set_Flags(UInt32 value);
    [CompilerGeneratedAttribute]
public short get_Module();
    [CompilerGeneratedAttribute]
private void set_Module(short value);
    [CompilerGeneratedAttribute]
public UInt32 get_DataCrc();
    [CompilerGeneratedAttribute]
private void set_DataCrc(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_RelocCrc();
    [CompilerGeneratedAttribute]
private void set_RelocCrc(UInt32 value);
}
public class JetBrains.Metadata.Debug.Pdb.Dbi.DbiStreamInfo : object {
    private DbiDbgHeader myDbiDbgHeader;
    private DbiHeader myDbiHeader;
    private JetReadOnlyList`1<DbiModuleInfo> myModules;
    private DbiFileInfo myFileInfo;
    public DbiHeader DbiHeader { get; }
    public DbiDbgHeader DbiDbgHeader { get; }
    public JetReadOnlyList`1<DbiModuleInfo> Modules { get; }
    public DbiFileInfo FileInfo { get; }
    public DbiStreamInfo(IBinaryReader reader);
    public DbiHeader get_DbiHeader();
    public DbiDbgHeader get_DbiDbgHeader();
    public JetReadOnlyList`1<DbiModuleInfo> get_Modules();
    public DbiFileInfo get_FileInfo();
}
public class JetBrains.Metadata.Debug.Pdb.DebugAssemblyInfo : object {
    private FileSystemPath myAssemblyFile;
    private string myPdbSignature;
    private DebugInfo myDebugInfo;
    public FileSystemPath AssemblyFile { get; }
    public string PdbFile { get; }
    public string PdbSignature { get; }
    public DebugInfoType Type { get; }
    public DebugAssemblyInfo(FileSystemPath assemblyFile, string pdbSignature);
    public DebugAssemblyInfo(FileSystemPath assemblyFile, DebugInfo debugInfo);
    public sealed virtual FileSystemPath get_AssemblyFile();
    public sealed virtual string get_PdbFile();
    public sealed virtual string get_PdbSignature();
    public sealed virtual DebugInfoType get_Type();
    public sealed virtual bool HasSignature();
}
[ExtensionAttribute]
public static class JetBrains.Metadata.Debug.Pdb.DebugAssemblyInfoHelper : object {
    [ExtensionAttribute]
public static IList`1<IDebugAssemblyInfo> GetDebugAssemblyInfos(FileSystemPath assembly);
    [ExtensionAttribute]
public static IDebugAssemblyInfo GetLastAnyStandaloneDebugAssemblyInfo(FileSystemPath assembly);
    [ExtensionAttribute]
public static IDebugAssemblyInfo GetLastDebugAssemblyInfoExceptDeterministic(FileSystemPath assembly);
}
internal class JetBrains.Metadata.Debug.Pdb.DebugSubsection.DocumentInfoVisitor : PdbDebugSubsectionVisitorBase {
    private IPdbStreamBuilder myPdbStreamBuilder;
    private IDictionary`2<int, DebugDocument> myIndexToDocument;
    public DocumentInfoVisitor(IPdbStreamBuilder pdbStreamBuilder, IDictionary`2<int, DebugDocument> indexToDocument);
    public virtual void Visit_FILECHKSMS(IBinaryReader moduleStream, int start, int stop);
}
internal interface JetBrains.Metadata.Debug.Pdb.DebugSubsection.IPdbDebugSubsectionVisitor {
    public abstract virtual void Visit_FILECHKSMS(IBinaryReader moduleStream, int start, int stop);
    public abstract virtual void Visit_LINES(IBinaryReader moduleStream, int start, int stop);
}
public class JetBrains.Metadata.Debug.Pdb.DebugSubsection.LocalVariablesNameProvider : object {
    private DebugData myDebugData;
    public LocalVariablesNameProvider(DebugData debugData);
    public sealed virtual string GetVariableName(IMetadataMethod methodBody, int index);
    public sealed virtual string GetVariableName(IMetadataMethod methodBody, int index, int ilOffset);
}
internal class JetBrains.Metadata.Debug.Pdb.DebugSubsection.ManagedLinesVisitor : PdbDebugSubsectionVisitorBase {
    private PdbFunction[] myFuncs;
    private IDictionary`2<int, DebugDocument> myIndexToDocument;
    [CanBeNullAttribute]
private CompactOneToListMap`2<PdbFunction, DebugDocument> myFunctionToDocuments;
    public ManagedLinesVisitor(PdbFunction[] funcs, IDictionary`2<int, DebugDocument> indexToDocument, CompactOneToListMap`2<PdbFunction, DebugDocument> functionToDocuments);
    public virtual void Visit_LINES(IBinaryReader moduleStream, int start, int stop);
    [CanBeNullAttribute]
private PdbFunction FindFirstFunctionWithoutLines(ushort sec, UInt32 off);
}
internal enum JetBrains.Metadata.Debug.Pdb.DebugSubsection.PdbDebugSubsection : Enum {
    public UInt32 value__;
    public static PdbDebugSubsection SYMBOLS;
    public static PdbDebugSubsection LINES;
    public static PdbDebugSubsection STRINGTABLE;
    public static PdbDebugSubsection FILECHKSMS;
    public static PdbDebugSubsection FRAMEDATA;
}
internal class JetBrains.Metadata.Debug.Pdb.DebugSubsection.PdbDebugSubsectionVisitorBase : object {
    public virtual void Visit_FILECHKSMS(IBinaryReader moduleStream, int start, int stop);
    public virtual void Visit_LINES(IBinaryReader moduleStream, int start, int stop);
}
internal class JetBrains.Metadata.Debug.Pdb.DebugSubsection.PdbLinesBlock : object {
    public DebugDocument Document;
    public PdbSequencePoint[] SequencePoints;
    public PdbLinesBlock(DebugDocument document, PdbSequencePoint[] sequencePoints);
}
public class JetBrains.Metadata.Debug.Pdb.DebugSubsection.SourceFileInfo : object {
    [NotNullAttribute]
public ReadOnlyDictionary`2<MetadataToken, PdbFunction> Functions;
    [CompilerGeneratedAttribute]
private static Func`2<PdbFunction, MetadataToken> CS$<>9__CachedAnonymousMethodDelegate1;
    internal SourceFileInfo(IEnumerable`1<PdbFunction> functions);
    [CompilerGeneratedAttribute]
private static MetadataToken <.ctor>b__0(PdbFunction f);
}
public class JetBrains.Metadata.Debug.Pdb.Generator.PdbFileBuilder : object {
    private static int PageSize;
    private static int TableOfContentsStreamIndex;
    private static int ListOfNamedStreamsStreamIndex;
    private static int DbiStreamIndex;
    private Dictionary`2<int, int> myStreamIndexToStreamStartPageIndex;
    private Dictionary`2<int, int> myStreamIndexToStreamSize;
    private Dictionary`2<int, MemoryStream> myStreams;
    private Dictionary`2<int, string> myStreamIndexToStreamName;
    private Dictionary`2<string, int> myStreamNameToStreamIndex;
    private List`1<int> myStreamOrder;
    private int myNumPages;
    private int myTableOfContentsPointersStartPageIndex;
    private MemoryStream myTableOfContentsPointers;
    private int myMaxStreamIndex;
    private bool myAllStreamsAreBuilt;
    private int GetNumPagesFor(int numBytes);
    private void AddStream(MemoryStream stream, int streamIndex, string streamName);
    public void AddStream(MemoryStream stream, int streamIndex);
    public void AddStream(MemoryStream stream, string streamName);
    public void AddEmptyStream(int streamIndex);
    private void BuildAllStreamsAndTocPointers();
    private void AddTableOfContentsPointers();
    public void WriteToStream(Stream stream);
    private void AlignToPageSize(Stream stream, int writtenBytesNum);
    private void WritePdbHeader(Stream stream);
    private void WriteAllStreams(Stream stream);
    private void CopyWithAlign(MemoryStream inputStream, Stream outputStream);
    private void WriteTableOfContentsPointers(Stream stream);
    private int GetStreamSize(int streamIndex);
    private int GetStreamStartPageIndex(int streamIndex);
    private void AddTableOfContentsStream();
    private void AddListOfNamedStreamsStream();
    public void WriteToFile(FileSystemPath file);
}
public static class JetBrains.Metadata.Debug.Pdb.Generator.PdbStreamGenerator : object {
    private static int SizeOfInt;
    [CompilerGeneratedAttribute]
private static Func`2<KeyValuePair`2<int, string>, int> CS$<>9__CachedAnonymousMethodDelegate1;
    [CompilerGeneratedAttribute]
private static Func`2<DbiModuleInfo, int> CS$<>9__CachedAnonymousMethodDelegate3;
    public static int GetStringSizeInBytes(string s);
    public static MemoryStream GenerateListOfNamedStreamsStream(int version, int timeStamp, int age, Guid symId, IDictionary`2<int, string> streamIndexToStreamName);
    public static MemoryStream GenerateTableOfContentsStream(IDictionary`2<int, int> streamIndexToStreamSize, IDictionary`2<int, int> streamIndexToStreamStartPageIndex, int maxStreamIndex, int tableOfContentsStreamStartPageIndex, int tableOfContentsStreamIndex, Func`2<int, int> getNumPages);
    private static void WriteStreamPages(BinaryWriter writer, int streamStartPageIndex, int streamNumPages);
    public static MemoryStream GenerateTableOfContentsPointers(int tableOfContentsStreamStartPageIndex, int tableOfContentsStreamNumPages);
    public static MemoryStream GenerateModuleStream();
    public static MemoryStream GenerateDbiStream(ushort versionMajorMinor, ushort versionBuildNumber, short globalSymbolInfoStreamIndex, short publicSymbolInfoStreamIndex, short symbolRecordStreamIndex, IList`1<DbiModuleInfo> modules, OneToListMap`2<DbiModuleInfo, string> fileNames);
    public static MemoryStream GenerateNamesStream();
    public static MemoryStream GenerateSrcFilesStream();
    public static MemoryStream GenerateEmptyStream();
    [CompilerGeneratedAttribute]
private static int <GenerateListOfNamedStreamsStream>b__0(KeyValuePair`2<int, string> item);
    [CompilerGeneratedAttribute]
private static int <GenerateDbiStream>b__2(DbiModuleInfo dbiModuleInfo);
}
public interface JetBrains.Metadata.Debug.Pdb.IDebugAssemblyInfo {
    [NotNullAttribute]
public FileSystemPath AssemblyFile { get; }
    [CanBeNullAttribute]
public string PdbFile { get; }
    [CanBeNullAttribute]
public string PdbSignature { get; }
    public DebugInfoType Type { get; }
    public abstract virtual FileSystemPath get_AssemblyFile();
    public abstract virtual string get_PdbFile();
    public abstract virtual string get_PdbSignature();
    public abstract virtual DebugInfoType get_Type();
    public abstract virtual bool HasSignature();
}
public interface JetBrains.Metadata.Debug.Pdb.IPdbStreamBuilder {
    [CanBeNullAttribute]
public abstract virtual Stream GetSrcSrvStream();
    [CanBeNullAttribute]
public abstract virtual Stream GetNamesStream();
    [CanBeNullAttribute]
public abstract virtual Stream GetSrcFileStream(string name);
    [NotNullAttribute]
public abstract virtual Stream GetDbiStream();
    public abstract virtual string GetStreamName(int name);
}
public class JetBrains.Metadata.Debug.Pdb.ParsedPdb : object {
    [CanBeNullAttribute]
private CompactOneToListMap`2<string, string> myType2Files;
    private Lazy`1<IDictionary`2<string, string>> myFile2Type;
    [CompilerGeneratedAttribute]
private DebugData <DebugData>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <PdbTimestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private SrcSrvInfo <SrcSrvInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private SourceLink <SourceLink>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, int> <DocumentNameToIndex>k__BackingField;
    [CanBeNullAttribute]
public DebugData DebugData { get; private set; }
    public DateTime PdbTimestamp { get; private set; }
    [CanBeNullAttribute]
public SrcSrvInfo SrcSrvInfo { get; private set; }
    [CanBeNullAttribute]
public SourceLink SourceLink { get; private set; }
    [CanBeNullAttribute]
public IDictionary`2<string, int> DocumentNameToIndex { get; private set; }
    public CompactOneToListMap`2<string, string> Type2Files { get; }
    internal bool HasType2Files { get; }
    public ParsedPdb(CompactOneToListMap`2<string, string> type2Files, SrcSrvInfo srcSrvInfo, SourceLink sourceLink, IDictionary`2<string, int> documentNameToIndex, DebugData debugData, DateTime pdbTimestamp);
    [CompilerGeneratedAttribute]
public DebugData get_DebugData();
    [CompilerGeneratedAttribute]
private void set_DebugData(DebugData value);
    private Dictionary`2<string, string> BuildFile2TypeDict();
    [CompilerGeneratedAttribute]
public DateTime get_PdbTimestamp();
    [CompilerGeneratedAttribute]
private void set_PdbTimestamp(DateTime value);
    [CompilerGeneratedAttribute]
public SrcSrvInfo get_SrcSrvInfo();
    [CompilerGeneratedAttribute]
private void set_SrcSrvInfo(SrcSrvInfo value);
    [CompilerGeneratedAttribute]
public SourceLink get_SourceLink();
    [CompilerGeneratedAttribute]
private void set_SourceLink(SourceLink value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, int> get_DocumentNameToIndex();
    [CompilerGeneratedAttribute]
private void set_DocumentNameToIndex(IDictionary`2<string, int> value);
    public CompactOneToListMap`2<string, string> get_Type2Files();
    internal bool get_HasType2Files();
    public void WriteTo(UnsafeWriter writer);
    public static ParsedPdb ReadFrom(UnsafeReader reader);
    private static void WriteTypeToFilesAndIndices(UnsafeWriter writer, CompactOneToListMap`2<string, string> typeToFiles, IDictionary`2<string, int> documentNameToIndex);
    private static void ReadTypeToFilesAndIndices(UnsafeReader reader, CompactOneToListMap`2& typeToFiles, IDictionary`2& documentNameToIndex);
    public void DumpSelf(TextWriter writer);
    public bool ReferencesFile(FileSystemPath fileName);
    public int GetByteCount(Encoding encoding);
}
internal interface JetBrains.Metadata.Debug.Pdb.PdbDefinition.IPdbDefinitionVisitor {
    public abstract virtual void Visit_S_OEM(IBinaryReader moduleStream, int stop);
    public abstract virtual void Visit_S_BLOCK32(IBinaryReader moduleStream, int stop);
    public abstract virtual void Visit_S_MANSLOT(IBinaryReader moduleStream, int stop);
    public abstract virtual void Visit_S_MANCONSTANT(IBinaryReader moduleStream, int stop);
    public abstract virtual void Visit_S_UNAMESPACE(IBinaryReader moduleStream, int stop);
    public abstract virtual void Visit_S_MANPROC(IBinaryReader moduleStream, int stop);
    public abstract virtual void Visit_S_THUNK(IBinaryReader moduleStream, int stop);
    public abstract virtual void Visit_S_PROC32(IBinaryReader moduleStream, int stop);
}
internal class JetBrains.Metadata.Debug.Pdb.PdbDefinition.ManagedFunctionListVisitor : PdbDefinitionVisitorBase {
    private List`1<PdbFunction> myFuctions;
    private ICollection`1<Proc32Scope> myScopes;
    public ManagedFunctionListVisitor(List`1<PdbFunction> fuctions, ICollection`1<Proc32Scope> scopes);
    public virtual void Visit_S_MANPROC(IBinaryReader moduleStream, int stop);
    public virtual void Visit_S_THUNK(IBinaryReader moduleStream, int stop);
    public virtual void Visit_S_PROC32(IBinaryReader moduleStream, int stop);
}
internal class JetBrains.Metadata.Debug.Pdb.PdbDefinition.PdbDefinitionVisitorBase : object {
    private static Stack`1<PdbSymbolDefinitions> myRec;
    private static Stack`1<PdbSymbolDefinitions> myNeedSEndRec;
    private static PdbDefinitionVisitorBase();
    private void DefaultHandler(IBinaryReader moduleStream, int stop);
    public virtual void Visit_S_OEM(IBinaryReader moduleStream, int stop);
    public virtual void Visit_S_BLOCK32(IBinaryReader moduleStream, int stop);
    public virtual void Visit_S_MANSLOT(IBinaryReader moduleStream, int stop);
    public virtual void Visit_S_MANCONSTANT(IBinaryReader moduleStream, int stop);
    public virtual void Visit_S_UNAMESPACE(IBinaryReader moduleStream, int stop);
    public virtual void Visit_S_MANPROC(IBinaryReader moduleStream, int stop);
    public virtual void Visit_S_THUNK(IBinaryReader moduleStream, int stop);
    public virtual void Visit_S_PROC32(IBinaryReader moduleStream, int stop);
}
internal class JetBrains.Metadata.Debug.Pdb.PdbDefinition.PdbFunctionVisitor : PdbScopeVisitor {
    private static long MD2;
    [CompilerGeneratedAttribute]
private MethodCustomDebugInformation <MethodCustomDebugInformation>k__BackingField;
    [CanBeNullAttribute]
public MethodCustomDebugInformation MethodCustomDebugInformation { get; private set; }
    public PdbFunctionVisitor(UInt32 address, PdbScope rootScope, ICollection`1<string> usedNamespaces, ICollection`1<PdbConstant> constants);
    [CompilerGeneratedAttribute]
public MethodCustomDebugInformation get_MethodCustomDebugInformation();
    [CompilerGeneratedAttribute]
private void set_MethodCustomDebugInformation(MethodCustomDebugInformation value);
    public virtual void Visit_S_OEM(IBinaryReader moduleStream, int stop);
    private void ReadCustomMetadata(IBinaryReader moduleStream);
}
internal class JetBrains.Metadata.Debug.Pdb.PdbDefinition.PdbScopeBase : object {
    public PdbConstant[] Constants;
    public String[] UsedNamespaces;
    public UInt32 Address;
    public UInt32 Offset;
    public UInt32 Length;
    public UInt32 TypeIndex;
    public PdbScope RootScope;
    internal PdbScopeBase(UInt32 funcOffset, UInt32 address, UInt32 len, UInt32 end, IBinaryReader stream);
}
internal class JetBrains.Metadata.Debug.Pdb.PdbDefinition.PdbScopeVisitor : PdbDefinitionVisitorBase {
    private UInt32 myAddress;
    private PdbScope myScope;
    private ICollection`1<string> myUsedNamespaces;
    private ICollection`1<PdbConstant> myConstants;
    public PdbScopeVisitor(UInt32 address, PdbScope scope, ICollection`1<string> usedNamespaces, ICollection`1<PdbConstant> constants);
    public virtual void Visit_S_BLOCK32(IBinaryReader moduleStream, int stop);
    public virtual void Visit_S_MANSLOT(IBinaryReader moduleStream, int stop);
    public virtual void Visit_S_UNAMESPACE(IBinaryReader moduleStream, int stop);
    public virtual void Visit_S_MANCONSTANT(IBinaryReader moduleStream, int stop);
}
internal enum JetBrains.Metadata.Debug.Pdb.PdbDefinition.PdbSymbolDefinitions : Enum {
    public UInt32 value__;
    public static PdbSymbolDefinitions S_END;
    public static PdbSymbolDefinitions S_LPROC_V1;
    public static PdbSymbolDefinitions S_GPROC_V1;
    public static PdbSymbolDefinitions S_THUNK_V1;
    public static PdbSymbolDefinitions S_BLOCK_V1;
    public static PdbSymbolDefinitions S_OEM;
    public static PdbSymbolDefinitions S_REGISTER_ST;
    public static PdbSymbolDefinitions S_CONSTANT_ST;
    public static PdbSymbolDefinitions S_UDT_ST;
    public static PdbSymbolDefinitions S_COBOLUDT_ST;
    public static PdbSymbolDefinitions S_MANYREG_ST;
    public static PdbSymbolDefinitions S_BPREL32_ST;
    public static PdbSymbolDefinitions S_LDATA32_ST;
    public static PdbSymbolDefinitions S_GDATA32_ST;
    public static PdbSymbolDefinitions S_PUB32_ST;
    public static PdbSymbolDefinitions S_LPROC32_ST;
    public static PdbSymbolDefinitions S_GPROC32_ST;
    public static PdbSymbolDefinitions S_VFTABLE32;
    public static PdbSymbolDefinitions S_REGREL32_ST;
    public static PdbSymbolDefinitions S_LTHREAD32_ST;
    public static PdbSymbolDefinitions S_GTHREAD32_ST;
    public static PdbSymbolDefinitions S_LPROCMIPS_ST;
    public static PdbSymbolDefinitions S_GPROCMIPS_ST;
    public static PdbSymbolDefinitions S_FRAMEPROC;
    public static PdbSymbolDefinitions S_COMPILE2_ST;
    public static PdbSymbolDefinitions S_MANYREG2_ST;
    public static PdbSymbolDefinitions S_LPROCIA64_ST;
    public static PdbSymbolDefinitions S_GPROCIA64_ST;
    public static PdbSymbolDefinitions S_LOCALSLOT_ST;
    public static PdbSymbolDefinitions S_PARAMSLOT_ST;
    public static PdbSymbolDefinitions S_ANNOTATION;
    public static PdbSymbolDefinitions S_GMANPROC_ST;
    public static PdbSymbolDefinitions S_LMANPROC_ST;
    public static PdbSymbolDefinitions S_RESERVED1;
    public static PdbSymbolDefinitions S_RESERVED2;
    public static PdbSymbolDefinitions S_RESERVED3;
    public static PdbSymbolDefinitions S_RESERVED4;
    public static PdbSymbolDefinitions S_LMANDATA_ST;
    public static PdbSymbolDefinitions S_GMANDATA_ST;
    public static PdbSymbolDefinitions S_MANFRAMEREL_ST;
    public static PdbSymbolDefinitions S_MANREGISTER_ST;
    public static PdbSymbolDefinitions S_MANSLOT_ST;
    public static PdbSymbolDefinitions S_MANMANYREG_ST;
    public static PdbSymbolDefinitions S_MANREGREL_ST;
    public static PdbSymbolDefinitions S_MANMANYREG2_ST;
    public static PdbSymbolDefinitions S_MANTYPREF;
    public static PdbSymbolDefinitions S_UNAMESPACE_ST;
    public static PdbSymbolDefinitions S_ST_MAX;
    public static PdbSymbolDefinitions S_OBJNAME;
    public static PdbSymbolDefinitions S_THUNK32;
    public static PdbSymbolDefinitions S_BLOCK32;
    public static PdbSymbolDefinitions S_WITH32;
    public static PdbSymbolDefinitions S_LABEL32;
    public static PdbSymbolDefinitions S_REGISTER;
    public static PdbSymbolDefinitions S_CONSTANT;
    public static PdbSymbolDefinitions S_UDT;
    public static PdbSymbolDefinitions S_COBOLUDT;
    public static PdbSymbolDefinitions S_MANYREG;
    public static PdbSymbolDefinitions S_BPREL32;
    public static PdbSymbolDefinitions S_LDATA32;
    public static PdbSymbolDefinitions S_GDATA32;
    public static PdbSymbolDefinitions S_PUB32;
    public static PdbSymbolDefinitions S_LPROC32;
    public static PdbSymbolDefinitions S_GPROC32;
    public static PdbSymbolDefinitions S_REGREL32;
    public static PdbSymbolDefinitions S_LTHREAD32;
    public static PdbSymbolDefinitions S_GTHREAD32;
    public static PdbSymbolDefinitions S_LPROCMIPS;
    public static PdbSymbolDefinitions S_GPROCMIPS;
    public static PdbSymbolDefinitions S_COMPILE2;
    public static PdbSymbolDefinitions S_MANYREG2;
    public static PdbSymbolDefinitions S_LPROCIA64;
    public static PdbSymbolDefinitions S_GPROCIA64;
    public static PdbSymbolDefinitions S_LOCALSLOT;
    public static PdbSymbolDefinitions S_SLOT;
    public static PdbSymbolDefinitions S_PARAMSLOT;
    public static PdbSymbolDefinitions S_LMANDATA;
    public static PdbSymbolDefinitions S_GMANDATA;
    public static PdbSymbolDefinitions S_MANFRAMEREL;
    public static PdbSymbolDefinitions S_MANREGISTER;
    public static PdbSymbolDefinitions S_MANSLOT;
    public static PdbSymbolDefinitions S_MANMANYREG;
    public static PdbSymbolDefinitions S_MANREGREL;
    public static PdbSymbolDefinitions S_MANMANYREG2;
    public static PdbSymbolDefinitions S_UNAMESPACE;
    public static PdbSymbolDefinitions S_PROCREF;
    public static PdbSymbolDefinitions S_DATAREF;
    public static PdbSymbolDefinitions S_LPROCREF;
    public static PdbSymbolDefinitions S_ANNOTATIONREF;
    public static PdbSymbolDefinitions S_TOKENREF;
    public static PdbSymbolDefinitions S_GMANPROC;
    public static PdbSymbolDefinitions S_LMANPROC;
    public static PdbSymbolDefinitions S_TRAMPOLINE;
    public static PdbSymbolDefinitions S_MANCONSTANT;
    public static PdbSymbolDefinitions S_ATTR_FRAMEREL;
    public static PdbSymbolDefinitions S_ATTR_REGISTER;
    public static PdbSymbolDefinitions S_ATTR_REGREL;
    public static PdbSymbolDefinitions S_ATTR_MANYREG;
    public static PdbSymbolDefinitions S_SEPCODE;
    public static PdbSymbolDefinitions S_LOCAL;
    public static PdbSymbolDefinitions S_DEFRANGE;
    public static PdbSymbolDefinitions S_DEFRANGE2;
    public static PdbSymbolDefinitions S_SECTION;
    public static PdbSymbolDefinitions S_COFFGROUP;
    public static PdbSymbolDefinitions S_EXPORT;
    public static PdbSymbolDefinitions S_CALLSITEINFO;
    public static PdbSymbolDefinitions S_FRAMECOOKIE;
    public static PdbSymbolDefinitions S_DISCARDED;
    public static PdbSymbolDefinitions S_RECTYPE_MAX;
    public static PdbSymbolDefinitions S_RECTYPE_LAST;
}
internal class JetBrains.Metadata.Debug.Pdb.PdbDefinition.Proc32Scope : PdbScopeBase {
    internal Proc32Scope(UInt32 funcOffset, ProcSym32 block, IBinaryReader stream);
}
internal class JetBrains.Metadata.Debug.Pdb.PdbDefinition.ThunkVisitor : PdbDefinitionVisitorBase {
}
public class JetBrains.Metadata.Debug.Pdb.PdbFunction : object {
    internal static IComparer`1<PdbFunction> ByAddress;
    public static IComparer`1<PdbFunction> ByAddressAndToken;
    internal static Guid MsilMetaData;
    public ushort Segment;
    public UInt32 Address;
    public string Name;
    [CompilerGeneratedAttribute]
private UInt32 <CodeLength>k__BackingField;
    [CompilerGeneratedAttribute]
private MetadataToken <Token>k__BackingField;
    [CompilerGeneratedAttribute]
private PdbLine[] <Lines>k__BackingField;
    [CompilerGeneratedAttribute]
private PdbConstant[] <Constants>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <UsedNamespaces>k__BackingField;
    [CompilerGeneratedAttribute]
private MethodCustomDebugInformation <MethodCustomDebugInformation>k__BackingField;
    [CompilerGeneratedAttribute]
private PdbScope <RootScope>k__BackingField;
    public UInt32 CodeLength { get; private set; }
    public MetadataToken Token { get; internal set; }
    [CanBeNullAttribute]
public PdbLine[] Lines { get; private set; }
    [CanBeNullAttribute]
public PdbConstant[] Constants { get; private set; }
    [CanBeNullAttribute]
public String[] UsedNamespaces { get; private set; }
    [CanBeNullAttribute]
public MethodCustomDebugInformation MethodCustomDebugInformation { get; private set; }
    public PdbScope RootScope { get; private set; }
    internal bool HasLines { get; }
    internal PdbFunction(IBinaryReader moduleStream, ManProcSym proc);
    internal PdbFunction(IBinaryReader moduleStream, DatasSym32 datas);
    public PdbFunction(ushort sec, UInt32 off);
    private static PdbFunction();
    [CompilerGeneratedAttribute]
public UInt32 get_CodeLength();
    [CompilerGeneratedAttribute]
private void set_CodeLength(UInt32 value);
    [CompilerGeneratedAttribute]
public MetadataToken get_Token();
    [CompilerGeneratedAttribute]
internal void set_Token(MetadataToken value);
    [CompilerGeneratedAttribute]
public PdbLine[] get_Lines();
    [CompilerGeneratedAttribute]
private void set_Lines(PdbLine[] value);
    [CompilerGeneratedAttribute]
public PdbConstant[] get_Constants();
    [CompilerGeneratedAttribute]
private void set_Constants(PdbConstant[] value);
    [CompilerGeneratedAttribute]
public String[] get_UsedNamespaces();
    [CompilerGeneratedAttribute]
private void set_UsedNamespaces(String[] value);
    [CompilerGeneratedAttribute]
public MethodCustomDebugInformation get_MethodCustomDebugInformation();
    [CompilerGeneratedAttribute]
private void set_MethodCustomDebugInformation(MethodCustomDebugInformation value);
    [CompilerGeneratedAttribute]
public PdbScope get_RootScope();
    [CompilerGeneratedAttribute]
private void set_RootScope(PdbScope value);
    internal bool get_HasLines();
    internal void AddLines(PdbLine[] linesBlock);
    [NotNullAttribute]
public static PdbFunction[] LoadManagedFunctions(StreamBinaryReader moduleStream, int initialPosition, int endPosition);
    [NotNullAttribute]
public static ReadOnlyDictionary`2<int, DebugDocument> LoadDocumentInfos(StreamBinaryReader moduleStream, int startManagedLines, int endManagedLines, IPdbStreamBuilder pdbStreamBuilder);
    public static void LoadManagedLines(StreamBinaryReader moduleStream, int startManagedLines, int endManagedLines, PdbFunction[] func, IDictionary`2<int, DebugDocument> indexToDocument, CompactOneToListMap`2<PdbFunction, DebugDocument> functionToDocuments);
    public static void SkipDebugSubsection(StreamBinaryReader moduleStream, int initialPosition, int endPosition);
    public void MergeFunction(PdbFunction pdbFunction);
}
public class JetBrains.Metadata.Debug.Pdb.PdbHeader : ValueType {
    public static int HeaderSize;
    public static string Pdb7Signature;
    public static int Pdb7SignatureSize;
    private UInt32 myBlockSize;
    private UInt32 myNumPages;
    private string mySignature;
    private UInt32 myStartPage;
    private UInt32 myTocPage;
    private UInt32 myTocSize;
    private UInt32 myUnknown2;
    public string Signature { get; }
    public UInt32 BlockSize { get; }
    public UInt32 NumPages { get; }
    public UInt32 TocSize { get; }
    public UInt32 TocBlocksPage { get; }
    public UInt32 FirstPage { get; }
    internal PdbHeader(BinaryReader reader);
    internal PdbHeader(UInt32 blockSize, UInt32 startPage, UInt32 numPages, UInt32 tocSize, UInt32 tocPage);
    internal void Write(BinaryWriter writer);
    public string get_Signature();
    public UInt32 get_BlockSize();
    public UInt32 get_NumPages();
    public UInt32 get_TocSize();
    public UInt32 get_TocBlocksPage();
    public UInt32 get_FirstPage();
}
public class JetBrains.Metadata.Debug.Pdb.PdbLine : object {
    public DebugDocument Document;
    public PdbSequencePoint SequencePoint;
    [CompilerGeneratedAttribute]
private static Func`2<PdbLinesBlock, IEnumerable`1<PdbSequencePoint>> CS$<>9__CachedAnonymousMethodDelegate2;
    [CompilerGeneratedAttribute]
private static Func`3<PdbLinesBlock, PdbSequencePoint, PdbLine> CS$<>9__CachedAnonymousMethodDelegate3;
    private PdbLine(DebugDocument document, PdbSequencePoint sequencePoint);
    internal static PdbLine[] ExtractLinesFromLinesBlock(IEnumerable`1<PdbLinesBlock> linesBlocks);
    internal static PdbLine[] MergeLines(PdbLine[] lines1, PdbLine[] lines2);
    private static int Comparison(PdbLine line1, PdbLine line2);
    [CompilerGeneratedAttribute]
private static IEnumerable`1<PdbSequencePoint> <ExtractLinesFromLinesBlock>b__0(PdbLinesBlock linesBlock);
    [CompilerGeneratedAttribute]
private static PdbLine <ExtractLinesFromLinesBlock>b__1(PdbLinesBlock linesBlock, PdbSequencePoint sequencePoint);
}
[FlagsAttribute]
public enum JetBrains.Metadata.Debug.Pdb.PdbParseLevel : Enum {
    public int value__;
    public static PdbParseLevel None;
    public static PdbParseLevel LoadFunc;
    public static PdbParseLevel LoadFuncAndStatement;
}
internal static class JetBrains.Metadata.Debug.Pdb.PdbParser : object {
    private static void Assert_S_END(IBinaryReader moduleStream, PdbSymbolDefinitions needFor);
    public static void ParseSymbolDefinitions(IBinaryReader moduleStream, int initialPosition, int endPosition, IPdbDefinitionVisitor visitor);
    public static void ParseDebugSubsection(IBinaryReader moduleStream, int initialPosition, int endPosition, IPdbDebugSubsectionVisitor visitor);
}
public class JetBrains.Metadata.Debug.Pdb.PdbReader : object {
    [CanBeNullAttribute]
public static ParsedPdb ReadPdb(FileSystemPath pdbPath, PdbParseLevel level, IDebugAssemblyInfo debugAssemblyInfo);
    public static FileSystemPath TemporarilyExtractEmbeddedPdb(Lifetime lifetime, FileSystemPath assemblyWithEmbeddedPdb);
    private static void ExtractEmbeddedPdb(FileStream extractedPdb, FileSystemPath assemblyWithEmbeddedPdb);
    private static ParsedPdb ReadPortablePdb(FileSystemPath pdbPath, DebugInfoType type, FileSystemPath assemblyPath, DateTime timestamp);
    [CanBeNullAttribute]
public static DebugData ReadPdb(FileSystemPath pdbPath, DebugInfoType pdbType);
    [CanBeNullAttribute]
public static DebugData ReadWindowsPdb(FileSystemPath pdbPath);
    [CanBeNullAttribute]
public static DebugData ReadPortablePdb(FileSystemPath pdbPath);
    [CanBeNullAttribute]
public static DebugData ReadEmbeddedPortablePdb(FileSystemPath assemblyWithEmbeddedPdb);
    [CanBeNullAttribute]
private static DebugData ReadPortablePdb(FileSystemPath pdbPath, DebugInfoType type);
}
public class JetBrains.Metadata.Debug.Pdb.PdbRootRecord : object {
    private Guid myPdbSignature;
    private UInt32 myTimeStamp;
    private UInt32 myVersion;
    private UInt32 myPdbAge;
    public UInt32 Version { get; }
    public UInt32 TimeDateStamp { get; }
    public Guid PdbSignature { get; }
    public UInt32 PdbAge { get; }
    public PdbRootRecord(BinaryReader rdr);
    public UInt32 get_Version();
    public UInt32 get_TimeDateStamp();
    public Guid get_PdbSignature();
    public UInt32 get_PdbAge();
}
public class JetBrains.Metadata.Debug.Pdb.PdbScope : object {
    private List`1<PdbVariable> myVariables;
    private List`1<PdbScope> myChildScopes;
    [CompilerGeneratedAttribute]
private PdbScope <ParentScope>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <StartOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Length>k__BackingField;
    [CanBeNullAttribute]
public PdbScope ParentScope { get; private set; }
    public UInt32 StartOffset { get; private set; }
    public UInt32 Length { get; private set; }
    public List`1<PdbVariable> Variables { get; }
    public List`1<PdbScope> ChildScopes { get; }
    private PdbScope(UInt32 startOffset, UInt32 length, PdbScope parentScope);
    [CompilerGeneratedAttribute]
public PdbScope get_ParentScope();
    [CompilerGeneratedAttribute]
private void set_ParentScope(PdbScope value);
    [CompilerGeneratedAttribute]
public UInt32 get_StartOffset();
    [CompilerGeneratedAttribute]
private void set_StartOffset(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_Length();
    [CompilerGeneratedAttribute]
private void set_Length(UInt32 value);
    internal static PdbScope Create(UInt32 startOffset, UInt32 length, PdbScope parentScope);
    internal static PdbScope CreateRoot(UInt32 functionCodeLength);
    public List`1<PdbVariable> get_Variables();
    public List`1<PdbScope> get_ChildScopes();
}
[ExtensionAttribute]
public static class JetBrains.Metadata.Debug.Pdb.PdbScopeEx : object {
    [ExtensionAttribute]
public static IList`1<Pair`2<PdbVariable, PdbScope>> FlattenVariables(PdbScope scope);
}
[DebuggerDisplayAttribute("PdbSequencePoint: {Offset} {LineBegin} {Statement}")]
public class JetBrains.Metadata.Debug.Pdb.PdbSequencePoint : object {
    public static int HiddenSequencePointLine;
    private CV_Line myLine;
    private CV_Column myColumn;
    public UInt32 Offset { get; }
    public UInt32 LineBegin { get; }
    public UInt32 LineEnd { get; }
    public bool Statement { get; }
    public ushort ColBegin { get; }
    public ushort ColEnd { get; }
    public bool IsValidLine { get; }
    internal PdbSequencePoint(CV_Line line, CV_Column column);
    public UInt32 get_Offset();
    public UInt32 get_LineBegin();
    public UInt32 get_LineEnd();
    public bool get_Statement();
    public ushort get_ColBegin();
    public ushort get_ColEnd();
    public bool get_IsValidLine();
}
public class JetBrains.Metadata.Debug.Pdb.PdbToc : object {
    private PdbStream[] myStreams;
    public PdbStream[] Streams { get; }
    internal PdbToc(BinaryReader reader, UInt32 blockSize);
    public PdbStream[] get_Streams();
    private static PdbStream LoadPDBStreamBlocks(BinaryReader reader, UInt32 streamSize, UInt32 blockSize);
}
[ExtensionAttribute]
public static class JetBrains.Metadata.Debug.Pdb.PdbUtils : object {
    [CompilerGeneratedAttribute]
private static Func`2<DebugInfo, bool> CS$<>9__CachedAnonymousMethodDelegate4;
    public static string GetPdbExtension(bool compressed);
    [NotNullAttribute]
public static IList`1<DebugInfo> GetDebugInfos(FileSystemPath pePath);
    [NotNullAttribute]
public static IList`1<DebugInfo> GetDebugInfosThrow(FileSystemPath pePath);
    [NotNullAttribute]
[ObsoleteAttribute("Use PdbUtils.GetDebugInfos instead")]
public static IList`1<DebugInfo7> GetDebugInfos7(FileSystemPath pePath);
    [CanBeNullAttribute]
public static Byte[] TryGetDecompressedEmbeddedPortablePdb(FileSystemPath pePath);
    [ExtensionAttribute]
public static IEnumerable`1<DebugInfo> OfDebugInfoType(IEnumerable`1<DebugInfo> debugInfos, DebugInfoType type);
    [ExtensionAttribute]
public static IEnumerable`1<DebugInfo> OfAnyStandaloneType(IEnumerable`1<DebugInfo> debugInfos);
    [CanBeNullAttribute]
public static string TryGetLastAnyStandalonePdbSignature(FileSystemPath pePath);
    public static void GetSignatureAndAge(FileSystemPath windowsPdbPath, Guid& signature, UInt32& ageFromDbi);
    private static void GetSignatureAndAge(WindowsPdbFile pdbFile, Guid& signature, UInt32& ageFromDbi, UInt32& ageFromRoot);
    public static void GetSignatureAndTimestamp(FileSystemPath portablePdbPath, Guid& signature, UInt32& timeDateStamp);
    public static bool VerifySignature(FileSystemPath assemblyPath, FileSystemPath pdbPath);
    public static bool VerifySignature(FileSystemPath assemblyPath, FileSystemPath pdbPath, DebugInfoType pdbType);
    private static bool VerifySignature(FileSystemPath assemblyPath, WindowsPdbFile windowsPdbFile);
    public static DebugInfoType GetPdbType(FileSystemPath pdbPath);
    public static bool TryGetPdbType(FileSystemPath pdbPath, DebugInfoType& debugInfoType);
    [CanBeNullAttribute]
public static DebugInfo TryGetPdbDebugInfo(FileSystemPath pdbPath);
    [NotNullAttribute]
[ExtensionAttribute]
public static ParsedPdb ToParsedPdb(PortablePdbFile portablePdbFile, DateTime pdbTimestamp);
    [NotNullAttribute]
[ExtensionAttribute]
public static ParsedPdb ToParsedPdb(WindowsPdbFile windowsPdbFile, PdbParseLevel level, FileSystemPath assemblyPath, DateTime pdbTimestamp);
    private static CompactOneToListMap`2<string, string> GetTypeToFilesMapping(WindowsPdbFile windowsPdbFile, FileSystemPath assemblyPath);
    private static CompactOneToListMap`2<string, string> GetTypeToFilesFromSequencePoints(WindowsPdbFile windowsPdbFile, IMetadataAssembly metadataAssembly, IMetadataAccess metadataAccess);
    private static void ProcessNestedTypes(MetadataToken typeToken, OneToSetMap`2<MetadataToken, MetadataToken> nestedTypeMap, CompactOneToListMap`2<string, string> typeToFiles, String[] typeFqns, Boolean[] processed);
    private static CompactOneToListMap`2<string, string> GetTypeToFilesFromModules(WindowsPdbFile windowsPdbFile);
    public static string GeneratePdbSignatureString(DebugInfo debugInfo);
    public static string GeneratePdbSignatureString(DebugInfo7 debugInfo7);
    public static string GeneratePdbSignatureString(Guid pdbSignature, UInt32 pdbAge);
    public static string GeneratePdbEmptySignatureString();
    public static string GetPdbFileName(DebugInfo debugInfo);
    public static string GetPdbFileNameWithoutExtension(DebugInfo debugInfo);
    public static string GetPdbFileNameWithoutExtension(string pdbFile);
    [CanBeNullAttribute]
public static DebugInfo TryGetLastWindowsDebugInfo(FileSystemPath pePath);
    [CanBeNullAttribute]
public static DebugInfo TryGetLastWindowsDebugInfo(IList`1<DebugInfo> debugInfos);
    [CanBeNullAttribute]
public static DebugInfo TryGetLastAnyStandaloneDebugInfo(FileSystemPath pePath);
    [CanBeNullAttribute]
public static DebugInfo TryGetLastAnyStandaloneDebugInfo(IList`1<DebugInfo> debugInfos);
    [CanBeNullAttribute]
public static DebugInfo TryGetLastDebugInfoExceptDeterministic(IList`1<DebugInfo> debugInfos);
    [CanBeNullAttribute]
[ObsoleteAttribute("Use PdbUtils.TryGetLastStandaloneDebugInfo instead")]
public static DebugInfo7 TryGetLastDebugInfo7(FileSystemPath pePath);
    [ExtensionAttribute]
public static bool IsAnyStandaloneType(DebugInfo debugInfo);
    [ExtensionAttribute]
public static void WritePdb(DebugData debugData, FileSystemPath pdbPath, FileSystemPath assemblyPath, DebugInfo debugInfo);
    private static void LongPathWriteFileAction(FileSystemPath filePath, Action`1<FileSystemPath> writeFileAction);
    private static bool FilePathIsLong(FileSystemPath filePath);
    [CompilerGeneratedAttribute]
private static bool <OfAnyStandaloneType>b__3(DebugInfo debugInfo);
}
public class JetBrains.Metadata.Debug.Pdb.PdbVariable : object {
    private string myName;
    private UInt32 mySlotIndex;
    private UInt32 myLocalSignatureToken;
    public UInt32 SlotIndex { get; }
    public string Name { get; }
    public UInt32 LocalSignatureToken { get; }
    internal PdbVariable(AttrSlotSym attrSlotSym);
    public UInt32 get_SlotIndex();
    public string get_Name();
    public UInt32 get_LocalSignatureToken();
}
public class JetBrains.Metadata.Debug.Pdb.PdbXml : object {
    [NotNullAttribute]
private DebugData myDebugData;
    [CanBeNullAttribute]
private ParsedPdb myParsedPdb;
    [CanBeNullAttribute]
private FileSystemPath myPdbPath;
    [CanBeNullAttribute]
private FileSystemPath myAssemblyPath;
    public PdbXml(DebugData debugData, ParsedPdb parsedPdb, FileSystemPath pdbPath, FileSystemPath assemblyPath);
    private void DumpType2Files(XmlWriter writer);
    private void DumpSourceLink(XmlWriter writer);
    private void DumpSrcSrvInfo(XmlWriter writer);
    private void WritePdbAttributes(XmlWriter writer, bool includePathInfos);
    public void Dump(XmlWriter writer, bool includePathInfos, string rootElement);
    public static void Dump(DebugData debugData, XmlWriter writer);
    public void DumpToFile(FileSystemPath filePath);
}
public class JetBrains.Metadata.Debug.Pdb.PortablePdbFile : object {
    internal static int ModuleImportScopeRid;
    private ILReaderMetadataAccess myPdbMetadataAccess;
    private PdbStream myPdbStream;
    private TableManager myPdbTableManager;
    [CanBeNullAttribute]
private IMetadataAssembly myAssembly;
    [CanBeNullAttribute]
private IMetadataAccess myAssemblyMetadataAccess;
    private CompactOneToListMap`2<string, string> myType2Files;
    private SourceLink mySourceLink;
    private bool mySourceLinkAlreadyRead;
    private bool myMethodTablesAreConsistent;
    private int myMdiEndRid;
    [NotNullAttribute]
public ILReaderMetadataAccess PdbMetadataAccess { get; }
    [CanBeNullAttribute]
public CompactOneToListMap`2<string, string> Type2Files { get; }
    [CanBeNullAttribute]
public SourceLink SourceLink { get; }
    public PortablePdbFile(ILReaderMetadataAccess portablePdbMetadataAccess, IMetadataAssembly assembly);
    public ILReaderMetadataAccess get_PdbMetadataAccess();
    public CompactOneToListMap`2<string, string> get_Type2Files();
    public SourceLink get_SourceLink();
    public DebugData GetDebugData(FileSystemPath originalPdbFilePath);
    private ImportScope[] GetImportScopes();
    private IDictionary`2<Pair`2<MetadataToken, Guid>, ICustomDebugInformationData> GetCustomDebugInformations();
    private IDictionary`2<MetadataToken, MetadataToken> GetMoveNextToKickoff();
    public int TryGetDocumentIndex(string documentName);
    public IEnumerable`1<DebugDocument> GetDocuments();
    [NotNullAttribute]
internal IDictionary`2<string, int> GetDocumentNameToIndexDictionary();
    [CanBeNullAttribute]
public string TryGetEmbeddedSource(int documentIndex);
}
public class JetBrains.Metadata.Debug.Pdb.PortablePdbFileCookie : SafeDisposable {
    private LifetimeDefinition myDefinition;
    [CompilerGeneratedAttribute]
private PortablePdbFile <Pdb>k__BackingField;
    [CanBeNullAttribute]
public PortablePdbFile Pdb { get; private set; }
    public PortablePdbFileCookie(FileSystemPath pdbPath, DebugInfoType type, FileSystemPath assemblyPath);
    [CompilerGeneratedAttribute]
public PortablePdbFile get_Pdb();
    [CompilerGeneratedAttribute]
private void set_Pdb(PortablePdbFile value);
    protected virtual void DisposeUnmanagedResources();
}
public class JetBrains.Metadata.Debug.Pdb.SrcSrv.SourceLink : object {
    private static char Wildcard;
    private static string WildcardString;
    public static string SourceLinkJsonFileName;
    private SourceLinkConversionRules myConversionRules;
    private bool myInvalidRules;
    public SourceLink(string sourceLinkJson);
    private SourceLink(IDictionary`2<string, string> conversionRules);
    public string GetUri(string filePath);
    [CanBeNullAttribute]
public SourceLocation GetFileLocation(string filePathFromPdb, string cacheItemRelativePath);
    public void WriteTo(UnsafeWriter writer);
    [NotNullAttribute]
public static SourceLink ReadFrom(UnsafeReader reader);
    public void DumpSelf(TextWriter writer, int indent);
    public void DumpToXml(XmlWriter writer);
}
public class JetBrains.Metadata.Debug.Pdb.SrcSrv.SourceLocation : object {
    private Func`2<string, string> myLocalPathGenerator;
    private string myLocalPath;
    private SourceLocationKind myLocationKind;
    private Func`2<string, string> myLocationGenerator;
    private string myLocation;
    public SourceLocationKind LocationKind { get; }
    public SourceLocation(string localPath, SourceLocationKind locationKind, string location);
    public SourceLocation(Func`2<string, string> localPathGenerator, SourceLocationKind locationKind, Func`2<string, string> locationGenerator);
    public string GetLocalPath(string cacheDirectory);
    public SourceLocationKind get_LocationKind();
    public string GetLocation(string cacheDirectory);
}
[ExtensionAttribute]
public static class JetBrains.Metadata.Debug.Pdb.SrcSrv.SourceLocationHelper : object {
    [ExtensionAttribute]
public static FileSystemPath GetLocalPath(SourceLocation sourceLocation, FileSystemPath cacheDirectory);
}
public enum JetBrains.Metadata.Debug.Pdb.SrcSrv.SourceLocationKind : Enum {
    public int value__;
    public static SourceLocationKind PATH;
    public static SourceLocationKind CMD;
    public static SourceLocationKind HTTP;
}
public class JetBrains.Metadata.Debug.Pdb.SrcSrv.SrcSrvInfo : object {
    private static HashSet`1<char> ourInvalidPathChars;
    private String[] myFileComponents;
    private IDictionary`2<string, Int32[]> myFileNameToFileComponentsMapping;
    private IDictionary`2<string, string> myIni;
    private IDictionary`2<string, string> myVariables;
    private IDictionary`2<string, string> myInitialContext;
    [CompilerGeneratedAttribute]
private static Func`2<string, string> CS$<>9__CachedAnonymousMethodDelegate5;
    [CompilerGeneratedAttribute]
private static Func`2<char, bool> CS$<>9__CachedAnonymousMethodDelegate11;
    public String[] FileComponents { get; }
    public IDictionary`2<string, string> Ini { get; }
    public IDictionary`2<string, string> Variables { get; }
    public SrcSrvInfo(IEnumerable`1<KeyValuePair`2<string, string>> ini, IEnumerable`1<KeyValuePair`2<string, string>> variables, String[] fileComponents);
    private static SrcSrvInfo();
    public String[] get_FileComponents();
    private static IDictionary`2<string, Int32[]> BuildFileNameToFileComponentsMapping(String[] components);
    public IDictionary`2<string, string> get_Ini();
    public IDictionary`2<string, string> get_Variables();
    private static string GetFileNameFunc(string name);
    private static string ParseString(string val, IDictionary`2<string, string> context, string targ, bool isTfHack);
    private static string ProcessEscapes(string val);
    [CanBeNullAttribute]
private static string GetVariableValue(string var, IDictionary`2<string, string> context, string targ, bool isTFHack);
    private static String[] SplitComponents(string components);
    [NotNullAttribute]
private static FileSystemPath GetFileNameFromComponents(string components);
    private Int32[] GetPossibleMappingForFileName(string fileName);
    public bool MayHaveMappingFor(string shortFileName);
    public bool IsOurLocalPath(FileSystemPath localPath, string cacheDirectory);
    [CanBeNullAttribute]
public FileSystemPath TryGetOriginalSourcePath(FileSystemPath sourcePathInCache, FileSystemPath cacheDirectory);
    private static string NormalizeLocalPath(string localPath);
    private static IDictionary`2<string, string> GetEnvironmentContext();
    [CanBeNullAttribute]
public SourceLocation GetFileLocation(FileSystemPath srcPath);
    private static string EscapePath(string srcsrvtrg);
    public void WriteTo(UnsafeWriter writer);
    [NotNullAttribute]
public static SrcSrvInfo ReadFrom(UnsafeReader reader);
    private int GetIndexBySourceName(FileSystemPath srcPath);
    private static IDictionary`2<string, string> ContextCombine(IDictionary`2<string, string> context, IEnumerable`1<KeyValuePair`2<string, string>> secondContext);
    private static IDictionary`2<string, string> CreateContext(IEnumerable`1<KeyValuePair`2<string, string>> contextSource);
    private IDictionary`2<string, string> CreateContextFromSourceName(FileSystemPath srcPath);
    public void DumpSelf(TextWriter writer, int indent, int maxComponentsToDump);
    public void DumpToXml(XmlWriter writer);
    public int GetByteCount(Encoding encoding);
    [CompilerGeneratedAttribute]
private static string <ParseString>b__1(string x);
    [CompilerGeneratedAttribute]
private static bool <.cctor>b__10(char x);
}
public class JetBrains.Metadata.Debug.Pdb.SrcSrv.SrcSrvInfoParser : object {
    private static void ReadKeyValue(string line, IDictionary`2<string, string> dictionary);
    public static SrcSrvInfo ParsePdbStream(TextReader stream);
}
internal static class JetBrains.Metadata.Debug.Pdb.SymbolWriter.CustomDebugInformationBlobEncoder : object {
    public static BlobBuilder EncodeAsyncMethodSteppingInformation(AsyncMethodSteppingInformationData asyncMethodSteppingInformation);
    public static BlobBuilder EncodeStateMachineHoistedLocalScopes(StateMachineHoistedLocalScopesData methodStateMachineHoistedLocalScopes);
    public static BlobBuilder EncodeTupleElementNames(TupleElementNamesData tupleElementNames);
}
internal class JetBrains.Metadata.Debug.Pdb.SymbolWriter.MethodCustomDebugInformationEncoder : object {
    private BlobBuilder myBlobBuilder;
    private Blob myRecordCountBlob;
    private int myRecordCount;
    public MethodCustomDebugInformationEncoder(BlobBuilder blobBuilder);
    public void AddStateMachineTypeName(string stateMachineTypeName);
    public void AddStateMachineHoistedLocalScopes(StateMachineHoistedLocalScopesData stateMachineHoistedLocalScopes);
    [CanBeNullAttribute]
public Byte[] ToArray();
    private void SerializeCustomDebugInformation(CustomDebugInfoKind kind, Action`1<BlobBuilder> serialize);
}
public class JetBrains.Metadata.Debug.Pdb.SymbolWriter.PortablePdbWriter : object {
    private DebugData myDebugData;
    private ILReaderMetadataAccess myAssembly;
    private MetadataBuilder myTablesAndHeaps;
    private MethodDefinitionHandle myEntryPoint;
    private Dictionary`2<int, DocumentHandle> myDocuments;
    private Dictionary`2<ImportScope, ImportScopeHandle> myImportScopes;
    private LocalVariableHandle myLastLocalVariableHandle;
    private LocalConstantHandle myLastLocalConstantHandle;
    private PortablePdbWriter(DebugData debugData, ILReaderMetadataAccess assembly);
    private void BuildPortablePdbTablesAndHeaps();
    private void AddMethodCustomDebugInformation(DebugMethod method);
    private void BuildDocumentTable();
    private void AddDefaultMethodDebugInformation();
    private void AddMethodDebugInformation(DebugMethod method);
    private void AddLocalScopes(MethodDefinitionHandle methodHandle, LocalScope scope);
    private void AddLocalVariable(DebugLocalVariable localVariable);
    private LocalVariableHandle NextLocalVariableHandle();
    private LocalConstantHandle NextLocalConstantHandle();
    private void DefineModuleImportScope();
    private ImportScopeHandle GetImportScopeHandle(ImportScope importScope);
    private BlobHandle SerializeImportsBlob(ImportScope importScope);
    private void SerializeImport(BlobBuilder writer, Import import);
    private void WriteContentTo(Stream pdbStream, Guid signature, UInt32 timestamp);
    public static void Write(DebugData debugData, FileSystemPath pdbPath, FileSystemPath assemblyPath);
    public static void Write(DebugData debugData, FileSystemPath pdbPath, FileSystemPath assemblyPath, Guid signature, UInt32 timestamp);
}
internal class JetBrains.Metadata.Debug.Pdb.SymbolWriter.UnmanagedSymbolWriterOwner : object {
    [CompilerGeneratedAttribute]
private ISymUnmanagedWriter <Writer>k__BackingField;
    public ISymUnmanagedWriter Writer { get; private set; }
    public UnmanagedSymbolWriterOwner(FileSystemPath pdbPath, FileSystemPath assemblyPath);
    [CompilerGeneratedAttribute]
public ISymUnmanagedWriter get_Writer();
    [CompilerGeneratedAttribute]
private void set_Writer(ISymUnmanagedWriter value);
    [CanBeNullAttribute]
private static IMetaDataEmit CreateEmitter(FileSystemPath assemblyPath);
    private static bool IsWinMd(FileSystemPath assemblyPath);
    public sealed virtual void Dispose();
}
public static class JetBrains.Metadata.Debug.Pdb.SymbolWriter.WindowsPdbWriter : object {
    public static void Write(DebugData debugData, FileSystemPath pdbPath, FileSystemPath assemblyPath);
    public static void Write(DebugData debugData, FileSystemPath pdbPath, FileSystemPath assemblyPath, Guid signature, UInt32 age);
    private static void UnguardedWrite(DebugData debugData, FileSystemPath pdbPath, FileSystemPath assemblyPath, Guid signature, UInt32 age);
    public static void PatchPdb(FileSystemPath pdbPath, Guid newSignature, UInt32 newAge);
    private static ISymUnmanagedDocumentWriter WriteSourceFile(DebugDocument sourceFile, ISymUnmanagedWriter writer);
    private static void WriteMethod(DebugMethod method, ISymUnmanagedWriter writer, Dictionary`2<int, ISymUnmanagedDocumentWriter> documentIndexToDocumentWriter);
    private static void OpenMethod(DebugMethod method, ISymUnmanagedWriter writer);
    private static void CloseMethod(DebugMethod method, ISymUnmanagedWriter writer);
    private static void WriteImports(ImportScope methodImportScope, ISymUnmanagedWriter writer);
    private static void WriteSequencePoints(DebugMethod method, ISymUnmanagedWriter writer, Dictionary`2<int, ISymUnmanagedDocumentWriter> documentIndexToDocumentWriter);
    private static void WriteMethodCustomDebugInformation(DebugMethod method, ISymUnmanagedWriter writer);
    private static void WriteCustomMetadata(Byte[] customMetadata, MetadataToken parent, ISymUnmanagedWriter writer);
    private static void WriteScope(LocalScope scope, ISymUnmanagedWriter writer);
    private static void WriteLocalVariable(DebugLocalVariable localVariable, ISymUnmanagedWriter writer);
}
internal static class JetBrains.Metadata.Debug.Pdb.WindowsPdbCustomDebugInfo : object {
    public static byte Version;
    public static void WriteStateMachineTypeName(BlobBuilder writer, string stateMachineTypeName);
    [NotNullAttribute]
public static string ReadStateMachineTypeName(IBinaryReader reader);
    public static void WriteStateMachineHoistedLocalScopes(BlobBuilder writer, StateMachineHoistedLocalScopesData stateMachineHoistedLocalScopes);
    [NotNullAttribute]
public static StateMachineHoistedLocalScopesData ReadStateMachineHoistedLocalScopes(IBinaryReader reader);
    public static void WriteKickoffMethod(ISymUnmanagedAsyncMethodPropertiesWriter writer, MetadataToken kickoffMethod);
    public static MetadataToken ReadKickoffMethod(IBinaryReader reader);
    public static void WriteAsyncMethodSteppingInformation(ISymUnmanagedAsyncMethodPropertiesWriter writer, AsyncMethodSteppingInformationData asyncMethodSteppingInformation);
    [NotNullAttribute]
public static AsyncMethodSteppingInformationData ReadAsyncMethodSteppingInformation(IBinaryReader reader);
    public static UInt16[] ReadUsingInfo(IBinaryReader moduleStream);
    public static void WriteString(BlobBuilder writer, string s);
    [NotNullAttribute]
public static string ReadString(IBinaryReader reader);
    private static MetadataToken ReadToken(IBinaryReader reader);
}
public class JetBrains.Metadata.Debug.Pdb.WindowsPdbFile : object {
    private static string SrcsrvStreamName;
    private static string NamesStreamName;
    private static string SrcFilesStreamPrefix;
    private static string SrcFilesStreamName;
    private static string SourcelinkStreamName;
    private static int ourSrcFilesStreamPrefixLength;
    private PdbHeader myHeader;
    private Stream myPdbStream;
    private PdbToc myTableOfContents;
    private ReadOnlyDictionary`2<string, int> myNameIndex;
    private ReadOnlyDictionary`2<int, string> myNameStream;
    private SourceFileInfo mySourceFileInfo;
    private bool mySourceFileInfoLoadStatements;
    private DebugData myCachedDebugData;
    private PdbParseLevel myCachedDebugDataParseLevel;
    private FileSystemPath myCachedDebugDataPath;
    private DbiStreamInfo myDbi;
    public PdbHeader Header { get; }
    [ObsoleteAttribute("Use IPdbStreamBuilder member for get pdb stream")]
[NotNullAttribute]
public ReadOnlyDictionary`2<string, int> NameIndex { get; }
    [ObsoleteAttribute("Use IPdbStreamBuilder member for get pdb stream")]
[NotNullAttribute]
public ReadOnlyDictionary`2<int, string> NameStream { get; }
    [NotNullAttribute]
public DbiStreamInfo Dbi { get; }
    public WindowsPdbFile(Stream pdbStream);
    private static WindowsPdbFile();
    public PdbHeader get_Header();
    public ReadOnlyDictionary`2<string, int> get_NameIndex();
    public ReadOnlyDictionary`2<int, string> get_NameStream();
    [NotNullAttribute]
private ReadOnlyDictionary`2<string, int> GetNameIndexDictionary();
    private void ReadStreamNames(ChunkHashMap`2<string, int> streamNameToIndex, Dictionary`2<string, int> sourceFiles);
    [NotNullAttribute]
private ReadOnlyDictionary`2<int, string> GetNamesStreamDictionary();
    [CanBeNullAttribute]
private Stream GetNamedPdbStream(string streamName);
    public sealed virtual Stream GetSrcSrvStream();
    public sealed virtual Stream GetNamesStream();
    public sealed virtual Stream GetSrcFileStream(string name);
    [CanBeNullAttribute]
private Stream GetSourcelinkStream();
    public sealed virtual Stream GetDbiStream();
    public sealed virtual string GetStreamName(int name);
    public DbiStreamInfo get_Dbi();
    [NotNullAttribute]
public PdbRootRecord GetRoot();
    [NotNullAttribute]
public Stream GetRootStream();
    [NotNullAttribute]
private Stream GetIndexPdbStream(int streamIndex);
    [CanBeNullAttribute]
public DebugData GetDebugData(PdbParseLevel level, FileSystemPath originalPdbFilePath);
    [CanBeNullAttribute]
public SrcSrvInfo GetSrcSrvInfo();
    [CanBeNullAttribute]
public SourceLink GetSourceLink();
    [NotNullAttribute]
public SourceFileInfo GetSourceFileInfo(bool loadStatements, CompactOneToListMap`2<PdbFunction, DebugDocument> functionToDocuments);
    private void LoadFunctionsFromDbiModule(ICollection`1<PdbFunction> functionCollector, CompactOneToListMap`2<PdbFunction, DebugDocument> functionToDocuments, DbiModuleInfo module, bool loadStatements);
    public IDictionary`2<string, int> GetDocumentNameToIndexDictionary();
}
public class JetBrains.Metadata.Debug.SequencePoint : object {
    [CompilerGeneratedAttribute]
private int <IlOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StartLine>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StartColumn>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EndLine>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EndColumn>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsHidden>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DocumentIndex>k__BackingField;
    public int IlOffset { get; private set; }
    public int StartLine { get; private set; }
    public int StartColumn { get; private set; }
    public int EndLine { get; private set; }
    public int EndColumn { get; private set; }
    public bool IsHidden { get; private set; }
    public int DocumentIndex { get; private set; }
    public SequencePoint(int documentIndex, int ilOffset, int startLine, int startColumn, int endLine, int endColumn);
    [CompilerGeneratedAttribute]
public int get_IlOffset();
    [CompilerGeneratedAttribute]
private void set_IlOffset(int value);
    [CompilerGeneratedAttribute]
public int get_StartLine();
    [CompilerGeneratedAttribute]
private void set_StartLine(int value);
    [CompilerGeneratedAttribute]
public int get_StartColumn();
    [CompilerGeneratedAttribute]
private void set_StartColumn(int value);
    [CompilerGeneratedAttribute]
public int get_EndLine();
    [CompilerGeneratedAttribute]
private void set_EndLine(int value);
    [CompilerGeneratedAttribute]
public int get_EndColumn();
    [CompilerGeneratedAttribute]
private void set_EndColumn(int value);
    [CompilerGeneratedAttribute]
public bool get_IsHidden();
    [CompilerGeneratedAttribute]
private void set_IsHidden(bool value);
    [CompilerGeneratedAttribute]
public int get_DocumentIndex();
    [CompilerGeneratedAttribute]
private void set_DocumentIndex(int value);
    public static SequencePoint CreateHiddenSequencePoint(int documentIndex, int ilOffset);
    public virtual string ToString();
}
public class JetBrains.Metadata.Debug.SequencePointInMethod : object {
    [CompilerGeneratedAttribute]
private SequencePoint <SequencePoint>k__BackingField;
    [CompilerGeneratedAttribute]
private DebugMethod <Method>k__BackingField;
    [NotNullAttribute]
public SequencePoint SequencePoint { get; private set; }
    [NotNullAttribute]
public DebugMethod Method { get; private set; }
    public SequencePointInMethod(SequencePoint sequencePoint, DebugMethod method);
    [CompilerGeneratedAttribute]
public SequencePoint get_SequencePoint();
    [CompilerGeneratedAttribute]
private void set_SequencePoint(SequencePoint value);
    [CompilerGeneratedAttribute]
public DebugMethod get_Method();
    [CompilerGeneratedAttribute]
private void set_Method(DebugMethod value);
}
public interface JetBrains.Metadata.Debug.SequencePoints.ISequencePointInstructionRedirector {
    public abstract virtual int ToSequencePointInstructionIndex(int instructionIndex);
}
public class JetBrains.Metadata.Debug.SequencePoints.SequencePointInstructionRedirector : object {
    private Dictionary`2<int, Instruction> myOffsetToSequencePointInstruction;
    private Int32[] myIndexToSpIndex;
    public SequencePointInstructionRedirector(Instruction[] instructions, IMetadataMethod method);
    public sealed virtual Instruction Redirect(Instruction instruction);
    public sealed virtual int ToSequencePointInstructionIndex(int instructionIndex);
}
[ExtensionAttribute]
public static class JetBrains.Metadata.Debug.SequencePoints.SequencePointUtils : object {
    [ExtensionAttribute]
private static bool CheckBranchTarget(Instruction[] instructions, int instructionIndex, ICollection`1<int> regularSpOffsets);
    [ExtensionAttribute]
public static IEnumerable`1<int> GetHiddenSequencePointsOffsets(Instruction[] instructions, ICollection`1<int> regularSpOffsets, ISequencePointInstructionRedirector sequencePointInstructionRedirector);
}
public class JetBrains.Metadata.IL.AssemblyIlCode : IlCodeBase {
    private Dictionary`2<MetadataToken, IMetadataTypeInfo> myMethodTokenToType;
    [CompilerGeneratedAttribute]
private IMetadataAssembly <Assembly>k__BackingField;
    public IMetadataAssembly Assembly { get; private set; }
    public AssemblyIlCode(IMetadataAssembly metadataAssembly);
    [NotNullAttribute]
public IMetadataTypeInfo GetType(MetadataToken methodToken);
    [CompilerGeneratedAttribute]
public IMetadataAssembly get_Assembly();
    [CompilerGeneratedAttribute]
private void set_Assembly(IMetadataAssembly value);
}
internal class JetBrains.Metadata.IL.CodeBlocks.CatchIlCodeBlock : IlCodeBlock {
    [CompilerGeneratedAttribute]
private IMetadataType <CatchType>k__BackingField;
    public IMetadataType CatchType { get; private set; }
    public CatchIlCodeBlock(int startOffset, int endOffset, IMetadataType catchType);
    [CompilerGeneratedAttribute]
public IMetadataType get_CatchType();
    [CompilerGeneratedAttribute]
private void set_CatchType(IMetadataType value);
    protected virtual void RenderStartText(IlMetadataFormatter formatter);
    protected virtual string GetEndComment();
}
internal class JetBrains.Metadata.IL.CodeBlocks.CatchWithFilterIlCodeBlock : IlCodeBlock {
    public CatchWithFilterIlCodeBlock(int startOffset, int endOffset);
    protected virtual string GetStartComment();
    protected virtual string GetEndComment();
}
internal class JetBrains.Metadata.IL.CodeBlocks.FaultIlCodeBlock : IlCodeBlock {
    public FaultIlCodeBlock(int startOffset, int endOffset);
    protected virtual void RenderStartText(IlMetadataFormatter formatter);
    protected virtual string GetEndComment();
}
internal class JetBrains.Metadata.IL.CodeBlocks.FilterIlCodeBlock : IlCodeBlock {
    public FilterIlCodeBlock(int startOffset, int endOffset);
    protected virtual void RenderStartText(IlMetadataFormatter formatter);
    protected virtual string GetEndComment();
}
internal class JetBrains.Metadata.IL.CodeBlocks.FinallyIlCodeBlock : IlCodeBlock {
    public FinallyIlCodeBlock(int startOffset, int endOffset);
    protected virtual void RenderStartText(IlMetadataFormatter formatter);
    protected virtual string GetEndComment();
}
internal abstract class JetBrains.Metadata.IL.CodeBlocks.IlCodeBlock : object {
    protected static string StartOf;
    protected static string EndOf;
    private LinkedList`1<IlCodeBlock> mySortedChildren;
    [CompilerGeneratedAttribute]
private int <StartOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EndOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private IlCodeBlockType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private IlCodeBlock <Parent>k__BackingField;
    public int StartOffset { get; private set; }
    public int EndOffset { get; private set; }
    public IlCodeBlockType Type { get; private set; }
    [CanBeNullAttribute]
public IlCodeBlock Parent { get; public set; }
    protected bool WithBraces { get; }
    protected IlCodeBlock(IlCodeBlockType type, int startOffset, int endOffset);
    [CompilerGeneratedAttribute]
public int get_StartOffset();
    [CompilerGeneratedAttribute]
private void set_StartOffset(int value);
    [CompilerGeneratedAttribute]
public int get_EndOffset();
    [CompilerGeneratedAttribute]
private void set_EndOffset(int value);
    [CompilerGeneratedAttribute]
public IlCodeBlockType get_Type();
    [CompilerGeneratedAttribute]
private void set_Type(IlCodeBlockType value);
    [CompilerGeneratedAttribute]
public IlCodeBlock get_Parent();
    [CompilerGeneratedAttribute]
public void set_Parent(IlCodeBlock value);
    public void AddChild(IlCodeBlock child);
    protected virtual bool AllowAdding(IlCodeBlock child);
    private bool ContainsBlockRange(IlCodeBlock block);
    private void MoveChildrenToNewParent(IlCodeBlock newParent, List`1<LinkedListNode`1<IlCodeBlock>> children);
    public virtual bool IsValid();
    protected virtual void MarkInvalid();
    public void RemoveInvalid();
    private void Remove();
    protected void RenderIndented(IlMetadataFormatter formatter, bool increase, IMethodBody methodBody, Int32& currentInstructionIndex);
    private void RenderBraceAndComment(IlMetadataFormatter formatter, bool start, string comment);
    private static void RenderInstructionRange(IlMetadataFormatter formatter, int rangeStartOffset, int rangeEndOffset, IMethodBody methodBody, Int32& currentInstructionIndex);
    protected virtual void RenderStartText(IlMetadataFormatter formatter);
    [CanBeNullAttribute]
protected virtual string GetStartComment();
    [CanBeNullAttribute]
protected virtual string GetEndComment();
    protected virtual bool get_WithBraces();
}
public enum JetBrains.Metadata.IL.CodeBlocks.IlCodeBlockType : Enum {
    public int value__;
    public static IlCodeBlockType MethodBody;
    public static IlCodeBlockType Try;
    public static IlCodeBlockType Catch;
    public static IlCodeBlockType Finally;
    public static IlCodeBlockType Fault;
    public static IlCodeBlockType Filter;
    public static IlCodeBlockType CatchWithFilter;
    public static IlCodeBlockType Loop;
}
internal class JetBrains.Metadata.IL.CodeBlocks.IlLoopDetector : object {
    private Instruction[] myInstructions;
    private Dictionary`2<int, int> myOffsetToIndex;
    private List`1<Jump> myJumps;
    private List`1<Loop> myLoops;
    public IlLoopDetector(Instruction[] instructions);
    public int GetIndent(int instructionOffset);
    private void FindLoops();
    public void AddLoopsToBody(MethodBodyIlCodeBlock body);
}
internal class JetBrains.Metadata.IL.CodeBlocks.LoopIlCodeBlock : IlCodeBlock {
    private bool myIsValid;
    [CompilerGeneratedAttribute]
private int <EntryPointOffset>k__BackingField;
    public int EntryPointOffset { get; private set; }
    protected bool WithBraces { get; }
    public LoopIlCodeBlock(int startOffset, int endOffset, int entryPointOffset);
    [CompilerGeneratedAttribute]
public int get_EntryPointOffset();
    [CompilerGeneratedAttribute]
private void set_EntryPointOffset(int value);
    protected virtual bool AllowAdding(IlCodeBlock child);
    public virtual bool IsValid();
    protected virtual void MarkInvalid();
    protected virtual bool get_WithBraces();
    protected virtual string GetStartComment();
    protected virtual string GetEndComment();
}
internal class JetBrains.Metadata.IL.CodeBlocks.MethodBodyIlCodeBlock : IlCodeBlock {
    protected bool WithBraces { get; }
    private MethodBodyIlCodeBlock(int startOffset, int endOffset);
    public static MethodBodyIlCodeBlock Create(IMethodBody methodBody);
    public void RenderIndented(IMethodBody methodBody, IlMetadataFormatter formatter);
    protected virtual bool get_WithBraces();
}
internal static class JetBrains.Metadata.IL.CodeBlocks.MethodBodyStructureBuilder : object {
    public static MethodBodyIlCodeBlock Build(IMethodBody methodBody, bool detectLoops);
}
internal class JetBrains.Metadata.IL.CodeBlocks.TryIlCodeBlock : IlCodeBlock {
    public TryIlCodeBlock(int startOffset, int endOffset);
    protected virtual bool AllowAdding(IlCodeBlock child);
    protected virtual void RenderStartText(IlMetadataFormatter formatter);
    protected virtual string GetEndComment();
}
public class JetBrains.Metadata.IL.ExceptionHandler : object {
    private int myCatchBlockLen;
    private int myCatchOffset;
    private MetadataToken myCatchTypeToken;
    private int myFilterOffset;
    private int myTryBlockLen;
    private int myTryOffset;
    private ExceptionHandlerType myType;
    public ExceptionHandlerType Type { get; }
    public int TryOffset { get; }
    public int TryLength { get; }
    public int HandlerOffset { get; }
    public int HandlerLength { get; }
    public int FilterOffset { get; }
    public MetadataToken CatchTypeToken { get; }
    internal ExceptionHandler(ExceptionHandlerType type, int tryOffset, int tryLength, int handlerOffset, int handlerLength);
    internal ExceptionHandler(ExceptionHandlerType type, int tryOffset, int tryLength, int handlerOffset, int handlerLength, int filterOffset);
    internal ExceptionHandler(ExceptionHandlerType type, int tryOffset, int tryLength, int handlerOffset, int handlerLength, MetadataToken catchType);
    public ExceptionHandlerType get_Type();
    public int get_TryOffset();
    public int get_TryLength();
    public int get_HandlerOffset();
    public int get_HandlerLength();
    public int get_FilterOffset();
    public MetadataToken get_CatchTypeToken();
}
public class JetBrains.Metadata.IL.ExceptionHandlersComparer : object {
    public static IComparer`1<IMethodBodyExceptionHandler> Instance;
    private static ExceptionHandlersComparer();
    public sealed virtual int Compare(IMethodBodyExceptionHandler x, IMethodBodyExceptionHandler y);
    private static bool ContainedIn(IMethodBodyExceptionHandler what, IMethodBodyExceptionHandler where);
    private static bool ContainedIn(IMethodBodyExceptionHandler what, int startOffset, int endOffset);
}
public enum JetBrains.Metadata.IL.ExceptionHandlerType : Enum {
    public int value__;
    public static ExceptionHandlerType Fault;
    public static ExceptionHandlerType Catch;
    public static ExceptionHandlerType Finally;
    public static ExceptionHandlerType CatchWithFilter;
}
public enum JetBrains.Metadata.IL.FlowControl : Enum {
    public int value__;
    public static FlowControl ConditionalBranch;
    public static FlowControl Next;
    public static FlowControl Return;
    public static FlowControl Throw;
    public static FlowControl Break;
    public static FlowControl Branch;
    public static FlowControl Call;
    public static FlowControl Meta;
    public static FlowControl Switch;
}
public interface JetBrains.Metadata.IL.IInstructionRedirector {
    public abstract virtual Instruction Redirect(Instruction instruction);
}
public class JetBrains.Metadata.IL.IlCodeBase : object {
    private Dictionary`2<MetadataToken, IMethodBody> myMethodTokenToMethodBody;
    protected void AddMethod(MetadataToken methodToken, IMethodBody methodBody);
    [NotNullAttribute]
public IMethodBody GetMethodBody(MetadataToken methodToken);
    public IEnumerable`1<MetadataToken> Methods();
    [NotNullAttribute]
public Instruction[] GetInstructions(MetadataToken methodToken);
    [NotNullAttribute]
public Instruction GetInstruction(MetadataToken methodToken, int instructionIndex);
    [NotNullAttribute]
public Instruction GetInstructionAndIndex(MetadataToken methodToken, int ilOffset, Int32& instructionIndex);
    public int GetMethodInstructionsCount(MetadataToken methodToken);
}
public class JetBrains.Metadata.IL.IlCodeOffsetMarker : object {
    public int Offset;
    public IlCodeOffsetMarker(int offset);
}
public class JetBrains.Metadata.IL.IlImageBodyAccess : object {
    private IBinaryReader myImageReader;
    private IMetadataAccess myMetadata;
    private PEFile myPeFile;
    public IlImageBodyAccess(IBinaryReader imageReader, IMetadataAccess metadata);
    [CanBeNullAttribute]
public ILMethodBody GetMethodBody(IMetadataMethod metadataMethod);
    [CanBeNullAttribute]
public Byte[] GetFieldInitialValue(MetadataToken fieldToken, int valueSize);
}
public static class JetBrains.Metadata.IL.IlKeywords : object {
    public static string DotAddon;
    public static string DotAssembly;
    public static string DotCctor;
    public static string DotClass;
    public static string DotCorflags;
    public static string DotCtor;
    public static string DotCulture;
    public static string DotCustom;
    public static string DotData;
    public static string DotEmitbyte;
    public static string DotEntrypoint;
    public static string DotEvent;
    public static string DotExport;
    public static string DotField;
    public static string DotFile;
    public static string DotFire;
    public static string DotGet;
    public static string DotHash;
    public static string DotImagebase;
    public static string DotImport;
    public static string DotLanguage;
    public static string DotLine;
    public static string SharpLine;
    public static string DotLocale;
    public static string DotLocals;
    public static string DotManifestres;
    public static string DotMaxstack;
    public static string DotMethod;
    public static string DotModule;
    public static string DotMresource;
    public static string DotNamespace;
    public static string DotOther;
    public static string DotOverride;
    public static string DotPack;
    public static string DotParam;
    public static string DotPdirect;
    public static string DotPermission;
    public static string DotPermissionset;
    public static string DotProperty;
    public static string DotPublickey;
    public static string DotPublickeytoken;
    public static string DotRemoveon;
    public static string DotSet;
    public static string DotSize;
    public static string DotStackreserve;
    public static string DotSubsystem;
    public static string DotTry;
    public static string DotVer;
    public static string DotVtable;
    public static string DotVtentry;
    public static string DotVtfixup;
    public static string DotZeroinit;
    public static string Abstract;
    public static string Algorithm;
    public static string Alignment;
    public static string Ansi;
    public static string Any;
    public static string Array;
    public static string As;
    public static string Assembly;
    public static string At;
    public static string Auto;
    public static string Autochar;
    public static string Beforefieldinit;
    public static string Blob;
    public static string BlobObject;
    public static string Bool;
    public static string Bstr;
    public static string Bytearray;
    public static string Byvalstr;
    public static string Callmostderived;
    public static string Carray;
    public static string Catch;
    public static string Cdecl;
    public static string Cf;
    public static string Char;
    public static string Cil;
    public static string Class;
    public static string Clsid;
    public static string Compilercontrolled;
    public static string Const;
    public static string Currency;
    public static string Custom;
    public static string Date;
    public static string Decimal;
    public static string Default;
    public static string Enum;
    public static string Error;
    public static string Explicit;
    public static string Extends;
    public static string Extern;
    public static string False;
    public static string Famandassem;
    public static string Family;
    public static string Famorassem;
    public static string Fastcall;
    public static string Fault;
    public static string Field;
    public static string Filetime;
    public static string Filter;
    public static string Final;
    public static string Finally;
    public static string Fixed;
    public static string Float;
    public static string Float32;
    public static string Float64;
    public static string Forwarder;
    public static string Forwardref;
    public static string Fromunmanaged;
    public static string Handler;
    public static string Hassecurity;
    public static string Hidebysig;
    public static string Hresult;
    public static string Hstring;
    public static string Idispatch;
    public static string Iinspectable;
    public static string Il;
    public static string Illegal;
    public static string Implements;
    public static string Implicitcom;
    public static string Implicitres;
    public static string Import;
    public static string In;
    public static string Init;
    public static string Initonly;
    public static string Instance;
    public static string Int;
    public static string Int16;
    public static string Int32;
    public static string Int64;
    public static string Int8;
    public static string Interface;
    public static string Internalcall;
    public static string Iunknown;
    public static string Lasterr;
    public static string Lcid;
    public static string Literal;
    public static string Lpstr;
    public static string Lpstruct;
    public static string Lptstr;
    public static string Lpvoid;
    public static string Lpwstr;
    public static string Managed;
    public static string Marshal;
    public static string Method;
    public static string Modopt;
    public static string Modreq;
    public static string Native;
    public static string Nested;
    public static string Newslot;
    public static string Noappdomain;
    public static string Noinlining;
    public static string Nomachine;
    public static string Nomangle;
    public static string Nometadata;
    public static string Noncasdemand;
    public static string Noncasinheritance;
    public static string Noncaslinkdemand;
    public static string Nooptimization;
    public static string Noprocess;
    public static string NotInGcHeap;
    public static string Notremotable;
    public static string Notserialized;
    public static string Null;
    public static string Nullref;
    public static string Object;
    public static string Objectref;
    public static string Opt;
    public static string Optil;
    public static string Out;
    public static string Pinned;
    public static string Pinvokeimpl;
    public static string Prefix1;
    public static string Prefix2;
    public static string Prefix3;
    public static string Prefix4;
    public static string Prefix5;
    public static string Prefix6;
    public static string Prefix7;
    public static string Prefixref;
    public static string Preservesig;
    public static string Private;
    public static string Privatescope;
    public static string Property;
    public static string Protected;
    public static string Public;
    public static string Record;
    public static string Refany;
    public static string Retval;
    public static string Rtspecialname;
    public static string Runtime;
    public static string Safearray;
    public static string Sealed;
    public static string Sequential;
    public static string Serializable;
    public static string Special;
    public static string Specialname;
    public static string Static;
    public static string Stdcall;
    public static string Storage;
    public static string StoredObject;
    public static string Stream;
    public static string StreamedObject;
    public static string Strict;
    public static string String;
    public static string Struct;
    public static string Synchronized;
    public static string Syschar;
    public static string Sysstring;
    public static string Tbstr;
    public static string Thiscall;
    public static string Tls;
    public static string To;
    public static string True;
    public static string Type;
    public static string Typedref;
    public static string Unicode;
    public static string Unmanaged;
    public static string Unmanagedexp;
    public static string Unsigned;
    public static string Userdefined;
    public static string Value;
    public static string Valuetype;
    public static string Vararg;
    public static string Variant;
    public static string Vector;
    public static string Virtual;
    public static string Void;
    public static string Wchar;
    public static string Winapi;
    public static string With;
    public static string Wrapper;
    public static string Assert;
    public static string Demand;
    public static string Deny;
    public static string Inheritcheck;
    public static string Linkcheck;
    public static string Permitonly;
    public static string Reqmin;
    public static string Reqopt;
    public static string Reqrefuse;
    public static string Reqsecobj;
    public static string Request;
    public static string Prejitdeny;
    public static string Prejitgrant;
    public static string Uint16;
    public static string Uint32;
    public static string Uint64;
    public static string Uint8;
    public static HashSet`1<string> Keywords;
    private static IlKeywords();
}
public class JetBrains.Metadata.IL.IlMetadataFormatter : object {
    private static string ContravariantAttribute;
    private static string CovariantAttribute;
    private static string DefaultConstructorConstraint;
    private static string Params;
    private static string This;
    private static string Unresolved;
    protected CodeTextWithLineCommentsWriter myWriter;
    private IMetadataLocalVariablesNameProvider myLocalVariablesNameProvider;
    protected IMetadataAssembly myContainingAssembly;
    protected bool myShowMetadataTokenValues;
    private bool myShowLoops;
    private Dictionary`2<AssemblyNameInfo, MetadataToken> myAssemblyReferenceToToken;
    private Dictionary`2<Pair`2<string, AssemblyNameInfo>, MetadataToken> myTypeRefs;
    private int myMultilineCommentLevel;
    public IlMetadataFormatter(ICodeTextWriter writer, IMetadataAssembly containingAssembly, IMetadataLocalVariablesNameProvider localVariablesNameProvider, bool showMetadataTokenValues, bool showLoops);
    public void RenderMethodBody(IMethodBody methodBody);
    protected virtual void StartMethodBodyRendering(IMethodBody methodBody);
    protected virtual void EndMethodBodyRendering(IMethodBody methodBody);
    public void RenderLocalVariables(IMethodBody methodBody);
    private string GetLocalVariableName(IMethodBodyLocalVariable variable, int ilOffset);
    private string GetLocalVariableName(IMethodBody methodBody, int index, int ilOffset);
    private void RenderLocal(IMethodBodyLocalVariable variable);
    public void RenderMaxStack(IMethodBody methodBody);
    protected virtual void StartInstructionRendering(IMethodBody methodBody, Instruction instruction);
    internal void TryRenderInstruction(IMethodBody methodBody, Instruction instruction);
    private static void LogInstructionRenderingException(Exception ex, IMetadataMethod method, Instruction instruction);
    private void RenderInstruction(IMethodBody methodBody, Instruction instruction);
    private static string GetLabelName(int absOffset);
    private static string GetDataLabelName(UInt32 initialValueRva);
    private bool RenderTokenReference(object operand, bool isLdtokenInstructionOperand, MetadataToken operandToken);
    private void RenderFieldSpecification(FieldSpecification fieldSpecification, MetadataToken operandToken);
    private void RenderMethodInstantiation(MethodInstantiation methodInstantiation, MetadataToken operandToken);
    private void RenderMethodSignature(MethodSignature methodSignature, MetadataToken operandToken);
    private void RenderLocalVariableName(IMethodBody methodBody, Instruction instruction);
    private void RenderArgName(IMethodBody methodBody, int index);
    private static string GetArgName(IMethodBody methodBody, int index);
    private void RenderMarshallingInformation(IBlob marshalSpecBlob, bool spaceBefore);
    private void RenderNativeType(NativeType nativeType, IMarshalSpec marshalSpec);
    private void RenderVariantType(VariantType variantType);
    public void RenderType(IMetadataTypeInfo type, IImageBodyReader bodyReader);
    protected virtual void StartTypeRendering(IMetadataTypeInfo type);
    protected virtual void EndTypeRendering(IMetadataTypeInfo type);
    public void RenderClassHeader(IMetadataTypeInfo type);
    private void RenderClassAttributes(IMetadataTypeInfo type);
    internal void RenderType(IMetadataType type, IMetadataType[] methodGenericArguments, IMetadataType[] ownerTypeGenericArguments, MetadataToken hintTypeToken);
    internal void RenderTypeReference(IMetadataTypeInfo type, MetadataToken typeToken);
    private void RenderResolutionScope(AssemblyNameInfo assemblyName);
    private void RenderTypeSpec(IMetadataType type, IMetadataType[] methodGenericArguments, IMetadataType[] ownerTypeGenericArguments, MetadataToken hintTypeToken);
    private void RenderTypeMemberName(IMetadataTypeMember typeMember, bool fqn);
    internal void RenderDottedName(string s);
    internal void RenderId(string s);
    private bool IsKeyword(string s);
    private bool IsID(string s, bool dotSeparatedIDs);
    private void RenderQString(string s);
    private void RenderSqString(string s);
    private void RenderString(string value, bool useSingleQuote);
    private void RenderGenericParameters(IMetadataGenericArgument[] genericParameters);
    private void RenderGenPar(IMetadataGenericArgument genericParameter);
    private void RenderTypeParametersCustomAttributes(IMetadataGenericArgument[] genericParameters);
    private void RenderSecurityDecl(IMetadataSecurityOwner securityOwner);
    private void RenderSecAction(SecurityAction securityAction);
    private void RenderAttributeFieldInitialization(IMetadataCustomAttributeFieldInitialization initializedField, bool standardValueTypes);
    private void RenderAttributePropertyInitialization(IMetadataCustomAttributePropertyInitialization initializedProperty, bool standardValueTypes);
    private void RenderCustomAttributes(IMetadataEntity entity);
    private void RenderCustomType(IMetadataMethod constructor);
    private void RenderMetadataAttributeValue(MetadataAttributeValue metadataAttributeValue, bool standardValueTypes);
    private void RenderFieldInit(object value, bool standardValueTypes);
    private void RenderChar(char ch);
    private void RenderDouble(double operand, LiteralRenderStyle renderStyle);
    private void RenderFloat(float operand, LiteralRenderStyle renderStyle);
    private string GetHexRepresentation(double operand, LiteralRenderStyle renderStyle);
    private string GetHexRepresentation(float operand, LiteralRenderStyle renderStyle);
    private void RenderStringAsArray(string value);
    private void RenderBytearray(Byte[] bytes);
    private void RenderBytes(Byte[] bytes);
    private string GetBytesString(Byte[] bytes);
    private char ToPresentableChar(byte b);
    private char ToPresentableChar(char ch);
    private void RenderSpecialnameAttributes(IMetadataTypeMember typeMember);
    private void RenderAccessor(IMetadataMethod accessor, string directive);
    private void RenderCommentedTokenIfNeeded(MetadataToken token, bool withSpace);
    private void RenderCommentedTokenIfNeeded(IMetadataEntity tokenOwner, bool withSpace, MetadataToken hintToken);
    private MetadataToken GetTypeRefToken(IMetadataTypeInfo type);
    public void RenderMethod(IMetadataMethod method, IImageBodyReader bodyReader);
    protected virtual void StartMethodRendering(IMetadataMethod method);
    protected virtual void EndMethodRendering(IMetadataMethod method);
    private static bool IsEntryPointMethod(IMetadataMethod method);
    public void RenderMethodHeader(IMetadataMethod method);
    private void RenderMethodName(string name);
    private void RenderMethodAttributes(IMetadataMethod method);
    private void RenderPlatformInvoke(IMetadataMethod method);
    private void RenderCallConv(IMetadataMethod method);
    internal void RenderCallConv(MethodSignature methodSignature);
    private void RenderMethodReturnType(IMetadataMethod method, bool renderMarshallingInformation);
    private void RenderMethodParameters(IMetadataMethod method, bool renderNames, bool oneParameterPerLine, int paramCount);
    private void RenderMethodImplementationAttributes(IMetadataMethod method);
    private void RenderParametersDefaultValuesAndAttributes(IMetadataMethod method);
    private void RenderDefaultValueAndAttributes(int paramIndex, IMetadataEntity entity);
    private void RenderImplementedMethods(IMetadataMethod method);
    private void RenderEvent(IMetadataEvent event);
    protected virtual void StartEventRendering(IMetadataEvent event);
    protected virtual void EndEventRendering(IMetadataEvent event);
    public void RenderEventHeader(IMetadataEvent event);
    private void RenderField(IMetadataField field);
    public void RenderFieldHeader(IMetadataField field);
    protected virtual void StartFieldRendering(IMetadataField field);
    protected virtual void EndFieldRendering(IMetadataField field);
    private void RenderFieldDecl(IMetadataField field);
    private void RenderFieldAttributes(IMetadataField field);
    private void RenderProperty(IMetadataProperty property);
    protected virtual void StartPropertyRendering(IMetadataProperty property);
    protected virtual void EndPropertyRendering(IMetadataProperty property);
    public void RenderPropertyHeader(IMetadataProperty property);
    internal IDisposable WithMultiLineComment(bool spaceAfterComment);
    private IDisposable WithLineComment(bool writeNewLineAfterComment);
    protected internal void RenderLineComment(string comment, bool writeNewLineAfterComment);
    internal void WriteWithSpace(string text);
    [StringFormatMethodAttribute("format")]
internal void Write(string format, Object[] args);
    internal void Write(string text);
    [StringFormatMethodAttribute("format")]
internal void WriteTextWithLineComment(string format, Object[] args);
    internal void WriteNewLine();
    internal IDisposable WithIncreaseIndent(bool increase);
    private void RenderSeparated(T[] elements, Action`1<T> renderElement, bool newLine, int paramCount);
    [CompilerGeneratedAttribute]
private void <RenderMethodInstantiation>b__3(IMetadataType genericArgument);
    [CompilerGeneratedAttribute]
private void <RenderMethodSignature>b__8(IMetadataType parameterType);
    [CompilerGeneratedAttribute]
private void <RenderClassHeader>b__9(IMetadataClassType implementedInterface);
    [CompilerGeneratedAttribute]
private void <RenderGenPar>b__b(IMetadataType typeConstraint);
    [CompilerGeneratedAttribute]
private void <RenderSecurityDecl>b__d(IMetadataSecurityAttribute securityAttribute);
    [CompilerGeneratedAttribute]
private void <WithMultiLineComment>b__13();
    [CompilerGeneratedAttribute]
private void <WithLineComment>b__17();
}
public class JetBrains.Metadata.IL.IlMetadataTypeNameFormatter : object {
    public static string GenericParameterInType;
    public static string GenericParameterInMethod;
    private IlMetadataFormatter myIlFormatter;
    private IMetadataType[] myMethodGenericArguments;
    private IMetadataType[] myOwnerTypeGenericArguments;
    private bool myGenericArgumentReferenceTypeStop;
    public IlMetadataTypeNameFormatter(IlMetadataFormatter ilFormatter, IMetadataType[] methodGenericArguments, IMetadataType[] ownerTypeGenericArguments);
    private void RenderModifiers(IMetadataType metadataType);
    public sealed virtual void VisitUnknownType(IMetadataType unknownType);
    public sealed virtual void VisitArrayType(IMetadataArrayType arrayType);
    public sealed virtual void VisitClassType(IMetadataClassType classType);
    public sealed virtual void VisitPointerType(IMetadataPointerType pointerType);
    public sealed virtual void VisitReferenceType(IMetadataReferenceType referenceType);
    public sealed virtual void VisitGenericArgumentReferenceType(IMetadataGenericArgumentReferenceType genericArgumentReferenceType);
    public sealed virtual void VisitFunctionPointer(IMetadataFunctionPointerType functionPointerType);
}
public class JetBrains.Metadata.IL.ILMethodBody : object {
    private int myCodeSize;
    private ExceptionHandler[] myExceptions;
    private Instruction[] myInstructions;
    private MetadataToken myLocalVarsToken;
    private int myMaxStack;
    private ILMethodFlags myMethodFlags;
    public int MaxStack { get; }
    public int CodeSize { get; }
    public ILMethodFlags Flags { get; }
    public ExceptionHandler[] Exceptions { get; }
    public Instruction[] Instructions { get; }
    public MetadataToken LocalVarsToken { get; }
    internal ILMethodBody(int codeSize, int maxStack, MetadataToken localVarsToken, ExceptionHandler[] arExceptions, Instruction[] arInstructions, ILMethodFlags flags);
    public int get_MaxStack();
    public int get_CodeSize();
    public ILMethodFlags get_Flags();
    public ExceptionHandler[] get_Exceptions();
    public Instruction[] get_Instructions();
    public MetadataToken get_LocalVarsToken();
    public static Instruction DecodeInstruction(IMetadataAccess metadataAccess, BinaryReader reader);
    public static ILMethodBody DecodeMethodBody(IMetadataAccess metadataAccess, IBinaryReader reader);
}
internal class JetBrains.Metadata.IL.ILMethodBodyReader : object {
    private Byte[] myCode;
    private ILMethodFlags myFlags;
    private UInt32 myLocalsToken;
    private ushort myStackMax;
    private CodeSection myStartCodeSection;
    public ushort MaxStack { get; }
    public UInt32 LocalVarSigToken { get; }
    public Byte[] Code { get; }
    public ILMethodFlags Flags { get; }
    public Clause[] Clauses { get; }
    public ILMethodBodyReader(IBinaryReader reader);
    public ushort get_MaxStack();
    public UInt32 get_LocalVarSigToken();
    public Byte[] get_Code();
    public ILMethodFlags get_Flags();
    public Clause[] get_Clauses();
}
[FlagsAttribute]
public enum JetBrains.Metadata.IL.ILMethodFlags : Enum {
    public int value__;
    public static ILMethodFlags SmallCode;
    public static ILMethodFlags TinyCode;
    public static ILMethodFlags FatCode;
    public static ILMethodFlags CodeMask;
    public static ILMethodFlags InitLocals;
    public static ILMethodFlags MoreSects;
}
[ExtensionAttribute]
public static class JetBrains.Metadata.IL.IlRenderer : object {
    [ExtensionAttribute]
public static string GetOperandString(Instruction instruction);
    [ExtensionAttribute]
public static string GetInstructionString(Instruction instruction);
    [ExtensionAttribute]
public static string GetInstructionShortString(Instruction instruction);
    public static string PresentIlOffset(int ilOffset);
    [ExtensionAttribute]
public static ICodeTextWriter RenderIlInstruction(ICodeTextWriter writer, Instruction instruction);
}
public interface JetBrains.Metadata.IL.IMetadataLocalVariablesNameProvider {
    [CanBeNullAttribute]
public abstract virtual string GetVariableName(IMetadataMethod methodBody, int index);
    [CanBeNullAttribute]
public abstract virtual string GetVariableName(IMetadataMethod methodBody, int index, int ilOffset);
}
public class JetBrains.Metadata.IL.Instruction : object {
    [NotNullAttribute]
private Opcode myCode;
    private int myOffset;
    private int mySize;
    private object myOperand;
    public int Offset { get; }
    public int Size { get; }
    public Opcode Code { get; }
    public object Operand { get; }
    public Instruction(int offset, int size, Opcode code, object operand);
    public Instruction(Instruction instruction, object operand);
    public int get_Offset();
    public int get_Size();
    public Opcode get_Code();
    public object get_Operand();
    public sealed virtual Instruction Clone();
    private sealed virtual override object System.ICloneable.Clone();
    public virtual string ToString();
}
[ExtensionAttribute]
public static class JetBrains.Metadata.IL.InstructionEx : object {
    [ExtensionAttribute]
public static int GetInt32Operand(Instruction instruction);
    [ExtensionAttribute]
public static long GetInt64Operand(Instruction instruction);
    [ExtensionAttribute]
public static string GetStringOperand(Instruction instruction);
    [ExtensionAttribute]
public static float GetSingleOperand(Instruction instruction);
    [ExtensionAttribute]
public static double GetDoubleOperand(Instruction instruction);
    [ExtensionAttribute]
public static sbyte GetSByteOperand(Instruction instruction);
    [ExtensionAttribute]
public static MetadataToken GetTokenOperand(Instruction instruction);
    [ExtensionAttribute]
public static IMetadataType GetMetadataTypeOperand(Instruction instruction);
    [ExtensionAttribute]
public static FieldSpecification GetFieldSpecificationOperand(Instruction instruction);
    [ExtensionAttribute]
public static MethodSpecification GetMethodSpecificationOperand(Instruction instruction);
    [ExtensionAttribute]
public static MethodInstantiation GetMethodInstantiationOperand(Instruction instruction);
    [ExtensionAttribute]
public static Int32[] GetSwitchTargetsOperand(Instruction instruction);
    [ExtensionAttribute]
public static int GetBranchTargetOperand(Instruction instruction);
    [ExtensionAttribute]
public static int GetVariableIndexOperand(Instruction instruction);
    [ExtensionAttribute]
public static MethodSignature GetMethodSignatureOperand(Instruction instruction);
    [ExtensionAttribute]
public static int GetInstructionIndex(Instruction[] instructions, Instruction instruction);
    [ExtensionAttribute]
public static int GetInstructionIndexByOffset(Instruction[] instructions, int offset);
    [ExtensionAttribute]
public static int GetNextInstructionOffset(Instruction instruction);
    [ExtensionAttribute]
public static int GetBranchTargetInstructionOffset(Instruction instruction);
    [ExtensionAttribute]
public static Int32[] GetSwitchTargetInstructionsOffsets(Instruction switchInstruction);
}
[ExtensionAttribute]
public static class JetBrains.Metadata.IL.InstructionStackEx : object {
    [ExtensionAttribute]
public static int GetMinimumStackHeightForCallAndCallvirt(Instruction instruction);
    [ExtensionAttribute]
public static int GetMinimumStackHeightForNewobj(Instruction instruction);
    [ExtensionAttribute]
public static int GetMinimumStackHeightForCalli(Instruction instruction);
    private static int GetMinimumStackHeightForRet(IMetadataMethod method);
    [ExtensionAttribute]
private static int GetRequiredStackItemsForVarpop(Instruction instruction, IMetadataMethod method);
    [ExtensionAttribute]
public static int GetMinimumStackHeight(Instruction instruction, IMetadataMethod method);
    [ExtensionAttribute]
public static int GetStackPushItemsCount(Instruction instruction);
    [ExtensionAttribute]
private static int GetStackPushItemsForVarpush(Instruction instruction);
    [ExtensionAttribute]
public static int GetRequiredPrefixPushCount(Instruction instruction, IMetadataMethod method);
}
public class JetBrains.Metadata.IL.Opcode : object {
    public static byte MultiByteOpCodePrefix;
    private string myName;
    private OpcodeType myType;
    private OpcodeValue myValue;
    private OperandType myOperandType;
    private StackBehavior myPopBehavior;
    private StackBehavior myPushBehavior;
    private FlowControl myFlowControl;
    private int mySize;
    private bool myEndsUnconditionalJumpBlock;
    private int myStackChange;
    public int StackChange { get; }
    public bool IsEndsUnconditionalJumpBlock { get; }
    public OperandType OperandType { get; }
    public FlowControl FlowControl { get; }
    public OpcodeType OpcodeType { get; }
    public StackBehavior StackBehaviorPop { get; }
    public StackBehavior StackBehaviorPush { get; }
    public int Size { get; }
    public OpcodeValue Value { get; }
    public string Name { get; }
    internal Opcode(string name, StackBehavior popBehavior, StackBehavior pushBehavior, OperandType operandType, OpcodeType type, int size, OpcodeValue value, FlowControl flowControl, bool endsUnconditionalJumpBlock, int stackChange);
    public int get_StackChange();
    public bool get_IsEndsUnconditionalJumpBlock();
    public OperandType get_OperandType();
    public FlowControl get_FlowControl();
    public OpcodeType get_OpcodeType();
    public StackBehavior get_StackBehaviorPop();
    public StackBehavior get_StackBehaviorPush();
    public int get_Size();
    public OpcodeValue get_Value();
    public string get_Name();
    public static bool op_Equality(Opcode left, Opcode right);
    public static bool op_Inequality(Opcode left, Opcode right);
    public bool Equals(Opcode other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public static class JetBrains.Metadata.IL.OpcodeNames : object {
    public static string Add;
    public static string AddOvf;
    public static string AddOvfUn;
    public static string And;
    public static string Arglist;
    public static string Beq;
    public static string BeqS;
    public static string Bge;
    public static string BgeS;
    public static string BgeUn;
    public static string BgeUnS;
    public static string Bgt;
    public static string BgtS;
    public static string BgtUn;
    public static string BgtUnS;
    public static string Ble;
    public static string BleS;
    public static string BleUn;
    public static string BleUnS;
    public static string Blt;
    public static string BltS;
    public static string BltUn;
    public static string BltUnS;
    public static string BneUn;
    public static string BneUnS;
    public static string Box;
    public static string Br;
    public static string BrS;
    public static string Break;
    public static string Brfalse;
    public static string BrfalseS;
    public static string Brtrue;
    public static string BrtrueS;
    public static string Call;
    public static string Calli;
    public static string Callvirt;
    public static string Castclass;
    public static string Ceq;
    public static string Cgt;
    public static string CgtUn;
    public static string Ckfinite;
    public static string Clt;
    public static string CltUn;
    public static string Constrained;
    public static string ConvI;
    public static string ConvI1;
    public static string ConvI2;
    public static string ConvI4;
    public static string ConvI8;
    public static string ConvOvfI;
    public static string ConvOvfIUn;
    public static string ConvOvfI1;
    public static string ConvOvfI1Un;
    public static string ConvOvfI2;
    public static string ConvOvfI2Un;
    public static string ConvOvfI4;
    public static string ConvOvfI4Un;
    public static string ConvOvfI8;
    public static string ConvOvfI8Un;
    public static string ConvOvfU;
    public static string ConvOvfUUn;
    public static string ConvOvfU1;
    public static string ConvOvfU1Un;
    public static string ConvOvfU2;
    public static string ConvOvfU2Un;
    public static string ConvOvfU4;
    public static string ConvOvfU4Un;
    public static string ConvOvfU8;
    public static string ConvOvfU8Un;
    public static string ConvRUn;
    public static string ConvR4;
    public static string ConvR8;
    public static string ConvU;
    public static string ConvU1;
    public static string ConvU2;
    public static string ConvU4;
    public static string ConvU8;
    public static string Cpblk;
    public static string Cpobj;
    public static string Div;
    public static string DivUn;
    public static string Dup;
    public static string Endfilter;
    public static string Endfinally;
    public static string Initblk;
    public static string No;
    public static string Initobj;
    public static string Isinst;
    public static string Jmp;
    public static string Ldarg;
    public static string Ldarg0;
    public static string Ldarg1;
    public static string Ldarg2;
    public static string Ldarg3;
    public static string LdargS;
    public static string Ldarga;
    public static string LdargaS;
    public static string LdcI4;
    public static string LdcI40;
    public static string LdcI41;
    public static string LdcI42;
    public static string LdcI43;
    public static string LdcI44;
    public static string LdcI45;
    public static string LdcI46;
    public static string LdcI47;
    public static string LdcI48;
    public static string LdcI4M1;
    public static string LdcI4S;
    public static string LdcI8;
    public static string LdcR4;
    public static string LdcR8;
    public static string Ldelem;
    public static string LdelemI;
    public static string LdelemI1;
    public static string LdelemI2;
    public static string LdelemI4;
    public static string LdelemI8;
    public static string LdelemR4;
    public static string LdelemR8;
    public static string LdelemRef;
    public static string LdelemU1;
    public static string LdelemU2;
    public static string LdelemU4;
    public static string Ldelema;
    public static string Ldfld;
    public static string Ldflda;
    public static string Ldftn;
    public static string LdindI;
    public static string LdindI1;
    public static string LdindI2;
    public static string LdindI4;
    public static string LdindI8;
    public static string LdindR4;
    public static string LdindR8;
    public static string LdindRef;
    public static string LdindU1;
    public static string LdindU2;
    public static string LdindU4;
    public static string Ldlen;
    public static string Ldloc;
    public static string Ldloc0;
    public static string Ldloc1;
    public static string Ldloc2;
    public static string Ldloc3;
    public static string LdlocS;
    public static string Ldloca;
    public static string LdlocaS;
    public static string Ldnull;
    public static string Ldobj;
    public static string Ldsfld;
    public static string Ldsflda;
    public static string Ldstr;
    public static string Ldtoken;
    public static string Ldvirtftn;
    public static string Leave;
    public static string LeaveS;
    public static string Localloc;
    public static string Mkrefany;
    public static string Mul;
    public static string MulOvf;
    public static string MulOvfUn;
    public static string Neg;
    public static string Newarr;
    public static string Newobj;
    public static string Nop;
    public static string Not;
    public static string Or;
    public static string Pop;
    public static string Readonly;
    public static string Refanytype;
    public static string Refanyval;
    public static string Rem;
    public static string RemUn;
    public static string Ret;
    public static string Rethrow;
    public static string Shl;
    public static string Shr;
    public static string ShrUn;
    public static string Sizeof;
    public static string Starg;
    public static string StargS;
    public static string Stelem;
    public static string StelemI;
    public static string StelemI1;
    public static string StelemI2;
    public static string StelemI4;
    public static string StelemI8;
    public static string StelemR4;
    public static string StelemR8;
    public static string StelemRef;
    public static string Stfld;
    public static string StindI;
    public static string StindI1;
    public static string StindI2;
    public static string StindI4;
    public static string StindI8;
    public static string StindR4;
    public static string StindR8;
    public static string StindRef;
    public static string Stloc;
    public static string Stloc0;
    public static string Stloc1;
    public static string Stloc2;
    public static string Stloc3;
    public static string StlocS;
    public static string Stobj;
    public static string Stsfld;
    public static string Sub;
    public static string SubOvf;
    public static string SubOvfUn;
    public static string Switch;
    public static string Tail;
    public static string Throw;
    public static string Unaligned;
    public static string Unbox;
    public static string UnboxAny;
    public static string Unused;
    public static string Volatile;
    public static string Xor;
    public static string BrnullOpAlias;
    public static string BrnullSOpAlias;
    public static string BrzeroOpAlias;
    public static string BrzeroSOpAlias;
    public static string BrinstOpAlias;
    public static string BrinstSOpAlias;
    public static string LdindU8OpAlias;
    public static string LdelemU8OpAlias;
    public static string LdcI4M1XOpAlias;
    public static string EndfaultOpAlias;
    public static string LdelemAnyOpAlias;
    public static string StelemAnyOpAlias;
    public static HashSet`1<string> Names;
    private static OpcodeNames();
}
public static class JetBrains.Metadata.IL.Opcodes : object {
    public static Opcode Add;
    public static Opcode Add_ovf;
    public static Opcode Add_ovf_un;
    public static Opcode And;
    public static Opcode Arglist;
    public static Opcode Beq;
    public static Opcode Beq_s;
    public static Opcode Bge;
    public static Opcode Bge_s;
    public static Opcode Bge_un;
    public static Opcode Bge_un_s;
    public static Opcode Bgt;
    public static Opcode Bgt_s;
    public static Opcode Bgt_un;
    public static Opcode Bgt_un_s;
    public static Opcode Ble;
    public static Opcode Ble_s;
    public static Opcode Ble_un;
    public static Opcode Ble_un_s;
    public static Opcode Blt;
    public static Opcode Blt_s;
    public static Opcode Blt_un;
    public static Opcode Blt_un_s;
    public static Opcode Bne_un;
    public static Opcode Bne_un_s;
    public static Opcode Box;
    public static Opcode Br;
    public static Opcode Br_s;
    public static Opcode Break;
    public static Opcode Brfalse;
    public static Opcode Brfalse_s;
    public static Opcode Brtrue;
    public static Opcode Brtrue_s;
    public static Opcode Call;
    public static Opcode Calli;
    public static Opcode Callvirt;
    public static Opcode Castclass;
    public static Opcode Ceq;
    public static Opcode Cgt;
    public static Opcode Cgt_un;
    public static Opcode Ckfinite;
    public static Opcode Clt;
    public static Opcode Clt_un;
    public static Opcode Constrained;
    public static Opcode Conv_i;
    public static Opcode Conv_i1;
    public static Opcode Conv_i2;
    public static Opcode Conv_i4;
    public static Opcode Conv_i8;
    public static Opcode Conv_ovf_i;
    public static Opcode Conv_ovf_i_un;
    public static Opcode Conv_ovf_i1;
    public static Opcode Conv_ovf_i1_un;
    public static Opcode Conv_ovf_i2;
    public static Opcode Conv_ovf_i2_un;
    public static Opcode Conv_ovf_i4;
    public static Opcode Conv_ovf_i4_un;
    public static Opcode Conv_ovf_i8;
    public static Opcode Conv_ovf_i8_un;
    public static Opcode Conv_ovf_u;
    public static Opcode Conv_ovf_u_un;
    public static Opcode Conv_ovf_u1;
    public static Opcode Conv_ovf_u1_un;
    public static Opcode Conv_ovf_u2;
    public static Opcode Conv_ovf_u2_un;
    public static Opcode Conv_ovf_u4;
    public static Opcode Conv_ovf_u4_un;
    public static Opcode Conv_ovf_u8;
    public static Opcode Conv_ovf_u8_un;
    public static Opcode Conv_r_un;
    public static Opcode Conv_r4;
    public static Opcode Conv_r8;
    public static Opcode Conv_u;
    public static Opcode Conv_u1;
    public static Opcode Conv_u2;
    public static Opcode Conv_u4;
    public static Opcode Conv_u8;
    public static Opcode Cpblk;
    public static Opcode Cpobj;
    public static Opcode Div;
    public static Opcode Div_un;
    public static Opcode Dup;
    public static Opcode Endfilter;
    public static Opcode Endfinally;
    public static Opcode Initblk;
    public static Opcode No;
    public static Opcode Initobj;
    public static Opcode Isinst;
    public static Opcode Jmp;
    public static Opcode Ldarg;
    public static Opcode Ldarg_0;
    public static Opcode Ldarg_1;
    public static Opcode Ldarg_2;
    public static Opcode Ldarg_3;
    public static Opcode Ldarg_s;
    public static Opcode Ldarga;
    public static Opcode Ldarga_s;
    public static Opcode Ldc_i4;
    public static Opcode Ldc_i4_0;
    public static Opcode Ldc_i4_1;
    public static Opcode Ldc_i4_2;
    public static Opcode Ldc_i4_3;
    public static Opcode Ldc_i4_4;
    public static Opcode Ldc_i4_5;
    public static Opcode Ldc_i4_6;
    public static Opcode Ldc_i4_7;
    public static Opcode Ldc_i4_8;
    public static Opcode Ldc_i4_m1;
    public static Opcode Ldc_i4_s;
    public static Opcode Ldc_i8;
    public static Opcode Ldc_r4;
    public static Opcode Ldc_r8;
    public static Opcode Ldelem;
    public static Opcode Ldelem_i;
    public static Opcode Ldelem_i1;
    public static Opcode Ldelem_i2;
    public static Opcode Ldelem_i4;
    public static Opcode Ldelem_i8;
    public static Opcode Ldelem_r4;
    public static Opcode Ldelem_r8;
    public static Opcode Ldelem_ref;
    public static Opcode Ldelem_u1;
    public static Opcode Ldelem_u2;
    public static Opcode Ldelem_u4;
    public static Opcode Ldelema;
    public static Opcode Ldfld;
    public static Opcode Ldflda;
    public static Opcode Ldftn;
    public static Opcode Ldind_i;
    public static Opcode Ldind_i1;
    public static Opcode Ldind_i2;
    public static Opcode Ldind_i4;
    public static Opcode Ldind_i8;
    public static Opcode Ldind_r4;
    public static Opcode Ldind_r8;
    public static Opcode Ldind_ref;
    public static Opcode Ldind_u1;
    public static Opcode Ldind_u2;
    public static Opcode Ldind_u4;
    public static Opcode Ldlen;
    public static Opcode Ldloc;
    public static Opcode Ldloc_0;
    public static Opcode Ldloc_1;
    public static Opcode Ldloc_2;
    public static Opcode Ldloc_3;
    public static Opcode Ldloc_s;
    public static Opcode Ldloca;
    public static Opcode Ldloca_s;
    public static Opcode Ldnull;
    public static Opcode Ldobj;
    public static Opcode Ldsfld;
    public static Opcode Ldsflda;
    public static Opcode Ldstr;
    public static Opcode Ldtoken;
    public static Opcode Ldvirtftn;
    public static Opcode Leave;
    public static Opcode Leave_s;
    public static Opcode Localloc;
    public static Opcode Mkrefany;
    public static Opcode Mul;
    public static Opcode Mul_ovf;
    public static Opcode Mul_ovf_un;
    public static Opcode Neg;
    public static Opcode Newarr;
    public static Opcode Newobj;
    public static Opcode Nop;
    public static Opcode Not;
    public static Opcode Or;
    public static Opcode Pop;
    public static Opcode Readonly;
    public static Opcode Refanytype;
    public static Opcode Refanyval;
    public static Opcode Rem;
    public static Opcode Rem_un;
    public static Opcode Ret;
    public static Opcode Rethrow;
    private static Opcode[] OurMultiByteOpcodes;
    private static Opcode[] OurSingleByteOpcodes;
    public static Opcode Shl;
    public static Opcode Shr;
    public static Opcode Shr_un;
    public static Opcode Sizeof;
    public static Opcode Starg;
    public static Opcode Starg_s;
    public static Opcode Stelem;
    public static Opcode Stelem_i;
    public static Opcode Stelem_i1;
    public static Opcode Stelem_i2;
    public static Opcode Stelem_i4;
    public static Opcode Stelem_i8;
    public static Opcode Stelem_r4;
    public static Opcode Stelem_r8;
    public static Opcode Stelem_ref;
    public static Opcode Stfld;
    public static Opcode Stind_i;
    public static Opcode Stind_i1;
    public static Opcode Stind_i2;
    public static Opcode Stind_i4;
    public static Opcode Stind_i8;
    public static Opcode Stind_r4;
    public static Opcode Stind_r8;
    public static Opcode Stind_ref;
    public static Opcode Stloc;
    public static Opcode Stloc_0;
    public static Opcode Stloc_1;
    public static Opcode Stloc_2;
    public static Opcode Stloc_3;
    public static Opcode Stloc_s;
    public static Opcode Stobj;
    public static Opcode Stsfld;
    public static Opcode Sub;
    public static Opcode Sub_ovf;
    public static Opcode Sub_ovf_un;
    public static Opcode Switch;
    public static Opcode Tail;
    public static Opcode Throw;
    public static Opcode Unaligned;
    public static Opcode Unbox;
    public static Opcode Unbox_any;
    public static Opcode Unused;
    public static Opcode Volatile;
    public static Opcode Xor;
    public static Opcode[] SingleByteOpcodes { get; }
    public static Opcode[] MultiByteOpcodes { get; }
    private static Opcodes();
    public static Opcode[] get_SingleByteOpcodes();
    public static Opcode[] get_MultiByteOpcodes();
}
public enum JetBrains.Metadata.IL.OpcodeType : Enum {
    public int value__;
    public static OpcodeType Prefix;
    public static OpcodeType ObjectModel;
    public static OpcodeType Primitive;
    public static OpcodeType Macro;
    public static OpcodeType Internal;
}
public enum JetBrains.Metadata.IL.OpcodeValue : Enum {
    public ushort value__;
    public static OpcodeValue Nop;
    public static OpcodeValue Break;
    public static OpcodeValue Ldarg_0;
    public static OpcodeValue Ldarg_1;
    public static OpcodeValue Ldarg_2;
    public static OpcodeValue Ldarg_3;
    public static OpcodeValue Ldloc_0;
    public static OpcodeValue Ldloc_1;
    public static OpcodeValue Ldloc_2;
    public static OpcodeValue Ldloc_3;
    public static OpcodeValue Stloc_0;
    public static OpcodeValue Stloc_1;
    public static OpcodeValue Stloc_2;
    public static OpcodeValue Stloc_3;
    public static OpcodeValue Ldarg_s;
    public static OpcodeValue Ldarga_s;
    public static OpcodeValue Starg_s;
    public static OpcodeValue Ldloc_s;
    public static OpcodeValue Ldloca_s;
    public static OpcodeValue Stloc_s;
    public static OpcodeValue Ldnull;
    public static OpcodeValue Ldc_i4_m1;
    public static OpcodeValue Ldc_i4_0;
    public static OpcodeValue Ldc_i4_1;
    public static OpcodeValue Ldc_i4_2;
    public static OpcodeValue Ldc_i4_3;
    public static OpcodeValue Ldc_i4_4;
    public static OpcodeValue Ldc_i4_5;
    public static OpcodeValue Ldc_i4_6;
    public static OpcodeValue Ldc_i4_7;
    public static OpcodeValue Ldc_i4_8;
    public static OpcodeValue Ldc_i4_s;
    public static OpcodeValue Ldc_i4;
    public static OpcodeValue Ldc_i8;
    public static OpcodeValue Ldc_r4;
    public static OpcodeValue Ldc_r8;
    public static OpcodeValue Dup;
    public static OpcodeValue Pop;
    public static OpcodeValue Jmp;
    public static OpcodeValue Call;
    public static OpcodeValue Calli;
    public static OpcodeValue Ret;
    public static OpcodeValue Br_s;
    public static OpcodeValue Brfalse_s;
    public static OpcodeValue Brtrue_s;
    public static OpcodeValue Beq_s;
    public static OpcodeValue Bge_s;
    public static OpcodeValue Bgt_s;
    public static OpcodeValue Ble_s;
    public static OpcodeValue Blt_s;
    public static OpcodeValue Bne_un_s;
    public static OpcodeValue Bge_un_s;
    public static OpcodeValue Bgt_un_s;
    public static OpcodeValue Ble_un_s;
    public static OpcodeValue Blt_un_s;
    public static OpcodeValue Br;
    public static OpcodeValue Brfalse;
    public static OpcodeValue Brtrue;
    public static OpcodeValue Beq;
    public static OpcodeValue Bge;
    public static OpcodeValue Bgt;
    public static OpcodeValue Ble;
    public static OpcodeValue Blt;
    public static OpcodeValue Bne_un;
    public static OpcodeValue Bge_un;
    public static OpcodeValue Bgt_un;
    public static OpcodeValue Ble_un;
    public static OpcodeValue Blt_un;
    public static OpcodeValue Switch;
    public static OpcodeValue Ldind_i1;
    public static OpcodeValue Ldind_u1;
    public static OpcodeValue Ldind_i2;
    public static OpcodeValue Ldind_u2;
    public static OpcodeValue Ldind_i4;
    public static OpcodeValue Ldind_u4;
    public static OpcodeValue Ldind_i8;
    public static OpcodeValue Ldind_i;
    public static OpcodeValue Ldind_r4;
    public static OpcodeValue Ldind_r8;
    public static OpcodeValue Ldind_ref;
    public static OpcodeValue Stind_ref;
    public static OpcodeValue Stind_i1;
    public static OpcodeValue Stind_i2;
    public static OpcodeValue Stind_i4;
    public static OpcodeValue Stind_i8;
    public static OpcodeValue Stind_r4;
    public static OpcodeValue Stind_r8;
    public static OpcodeValue Add;
    public static OpcodeValue Sub;
    public static OpcodeValue Mul;
    public static OpcodeValue Div;
    public static OpcodeValue Div_un;
    public static OpcodeValue Rem;
    public static OpcodeValue Rem_un;
    public static OpcodeValue And;
    public static OpcodeValue Or;
    public static OpcodeValue Xor;
    public static OpcodeValue Shl;
    public static OpcodeValue Shr;
    public static OpcodeValue Shr_un;
    public static OpcodeValue Neg;
    public static OpcodeValue Not;
    public static OpcodeValue Conv_i1;
    public static OpcodeValue Conv_i2;
    public static OpcodeValue Conv_i4;
    public static OpcodeValue Conv_i8;
    public static OpcodeValue Conv_r4;
    public static OpcodeValue Conv_r8;
    public static OpcodeValue Conv_u4;
    public static OpcodeValue Conv_u8;
    public static OpcodeValue Callvirt;
    public static OpcodeValue Cpobj;
    public static OpcodeValue Ldobj;
    public static OpcodeValue Ldstr;
    public static OpcodeValue Newobj;
    public static OpcodeValue Castclass;
    public static OpcodeValue Isinst;
    public static OpcodeValue Conv_r_un;
    public static OpcodeValue Unbox;
    public static OpcodeValue Throw;
    public static OpcodeValue Ldfld;
    public static OpcodeValue Ldflda;
    public static OpcodeValue Stfld;
    public static OpcodeValue Ldsfld;
    public static OpcodeValue Ldsflda;
    public static OpcodeValue Stsfld;
    public static OpcodeValue Stobj;
    public static OpcodeValue Conv_ovf_i1_un;
    public static OpcodeValue Conv_ovf_i2_un;
    public static OpcodeValue Conv_ovf_i4_un;
    public static OpcodeValue Conv_ovf_i8_un;
    public static OpcodeValue Conv_ovf_u1_un;
    public static OpcodeValue Conv_ovf_u2_un;
    public static OpcodeValue Conv_ovf_u4_un;
    public static OpcodeValue Conv_ovf_u8_un;
    public static OpcodeValue Conv_ovf_i_un;
    public static OpcodeValue Conv_ovf_u_un;
    public static OpcodeValue Box;
    public static OpcodeValue Newarr;
    public static OpcodeValue Ldlen;
    public static OpcodeValue Ldelema;
    public static OpcodeValue Ldelem_i1;
    public static OpcodeValue Ldelem_u1;
    public static OpcodeValue Ldelem_i2;
    public static OpcodeValue Ldelem_u2;
    public static OpcodeValue Ldelem_i4;
    public static OpcodeValue Ldelem_u4;
    public static OpcodeValue Ldelem_i8;
    public static OpcodeValue Ldelem_i;
    public static OpcodeValue Ldelem_r4;
    public static OpcodeValue Ldelem_r8;
    public static OpcodeValue Ldelem_ref;
    public static OpcodeValue Stelem_i;
    public static OpcodeValue Stelem_i1;
    public static OpcodeValue Stelem_i2;
    public static OpcodeValue Stelem_i4;
    public static OpcodeValue Stelem_i8;
    public static OpcodeValue Stelem_r4;
    public static OpcodeValue Stelem_r8;
    public static OpcodeValue Stelem_ref;
    public static OpcodeValue Ldelem;
    public static OpcodeValue Stelem;
    public static OpcodeValue Unbox_any;
    public static OpcodeValue Conv_ovf_i1;
    public static OpcodeValue Conv_ovf_u1;
    public static OpcodeValue Conv_ovf_i2;
    public static OpcodeValue Conv_ovf_u2;
    public static OpcodeValue Conv_ovf_i4;
    public static OpcodeValue Conv_ovf_u4;
    public static OpcodeValue Conv_ovf_i8;
    public static OpcodeValue Conv_ovf_u8;
    public static OpcodeValue Refanyval;
    public static OpcodeValue Ckfinite;
    public static OpcodeValue Mkrefany;
    public static OpcodeValue Ldtoken;
    public static OpcodeValue Conv_u2;
    public static OpcodeValue Conv_u1;
    public static OpcodeValue Conv_i;
    public static OpcodeValue Conv_ovf_i;
    public static OpcodeValue Conv_ovf_u;
    public static OpcodeValue Add_ovf;
    public static OpcodeValue Add_ovf_un;
    public static OpcodeValue Mul_ovf;
    public static OpcodeValue Mul_ovf_un;
    public static OpcodeValue Sub_ovf;
    public static OpcodeValue Sub_ovf_un;
    public static OpcodeValue Endfinally;
    public static OpcodeValue Leave;
    public static OpcodeValue Leave_s;
    public static OpcodeValue Stind_i;
    public static OpcodeValue Conv_u;
    public static OpcodeValue Arglist;
    public static OpcodeValue Ceq;
    public static OpcodeValue Cgt;
    public static OpcodeValue Cgt_un;
    public static OpcodeValue Clt;
    public static OpcodeValue Clt_un;
    public static OpcodeValue Ldftn;
    public static OpcodeValue Ldvirtftn;
    public static OpcodeValue Ldarg;
    public static OpcodeValue Ldarga;
    public static OpcodeValue Starg;
    public static OpcodeValue Ldloc;
    public static OpcodeValue Ldloca;
    public static OpcodeValue Stloc;
    public static OpcodeValue Localloc;
    public static OpcodeValue Endfilter;
    public static OpcodeValue Unaligned;
    public static OpcodeValue Volatile;
    public static OpcodeValue Tailcall;
    public static OpcodeValue Initobj;
    public static OpcodeValue Constrained;
    public static OpcodeValue Cpblk;
    public static OpcodeValue Initblk;
    public static OpcodeValue No;
    public static OpcodeValue Rethrow;
    public static OpcodeValue Sizeof;
    public static OpcodeValue Refanytype;
    public static OpcodeValue Readonly;
    public static OpcodeValue Unused;
}
[ExtensionAttribute]
public static class JetBrains.Metadata.IL.OpcodeValueEx : object {
    [ExtensionAttribute]
public static bool IsUnsigned(OpcodeValue opcodeValue);
    [ExtensionAttribute]
public static OpcodeValue ToFullForm(OpcodeValue opcodeValue);
    [ExtensionAttribute]
public static ElementType ToConversionElementType(OpcodeValue opcodeValue);
}
public enum JetBrains.Metadata.IL.OperandType : Enum {
    public int value__;
    public static OperandType Int32;
    public static OperandType Int64;
    public static OperandType None;
    public static OperandType TypeToken;
    public static OperandType SwitchTargets;
    public static OperandType ShortVariableIndex;
    public static OperandType SByte;
    public static OperandType Double;
    public static OperandType SignatureToken;
    public static OperandType Single;
    public static OperandType ShortBranchTarget;
    public static OperandType FieldToken;
    public static OperandType String;
    public static OperandType MethodToken;
    public static OperandType BranchTarget;
    public static OperandType Token;
    public static OperandType VariableIndex;
}
public enum JetBrains.Metadata.IL.StackBehavior : Enum {
    public int value__;
    public static StackBehavior Popref_popi_popi;
    public static StackBehavior Popref_popi_popr4;
    public static StackBehavior Popref_popi_pop1;
    public static StackBehavior Popref_popi_popref;
    public static StackBehavior Popi;
    public static StackBehavior Popi_popi_popi;
    public static StackBehavior Varpop;
    public static StackBehavior Push1_push1;
    public static StackBehavior Popi_popi8;
    public static StackBehavior Popi_popr8;
    public static StackBehavior Pushref;
    public static StackBehavior Popi_popr4;
    public static StackBehavior Popi_popi;
    public static StackBehavior Pushi8;
    public static StackBehavior Pushr4;
    public static StackBehavior Pop1_pop1;
    public static StackBehavior Popref_pop1;
    public static StackBehavior Popi_pop1;
    public static StackBehavior Popref_popi_popi8;
    public static StackBehavior Pop1;
    public static StackBehavior Pop0;
    public static StackBehavior Pushr8;
    public static StackBehavior Popref_popi;
    public static StackBehavior Pushi;
    public static StackBehavior Varpush;
    public static StackBehavior Popref_popi_popr8;
    public static StackBehavior Push0;
    public static StackBehavior Push1;
    public static StackBehavior Popref;
}
public class JetBrains.Metadata.IL.TypeIlCode : IlCodeBase {
    [CompilerGeneratedAttribute]
private IMetadataTypeInfo <Type>k__BackingField;
    public IMetadataTypeInfo Type { get; private set; }
    public TypeIlCode(IMetadataTypeInfo metadataType, IImageBodyReader imageBodyReader);
    [CompilerGeneratedAttribute]
public IMetadataTypeInfo get_Type();
    [CompilerGeneratedAttribute]
private void set_Type(IMetadataTypeInfo value);
}
public class JetBrains.Metadata.Reader.API.AnonymousDelegateType : SentinelTypeBase {
    public static IMetadataType Instance;
    public string FullName { get; }
    public bool IsResolved { get; }
    private static AnonymousDelegateType();
    public virtual string get_FullName();
    public virtual bool get_IsResolved();
}
public class JetBrains.Metadata.Reader.API.AssemblyReferenceWithSource : object {
    private FileSystemPath mySourcePath;
    private AssemblyNameInfo myAssemblyNameInfo;
    [NotNullAttribute]
public AssemblyNameInfo AssemblyNameInfo { get; }
    [NotNullAttribute]
public FileSystemPath SourcePath { get; }
    public AssemblyReferenceWithSource(FileSystemPath sourcePath, AssemblyNameInfo assemblyNameInfo);
    protected bool Equals(AssemblyReferenceWithSource other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public AssemblyNameInfo get_AssemblyNameInfo();
    public FileSystemPath get_SourcePath();
}
public class JetBrains.Metadata.Reader.API.AssemblyResolverAppDomainAssemblyResolver : object {
    public AssemblyResolverAppDomainAssemblyResolver(Lifetime lifetime, IFolderBasedAssemblyResolver metaresolver);
}
[ExtensionAttribute]
public static class JetBrains.Metadata.Reader.API.AssemblyResolverEx : object {
    [ExtensionAttribute]
public static string DumpDebugInformation(IAssemblyResolver resolver);
}
public class JetBrains.Metadata.Reader.API.AssemblyResolverOnFolders : object {
    private IMetadataProvider myMetadataProvider;
    private JetHashSet`1<FileSystemPath> myPaths;
    private Dictionary`2<AssemblyNameInfo, FileSystemPath> myPathCache;
    private static ILogger Logger;
    [CanBeNullAttribute]
private Func`2<FileSystemPath, bool> myFileExists;
    [CompilerGeneratedAttribute]
private static Func`2<FileSystemPath, bool> CS$<>9__CachedAnonymousMethodDelegate1;
    public AssemblyResolverOnFolders(FileSystemPath[] folders);
    public AssemblyResolverOnFolders(IEnumerable`1<FileSystemPath> folders);
    public AssemblyResolverOnFolders(IMetadataProvider metadataProvider, FileSystemPath[] folders);
    public AssemblyResolverOnFolders(IMetadataProvider metadataProvider, IEnumerable`1<FileSystemPath> folders, Func`2<FileSystemPath, bool> filesExists);
    private static AssemblyResolverOnFolders();
    public void AddPath(FileSystemPath folder);
    public sealed virtual IMetadataAccess ResolveAssembly(AssemblyNameInfo nameToResolve, FileSystemPath& assemblyLocation, IModuleReferenceResolveContext moduleReferenceResolveContext);
    [CanBeNullAttribute]
public sealed virtual FileSystemPath TryResolveAssemblyPath(AssemblyNameInfo nameToResolve);
    public sealed virtual void DumpDebugInformation(IndentedTextWriter textWriter);
    public sealed virtual bool IsUnderResolvePaths(FileSystemPath path);
    [CompilerGeneratedAttribute]
private static bool <TryResolveAssemblyPath>b__0(FileSystemPath path);
}
public enum JetBrains.Metadata.Reader.API.ClassLayoutType : Enum {
    public int value__;
    public static ClassLayoutType Auto;
    public static ClassLayoutType Sequential;
    public static ClassLayoutType Explicit;
}
[ExtensionAttribute]
public static class JetBrains.Metadata.Reader.API.ClrTypeNameExtensions : object {
    [ExtensionAttribute]
public static bool IsEmpty(IClrTypeName name);
    [ExtensionAttribute]
public static string GetNamespaceName(IClrTypeName name);
    [CanBeNullAttribute]
[ExtensionAttribute]
public static IClrTypeName GetParent(IClrTypeName name);
    [ExtensionAttribute]
public static bool GetIsInnerType(IClrTypeName name);
}
public enum JetBrains.Metadata.Reader.API.CodeType : Enum {
    public int value__;
    public static CodeType IL;
    public static CodeType NATIVE;
    public static CodeType OPTIL;
    public static CodeType RUNTIME;
}
[ExtensionAttribute]
public static class JetBrains.Metadata.Reader.API.CompilerSpecificAttributesExtensions : object {
    [CanBeNullAttribute]
private static ICompilerSpecificAttribute CreateMarshalAsAttribute(IBlob blob, IMetadataAssembly context);
    [ExtensionAttribute]
public static ICompilerSpecificAttribute[] GetCompilerSpecificAttributes(IMetadataEntity entity);
    [NotNullAttribute]
public static IEnumerable`1<ICompilerSpecificAttribute> CreateTypeForwardedToAttributes(IMetadataAssembly assembly);
    private static ICompilerSpecificAttribute[] GetAssemblyAttributes(IMetadataAssembly assembly);
    private static ICompilerSpecificAttribute[] GetReturnValueAttributes(IMetadataReturnValue returnValue);
    [ExtensionAttribute]
private static ICompilerSpecificAttribute[] GetParameterAttributes(IMetadataParameter parameter);
    [ExtensionAttribute]
private static ICompilerSpecificAttribute[] GetFieldAttributes(IMetadataField field);
    [ExtensionAttribute]
private static ICompilerSpecificAttribute[] GetMethodAttributes(IMetadataMethod method);
    [ExtensionAttribute]
private static bool HasNamedParameter(IMetadataTypeInfo customAttributeType, string parameterName);
    private static ClassLayoutType GetDefaultLayoutType(IMetadataTypeInfo typeInfo);
    [ExtensionAttribute]
private static ICompilerSpecificAttribute[] GetTypeInfoAttributes(IMetadataTypeInfo typeInfo);
    private static IEnumerable`1<Pair`2<string, MetadataAttributeValue>> MakeStructLayoutAttributeNamedArguments(IMetadataAssembly corlib, IMetadataTypeInfo typeInfo);
    private static IEnumerable`1<Pair`2<string, MetadataAttributeValue>> MakeDllImportNamedArguments(IMetadataAssembly corlib, IMetadataMethod method);
}
public class JetBrains.Metadata.Reader.API.CopyingMetadataTypeTransformer : object {
    public virtual IMetadataType TransformArrayType(IMetadataArrayType arrayType);
    public virtual IMetadataType TransformClassType(IMetadataClassType classType);
    public virtual IMetadataType TransformPointerType(IMetadataPointerType pointerType);
    public virtual IMetadataType TransformReferenceType(IMetadataReferenceType referenceType);
    public virtual IMetadataType TransformGenericArgumentReferenceType(IMetadataGenericArgumentReferenceType genericArgumentReferenceType);
    public sealed virtual IMetadataType TransformFunctionPointerType(IMetadataFunctionPointerType functionPointerType);
}
public class JetBrains.Metadata.Reader.API.CurrentRuntimeAssemblyResolvers : object {
    public static IFolderBasedAssemblyResolver CreateInstance(Nullable`1<GacResolvePreferences> gacResolvePreferences, RuntimeAssemblySources sources);
}
public class JetBrains.Metadata.Reader.API.DiagnosticResolveContext : ConcurrentUserDataHolder {
    private static IModuleReferenceResolveContext myInstance;
    private string myUniqueName;
    private AssemblyNameAndLocation myOriginator;
    public string UniqueName { get; }
    public AssemblyNameAndLocation Originator { get; }
    public TargetFrameworkId TargetFramework { get; }
    public static IModuleReferenceResolveContext Instance { get; }
    public DiagnosticResolveContext(string sUniqueName, AssemblyNameAndLocation originator);
    private static DiagnosticResolveContext();
    public sealed virtual string get_UniqueName();
    public sealed virtual bool IsValid();
    public sealed virtual AssemblyNameAndLocation get_Originator();
    public sealed virtual TargetFrameworkId get_TargetFramework();
    public sealed virtual void Write(BinaryWriter writer);
    public static IModuleReferenceResolveContext get_Instance();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public virtual string ToString();
}
public class JetBrains.Metadata.Reader.API.DotNetFrameworkCurrentRuntimeAssemblyResolver : object {
    private LocalLazy`2<AssemblyResolverOnFolders, RuntimeAssemblySources> myAdditionalFolders;
    [CanBeNullAttribute]
private DotNetFrameworkGacAssemblyResolver myGac;
    [CompilerGeneratedAttribute]
private static Func`2<InstalledVs, bool> CS$<>9__CachedAnonymousMethodDelegate5;
    public DotNetFrameworkCurrentRuntimeAssemblyResolver(Nullable`1<GacResolvePreferences> gacResolvePreferences, RuntimeAssemblySources sources);
    public sealed virtual void DumpDebugInformation(IndentedTextWriter textWriter);
    public sealed virtual bool IsUnderResolvePaths(FileSystemPath path);
    public sealed virtual IMetadataAccess ResolveAssembly(AssemblyNameInfo name, FileSystemPath& assemblyLocation, IModuleReferenceResolveContext moduleReferenceResolveContext);
    public sealed virtual FileSystemPath TryResolveAssemblyPath(AssemblyNameInfo name);
    private static AssemblyResolverOnFolders CreateAdditionalFoldersResolver(RuntimeAssemblySources runtimeAssemblySources);
    [CompilerGeneratedAttribute]
private static bool <CreateAdditionalFoldersResolver>b__4(InstalledVs ins);
}
public class JetBrains.Metadata.Reader.API.DotNetFrameworkDescriptor : object {
    public string Framework;
    public Version Version;
    public string Profile;
    public DotNetFrameworkDescriptor(string framework, Version version, string profile);
}
public class JetBrains.Metadata.Reader.API.DotNetFrameworkGacAssemblyResolver : object {
    private ILogger Logger;
    private GacResolvePreferences myPreferences;
    private DotNetFrameworkGacAssemblyResolver(GacResolvePreferences preferences);
    [NotNullAttribute]
public static DotNetFrameworkGacAssemblyResolver CreateOnCurrentRuntimeGac(GacResolvePreferences preferences);
    public virtual FileSystemPath TryResolveAssemblyPath(AssemblyNameInfo name);
    public sealed virtual IMetadataAccess ResolveAssembly(AssemblyNameInfo name, FileSystemPath& assemblyLocation, IModuleReferenceResolveContext moduleReferenceResolveContext);
    public sealed virtual bool IsUnderResolvePaths(FileSystemPath path);
    public sealed virtual void DumpDebugInformation(IndentedTextWriter textWriter);
}
public class JetBrains.Metadata.Reader.API.DotNetRuntimeAssemblyResolver : object {
    private DotNetRuntime myDotNetRuntime;
    public DotNetRuntimeAssemblyResolver(DotNetRuntime dotNetRuntime);
    public static IFolderBasedAssemblyResolver FromPlatformId(PlatformID platformID);
    public static IFolderBasedAssemblyResolver FromDotNetRuntime(DotNetRuntime dotNetRuntime);
    public sealed virtual void DumpDebugInformation(IndentedTextWriter textWriter);
    public sealed virtual bool IsUnderResolvePaths(FileSystemPath path);
    public sealed virtual IMetadataAccess ResolveAssembly(AssemblyNameInfo name, FileSystemPath& assemblyLocation, IModuleReferenceResolveContext moduleReferenceResolveContext);
    public sealed virtual FileSystemPath TryResolveAssemblyPath(AssemblyNameInfo name);
}
public enum JetBrains.Metadata.Reader.API.ElementType : Enum {
    public byte value__;
    public static ElementType End;
    public static ElementType Void;
    public static ElementType Bool;
    public static ElementType Char;
    public static ElementType I1;
    public static ElementType U1;
    public static ElementType I2;
    public static ElementType U2;
    public static ElementType I4;
    public static ElementType U4;
    public static ElementType I8;
    public static ElementType U8;
    public static ElementType R4;
    public static ElementType R8;
    public static ElementType String;
    public static ElementType Ptr;
    public static ElementType ByRef;
    public static ElementType ValueType;
    public static ElementType Class;
    public static ElementType Var;
    public static ElementType Array;
    public static ElementType GenericInst;
    public static ElementType TypedByRef;
    public static ElementType I;
    public static ElementType U;
    public static ElementType FnPtr;
    public static ElementType Object;
    public static ElementType SzArray;
    public static ElementType MVar;
    public static ElementType CmodReqd;
    public static ElementType CmodOpt;
    public static ElementType Internal;
    public static ElementType Modifier;
    public static ElementType Sentinel;
    public static ElementType Pinned;
    public static ElementType Type;
    public static ElementType Boxed;
    public static ElementType Field;
    public static ElementType Property;
    public static ElementType Enum;
}
[ExtensionAttribute]
public static class JetBrains.Metadata.Reader.API.ElementTypeEx : object {
    [ExtensionAttribute]
public static ElementType ToSigned(ElementType type);
    [ExtensionAttribute]
public static ElementType ToUnsigned(ElementType type);
    [ExtensionAttribute]
public static TypeCode ToTypeCode(ElementType type);
    [ExtensionAttribute]
public static bool IsAnyOf(ElementType lhs, ElementType rhs1);
    [ExtensionAttribute]
public static bool IsAnyOf(ElementType lhs, ElementType rhs1, ElementType rhs2);
    [ExtensionAttribute]
public static bool IsAnyOf(ElementType lhs, ElementType rhs1, ElementType rhs2, ElementType rhs3);
    [ExtensionAttribute]
public static bool IsAnyOf(ElementType lhs, ElementType rhs1, ElementType rhs2, ElementType rhs3, ElementType rhs4);
    [ExtensionAttribute]
public static bool IsAnyOf(ElementType lhs, ElementType[] rhs);
    [ExtensionAttribute]
public static bool IsNumeric(ElementType type);
    [ExtensionAttribute]
public static bool IsNumericOrChar(ElementType type);
    [ExtensionAttribute]
public static bool IsIntegral(ElementType type);
    [ExtensionAttribute]
public static bool IsIntegralOrChar(ElementType type);
    [ExtensionAttribute]
public static bool IsFloat(ElementType type);
    [ExtensionAttribute]
public static bool IsPointerOrReference(ElementType type);
    [ExtensionAttribute]
public static bool IsSigned(ElementType type);
    [ExtensionAttribute]
public static bool IsUnsigned(ElementType type);
    [ExtensionAttribute]
public static bool IsBinaryEquivalentTo(ElementType type1, ElementType type2);
    [ExtensionAttribute]
private static ElementType ToCanonical(ElementType type);
    [ExtensionAttribute]
public static bool IsImplicitNumericConvertibleTo(ElementType from, ElementType to);
    [ExtensionAttribute]
private static int Weight(ElementType type);
}
[ExtensionAttribute]
public static class JetBrains.Metadata.Reader.API.ElementTypeExtensions : object {
    [ExtensionAttribute]
public static int GetSize(ElementType elementType);
}
public class JetBrains.Metadata.Reader.API.EmptyResolveContext : UserDataHolder {
    public static EmptyResolveContext Instance;
    public string UniqueName { get; }
    public AssemblyNameAndLocation Originator { get; }
    public TargetFrameworkId TargetFramework { get; }
    private static EmptyResolveContext();
    public FileSystemPath GetResolveResult(AssemblyReferenceWithSource assemblyReferenceWithSource);
    public void SetResolveResult(AssemblyReferenceWithSource assemblyReferenceWithSource, FileSystemPath resolveResult);
    public sealed virtual string get_UniqueName();
    public sealed virtual bool IsValid();
    public sealed virtual AssemblyNameAndLocation get_Originator();
    public sealed virtual TargetFrameworkId get_TargetFramework();
    public sealed virtual void Write(BinaryWriter writer);
    public virtual string ToString();
}
public class JetBrains.Metadata.Reader.API.FieldSignature : object {
    private IMetadataType myType;
    public IMetadataType Type { get; }
    public FieldSignature(IMetadataType type);
    public IMetadataType get_Type();
    internal static FieldSignature FromBlob(IBlob blob, IMetadataAssembly assembly, TypeDecodeContext context);
    public bool IsEqualTo(FieldSignature other);
}
public class JetBrains.Metadata.Reader.API.FieldSpecification : object {
    public static FieldSpecification Null;
    private IMetadataClassType myOwnerType;
    private IMetadataField myField;
    public IMetadataClassType OwnerType { get; }
    public IMetadataField Field { get; }
    public FieldSpecification(IMetadataField field);
    public FieldSpecification(IMetadataField field, IMetadataClassType ownerType);
    private static FieldSpecification();
    public IMetadataClassType get_OwnerType();
    public IMetadataField get_Field();
    public sealed virtual bool Equals(FieldSpecification other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[FlagsAttribute]
public enum JetBrains.Metadata.Reader.API.GacResolvePreferences : Enum {
    public int value__;
    public static GacResolvePreferences None;
    public static GacResolvePreferences MatchSameOrNewer;
    public static GacResolvePreferences RedirectGac20ToGac40;
}
public class JetBrains.Metadata.Reader.API.GacResolverUtil : object {
    public static FileSystemPath BestCandidate(IEnumerable`1<FileSystemPath> candidates, AssemblyNameInfo name, GacResolvePreferences preferences);
}
[FlagsAttribute]
public enum JetBrains.Metadata.Reader.API.GenericArgumentAttributes : Enum {
    public int value__;
    public static GenericArgumentAttributes VarianceMask;
    public static GenericArgumentAttributes NonVariant;
    public static GenericArgumentAttributes Covariant;
    public static GenericArgumentAttributes Contravariant;
    public static GenericArgumentAttributes SpecialConstraintMask;
    public static GenericArgumentAttributes NoSpecialConstraint;
    public static GenericArgumentAttributes ReferenceTypeConstraint;
    public static GenericArgumentAttributes ValueTypeConstraint;
    public static GenericArgumentAttributes DefaultConstructorConstraint;
}
public enum JetBrains.Metadata.Reader.API.GenericArgumentKind : Enum {
    public int value__;
    public static GenericArgumentKind Type;
    public static GenericArgumentKind Method;
}
public interface JetBrains.Metadata.Reader.API.IAssemblyResolver {
    [CanBeNullAttribute]
public abstract virtual IMetadataAccess ResolveAssembly(AssemblyNameInfo name, FileSystemPath& assemblyLocation, IModuleReferenceResolveContext moduleReferenceResolveContext);
    public abstract virtual void DumpDebugInformation(IndentedTextWriter textWriter);
}
[CannotApplyEqualityOperatorAttribute]
public interface JetBrains.Metadata.Reader.API.IClrTypeName {
    public string ShortName { get; }
    public string FullName { get; }
    public IEnumerable`1<string> NamespaceNames { get; }
    public IEnumerable`1<TypeNameAndTypeParameterNumber> TypeNames { get; }
    public int TypeParametersCount { get; }
    public abstract virtual string get_ShortName();
    public abstract virtual string get_FullName();
    public abstract virtual IEnumerable`1<string> get_NamespaceNames();
    public abstract virtual IEnumerable`1<TypeNameAndTypeParameterNumber> get_TypeNames();
    public abstract virtual int get_TypeParametersCount();
    [PureAttribute]
public abstract virtual IClrTypeName GetPersistent();
    [PureAttribute]
public abstract virtual int GetPartsCount();
    [PureAttribute]
public abstract virtual IClrTypeNamePartIterator GetPartIterator();
    [PureAttribute]
public abstract virtual string GetFullNameFast();
}
public interface JetBrains.Metadata.Reader.API.IClrTypeNamePartIterator {
    public abstract virtual bool GetNextPart(TypeNameAndTypeParameterNumber& info);
}
public interface JetBrains.Metadata.Reader.API.ICompilerSpecificAttribute {
    [NotNullAttribute]
public string AttributeType { get; }
    [NotNullAttribute]
public MetadataAttributeValue[] PositionalArguments { get; }
    [NotNullAttribute]
public Pair`2[] NamedArguments { get; }
    public abstract virtual string get_AttributeType();
    public abstract virtual MetadataAttributeValue[] get_PositionalArguments();
    public abstract virtual Pair`2[] get_NamedArguments();
}
public interface JetBrains.Metadata.Reader.API.IEntityPresentations {
    public abstract virtual MetadataToken[] GetFieldPresentations(IMetadataField field);
    public abstract virtual MetadataToken[] GetTypePresentations(IMetadataTypeInfo typeInfo);
    public abstract virtual MetadataToken[] GetMethodPresentations(IMetadataMethod method);
    public abstract virtual MetadataToken GetTokenFromTypeInfo(IMetadataTypeInfo typeInfo);
}
public interface JetBrains.Metadata.Reader.API.IFolderBasedAssemblyResolver {
    [CanBeNullAttribute]
public abstract virtual FileSystemPath TryResolveAssemblyPath(AssemblyNameInfo name);
    public abstract virtual bool IsUnderResolvePaths(FileSystemPath path);
}
public interface JetBrains.Metadata.Reader.API.IImageBodyReader {
    [CanBeNullAttribute]
public abstract virtual IMethodBody GetMethodBody(IMetadataMethod method);
    [CanBeNullAttribute]
public abstract virtual ILMethodBody GetIlMethodBody(IMetadataMethod method);
    [CanBeNullAttribute]
public abstract virtual Byte[] GetFieldInitialValue(IMetadataField field);
}
public interface JetBrains.Metadata.Reader.API.IManifestResourceDisposition {
    [NotNullAttribute]
public string ResourceName { get; }
    public abstract virtual string get_ResourceName();
    [NotNullAttribute]
public abstract virtual Stream CreateResourceReader();
}
public interface JetBrains.Metadata.Reader.API.IMetadataArrayType {
    public IMetadataType ElementType { get; }
    public bool IsVector { get; }
    public UInt32 Rank { get; }
    public UInt32[] Sizes { get; }
    public Int32[] LBounds { get; }
    public IMetadataArrayTypeInfo TypeInfo { get; }
    public abstract virtual IMetadataType get_ElementType();
    public abstract virtual bool get_IsVector();
    public abstract virtual UInt32 get_Rank();
    public abstract virtual UInt32[] get_Sizes();
    public abstract virtual Int32[] get_LBounds();
    public abstract virtual IMetadataArrayTypeInfo get_TypeInfo();
}
public interface JetBrains.Metadata.Reader.API.IMetadataArrayTypeInfo {
    public IMetadataArrayType ArrayType { get; }
    public abstract virtual IMetadataArrayType get_ArrayType();
}
public interface JetBrains.Metadata.Reader.API.IMetadataAssembly {
    public IMetadataAccess MetadataAccess { get; }
    [CanBeNullAttribute]
public AssemblyNameInfo AssemblyName { get; }
    public Guid Mvid { get; }
    public IEnumerable`1<AssemblyNameInfo> ReferencedAssembliesNames { get; }
    public FileSystemPath Location { get; }
    public IMetadataAssemblyInternals Internals { get; }
    public IMetadataCustomAttribute[] ModuleAttributes { get; }
    public abstract virtual IMetadataAccess get_MetadataAccess();
    public abstract virtual AssemblyNameInfo get_AssemblyName();
    public abstract virtual Guid get_Mvid();
    public abstract virtual IEnumerable`1<AssemblyNameInfo> get_ReferencedAssembliesNames();
    public abstract virtual FileSystemPath get_Location();
    [NotNullAttribute]
public abstract virtual IMetadataTypeInfo GetTypeInfoFromQualifiedName(string assemblyQualifiedName, bool searchReferencedAssemblies);
    [NotNullAttribute]
public abstract virtual IMetadataTypeInfo GetTypeInfoFromToken(MetadataToken token);
    [NotNullAttribute]
public abstract virtual IMetadataType GetTypeFromQualifiedName(string qualifiedName, bool searchReferencedAssemblies);
    public abstract virtual IMetadataTypeInfo[] GetTypes();
    public abstract virtual IMetadataTypeInfo[] GetExportedTypes();
    public abstract virtual IDictionary`2<string, AssemblyNameInfo> GetForwardedTypes();
    public abstract virtual IMetadataManifestResource[] GetManifestResources();
    public abstract virtual IImageBodyReader CreateImageBodyReader();
    public abstract virtual IMethodBodyUsagesFinder CreateUsagesFinder();
    public abstract virtual IMetadataAssemblyInternals get_Internals();
    public abstract virtual IMetadataCustomAttribute[] get_ModuleAttributes();
}
public interface JetBrains.Metadata.Reader.API.IMetadataAssemblyInternals {
    public MetadataLoader Loader { get; }
    public IEnumerable`1<AssemblyReference> ReferencedAssemblies { get; }
    public IEnumerable`1<KeyValuePair`2<MetadataToken, string>> ReferencedModules { get; }
    public FileReference[] ReferencedFiles { get; }
    public IEntityPresentations EntityPresentations { get; }
    public abstract virtual MetadataLoader get_Loader();
    public abstract virtual IEnumerable`1<AssemblyReference> get_ReferencedAssemblies();
    public abstract virtual IEnumerable`1<KeyValuePair`2<MetadataToken, string>> get_ReferencedModules();
    public abstract virtual FileReference[] get_ReferencedFiles();
    [CanBeNullAttribute]
public abstract virtual AssemblyNameInfo GetReferencedAssemblyName(MetadataToken assemblyToken);
    [CanBeNullAttribute]
public abstract virtual IMetadataAssembly GetReferencedAssembly(MetadataToken assemblyToken);
    [CanBeNullAttribute]
public abstract virtual IMetadataAssembly GetReferencedAssembly(AssemblyReference assemblyReference);
    [CanBeNullAttribute]
public abstract virtual FileSystemPath GetReferencedFile(MetadataToken token);
    [CanBeNullAttribute]
public abstract virtual IMetadataAssembly GetAssemblyFromReferencedFile(MetadataToken token);
    public abstract virtual void ResetReferencedAssembliesCache();
    [CanBeNullAttribute]
public abstract virtual IMetadataType GetTypeFromToken(MetadataToken token);
    [CanBeNullAttribute]
public abstract virtual IMetadataType GetTypeFromToken(MetadataToken token, TypeDecodeContext context);
    public abstract virtual MethodSpecification GetMethodFromToken(MetadataToken methodToken);
    public abstract virtual MethodSpecification GetMethodFromToken(MetadataToken methodToken, TypeDecodeContext context);
    public abstract virtual FieldSpecification GetFieldFromToken(MetadataToken fieldToken, TypeDecodeContext typeContext);
    public abstract virtual IEntityPresentations get_EntityPresentations();
    public abstract virtual IMetadataType DecodeType(IBinaryReader reader, TypeDecodeContext context);
    public abstract virtual IEnumerable`1<Pair`2<string, MetadataToken>> GetAllCustomAttributeStringsWithTokens();
}
public interface JetBrains.Metadata.Reader.API.IMetadataBoxedType {
    public IMetadataType UnderlyingType { get; }
    public abstract virtual IMetadataType get_UnderlyingType();
}
public interface JetBrains.Metadata.Reader.API.IMetadataClassType {
    [NotNullAttribute]
public IMetadataTypeInfo Type { get; }
    [NotNullAttribute]
public IMetadataType[] Arguments { get; }
    public abstract virtual IMetadataTypeInfo get_Type();
    public abstract virtual IMetadataType[] get_Arguments();
}
public interface JetBrains.Metadata.Reader.API.IMetadataCustomAttribute {
    [CanBeNullAttribute]
public IMetadataMethod UsedConstructor { get; }
    public MetadataAttributeValue[] ConstructorArguments { get; }
    public IMetadataCustomAttributeFieldInitialization[] InitializedFields { get; }
    public IMetadataCustomAttributePropertyInitialization[] InitializedProperties { get; }
    public abstract virtual IMetadataMethod get_UsedConstructor();
    public abstract virtual MetadataAttributeValue[] get_ConstructorArguments();
    public abstract virtual IMetadataCustomAttributeFieldInitialization[] get_InitializedFields();
    public abstract virtual IMetadataCustomAttributePropertyInitialization[] get_InitializedProperties();
    [CanBeNullAttribute]
public abstract virtual Byte[] GetBytes();
}
public interface JetBrains.Metadata.Reader.API.IMetadataCustomAttributeFieldInitialization {
    public IMetadataField Field { get; }
    public MetadataAttributeValue Value { get; }
    public abstract virtual IMetadataField get_Field();
    public abstract virtual MetadataAttributeValue get_Value();
}
public interface JetBrains.Metadata.Reader.API.IMetadataCustomAttributePropertyInitialization {
    public IMetadataProperty Property { get; }
    public MetadataAttributeValue Value { get; }
    public abstract virtual IMetadataProperty get_Property();
    public abstract virtual MetadataAttributeValue get_Value();
}
public interface JetBrains.Metadata.Reader.API.IMetadataEntity {
    [CanBeNullAttribute]
public IMetadataAssembly Assembly { get; }
    public MetadataToken Token { get; }
    public IMetadataCustomAttribute[] CustomAttributes { get; }
    public MetadataTypeReference[] CustomAttributesTypeNames { get; }
    public bool IsResolved { get; }
    public abstract virtual IMetadataAssembly get_Assembly();
    public abstract virtual MetadataToken get_Token();
    public abstract virtual IMetadataCustomAttribute[] get_CustomAttributes();
    public abstract virtual MetadataTypeReference[] get_CustomAttributesTypeNames();
    public abstract virtual IList`1<IMetadataCustomAttribute> GetCustomAttributes(string attributeClassFullyQualifiedName);
    public abstract virtual bool HasCustomAttribute(string attributeClassFullyQualifiedName);
    public abstract virtual bool get_IsResolved();
}
public interface JetBrains.Metadata.Reader.API.IMetadataEvent {
    public IMetadataType Type { get; }
    public IMetadataMethod Adder { get; }
    public IMetadataMethod Remover { get; }
    public IMetadataMethod Raiser { get; }
    public IMetadataMethod[] OtherMethods { get; }
    public abstract virtual IMetadataType get_Type();
    public abstract virtual IMetadataMethod get_Adder();
    public abstract virtual IMetadataMethod get_Remover();
    public abstract virtual IMetadataMethod get_Raiser();
    public abstract virtual IMetadataMethod[] get_OtherMethods();
}
public interface JetBrains.Metadata.Reader.API.IMetadataField {
    [CanBeNullAttribute]
public IMetadataType Type { get; }
    [CanBeNullAttribute]
public IBlob MarshalSpec { get; }
    public int Offset { get; }
    [CanBeNullAttribute]
public FieldSignature Signature { get; }
    public UInt32 InitialValueRva { get; }
    public bool IsAssembly { get; }
    public bool IsPrivate { get; }
    public bool IsPublic { get; }
    public bool IsFamily { get; }
    public bool IsFamilyAndAssembly { get; }
    public bool IsFamilyOrAssembly { get; }
    public bool IsStatic { get; }
    public bool IsInitOnly { get; }
    public bool IsLiteral { get; }
    public bool HasMarshalSpec { get; }
    public bool NotSerialized { get; }
    public abstract virtual IMetadataType get_Type();
    public abstract virtual IBlob get_MarshalSpec();
    [CanBeNullAttribute]
public abstract virtual object GetLiteralValue();
    [CanBeNullAttribute]
public abstract virtual IBlob GetLiteralValueBlob();
    public abstract virtual int get_Offset();
    public abstract virtual FieldSignature get_Signature();
    public abstract virtual UInt32 get_InitialValueRva();
    public abstract virtual bool get_IsAssembly();
    public abstract virtual bool get_IsPrivate();
    public abstract virtual bool get_IsPublic();
    public abstract virtual bool get_IsFamily();
    public abstract virtual bool get_IsFamilyAndAssembly();
    public abstract virtual bool get_IsFamilyOrAssembly();
    public abstract virtual bool get_IsStatic();
    public abstract virtual bool get_IsInitOnly();
    public abstract virtual bool get_IsLiteral();
    public abstract virtual bool get_HasMarshalSpec();
    public abstract virtual bool get_NotSerialized();
}
public interface JetBrains.Metadata.Reader.API.IMetadataForwardedTypeInfo {
    public AssemblyNameInfo AssemblyName { get; }
    public string FullName { get; }
    public abstract virtual AssemblyNameInfo get_AssemblyName();
    public abstract virtual string get_FullName();
}
public interface JetBrains.Metadata.Reader.API.IMetadataFunctionPointerType {
    public MethodSignature MethodSignature { get; }
    public abstract virtual MethodSignature get_MethodSignature();
}
public interface JetBrains.Metadata.Reader.API.IMetadataGenericArgument {
    public GenericArgumentKind Kind { get; }
    public string Name { get; }
    public UInt32 Index { get; }
    public IMetadataTypeInfo TypeOwner { get; }
    public IMetadataMethod MethodOwner { get; }
    public IMetadataType[] TypeConstraints { get; }
    public GenericArgumentAttributes Attributes { get; }
    public abstract virtual GenericArgumentKind get_Kind();
    public abstract virtual string get_Name();
    public abstract virtual UInt32 get_Index();
    public abstract virtual IMetadataTypeInfo get_TypeOwner();
    public abstract virtual IMetadataMethod get_MethodOwner();
    public abstract virtual IMetadataType[] get_TypeConstraints();
    public abstract virtual GenericArgumentAttributes get_Attributes();
}
public interface JetBrains.Metadata.Reader.API.IMetadataGenericArgumentReferenceType {
    public IMetadataGenericArgument Argument { get; }
    public abstract virtual IMetadataGenericArgument get_Argument();
}
public interface JetBrains.Metadata.Reader.API.IMetadataManifestResource {
    public UInt32 Offset { get; }
    public ManifestResourceAttributes Flags { get; }
    public string Name { get; }
    public MetadataToken Implementation { get; }
    public abstract virtual UInt32 get_Offset();
    public abstract virtual ManifestResourceAttributes get_Flags();
    public abstract virtual string get_Name();
    public abstract virtual MetadataToken get_Implementation();
    [CanBeNullAttribute]
public abstract virtual IManifestResourceDisposition GetDisposition();
}
public interface JetBrains.Metadata.Reader.API.IMetadataMethod {
    public IMetadataReturnValue ReturnValue { get; }
    public IMetadataParameter[] Parameters { get; }
    public IMetadataGenericArgument[] GenericArguments { get; }
    public IList`1<MethodSpecification> ImplementedMethods { get; }
    public MethodSignature Signature { get; }
    [CanBeNullAttribute]
public PInvokeInfo PInvokeInfo { get; }
    public CorMethodImpl MethodImplFlags { get; }
    public bool IsPInvokeImpl { get; }
    public CodeType CodeType { get; }
    public UInt32 CodeRva { get; }
    public bool IsForwardRef { get; }
    public bool IsPreserveSig { get; }
    public bool IsInternalCall { get; }
    public bool IsSynchronized { get; }
    public bool NoInlining { get; }
    public bool AggressiveInlining { get; }
    public bool NoOptimization { get; }
    public bool IsAssembly { get; }
    public bool IsPrivate { get; }
    public bool IsPublic { get; }
    public bool IsFamily { get; }
    public bool IsFamilyAndAssembly { get; }
    public bool IsFamilyOrAssembly { get; }
    public bool IsStatic { get; }
    public bool IsAbstract { get; }
    public bool IsExtern { get; }
    public bool IsVirtual { get; }
    public bool IsFinal { get; }
    public bool IsHideBySig { get; }
    public bool IsNewSlot { get; }
    public bool IsStrict { get; }
    public bool IsVarArg { get; }
    public bool IsUnmanaged { get; }
    public abstract virtual IMetadataReturnValue get_ReturnValue();
    public abstract virtual IMetadataParameter[] get_Parameters();
    public abstract virtual IMetadataGenericArgument[] get_GenericArguments();
    public abstract virtual IList`1<MethodSpecification> get_ImplementedMethods();
    public abstract virtual MethodSignature get_Signature();
    public abstract virtual PInvokeInfo get_PInvokeInfo();
    public abstract virtual CorMethodImpl get_MethodImplFlags();
    public abstract virtual bool get_IsPInvokeImpl();
    public abstract virtual CodeType get_CodeType();
    public abstract virtual UInt32 get_CodeRva();
    public abstract virtual bool get_IsForwardRef();
    public abstract virtual bool get_IsPreserveSig();
    public abstract virtual bool get_IsInternalCall();
    public abstract virtual bool get_IsSynchronized();
    public abstract virtual bool get_NoInlining();
    public abstract virtual bool get_AggressiveInlining();
    public abstract virtual bool get_NoOptimization();
    public abstract virtual bool get_IsAssembly();
    public abstract virtual bool get_IsPrivate();
    public abstract virtual bool get_IsPublic();
    public abstract virtual bool get_IsFamily();
    public abstract virtual bool get_IsFamilyAndAssembly();
    public abstract virtual bool get_IsFamilyOrAssembly();
    public abstract virtual bool get_IsStatic();
    public abstract virtual bool get_IsAbstract();
    public abstract virtual bool get_IsExtern();
    public abstract virtual bool get_IsVirtual();
    public abstract virtual bool get_IsFinal();
    public abstract virtual bool get_IsHideBySig();
    public abstract virtual bool get_IsNewSlot();
    public abstract virtual bool get_IsStrict();
    public abstract virtual bool get_IsVarArg();
    public abstract virtual bool get_IsUnmanaged();
}
public interface JetBrains.Metadata.Reader.API.IMetadataParameter {
    public string Name { get; }
    public IMetadataType Type { get; }
    public IMetadataMethod DeclaringMethod { get; }
    [CanBeNullAttribute]
public IBlob MarshalSpec { get; }
    public bool IsIn { get; }
    public bool IsOut { get; }
    public bool IsParamArray { get; }
    public bool IsOptional { get; }
    public bool HasMarshalSpec { get; }
    public bool HasDefaultValue { get; }
    public abstract virtual string get_Name();
    public abstract virtual IMetadataType get_Type();
    public abstract virtual IMetadataMethod get_DeclaringMethod();
    public abstract virtual IBlob get_MarshalSpec();
    public abstract virtual bool get_IsIn();
    public abstract virtual bool get_IsOut();
    public abstract virtual bool get_IsParamArray();
    public abstract virtual bool get_IsOptional();
    public abstract virtual bool get_HasMarshalSpec();
    public abstract virtual bool get_HasDefaultValue();
    public abstract virtual object GetDefaultValue();
    public abstract virtual IBlob GetDefaultValueBlob();
}
public interface JetBrains.Metadata.Reader.API.IMetadataPointerType {
    public IMetadataType Type { get; }
    public abstract virtual IMetadataType get_Type();
}
public interface JetBrains.Metadata.Reader.API.IMetadataProperty {
    public IMetadataType Type { get; }
    public IMetadataMethod Getter { get; }
    public IMetadataMethod Setter { get; }
    public IMetadataMethod[] OtherAccessors { get; }
    public abstract virtual IMetadataType get_Type();
    public abstract virtual IMetadataMethod get_Getter();
    public abstract virtual IMetadataMethod get_Setter();
    public abstract virtual IMetadataMethod[] get_OtherAccessors();
}
public interface JetBrains.Metadata.Reader.API.IMetadataReferenceType {
    public IMetadataType Type { get; }
    public abstract virtual IMetadataType get_Type();
}
public interface JetBrains.Metadata.Reader.API.IMetadataReturnValue {
    public IMetadataMethod DeclaringMethod { get; }
    public IMetadataType Type { get; }
    [CanBeNullAttribute]
public IBlob MarshalSpec { get; }
    public bool HasMarshalSpec { get; }
    public abstract virtual IMetadataMethod get_DeclaringMethod();
    public abstract virtual IMetadataType get_Type();
    public abstract virtual IBlob get_MarshalSpec();
    public abstract virtual bool get_HasMarshalSpec();
}
public interface JetBrains.Metadata.Reader.API.IMetadataSecurityAttribute {
    [NotNullAttribute]
public IMetadataSecurityRow DeclaringSecurityRow { get; }
    [NotNullAttribute]
public IMetadataTypeInfo Type { get; }
    public IMetadataCustomAttributeFieldInitialization[] InitializedFields { get; }
    public IMetadataCustomAttributePropertyInitialization[] InitializedProperties { get; }
    [CanBeNullAttribute]
public Byte[] ConstructorArgumentsBlob { get; }
    public SecurityAction Action { get; }
    public abstract virtual IMetadataSecurityRow get_DeclaringSecurityRow();
    public abstract virtual IMetadataTypeInfo get_Type();
    public abstract virtual IMetadataCustomAttributeFieldInitialization[] get_InitializedFields();
    public abstract virtual IMetadataCustomAttributePropertyInitialization[] get_InitializedProperties();
    public abstract virtual Byte[] get_ConstructorArgumentsBlob();
    public abstract virtual SecurityAction get_Action();
}
public interface JetBrains.Metadata.Reader.API.IMetadataSecurityOwner {
    [NotNullAttribute]
public IMetadataSecurityRow[] Security { get; }
    [NotNullAttribute]
public String[] SecurityAttributesTypeName { get; }
    public bool HasSecurity { get; }
    public abstract virtual IMetadataSecurityRow[] get_Security();
    public abstract virtual String[] get_SecurityAttributesTypeName();
    public abstract virtual bool get_HasSecurity();
}
public interface JetBrains.Metadata.Reader.API.IMetadataSecurityRow {
    public SecurityAction Action { get; }
    public IMetadataSecurityAttribute[] Attributes { get; }
    public abstract virtual SecurityAction get_Action();
    public abstract virtual IMetadataSecurityAttribute[] get_Attributes();
}
[CannotApplyEqualityOperatorAttribute]
public interface JetBrains.Metadata.Reader.API.IMetadataType {
    public string AssemblyQualifiedName { get; }
    public string FullName { get; }
    public string AssemblyQualification { get; }
    public IMetadataTypeModifier[] TypeModifiers { get; }
    public bool Pinned { get; }
    public bool IsResolved { get; }
    public abstract virtual string get_AssemblyQualifiedName();
    public abstract virtual string get_FullName();
    public abstract virtual string get_AssemblyQualification();
    public abstract virtual IMetadataTypeModifier[] get_TypeModifiers();
    public abstract virtual bool get_Pinned();
    public abstract virtual bool get_IsResolved();
    public abstract virtual void Accept(IMetadataTypeVisitor visitor);
    public abstract virtual IMetadataType Transform(IMetadataTypeTransformer transformer);
}
public interface JetBrains.Metadata.Reader.API.IMetadataTypeInfo {
    public string FullyQualifiedName { get; }
    public string AssemblyQualifiedName { get; }
    public string NamespaceName { get; }
    public string TypeName { get; }
    [CanBeNullAttribute]
public AssemblyNameInfo DeclaringAssemblyName { get; }
    [CanBeNullAttribute]
public IMetadataClassType Base { get; }
    public IMetadataClassType[] Interfaces { get; }
    public IMetadataGenericArgument[] GenericParameters { get; }
    public bool IsAbstract { get; }
    public bool IsSealed { get; }
    public bool IsImported { get; }
    public ClassLayoutType Layout { get; }
    public CharSetSpec InteropStringFormat { get; }
    public bool IsBeforeFieldInit { get; }
    public bool IsClass { get; }
    public bool IsInterface { get; }
    public bool IsSerializable { get; }
    public bool IsWindowsRuntime { get; }
    public bool IsPublic { get; }
    public bool IsNotPublic { get; }
    public bool IsNested { get; }
    public bool IsNestedPublic { get; }
    public bool IsNestedPrivate { get; }
    public bool IsNestedFamily { get; }
    public bool IsNestedAssembly { get; }
    public bool IsNestedFamilyAndAssembly { get; }
    public bool IsNestedFamilyOrAssembly { get; }
    public int PackingSize { get; }
    public int ClassSize { get; }
    public abstract virtual string get_FullyQualifiedName();
    public abstract virtual string get_AssemblyQualifiedName();
    public abstract virtual string get_NamespaceName();
    public abstract virtual string get_TypeName();
    public abstract virtual AssemblyNameInfo get_DeclaringAssemblyName();
    public abstract virtual IMetadataClassType get_Base();
    public abstract virtual IMetadataClassType[] get_Interfaces();
    public abstract virtual IMetadataGenericArgument[] get_GenericParameters();
    public abstract virtual bool get_IsAbstract();
    public abstract virtual bool get_IsSealed();
    public abstract virtual bool get_IsImported();
    public abstract virtual ClassLayoutType get_Layout();
    public abstract virtual CharSetSpec get_InteropStringFormat();
    public abstract virtual bool get_IsBeforeFieldInit();
    public abstract virtual bool get_IsClass();
    public abstract virtual bool get_IsInterface();
    public abstract virtual bool get_IsSerializable();
    public abstract virtual bool get_IsWindowsRuntime();
    public abstract virtual bool get_IsPublic();
    public abstract virtual bool get_IsNotPublic();
    public abstract virtual bool get_IsNested();
    public abstract virtual bool get_IsNestedPublic();
    public abstract virtual bool get_IsNestedPrivate();
    public abstract virtual bool get_IsNestedFamily();
    public abstract virtual bool get_IsNestedAssembly();
    public abstract virtual bool get_IsNestedFamilyAndAssembly();
    public abstract virtual bool get_IsNestedFamilyOrAssembly();
    public abstract virtual int get_PackingSize();
    public abstract virtual int get_ClassSize();
    public abstract virtual IEnumerable`1<MemberInfo> GetMemberInfos();
    public abstract virtual IMetadataMethod[] GetMethods();
    public abstract virtual IMetadataField[] GetFields();
    public abstract virtual IMetadataProperty[] GetProperties();
    public abstract virtual IMetadataEvent[] GetEvents();
    public abstract virtual IMetadataTypeInfo[] GetNestedTypes();
    public abstract virtual bool HasExtensionMethods();
}
public interface JetBrains.Metadata.Reader.API.IMetadataTypeMember {
    [NotNullAttribute]
public string Name { get; }
    public IMetadataTypeInfo DeclaringType { get; }
    public bool IsSpecialName { get; }
    public bool IsRuntimeSpecialName { get; }
    public abstract virtual string get_Name();
    public abstract virtual IMetadataTypeInfo get_DeclaringType();
    public abstract virtual bool get_IsSpecialName();
    public abstract virtual bool get_IsRuntimeSpecialName();
}
public interface JetBrains.Metadata.Reader.API.IMetadataTypeModifier {
    public MetadataModifierKind Kind { get; }
    public IMetadataType Type { get; }
    public abstract virtual MetadataModifierKind get_Kind();
    public abstract virtual IMetadataType get_Type();
}
public interface JetBrains.Metadata.Reader.API.IMetadataTypeTransformer {
    public abstract virtual IMetadataType TransformArrayType(IMetadataArrayType arrayType);
    public abstract virtual IMetadataType TransformClassType(IMetadataClassType classType);
    public abstract virtual IMetadataType TransformPointerType(IMetadataPointerType pointerType);
    public abstract virtual IMetadataType TransformReferenceType(IMetadataReferenceType referenceType);
    public abstract virtual IMetadataType TransformGenericArgumentReferenceType(IMetadataGenericArgumentReferenceType genericArgumentReferenceType);
    public abstract virtual IMetadataType TransformFunctionPointerType(IMetadataFunctionPointerType functionPointerType);
}
public interface JetBrains.Metadata.Reader.API.IMetadataTypeVisitor {
    public abstract virtual void VisitUnknownType(IMetadataType unknownType);
    public abstract virtual void VisitArrayType(IMetadataArrayType arrayType);
    public abstract virtual void VisitClassType(IMetadataClassType classType);
    public abstract virtual void VisitPointerType(IMetadataPointerType pointerType);
    public abstract virtual void VisitReferenceType(IMetadataReferenceType referenceType);
    public abstract virtual void VisitGenericArgumentReferenceType(IMetadataGenericArgumentReferenceType genericArgumentReferenceType);
    public abstract virtual void VisitFunctionPointer(IMetadataFunctionPointerType functionPointerType);
}
public interface JetBrains.Metadata.Reader.API.IMethodBody {
    [NotNullAttribute]
public IMetadataMethod Method { get; }
    [NotNullAttribute]
public IMethodBodyLocalVariable[] LocalVariables { get; }
    [NotNullAttribute]
public Instruction[] Instructions { get; }
    [NotNullAttribute]
public IMethodBodyExceptionHandler[] ExceptionHandlers { get; }
    public int MaxStack { get; }
    public MetadataToken LocalVariablesSignatureToken { get; }
    public abstract virtual IMetadataMethod get_Method();
    public abstract virtual IMethodBodyLocalVariable[] get_LocalVariables();
    public abstract virtual Instruction[] get_Instructions();
    public abstract virtual IMethodBodyExceptionHandler[] get_ExceptionHandlers();
    public abstract virtual int get_MaxStack();
    public abstract virtual MetadataToken get_LocalVariablesSignatureToken();
}
public interface JetBrains.Metadata.Reader.API.IMethodBodyExceptionHandler {
    public ExceptionHandlerType Type { get; }
    public int HandlerLength { get; }
    public int HandlerOffset { get; }
    [CanBeNullAttribute]
public IMetadataType CatchType { get; }
    public int FilterOffset { get; }
    public int TryLength { get; }
    public int TryOffset { get; }
    public abstract virtual ExceptionHandlerType get_Type();
    public abstract virtual int get_HandlerLength();
    public abstract virtual int get_HandlerOffset();
    public abstract virtual IMetadataType get_CatchType();
    public abstract virtual int get_FilterOffset();
    public abstract virtual int get_TryLength();
    public abstract virtual int get_TryOffset();
}
public interface JetBrains.Metadata.Reader.API.IMethodBodyLocalVariable {
    public IMetadataMethod Method { get; }
    public int Index { get; }
    public IMetadataType Type { get; }
    public bool Pinned { get; }
    public abstract virtual IMetadataMethod get_Method();
    public abstract virtual int get_Index();
    public abstract virtual IMetadataType get_Type();
    public abstract virtual bool get_Pinned();
}
public interface JetBrains.Metadata.Reader.API.IMethodBodyUsagesFinder {
    public abstract virtual IReadOnlyList`1<MethodUsageCount> FindUsagesOf(IMetadataMethod method);
    public abstract virtual IReadOnlyList`1<MethodUsageCount> FindUsagesOf(IMetadataField field);
    public abstract virtual IReadOnlyList`1<MethodUsageCount> FindUsagesOf(IMetadataTypeInfo typeInfo);
    public abstract virtual IReadOnlyList`1<MethodUsageCount> FindUsagesOf(MetadataToken userStringToken, string userString);
    public abstract virtual IReadOnlyList`1<MethodUsageCount> FindDefaultConstructorUsagesOfValueType(IMetadataTypeInfo typeInfo);
}
public interface JetBrains.Metadata.Reader.API.IModuleReferenceResolveContext {
    [NotNullAttribute]
public string UniqueName { get; }
    public AssemblyNameAndLocation Originator { get; }
    [NotNullAttribute]
public TargetFrameworkId TargetFramework { get; }
    public abstract virtual string get_UniqueName();
    public abstract virtual bool IsValid();
    public abstract virtual AssemblyNameAndLocation get_Originator();
    public abstract virtual TargetFrameworkId get_TargetFramework();
    public abstract virtual void Write(BinaryWriter writer);
}
internal interface JetBrains.Metadata.Reader.API.IOperandTokenMapping {
    public abstract virtual MetadataToken GetTokenByInstructionOperand(object instructionOperand);
}
public interface JetBrains.Metadata.Reader.API.ITypeInfoByNameProvider {
    public abstract virtual IMetadataTypeInfo GetTypeInfoFromQualifiedName(string name, AssemblyNameInfo assemblyName, bool searchReferencedAssemblies);
}
public class JetBrains.Metadata.Reader.API.MarshalSpec.ArrayMarshalSpec : MarshalSpecBase {
    private NativeType myElementType;
    private int myNumElem;
    private int myParamNum;
    public NativeType ElementType { get; }
    public int ParamNum { get; }
    public int NumElem { get; }
    public ArrayMarshalSpec(NativeType elementType, int paramNum, int numElem);
    public NativeType get_ElementType();
    public int get_ParamNum();
    public int get_NumElem();
    public virtual string ToString();
}
public class JetBrains.Metadata.Reader.API.MarshalSpec.CustomMarshalerMarshalSpec : MarshalSpecBase {
    private string myCookie;
    private Guid myGuid;
    private string myManagedType;
    private string myUnmanagedType;
    public string Cookie { get; }
    public string ManagedType { get; }
    public string UnmanagedType { get; }
    public Guid Guid { get; }
    public CustomMarshalerMarshalSpec(Guid guid, string unmanagedType, string managedType, string cookie);
    public string get_Cookie();
    public string get_ManagedType();
    public string get_UnmanagedType();
    public Guid get_Guid();
    public virtual string ToString();
}
public class JetBrains.Metadata.Reader.API.MarshalSpec.FixedArrayMarshalSpec : MarshalSpecBase {
    private NativeType myElementType;
    private int myNumElem;
    public NativeType ElementType { get; }
    public int NumElem { get; }
    public FixedArrayMarshalSpec(NativeType elementType, int numElem);
    public NativeType get_ElementType();
    public int get_NumElem();
    public virtual string ToString();
}
public class JetBrains.Metadata.Reader.API.MarshalSpec.FixedSysStringMarshalSpec : MarshalSpecBase {
    private int mySize;
    public int Size { get; }
    public FixedSysStringMarshalSpec(int size);
    public int get_Size();
    public virtual string ToString();
}
public interface JetBrains.Metadata.Reader.API.MarshalSpec.IMarshalSpec {
    public NativeType Type { get; }
    public abstract virtual NativeType get_Type();
}
public class JetBrains.Metadata.Reader.API.MarshalSpec.IntrinsicMarshalSpec : MarshalSpecBase {
    public IntrinsicMarshalSpec(NativeType type);
    public virtual string ToString();
}
public abstract class JetBrains.Metadata.Reader.API.MarshalSpec.MarshalSpecBase : object {
    private NativeType myType;
    public NativeType Type { get; }
    protected MarshalSpecBase(NativeType type);
    public sealed virtual NativeType get_Type();
}
public enum JetBrains.Metadata.Reader.API.MarshalSpec.NativeType : Enum {
    public int value__;
    public static NativeType NONE;
    public static NativeType BOOLEAN;
    public static NativeType I1;
    public static NativeType U1;
    public static NativeType I2;
    public static NativeType U2;
    public static NativeType I4;
    public static NativeType U4;
    public static NativeType I8;
    public static NativeType U8;
    public static NativeType R4;
    public static NativeType R8;
    public static NativeType LPSTR;
    public static NativeType INT;
    public static NativeType UINT;
    public static NativeType FUNC;
    public static NativeType ARRAY;
    public static NativeType CURRENCY;
    public static NativeType BSTR;
    public static NativeType LPWSTR;
    public static NativeType LPTSTR;
    public static NativeType FIXEDSYSSTRING;
    public static NativeType IUNKNOWN;
    public static NativeType IDISPATCH;
    public static NativeType STRUCT;
    public static NativeType INTF;
    public static NativeType SAFEARRAY;
    public static NativeType FIXEDARRAY;
    public static NativeType BYVALSTR;
    public static NativeType ANSIBSTR;
    public static NativeType TBSTR;
    public static NativeType VARIANTBOOL;
    public static NativeType ASANY;
    public static NativeType LPSTRUCT;
    public static NativeType CUSTOMMARSHALER;
    public static NativeType ERROR;
    public static NativeType IINSPECTABLE;
    public static NativeType HSTRING;
    public static NativeType MAX;
}
public class JetBrains.Metadata.Reader.API.MarshalSpec.SafeArrayMarshalSpec : MarshalSpecBase {
    private VariantType myElementType;
    public VariantType ElementType { get; }
    public SafeArrayMarshalSpec(VariantType elementType);
    public VariantType get_ElementType();
    public virtual string ToString();
}
public enum JetBrains.Metadata.Reader.API.MarshalSpec.VariantType : Enum {
    public int value__;
    public static VariantType NONE;
    public static VariantType NULL;
    public static VariantType I2;
    public static VariantType I4;
    public static VariantType R4;
    public static VariantType R8;
    public static VariantType CY;
    public static VariantType DATE;
    public static VariantType BSTR;
    public static VariantType DISPATCH;
    public static VariantType ERROR;
    public static VariantType BOOL;
    public static VariantType VARIANT;
    public static VariantType UNKNOWN;
    public static VariantType DECIMAL;
    public static VariantType I1;
    public static VariantType UI1;
    public static VariantType UI2;
    public static VariantType UI4;
    public static VariantType I8;
    public static VariantType UI8;
    public static VariantType INT;
    public static VariantType UINT;
    public static VariantType VOID;
    public static VariantType HRESULT;
    public static VariantType PTR;
    public static VariantType SAFEARRAY;
    public static VariantType CARRAY;
    public static VariantType USERDEFINED;
    public static VariantType LPSTR;
    public static VariantType LPWSTR;
    public static VariantType RECORD;
    public static VariantType FILETIME;
    public static VariantType BLOB;
    public static VariantType STREAM;
    public static VariantType STORAGE;
    public static VariantType STREAMED_OBJECT;
    public static VariantType STORED_OBJECT;
    public static VariantType BLOB_OBJECT;
    public static VariantType CF;
    public static VariantType CLSID;
    public static VariantType VECTOR;
    public static VariantType ARRAY;
    public static VariantType BYREF;
}
public class JetBrains.Metadata.Reader.API.MemberInfo : ValueType {
    public string Name;
    public MetadataToken Token;
    public MemberInfo(string name, MetadataToken token);
}
public class JetBrains.Metadata.Reader.API.MetadataAttributeValue : ValueType {
    public static MetadataAttributeValue BadValue;
    private IMetadataType myType;
    private object myValue;
    public IMetadataType Type { get; }
    public object Value { get; }
    public MetadataAttributeValue[] ValuesArray { get; }
    private MetadataAttributeValue(IMetadataType type, object value);
    private static MetadataAttributeValue();
    public IMetadataType get_Type();
    public object get_Value();
    public MetadataAttributeValue[] get_ValuesArray();
    public static MetadataAttributeValue MakeArray(IMetadataArrayType arrayType, MetadataAttributeValue[] valuesArray);
    public static MetadataAttributeValue MakeScalar(IMetadataType type, object value);
    public static MetadataAttributeValue MakeScalar(IMetadataAssembly assembly, string type, object value);
    public bool IsBadValue();
    public virtual string ToString();
}
[ExtensionAttribute]
public static class JetBrains.Metadata.Reader.API.MetadataEx : object {
    private static string CSharpClosureTypeNamePrefix;
    private static string VBClosureTypeNamePrefix;
    private static string Uniti3DClosureTypeNameMiddle;
    private static string CSharpAnonymousTypeNamePrefix;
    private static string VBAnonymousTypeNamePrefix;
    private static Dictionary`2<Type, ElementType> TypeToElementType;
    private static MetadataEx();
    [ExtensionAttribute]
public static ElementType ToElementType(Type type);
    [ExtensionAttribute]
public static ElementType ToElementType(IMetadataType type);
    [ExtensionAttribute]
public static IMetadataClassType ToClassType(IMetadataTypeInfo typeInfo);
    [ExtensionAttribute]
public static IMetadataReferenceType ToReferenceType(IMetadataType type);
    [ExtensionAttribute]
public static IMetadataPointerType ToPointerType(IMetadataType type);
    [ExtensionAttribute]
public static IMetadataMethod GetMethodFromFullyQualifiedName(IMetadataAssembly assembly, string fqn);
    [ExtensionAttribute]
public static IMetadataMethod GetMethodFromName(IMetadataAssembly assembly, string classFqn, string methodName);
    [ExtensionAttribute]
public static ICollection`1<IMetadataMethod> GetMatchingMethods(IMetadataAssembly assembly, string classFqn, string methodName);
    [ExtensionAttribute]
public static IMetadataMethod GetMethodFromFullyQualifiedNameAndSignature(IMetadataAssembly assembly, string fqn, IMetadataType[] signature);
    [ExtensionAttribute]
public static IMetadataProperty GetPropertyFromFullyQualifiedName(IMetadataAssembly assembly, string fqn);
    [ExtensionAttribute]
public static IMetadataField GetFieldFromFullyQualifiedName(IMetadataAssembly assembly, string fqn);
    [CanBeNullAttribute]
[ExtensionAttribute]
public static IMetadataProperty GetPropertyFromAccessor(IMetadataMethod method);
    [CanBeNullAttribute]
[ExtensionAttribute]
public static IMetadataEvent GetEventFromAccessor(IMetadataMethod method);
    [ExtensionAttribute]
public static bool IsInterface(IMetadataType type);
    [ExtensionAttribute]
public static bool IsArray(IMetadataTypeInfo info);
    [ExtensionAttribute]
public static bool IsVector(IMetadataArrayType type);
    [ExtensionAttribute]
public static bool IsIndexer(IMetadataProperty property);
    [ExtensionAttribute]
public static bool IsExplicitInterfaceIndexer(IMetadataProperty property);
    [ExtensionAttribute]
public static string GetShortName(IMetadataProperty property);
    private static string GetShortName(string fullName);
    [ExtensionAttribute]
public static bool IsConstructor(IMetadataMethod method);
    [ExtensionAttribute]
public static bool IsOperator(IMetadataMethod method);
    [ExtensionAttribute]
public static bool IsClassConstructor(IMetadataMethod method);
    [ExtensionAttribute]
public static bool IsFinalizer(IMetadataMethod method);
    [ExtensionAttribute]
public static bool IsExtensionMethod(IMetadataMethod method);
    [ExtensionAttribute]
public static bool IsPropertyGetter(IMetadataMethod method);
    [ExtensionAttribute]
public static bool IsPropertyGetter(IMetadataMethod method, IMetadataProperty& property);
    [ExtensionAttribute]
public static bool IsPropertySetter(IMetadataMethod method);
    [ExtensionAttribute]
public static bool IsPropertySetter(IMetadataMethod method, IMetadataProperty& property);
    [ExtensionAttribute]
public static bool IsEventAdder(IMetadataMethod method);
    [ExtensionAttribute]
public static bool IsEventAdder(IMetadataMethod method, IMetadataEvent& event);
    [ExtensionAttribute]
public static bool IsEventRemover(IMetadataMethod method);
    [ExtensionAttribute]
public static bool IsEventRemover(IMetadataMethod method, IMetadataEvent& event);
    [ExtensionAttribute]
public static bool IsCompilerGenerated(IMetadataType type);
    [ExtensionAttribute]
public static bool IsCompilerGenerated(IMetadataEntity entity);
    [ExtensionAttribute]
public static bool IsHeriditaryCompilerGenerated(IMetadataMethod method);
    [ExtensionAttribute]
public static bool IsHereditaryCompilerGenerated(IMetadataField field);
    [ExtensionAttribute]
public static bool IsHereditaryCompilerGenerated(IMetadataType type);
    [ExtensionAttribute]
public static bool IsHereditaryCompilerGenerated(IMetadataTypeInfo typeInfo);
    [ExtensionAttribute]
public static bool IsClosureFrameType(IMetadataType type);
    [ExtensionAttribute]
public static bool IsAnonymousType(IMetadataType type);
    [ExtensionAttribute]
public static bool IsRecursivelyAnonymousType(IMetadataType type);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static IMetadataClassType GetPresentableExplicitInterface(IMetadataProperty property);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static IMetadataClassType GetPresentableExplicitInterface(IMetadataEvent evt);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static IMetadataClassType GetPresentableExplicitInterface(IMetadataMethod method);
}
[ExtensionAttribute]
public static class JetBrains.Metadata.Reader.API.MetadataFieldEx : object {
    [ExtensionAttribute]
public static bool IsVolatile(IMetadataField field);
}
[ExtensionAttribute]
public static class JetBrains.Metadata.Reader.API.MetadataGenericArgumentExtensions : object {
    [ExtensionAttribute]
public static bool IsCovariant(IMetadataGenericArgument metadataGenericArgument);
    [ExtensionAttribute]
public static bool IsContravariant(IMetadataGenericArgument metadataGenericArgument);
    [ExtensionAttribute]
public static bool HasClassConstraint(IMetadataGenericArgument metadataGenericArgument);
    [ExtensionAttribute]
public static bool HasStructConstraint(IMetadataGenericArgument metadataGenericArgument);
    [ExtensionAttribute]
public static bool HasDefaultConstructorConstraint(IMetadataGenericArgument metadataGenericArgument);
}
public class JetBrains.Metadata.Reader.API.MetadataLoader : SafeDisposable {
    private static Dictionary`2<string, ElementType> ElementTypes;
    private static ElementTypeName[] ElementTypeNames;
    private List`1<IMetadataAssembly> myLoadedAssemblies;
    private List`1<IMetadataAccess> myMetadataAccessToDispose;
    private IAssemblyResolver myResolver;
    private bool myGuardMultiThreading;
    private Dictionary`2<string, IMetadataTypeInfo> myWellKnownTypesByName;
    private IMetadataProvider myMetadataProvider;
    private Thread myOwningThread;
    private bool myDisposed;
    private bool myWellKnownTypesResolved;
    [CompilerGeneratedAttribute]
private MetadataLoaderErrors <ErrorNotifications>k__BackingField;
    [CompilerGeneratedAttribute]
private static Func`2<IMetadataTypeInfo, bool> CS$<>9__CachedAnonymousMethodDelegate13;
    [CompilerGeneratedAttribute]
private static Action`1<IMetadataAccess> CS$<>9__CachedAnonymousMethodDelegate15;
    [NotNullAttribute]
public MetadataLoaderErrors ErrorNotifications { get; private set; }
    private static MetadataLoader();
    public MetadataLoader(FileSystemPath[] folders);
    public MetadataLoader(IEnumerable`1<FileSystemPath> folders, Func`2<FileSystemPath, bool> filesExists);
    public MetadataLoader(IMetadataProvider metadataProvider, FileSystemPath[] folders);
    public MetadataLoader(IMetadataProvider metadataProvider, IEnumerable`1<FileSystemPath> folders, Func`2<FileSystemPath, bool> filesExists);
    public MetadataLoader(IAssemblyResolver resolver);
    public MetadataLoader(IMetadataProvider metadataProvider, IAssemblyResolver resolver, bool guardMultiThreading);
    public static ElementTypeName GetElementTypeMapping(ElementType elementType);
    private static void SetElementTypeMapping(ElementType elementType, string typeName);
    [CanBeNullAttribute]
public IMetadataAssembly TryLoadFrom(FileSystemPath file, Func`2<AssemblyNameInfo, bool> loadReferencedAssembly, bool loadElementTypes);
    [NotNullAttribute]
public IMetadataAssembly LoadFrom(FileSystemPath file, Func`2<AssemblyNameInfo, bool> loadReferencedAssembly, bool loadElementTypes);
    public void RemoveAssemblyByMvid(Guid mvid);
    [NotNullAttribute]
public IMetadataAssembly LoadAssemblyModule(FileSystemPath file, IMetadataAccess access, MetadataToken moduleToken, Func`2<AssemblyNameInfo, bool> loadReferencedAssembly, bool loadElementTypes);
    [CanBeNullAttribute]
public IMetadataAssembly TryLoad(AssemblyNameInfo assemblyName, Func`2<AssemblyNameInfo, bool> loadReferencedAssembly, bool loadElementTypes, IMetadataAssembly originator);
    private IMetadataAssembly GetLoadedAssemblyByMvid(Guid mvid);
    private IMetadataAssembly GetLoadedAssemblyByName(AssemblyNameInfo name);
    private IMetadataAssembly GetLoadedAssemblyByPath(FileSystemPath path);
    private void RegisterAssembly(IMetadataAssembly assembly, bool loadElementTypes);
    private IMetadataTypeInfo GetWellKnownType(string fqn);
    public IMetadataTypeInfo GetWellKnownType(ElementType elementType);
    internal static ElementType FindElementType(IMetadataTypeInfo metadataTypeInfo);
    public static ElementType FindElementType(IMetadataType metadataType);
    [CompilerGeneratedAttribute]
public MetadataLoaderErrors get_ErrorNotifications();
    [CompilerGeneratedAttribute]
private void set_ErrorNotifications(MetadataLoaderErrors value);
    protected virtual void DisposeUnmanagedResources();
    internal void AssertCorrectThread();
    public string DumpResolversInformation();
    [CompilerGeneratedAttribute]
private static bool <RegisterAssembly>b__12(IMetadataTypeInfo type);
    [CompilerGeneratedAttribute]
private static void <DisposeUnmanagedResources>b__14(IMetadataAccess ma);
}
public class JetBrains.Metadata.Reader.API.MetadataLoaderErrors : object {
    [NotNullAttribute]
public ISignalOptionalFiring`1<IncompleteAttributeArgs> IncompleteAttribute;
    [NotNullAttribute]
public ISignalOptionalFiring`1<UndeclaredAssemblyReferenceArgs> UndeclaredAssemblyReference;
    [NotNullAttribute]
public ISignalOptionalFiring`1<UnresolvedTypeArgs> UnresolvedType;
}
public enum JetBrains.Metadata.Reader.API.MetadataModifierKind : Enum {
    public int value__;
    public static MetadataModifierKind Optional;
    public static MetadataModifierKind Required;
}
[ExtensionAttribute]
public static class JetBrains.Metadata.Reader.API.MetadataParameterEx : object {
    [ExtensionAttribute]
public static int Index(IMetadataParameter parameter);
    [ExtensionAttribute]
[NotNullAttribute]
public static string GetNonEmptyName(IMetadataParameter parameter);
    [ExtensionAttribute]
[NotNullAttribute]
public static string GetIndexedName(IMetadataParameter parameter);
    [NotNullAttribute]
public static string GetParameterIndexedName(int index, bool parametersOwnerIsStatic);
}
public class JetBrains.Metadata.Reader.API.MetadataTypeComparer : object {
    public static IEqualityComparer`1<IMetadataType> Instance;
    [CompilerGeneratedAttribute]
private static Func`2<IMetadataTypeModifier, bool> CS$<>9__CachedAnonymousMethodDelegate2;
    [CompilerGeneratedAttribute]
private static Func`2<IMetadataTypeModifier, bool> CS$<>9__CachedAnonymousMethodDelegate3;
    private static MetadataTypeComparer();
    public sealed virtual bool Equals(IMetadataType type1, IMetadataType type2);
    public sealed virtual int GetHashCode(IMetadataType type);
    [CompilerGeneratedAttribute]
private static bool <Equals>b__0(IMetadataTypeModifier x);
    [CompilerGeneratedAttribute]
private static bool <Equals>b__1(IMetadataTypeModifier x);
}
[ExtensionAttribute]
public static class JetBrains.Metadata.Reader.API.MetadataTypeEx : object {
    [CompilerGeneratedAttribute]
private static Func`2<IMetadataGenericArgument, string> CS$<>9__CachedAnonymousMethodDelegatee;
    [ExtensionAttribute]
public static JetHashSet`1<IMetadataClassType> GetBaseTypesAndInterfacesRecursive(IMetadataClassType type);
    [ExtensionAttribute]
public static IEnumerable`1<IMetadataType> GetBaseTypes(IMetadataType type);
    public static IMetadataType ComputeClosestSupertype(IMetadataType type1, IMetadataType type2);
    [ExtensionAttribute]
public static bool IsSubtypeOf(IMetadataType subType, IMetadataType superType);
    [ExtensionAttribute]
public static bool IsBaseOf(IMetadataType baseType, IMetadataType derivedType);
    [ExtensionAttribute]
public static bool IsImplementedBy(IMetadataType interfaceType, IMetadataType implementationType);
    [ExtensionAttribute]
public static bool IsImplementationOf(MethodSpecification interfaceMethod, MethodSpecification implementationMethod);
    [ExtensionAttribute]
public static bool IsCompatibleWith(IMetadataType type1, IMetadataType type2);
    [ExtensionAttribute]
public static bool IsBinaryEquivalentTo(IMetadataType type1, IMetadataType type2);
    [ExtensionAttribute]
public static bool IsAssignmentCompatibleWith(IMetadataType weakerType, IMetadataType strongerType);
    [ExtensionAttribute]
public static bool IsImplicitNumericConvertibleTo(IMetadataType from, IMetadataType to);
    [ExtensionAttribute]
public static bool IsEqualTo(IMetadataType type1, IMetadataType type2);
    [ExtensionAttribute]
public static IMetadataType UnwrapArrayType(IMetadataType type);
    [ExtensionAttribute]
public static IMetadataType UnwrapEnumType(IMetadataType type);
    [ExtensionAttribute]
public static IMetadataType UnwrapBoxedType(IMetadataType type);
    [ExtensionAttribute]
public static T LookupMember(IMetadataClassType type, Func`2<IMetadataTypeInfo, IEnumerable`1<T>> membersSelector, Predicate`1<T> memberChecker);
    private static LookupResult LookupMember(IMetadataClassType type, Func`2<IMetadataTypeInfo, IEnumerable`1<T>> membersSelector, Predicate`1<T> memberChecker, T& member);
    private static LookupResult LookupInterfaceMember(IMetadataClassType type, JetHashSet`1<IMetadataClassType> visistedTypes, Func`2<IMetadataTypeInfo, IEnumerable`1<T>> membersSelector, Predicate`1<T> memberChecker, T& member);
    private static LookupResult LookupMemberNonRecursive(IMetadataClassType type, Func`2<IMetadataTypeInfo, IEnumerable`1<T>> membersSelector, Predicate`1<T> memberChecker, T& member);
    [ExtensionAttribute]
public static IMetadataType ToBoxedType(IMetadataType type);
    private static string StripTypeParametersCount(IMetadataTypeInfo type, string name);
    [ExtensionAttribute]
public static string TypeParametersCountStrippedShortName(IMetadataTypeInfo type);
    [ExtensionAttribute]
public static string TypeParametersCountStrippedFullName(IMetadataTypeInfo type);
    [ExtensionAttribute]
public static string ShortNameWithTypeParameters(IMetadataTypeInfo type);
    [ExtensionAttribute]
public static IMetadataGenericArgument[] GetTypeOwnGenericArguments(IMetadataTypeInfo typeInfo);
    [CompilerGeneratedAttribute]
private static string <ShortNameWithTypeParameters>b__d(IMetadataGenericArgument x);
}
public static class JetBrains.Metadata.Reader.API.MetadataTypeFactory : object {
    public static IMetadataTypeModifier CreateModifier(MetadataModifierKind kind, IMetadataType type);
    [NotNullAttribute]
public static IMetadataClassType CreateClassType(IMetadataTypeInfo typeInfo, IMetadataType[] genericArguments, IMetadataTypeModifier[] typeModifiers, bool pinned);
    [NotNullAttribute]
public static IMetadataArrayType CreateArrayType(IMetadataType elementType, IMetadataTypeModifier[] typeModifiers, bool pinned);
    [NotNullAttribute]
public static IMetadataArrayType CreateArrayType(IMetadataType elementType, UInt32 rank, UInt32[] sizes, Int32[] lBounds, IMetadataTypeModifier[] typeModifiers, bool pinned);
    [NotNullAttribute]
public static IMetadataPointerType CreatePointerType(IMetadataType elementType, IMetadataTypeModifier[] typeModifiers, bool pinned);
    [NotNullAttribute]
public static IMetadataFunctionPointerType CreateFunctionPointerType(MethodSignature methodSignature, IMetadataTypeModifier[] typeModifiers, bool pinned);
    [NotNullAttribute]
public static IMetadataReferenceType CreateReferenceType(IMetadataType elementType, IMetadataTypeModifier[] typeModifiers, bool pinned);
    [NotNullAttribute]
public static IMetadataGenericArgumentReferenceType CreateGenericArgumentReferenceType(IMetadataGenericArgument genericArgument, IMetadataTypeModifier[] typeModifiers, bool pinned);
    [NotNullAttribute]
public static IMetadataClassType CreateUndecodedType();
}
public class JetBrains.Metadata.Reader.API.MetadataTypeReference : ValueType {
    public static MetadataTypeReference Nil;
    [CanBeNullAttribute]
public AssemblyNameInfo AssemblyName;
    [NotNullAttribute]
public string NamespaceName;
    [NotNullAttribute]
public string TypeName;
    public StringDotConcat FullName { get; }
    public MetadataTypeReference(AssemblyNameInfo assemblyName, string namespaceName, string typeName);
    private static MetadataTypeReference();
    public StringDotConcat get_FullName();
}
[ExtensionAttribute]
public static class JetBrains.Metadata.Reader.API.MetadataTypeUtil : object {
    public static int GetTypeSize(IMetadataTypeInfo type);
    [ExtensionAttribute]
public static IMetadataClassType GetBaseType(IMetadataType type);
    [ExtensionAttribute]
public static IMetadataClassType[] GetInterfaces(IMetadataClassType classType);
    public static T SubstituteGenericArguments(T inputType, IMetadataClassType substitutionsProvider);
    public static T SubstituteGenericArguments(T inputType, MethodInstantiation substitutionsProvider);
    public static T SubstituteGenericArguments(IMetadataType inputType, IDictionary`2<IMetadataGenericArgument, IMetadataType> substitutions);
    private static bool IsGenericSubstitutionNeeded(IMetadataType type);
    [CanBeNullAttribute]
[ExtensionAttribute]
public static MetadataLoader GetLoader(IMetadataType type);
    [ExtensionAttribute]
public static bool IsMscorlibClassType(IMetadataType type, string fullyQualifiedName);
}
public class JetBrains.Metadata.Reader.API.MethodInstantiation : object {
    [CompilerGeneratedAttribute]
private MethodSpecification <MethodSpecification>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataType[] <GenericArguments>k__BackingField;
    [CompilerGeneratedAttribute]
private static Func`2<IMetadataType, string> CS$<>9__CachedAnonymousMethodDelegate2;
    [CompilerGeneratedAttribute]
private static Func`3<StringBuilder, string, StringBuilder> CS$<>9__CachedAnonymousMethodDelegate3;
    [NotNullAttribute]
public MethodSpecification MethodSpecification { get; private set; }
    [NotNullAttribute]
public IMetadataType[] GenericArguments { get; private set; }
    public MethodInstantiation(MethodSpecification methodSpecification, IMetadataType[] genericArguments);
    public MethodInstantiation(MethodSpecification methodSpecification);
    [CompilerGeneratedAttribute]
public MethodSpecification get_MethodSpecification();
    [CompilerGeneratedAttribute]
private void set_MethodSpecification(MethodSpecification value);
    [CompilerGeneratedAttribute]
public IMetadataType[] get_GenericArguments();
    [CompilerGeneratedAttribute]
private void set_GenericArguments(IMetadataType[] value);
    private static MethodInstantiation FromBlob(IBlob blob, IMetadataAssembly assembly, MethodSpecification methodSpecification, TypeDecodeContext context);
    internal static MethodInstantiation FromSpecification(MethodSpecification methodSpecification);
    internal static MethodInstantiation FromToken(MetadataToken methodSpecToken, IMetadataAssembly assembly, TypeDecodeContext context);
    public sealed virtual bool Equals(MethodInstantiation other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
private static string <ToString>b__0(IMetadataType x);
    [CompilerGeneratedAttribute]
private static StringBuilder <ToString>b__1(StringBuilder x, string y);
}
public class JetBrains.Metadata.Reader.API.MethodSignature : object {
    private bool myHasThis;
    private UInt32 myMethodGenericArgumentsCount;
    private bool myIsVararg;
    private IMetadataType[] myParameterTypes;
    private IMetadataType[] myVarargParameterTypes;
    private IMetadataType myReturnType;
    public bool IsVararg { get; }
    public bool HasThis { get; }
    public UInt32 MethodGenericArgumentsCount { get; }
    public IMetadataType ReturnType { get; }
    public IMetadataType[] ParameterTypes { get; }
    public IMetadataType[] VarargParameterTypes { get; }
    public int ParamCount { get; }
    public MethodSignature(bool isVararg, bool hasThis, UInt32 methodGenericArgumentsCount, IMetadataType returnType, IMetadataType[] parameterTypes, IMetadataType[] varargParameterTypes);
    public bool get_IsVararg();
    public bool get_HasThis();
    public UInt32 get_MethodGenericArgumentsCount();
    public IMetadataType get_ReturnType();
    public IMetadataType[] get_ParameterTypes();
    public IMetadataType[] get_VarargParameterTypes();
    public int get_ParamCount();
    public sealed virtual bool Equals(MethodSignature other);
    private static bool Compare(MethodSignature a, MethodSignature b, bool compareVararg, bool compareReturnType);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public MethodSignature TransformTypes(Func`2<IMetadataType, IMetadataType> transformer);
    public bool CanBeCalledBy(MethodSignature by);
    public bool CompareWithoutReturnType(MethodSignature other);
}
public class JetBrains.Metadata.Reader.API.MethodSpecification : object {
    public static MethodSpecification Null;
    [CompilerGeneratedAttribute]
private IMetadataClassType <OwnerType>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataMethod <Method>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataType[] <VarargParameters>k__BackingField;
    public IMetadataClassType OwnerType { get; private set; }
    public IMetadataMethod Method { get; private set; }
    public IMetadataType[] VarargParameters { get; private set; }
    public MethodSpecification(IMetadataMethod method, IMetadataType[] varargParameters);
    public MethodSpecification(IMetadataMethod method, IMetadataClassType ownerType, IMetadataType[] varargParameters);
    private static MethodSpecification();
    [CompilerGeneratedAttribute]
public IMetadataClassType get_OwnerType();
    [CompilerGeneratedAttribute]
private void set_OwnerType(IMetadataClassType value);
    [CompilerGeneratedAttribute]
public IMetadataMethod get_Method();
    [CompilerGeneratedAttribute]
private void set_Method(IMetadataMethod value);
    [CompilerGeneratedAttribute]
public IMetadataType[] get_VarargParameters();
    [CompilerGeneratedAttribute]
private void set_VarargParameters(IMetadataType[] value);
    public sealed virtual bool Equals(MethodSpecification other);
    public static bool op_Equality(MethodSpecification s1, MethodSpecification s2);
    public static bool op_Inequality(MethodSpecification s1, MethodSpecification s2);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class JetBrains.Metadata.Reader.API.MethodUsageCount : object {
    [CompilerGeneratedAttribute]
private IMetadataMethod <Usage>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Count>k__BackingField;
    [NotNullAttribute]
public IMetadataMethod Usage { get; private set; }
    public int Count { get; private set; }
    public MethodUsageCount(IMetadataMethod usage, int count);
    public MethodUsageCount(IMetadataMethod usage);
    [CompilerGeneratedAttribute]
public IMetadataMethod get_Usage();
    [CompilerGeneratedAttribute]
private void set_Usage(IMetadataMethod value);
    [CompilerGeneratedAttribute]
public int get_Count();
    [CompilerGeneratedAttribute]
private void set_Count(int value);
    public virtual string ToString();
}
[ExtensionAttribute]
public static class JetBrains.Metadata.Reader.API.MethodUsageCountExtensions : object {
    [ExtensionAttribute]
public static IEnumerable`1<int> GetIndices(MethodUsageCount usageCount);
}
[ExtensionAttribute]
public static class JetBrains.Metadata.Reader.API.ModuleReferenceResolveContextEx : object {
    [ExtensionAttribute]
[ConditionalAttribute("JET_MODE_ASSERT")]
public static void AssertIsValid(IModuleReferenceResolveContext resolveContext);
}
internal class JetBrains.Metadata.Reader.API.MonoCurrentRuntimeAssemblyResolver : object {
    private MonoGacAssemblyResolver myGac;
    private AssemblyResolverOnFolders myRuntimeFolderResolver;
    private MonoRuntime myMonoRuntime;
    public sealed virtual void DumpDebugInformation(IndentedTextWriter textWriter);
    public sealed virtual bool IsUnderResolvePaths(FileSystemPath path);
    public sealed virtual IMetadataAccess ResolveAssembly(AssemblyNameInfo name, FileSystemPath& assemblyLocation, IModuleReferenceResolveContext moduleReferenceResolveContext);
    public sealed virtual FileSystemPath TryResolveAssemblyPath(AssemblyNameInfo name);
    private static AssemblyResolverOnFolders CreateAdditionalFoldersResolver(MonoRuntime monoRuntime);
}
public class JetBrains.Metadata.Reader.API.MonoGacAssemblyResolver : object {
    private ILogger Logger;
    private MonoRuntime myMonoRuntime;
    private GacResolvePreferences myPreferences;
    public MonoGacAssemblyResolver(MonoRuntime monoRuntime, GacResolvePreferences preferences);
    public virtual FileSystemPath TryResolveAssemblyPath(AssemblyNameInfo name);
    [NotNullAttribute]
private IList`1<FileSystemPath> GetCandidatesFromGac(AssemblyNameInfo name);
    private FileSystemPath ResolveInGac(AssemblyNameInfo assemblyName);
    public sealed virtual IMetadataAccess ResolveAssembly(AssemblyNameInfo name, FileSystemPath& assemblyLocation, IModuleReferenceResolveContext moduleReferenceResolveContext);
    public sealed virtual bool IsUnderResolvePaths(FileSystemPath path);
    public sealed virtual void DumpDebugInformation(IndentedTextWriter textWriter);
}
[ExtensionAttribute]
public static class JetBrains.Metadata.Reader.API.NuGetFrameworkEx : object {
    public static string UnitySubset;
    public static string UnityFull;
    [CanBeNullAttribute]
[ExtensionAttribute]
public static Version TryGetUnitySubsetVersion(NuGetFramework nuGetFramework);
    [CanBeNullAttribute]
[ExtensionAttribute]
public static Version TryGetUnityFullVersion(NuGetFramework nuGetFramework);
    [CanBeNullAttribute]
private static Version TryGetUnityVersion(NuGetFramework nuGetFramework, string unityPrefix);
}
public class JetBrains.Metadata.Reader.API.NullType : SentinelTypeBase {
    public static IMetadataType Instance;
    public string FullName { get; }
    public bool IsResolved { get; }
    private static NullType();
    public virtual string get_FullName();
    public virtual bool get_IsResolved();
    public virtual void Accept(IMetadataTypeVisitor visitor);
}
public class JetBrains.Metadata.Reader.API.PInvokeInfo : object {
    private CorPInvokeMap myFlags;
    private string myImportName;
    private string myModuleName;
    public string ModuleName { get; }
    public string ImportName { get; }
    public CallConvSpec CallConv { get; }
    public CharSetSpec CharSet { get; }
    public BestFitFlag BestFit { get; }
    public ThrowOnUnmappableFlag ThrowOnUnmappable { get; }
    public bool SupportsLastError { get; }
    public bool NoMangle { get; }
    public PInvokeInfo(CorPInvokeMap flags, string moduleName, string importName);
    public PInvokeInfo(BinaryReader reader);
    public void Save(BinaryWriter writer);
    public string get_ModuleName();
    public string get_ImportName();
    public CallConvSpec get_CallConv();
    public CharSetSpec get_CharSet();
    public BestFitFlag get_BestFit();
    public ThrowOnUnmappableFlag get_ThrowOnUnmappable();
    public bool get_SupportsLastError();
    public bool get_NoMangle();
}
public class JetBrains.Metadata.Reader.API.RecursiveMetadataTypeVisitor : object {
    public virtual void VisitUnknownType(IMetadataType unknownType);
    public virtual void VisitArrayType(IMetadataArrayType arrayType);
    public virtual void VisitClassType(IMetadataClassType classType);
    public virtual void VisitPointerType(IMetadataPointerType pointerType);
    public virtual void VisitReferenceType(IMetadataReferenceType referenceType);
    public virtual void VisitGenericArgumentReferenceType(IMetadataGenericArgumentReferenceType genericArgumentReferenceType);
    public virtual void VisitFunctionPointer(IMetadataFunctionPointerType functionPointerType);
}
public enum JetBrains.Metadata.Reader.API.SecurityAction : Enum {
    public int value__;
    public static SecurityAction ActionNil;
    public static SecurityAction Request;
    public static SecurityAction Demand;
    public static SecurityAction Assert;
    public static SecurityAction Deny;
    public static SecurityAction PermitOnly;
    public static SecurityAction LinkDemand;
    public static SecurityAction InheritanceDemand;
    public static SecurityAction RequestMinimum;
    public static SecurityAction RequestOptional;
    public static SecurityAction RequestRefuse;
    public static SecurityAction PrejitGrant;
    public static SecurityAction PrejitDenied;
    public static SecurityAction NonCasDemand;
    public static SecurityAction NonCasLinkDemand;
    public static SecurityAction NonCasInheritance;
}
public abstract class JetBrains.Metadata.Reader.API.SentinelTypeBase : object {
    public string AssemblyQualifiedName { get; }
    public string FullName { get; }
    public string AssemblyQualification { get; }
    public IMetadataTypeModifier[] TypeModifiers { get; }
    public bool Pinned { get; }
    public bool IsResolved { get; }
    public sealed virtual string get_AssemblyQualifiedName();
    public abstract virtual string get_FullName();
    public sealed virtual string get_AssemblyQualification();
    public sealed virtual IMetadataTypeModifier[] get_TypeModifiers();
    public sealed virtual bool get_Pinned();
    public abstract virtual bool get_IsResolved();
    public virtual void Accept(IMetadataTypeVisitor visitor);
    public sealed virtual IMetadataType Transform(IMetadataTypeTransformer transformer);
    public virtual string ToString();
}
public static class JetBrains.Metadata.Reader.API.StandardMemberNames : object {
    public static string PropertyGetterPrefix;
    public static string PropertySetterPrefix;
    public static string EventAdderPrefix;
    public static string EventRemoverPrefix;
    public static string EventRaiserPrefix;
    public static string OperatorPrefix;
    public static string Constructor;
    public static string ClassConstructor;
    public static string ObjectToString;
    public static string ObjectFinalize;
    public static string ObjectGetType;
    public static string ArraySet;
    public static string ArrayGet;
    public static string ArrayAddress;
    public static string ArrayLength;
    public static string ArrayInternalGetReference;
    public static string StringLength;
    public static string StringChars;
    public static string StringConcat;
    public static string IsInterned;
    public static string RuntimeHelpersInitializeArray;
    public static string RuntimeHelpersOffsetToStringData;
    public static string TypeGetTypeFromHandle;
    public static string IEnumerableGetEnumerator;
    public static string IEnumeratorMoveNext;
    public static string IEnumeratorCurrent;
    public static string IEnumerable1GetEnumerator;
    public static string IEnumerator1MoveNext;
    public static string IEnumerator1Current;
    public static string IAsyncStateMachineMoveNext;
    public static string IDisposableDispose;
    public static string IntPtrZero;
    public static string IntPtrToInt64;
    public static string UIntPtrZero;
    public static string MonitorEnter;
    public static string MonitorExit;
    public static string CharMinValue;
    public static string CharMaxValue;
    public static string SByteMinValue;
    public static string SByteMaxValue;
    public static string ByteMinValue;
    public static string ByteMaxValue;
    public static string Int16MinValue;
    public static string Int16MaxValue;
    public static string UInt16MinValue;
    public static string UInt16MaxValue;
    public static string Int32MinValue;
    public static string Int32MaxValue;
    public static string UInt32MinValue;
    public static string UInt32MaxValue;
    public static string Int64MinValue;
    public static string Int64MaxValue;
    public static string UInt64MinValue;
    public static string UInt64MaxValue;
    public static string SingleMinValue;
    public static string SingleMaxValue;
    public static string DoubleMinValue;
    public static string DoubleMaxValue;
    public static string SingleEpsilon;
    public static string DoubleEpsilon;
    public static string ActivatorCreateInstance;
    public static string ArrayCreateInstance;
    public static string DebuggerBreak;
    public static string HashtableAdd;
    public static string DictionaryAdd;
    public static string DictionaryTryGetValue;
    public static string DelegateCombine;
    public static string DelegateRemove;
    public static string DelegateInvoke;
    public static string NullableHasValue;
    public static string NullableGetValueOrDefault;
    public static string DefaultIndexerName;
    public static string MathPi;
    public static string MathE;
    public static string MethodCodeTypeOfMethodImplAttribute;
    public static string AssemblyLoadFrom;
    public static string AssemblyLoad;
}
public static class JetBrains.Metadata.Reader.API.StandardOperatorNames : object {
    public static string Decrement;
    public static string Increment;
    public static string UnaryNegation;
    public static string UnaryPlus;
    public static string LogicalNot;
    public static string True;
    public static string False;
    public static string AddressOf;
    public static string OnesComplement;
    public static string PointerDereference;
    public static string Addition;
    public static string Subtraction;
    public static string Multiply;
    public static string Division;
    public static string Modulus;
    public static string ExclusiveOr;
    public static string BitwiseAnd;
    public static string BitwiseOr;
    public static string LogicalAnd;
    public static string LogicalOr;
    public static string Assign;
    public static string LeftShift;
    public static string RightShift;
    public static string SignedRightShift;
    public static string UnsignedRightShift;
    public static string Equality;
    public static string GreaterThan;
    public static string LessThan;
    public static string Inequality;
    public static string GreaterThanOrEqual;
    public static string LessThanOrEqual;
    public static string UnsignedRightShiftAssignment;
    public static string MemberSelection;
    public static string RightShiftAssignment;
    public static string MultiplicationAssignment;
    public static string PointerToMemberSelection;
    public static string SubtractionAssignment;
    public static string ExclusiveOrAssignment;
    public static string LeftShiftAssignment;
    public static string ModulusAssignment;
    public static string AdditionAssignment;
    public static string BitwiseAndAssignment;
    public static string BitwiseOrAssignment;
    public static string Comma;
    public static string DivisionAssignment;
    public static string Implicit;
    public static string Explicit;
}
public static class JetBrains.Metadata.Reader.API.StandardTypeNames : object {
    public static string ModuleType;
    public static string Array;
    public static string Boolean;
    public static string Char;
    public static string IntPtr;
    public static string SByte;
    public static string Int16;
    public static string Int32;
    public static string Int64;
    public static string Object;
    public static string Single;
    public static string Double;
    public static string String;
    public static string UIntPtr;
    public static string Byte;
    public static string UInt16;
    public static string UInt32;
    public static string UInt64;
    public static string Void;
    public static string Decimal;
    public static string TypedReference;
    public static string Type;
    public static string ValueType;
    public static string Enum;
    public static string Delegate;
    public static string MulticastDelegate;
    public static string Exception;
    public static string Activator;
    public static string Nullable;
    public static string FlagsAttribute;
    public static string NonSerializedAttribute;
    public static string SerializableAttribute;
    public static string IDisposable;
    public static string ParamArrayAttribute;
    public static string DateTime;
    public static string TimeSpan;
    public static string Math;
    public static string RuntimeMethodHandle;
    public static string RuntimeTypeHandle;
    public static string RuntimeFieldHandle;
    public static string RuntimeArgumentHandle;
    public static string Monitor;
    public static string DynamicAttribute;
    public static string FixedBufferAttribute;
    public static string DecimalConstantAttribute;
    public static string IsVolatile;
    public static string CompilerGeneratedAttribute;
    public static string IndexerNameAttribute;
    public static string MethodImplAttribute;
    public static string MethodImplOptions;
    public static string MethodCodeType;
    public static string SpecialNameAttribute;
    public static string ExtensionAttribute;
    public static string RuntimeHelpers;
    public static string ReferenceAssemblyAttribute;
    public static string AsyncStateMachineAttribute;
    public static string IAsyncStateMachine;
    public static string IteratorStateMachineAttribute;
    public static string TypeForwardedToAttribute;
    public static string UnmanagedType;
    public static string VarEnum;
    public static string InAttribute;
    public static string OutAttribute;
    public static string OptionalAttribute;
    public static string FieldOffsetAttribute;
    public static string DllImportAttribute;
    public static string MarshalAsAttribute;
    public static string CallingConvention;
    public static string ComImportAttribute;
    public static string StructLayoutAttribute;
    public static string LayoutKind;
    public static string CharSet;
    public static string TargetFrameworkAttribute;
    public static string Assembly;
    public static string AssemlyVersionAttribute;
    public static string DefaultMemberAttribute;
    public static string ConfigAssemblyHashAlgorithm;
    public static string PermissionSetAttribute;
    public static string SecurityAction;
    public static string Debugger;
    public static string DebuggerStepThroughAttribute;
    public static string IEnumerable;
    public static string IEnumerator;
    public static string Hashtable;
    public static string ICollection;
    public static string IList;
    public static string ICollection1;
    public static string Dictionary;
    public static string IList1;
    public static string IEnumerable1;
    public static string IEnumerator1;
    public static string ISet1;
    public static string IReadOnlyCollection1;
    public static string IReadOnlyList1;
    public static string HashSet1;
    public static string List1;
    public static string Queue1;
    public static string Stack1;
    public static string ICloneable;
}
public class JetBrains.Metadata.Reader.API.TargetFrameworkId : object {
    private static string netCoreRcVersionString;
    private static HashSet`1<TargetFrameworkId> ourAllKnownIds;
    private static Dictionary`2<string, TargetFrameworkId> ourIntern;
    private static ReaderWriterLockSlim ourReaderWriterLock;
    private static Dictionary`2<string, NuGetFramework> TargetFrameworkMapping;
    public static TargetFrameworkId Default;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetFramework <NuGetFramework>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowedToReferenceDefaultTargetFramework>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UniqueString>k__BackingField;
    public string Name { get; private set; }
    public Version Version { get; private set; }
    [NotNullAttribute]
public NuGetFramework NuGetFramework { get; private set; }
    public bool AllowedToReferenceDefaultTargetFramework { get; private set; }
    public static IEnumerable`1<TargetFrameworkId> AllKnownIds { get; }
    public string PresentableString { get; }
    public string UniqueString { get; private set; }
    public bool IsDNX { get; }
    public bool IsDNXCore { get; }
    public bool IsNetFramework { get; }
    public bool IsNetPlatform { get; }
    public bool IsNetCore { get; }
    public bool IsNetCoreApp { get; }
    public bool IsNetStandard { get; }
    public bool IsUAP { get; }
    public bool IsWindowsPhone { get; }
    public bool IsWindowsStoreApp { get; }
    public bool IsSilverlight { get; }
    public TargetFrameworkId(NuGetFramework nugetFramework, bool allowedToReferenceDefaultTargetFramework);
    private TargetFrameworkId(string name, Version version, NuGetFramework nugetFramework, bool allowedToReferenceDefaultTargetFramework);
    private static TargetFrameworkId();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public Version get_Version();
    [CompilerGeneratedAttribute]
private void set_Version(Version value);
    [CompilerGeneratedAttribute]
public NuGetFramework get_NuGetFramework();
    [CompilerGeneratedAttribute]
private void set_NuGetFramework(NuGetFramework value);
    [CompilerGeneratedAttribute]
public bool get_AllowedToReferenceDefaultTargetFramework();
    [CompilerGeneratedAttribute]
private void set_AllowedToReferenceDefaultTargetFramework(bool value);
    public static IEnumerable`1<TargetFrameworkId> get_AllKnownIds();
    private static Pair`2<string, Version> GetNameAndVersion(string raw);
    public static TargetFrameworkId Create(string name, Nullable`1<bool> allowedToReferenceDefaultTargetFramework);
    public sealed virtual int CompareTo(TargetFrameworkId other);
    public virtual string ToString();
    public string get_PresentableString();
    [CompilerGeneratedAttribute]
public string get_UniqueString();
    [CompilerGeneratedAttribute]
private void set_UniqueString(string value);
    private string CalculateUniqueString();
    [CanBeNullAttribute]
public string TryGetShortIdentifier();
    private bool Equals(TargetFrameworkId other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public bool get_IsDNX();
    public bool get_IsDNXCore();
    public bool get_IsNetFramework();
    public bool get_IsNetPlatform();
    public bool get_IsNetCore();
    public bool get_IsNetCoreApp();
    public bool get_IsNetStandard();
    public bool get_IsUAP();
    public bool get_IsWindowsPhone();
    public bool get_IsWindowsStoreApp();
    public bool get_IsSilverlight();
    public static bool IsDnxName(string name);
    public static bool IsDnxCoreName(string name);
    public static bool IsNetPlatformName(string name);
    public static bool IsNetFrameworkName(string name);
    public static bool IsNetCoreAppName(string name);
    public static bool IsNetCoreName(string name);
    public static bool IsNetStandardName(string name);
    public static bool IsUAPName(string name);
    public static bool IsWindowsPhoneName(string name);
    public static bool IsSilverlightName(string name);
    public static bool IsWindowsStoreAppName(string name);
    public static TargetFrameworkId Read(BinaryReader reader);
    public void Write(BinaryWriter writer);
}
[ExtensionAttribute]
public static class JetBrains.Metadata.Reader.API.TargetFrameworkIdEx : object {
    [CompilerGeneratedAttribute]
private static Func`3<TargetFrameworkId, TargetFrameworkId, Nullable`1<int>> CS$<>9__CachedAnonymousMethodDelegate8;
    [CompilerGeneratedAttribute]
private static Func`2<string, TargetFrameworkId> CS$<>9__CachedAnonymousMethodDelegatec;
    [CompilerGeneratedAttribute]
private static Func`2<TargetFrameworkId, string> CS$<>9__CachedAnonymousMethodDelegatee;
    [ContractAnnotationAttribute("null => true")]
[ExtensionAttribute]
public static bool IsNullOrDefault(TargetFrameworkId thIs);
    [ExtensionAttribute]
public static bool IsReferenceAllowed(TargetFrameworkId fromTargetFrameworkId, TargetFrameworkId referenceTargetFrameworkId);
    [CanBeNullAttribute]
[ExtensionAttribute]
public static TargetFrameworkId SelectTargetFrameworkIdToReference(TargetFrameworkId fromTargetFrameworkId, IEnumerable`1<TargetFrameworkId> candidates);
    public static IReadOnlyCollection`1<TargetFrameworkId> GetTargetFrameworkIdsFromProjectProperties(Func`2<string, string> getPropertyValue, Func`1<IReadOnlyCollection`1<TargetFrameworkId>> getDefaultValue);
    [CanBeNullAttribute]
public static TargetFrameworkId TryGetSingleTargetFrameworkIdFromProjectProperties(Func`2<string, string> getPropertyValue);
    [NotNullAttribute]
[ExtensionAttribute]
[ObsoleteAttribute("Temporary. Will be removed along with PlatformID")]
public static PlatformID ToPlatformId(TargetFrameworkId targetFrameworkId);
    [NotNullAttribute]
[ExtensionAttribute]
public static TargetFrameworkId ToTargetFrameworkId(PlatformID platformId);
    [ExtensionAttribute]
[NotNullAttribute]
public static IReadOnlyCollection`1<TargetFrameworkId> ToTargetFrameworkIds(PlatformID platformId);
    [ExtensionAttribute]
public static DotNetFrameworkDescriptor ToNugetFrameworkDescriptor(TargetFrameworkId id);
    [ExtensionAttribute]
public static string GetShortFolderName(TargetFrameworkId id);
    [ExtensionAttribute]
public static void Dump(IEnumerable`1<TargetFrameworkId> ids, TextWriter writer);
    [CompilerGeneratedAttribute]
private static Nullable`1<int> <SelectTargetFrameworkIdToReference>b__7(TargetFrameworkId id1, TargetFrameworkId id2);
    [CompilerGeneratedAttribute]
private static TargetFrameworkId <GetTargetFrameworkIdsFromProjectProperties>b__b(string slice);
    [CompilerGeneratedAttribute]
private static string <Dump>b__d(TargetFrameworkId id);
}
public class JetBrains.Metadata.Reader.API.TypeDecodeContext : object {
    private IMetadataGenericArgument[] myTypeArguments;
    private IMetadataGenericArgument[] myMethodArguments;
    public IMetadataGenericArgument[] TypeArguments { get; }
    public IMetadataGenericArgument[] MethodArguments { get; }
    public TypeDecodeContext(IMetadataGenericArgument[] typeArguments);
    public TypeDecodeContext(IMetadataGenericArgument[] typeArguments, IMetadataGenericArgument[] methodArguments);
    public IMetadataGenericArgument[] get_TypeArguments();
    public IMetadataGenericArgument[] get_MethodArguments();
    public static TypeDecodeContext CreateContextFromType(IMetadataTypeInfo type);
    public static TypeDecodeContext CreateContextFromMethod(IMetadataMethod method);
}
public class JetBrains.Metadata.Reader.API.TypeNameAndTypeParameterNumber : ValueType {
    public string TypeName;
    public int TypeParametersNumber;
    public TypeNameAndTypeParameterNumber(string typeName, int typeParametersNumber);
    public bool Equals(TypeNameAndTypeParameterNumber other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class JetBrains.Metadata.Reader.API.UniversalModuleReferenceContext : ConcurrentUserDataHolder {
    [NotNullAttribute]
public static UniversalModuleReferenceContext Instance;
    public string UniqueName { get; }
    public AssemblyNameAndLocation Originator { get; }
    public TargetFrameworkId TargetFramework { get; }
    private static UniversalModuleReferenceContext();
    public FileSystemPath GetResolveResult(AssemblyReferenceWithSource assemblyReferenceWithSource);
    public void SetResolveResult(AssemblyReferenceWithSource assemblyReferenceWithSource, FileSystemPath resolveResult);
    public sealed virtual string get_UniqueName();
    public sealed virtual bool IsValid();
    public sealed virtual AssemblyNameAndLocation get_Originator();
    public sealed virtual TargetFrameworkId get_TargetFramework();
    public sealed virtual void Write(BinaryWriter writer);
    public virtual string ToString();
}
public static class JetBrains.Metadata.Reader.Impl.BuilderFactory : object {
    public static ITypeBuilder`2<IMetadataType, MethodSignature> CreateTypeBuilder(IMetadataAssembly assembly);
    public static IMethodSignatureBuilder`2<IMetadataType, MethodSignature> CreateMethodSignatureBuilder(IMetadataAssembly assembly, int typeGenericArgumentsCount);
}
[LocalizableAttribute("False")]
public class JetBrains.Metadata.Reader.Impl.ClrTypeName : ClrTypeNameBase {
    private string myFullName;
    private String[] myNamespaces;
    private TypeNameAndTypeParameterNumber[] myTypes;
    public string ShortName { get; }
    public int TypeParametersCount { get; }
    public string FullName { get; }
    public IEnumerable`1<string> NamespaceNames { get; }
    public IEnumerable`1<TypeNameAndTypeParameterNumber> TypeNames { get; }
    public ClrTypeName(string fullName, Func`2<string, string> intern, IList`1<int> typeParameterNumberFromReflection);
    public ClrTypeName(string fullName, IList`1<int> typeParameterNumberFromReflection);
    public static TypeNameAndTypeParameterNumber[] ParseTypeName(Func`2<string, string> intern, string typeNameString, IList`1<int> typeParameterNumberFromReflection, IMetadataTypeInfo typeHint);
    private static String[] GetTypes(string typeNameString, IMetadataTypeInfo typeHint, int count);
    public static TypeNameAndTypeParameterNumber ParseSingleTypeName(Func`2<string, string> intern, string typeNameString, int typeParameterNumberFromReflection);
    public virtual IClrTypeName GetPersistent();
    public virtual string get_ShortName();
    public virtual int get_TypeParametersCount();
    public virtual string get_FullName();
    public virtual IEnumerable`1<string> get_NamespaceNames();
    public virtual IEnumerable`1<TypeNameAndTypeParameterNumber> get_TypeNames();
    public virtual int GetPartsCount();
    protected virtual bool CompareParts(IClrTypeName name);
    public virtual IClrTypeNamePartIterator GetPartIterator();
    private ClrTypePartArrayIterator GetPartIteratorInternal();
    public virtual string GetFullNameFast();
}
public abstract class JetBrains.Metadata.Reader.Impl.ClrTypeNameBase : object {
    public static string UNRESOLVED_PRESENTATION;
    public string ShortName { get; }
    public string FullName { get; }
    public IEnumerable`1<string> NamespaceNames { get; }
    public IEnumerable`1<TypeNameAndTypeParameterNumber> TypeNames { get; }
    public int TypeParametersCount { get; }
    public abstract virtual string get_ShortName();
    public abstract virtual string get_FullName();
    public abstract virtual IEnumerable`1<string> get_NamespaceNames();
    public abstract virtual IEnumerable`1<TypeNameAndTypeParameterNumber> get_TypeNames();
    public abstract virtual int get_TypeParametersCount();
    public sealed virtual bool Equals(object obj);
    protected virtual bool CompareParts(IClrTypeName name);
    public sealed virtual int GetHashCode();
    public virtual string ToString();
    [NotNullAttribute]
public virtual IClrTypeName GetPersistent();
    public abstract virtual int GetPartsCount();
    public abstract virtual IClrTypeNamePartIterator GetPartIterator();
    public abstract virtual string GetFullNameFast();
}
public class JetBrains.Metadata.Reader.Impl.ClrTypePartArrayIterator : ValueType {
    private TypeNameAndTypeParameterNumber[] myTypes;
    private String[] myNamespaces;
    private int myTypeIndex;
    private int myNamespaceIndex;
    public ClrTypePartArrayIterator(TypeNameAndTypeParameterNumber[] types, String[] namespaces);
    public sealed virtual bool GetNextPart(TypeNameAndTypeParameterNumber& info);
}
public class JetBrains.Metadata.Reader.Impl.CombiningAssemblyResolver : object {
    private IAssemblyResolver[] myResolvers;
    [CompilerGeneratedAttribute]
private static Func`2<IAssemblyResolver, string> CS$<>9__CachedAnonymousMethodDelegate1;
    public CombiningAssemblyResolver(IAssemblyResolver[] resolvers);
    private sealed virtual override IMetadataAccess JetBrains.Metadata.Reader.API.IAssemblyResolver.ResolveAssembly(AssemblyNameInfo name, FileSystemPath& assemblyLocation, IModuleReferenceResolveContext moduleReferenceResolveContext);
    public sealed virtual void DumpDebugInformation(IndentedTextWriter textWriter);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
private static string <ToString>b__0(IAssemblyResolver x);
}
internal class JetBrains.Metadata.Reader.Impl.CompilerSpecificAttribute : object {
    private string myAttributeType;
    private MetadataAttributeValue[] myPositionalArguments;
    private Pair`2[] myNamedArguments;
    public string AttributeType { get; }
    public MetadataAttributeValue[] PositionalArguments { get; }
    public Pair`2[] NamedArguments { get; }
    public CompilerSpecificAttribute(string attributeType, MetadataAttributeValue[] positionalArguments, Pair`2[] namedArguments);
    public sealed virtual string get_AttributeType();
    public sealed virtual MetadataAttributeValue[] get_PositionalArguments();
    public sealed virtual Pair`2[] get_NamedArguments();
}
internal class JetBrains.Metadata.Reader.Impl.CustomAttributeBlobDecoder : object {
    private IMetadataAssembly myAssembly;
    private IMetadataTypeInfo myAttributeType;
    private IMetadataParameter[] myConstructorFormalParameters;
    public CustomAttributeBlobDecoder(IMetadataAssembly assembly, IMetadataTypeInfo attributeType, IMetadataParameter[] constructorFormalParameters);
    public DecodeResult ReadBlob(IBlob blob);
    public NamedArgInitializationData ReadNamedArg(IBinaryReader reader, UInt32 nArg);
    private IMetadataType ReadFieldOrPropType(IBinaryReader reader);
    private MetadataAttributeValue ReadFixedArg(IBinaryReader reader, IMetadataType type);
    private MetadataAttributeValue ReadArray(IBinaryReader blob, IMetadataArrayType arrayType);
    private static IMetadataProperty GetProperty(IMetadataTypeInfo type, string name);
    private static IMetadataField GetField(IMetadataTypeInfo type, string name);
    private MetadataAttributeValue ReadScalarValue(IMetadataType type, IBinaryReader reader);
    private object ReadScalarValueRaw(ElementType elementType, IBinaryReader blob);
}
public class JetBrains.Metadata.Reader.Impl.CustomDebugInformation.AsyncMethodSteppingInformationData : object {
    [CompilerGeneratedAttribute]
private int <CatchHandlerOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private Int32[] <YieldOffsets>k__BackingField;
    [CompilerGeneratedAttribute]
private Int32[] <ResumeOffsets>k__BackingField;
    [CompilerGeneratedAttribute]
private MetadataToken[] <ResumeMethods>k__BackingField;
    public int CatchHandlerOffset { get; private set; }
    public Int32[] YieldOffsets { get; private set; }
    public Int32[] ResumeOffsets { get; private set; }
    public MetadataToken[] ResumeMethods { get; private set; }
    internal AsyncMethodSteppingInformationData(int catchHandlerOffset, Int32[] yieldOffsets, Int32[] resumeOffsets, MetadataToken[] resumeMethods);
    [CompilerGeneratedAttribute]
public int get_CatchHandlerOffset();
    [CompilerGeneratedAttribute]
private void set_CatchHandlerOffset(int value);
    [CompilerGeneratedAttribute]
public Int32[] get_YieldOffsets();
    [CompilerGeneratedAttribute]
private void set_YieldOffsets(Int32[] value);
    [CompilerGeneratedAttribute]
public Int32[] get_ResumeOffsets();
    [CompilerGeneratedAttribute]
private void set_ResumeOffsets(Int32[] value);
    [CompilerGeneratedAttribute]
public MetadataToken[] get_ResumeMethods();
    [CompilerGeneratedAttribute]
private void set_ResumeMethods(MetadataToken[] value);
    public sealed virtual string Present();
}
public class JetBrains.Metadata.Reader.Impl.CustomDebugInformation.ClosureDebugInfo : ValueType {
    public int SyntaxOffset;
    public DebugId ClosureId;
    internal ClosureDebugInfo(int syntaxOffset, DebugId closureId);
    public virtual string ToString();
}
public class JetBrains.Metadata.Reader.Impl.CustomDebugInformation.DebugId : ValueType {
    internal static int UndefinedOrdinal;
    public int Ordinal;
    public int Generation;
    internal DebugId(int ordinal, int generation);
    public virtual string ToString();
}
public class JetBrains.Metadata.Reader.Impl.CustomDebugInformation.DefaultNamespaceData : object {
    [CompilerGeneratedAttribute]
private string <DefaultNamespace>k__BackingField;
    public string DefaultNamespace { get; private set; }
    internal DefaultNamespaceData(string defaultNamespace);
    [CompilerGeneratedAttribute]
public string get_DefaultNamespace();
    [CompilerGeneratedAttribute]
private void set_DefaultNamespace(string value);
    public sealed virtual string Present();
}
public class JetBrains.Metadata.Reader.Impl.CustomDebugInformation.DynamicLocalVariablesData : object {
    [CompilerGeneratedAttribute]
private Boolean[] <DynamicFlags>k__BackingField;
    public Boolean[] DynamicFlags { get; private set; }
    internal DynamicLocalVariablesData(Boolean[] dynamicFlags);
    [CompilerGeneratedAttribute]
public Boolean[] get_DynamicFlags();
    [CompilerGeneratedAttribute]
private void set_DynamicFlags(Boolean[] value);
    public sealed virtual string Present();
}
public class JetBrains.Metadata.Reader.Impl.CustomDebugInformation.EditAndContinueLambdaAndClosureMapData : object {
    [CompilerGeneratedAttribute]
private int <MethodOrdinal>k__BackingField;
    [CompilerGeneratedAttribute]
private ClosureDebugInfo[] <Closures>k__BackingField;
    [CompilerGeneratedAttribute]
private LambdaDebugInfo[] <Lambdas>k__BackingField;
    public int MethodOrdinal { get; private set; }
    public ClosureDebugInfo[] Closures { get; private set; }
    public LambdaDebugInfo[] Lambdas { get; private set; }
    internal EditAndContinueLambdaAndClosureMapData(int methodOrdinal, ClosureDebugInfo[] closures, LambdaDebugInfo[] lambdas);
    [CompilerGeneratedAttribute]
public int get_MethodOrdinal();
    [CompilerGeneratedAttribute]
private void set_MethodOrdinal(int value);
    [CompilerGeneratedAttribute]
public ClosureDebugInfo[] get_Closures();
    [CompilerGeneratedAttribute]
private void set_Closures(ClosureDebugInfo[] value);
    [CompilerGeneratedAttribute]
public LambdaDebugInfo[] get_Lambdas();
    [CompilerGeneratedAttribute]
private void set_Lambdas(LambdaDebugInfo[] value);
    public sealed virtual string Present();
}
public class JetBrains.Metadata.Reader.Impl.CustomDebugInformation.EditAndContinueLocalSlotMapData : object {
    [CompilerGeneratedAttribute]
private LocalSlotDebugInfo[] <LocalSlotDebugInfos>k__BackingField;
    public LocalSlotDebugInfo[] LocalSlotDebugInfos { get; private set; }
    internal EditAndContinueLocalSlotMapData(LocalSlotDebugInfo[] localSlotDebugInfos);
    [CompilerGeneratedAttribute]
public LocalSlotDebugInfo[] get_LocalSlotDebugInfos();
    [CompilerGeneratedAttribute]
private void set_LocalSlotDebugInfos(LocalSlotDebugInfo[] value);
    public sealed virtual string Present();
}
public class JetBrains.Metadata.Reader.Impl.CustomDebugInformation.EmbeddedSourceData : object {
    [CompilerGeneratedAttribute]
private string <EmbeddedSource>k__BackingField;
    public string EmbeddedSource { get; private set; }
    internal EmbeddedSourceData(string embeddedSource);
    [CompilerGeneratedAttribute]
public string get_EmbeddedSource();
    [CompilerGeneratedAttribute]
private void set_EmbeddedSource(string value);
    public sealed virtual string Present();
}
public interface JetBrains.Metadata.Reader.Impl.CustomDebugInformation.ICustomDebugInformationData {
    public abstract virtual string Present();
}
public class JetBrains.Metadata.Reader.Impl.CustomDebugInformation.LambdaDebugInfo : ValueType {
    public static int StaticClosureOrdinal;
    public static int ThisOnlyClosureOrdinal;
    public static int MinClosureOrdinal;
    public int SyntaxOffset;
    public int ClosureOrdinal;
    public DebugId LambdaId;
    internal LambdaDebugInfo(int syntaxOffset, DebugId lambdaId, int closureOrdinal);
    public virtual string ToString();
}
public class JetBrains.Metadata.Reader.Impl.CustomDebugInformation.LocalDebugId : ValueType {
    public int SyntaxOffset;
    public int Ordinal;
    internal LocalDebugId(int syntaxOffset, int ordinal);
    public virtual string ToString();
}
public class JetBrains.Metadata.Reader.Impl.CustomDebugInformation.LocalSlotDebugInfo : ValueType {
    public SynthesizedLocalKind SynthesizedKind;
    public LocalDebugId Id;
    internal LocalSlotDebugInfo(SynthesizedLocalKind synthesizedKind, LocalDebugId id);
    public virtual string ToString();
}
public class JetBrains.Metadata.Reader.Impl.CustomDebugInformation.SourceLinkData : object {
    [CompilerGeneratedAttribute]
private string <SourceLink>k__BackingField;
    public string SourceLink { get; private set; }
    internal SourceLinkData(string sourceLink);
    [CompilerGeneratedAttribute]
public string get_SourceLink();
    [CompilerGeneratedAttribute]
private void set_SourceLink(string value);
    public sealed virtual string Present();
}
public class JetBrains.Metadata.Reader.Impl.CustomDebugInformation.StateMachineHoistedLocalScope : ValueType {
    public int StartOffset;
    public int Length;
    public int EndOffset { get; }
    public bool IsDefault { get; }
    internal StateMachineHoistedLocalScope(int startOffset, int length);
    public int get_EndOffset();
    public bool get_IsDefault();
}
public class JetBrains.Metadata.Reader.Impl.CustomDebugInformation.StateMachineHoistedLocalScopesData : object {
    [CompilerGeneratedAttribute]
private StateMachineHoistedLocalScope[] <Scopes>k__BackingField;
    public StateMachineHoistedLocalScope[] Scopes { get; private set; }
    internal StateMachineHoistedLocalScopesData(StateMachineHoistedLocalScope[] scopes);
    [CompilerGeneratedAttribute]
public StateMachineHoistedLocalScope[] get_Scopes();
    [CompilerGeneratedAttribute]
private void set_Scopes(StateMachineHoistedLocalScope[] value);
    public sealed virtual string Present();
}
public enum JetBrains.Metadata.Reader.Impl.CustomDebugInformation.SynthesizedLocalKind : Enum {
    public int value__;
    public static SynthesizedLocalKind FrameCache;
    public static SynthesizedLocalKind PatternMatchingTemp;
    public static SynthesizedLocalKind OptimizerTemp;
    public static SynthesizedLocalKind LoweringTemp;
    public static SynthesizedLocalKind EmitterTemp;
    public static SynthesizedLocalKind UserDefined;
    public static SynthesizedLocalKind ConditionalBranchDiscriminator;
    public static SynthesizedLocalKind LockTaken;
    public static SynthesizedLocalKind Lock;
    public static SynthesizedLocalKind Using;
    public static SynthesizedLocalKind ForEachEnumerator;
    public static SynthesizedLocalKind ForEachArray;
    public static SynthesizedLocalKind ForEachArrayLimit;
    public static SynthesizedLocalKind ForEachArrayIndex;
    public static SynthesizedLocalKind FixedString;
    public static SynthesizedLocalKind With;
    public static SynthesizedLocalKind ForLimit;
    public static SynthesizedLocalKind ForStep;
    public static SynthesizedLocalKind ForInitialValue;
    public static SynthesizedLocalKind ForDirection;
    public static SynthesizedLocalKind SelectCaseValue;
    public static SynthesizedLocalKind OnErrorActiveHandler;
    public static SynthesizedLocalKind OnErrorResumeTarget;
    public static SynthesizedLocalKind OnErrorCurrentStatement;
    public static SynthesizedLocalKind OnErrorCurrentLine;
    public static SynthesizedLocalKind AsyncMethodReturnValue;
    public static SynthesizedLocalKind StateMachineReturnValue;
    public static SynthesizedLocalKind FunctionReturnValue;
    public static SynthesizedLocalKind TryAwaitPendingException;
    public static SynthesizedLocalKind TryAwaitPendingBranch;
    public static SynthesizedLocalKind TryAwaitPendingCatch;
    public static SynthesizedLocalKind TryAwaitPendingCaughtException;
    public static SynthesizedLocalKind ExceptionFilterAwaitHoistedExceptionLocal;
    public static SynthesizedLocalKind StateMachineCachedState;
    public static SynthesizedLocalKind AwaitSpill;
    public static SynthesizedLocalKind AwaitByRefSpill;
    public static SynthesizedLocalKind LambdaDisplayClass;
    public static SynthesizedLocalKind CachedAnonymousMethodDelegate;
    public static SynthesizedLocalKind XmlInExpressionLambda;
    public static SynthesizedLocalKind Awaiter;
    public static SynthesizedLocalKind InstrumentationPayload;
    public static SynthesizedLocalKind MaxValidValueForLocalVariableSerializedToDebugInformation;
    public static SynthesizedLocalKind AwaiterField;
    public static SynthesizedLocalKind DelegateRelaxationReceiver;
}
public class JetBrains.Metadata.Reader.Impl.CustomDebugInformation.TupleElementNamesData : object {
    [CompilerGeneratedAttribute]
private String[] <Names>k__BackingField;
    [ItemCanBeNullAttribute]
public String[] Names { get; private set; }
    internal TupleElementNamesData(String[] names);
    [CompilerGeneratedAttribute]
public String[] get_Names();
    [CompilerGeneratedAttribute]
private void set_Names(String[] value);
    public sealed virtual string Present();
}
public static class JetBrains.Metadata.Reader.Impl.CustomDebugInformationBlobDecoder : object {
    private static byte SyntaxOffsetBaseline;
    [CanBeNullAttribute]
public static ICustomDebugInformationData Decode(MetadataToken parent, Guid kind, IBlob value);
    public static StateMachineHoistedLocalScopesData DecodeStateMachineHoistedLocalScopes(IBlob blob);
    public static string DecodeDefaultNamespace(IBlob blob);
    public static string DecodeEmbeddedSource(IBlob blob);
    public static string DecodeSourceLink(IBlob blob);
    private static string GetUtf8StringWithoutBom(Byte[] bytes);
    public static AsyncMethodSteppingInformationData DecodeAsyncMethodSteppingInformation(IBlob blob);
    public static TupleElementNamesData DecodeTupleElementNames(IBlob blob);
    public static EditAndContinueLocalSlotMapData DecodeEditAndContinueLocalSlotMap(IBlob blob);
    public static EditAndContinueLambdaAndClosureMapData DecodeEditAndContinueLambdaAndClosureMap(IBlob blob);
    public static DynamicLocalVariablesData DecodeDynamicLocalVariables(IBlob blob);
}
public static class JetBrains.Metadata.Reader.Impl.DecimalConstantUtil : object {
    [CompilerGeneratedAttribute]
private static Func`2<MetadataAttributeValue, object> CS$<>9__CachedAnonymousMethodDelegate1;
    private static void WriteIntOrUint(BinaryWriter sw, object o);
    public static IBlob ExtractDecimalConstantBlob(IMetadataEntity owner);
    public static Nullable`1<decimal> ExtractDecimalConstant(IBlob blob);
    [CompilerGeneratedAttribute]
private static object <ExtractDecimalConstantBlob>b__0(MetadataAttributeValue x);
}
public static class JetBrains.Metadata.Reader.Impl.DocumentBlobDecoder : object {
    private static Decoder ourUtf8Decoder;
    public static string DecodeName(int nameBlobOffset, StreamsManager streams);
    public static bool ReadUtf8Char(IBlob blob, Char& c, Int32& bytesUsed);
}
public class JetBrains.Metadata.Reader.Impl.EmbeddedManifestResourceDisposition : object {
    private string myResourceName;
    private FileSystemPath myPath;
    private long myOffset;
    public string ResourceName { get; }
    public EmbeddedManifestResourceDisposition(string resourceName, FileSystemPath path, long offset);
    public sealed virtual string get_ResourceName();
    public sealed virtual Stream CreateResourceReader();
    private bool Equals(EmbeddedManifestResourceDisposition other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class JetBrains.Metadata.Reader.Impl.EmptyClrTypeName : ClrTypeNameBase {
    [NotNullAttribute]
public static IClrTypeName Instance;
    public string ShortName { get; }
    public int TypeParametersCount { get; }
    public string FullName { get; }
    public IEnumerable`1<string> NamespaceNames { get; }
    public IEnumerable`1<TypeNameAndTypeParameterNumber> TypeNames { get; }
    private static EmptyClrTypeName();
    public virtual string get_ShortName();
    public virtual int get_TypeParametersCount();
    public virtual string get_FullName();
    public virtual IEnumerable`1<string> get_NamespaceNames();
    public virtual IEnumerable`1<TypeNameAndTypeParameterNumber> get_TypeNames();
    public virtual string ToString();
    public virtual IClrTypeNamePartIterator GetPartIterator();
    public virtual string GetFullNameFast();
    public virtual int GetPartsCount();
}
public class JetBrains.Metadata.Reader.Impl.EntityPresentations : object {
    private IMetadataAssembly myAssembly;
    public EntityPresentations(IMetadataAssembly assembly);
    public sealed virtual MetadataToken[] GetFieldPresentations(IMetadataField field);
    public sealed virtual MetadataToken[] GetTypePresentations(IMetadataTypeInfo typeInfo);
    public sealed virtual MetadataToken GetTokenFromTypeInfo(IMetadataTypeInfo typeInfo);
    public sealed virtual MetadataToken[] GetMethodPresentations(IMetadataMethod method);
    private IEnumerable`1<MetadataToken> FindTypeSpec(MetadataToken typeToken);
    private MetadataToken FindAssemblyRef(IMetadataAssembly assembly);
}
public class JetBrains.Metadata.Reader.Impl.FailAssemblyResolver : object {
    [CanBeNullAttribute]
private string myExceptionMessagePrefix;
    private JetHashSet`1<AssemblyNameInfo> myHashReportedErrors;
    [NotNullAttribute]
private OnError myOnError;
    public FailAssemblyResolver(OnError onerror, string prefixExceptionMessage);
    public void ReportDistinctError(AssemblyNameInfo name, IModuleReferenceResolveContext ctx);
    private sealed virtual override IMetadataAccess JetBrains.Metadata.Reader.API.IAssemblyResolver.ResolveAssembly(AssemblyNameInfo name, FileSystemPath& assemblyLocation, IModuleReferenceResolveContext ctx);
    public sealed virtual void DumpDebugInformation(IndentedTextWriter textWriter);
}
public static class JetBrains.Metadata.Reader.Impl.FieldSignatureBlobDecoder : object {
    public static TFieldType DecodeFieldSig(IBlob signature, ITypeBuilder`2<TFieldType, TMethodSig> builder);
}
public class JetBrains.Metadata.Reader.Impl.FileManifestResourceDisposition : object {
    private string myResourceName;
    private FileSystemPath myPath;
    public string ResourceName { get; }
    public FileManifestResourceDisposition(string resourceName, FileSystemPath path);
    public sealed virtual string get_ResourceName();
    public sealed virtual Stream CreateResourceReader();
    private bool Equals(FileManifestResourceDisposition other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class JetBrains.Metadata.Reader.Impl.HashingSignatureBuilder : object {
    private Func`2<MetadataToken, Hash> myTypeTokenPresenter;
    public IMethodSignatureBuilder`2<Hash, Hash> MethodSignatureBuilder { get; }
    public HashingSignatureBuilder(Func`2<MetadataToken, Hash> typeTokenPresenter);
    public sealed virtual ITypeBuilder`2<Hash, Hash> GetTypeBuilder(UInt32 methodGenericArgumentsCount);
    public sealed virtual Hash BuildMethodSignature(bool isVararg, bool hasThis, UInt32 genericArgumentsCount, Hash returnType, Hash[] parameterTypes, Hash[] varargParameterTypes);
    public sealed virtual IMethodSignatureBuilder`2<Hash, Hash> get_MethodSignatureBuilder();
    public sealed virtual Hash BuildWellKnownType(ElementType type);
    public sealed virtual Hash BuildPointerType(Hash type);
    public sealed virtual Hash BuildReferenceType(Hash type);
    public sealed virtual Hash BuildClassType(MetadataToken typeDefOrRefOrSpecToken);
    public sealed virtual Hash BuildGenericInst(Hash type, Hash[] args);
    public sealed virtual Hash BuildTypeGenericArgument(UInt32 index);
    public sealed virtual Hash BuildMethodGenericArgument(UInt32 index);
    public sealed virtual Hash BuildFunctionPointer(Hash fnsig);
    public sealed virtual Hash BuildArrayType(Hash elementType, UInt32 rank, UInt32[] sizes, Int32[] lBounds);
    public sealed virtual Hash BuildArrayType(Hash elementType);
    public sealed virtual Hash AddRequiredModifier(Hash type, Hash modifier);
    public sealed virtual Hash AddOptionalModifier(Hash type, Hash modifier);
    public sealed virtual Hash AddPinnedConstraint(Hash type);
    public sealed virtual Hash BuildUndecodedType();
}
public class JetBrains.Metadata.Reader.Impl.ImageBodyReader : object {
    private IMetadataAssembly myAssembly;
    private IlImageBodyAccess myBodyAccess;
    private LifetimeDefinition myLifetimeDefinition;
    private ImageBodyReader(IMetadataAssembly assembly, UnmanagedBlock block);
    public ImageBodyReader(IMetadataAssembly assembly);
    public ImageBodyReader(IMetadataAssembly assembly, Stream stream);
    public ImageBodyReader(IMetadataAssembly assembly, UnmanagedBlob blob);
    public sealed virtual void Dispose();
    public sealed virtual IMethodBody GetMethodBody(IMetadataMethod method);
    public sealed virtual ILMethodBody GetIlMethodBody(IMetadataMethod method);
    public sealed virtual Byte[] GetFieldInitialValue(IMetadataField field);
    private static FileSystemPath CheckedGetAssemblyLocation(IMetadataAssembly assembly);
}
public interface JetBrains.Metadata.Reader.Impl.IMethodSignatureBuilder`2 {
    public abstract virtual ITypeBuilder`2<TType, TSig> GetTypeBuilder(UInt32 methodGenericArgumentsCount);
    public abstract virtual TSig BuildMethodSignature(bool isVararg, bool hasThis, UInt32 genericArgumentsCount, TType returnType, TType[] parameterTypes, TType[] varargParameterTypes);
}
public static class JetBrains.Metadata.Reader.Impl.ImportScopeBlobDecoder : object {
    public static IList`1<Import> DecodeImports(IBlob blob, StreamsManager streams, IDictionary`2<UInt32, object> blobs);
}
public interface JetBrains.Metadata.Reader.Impl.ITypeBuilder`2 {
    public IMethodSignatureBuilder`2<TType, TMethodSig> MethodSignatureBuilder { get; }
    public abstract virtual IMethodSignatureBuilder`2<TType, TMethodSig> get_MethodSignatureBuilder();
    public abstract virtual TType BuildWellKnownType(ElementType type);
    public abstract virtual TType BuildPointerType(TType type);
    public abstract virtual TType BuildReferenceType(TType type);
    public abstract virtual TType BuildClassType(MetadataToken typeDefOrRefOrSpecToken);
    public abstract virtual TType BuildTypeGenericArgument(UInt32 index);
    public abstract virtual TType BuildGenericInst(TType type, TType[] args);
    public abstract virtual TType BuildMethodGenericArgument(UInt32 index);
    public abstract virtual TType BuildFunctionPointer(TMethodSig fnsig);
    public abstract virtual TType BuildArrayType(TType elementType, UInt32 rank, UInt32[] sizes, Int32[] lBounds);
    public abstract virtual TType BuildArrayType(TType elementType);
    public abstract virtual TType AddRequiredModifier(TType type, TType modifier);
    public abstract virtual TType AddOptionalModifier(TType type, TType modifier);
    public abstract virtual TType AddPinnedConstraint(TType type);
    public abstract virtual TType BuildUndecodedType();
}
public static class JetBrains.Metadata.Reader.Impl.LiteralValueDecoder : object {
    internal static object GetLiteralValue(ElementType elementType, IBinaryReader rdr, int len);
    public static object GetLiteralValue(ElementType elementType, IBlob blob);
}
public class JetBrains.Metadata.Reader.Impl.LoadedAssembliesResolver : object {
    private Lifetime myLifetime;
    private Dictionary`2<string, Lazy`1<FileSystemPath>> myMapIdentityToPath;
    [CompilerGeneratedAttribute]
private static Func`2<Assembly, Lazy`1<FileSystemPath>> CS$<>9__CachedAnonymousMethodDelegate8;
    public LoadedAssembliesResolver(Lifetime lifetime, bool isCheckingShortNameOnly);
    private void LazyInitMap();
    private sealed virtual override IMetadataAccess JetBrains.Metadata.Reader.API.IAssemblyResolver.ResolveAssembly(AssemblyNameInfo name, FileSystemPath& assemblyLocation, IModuleReferenceResolveContext moduleReferenceResolveContext);
    public sealed virtual void DumpDebugInformation(IndentedTextWriter textWriter);
    [CompilerGeneratedAttribute]
private void <LazyInitMap>b__0();
    [CompilerGeneratedAttribute]
private void <LazyInitMap>b__1();
    [CompilerGeneratedAttribute]
private static Lazy`1<FileSystemPath> <LazyInitMap>b__2(Assembly ass);
}
public static class JetBrains.Metadata.Reader.Impl.MarshalSpecConverter : object {
    [CanBeNullAttribute]
public static ICompilerSpecificAttribute CreateMarshalAsAttribute(IMarshalSpec marshalSpec, IMetadataAssembly context);
    private static Pair`2[] MakeMarshalAsAttributeNamedArguments(IMarshalSpec marshalSpec, IMetadataAssembly context, IMetadataAssembly corlib);
}
public static class JetBrains.Metadata.Reader.Impl.MemberRefBlobDecoder : object {
    public static MemberRefType GetReferenceType(IBlob memberRefSignature);
    public static TFieldType DecodeFieldSig(IBlob memberRefSignature, ITypeBuilder`2<TFieldType, TMethodSig> builder);
    public static TSig DecodeMethodSig(IBlob memberRefSignature, IMethodSignatureBuilder`2<TType, TSig> builder);
}
internal class JetBrains.Metadata.Reader.Impl.MetadataArrayMethod : object {
    private static MetadataToken TOKEN;
    private IMetadataTypeInfo myDeclaringType;
    private string myName;
    private MetadataArrayMethodReturnValue myReturnValue;
    private MethodSignature mySignature;
    private IMetadataParameter[] myParameters;
    public IMetadataAssembly Assembly { get; }
    public MetadataToken Token { get; }
    public IMetadataCustomAttribute[] CustomAttributes { get; }
    public MetadataTypeReference[] CustomAttributesTypeNames { get; }
    public bool IsResolved { get; }
    public string Name { get; }
    public IMetadataTypeInfo DeclaringType { get; }
    public IMetadataReturnValue ReturnValue { get; }
    public IMetadataParameter[] Parameters { get; }
    public IMetadataGenericArgument[] GenericArguments { get; }
    public IList`1<MethodSpecification> ImplementedMethods { get; }
    public MethodSignature Signature { get; }
    public PInvokeInfo PInvokeInfo { get; }
    public CorMethodImpl MethodImplFlags { get; }
    public IMetadataSecurityRow[] Security { get; }
    public String[] SecurityAttributesTypeName { get; }
    public bool IsPInvokeImpl { get; }
    public bool HasSecurity { get; }
    public CodeType CodeType { get; }
    public UInt32 CodeRva { get; }
    public bool IsForwardRef { get; }
    public bool IsPreserveSig { get; }
    public bool IsInternalCall { get; }
    public bool IsSynchronized { get; }
    public bool NoInlining { get; }
    public bool AggressiveInlining { get; }
    public bool NoOptimization { get; }
    public bool IsAssembly { get; }
    public bool IsPrivate { get; }
    public bool IsPublic { get; }
    public bool IsFamily { get; }
    public bool IsFamilyAndAssembly { get; }
    public bool IsFamilyOrAssembly { get; }
    public bool IsSpecialName { get; }
    public bool IsRuntimeSpecialName { get; }
    public bool IsStatic { get; }
    public bool IsAbstract { get; }
    public bool IsExtern { get; }
    public bool IsVirtual { get; }
    public bool IsFinal { get; }
    public bool IsHideBySig { get; }
    public bool IsNewSlot { get; }
    public bool IsStrict { get; }
    public bool IsVarArg { get; }
    public bool IsUnmanaged { get; }
    public MetadataArrayMethod(IMetadataTypeInfo declaringType, string name, MethodSignature signature);
    private static MetadataArrayMethod();
    public sealed virtual bool Equals(IMetadataEntity other);
    public sealed virtual IMetadataAssembly get_Assembly();
    public sealed virtual MetadataToken get_Token();
    public sealed virtual IMetadataCustomAttribute[] get_CustomAttributes();
    public sealed virtual MetadataTypeReference[] get_CustomAttributesTypeNames();
    public sealed virtual IList`1<IMetadataCustomAttribute> GetCustomAttributes(string attributeClassFullyQualifiedName);
    public sealed virtual bool HasCustomAttribute(string attributeClassFullyQualifiedName);
    public sealed virtual bool get_IsResolved();
    public sealed virtual string get_Name();
    public sealed virtual IMetadataTypeInfo get_DeclaringType();
    public sealed virtual IMetadataReturnValue get_ReturnValue();
    public sealed virtual IMetadataParameter[] get_Parameters();
    public sealed virtual IMetadataGenericArgument[] get_GenericArguments();
    public sealed virtual IList`1<MethodSpecification> get_ImplementedMethods();
    public sealed virtual MethodSignature get_Signature();
    public sealed virtual PInvokeInfo get_PInvokeInfo();
    public sealed virtual CorMethodImpl get_MethodImplFlags();
    public sealed virtual IMetadataSecurityRow[] get_Security();
    public sealed virtual String[] get_SecurityAttributesTypeName();
    public sealed virtual bool get_IsPInvokeImpl();
    public sealed virtual bool get_HasSecurity();
    public sealed virtual CodeType get_CodeType();
    public sealed virtual UInt32 get_CodeRva();
    public sealed virtual bool get_IsForwardRef();
    public sealed virtual bool get_IsPreserveSig();
    public sealed virtual bool get_IsInternalCall();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual bool get_NoInlining();
    public sealed virtual bool get_AggressiveInlining();
    public sealed virtual bool get_NoOptimization();
    public sealed virtual bool get_IsAssembly();
    public sealed virtual bool get_IsPrivate();
    public sealed virtual bool get_IsPublic();
    public sealed virtual bool get_IsFamily();
    public sealed virtual bool get_IsFamilyAndAssembly();
    public sealed virtual bool get_IsFamilyOrAssembly();
    public sealed virtual bool get_IsSpecialName();
    public sealed virtual bool get_IsRuntimeSpecialName();
    public sealed virtual bool get_IsStatic();
    public sealed virtual bool get_IsAbstract();
    public sealed virtual bool get_IsExtern();
    public sealed virtual bool get_IsVirtual();
    public sealed virtual bool get_IsFinal();
    public sealed virtual bool get_IsHideBySig();
    public sealed virtual bool get_IsNewSlot();
    public sealed virtual bool get_IsStrict();
    public sealed virtual bool get_IsVarArg();
    public sealed virtual bool get_IsUnmanaged();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public virtual string ToString();
}
internal class JetBrains.Metadata.Reader.Impl.MetadataArrayMethodParameter : object {
    private static MetadataToken TOKEN;
    private int myIndex;
    private IMetadataMethod myMethod;
    private IMetadataType myType;
    public IMetadataAssembly Assembly { get; }
    public MetadataToken Token { get; }
    public IMetadataCustomAttribute[] CustomAttributes { get; }
    public MetadataTypeReference[] CustomAttributesTypeNames { get; }
    public bool IsResolved { get; }
    public string Name { get; }
    public IMetadataType Type { get; }
    public IMetadataMethod DeclaringMethod { get; }
    public IBlob MarshalSpec { get; }
    public bool IsIn { get; }
    public bool IsOut { get; }
    public bool IsParamArray { get; }
    public bool IsOptional { get; }
    public bool HasMarshalSpec { get; }
    public bool HasDefaultValue { get; }
    public MetadataArrayMethodParameter(IMetadataMethod method, IMetadataType type, int index);
    private static MetadataArrayMethodParameter();
    public sealed virtual bool Equals(IMetadataEntity other);
    public sealed virtual IMetadataAssembly get_Assembly();
    public sealed virtual MetadataToken get_Token();
    public sealed virtual IMetadataCustomAttribute[] get_CustomAttributes();
    public sealed virtual MetadataTypeReference[] get_CustomAttributesTypeNames();
    public sealed virtual IList`1<IMetadataCustomAttribute> GetCustomAttributes(string attributeClassFullyQualifiedName);
    public sealed virtual bool HasCustomAttribute(string attributeClassFullyQualifiedName);
    public sealed virtual bool get_IsResolved();
    public sealed virtual string get_Name();
    public sealed virtual IMetadataType get_Type();
    public sealed virtual IMetadataMethod get_DeclaringMethod();
    public sealed virtual IBlob get_MarshalSpec();
    public sealed virtual bool get_IsIn();
    public sealed virtual bool get_IsOut();
    public sealed virtual bool get_IsParamArray();
    public sealed virtual bool get_IsOptional();
    public sealed virtual bool get_HasMarshalSpec();
    public sealed virtual bool get_HasDefaultValue();
    public sealed virtual object GetDefaultValue();
    public sealed virtual IBlob GetDefaultValueBlob();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public virtual string ToString();
}
internal class JetBrains.Metadata.Reader.Impl.MetadataArrayMethodReturnValue : object {
    private static MetadataToken TOKEN;
    private IMetadataMethod myMethod;
    private IMetadataType myType;
    public IMetadataAssembly Assembly { get; }
    public MetadataToken Token { get; }
    public IMetadataCustomAttribute[] CustomAttributes { get; }
    public MetadataTypeReference[] CustomAttributesTypeNames { get; }
    public bool IsResolved { get; }
    public IMetadataMethod DeclaringMethod { get; }
    public IMetadataType Type { get; }
    public IBlob MarshalSpec { get; }
    public bool HasMarshalSpec { get; }
    public MetadataArrayMethodReturnValue(IMetadataMethod method, IMetadataType type);
    private static MetadataArrayMethodReturnValue();
    public sealed virtual bool Equals(IMetadataEntity other);
    public sealed virtual IMetadataAssembly get_Assembly();
    public sealed virtual MetadataToken get_Token();
    public sealed virtual IMetadataCustomAttribute[] get_CustomAttributes();
    public sealed virtual MetadataTypeReference[] get_CustomAttributesTypeNames();
    public sealed virtual IList`1<IMetadataCustomAttribute> GetCustomAttributes(string attributeClassFullyQualifiedName);
    public sealed virtual bool HasCustomAttribute(string attributeClassFullyQualifiedName);
    public sealed virtual bool get_IsResolved();
    public sealed virtual IMetadataMethod get_DeclaringMethod();
    public sealed virtual IMetadataType get_Type();
    public sealed virtual IBlob get_MarshalSpec();
    public sealed virtual bool get_HasMarshalSpec();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public virtual string ToString();
}
public class JetBrains.Metadata.Reader.Impl.MetadataArrayType : MetadataTypeBase {
    private IMetadataType myElementType;
    private UInt32 myRank;
    private UInt32[] mySizes;
    private Int32[] myLBounds;
    private IMetadataArrayTypeInfo myTypeInfo;
    private string myFullName;
    private bool myIsVector;
    public IMetadataType ElementType { get; }
    public bool IsVector { get; }
    public UInt32 Rank { get; }
    public UInt32[] Sizes { get; }
    public Int32[] LBounds { get; }
    public IMetadataArrayTypeInfo TypeInfo { get; }
    public bool IsResolved { get; }
    public string FullName { get; }
    private string RankText { get; }
    public string AssemblyQualification { get; }
    public MetadataArrayType(IMetadataType elementType, UInt32 rank, UInt32[] sizes, Int32[] lBounds, IMetadataTypeModifier[] typeModifiers, bool pinned);
    public MetadataArrayType(IMetadataType elementType, IMetadataTypeModifier[] typeModifiers, bool pinned);
    public sealed virtual IMetadataType get_ElementType();
    public sealed virtual bool get_IsVector();
    public sealed virtual UInt32 get_Rank();
    public sealed virtual UInt32[] get_Sizes();
    public sealed virtual Int32[] get_LBounds();
    public sealed virtual IMetadataArrayTypeInfo get_TypeInfo();
    public virtual bool get_IsResolved();
    public virtual void Accept(IMetadataTypeVisitor visitor);
    public virtual IMetadataType Transform(IMetadataTypeTransformer transformer);
    public virtual string get_FullName();
    private string get_RankText();
    public static string GetRankText(UInt32 rank, UInt32[] sizes, Int32[] lBounds);
    public virtual string get_AssemblyQualification();
}
internal class JetBrains.Metadata.Reader.Impl.MetadataArrayTypeInfo : object {
    private static MetadataToken TOKEN;
    private IMetadataArrayType myArrayType;
    private IMetadataClassType myBaseType;
    private IMetadataMethod[] myMethods;
    [CompilerGeneratedAttribute]
private static Func`2<IMetadataMethod, MemberInfo> CS$<>9__CachedAnonymousMethodDelegate1;
    [CompilerGeneratedAttribute]
private static Func`2<IMetadataMethod, bool> CS$<>9__CachedAnonymousMethodDelegate7;
    [CompilerGeneratedAttribute]
private static Func`2<IMetadataProperty, bool> CS$<>9__CachedAnonymousMethodDelegate9;
    public IMetadataAssembly Assembly { get; }
    public MetadataToken Token { get; }
    public IMetadataCustomAttribute[] CustomAttributes { get; }
    public MetadataTypeReference[] CustomAttributesTypeNames { get; }
    public bool IsResolved { get; }
    public string FullyQualifiedName { get; }
    public string AssemblyQualifiedName { get; }
    public string NamespaceName { get; }
    public string TypeName { get; }
    public string Name { get; }
    public AssemblyNameInfo DeclaringAssemblyName { get; }
    public IMetadataClassType Base { get; }
    public IMetadataTypeInfo DeclaringType { get; }
    public IMetadataClassType[] Interfaces { get; }
    public IMetadataGenericArgument[] GenericParameters { get; }
    public bool IsSpecialName { get; }
    public bool IsRuntimeSpecialName { get; }
    public bool IsBeforeFieldInit { get; }
    public bool IsAbstract { get; }
    public bool IsSealed { get; }
    public bool IsImported { get; }
    public ClassLayoutType Layout { get; }
    public CharSetSpec InteropStringFormat { get; }
    public bool IsClass { get; }
    public bool IsInterface { get; }
    public bool IsSerializable { get; }
    public bool IsWindowsRuntime { get; }
    public bool IsPublic { get; }
    public bool IsNotPublic { get; }
    public bool IsNested { get; }
    public bool IsNestedPublic { get; }
    public bool IsNestedPrivate { get; }
    public bool IsNestedFamily { get; }
    public bool IsNestedAssembly { get; }
    public bool IsNestedFamilyAndAssembly { get; }
    public bool IsNestedFamilyOrAssembly { get; }
    public int PackingSize { get; }
    public int ClassSize { get; }
    public String[] SecurityAttributesTypeName { get; }
    public bool HasSecurity { get; }
    public IMetadataSecurityRow[] Security { get; }
    public IMetadataArrayType ArrayType { get; }
    public MetadataArrayTypeInfo(IMetadataArrayType arrayType);
    private static MetadataArrayTypeInfo();
    public sealed virtual bool Equals(IMetadataEntity other);
    public sealed virtual IMetadataAssembly get_Assembly();
    public sealed virtual MetadataToken get_Token();
    public sealed virtual IMetadataCustomAttribute[] get_CustomAttributes();
    public sealed virtual MetadataTypeReference[] get_CustomAttributesTypeNames();
    public sealed virtual IList`1<IMetadataCustomAttribute> GetCustomAttributes(string attributeClassFullyQualifiedName);
    public sealed virtual bool HasCustomAttribute(string attributeClassFullyQualifiedName);
    public sealed virtual bool get_IsResolved();
    public sealed virtual string get_FullyQualifiedName();
    public sealed virtual string get_AssemblyQualifiedName();
    public sealed virtual string get_NamespaceName();
    public sealed virtual string get_TypeName();
    public sealed virtual string get_Name();
    public sealed virtual AssemblyNameInfo get_DeclaringAssemblyName();
    public sealed virtual IMetadataClassType get_Base();
    public sealed virtual IMetadataTypeInfo get_DeclaringType();
    public sealed virtual IMetadataClassType[] get_Interfaces();
    public sealed virtual IMetadataGenericArgument[] get_GenericParameters();
    public sealed virtual bool get_IsSpecialName();
    public sealed virtual bool get_IsRuntimeSpecialName();
    public sealed virtual bool get_IsBeforeFieldInit();
    public sealed virtual bool get_IsAbstract();
    public sealed virtual bool get_IsSealed();
    public sealed virtual bool get_IsImported();
    public sealed virtual ClassLayoutType get_Layout();
    public sealed virtual CharSetSpec get_InteropStringFormat();
    public sealed virtual bool get_IsClass();
    public sealed virtual bool get_IsInterface();
    public sealed virtual bool get_IsSerializable();
    public sealed virtual bool get_IsWindowsRuntime();
    public sealed virtual bool get_IsPublic();
    public sealed virtual bool get_IsNotPublic();
    public sealed virtual bool get_IsNested();
    public sealed virtual bool get_IsNestedPublic();
    public sealed virtual bool get_IsNestedPrivate();
    public sealed virtual bool get_IsNestedFamily();
    public sealed virtual bool get_IsNestedAssembly();
    public sealed virtual bool get_IsNestedFamilyAndAssembly();
    public sealed virtual bool get_IsNestedFamilyOrAssembly();
    public sealed virtual int get_PackingSize();
    public sealed virtual int get_ClassSize();
    public sealed virtual IEnumerable`1<MemberInfo> GetMemberInfos();
    public sealed virtual String[] get_SecurityAttributesTypeName();
    public sealed virtual bool get_HasSecurity();
    public sealed virtual IMetadataSecurityRow[] get_Security();
    public sealed virtual IMetadataMethod[] GetMethods();
    public sealed virtual bool HasExtensionMethods();
    public sealed virtual IMetadataField[] GetFields();
    public sealed virtual IMetadataProperty[] GetProperties();
    public sealed virtual IMetadataEvent[] GetEvents();
    public sealed virtual IMetadataTypeInfo[] GetNestedTypes();
    public sealed virtual IMetadataArrayType get_ArrayType();
    [CompilerGeneratedAttribute]
private static MemberInfo <GetMemberInfos>b__0(IMetadataMethod x);
    [CompilerGeneratedAttribute]
private UnresolvedMethod <GetMethods>b__2(Pair`2<string, MethodSignature> x);
    [CompilerGeneratedAttribute]
private MetadataArrayMethod <GetMethods>b__3(Pair`2<string, MethodSignature> x);
    [CompilerGeneratedAttribute]
private static bool <GetMethods>b__4(IMetadataMethod method);
    [CompilerGeneratedAttribute]
private static bool <GetProperties>b__8(IMetadataProperty property);
}
internal class JetBrains.Metadata.Reader.Impl.MetadataAssembly : MetadataEntity {
    [CanBeNullAttribute]
private FileSystemPath myLocation;
    private IMetadataAccess myMetadataAccess;
    private IMetadataAssemblyInfo myAssemblyInfo;
    private Lazy`1<AssemblyNameInfo> myAssemblyName;
    private IMetadataTypeInfo[] myTypes;
    private IMetadataManifestResource[] myManifestResources;
    private MetadataTokenRange myTypesRange;
    private MetadataTokenRange myMethodsRange;
    private IMetadataTypeInfo[] myExportedTypes;
    private IMetadataCustomAttribute[] myModuleAttributes;
    private Dictionary`2<string, AssemblyNameInfo> myForwardedTypes;
    private MetadataLoader myLoader;
    private Dictionary`2<MetadataToken, IMetadataTypeInfo> myTypeInfoCache;
    private Dictionary`2<MetadataToken, MethodSpecification> myMethodCache;
    private Dictionary`2<MetadataToken, IMetadataAssembly> myAssemblyReferences;
    private Dictionary`2<MetadataToken, AssemblyReference> myReferencedAssemblies;
    private Func`2<AssemblyNameInfo, bool> myLoadReferencedAssembly;
    private IMetadataSecurityRow[] mySecurity;
    private String[] mySecurityAttributesTypeName;
    private FileReference[] myReferencedFiles;
    private Guid myMvid;
    [ThreadStaticAttribute]
private static JetHashSet`1<MetadataAssembly> ourForwardedTypesResolutionInProgress;
    protected static ILogger Logger;
    [CompilerGeneratedAttribute]
private static Func`2<KeyValuePair`2<MetadataToken, AssemblyReference>, AssemblyNameInfo> CS$<>9__CachedAnonymousMethodDelegate3;
    public AssemblyNameInfo AssemblyName { get; }
    public Guid Mvid { get; }
    [CanBeNullAttribute]
public FileSystemPath Location { get; }
    public IMetadataAssemblyInternals Internals { get; }
    public IMetadataCustomAttribute[] ModuleAttributes { get; }
    public IMetadataSecurityRow[] Security { get; }
    public String[] SecurityAttributesTypeName { get; }
    public bool HasSecurity { get; }
    public IMetadataAccess MetadataAccess { get; }
    public IEnumerable`1<AssemblyNameInfo> ReferencedAssembliesNames { get; }
    public IEnumerable`1<AssemblyReference> ReferencedAssemblies { get; }
    public IEnumerable`1<KeyValuePair`2<MetadataToken, string>> ReferencedModules { get; }
    public FileReference[] ReferencedFiles { get; }
    public MetadataLoader Loader { get; }
    public IEntityPresentations EntityPresentations { get; }
    internal MetadataAssembly(MetadataToken assemblyToken, FileSystemPath location, IMetadataAccess metadataAccess, MetadataLoader loader, Func`2<AssemblyNameInfo, bool> loadReferencedAssembly);
    private static MetadataAssembly();
    public sealed virtual AssemblyNameInfo get_AssemblyName();
    public sealed virtual Guid get_Mvid();
    public sealed virtual FileSystemPath get_Location();
    public sealed virtual IMetadataTypeInfo GetTypeInfoFromQualifiedName(string assemblyQualifiedName, bool searchReferencedAssemblies);
    public sealed virtual IMetadataTypeInfo GetTypeInfoFromQualifiedName(string name, AssemblyNameInfo assemblyName, bool searchReferencedAssemblies);
    [CanBeNullAttribute]
private IMetadataTypeInfo TryGetTypeInfoFromQualifiedName(string name, bool searchReferencedAssemblies);
    public sealed virtual IMetadataType GetTypeFromQualifiedName(string qualifiedName, bool searchReferencedAssemblies);
    public sealed virtual IMetadataTypeInfo GetTypeInfoFromToken(MetadataToken token);
    public sealed virtual MethodSpecification GetMethodFromToken(MetadataToken methodToken);
    public sealed virtual IMetadataTypeInfo[] GetTypes();
    private void LoadTypes();
    private void BuildExportedTypes();
    public sealed virtual IMetadataTypeInfo[] GetExportedTypes();
    public sealed virtual IDictionary`2<string, AssemblyNameInfo> GetForwardedTypes();
    public sealed virtual IMetadataManifestResource[] GetManifestResources();
    public sealed virtual IImageBodyReader CreateImageBodyReader();
    public sealed virtual IMethodBodyUsagesFinder CreateUsagesFinder();
    public sealed virtual IMetadataAssemblyInternals get_Internals();
    public sealed virtual IMetadataCustomAttribute[] get_ModuleAttributes();
    public sealed virtual IMetadataSecurityRow[] get_Security();
    public sealed virtual String[] get_SecurityAttributesTypeName();
    public sealed virtual bool get_HasSecurity();
    public sealed virtual IMetadataAccess get_MetadataAccess();
    public sealed virtual IEnumerable`1<AssemblyNameInfo> get_ReferencedAssembliesNames();
    public sealed virtual IEnumerable`1<AssemblyReference> get_ReferencedAssemblies();
    public sealed virtual IEnumerable`1<KeyValuePair`2<MetadataToken, string>> get_ReferencedModules();
    public sealed virtual FileReference[] get_ReferencedFiles();
    public sealed virtual MetadataLoader get_Loader();
    public sealed virtual IMetadataType DecodeType(IBinaryReader reader, TypeDecodeContext context);
    public sealed virtual void ResetReferencedAssembliesCache();
    public sealed virtual IMetadataType GetTypeFromToken(MetadataToken token);
    public sealed virtual IMetadataType GetTypeFromToken(MetadataToken token, TypeDecodeContext context);
    public sealed virtual MethodSpecification GetMethodFromToken(MetadataToken methodToken, TypeDecodeContext context);
    private static MethodSpecification SearchMethodInType(IMetadataClassType type, string name, MethodSignature signature);
    public sealed virtual AssemblyNameInfo GetReferencedAssemblyName(MetadataToken assemblyToken);
    public sealed virtual IMetadataAssembly GetReferencedAssembly(MetadataToken assemblyToken);
    public sealed virtual IMetadataAssembly GetReferencedAssembly(AssemblyReference assemblyReference);
    private IMetadataAssembly GetReferencedAssembly(AssemblyNameInfo assemblyNameInfo);
    public sealed virtual IMetadataAssembly GetAssemblyFromReferencedFile(MetadataToken token);
    public sealed virtual FileSystemPath GetReferencedFile(MetadataToken token);
    public sealed virtual FieldSpecification GetFieldFromToken(MetadataToken fieldToken, TypeDecodeContext typeContext);
    public sealed virtual IEntityPresentations get_EntityPresentations();
    public sealed virtual IEnumerable`1<Pair`2<string, MetadataToken>> GetAllCustomAttributeStringsWithTokens();
    private static IList`1<string> ExtractStrings(MetadataAttributeValue[] values);
    private static IList`1<string> ExtractStrings(MetadataAttributeValue value);
    public virtual string ToString();
    public virtual int GetHashCode();
    public virtual bool Equals(IMetadataEntity other);
    [CompilerGeneratedAttribute]
private AssemblyNameInfo <.ctor>b__0();
    [CompilerGeneratedAttribute]
private static AssemblyNameInfo <get_ReferencedAssembliesNames>b__2(KeyValuePair`2<MetadataToken, AssemblyReference> pair);
    [CompilerGeneratedAttribute]
private object <GetAssemblyFromReferencedFile>b__4();
}
internal class JetBrains.Metadata.Reader.Impl.MetadataBoxedType : MetadataTypeBase {
    [CompilerGeneratedAttribute]
private IMetadataType <UnderlyingType>k__BackingField;
    public bool IsResolved { get; }
    public string FullName { get; }
    public string AssemblyQualification { get; }
    public IMetadataType UnderlyingType { get; private set; }
    public MetadataBoxedType(IMetadataType underlyingType, bool pinned);
    public virtual bool get_IsResolved();
    public virtual void Accept(IMetadataTypeVisitor visitor);
    public virtual IMetadataType Transform(IMetadataTypeTransformer transformer);
    public virtual string get_FullName();
    public virtual string get_AssemblyQualification();
    [CompilerGeneratedAttribute]
public sealed virtual IMetadataType get_UnderlyingType();
    [CompilerGeneratedAttribute]
private void set_UnderlyingType(IMetadataType value);
    public virtual string ToString();
}
internal class JetBrains.Metadata.Reader.Impl.MetadataClassType : MetadataTypeBase {
    private IMetadataTypeInfo myType;
    private IMetadataType[] myArguments;
    private string myFullName;
    public IMetadataTypeInfo Type { get; }
    public IMetadataType[] Arguments { get; }
    public bool IsResolved { get; }
    public string FullName { get; }
    public string AssemblyQualification { get; }
    public MetadataClassType(IMetadataTypeInfo type, IMetadataType[] genericArguments, IMetadataTypeModifier[] typeModifiers, bool pinned);
    public sealed virtual IMetadataTypeInfo get_Type();
    public sealed virtual IMetadataType[] get_Arguments();
    public virtual bool get_IsResolved();
    public virtual void Accept(IMetadataTypeVisitor visitor);
    public virtual IMetadataType Transform(IMetadataTypeTransformer transformer);
    public virtual string get_FullName();
    public virtual string get_AssemblyQualification();
}
public class JetBrains.Metadata.Reader.Impl.MetadataCustomAttribute : MetadataEntity {
    private IMetadataMethod myConstructor;
    private MetadataAttributeValue[] myConstructorArguments;
    private IMetadataCustomAttributeFieldInitialization[] myInitializedFields;
    private IMetadataCustomAttributePropertyInitialization[] myInitializedProperties;
    public IMetadataMethod UsedConstructor { get; }
    public MetadataAttributeValue[] ConstructorArguments { get; }
    public IMetadataCustomAttributeFieldInitialization[] InitializedFields { get; }
    public IMetadataCustomAttributePropertyInitialization[] InitializedProperties { get; }
    public MetadataCustomAttribute(MetadataToken token, IMetadataAssembly assembly);
    public sealed virtual IMetadataMethod get_UsedConstructor();
    public sealed virtual MetadataAttributeValue[] get_ConstructorArguments();
    public sealed virtual IMetadataCustomAttributeFieldInitialization[] get_InitializedFields();
    public sealed virtual IMetadataCustomAttributePropertyInitialization[] get_InitializedProperties();
    public sealed virtual Byte[] GetBytes();
    private void ReadBlobIfNeeded();
    public virtual string ToString();
}
public abstract class JetBrains.Metadata.Reader.Impl.MetadataEntity : object {
    protected MetadataToken myToken;
    protected IMetadataAssembly myAssembly;
    private IMetadataCustomAttribute[] myMetadataCustomAttributes;
    private MetadataTypeReference[] myCustomAttributesTypeName;
    [NotNullAttribute]
public IMetadataAssembly Assembly { get; }
    public MetadataToken Token { get; }
    public IMetadataCustomAttribute[] CustomAttributes { get; }
    public MetadataTypeReference[] CustomAttributesTypeNames { get; }
    public bool IsResolved { get; }
    protected MetadataEntity(MetadataToken token, IMetadataAssembly assembly);
    protected void SetAssembly(IMetadataAssembly assembly);
    public sealed virtual IMetadataAssembly get_Assembly();
    public sealed virtual MetadataToken get_Token();
    private void LoadCustomAttributesTypeName();
    public sealed virtual IMetadataCustomAttribute[] get_CustomAttributes();
    public sealed virtual MetadataTypeReference[] get_CustomAttributesTypeNames();
    private void LoadCustomAttributes();
    public sealed virtual IList`1<IMetadataCustomAttribute> GetCustomAttributes(string attributeClassFullyQualifiedName);
    public sealed virtual bool HasCustomAttribute(string attributeClassFullyQualifiedName);
    public sealed virtual bool get_IsResolved();
    public abstract virtual string ToString();
    public virtual bool Equals(IMetadataEntity other);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
public class JetBrains.Metadata.Reader.Impl.MetadataEvent : MetadataEntity {
    private EventProperties myProperties;
    private IMetadataMethod myAdder;
    private IMetadataMethod myRemover;
    private IMetadataMethod myRaiser;
    private IMetadataMethod[] myOther;
    private IMetadataType myType;
    public string Name { get; }
    public IMetadataType Type { get; }
    public IMetadataTypeInfo DeclaringType { get; }
    public IMetadataMethod Adder { get; }
    public IMetadataMethod Remover { get; }
    public IMetadataMethod Raiser { get; }
    public IMetadataMethod[] OtherMethods { get; }
    public bool IsSpecialName { get; }
    public bool IsRuntimeSpecialName { get; }
    public MetadataEvent(MetadataToken token, IMetadataAssembly assembly);
    public sealed virtual string get_Name();
    public sealed virtual IMetadataType get_Type();
    public sealed virtual IMetadataTypeInfo get_DeclaringType();
    public sealed virtual IMetadataMethod get_Adder();
    public sealed virtual IMetadataMethod get_Remover();
    public sealed virtual IMetadataMethod get_Raiser();
    public sealed virtual IMetadataMethod[] get_OtherMethods();
    public sealed virtual bool get_IsSpecialName();
    public sealed virtual bool get_IsRuntimeSpecialName();
    public virtual string ToString();
}
public class JetBrains.Metadata.Reader.Impl.MetadataField : MetadataEntity {
    private object myLiteralValue;
    private FieldSignature mySignature;
    private IMetadataTypeInfo myDeclaringType;
    private bool myIsLiteral;
    private CorFieldAttr myFlags;
    private MetadataToken myDeclaringTypeToken;
    private string myName;
    private int myFieldOffset;
    private UInt32 myInitialValueRva;
    private IBlob myLiteralValueBlob;
    private IBlob myMarshalSpec;
    public string Name { get; }
    public IMetadataType Type { get; }
    public IMetadataTypeInfo DeclaringType { get; }
    public IBlob MarshalSpec { get; }
    public int Offset { get; }
    public FieldSignature Signature { get; }
    public UInt32 InitialValueRva { get; }
    public bool IsAssembly { get; }
    public bool IsPrivate { get; }
    public bool IsPublic { get; }
    public bool IsFamily { get; }
    public bool IsFamilyAndAssembly { get; }
    public bool IsFamilyOrAssembly { get; }
    public bool IsSpecialName { get; }
    public bool IsRuntimeSpecialName { get; }
    public bool IsStatic { get; }
    public bool IsInitOnly { get; }
    public bool IsLiteral { get; }
    public bool HasMarshalSpec { get; }
    public bool NotSerialized { get; }
    public MetadataField(MetadataToken token, IMetadataAssembly assembly, int fieldOffset);
    public sealed virtual string get_Name();
    public sealed virtual IMetadataType get_Type();
    public sealed virtual IMetadataTypeInfo get_DeclaringType();
    public sealed virtual IBlob get_MarshalSpec();
    public sealed virtual object GetLiteralValue();
    public sealed virtual IBlob GetLiteralValueBlob();
    public sealed virtual int get_Offset();
    public sealed virtual FieldSignature get_Signature();
    public sealed virtual UInt32 get_InitialValueRva();
    public sealed virtual bool get_IsAssembly();
    public sealed virtual bool get_IsPrivate();
    public sealed virtual bool get_IsPublic();
    public sealed virtual bool get_IsFamily();
    public sealed virtual bool get_IsFamilyAndAssembly();
    public sealed virtual bool get_IsFamilyOrAssembly();
    public sealed virtual bool get_IsSpecialName();
    public sealed virtual bool get_IsRuntimeSpecialName();
    public sealed virtual bool get_IsStatic();
    public sealed virtual bool get_IsInitOnly();
    public sealed virtual bool get_IsLiteral();
    public sealed virtual bool get_HasMarshalSpec();
    public sealed virtual bool get_NotSerialized();
    private void ImportLiteralValue(FieldProperties fieldProperties);
    public virtual string ToString();
}
public class JetBrains.Metadata.Reader.Impl.MetadataForwardedTypeInfo : object {
    private AssemblyNameInfo myAssemblyName;
    private string myFullName;
    public AssemblyNameInfo AssemblyName { get; }
    public string FullName { get; }
    public MetadataForwardedTypeInfo(AssemblyNameInfo assemblyName, string typeFullName);
    public sealed virtual AssemblyNameInfo get_AssemblyName();
    public sealed virtual string get_FullName();
}
internal class JetBrains.Metadata.Reader.Impl.MetadataFunctionPointerType : MetadataTypeBase {
    private MethodSignature myMethodSignature;
    [CompilerGeneratedAttribute]
private static Func`3<StringBuilder, IMetadataType, StringBuilder> CS$<>9__CachedAnonymousMethodDelegate1;
    public string AssemblyQualification { get; }
    public bool IsResolved { get; }
    public string FullName { get; }
    public MethodSignature MethodSignature { get; }
    public MetadataFunctionPointerType(MethodSignature methodSignature, IMetadataTypeModifier[] typeModifiers, bool pinned);
    public virtual string get_AssemblyQualification();
    public virtual void Accept(IMetadataTypeVisitor visitor);
    public virtual bool get_IsResolved();
    public virtual IMetadataType Transform(IMetadataTypeTransformer transformer);
    public virtual string get_FullName();
    public sealed virtual MethodSignature get_MethodSignature();
    [CompilerGeneratedAttribute]
private static StringBuilder <get_FullName>b__0(StringBuilder b, IMetadataType t);
}
public class JetBrains.Metadata.Reader.Impl.MetadataGenericArgument : MetadataEntity {
    private GenericParamProperties myProperties;
    private IMetadataType[] myConstraints;
    private IMetadataTypeInfo myOwnerType;
    private IMetadataMethod myOwnerMethod;
    public GenericArgumentKind Kind { get; }
    public string Name { get; }
    public UInt32 Index { get; }
    public IMetadataTypeInfo TypeOwner { get; }
    public IMetadataMethod MethodOwner { get; }
    public IMetadataType[] TypeConstraints { get; }
    public GenericArgumentAttributes Attributes { get; }
    public MetadataGenericArgument(MetadataToken token, IMetadataAssembly assembly);
    public sealed virtual GenericArgumentKind get_Kind();
    public sealed virtual string get_Name();
    public sealed virtual UInt32 get_Index();
    public sealed virtual IMetadataTypeInfo get_TypeOwner();
    public sealed virtual IMetadataMethod get_MethodOwner();
    public sealed virtual IMetadataType[] get_TypeConstraints();
    public sealed virtual GenericArgumentAttributes get_Attributes();
    public virtual string ToString();
}
internal class JetBrains.Metadata.Reader.Impl.MetadataGenericArgumentReferenceType : MetadataTypeBase {
    private IMetadataGenericArgument myArgument;
    public IMetadataGenericArgument Argument { get; }
    public string AssemblyQualification { get; }
    public string AssemblyQualifiedName { get; }
    public bool IsResolved { get; }
    public string FullName { get; }
    public MetadataGenericArgumentReferenceType(IMetadataGenericArgument argument, IMetadataTypeModifier[] typeModifiers, bool pinned);
    public sealed virtual IMetadataGenericArgument get_Argument();
    public virtual string get_AssemblyQualification();
    public virtual string get_AssemblyQualifiedName();
    public virtual bool get_IsResolved();
    public virtual void Accept(IMetadataTypeVisitor visitor);
    public virtual IMetadataType Transform(IMetadataTypeTransformer transformer);
    public virtual string get_FullName();
}
public class JetBrains.Metadata.Reader.Impl.MetadataManifestResource : MetadataEntity {
    private ManifestResourceAttributes myFlags;
    private MetadataToken myImplementation;
    private string myName;
    private UInt32 myOffset;
    public UInt32 Offset { get; }
    public ManifestResourceAttributes Flags { get; }
    public string Name { get; }
    public MetadataToken Implementation { get; }
    public MetadataManifestResource(MetadataToken manifestResourceToken, IMetadataAssembly assembly);
    public sealed virtual UInt32 get_Offset();
    public sealed virtual ManifestResourceAttributes get_Flags();
    public sealed virtual string get_Name();
    public sealed virtual MetadataToken get_Implementation();
    public sealed virtual IManifestResourceDisposition GetDisposition();
    public virtual string ToString();
}
public class JetBrains.Metadata.Reader.Impl.MetadataMethod : MetadataEntity {
    private MetadataToken myDeclaringTypeToken;
    private CorMethodAttr myFlags;
    private CorMethodImpl myImplFlags;
    private UInt32 myCodeRva;
    private string myName;
    private PInvokeInfo myPInvokeInfo;
    private IMetadataGenericArgument[] myArguments;
    private IMetadataTypeInfo myDeclaringType;
    private IMetadataParameter[] myParameters;
    private IMetadataReturnValue myReturnValue;
    private MethodSignature mySignature;
    private IBlob mySignatureBlob;
    private IMetadataSecurityRow[] mySecurity;
    private String[] mySecurityAttributesTypeName;
    public string Name { get; }
    public IMetadataTypeInfo DeclaringType { get; }
    public IMetadataParameter[] Parameters { get; }
    public IMetadataReturnValue ReturnValue { get; }
    public IMetadataGenericArgument[] GenericArguments { get; }
    public IList`1<MethodSpecification> ImplementedMethods { get; }
    public MethodSignature Signature { get; }
    public PInvokeInfo PInvokeInfo { get; }
    public CorMethodImpl MethodImplFlags { get; }
    public IMetadataSecurityRow[] Security { get; }
    public String[] SecurityAttributesTypeName { get; }
    public bool IsPInvokeImpl { get; }
    public bool HasSecurity { get; }
    public CodeType CodeType { get; }
    public UInt32 CodeRva { get; }
    public bool IsForwardRef { get; }
    public bool IsPreserveSig { get; }
    public bool IsInternalCall { get; }
    public bool IsSynchronized { get; }
    public bool NoInlining { get; }
    public bool AggressiveInlining { get; }
    public bool NoOptimization { get; }
    public bool IsAssembly { get; }
    public bool IsPrivate { get; }
    public bool IsPublic { get; }
    public bool IsFamily { get; }
    public bool IsFamilyAndAssembly { get; }
    public bool IsFamilyOrAssembly { get; }
    public bool IsSpecialName { get; }
    public bool IsRuntimeSpecialName { get; }
    public bool IsStatic { get; }
    public bool IsAbstract { get; }
    public bool IsExtern { get; }
    public bool IsVirtual { get; }
    public bool IsFinal { get; }
    public bool IsHideBySig { get; }
    public bool IsNewSlot { get; }
    public bool IsStrict { get; }
    public bool IsVarArg { get; }
    public bool IsUnmanaged { get; }
    public MetadataMethod(MetadataToken token, IMetadataAssembly assembly);
    public sealed virtual string get_Name();
    public sealed virtual IMetadataTypeInfo get_DeclaringType();
    public sealed virtual IMetadataParameter[] get_Parameters();
    public sealed virtual IMetadataReturnValue get_ReturnValue();
    public sealed virtual IMetadataGenericArgument[] get_GenericArguments();
    public sealed virtual IList`1<MethodSpecification> get_ImplementedMethods();
    public sealed virtual MethodSignature get_Signature();
    public sealed virtual PInvokeInfo get_PInvokeInfo();
    public sealed virtual CorMethodImpl get_MethodImplFlags();
    public sealed virtual IMetadataSecurityRow[] get_Security();
    public sealed virtual String[] get_SecurityAttributesTypeName();
    public sealed virtual bool get_IsPInvokeImpl();
    public sealed virtual bool get_HasSecurity();
    public sealed virtual CodeType get_CodeType();
    public sealed virtual UInt32 get_CodeRva();
    public sealed virtual bool get_IsForwardRef();
    public sealed virtual bool get_IsPreserveSig();
    public sealed virtual bool get_IsInternalCall();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual bool get_NoInlining();
    public sealed virtual bool get_AggressiveInlining();
    public sealed virtual bool get_NoOptimization();
    public sealed virtual bool get_IsAssembly();
    public sealed virtual bool get_IsPrivate();
    public sealed virtual bool get_IsPublic();
    public sealed virtual bool get_IsFamily();
    public sealed virtual bool get_IsFamilyAndAssembly();
    public sealed virtual bool get_IsFamilyOrAssembly();
    public sealed virtual bool get_IsSpecialName();
    public sealed virtual bool get_IsRuntimeSpecialName();
    public sealed virtual bool get_IsStatic();
    public sealed virtual bool get_IsAbstract();
    public sealed virtual bool get_IsExtern();
    public sealed virtual bool get_IsVirtual();
    public sealed virtual bool get_IsFinal();
    public sealed virtual bool get_IsHideBySig();
    public sealed virtual bool get_IsNewSlot();
    public sealed virtual bool get_IsStrict();
    public sealed virtual bool get_IsVarArg();
    public sealed virtual bool get_IsUnmanaged();
    public virtual string ToString();
}
internal class JetBrains.Metadata.Reader.Impl.MetadataMethodSignatureBuilder : object {
    private IMetadataGenericArgument[] myTypeGenericArguments;
    private IMetadataAssembly myAssembly;
    private TypeDecodeContext myContext;
    public MetadataMethodSignatureBuilder(IMetadataAssembly assembly, IMetadataGenericArgument[] typeGenericArguments);
    public MetadataMethodSignatureBuilder(IMetadataAssembly assembly, TypeDecodeContext context);
    public sealed virtual ITypeBuilder`2<IMetadataType, MethodSignature> GetTypeBuilder(UInt32 methodGenericArgumentsCount);
    public sealed virtual MethodSignature BuildMethodSignature(bool isVararg, bool hasThis, UInt32 genericArgumentsCount, IMetadataType returnType, IMetadataType[] parameterTypes, IMetadataType[] varargParameterTypes);
}
public class JetBrains.Metadata.Reader.Impl.MetadataParameter : MetadataEntity {
    private IMetadataType myType;
    private ParamProperties myProperties;
    private IMetadataMethod myMethod;
    private bool myIsParamArray;
    private bool myHasDefaultValue;
    private IBlob myMarshalSpec;
    private IBlob myDefaultValueBlob;
    private object myDefaultValue;
    public string Name { get; }
    public IMetadataType Type { get; }
    public IMetadataMethod DeclaringMethod { get; }
    public IBlob MarshalSpec { get; }
    public bool IsIn { get; }
    public bool IsOut { get; }
    public bool IsParamArray { get; }
    public bool IsOptional { get; }
    public bool HasMarshalSpec { get; }
    public bool HasDefaultValue { get; }
    public MetadataParameter(MetadataToken token, IMetadataType type, IMetadataMethod method, IMetadataAssembly assembly);
    public sealed virtual string get_Name();
    public sealed virtual IMetadataType get_Type();
    public sealed virtual IMetadataMethod get_DeclaringMethod();
    public sealed virtual IBlob get_MarshalSpec();
    public sealed virtual bool get_IsIn();
    public sealed virtual bool get_IsOut();
    public sealed virtual bool get_IsParamArray();
    public sealed virtual bool get_IsOptional();
    public sealed virtual bool get_HasMarshalSpec();
    public sealed virtual bool get_HasDefaultValue();
    public sealed virtual object GetDefaultValue();
    public sealed virtual IBlob GetDefaultValueBlob();
    public virtual string ToString();
}
internal class JetBrains.Metadata.Reader.Impl.MetadataPointerType : MetadataTypeBase {
    private IMetadataType myType;
    public IMetadataType Type { get; }
    public string AssemblyQualification { get; }
    public bool IsResolved { get; }
    public string FullName { get; }
    public MetadataPointerType(IMetadataType type, IMetadataTypeModifier[] typeModifiers, bool pinned);
    public sealed virtual IMetadataType get_Type();
    public virtual string get_AssemblyQualification();
    public virtual bool get_IsResolved();
    public virtual void Accept(IMetadataTypeVisitor visitor);
    public virtual IMetadataType Transform(IMetadataTypeTransformer transformer);
    public virtual string get_FullName();
}
public class JetBrains.Metadata.Reader.Impl.MetadataProperty : MetadataEntity {
    private IMetadataMethod[] myOtherAccessors;
    private IMetadataType myType;
    private MetadataToken myDeclaringTypeToken;
    private MetadataToken myGetter;
    private MetadataToken mySetter;
    private MetadataToken[] myOtherMethods;
    private string myName;
    private CorPropertyAttr myPropertyFlags;
    public string Name { get; }
    public IMetadataType Type { get; }
    public IMetadataTypeInfo DeclaringType { get; }
    public IMetadataMethod Getter { get; }
    public IMetadataMethod Setter { get; }
    public IMetadataMethod[] OtherAccessors { get; }
    public bool IsSpecialName { get; }
    public bool IsRuntimeSpecialName { get; }
    public MetadataProperty(MetadataToken token, IMetadataAssembly assembly);
    public sealed virtual string get_Name();
    public sealed virtual IMetadataType get_Type();
    public sealed virtual IMetadataTypeInfo get_DeclaringType();
    public sealed virtual IMetadataMethod get_Getter();
    public sealed virtual IMetadataMethod get_Setter();
    public sealed virtual IMetadataMethod[] get_OtherAccessors();
    public sealed virtual bool get_IsSpecialName();
    public sealed virtual bool get_IsRuntimeSpecialName();
    private void ReadSignature(IBlob signatureBlob);
    public virtual string ToString();
}
internal class JetBrains.Metadata.Reader.Impl.MetadataReferenceType : MetadataTypeBase {
    private IMetadataType myType;
    public IMetadataType Type { get; }
    public string AssemblyQualification { get; }
    public bool IsResolved { get; }
    public string FullName { get; }
    public MetadataReferenceType(IMetadataType type, IMetadataTypeModifier[] typeModifiers, bool pinned);
    public sealed virtual IMetadataType get_Type();
    public virtual string get_AssemblyQualification();
    public virtual bool get_IsResolved();
    public virtual void Accept(IMetadataTypeVisitor visitor);
    public virtual IMetadataType Transform(IMetadataTypeTransformer transformer);
    public virtual string get_FullName();
}
public class JetBrains.Metadata.Reader.Impl.MetadataReturnValue : MetadataEntity {
    private IMetadataType myType;
    private ParamProperties myProperties;
    private IMetadataMethod myMethod;
    private IBlob myMarshalSpec;
    public IMetadataMethod DeclaringMethod { get; }
    public IMetadataType Type { get; }
    public bool HasMarshalSpec { get; }
    public IBlob MarshalSpec { get; }
    public MetadataReturnValue(MetadataToken token, IMetadataType type, IMetadataMethod method, IMetadataAssembly assembly);
    public sealed virtual IMetadataMethod get_DeclaringMethod();
    public sealed virtual IMetadataType get_Type();
    public sealed virtual bool get_HasMarshalSpec();
    public sealed virtual IBlob get_MarshalSpec();
    public virtual string ToString();
}
internal class JetBrains.Metadata.Reader.Impl.MetadataSecurityAttribute : object {
    private IMetadataCustomAttributeFieldInitialization[] myInitializedFields;
    private IMetadataCustomAttributePropertyInitialization[] myInitializedProperties;
    private IMetadataTypeInfo myType;
    private IMetadataSecurityRow myDeclaringSecurityRow;
    private Byte[] myConstructorArgumentsBlob;
    private SecurityAction myAction;
    public IMetadataSecurityRow DeclaringSecurityRow { get; }
    public IMetadataTypeInfo Type { get; }
    public IMetadataCustomAttributeFieldInitialization[] InitializedFields { get; }
    public IMetadataCustomAttributePropertyInitialization[] InitializedProperties { get; }
    public Byte[] ConstructorArgumentsBlob { get; }
    public SecurityAction Action { get; }
    public MetadataSecurityAttribute(IMetadataTypeInfo type, IMetadataCustomAttributeFieldInitialization[] initializedFields, IMetadataCustomAttributePropertyInitialization[] initializedProperties, Byte[] constructorArgumentsBlob, SecurityAction action, IMetadataSecurityRow declaringSecurityRow);
    public MetadataSecurityAttribute(IMetadataTypeInfo type, IMetadataCustomAttributeFieldInitialization[] initializedFields, IMetadataCustomAttributePropertyInitialization[] initializedProperties, Byte[] constructorArgumentsBlob, IMetadataSecurityRow declaringSecurityRow);
    public sealed virtual IMetadataSecurityRow get_DeclaringSecurityRow();
    public sealed virtual IMetadataTypeInfo get_Type();
    public sealed virtual IMetadataCustomAttributeFieldInitialization[] get_InitializedFields();
    public sealed virtual IMetadataCustomAttributePropertyInitialization[] get_InitializedProperties();
    public sealed virtual Byte[] get_ConstructorArgumentsBlob();
    public sealed virtual SecurityAction get_Action();
    public virtual string ToString();
}
public class JetBrains.Metadata.Reader.Impl.MetadataSecurityRow : MetadataEntity {
    private SecurityAction myAction;
    private IBlob myPermissionSetBlob;
    private IMetadataSecurityAttribute[] myAttributes;
    [CompilerGeneratedAttribute]
private static Func`3<StringBuilder, IMetadataSecurityAttribute, StringBuilder> CS$<>9__CachedAnonymousMethodDelegate1;
    public SecurityAction Action { get; }
    public IMetadataSecurityAttribute[] Attributes { get; }
    public MetadataSecurityRow(MetadataToken declSecurityToken, IMetadataAssembly assembly);
    public sealed virtual SecurityAction get_Action();
    public sealed virtual IMetadataSecurityAttribute[] get_Attributes();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
private static StringBuilder <ToString>b__0(StringBuilder sb, IMetadataSecurityAttribute sa);
}
public class JetBrains.Metadata.Reader.Impl.MetadataSpecificTypeNameParser : AbstractTypeNameParser`1<IMetadataType> {
    private bool mySearchReferencedAssemblies;
    private ITypeInfoByNameProvider myTypeInfoByNameProvider;
    public MetadataSpecificTypeNameParser(string typeName, ITypeInfoByNameProvider typeInfoByNameProvider, bool searchReferencedAssemblies);
    protected virtual IMetadataType CreateUnresolvedType(string typeName, TextRange typeNameRange);
    protected virtual IMetadataType CreateTypeByNameAndAssembly(string typeName, TextRange typeNameRange, string assemblyName, TextRange assemblyNameRange, TextRange assemblyFullNameRange, IMetadataType[] genericParameters);
    protected virtual IMetadataType CreatePointerType(IMetadataType elementType);
    protected virtual IMetadataType CreateArrayType(IMetadataType elementType, UInt32 rank, UInt32[] sizes, Int32[] lBounds);
    protected virtual IMetadataType CreateArrayType(IMetadataType elementType);
    protected virtual IMetadataType CreateReferenceType(IMetadataType elementType);
}
public abstract class JetBrains.Metadata.Reader.Impl.MetadataTypeBase : object {
    private IMetadataTypeModifier[] myTypeModifiers;
    private bool myPinned;
    public IMetadataTypeModifier[] TypeModifiers { get; }
    public bool Pinned { get; }
    public bool IsResolved { get; }
    public string FullName { get; }
    public string AssemblyQualification { get; }
    public string AssemblyQualifiedName { get; }
    protected MetadataTypeBase(IMetadataTypeModifier[] typeModifiers, bool pinned);
    public sealed virtual IMetadataTypeModifier[] get_TypeModifiers();
    public sealed virtual bool get_Pinned();
    public virtual bool get_IsResolved();
    public abstract virtual void Accept(IMetadataTypeVisitor visitor);
    public abstract virtual IMetadataType Transform(IMetadataTypeTransformer transformer);
    public abstract virtual string get_FullName();
    public abstract virtual string get_AssemblyQualification();
    public virtual string get_AssemblyQualifiedName();
    public virtual string ToString();
}
internal class JetBrains.Metadata.Reader.Impl.MetadataTypeBuilder : object {
    private IMetadataAssembly myAssembly;
    private TypeDecodeContext myTypeDecodeContext;
    public IMethodSignatureBuilder`2<IMetadataType, MethodSignature> MethodSignatureBuilder { get; }
    public MetadataTypeBuilder(IMetadataAssembly assembly, TypeDecodeContext typeDecodeContext);
    public sealed virtual IMethodSignatureBuilder`2<IMetadataType, MethodSignature> get_MethodSignatureBuilder();
    public sealed virtual IMetadataType BuildWellKnownType(ElementType type);
    public sealed virtual IMetadataType BuildPointerType(IMetadataType type);
    public sealed virtual IMetadataType BuildReferenceType(IMetadataType type);
    public sealed virtual IMetadataType BuildClassType(MetadataToken typeDefOrRefOrSpecToken);
    public sealed virtual IMetadataType BuildGenericInst(IMetadataType type, IMetadataType[] args);
    public sealed virtual IMetadataType BuildTypeGenericArgument(UInt32 index);
    public sealed virtual IMetadataType BuildMethodGenericArgument(UInt32 index);
    public sealed virtual IMetadataType BuildFunctionPointer(MethodSignature fnsig);
    public sealed virtual IMetadataType BuildArrayType(IMetadataType elementType, UInt32 rank, UInt32[] sizes, Int32[] lBounds);
    public sealed virtual IMetadataType BuildArrayType(IMetadataType elementType);
    public sealed virtual IMetadataType AddRequiredModifier(IMetadataType type, IMetadataType modifier);
    public sealed virtual IMetadataType AddOptionalModifier(IMetadataType type, IMetadataType modifier);
    public sealed virtual IMetadataType AddPinnedConstraint(IMetadataType type);
    public sealed virtual IMetadataType BuildUndecodedType();
    private static IMetadataType AddModifier(IMetadataType type, IMetadataTypeModifier modifier);
}
public class JetBrains.Metadata.Reader.Impl.MetadataTypeInfo : MetadataEntity {
    private IMetadataClassType myBase;
    private IMetadataGenericArgument[] myArguments;
    private ClassLayout myClassLayout;
    private IMetadataTypeInfo myDeclaringType;
    private IMetadataEvent[] myEvents;
    private IMetadataField[] myFields;
    private string myFullName;
    private IMetadataClassType[] myInterfaces;
    private IMetadataMethod[] myMethods;
    private IMetadataTypeInfo[] myNestedTypes;
    private TypeDefProperties myProperties;
    private IMetadataProperty[] myTypeProperties;
    private IMetadataSecurityRow[] mySecurity;
    private String[] mySecurityAttributesTypeName;
    private ClassLayout ClassLayout { get; }
    private bool IsNested { get; }
    public string FullyQualifiedName { get; }
    public string AssemblyQualifiedName { get; }
    public string Name { get; }
    public string NamespaceName { get; }
    public string TypeName { get; }
    public AssemblyNameInfo DeclaringAssemblyName { get; }
    public IMetadataClassType Base { get; }
    public IMetadataTypeInfo DeclaringType { get; }
    public IMetadataClassType[] Interfaces { get; }
    public IMetadataGenericArgument[] GenericParameters { get; }
    public bool IsAbstract { get; }
    public bool IsSealed { get; }
    public bool IsImported { get; }
    public ClassLayoutType Layout { get; }
    public CharSetSpec InteropStringFormat { get; }
    public bool IsClass { get; }
    public bool IsInterface { get; }
    public bool IsSerializable { get; }
    public bool IsWindowsRuntime { get; }
    public bool IsPublic { get; }
    public bool IsNotPublic { get; }
    private bool JetBrains.Metadata.Reader.API.IMetadataTypeInfo.IsNested { get; }
    public bool IsNestedPublic { get; }
    public bool IsNestedPrivate { get; }
    public bool IsNestedFamily { get; }
    public bool IsNestedAssembly { get; }
    public bool IsNestedFamilyAndAssembly { get; }
    public bool IsNestedFamilyOrAssembly { get; }
    public int PackingSize { get; }
    public int ClassSize { get; }
    public bool IsSpecialName { get; }
    public bool IsRuntimeSpecialName { get; }
    public bool IsBeforeFieldInit { get; }
    public bool HasSecurity { get; }
    public IMetadataSecurityRow[] Security { get; }
    public String[] SecurityAttributesTypeName { get; }
    public MetadataTypeInfo(MetadataToken token, IMetadataAssembly assembly);
    private ClassLayout get_ClassLayout();
    private bool get_IsNested();
    public sealed virtual string get_FullyQualifiedName();
    public sealed virtual string get_AssemblyQualifiedName();
    public sealed virtual string get_Name();
    public sealed virtual string get_NamespaceName();
    public sealed virtual string get_TypeName();
    public sealed virtual AssemblyNameInfo get_DeclaringAssemblyName();
    public sealed virtual IMetadataClassType get_Base();
    public sealed virtual IMetadataTypeInfo get_DeclaringType();
    public sealed virtual IMetadataClassType[] get_Interfaces();
    public sealed virtual IMetadataGenericArgument[] get_GenericParameters();
    public sealed virtual bool get_IsAbstract();
    public sealed virtual bool get_IsSealed();
    public sealed virtual bool get_IsImported();
    public sealed virtual ClassLayoutType get_Layout();
    public sealed virtual CharSetSpec get_InteropStringFormat();
    public sealed virtual bool get_IsClass();
    public sealed virtual bool get_IsInterface();
    public sealed virtual bool get_IsSerializable();
    public sealed virtual bool get_IsWindowsRuntime();
    public sealed virtual bool get_IsPublic();
    public sealed virtual bool get_IsNotPublic();
    private sealed virtual override bool JetBrains.Metadata.Reader.API.IMetadataTypeInfo.get_IsNested();
    public sealed virtual bool get_IsNestedPublic();
    public sealed virtual bool get_IsNestedPrivate();
    public sealed virtual bool get_IsNestedFamily();
    public sealed virtual bool get_IsNestedAssembly();
    public sealed virtual bool get_IsNestedFamilyAndAssembly();
    public sealed virtual bool get_IsNestedFamilyOrAssembly();
    public sealed virtual int get_PackingSize();
    public sealed virtual int get_ClassSize();
    public sealed virtual bool get_IsSpecialName();
    public sealed virtual bool get_IsRuntimeSpecialName();
    public sealed virtual bool get_IsBeforeFieldInit();
    public sealed virtual IEnumerable`1<MemberInfo> GetMemberInfos();
    public sealed virtual bool get_HasSecurity();
    public sealed virtual IMetadataSecurityRow[] get_Security();
    public sealed virtual String[] get_SecurityAttributesTypeName();
    public sealed virtual IMetadataMethod[] GetMethods();
    public sealed virtual bool HasExtensionMethods();
    public sealed virtual IMetadataField[] GetFields();
    public sealed virtual IMetadataProperty[] GetProperties();
    public sealed virtual IMetadataEvent[] GetEvents();
    public sealed virtual IMetadataTypeInfo[] GetNestedTypes();
    private IMetadataClassType GetBase();
    public virtual string ToString();
}
public class JetBrains.Metadata.Reader.Impl.MetadataTypeModifier : object {
    private MetadataModifierKind myKind;
    private IMetadataType myType;
    public MetadataModifierKind Kind { get; }
    public IMetadataType Type { get; }
    public MetadataTypeModifier(MetadataModifierKind kind, IMetadataType type);
    public sealed virtual MetadataModifierKind get_Kind();
    public sealed virtual IMetadataType get_Type();
}
internal class JetBrains.Metadata.Reader.Impl.MethodBody : object {
    private IMetadataAssembly myAssembly;
    private Dictionary`2<object, MetadataToken> myInstructionOperandToToken;
    [CompilerGeneratedAttribute]
private IMetadataMethod <Method>k__BackingField;
    [CompilerGeneratedAttribute]
private Instruction[] <Instructions>k__BackingField;
    [CompilerGeneratedAttribute]
private IMethodBodyExceptionHandler[] <ExceptionHandlers>k__BackingField;
    [CompilerGeneratedAttribute]
private IMethodBodyLocalVariable[] <LocalVariables>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxStack>k__BackingField;
    [CompilerGeneratedAttribute]
private MetadataToken <LocalVariablesSignatureToken>k__BackingField;
    public IMetadataMethod Method { get; private set; }
    public Instruction[] Instructions { get; private set; }
    public IMethodBodyExceptionHandler[] ExceptionHandlers { get; private set; }
    public IMethodBodyLocalVariable[] LocalVariables { get; private set; }
    public int MaxStack { get; private set; }
    public MetadataToken LocalVariablesSignatureToken { get; private set; }
    public MethodBody(ILMethodBody body, IMetadataMethod context, IMetadataAssembly assembly);
    [CompilerGeneratedAttribute]
public sealed virtual IMetadataMethod get_Method();
    [CompilerGeneratedAttribute]
private void set_Method(IMetadataMethod value);
    [CompilerGeneratedAttribute]
public sealed virtual Instruction[] get_Instructions();
    [CompilerGeneratedAttribute]
private void set_Instructions(Instruction[] value);
    [CompilerGeneratedAttribute]
public sealed virtual IMethodBodyExceptionHandler[] get_ExceptionHandlers();
    [CompilerGeneratedAttribute]
private void set_ExceptionHandlers(IMethodBodyExceptionHandler[] value);
    [CompilerGeneratedAttribute]
public sealed virtual IMethodBodyLocalVariable[] get_LocalVariables();
    [CompilerGeneratedAttribute]
private void set_LocalVariables(IMethodBodyLocalVariable[] value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_MaxStack();
    [CompilerGeneratedAttribute]
private void set_MaxStack(int value);
    [CompilerGeneratedAttribute]
public sealed virtual MetadataToken get_LocalVariablesSignatureToken();
    [CompilerGeneratedAttribute]
private void set_LocalVariablesSignatureToken(MetadataToken value);
    public sealed virtual MetadataToken GetTokenByInstructionOperand(object instructionOperand);
    private IMethodBodyExceptionHandler[] DecodeExceptionHandlers(ExceptionHandler[] handlers);
    private Instruction[] DecodeInstructions(ILMethodBody methodBody);
    private static object WrapMethodSpecification(Instruction instruction, MethodSpecification methodSpecification);
    private TypeDecodeContext GetTypeDecodeContext();
    private IMethodBodyLocalVariable[] DecodeLocalVariables(MetadataToken localVarsToken);
    public virtual string ToString();
}
[DebuggerDisplayAttribute("{myType} {myTryOffset}:{myTryLength} {myHandlerOffset}:{myHandlerLength}")]
internal class JetBrains.Metadata.Reader.Impl.MethodBodyExceptionHandler : object {
    private int myHandlerLength;
    private int myHandlerOffset;
    private IMetadataType myCatchType;
    private int myFilterOffset;
    private int myTryLength;
    private int myTryOffset;
    private ExceptionHandlerType myType;
    public ExceptionHandlerType Type { get; }
    public int HandlerLength { get; }
    public int HandlerOffset { get; }
    public IMetadataType CatchType { get; }
    public int FilterOffset { get; }
    public int TryLength { get; }
    public int TryOffset { get; }
    public MethodBodyExceptionHandler(ExceptionHandlerType type, int tryOffset, int tryLength, int filterOffset, IMetadataType catchType, int handlerOffset, int handlerLength);
    public sealed virtual ExceptionHandlerType get_Type();
    public sealed virtual int get_HandlerLength();
    public sealed virtual int get_HandlerOffset();
    public sealed virtual IMetadataType get_CatchType();
    public sealed virtual int get_FilterOffset();
    public sealed virtual int get_TryLength();
    public sealed virtual int get_TryOffset();
}
internal class JetBrains.Metadata.Reader.Impl.MethodBodyLocalVariable : object {
    private int myIndex;
    private IMetadataMethod myMethod;
    private IMetadataType myType;
    public IMetadataMethod Method { get; }
    public int Index { get; }
    public IMetadataType Type { get; }
    public bool Pinned { get; }
    public MethodBodyLocalVariable(IMetadataMethod method, int index, IMetadataType type);
    public virtual string ToString();
    public sealed virtual IMetadataMethod get_Method();
    public sealed virtual int get_Index();
    public sealed virtual IMetadataType get_Type();
    public sealed virtual bool get_Pinned();
}
internal class JetBrains.Metadata.Reader.Impl.MethodBodyUsagesFinder : object {
    private IMetadataAssembly myAssembly;
    private ImageBodyReader myBodyReader;
    private PEFile myPeFile;
    private ChunkHashMap`2<int, MetadataToken> myMethodsOffsets;
    private UnmanagedBlock myUnmanagedBlock;
    private LifetimeDefinition myLifetimeDefinition;
    [CompilerGeneratedAttribute]
private static Func`2<IMetadataField, bool> CS$<>9__CachedAnonymousMethodDelegate5;
    [CompilerGeneratedAttribute]
private static Func`2<IMetadataMethod, MethodUsageCount> CS$<>9__CachedAnonymousMethodDelegate6;
    public MethodBodyUsagesFinder(IMetadataAssembly assembly);
    public sealed virtual IReadOnlyList`1<MethodUsageCount> FindUsagesOf(IMetadataMethod method);
    public sealed virtual IReadOnlyList`1<MethodUsageCount> FindUsagesOf(IMetadataField field);
    public sealed virtual IReadOnlyList`1<MethodUsageCount> FindUsagesOf(IMetadataTypeInfo typeInfo);
    public sealed virtual IReadOnlyList`1<MethodUsageCount> FindUsagesOf(MetadataToken userStringToken, string userString);
    public sealed virtual IReadOnlyList`1<MethodUsageCount> FindDefaultConstructorUsagesOfValueType(IMetadataTypeInfo typeInfo);
    public sealed virtual void Dispose();
    private IEnumerable`1<MetadataToken> GetMethodsPossiblyContains(IEnumerable`1<MetadataToken> tokens);
    private static bool IsMethodsEqual(IMetadataMethod method1, IMetadataMethod method2);
    private static bool IsFieldsEqual(IMetadataField field1, IMetadataField field2);
    private int GetMethodReferencesCount(IMetadataMethod method, IMetadataMethod searchFor);
    private bool IsMethodReferencesType(IMetadataMethod method, IMetadataTypeInfo searchFor);
    private static bool IsStaticOrConstructor(IMetadataMethod method);
    private static bool IsMethodInstantiationReferencesType(MethodInstantiation methodInstantiation, IMetadataTypeInfo searchFor);
    private static bool IsMethodSpecificationReferencesType(MethodSpecification methodSpecification, IMetadataTypeInfo searchFor);
    private static int IndexOf(UnmanagedBlock array, UInt32 value, int startOffset);
    private int GetFieldReferencesCount(IMetadataMethod method, IMetadataField searchFor);
    private int GetStringReferencesCount(IMetadataMethod method, string searchFor);
    private int GetDefaultConstructorOfValueTypeReferencesCount(IMetadataMethod method, IMetadataTypeInfo searchFor);
    private ChunkHashMap`2<int, MetadataToken> GetMethodsOffsets();
    private static bool TypeHasTypeInfo(IMetadataType type, IMetadataTypeInfo searchFor);
    [CompilerGeneratedAttribute]
private IMetadataMethod <FindUsagesOf>b__0(MetadataToken x);
    [CompilerGeneratedAttribute]
private static bool <FindUsagesOf>b__1(IMetadataField f);
    [CompilerGeneratedAttribute]
private IMetadataMethod <FindUsagesOf>b__2(MetadataToken x);
    [CompilerGeneratedAttribute]
private static MethodUsageCount <FindUsagesOf>b__4(IMetadataMethod method);
    [CompilerGeneratedAttribute]
private IMetadataMethod <FindUsagesOf>b__9(MetadataToken x);
    [CompilerGeneratedAttribute]
private IMetadataMethod <FindDefaultConstructorUsagesOfValueType>b__a(MetadataToken x);
}
public static class JetBrains.Metadata.Reader.Impl.MethodDebugInformationBlobDecoder : object {
    public static IList`1<SequencePoint> DecodeSequencePoints(UInt32 documentIndex, IBlob blob);
    public static MetadataToken DecodeLocalSignature(IBlob blob);
}
public static class JetBrains.Metadata.Reader.Impl.MethodSignatureBlobDecoder : object {
    public static TSig DecodeBlob(IBinaryReader reader, IMethodSignatureBuilder`2<TType, TSig> builder);
}
public class JetBrains.Metadata.Reader.Impl.ParsedClrTypeName : ClrTypeNameBase {
    private static String[] ourTypeParametersStrings;
    private static int ourTypeParametersStringsCount;
    private String[] myNamespaces;
    private TypeNameAndTypeParameterNumber[] myTypes;
    public string ShortName { get; }
    public int TypeParametersCount { get; }
    public string FullName { get; }
    public IEnumerable`1<string> NamespaceNames { get; }
    public IEnumerable`1<TypeNameAndTypeParameterNumber> TypeNames { get; }
    public ParsedClrTypeName(String[] namespaces, TypeNameAndTypeParameterNumber[] types);
    private static ParsedClrTypeName();
    public static string BuildFullName(String[] namespaces, TypeNameAndTypeParameterNumber[] types);
    public virtual IClrTypeName GetPersistent();
    public virtual string get_ShortName();
    public virtual int get_TypeParametersCount();
    public virtual string get_FullName();
    public virtual IEnumerable`1<string> get_NamespaceNames();
    public virtual IEnumerable`1<TypeNameAndTypeParameterNumber> get_TypeNames();
    public virtual IClrTypeNamePartIterator GetPartIterator();
    public virtual string GetFullNameFast();
    public virtual int GetPartsCount();
}
internal static class JetBrains.Metadata.Reader.Impl.PermissionSetBlobDecoder : object {
    [CompilerGeneratedAttribute]
private static Func`2<byte, bool> CS$<>9__CachedAnonymousMethodDelegate1;
    [CompilerGeneratedAttribute]
private static Func`2<IMetadataProperty, bool> CS$<>9__CachedAnonymousMethodDelegate3;
    public static IMetadataSecurityAttribute[] DecodeBlob(IBlob blob, IMetadataSecurityRow context);
    [CanBeNullAttribute]
private static Byte[] ReadArguments(IBinaryReader reader, int attributeBlobStartPosition, int attributeBlobEndPosition, bool altFormat, CustomAttributeBlobDecoder customAttributeBlobDecoder, List`1<IMetadataCustomAttributeFieldInitialization> fields, List`1<IMetadataCustomAttributePropertyInitialization> properties);
    [CanBeNullAttribute]
private static Byte[] GetConstructorArgumentsBlob(IBinaryReader reader, int fromPosition, int toPosition);
    private static IMetadataSecurityAttribute[] DecodeBlob10(IBlob blob, IMetadataSecurityRow context);
    [CompilerGeneratedAttribute]
private static bool <DecodeBlob>b__0(byte b);
    [CompilerGeneratedAttribute]
private static bool <DecodeBlob10>b__2(IMetadataProperty x);
}
public class JetBrains.Metadata.Reader.Impl.PresentingMethodSignatureBuilder : object {
    private Func`2<MetadataToken, string> myTypeTokenPresenter;
    public PresentingMethodSignatureBuilder(Func`2<MetadataToken, string> typeTokenPresenter);
    public sealed virtual ITypeBuilder`2<string, string> GetTypeBuilder(UInt32 methodGenericArgumentsCount);
    public sealed virtual string BuildMethodSignature(bool isVararg, bool hasThis, UInt32 genericArgumentsCount, string returnType, String[] parameterTypes, String[] varargParameterTypes);
}
public class JetBrains.Metadata.Reader.Impl.PresentingTypeBuilder : object {
    private Func`2<MetadataToken, string> myTypeTokenPresenter;
    public IMethodSignatureBuilder`2<string, string> MethodSignatureBuilder { get; }
    public PresentingTypeBuilder(Func`2<MetadataToken, string> typeTokenPresenter);
    public sealed virtual IMethodSignatureBuilder`2<string, string> get_MethodSignatureBuilder();
    public sealed virtual string BuildWellKnownType(ElementType type);
    public sealed virtual string BuildPointerType(string type);
    public sealed virtual string BuildReferenceType(string type);
    public sealed virtual string BuildClassType(MetadataToken typeDefOrRefOrSpecToken);
    public sealed virtual string BuildGenericInst(string type, String[] args);
    public sealed virtual string BuildTypeGenericArgument(UInt32 index);
    public sealed virtual string BuildMethodGenericArgument(UInt32 index);
    public sealed virtual string BuildFunctionPointer(string fnsig);
    public sealed virtual string BuildArrayType(string elementType, UInt32 rank, UInt32[] sizes, Int32[] lBounds);
    public sealed virtual string BuildArrayType(string elementType);
    public sealed virtual string AddRequiredModifier(string type, string modifier);
    public sealed virtual string AddOptionalModifier(string type, string modifier);
    public sealed virtual string AddPinnedConstraint(string type);
    public sealed virtual string BuildUndecodedType();
}
public static class JetBrains.Metadata.Reader.Impl.PropertySignatureBlobDecoder : object {
    public static TPropertySignature DecodePropertySignature(IBlob signature, IMethodSignatureBuilder`2<TType, TPropertySignature> builder);
}
internal class JetBrains.Metadata.Reader.Impl.SecurityUtil : object {
    public static IMetadataSecurityRow[] ConstructRowsFromOwner(IMetadataAssembly assembly, MetadataToken owner);
    public static String[] GetSecurityAttributesTypeNames(IMetadataEntity entity);
}
public static class JetBrains.Metadata.Reader.Impl.TypeBlobDecoder : object {
    public static TType DecodeType(IBinaryReader reader, ITypeBuilder`2<TType, TMethodSig> typeBuilder);
    private static T DecodeTypeDefOrRef(IBinaryReader reader, ITypeBuilder`2<T, TMethodSig> typeBuilder);
    private static T DecodeModOpt(IBinaryReader reader, ITypeBuilder`2<T, TMethodSig> typeBuilder);
    private static T DecodeModReq(IBinaryReader reader, ITypeBuilder`2<T, TMethodSig> typeBuilder);
    private static T DecodeGenericInstance(IBinaryReader reader, ITypeBuilder`2<T, TMethodSig> typeBuilder);
    private static T DecodeArrayType(IBinaryReader reader, ITypeBuilder`2<T, TMethodSig> typeBuilder);
}
internal class JetBrains.Metadata.Reader.Impl.UnknownMetadataType : MetadataTypeBase {
    public static UnknownMetadataType UndecodedType;
    private string myComment;
    public bool IsResolved { get; }
    public string FullName { get; }
    public string AssemblyQualification { get; }
    public IMetadataTypeInfo Type { get; }
    public IMetadataType[] Arguments { get; }
    private UnknownMetadataType(string comment);
    private static UnknownMetadataType();
    public virtual bool get_IsResolved();
    public virtual void Accept(IMetadataTypeVisitor visitor);
    public virtual IMetadataType Transform(IMetadataTypeTransformer transformer);
    public virtual string get_FullName();
    public virtual string get_AssemblyQualification();
    public sealed virtual IMetadataTypeInfo get_Type();
    public sealed virtual IMetadataType[] get_Arguments();
}
public class JetBrains.Metadata.Reader.Impl.UnresolvedField : UnresolvedMetadataEntity {
    private IMetadataTypeInfo myDeclaringType;
    private string myName;
    private IMetadataType myType;
    public string Name { get; }
    public IMetadataType Type { get; }
    public IMetadataTypeInfo DeclaringType { get; }
    public IBlob MarshalSpec { get; }
    public int Offset { get; }
    public FieldSignature Signature { get; }
    public UInt32 InitialValueRva { get; }
    public bool IsAssembly { get; }
    public bool IsPrivate { get; }
    public bool IsPublic { get; }
    public bool IsFamily { get; }
    public bool IsFamilyAndAssembly { get; }
    public bool IsFamilyOrAssembly { get; }
    public bool IsSpecialName { get; }
    public bool IsRuntimeSpecialName { get; }
    public bool IsStatic { get; }
    public bool IsInitOnly { get; }
    public bool IsLiteral { get; }
    public bool HasMarshalSpec { get; }
    public bool NotSerialized { get; }
    public UnresolvedField(IMetadataTypeInfo declaringType, string name, IMetadataType type);
    public UnresolvedField(IMetadataTypeInfo declaringType, string name);
    public sealed virtual string get_Name();
    public sealed virtual IMetadataType get_Type();
    public sealed virtual IMetadataTypeInfo get_DeclaringType();
    public sealed virtual IBlob get_MarshalSpec();
    public sealed virtual object GetLiteralValue();
    public sealed virtual IBlob GetLiteralValueBlob();
    public sealed virtual int get_Offset();
    public sealed virtual FieldSignature get_Signature();
    public sealed virtual UInt32 get_InitialValueRva();
    public sealed virtual bool get_IsAssembly();
    public sealed virtual bool get_IsPrivate();
    public sealed virtual bool get_IsPublic();
    public sealed virtual bool get_IsFamily();
    public sealed virtual bool get_IsFamilyAndAssembly();
    public sealed virtual bool get_IsFamilyOrAssembly();
    public sealed virtual bool get_IsSpecialName();
    public sealed virtual bool get_IsRuntimeSpecialName();
    public sealed virtual bool get_IsStatic();
    public sealed virtual bool get_IsInitOnly();
    public sealed virtual bool get_IsLiteral();
    public sealed virtual bool get_HasMarshalSpec();
    public sealed virtual bool get_NotSerialized();
    public virtual int GetHashCode();
    public virtual string ToString();
    public virtual bool Equals(IMetadataEntity other);
}
public class JetBrains.Metadata.Reader.Impl.UnresolvedGenericArgument : UnresolvedMetadataEntity {
    private UInt32 myIndex;
    private GenericArgumentKind myKind;
    private IMetadataTypeInfo myTypeOwner;
    private IMetadataMethod myMethodOwner;
    public GenericArgumentKind Kind { get; }
    public string Name { get; }
    public UInt32 Index { get; }
    public IMetadataTypeInfo TypeOwner { get; }
    public IMetadataMethod MethodOwner { get; }
    public IMetadataType[] TypeConstraints { get; }
    public GenericArgumentAttributes Attributes { get; }
    public UnresolvedGenericArgument(UInt32 index, GenericArgumentKind kind);
    public UnresolvedGenericArgument(UInt32 index, IMetadataTypeInfo typeOwner);
    public UnresolvedGenericArgument(UInt32 index, IMetadataMethod method);
    public sealed virtual GenericArgumentKind get_Kind();
    public sealed virtual string get_Name();
    public sealed virtual UInt32 get_Index();
    public sealed virtual IMetadataTypeInfo get_TypeOwner();
    public sealed virtual IMetadataMethod get_MethodOwner();
    public sealed virtual IMetadataType[] get_TypeConstraints();
    public sealed virtual GenericArgumentAttributes get_Attributes();
    public virtual int GetHashCode();
    public virtual string ToString();
    public virtual bool Equals(IMetadataEntity other);
}
public abstract class JetBrains.Metadata.Reader.Impl.UnresolvedMetadataEntity : object {
    private IMetadataAssembly myAssembly;
    public IMetadataAssembly Assembly { get; }
    public MetadataToken Token { get; }
    public IMetadataCustomAttribute[] CustomAttributes { get; }
    public MetadataTypeReference[] CustomAttributesTypeNames { get; }
    public bool IsResolved { get; }
    protected UnresolvedMetadataEntity(IMetadataAssembly assembly);
    public sealed virtual IMetadataAssembly get_Assembly();
    public sealed virtual MetadataToken get_Token();
    public sealed virtual IMetadataCustomAttribute[] get_CustomAttributes();
    public sealed virtual MetadataTypeReference[] get_CustomAttributesTypeNames();
    public sealed virtual IList`1<IMetadataCustomAttribute> GetCustomAttributes(string attributeClassFullyQualifiedName);
    public sealed virtual bool HasCustomAttribute(string attributeClassFullyQualifiedName);
    public sealed virtual bool get_IsResolved();
    public abstract virtual bool Equals(IMetadataEntity other);
    public abstract virtual int GetHashCode();
    public abstract virtual string ToString();
    public virtual bool Equals(object obj);
}
public class JetBrains.Metadata.Reader.Impl.UnresolvedMethod : UnresolvedMetadataEntity {
    private IMetadataTypeInfo myDeclaringType;
    private IMetadataParameter[] myParameters;
    private IMetadataReturnValue myReturnValue;
    private MethodSignature mySignature;
    private string myName;
    public string Name { get; }
    public IMetadataTypeInfo DeclaringType { get; }
    public IMetadataReturnValue ReturnValue { get; }
    public IMetadataParameter[] Parameters { get; }
    public IMetadataGenericArgument[] GenericArguments { get; }
    public IList`1<MethodSpecification> ImplementedMethods { get; }
    public MethodSignature Signature { get; }
    public PInvokeInfo PInvokeInfo { get; }
    public CorMethodImpl MethodImplFlags { get; }
    public IMetadataSecurityRow[] Security { get; }
    public String[] SecurityAttributesTypeName { get; }
    public bool IsPInvokeImpl { get; }
    public bool HasSecurity { get; }
    public CodeType CodeType { get; }
    public UInt32 CodeRva { get; }
    public bool IsForwardRef { get; }
    public bool IsPreserveSig { get; }
    public bool IsInternalCall { get; }
    public bool IsSynchronized { get; }
    public bool NoInlining { get; }
    public bool AggressiveInlining { get; }
    public bool NoOptimization { get; }
    public bool IsAssembly { get; }
    public bool IsPrivate { get; }
    public bool IsPublic { get; }
    public bool IsFamily { get; }
    public bool IsFamilyAndAssembly { get; }
    public bool IsFamilyOrAssembly { get; }
    public bool IsSpecialName { get; }
    public bool IsRuntimeSpecialName { get; }
    public bool IsStatic { get; }
    public bool IsAbstract { get; }
    public bool IsExtern { get; }
    public bool IsVirtual { get; }
    public bool IsFinal { get; }
    public bool IsHideBySig { get; }
    public bool IsNewSlot { get; }
    public bool IsStrict { get; }
    public bool IsVarArg { get; }
    public bool IsUnmanaged { get; }
    public UnresolvedMethod(IMetadataTypeInfo declaringType, string name, MethodSignature signature);
    public sealed virtual string get_Name();
    public sealed virtual IMetadataTypeInfo get_DeclaringType();
    public sealed virtual IMetadataReturnValue get_ReturnValue();
    public sealed virtual IMetadataParameter[] get_Parameters();
    public sealed virtual IMetadataGenericArgument[] get_GenericArguments();
    public sealed virtual IList`1<MethodSpecification> get_ImplementedMethods();
    public sealed virtual MethodSignature get_Signature();
    public sealed virtual PInvokeInfo get_PInvokeInfo();
    public sealed virtual CorMethodImpl get_MethodImplFlags();
    public sealed virtual IMetadataSecurityRow[] get_Security();
    public sealed virtual String[] get_SecurityAttributesTypeName();
    public sealed virtual bool get_IsPInvokeImpl();
    public sealed virtual bool get_HasSecurity();
    public sealed virtual CodeType get_CodeType();
    public sealed virtual UInt32 get_CodeRva();
    public sealed virtual bool get_IsForwardRef();
    public sealed virtual bool get_IsPreserveSig();
    public sealed virtual bool get_IsInternalCall();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual bool get_NoInlining();
    public sealed virtual bool get_AggressiveInlining();
    public sealed virtual bool get_NoOptimization();
    public sealed virtual bool get_IsAssembly();
    public sealed virtual bool get_IsPrivate();
    public sealed virtual bool get_IsPublic();
    public sealed virtual bool get_IsFamily();
    public sealed virtual bool get_IsFamilyAndAssembly();
    public sealed virtual bool get_IsFamilyOrAssembly();
    public sealed virtual bool get_IsSpecialName();
    public sealed virtual bool get_IsRuntimeSpecialName();
    public sealed virtual bool get_IsStatic();
    public sealed virtual bool get_IsAbstract();
    public sealed virtual bool get_IsExtern();
    public sealed virtual bool get_IsVirtual();
    public sealed virtual bool get_IsFinal();
    public sealed virtual bool get_IsHideBySig();
    public sealed virtual bool get_IsNewSlot();
    public sealed virtual bool get_IsStrict();
    public sealed virtual bool get_IsVarArg();
    public sealed virtual bool get_IsUnmanaged();
    public virtual bool Equals(IMetadataEntity other);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class JetBrains.Metadata.Reader.Impl.UnresolvedParameter : UnresolvedMetadataEntity {
    private IMetadataMethod myDeclaringMethod;
    private IMetadataType myType;
    private string myName;
    public string Name { get; }
    public IMetadataType Type { get; }
    public IMetadataMethod DeclaringMethod { get; }
    public IBlob MarshalSpec { get; }
    public bool IsIn { get; }
    public bool IsOut { get; }
    public bool IsParamArray { get; }
    public bool IsOptional { get; }
    public bool HasMarshalSpec { get; }
    public bool HasDefaultValue { get; }
    public UnresolvedParameter(IMetadataType type, IMetadataMethod declaringMethod, int index);
    public sealed virtual string get_Name();
    public sealed virtual IMetadataType get_Type();
    public sealed virtual IMetadataMethod get_DeclaringMethod();
    public sealed virtual IBlob get_MarshalSpec();
    public sealed virtual bool get_IsIn();
    public sealed virtual bool get_IsOut();
    public sealed virtual bool get_IsParamArray();
    public sealed virtual bool get_IsOptional();
    public sealed virtual bool get_HasMarshalSpec();
    public sealed virtual bool get_HasDefaultValue();
    public sealed virtual object GetDefaultValue();
    public sealed virtual IBlob GetDefaultValueBlob();
    public virtual bool Equals(IMetadataEntity other);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class JetBrains.Metadata.Reader.Impl.UnresolvedProperty : UnresolvedMetadataEntity {
    private IMetadataTypeInfo myDeclaringType;
    private string myName;
    public string Name { get; }
    public IMetadataType Type { get; }
    public IMetadataTypeInfo DeclaringType { get; }
    public IMetadataMethod Getter { get; }
    public IMetadataMethod Setter { get; }
    public IMetadataMethod[] OtherAccessors { get; }
    public bool IsSpecialName { get; }
    public bool IsRuntimeSpecialName { get; }
    public UnresolvedProperty(IMetadataTypeInfo declaringType, string name);
    public virtual bool Equals(IMetadataEntity other);
    public virtual int GetHashCode();
    public sealed virtual string get_Name();
    public sealed virtual IMetadataType get_Type();
    public sealed virtual IMetadataTypeInfo get_DeclaringType();
    public sealed virtual IMetadataMethod get_Getter();
    public sealed virtual IMetadataMethod get_Setter();
    public sealed virtual IMetadataMethod[] get_OtherAccessors();
    public sealed virtual bool get_IsSpecialName();
    public sealed virtual bool get_IsRuntimeSpecialName();
    public virtual string ToString();
}
public class JetBrains.Metadata.Reader.Impl.UnresolvedReturnValue : UnresolvedMetadataEntity {
    private IMetadataMethod myDeclaringMethod;
    private IMetadataType myType;
    public IMetadataMethod DeclaringMethod { get; }
    public IMetadataType Type { get; }
    public IBlob MarshalSpec { get; }
    public bool HasMarshalSpec { get; }
    public UnresolvedReturnValue(IMetadataMethod declaringMethod, IMetadataType type);
    public sealed virtual IMetadataMethod get_DeclaringMethod();
    public sealed virtual IMetadataType get_Type();
    public sealed virtual IBlob get_MarshalSpec();
    public sealed virtual bool get_HasMarshalSpec();
    public virtual bool Equals(IMetadataEntity other);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class JetBrains.Metadata.Reader.Impl.UnresolvedTypeInfo : UnresolvedMetadataEntity {
    private string myFullyQualifiedName;
    private AssemblyNameInfo myAssemblyName;
    private IMetadataGenericArgument[] myGenericArguments;
    public string FullyQualifiedName { get; }
    public string AssemblyQualifiedName { get; }
    public string NamespaceName { get; }
    public string TypeName { get; }
    public string Name { get; }
    public AssemblyNameInfo DeclaringAssemblyName { get; }
    public IMetadataClassType Base { get; }
    public IMetadataTypeInfo DeclaringType { get; }
    public IMetadataClassType[] Interfaces { get; }
    public IMetadataGenericArgument[] GenericParameters { get; }
    public bool IsAbstract { get; }
    public bool IsSealed { get; }
    public bool IsImported { get; }
    public ClassLayoutType Layout { get; }
    public CharSetSpec InteropStringFormat { get; }
    public bool IsSpecialName { get; }
    public bool IsRuntimeSpecialName { get; }
    public bool IsBeforeFieldInit { get; }
    public bool IsClass { get; }
    public bool IsInterface { get; }
    public bool IsSerializable { get; }
    public bool IsWindowsRuntime { get; }
    public bool IsPublic { get; }
    public bool IsNotPublic { get; }
    public bool IsNested { get; }
    public bool IsNestedPublic { get; }
    public bool IsNestedPrivate { get; }
    public bool IsNestedFamily { get; }
    public bool IsNestedAssembly { get; }
    public bool IsNestedFamilyAndAssembly { get; }
    public bool IsNestedFamilyOrAssembly { get; }
    public int PackingSize { get; }
    public int ClassSize { get; }
    public String[] SecurityAttributesTypeName { get; }
    public bool HasSecurity { get; }
    public IMetadataSecurityRow[] Security { get; }
    public UnresolvedTypeInfo(string fullyQualifiedName);
    public UnresolvedTypeInfo(string fullyQualifiedName, AssemblyNameInfo assemblyName);
    public sealed virtual string get_FullyQualifiedName();
    public sealed virtual string get_AssemblyQualifiedName();
    public sealed virtual string get_NamespaceName();
    public sealed virtual string get_TypeName();
    public sealed virtual string get_Name();
    public sealed virtual AssemblyNameInfo get_DeclaringAssemblyName();
    public sealed virtual IMetadataClassType get_Base();
    public sealed virtual IMetadataTypeInfo get_DeclaringType();
    public sealed virtual IMetadataClassType[] get_Interfaces();
    public sealed virtual IMetadataGenericArgument[] get_GenericParameters();
    public sealed virtual bool get_IsAbstract();
    public sealed virtual bool get_IsSealed();
    public sealed virtual bool get_IsImported();
    public sealed virtual ClassLayoutType get_Layout();
    public sealed virtual CharSetSpec get_InteropStringFormat();
    public sealed virtual bool get_IsSpecialName();
    public sealed virtual bool get_IsRuntimeSpecialName();
    public sealed virtual bool get_IsBeforeFieldInit();
    public sealed virtual bool get_IsClass();
    public sealed virtual bool get_IsInterface();
    public sealed virtual bool get_IsSerializable();
    public sealed virtual bool get_IsWindowsRuntime();
    public sealed virtual bool get_IsPublic();
    public sealed virtual bool get_IsNotPublic();
    public sealed virtual bool get_IsNested();
    public sealed virtual bool get_IsNestedPublic();
    public sealed virtual bool get_IsNestedPrivate();
    public sealed virtual bool get_IsNestedFamily();
    public sealed virtual bool get_IsNestedAssembly();
    public sealed virtual bool get_IsNestedFamilyAndAssembly();
    public sealed virtual bool get_IsNestedFamilyOrAssembly();
    public sealed virtual int get_PackingSize();
    public sealed virtual int get_ClassSize();
    public sealed virtual IEnumerable`1<MemberInfo> GetMemberInfos();
    public sealed virtual String[] get_SecurityAttributesTypeName();
    public sealed virtual bool get_HasSecurity();
    public sealed virtual IMetadataSecurityRow[] get_Security();
    public sealed virtual IMetadataMethod[] GetMethods();
    public sealed virtual bool HasExtensionMethods();
    public sealed virtual IMetadataField[] GetFields();
    public sealed virtual IMetadataProperty[] GetProperties();
    public sealed virtual IMetadataEvent[] GetEvents();
    public sealed virtual IMetadataTypeInfo[] GetNestedTypes();
    public virtual bool Equals(IMetadataEntity other);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class JetBrains.Metadata.Utils.AssemblyItem : object {
    [NotNullAttribute]
public AssemblyNameInfo AssemblyName;
    [NotNullAttribute]
public SimpleFileItem File;
    [CanBeNullAttribute]
public SimpleFileItem ProgramDatabase;
    [CanBeNullAttribute]
public SimpleFileItem XmlDocumentation;
    [CompilerGeneratedAttribute]
private static Func`2<IStructuredStorage, SimpleFileItem> CS$<>9__CachedAnonymousMethodDelegate2;
    [CompilerGeneratedAttribute]
private static Func`2<IStructuredStorage, SimpleFileItem> CS$<>9__CachedAnonymousMethodDelegate3;
    private AssemblyNameInfo JetBrains.Metadata.Utils.IAssemblyItem.AssemblyName { get; }
    private SimpleFileItem JetBrains.Metadata.Utils.IAssemblyItem.File { get; }
    private SimpleFileItem JetBrains.Metadata.Utils.IAssemblyItem2.ProgramDatabase { get; }
    private SimpleFileItem JetBrains.Metadata.Utils.IAssemblyItem2.XmlDocumentation { get; }
    public AssemblyItem(AssemblyNameInfo assemblyName, SimpleFileItem file, SimpleFileItem programDatabase, SimpleFileItem xmlDocumentation);
    public AssemblyItem(IStructuredStorage storage);
    [NotNullAttribute]
public static AssemblyItem CreateAndReadAssemblyName(SimpleFileItem file);
    public virtual string ToString();
    [CanBeNullAttribute]
public static AssemblyItem TryCreateAndReadAssemblyName(SimpleFileItem file);
    private sealed virtual override AssemblyNameInfo JetBrains.Metadata.Utils.IAssemblyItem.get_AssemblyName();
    private sealed virtual override SimpleFileItem JetBrains.Metadata.Utils.IAssemblyItem.get_File();
    private sealed virtual override void JetBrains.Util.Storage.StructuredStorage.IStructuredStorageSerializable.GetObjectData(IStructuredStorage storage);
    private sealed virtual override SimpleFileItem JetBrains.Metadata.Utils.IAssemblyItem2.get_ProgramDatabase();
    private sealed virtual override SimpleFileItem JetBrains.Metadata.Utils.IAssemblyItem2.get_XmlDocumentation();
    [CompilerGeneratedAttribute]
private static SimpleFileItem <.ctor>b__0(IStructuredStorage sstg);
    [CompilerGeneratedAttribute]
private static SimpleFileItem <.ctor>b__1(IStructuredStorage sstg);
}
[ExtensionAttribute]
public static class JetBrains.Metadata.Utils.AssemblyNameMetadataExtensions : object {
    [CompilerGeneratedAttribute]
private static Func`2<FileSystemPath, bool> CS$<>9__CachedAnonymousMethodDelegate12;
    [ExtensionAttribute]
[ContractAnnotationAttribute("failIfNotFound:true=>notnull")]
[CanBeNullAttribute]
public static FileSystemPath FindAssemblyFile(FileSystemPath pathFolder, AssemblyNameInfo shortAssemblyName, bool failIfNotFound);
    [ContractAnnotationAttribute("failIfNotFound:true=>notnull")]
[CanBeNullAttribute]
[ExtensionAttribute]
public static FileSystemPath FindAssemblyFile(FileSystemPath pathFolder, string shortAssemblyName, bool failIfNotFound);
    [CompilerGeneratedAttribute]
private static bool <FindAssemblyFile>b__2(FileSystemPath path);
}
public class JetBrains.Metadata.Utils.AssemblyNameReader : object {
    private StreamsManager myStreamsManager;
    internal AssemblyNameReader(StreamsManager streamsManager);
    public Guid GetMvid();
    public void GetModuleNameAndMvid(Guid& mvid, String& moduleName);
    public AssemblyNameInfo GetAssemblyName();
    internal Dictionary`2<MetadataToken, string> GetModuleRefs();
    internal IEnumerable`1<KeyValuePair`2<MetadataToken, AssemblyNameInfo>> GetReferences();
    private AssemblyNameInfo CreateAssemblyName(int name, Version version, int pubKeyTokenToken, int culture, UInt32 flags, AssemblyHashAlgorithm hashAlgID);
    [CanBeNullAttribute]
public static AssemblyNameReader CreateReader(IBinaryReader reader, string imageMoniker);
    [CanBeNullAttribute]
public static AssemblyNameInfo GetAssemblyNameRaw(FileSystemPath path);
    [CanBeNullAttribute]
private static AssemblyInfo ReadAssemblyInfo(Stream stream, string moniker);
    [CanBeNullAttribute]
public static AssemblyInfo GetAssemblyInfoRaw(FileSystemPath path);
    [CanBeNullAttribute]
public static AssemblyInfo GetAssemblyInfoIgnoreExceptions(FileSystemPath path);
    [CanBeNullAttribute]
public static AssemblyInfo GetAssemblyInfo(Stream stream);
}
public class JetBrains.Metadata.Utils.AssemblyResolver : object {
    protected Func`2<AssemblyNameInfo, bool> myPredicate;
    protected List`1<FileSystemPath> myBaseDirs;
    protected JetHashSet`1<AppDomain> myInstalledOn;
    public AssemblyResolver(IEnumerable`1<FileSystemPath> basedirs);
    public AssemblyResolver(IEnumerable`1<FileSystemPath> basedirs, Func`2<AssemblyNameInfo, bool> predicate);
    public static AssemblyResolver FromAssembly(Assembly assembly, Func`2<AssemblyNameInfo, bool> predicate);
    public void Install(AppDomain appDomain);
    public void Uninstall(AppDomain appDomain);
    [CanBeNullAttribute]
private Assembly Resolve(object sender, ResolveEventArgs args);
    protected virtual void Finalize();
    public sealed virtual void Dispose();
}
[ExtensionAttribute]
public static class JetBrains.Metadata.Utils.BinaryBlobExtensions : object {
    [ExtensionAttribute]
public static bool IsEmpty(IBlob blob);
    [ExtensionAttribute]
public static Byte[] ReadBytes(IBlob blob, int offset, int count);
    [ExtensionAttribute]
public static Byte[] ToArray(IBlob blob);
    [ExtensionAttribute]
public static bool CanReadBytes(IBlob blob, int offset, int count);
    [ExtensionAttribute]
public static string ReadStringUtf8(IBlob blob, int offset);
    [ExtensionAttribute]
public static sbyte ReadSByte(IBlob blob, int offset);
    [ExtensionAttribute]
public static byte ReadUInt8(IBlob blob, int offset);
    [ExtensionAttribute]
public static short ReadInt16(IBlob blob, int offset);
    [ExtensionAttribute]
public static int ReadInt32(IBlob blob, int offset);
    [ExtensionAttribute]
public static long ReadInt64(IBlob blob, int offset);
    [ExtensionAttribute]
public static UInt32 ReadCompressedInteger(IBlob blob, int offset);
    [ExtensionAttribute]
public static MetadataToken ReadTypeDefOrTypeRefEncoded(IBlob blob, int offset);
}
public class JetBrains.Metadata.Utils.BinaryBlobReader : object {
    private IBlob myBlob;
    private int myLength;
    private int myPosition;
    public int Position { get; public set; }
    public int Length { get; }
    public BinaryBlobReader(IBlob blob);
    private BinaryBlobReader(BinaryBlobReader reader);
    public BinaryBlobReader(IBlob blob, int initialPosition);
    public sealed virtual int get_Position();
    public sealed virtual void set_Position(int value);
    public sealed virtual int get_Length();
    [NotNullAttribute]
private sealed virtual override IBinaryReader JetBrains.Metadata.Utils.IBinaryReader.Clone();
    public sealed virtual char ReadChar();
    public sealed virtual float ReadSingle();
    public sealed virtual double ReadDouble();
    public sealed virtual short ReadInt16();
    public sealed virtual sbyte ReadSByte();
    public sealed virtual byte ReadUInt8();
    public sealed virtual ushort ReadUInt16();
    public sealed virtual int ReadInt32();
    public sealed virtual UInt32 ReadUInt32();
    public sealed virtual long ReadInt64();
    public sealed virtual ulong ReadUInt64();
    public sealed virtual string ReadStringUtf8();
    public sealed virtual string ReadStringUtf16le(int cbLength);
    public sealed virtual void Read(Byte[] buffer, int offset, int count);
    public sealed virtual byte ReadByte();
    public sealed virtual UInt32 ReadCompressedInteger();
    public sealed virtual string ReadUtf8Constant();
    public sealed virtual void Skip(int bytes);
}
public class JetBrains.Metadata.Utils.BinaryBlobStream : Stream {
    private IBlob myBlob;
    private int myPosition;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public BinaryBlobStream(IBlob blob);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Flush();
    public virtual long Seek(long offset, SeekOrigin origin);
    private static void ThrowReadOnlyException();
    public virtual void SetLength(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Write(Byte[] buffer, int offset, int count);
}
[ExtensionAttribute]
public static class JetBrains.Metadata.Utils.BinaryReaderExtensions : object {
    [ExtensionAttribute]
public static bool Eof(IBinaryReader reader);
    [ExtensionAttribute]
public static void Align(IBinaryReader reader, int alignment);
    [ExtensionAttribute]
public static IDisposable Mark(IBinaryReader reader);
    [ExtensionAttribute]
public static Byte[] ReadBytes(IBinaryReader reader, int count);
    [ExtensionAttribute]
public static bool CanReadBytes(IBinaryReader reader, int count);
    [ExtensionAttribute]
public static MetadataToken ReadTypeDefOrTypeRefEncoded(IBinaryReader reader);
    [ExtensionAttribute]
public static int ReadCompressedSignedInteger(IBinaryReader reader);
    [ExtensionAttribute]
public static decimal ReadDecimal(IBinaryReader reader);
    [ExtensionAttribute]
public static string ReadBString(IBinaryReader reader);
    [ExtensionAttribute]
public static string ReadCString(IBinaryReader reader);
    [ExtensionAttribute]
public static Guid ReadGuid(IBinaryReader reader);
}
public class JetBrains.Metadata.Utils.BlobOnReader : object {
    private IBinaryReader myReader;
    private int myStartOffset;
    private int myLength;
    public int Length { get; }
    public BlobOnReader(IBinaryReader reader);
    private BlobOnReader(IBinaryReader reader, int startOffset, int length);
    public sealed virtual int get_Length();
    public sealed virtual IBlob Clone();
    public sealed virtual IBinaryReader CreateReader(int position);
    public sealed virtual IBlob Slice(int position, int length);
    public sbyte ReadSByte(int offset);
    public sealed virtual byte ReadByte(int offset);
    public byte ReadUInt8(int offset);
    public short ReadInt16(int offset);
    public sealed virtual ushort ReadUInt16(int offset);
    public sealed virtual UInt32 ReadUInt32(int offset);
    public sealed virtual ulong ReadUInt64(int offset);
    public sealed virtual void Read(int sourceOffset, Byte[] buffer, int bufferOffset, int count);
    public sealed virtual string ReadStringUtf8(int offset, Int32& bytesLen);
    public sealed virtual UInt32 ReadCompressedInteger(int offset, Int32& size);
    public sealed virtual string ReadUtf8Constant(int offset, Int32& len);
}
internal abstract class JetBrains.Metadata.Utils.CodeTextWriter.BaseCodeTextWriter : object {
    protected ICursorPositionStringBuilder Buffer;
    private bool myAtLineStart;
    [CompilerGeneratedAttribute]
private int <CurrentLineEstimatedLength>k__BackingField;
    [CompilerGeneratedAttribute]
private int <IndentSize>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IndentEmptyLines>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Indent>k__BackingField;
    public int CurrentLineEstimatedLength { get; protected set; }
    public int IndentSize { get; public set; }
    public bool IndentEmptyLines { get; public set; }
    public int Indent { get; public set; }
    protected BaseCodeTextWriter(ICursorPositionStringBuilder buffer);
    [CompilerGeneratedAttribute]
public sealed virtual int get_CurrentLineEstimatedLength();
    [CompilerGeneratedAttribute]
protected void set_CurrentLineEstimatedLength(int value);
    [CompilerGeneratedAttribute]
public int get_IndentSize();
    [CompilerGeneratedAttribute]
public void set_IndentSize(int value);
    [CompilerGeneratedAttribute]
public bool get_IndentEmptyLines();
    [CompilerGeneratedAttribute]
public void set_IndentEmptyLines(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_Indent();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Indent(int value);
    public sealed virtual void WriteText(string text);
    public sealed virtual void WriteNewLine();
    public abstract virtual void WriteTypeName(string namespaceName, string typeName);
    public abstract virtual void WriteMarker(ICodeMarker marker);
    public virtual string GetText();
    protected void IndentAtLineStart();
}
public class JetBrains.Metadata.Utils.CodeTextWriter.CodeTextWriterAdapter : object {
    private IndentedTextWriter myWriter;
    public int Indent { get; public set; }
    public CodeTextWriterAdapter(TextWriter writer, int indentSize);
    public sealed virtual int get_Indent();
    public sealed virtual void set_Indent(int value);
    public sealed virtual void WriteText(string text);
    public sealed virtual void WriteNewLine();
    public sealed virtual void WriteTypeName(string namespaceName, string typeName);
    public sealed virtual void WriteMarker(ICodeMarker marker);
}
[ExtensionAttribute]
public static class JetBrains.Metadata.Utils.CodeTextWriter.CodeTextWriterEx : object {
    [ExtensionAttribute]
public static ICodeTextWriter AppendText(ICodeTextWriter writer, string text);
    [ExtensionAttribute]
public static ICodeTextWriter AppendTextIf(ICodeTextWriter writer, string text, bool condition);
    [ExtensionAttribute]
public static ICodeTextWriter AppendDelimited(ICodeTextWriter writer, string delimiter, IEnumerable`1<T> items, Action`1<T> action);
    [ExtensionAttribute]
public static ICodeTextWriter AppendDelimited(ICodeTextWriter writer, string delimiter, IEnumerable`1<T> items, Action`2<T, ICodeTextWriter> action);
    [ExtensionAttribute]
[StringFormatMethodAttribute("format")]
public static ICodeTextWriter AppendText(ICodeTextWriter writer, string format, Object[] args);
    [ExtensionAttribute]
public static ICodeTextWriter AppendNewLine(ICodeTextWriter writer);
    [ExtensionAttribute]
public static ICodeTextWriter AppendNewLineIf(ICodeTextWriter writer, bool condition);
    [ExtensionAttribute]
public static IDisposable WithIncreaseIndent(ICodeTextWriter writer);
    [ExtensionAttribute]
public static IDisposable WithIncreaseIndent(ICodeTextWriter writer, int indentation);
    [ExtensionAttribute]
public static IDisposable WithSetIndent(ICodeTextWriter writer, int indent);
}
[ExtensionAttribute]
public static class JetBrains.Metadata.Utils.CodeTextWriter.ConflictingNamesHelper : object {
    [ExtensionAttribute]
public static HashSet`1<string> GetConflictingNames(IMetadataTypeInfo metadataTypeInfo);
}
internal class JetBrains.Metadata.Utils.CodeTextWriter.CursorPositionStringBuilder : object {
    private static char NewLineChar;
    private StringBuilder myStringBuilder;
    private int myCurrentLine;
    private int myCurrentColumn;
    public CursorPositionStringBuilder(int startLinesCount);
    public sealed virtual void Append(string s);
    public sealed virtual string GetText();
    public sealed virtual int GetCurrentLine();
    public sealed virtual int GetCurrentColumn();
}
public interface JetBrains.Metadata.Utils.CodeTextWriter.ICodeMarker {
}
public interface JetBrains.Metadata.Utils.CodeTextWriter.ICodeTextWriter {
    public int Indent { get; public set; }
    public abstract virtual int get_Indent();
    public abstract virtual void set_Indent(int value);
    public abstract virtual void WriteText(string text);
    public abstract virtual void WriteNewLine();
    public abstract virtual void WriteTypeName(string namespaceName, string typeName);
    public abstract virtual void WriteMarker(ICodeMarker marker);
}
public interface JetBrains.Metadata.Utils.CodeTextWriter.ICodeTextWriterWithLineLengthEstimation {
    public int CurrentLineEstimatedLength { get; }
    public abstract virtual int get_CurrentLineEstimatedLength();
}
internal interface JetBrains.Metadata.Utils.CodeTextWriter.ICursorPositionStringBuilder {
    public abstract virtual void Append(string s);
    public abstract virtual string GetText();
    public abstract virtual int GetCurrentLine();
    public abstract virtual int GetCurrentColumn();
}
public interface JetBrains.Metadata.Utils.CodeTextWriter.IPreRenderOptimizations {
    public abstract virtual OptimizeImportsResult Optimize(ICollection`1<IClrTypeName> referencedTypeNames);
}
public interface JetBrains.Metadata.Utils.CodeTextWriter.ITypesCache {
    public abstract virtual void AddTypes(IEnumerable`1<IClrTypeName> typeNames);
    public abstract virtual IEnumerable`1<string> GetNamespacesContainingTypeShortName(IClrTypeName typeName);
}
public class JetBrains.Metadata.Utils.CodeTextWriter.NoPreRenderOptimizations : object {
    public sealed virtual OptimizeImportsResult Optimize(ICollection`1<IClrTypeName> referencedTypeNames);
}
public class JetBrains.Metadata.Utils.CodeTextWriter.OptimizeImportsResult : object {
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <QualifiedTypeNameToPresentation>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <ImportedNamespaces>k__BackingField;
    public IDictionary`2<string, string> QualifiedTypeNameToPresentation { get; private set; }
    public String[] ImportedNamespaces { get; private set; }
    public OptimizeImportsResult(IDictionary`2<string, string> qualifiedTypeNameToPresentation, String[] importedNamespaces);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_QualifiedTypeNameToPresentation();
    [CompilerGeneratedAttribute]
private void set_QualifiedTypeNameToPresentation(IDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public String[] get_ImportedNamespaces();
    [CompilerGeneratedAttribute]
private void set_ImportedNamespaces(String[] value);
}
public static class JetBrains.Metadata.Utils.CodeTextWriter.OptimizeImportsUtil : object {
    [CompilerGeneratedAttribute]
private static Func`2<IClrTypeName, string> CS$<>9__CachedAnonymousMethodDelegate1;
    public static OptimizeImportsResult OptimizeImports(ITypesCache typesCache, IMetadataTypeInfo typeInfo, ICollection`1<IClrTypeName> types, bool projectionIsUsed);
    public static OptimizeImportsResult OptimizeImports(ITypesCache typesCache, string ownNamespace, ICollection`1<string> conflictingNames, ICollection`1<IClrTypeName> types, bool projectionIsUsed);
    private static void CollectAllShortNames(HashSet`1<string> shortNames, IEnumerable`1<string> namespaces);
    private static HashSet`1<string> GetParentNamespaces(string namespace);
    private static bool NamespaceIsGlobal(string namespaceName);
    private static string GetGlobalTypeName(string fqn);
    private static string GetFullTypeName(IClrTypeName typeName, string namespaceName, bool projectionIsUsed);
    [CompilerGeneratedAttribute]
private static string <OptimizeImports>b__0(IClrTypeName x);
}
public class JetBrains.Metadata.Utils.CodeTextWriter.PreRenderImportsOptimizations : object {
    private ITypesCache myTypesCache;
    private string myOwnNamespace;
    private ICollection`1<string> myConflictingNames;
    private bool myProjectionIsUsed;
    public PreRenderImportsOptimizations(bool projectionIsUsed);
    public PreRenderImportsOptimizations(ITypesCache typesCache, IMetadataTypeInfo typeInfo, bool projectionIsUsed);
    public PreRenderImportsOptimizations(ITypesCache typesCache, string ownNamespace, ICollection`1<string> conflictingNames, bool projectionIsUsed);
    public sealed virtual OptimizeImportsResult Optimize(ICollection`1<IClrTypeName> referencedTypeNames);
    private OptimizeImportsResult OptimizeImports(ICollection`1<IClrTypeName> referencedTypeNames);
    protected virtual void PostOptimizeImports(OptimizeImportsResult imports);
    private static HashSet`1<string> GetConflictingNames(IMetadataTypeInfo typeInfo);
    private static string GetOwnNamespace(IMetadataTypeInfo typeInfo);
}
public class JetBrains.Metadata.Utils.CodeTextWriter.TypeUsageCodeMarker : object {
    [CompilerGeneratedAttribute]
private string <TypeName>k__BackingField;
    public string TypeName { get; private set; }
    public TypeUsageCodeMarker(string typeName);
    [CompilerGeneratedAttribute]
public string get_TypeName();
    [CompilerGeneratedAttribute]
private void set_TypeName(string value);
}
public class JetBrains.Metadata.Utils.ComStreamWrapper : object {
    private static int STG_E_INVALIDFUNCTION;
    private Stream myBaseStream;
    private long myPosition;
    public ComStreamWrapper(Stream stream);
    private void SetSizeToPosition();
    public sealed virtual void Read(Byte[] pv, int cb, IntPtr pcbRead);
    public sealed virtual void Write(Byte[] pv, int cb, IntPtr pcbWritten);
    public sealed virtual void Seek(long dlibMove, int dwOrigin, IntPtr plibNewPosition);
    public sealed virtual void SetSize(long libNewSize);
    public sealed virtual void CopyTo(IStream pstm, long cb, IntPtr pcbRead, IntPtr pcbWritten);
    public sealed virtual void Commit(int grfCommitFlags);
    public sealed virtual void Revert();
    public sealed virtual void LockRegion(long libOffset, long cb, int dwLockType);
    public sealed virtual void UnlockRegion(long libOffset, long cb, int dwLockType);
    public sealed virtual void Stat(STATSTG& pstatstg, int grfStatFlag);
    public sealed virtual void Clone(IStream& ppstm);
}
public enum JetBrains.Metadata.Utils.DotNetLegacy.AssemblyContentType : Enum {
    public int value__;
    public static AssemblyContentType Default;
    public static AssemblyContentType WindowsRuntime;
}
public class JetBrains.Metadata.Utils.DotNetLegacy.AssemblyNameInfoComparer : object {
    public static AssemblyNameInfoComparer Default;
    private static AssemblyNameInfoComparer();
    public bool ReferenceMatchesDefinition(string referenceDisplayName, AssemblyNameInfo definition);
    public bool ReferenceMatchesDefinition(AssemblyNameInfo reference, AssemblyNameInfo definition);
    public ComparisonResult Compare(AssemblyNameInfo reference, AssemblyNameInfo definition);
    public ComparisonResult Compare(AssemblyNameInfo reference, string referenceDisplayName, AssemblyNameInfo definition, Boolean& unificationApplied, bool ignoreVersion);
    private static Nullable`1<bool> TriviallyEquivalent(AssemblyNameInfo x, AssemblyNameInfo y);
    internal virtual bool ApplyUnificationPolicies(AssemblyNameInfo& reference, AssemblyNameInfo& definition, AssemblyNameInfoParts referenceParts, Boolean& isFxAssembly);
}
[FlagsAttribute]
public enum JetBrains.Metadata.Utils.DotNetLegacy.AssemblyNameInfoParts : Enum {
    public int value__;
    public static AssemblyNameInfoParts Name;
    public static AssemblyNameInfoParts Version;
    public static AssemblyNameInfoParts VersionMajor;
    public static AssemblyNameInfoParts VersionMinor;
    public static AssemblyNameInfoParts VersionBuild;
    public static AssemblyNameInfoParts VersionRevision;
    public static AssemblyNameInfoParts Culture;
    public static AssemblyNameInfoParts PublicKey;
    public static AssemblyNameInfoParts PublicKeyToken;
    public static AssemblyNameInfoParts PublicKeyOrToken;
    public static AssemblyNameInfoParts Retargetability;
    public static AssemblyNameInfoParts ContentType;
    public static AssemblyNameInfoParts Unknown;
}
internal class JetBrains.Metadata.Utils.DotNetLegacy.AssemblyVersion : ValueType {
    private ushort myMajor;
    private ushort myMinor;
    private ushort myBuild;
    private ushort myRevision;
    public int Major { get; }
    public int Minor { get; }
    public int Build { get; }
    public int Revision { get; }
    public AssemblyVersion(ushort major, ushort minor, ushort build, ushort revision);
    public int get_Major();
    public int get_Minor();
    public int get_Build();
    public int get_Revision();
    private ulong ToInteger();
    public sealed virtual int CompareTo(AssemblyVersion other);
    public sealed virtual bool Equals(AssemblyVersion other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(AssemblyVersion left, AssemblyVersion right);
    public static bool op_Inequality(AssemblyVersion left, AssemblyVersion right);
    public static bool op_LessThan(AssemblyVersion left, AssemblyVersion right);
    public static bool op_LessThanOrEqual(AssemblyVersion left, AssemblyVersion right);
    public static bool op_GreaterThan(AssemblyVersion left, AssemblyVersion right);
    public static bool op_GreaterThanOrEqual(AssemblyVersion left, AssemblyVersion right);
    public static AssemblyVersion op_Explicit(Version version);
    public static Version op_Explicit(AssemblyVersion version);
}
public class JetBrains.Metadata.Utils.DotNetLegacy.DesktopAssemblyNameComparer : AssemblyNameInfoComparer {
    internal static string NeutralCulture;
    private static string NULL;
    private static bool TRUE;
    public static DesktopAssemblyNameComparer Default;
    private static IReadOnlyList`1<byte> NETCF_PUBLIC_KEY_TOKEN_1;
    private static IReadOnlyList`1<byte> NETCF_PUBLIC_KEY_TOKEN_2;
    private static IReadOnlyList`1<byte> NETCF_PUBLIC_KEY_TOKEN_3;
    private static IReadOnlyList`1<byte> SQL_PUBLIC_KEY_TOKEN;
    private static IReadOnlyList`1<byte> SQL_MOBILE_PUBLIC_KEY_TOKEN;
    private static IReadOnlyList`1<byte> ECMA_PUBLICKEY_STR_L;
    private static IReadOnlyList`1<byte> SHAREDLIB_PUBLICKEY_STR_L;
    private static IReadOnlyList`1<byte> MICROSOFT_PUBLICKEY_STR_L;
    private static IReadOnlyList`1<byte> SILVERLIGHT_PLATFORM_PUBLICKEY_STR_L;
    private static IReadOnlyList`1<byte> SILVERLIGHT_PUBLICKEY_STR_L;
    private static IReadOnlyList`1<byte> RIA_SERVICES_KEY_TOKEN;
    private static AssemblyVersion VER_VS_COMPATIBILITY_ASSEMBLYVERSION_STR_L;
    private static AssemblyVersion VER_VS_ASSEMBLYVERSION_STR_L;
    private static AssemblyVersion VER_SQL_ASSEMBLYVERSION_STR_L;
    private static AssemblyVersion VER_LINQ_ASSEMBLYVERSION_STR_L;
    private static AssemblyVersion VER_LINQ_ASSEMBLYVERSION_STR_2_L;
    private static AssemblyVersion VER_SQL_ORCAS_ASSEMBLYVERSION_STR_L;
    private static AssemblyVersion VER_ASSEMBLYVERSION_STR_L;
    private static AssemblyVersion VER_VC_STLCLR_ASSEMBLYVERSION_STR_L;
    private static FrameworkRetargetingDictionary ourGArRetargetPolicy;
    private static FrameworkAssemblyDictionary ourGArFxPolicy;
    private static DesktopAssemblyNameComparer();
    internal virtual bool ApplyUnificationPolicies(AssemblyNameInfo& reference, AssemblyNameInfo& definition, AssemblyNameInfoParts referenceParts, Boolean& isFxAssembly);
    public static bool IsFrameworkAssembly(AssemblyNameInfo identity);
    private static bool IsRetargetableAssembly(AssemblyNameInfo identity);
    private static bool IsOptionallyRetargetableAssembly(AssemblyNameInfo identity);
    private static bool IsTriviallyNonRetargetable(AssemblyNameInfo identity);
    private static void IsRetargetableAssembly(AssemblyNameInfo identity, Boolean& retargetable, Boolean& portable);
    private static AssemblyNameInfo Retarget(AssemblyNameInfo identity);
    private AssemblyNameInfo Port(AssemblyNameInfo identity);
}
internal class JetBrains.Metadata.Utils.DotNetLegacy.EqualityComparerCovariantAdapter`2 : object {
    private IEqualityComparer`1<TBase> myComparer;
    public EqualityComparerCovariantAdapter`2(IEqualityComparer`1<TBase> comparer);
    public sealed virtual bool Equals(TDervied x, TDervied y);
    public sealed virtual int GetHashCode(TDervied obj);
}
[ExtensionAttribute]
public static class JetBrains.Metadata.Utils.DotNetLegacy.Utils : object {
    [ExtensionAttribute]
public static bool IsFullName(AssemblyNameInfoParts parts);
    public static AssemblyNameInfoParts GetParts(AssemblyNameInfo parsedInfo);
}
public class JetBrains.Metadata.Utils.EmptyBlob : object {
    public static IBlob Instance;
    public int Length { get; }
    private static EmptyBlob();
    public sealed virtual int get_Length();
    public sealed virtual IBlob Clone();
    public sealed virtual IBinaryReader CreateReader(int position);
    public sealed virtual IBlob Slice(int position, int length);
    public sealed virtual byte ReadByte(int offset);
    public sealed virtual ushort ReadUInt16(int offset);
    public sealed virtual UInt32 ReadUInt32(int offset);
    public sealed virtual ulong ReadUInt64(int offset);
    public sealed virtual void Read(int sourceOffset, Byte[] buffer, int bufferOffset, int count);
    public sealed virtual string ReadStringUtf8(int offset, Int32& bytesLen);
    public sealed virtual UInt32 ReadCompressedInteger(int offset, Int32& size);
    public sealed virtual string ReadUtf8Constant(int offset, Int32& len);
}
public interface JetBrains.Metadata.Utils.IAssemblyItem {
    [NotNullAttribute]
public AssemblyNameInfo AssemblyName { get; }
    [NotNullAttribute]
public SimpleFileItem File { get; }
    public abstract virtual AssemblyNameInfo get_AssemblyName();
    public abstract virtual SimpleFileItem get_File();
}
public interface JetBrains.Metadata.Utils.IAssemblyItem2 {
    [CanBeNullAttribute]
public SimpleFileItem ProgramDatabase { get; }
    [CanBeNullAttribute]
public SimpleFileItem XmlDocumentation { get; }
    public abstract virtual SimpleFileItem get_ProgramDatabase();
    public abstract virtual SimpleFileItem get_XmlDocumentation();
}
public interface JetBrains.Metadata.Utils.IBinaryReader {
    public int Position { get; public set; }
    public int Length { get; }
    public abstract virtual int get_Position();
    public abstract virtual void set_Position(int value);
    public abstract virtual int get_Length();
    [NotNullAttribute]
public abstract virtual IBinaryReader Clone();
    public abstract virtual char ReadChar();
    public abstract virtual float ReadSingle();
    public abstract virtual double ReadDouble();
    public abstract virtual short ReadInt16();
    public abstract virtual sbyte ReadSByte();
    public abstract virtual byte ReadUInt8();
    public abstract virtual ushort ReadUInt16();
    public abstract virtual int ReadInt32();
    public abstract virtual UInt32 ReadUInt32();
    public abstract virtual long ReadInt64();
    public abstract virtual ulong ReadUInt64();
    public abstract virtual void Read(Byte[] buffer, int offset, int count);
    public abstract virtual byte ReadByte();
    public abstract virtual string ReadStringUtf8();
    public abstract virtual string ReadStringUtf16le(int cbLength);
    public abstract virtual UInt32 ReadCompressedInteger();
    public abstract virtual string ReadUtf8Constant();
    public abstract virtual void Skip(int bytes);
}
public interface JetBrains.Metadata.Utils.IBlob {
    public int Length { get; }
    public abstract virtual int get_Length();
    public abstract virtual IBlob Clone();
    public abstract virtual IBinaryReader CreateReader(int position);
    public abstract virtual IBlob Slice(int position, int length);
    public abstract virtual byte ReadByte(int offset);
    public abstract virtual ushort ReadUInt16(int offset);
    public abstract virtual UInt32 ReadUInt32(int offset);
    public abstract virtual ulong ReadUInt64(int offset);
    public abstract virtual void Read(int sourceOffset, Byte[] buffer, int bufferOffset, int count);
    public abstract virtual string ReadStringUtf8(int offset, Int32& bytesLen);
    public abstract virtual UInt32 ReadCompressedInteger(int offset, Int32& size);
    public abstract virtual string ReadUtf8Constant(int offset, Int32& len);
}
internal class JetBrains.Metadata.Utils.IntInterval : ValueType {
    public int From;
    public int To;
    public int Length { get; }
    public IntInterval(int from, int to);
    public int get_Length();
}
[ExtensionAttribute]
public static class JetBrains.Metadata.Utils.ManifestResourceUtil : object {
    [ExtensionAttribute]
[CanBeNullAttribute]
public static Stream TryGetManifestResourceStream(IMetadataAssembly metadataAssembly, string resourceName);
    [NotNullAttribute]
[ExtensionAttribute]
public static Stream GetManifestResourceStream(IMetadataAssembly metadataAssembly, string resourceName);
    [ExtensionAttribute]
[NotNullAttribute]
public static IManifestResourceDisposition GetManifestResourceDisposition(IMetadataAssembly metadataAssembly, string resourceName);
    [ExtensionAttribute]
[NotNullAttribute]
public static IMetadataManifestResource GetManifestResource(IMetadataAssembly metadataAssembly, string resourceName);
    [CanBeNullAttribute]
public static Stream TryGetManifestResourceStream(FileSystemPath assemblyLocation, string resourceName);
    [NotNullAttribute]
public static Stream GetManifestResourceStream(FileSystemPath assemblyLocation, string resourceName);
}
public static class JetBrains.Metadata.Utils.MarshalSpecParser : object {
    public static IMarshalSpec Parse(IBlob blob);
}
[ExtensionAttribute]
public static class JetBrains.Metadata.Utils.MetadataHelpers : object {
    private static Dictionary`2<NativeType, UnmanagedType> ourNativeType2UnmanagedType;
    private static Dictionary`2<VariantType, VarEnum> ourVariantType2VarEnum;
    private static MetadataHelpers();
    [ExtensionAttribute]
public static LayoutKind ToLayoutKind(ClassLayoutType layoutType);
    [ExtensionAttribute]
public static CallingConvention ToCallingConvention(CallConvSpec spec);
    [ExtensionAttribute]
public static CharSet ToCharSet(CharSetSpec spec);
    [ExtensionAttribute]
public static bool IsValueType(IMetadataTypeInfo info);
    [ExtensionAttribute]
public static bool IsValueType(IMetadataType type);
    [ExtensionAttribute]
public static bool IsSealed(IMetadataType type);
    [ExtensionAttribute]
public static bool IsDelegate(IMetadataTypeInfo info);
    [ExtensionAttribute]
public static bool IsDelegate(IMetadataType type);
    [ExtensionAttribute]
public static bool IsModuleType(IMetadataTypeInfo typeInfo);
    [ExtensionAttribute]
public static bool IsEnum(IMetadataTypeInfo typeInfo);
    [ExtensionAttribute]
public static bool IsEnum(IMetadataType type);
    [ExtensionAttribute]
public static bool IsString(IMetadataType type);
    [ExtensionAttribute]
public static bool IsDouble(IMetadataType type);
    [ExtensionAttribute]
public static bool IsFloat(IMetadataType type);
    [ExtensionAttribute]
public static bool IsDecimal(IMetadataType type);
    [ExtensionAttribute]
public static bool IsLong(IMetadataType type);
    [ExtensionAttribute]
public static bool IsULong(IMetadataType type);
    [ExtensionAttribute]
public static bool IsChar(IMetadataType type);
    [ExtensionAttribute]
public static bool IsInt(IMetadataType type);
    [ExtensionAttribute]
public static bool IsUInt(IMetadataType type);
    [ExtensionAttribute]
public static bool IsByte(IMetadataType type);
    [ExtensionAttribute]
public static bool IsSByte(IMetadataType type);
    [ExtensionAttribute]
public static bool IsShort(IMetadataType type);
    [ExtensionAttribute]
public static bool IsUShort(IMetadataType type);
    [ExtensionAttribute]
public static bool IsDateTime(IMetadataType type);
    [ExtensionAttribute]
public static bool IsTimeSpan(IMetadataType type);
    [ExtensionAttribute]
public static bool IsObject(IMetadataType type);
    [ExtensionAttribute]
public static IMetadataClassType GetUnderlyingEnumType(IMetadataTypeInfo typeInfo);
    [ExtensionAttribute]
public static IMetadataClassType GetUnderlyingEnumType(IMetadataType type);
    [ExtensionAttribute]
public static bool IsNullable(IMetadataType type);
    [ExtensionAttribute]
public static IMetadataType GetUnderlyingNullableType(IMetadataType type);
    [ExtensionAttribute]
public static MethodCodeType ToMethodCodeType(CodeType codeType);
    [ExtensionAttribute]
public static UnmanagedType ToUnmanagedType(NativeType type);
    [ExtensionAttribute]
public static VarEnum ToVarEnum(VariantType type);
    [ExtensionAttribute]
public static VariantType ToSimple(VariantType type);
    [ExtensionAttribute]
public static bool IsVector(VariantType type);
    [ExtensionAttribute]
public static bool IsArray(VariantType type);
    [ExtensionAttribute]
public static bool IsByref(VariantType type);
    [ExtensionAttribute]
public static bool HasModifier(IMetadataType type, string modifierFqn);
    [ExtensionAttribute]
public static bool TypeSpecIsInstantiationOf(IMetadataAssembly assembly, MetadataToken typeSpec, MetadataToken type);
    [ExtensionAttribute]
public static MetadataTypeReference GetTypeInfoFullName(IMetadataAccess metadataAccess, MetadataToken type);
    [CanBeNullAttribute]
[ExtensionAttribute]
public static IMetadataAssembly GetCorlib(IMetadataAssembly assembly);
}
public static class JetBrains.Metadata.Utils.ModuleQualificationUtil : object {
    public static string TYPE_GROUP;
    public static string ASSEMBLY_GROUP;
    public static string VERSION_GROUP;
    public static string CULTURE_GROUP;
    public static string PUBLIC_KEY_TOKEN_GROUP;
    public static string TYPE_PATTERN;
    public static string ASSEMBLY_PATTERN;
    public static string ASSEMBLY_PATTERN_NO_COMMA;
    public static string VERSION_PATTERN;
    public static string CULTURE_PATTERN;
    public static string PUBLIC_KEY_TOKEN_PATTERN;
    public static string FULL_TYPE_NAME_PATTERN;
    public static string MODULE_QUALIFICATION_PATTERN;
    public static string MODULE_QUALIFICATION_PATTERN_NO_COMMA;
    public static Regex FULL_TYPE_NAME_REGEX;
    public static Regex MODULE_QUALIFICATION_REGEX;
    public static Regex MODULE_QUALIFICATION_REGEX_NO_COMMA;
    private static ModuleQualificationUtil();
    public static string Optional(string pattern);
    [CanBeNullAttribute]
public static AssemblyNameInfo GetAssemblyName(string moduleQualification, String& error, bool hasLeadingComma);
    internal static int GetIndexOfCommaAfterTypeName(string qualifiedTypeString);
    public static string GetTypeName(string qualifiedTypeString, AssemblyNameInfo& assemblyName);
}
[ExtensionAttribute]
internal static class JetBrains.Metadata.Utils.Pdb.PdbContent.DebugDataXmlSerializer : object {
    [ExtensionAttribute]
public static void DumpToXml(DebugData debugData, XmlWriter writer);
    [ExtensionAttribute]
private static void DumpToXml(DebugDocument document, XmlWriter writer);
    [ExtensionAttribute]
private static void DumpToXml(ImportScope importScope, XmlWriter writer, DebugData debugData);
    [ExtensionAttribute]
private static void DumpToXml(DebugMethod method, XmlWriter writer);
    [ExtensionAttribute]
private static void DumpToXml(SequencePoint sequencePoint, XmlWriter writer);
    [ExtensionAttribute]
private static void DumpToXml(LocalScope localScope, XmlWriter writer);
    [ExtensionAttribute]
private static void DumpToXml(DebugLocalVariable localVariable, XmlWriter writer);
}
[FlagsAttribute]
public enum JetBrains.Metadata.Utils.PE.Characteristics : Enum {
    public ushort value__;
    public static Characteristics RELOCS_STRIPPED;
    public static Characteristics EXECUTABLE_IMAGE;
    public static Characteristics LINE_NUMS_STRIPPED;
    public static Characteristics LOCAL_SYMS_STRIPPED;
    public static Characteristics AGGRESSIVE_WS_TRIM;
    public static Characteristics LARGE_ADDRESS_AWARE;
    public static Characteristics MACHINE_16BIT;
    public static Characteristics BYTES_REVERSED_LO;
    public static Characteristics MACHINE_32BIT;
    public static Characteristics DEBUG_STRIPPED;
    public static Characteristics REMOVABLE_RUN_FROM_SWAP;
    public static Characteristics NET_RUN_FROM_SWAP;
    public static Characteristics SYSTEM;
    public static Characteristics DLL;
    public static Characteristics UP_SYSTEM_ONLY;
    public static Characteristics BYTES_REVERSED_HI;
}
[FlagsAttribute]
public enum JetBrains.Metadata.Utils.PE.CLIFlags : Enum {
    public UInt32 value__;
    public static CLIFlags IlOnly;
    public static CLIFlags Required32Bit;
    public static CLIFlags IlLibrary;
    public static CLIFlags StrongNameSigned;
    public static CLIFlags NativeEntryPoint;
    public static CLIFlags TrackDebugData;
    public static CLIFlags Preferred32Bit;
}
public class JetBrains.Metadata.Utils.PE.CLIHeader : object {
    private DataDirectory myCodeManagerTable;
    private DataDirectory myExportAddressTableJumps;
    private UInt32 myEntryPointToken;
    private CLIFlags myFlags;
    private DataDirectory myManagedNativeHeader;
    private DataDirectory myMetadata;
    private int myMetadataStartOffset;
    private DataDirectory myResources;
    private ushort myMajorRuntimeVersion;
    private ushort myMinorRuntimeVersion;
    private UInt32 mySize;
    private DataDirectory myStrongNameSignature;
    private DataDirectory myVTableFixups;
    public UInt32 Size { get; }
    public ushort MajorRuntimeVersion { get; }
    public ushort MinorRuntimeVersion { get; }
    public DataDirectory MetaData { get; }
    public CLIFlags Flags { get; }
    public UInt32 EntryPointToken { get; }
    public DataDirectory Resources { get; }
    public DataDirectory StrongNameSignature { get; }
    public DataDirectory CodeManagerTable { get; }
    public DataDirectory VTableFixups { get; }
    public DataDirectory ExportAddressTableJumps { get; }
    public DataDirectory ManagedNativeHeader { get; }
    public int MetadataStartOffset { get; }
    public CLIHeader(IBinaryReader reader, PEFile file);
    public UInt32 get_Size();
    public ushort get_MajorRuntimeVersion();
    public ushort get_MinorRuntimeVersion();
    public DataDirectory get_MetaData();
    public CLIFlags get_Flags();
    public UInt32 get_EntryPointToken();
    public DataDirectory get_Resources();
    public DataDirectory get_StrongNameSignature();
    public DataDirectory get_CodeManagerTable();
    public DataDirectory get_VTableFixups();
    public DataDirectory get_ExportAddressTableJumps();
    public DataDirectory get_ManagedNativeHeader();
    public int get_MetadataStartOffset();
}
public class JetBrains.Metadata.Utils.PE.CoffHeader : object {
    private Characteristics myCharacteristics;
    private MachineId myMachine;
    private OptHeaderSize mySizeOfOptionalHeader;
    private ushort mySectionsNo;
    private UInt32 mySignature;
    private UInt32 mySymbolsNo;
    private UInt32 mySymTablePtr;
    private UInt32 myTimeDateStamp;
    public UInt32 Signature { get; }
    public MachineId Machine { get; }
    public ushort NumberOfSections { get; }
    public UInt32 TimeDateStamp { get; }
    public UInt32 PointerToSymbolTable { get; }
    public UInt32 NumberOfSymbols { get; }
    public OptHeaderSize SizeOfOptionalHeader { get; }
    public Characteristics Characteristics { get; }
    public CoffHeader(IBinaryReader reader);
    public UInt32 get_Signature();
    public MachineId get_Machine();
    public ushort get_NumberOfSections();
    public UInt32 get_TimeDateStamp();
    public UInt32 get_PointerToSymbolTable();
    public UInt32 get_NumberOfSymbols();
    public OptHeaderSize get_SizeOfOptionalHeader();
    public Characteristics get_Characteristics();
}
[DebuggerDisplayAttribute("RVA={myRva} Size={mySize}")]
public class JetBrains.Metadata.Utils.PE.DataDirectory : object {
    private UInt32 myRva;
    private int mySize;
    public UInt32 RVA { get; }
    public int Size { get; }
    public DataDirectory(IBinaryReader reader);
    public UInt32 get_RVA();
    public int get_Size();
}
public class JetBrains.Metadata.Utils.PE.Directories.DebugDataInfo : object {
    protected UInt32 myAge;
    protected int myOffset;
    protected string myPdbFile;
    protected UInt32 myCodeViewSignature;
    public UInt32 CodeViewSignature { get; }
    public int Offset { get; }
    public UInt32 Age { get; }
    public string PdbFile { get; }
    public UInt32 get_CodeViewSignature();
    public int get_Offset();
    public UInt32 get_Age();
    public string get_PdbFile();
    protected string ReadNullTerminatedString(IBinaryReader reader);
}
public class JetBrains.Metadata.Utils.PE.Directories.DebugDirectory : PEDirectoryBase {
    private static UInt32 CodeViewSignaturePdb2;
    private static UInt32 CodeViewSignaturePdb7;
    private static UInt32 EmbeddedPortablePdbDebugDirectoryEntrySignature;
    private Entry[] myEntries;
    public Entry[] Entries { get; }
    public Entry[] get_Entries();
    public virtual void Read(IBinaryReader rdr, int size);
    [CanBeNullAttribute]
public static DebugDataInfo ReadDebugDataInfo(IBinaryReader reader);
}
public class JetBrains.Metadata.Utils.PE.Directories.DebugInfo : object {
    private static ushort PortableMinorVersion;
    private static ushort EmbeddedPortableMinorVersion;
    internal static DebugInfo EmbeddedPortable;
    internal static DebugInfo Deterministic;
    [CompilerGeneratedAttribute]
private DebugInfoType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <Signature>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <AgeOrTimestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PdbFile>k__BackingField;
    public DebugInfoType Type { get; private set; }
    public Guid Signature { get; private set; }
    public UInt32 AgeOrTimestamp { get; private set; }
    [CanBeNullAttribute]
public string PdbFile { get; private set; }
    private DebugInfo(DebugInfoType type, Guid signature, UInt32 ageOrTimestamp, string pdbFile);
    private static DebugInfo();
    protected bool Equals(DebugInfo other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public DebugInfoType get_Type();
    [CompilerGeneratedAttribute]
private void set_Type(DebugInfoType value);
    [CompilerGeneratedAttribute]
public Guid get_Signature();
    [CompilerGeneratedAttribute]
private void set_Signature(Guid value);
    [CompilerGeneratedAttribute]
public UInt32 get_AgeOrTimestamp();
    [CompilerGeneratedAttribute]
private void set_AgeOrTimestamp(UInt32 value);
    [CompilerGeneratedAttribute]
public string get_PdbFile();
    [CompilerGeneratedAttribute]
private void set_PdbFile(string value);
    [NotNullAttribute]
internal static DebugInfo CreateWindows(Guid signature, UInt32 age, string pdbFile);
    [NotNullAttribute]
internal static DebugInfo CreatePortable(Guid signature, UInt32 timeDateStamp, string pdbFile);
    [CanBeNullAttribute]
public static DebugInfo Create(ImageDebugDirectory imageDebugDirectory, DebugInfo7 debugInfo7);
}
public class JetBrains.Metadata.Utils.PE.Directories.DebugInfo2 : DebugDataInfo {
    private UInt32 myTimestamp;
    public DateTime Timestamp { get; }
    public DebugInfo2(IBinaryReader stm);
    public DateTime get_Timestamp();
}
public class JetBrains.Metadata.Utils.PE.Directories.DebugInfo7 : DebugDataInfo {
    private Guid mySignature;
    public Guid Signature { get; }
    public DebugInfo7(IBinaryReader stm);
    public Guid get_Signature();
}
public enum JetBrains.Metadata.Utils.PE.Directories.DebugInfoType : Enum {
    public int value__;
    public static DebugInfoType Windows;
    public static DebugInfoType Portable;
    public static DebugInfoType EmbeddedPortable;
    public static DebugInfoType Deterministic;
}
public enum JetBrains.Metadata.Utils.PE.Directories.DebugType : Enum {
    public UInt32 value__;
    public static DebugType Unknown;
    public static DebugType COFF;
    public static DebugType CodeView;
    public static DebugType FPO;
    public static DebugType Misc;
    public static DebugType Exception;
    public static DebugType Fixup;
    public static DebugType OMAPtoSRC;
    public static DebugType OMAPfromSRC;
    public static DebugType Borland;
    public static DebugType Reserved10;
    public static DebugType CLSID;
    public static DebugType Deterministic;
    public static DebugType EmbeddedPortablePdb;
}
public class JetBrains.Metadata.Utils.PE.Directories.EntireResourceDirectory : PEDirectoryBase {
    private ResourceDirectory myRoot;
    public ResourceDirectory Root { get; }
    public virtual void Read(IBinaryReader rdr, int size);
    public ResourceDirectory get_Root();
    public void Dump(TextWriter result);
}
public class JetBrains.Metadata.Utils.PE.Directories.MiscDebugInfo : DebugDataInfo {
    public MiscDebugInfo(IBinaryReader stm);
}
public abstract class JetBrains.Metadata.Utils.PE.Directories.PEDirectoryBase : object {
    public abstract virtual void Read(IBinaryReader rdr, int size);
}
public class JetBrains.Metadata.Utils.PE.Directories.ResourceDataEntry : object {
    private int myBaseOffset;
    private int myOffsetToData;
    private int mySize;
    private int myCodepage;
    private int myReserved;
    public int OffsetToData { get; }
    public int Size { get; }
    public int Codepage { get; }
    public int Reserved { get; }
    public ResourceDataEntry(IBinaryReader reader, int baseOffset);
    public IBinaryReader GetData(PEFile peFile);
    public int get_OffsetToData();
    public int get_Size();
    public int get_Codepage();
    public int get_Reserved();
    public void Dump(TextWriter result);
}
public class JetBrains.Metadata.Utils.PE.Directories.ResourceDirectory : object {
    public static int StructureSize;
    private int myCharacteristics;
    private ResourceDirectoryEntry[] myEntries;
    private int myMajorVersion;
    private int myMinorVersion;
    private int myNumberOfIdEntries;
    private int myNumberOfNamedEntries;
    private int myTimestamp;
    public int Characteristics { get; }
    public int Timestamp { get; }
    public int MajorVersion { get; }
    public int MinorVersion { get; }
    public int NumberOfNamedEntries { get; }
    public int NumberOfIdEntries { get; }
    public ResourceDirectoryEntry[] Entries { get; }
    public ResourceDirectory(IBinaryReader reader, int baseOffset);
    public int get_Characteristics();
    public int get_Timestamp();
    public int get_MajorVersion();
    public int get_MinorVersion();
    public int get_NumberOfNamedEntries();
    public int get_NumberOfIdEntries();
    public ResourceDirectoryEntry[] get_Entries();
    public void Dump(TextWriter result);
}
public class JetBrains.Metadata.Utils.PE.Directories.ResourceDirectoryEntry : object {
    public static int StructureSize;
    private int myId;
    private string myName;
    private int myOffset;
    private ResourceDirectory myDirectory;
    private ResourceDataEntry myDataEntry;
    private UInt32 myRawName;
    private UInt32 myRawOffset;
    private ResourceDirectoryEntryNameType myNameType;
    public int Id { get; }
    public string Name { get; }
    public int Offset { get; }
    public UInt32 RawName { get; }
    public UInt32 RawOffset { get; }
    public ResourceDirectoryEntryNameType NameType { get; }
    public ResourceDirectory Directory { get; }
    public ResourceDataEntry DataEntry { get; }
    public ResourceDirectoryEntry(IBinaryReader reader, int baseOffset);
    private static ResourceDirectoryEntry();
    public int get_Id();
    public string get_Name();
    public int get_Offset();
    public UInt32 get_RawName();
    public UInt32 get_RawOffset();
    public ResourceDirectoryEntryNameType get_NameType();
    public ResourceDirectory get_Directory();
    public ResourceDataEntry get_DataEntry();
    public void Dump(TextWriter result, bool isTopLevel, int indent);
}
public enum JetBrains.Metadata.Utils.PE.Directories.ResourceDirectoryEntryNameType : Enum {
    public int value__;
    public static ResourceDirectoryEntryNameType Id;
    public static ResourceDirectoryEntryNameType String;
}
public enum JetBrains.Metadata.Utils.PE.Directories.ResourceType : Enum {
    public int value__;
    public static ResourceType None;
    public static ResourceType Cursor;
    public static ResourceType Bitmap;
    public static ResourceType Icon;
    public static ResourceType Menu;
    public static ResourceType Dialog;
    public static ResourceType String;
    public static ResourceType FontDir;
    public static ResourceType Font;
    public static ResourceType Accelerator;
    public static ResourceType RcData;
    public static ResourceType MessageTable;
    public static ResourceType GroupCursor;
    public static ResourceType GroupIcon;
    public static ResourceType Version;
    public static ResourceType DlgInclude;
    public static ResourceType PlugPlay;
    public static ResourceType VxD;
    public static ResourceType AniCursor;
    public static ResourceType AniIcon;
    public static ResourceType Html;
    public static ResourceType Manifest;
}
[FlagsAttribute]
public enum JetBrains.Metadata.Utils.PE.DllCharacteristics : Enum {
    public ushort value__;
    public static DllCharacteristics HighEntropyVa;
    public static DllCharacteristics DynamicBase;
    public static DllCharacteristics ForceIntegrity;
    public static DllCharacteristics NxCompat;
    public static DllCharacteristics NoIsolation;
    public static DllCharacteristics NoSeh;
    public static DllCharacteristics NoBind;
    public static DllCharacteristics Appcontainer;
    public static DllCharacteristics WdmDriver;
    public static DllCharacteristics GuardCf;
    public static DllCharacteristics TerminalServerAware;
}
public class JetBrains.Metadata.Utils.PE.DosHeader : object {
    public static ushort MarkZbikowskiSignature;
    private ushort myMagic;
    private ushort myCblp;
    private ushort myCp;
    private ushort myCrlc;
    private ushort myCparHdr;
    private ushort myMinAlloc;
    private ushort myMaxAlloc;
    private ushort mySs;
    private ushort mySp;
    private ushort myCSum;
    private ushort myIp;
    private ushort myCs;
    private ushort myLfaRlc;
    private ushort myOvNo;
    private UInt16[] myRes;
    private ushort myOemId;
    private ushort myOemInfo;
    private UInt16[] myRes2;
    private UInt32 myLfaNew;
    public ushort Magic { get; }
    public bool IsMagicValid { get; }
    public ushort Cblp { get; }
    public ushort Cp { get; }
    public ushort Crlc { get; }
    public ushort CparHdr { get; }
    public ushort MinAlloc { get; }
    public ushort MaxAlloc { get; }
    public ushort Ss { get; }
    public ushort Sp { get; }
    public ushort CSum { get; }
    public ushort Ip { get; }
    public ushort Cs { get; }
    public ushort LfaRlc { get; }
    public ushort OvNo { get; }
    public UInt16[] Res { get; }
    public ushort OemId { get; }
    public ushort OemInfo { get; }
    public UInt16[] Res2 { get; }
    public UInt32 LfaNew { get; }
    public DosHeader(IBinaryReader reader);
    private static DosHeader();
    public ushort get_Magic();
    public bool get_IsMagicValid();
    public ushort get_Cblp();
    public ushort get_Cp();
    public ushort get_Crlc();
    public ushort get_CparHdr();
    public ushort get_MinAlloc();
    public ushort get_MaxAlloc();
    public ushort get_Ss();
    public ushort get_Sp();
    public ushort get_CSum();
    public ushort get_Ip();
    public ushort get_Cs();
    public ushort get_LfaRlc();
    public ushort get_OvNo();
    public UInt16[] get_Res();
    public ushort get_OemId();
    public ushort get_OemInfo();
    public UInt16[] get_Res2();
    public UInt32 get_LfaNew();
}
public enum JetBrains.Metadata.Utils.PE.ExeSignature : Enum {
    public ushort value__;
    public static ExeSignature UNKNOWN;
    public static ExeSignature DOS;
    public static ExeSignature OS2;
    public static ExeSignature OS2_LE;
    public static ExeSignature VXD;
    public static ExeSignature NT;
    public static ExeSignature NT2;
}
public enum JetBrains.Metadata.Utils.PE.MachineId : Enum {
    public ushort value__;
    public static MachineId UNKNOWN;
    public static MachineId I386;
    public static MachineId I486;
    public static MachineId PENTIUM;
    public static MachineId R3000_BE;
    public static MachineId R3000;
    public static MachineId R4000;
    public static MachineId R10000;
    public static MachineId WCEMIPSV2;
    public static MachineId ALPHA;
    public static MachineId SH3;
    public static MachineId SH3DSP;
    public static MachineId SH3E;
    public static MachineId SH4;
    public static MachineId SH5;
    public static MachineId ARM;
    public static MachineId THUMB;
    public static MachineId AM33;
    public static MachineId POWERPC;
    public static MachineId POWERPCFP;
    public static MachineId IA64;
    public static MachineId MIPS16;
    public static MachineId ALPHA64;
    public static MachineId MIPSFPU;
    public static MachineId MIPSFPU16;
    public static MachineId AXP64;
    public static MachineId TRICORE;
    public static MachineId CEF;
    public static MachineId EBC;
    public static MachineId AMD64;
    public static MachineId M32R;
    public static MachineId CEE;
    public static MachineId ARMNT;
    public static MachineId NETCORE_NGEN_MAC64;
    public static MachineId NETCORE_NGEN_LINUX64;
}
public class JetBrains.Metadata.Utils.PE.MetadataHeader : object {
    public static int SIGNATURE;
    public static int SignatureSize;
    private ushort myFlags;
    private UInt32 myReserved;
    private UInt32 mySignature;
    private StreamHeader[] myStreams;
    private ushort myVersionMajor;
    private ushort myVersionMinor;
    private int myVersionStringLength;
    private string myVersionString;
    public UInt32 Signature { get; }
    public ushort MajorVersion { get; }
    public ushort MinorVersion { get; }
    public UInt32 Reserved { get; }
    public string VersionString { get; }
    public int VersionStringLength { get; }
    public ushort Flags { get; }
    public ushort NumberOfStreams { get; }
    public StreamHeader[] StreamHeaders { get; }
    public MetadataHeader(IBinaryReader reader);
    public UInt32 get_Signature();
    public ushort get_MajorVersion();
    public ushort get_MinorVersion();
    public UInt32 get_Reserved();
    public string get_VersionString();
    public int get_VersionStringLength();
    public ushort get_Flags();
    public ushort get_NumberOfStreams();
    public StreamHeader[] get_StreamHeaders();
}
public class JetBrains.Metadata.Utils.PE.MetadataReaderException : Exception {
    public MetadataReaderException(string message);
    public MetadataReaderException(string message, Exception innerException);
    protected MetadataReaderException(SerializationInfo info, StreamingContext context);
}
public enum JetBrains.Metadata.Utils.PE.OptHeaderSize : Enum {
    public ushort value__;
    public static OptHeaderSize IMAGE_SIZEOF_ROM_OPTIONAL_HEADER;
    public static OptHeaderSize IMAGE_SIZEOF_STD_OPTIONAL_HEADER;
    public static OptHeaderSize IMAGE_SIZEOF_NT_OPTIONAL32_HEADER;
    public static OptHeaderSize IMAGE_SIZEOF_NT_OPTIONAL64_HEADER;
}
public class JetBrains.Metadata.Utils.PE.OptionalNtHeader32 : OptionalNtHeaderBase {
    private UInt32 mySizeOfHeapCommit;
    private UInt32 mySizeOfHeapReserve;
    private UInt32 mySizeOfStackCommit;
    private UInt32 mySizeOfStackReserve;
    private UInt32 myBaseOfData;
    private UInt32 myImageBase;
    public UInt32 BaseOfData { get; }
    public UInt32 ImageBase { get; }
    public UInt32 SizeOfStackReserve { get; }
    public UInt32 SizeOfStackCommit { get; }
    public UInt32 SizeOfHeapReserve { get; }
    public UInt32 SizeOfHeapCommit { get; }
    public OptionalNtHeader32(IBinaryReader reader);
    public UInt32 get_BaseOfData();
    public UInt32 get_ImageBase();
    public UInt32 get_SizeOfStackReserve();
    public UInt32 get_SizeOfStackCommit();
    public UInt32 get_SizeOfHeapReserve();
    public UInt32 get_SizeOfHeapCommit();
    protected virtual void ReadImageBase(IBinaryReader reader);
    protected virtual void ReadStackHeapSizes(IBinaryReader reader);
}
public class JetBrains.Metadata.Utils.PE.OptionalNtHeader64 : OptionalNtHeaderBase {
    private ulong mySizeOfHeapCommit;
    private ulong mySizeOfHeapReserve;
    private ulong mySizeOfStackCommit;
    private ulong mySizeOfStackReserve;
    private ulong myImageBase;
    public ulong ImageBase { get; }
    public ulong SizeOfStackReserve { get; }
    public ulong SizeOfStackCommit { get; }
    public ulong SizeOfHeapReserve { get; }
    public ulong SizeOfHeapCommit { get; }
    public OptionalNtHeader64(IBinaryReader reader);
    public ulong get_ImageBase();
    public ulong get_SizeOfStackReserve();
    public ulong get_SizeOfStackCommit();
    public ulong get_SizeOfHeapReserve();
    public ulong get_SizeOfHeapCommit();
    protected virtual void ReadImageBase(IBinaryReader reader);
    protected virtual void ReadStackHeapSizes(IBinaryReader reader);
}
public abstract class JetBrains.Metadata.Utils.PE.OptionalNtHeaderBase : object {
    private UInt32 myNumberOfRvaAndSizes;
    private DllCharacteristics myDllCharacteristics;
    private UInt32 myFileAlignment;
    private UInt32 myCheckSum;
    private UInt32 mySizeOfHeaders;
    private UInt32 mySizeOfImage;
    private ushort myImageVersionMajor;
    private ushort myImageVersionMinor;
    private UInt32 myLoaderFlags;
    private ushort myOsVersionMajor;
    private ushort myOsVersionMinor;
    private UInt32 myWin32VersionValue;
    private UInt32 mySectionAlignment;
    private Subsystem mySubsystem;
    private ushort mySubsysVersionMajor;
    private ushort mySubsysVersionMinor;
    public UInt32 SectionAlignment { get; }
    public UInt32 FileAlignment { get; }
    public ushort MajorOperatingSystemVersion { get; }
    public ushort MinorOperatingSystemVersion { get; }
    public ushort MajorImageVersion { get; }
    public ushort MinorImageVersion { get; }
    public ushort MajorSubsystemVersion { get; }
    public ushort MinorSubsystemVersion { get; }
    public UInt32 Win32VersionValue { get; }
    public UInt32 SizeOfImage { get; }
    public UInt32 SizeOfHeaders { get; }
    public UInt32 CheckSum { get; }
    public Subsystem Subsystem { get; }
    public DllCharacteristics DllCharacteristics { get; }
    public UInt32 LoaderFlags { get; }
    public UInt32 NumberOfRvaAndSizes { get; }
    protected OptionalNtHeaderBase(IBinaryReader reader);
    public UInt32 get_SectionAlignment();
    public UInt32 get_FileAlignment();
    public ushort get_MajorOperatingSystemVersion();
    public ushort get_MinorOperatingSystemVersion();
    public ushort get_MajorImageVersion();
    public ushort get_MinorImageVersion();
    public ushort get_MajorSubsystemVersion();
    public ushort get_MinorSubsystemVersion();
    public UInt32 get_Win32VersionValue();
    public UInt32 get_SizeOfImage();
    public UInt32 get_SizeOfHeaders();
    public UInt32 get_CheckSum();
    public Subsystem get_Subsystem();
    public DllCharacteristics get_DllCharacteristics();
    public UInt32 get_LoaderFlags();
    public UInt32 get_NumberOfRvaAndSizes();
    protected abstract virtual void ReadImageBase(IBinaryReader reader);
    protected abstract virtual void ReadStackHeapSizes(IBinaryReader reader);
}
public enum JetBrains.Metadata.Utils.PE.PeDirectoryEntry : Enum {
    public int value__;
    public static PeDirectoryEntry Export;
    public static PeDirectoryEntry Import;
    public static PeDirectoryEntry Resource;
    public static PeDirectoryEntry Exception;
    public static PeDirectoryEntry Security;
    public static PeDirectoryEntry BaseReloc;
    public static PeDirectoryEntry Debug;
    public static PeDirectoryEntry Architecture;
    public static PeDirectoryEntry GlobalPtr;
    public static PeDirectoryEntry Tls;
    public static PeDirectoryEntry LoadConfig;
    public static PeDirectoryEntry BoundImport;
    public static PeDirectoryEntry ImportAddressTable;
    public static PeDirectoryEntry DelayImport;
    public static PeDirectoryEntry ComDescriptor;
    public static PeDirectoryEntry Unknown;
}
public class JetBrains.Metadata.Utils.PE.PEFile : object {
    private CLIHeader myCLIHeader;
    private CoffHeader myCOFFHeader;
    private DataDirectory[] myDirs;
    private DosHeader myDosHeader;
    private MetadataHeader myMetadataHeader;
    private OptionalNtHeaderBase myNTHeader;
    private PEHeader myPEHeader;
    private IBinaryReader myReader;
    private SectionHeader[] mySectionsTable;
    public int EndOffset;
    public DosHeader DOSheader { get; }
    public CoffHeader COFFheader { get; }
    public PEHeader PEHeader { get; }
    public OptionalNtHeaderBase NTHeader { get; }
    public DataDirectory[] Entries { get; }
    public SectionHeader[] Sections { get; }
    [CanBeNullAttribute]
public CLIHeader CLIHeader { get; }
    [CanBeNullAttribute]
public MetadataHeader MetadataHeader { get; }
    public IBinaryReader Reader { get; }
    public bool IsValid { get; }
    public PEFile(IBinaryReader reader);
    public DosHeader get_DOSheader();
    public CoffHeader get_COFFheader();
    public PEHeader get_PEHeader();
    public OptionalNtHeaderBase get_NTHeader();
    public DataDirectory[] get_Entries();
    public DataDirectory GetDataDirectoryEntry(PeDirectoryEntry directoryId);
    public SectionHeader[] get_Sections();
    public CLIHeader get_CLIHeader();
    public MetadataHeader get_MetadataHeader();
    public IBinaryReader get_Reader();
    [CanBeNullAttribute]
public PEDirectoryBase GetDirectory(PeDirectoryEntry directoryId);
    public int RvaToVa(UInt32 rva);
    [CanBeNullAttribute]
public SectionHeader RvaToSection(UInt32 rva);
    public bool get_IsValid();
    private static PEDirectoryBase CreateDirectory(PeDirectoryEntry directoryId, int dirSize);
}
[ExtensionAttribute]
public static class JetBrains.Metadata.Utils.PE.PEFileEx : object {
    [CompilerGeneratedAttribute]
private static Func`2<Entry, DebugInfo> CS$<>9__CachedAnonymousMethodDelegate1;
    [CompilerGeneratedAttribute]
private static Func`2<Entry, DebugDataInfo> CS$<>9__CachedAnonymousMethodDelegate3;
    [CompilerGeneratedAttribute]
private static Func`2<Entry, Byte[]> CS$<>9__CachedAnonymousMethodDelegate6;
    [CompilerGeneratedAttribute]
private static Func`2<Byte[], bool> CS$<>9__CachedAnonymousMethodDelegate7;
    [ExtensionAttribute]
[NotNullAttribute]
public static IList`1<DebugInfo> GetDebugInfos(PEFile peFile);
    [ObsoleteAttribute("Use PEFileEx.GetDebugInfos instead")]
[ExtensionAttribute]
[NotNullAttribute]
public static IList`1<DebugInfo7> GetDebugInfos7(PEFile peFile);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static Byte[] GetDecompressedEmbeddedPortablePdb(PEFile peFile);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static EntireResourceDirectory GetResources(PEFile peFile);
    [ExtensionAttribute]
public static MetadataToken GetEntryPoint(PEFile peFile);
    [CompilerGeneratedAttribute]
private static DebugInfo <GetDebugInfos>b__0(Entry entry);
    [CompilerGeneratedAttribute]
private static DebugDataInfo <GetDebugInfos7>b__2(Entry entry);
    [CompilerGeneratedAttribute]
private static Byte[] <GetDecompressedEmbeddedPortablePdb>b__4(Entry entry);
    [CompilerGeneratedAttribute]
private static bool <GetDecompressedEmbeddedPortablePdb>b__5(Byte[] b);
}
public class JetBrains.Metadata.Utils.PE.PEHeader : object {
    private UInt32 myBaseOfCode;
    private UInt32 mySizeOfCode;
    private UInt32 myAddressOfEntryPoint;
    private UInt32 mySizeOfInitializedData;
    private byte myLinkerVersionMinor;
    private byte myLinkVersionMajor;
    private PESignature myMagic;
    private UInt32 mySizeOfUninitializedData;
    public PESignature Magic { get; }
    public byte MajorLinkerVersion { get; }
    public byte MinorLinkerVersion { get; }
    public UInt32 SizeOfCode { get; }
    public UInt32 SizeOfInitializedData { get; }
    public UInt32 SizeOfUninitializedData { get; }
    public UInt32 AddressOfEntryPoint { get; }
    public UInt32 BaseOfCode { get; }
    public PEHeader(IBinaryReader reader);
    public PESignature get_Magic();
    public byte get_MajorLinkerVersion();
    public byte get_MinorLinkerVersion();
    public UInt32 get_SizeOfCode();
    public UInt32 get_SizeOfInitializedData();
    public UInt32 get_SizeOfUninitializedData();
    public UInt32 get_AddressOfEntryPoint();
    public UInt32 get_BaseOfCode();
}
public enum JetBrains.Metadata.Utils.PE.PESignature : Enum {
    public ushort value__;
    public static PESignature PE_32BIT;
    public static PESignature PE_64BIT;
    public static PESignature PE_ROM;
}
[FlagsAttribute]
public enum JetBrains.Metadata.Utils.PE.SectionCharacteristics : Enum {
    public UInt32 value__;
    public static SectionCharacteristics TypeDsect;
    public static SectionCharacteristics TypeNoload;
    public static SectionCharacteristics TypeGroup;
    public static SectionCharacteristics TypeNoPad;
    public static SectionCharacteristics TypeCopy;
    public static SectionCharacteristics CntCode;
    public static SectionCharacteristics CntInitializedData;
    public static SectionCharacteristics CntUninitializedData;
    public static SectionCharacteristics LnkOther;
    public static SectionCharacteristics LnkInfo;
    public static SectionCharacteristics TypeOver;
    public static SectionCharacteristics LnkRemove;
    public static SectionCharacteristics LnkComdat;
    public static SectionCharacteristics NoDeferSpecExc;
    public static SectionCharacteristics Gprel;
    public static SectionCharacteristics MemPurgeable;
    public static SectionCharacteristics Mem16Bit;
    public static SectionCharacteristics MemLocked;
    public static SectionCharacteristics MemPreload;
    public static SectionCharacteristics AlignMask;
    public static SectionCharacteristics AlignDefault;
    public static SectionCharacteristics AlignReserved;
    public static SectionCharacteristics Align1Bytes;
    public static SectionCharacteristics Align2Bytes;
    public static SectionCharacteristics Align4Bytes;
    public static SectionCharacteristics Align8Bytes;
    public static SectionCharacteristics Align16Bytes;
    public static SectionCharacteristics Align32Bytes;
    public static SectionCharacteristics Align64Bytes;
    public static SectionCharacteristics Align128Bytes;
    public static SectionCharacteristics Align256Bytes;
    public static SectionCharacteristics Align512Bytes;
    public static SectionCharacteristics Align1024Bytes;
    public static SectionCharacteristics Align2048Bytes;
    public static SectionCharacteristics Align4096Bytes;
    public static SectionCharacteristics Align8192Bytes;
    public static SectionCharacteristics LnkNrelocOvfl;
    public static SectionCharacteristics MemDiscardable;
    public static SectionCharacteristics MemNotCached;
    public static SectionCharacteristics MemNotPaged;
    public static SectionCharacteristics MemShared;
    public static SectionCharacteristics MemExecute;
    public static SectionCharacteristics MemRead;
    public static SectionCharacteristics MemWrite;
}
[DebuggerDisplayAttribute("Start={myVirtualAddress} Size={myVirtualSize}")]
public class JetBrains.Metadata.Utils.PE.SectionHeader : object {
    private SectionCharacteristics myCharacteristics;
    private ushort myNumberOfLineNumbers;
    private int myPointerToLineNumbers;
    private string myName;
    private int myPointerToRawData;
    private int mySizeOfRawData;
    private ushort myNumberOfRelocations;
    private int myPointerToRelocations;
    private int myVirtualAddress;
    private int myVirtualSize;
    public string Name { get; }
    public int VirtualSize { get; }
    public int VirtualAddress { get; }
    public int SizeOfRawData { get; }
    public int PointerToRawData { get; }
    public int PointerToRelocations { get; }
    public int PointerToLineNumbers { get; }
    public ushort NumberOfRelocations { get; }
    public ushort NumberOfLineNumbers { get; }
    public SectionCharacteristics Characteristics { get; }
    public SectionHeader(IBinaryReader reader);
    public string get_Name();
    public int get_VirtualSize();
    public int get_VirtualAddress();
    public int get_SizeOfRawData();
    public int get_PointerToRawData();
    public int get_PointerToRelocations();
    public int get_PointerToLineNumbers();
    public ushort get_NumberOfRelocations();
    public ushort get_NumberOfLineNumbers();
    public SectionCharacteristics get_Characteristics();
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Metadata.Utils.PE.SectionHeaderTable : DictionaryBase {
    public SectionHeader Item { get; }
    public SectionHeader get_Item(string name);
    internal void AddSection(SectionHeader hdr);
}
public class JetBrains.Metadata.Utils.PE.StreamHeader : object {
    private string myName;
    private int myAlignedNameLength;
    private int myOffset;
    private int mySize;
    public int Offset { get; }
    public int Size { get; }
    public string Name { get; }
    public int StreamHeaderSize { get; }
    public int AlignedNameLength { get; }
    public StreamHeader(IBinaryReader reader);
    public int get_Offset();
    public int get_Size();
    public string get_Name();
    public int get_StreamHeaderSize();
    public int get_AlignedNameLength();
}
public enum JetBrains.Metadata.Utils.PE.Subsystem : Enum {
    public ushort value__;
    public static Subsystem UNKNOWN;
    public static Subsystem NATIVE;
    public static Subsystem WINDOWS_GUI;
    public static Subsystem WINDOWS_CUI;
    public static Subsystem OS2_CUI;
    public static Subsystem POSIX_CUI;
    public static Subsystem NATIVE_WINDOWS;
    public static Subsystem WINDOWS_CE_GUI;
    public static Subsystem EFI_APPLICATION;
    public static Subsystem EFI_BOOT_SERVICE_DRIVER;
    public static Subsystem EFI_RUNTIME_DRIVER;
    public static Subsystem EFI_ROM;
    public static Subsystem XBOX;
    public static Subsystem WINDOWS_BOOT_APPLICATION;
}
[ExtensionAttribute]
public static class JetBrains.Metadata.Utils.PE.UserStrings : object {
    public static int UserStringHeapId;
    [ExtensionAttribute]
public static bool IsUserString(MetadataToken token);
    public static MetadataToken CreateUserStringToken(int offset);
}
[FlagsAttribute]
public enum JetBrains.Metadata.Utils.SdkAppliesTo : Enum {
    public int value__;
    public static SdkAppliesTo WindowsAppContainer;
    public static SdkAppliesTo VisualC;
    public static SdkAppliesTo VB;
    public static SdkAppliesTo CSharp;
    public static SdkAppliesTo WindowsXAML;
    public static SdkAppliesTo JavaScript;
    public static SdkAppliesTo Managed;
    public static SdkAppliesTo Native;
    public static SdkAppliesTo Undefined;
}
public class JetBrains.Metadata.Utils.SdkModuleInfo : object {
    private string myIdentity;
    private string myVersion;
    private bool myIsPlatformSdk;
    private SdkAppliesTo myAppliesTo;
    private FileSystemPath myManifestPath;
    private ICollection`1<FileSystemPath> myNestedAssemblies;
    private JetHashSet`1<FileSystemPath> myContentFiles;
    private JetHashSet`1<FileSystemPath> myHierarchyItems;
    private string mySdkName;
    private FileSystemPath myRootFolderForContentFiles;
    private List`1<string> mySdkDependencies;
    public string Identity { get; }
    public FileSystemPath ManifestPath { get; }
    public ICollection`1<FileSystemPath> NestedAssemblies { get; }
    [CanBeNullAttribute]
public FileSystemPath RootFolderForContentFiles { get; }
    public JetHashSet`1<FileSystemPath> ContentFiles { get; }
    public JetHashSet`1<FileSystemPath> HierarchyItems { get; }
    public string SdkName { get; }
    public string Version { get; }
    public bool IsPlatformSdk { get; }
    public List`1<string> SdkDependencies { get; }
    public SdkAppliesTo AppliesTo { get; }
    public SdkModuleInfo(string sdkName, FileSystemPath sdkManifestPath, FileSystemPath contentRootPath, string identity, string version, bool isPlatformSdk, SdkAppliesTo appliesTo);
    public string get_Identity();
    public FileSystemPath get_ManifestPath();
    public ICollection`1<FileSystemPath> get_NestedAssemblies();
    public FileSystemPath get_RootFolderForContentFiles();
    public JetHashSet`1<FileSystemPath> get_ContentFiles();
    public JetHashSet`1<FileSystemPath> get_HierarchyItems();
    public string get_SdkName();
    public string get_Version();
    public bool get_IsPlatformSdk();
    public List`1<string> get_SdkDependencies();
    public SdkAppliesTo get_AppliesTo();
    public void AddContentItem(FileSystemPath absoluteFilePath);
    public void TryAddNestedAssembly(FileSystemPath absoluteFilePath);
    public void DumpShort(TextWriter to);
    public void RetriveAdditionalInfo(XmlElement fileListElement);
    public void DumpFull(TextWriter to);
}
public class JetBrains.Metadata.Utils.StreamBinaryReader : object {
    private static int InternalBufferSize;
    [NotNullAttribute]
private Stream myStream;
    private int myBufSizePositionInStream;
    [NotNullAttribute]
private Byte[] myBuf;
    private int myBufPos;
    private int myBufSize;
    public int Position { get; public set; }
    public int Length { get; }
    public StreamBinaryReader(Stream stream);
    public StreamBinaryReader(Stream stream, int position);
    public StreamBinaryReader(Stream stream, int position, int customBufferSize);
    public sealed virtual int get_Position();
    public sealed virtual void set_Position(int value);
    public sealed virtual int get_Length();
    public sealed virtual IBinaryReader Clone();
    public sealed virtual char ReadChar();
    public sealed virtual float ReadSingle();
    public sealed virtual double ReadDouble();
    public sealed virtual short ReadInt16();
    public sealed virtual sbyte ReadSByte();
    public sealed virtual byte ReadUInt8();
    public sealed virtual ushort ReadUInt16();
    public sealed virtual int ReadInt32();
    public sealed virtual UInt32 ReadUInt32();
    public sealed virtual long ReadInt64();
    public sealed virtual ulong ReadUInt64();
    public sealed virtual void Read(Byte[] buffer, int offset, int count);
    public sealed virtual byte ReadByte();
    public sealed virtual string ReadStringUtf8();
    public sealed virtual string ReadStringUtf16le(int cbLength);
    public sealed virtual UInt32 ReadCompressedInteger();
    public sealed virtual string ReadUtf8Constant();
    public sealed virtual void Skip(int bytes);
    private void PrepareStream();
    private void FillBuffer(int bytes);
    private void FillBufferCore(int bytes);
    [ConditionalAttribute("JET_MODE_ASSERT_PARANOID")]
private void AssertValidBuffer();
}
public class JetBrains.Metadata.Utils.TargetPlatformData : object {
    private bool myIsEmpty;
    [CompilerGeneratedAttribute]
private string <TargetPlatformIdentifier>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetPlatformVersion>k__BackingField;
    [NotNullAttribute]
public string TargetPlatformIdentifier { get; private set; }
    [NotNullAttribute]
public string TargetPlatformVersion { get; private set; }
    public bool IsEmpty { get; }
    public TargetPlatformData(string targetPlatformIdentifier, string targetPlatformVersion);
    [CompilerGeneratedAttribute]
public string get_TargetPlatformIdentifier();
    [CompilerGeneratedAttribute]
private void set_TargetPlatformIdentifier(string value);
    [CompilerGeneratedAttribute]
public string get_TargetPlatformVersion();
    [CompilerGeneratedAttribute]
private void set_TargetPlatformVersion(string value);
    public void Write(BinaryWriter writer);
    public void Read(BinaryReader reader);
    public bool get_IsEmpty();
    public static void WriteEmpty(BinaryWriter writer);
}
public static class JetBrains.Metadata.Utils.ToolLocationHelper : object {
    private static string Annotated;
    private static string RedistFolder;
    private static string ReferencesFolder;
    private static string DesignTimeFolder;
    private static string DebugConfiguration;
    private static string RetailConfiguration;
    private static string CommonConfiguration;
    private static string NeutralArchitecture;
    private static string AnyCPU;
    private static string Amd64;
    private static string Msil;
    private static string X64;
    private static string X86;
    private static string ARM;
    public static string SDKManifestFileName;
    [CompilerGeneratedAttribute]
private static Func`2<FileSystemPath, bool> CS$<>9__CachedAnonymousMethodDelegate1;
    [CompilerGeneratedAttribute]
private static Func`2<char, char> CS$<>9__CachedAnonymousMethodDelegate13;
    private static ToolLocationHelper();
    public static ICollection`1<FileSystemPath> GetContentRoots(FileSystemPath sdkRoot, string targetConfiguration, string targetArchitecture);
    public static ICollection`1<FileSystemPath> GetContentRootsForSpecifiedTargetPlatform(FileSystemPath sdkRoot, string targetArchitecture);
    private static IEnumerable`1<FileSystemPath> ReadFolder(string rootFolderName, string targetArchitecture, FileSystemPath sdkRootPath);
    public static IEnumerable`1<FileSystemPath> EnumerateContentRoots(FileSystemPath sdkRoot, string targetConfiguration, string targetArchitecture);
    private static IEnumerable`1<FileSystemPath> ReadFolder(string rootFolderName, string targetConfiguration, string targetArchitecture, FileSystemPath sdkRootPath);
    private static string RemapSdkArchitecture(string targetArchitecture);
    [CanBeNullAttribute]
private static FileSystemPath Combine(FileSystemPath sdkRootPath, string contentFolderName, string targetConfiguration, string targetArchitecture);
    [CanBeNullAttribute]
public static SdkModuleInfo GetSdkModuleInfo(FileSystemPath manifestPath, ICollection`1<FileSystemPath> contentRoots);
    private static bool IsRedistContentRoot(FileSystemPath contentRoot);
    private static void FillContents(IEnumerable`1<FileSystemPath> contentRoots, XmlElement fileListElement, SdkModuleInfo result, XmlDocument sdkManifestDoc);
    [CanBeNullAttribute]
private static SdkModuleInfo RetrieveSdkModuleInfo(FileSystemPath contentRoot, FileSystemPath manifestPath, XmlElement fileListElement);
    private static SdkAppliesTo ParseAppliesTo(string value);
    [NotNullAttribute]
public static FileSystemPath GetPlatformSDKPath(TargetPlatformData targetPlatformData);
    private static string CreatePlatfromSdkIdentity(string sdkName, string sdkVersion);
    private static string CreateExtensionSdkIdentity(string sdkName, XmlElement fileListElement, String& name, String& version);
    private static void FillContentItems(FileSystemPath contentRoot, SdkModuleInfo result, string mask);
    private static void FillNestedAssemblies(FileSystemPath contentRoot, SdkModuleInfo result, bool addOnlyWinmd);
    [CompilerGeneratedAttribute]
private static bool <GetContentRoots>b__0(FileSystemPath path);
    [CompilerGeneratedAttribute]
private static char <GetSdkModuleInfo>b__12(char c);
}
public abstract class JetBrains.Metadata.Utils.TypeName.AbstractTypeNameParser`1 : object {
    private TypeNameParserArrayRanksOrder myArrayRanksOrder;
    [CompilerGeneratedAttribute]
private string <TypeName>k__BackingField;
    [NotNullAttribute]
protected string TypeName { get; private set; }
    protected AbstractTypeNameParser`1(string typeName);
    protected AbstractTypeNameParser`1(string typeName, TypeNameParserArrayRanksOrder arrayRanksOrder);
    [CompilerGeneratedAttribute]
protected string get_TypeName();
    [CompilerGeneratedAttribute]
private void set_TypeName(string value);
    [NotNullAttribute]
public TType Parse();
    [NotNullAttribute]
protected abstract virtual TType CreateUnresolvedType(string typeName, TextRange typeNameRange);
    [NotNullAttribute]
private TType CreatePlainType(ParsedName parsed, string assemblyName, TextRange assemblyNameRange, TextRange assemblyFullNameRange);
    [NotNullAttribute]
protected abstract virtual TType CreateTypeByNameAndAssembly(string typeName, TextRange typeNameRange, string assemblyName, TextRange assemblyNameRange, TextRange assemblyFullNameRange, TType[] genericArguments);
    [NotNullAttribute]
private TType CreateQualifiedType(ParsedName parsed, string assemblyName, TextRange assemblyNameRange, TextRange assemblyFullNameRange);
    [NotNullAttribute]
protected abstract virtual TType CreatePointerType(TType elementType);
    [NotNullAttribute]
protected abstract virtual TType CreateArrayType(TType elementType, UInt32 rank, UInt32[] sizes, Int32[] lBounds);
    [NotNullAttribute]
protected abstract virtual TType CreateArrayType(TType elementType);
    [NotNullAttribute]
protected abstract virtual TType CreateReferenceType(TType elementType);
    [NotNullAttribute]
private TType CreateTypeFromParsedName(ParsedName parsed);
}
public class JetBrains.Metadata.Utils.TypeName.InvalidTypeNameException : Exception {
    public InvalidTypeNameException(string message);
    public InvalidTypeNameException(string message, Exception exInner);
}
internal class JetBrains.Metadata.Utils.TypeName.NameToken : Token {
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private TextRange <Range>k__BackingField;
    public string Value { get; private set; }
    public TextRange Range { get; private set; }
    public NameToken(string val, TextRange range);
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(string value);
    [CompilerGeneratedAttribute]
public TextRange get_Range();
    [CompilerGeneratedAttribute]
private void set_Range(TextRange value);
    public virtual string ToString();
}
internal class JetBrains.Metadata.Utils.TypeName.Parser : object {
    private Lexer myLex;
    private Stack`1<ParsedName> myNameStack;
    private Token myCurrentToken;
    private Token myNextToken;
    public ParsedName TypeName { get; }
    private ParsedName Context { get; }
    public Parser(string name);
    public ParsedName get_TypeName();
    private void Advance();
    private ParsedName get_Context();
    private bool START();
    private bool AQN();
    private bool ASSEMSPEC();
    private bool FULLNAME();
    private bool GENPARAMS();
    private bool GENARGS();
    private bool GENARG();
    private bool EAQN();
    private bool QUALIFIER();
    private bool ARRAY();
    private bool RANK(UInt32& rank);
    private bool NAME();
}
internal class JetBrains.Metadata.Utils.TypeName.Token : object {
    private TokenType myType;
    public TokenType Type { get; }
    public Token(TokenType t);
    public TokenType get_Type();
    public virtual string ToString();
    public bool IsType(TokenType type);
}
[FlagsAttribute]
internal enum JetBrains.Metadata.Utils.TypeName.TokenType : Enum {
    public int value__;
    public static TokenType Empty;
    public static TokenType Identifier;
    public static TokenType OpenSqBracket;
    public static TokenType CloseSqBracket;
    public static TokenType Comma;
    public static TokenType Astrix;
    public static TokenType Amperstand;
    public static TokenType Apostrof;
    public static TokenType End;
    public static TokenType NAME;
    public static TokenType ASSEMSPEC;
    public static TokenType GENPARAM;
    public static TokenType FULLNAME;
    public static TokenType AQN;
    public static TokenType GENARG;
    public static TokenType GENARGS;
    public static TokenType EAQN;
    public static TokenType ARRAY;
    public static TokenType QUALIFIER;
    public static TokenType RANK;
}
public enum JetBrains.Metadata.Utils.TypeName.TypeNameParserArrayRanksOrder : Enum {
    public int value__;
    public static TypeNameParserArrayRanksOrder MSIL;
    public static TypeNameParserArrayRanksOrder CSHARP;
}
public class JetBrains.Metadata.Utils.UnmanagedBlob : object {
    public static UnmanagedBlob Empty;
    private UnmanagedBlock myBuffer;
    private Byte* myBuf;
    private int myLimit;
    private int myStartOffset;
    internal IntPtr InternalBuffer { get; }
    internal UnmanagedBlock InternalUnmanagedBlock { get; }
    public int Length { get; }
    internal int InternalStartOffset { get; }
    public UnmanagedBlob(UnmanagedBlock block);
    public UnmanagedBlob(UnmanagedBlob source);
    public UnmanagedBlob(UnmanagedBlob source, int start);
    public UnmanagedBlob(UnmanagedBlob source, int start, int length);
    private static UnmanagedBlob();
    internal IntPtr get_InternalBuffer();
    internal UnmanagedBlock get_InternalUnmanagedBlock();
    public sealed virtual int get_Length();
    internal int get_InternalStartOffset();
    public sealed virtual IBlob Clone();
    public sealed virtual IBinaryReader CreateReader(int position);
    public sealed virtual IBlob Slice(int position, int length);
    public sealed virtual byte ReadByte(int offset);
    public sealed virtual ushort ReadUInt16(int offset);
    public sealed virtual UInt32 ReadUInt32(int offset);
    public sealed virtual string ReadStringUtf8(int offset, Int32& bytesLen);
    public sealed virtual void Read(int sourceOffset, Byte[] buffer, int bufferOffset, int count);
    public sealed virtual UInt32 ReadCompressedInteger(int offset, Int32& size);
    public sealed virtual string ReadUtf8Constant(int offset, Int32& len);
    private string Read0TerminatedString(int startOffset, Int32& actualStringLength);
    public sealed virtual ulong ReadUInt64(int offset);
}
