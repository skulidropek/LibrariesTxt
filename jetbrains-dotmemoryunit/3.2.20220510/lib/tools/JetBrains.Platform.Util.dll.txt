[ObsoleteAttribute("No usages in ReSharper")]
[ThreadUnsafeAttribute]
public static class JetBrains.ActivityCollector.ActivityCollector : object {
    private static byte THREAD_RECORD_ID;
    private static byte ACTIVITY_RECORD_ID;
    private static BinaryWriter myBinaryWriter;
    private static object myLock;
    private static Dictionary`2<int, ActivityEndpoint> myRegisteredThreads;
    private static ActivityCollector();
    public static ActivityEndpoint GetEndpoint();
    public static void Flush();
    private static void EnsureWriter();
    private static void EnsureThread();
    private static void RegisterThread(int id, string name);
    private static void WriteActivity(Activity activity);
}
public class JetBrains.ActivityCollector.Key : object {
    private string myName;
    public string Name { get; }
    public Key(string name);
    public string get_Name();
}
[NoReorderAttribute]
[ExtensionAttribute]
public static class JetBrains.Application.Icons.Emitters.SvgCssGrammar : object {
    public static Parser`1<string> Property;
    public static Parser`1<int> UnaryOperator;
    public static Parser`1<string> Hexcolor;
    public static Parser`1<DimWithSign> TermDim;
    public static Parser`1<string> TermNonDim;
    public static Parser`1<object> Term;
    public static Parser`1<char> Operator;
    public static Parser`1<object> Expr;
    public static Parser`1<ParsedDeclaration> Declaration;
    public static Parser`1<ICollection`1<ParsedDeclaration>> InlineRuleset;
    [CompilerGeneratedAttribute]
private static Func`2<string, Parser`1<IOption`1<IEnumerable`1<char>>>> CS$<>9__CachedAnonymousMethodDelegate29;
    [CompilerGeneratedAttribute]
private static Func`3<string, IOption`1<IEnumerable`1<char>>, string> CS$<>9__CachedAnonymousMethodDelegate2a;
    [CompilerGeneratedAttribute]
private static Func`2<char, int> CS$<>9__CachedAnonymousMethodDelegate2b;
    [CompilerGeneratedAttribute]
private static Func`2<char, int> CS$<>9__CachedAnonymousMethodDelegate2c;
    [CompilerGeneratedAttribute]
private static Func`2<IOption`1<int>, Parser`1<DIM>> CS$<>9__CachedAnonymousMethodDelegate2d;
    [CompilerGeneratedAttribute]
private static Func`3<IOption`1<int>, DIM, DimWithSign> CS$<>9__CachedAnonymousMethodDelegate2e;
    [CompilerGeneratedAttribute]
private static Func`2<DimWithSign, object> CS$<>9__CachedAnonymousMethodDelegate2f;
    [CompilerGeneratedAttribute]
private static Func`2<string, object> CS$<>9__CachedAnonymousMethodDelegate30;
    [CompilerGeneratedAttribute]
private static Func`2<IEnumerable`1<char>, char> CS$<>9__CachedAnonymousMethodDelegate31;
    [CompilerGeneratedAttribute]
private static Func`2<object, Parser`1<IEnumerable`1<Pair`2<char, object>>>> CS$<>9__CachedAnonymousMethodDelegate32;
    [CompilerGeneratedAttribute]
private static Func`3<object, IEnumerable`1<Pair`2<char, object>>, object> CS$<>9__CachedAnonymousMethodDelegate33;
    [CompilerGeneratedAttribute]
private static Func`2<string, Parser`1<char>> CS$<>9__CachedAnonymousMethodDelegate34;
    [CompilerGeneratedAttribute]
private static Func`3<string, char, <>f__AnonymousType0`2<string, char>> CS$<>9__CachedAnonymousMethodDelegate35;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType0`2<string, char>, Parser`1<IOption`1<IEnumerable`1<char>>>> CS$<>9__CachedAnonymousMethodDelegate36;
    [CompilerGeneratedAttribute]
private static Func`3<<>f__AnonymousType0`2<string, char>, IOption`1<IEnumerable`1<char>>, <>f__AnonymousType1`2<<>f__AnonymousType0`2<string, char>, IOption`1<IEnumerable`1<char>>>> CS$<>9__CachedAnonymousMethodDelegate37;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType1`2<<>f__AnonymousType0`2<string, char>, IOption`1<IEnumerable`1<char>>>, Parser`1<object>> CS$<>9__CachedAnonymousMethodDelegate38;
    [CompilerGeneratedAttribute]
private static Func`3<<>f__AnonymousType1`2<<>f__AnonymousType0`2<string, char>, IOption`1<IEnumerable`1<char>>>, object, ParsedDeclaration> CS$<>9__CachedAnonymousMethodDelegate39;
    [CompilerGeneratedAttribute]
private static Func`2<IOption`1<IEnumerable`1<char>>, Parser`1<ParsedDeclaration>> CS$<>9__CachedAnonymousMethodDelegate3a;
    [CompilerGeneratedAttribute]
private static Func`3<IOption`1<IEnumerable`1<char>>, ParsedDeclaration, <>f__AnonymousType2`2<IOption`1<IEnumerable`1<char>>, ParsedDeclaration>> CS$<>9__CachedAnonymousMethodDelegate3b;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType2`2<IOption`1<IEnumerable`1<char>>, ParsedDeclaration>, Parser`1<IEnumerable`1<ParsedDeclaration>>> CS$<>9__CachedAnonymousMethodDelegate3c;
    [CompilerGeneratedAttribute]
private static Func`3<<>f__AnonymousType2`2<IOption`1<IEnumerable`1<char>>, ParsedDeclaration>, IEnumerable`1<ParsedDeclaration>, ICollection`1<ParsedDeclaration>> CS$<>9__CachedAnonymousMethodDelegate3d;
    [CompilerGeneratedAttribute]
private static Func`2<char, Parser`1<object>> CS$<>9__CachedAnonymousMethodDelegate3e;
    [CompilerGeneratedAttribute]
private static Func`3<char, object, Pair`2<char, object>> CS$<>9__CachedAnonymousMethodDelegate3f;
    [CompilerGeneratedAttribute]
private static Func`2<char, Parser`1<ParsedDeclaration>> CS$<>9__CachedAnonymousMethodDelegate40;
    [CompilerGeneratedAttribute]
private static Func`3<char, ParsedDeclaration, ParsedDeclaration> CS$<>9__CachedAnonymousMethodDelegate41;
    private static SvgCssGrammar();
    [ExtensionAttribute]
public static Parser`1<T> ThenS(Parser`1<T> main);
    [CompilerGeneratedAttribute]
private static Parser`1<T> <ThenS>b__0(T value);
    [CompilerGeneratedAttribute]
private static Parser`1<IOption`1<IEnumerable`1<char>>> <.cctor>b__10(string ident);
    [CompilerGeneratedAttribute]
private static string <.cctor>b__11(string ident, IOption`1<IEnumerable`1<char>> ws);
    [CompilerGeneratedAttribute]
private static int <.cctor>b__12(char o);
    [CompilerGeneratedAttribute]
private static int <.cctor>b__13(char o);
    [CompilerGeneratedAttribute]
private static Parser`1<DIM> <.cctor>b__14(IOption`1<int> uo);
    [CompilerGeneratedAttribute]
private static DimWithSign <.cctor>b__15(IOption`1<int> uo, DIM dim);
    [CompilerGeneratedAttribute]
private static object <.cctor>b__16(DimWithSign dim);
    [CompilerGeneratedAttribute]
private static object <.cctor>b__17(string s);
    [CompilerGeneratedAttribute]
private static char <.cctor>b__18(IEnumerable`1<char> s);
    [CompilerGeneratedAttribute]
private static Parser`1<IEnumerable`1<Pair`2<char, object>>> <.cctor>b__19(object head);
    [CompilerGeneratedAttribute]
private static object <.cctor>b__1c(object head, IEnumerable`1<Pair`2<char, object>> tail);
    [CompilerGeneratedAttribute]
private static Parser`1<char> <.cctor>b__1d(string prop);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType0`2<string, char> <.cctor>b__1e(string prop, char colon);
    [CompilerGeneratedAttribute]
private static Parser`1<IOption`1<IEnumerable`1<char>>> <.cctor>b__1f(<>f__AnonymousType0`2<string, char> <>h__TransparentIdentifier8);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType1`2<<>f__AnonymousType0`2<string, char>, IOption`1<IEnumerable`1<char>>> <.cctor>b__20(<>f__AnonymousType0`2<string, char> <>h__TransparentIdentifier8, IOption`1<IEnumerable`1<char>> ws);
    [CompilerGeneratedAttribute]
private static Parser`1<object> <.cctor>b__21(<>f__AnonymousType1`2<<>f__AnonymousType0`2<string, char>, IOption`1<IEnumerable`1<char>>> <>h__TransparentIdentifier9);
    [CompilerGeneratedAttribute]
private static ParsedDeclaration <.cctor>b__22(<>f__AnonymousType1`2<<>f__AnonymousType0`2<string, char>, IOption`1<IEnumerable`1<char>>> <>h__TransparentIdentifier9, object expr);
    [CompilerGeneratedAttribute]
private static Parser`1<ParsedDeclaration> <.cctor>b__23(IOption`1<IEnumerable`1<char>> w1);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType2`2<IOption`1<IEnumerable`1<char>>, ParsedDeclaration> <.cctor>b__24(IOption`1<IEnumerable`1<char>> w1, ParsedDeclaration head);
    [CompilerGeneratedAttribute]
private static Parser`1<IEnumerable`1<ParsedDeclaration>> <.cctor>b__25(<>f__AnonymousType2`2<IOption`1<IEnumerable`1<char>>, ParsedDeclaration> <>h__TransparentIdentifierb);
    [CompilerGeneratedAttribute]
private static ICollection`1<ParsedDeclaration> <.cctor>b__28(<>f__AnonymousType2`2<IOption`1<IEnumerable`1<char>>, ParsedDeclaration> <>h__TransparentIdentifierb, IEnumerable`1<ParsedDeclaration> tail);
    [CompilerGeneratedAttribute]
private static Parser`1<object> <.cctor>b__1a(char operator);
    [CompilerGeneratedAttribute]
private static Pair`2<char, object> <.cctor>b__1b(char operator, object term);
    [CompilerGeneratedAttribute]
private static Parser`1<ParsedDeclaration> <.cctor>b__26(char semi);
    [CompilerGeneratedAttribute]
private static ParsedDeclaration <.cctor>b__27(char semi, ParsedDeclaration item);
}
public static class JetBrains.Application.Icons.Emitters.SvgFile : object {
}
[NoReorderAttribute]
public static class JetBrains.Application.Icons.Emitters.SvgGrammar : object {
    public static Parser`1<char> Wsp;
    private static Parser`1<IOption`1<IEnumerable`1<char>>> WspStar;
    public static Parser`1<char> Digit;
    public static Parser`1<string> DigitSequence;
    public static Parser`1<string> Sign;
    public static Parser`1<string> Exponent;
    public static Parser`1<string> FractionalConstant;
    public static Parser`1<string> FloatingPointConstant;
    public static Parser`1<string> IntegerConstant;
    public static Parser`1<char> Comma;
    public static Parser`1<char> CommaWsp;
    public static Parser`1<bool> Flag;
    public static Parser`1<double> Number;
    public static Parser`1<double> NonnegativeNumber;
    public static Parser`1<double> Coordinate;
    public static Parser`1<Point> CoordinatePair;
    public static Parser`1<S> EllipticalArcArgument;
    public static Parser`1<ICollection`1<S>> EllipticalArc;
    public static Parser`1<ICollection`1<S>> VerticalLineto;
    public static Parser`1<ICollection`1<S>> HorizontalLineto;
    public static Parser`1<ICollection`1<S>> Moveto;
    public static Parser`1<ICollection`1<S>> Lineto;
    public static Parser`1<S> CurvetoArgument;
    public static Parser`1<ICollection`1<S>> Curveto;
    public static Parser`1<S> SmoothCurvetoArgument;
    public static Parser`1<ICollection`1<S>> SmoothCurveto;
    public static Parser`1<S> QuadraticBezierCurvetoArgument;
    public static Parser`1<ICollection`1<S>> QuadraticBezierCurveto;
    public static Parser`1<S> SmoothQuadraticBezierCurvetoArgument;
    public static Parser`1<ICollection`1<S>> SmoothQuadraticBezierCurveto;
    public static Parser`1<SZ> Closepath;
    public static Parser`1<ICollection`1<S>> DrawtoCommand;
    public static Parser`1<ICollection`1<S>> DrawtoCommands;
    public static Parser`1<ICollection`1<S>> MovetoDrawtoCommandGroup;
    public static Parser`1<ICollection`1<S>> MovetoDrawtoCommandGroups;
    public static Parser`1<ICollection`1<S>> SvgPath;
    public static Parser`1<ICollection`1<Point>> CoordinatePairs;
    public static Parser`1<ICollection`1<Point>> ListOfPoints;
    public static Parser`1<string> BdtName;
    public static Parser`1<byte> BdtHexDigit;
    public static Parser`1<Color> BdtColorRgb;
    public static Parser`1<Color> BdtColorArgb;
    public static Parser`1<Color> BdtColorRrggbb;
    public static Parser`1<Color> BdtColorAarrggbb;
    public static Parser`1<Color> BdtColor;
    public static Parser`1<string> BdtFuncIri;
    public static Parser`1<Nullable`1<ColorOrIri>> Paint;
    public static Parser`1<Transform> Matrix;
    public static Parser`1<Transform> Translate;
    public static Parser`1<Transform> Scale;
    public static Parser`1<Transform> Rotate;
    public static Parser`1<Transform> SkewX;
    public static Parser`1<Transform> SkewY;
    public static Parser`1<Transform> Transform;
    public static Parser`1<Transform> Transforms;
    public static Parser`1<Transform> TransformList;
    [CompilerGeneratedAttribute]
private static Predicate`1<char> CS$<>9__CachedAnonymousMethodDelegate196;
    [CompilerGeneratedAttribute]
private static Func`2<char, string> CS$<>9__CachedAnonymousMethodDelegate197;
    [CompilerGeneratedAttribute]
private static Func`2<char, Parser`1<IOption`1<string>>> CS$<>9__CachedAnonymousMethodDelegate198;
    [CompilerGeneratedAttribute]
private static Func`3<char, IOption`1<string>, <>f__AnonymousType6`2<char, IOption`1<string>>> CS$<>9__CachedAnonymousMethodDelegate199;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType6`2<char, IOption`1<string>>, Parser`1<string>> CS$<>9__CachedAnonymousMethodDelegate19a;
    [CompilerGeneratedAttribute]
private static Func`3<<>f__AnonymousType6`2<char, IOption`1<string>>, string, string> CS$<>9__CachedAnonymousMethodDelegate19b;
    [CompilerGeneratedAttribute]
private static Func`2<IOption`1<string>, Parser`1<char>> CS$<>9__CachedAnonymousMethodDelegate19c;
    [CompilerGeneratedAttribute]
private static Func`3<IOption`1<string>, char, <>f__AnonymousType7`2<IOption`1<string>, char>> CS$<>9__CachedAnonymousMethodDelegate19d;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType7`2<IOption`1<string>, char>, Parser`1<string>> CS$<>9__CachedAnonymousMethodDelegate19e;
    [CompilerGeneratedAttribute]
private static Func`3<<>f__AnonymousType7`2<IOption`1<string>, char>, string, string> CS$<>9__CachedAnonymousMethodDelegate19f;
    [CompilerGeneratedAttribute]
private static Func`2<string, Parser`1<char>> CS$<>9__CachedAnonymousMethodDelegate1a0;
    [CompilerGeneratedAttribute]
private static Func`3<string, char, string> CS$<>9__CachedAnonymousMethodDelegate1a1;
    [CompilerGeneratedAttribute]
private static Func`2<string, Parser`1<IOption`1<string>>> CS$<>9__CachedAnonymousMethodDelegate1a2;
    [CompilerGeneratedAttribute]
private static Func`3<string, IOption`1<string>, string> CS$<>9__CachedAnonymousMethodDelegate1a3;
    [CompilerGeneratedAttribute]
private static Func`2<string, Parser`1<string>> CS$<>9__CachedAnonymousMethodDelegate1a4;
    [CompilerGeneratedAttribute]
private static Func`3<string, string, string> CS$<>9__CachedAnonymousMethodDelegate1a5;
    [CompilerGeneratedAttribute]
private static Func`2<IEnumerable`1<char>, Parser`1<IOption`1<char>>> CS$<>9__CachedAnonymousMethodDelegate1a6;
    [CompilerGeneratedAttribute]
private static Func`3<IEnumerable`1<char>, IOption`1<char>, <>f__AnonymousType8`2<IEnumerable`1<char>, IOption`1<char>>> CS$<>9__CachedAnonymousMethodDelegate1a7;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType8`2<IEnumerable`1<char>, IOption`1<char>>, Parser`1<IOption`1<IEnumerable`1<char>>>> CS$<>9__CachedAnonymousMethodDelegate1a8;
    [CompilerGeneratedAttribute]
private static Func`3<<>f__AnonymousType8`2<IEnumerable`1<char>, IOption`1<char>>, IOption`1<IEnumerable`1<char>>, char> CS$<>9__CachedAnonymousMethodDelegate1a9;
    [CompilerGeneratedAttribute]
private static Func`2<char, Parser`1<IOption`1<IEnumerable`1<char>>>> CS$<>9__CachedAnonymousMethodDelegate1aa;
    [CompilerGeneratedAttribute]
private static Func`3<char, IOption`1<IEnumerable`1<char>>, char> CS$<>9__CachedAnonymousMethodDelegate1ab;
    [CompilerGeneratedAttribute]
private static Func`2<char, bool> CS$<>9__CachedAnonymousMethodDelegate1ac;
    [CompilerGeneratedAttribute]
private static Func`2<IOption`1<string>, Parser`1<string>> CS$<>9__CachedAnonymousMethodDelegate1ad;
    [CompilerGeneratedAttribute]
private static Func`3<IOption`1<string>, string, string> CS$<>9__CachedAnonymousMethodDelegate1ae;
    [CompilerGeneratedAttribute]
private static Func`2<IOption`1<string>, Parser`1<string>> CS$<>9__CachedAnonymousMethodDelegate1af;
    [CompilerGeneratedAttribute]
private static Func`3<IOption`1<string>, string, string> CS$<>9__CachedAnonymousMethodDelegate1b0;
    [CompilerGeneratedAttribute]
private static Func`2<string, double> CS$<>9__CachedAnonymousMethodDelegate1b1;
    [CompilerGeneratedAttribute]
private static Func`2<string, double> CS$<>9__CachedAnonymousMethodDelegate1b2;
    [CompilerGeneratedAttribute]
private static Func`2<double, Parser`1<IOption`1<char>>> CS$<>9__CachedAnonymousMethodDelegate1b3;
    [CompilerGeneratedAttribute]
private static Func`3<double, IOption`1<char>, <>f__AnonymousType9`2<double, IOption`1<char>>> CS$<>9__CachedAnonymousMethodDelegate1b4;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType9`2<double, IOption`1<char>>, Parser`1<double>> CS$<>9__CachedAnonymousMethodDelegate1b5;
    [CompilerGeneratedAttribute]
private static Func`3<<>f__AnonymousType9`2<double, IOption`1<char>>, double, Point> CS$<>9__CachedAnonymousMethodDelegate1b6;
    [CompilerGeneratedAttribute]
private static Func`2<double, Parser`1<IOption`1<char>>> CS$<>9__CachedAnonymousMethodDelegate1b7;
    [CompilerGeneratedAttribute]
private static Func`3<double, IOption`1<char>, <>f__AnonymousTypea`2<double, IOption`1<char>>> CS$<>9__CachedAnonymousMethodDelegate1b8;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousTypea`2<double, IOption`1<char>>, Parser`1<double>> CS$<>9__CachedAnonymousMethodDelegate1b9;
    [CompilerGeneratedAttribute]
private static Func`3<<>f__AnonymousTypea`2<double, IOption`1<char>>, double, <>f__AnonymousTypeb`2<<>f__AnonymousTypea`2<double, IOption`1<char>>, double>> CS$<>9__CachedAnonymousMethodDelegate1ba;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousTypeb`2<<>f__AnonymousTypea`2<double, IOption`1<char>>, double>, Parser`1<IOption`1<char>>> CS$<>9__CachedAnonymousMethodDelegate1bb;
    [CompilerGeneratedAttribute]
private static Func`3<<>f__AnonymousTypeb`2<<>f__AnonymousTypea`2<double, IOption`1<char>>, double>, IOption`1<char>, <>f__AnonymousTypec`2<<>f__AnonymousTypeb`2<<>f__AnonymousTypea`2<double, IOption`1<char>>, double>, IOption`1<char>>> CS$<>9__CachedAnonymousMethodDelegate1bc;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousTypec`2<<>f__AnonymousTypeb`2<<>f__AnonymousTypea`2<double, IOption`1<char>>, double>, IOption`1<char>>, Parser`1<double>> CS$<>9__CachedAnonymousMethodDelegate1bd;
    [CompilerGeneratedAttribute]
private static Func`3<<>f__AnonymousTypec`2<<>f__AnonymousTypeb`2<<>f__AnonymousTypea`2<double, IOption`1<char>>, double>, IOption`1<char>>, double, <>f__AnonymousTyped`2<<>f__AnonymousTypec`2<<>f__AnonymousTypeb`2<<>f__AnonymousTypea`2<double, IOption`1<char>>, double>, IOption`1<char>>, double>> CS$<>9__CachedAnonymousMethodDelegate1be;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousTyped`2<<>f__AnonymousTypec`2<<>f__AnonymousTypeb`2<<>f__AnonymousTypea`2<double, IOption`1<char>>, double>, IOption`1<char>>, double>, Parser`1<char>> CS$<>9__CachedAnonymousMethodDelegate1bf;
    [CompilerGeneratedAttribute]
private static Func`3<<>f__AnonymousTyped`2<<>f__AnonymousTypec`2<<>f__AnonymousTypeb`2<<>f__AnonymousTypea`2<double, IOption`1<char>>, double>, IOption`1<char>>, double>, char, <>f__AnonymousTypee`2<<>f__AnonymousTyped`2<<>f__AnonymousTypec`2<<>f__AnonymousTypeb`2<<>f__AnonymousTypea`2<double, IOption`1<char>>, double>, IOption`1<char>>, double>, char>> CS$<>9__CachedAnonymousMethodDelegate1c0;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousTypee`2<<>f__AnonymousTyped`2<<>f__AnonymousTypec`2<<>f__AnonymousTypeb`2<<>f__AnonymousTypea`2<double, IOption`1<char>>, double>, IOption`1<char>>, double>, char>, Parser`1<bool>> CS$<>9__CachedAnonymousMethodDelegate1c1;
    [CompilerGeneratedAttribute]
private static Func`3<<>f__AnonymousTypee`2<<>f__AnonymousTyped`2<<>f__AnonymousTypec`2<<>f__AnonymousTypeb`2<<>f__AnonymousTypea`2<double, IOption`1<char>>, double>, IOption`1<char>>, double>, char>, bool, <>f__AnonymousTypef`2<<>f__AnonymousTypee`2<<>f__AnonymousTyped`2<<>f__AnonymousTypec`2<<>f__AnonymousTypeb`2<<>f__AnonymousTypea`2<double, IOption`1<char>>, double>, IOption`1<char>>, double>, char>, bool>> CS$<>9__CachedAnonymousMethodDelegate1c2;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousTypef`2<<>f__AnonymousTypee`2<<>f__AnonymousTyped`2<<>f__AnonymousTypec`2<<>f__AnonymousTypeb`2<<>f__AnonymousTypea`2<double, IOption`1<char>>, double>, IOption`1<char>>, double>, char>, bool>, Parser`1<IOption`1<char>>> CS$<>9__CachedAnonymousMethodDelegate1c3;
    [CompilerGeneratedAttribute]
private static Func`3<<>f__AnonymousTypef`2<<>f__AnonymousTypee`2<<>f__AnonymousTyped`2<<>f__AnonymousTypec`2<<>f__AnonymousTypeb`2<<>f__AnonymousTypea`2<double, IOption`1<char>>, double>, IOption`1<char>>, double>, char>, bool>, IOption`1<char>, <>f__AnonymousType10`2<<>f__AnonymousTypef`2<<>f__AnonymousTypee`2<<>f__AnonymousTyped`2<<>f__AnonymousTypec`2<<>f__AnonymousTypeb`2<<>f__AnonymousTypea`2<double, IOption`1<char>>, double>, IOption`1<char>>, double>, char>, bool>, IOption`1<char>>> CS$<>9__CachedAnonymousMethodDelegate1c4;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType10`2<<>f__AnonymousTypef`2<<>f__AnonymousTypee`2<<>f__AnonymousTyped`2<<>f__AnonymousTypec`2<<>f__AnonymousTypeb`2<<>f__AnonymousTypea`2<double, IOption`1<char>>, double>, IOption`1<char>>, double>, char>, bool>, IOption`1<char>>, Parser`1<bool>> CS$<>9__CachedAnonymousMethodDelegate1c5;
    [CompilerGeneratedAttribute]
private static Func`3<<>f__AnonymousType10`2<<>f__AnonymousTypef`2<<>f__AnonymousTypee`2<<>f__AnonymousTyped`2<<>f__AnonymousTypec`2<<>f__AnonymousTypeb`2<<>f__AnonymousTypea`2<double, IOption`1<char>>, double>, IOption`1<char>>, double>, char>, bool>, IOption`1<char>>, bool, <>f__AnonymousType11`2<<>f__AnonymousType10`2<<>f__AnonymousTypef`2<<>f__AnonymousTypee`2<<>f__AnonymousTyped`2<<>f__AnonymousTypec`2<<>f__AnonymousTypeb`2<<>f__AnonymousTypea`2<double, IOption`1<char>>, double>, IOption`1<char>>, double>, char>, bool>, IOption`1<char>>, bool>> CS$<>9__CachedAnonymousMethodDelegate1c6;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType11`2<<>f__AnonymousType10`2<<>f__AnonymousTypef`2<<>f__AnonymousTypee`2<<>f__AnonymousTyped`2<<>f__AnonymousTypec`2<<>f__AnonymousTypeb`2<<>f__AnonymousTypea`2<double, IOption`1<char>>, double>, IOption`1<char>>, double>, char>, bool>, IOption`1<char>>, bool>, Parser`1<IOption`1<char>>> CS$<>9__CachedAnonymousMethodDelegate1c7;
    [CompilerGeneratedAttribute]
private static Func`3<<>f__AnonymousType11`2<<>f__AnonymousType10`2<<>f__AnonymousTypef`2<<>f__AnonymousTypee`2<<>f__AnonymousTyped`2<<>f__AnonymousTypec`2<<>f__AnonymousTypeb`2<<>f__AnonymousTypea`2<double, IOption`1<char>>, double>, IOption`1<char>>, double>, char>, bool>, IOption`1<char>>, bool>, IOption`1<char>, <>f__AnonymousType12`2<<>f__AnonymousType11`2<<>f__AnonymousType10`2<<>f__AnonymousTypef`2<<>f__AnonymousTypee`2<<>f__AnonymousTyped`2<<>f__AnonymousTypec`2<<>f__AnonymousTypeb`2<<>f__AnonymousTypea`2<double, IOption`1<char>>, double>, IOption`1<char>>, double>, char>, bool>, IOption`1<char>>, bool>, IOption`1<char>>> CS$<>9__CachedAnonymousMethodDelegate1c8;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType12`2<<>f__AnonymousType11`2<<>f__AnonymousType10`2<<>f__AnonymousTypef`2<<>f__AnonymousTypee`2<<>f__AnonymousTyped`2<<>f__AnonymousTypec`2<<>f__AnonymousTypeb`2<<>f__AnonymousTypea`2<double, IOption`1<char>>, double>, IOption`1<char>>, double>, char>, bool>, IOption`1<char>>, bool>, IOption`1<char>>, Parser`1<Point>> CS$<>9__CachedAnonymousMethodDelegate1c9;
    [CompilerGeneratedAttribute]
private static Func`3<<>f__AnonymousType12`2<<>f__AnonymousType11`2<<>f__AnonymousType10`2<<>f__AnonymousTypef`2<<>f__AnonymousTypee`2<<>f__AnonymousTyped`2<<>f__AnonymousTypec`2<<>f__AnonymousTypeb`2<<>f__AnonymousTypea`2<double, IOption`1<char>>, double>, IOption`1<char>>, double>, char>, bool>, IOption`1<char>>, bool>, IOption`1<char>>, Point, SA> CS$<>9__CachedAnonymousMethodDelegate1ca;
    [CompilerGeneratedAttribute]
private static Func`2<double, S> CS$<>9__CachedAnonymousMethodDelegate1cb;
    [CompilerGeneratedAttribute]
private static Func`2<double, S> CS$<>9__CachedAnonymousMethodDelegate1cc;
    [CompilerGeneratedAttribute]
private static Func`2<Point, S> CS$<>9__CachedAnonymousMethodDelegate1cd;
    [CompilerGeneratedAttribute]
private static Func`2<Point, S> CS$<>9__CachedAnonymousMethodDelegate1ce;
    [CompilerGeneratedAttribute]
private static Func`2<Point, Parser`1<IOption`1<char>>> CS$<>9__CachedAnonymousMethodDelegate1cf;
    [CompilerGeneratedAttribute]
private static Func`3<Point, IOption`1<char>, <>f__AnonymousType13`2<Point, IOption`1<char>>> CS$<>9__CachedAnonymousMethodDelegate1d0;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType13`2<Point, IOption`1<char>>, Parser`1<Point>> CS$<>9__CachedAnonymousMethodDelegate1d1;
    [CompilerGeneratedAttribute]
private static Func`3<<>f__AnonymousType13`2<Point, IOption`1<char>>, Point, <>f__AnonymousType14`2<<>f__AnonymousType13`2<Point, IOption`1<char>>, Point>> CS$<>9__CachedAnonymousMethodDelegate1d2;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType14`2<<>f__AnonymousType13`2<Point, IOption`1<char>>, Point>, Parser`1<IOption`1<char>>> CS$<>9__CachedAnonymousMethodDelegate1d3;
    [CompilerGeneratedAttribute]
private static Func`3<<>f__AnonymousType14`2<<>f__AnonymousType13`2<Point, IOption`1<char>>, Point>, IOption`1<char>, <>f__AnonymousType15`2<<>f__AnonymousType14`2<<>f__AnonymousType13`2<Point, IOption`1<char>>, Point>, IOption`1<char>>> CS$<>9__CachedAnonymousMethodDelegate1d4;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType15`2<<>f__AnonymousType14`2<<>f__AnonymousType13`2<Point, IOption`1<char>>, Point>, IOption`1<char>>, Parser`1<Point>> CS$<>9__CachedAnonymousMethodDelegate1d5;
    [CompilerGeneratedAttribute]
private static Func`3<<>f__AnonymousType15`2<<>f__AnonymousType14`2<<>f__AnonymousType13`2<Point, IOption`1<char>>, Point>, IOption`1<char>>, Point, SC> CS$<>9__CachedAnonymousMethodDelegate1d6;
    [CompilerGeneratedAttribute]
private static Func`2<Point, Parser`1<IOption`1<char>>> CS$<>9__CachedAnonymousMethodDelegate1d7;
    [CompilerGeneratedAttribute]
private static Func`3<Point, IOption`1<char>, <>f__AnonymousType16`2<Point, IOption`1<char>>> CS$<>9__CachedAnonymousMethodDelegate1d8;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType16`2<Point, IOption`1<char>>, Parser`1<Point>> CS$<>9__CachedAnonymousMethodDelegate1d9;
    [CompilerGeneratedAttribute]
private static Func`3<<>f__AnonymousType16`2<Point, IOption`1<char>>, Point, SS> CS$<>9__CachedAnonymousMethodDelegate1da;
    [CompilerGeneratedAttribute]
private static Func`2<Point, Parser`1<IOption`1<char>>> CS$<>9__CachedAnonymousMethodDelegate1db;
    [CompilerGeneratedAttribute]
private static Func`3<Point, IOption`1<char>, <>f__AnonymousType13`2<Point, IOption`1<char>>> CS$<>9__CachedAnonymousMethodDelegate1dc;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType13`2<Point, IOption`1<char>>, Parser`1<Point>> CS$<>9__CachedAnonymousMethodDelegate1dd;
    [CompilerGeneratedAttribute]
private static Func`3<<>f__AnonymousType13`2<Point, IOption`1<char>>, Point, SQ> CS$<>9__CachedAnonymousMethodDelegate1de;
    [CompilerGeneratedAttribute]
private static Func`2<Point, ST> CS$<>9__CachedAnonymousMethodDelegate1df;
    [CompilerGeneratedAttribute]
private static Func`2<char, SZ> CS$<>9__CachedAnonymousMethodDelegate1e0;
    [CompilerGeneratedAttribute]
private static Func`2<SZ, S[]> CS$<>9__CachedAnonymousMethodDelegate1e1;
    [CompilerGeneratedAttribute]
private static Func`2<ICollection`1<S>, Parser`1<IOption`1<IEnumerable`1<ICollection`1<S>>>>> CS$<>9__CachedAnonymousMethodDelegate1e2;
    [CompilerGeneratedAttribute]
private static Func`3<ICollection`1<S>, IOption`1<IEnumerable`1<ICollection`1<S>>>, ICollection`1<S>> CS$<>9__CachedAnonymousMethodDelegate1e3;
    [CompilerGeneratedAttribute]
private static Func`2<ICollection`1<S>, Parser`1<IOption`1<IEnumerable`1<char>>>> CS$<>9__CachedAnonymousMethodDelegate1e4;
    [CompilerGeneratedAttribute]
private static Func`3<ICollection`1<S>, IOption`1<IEnumerable`1<char>>, <>f__AnonymousType17`2<ICollection`1<S>, IOption`1<IEnumerable`1<char>>>> CS$<>9__CachedAnonymousMethodDelegate1e5;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType17`2<ICollection`1<S>, IOption`1<IEnumerable`1<char>>>, Parser`1<IOption`1<ICollection`1<S>>>> CS$<>9__CachedAnonymousMethodDelegate1e6;
    [CompilerGeneratedAttribute]
private static Func`3<<>f__AnonymousType17`2<ICollection`1<S>, IOption`1<IEnumerable`1<char>>>, IOption`1<ICollection`1<S>>, ICollection`1<S>> CS$<>9__CachedAnonymousMethodDelegate1e7;
    [CompilerGeneratedAttribute]
private static Func`2<ICollection`1<S>, Parser`1<IOption`1<IEnumerable`1<S>>>> CS$<>9__CachedAnonymousMethodDelegate1e8;
    [CompilerGeneratedAttribute]
private static Func`3<ICollection`1<S>, IOption`1<IEnumerable`1<S>>, ICollection`1<S>> CS$<>9__CachedAnonymousMethodDelegate1e9;
    [CompilerGeneratedAttribute]
private static Func`2<IOption`1<IEnumerable`1<char>>, Parser`1<IOption`1<ICollection`1<S>>>> CS$<>9__CachedAnonymousMethodDelegate1ea;
    [CompilerGeneratedAttribute]
private static Func`3<IOption`1<IEnumerable`1<char>>, IOption`1<ICollection`1<S>>, <>f__AnonymousType18`2<IOption`1<IEnumerable`1<char>>, IOption`1<ICollection`1<S>>>> CS$<>9__CachedAnonymousMethodDelegate1eb;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType18`2<IOption`1<IEnumerable`1<char>>, IOption`1<ICollection`1<S>>>, Parser`1<IOption`1<IEnumerable`1<char>>>> CS$<>9__CachedAnonymousMethodDelegate1ec;
    [CompilerGeneratedAttribute]
private static Func`3<<>f__AnonymousType18`2<IOption`1<IEnumerable`1<char>>, IOption`1<ICollection`1<S>>>, IOption`1<IEnumerable`1<char>>, ICollection`1<S>> CS$<>9__CachedAnonymousMethodDelegate1ed;
    [CompilerGeneratedAttribute]
private static Func`2<Point, Parser`1<IOption`1<IEnumerable`1<Point>>>> CS$<>9__CachedAnonymousMethodDelegate1ee;
    [CompilerGeneratedAttribute]
private static Func`3<Point, IOption`1<IEnumerable`1<Point>>, ICollection`1<Point>> CS$<>9__CachedAnonymousMethodDelegate1ef;
    [CompilerGeneratedAttribute]
private static Func`2<IOption`1<IEnumerable`1<char>>, Parser`1<IOption`1<ICollection`1<Point>>>> CS$<>9__CachedAnonymousMethodDelegate1f0;
    [CompilerGeneratedAttribute]
private static Func`3<IOption`1<IEnumerable`1<char>>, IOption`1<ICollection`1<Point>>, <>f__AnonymousType19`2<IOption`1<IEnumerable`1<char>>, IOption`1<ICollection`1<Point>>>> CS$<>9__CachedAnonymousMethodDelegate1f1;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType19`2<IOption`1<IEnumerable`1<char>>, IOption`1<ICollection`1<Point>>>, Parser`1<IOption`1<IEnumerable`1<char>>>> CS$<>9__CachedAnonymousMethodDelegate1f2;
    [CompilerGeneratedAttribute]
private static Func`3<<>f__AnonymousType19`2<IOption`1<IEnumerable`1<char>>, IOption`1<ICollection`1<Point>>>, IOption`1<IEnumerable`1<char>>, ICollection`1<Point>> CS$<>9__CachedAnonymousMethodDelegate1f3;
    [CompilerGeneratedAttribute]
private static Predicate`1<char> CS$<>9__CachedAnonymousMethodDelegate1f4;
    [CompilerGeneratedAttribute]
private static Func`2<char, Parser`1<byte>> CS$<>9__CachedAnonymousMethodDelegate1f5;
    [CompilerGeneratedAttribute]
private static Func`3<char, byte, <>f__AnonymousType1a`2<char, byte>> CS$<>9__CachedAnonymousMethodDelegate1f6;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType1a`2<char, byte>, Parser`1<byte>> CS$<>9__CachedAnonymousMethodDelegate1f7;
    [CompilerGeneratedAttribute]
private static Func`3<<>f__AnonymousType1a`2<char, byte>, byte, <>f__AnonymousType1b`2<<>f__AnonymousType1a`2<char, byte>, byte>> CS$<>9__CachedAnonymousMethodDelegate1f8;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType1b`2<<>f__AnonymousType1a`2<char, byte>, byte>, Parser`1<byte>> CS$<>9__CachedAnonymousMethodDelegate1f9;
    [CompilerGeneratedAttribute]
private static Func`3<<>f__AnonymousType1b`2<<>f__AnonymousType1a`2<char, byte>, byte>, byte, Color> CS$<>9__CachedAnonymousMethodDelegate1fa;
    [CompilerGeneratedAttribute]
private static Func`2<char, Parser`1<byte>> CS$<>9__CachedAnonymousMethodDelegate1fb;
    [CompilerGeneratedAttribute]
private static Func`3<char, byte, <>f__AnonymousType1c`2<char, byte>> CS$<>9__CachedAnonymousMethodDelegate1fc;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType1c`2<char, byte>, Parser`1<byte>> CS$<>9__CachedAnonymousMethodDelegate1fd;
    [CompilerGeneratedAttribute]
private static Func`3<<>f__AnonymousType1c`2<char, byte>, byte, <>f__AnonymousType1d`2<<>f__AnonymousType1c`2<char, byte>, byte>> CS$<>9__CachedAnonymousMethodDelegate1fe;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType1d`2<<>f__AnonymousType1c`2<char, byte>, byte>, Parser`1<byte>> CS$<>9__CachedAnonymousMethodDelegate1ff;
    [CompilerGeneratedAttribute]
private static Func`3<<>f__AnonymousType1d`2<<>f__AnonymousType1c`2<char, byte>, byte>, byte, <>f__AnonymousType1e`2<<>f__AnonymousType1d`2<<>f__AnonymousType1c`2<char, byte>, byte>, byte>> CS$<>9__CachedAnonymousMethodDelegate200;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType1e`2<<>f__AnonymousType1d`2<<>f__AnonymousType1c`2<char, byte>, byte>, byte>, Parser`1<byte>> CS$<>9__CachedAnonymousMethodDelegate201;
    [CompilerGeneratedAttribute]
private static Func`3<<>f__AnonymousType1e`2<<>f__AnonymousType1d`2<<>f__AnonymousType1c`2<char, byte>, byte>, byte>, byte, Color> CS$<>9__CachedAnonymousMethodDelegate202;
    [CompilerGeneratedAttribute]
private static Func`2<char, Parser`1<byte>> CS$<>9__CachedAnonymousMethodDelegate203;
    [CompilerGeneratedAttribute]
private static Func`3<char, byte, <>f__AnonymousType1f`2<char, byte>> CS$<>9__CachedAnonymousMethodDelegate204;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType1f`2<char, byte>, Parser`1<byte>> CS$<>9__CachedAnonymousMethodDelegate205;
    [CompilerGeneratedAttribute]
private static Func`3<<>f__AnonymousType1f`2<char, byte>, byte, <>f__AnonymousType20`2<<>f__AnonymousType1f`2<char, byte>, byte>> CS$<>9__CachedAnonymousMethodDelegate206;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType20`2<<>f__AnonymousType1f`2<char, byte>, byte>, Parser`1<byte>> CS$<>9__CachedAnonymousMethodDelegate207;
    [CompilerGeneratedAttribute]
private static Func`3<<>f__AnonymousType20`2<<>f__AnonymousType1f`2<char, byte>, byte>, byte, <>f__AnonymousType21`2<<>f__AnonymousType20`2<<>f__AnonymousType1f`2<char, byte>, byte>, byte>> CS$<>9__CachedAnonymousMethodDelegate208;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType21`2<<>f__AnonymousType20`2<<>f__AnonymousType1f`2<char, byte>, byte>, byte>, Parser`1<byte>> CS$<>9__CachedAnonymousMethodDelegate209;
    [CompilerGeneratedAttribute]
private static Func`3<<>f__AnonymousType21`2<<>f__AnonymousType20`2<<>f__AnonymousType1f`2<char, byte>, byte>, byte>, byte, <>f__AnonymousType22`2<<>f__AnonymousType21`2<<>f__AnonymousType20`2<<>f__AnonymousType1f`2<char, byte>, byte>, byte>, byte>> CS$<>9__CachedAnonymousMethodDelegate20a;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType22`2<<>f__AnonymousType21`2<<>f__AnonymousType20`2<<>f__AnonymousType1f`2<char, byte>, byte>, byte>, byte>, Parser`1<byte>> CS$<>9__CachedAnonymousMethodDelegate20b;
    [CompilerGeneratedAttribute]
private static Func`3<<>f__AnonymousType22`2<<>f__AnonymousType21`2<<>f__AnonymousType20`2<<>f__AnonymousType1f`2<char, byte>, byte>, byte>, byte>, byte, <>f__AnonymousType23`2<<>f__AnonymousType22`2<<>f__AnonymousType21`2<<>f__AnonymousType20`2<<>f__AnonymousType1f`2<char, byte>, byte>, byte>, byte>, byte>> CS$<>9__CachedAnonymousMethodDelegate20c;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType23`2<<>f__AnonymousType22`2<<>f__AnonymousType21`2<<>f__AnonymousType20`2<<>f__AnonymousType1f`2<char, byte>, byte>, byte>, byte>, byte>, Parser`1<byte>> CS$<>9__CachedAnonymousMethodDelegate20d;
    [CompilerGeneratedAttribute]
private static Func`3<<>f__AnonymousType23`2<<>f__AnonymousType22`2<<>f__AnonymousType21`2<<>f__AnonymousType20`2<<>f__AnonymousType1f`2<char, byte>, byte>, byte>, byte>, byte>, byte, Color> CS$<>9__CachedAnonymousMethodDelegate20e;
    [CompilerGeneratedAttribute]
private static Func`2<char, Parser`1<byte>> CS$<>9__CachedAnonymousMethodDelegate20f;
    [CompilerGeneratedAttribute]
private static Func`3<char, byte, <>f__AnonymousType24`2<char, byte>> CS$<>9__CachedAnonymousMethodDelegate210;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType24`2<char, byte>, Parser`1<byte>> CS$<>9__CachedAnonymousMethodDelegate211;
    [CompilerGeneratedAttribute]
private static Func`3<<>f__AnonymousType24`2<char, byte>, byte, <>f__AnonymousType25`2<<>f__AnonymousType24`2<char, byte>, byte>> CS$<>9__CachedAnonymousMethodDelegate212;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType25`2<<>f__AnonymousType24`2<char, byte>, byte>, Parser`1<byte>> CS$<>9__CachedAnonymousMethodDelegate213;
    [CompilerGeneratedAttribute]
private static Func`3<<>f__AnonymousType25`2<<>f__AnonymousType24`2<char, byte>, byte>, byte, <>f__AnonymousType26`2<<>f__AnonymousType25`2<<>f__AnonymousType24`2<char, byte>, byte>, byte>> CS$<>9__CachedAnonymousMethodDelegate214;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType26`2<<>f__AnonymousType25`2<<>f__AnonymousType24`2<char, byte>, byte>, byte>, Parser`1<byte>> CS$<>9__CachedAnonymousMethodDelegate215;
    [CompilerGeneratedAttribute]
private static Func`3<<>f__AnonymousType26`2<<>f__AnonymousType25`2<<>f__AnonymousType24`2<char, byte>, byte>, byte>, byte, <>f__AnonymousType27`2<<>f__AnonymousType26`2<<>f__AnonymousType25`2<<>f__AnonymousType24`2<char, byte>, byte>, byte>, byte>> CS$<>9__CachedAnonymousMethodDelegate216;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType27`2<<>f__AnonymousType26`2<<>f__AnonymousType25`2<<>f__AnonymousType24`2<char, byte>, byte>, byte>, byte>, Parser`1<byte>> CS$<>9__CachedAnonymousMethodDelegate217;
    [CompilerGeneratedAttribute]
private static Func`3<<>f__AnonymousType27`2<<>f__AnonymousType26`2<<>f__AnonymousType25`2<<>f__AnonymousType24`2<char, byte>, byte>, byte>, byte>, byte, <>f__AnonymousType28`2<<>f__AnonymousType27`2<<>f__AnonymousType26`2<<>f__AnonymousType25`2<<>f__AnonymousType24`2<char, byte>, byte>, byte>, byte>, byte>> CS$<>9__CachedAnonymousMethodDelegate218;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType28`2<<>f__AnonymousType27`2<<>f__AnonymousType26`2<<>f__AnonymousType25`2<<>f__AnonymousType24`2<char, byte>, byte>, byte>, byte>, byte>, Parser`1<byte>> CS$<>9__CachedAnonymousMethodDelegate219;
    [CompilerGeneratedAttribute]
private static Func`3<<>f__AnonymousType28`2<<>f__AnonymousType27`2<<>f__AnonymousType26`2<<>f__AnonymousType25`2<<>f__AnonymousType24`2<char, byte>, byte>, byte>, byte>, byte>, byte, <>f__AnonymousType29`2<<>f__AnonymousType28`2<<>f__AnonymousType27`2<<>f__AnonymousType26`2<<>f__AnonymousType25`2<<>f__AnonymousType24`2<char, byte>, byte>, byte>, byte>, byte>, byte>> CS$<>9__CachedAnonymousMethodDelegate21a;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType29`2<<>f__AnonymousType28`2<<>f__AnonymousType27`2<<>f__AnonymousType26`2<<>f__AnonymousType25`2<<>f__AnonymousType24`2<char, byte>, byte>, byte>, byte>, byte>, byte>, Parser`1<byte>> CS$<>9__CachedAnonymousMethodDelegate21b;
    [CompilerGeneratedAttribute]
private static Func`3<<>f__AnonymousType29`2<<>f__AnonymousType28`2<<>f__AnonymousType27`2<<>f__AnonymousType26`2<<>f__AnonymousType25`2<<>f__AnonymousType24`2<char, byte>, byte>, byte>, byte>, byte>, byte>, byte, <>f__AnonymousType2a`2<<>f__AnonymousType29`2<<>f__AnonymousType28`2<<>f__AnonymousType27`2<<>f__AnonymousType26`2<<>f__AnonymousType25`2<<>f__AnonymousType24`2<char, byte>, byte>, byte>, byte>, byte>, byte>, byte>> CS$<>9__CachedAnonymousMethodDelegate21c;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType2a`2<<>f__AnonymousType29`2<<>f__AnonymousType28`2<<>f__AnonymousType27`2<<>f__AnonymousType26`2<<>f__AnonymousType25`2<<>f__AnonymousType24`2<char, byte>, byte>, byte>, byte>, byte>, byte>, byte>, Parser`1<byte>> CS$<>9__CachedAnonymousMethodDelegate21d;
    [CompilerGeneratedAttribute]
private static Func`3<<>f__AnonymousType2a`2<<>f__AnonymousType29`2<<>f__AnonymousType28`2<<>f__AnonymousType27`2<<>f__AnonymousType26`2<<>f__AnonymousType25`2<<>f__AnonymousType24`2<char, byte>, byte>, byte>, byte>, byte>, byte>, byte>, byte, Color> CS$<>9__CachedAnonymousMethodDelegate21e;
    [CompilerGeneratedAttribute]
private static Func`2<IEnumerable`1<char>, Parser`1<string>> CS$<>9__CachedAnonymousMethodDelegate21f;
    [CompilerGeneratedAttribute]
private static Func`3<IEnumerable`1<char>, string, <>f__AnonymousType2b`2<IEnumerable`1<char>, string>> CS$<>9__CachedAnonymousMethodDelegate220;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType2b`2<IEnumerable`1<char>, string>, Parser`1<char>> CS$<>9__CachedAnonymousMethodDelegate221;
    [CompilerGeneratedAttribute]
private static Func`3<<>f__AnonymousType2b`2<IEnumerable`1<char>, string>, char, string> CS$<>9__CachedAnonymousMethodDelegate222;
    [CompilerGeneratedAttribute]
private static Func`2<IEnumerable`1<char>, Nullable`1<ColorOrIri>> CS$<>9__CachedAnonymousMethodDelegate223;
    [CompilerGeneratedAttribute]
private static Func`2<Color, Nullable`1<ColorOrIri>> CS$<>9__CachedAnonymousMethodDelegate224;
    [CompilerGeneratedAttribute]
private static Func`2<string, Nullable`1<ColorOrIri>> CS$<>9__CachedAnonymousMethodDelegate225;
    [CompilerGeneratedAttribute]
private static Func`2<IEnumerable`1<char>, Parser`1<IOption`1<IEnumerable`1<char>>>> CS$<>9__CachedAnonymousMethodDelegate226;
    [CompilerGeneratedAttribute]
private static Func`3<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>, <>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>> CS$<>9__CachedAnonymousMethodDelegate227;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, Parser`1<char>> CS$<>9__CachedAnonymousMethodDelegate228;
    [CompilerGeneratedAttribute]
private static Func`3<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char, <>f__AnonymousType2d`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>> CS$<>9__CachedAnonymousMethodDelegate229;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType2d`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, Parser`1<IOption`1<IEnumerable`1<char>>>> CS$<>9__CachedAnonymousMethodDelegate22a;
    [CompilerGeneratedAttribute]
private static Func`3<<>f__AnonymousType2d`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>, <>f__AnonymousType2e`2<<>f__AnonymousType2d`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>> CS$<>9__CachedAnonymousMethodDelegate22b;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType2e`2<<>f__AnonymousType2d`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, Parser`1<double>> CS$<>9__CachedAnonymousMethodDelegate22c;
    [CompilerGeneratedAttribute]
private static Func`3<<>f__AnonymousType2e`2<<>f__AnonymousType2d`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double, <>f__AnonymousType2f`2<<>f__AnonymousType2e`2<<>f__AnonymousType2d`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>> CS$<>9__CachedAnonymousMethodDelegate22d;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType2f`2<<>f__AnonymousType2e`2<<>f__AnonymousType2d`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, Parser`1<char>> CS$<>9__CachedAnonymousMethodDelegate22e;
    [CompilerGeneratedAttribute]
private static Func`3<<>f__AnonymousType2f`2<<>f__AnonymousType2e`2<<>f__AnonymousType2d`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, char, <>f__AnonymousType30`2<<>f__AnonymousType2f`2<<>f__AnonymousType2e`2<<>f__AnonymousType2d`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, char>> CS$<>9__CachedAnonymousMethodDelegate22f;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType30`2<<>f__AnonymousType2f`2<<>f__AnonymousType2e`2<<>f__AnonymousType2d`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, char>, Parser`1<double>> CS$<>9__CachedAnonymousMethodDelegate230;
    [CompilerGeneratedAttribute]
private static Func`3<<>f__AnonymousType30`2<<>f__AnonymousType2f`2<<>f__AnonymousType2e`2<<>f__AnonymousType2d`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, char>, double, <>f__AnonymousType31`2<<>f__AnonymousType30`2<<>f__AnonymousType2f`2<<>f__AnonymousType2e`2<<>f__AnonymousType2d`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, char>, double>> CS$<>9__CachedAnonymousMethodDelegate231;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType31`2<<>f__AnonymousType30`2<<>f__AnonymousType2f`2<<>f__AnonymousType2e`2<<>f__AnonymousType2d`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, char>, double>, Parser`1<char>> CS$<>9__CachedAnonymousMethodDelegate232;
    [CompilerGeneratedAttribute]
private static Func`3<<>f__AnonymousType31`2<<>f__AnonymousType30`2<<>f__AnonymousType2f`2<<>f__AnonymousType2e`2<<>f__AnonymousType2d`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, char>, double>, char, <>f__AnonymousType32`2<<>f__AnonymousType31`2<<>f__AnonymousType30`2<<>f__AnonymousType2f`2<<>f__AnonymousType2e`2<<>f__AnonymousType2d`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, char>, double>, char>> CS$<>9__CachedAnonymousMethodDelegate233;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType32`2<<>f__AnonymousType31`2<<>f__AnonymousType30`2<<>f__AnonymousType2f`2<<>f__AnonymousType2e`2<<>f__AnonymousType2d`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, char>, double>, char>, Parser`1<double>> CS$<>9__CachedAnonymousMethodDelegate234;
    [CompilerGeneratedAttribute]
private static Func`3<<>f__AnonymousType32`2<<>f__AnonymousType31`2<<>f__AnonymousType30`2<<>f__AnonymousType2f`2<<>f__AnonymousType2e`2<<>f__AnonymousType2d`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, char>, double>, char>, double, <>f__AnonymousType33`2<<>f__AnonymousType32`2<<>f__AnonymousType31`2<<>f__AnonymousType30`2<<>f__AnonymousType2f`2<<>f__AnonymousType2e`2<<>f__AnonymousType2d`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, char>, double>, char>, double>> CS$<>9__CachedAnonymousMethodDelegate235;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType33`2<<>f__AnonymousType32`2<<>f__AnonymousType31`2<<>f__AnonymousType30`2<<>f__AnonymousType2f`2<<>f__AnonymousType2e`2<<>f__AnonymousType2d`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, char>, double>, char>, double>, Parser`1<char>> CS$<>9__CachedAnonymousMethodDelegate236;
    [CompilerGeneratedAttribute]
private static Func`3<<>f__AnonymousType33`2<<>f__AnonymousType32`2<<>f__AnonymousType31`2<<>f__AnonymousType30`2<<>f__AnonymousType2f`2<<>f__AnonymousType2e`2<<>f__AnonymousType2d`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, char>, double>, char>, double>, char, <>f__AnonymousType34`2<<>f__AnonymousType33`2<<>f__AnonymousType32`2<<>f__AnonymousType31`2<<>f__AnonymousType30`2<<>f__AnonymousType2f`2<<>f__AnonymousType2e`2<<>f__AnonymousType2d`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, char>, double>, char>, double>, char>> CS$<>9__CachedAnonymousMethodDelegate237;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType34`2<<>f__AnonymousType33`2<<>f__AnonymousType32`2<<>f__AnonymousType31`2<<>f__AnonymousType30`2<<>f__AnonymousType2f`2<<>f__AnonymousType2e`2<<>f__AnonymousType2d`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, char>, double>, char>, double>, char>, Parser`1<double>> CS$<>9__CachedAnonymousMethodDelegate238;
    [CompilerGeneratedAttribute]
private static Func`3<<>f__AnonymousType34`2<<>f__AnonymousType33`2<<>f__AnonymousType32`2<<>f__AnonymousType31`2<<>f__AnonymousType30`2<<>f__AnonymousType2f`2<<>f__AnonymousType2e`2<<>f__AnonymousType2d`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, char>, double>, char>, double>, char>, double, <>f__AnonymousType35`2<<>f__AnonymousType34`2<<>f__AnonymousType33`2<<>f__AnonymousType32`2<<>f__AnonymousType31`2<<>f__AnonymousType30`2<<>f__AnonymousType2f`2<<>f__AnonymousType2e`2<<>f__AnonymousType2d`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, char>, double>, char>, double>, char>, double>> CS$<>9__CachedAnonymousMethodDelegate239;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType35`2<<>f__AnonymousType34`2<<>f__AnonymousType33`2<<>f__AnonymousType32`2<<>f__AnonymousType31`2<<>f__AnonymousType30`2<<>f__AnonymousType2f`2<<>f__AnonymousType2e`2<<>f__AnonymousType2d`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, char>, double>, char>, double>, char>, double>, Parser`1<char>> CS$<>9__CachedAnonymousMethodDelegate23a;
    [CompilerGeneratedAttribute]
private static Func`3<<>f__AnonymousType35`2<<>f__AnonymousType34`2<<>f__AnonymousType33`2<<>f__AnonymousType32`2<<>f__AnonymousType31`2<<>f__AnonymousType30`2<<>f__AnonymousType2f`2<<>f__AnonymousType2e`2<<>f__AnonymousType2d`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, char>, double>, char>, double>, char>, double>, char, <>f__AnonymousType36`2<<>f__AnonymousType35`2<<>f__AnonymousType34`2<<>f__AnonymousType33`2<<>f__AnonymousType32`2<<>f__AnonymousType31`2<<>f__AnonymousType30`2<<>f__AnonymousType2f`2<<>f__AnonymousType2e`2<<>f__AnonymousType2d`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, char>, double>, char>, double>, char>, double>, char>> CS$<>9__CachedAnonymousMethodDelegate23b;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType36`2<<>f__AnonymousType35`2<<>f__AnonymousType34`2<<>f__AnonymousType33`2<<>f__AnonymousType32`2<<>f__AnonymousType31`2<<>f__AnonymousType30`2<<>f__AnonymousType2f`2<<>f__AnonymousType2e`2<<>f__AnonymousType2d`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, char>, double>, char>, double>, char>, double>, char>, Parser`1<double>> CS$<>9__CachedAnonymousMethodDelegate23c;
    [CompilerGeneratedAttribute]
private static Func`3<<>f__AnonymousType36`2<<>f__AnonymousType35`2<<>f__AnonymousType34`2<<>f__AnonymousType33`2<<>f__AnonymousType32`2<<>f__AnonymousType31`2<<>f__AnonymousType30`2<<>f__AnonymousType2f`2<<>f__AnonymousType2e`2<<>f__AnonymousType2d`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, char>, double>, char>, double>, char>, double>, char>, double, <>f__AnonymousType37`2<<>f__AnonymousType36`2<<>f__AnonymousType35`2<<>f__AnonymousType34`2<<>f__AnonymousType33`2<<>f__AnonymousType32`2<<>f__AnonymousType31`2<<>f__AnonymousType30`2<<>f__AnonymousType2f`2<<>f__AnonymousType2e`2<<>f__AnonymousType2d`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, char>, double>, char>, double>, char>, double>, char>, double>> CS$<>9__CachedAnonymousMethodDelegate23d;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType37`2<<>f__AnonymousType36`2<<>f__AnonymousType35`2<<>f__AnonymousType34`2<<>f__AnonymousType33`2<<>f__AnonymousType32`2<<>f__AnonymousType31`2<<>f__AnonymousType30`2<<>f__AnonymousType2f`2<<>f__AnonymousType2e`2<<>f__AnonymousType2d`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, char>, double>, char>, double>, char>, double>, char>, double>, Parser`1<char>> CS$<>9__CachedAnonymousMethodDelegate23e;
    [CompilerGeneratedAttribute]
private static Func`3<<>f__AnonymousType37`2<<>f__AnonymousType36`2<<>f__AnonymousType35`2<<>f__AnonymousType34`2<<>f__AnonymousType33`2<<>f__AnonymousType32`2<<>f__AnonymousType31`2<<>f__AnonymousType30`2<<>f__AnonymousType2f`2<<>f__AnonymousType2e`2<<>f__AnonymousType2d`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, char>, double>, char>, double>, char>, double>, char>, double>, char, <>f__AnonymousType38`2<<>f__AnonymousType37`2<<>f__AnonymousType36`2<<>f__AnonymousType35`2<<>f__AnonymousType34`2<<>f__AnonymousType33`2<<>f__AnonymousType32`2<<>f__AnonymousType31`2<<>f__AnonymousType30`2<<>f__AnonymousType2f`2<<>f__AnonymousType2e`2<<>f__AnonymousType2d`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, char>, double>, char>, double>, char>, double>, char>, double>, char>> CS$<>9__CachedAnonymousMethodDelegate23f;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType38`2<<>f__AnonymousType37`2<<>f__AnonymousType36`2<<>f__AnonymousType35`2<<>f__AnonymousType34`2<<>f__AnonymousType33`2<<>f__AnonymousType32`2<<>f__AnonymousType31`2<<>f__AnonymousType30`2<<>f__AnonymousType2f`2<<>f__AnonymousType2e`2<<>f__AnonymousType2d`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, char>, double>, char>, double>, char>, double>, char>, double>, char>, Parser`1<double>> CS$<>9__CachedAnonymousMethodDelegate240;
    [CompilerGeneratedAttribute]
private static Func`3<<>f__AnonymousType38`2<<>f__AnonymousType37`2<<>f__AnonymousType36`2<<>f__AnonymousType35`2<<>f__AnonymousType34`2<<>f__AnonymousType33`2<<>f__AnonymousType32`2<<>f__AnonymousType31`2<<>f__AnonymousType30`2<<>f__AnonymousType2f`2<<>f__AnonymousType2e`2<<>f__AnonymousType2d`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, char>, double>, char>, double>, char>, double>, char>, double>, char>, double, <>f__AnonymousType39`2<<>f__AnonymousType38`2<<>f__AnonymousType37`2<<>f__AnonymousType36`2<<>f__AnonymousType35`2<<>f__AnonymousType34`2<<>f__AnonymousType33`2<<>f__AnonymousType32`2<<>f__AnonymousType31`2<<>f__AnonymousType30`2<<>f__AnonymousType2f`2<<>f__AnonymousType2e`2<<>f__AnonymousType2d`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, char>, double>, char>, double>, char>, double>, char>, double>, char>, double>> CS$<>9__CachedAnonymousMethodDelegate241;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType39`2<<>f__AnonymousType38`2<<>f__AnonymousType37`2<<>f__AnonymousType36`2<<>f__AnonymousType35`2<<>f__AnonymousType34`2<<>f__AnonymousType33`2<<>f__AnonymousType32`2<<>f__AnonymousType31`2<<>f__AnonymousType30`2<<>f__AnonymousType2f`2<<>f__AnonymousType2e`2<<>f__AnonymousType2d`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, char>, double>, char>, double>, char>, double>, char>, double>, char>, double>, Parser`1<IOption`1<IEnumerable`1<char>>>> CS$<>9__CachedAnonymousMethodDelegate242;
    [CompilerGeneratedAttribute]
private static Func`3<<>f__AnonymousType39`2<<>f__AnonymousType38`2<<>f__AnonymousType37`2<<>f__AnonymousType36`2<<>f__AnonymousType35`2<<>f__AnonymousType34`2<<>f__AnonymousType33`2<<>f__AnonymousType32`2<<>f__AnonymousType31`2<<>f__AnonymousType30`2<<>f__AnonymousType2f`2<<>f__AnonymousType2e`2<<>f__AnonymousType2d`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, char>, double>, char>, double>, char>, double>, char>, double>, char>, double>, IOption`1<IEnumerable`1<char>>, <>f__AnonymousType3a`2<<>f__AnonymousType39`2<<>f__AnonymousType38`2<<>f__AnonymousType37`2<<>f__AnonymousType36`2<<>f__AnonymousType35`2<<>f__AnonymousType34`2<<>f__AnonymousType33`2<<>f__AnonymousType32`2<<>f__AnonymousType31`2<<>f__AnonymousType30`2<<>f__AnonymousType2f`2<<>f__AnonymousType2e`2<<>f__AnonymousType2d`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, char>, double>, char>, double>, char>, double>, char>, double>, char>, double>, IOption`1<IEnumerable`1<char>>>> CS$<>9__CachedAnonymousMethodDelegate243;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType3a`2<<>f__AnonymousType39`2<<>f__AnonymousType38`2<<>f__AnonymousType37`2<<>f__AnonymousType36`2<<>f__AnonymousType35`2<<>f__AnonymousType34`2<<>f__AnonymousType33`2<<>f__AnonymousType32`2<<>f__AnonymousType31`2<<>f__AnonymousType30`2<<>f__AnonymousType2f`2<<>f__AnonymousType2e`2<<>f__AnonymousType2d`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, char>, double>, char>, double>, char>, double>, char>, double>, char>, double>, IOption`1<IEnumerable`1<char>>>, Parser`1<char>> CS$<>9__CachedAnonymousMethodDelegate244;
    [CompilerGeneratedAttribute]
private static Func`3<<>f__AnonymousType3a`2<<>f__AnonymousType39`2<<>f__AnonymousType38`2<<>f__AnonymousType37`2<<>f__AnonymousType36`2<<>f__AnonymousType35`2<<>f__AnonymousType34`2<<>f__AnonymousType33`2<<>f__AnonymousType32`2<<>f__AnonymousType31`2<<>f__AnonymousType30`2<<>f__AnonymousType2f`2<<>f__AnonymousType2e`2<<>f__AnonymousType2d`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, char>, double>, char>, double>, char>, double>, char>, double>, char>, double>, IOption`1<IEnumerable`1<char>>>, char, MatrixTransform> CS$<>9__CachedAnonymousMethodDelegate245;
    [CompilerGeneratedAttribute]
private static Func`2<IEnumerable`1<char>, Parser`1<IOption`1<IEnumerable`1<char>>>> CS$<>9__CachedAnonymousMethodDelegate246;
    [CompilerGeneratedAttribute]
private static Func`3<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>, <>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>> CS$<>9__CachedAnonymousMethodDelegate247;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, Parser`1<char>> CS$<>9__CachedAnonymousMethodDelegate248;
    [CompilerGeneratedAttribute]
private static Func`3<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char, <>f__AnonymousType3b`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>> CS$<>9__CachedAnonymousMethodDelegate249;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType3b`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, Parser`1<IOption`1<IEnumerable`1<char>>>> CS$<>9__CachedAnonymousMethodDelegate24a;
    [CompilerGeneratedAttribute]
private static Func`3<<>f__AnonymousType3b`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>, <>f__AnonymousType3c`2<<>f__AnonymousType3b`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>> CS$<>9__CachedAnonymousMethodDelegate24b;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType3c`2<<>f__AnonymousType3b`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, Parser`1<double>> CS$<>9__CachedAnonymousMethodDelegate24c;
    [CompilerGeneratedAttribute]
private static Func`3<<>f__AnonymousType3c`2<<>f__AnonymousType3b`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double, <>f__AnonymousType3d`2<<>f__AnonymousType3c`2<<>f__AnonymousType3b`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>> CS$<>9__CachedAnonymousMethodDelegate24d;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType3d`2<<>f__AnonymousType3c`2<<>f__AnonymousType3b`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, Parser`1<IOption`1<double>>> CS$<>9__CachedAnonymousMethodDelegate24e;
    [CompilerGeneratedAttribute]
private static Func`3<<>f__AnonymousType3d`2<<>f__AnonymousType3c`2<<>f__AnonymousType3b`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, IOption`1<double>, <>f__AnonymousType3e`2<<>f__AnonymousType3d`2<<>f__AnonymousType3c`2<<>f__AnonymousType3b`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, IOption`1<double>>> CS$<>9__CachedAnonymousMethodDelegate24f;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType3e`2<<>f__AnonymousType3d`2<<>f__AnonymousType3c`2<<>f__AnonymousType3b`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, IOption`1<double>>, Parser`1<IOption`1<IEnumerable`1<char>>>> CS$<>9__CachedAnonymousMethodDelegate250;
    [CompilerGeneratedAttribute]
private static Func`3<<>f__AnonymousType3e`2<<>f__AnonymousType3d`2<<>f__AnonymousType3c`2<<>f__AnonymousType3b`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, IOption`1<double>>, IOption`1<IEnumerable`1<char>>, <>f__AnonymousType3f`2<<>f__AnonymousType3e`2<<>f__AnonymousType3d`2<<>f__AnonymousType3c`2<<>f__AnonymousType3b`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, IOption`1<double>>, IOption`1<IEnumerable`1<char>>>> CS$<>9__CachedAnonymousMethodDelegate251;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType3f`2<<>f__AnonymousType3e`2<<>f__AnonymousType3d`2<<>f__AnonymousType3c`2<<>f__AnonymousType3b`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, IOption`1<double>>, IOption`1<IEnumerable`1<char>>>, Parser`1<char>> CS$<>9__CachedAnonymousMethodDelegate252;
    [CompilerGeneratedAttribute]
private static Func`3<<>f__AnonymousType3f`2<<>f__AnonymousType3e`2<<>f__AnonymousType3d`2<<>f__AnonymousType3c`2<<>f__AnonymousType3b`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, IOption`1<double>>, IOption`1<IEnumerable`1<char>>>, char, TranslateTransform> CS$<>9__CachedAnonymousMethodDelegate253;
    [CompilerGeneratedAttribute]
private static Func`2<IEnumerable`1<char>, Parser`1<IOption`1<IEnumerable`1<char>>>> CS$<>9__CachedAnonymousMethodDelegate254;
    [CompilerGeneratedAttribute]
private static Func`3<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>, <>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>> CS$<>9__CachedAnonymousMethodDelegate255;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, Parser`1<char>> CS$<>9__CachedAnonymousMethodDelegate256;
    [CompilerGeneratedAttribute]
private static Func`3<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char, <>f__AnonymousType40`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>> CS$<>9__CachedAnonymousMethodDelegate257;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType40`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, Parser`1<IOption`1<IEnumerable`1<char>>>> CS$<>9__CachedAnonymousMethodDelegate258;
    [CompilerGeneratedAttribute]
private static Func`3<<>f__AnonymousType40`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>, <>f__AnonymousType41`2<<>f__AnonymousType40`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>> CS$<>9__CachedAnonymousMethodDelegate259;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType41`2<<>f__AnonymousType40`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, Parser`1<double>> CS$<>9__CachedAnonymousMethodDelegate25a;
    [CompilerGeneratedAttribute]
private static Func`3<<>f__AnonymousType41`2<<>f__AnonymousType40`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double, <>f__AnonymousType42`2<<>f__AnonymousType41`2<<>f__AnonymousType40`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>> CS$<>9__CachedAnonymousMethodDelegate25b;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType42`2<<>f__AnonymousType41`2<<>f__AnonymousType40`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, Parser`1<IOption`1<double>>> CS$<>9__CachedAnonymousMethodDelegate25c;
    [CompilerGeneratedAttribute]
private static Func`3<<>f__AnonymousType42`2<<>f__AnonymousType41`2<<>f__AnonymousType40`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, IOption`1<double>, <>f__AnonymousType43`2<<>f__AnonymousType42`2<<>f__AnonymousType41`2<<>f__AnonymousType40`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, IOption`1<double>>> CS$<>9__CachedAnonymousMethodDelegate25d;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType43`2<<>f__AnonymousType42`2<<>f__AnonymousType41`2<<>f__AnonymousType40`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, IOption`1<double>>, Parser`1<IOption`1<IEnumerable`1<char>>>> CS$<>9__CachedAnonymousMethodDelegate25e;
    [CompilerGeneratedAttribute]
private static Func`3<<>f__AnonymousType43`2<<>f__AnonymousType42`2<<>f__AnonymousType41`2<<>f__AnonymousType40`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, IOption`1<double>>, IOption`1<IEnumerable`1<char>>, <>f__AnonymousType44`2<<>f__AnonymousType43`2<<>f__AnonymousType42`2<<>f__AnonymousType41`2<<>f__AnonymousType40`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, IOption`1<double>>, IOption`1<IEnumerable`1<char>>>> CS$<>9__CachedAnonymousMethodDelegate25f;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType44`2<<>f__AnonymousType43`2<<>f__AnonymousType42`2<<>f__AnonymousType41`2<<>f__AnonymousType40`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, IOption`1<double>>, IOption`1<IEnumerable`1<char>>>, Parser`1<char>> CS$<>9__CachedAnonymousMethodDelegate260;
    [CompilerGeneratedAttribute]
private static Func`3<<>f__AnonymousType44`2<<>f__AnonymousType43`2<<>f__AnonymousType42`2<<>f__AnonymousType41`2<<>f__AnonymousType40`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, IOption`1<double>>, IOption`1<IEnumerable`1<char>>>, char, ScaleTransform> CS$<>9__CachedAnonymousMethodDelegate261;
    [CompilerGeneratedAttribute]
private static Func`2<IEnumerable`1<char>, Parser`1<IOption`1<IEnumerable`1<char>>>> CS$<>9__CachedAnonymousMethodDelegate262;
    [CompilerGeneratedAttribute]
private static Func`3<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>, <>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>> CS$<>9__CachedAnonymousMethodDelegate263;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, Parser`1<char>> CS$<>9__CachedAnonymousMethodDelegate264;
    [CompilerGeneratedAttribute]
private static Func`3<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char, <>f__AnonymousType45`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>> CS$<>9__CachedAnonymousMethodDelegate265;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType45`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, Parser`1<IOption`1<IEnumerable`1<char>>>> CS$<>9__CachedAnonymousMethodDelegate266;
    [CompilerGeneratedAttribute]
private static Func`3<<>f__AnonymousType45`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>, <>f__AnonymousType46`2<<>f__AnonymousType45`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>> CS$<>9__CachedAnonymousMethodDelegate267;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType46`2<<>f__AnonymousType45`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, Parser`1<double>> CS$<>9__CachedAnonymousMethodDelegate268;
    [CompilerGeneratedAttribute]
private static Func`3<<>f__AnonymousType46`2<<>f__AnonymousType45`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double, <>f__AnonymousType47`2<<>f__AnonymousType46`2<<>f__AnonymousType45`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>> CS$<>9__CachedAnonymousMethodDelegate269;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType47`2<<>f__AnonymousType46`2<<>f__AnonymousType45`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, Parser`1<IOption`1<Pair`2<double, double>>>> CS$<>9__CachedAnonymousMethodDelegate26a;
    [CompilerGeneratedAttribute]
private static Func`3<<>f__AnonymousType47`2<<>f__AnonymousType46`2<<>f__AnonymousType45`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, IOption`1<Pair`2<double, double>>, <>f__AnonymousType4a`2<<>f__AnonymousType47`2<<>f__AnonymousType46`2<<>f__AnonymousType45`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, IOption`1<Pair`2<double, double>>>> CS$<>9__CachedAnonymousMethodDelegate26b;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType4a`2<<>f__AnonymousType47`2<<>f__AnonymousType46`2<<>f__AnonymousType45`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, IOption`1<Pair`2<double, double>>>, Parser`1<IOption`1<IEnumerable`1<char>>>> CS$<>9__CachedAnonymousMethodDelegate26c;
    [CompilerGeneratedAttribute]
private static Func`3<<>f__AnonymousType4a`2<<>f__AnonymousType47`2<<>f__AnonymousType46`2<<>f__AnonymousType45`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, IOption`1<Pair`2<double, double>>>, IOption`1<IEnumerable`1<char>>, <>f__AnonymousType4b`2<<>f__AnonymousType4a`2<<>f__AnonymousType47`2<<>f__AnonymousType46`2<<>f__AnonymousType45`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, IOption`1<Pair`2<double, double>>>, IOption`1<IEnumerable`1<char>>>> CS$<>9__CachedAnonymousMethodDelegate26d;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType4b`2<<>f__AnonymousType4a`2<<>f__AnonymousType47`2<<>f__AnonymousType46`2<<>f__AnonymousType45`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, IOption`1<Pair`2<double, double>>>, IOption`1<IEnumerable`1<char>>>, Parser`1<char>> CS$<>9__CachedAnonymousMethodDelegate26e;
    [CompilerGeneratedAttribute]
private static Func`3<<>f__AnonymousType4b`2<<>f__AnonymousType4a`2<<>f__AnonymousType47`2<<>f__AnonymousType46`2<<>f__AnonymousType45`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, IOption`1<Pair`2<double, double>>>, IOption`1<IEnumerable`1<char>>>, char, RotateTransform> CS$<>9__CachedAnonymousMethodDelegate26f;
    [CompilerGeneratedAttribute]
private static Func`2<IEnumerable`1<char>, Parser`1<IOption`1<IEnumerable`1<char>>>> CS$<>9__CachedAnonymousMethodDelegate270;
    [CompilerGeneratedAttribute]
private static Func`3<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>, <>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>> CS$<>9__CachedAnonymousMethodDelegate271;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, Parser`1<char>> CS$<>9__CachedAnonymousMethodDelegate272;
    [CompilerGeneratedAttribute]
private static Func`3<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char, <>f__AnonymousType4c`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>> CS$<>9__CachedAnonymousMethodDelegate273;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType4c`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, Parser`1<IOption`1<IEnumerable`1<char>>>> CS$<>9__CachedAnonymousMethodDelegate274;
    [CompilerGeneratedAttribute]
private static Func`3<<>f__AnonymousType4c`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>, <>f__AnonymousType4d`2<<>f__AnonymousType4c`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>> CS$<>9__CachedAnonymousMethodDelegate275;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType4d`2<<>f__AnonymousType4c`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, Parser`1<double>> CS$<>9__CachedAnonymousMethodDelegate276;
    [CompilerGeneratedAttribute]
private static Func`3<<>f__AnonymousType4d`2<<>f__AnonymousType4c`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double, <>f__AnonymousType4e`2<<>f__AnonymousType4d`2<<>f__AnonymousType4c`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>> CS$<>9__CachedAnonymousMethodDelegate277;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType4e`2<<>f__AnonymousType4d`2<<>f__AnonymousType4c`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, Parser`1<IOption`1<IEnumerable`1<char>>>> CS$<>9__CachedAnonymousMethodDelegate278;
    [CompilerGeneratedAttribute]
private static Func`3<<>f__AnonymousType4e`2<<>f__AnonymousType4d`2<<>f__AnonymousType4c`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, IOption`1<IEnumerable`1<char>>, <>f__AnonymousType4f`2<<>f__AnonymousType4e`2<<>f__AnonymousType4d`2<<>f__AnonymousType4c`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, IOption`1<IEnumerable`1<char>>>> CS$<>9__CachedAnonymousMethodDelegate279;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType4f`2<<>f__AnonymousType4e`2<<>f__AnonymousType4d`2<<>f__AnonymousType4c`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, IOption`1<IEnumerable`1<char>>>, Parser`1<char>> CS$<>9__CachedAnonymousMethodDelegate27a;
    [CompilerGeneratedAttribute]
private static Func`3<<>f__AnonymousType4f`2<<>f__AnonymousType4e`2<<>f__AnonymousType4d`2<<>f__AnonymousType4c`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, IOption`1<IEnumerable`1<char>>>, char, SkewTransform> CS$<>9__CachedAnonymousMethodDelegate27b;
    [CompilerGeneratedAttribute]
private static Func`2<IEnumerable`1<char>, Parser`1<IOption`1<IEnumerable`1<char>>>> CS$<>9__CachedAnonymousMethodDelegate27c;
    [CompilerGeneratedAttribute]
private static Func`3<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>, <>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>> CS$<>9__CachedAnonymousMethodDelegate27d;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, Parser`1<char>> CS$<>9__CachedAnonymousMethodDelegate27e;
    [CompilerGeneratedAttribute]
private static Func`3<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char, <>f__AnonymousType50`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>> CS$<>9__CachedAnonymousMethodDelegate27f;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType50`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, Parser`1<IOption`1<IEnumerable`1<char>>>> CS$<>9__CachedAnonymousMethodDelegate280;
    [CompilerGeneratedAttribute]
private static Func`3<<>f__AnonymousType50`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>, <>f__AnonymousType51`2<<>f__AnonymousType50`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>> CS$<>9__CachedAnonymousMethodDelegate281;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType51`2<<>f__AnonymousType50`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, Parser`1<double>> CS$<>9__CachedAnonymousMethodDelegate282;
    [CompilerGeneratedAttribute]
private static Func`3<<>f__AnonymousType51`2<<>f__AnonymousType50`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double, <>f__AnonymousType52`2<<>f__AnonymousType51`2<<>f__AnonymousType50`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>> CS$<>9__CachedAnonymousMethodDelegate283;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType52`2<<>f__AnonymousType51`2<<>f__AnonymousType50`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, Parser`1<IOption`1<IEnumerable`1<char>>>> CS$<>9__CachedAnonymousMethodDelegate284;
    [CompilerGeneratedAttribute]
private static Func`3<<>f__AnonymousType52`2<<>f__AnonymousType51`2<<>f__AnonymousType50`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, IOption`1<IEnumerable`1<char>>, <>f__AnonymousType53`2<<>f__AnonymousType52`2<<>f__AnonymousType51`2<<>f__AnonymousType50`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, IOption`1<IEnumerable`1<char>>>> CS$<>9__CachedAnonymousMethodDelegate285;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType53`2<<>f__AnonymousType52`2<<>f__AnonymousType51`2<<>f__AnonymousType50`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, IOption`1<IEnumerable`1<char>>>, Parser`1<char>> CS$<>9__CachedAnonymousMethodDelegate286;
    [CompilerGeneratedAttribute]
private static Func`3<<>f__AnonymousType53`2<<>f__AnonymousType52`2<<>f__AnonymousType51`2<<>f__AnonymousType50`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, IOption`1<IEnumerable`1<char>>>, char, SkewTransform> CS$<>9__CachedAnonymousMethodDelegate287;
    [CompilerGeneratedAttribute]
private static Func`2<Transform, Parser`1<IOption`1<IEnumerable`1<Transform>>>> CS$<>9__CachedAnonymousMethodDelegate288;
    [CompilerGeneratedAttribute]
private static Func`3<Transform, IOption`1<IEnumerable`1<Transform>>, Transform> CS$<>9__CachedAnonymousMethodDelegate289;
    [CompilerGeneratedAttribute]
private static Func`2<IOption`1<IEnumerable`1<char>>, Parser`1<IOption`1<Transform>>> CS$<>9__CachedAnonymousMethodDelegate28a;
    [CompilerGeneratedAttribute]
private static Func`3<IOption`1<IEnumerable`1<char>>, IOption`1<Transform>, <>f__AnonymousType54`2<IOption`1<IEnumerable`1<char>>, IOption`1<Transform>>> CS$<>9__CachedAnonymousMethodDelegate28b;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType54`2<IOption`1<IEnumerable`1<char>>, IOption`1<Transform>>, Parser`1<IOption`1<IEnumerable`1<char>>>> CS$<>9__CachedAnonymousMethodDelegate28c;
    [CompilerGeneratedAttribute]
private static Func`3<<>f__AnonymousType54`2<IOption`1<IEnumerable`1<char>>, IOption`1<Transform>>, IOption`1<IEnumerable`1<char>>, Transform> CS$<>9__CachedAnonymousMethodDelegate28d;
    [CompilerGeneratedAttribute]
private static Func`2<IOption`1<IEnumerable`1<char>>, Parser`1<ICollection`1<S>>> CS$<>9__CachedAnonymousMethodDelegate28e;
    [CompilerGeneratedAttribute]
private static Func`3<IOption`1<IEnumerable`1<char>>, ICollection`1<S>, ICollection`1<S>> CS$<>9__CachedAnonymousMethodDelegate28f;
    [CompilerGeneratedAttribute]
private static Func`2<ICollection`1<S>, IEnumerable`1<S>> CS$<>9__CachedAnonymousMethodDelegate290;
    [CompilerGeneratedAttribute]
private static Func`2<IOption`1<IEnumerable`1<char>>, Parser`1<ICollection`1<S>>> CS$<>9__CachedAnonymousMethodDelegate291;
    [CompilerGeneratedAttribute]
private static Func`3<IOption`1<IEnumerable`1<char>>, ICollection`1<S>, ICollection`1<S>> CS$<>9__CachedAnonymousMethodDelegate292;
    [CompilerGeneratedAttribute]
private static Func`2<IEnumerable`1<ICollection`1<S>>, IEnumerable`1<S>> CS$<>9__CachedAnonymousMethodDelegate293;
    [CompilerGeneratedAttribute]
private static Func`2<ICollection`1<S>, IEnumerable`1<S>> CS$<>9__CachedAnonymousMethodDelegate294;
    [CompilerGeneratedAttribute]
private static Func`2<char, Parser`1<Point>> CS$<>9__CachedAnonymousMethodDelegate295;
    [CompilerGeneratedAttribute]
private static Func`3<char, Point, Point> CS$<>9__CachedAnonymousMethodDelegate296;
    [CompilerGeneratedAttribute]
private static Func`2<char, Parser`1<double>> CS$<>9__CachedAnonymousMethodDelegate297;
    [CompilerGeneratedAttribute]
private static Func`3<char, double, double> CS$<>9__CachedAnonymousMethodDelegate298;
    [CompilerGeneratedAttribute]
private static Func`2<char, Parser`1<double>> CS$<>9__CachedAnonymousMethodDelegate299;
    [CompilerGeneratedAttribute]
private static Func`3<char, double, double> CS$<>9__CachedAnonymousMethodDelegate29a;
    [CompilerGeneratedAttribute]
private static Func`2<char, Parser`1<double>> CS$<>9__CachedAnonymousMethodDelegate29b;
    [CompilerGeneratedAttribute]
private static Func`3<char, double, <>f__AnonymousType48`2<char, double>> CS$<>9__CachedAnonymousMethodDelegate29c;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType48`2<char, double>, Parser`1<char>> CS$<>9__CachedAnonymousMethodDelegate29d;
    [CompilerGeneratedAttribute]
private static Func`3<<>f__AnonymousType48`2<char, double>, char, <>f__AnonymousType49`2<<>f__AnonymousType48`2<char, double>, char>> CS$<>9__CachedAnonymousMethodDelegate29e;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType49`2<<>f__AnonymousType48`2<char, double>, char>, Parser`1<double>> CS$<>9__CachedAnonymousMethodDelegate29f;
    [CompilerGeneratedAttribute]
private static Func`3<<>f__AnonymousType49`2<<>f__AnonymousType48`2<char, double>, char>, double, Pair`2<double, double>> CS$<>9__CachedAnonymousMethodDelegate2a0;
    [CompilerGeneratedAttribute]
private static Func`2<IEnumerable`1<char>, Parser`1<Transform>> CS$<>9__CachedAnonymousMethodDelegate2a1;
    [CompilerGeneratedAttribute]
private static Func`3<IEnumerable`1<char>, Transform, Transform> CS$<>9__CachedAnonymousMethodDelegate2a2;
    private static SvgGrammar();
    private static Parser`1<ICollection`1<TItem>> ParseCommand(char ch, Parser`1<TItem> ParseItem);
    private static Parser`1<ICollection`1<TItem>> CommaWspSequence(Parser`1<TItem> ParseItem);
    [NotNullAttribute]
public static IList`1<TiSegment> ParsePolygonPointsToSegments(string sPolygonPoints, OnError onerror);
    public static IList`1<TiSegment> ParsePathDataToSegments(string sPathData, OnError onerror);
    [NotNullAttribute]
private static S[] SvgPathCommandsApplyImplicitConversions(IResult`1<ICollection`1<S>> parsed);
    private static Transform CombineTransforms(Transform first, IOption`1<IEnumerable`1<Transform>> tail);
    [CompilerGeneratedAttribute]
private static bool <.cctor>b__89(char c);
    [CompilerGeneratedAttribute]
private static string <.cctor>b__8a(char ch);
    [CompilerGeneratedAttribute]
private static Parser`1<IOption`1<string>> <.cctor>b__8b(char ee);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType6`2<char, IOption`1<string>> <.cctor>b__8c(char ee, IOption`1<string> sign);
    [CompilerGeneratedAttribute]
private static Parser`1<string> <.cctor>b__8d(<>f__AnonymousType6`2<char, IOption`1<string>> <>h__TransparentIdentifier0);
    [CompilerGeneratedAttribute]
private static string <.cctor>b__8e(<>f__AnonymousType6`2<char, IOption`1<string>> <>h__TransparentIdentifier0, string digits);
    [CompilerGeneratedAttribute]
private static Parser`1<char> <.cctor>b__8f(IOption`1<string> ds1);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType7`2<IOption`1<string>, char> <.cctor>b__90(IOption`1<string> ds1, char dot);
    [CompilerGeneratedAttribute]
private static Parser`1<string> <.cctor>b__91(<>f__AnonymousType7`2<IOption`1<string>, char> <>h__TransparentIdentifier2);
    [CompilerGeneratedAttribute]
private static string <.cctor>b__92(<>f__AnonymousType7`2<IOption`1<string>, char> <>h__TransparentIdentifier2, string ds2);
    [CompilerGeneratedAttribute]
private static Parser`1<char> <.cctor>b__93(string ds);
    [CompilerGeneratedAttribute]
private static string <.cctor>b__94(string ds, char dot);
    [CompilerGeneratedAttribute]
private static Parser`1<IOption`1<string>> <.cctor>b__95(string fc);
    [CompilerGeneratedAttribute]
private static string <.cctor>b__96(string fc, IOption`1<string> exp);
    [CompilerGeneratedAttribute]
private static Parser`1<string> <.cctor>b__97(string ds);
    [CompilerGeneratedAttribute]
private static string <.cctor>b__98(string ds, string exp);
    [CompilerGeneratedAttribute]
private static Parser`1<IOption`1<char>> <.cctor>b__99(IEnumerable`1<char> w1);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType8`2<IEnumerable`1<char>, IOption`1<char>> <.cctor>b__9a(IEnumerable`1<char> w1, IOption`1<char> c);
    [CompilerGeneratedAttribute]
private static Parser`1<IOption`1<IEnumerable`1<char>>> <.cctor>b__9b(<>f__AnonymousType8`2<IEnumerable`1<char>, IOption`1<char>> <>h__TransparentIdentifier7);
    [CompilerGeneratedAttribute]
private static char <.cctor>b__9c(<>f__AnonymousType8`2<IEnumerable`1<char>, IOption`1<char>> <>h__TransparentIdentifier7, IOption`1<IEnumerable`1<char>> w2);
    [CompilerGeneratedAttribute]
private static Parser`1<IOption`1<IEnumerable`1<char>>> <.cctor>b__9d(char c);
    [CompilerGeneratedAttribute]
private static char <.cctor>b__9e(char c, IOption`1<IEnumerable`1<char>> wsp);
    [CompilerGeneratedAttribute]
private static bool <.cctor>b__9f(char ch);
    [CompilerGeneratedAttribute]
private static Parser`1<string> <.cctor>b__a0(IOption`1<string> s);
    [CompilerGeneratedAttribute]
private static string <.cctor>b__a1(IOption`1<string> s, string fpc);
    [CompilerGeneratedAttribute]
private static Parser`1<string> <.cctor>b__a2(IOption`1<string> s);
    [CompilerGeneratedAttribute]
private static string <.cctor>b__a3(IOption`1<string> s, string ic);
    [CompilerGeneratedAttribute]
private static double <.cctor>b__a4(string s);
    [CompilerGeneratedAttribute]
private static double <.cctor>b__a5(string s);
    [CompilerGeneratedAttribute]
private static Parser`1<IOption`1<char>> <.cctor>b__a6(double c1);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType9`2<double, IOption`1<char>> <.cctor>b__a7(double c1, IOption`1<char> w);
    [CompilerGeneratedAttribute]
private static Parser`1<double> <.cctor>b__a8(<>f__AnonymousType9`2<double, IOption`1<char>> <>h__TransparentIdentifierc);
    [CompilerGeneratedAttribute]
private static Point <.cctor>b__a9(<>f__AnonymousType9`2<double, IOption`1<char>> <>h__TransparentIdentifierc, double c2);
    [CompilerGeneratedAttribute]
private static Parser`1<IOption`1<char>> <.cctor>b__aa(double rx);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousTypea`2<double, IOption`1<char>> <.cctor>b__ab(double rx, IOption`1<char> w1);
    [CompilerGeneratedAttribute]
private static Parser`1<double> <.cctor>b__ac(<>f__AnonymousTypea`2<double, IOption`1<char>> <>h__TransparentIdentifiere);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousTypeb`2<<>f__AnonymousTypea`2<double, IOption`1<char>>, double> <.cctor>b__ad(<>f__AnonymousTypea`2<double, IOption`1<char>> <>h__TransparentIdentifiere, double ry);
    [CompilerGeneratedAttribute]
private static Parser`1<IOption`1<char>> <.cctor>b__ae(<>f__AnonymousTypeb`2<<>f__AnonymousTypea`2<double, IOption`1<char>>, double> <>h__TransparentIdentifierf);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousTypec`2<<>f__AnonymousTypeb`2<<>f__AnonymousTypea`2<double, IOption`1<char>>, double>, IOption`1<char>> <.cctor>b__af(<>f__AnonymousTypeb`2<<>f__AnonymousTypea`2<double, IOption`1<char>>, double> <>h__TransparentIdentifierf, IOption`1<char> w2);
    [CompilerGeneratedAttribute]
private static Parser`1<double> <.cctor>b__b0(<>f__AnonymousTypec`2<<>f__AnonymousTypeb`2<<>f__AnonymousTypea`2<double, IOption`1<char>>, double>, IOption`1<char>> <>h__TransparentIdentifier10);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousTyped`2<<>f__AnonymousTypec`2<<>f__AnonymousTypeb`2<<>f__AnonymousTypea`2<double, IOption`1<char>>, double>, IOption`1<char>>, double> <.cctor>b__b1(<>f__AnonymousTypec`2<<>f__AnonymousTypeb`2<<>f__AnonymousTypea`2<double, IOption`1<char>>, double>, IOption`1<char>> <>h__TransparentIdentifier10, double x_axis_rotation);
    [CompilerGeneratedAttribute]
private static Parser`1<char> <.cctor>b__b2(<>f__AnonymousTyped`2<<>f__AnonymousTypec`2<<>f__AnonymousTypeb`2<<>f__AnonymousTypea`2<double, IOption`1<char>>, double>, IOption`1<char>>, double> <>h__TransparentIdentifier11);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousTypee`2<<>f__AnonymousTyped`2<<>f__AnonymousTypec`2<<>f__AnonymousTypeb`2<<>f__AnonymousTypea`2<double, IOption`1<char>>, double>, IOption`1<char>>, double>, char> <.cctor>b__b3(<>f__AnonymousTyped`2<<>f__AnonymousTypec`2<<>f__AnonymousTypeb`2<<>f__AnonymousTypea`2<double, IOption`1<char>>, double>, IOption`1<char>>, double> <>h__TransparentIdentifier11, char w3);
    [CompilerGeneratedAttribute]
private static Parser`1<bool> <.cctor>b__b4(<>f__AnonymousTypee`2<<>f__AnonymousTyped`2<<>f__AnonymousTypec`2<<>f__AnonymousTypeb`2<<>f__AnonymousTypea`2<double, IOption`1<char>>, double>, IOption`1<char>>, double>, char> <>h__TransparentIdentifier12);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousTypef`2<<>f__AnonymousTypee`2<<>f__AnonymousTyped`2<<>f__AnonymousTypec`2<<>f__AnonymousTypeb`2<<>f__AnonymousTypea`2<double, IOption`1<char>>, double>, IOption`1<char>>, double>, char>, bool> <.cctor>b__b5(<>f__AnonymousTypee`2<<>f__AnonymousTyped`2<<>f__AnonymousTypec`2<<>f__AnonymousTypeb`2<<>f__AnonymousTypea`2<double, IOption`1<char>>, double>, IOption`1<char>>, double>, char> <>h__TransparentIdentifier12, bool large_arc_flag);
    [CompilerGeneratedAttribute]
private static Parser`1<IOption`1<char>> <.cctor>b__b6(<>f__AnonymousTypef`2<<>f__AnonymousTypee`2<<>f__AnonymousTyped`2<<>f__AnonymousTypec`2<<>f__AnonymousTypeb`2<<>f__AnonymousTypea`2<double, IOption`1<char>>, double>, IOption`1<char>>, double>, char>, bool> <>h__TransparentIdentifier13);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType10`2<<>f__AnonymousTypef`2<<>f__AnonymousTypee`2<<>f__AnonymousTyped`2<<>f__AnonymousTypec`2<<>f__AnonymousTypeb`2<<>f__AnonymousTypea`2<double, IOption`1<char>>, double>, IOption`1<char>>, double>, char>, bool>, IOption`1<char>> <.cctor>b__b7(<>f__AnonymousTypef`2<<>f__AnonymousTypee`2<<>f__AnonymousTyped`2<<>f__AnonymousTypec`2<<>f__AnonymousTypeb`2<<>f__AnonymousTypea`2<double, IOption`1<char>>, double>, IOption`1<char>>, double>, char>, bool> <>h__TransparentIdentifier13, IOption`1<char> w4);
    [CompilerGeneratedAttribute]
private static Parser`1<bool> <.cctor>b__b8(<>f__AnonymousType10`2<<>f__AnonymousTypef`2<<>f__AnonymousTypee`2<<>f__AnonymousTyped`2<<>f__AnonymousTypec`2<<>f__AnonymousTypeb`2<<>f__AnonymousTypea`2<double, IOption`1<char>>, double>, IOption`1<char>>, double>, char>, bool>, IOption`1<char>> <>h__TransparentIdentifier14);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType11`2<<>f__AnonymousType10`2<<>f__AnonymousTypef`2<<>f__AnonymousTypee`2<<>f__AnonymousTyped`2<<>f__AnonymousTypec`2<<>f__AnonymousTypeb`2<<>f__AnonymousTypea`2<double, IOption`1<char>>, double>, IOption`1<char>>, double>, char>, bool>, IOption`1<char>>, bool> <.cctor>b__b9(<>f__AnonymousType10`2<<>f__AnonymousTypef`2<<>f__AnonymousTypee`2<<>f__AnonymousTyped`2<<>f__AnonymousTypec`2<<>f__AnonymousTypeb`2<<>f__AnonymousTypea`2<double, IOption`1<char>>, double>, IOption`1<char>>, double>, char>, bool>, IOption`1<char>> <>h__TransparentIdentifier14, bool sweep_flag);
    [CompilerGeneratedAttribute]
private static Parser`1<IOption`1<char>> <.cctor>b__ba(<>f__AnonymousType11`2<<>f__AnonymousType10`2<<>f__AnonymousTypef`2<<>f__AnonymousTypee`2<<>f__AnonymousTyped`2<<>f__AnonymousTypec`2<<>f__AnonymousTypeb`2<<>f__AnonymousTypea`2<double, IOption`1<char>>, double>, IOption`1<char>>, double>, char>, bool>, IOption`1<char>>, bool> <>h__TransparentIdentifier15);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType12`2<<>f__AnonymousType11`2<<>f__AnonymousType10`2<<>f__AnonymousTypef`2<<>f__AnonymousTypee`2<<>f__AnonymousTyped`2<<>f__AnonymousTypec`2<<>f__AnonymousTypeb`2<<>f__AnonymousTypea`2<double, IOption`1<char>>, double>, IOption`1<char>>, double>, char>, bool>, IOption`1<char>>, bool>, IOption`1<char>> <.cctor>b__bb(<>f__AnonymousType11`2<<>f__AnonymousType10`2<<>f__AnonymousTypef`2<<>f__AnonymousTypee`2<<>f__AnonymousTyped`2<<>f__AnonymousTypec`2<<>f__AnonymousTypeb`2<<>f__AnonymousTypea`2<double, IOption`1<char>>, double>, IOption`1<char>>, double>, char>, bool>, IOption`1<char>>, bool> <>h__TransparentIdentifier15, IOption`1<char> w5);
    [CompilerGeneratedAttribute]
private static Parser`1<Point> <.cctor>b__bc(<>f__AnonymousType12`2<<>f__AnonymousType11`2<<>f__AnonymousType10`2<<>f__AnonymousTypef`2<<>f__AnonymousTypee`2<<>f__AnonymousTyped`2<<>f__AnonymousTypec`2<<>f__AnonymousTypeb`2<<>f__AnonymousTypea`2<double, IOption`1<char>>, double>, IOption`1<char>>, double>, char>, bool>, IOption`1<char>>, bool>, IOption`1<char>> <>h__TransparentIdentifier16);
    [CompilerGeneratedAttribute]
private static SA <.cctor>b__bd(<>f__AnonymousType12`2<<>f__AnonymousType11`2<<>f__AnonymousType10`2<<>f__AnonymousTypef`2<<>f__AnonymousTypee`2<<>f__AnonymousTyped`2<<>f__AnonymousTypec`2<<>f__AnonymousTypeb`2<<>f__AnonymousTypea`2<double, IOption`1<char>>, double>, IOption`1<char>>, double>, char>, bool>, IOption`1<char>>, bool>, IOption`1<char>> <>h__TransparentIdentifier16, Point xy);
    [CompilerGeneratedAttribute]
private static S <.cctor>b__be(double c);
    [CompilerGeneratedAttribute]
private static S <.cctor>b__bf(double c);
    [CompilerGeneratedAttribute]
private static S <.cctor>b__c0(Point o);
    [CompilerGeneratedAttribute]
private static S <.cctor>b__c1(Point o);
    [CompilerGeneratedAttribute]
private static Parser`1<IOption`1<char>> <.cctor>b__c2(Point xy1);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType13`2<Point, IOption`1<char>> <.cctor>b__c3(Point xy1, IOption`1<char> w1);
    [CompilerGeneratedAttribute]
private static Parser`1<Point> <.cctor>b__c4(<>f__AnonymousType13`2<Point, IOption`1<char>> <>h__TransparentIdentifier18);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType14`2<<>f__AnonymousType13`2<Point, IOption`1<char>>, Point> <.cctor>b__c5(<>f__AnonymousType13`2<Point, IOption`1<char>> <>h__TransparentIdentifier18, Point xy2);
    [CompilerGeneratedAttribute]
private static Parser`1<IOption`1<char>> <.cctor>b__c6(<>f__AnonymousType14`2<<>f__AnonymousType13`2<Point, IOption`1<char>>, Point> <>h__TransparentIdentifier19);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType15`2<<>f__AnonymousType14`2<<>f__AnonymousType13`2<Point, IOption`1<char>>, Point>, IOption`1<char>> <.cctor>b__c7(<>f__AnonymousType14`2<<>f__AnonymousType13`2<Point, IOption`1<char>>, Point> <>h__TransparentIdentifier19, IOption`1<char> w2);
    [CompilerGeneratedAttribute]
private static Parser`1<Point> <.cctor>b__c8(<>f__AnonymousType15`2<<>f__AnonymousType14`2<<>f__AnonymousType13`2<Point, IOption`1<char>>, Point>, IOption`1<char>> <>h__TransparentIdentifier1a);
    [CompilerGeneratedAttribute]
private static SC <.cctor>b__c9(<>f__AnonymousType15`2<<>f__AnonymousType14`2<<>f__AnonymousType13`2<Point, IOption`1<char>>, Point>, IOption`1<char>> <>h__TransparentIdentifier1a, Point xy);
    [CompilerGeneratedAttribute]
private static Parser`1<IOption`1<char>> <.cctor>b__ca(Point xy2);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType16`2<Point, IOption`1<char>> <.cctor>b__cb(Point xy2, IOption`1<char> w1);
    [CompilerGeneratedAttribute]
private static Parser`1<Point> <.cctor>b__cc(<>f__AnonymousType16`2<Point, IOption`1<char>> <>h__TransparentIdentifier1c);
    [CompilerGeneratedAttribute]
private static SS <.cctor>b__cd(<>f__AnonymousType16`2<Point, IOption`1<char>> <>h__TransparentIdentifier1c, Point xy);
    [CompilerGeneratedAttribute]
private static Parser`1<IOption`1<char>> <.cctor>b__ce(Point xy1);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType13`2<Point, IOption`1<char>> <.cctor>b__cf(Point xy1, IOption`1<char> w1);
    [CompilerGeneratedAttribute]
private static Parser`1<Point> <.cctor>b__d0(<>f__AnonymousType13`2<Point, IOption`1<char>> <>h__TransparentIdentifier1e);
    [CompilerGeneratedAttribute]
private static SQ <.cctor>b__d1(<>f__AnonymousType13`2<Point, IOption`1<char>> <>h__TransparentIdentifier1e, Point xy);
    [CompilerGeneratedAttribute]
private static ST <.cctor>b__d2(Point pt);
    [CompilerGeneratedAttribute]
private static SZ <.cctor>b__d3(char ch);
    [CompilerGeneratedAttribute]
private static S[] <.cctor>b__d4(SZ x);
    [CompilerGeneratedAttribute]
private static Parser`1<IOption`1<IEnumerable`1<ICollection`1<S>>>> <.cctor>b__d5(ICollection`1<S> first);
    [CompilerGeneratedAttribute]
private static ICollection`1<S> <.cctor>b__d8(ICollection`1<S> first, IOption`1<IEnumerable`1<ICollection`1<S>>> tail);
    [CompilerGeneratedAttribute]
private static Parser`1<IOption`1<IEnumerable`1<char>>> <.cctor>b__da(ICollection`1<S> m);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType17`2<ICollection`1<S>, IOption`1<IEnumerable`1<char>>> <.cctor>b__db(ICollection`1<S> m, IOption`1<IEnumerable`1<char>> w);
    [CompilerGeneratedAttribute]
private static Parser`1<IOption`1<ICollection`1<S>>> <.cctor>b__dc(<>f__AnonymousType17`2<ICollection`1<S>, IOption`1<IEnumerable`1<char>>> <>h__TransparentIdentifier22);
    [CompilerGeneratedAttribute]
private static ICollection`1<S> <.cctor>b__dd(<>f__AnonymousType17`2<ICollection`1<S>, IOption`1<IEnumerable`1<char>>> <>h__TransparentIdentifier22, IOption`1<ICollection`1<S>> ds);
    [CompilerGeneratedAttribute]
private static Parser`1<IOption`1<IEnumerable`1<S>>> <.cctor>b__de(ICollection`1<S> first);
    [CompilerGeneratedAttribute]
private static ICollection`1<S> <.cctor>b__e3(ICollection`1<S> first, IOption`1<IEnumerable`1<S>> tail);
    [CompilerGeneratedAttribute]
private static Parser`1<IOption`1<ICollection`1<S>>> <.cctor>b__e4(IOption`1<IEnumerable`1<char>> w1);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType18`2<IOption`1<IEnumerable`1<char>>, IOption`1<ICollection`1<S>>> <.cctor>b__e5(IOption`1<IEnumerable`1<char>> w1, IOption`1<ICollection`1<S>> items);
    [CompilerGeneratedAttribute]
private static Parser`1<IOption`1<IEnumerable`1<char>>> <.cctor>b__e6(<>f__AnonymousType18`2<IOption`1<IEnumerable`1<char>>, IOption`1<ICollection`1<S>>> <>h__TransparentIdentifier26);
    [CompilerGeneratedAttribute]
private static ICollection`1<S> <.cctor>b__e7(<>f__AnonymousType18`2<IOption`1<IEnumerable`1<char>>, IOption`1<ICollection`1<S>>> <>h__TransparentIdentifier26, IOption`1<IEnumerable`1<char>> w2);
    [CompilerGeneratedAttribute]
private static Parser`1<IOption`1<IEnumerable`1<Point>>> <.cctor>b__e8(Point first);
    [CompilerGeneratedAttribute]
private static ICollection`1<Point> <.cctor>b__eb(Point first, IOption`1<IEnumerable`1<Point>> tail);
    [CompilerGeneratedAttribute]
private static Parser`1<IOption`1<ICollection`1<Point>>> <.cctor>b__ec(IOption`1<IEnumerable`1<char>> w1);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType19`2<IOption`1<IEnumerable`1<char>>, IOption`1<ICollection`1<Point>>> <.cctor>b__ed(IOption`1<IEnumerable`1<char>> w1, IOption`1<ICollection`1<Point>> cps);
    [CompilerGeneratedAttribute]
private static Parser`1<IOption`1<IEnumerable`1<char>>> <.cctor>b__ee(<>f__AnonymousType19`2<IOption`1<IEnumerable`1<char>>, IOption`1<ICollection`1<Point>>> <>h__TransparentIdentifier2a);
    [CompilerGeneratedAttribute]
private static ICollection`1<Point> <.cctor>b__ef(<>f__AnonymousType19`2<IOption`1<IEnumerable`1<char>>, IOption`1<ICollection`1<Point>>> <>h__TransparentIdentifier2a, IOption`1<IEnumerable`1<char>> w2);
    [CompilerGeneratedAttribute]
private static bool <.cctor>b__f0(char ch);
    [CompilerGeneratedAttribute]
private static Parser`1<byte> <.cctor>b__f1(char hash);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType1a`2<char, byte> <.cctor>b__f2(char hash, byte r);
    [CompilerGeneratedAttribute]
private static Parser`1<byte> <.cctor>b__f3(<>f__AnonymousType1a`2<char, byte> <>h__TransparentIdentifier2c);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType1b`2<<>f__AnonymousType1a`2<char, byte>, byte> <.cctor>b__f4(<>f__AnonymousType1a`2<char, byte> <>h__TransparentIdentifier2c, byte g);
    [CompilerGeneratedAttribute]
private static Parser`1<byte> <.cctor>b__f5(<>f__AnonymousType1b`2<<>f__AnonymousType1a`2<char, byte>, byte> <>h__TransparentIdentifier2d);
    [CompilerGeneratedAttribute]
private static Color <.cctor>b__f6(<>f__AnonymousType1b`2<<>f__AnonymousType1a`2<char, byte>, byte> <>h__TransparentIdentifier2d, byte b);
    [CompilerGeneratedAttribute]
private static Parser`1<byte> <.cctor>b__f7(char hash);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType1c`2<char, byte> <.cctor>b__f8(char hash, byte a);
    [CompilerGeneratedAttribute]
private static Parser`1<byte> <.cctor>b__f9(<>f__AnonymousType1c`2<char, byte> <>h__TransparentIdentifier2f);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType1d`2<<>f__AnonymousType1c`2<char, byte>, byte> <.cctor>b__fa(<>f__AnonymousType1c`2<char, byte> <>h__TransparentIdentifier2f, byte r);
    [CompilerGeneratedAttribute]
private static Parser`1<byte> <.cctor>b__fb(<>f__AnonymousType1d`2<<>f__AnonymousType1c`2<char, byte>, byte> <>h__TransparentIdentifier30);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType1e`2<<>f__AnonymousType1d`2<<>f__AnonymousType1c`2<char, byte>, byte>, byte> <.cctor>b__fc(<>f__AnonymousType1d`2<<>f__AnonymousType1c`2<char, byte>, byte> <>h__TransparentIdentifier30, byte g);
    [CompilerGeneratedAttribute]
private static Parser`1<byte> <.cctor>b__fd(<>f__AnonymousType1e`2<<>f__AnonymousType1d`2<<>f__AnonymousType1c`2<char, byte>, byte>, byte> <>h__TransparentIdentifier31);
    [CompilerGeneratedAttribute]
private static Color <.cctor>b__fe(<>f__AnonymousType1e`2<<>f__AnonymousType1d`2<<>f__AnonymousType1c`2<char, byte>, byte>, byte> <>h__TransparentIdentifier31, byte b);
    [CompilerGeneratedAttribute]
private static Parser`1<byte> <.cctor>b__ff(char hash);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType1f`2<char, byte> <.cctor>b__100(char hash, byte rh);
    [CompilerGeneratedAttribute]
private static Parser`1<byte> <.cctor>b__101(<>f__AnonymousType1f`2<char, byte> <>h__TransparentIdentifier33);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType20`2<<>f__AnonymousType1f`2<char, byte>, byte> <.cctor>b__102(<>f__AnonymousType1f`2<char, byte> <>h__TransparentIdentifier33, byte rl);
    [CompilerGeneratedAttribute]
private static Parser`1<byte> <.cctor>b__103(<>f__AnonymousType20`2<<>f__AnonymousType1f`2<char, byte>, byte> <>h__TransparentIdentifier34);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType21`2<<>f__AnonymousType20`2<<>f__AnonymousType1f`2<char, byte>, byte>, byte> <.cctor>b__104(<>f__AnonymousType20`2<<>f__AnonymousType1f`2<char, byte>, byte> <>h__TransparentIdentifier34, byte gh);
    [CompilerGeneratedAttribute]
private static Parser`1<byte> <.cctor>b__105(<>f__AnonymousType21`2<<>f__AnonymousType20`2<<>f__AnonymousType1f`2<char, byte>, byte>, byte> <>h__TransparentIdentifier35);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType22`2<<>f__AnonymousType21`2<<>f__AnonymousType20`2<<>f__AnonymousType1f`2<char, byte>, byte>, byte>, byte> <.cctor>b__106(<>f__AnonymousType21`2<<>f__AnonymousType20`2<<>f__AnonymousType1f`2<char, byte>, byte>, byte> <>h__TransparentIdentifier35, byte gl);
    [CompilerGeneratedAttribute]
private static Parser`1<byte> <.cctor>b__107(<>f__AnonymousType22`2<<>f__AnonymousType21`2<<>f__AnonymousType20`2<<>f__AnonymousType1f`2<char, byte>, byte>, byte>, byte> <>h__TransparentIdentifier36);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType23`2<<>f__AnonymousType22`2<<>f__AnonymousType21`2<<>f__AnonymousType20`2<<>f__AnonymousType1f`2<char, byte>, byte>, byte>, byte>, byte> <.cctor>b__108(<>f__AnonymousType22`2<<>f__AnonymousType21`2<<>f__AnonymousType20`2<<>f__AnonymousType1f`2<char, byte>, byte>, byte>, byte> <>h__TransparentIdentifier36, byte bh);
    [CompilerGeneratedAttribute]
private static Parser`1<byte> <.cctor>b__109(<>f__AnonymousType23`2<<>f__AnonymousType22`2<<>f__AnonymousType21`2<<>f__AnonymousType20`2<<>f__AnonymousType1f`2<char, byte>, byte>, byte>, byte>, byte> <>h__TransparentIdentifier37);
    [CompilerGeneratedAttribute]
private static Color <.cctor>b__10a(<>f__AnonymousType23`2<<>f__AnonymousType22`2<<>f__AnonymousType21`2<<>f__AnonymousType20`2<<>f__AnonymousType1f`2<char, byte>, byte>, byte>, byte>, byte> <>h__TransparentIdentifier37, byte bl);
    [CompilerGeneratedAttribute]
private static Parser`1<byte> <.cctor>b__10b(char hash);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType24`2<char, byte> <.cctor>b__10c(char hash, byte ah);
    [CompilerGeneratedAttribute]
private static Parser`1<byte> <.cctor>b__10d(<>f__AnonymousType24`2<char, byte> <>h__TransparentIdentifier39);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType25`2<<>f__AnonymousType24`2<char, byte>, byte> <.cctor>b__10e(<>f__AnonymousType24`2<char, byte> <>h__TransparentIdentifier39, byte al);
    [CompilerGeneratedAttribute]
private static Parser`1<byte> <.cctor>b__10f(<>f__AnonymousType25`2<<>f__AnonymousType24`2<char, byte>, byte> <>h__TransparentIdentifier3a);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType26`2<<>f__AnonymousType25`2<<>f__AnonymousType24`2<char, byte>, byte>, byte> <.cctor>b__110(<>f__AnonymousType25`2<<>f__AnonymousType24`2<char, byte>, byte> <>h__TransparentIdentifier3a, byte rh);
    [CompilerGeneratedAttribute]
private static Parser`1<byte> <.cctor>b__111(<>f__AnonymousType26`2<<>f__AnonymousType25`2<<>f__AnonymousType24`2<char, byte>, byte>, byte> <>h__TransparentIdentifier3b);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType27`2<<>f__AnonymousType26`2<<>f__AnonymousType25`2<<>f__AnonymousType24`2<char, byte>, byte>, byte>, byte> <.cctor>b__112(<>f__AnonymousType26`2<<>f__AnonymousType25`2<<>f__AnonymousType24`2<char, byte>, byte>, byte> <>h__TransparentIdentifier3b, byte rl);
    [CompilerGeneratedAttribute]
private static Parser`1<byte> <.cctor>b__113(<>f__AnonymousType27`2<<>f__AnonymousType26`2<<>f__AnonymousType25`2<<>f__AnonymousType24`2<char, byte>, byte>, byte>, byte> <>h__TransparentIdentifier3c);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType28`2<<>f__AnonymousType27`2<<>f__AnonymousType26`2<<>f__AnonymousType25`2<<>f__AnonymousType24`2<char, byte>, byte>, byte>, byte>, byte> <.cctor>b__114(<>f__AnonymousType27`2<<>f__AnonymousType26`2<<>f__AnonymousType25`2<<>f__AnonymousType24`2<char, byte>, byte>, byte>, byte> <>h__TransparentIdentifier3c, byte gh);
    [CompilerGeneratedAttribute]
private static Parser`1<byte> <.cctor>b__115(<>f__AnonymousType28`2<<>f__AnonymousType27`2<<>f__AnonymousType26`2<<>f__AnonymousType25`2<<>f__AnonymousType24`2<char, byte>, byte>, byte>, byte>, byte> <>h__TransparentIdentifier3d);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType29`2<<>f__AnonymousType28`2<<>f__AnonymousType27`2<<>f__AnonymousType26`2<<>f__AnonymousType25`2<<>f__AnonymousType24`2<char, byte>, byte>, byte>, byte>, byte>, byte> <.cctor>b__116(<>f__AnonymousType28`2<<>f__AnonymousType27`2<<>f__AnonymousType26`2<<>f__AnonymousType25`2<<>f__AnonymousType24`2<char, byte>, byte>, byte>, byte>, byte> <>h__TransparentIdentifier3d, byte gl);
    [CompilerGeneratedAttribute]
private static Parser`1<byte> <.cctor>b__117(<>f__AnonymousType29`2<<>f__AnonymousType28`2<<>f__AnonymousType27`2<<>f__AnonymousType26`2<<>f__AnonymousType25`2<<>f__AnonymousType24`2<char, byte>, byte>, byte>, byte>, byte>, byte> <>h__TransparentIdentifier3e);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType2a`2<<>f__AnonymousType29`2<<>f__AnonymousType28`2<<>f__AnonymousType27`2<<>f__AnonymousType26`2<<>f__AnonymousType25`2<<>f__AnonymousType24`2<char, byte>, byte>, byte>, byte>, byte>, byte>, byte> <.cctor>b__118(<>f__AnonymousType29`2<<>f__AnonymousType28`2<<>f__AnonymousType27`2<<>f__AnonymousType26`2<<>f__AnonymousType25`2<<>f__AnonymousType24`2<char, byte>, byte>, byte>, byte>, byte>, byte> <>h__TransparentIdentifier3e, byte bh);
    [CompilerGeneratedAttribute]
private static Parser`1<byte> <.cctor>b__119(<>f__AnonymousType2a`2<<>f__AnonymousType29`2<<>f__AnonymousType28`2<<>f__AnonymousType27`2<<>f__AnonymousType26`2<<>f__AnonymousType25`2<<>f__AnonymousType24`2<char, byte>, byte>, byte>, byte>, byte>, byte>, byte> <>h__TransparentIdentifier3f);
    [CompilerGeneratedAttribute]
private static Color <.cctor>b__11a(<>f__AnonymousType2a`2<<>f__AnonymousType29`2<<>f__AnonymousType28`2<<>f__AnonymousType27`2<<>f__AnonymousType26`2<<>f__AnonymousType25`2<<>f__AnonymousType24`2<char, byte>, byte>, byte>, byte>, byte>, byte>, byte> <>h__TransparentIdentifier3f, byte bl);
    [CompilerGeneratedAttribute]
private static Parser`1<string> <.cctor>b__11b(IEnumerable`1<char> open);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType2b`2<IEnumerable`1<char>, string> <.cctor>b__11c(IEnumerable`1<char> open, string iri);
    [CompilerGeneratedAttribute]
private static Parser`1<char> <.cctor>b__11d(<>f__AnonymousType2b`2<IEnumerable`1<char>, string> <>h__TransparentIdentifier41);
    [CompilerGeneratedAttribute]
private static string <.cctor>b__11e(<>f__AnonymousType2b`2<IEnumerable`1<char>, string> <>h__TransparentIdentifier41, char close);
    [CompilerGeneratedAttribute]
private static Nullable`1<ColorOrIri> <.cctor>b__11f(IEnumerable`1<char> o);
    [CompilerGeneratedAttribute]
private static Nullable`1<ColorOrIri> <.cctor>b__120(Color c);
    [CompilerGeneratedAttribute]
private static Nullable`1<ColorOrIri> <.cctor>b__121(string u);
    [CompilerGeneratedAttribute]
private static Parser`1<IOption`1<IEnumerable`1<char>>> <.cctor>b__122(IEnumerable`1<char> prefix);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>> <.cctor>b__123(IEnumerable`1<char> prefix, IOption`1<IEnumerable`1<char>> w1);
    [CompilerGeneratedAttribute]
private static Parser`1<char> <.cctor>b__124(<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>> <>h__TransparentIdentifier43);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType2d`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char> <.cctor>b__125(<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>> <>h__TransparentIdentifier43, char leftparen);
    [CompilerGeneratedAttribute]
private static Parser`1<IOption`1<IEnumerable`1<char>>> <.cctor>b__126(<>f__AnonymousType2d`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char> <>h__TransparentIdentifier44);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType2e`2<<>f__AnonymousType2d`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>> <.cctor>b__127(<>f__AnonymousType2d`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char> <>h__TransparentIdentifier44, IOption`1<IEnumerable`1<char>> w2);
    [CompilerGeneratedAttribute]
private static Parser`1<double> <.cctor>b__128(<>f__AnonymousType2e`2<<>f__AnonymousType2d`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>> <>h__TransparentIdentifier45);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType2f`2<<>f__AnonymousType2e`2<<>f__AnonymousType2d`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double> <.cctor>b__129(<>f__AnonymousType2e`2<<>f__AnonymousType2d`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>> <>h__TransparentIdentifier45, double n1);
    [CompilerGeneratedAttribute]
private static Parser`1<char> <.cctor>b__12a(<>f__AnonymousType2f`2<<>f__AnonymousType2e`2<<>f__AnonymousType2d`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double> <>h__TransparentIdentifier46);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType30`2<<>f__AnonymousType2f`2<<>f__AnonymousType2e`2<<>f__AnonymousType2d`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, char> <.cctor>b__12b(<>f__AnonymousType2f`2<<>f__AnonymousType2e`2<<>f__AnonymousType2d`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double> <>h__TransparentIdentifier46, char wan1);
    [CompilerGeneratedAttribute]
private static Parser`1<double> <.cctor>b__12c(<>f__AnonymousType30`2<<>f__AnonymousType2f`2<<>f__AnonymousType2e`2<<>f__AnonymousType2d`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, char> <>h__TransparentIdentifier47);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType31`2<<>f__AnonymousType30`2<<>f__AnonymousType2f`2<<>f__AnonymousType2e`2<<>f__AnonymousType2d`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, char>, double> <.cctor>b__12d(<>f__AnonymousType30`2<<>f__AnonymousType2f`2<<>f__AnonymousType2e`2<<>f__AnonymousType2d`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, char> <>h__TransparentIdentifier47, double n2);
    [CompilerGeneratedAttribute]
private static Parser`1<char> <.cctor>b__12e(<>f__AnonymousType31`2<<>f__AnonymousType30`2<<>f__AnonymousType2f`2<<>f__AnonymousType2e`2<<>f__AnonymousType2d`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, char>, double> <>h__TransparentIdentifier48);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType32`2<<>f__AnonymousType31`2<<>f__AnonymousType30`2<<>f__AnonymousType2f`2<<>f__AnonymousType2e`2<<>f__AnonymousType2d`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, char>, double>, char> <.cctor>b__12f(<>f__AnonymousType31`2<<>f__AnonymousType30`2<<>f__AnonymousType2f`2<<>f__AnonymousType2e`2<<>f__AnonymousType2d`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, char>, double> <>h__TransparentIdentifier48, char wan2);
    [CompilerGeneratedAttribute]
private static Parser`1<double> <.cctor>b__130(<>f__AnonymousType32`2<<>f__AnonymousType31`2<<>f__AnonymousType30`2<<>f__AnonymousType2f`2<<>f__AnonymousType2e`2<<>f__AnonymousType2d`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, char>, double>, char> <>h__TransparentIdentifier49);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType33`2<<>f__AnonymousType32`2<<>f__AnonymousType31`2<<>f__AnonymousType30`2<<>f__AnonymousType2f`2<<>f__AnonymousType2e`2<<>f__AnonymousType2d`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, char>, double>, char>, double> <.cctor>b__131(<>f__AnonymousType32`2<<>f__AnonymousType31`2<<>f__AnonymousType30`2<<>f__AnonymousType2f`2<<>f__AnonymousType2e`2<<>f__AnonymousType2d`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, char>, double>, char> <>h__TransparentIdentifier49, double n3);
    [CompilerGeneratedAttribute]
private static Parser`1<char> <.cctor>b__132(<>f__AnonymousType33`2<<>f__AnonymousType32`2<<>f__AnonymousType31`2<<>f__AnonymousType30`2<<>f__AnonymousType2f`2<<>f__AnonymousType2e`2<<>f__AnonymousType2d`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, char>, double>, char>, double> <>h__TransparentIdentifier4a);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType34`2<<>f__AnonymousType33`2<<>f__AnonymousType32`2<<>f__AnonymousType31`2<<>f__AnonymousType30`2<<>f__AnonymousType2f`2<<>f__AnonymousType2e`2<<>f__AnonymousType2d`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, char>, double>, char>, double>, char> <.cctor>b__133(<>f__AnonymousType33`2<<>f__AnonymousType32`2<<>f__AnonymousType31`2<<>f__AnonymousType30`2<<>f__AnonymousType2f`2<<>f__AnonymousType2e`2<<>f__AnonymousType2d`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, char>, double>, char>, double> <>h__TransparentIdentifier4a, char wan3);
    [CompilerGeneratedAttribute]
private static Parser`1<double> <.cctor>b__134(<>f__AnonymousType34`2<<>f__AnonymousType33`2<<>f__AnonymousType32`2<<>f__AnonymousType31`2<<>f__AnonymousType30`2<<>f__AnonymousType2f`2<<>f__AnonymousType2e`2<<>f__AnonymousType2d`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, char>, double>, char>, double>, char> <>h__TransparentIdentifier4b);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType35`2<<>f__AnonymousType34`2<<>f__AnonymousType33`2<<>f__AnonymousType32`2<<>f__AnonymousType31`2<<>f__AnonymousType30`2<<>f__AnonymousType2f`2<<>f__AnonymousType2e`2<<>f__AnonymousType2d`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, char>, double>, char>, double>, char>, double> <.cctor>b__135(<>f__AnonymousType34`2<<>f__AnonymousType33`2<<>f__AnonymousType32`2<<>f__AnonymousType31`2<<>f__AnonymousType30`2<<>f__AnonymousType2f`2<<>f__AnonymousType2e`2<<>f__AnonymousType2d`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, char>, double>, char>, double>, char> <>h__TransparentIdentifier4b, double n4);
    [CompilerGeneratedAttribute]
private static Parser`1<char> <.cctor>b__136(<>f__AnonymousType35`2<<>f__AnonymousType34`2<<>f__AnonymousType33`2<<>f__AnonymousType32`2<<>f__AnonymousType31`2<<>f__AnonymousType30`2<<>f__AnonymousType2f`2<<>f__AnonymousType2e`2<<>f__AnonymousType2d`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, char>, double>, char>, double>, char>, double> <>h__TransparentIdentifier4c);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType36`2<<>f__AnonymousType35`2<<>f__AnonymousType34`2<<>f__AnonymousType33`2<<>f__AnonymousType32`2<<>f__AnonymousType31`2<<>f__AnonymousType30`2<<>f__AnonymousType2f`2<<>f__AnonymousType2e`2<<>f__AnonymousType2d`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, char>, double>, char>, double>, char>, double>, char> <.cctor>b__137(<>f__AnonymousType35`2<<>f__AnonymousType34`2<<>f__AnonymousType33`2<<>f__AnonymousType32`2<<>f__AnonymousType31`2<<>f__AnonymousType30`2<<>f__AnonymousType2f`2<<>f__AnonymousType2e`2<<>f__AnonymousType2d`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, char>, double>, char>, double>, char>, double> <>h__TransparentIdentifier4c, char wan4);
    [CompilerGeneratedAttribute]
private static Parser`1<double> <.cctor>b__138(<>f__AnonymousType36`2<<>f__AnonymousType35`2<<>f__AnonymousType34`2<<>f__AnonymousType33`2<<>f__AnonymousType32`2<<>f__AnonymousType31`2<<>f__AnonymousType30`2<<>f__AnonymousType2f`2<<>f__AnonymousType2e`2<<>f__AnonymousType2d`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, char>, double>, char>, double>, char>, double>, char> <>h__TransparentIdentifier4d);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType37`2<<>f__AnonymousType36`2<<>f__AnonymousType35`2<<>f__AnonymousType34`2<<>f__AnonymousType33`2<<>f__AnonymousType32`2<<>f__AnonymousType31`2<<>f__AnonymousType30`2<<>f__AnonymousType2f`2<<>f__AnonymousType2e`2<<>f__AnonymousType2d`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, char>, double>, char>, double>, char>, double>, char>, double> <.cctor>b__139(<>f__AnonymousType36`2<<>f__AnonymousType35`2<<>f__AnonymousType34`2<<>f__AnonymousType33`2<<>f__AnonymousType32`2<<>f__AnonymousType31`2<<>f__AnonymousType30`2<<>f__AnonymousType2f`2<<>f__AnonymousType2e`2<<>f__AnonymousType2d`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, char>, double>, char>, double>, char>, double>, char> <>h__TransparentIdentifier4d, double n5);
    [CompilerGeneratedAttribute]
private static Parser`1<char> <.cctor>b__13a(<>f__AnonymousType37`2<<>f__AnonymousType36`2<<>f__AnonymousType35`2<<>f__AnonymousType34`2<<>f__AnonymousType33`2<<>f__AnonymousType32`2<<>f__AnonymousType31`2<<>f__AnonymousType30`2<<>f__AnonymousType2f`2<<>f__AnonymousType2e`2<<>f__AnonymousType2d`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, char>, double>, char>, double>, char>, double>, char>, double> <>h__TransparentIdentifier4e);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType38`2<<>f__AnonymousType37`2<<>f__AnonymousType36`2<<>f__AnonymousType35`2<<>f__AnonymousType34`2<<>f__AnonymousType33`2<<>f__AnonymousType32`2<<>f__AnonymousType31`2<<>f__AnonymousType30`2<<>f__AnonymousType2f`2<<>f__AnonymousType2e`2<<>f__AnonymousType2d`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, char>, double>, char>, double>, char>, double>, char>, double>, char> <.cctor>b__13b(<>f__AnonymousType37`2<<>f__AnonymousType36`2<<>f__AnonymousType35`2<<>f__AnonymousType34`2<<>f__AnonymousType33`2<<>f__AnonymousType32`2<<>f__AnonymousType31`2<<>f__AnonymousType30`2<<>f__AnonymousType2f`2<<>f__AnonymousType2e`2<<>f__AnonymousType2d`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, char>, double>, char>, double>, char>, double>, char>, double> <>h__TransparentIdentifier4e, char wan5);
    [CompilerGeneratedAttribute]
private static Parser`1<double> <.cctor>b__13c(<>f__AnonymousType38`2<<>f__AnonymousType37`2<<>f__AnonymousType36`2<<>f__AnonymousType35`2<<>f__AnonymousType34`2<<>f__AnonymousType33`2<<>f__AnonymousType32`2<<>f__AnonymousType31`2<<>f__AnonymousType30`2<<>f__AnonymousType2f`2<<>f__AnonymousType2e`2<<>f__AnonymousType2d`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, char>, double>, char>, double>, char>, double>, char>, double>, char> <>h__TransparentIdentifier4f);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType39`2<<>f__AnonymousType38`2<<>f__AnonymousType37`2<<>f__AnonymousType36`2<<>f__AnonymousType35`2<<>f__AnonymousType34`2<<>f__AnonymousType33`2<<>f__AnonymousType32`2<<>f__AnonymousType31`2<<>f__AnonymousType30`2<<>f__AnonymousType2f`2<<>f__AnonymousType2e`2<<>f__AnonymousType2d`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, char>, double>, char>, double>, char>, double>, char>, double>, char>, double> <.cctor>b__13d(<>f__AnonymousType38`2<<>f__AnonymousType37`2<<>f__AnonymousType36`2<<>f__AnonymousType35`2<<>f__AnonymousType34`2<<>f__AnonymousType33`2<<>f__AnonymousType32`2<<>f__AnonymousType31`2<<>f__AnonymousType30`2<<>f__AnonymousType2f`2<<>f__AnonymousType2e`2<<>f__AnonymousType2d`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, char>, double>, char>, double>, char>, double>, char>, double>, char> <>h__TransparentIdentifier4f, double n6);
    [CompilerGeneratedAttribute]
private static Parser`1<IOption`1<IEnumerable`1<char>>> <.cctor>b__13e(<>f__AnonymousType39`2<<>f__AnonymousType38`2<<>f__AnonymousType37`2<<>f__AnonymousType36`2<<>f__AnonymousType35`2<<>f__AnonymousType34`2<<>f__AnonymousType33`2<<>f__AnonymousType32`2<<>f__AnonymousType31`2<<>f__AnonymousType30`2<<>f__AnonymousType2f`2<<>f__AnonymousType2e`2<<>f__AnonymousType2d`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, char>, double>, char>, double>, char>, double>, char>, double>, char>, double> <>h__TransparentIdentifier50);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType3a`2<<>f__AnonymousType39`2<<>f__AnonymousType38`2<<>f__AnonymousType37`2<<>f__AnonymousType36`2<<>f__AnonymousType35`2<<>f__AnonymousType34`2<<>f__AnonymousType33`2<<>f__AnonymousType32`2<<>f__AnonymousType31`2<<>f__AnonymousType30`2<<>f__AnonymousType2f`2<<>f__AnonymousType2e`2<<>f__AnonymousType2d`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, char>, double>, char>, double>, char>, double>, char>, double>, char>, double>, IOption`1<IEnumerable`1<char>>> <.cctor>b__13f(<>f__AnonymousType39`2<<>f__AnonymousType38`2<<>f__AnonymousType37`2<<>f__AnonymousType36`2<<>f__AnonymousType35`2<<>f__AnonymousType34`2<<>f__AnonymousType33`2<<>f__AnonymousType32`2<<>f__AnonymousType31`2<<>f__AnonymousType30`2<<>f__AnonymousType2f`2<<>f__AnonymousType2e`2<<>f__AnonymousType2d`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, char>, double>, char>, double>, char>, double>, char>, double>, char>, double> <>h__TransparentIdentifier50, IOption`1<IEnumerable`1<char>> wan6);
    [CompilerGeneratedAttribute]
private static Parser`1<char> <.cctor>b__140(<>f__AnonymousType3a`2<<>f__AnonymousType39`2<<>f__AnonymousType38`2<<>f__AnonymousType37`2<<>f__AnonymousType36`2<<>f__AnonymousType35`2<<>f__AnonymousType34`2<<>f__AnonymousType33`2<<>f__AnonymousType32`2<<>f__AnonymousType31`2<<>f__AnonymousType30`2<<>f__AnonymousType2f`2<<>f__AnonymousType2e`2<<>f__AnonymousType2d`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, char>, double>, char>, double>, char>, double>, char>, double>, char>, double>, IOption`1<IEnumerable`1<char>>> <>h__TransparentIdentifier51);
    [CompilerGeneratedAttribute]
private static MatrixTransform <.cctor>b__141(<>f__AnonymousType3a`2<<>f__AnonymousType39`2<<>f__AnonymousType38`2<<>f__AnonymousType37`2<<>f__AnonymousType36`2<<>f__AnonymousType35`2<<>f__AnonymousType34`2<<>f__AnonymousType33`2<<>f__AnonymousType32`2<<>f__AnonymousType31`2<<>f__AnonymousType30`2<<>f__AnonymousType2f`2<<>f__AnonymousType2e`2<<>f__AnonymousType2d`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, char>, double>, char>, double>, char>, double>, char>, double>, char>, double>, IOption`1<IEnumerable`1<char>>> <>h__TransparentIdentifier51, char rightparen);
    [CompilerGeneratedAttribute]
private static Parser`1<IOption`1<IEnumerable`1<char>>> <.cctor>b__142(IEnumerable`1<char> prefix);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>> <.cctor>b__143(IEnumerable`1<char> prefix, IOption`1<IEnumerable`1<char>> w1);
    [CompilerGeneratedAttribute]
private static Parser`1<char> <.cctor>b__144(<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>> <>h__TransparentIdentifier53);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType3b`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char> <.cctor>b__145(<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>> <>h__TransparentIdentifier53, char leftparen);
    [CompilerGeneratedAttribute]
private static Parser`1<IOption`1<IEnumerable`1<char>>> <.cctor>b__146(<>f__AnonymousType3b`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char> <>h__TransparentIdentifier54);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType3c`2<<>f__AnonymousType3b`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>> <.cctor>b__147(<>f__AnonymousType3b`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char> <>h__TransparentIdentifier54, IOption`1<IEnumerable`1<char>> w2);
    [CompilerGeneratedAttribute]
private static Parser`1<double> <.cctor>b__148(<>f__AnonymousType3c`2<<>f__AnonymousType3b`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>> <>h__TransparentIdentifier55);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType3d`2<<>f__AnonymousType3c`2<<>f__AnonymousType3b`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double> <.cctor>b__149(<>f__AnonymousType3c`2<<>f__AnonymousType3b`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>> <>h__TransparentIdentifier55, double tx);
    [CompilerGeneratedAttribute]
private static Parser`1<IOption`1<double>> <.cctor>b__14a(<>f__AnonymousType3d`2<<>f__AnonymousType3c`2<<>f__AnonymousType3b`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double> <>h__TransparentIdentifier56);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType3e`2<<>f__AnonymousType3d`2<<>f__AnonymousType3c`2<<>f__AnonymousType3b`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, IOption`1<double>> <.cctor>b__14d(<>f__AnonymousType3d`2<<>f__AnonymousType3c`2<<>f__AnonymousType3b`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double> <>h__TransparentIdentifier56, IOption`1<double> ty_);
    [CompilerGeneratedAttribute]
private static Parser`1<IOption`1<IEnumerable`1<char>>> <.cctor>b__14e(<>f__AnonymousType3e`2<<>f__AnonymousType3d`2<<>f__AnonymousType3c`2<<>f__AnonymousType3b`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, IOption`1<double>> <>h__TransparentIdentifier57);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType3f`2<<>f__AnonymousType3e`2<<>f__AnonymousType3d`2<<>f__AnonymousType3c`2<<>f__AnonymousType3b`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, IOption`1<double>>, IOption`1<IEnumerable`1<char>>> <.cctor>b__14f(<>f__AnonymousType3e`2<<>f__AnonymousType3d`2<<>f__AnonymousType3c`2<<>f__AnonymousType3b`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, IOption`1<double>> <>h__TransparentIdentifier57, IOption`1<IEnumerable`1<char>> w3);
    [CompilerGeneratedAttribute]
private static Parser`1<char> <.cctor>b__150(<>f__AnonymousType3f`2<<>f__AnonymousType3e`2<<>f__AnonymousType3d`2<<>f__AnonymousType3c`2<<>f__AnonymousType3b`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, IOption`1<double>>, IOption`1<IEnumerable`1<char>>> <>h__TransparentIdentifier58);
    [CompilerGeneratedAttribute]
private static TranslateTransform <.cctor>b__151(<>f__AnonymousType3f`2<<>f__AnonymousType3e`2<<>f__AnonymousType3d`2<<>f__AnonymousType3c`2<<>f__AnonymousType3b`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, IOption`1<double>>, IOption`1<IEnumerable`1<char>>> <>h__TransparentIdentifier58, char rightparen);
    [CompilerGeneratedAttribute]
private static Parser`1<IOption`1<IEnumerable`1<char>>> <.cctor>b__152(IEnumerable`1<char> prefix);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>> <.cctor>b__153(IEnumerable`1<char> prefix, IOption`1<IEnumerable`1<char>> w1);
    [CompilerGeneratedAttribute]
private static Parser`1<char> <.cctor>b__154(<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>> <>h__TransparentIdentifier5b);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType40`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char> <.cctor>b__155(<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>> <>h__TransparentIdentifier5b, char leftparen);
    [CompilerGeneratedAttribute]
private static Parser`1<IOption`1<IEnumerable`1<char>>> <.cctor>b__156(<>f__AnonymousType40`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char> <>h__TransparentIdentifier5c);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType41`2<<>f__AnonymousType40`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>> <.cctor>b__157(<>f__AnonymousType40`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char> <>h__TransparentIdentifier5c, IOption`1<IEnumerable`1<char>> w2);
    [CompilerGeneratedAttribute]
private static Parser`1<double> <.cctor>b__158(<>f__AnonymousType41`2<<>f__AnonymousType40`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>> <>h__TransparentIdentifier5d);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType42`2<<>f__AnonymousType41`2<<>f__AnonymousType40`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double> <.cctor>b__159(<>f__AnonymousType41`2<<>f__AnonymousType40`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>> <>h__TransparentIdentifier5d, double sx);
    [CompilerGeneratedAttribute]
private static Parser`1<IOption`1<double>> <.cctor>b__15a(<>f__AnonymousType42`2<<>f__AnonymousType41`2<<>f__AnonymousType40`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double> <>h__TransparentIdentifier5e);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType43`2<<>f__AnonymousType42`2<<>f__AnonymousType41`2<<>f__AnonymousType40`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, IOption`1<double>> <.cctor>b__15d(<>f__AnonymousType42`2<<>f__AnonymousType41`2<<>f__AnonymousType40`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double> <>h__TransparentIdentifier5e, IOption`1<double> sy_);
    [CompilerGeneratedAttribute]
private static Parser`1<IOption`1<IEnumerable`1<char>>> <.cctor>b__15e(<>f__AnonymousType43`2<<>f__AnonymousType42`2<<>f__AnonymousType41`2<<>f__AnonymousType40`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, IOption`1<double>> <>h__TransparentIdentifier5f);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType44`2<<>f__AnonymousType43`2<<>f__AnonymousType42`2<<>f__AnonymousType41`2<<>f__AnonymousType40`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, IOption`1<double>>, IOption`1<IEnumerable`1<char>>> <.cctor>b__15f(<>f__AnonymousType43`2<<>f__AnonymousType42`2<<>f__AnonymousType41`2<<>f__AnonymousType40`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, IOption`1<double>> <>h__TransparentIdentifier5f, IOption`1<IEnumerable`1<char>> w3);
    [CompilerGeneratedAttribute]
private static Parser`1<char> <.cctor>b__160(<>f__AnonymousType44`2<<>f__AnonymousType43`2<<>f__AnonymousType42`2<<>f__AnonymousType41`2<<>f__AnonymousType40`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, IOption`1<double>>, IOption`1<IEnumerable`1<char>>> <>h__TransparentIdentifier60);
    [CompilerGeneratedAttribute]
private static ScaleTransform <.cctor>b__161(<>f__AnonymousType44`2<<>f__AnonymousType43`2<<>f__AnonymousType42`2<<>f__AnonymousType41`2<<>f__AnonymousType40`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, IOption`1<double>>, IOption`1<IEnumerable`1<char>>> <>h__TransparentIdentifier60, char rightparen);
    [CompilerGeneratedAttribute]
private static Parser`1<IOption`1<IEnumerable`1<char>>> <.cctor>b__162(IEnumerable`1<char> prefix);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>> <.cctor>b__163(IEnumerable`1<char> prefix, IOption`1<IEnumerable`1<char>> w1);
    [CompilerGeneratedAttribute]
private static Parser`1<char> <.cctor>b__164(<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>> <>h__TransparentIdentifier63);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType45`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char> <.cctor>b__165(<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>> <>h__TransparentIdentifier63, char leftparen);
    [CompilerGeneratedAttribute]
private static Parser`1<IOption`1<IEnumerable`1<char>>> <.cctor>b__166(<>f__AnonymousType45`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char> <>h__TransparentIdentifier64);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType46`2<<>f__AnonymousType45`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>> <.cctor>b__167(<>f__AnonymousType45`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char> <>h__TransparentIdentifier64, IOption`1<IEnumerable`1<char>> w2);
    [CompilerGeneratedAttribute]
private static Parser`1<double> <.cctor>b__168(<>f__AnonymousType46`2<<>f__AnonymousType45`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>> <>h__TransparentIdentifier65);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType47`2<<>f__AnonymousType46`2<<>f__AnonymousType45`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double> <.cctor>b__169(<>f__AnonymousType46`2<<>f__AnonymousType45`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>> <>h__TransparentIdentifier65, double rotateangle);
    [CompilerGeneratedAttribute]
private static Parser`1<IOption`1<Pair`2<double, double>>> <.cctor>b__16a(<>f__AnonymousType47`2<<>f__AnonymousType46`2<<>f__AnonymousType45`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double> <>h__TransparentIdentifier66);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType4a`2<<>f__AnonymousType47`2<<>f__AnonymousType46`2<<>f__AnonymousType45`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, IOption`1<Pair`2<double, double>>> <.cctor>b__171(<>f__AnonymousType47`2<<>f__AnonymousType46`2<<>f__AnonymousType45`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double> <>h__TransparentIdentifier66, IOption`1<Pair`2<double, double>> cxcy_);
    [CompilerGeneratedAttribute]
private static Parser`1<IOption`1<IEnumerable`1<char>>> <.cctor>b__172(<>f__AnonymousType4a`2<<>f__AnonymousType47`2<<>f__AnonymousType46`2<<>f__AnonymousType45`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, IOption`1<Pair`2<double, double>>> <>h__TransparentIdentifier67);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType4b`2<<>f__AnonymousType4a`2<<>f__AnonymousType47`2<<>f__AnonymousType46`2<<>f__AnonymousType45`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, IOption`1<Pair`2<double, double>>>, IOption`1<IEnumerable`1<char>>> <.cctor>b__173(<>f__AnonymousType4a`2<<>f__AnonymousType47`2<<>f__AnonymousType46`2<<>f__AnonymousType45`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, IOption`1<Pair`2<double, double>>> <>h__TransparentIdentifier67, IOption`1<IEnumerable`1<char>> w3);
    [CompilerGeneratedAttribute]
private static Parser`1<char> <.cctor>b__174(<>f__AnonymousType4b`2<<>f__AnonymousType4a`2<<>f__AnonymousType47`2<<>f__AnonymousType46`2<<>f__AnonymousType45`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, IOption`1<Pair`2<double, double>>>, IOption`1<IEnumerable`1<char>>> <>h__TransparentIdentifier68);
    [CompilerGeneratedAttribute]
private static RotateTransform <.cctor>b__175(<>f__AnonymousType4b`2<<>f__AnonymousType4a`2<<>f__AnonymousType47`2<<>f__AnonymousType46`2<<>f__AnonymousType45`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, IOption`1<Pair`2<double, double>>>, IOption`1<IEnumerable`1<char>>> <>h__TransparentIdentifier68, char rightparen);
    [CompilerGeneratedAttribute]
private static Parser`1<IOption`1<IEnumerable`1<char>>> <.cctor>b__176(IEnumerable`1<char> prefix);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>> <.cctor>b__177(IEnumerable`1<char> prefix, IOption`1<IEnumerable`1<char>> w1);
    [CompilerGeneratedAttribute]
private static Parser`1<char> <.cctor>b__178(<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>> <>h__TransparentIdentifier6d);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType4c`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char> <.cctor>b__179(<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>> <>h__TransparentIdentifier6d, char leftparen);
    [CompilerGeneratedAttribute]
private static Parser`1<IOption`1<IEnumerable`1<char>>> <.cctor>b__17a(<>f__AnonymousType4c`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char> <>h__TransparentIdentifier6e);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType4d`2<<>f__AnonymousType4c`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>> <.cctor>b__17b(<>f__AnonymousType4c`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char> <>h__TransparentIdentifier6e, IOption`1<IEnumerable`1<char>> w2);
    [CompilerGeneratedAttribute]
private static Parser`1<double> <.cctor>b__17c(<>f__AnonymousType4d`2<<>f__AnonymousType4c`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>> <>h__TransparentIdentifier6f);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType4e`2<<>f__AnonymousType4d`2<<>f__AnonymousType4c`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double> <.cctor>b__17d(<>f__AnonymousType4d`2<<>f__AnonymousType4c`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>> <>h__TransparentIdentifier6f, double skewangle);
    [CompilerGeneratedAttribute]
private static Parser`1<IOption`1<IEnumerable`1<char>>> <.cctor>b__17e(<>f__AnonymousType4e`2<<>f__AnonymousType4d`2<<>f__AnonymousType4c`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double> <>h__TransparentIdentifier70);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType4f`2<<>f__AnonymousType4e`2<<>f__AnonymousType4d`2<<>f__AnonymousType4c`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, IOption`1<IEnumerable`1<char>>> <.cctor>b__17f(<>f__AnonymousType4e`2<<>f__AnonymousType4d`2<<>f__AnonymousType4c`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double> <>h__TransparentIdentifier70, IOption`1<IEnumerable`1<char>> w3);
    [CompilerGeneratedAttribute]
private static Parser`1<char> <.cctor>b__180(<>f__AnonymousType4f`2<<>f__AnonymousType4e`2<<>f__AnonymousType4d`2<<>f__AnonymousType4c`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, IOption`1<IEnumerable`1<char>>> <>h__TransparentIdentifier71);
    [CompilerGeneratedAttribute]
private static SkewTransform <.cctor>b__181(<>f__AnonymousType4f`2<<>f__AnonymousType4e`2<<>f__AnonymousType4d`2<<>f__AnonymousType4c`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, IOption`1<IEnumerable`1<char>>> <>h__TransparentIdentifier71, char rightparen);
    [CompilerGeneratedAttribute]
private static Parser`1<IOption`1<IEnumerable`1<char>>> <.cctor>b__182(IEnumerable`1<char> prefix);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>> <.cctor>b__183(IEnumerable`1<char> prefix, IOption`1<IEnumerable`1<char>> w1);
    [CompilerGeneratedAttribute]
private static Parser`1<char> <.cctor>b__184(<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>> <>h__TransparentIdentifier73);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType50`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char> <.cctor>b__185(<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>> <>h__TransparentIdentifier73, char leftparen);
    [CompilerGeneratedAttribute]
private static Parser`1<IOption`1<IEnumerable`1<char>>> <.cctor>b__186(<>f__AnonymousType50`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char> <>h__TransparentIdentifier74);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType51`2<<>f__AnonymousType50`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>> <.cctor>b__187(<>f__AnonymousType50`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char> <>h__TransparentIdentifier74, IOption`1<IEnumerable`1<char>> w2);
    [CompilerGeneratedAttribute]
private static Parser`1<double> <.cctor>b__188(<>f__AnonymousType51`2<<>f__AnonymousType50`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>> <>h__TransparentIdentifier75);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType52`2<<>f__AnonymousType51`2<<>f__AnonymousType50`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double> <.cctor>b__189(<>f__AnonymousType51`2<<>f__AnonymousType50`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>> <>h__TransparentIdentifier75, double skewangle);
    [CompilerGeneratedAttribute]
private static Parser`1<IOption`1<IEnumerable`1<char>>> <.cctor>b__18a(<>f__AnonymousType52`2<<>f__AnonymousType51`2<<>f__AnonymousType50`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double> <>h__TransparentIdentifier76);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType53`2<<>f__AnonymousType52`2<<>f__AnonymousType51`2<<>f__AnonymousType50`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, IOption`1<IEnumerable`1<char>>> <.cctor>b__18b(<>f__AnonymousType52`2<<>f__AnonymousType51`2<<>f__AnonymousType50`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double> <>h__TransparentIdentifier76, IOption`1<IEnumerable`1<char>> w3);
    [CompilerGeneratedAttribute]
private static Parser`1<char> <.cctor>b__18c(<>f__AnonymousType53`2<<>f__AnonymousType52`2<<>f__AnonymousType51`2<<>f__AnonymousType50`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, IOption`1<IEnumerable`1<char>>> <>h__TransparentIdentifier77);
    [CompilerGeneratedAttribute]
private static SkewTransform <.cctor>b__18d(<>f__AnonymousType53`2<<>f__AnonymousType52`2<<>f__AnonymousType51`2<<>f__AnonymousType50`2<<>f__AnonymousType2c`2<IEnumerable`1<char>, IOption`1<IEnumerable`1<char>>>, char>, IOption`1<IEnumerable`1<char>>>, double>, IOption`1<IEnumerable`1<char>>> <>h__TransparentIdentifier77, char rightparen);
    [CompilerGeneratedAttribute]
private static Parser`1<IOption`1<IEnumerable`1<Transform>>> <.cctor>b__18e(Transform first);
    [CompilerGeneratedAttribute]
private static Transform <.cctor>b__191(Transform first, IOption`1<IEnumerable`1<Transform>> tail);
    [CompilerGeneratedAttribute]
private static Parser`1<IOption`1<Transform>> <.cctor>b__192(IOption`1<IEnumerable`1<char>> w1);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType54`2<IOption`1<IEnumerable`1<char>>, IOption`1<Transform>> <.cctor>b__193(IOption`1<IEnumerable`1<char>> w1, IOption`1<Transform> tr);
    [CompilerGeneratedAttribute]
private static Parser`1<IOption`1<IEnumerable`1<char>>> <.cctor>b__194(<>f__AnonymousType54`2<IOption`1<IEnumerable`1<char>>, IOption`1<Transform>> <>h__TransparentIdentifier7b);
    [CompilerGeneratedAttribute]
private static Transform <.cctor>b__195(<>f__AnonymousType54`2<IOption`1<IEnumerable`1<char>>, IOption`1<Transform>> <>h__TransparentIdentifier7b, IOption`1<IEnumerable`1<char>> w2);
    [CompilerGeneratedAttribute]
private static Parser`1<ICollection`1<S>> <.cctor>b__d6(IOption`1<IEnumerable`1<char>> w);
    [CompilerGeneratedAttribute]
private static ICollection`1<S> <.cctor>b__d7(IOption`1<IEnumerable`1<char>> w, ICollection`1<S> item);
    [CompilerGeneratedAttribute]
private static IEnumerable`1<S> <.cctor>b__d9(ICollection`1<S> o);
    [CompilerGeneratedAttribute]
private static Parser`1<ICollection`1<S>> <.cctor>b__df(IOption`1<IEnumerable`1<char>> w);
    [CompilerGeneratedAttribute]
private static ICollection`1<S> <.cctor>b__e0(IOption`1<IEnumerable`1<char>> w, ICollection`1<S> item);
    [CompilerGeneratedAttribute]
private static IEnumerable`1<S> <.cctor>b__e1(IEnumerable`1<ICollection`1<S>> e);
    [CompilerGeneratedAttribute]
private static IEnumerable`1<S> <.cctor>b__e2(ICollection`1<S> o);
    [CompilerGeneratedAttribute]
private static Parser`1<Point> <.cctor>b__e9(char w);
    [CompilerGeneratedAttribute]
private static Point <.cctor>b__ea(char w, Point item);
    [CompilerGeneratedAttribute]
private static Parser`1<double> <.cctor>b__14b(char cw);
    [CompilerGeneratedAttribute]
private static double <.cctor>b__14c(char cw, double ty);
    [CompilerGeneratedAttribute]
private static Parser`1<double> <.cctor>b__15b(char cw);
    [CompilerGeneratedAttribute]
private static double <.cctor>b__15c(char cw, double sy);
    [CompilerGeneratedAttribute]
private static Parser`1<double> <.cctor>b__16b(char cw1);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType48`2<char, double> <.cctor>b__16c(char cw1, double cx);
    [CompilerGeneratedAttribute]
private static Parser`1<char> <.cctor>b__16d(<>f__AnonymousType48`2<char, double> <>h__TransparentIdentifier6a);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType49`2<<>f__AnonymousType48`2<char, double>, char> <.cctor>b__16e(<>f__AnonymousType48`2<char, double> <>h__TransparentIdentifier6a, char cw2);
    [CompilerGeneratedAttribute]
private static Parser`1<double> <.cctor>b__16f(<>f__AnonymousType49`2<<>f__AnonymousType48`2<char, double>, char> <>h__TransparentIdentifier6b);
    [CompilerGeneratedAttribute]
private static Pair`2<double, double> <.cctor>b__170(<>f__AnonymousType49`2<<>f__AnonymousType48`2<char, double>, char> <>h__TransparentIdentifier6b, double cy);
    [CompilerGeneratedAttribute]
private static Parser`1<Transform> <.cctor>b__18f(IEnumerable`1<char> w);
    [CompilerGeneratedAttribute]
private static Transform <.cctor>b__190(IEnumerable`1<char> w, Transform tr);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType55`2<bool, ICollection`1<TItem>> <ParseCommand>b__2a5(char type, ICollection`1<TItem> items);
    [CompilerGeneratedAttribute]
private static ICollection`1<TItem> <ParseCommand>b__2a6(<>f__AnonymousType55`2<bool, ICollection`1<TItem>> t);
    [CompilerGeneratedAttribute]
private static ICollection`1<TItem> <CommaWspSequence>b__2ae(TItem first, IOption`1<IEnumerable`1<TItem>> tail);
}
public interface JetBrains.Application.ISorter`1 {
    public abstract virtual ICollection`1<T> Sort(ICollection`1<T> unsorted);
}
[LocalizableAttribute("False")]
public class JetBrains.Application.platforms.FrameworkIdentifier : object {
    public static string NET_FRAMEWORK_ID;
    public static string NET_CORE;
    public static string NET_PORTABLE_ID;
    public static string SILVERLIGHT;
    public static FrameworkIdentifier NetFramework;
    public static FrameworkIdentifier NetMicroFramework;
    public static FrameworkIdentifier Silverlight;
    public static FrameworkIdentifier WindowsPhone;
    public static FrameworkIdentifier WindowsPhoneApp;
    public static FrameworkIdentifier PocketPC;
    public static FrameworkIdentifier Smartphone;
    public static FrameworkIdentifier WindowsCE;
    public static FrameworkIdentifier NetCore45;
    public static FrameworkIdentifier NetCoreApp;
    public static FrameworkIdentifier Portable;
    public static FrameworkIdentifier XamarinIos;
    public static FrameworkIdentifier MonoTouch;
    public static FrameworkIdentifier MonoAndroid;
    public static FrameworkIdentifier DNX;
    public static FrameworkIdentifier DNXCore;
    public static FrameworkIdentifier ASPNet;
    public static FrameworkIdentifier ASPNetCore;
    public static FrameworkIdentifier NetStandart;
    [NotNullAttribute]
private string myIdentifier;
    private static Dictionary`2<string, string> ourPresentableNamesDictionary;
    private static IEqualityComparer`1<string> ID_COMPARER;
    [NotNullAttribute]
public string PresentableName { get; }
    public FrameworkIdentifier(string identifier);
    private static FrameworkIdentifier();
    public static IEnumerable`1<FrameworkIdentifier> GetWellKnownIdentifiers();
    public string get_PresentableName();
    public sealed virtual bool Equals(FrameworkIdentifier other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static bool op_Equality(FrameworkIdentifier left, FrameworkIdentifier right);
    public static bool op_Inequality(FrameworkIdentifier left, FrameworkIdentifier right);
    public void WriteFrameworkIdentifier(BinaryWriter writer);
    public void WriteFrameworkIdentifier(UnsafeWriter writer);
}
[LocalizableAttribute("False")]
public class JetBrains.Application.platforms.PlatformID : object {
    private FrameworkIdentifier myIdentifier;
    private Version myVersion;
    private ProfileIdentifier myProfile;
    private string myFullName;
    public string FullName { get; }
    public ProfileIdentifier Profile { get; }
    public FrameworkIdentifier Identifier { get; }
    public Version Version { get; }
    private PlatformID(string frameworkName);
    public PlatformID(NuGetFramework nugetFramework);
    public PlatformID(FrameworkIdentifier identifier, Version version, ProfileIdentifier profile);
    public static PlatformID TryCreate(string frameworkName);
    public string get_FullName();
    public ProfileIdentifier get_Profile();
    public FrameworkIdentifier get_Identifier();
    public Version get_Version();
    public static PlatformID CreateFromName(string name, Version version, ProfileIdentifier profile);
    public static PlatformID CreateFromName(FrameworkIdentifier framework, Version version, ProfileIdentifier profile);
    public sealed virtual bool Equals(PlatformID other);
    public virtual bool Equals(object obj);
    public static bool op_Equality(PlatformID left, PlatformID right);
    public static bool op_Inequality(PlatformID left, PlatformID right);
    public virtual int GetHashCode();
    public virtual string ToString();
    public void WritePlatformId(BinaryWriter writer);
    public static PlatformID ReadPlatformId(BinaryReader reader);
    public void WritePlatformId(UnsafeWriter writer);
    public static PlatformID ReadPlatformId(UnsafeReader reader);
}
[ExtensionAttribute]
public static class JetBrains.Application.platforms.PlatformIdEx : object {
    [ExtensionAttribute]
[CanBeNullAttribute]
public static FrameworkName GetFrameworkName(PlatformID platformID);
    [ExtensionAttribute]
public static bool IsPortable(PlatformID platformID);
    [ExtensionAttribute]
public static bool IsFull(PlatformID platformID);
}
[LocalizableAttribute("False")]
public class JetBrains.Application.platforms.ProfileIdentifier : object {
    public static ProfileIdentifier WindowsPhone;
    public static ProfileIdentifier WindowsPhone71;
    public static ProfileIdentifier Client;
    public static ProfileIdentifier Runtime;
    public static ProfileIdentifier Default;
    [NotNullAttribute]
private string myIdentifier;
    private static Dictionary`2<string, string> ourPresentableNamesDictionary;
    [NotNullAttribute]
public string PresentableName { get; }
    public ProfileIdentifier(string identifier);
    private static ProfileIdentifier();
    public bool Equals(ProfileIdentifier other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public string get_PresentableName();
    public static bool op_Equality(ProfileIdentifier left, ProfileIdentifier right);
    public static bool op_Inequality(ProfileIdentifier left, ProfileIdentifier right);
    public virtual string ToString();
    public bool IsDefault();
    public bool IsRuntime();
    public void WriteProfileIdentifier(BinaryWriter writer);
    public void WriteProfileIdentifier(UnsafeWriter writer);
}
public class JetBrains.Application.Progress.CombinedProgressIndicator : object {
    [NotNullAttribute]
private IEnumerable`1<IProgressIndicator> myChildIndicators;
    [CompilerGeneratedAttribute]
private static Func`2<IProgressIndicator, bool> CS$<>9__CachedAnonymousMethodDelegate1;
    unknown string CurrentItemText {public set; }
    public bool IsCanceled { get; }
    public string TaskName { get; public set; }
    public CombinedProgressIndicator(IReadOnlyCollection`1<IProgressIndicator> childIndicators);
    public sealed virtual void Dispose();
    public sealed virtual void set_CurrentItemText(string value);
    public sealed virtual bool get_IsCanceled();
    public sealed virtual string get_TaskName();
    public sealed virtual void set_TaskName(string value);
    public sealed virtual void Advance(double units);
    public sealed virtual void Start(int totalWorkUnits);
    public sealed virtual void Stop();
    [CompilerGeneratedAttribute]
private static bool <get_IsCanceled>b__0(IProgressIndicator _);
}
public class JetBrains.Application.Progress.LiveCombinedProgressIndicator : object {
    private List`1<IProgressIndicator> myIndicators;
    [CanBeNullAttribute]
private string myCurrentItemText;
    private string myTaskName;
    private int myTotalUnit;
    private double myProgress;
    private object myLock;
    private bool myIsCancelled;
    unknown string CurrentItemText {public set; }
    public bool IsCanceled { get; }
    public string TaskName { get; public set; }
    public LiveCombinedProgressIndicator(Lifetime lifetime);
    public void Add(Lifetime lifetime, IProgressIndicator indicator);
    public void Cancel();
    public bool Remove(IProgressIndicator item);
    public sealed virtual void Dispose();
    public sealed virtual void set_CurrentItemText(string value);
    public sealed virtual bool get_IsCanceled();
    public sealed virtual string get_TaskName();
    public sealed virtual void set_TaskName(string value);
    public sealed virtual void Advance(double units);
    public sealed virtual void Start(int totalWorkUnits);
    public sealed virtual void Stop();
}
public class JetBrains.Application.Progress.NullProgressIndicator : ProgressIndicatorBase {
    [NotNullAttribute]
[ObsoleteAttribute("This property always creates a new instance, so should better be using the Create method.")]
public static IProgressIndicator Instance { get; }
    [DebuggerStepThroughAttribute]
public static IProgressIndicator get_Instance();
    [DebuggerStepThroughAttribute]
[NotNullAttribute]
public static IProgressIndicator Create();
}
[ExtensionAttribute]
public static class JetBrains.Application.UI.CrossFramework.SizeAndLength : object {
    [ExtensionAttribute]
[PureAttribute]
public static Point ToAvalonPoint(Point value, DpiResolution resolution);
    [PureAttribute]
[ExtensionAttribute]
public static Point ToAvalonPoint(PointF value, DpiResolution resolution);
    [ExtensionAttribute]
[PureAttribute]
public static Point ToAvalonPoint96(Point value);
    [PureAttribute]
[ExtensionAttribute]
public static Point ToAvalonPoint96(PointF value);
    [ExtensionAttribute]
[PureAttribute]
public static Rect ToAvalonRect(Rectangle value, DpiResolution resolution);
    [PureAttribute]
[ExtensionAttribute]
public static Rect ToAvalonRect(RectangleF value, DpiResolution resolution);
    [ExtensionAttribute]
[PureAttribute]
public static Rect ToAvalonRect96(Rectangle value);
    [PureAttribute]
[ExtensionAttribute]
public static Size ToAvalonSize(SizeF value, DpiResolution resolution);
    [ExtensionAttribute]
[PureAttribute]
public static Size ToAvalonSize(Size value, DpiResolution resolution);
    [PureAttribute]
[ExtensionAttribute]
public static Size ToAvalonSize96(Size value);
    [PureAttribute]
[ExtensionAttribute]
public static Vector ToAvalonVector(SizeF value, DpiResolution resolution);
    [PureAttribute]
[ExtensionAttribute]
public static Vector ToAvalonVector(Size value, DpiResolution resolution);
    [ExtensionAttribute]
[PureAttribute]
public static Vector ToAvalonVector96(Size value);
    [PureAttribute]
[ExtensionAttribute]
public static Padding ToWinFormsPadding(Thickness value, DpiResolution resolution);
    [ExtensionAttribute]
[PureAttribute]
public static Point ToWinFormsPoint96(Point value);
    [ExtensionAttribute]
[PureAttribute]
public static Point ToWinFormsPointCeiling(Point value, DpiResolution resolution);
    [ExtensionAttribute]
[PureAttribute]
public static PointF ToWinFormsPointF96(Point value);
    [PureAttribute]
[ExtensionAttribute]
public static Point ToWinFormsPointFloor(Point value, DpiResolution resolution);
    [PureAttribute]
[ExtensionAttribute]
public static Point ToWinFormsPointRounded(Point value, DpiResolution resolution);
    [PureAttribute]
[ExtensionAttribute]
public static Rectangle ToWinFormsRectangle96(Rect value);
    [ExtensionAttribute]
[PureAttribute]
public static RectangleF ToWinFormsRectangleF96(Rect value);
    [PureAttribute]
[ExtensionAttribute]
public static Size ToWinFormsSize(Vector value, DpiResolution resolution);
    [PureAttribute]
[ExtensionAttribute]
public static Size ToWinFormsSize(Size value, DpiResolution resolution);
    [ExtensionAttribute]
[PureAttribute]
public static Size ToWinFormsSize96(Size value);
    [PureAttribute]
[ExtensionAttribute]
public static Size ToWinFormsSizeCeiling(Vector value, DpiResolution resolution);
    [ExtensionAttribute]
[PureAttribute]
public static SizeF ToWinFormsSizeF(Vector value, DpiResolution resolution);
    [PureAttribute]
[ExtensionAttribute]
public static SizeF ToWinFormsSizeF(Size value, DpiResolution resolution);
    [PureAttribute]
[ExtensionAttribute]
public static Size ToWinFormsSizeRounded(Size value, DpiResolution resolution);
    [PureAttribute]
private static int AvalonLengthToWinFormsLength_Ceiling(double length, double dpi);
    [PureAttribute]
private static int AvalonLengthToWinFormsLength_Floor(double length, double dpi);
    [PureAttribute]
private static int AvalonLengthToWinFormsLength_Round(double length, double dpi);
    [PureAttribute]
private static double WinFormsLengthToAvalonLength(int length, double dpi);
    [PureAttribute]
private static double WinFormsLengthToAvalonLength(float length, double dpi);
}
public static class JetBrains.Application.UI.Icons.Images.GeometryHelpers : object {
    [CompilerGeneratedAttribute]
private static Func`3<Vector, Vector, Vector> CS$<>9__CachedAnonymousMethodDelegateb;
    [CompilerGeneratedAttribute]
private static Func`3<Vector, Vector, Vector> CS$<>9__CachedAnonymousMethodDelegatec;
    [CompilerGeneratedAttribute]
private static Func`2<Vector, Vector> CS$<>9__CachedAnonymousMethodDelegated;
    [CompilerGeneratedAttribute]
private static Func`2<Vector, Vector> CS$<>9__CachedAnonymousMethodDelegatee;
    [CompilerGeneratedAttribute]
private static Func`2<double, double> CS$<>9__CachedAnonymousMethodDelegate15;
    public static ArcInCenterCoordinates ArcPathToCenterCoordinates(ArcInPathCoordinates arc, bool isFallbackImpossibleArcs);
    public static ArcInPathCoordinates ArcSegmentToPathCoordinates(Point ptStart, ArcSegment arc);
    public static BzierCurve[] ArcToBzierCurves(ArcInCenterCoordinates arc);
    public static Rect BzierCurveBoundingBox(BzierCurve curve);
    public static BzierCurve SmallArcToBzierCurve(ArcInCenterCoordinates arc);
    private static double DegToRad(double deg);
    private static double RadToDeg(double rad);
    [CompilerGeneratedAttribute]
private static Vector <BzierCurveBoundingBox>b__6(Vector u, Vector v);
    [CompilerGeneratedAttribute]
private static Vector <BzierCurveBoundingBox>b__7(Vector u, Vector v);
    [CompilerGeneratedAttribute]
private static Vector <BzierCurveBoundingBox>b__8(Vector u);
    [CompilerGeneratedAttribute]
private static Vector <BzierCurveBoundingBox>b__9(Vector u);
    [CompilerGeneratedAttribute]
private static double <SmallArcToBzierCurve>b__11(double o);
}
public abstract class JetBrains.Application.UI.Icons.Images.TiBrush : object {
    public abstract virtual void AssertValid(string sOrigin, UInt32 nOriginIndex, OnError onerror);
}
public abstract class JetBrains.Application.UI.Icons.Images.TiGradientBrush : TiBrush {
    public FrugalLocalList`1<TiGradientStop> Stops;
    public virtual void AssertValid(string sOrigin, UInt32 nOriginIndex, OnError onerror);
}
public class JetBrains.Application.UI.Icons.Images.TiGradientStop : ValueType {
    public Color Color;
    public float Offset;
    public TiGradientStop(Color color, float offset);
    public sealed virtual bool Equals(TiGradientStop other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(TiGradientStop left, TiGradientStop right);
    public static bool op_Inequality(TiGradientStop left, TiGradientStop right);
    public virtual string ToString();
}
public abstract class JetBrains.Application.UI.Icons.Images.TiImage : object {
    public abstract virtual Size GetLogicalSize();
    public virtual string ToString();
}
public static class JetBrains.Application.UI.Icons.Images.TiImageConverterUtil : object {
    public static TiImage FromCanonicalSExpression(Byte[] data);
    public static TiImage FromCanonicalSExpression(UInt32[] data);
    public static TiImage FromCanonicalSExpressionAsciiString(string text);
    [NotNullAttribute]
public static XDocument ToSvgImage(TiImage tiimage, OnError onerror);
}
public static class JetBrains.Application.UI.Icons.Images.TiImageSerializerCsexp : object {
    private static string BrushLinear;
    private static string BrushNull;
    private static string BrushRadial;
    private static string BrushSolid;
    private static string ImageKindRaster;
    private static string ImageKindVector;
    private static string MainHeader;
    private static string V1;
    [CompilerGeneratedAttribute]
private static SerializeItemDelegate`1<TiSegment> CS$<>9__CachedAnonymousMethodDelegate1;
    [CompilerGeneratedAttribute]
private static Action`2<TiPath, CsexpArchive> CS$<>9__CachedAnonymousMethodDelegate4;
    [CompilerGeneratedAttribute]
private static SerializeItemDelegate`1<TiSegment> CS$<>9__CachedAnonymousMethodDelegate5;
    [CompilerGeneratedAttribute]
private static SerializeItemDelegate`1<TiGradientStop> CS$<>9__CachedAnonymousMethodDelegate7;
    private static TiImageSerializerCsexp();
    public static void Serialize(TiImage tiimage, Stream stream);
    [NotNullAttribute]
public static TiImage Serialize(Stream stream);
    public static void Serialize(CsexpArchive ar, TiImage& value);
    private static TiSegmentKind SegmentKindFromCode(string code);
    [NotNullAttribute]
private static string SegmentKindToCode(TiSegmentKind kind);
    private static void Serialize(CsexpArchive ar, TiPath& tiPath);
    private static void Serialize(CsexpArchive ar, TiSegment& tiSegment);
    private static void Serialize(CsexpArchive ar, TiBrush& value);
    private static void SerializeBody(CsexpArchive ar, TiVectorImage& value);
    private static void SerializeBody(CsexpArchive ar, TiRasterImage& value);
    private static void SerializeBody(CsexpArchive ar, TiSolidColorBrush tisolid);
    private static void SerializeBody(CsexpArchive ar, TiGradientBrush tiradial);
    private static void SerializeBody(CsexpArchive ar, TiLinearGradientBrush tilinear);
    private static void SerializeBody(CsexpArchive ar, TiRadialGradientBrush tiradial);
    private static void SerializeBody(CsexpArchive ar, TiGradientStop& tistop);
    [CompilerGeneratedAttribute]
private static void <Serialize>b__0(TiSegment& s, CsexpArchive a);
    [CompilerGeneratedAttribute]
private static void <SerializeBody>b__2(TiPath p, CsexpArchive a);
    [CompilerGeneratedAttribute]
private static void <SerializeBody>b__3(TiSegment& p, CsexpArchive a);
    [CompilerGeneratedAttribute]
private static void <SerializeBody>b__6(TiGradientStop& s, CsexpArchive a);
}
public static class JetBrains.Application.UI.Icons.Images.TiImageSerializerSvg : object {
    private static XNamespace NS;
    private static TiImageSerializerSvg();
    [NotNullAttribute]
public static XDocument Serialize(TiImage tiimage, OnError onerror);
    private static string MakeRasterImageDataUri(TiRasterImage tiraster);
    private static XElement SerializeBody(TiRasterImage tiraster, OnError onerror);
    private static XElement SerializeBody(TiVectorImage tivector, OnError onerror);
    private static XElement SerializeBodyPolymorphic(TiImage tiimage, OnError onerror);
    private static void SerializeStops(TiGradientBrush tiLinear, XElement xeParent);
    private static void SetColor(Color color, XElement xe, Attribute attrColor, Attribute attrOpacity);
}
public class JetBrains.Application.UI.Icons.Images.TiLinearGradientBrush : TiGradientBrush {
    public Point EndPoint;
    public Point StartPoint;
    public virtual void AssertValid(string sOrigin, UInt32 nOriginIndex, OnError onerror);
}
public class JetBrains.Application.UI.Icons.Images.TiNullBrush : TiBrush {
    public static TiNullBrush Instance;
    private static TiNullBrush();
    public virtual void AssertValid(string sOrigin, UInt32 nOriginIndex, OnError onerror);
}
public class JetBrains.Application.UI.Icons.Images.TiPath : object {
    internal TiBrush myFill;
    private IList`1<TiSegment> mySegments;
    [NotNullAttribute]
public TiBrush Fill { get; public set; }
    [NotNullAttribute]
public IList`1<TiSegment> Segments { get; }
    public TiBrush get_Fill();
    public void set_Fill(TiBrush value);
    public IList`1<TiSegment> get_Segments();
    public static TiPath FromRect(Rect rect, TiBrush fill);
    public void AssertValid(string sPathOrigin, UInt32 nPathIndex, OnError onerror);
    public Rect CalculateBounds();
}
public class JetBrains.Application.UI.Icons.Images.TiRadialGradientBrush : TiGradientBrush {
    public Point Start;
    public Matrix Transform;
    public virtual void AssertValid(string sOrigin, UInt32 nOriginIndex, OnError onerror);
}
public class JetBrains.Application.UI.Icons.Images.TiRasterImage : TiImage {
    internal DpiResolution myDpi;
    internal ushort myHeight;
    internal UInt32[] myPixels;
    internal ushort myWidth;
    public ushort DeviceHeight { get; }
    public ushort DeviceWidth { get; }
    public DpiResolution Dpi { get; }
    public UInt32[] Pixels { get; }
    public TiRasterImage(ushort width, ushort height, UInt32[] pixels, DpiResolution dpi);
    public ushort get_DeviceHeight();
    public ushort get_DeviceWidth();
    public DpiResolution get_Dpi();
    public UInt32[] get_Pixels();
    public virtual Size GetLogicalSize();
}
public class JetBrains.Application.UI.Icons.Images.TiSegment : ValueType {
    public Point Target;
    public Point Ctrl1;
    public Point Ctrl2;
    public TiSegmentKind Kind;
    public static TiSegment BzierTo(Point ctrl1, Point ctrl2, Point next);
    public static TiSegment LineTo(Point point);
    public static TiSegment BeginFigure(Point startpoint, bool isFillRuleNonzero, bool isFigureClosed);
    public sealed virtual bool Equals(TiSegment other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(TiSegment left, TiSegment right);
    public static bool op_Inequality(TiSegment left, TiSegment right);
    public bool IsFigureClosed();
    public bool IsFillRuleNonzero();
    public virtual string ToString();
    public void AssertValid(string sPathOrigin, UInt32 nPathIndex, UInt32 nSegmentIndex, OnError onerror);
    public static Rect CalculateBounds(IList`1<TiSegment> segments);
    public static TiSegment Transform(TiSegment tiseg, Transform transform);
}
public enum JetBrains.Application.UI.Icons.Images.TiSegmentKind : Enum {
    public ushort value__;
    public static TiSegmentKind BeginFigure;
    public static TiSegmentKind LineTo;
    public static TiSegmentKind BzierTo;
}
public class JetBrains.Application.UI.Icons.Images.TiSolidColorBrush : TiBrush {
    public Color Color;
    public TiSolidColorBrush(Color color);
    public virtual void AssertValid(string sOrigin, UInt32 nOriginIndex, OnError onerror);
}
public class JetBrains.Application.UI.Icons.Images.TiVectorImage : TiImage {
    internal IList`1<TiSegment> myClipMask;
    private IList`1<TiPath> myPaths;
    public Size LogicalSize;
    [NotNullAttribute]
public IList`1<TiSegment> ClipMask { get; }
    [NotNullAttribute]
public IList`1<TiPath> Paths { get; }
    public IList`1<TiSegment> get_ClipMask();
    public IList`1<TiPath> get_Paths();
    public void AssertValid(OnError onerror);
    public virtual Size GetLogicalSize();
}
public static class JetBrains.BooleanUtil : object {
    [NotNullAttribute]
[PureAttribute]
public static Func`2<string, bool> SafeParseBool(bool defaultValue);
    [PureAttribute]
public static bool SafeParseBool(string value, bool defaultValue);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.EventExtensions : object {
    [ExtensionAttribute]
public static void Raise(EventHandler`1<T> event, object sender, T args);
    [ExtensionAttribute]
public static void Raise(PropertyChangedEventHandler event, object sender, Expression`1<Func`1<T>> property);
    [ExtensionAttribute]
public static void Raise(PropertyChangedEventHandler event, object sender, Expression`1<Func`2<T, TV>> property);
    [ExtensionAttribute]
public static void Raise(PropertyChangedEventHandler event, object sender, string propertyName);
    [ExtensionAttribute]
public static void Raise(PropertyChangedEventHandler event, object sender, PropertyChangedEventArgs args);
    [ExtensionAttribute]
public static void Raise(EventHandler`1<EventArgs`1<T>> event, object sender, T args);
    [ExtensionAttribute]
public static void RaiseAsync(EventHandler`1<EventArgs`1<T>> event, object sender, T args);
    [ExtensionAttribute]
public static void Raise(EventHandler`2<T, EventArgs> event, T sender);
    [ExtensionAttribute]
public static void Raise(EventHandler`2<T, EventArgs`1<TValue>> event, T sender, TValue value);
    [ExtensionAttribute]
public static void Raise(EventHandler`2<T, TArgs> event, T sender, TArgs args);
    [ExtensionAttribute]
public static void Raise(EventHandler event, object sender);
    [ExtensionAttribute]
public static void Raise(EventHandler event, object sender, EventArgs eventArgs);
    [ExtensionAttribute]
public static void Raise(Action action);
    [ExtensionAttribute]
public static void Raise(Action`1<T> action, T arg);
    [ExtensionAttribute]
public static void UnsubscribeAll(EventHandler`2<T, TArgs> event);
}
public class JetBrains.Common.Util.EventHandler`2 : MulticastDelegate {
    public EventHandler`2(object object, IntPtr method);
    public virtual void Invoke(T sender, TArgs args);
    public virtual IAsyncResult BeginInvoke(T sender, TArgs args, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class JetBrains.Compression.IntegerDecoder : object {
    private static Byte[] SPEEDY;
    private Byte[] myBuffer;
    private int myBitPosition;
    public long FilePointer { get; }
    public int Limit { get; }
    public IntegerDecoder(Byte[] buff);
    public IntegerDecoder(IntegerEncoder integerEncoder);
    private static IntegerDecoder();
    public long get_FilePointer();
    public void Jump(long bits);
    public void Load(long fromBit);
    public void FullBuff(long fromBit);
    public void Close();
    public int Read();
    public byte Read0();
    public int ReadBit();
    public int ReadUnary();
    public int ReadBinary(int len);
    public int ReadGamma();
    public long ReadPack7();
    public int ReadPack7I();
    public int ReadGolomb(int b);
    public int get_Limit();
    protected int ENSURE();
    private int Shift();
    private int Gimme();
}
public class JetBrains.Compression.IntegerEncoder : object {
    internal static Int32[] INVONE;
    private Byte[] myBuff;
    private int myBitPosition;
    public long WrittenBits { get; }
    public int ByteLength { get; }
    public IntegerEncoder(int bufferSize);
    private static IntegerEncoder();
    public long get_WrittenBits();
    public Byte[] GetBytes();
    public void Close();
    public void Write(Byte[] b, int off, int len);
    public void FlushByte();
    public int get_ByteLength();
    public void Flush();
    public void Write(int b);
    public void WriteBit(int b);
    public void WriteUnary(int k);
    private void EnsureBuffer(int bytePos);
    public void WriteBinary(int val, int len);
    public void WriteGamma(int val);
    public void WritePack7(long val);
    public void WritePack7I(int val);
    public void WriteGolomb(int val, int b);
}
public class JetBrains.DataFlow.BidirectionalCompositeProperty`3 : CompositeProperty`3<TSourceOne, TSourceTwo, TTarget> {
    private object _cookie;
    protected BidirectionalCompositeProperty`3(Lifetime lifetime, IProperty`1<TSourceOne> propertySourceOne, IProperty`1<TSourceTwo> propertySourceTwo, ComposerDelegate<TSourceOne, TSourceTwo, TTarget> composer, Func`2<TTarget, TSourceOne> decomposerOne, Func`2<TTarget, TSourceTwo> decomposerTwo);
    protected virtual Property`1<TTarget> DecorateProperty(Lifetime lifetime, Property`1<TTarget> property);
    public static IProperty`1<TTarget> Create(Lifetime lifetime, IProperty`1<TSourceOne> propertySourceOne, IProperty`1<TSourceTwo> propertySourceTwo, ComposerDelegate<TSourceOne, TSourceTwo, TTarget> composer, Func`2<TTarget, TSourceOne> decomposerOne, Func`2<TTarget, TSourceTwo> decomposerTwo);
    [CompilerGeneratedAttribute]
private void <.ctor>b__0(BeforePropertyChangedEventArgs`1<TTarget> args);
}
[ExtensionAttribute]
public static class JetBrains.DataFlow.BidirectionalCompositePropertyEx : object {
    [ExtensionAttribute]
public static IProperty`1<Pair`2<T1, T2>> Compose(IProperty`1<T1> p1, Lifetime lifetime, IProperty`1<T2> p2);
    [CompilerGeneratedAttribute]
private static T1 <Compose>b__0(Pair`2<T1, T2> p);
    [CompilerGeneratedAttribute]
private static T2 <Compose>b__1(Pair`2<T1, T2> p);
}
[ExtensionAttribute]
public static class JetBrains.DataFlow.DataFlowEx : object {
    [ExtensionAttribute]
[NotNullAttribute]
public static Lifetime DefineWinFormsLifetime(Control ths);
    [ExtensionAttribute]
[NotNullAttribute]
public static Lifetime DefineWinFormsLifetime(Control ths, Lifetime parentLifetime);
}
public class JetBrains.DataFlow.DependencyPropertyChangeSink`1 : DependencyObject {
    private IProperty`1<TValue> myProperty;
    public static DependencyProperty ValueProperty;
    public IProperty`1<TValue> Property { get; }
    [UsedImplicitlyAttribute]
public TValue Value { get; public set; }
    public DependencyPropertyChangeSink`1(Lifetime lifetime, DependencyObject owner, DependencyProperty property, bool isVarianceAllowed);
    private static DependencyPropertyChangeSink`1();
    public IProperty`1<TValue> get_Property();
    public TValue get_Value();
    public void set_Value(TValue value);
    public static bool CheckDependencyPropertyType(DependencyObject dependencyobject, DependencyProperty dependencyproperty, bool isVarianceAllowed);
    public static PropertyId`1<TValue> CreatePropertyId(DependencyObject owner, DependencyProperty property);
    private static void OnValueChanged_Static(DependencyObject d, DependencyPropertyChangedEventArgs args);
    private void OnValueChanged(DependencyPropertyChangedEventArgs args);
    [CompilerGeneratedAttribute]
private void <.ctor>b__1(PropertyChangedEventArgs`1<TValue> args);
}
[ExtensionAttribute]
public static class JetBrains.DataFlow.DependencyPropertyWrapper : object {
    [NotNullAttribute]
public static IProperty`1<TValue> Create(Lifetime lifetime, DependencyObject dependencyobject, DependencyProperty dependencyproperty, bool bSinkEvents);
    [NotNullAttribute]
public static IProperty`1<TValue> Create(Lifetime lifetime, UIElement owner, DependencyProperty dependencyproperty, RoutedEvent event);
    [ObsoleteAttribute("Use overload with lifetime.")]
[ExtensionAttribute]
public static IDisposable FlowInto(IProperty`1<TSource> propSource, DependencyObject doTarget, DependencyProperty dpropTarget);
    [ExtensionAttribute]
public static void FlowInto(IProperty`1<TSource> propSource, Lifetime lifetime, DependencyObject doTarget, DependencyProperty dpropTarget);
    [ExtensionAttribute]
public static void FlowInto(IProperty`1<TSource> propSource, Lifetime lifetime, DependencyObject doTarget, DependencyProperty dpropTarget, Func`2<TSource, TTarget> FConvert);
    private static void BindDataFlowToDependency(Lifetime lifetime, IProperty`1<TValue> property, DependencyObject dependencyobject, DependencyProperty dependencyproperty);
    private static void BindDependencyToDataFlow_RoutedEvent(Lifetime lifetime, IProperty`1<TValue> property, UIElement owner, DependencyProperty dependencyproperty, RoutedEvent event);
}
[ExtensionAttribute]
public static class JetBrains.DataFlow.ICollectionEventsEx : object {
    [NotNullAttribute]
[ExtensionAttribute]
public static IListEvents`1<TItem> OrderByLive(IReadonlyCollectionEvents`1<TItem> ths, Lifetime lifetime, IComparer`1<TItem> comparer);
}
public static class JetBrains.DataFlow.Interop.PropertyBinding : object {
    public static void CreateBidirectional(Lifetime lifetime, IProperty`1<TValue> source, DependencyObject targetobject, DependencyProperty targetproperty, bool isVarianceAllowed);
    public static void CreateBidirectional(Lifetime lifetime, IProperty`1<TSource> source, DependencyObject targetobject, DependencyProperty targetproperty, Func`2<TSource, TTarget> FConvertSourceToTarget, Func`2<TTarget, TSource> FConvertTargetToSource);
    public static void CreateOneWayToSource(Lifetime lifetime, IProperty`1<TSource> source, DependencyObject targetobject, DependencyProperty targetproperty, Func`2<TTarget, TSource> FConvertTargetToSource);
    public static void CreateOneWayToSource(Lifetime lifetime, IProperty`1<TValue> source, DependencyObject targetobject, DependencyProperty targetproperty);
}
[DebuggerStepThroughAttribute]
[DefaultMemberAttribute("Item")]
public class JetBrains.DataFlow.ListEvents`1 : CollectionEvents`1<TValue> {
    private static string ValueNameListStorage;
    private SignalWithDelegates`1<AddRemoveIndexEventArgs`1<TValue>> mySignalAddRemove;
    private SignalWithDelegates`1<BeforeAddRemoveIndexEventArgs`1<TValue>> mySignalBeforeAddRemove;
    [NotNullAttribute]
private IList`1<TValue> myStorage;
    private object System.Collections.IList.Item { get; private set; }
    private bool System.Collections.IList.IsFixedSize { get; }
    public TValue Item { get; public set; }
    public ISignal`1<AddRemoveIndexEventArgs`1<TValue>> AddRemove { get; }
    public ISignal`1<BeforeAddRemoveIndexEventArgs`1<TValue>> BeforeAddRemove { get; }
    public ListEvents`1(Lifetime lifetime, PropertyId`1<TValue> id, IList`1<TValue> storage, bool bUniqueItems, ILogger logger);
    public ListEvents`1(PropertyId`1<TValue> id, IList`1<TValue> storage, bool bUniqueItems);
    public ListEvents`1(string id, IList`1<TValue> storage, bool bUniqueItems);
    public ListEvents`1(Lifetime lifetime, string id, IList`1<TValue> storage, bool bUniqueItems);
    public ListEvents`1(string id);
    public ListEvents`1(Lifetime lifetime, string id);
    public ListEvents`1(string id, bool bUniqueItems);
    public ListEvents`1(PropertyId`1<TValue> id, bool bUniqueItems);
    public ListEvents`1(Lifetime lifetime, string id, bool bUniqueItems);
    protected ListEvents`1(SerializationInfo info, StreamingContext context);
    private static ListEvents`1();
    protected void FireAddRemove(AddRemove action, TValue value, int index, object cookie);
    protected bool FireBeforeAddRemove(AddRemove action, TValue value, int index, object cookie);
    protected virtual bool InternalAdd(TValue value, int nIndexOrEnd, object cookie);
    protected virtual bool InternalRemove(int index, object cookie);
    private void OnAcknowledgeSinkAddRemove_Add(Action`1<AddRemoveIndexEventArgs`1<TValue>> handler);
    private void OnAcknowledgeSinkAddRemove_Remove(Action`1<AddRemoveIndexEventArgs`1<TValue>> handler);
    private bool OnAcknowledgeSinkBeforeAddRemove(Action`1<BeforeAddRemoveIndexEventArgs`1<TValue>> handler);
    protected virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    protected virtual bool InternalAdd(TValue value, object cookie);
    protected virtual bool InternalRemove(TValue value, object cookie);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object value);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string text);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    public sealed virtual TValue get_Item(int index);
    public sealed virtual void set_Item(int index, TValue value);
    public sealed virtual int IndexOf(TValue item);
    public sealed virtual void Insert(int index, TValue item);
    public sealed virtual bool Modify(AddRemove action, TValue item, int index, object cookie);
    public sealed virtual bool Modify(AddRemove action, Func`1<TValue> funcGetItemIfAdding, int index, object cookie);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual ISignal`1<AddRemoveIndexEventArgs`1<TValue>> get_AddRemove();
    public sealed virtual ISignal`1<BeforeAddRemoveIndexEventArgs`1<TValue>> get_BeforeAddRemove();
}
[ObsoleteAttribute("remove and use the one-type-param PropertyChangedEventArgs")]
[DebuggerStepThroughAttribute]
public class JetBrains.DataFlow.PropertyChangedEventArgs`2 : EventArgs {
    [CanBeNullAttribute]
private TIdentity myIdentity;
    [CanBeNullAttribute]
private TValue myNew;
    [CanBeNullAttribute]
private TValue myOld;
    [CanBeNullAttribute]
public TIdentity Identity { get; }
    [CanBeNullAttribute]
public TValue New { get; }
    [CanBeNullAttribute]
public TValue Old { get; }
    public PropertyChangedEventArgs`2(TIdentity identity, TValue old, TValue new);
    public TIdentity get_Identity();
    public TValue get_New();
    public TValue get_Old();
}
public static class JetBrains.DataFlow.RegistryValueProperty : object {
    public static IProperty`1<TValue> CreatePassive(Lifetime lifetime, RegistryKey keyRoot, string sKeyPath, string sDataName, TValue defvalue);
}
public static class JetBrains.DataFlow.StackTraceUtilRich : object {
    [NotNullAttribute]
public static RichText StackFrameToRichString(StackFrame frame);
}
public class JetBrains.DataStructures.CyclicBuffer : object {
    private int _end;
    private InputStream _input;
    private OutputStream _output;
    private int _start;
    private Byte[] _storage;
    public int Capacity { get; public set; }
    [NotNullAttribute]
public InputStream Input { get; }
    public OutputStream Output { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public int get_Capacity();
    public void set_Capacity(int value);
    public InputStream get_Input();
    public OutputStream get_Output();
    private int ReadCore(Byte[] arTarget, int nTargetOffset, int nTargetCount, BehaviorFlags behavior, bool bAdvanceReadPosition);
    private void Resize(int nNewSize);
    private void WriteCore(Byte[] arSource, int nSourceOffset, int nSourceCount, BehaviorFlags behavior);
    public sealed virtual void Add(byte item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(byte item);
    public sealed virtual void CopyTo(Byte[] array, int arrayIndex);
    public sealed virtual IEnumerator`1<byte> GetEnumerator();
    public sealed virtual bool Remove(byte item);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
}
[ExtensionAttribute]
public static class JetBrains.DataStructures.ImmutableArray : object {
    [ExtensionAttribute]
[NotNullAttribute]
public static ImmutableArray`1<T> ToImmutableArray(IEnumerable`1<T> enumerable);
    [NotNullAttribute]
[ExtensionAttribute]
public static ImmutableArray`1<T> ToImmutableArray(IReadOnlyCollection`1<T> collection);
    [NotNullAttribute]
public static ImmutableArray`1<T> Create(IEnumerable`1<T> enumerable);
    [NotNullAttribute]
public static ImmutableArray`1<T> Create(IReadOnlyCollection`1<T> collection);
    [NotNullAttribute]
public static ImmutableArray`1<T> FromArguments(T[] array);
}
[DefaultMemberAttribute("Item")]
public class JetBrains.DataStructures.ImmutableArray`1 : object {
    [NotNullAttribute]
private static ImmutableArray`1<T> EMPTY;
    [NotNullAttribute]
private T[] myArray;
    public static ImmutableArray`1<T> Empty { get; }
    public bool IsEmpty { get; }
    public int Count { get; }
    public T Item { get; }
    public ImmutableArray`1(IEnumerable`1<T> data);
    public ImmutableArray`1(IReadOnlyCollection`1<T> collection);
    private ImmutableArray`1(IEnumerable`1<T> data, int count);
    private static ImmutableArray`1();
    public static ImmutableArray`1<T> get_Empty();
    public bool get_IsEmpty();
    public sealed virtual bool Equals(ImmutableArray`1<T> other);
    public sealed virtual int get_Count();
    public sealed virtual T get_Item(int index);
    public int IndexOf(T value);
    public bool Contains(T value);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public static class JetBrains.DataStructures.StreamPipe : object {
    public static void Run(Action`1<Stream> funcWriter, Action`1<Stream> funcReader, ITaskHost tasker);
}
public static class JetBrains.DataStructures.StreamPipeXml : object {
    public static void Run(Action`1<XmlWriter> FInput, Action`1<XmlReader> FOutput, ITaskHost tasker);
    public static void Run(Action`1<XmlWriter> FInput, Action`2<XmlReader, XmlWriter> FTransform, Action`1<XmlReader> FOutput, ITaskHost tasker);
}
[ExtensionAttribute]
public static class JetBrains.Extension.DateTimeEx : object {
    [ExtensionAttribute]
public static string ToRelativeTime(DateTime dateTime);
    private static string Decorate(string delta, DateTime dateTime);
}
[ExtensionAttribute]
public static class JetBrains.Extension.IWin32WindowEx : object {
    [ExtensionAttribute]
public static Rectangle GetBounds(IWin32Window window);
    [ExtensionAttribute]
public static bool IsValidWindow(IWin32Window ths);
    [ExtensionAttribute]
public static IDisposable PushDisable(IWin32Window window);
}
[ExtensionAttribute]
public static class JetBrains.Extension.SupportInitializeExtensions : object {
    [ExtensionAttribute]
public static IDisposable InitScope(ISupportInitialize component);
}
public static class JetBrains.Interop.Modules.ControlPaint : object {
    public static void PaintStatusBarBackground(IntPtr hwnd, Graphics g, Rectangle rectArea, Rectangle rectClip);
}
public static class JetBrains.ReflectionUtil : object {
    public static IEnumerable`1<T> EnumerateEnumValues();
}
public class JetBrains.SlruCache`2 : object {
    private static Statistics Statistics;
    private static Func`4<K, V, TimeSpan, bool> EvictNever;
    [NotNullAttribute]
private Func`2<K, V> myProducer;
    [NotNullAttribute]
private Entry[] myEntries;
    [NotNullAttribute]
private Int32[] myProbationaryQueue;
    [NotNullAttribute]
private Int32[] myProtectedQueue;
    [CanBeNullAttribute]
private IEqualityComparer`1<K> myComparer;
    private int myProbationarySize;
    private int myProtectedSize;
    private int myEntriesSize;
    private int myFirstFreeEntry;
    private TimeSpan myEvictPeriod;
    private Func`4<K, V, TimeSpan, bool> myEvictPredicate;
    private DateTime myLastEvict;
    [CompilerGeneratedAttribute]
private static Func`4<K, V, TimeSpan, bool> CS$<>9__CachedAnonymousMethodDelegate8;
    public int Count { get; }
    public SlruCache`2(int capacity);
    public SlruCache`2(int capacity, Func`4<K, V, TimeSpan, bool> evictPredicate, TimeSpan evictionPeriod);
    public SlruCache`2(int probationaryCapacity, int protectedCapacity);
    public SlruCache`2(IEqualityComparer`1<K> comparer, int probationaryCapacity, int protectedCapacity);
    public SlruCache`2(Func`2<K, V> producer);
    public SlruCache`2(Func`2<K, V> producer, int capacity);
    public SlruCache`2(Func`2<K, V> producer, int probationaryCapacity, int protectedCapacity);
    public SlruCache`2(Func`2<K, V> producer, IEqualityComparer`1<K> equalityComparer, int probationaryCapacity, int protectedCapacity, Func`4<K, V, TimeSpan, bool> evictPredicate, TimeSpan evictionPeriod);
    private static SlruCache`2();
    private void Initialize();
    public void EvictConditionally();
    private void EvictFromQueue(Int32[] queue, Int32& size, DateTime now);
    public int get_Count();
    public void Invalidate(K key);
    private void InvalidateImpl(K key);
    private bool RemoveKey(K key, Int32[] queue, Int32& size);
    public void Clear();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IEnumerator`1<KeyValuePair`2<K, V>> GetEnumerator();
    public bool Lookup(K key, V& value);
    public void Provide(K key, V value);
    public V GetValue(K key);
    private void ProtectedHit(int i);
    private void ProbationaryHit(int i);
    private V CacheMiss(K key);
    private bool KeysEqual(K x, K y);
    private static V EmptyProducer(K k);
    [CompilerGeneratedAttribute]
private static bool <.cctor>b__7(K k, V v, TimeSpan ts);
}
public class JetBrains.Text.AnyOrderIdentiferMatcherFactory : object {
    public static IIdentifierMatcherFactory Instance;
    private static AnyOrderIdentiferMatcherFactory();
    public sealed virtual IIdentifierMatcher Create(string pattern, IdentifierMatchingStyle style, bool correctTypos);
}
public class JetBrains.Text.DefaultIdenfierMatcherFactory : object {
    public static IIdentifierMatcherFactory Instance;
    private static DefaultIdenfierMatcherFactory();
    public sealed virtual IIdentifierMatcher Create(string pattern, IdentifierMatchingStyle style, bool correctTypos);
}
public class JetBrains.Text.DefaultIdentifierMatcher : object {
    private IdentifierMatcher myImpl;
    public bool CorrectTypos { get; }
    public IdentifierMatchingStyle MatchingStyle { get; }
    public MatcherScore CurrentScore { get; }
    public bool CurrentResult { get; }
    public string CurrentIdentifier { get; }
    public string Filter { get; }
    public bool HasSuffixShrinkProperty { get; }
    public DefaultIdentifierMatcher(IdentifierMatcher impl);
    public sealed virtual Int32[] CurrentMatchingIndicesCopy();
    public sealed virtual bool get_CorrectTypos();
    public sealed virtual IdentifierMatchingStyle get_MatchingStyle();
    public sealed virtual MatcherScore get_CurrentScore();
    public sealed virtual bool get_CurrentResult();
    public sealed virtual string get_CurrentIdentifier();
    public sealed virtual string get_Filter();
    public sealed virtual bool Matches(string text);
    public sealed virtual Int32[] MatchingIndicies(string text);
    private sealed virtual override IIdentifierMatcher JetBrains.Util.ICloneable<JetBrains.Text.IIdentifierMatcher>.Clone();
    public sealed virtual object Clone();
    public sealed virtual bool get_HasSuffixShrinkProperty();
}
public class JetBrains.Text.IdentifierMatcher : object {
    private Int32[] myPrecalculatedPrefixMatchPositions;
    private Int32[] myMutableMatchPositionsPlaceholder;
    private IdentifierMatchingStyle myStyle;
    private bool myCorrectTypos;
    private bool myTrailingStar;
    private Int32[] myMatchPositions;
    private string myPattern;
    private string myLowerPattern;
    private string myAlternateKeyboardLayoutPattern;
    private Thread myFirstUseThread;
    [CompilerGeneratedAttribute]
private MatcherScore <CurrentScore>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CurrentResult>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CurrentIdentifier>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Filter>k__BackingField;
    public MatcherScore CurrentScore { get; private set; }
    public bool CurrentResult { get; private set; }
    public string CurrentIdentifier { get; private set; }
    public Int32[] SharedMatchingIndices { get; }
    public string Filter { get; private set; }
    public IdentifierMatchingStyle MatchingStyle { get; }
    public bool CorrectTypos { get; }
    private IdentifierMatcher(string filter, string pattern, string alternatePattern, string lowerPattern, IdentifierMatchingStyle style, bool correctTypos, bool trailingStar, Int32[] mutableMatchPositionsPlaceholder, Int32[] precalculatedPrefixMatchPositions);
    public IdentifierMatcher(string pattern, IdentifierMatchingStyle style, bool correctTypos);
    [CompilerGeneratedAttribute]
public MatcherScore get_CurrentScore();
    [CompilerGeneratedAttribute]
private void set_CurrentScore(MatcherScore value);
    [CompilerGeneratedAttribute]
public bool get_CurrentResult();
    [CompilerGeneratedAttribute]
private void set_CurrentResult(bool value);
    [CompilerGeneratedAttribute]
public string get_CurrentIdentifier();
    [CompilerGeneratedAttribute]
private void set_CurrentIdentifier(string value);
    public Int32[] get_SharedMatchingIndices();
    public Int32[] CurrentMatchingIndicesCopy();
    [CompilerGeneratedAttribute]
public string get_Filter();
    [CompilerGeneratedAttribute]
private void set_Filter(string value);
    public IdentifierMatchingStyle get_MatchingStyle();
    public bool get_CorrectTypos();
    private sealed virtual override object System.ICloneable.Clone();
    [PublicAPIAttribute]
public sealed virtual IdentifierMatcher Clone();
    public bool Matches(string text);
    [CanBeNullAttribute]
public Int32[] MatchingIndicies(string text);
    [ConditionalAttribute("JET_MODE_ASSERT")]
private void CheckThread();
    private bool Execute(Char* textData, int textLen, string pattern);
    private static int NextHmp(UnsafeIntArray humps, int index);
    private bool TypoCorrection(Char* lowerText, int n);
    private void CalculateScore(Char* textData, int textLen, int lastMatch, UnsafeIntArray humps, UnsafeIntArray allocatedEmptyArray, string pattern);
    private void CalcScoreOnHumps(UnsafeIntArray humps, MatcherScore allHumpMatchScore, MatcherScore firstHumpMatchScore, MatcherScore noGapsScore);
}
[ExtensionAttribute]
public static class JetBrains.Text.IdentifierMatcherExtensions : object {
    [ExtensionAttribute]
public static IdentifierMatcher Handle(IdentifierMatcher identifierMatcher, string text);
    [ExtensionAttribute]
public static IIdentifierMatcher Handle(IIdentifierMatcher identifierMatcher, string text);
}
[FlagsAttribute]
public enum JetBrains.Text.IdentifierMatchingFlags : Enum {
    public int value__;
    public static IdentifierMatchingFlags None;
    public static IdentifierMatchingFlags MatchPrefixCaseInsensitive;
    public static IdentifierMatchingFlags MatchInsideCaseInsensitive;
    public static IdentifierMatchingFlags MatchPrefixCaseSensitive;
    public static IdentifierMatchingFlags MatchPrefixIgnoreTypos;
}
public enum JetBrains.Text.IdentifierMatchingStyle : Enum {
    public int value__;
    public static IdentifierMatchingStyle BeginingOfIdentifier;
    public static IdentifierMatchingStyle EntireIdentifier;
    public static IdentifierMatchingStyle MiddleOfIdentifier;
    public static IdentifierMatchingStyle Default;
}
public interface JetBrains.Text.IIdentifierMatcher {
    public MatcherScore CurrentScore { get; }
    public bool CurrentResult { get; }
    public string CurrentIdentifier { get; }
    public string Filter { get; }
    public IdentifierMatchingStyle MatchingStyle { get; }
    public bool CorrectTypos { get; }
    public abstract virtual MatcherScore get_CurrentScore();
    public abstract virtual bool get_CurrentResult();
    public abstract virtual string get_CurrentIdentifier();
    public abstract virtual string get_Filter();
    public abstract virtual IdentifierMatchingStyle get_MatchingStyle();
    public abstract virtual bool get_CorrectTypos();
    public abstract virtual bool Matches(string text);
    public abstract virtual Int32[] MatchingIndicies(string text);
    public abstract virtual Int32[] CurrentMatchingIndicesCopy();
}
public interface JetBrains.Text.IIdentifierMatcherFactory {
    public abstract virtual IIdentifierMatcher Create(string pattern, IdentifierMatchingStyle style, bool correctTypos);
}
public interface JetBrains.Text.ISuffixShrinkMatcher {
    public bool HasSuffixShrinkProperty { get; }
    public abstract virtual bool get_HasSuffixShrinkProperty();
}
[FlagsAttribute]
public enum JetBrains.Text.MatcherScore : Enum {
    public int value__;
    public static MatcherScore None;
    public static MatcherScore NoTypos;
    public static MatcherScore NoCaseTypos;
    public static MatcherScore ExactMatch;
    public static MatcherScore ExactPrefixMatch;
    public static MatcherScore CorrectOrder;
    public static MatcherScore AllHumpsMatch;
    public static MatcherScore AllLetterHumpsMatch;
    public static MatcherScore FirstHumpMatch;
    public static MatcherScore FirstLetterHumpMatch;
    public static MatcherScore ExactMiddleMatch;
    public static MatcherScore NoGapsBetweenHumps;
    public static MatcherScore NoGapsBetweenLetterHumps;
    public static MatcherScore FirstLetterHumpCaseMatch;
    public static MatcherScore Highest;
}
[ExtensionAttribute]
public static class JetBrains.Text.MatcherScoreEx : object {
    [ExtensionAttribute]
public static int ToComparableInt(MatcherScore score, int adjustementCoefficient, MatcherScore adjustement);
    [ExtensionAttribute]
public static int ToCompletionScore(MatcherScore score);
    public static int HighestCompletionScore();
    public static int ExactPrefixMatchCompletionScore();
    [ExtensionAttribute]
public static bool IsExactPrefixMatch(MatcherScore score);
    [ExtensionAttribute]
public static bool HasTypos(MatcherScore score);
    [ExtensionAttribute]
public static bool IsExactMatch(MatcherScore score);
}
public class JetBrains.TextChange : object {
    [CompilerGeneratedAttribute]
private TextRange <Range>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NewText>k__BackingField;
    public TextRange Range { get; private set; }
    public string NewText { get; private set; }
    private int LengthDelta { get; }
    public TextChange(TextRange range, string newText);
    [CompilerGeneratedAttribute]
public TextRange get_Range();
    [CompilerGeneratedAttribute]
private void set_Range(TextRange value);
    [CompilerGeneratedAttribute]
public string get_NewText();
    [CompilerGeneratedAttribute]
private void set_NewText(string value);
    private int get_LengthDelta();
    private TextChange Shift(int offset);
    public static void ApplyChanges(IEnumerable`1<TextChange> changes, Action`1<TextChange> makeChange);
    public static int TranslateOffset(IEnumerable`1<TextChange> changes, int offset);
    private static List`1<TextChange> GetSortedChanges(IEnumerable`1<TextChange> changes);
}
public enum JetBrains.UI.Anchoring : Enum {
    public int value__;
    public static Anchoring NearWithout;
    public static Anchoring NearWithin;
    public static Anchoring MiddleWithin;
    public static Anchoring FarWithin;
    public static Anchoring FarWithout;
}
public class JetBrains.UI.Anchoring2D : ValueType {
    public static int BitsPerDim;
    public static int DimMask;
    public static int HorizontalMask;
    public static int HorizontalShift;
    public static int VerticalMask;
    public static int VerticalShift;
    public static Anchoring2D Empty;
    private static Anchoring2D[] myAnchorAside;
    private static Anchoring2D[] myAnchorBottomOrTop;
    private static Anchoring2D[] myAnchorLeftOrRightOnly;
    private static Anchoring2D[] myAnchorTop;
    private static Anchoring2D[] myAnchorTopOrBottom;
    public int Value;
    public static Anchoring2D[] AnchorAside { get; }
    public static Anchoring2D[] AnchorBottomOrTop { get; }
    public static Anchoring2D[] AnchorLeftOrRightOnly { get; }
    public static Anchoring2D[] AnchorTop { get; }
    public static Anchoring2D[] AnchorTopOrBottom { get; }
    public Anchoring Horizontal { get; public set; }
    public bool IsInside { get; }
    public Anchoring Vertical { get; public set; }
    public Anchoring2D(int value);
    public Anchoring2D(Anchoring horizontal, Anchoring vertical);
    private static Anchoring2D();
    public static Anchoring2D[] get_AnchorAside();
    public static Anchoring2D[] get_AnchorBottomOrTop();
    public static Anchoring2D[] get_AnchorLeftOrRightOnly();
    public static Anchoring2D[] get_AnchorTop();
    public static Anchoring2D[] get_AnchorTopOrBottom();
    public Anchoring get_Horizontal();
    public void set_Horizontal(Anchoring value);
    public bool get_IsInside();
    public Anchoring get_Vertical();
    public void set_Vertical(Anchoring value);
    public static bool IsFar(Anchoring anchoring);
    public static bool IsNear(Anchoring anchoring);
    [NotNullAttribute]
public Anchoring2D[] ToArray();
    public sealed virtual bool Equals(Anchoring2D other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static bool op_Equality(Anchoring2D , Anchoring2D );
    public static int op_Implicit(Anchoring2D anchoring);
    public static Anchoring2D op_Implicit(int value);
    public static bool op_Inequality(Anchoring2D , Anchoring2D );
}
internal class JetBrains.UI.ControlGraphicsContainer : object {
    private Control myControl;
    private Graphics myGraphics;
    public Graphics Graphics { get; }
    public ControlGraphicsContainer(Control control);
    public static bool IsGoodControl(Control control);
    public sealed virtual void Dispose();
    public sealed virtual Graphics get_Graphics();
}
[ContentPropertyAttribute("Child")]
public class JetBrains.UI.CrossFramework.JetElementHost : Control {
    private HwndSource myHwndSource;
    private RootDecorator myDecorator;
    private int myIsManualMeasure;
    private IMessageFilter[] myMessageFilters;
    [NotNullAttribute]
public IProperty`1<UIElement> Child;
    [CanBeNullAttribute]
public RootDecorator TopLevelElement { get; }
    [CanBeNullAttribute]
public HwndSource HwndSource { get; }
    public bool IsSelectable { get; public set; }
    public bool Focused { get; }
    protected Size DefaultSize { get; }
    public JetElementHost(UIElement child);
    public RootDecorator get_TopLevelElement();
    public HwndSource get_HwndSource();
    public bool get_IsSelectable();
    public void set_IsSelectable(bool value);
    [CanBeNullAttribute]
public static JetElementHost FromUIElement(UIElement element);
    public void RegisterMessageFilter(Lifetime lifetime, IMessageFilter messageFilter);
    private static ModifierKeys GetAvalonModifiers(Keys keys);
    private void DisposeHWndSource();
    private IntPtr HwndSourceHook(IntPtr hwnd, int msg, IntPtr wParam, IntPtr lParam, Boolean& handled);
    private void InputManager_PostProcessInput(object sender, ProcessInputEventArgs e);
    private void SetHWndSourceWindowPos();
    private bool OnTabNext(bool isForward);
    protected virtual void Dispose(bool disposing);
    public virtual bool get_Focused();
    protected virtual bool IsInputChar(char charCode);
    protected virtual void OnGotFocus(EventArgs e);
    protected virtual void OnHandleCreated(EventArgs e);
    protected virtual void OnLeave(EventArgs e);
    protected virtual void OnPaint(PaintEventArgs e);
    protected virtual void OnPaintBackground(PaintEventArgs pevent);
    protected virtual bool ProcessCmdKey(Message& msg, Keys keyData);
    protected virtual bool ProcessMnemonic(char charCode);
    protected virtual void Select(bool directed, bool forward);
    protected virtual void WndProc(Message& m);
    protected virtual Size get_DefaultSize();
    public virtual Size GetPreferredSize(Size proposedSize);
    private double ConvertProposedToAvailable(int proposedValue);
    [CompilerGeneratedAttribute]
private void <.ctor>b__0();
    [CompilerGeneratedAttribute]
private void <.ctor>b__1();
    [CompilerGeneratedAttribute]
private void <.ctor>b__2(PropertyChangedEventArgs`1<UIElement> args);
    [CompilerGeneratedAttribute]
private void <.ctor>b__3(PropertyChangedEventArgs`1<Size> size);
}
internal class JetBrains.UI.EmptyGraphicsContainer : object {
    public static EmptyGraphicsContainer Instance;
    public Graphics Graphics { get; }
    private static EmptyGraphicsContainer();
    public sealed virtual void Dispose();
    public sealed virtual Graphics get_Graphics();
}
public enum JetBrains.UI.ExpectedBackgroundColorHintMode : Enum {
    public int value__;
    public static ExpectedBackgroundColorHintMode Semblance;
    public static ExpectedBackgroundColorHintMode Contrast;
}
internal class JetBrains.UI.GetDcGraphicsContainer : object {
    private bool myDisposed;
    private Graphics myGraphics;
    private Void* myHdc;
    private Void* myHwnd;
    public Graphics Graphics { get; }
    public GetDcGraphicsContainer(Void* hwnd);
    private void Dispose(bool disposed);
    protected virtual void Finalize();
    public sealed virtual void Dispose();
    public sealed virtual Graphics get_Graphics();
}
[ExtensionAttribute]
public static class JetBrains.UI.GraphicsContainer : object {
    public static IGraphicsContainer FromControl(Control control);
    public static IGraphicsContainer FromGetDc(Void* hwnd);
    public static IGraphicsContainer FromGraphics(Graphics g);
    public static IGraphicsContainer FromGraphicsOrControl(Graphics g, Control control);
    public static IGraphicsContainer FromNothing();
    public static IGraphicsContainer FromPainting(Control control);
    public static IGraphicsContainer FromPainting(IntPtr hwnd);
    public static IGraphicsContainer FromScreen();
    [ExtensionAttribute]
[NotNullAttribute]
public static Graphics SetHighQuality(Graphics graphics);
}
internal class JetBrains.UI.HollowGraphicsContainer : object {
    public Graphics Graphics { get; }
    public sealed virtual void Dispose();
    public sealed virtual Graphics get_Graphics();
}
public interface JetBrains.UI.IGraphicsContainer {
    public Graphics Graphics { get; }
    public abstract virtual Graphics get_Graphics();
}
[ExtensionAttribute]
public static class JetBrains.UI.Interop.Helpers : object {
    internal static bool OptionTrace;
    private static Helpers();
    public static void BitBlt(Void* hdcDestination, Bitmap bitmapSource, Point ptDestinationLocation, Void* hdcIntermediate, byte nOpacity, Rectangle[] rectsSource);
    public static bool CanGlassify(IntPtr hwnd);
    [NotNullAttribute]
public static Bitmap CreateBitmap(Int32[0...,0...] pixels);
    [NotNullAttribute]
public static Bitmap FlattenAlpha(Image bmpAltiAliased, byte threshold);
    public static WindowExStyles GetWindowExStyle(IntPtr hwnd);
    public static WindowStyles GetWindowStyle(IntPtr hwnd);
    public static int MeasureDisplayStringWidth(Graphics graphics, string text, Font font);
    public static int MeasureDisplayStringWidthEffective(Graphics graphics, string text, Font font);
    public static Bitmap PaintWindowToBitmap(IWin32Window window);
    [ExtensionAttribute]
public static void RenderBuffered(IGraphicsContainer gc, Rectangle bounds, Action`1<Graphics> paint, bool bSupportAlphaChannel);
    [ExtensionAttribute]
public static void RenderBuffered(Graphics g, Rectangle bounds, Action`1<Graphics> FPaint, bool bSupportAlphaChannel);
    public static void ShowLayered(IntPtr hwnd, Rectangle area, Action`1<Graphics> funcRender);
}
[ExtensionAttribute]
public static class JetBrains.UI.Interop.HResultsEx : object {
    [ExtensionAttribute]
public static void Assert(HResults hresult);
    [ExtensionAttribute]
public static void Assert(HResults hresult, string comment);
    [ExtensionAttribute]
public static void AssertSucceeded(int hresult, string comment);
    [ExtensionAttribute]
public static void AssertSucceeded(UInt32 hresult, string comment);
    [ExtensionAttribute]
public static void AssertSucceeded(int hresult);
    [ExtensionAttribute]
public static bool Failed(HResults hresult);
    [ExtensionAttribute]
public static bool Succeeded(HResults hresult);
    [ExtensionAttribute]
[SourceTemplateAttribute]
public static void hr(int hresult);
}
internal class JetBrains.UI.PaintGraphicsContainer : object {
    private bool myDisposed;
    private Graphics myGraphics;
    private Void* myHwnd;
    private PAINTSTRUCT myPaintStruct;
    public Graphics Graphics { get; }
    public PaintGraphicsContainer(Void* hwnd);
    public static Graphics op_Implicit(PaintGraphicsContainer pg);
    public sealed virtual void Dispose();
    public sealed virtual Graphics get_Graphics();
}
public class JetBrains.UI.RenderParams : object {
    protected Font myFont;
    protected FontStyle myFontStyle;
    protected Color myNeutralForegroundColor;
    protected Color myNeutralBackgroundColor;
    protected ExpectedBackgroundColorHintMode myExpectedBackgroundColorHintMode;
    protected Color myExpectedBackgroundColorHint;
    protected StringTrimming myTrimming;
    protected HotkeyPrefix myMnemonics;
    protected int myPadding;
    protected Color myOverrideForegroundColor;
    protected Color myOverrideBackgroundColor;
    protected EffectStyle myEffect;
    protected Color myEffectColor;
    protected TextRenderingMethod myTextRenderingMethod;
    protected static Font myDefaultFont;
    protected bool myReadonly;
    protected static RenderParams myEmpty;
    protected static TextRenderingMethod myDefaultTextRenderingMethod;
    public Font Font { get; public set; }
    public FontStyle FontStyle { get; public set; }
    public Color NeutralForegroundColor { get; public set; }
    public Color NeutralBackgroundColor { get; public set; }
    public Color ExpectedBackgroundColorHint { get; public set; }
    public ExpectedBackgroundColorHintMode ExpectedBackgroundColorHintMode { get; public set; }
    public StringTrimming Trimming { get; public set; }
    public HotkeyPrefix Mnemonics { get; public set; }
    public int Padding { get; public set; }
    public Color OverrideForegroundColor { get; public set; }
    public Color OverrideBackgroundColor { get; public set; }
    public EffectStyle Effect { get; public set; }
    public Color EffectColor { get; public set; }
    public TextRenderingMethod TextRenderingMethod { get; public set; }
    public static RenderParams Empty { get; }
    public static Font DefaultFont { get; }
    public static TextRenderingMethod DefaultTextRenderingMethod { get; }
    public bool Readonly { get; }
    protected RenderParams(bool readonly);
    private static RenderParams();
    public Font get_Font();
    public void set_Font(Font value);
    public FontStyle get_FontStyle();
    public void set_FontStyle(FontStyle value);
    public Color get_NeutralForegroundColor();
    public void set_NeutralForegroundColor(Color value);
    public Color get_NeutralBackgroundColor();
    public void set_NeutralBackgroundColor(Color value);
    public Color get_ExpectedBackgroundColorHint();
    public void set_ExpectedBackgroundColorHint(Color value);
    public ExpectedBackgroundColorHintMode get_ExpectedBackgroundColorHintMode();
    public void set_ExpectedBackgroundColorHintMode(ExpectedBackgroundColorHintMode value);
    public StringTrimming get_Trimming();
    public void set_Trimming(StringTrimming value);
    public HotkeyPrefix get_Mnemonics();
    public void set_Mnemonics(HotkeyPrefix value);
    public int get_Padding();
    public void set_Padding(int value);
    public Color get_OverrideForegroundColor();
    public void set_OverrideForegroundColor(Color value);
    public Color get_OverrideBackgroundColor();
    public void set_OverrideBackgroundColor(Color value);
    public EffectStyle get_Effect();
    public void set_Effect(EffectStyle value);
    public Color get_EffectColor();
    public void set_EffectColor(Color value);
    public TextRenderingMethod get_TextRenderingMethod();
    public void set_TextRenderingMethod(TextRenderingMethod value);
    public static RenderParams get_Empty();
    public static Font get_DefaultFont();
    public static TextRenderingMethod get_DefaultTextRenderingMethod();
    public bool get_Readonly();
    public RenderParams Clone();
    private sealed virtual override object System.ICloneable.Clone();
    public void DumpToXaml(XmlWriter writer);
    public void ResetColors();
    public void SetReadonly();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class JetBrains.UI.RichText.FontCache : object {
    private List`1<Font> _fontList;
    private List`1<string> _fontFamilyNames;
    private List`1<IntPtr> _fontHandleList;
    public sealed virtual void Dispose();
    public Font GetFont(Font baseFont, FontStyle style);
    public IntPtr GetHFont(Font font);
    public IntPtr GetHFont(Font font, FontStyle fontStyle);
}
public class JetBrains.UI.RichText.RichString : object {
    private static int WaveLength;
    private static FontCache FontCache;
    public static bool AugmentGdiPlusContext;
    private int myOffset;
    private int myLength;
    private RichText myRichText;
    [CompilerGeneratedAttribute]
private TextStyle <Style>k__BackingField;
    public string Text { get; }
    public TextStyle Style { get; public set; }
    public int Offset { get; public set; }
    public int Length { get; public set; }
    public RichText RichText { get; }
    public RichString(int offset, int length, TextStyle style, RichText richtext);
    private static RichString();
    public string get_Text();
    [CompilerGeneratedAttribute]
public TextStyle get_Style();
    [CompilerGeneratedAttribute]
public void set_Style(TextStyle value);
    public int get_Offset();
    public void set_Offset(int value);
    public int get_Length();
    public void set_Length(int value);
    public RichText get_RichText();
    public SizeF GetSize(Graphics g, RenderParams renderParams);
    public int GetIndexFromPoint(Graphics g, RenderParams renderParams, int x);
    public static SizeF Measure(Graphics g, string s, SizeF size, RenderParams renderParams, TextStyle localStyle);
    public int Draw(Graphics g, Rectangle rectClip, RenderParams renderParams);
    public static TextFormatFlags GetParameterizedFormat_Gdi(RenderParams renderParams);
    public static StringFormat GetParameterizedFormat_GdiPlus(RenderParams renderParams);
    public static Font GetParametrizedFont(RenderParams renderParams, TextStyle localStyle);
    public static TextStyle OverrideTextStyle(RenderParams renderParams, TextStyle localStyle);
    public static FontStyle OverrideFontStyle(RenderParams renderParams, TextStyle localStyle);
    [ConditionalAttribute("JET_MODE_ASSERT")]
public void AssertValid();
    public void Dump(XmlWriter writer);
    public static void UnderlineStraight(Graphics g, RectangleF rect, Color effectColor);
    public static void UnderlineWeavy(Graphics g, RectangleF rect, Color effectColor);
    public static void StrikeOut(Graphics g, RectangleF rect, Color effectColor);
    public sealed virtual int CompareTo(object obj);
    public virtual string ToString();
}
public class JetBrains.UI.RichText.RichText : object {
    internal static bool OptionTrace;
    private static int ourPaintCounter;
    private List`1<RichString> myParts;
    private SizeF mySize;
    private bool mySizeIsValid;
    private Nullable`1<int> mySizeParametersHash;
    private string myString;
    [CompilerGeneratedAttribute]
private static Func`3<StringBuilder, RichString, StringBuilder> CS$<>9__CachedAnonymousMethodDelegate2;
    [CompilerGeneratedAttribute]
private static Func`3<StringBuilder, RichString, StringBuilder> CS$<>9__CachedAnonymousMethodDelegate3;
    public static RichText Empty { get; }
    public Color BackgroundColor { get; }
    public Color ForegroundColor { get; }
    public bool IsEmpty { get; }
    public int Length { get; }
    public string Text { get; public set; }
    public RichText(string text, TextStyle style);
    public RichText(string text);
    private RichText(string text, ICollection`1<RichString> parts);
    private static RichText();
    public static RichText get_Empty();
    public Color get_BackgroundColor();
    public Color get_ForegroundColor();
    public bool get_IsEmpty();
    public int get_Length();
    public string get_Text();
    public void set_Text(string value);
    public static bool IsNullOrEmpty(RichText richtext);
    public RichText Append(string s, TextStyle style);
    public RichText Append(string s);
    public RichText Append(RichText richText);
    [ConditionalAttribute("JET_MODE_ASSERT")]
public void AssertValid();
    public void Clear();
    public RichText Clone();
    public void Draw(Graphics g, Rectangle bounds, RenderParams renderParams);
    public string DumpToString();
    public void DumpToXaml(XmlWriter writer);
    [NotNullAttribute]
public IList`1<RichString> GetFormattedParts();
    public int GetIndexFromPoint(Graphics g, RenderParams renderParams, int x);
    public int GetIndexFromPoint(Graphics g, RenderParams renderParams, Point point);
    public Size GetSize(Graphics g, RenderParams renderParams);
    public SizeF GetSizeF(Graphics g, RenderParams renderParams);
    public RichText Prepend(string s, TextStyle style);
    public RichText Prepend(string s);
    public RichText Prepend(RichText richText);
    public void SetBackColor(Color backColor, int startOffset, int length);
    public void SetBackColor(Color backColor);
    public void SetColors(Color foreColor, Color backColor);
    public void SetColors(Color foreColor, Color backColor, int startOffset, int length);
    public void SetForeColor(Color foreColor);
    public void SetForeColor(Color foreColor, int startOffset, int length);
    public void SetStyle(TextStyle style, int startOffset, int length);
    public void SetStyle(FontStyle style, int startOffset, int length);
    public void SetStyle(FontStyle style);
    public void SetStyle(TextStyle style);
    public void SetStyle(EffectStyle effect, Color effectColor, int startOffset, int length);
    public void SetStyle(EffectStyle effect, Color effectColor);
    public RichText[] Split(int offset);
    public RichText Trim(Char[] trimChars);
    public RichText TrimEnd(Char[] trimChars);
    public RichText TrimStart(Char[] trimChars);
    private IList`1<RichString> BreakString(RichString partSrc, int nLocalOffset, bool bModifyPartsCollection);
    public void Replace(char a, char b);
    private IList`1<RichString> GetPartsFromRangeAndSplit(int startOffset, int length);
    public string ToString(bool addPartMarks);
    public virtual string ToString();
    [ContractAnnotationAttribute("a:null => null; b:null => null; a:notnull, b:notnull => notnull")]
public static RichText op_Addition(RichText a, RichText b);
    [ContractAnnotationAttribute("a:null => null; b:null => null; a:notnull, b:notnull => notnull")]
public static RichText op_Addition(RichText a, string b);
    [ContractAnnotationAttribute("a:null => null; b:null => null; a:notnull, b:notnull => notnull")]
public static RichText op_Addition(string a, RichText b);
    [ContractAnnotationAttribute("null => null; notnull => notnull")]
public static string op_Implicit(RichText richText);
    [ContractAnnotationAttribute("null => null; notnull => notnull")]
public static RichText op_Implicit(string text);
    private sealed virtual override object System.ICloneable.Clone();
    [CompilerGeneratedAttribute]
private static StringBuilder <ToString>b__0(StringBuilder builder, RichString part);
    [CompilerGeneratedAttribute]
private static StringBuilder <ToString>b__1(StringBuilder builder, RichString part);
}
public class JetBrains.UI.RichText.RichTextBlock : object {
    private List`1<RichText> myLines;
    private RichTextBlockParameters myParameters;
    [CompilerGeneratedAttribute]
private static Func`3<RichText, RichText, RichText> CS$<>9__CachedAnonymousMethodDelegate1;
    [CompilerGeneratedAttribute]
private static Func`2<RichText, bool> CS$<>9__CachedAnonymousMethodDelegate3;
    public IList`1<RichText> Lines { get; }
    public RichTextBlockParameters Parameters { get; public set; }
    public RichText RichText { get; public set; }
    public string Text { get; public set; }
    public RichTextBlock(RichTextBlockParameters parameters);
    public RichTextBlock(string text);
    public RichTextBlock(string text, RichTextBlockParameters parameters);
    public RichTextBlock(RichText richtext);
    public RichTextBlock(RichText richtext, RichTextBlockParameters parameters);
    public RichTextBlock(RichTextBlock block);
    public IList`1<RichText> get_Lines();
    public RichTextBlockParameters get_Parameters();
    public void set_Parameters(RichTextBlockParameters value);
    public RichText get_RichText();
    public void set_RichText(RichText value);
    public string get_Text();
    public void set_Text(string value);
    public static bool IsNullOrEmpty(RichTextBlock text);
    public static bool IsNullOrWhiteSpace(RichTextBlock text);
    public void SplitAndAdd(RichText value);
    public int Add(RichText line);
    public void AddLines(RichTextBlock lines);
    public void AddLinesCloned(RichTextBlock lines);
    public RichTextBlock Clone();
    public void Draw(Graphics g, Rectangle blockRect, RenderParams renderParams);
    [ObsoleteAttribute("Supply the RenderParams when measuring text.")]
public void Draw(Graphics g, Rectangle blockRect);
    public void DumpToXaml(XmlWriter writer);
    public int GetLine(Point point, Graphics g, RenderParams renderParams);
    [ObsoleteAttribute("Supply the RenderParams when measuring text.")]
public int GetLine(Point point, Graphics g);
    public int GetOffset(Graphics g, Point point, RenderParams renderParams);
    [ObsoleteAttribute("Supply the RenderParams when measuring text.")]
public int GetOffset(Graphics g, Point point);
    public Size GetSize(Graphics g, RenderParams renderParams);
    public SizeF GetSizeF(Graphics g, RenderParams renderParams);
    [ObsoleteAttribute("Supply the RenderParams when measuring text.")]
public SizeF GetSizeF(Graphics g);
    public void InsertLine(RichText line, int index);
    public void RemoveLine(RichText line);
    public void RemoveLineAt(int index);
    public virtual string ToString();
    public static RichText op_Explicit(RichTextBlock value);
    public static RichTextBlock op_Explicit(RichText value);
    public static string op_Explicit(RichTextBlock value);
    public static RichTextBlock op_Explicit(string value);
    public sealed virtual IEnumerator GetEnumerator();
    [CompilerGeneratedAttribute]
private static RichText <get_RichText>b__0(RichText text, RichText richText);
    [CompilerGeneratedAttribute]
private static bool <IsNullOrWhiteSpace>b__2(RichText x);
}
public static class JetBrains.UI.RichText.RichTextBlockFormatter : object {
    private static Char[] ourSplitters;
    private static RichTextBlockFormatter();
    public static RichTextBlock Format(RichTextBlock block, int width, Graphics g, RenderParams renderParams);
    public static RichTextBlock Format(RichText text, int width, Graphics g, RenderParams renderParams);
}
public class JetBrains.UI.RichText.RichTextBlockParameters : ValueType {
    private ContentAlignment myAlignment;
    private int myInterlineSpacing;
    public static RichTextBlockParameters Default { get; }
    public ContentAlignment Alignment { get; public set; }
    public int InterlineSpacing { get; public set; }
    public RichTextBlockParameters(int interlineSpacing, ContentAlignment alignment);
    public RichTextBlockParameters(int interlineSpacing);
    public static RichTextBlockParameters get_Default();
    public ContentAlignment get_Alignment();
    public void set_Alignment(ContentAlignment value);
    public int get_InterlineSpacing();
    public void set_InterlineSpacing(int value);
    public void DumpToXaml(XmlWriter writer);
    public virtual string ToString();
}
[ObsoleteAttribute("Possibly, useless.")]
public class JetBrains.UI.RichText.RichTextBlockPresenter : object {
    protected RichTextBlock myContent;
    protected Size myDesiredSize;
    protected RichTextBlock myReflowedContent;
    protected RenderParams myRenderParams;
    protected Size mySize;
    public RichTextBlock Content { get; }
    public Size DesiredSize { get; }
    public RenderParams RenderParams { get; public set; }
    public Size Size { get; }
    protected RichTextBlock ReflowedContent { get; }
    public RichTextBlock get_Content();
    public Size get_DesiredSize();
    public RenderParams get_RenderParams();
    public void set_RenderParams(RenderParams value);
    public Size get_Size();
    public Size GetConstrainedSize(Graphics g, Size sizeConstraint);
    public void SetContent(Graphics g, RichTextBlock value);
    public void SetSize(Graphics g, Size size);
    protected void PerformLayout(Graphics g);
    protected RichTextBlock get_ReflowedContent();
}
[ExtensionAttribute]
public static class JetBrains.UI.RichText.RichTextBlockToHtml : object {
    [ExtensionAttribute]
public static string ToHtml(RichTextBlock block);
}
[ExtensionAttribute]
public static class JetBrains.UI.RichText.RichTextEx : object {
    [ExtensionAttribute]
[ContractAnnotationAttribute("null=>true")]
public static bool IsNullOrEmpty(RichText ths);
}
public class JetBrains.UI.RichText.RichTextParameters : object {
    [CompilerGeneratedAttribute]
private bool <DrawEllipsis>k__BackingField;
    [CompilerGeneratedAttribute]
private Font <Font>k__BackingField;
    [CompilerGeneratedAttribute]
private TextStyle <Style>k__BackingField;
    public bool DrawEllipsis { get; public set; }
    public Font Font { get; public set; }
    public TextStyle Style { get; public set; }
    public RichTextParameters(Font font);
    public RichTextParameters(Font font, TextStyle style);
    public RichTextParameters(Font font, TextStyle style, bool drawEllipsis);
    [CompilerGeneratedAttribute]
public bool get_DrawEllipsis();
    [CompilerGeneratedAttribute]
public void set_DrawEllipsis(bool value);
    [CompilerGeneratedAttribute]
public Font get_Font();
    [CompilerGeneratedAttribute]
public void set_Font(Font value);
    [CompilerGeneratedAttribute]
public TextStyle get_Style();
    [CompilerGeneratedAttribute]
public void set_Style(TextStyle value);
    public void Dump(XmlWriter writer);
}
public enum JetBrains.UI.RichText.TextRenderingMethod : Enum {
    public int value__;
    public static TextRenderingMethod GdiPlus;
    public static TextRenderingMethod Gdi;
}
public class JetBrains.UI.RichText.TextStyle : ValueType {
    private FontStyle myFontStyle;
    private Color myForegroundColor;
    private Color myBackgroundColor;
    private EffectStyle myEffect;
    private Color myEffectColor;
    private static TextStyle ourDefaultStyle;
    private static TextStyle ourHiddenStyle;
    public FontStyle FontStyle { get; public set; }
    public Color ForegroundColor { get; public set; }
    public Color BackgroundColor { get; public set; }
    public EffectStyle Effect { get; public set; }
    public Color EffectColor { get; public set; }
    public static TextStyle Default { get; }
    public static TextStyle Hidden { get; }
    public static Color DefaultForegroundColor { get; }
    public static Color DefaultBackgroundColor { get; }
    public static Color DefaultEffectColor { get; }
    public TextStyle(FontStyle fontStyle, Color foregroundColor, Color backgroundColor);
    public TextStyle(FontStyle fontStyle, Color foregroundColor);
    public TextStyle(FontStyle fontStyle, Color foregroundColor, Color backgroundColor, EffectStyle effect, Color effectColor);
    public TextStyle(FontStyle fontStyle);
    public TextStyle(Color foregroundColor, Color backgroundColor);
    private static TextStyle();
    [PureAttribute]
public static TextStyle FromBackColor(Color color);
    [PureAttribute]
public static TextStyle FromForeColor(Color color);
    public FontStyle get_FontStyle();
    public void set_FontStyle(FontStyle value);
    public Color get_ForegroundColor();
    public void set_ForegroundColor(Color value);
    public Color get_BackgroundColor();
    public void set_BackgroundColor(Color value);
    public EffectStyle get_Effect();
    public void set_Effect(EffectStyle value);
    public Color get_EffectColor();
    public void set_EffectColor(Color value);
    public static TextStyle get_Default();
    public static TextStyle get_Hidden();
    public static Color get_DefaultForegroundColor();
    public static Color get_DefaultBackgroundColor();
    public static Color get_DefaultEffectColor();
    public void Dump(XmlWriter writer);
    public sealed virtual bool Equals(TextStyle other);
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(TextStyle left, TextStyle right);
    public static bool op_Inequality(TextStyle left, TextStyle right);
}
internal class JetBrains.UI.ScreenGraphics : object {
    private bool myDisposed;
    private Graphics myGraphics;
    private Void* myHdc;
    public Graphics Graphics { get; }
    public ScreenGraphics(Control control);
    public static Graphics op_Implicit(ScreenGraphics sg);
    private void Dispose(bool disposed);
    protected virtual void Finalize();
    public sealed virtual void Dispose();
    public sealed virtual Graphics get_Graphics();
}
internal class JetBrains.UI.SimpleGraphicsContainer : object {
    private Graphics myGraphics;
    public Graphics Graphics { get; }
    public SimpleGraphicsContainer(Graphics graphics);
    public sealed virtual void Dispose();
    public sealed virtual Graphics get_Graphics();
}
[NoReorderAttribute]
public class JetBrains.Util._DEBUG_EVENT : ValueType {
    public UInt32 dwDebugEventCode;
    public UInt32 dwProcessId;
    public UInt32 dwThreadId;
}
public class JetBrains.Util.AlphanumericComparer : object {
    public sealed virtual int Compare(string x, string y);
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Util.Alternative`1 : ValueType {
    private T myForTrue;
    private T myForFalse;
    public T Item { get; }
    public Alternative`1(T forTrue, T forFalse);
    public T get_Item(bool value);
}
public class JetBrains.Util.AppDomainDumper : object {
    [CompilerGeneratedAttribute]
private static Func`2<Assembly, string> CS$<>9__CachedAnonymousMethodDelegate1;
    [CompilerGeneratedAttribute]
private static Func`2<AssemblyName, string> CS$<>9__CachedAnonymousMethodDelegate3;
    public static void DumpDomain();
    public static void DumpDomain(FileSystemPath path);
    public static void DumpDomain(AppDomain domain, TextWriter writer);
    private static void DumpAssembly(TextWriter writer, Assembly assembly, Dictionary`2<AssemblyNameInfo, Assembly> loadedAssemblies, HashSet`1<AssemblyNameInfo> seen, int indent);
    private static string GetCodeBaseSafe(Assembly assembly);
    private static void Indent(TextWriter writer, int indent);
    [CompilerGeneratedAttribute]
private static string <DumpDomain>b__0(Assembly x);
    [CompilerGeneratedAttribute]
private static string <DumpAssembly>b__2(AssemblyName x);
}
[LocalizableAttribute("False")]
public static class JetBrains.Util.AssertionWithSensitiveData : object {
    [AssertionMethodAttribute]
[ConditionalAttribute("JET_MODE_ASSERT")]
[ContractAnnotationAttribute("condition:false=>void")]
public static void Assert(bool condition, string message, Pair`2[] sensitiveData);
    [ConditionalAttribute("JET_MODE_ASSERT")]
[ContractAnnotationAttribute("condition:false=>void")]
[AssertionMethodAttribute]
public static void Assert(bool condition, string message, Pair`2<string, object> d1);
    [AssertionMethodAttribute]
[ConditionalAttribute("JET_MODE_ASSERT")]
[ContractAnnotationAttribute("condition:false=>void")]
public static void Assert(bool condition, string message, Pair`2<string, object> d1, Pair`2<string, object> d2);
    [ConditionalAttribute("JET_MODE_ASSERT")]
[ContractAnnotationAttribute("condition:false=>void")]
[AssertionMethodAttribute]
public static void Assert(bool condition, string message, Pair`2<string, object> d1, Pair`2<string, object> d2, Pair`2<string, object> d3);
    [StringFormatMethodAttribute("message")]
[AssertionMethodAttribute]
[ConditionalAttribute("JET_MODE_ASSERT")]
[ContractAnnotationAttribute("condition:false=>void")]
public static void Assert(bool condition, string message, Pair`2[] sensitiveData, T arg);
    [StringFormatMethodAttribute("message")]
[ConditionalAttribute("JET_MODE_ASSERT")]
[AssertionMethodAttribute]
[ContractAnnotationAttribute("condition:false=>void")]
public static void Assert(bool condition, string message, Pair`2<string, object> d1, T arg);
    [StringFormatMethodAttribute("message")]
[AssertionMethodAttribute]
[ConditionalAttribute("JET_MODE_ASSERT")]
[ContractAnnotationAttribute("condition:false=>void")]
public static void Assert(bool condition, string message, Pair`2<string, object> d1, Pair`2<string, object> d2, T arg);
    [AssertionMethodAttribute]
[ContractAnnotationAttribute("condition:false=>void")]
[ConditionalAttribute("JET_MODE_ASSERT")]
[StringFormatMethodAttribute("message")]
public static void Assert(bool condition, string message, Pair`2[] sensitiveData, T1 arg1, T2 arg2);
    [ContractAnnotationAttribute("condition:false=>void")]
[AssertionMethodAttribute]
[ConditionalAttribute("JET_MODE_ASSERT")]
[StringFormatMethodAttribute("message")]
public static void Assert(bool condition, string message, Pair`2<string, object> d1, T1 arg1, T2 arg2);
    [StringFormatMethodAttribute("message")]
[ConditionalAttribute("JET_MODE_ASSERT")]
[AssertionMethodAttribute]
[ContractAnnotationAttribute("condition:false=>void")]
public static void Assert(bool condition, string message, Pair`2<string, object> d1, Pair`2<string, object> d2, T1 arg1, T2 arg2);
    [ContractAnnotationAttribute("condition:false=>void")]
[ConditionalAttribute("JET_MODE_ASSERT")]
[AssertionMethodAttribute]
[StringFormatMethodAttribute("message")]
public static void Assert(bool condition, string message, Pair`2[] sensitiveData, T1 arg1, T2 arg2, T3 arg3);
    [AssertionMethodAttribute]
[ConditionalAttribute("JET_MODE_ASSERT")]
[ContractAnnotationAttribute("condition:false=>void")]
[StringFormatMethodAttribute("message")]
public static void Assert(bool condition, string message, Pair`2[] sensitiveData, T1 arg1, T2 arg2, T3 arg3, T4 arg4);
    [ContractAnnotationAttribute("condition:false=>void")]
[AssertionMethodAttribute]
[StringFormatMethodAttribute("message")]
[ConditionalAttribute("JET_MODE_ASSERT")]
public static void Assert(bool condition, string message, Pair`2[] sensitiveData, Object[] args);
    [AssertionMethodAttribute]
[ContractAnnotationAttribute("=>void")]
public static void Fail(string message, Pair`2[] sensitiveData);
    [AssertionMethodAttribute]
[ContractAnnotationAttribute("condition:null=>void")]
[ConditionalAttribute("JET_MODE_ASSERT")]
public static void AssertNotNull(object condition, string message, Pair`2[] sensitiveData);
    [ConditionalAttribute("JET_MODE_ASSERT")]
[AssertionMethodAttribute]
[ContractAnnotationAttribute("condition:null=>void")]
public static void AssertNotNull(object condition, string message, Pair`2[] sensitiveData, object arg1);
    [AssertionMethodAttribute]
[ConditionalAttribute("JET_MODE_ASSERT")]
[ContractAnnotationAttribute("condition:null=>void")]
public static void AssertNotNull(object condition, string message, Pair`2[] sensitiveData, object arg1, object arg2);
    [AssertionMethodAttribute]
[ContractAnnotationAttribute("condition:null=>void")]
[ConditionalAttribute("JET_MODE_ASSERT")]
public static void AssertNotNull(object condition, string message, Pair`2[] sensitiveData, object arg1, object arg2, object arg3);
    [ConditionalAttribute("JET_MODE_ASSERT")]
[AssertionMethodAttribute]
[ContractAnnotationAttribute("condition:null=>void")]
public static void AssertNotNull(object condition, string message, Pair`2[] sensitiveData, Object[] args);
    [ContractAnnotationAttribute("condition:null=>void")]
[ConditionalAttribute("JET_MODE_ASSERT")]
[AssertionMethodAttribute]
public static void AssertNotNull(object condition, string message, Pair`2<string, object> d1);
    [AssertionMethodAttribute]
[ConditionalAttribute("JET_MODE_ASSERT")]
[ContractAnnotationAttribute("condition:null=>void")]
public static void AssertNotNull(object condition, string message, Pair`2<string, object> d1, object arg1);
    [AssertionMethodAttribute]
[ContractAnnotationAttribute("condition:null=>void")]
[ConditionalAttribute("JET_MODE_ASSERT")]
public static void AssertNotNull(object condition, string message, Pair`2<string, object> d1, object arg1, object arg2);
    [ContractAnnotationAttribute("condition:null=>void")]
[ConditionalAttribute("JET_MODE_ASSERT")]
[AssertionMethodAttribute]
public static void AssertNotNull(object condition, string message, Pair`2<string, object> d1, object arg1, object arg2, object arg3);
    [ContractAnnotationAttribute("condition:null=>void")]
[ConditionalAttribute("JET_MODE_ASSERT")]
[AssertionMethodAttribute]
public static void AssertNotNull(object condition, string message, Pair`2<string, object> d1, Object[] args);
    [ContractAnnotationAttribute("condition:null=>void")]
[AssertionMethodAttribute]
[ConditionalAttribute("JET_MODE_ASSERT")]
public static void AssertNotNull(object condition, string message, Pair`2<string, object> d1, Pair`2<string, object> d2);
    [ContractAnnotationAttribute("condition:null=>void")]
[ConditionalAttribute("JET_MODE_ASSERT")]
[AssertionMethodAttribute]
public static void AssertNotNull(object condition, string message, Pair`2<string, object> d1, Pair`2<string, object> d2, object arg1);
    [ContractAnnotationAttribute("condition:null=>void")]
[ConditionalAttribute("JET_MODE_ASSERT")]
[AssertionMethodAttribute]
public static void AssertNotNull(object condition, string message, Pair`2<string, object> d1, Pair`2<string, object> d2, object arg1, object arg2);
    [ConditionalAttribute("JET_MODE_ASSERT")]
[ContractAnnotationAttribute("condition:null=>void")]
[AssertionMethodAttribute]
public static void AssertNotNull(object condition, string message, Pair`2<string, object> d1, Pair`2<string, object> d2, object arg1, object arg2, object arg3);
    [ContractAnnotationAttribute("condition:null=>void")]
[AssertionMethodAttribute]
[ConditionalAttribute("JET_MODE_ASSERT")]
public static void AssertNotNull(object condition, string message, Pair`2<string, object> d1, Pair`2<string, object> d2, Object[] args);
    [AssertionMethodAttribute]
[ContractAnnotationAttribute("condition:null=>void")]
[ConditionalAttribute("JET_MODE_ASSERT")]
public static void AssertNotNull(object condition, string message, Pair`2<string, object> d1, Pair`2<string, object> d2, Pair`2<string, object> d3);
    [ContractAnnotationAttribute("condition:null=>void")]
[AssertionMethodAttribute]
[ConditionalAttribute("JET_MODE_ASSERT")]
public static void AssertNotNull(object condition, string message, Pair`2<string, object> d1, Pair`2<string, object> d2, Pair`2<string, object> d3, object arg1);
    [ContractAnnotationAttribute("condition:null=>void")]
[AssertionMethodAttribute]
[ConditionalAttribute("JET_MODE_ASSERT")]
public static void AssertNotNull(object condition, string message, Pair`2<string, object> d1, Pair`2<string, object> d2, Pair`2<string, object> d3, object arg1, object arg2);
    [ConditionalAttribute("JET_MODE_ASSERT")]
[AssertionMethodAttribute]
[ContractAnnotationAttribute("condition:null=>void")]
public static void AssertNotNull(object condition, string message, Pair`2<string, object> d1, Pair`2<string, object> d2, Pair`2<string, object> d3, object arg1, object arg2, object arg3);
    [ConditionalAttribute("JET_MODE_ASSERT")]
[AssertionMethodAttribute]
[ContractAnnotationAttribute("condition:null=>void")]
public static void AssertNotNull(object condition, string message, Pair`2<string, object> d1, Pair`2<string, object> d2, Pair`2<string, object> d3, Object[] args);
}
public static class JetBrains.Util.AsyncLazy : object {
    [NotNullAttribute]
[PureAttribute]
public static AsyncLazy`1<T> Create(Func`1<T> value);
    [NotNullAttribute]
[PureAttribute]
public static AsyncLazy`1<T> Create(Func`1<Task`1<T>> value);
    [PureAttribute]
[NotNullAttribute]
public static AsyncLazy`1<T> Create(T value);
}
public class JetBrains.Util.AsyncLazy`1 : object {
    [CanBeNullAttribute]
private Func`1<Task`1<TValue>> myAfactory;
    [CanBeNullAttribute]
private Task`1<TValue> myValue;
    public AsyncLazy`1(Task`1<TValue> value);
    public AsyncLazy`1(Func`1<TValue> factory);
    public AsyncLazy`1(Func`1<Task`1<TValue>> afactory);
    [UsedImplicitlyAttribute]
public TaskAwaiter`1<TValue> GetAwaiter();
    [NotNullAttribute]
public Task`1<TValue> GetValueAsync();
    [NotNullAttribute]
private Task`1<TValue> GetValueCold();
    [NotNullAttribute]
protected virtual Task`1<TValue> OnCustomGetValue();
}
public class JetBrains.Util.AsyncStreamReader : object {
    internal static int DefaultBufferSize;
    private static int MinBufferSize;
    private Stream myStream;
    private Encoding myEncoding;
    private Decoder myDecoder;
    private Byte[] myByteBuffer;
    private Char[] myCharBuffer;
    private int myMaxCharsPerBuffer;
    private Action`1<string> myUserCallBack;
    private bool myCancelOperation;
    private ManualResetEvent myEofEvent;
    private Queue myMessageQueue;
    private StringBuilder mySb;
    private bool myBLastCarriageReturn;
    public Encoding CurrentEncoding { get; }
    public Stream BaseStream { get; }
    public AsyncStreamReader(Stream stream, Action`1<string> callback, Encoding encoding);
    internal AsyncStreamReader(Stream stream, Action`1<string> callback, Encoding encoding, int bufferSize);
    private void Init(Stream stream, Action`1<string> callback, Encoding encoding, int bufferSize);
    public virtual void Close();
    private sealed virtual override void System.IDisposable.Dispose();
    protected virtual void Dispose(bool disposing);
    public virtual Encoding get_CurrentEncoding();
    public virtual Stream get_BaseStream();
    public void BeginReadLine();
    internal void CancelOperation();
    private void ReadBuffer(IAsyncResult ar);
    private void GetLinesFromStringBuilder();
    private void FlushMessageQueue();
    public void WaitUtilEof();
}
public class JetBrains.Util.Bdd.Bdd : object {
}
internal class JetBrains.Util.Bdd.BddNode : ValueType {
    private static int ChildMask;
    private static int ChildShift;
    private static int VarShiftA;
    private static int VarMaskA;
    private int myA;
    private int myB;
    private bool IsSpecial { get; }
    private int SpecialValue { get; }
    private int Left { get; }
    private int Right { get; }
    private int Var { get; }
    private bool get_IsSpecial();
    private int get_SpecialValue();
    private int get_Left();
    private int get_Right();
    private int get_Var();
}
[ObsoleteAttribute("The implementation has been switched from Dictionary to CompactMap some time ago. This relieved mem pressure in some scenarios, but impaired performance (got a few times slower). Pls choose specifically between BidirectionalMapOnDictionary (if targeting perf without large mem use) or BidirectionalMapOnCompactMap (if hi mem use but not so perf critical).")]
public class JetBrains.Util.BidirectionalMap`2 : object {
    private CompactMap`2<TLeft, TRight> myLeftToRightMap;
    private CompactMap`2<TRight, TLeft> myRightToLeftMap;
    public int Count { get; }
    public ICollection`1<TLeft> LeftKeys { get; }
    public IDictionary`2<TLeft, TRight> LeftToRight { get; }
    public ICollection`1<TRight> RightKeys { get; }
    public IDictionary`2<TRight, TLeft> RightToLeft { get; }
    public BidirectionalMap`2(int capacity);
    public BidirectionalMap`2(int capacity, IEqualityComparer`1<TLeft> leftComparer, IEqualityComparer`1<TRight> rightComparer);
    public BidirectionalMap`2(IEqualityComparer`1<TLeft> leftComparer, IEqualityComparer`1<TRight> rightComparer);
    public int get_Count();
    public ICollection`1<TLeft> get_LeftKeys();
    public IDictionary`2<TLeft, TRight> get_LeftToRight();
    public ICollection`1<TRight> get_RightKeys();
    public IDictionary`2<TRight, TLeft> get_RightToLeft();
    public void Add(TLeft left, TRight right);
    public void Clear();
    public bool ContainsLeft(TLeft left);
    public bool ContainsRight(TRight right);
    public TLeft GetLeftByRight(TRight right);
    public TRight GetRightByLeft(TLeft left);
    public void RemoveLeft(TLeft left);
    public void RemoveMapping(TLeft left, TRight right);
    public void RemoveRight(TRight right);
    public void SetMapping(TLeft left, TRight right, bool bIgnoreConflicts);
    private static ArgumentException CreateDuplicateRightKeysException(TLeft left, TRight right, TLeft oldLeft);
    private static ArgumentException CreateDuplicateLeftKeysException(TLeft left, TRight right, TRight oldRight);
    public bool TryGetLeftByRight(TRight right, TLeft& left);
    public bool TryGetRightByLeft(TLeft left, TRight& right);
    public TLeft GetOrCreateLeftByRight(TRight right, Func`2<TRight, TLeft> factory);
    public TRight GetOrCreateRightByLeft(TLeft left, Func`2<TLeft, TRight> factory);
    public sealed virtual IEnumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<KeyValuePair`2<TLeft, TRight>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TLeft,TRight>>.GetEnumerator();
}
public static class JetBrains.Util.BinarySerializers : object {
    public static Dictionary`2<string, string> ReadStringDictionary(UnsafeReader reader);
    public static void WriteStringOneToList(UnsafeWriter writer, CompactOneToListMap`2<string, string> map);
    public static CompactOneToListMap`2<string, string> ReadStringOneToList(UnsafeReader reader);
    public static void WriteNullCollection(UnsafeWriter writer);
    public static void WriteStringDictionary(UnsafeWriter writer, IDictionary`2<string, string> dict);
    public static void WriteStringCollection(UnsafeWriter writer, ICollection`1<string> strings);
    public static String[] ReadStringCollection(UnsafeReader reader);
}
[ExtensionAttribute]
public static class JetBrains.Util.BinaryStreamEx : object {
    [ExtensionAttribute]
public static UInt32 ReadCompressedUInt32(BinaryReader reader);
    [ExtensionAttribute]
public static void WriteCompressedUInt32(BinaryWriter writer, UInt32 value);
    [ExtensionAttribute]
public static void WriteCompressedInt32(BinaryWriter writer, int value);
    [ExtensionAttribute]
public static int ReadCompressedInt32(BinaryReader reader);
}
public class JetBrains.Util.BitArrayUtil : object {
    public static BitArray FromSet(short count, Int16[] values);
    public static Boolean[] BoolArrayFromSet(short count, Int16[] values);
}
public static class JetBrains.Util.BitHacks : object {
    private static Int32[] Log2Lookup;
    private static BitHacks();
    public static int Log2(int x);
    public static int NumberOfBitSet(int x);
}
public class JetBrains.Util.BitsIncreasedHandler : MulticastDelegate {
    public BitsIncreasedHandler(object object, IntPtr method);
    public virtual void Invoke(int oldBitsCount, int newBitsCount);
    public virtual IAsyncResult BeginInvoke(int oldBitsCount, int newBitsCount, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public static class JetBrains.Util.BooleanBoxes : object {
    [NotNullAttribute]
public static object True;
    [NotNullAttribute]
public static object False;
    private static BooleanBoxes();
}
public static class JetBrains.Util.Build.BuildConstants : object {
    public static Regex ExcludedSystemAssembliesNameRegex;
    private static BuildConstants();
}
[ExtensionAttribute]
public static class JetBrains.Util.BuildExtensions : object {
    [NotNullAttribute]
[ExtensionAttribute]
public static string GetAssemblyCustomBuildProperty_SemanticVersion(Assembly assembly);
    [NotNullAttribute]
[ExtensionAttribute]
public static string GetAssemblyCustomBuildProperty_WaveMarketingName(Assembly assembly);
    [NotNullAttribute]
[ExtensionAttribute]
public static string GetAssemblyCustomBuildProperty_WaveMarketingNameCompressed(Assembly assembly);
    [ExtensionAttribute]
public static DateTime GetAssemblyCustomBuildProperty_BuildDate(Assembly assembly);
    [ExtensionAttribute]
[NotNullAttribute]
private static string GetAssemblyCustomBuildProperty(Assembly assembly, string key);
}
public class JetBrains.Util.ByteArrayIcon : object {
    private Byte[] myIconBytes;
    private Icon myIcon;
    public Icon Icon { get; }
    public Byte[] ByteArray { get; }
    public ByteArrayIcon(Byte[] iconBytes);
    public ByteArrayIcon(Stream iconBytes);
    public Icon get_Icon();
    public Byte[] get_ByteArray();
    [ObsoleteAttribute("This method leads to icon convertion")]
public static ByteArrayIcon FromIcon(Icon icon);
    public static Icon op_Implicit(ByteArrayIcon byteArrayIcon);
    public static Byte[] op_Implicit(ByteArrayIcon byteArrayIcon);
    public static ByteArrayIcon op_Explicit(Byte[] byteArrayIcon);
    public void Save(Stream stream);
}
public class JetBrains.Util.CachedFileSystemData : object {
    private DateTime myLastWriteTimeUtc;
    private FileAttributes myFileAttributes;
    private bool myFileExists;
    private long myFileLength;
    [CompilerGeneratedAttribute]
private bool <ExceptionIsFiredOnLastLoad>k__BackingField;
    public bool ExceptionIsFiredOnLastLoad { get; private set; }
    public DateTime LastWriteTimeUtc { get; public set; }
    public FileAttributes FileAttributes { get; public set; }
    public bool FileExists { get; public set; }
    public long FileLength { get; public set; }
    public CachedFileSystemData(FileSystemPath location);
    [CompilerGeneratedAttribute]
public bool get_ExceptionIsFiredOnLastLoad();
    [CompilerGeneratedAttribute]
private void set_ExceptionIsFiredOnLastLoad(bool value);
    public DateTime get_LastWriteTimeUtc();
    public void set_LastWriteTimeUtc(DateTime value);
    public FileAttributes get_FileAttributes();
    public void set_FileAttributes(FileAttributes value);
    public bool get_FileExists();
    public void set_FileExists(bool value);
    public long get_FileLength();
    public void set_FileLength(long value);
    public void Load(FileSystemPath path);
}
[ObsoleteAttribute("No usages in ReSharper")]
public class JetBrains.Util.CollectionAdapter`1 : object {
    private ICollection`1<T> myGenericCollection;
    private object mySentry;
    public int Count { get; }
    public object SyncRoot { get; }
    public bool IsSynchronized { get; }
    public CollectionAdapter`1(ICollection`1<T> genericcollection);
    public sealed virtual void CopyTo(Array array, int index);
    public sealed virtual int get_Count();
    public sealed virtual object get_SyncRoot();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual IEnumerator GetEnumerator();
}
public class JetBrains.Util.Collections.AlphanumComparatorFast : object {
    public static IComparer`1<string> Instance;
    private static AlphanumComparatorFast();
    public sealed virtual int Compare(string s1, string s2);
}
[ObsoleteAttribute("No usages in ReSharper")]
public class JetBrains.Util.Collections.ComparisonListSorter`1 : object {
    [NotNullAttribute]
private Comparison`1<T> myComparison;
    public ComparisonListSorter`1(Comparison`1<T> comparison);
    public sealed virtual T[] Sort(List`1<T> list);
}
[ThreadUnsafeAttribute]
[DefaultMemberAttribute("Item")]
public class JetBrains.Util.Collections.CountingMultiMap`2 : object {
    private Dictionary`2<TKey, CountingSet`1<TValue>> myMap;
    public IEnumerable`1<TValue> Item { get; }
    public ICollection`1<TKey> Keys { get; }
    public CountingMultiMap`2(int capacity);
    public CountingMultiMap`2(int capacity, IEqualityComparer`1<TKey> comparer);
    private CountingMultiMap`2(Dictionary`2<TKey, CountingSet`1<TValue>> map);
    public int Add(TKey key, TValue value);
    public int Remove(TKey key, TValue value);
    public void Clear();
    public IEnumerable`1<TValue> get_Item(TKey key);
    public ICollection`1<TKey> get_Keys();
}
[ThreadUnsafeAttribute]
public class JetBrains.Util.Collections.CountingSet`1 : object {
    private HashMap`2<T, int> mySet;
    public int Count { get; }
    public CountingSet`1(int capacity);
    public CountingSet`1(int capacity, IEqualityComparer`1<T> comparer);
    public CountingSet`1(CountingSet`1<T> set);
    private CountingSet`1(HashMap`2<T, int> set);
    public int Add(T item);
    public int Add(T item, int cnt);
    public T Intern(T item);
    public int Remove(T item);
    public void Clear();
    public int GetCount(T item);
    public bool Contains(T item);
    public IEnumerable`1<T> GetItems();
    public PairEnumerator<T, int> GetEnumerator();
    private sealed virtual override IEnumerator`1<KeyValuePair`2<T, int>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<T,System.Int32>>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public int get_Count();
}
public class JetBrains.Util.Collections.EnumerableCollection`1 : object {
    [NotNullAttribute]
public static ICollection`1<T> Empty;
    [NotNullAttribute]
private IEnumerable`1<T> myEnumerable;
    private int myCount;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public EnumerableCollection`1(IEnumerable`1<T> enumerable, int count);
    private static EnumerableCollection`1();
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual bool Remove(T item);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[ExtensionAttribute]
public static class JetBrains.Util.Collections.EnumeratorExt : object {
    [ExtensionAttribute]
public static bool AnyElem(TEnumerator source);
    [ExtensionAttribute]
public static bool CountEq(TEnumerator source, int expectedCount);
    [ExtensionAttribute]
public static bool CountLeq(TEnumerator source, int expectedCount);
    [ExtensionAttribute]
public static IEnumeratorWithEnd`1<T> WithEnd(IEnumerator`1<T> src);
}
public static class JetBrains.Util.Collections.EqualityComparer : object {
    [NotNullAttribute]
[PureAttribute]
public static IEqualityComparer`1<T> Create(Func`3<T, T, bool> equals, Func`2<T, int> getHashCode);
    [NotNullAttribute]
[PureAttribute]
public static IEqualityComparer`1<TSource> Create(Func`2<TSource, TKey> keySelector, IEqualityComparer`1<TKey> keyEqualityComparer);
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Util.Collections.Fixed.Bunch16`1 : ValueType {
    private T myItem0;
    private T myItem1;
    private T myItem2;
    private T myItem3;
    private T myItem4;
    private T myItem5;
    private T myItem6;
    private T myItem7;
    private T myItem8;
    private T myItem9;
    private T myItem10;
    private T myItem11;
    private T myItem12;
    private T myItem13;
    private T myItem14;
    private T myItem15;
    public int Length { get; }
    public T Item { get; public set; }
    public int get_Length();
    public T get_Item(int index);
    public void set_Item(int index, T value);
    public Enumerator<T> GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Util.Collections.Fixed.Bunch32`1 : ValueType {
    private T myItem0;
    private T myItem1;
    private T myItem2;
    private T myItem3;
    private T myItem4;
    private T myItem5;
    private T myItem6;
    private T myItem7;
    private T myItem8;
    private T myItem9;
    private T myItem10;
    private T myItem11;
    private T myItem12;
    private T myItem13;
    private T myItem14;
    private T myItem15;
    private T myItem16;
    private T myItem17;
    private T myItem18;
    private T myItem19;
    private T myItem20;
    private T myItem21;
    private T myItem22;
    private T myItem23;
    private T myItem24;
    private T myItem25;
    private T myItem26;
    private T myItem27;
    private T myItem28;
    private T myItem29;
    private T myItem30;
    private T myItem31;
    public int Length { get; }
    public T Item { get; public set; }
    public int get_Length();
    public T get_Item(int index);
    public void set_Item(int index, T value);
    public Enumerator<T> GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Util.Collections.Fixed.Bunch4`1 : ValueType {
    private T myItem0;
    private T myItem1;
    private T myItem2;
    private T myItem3;
    public int Length { get; }
    public T Item { get; public set; }
    public int get_Length();
    public T get_Item(int index);
    public void set_Item(int index, T value);
    public Enumerator<T> GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Util.Collections.Fixed.Bunch64`1 : ValueType {
    private T myItem0;
    private T myItem1;
    private T myItem2;
    private T myItem3;
    private T myItem4;
    private T myItem5;
    private T myItem6;
    private T myItem7;
    private T myItem8;
    private T myItem9;
    private T myItem10;
    private T myItem11;
    private T myItem12;
    private T myItem13;
    private T myItem14;
    private T myItem15;
    private T myItem16;
    private T myItem17;
    private T myItem18;
    private T myItem19;
    private T myItem20;
    private T myItem21;
    private T myItem22;
    private T myItem23;
    private T myItem24;
    private T myItem25;
    private T myItem26;
    private T myItem27;
    private T myItem28;
    private T myItem29;
    private T myItem30;
    private T myItem31;
    private T myItem32;
    private T myItem33;
    private T myItem34;
    private T myItem35;
    private T myItem36;
    private T myItem37;
    private T myItem38;
    private T myItem39;
    private T myItem40;
    private T myItem41;
    private T myItem42;
    private T myItem43;
    private T myItem44;
    private T myItem45;
    private T myItem46;
    private T myItem47;
    private T myItem48;
    private T myItem49;
    private T myItem50;
    private T myItem51;
    private T myItem52;
    private T myItem53;
    private T myItem54;
    private T myItem55;
    private T myItem56;
    private T myItem57;
    private T myItem58;
    private T myItem59;
    private T myItem60;
    private T myItem61;
    private T myItem62;
    private T myItem63;
    public int Length { get; }
    public T Item { get; public set; }
    public int get_Length();
    public T get_Item(int index);
    public void set_Item(int index, T value);
    public Enumerator<T> GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Util.Collections.Fixed.Bunch8`1 : ValueType {
    private T myItem0;
    private T myItem1;
    private T myItem2;
    private T myItem3;
    private T myItem4;
    private T myItem5;
    private T myItem6;
    private T myItem7;
    public int Length { get; }
    public T Item { get; public set; }
    public int get_Length();
    public T get_Item(int index);
    public void set_Item(int index, T value);
    public Enumerator<T> GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Util.Collections.Fixed.List16`1 : ValueType {
    private static int MaxIndex;
    private Bunch16`1<T> myInnerArray;
    private int myCount;
    private int LastItemIndex { get; }
    public T Item { get; public set; }
    public int Count { get; }
    public int Capacity { get; }
    private int get_LastItemIndex();
    public T get_Item(int index);
    public void set_Item(int index, T value);
    public int get_Count();
    public int get_Capacity();
    public void Add(T item);
    public void Insert(int index, T item);
    public void RemoveAt(int index);
    public void Clear();
    public Enumerator<T> GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Util.Collections.Fixed.List32`1 : ValueType {
    private static int MaxIndex;
    private Bunch32`1<T> myInnerArray;
    private int myCount;
    private int LastItemIndex { get; }
    public T Item { get; public set; }
    public int Count { get; }
    public int Capacity { get; }
    private int get_LastItemIndex();
    public T get_Item(int index);
    public void set_Item(int index, T value);
    public int get_Count();
    public int get_Capacity();
    public void Add(T item);
    public void Insert(int index, T item);
    public void RemoveAt(int index);
    public void Clear();
    public Enumerator<T> GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Util.Collections.Fixed.List4`1 : ValueType {
    private static int MaxIndex;
    private Bunch4`1<T> myInnerArray;
    private int myCount;
    private int LastItemIndex { get; }
    public T Item { get; public set; }
    public int Count { get; }
    public int Capacity { get; }
    private int get_LastItemIndex();
    public T get_Item(int index);
    public void set_Item(int index, T value);
    public int get_Count();
    public int get_Capacity();
    public void Add(T item);
    public void Insert(int index, T item);
    public void RemoveAt(int index);
    public void Clear();
    public Enumerator<T> GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Util.Collections.Fixed.List64`1 : ValueType {
    private static int MaxIndex;
    private Bunch64`1<T> myInnerArray;
    private int myCount;
    private int LastItemIndex { get; }
    public T Item { get; public set; }
    public int Count { get; }
    public int Capacity { get; }
    private int get_LastItemIndex();
    public T get_Item(int index);
    public void set_Item(int index, T value);
    public int get_Count();
    public int get_Capacity();
    public void Add(T item);
    public void Insert(int index, T item);
    public void RemoveAt(int index);
    public void Clear();
    public Enumerator<T> GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Util.Collections.Fixed.List8`1 : ValueType {
    private static int MaxIndex;
    private Bunch8`1<T> myInnerArray;
    private int myCount;
    private int LastItemIndex { get; }
    public T Item { get; public set; }
    public int Count { get; }
    public int Capacity { get; }
    private int get_LastItemIndex();
    public T get_Item(int index);
    public void set_Item(int index, T value);
    public int get_Count();
    public int get_Capacity();
    public void Add(T item);
    public void Insert(int index, T item);
    public void RemoveAt(int index);
    public void Clear();
    public Enumerator<T> GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class JetBrains.Util.Collections.Fixed.OutOfCapacityException : Exception {
    public OutOfCapacityException(string message, Exception innerException);
    public OutOfCapacityException(string message);
}
[ObsoleteAttribute("No usages in ReSharper")]
public interface JetBrains.Util.Collections.IListSorter`1 {
    public abstract virtual T[] Sort(List`1<T> list);
}
[FlagsAttribute]
public enum JetBrains.Util.Collections.JetBinaryTree.AdvancedMatchingResults : Enum {
    public int value__;
    public static AdvancedMatchingResults NoAction;
    public static AdvancedMatchingResults Match;
    public static AdvancedMatchingResults VisitLeft;
    public static AdvancedMatchingResults VisitRight;
}
public enum JetBrains.Util.Collections.JetBinaryTree.FindStrategy : Enum {
    public int value__;
    public static FindStrategy Exactly;
    public static FindStrategy NearestBelow;
    public static FindStrategy NearestAbove;
}
[ThreadUnsafeAttribute]
public class JetBrains.Util.Collections.JetBinaryTree.JetBinaryTree`2 : object {
    private IComparer`1<TKeyType> myComparer;
    private JetBinaryTreeNode`2<TKeyType, TDataType> myJetBinaryTreeTree;
    private int myCount;
    private JetBinaryTreeNode`2<TKeyType, TDataType> mySentinelNode;
    private JetBinaryTreeNode`2<TKeyType, TDataType> myLastNodeFound;
    public int Size { get; }
    public JetBinaryTree`2(IComparer`1<TKeyType> comparer);
    protected JetBinaryTree`2(JetBinaryTree`2<TKeyType, TDataType> copyFrom);
    public int get_Size();
    public void Clear();
    public bool IsEmpty();
    public void RemoveMin();
    public void RemoveMax();
    public TKeyType GetMinKey();
    private JetBinaryTreeNode`2<TKeyType, TDataType> GetMinNode();
    public TKeyType GetMaxKey();
    public JetBinaryTreeNode`2<TKeyType, TDataType> GetMaxNode();
    public TDataType GetMinValue();
    public TDataType GetMaxValue();
    public JetBinaryTreeNode`2<TKeyType, TDataType> GetNode(TKeyType key);
    public TDataType GetData(TKeyType key);
    private IEnumerable`1<TDataType> IterateTree(Func`2<TKeyType, AdvancedMatchingResults> comparer, JetBinaryTreeNode`2<TKeyType, TDataType> treeNode);
    public IEnumerable`1<TDataType> FindData(Func`2<TKeyType, AdvancedMatchingResults> comparer);
    public TDataType FindData(TKeyType key, FindStrategy strategy, TDataType defaultData, IComparer`1<TKeyType> comparer);
    public void InplaceReplace(TKeyType oldKey, TKeyType newKey, TDataType newData);
    public void Add(TKeyType key, TDataType data);
    protected void RotateLeft(JetBinaryTreeNode`2<TKeyType, TDataType> x);
    protected void RotateRight(JetBinaryTreeNode`2<TKeyType, TDataType> x);
    public void Remove(TKeyType key);
    public IEnumerable`1<JetBinaryTreeNode`2<TKeyType, TDataType>> Nodes(bool ascending);
    public IEnumerable`1<Pair`2<TKeyType, TDataType>> Pairs(bool ascending);
    public IEnumerable`1<TKeyType> Keys(bool ascending);
    public IEnumerable`1<TDataType> Values(bool ascending);
    public sealed virtual IEnumerator`1<Pair`2<TKeyType, TDataType>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private JetBinaryTreeEnumerator`2<TKeyType, TDataType> Elements(bool ascending);
    private void RestoreAfterInsert(JetBinaryTreeNode`2<TKeyType, TDataType> x);
    private void RestoreAfterDelete(JetBinaryTreeNode`2<TKeyType, TDataType> x);
    private void Delete(JetBinaryTreeNode`2<TKeyType, TDataType> node);
    private JetBinaryTreeNode`2<TKeyType, TDataType> CloneNode(JetBinaryTreeNode`2<TKeyType, TDataType> treeNode, JetBinaryTree`2<TKeyType, TDataType> targetTree, JetBinaryTreeNode`2<TKeyType, TDataType> targetParent);
    public sealed virtual JetBinaryTree`2<TKeyType, TDataType> Clone();
    private sealed virtual override object System.ICloneable.Clone();
}
public class JetBrains.Util.Collections.JetBinaryTree.JetBinaryTreeEnumerator`2 : object {
    private bool myAscending;
    private JetBinaryTreeNode`2<TKeyType, TDataType> mySentinelNode;
    private Stack`1<JetBinaryTreeNode`2<TKeyType, TDataType>> myStack;
    [CompilerGeneratedAttribute]
private TKeyType <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private TDataType <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private JetBinaryTreeNode`2<TKeyType, TDataType> <Node>k__BackingField;
    public TKeyType Key { get; public set; }
    public TDataType Value { get; public set; }
    public JetBinaryTreeNode`2<TKeyType, TDataType> Node { get; public set; }
    public JetBinaryTreeEnumerator`2(JetBinaryTreeNode`2<TKeyType, TDataType> node, bool ascending, JetBinaryTreeNode`2<TKeyType, TDataType> sentinelNode);
    [CompilerGeneratedAttribute]
public TKeyType get_Key();
    [CompilerGeneratedAttribute]
public void set_Key(TKeyType value);
    [CompilerGeneratedAttribute]
public TDataType get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(TDataType value);
    [CompilerGeneratedAttribute]
public JetBinaryTreeNode`2<TKeyType, TDataType> get_Node();
    [CompilerGeneratedAttribute]
public void set_Node(JetBinaryTreeNode`2<TKeyType, TDataType> value);
    private void InsertNewNode(JetBinaryTreeNode`2<TKeyType, TDataType> node);
    public TDataType NextElement();
    public bool HasMoreElements();
    public bool MoveNext();
}
public class JetBrains.Util.Collections.JetBinaryTree.JetBinaryTreeException : Exception {
    public JetBinaryTreeException(string message);
}
public class JetBrains.Util.Collections.JetBinaryTree.JetBinaryTreeNode`2 : object {
    [CompilerGeneratedAttribute]
private NodeColor <Color>k__BackingField;
    [CompilerGeneratedAttribute]
private JetBinaryTreeNode`2<TKeyType, TDataType> <Left>k__BackingField;
    [CompilerGeneratedAttribute]
private JetBinaryTreeNode`2<TKeyType, TDataType> <Right>k__BackingField;
    [CompilerGeneratedAttribute]
private JetBinaryTreeNode`2<TKeyType, TDataType> <Parent>k__BackingField;
    [CompilerGeneratedAttribute]
private TKeyType <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private TDataType <Data>k__BackingField;
    public NodeColor Color { get; public set; }
    public JetBinaryTreeNode`2<TKeyType, TDataType> Left { get; public set; }
    public JetBinaryTreeNode`2<TKeyType, TDataType> Right { get; public set; }
    public JetBinaryTreeNode`2<TKeyType, TDataType> Parent { get; public set; }
    public TKeyType Key { get; public set; }
    public TDataType Data { get; public set; }
    [CompilerGeneratedAttribute]
public NodeColor get_Color();
    [CompilerGeneratedAttribute]
public void set_Color(NodeColor value);
    [CompilerGeneratedAttribute]
public JetBinaryTreeNode`2<TKeyType, TDataType> get_Left();
    [CompilerGeneratedAttribute]
public void set_Left(JetBinaryTreeNode`2<TKeyType, TDataType> value);
    [CompilerGeneratedAttribute]
public JetBinaryTreeNode`2<TKeyType, TDataType> get_Right();
    [CompilerGeneratedAttribute]
public void set_Right(JetBinaryTreeNode`2<TKeyType, TDataType> value);
    [CompilerGeneratedAttribute]
public JetBinaryTreeNode`2<TKeyType, TDataType> get_Parent();
    [CompilerGeneratedAttribute]
public void set_Parent(JetBinaryTreeNode`2<TKeyType, TDataType> value);
    [CompilerGeneratedAttribute]
public TKeyType get_Key();
    [CompilerGeneratedAttribute]
public void set_Key(TKeyType value);
    [CompilerGeneratedAttribute]
public TDataType get_Data();
    [CompilerGeneratedAttribute]
public void set_Data(TDataType value);
}
public enum JetBrains.Util.Collections.JetBinaryTree.NodeColor : Enum {
    public int value__;
    public static NodeColor Red;
    public static NodeColor Black;
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Util.Collections.JetBitArray : object {
    private static int SlotSizeInBytes;
    private static int SlotSizeInBits;
    private int myFlagsCapacity;
    private Int32[] myInnerArray;
    private int mySetFlagsCount;
    public int Size { get; }
    public int Length { get; }
    public int Count { get; }
    public bool Item { get; public set; }
    public JetBitArray(int length);
    public int get_Size();
    public int get_Length();
    public int get_Count();
    public bool get_Item(int index);
    public void set_Item(int index, bool value);
    public bool Set(int index, bool value);
    public Enumerator GetEnumerator();
    public void Clear();
    private sealed virtual override IEnumerator`1<int> System.Collections.Generic.IEnumerable<System.Int32>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class JetBrains.Util.Collections.LimitedDictionary`2 : object {
    private ConcurrentDictionary`2<TKey, TValue> myItems;
    private ConcurrentQueue`1<TKey> myRecentItems;
    private int myCount;
    private int myMaxCount;
    public LimitedDictionary`2(int maxCount);
    public TValue GetItemWithCache(TKey key, Func`2<TKey, TValue> eval);
}
public class JetBrains.Util.Collections.MultiTypeEqualityComparer : object {
    private List`1<TypeComparer> myTypeComparers;
    private Dictionary`2<Type, TypeComparer> myCachedComparers;
    public void RegisterComparer(IEqualityComparer`1<object> a);
    public void RegisterComparer(Func`2<object, bool> isApplicable, IEqualityComparer`1<object> equalityComparer);
    private sealed virtual override bool System.Collections.Generic.IEqualityComparer<System.Object>.Equals(object x, object y);
    [NotNullAttribute]
private TypeComparer GetComparer(Type xtype, object obj);
    public sealed virtual int GetHashCode(object obj);
    [CompilerGeneratedAttribute]
private static bool <RegisterComparer>b__0(object f);
}
public class JetBrains.Util.Collections.ObjectPool`1 : object {
    private int myMaxObjectsCount;
    private Func`1<T> myCreateObject;
    private object myQueueAccess;
    private Queue`1<T> myQueue;
    private object myObjectsCountAccess;
    private int myObjectsCount;
    [CompilerGeneratedAttribute]
private static Func`1<T> CS$<>9__CachedAnonymousMethodDelegate1;
    public ObjectPool`1(IReadOnlyCollection`1<T> initialPool);
    public ObjectPool`1(Func`1<T> createObject);
    public ObjectPool`1(Func`1<T> createObject, IEnumerable`1<T> initialPool);
    public ObjectPool`1(Func`1<T> createObject, int maxObjectsCount);
    public ObjectPool`1(Func`1<T> createObject, IEnumerable`1<T> initialPool, int maxObjectsCount);
    public T GetObject(Lifetime lifetime);
    public T GetObject();
    public T CreateAndGetObject(Lifetime lifetime);
    public void AddObjectToPool(T object);
    private T CreateNewObject();
    private void IncreaseObjectsCount();
    private void HangEntityOnLifetime(Lifetime lifetime, T entity);
    public void ReturnObject(T object);
    private static int GetInitialPoolSize(IReadOnlyCollection`1<T> initialPool);
    [CompilerGeneratedAttribute]
private static T <.ctor>b__0();
}
public class JetBrains.Util.Collections.PartialSorter : object {
    public static IEnumerable`1<T> Sort(IList`1<T> arr, Func`3<T, T, int> comparer);
    private static IEnumerable`1<T> Sort(IList`1<T> arr, int left, int right, Func`3<T, T, int> comparer);
    private static void Swap(IList`1<T> arr, int i, int j);
    private static int Partition(IList`1<T> arr, int low, int high, Func`3<T, T, int> comparer);
}
[ExtensionAttribute]
public static class JetBrains.Util.Collections.TimeExtensions : object {
    [ExtensionAttribute]
public static TimeSpan Day(double value);
    [ExtensionAttribute]
public static TimeSpan Days(double value);
    [ExtensionAttribute]
public static TimeSpan Hour(double value);
    [ExtensionAttribute]
public static TimeSpan Hours(double value);
    [ExtensionAttribute]
public static TimeSpan Minute(double value);
    [ExtensionAttribute]
public static TimeSpan Minutes(double value);
    [ExtensionAttribute]
public static TimeSpan Second(double value);
    [ExtensionAttribute]
public static TimeSpan Seconds(double value);
    [ExtensionAttribute]
public static TimeSpan Milliseconds(double value);
    [ExtensionAttribute]
public static TimeSpan Day(int value);
    [ExtensionAttribute]
public static TimeSpan Days(int value);
    [ExtensionAttribute]
public static TimeSpan Hour(int value);
    [ExtensionAttribute]
public static TimeSpan Hours(int value);
    [ExtensionAttribute]
public static TimeSpan Minute(int value);
    [ExtensionAttribute]
public static TimeSpan Minutes(int value);
    [ExtensionAttribute]
public static TimeSpan Second(int value);
    [ExtensionAttribute]
public static TimeSpan Seconds(int value);
    [ExtensionAttribute]
public static TimeSpan Milliseconds(int value);
    [ExtensionAttribute]
public static DateTime Ago(TimeSpan value);
    [ExtensionAttribute]
public static DateTime Hence(TimeSpan value);
    [ExtensionAttribute]
public static DateTime Before(TimeSpan value, DateTime date);
    [ExtensionAttribute]
public static DateTime After(TimeSpan value, DateTime date);
}
public static class JetBrains.Util.Collections.WeakCollectionsManager : object {
    public static Statistics Statistics;
    private static WeakCollectionsManager();
}
[ExtensionAttribute]
public static class JetBrains.Util.CollectionValidator : object {
    [ExtensionAttribute]
[NotNullAttribute]
public static ListEvents`1<TValue> EnsureReadonly(ListEvents`1<TValue> ths, ReadonlyToken token);
    [NotNullAttribute]
[ExtensionAttribute]
public static ListEvents`1<TValue> EnsureReadonly(ListEvents`1<TValue> ths, Lifetime lifetime, ReadonlyToken token);
    [NotNullAttribute]
[ExtensionAttribute]
public static ListEvents`1<TItem> EnsureThisThread(ListEvents`1<TItem> ths);
    [ExtensionAttribute]
[NotNullAttribute]
public static ListEvents`1<TItem> EnsureThisThread(ListEvents`1<TItem> ths, Lifetime lifetime);
}
public static class JetBrains.Util.ColorParsing : object {
    private static Dictionary`2<string, UInt32> NamedColors;
    private static ColorParsing();
    public static Nullable`1<Color> GetNamedColor(string name);
    [CanBeNullAttribute]
public static string GetColorName(Color color);
    public static Nullable`1<Color> FromHexOrNamed(string color);
    public static Nullable`1<Color> GetColorFromHexString(string hexFormattedColor);
    public static Nullable`1<Color> GetColorFromHexString(string hexFormattedColor, bool allowThreeDigitsFormat);
    public static Color ToColor(UInt32 color);
    public static UInt32 ToUint(Color color);
    public static UInt32 ToUint(double a, double r, double g, double b);
    public static string Hex(Color rgbColor);
    public static string HexNoAlpha(Color rgbColor);
    public static string HexAlphaAndColor(Color rgbColor);
    public static string FindFirstColorNameOccurrence(string sentence);
}
public class JetBrains.Util.Colors.ColorAdjustment : object {
    private HumanPerceptibleColor myColor;
    private bool IsLight { get; }
    public ColorAdjustment(Color color);
    public ColorAdjustment(Color color);
    public ColorAdjustment Shade(double offset);
    public ColorAdjustment Lighter(double offset);
    public ColorAdjustment Darker(double offset);
    public ColorAdjustment Brightness(double brightness);
    public ColorAdjustment Brightness(Color brightness);
    public ColorAdjustment Brightness(Color brightness);
    public ColorAdjustment Lightest();
    public ColorAdjustment Darkest();
    public ColorAdjustment Saturate(double offset);
    public ColorAdjustment Desaturate(double offset);
    public ColorAdjustment Saturation(double saturation);
    public ColorAdjustment Saturation(Color saturation);
    public ColorAdjustment Saturation(Color saturation);
    public ColorAdjustment Tingle(double offset);
    public ColorAdjustment Tint(double hue);
    public ColorAdjustment Tint(Color hue);
    public ColorAdjustment Tint(Color hue);
    public ColorAdjustment Fade(double offset);
    public ColorAdjustment Opacity(double opacity);
    public ColorAdjustment Accent(Color accent, double strange);
    public ColorAdjustment Accent(Color accent, double strange);
    public ColorAdjustment Admix(Color other, double strange, bool affectAlpha);
    public ColorAdjustment Admix(Color other, double strange, bool affectAlpha);
    private static double Clamp(double value, double from, double to);
    private static bool IsInRange(double value, double from, double to, bool inclusive);
    private static void VerifyInRange(double value, double from, double to, bool inclusive);
    private bool get_IsLight();
    public static Color op_Implicit(ColorAdjustment adjustment);
    public static Color op_Implicit(ColorAdjustment adjustment);
    public Color ToColor();
}
[ExtensionAttribute]
public static class JetBrains.Util.Colors.ColorAdjustmentExtensions : object {
    [ExtensionAttribute]
public static ColorAdjustment Adjust(Color color);
    [ExtensionAttribute]
public static ColorAdjustment Adjust(Color color);
}
public static class JetBrains.Util.Colors.ColorManagement : object {
    private static float LumaRed;
    private static float LumaGreen;
    private static float LumaBlue;
    private static byte c_nMaxHLS;
    private static byte c_nMaxRGB;
    private static byte c_nUndefinedHue;
    public static byte MaxHLS { get; }
    public static byte MaxRGB { get; }
    public static byte UndefinedHue { get; }
    private static ColorManagement();
    public static byte get_MaxHLS();
    public static byte get_MaxRGB();
    public static byte get_UndefinedHue();
    public static void RGBtoHLS(UInt32 lRGBColor, Byte& H, Byte& L, Byte& S);
    public static ushort HueToRGB(ushort n1, ushort n2, ushort hue);
    public static void HLStoRGB(ushort H, ushort L, ushort S, Byte& R, Byte& G, Byte& B);
    public static Color HLStoRGB(ushort H, ushort L, ushort S);
    public static UInt32 HLStoBGR(ushort hue, ushort lum, ushort sat);
    public static UInt32 Mix(UInt32 colorA, UInt32 colorB, double fA);
    public static Color Mix(Color colorA, Color colorB, double proportion);
    public static Color Mix(Color colorA, Color colorB, double proportion);
    public static UInt32 RGB2BGR(UInt32 color);
    public static UInt32 BlendTwo(UInt32 rgbA, UInt32 rgbB);
    public static Color GetAlphaBlendedColor(Color src, Color dest, int alpha);
    public static byte GetRValue(UInt32 RGB);
    public static byte GetGValue(UInt32 RGB);
    public static byte GetBValue(UInt32 RGB);
    public static UInt32 RGB(byte R, byte G, byte B);
    public static UInt32 RGBA(byte A, byte R, byte G, byte B);
    public static UInt32 RGB(Color color);
    public static UInt32 RGB(Color color);
    public static UInt32 BGR(Color color);
    public static byte ConstrainHls(int value);
    public static Color GetContrastedForeground(Color background, Color foreground, double contrast, double margin, double whiteBalance);
    private static Color RangeColor(Color source, int rangeStart, int rangeEnd, int grayValue);
    public static Color MakeMonochrome(Color colorSrc, Color colorBias);
    public static Color MakeMonochrome(Color colorSrc, Color colorBias);
    public static BitmapSource MakeMonochrome(BitmapSource bmpSrc, Color colorBias);
    public static Color MakeSimilarColor(Color color, Color pattern, double threshold, double offset);
    public static Color Invert(Color color);
    public static Color GetSimilarForeground(Color foreground, Color goodForeground);
    public static Color GetDarkerColor(Color color, double value);
    public static Color GetLighterColor(Color color, double value);
    public static Color BlendColors(Color a, Color b, double proportion);
}
[ExtensionAttribute]
public static class JetBrains.Util.Colors.ColorsEx : object {
    [ExtensionAttribute]
public static Color ToAvalonColor(Color value);
    [ExtensionAttribute]
public static Color ToWinFormsColor(Color value);
    [ExtensionAttribute]
public static UInt32 RGB(Color color);
    [ExtensionAttribute]
public static UInt32 BGR(Color color);
    public static Nullable`1<Color> ParseWPFColor(string colorText);
    [ExtensionAttribute]
public static Color MixWith(Color first, Color second, float firstpercentage);
}
public class JetBrains.Util.Colors.ColorSpaces.CIELab : ValueType {
    public static CIELab Empty;
    private double l;
    private double a;
    private double b;
    public double L { get; public set; }
    public double A { get; public set; }
    public double B { get; public set; }
    public CIELab(double l, double a, double b);
    private static CIELab();
    public static bool op_Equality(CIELab item1, CIELab item2);
    public static bool op_Inequality(CIELab item1, CIELab item2);
    public double get_L();
    public void set_L(double value);
    public double get_A();
    public void set_A(double value);
    public double get_B();
    public void set_B(double value);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class JetBrains.Util.Colors.ColorSpaces.CIEXYZ : ValueType {
    public static CIEXYZ Empty;
    public static CIEXYZ D65;
    private double x;
    private double y;
    private double z;
    public double X { get; public set; }
    public double Y { get; public set; }
    public double Z { get; public set; }
    public CIEXYZ(double x, double y, double z);
    private static CIEXYZ();
    public static bool op_Equality(CIEXYZ item1, CIEXYZ item2);
    public static bool op_Inequality(CIEXYZ item1, CIEXYZ item2);
    public double get_X();
    public void set_X(double value);
    public double get_Y();
    public void set_Y(double value);
    public double get_Z();
    public void set_Z(double value);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class JetBrains.Util.Colors.ColorSpaces.CMYK : ValueType {
    public static CMYK Empty;
    private double c;
    private double m;
    private double y;
    private double k;
    public double Cyan { get; public set; }
    public double Magenta { get; public set; }
    public double Yellow { get; public set; }
    public double Black { get; public set; }
    public CMYK(double c, double m, double y, double k);
    private static CMYK();
    public static bool op_Equality(CMYK item1, CMYK item2);
    public static bool op_Inequality(CMYK item1, CMYK item2);
    public double get_Cyan();
    public void set_Cyan(double value);
    public double get_Magenta();
    public void set_Magenta(double value);
    public double get_Yellow();
    public void set_Yellow(double value);
    public double get_Black();
    public void set_Black(double value);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class JetBrains.Util.Colors.ColorSpaces.ColorSpace : object {
    public static double GetColorDistance(double r1, double g1, double b1, double r2, double g2, double b2);
    public static double GetColorDistance(Double[] color1, Double[] color2);
    public static double GetColorDistance(Color c1, Color c2);
    private static int GetIntFromHex(string strHex);
    [ObsoleteAttribute("A very oops method. Use smth more optimal.")]
public static Color HexToColor(string hexColor);
    public static string RGBToHex(int r, int g, int b);
    public static string RGBToHex(Color c);
    public static RGB HSBtoRGB(HSB hsb);
    public static RGB HSBtoRGB(double h, double s, double b);
    public static Color HSBtoColor(HSB hsb);
    public static Color HSBtoColor(double h, double s, double b);
    public static Color HSBtoColor(int h, int s, int b);
    public static HSL HSBtoHSL(double h, double s, double b);
    public static CMYK HSBtoCMYK(double h, double s, double b);
    public static YUV HSBtoYUV(double h, double s, double b);
    public static RGB HSLtoRGB(double h, double s, double l);
    public static RGB HSLtoRGB(HSL hsl);
    public static Color HSLtoColor(double h, double s, double l);
    public static Color HSLtoColor(HSL hsl);
    public static HSB HSLtoHSB(double h, double s, double l);
    public static CMYK HSLtoCMYK(double h, double s, double l);
    public static YUV HSLtoYUV(double h, double s, double l);
    public static HSL RGBtoHSL(int red, int green, int blue);
    public static HSL RGBtoHSL(RGB rgb);
    public static HSL RGBtoHSL(Color c);
    public static HSB RGBtoHSB(int red, int green, int blue);
    public static HSB RGBtoHSB(RGB rgb);
    public static HSB RGBtoHSB(Color c);
    public static CMYK RGBtoCMYK(int red, int green, int blue);
    public static CMYK RGBtoCMYK(Color c);
    public static CMYK RGBtoCMYK(RGB rgb);
    public static YUV RGBtoYUV(int red, int green, int blue);
    public static YUV RGBtoYUV(Color c);
    public static YUV RGBtoYUV(RGB rgb);
    public static CIEXYZ RGBtoXYZ(int red, int green, int blue);
    public static CIEXYZ RGBtoXYZ(RGB rgb);
    public static CIEXYZ RGBtoXYZ(Color c);
    public static CIELab RGBtoLab(int red, int green, int blue);
    public static CIELab RGBtoLab(RGB rgb);
    public static CIELab RGBtoLab(Color color);
    public static Color CMYKtoColor(float c, float m, float y, float k);
    public static Color CMYKtoColor(double c, double m, double y, double k);
    public static Color CMYKtoColor(CMYK cmyk);
    public static RGB CMYKtoRGB(double c, double m, double y, double k);
    public static RGB CMYKtoRGB(CMYK cmyk);
    public static HSL CMYKtoHSL(double c, double m, double y, double k);
    public static HSB CMYKtoHSB(double c, double m, double y, double k);
    public static YUV CMYKtoYUV(double c, double m, double y, double k);
    public static RGB YUVtoRGB(double y, double u, double v);
    public static RGB YUVtoRGB(YUV yuv);
    public static Color YUVtoColor(double y, double u, double v);
    public static Color YUVtoColor(YUV yuv);
    public static HSL YUVtoHSL(double y, double u, double v);
    public static HSB YUVtoHSB(double y, double u, double v);
    public static CMYK YUVtoCMYK(double y, double u, double v);
    public static RGB XYZtoRGB(double x, double y, double z);
    public static RGB XYZtoRGB(CIEXYZ xyz);
    private static double Fxyz(double t);
    public static CIELab XYZtoLab(double x, double y, double z);
    public static CIELab XYZtoLab(CIEXYZ xyz);
    public static CIEXYZ LabtoXYZ(double l, double a, double b);
    public static CIEXYZ LabtoXYZ(CIELab lab);
    public static RGB LabtoRGB(double l, double a, double b);
    public static RGB LabtoRGB(CIELab lab);
    public static Color RGBtoColor(RGB rGB);
}
public class JetBrains.Util.Colors.ColorSpaces.HSB : ValueType {
    public static HSB Empty;
    private double hue;
    private double saturation;
    private double brightness;
    [DescriptionAttribute("Hue component")]
public double Hue { get; public set; }
    [DescriptionAttribute("Saturation component")]
public double Saturation { get; public set; }
    [DescriptionAttribute("Brightness component")]
public double Brightness { get; public set; }
    public HSB(double h, double s, double b);
    private static HSB();
    public static bool op_Equality(HSB item1, HSB item2);
    public static bool op_Inequality(HSB item1, HSB item2);
    public double get_Hue();
    public void set_Hue(double value);
    public double get_Saturation();
    public void set_Saturation(double value);
    public double get_Brightness();
    public void set_Brightness(double value);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class JetBrains.Util.Colors.ColorSpaces.HSL : ValueType {
    public static HSL Empty;
    private double hue;
    private double saturation;
    private double luminance;
    [DescriptionAttribute("Hue component")]
public double Hue { get; public set; }
    [DescriptionAttribute("Saturation component")]
public double Saturation { get; public set; }
    [DescriptionAttribute("Luminance component")]
public double Luminance { get; public set; }
    public HSL(double h, double s, double l);
    private static HSL();
    public static bool op_Equality(HSL item1, HSL item2);
    public static bool op_Inequality(HSL item1, HSL item2);
    public double get_Hue();
    public void set_Hue(double value);
    public double get_Saturation();
    public void set_Saturation(double value);
    public double get_Luminance();
    public void set_Luminance(double value);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class JetBrains.Util.Colors.ColorSpaces.RGB : ValueType {
    public static RGB Empty;
    private int red;
    private int green;
    private int blue;
    [DescriptionAttribute("Red component.")]
public int Red { get; public set; }
    [DescriptionAttribute("Green component.")]
public int Green { get; public set; }
    [DescriptionAttribute("Blue component.")]
public int Blue { get; public set; }
    public RGB(int R, int G, int B);
    private static RGB();
    public static bool op_Equality(RGB item1, RGB item2);
    public static bool op_Inequality(RGB item1, RGB item2);
    public int get_Red();
    public void set_Red(int value);
    public int get_Green();
    public void set_Green(int value);
    public int get_Blue();
    public void set_Blue(int value);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class JetBrains.Util.Colors.ColorSpaces.YUV : ValueType {
    public static YUV Empty;
    private double y;
    private double u;
    private double v;
    public double Y { get; public set; }
    public double U { get; public set; }
    public double V { get; public set; }
    public YUV(double y, double u, double v);
    private static YUV();
    public static bool op_Equality(YUV item1, YUV item2);
    public static bool op_Inequality(YUV item1, YUV item2);
    public double get_Y();
    public void set_Y(double value);
    public double get_U();
    public void set_U(double value);
    public double get_V();
    public void set_V(double value);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[ObsoleteAttribute("Use structs from JetBrains.Util.Colors.ColorSpaces")]
public class JetBrains.Util.Colors.HslColor : ValueType {
    private double myH;
    private double myS;
    private double myL;
    public double H { get; public set; }
    public double S { get; public set; }
    public double L { get; public set; }
    public static HslColor FromRGB(Color rgb);
    public Color ToRgb();
    public double get_H();
    public void set_H(double value);
    public double get_S();
    public void set_S(double value);
    public double get_L();
    public void set_L(double value);
    public static Color HslToRgb(double alpha, double h, double s, double l);
    public static void RgbToHsl(Color rgbColor, Double& hue, Double& sat, Double& lum);
}
public class JetBrains.Util.Colors.HumanPerceptibleColor : ValueType {
    private static double Pr;
    private static double Pg;
    private static double Pb;
    private double myHue;
    private double mySaturation;
    private double myBrightness;
    private double myAlpha;
    public double Hue { get; public set; }
    public double Saturation { get; public set; }
    public double Brightness { get; public set; }
    public double Alpha { get; public set; }
    public HumanPerceptibleColor(double a, double h, double s, double b);
    public double get_Hue();
    public void set_Hue(double value);
    public double get_Saturation();
    public void set_Saturation(double value);
    public double get_Brightness();
    public void set_Brightness(double value);
    public double get_Alpha();
    public void set_Alpha(double value);
    public static HumanPerceptibleColor FromColor(Color color);
    public static HumanPerceptibleColor FromColor(Color color);
    public static HumanPerceptibleColor FromArgb(int a, int r, int g, int b);
    public static HumanPerceptibleColor FromArgb(double a, double r, double g, double b);
    public Color ToColor();
    public Double[] ToArgb();
    private static double Clamp(double value);
}
public class JetBrains.Util.CommandLineBuilderJet : object {
    private StringBuilder myStringBuilder;
    [NotNullAttribute]
public CommandLineBuilderJet AppendFileName(FileSystemPath path);
    [NotNullAttribute]
public CommandLineBuilderJet AppendFileName(RelativePath path);
    [NotNullAttribute]
public CommandLineBuilderJet AppendFileName(string path);
    [NotNullAttribute]
public CommandLineBuilderJet AppendFileNameIfNotNull(FileSystemPath path);
    [NotNullAttribute]
public CommandLineBuilderJet AppendFileNameIfNotNull(RelativePath path);
    [NotNullAttribute]
public CommandLineBuilderJet AppendFileNameIfNotNull(string fullpath);
    [NotNullAttribute]
public CommandLineBuilderJet AppendParameterWithQuoting(string parameter);
    [NotNullAttribute]
public CommandLineBuilderJet AppendSpaceIfNotEmpty();
    [NotNullAttribute]
public CommandLineBuilderJet AppendSwitch(string switchname);
    [NotNullAttribute]
public CommandLineBuilderJet AppendSwitchIfNotNull(string switchname, string parameter);
    [NotNullAttribute]
public CommandLineBuilderJet AppendSwitchIfNotNull(string switchname, FileSystemPath path);
    [NotNullAttribute]
public CommandLineBuilderJet AppendSwitchIfNotNull(string switchname, RelativePath path);
    [ContractAnnotationAttribute("value:null => null; notnull => notnull")]
public static string op_Implicit(CommandLineBuilderJet value);
    public virtual string ToString();
    [NotNullAttribute]
private CommandLineBuilderJet AppendTextUnquotedRaw(string switchname);
    [NotNullAttribute]
private CommandLineBuilderJet AppendTextWithQuotingRaw(string parameter);
}
[AttributeUsageAttribute("256")]
[MeansImplicitUseAttribute]
public abstract class JetBrains.Util.CommandLineMapper.Attributes.AbstractGroupAttribute : AbstractMapperAttribute {
    [CompilerGeneratedAttribute]
private string <SymbolicName>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<Type> <KnownTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRequired>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HelpText>k__BackingField;
    [NotNullAttribute]
public string SymbolicName { get; private set; }
    public IReadOnlyList`1<Type> KnownTypes { get; private set; }
    public bool IsRequired { get; public set; }
    [CanBeNullAttribute]
public string HelpText { get; public set; }
    public bool IsMultipleAllowed { get; }
    [NotNullAttribute]
public Type GroupDefinitionAttributeType { get; }
    protected AbstractGroupAttribute(string symbolicName, Type knownType, Type[] otherKnownTypes);
    [CompilerGeneratedAttribute]
public string get_SymbolicName();
    [CompilerGeneratedAttribute]
private void set_SymbolicName(string value);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<Type> get_KnownTypes();
    [CompilerGeneratedAttribute]
private void set_KnownTypes(IReadOnlyList`1<Type> value);
    [CompilerGeneratedAttribute]
public bool get_IsRequired();
    [CompilerGeneratedAttribute]
public void set_IsRequired(bool value);
    [CompilerGeneratedAttribute]
public string get_HelpText();
    [CompilerGeneratedAttribute]
public void set_HelpText(string value);
    public virtual bool get_IsMultipleAllowed();
    public abstract virtual Type get_GroupDefinitionAttributeType();
    [NotNullAttribute]
public virtual IEnumerable`1<string> GetKnownGroupNames();
    [NotNullAttribute]
public virtual string GetGroupName(Type groupType);
    [CanBeNullAttribute]
public virtual KeyDefinition GetKeyDefinition();
    [NotNullAttribute]
public abstract virtual IEnumerable`1<Type> GetSuitableTypes(ICommandLineInternal commandLine);
}
[MeansImplicitUseAttribute]
[AttributeUsageAttribute("4")]
public abstract class JetBrains.Util.CommandLineMapper.Attributes.AbstractGroupDefinitionAttribute : AbstractMapperAttribute {
    private string myName;
    [CompilerGeneratedAttribute]
private string <HelpText>k__BackingField;
    public string Name { get; }
    public string HelpText { get; public set; }
    protected AbstractGroupDefinitionAttribute(string name);
    public string get_Name();
    [CompilerGeneratedAttribute]
public string get_HelpText();
    [CompilerGeneratedAttribute]
public void set_HelpText(string value);
    [NotNullAttribute]
public abstract virtual GroupSignature GetGroupSignature(Type type);
}
public abstract class JetBrains.Util.CommandLineMapper.Attributes.AbstractMapperAttribute : Attribute {
}
[MeansImplicitUseAttribute]
[AttributeUsageAttribute("384")]
public abstract class JetBrains.Util.CommandLineMapper.Attributes.AbstractOptionAttribute : AbstractMapperAttribute {
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private char <Shortcut>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NonKeyedIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsNonKeyedTail>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRequired>k__BackingField;
    [CompilerGeneratedAttribute]
private object <DefaultValue>k__BackingField;
    [CompilerGeneratedAttribute]
private object <EmptyValue>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Alias>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SymbolicValue>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HelpText>k__BackingField;
    [CompilerGeneratedAttribute]
private char <Separator>k__BackingField;
    public bool IsKeyed { get; }
    [CanBeNullAttribute]
public string Key { get; private set; }
    public char Shortcut { get; private set; }
    public int NonKeyedIndex { get; private set; }
    public bool IsNonKeyedTail { get; public set; }
    public bool IsRequired { get; public set; }
    public object DefaultValue { get; public set; }
    public object EmptyValue { get; public set; }
    [CanBeNullAttribute]
public string Alias { get; public set; }
    [NotNullAttribute]
public string SymbolicValue { get; public set; }
    [CanBeNullAttribute]
public string HelpText { get; public set; }
    public char Separator { get; public set; }
    [NotNullAttribute]
public Type ValueType { get; }
    [CanBeNullAttribute]
public Type MultiValueType { get; }
    protected AbstractOptionAttribute(string key, char shortcut, int nonKeyedIndex);
    protected AbstractOptionAttribute(string key);
    protected AbstractOptionAttribute(string key, char shortcut);
    protected AbstractOptionAttribute(char shortcut);
    protected AbstractOptionAttribute(int nonKeyedIndex, string symbolicValue);
    public bool get_IsKeyed();
    [CompilerGeneratedAttribute]
public string get_Key();
    [CompilerGeneratedAttribute]
private void set_Key(string value);
    [CompilerGeneratedAttribute]
public char get_Shortcut();
    [CompilerGeneratedAttribute]
private void set_Shortcut(char value);
    [CompilerGeneratedAttribute]
public int get_NonKeyedIndex();
    [CompilerGeneratedAttribute]
private void set_NonKeyedIndex(int value);
    [CompilerGeneratedAttribute]
public bool get_IsNonKeyedTail();
    [CompilerGeneratedAttribute]
public void set_IsNonKeyedTail(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsRequired();
    [CompilerGeneratedAttribute]
public void set_IsRequired(bool value);
    [CanBeNullAttribute]
[CompilerGeneratedAttribute]
public object get_DefaultValue();
    [CompilerGeneratedAttribute]
[NotNullAttribute]
public void set_DefaultValue(object value);
    [CompilerGeneratedAttribute]
[CanBeNullAttribute]
public object get_EmptyValue();
    [NotNullAttribute]
[CompilerGeneratedAttribute]
public void set_EmptyValue(object value);
    [CompilerGeneratedAttribute]
public string get_Alias();
    [CompilerGeneratedAttribute]
public void set_Alias(string value);
    [CompilerGeneratedAttribute]
public string get_SymbolicValue();
    [CompilerGeneratedAttribute]
public void set_SymbolicValue(string value);
    [CompilerGeneratedAttribute]
public string get_HelpText();
    [CompilerGeneratedAttribute]
public void set_HelpText(string value);
    [CompilerGeneratedAttribute]
public char get_Separator();
    [CompilerGeneratedAttribute]
public void set_Separator(char value);
    public abstract virtual Type get_ValueType();
    public virtual Type get_MultiValueType();
    [CanBeNullAttribute]
public virtual KeyDefinition GetKeyDefinition();
    [NotNullAttribute]
public IEnumerable`1<string> FormatValues(object value, bool forceDefaultValue);
    [CanBeNullAttribute]
protected virtual string FormatValue(object value);
    [CanBeNullAttribute]
public virtual object TryMap(ICommandLineInternal commandLine, Type type);
    [NotNullAttribute]
private IReadOnlyList`1<CommandLineArgument> GetMyArguments(ICommandLineInternal commandLine);
    [CanBeNullAttribute]
private object MapDefaultValue(Type type);
    [NotNullAttribute]
private object MapEmptyValue(Type type);
    [NotNullAttribute]
private object MapArguments(IReadOnlyList`1<CommandLineArgument> arguments, Type type);
    [NotNullAttribute]
protected abstract virtual object ConvertValue(string value, Type type);
    [CompilerGeneratedAttribute]
private object <MapDefaultValue>b__0(string x);
    [CompilerGeneratedAttribute]
private object <MapEmptyValue>b__1(string x);
    [CompilerGeneratedAttribute]
private object <MapArguments>b__2(string x);
}
[AttributeUsageAttribute("4")]
public class JetBrains.Util.CommandLineMapper.Attributes.AdvancedOptionsAttribute : AbstractMapperAttribute {
    private string mySymbolicName;
    [CompilerGeneratedAttribute]
private string <HelpText>k__BackingField;
    public string SymbolicName { get; }
    [CanBeNullAttribute]
public string HelpText { get; public set; }
    public AdvancedOptionsAttribute(string symbolicName);
    public string get_SymbolicName();
    [CompilerGeneratedAttribute]
public string get_HelpText();
    [CompilerGeneratedAttribute]
public void set_HelpText(string value);
}
[AttributeUsageAttribute("4")]
public class JetBrains.Util.CommandLineMapper.Attributes.AppNameAttribute : AbstractMapperAttribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; private set; }
    public AppNameAttribute(string nameWithoutExt);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
}
public class JetBrains.Util.CommandLineMapper.Attributes.BoolOptionAttribute : AbstractOptionAttribute {
    public bool DefaultValue { get; }
    public bool EmptyValue { get; }
    public Type ValueType { get; }
    public Type MultiValueType { get; }
    private BoolOptionAttribute(string key, char shortcut, int nonKeyedIndex);
    public BoolOptionAttribute(string key);
    public BoolOptionAttribute(string key, char shortcut);
    public BoolOptionAttribute(char shortcut);
    public bool get_DefaultValue();
    public bool get_EmptyValue();
    public virtual Type get_ValueType();
    public virtual Type get_MultiValueType();
    public virtual KeyDefinition GetKeyDefinition();
    protected virtual string FormatValue(object value);
    protected virtual object ConvertValue(string value, Type type);
}
public class JetBrains.Util.CommandLineMapper.Attributes.CommandDefinitionAttribute : AbstractGroupDefinitionAttribute {
    public CommandDefinitionAttribute(string name);
    public virtual GroupSignature GetGroupSignature(Type type);
}
public class JetBrains.Util.CommandLineMapper.Attributes.CommandGroupAttribute : AbstractGroupAttribute {
    [CompilerGeneratedAttribute]
private static Func`2<CommandLineArgument, string> CS$<>9__CachedAnonymousMethodDelegate3;
    public Type GroupDefinitionAttributeType { get; }
    public bool IsRequired { get; }
    public string HelpText { get; }
    public CommandGroupAttribute(Type knownType, Type[] otherKnownTypes);
    public virtual Type get_GroupDefinitionAttributeType();
    public bool get_IsRequired();
    public string get_HelpText();
    public virtual IEnumerable`1<Type> GetSuitableTypes(ICommandLineInternal commandLine);
    [CompilerGeneratedAttribute]
private static string <GetSuitableTypes>b__2(CommandLineArgument x);
}
public class JetBrains.Util.CommandLineMapper.Attributes.DirectoryOptionAttribute : AbstractOptionAttribute {
    [CompilerGeneratedAttribute]
private bool <MustExist>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <MustNotExist>k__BackingField;
    public bool MustExist { get; public set; }
    public bool MustNotExist { get; public set; }
    public Type ValueType { get; }
    private DirectoryOptionAttribute(string key, char shortcut, int nonKeyedIndex);
    public DirectoryOptionAttribute(string key);
    public DirectoryOptionAttribute(string key, char shortcut);
    public DirectoryOptionAttribute(char shortcut);
    public DirectoryOptionAttribute(int nonKeyedIndex, string symbolicName);
    [CompilerGeneratedAttribute]
public bool get_MustExist();
    [CompilerGeneratedAttribute]
public void set_MustExist(bool value);
    [CompilerGeneratedAttribute]
public bool get_MustNotExist();
    [CompilerGeneratedAttribute]
public void set_MustNotExist(bool value);
    public virtual Type get_ValueType();
    protected virtual object ConvertValue(string value, Type type);
}
public class JetBrains.Util.CommandLineMapper.Attributes.EnumOptionAttribute : AbstractOptionAttribute {
    private Type myEnumType;
    public Type ValueType { get; }
    private EnumOptionAttribute(string key, char shortcut, int nonKeyedIndex, Type enumType);
    public EnumOptionAttribute(string key, Type enumType);
    public EnumOptionAttribute(string key, char shortcut, Type enumType);
    public EnumOptionAttribute(char shortcut, Type enumType);
    public EnumOptionAttribute(int nonKeyedIndex, Type enumType);
    public virtual Type get_ValueType();
    protected virtual object ConvertValue(string value, Type type);
}
public class JetBrains.Util.CommandLineMapper.Attributes.FileOptionAttribute : AbstractOptionAttribute {
    [CompilerGeneratedAttribute]
private bool <MustExist>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <MustNotExist>k__BackingField;
    public bool MustExist { get; public set; }
    public bool MustNotExist { get; public set; }
    public Type ValueType { get; }
    private FileOptionAttribute(string key, char shortcut, int nonKeyedIndex);
    public FileOptionAttribute(string key);
    public FileOptionAttribute(string key, char shortcut);
    public FileOptionAttribute(char shortcut);
    public FileOptionAttribute(int nonKeyedIndex, string symbolicName);
    [CompilerGeneratedAttribute]
public bool get_MustExist();
    [CompilerGeneratedAttribute]
public void set_MustExist(bool value);
    [CompilerGeneratedAttribute]
public bool get_MustNotExist();
    [CompilerGeneratedAttribute]
public void set_MustNotExist(bool value);
    public virtual Type get_ValueType();
    protected virtual object ConvertValue(string value, Type type);
}
public class JetBrains.Util.CommandLineMapper.Attributes.FileSetOptionAttribute : AbstractOptionAttribute {
    private static Char[] ourDirectorySeparators;
    private static Char[] ourWildcard;
    public Type ValueType { get; }
    private FileSetOptionAttribute(string key, char shortcut, int nonKeyedIndex);
    public FileSetOptionAttribute(string key);
    public FileSetOptionAttribute(string key, char shortcut);
    public FileSetOptionAttribute(char shortcut);
    public FileSetOptionAttribute(int nonKeyedIndex, string symbolicName);
    private static FileSetOptionAttribute();
    public virtual Type get_ValueType();
    protected virtual object ConvertValue(string source, Type type);
}
[MeansImplicitUseAttribute]
[AttributeUsageAttribute("64")]
public class JetBrains.Util.CommandLineMapper.Attributes.HelpEpilogAttribute : AbstractMapperAttribute {
}
[AttributeUsageAttribute("64")]
[MeansImplicitUseAttribute]
public class JetBrains.Util.CommandLineMapper.Attributes.HelpPrologAttribute : AbstractMapperAttribute {
}
[MeansImplicitUseAttribute]
[AttributeUsageAttribute("64")]
public class JetBrains.Util.CommandLineMapper.Attributes.HelpTopicAttribute : AbstractMapperAttribute {
    private string myName;
    public string Name { get; }
    public HelpTopicAttribute(string name);
    public string get_Name();
}
public class JetBrains.Util.CommandLineMapper.Attributes.ImplicitGroupAttribute : AbstractGroupAttribute {
    public bool IsMultipleAllowed { get; }
    public Type GroupDefinitionAttributeType { get; }
    public ImplicitGroupAttribute(string symbolicName, Type knownType, Type[] otherKnownTypes);
    public virtual bool get_IsMultipleAllowed();
    public virtual Type get_GroupDefinitionAttributeType();
    public virtual IEnumerable`1<Type> GetSuitableTypes(ICommandLineInternal commandLine);
}
public class JetBrains.Util.CommandLineMapper.Attributes.ImplicitGroupDefinitionAttribute : AbstractGroupDefinitionAttribute {
    [CompilerGeneratedAttribute]
private int <Weight>k__BackingField;
    public int Weight { get; public set; }
    public ImplicitGroupDefinitionAttribute(string name);
    [CompilerGeneratedAttribute]
public int get_Weight();
    [CompilerGeneratedAttribute]
public void set_Weight(int value);
    public virtual GroupSignature GetGroupSignature(Type type);
}
public class JetBrains.Util.CommandLineMapper.Attributes.IntOptionAttribute : AbstractOptionAttribute {
    [CompilerGeneratedAttribute]
private bool <MustBeNonNegative>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <MustBePositive>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <MustBeInRange>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MinValue>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxValue>k__BackingField;
    public bool MustBeNonNegative { get; public set; }
    public bool MustBePositive { get; public set; }
    public bool MustBeInRange { get; public set; }
    public int MinValue { get; public set; }
    public int MaxValue { get; public set; }
    public Type ValueType { get; }
    private IntOptionAttribute(string key, char shortcut, int nonKeyedIndex);
    public IntOptionAttribute(string key);
    public IntOptionAttribute(string key, char shortcut);
    public IntOptionAttribute(char shortcut);
    public IntOptionAttribute(int nonKeyedIndex, string symbolicValue);
    [CompilerGeneratedAttribute]
public bool get_MustBeNonNegative();
    [CompilerGeneratedAttribute]
public void set_MustBeNonNegative(bool value);
    [CompilerGeneratedAttribute]
public bool get_MustBePositive();
    [CompilerGeneratedAttribute]
public void set_MustBePositive(bool value);
    [CompilerGeneratedAttribute]
public bool get_MustBeInRange();
    [CompilerGeneratedAttribute]
public void set_MustBeInRange(bool value);
    [CompilerGeneratedAttribute]
public int get_MinValue();
    [CompilerGeneratedAttribute]
public void set_MinValue(int value);
    [CompilerGeneratedAttribute]
public int get_MaxValue();
    [CompilerGeneratedAttribute]
public void set_MaxValue(int value);
    public virtual Type get_ValueType();
    protected virtual object ConvertValue(string value, Type type);
}
public class JetBrains.Util.CommandLineMapper.Attributes.NonKeyedTailAttribute : AbstractOptionAttribute {
    [CompilerGeneratedAttribute]
private static Func`2<CommandLineArgument, string> CS$<>9__CachedAnonymousMethodDelegate1;
    public Type ValueType { get; }
    public Type MultiValueType { get; }
    public string DefaultValue { get; }
    public string EmptyValue { get; }
    public bool IsNonKeyedTail { get; }
    public NonKeyedTailAttribute(int startNonKeyedIndex);
    public virtual Type get_ValueType();
    public virtual Type get_MultiValueType();
    public string get_DefaultValue();
    public string get_EmptyValue();
    public bool get_IsNonKeyedTail();
    public virtual object TryMap(ICommandLineInternal commandLine, Type type);
    protected virtual object ConvertValue(string value, Type type);
    [CompilerGeneratedAttribute]
private static string <TryMap>b__0(CommandLineArgument x);
}
[AttributeUsageAttribute("384")]
public class JetBrains.Util.CommandLineMapper.Attributes.OptionOrderAttribute : AbstractMapperAttribute {
    public int Order;
    public OptionOrderAttribute(int order);
}
public class JetBrains.Util.CommandLineMapper.Attributes.PathOptionAttribute : AbstractOptionAttribute {
    public Type ValueType { get; }
    private PathOptionAttribute(string key, char shortcut, int nonKeyedIndex);
    public PathOptionAttribute(string key);
    public PathOptionAttribute(string key, char shortcut);
    public PathOptionAttribute(char shortcut);
    public PathOptionAttribute(int nonKeyedIndex, string symbolicName);
    public virtual Type get_ValueType();
    protected virtual object ConvertValue(string value, Type type);
}
public class JetBrains.Util.CommandLineMapper.Attributes.StringOptionAttribute : AbstractOptionAttribute {
    [CompilerGeneratedAttribute]
private bool <MustNotBeEmpty>k__BackingField;
    public Type ValueType { get; }
    public bool MustNotBeEmpty { get; public set; }
    public StringOptionAttribute(string key);
    public StringOptionAttribute(string key, char shortcut);
    public StringOptionAttribute(char shortcut);
    public StringOptionAttribute(int nonKeyedIndex, string symbolicName);
    public virtual Type get_ValueType();
    [CompilerGeneratedAttribute]
public bool get_MustNotBeEmpty();
    [CompilerGeneratedAttribute]
public void set_MustNotBeEmpty(bool value);
    protected virtual object ConvertValue(string value, Type type);
}
[AttributeUsageAttribute("384")]
[MeansImplicitUseAttribute]
public class JetBrains.Util.CommandLineMapper.Attributes.SubOptionsAttribute : AbstractMapperAttribute {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CanBeNullAttribute]
public Type Type { get; private set; }
    public SubOptionsAttribute(Type type);
    [CompilerGeneratedAttribute]
public Type get_Type();
    [CompilerGeneratedAttribute]
private void set_Type(Type value);
}
[AttributeUsageAttribute("4")]
public class JetBrains.Util.CommandLineMapper.Attributes.SupportsHelpCommandAttribute : AbstractMapperAttribute {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <Names>k__BackingField;
    public IReadOnlyList`1<string> Names { get; private set; }
    public SupportsHelpCommandAttribute(string name, String[] otherNames);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_Names();
    [CompilerGeneratedAttribute]
private void set_Names(IReadOnlyList`1<string> value);
}
[AttributeUsageAttribute("4")]
public class JetBrains.Util.CommandLineMapper.Attributes.SupportsHelpKeysAttribute : AbstractMapperAttribute {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <Keys>k__BackingField;
    [CompilerGeneratedAttribute]
private static Func`2<string, KeyDefinition> CS$<>9__CachedAnonymousMethodDelegate1;
    public IReadOnlyList`1<string> Keys { get; private set; }
    public SupportsHelpKeysAttribute(string key, String[] otherKeys);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_Keys();
    [CompilerGeneratedAttribute]
private void set_Keys(IReadOnlyList`1<string> value);
    public IEnumerable`1<KeyDefinition> GetKeyDefinitions();
    [CompilerGeneratedAttribute]
private static KeyDefinition <GetKeyDefinitions>b__0(string x);
}
public class JetBrains.Util.CommandLineMapper.Attributes.TimeSpanOptionAttribute : AbstractOptionAttribute {
    private static long Day;
    private static long Hour;
    private static long Minute;
    private static long Second;
    private static Dictionary`2<string, long> ourUnitMarks;
    [CompilerGeneratedAttribute]
private static Func`2<char, bool> CS$<>9__CachedAnonymousMethodDelegate1;
    public Type ValueType { get; }
    private TimeSpanOptionAttribute(string key, char shortcut, int nonKeyedIndex);
    public TimeSpanOptionAttribute(string key);
    public TimeSpanOptionAttribute(string key, char shortcut);
    public TimeSpanOptionAttribute(char shortcut);
    public TimeSpanOptionAttribute(int nonKeyedIndex);
    private static TimeSpanOptionAttribute();
    public virtual Type get_ValueType();
    protected virtual string FormatValue(object value);
    protected virtual object ConvertValue(string value, Type type);
    [CompilerGeneratedAttribute]
private static bool <ConvertValue>b__0(char x);
}
[AttributeUsageAttribute("64")]
[MeansImplicitUseAttribute]
public class JetBrains.Util.CommandLineMapper.Attributes.UsageExamplesAttribute : AbstractMapperAttribute {
}
public static class JetBrains.Util.CommandLineMapper.CLI : object {
    [CompilerGeneratedAttribute]
private static FileSystemPath <StartupDirectory>k__BackingField;
    public static FileSystemPath StartupDirectory { get; public set; }
    private static CLI();
    [CompilerGeneratedAttribute]
public static FileSystemPath get_StartupDirectory();
    [CompilerGeneratedAttribute]
public static void set_StartupDirectory(FileSystemPath value);
    [NotNullAttribute]
public static string GetCommandName(object command);
    [NotNullAttribute]
public static string GetAppName();
    [NotNullAttribute]
public static string GreetingOf(string toolName, int sinceYear);
}
public class JetBrains.Util.CommandLineMapper.CommandLineArgument : object {
    private string myKey;
    private string myValue;
    public bool HasKey { get; }
    [NotNullAttribute]
public string Key { get; }
    public bool HasValue { get; }
    [NotNullAttribute]
public string Value { get; }
    private CommandLineArgument(string key, string value);
    public bool get_HasKey();
    public string get_Key();
    public bool get_HasValue();
    public string get_Value();
    public virtual string ToString();
    public static CommandLineArgument Keyed(string key, string value);
    public static CommandLineArgument Keyed(string key);
    public static CommandLineArgument NonKeyed(string value);
    public static CommandLineArgument Adopt(string key, string value);
}
public class JetBrains.Util.CommandLineMapper.CommandLineException : Exception {
    private string myLocalizationKey;
    [CanBeNullAttribute]
public string LocalizationKey { get; }
    private CommandLineException(string localizationKey, string defaultMessage);
    private CommandLineException(string message);
    public string get_LocalizationKey();
    public static CommandLineException Localized(string message);
    [StringFormatMethodAttribute("format")]
public static CommandLineException Localized(string format, Object[] args);
    public static CommandLineException Aggregated(IEnumerable`1<CommandLineException> exceptions);
}
[FlagsAttribute]
public enum JetBrains.Util.CommandLineMapper.ExampleFormatFlags : Enum {
    public int value__;
    public static ExampleFormatFlags AppName;
    public static ExampleFormatFlags AppNameDotExe;
    public static ExampleFormatFlags Arguments;
}
public class JetBrains.Util.CommandLineMapper.FormattedTextBuilder : object {
    private IDictionary`2<string, string> myMacros;
    private StringBuilder myText;
    private int myIndent;
    private int myAlignMark;
    private int myAlignPosition;
    public bool IsEmpty { get; }
    public int Indent { get; }
    public int AlignPosition { get; }
    public IDictionary`2<string, string> Macros { get; }
    public bool get_IsEmpty();
    public int get_Indent();
    public int get_AlignPosition();
    public IDictionary`2<string, string> get_Macros();
    public virtual string ToString();
    public FormattedTextBuilder IncreaseIndent();
    public FormattedTextBuilder DecreaseIndent();
    public FormattedTextBuilder Break();
    public FormattedTextBuilder Separator();
    public FormattedTextBuilder NewLine();
    public FormattedTextBuilder Space();
    public FormattedTextBuilder AlignBegin();
    public FormattedTextBuilder AlignTo(int position);
    public FormattedTextBuilder AlignToCurrent();
    public FormattedTextBuilder AlignEnd();
    public FormattedTextBuilder Text(string text);
    public FormattedTextBuilder Text(object value);
    public FormattedTextBuilder LocalizedText(string text);
    public FormattedTextBuilder LocalizedText(string text, int width);
    public FormattedTextBuilder Char(char ch);
    private string Localize(string text);
}
[ExtensionAttribute]
public static class JetBrains.Util.CommandLineMapper.FormattedTextBuilderExtension : object {
    [NotNullAttribute]
[ExtensionAttribute]
public static FormattedTextBuilder Usage(FormattedTextBuilder builder);
    [NotNullAttribute]
[ExtensionAttribute]
public static FormattedTextBuilder Example(FormattedTextBuilder builder);
    [NotNullAttribute]
[ExtensionAttribute]
public static FormattedTextBuilder AppName(FormattedTextBuilder builder, Type optionsType);
}
public class JetBrains.Util.CommandLineMapper.GroupSignature : object {
    private string myArgs;
    private int myWeight;
    private GroupSignature(string args, int weight);
    public virtual string ToString();
    public sealed virtual bool Equals(GroupSignature other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual int CompareTo(GroupSignature other);
}
public interface JetBrains.Util.CommandLineMapper.ICommandLineBuilder`1 {
    [NotNullAttribute]
public RelativePath AppNameDotExe { get; }
    public abstract virtual RelativePath get_AppNameDotExe();
    [NotNullAttribute]
public abstract virtual string BuildArguments(TOptions options);
}
public interface JetBrains.Util.CommandLineMapper.ICommandLineMapper`1 {
    public IHelpGenerator HelpGenerator { get; }
    public abstract virtual IHelpGenerator get_HelpGenerator();
    [NotNullAttribute]
public abstract virtual KeyDefinitionSet GetKeyDefinitions();
    [CanBeNullAttribute]
public abstract virtual TOptions Map(ICommandLineParser parser, Action`1<string> displayHelp);
    [CanBeNullAttribute]
public abstract virtual TOptions Map(ICommandLineParser parser);
}
public interface JetBrains.Util.CommandLineMapper.ICommandLineParser {
    [NotNullAttribute]
public abstract virtual IEnumerable`1<CommandLineArgument> GetArguments(KeyDefinitionSet keyDefinitions);
}
public interface JetBrains.Util.CommandLineMapper.IExampleFormatter {
    [NotNullAttribute]
public abstract virtual string Format(object options, ExampleFormatFlags flags);
}
public interface JetBrains.Util.CommandLineMapper.IHelpGenerator {
    [NotNullAttribute]
public IOptionFormatter OptionFormatter { get; }
    [NotNullAttribute]
public IExampleFormatter ExampleFormatter { get; }
    public abstract virtual IOptionFormatter get_OptionFormatter();
    public abstract virtual IExampleFormatter get_ExampleFormatter();
    [NotNullAttribute]
public abstract virtual string GenerateHelp();
    [NotNullAttribute]
public abstract virtual string GenerateHelp(string groupName);
}
[DebuggerDisplayAttribute("{Name}")]
internal abstract class JetBrains.Util.CommandLineMapper.Impl.AbstractMappedMember : object {
    private int myOrder;
    protected MemberInfo MemberInfo { get; }
    public int Order { get; }
    public string Name { get; }
    public Type DeclaringType { get; }
    public Type Type { get; }
    public bool IsReadable { get; }
    public bool IsWriteable { get; }
    public bool IsStatic { get; }
    protected AbstractMappedMember(MemberInfo memberInfo);
    protected abstract virtual MemberInfo get_MemberInfo();
    public sealed virtual int get_Order();
    public sealed virtual string get_Name();
    public sealed virtual Type get_DeclaringType();
    public sealed virtual TAttribute GetAttribute();
    public abstract virtual Type get_Type();
    public abstract virtual bool get_IsReadable();
    public abstract virtual bool get_IsWriteable();
    public abstract virtual bool get_IsStatic();
    public abstract virtual object GetValue(object instance);
    public abstract virtual void SetValue(object instance, object value);
    [CanBeNullAttribute]
public static IMappedMember TryCreate(MemberInfo memberInfo);
}
public abstract class JetBrains.Util.CommandLineMapper.Impl.AbstractOptionsIntrospector : object {
    [CompilerGeneratedAttribute]
private bool <IsCancelled>k__BackingField;
    [CompilerGeneratedAttribute]
private static Comparison`1<IMappedMember> CS$<>9__CachedAnonymousMethodDelegate1;
    protected bool IsCancelled { get; private set; }
    protected BindingFlags BindingFlags { get; }
    public void Introspect(Type optionsType);
    protected virtual void Begin(Type type);
    protected virtual void End(Type type);
    protected virtual void End();
    protected virtual void OnOption(AbstractOptionAttribute optionAttribute, IMappedMember member);
    protected virtual void BeginGroup(AbstractGroupAttribute groupAttribute, IMappedMember member);
    protected virtual void EndGroup(AbstractGroupAttribute groupAttribute, IMappedMember member);
    protected virtual void EndGroup();
    protected virtual void OnGroupDefinition(AbstractGroupDefinitionAttribute groupDefinitionAttribute, Type type);
    protected virtual IEnumerable`1<Type> GroupTypesOf(AbstractGroupAttribute groupAttribute, IMappedMember member);
    protected virtual void OnSubOptions(IMappedMember member, Type type);
    [CompilerGeneratedAttribute]
protected bool get_IsCancelled();
    [CompilerGeneratedAttribute]
private void set_IsCancelled(bool value);
    protected void Cancel();
    protected virtual BindingFlags get_BindingFlags();
    private static void GetMappedMembers(Type type, BindingFlags bindingFlags, List`1<IMappedMember> outMembers);
    internal static IEnumerable`1<IMappedMember> GetMappedMembersOrdered(Type type, BindingFlags bindingFlags);
    [CompilerGeneratedAttribute]
private static int <GetMappedMembersOrdered>b__0(IMappedMember x, IMappedMember y);
}
public abstract class JetBrains.Util.CommandLineMapper.Impl.AbstractParser : object {
    private IReadOnlyList`1<string> myRawArguments;
    private string myRawCommandLine;
    private CommandLineParserSettings mySettings;
    private static Char[] ourDefaultValueSeparators;
    protected Char[] ValueSeparators { get; }
    protected AbstractParser(IReadOnlyList`1<string> rawArguments, CommandLineParserSettings settings);
    protected AbstractParser(string rawCommandLine, CommandLineParserSettings settings);
    private static AbstractParser();
    public sealed virtual string GetNonKeyedTailRaw(int startNonKeyedParamIndex);
    public sealed virtual IEnumerable`1<CommandLineArgument> GetArguments(KeyDefinitionSet keyDefinitions);
    protected virtual void ParseKey(KeyDefinitionSet keyDefinitions, RawArgumentIterator rawArgumentIt, IList`1<CommandLineArgument> outParsedArguments);
    protected virtual void ParseShortcuts(KeyDefinitionSet keyDefinitions, RawArgumentIterator rawArgumentIt, IList`1<CommandLineArgument> outParsedArguments);
    protected virtual void ParseValue(RawArgumentIterator rawArgumentIt, IList`1<CommandLineArgument> outParsedArguments);
    protected virtual KeyValuePair`2<string, string> ToKeyValue(string argument);
    protected virtual KeyValuePair`2<string, string> ToShortcutValue(string argument);
    protected virtual Char[] get_ValueSeparators();
    protected abstract virtual bool IsShortcut(string rawArgument);
    protected abstract virtual bool IsKey(string rawArgument);
    protected abstract virtual bool IsNonKeyedMarker(string rawArgument);
    protected abstract virtual string TrimKeyMark(string rawArgument);
    protected abstract virtual string TrimShortcutMark(string rawArgument);
}
internal static class JetBrains.Util.CommandLineMapper.Impl.AppNameUtils : object {
    [NotNullAttribute]
public static string GetAppName(Type optionsType);
}
public class JetBrains.Util.CommandLineMapper.Impl.BackwardCompatibilityParser : AbstractParser {
    public BackwardCompatibilityParser(IReadOnlyList`1<string> rawArguments, CommandLineParserSettings settings);
    public BackwardCompatibilityParser(string rawCommandLine, CommandLineParserSettings settings);
    protected virtual bool IsShortcut(string rawArgument);
    protected virtual bool IsKey(string rawArgument);
    protected virtual bool IsNonKeyedMarker(string rawArgument);
    protected virtual string TrimKeyMark(string rawArgument);
    protected virtual string TrimShortcutMark(string rawArgument);
}
public class JetBrains.Util.CommandLineMapper.Impl.CommandLineBuilder`1 : object {
    private IExampleFormatter myExampleFormatter;
    public RelativePath AppNameDotExe { get; }
    public CommandLineBuilder`1(IOptionFormatter optionFormatter);
    public sealed virtual RelativePath get_AppNameDotExe();
    public sealed virtual string BuildArguments(TOptions options);
}
public class JetBrains.Util.CommandLineMapper.Impl.CommandLineInternal : object {
    private ICommandLineParser myParser;
    private List`1<CommandLineArgument> myArgs;
    private OneToListMap`2<string, CommandLineArgument> myKeyedArgs;
    private List`1<CommandLineArgument> myNonKeyedArgs;
    private HashSet`1<CommandLineArgument> myMappedArgs;
    private CommandLineInternal myParent;
    [CompilerGeneratedAttribute]
private static Func`2<CommandLineArgument, bool> CS$<>9__CachedAnonymousMethodDelegate7;
    public ICommandLineParser Parser { get; }
    public bool IsEmpty { get; }
    public bool HasMapped { get; }
    public CommandLineInternal(ICommandLineParser parser, KeyDefinitionSet keyDefinitions);
    private CommandLineInternal(CommandLineInternal commandLine);
    public sealed virtual ICommandLineParser get_Parser();
    public sealed virtual bool get_IsEmpty();
    public sealed virtual bool get_HasMapped();
    public sealed virtual IEnumerable`1<CommandLineArgument> GetArguments(string key);
    public sealed virtual IEnumerable`1<CommandLineArgument> GetArguments(int nonKeyedIndex, int count);
    public sealed virtual IEnumerable`1<CommandLineArgument> GetArguments();
    public sealed virtual int IndexOf(CommandLineArgument argument);
    public sealed virtual void MarkAsMapped(CommandLineArgument argument);
    public sealed virtual ICommandLineInternal BeginMapping();
    public sealed virtual void RemoveMapped();
    private void RemoveMapped(OneToListMap`2<TKey, CommandLineArgument> keyedArgs);
    private void RemoveMapped(List`1<CommandLineArgument> nonkeyedArgs);
    [CompilerGeneratedAttribute]
private static bool <get_IsEmpty>b__6(CommandLineArgument x);
}
public class JetBrains.Util.CommandLineMapper.Impl.CommandLineMapper`1 : object {
    private OneToListMap`2<string, CommandLineException> myMappingErrors;
    private CommandLineMapperSettings mySettings;
    private KeyDefinitionSet myKeyDefinitions;
    [CompilerGeneratedAttribute]
private static Func`2<CommandLineArgument, string> CS$<>9__CachedAnonymousMethodDelegate1;
    [CompilerGeneratedAttribute]
private static Func`2<CommandLineArgument, string> CS$<>9__CachedAnonymousMethodDelegate3;
    [CompilerGeneratedAttribute]
private static Func`2<Type, GroupSignature> CS$<>9__CachedAnonymousMethodDelegate6;
    public IHelpGenerator HelpGenerator { get; }
    public CommandLineMapper`1(CommandLineMapperSettings settings);
    public sealed virtual IHelpGenerator get_HelpGenerator();
    public sealed virtual KeyDefinitionSet GetKeyDefinitions();
    public sealed virtual TOptions Map(ICommandLineParser parser, Action`1<string> displayHelp);
    public sealed virtual TOptions Map(ICommandLineParser parser);
    private TOptions Map(ICommandLineInternal commandLine);
    private bool TryMapHelp(ICommandLineInternal commandLine, Action`1<string> displayHelp);
    [NotNullAttribute]
private object Map(ICommandLineInternal commandLine, Type optionsType, int depth);
    [CanBeNullAttribute]
private object Map(ICommandLineInternal commandLine, Type type, AbstractGroupAttribute groupAttribute, int depth);
    private string Format(AbstractOptionAttribute optionAttribute);
    private string Format(AbstractGroupAttribute groupAttribute);
    [CompilerGeneratedAttribute]
private static string <Map>b__0(CommandLineArgument x);
    [CompilerGeneratedAttribute]
private static string <TryMapHelp>b__2(CommandLineArgument x);
    [CompilerGeneratedAttribute]
private static GroupSignature <Map>b__4(Type x);
}
public class JetBrains.Util.CommandLineMapper.Impl.CommandLineMapperSettings : object {
    [CompilerGeneratedAttribute]
private StringComparer <KeyComparer>k__BackingField;
    [CompilerGeneratedAttribute]
private IHelpGenerator <HelpGenerator>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreExcessiveArguments>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ValidateHelpText>k__BackingField;
    [NotNullAttribute]
public StringComparer KeyComparer { get; private set; }
    [NotNullAttribute]
public IHelpGenerator HelpGenerator { get; private set; }
    public bool IgnoreExcessiveArguments { get; private set; }
    public bool ValidateHelpText { get; private set; }
    [CompilerGeneratedAttribute]
public StringComparer get_KeyComparer();
    [CompilerGeneratedAttribute]
private void set_KeyComparer(StringComparer value);
    [CompilerGeneratedAttribute]
public IHelpGenerator get_HelpGenerator();
    [CompilerGeneratedAttribute]
private void set_HelpGenerator(IHelpGenerator value);
    [CompilerGeneratedAttribute]
public bool get_IgnoreExcessiveArguments();
    [CompilerGeneratedAttribute]
private void set_IgnoreExcessiveArguments(bool value);
    [CompilerGeneratedAttribute]
public bool get_ValidateHelpText();
    [CompilerGeneratedAttribute]
private void set_ValidateHelpText(bool value);
}
public class JetBrains.Util.CommandLineMapper.Impl.CommandLineParserSettings : object {
    [CompilerGeneratedAttribute]
private Action`2<string, string> <OnKeyFound>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`2<string, string> <OnUndefinedKeyFound>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`3<string, char, string> <OnShortcutFound>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`2<string, char> <OnUndefinedShortcutFound>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`3<string, string, string> <OnAliasFound>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TreatUndefinedKeyAsIs>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TreatSpaceAsValueSeparator>k__BackingField;
    [CanBeNullAttribute]
public Action`2<string, string> OnKeyFound { get; private set; }
    [CanBeNullAttribute]
public Action`2<string, string> OnUndefinedKeyFound { get; private set; }
    [CanBeNullAttribute]
public Action`3<string, char, string> OnShortcutFound { get; private set; }
    [CanBeNullAttribute]
public Action`2<string, char> OnUndefinedShortcutFound { get; private set; }
    [CanBeNullAttribute]
public Action`3<string, string, string> OnAliasFound { get; private set; }
    public bool TreatUndefinedKeyAsIs { get; private set; }
    public bool TreatSpaceAsValueSeparator { get; private set; }
    [CompilerGeneratedAttribute]
public Action`2<string, string> get_OnKeyFound();
    [CompilerGeneratedAttribute]
private void set_OnKeyFound(Action`2<string, string> value);
    [CompilerGeneratedAttribute]
public Action`2<string, string> get_OnUndefinedKeyFound();
    [CompilerGeneratedAttribute]
private void set_OnUndefinedKeyFound(Action`2<string, string> value);
    [CompilerGeneratedAttribute]
public Action`3<string, char, string> get_OnShortcutFound();
    [CompilerGeneratedAttribute]
private void set_OnShortcutFound(Action`3<string, char, string> value);
    [CompilerGeneratedAttribute]
public Action`2<string, char> get_OnUndefinedShortcutFound();
    [CompilerGeneratedAttribute]
private void set_OnUndefinedShortcutFound(Action`2<string, char> value);
    [CompilerGeneratedAttribute]
public Action`3<string, string, string> get_OnAliasFound();
    [CompilerGeneratedAttribute]
private void set_OnAliasFound(Action`3<string, string, string> value);
    [CompilerGeneratedAttribute]
public bool get_TreatUndefinedKeyAsIs();
    [CompilerGeneratedAttribute]
private void set_TreatUndefinedKeyAsIs(bool value);
    [CompilerGeneratedAttribute]
public bool get_TreatSpaceAsValueSeparator();
    [CompilerGeneratedAttribute]
private void set_TreatSpaceAsValueSeparator(bool value);
}
public class JetBrains.Util.CommandLineMapper.Impl.CompactHelpGenerator : object {
    private Type myOptionsType;
    private IOptionFormatter myOptionFormatter;
    private int myOptionColumnWidth;
    private int myDescriptionColumnWidth;
    public IOptionFormatter OptionFormatter { get; }
    public IExampleFormatter ExampleFormatter { get; }
    public CompactHelpGenerator(Type optionsType, IOptionFormatter optionFormatter, int optionColumnWidth, int descriptionColumnWidth);
    public sealed virtual IOptionFormatter get_OptionFormatter();
    public sealed virtual IExampleFormatter get_ExampleFormatter();
    public sealed virtual string GenerateHelp();
    public sealed virtual string GenerateHelp(string groupName);
}
public class JetBrains.Util.CommandLineMapper.Impl.DefaultHelpGenerator : object {
    private Type myOptionsType;
    private IOptionFormatter myOptionFormatter;
    private IExampleFormatter myExampleFormatter;
    private int myOptionColumnWidth;
    private int myDescriptionColumnWidth;
    public IOptionFormatter OptionFormatter { get; }
    public IExampleFormatter ExampleFormatter { get; }
    public DefaultHelpGenerator(Type optionsType, IOptionFormatter optionFormatter, int optionColumnWidth, int descriptionColumnWidth);
    public sealed virtual IOptionFormatter get_OptionFormatter();
    public sealed virtual IExampleFormatter get_ExampleFormatter();
    public sealed virtual string GenerateHelp();
    public sealed virtual string GenerateHelp(string groupName);
    private void DefineMacros(FormattedTextBuilder help, Type optionsType);
}
public class JetBrains.Util.CommandLineMapper.Impl.ExampleFormatter : object {
    private Type myOptionsType;
    private IOptionFormatter myOptionFormatter;
    public ExampleFormatter(Type optionsType, IOptionFormatter optionFormatter);
    public sealed virtual string Format(object options, ExampleFormatFlags flags);
}
[ExtensionAttribute]
internal static class JetBrains.Util.CommandLineMapper.Impl.HelpGeneratorUtils : object {
    public static BindingFlags BindingFlags;
    [CompilerGeneratedAttribute]
private static Func`2<MethodInfo, bool> CS$<>9__CachedAnonymousMethodDelegate1;
    [CompilerGeneratedAttribute]
private static Func`2<MethodInfo, bool> CS$<>9__CachedAnonymousMethodDelegate3;
    [CompilerGeneratedAttribute]
private static Func`2<MethodInfo, bool> CS$<>9__CachedAnonymousMethodDelegate5;
    private static HelpGeneratorUtils();
    [ExtensionAttribute]
[NotNullAttribute]
public static IEnumerable`1<UsageExample> GetExamples(Type optionsType);
    [ExtensionAttribute]
public static bool AppendHelpPrologIfAny(Type optionsType, FormattedTextBuilder text, IOptionFormatter optionFormatter, int optionColumnWidth, int descriptionColumnWidth);
    [ExtensionAttribute]
public static bool AppendHelpEpilogIfAny(Type optionsType, FormattedTextBuilder text, IOptionFormatter optionFormatter, int optionColumnWidth, int descriptionColumnWidth);
    [ExtensionAttribute]
public static bool AppendHelpTopicIfAny(Type optionsType, string name, FormattedTextBuilder text, IOptionFormatter optionFormatter, int optionColumnWidth, int descriptionColumnWidth);
    private static void AppendHelp(MethodInfo method, FormattedTextBuilder text, IOptionFormatter optionFormatter, int optionColumnWidth, int descriptionColumnWidth);
    [CompilerGeneratedAttribute]
private static bool <GetExamples>b__0(MethodInfo x);
    [CompilerGeneratedAttribute]
private static bool <AppendHelpPrologIfAny>b__2(MethodInfo x);
    [CompilerGeneratedAttribute]
private static bool <AppendHelpEpilogIfAny>b__4(MethodInfo x);
}
public interface JetBrains.Util.CommandLineMapper.Impl.ICommandLineInternal {
    public bool IsEmpty { get; }
    public bool HasMapped { get; }
    [NotNullAttribute]
public ICommandLineParser Parser { get; }
    public abstract virtual bool get_IsEmpty();
    public abstract virtual bool get_HasMapped();
    public abstract virtual ICommandLineParser get_Parser();
    [NotNullAttribute]
public abstract virtual IEnumerable`1<CommandLineArgument> GetArguments(string key);
    [NotNullAttribute]
public abstract virtual IEnumerable`1<CommandLineArgument> GetArguments(int nonKeyedIndex, int count);
    [NotNullAttribute]
public abstract virtual IEnumerable`1<CommandLineArgument> GetArguments();
    public abstract virtual int IndexOf(CommandLineArgument argument);
    [NotNullAttribute]
public abstract virtual ICommandLineInternal BeginMapping();
    public abstract virtual void MarkAsMapped(CommandLineArgument argument);
    public abstract virtual void RemoveMapped();
}
public interface JetBrains.Util.CommandLineMapper.Impl.IMappedMember {
    public int Order { get; }
    [NotNullAttribute]
public string Name { get; }
    [NotNullAttribute]
public Type Type { get; }
    public bool IsReadable { get; }
    public bool IsWriteable { get; }
    public bool IsStatic { get; }
    [NotNullAttribute]
public Type DeclaringType { get; }
    public abstract virtual int get_Order();
    public abstract virtual string get_Name();
    public abstract virtual Type get_Type();
    public abstract virtual bool get_IsReadable();
    public abstract virtual bool get_IsWriteable();
    public abstract virtual bool get_IsStatic();
    public abstract virtual Type get_DeclaringType();
    [CanBeNullAttribute]
public abstract virtual object GetValue(object instance);
    public abstract virtual void SetValue(object instance, object value);
    public abstract virtual TAttribute GetAttribute();
}
internal class JetBrains.Util.CommandLineMapper.Impl.MappedField : AbstractMappedMember {
    private FieldInfo myField;
    protected MemberInfo MemberInfo { get; }
    public Type Type { get; }
    public bool IsReadable { get; }
    public bool IsWriteable { get; }
    public bool IsStatic { get; }
    public MappedField(FieldInfo field);
    protected virtual MemberInfo get_MemberInfo();
    public virtual Type get_Type();
    public virtual bool get_IsReadable();
    public virtual bool get_IsWriteable();
    public virtual bool get_IsStatic();
    public virtual object GetValue(object instance);
    public virtual void SetValue(object instance, object value);
}
internal class JetBrains.Util.CommandLineMapper.Impl.MappedProperty : AbstractMappedMember {
    private PropertyInfo myProperty;
    protected MemberInfo MemberInfo { get; }
    public Type Type { get; }
    public bool IsReadable { get; }
    public bool IsWriteable { get; }
    public bool IsStatic { get; }
    public MappedProperty(PropertyInfo property);
    protected virtual MemberInfo get_MemberInfo();
    public virtual Type get_Type();
    public virtual bool get_IsReadable();
    public virtual bool get_IsWriteable();
    public virtual bool get_IsStatic();
    public virtual object GetValue(object instance);
    public virtual void SetValue(object instance, object value);
}
[ExtensionAttribute]
internal static class JetBrains.Util.CommandLineMapper.Impl.MultiValueUtils : object {
    [CompilerGeneratedAttribute]
private static Func`2<Type, bool> CS$<>9__CachedAnonymousMethodDelegate1;
    [CompilerGeneratedAttribute]
private static Func`2<string, string> CS$<>9__CachedAnonymousMethodDelegate4;
    [CompilerGeneratedAttribute]
private static Func`2<string, bool> CS$<>9__CachedAnonymousMethodDelegate5;
    [ExtensionAttribute]
public static bool IsEnumerableOfAny(Type type);
    [ExtensionAttribute]
public static bool IsEnumerableOfAny(Type type, Type& itemType);
    [ExtensionAttribute]
public static bool IsEnumerableOf(Type type, Type itemType);
    [ExtensionAttribute]
private static bool IsEnumerable(Type type, Type& itemType);
    [NotNullAttribute]
public static IEnumerable`1<string> Split(string value, char separator);
    [NotNullAttribute]
[ExtensionAttribute]
public static object ToTypedArray(IReadOnlyList`1<object> items, Type itemType);
    public static bool Equals(object one, object other);
    [CompilerGeneratedAttribute]
private static bool <IsEnumerable>b__0(Type x);
    [CompilerGeneratedAttribute]
private static string <Split>b__2(string x);
    [CompilerGeneratedAttribute]
private static bool <Split>b__3(string x);
}
public class JetBrains.Util.CommandLineMapper.Impl.OptionFormatter : object {
    private string myKeyMarker;
    private char myShortcutMarker;
    private char myValueSeparator;
    private string myNonKeyedMarker;
    public string KeyMarker { get; }
    public char ShortcutMarker { get; }
    public string NonKeyedMarker { get; }
    public char ValueSeparator { get; }
    public OptionFormatter(string keyMarker, char shortcutMarker, char valueSeparator, string nonKeyedMarker);
    public sealed virtual string get_KeyMarker();
    public sealed virtual char get_ShortcutMarker();
    public sealed virtual string get_NonKeyedMarker();
    public sealed virtual char get_ValueSeparator();
    public sealed virtual string Format(AbstractOptionAttribute optionAttribute, bool isMultiValued);
    public sealed virtual string Format(AbstractGroupAttribute groupAttribute, bool isMultipleAllowed);
    public sealed virtual string Format(AbstractGroupDefinitionAttribute groupDefinitionAttribute);
    public sealed virtual string Format(AbstractOptionAttribute optionAttribute, object value, Boolean& nonKeyedMarkerRequired);
    private static bool IsNonKeyedMarkerRequired(string formattedValue, bool isRaw);
    public sealed virtual string FormatName(AbstractOptionAttribute optionAttribute);
    public sealed virtual string FormatName(AbstractGroupAttribute groupAttribute);
    [UsedImplicitlyAttribute]
private static string FormatGroup(AbstractGroupDefinitionAttribute groupDefinition);
    [UsedImplicitlyAttribute]
private static string FormatGroup(CommandDefinitionAttribute commandDefinition);
    [UsedImplicitlyAttribute]
private static string FormatGroup(ImplicitGroupDefinitionAttribute implicitGroupDefinition);
}
public class JetBrains.Util.CommandLineMapper.Impl.OptionsValidator : AbstractOptionsIntrospector {
    private bool myValidateTextHelp;
    private UniqueContext myCurrentUniqueContext;
    private UniqueContext myParentUniqueContext;
    private bool myCurrentGroupIsMultiple;
    private bool myIsCommandFound;
    private bool myIsInsideCommand;
    protected BindingFlags BindingFlags { get; }
    public OptionsValidator(StringComparer comparer, bool validateTextHelp);
    protected virtual BindingFlags get_BindingFlags();
    protected virtual void Begin(Type type);
    protected virtual void End(Type type);
    protected virtual void OnOption(AbstractOptionAttribute optionAttribute, IMappedMember member);
    protected virtual void BeginGroup(AbstractGroupAttribute groupAttribute, IMappedMember member);
    [UsedImplicitlyAttribute]
private void ValidateGroup(AbstractGroupAttribute groupAttribute, IMappedMember member);
    [UsedImplicitlyAttribute]
private void ValidateGroup(CommandGroupAttribute commandAttribute, IMappedMember member);
    protected virtual void EndGroup();
    protected virtual void OnGroupDefinition(AbstractGroupDefinitionAttribute groupDefinitionAttribute, Type type);
    private void ValidateConstructor(Type type);
    private void ValidateDeclaration(IMappedMember member);
    private void ValidateOptionUnique(AbstractOptionAttribute optionAttribute, IMappedMember member);
    private void ValidateKeyUnique(string key, IMappedMember member);
    private void ValidateShortcutUnique(char shortcut, IMappedMember member);
    private void ValidateAliasUnique(string alias, IMappedMember member);
    private void ValidateNonKeyedIndexUnique(int nonKeyedIndex, bool isTail, IMappedMember member);
    private void ValidateOptionPosition(IMappedMember member);
    private void ValidateOptionMultiValueType(AbstractOptionAttribute optionAttribute, IMappedMember member);
    private void ValidateOptionValueType(AbstractOptionAttribute optionAttribute, IMappedMember member);
    private void ValidateOptionDefaultValue(AbstractOptionAttribute optionAttribute, IMappedMember member);
    private void ValidateOptionEmptyValue(AbstractOptionAttribute optionAttribute, IMappedMember member);
    private void ValidateMultiGroupType(AbstractGroupAttribute groupAttribute, IMappedMember member, Type groupType);
    private void ValidateGroupKnownTypes(AbstractGroupAttribute groupAttribute, IMappedMember member, Type groupType);
    private void ValidateExamples(Type type);
    private void ValidateCustomHelp(Type type);
    private void ValidateHelpText(AbstractOptionAttribute optionAttribute, IMappedMember member);
    [StringFormatMethodAttribute("format")]
private static Exception ValidationException(IMappedMember member, string format, Object[] args);
    [StringFormatMethodAttribute("format")]
private static Exception ValidationException(MethodInfo method, string format, Object[] args);
    [StringFormatMethodAttribute("format")]
private static Exception ValidationException(string format, Object[] args);
    private static string FormatLong(IMappedMember member);
    private static string FormatShort(IMappedMember member);
    private static string FormatType(Type type);
    private static StringBuilder FormatType(StringBuilder sb, Type type);
}
internal static class JetBrains.Util.CommandLineMapper.Impl.PathParserUtils : object {
    public static string ExpandVariables(string path);
    public static FileSystemPath ParseExpandablePath(string value, bool mustExist);
    public static FileSystemPath ParseExpandableDirecory(string value, bool mustExist, bool mustNotExist);
    public static FileSystemPath ParseExpandableFile(string value, bool mustExist, bool mustNotExist);
    public static FileSystemPath ParsePath(string value, bool mustExist);
    public static FileSystemPath ParseDirecory(string value, bool mustExist, bool mustNotExist);
    public static FileSystemPath ParseFile(string value, bool mustExist, bool mustNotExist);
    private static FileSystemPath ParseExpandablePathCore(string value, bool mustExist, bool mustNotExist, PathEntity pathEntity);
    private static FileSystemPath ParsePathCore(string value, bool mustExist, bool mustNotExist, PathEntity pathEntity);
    private static CommandLineException GetInvalidPathException(PathEntity pathEntity, string path);
    private static CommandLineException GetPathExistsException(PathEntity pathEntity, string path);
    private static CommandLineException GetPathExistsException(PathEntity expectedEntity, PathEntity actualEntity, string path);
    private static CommandLineException GetPathDoesntExistsException(PathEntity pathEntity, string path);
    private static bool Exists(PathEntity pathEntity, FileSystemPath path);
}
public class JetBrains.Util.CommandLineMapper.Impl.UniversalParser : AbstractParser {
    public UniversalParser(IReadOnlyList`1<string> rawArguments, CommandLineParserSettings settings);
    public UniversalParser(string rawCommandLine, CommandLineParserSettings settings);
    protected virtual bool IsShortcut(string rawArgument);
    protected virtual bool IsKey(string rawArgument);
    protected virtual bool IsNonKeyedMarker(string rawArgument);
    protected virtual string TrimKeyMark(string rawArgument);
    protected virtual string TrimShortcutMark(string rawArgument);
}
public class JetBrains.Util.CommandLineMapper.Impl.UnixStyleParser : AbstractParser {
    public UnixStyleParser(IReadOnlyList`1<string> rawArguments, CommandLineParserSettings settings);
    public UnixStyleParser(string rawCommandLine, CommandLineParserSettings settings);
    protected virtual bool IsShortcut(string rawArgument);
    protected virtual bool IsKey(string rawArgument);
    protected virtual bool IsNonKeyedMarker(string rawArgument);
    protected virtual string TrimKeyMark(string rawArgument);
    protected virtual string TrimShortcutMark(string rawArgument);
}
public interface JetBrains.Util.CommandLineMapper.IOptionFormatter {
    [NotNullAttribute]
public string KeyMarker { get; }
    public char ShortcutMarker { get; }
    [NotNullAttribute]
public string NonKeyedMarker { get; }
    public char ValueSeparator { get; }
    public abstract virtual string get_KeyMarker();
    public abstract virtual char get_ShortcutMarker();
    public abstract virtual string get_NonKeyedMarker();
    public abstract virtual char get_ValueSeparator();
    [NotNullAttribute]
public abstract virtual string Format(AbstractOptionAttribute optionAttribute, bool isMultiValued);
    [NotNullAttribute]
public abstract virtual string Format(AbstractGroupAttribute groupAttribute, bool isMultipleAllowed);
    [NotNullAttribute]
public abstract virtual string Format(AbstractGroupDefinitionAttribute groupDefinitionAttribute);
    [NotNullAttribute]
public abstract virtual string Format(AbstractOptionAttribute optionAttribute, object value, Boolean& nonKeyedMarkerRequired);
    [NotNullAttribute]
public abstract virtual string FormatName(AbstractOptionAttribute optionAttribute);
    [NotNullAttribute]
public abstract virtual string FormatName(AbstractGroupAttribute groupAttribute);
}
public interface JetBrains.Util.CommandLineMapper.ISupportRawCommandLine {
    [NotNullAttribute]
public abstract virtual string GetNonKeyedTailRaw(int startNonKeyedParamIndex);
}
public interface JetBrains.Util.CommandLineMapper.ISupportRawValueFormat {
}
public class JetBrains.Util.CommandLineMapper.KeyDefinition : object {
    private string myKey;
    private char myShortcut;
    private string myAlias;
    private bool myIsValueExpected;
    private bool myIsValueRequired;
    [NotNullAttribute]
public string Key { get; }
    public bool HasShortcut { get; }
    public char Shortcut { get; }
    public bool HasAlias { get; }
    [NotNullAttribute]
public string Alias { get; }
    public bool IsValueExpected { get; }
    public bool IsValueRequired { get; }
    public KeyDefinition(string key, char shortcut, string alias, bool isValueExpected, bool isValueRequired);
    public string get_Key();
    public bool get_HasShortcut();
    public char get_Shortcut();
    public bool get_HasAlias();
    public string get_Alias();
    public bool get_IsValueExpected();
    public bool get_IsValueRequired();
    public virtual string ToString();
    public sealed virtual bool Equals(KeyDefinition other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class JetBrains.Util.CommandLineMapper.KeyDefinitionSet : object {
    private Dictionary`2<char, KeyDefinition> myShortcutsMap;
    private Dictionary`2<string, KeyDefinition> myKeysMap;
    private Dictionary`2<string, KeyDefinition> myAliasesMap;
    private KeyDefinitionSet(StringComparer keyComparer);
    [CanBeNullAttribute]
public KeyDefinition TryGetByKey(string key);
    [CanBeNullAttribute]
public KeyDefinition TryGetByShortcut(char shortcut);
    [CanBeNullAttribute]
public KeyDefinition TryGetByAlias(string alias);
    public ISet`1<KeyDefinition> ToSet();
    public static Builder CaseSensitive();
    public static Builder CaseInsensitive();
}
[ExtensionAttribute]
public static class JetBrains.Util.CommandLineMapper.OptionFormatterExtension : object {
    [ExtensionAttribute]
public static string FormatName(IOptionFormatter formatter, Expression`1<Func`2<TOptions, TValue>> fieldPicker);
    [ExtensionAttribute]
public static bool IsKeyed(IOptionFormatter formatter, string argument);
    private static IMappedMember GetMappedMember(Expression`1<Func`2<TOptions, TValue>> memberPicker);
}
public class JetBrains.Util.CommandLineMapper.PredefinedOptionsOrder : object {
    public static int RequiredNonKeyed;
    public static int OptionalNonKeyed;
    public static int RequiredKeyed;
    public static int OptionalKeyed;
    public static int Command;
    public static int NonKeyedTail;
}
public class JetBrains.Util.CommandLineMapper.UsageExample : object {
    [CompilerGeneratedAttribute]
private object <Options>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HelpText>k__BackingField;
    [CanBeNullAttribute]
public object Options { get; private set; }
    [CanBeNullAttribute]
public string HelpText { get; private set; }
    public UsageExample(object options, string helpText);
    [CompilerGeneratedAttribute]
public object get_Options();
    [CompilerGeneratedAttribute]
private void set_Options(object value);
    [CompilerGeneratedAttribute]
public string get_HelpText();
    [CompilerGeneratedAttribute]
private void set_HelpText(string value);
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Util.CommandLineMapper.WildcardedPath : object {
    private string myValue;
    public int Count { get; }
    public FileSystemPath Item { get; }
    public WildcardedPath(string value);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IEnumerator`1<FileSystemPath> GetEnumerator();
    public sealed virtual int get_Count();
    public sealed virtual FileSystemPath get_Item(int index);
    public virtual string ToString();
}
public static class JetBrains.Util.CompanySpecificFolderLocations : object {
    public static string JET_LOCAL_APPDATA_DIR;
    public static string JET_ROAMING_APPDATA_DIR;
    public static string JET_TEMP_DIR;
    private static Lazy`1<FileSystemPath> ourLocalAppData;
    private static Lazy`1<FileSystemPath> ourRoamingAppData;
    private static Lazy`1<FileSystemPath> ourTemp;
    [CompilerGeneratedAttribute]
private static Func`1<FileSystemPath> CS$<>9__CachedAnonymousMethodDelegate3;
    [CompilerGeneratedAttribute]
private static Func`1<FileSystemPath> CS$<>9__CachedAnonymousMethodDelegate4;
    [CompilerGeneratedAttribute]
private static Func`1<FileSystemPath> CS$<>9__CachedAnonymousMethodDelegate5;
    [NotNullAttribute]
public static FileSystemPath LocalAppdata { get; }
    [NotNullAttribute]
public static FileSystemPath RoamingAppdata { get; }
    [NotNullAttribute]
public static FileSystemPath TempFolder { get; }
    private static CompanySpecificFolderLocations();
    public static FileSystemPath get_LocalAppdata();
    public static FileSystemPath get_RoamingAppdata();
    public static FileSystemPath get_TempFolder();
    [CompilerGeneratedAttribute]
private static FileSystemPath <.cctor>b__0();
    [CompilerGeneratedAttribute]
private static FileSystemPath <.cctor>b__1();
    [CompilerGeneratedAttribute]
private static FileSystemPath <.cctor>b__2();
}
public class JetBrains.Util.Comparator`1 : MulticastDelegate {
    public Comparator`1(object object, IntPtr method);
    public virtual int Invoke(T x, T y);
    public virtual IAsyncResult BeginInvoke(T x, T y, AsyncCallback callback, object object);
    public virtual int EndInvoke(IAsyncResult result);
}
public static class JetBrains.Util.Compression.Crc32Helper : object {
    private static UInt32[] ourTable;
    private static Crc32Helper();
    public static UInt32 CalculateCrc32(Byte[] bytes, int start, int count);
    public static UInt32 UpdateCrc32(UInt32 crc32, Byte[] bytes, int start, int count);
}
public class JetBrains.Util.ConcurrentUserDataHolder : object {
    [NotNullAttribute]
private ConcurrentDictionary`2<object, object> myKeys;
    [CompilerGeneratedAttribute]
private static Func`2<KeyValuePair`2<object, object>, KeyValuePair`2<object, object>> CS$<>9__CachedAnonymousMethodDelegate6;
    public sealed virtual T GetData(Key`1<T> key);
    public sealed virtual void PutData(Key`1<T> key, T value);
    public sealed virtual T GetOrCreateDataUnderLock(Key`1<T> key, Func`1<T> factory);
    public sealed virtual T GetOrCreateDataUnderLock(Key`1<T> key, TState state, Func`2<TState, T> factory);
    public sealed virtual IEnumerable`1<KeyValuePair`2<object, object>> EnumerateData();
    [CompilerGeneratedAttribute]
private static object <GetOrCreateDataUnderLock>b__2(object _);
    [CompilerGeneratedAttribute]
private static object <GetOrCreateDataUnderLock>b__4(object _);
    [CompilerGeneratedAttribute]
private static KeyValuePair`2<object, object> <EnumerateData>b__5(KeyValuePair`2<object, object> x);
}
[FlagsAttribute]
public enum JetBrains.Util.Console.ConsoleColor : Enum {
    public short value__;
    public static ConsoleColor Black;
    public static ConsoleColor Blue;
    public static ConsoleColor Green;
    public static ConsoleColor Cyan;
    public static ConsoleColor Red;
    public static ConsoleColor Violet;
    public static ConsoleColor Yellow;
    public static ConsoleColor White;
    public static ConsoleColor Intensified;
    public static ConsoleColor Normal;
    public static ConsoleColor BlackBG;
    public static ConsoleColor BlueBG;
    public static ConsoleColor GreenBG;
    public static ConsoleColor CyanBG;
    public static ConsoleColor RedBG;
    public static ConsoleColor VioletBG;
    public static ConsoleColor YellowBG;
    public static ConsoleColor WhiteBG;
    public static ConsoleColor IntensifiedBG;
    public static ConsoleColor Underline;
    public static ConsoleColor ReverseVideo;
}
public enum JetBrains.Util.Console.ConsoleFlashMode : Enum {
    public int value__;
    public static ConsoleFlashMode NoFlashing;
    public static ConsoleFlashMode FlashOnce;
    public static ConsoleFlashMode FlashUntilResponse;
}
public class JetBrains.Util.Console.ConsoleLoggerListener : object {
    [CompilerGeneratedAttribute]
private ILayout <Layout>k__BackingField;
    public ILayout Layout { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual ILayout get_Layout();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Layout(ILayout value);
    public sealed virtual void OnLogEvent(LogEvent logEvent);
}
public class JetBrains.Util.Console.ConsoleWriter : TextWriter {
    private TextWriter myWriter;
    private ConsoleColor myColor;
    private ConsoleFlashMode myFlashing;
    private bool myBeep;
    public ConsoleColor Color { get; public set; }
    public ConsoleFlashMode FlashMode { get; public set; }
    public bool BeepOnWrite { get; public set; }
    public Encoding Encoding { get; }
    public ConsoleWriter(TextWriter writer, ConsoleColor color, ConsoleFlashMode mode, bool beep);
    public ConsoleColor get_Color();
    public void set_Color(ConsoleColor value);
    public ConsoleFlashMode get_FlashMode();
    public void set_FlashMode(ConsoleFlashMode value);
    public bool get_BeepOnWrite();
    public void set_BeepOnWrite(bool value);
    public virtual Encoding get_Encoding();
    protected void Flash();
    public virtual void Write(char value);
    public virtual void Write(string value);
    public virtual void Write(Char[] buffer, int index, int count);
}
public class JetBrains.Util.Console.Coord : ValueType {
    public short X;
    public short Y;
}
public class JetBrains.Util.Console.MyConsole : object {
    private static int WS_POPUP;
    private static int WS_OVERLAPPED;
    private static int WS_CHILD;
    private static int WS_MINIMIZE;
    private static int WS_VISIBLE;
    private static int WS_DISABLED;
    private static int WS_CLIPSIBLINGS;
    private static int WS_CLIPCHILDREN;
    private static int WS_MAXIMIZE;
    private static int WS_CAPTION;
    private static int WS_BORDER;
    private static int WS_DLGFRAME;
    private static int WS_VSCROLL;
    private static int WS_HSCROLL;
    private static int WS_SYSMENU;
    private static int WS_THICKFRAME;
    private static int WS_GROUP;
    private static int WS_TABSTOP;
    private static int WS_MINIMIZEBOX;
    private static int WS_MAXIMIZEBOX;
    private static int WS_TILED;
    private static int WS_ICONIC;
    private static int WS_SIZEBOX;
    private static int WS_OVERLAPPEDWINDOW;
    private static int WS_TILEDWINDOW;
    private static int GWL_STYLE;
    private static int SW_HIDE;
    private static int SW_SHOWNORMAL;
    private static int SW_NORMAL;
    private static int SW_SHOWMINIMIZED;
    private static int SW_SHOWMAXIMIZED;
    private static int SW_MAXIMIZE;
    private static int SW_SHOWNOACTIVATE;
    private static int SW_SHOW;
    private static int SW_MINIMIZE;
    private static int SW_SHOWMINNOACTIVE;
    private static int SW_SHOWNA;
    private static int SW_RESTORE;
    private static int SW_SHOWDEFAULT;
    private static int SW_MAX;
    private static int EMPTY;
    private static int CONSOLE_TEXTMODE_BUFFER;
    private static int FLASHW_STOP;
    private static int FLASHW_CAPTION;
    private static int FLASHW_TRAY;
    private static int FLASHW_ALL;
    private static int FLASHW_TIMER;
    private static int FLASHW_TIMERNOFG;
    private static int _DefaultConsoleBufferSize;
    private static int FOREGROUND_BLUE;
    private static int FOREGROUND_GREEN;
    private static int FOREGROUND_RED;
    private static int FOREGROUND_INTENSITY;
    private static int BACKGROUND_BLUE;
    private static int BACKGROUND_GREEN;
    private static int BACKGROUND_RED;
    private static int BACKGROUND_INTENSITY;
    private static int COMMON_LVB_REVERSE_VIDEO;
    private static int COMMON_LVB_UNDERSCORE;
    private static int GENERIC_READ;
    private static int GENERIC_WRITE;
    private static int FILE_SHARE_READ;
    private static int FILE_SHARE_WRITE;
    private static int STD_INPUT_HANDLE;
    private static int STD_OUTPUT_HANDLE;
    private static int STD_ERROR_HANDLE;
    private static int SWP_NOSIZE;
    private static int SWP_NOMOVE;
    private static int SWP_NOZORDER;
    private static int SWP_NOREDRAW;
    private static int SWP_NOACTIVATE;
    private static IntPtr ourBuffer;
    private static bool ourInitialized;
    private static bool ourBreakHit;
    private static HandlerRoutine Break;
    public static bool Visible { get; public set; }
    public static string Title { get; public set; }
    public static IntPtr Handle { get; }
    public static IntPtr ParentHandle { get; public set; }
    public static IntPtr Buffer { get; }
    public static Coord CursorPosition { get; public set; }
    public static SmallRect ScreenSize { get; }
    public static Coord BufferSize { get; }
    public static Coord MaximumScreenSize { get; }
    private static ConsoleScreenBufferInfo Info { get; }
    public static ConsoleColor Color { get; public set; }
    public static bool CtrlBreakPressed { get; }
    public static TextWriter Error { get; }
    public static TextReader In { get; }
    public static TextWriter Out { get; }
    private static void FlashWindowEx(FlashWInfo& info);
    private static void MessageBeep(int type);
    private static int SetWindowLong(IntPtr hWnd, int nIndex, int newValue);
    private static int GetWindowLong(IntPtr hWnd, int nIndex);
    private static bool AllocConsole();
    private static bool FreeConsole();
    private static bool GetConsoleScreenBufferInfo(IntPtr consoleOutput, ConsoleScreenBufferInfo& info);
    private static bool GetConsoleTitle(StringBuilder text, int size);
    private static IntPtr GetConsoleWindow();
    private static IntPtr GetStdHandle(int handle);
    private static int SetConsoleCursorPosition(IntPtr buffer, Coord position);
    private static int FillConsoleOutputCharacter(IntPtr buffer, char character, int length, Coord position, Int32& written);
    private static bool SetConsoleTextAttribute(IntPtr hConsoleOutput, ConsoleColor wAttributes);
    private static bool SetConsoleTitle(string lpConsoleTitle);
    private static bool SetConsoleCtrlHandler(HandlerRoutine routine, bool add);
    private static bool ShowWindow(IntPtr hwnd, int nCmdShow);
    private static bool IsWindowVisible(IntPtr hwnd);
    private static IntPtr CreateConsoleScreenBuffer(int access, int share, IntPtr security, int flags, IntPtr reserved);
    private static bool SetConsoleActiveScreenBuffer(IntPtr handle);
    private static bool WriteConsole(IntPtr handle, string s, int length, Int32& written, IntPtr reserved);
    private static int GetConsoleCP();
    private static int GetConsoleOutputCP();
    private static bool GetConsoleMode(IntPtr handle, Int32& flags);
    private static bool SetStdHandle(int handle1, IntPtr handle2);
    private static IntPtr SetParent(IntPtr hwnd, IntPtr hwnd2);
    private static IntPtr GetParent(IntPtr hwnd);
    private static bool SetWindowPos(IntPtr hWnd, IntPtr hWndInsertAfter, int x, int y, int cx, int cy, int flags);
    private static bool GetClientRect(IntPtr hWnd, RECT& rect);
    public static void add_Break(HandlerRoutine value);
    public static void remove_Break(HandlerRoutine value);
    public static bool get_Visible();
    public static void set_Visible(bool value);
    public static void Initialize();
    public static string get_Title();
    public static void set_Title(string value);
    public static IntPtr get_Handle();
    public static IntPtr get_ParentHandle();
    public static void set_ParentHandle(IntPtr value);
    public static IntPtr get_Buffer();
    public static void Beep();
    public static void Flash(bool once);
    public static void Clear();
    public static Coord get_CursorPosition();
    public static void set_CursorPosition(Coord value);
    public static SmallRect get_ScreenSize();
    public static Coord get_BufferSize();
    public static Coord get_MaximumScreenSize();
    public void RedirectDebugOutput(bool clear, ConsoleColor color, bool beep);
    public void RedirectTraceOutput(bool clear, ConsoleColor color);
    private static ConsoleScreenBufferInfo get_Info();
    public static ConsoleColor get_Color();
    public static void set_Color(ConsoleColor value);
    public static bool get_CtrlBreakPressed();
    private static bool HandleBreak(int type);
    public void GetWindowPosition(Int32& x, Int32& y, Int32& width, Int32& height);
    public void SetWindowPosition(int x, int y, int width, int height);
    public static TextWriter get_Error();
    public static TextReader get_In();
    public static TextWriter get_Out();
    public static Stream OpenStandardInput();
    public static Stream OpenStandardInput(int bufferSize);
    public static Stream OpenStandardError();
    public static Stream OpenStandardError(int bufferSize);
    public static Stream OpenStandardOutput();
    public static Stream OpenStandardOutput(int bufferSize);
    public static void SetIn(TextReader newIn);
    public static void SetOut(TextWriter newOut);
    public static void SetError(TextWriter newError);
    public static int Read();
    public static string ReadLine();
    public static void WriteLine();
    public static void WriteLine(bool value);
    public static void WriteLine(char value);
    public static void WriteLine(Char[] buffer);
    public static void WriteLine(Char[] buffer, int index, int count);
    public static void WriteLine(decimal value);
    public static void WriteLine(double value);
    public static void WriteLine(float value);
    public static void WriteLine(int value);
    public static void WriteLine(UInt32 value);
    public static void WriteLine(long value);
    public static void WriteLine(ulong value);
    public static void WriteLine(object value);
    public static void WriteLine(string value);
    public static void WriteLine(string format, object arg0);
    public static void WriteLine(string format, object arg0, object arg1);
    public static void WriteLine(string format, object arg0, object arg1, object arg2);
    public static void WriteLine(string format, Object[] arg);
    public static void Write(string format, object arg0);
    public static void Write(string format, object arg0, object arg1);
    public static void Write(string format, object arg0, object arg1, object arg2);
    public static void Write(string format, Object[] arg);
    public static void Write(bool value);
    public static void Write(char value);
    public static void Write(Char[] buffer);
    public static void Write(Char[] buffer, int index, int count);
    public static void Write(double value);
    public static void Write(decimal value);
    public static void Write(float value);
    public static void Write(int value);
    public static void Write(UInt32 value);
    public static void Write(long value);
    public static void Write(ulong value);
    public static void Write(object value);
    public static void Write(string value);
    public static int LaunchNotepadDialog(string arguments);
}
public static class JetBrains.Util.Console.OutputUtil : object {
    public static object mySync;
    private static bool ourColorOutput;
    private static OutputUtil();
    public static void WriteLineOutput(string text, Object[] args);
    public static void WriteLineError(string error, Object[] args);
    public static void WriteLineWarning(string warning, Object[] args);
}
[ObsoleteAttribute("Unverified piece of interop outside of Interop.WinApi.")]
internal class JetBrains.Util.ConsoleHelper : object {
    private static string KERNEL32;
    private static UInt32 ENABLE_PROCESSED_INPUT;
    private static UInt32 ENABLE_LINE_INPUT;
    private static UInt32 ENABLE_ECHO_INPUT;
    private static UInt32 ENABLE_WINDOW_INPUT;
    private static UInt32 ENABLE_MOUSE_INPUT;
    private static UInt32 ENABLE_PROCESSED_OUTPUT;
    private static UInt32 ENABLE_WRAP_AT_EOL_OUTPUT;
    private static UInt32 STD_INPUT_HANDLE;
    private static UInt32 STD_OUTPUT_HANDLE;
    private static UInt32 STD_ERROR_HANDLE;
    private static UInt32 INVALID_HANDLE_VALUE;
    private static Encoding ourEncoding;
    private static TextWriter ourStdOutWriter;
    private static TextWriter ourStdErrWriter;
    private static UInt32 ourHConsoleWindow;
    public static TextWriter Out { get; }
    public static TextWriter Error { get; }
    private static ConsoleHelper();
    private static bool AllocConsole();
    private static bool FreeConsole();
    private static UInt32 GetStdHandle(UInt32 nStdHandle);
    private static bool WriteConsole(UInt32 hConsoleOutput, string message, int nNumberOfCharsToWrite, Int32& lpNumberOfCharsWritten, IntPtr lpReserved);
    private static bool SetConsoleMode(UInt32 nConsoleHandle, UInt32 dwMode);
    private static UInt32 GetConsoleWindow();
    private static bool SetConsoleTitle(string title);
    private static UInt32 GetLastError();
    public static TextWriter get_Out();
    public static TextWriter get_Error();
    public static void Write(string message);
    public static void WriteLine(string message);
    public static void Write(string format, Object[] arg);
    public static void WriteLine(string format, Object[] arg);
    public static void Main();
}
public abstract class JetBrains.Util.ConvertableEnumPattern`1 : EnumPattern {
    private static Dictionary`2<string, ConvertableEnumPattern`1<T>> ourConstants;
    private static ConvertableEnumPattern`1();
    protected ConvertableEnumPattern`1(string name);
    [CanBeNullAttribute]
public static ConvertableEnumPattern`1<T> FromString(string name);
}
public class JetBrains.Util.ConvertableEnumPatternConverter`1 : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object source);
}
public class JetBrains.Util.Converters.JetSemanticVersionJSonConvertor : JsonConverter {
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual bool CanConvert(Type objectType);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
}
public class JetBrains.Util.Converters.VersionJSonConvertor : JsonConverter {
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual bool CanConvert(Type objectType);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
}
public class JetBrains.Util.CppProcessWrapper : object {
    public static int MaxCommandLineLength;
    private Void* myHChildStdInWr;
    private Void* myHChildStdOutWr;
    public static UInt32 INFINITE;
    public static UInt32 HANDLE_FLAG_INHERIT;
    [CompilerGeneratedAttribute]
private Void* <ProcessHandle>k__BackingField;
    [CompilerGeneratedAttribute]
private Void* <ThreadHandle>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <ProcessId>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <ExitCode>k__BackingField;
    [CompilerGeneratedAttribute]
private Stream <StdOut>k__BackingField;
    [CompilerGeneratedAttribute]
private Stream <StdIn>k__BackingField;
    public Void* ProcessHandle { get; public set; }
    public Void* ThreadHandle { get; private set; }
    public UInt32 ProcessId { get; private set; }
    public UInt32 ExitCode { get; private set; }
    public Stream StdOut { get; private set; }
    public Stream StdIn { get; private set; }
    public CppProcessWrapper(UInt32 processId);
    public CppProcessWrapper(UInt32 processId, Void* hChildStdOutWr, Void* stdOut);
    private static CppProcessWrapper();
    [CompilerGeneratedAttribute]
public Void* get_ProcessHandle();
    [CompilerGeneratedAttribute]
public void set_ProcessHandle(Void* value);
    [CompilerGeneratedAttribute]
public Void* get_ThreadHandle();
    [CompilerGeneratedAttribute]
private void set_ThreadHandle(Void* value);
    [CompilerGeneratedAttribute]
public sealed virtual UInt32 get_ProcessId();
    [CompilerGeneratedAttribute]
private void set_ProcessId(UInt32 value);
    [CompilerGeneratedAttribute]
public sealed virtual UInt32 get_ExitCode();
    [CompilerGeneratedAttribute]
private void set_ExitCode(UInt32 value);
    [CompilerGeneratedAttribute]
public sealed virtual Stream get_StdOut();
    [CompilerGeneratedAttribute]
private void set_StdOut(Stream value);
    [CompilerGeneratedAttribute]
public sealed virtual Stream get_StdIn();
    [CompilerGeneratedAttribute]
private void set_StdIn(Stream value);
    public sealed virtual void Dispose();
    public void Resume();
    public static CppProcessWrapper Start(ProcessStartinfo startInfo);
    public sealed virtual void Wait();
    public static string GetCommandLine(ProcessStartinfo startInfo);
}
public class JetBrains.Util.CultureCookie : object {
    public static CultureInfo TURKISH;
    private CultureInfo myOldCulture;
    private CultureCookie(CultureInfo newCulture);
    private static CultureCookie();
    public static IDisposable SetCulture(CultureInfo newCulture);
    public static IDisposable SetInvariantCulture();
    public static void SetInvariantCulture(Lifetime lifetime);
    public sealed virtual void Dispose();
}
public class JetBrains.Util.dataStructures.AggregatedSet`2 : object {
    private object myLockObject;
    private OneToSetMap`2<T, TProvider> myData;
    private Dictionary`2<TProvider, JetHashSet`1<T>> myProviderData;
    [CompilerGeneratedAttribute]
private ISignal`1<ChangedArgs<T, TProvider>> <Changed>k__BackingField;
    public ISignal`1<ChangedArgs<T, TProvider>> Changed { get; private set; }
    public AggregatedSet`2(Lifetime lifetime);
    [CompilerGeneratedAttribute]
public ISignal`1<ChangedArgs<T, TProvider>> get_Changed();
    [CompilerGeneratedAttribute]
private void set_Changed(ISignal`1<ChangedArgs<T, TProvider>> value);
    public JetHashSet`1<T> GetData();
    public void OnProviderDataChanged(TProvider provider, JetHashSet`1<T> newData);
    private bool AddProviderItem(T item, TProvider provider);
    private bool RemoveProviderItem(T item, TProvider provider);
    [CompilerGeneratedAttribute]
private void <.ctor>b__0();
    [CompilerGeneratedAttribute]
private void <.ctor>b__1();
}
[ExtensionAttribute]
public static class JetBrains.Util.dataStructures.AggregatedSetEx : object {
    [ExtensionAttribute]
public static void OnProviderDataChanged(AggregatedSet`2<T, TProvider> aggregatedSet, TProvider provider, T[] newData);
    [ExtensionAttribute]
public static void OnProviderDataChanged(AggregatedSet`2<T, TProvider> aggregatedSet, TProvider provider, IEnumerable`1<T> newData);
}
public class JetBrains.Util.dataStructures.BankSwitchingMemoryStreamSimple : Stream {
    private FrugalLocalList`1<Substream> mySubstreamsFixedLength;
    [CanBeNullAttribute]
private Substream mySubstreamAppending;
    public static UInt32 DefaultBankSizeExponent;
    public static UInt32 DefaultOpenBanksLimit;
    private UInt32 myCurrentGeneration;
    private Void* myMmf;
    [CanBeNullAttribute]
private Bank myMruBank;
    private ulong myPosition;
    private StateFlags myStateFlags;
    private ulong myWrittenLength;
    private List`1<Bank> myBanks;
    private UInt32 myBankSizeExponent;
    private ulong myLengthLimit;
    private Lifetime myLifetime;
    private UInt32 myOpenBanksLimit;
    public ILogger Logger;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public ulong LengthLimit { get; }
    public long Position { get; public set; }
    private bool JetBrains.Util.Collections.IFreezable.IsFrozen { get; }
    public bool CanOpenSubstreamForAppendingNow { get; }
    public BankSwitchingMemoryStreamSimple(Lifetime lifetime, ulong qwLengthLimit, BankSpec bankspec);
    private BankSwitchingMemoryStreamSimple(Lifetime lifetime, Void* hExternalMmf, ulong qwLengthLimit, ulong qwWrittenLength, BankSpec bankspec);
    private static BankSwitchingMemoryStreamSimple();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public ulong get_LengthLimit();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    [NotNullAttribute]
public static BankSwitchingMemoryStreamSimple Attach(Lifetime lifetime, Void* hExistingMmf, ulong qwMmfSize, ulong qwWrittenLength, BankSpec bankspec);
    [NotNullAttribute]
public static Void* CreateStandardMmf(Lifetime lifetime, ulong qwLengthLimit);
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public UInt32 ReadAt(ulong ulOffset, Void* pv, UInt32 cb);
    public virtual int ReadByte();
    public void ReleaseBanks();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public void SetLength(ulong value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public void WriteAt(ulong ulOffset, Void* pv, UInt32 cb);
    public virtual void WriteByte(byte value);
    private void AssertWritable();
    [NotNullAttribute]
private Bank GetBankByViewPointer(ulong qwBankStart, Bank& mru);
    private void ReleaseBank(Bank bank);
    private sealed virtual override bool JetBrains.Util.Collections.IFreezable.get_IsFrozen();
    private sealed virtual override void JetBrains.Util.Collections.IFreezable.Freeze();
    [NotNullAttribute]
public Substream OpenSubstreamFixedLength(Lifetime lifetime, ulong start, ulong length, ReadWrite rw);
    [NotNullAttribute]
public Substream OpenSubstreamForAppending(Lifetime lifetime);
    public bool get_CanOpenSubstreamForAppendingNow();
    private sealed virtual override int JetBrains.Interop.WinApi.Declarations.Interfaces.ILockBytes.ReadAt(ulong ulOffset, Void* pv, UInt32 cb, UInt32* pcbRead);
    private sealed virtual override int JetBrains.Interop.WinApi.Declarations.Interfaces.ILockBytes.WriteAt(ulong ulOffset, Void* pv, UInt32 cb, UInt32* pcbWritten);
    private sealed virtual override int JetBrains.Interop.WinApi.Declarations.Interfaces.ILockBytes.Flush();
    private sealed virtual override int JetBrains.Interop.WinApi.Declarations.Interfaces.ILockBytes.SetSize(ulong cb);
    private sealed virtual override int JetBrains.Interop.WinApi.Declarations.Interfaces.ILockBytes.LockRegion(ulong libOffset, ulong cb, UInt32 dwLockType);
    private sealed virtual override int JetBrains.Interop.WinApi.Declarations.Interfaces.ILockBytes.UnlockRegion(ulong libOffset, ulong cb, UInt32 dwLockType);
    private sealed virtual override int JetBrains.Interop.WinApi.Declarations.Interfaces.ILockBytes.Stat(STATSTG* pstatstg, UInt32 grfStatFlag);
    [CompilerGeneratedAttribute]
private void <.ctor>b__1();
    [CompilerGeneratedAttribute]
private void <.ctor>b__2();
    [CompilerGeneratedAttribute]
private object <Seek>b__14();
    [CompilerGeneratedAttribute]
private object <Seek>b__15();
    [CompilerGeneratedAttribute]
private void <OpenSubstreamForAppending>b__21();
}
public class JetBrains.Util.dataStructures.BidirectionalMapOnCompactMap`2 : object {
    private CompactMap`2<TLeft, TRight> myLeftToRightMap;
    private CompactMap`2<TRight, TLeft> myRightToLeftMap;
    public int Count { get; }
    public ICollection`1<TLeft> LeftKeys { get; }
    public IDictionary`2<TLeft, TRight> LeftToRight { get; }
    public ICollection`1<TRight> RightKeys { get; }
    public IDictionary`2<TRight, TLeft> RightToLeft { get; }
    public BidirectionalMapOnCompactMap`2(int capacity);
    public BidirectionalMapOnCompactMap`2(int capacity, IEqualityComparer`1<TLeft> leftComparer, IEqualityComparer`1<TRight> rightComparer);
    public BidirectionalMapOnCompactMap`2(IEqualityComparer`1<TLeft> leftComparer, IEqualityComparer`1<TRight> rightComparer);
    public int get_Count();
    public ICollection`1<TLeft> get_LeftKeys();
    public IDictionary`2<TLeft, TRight> get_LeftToRight();
    public ICollection`1<TRight> get_RightKeys();
    public IDictionary`2<TRight, TLeft> get_RightToLeft();
    public void Add(TLeft left, TRight right);
    public void Clear();
    public bool ContainsLeft(TLeft left);
    public bool ContainsRight(TRight right);
    public sealed virtual IEnumerator GetEnumerator();
    public TLeft GetLeftByRight(TRight right);
    public TRight GetRightByLeft(TLeft left);
    public void RemoveLeft(TLeft left);
    public void RemoveMapping(TLeft left, TRight right);
    public void RemoveRight(TRight right);
    public void SetMapping(TLeft left, TRight right, bool bIgnoreConflicts);
    public bool TryGetLeftByRight(TRight right, TLeft& left);
    public bool TryGetRightByLeft(TLeft left, TRight& right);
    private static ArgumentException CreateDuplicateLeftKeysException(TLeft left, TRight right, TRight oldRight);
    private static ArgumentException CreateDuplicateRightKeysException(TLeft left, TRight right, TLeft oldLeft);
    private sealed virtual override IEnumerator`1<KeyValuePair`2<TLeft, TRight>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TLeft,TRight>>.GetEnumerator();
}
public enum JetBrains.Util.dataStructures.Bit : Enum {
    public int value__;
    public static Bit Zero;
    public static Bit One;
}
public static class JetBrains.Util.dataStructures.Boxed : object {
    public static int Compare(Boxed`1<T> n1, Boxed`1<T> n2);
    [ComVisibleAttribute("True")]
public static bool Equals(Boxed`1<T> n1, Boxed`1<T> n2);
    public static Type TryGetUnderlyingType(Type boxedtype);
}
public class JetBrains.Util.dataStructures.Boxed`1 : object {
    [CanBeNullAttribute]
public T Value;
    public Boxed`1(T value);
    public sealed virtual bool Equals(Boxed`1<T> other);
    public sealed virtual int CompareTo(Boxed`1<T> other);
    [NotNullAttribute]
public static Boxed`1<T> op_Explicit(T value);
    public static T op_Explicit(Boxed`1<T> value);
    public static bool op_Equality(Boxed`1<T> left, Boxed`1<T> right);
    public static bool op_Inequality(Boxed`1<T> left, Boxed`1<T> right);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public enum JetBrains.Util.dataStructures.CapacityPolicy : Enum {
    public int value__;
    public static CapacityPolicy ExactFit;
    public static CapacityPolicy FibGrow;
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Util.DataStructures.ChunkArray`1 : ValueType {
    private static int MaxChunkSizeInBytes;
    private T[][] myArray;
    private int myIndexInChunkMask;
    private int myChunkLengthLog2;
    private int myChunkLength;
    private int myLength;
    public int Length { get; }
    public T Item { get; public set; }
    public ChunkArray`1(int length, int chunkLength);
    public ChunkArray`1(int length);
    private ChunkArray`1(int length, int chunkLength, bool throwIfAllocatedInLoh);
    public ChunkArray`1(ChunkArray`1<T> source);
    private static int GetAntiLohChunkLength();
    public int get_Length();
    public T get_Item(int index);
    public void set_Item(int index, T value);
    public void Fill(T item);
    private static int CalculateSizeofNode();
    private static int GetNearestLessPowOf2(int number);
    private static int GetPowOf2(int number);
    public Location<T> GetLocation(int index);
    public void Resize(int newLength);
    private void ExpandLastChunk(int size);
    public void Clear();
    public Enumerator<T> GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Util.DataStructures.ChunkHashMap`2 : object {
    private static Statistics Statistics;
    private IEqualityComparer`1<TKey> myComparer;
    private ChunkArray`1<Entry<TKey, TValue>> myEntries;
    private ChunkArray`1<int> myHashToEntryIndex;
    private int myEntriesUsed;
    private int myFirstFreeIndex;
    private int myFreeCount;
    private KeyCollection<TKey, TValue> myKeys;
    private ValueCollection<TKey, TValue> myValues;
    private int myVersion;
    public IEqualityComparer`1<TKey> Comparer { get; }
    private ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.Keys { get; }
    private ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.Values { get; }
    public KeyCollection<TKey, TValue> Keys { get; }
    public ValueCollection<TKey, TValue> Values { get; }
    private IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Keys { get; }
    private IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Values { get; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.IsReadOnly { get; }
    public TValue Item { get; public set; }
    public ChunkHashMap`2(IDictionary`2<TKey, TValue> dictionary);
    public ChunkHashMap`2(IEqualityComparer`1<TKey> comparer);
    public ChunkHashMap`2(int capacity);
    public ChunkHashMap`2(IDictionary`2<TKey, TValue> dictionary, IEqualityComparer`1<TKey> comparer);
    public ChunkHashMap`2(int capacity, IEqualityComparer`1<TKey> comparer);
    private static ChunkHashMap`2();
    public IEqualityComparer`1<TKey> get_Comparer();
    private sealed virtual override ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.get_Keys();
    private sealed virtual override ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.get_Values();
    public KeyCollection<TKey, TValue> get_Keys();
    public ValueCollection<TKey, TValue> get_Values();
    private sealed virtual override IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Keys();
    private sealed virtual override IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Values();
    public sealed virtual int get_Count();
    public sealed virtual void Add(TKey key, TValue value);
    public sealed virtual bool Remove(TKey key);
    public sealed virtual void Clear();
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Add(KeyValuePair`2<TKey, TValue> item);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Contains(KeyValuePair`2<TKey, TValue> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.CopyTo(KeyValuePair`2[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Remove(KeyValuePair`2<TKey, TValue> item);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.get_IsReadOnly();
    public sealed virtual bool ContainsKey(TKey key);
    public bool ContainsValue(TValue value);
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    public bool IsEmpty();
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    private sealed virtual override IEnumerator`1<KeyValuePair`2<TKey, TValue>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TValue>>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public Enumerator<TKey, TValue> GetEnumerator();
    private void RemoveEntry(int entryIndex, int prevIndex);
    private bool CompareKey(TKey key, int entryIndex);
    private int GetEntryIndex(TKey key);
    private void Initialize(int capacity);
    private void Insert(TKey key, TValue value, bool add);
    public void Compact();
    private void Expand();
    private void Resize(int newCapacity);
}
[DebuggerTypeProxyAttribute("JetBrains.Util.DataStructures.ChunkHashSetDebugView`1")]
[DebuggerDisplayAttribute("Count = {Count}")]
public class JetBrains.Util.DataStructures.ChunkHashSet`1 : object {
    private static Statistics Statistics;
    [NotNullAttribute]
private IEqualityComparer`1<T> myComparer;
    private ChunkArray`1<Entry<T>> myEntries;
    private ChunkArray`1<int> myHashToEntryIndex;
    private int myEntriesUsed;
    private int myFirstFreeIndex;
    private int myFreeCount;
    private int myVersion;
    [NotNullAttribute]
public IEqualityComparer`1<T> Comparer { get; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    public ChunkHashSet`1(IEnumerable`1<T> enumerable);
    public ChunkHashSet`1(IEqualityComparer`1<T> comparer);
    public ChunkHashSet`1(int capacity);
    public ChunkHashSet`1(IEnumerable`1<T> enumerable, IEqualityComparer`1<T> comparer);
    [EditorBrowsableAttribute("1")]
public ChunkHashSet`1(ICollection`1<T> collection, IEqualityComparer`1<T> comparer);
    public ChunkHashSet`1(int capacity, IEqualityComparer`1<T> comparer);
    private static ChunkHashSet`1();
    public IEqualityComparer`1<T> get_Comparer();
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    public bool Add(T element);
    private bool AddImpl(T element, Func`2<T, T> elementConverter, T& storedElement);
    public sealed virtual bool Remove(T element);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T element);
    public T GetValue(T key);
    public T Intern(T key, Func`2<T, T> elementFactory);
    public bool TryGetValue(T key, T& value);
    public void CopyTo(T[] array);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public void CopyTo(T[] array, int arrayIndex, int count);
    public void UnionWith(IEnumerable`1<T> other);
    private void IntersectWith(ICollection`1<T> other);
    private bool IsSubsetOf(ICollection`1<T> other);
    public void IntersectWith(IEnumerable`1<T> other);
    public bool SetEquals(IEnumerable`1<T> other);
    [EditorBrowsableAttribute("1")]
public bool SetEquals(ChunkHashSet`1<T> other);
    private bool SetEqualsImpl(IEnumerable`1<T> other);
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public ElementEnumerator<T> GetEnumerator();
    public int RemoveWhere(Func`2<T, bool> predicate);
    public bool IsSubsetOf(IEnumerable`1<T> other);
    public bool IsSupersetOf(IEnumerable`1<T> other);
    [EditorBrowsableAttribute("1")]
public bool IsSupersetOf(ICollection`1<T> other);
    [EditorBrowsableAttribute("1")]
public bool IsSupersetOf(ChunkHashSet`1<T> other);
    private bool IsSupersetOfImpl(IEnumerable`1<T> other);
    private bool IsGreaterSet(ChunkHashSet`1<T> set);
    public bool Overlaps(IEnumerable`1<T> other);
    private static bool CollectionContainsAll(ICollection`1<T> collection, IEnumerable`1<T> other);
    public void ExceptWith(IEnumerable`1<T> other);
    private void RemoveEntry(int entryIndex, int prevIndex);
    private int GetEntryIndex(T key);
    private void Initialize(int capacity);
    public void Compact();
    private void Expand();
    private void Resize(int newCapacity);
    [NotNullAttribute]
public T[] ToArray();
}
internal class JetBrains.Util.DataStructures.ChunkHashSetDebugView`1 : object {
    private ChunkHashSet`1<T> myHashSet;
    [DebuggerBrowsableAttribute("3")]
public T[] Items { get; }
    public ChunkHashSetDebugView`1(ChunkHashSet`1<T> set);
    public T[] get_Items();
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Util.DataStructures.ChunkPackedIntArray : object {
    private static int MAX_CHUNK_SIZE;
    private int myLength;
    private int myValueBits;
    private int myStandardChunkLength;
    private UncheckedPackedIntArray[] myChunks;
    public UInt32[] Item { get; public set; }
    public int Length { get; }
    public int ValueBits { get; }
    public int ValueInts { get; }
    public ChunkPackedIntArray(int length, int valueBits);
    public UInt32[] get_Item(int index);
    public void set_Item(int index, UInt32[] value);
    public UInt32 GetItem(int index, int iSubIndex);
    public int get_Length();
    public int get_ValueBits();
    public int get_ValueInts();
    public static ChunkPackedIntArray IncreaseValueBits(ChunkPackedIntArray oldArray, int newValueBits);
    public void Clear();
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Util.DataStructures.ChunkSparseArray`1 : object {
    private static int myChunkSize;
    private int myCount;
    private T[][] myChunks;
    private int myLastChunkSize;
    public T Item { get; public set; }
    public ChunkSparseArray`1(int initialSize);
    public T get_Item(int index);
    public void set_Item(int index, T value);
}
public class JetBrains.Util.DataStructures.CompactIntToIntMap : CompactMapBase`4<int, int, CompactIntToIntMapStorage, object> {
    public CompactIntToIntMap(int intialSlotCount, double maxLoadFactor);
    protected virtual CompactIntToIntMapStorage CreateStorage(int slotCount);
    protected virtual SlotState<int, int, CompactIntToIntMapStorage, object> GetSlotState(CompactIntToIntMapStorage storage, int index, Int32& key);
    protected virtual object GetSlotData(CompactIntToIntMapStorage storage, int index);
    protected virtual int GetValue(CompactIntToIntMapStorage storage, int index, object data);
    protected virtual void SetValue(CompactIntToIntMapStorage storage, int index, int value);
    protected virtual void SetKeyAndValue(CompactIntToIntMapStorage storage, int index, int key, int value);
    protected virtual void RemoveValue(CompactIntToIntMapStorage storage, int index);
    protected virtual void ClearStorage(CompactIntToIntMapStorage storage);
}
public class JetBrains.Util.DataStructures.CompactIntToIntMapStorage : ValueType {
    public ChunkList`1<int> Keys;
    public ChunkList`1<int> Values;
    public ChunkList`1<int> SlotStates;
    public CompactIntToIntMapStorage(int length);
    public int GetSlotState(int index);
    public void SetSlotState(int index, int state);
}
public class JetBrains.Util.dataStructures.CompactionPolicy : ValueType {
    public static CompactionPolicy DefaultFibGrow;
    public static CompactionPolicy DefaultExactFit;
    private float myFreeToAllSizeRatio;
    private int myFreeCount;
    private CompactionPolicyEnum myFlags;
    public float FreeToAllSizeRatio { get; }
    public int FreeCount { get; }
    public CompactionPolicyEnum Flags { get; }
    public bool CompactToExactSizeOnManualCompact { get; }
    public CompactionPolicy(CompactionPolicyEnum flags, int freeCount);
    public CompactionPolicy(CompactionPolicyEnum flags, float freeToAllSizeRatio);
    private static CompactionPolicy();
    public float get_FreeToAllSizeRatio();
    public int get_FreeCount();
    public CompactionPolicyEnum get_Flags();
    public bool get_CompactToExactSizeOnManualCompact();
}
[FlagsAttribute]
public enum JetBrains.Util.dataStructures.CompactionPolicyEnum : Enum {
    public int value__;
    public static CompactionPolicyEnum Manual;
    public static CompactionPolicyEnum Auto;
    public static CompactionPolicyEnum CompactWhenEmptyToAllRatioTooHigh;
    public static CompactionPolicyEnum CompactWhenFreeCountTooHigh;
    public static CompactionPolicyEnum CompactLastChunkOnManualCompact;
    public static CompactionPolicyEnum CompactToExactFitOnManualCompact;
}
public class JetBrains.Util.dataStructures.ConcatCollection`1 : ValueType {
    [NotNullAttribute]
private IReadOnlyCollection`1<TValue> myFirstCollection;
    [NotNullAttribute]
private IReadOnlyCollection`1<TValue> mySecondCollection;
    public int Count { get; }
    public ConcatCollection`1(IReadOnlyCollection`1<TValue> firstCollection, IReadOnlyCollection`1<TValue> secondCollection);
    public sealed virtual IEnumerator`1<TValue> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual int get_Count();
}
public class JetBrains.Util.dataStructures.ConciseBitArray : SafeDisposable {
    public static int DefaultCapacity;
    public static int DefaultCompactifyThreshold;
    private static int BytesInChunk;
    private static int BitsInChunk;
    private static int BitsInCompressedChunk;
    private static int FillBit;
    private static int EmptyChunkMarkerMask;
    private static int BitsForPollution;
    private static int CompressBitMask;
    private static int FillBitMask;
    private static int ChunksNumberMask;
    private static int PollutionMask;
    private static int PollutionShift;
    private static int FillBitShift;
    public static int MaxSize;
    private int myArrayCapacity;
    private Int32* myArray;
    private int myNumberOfChunksAddedSinceLastCompactify;
    public static IUnsafeMarshaller`1<ConciseBitArray> Marshaller;
    [CompilerGeneratedAttribute]
private int <CompactifyThreshold>k__BackingField;
    public int CompactifyThreshold { get; public set; }
    public int Capacity { get; }
    public Int32* Ptr { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    private ConciseBitArray(int initialCapacity);
    private static ConciseBitArray();
    [CompilerGeneratedAttribute]
public int get_CompactifyThreshold();
    [CompilerGeneratedAttribute]
public void set_CompactifyThreshold(int value);
    public int get_Capacity();
    public Int32* get_Ptr();
    public static ConciseBitArray CreateEmpty(int initialCapacity);
    public static ConciseBitArray CreateFromExisting(int capacity, Int32* array);
    private static int ProduceLiteralWord(int word);
    private static int ProduceFillWord(int numOfChunks, Bit fill, int pollution);
    private static int MultiplyToBitsInCompressedChunk(int x);
    public bool Get(int i);
    public bool GetAndSet(int i);
    public bool GetAndUnset(int i);
    public void Set(int i);
    public void Unset(int i);
    private void Set(int i, Bit bit);
    private bool GetAndSet(int i, Bit bit);
    private void ReplaceByLiteral(Int32* ptr, int compressedChunksInThisFillChunk, int literal, int chunkNumber);
    private void ShiftChunksRight(Int32* ptr);
    private void ShiftChunksRight2(Int32* ptr);
    private void EnsureCapacity();
    public int Compactify(bool reduceCapacity);
    public int Cardinality();
    private void Realloc(int newCapacity);
    public int NumberOfChunks();
    protected virtual void DisposeUnmanagedResources();
    public IEnumerable`1<int> AsZeroEnumerable();
    public sealed virtual IEnumerator`1<int> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private static string Fmt(int x, int space);
    private static string ChunkToString(int chunk);
    public sealed virtual void Add(int item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(int item);
    public sealed virtual void CopyTo(Int32[] array, int arrayIndex);
    public sealed virtual bool Remove(int item);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public static void Write(UnsafeWriter writer, ConciseBitArray value);
    public static ConciseBitArray Read(UnsafeReader reader);
}
public class JetBrains.Util.dataStructures.ConcurrentCachingEnumerable`1 : object {
    private object myLockObject;
    private IEnumerable`1<T> myEnumerable;
    private IEnumerator`1<T> myEnumerator;
    private LocalList`1<T> myCachedItems;
    public ConcurrentCachingEnumerable`1(IEnumerable`1<T> enumerable);
    private bool TryEnsureItemAt(int index);
    private T GetItemAt(int index);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[ExtensionAttribute]
public static class JetBrains.Util.dataStructures.ConcurrentCachingEnumerableEx : object {
    [ExtensionAttribute]
public static ConcurrentCachingEnumerable`1<T> ToCachingEnumerable(IEnumerable`1<T> enumerable);
}
public class JetBrains.Util.DataStructures.ConvertedCollection`2 : ConvertedEnumerable`2<T1, T2> {
    private ICollection`1<T1> myOriginal;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public ConvertedCollection`2(ICollection`1<T1> original, Converter`2<T1, T2> converter);
    public sealed virtual void Add(T2 item);
    public sealed virtual void Clear();
    public sealed virtual bool Remove(T2 item);
    public sealed virtual bool Contains(T2 item);
    public sealed virtual void CopyTo(T2[] array, int arrayIndex);
    private static void CopyTo(IEnumerable`1<T> collection, T[] array, int index);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
}
public class JetBrains.Util.DataStructures.ConvertedEnumerable`2 : object {
    private IEnumerator`1<T1> myOriginal;
    private Converter`2<T1, T2> myConverter;
    public ConvertedEnumerable`2(IEnumerator`1<T1> original, Converter`2<T1, T2> converter);
    public ConvertedEnumerable`2(IEnumerable`1<T1> original, Converter`2<T1, T2> converter);
    public sealed virtual IEnumerator`1<T2> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class JetBrains.Util.DataStructures.ConvertedEnumerator`2 : object {
    private IEnumerator`1<T1> myOriginal;
    private Converter`2<T1, T2> myConverter;
    public T2 Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    public ConvertedEnumerator`2(IEnumerator`1<T1> original, Converter`2<T1, T2> converter);
    public sealed virtual void Dispose();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
    public sealed virtual T2 get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
}
public class JetBrains.Util.DataStructures.DataIntern`1 : object {
    private ChunkHashSet`1<T> myIntern;
    public DataIntern`1(IEqualityComparer`1<T> comparer);
    public DataIntern`1(int capacity, IEqualityComparer`1<T> comparer);
    public T Intern(T data);
    public bool TryGet(T data, T& internedData);
    public void Compact();
    public bool IsEmpty();
    public void Clear();
}
public class JetBrains.Util.DataStructures.EnumeratorWithEnd`1 : object {
    private bool myEndReached;
    private IEnumerator`1<T> myUnderlyingEnumerator;
    private object System.Collections.IEnumerator.Current { get; }
    public T Current { get; }
    public bool AtEnd { get; }
    public EnumeratorWithEnd`1(IEnumerator`1<T> underlyingEnumerator);
    public sealed virtual void Dispose();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual T get_Current();
    public sealed virtual bool get_AtEnd();
}
public static class JetBrains.Util.dataStructures.FibFinder : object {
    public static Int32[] FibSeq;
    private static FibFinder();
    private static int SearchHiIndexFor(int x, int lo, int hi);
    public static int NextFib(int x);
    public static int NextFibIndex(int x);
}
public static class JetBrains.Util.dataStructures.FinalizerManager : object {
    public static Statistics Statistics;
    private static FinalizerManager();
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Util.DataStructures.HybridCollection`1 : ValueType {
    public static HybridCollection`1<T> Empty;
    private T myItem;
    private IList`1<T> myItems;
    [CompilerGeneratedAttribute]
private static Func`2<T, bool> CS$<>9__CachedAnonymousMethodDelegate2;
    public bool IsEmpty { get; }
    public int Count { get; }
    [NotNullAttribute]
public T Item { get; }
    public HybridCollection`1(T item);
    private HybridCollection`1(IList`1<T> itemsList, IEnumerable`1<T> items);
    public HybridCollection`1(IEnumerable`1<T> items);
    public HybridCollection`1(IList`1<T> items);
    public HybridCollection`1(T[] items);
    private static HybridCollection`1();
    public bool get_IsEmpty();
    public sealed virtual int get_Count();
    public sealed virtual T get_Item(int i);
    [PureAttribute]
public int IndexOf(T item);
    [PureAttribute]
public bool Contains(T item);
    [PureAttribute]
public HybridCollection`1<T> Add(T item);
    [PureAttribute]
public HybridCollection`1<T> Add(HybridCollection`1<T> collection);
    [PureAttribute]
public HybridCollection`1<T> Add(IList`1<T> collection);
    [PureAttribute]
public HybridCollection`1<TCast> OfType();
    [PureAttribute]
public HybridCollection`1<T> Where(Func`2<T, bool> predicate);
    [PureAttribute]
public bool Any();
    [PureAttribute]
public bool Any(Func`2<T, bool> predicate);
    [PureAttribute]
[NotNullAttribute]
public T First();
    [PureAttribute]
[NotNullAttribute]
public T Last();
    [CanBeNullAttribute]
[PureAttribute]
public T FirstOrDefault();
    [CanBeNullAttribute]
[PureAttribute]
public T FirstOrDefault(Func`2<T, bool> predicate);
    [PureAttribute]
[CanBeNullAttribute]
public T LastOrDefault();
    [PureAttribute]
[CanBeNullAttribute]
public T LastOrDefault(Func`2<T, bool> predicate);
    [NotNullAttribute]
[PureAttribute]
public IList`1<T> ResultingList();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    [PureAttribute]
public HybridCollectionEnumerator`1<T> GetEnumerator();
    [CompilerGeneratedAttribute]
private static bool <.ctor>b__1(T d);
}
public class JetBrains.Util.DataStructures.HybridCollectionEnumerator`1 : ValueType {
    private HybridCollection`1<T> myOwner;
    private int myIndex;
    private T myCurrent;
    [NotNullAttribute]
public T Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    internal HybridCollectionEnumerator`1(HybridCollection`1<T> owner);
    public sealed virtual bool MoveNext();
    public sealed virtual T get_Current();
    [ConditionalAttribute("JET_MODE_ASSERT")]
private void AssertIndex();
    public sealed virtual void Dispose();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual void Reset();
}
public class JetBrains.Util.DataStructures.HybridDistinctCollection`1 : ValueType {
    private static int LinearThreshold;
    public static HybridDistinctCollection`1<T> Empty;
    private object myData;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public bool IsEmpty { get; }
    public HybridDistinctCollection`1(T data);
    private static HybridDistinctCollection`1();
    public bool Add(T item);
    public void Clear();
    public int get_Count();
    public bool get_IsReadOnly();
    [PureAttribute]
public HybridDistinctCollection`1<T> Clone();
    [PureAttribute]
public bool Contains(T item);
    public void CopyTo(T[] array, int arrayIndex);
    [PureAttribute]
public T[] ToArray();
    public bool get_IsEmpty();
    public bool Remove(T item);
    [PureAttribute]
public Enumerator<T> GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public interface JetBrains.Util.DataStructures.IEnumeratorWithEnd`1 {
    public bool AtEnd { get; }
    public abstract virtual bool get_AtEnd();
}
public class JetBrains.Util.DataStructures.ImmutableStack`1 : object {
    private T myHead;
    [CanBeNullAttribute]
private ImmutableStack`1<T> myTail;
    [NotNullAttribute]
public static ImmutableStack`1<T> Empty;
    public bool IsEmpty { get; }
    private ImmutableStack`1(T head, ImmutableStack`1<T> tail);
    private static ImmutableStack`1();
    public bool get_IsEmpty();
    public int GetCount();
    [PureAttribute]
public T Peek();
    [NotNullAttribute]
[PureAttribute]
public ImmutableStack`1<T> Pop();
    [PureAttribute]
[NotNullAttribute]
public ImmutableStack`1<T> Push(T value);
    [ContractAnnotationAttribute("=> halt")]
private static void ThrowEmptyStack();
    [PureAttribute]
public Enumerator<T> GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [PureAttribute]
[NotNullAttribute]
private IEnumerator`1<T> GetEnumeratorImpl();
}
public class JetBrains.Util.dataStructures.IntSet : object {
    public static int DefaultMarker;
    private static int NextBucketShift;
    private static double LoadFactor;
    public static IntSet Empty;
    private Int32[] myArray;
    private int myCount;
    private int myVersion;
    private int myCapacity;
    private int myMarker;
    private bool myTreatMarkerAsSetElement;
    public static IUnsafeMarshaller`1<IntSet> Marshaller;
    public int Count { get; }
    public int Capacity { get; }
    public bool IsReadOnly { get; }
    private IntSet(int count, int marker, bool treatMarkerAsSetElement, Int32[] array);
    private IntSet(IntSet toClone);
    public IntSet(int expectedNumberOfElements, int marker, bool treatMarkerAsSetElement);
    private static IntSet();
    public static IntSet Read(UnsafeReader reader);
    public static void Write(UnsafeWriter writer, IntSet value);
    private void Init(int expectedCapacity);
    private void FillByMarker();
    private int InitBucket(int x);
    private int NextBucket(int prevBucket);
    private void Resize();
    private void EnsureCapacity();
    private bool AddInternal(int item);
    public sealed virtual void Add(int item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(int item);
    public sealed virtual void CopyTo(Int32[] array, int arrayIndex);
    public sealed virtual bool Remove(int item);
    public sealed virtual int get_Count();
    public int get_Capacity();
    public sealed virtual bool get_IsReadOnly();
    public IntSet Clone();
    public IntSetEnumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<int> System.Collections.Generic.IEnumerable<System.Int32>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[ExtensionAttribute]
public static class JetBrains.Util.dataStructures.IntSetExtensions : object {
    [ExtensionAttribute]
public static bool ContainsAll(IntSet intSet, Int32[] values);
}
public interface JetBrains.Util.DataStructures.ISettingsTable {
    public abstract virtual bool GetBoolean(string settingName);
    public abstract virtual bool GetBoolean(string settingName, bool defaultVal);
    public abstract virtual int GetInteger(string settingName);
    public abstract virtual int GetInteger(string settingName, int defaultVal);
    public abstract virtual string GetString(string settingName);
    public abstract virtual string GetString(string settingName, string defaultVal);
    public abstract virtual void SetBoolean(string settingName, bool val);
    public abstract virtual void SetInteger(string settingName, int val);
    public abstract virtual void SetString(string settingName, string val);
}
public interface JetBrains.Util.dataStructures.IValueConsumer`2 {
    public abstract virtual bool Consume(TValue value, TParameter parameter);
}
[DefaultMemberAttribute("Item")]
internal class JetBrains.Util.dataStructures.KeyToEntryMap`1 : object {
    private static int NextBucketShift;
    private static double LoadFactor;
    private static int MinCapacity;
    private KeyValuePair`2[] myEntries;
    private int myEntriesCountMask;
    private IEqualityComparer`1<TKey> myEqualityComparer;
    private int myRemovedCount;
    [CompilerGeneratedAttribute]
private int <Count>k__BackingField;
    internal int Count { get; private set; }
    internal ValueRefEntry Item { get; }
    internal IEnumerable`1<TKey> Keys { get; }
    internal KeyToEntryMap`1(int capacity, IEqualityComparer`1<TKey> equalityComparer);
    [CompilerGeneratedAttribute]
internal int get_Count();
    [CompilerGeneratedAttribute]
private void set_Count(int value);
    private void InitializeByDesiredCapacity(int desiredCapacity);
    private void InitEntries();
    internal ValueRefEntry get_Item(TKey key);
    internal ValueRefEntry GetEntryByIndex(int index);
    internal void SetByIndex(int index, ValueRefEntry newEntry);
    internal void RemoveByIndex(int index);
    internal bool ContainsKey(TKey key);
    private int GetBucket(TKey key);
    private int NextBucket(int prevBucket);
    internal bool TryGetValue(TKey key, ValueRefEntry& value, Int32& index);
    internal void Clear();
    private int Add0(TKey key, ValueRefEntry entry);
    internal void Add(TKey key, ValueRefEntry entry, Int32& lastIndex);
    internal bool ConditionallyResize(Int32& lastIndex, bool allowTrim);
    internal IEnumerable`1<TKey> get_Keys();
    internal KeyValuePair`2[] IdxToValues();
    internal TKey GetKeyByIndex(int index);
}
public class JetBrains.Util.DataStructures.MergedEnumerable`1 : object {
    private IEnumerable`1[] myEnumerables;
    public MergedEnumerable`1(IEnumerable`1[] enumerables);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class JetBrains.Util.DataStructures.MergedEnumerator : object {
    private IEnumerator[] myEnumerators;
    private int myCurrentEnumeratorIndex;
    private IEnumerator myCurrentEnumerator;
    private object System.Collections.IEnumerator.Current { get; }
    public MergedEnumerator(IEnumerator[] enumerators);
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    private sealed virtual override void System.IDisposable.Dispose();
    private sealed virtual override bool System.Collections.IEnumerator.MoveNext();
    private sealed virtual override void System.Collections.IEnumerator.Reset();
}
public class JetBrains.Util.DataStructures.MergedEnumerator`1 : object {
    private IEnumerator`1[] myEnumerators;
    private int myCurrentEnumeratorIndex;
    private IEnumerator`1<T> myCurrentEnumerator;
    public T Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    public MergedEnumerator`1(IEnumerator`1[] enumerators);
    public sealed virtual T get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    private sealed virtual override void System.IDisposable.Dispose();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
}
[DefaultMemberAttribute("Item")]
internal class JetBrains.Util.dataStructures.MultimapStorage`1 : object {
    private int myChunkOffset;
    private int myChunkMask;
    private int myChunkCount;
    private TValue[][] myChunks;
    private int ChunkSize { get; }
    internal TValue Item { get; internal set; }
    internal MultimapStorage`1(int chunkSizeLog2, int initialChunkNumber);
    private int get_ChunkSize();
    internal TValue get_Item(int index);
    internal void set_Item(int index, TValue value);
    internal void SetInternal(int index, TValue value);
    private void EnsureCapacity(int index);
    internal void CompactToNewCount(int newCount);
    internal void DebugPrint();
}
public class JetBrains.Util.dataStructures.MultimapValueCollection`2 : ValueType {
    public static MultimapValueCollection`2<TKey, TValue> EmptyInstance;
    private OneToListMultimap`2<TKey, TValue> myMultimap;
    private TKey myKey;
    private ValueRefEntry Entry { get; }
    internal TKey Key { get; }
    internal OneToListMultimap`2<TKey, TValue> Multimap { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    internal MultimapValueCollection`2(OneToListMultimap`2<TKey, TValue> multimap, TKey key);
    private static MultimapValueCollection`2();
    private ValueRefEntry get_Entry();
    internal TKey get_Key();
    internal OneToListMultimap`2<TKey, TValue> get_Multimap();
    public MultimapValueCollectionEnumerator`1<TValue> GetEnumerator();
    private sealed virtual override IEnumerator`1<TValue> System.Collections.Generic.IEnumerable<TValue>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Add(TValue item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(TValue item);
    public sealed virtual void CopyTo(TValue[] array, int arrayIndex);
    public sealed virtual bool Remove(TValue item);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
}
public class JetBrains.Util.dataStructures.MultimapValueCollectionEnumerator`1 : ValueType {
    private int myIndex;
    private int myRestCount;
    private MultimapStorage`1<TValue> myStorage;
    public TValue Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    internal MultimapValueCollectionEnumerator`1(ValueRefEntry entry, MultimapStorage`1<TValue> storage);
    public sealed virtual void Dispose();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
    public sealed virtual TValue get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
}
public class JetBrains.Util.dataStructures.NaturalSort : object {
    [NotNullAttribute]
public static IComparer`1<string> Comparer;
    [NotNullAttribute]
public static IEqualityComparer`1<string> EqualityComparer;
    private static NaturalSort();
    private sealed virtual override int System.Collections.Generic.IComparer<System.String>.Compare(string black, string white);
    private sealed virtual override int System.Collections.IComparer.Compare(object black, object white);
    private sealed virtual override bool System.Collections.IEqualityComparer.Equals(object black, object white);
    private sealed virtual override bool System.Collections.Generic.IEqualityComparer<System.String>.Equals(string black, string white);
    private sealed virtual override int System.Collections.IEqualityComparer.GetHashCode(object o);
    private sealed virtual override int System.Collections.Generic.IEqualityComparer<System.String>.GetHashCode(string s);
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Util.dataStructures.OneToListMultimap`2 : object {
    public static int DefaultKeysCapacity;
    private IEqualityComparer`1<TKey> myKeyComparer;
    private CapacityPolicy myCapacityPolicy;
    internal MultimapStorage`1<TValue> ValueStorage;
    private int myNextWritePosition;
    private int myLastKeyIndex;
    private int myEmptyCellCount;
    [CompilerGeneratedAttribute]
private KeyToEntryMap`1<TKey> <BaseMap>k__BackingField;
    [CompilerGeneratedAttribute]
private IEqualityComparer`1<TValue> <ValueComparer>k__BackingField;
    [CompilerGeneratedAttribute]
private CompactionPolicy <CompactionPolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private static Comparison`1<KeyValuePair`2<int, ValueRefEntry>> CS$<>9__CachedAnonymousMethodDelegate1;
    [CompilerGeneratedAttribute]
private static Func`2<MultimapValueCollection`2<TKey, TValue>, TKey> CS$<>9__CachedAnonymousMethodDelegate4;
    [CompilerGeneratedAttribute]
private static Comparison`1<KeyValuePair`2<int, ValueRefEntry>> CS$<>9__CachedAnonymousMethodDelegate11;
    [CompilerGeneratedAttribute]
private static Func`2<TValue, string> CS$<>9__CachedAnonymousMethodDelegate12;
    internal KeyToEntryMap`1<TKey> BaseMap { get; private set; }
    internal IEqualityComparer`1<TValue> ValueComparer { get; private set; }
    public CompactionPolicy CompactionPolicy { get; public set; }
    public MultimapValueCollection`2<TKey, TValue> Item { get; public set; }
    public ICollection`1<TKey> Keys { get; }
    private IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,JetBrains.Util.dataStructures.MultimapValueCollection<TKey,TValue>>.Keys { get; }
    public IEnumerable`1<TKey> KeysLazy { get; }
    public ICollection`1<MultimapValueCollection`2<TKey, TValue>> Values { get; }
    private IEnumerable`1<MultimapValueCollection`2<TKey, TValue>> System.Collections.Generic.IReadOnlyDictionary<TKey,JetBrains.Util.dataStructures.MultimapValueCollection<TKey,TValue>>.Values { get; }
    public IEnumerable`1<TValue> AllValuesLazy { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public OneToListMultimap`2(int keyCapacity, IEqualityComparer`1<TKey> keyComparer, IEqualityComparer`1<TValue> valueComparer, CapacityPolicy capacityPolicy);
    [CompilerGeneratedAttribute]
internal KeyToEntryMap`1<TKey> get_BaseMap();
    [CompilerGeneratedAttribute]
private void set_BaseMap(KeyToEntryMap`1<TKey> value);
    [CompilerGeneratedAttribute]
internal IEqualityComparer`1<TValue> get_ValueComparer();
    [CompilerGeneratedAttribute]
private void set_ValueComparer(IEqualityComparer`1<TValue> value);
    [CompilerGeneratedAttribute]
public CompactionPolicy get_CompactionPolicy();
    [CompilerGeneratedAttribute]
public void set_CompactionPolicy(CompactionPolicy value);
    private void Reset();
    private void TryAutoCompact();
    private int CompactInternal();
    private void NonoverlappingCopyWithClean(int indexFrom, int size, int indexTo);
    private void AdvanceNextWritePositionAccordingPolicy();
    public void AddValue(TKey key, TValue value);
    public bool RemoveValue(TKey key, TValue value);
    public int RemoveValueRange(TKey key, IEnumerable`1<TValue> valuesEnumerable);
    public void AddValueRange(TKey key, IEnumerable`1<TValue> valuesEnumerable);
    public void SetValueRange(TKey key, IEnumerable`1<TValue> valuesEnumerable);
    public int Compact();
    public int CompactConditionally();
    public sealed virtual bool ContainsKey(TKey key);
    public sealed virtual void Add(TKey key, MultimapValueCollection`2<TKey, TValue> value);
    public sealed virtual bool Remove(TKey key);
    public sealed virtual bool TryGetValue(TKey key, MultimapValueCollection`2& value);
    public sealed virtual MultimapValueCollection`2<TKey, TValue> get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, MultimapValueCollection`2<TKey, TValue> value);
    public sealed virtual ICollection`1<TKey> get_Keys();
    private sealed virtual override IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,JetBrains.Util.dataStructures.MultimapValueCollection<TKey,TValue>>.get_Keys();
    public IEnumerable`1<TKey> get_KeysLazy();
    public sealed virtual ICollection`1<MultimapValueCollection`2<TKey, TValue>> get_Values();
    private sealed virtual override IEnumerable`1<MultimapValueCollection`2<TKey, TValue>> System.Collections.Generic.IReadOnlyDictionary<TKey,JetBrains.Util.dataStructures.MultimapValueCollection<TKey,TValue>>.get_Values();
    public IEnumerable`1<TValue> get_AllValuesLazy();
    public IEnumerator`1<KeyValuePair`2<TKey, MultimapValueCollection`2<TKey, TValue>>> GetEnumerator();
    private sealed virtual override IEnumerator`1<KeyValuePair`2<TKey, MultimapValueCollection`2<TKey, TValue>>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,JetBrains.Util.dataStructures.MultimapValueCollection<TKey,TValue>>>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public bool FindAndConsume(TKey keyToFind, IValueConsumer`2<TValue, TParameter> consumer, TParameter parameter, Action interruptChecker);
    public sealed virtual MultimapValueCollection`2<TKey, TValue> GetValuesSafe(TKey key);
    public sealed virtual void Add(TKey key, TValue value);
    public sealed virtual bool Remove(TKey key, TValue value);
    public sealed virtual void Add(KeyValuePair`2<TKey, MultimapValueCollection`2<TKey, TValue>> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<TKey, MultimapValueCollection`2<TKey, TValue>> item);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual bool Remove(KeyValuePair`2<TKey, MultimapValueCollection`2<TKey, TValue>> item);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public string DebugPrintOrdered();
    public int StatValueStorageUsed();
    public int StatEmptyCount();
    [CompilerGeneratedAttribute]
private static int <CompactInternal>b__0(KeyValuePair`2<int, ValueRefEntry> p1, KeyValuePair`2<int, ValueRefEntry> p2);
    [CompilerGeneratedAttribute]
private static TKey <get_Values>b__2(MultimapValueCollection`2<TKey, TValue> mvcol);
    [CompilerGeneratedAttribute]
private MultimapValueCollection`2<TKey, TValue> <get_Values>b__3(TKey key);
    [CompilerGeneratedAttribute]
private KeyValuePair`2<TKey, MultimapValueCollection`2<TKey, TValue>> <GetEnumerator>b__e(IEnumerator`1<TKey> keyEnum);
    [CompilerGeneratedAttribute]
private static int <DebugPrintOrdered>b__f(KeyValuePair`2<int, ValueRefEntry> p1, KeyValuePair`2<int, ValueRefEntry> p2);
    [CompilerGeneratedAttribute]
private static string <DebugPrintOrdered>b__10(TValue _);
}
[ExtensionAttribute]
public static class JetBrains.Util.dataStructures.OneToManyEquivalenceComparerEx : object {
    [ExtensionAttribute]
public static bool IsEquivalentTo(OneToListMultimap`2<TKey, TValue> x, OneToListMultimap`2<TKey, TValue> y);
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Util.DataStructures.OrderedDictionary`2 : object {
    private Dictionary`2<TKey, TValue> myDictionary;
    private List`1<TKey> myList;
    public TValue Item { get; public set; }
    public ICollection`1<TKey> Keys { get; }
    private IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Keys { get; }
    public ICollection`1<TValue> Values { get; }
    private IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Values { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public OrderedDictionary`2(IEqualityComparer`1<TKey> comparer);
    public sealed virtual bool ContainsKey(TKey key);
    public sealed virtual void Add(TKey key, TValue value);
    public void Insert(int index, TKey key, TValue value);
    public sealed virtual bool Remove(TKey key);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    public sealed virtual ICollection`1<TKey> get_Keys();
    private sealed virtual override IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Keys();
    public sealed virtual ICollection`1<TValue> get_Values();
    private sealed virtual override IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Values();
    public sealed virtual void Add(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    private static void CopyTo(ICollection`1<T> collection, T[] array, int index);
    public sealed virtual bool Remove(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [CompilerGeneratedAttribute]
private KeyValuePair`2<TKey, TValue> <GetEnumerator>b__0(TKey input);
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Util.DataStructures.PackedIntArray : ValueType {
    private int myLength;
    private int myValueBits;
    private UncheckedPackedIntArray myArray;
    public UInt32[] Item { get; public set; }
    public int Length { get; }
    public int ValueBits { get; }
    public int ValueInts { get; }
    public PackedIntArray(int length, int valueBits);
    private PackedIntArray(int length, int valueBits, UncheckedPackedIntArray array);
    public UInt32[] get_Item(int index);
    public void set_Item(int index, UInt32[] value);
    public int get_Length();
    public int get_ValueBits();
    public int get_ValueInts();
    public void CopyTo(PackedIntArray array, int count);
    public static PackedIntArray IncreaseValueBits(PackedIntArray oldArray, int newValueBits);
    public void Clear();
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Util.DataStructures.PackedIntArrayList : ValueType {
    private UncheckedPackedIntArray myArray;
    private UInt32 Item { get; private set; }
    public PackedIntArrayList(int valueBits, int initialCapacity);
    private PackedIntArrayList(UncheckedPackedIntArray array);
    [PureAttribute]
public int GetCount(int valueBits);
    private void SetCount(int count, int valueBits);
    public PackedIntArrayList SetCapacity(int capacity, int valueBits);
    public PackedIntArrayList Add(UInt32 value, int valueBits);
    public bool Remove(UInt32 value, int valueBits);
    private UInt32 get_Item(int index, int valueBits);
    private void set_Item(int index, int valueBits, UInt32 value);
    [ConditionalAttribute("JET_MODE_ASSERT")]
private void AssertIndexInRange(int index, int valueBits);
    public bool Contains(UInt32 value, int valueBits);
    public PackedIntArrayList IncreaseValueBits(int oldValueBits, int newValueBits);
    public IList`1<UInt32> AsReadOnlyList(int valueBits);
    public static bool op_Equality(PackedIntArrayList list1, PackedIntArrayList list2);
    public static bool op_Inequality(PackedIntArrayList list1, PackedIntArrayList list2);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
public class JetBrains.Util.DataStructures.PackedIntKeyMap`1 : CompactMapBase`4<UInt32, TValue, PackedIntKeyMapStorage`1<TValue>, UInt32> {
    private int myKeyBits;
    private UInt32 myKeyMask;
    private UInt32 mySlotOccupiedMask;
    private UInt32[] myRemovedValue;
    public PackedIntKeyMap`1(int keyBits);
    public PackedIntKeyMap`1(int keyBits, int intialSlotCount, double maxLoadFactor);
    protected virtual void DoValidateKey(UInt32 key);
    protected virtual PackedIntKeyMapStorage`1<TValue> CreateStorage(int slotCount);
    protected virtual SlotState<UInt32, TValue, PackedIntKeyMapStorage`1<TValue>, UInt32> GetSlotState(PackedIntKeyMapStorage`1<TValue> storage, int index, UInt32& key);
    protected virtual UInt32 GetSlotData(PackedIntKeyMapStorage`1<TValue> storage, int index);
    protected virtual TValue GetValue(PackedIntKeyMapStorage`1<TValue> storage, int index, UInt32 data);
    protected virtual void SetValue(PackedIntKeyMapStorage`1<TValue> storage, int index, TValue value);
    protected virtual void SetKeyAndValue(PackedIntKeyMapStorage`1<TValue> storage, int index, UInt32 key, TValue value);
    protected virtual void RemoveValue(PackedIntKeyMapStorage`1<TValue> storage, int index);
    protected virtual void ClearStorage(PackedIntKeyMapStorage`1<TValue> storage);
}
public class JetBrains.Util.DataStructures.PackedIntKeyMapStorage`1 : ValueType {
    public ChunkPackedIntArray PackedArray;
    public TValue[] Values;
    public PackedIntKeyMapStorage`1(int length, int keyBits);
}
public class JetBrains.Util.DataStructures.PackedIntSet : object {
    public static double DEFAULT_MAX_LOAD_FACTOR;
    public static int DEFAULT_INITIAL_SLOT_COUNT;
    private PackedIntSetInternal myImpl;
    public double MaxLoadFactor { get; }
    public int Count { get; }
    public int SlotCount { get; }
    public bool IsReadOnly { get; }
    public PackedIntSet(int keyBits);
    public PackedIntSet(int keyBits, int intialSlotCount, double maxLoadFactor);
    public double get_MaxLoadFactor();
    public sealed virtual void Add(UInt32 item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(UInt32 item);
    public sealed virtual void CopyTo(UInt32[] array, int arrayIndex);
    private static void CopyTo(IEnumerable`1<T> collection, T[] array, int index);
    public sealed virtual bool Remove(UInt32 item);
    public sealed virtual int get_Count();
    public int get_SlotCount();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual IEnumerator`1<UInt32> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public void Compact();
}
public class JetBrains.Util.DataStructures.PackedIntSetInternal : CompactMapBase`4<UInt32, object, ChunkPackedIntArray, object> {
    private int myKeyBits;
    private UInt32 myKeyMask;
    private UInt32 mySlotOccupiedMask;
    private static UInt32[] REMOVED_VALUE;
    public PackedIntSetInternal(int keyBits);
    public PackedIntSetInternal(int keyBits, int intialSlotCount, double maxLoadFactor);
    private static PackedIntSetInternal();
    protected virtual void DoValidateKey(UInt32 key);
    protected virtual ChunkPackedIntArray CreateStorage(int slotCount);
    protected virtual SlotState<UInt32, object, ChunkPackedIntArray, object> GetSlotState(ChunkPackedIntArray storage, int index, UInt32& key);
    protected virtual object GetSlotData(ChunkPackedIntArray storage, int index);
    protected virtual object GetValue(ChunkPackedIntArray storage, int index, object data);
    protected virtual void SetValue(ChunkPackedIntArray storage, int index, object value);
    protected virtual void SetKeyAndValue(ChunkPackedIntArray storage, int index, UInt32 key, object value);
    protected virtual void RemoveValue(ChunkPackedIntArray storage, int index);
    protected virtual void ClearStorage(ChunkPackedIntArray storage);
}
public class JetBrains.Util.DataStructures.PackedIntToIntMap : CompactMapBase`4<UInt32, UInt32[], ChunkPackedIntArray, UInt32[]> {
    private int myKeyBits;
    private int myValueBits;
    private UInt32 myKeyMask;
    private UInt32 mySlotOccupiedMask;
    private UInt32[] myRemovedValue;
    private int myValueInts;
    private UInt32 myLastValueIntMask;
    public int ValueBits { get; }
    public int ValueInts { get; }
    public PackedIntToIntMap(int keyBits, int valueBits);
    public PackedIntToIntMap(int keyBits, int valueBits, int intialSlotCount, double maxLoadFactor);
    protected virtual void DoValidateKey(UInt32 key);
    public int get_ValueBits();
    public int get_ValueInts();
    protected virtual ChunkPackedIntArray CreateStorage(int slotCount);
    protected virtual SlotState<UInt32, UInt32[], ChunkPackedIntArray, UInt32[]> GetSlotState(ChunkPackedIntArray storage, int index, UInt32& key);
    protected virtual UInt32[] GetSlotData(ChunkPackedIntArray storage, int index);
    protected virtual UInt32[] GetValue(ChunkPackedIntArray storage, int index, UInt32[] data);
    protected virtual void SetValue(ChunkPackedIntArray storage, int index, UInt32[] value);
    protected virtual void SetKeyAndValue(ChunkPackedIntArray storage, int index, UInt32 key, UInt32[] value);
    protected virtual void RemoveValue(ChunkPackedIntArray storage, int index);
    private UInt32 GetDataAtWithoutOccupiedBit(UInt32[] data, int index);
    private void SetValueWhenCleared(UInt32[] data, UInt32[] value);
    protected virtual void ClearStorage(ChunkPackedIntArray storage);
}
public class JetBrains.Util.DataStructures.ProxySettingsTable : SettingsTable {
    private ISettingsTable myOriginalTable;
    [CompilerGeneratedAttribute]
private object <LockObject>k__BackingField;
    protected object LockObject { get; private set; }
    public ProxySettingsTable(ISettingsTable originalTable);
    [CompilerGeneratedAttribute]
protected object get_LockObject();
    [CompilerGeneratedAttribute]
private void set_LockObject(object value);
    public virtual bool GetBoolean(string settingName);
    public virtual bool GetBoolean(string settingName, bool defaultVal);
    public virtual int GetInteger(string settingName);
    public virtual int GetInteger(string settingName, int defaultVal);
    public virtual string GetString(string settingName);
    public virtual string GetString(string settingName, string defaultVal);
    public virtual void SetBoolean(string settingName, bool val);
    public virtual void SetInteger(string settingName, int val);
    public virtual void SetString(string settingName, string val);
}
public class JetBrains.Util.DataStructures.RegistrySettingsTable : ProxySettingsTable {
    private static string INTS;
    private static string BOOLS;
    private static string STRINGS;
    private static string LICENSE_SETTINGS_SUB;
    [NotNullAttribute]
private string myRootFullKeyName;
    [NotNullAttribute]
private string myEnvironmentSuffixWithLeadingSlash;
    private RegistryKey myRegistryKey;
    private static Action`1<Version> DO_NOTHING;
    private static Regex ourVersionRegex;
    [CompilerGeneratedAttribute]
private static Action`1<Version> CS$<>9__CachedAnonymousMethodDelegate6;
    [CompilerGeneratedAttribute]
private static Comparison`1<string> CS$<>9__CachedAnonymousMethodDelegate7;
    [CompilerGeneratedAttribute]
private static Converter`2<int, bool> CS$<>9__CachedAnonymousMethodDelegate9;
    [CompilerGeneratedAttribute]
private static Converter`2<bool, int> CS$<>9__CachedAnonymousMethodDelegatec;
    [CompilerGeneratedAttribute]
private static Action`1<Version> CS$<>9__CachedAnonymousMethodDelegatee;
    public RegistrySettingsTable(RegistryKey registryKey, string rootFullKeyName, string environmentSuffixWithLeadingSlash, ISettingsTable settings);
    private static RegistrySettingsTable();
    private static void Load(IDictionary`2<string, TSetting> dict, string keyName, RegistryKey rootKey, Converter`2<TValue, TSetting> converter);
    private void Save(IDictionary`2<string, TSetting> dict, string keyName, RegistryKey rootKey, Converter`2<TSetting, TValue> converter);
    private Version GetVersion(string key);
    public bool Load(Action`1<Version> onLoadFromVersion);
    private bool TryLoadFromProductVersion(string productVersionRootKeyName);
    private bool TryLoadFrom(string keyName);
    public bool Save();
    [CompilerGeneratedAttribute]
private static void <Load>b__4(Version version);
    [CompilerGeneratedAttribute]
private static int <Load>b__5(string s, string s1);
    [CompilerGeneratedAttribute]
private static bool <TryLoadFrom>b__8(int x);
    [CompilerGeneratedAttribute]
private static int <Save>b__b(bool x);
    [CompilerGeneratedAttribute]
private static void <.cctor>b__d(Version version);
}
public class JetBrains.Util.dataStructures.SafeUnmanagedMemory : ValueType {
    private IntPtr myPtr;
    public IntPtr Ptr { get; }
    public Byte* RawPtr { get; }
    private SafeUnmanagedMemory(int size);
    public IntPtr get_Ptr();
    public Byte* get_RawPtr();
    public static SafeUnmanagedMemory Alloc(int size);
    public sealed virtual void Dispose();
}
public class JetBrains.Util.DataStructures.SettingsTable : object {
    private Dictionary`2<string, bool> myBools;
    private Dictionary`2<string, int> myInts;
    private Dictionary`2<string, string> myStrings;
    protected Dictionary`2<string, bool> Bools { get; }
    protected Dictionary`2<string, int> Ints { get; }
    protected Dictionary`2<string, string> Strings { get; }
    public SettingsTable(SettingsTable settings);
    protected Dictionary`2<string, bool> get_Bools();
    protected Dictionary`2<string, int> get_Ints();
    protected Dictionary`2<string, string> get_Strings();
    public virtual bool GetBoolean(string settingName);
    public virtual bool GetBoolean(string settingName, bool defaultVal);
    public virtual int GetInteger(string settingName);
    public virtual int GetInteger(string settingName, int defaultVal);
    public virtual string GetString(string settingName);
    public virtual string GetString(string settingName, string defaultVal);
    public virtual void SetBoolean(string settingName, bool val);
    public virtual void SetInteger(string settingName, int val);
    public virtual void SetString(string settingName, string val);
    protected static T GetValue(IDictionary`2<string, T> dict, string settingName);
    protected static T GetValue(IDictionary`2<string, T> dict, string settingName, T defautValue);
    protected static void SetValue(IDictionary`2<string, T> dict, string settingName, T value);
}
public class JetBrains.Util.dataStructures.SimpleTrie`2 : object {
    private TrieNode<TKey, TValue> myRootNode;
    public bool IsEmpty { get; }
    [NotNullAttribute]
public TrieNode<TKey, TValue> RootNode { get; }
    public bool get_IsEmpty();
    public TrieNode<TKey, TValue> get_RootNode();
    public void AddOrUpdateValue(KeyEnumerator`2<TKey, TValue, TContext, TState> keys, AddOrUpdateHandler`1<TKey, TValue, TContext> value, TContext context);
    public bool Remove(IList`1<TKey> keys);
    public void RemoveAllKeyPrefixes(IList`1<TKey> keys);
    public void SetValue(KeyEnumerator`2<TKey, TValue, TContext, TState> keys, TValue value, TContext context);
    public void SetValue(IList`1<TKey> keys, TValue value);
    public bool TryGetValue(KeyEnumerator`2<TKey, TValue, TContext, TState> keys, TValue& value, TContext context);
    public bool TryGetValue(IList`1<TKey> keys, TValue& value);
}
internal enum JetBrains.Util.dataStructures.SlotState : Enum {
    public int value__;
    public static SlotState Free;
    public static SlotState Removed;
    public static SlotState Occupied;
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Util.dataStructures.StringConcat : ValueType {
    [NotNullAttribute]
private String[] myParts;
    private int myLength;
    [NotNullAttribute]
public String[] Parts { get; }
    public int Length { get; }
    public char Item { get; }
    public StringConcat(String[] parts);
    public String[] get_Parts();
    public virtual string ToString();
    public sealed virtual int get_Length();
    public sealed virtual string GetText();
    [ConditionalAttribute("JET_MODE_ASSERT")]
private void Assert(int startOffset, int endOffset, int len);
    public sealed virtual string GetText(TextRange range);
    public sealed virtual void AppendTextTo(StringBuilder builder, TextRange range);
    public sealed virtual char get_Item(int index);
    public sealed virtual void CopyTo(int sourceIndex, Char[] destinationArray, int destinationIndex, int length);
    public bool EqualTo(string s);
    public bool Contains(string s, int start);
    public bool StartsWith(string s);
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Util.dataStructures.StringDotConcat : ValueType {
    [NotNullAttribute]
private string myPart1;
    [CanBeNullAttribute]
private string myPart2;
    public int Length { get; }
    public char Item { get; }
    public StringDotConcat(string part1);
    public StringDotConcat(string part1, string part2);
    public virtual string ToString();
    public sealed virtual int get_Length();
    public sealed virtual string GetText();
    [ConditionalAttribute("JET_MODE_ASSERT")]
private void Assert(int startOffset, int endOffset, int len);
    public sealed virtual string GetText(TextRange range);
    public sealed virtual void AppendTextTo(StringBuilder builder, TextRange range);
    public sealed virtual char get_Item(int index);
    public sealed virtual void CopyTo(int sourceIndex, Char[] destinationArray, int destinationIndex, int length);
    public bool EqualTo(string s);
    public bool StartsWith(string s);
}
public class JetBrains.Util.dataStructures.SubStream : Stream {
    private Nullable`1<long> myLength;
    private FileAccess myRwfilter;
    private long myStart;
    [NotNullAttribute]
private Stream myStream;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public SubStream(Stream stream, long start, Nullable`1<long> length, FileAccess rwfilter);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    [NotNullAttribute]
public static SubStream Append(Stream stream);
    public virtual void Close();
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual string ToString();
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte value);
}
public class JetBrains.Util.DataStructures.ToStringComparer : object {
    public static ToStringComparer INSTANCE;
    private static ToStringComparer();
    public sealed virtual int Compare(object x, object y);
}
public class JetBrains.Util.DataStructures.ToStringComparer`1 : object {
    public static ToStringComparer`1<T> INSTANCE;
    private static ToStringComparer`1();
    public sealed virtual int Compare(T x, T y);
}
public class JetBrains.Util.dataStructures.TypedIntrinsics.Int32`1 : ValueType {
    private int Value;
    public static Int32`1<TType> I;
    public static Int32`1<TType> MaxValue;
    public static Int32`1<TType> MinValue;
    public static Int32`1<TType> O;
    private static Int32`1();
    public static Int32`1<TType> Abs(Int32`1<TType> );
    public static Int32`1<TType> Max(Int32`1<TType> , Int32`1<TType> );
    public static Int32`1<TType> Min(Int32`1<TType> , Int32`1<TType> );
    public static Int32`1<TType> Parse(string s);
    public static Int32`1<TType> Parse(string s, NumberStyles style);
    public static Int32`1<TType> Parse(string s, IFormatProvider provider);
    public static Int32`1<TType> Parse(string s, NumberStyles style, IFormatProvider provider);
    public static bool TryParse(string s, Int32`1& result);
    public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, Int32`1& result);
    public static Int32`1<TType> op_Addition(Int32`1<TType> , Int32`1<TType> );
    public static Int32`1<TType> op_Decrement(Int32`1<TType> );
    public static Int32`1<TType> op_Division(Int32`1<TType> , Int32`1<TType> );
    public static bool op_Equality(Int32`1<TType> left, Int32`1<TType> right);
    public static int op_Explicit(Int32`1<TType> other);
    public static Int32`1<TType> op_Explicit(int other);
    public static UInt32 op_Explicit(Int32`1<TType> other);
    public static Int32`1<TType> op_Explicit(UInt32 other);
    public static double op_Explicit(Int32`1<TType> other);
    public static bool op_GreaterThan(Int32`1<TType> , Int32`1<TType> );
    public static bool op_GreaterThanOrEqual(Int32`1<TType> , Int32`1<TType> );
    public static Int32`1<TType> op_Increment(Int32`1<TType> );
    public static bool op_Inequality(Int32`1<TType> left, Int32`1<TType> right);
    public static Int32`1<TType> op_LeftShift(Int32`1<TType> , int );
    public static bool op_LessThan(Int32`1<TType> , Int32`1<TType> );
    public static bool op_LessThanOrEqual(Int32`1<TType> , Int32`1<TType> );
    public static Int32`1<TType> op_Multiply(Int32`1<TType> , Int32`1<TType> );
    public static Int32`1<TType> op_RightShift(Int32`1<TType> , int );
    public static Int32`1<TType> op_Subtraction(Int32`1<TType> , Int32`1<TType> );
    public Int32`1<TType> Limited(Int32`1<TType> minInclusive, Int32`1<TType> maxExclusive);
    public Int32`1<TType> Minus1();
    public Int32`1<TType> Plus1();
    public string ToString(string format);
    public string ToString(IFormatProvider provider);
    public string ToString(string format, IFormatProvider provider);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    private sealed virtual override int System.IComparable<JetBrains.Util.dataStructures.TypedIntrinsics.Int32<TType>>.CompareTo(Int32`1<TType> other);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    public sealed virtual bool Equals(Int32`1<TType> other);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider formatProvider);
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Util.DataStructures.UncheckedPackedIntArray : ValueType {
    private static UInt32 ALL_1_BIT_MASK;
    private UInt32[] myData;
    public UInt32[] Data { get; }
    public UInt32[] Item { get; public set; }
    public UncheckedPackedIntArray(int length, int valueBits);
    public UncheckedPackedIntArray(UInt32[] data);
    public static int GetCapacityByLength(int length, int valueBits);
    public UInt32[] get_Data();
    [PureAttribute]
public UInt32 GetItem(int index, int valueBits, int iSubItem);
    public UInt32[] get_Item(int index, int valueBits);
    public void set_Item(int index, int valueBits, UInt32[] value);
    [PureAttribute]
public int GetCapacity(int valueBits);
    private static UInt32 LastIntMask(int valueBits, int valueInts);
    public static int ValueInts(int valueBits);
    public void CopyTo(UncheckedPackedIntArray array, int count, int valueBits);
    public static UncheckedPackedIntArray IncreaseValueBits(UncheckedPackedIntArray oldArray, int length, int oldValueBits, int newValueBits);
    public static bool op_Equality(UncheckedPackedIntArray array1, UncheckedPackedIntArray array2);
    public static bool op_Inequality(UncheckedPackedIntArray array1, UncheckedPackedIntArray array2);
    public void Clear();
    public sealed virtual bool Equals(UncheckedPackedIntArray uncheckedPackedIntArray);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class JetBrains.Util.dataStructures.UncloseableStream : Stream {
    private Stream myStream;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanTimeout { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public int ReadTimeout { get; public set; }
    public int WriteTimeout { get; public set; }
    public UncloseableStream(Stream stream);
    public object GetLifetimeService();
    public virtual object InitializeLifetimeService();
    public virtual ObjRef CreateObjRef(Type requestedType);
    public virtual void Close();
    public virtual void Flush();
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte value);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanTimeout();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
}
internal class JetBrains.Util.dataStructures.ValueRefEntry : ValueType {
    private static int RemovedMarkerIndex;
    private static int ExactFitCapacity;
    private static int SizeNBits;
    private static int SizeMask;
    private static int CapacityNBits;
    private static int CapacityOffset;
    private static int CapacityMask;
    public static ValueRefEntry FreeMarker;
    public static ValueRefEntry RemovedMarker;
    private int myIndex;
    private int myLen;
    internal SlotState State { get; }
    internal int Index { get; }
    internal int Capacity { get; }
    internal bool IsExactFit { get; }
    internal int Count { get; }
    internal bool IsFull { get; }
    internal ValueRefEntry(CapacityPolicy capacityPolicy, int index, int size);
    private static ValueRefEntry();
    private static ValueRefEntry CreateMarker(int index);
    internal SlotState get_State();
    internal int get_Index();
    internal int get_Capacity();
    internal bool get_IsExactFit();
    internal int get_Count();
    internal bool get_IsFull();
    internal ValueRefEntry WithIndex(int newIndex);
    internal ValueRefEntry WithCount(int newCount);
    internal ValueRefEntry WithReducedCount(int reduceCount);
    internal ValueRefEntry WithAdvancedCount();
    private void IncreaseCapacityConditionally();
    private void SetFibCapacity(int cnt);
    public void TrimCapacity();
}
public enum JetBrains.Util.DefaultAction : Enum {
    public int value__;
    public static DefaultAction Commit;
    public static DefaultAction Rollback;
}
public class JetBrains.Util.DelegateComparer : object {
    private Comparison myComparison;
    public DelegateComparer(Comparison comparison);
    public sealed virtual int Compare(object x, object y);
}
public class JetBrains.Util.DelegatingComparer`2 : object {
    private IComparer`1<TTarget> mySourceComparer;
    private Func`2<TSource, TTarget> myTransformation;
    private DelegatingComparer`2(IComparer`1<TTarget> sourceComparer, Func`2<TSource, TTarget> transformation);
    public static DelegatingComparer`2<TSource, TTarget> Create(Func`2<TSource, TTarget> transformation, IComparer`1<TTarget> targetComparer);
    public static DelegatingComparer`2<TSource, TTarget> Create(Func`2<TSource, TTarget> transformation);
    public sealed virtual int Compare(TSource x, TSource y);
}
public static class JetBrains.Util.DependentEntitiesSortUtil : object {
    public static bool Sort(IList entities, Entity& failedOn);
    private static int FindEntityToLoad(IList entities, int startIndex, ICollection`1<object> loadedIds, ICollection`1<object> allDeclaredIds);
    private static bool CanLoadEntity(Entity entity, ICollection`1<object> loadedIds, ICollection`1<object> allDeclaredIds);
}
public static class JetBrains.Util.DevEnv.DevenvHostDiscovery : object {
    public static string DevEnvExeName;
    private static ILogger Logger;
    public static string PrivateRegistryDetourFileInLocalAppData_Vs15lt_Build_2016_03_17;
    public static string PrivateRegistryUserDetourFileInLocalAppData_Vs15_Win7;
    private static string RegConfigHiveSuffix;
    private static Regex RegexParseVsVersion;
    private static string RegValueInstallDir;
    private static string SubfolderMicrosoft;
    private static string SubfolderVisualStudio;
    public static BackSlashSeparatedRelativePath VisualStudioRegistryPathNoHive;
    [NotNullAttribute]
public static RelativePath[] VsOutOfGacAssemblyFoldersUnderInstalldir;
    private static Version2[] VsClassicVersionsWhiteList;
    [CompilerGeneratedAttribute]
private static Func`2<InstalledVs, FileSystemPath> CS$<>9__CachedAnonymousMethodDelegate2;
    [CompilerGeneratedAttribute]
private static Action CS$<>9__CachedAnonymousMethodDelegatef;
    [CompilerGeneratedAttribute]
private static Func`1<bool> CS$<>9__CachedAnonymousMethodDelegate13;
    [CompilerGeneratedAttribute]
private static Func`2<InstalledVs, VsHive> CS$<>9__CachedAnonymousMethodDelegate1b;
    [CompilerGeneratedAttribute]
private static Func`2<StreamReader, JObject> CS$<>9__CachedAnonymousMethodDelegate1d;
    private static DevenvHostDiscovery();
    [NotNullAttribute]
public static IList`1<InstalledVs> EnumInstalledVs();
    [NotNullAttribute]
public static IList`1<InstalledVs> EnumInstalledVs(EnumInstalledVsFlags flags);
    [NotNullAttribute]
public static FileSystemPath GetMsEnvDllPath();
    [NotNullAttribute]
public static BackSlashSeparatedRelativePath GetVsRegistryPath(VsHive vsHive);
    [NotNullAttribute]
public static FileSystemPath GetVsAppDataPath(SpecialFolder spec, VsHive vsHive);
    [NotNullAttribute]
public static FileSystemPath GetVsAppDataRootPath(SpecialFolder spec);
    [CanBeNullAttribute]
public static FileSystemPath GetVsInstallDir(VsHive hive, OnError onerror);
    private static FileSystemPath GetVsInstallDirFromRegistryRaw(BackSlashSeparatedRelativePath relLocalRegistryRoot, OnError onerror);
    [NotNullAttribute]
public static Version GetVsVersion4();
    public static bool IsVsInstalled(VsHive hive);
    public static bool IsRegistryHiveDetourRequired(VsHive vshive);
    public static Nullable`1<RegistryHiveAccess> OpenRegistryHiveDetourForVs15lt(Lifetime lifetime, VsHive vshive, bool isForceCreateMissingFile);
    [NotNullAttribute]
public static FileSystemPath GetRegistryHiveDetourFileForVs15(VsHive vshive);
    [CanBeNullAttribute]
public static Version TryGetVsVersionFromDllVersion();
    public static string VsVersionToYearString(Version2 ver);
    public static string GetDefaultVsPresentationShort(Version2 ver);
    public static string GetDefaultVsPresentationShort(VsHive vsHive, bool isPreview);
    public static string GetDefaultVsPresentationLong(Version2 ver);
    public static string GetDefaultVsPresentationLong(VsHive vsHive);
    public static string PresentVsLong(VsHive hive, ICollection`1<InstalledVs> installedVs);
    public static HResults IsVs15DiscoveryAvailable();
    [CanBeNullAttribute]
public static InstalledVs TryGetCurrentVs15Instance(OnError onerror);
    [NotNullAttribute]
private static IList`1<InstalledVs> EnumInstalledVsCore(EnumInstalledVsFlags flags, OnError onerror);
    private static void EnumInstalledVsCore_Classic(ICollection`1<InstalledVs> retval, OnError onerror);
    [PublicAPIAttribute]
private static IList`1<InstalledVs> GetInstalledVs15Lightweight_Build_2016_03_17(OnError onerror);
    [PublicAPIAttribute]
private static IList`1<InstalledVs> GetInstalledVs15Lightweight_Build_2016_07_07(OnError onerror);
    [CompilerGeneratedAttribute]
private static FileSystemPath <GetVsInstallDir>b__1(InstalledVs x);
    [CompilerGeneratedAttribute]
private static void <OpenRegistryHiveDetourForVs15lt>b__e();
    [CompilerGeneratedAttribute]
private static bool <GetRegistryHiveDetourFileForVs15>b__12();
    [CompilerGeneratedAttribute]
private static VsHive <EnumInstalledVsCore>b__1a(InstalledVs o);
    [CompilerGeneratedAttribute]
private static JObject <GetInstalledVs15Lightweight_Build_2016_03_17>b__1c(StreamReader reader);
}
[ObsoleteAttribute("Use DevenvHostDiscovery.")]
public static class JetBrains.Util.DevEnv.DevEnvUtil : object {
    private static string VsRegistryKey;
    private static string InstallDirValueName;
    private static string SettingsFileValueName;
    private static string LocationValueName;
    private static OnError ourOnError;
    private static Version[] ourInstalledVersions;
    private static Version ourHighestVersion;
    public static Version[] SupportedVersions;
    [CompilerGeneratedAttribute]
private static Func`2<Version, bool> CS$<>9__CachedAnonymousMethodDelegate1;
    public static Version[] InstalledVersions { get; }
    [CanBeNullAttribute]
public static Version HighestInstalledVersion { get; }
    private static DevEnvUtil();
    public static Version[] get_InstalledVersions();
    public static Version get_HighestInstalledVersion();
    [CanBeNullAttribute]
public static FileSystemPath TryGetInstallDir(Version ver);
    [CanBeNullAttribute]
public static string TryGetDataLocation(Version ver);
    [CanBeNullAttribute]
public static string TryGetSettingsFilePath(Version ver);
    [NotNullAttribute]
public static string GetRegistryRootKey(Version ver, string hive);
    [NotNullAttribute]
public static string ExpandVsVariables(string str, Version ver);
    [CompilerGeneratedAttribute]
private static bool <get_InstalledVersions>b__0(Version ver);
}
public static class JetBrains.Util.DevEnv.EnvDteUtil : object {
    private static OnError ourOnError;
    [CompilerGeneratedAttribute]
private static Func`2<string, bool> CS$<>9__CachedAnonymousMethodDelegate3;
    [CompilerGeneratedAttribute]
private static Func`2<BoundObject`1<object>, int> CS$<>9__CachedAnonymousMethodDelegate4;
    [CompilerGeneratedAttribute]
private static Func`2<BoundObject`1<object>, object> CS$<>9__CachedAnonymousMethodDelegate5;
    [CompilerGeneratedAttribute]
private static Func`2<KeyValuePair`2<int, object>, bool> CS$<>9__CachedAnonymousMethodDelegate9;
    [CompilerGeneratedAttribute]
private static Func`2<KeyValuePair`2<int, object>, int> CS$<>9__CachedAnonymousMethodDelegatea;
    [CompilerGeneratedAttribute]
private static Func`2<KeyValuePair`2<int, object>, object> CS$<>9__CachedAnonymousMethodDelegateb;
    private static EnvDteUtil();
    [NotNullAttribute]
[HandleProcessCorruptedStateExceptionsAttribute]
public static IDictionary`2<int, object> GetRunningDteInstances();
    [NotNullAttribute]
public static IDictionary`2<int, object> GetRunningDteInstancesWithGeneratedSolution();
    public static bool ExecuteCommandWithBestDte(string command);
    [HandleProcessCorruptedStateExceptionsAttribute]
public static bool ExecuteDteCommand(object dte, string command, string args);
    [HandleProcessCorruptedStateExceptionsAttribute]
public static Void* TryGetMainWindowHandle(object dte);
    private static bool IsGeneratedSolution(int procid);
    [HandleProcessCorruptedStateExceptionsAttribute]
private static bool IterateParentProcesses(Func`2<int, bool> predicate);
    [CompilerGeneratedAttribute]
private static bool <GetRunningDteInstances>b__0(string name);
    [CompilerGeneratedAttribute]
private static int <GetRunningDteInstances>b__1(BoundObject`1<object> x);
    [CompilerGeneratedAttribute]
private static object <GetRunningDteInstances>b__2(BoundObject`1<object> x);
    [CompilerGeneratedAttribute]
private static bool <GetRunningDteInstancesWithGeneratedSolution>b__6(KeyValuePair`2<int, object> pair);
    [CompilerGeneratedAttribute]
private static int <GetRunningDteInstancesWithGeneratedSolution>b__7(KeyValuePair`2<int, object> pair);
    [CompilerGeneratedAttribute]
private static object <GetRunningDteInstancesWithGeneratedSolution>b__8(KeyValuePair`2<int, object> pair);
}
[ValueSerializerAttribute("JetBrains.Util.DevEnv.VsHive/HiveSerializer")]
[TypeConverterAttribute("JetBrains.Util.DevEnv.VsHive/HiveConverter")]
public class JetBrains.Util.DevEnv.VsHive : object {
    private static ILogger ourLogger;
    [NotNullAttribute]
public Version2 Version;
    [NotNullAttribute]
public string InstanceId;
    [NotNullAttribute]
public string RootSuffix;
    [NotNullAttribute]
public string HiveString { get; }
    public string InstanceIdString { get; }
    public VsHive(Version2 version);
    public VsHive(Version2 version, string rootSuffix, string instanceId);
    private static VsHive();
    public string get_HiveString();
    public string get_InstanceIdString();
    public VsHive NewWithRootSuffux(string rootSuffix);
    public sealed virtual int CompareTo(VsHive other);
    public sealed virtual bool Equals(VsHive other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(VsHive left, VsHive right);
    public static bool op_Inequality(VsHive left, VsHive right);
    public virtual string ToString();
    [NotNullAttribute]
public static VsHive Parse(string hiveString);
    public static Pair`2<VsHive, string> TryParse(string hiveString);
    [NotNullAttribute]
public static VsHive FromVersionAndHive(Version2 version, string sInstanceIdAndRootSuffix);
    public static Pair`2<string, string> ParseInstanceIdAndRootSuffix(string source);
}
[ObsoleteAttribute("No usages in ReSharper")]
[ThreadUnsafeAttribute]
[DefaultMemberAttribute("Item")]
public class JetBrains.Util.DictionaryWrapper`2 : object {
    private static Statistics Statistics;
    private Dictionary`2<TKey, TValue> myDictionary;
    public IEqualityComparer`1<TKey> Comparer { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public ICollection`1<TKey> Keys { get; }
    public ICollection`1<TValue> Values { get; }
    private IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Keys { get; }
    private IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Values { get; }
    public TValue Item { get; public set; }
    protected DictionaryWrapper`2(SerializationInfo info, StreamingContext context);
    public DictionaryWrapper`2(IDictionary`2<TKey, TValue> dictionary);
    public DictionaryWrapper`2(IDictionary`2<TKey, TValue> dictionary, IEqualityComparer`1<TKey> comparer);
    public DictionaryWrapper`2(IEqualityComparer`1<TKey> comparer);
    public DictionaryWrapper`2(int capacity, IEqualityComparer`1<TKey> comparer);
    public DictionaryWrapper`2(int capacity);
    private static DictionaryWrapper`2();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public void CopyTo(Array array, int index);
    public sealed virtual void Add(TKey key, TValue value);
    public sealed virtual void Add(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual bool Remove(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual bool ContainsKey(TKey key);
    public bool ContainsValue(TValue value);
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    public sealed virtual bool Remove(TKey key);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    public IEqualityComparer`1<TKey> get_Comparer();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual ICollection`1<TKey> get_Keys();
    public sealed virtual ICollection`1<TValue> get_Values();
    private sealed virtual override IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Keys();
    private sealed virtual override IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Values();
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public sealed virtual void OnDeserialization(object sender);
}
public static class JetBrains.Util.Diff.Diff : object {
    public static IList`1<DiffFragment> Calc(int oldLength, int newLength, DiffComparer comparer);
}
public class JetBrains.Util.Diff.DiffComparer : MulticastDelegate {
    public DiffComparer(object object, IntPtr method);
    public virtual bool Invoke(int x, int y);
    public virtual IAsyncResult BeginInvoke(int x, int y, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
public class JetBrains.Util.Diff.DiffFragment : ValueType {
    private TextRange myRangeOld;
    private TextRange myRangeNew;
    private DiffFragmentType myDiffFragmentType;
    public TextRange RangeOld { get; }
    public TextRange RangeNew { get; }
    public DiffFragmentType Type { get; }
    public DiffFragment(TextRange rangeOld, TextRange rangeNew, DiffFragmentType fragmentType);
    public TextRange get_RangeOld();
    public TextRange get_RangeNew();
    public DiffFragmentType get_Type();
    public virtual string ToString();
    public static bool op_Equality(DiffFragment f1, DiffFragment f2);
    public static bool op_Inequality(DiffFragment f1, DiffFragment f2);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public enum JetBrains.Util.Diff.DiffFragmentType : Enum {
    public int value__;
    public static DiffFragmentType EQUAL;
    public static DiffFragmentType ADDED;
    public static DiffFragmentType DELETED;
    public static DiffFragmentType MODIFIED;
}
internal class JetBrains.Util.Diff.FragmentBuilder : object {
    private int myPosOld;
    private int myPosNew;
    private List`1<DiffFragment> myFragments;
    public IList`1<DiffFragment> Fragments { get; }
    public FragmentBuilder(int lengthOld, int lengthNew);
    public IList`1<DiffFragment> get_Fragments();
    public sealed virtual void AddEqual(int length);
    public sealed virtual void AddChange(int first, int second);
}
internal interface JetBrains.Util.Diff.IDiffBuilder {
    public abstract virtual void AddEqual(int length);
    public abstract virtual void AddChange(int first, int second);
}
internal class JetBrains.Util.Diff.LCS : object {
    private int myMaxX;
    private int myMaxY;
    private DiffComparer myComparer;
    private LinkedDiffPaths myPathsMatrix;
    private Int32[] myPrevPathKey;
    private Int32[] myPrevEnds;
    private Int32[] myCurrentEnds;
    public LinkedDiffPaths Paths { get; }
    public LCS(int maxX, int maxY, DiffComparer comparer);
    public LinkedDiffPaths get_Paths();
    public int Run();
    private int FindDiagonalEnd(int prevDiagonal, int prevEnd, bool isVertical);
    private int EncodeStep(int prevEnd, int diagLength, int tDiagonal, bool afterVertical);
    private static int CalcBound(int bound, int d);
    private int SkipSnake(int x, int y);
}
internal class JetBrains.Util.Diff.LinkedDiffPaths : object {
    private static int VERTICAL_DIRECTION_FLAG;
    private static int DISTANCE_MASK;
    private int myMaxX;
    private int myMaxY;
    private ChunkList`1<Step> mySteps;
    private int myCornerIndex;
    public LinkedDiffPaths(int maxX, int maxY);
    public void DecodePath(IDiffBuilder builder);
    public int EncodeStep(int x, int y, int diagLength, bool afterVertical, int prevIndex);
}
public class JetBrains.Util.DirectoryScanner : object {
    private IList`1<string> myExcludePatterns;
    private IList`1<string> myIncludePatterns;
    [CompilerGeneratedAttribute]
private static Predicate`1<MatchResult> CS$<>9__CachedAnonymousMethodDelegate8;
    [CompilerGeneratedAttribute]
private static Predicate`1<MatchResult> CS$<>9__CachedAnonymousMethodDelegate9;
    [CompilerGeneratedAttribute]
private static Predicate`1<MatchResult> CS$<>9__CachedAnonymousMethodDelegatea;
    [CompilerGeneratedAttribute]
private static Predicate`1<MatchResult> CS$<>9__CachedAnonymousMethodDelegateb;
    public IList`1<string> IncludePatterns { get; public set; }
    public IList`1<string> ExcludePatterns { get; public set; }
    public IList`1<string> get_IncludePatterns();
    public void set_IncludePatterns(IList`1<string> value);
    public IList`1<string> get_ExcludePatterns();
    public void set_ExcludePatterns(IList`1<string> value);
    private static Wildcard[] ParsePattern(IFileSystem fs, IEnumerable`1<Wildcard> rootPrefix, bool caseSensitive, string pattern);
    public ImmutableArray`1<FileSystemPath> FindFiles(IFileSystem fs, IDirectoryEntry root, bool caseSensitive);
    public ImmutableArray`1<FileSystemPath> FindFiles(FileSystemPath root, bool caseSensitive);
    private static bool Any(AntPatternState[] state, string component, Predicate`1<MatchResult> predicate, AntPatternState[]& newState);
    private static void FindFilesRec(IDirectoryEntry directory, IList`1<FileSystemPath> result, AntPatternState[] includeState, AntPatternState[] excludeState);
    [CompilerGeneratedAttribute]
private static bool <FindFilesRec>b__4(MatchResult x);
    [CompilerGeneratedAttribute]
private static bool <FindFilesRec>b__5(MatchResult x);
    [CompilerGeneratedAttribute]
private static bool <FindFilesRec>b__6(MatchResult x);
    [CompilerGeneratedAttribute]
private static bool <FindFilesRec>b__7(MatchResult x);
}
public class JetBrains.Util.DnsAPI.AAAARecord : ValueType {
    public IP6Address Address;
    public virtual string ToString();
}
public class JetBrains.Util.DnsAPI.ARecord : ValueType {
    public UInt32 Address;
    public virtual string ToString();
}
public class JetBrains.Util.DnsAPI.ATMARecord : ValueType {
    public byte AddressType;
    public string Address;
    public virtual string ToString();
}
public class JetBrains.Util.DnsAPI.DnsException : ApplicationException {
    private UInt32 errcode;
    public UInt32 ErrorCode { get; }
    public DnsException(string message);
    public DnsException(string message, UInt32 errcode);
    public DnsException(string message, Exception innerException);
    public DnsException(SerializationInfo info, StreamingContext context);
    public UInt32 get_ErrorCode();
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
}
internal enum JetBrains.Util.DnsAPI.DnsFreeType : Enum {
    public UInt32 value__;
    public static DnsFreeType FreeFlat;
    public static DnsFreeType FreeRecordList;
}
public enum JetBrains.Util.DnsAPI.DnsQueryReturnCode : Enum {
    public ulong value__;
    public static DnsQueryReturnCode SUCCESS;
    public static DnsQueryReturnCode UNSPECIFIED_ERROR;
    public static DnsQueryReturnCode MASK;
    public static DnsQueryReturnCode FORMAT_ERROR;
    public static DnsQueryReturnCode SERVER_FAILURE;
    public static DnsQueryReturnCode NAME_ERROR;
    public static DnsQueryReturnCode NOT_IMPLEMENTED;
    public static DnsQueryReturnCode REFUSED;
    public static DnsQueryReturnCode YXDOMAIN;
    public static DnsQueryReturnCode YXRRSET;
    public static DnsQueryReturnCode NXRRSET;
    public static DnsQueryReturnCode NOTAUTH;
    public static DnsQueryReturnCode NOTZONE;
    public static DnsQueryReturnCode BADSIG;
    public static DnsQueryReturnCode BADKEY;
    public static DnsQueryReturnCode BADTIME;
    public static DnsQueryReturnCode PACKET_FMT_BASE;
    public static DnsQueryReturnCode NO_RECORDS;
    public static DnsQueryReturnCode BAD_PACKET;
    public static DnsQueryReturnCode NO_PACKET;
    public static DnsQueryReturnCode RCODE;
    public static DnsQueryReturnCode UNSECURE_PACKET;
}
[FlagsAttribute]
internal enum JetBrains.Util.DnsAPI.DnsQueryType : Enum {
    public UInt32 value__;
    public static DnsQueryType STANDARD;
    public static DnsQueryType ACCEPT_TRUNCATED_RESPONSE;
    public static DnsQueryType USE_TCP_ONLY;
    public static DnsQueryType NO_RECURSION;
    public static DnsQueryType BYPASS_CACHE;
    public static DnsQueryType NO_WIRE_QUERY;
    public static DnsQueryType NO_LOCAL_NAME;
    public static DnsQueryType NO_HOSTS_FILE;
    public static DnsQueryType NO_NETBT;
    public static DnsQueryType WIRE_ONLY;
    public static DnsQueryType TREAT_AS_FQDN;
    [ObsoleteAttribute]
public static DnsQueryType ALLOW_EMPTY_AUTH_RESP;
    public static DnsQueryType DONT_RESET_TTL_VALUES;
    public static DnsQueryType RESERVED;
    [ObsoleteAttribute("use NO_WIRE_QUERY instead")]
public static DnsQueryType CACHE_ONLY;
    public static DnsQueryType RETURN_MESSAGE;
}
internal class JetBrains.Util.DnsAPI.DnsRecord : ValueType {
    public IntPtr Next;
    public string Name;
    public DnsRecordType RecordType;
    public ushort DataLength;
    public DnsRecordFlags Flags;
    public UInt32 Ttl;
    public UInt32 Reserved;
}
[FlagsAttribute]
public enum JetBrains.Util.DnsAPI.DnsRecordType : Enum {
    public ushort value__;
    public static DnsRecordType A;
    public static DnsRecordType NS;
    [ObsoleteAttribute]
public static DnsRecordType MD;
    [ObsoleteAttribute]
public static DnsRecordType MF;
    public static DnsRecordType CNAME;
    public static DnsRecordType SOA;
    public static DnsRecordType MB;
    public static DnsRecordType MG;
    public static DnsRecordType MR;
    public static DnsRecordType NULL;
    public static DnsRecordType WKS;
    public static DnsRecordType PTR;
    public static DnsRecordType HINFO;
    public static DnsRecordType MINFO;
    public static DnsRecordType MX;
    public static DnsRecordType TEXT;
    public static DnsRecordType RP;
    public static DnsRecordType AFSDB;
    public static DnsRecordType X25;
    public static DnsRecordType ISDN;
    public static DnsRecordType RT;
    public static DnsRecordType NSAP;
    [ObsoleteAttribute]
public static DnsRecordType NSAPPTR;
    public static DnsRecordType SIG;
    public static DnsRecordType KEY;
    public static DnsRecordType PX;
    [ObsoleteAttribute]
public static DnsRecordType GPOS;
    public static DnsRecordType AAAA;
    public static DnsRecordType LOC;
    public static DnsRecordType NXT;
    public static DnsRecordType SRV;
    public static DnsRecordType ATMA;
    public static DnsRecordType TKEY;
    public static DnsRecordType TSIG;
    public static DnsRecordType IXFR;
    public static DnsRecordType AXFR;
    public static DnsRecordType MAILB;
    public static DnsRecordType MAILA;
    public static DnsRecordType ALL;
    public static DnsRecordType ANY;
    public static DnsRecordType WINS;
    public static DnsRecordType WINSR;
    public static DnsRecordType NBSTAT;
}
public class JetBrains.Util.DnsAPI.DnsRequest : object {
    private DnsQueryType QueryType;
    private string domain;
    private DnsServerCollection servers;
    public DnsServerCollection Servers { get; }
    public bool UseTCPOnly { get; public set; }
    public bool AcceptTruncatedResponse { get; public set; }
    public bool NoRecursion { get; public set; }
    public bool BypassCache { get; public set; }
    public bool QueryCacheOnly { get; public set; }
    public bool WireOnly { get; public set; }
    public bool NoLocalName { get; public set; }
    public bool NoHostsFile { get; public set; }
    public bool NoNetbt { get; public set; }
    public bool QueryReturnMessage { get; public set; }
    public bool TreatAsFQDN { get; public set; }
    public bool DontResetTTLValues { get; public set; }
    public string Domain { get; public set; }
    public DnsRequest(string domain);
    private static UInt32 DnsQuery(string Name, DnsRecordType Type, DnsQueryType Options, IntPtr Servers, IntPtr& QueryResultsSet, IntPtr Reserved);
    private static void DnsRecordListFree(IntPtr RecordList, DnsFreeType FreeType);
    public DnsServerCollection get_Servers();
    public bool get_UseTCPOnly();
    public void set_UseTCPOnly(bool value);
    public bool get_AcceptTruncatedResponse();
    public void set_AcceptTruncatedResponse(bool value);
    public bool get_NoRecursion();
    public void set_NoRecursion(bool value);
    public bool get_BypassCache();
    public void set_BypassCache(bool value);
    public bool get_QueryCacheOnly();
    public void set_QueryCacheOnly(bool value);
    public bool get_WireOnly();
    public void set_WireOnly(bool value);
    public bool get_NoLocalName();
    public void set_NoLocalName(bool value);
    public bool get_NoHostsFile();
    public void set_NoHostsFile(bool value);
    public bool get_NoNetbt();
    public void set_NoNetbt(bool value);
    public bool get_QueryReturnMessage();
    public void set_QueryReturnMessage(bool value);
    public bool get_TreatAsFQDN();
    public void set_TreatAsFQDN(bool value);
    public bool get_DontResetTTLValues();
    public void set_DontResetTTLValues(bool value);
    private bool GetSetting(DnsQueryType type);
    private void SetSetting(DnsQueryType type, bool newvalue);
    public string get_Domain();
    public void set_Domain(string value);
    private void Initialize(string domain);
    public DnsResponse GetResponse();
    private void GetData(IntPtr ptr, DnsRecord& dnsrec, Object& Data);
}
public class JetBrains.Util.DnsAPI.DnsResponse : object {
    private DnsWrapperCollection rawrecords;
    public DnsWrapperCollection RawRecords { get; }
    public ARecord[] ARecords { get; }
    public MXRecord[] MXRecords { get; }
    public PTRRecord[] NSRecords { get; }
    public DnsWrapperCollection get_RawRecords();
    public ArrayList GetRecords(DnsRecordType type);
    public ARecord[] get_ARecords();
    public MXRecord[] get_MXRecords();
    public PTRRecord[] get_NSRecords();
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Util.DnsAPI.DnsServerCollection : CollectionBase {
    public IPAddress Item { get; }
    internal IP4_Array ToIP4_Array();
    public void Add(string host);
    public IPAddress get_Item(int idx);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class JetBrains.Util.DnsAPI.DnsWrapper : ValueType {
    public DnsRecordType RecordType;
    public object RecordData;
    public bool Equals(DnsRecordType type);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual int CompareTo(object obj);
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Util.DnsAPI.DnsWrapperCollection : ReadOnlyCollectionBase {
    public DnsWrapper Item { get; }
    internal bool Contains(DnsWrapper w);
    internal void Add(DnsWrapper w);
    public DnsWrapper get_Item(int i);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class JetBrains.Util.DnsAPI.IP4_Array : ValueType {
    public int AddrCount;
    public Int32[] AddrArray;
}
public class JetBrains.Util.DnsAPI.IP6Address : ValueType {
    public UInt32 IPFrag1;
    public UInt32 IPFrag2;
    public UInt32 IPFrag3;
    public UInt32 IPFrag4;
    public UInt32 IPFrag5;
    public UInt32 IPFrag6;
    public UInt32 IPFrag7;
    public UInt32 IPFrag8;
    public virtual string ToString();
}
public class JetBrains.Util.DnsAPI.KEYRecord : ValueType {
    public ushort Flags;
    public byte Protocol;
    public byte Algorithm;
    public byte Key;
    public virtual string ToString();
}
public class JetBrains.Util.DnsAPI.LOCRecord : ValueType {
    public ushort Version;
    public ushort Size;
    public ushort HorPrec;
    public ushort VerPrec;
    public UInt32 Latitude;
    public UInt32 Longitude;
    public UInt32 Altitude;
}
public class JetBrains.Util.DnsAPI.MINFORecord : ValueType {
    public string Mailbox;
    public string ErrorsMailbox;
    public virtual string ToString();
}
public class JetBrains.Util.DnsAPI.MXRecord : ValueType {
    public string Exchange;
    public ushort Preference;
    public ushort Pad;
    public virtual string ToString();
}
public class JetBrains.Util.DnsAPI.NULLRecord : ValueType {
    public UInt32 ByteCount;
    public string Data;
    public virtual string ToString();
}
public class JetBrains.Util.DnsAPI.NXTRecord : ValueType {
    public string NameNext;
    public byte TypeBitMap;
    public virtual string ToString();
}
public class JetBrains.Util.DnsAPI.PTRRecord : ValueType {
    public string HostName;
    public virtual string ToString();
}
public class JetBrains.Util.DnsAPI.SIGRecord : ValueType {
    public string Signer;
    public ushort TypeCovered;
    public byte Algorithm;
    public byte LabelCount;
    public UInt32 OriginalTtl;
    public UInt32 Expiration;
    public UInt32 TimeSigned;
    public ushort KeyTag;
    public ushort Pad;
    public byte Signature;
}
public class JetBrains.Util.DnsAPI.SOARecord : ValueType {
    public string PrimaryServer;
    public string Administrator;
    public UInt32 SerialNo;
    public UInt32 Refresh;
    public UInt32 Retry;
    public UInt32 Expire;
    public UInt32 DefaultTtl;
    public virtual string ToString();
}
public class JetBrains.Util.DnsAPI.SRVRecord : ValueType {
    public string NameNext;
    public ushort Priority;
    public ushort Weight;
    public ushort Port;
    public ushort Pad;
    public virtual string ToString();
}
public class JetBrains.Util.DnsAPI.TKEYRecord : ValueType {
    public string Algorithm;
    public IntPtr AlgorithmPacket;
    public IntPtr Key;
    public IntPtr OtherData;
    public UInt32 CreateTime;
    public UInt32 ExpireTime;
    public ushort Mode;
    public ushort Error;
    public ushort KeyLength;
    public ushort OtherLength;
    public char AlgNameLength;
    public bool PacketPointers;
}
public class JetBrains.Util.DnsAPI.TSIGRecord : ValueType {
    public string Algorithm;
    public IntPtr AlgorithmPacket;
    public IntPtr Key;
    public IntPtr OtherData;
    public long CreateTime;
    public ushort FudgeTime;
    public ushort OriginalXid;
    public ushort Error;
    public ushort KeyLength;
    public ushort OtherLength;
    public char AlgNameLength;
    public bool PacketPointers;
}
public class JetBrains.Util.DnsAPI.TXTRecord : ValueType {
    public UInt32 StringCount;
    public string StringArray;
    public virtual string ToString();
}
public class JetBrains.Util.DnsAPI.WINSRecord : ValueType {
    public UInt32 MappingFlag;
    public UInt32 LookupTimeout;
    public UInt32 CacheTimeout;
    public UInt32 ServerCount;
    public IntPtr WinsServers;
    public virtual string ToString();
}
public class JetBrains.Util.DnsAPI.WINSRRecord : ValueType {
    public UInt32 MappingFlag;
    public UInt32 LookupTimeout;
    public UInt32 CacheTimeout;
    public string ResultDomain;
    public virtual string ToString();
}
public class JetBrains.Util.DnsAPI.WKSRecord : ValueType {
    public UInt32 IpAddress;
    public char Protocol;
    public byte BitMask;
    public virtual string ToString();
}
public class JetBrains.Util.Dotnet.Internal.GacFolderUtil : object {
    private static Dictionary`2<FileSystemPath, FolderContentCache> ourGacFolderCaches;
    private static GacFolderUtil();
    public static FolderContentCache CreateCache(Lifetime lifetime, FileSystemPath gacRootPath);
    private static IEnumerable`1<FileSystemPath> GetChildDirectories(FileSystemPath gacRootPath, FileSystemPath folderPath);
    public static bool FileExists(FileSystemPath gacRootPath, FileSystemPath filePath);
    public static bool DirectoryExists(FileSystemPath gacRootPath, FileSystemPath folderPath);
    public static void GetCandidatesFromGac(FileSystemPath gacPath, FileSystemPath assemblyFolder, string name, LocalList`1& result);
}
public static class JetBrains.Util.Dotnet.MicrosoftDotNet.DotNetFrameworkGac : object {
    public static String[] GacFolders;
    private static String[] ourGacFolders40;
    private static DotNetFrameworkGac();
    public static FileSystemPath ResolveInGac(AssemblyNameInfo assemblyName, FileSystemPath gacRootPath);
    public static FileSystemPath GetGacPath();
    [CanBeNullAttribute]
public static FileSystemPath GetGacPath40();
    public static FileSystemPath ResolveInGac40(AssemblyNameInfo assemblyName, string platform, FileSystemPath gacPath);
    [NotNullAttribute]
private static IList`1<FileSystemPath> GetCandidatesFromGacCore(string name, FileSystemPath gacPath, String[] gacfolders);
    [NotNullAttribute]
public static IList`1<FileSystemPath> GetCandidatesFromGac(string name, FileSystemPath gacPath);
    [NotNullAttribute]
public static IList`1<FileSystemPath> GetCandidatesFromGac40(string name, FileSystemPath gacPath);
}
public class JetBrains.Util.Dotnet.MicrosoftDotNet.DotNetGac : object {
    public static DotNetGac Instance;
    [CompilerGeneratedAttribute]
private FileSystemPath <GacPath>k__BackingField;
    [CompilerGeneratedAttribute]
private FileSystemPath <GacPath40>k__BackingField;
    public FileSystemPath GacPath { get; private set; }
    public FileSystemPath GacPath40 { get; private set; }
    private static DotNetGac();
    [CompilerGeneratedAttribute]
public FileSystemPath get_GacPath();
    [CompilerGeneratedAttribute]
private void set_GacPath(FileSystemPath value);
    [CompilerGeneratedAttribute]
public FileSystemPath get_GacPath40();
    [CompilerGeneratedAttribute]
private void set_GacPath40(FileSystemPath value);
}
public class JetBrains.Util.Dotnet.MicrosoftDotNet.DotNetRuntimes : object {
    private static string MsCorLib;
    private static DotNetRuntimes ourInstance;
    private static DotNetRuntimes ourInstances32;
    private static RelativePath ourRegistryPathNDP;
    private static RelativePath ourRegistryPathWowNDP;
    private static BackSlashSeparatedRelativePath ourRegistryPathFramework;
    [CompilerGeneratedAttribute]
private IList`1<DotNetRuntime> <AllRuntimes>k__BackingField;
    [CompilerGeneratedAttribute]
private static Func`2<FrameworkRegistryData, bool> CS$<>9__CachedAnonymousMethodDelegate5;
    [CompilerGeneratedAttribute]
private static Func`2<FrameworkRegistryData, bool> CS$<>9__CachedAnonymousMethodDelegate6;
    [CompilerGeneratedAttribute]
private static Func`2<FrameworkRegistryData, bool> CS$<>9__CachedAnonymousMethodDelegate7;
    [CompilerGeneratedAttribute]
private static Func`2<FrameworkRegistryData, bool> CS$<>9__CachedAnonymousMethodDelegate8;
    [CompilerGeneratedAttribute]
private static Func`2<FrameworkRegistryData, Version> CS$<>9__CachedAnonymousMethodDelegateb;
    [CompilerGeneratedAttribute]
private static Func`2<DotNetRuntime, bool> CS$<>9__CachedAnonymousMethodDelegatef;
    public IList`1<DotNetRuntime> AllRuntimes { get; private set; }
    [UsedImplicitlyAttribute]
public static DotNetRuntimes Instance { get; }
    [UsedImplicitlyAttribute]
public static DotNetRuntimes Instances32 { get; }
    private DotNetRuntimes(IList`1<DotNetRuntime> allRuntimes);
    private static DotNetRuntimes();
    [CompilerGeneratedAttribute]
public IList`1<DotNetRuntime> get_AllRuntimes();
    [CompilerGeneratedAttribute]
private void set_AllRuntimes(IList`1<DotNetRuntime> value);
    public static DotNetRuntimes get_Instance();
    public static DotNetRuntimes get_Instances32();
    private static DotNetRuntimes GetDotNetRuntimes();
    private static DotNetRuntime GetRuntime(Func`2<FrameworkRegistryData, bool> versionFilter, string folderPrefix, string fileToCheck, RelativePath aspNetCompilerPath, RelativePath temporaryASPFilesFile);
    [CanBeNullAttribute]
public static FileSystemPath FindDotNetFrameworkPath(string prefix, string requiredFile);
    private static FileSystemPath GetInstallRoot();
    [CanBeNullAttribute]
public DotNetRuntime GetByTargetPlatformId(PlatformID platformId);
    [CanBeNullAttribute]
public DotNetRuntime GetByTargetNuGetFramework(NuGetFramework nugetFramework);
    public DotNetRuntime GetByTargetFrameworkVersion(Version targetVersion);
    [CompilerGeneratedAttribute]
private static bool <GetDotNetRuntimes>b__1(FrameworkRegistryData x);
    [CompilerGeneratedAttribute]
private static bool <GetDotNetRuntimes>b__2(FrameworkRegistryData x);
    [CompilerGeneratedAttribute]
private static bool <GetDotNetRuntimes>b__3(FrameworkRegistryData x);
    [CompilerGeneratedAttribute]
private static bool <GetDotNetRuntimes>b__4(FrameworkRegistryData x);
    [CompilerGeneratedAttribute]
private static Version <GetRuntime>b__a(FrameworkRegistryData x);
    [CompilerGeneratedAttribute]
private static bool <GetByTargetFrameworkVersion>b__c(DotNetRuntime x);
}
[PublicAPIAttribute]
public class JetBrains.Util.Dotnet.MicrosoftDotNet.ReferenceAssemblies : object {
    private static ReferenceAssemblies ourInstance;
    [CompilerGeneratedAttribute]
private List`1<ReferenceAssemblyFolder> <ReferenceAssemblyFolders>k__BackingField;
    [CompilerGeneratedAttribute]
private ILookup`2<Version, ReferenceAssemblyFolder> <ReferenceAssemblyFoldersLookup>k__BackingField;
    [CompilerGeneratedAttribute]
private static Func`2<ReferenceAssemblyFolder, Version> CS$<>9__CachedAnonymousMethodDelegate1;
    [PublicAPIAttribute]
public List`1<ReferenceAssemblyFolder> ReferenceAssemblyFolders { get; private set; }
    [PublicAPIAttribute]
public ILookup`2<Version, ReferenceAssemblyFolder> ReferenceAssemblyFoldersLookup { get; private set; }
    public static ReferenceAssemblies Instance { get; }
    private static ReferenceAssemblies();
    [CompilerGeneratedAttribute]
public List`1<ReferenceAssemblyFolder> get_ReferenceAssemblyFolders();
    [CompilerGeneratedAttribute]
private void set_ReferenceAssemblyFolders(List`1<ReferenceAssemblyFolder> value);
    [CompilerGeneratedAttribute]
public ILookup`2<Version, ReferenceAssemblyFolder> get_ReferenceAssemblyFoldersLookup();
    [CompilerGeneratedAttribute]
private void set_ReferenceAssemblyFoldersLookup(ILookup`2<Version, ReferenceAssemblyFolder> value);
    public static ReferenceAssemblies get_Instance();
    private IList`1<ReferenceAssemblyFolder> GetReferenceAssembliesVersion3Folder();
    private static List`1<ReferenceAssemblyFolder> AddRuntimeFolders();
    public IList`1<ReferenceAssemblyFolder> GetReferenceAssembliesFolder();
    [NotNullAttribute]
private FileSystemPath GetProgramFiles86();
    [NotNullAttribute]
public FileSystemPath GetMicrosoftReferenceAssembliesRoot();
    [NotNullAttribute]
private FileSystemPath GetReferencedAssembliesDir();
    [CanBeNullAttribute]
private FileSystemPath GetReferenceAssembliesDirectory(string directoryName);
    [CompilerGeneratedAttribute]
private static Version <.ctor>b__0(ReferenceAssemblyFolder x);
}
public static class JetBrains.Util.Dotnet.Mono.MonoDiscoveryUtil : object {
    public static List`1<MonoInstance> InstancesFromDefaultLocation;
    private static MonoDiscoveryUtil();
    [CanBeNullAttribute]
public static MonoInstance TryGetMonoRuntimeFromFolder(FileSystemPath rootFolder);
    [NotNullAttribute]
public static List`1<MonoInstance> MonoInstancesFromDefaultLocation();
    [NotNullAttribute]
private static List`1<MonoInstance> TryGetMonoRuntimeFromFolders(IEnumerable`1<FileSystemPath> rootFolders);
}
public class JetBrains.Util.Dotnet.Mono.MonoInstance : object {
    private IList`1<MonoRuntime> myMonoRuntimes;
    [CompilerGeneratedAttribute]
private FileSystemPath <RootFolder>k__BackingField;
    public FileSystemPath RootFolder { get; private set; }
    public IList`1<MonoRuntime> MonoRuntimes { get; }
    public MonoInstance(FileSystemPath rootFolder);
    [CompilerGeneratedAttribute]
public FileSystemPath get_RootFolder();
    [CompilerGeneratedAttribute]
private void set_RootFolder(FileSystemPath value);
    public IList`1<MonoRuntime> get_MonoRuntimes();
    private IEnumerable`1<MonoRuntime> GetRuntimes();
}
public class JetBrains.Util.Dotnet.Mono.MonoRuntime : object {
    [CanBeNullAttribute]
public static MonoRuntime ExecutingRuntime;
    public static IList`1<MonoRuntime> DefaultRuntimes;
    [CompilerGeneratedAttribute]
private FileSystemPath <RuntimePath>k__BackingField;
    [CompilerGeneratedAttribute]
private FileSystemPath <GacPath>k__BackingField;
    [CompilerGeneratedAttribute]
private FileSystemPath <GacPathOverride>k__BackingField;
    [CompilerGeneratedAttribute]
private static Func`1<string> CS$<>9__CachedAnonymousMethodDelegate1;
    [CompilerGeneratedAttribute]
private static Func`2<MonoInstance, IEnumerable`1<MonoRuntime>> CS$<>9__CachedAnonymousMethodDelegate3;
    public FileSystemPath RuntimePath { get; private set; }
    public FileSystemPath GacPath { get; private set; }
    public FileSystemPath GacPathOverride { get; private set; }
    internal MonoRuntime(FileSystemPath gacPath, FileSystemPath gacPathOverride, FileSystemPath runtimePath);
    private static MonoRuntime();
    [CompilerGeneratedAttribute]
public FileSystemPath get_RuntimePath();
    [CompilerGeneratedAttribute]
private void set_RuntimePath(FileSystemPath value);
    [CompilerGeneratedAttribute]
public FileSystemPath get_GacPath();
    [CompilerGeneratedAttribute]
private void set_GacPath(FileSystemPath value);
    [CompilerGeneratedAttribute]
public FileSystemPath get_GacPathOverride();
    [CompilerGeneratedAttribute]
private void set_GacPathOverride(FileSystemPath value);
    [CanBeNullAttribute]
private static MonoRuntime InitFromCurrentRuntime();
    private static string GetMonoGacDir();
    private static IList`1<MonoRuntime> InitDefaultInstance();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
private static string <GetMonoGacDir>b__0();
    [CompilerGeneratedAttribute]
private static IEnumerable`1<MonoRuntime> <InitDefaultInstance>b__2(MonoInstance x);
}
public class JetBrains.Util.ElementCreator`2 : MulticastDelegate {
    public ElementCreator`2(object object, IntPtr method);
    public virtual TElement Invoke(TKey key);
    public virtual IAsyncResult BeginInvoke(TKey key, AsyncCallback callback, object object);
    public virtual TElement EndInvoke(IAsyncResult result);
}
public class JetBrains.Util.ElementsCache`2 : object {
    private ReaderWriterLock myCacheLock;
    private ElementCreator`2<TKey, TElement> myElementCreator;
    private Dictionary`2<TKey, TElement> myElements;
    public ElementCreator`2<TKey, TElement> ElementCreator { get; }
    public ICollection`1<TKey> Keys { get; }
    public ElementsCache`2(ElementCreator`2<TKey, TElement> elementCreator);
    public ElementCreator`2<TKey, TElement> get_ElementCreator();
    public ICollection`1<TKey> get_Keys();
    public TElement Get(TKey key);
    protected virtual void OnAfterElementCreated(TKey key, TElement element);
    public bool TryGet(TKey key, TElement& element);
    public bool Contains(TKey key);
    public virtual void Drop(TKey key);
    public virtual void Reset();
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Util.EmptyDictionary`2 : object {
    [NotNullAttribute]
public static EmptyDictionary`2<TKey, TValue> Instance;
    [NotNullAttribute]
public static IDictionary`2<TKey, TValue> InstanceDictionary;
    [NotNullAttribute]
public static IReadOnlyDictionary`2<TKey, TValue> InstanceReadOnly;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public ICollection`1<TKey> Keys { get; }
    public ICollection`1<TValue> Values { get; }
    [NotNullAttribute]
private IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Keys { get; }
    [NotNullAttribute]
private IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Values { get; }
    public TValue Item { get; public set; }
    private static EmptyDictionary`2();
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Add(TKey key, TValue value);
    public sealed virtual void Add(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual bool ContainsKey(TKey key);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual bool Remove(TKey key);
    public sealed virtual bool Remove(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual ICollection`1<TKey> get_Keys();
    public sealed virtual ICollection`1<TValue> get_Values();
    private sealed virtual override IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Keys();
    private sealed virtual override IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Values();
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
}
[ExtensionAttribute]
public static class JetBrains.Util.EncryptionUtil : object {
    public static string DES_KEY;
    private static string PREFIX;
    public static string Encrypt(string settingValue);
    public static string Decrypt(string encryptedValue);
    public static string SetEncryptedString(string value);
    [ExtensionAttribute]
public static void SetEncryptedString(ISettingsTable settingsTable, string settingName, string value);
    public static string GetEncryptedString(string value);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static string GetEncryptedString(ISettingsTable settingsTable, string settingName);
    [ExtensionAttribute]
public static string GetEncryptedString(ISettingsTable settingsTable, string settingName, string defaultValue);
    [ObsoleteAttribute("Slow, use version from ArrayUtil.")]
public static string ToHexString(Byte[] buf);
    [ExtensionAttribute]
public static string SHA1(string input);
    [ExtensionAttribute]
public static string SHA1(Byte[] input);
}
public enum JetBrains.Util.EnsureWritableResult : Enum {
    public int value__;
    public static EnsureWritableResult SUCCESS;
    public static EnsureWritableResult FAILURE;
    public static EnsureWritableResult CHANGES_DETECTED;
    public static EnsureWritableResult CANCELLED;
}
public abstract class JetBrains.Util.EnumPattern : object {
    [NotNullAttribute]
private string myName;
    protected EnumPattern(string name);
    public virtual string ToString();
    public static bool op_Equality(EnumPattern p1, EnumPattern p2);
    public static bool op_Inequality(EnumPattern p1, EnumPattern p2);
    [DebuggerStepThroughAttribute]
public sealed virtual bool Equals(object obj);
    [DebuggerStepThroughAttribute]
public sealed virtual int GetHashCode();
}
[ExtensionAttribute]
public static class JetBrains.Util.EnvironmentVariablesUtil : object {
    private static ILogger ourLogger;
    private static EnvironmentVariablesUtil();
    [NotNullAttribute]
public static FileSystemPath TryFindInPath(string fileName);
    [ExtensionAttribute]
public static void LogEnvironmentVariables(ILogger logger);
    [ExtensionAttribute]
public static void LogEnvironmentVariables(ILogger logger, ProcessStartInfo info);
    public static string Dump(IDictionary`2<string, string> environmentVariables);
    public static string GetEnvironmentVariableWithRenameToPidSpecificName(string sEnvironmentVariableName);
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Util.EquatableList`1 : object {
    [NotNullAttribute]
private IList`1<TItem> myStorage;
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<TItem>.IsReadOnly { get; }
    public TItem Item { get; public set; }
    public EquatableList`1(IList`1<TItem> storage);
    private sealed virtual override IEnumerator`1<TItem> System.Collections.Generic.IEnumerable<TItem>.GetEnumerator();
    private sealed virtual override void System.Collections.Generic.ICollection<TItem>.Add(TItem item);
    private sealed virtual override void System.Collections.Generic.ICollection<TItem>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<TItem>.Contains(TItem item);
    private sealed virtual override void System.Collections.Generic.ICollection<TItem>.CopyTo(TItem[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<TItem>.Remove(TItem item);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<TItem>.get_IsReadOnly();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override int System.Collections.Generic.IList<TItem>.IndexOf(TItem item);
    private sealed virtual override void System.Collections.Generic.IList<TItem>.Insert(int index, TItem item);
    private sealed virtual override void System.Collections.Generic.IList<TItem>.RemoveAt(int index);
    public sealed virtual TItem get_Item(int index);
    public sealed virtual void set_Item(int index, TItem value);
    public sealed virtual bool Equals(EquatableList`1<TItem> other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(EquatableList`1<TItem> left, EquatableList`1<TItem> right);
    public static bool op_Inequality(EquatableList`1<TItem> left, EquatableList`1<TItem> right);
}
[ExtensionAttribute]
public static class JetBrains.Util.EventBus.EventBusExtensions : object {
    [ExtensionAttribute]
public static void Fire(IEventContext context, EventId`1<T> eventId, T args);
    [ExtensionAttribute]
public static void Fire(EventId`1<T> eventId, IEventContext context, T args);
    [ExtensionAttribute]
public static void Subscribe(IEventBus bus, Lifetime lifetime, Action`1<TEventArgs> action);
    [ExtensionAttribute]
public static void Subscribe(IEventBus bus, Lifetime lifetime, Action`2<EventId, TEventArgs> action);
    [ExtensionAttribute]
public static void Subscribe(IEventBus bus, Lifetime lifetime, ExecutionMode executionMode, Action`1<TEventArgs> action);
    [ExtensionAttribute]
public static void Subscribe(IEventBus bus, Lifetime lifetime, ExecutionMode executionMode, Action`2<EventId, TEventArgs> action);
    [ExtensionAttribute]
public static void Subscribe(IEventBus bus, Lifetime lifetime, EventId`1<TEventArgs> eventId, Action`1<TEventArgs> action);
    [ExtensionAttribute]
public static void Subscribe(IEventBus bus, Lifetime lifetime, EventId`1<TEventArgs> eventId, Action`2<EventId, TEventArgs> action);
    [ExtensionAttribute]
public static void Subscribe(IEventBus bus, Lifetime lifetime, EventId`1<TEventArgs> eventId, ExecutionMode executionMode, Action`1<TEventArgs> action);
    [ExtensionAttribute]
public static void Subscribe(IEventBus bus, Lifetime lifetime, EventId`1<TEventArgs> eventId, ExecutionMode executionMode, Action`2<EventId, TEventArgs> action);
    [ExtensionAttribute]
public static bool IsSubEventOf(EventId id, EventId parent);
}
public abstract class JetBrains.Util.EventBus.EventId : object {
    protected string myEventName;
    protected EventId myParentEvent;
    public string EventName { get; }
    public EventId ParentEvent { get; }
    internal EventId(string eventName);
    public string get_EventName();
    public EventId get_ParentEvent();
    public bool Equals(EventId other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public abstract virtual Type GetEventArgsType();
    public virtual string ToString();
}
public class JetBrains.Util.EventBus.EventId`1 : EventId {
    public EventId`1(string eventName);
    public EventId`1<TSubEventType> CreateSubEvent(string eventName);
    public virtual Type GetEventArgsType();
    public bool Equals(EventId`1<TEventArgs> other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public abstract class JetBrains.Util.EventBus.Execution.ExecutionMode : object {
    public static ExecutionMode Simple;
    public static ExecutionMode ThreadPool;
    private static ExecutionMode();
    public abstract virtual void Execute(Action`2<EventId, T> action, EventId eventId, T argument);
    public ExecutionMode Grouping(TimeSpan minimumTimespan);
    public ExecutionMode Grouping(TimeSpan minimumTimespan, bool skipFirst);
}
public class JetBrains.Util.EventBus.Execution.FreeThreadedExecutionMode : ExecutionMode {
    public virtual void Execute(Action`2<EventId, T> action, EventId eventId, T argument);
}
public class JetBrains.Util.EventBus.Execution.GroupingExecutionMode : ExecutionMode {
    private object myLock;
    private TimeSpan myMinimumInterval;
    private DateTime myInitialDate;
    private Dictionary`2<EventId, DateTime> myLastExecuted;
    private ExecutionMode myParentExecutionMode;
    public GroupingExecutionMode(ExecutionMode parentExecutionMode, TimeSpan minimumInterval, bool skipFirst);
    public virtual void Execute(Action`2<EventId, T> action, EventId eventId, T argument);
}
public interface JetBrains.Util.EventBus.Execution.IWork {
    public abstract virtual void Execute();
}
public class JetBrains.Util.EventBus.Execution.SimpleExecutionMode : ExecutionMode {
    public virtual void Execute(Action`2<EventId, T> action, EventId eventId, T argument);
}
public class JetBrains.Util.EventBus.Execution.SingleFreeThreadExecutionMode : ExecutionMode {
    private ThreadUtil myThreadUtil;
    public SingleFreeThreadExecutionMode(Lifetime lifetime, string threadName);
    public void EnsureThread(Action action);
    private void Enqueue(Action action);
    public virtual void Execute(Action`2<EventId, T> action, EventId eventId, T argument);
    public bool CheckAccess();
    public void AssertAccess();
}
public class JetBrains.Util.EventBus.Execution.ThreadUtil : object {
    [NotNullAttribute]
private string myName;
    private object myLock;
    private Queue`1<IWork> myQueue;
    private AutoResetEvent myEvent;
    private Thread myThread;
    public ThreadUtil(Lifetime lifetime, string name);
    public bool CheckThread();
    public void Enqueue(IWork work);
    private void ThreadBody();
    public void AssertAccess();
    [CompilerGeneratedAttribute]
private void <.ctor>b__1();
    [CompilerGeneratedAttribute]
private void <.ctor>b__2();
}
public interface JetBrains.Util.EventBus.IEvent`1 {
    public abstract virtual void Raise(T eventArgs);
}
public interface JetBrains.Util.EventBus.IEventBus {
    public abstract virtual IEventRef`1<T> Event(EventId`1<T> eventId);
    public abstract virtual IEventRef`1<T> Event();
}
public interface JetBrains.Util.EventBus.IEventContext {
    public abstract virtual void Invoke(EventId`1<T> eventId, T args);
    public abstract virtual IEventContext InvokeStartFinish(EventId`1<TStartArgs> startEventId, EventId`1<TFinishArgs> finishEventId, TStartArgs args, Func`1<TFinishArgs> finishArgs);
}
public interface JetBrains.Util.EventBus.IEventRef`1 {
    public abstract virtual void Subscribe(Lifetime lifetime, Action`1<T> handler);
    public abstract virtual void Subscribe(Lifetime lifetime, Action`2<EventId, T> handler);
    public abstract virtual void Subscribe(Lifetime lifetime, ExecutionMode mode, Action`1<T> handler);
    public abstract virtual void Subscribe(Lifetime lifetime, ExecutionMode mode, Action`2<EventId, T> handler);
}
public interface JetBrains.Util.EventBus.IEventSubscribtion {
    public abstract virtual void Invoke(EventId eventId, object eventArgs);
}
public interface JetBrains.Util.EventBus.IEventSubscribtion`1 {
    public abstract virtual void Invoke(EventId eventId, T eventArgs);
}
public class JetBrains.Util.EventBus.Impl.EventBusException : Exception {
    public EventBusException(string message);
}
public class JetBrains.Util.EventBus.Impl.EventBusImpl : object {
    private object mySync;
    private Dictionary`2<EventId, List`1<IEventSubscribtion>> myEventIdToSubscribtions;
    private Dictionary`2<Type, List`1<IEventSubscribtion>> myArgTypeToSubscribtions;
    public sealed virtual IEventRef`1<T> Event(EventId`1<T> eventId);
    public sealed virtual IEventRef`1<T> Event();
    private List`1<EventId> GetEventIds(EventId`1<T> id);
    private bool IsParentEvent(EventId childEvent, EventId parentEvent);
    private List`1<EventId> GetEventIdsByType();
    private static bool IsMatchByType(Type eventType, Type subscriberType);
    private void AddEventSubscribtion(EventId eventId, IEventSubscribtion eventSubscribtion);
    private void RemoveEventSubscribtion(EventId eventId, IEventSubscribtion subscribtion);
    private void InvokeEventNow(EventId eventId, object eventArgs);
    private void RegisterEventInternal(EventId`1<T> eventId);
    public sealed virtual void Invoke(EventId`1<T> eventId, T args);
    private void RegisterEvent(EventId`1<T> eventId);
    public sealed virtual IEventContext InvokeStartFinish(EventId`1<TStartArgs> startEventId, EventId`1<TFinishArgs> finishEventId, TStartArgs args, Func`1<TFinishArgs> finishArgs);
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
private void <Event>b__8(IEventSubscribtion`1<T> s);
    [CompilerGeneratedAttribute]
private void <Event>b__9(IEventSubscribtion`1<T> s);
}
public class JetBrains.Util.EventBus.Impl.EventImpl`1 : object {
    private EventId`1<TEventArgs> myEventId;
    private Action`2<EventImpl`1<TEventArgs>, TEventArgs> myInvoke;
    private bool myIsDisposed;
    public EventId`1<TEventArgs> EventId { get; }
    internal EventImpl`1(EventId`1<TEventArgs> eventId, Action`2<EventImpl`1<TEventArgs>, TEventArgs> invoke);
    [DebuggerStepThroughAttribute]
public EventId`1<TEventArgs> get_EventId();
    public sealed virtual void Raise(TEventArgs eventArgs);
}
public class JetBrains.Util.EventBus.Impl.EventQueueItem : ValueType {
    public EventId EventId;
    public object Args;
    public EventQueueItem(EventId eventId, object args);
}
internal class JetBrains.Util.EventBus.Impl.EventRef`1 : object {
    private Action`1<IEventSubscribtion`1<TEventArgs>> myAddSubscribtion;
    private Action`1<IEventSubscribtion`1<TEventArgs>> myRemoveSubscribtion;
    public EventRef`1(Action`1<IEventSubscribtion`1<TEventArgs>> addSubscribtion, Action`1<IEventSubscribtion`1<TEventArgs>> removeSubscribtion);
    public sealed virtual void Subscribe(Lifetime lifetime, Action`1<TEventArgs> handler);
    public sealed virtual void Subscribe(Lifetime lifetime, Action`2<EventId, TEventArgs> handler);
    public sealed virtual void Subscribe(Lifetime lifetime, ExecutionMode mode, Action`1<TEventArgs> handler);
    public sealed virtual void Subscribe(Lifetime lifetime, ExecutionMode mode, Action`2<EventId, TEventArgs> handler);
    [CompilerGeneratedAttribute]
private void <Subscribe>b__6(EventSubscribtionImpl`1<TEventArgs> impl);
}
public class JetBrains.Util.EventBus.Impl.EventSubContextImpl`1 : object {
    private IEventContext myContext;
    private EventId`1<TEventArgs> myFinishEventId;
    private Func`1<TEventArgs> myFnishArgs;
    public EventSubContextImpl`1(IEventContext context, EventId`1<TEventArgs> finishEventId, Func`1<TEventArgs> fnishArgs);
    public sealed virtual void Dispose();
    public sealed virtual void Invoke(EventId`1<T> eventId, T args);
    public sealed virtual IEventContext InvokeStartFinish(EventId`1<TStartArgs> startEventId, EventId`1<TFinishArgs> finishEventId, TStartArgs args, Func`1<TFinishArgs> finishArgs);
}
public class JetBrains.Util.EventBus.Impl.EventSubscribtionImpl`1 : object {
    private Action`2<EventId, T> myAction;
    private ExecutionMode myExecutionMode;
    private Action`1<EventSubscribtionImpl`1<T>> myDisposed;
    public EventSubscribtionImpl`1(Action`2<EventId, T> action, ExecutionMode executionMode, Action`1<EventSubscribtionImpl`1<T>> disposed);
    [DebuggerStepThroughAttribute]
public sealed virtual void Invoke(EventId eventId, T eventArgs);
    public sealed virtual void Dispose();
    [DebuggerStepThroughAttribute]
private sealed virtual override void JetBrains.Util.EventBus.IEventSubscribtion.Invoke(EventId eventId, object eventArgs);
}
public interface JetBrains.Util.EventBus.ISubscribtionCookie {
}
public class JetBrains.Util.Events.EventDispatcher : object {
    private static Statistics Statistics;
    private Stack`1<Delegate> myDispatchingListeners;
    private List`1<Delegate> myListeners;
    private Dictionary`2<Delegate, bool> myListenersMap;
    private Object[] myLastArgs;
    private Delegate[] myListenersArray;
    private static EventDispatcher();
    public void AddListener(Delegate listener);
    public void RemoveListener(Delegate listener);
    private void UpdateListeners();
    public bool DispatchPendingEvents(Delegate listener);
    public void RaiseEvent(object sender, EventArgs args);
    private void Invoke(Delegate listener);
}
public static class JetBrains.Util.ExprHelper`1 : object {
    public static PropertyInfo PropertyInfoOf(Expression`1<Func`2<TEntity, TResult>> expr);
    public static MemberInfo InfoOf(Expression`1<Func`2<TEntity, TResult>> expr);
    public static string NameOf(Expression`1<Func`2<TEntity, TResult>> expr);
}
public static class JetBrains.Util.Extension.AppDomainEx : object {
    [NotNullAttribute]
public static AppDomain CreateTemporaryAppDomain(Lifetime lifetime, string nameDomain, AppDomainSetup adsetup, Evidence evidence);
    public static void ExecuteInTemporaryAppDomain(string nameDomain, CrossAppDomainDelegate F, AppDomainSetup adsetup, Evidence evidence);
    public static void WithTemporaryAppDomain(string nameDomain, Action`1<AppDomain> F, AppDomainSetup adsetup, Evidence evidence);
}
[ExtensionAttribute]
public static class JetBrains.Util.Extension.BinaryReaderWriterEx : object {
    [ExtensionAttribute]
public static void WriteNullableString(BinaryWriter writer, string s);
    [CanBeNullAttribute]
[ExtensionAttribute]
public static string ReadNullableString(BinaryReader reader);
    [ExtensionAttribute]
public static void WriteEnum(BinaryWriter writer, T enumValue);
    [ExtensionAttribute]
public static Nullable`1<T> ReadEnum(BinaryReader reader);
    [ExtensionAttribute]
public static T ReadEnum(BinaryReader reader, T defaultValue);
    [ExtensionAttribute]
public static TCollection ReadCollection(BinaryReader reader, Func`2<int, TCollection> createCollectionFunc, Func`2<BinaryReader, U> readFunc);
    [ExtensionAttribute]
public static IEnumerable`1<T> Read(BinaryReader reader, Func`2<BinaryReader, T> readFunc);
    [ExtensionAttribute]
public static void Write(BinaryWriter writer, ICollection`1<T> items, Action`2<BinaryWriter, T> writeAction);
    [ExtensionAttribute]
public static void Write(BinaryWriter writer, FrugalLocalList`1<T> items, Action`2<BinaryWriter, T> writeAction);
}
[ExtensionAttribute]
public static class JetBrains.Util.Extension.HttpWebRequestEx : object {
    [CompilerGeneratedAttribute]
private static Func`3<AsyncCallback, object, IAsyncResult> CS$<>9__CachedAnonymousMethodDelegate2;
    [CompilerGeneratedAttribute]
private static Func`2<IAsyncResult, HttpWebResponse> CS$<>9__CachedAnonymousMethodDelegate3;
    [NotNullAttribute]
[ExtensionAttribute]
public static Task`1<HttpWebResponse> GetHttpResponseAsync(HttpWebRequest request);
    [CompilerGeneratedAttribute]
private static IAsyncResult <GetHttpResponseAsync>b__0(AsyncCallback callback, object o);
    [CompilerGeneratedAttribute]
private static HttpWebResponse <GetHttpResponseAsync>b__1(IAsyncResult result);
}
[ExtensionAttribute]
public static class JetBrains.Util.Extension.JavaCompatibilityStringExtensions : object {
    [ExtensionAttribute]
public static string ToRegistryValue(string javaName);
    [ExtensionAttribute]
public static string FromRegistryValue(string windowsName);
}
[ExtensionAttribute]
public static class JetBrains.Util.Extension.StreamReaderEx : object {
    [NotNullAttribute]
[ExtensionAttribute]
public static IEnumerable`1<string> SelectManyLines(StreamReader ths);
}
[ExtensionAttribute]
public static class JetBrains.Util.Extension.StringExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
public static bool IsNullOrEmpty(string value);
    [PureAttribute]
[ExtensionAttribute]
public static String[] Split(string value, String[] separator);
    [ExtensionAttribute]
public static StringSlice Slice(string s, int start, int length);
    [ExtensionAttribute]
public static StringSlicesEnumerable Split(string source, char separator);
    [ExtensionAttribute]
public static StringSlicesEnumerable Split(string source, char separator, StringSplitOptions options);
    [ExtensionAttribute]
public static StringSlicesEnumerable Split(string source, Char[] separator);
    [ExtensionAttribute]
public static StringSlicesEnumerable Split(string source, Char[] separator, StringSplitOptions options);
    [PureAttribute]
[ExtensionAttribute]
public static bool Contains(string original, string value, StringComparison comparisonType);
    [ExtensionAttribute]
[PureAttribute]
public static string SubstringBefore(string original, string value);
    [ExtensionAttribute]
[PureAttribute]
public static string SubstringBefore(string original, string value, StringComparison comparisonType);
    [ExtensionAttribute]
[PureAttribute]
public static string SubstringBeforeLast(string original, string value);
    [PureAttribute]
[ExtensionAttribute]
public static string SubstringBeforeLast(string original, string value, StringComparison comparisonType);
    [ExtensionAttribute]
private static string SubstringBefore(string original, int index);
    [ExtensionAttribute]
[PureAttribute]
public static string SubstringAfter(string original, string value);
    [ExtensionAttribute]
[PureAttribute]
public static string SubstringAfter(string original, string value, StringComparison comparisonType);
    [ExtensionAttribute]
[PureAttribute]
public static string SubstringAfterLast(string original, string value);
    [ExtensionAttribute]
[PureAttribute]
public static string SubstringAfterLast(string original, string value, StringComparison comparisonType);
    [ExtensionAttribute]
private static string SubstringAfter(string original, int index, int length);
    [PureAttribute]
[ExtensionAttribute]
public static string RemoveStart(string original, string prefix);
    [PureAttribute]
[ExtensionAttribute]
public static string RemoveEnd(string original, string suffix);
    [PureAttribute]
[ExtensionAttribute]
public static string FormatWith(string formatString, Object[] args);
    [ExtensionAttribute]
[PureAttribute]
public static string ToBase64(string text);
    [PureAttribute]
[ExtensionAttribute]
public static string FromBase64(string text);
}
[ExtensionAttribute]
public static class JetBrains.Util.Extension.StringXorExtensions : object {
    private static string DefaultSecret;
    private static Byte[] XorBytes(Byte[] str, Byte[] secret);
    [ExtensionAttribute]
public static string XorEncode(string str, string secret);
    [ExtensionAttribute]
public static string XorDecode(string base64String, string secret);
}
public static class JetBrains.Util.ExternalProcess.ExternalProcess : object {
    private static string ProcessUpEventName;
    private static string AbortProcessEventName;
    public static EventWaitHandle CreateProcessUpEvent(string instanceName);
    public static EventWaitHandle CreateAbortUpEvent(string instanceName);
}
[ExtensionAttribute]
public static class JetBrains.Util.FEx : object {
    [ExtensionAttribute]
public static Func`1<TY> Beta(Func`2<TX, TY> func, TX value);
    [ExtensionAttribute]
public static Func`1<TY> Beta(Func`2<TX, TY> FToBeta, Func`1<TX> FGetValue);
    [ExtensionAttribute]
public static Func`2<TY, TResult> Beta(Func`3<TX, TY, TResult> func, TX value);
    [ExtensionAttribute]
public static Func`2<TX, TResult> Beta(Func`3<TX, TY, TResult> func, TY value);
    [ExtensionAttribute]
public static Func`2<TX, TResult> BetaX(Func`4<TX, TY, TZ, TResult> func, TY y, TZ z);
    [ExtensionAttribute]
public static Action`2<TY, TZ> BetaX(Action`3<TX, TY, TZ> func, TX x);
    [ExtensionAttribute]
public static Action`1<TY> BetaX(Action`2<TX, TY> func, TX x);
    [ExtensionAttribute]
public static Action`1<TZ> BetaXY(Action`3<TX, TY, TZ> func, TX x, TY y);
    [ExtensionAttribute]
public static Action`1<TY> BetaXZ(Action`3<TX, TY, TZ> func, TX x, TZ z);
    [ExtensionAttribute]
public static Func`2<TY, TResult> BetaY(Func`4<TX, TY, TZ, TResult> func, TX x, TZ z);
    [ExtensionAttribute]
public static Action`2<TX, TZ> BetaY(Action`3<TX, TY, TZ> func, TY y);
    [ExtensionAttribute]
public static Action`1<TX> BetaY(Action`2<TX, TY> func, TY y);
    [ExtensionAttribute]
public static Action`1<TX> BetaYZ(Action`3<TX, TY, TZ> func, TY y, TZ z);
    [ExtensionAttribute]
public static Func`2<TZ, TResult> BetaZ(Func`4<TX, TY, TZ, TResult> func, TX x, TY y);
    [ExtensionAttribute]
public static Action`2<TX, TY> BetaZ(Action`3<TX, TY, TZ> func, TZ z);
    public static T Return(Action`1<Func`2<Func`1<T>, Action>> FOuter);
}
public class JetBrains.Util.FilePersistence.SafeFileThrowAwayAccess : object {
    [NotNullAttribute]
private FileSystemPath myOwnerDirectory;
    [NotNullAttribute]
private FileSystemPath myFileName;
    public SafeFileThrowAwayAccess(FileSystemPath fileName);
    public void SaveStream(Action`1<Stream> write);
    public bool LoadStream(Action`1<Stream> read);
    public void Save(Action`1<BinaryWriter> write);
    public bool Load(Action`1<BinaryReader> read);
    private void SafeSafe(Action write);
    private bool SafeLoad(Action read);
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Util.FileSystemPathTrie`1 : QualifiedNamesTrie`1<T> {
    private bool myPreserveNames;
    public T Item { get; public set; }
    public FileSystemPathTrie`1(bool preserveNames);
    public T get_Item(FileSystemPath path);
    public void set_Item(FileSystemPath path, T value);
    private string GetPathValue(FileSystemPath fsp);
    [CanBeNullAttribute]
public T Find(FileSystemPath fsp);
    public ITrieNode<T> FindTrieNode(FileSystemPath fsp);
    public IList`1<T> GetChildrenData(FileSystemPath fsp);
    public IList`1<T> GetSubTreeData(FileSystemPath fsp);
    public void MoveSubtree(FileSystemPath oldPath, FileSystemPath newPath);
    public bool Remove(FileSystemPath fsp);
    public bool RemoveSubtree(FileSystemPath fsp);
    public void Add(FileSystemPath fsp, T o);
    public TrieEntry[] GetChildren(FileSystemPath fsp);
    public T FindLongestPrefix(FileSystemPath fsp);
}
public class JetBrains.Util.FilteringEnumerator`1 : object {
    private IEnumerator`1<T> myBaseEnumerator;
    private Predicate`1<T> myPredicate;
    private T myCurrent;
    private T System.Collections.Generic.IEnumerator<T>.Current { get; }
    public object Current { get; }
    public FilteringEnumerator`1(IEnumerator`1<T> baseEnumerator, Predicate`1<T> predicate);
    private sealed virtual override T System.Collections.Generic.IEnumerator<T>.get_Current();
    public sealed virtual void Dispose();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
    public sealed virtual object get_Current();
}
public class JetBrains.Util.FolderContentCache : object {
    public FileSystemPath FolderPath;
    private ConcurrentDictionary`2<FileSystemPath, Existence> myExistence;
    private ConcurrentDictionary`2<FileSystemPath, List`1<FileSystemPath>> myChildDirectories;
    [CompilerGeneratedAttribute]
private static Func`2<FileSystemPath, List`1<FileSystemPath>> CS$<>9__CachedAnonymousMethodDelegate1;
    [CompilerGeneratedAttribute]
private static Func`2<FileSystemPath, Existence> CS$<>9__CachedAnonymousMethodDelegate3;
    public FolderContentCache(FileSystemPath folderPath);
    public void Clear();
    public IList`1<FileSystemPath> GetChildDirectories(FileSystemPath folderPath);
    public Existence Exists(FileSystemPath path);
    public bool FileExists(FileSystemPath path);
    public bool DirectoryExists(FileSystemPath path);
    [CompilerGeneratedAttribute]
private static List`1<FileSystemPath> <GetChildDirectories>b__0(FileSystemPath p);
    [CompilerGeneratedAttribute]
private static Existence <Exists>b__2(FileSystemPath p);
}
public static class JetBrains.Util.Formats.AsmConfigFile : object {
    [NotNullAttribute]
public static XmlNamespaceManager CreateNamespaceManager(XmlDocument xmlDoc);
    public static void EnsureConfigFileElements(XmlDocument xmlDoc);
    [NotNullAttribute]
public static XmlElement GetAssemblyBindingVersionlessElement(XmlDocument xmlConfig);
}
public static class JetBrains.Util.Frameworks.FrameworkDetectionUtils : object {
    public static string MscorlibDllName;
    public static string MSBuildExeName;
    private static string WCFServiceModel;
    private static string Framework64;
    private static string Framework32;
    private static BackSlashSeparatedRelativePath ourRegistryPathNDP;
    private static BackSlashSeparatedRelativePath ourRegistryPathFramework;
    private static FrameworkDetectionUtils();
    public static FileSystemPath GetInstallRoot(KeyAccessRights keyAccessRights);
    private static UInt32 GetDwordValue(BackSlashSeparatedRelativePath path, string keyName, KeyAccessRights keyAccessRights);
    public static FileSystemPath GetPathToDotNetFrameworkV11();
    [CanBeNullAttribute]
public static FileSystemPath FindDotNetFrameworkPath(string prefix, string requiredFile);
    public static FileSystemPath GetPathToDotNetFrameworkV10();
    public static FileSystemPath GetPathToDotNetFrameworkV20();
    [CanBeNullAttribute]
public static Version ExtractExactVersion(string name);
    public static FileSystemPath GetPathToDotNetFrameworkV30();
    public static FileSystemPath GetPathToDotNetFrameworkV35();
    public static FileSystemPath GetPathToDotNetFrameworkV4X();
    private static FileSystemPath GetSecondaryPath(FileSystemPath path);
    public static FileSystemPath GetSecondaryPathToDotNetFrameworkV20();
    public static FileSystemPath GetSecondaryPathToDotNetFrameworkV30();
    public static FileSystemPath GetSecondaryPathToDotNetFrameworkV35();
    public static FileSystemPath GetSecondaryPathToDotNetFrameworkV4X();
}
internal class JetBrains.Util.Frameworks.FrameworkRegistryData : object {
    private static IList`1<FrameworkRegistryData> ourFrameworks;
    private static BackSlashSeparatedRelativePath ourRegistryPathNDP;
    private static Tuple`2[] ourAnchorVersionsOfdotNet4;
    [CompilerGeneratedAttribute]
private Version <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<UInt32> <Release>k__BackingField;
    [CompilerGeneratedAttribute]
private static Func`2<string, bool> CS$<>9__CachedAnonymousMethodDelegate4;
    public static IList`1<FrameworkRegistryData> Frameworks { get; }
    public Version Version { get; private set; }
    public Nullable`1<UInt32> Release { get; private set; }
    public FrameworkRegistryData(Version version, Nullable`1<UInt32> release);
    private static FrameworkRegistryData();
    public static IList`1<FrameworkRegistryData> get_Frameworks();
    [NotNullAttribute]
public static IEnumerable`1<FrameworkRegistryData> EnumerateInstalledNetFrameworksRegistryData(KeyAccessRights keyAccessRights);
    [CompilerGeneratedAttribute]
public Version get_Version();
    [CompilerGeneratedAttribute]
private void set_Version(Version value);
    [CompilerGeneratedAttribute]
public Nullable`1<UInt32> get_Release();
    [CompilerGeneratedAttribute]
private void set_Release(Nullable`1<UInt32> value);
    public sealed virtual bool Equals(FrameworkRegistryData other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [CanBeNullAttribute]
private static Version ExtractMajorMinorVersion(string name);
    [CanBeNullAttribute]
private static Version ExtractExactVersion(string name);
    public Version MarketingVersion();
    [CompilerGeneratedAttribute]
private static bool <EnumerateInstalledNetFrameworksRegistryData>b__1(string keyName);
    [CompilerGeneratedAttribute]
private bool <MarketingVersion>b__9(Tuple`2<int, Version> x);
}
public static class JetBrains.Util.GcUtil : object {
    private static int ourLohCollectionCount;
    public static int LohCollectionCount { get; }
    public static int get_LohCollectionCount();
    public static void UltraCollect();
}
public static class JetBrains.Util.GenericIComparableCache : object {
    private static MethodInfo ComparerHelperMethodGenericDefinition;
    private static Func`2<Type, Type[]> myFGetComparableSpecializations;
    private static Func`2<Type, CompareToDelegate> myFGetInvocation;
    [ThreadStaticAttribute]
private static IDictionary`2<Type, Type[]> myComparableSpecializations;
    [ThreadStaticAttribute]
private static IDictionary`2<Type, CompareToDelegate> myCompareInvocationsCache;
    [CompilerGeneratedAttribute]
private static Func`2<Type, Type[]> CS$<>9__CachedAnonymousMethodDelegate4;
    [CompilerGeneratedAttribute]
private static Func`2<Type, CompareToDelegate> CS$<>9__CachedAnonymousMethodDelegate5;
    [CompilerGeneratedAttribute]
private static Func`2<Type, bool> CS$<>9__CachedAnonymousMethodDelegate6;
    [CompilerGeneratedAttribute]
private static Func`2<Type, Type> CS$<>9__CachedAnonymousMethodDelegate7;
    private static GenericIComparableCache();
    public static Nullable`1<int> TryCompare(object , object );
    [NotNullAttribute]
private static ICollection`1<Type> GetComparableSpecializations(Type type);
    [NotNullAttribute]
private static CompareToDelegate GetInvocation(Type type);
    private static int InvokeCompareTo(object comparable, object other);
    [CompilerGeneratedAttribute]
private static Type[] <.cctor>b__0(Type type);
    [CompilerGeneratedAttribute]
private static CompareToDelegate <.cctor>b__3(Type type);
    [CompilerGeneratedAttribute]
private static bool <.cctor>b__1(Type t);
    [CompilerGeneratedAttribute]
private static Type <.cctor>b__2(Type t);
}
public class JetBrains.Util.Hash : ValueType {
    public static Hash ZERO;
    public static Hash INVALID;
    private int myValue;
    [CompilerGeneratedAttribute]
private static Func`2<string, Hash> CS$<>9__CachedAnonymousMethodDelegate1;
    public int Value { get; }
    public Hash(int value);
    private static Hash();
    public static Hash Create(string val);
    public int get_Value();
    public void PutByte(byte b);
    public void PutChar(char c);
    public void PutString(string s);
    public void PutStringFromStringBuilder(StringBuilder sb);
    public void PutInt(int i);
    public void PutBool(bool b);
    public void PutHash(Hash hash);
    public void Finish();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public virtual string ToString();
    public static Hash op_Addition(Hash hash1, Hash hash2);
    public static Hash op_Subtraction(Hash hash1, Hash hash2);
    public static Hash op_UnaryNegation(Hash hash);
    public static bool op_Equality(Hash hash1, Hash hash2);
    public static bool op_Inequality(Hash hash1, Hash hash2);
    public static Hash CommutativeMix(IEnumerable`1<string> values);
    public static Hash CommutativeMix(IEnumerable`1<Hash> values);
    [PureAttribute]
public void WriteTo(UnsafeWriter writer);
    public static Hash ReadFrom(UnsafeReader reader);
    public static void WriteArray(Hash[] hashes, BinaryWriter writer);
    public static Hash[] ReadArray(BinaryReader reader);
    [CompilerGeneratedAttribute]
private static Hash <CommutativeMix>b__0(string str);
}
public class JetBrains.Util.HashedPair`2 : ValueType {
    public T1 First;
    public T2 Second;
    private int myHashCode;
    [NotNullAttribute]
public static IEqualityComparer`1<HashedPair`2<T1, T2>> EqualityComparer;
    [NotNullAttribute]
public static IComparer`1<HashedPair`2<T1, T2>> Comparer;
    [DebuggerStepThroughAttribute]
public HashedPair`2(T1 first, T2 second);
    public HashedPair`2(T1 first, T2 second, Func`3<T1, T2, int> getHashCodeFunc);
    private static HashedPair`2();
    [DebuggerStepThroughAttribute]
[PureAttribute]
public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(HashedPair`2<T1, T2> other);
    public sealed virtual int CompareTo(HashedPair`2<T1, T2> other);
    [DebuggerStepThroughAttribute]
[PureAttribute]
public HashedPair`2<T2, T1> Reverse();
    public virtual string ToString();
}
public class JetBrains.Util.HashPair : ValueType {
    public Hash Old;
    public Hash New;
    public HashPair(Hash old, Hash new);
    public virtual string ToString();
}
public interface JetBrains.Util.ICppProcessWrapper {
    public UInt32 ProcessId { get; }
    public UInt32 ExitCode { get; }
    public Stream StdOut { get; }
    public Stream StdIn { get; }
    public abstract virtual UInt32 get_ProcessId();
    public abstract virtual UInt32 get_ExitCode();
    public abstract virtual Stream get_StdOut();
    public abstract virtual Stream get_StdIn();
    public abstract virtual void Wait();
}
public class JetBrains.Util.IdsMap`1 : object {
    private CompactMap`2<TItem, UInt32> myIdsMap;
    private CompactMap`2<UInt32, TItem> myItemsMap;
    private UInt32 myLastId;
    private int myIdBits;
    private BitsIncreasedHandler OnIdBitsIncreased;
    public int IdBits { get; }
    public int Count { get; }
    public IdsMap`1(UInt32 minId, int expectedFilesCount);
    public void add_OnIdBitsIncreased(BitsIncreasedHandler value);
    public void remove_OnIdBitsIncreased(BitsIncreasedHandler value);
    public int get_IdBits();
    public int get_Count();
    public TItem GetItemById(UInt32 id);
    public UInt32 GetIdByItem(TItem item);
    public bool HasId(TItem item);
}
[DefaultMemberAttribute("Item")]
public interface JetBrains.Util.IEquatableList`1 {
    public TItem Item { get; }
    public int Count { get; }
    public abstract virtual TItem get_Item(int index);
    public abstract virtual int get_Count();
}
[AttributeUsageAttribute("396")]
public class JetBrains.Util.ImmutableAttribute : Attribute {
}
[ExtensionAttribute]
public static class JetBrains.Util.IndentedTextWriterEx : object {
    [ExtensionAttribute]
public static IDisposable Indent(IndentedTextWriter indentedTextWriter);
}
public class JetBrains.Util.IndexComparer`1 : object {
    private IList`1<T> myList;
    public IndexComparer`1(IList`1<T> list);
    public IndexComparer`1(T[] array);
    public sealed virtual int Compare(T x, T y);
}
public static class JetBrains.Util.InputLanguageUtil : object {
    [CompilerGeneratedAttribute]
private static Func`2<InputLanguage, bool> CS$<>9__CachedAnonymousMethodDelegate2;
    [CanBeNullAttribute]
public static InputLanguage TrySetEnglishInputLanguage(ILogger logger);
    public static void WithEnglishInputLanguage(Action action, ILogger logger);
    public static void LogInputLanguages(ILogger logger);
    [NotNullAttribute]
private static string LanguageToString(InputLanguage lang);
    [CompilerGeneratedAttribute]
private static bool <TrySetEnglishInputLanguage>b__0(InputLanguage lang);
}
[ExtensionAttribute]
public static class JetBrains.Util.Int32Util : object {
    [ExtensionAttribute]
[NotNullAttribute]
public static T[] Times(int count, Func`2<int, T> generator);
}
public class JetBrains.Util.InternalErrorException : ApplicationException {
    private string myClassName;
    public InternalErrorException(string details);
    public InternalErrorException(string format, Object[] args);
    protected InternalErrorException(SerializationInfo info, StreamingContext context);
    public virtual string ToString();
    private string GetClassName();
}
public static class JetBrains.Util.Interop.ClrHelpers : object {
    private static string ProfileOptimizationDirName;
    private static string ProfileOptimizationScenario;
    private static ClrHelpers();
    public static void EnableMultithreadedJit();
}
public static class JetBrains.Util.Interop.Com : object {
    public static TInterface QueryInteface(object comobj);
    public static TInterface QueryInteface(Void* punk);
    [NotNullAttribute]
public static Void* UnknownAddRef(object comobj);
    public static void UnknownRelease(Void* punk);
    public static ReleaseToken UsingReference(Void** punk);
}
[ValueSerializerAttribute("JetBrains.Util.Interop.DpiResolution/DpiResolutionSerializer")]
public class JetBrains.Util.Interop.DpiResolution : ValueType {
    private double myDpiX;
    private double myDpiY;
    public static DpiResolution DeviceIndependent96Dpi;
    public static DpiResolution NotSure;
    public static int DeviceIndependent96DpiValue;
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("With dynamic per-monitor DPI, this value has no meaning anymore. Call DpiResolutions::From* to get a specific screen resolution.")]
public static DpiResolution CurrentScreenDpi { get; }
    public double DpiX { get; }
    public double DpiY { get; }
    public DpiResolution(double dpiX, double dpiY);
    private static DpiResolution();
    public static DpiResolution get_CurrentScreenDpi();
    public double get_DpiX();
    public double get_DpiY();
    public static bool op_Equality(DpiResolution left, DpiResolution right);
    public static bool op_Inequality(DpiResolution left, DpiResolution right);
    public static DpiResolution op_Addition(DpiResolution black, DpiResolution white);
    public static DpiResolution op_Subtraction(DpiResolution black, DpiResolution white);
    public static DpiResolution op_Multiply(DpiResolution dpi, double factor);
    public static DpiResolution op_Division(DpiResolution dpi, double factor);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public sealed virtual bool Equals(DpiResolution other);
}
[ObsoleteAttribute("Use DpiUtil from Shell.")]
[ExtensionAttribute]
public static class JetBrains.Util.Interop.DpiUtil : object {
    private static Nullable`1<DpiResolution> ourDpi;
    [ObsoleteAttribute("Either use boot-time or per-monitor DPI explicitly.")]
public static double DpiHorizontalFactor { get; }
    [ObsoleteAttribute("Either use boot-time or per-monitor DPI explicitly.")]
public static double DpiVerticalFactor { get; }
    [ObsoleteAttribute("Either use boot-time or per-monitor DPI explicitly.")]
public static DpiResolution ScreenDpi { get; }
    [ObsoleteAttribute("Does not represent per-monitor factor. Does not treat correctly anisotropic DPI.")]
public static double DpiFactor { get; }
    public static double get_DpiHorizontalFactor();
    public static double get_DpiVerticalFactor();
    public static DpiResolution get_ScreenDpi();
    public static double get_DpiFactor();
    private static DpiResolution GetBootTimeScreenDpi();
    [ExtensionAttribute]
[ObsoleteAttribute("Use ToWindowsFormsSize.")]
public static Size ScaleToScreenDpi(Size this);
    [ObsoleteAttribute("Use ToWindowsFormsSize.")]
[ExtensionAttribute]
public static Padding ScaleToScreenDpi(Padding this);
}
public class JetBrains.Util.Interop.ErrorLevelException : ApplicationException {
    private UInt32 myErrorlevel;
    public HResults ErrorlevelHresult { get; }
    public int ErrorlevelInt { get; }
    public UInt32 ErrorlevelUint { get; }
    public bool IsComFailed { get; }
    public bool IsComSucceeded { get; }
    public bool IsNonZero { get; }
    public bool IsZero { get; }
    public ErrorLevelException(int errorlevel);
    public ErrorLevelException(UInt32 errorlevel);
    public ErrorLevelException(HResults errorlevel);
    protected ErrorLevelException(SerializationInfo info, StreamingContext context);
    public HResults get_ErrorlevelHresult();
    public int get_ErrorlevelInt();
    public UInt32 get_ErrorlevelUint();
    public bool get_IsComFailed();
    public bool get_IsComSucceeded();
    public bool get_IsNonZero();
    public bool get_IsZero();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public static void ThrowIfComFailed(int errorlevel);
    public static void ThrowIfComFailed(UInt32 errorlevel);
    public static void ThrowIfComFailed(HResults errorlevel);
    public static void ThrowIfNonZero(int errorlevel);
    public static void ThrowIfNonZero(UInt32 errorlevel);
    public static void ThrowIfNonZero(HResults errorlevel);
}
public class JetBrains.Util.Interop.FixedBuffer : object {
    private bool bInFinalizationQueue;
    private IntPtr myBufferAddress;
    private int myBufferLength;
    private string myOriginatingStackTrace;
    public IntPtr Address { get; }
    public bool IsAllocated { get; }
    public int Length { get; }
    public FixedBuffer(int nLengthToAllocateInBytes);
    public IntPtr get_Address();
    public bool get_IsAllocated();
    public int get_Length();
    public void Allocate(int nLengthInBytes);
    public sealed virtual void Dispose();
}
internal interface JetBrains.Util.Interop.IDllLoader {
    public abstract virtual IntPtr LoadLibrary(FileSystemPath absoluteDllPath);
    public abstract virtual void FreeLibrary(IntPtr handle);
    public abstract virtual IntPtr GetProcAddress(IntPtr handle, string methodName);
    public abstract virtual bool IsLoaded(FileSystemPath absoluteDllPath);
}
public static class JetBrains.Util.Interop.ImportAddressTableHook : object {
    private static int IterationLimit;
    private static List`1<Delegate> myDelegateReferences;
    private static ImportAddressTableHook();
    public static void Install(string sFuncMod, string sFuncName, Void* hCallingMod, Delegate pNewFunction);
    public static void Install(string sFuncMod, string sFuncName, string sCallingMod, Delegate pNewFunction);
    public static void InstallCore(string sFuncMod, string sFuncName, Void* hCallingMod, string sCallingMod, Delegate pNewFunction);
    private static void AssertNoWin32Error();
    private static void DelegateAddRef(Delegate function);
}
public class JetBrains.Util.Interop.JavaPropertiesFile : Dictionary`2<string, string> {
    public void Load(Stream stream);
    public void Load(TextReader reader);
    private void Load0(LineReader lineReader);
    private string loadConvert(Char[] array, int i, int num, Char[] array2);
}
[ExtensionAttribute]
public static class JetBrains.Util.Interop.LpwstrHelper : object {
    [ThreadStaticAttribute]
private static UInt16[] _buffer;
    [ExtensionAttribute]
[NotNullAttribute]
public static string GetString(GetLpcwstrDelegate2 func, string faultmsg);
    [NotNullAttribute]
public static string GetString(GetLpcwstrDelegate func, string faultmsg);
}
public class JetBrains.Util.Interop.NativeDll : object {
    [NotNullAttribute]
internal Void* Handle;
    [NotNullAttribute]
internal NativeDllKey Key;
    [NotNullAttribute]
private IDllLoader DllLoader;
    [NotNullAttribute]
internal FileSystemPath File;
    private Dictionary`2<string, Delegate> myMethods;
    internal NativeDll(Void* handle, NativeDllKey key, FileSystemPath file, IDllLoader dllLoader);
    [NotNullAttribute]
public TDelegate ImportMethod(string methodName);
    [NotNullAttribute]
public ComObject CreateComObject(Guid guidClsid);
    [NotNullAttribute]
public ComObject CreateComObject();
}
internal class JetBrains.Util.Interop.NativeDllKey : object {
    public bool Debug;
    [NotNullAttribute]
public IPath Path;
    public NativeDllKey(IPath path, bool debug);
    public sealed virtual bool Equals(NativeDllKey other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public static class JetBrains.Util.Interop.NativeDllsLoader : object {
    private static FileSystemPath ourDllDirectory;
    private static FileSystemPath ourDebugDllDirectory;
    private static Dictionary`2<NativeDllKey, NativeDll> ourLoadedDlls;
    private static IDllLoader ourDllLoader;
    private static string WindowsDynamicLibrarySuffix;
    private static string LinuxDynamicLibrarySuffix;
    private static string MacOsDynamicLibrarySuffix;
    private static List`1<string> DynamicLibrariesSuffixes;
    private static NativeDllsLoader();
    [NotNullAttribute]
public static NativeDll LoadDll(Lifetime lifetime, RelativePath relativePathWithoutSuffix, Options options);
    private static NativeDll LoadDllCore(Lifetime lifetime, NativeDllKey key, IPath pathForDiagnostics, FileSystemPath file);
    [NotNullAttribute]
public static NativeDll LoadDllExact(Lifetime lifetime, FileSystemPath pathExact);
    private static RelativePath StripExistingDynamicLibrarySuffix(RelativePath relativePath);
    private static RelativePath AddDynamicLibrarySuffix(RelativePath relativePath);
    private static string GetSuffix();
    [NotNullAttribute]
private static FileSystemPath GetDllDirectory(ProcessorArchitecture architecture, bool debug);
}
public static class JetBrains.Util.Interop.OsVersionUtil : object {
    public static Windows GetWindowsVersion();
}
[ExtensionAttribute]
public static class JetBrains.Util.Interop.ProcessorArchitectureEx : object {
    [ExtensionAttribute]
public static string ToPresentableString(ProcessorArchitecture processorArchitecture);
}
public static class JetBrains.Util.Interop.ProcessorUtil : object {
    public static ProcessorArchitecture Architecture;
    public static ProcessorArchitecture NativeArchitecture;
    private static ProcessorUtil();
}
[ExtensionAttribute]
public static class JetBrains.Util.Interop.RegistryEx : object {
    private static KeyAccessRights KEY_32;
    private static KeyAccessRights KEY_64;
    [CompilerGeneratedAttribute]
private static Func`2<Type, bool> CS$<>9__CachedAnonymousMethodDelegate10;
    private static RegistryEx();
    [ExtensionAttribute]
public static RegistryHiveAccess InCertainty(RegistryKey keyBase, KeyAccessRights keyArchitectureFlag);
    [ExtensionAttribute]
public static RegistryHiveAccess InProcessSpecific(RegistryKey keyBase);
    [ExtensionAttribute]
public static RegistryHiveAccess InSystemNative(RegistryKey keyBase);
    [ExtensionAttribute]
public static RegistryHiveAccess InWin32(RegistryKey keyBase);
    public static Nullable`1<RegistryHiveAccess> LoadAppHive(Lifetime lifetime, FileSystemPath file, ILogger logger, LoadExclusiveness exclusiveness);
    public static Nullable`1<RegistryHiveAccess> LoadOrReuseAppHive(Lifetime lifetime, FileSystemPath file, ILogger logger);
    private static Void* LoadOrReuseAppHiveCore(Lifetime lifetime, FileSystemPath file, ILogger logger);
    private static Void* LoadAppHiveCore(Lifetime lifetime, FileSystemPath file, ILogger logger, LoadExclusiveness exclusiveness, int nAttempts);
    [NotNullAttribute]
private static Type FindShtType();
    [NotNullAttribute]
private static object CreateSrhInst(Type srhType, IntPtr hKey);
    [NotNullAttribute]
private static string GetHiveName(Void* hkeyRoot);
    private static Void* GetRootHKey(RegistryKey keyBase, bool isCustomRootKey, OnError onerror);
    private static T WithOpenHKey(RegistryKey keyBase, bool isCustomRootKey, BackSlashSeparatedRelativePath subkey, KeyAccessRights accessRights, bool notFoundAsError, OnError onerror, Func`3<IntPtr, string, T> action);
    private static T WithCreateHKey(RegistryKey keyBase, bool isCustomRootKey, BackSlashSeparatedRelativePath subkey, KeyAccessRights accessRights, OnError onerror, Func`3<IntPtr, string, T> action);
    [CompilerGeneratedAttribute]
private static bool <FindShtType>b__f(Type x);
}
public static class JetBrains.Util.Interop.ShellLinkHelper : object {
    [NotNullAttribute]
public static string ExtensionNoDot;
    [NotNullAttribute]
public static string ExtensionWithDot;
    private static ShellLinkHelper();
    public static void CreateLink(FileSystemPath pathLnkFile, FileSystemPath pathLinkTarget);
    [NotNullAttribute]
public static IShellLinkW CreateShellLinkComObject();
    [NotNullAttribute]
public static FileSystemPath ResolveLinkTarget(FileSystemPath pathLnk);
}
internal class JetBrains.Util.Interop.UnixDllLoader : object {
    private static int RTLD_NOW;
    private static int RTLD_NOLOAD;
    public sealed virtual IntPtr LoadLibrary(FileSystemPath absoluteDllPath);
    public sealed virtual void FreeLibrary(IntPtr handle);
    public sealed virtual IntPtr GetProcAddress(IntPtr handle, string methodName);
    public sealed virtual bool IsLoaded(FileSystemPath absoluteDllPath);
    private static void ThrowError(string message);
    private static void ResetLastError();
    private static IntPtr dlopen(string fileName, int flags);
    private static IntPtr dlsym(IntPtr handle, string symbol);
    private static int dlclose(IntPtr handle);
    private static IntPtr dlerror();
}
internal class JetBrains.Util.Interop.WindowsDllLoader : object {
    public sealed virtual IntPtr LoadLibrary(FileSystemPath absoluteDllPath);
    public sealed virtual void FreeLibrary(IntPtr handle);
    public sealed virtual IntPtr GetProcAddress(IntPtr handle, string methodName);
    public sealed virtual bool IsLoaded(FileSystemPath absoluteDllPath);
}
public static class JetBrains.Util.InvokeChildProcess : object {
    private static Regex RegexOriginCategoryCodeTextExpression;
    public static TimeSpan TimeoutChildProcess;
    [CompilerGeneratedAttribute]
private static Func`2<KeyValuePair`2<string, string>, string> CS$<>9__CachedAnonymousMethodDelegatee;
    [CompilerGeneratedAttribute]
private static Func`2<KeyValuePair`2<string, string>, string> CS$<>9__CachedAnonymousMethodDelegate25;
    [CompilerGeneratedAttribute]
private static Func`2<KeyValuePair`2<string, string>, string> CS$<>9__CachedAnonymousMethodDelegate26;
    [CompilerGeneratedAttribute]
private static Comparison`1<ProcessIdHandleName> CS$<>9__CachedAnonymousMethodDelegate45;
    private static InvokeChildProcess();
    public static UInt32 InvokeChildProcessIntoLogger(FileSystemPath target, CommandLineBuilderJet cmdline, LoggingLevel levelDefault, Nullable`1<TimeSpan> timeout, TreatStderr treatStderr, FileSystemPath dirCurrent, IDictionary`2<string, string> environmentVariables, Nullable`1<ProcessPriorityClass> priorityClass);
    public static UInt32 InvokeChildProcessIntoStdout(FileSystemPath target, CommandLineBuilderJet cmdline, Nullable`1<TimeSpan> timeout, TreatStderr treatStderr, FileSystemPath dirCurrent, IDictionary`2<string, string> environmentVariables, Nullable`1<ProcessPriorityClass> priorityClass);
    public static Task`1<UInt32> InvokeCore(OuterLifetime lifetime, StartInfo startinfo, SyncAsync syncasync, ILogger logger);
    public static UInt32 InvokeSync(FileSystemPath target, CommandLineBuilderJet cmdline, PipeStreams pipe, Nullable`1<TimeSpan> timeout, FileSystemPath dirCurrent, IDictionary`2<string, string> environmentVariables, Nullable`1<ProcessPriorityClass> priorityClass, ILogger logger);
    public static Task`1<UInt32> InvokeCore_Managed(OuterLifetime lifeOuter, StartInfo startinfo, SyncAsync syncasync, ILogger logger);
    public static Task`1<UInt32> InvokeCore_Native(OuterLifetime lifeOuter, StartInfo startinfo, SyncAsync syncasync, ILogger logger);
    private static void InvokeCore_Native_JobObject(Lifetime lifetime, PROCESS_INFORMATION* pProcessInfo, ILogger logger);
    [NotNullAttribute]
private static IList`1<ProcessIdHandleName> InvokeCore_Native_JobObject_ListProcesses(Lifetime lifeTerminating, Void* hJob, ILogger logger);
    private static void InvokeCore_Native_PumpStream(Lifetime lifeCp, Void* hFile, PipeStreams pipestreams, bool isErrNotOut, ILogger logger);
    [CompilerGeneratedAttribute]
private static string <InvokeCore_Managed>b__2(KeyValuePair`2<string, string> x);
    [CompilerGeneratedAttribute]
private static string <InvokeCore_Native>b__1c(KeyValuePair`2<string, string> x);
    [CompilerGeneratedAttribute]
private static string <InvokeCore_Native>b__1d(KeyValuePair`2<string, string> x);
    [CompilerGeneratedAttribute]
private static int <InvokeCore_Native_JobObject_ListProcesses>b__44(ProcessIdHandleName black, ProcessIdHandleName white);
}
public static class JetBrains.Util.IOUtil : object {
    private static String[] RESERVED_DOS_NAMES;
    private static IOUtil();
    public static bool IsValidPath(string path);
}
public interface JetBrains.Util.IPairEnumerator`2 {
    public TKey CurrentKey { get; }
    public TValue CurrentValue { get; }
    public abstract virtual TKey get_CurrentKey();
    public abstract virtual TValue get_CurrentValue();
}
public interface JetBrains.Util.IPresentableStructureElement {
    public object PresentationObject { get; }
    public abstract virtual object get_PresentationObject();
}
public enum JetBrains.Util.IsDisposedState : Enum {
    public int value__;
    public static IsDisposedState Live;
    public static IsDisposedState Disposing;
    public static IsDisposedState Disposed;
}
public interface JetBrains.Util.ITransactionCookie {
    public abstract virtual void AddUndoRedoHandler(IUndoRedoHandler handler);
    public abstract virtual TransactionCommitResult Commit(IProgressIndicator pi);
    public abstract virtual void Rollback();
}
public interface JetBrains.Util.IUndoRedoHandler {
    public abstract virtual void Do();
    public abstract virtual void Undo();
    public abstract virtual void Redo();
}
public interface JetBrains.Util.IWorkingDirectory {
    public FileSystemPath Path { get; }
    public abstract virtual FileSystemPath get_Path();
}
public static class JetBrains.Util.JetPredicate`1 : object {
    [NotNullAttribute]
public static Predicate`1<T> True;
    [NotNullAttribute]
public static Predicate`1<T> False;
    [CompilerGeneratedAttribute]
private static Predicate`1<T> CS$<>9__CachedAnonymousMethodDelegate2;
    [CompilerGeneratedAttribute]
private static Predicate`1<T> CS$<>9__CachedAnonymousMethodDelegate3;
    private static JetPredicate`1();
    [CompilerGeneratedAttribute]
private static bool <.cctor>b__0(T t);
    [CompilerGeneratedAttribute]
private static bool <.cctor>b__1(T t);
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Util.JetReadOnlyList`1 : object {
    private IList`1<T> myList;
    public int Count { get; }
    public T Item { get; public set; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    public JetReadOnlyList`1(IList`1<T> list);
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual int get_Count();
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    public sealed virtual int IndexOf(T item);
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.Remove(T item);
    private sealed virtual override void System.Collections.Generic.IList<T>.Insert(int index, T item);
    private sealed virtual override void System.Collections.Generic.IList<T>.RemoveAt(int index);
}
[ValueSerializerAttribute("JetBrains.Util.JetSemanticVersion/JetSemanticVersionSerializer")]
[TypeConverterAttribute("JetBrains.Util.JetSemanticVersion/JetSemanticVersionConverter")]
public class JetBrains.Util.JetSemanticVersion : object {
    public static JetSemanticVersion Empty;
    private static Regex ourSemanticVersionRegex;
    private static Regex ourRegexPrereleaseMetadata;
    private static Regex ourRegexBuildMetadata;
    [CanBeNullAttribute]
private string myOriginalString;
    [NotNullAttribute]
private Version myVersion;
    [CompilerGeneratedAttribute]
private string <PrereleaseMetadata>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BuildMetadata>k__BackingField;
    public bool IsVersionNumberOnly { get; }
    public int Major { get; }
    public int Minor { get; }
    public int Patch { get; }
    public int LegacyRevision { get; }
    public string PrereleaseMetadata { get; private set; }
    public string BuildMetadata { get; private set; }
    private JetSemanticVersion(string originalString, Version version, string prerelease, string build);
    public JetSemanticVersion(UInt32 major, UInt32 minor, UInt32 build, UInt32 revision, string prereleasemeta, string buildmeta);
    public JetSemanticVersion(int major, int minor, int build, int revision, string prereleasemeta, string buildmeta);
    public JetSemanticVersion(Version version, string prerelease, string build);
    private static JetSemanticVersion();
    public static bool TryParse(string versionString, JetSemanticVersion& semanticVersion);
    [NotNullAttribute]
public static JetSemanticVersion Parse(string versionString);
    [ContractAnnotationAttribute("version:null => null; notnull => notnull")]
public static JetSemanticVersion FromVersion4(Version version);
    public Version ToVersion4Lossy();
    public Version2 ToVersion2Lossy();
    public Version ToVersion4Exact();
    public bool get_IsVersionNumberOnly();
    public int get_Major();
    public int get_Minor();
    public int get_Patch();
    public int get_LegacyRevision();
    [CompilerGeneratedAttribute]
public string get_PrereleaseMetadata();
    [CompilerGeneratedAttribute]
private void set_PrereleaseMetadata(string value);
    [CompilerGeneratedAttribute]
public string get_BuildMetadata();
    [CompilerGeneratedAttribute]
private void set_BuildMetadata(string value);
    public sealed virtual int CompareTo(object other);
    public sealed virtual int CompareTo(JetSemanticVersion other);
    private static int ComparePrereleaseMetadata(string prereleaseMetadata, string otherPrereleaseMetadata);
    private static int CompareIdentifier(string identifier, string otherIdentifier);
    public sealed virtual bool Equals(JetSemanticVersion other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static bool op_Equality(JetSemanticVersion version1, JetSemanticVersion version2);
    public static bool op_Inequality(JetSemanticVersion version1, JetSemanticVersion version2);
    public static bool op_LessThan(JetSemanticVersion version1, JetSemanticVersion version2);
    public static bool op_GreaterThan(JetSemanticVersion version1, JetSemanticVersion version2);
    public static bool op_LessThanOrEqual(JetSemanticVersion version1, JetSemanticVersion version2);
    public static bool op_GreaterThanOrEqual(JetSemanticVersion version1, JetSemanticVersion version2);
    [ContractAnnotationAttribute("value:null => null; notnull => notnull")]
public static string op_Explicit(JetSemanticVersion value);
    [ContractAnnotationAttribute("value:null => null; notnull => notnull")]
public static JetSemanticVersion op_Explicit(string value);
    [ContractAnnotationAttribute("value:null => null; notnull => notnull")]
public static JetSemanticVersion op_Explicit(Version value);
}
[ExtensionAttribute]
public static class JetBrains.Util.ListUtil : object {
    public static List`1<T> SubtractSortedInplace(List`1<T> minuend, List`1<T> subtrahend);
    public static string ToSortedString(ICollection`1<T> list);
    public static string ToString(ICollection`1<T> list);
    [ExtensionAttribute]
public static TValue ValueOrDefault(IDictionary`2<TKey, TValue> dictionary, TKey key);
    [ExtensionAttribute]
public static void Insert(IList`1<TItem> ths, Lifetime lifetime, int index, TItem item);
    [ExtensionAttribute]
public static void Insert(IList ths, Lifetime lifetime, int index, object item);
    [ExtensionAttribute]
public static void Move(IList ths, int oldIndex, int newIndex, int count);
}
public class JetBrains.Util.LocalUserDataHolder : ValueType {
    [CanBeNullAttribute]
private UserDataHolder myHolder;
    public sealed virtual void PutData(Key`1<T> key, T value);
    public sealed virtual T GetData(Key`1<T> key);
    public sealed virtual T GetOrCreateDataUnderLock(Key`1<T> key, Func`1<T> factory);
    public sealed virtual T GetOrCreateDataUnderLock(Key`1<T> key, TState state, Func`2<TState, T> factory);
    public sealed virtual IEnumerable`1<KeyValuePair`2<object, object>> EnumerateData();
}
public static class JetBrains.Util.LogUtil : object {
    [NotNullAttribute]
private static string GetUserFriendlyShortName(object obj);
    [NotNullAttribute]
public static string GetUserFriendlyWinFormsShortName(Control control);
}
public enum JetBrains.Util.MbButton : Enum {
    public UInt32 value__;
    public static MbButton MB_OK;
    public static MbButton MB_OKCANCEL;
    public static MbButton MB_ABORTRETRYIGNORE;
    public static MbButton MB_YESNOCANCEL;
    public static MbButton MB_YESNO;
    public static MbButton MB_RETRYCANCEL;
    public static MbButton MB_CANCELTRYCONTINUE;
}
public enum JetBrains.Util.MbIcon : Enum {
    public UInt32 value__;
    public static MbIcon MB_ICONHAND;
    public static MbIcon MB_ICONQUESTION;
    public static MbIcon MB_ICONEXCLAMATION;
    public static MbIcon MB_ICONASTERISK;
}
public interface JetBrains.Util.Memory.IMemoryGrave {
    public int SurvivorsCount { get; }
    public abstract virtual void AddObject(object obj);
    public abstract virtual int get_SurvivorsCount();
}
public interface JetBrains.Util.Memory.IMemoryGraveProvider {
    [NotNullAttribute]
public abstract virtual IMemoryGrave GetOrCreateMemoryGrave();
}
public static class JetBrains.Util.Memory.LeakWatchdog : object {
    private static IDictionaryEvents`2<Lifetime, Grave> ourLifetimesToGraves;
    private static ICollectionEvents`1<Grave> ourWaitingGraves;
    private static ICollectionEvents`1<Grave> ourSurvivedGraves;
    private static TimeSpan ourTimerInterval;
    private static TimeSpan ourGcInterval;
    [CanBeNullAttribute]
private static Timer ourTimer;
    [CanBeNullAttribute]
private static object ourTimerCookie;
    private static bool ourIsShutdown;
    private static int ourIsCallbackExecuted;
    private static int ourLastGcCount;
    private static DateTime ourLastGcDateTime;
    private static ILogger ourLogger;
    [CompilerGeneratedAttribute]
private static Action`1<AddRemoveEventArgs`1<KeyValuePair`2<Lifetime, Grave>>> CS$<>9__CachedAnonymousMethodDelegate7;
    [CompilerGeneratedAttribute]
private static Action`1<AddRemoveEventArgs`1<KeyValuePair`2<Lifetime, Grave>>> CS$<>9__CachedAnonymousMethodDelegate8;
    [CompilerGeneratedAttribute]
private static Action`1<AddRemoveEventArgs`1<Grave>> CS$<>9__CachedAnonymousMethodDelegate9;
    [CompilerGeneratedAttribute]
private static Action`1<Lifetime> CS$<>9__CachedAnonymousMethodDelegatea;
    [CompilerGeneratedAttribute]
private static Action CS$<>9__CachedAnonymousMethodDelegated;
    [CompilerGeneratedAttribute]
private static Action CS$<>9__CachedAnonymousMethodDelegatee;
    [CompilerGeneratedAttribute]
private static Comparison`1<Grave> CS$<>9__CachedAnonymousMethodDelegate17;
    private static LeakWatchdog();
    [NotNullAttribute]
public static IMemoryGrave GetOrCreateGrave(Lifetime lifetime, string graveName);
    public static void RegisterObject(Lifetime lifetime, object obj, string graveName);
    public static void RegisterTerminatedObject(object obj, TimeSpan timeout, Mode mode, Action`1<int> onFinish);
    public static ICollection`1<IMemoryGrave> GeSurvivedGraves();
    public static void ClearSurvivedGraves();
    public static void DumpSurvivors(StringBuilder sb);
    public static void ShutDown();
    [HandleProcessCorruptedStateExceptionsAttribute]
private static void OurTimerCallback(object cookie);
    private static bool SweepWaitingGraves();
    private static void SweepSurvivedGraves();
    private static void LogGrave(Grave grave, string text);
    private static int GetCurrentGcCount();
    private static void ForceGc();
    [CompilerGeneratedAttribute]
private static void <.cctor>b__0(AddRemoveEventArgs`1<KeyValuePair`2<Lifetime, Grave>> args);
    [CompilerGeneratedAttribute]
private static void <.cctor>b__2(AddRemoveEventArgs`1<KeyValuePair`2<Lifetime, Grave>> args);
    [CompilerGeneratedAttribute]
private static void <.cctor>b__3(AddRemoveEventArgs`1<Grave> args);
    [CompilerGeneratedAttribute]
private static void <.cctor>b__4(Lifetime timerLifetime);
    [CompilerGeneratedAttribute]
private static void <.cctor>b__5();
    [CompilerGeneratedAttribute]
private static void <.cctor>b__6();
    [CompilerGeneratedAttribute]
private static int <DumpSurvivors>b__16(Grave x, Grave y);
}
public static class JetBrains.Util.MessageBox : object {
    public static DialogBoxCommandId ShowCore(Void* window, string text, string caption, MessageBoxFlags flags);
    public static void ShowError(string text, string caption);
    public static void ShowError(string text, string caption, IntPtr window);
    public static void ShowExclamation(string text, string caption);
    public static void ShowExclamation(string text, string caption, IntPtr window);
    public static void ShowInfo(string text, string caption);
    public static void ShowInfo(string text, string caption, IntPtr window);
    public static DialogBoxCommandId ShowMessageBox(string text, string caption, IntPtr window, MbButton button, MbIcon icon);
    public static DialogBoxCommandId ShowMessageBox(string text, string caption, MbButton button, MbIcon icon);
    public static DialogBoxCommandId ShowMessageBox(string text, MbButton button, MbIcon icon);
    public static bool ShowOKCancel(string text, string caption);
    public static bool ShowOKCancel(string text, string caption, IntPtr window);
    public static bool ShowOKCancel(string text, string caption, IntPtr window, bool defaultButton);
    public static bool ShowYesNo(string text, string caption);
    public static bool ShowYesNo(string text, string caption, IntPtr window);
    public static bool ShowYesNo(string text, string caption, IntPtr window, bool defaultButton);
    public static Nullable`1<bool> ShowYesNoCancel(string text, string caption);
    public static Nullable`1<bool> ShowYesNoCancel(string text, string caption, IntPtr window);
    public static Nullable`1<bool> ShowYesNoCancel(string text, string caption, IntPtr window, Nullable`1<bool> defaultButton);
}
public static class JetBrains.Util.MessageBoxHandlers : object {
    public static ListEvents`1<MessageBoxHandlerDelegate> MessageBoxHandlersStack;
    private static MessageBoxHandlers();
    [NotNullAttribute]
public static MessageBoxHandlerDelegate GetHandlerSilent(ILogger logger);
    [NotNullAttribute]
public static MessageBoxHandlerDelegate GetHandlerWinNT();
}
public class JetBrains.Util.ModificationCookie : object {
    private EnsureWritableResult myEnsureWritableResult;
    private string myMessage;
    private bool myIsDisposed;
    private EventHandler ModificationFinished;
    public EnsureWritableResult EnsureWritableResult { get; }
    public string Message { get; }
    public ModificationCookie(EnsureWritableResult ensureWritableResult);
    public ModificationCookie(EnsureWritableResult ensureWritableResult, string message);
    public void add_ModificationFinished(EventHandler value);
    public void remove_ModificationFinished(EventHandler value);
    public EnsureWritableResult get_EnsureWritableResult();
    public string get_Message();
    public sealed virtual void Dispose();
}
public class JetBrains.Util.MultiTypeComparer : object {
    private TypeHierarchyMap`1<IComparer> myComparers;
    private IList`1<Type> myTypeLinearOrder;
    private Dictionary`2<Type, Type> myTypeCache;
    public IList`1<Type> TypeLinearOrder { get; }
    public MultiTypeComparer(IEnumerable`1<Type> typeLinearOrder);
    public IList`1<Type> get_TypeLinearOrder();
    public sealed virtual int Compare(object x, object y);
    private Type GetRegisteredType(Type type);
    protected virtual Type DisambiguateTypeConflict(Type t1, Type t2);
    protected static Type DisambiguateRule(Type candidate1, Type candidate2, Type winner, Type loser);
    public void Compare();
    public void Compare(Comparator`1<T> callback);
    protected virtual object Unwrap(object wrapper);
}
public class JetBrains.Util.NamedAutoResetEvent : WaitHandle {
    public NamedAutoResetEvent(string name, bool initialState);
    public void Reset();
    public void Set();
    private static IntPtr CreateEvent(IntPtr lpEventAttributes, bool bManualReset, bool bInitialState, string lpName);
    private static bool ResetEvent(IntPtr hEvent);
    private static bool SetEvent(IntPtr hEvent);
}
public class JetBrains.Util.NamedPipes.AsyncMessageStreamReader : object {
    private static int DefaultBufferSize;
    private static int MinBufferSize;
    [NotNullAttribute]
private Byte[] myBuffer;
    private int myBufferSize;
    [CanBeNullAttribute]
private ManualResetEvent myEventEof;
    [NotNullAttribute]
private Func`1<bool> myFIsMessageComplete;
    private bool myIsCanceled;
    private ChunkList`1<Byte[]> myPreviousPartBuffers;
    [NotNullAttribute]
private Stream myStream;
    [NotNullAttribute]
public ISignal`1<Stream> MessageReceived;
    [NotNullAttribute]
public Stream BaseStream { get; }
    public AsyncMessageStreamReader(Lifetime lifetime, Stream stream, Func`1<bool> FIsCompleteMessageReceived);
    public AsyncMessageStreamReader(Lifetime lifetime, Stream stream, Func`1<bool> FIsCompleteMessageReceived, int bufferSize);
    private static AsyncMessageStreamReader();
    public Stream get_BaseStream();
    public void BeginReadMessage();
    public void CancelOperation();
    public void WaitUtilEOF();
    private void FireMessageReceivedIfComplete(int nBytesInCurrentChunk);
    private void OnBeginReadCompleted(IAsyncResult ar);
    [CompilerGeneratedAttribute]
private void <.ctor>b__0();
    [CompilerGeneratedAttribute]
private void <.ctor>b__1();
}
public class JetBrains.Util.NamedPipes.AsyncServerPipeMessageReader : object {
    private Lifetime myLifetime;
    private NamedPipeServerStream myPipe;
    private AsyncMessageStreamReader myReaderNested;
    [NotNullAttribute]
public ISignal`1<Stream> MessageReceived { get; }
    public AsyncServerPipeMessageReader(Lifetime lifetime, NamedPipeServerStream pipe);
    public ISignal`1<Stream> get_MessageReceived();
    public void BeginReadMessage();
    [CompilerGeneratedAttribute]
private void <BeginReadMessage>b__4(IAsyncResult result);
}
public class JetBrains.Util.NamedPipes.AsyncServerPipeObjectReader`1 : object {
    [NotNullAttribute]
private AsyncServerPipeMessageReader myNestedReader;
    private NamedPipeServerStream myPipe;
    public ISignal`1<TObject> ObjectReceived;
    [CompilerGeneratedAttribute]
private static Func`2<Stream, TObject> CS$<>9__CachedAnonymousMethodDelegate1;
    public AsyncServerPipeObjectReader`1(Lifetime lifetime, NamedPipeServerStream pipe);
    public AsyncServerPipeObjectReader`1(Lifetime lifetime, NamedPipeServerStream pipe, Func`2<Stream, TObject> FDeserializeObject);
    public void BeginReadMessage();
    [CompilerGeneratedAttribute]
private static TObject <.ctor>b__0(Stream stream);
}
public class JetBrains.Util.NamedPipes.ChannelReader : ValueType {
    private string myChannelName;
    private Func`1<Task> myFTaskRemainingMessagesRead;
    [NotNullAttribute]
public string ChannelName { get; }
    internal ChannelReader(string sChannelName, Task taskRemainingMessagesRead);
    internal ChannelReader(string sChannelName, Func`1<Task> FTaskRemainingMessagesRead);
    public string get_ChannelName();
    public void ReadRemainingMessages();
    [NotNullAttribute]
public Task ReadRemainingMessagesAsync();
}
public class JetBrains.Util.NamedPipes.ChannelWriter`1 : ValueType {
    private Action`1<TItem> myFWrite;
    internal ChannelWriter`1(Action`1<TItem> FWrite);
    public void Write(TItem item);
}
public class JetBrains.Util.NamedPipes.DiskFileBasedPipeEmulationChannel : object {
    [NotNullAttribute]
public static IPipeMessageChannel Factory;
    private static DiskFileBasedPipeEmulationChannel();
    private sealed virtual override ChannelReader JetBrains.Util.NamedPipes.IPipeMessageChannel.CreateReader(Lifetime lifetime, Action`3<Byte[], UInt32, UInt32> FOnRead, ILogger logger);
    private sealed virtual override ChannelWriter`1<TItem> JetBrains.Util.NamedPipes.IPipeMessageChannel.CreateWriter(Lifetime lifetime, string sChannelName, ItemSerializer<TItem> serializer, ILogger logger);
    private FileSystemPath GetFilePathFromName(string sChannelName);
}
public interface JetBrains.Util.NamedPipes.IPipeMessageChannel {
    public abstract virtual ChannelReader CreateReader(Lifetime lifetime, Action`3<Byte[], UInt32, UInt32> FOnRead, ILogger logger);
    public abstract virtual ChannelWriter`1<TItem> CreateWriter(Lifetime lifetime, string sChannelName, ItemSerializer<TItem> serializer, ILogger logger);
}
public class JetBrains.Util.NamedPipes.NamedPipeMessageChannel : object {
    [NotNullAttribute]
public static IPipeMessageChannel Factory;
    private static int PipeBufferSize;
    private static NamedPipeMessageChannel();
    private sealed virtual override ChannelReader JetBrains.Util.NamedPipes.IPipeMessageChannel.CreateReader(Lifetime lifetime, Action`3<Byte[], UInt32, UInt32> FOnRead, ILogger logger);
    private sealed virtual override ChannelWriter`1<TItem> JetBrains.Util.NamedPipes.IPipeMessageChannel.CreateWriter(Lifetime lifetime, string sChannelName, ItemSerializer<TItem> serializer, ILogger logger);
}
public class JetBrains.Util.NamedPipes.NamedPipeNativeMessageChannel : object {
    private static string ChannelNameSerializationPrefix;
    [NotNullAttribute]
public static IPipeMessageChannel Factory;
    private static UInt32 PipeBufferSize;
    private static NamedPipeNativeMessageChannel();
    private sealed virtual override ChannelReader JetBrains.Util.NamedPipes.IPipeMessageChannel.CreateReader(Lifetime lifetime, Action`3<Byte[], UInt32, UInt32> FOnRead, ILogger logger);
    private sealed virtual override ChannelWriter`1<TItem> JetBrains.Util.NamedPipes.IPipeMessageChannel.CreateWriter(Lifetime lifetime, string sChannelName, ItemSerializer<TItem> serializer, ILogger logger);
    private static Void* DeserializeHandleFromChannelName(Lifetime lifetime, string name);
    private static string MakePipeName(string sChannelName);
    private static Void* OpenReaderPipe(Lifetime lifetime, string sChannelName);
    private static Void* OpenWriterPipe(Lifetime lifetime, string sChannelName);
    private static string SerializeHandleToChannelName(Void* handle);
}
[ObsoleteAttribute("Will be removed/renamed soon because of intersection with C# 6.0 'nameof' expression")]
public static class JetBrains.Util.nameof : object {
    public static string Property(Expression`1<Func`1<TV>> property);
}
public static class JetBrains.Util.nameof`1 : object {
    public static string Property(Expression`1<Func`2<T, TV>> property);
}
public static class JetBrains.Util.NetworkUtil : object {
    public static int GetFreePort();
}
public static class JetBrains.Util.NumberUtilParsing : object {
    public static bool TryParseFloatingPoint(Byte* pchAscii, UInt32 cbText, Double* pNumber);
    public static bool TryParseFloatingPoint(string text, Double& number);
    private static bool TryExtractFloatingPointData(Byte* pchAscii, UInt32 cbText, FloatingData* pNumber);
    private static bool TryMatchNonNumbers(Byte* pchAscii, UInt32 cbText, Double* pNumber);
}
public class JetBrains.Util.ObservableRangeCollection`1 : ObservableCollection`1<T> {
    public ObservableRangeCollection`1(IEnumerable`1<T> collection);
    public void AddRange(IList`1<T> collection);
    public void RemoveRange(IList`1<T> collection);
    public void Replace(T item);
    public void ReplaceRange(IEnumerable`1<T> collection);
}
public class JetBrains.Util.OperationResult : object {
    private OperationResultType myType;
    private string myMessage;
    public OperationResultType Type { get; }
    public string Message { get; }
    public OperationResult(OperationResultType type, string message);
    public static OperationResult Success();
    public static OperationResult Fail(string failReason);
    public OperationResultType get_Type();
    public string get_Message();
}
public enum JetBrains.Util.OperationResultType : Enum {
    public int value__;
    public static OperationResultType Success;
    public static OperationResultType Fail;
}
public class JetBrains.Util.PairEnumerator`2 : object {
    private IEnumerator`1<KeyValuePair`2<TKey, TValue>> myEnumerator;
    public KeyValuePair`2<TKey, TValue> Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    public TKey CurrentKey { get; }
    public TValue CurrentValue { get; }
    public PairEnumerator`2(IEnumerator`1<KeyValuePair`2<TKey, TValue>> enumerator);
    public sealed virtual void Dispose();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
    public sealed virtual KeyValuePair`2<TKey, TValue> get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual TKey get_CurrentKey();
    public sealed virtual TValue get_CurrentValue();
}
public class JetBrains.Util.PartialSorter`1 : object {
    private List`1<T> myOrder;
    private List`1<T> myContent;
    public ICollection`1<T> OrderedContent { get; }
    public ICollection`1<T> get_OrderedContent();
    public void SetContent(ICollection`1<T> content);
    public void MoveUp(T item);
    public void MoveDown(T item);
    private T MoveUpInContent(T item);
    private T MoveDownInContent(T item);
    private void MoveUpInOrder(T item);
    private void MoveDownInOrder(T item);
}
public class JetBrains.Util.PaternMatching.Match : ValueType {
    public bool Success;
    public object Value;
}
public class JetBrains.Util.PaternMatching.MatchFailureException : Exception {
    public MatchFailureException(string message);
}
public class JetBrains.Util.PaternMatching.PatternMatcher`1 : object {
    private Func`1<Match> myMatcher;
    [CompilerGeneratedAttribute]
private static Func`2<object, bool> CS$<>9__CachedAnonymousMethodDelegate1;
    public PatternMatcher`1(Func`1<Match> matcher);
    public PatternMatcher`1<T> WithOpenGeneric(Type openGenericType, Func`2<object, object> f);
    public PatternMatcher`1<T> Default(Func`2<T, object> defaultAction, bool allowNullValue);
    public PatternMatcher`1<T> With(Func`2<TPattern, object> f);
    public PatternMatcher`1<T> WithOpenGeneric(Type openGenericType, Func`2<object, bool> predicate, Func`2<object, object> f);
    public PatternMatcher`1<T> With(Func`2<TPattern, bool> predicate, Func`2<TPattern, object> f);
    private PatternMatcher`1<T> With(Func`2<TPattern, bool> predicate, Func`2<TPattern, object> f, bool allowNullValue);
    private static Match Fail(Match obj);
    private static Match Success(Func`2<TPattern, object> f, Match obj);
    public PatternMatcher`1<T> Any(Func`1<object> f);
    public TResult Return();
    [CompilerGeneratedAttribute]
private static bool <WithOpenGeneric>b__0(object _);
    [CompilerGeneratedAttribute]
private static bool <With>b__5(TPattern _);
}
[ExtensionAttribute]
public static class JetBrains.Util.PaternMatching.PatternMatchingExtensions : object {
    [ExtensionAttribute]
public static PatternMatcher`1<T> Match(T obj);
}
public static class JetBrains.Util.Predicate : object {
    public static bool True();
    public static bool False();
}
[ExtensionAttribute]
public static class JetBrains.Util.PresentationEx : object {
    [ExtensionAttribute]
[NotNullAttribute]
public static string ToKibibytePresentation(long value);
    [NotNullAttribute]
[ExtensionAttribute]
public static string ToKibibytePresentation(ulong value);
    [NotNullAttribute]
[ExtensionAttribute]
public static string ToKibibitPresentation(long value);
    [NotNullAttribute]
[ExtensionAttribute]
public static string ToKibibitPresentation(ulong value);
}
[ExtensionAttribute]
public static class JetBrains.Util.ProcessUtil : object {
    [CompilerGeneratedAttribute]
private static Func`2<ProcessInfo, Process> CS$<>9__CachedAnonymousMethodDelegate2;
    [CompilerGeneratedAttribute]
private static Action`1<Process> CS$<>9__CachedAnonymousMethodDelegate1d;
    [CompilerGeneratedAttribute]
private static Action`1<Process> CS$<>9__CachedAnonymousMethodDelegate23;
    [CompilerGeneratedAttribute]
private static Func`2<ProcessInfo, UInt32> CS$<>9__CachedAnonymousMethodDelegate27;
    [CompilerGeneratedAttribute]
private static Func`2<Process, Process> CS$<>9__CachedAnonymousMethodDelegate38;
    [CompilerGeneratedAttribute]
private static Func`2<KeyValuePair`2<string, string>, string> CS$<>9__CachedAnonymousMethodDelegate3b;
    [CompilerGeneratedAttribute]
private static Func`3<StringBuilder, KeyValuePair`2<string, string>, StringBuilder> CS$<>9__CachedAnonymousMethodDelegate3c;
    [CompilerGeneratedAttribute]
private static Func`2<KeyValuePair`2<string, string>, string> CS$<>9__CachedAnonymousMethodDelegate3e;
    [CompilerGeneratedAttribute]
private static Func`2<DictionaryEntry, KeyValuePair`2<string, string>> CS$<>9__CachedAnonymousMethodDelegate40;
    [CompilerGeneratedAttribute]
private static Func`2<ConstructorInfo, bool> CS$<>9__CachedAnonymousMethodDelegate5f;
    [NotNullAttribute]
[ExtensionAttribute]
public static List`1<Process> GetChildren(Process process);
    [ExtensionAttribute]
public static bool Is64BitProcess(Process process);
    [CanBeNullAttribute]
[ExtensionAttribute]
public static Process GetParent(Process process);
    [ExtensionAttribute]
private static bool IsMatch(Process process, string processName);
    [ExtensionAttribute]
private static bool IsMatch(Process process, Regex regex);
    public static bool HasByProcessName(string processName);
    public static bool HasByProcessName(string processNamePattern, RegexOptions regexOptions);
    public static void KillByProcessName(string processName);
    public static void KillByProcessName(string processNamePattern, RegexOptions regexOptions);
    [ExtensionAttribute]
public static IEnumerable`1<UInt32> GetDescendantProcesses(Process process, ISet`1<UInt32> pidsToExclude);
    public static IEnumerable`1<UInt32> GetAllPids();
    [ExtensionAttribute]
public static void KillTree(Process process, ISet`1<UInt32> pidsToExclude);
    public static void KillTree(UInt32 pid, ISet`1<UInt32> pidsToExclude);
    [ExtensionAttribute]
public static bool ShutdownGracefully(Process process, ShutdownFlags flags, TimeSpan waitTimeout, ILogger logger);
    public static bool IsRunningElevated();
    public static TValue UnderDisableFsRedirection(bool disableIfNeed, Func`1<TValue> func);
    [NotNullAttribute]
public static Process Start(ProcessStartInfo startInfo);
    [NotNullAttribute]
public static Process Start_NoHandleInheritance(ProcessStartInfo startInfo, bool createNewProcessGroup);
    public static string GetEnvironmentString(IEnumerable`1<KeyValuePair`2<string, string>> environment);
    public static Byte[] EncodeEnvironmentString(IEnumerable`1<KeyValuePair`2<string, string>> environment);
    public static void EncodeEnvironmentString(IEnumerable`1<KeyValuePair`2<string, string>> environment, Cookie writeout);
    public static Byte[] EncodeEnvironmentStringMbcs(IEnumerable`1<KeyValuePair`2<string, string>> environment, Encoding encoding);
    public static Byte[] EncodeEnvironmentString(StringDictionary environment);
    [NotNullAttribute]
public static TValue Start_NoHandleInheritance(ProcessStartInfo startInfo, Func`2<Process, TValue> beforeResume, bool createNewProcessGroup);
    [NotNullAttribute]
public static TValue CreateProcess(LifetimeDefinition definition, CreateProcessInfo`1<TValue> cretinfo);
    private static Pipes CreateProcess_SetupStreamRedirects(Lifetime lifetime, CreateProcessInfo`1<TValue> startInfo, STARTUPINFO* si);
    private static void CreateProcess_SetupStreamRedirects_CreatePipe(Lifetime lifetime, string sStreamName, bool isParentReadNotWrite, Void*& hParentUninh, Void*& hChild);
    private static void CreateProcess_SyncTermination(LifetimeDefinition definition, PROCESS_INFORMATION pi);
    [NotNullAttribute]
public static Process GetProcessById(UInt32 pid);
    [NotNullAttribute]
public static Task`1<Nullable`1<UInt32>> WaitForProcessExitAsync(UInt32 pid);
    [NotNullAttribute]
[ExtensionAttribute]
public static Task`1<Nullable`1<UInt32>> WaitForExitAsync(Process process);
    public static FrugalLocalList`1<UInt32> EnumerateJobProcessIds(Void* hJob, OnError onerror);
    private static int GetInt(Byte[] buffer, int offset);
    private static IntPtr GetIntPtr(Byte[] buffer, int offset);
    public static List`1<ProcessInfo> GetProcessInfos();
    private static List`1<ProcessInfo> GetProcessInfos_Toolhelp32();
    [ObsoleteAttribute("MSDN: ZwQuerySystemInformation is no longer available for use as of Windows 8. Instead, use the alternate functions listed in this topic.")]
private static IEnumerable`1<ProcessInfo> GetProcessInfos_ZwQuerySystemInformation();
    [ExtensionAttribute]
private static void SendShutdownControl(Process process);
    [CompilerGeneratedAttribute]
private static Process <GetChildren>b__1(ProcessInfo info);
    [CompilerGeneratedAttribute]
private static void <KillByProcessName>b__1b(Process x);
    [CompilerGeneratedAttribute]
private static void <KillByProcessName>b__21(Process x);
    [CompilerGeneratedAttribute]
private static UInt32 <GetAllPids>b__26(ProcessInfo p);
    [CompilerGeneratedAttribute]
private static Process <Start_NoHandleInheritance>b__37(Process x);
    [CompilerGeneratedAttribute]
private static string <GetEnvironmentString>b__39(KeyValuePair`2<string, string> x);
    [CompilerGeneratedAttribute]
private static StringBuilder <GetEnvironmentString>b__3a(StringBuilder b, KeyValuePair`2<string, string> x);
    [CompilerGeneratedAttribute]
private static string <EncodeEnvironmentString>b__3d(KeyValuePair`2<string, string> x);
    [CompilerGeneratedAttribute]
private static KeyValuePair`2<string, string> <EncodeEnvironmentString>b__3f(DictionaryEntry x);
    [CompilerGeneratedAttribute]
private static string <Start_NoHandleInheritance>b__41(DictionaryEntry de);
    [CompilerGeneratedAttribute]
private static string <Start_NoHandleInheritance>b__42(DictionaryEntry de);
    [CompilerGeneratedAttribute]
private static bool <GetProcessById>b__5e(ConstructorInfo x);
}
public static class JetBrains.Util.ProductHeadline : object {
    public static string Copyright;
    public static string CopyrightUtfMark;
    public static string CopyrightAnsiMark;
    public static string Build;
    public static string Of(string productName, int sinceYear, bool useAnsiCopyrightMark);
}
public class JetBrains.Util.ProfileUtil : object {
    private static Hashtable ourClock;
    private static Hashtable ourStartTimes;
    private static Hashtable ourWorkingTimers;
    private static Hashtable ourCallCounter;
    private static ProfileUtil();
    public static void Clear();
    public static void Dump(double minimalTime);
    public static void StartTimer(object key);
    public static void StopTimer(object key);
    public static bool TimerWorks(object key);
}
public static class JetBrains.Util.Properties.PublicKey : object {
    public static string Product;
    public static string Mocks;
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Util.QualifiedNamesTrie`1 : object {
    private IEqualityComparer`1<StringSlice> myComparer;
    private char myDelimiter;
    protected string myDelimiterString;
    protected Node<T> myRoot;
    public T Item { get; public set; }
    public QualifiedNamesTrie`1(bool ignoreCase, char delimiter);
    public T get_Item(string qualification);
    public void set_Item(string qualification, T value);
    private static bool IsValid(string qualification);
    public bool Add(string qualification, T data);
    private bool Add(string qualification, T data, bool overwrite);
    public void ClearData(string qualification);
    [CanBeNullAttribute]
private Node<T> FindNode(string qualification);
    private Node<T> FindLongestPrefixNode(string qualification);
    [CanBeNullAttribute]
public ITrieNode<T> FindTrieNode(string qualification);
    [CanBeNullAttribute]
public T Find(string qualification);
    [CanBeNullAttribute]
public T FindLongestPrefix(string qualification);
    [CanBeNullAttribute]
private Node<T> FindParentNode(string qualifiedName, String& childName);
    public void MoveSubtree(string oldQualifiedName, string newQualifiedName);
    [NotNullAttribute]
public TrieEntry[] GetChildren(string qualification);
    public void CollectChildrenData(string qualification, IDataConsumer<T> consumer);
    public void CollectSubTreeData(string qualification, IDataConsumer<T> consumer);
    public bool RemoveKey(string qualification);
    public bool RemoveSubtree(string qualification);
    public void Dump(TextWriter to, Func`2<T, string> dataPresenter);
    public static string DefaultDataConverter(T data);
    private void MergeWith(Node<T> currNode, Node<T> otherCurrNode, QualifiedNamesTrie`1<T> otherTrie, NodeMergeHandler<T> mergeHandler);
    public void MergeWith(QualifiedNamesTrie`1<T> otherTrie, NodeMergeHandler<T> mergeHandler);
}
[ExtensionAttribute]
public static class JetBrains.Util.ReaderWriterLockHelper : object {
    [ExtensionAttribute]
public static DisposeReaderLock GetReaderLock(ReaderWriterLock readerWriterLock);
    [ExtensionAttribute]
public static DisposeWriterLock GetWriterLock(ReaderWriterLock readerWriterLock);
    [ExtensionAttribute]
public static IDisposable UpgradeToWriterLock(ReaderWriterLock readerWriterLock);
}
public class JetBrains.Util.RecentItemsList`1 : object {
    public static int UNLIMITED;
    private int myMaxCount;
    private List`1<T> myItems;
    private Func`2<T, bool> myItemValidator;
    public int MaxCount { get; public set; }
    public int Count { get; }
    public IList`1<T> Items { get; }
    public T RecentItem { get; }
    public RecentItemsList`1(int maxCount, Func`2<T, bool> itemValidator);
    public int get_MaxCount();
    public void set_MaxCount(int value);
    public int get_Count();
    public IList`1<T> get_Items();
    public void Add(T item);
    public void Remove(T item);
    public T get_RecentItem();
    private void RemoveExceedingItems();
    private void RemoveInvalidItems();
    public void Clear();
    public bool Contains(T file);
}
[ExtensionAttribute]
public static class JetBrains.Util.Rects : object {
    public static Size MaxSize { get; }
    public static Size get_MaxSize();
    [ExtensionAttribute]
public static int AbsMaximum(Size size);
    [ExtensionAttribute]
public static Rect AlignWithin(Rect source, Rect bounds);
    [ExtensionAttribute]
public static Rectangle AlignWithinUsingMinSize(Rectangle source, Rectangle bounds, Size minSize);
    [ExtensionAttribute]
public static Rectangle AlignWithinNoResize(Rectangle source, Rectangle bounds);
    public static Rectangle AlignCenter(Rectangle source, Rectangle bounds);
    public static Rect AlignCenter(Rect source, Rect bounds);
    public static Rectangle AlignCenter(Size source, Rectangle bounds);
    public static Rect AlignCenter(Size source, Rect bounds);
    public static Rectangle AlignCenterAndCrop(Rectangle source, Rectangle bounds);
    public static Rectangle AlignCenterAndCrop(Size source, Rectangle bounds);
    public static Rectangle AlignCenterAndDownscale(Rectangle source, Rectangle bounds);
    public static Rect AlignCenterAndDownscale(Rect source, Rect bounds);
    public static Rectangle AlignCenterAndDownscale(Size source, Rectangle bounds);
    public static Rect AlignCenterAndDownscale(Size source, Rect bounds);
    public static Rectangle Attach(Rectangle& anchor, DockStyle dockstyle, int size);
    public static Rectangle Attach(Rectangle& anchor, DockStyle dockstyle, Size size);
    public static Rectangle Attach(Rectangle anchor, DockStyle dockstyle, int size);
    public static Rectangle Attach(Rectangle anchor, DockStyle dockstyle, Size size);
    public static Rectangle ClipSmart(Rectangle source, Rectangle bounds);
    public static Rect ClipSmart(Rect source, Rect bounds);
    [ExtensionAttribute]
public static Point Collapse(Rectangle rectangle, Anchoring2D how);
    [ExtensionAttribute]
public static Point Collapse(Rect rectangle, Anchoring2D how);
    [PureAttribute]
[ExtensionAttribute]
public static Size Constrain(Size source, Size limit);
    [ExtensionAttribute]
public static Size Constrain(Size source, Size limit);
    [ExtensionAttribute]
public static Rectangle Deflate(Rectangle source, int left, int top, int right, int bottom);
    [ExtensionAttribute]
public static Rectangle Deflate(Rectangle source, Size size);
    [ExtensionAttribute]
public static Rect Deflate(Rect source, Size size);
    [ExtensionAttribute]
public static Rectangle Deflate(Rectangle source, Padding padding);
    [ExtensionAttribute]
public static Rect Deflate(Rect source, Thickness thickness);
    public static Rectangle Dock(Rectangle& space, DockStyle dockstyle, int size);
    public static Rect Dock(Rect& space, Nullable`1<Dock> dock, double size);
    public static Rectangle Dock(Rectangle& space, DockStyle dockstyle, Size size);
    public static Rect Dock(Rect& space, Nullable`1<Dock> dock, Size size);
    [ExtensionAttribute]
public static Rectangle Dock(Rectangle space, DockStyle dockstyle, int size);
    [ExtensionAttribute]
public static Rect Dock(Rect space, Nullable`1<Dock> dock, double size);
    [ExtensionAttribute]
public static Rectangle Dock(Rectangle space, DockStyle dockstyle, Size size);
    [ExtensionAttribute]
public static Rect Dock(Rect space, Nullable`1<Dock> dock, Size size);
    public static Size EnsureEmptySize(Size size);
    public static Rectangle FromLtrbNonnegative(int left, int top, int right, int bottom);
    public static Rect FromLtrbNonnegative(double left, double top, double right, double bottom);
    [ExtensionAttribute]
public static Rectangle[] GetBorder(Rectangle rect, Size dim);
    [ExtensionAttribute]
public static Point GetCenter(Rectangle rect);
    [ExtensionAttribute]
public static Point GetCenter(Rect rect);
    [ExtensionAttribute]
public static Point GetCenter(RECT rect);
    [ExtensionAttribute]
public static Rectangle Inflate(Rectangle source, int left, int top, int right, int bottom);
    [ExtensionAttribute]
public static Rectangle Inflate(Rectangle source, Size size);
    [ExtensionAttribute]
public static Rectangle Inflate(Rectangle source, Padding padding);
    [ExtensionAttribute]
public static Rect Inflate(Rect source, double left, double top, double right, double bottom);
    [ExtensionAttribute]
public static Rect Inflate(Rect source, Size size);
    [ExtensionAttribute]
public static Rect Inflate(Rect source, Thickness padding);
    [ExtensionAttribute]
public static bool IsCollapsed(Size size);
    [ExtensionAttribute]
public static bool IsCollapsed(Size size);
    [ExtensionAttribute]
public static bool IsCollapsed(Rectangle rect);
    [ExtensionAttribute]
public static bool IsCollapsed(Rect rect);
    [ExtensionAttribute]
public static bool IsCollapsed(Nullable`1<Rect> rect);
    [ExtensionAttribute]
public static bool IsConstrained(Size source, Size limit);
    [ExtensionAttribute]
public static bool IsConstrained(Size source, Size limit);
    [ExtensionAttribute]
public static bool IsEmptyArea(Size size);
    [ExtensionAttribute]
public static bool IsEmptyArea(Rectangle rect);
    [ExtensionAttribute]
public static bool IsInfinite(Size rect);
    [ExtensionAttribute]
public static bool IsNanOrInf(Point pt);
    [ExtensionAttribute]
public static bool IsNanOrInf(Size size);
    [ExtensionAttribute]
public static bool IsNanOrInf(Vector vector);
    [ExtensionAttribute]
public static bool IsNanOrInf(Rect rect);
    [ExtensionAttribute]
public static bool IsNormalized(Size size);
    [ExtensionAttribute]
public static bool IsNormalized(Size size);
    [ExtensionAttribute]
public static bool IsNormalized(Rectangle rect);
    [ExtensionAttribute]
public static bool IsNormalized(Rect rect);
    public static Size Max(Size , Size );
    public static Size Max(Size , Size );
    [ExtensionAttribute]
public static Size MaxValuesToZeros(Size size);
    public static Size Min(Size , Size );
    public static Size Min(Size , Size );
    [ExtensionAttribute]
public static Size Negate(Size size);
    [ExtensionAttribute]
public static Rectangle Normalize(Rectangle rect);
    [ExtensionAttribute]
public static Rect Normalize(Rect rect);
    [ExtensionAttribute]
public static Size Normalize(Size size);
    [ExtensionAttribute]
public static Rectangle Offset(Rectangle source, Size offset);
    [ExtensionAttribute]
public static Rectangle Offset(Rectangle source, Point offset);
    public static Rectangle SetBottom(Rectangle source, int bottom);
    public static Rect SetBottom(Rect source, double bottom);
    public static void SetBottom(Rectangle& source, int bottom);
    public static void SetBottom(Rect& source, double bottom);
    public static Rectangle SetLeft(Rectangle source, int left);
    public static Rect SetLeft(Rect source, double left);
    public static void SetLeft(Rectangle& source, int left);
    public static void SetLeft(Rect& source, double left);
    public static Rectangle SetRight(Rectangle source, int right);
    public static Rect SetRight(Rect source, double right);
    public static void SetRight(Rectangle& source, int right);
    public static void SetRight(Rect& source, double right);
    public static Rectangle SetTop(Rectangle source, int top);
    public static Rect SetTop(Rect source, double top);
    public static void SetTop(Rectangle& source, int top);
    public static void SetTop(Rect& source, double top);
    public static Size Size(int width, int height);
    public static Size Size(double width, double height);
    public static Size Size(Size size);
    public static Size StackHorizontally(IEnumerable`1<Size> sizes, int gap);
    public static Size StackHorizontally(int gap, Size[] sizes);
    public static Size StackVertically(IEnumerable`1<Size> sizes, int gap);
    public static Size StackVertically(int gap, Size[] sizes);
    public static Rectangle Unite(Rectangle one, Rectangle two);
    public static Rectangle UniteHorizontally(Rectangle source, Rectangle other);
    public static Rect UniteHorizontally(Rect source, Rect other);
    public static Rectangle UniteVertically(Rectangle source, Rectangle other);
    public static Rect UniteVertically(Rect source, Rect other);
    [ExtensionAttribute]
public static Size ZerosToMaxValues(Size size);
    [ExtensionAttribute]
public static Point AssertIsReal(Point pt, string failmessage);
    [ExtensionAttribute]
public static Rect AssertIsReal(Rect rect, string failmessage);
    [ExtensionAttribute]
public static Size AssertIsReal(Size size, string failmessage);
    private static int Collapse_Linear(int first, int second, Anchoring how);
    private static double Collapse_Linear(double first, double second, Anchoring how);
    private static Size StackImpl(IEnumerable`1<Size> sizes, int gap, bool bHorizontally);
}
public class JetBrains.Util.RecursiveQualifiedNamesTrieVisitior`1 : object {
    private EventHandler`1<EventArgs`1<TrieEntry<T>>> VisitingChildEntry;
    private EventHandler`1<EventArgs`1<ITrieNode<T>>> VisitingNode;
    private EventHandler`1<EventArgs`1<ITrieNode<T>>> VisitedNode;
    public void add_VisitingChildEntry(EventHandler`1<EventArgs`1<TrieEntry<T>>> value);
    public void remove_VisitingChildEntry(EventHandler`1<EventArgs`1<TrieEntry<T>>> value);
    public void add_VisitingNode(EventHandler`1<EventArgs`1<ITrieNode<T>>> value);
    public void remove_VisitingNode(EventHandler`1<EventArgs`1<ITrieNode<T>>> value);
    public void add_VisitedNode(EventHandler`1<EventArgs`1<ITrieNode<T>>> value);
    public void remove_VisitedNode(EventHandler`1<EventArgs`1<ITrieNode<T>>> value);
    public virtual void Visit(ITrieNode<T> trieNode);
    protected virtual void ProcessBeforeChildren(ITrieNode<T> trieNode);
    protected virtual void ProcessChild(TrieEntry<T> childEntry);
    protected virtual void ProcessAfterChildren(ITrieNode<T> trieNode);
}
public class JetBrains.Util.Reflection.LoggerTypeDescriptorContext : object {
    private ILogger myLogger;
    [NotNullAttribute]
protected ILogger Logger { get; }
    private IContainer System.ComponentModel.ITypeDescriptorContext.Container { get; }
    private object System.ComponentModel.ITypeDescriptorContext.Instance { get; }
    private PropertyDescriptor System.ComponentModel.ITypeDescriptorContext.PropertyDescriptor { get; }
    public LoggerTypeDescriptorContext(ILogger logger);
    private sealed virtual override object System.IServiceProvider.GetService(Type serviceType);
    protected ILogger get_Logger();
    private sealed virtual override bool System.ComponentModel.ITypeDescriptorContext.OnComponentChanging();
    private sealed virtual override void System.ComponentModel.ITypeDescriptorContext.OnComponentChanged();
    private sealed virtual override IContainer System.ComponentModel.ITypeDescriptorContext.get_Container();
    private sealed virtual override object System.ComponentModel.ITypeDescriptorContext.get_Instance();
    private sealed virtual override PropertyDescriptor System.ComponentModel.ITypeDescriptorContext.get_PropertyDescriptor();
    private sealed virtual override ValueSerializer System.Windows.Markup.IValueSerializerContext.GetValueSerializerFor(Type type);
    private sealed virtual override ValueSerializer System.Windows.Markup.IValueSerializerContext.GetValueSerializerFor(PropertyDescriptor descriptor);
}
[ExtensionAttribute]
public static class JetBrains.Util.RegistryKeyEx : object {
    [ExtensionAttribute]
[CanBeNullAttribute]
public static RegistryKey OpenSubKey(RegistryKey root, Lifetime lifetime, string subKeyName);
}
public class JetBrains.Util.RegistryNavigator : XPathNavigator {
    private RegNavState myState;
    public XPathNodeType NodeType { get; }
    public string LocalName { get; }
    public string NamespaceURI { get; }
    public string Name { get; }
    public string Prefix { get; }
    public string Value { get; }
    public bool IsEmptyElement { get; }
    public XmlNameTable NameTable { get; }
    private int AttributeCount { get; }
    public bool HasAttributes { get; }
    public bool HasChildren { get; }
    public string BaseURI { get; }
    public string XmlLang { get; }
    internal RegistryNavigator(RegNavState state);
    public virtual XPathNavigator Clone();
    public virtual XPathNodeType get_NodeType();
    public virtual string get_LocalName();
    public virtual string get_NamespaceURI();
    public virtual string get_Name();
    public virtual string get_Prefix();
    public virtual string get_Value();
    public virtual bool get_IsEmptyElement();
    public virtual XmlNameTable get_NameTable();
    private int get_AttributeCount();
    public virtual bool get_HasAttributes();
    public virtual bool get_HasChildren();
    public virtual string get_BaseURI();
    public virtual string get_XmlLang();
    public virtual string GetAttribute(string localName, string namespaceURI);
    public virtual bool MoveToAttribute(string localName, string namespaceURI);
    public virtual bool MoveToFirstAttribute();
    public virtual bool MoveToNextAttribute();
    public bool MoveToPreviousAttribute();
    public virtual string GetNamespace(string name);
    public virtual bool MoveToNamespace(string name);
    public virtual bool MoveToFirstNamespace(XPathNamespaceScope namespaceScope);
    public virtual bool MoveToNextNamespace(XPathNamespaceScope namespaceScope);
    public virtual bool MoveToNext();
    public virtual bool MoveToPrevious();
    public virtual bool MoveToFirst();
    public virtual bool MoveToFirstChild();
    private bool MoveToChild(int i);
    public virtual bool MoveToParent();
    public virtual void MoveToRoot();
    public virtual bool MoveTo(XPathNavigator other);
    public virtual bool MoveToId(string id);
    public virtual bool IsSamePosition(XPathNavigator other);
}
public class JetBrains.Util.RegistryUtil : object {
    public static string GetValue(string xpath);
    [ObsoleteAttribute("See RegistryHiveAccess class which has registry-view-bound helper methods.")]
[CanBeNullAttribute]
public static RegistryKey OpenSoftwareKey(Lifetime lifetime);
    [NotNullAttribute]
public static string GetMimeType(string sExtensionWithDot);
}
internal class JetBrains.Util.RegNavState : object {
    private RegistryKey myCurrentKey;
    private int myUserCount;
    private int myCurrentAttr;
    private String[] myValueNames;
    private String[] myKeyNames;
    public RegNavState prev;
    public int index;
    private string myName;
    private string myXmlName;
    private int myCount;
    private NameTable myNameTable;
    private object myTextnodename;
    private object myDocnodename;
    private object myRegnodename;
    private static String[] ourRootNames;
    private static RegNavState[] ourRootStates;
    public RegNavState Parent { get; }
    public int IndexInParent { get; }
    private RegistryKey CurrentKey { get; }
    public bool IsDocument { get; }
    public bool IsDocumentElement { get; }
    public bool IsTextNode { get; }
    public bool HasTextNode { get; }
    public bool HasChildren { get; }
    public int ChildCount { get; }
    public int AttributeCount { get; }
    public bool IsAttribute { get; }
    public string Name { get; }
    public string Value { get; }
    public string AttributeValue { get; }
    public NameTable NameTable { get; }
    internal RegNavState(RegistryKey key, string name, RegNavState parent, int i, int attr);
    private static RegNavState();
    private RegNavState GetRootState(int i, RegNavState root);
    public bool IsSame(RegNavState other);
    public RegNavState get_Parent();
    public RegNavState Clone();
    public int get_IndexInParent();
    public RegNavState FindRoot(string name);
    private String[] GetKeyNames();
    private String[] GetValueNames();
    private RegistryKey get_CurrentKey();
    public RegNavState OpenChild(int i);
    public bool get_IsDocument();
    public bool get_IsDocumentElement();
    public bool get_IsTextNode();
    public bool get_HasTextNode();
    public bool get_HasChildren();
    public int get_ChildCount();
    public int get_AttributeCount();
    public bool get_IsAttribute();
    public bool MoveToAttribute(int i);
    public void MoveToElement();
    public bool MoveToNextAttribute();
    public bool MoveToPreviousAttribute();
    public string XmlName(string str);
    public string get_Name();
    public string get_Value();
    public string get_AttributeValue();
    public bool MoveToAttribute(string name);
    internal int FindAttrOffset(string name);
    public NameTable get_NameTable();
    public void Close();
    public void AddRef();
    protected virtual void Finalize();
}
public static class JetBrains.Util.ReinterpretCast : object {
    public static TTo ValueTypeOrNullable(TFrom original);
}
[ExtensionAttribute]
public static class JetBrains.Util.ResultExtensions : object {
    [ExtensionAttribute]
public static bool IsSuccess(OperationResult result);
    [ExtensionAttribute]
public static bool IsFail(OperationResult result);
}
public class JetBrains.Util.Runnable : MulticastDelegate {
    public Runnable(object object, IntPtr method);
    public virtual void Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class JetBrains.Util.SeparateThreadRunner : object {
    private Thread myWorkThread;
    private Thread myWaitThread;
    private int myWorkThreadId;
    private int myWaitThreadId;
    private static ILogger ourLogger;
    public SeparateThreadRunner(Lifetime lifetime, string name, Action`1<SeparateThreadRunner> actionToPerform, Action`1<SeparateThreadRunner> actionOnTimeout, TimeSpan timeout);
    private static SeparateThreadRunner();
    private static void AbortThread(Thread thread, int threadId, TimeSpan abortTimeout);
    private static bool TerminateThread(int threadId, string threadName);
}
public class JetBrains.Util.Serialization.CsexpArchive : object {
    [CanBeNullAttribute]
private CsexpReader myReader;
    [CanBeNullAttribute]
private CsexpWriter myWriter;
    public bool IsStoring { get; }
    public CsexpArchive(CsexpReader reader);
    public CsexpArchive(CsexpWriter writer);
    public bool get_IsStoring();
    public AutoEndSerializeList BeginSerializeList();
    public AutoEndSerializeList BeginSerializeNamedList(string name);
    [NotNullAttribute]
public CsexpReader GetReader();
    [NotNullAttribute]
public CsexpWriter GetWriter();
    public static CsexpArchive op_Implicit(CsexpReader reader);
    public static CsexpArchive op_Implicit(CsexpWriter writer);
    public void SerializeNamedListItems(string listname, ICollection`1<TItem> items, Action`2<TItem, CsexpArchive> FSerializeItem);
    public void SerializeNamedListItems(string listname, FrugalLocalList`1& items, Action`2<TItem, CsexpArchive> FSerializeItem);
    public void SerializeNamedListItems(string listname, ICollection`1<TItem> items, Func`2<CsexpReader, TItem> FRead, Action`2<TItem, CsexpWriter> FWrite);
    public void SerializeNamedListItemsByRef(string listname, ICollection`1& items, SerializeItemDelegate`1<TItem> FSerializeItem);
    public void SerializeNamedListItemsByRef(string listname, IList`1& items, SerializeItemDelegate`1<TItem> FSerializeItem);
    public void SerializeNamedListItemsByRef(string listname, FrugalLocalList`1& items, SerializeItemDelegate`1<TItem> FSerializeItem);
    public void SerializeNamedValue(string name, TValue& value);
    public void SerializeNamedValue(string name, String& value);
    public void SerializeValue(TValue& value);
    public void SerializeValue(String& value);
    public virtual string ToString();
}
[ExtensionAttribute]
public static class JetBrains.Util.Serialization.CsexpArchiveEx : object {
    [ExtensionAttribute]
public static void SerializeDoubleTextValue(CsexpArchive ar, Double& value);
}
public class JetBrains.Util.Serialization.CsexpReader : object {
    private static int BuffersCbSize;
    private Stream myInStream;
    private UInt32 myLevel;
    private Byte[] myPrecache;
    private UInt32 myPrecacheDataEnd;
    private UInt32 myPrecacheDataStart;
    private ulong myReadTillNextToken;
    private Byte[] myTmpBuffer;
    private CsexpTokenKind myTokenKind;
    public UInt32 Level { get; }
    public CsexpTokenKind TokenKind { get; }
    public CsexpReader(Stream instream);
    public UInt32 get_Level();
    public CsexpTokenKind get_TokenKind();
    public ulong GetCurrentStringTokenCbSize();
    [NotNullAttribute]
public Byte[] ReadBufferValue();
    public UInt32 ReadBufferValue(Byte[] buffer, UInt32 position);
    public void ReadBufferValue(Cookie writeout);
    public ulong ReadDecValue();
    public ulong ReadHexValue();
    public void ReadStreamValue(Stream outstream);
    [NotNullAttribute]
public string ReadStringValue(string assertThisValue);
    public CsexpTokenKind Skip();
    private void BeginReadNextToken();
    private void FillCache();
    private long GetUnderlyingStreamPosition();
    private void ReadBufferValueSlow(Byte[] buffer, UInt32 position, UInt32 dwRemaining);
    private void ReadBufferValueSlow(Cookie writeout, UInt32 dwRemaining);
    private byte ReadByte();
    private byte ReadByteSlow();
    [NotNullAttribute]
private string ReadStringValueLarge(string assertThisValue);
    private void SkipUnreadBytes();
}
[ExtensionAttribute]
public static class JetBrains.Util.Serialization.CsexpReaderEx : object {
    [ExtensionAttribute]
public static AutoEndReadList BeginReadList(CsexpReader reader);
    [ExtensionAttribute]
public static AutoEndReadList BeginReadNamedList(CsexpReader reader, string name);
    [ExtensionAttribute]
public static void EndReadList(CsexpReader reader, string sListNameIfKnown);
    [ExtensionAttribute]
public static double ReadDoubleTextValue(CsexpReader reader);
    [ExtensionAttribute]
[NotNullAttribute]
public static string ReadNamedValue(CsexpReader reader, string name);
    [CanBeNullAttribute]
[ExtensionAttribute]
public static TValue ReadNamedValue(CsexpReader reader, string name);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static TValue ReadValue(CsexpReader reader);
    private static void ReadDoubleTextValue_Throw(HResults hr, Cookie buffer, int nBytes);
    private static double ReadDoubleTextValue_ToString(Cookie buffer);
}
public static class JetBrains.Util.Serialization.CsexpSerialization : object {
    public static string DefaultFileExtension;
    public static Encoding TransportEncoding;
    private static CsexpSerialization();
}
public enum JetBrains.Util.Serialization.CsexpTokenKind : Enum {
    public int value__;
    public static CsexpTokenKind End;
    public static CsexpTokenKind ListOpen;
    public static CsexpTokenKind ListClose;
    public static CsexpTokenKind String;
}
public class JetBrains.Util.Serialization.CsexpWriter : object {
    private Byte[] myBuffer;
    [NotNullAttribute]
private Stream myOutStream;
    [CompilerGeneratedAttribute]
private bool <IsOuterListClosed>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Level>k__BackingField;
    public bool IsOuterListClosed { get; private set; }
    public UInt32 Level { get; private set; }
    public CsexpWriter(Stream stream);
    [CompilerGeneratedAttribute]
public bool get_IsOuterListClosed();
    [CompilerGeneratedAttribute]
private void set_IsOuterListClosed(bool value);
    [CompilerGeneratedAttribute]
public UInt32 get_Level();
    [CompilerGeneratedAttribute]
private void set_Level(UInt32 value);
    public void CloseNestedList();
    public void OpenNestedList();
    public void WriteBuffer(Byte[] value);
    public void WriteBuffer(Void* pbuffer, UInt32 length);
    public void WriteDecValue(ulong value);
    public void WriteHexValue(ulong value);
    public void WriteStream(Stream instream);
    public void WriteString(string value);
}
[ExtensionAttribute]
public static class JetBrains.Util.Serialization.CsexpWriterEx : object {
    [ExtensionAttribute]
public static AutoEndWriteList BeginWriteList(CsexpWriter writer);
    [ExtensionAttribute]
public static AutoEndWriteList BeginWriteNamedList(CsexpWriter writer, string name);
    [ExtensionAttribute]
public static void WriteNameValue(CsexpWriter writer, string name, string value);
    [ExtensionAttribute]
public static void WriteNameValue(CsexpWriter writer, string name, TValue value);
    [ExtensionAttribute]
public static void WriteValue(CsexpWriter writer, TValue value);
    [ExtensionAttribute]
public static void WriteDoubleTextValue(CsexpWriter writer, double value);
}
public class JetBrains.Util.Serialization.JsonTypeConverter`1 : TypeConverterBase`1<T> {
    private static DataContractJsonSerializer ourJsonSerializer;
    private static JsonTypeConverter`1();
    private static string SerializeToString(ITypeDescriptorContext typeDescriptorContext, CultureInfo cultureInfo, T value);
    private static T DeserializeFromString(ITypeDescriptorContext typeDescriptorContext, CultureInfo cultureInfo, string value);
}
public class JetBrains.Util.Serialization.JsonTypeConverterNewtonsoft`1 : TypeConverterBase`1<T> {
    private static Func`4<ITypeDescriptorContext, CultureInfo, string, T> FromString;
    private static Func`4<ITypeDescriptorContext, CultureInfo, T, string> ToString;
    [CompilerGeneratedAttribute]
private static Func`4<ITypeDescriptorContext, CultureInfo, string, T> CS$<>9__CachedAnonymousMethodDelegate2;
    [CompilerGeneratedAttribute]
private static Func`4<ITypeDescriptorContext, CultureInfo, T, string> CS$<>9__CachedAnonymousMethodDelegate3;
    private static JsonTypeConverterNewtonsoft`1();
    [CompilerGeneratedAttribute]
private static T <.cctor>b__0(ITypeDescriptorContext x, CultureInfo y, string s);
    [CompilerGeneratedAttribute]
private static string <.cctor>b__1(ITypeDescriptorContext x, CultureInfo y, T o);
}
public class JetBrains.Util.Serialization.JsonValueSerializer`1 : ValueSerializerBase`1<T> {
    private static DataContractJsonSerializer ourJsonSerializer;
    private static JsonValueSerializer`1();
    private static T FFromString(IValueSerializerContext valueSerializerContext, string value);
    private static string FToString(IValueSerializerContext valueSerializerContext, T value);
}
public class JetBrains.Util.Serialization.JsonValueSerializerNewtonsoft`1 : ValueSerializerBase`1<T> {
    private static Func`3<IValueSerializerContext, string, T> FromString;
    private static Func`3<IValueSerializerContext, T, string> ToString;
    [CompilerGeneratedAttribute]
private static Func`3<IValueSerializerContext, string, T> CS$<>9__CachedAnonymousMethodDelegate2;
    [CompilerGeneratedAttribute]
private static Func`3<IValueSerializerContext, T, string> CS$<>9__CachedAnonymousMethodDelegate3;
    private static JsonValueSerializerNewtonsoft`1();
    [CompilerGeneratedAttribute]
private static T <.cctor>b__0(IValueSerializerContext context, string s);
    [CompilerGeneratedAttribute]
private static string <.cctor>b__1(IValueSerializerContext context, T o);
}
[AttributeUsageAttribute("28")]
public class JetBrains.Util.Serialization.MemberwiseSerializableAttribute : Attribute {
}
[AttributeUsageAttribute("28")]
public class JetBrains.Util.Serialization.XamlSerializableAttribute : Attribute {
}
public static class JetBrains.Util.Sizeof : object {
    private static IDynamicInterface DynamicObject;
    private static Sizeof();
    public static int Type();
}
[DebuggerTypeProxyAttribute("JetBrains.Util.SortedOneToListMap`2/OneToListMapDebugView")]
[DebuggerDisplayAttribute("Count = {Count}")]
[DefaultMemberAttribute("Item")]
public class JetBrains.Util.SortedOneToListMap`2 : object {
    private static Statistics Statistics;
    private SortedDictionary`2<TKey, List`1<TValue>> myMap;
    public int Count { get; }
    public ICollection`1<TKey> Keys { get; }
    [NotNullAttribute]
public IList`1<TValue> Item { get; }
    public SortedOneToListMap`2(IEnumerable`1<KeyValuePair`2<TKey, IList`1<TValue>>> enumerable, IComparer`1<TKey> comparer);
    public SortedOneToListMap`2(IComparer`1<TKey> comparer);
    private static SortedOneToListMap`2();
    public int get_Count();
    public void Clear();
    public ICollection`1<TKey> get_Keys();
    public IList`1<TValue> get_Item(TKey key);
    public void Add(TKey key, TValue value);
    public void AddValue(TKey key, TValue value);
    public void AddValueRange(TKey key, IEnumerable`1<TValue> list);
    public bool RemoveValue(TKey key, TValue value);
    public bool RemoveKey(TKey key);
    public bool ContainsKey(TKey key);
    public bool ContainsValue(TValue value);
    public bool ContainsPair(TKey key, TValue value);
    [CanBeNullAttribute]
private List`1<TValue> GetValues(TKey key);
    public JetReadOnlyCollection`1<TValue> GetValuesCollection(TKey key);
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, IList`1<TValue>>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public void ClearKey(TKey key);
}
[ExtensionAttribute]
public static class JetBrains.Util.StableSorter : object {
    [ExtensionAttribute]
public static void StableSort(IList`1<T> list, IComparer`1<T> comparer);
    public static void Sort(IList`1<T> list, IComparer`1<T> comparer);
    private static void SortList(IList`1<T> list, T[] temp, int startIndex, int endIndex, IComparer`1<T> comparer);
    private static void Merge(IList`1<T> list, T[] temp, int startIndex, int mediumIndex, int endIndex, IComparer`1<T> comparer);
}
public class JetBrains.Util.StackTraceParser.CompositeNode : StackTraceNode {
    private List`1<StackTraceNode> myNodes;
    [CompilerGeneratedAttribute]
private static Func`3<int, StackTraceNode, int> CS$<>9__CachedAnonymousMethodDelegate1;
    public List`1<StackTraceNode> Nodes { get; }
    public CompositeNode(TextRange range);
    public void AppendNode(StackTraceNode node);
    public List`1<StackTraceNode> get_Nodes();
    public virtual void Dump(TextWriter writer);
    public virtual void Accept(StackTraceNodeVisitor visitor);
    protected bool Equals(CompositeNode other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
private static int <GetHashCode>b__0(int current, StackTraceNode node);
}
public class JetBrains.Util.StackTraceParser.IdentifierNode : StackTraceNode {
    private string myName;
    private IdentifierNode myQualifier;
    private IList`1<IdentifierNode> myTypeParameters;
    public string Name { get; public set; }
    public IdentifierNode Qualifier { get; public set; }
    public IList`1<IdentifierNode> TypeParameters { get; public set; }
    public IdentifierNode(string fullName, TextRange range);
    public string get_Name();
    public void set_Name(string value);
    public IdentifierNode get_Qualifier();
    public void set_Qualifier(IdentifierNode value);
    public IList`1<IdentifierNode> get_TypeParameters();
    public void set_TypeParameters(IList`1<IdentifierNode> value);
    public void DumpQualifier(TextWriter writer);
    public virtual void Dump(TextWriter writer);
    public virtual void Accept(StackTraceNodeVisitor visitor);
    protected bool Equals(IdentifierNode other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class JetBrains.Util.StackTraceParser.Java.JavaStackTraceParser : object {
    private JavaStackTraceLexer myLexer;
    private CompositeNode myRootNode;
    public CompositeNode RootNode { get; }
    public JavaStackTraceParser(JavaStackTraceLexer lexer);
    public JavaStackTraceParser(string text);
    public CompositeNode get_RootNode();
    public void Parse();
    private bool ParseExceptions(CompositeNode compositeNode);
    private bool ParseMethod(CompositeNode parentNode);
    private bool ParsePath(CompositeNode parentNode);
    private IdentifierNode ParseIdentifier();
    private IdentifierNode ProcessQualifier(IdentifierNode current);
}
public class JetBrains.Util.StackTraceParser.JavaStackTraceLexer : object {
    private static int YY_F;
    private static int YY_NO_STATE;
    private static int YY_NOT_ACCEPT;
    private static int YY_START;
    private static int YY_END;
    private static int YY_NO_ANCHOR;
    private static int YY_BOL;
    private static int YY_EOF;
    protected static int YYINITIAL;
    private static int YY_E_INTERNAL;
    private static int YY_E_MATCH;
    protected StackTokenTypes currTokenType;
    private int yy_buffer_index;
    private int yy_buffer_start;
    private int yy_buffer_end;
    private IBuffer yy_buffer;
    private int yy_eof_pos;
    private bool yy_at_bol;
    private int yy_lexical_state;
    private static Int32[] yy_state_dtrans;
    private static String[] yy_error_string;
    private static Int32[] yy_acpt;
    private static Int32[] yy_cmap;
    private static Int32[] yy_rmap;
    private static Int32[0...,0...] yy_nxt;
    public UInt32 LexerState { get; }
    public StackTokenTypes TokenType { get; }
    public int TokenStart { get; }
    public int TokenEnd { get; }
    public string TokenText { get; }
    public int LexemIndent { get; }
    public IBuffer Buffer { get; }
    public static short NStates { get; }
    protected int BufferIndex { get; protected set; }
    protected int BufferStart { get; protected set; }
    protected int BufferEnd { get; protected set; }
    protected int EOFPos { get; protected set; }
    protected int LexicalState { get; protected set; }
    public JavaStackTraceLexer(IBuffer buffer);
    public JavaStackTraceLexer(IBuffer buffer, int startOffset, int endOffset);
    private static JavaStackTraceLexer();
    protected StackTokenTypes makeToken(StackTokenTypes type);
    public void Start();
    public void Start(int startOffset, int endOffset, UInt32 state);
    public void Advance();
    public UInt32 get_LexerState();
    public State SaveState();
    public void RestoreState(State pos);
    public StackTokenTypes get_TokenType();
    public int get_TokenStart();
    public int get_TokenEnd();
    public string get_TokenText();
    public int get_LexemIndent();
    public IBuffer get_Buffer();
    protected virtual void locateToken();
    public static short get_NStates();
    protected int get_BufferIndex();
    protected void set_BufferIndex(int value);
    protected int get_BufferStart();
    protected void set_BufferStart(int value);
    protected int get_BufferEnd();
    protected void set_BufferEnd(int value);
    protected int get_EOFPos();
    protected void set_EOFPos(int value);
    protected int get_LexicalState();
    protected void set_LexicalState(int value);
    private void yybegin(int state);
    private int yy_advance();
    private void yy_move_end();
    private void yy_mark_start();
    private void yy_mark_end();
    private void yy_to_mark();
    internal string yytext();
    private int yylength();
    private void yy_error(int code, bool fatal);
    public StackTokenTypes _locateToken();
}
public class JetBrains.Util.StackTraceParser.MethodNode : StackTraceNode {
    private IdentifierNode myName;
    private ParameterListNode myParameterList;
    public IdentifierNode Name { get; }
    public ParameterListNode ParameterList { get; public set; }
    public MethodNode(IdentifierNode fullName, TextRange range);
    public IdentifierNode get_Name();
    public ParameterListNode get_ParameterList();
    public void set_ParameterList(ParameterListNode value);
    public virtual void Dump(TextWriter writer);
    public virtual void Accept(StackTraceNodeVisitor visitor);
    protected bool Equals(MethodNode other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public enum JetBrains.Util.StackTraceParser.ParameterKind : Enum {
    public int value__;
    public static ParameterKind ByVal;
    public static ParameterKind ByRef;
    public static ParameterKind Pointer;
}
public class JetBrains.Util.StackTraceParser.ParameterListNode : CompositeNode {
    public ParameterListNode(TextRange range);
    public virtual void Dump(TextWriter writer);
    public virtual void Accept(StackTraceNodeVisitor visitor);
}
public class JetBrains.Util.StackTraceParser.ParameterNode : StackTraceNode {
    private IdentifierNode myType;
    private IdentifierNode myName;
    private TextNode myValue;
    private ParameterKind myKind;
    private int myArrayBounds;
    public ParameterKind Kind { get; }
    public int ArrayBounds { get; }
    public IdentifierNode Type { get; }
    public IdentifierNode Name { get; }
    public TextNode Value { get; }
    public ParameterNode(TextRange range, IdentifierNode type, IdentifierNode name, ParameterKind kind, int arrayBounds, TextNode value);
    public ParameterKind get_Kind();
    public int get_ArrayBounds();
    public IdentifierNode get_Type();
    public IdentifierNode get_Name();
    public TextNode get_Value();
    public virtual void Dump(TextWriter writer);
    public virtual void Accept(StackTraceNodeVisitor visitor);
}
public class JetBrains.Util.StackTraceParser.PathNode : StackTraceNode {
    private string myPath;
    private int myLine;
    private int myColumn;
    public string Path { get; }
    public int Line { get; public set; }
    public int Column { get; public set; }
    public PathNode(TextRange range, string path);
    public string get_Path();
    public int get_Line();
    public void set_Line(int value);
    public int get_Column();
    public void set_Column(int value);
    public virtual void Dump(TextWriter writer);
    public virtual void Accept(StackTraceNodeVisitor visitor);
}
public enum JetBrains.Util.StackTraceParser.StackTokenTypes : Enum {
    public int value__;
    public static StackTokenTypes UNDEFINED;
    public static StackTokenTypes WHITESPACE;
    public static StackTokenTypes IDENTIFIER;
    public static StackTokenTypes WORD;
    public static StackTokenTypes NUMBER;
    public static StackTokenTypes PATH_SEPARATOR;
    public static StackTokenTypes LPARENTH;
    public static StackTokenTypes RPARENTH;
    public static StackTokenTypes DOT;
    public static StackTokenTypes COMMA;
    public static StackTokenTypes AMPERSAND;
    public static StackTokenTypes ASTERISK;
    public static StackTokenTypes LBRACKET;
    public static StackTokenTypes RBRACKET;
    public static StackTokenTypes LANGLE;
    public static StackTokenTypes RANGLE;
    public static StackTokenTypes COLON;
    public static StackTokenTypes EXCLAMATION;
    public static StackTokenTypes EQUALS;
    public static StackTokenTypes LBRACE;
    public static StackTokenTypes RBRACE;
    public static StackTokenTypes QUOTATION;
    public static StackTokenTypes MINUS;
}
public class JetBrains.Util.StackTraceParser.StackTraceLexer : object {
    private static int YY_F;
    private static int YY_NO_STATE;
    private static int YY_NOT_ACCEPT;
    private static int YY_START;
    private static int YY_END;
    private static int YY_NO_ANCHOR;
    private static int YY_BOL;
    private static int YY_EOF;
    protected static int YYINITIAL;
    private static int YY_E_INTERNAL;
    private static int YY_E_MATCH;
    protected StackTokenTypes currTokenType;
    private int yy_buffer_index;
    private int yy_buffer_start;
    private int yy_buffer_end;
    private IBuffer yy_buffer;
    private int yy_eof_pos;
    private bool yy_at_bol;
    private int yy_lexical_state;
    private static Int32[] yy_state_dtrans;
    private static String[] yy_error_string;
    private static Int32[] yy_acpt;
    private static Int32[] yy_cmap;
    private static Int32[] yy_rmap;
    private static Int32[0...,0...] yy_nxt;
    public UInt32 LexerState { get; }
    public StackTokenTypes TokenType { get; }
    public int TokenStart { get; }
    public int TokenEnd { get; }
    public string TokenText { get; }
    public int LexemIndent { get; }
    public IBuffer Buffer { get; }
    public static short NStates { get; }
    protected int BufferIndex { get; protected set; }
    protected int BufferStart { get; protected set; }
    protected int BufferEnd { get; protected set; }
    protected int EOFPos { get; protected set; }
    protected int LexicalState { get; protected set; }
    public StackTraceLexer(IBuffer buffer);
    public StackTraceLexer(IBuffer buffer, int startOffset, int endOffset);
    private static StackTraceLexer();
    protected StackTokenTypes makeToken(StackTokenTypes type);
    public void Start();
    public void Start(int startOffset, int endOffset, UInt32 state);
    public void Advance();
    public UInt32 get_LexerState();
    public State SaveState();
    public void RestoreState(State pos);
    public StackTokenTypes get_TokenType();
    public int get_TokenStart();
    public int get_TokenEnd();
    public string get_TokenText();
    public int get_LexemIndent();
    public IBuffer get_Buffer();
    protected virtual void locateToken();
    public static short get_NStates();
    protected int get_BufferIndex();
    protected void set_BufferIndex(int value);
    protected int get_BufferStart();
    protected void set_BufferStart(int value);
    protected int get_BufferEnd();
    protected void set_BufferEnd(int value);
    protected int get_EOFPos();
    protected void set_EOFPos(int value);
    protected int get_LexicalState();
    protected void set_LexicalState(int value);
    private void yybegin(int state);
    private int yy_advance();
    private void yy_move_end();
    private void yy_mark_start();
    private void yy_mark_end();
    private void yy_to_mark();
    internal string yytext();
    private int yylength();
    private void yy_error(int code, bool fatal);
    public StackTokenTypes _locateToken();
}
public static class JetBrains.Util.StackTraceParser.StackTraceLexerUtil : object {
    public static string Normalize(string text);
}
public abstract class JetBrains.Util.StackTraceParser.StackTraceNode : object {
    private TextRange myRange;
    public TextRange Range { get; }
    protected StackTraceNode(TextRange range);
    public TextRange get_Range();
    public void UnionRange(TextRange range);
    public abstract virtual void Dump(TextWriter writer);
    public abstract virtual void Accept(StackTraceNodeVisitor visitor);
}
public class JetBrains.Util.StackTraceParser.StackTraceNodeVisitor : object {
    public virtual void VisitText(TextNode node);
    public virtual void VisitParameter(ParameterNode node);
    public virtual void VisitPath(PathNode node);
    public virtual void VisitMethod(MethodNode node);
    public virtual void VisitIdentifier(IdentifierNode node);
    public virtual void VisitCompositeNode(CompositeNode node);
    public virtual void VisitParameterList(ParameterListNode node);
}
public class JetBrains.Util.StackTraceParser.StackTraceParser : object {
    private StackTraceLexer myLexer;
    private String[] myInvalidPathChars;
    private bool myCheckForInvalidChars;
    private bool myParsePath;
    private CompositeNode myRootNode;
    [CompilerGeneratedAttribute]
private static Func`2<char, string> CS$<>9__CachedAnonymousMethodDelegate1;
    public CompositeNode RootNode { get; }
    public StackTraceParser(StackTraceLexer lexer);
    public StackTraceParser(StackTraceLexer lexer, bool checkForInvalidChars, bool parsePath);
    public CompositeNode get_RootNode();
    public void Parse();
    private bool ParseMethod(CompositeNode node);
    private static string CleanPath(string path);
    private bool ParsePath(CompositeNode parentNode);
    private bool ParsePathSlow(CompositeNode parentNode);
    private bool ParsePathFast();
    private int ParseCoordinate();
    private void ParseCoordinates(PathNode node);
    private IdentifierNode ParseIdentifier();
    private IdentifierNode ProcessQualifiee(IdentifierNode current);
    private bool ParseParameters(MethodNode node);
    private void SkipWhiteSpace();
    private TextNode ParseParameterValue();
    private TextNode ParseStringConstant();
    private TextNode ParseNumericConstant();
    private TextNode CreateNonEmptyTextNode(int start, int end);
    [CompilerGeneratedAttribute]
private static string <.ctor>b__0(char c);
}
public class JetBrains.Util.StackTraceParser.TextNode : StackTraceNode {
    private string myText;
    public string Text { get; }
    public TextNode(TextRange range, string text);
    public string get_Text();
    public virtual void Dump(TextWriter writer);
    public virtual void Accept(StackTraceNodeVisitor visitor);
}
public static class JetBrains.Util.StandardFolderLocationsStatic : object {
    [NotNullAttribute]
public static FileSystemPath LocalAppdata { get; }
    [NotNullAttribute]
public static FileSystemPath RoamingAppdata { get; }
    [NotNullAttribute]
public static FileSystemPath TempFolder { get; }
    [NotNullAttribute]
public static FileSystemPath TransientAppdata { get; }
    [NotNullAttribute]
public static FileSystemPath TransientAppdataShortened { get; }
    public static FileSystemPath get_LocalAppdata();
    public static FileSystemPath get_RoamingAppdata();
    public static FileSystemPath get_TempFolder();
    public static FileSystemPath get_TransientAppdata();
    public static FileSystemPath get_TransientAppdataShortened();
    [NotNullAttribute]
private static RelativePath GetRelativeHostFolder();
}
public class JetBrains.Util.Statistics : object {
    private static Statistics Empty;
    private static IDictionary`2<string, long> EmptyCounters;
    private static IDictionary`2<string, Func`1<object>> EmptyCalculators;
    private static Dictionary`2<string, TimeSpan> EmptyActivities;
    public IDictionary`2<string, long> Counters { get; }
    public IDictionary`2<string, Func`1<object>> Calculators { get; }
    public Dictionary`2<string, TimeSpan> Activities { get; }
    private static Statistics();
    public IDictionary`2<string, long> get_Counters();
    public IDictionary`2<string, Func`1<object>> get_Calculators();
    public Dictionary`2<string, TimeSpan> get_Activities();
    public IDisposable Suspend();
    [ConditionalAttribute("NEVER")]
public void Resume();
    public static Statistics Allocate(string key);
    public static Statistics Allocate(Type type);
    public static IEnumerable`1<StatisticsNode> Enumerate();
    public static bool HasBreakpoint(string key, string name);
    [ConditionalAttribute("NEVER")]
public static void ToggleBreakpoint(string key, string name);
    [ConditionalAttribute("NEVER")]
public void Calculate(string name, Func`1<object> calculator);
    [ConditionalAttribute("NEVER")]
public void CalculateRatio(string name, string numerator, string denominator);
    public StatisticsActivityCookie Activity(string name);
    [StringFormatMethodAttribute("format")]
[ConditionalAttribute("NEVER")]
public void DecrementFormat(string format, Object[] args);
    [ConditionalAttribute("NEVER")]
public void Decrement(string name);
    [ConditionalAttribute("NEVER")]
public void Decrement(string name, long value);
    [ConditionalAttribute("NEVER")]
public void Increment(string name);
    [ConditionalAttribute("NEVER")]
[StringFormatMethodAttribute("format")]
public void IncrementFormat(string format, Object[] args);
    [ConditionalAttribute("NEVER")]
public void Increment(string name, long value);
    [ConditionalAttribute("NEVER")]
public void Clear();
    [ConditionalAttribute("NEVER")]
public static void ClearAll();
    [ConditionalAttribute("NEVER")]
public void Dump(TextWriter writer);
}
public class JetBrains.Util.StatisticsActivity : StatisticsNode {
    private TimeSpan myTimeSpan;
    public TimeSpan Time { get; }
    public StatisticsActivity(string key, string name, TimeSpan stopwatch);
    public TimeSpan get_Time();
}
public class JetBrains.Util.StatisticsCalculator : StatisticsNode {
    private Func`1<object> myCalculator;
    public object Value { get; }
    public StatisticsCalculator(string key, string name, Func`1<object> calculator);
    public object get_Value();
}
public class JetBrains.Util.StatisticsCounter : StatisticsNode {
    private long myCount;
    public long Count { get; }
    public StatisticsCounter(string key, string name, long value);
    public long get_Count();
}
public class JetBrains.Util.StatisticsGroup : object {
    private string myKey;
    public string Key { get; }
    public RichText ShortName { get; }
    public StatisticsGroup(string key);
    public string get_Key();
    public RichText get_ShortName();
    public bool Equals(StatisticsGroup obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public abstract class JetBrains.Util.StatisticsNode : object {
    private string myKey;
    private string myName;
    public string Key { get; }
    public IEnumerable`1<StatisticsGroup> Groups { get; }
    public string Name { get; }
    protected StatisticsNode(string key, string name);
    public string get_Key();
    public IEnumerable`1<StatisticsGroup> get_Groups();
    public string get_Name();
}
public interface JetBrains.Util.Storage.IInMemoryStream {
    public abstract virtual IntPtr GetBufferFromPosition(long startPosition, SeekOrigin origin, int needBytes, Int32& avalableBytes);
    public abstract virtual IntPtr GetBufferEndAtPosition(long endOffset, SeekOrigin origin, int needBytes, Int32& avalableBytes);
}
public class JetBrains.Util.Storage.MemoryMappedStream.MemoryMappedException : IOException {
    protected MemoryMappedException(SerializationInfo info, StreamingContext context);
    public MemoryMappedException(string moniker);
}
internal static class JetBrains.Util.Storage.MemoryMappedStream.MemoryMappedFilesManager : object {
    private static object LockObject;
    private static IDictionary`2<FileSystemPath, SafeMemoryMappedHandler> FilePathToMemoryHandleDictionary;
    private static IDictionary`2<SafeMemoryMappedHandler, FileSystemPath> MemoryHandleToFilePathDictionary;
    private static IDictionary`2<SafeMemoryMappedHandler, int> MemoryHandleToRefCountDictionary;
    private static IDictionary`2<SafeMemoryMappedHandler, SafeFileHandle> MemoryHandleToFileHandleDictionary;
    private static MemoryMappedFilesManager();
    public static SafeMemoryMappedHandler GetMemoryMapping(FileSystemPath path, FileShare fileShare);
    public static void ReleaseMemoryMapping(SafeMemoryMappedHandler memoryHandle);
}
internal static class JetBrains.Util.Storage.MemoryMappedStream.MemoryMappedWinApi : object {
    [ObsoleteAttribute("Use stuff from Kernel32Dll class.")]
internal static SafeMemoryMappedHandler CreateFileMapping(SafeFileHandle handle, IntPtr lpFileMappingAttributes, FileMapProtection flProtect, UInt32 dwMaximumSizeHigh, UInt32 dwMaximumSizeLow, string lpName);
    [ObsoleteAttribute("Use stuff from Kernel32Dll class.")]
internal static SafeMemoryMappedHandler OpenFileMapping(FileMapAccess dwDesiredAccess, bool bInheritHandle, string lpName);
    [ObsoleteAttribute("Use stuff from Kernel32Dll class.")]
internal static IntPtr MapViewOfFile(SafeMemoryMappedHandler hFileMappingObject, FileMapAccess dwDesiredAccess, UInt32 dwFileOffsetHigh, UInt32 dwFileOffsetLow, UIntPtr dwNumberOfBytesToMap);
    [ObsoleteAttribute("Use stuff from Kernel32Dll class.")]
internal static bool UnmapViewOfFile(IntPtr lpBaseAddress);
}
public class JetBrains.Util.Storage.MemoryMappedStream.ReadonlyMemoryMappedStream : Stream {
    private static byte PageBitSize;
    private static int PageSize;
    private static ulong PageMask;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) myDisposed;
    private long myLength;
    private SafeMemoryMappedHandler myHandle;
    private int myBufferSize;
    private long myPosition;
    private long myBufferStartPosition;
    private IntPtr myBuffer;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public ReadonlyMemoryMappedStream(FileSystemPath path, int pagesInBuffer);
    public ReadonlyMemoryMappedStream(FileSystemPath path, FileShare fileShare, int pagesInBuffer);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual int Read(Byte[] buffer, int offset, int count);
    private IntPtr GetBufferFromCurrentPosition(int needBytes, bool reverse, Int32& size);
    private void ChangeBufferRightAlign();
    private void ChangeBuffer();
    public virtual void Flush();
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void SetLength(long value);
    protected virtual void Dispose(bool disposing);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public sealed virtual IntPtr GetBufferFromPosition(long startPosition, SeekOrigin origin, int needBytes, Int32& avalableBytes);
    public sealed virtual IntPtr GetBufferEndAtPosition(long endOffset, SeekOrigin origin, int needBytes, Int32& avalableBytes);
}
public class JetBrains.Util.Storage.MemoryMappedStream.SafeMemoryMappedHandler : SafeHandleZeroOrMinusOneIsInvalid {
    public SafeMemoryMappedHandler(IntPtr preexistingHandle, bool ownsHandle);
    protected virtual bool ReleaseHandle();
    private static bool CloseHandle(IntPtr hObject);
}
public interface JetBrains.Util.Storage.Packages.IHaveNugetPackageFileItem {
    [NotNullAttribute]
public NugetPackageFileItem Package { get; }
    public abstract virtual NugetPackageFileItem get_Package();
}
public interface JetBrains.Util.Storage.Packages.IJetNugetPackageManager {
    [NotNullAttribute]
public IPackageManager LocalPackageManager { get; }
    [CanBeNullAttribute]
public IPackageManager MaybeLocalPackageManager { get; }
    [CanBeNullAttribute]
public LocalPackageRepository MaybeLocalPackageRepository { get; }
    [NotNullAttribute]
public ISettings Settings { get; }
    [NotNullAttribute]
public PriorityPackageRepository SourcePackageRepository { get; }
    [NotNullAttribute]
public AggregateRepository SourcePackageRepositoryNoCache { get; }
    public abstract virtual IPackageManager get_LocalPackageManager();
    public abstract virtual IPackageManager get_MaybeLocalPackageManager();
    public abstract virtual LocalPackageRepository get_MaybeLocalPackageRepository();
    public abstract virtual ISettings get_Settings();
    public abstract virtual PriorityPackageRepository get_SourcePackageRepository();
    public abstract virtual AggregateRepository get_SourcePackageRepositoryNoCache();
}
public class JetBrains.Util.Storage.Packages.JetNuGetSettings : object {
    private XDocument _config;
    private IFileSystem _fileSystem;
    private string _fileName;
    private JetNuGetSettings _next;
    private int _priority;
    private bool _isMachineWideSettings;
    [CompilerGeneratedAttribute]
private static Func`2<JetNuGetSettings, bool> CS$<>9__CachedAnonymousMethodDelegate6;
    public bool IsMachineWideSettings { get; }
    public string ConfigFilePath { get; }
    public JetNuGetSettings(IFileSystem fileSystem);
    public JetNuGetSettings(IFileSystem fileSystem, string fileName);
    public JetNuGetSettings(IFileSystem fileSystem, string fileName, bool isMachineWideSettings);
    private static XDocument GetOrCreateDocument(XName rootName, IFileSystem fileSystem, string path);
    private static XDocument CreateDocument(XName rootName, IFileSystem fileSystem, string path);
    private static XDocument GetDocument(IFileSystem fileSystem, string path);
    public bool get_IsMachineWideSettings();
    public string get_ConfigFilePath();
    public static ISettings LoadDefaultSettings(IFileSystem fileSystem, string configFileName);
    private static void LoadUserSpecificSettings(List`1<JetNuGetSettings> validSettingFiles, IFileSystem fileSystem, string configFileName);
    public sealed virtual string GetValue(string section, string key, bool isPath);
    private string ApplyEnvironmentTransform(string configValue);
    private static string ResolvePath(string configDirectory, string value);
    private string ElementToValue(XElement element, bool isPath);
    private XElement GetValueInternal(string section, string key, XElement curr);
    public sealed virtual IList`1<SettingValue> GetValues(string section, bool isPath);
    private void PopulateValues(string section, List`1<SettingValue> current, bool isPath);
    public sealed virtual IList`1<SettingValue> GetNestedValues(string section, string subsection);
    private void PopulateNestedValues(string section, string subsection, List`1<SettingValue> current);
    public sealed virtual void SetValue(string section, string key, string value);
    public sealed virtual void SetValues(string section, IList`1<SettingValue> values);
    public sealed virtual void UpdateSections(string section, IList`1<SettingValue> values);
    private static void SetElementValues(XElement element, string key, string value, IDictionary`2<string, string> attributes);
    public sealed virtual void SetNestedValues(string section, string key, IList`1<KeyValuePair`2<string, string>> values);
    private void SetValueInternal(XElement sectionElement, string key, string value, IDictionary`2<string, string> attributes);
    public sealed virtual bool DeleteValue(string section, string key);
    public sealed virtual bool DeleteSection(string section);
    private void ReadSection(XContainer sectionElement, ICollection`1<SettingValue> values, bool isPath);
    private void Save();
    private SettingValue ReadSettingsValue(XElement element, bool isPath);
    private static XElement GetSection(XElement parentElement, string section);
    private static XElement GetOrCreateSection(XElement parentElement, string sectionName);
    private static XElement FindElementByKey(XElement sectionElement, string key, XElement curr);
    private static IEnumerable`1<string> GetSettingsFileNames(IFileSystem fileSystem);
    private static IEnumerable`1<string> GetSettingsFilePaths(IFileSystem fileSystem);
    private static JetNuGetSettings ReadSettings(IFileSystem fileSystem, string settingsPath);
    private static JetNuGetSettings ReadSettings(IFileSystem fileSystem, string settingsPath, bool isMachineWideSettings);
    private void ExecuteSynchronized(Action ioOperation);
    [CompilerGeneratedAttribute]
private static bool <LoadDefaultSettings>b__4(JetNuGetSettings f);
    [CompilerGeneratedAttribute]
private bool <UpdateSections>b__9(SettingValue v);
    [CompilerGeneratedAttribute]
private bool <UpdateSections>b__a(SettingValue v);
    [CompilerGeneratedAttribute]
private void <Save>b__c();
}
public class JetBrains.Util.Storage.Packages.JetPackageManifest : object {
    [NotNullAttribute]
public Manifest RawValue;
    [CompilerGeneratedAttribute]
private static Func`2<Stream, Manifest> CS$<>9__CachedAnonymousMethodDelegate1;
    [CompilerGeneratedAttribute]
private static Func`2<Manifest, JetPackageManifest> CS$<>9__CachedAnonymousMethodDelegate3;
    [NotNullAttribute]
public List`1<ManifestFile> Files { get; }
    [NotNullAttribute]
public ManifestMetadata Metadata { get; }
    public JetPackageManifest(Manifest rawValue);
    public JetPackageManifest(IStructuredStorage sstg);
    public List`1<ManifestFile> get_Files();
    public ManifestMetadata get_Metadata();
    public string GetFullName();
    [NotNullAttribute]
public PackageIdentity GetPackageIdentity();
    public static JetPackageManifest op_Implicit(Manifest manifest);
    private sealed virtual override void JetBrains.Util.Storage.StructuredStorage.IStructuredStorageSerializable.GetObjectData(IStructuredStorage storage);
    [CompilerGeneratedAttribute]
private static Manifest <.ctor>b__0(Stream stream);
    [CompilerGeneratedAttribute]
private static JetPackageManifest <op_Implicit>b__2(Manifest m);
    [CompilerGeneratedAttribute]
private void <JetBrains.Util.Storage.StructuredStorage.IStructuredStorageSerializable.GetObjectData>b__4(Stream stream);
}
[XamlSerializableAttribute]
public class JetBrains.Util.Storage.Packages.JetPackageReference : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDevelopmentDependency>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RawTargetFramework>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RawVersionConstraint>k__BackingField;
    [CompilerGeneratedAttribute]
private SemanticVersion <Version>k__BackingField;
    public string Id { get; public set; }
    public bool IsDevelopmentDependency { get; public set; }
    public string RawTargetFramework { get; public set; }
    public string RawVersionConstraint { get; public set; }
    [DesignerSerializationVisibilityAttribute("0")]
public FrameworkName TargetFramework { get; public set; }
    public SemanticVersion Version { get; public set; }
    [DesignerSerializationVisibilityAttribute("0")]
public IVersionSpec VersionConstraint { get; public set; }
    public JetPackageReference(PackageIdentity target, bool isDevelopmentDependency);
    public JetPackageReference(PackageReference pref);
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
    [CompilerGeneratedAttribute]
public bool get_IsDevelopmentDependency();
    [CompilerGeneratedAttribute]
public void set_IsDevelopmentDependency(bool value);
    [CompilerGeneratedAttribute]
public string get_RawTargetFramework();
    [CompilerGeneratedAttribute]
public void set_RawTargetFramework(string value);
    [CompilerGeneratedAttribute]
public string get_RawVersionConstraint();
    [CompilerGeneratedAttribute]
public void set_RawVersionConstraint(string value);
    public FrameworkName get_TargetFramework();
    public void set_TargetFramework(FrameworkName value);
    [CompilerGeneratedAttribute]
public SemanticVersion get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(SemanticVersion value);
    public IVersionSpec get_VersionConstraint();
    public void set_VersionConstraint(IVersionSpec value);
    public sealed virtual bool Equals(JetPackageReference other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(JetPackageReference left, JetPackageReference right);
    public static JetPackageReference op_Implicit(PackageReference pref);
    public static bool op_Inequality(JetPackageReference left, JetPackageReference right);
    [CanBeNullAttribute]
public PackageIdentity ToExactIdentity(OnError onerror);
    public virtual string ToString();
}
public class JetBrains.Util.Storage.Packages.JetPackageReferenceAdvancedComparer : object {
    private Equalities myEqualities;
    public JetPackageReferenceAdvancedComparer(Equalities equalities);
    public sealed virtual bool Equals(JetPackageReference x, JetPackageReference y);
    public sealed virtual int GetHashCode(JetPackageReference obj);
}
public class JetBrains.Util.Storage.Packages.JetPackageRepositoryFactory : PackageRepositoryFactory {
    public static IPackageRepositoryFactory Default;
    private static JetPackageRepositoryFactory();
    public virtual IPackageRepository CreateRepository(string packageSource);
}
public class JetBrains.Util.Storage.Packages.JetPathFileSystem : object {
    private ILogger _logger;
    private FileSystemPath _root;
    [CompilerGeneratedAttribute]
private static Func`2<IPackageFile, RelativePath> CS$<>9__CachedAnonymousMethodDelegate13;
    [CompilerGeneratedAttribute]
private static Func`2<IGrouping`2<RelativePath, IPackageFile>, IEnumerable`1<RelativePath>> CS$<>9__CachedAnonymousMethodDelegate14;
    [CompilerGeneratedAttribute]
private static Func`3<IGrouping`2<RelativePath, IPackageFile>, RelativePath, <>f__AnonymousType58`2<IGrouping`2<RelativePath, IPackageFile>, RelativePath>> CS$<>9__CachedAnonymousMethodDelegate15;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType58`2<IGrouping`2<RelativePath, IPackageFile>, RelativePath>, int> CS$<>9__CachedAnonymousMethodDelegate16;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType58`2<IGrouping`2<RelativePath, IPackageFile>, RelativePath>, RelativePath> CS$<>9__CachedAnonymousMethodDelegate17;
    public string Root { get; }
    public ILogger Logger { get; public set; }
    public JetPathFileSystem(FileSystemPath root);
    public sealed virtual string get_Root();
    public sealed virtual ILogger get_Logger();
    public sealed virtual void set_Logger(ILogger value);
    private sealed virtual override string NuGet.IFileSystem.GetFullPath(string path);
    public virtual FileSystemPath GetFullPath(string path);
    public virtual void AddFile(string path, Stream stream);
    public virtual void AddFile(string path, Action`1<Stream> writeToStream);
    public virtual void AddFiles(IEnumerable`1<IPackageFile> files, string rootDir);
    private void AddFileCore(string path, Action`1<Stream> writeToStream);
    private void WriteAddedFileAndDirectory(FileSystemPath path);
    public virtual void DeleteFile(string path);
    private static IEnumerable`1<RelativePath> GetParentComponents(RelativePath path);
    private static void DoSafeAction(Action action, ILogger logger);
    private static void Attempt(Action action, int retries, int delayBeforeRetry);
    private static IEnumerable`1<string> GetDirectoriesSafe(IFileSystem fileSystem, string path);
    private static IEnumerable`1<string> GetFilesSafe(IFileSystem fileSystem, string path, string filter);
    private static void DeleteDirectorySafe(IFileSystem fileSystem, string path, bool recursive);
    private static void DeleteFileSafe(IFileSystem fileSystem, string path);
    private static void DeleteFiles(IFileSystem fileSystem, IEnumerable`1<IPackageFile> files, FileSystemPath rootDir);
    public virtual void DeleteFiles(IEnumerable`1<IPackageFile> files, string rootDir);
    public virtual void DeleteDirectory(string path);
    public virtual void DeleteDirectory(string path, bool recursive);
    public virtual IEnumerable`1<string> GetFiles(string path, bool recursive);
    public virtual IEnumerable`1<string> GetFiles(string path, string filter, bool recursive);
    public virtual IEnumerable`1<string> GetFiles(FileSystemPath path, string filter, bool recursive);
    public virtual IEnumerable`1<string> GetDirectories(string path);
    public virtual IEnumerable`1<string> GetDirectories(FileSystemPath path);
    public virtual DateTimeOffset GetLastModified(string path);
    public sealed virtual DateTimeOffset GetCreated(string path);
    public sealed virtual DateTimeOffset GetLastAccessed(string path);
    public virtual bool FileExists(string path);
    public virtual bool DirectoryExists(string path);
    public virtual Stream OpenFile(string path);
    public virtual Stream CreateFile(string path);
    protected RelativePath MakeRelativePath(FileSystemPath fullPath);
    protected virtual void EnsureDirectory(FileSystemPath filePath);
    public sealed virtual void MakeFileWritable(string path);
    public virtual void MoveFile(string source, string destination);
    [CompilerGeneratedAttribute]
private static RelativePath <DeleteFiles>b__d(IPackageFile p);
    [CompilerGeneratedAttribute]
private static IEnumerable`1<RelativePath> <DeleteFiles>b__e(IGrouping`2<RelativePath, IPackageFile> grouping);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType58`2<IGrouping`2<RelativePath, IPackageFile>, RelativePath> <DeleteFiles>b__f(IGrouping`2<RelativePath, IPackageFile> grouping, RelativePath directory);
    [CompilerGeneratedAttribute]
private static int <DeleteFiles>b__10(<>f__AnonymousType58`2<IGrouping`2<RelativePath, IPackageFile>, RelativePath> <>h__TransparentIdentifierc);
    [CompilerGeneratedAttribute]
private static RelativePath <DeleteFiles>b__11(<>f__AnonymousType58`2<IGrouping`2<RelativePath, IPackageFile>, RelativePath> <>h__TransparentIdentifierc);
    [CompilerGeneratedAttribute]
private string <GetFiles>b__1b(FileSystemPath _);
    [CompilerGeneratedAttribute]
private string <GetDirectories>b__1d(FileSystemPath _);
}
public class JetBrains.Util.Storage.Packages.LocalPackagesMeta : object {
    public static UInt32 CurrentVersionIndex;
    public static string PackagesMetadataFileName;
    public static string SinglePackageMetadataFileName;
    public IDictionary`2<PkgIdString, PackageRecord> Records;
    [CompilerGeneratedAttribute]
private static Func`2<PackageRecord, string> CS$<>9__CachedAnonymousMethodDelegate6;
    [CompilerGeneratedAttribute]
private static Func`2<PackageRecord, string> CS$<>9__CachedAnonymousMethodDelegate7;
    private LocalPackagesMeta(IDictionary`2<PkgIdString, PackageRecord> records);
    private static LocalPackagesMeta();
    public static LocalPackagesMeta Load(Stream stream);
    [NotNullAttribute]
public static LocalPackagesMeta OpenInFolder(Lifetime lifetime, FileSystemPath dirPackages);
    public void Save(Stream stream);
    [CompilerGeneratedAttribute]
private static string <Save>b__4(PackageRecord rec);
    [CompilerGeneratedAttribute]
private static string <Save>b__5(PackageRecord rec);
}
public class JetBrains.Util.Storage.Packages.LocalRestoreNugetPackagesCentralCache : object {
    private static string CacheDirName;
    private static FileSystemPath DefaultCacheDir;
    [CanBeNullAttribute]
public FileSystemPath CacheDirectory;
    private LocalRestoreNugetPackagesCentralCache(FileSystemPath cacheDirectory);
    private static LocalRestoreNugetPackagesCentralCache();
    [NotNullAttribute]
public static LocalRestoreNugetPackagesCentralCache Create(FileSystemPath cacheDirectory);
    [NotNullAttribute]
public static LocalRestoreNugetPackagesCentralCache CreateIfSupported(FileSystemPath pathCache);
    [NotNullAttribute]
public static LocalRestoreNugetPackagesCentralCache CreateInLocalAppDataIfSupported();
    public virtual string ToString();
}
public class JetBrains.Util.Storage.Packages.LocalRestoreNugetPackagesSession : object {
    private static TimeSpan BacklogAgeLimit;
    public static string EnvironmentVariableNameForNoNugetValidation;
    public static double OptionNugetExpandedFilesCompressionRatioThreshold;
    public static RelativePath PackagesBacklogFolder;
    private ILogger Logger;
    private FileSystemPath myBacklogPackagesDir;
    private FileSystemPath myCentralCacheDirectory;
    private IDictionary`2<string, RestoredPackage> myFolderLocalNames;
    private LocalPackagesMeta myMetadata;
    public static int IsEnvironmentVariableForNoNugetValidation;
    public bool IsNoAutoBacklogOnClose;
    [NotNullAttribute]
public FileSystemPath PackagesDir;
    [CompilerGeneratedAttribute]
private static Func`2<RestoredPackage, bool> CS$<>9__CachedAnonymousMethodDelegate5;
    [CompilerGeneratedAttribute]
private static Func`2<DirectoryEntryData, RelativePath> CS$<>9__CachedAnonymousMethodDelegate17;
    [CompilerGeneratedAttribute]
private static Func`2<DirectoryEntryData, DirectoryEntryData> CS$<>9__CachedAnonymousMethodDelegate18;
    [CompilerGeneratedAttribute]
private static Func`2<DirectoryEntryData, bool> CS$<>9__CachedAnonymousMethodDelegate19;
    [CompilerGeneratedAttribute]
private static Func`2<DirectoryEntryData, bool> CS$<>9__CachedAnonymousMethodDelegate1a;
    [CompilerGeneratedAttribute]
private static Func`2<FileSystemPath, bool> CS$<>9__CachedAnonymousMethodDelegate20;
    [CompilerGeneratedAttribute]
private static Func`2<DirectoryEntryData, bool> CS$<>9__CachedAnonymousMethodDelegate25;
    public LocalRestoreNugetPackagesSession(Lifetime lifetime, FileSystemPath dirPackages, LocalRestoreNugetPackagesCentralCache centralcache);
    private static LocalRestoreNugetPackagesSession();
    public void BacklogUnusedPackages();
    public RestoredPackage LocalRestore(NugetPackageFileItem package, OnError onerror);
    public static bool ValidateExpandedPackage(FileSystemPath dirExpanded, NugetPackageFileItem pkg, LocalPackagesMeta meta, ValidationScope scope, ILogger logger);
    private void CleanupBacklogOrCache(FileSystemPath dirToCleanup);
    private static void ExpandCore(FileSystemPath dirExpanded, NugetPackageFileItem pkg, LocalPackagesMeta meta, FileSystemPath centralcache, ILogger logger);
    private static void ExpandCore_FixFileMode(FileSystemPath file, ILogger logger);
    private static bool ExpandCore_IsCompress(NugetPackageFileItem pkg, ILogger logger);
    private void MoveExtraPackagesToBacklog();
    [CanBeNullAttribute]
private static PackageRecord TryGetMetadataRecordForPackage(NugetPackageFileItem pkgid, FileSystemPath dirExpanded, LocalPackagesMeta meta);
    [CompilerGeneratedAttribute]
private void <.ctor>b__0();
    [CompilerGeneratedAttribute]
private void <.ctor>b__2();
    [CompilerGeneratedAttribute]
private static bool <.ctor>b__1(RestoredPackage rest);
    [CompilerGeneratedAttribute]
private static RelativePath <ValidateExpandedPackage>b__12(DirectoryEntryData ded);
    [CompilerGeneratedAttribute]
private static DirectoryEntryData <ValidateExpandedPackage>b__13(DirectoryEntryData ded);
    [CompilerGeneratedAttribute]
private static bool <ValidateExpandedPackage>b__15(DirectoryEntryData data);
    [CompilerGeneratedAttribute]
private static bool <ValidateExpandedPackage>b__16(DirectoryEntryData data);
    [CompilerGeneratedAttribute]
private static bool <CleanupBacklogOrCache>b__1f(FileSystemPath path);
    [CompilerGeneratedAttribute]
private static bool <ExpandCore>b__21(DirectoryEntryData ded);
}
[ExtensionAttribute]
public static class JetBrains.Util.Storage.Packages.NugetHelpers : object {
    public static ILogger Logger;
    public static Lazy`1<NuGetLogger> NugetLogger;
    public static string ProgramDatabasePackageIdAppendix;
    [CompilerGeneratedAttribute]
private static Action`1<AggregateRepository> CS$<>9__CachedAnonymousMethodDelegate1;
    [CompilerGeneratedAttribute]
private static Func`2<PackageDependencySet, NuGetFramework> CS$<>9__CachedAnonymousMethodDelegatee;
    [CompilerGeneratedAttribute]
private static Action CS$<>9__CachedAnonymousMethodDelegate17;
    [CompilerGeneratedAttribute]
private static Func`2<IPackageFile, Uri> CS$<>9__CachedAnonymousMethodDelegate22;
    [CompilerGeneratedAttribute]
private static Func`2<IGrouping`2<Uri, IPackageFile>, bool> CS$<>9__CachedAnonymousMethodDelegate23;
    [CompilerGeneratedAttribute]
private static Func`2<PackageSource, PackageServer> CS$<>9__CachedAnonymousMethodDelegate2f;
    [CompilerGeneratedAttribute]
private static Func`2<ManifestDependencySet, IEnumerable`1<ManifestDependency>> CS$<>9__CachedAnonymousMethodDelegate36;
    [CompilerGeneratedAttribute]
private static Func`1<NuGetLogger> CS$<>9__CachedAnonymousMethodDelegate3b;
    private static NugetHelpers();
    [NotNullAttribute]
[ExtensionAttribute]
public static Uri CreateOpcPartUri(RelativePath path);
    [ExtensionAttribute]
public static void CreatePackageManager(ISettings settings, PackageManager& packman, PriorityPackageRepository& repositorySource, LocalPackageRepository& repositoryLocal);
    [ExtensionAttribute]
[NotNullAttribute]
public static PriorityPackageRepository CreateSourceRepository(ISettings settings);
    [NotNullAttribute]
[ExtensionAttribute]
public static AggregateRepository CreateSourceRepositoryNoMachineCache(ISettings settings);
    public static IPackage FindNugetPackage(string packageId, SemanticVersion version, IPackageManager packman);
    [NotNullAttribute]
public static TPackage FindPackage(IEnumerable`1<TPackage> packages, string idPackage);
    [NotNullAttribute]
public static IList`1<TPackage> FindPackageAndItsReferences(IEnumerable`1<TPackage> packages, string idPackage, OnError onError);
    [NotNullAttribute]
public static IList`1<TPackage> FindPackages(IEnumerable`1<TPackage> packages, IEnumerable`1<string> idsPackage);
    [NotNullAttribute]
public static IList`1<TPackage> FindPackagesCore(IEnumerable`1<TPackage> packages, IEnumerable`1<string> idsPackage, bool isTraversingReferences, Predicate`1<string> DependecyPredicate, OnError onError);
    public static NuGetFramework ToNuGetFramework(FrameworkName frameworkName);
    public static FrugalLocalList`1<PackageDependencySet> FilterDependencySets(IEnumerable`1<PackageDependencySet> depsetsAll);
    [NotNullAttribute]
public static ICollection`1<TPackage> FindPackagesWithSymbols(ICollection`1<TPackage> packagesWithBinaries, IEnumerable`1<TPackage> allpackages);
    [NotNullAttribute]
[ExtensionAttribute]
public static string GetFullName(IHaveNugetPackageFileItem ths);
    [NotNullAttribute]
[ExtensionAttribute]
public static string GetId(IHaveNugetPackageFileItem ths);
    [ExtensionAttribute]
[NotNullAttribute]
public static RelativePath GetExpandedPackageDirectoryName(IHaveNugetPackageFileItem ths);
    [ExtensionAttribute]
[NotNullAttribute]
public static RelativePath GetExpandedPackageDirectoryName(IPackageName pkgname);
    [ExtensionAttribute]
[NotNullAttribute]
public static PackageIdentity GetIdentity(NugetPackageFileItem pkg);
    [NotNullAttribute]
[ExtensionAttribute]
public static PackageIdentity GetIdentity(IHaveNugetPackageFileItem pkg);
    [NotNullAttribute]
[ExtensionAttribute]
public static RelativePath GetJetOrNugetEffectivePath(IPackageFile ths);
    public static ISettings GetNugetSettingsFromDirectory(FileSystemPath dir);
    public static ISettings GetNugetSettingsFromFileSystem(IFileSystem fileSystem);
    [ExtensionAttribute]
[NotNullAttribute]
public static string GetPackageFileName(IHaveNugetPackageFileItem pkg);
    [NotNullAttribute]
[ExtensionAttribute]
public static string GetPackageFileName(IPackageName name);
    [ExtensionAttribute]
[NotNullAttribute]
public static PackageIdentity GetPackageIdentity(IHaveNugetPackageFileItem ths);
    [NotNullAttribute]
[ExtensionAttribute]
public static IPackageName GetPackageName(IHaveNugetPackageFileItem ths);
    [ExtensionAttribute]
[NotNullAttribute]
public static JetSemanticVersion GetVersion(IHaveNugetPackageFileItem ths);
    public static bool MightHaveDependencyOn(SimpleFileItem fiNuget, string pkgid);
    public static NugetPackageFileItem RetrievePackageCore(Func`2<bool, IPackage> RetrieveCoreCachedOrNot, object pkgidForDiagnostyx, OnError onerror);
    private static void RetrievePackageCore_AddToMachineCache(IPackage package);
    [ExtensionAttribute]
[NotNullAttribute]
public static IPackageBuilder SanitizePackageBuilder(IPackageBuilder builder);
    [ExtensionAttribute]
[NotNullAttribute]
public static SimpleFileItem ToFileItem(IPackageFile ths);
    [ExtensionAttribute]
[ContractAnnotationAttribute("ths:null => null; notnull => notnull")]
public static JetSemanticVersion ToJetSemanticVersion(SemanticVersion ths);
    [ExtensionAttribute]
[ContractAnnotationAttribute("ths:null => null; notnull => notnull")]
public static SemanticVersion ToNuSemanticVersion(JetSemanticVersion ths);
    [CanBeNullAttribute]
[ExtensionAttribute]
public static RelativePath TryGetJetEffectivePath(IPackageFile ths);
    [NotNullAttribute]
[ExtensionAttribute]
public static IEnumerable`1<PackageServer> GetPackageServers(IJetNugetPackageManager ths);
    [ItemNotNullAttribute]
[ExtensionAttribute]
[DebuggerStepThroughAttribute]
[AsyncStateMachineAttribute("JetBrains.Util.Storage.Packages.NugetHelpers/<RetrievePackageExactAsync>d__30")]
public static Task`1<NugetPackageFileItem> RetrievePackageExactAsync(IJetNugetPackageManager ths, PackageIdentity pkgid, OnError onerror);
    [ExtensionAttribute]
public static NugetPackageFileItem RetrievePackageExact(IJetNugetPackageManager ths, PackageIdentity pkgid, OnError onerror);
    [ExtensionAttribute]
[NotNullAttribute]
public static ICollection`1<NugetPackageFileItem> RetrievePackageExactDeep(IJetNugetPackageManager ths, PackageIdentity pkgid, OnError onerror);
    public static void RetrievePackageExactDeep(IJetNugetPackageManager ths, PackageIdentity pkgid, IDictionary`2<PackageIdentity, NugetPackageFileItem> output, OnError onerror);
    [ExtensionAttribute]
public static NugetPackageFileItem RetrievePackageNewest(IJetNugetPackageManager ths, string id, OnError onerror);
    [CompilerGeneratedAttribute]
private static void <CreateSourceRepositoryNoMachineCache>b__0(AggregateRepository repo);
    [CompilerGeneratedAttribute]
private static string <FindPackagesCore>b__5(TPackage pkg);
    [CompilerGeneratedAttribute]
private static string <FindPackagesCore>b__8(TPackage pkg);
    [CompilerGeneratedAttribute]
private static string <FindPackagesCore>b__9(TPackage pkg);
    [CompilerGeneratedAttribute]
private static NuGetFramework <FilterDependencySets>b__d(PackageDependencySet set);
    [CompilerGeneratedAttribute]
private static string <FindPackagesWithSymbols>b__f(TPackage pkg);
    [CompilerGeneratedAttribute]
private static void <RetrievePackageCore>b__16();
    [CompilerGeneratedAttribute]
private static Uri <SanitizePackageBuilder>b__1d(IPackageFile file);
    [CompilerGeneratedAttribute]
private static bool <SanitizePackageBuilder>b__1e(IGrouping`2<Uri, IPackageFile> g);
    [CompilerGeneratedAttribute]
private static PackageServer <GetPackageServers>b__2e(PackageSource src);
    [CompilerGeneratedAttribute]
private static IEnumerable`1<ManifestDependency> <RetrievePackageExactDeep>b__35(ManifestDependencySet ds);
    [CompilerGeneratedAttribute]
private static NuGetLogger <.cctor>b__3a();
}
public class JetBrains.Util.Storage.Packages.NuGetLogger : object {
    private ILogger myLogger;
    private string myName;
    public NuGetLogger(ILogger logger, Type caller);
    public NuGetLogger(ILogger logger, string name);
    public sealed virtual void Log(MessageLevel level, string message, Object[] args);
    public sealed virtual FileConflictResolution ResolveFileConflict(string message);
}
[MemberwiseSerializableAttribute]
public class JetBrains.Util.Storage.Packages.NugetPackageFileItem : object {
    [NotNullAttribute]
public SimpleFileItem File;
    [NotNullAttribute]
public JetPackageManifest Manifest;
    private NugetPackageFileItem JetBrains.Util.Storage.Packages.IHaveNugetPackageFileItem.Package { get; }
    public NugetPackageFileItem(JetPackageManifest manifest, SimpleFileItem file);
    public NugetPackageFileItem(SimpleFileItem file);
    public NugetPackageFileItem(IPackage package);
    public NugetPackageFileItem(IPackageBuilder builder);
    public sealed virtual bool Equals(NugetPackageFileItem other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [NotNullAttribute]
public IPackage Load();
    public static bool op_Equality(NugetPackageFileItem left, NugetPackageFileItem right);
    public static bool op_Inequality(NugetPackageFileItem left, NugetPackageFileItem right);
    public virtual string ToString();
    private sealed virtual override int System.IComparable<JetBrains.Util.Storage.Packages.NugetPackageFileItem>.CompareTo(NugetPackageFileItem other);
    private sealed virtual override NugetPackageFileItem JetBrains.Util.Storage.Packages.IHaveNugetPackageFileItem.get_Package();
}
[ExtensionAttribute]
public static class JetBrains.Util.Storage.Packages.NugetPackageIntrospection : object {
    private static ILogger Logger;
    private static OnError OnErrorLogger;
    [CompilerGeneratedAttribute]
private static Func`2<IList`1<NugetEntry>, List`1<SimpleFileItem>> CS$<>9__CachedAnonymousMethodDelegate2;
    private static NugetPackageIntrospection();
    public static TReturn EnumNugetEntriesDirectory(SimpleFileItem fiNugetPackage, FilterFlags flags, NugetTargetFramework targetfx, Func`2<NugetPartPaths, bool> Filter, Func`2<IList`1<NugetEntry>, TReturn> Entries);
    public static void EnumNugetEntriesStream(SimpleFileItem fiNugetPackage, FilterFlags flags, Action`2<NugetPartPaths, Stream> Entry, Func`2<NugetPartPaths, bool> Filter);
    [NotNullAttribute]
public static ICollection`1<SimpleFileItem> GetJetContentFileItemsFast(SimpleFileItem fiNugetPackage, Func`2<NugetPartPaths, bool> Filter, NugetTargetFramework targetfx);
    [NotNullAttribute]
[ExtensionAttribute]
public static ICollection`1<SimpleFileItem> GetJetContentFileItemsFast(IHaveNugetPackageFileItem nupkg, Func`2<NugetPartPaths, bool> Filter, NugetTargetFramework targetfx);
    [ExtensionAttribute]
[NotNullAttribute]
public static Byte[] GetNameBytes(ZipEntry entry);
    public static string GetNugetManifestPartName(ZipFile zipfile, object oPackageNameForContext, OnError onerror);
    public static Manifest GetPackageManifestFast(SimpleFileItem fiNuget);
    public static Manifest GetPackageManifestFast_SystemPackaging(SimpleFileItem fiNuget);
    public static Manifest GetPackageManifestFast_Zip(SimpleFileItem fiNuget);
    private static void EnumNugetEntriesDirectory_FillOpcItems(SimpleFileItem fiNugetPackage, FilterFlags flags, Func`2<NugetPartPaths, bool> Filter, ZipFile zipfile, bool isSkipNonContent, IList`1<NugetEntry> callitems);
    private static void EnumNugetEntriesDirectory_FilterByTargetFx(FrameworkName targetfx, List`1<NugetEntry> callitems);
    [CompilerGeneratedAttribute]
private static List`1<SimpleFileItem> <GetJetContentFileItemsFast>b__1(IList`1<NugetEntry> entries);
}
public class JetBrains.Util.Storage.Packages.NugetPartPaths : ValueType {
    public RelativePath EffectivePathJet;
    public RelativePath PartPath;
    public virtual string ToString();
}
public class JetBrains.Util.Storage.Packages.NugetTargetFramework : ValueType {
    public static NugetTargetFramework DontFilter;
    public static NugetTargetFramework ToolsetDefault;
    private bool myIsDontFilter;
    [CanBeNullAttribute]
private FrameworkName myTargetfx;
    public bool IsFiltering { get; }
    private NugetTargetFramework(bool isDontFilter, FrameworkName targetfx);
    private static NugetTargetFramework();
    public bool get_IsFiltering();
    public static NugetTargetFramework Custom(FrameworkName targetfx);
    [NotNullAttribute]
[PureAttribute]
public FrameworkName GetTargetFrameworkName();
}
[TypeConverterAttribute("JetBrains.Util.Storage.Packages.PackageIdentity/PackageIdentityConverter")]
[ValueSerializerAttribute("JetBrains.Util.Storage.Packages.PackageIdentity/PackageIdentitySerializer")]
public class JetBrains.Util.Storage.Packages.PackageIdentity : object {
    public static Regex RegexPackageNameAndSemanticVersion;
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private SemanticVersion <Version>k__BackingField;
    [NotNullAttribute]
public string Id { get; private set; }
    [NotNullAttribute]
public SemanticVersion Version { get; private set; }
    public PackageIdentity(NugetPackageFileItem item);
    public PackageIdentity(IPackageName name);
    public PackageIdentity(string id, SemanticVersion version);
    public PackageIdentity(string id, JetSemanticVersion version);
    private static PackageIdentity();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Id();
    [CompilerGeneratedAttribute]
private void set_Id(string value);
    [CompilerGeneratedAttribute]
public sealed virtual SemanticVersion get_Version();
    [CompilerGeneratedAttribute]
private void set_Version(SemanticVersion value);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(PackageIdentity other);
    public virtual int GetHashCode();
    public static bool op_Equality(PackageIdentity left, PackageIdentity right);
    public static bool op_Inequality(PackageIdentity left, PackageIdentity right);
    [NotNullAttribute]
public static PackageIdentity Parse(string text);
    public virtual string ToString();
    [CanBeNullAttribute]
public static PackageIdentity TryParse(string text);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    private sealed virtual override int System.IComparable<JetBrains.Util.Storage.Packages.PackageIdentity>.CompareTo(PackageIdentity other);
}
public static class JetBrains.Util.Storage.Packages.SubplatformPackageLayoutConstants : object {
    public static string JetBrainsContentFilesFolder;
    [NotNullAttribute]
public static string JetMetadataInApplicationPackageExt;
    public static string NugetLibFolder;
    public static string PackageEmptyFileName;
    public static string SubplatformPlatformCoreShellPackageId;
    private static SubplatformPackageLayoutConstants();
    public static bool IsPackageFileEffectivePathSuitableForManagedReference(RelativePath pathEffective);
    [CanBeNullAttribute]
public static RelativePath TryGetJetEffectivePath(RelativePath relOpcPartPath);
}
public static class JetBrains.Util.Storage.Packages.TargetFrameworkFilter : object {
    public static TReturn EnumNugetEntriesDirectoryFilteredByTargetFramework(SimpleFileItem fiNugetPackage, Func`2<NugetPartPaths, bool> Filter, FrameworkName targetFramework, Func`2<IList`1<NugetEntry>, TReturn> Entries, Nullable`1<FilterFlags> flags);
}
public class JetBrains.Util.Storage.SimpleFileItem : object {
    private static ILogger Logger;
    private static string myNameFileContent;
    private static string myNameRelPath;
    private Byte[] myContentHash;
    [NotNullAttribute]
private ChunkedMemoryStream myFileContent;
    [NotNullAttribute]
private RelativePath myRelativePath;
    [CompilerGeneratedAttribute]
private static Func`2<Stream, ChunkedMemoryStream> CS$<>9__CachedAnonymousMethodDelegate1;
    public Byte[] ContentHash { get; }
    [NotNullAttribute]
public ChunkedMemoryStream FileContent { get; }
    [NotNullAttribute]
public RelativePath RelativePath { get; }
    private int ContentHashAsInt { get; }
    public SimpleFileItem(RelativePath relativePath, ChunkedMemoryStream fileContent);
    public SimpleFileItem(SimpleFileItem sample);
    public SimpleFileItem(IStructuredStorage sstg);
    private static SimpleFileItem();
    public Byte[] get_ContentHash();
    public ChunkedMemoryStream get_FileContent();
    public RelativePath get_RelativePath();
    [NotNullAttribute]
public SimpleFileItem AsAnotherPath(RelativePath relNew);
    [NotNullAttribute]
public SimpleFileItem AsAnotherPath(Func`2<RelativePath, RelativePath> ChangePath);
    public static Byte[] ComputeHash(Stream stream);
    [NotNullAttribute]
public static SimpleFileItem CreateFromDisk(FileSystemPath path);
    [ObsoleteAttribute("Use SimpleFileItem::CreateFromDisk(fullpath).AsAnotherPath(relpath).")]
[NotNullAttribute]
public static SimpleFileItem CreateFromDisk(FileSystemPath path, RelativePath overrideRelativePath);
    [NotNullAttribute]
public static SimpleFileItem CreateFromStream(RelativePath relativePath, Action`1<Stream> WriteStream);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(SimpleFileItem other);
    public virtual int GetHashCode();
    public static bool op_Equality(SimpleFileItem left, SimpleFileItem right);
    public static bool op_Inequality(SimpleFileItem left, SimpleFileItem right);
    public virtual string ToString();
    private sealed virtual override int System.IComparable<JetBrains.Util.Storage.SimpleFileItem>.CompareTo(SimpleFileItem other);
    private int get_ContentHashAsInt();
    private sealed virtual override void JetBrains.Util.Storage.StructuredStorage.IStructuredStorageSerializable.GetObjectData(IStructuredStorage sstg);
    [CompilerGeneratedAttribute]
private static ChunkedMemoryStream <.ctor>b__0(Stream stream);
}
[ExtensionAttribute]
public static class JetBrains.Util.Storage.SimpleFileItemEx : object {
    private static ILogger Logger;
    [CompilerGeneratedAttribute]
private static Func`2<Stream, Byte[]> CS$<>9__CachedAnonymousMethodDelegate7;
    private static SimpleFileItemEx();
    [NotNullAttribute]
[ExtensionAttribute]
public static FileSystemPath RealizeOnDisk(SimpleFileItem ths, Lifetime lifetimeFileAvailability, IWorkingDirectory workdir);
    [ObsoleteAttribute("Use WriteToDirectoryIfDirtyWithMoveAside.")]
[ExtensionAttribute]
public static void WriteIfDirty(SimpleFileItem fi, FileSystemPath directory, ILogger logger);
    [NotNullAttribute]
[ExtensionAttribute]
public static FileSystemPath WriteToDirectoryIfDirtyWithMoveAside(SimpleFileItem fi, FileSystemPath directory, ILogger logger, FileCheck check);
    [CompilerGeneratedAttribute]
private static Byte[] <WriteToDirectoryIfDirtyWithMoveAside>b__5(Stream stream);
}
public class JetBrains.Util.Storage.SimpleFileItemPackageFile : object {
    public SimpleFileItem FileItem;
    private string NuGet.IPackageFile.EffectivePath { get; }
    private string NuGet.IPackageFile.Path { get; }
    private IEnumerable`1<FrameworkName> NuGet.IFrameworkTargetable.SupportedFrameworks { get; }
    private FrameworkName NuGet.IPackageFile.TargetFramework { get; }
    public SimpleFileItemPackageFile(SimpleFileItem file);
    public virtual string ToString();
    private sealed virtual override string NuGet.IPackageFile.get_EffectivePath();
    private sealed virtual override Stream NuGet.IPackageFile.GetStream();
    private sealed virtual override string NuGet.IPackageFile.get_Path();
    private sealed virtual override IEnumerable`1<FrameworkName> NuGet.IFrameworkTargetable.get_SupportedFrameworks();
    private sealed virtual override FrameworkName NuGet.IPackageFile.get_TargetFramework();
}
public class JetBrains.Util.Storage.StructuredStorage.AnonymousStructuredStorageCollection`1 : object {
    private Func`1<Nullable`1<int>> myFCount;
    private Func`2<string, TItem> myFCreate;
    private Func`1<IEnumerable`1<TItem>> myFEnum;
    private Func`2<TItem, bool> myFRemove;
    [NotNullAttribute]
private Func`2<string, TItem> myFTryGet;
    private TItem JetBrains.Util.Storage.StructuredStorage.IStructuredStorageCollection<TItem>.Item { get; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<TItem>.IsReadOnly { get; }
    public AnonymousStructuredStorageCollection`1(Func`1<IEnumerable`1<TItem>> FEnum, Func`1<Nullable`1<int>> FCount, Func`2<TItem, bool> FRemove, Func`2<string, TItem> FCreate, Func`2<string, TItem> FTryGet);
    private sealed virtual override TItem JetBrains.Util.Storage.StructuredStorage.IStructuredStorageCollection<TItem>.get_Item(string name);
    private sealed virtual override void System.Collections.Generic.ICollection<TItem>.Add(TItem item);
    private sealed virtual override void System.Collections.Generic.ICollection<TItem>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<TItem>.Contains(TItem item);
    private sealed virtual override void System.Collections.Generic.ICollection<TItem>.CopyTo(TItem[] array, int arrayIndex);
    private sealed virtual override TItem JetBrains.Util.Storage.StructuredStorage.IStructuredStorageCollection<TItem>.Create(string name);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IEnumerator`1<TItem> System.Collections.Generic.IEnumerable<TItem>.GetEnumerator();
    private sealed virtual override bool System.Collections.Generic.ICollection<TItem>.Remove(TItem item);
    private sealed virtual override TItem JetBrains.Util.Storage.StructuredStorage.IStructuredStorageCollection<TItem>.TryGetItem(string name);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<TItem>.get_IsReadOnly();
}
public class JetBrains.Util.Storage.StructuredStorage.AnonymousStructuredStorageCollectionClosureFree`2 : object {
    private TCtx myCtx;
    private Func`2<TCtx, Nullable`1<int>> myFCount;
    private Func`3<TCtx, string, TItem> myFCreate;
    private Func`2<TCtx, IEnumerable`1<TItem>> myFEnum;
    private Func`3<TCtx, TItem, bool> myFRemove;
    [CanBeNullAttribute]
private Func`3<TCtx, string, TItem> myFTryGet;
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<TItem>.IsReadOnly { get; }
    private TItem JetBrains.Util.Storage.StructuredStorage.IStructuredStorageCollection<TItem>.Item { get; }
    public AnonymousStructuredStorageCollectionClosureFree`2(TCtx ctx, Func`2<TCtx, IEnumerable`1<TItem>> FEnum, Func`2<TCtx, Nullable`1<int>> FCount, Func`3<TCtx, TItem, bool> FRemove, Func`3<TCtx, string, TItem> FCreate, Func`3<TCtx, string, TItem> FTryGet);
    private sealed virtual override void System.Collections.Generic.ICollection<TItem>.Add(TItem item);
    private sealed virtual override void System.Collections.Generic.ICollection<TItem>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<TItem>.Contains(TItem item);
    private sealed virtual override void System.Collections.Generic.ICollection<TItem>.CopyTo(TItem[] array, int arrayIndex);
    public sealed virtual int get_Count();
    private sealed virtual override TItem JetBrains.Util.Storage.StructuredStorage.IStructuredStorageCollection<TItem>.Create(string name);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IEnumerator`1<TItem> System.Collections.Generic.IEnumerable<TItem>.GetEnumerator();
    private sealed virtual override bool System.Collections.Generic.ICollection<TItem>.get_IsReadOnly();
    private sealed virtual override TItem JetBrains.Util.Storage.StructuredStorage.IStructuredStorageCollection<TItem>.get_Item(string name);
    private sealed virtual override bool System.Collections.Generic.ICollection<TItem>.Remove(TItem item);
    private sealed virtual override TItem JetBrains.Util.Storage.StructuredStorage.IStructuredStorageCollection<TItem>.TryGetItem(string name);
    private TItem TryGetItemCore(string name);
}
public class JetBrains.Util.Storage.StructuredStorage.AnonymousStructuredStorageStream : object {
    private Func`3<Lifetime, StreamOpenFlags, Stream> myFOpen;
    private string myName;
    private string JetBrains.Util.Storage.StructuredStorage.INamedItem.Name { get; }
    public AnonymousStructuredStorageStream(string name, Func`3<Lifetime, StreamOpenFlags, Stream> FOpen);
    private sealed virtual override Stream JetBrains.Util.Storage.StructuredStorage.IStructuredStorageStream.Open(Lifetime lifetime, StreamOpenFlags flags);
    private sealed virtual override string JetBrains.Util.Storage.StructuredStorage.INamedItem.get_Name();
}
public class JetBrains.Util.Storage.StructuredStorage.BankSwitchingStructuredStorageSimple : object {
    private Stg myRoot;
    private string JetBrains.Util.Storage.StructuredStorage.INamedItem.Name { get; }
    private IStructuredStorageCollection`1<IStructuredStorage> JetBrains.Util.Storage.StructuredStorage.IStructuredStorage.Storages { get; }
    private IStructuredStorageCollection`1<IStructuredStorageStream> JetBrains.Util.Storage.StructuredStorage.IStructuredStorage.Streams { get; }
    public BankSwitchingStructuredStorageSimple(BankSwitchingMemoryStreamSimple mainstream);
    private sealed virtual override string JetBrains.Util.Storage.StructuredStorage.INamedItem.get_Name();
    private sealed virtual override IStructuredStorageCollection`1<IStructuredStorage> JetBrains.Util.Storage.StructuredStorage.IStructuredStorage.get_Storages();
    private sealed virtual override IStructuredStorageCollection`1<IStructuredStorageStream> JetBrains.Util.Storage.StructuredStorage.IStructuredStorage.get_Streams();
}
public class JetBrains.Util.Storage.StructuredStorage.ComStructuredStorage : object {
    private static Guid LongNamesPropertySetFmtId;
    private OpenStoragesPool myOpenStoragesPool;
    private RelativePath myPath;
    private IStructuredStorageCollection`1<IStructuredStorage> myStoragesCollection;
    private IStructuredStorageCollection`1<IStructuredStorageStream> myStreamsCollection;
    private string JetBrains.Util.Storage.StructuredStorage.INamedItem.Name { get; }
    private IStructuredStorageCollection`1<IStructuredStorage> JetBrains.Util.Storage.StructuredStorage.IStructuredStorage.Storages { get; }
    private IStructuredStorageCollection`1<IStructuredStorageStream> JetBrains.Util.Storage.StructuredStorage.IStructuredStorage.Streams { get; }
    public ComStructuredStorage(Lifetime lifetime, IStorage storage, ImplementationFlags implflags);
    private ComStructuredStorage(RelativePath path, OpenStoragesPool openStoragesPool);
    private static ComStructuredStorage();
    private int CountElements(STGTY stgty);
    private IStructuredStorageStream CreateChildStream(string sName, OpenOrCreate openorcreate);
    private AnonymousStructuredStorageCollection`1<IStructuredStorage> Ctor_Storages();
    private IStructuredStorageCollection`1<IStructuredStorageStream> Ctor_Streams();
    private IEnumerable`1<TInterface> EnumElements();
    [NotNullAttribute]
private OpenStorageRecord OpenMyStorageNoLock();
    private sealed virtual override string JetBrains.Util.Storage.StructuredStorage.INamedItem.get_Name();
    private sealed virtual override IStructuredStorageCollection`1<IStructuredStorage> JetBrains.Util.Storage.StructuredStorage.IStructuredStorage.get_Storages();
    private sealed virtual override IStructuredStorageCollection`1<IStructuredStorageStream> JetBrains.Util.Storage.StructuredStorage.IStructuredStorage.get_Streams();
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Ctor_Storages>b__0();
    [CompilerGeneratedAttribute]
private bool <Ctor_Storages>b__1(IStructuredStorage substorage);
    [CompilerGeneratedAttribute]
private IStructuredStorage <Ctor_Storages>b__3(string name);
    [CompilerGeneratedAttribute]
private IStructuredStorage <Ctor_Storages>b__4(string name);
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Ctor_Streams>b__7();
    [CompilerGeneratedAttribute]
private bool <Ctor_Streams>b__8(IStructuredStorageStream substream);
    [CompilerGeneratedAttribute]
private IStructuredStorageStream <Ctor_Streams>b__9(string name);
    [CompilerGeneratedAttribute]
private IStructuredStorageStream <Ctor_Streams>b__a(string name);
    [CompilerGeneratedAttribute]
private object <EnumElements>b__c();
}
public static class JetBrains.Util.Storage.StructuredStorage.ComStructuredStorages : object {
    private static STGC DefaultCommitFlags;
    private static ComStructuredStorages();
    public static void CreateDiskFile(FileSystemPath file, ComStorageFormat format, Action`1<IStructuredStorage> Write);
    [NotNullAttribute]
public static ChunkedMemoryStream CreateMemoryStream(ComStorageFormat format, Action`1<IStructuredStorage> Write);
    public static void CreateOnLockBytes(ILockBytes lockbytes, ComStorageFormat format, Action`1<IStructuredStorage> Write);
    [NotNullAttribute]
public static ComStructuredStorage CreateOnLockBytes(Lifetime lifetime, ILockBytes lockbytes, ComStorageFormat format);
    [NotNullAttribute]
public static ComStructuredStorage CreateOnStream(Lifetime lifetime, Stream stream, ComStorageFormat format);
    public static void ModifyLockBytes(ILockBytes lockbytes, ComStorageFormat format, Action`1<IStructuredStorage> Modify);
    public static TValue OpenDiskFile(FileSystemPath file, ComStorageFormat format, Func`2<IStructuredStorage, TValue> Read);
    [NotNullAttribute]
public static ComStructuredStorage OpenLockBytes(Lifetime lifetime, ILockBytes lockbytes, ComStorageFormat format, ReadWrite rw);
    [NotNullAttribute]
public static ComStructuredStorage OpenStream(Lifetime lifetime, Stream stream, ComStorageFormat format);
    [NotNullAttribute]
public static TValue ReadLockBytes(ILockBytes lockbytes, ComStorageFormat format, Func`2<IStructuredStorage, TValue> Read);
    [NotNullAttribute]
public static TValue ReadStream(Stream stream, ComStorageFormat format, Func`2<IStructuredStorage, TValue> Read);
}
public class JetBrains.Util.Storage.StructuredStorage.DiskFolderStructuredStorage : object {
    private FileSystemPath myFolder;
    private IStructuredStorageCollection`1<IStructuredStorage> myStoragesCollection;
    private IStructuredStorageCollection`1<IStructuredStorageStream> myStreamsCollection;
    [CompilerGeneratedAttribute]
private static Func`1<Nullable`1<int>> CS$<>9__CachedAnonymousMethodDelegatee;
    [CompilerGeneratedAttribute]
private static Func`2<IStructuredStorage, bool> CS$<>9__CachedAnonymousMethodDelegatef;
    [CompilerGeneratedAttribute]
private static Func`2<FileSystemPath, IStructuredStorageStream> CS$<>9__CachedAnonymousMethodDelegate12;
    [CompilerGeneratedAttribute]
private static Func`1<Nullable`1<int>> CS$<>9__CachedAnonymousMethodDelegate13;
    private string JetBrains.Util.Storage.StructuredStorage.INamedItem.Name { get; }
    private IStructuredStorageCollection`1<IStructuredStorage> JetBrains.Util.Storage.StructuredStorage.IStructuredStorage.Storages { get; }
    private IStructuredStorageCollection`1<IStructuredStorageStream> JetBrains.Util.Storage.StructuredStorage.IStructuredStorage.Streams { get; }
    public DiskFolderStructuredStorage(FileSystemPath pathFolder);
    private sealed virtual override string JetBrains.Util.Storage.StructuredStorage.INamedItem.get_Name();
    private sealed virtual override IStructuredStorageCollection`1<IStructuredStorage> JetBrains.Util.Storage.StructuredStorage.IStructuredStorage.get_Storages();
    private sealed virtual override IStructuredStorageCollection`1<IStructuredStorageStream> JetBrains.Util.Storage.StructuredStorage.IStructuredStorage.get_Streams();
    [CompilerGeneratedAttribute]
private static Nullable`1<int> <.ctor>b__2();
    [CompilerGeneratedAttribute]
private static bool <.ctor>b__3(IStructuredStorage storage);
    [CompilerGeneratedAttribute]
private static IStructuredStorageStream <.ctor>b__6(FileSystemPath pathFile);
    [CompilerGeneratedAttribute]
private static Nullable`1<int> <.ctor>b__9();
}
public interface JetBrains.Util.Storage.StructuredStorage.INamedItem {
    [NotNullAttribute]
public string Name { get; }
    public abstract virtual string get_Name();
}
public interface JetBrains.Util.Storage.StructuredStorage.IStructuredStorage {
    [NotNullAttribute]
public IStructuredStorageCollection`1<IStructuredStorage> Storages { get; }
    [NotNullAttribute]
public IStructuredStorageCollection`1<IStructuredStorageStream> Streams { get; }
    public abstract virtual IStructuredStorageCollection`1<IStructuredStorage> get_Storages();
    public abstract virtual IStructuredStorageCollection`1<IStructuredStorageStream> get_Streams();
}
[DefaultMemberAttribute("Item")]
public interface JetBrains.Util.Storage.StructuredStorage.IStructuredStorageCollection`1 {
    public int Count { get; }
    [NotNullAttribute]
public TItem Item { get; }
    public abstract virtual int get_Count();
    public abstract virtual TItem get_Item(string name);
    [NotNullAttribute]
public abstract virtual TItem Create(string name);
    [CanBeNullAttribute]
public abstract virtual TItem TryGetItem(string name);
}
[ExtensionAttribute]
public static class JetBrains.Util.Storage.StructuredStorage.IStructuredStorageEx : object {
    [ExtensionAttribute]
public static bool Contains(IStructuredStorageCollection`1<TItem> ths, string name);
    [ExtensionAttribute]
public static void CopyTo(IStructuredStorage ths, IStructuredStorage dest);
    [ExtensionAttribute]
public static bool Remove(IStructuredStorageCollection`1<TItem> ths, string name);
}
[ComVisibleAttribute("True")]
public interface JetBrains.Util.Storage.StructuredStorage.IStructuredStorageSerializable {
    public abstract virtual void GetObjectData(IStructuredStorage storage);
}
public interface JetBrains.Util.Storage.StructuredStorage.IStructuredStorageStream {
    [NotNullAttribute]
public abstract virtual Stream Open(Lifetime lifetime, StreamOpenFlags flags);
}
public class JetBrains.Util.Storage.StructuredStorage.PackageStructuredStorage : object {
    public static CompressionOption CompressionOption;
    private string myName;
    private IStructuredStorageCollection`1<IStructuredStorage> myStoragesCollection;
    private IStructuredStorageCollection`1<IStructuredStorageStream> myStreamsCollection;
    private string JetBrains.Util.Storage.StructuredStorage.INamedItem.Name { get; }
    private IStructuredStorageCollection`1<IStructuredStorage> JetBrains.Util.Storage.StructuredStorage.IStructuredStorage.Storages { get; }
    private IStructuredStorageCollection`1<IStructuredStorageStream> JetBrains.Util.Storage.StructuredStorage.IStructuredStorage.Streams { get; }
    public PackageStructuredStorage(string name, Package package);
    private static PackageStructuredStorage();
    [NotNullAttribute]
public static ChunkedMemoryStream CreateMemoryStream(Action`1<IStructuredStorage> FWrite);
    [NotNullAttribute]
public static PackageStructuredStorage CreateOnStream(Lifetime lifetime, Stream stream);
    public static void OpenStream(Stream stream, Action`1<IStructuredStorage> FRead);
    [NotNullAttribute]
public static PackageStructuredStorage OpenStream(Lifetime lifetime, Stream stream);
    public static TReturn OpenStream(Stream stream, Func`2<IStructuredStorage, TReturn> FRead);
    [NotNullAttribute]
private static RelativePath GetPartPath(PackagePart part);
    private static Uri GetPartUri(RelativePath path);
    private sealed virtual override string JetBrains.Util.Storage.StructuredStorage.INamedItem.get_Name();
    private sealed virtual override IStructuredStorageCollection`1<IStructuredStorage> JetBrains.Util.Storage.StructuredStorage.IStructuredStorage.get_Storages();
    private sealed virtual override IStructuredStorageCollection`1<IStructuredStorageStream> JetBrains.Util.Storage.StructuredStorage.IStructuredStorage.get_Streams();
}
public class JetBrains.Util.Storage.StructuredStorage.RuntimeStructuredStorage : object {
    private static string RootStorageName;
    private static Func`2<IDictionary`2<string, IStructuredStorage>, Nullable`1<int>> StgCount;
    private static Func`3<IDictionary`2<string, IStructuredStorage>, string, IStructuredStorage> StgCreate;
    private static Func`2<IDictionary`2<string, IStructuredStorage>, IEnumerable`1<IStructuredStorage>> StgEnum;
    private static Func`3<IDictionary`2<string, IStructuredStorage>, IStructuredStorage, bool> StgRemove;
    private static Func`3<IDictionary`2<string, IStructuredStorage>, string, IStructuredStorage> StgTryGet;
    private static Func`2<IDictionary`2<string, IStructuredStorageStream>, Nullable`1<int>> StmCount;
    private static Func`3<IDictionary`2<string, IStructuredStorageStream>, string, IStructuredStorageStream> StmCreate;
    private static Func`2<IDictionary`2<string, IStructuredStorageStream>, IEnumerable`1<IStructuredStorageStream>> StmEnum;
    private static Func`3<IDictionary`2<string, IStructuredStorageStream>, IStructuredStorageStream, bool> StmRemove;
    private static Func`3<IDictionary`2<string, IStructuredStorageStream>, string, IStructuredStorageStream> StmTryGet;
    private string myName;
    private IStructuredStorageCollection`1<IStructuredStorage> myStoragesCollection;
    private IStructuredStorageCollection`1<IStructuredStorageStream> myStreamsCollection;
    [CompilerGeneratedAttribute]
private static Func`2<IDictionary`2<string, IStructuredStorage>, Nullable`1<int>> CS$<>9__CachedAnonymousMethodDelegateb;
    [CompilerGeneratedAttribute]
private static Func`3<IDictionary`2<string, IStructuredStorage>, string, IStructuredStorage> CS$<>9__CachedAnonymousMethodDelegatec;
    [CompilerGeneratedAttribute]
private static Func`2<IDictionary`2<string, IStructuredStorage>, IEnumerable`1<IStructuredStorage>> CS$<>9__CachedAnonymousMethodDelegated;
    [CompilerGeneratedAttribute]
private static Func`3<IDictionary`2<string, IStructuredStorage>, IStructuredStorage, bool> CS$<>9__CachedAnonymousMethodDelegatee;
    [CompilerGeneratedAttribute]
private static Func`3<IDictionary`2<string, IStructuredStorage>, string, IStructuredStorage> CS$<>9__CachedAnonymousMethodDelegatef;
    [CompilerGeneratedAttribute]
private static Func`2<IDictionary`2<string, IStructuredStorageStream>, Nullable`1<int>> CS$<>9__CachedAnonymousMethodDelegate10;
    [CompilerGeneratedAttribute]
private static Func`3<IDictionary`2<string, IStructuredStorageStream>, string, IStructuredStorageStream> CS$<>9__CachedAnonymousMethodDelegate11;
    [CompilerGeneratedAttribute]
private static Func`2<IDictionary`2<string, IStructuredStorageStream>, IEnumerable`1<IStructuredStorageStream>> CS$<>9__CachedAnonymousMethodDelegate12;
    [CompilerGeneratedAttribute]
private static Func`3<IDictionary`2<string, IStructuredStorageStream>, IStructuredStorageStream, bool> CS$<>9__CachedAnonymousMethodDelegate13;
    [CompilerGeneratedAttribute]
private static Func`3<IDictionary`2<string, IStructuredStorageStream>, string, IStructuredStorageStream> CS$<>9__CachedAnonymousMethodDelegate14;
    private string JetBrains.Util.Storage.StructuredStorage.INamedItem.Name { get; }
    private IStructuredStorageCollection`1<IStructuredStorage> JetBrains.Util.Storage.StructuredStorage.IStructuredStorage.Storages { get; }
    private IStructuredStorageCollection`1<IStructuredStorageStream> JetBrains.Util.Storage.StructuredStorage.IStructuredStorage.Streams { get; }
    public RuntimeStructuredStorage(string name);
    private static RuntimeStructuredStorage();
    private sealed virtual override string JetBrains.Util.Storage.StructuredStorage.INamedItem.get_Name();
    private sealed virtual override IStructuredStorageCollection`1<IStructuredStorage> JetBrains.Util.Storage.StructuredStorage.IStructuredStorage.get_Storages();
    private sealed virtual override IStructuredStorageCollection`1<IStructuredStorageStream> JetBrains.Util.Storage.StructuredStorage.IStructuredStorage.get_Streams();
    [CompilerGeneratedAttribute]
private static Nullable`1<int> <.cctor>b__0(IDictionary`2<string, IStructuredStorage> dict);
    [CompilerGeneratedAttribute]
private static IStructuredStorage <.cctor>b__1(IDictionary`2<string, IStructuredStorage> dict, string name);
    [CompilerGeneratedAttribute]
private static IEnumerable`1<IStructuredStorage> <.cctor>b__2(IDictionary`2<string, IStructuredStorage> dict);
    [CompilerGeneratedAttribute]
private static bool <.cctor>b__3(IDictionary`2<string, IStructuredStorage> dict, IStructuredStorage storage);
    [CompilerGeneratedAttribute]
private static IStructuredStorage <.cctor>b__4(IDictionary`2<string, IStructuredStorage> dict, string s);
    [CompilerGeneratedAttribute]
private static Nullable`1<int> <.cctor>b__5(IDictionary`2<string, IStructuredStorageStream> dict);
    [CompilerGeneratedAttribute]
private static IStructuredStorageStream <.cctor>b__6(IDictionary`2<string, IStructuredStorageStream> dict, string name);
    [CompilerGeneratedAttribute]
private static IEnumerable`1<IStructuredStorageStream> <.cctor>b__8(IDictionary`2<string, IStructuredStorageStream> dict);
    [CompilerGeneratedAttribute]
private static bool <.cctor>b__9(IDictionary`2<string, IStructuredStorageStream> dict, IStructuredStorageStream stm);
    [CompilerGeneratedAttribute]
private static IStructuredStorageStream <.cctor>b__a(IDictionary`2<string, IStructuredStorageStream> dict, string name);
}
public enum JetBrains.Util.Storage.StructuredStorage.StreamOpenFlags.Exists : Enum {
    public byte value__;
    public static Exists DontCare;
    public static Exists MustExist;
    public static Exists MustNotExist;
}
[FlagsAttribute]
public enum JetBrains.Util.Storage.StructuredStorage.StreamOpenFlags.ReadWrite : Enum {
    public byte value__;
    public static ReadWrite Read;
    public static ReadWrite Write;
    public static ReadWrite ReadWrite;
}
public enum JetBrains.Util.Storage.StructuredStorage.StreamOpenFlags.Seek : Enum {
    public byte value__;
    public static Seek Begin;
    public static Seek End;
}
public class JetBrains.Util.Storage.StructuredStorage.StreamOpenFlags.StreamOpenFlags : ValueType {
    public Exists Exists;
    public ReadWrite ReadWrite;
    public Seek Seek;
    public Truncate Truncate;
    public static StreamOpenFlags ReadExisting { get; }
    public static StreamOpenFlags WriteNewContent { get; }
    public StreamOpenFlags(ReadWrite readWrite, Seek seek, Exists exists, Truncate truncate);
    public static StreamOpenFlags get_ReadExisting();
    public static StreamOpenFlags get_WriteNewContent();
    public static bool op_Equality(StreamOpenFlags left, StreamOpenFlags right);
    public static bool op_Inequality(StreamOpenFlags left, StreamOpenFlags right);
    public bool IsValidCombination(OnError onerror);
    public FileAccess ToFileAccess();
    public FileMode ToFileMode();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public sealed virtual bool Equals(StreamOpenFlags other);
}
public enum JetBrains.Util.Storage.StructuredStorage.StreamOpenFlags.Truncate : Enum {
    public int value__;
    public static Truncate KeepSize;
    public static Truncate ZeroSize;
}
[ExtensionAttribute]
public static class JetBrains.Util.Storage.StructuredStorage.StructuredStorageHelpers : object {
    private static ILogger Logger;
    private static StructuredStorageHelpers();
    [ExtensionAttribute]
[NotNullAttribute]
public static TItem GetOrCreateItem(IStructuredStorageCollection`1<TItem> ths, string name);
    public static bool IsNameValid(string name, OnError onerror);
    [ExtensionAttribute]
public static void ReadStream(IStructuredStorageStream ths, Action`1<Stream> FRead);
    [ExtensionAttribute]
public static TValue ReadStream(IStructuredStorageStream ths, Func`2<Stream, TValue> FRead);
    [ExtensionAttribute]
public static void ReadStream(IStructuredStorageCollection`1<IStructuredStorageStream> ths, string name, Action`1<Stream> FRead);
    [ExtensionAttribute]
public static TValue ReadStream(IStructuredStorageCollection`1<IStructuredStorageStream> ths, string name, Func`2<Stream, TValue> FRead);
    [ExtensionAttribute]
[NotNullAttribute]
public static string ReadUtf8(IStructuredStorageCollection`1<IStructuredStorageStream> ths, string name);
    [ExtensionAttribute]
[NotNullAttribute]
public static string ReadUtf8(IStructuredStorageStream ths);
    [ExtensionAttribute]
public static void ReadUtf8(IStructuredStorageStream ths, Action`1<StreamReader> Read);
    [ExtensionAttribute]
public static TValue ReadUtf8(IStructuredStorageStream ths, Func`2<StreamReader, TValue> Read);
    [ExtensionAttribute]
public static void WriteCsexp(IStructuredStorageStream ths, Action`1<CsexpWriter> Write);
    [ExtensionAttribute]
public static void WriteStream(IStructuredStorageStream ths, Action`1<Stream> FWrite);
    [ExtensionAttribute]
public static void WriteStream(IStructuredStorageStream ths, Stream streamCopyFrom);
    [ExtensionAttribute]
public static void WriteStream(IStructuredStorageCollection`1<IStructuredStorageStream> ths, string name, Action`1<Stream> FWrite);
    [ExtensionAttribute]
public static void WriteUtf8(IStructuredStorageCollection`1<IStructuredStorageStream> ths, string name, string value);
    [ExtensionAttribute]
public static void WriteUtf8(IStructuredStorageStream ths, string value);
    [ExtensionAttribute]
public static void WriteUtf8(IStructuredStorageStream ths, Action`1<StreamWriter> Write);
}
public static class JetBrains.Util.Storage.StructuredStorage.StructuredStorages : object {
    public static Format DefaultStorageFormat;
    private static Header[] Headers;
    public static Format PublicFilesPreferredFormat;
    public static string UniversalStorageExtension;
    [CompilerGeneratedAttribute]
private static Func`2<Header, int> CS$<>9__CachedAnonymousMethodDelegatee;
    [CompilerGeneratedAttribute]
private static Func`2<Format, string> CS$<>9__CachedAnonymousMethodDelegatef;
    private static StructuredStorages();
    [NotNullAttribute]
public static ChunkedMemoryStream CreateMemoryStream(Action`1<IStructuredStorage> , Nullable`1<Format> formatIfPreferred);
    public static void CreateOnStream(Stream stream, Action`1<IStructuredStorage> , Nullable`1<Format> formatIfPreferred);
    public static IStructuredStorage CreateOnStream(Lifetime lifetime, Stream stream, Format format, OnError onerror);
    public static TReturn OpenStream(Stream stream, Func`2<IStructuredStorage, TReturn> , Nullable`1<Format> formatIfKnown);
    public static void OpenStream(Stream stream, Action`1<IStructuredStorage> , Nullable`1<Format> formatIfKnown);
    public static IStructuredStorage OpenStream(Lifetime lifetime, Stream stream, OnError onerror, Nullable`1<Format> formatIfKnown);
    private static Nullable`1<Format> DetectStreamFormat(Stream stream, OnError onerror);
    private static void RestoreStreamPosition(Stream stream, long position, OnError onerror);
    [CompilerGeneratedAttribute]
private static int <DetectStreamFormat>b__c(Header h);
    [CompilerGeneratedAttribute]
private static string <DetectStreamFormat>b__d(Format f);
}
public class JetBrains.Util.Storage.StructuredStorage.ZipStructuredStorage : object {
    public static EscapeChars EscapeRules;
    private IStructuredStorage myRoot;
    private string JetBrains.Util.Storage.StructuredStorage.INamedItem.Name { get; }
    private IStructuredStorageCollection`1<IStructuredStorage> JetBrains.Util.Storage.StructuredStorage.IStructuredStorage.Storages { get; }
    private IStructuredStorageCollection`1<IStructuredStorageStream> JetBrains.Util.Storage.StructuredStorage.IStructuredStorage.Streams { get; }
    public ZipStructuredStorage(Lifetime lifetime, ZipFile package);
    private static ZipStructuredStorage();
    [NotNullAttribute]
public static ZipStructuredStorage CreateOnStream(Lifetime lifetime, Stream stream);
    public static void OpenStream(Stream stream, Action`1<IStructuredStorage> fRead);
    [NotNullAttribute]
public static ZipStructuredStorage OpenStream(Lifetime lifetime, Stream stream);
    public static TReturn OpenStream(Stream stream, Func`2<IStructuredStorage, TReturn> fRead);
    private sealed virtual override string JetBrains.Util.Storage.StructuredStorage.INamedItem.get_Name();
    private sealed virtual override IStructuredStorageCollection`1<IStructuredStorage> JetBrains.Util.Storage.StructuredStorage.IStructuredStorage.get_Storages();
    private sealed virtual override IStructuredStorageCollection`1<IStructuredStorageStream> JetBrains.Util.Storage.StructuredStorage.IStructuredStorage.get_Streams();
}
public class JetBrains.Util.StreamUnderLifetime : Stream {
    private LifetimeDefinition myLifetimeDefinition;
    private Stream myStream;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanTimeout { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public int ReadTimeout { get; public set; }
    public int WriteTimeout { get; public set; }
    public StreamUnderLifetime(OuterLifetime outerlifetime, Func`2<Lifetime, Stream> FGetStream);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void Close();
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte value);
    protected virtual void Dispose(bool disposing);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanTimeout();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
}
public class JetBrains.Util.StringEncryption : object {
    private SymmetricAlgorithm myCryptoService;
    public StringEncryption(StringEncryptionMethod method);
    public StringEncryption(SymmetricAlgorithm serviceProvider);
    private Byte[] GetLegalKey(string key);
    public string Encrypt(string source, string key);
    public string Decrypt(string source, string key);
    public sealed virtual void Dispose();
}
public class JetBrains.Util.StringSearcher : object {
    private string myPattern;
    private int myPatternLength;
    private Int32[] mySearchTable;
    private Char[] myPatternArray;
    private bool myCaseSensitive;
    private bool myForwardDirection;
    public string Pattern { get; }
    public bool CaseSensitive { get; }
    public StringSearcher(string pattern, bool caseSensitive);
    public string get_Pattern();
    public bool get_CaseSensitive();
    public int Find(IBuffer buffer);
    public int Find(IBuffer buffer, int startOffset, int endOffset);
    public IList`1<int> FindAll(IBuffer buffer);
    public IList`1<int> FindAll(IBuffer buffer, int startOffset, int endOffset);
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Util.StrongToWeakDictionary`2 : object {
    private static Statistics Statistics;
    private static object NullObject;
    private IEqualityComparer`1<TKey> myComparer;
    private Entry[] myEntries;
    private int myEntriesUsed;
    private int myFirstFreeIndex;
    private int myFreeCount;
    private Int32[] myHashToEntryIndex;
    private KeyCollection<TKey, TValue> myKeys;
    private ValueCollection<TKey, TValue> myValues;
    private int myVersion;
    public IEqualityComparer`1<TKey> Comparer { get; }
    public KeyCollection<TKey, TValue> Keys { get; }
    public ValueCollection<TKey, TValue> Values { get; }
    public int Capacity { get; }
    public TValue Item { get; public set; }
    [ObsoleteAttribute("Use an overload with lifetime.")]
public StrongToWeakDictionary`2(IDictionary`2<TKey, TValue> dictionary);
    [ObsoleteAttribute("Use an overload with lifetime.")]
public StrongToWeakDictionary`2(IEqualityComparer`1<TKey> comparer);
    [ObsoleteAttribute("Use an overload with lifetime.")]
public StrongToWeakDictionary`2(int capacity);
    [ObsoleteAttribute("Use an overload with lifetime.")]
public StrongToWeakDictionary`2(IDictionary`2<TKey, TValue> dictionary, IEqualityComparer`1<TKey> comparer);
    [ObsoleteAttribute("Use an overload with lifetime.")]
public StrongToWeakDictionary`2(int capacity, IEqualityComparer`1<TKey> comparer);
    public StrongToWeakDictionary`2(Lifetime lifetime);
    public StrongToWeakDictionary`2(Lifetime lifetime, IDictionary`2<TKey, TValue> dictionary);
    public StrongToWeakDictionary`2(Lifetime lifetime, IEqualityComparer`1<TKey> comparer);
    public StrongToWeakDictionary`2(Lifetime lifetime, int capacity);
    public StrongToWeakDictionary`2(Lifetime lifetime, IDictionary`2<TKey, TValue> dictionary, IEqualityComparer`1<TKey> comparer);
    public StrongToWeakDictionary`2(Lifetime lifetime, int capacity, IEqualityComparer`1<TKey> comparer);
    private static StrongToWeakDictionary`2();
    public IEqualityComparer`1<TKey> get_Comparer();
    public KeyCollection<TKey, TValue> get_Keys();
    public ValueCollection<TKey, TValue> get_Values();
    public int get_Capacity();
    public void Add(TKey key, TValue value);
    public void Clear();
    public bool ContainsKey(TKey key);
    public bool ContainsValue(TValue value);
    public bool Remove(TKey key);
    public TValue get_Item(TKey key);
    public void set_Item(TKey key, TValue value);
    public bool TryGetValue(TKey key, TValue& value);
    private sealed virtual override IEnumerator`1<KeyValuePair`2<TKey, TValue>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TValue>>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public PairEnumerator<TKey, TValue> GetEnumerator();
    public sealed virtual void Dispose();
    protected virtual void Finalize();
    private static TValue FixValue(object value);
    private void RemoveEntry(int entryIndex);
    private bool CompareKeyOptionallyRemoveIfDead(TKey key, int entryIndex, TValue& value, bool removeIfDead);
    private int FindEntry(TKey key, TValue& value);
    private void Initialize(int capacity);
    private void Insert(TKey key, TValue value, bool add);
    private void Resize();
    public void Sweep();
}
public class JetBrains.Util.SystemObjectEqualityComparer`1 : object {
    public static SystemObjectEqualityComparer`1<T> Instance;
    private static SystemObjectEqualityComparer`1();
    private sealed virtual override bool System.Collections.IEqualityComparer.Equals(object x, object y);
    private sealed virtual override int System.Collections.IEqualityComparer.GetHashCode(object obj);
    private sealed virtual override bool System.Collections.Generic.IEqualityComparer<T>.Equals(T x, T y);
    private sealed virtual override int System.Collections.Generic.IEqualityComparer<T>.GetHashCode(T obj);
}
public class JetBrains.Util.TemporaryDirectoryCookie : object {
    [CompilerGeneratedAttribute]
private FileSystemPath <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <LogExceptionSilentlyOnDispose>k__BackingField;
    public FileSystemPath Path { get; private set; }
    public bool LogExceptionSilentlyOnDispose { get; public set; }
    private TemporaryDirectoryCookie(FileSystemPath path);
    [CompilerGeneratedAttribute]
public sealed virtual FileSystemPath get_Path();
    [CompilerGeneratedAttribute]
private void set_Path(FileSystemPath value);
    [CompilerGeneratedAttribute]
public bool get_LogExceptionSilentlyOnDispose();
    [CompilerGeneratedAttribute]
public void set_LogExceptionSilentlyOnDispose(bool value);
    public sealed virtual void Dispose();
    private void Remove();
    public static TemporaryDirectoryCookie CreateFolder(FileSystemPath parentFolder, string prefix);
    [NotNullAttribute]
public static TemporaryDirectoryCookie CreateFolderEx(Lifetime lifetime, FileSystemPath parentFolder, string prefix, bool logExceptionSilentlyOnDispose);
    [NotNullAttribute]
public static FileSystemPath CreateFolder(Lifetime lifetime, FileSystemPath parentFolder, string prefix, bool logExceptionSilentlyOnDispose);
    public static TemporaryDirectoryCookie UseFolder(FileSystemPath folderPath);
    [CompilerGeneratedAttribute]
private object <Remove>b__0();
}
public class JetBrains.Util.TestPresentationMap : object {
    private static TestPresentationMap modreq(System.Runtime.CompilerServices.IsVolatile) ourInstance;
    private IDictionary`2<Pair`2<Type, int>, string> myTestPresentations;
    private static ILogger ourLogger;
    private static int ourRequestCount;
    public static bool Available { get; }
    private static TestPresentationMap();
    public static void Setup();
    public static void Acquire();
    public static void Release();
    public static IDisposable Cookie();
    public static bool get_Available();
    public static void RegisterTestPresentation(T t, string presentation);
    private static string HashToStr(int hash);
    public static string ToString(T t);
}
public class JetBrains.Util.Text.IdentifierMatcherAnyOrder : object {
    private string myPattern;
    private bool myCorrectTypos;
    private IdentifierMatchingStyle myStyle;
    private Char[] myPatternLowerChars;
    private Boolean[] myPatternIsLowerLookup;
    private int myPatternLength;
    private Int32[] myMatchingIndicies;
    private Int32[] myGreedyMatchedSources;
    private Boolean[] myKuhnDfsUsed;
    [CompilerGeneratedAttribute]
private bool <CurrentResult>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CurrentIdentifier>k__BackingField;
    [CompilerGeneratedAttribute]
private MatcherScore <CurrentScore>k__BackingField;
    public bool HasSuffixShrinkProperty { get; }
    public string Filter { get; }
    public bool CorrectTypos { get; }
    public IdentifierMatchingStyle MatchingStyle { get; }
    public bool CurrentResult { get; private set; }
    public string CurrentIdentifier { get; private set; }
    public MatcherScore CurrentScore { get; private set; }
    public IdentifierMatcherAnyOrder(string pattern, IdentifierMatchingStyle style, bool correctTypos);
    public sealed virtual bool get_HasSuffixShrinkProperty();
    public sealed virtual string get_Filter();
    public sealed virtual bool get_CorrectTypos();
    public sealed virtual IdentifierMatchingStyle get_MatchingStyle();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_CurrentResult();
    [CompilerGeneratedAttribute]
private void set_CurrentResult(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_CurrentIdentifier();
    [CompilerGeneratedAttribute]
private void set_CurrentIdentifier(string value);
    [CompilerGeneratedAttribute]
public sealed virtual MatcherScore get_CurrentScore();
    [CompilerGeneratedAttribute]
private void set_CurrentScore(MatcherScore value);
    public sealed virtual bool Matches(string text);
    public bool MatchInternal(string text);
    private bool TryMatchNoTypos(UnsafeIntArray bigraphPtr, int n, Char* lowerText, UnsafeIntArray humps, Char* textData, UnsafeIntArray matchingGraph, UnsafeIntArray mt, UnsafeIntArray isHumpLookupPtr, UnsafeIntArray dynMatrix);
    private bool MakeBigraph(UnsafeIntArray graph, int n, Char* lowerText, UnsafeIntArray humps, Char* textData);
    private MatcherScore CalculateScores(UnsafeIntArray humps, Int32[] kuhnResult, UnsafeIntArray mt, Char* textData, MatcherScore initialScore);
    public void FindMatchingIndices(UnsafeIntArray bigraph, int patternLength, int inputLength, UnsafeIntArray mt, UnsafeIntArray isHumpLookup, UnsafeIntArray dynMatrix, UnsafeIntArray humps);
    private UnsafeIntArray SolveKuhn(UnsafeIntArray bigraph, int patternLength, int inputLength, UnsafeIntArray mt, SequentialMatchMaxIndexCollector simpleSeqMatch);
    private void FindMatchingIndicesInCorrectOrder(UnsafeIntArray bigraph, int inputLength, UnsafeIntArray mt, UnsafeIntArray isHumpLookup, UnsafeIntArray dynMatrix);
    private static bool TryKuhn(int v, Boolean[] used, UnsafeIntArray mt, UnsafeIntArray bigraph, int inputLength);
    private bool TypoCorrection(Char* lowerText, int n);
    public sealed virtual Int32[] MatchingIndicies(string text);
    public sealed virtual Int32[] CurrentMatchingIndicesCopy();
    public sealed virtual IIdentifierMatcher Clone();
    private sealed virtual override object System.ICloneable.Clone();
}
public class JetBrains.Util.Text.IdentifierMatcherCollection : object {
    [NotNullAttribute]
private IIdentifierMatcher myActive;
    private IIdentifierMatcher[] myMatchers;
    [CompilerGeneratedAttribute]
private static Func`2<IIdentifierMatcher, bool> CS$<>9__CachedAnonymousMethodDelegate1;
    [CompilerGeneratedAttribute]
private static Func`2<IIdentifierMatcher, IIdentifierMatcher> CS$<>9__CachedAnonymousMethodDelegate3;
    public bool HasSuffixShrinkProperty { get; }
    public MatcherScore CurrentScore { get; }
    public bool CurrentResult { get; }
    public string CurrentIdentifier { get; }
    public string Filter { get; }
    public IdentifierMatchingStyle MatchingStyle { get; }
    public bool CorrectTypos { get; }
    public IdentifierMatcherCollection(IIdentifierMatcher[] matchers);
    public sealed virtual bool get_HasSuffixShrinkProperty();
    public sealed virtual MatcherScore get_CurrentScore();
    public sealed virtual bool get_CurrentResult();
    public sealed virtual string get_CurrentIdentifier();
    public sealed virtual string get_Filter();
    public sealed virtual IdentifierMatchingStyle get_MatchingStyle();
    public sealed virtual bool get_CorrectTypos();
    public sealed virtual bool Matches(string text);
    public sealed virtual Int32[] MatchingIndicies(string text);
    public sealed virtual Int32[] CurrentMatchingIndicesCopy();
    public sealed virtual IIdentifierMatcher Clone();
    private sealed virtual override object System.ICloneable.Clone();
    [CompilerGeneratedAttribute]
private static bool <get_HasSuffixShrinkProperty>b__0(IIdentifierMatcher m);
    [CompilerGeneratedAttribute]
private static IIdentifierMatcher <Clone>b__2(IIdentifierMatcher m);
}
public static class JetBrains.Util.Text.IdentifierMatcherUtil : object {
    public static int MinSymbolsForTypoCorrection;
    private static HashMap`2<char, char> ourRussianQwertyMap;
    private static HashMap`2<char, char> ourHebrewQwertyMap;
    private static IdentifierMatcherUtil();
    public static string HandleWrongKeyboardLayout(string pattern);
    public static void FindHumps(Char* textData, int textLen, UnsafeIntArray& humps, Char* textLowercase);
    public static string HandleCastingTypos(string pattern);
}
public class JetBrains.Util.Text.StringAbbreviator`1 : object {
    private static PropertyId`1<string> Abbr;
    private static PropertyId`1<Nullable`1<char>> Caps;
    private static PropertyId`1<TItem> Item;
    private static PropertyId`1<string> NonCapsText;
    private static PropertyId`1<PropertyBag[]> Parts;
    private static PropertyId`1<string> Text;
    private static string myDisambigChars;
    private static Regex myRegexMatchNonWord;
    private static Regex myRegexSplitByCaps;
    private int myCharsLimit;
    private OneToSetMap`2<string, PropertyBag> myData;
    private Func`2<TItem, string> myFItemName;
    [CompilerGeneratedAttribute]
private static Func`2<PropertyBag, bool> CS$<>9__CachedAnonymousMethodDelegate6;
    [CompilerGeneratedAttribute]
private static Func`2<PropertyBag, char> CS$<>9__CachedAnonymousMethodDelegate7;
    [CompilerGeneratedAttribute]
private static Func`3<PropertyBag, int, <>f__AnonymousType56`2<PropertyBag, int>> CS$<>9__CachedAnonymousMethodDelegate8;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType56`2<PropertyBag, int>, int> CS$<>9__CachedAnonymousMethodDelegate9;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType56`2<PropertyBag, int>, int> CS$<>9__CachedAnonymousMethodDelegatea;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType56`2<PropertyBag, int>, char> CS$<>9__CachedAnonymousMethodDelegateb;
    [CompilerGeneratedAttribute]
private static Func`2<KeyValuePair`2<string, ISet`1<PropertyBag>>, IEnumerable`1<<>f__AnonymousType57`2<string, TItem>>> CS$<>9__CachedAnonymousMethodDelegate10;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType57`2<string, TItem>, TItem> CS$<>9__CachedAnonymousMethodDelegate11;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType57`2<string, TItem>, string> CS$<>9__CachedAnonymousMethodDelegate12;
    [CompilerGeneratedAttribute]
private static Func`2<KeyValuePair`2<string, ISet`1<PropertyBag>>, bool> CS$<>9__CachedAnonymousMethodDelegate17;
    [CompilerGeneratedAttribute]
private static Func`2<KeyValuePair`2<string, ISet`1<PropertyBag>>, Nullable`1<KeyValuePair`2<string, ISet`1<PropertyBag>>>> CS$<>9__CachedAnonymousMethodDelegate18;
    [CompilerGeneratedAttribute]
private static Func`2<int, char> CS$<>9__CachedAnonymousMethodDelegate1a;
    protected StringAbbreviator`1(IEnumerable`1<TItem> items, Func`2<TItem, string> FItemName, int nChars);
    private static StringAbbreviator`1();
    [NotNullAttribute]
public static Dictionary`2<TItem, string> Run(IEnumerable`1<TItem> items, Func`2<TItem, string> FItemName, int nChars);
    private static bool IsCaps(char ch);
    private static string RemoveNonAlphaChars(string text);
    private OneToSetMap`2<string, PropertyBag> CreateData(IEnumerable`1<TItem> items);
    private string GetDefaultAbbreviation(PropertyBag bag);
    [NotNullAttribute]
private PropertyBag GetNameParts(TItem item);
    [NotNullAttribute]
private Dictionary`2<TItem, string> GetResult();
    private void ResolveConflicts();
    private void ResolveConflicts_ChooseUniqueChars();
    private void ResolveConflicts_DisambigChars();
    [CompilerGeneratedAttribute]
private static bool <GetDefaultAbbreviation>b__0(PropertyBag part);
    [CompilerGeneratedAttribute]
private static char <GetDefaultAbbreviation>b__1(PropertyBag part);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType56`2<PropertyBag, int> <GetDefaultAbbreviation>b__2(PropertyBag part, int index);
    [CompilerGeneratedAttribute]
private static int <GetDefaultAbbreviation>b__3(<>f__AnonymousType56`2<PropertyBag, int> tuple);
    [CompilerGeneratedAttribute]
private static int <GetDefaultAbbreviation>b__4(<>f__AnonymousType56`2<PropertyBag, int> tuple);
    [CompilerGeneratedAttribute]
private static char <GetDefaultAbbreviation>b__5(<>f__AnonymousType56`2<PropertyBag, int> tuple);
    [CompilerGeneratedAttribute]
private static IEnumerable`1<<>f__AnonymousType57`2<string, TItem>> <GetResult>b__c(KeyValuePair`2<string, ISet`1<PropertyBag>> pair);
    [CompilerGeneratedAttribute]
private static TItem <GetResult>b__e(<>f__AnonymousType57`2<string, TItem> tuple);
    [CompilerGeneratedAttribute]
private static string <GetResult>b__f(<>f__AnonymousType57`2<string, TItem> tuple);
    [CompilerGeneratedAttribute]
private static bool <ResolveConflicts_DisambigChars>b__15(KeyValuePair`2<string, ISet`1<PropertyBag>> pair);
    [CompilerGeneratedAttribute]
private static Nullable`1<KeyValuePair`2<string, ISet`1<PropertyBag>>> <ResolveConflicts_DisambigChars>b__16(KeyValuePair`2<string, ISet`1<PropertyBag>> pair);
    [CompilerGeneratedAttribute]
private static char <.cctor>b__19(int n);
}
public class JetBrains.Util.Text.WildcardIdentifierMatcher : object {
    private string myPattern;
    private bool myCaseSensitive;
    private Wildcard myWildcard;
    [CompilerGeneratedAttribute]
private MatcherScore <CurrentScore>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CurrentResult>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CurrentIdentifier>k__BackingField;
    public bool HasSuffixShrinkProperty { get; }
    public MatcherScore CurrentScore { get; private set; }
    public bool CurrentResult { get; private set; }
    [CanBeNullAttribute]
public string CurrentIdentifier { get; private set; }
    public string Filter { get; }
    public IdentifierMatchingStyle MatchingStyle { get; }
    public bool CorrectTypos { get; }
    public WildcardIdentifierMatcher(string pattern, bool caseSensitive);
    public sealed virtual IIdentifierMatcher Clone();
    private sealed virtual override object System.ICloneable.Clone();
    public sealed virtual bool get_HasSuffixShrinkProperty();
    [CompilerGeneratedAttribute]
public sealed virtual MatcherScore get_CurrentScore();
    [CompilerGeneratedAttribute]
private void set_CurrentScore(MatcherScore value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_CurrentResult();
    [CompilerGeneratedAttribute]
private void set_CurrentResult(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_CurrentIdentifier();
    [CompilerGeneratedAttribute]
private void set_CurrentIdentifier(string value);
    public sealed virtual string get_Filter();
    public sealed virtual IdentifierMatchingStyle get_MatchingStyle();
    public sealed virtual bool get_CorrectTypos();
    public sealed virtual bool Matches(string text);
    public sealed virtual Int32[] MatchingIndicies(string text);
    public sealed virtual Int32[] CurrentMatchingIndicesCopy();
}
[ObsoleteAttribute("Inconsistent treatment of line endings due to TextUtil::ReadToEnd, don't use unless you absolutely wish to kill them.")]
public class JetBrains.Util.TextStreamReader : StreamReader {
    public TextStreamReader(FileSystemPath fileName);
    public virtual string ReadToEnd();
}
[ObsoleteAttribute("Inconsistent treatment of line endings due to TextUtil::ReadToEnd, don't use unless you absolutely wish to kill them.")]
public class JetBrains.Util.TextStringReader : StringReader {
    public TextStringReader(string buffer);
    public virtual string ReadToEnd();
}
[ObsoleteAttribute("Inconsistent treatment of line endings, don't use unless you absolutely wish to kill them.")]
public class JetBrains.Util.TextUtil : object {
    [ObsoleteAttribute("Inconsistent treatment of line endings, don't use unless you absolutely wish to kill them.")]
public static string ReadToEnd(TextReader reader);
}
public class JetBrains.Util.TimestampedValue`1 : object {
    private T myValue;
    private DateTime myLastEvaluated;
    private TimeSpan myUpdatePeriod;
    private Func`1<T> myEvaluator;
    public T Value { get; }
    public TimestampedValue`1(Func`1<T> evaluator, TimeSpan updatePeriod);
    public T get_Value();
}
public static class JetBrains.Util.ToolsetInfo : object {
    [NotNullAttribute]
public static FrameworkName CurrentDefaultTargetFx;
    [NotNullAttribute]
public static Version2 CurrentDevToolset;
    private static ToolsetInfo();
}
public class JetBrains.Util.TransactionCommitResult : object {
    [CompilerGeneratedAttribute]
private EnsureWritableResult <EnsureWritableResult>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EnsureWritableMessage>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Succeded>k__BackingField;
    public EnsureWritableResult EnsureWritableResult { get; private set; }
    public string EnsureWritableMessage { get; private set; }
    public bool Succeded { get; private set; }
    public TransactionCommitResult(EnsureWritableResult ensureWritableResult, string ensureWritableMessage, bool succeded);
    [CompilerGeneratedAttribute]
public EnsureWritableResult get_EnsureWritableResult();
    [CompilerGeneratedAttribute]
private void set_EnsureWritableResult(EnsureWritableResult value);
    [CompilerGeneratedAttribute]
public string get_EnsureWritableMessage();
    [CompilerGeneratedAttribute]
private void set_EnsureWritableMessage(string value);
    [CompilerGeneratedAttribute]
public bool get_Succeded();
    [CompilerGeneratedAttribute]
private void set_Succeded(bool value);
}
[ExtensionAttribute]
public static class JetBrains.Util.TraverseUtil : object {
    [ExtensionAttribute]
[NotNullAttribute]
public static IEnumerable`1<T> TraverseAcross(T first, Func`2<T, T> next);
    [NotNullAttribute]
[ExtensionAttribute]
public static IEnumerable`1<T> Traverse(IEnumerable`1<T> source, Func`2<T, IEnumerable`1<T>> selectChildren);
    [ExtensionAttribute]
public static TAccumulate TraverseAggregate(IEnumerable`1<T> source, Func`2<T, IEnumerable`1<T>> selectChildren, TAccumulate seed, Func`3<TAccumulate, T, TAccumulate> func);
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Util.TypeHierarchyMap`1 : object {
    private Dictionary`2<Type, TElement> myElements;
    public TElement Item { get; }
    public TElement get_Item(Type type);
    public sealed virtual IEnumerator`1<KeyValuePair`2<Type, TElement>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private TElement FindElement(Type type);
    private Type FindRegisteredType(Type type);
    public virtual void Add(Type type, TElement element);
    public virtual void Remove(Type type);
    protected virtual TElement GetElement(Type type);
    public virtual Type GetRegisteredType(Type type);
}
public class JetBrains.Util.TypeHierarchyMapCached`1 : TypeHierarchyMap`1<TElement> {
    private ConcurrentDictionary`2<Type, TElement> myElementCache;
    private ConcurrentDictionary`2<Type, Type> myTypeCache;
    public virtual void Add(Type type, TElement element);
    public virtual void Remove(Type type);
    public virtual Type GetRegisteredType(Type type);
    protected virtual TElement GetElement(Type type);
}
[ExtensionAttribute]
public static class JetBrains.Util.UriUtil : object {
    [NotNullAttribute]
[ExtensionAttribute]
public static Uri ToDirectoryUri(Uri uri);
}
public static class JetBrains.Util.UrlUtil : object {
    public static string Encode(string s, Encoding encoding);
    public static bool IsUnsafe(byte b);
}
public static class JetBrains.Util.Uuid : object {
    public static Guid NewUuid(Guid namespaceGuid, string value);
}
[ValueSerializerAttribute("JetBrains.Util.Version2/Version2Serializer")]
[PublicAPIAttribute]
[TypeConverterAttribute("JetBrains.Util.Version2/Version2Converter")]
public class JetBrains.Util.Version2 : object {
    private UInt32 major;
    private UInt32 minor;
    public UInt32 Major { get; }
    public UInt32 Minor { get; }
    public Version2(UInt32 nMajor, UInt32 nMinor);
    public Version2(Version version4);
    public UInt32 get_Major();
    public UInt32 get_Minor();
    public sealed virtual object Clone();
    public sealed virtual int CompareTo(Version2 value);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Version2 other);
    public virtual int GetHashCode();
    public sealed virtual int CompareTo(object obj);
    public static bool op_Equality(Version2 v1, Version2 v2);
    [ContractAnnotationAttribute("ver2:null => null; notnull => notnull")]
public static Version op_Explicit(Version2 ver2);
    [ContractAnnotationAttribute("ver:null => null; notnull => notnull")]
public static Version2 op_Explicit(Version ver);
    public static bool op_GreaterThan(Version2 v1, Version2 v2);
    public static bool op_GreaterThanOrEqual(Version2 v1, Version2 v2);
    public static bool op_Inequality(Version2 v1, Version2 v2);
    public static bool op_LessThan(Version2 v1, Version2 v2);
    public static bool op_LessThanOrEqual(Version2 v1, Version2 v2);
    public static Version2 Parse(string s);
    public virtual string ToString();
    [NotNullAttribute]
public Version ToVersion4WithMinusOnes();
    [NotNullAttribute]
public Version ToVersion4WithZeros();
    [CanBeNullAttribute]
public static Version2 TryParse(string s);
}
[ExtensionAttribute]
public static class JetBrains.Util.VersionExtensions : object {
    public static Version Empty;
    public static Version2 Empty2;
    private static VersionExtensions();
    [ExtensionAttribute]
public static bool IsNullOrEmpty(Version version);
    [ExtensionAttribute]
public static bool IsNullOrEmpty(Version2 version);
    [CanBeNullAttribute]
public static Version TryParseVersion(string str);
    [CanBeNullAttribute]
public static Version2 TryParseVersion2(string str);
    [ExtensionAttribute]
public static Version Clone(Version version, int fieldCount);
    [ExtensionAttribute]
public static string ToStringWithNoZerosForBuildAndRevision(Version version);
}
public class JetBrains.Util.WaveInfo : object {
    public static int NumberCompiler;
    public static string PackageName;
    public static WaveInfo Current;
    public UInt32 Number;
    public WaveInfo(UInt32 number);
    private static WaveInfo();
    public Version2 AsVersion2();
    public Version AsVersion4();
    public JetSemanticVersion AsVersionSemantic();
    public virtual string ToString();
}
[ExtensionAttribute]
public static class JetBrains.Util.WaveInfoEx : object {
    public static UInt32 BaseMajorForWavedAssemblyVersion;
    private static WaveInfoEx();
    [NotNullAttribute]
[ExtensionAttribute]
public static Version2 GetDefaultAssemblyVersion(WaveInfo ths);
}
public class JetBrains.Util.WeakCollection`1 : object {
    private static Statistics Statistics;
    private WeakHolder`1[] myArray;
    private int myFirstFreeIndex;
    private int myNextSize;
    private int myVersion;
    public int Capacity { get; }
    public bool IsEmpty { get; }
    public WeakCollection`1(ICollection`1<T> collection);
    private static WeakCollection`1();
    public int get_Capacity();
    public bool get_IsEmpty();
    public int CountLive();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    public ElementEnumerator<T> GetEnumerator();
    public void Add(T item);
    public bool Remove(T item);
    public bool Contains(T item);
    public T[] ToArray();
    public List`1<T> ToList();
    public void CopyTo(T[] array, int arrayIndex);
    public void Clear();
    public sealed virtual void Dispose();
    protected virtual void Finalize();
    public T First();
    public T First(Func`2<T, bool> predicate);
    public T Last();
    public T Last(Func`2<T, bool> predicate);
    private void SweepCore();
    public void Sweep();
}
public class JetBrains.Util.WeakHashSet`1 : object {
    private static Statistics Statistics;
    private IEqualityComparer`1<T> myComparer;
    private Entry[] myEntries;
    private int myEntriesUsed;
    private int myFirstFreeIndex;
    private int myFreeCount;
    private Int32[] myHashToEntryIndex;
    private int myVersion;
    public IEqualityComparer`1<T> Comparer { get; }
    public int Capacity { get; }
    public WeakHashSet`1(IEnumerable`1<T> enumerable);
    public WeakHashSet`1(IEqualityComparer`1<T> comparer);
    public WeakHashSet`1(int capacity);
    public WeakHashSet`1(IEnumerable`1<T> enumerable, IEqualityComparer`1<T> comparer);
    [EditorBrowsableAttribute("1")]
public WeakHashSet`1(ICollection`1<T> enumerable, IEqualityComparer`1<T> comparer);
    public WeakHashSet`1(int capacity, IEqualityComparer`1<T> comparer);
    private static WeakHashSet`1();
    public IEqualityComparer`1<T> get_Comparer();
    public int get_Capacity();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public bool Add(T key);
    public bool Remove(T key);
    public void Clear();
    public bool Contains(T key);
    [CanBeNullAttribute]
public T TryGetExisting(T key);
    public void Sweep();
    public sealed virtual void Dispose();
    public ElementEnumerator<T> GetEnumerator();
    protected virtual void Finalize();
    private void RemoveEntry(int entryIndex);
    private bool CompareKeyRemoveIfDead(T key, int entryIndex);
    private int FindEntry(T key);
    private void Initialize(int capacity);
    private void Resize();
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Util.WeakToStrongDictionary`2 : object {
    private static Statistics Statistics;
    private IEqualityComparer`1<TKey> myComparer;
    private Entry[] myEntries;
    private int myEntriesUsed;
    private int myFirstFreeIndex;
    private int myFreeCount;
    private Int32[] myHashToEntryIndex;
    private KeyCollection<TKey, TValue> myKeys;
    private ValueCollection<TKey, TValue> myValues;
    private int myVersion;
    public IEqualityComparer`1<TKey> Comparer { get; }
    public KeyCollection<TKey, TValue> Keys { get; }
    [NotNullAttribute]
public ValueCollection<TKey, TValue> Values { get; }
    public int Capacity { get; }
    public TValue Item { get; public set; }
    public WeakToStrongDictionary`2(IDictionary`2<TKey, TValue> dictionary);
    public WeakToStrongDictionary`2(IEqualityComparer`1<TKey> comparer);
    public WeakToStrongDictionary`2(int capacity);
    public WeakToStrongDictionary`2(IDictionary`2<TKey, TValue> dictionary, IEqualityComparer`1<TKey> comparer);
    public WeakToStrongDictionary`2(int capacity, IEqualityComparer`1<TKey> comparer);
    private static WeakToStrongDictionary`2();
    public IEqualityComparer`1<TKey> get_Comparer();
    public KeyCollection<TKey, TValue> get_Keys();
    public ValueCollection<TKey, TValue> get_Values();
    public int get_Capacity();
    public void Add(TKey key, TValue value);
    public bool Remove(TKey key);
    public void Clear();
    public bool ContainsKey(TKey key);
    public bool ContainsValue(TValue value);
    public TValue get_Item(TKey key);
    public void set_Item(TKey key, TValue value);
    public bool TryGetValue(TKey key, TValue& value);
    public void Sweep();
    public sealed virtual void Dispose();
    private sealed virtual override IEnumerator`1<KeyValuePair`2<TKey, TValue>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TValue>>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public PairEnumerator<TKey, TValue> GetEnumerator();
    protected virtual void Finalize();
    private void RemoveEntry(int entryIndex);
    private bool CompareKeyRemoveIfDead(TKey key, int entryIndex);
    private int FindEntry(TKey key);
    private void Initialize(int capacity);
    private void Insert(TKey key, TValue value, bool add);
    private void Resize();
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Util.WeakToWeakDictionary`2 : object {
    private static Statistics Statistics;
    private static object NullObject;
    private IEqualityComparer`1<TKey> myComparer;
    private Entry[] myEntries;
    private int myEntriesUsed;
    private int myFirstFreeIndex;
    private int myFreeCount;
    private Int32[] myHashToEntryIndex;
    private KeyCollection<TKey, TValue> myKeys;
    private ValueCollection<TKey, TValue> myValues;
    private int myVersion;
    public IEqualityComparer`1<TKey> Comparer { get; }
    public KeyCollection<TKey, TValue> Keys { get; }
    public ValueCollection<TKey, TValue> Values { get; }
    public int Capacity { get; }
    public TValue Item { get; public set; }
    public WeakToWeakDictionary`2(IDictionary`2<TKey, TValue> dictionary);
    public WeakToWeakDictionary`2(IEqualityComparer`1<TKey> comparer);
    public WeakToWeakDictionary`2(int capacity);
    public WeakToWeakDictionary`2(IDictionary`2<TKey, TValue> dictionary, IEqualityComparer`1<TKey> comparer);
    public WeakToWeakDictionary`2(int capacity, IEqualityComparer`1<TKey> comparer);
    private static WeakToWeakDictionary`2();
    public IEqualityComparer`1<TKey> get_Comparer();
    public KeyCollection<TKey, TValue> get_Keys();
    public ValueCollection<TKey, TValue> get_Values();
    public int get_Capacity();
    public void Add(TKey key, TValue value);
    public void Clear();
    public bool ContainsKey(TKey key);
    public bool ContainsValue(TValue value);
    public bool Remove(TKey key);
    public TValue get_Item(TKey key);
    public void set_Item(TKey key, TValue value);
    public bool TryGetValue(TKey key, TValue& value);
    private sealed virtual override IEnumerator`1<KeyValuePair`2<TKey, TValue>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TValue>>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public PairEnumerator<TKey, TValue> GetEnumerator();
    public sealed virtual void Dispose();
    protected virtual void Finalize();
    private static TValue FixValue(object value);
    private void RemoveEntry(int entryIndex);
    private bool CompareKeyOptionallyRemoveIfDead(TKey key, int entryIndex, bool removeIfDead, TValue& value);
    private int FindEntry(TKey key, TValue& value);
    private void Initialize(int capacity);
    private void Insert(TKey key, TValue value, bool add);
    private void Resize();
    public void Sweep();
}
public class JetBrains.Util.XMath.BigInteger : object {
    private static int maxLength;
    public static BigInteger Zero;
    public static Int32[] primesBelow100000;
    private UInt32[] data;
    public int dataLength;
    public BigInteger(long value);
    public BigInteger(ulong value);
    public BigInteger(BigInteger bi);
    public BigInteger(string value, int radix);
    public BigInteger(Byte[] inData);
    public BigInteger(Byte[] inData, int inLen);
    public BigInteger(UInt32[] inData);
    private static BigInteger();
    public static BigInteger op_Implicit(long value);
    public static BigInteger op_Implicit(ulong value);
    public static BigInteger op_Implicit(int value);
    public static BigInteger op_Implicit(UInt32 value);
    public static BigInteger op_Addition(BigInteger bi1, BigInteger bi2);
    public static BigInteger op_Increment(BigInteger bi1);
    public static BigInteger op_Subtraction(BigInteger bi1, BigInteger bi2);
    public static BigInteger op_Decrement(BigInteger bi1);
    public static BigInteger op_Multiply(BigInteger bi1, BigInteger bi2);
    public static BigInteger op_LeftShift(BigInteger bi1, int shiftVal);
    private static int shiftLeft(UInt32[] buffer, int shiftVal);
    public static BigInteger op_RightShift(BigInteger bi1, int shiftVal);
    private static int shiftRight(UInt32[] buffer, int shiftVal);
    public static BigInteger op_OnesComplement(BigInteger bi1);
    public static BigInteger op_UnaryNegation(BigInteger bi1);
    public static bool op_Equality(BigInteger bi1, BigInteger bi2);
    public static bool op_Inequality(BigInteger bi1, BigInteger bi2);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public static bool op_GreaterThan(BigInteger bi1, BigInteger bi2);
    public static bool op_LessThan(BigInteger bi1, BigInteger bi2);
    public static bool op_GreaterThanOrEqual(BigInteger bi1, BigInteger bi2);
    public static bool op_LessThanOrEqual(BigInteger bi1, BigInteger bi2);
    private static void multiByteDivide(BigInteger bi1, BigInteger bi2, BigInteger outQuotient, BigInteger outRemainder);
    private static void singleByteDivide(BigInteger bi1, BigInteger bi2, BigInteger outQuotient, BigInteger outRemainder);
    public static BigInteger op_Division(BigInteger bi1, BigInteger bi2);
    public static BigInteger op_Modulus(BigInteger bi1, BigInteger bi2);
    public static BigInteger op_BitwiseAnd(BigInteger bi1, BigInteger bi2);
    public static BigInteger op_BitwiseOr(BigInteger bi1, BigInteger bi2);
    public static BigInteger op_ExclusiveOr(BigInteger bi1, BigInteger bi2);
    public BigInteger max(BigInteger bi);
    public BigInteger min(BigInteger bi);
    public BigInteger abs();
    public virtual string ToString();
    public string ToString(int radix);
    public string ToHexString();
    public BigInteger modPow(BigInteger exp, BigInteger n);
    private BigInteger BarrettReduction(BigInteger x, BigInteger n, BigInteger constant);
    public BigInteger gcd(BigInteger bi);
    public void genRandomBits(int bits, Random rand);
    public int bitCount();
    public bool FermatLittleTest(int confidence);
    public bool RabinMillerTest(int confidence);
    public bool SolovayStrassenTest(int confidence);
    public bool LucasStrongTest();
    private bool LucasStrongTestHelper(BigInteger thisVal);
    public bool isProbablePrime(int confidence);
    public bool isProbablePrime();
    public static bool IsDivisibleByFirstPrimes(BigInteger thisVal);
    public int IntValue();
    public long LongValue();
    public static int Jacobi(BigInteger a, BigInteger b);
    public static BigInteger genPseudoPrime(int bits, int confidence, Random rand);
    public BigInteger genCoPrime(int bits, Random rand);
    public BigInteger modInverse(BigInteger modulus);
    public Byte[] getBytes();
    public void setBit(UInt32 bitNum);
    public void unsetBit(UInt32 bitNum);
    public BigInteger sqrt();
    public static BigInteger[] LucasSequence(BigInteger P, BigInteger Q, BigInteger k, BigInteger n);
    private static BigInteger[] LucasSequenceHelper(BigInteger P, BigInteger Q, BigInteger k, BigInteger n, BigInteger constant, int s);
    public static void MulDivTest(int rounds);
    public static void RSATest(int rounds);
    public static void RSATest2(int rounds);
    public static void SqrtTest(int rounds);
}
public static class JetBrains.Util.XMath.StringToBytesConverter : object {
    public static Byte[] Unicode(string s);
    public static Byte[] Utf8(string s);
    public static Byte[] Ascii(string s);
    public static Byte[] Old(string s);
}
[ExtensionAttribute]
public static class JetBrains.Util.XmlEscape : object {
    [PureAttribute]
[CanBeNullAttribute]
private static string EscapeChar(char c);
    [NotNullAttribute]
[PureAttribute]
public static string AttributeValue(string value, char quotes);
    [PureAttribute]
[NotNullAttribute]
public static string Content(string value);
    [PureAttribute]
[NotNullAttribute]
public static string MarkupExtensionAttributeValue(string value, bool wrapInQuotes);
    [PureAttribute]
[NotNullAttribute]
[ExtensionAttribute]
public static StringBuilder AppendXmlAttributeValue(StringBuilder builder, string value);
}
[ExtensionAttribute]
public static class JetBrains.Util.XmlReaderEx : object {
    [ExtensionAttribute]
public static void AssertAtElement(XmlReader reader, string sElementName);
    [ExtensionAttribute]
public static void KeepDepth(XmlReader reader, Action action);
    [ExtensionAttribute]
public static void KeepParentDepth(XmlReader reader, Action action);
    [ExtensionAttribute]
public static void ReadElement(XmlReader reader, Action`1<XmlReader> funcElem);
    [ExtensionAttribute]
public static void ReadElementChildren(XmlReader reader, Action`1<XmlReader> funcChild);
    [ExtensionAttribute]
public static void ReadSiblingElements(XmlReader reader, Action`1<XmlReader> funcElem);
    [ExtensionAttribute]
public static void ReadSubElements(XmlReader reader, Action`1<XmlReader> action);
    [ExtensionAttribute]
public static bool ReadToElementStart(XmlReader reader);
    [ExtensionAttribute]
public static bool ReadToElementStart(XmlReader reader, int depth);
    private static void KeepReaderDepthCore(XmlReader reader, Action action, int depth);
    [ExtensionAttribute]
public static void ReadXml(Stream stream, Action`1<XmlReader> FRead);
    [ExtensionAttribute]
public static void ReadXml(Stream stream, XmlReaderSettings settings, Action`1<XmlReader> FRead);
    [ExtensionAttribute]
public static void AddLineColumnData(IXmlLineInfo ths, Exception ex);
    [ExtensionAttribute]
public static void AddLineColumnData(XmlReader ths, Exception ex);
}
public static class JetBrains.Util.XmlUnescape : object {
    [PureAttribute]
private static char UnescapeChar(string str, int index, Int32& length);
    [PureAttribute]
[NotNullAttribute]
public static string Value(string value);
    [NotNullAttribute]
[PureAttribute]
public static string MarkupExtensionValue(string value);
}
[GuidAttribute("6380BCFF-41D3-4B2E-8B2E-BF8A6810C848")]
[InterfaceTypeAttribute("1")]
[NoReorderAttribute]
internal interface Microsoft.VisualStudio.Setup.Configuration.IEnumSetupInstances {
    public abstract virtual void Next(int celt, ISetupInstance[] rgelt, Int32& pceltFetched);
    public abstract virtual void Skip(int celt);
    public abstract virtual void Reset();
    public abstract virtual IEnumSetupInstances Clone();
}
[NoReorderAttribute]
[FlagsAttribute]
internal enum Microsoft.VisualStudio.Setup.Configuration.InstanceState : Enum {
    public UInt32 value__;
    public static InstanceState None;
    public static InstanceState Local;
    public static InstanceState Registered;
    public static InstanceState NoRebootRequired;
    public static InstanceState NoErrors;
    public static InstanceState Complete;
}
[GuidAttribute("42843719-DB4C-46C2-8E7C-64F1816EFD5B")]
[NoReorderAttribute]
[InterfaceTypeAttribute("1")]
internal interface Microsoft.VisualStudio.Setup.Configuration.ISetupConfiguration {
    public abstract virtual IEnumSetupInstances EnumInstances();
    public abstract virtual ISetupInstance GetInstanceForCurrentProcess();
    public abstract virtual ISetupInstance GetInstanceForPath(string path);
}
[GuidAttribute("26AAB78C-4A60-49D6-AF3B-3C35BC93365D")]
[NoReorderAttribute]
[InterfaceTypeAttribute("1")]
internal interface Microsoft.VisualStudio.Setup.Configuration.ISetupConfiguration2 {
    public abstract virtual IEnumSetupInstances EnumInstances();
    public abstract virtual ISetupInstance GetInstanceForCurrentProcess();
    public abstract virtual ISetupInstance GetInstanceForPath(string path);
    public abstract virtual IEnumSetupInstances EnumAllInstances();
}
[NoReorderAttribute]
[GuidAttribute("46DCCD94-A287-476A-851E-DFBC2FFDBC20")]
[InterfaceTypeAttribute("1")]
internal interface Microsoft.VisualStudio.Setup.Configuration.ISetupErrorState {
    public abstract virtual ISetupFailedPackageReference[] GetFailedPackages();
    public abstract virtual ISetupPackageReference[] GetSkippedPackages();
}
[InterfaceTypeAttribute("1")]
[NoReorderAttribute]
[GuidAttribute("E73559CD-7003-4022-B134-27DC650B280F")]
internal interface Microsoft.VisualStudio.Setup.Configuration.ISetupFailedPackageReference {
    public abstract virtual string GetId();
    public abstract virtual string GetVersion();
    public abstract virtual string GetChip();
    public abstract virtual string GetLanguage();
    public abstract virtual string GetBranch();
    public abstract virtual string GetType();
    public abstract virtual string GetUniqueId();
    public abstract virtual bool GetIsExtension();
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("42B21B78-6192-463E-87BF-D577838F1D5C")]
[NoReorderAttribute]
internal interface Microsoft.VisualStudio.Setup.Configuration.ISetupHelper {
    public abstract virtual ulong ParseVersion(string version);
    public abstract virtual void ParseVersionRange(string versionRange, UInt64& minVersion, UInt64& maxVersion);
}
[NoReorderAttribute]
[GuidAttribute("B41463C3-8866-43B5-BC33-2B0676F7F42E")]
[InterfaceTypeAttribute("1")]
internal interface Microsoft.VisualStudio.Setup.Configuration.ISetupInstance {
    public abstract virtual string GetInstanceId();
    public abstract virtual FILETIME GetInstallDate();
    public abstract virtual string GetInstallationName();
    public abstract virtual string GetInstallationPath();
    public abstract virtual string GetInstallationVersion();
    public abstract virtual string GetDisplayName(int lcid);
    public abstract virtual string GetDescription(int lcid);
    public abstract virtual string ResolvePath(string pwszRelativePath);
}
[InterfaceTypeAttribute("1")]
[NoReorderAttribute]
[GuidAttribute("89143C9A-05AF-49B0-B717-72E218A2185C")]
internal interface Microsoft.VisualStudio.Setup.Configuration.ISetupInstance2 {
    public abstract virtual string GetInstanceId();
    public abstract virtual FILETIME GetInstallDate();
    public abstract virtual string GetInstallationName();
    public abstract virtual string GetInstallationPath();
    public abstract virtual string GetInstallationVersion();
    public abstract virtual string GetDisplayName(int lcid);
    public abstract virtual string GetDescription(int lcid);
    public abstract virtual string ResolvePath(string pwszRelativePath);
    public abstract virtual InstanceState GetState();
    public abstract virtual ISetupPackageReference[] GetPackages();
    public abstract virtual ISetupPackageReference GetProduct();
    public abstract virtual string GetProductPath();
    public abstract virtual ISetupErrorState GetErrors();
    public abstract virtual bool IsLaunchable();
    public abstract virtual bool IsComplete();
    public abstract virtual ISetupPropertyStore GetProperties();
    public abstract virtual string GetEnginePath();
}
[InterfaceTypeAttribute("1")]
[NoReorderAttribute]
[GuidAttribute("DA8D8A16-B2B6-4487-A2F1-594CCCCD6BF5")]
internal interface Microsoft.VisualStudio.Setup.Configuration.ISetupPackageReference {
    public abstract virtual string GetId();
    public abstract virtual string GetVersion();
    public abstract virtual string GetChip();
    public abstract virtual string GetLanguage();
    public abstract virtual string GetBranch();
    public abstract virtual string GetType();
    public abstract virtual string GetUniqueId();
    public abstract virtual bool GetIsExtension();
}
[GuidAttribute("c601c175-a3be-44bc-91f6-4568d230fc83")]
[InterfaceTypeAttribute("1")]
[NoReorderAttribute]
internal interface Microsoft.VisualStudio.Setup.Configuration.ISetupPropertyStore {
    public abstract virtual String[] GetNames();
    public abstract virtual object GetValue(string pwszName);
}
[TypeLibImportClassAttribute("Microsoft.VisualStudio.Setup.Configuration.SetupConfigurationClass")]
[NoReorderAttribute]
[CoClassAttribute("Microsoft.VisualStudio.Setup.Configuration.SetupConfigurationClass")]
[GuidAttribute("42843719-DB4C-46C2-8E7C-64F1816EFD5B")]
internal interface Microsoft.VisualStudio.Setup.Configuration.SetupConfiguration {
}
[NoReorderAttribute]
[ClassInterfaceAttribute("0")]
[GuidAttribute("177F0C4A-1CD3-4DE7-A32C-71DBBB9FA36D")]
internal class Microsoft.VisualStudio.Setup.Configuration.SetupConfigurationClass : object {
}
public static class MimeTypes.MimeTypeMap : object {
    private static Lazy`1<IDictionary`2<string, string>> _mappings;
    private static MimeTypeMap();
    private static IDictionary`2<string, string> BuildMappings();
    [CanBeNullAttribute]
public static string GetMimeType(string extension);
    public static string GetExtension(string mimeType);
}
[FlagsAttribute]
public enum System.GAC.ASM_CACHE_FLAGS : Enum {
    public int value__;
    public static ASM_CACHE_FLAGS ASM_CACHE_ZAP;
    public static ASM_CACHE_FLAGS ASM_CACHE_GAC;
    public static ASM_CACHE_FLAGS ASM_CACHE_DOWNLOAD;
}
[FlagsAttribute]
public enum System.GAC.ASM_CMP_FLAGS : Enum {
    public int value__;
    public static ASM_CMP_FLAGS NAME;
    public static ASM_CMP_FLAGS MAJOR_VERSION;
    public static ASM_CMP_FLAGS MINOR_VERSION;
    public static ASM_CMP_FLAGS BUILD_NUMBER;
    public static ASM_CMP_FLAGS REVISION_NUMBER;
    public static ASM_CMP_FLAGS PUBLIC_KEY_TOKEN;
    public static ASM_CMP_FLAGS CULTURE;
    public static ASM_CMP_FLAGS CUSTOM;
    public static ASM_CMP_FLAGS ALL;
    public static ASM_CMP_FLAGS DEFAULT;
}
[FlagsAttribute]
public enum System.GAC.ASM_DISPLAY_FLAGS : Enum {
    public int value__;
    public static ASM_DISPLAY_FLAGS VERSION;
    public static ASM_DISPLAY_FLAGS CULTURE;
    public static ASM_DISPLAY_FLAGS PUBLIC_KEY_TOKEN;
    public static ASM_DISPLAY_FLAGS PUBLIC_KEY;
    public static ASM_DISPLAY_FLAGS CUSTOM;
    public static ASM_DISPLAY_FLAGS PROCESSORARCHITECTURE;
    public static ASM_DISPLAY_FLAGS LANGUAGEID;
}
public enum System.GAC.ASM_NAME : Enum {
    public int value__;
    public static ASM_NAME ASM_NAME_PUBLIC_KEY;
    public static ASM_NAME ASM_NAME_PUBLIC_KEY_TOKEN;
    public static ASM_NAME ASM_NAME_HASH_VALUE;
    public static ASM_NAME ASM_NAME_NAME;
    public static ASM_NAME ASM_NAME_MAJOR_VERSION;
    public static ASM_NAME ASM_NAME_MINOR_VERSION;
    public static ASM_NAME ASM_NAME_BUILD_NUMBER;
    public static ASM_NAME ASM_NAME_REVISION_NUMBER;
    public static ASM_NAME ASM_NAME_CULTURE;
    public static ASM_NAME ASM_NAME_PROCESSOR_ID_ARRAY;
    public static ASM_NAME ASM_NAME_OSINFO_ARRAY;
    public static ASM_NAME ASM_NAME_HASH_ALGID;
    public static ASM_NAME ASM_NAME_ALIAS;
    public static ASM_NAME ASM_NAME_CODEBASE_URL;
    public static ASM_NAME ASM_NAME_CODEBASE_LASTMOD;
    public static ASM_NAME ASM_NAME_NULL_PUBLIC_KEY;
    public static ASM_NAME ASM_NAME_NULL_PUBLIC_KEY_TOKEN;
    public static ASM_NAME ASM_NAME_CUSTOM;
    public static ASM_NAME ASM_NAME_NULL_CUSTOM;
    public static ASM_NAME ASM_NAME_MVID;
    public static ASM_NAME ASM_NAME_MAX_PARAMS;
}
public class System.GAC.ASSEMBLY_INFO : ValueType {
    public UInt32 cbAssemblyInfo;
    public UInt32 dwAssemblyFlags;
    public ulong uliAssemblySizeInKB;
    public string pszCurrentAssemblyPathBuf;
    public UInt32 cchBuf;
}
public class System.GAC.AssemblyCache : object {
    public static Guid FUSION_REFCOUNT_UNINSTALL_SUBKEY_GUID { get; }
    public static Guid FUSION_REFCOUNT_FILEPATH_GUID { get; }
    public static Guid FUSION_REFCOUNT_OPAQUE_STRING_GUID { get; }
    public static Guid FUSION_REFCOUNT_MSI_GUID { get; }
    private static void CreateAssemblyCache(IAssemblyCache& ppAsmCache, UInt32 dwReserved);
    private static void CreateAssemblyNameObject(IAssemblyName& ppAssemblyNameObj, string szAssemblyName, UInt32 dwFlags, IntPtr pvReserved);
    private static void CreateAssemblyEnum(IAssemblyEnum& pEnum, IntPtr pUnkReserved, IAssemblyName pName, ASM_CACHE_FLAGS dwFlags, IntPtr pvReserved);
    private static void CreateInstallReferenceEnum(IInstallReferenceEnum& ppRefEnum, IAssemblyName pName, UInt32 dwFlags, IntPtr pvReserved);
    private static void GetCachePath(ASM_CACHE_FLAGS dwCacheFlags, StringBuilder pwzCachePath, UInt32& pcchPath);
    public static Guid get_FUSION_REFCOUNT_UNINSTALL_SUBKEY_GUID();
    public static Guid get_FUSION_REFCOUNT_FILEPATH_GUID();
    public static Guid get_FUSION_REFCOUNT_OPAQUE_STRING_GUID();
    public static Guid get_FUSION_REFCOUNT_MSI_GUID();
    public static IAssemblyCache CreateAssemblyCache();
    public static IAssemblyName CreateAssemblyName(string name);
    public static string GetDisplayName(IAssemblyName name, ASM_DISPLAY_FLAGS which);
    public static string GetName(IAssemblyName name);
    public static Version GetVersion(IAssemblyName name);
    public static Byte[] GetPublicKeyToken(IAssemblyName name);
    public static Byte[] GetPublicKey(IAssemblyName name);
    public static CultureInfo GetCulture(IAssemblyName name);
    public static IAssemblyEnum CreateGACEnum();
    public static int GetNextAssembly(IAssemblyEnum enumerator, IAssemblyName& name);
    public static string GetGACPath();
    public static string GetZapPath();
    public static string GetDownloadPath();
}
public enum System.GAC.CREATE_ASM_NAME_OBJ_FLAGS : Enum {
    public int value__;
    public static CREATE_ASM_NAME_OBJ_FLAGS CANOF_PARSE_DISPLAY_NAME;
    public static CREATE_ASM_NAME_OBJ_FLAGS CANOF_SET_DEFAULT_VALUES;
}
public class System.GAC.FUSION_INSTALL_REFERENCE : ValueType {
    public UInt32 cbSize;
    public UInt32 dwFlags;
    public Guid guidScheme;
    public string szIdentifier;
    public string szNonCannonicalData;
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("e707dcde-d1cd-11d2-bab9-00c04f8eceae")]
public interface System.GAC.IAssemblyCache {
    public abstract virtual int UninstallAssembly(UInt32 dwFlags, string pszAssemblyName, FUSION_INSTALL_REFERENCE[] pRefData, UInt32& pulDisposition);
    public abstract virtual int QueryAssemblyInfo(UInt32 dwFlags, string pszAssemblyName, ASSEMBLY_INFO& pAsmInfo);
    public abstract virtual int CreateAssemblyCacheItem(UInt32 dwFlags, IntPtr pvReserved, IAssemblyCacheItem& ppAsmItem, string pszAssemblyName);
    public abstract virtual int CreateAssemblyScavenger(Object& ppAsmScavenger);
    public abstract virtual int InstallAssembly(UInt32 dwFlags, string pszManifestFilePath, FUSION_INSTALL_REFERENCE[] pRefData);
}
public enum System.GAC.IASSEMBLYCACHE_INSTALL_FLAG : Enum {
    public int value__;
    public static IASSEMBLYCACHE_INSTALL_FLAG IASSEMBLYCACHE_INSTALL_FLAG_REFRESH;
    public static IASSEMBLYCACHE_INSTALL_FLAG IASSEMBLYCACHE_INSTALL_FLAG_FORCE_REFRESH;
}
public enum System.GAC.IASSEMBLYCACHE_UNINSTALL_DISPOSITION : Enum {
    public int value__;
    public static IASSEMBLYCACHE_UNINSTALL_DISPOSITION IASSEMBLYCACHE_UNINSTALL_DISPOSITION_UNINSTALLED;
    public static IASSEMBLYCACHE_UNINSTALL_DISPOSITION IASSEMBLYCACHE_UNINSTALL_DISPOSITION_STILL_IN_USE;
    public static IASSEMBLYCACHE_UNINSTALL_DISPOSITION IASSEMBLYCACHE_UNINSTALL_DISPOSITION_ALREADY_UNINSTALLED;
    public static IASSEMBLYCACHE_UNINSTALL_DISPOSITION IASSEMBLYCACHE_UNINSTALL_DISPOSITION_DELETE_PENDING;
    public static IASSEMBLYCACHE_UNINSTALL_DISPOSITION IASSEMBLYCACHE_UNINSTALL_DISPOSITION_HAS_INSTALL_REFERENCES;
    public static IASSEMBLYCACHE_UNINSTALL_DISPOSITION IASSEMBLYCACHE_UNINSTALL_DISPOSITION_REFERENCE_NOT_FOUND;
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("9E3AAEB4-D1CD-11D2-BAB9-00C04F8ECEAE")]
public interface System.GAC.IAssemblyCacheItem {
    public abstract virtual void CreateStream(UInt32 dwFlags, string pszStreamName, UInt32 dwFormat, UInt32 dwFormatFlags, IStream& ppIStream, Int64& puliMaxSize);
    public abstract virtual void Commit(UInt32 dwFlags, Int64& pulDisposition);
    public abstract virtual void AbortItem();
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("21b8916c-f28e-11d2-a473-00c04f8ef448")]
public interface System.GAC.IAssemblyEnum {
    public abstract virtual int GetNextAssembly(IntPtr pvReserved, IAssemblyName& ppName, UInt32 dwFlags);
    public abstract virtual int Reset();
    public abstract virtual int Clone(IAssemblyEnum& ppEnum);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("CD193BC0-B4BC-11d2-9833-00C04FC31D2E")]
public interface System.GAC.IAssemblyName {
    public abstract virtual int SetProperty(ASM_NAME propertyId, IntPtr pvProperty, UInt32 cbProperty);
    public abstract virtual int GetProperty(ASM_NAME propertyId, IntPtr pvProperty, UInt32& pcbProperty);
    public abstract virtual int Finalize();
    public abstract virtual int GetDisplayName(StringBuilder szDisplayName, UInt32& pccDisplayName, ASM_DISPLAY_FLAGS dwDisplayFlags);
    public abstract virtual int BindToObject(Guid& refIID, object pUnkSink, object pUnkContext, string szCodeBase, long llFlags, IntPtr pvReserved, UInt32 cbReserved, IntPtr& ppv);
    public abstract virtual int GetName(UInt32& lpcwBuffer, StringBuilder pwzName);
    public abstract virtual int GetVersion(UInt32& pdwVersionHi, UInt32& pdwVersionLow);
    public abstract virtual int IsEqual(IAssemblyName pName, ASM_CMP_FLAGS dwCmpFlags);
    public abstract virtual int Clone(IAssemblyName& pName);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("56b1a988-7c0c-4aa2-8639-c3eb5a90226f")]
public interface System.GAC.IInstallReferenceEnum {
    public abstract virtual int GetNextInstallReferenceItem(IInstallReferenceItem& ppRefItem, UInt32 dwFlags, IntPtr pvReserved);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("582dac66-e678-449f-aba6-6faaec8a9394")]
public interface System.GAC.IInstallReferenceItem {
    public abstract virtual int GetReference(FUSION_INSTALL_REFERENCE[]& ppRefData, UInt32 dwFlags, IntPtr pvReserved);
}
public enum System.GAC.QUERYASMINFO_FLAG : Enum {
    public int value__;
    public static QUERYASMINFO_FLAG QUERYASMINFO_FLAG_VALIDATE;
    public static QUERYASMINFO_FLAG QUERYASMINFO_FLAG_GETSIZE;
}
public class System.JetAction`5 : MulticastDelegate {
    public JetAction`5(object object, IntPtr method);
    public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
