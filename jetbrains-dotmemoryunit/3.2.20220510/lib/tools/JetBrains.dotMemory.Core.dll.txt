[DefaultMemberAttribute("Item")]
public class JetBrains.dotMemory.Core.AlmostOneValueArray : object {
    private int myOneValue;
    private Dictionary`2<int, int> myOtherValues;
    private int myLength;
    public int Length { get; }
    public int Item { get; public set; }
    public AlmostOneValueArray(int oneValue, int length);
    public int get_Length();
    public int get_Item(int index);
    public void set_Item(int index, int value);
}
[DefaultMemberAttribute("Item")]
public class JetBrains.dotMemory.Core.AlmostOneValueArray`1 : object {
    private T myMostPopularValue;
    private Dictionary`2<int, T> myOtherValues;
    private int myLength;
    public int Length { get; }
    public T Item { get; public set; }
    public AlmostOneValueArray`1(T mostPopularValue, int length);
    public int get_Length();
    public T get_Item(int index);
    public void set_Item(int index, T value);
}
public class JetBrains.dotMemory.Core.ArrayTrie`1 : object {
    private ChunkList`1<Element`1<TValue>> myArray;
    private int myArrayCount;
    public int Count { get; }
    public int get_Count();
    public void Add(ulong key, TValue value);
    public TValue Find(ulong key);
}
public static class JetBrains.dotMemory.Core.BytesCountToSizeString : object {
    private static long Byte;
    private static long Kilobyte;
    private static long Megabyte;
    private static long Gigabyte;
    private static long Terabyte;
    private static long Threshold;
    private static int BytePrecision;
    private static int KbPrecision;
    private static int DefaultPrecision;
    public static string Convert(long bytesCount);
    public static string ConvertPrecisely(long bytesCount);
    private static string FormatValue(long value, long divider, int precision);
}
[DefaultMemberAttribute("Item")]
public class JetBrains.dotMemory.Core.ChunkRangeArray : object {
    private List`1<RangeArray> myRangeArrays;
    private int myMaxSumInChunk;
    private int myLogMaxSumInChunk;
    private RangeArray myRangeArray;
    private int myLastRangeArrayIndex;
    private int mySum;
    public int Item { get; }
    public bool Add(int value);
    public int get_Item(int index);
}
public static class JetBrains.dotMemory.Core.Collection : object {
    public static ListEvents`1<T> CreateList(ReadonlyToken readonlyToken);
    public static DictionaryEvents`2<TKey, TValue> CreateDictionary(ReadonlyToken readonlyToken);
}
[ExtensionAttribute]
public static class JetBrains.dotMemory.Core.CollectionDataProvidersExtension : object {
    private static string Id;
    private static CollectionDataProvidersExtension();
    [ExtensionAttribute]
public static IDictionaryEvents`2<TTargetKey, TTargetValue> TransformEachItem(IDictionaryEvents`2<TSourceKey, TSourceValue> source, Lifetime lifetime, Func`2<KeyValuePair`2<TSourceKey, TSourceValue>, KeyValuePair`2<TTargetKey, TTargetValue>> transform);
    [ExtensionAttribute]
public static IReadonlyListEvents`1<TTarget> TransformEachItem(IDictionaryEvents`2<TSourceKey, TSourceValue> source, Lifetime lifetime, Func`2<KeyValuePair`2<TSourceKey, TSourceValue>, TTarget> transform);
    [ExtensionAttribute]
public static IReadonlyListEvents`1<TTarget> TransformEachItem(IReadonlyCollectionEvents`1<TSource> source, Lifetime lifetime, Pipeline`2<TSource, TTarget> transformPipeline, Func`2<TSource, bool> filter);
    [ExtensionAttribute]
public static IReadonlyListEvents`1<T> TransformReverse(IReadonlyListEvents`1<T> source, Lifetime lifetime, Func`2<T, bool> filter);
    [ExtensionAttribute]
public static IReadonlyListEvents`1<TTarget> CastEachItem(IReadonlyCollectionEvents`1<TSource> source, Lifetime lifetime);
    [ExtensionAttribute]
public static IReadonlyListEvents`1<TTarget> TransformEachItem(IReadonlyCollectionEvents`1<TSource> source, Lifetime lifetime, Func`2<TSource, TTarget> transform, Func`2<TSource, bool> filter);
    [ExtensionAttribute]
public static IReadonlyListEvents`1<TTarget> TransformEachItem(IReadonlyCollectionEvents`1<TSource> source, Lifetime lifetime, Func`3<Lifetime, TSource, TTarget> transform, Func`2<TSource, bool> filter);
    [ExtensionAttribute]
public static IReadonlyListEvents`1<TSource> CopyEachItemTo(IReadonlyCollectionEvents`1<TSource> source, Lifetime lifetime, IListEvents`1<TSource> target, Func`2<TSource, bool> filter);
    [ExtensionAttribute]
public static ListEvents`1<TSource> TransformFromProviderOrdered(IReadonlyListEvents`1<IDataProvider`1<TSource>> source, Lifetime lifetime, Func`2<TSource, bool> filter);
    [ExtensionAttribute]
public static IReadonlyListEvents`1<T> WhereNotNullLive(IReadonlyCollectionEvents`1<IDataProvider`1<T>> source, Lifetime lifetime);
    [ExtensionAttribute]
public static IReadonlyListEvents`1<TTarget> TransformEachItemWithPrevious(IReadonlyListEvents`1<TSource> source, Lifetime lifetime, Func`3<TSource, TSource, TTarget> transform, Func`3<TSource, TSource, bool> filter);
    [ExtensionAttribute]
public static IDataProvider`1<TA> ToItemDataProvider(IReadonlyCollectionEvents`1<TA> collection, Lifetime lifetime, Predicate`1<TA> itemSelector);
    [ExtensionAttribute]
public static IDataProvider`1<TA> ToLastItemDataProvider(IReadonlyCollectionEvents`1<TA> collection, Lifetime lifetime);
    [NotNullAttribute]
[ExtensionAttribute]
public static IDataProvider`1<int> CreateCountProvider(IReadonlyCollectionEvents`1<T> thіs, Lifetime lifetime);
    private static string MakeLifetimeId(string name);
    [CompilerGeneratedAttribute]
private static TTarget <CastEachItem>b__d(TSource item);
}
[ExtensionAttribute]
public static class JetBrains.dotMemory.Core.CollectionEventsExtension : object {
    private static string DebugId;
    private static CollectionEventsExtension();
    [ExtensionAttribute]
public static IDictionaryEvents`2<TValue, ListEvents`1<TItem>> GroupByLive(IReadonlyListEvents`1<TItem> source, Lifetime lifetime, Func`2<TItem, IProperty`1<TValue>> getProperty, IEqualityComparer`1<TValue> comparer);
    [ExtensionAttribute]
public static void FlowIntoSortedLive(IReadonlyCollectionEvents`1<TItem> source, Lifetime lifetime, IListEvents`1<TItem> target, Func`2<TItem, IProperty`1<TValue>> getProperty, IComparer`1<TValue> comparerForSorting, object cookie);
    [ExtensionAttribute]
public static void Advise(IReadonlyCollectionEvents`1<TValue> thіs, FullLifetime fullLifetime, Action`2<FullLifetime, TValue> handler);
    [ExtensionAttribute]
public static void Advise(IReadonlyCollectionEvents`1<TValue> thіs, Lifetime lifetime, Action`2<FullLifetime, TValue> handler);
    [ExtensionAttribute]
private static void ForEachItemCore(IReadonlyCollectionEvents`1<TValue> thіs, FullLifetime fullLifetime, Action`2<FullLifetime, TValue> FHandlerA, Action`3<FullLifetime, TValue, object> FHandlerB);
}
public static class JetBrains.dotMemory.Core.CommandLineConstants : object {
    public static string StartProfilingArgument;
    public static string OpenWorkspaceArgument;
}
[DefaultMemberAttribute("Item")]
public class JetBrains.dotMemory.Core.CompressedArray : object {
    private int myLength;
    private ChunkArray`1<byte> myBytesCollection;
    private CompactMap`2<int, ulong> myOthersCollection;
    public int Length { get; }
    public ulong Item { get; public set; }
    public CompressedArray(int length);
    public int get_Length();
    public ulong get_Item(int index);
    public void set_Item(int index, ulong value);
}
[DefaultMemberAttribute("Item")]
public class JetBrains.dotMemory.Core.CompressedArray`1 : object {
    private int myCount;
    private IByteCompressor`1<T> myCompressor;
    private byte myInvalidValue;
    public ChunkArray`1<byte> BytesCollection;
    public CompactMap`2<int, T> OthersCollection;
    public int Count { get; }
    public T Item { get; public set; }
    public CompressedArray`1(int count, IByteCompressor`1<T> compressor);
    public int get_Count();
    public T get_Item(int index);
    public void set_Item(int index, T value);
}
[DefaultMemberAttribute("Item")]
public class JetBrains.dotMemory.Core.CompressedTwoBytesArray`1 : object {
    private int myCount;
    private ITwoBytesCompressor`1<T> myCompressor;
    private ushort myInvalidValue;
    private ChunkArray`1<ushort> myTwoBytesCollection;
    private CompactMap`2<int, T> myOthersCollection;
    public int Count { get; }
    public T Item { get; public set; }
    public CompressedTwoBytesArray`1(int count, ITwoBytesCompressor`1<T> compressor);
    public int get_Count();
    public T get_Item(int index);
    public void set_Item(int index, T value);
}
public class JetBrains.dotMemory.Core.Configuration.CaseInsensitiveEnumConfigConverter`1 : ConfigurationConverterBase {
    public virtual object ConvertFrom(ITypeDescriptorContext ctx, CultureInfo ci, object data);
}
[DefaultMemberAttribute("Item")]
public abstract class JetBrains.dotMemory.Core.Configuration.ElementCollectionBase`1 : ConfigurationElementCollection {
    public T Item { get; }
    public T Item { get; }
    public void AddRange(IEnumerable`1<T> collection);
    public T get_Item(string name);
    public T get_Item(int index);
    protected virtual ConfigurationElement CreateNewElement();
    protected abstract virtual object GetElementKey(T element);
    protected sealed virtual object GetElementKey(ConfigurationElement element);
}
public class JetBrains.dotMemory.Core.Configuration.JetBrainsDiagnosticsSection : ConfigurationSection {
    public static string SectionName;
    private static string LoggingElementName;
    [ConfigurationPropertyAttribute("logging")]
public LoggingElement Logging { get; }
    public LoggingElement get_Logging();
}
public class JetBrains.dotMemory.Core.Configuration.LoggingElement : ConfigurationElement {
    private static string IsEnabledPropertyName;
    private static string LoggingLevelPropertyName;
    [ConfigurationPropertyAttribute("isEnabled")]
public bool IsEnabled { get; }
    [TypeConverterAttribute("JetBrains.dotMemory.Core.Configuration.CaseInsensitiveEnumConfigConverter`1<JetBrains.Util.LoggingLevel>")]
[ConfigurationPropertyAttribute("loggingLevel")]
public LoggingLevel LoggingLevel { get; }
    public bool get_IsEnabled();
    public LoggingLevel get_LoggingLevel();
}
public static class JetBrains.dotMemory.Core.ConstantPublicResources : object {
    public static string TagObjectMenuActionsGroup;
}
public static class JetBrains.dotMemory.Core.CountToString : object {
    private static long Thousand;
    private static long Million;
    public static string ConvertPrecisely(long count, string postfix, bool insertSpaces);
    public static string Convert(long count, string postfix, bool insertSpaces);
}
public static class JetBrains.dotMemory.Core.DataContractNamespace : object {
    public static string Common;
}
[ExtensionAttribute]
public static class JetBrains.dotMemory.Core.DataProvidersExtension : object {
    [ExtensionAttribute]
public static IDataNotifier`1<T> PublishAndActivate(IDataProvider`1<T> pipe, Lifetime lifetime);
    [ExtensionAttribute]
public static IWriteableDataNotifier`1<T> PublishAndActivateWriteable(IDataProvider`1<T> source, Lifetime lifetime, Action`1<T> setValue, bool validateSetValue);
    [ExtensionAttribute]
public static IWriteableDataNotifier`1<T> PublishAndActivateWriteable(IDataController`1<T> pipeInput, Lifetime lifetime, IDataProvider`1<string> error);
    [ExtensionAttribute]
public static IDataNotifier`1<T> PublishAndActivate(IDataProvider`1<T> pipe, IDataProvider`1<bool> isActiveProvider);
    [ExtensionAttribute]
public static IWriteableDataNotifier`1<T> PublishAndActivateWriteable(IDataProvider`1<T> source, IDataProvider`1<bool> isActiveProvider, Action`1<T> setValue, bool validateSetValue);
    [ExtensionAttribute]
public static IWriteableDataNotifier`1<T> PublishAndActivateWriteable(IDataController`1<T> pipeInput, IDataProvider`1<bool> isActiveProvider, IDataProvider`1<string> error);
    [ExtensionAttribute]
public static IEnumerable`1<T> PublishCollectionAndActivate(IDataProvider`1<IEnumerable`1<T>> collectionProvider, Lifetime lifetime, CollectionNotificationMode mode);
    [ExtensionAttribute]
private static void Activate(IDataNotifier`1<T> pipeOut, IDataProvider`1<bool> isActiveProvider);
    [ExtensionAttribute]
private static void Activate(IDataNotifier`1<T> pipeOut, Lifetime lifetime);
    private static void PipeOutOnPropertyChanged(object sender, PropertyChangedEventArgs propertyChangedEventArgs);
    private static void NotifierOnCollectionChanged(object sender, NotifyCollectionChangedEventArgs notifyCollectionChangedEventArgs);
}
[ExtensionAttribute]
public static class JetBrains.dotMemory.Core.DataRule : object {
    public static IList`1<IDataRule> CreateBag(IEnumerable`1<IDataRule> dataRules);
    [NotNullAttribute]
[ExtensionAttribute]
public static IList`1<IDataRule> AddRule(IList`1<IDataRule> thіs, DataConstant`1<TValue> dataconstant, TValue value);
    [NotNullAttribute]
[ExtensionAttribute]
public static IList`1<IDataRule> AddRule(IList`1<IDataRule> thіs, DataConstant`1<TValue> dataconstant, Func`2<IDataContext, TValue> getValue);
    [ExtensionAttribute]
public static IList`1<IDataRule> AddRules(IList`1<IDataRule> thіs, IEnumerable`1<IDataRule> rules);
}
[ExtensionAttribute]
public static class JetBrains.dotMemory.Core.Diagnostics.FileSystemPathDiagnosticExtension : object {
    private static ISet`1<string> ourWellkonwnNames;
    private static FileSystemPathDiagnosticExtension();
    [ExtensionAttribute]
public static string ToAnonymous(FileSystemPath path);
    public static string ToAnonymous(string fullPath);
}
public class JetBrains.dotMemory.Core.DotMemoryGlobalState : object {
    private object myWriteOperationsCountAccess;
    private int myWriteOperationsCount;
    public sealed virtual IDisposable TryLockWriteOperations();
    public sealed virtual IDisposable WriteOperationStarted();
    public sealed virtual void WriteOperationFinished();
    [CompilerGeneratedAttribute]
private void <TryLockWriteOperations>b__0();
}
public static class JetBrains.dotMemory.Core.DotMemoryProcessUtil : object {
    public static string DotMemoryProcessName;
    private static DotMemoryProcessUtil();
}
public class JetBrains.dotMemory.Core.DotMemoryProgressIndicator : object {
    private IProgressIndicator myProgressIndicator;
    private IProgressIndicatorModel myProgressIndicatorModel;
    unknown string CurrentItemText {public set; }
    private bool JetBrains.Application.Progress.IProgressIndicator.IsCanceled { get; }
    public string TaskName { get; public set; }
    public IProperty`1<double> Fraction { get; }
    public IProperty`1<bool> IsCanceled { get; }
    public IProperty`1<bool> IsRunning { get; }
    public IProperty`1<string> Name { get; }
    public IProperty`1<string> StepName { get; }
    public DotMemoryProgressIndicator(Lifetime lifetime);
    public void Cancel();
    public sealed virtual void Advance(double units);
    public sealed virtual void Dispose();
    public sealed virtual void set_CurrentItemText(string value);
    private sealed virtual override bool JetBrains.Application.Progress.IProgressIndicator.get_IsCanceled();
    public sealed virtual string get_TaskName();
    public sealed virtual void set_TaskName(string value);
    public sealed virtual void Start(int totalWorkUnits);
    public sealed virtual void Stop();
    public sealed virtual IProperty`1<double> get_Fraction();
    public sealed virtual IProperty`1<bool> get_IsCanceled();
    public sealed virtual IProperty`1<bool> get_IsRunning();
    public sealed virtual IProperty`1<string> get_Name();
    public sealed virtual IProperty`1<string> get_StepName();
    [CompilerGeneratedAttribute]
private void <.ctor>b__0();
}
public class JetBrains.dotMemory.Core.Element`1 : ValueType {
    public int LeftIndex;
    public int RightIndex;
    public TValue Value;
    public Element`1(int leftIndex, int rightIndex, TValue value);
}
public class JetBrains.dotMemory.Core.EternalCollection : object {
    public static Lifetime Lifetime;
    private static EternalCollection();
}
[ShellComponentAttribute]
internal class JetBrains.dotMemory.Core.ExecutionMode : object {
    private static string DevKey;
    private bool myIsInternal;
    private bool myIsDevelopment;
    public bool IsInternal { get; }
    public bool IsDevelopment { get; }
    public ExecutionMode(ProductConfigurations productConfigurations, ICommandLine commandLine);
    public sealed virtual bool get_IsInternal();
    public sealed virtual bool get_IsDevelopment();
}
[ExtensionAttribute]
public static class JetBrains.dotMemory.Core.FactoryExtension : object {
    private static string Id;
    private static FactoryExtension();
    [ExtensionAttribute]
public static T Create(IFactory factory, Lifetime lifetime, Object[] parameters);
    [ExtensionAttribute]
public static T Create(IFactory factory, Object[] parameters);
    [ExtensionAttribute]
public static State UsingToken(IFactory factory, object token);
    [ExtensionAttribute]
public static State UsingConstructor(IFactory factory, object ctorId);
}
[ExtensionAttribute]
public static class JetBrains.dotMemory.Core.FileSystemExtension : object {
    [CompilerGeneratedAttribute]
private static Func`2<FileSystemPath, long> CS$<>9__CachedAnonymousMethodDelegate1;
    [ExtensionAttribute]
public static long GetSize(FileSystemPath path);
    [ExtensionAttribute]
public static void MoveDirectory(FileSystemPath sourceDirectoryPath, FileSystemPath targetDirectoryPath);
    [ExtensionAttribute]
public static string GetFilePropertySafe(string value, Func`2<FileSystemPath, string> getProperty);
    [CompilerGeneratedAttribute]
private static long <GetSize>b__0(FileSystemPath filePath);
}
public interface JetBrains.dotMemory.Core.IAlertUser {
    public abstract virtual DialogBoxCommandId Alert(string message, MessageBoxFlags flags);
    public abstract virtual void AlertAsync(string message, MbButton buttons, MbIcon icon, Action`1<DialogBoxCommandId> resultCallback);
}
public interface JetBrains.dotMemory.Core.IByteCompressor`1 {
    public byte InvalidValue { get; }
    public abstract virtual byte Compress(T value);
    public abstract virtual T Decompress(byte value);
    public abstract virtual byte get_InvalidValue();
}
public interface JetBrains.dotMemory.Core.IComparableBy`2 {
    public abstract virtual int CompareTo(T other, TBy by);
}
public interface JetBrains.dotMemory.Core.ID {
}
[ZoneDefinitionAttribute]
public interface JetBrains.dotMemory.Core.IDotMemoryCoreZone {
}
public interface JetBrains.dotMemory.Core.IDotMemoryGlobalState {
    public abstract virtual IDisposable WriteOperationStarted();
    public abstract virtual void WriteOperationFinished();
    public abstract virtual IDisposable TryLockWriteOperations();
}
public interface JetBrains.dotMemory.Core.IEntityProvider`1 {
    public abstract virtual T GetData(IExecutionController executionController);
}
public interface JetBrains.dotMemory.Core.IEntityReference`1 {
    [NotNullAttribute]
public abstract virtual T GetEntity(IExecutionController executionController, Lifetime lifetime);
}
public interface JetBrains.dotMemory.Core.IExecutionMode {
    public bool IsInternal { get; }
    public bool IsDevelopment { get; }
    public abstract virtual bool get_IsInternal();
    public abstract virtual bool get_IsDevelopment();
}
public interface JetBrains.dotMemory.Core.IFactory {
    public abstract virtual object Resolve(object token, Type typeToResolve, Registry sessionContext);
}
[UsedImplicitlyAttribute]
public class JetBrains.dotMemory.Core.InjectablePlatformClasses : object {
    private IComponentContainer myComponentContainer;
    private SettingsStorageProvidersCollection JetBrains.dotMemory.Core.IShellComponent<JetBrains.Application.Settings.Storage.DefaultBody.SettingsStorageProvidersCollection>.Component { get; }
    private FileSettingsStorageBehavior JetBrains.dotMemory.Core.IShellComponent<JetBrains.Application.Settings.Storage.Persistence.FileSettingsStorageBehavior>.Component { get; }
    public ProductSettingsLocation Component { get; }
    private InternKeyPathComponent JetBrains.dotMemory.Core.IShellComponent<JetBrains.Application.Settings.Storage.DefaultBody.InternKeyPathComponent>.Component { get; }
    public InjectablePlatformClasses(IComponentContainer componentContainer);
    private sealed virtual override SettingsStorageProvidersCollection JetBrains.dotMemory.Core.IShellComponent<JetBrains.Application.Settings.Storage.DefaultBody.SettingsStorageProvidersCollection>.get_Component();
    private sealed virtual override FileSettingsStorageBehavior JetBrains.dotMemory.Core.IShellComponent<JetBrains.Application.Settings.Storage.Persistence.FileSettingsStorageBehavior>.get_Component();
    public sealed virtual ProductSettingsLocation get_Component();
    private sealed virtual override InternKeyPathComponent JetBrains.dotMemory.Core.IShellComponent<JetBrains.Application.Settings.Storage.DefaultBody.InternKeyPathComponent>.get_Component();
}
public class JetBrains.dotMemory.Core.IntCompressor : object {
    private byte myInvalidValue;
    public byte InvalidValue { get; }
    public IntCompressor(byte invalidValue);
    public sealed virtual byte Compress(int value);
    public sealed virtual int Decompress(byte value);
    public sealed virtual byte get_InvalidValue();
}
public class JetBrains.dotMemory.Core.IntTwoBytesCompressor : object {
    private ushort myInvalidValue;
    public ushort InvalidValue { get; }
    public IntTwoBytesCompressor(ushort invalidValue);
    public sealed virtual ushort Compress(int value);
    public sealed virtual int Decompress(ushort value);
    public sealed virtual ushort get_InvalidValue();
}
public interface JetBrains.dotMemory.Core.INumericValueTrackingService {
    public abstract virtual void TrackDotMemoryRamConsumption(double ramConsumed);
    public abstract virtual void TrackSnapshotSize(int objectsCount);
    public abstract virtual void TrackObjectSetSize(int objectsCount);
    public abstract virtual void TrackCompareSnapshotsTime(TimeSpan executionTime);
    public abstract virtual void TrackBuildObjectPathsToRootsTime(Lifetime instance);
    public abstract virtual void TrackBuildObjectSetAllocationBackTracesTime(Lifetime instance);
    public abstract virtual void TrackBuildObjectSetPlainAllocationsTime(Lifetime instance);
    public abstract virtual void TrackBuildSetToSetPathsTime(Lifetime instance);
    public abstract virtual void TrackBuildTrafficByFunctionTime(Lifetime instance);
    public abstract virtual void TrackBuildTrafficByClassTime(TimeSpan executionTime);
    public abstract virtual void TrackBuildObjectSetAllocationsTree(Lifetime instance);
    public abstract virtual void TrackBuildKeyRetentionPathTime(Lifetime instance);
    public abstract virtual void TrackBuildGroupBySimilarRetentionTime(Lifetime instance);
}
public interface JetBrains.dotMemory.Core.ISettingsIndexedKey`1 {
    [NotNullAttribute]
public TIndex Index { get; }
    public abstract virtual TIndex get_Index();
}
public interface JetBrains.dotMemory.Core.IShellComponent`1 {
    public T Component { get; }
    public abstract virtual T get_Component();
}
public interface JetBrains.dotMemory.Core.ISortable`1 {
    public abstract virtual void Sort(Comparison`1<T> comparison);
}
public interface JetBrains.dotMemory.Core.ITransient`1 {
    public TEntity Entity { get; }
    public abstract virtual TEntity get_Entity();
    public abstract virtual void Terminate();
}
public interface JetBrains.dotMemory.Core.ITwoBytesCompressor`1 {
    public ushort InvalidValue { get; }
    public abstract virtual ushort Compress(T value);
    public abstract virtual T Decompress(ushort value);
    public abstract virtual ushort get_InvalidValue();
}
[ExtensionAttribute]
public static class JetBrains.dotMemory.Core.LoggerExtension : object {
    [ExtensionAttribute]
public static ILogger LogAction(ILogger logger, string actionName, Action action, LoggingLevel loggingLevel);
}
public class JetBrains.dotMemory.Core.LongCompressor : object {
    private byte myInvalidValue;
    public byte InvalidValue { get; }
    public LongCompressor(byte invalidValue);
    public sealed virtual byte Compress(long value);
    public sealed virtual long Decompress(byte value);
    public sealed virtual byte get_InvalidValue();
}
public class JetBrains.dotMemory.Core.Node`1 : object {
    public Node`1<TValue> Left;
    public Node`1<TValue> Right;
    public TValue Value;
}
public static class JetBrains.dotMemory.Core.Pipeline : object {
    public static Pipeline`2<TA, TB> Create(Func`2<IDataProvider`1<TA>, IDataProvider`1<TB>> transform);
    public static Pipeline`2<TA, TB> Create(IDataController`1<TA> pipeInput, IDataProvider`1<TB> dataProvider);
}
public class JetBrains.dotMemory.Core.Pipeline`2 : object {
    private IDataController`1<TA> myPipeInput;
    public IDataProvider`1<TB> Output;
    unknown TA Input {public set; }
    public Pipeline`2(IDataController`1<TA> pipeInput, IDataProvider`1<TB> output);
    public void set_Input(TA value);
}
public class JetBrains.dotMemory.Core.ProgressNotifier : object {
    private IDataNotifier`1<AsyncComputationState> myState;
    private IDataNotifier`1<string> myTitle;
    private IDataNotifier`1<int> myProgress;
    private PropertyChangedEventHandler PropertyChanged;
    public IDataNotifier`1<int> Progress { get; }
    public IDataNotifier`1<AsyncComputationState> State { get; }
    public IDataNotifier`1<string> Title { get; }
    public ProgressNotifier(ProgressProvider progressProvider, IDataNotifier`1<string> title);
    public IDataNotifier`1<int> get_Progress();
    public IDataNotifier`1<AsyncComputationState> get_State();
    public IDataNotifier`1<string> get_Title();
    public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
}
[ExtensionAttribute]
public static class JetBrains.dotMemory.Core.Property : object {
    public static string Of(string name);
    public static string GetName(T source, Expression`1<Func`2<T, object>> expression);
    [ExtensionAttribute]
public static string GetPropertyName(T source, Expression`1<Func`2<T, object>> expression);
}
[DefaultMemberAttribute("Item")]
public class JetBrains.dotMemory.Core.RangeArray : object {
    private List`1<int> myRangeArray;
    private int myLastItem;
    private int mySum;
    private int myStartValue;
    private int myCount;
    public int Item { get; }
    public RangeArray(int startValue, int sum);
    public bool Add(int value);
    private int binary_search(int index, int a, int b);
    public int get_Item(int index);
}
public class JetBrains.dotMemory.Core.Remoting.ConnectionBrokenException : Exception {
    public ConnectionBrokenException(string message);
}
public class JetBrains.dotMemory.Core.Remoting.ExternalExecutionException : Exception {
    public ExternalExecutionException(Exception innerException);
}
internal class JetBrains.dotMemory.Core.Remoting.ExternalExecutor : object {
    private Lifetime myLifetime;
    private IThreading myMainThread;
    public ExternalExecutor(Lifetime lifetime, IThreading mainThread);
    public sealed virtual TResultingData Execute(string executorName, TSourceData sourceData, Func`3<TSourceData, IExecutionController, TResultingData> execute, IExecutionController executionController, PlatformKind platformKind);
    private FileSystemPath TryGetLogFileCopy(FileSystemPath originalFilePath, string executorName);
    private Func`3<TSourceData, IExecutionController, ExecutionResult`1<TResultingData>> GetExceptionWrappingClosure(Func`3<TSourceData, IExecutionController, TResultingData> execute);
}
public interface JetBrains.dotMemory.Core.Remoting.IExternalExecutor {
    public abstract virtual TResultingData Execute(string executorName, TSourceData sourceData, Func`3<TSourceData, IExecutionController, TResultingData> execute, IExecutionController executionController, PlatformKind platformKind);
}
public class JetBrains.dotMemory.Core.RestoreStateSignal`1 : Signal`1<TValue> {
    private Action`1<Action`1<TValue>> myRestateAction;
    public RestoreStateSignal`1(Lifetime lifetime, Action`1<Action`1<TValue>> restateAction, string id);
    protected virtual bool OnBeforeAdvise(Action`1<TValue> handler);
}
public class JetBrains.dotMemory.Core.Settings.ApplicationSettings : LiveSettings {
    public ApplicationSettings(IContextBoundSettingsStoreLive settings);
}
public static class JetBrains.dotMemory.Core.Settings.DmSettingsContext : object {
    public static DataConstant`1<object> SettingsFileId;
    private static DmSettingsContext();
}
public static class JetBrains.dotMemory.Core.Settings.DmSettingsContextPriority : object {
    public static double ProfilingSession;
    private static DmSettingsContextPriority();
}
[SettingsKeyAttribute("System.Reflection.Missing", "ActivityTrackingState")]
public class JetBrains.dotMemory.Core.Settings.DotMemoryActivityTrackingSettingsKey : object {
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "UserWarnedAboutActivityTracking")]
public bool UserWarnedAboutActivityTracking;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "ActivityTrackingIsOn")]
public bool IsOn;
}
[SettingsKeyAttribute("System.Reflection.Missing", "DotMemoryInternalSettings")]
public class JetBrains.dotMemory.Core.Settings.DotMemoryInternalSettingsKey : object {
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "DebugProcessDumpConverter")]
public bool DebugProcessDumpConverter;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "ShowClrDumpDisclaimer")]
public bool ShowClrDumpDisclaimer;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "ShowDebuggerLibsInfo")]
public bool ShowDebuggerLibsInfo;
}
public interface JetBrains.dotMemory.Core.Settings.IApplicationSettings {
}
public interface JetBrains.dotMemory.Core.Settings.IProbingScopeStateSettings {
}
public interface JetBrains.dotMemory.Core.Settings.ISettingsFactory {
    public abstract virtual SettingsFileLive OpenLiveSettingsFile(FileSystemPath settingsFilePath, Lifetime lifetime);
    public abstract virtual IContextBoundSettingsFileLive OpenLiveFile(FileSystemPath settingsFilePath, Lifetime lifetime);
}
public interface JetBrains.dotMemory.Core.Settings.ISharedStateSettings {
}
public interface JetBrains.dotMemory.Core.Settings.IStateSettings {
}
[SettingsKeyAttribute("System.Reflection.Missing", "dotMemory.GeneralOptions")]
public class JetBrains.dotMemory.Core.Settings.OptionsGeneralSettingsKey : object {
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "Directory")]
public string WorkspaceStorageDirectory;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "Display unmanaged memory by default")]
public bool ShowUnmanagedMemory;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "Automaticaly delete not pinned workspaces older N days")]
public int AutoDeleteWorkspaceOlderNDays;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "Clear exceptions on exit")]
public bool ClearExceptionsOnExit;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "Support navigation from dotMemory to source code")]
public bool EnableNavigation;
}
[UsedImplicitlyAttribute]
public class JetBrains.dotMemory.Core.Settings.SettingsFactory : object {
    private InternKeyPathComponent myInternKeyPathComponent;
    private IFileSystemTracker myFileSystemTracker;
    private ISettingsStore mySettingsStore;
    private ProductConfigurations myProductConfigurations;
    private IThreading myUIThreading;
    public SettingsFactory(InternKeyPathComponent internKeyPathComponent, IFileSystemTracker fileSystemTracker, ISettingsStore settingsStore, ProductConfigurations productConfigurations, IThreading uiThreading);
    public sealed virtual SettingsFileLive OpenLiveSettingsFile(FileSystemPath settingsFilePath, Lifetime lifetime);
    public sealed virtual IContextBoundSettingsFileLive OpenLiveFile(FileSystemPath settingsFilePath, Lifetime lifetime);
}
public class JetBrains.dotMemory.Core.Settings.StateSettings : SettingsFileLive {
    public StateSettings(IContextBoundSettingsFileLive settingsFile);
}
public static class JetBrains.dotMemory.Core.Settings.WorkspaceStorageDirectory : object {
    public static string LocalApplicationData;
    public static string CommonApplicationData;
}
public static class JetBrains.dotMemory.Core.Signal : object {
    public static ISignal`1<T> Create();
}
public class JetBrains.dotMemory.Core.SingleThreadExecutionController : object {
    public static IExecutionController Instance;
    private static ITaskExecutionEnvironment ExecutionEnvironment;
    private static SingleThreadExecutionController();
    public sealed virtual void Dispose();
    public sealed virtual IExecutionController StartProgress(int stepsCount, string operationName);
    public sealed virtual IExecutionController CreateSubOperation(int parentStepsCount);
    public sealed virtual void Yield();
    public sealed virtual void AdvanceProgress();
    public sealed virtual void AttachTask(ITask task, int parentStepsCount, bool isShared);
    public sealed virtual void WaitForTask(ITask task, int parentStepsCount, bool isShared);
}
[DefaultMemberAttribute("Item")]
public class JetBrains.dotMemory.Core.SparseArray`1 : object {
    private static int MaxChunkSizeInBytes;
    private int myChunkLength;
    private int myIndexInChunkMask;
    private int myChunkLengthLog2;
    private Dictionary`2<int, T[]> myChunks;
    private int myItemsCount;
    private int myVersion;
    private ulong myMinItemIndex;
    private ulong myMaxItemIndex;
    private T myDefaultT;
    public int ItemsCount { get; }
    public T Item { get; public set; }
    public ulong MinItemIndex { get; }
    public ulong MaxItemIndex { get; }
    public SparseArray`1(int chunkLength, T defaultT);
    private T[] CreateNewChunk();
    public int get_ItemsCount();
    public T get_Item(ulong index);
    public void set_Item(ulong index, T value);
    public ulong get_MinItemIndex();
    public ulong get_MaxItemIndex();
    public bool ExistsItem(ulong index);
    private bool ExistsItem(int chunkNumber, int indexInChunk);
    private static int GetNearestLessPowOf2(int number, Int32& pow);
    public sealed virtual IEnumerator`1<KeyValuePair`2<ulong, T>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[ExtensionAttribute]
public static class JetBrains.dotMemory.Core.ThreadingExtensions : object {
    [ExtensionAttribute]
public static T ExecuteAndWait(IThreading threading, Lifetime lifetime, TimeSpan timeout, string name, Func`1<T> func);
    [ExtensionAttribute]
public static void ExecuteAndWait(IThreading threading, Lifetime lifetime, TimeSpan timeout, string name, Action action);
}
public class JetBrains.dotMemory.Core.Transient : object {
    public static ITransient`1<TEntity> Create(Func`2<Lifetime, TEntity> create, string lifetimeId);
    public static ITransient`1<TEntity> Create(LifetimeDefinition lifetimeDefinition, Func`2<Lifetime, TEntity> create);
}
public class JetBrains.dotMemory.Core.Transient`1 : Transient {
    private TEntity myEntity;
    private LifetimeDefinition myLifetimeDefinition;
    private bool myDisposed;
    public TEntity Entity { get; }
    public Transient`1(Func`2<Lifetime, TEntity> create, string lifetimeId);
    public Transient`1(TEntity entity, LifetimeDefinition lifetimeDefinition);
    public sealed virtual TEntity get_Entity();
    public sealed virtual void Terminate();
    public sealed virtual void Dispose();
}
public class JetBrains.dotMemory.Core.Trie`1 : object {
    private Node`1<TValue> myRoot;
    public void Add(ulong key, TValue value);
    public TValue Find(ulong key);
}
[DefaultMemberAttribute("Item")]
public class JetBrains.dotMemory.Core.TwoBitsArray : object {
    private static int BitsInInt;
    private static int ElementsInInt;
    private ChunkArray`1<UInt32> myArray;
    private int myElementsInIntLog2;
    private int myIndexInIntMask;
    private int myIndexInElementMask;
    private int myArrayLength;
    public int Length { get; }
    public int Item { get; public set; }
    public TwoBitsArray(int count);
    public TwoBitsArray(IList`1<int> intArray);
    public int get_Length();
    public int get_Item(int index);
    public void set_Item(int index, int value);
}
[DataContractAttribute]
[ValueSerializerAttribute("JetBrains.dotMemory.Core.Uid/Serializer")]
public class JetBrains.dotMemory.Core.Uid : object {
    [DataMemberAttribute]
public Guid Guid;
    public Uid(Guid guid);
    public virtual string ToString();
    public sealed virtual bool Equals(Uid other);
    public sealed virtual bool Equals(ID other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(Uid left, Uid right);
    public static bool op_Inequality(Uid left, Uid right);
    public static ID NewId();
}
[ExtensionAttribute]
public static class JetBrains.dotMemory.Core.UidExtensions : object {
    [ExtensionAttribute]
public static bool IsNullOrInvalid(Uid uid);
}
public class JetBrains.dotMemory.Core.UintCompressor : object {
    private byte myInvalidValue;
    public byte InvalidValue { get; }
    public UintCompressor(byte invalidValue);
    public sealed virtual byte Compress(UInt32 value);
    public sealed virtual UInt32 Decompress(byte value);
    public sealed virtual byte get_InvalidValue();
}
public class JetBrains.dotMemory.Core.UlongCompressor : object {
    private byte myInvalidValue;
    public byte InvalidValue { get; }
    public UlongCompressor(byte invalidValue);
    public sealed virtual byte Compress(ulong value);
    public sealed virtual ulong Decompress(byte value);
    public sealed virtual byte get_InvalidValue();
}
public class JetBrains.dotMemory.Core.UlongTwoBytesCompressor : object {
    private ushort myInvalidValue;
    public ushort InvalidValue { get; }
    public UlongTwoBytesCompressor(ushort invalidValue);
    public sealed virtual ushort Compress(ulong value);
    public sealed virtual ulong Decompress(ushort value);
    public sealed virtual ushort get_InvalidValue();
}
public class JetBrains.dotMemory.Core.UrlUtil : object {
    public static string GetUrlLastPart(string url);
}
public static class JetBrains.dotMemory.Core.ViewNames : object {
    public static string DeadObjects;
    public static string LiveObjects;
    public static string SurvivedObjects;
    public static string NewObjects;
    public static string Comparison;
    public static string CrossWorkspaceOverview;
    public static string CrossWorkspaceComparison;
    public static string Snapshot;
    public static string AllObjects;
    public static string Inspections;
    public static string ObjectSet;
    public static string Traffic;
    public static string TrafficByFunction;
    public static string TrafficByClass;
    public static string Retained;
    public static string DominatedObjectSet;
    public static string DominatorsObjectSet;
    public static string AllocatedinFunctionObjectSet;
    public static string OwnAllocatedObjectSet;
    public static string SubTreeAllocatedObjectSet;
    public static string Object;
    public static string DominatorObject;
    public static string Dominators;
    public static string DominatorsSunburst;
    public static string PrincipalRetention;
    public static string RootPaths;
    public static string ByClass;
    public static string Merged;
    public static string Plain;
    public static string Tree;
    public static string AllocationsChart;
    public static string Generation;
    public static string Fragmentation;
    public static string Instances;
    public static string GroupedByNameSpace;
    public static string GroupedByInterface;
    public static string GroupedByAssembly;
    public static string IncomingReferences;
    public static string OutgoingReferences;
    public static string Allocations;
    public static string TwoWayClassifier;
    public static string BacktraceTree;
    public static string IcicleTree;
    public static string PathsToRoots;
    public static string ImportClrDump;
    public static string ImportWorkspace;
    public static string ImportWorkspaceIntoPortable;
    public static string ExportWorkspace;
    public static string PackDebuggerLibs;
}
[ExtensionAttribute]
public static class JetBrains.dotMemory.Core.WaitHandleExtension : object {
    [ExtensionAttribute]
public static void WaitOneWithTimeout(WaitHandle waitHandle, TimeSpan timespan);
    [ExtensionAttribute]
public static void WaitOneWithIntermediateCheckAndTimeout(WaitHandle waitHandle, TimeSpan timespan, Action intermediateCheck);
}
public static class JetBrains.dotMemory.Core.WaitUtil : object {
    public static void WaitForConditionWithTimeout(TimeSpan timespan, Func`1<bool> condition, Action errorHandler, int sleepPeriod);
}
public class JetBrains.dotMemory.Core.WithCatch`1 : object {
    private Action`1<Exception> myCatch;
    private TA myValue;
    public WithCatch`1(TA value, Action`1<Exception> catch);
    internal TB CatchException(TB fallbackValue, Func`2<TA, TB> func);
}
[ExtensionAttribute]
public static class JetBrains.dotMemory.Core.WithCatchExtension : object {
    [ExtensionAttribute]
public static TB Catch(WithCatch`1<TA> handler, TB fallbackValue, Func`2<TA, TB> func);
}
[SettingsIndexedKeyAttribute("System.Reflection.Missing", "ProfileConfiguration stored for history", "JetBrains.Application.Settings.GuidIndex")]
public class JetBrains.dotMemory.Core.Workspace.ProfileConfigurationSettingsKey : object {
    private static string KeyDescription;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "ProfileConfiguration stored for history")]
public string ProfileConfigurationXml;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "Access time")]
public DateTime AccessTime;
    public ProfileConfigurationSettingsKey(string profileConfigurationXml);
}
public static class JetBrains.dotMemory.Core.Workspace.WorkspaceStorageUtil : object {
    private static string WorkspacesListFileRelativePath;
    public static FileSystemPath GetWorkpsaceListFilePath(IAnyProductSettingsLocation productLocation);
}
[ExtensionAttribute]
public static class JetBrains.dotMemory.Core.ZipUtil : object {
    [CompilerGeneratedAttribute]
private static Func`2<ZipEntry, long> CS$<>9__CachedAnonymousMethodDelegate3;
    public static void AddFilesToArchive(FileSystemPath targetFilePath, IExecutionController executionController, string executionControllerOperationName, IList`1<Pair`2<FileSystemPath, RelativePath>> paths);
    public static void AddFilesToArchive(FileSystemPath baseDirectory, FileSystemPath targetFilePath, IExecutionController executionController, string executionControllerOperationName, FileSystemPath[] paths);
    [ExtensionAttribute]
public static void Save(ZipFile zip, FileSystemPath baseDirectory, IExecutionController executionController, string executionControllerOperationName, FileSystemPath[] paths, FileSystemPath targetFilePath);
    [ExtensionAttribute]
public static void Extract(ZipFile zip, FileSystemPath directoryPath, IExecutionController executionController, string executionControllerOperationName, ExtractExistingFileAction extractExistingFileAction);
    [ExtensionAttribute]
public static void ExtractFile(ZipFile zip, string filename, FileSystemPath directoryPath);
    private static void ProcessException(Exception exception);
    private static ZipFileProgressToExecutionController FlowSaveProgressToExecutionController(long totalBytes, ZipFile zipFile, IExecutionController executionController, string executionControllerOperationName);
    private static ZipFileProgressToExecutionController FlowExtractProgressIntoExecutionController(long totalBytes, ZipFile zipFile, IExecutionController executionController, string executionControllerOperationName);
    [CompilerGeneratedAttribute]
private static long <Extract>b__2(ZipEntry zipEntry);
}
public class JetBrains.dotMemory.Core.ZipUtils.ZipProgressAdapter : object {
    private ZipFile myZip;
    private long myTotalBytes;
    private IExecutionController myExecutionController;
    private long myCurrentBytes;
    private long myEntryBytes;
    private int myCurrentPercents;
    private Exception myLastException;
    public ZipProgressAdapter(ZipFile zip, long totalBytes, IExecutionController executionController);
    public sealed virtual void Dispose();
    private void OnProgress(object sender, ZipProgressEventArgs args);
}
[ZoneMarkerAttribute]
public class JetBrains.dotMemory.Core.ZoneMarker : object {
}
public static class JetBrains.dotMemory.Logging.LoggingInitializer : object {
    public static string LogFileKey;
    public static string LogLevelKey;
    public static void Initialize(ICommandLine commandLine);
    public static void Initialize(string logFile, string logLevel);
    public static void Initialize(FileSystemPath logFile, LoggingLevel logLevel);
    public static void Initialize(Lifetime lifetime, FileSystemPath logFile, LoggingLevel logLevel);
}
