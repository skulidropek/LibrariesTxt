[UsedImplicitlyAttribute]
public class JetBrains.dotMemory.Model.AllObjectsSetGenerator : object {
    private SnapshotId mySnapshotId;
    private IAllObjectsSetReference myAllObjectsSetReference;
    public SnapshotId SnapshotId { get; }
    public AllObjectsSetGenerator(SnapshotId snapshotId, IAllObjectsSetReference allObjectsSetReference);
    public sealed virtual IPersistentFactory`1<IObjectSetGenerator> GetPersistentFactory();
    public sealed virtual bool Equals(IObjectSetGenerator obj);
    public sealed virtual SnapshotId get_SnapshotId();
    public sealed virtual IEnumerable`1<ObjectNumber> GetObjectSet(IObjectSetReference superSetReference, IExecutionController executionController);
    public void Destroy();
}
[UsedImplicitlyAttribute]
public class JetBrains.dotMemory.Model.AllObjectsSetReference : object {
    private IEntityReference`1<IAccessibilityMask> myAccessibilityMaskReference;
    private ObjectSetId myId;
    public ObjectSetId Id { get; }
    public AllObjectsSetReference(IEntityReference`1<IAccessibilityMask> accessibilityMaskReference, SnapshotId snapshotId);
    public sealed virtual IObjectSet GetEntity(IExecutionController executionController, Lifetime lifetime);
    public sealed virtual ObjectSetId get_Id();
}
internal class JetBrains.dotMemory.Model.AllocationsInfoLinksBag`1 : object {
    private Dictionary`2<CallTreeLink, T> myLinks;
    public IReadOnlyCollection`1<T> Links { get; }
    public void AddOrCreate(SnapshotId snapshotId, UInt32 callTreeNumber, UInt32 callTreePtr, UInt32 objectsCount, ulong memoryAmount, Func`1<T> createNew);
    public IReadOnlyCollection`1<T> get_Links();
}
public static class JetBrains.dotMemory.Model.ArrayMath : object {
    [CompilerGeneratedAttribute]
private static Func`2<ArrayDimensionInfo, bool> CS$<>9__CachedAnonymousMethodDelegate1;
    public static IList`1<UInt32> OneDimensionalIndexToNDimensional(int index, IReadOnlyList`1<ArrayDimensionInfo> arrayDimensions);
    [CompilerGeneratedAttribute]
private static bool <OneDimensionalIndexToNDimensional>b__0(ArrayDimensionInfo _);
}
[UsedImplicitlyAttribute]
public class JetBrains.dotMemory.Model.CompactTreeReaderProvider : object {
    private IFactory myFactory;
    private Func`2<Lifetime, BinaryReader> myGetReader;
    private int mySize;
    public CompactTreeReaderProvider(IFactory factory, Func`2<Lifetime, BinaryReader> getReader, int size);
    public sealed virtual ICompactTreeReader GetData(IExecutionController executionController);
}
[UsedImplicitlyAttribute]
public class JetBrains.dotMemory.Model.Comparison.ComparisonDescriptionBuilder : object {
    public sealed virtual IComparisonDescription Build(ISnapshotScope snapshotScope1, ISnapshotScope snapshotScope2);
}
public class JetBrains.dotMemory.Model.Comparison.ComparisonInfo : object {
    private ISnapshotScope myNewSnapshotScope;
    private ISnapshotScope myOldSnapshotScope;
    private string myComparisonId;
    public ISnapshotScope NewSnapshot { get; }
    public ISnapshotScope OldSnapshot { get; }
    public string ComparisonId { get; }
    public SnapshotId OldSnapshotId { get; }
    public SnapshotId NewSnapshotId { get; }
    public ComparisonInfo(ISnapshotScope snapshotScope1, ISnapshotScope snapshotScope2);
    public sealed virtual ISnapshotScope get_NewSnapshot();
    public sealed virtual ISnapshotScope get_OldSnapshot();
    public sealed virtual string get_ComparisonId();
    public sealed virtual SnapshotId get_OldSnapshotId();
    public sealed virtual SnapshotId get_NewSnapshotId();
    public sealed virtual bool Equals(IComparisonDescription other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[UsedImplicitlyAttribute]
internal class JetBrains.dotMemory.Model.Comparison.CrossWorkspaceSnapshotsComparisonService : object {
    private IComparisonPair`1<IObjectByTypeAggregator> myObjectByTypeAggregatorPair;
    private IComparisonPair`1<IAllObjectsSetReference> myAllObjectsPair;
    private IComparisonPair`1<ITypeService> myTypeServicePair;
    private IComparisonPair`1<IEntityReference`1<IMetadataService>> myMetadataSerivceReferencesPair;
    [CompilerGeneratedAttribute]
private static Comparison`1<Pair`2<GlobalTypeName, TypeStatistics>> CS$<>9__CachedAnonymousMethodDelegate2;
    public CrossWorkspaceSnapshotsComparisonService(IComparisonPair`1<IObjectByTypeAggregator> objectByTypeAggregatorPair, IComparisonPair`1<IAllObjectsSetReference> allObjectsPair, IComparisonPair`1<ITypeService> typeServicePair, IComparisonPair`1<IEntityReference`1<IMetadataService>> metadataSerivceReferencesPair);
    public sealed virtual IReadOnlyCollection`1<CrossWorkspaceTypeStatistics> Calculate(IExecutionController executionController);
    private static IReadOnlyList`1<Pair`2<GlobalTypeName, TypeStatistics>> PairWithTypeName(TypeAggregate aggregatedInfo, ITypeService typeService, IMetadataService metadataService);
    private static GlobalTypeName CreateGlobalTypeName(TypeId typeId, Dictionary`2<TypeId, GlobalTypeName> globalTypeNamesCache, ITypeService typeService, IMetadataService metadataService);
    [NotNullAttribute]
private static IEnumerable`1<GlobalTypeName> GetGlobalTypeNamesForGenericArguments(IReadOnlyCollection`1<ITypeName> genericArguments, Dictionary`2<TypeId, GlobalTypeName> globalTypeNamesCache, ITypeService typeService, IMetadataService metadataService);
    [CompilerGeneratedAttribute]
private static int <PairWithTypeName>b__1(Pair`2<GlobalTypeName, TypeStatistics> l, Pair`2<GlobalTypeName, TypeStatistics> r);
}
[UsedImplicitlyAttribute]
public class JetBrains.dotMemory.Model.Comparison.SnapshotComparer : object {
    private IComparisonPair`1<IAllObjectsSetReference> myAllObjectsSetPair;
    private IComparisonPair`1<IEntityReference`1<IObjectTypeCollection>> myObjectTypeCollectionPair;
    private IComparisonPair`1<IEntityReference`1<IObjectSizeCollection>> myObjectSizeCollectionPair;
    private IComparisonPair`1<IEntityReference`1<IGlobalObjectNumbersCollection>> myObjectGlobalNumberCollectionPair;
    private IComparisonPair`1<ITypeSection> myTypeSectionPair;
    [CompilerGeneratedAttribute]
private static Func`2<TypeComparisonInfo, bool> CS$<>9__CachedAnonymousMethodDelegate4;
    public SnapshotComparer(IComparisonPair`1<IAllObjectsSetReference> allObjectsSetPair, IComparisonPair`1<IEntityReference`1<IObjectTypeCollection>> objectTypeCollectionPair, IComparisonPair`1<IEntityReference`1<IObjectSizeCollection>> objectSizeCollectionPair, IComparisonPair`1<IEntityReference`1<IGlobalObjectNumbersCollection>> objectGlobalNumberCollectionPair, IComparisonPair`1<ITypeSection> typeSectionPair);
    public sealed virtual IReadOnlyCollection`1<TypeComparisonInfo> Compare(IExecutionController executionController);
    [CompilerGeneratedAttribute]
private static bool <Compare>b__3(TypeComparisonInfo x);
}
[UsedImplicitlyAttribute]
internal class JetBrains.dotMemory.Model.Comparison.SnapshotsComparisonSummaryCalculator : object {
    private ISnapshotComparer mySnapshotsComparer;
    public SnapshotsComparisonSummaryCalculator(ISnapshotComparer snapshotsComparer);
    public sealed virtual SnapshotsComparisonSummary Calculate(IExecutionController executionController);
}
[UsedImplicitlyAttribute]
public class JetBrains.dotMemory.Model.Comparison.SnapshotsComparisonSummaryDiskCache : object {
    private static string DataName;
    private static Version FormatVersion;
    private ISharedCacheDataStorage myStorage;
    private ISnapshotsComparisonSummaryCalculator myCalculator;
    [CompilerGeneratedAttribute]
private static Action`3<SnapshotsComparisonSummary, BinaryWriter, IExecutionController> CS$<>9__CachedAnonymousMethodDelegate3;
    [CompilerGeneratedAttribute]
private static Func`3<BinaryReader, IExecutionController, SnapshotsComparisonSummary> CS$<>9__CachedAnonymousMethodDelegate4;
    public SnapshotsComparisonSummaryDiskCache(ISharedCacheDataStorage storage, ISnapshotsComparisonSummaryCalculator calculator);
    private static SnapshotsComparisonSummaryDiskCache();
    public sealed virtual SnapshotsComparisonSummary Calculate(IExecutionController executionController);
    [CompilerGeneratedAttribute]
private SnapshotsComparisonSummary <Calculate>b__0(IExecutionController controller);
    [CompilerGeneratedAttribute]
private static void <Calculate>b__1(SnapshotsComparisonSummary summary, BinaryWriter writer, IExecutionController controller);
    [CompilerGeneratedAttribute]
private static SnapshotsComparisonSummary <Calculate>b__2(BinaryReader reader, IExecutionController _);
}
[UsedImplicitlyAttribute]
public class JetBrains.dotMemory.Model.CuttedSessionDetector : object {
    private ISnapshotServiceLocator mySnapshotServiceLocator;
    private IReadOnlyList`1<ISnapshot> mySnapshots;
    private object myCalculationAccessor;
    private bool myIsCalculated;
    private bool mySessionCutted;
    private int mySnapshotIndexCutPoint;
    private GCNumber myGCNumberCutPoint;
    public bool IsSessionCutted { get; }
    public int SnapshotIndexCutPoint { get; }
    public GCNumber GCNumberCutPoint { get; }
    public CuttedSessionDetector(ISnapshotServiceLocator snapshotServiceLocator, IReadOnlyList`1<ISnapshot> snapshots);
    public sealed virtual bool get_IsSessionCutted();
    public sealed virtual int get_SnapshotIndexCutPoint();
    public sealed virtual GCNumber get_GCNumberCutPoint();
    private void Calculate();
}
[UsedImplicitlyAttribute]
public class JetBrains.dotMemory.Model.DataMemoryCache`1 : MemoryCache`1<T> {
    public DataMemoryCache`1(IEntityProvider`1<T> dataProvider, TimeSpan holdInMemoryPeriod, Lifetime lifetime);
}
internal class JetBrains.dotMemory.Model.DetailedGraph : object {
    private IGraphIndexReader myGraphIndexReader;
    private IGraphReferenceTargetsReader myGraphReferenceTargetsReader;
    private IGraphReferenceDetailsReader myReferenceDetailsReader;
    public int NodesCount { get; }
    public int EdgesCount { get; }
    public DetailedGraph(IGraphIndexReader graphIndexReader, IGraphReferenceTargetsReader graphReferenceTargetsReader, IGraphReferenceDetailsReader referenceDetailsReader);
    public sealed virtual int get_NodesCount();
    public sealed virtual int get_EdgesCount();
    public sealed virtual int GetReferencesCount(ObjectNumber objectNumber);
    public sealed virtual IEnumerable`1<ObjectNumber> GetReferencedObjectNumbers(ObjectNumber objectNumber);
    public sealed virtual IReadOnlyCollection`1<GraphReference> GetReferences(ObjectNumber objectNumber);
    public sealed virtual IEnumerable`1<GraphReferenceId> GetReferenceIds(ObjectNumber objectNumber);
    private int GetReferencesCount(int objectIndex, int firstReferenceIndex);
}
public class JetBrains.dotMemory.Model.Dominators.CompactDominatorTreeReference : object {
    private IObjectSetReference myObjectSetRef;
    private IEntityReference`1<IObjectTypeCollection> myObjectTypesRef;
    private IEntityReference`1<IObjectSizeCollection> myObjectSizesRef;
    private IEntityReference`1<IDominatorTreeParentCollection> myDominatorParentsRef;
    public CompactDominatorTreeReference(IObjectSetReference objectSetRef, IEntityReference`1<IObjectTypeCollection> objectTypesRef, IEntityReference`1<IObjectSizeCollection> objectSizesRef, IEntityReference`1<IDominatorTreeParentCollection> dominatorParentsRef);
    public sealed virtual CompactDominatorTree GetEntity(IExecutionController executionController, Lifetime lifetime);
}
public class JetBrains.dotMemory.Model.Dominators.DomianatorTreeParentCollection : ChunkArray`1<ObjectNumber> {
    public DomianatorTreeParentCollection(int length);
}
[UsedImplicitlyAttribute]
public class JetBrains.dotMemory.Model.Dominators.DominatorTreeCalculatorBelov : object {
    public static IDominatorTreeParentCollection Calculate(IDfsData dfsData, GraphData originalReverseGraph, IReadOnlyCollection`1<ObjectNumber> rootCollection, IExecutionController executionController);
    private static void Compress(int node, ChunkArray`1<int> semiDominator, ChunkArray`1<int> label, ChunkArray`1<int> enterTimeOf, ChunkArray`1<ObjectNumber> ancestorOf);
}
public class JetBrains.dotMemory.Model.Dominators.DominatorTreeCalculatorCooper : object {
    private IEntityReference`1<IGraphRootTargetsCollection> myRootCollectionReference;
    private IEntityReference`1<GraphData> myDirectGraphReference;
    private IEntityReference`1<GraphData> myReverseGraphReference;
    public DominatorTreeCalculatorCooper(IEntityReference`1<IGraphRootTargetsCollection> rootCollectionReference, IEntityReference`1<GraphData> directGraphReference, IEntityReference`1<GraphData> reverseGraphReference);
    public ChunkArray`1<ObjectNumber> Calculate(IExecutionController executionController);
    private static ObjectNumber IntersectDominatorsSets(ObjectNumber parent, ObjectNumber newIdom, IReadOnlyList`1<ObjectNumber> immediateDominator, IReadOnlyList`1<int> exitTimeOf);
}
public static class JetBrains.dotMemory.Model.Dominators.DominatorTreeCalculatorSimpleTarjan : object {
    public static IDominatorTreeParentCollection Calculate(IDfsData dfsData, IGraph originalReverseGraph, IEnumerable`1<ObjectNumber> rootCollection, IExecutionController executionController);
    private static void Compress(int v, ChunkArray`1<int> parent, ChunkArray`1<int> semi, ChunkArray`1<int> label, int c);
}
[UsedImplicitlyAttribute]
public class JetBrains.dotMemory.Model.Dominators.DominatorTreeCalculatorTarjan : object {
    private IEntityReference`1<IGraphRootTargetsCollection> myRootCollectionReference;
    private IEntityReference`1<IDirectGraph> myDirectGraphReference;
    private IEntityReference`1<IReverseGraph> myReverseGraphReference;
    public DominatorTreeCalculatorTarjan(IEntityReference`1<IGraphRootTargetsCollection> rootCollectionReference, IEntityReference`1<IDirectGraph> directGraphReference, IEntityReference`1<IReverseGraph> reverseGraphReference);
    public ChunkArray`1<ObjectNumber> Calculate(IExecutionController executionController);
}
[UsedImplicitlyAttribute]
public class JetBrains.dotMemory.Model.Dominators.DominatorTreeService : object {
    private IEntityReference`1<IDominatorTreeParentCollection> myDominatorParentDataReference;
    private IEntityReference`1<IObjectRetainedSizeCollection> mySizeDataReference;
    private IEntityReference`1<IEnterTimeCollection> myEnterTimesReference;
    private IEntityReference`1<IExitTimeCollection> myExitTimesReference;
    public DominatorTreeService(IEntityReference`1<IDominatorTreeParentCollection> dominatorParentDataReference, IEntityReference`1<IObjectRetainedSizeCollection> sizeDataReference, IEntityReference`1<IEnterTimeCollection> enterTimesReference, IEntityReference`1<IExitTimeCollection> exitTimesReference);
    public sealed virtual ICollection`1<Dominator> GetDominatedPathOf(ObjectNumber objectNumber, IExecutionController executionController);
    public sealed virtual ulong GetMinRetainedSize(IEnumerable`1<ObjectNumber> set, IExecutionController executionController);
}
[DefaultMemberAttribute("Item")]
public class JetBrains.dotMemory.Model.Dominators.DominatorTreeWrapper : object {
    private IReadOnlyList`1<ObjectNumber> myCollection;
    public int Count { get; }
    public ObjectNumber Item { get; }
    public DominatorTreeWrapper(IReadOnlyList`1<ObjectNumber> collection);
    public sealed virtual IEnumerator`1<ObjectNumber> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual int get_Count();
    public sealed virtual ObjectNumber get_Item(int index);
}
public class JetBrains.dotMemory.Model.EntityReference`1 : object {
    private Func`3<IExecutionController, Lifetime, T> myFactory;
    public EntityReference`1(Func`3<IExecutionController, Lifetime, T> factory);
    public sealed virtual T GetEntity(IExecutionController executionController, Lifetime lifetime);
}
[UsedImplicitlyAttribute]
public class JetBrains.dotMemory.Model.FieldGraphNavigator : object {
    private IDirectGraph myGraph;
    private IMetadataService myMetadataService;
    private IDirectGraphDetails myGraphDetails;
    public FieldGraphNavigator(IExecutionController ec, Lifetime lifetime, IEntityReference`1<IMetadataService> metadataServiceReference, IEntityReference`1<IDirectGraphDetails> graphDetailsReference, IEntityReference`1<IDirectGraph> graphReference, IFieldNameService fieldNameService);
    public FieldGraphNavigator(IMetadataService metadataService, IFieldNameService fieldNameService, IDirectGraphDetails graphDetails, IDirectGraph graph);
    public sealed virtual IEnumerable`1<ObjectNumber> Get(ObjectNumber start, string fieldName);
    public sealed virtual IEnumerable`1<ObjectNumber> Get(IEnumerable`1<ObjectNumber> start, IEnumerable`1<string> path);
}
[UsedImplicitlyAttribute]
public class JetBrains.dotMemory.Model.FieldNameService : object {
    private IReverseGraphReferenceDetailsReader myGraphReferenceDetailsReader;
    private IObjectArrayInfo myObjectArrayInfo;
    private IMetadataService myMetadataService;
    private ISnapshotDiagnosticService mySnapshotDiagnostic;
    [CompilerGeneratedAttribute]
private static Func`2<UInt32, string> CS$<>9__CachedAnonymousMethodDelegate1;
    public FieldNameService(IReverseGraphReferenceDetailsReader graphReferenceDetailsReader, ITypeService typeService, IObjectArrayInfo objectArrayInfo, IMetadataService metadataService, ISnapshotDiagnosticService snapshotDiagnostic);
    public sealed virtual string GetFieldName(GraphReferenceId reverseGraphReferenceId);
    public sealed virtual string GetFieldName(GraphReference reverseGraphReference);
    private string GetFieldName(SectionPointer`1<IFieldNamesCollection> fieldNameOffset, int arrayIndex, ObjectNumber fromObjectNumber, bool getExactIndicies);
    private string __GetFieldName(SectionPointer`1<IFieldNamesCollection> fieldNameOffset, int arrayIndex, ObjectNumber fromObjectNumber, bool getExactIndicies);
    public sealed virtual string GetFieldName(IStaticReference staticReference);
    public sealed virtual string GetFieldNameWithoutExactIndicies(GraphReferenceId reverseGraphReferenceId);
    [NotNullAttribute]
private static string GetNotNullFieldName(string originalFieldName);
    private static string ArrayIndeciesAsString(IEnumerable`1<UInt32> indicies);
    [CompilerGeneratedAttribute]
private static string <ArrayIndeciesAsString>b__0(UInt32 _);
}
[UsedImplicitlyAttribute]
public class JetBrains.dotMemory.Model.FunctionSignatureModel.CachingFunctionService : object {
    private IFunctionService myRealService;
    private IFunctionSignatureCache myCache;
    public CachingFunctionService(IFunctionService realService, IFunctionSignatureCache cache);
    public sealed virtual IFunctionSignature Get(MethodId methodId);
    [CompilerGeneratedAttribute]
private IFunctionSignature <Get>b__0(MethodId mid);
}
[UsedImplicitlyAttribute]
public class JetBrains.dotMemory.Model.FunctionSignatureModel.FunctionService : object {
    private ITypeService myTypeService;
    private IMetadataService myMetadataService;
    private IExecutionMode myExecutionMode;
    private ILogger myLogger;
    [CompilerGeneratedAttribute]
private static Func`2<IMetadataGenericArgument, string> CS$<>9__CachedAnonymousMethodDelegate2;
    public FunctionService(ITypeService typeService, IMetadataService metadataService, IExecutionMode executionMode, ILogger logger);
    public sealed virtual IFunctionSignature Get(MethodId methodId);
    private IFunctionSignature Get(IMetadataMethod metadataMethod);
    [CanBeNullAttribute]
private IFunctionSignature TraverseExplicitInterfaceImplementations(IMetadataMethod metadataMethod, String& realMethodName);
    [CompilerGeneratedAttribute]
private static string <Get>b__0(IMetadataGenericArgument ga);
    [CompilerGeneratedAttribute]
private Parameter <Get>b__1(IMetadataParameter p);
}
[DebuggerDisplayAttribute("{Name}")]
internal class JetBrains.dotMemory.Model.FunctionSignatureModel.FunctionSignature : object {
    private static string Ctor;
    private static string CCtor;
    private bool myIsSpecialName;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private IFunctionSignature <ExplicitlyImplementedMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private ITypeName <DeclaringClass>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<string> <GenericArguments>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<IParameter> <Parameters>k__BackingField;
    [CompilerGeneratedAttribute]
private ITypeName <ReturnValue>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NonClrMethod>k__BackingField;
    [NotNullAttribute]
public string Name { get; private set; }
    [CanBeNullAttribute]
public IFunctionSignature ExplicitlyImplementedMethod { get; private set; }
    [NotNullAttribute]
public ITypeName DeclaringClass { get; private set; }
    [NotNullAttribute]
public IReadOnlyCollection`1<string> GenericArguments { get; private set; }
    [NotNullAttribute]
public IReadOnlyCollection`1<IParameter> Parameters { get; private set; }
    [NotNullAttribute]
public ITypeName ReturnValue { get; private set; }
    public bool IsCtor { get; }
    public bool NonClrMethod { get; private set; }
    private FunctionSignature(string name, ITypeName declaringClass, IReadOnlyCollection`1<string> genericArguments, IReadOnlyCollection`1<IParameter> parameters, ITypeName returnValue, IFunctionSignature explicitlyImplementedInterfaceMethod, bool isSpecialName, bool isClrMethod);
    public static FunctionSignature CreateNonClrMethod(string functionName);
    public static FunctionSignature CreateClrMethod(string name, ITypeName declaringClass, IReadOnlyCollection`1<string> genericArguments, IReadOnlyCollection`1<IParameter> parameters, ITypeName returnValue, IFunctionSignature explicitlyImplementedInterfaceMethod, bool isSpecialName);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public sealed virtual IFunctionSignature get_ExplicitlyImplementedMethod();
    [CompilerGeneratedAttribute]
private void set_ExplicitlyImplementedMethod(IFunctionSignature value);
    [CompilerGeneratedAttribute]
public sealed virtual ITypeName get_DeclaringClass();
    [CompilerGeneratedAttribute]
private void set_DeclaringClass(ITypeName value);
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyCollection`1<string> get_GenericArguments();
    [CompilerGeneratedAttribute]
private void set_GenericArguments(IReadOnlyCollection`1<string> value);
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyCollection`1<IParameter> get_Parameters();
    [CompilerGeneratedAttribute]
private void set_Parameters(IReadOnlyCollection`1<IParameter> value);
    [CompilerGeneratedAttribute]
public sealed virtual ITypeName get_ReturnValue();
    [CompilerGeneratedAttribute]
private void set_ReturnValue(ITypeName value);
    public sealed virtual bool get_IsCtor();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_NonClrMethod();
    [CompilerGeneratedAttribute]
private void set_NonClrMethod(bool value);
    public sealed virtual int CompareTo(IFunctionSignature other);
}
[UsedImplicitlyAttribute]
public class JetBrains.dotMemory.Model.FunctionSignatureModel.FunctionSignatureCache : object {
    private Lifetime myLifetime;
    private object myFunctionSignatureCacheAccess;
    private StrongToWeakDictionary`2<MethodId, IFunctionSignature> myFunctionSignatureCache;
    public FunctionSignatureCache(Lifetime lifetime);
    [NotNullAttribute]
public sealed virtual IFunctionSignature GetOrCreate(MethodId methodId, Func`2<MethodId, IFunctionSignature> createFunctionSignature);
    [CompilerGeneratedAttribute]
private void <.ctor>b__0();
}
internal class JetBrains.dotMemory.Model.FunctionSignatureModel.Parameter : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private ITypeName <Type>k__BackingField;
    public string Name { get; private set; }
    public ITypeName Type { get; private set; }
    public Parameter(string name, ITypeName type);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public sealed virtual ITypeName get_Type();
    [CompilerGeneratedAttribute]
private void set_Type(ITypeName value);
}
[UsedImplicitlyAttribute]
public class JetBrains.dotMemory.Model.GetObjectsDirectlyRetainedByDependencyProperty : object {
    private static string ArrayIndexFieldFlag;
    private static string InvocationList;
    private static string Name;
    private static string TargetField;
    private static String[] ourPathFromDescriptorToDependencyObject;
    private IEntityReference`1<IMetadataService> myMetadataServiceReference;
    private IEntityReference`1<IDirectGraphDetails> myGraphDetailsReference;
    private IEntityReference`1<IDirectGraph> myGraphReference;
    private IFieldValuesProvider myFieldValuesProvider;
    [CompilerGeneratedAttribute]
private static Func`2<FieldDescription, string> CS$<>9__CachedAnonymousMethodDelegate3;
    public GetObjectsDirectlyRetainedByDependencyProperty(IEntityReference`1<IMetadataService> metadataServiceReference, IEntityReference`1<IDirectGraphDetails> graphDetailsReference, IEntityReference`1<IDirectGraph> graphReference, IFieldValuesProvider fieldValuesProvider);
    private static GetObjectsDirectlyRetainedByDependencyProperty();
    private IList`1<string> GetDependencyPropertyName(ObjectNumber dependencyObjectPropertyDescriptor, IGraph graph, IGraphDetails graphDetails, IMetadataService metadataService);
    public sealed virtual IEnumerable`1<RetainedObjectAndDependencyPropertyNames> Get(IExecutionController controller, IEnumerable`1<ObjectNumber> start);
    [CompilerGeneratedAttribute]
private static string <GetDependencyPropertyName>b__2(FieldDescription _);
}
public class JetBrains.dotMemory.Model.GraphDetails : object {
    private IReadOnlyList`1<GraphReferenceDetails> myDetails;
    public GraphDetails(IReadOnlyList`1<GraphReferenceDetails> details);
    public sealed virtual GraphReference GetArcDetails(GraphReferenceId graphReferenceId);
}
[ExtensionAttribute]
internal static class JetBrains.dotMemory.Model.GraphExtension : object {
    [ExtensionAttribute]
public static GraphData DirectGraphToSuperRootDirectGraph(GraphData originalGraph, IGraphRootTargetsCollection rootCollection, ObjectNumber rootNumber);
    [ExtensionAttribute]
public static GraphData ReverseGraphToSuperRootReverseGraph(GraphData reverseGraph, IReadOnlyCollection`1<ObjectNumber> rootCollection, ObjectNumber superRootNumber);
}
public class JetBrains.dotMemory.Model.HeapFragmentationMap : object {
    private ulong myResolution;
    private List`1<MemoryFragment> myMemoryFragments;
    private UInt32 myObjectsCount;
    private ulong myPinnedBytesCount;
    private ulong myNotPinnedBytesCount;
    private ulong myMaxFreeBlock;
    private ulong myClrReservedBytesCount;
    private PropertyChangedEventHandler PropertyChanged;
    [CompilerGeneratedAttribute]
private HeapDescription <HeapDescription>k__BackingField;
    [CompilerGeneratedAttribute]
private int <HeapIndex>k__BackingField;
    public HeapDescription HeapDescription { get; private set; }
    public int HeapIndex { get; private set; }
    public UInt32 ObjectsCount { get; }
    public ulong TotalUsedBytesCount { get; }
    public ulong NotPinnedBytesCount { get; }
    public ulong ClrReservedBytesCount { get; }
    public ulong PinnedBytesCount { get; }
    public double Utilization { get; }
    public double Fragmentation { get; }
    public ulong MaxFreeBlock { get; }
    public IReadOnlyCollection`1<IMemoryFragment> MemoryFragments { get; }
    public HeapFragmentationMap(HeapDescription heapDescription, int heapIndex, ulong resolution);
    [CompilerGeneratedAttribute]
public sealed virtual HeapDescription get_HeapDescription();
    [CompilerGeneratedAttribute]
private void set_HeapDescription(HeapDescription value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_HeapIndex();
    [CompilerGeneratedAttribute]
private void set_HeapIndex(int value);
    public sealed virtual UInt32 get_ObjectsCount();
    public sealed virtual ulong get_TotalUsedBytesCount();
    public sealed virtual ulong get_NotPinnedBytesCount();
    public sealed virtual ulong get_ClrReservedBytesCount();
    public sealed virtual ulong get_PinnedBytesCount();
    public sealed virtual double get_Utilization();
    public sealed virtual double get_Fragmentation();
    public sealed virtual ulong get_MaxFreeBlock();
    public sealed virtual IReadOnlyCollection`1<IMemoryFragment> get_MemoryFragments();
    public void PushObject(ulong address, ulong size, bool isPinned, bool isStaticStorage);
    private MemoryFragment CreateEmptyMemoryFragment(ulong start, ulong end);
    public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
}
[UsedImplicitlyAttribute]
public class JetBrains.dotMemory.Model.HeapsService : object {
    private IEntityReference`1<IAccessibilityMask> myAccessibilityMaskReference;
    private IEntityReference`1<IGraphRootCollection> myRootsReference;
    private IEntityReference`1<IObjectRootReferencesCollection> myIncomingRootReferencesReference;
    private IEntityReference`1<IHeapsCollection> myHeapsReference;
    private IEntityReference`1<IObjectSizeCollection> mySizesReference;
    private IEntityReference`1<IObjectAddressCollection> myAddressesReference;
    [CompilerGeneratedAttribute]
private static Func`3<ulong, int, Pair`2<ObjectNumber, ulong>> CS$<>9__CachedAnonymousMethodDelegate5;
    [CompilerGeneratedAttribute]
private static Comparison`1<Pair`2<ObjectNumber, ulong>> CS$<>9__CachedAnonymousMethodDelegate6;
    [CompilerGeneratedAttribute]
private static Func`2<HeapDescription, ulong> CS$<>9__CachedAnonymousMethodDelegate10;
    public HeapsService(IEntityReference`1<IAccessibilityMask> accessibilityMaskReference, IEntityReference`1<IGraphRootCollection> rootsReference, IEntityReference`1<IObjectRootReferencesCollection> incomingRootReferencesReference, IEntityReference`1<IHeapsCollection> heapsReference, IEntityReference`1<IObjectSizeCollection> sizesReference, IEntityReference`1<IObjectAddressCollection> addressesReference);
    public sealed virtual IReadOnlyCollection`1<IHeapFragmentationMap> CalculateHeapsFragmentationMaps(ulong resolution, IExecutionController executionController);
    public sealed virtual IReadOnlyCollection`1<ObjectByHeapStats> Aggregate(IObjectSet objectSet, IExecutionController executionController);
    public sealed virtual ulong MaxHeapSize(IExecutionController executionController);
    [CompilerGeneratedAttribute]
private static Pair`2<ObjectNumber, ulong> <CalculateHeapsFragmentationMaps>b__1(ulong arg1, int i);
    [CompilerGeneratedAttribute]
private static int <CalculateHeapsFragmentationMaps>b__2(Pair`2<ObjectNumber, ulong> l, Pair`2<ObjectNumber, ulong> r);
    [CompilerGeneratedAttribute]
private static ulong <MaxHeapSize>b__f(HeapDescription description);
}
public interface JetBrains.dotMemory.Model.Impl.IStorageSectionsProvider {
    public abstract virtual T Get();
}
[UsedImplicitlyAttribute]
public class JetBrains.dotMemory.Model.Impl.Services.ObjectsGraphService : object {
    private IEntityReference`1<IGraphRootTargetsCollection> myRootCollectionReference;
    private IEntityReference`1<IDirectGraph> myDirectGraphReference;
    private ISnapshot mySnapshot;
    public ObjectsGraphService(IDominatorTree dominatorTree, IEntityReference`1<IGraphRootTargetsCollection> rootCollectionReference, IEntityReference`1<IDirectGraph> directGraphReference, ISnapshot snapshot);
    public sealed virtual IEnumerable`1<ObjectNumber> GetRetainedSet(IEnumerable`1<ObjectNumber> objectSet, IExecutionController executionController);
}
internal class JetBrains.dotMemory.Model.Imprints.ProcessImprint : object {
    private ProfilingSessionId mySessionId;
    private FileSystemPath myExecutablePath;
    private ICollection`1<ISnapshotImprint> mySnapshots;
    public ProfilingSessionId SessionId { get; }
    public FileSystemPath ExecutablePath { get; }
    public IEnumerable`1<ISnapshotImprint> Snapshots { get; }
    public ProcessImprint(ProfilingSessionId sessionId, FileSystemPath executablePath);
    public sealed virtual ProfilingSessionId get_SessionId();
    public sealed virtual FileSystemPath get_ExecutablePath();
    public sealed virtual IEnumerable`1<ISnapshotImprint> get_Snapshots();
    public void AddSnapshot(ISnapshotImprint snapshot);
}
internal class JetBrains.dotMemory.Model.Imprints.SnapshotImprint : object {
    [CompilerGeneratedAttribute]
private SnapshotId <SnapshotId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SnapshotName>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <CreationTime>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TotalMemoryAmount>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TotalNetMemoryAmount>k__BackingField;
    [CompilerGeneratedAttribute]
private long <UsedNetMemoryAmount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ObjectsNumber>k__BackingField;
    public SnapshotId SnapshotId { get; private set; }
    public string SnapshotName { get; private set; }
    public DateTime CreationTime { get; private set; }
    public long TotalMemoryAmount { get; private set; }
    public long TotalNetMemoryAmount { get; private set; }
    public long UsedNetMemoryAmount { get; private set; }
    public int ObjectsNumber { get; private set; }
    public SnapshotImprint(SnapshotId snapshotId, string snapshotName, DateTime creationTime, long totalMemoryAmount, long totalNetMemoryAmount, long usedNetMemoryAmount, int objectsNumber);
    [CompilerGeneratedAttribute]
public sealed virtual SnapshotId get_SnapshotId();
    [CompilerGeneratedAttribute]
private void set_SnapshotId(SnapshotId value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_SnapshotName();
    [CompilerGeneratedAttribute]
private void set_SnapshotName(string value);
    [CompilerGeneratedAttribute]
public sealed virtual DateTime get_CreationTime();
    [CompilerGeneratedAttribute]
private void set_CreationTime(DateTime value);
    [CompilerGeneratedAttribute]
public sealed virtual long get_TotalMemoryAmount();
    [CompilerGeneratedAttribute]
private void set_TotalMemoryAmount(long value);
    [CompilerGeneratedAttribute]
public sealed virtual long get_TotalNetMemoryAmount();
    [CompilerGeneratedAttribute]
private void set_TotalNetMemoryAmount(long value);
    [CompilerGeneratedAttribute]
public sealed virtual long get_UsedNetMemoryAmount();
    [CompilerGeneratedAttribute]
private void set_UsedNetMemoryAmount(long value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_ObjectsNumber();
    [CompilerGeneratedAttribute]
private void set_ObjectsNumber(int value);
}
internal class JetBrains.dotMemory.Model.Imprints.WorkspaceImprint : object {
    private WorkspaceId myWorkspaceId;
    private FileSystemPath myWorkspacePath;
    private WorkspaceStatus myWorkspaceStatus;
    private string myProductName;
    private ICollection`1<IProcessImprint> myProcesses;
    public WorkspaceId WorkspaceId { get; }
    public FileSystemPath WorkspacePath { get; }
    public WorkspaceStatus WorkspaceStatus { get; }
    public string ProductName { get; }
    public IEnumerable`1<IProcessImprint> Processes { get; }
    public WorkspaceImprint(WorkspaceId workspaceId, FileSystemPath workspacePath, WorkspaceStatus workspaceStatus, string productName);
    public sealed virtual WorkspaceId get_WorkspaceId();
    public sealed virtual FileSystemPath get_WorkspacePath();
    public sealed virtual WorkspaceStatus get_WorkspaceStatus();
    public sealed virtual string get_ProductName();
    public sealed virtual IEnumerable`1<IProcessImprint> get_Processes();
    public void AddProcess(IProcessImprint process);
}
internal class JetBrains.dotMemory.Model.Imprints.WorkspaceImprintCollection : object {
    private ReadonlyToken myToken;
    private IDictionary`2<WorkspaceId, int> myWorkspaceImprintIndices;
    private ListEvents`1<IWorkspaceImprint> myImprints;
    private Func`3<WorkspaceId, IExecutionController, IWorkspaceImprint> myGetImprint;
    public IListEvents`1<IWorkspaceImprint> Imprints { get; }
    public WorkspaceImprintCollection(Lifetime lifetime, IEnumerable`1<IWorkspaceImprint> imprints, Func`3<WorkspaceId, IExecutionController, IWorkspaceImprint> getImprint);
    public sealed virtual void ReloadImprint(WorkspaceId workspaceId, IExecutionController executionController);
    public sealed virtual void SetImprint(WorkspaceId workspaceId, IWorkspaceImprint workspaceImprint);
    public sealed virtual IListEvents`1<IWorkspaceImprint> get_Imprints();
}
internal class JetBrains.dotMemory.Model.Imprints.WorkspaceImprintCollectionProvider : object {
    private Lifetime myLifetime;
    private WorkspaceId myWorkspaceId;
    private IWorkspaceStorage myWorkspaceStorage;
    private IWorkspaceImprintProvider myWorkspaceImprintsProvider;
    private object myLock;
    private IWorkspaceImprintCollection myImprintCollection;
    [CompilerGeneratedAttribute]
private static Func`2<WorkspaceHistoryItem, DateTime> CS$<>9__CachedAnonymousMethodDelegate3;
    public WorkspaceImprintCollectionProvider(Lifetime lifetime, WorkspaceId workspaceId, IWorkspaceStorage workspaceStorage, IWorkspaceImprintProvider workspaceImprintsProvider);
    public IWorkspaceImprintCollection CreateImprintCollection(IExecutionController executionController);
    public sealed virtual IWorkspaceImprintCollection GetData(IExecutionController executionController);
    [CompilerGeneratedAttribute]
private bool <CreateImprintCollection>b__0(WorkspaceHistoryItem item);
    [CompilerGeneratedAttribute]
private static DateTime <CreateImprintCollection>b__1(WorkspaceHistoryItem _);
}
[UsedImplicitlyAttribute]
public class JetBrains.dotMemory.Model.IndependentPathsFinder : object {
    private IDominatorTreeParentCollection myDominatorTreeParentCollection;
    private IEntityReference`1<IObjectRootReferencesCollection> myRootsReferencesCollectionReference;
    private IEntityReference`1<IReverseGraph> myReverseGraphReference;
    private IEntityReference`1<IDirectGraph> myDirectGraphReference;
    private IEntityReference`1<IReverseToDirectReferenceMap> myReverseToDirectRefMapReference;
    private ChunkArray`1<bool> myMarks;
    private Queue`1<int> myQueue;
    private ChunkArray`1<Pair`2<int, int>> myTree;
    private ChunkArray`1<int> myVisited;
    private int myLastVisitedCount;
    private HashSet`1<int> myExcludedReferences;
    private HashSet`1<ObjectNumber> myExcludedObjects;
    [CompilerGeneratedAttribute]
private static Func`2<GraphReferenceId, bool> CS$<>9__CachedAnonymousMethodDelegate6;
    [CompilerGeneratedAttribute]
private static Comparison`1<IReversePath> CS$<>9__CachedAnonymousMethodDelegate7;
    public IndependentPathsFinder(IDominatorTreeParentCollection dominatorTreeParentCollection, IEntityReference`1<IObjectRootReferencesCollection> rootsReferencesCollectionReference, IEntityReference`1<IReverseGraph> reverseGraphReference, IEntityReference`1<IDirectGraph> directGraphReference, IEntityReference`1<IReverseToDirectReferenceMap> reverseToDirectRefMapReference);
    public sealed virtual IEnumerable`1<IReversePath> FindPathsToDominator(ObjectNumber objectNumber, int maxPathsCount, IExecutionController executionController, IEnumerable`1<GraphReferenceId> excludedReferences, IEnumerable`1<ObjectNumber> excludedObjects);
    private IEnumerable`1<FlowReference> GetFlowReferences(int objectNumber, IDirectGraph directGraph, IReverseGraph reverseGraph, IReadOnlyList`1<int> reverseToDirectRefMapper, ChunkArray`1<bool> saturatedEdges, ChunkArray`1<bool> saturatedNodes);
    private bool IsFinish(int number, ObjectNumber dominator, IObjectRootReferencesCollection rootsReferences);
    private bool FindAndSaturatePath(ObjectNumber objectNumber, IDirectGraph directGraph, IReverseGraph reverseGraph, IReadOnlyList`1<int> reverseToDirectRefMapper, ChunkArray`1<bool> saturatedEdges, ChunkArray`1<bool> saturatedNodes, ObjectNumber dominator, IObjectRootReferencesCollection rootsReferences, IExecutionController executionController);
    [CompilerGeneratedAttribute]
private static bool <FindPathsToDominator>b__1(GraphReferenceId id);
    [CompilerGeneratedAttribute]
private static int <FindPathsToDominator>b__5(IReversePath l, IReversePath r);
}
[UsedImplicitlyAttribute]
public class JetBrains.dotMemory.Model.Inspections.DependencyPropertyLeakInspection.DependencyPropertyLeakInspection : object {
    private static string DependencyObjectPropertyDescriptorTypeName;
    private IAllObjectsSetReference myAllObjectsSetReference;
    private IEntityReference`1<ITypeResolvingService> myTypeResolvingServiceReference;
    private IEntityReference`1<IGetObjectsDirectlyRetainedByDependencyProperty> myGetObjectsDirectlyRetainedByDependencyPropertyReference;
    private IEntityReference`1<IObjectTypeCollection> myTypeCollectionReference;
    private IReachableObjectsService myReachableObjectsService;
    [CompilerGeneratedAttribute]
private static Func`2<RetainedObjectAndDependencyPropertyNames, ObjectNumber> CS$<>9__CachedAnonymousMethodDelegate5;
    [CompilerGeneratedAttribute]
private static Func`2<IGrouping`2<ObjectNumber, RetainedObjectAndDependencyPropertyNames>, RetainedObjectAndDependencyPropertyNames> CS$<>9__CachedAnonymousMethodDelegate6;
    [CompilerGeneratedAttribute]
private static Func`2<RetainedObjectAndDependencyPropertyNames, IEnumerable`1<string>> CS$<>9__CachedAnonymousMethodDelegate9;
    public DependencyPropertyLeakInspection(IEntityReference`1<IObjectTypeCollection> typeCollectionReference, IReachableObjectsService reachableObjectsService, IAllObjectsSetReference allObjectsSetReference, IEntityReference`1<ITypeResolvingService> typeResolvingServiceReference, IEntityReference`1<IGetObjectsDirectlyRetainedByDependencyProperty> getObjectsDirectlyRetainedByDependencyPropertyReference, ITypeService typeSerivce);
    [NotNullAttribute]
public sealed virtual IEnumerable`1<RetainedObjectAndDependencyPropertyNames> GetDependencyPropertyLeaks(IExecutionController controller);
    [CompilerGeneratedAttribute]
private static ObjectNumber <GetDependencyPropertyLeaks>b__2(RetainedObjectAndDependencyPropertyNames _);
    [CompilerGeneratedAttribute]
private static RetainedObjectAndDependencyPropertyNames <GetDependencyPropertyLeaks>b__3(IGrouping`2<ObjectNumber, RetainedObjectAndDependencyPropertyNames> _);
    [CompilerGeneratedAttribute]
private static IEnumerable`1<string> <GetDependencyPropertyLeaks>b__4(RetainedObjectAndDependencyPropertyNames i);
}
[UsedImplicitlyAttribute]
public class JetBrains.dotMemory.Model.Inspections.DependencyPropertyLeakInspection.DependencyPropertyLeakInspectionDiskCache : object {
    private static string StorageKey;
    private static Version ourDataFormatVersion;
    private IDependencyPropertyLeakInspection myDependencyPropertyLeakInspection;
    private ISharedCacheDataStorage myDataStorage;
    [CompilerGeneratedAttribute]
private static Func`3<BinaryReader, IExecutionController, ChunkList`1<RetainedObjectAndDependencyPropertyNames>> CS$<>9__CachedAnonymousMethodDelegate2;
    public DependencyPropertyLeakInspectionDiskCache(IDependencyPropertyLeakInspection dependencyPropertyLeakInspection, ISharedCacheDataStorage dataStorage);
    private static DependencyPropertyLeakInspectionDiskCache();
    public sealed virtual IEnumerable`1<RetainedObjectAndDependencyPropertyNames> GetDependencyPropertyLeaks(IExecutionController controller);
    private static void WriteData(IReadOnlyCollection`1<RetainedObjectAndDependencyPropertyNames> issues, BinaryWriter writer, IExecutionController controller);
    private static IEnumerable`1<RetainedObjectAndDependencyPropertyNames> ReadData(BinaryReader reader, IExecutionController controller);
    [CompilerGeneratedAttribute]
private ChunkList`1<RetainedObjectAndDependencyPropertyNames> <GetDependencyPropertyLeaks>b__0(IExecutionController creatingController);
    [CompilerGeneratedAttribute]
private static ChunkList`1<RetainedObjectAndDependencyPropertyNames> <GetDependencyPropertyLeaks>b__1(BinaryReader reader, IExecutionController readingController);
}
[UsedImplicitlyAttribute]
public class JetBrains.dotMemory.Model.Inspections.EventHandlers.EventHandlersInspection : object {
    private static string InvocationListFieldName;
    private IEntityReference`1<IDirectGraph> myGraphReference;
    private IObjectHandlerService myHandlerService;
    private IReachableObjectsService myReachableObjectsService;
    private IEntityReference`1<IGraphRootTargetsCollection> myRootsReference;
    private IAllObjectsSetReference myAllObjectsSetReference;
    private IEntityReference`1<IFieldGraphNavigator> myFieldGraphNavigatorReference;
    public EventHandlersInspection(IEntityReference`1<IDirectGraph> graphReference, IObjectHandlerService handlerService, IReachableObjectsService reachableObjectsService, IEntityReference`1<IGraphRootTargetsCollection> rootsReference, IAllObjectsSetReference allObjectsSetReference, IEntityReference`1<IFieldGraphNavigator> fieldGraphNavigatorReference);
    public sealed virtual IEnumerable`1<ObjectNumber> GetEventHandlersDescendants(IExecutionController controller);
}
[UsedImplicitlyAttribute]
public class JetBrains.dotMemory.Model.Inspections.EventHandlers.EventHandlersInspectionDiskCache : object {
    private static string StorageKey;
    private static Version ourDataFormatVersion;
    private IEventHandlersInspection myEventHandlersInspection;
    private ISharedCacheDataStorage myDataStorage;
    [CompilerGeneratedAttribute]
private static Func`3<BinaryReader, IExecutionController, ChunkList`1<ObjectNumber>> CS$<>9__CachedAnonymousMethodDelegate2;
    public EventHandlersInspectionDiskCache(IEventHandlersInspection eventHandlersInspection, ISharedCacheDataStorage dataStorage);
    private static EventHandlersInspectionDiskCache();
    public sealed virtual IEnumerable`1<ObjectNumber> GetEventHandlersDescendants(IExecutionController controller);
    private static void WriteData(IReadOnlyCollection`1<ObjectNumber> issues, BinaryWriter writer, IExecutionController controller);
    private static IEnumerable`1<ObjectNumber> ReadData(BinaryReader reader, IExecutionController controller);
    [CompilerGeneratedAttribute]
private ChunkList`1<ObjectNumber> <GetEventHandlersDescendants>b__0(IExecutionController creatingController);
    [CompilerGeneratedAttribute]
private static ChunkList`1<ObjectNumber> <GetEventHandlersDescendants>b__1(BinaryReader reader, IExecutionController readingController);
}
public class JetBrains.dotMemory.Model.Inspections.EventHandlers.FirstNotReachablePicker : object {
    private IObjectIsReachableCollection myIsReachableCollection;
    private IList`1<ObjectNumber> myFirstNotReachables;
    public IEnumerable`1<ObjectNumber> FirstNotReahables { get; }
    public FirstNotReachablePicker(IObjectIsReachableCollection isReachableCollection);
    public IEnumerable`1<ObjectNumber> get_FirstNotReahables();
    public sealed virtual bool EnterWhite(ObjectNumber current);
    public sealed virtual void EnterGrey(ObjectNumber current);
}
[UsedImplicitlyAttribute]
public class JetBrains.dotMemory.Model.Inspections.EventHandlers.ObjectHandlerService : object {
    private static byte Unknown;
    private static byte Handler;
    private static byte NotHandler;
    private IEntityReference`1<IObjectTypeCollection> myTypeCollection;
    private IEntityReference`1<IMetadataService> myMetadataServiceReference;
    private IEntityReference`1<ITypeSection> myTypeSectionReference;
    public ObjectHandlerService(IEntityReference`1<IObjectTypeCollection> typeCollection, IEntityReference`1<IMetadataService> metadataServiceReference, IEntityReference`1<ITypeSection> typeSectionReference);
    public sealed virtual IEnumerable`1<ObjectNumber> GetHandlers(IEnumerable`1<ObjectNumber> objects, IExecutionController executionController);
}
public class JetBrains.dotMemory.Model.Inspections.FinalizedObjects.FinalizedObjectIssueSet : object {
    private IReadOnlyCollection`1<FinalizedObjectsIssue> myIssues;
    private long myObjectsTotalCount;
    private int myObjectsCount;
    private int myTypesCount;
    public int Count { get; }
    public long ObjectsTotalCount { get; }
    public int ObjectsCount { get; }
    public int TypesCount { get; }
    public FinalizedObjectIssueSet(IReadOnlyCollection`1<FinalizedObjectsIssue> issues, long objectsTotalCount, int objectsCount, int typesCount);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IEnumerator`1<FinalizedObjectsIssue> GetEnumerator();
    public sealed virtual int get_Count();
    public sealed virtual long get_ObjectsTotalCount();
    public sealed virtual int get_ObjectsCount();
    public sealed virtual int get_TypesCount();
}
[UsedImplicitlyAttribute]
public class JetBrains.dotMemory.Model.Inspections.FinalizedObjects.FinalizedObjectsInspection : object {
    private IMetadataService myMetadataService;
    private IEntityReference`1<ISnapshottedFinalizedObjectSet> myFinalizedObjectsRef;
    [CompilerGeneratedAttribute]
private static Func`2<IMetadataClassType, bool> CS$<>9__CachedAnonymousMethodDelegate1;
    public FinalizedObjectsInspection(IMetadataService metadataService, IEntityReference`1<ISnapshottedFinalizedObjectSet> finalizedObjectsRef);
    public sealed virtual IFinalizedObjectIssueSet FindIssues(IExecutionController controller);
    private FinalizedObjectTypeHint GetTypeHint(TypeId typeId);
    [CompilerGeneratedAttribute]
private static bool <GetTypeHint>b__0(IMetadataClassType iface);
}
public class JetBrains.dotMemory.Model.Inspections.ObjectIsReachableCollection : ChunkArray`1<bool> {
    public ObjectIsReachableCollection(int length);
    public sealed virtual bool Reachable(ObjectNumber objectNumber);
    public sealed virtual bool NotReachable(ObjectNumber objectNumber);
}
[UsedImplicitlyAttribute]
public class JetBrains.dotMemory.Model.Inspections.ReachableObjectsService : object {
    private ISnapshot mySnapshot;
    private IEntityReference`1<IDirectGraph> myGraphReference;
    public ReachableObjectsService(ISnapshot snapshot, IEntityReference`1<IDirectGraph> graphReference);
    public sealed virtual IObjectIsReachableCollection MarkReachable(IEnumerable`1<ObjectNumber> markedObjects, IExecutionController controller);
}
[UsedImplicitlyAttribute]
public class JetBrains.dotMemory.Model.Inspections.SparseArrays.SparseArraysInspection : object {
    private static byte NotArray;
    private static byte Array;
    private IMetadataService myMetadataService;
    private IEntityReference`1<IObjectTypeCollection> myTypeCollection;
    private IDirectDetailedGraph myDetailedGraph;
    private IEntityReference`1<IDirectGraph> myDirectGraphReference;
    private ITypeSection myTypeSection;
    private IObjectArrayInfo myObjectArrayInfo;
    private IEntityReference`1<IObjectRootReferencesCollection> myRootCollectionReference;
    private IEntityReference`1<ITypeResolvingService> myTypeResolvingServiceReference;
    private IAllObjectsSetReference myAllObjectsSetReference;
    private IEnvironmentSection myEnvironmentSection;
    [CompilerGeneratedAttribute]
private static Func`2<GraphReference, bool> CS$<>9__CachedAnonymousMethodDelegate18;
    [CompilerGeneratedAttribute]
private static Func`2<IMetadataField, bool> CS$<>9__CachedAnonymousMethodDelegate1a;
    [CompilerGeneratedAttribute]
private static Func`3<int, ArrayDimensionInfo, int> CS$<>9__CachedAnonymousMethodDelegate1c;
    public SparseArraysInspection(IMetadataService metadataService, IEntityReference`1<IObjectTypeCollection> typeCollection, IDirectDetailedGraph detailedGraph, IEntityReference`1<IDirectGraph> directGraphReference, ITypeSection typeSection, IObjectArrayInfo objectArrayInfo, IEntityReference`1<IObjectRootReferencesCollection> rootCollectionReference, IEntityReference`1<ITypeResolvingService> typeResolvingServiceReference, IAllObjectsSetReference allObjectsSetReference, IEnvironmentSection environmentSection);
    public sealed virtual IEnumerable`1<SparseArrayIssue> FindIssues(IExecutionController controller);
    private static bool IsReferenceType(IMetadataType type);
    private int CountValueTypeArrayUsage(ObjectNumber array);
    private void GetValueTypeArrayInfo(SparseArrayIssue& sparseArrayIssue, ObjectNumber obj, IMetadataTypeInfo typeInfo);
    private void GetArrayInfo(SparseArrayIssue& sparseArrayIssue, ObjectNumber obj, DataKind kind, IMetadataTypeInfo typeInfo, IDirectGraph directGraph);
    private int GetArrayLength(ObjectNumber obj);
    [CompilerGeneratedAttribute]
private static bool <CountValueTypeArrayUsage>b__17(GraphReference r);
    [CompilerGeneratedAttribute]
private static bool <GetValueTypeArrayInfo>b__19(IMetadataField f);
    [CompilerGeneratedAttribute]
private static int <GetArrayLength>b__1b(int current, ArrayDimensionInfo info);
}
[UsedImplicitlyAttribute]
public class JetBrains.dotMemory.Model.Inspections.SparseArrays.SparseArraysInspectionDiskCache : object {
    private static string StorageKey;
    private static Version ourDataFormatVersion;
    private ISparseArraysInspection mySparseArraysInspection;
    private ISharedCacheDataStorage myDataStorage;
    [CompilerGeneratedAttribute]
private static Func`3<BinaryReader, IExecutionController, ChunkList`1<SparseArrayIssue>> CS$<>9__CachedAnonymousMethodDelegate2;
    public SparseArraysInspectionDiskCache(ISparseArraysInspection sparseArraysInspection, ISharedCacheDataStorage dataStorage);
    private static SparseArraysInspectionDiskCache();
    public sealed virtual IEnumerable`1<SparseArrayIssue> FindIssues(IExecutionController controller);
    private static void WriteData(ChunkList`1<SparseArrayIssue> issues, BinaryWriter writer, IExecutionController controller);
    private static IEnumerable`1<SparseArrayIssue> ReadData(BinaryReader reader, IExecutionController controller);
    [CompilerGeneratedAttribute]
private ChunkList`1<SparseArrayIssue> <FindIssues>b__0(IExecutionController creatingController);
    [CompilerGeneratedAttribute]
private static ChunkList`1<SparseArrayIssue> <FindIssues>b__1(BinaryReader reader, IExecutionController readingController);
}
[UsedImplicitlyAttribute]
public class JetBrains.dotMemory.Model.Inspections.Strings.DuplicatedStringsInspection : object {
    private ILogger myLogger;
    private static string ourStringTypeFullName;
    private IEntityReference`1<IFieldValuesProvider> myFieldValuesProviderReference;
    private IAllObjectsSetReference myObjectSetReference;
    private IEntityReference`1<IObjectTypeCollection> myObjectTypeCollectionReference;
    private IEntityReference`1<IObjectSizeCollection> myObjectSizeCollectionReference;
    private IEntityReference`1<ITypeResolvingService> myTypeResolvingServiceReference;
    [CompilerGeneratedAttribute]
private static Comparison`1<StringInfo> CS$<>9__CachedAnonymousMethodDelegate5;
    public DuplicatedStringsInspection(IAllObjectsSetReference objectSetReference, IEntityReference`1<IObjectTypeCollection> objectTypeCollectionReference, IEntityReference`1<IObjectSizeCollection> objectSizeCollectionReference, IEntityReference`1<ITypeResolvingService> typeResolvingServiceReference, IEntityReference`1<IFieldValuesProvider> fieldValuesProviderReference);
    private static DuplicatedStringsInspection();
    public sealed virtual IEnumerable`1<DuplicatedStringIssue> GetDuplicatedStrings(IExecutionController controller);
    private static string GetStringValue(ObjectNumber obj, IFieldValuesProvider fieldValuesProvider);
    [CompilerGeneratedAttribute]
private static int <GetDuplicatedStrings>b__3(StringInfo l, StringInfo r);
}
[UsedImplicitlyAttribute]
public class JetBrains.dotMemory.Model.Inspections.Strings.DuplicatedStringsInspectionDiscCache : object {
    private static string StorageKey;
    private static Version ourDataFormatVersion;
    private ISharedCacheDataStorage myDataStorage;
    private IDuplicatedStringsInspection myStringsInspection;
    [CompilerGeneratedAttribute]
private static Func`3<BinaryReader, IExecutionController, ChunkList`1<DuplicatedStringIssue>> CS$<>9__CachedAnonymousMethodDelegate2;
    public DuplicatedStringsInspectionDiscCache(IDuplicatedStringsInspection stringsInspection, ISharedCacheDataStorage dataStorage);
    private static DuplicatedStringsInspectionDiscCache();
    public sealed virtual IEnumerable`1<DuplicatedStringIssue> GetDuplicatedStrings(IExecutionController controller);
    private static void WriteData(ChunkList`1<DuplicatedStringIssue> issues, BinaryWriter writer, IExecutionController controller);
    private static IEnumerable`1<DuplicatedStringIssue> ReadData(BinaryReader reader, IExecutionController controller);
    [CompilerGeneratedAttribute]
private ChunkList`1<DuplicatedStringIssue> <GetDuplicatedStrings>b__0(IExecutionController creatingController);
    [CompilerGeneratedAttribute]
private static ChunkList`1<DuplicatedStringIssue> <GetDuplicatedStrings>b__1(BinaryReader reader, IExecutionController readingController);
}
[UsedImplicitlyAttribute]
public class JetBrains.dotMemory.Model.Inspections.WpfBinding.WpfBindingInspection : object {
    private static string ReflectPropertyDescriptorFullName;
    private static string WeakEventTableFullName;
    private static String[] ourPathFromWeakEventTableToPropertyDescriptors;
    private static String[] ourPathFromReflectPropertyDescriptorToLeakRoot;
    private IAllObjectsSetReference myAllObjectsSetReference;
    private IEntityReference`1<IFieldGraphNavigator> myFieldGraphNavigatorReference;
    private IEntityReference`1<IFieldValuesProvider> myFieldValuesProviderReference;
    private IEntityReference`1<IObjectTypeCollection> myTypeCollection;
    private IEntityReference`1<ITypeResolvingService> myTypeResolvingServiceReference;
    public WpfBindingInspection(IAllObjectsSetReference allObjectsSetReference, IEntityReference`1<IObjectTypeCollection> typeCollection, IEntityReference`1<ITypeResolvingService> typeResolvingServiceReference, IEntityReference`1<IFieldGraphNavigator> fieldGraphNavigatorReference, IEntityReference`1<IFieldValuesProvider> fieldValuesProviderReference);
    private static WpfBindingInspection();
    public sealed virtual IEnumerable`1<WpfBindingInfo> GetLeakRoots(IExecutionController controller);
    private static string GetStringValue(Byte[] array);
}
[UsedImplicitlyAttribute]
public class JetBrains.dotMemory.Model.Inspections.WpfBinding.WpfBindingInspectionDiskCache : object {
    private static string StorageKey;
    private static Version ourDataFormatVersion;
    private ISharedCacheDataStorage myDataStorage;
    private IWpfBindingInspection myWpfBindingInspection;
    [CompilerGeneratedAttribute]
private static Func`3<BinaryReader, IExecutionController, ChunkList`1<WpfBindingInfo>> CS$<>9__CachedAnonymousMethodDelegate2;
    public WpfBindingInspectionDiskCache(IWpfBindingInspection wpfBindingInspection, ISharedCacheDataStorage dataStorage);
    private static WpfBindingInspectionDiskCache();
    public sealed virtual IEnumerable`1<WpfBindingInfo> GetLeakRoots(IExecutionController controller);
    private static void WriteData(ChunkList`1<WpfBindingInfo> issues, BinaryWriter writer, IExecutionController controller);
    private static IEnumerable`1<WpfBindingInfo> ReadData(BinaryReader reader, IExecutionController controller);
    [CompilerGeneratedAttribute]
private ChunkList`1<WpfBindingInfo> <GetLeakRoots>b__0(IExecutionController creatingController);
    [CompilerGeneratedAttribute]
private static ChunkList`1<WpfBindingInfo> <GetLeakRoots>b__1(BinaryReader reader, IExecutionController readingController);
}
[UsedImplicitlyAttribute]
public class JetBrains.dotMemory.Model.Inspections.WpfCollectionBinding.WpfCollectionBindingInspection : object {
    private static string ViewManagerFullName;
    private String[] myPathToInactiveTable;
    private String[] myPathFromHibridToListDictionary;
    private String[] myPathFromHibridToListHead;
    private String[] myPathFromListNodeToListDictionary;
    private String[] myPathFromListDictionaryToHeadNode;
    private String[] myPathFromNodeToCollection;
    private String[] myPathToNextNode;
    private IAllObjectsSetReference myAllObjectsSetReference;
    private IEntityReference`1<IFieldGraphNavigator> myFieldGraphNavigatorReference;
    private IEntityReference`1<IObjectTypeCollection> myObjectTypeCollectionReference;
    private IReachableObjectsService myReachableObjectsService;
    private IEntityReference`1<ITypeResolvingService> myTypeResolvingServiceReference;
    [CompilerGeneratedAttribute]
private static Comparison`1<ObjectNumber> CS$<>9__CachedAnonymousMethodDelegate2;
    public WpfCollectionBindingInspection(IAllObjectsSetReference allObjectsSetReference, IEntityReference`1<ITypeResolvingService> typeResolvingServiceReference, IEntityReference`1<IFieldGraphNavigator> fieldGraphNavigatorReference, IEntityReference`1<IObjectTypeCollection> objectTypeCollectionReference, IReachableObjectsService reachableObjectsService);
    public sealed virtual IEnumerable`1<ObjectNumber> GetLeakRoots(IExecutionController controller);
    private IEnumerable`1<ObjectNumber> GetObjectsFromList(IEnumerable`1<ObjectNumber> inactiveTables, IFieldGraphNavigator fieldGraphNavigator);
    private IEnumerable`1<ObjectNumber> GetObjectsFromHashtable(IEnumerable`1<ObjectNumber> inactiveTables, IFieldGraphNavigator fieldGraphNavigator);
    private IEnumerable`1<ObjectNumber> GetObjectsFromListDictionary(IEnumerable`1<ObjectNumber> listDictionary, IFieldGraphNavigator fieldGraphNavigator);
    private static ChunkList`1<ObjectNumber> GetUnique(ChunkList`1<ObjectNumber> list);
    [CompilerGeneratedAttribute]
private static int <GetLeakRoots>b__1(ObjectNumber i1, ObjectNumber i2);
}
[UsedImplicitlyAttribute]
public class JetBrains.dotMemory.Model.Inspections.WpfCollectionBinding.WpfCollectionBindingInspectionDiskCache : object {
    private static string StorageKey;
    private static Version ourDataFormatVersion;
    private IDataStorage myDataStorage;
    private IWpfCollectionBindingInspection myWpfCollectionBindingInspection;
    [CompilerGeneratedAttribute]
private static Func`3<BinaryReader, IExecutionController, ChunkList`1<ObjectNumber>> CS$<>9__CachedAnonymousMethodDelegate2;
    public WpfCollectionBindingInspectionDiskCache(IWpfCollectionBindingInspection wpfCollectionBindingInspection, ISharedCacheDataStorage dataStorage);
    private static WpfCollectionBindingInspectionDiskCache();
    public sealed virtual IEnumerable`1<ObjectNumber> GetLeakRoots(IExecutionController controller);
    private static void WriteData(ChunkList`1<ObjectNumber> issues, BinaryWriter writer, IExecutionController controller);
    private static IEnumerable`1<ObjectNumber> ReadData(BinaryReader reader, IExecutionController controller);
    [CompilerGeneratedAttribute]
private ChunkList`1<ObjectNumber> <GetLeakRoots>b__0(IExecutionController creatingController);
    [CompilerGeneratedAttribute]
private static ChunkList`1<ObjectNumber> <GetLeakRoots>b__1(BinaryReader reader, IExecutionController readingController);
}
[UsedImplicitlyAttribute]
public class JetBrains.dotMemory.Model.Inspections.XNameWpf.XNameWpfInspection : object {
    private static string VisualTypeFullName;
    private static string NameScopeTypeFullName;
    private static string PathToLeak;
    private static string PathToNextNode;
    private static string PathToKey;
    private String[] myPathFromNameScopes;
    private String[] myPathToNameScopes;
    private IObjectSetReference myAllObjectsSetReference;
    private IEntityReference`1<IDominatorTreeParentCollection> myDominatorTreeParentsReference;
    private IEntityReference`1<IFieldGraphNavigator> myFieldGraphNavigatorReference;
    private IEntityReference`1<IFieldValuesProvider> myFieldValuesProviderReference;
    private IEntityReference`1<IObjectTypeCollection> myObjectTypeCollectionReference;
    private IReachableObjectsService myReachableObjectsService;
    private IEntityReference`1<ITypeResolvingService> myTypeResolvingServiceReference;
    private IEntityReference`1<ITypeSection> myTypeSectionReference;
    private Dictionary`2<TypeId, bool> myInheritVisualCache;
    private Dictionary`2<ObjectNumber, bool> myMarkedDominatorsCache;
    [CompilerGeneratedAttribute]
private static Comparison`1<XNameInfo> CS$<>9__CachedAnonymousMethodDelegate4;
    public XNameWpfInspection(IAllObjectsSetReference allObjectsSetReference, IEntityReference`1<IObjectTypeCollection> objectTypeCollectionReference, IEntityReference`1<ITypeResolvingService> typeResolvingServiceReference, IEntityReference`1<IFieldGraphNavigator> fieldGraphNavigatorReference, IEntityReference`1<IFieldValuesProvider> fieldValuesProviderReference, IReachableObjectsService reachableObjectsService, IEntityReference`1<ITypeSection> typeSectionReference, IEntityReference`1<IDominatorTreeParentCollection> dominatorTreeParentsReference);
    public sealed virtual IEnumerable`1<XNameInfo> GetLeakRoots(IExecutionController controller);
    private bool IsInheritVisualType(TypeId targetType, TypeId visualType, ITypeSection typeSection);
    private IEnumerable`1<XNameInfo> GetOnlyLastDominators(IList`1<XNameInfo> leaks, IDominatorTreeParentCollection dominatorTreeParents);
    private bool MarkAllOnTheWay(ObjectNumber vertex, IDominatorTreeParentCollection dominatorTreeParents);
    private static string GetStringValue(Byte[] array);
    private static ChunkList`1<XNameInfo> Unique(ChunkList`1<XNameInfo> array);
    [CompilerGeneratedAttribute]
private static int <GetLeakRoots>b__2(XNameInfo i1, XNameInfo i2);
}
[UsedImplicitlyAttribute]
public class JetBrains.dotMemory.Model.Inspections.XNameWpf.XNameWpfInspectionDiskCache : object {
    private static string StorageKey;
    private static Version ourDataFormatVersion;
    private ISharedCacheDataStorage myDataStorage;
    private IXNameWpfInspection myXNameWpfInspection;
    [CompilerGeneratedAttribute]
private static Func`3<BinaryReader, IExecutionController, ChunkList`1<XNameInfo>> CS$<>9__CachedAnonymousMethodDelegate2;
    public XNameWpfInspectionDiskCache(IXNameWpfInspection xNameWpfInspection, ISharedCacheDataStorage dataStorage);
    private static XNameWpfInspectionDiskCache();
    public sealed virtual IEnumerable`1<XNameInfo> GetLeakRoots(IExecutionController controller);
    private static void WriteData(ChunkList`1<XNameInfo> issues, BinaryWriter writer, IExecutionController controller);
    private static IEnumerable`1<XNameInfo> ReadData(BinaryReader reader, IExecutionController controller);
    [CompilerGeneratedAttribute]
private ChunkList`1<XNameInfo> <GetLeakRoots>b__0(IExecutionController creatingController);
    [CompilerGeneratedAttribute]
private static ChunkList`1<XNameInfo> <GetLeakRoots>b__1(BinaryReader reader, IExecutionController readingController);
}
public interface JetBrains.dotMemory.Model.ITypeResolvingService {
    public abstract virtual TypeId GetTypeId(string typeName);
}
public class JetBrains.dotMemory.Model.MemoryCache`1 : object {
    private string DebugId;
    private static string ourOperationName;
    private ILogger myLogger;
    private object myAccess;
    private Func`2<IExecutionController, T> myLoader;
    private TimeSpan myHoldInMemoryPeriod;
    private Lifetime myLifetime;
    private LifetimeDefinition myReleaseStrongReferenceActionLifetime;
    private WeakReference myEntityWeakReference;
    private HardReference<T> myHardReference;
    private int myReferencesCount;
    public MemoryCache`1(Lifetime lifetime, TimeSpan holdInMemoryPeriod, Func`2<IExecutionController, T> loader);
    private static MemoryCache`1();
    public sealed virtual T GetEntity(IExecutionController executionController, Lifetime lifetime);
    private void AddRef();
    private void Release();
    [CompilerGeneratedAttribute]
private void <.ctor>b__1();
    [CompilerGeneratedAttribute]
private void <Release>b__7();
}
[UsedImplicitlyAttribute]
public class JetBrains.dotMemory.Model.MergedDominatorTreeBuilder : object {
    private ISnapshot mySnapshot;
    private IEntityReference`1<IDominatorTreeTopdownGraph> myDominatorTreeTopdownGraphReferece;
    private IEntityReference`1<IDominatorTreeParentCollection> myDominatorsReference;
    private IEntityReference`1<IObjectTypeCollection> myTypesReference;
    private IEntityReference`1<IObjectSizeCollection> mySizesReference;
    private IEntityReference`1<IObjectRetainedSizeCollection> myRetainedSizesReference;
    private ITypeService myTypeService;
    [CompilerGeneratedAttribute]
private static Func`3<ulong, IMergedDominatorTreeNode, ulong> CS$<>9__CachedAnonymousMethodDelegate1;
    [CompilerGeneratedAttribute]
private static Comparison`1<MergedDominatorTreeNode> CS$<>9__CachedAnonymousMethodDelegate4;
    public MergedDominatorTreeBuilder(ISnapshot snapshot, IEntityReference`1<IDominatorTreeTopdownGraph> dominatorTreeTopdownGraphReferece, IEntityReference`1<IDominatorTreeParentCollection> dominatorsReference, IEntityReference`1<IObjectTypeCollection> typesReference, IEntityReference`1<IObjectSizeCollection> sizesReference, IEntityReference`1<IObjectRetainedSizeCollection> retainedSizesReference, ITypeService typeService);
    public sealed virtual IMergedDominatorTreeNode Build(IExecutionController executionController);
    public sealed virtual IMergedDominatorTreeNode BuildTop(int topTypeCount, int maxLevelsCount, IExecutionController executionController);
    private IEnumerable`1<ObjectNumber> GetChildren(MergedDominatorTreeNode multiNode, IDominatorTreeParentCollection dominators, IDominatorTreeTopdownGraph domintorsGraph, IExecutionController executionController);
    [CompilerGeneratedAttribute]
private static ulong <Build>b__0(ulong current, IMergedDominatorTreeNode node);
    [CompilerGeneratedAttribute]
private static int <BuildTop>b__3(MergedDominatorTreeNode node1, MergedDominatorTreeNode node2);
}
[UsedImplicitlyAttribute]
public class JetBrains.dotMemory.Model.Metadata.MetadataService : object {
    private ITypeSection myTypeSection;
    private IFieldNamesCollection myFieldNamesCollection;
    private IMetadataSectionAssemblyProvider myMetadataAssemblyProvider;
    private IModuleInformationProvider myModuleInformationProvider;
    private object myMetadataAccess;
    public MetadataService(ITypeSection typeSection, IFieldNamesCollection fieldNamesCollection, IMetadataSectionAssemblyProvider metadataAssemblyProvider, IModuleInformationProvider moduleInformationProvider);
    public sealed virtual IMetadataAssembly GetAssemblyFrom(TypeId typeId);
    public sealed virtual IMetadataAssembly GetAssemblyFrom(MetadataId mid);
    [NotNullAttribute]
public sealed virtual IModuleInformation GetModuleFrom(TypeId typeId);
    public sealed virtual IMetadataTypeInfo GetMetadataTypeInfo(TypeId typeId);
    public sealed virtual IMetadataMethod Get(MethodId methodId);
    [CanBeNullAttribute]
public sealed virtual IMetadataTypeInfo Get(SectionPointer`1<IFieldNamesCollection> fieldId);
    public sealed virtual bool IsArray(TypeId typeId);
    public sealed virtual bool IsArray(SectionPointer`1<IFieldNamesCollection> fieldId);
    private IMetadataType GetFieldType(SectionPointer`1<IFieldNamesCollection> fieldId);
    [CanBeNullAttribute]
public sealed virtual string GetFieldName(SectionPointer`1<IFieldNamesCollection> fieldId);
    public sealed virtual string GetFieldDeclaredType(SectionPointer`1<IFieldNamesCollection> fieldId);
    public sealed virtual string GetTypeResolvedFullName(IMetadataTypeInfo typeInfo);
    [ObsoleteAttribute]
public sealed virtual string GetMethodSignature(IMetadataMethod metadataMethod, String& namespace);
    public sealed virtual DataKind GetDataKind(TypeId typeId);
    public sealed virtual DataKind GetDataKind(IMetadataTypeInfo typeInfo);
    private string GetClassName(IMetadataType metadataType);
    [CanBeNullAttribute]
private IMetadataTypeInfo GetTypeInfoFromType(IMetadataType metadataType);
    private static string GetClassName(IMetadataTypeInfo typeInfo, String& namespace);
    private static string GetGenericParametersString(IMetadataGenericArgument[] arguments);
    [NotNullAttribute]
private static string GetShortCleanedName(string name);
}
public class JetBrains.dotMemory.Model.Metadata.ModuleInformation : object {
    private static ModuleInformation ourUnknownModule;
    [CompilerGeneratedAttribute]
private string <ModuleName>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <Mvid>k__BackingField;
    public string ModuleName { get; private set; }
    public Guid Mvid { get; private set; }
    public static ModuleInformation UnknownModule { get; }
    public ModuleInformation(string moduleName, Guid mvid);
    private static ModuleInformation();
    [CompilerGeneratedAttribute]
public sealed virtual string get_ModuleName();
    [CompilerGeneratedAttribute]
private void set_ModuleName(string value);
    [CompilerGeneratedAttribute]
public sealed virtual Guid get_Mvid();
    [CompilerGeneratedAttribute]
private void set_Mvid(Guid value);
    public static ModuleInformation get_UnknownModule();
}
[UsedImplicitlyAttribute]
[DefaultMemberAttribute("Item")]
public class JetBrains.dotMemory.Model.Metadata.ModuleInformationProvider : object {
    private Dictionary`2<SectionIndex`1<IMetadataSection>, IModuleInformation> myModules;
    [CompilerGeneratedAttribute]
private static Func`2<KeyValuePair`2<SectionIndex`1<IMetadataSection>, IModuleInfo>, SectionIndex`1<IMetadataSection>> CS$<>9__CachedAnonymousMethodDelegate2;
    [CompilerGeneratedAttribute]
private static Func`2<KeyValuePair`2<SectionIndex`1<IMetadataSection>, IModuleInfo>, IModuleInformation> CS$<>9__CachedAnonymousMethodDelegate3;
    public IModuleInformation Item { get; }
    public ModuleInformationProvider(IEnumerable`1<KeyValuePair`2<SectionIndex`1<IMetadataSection>, IModuleInfo>> modules);
    public sealed virtual IModuleInformation get_Item(SectionIndex`1<IMetadataSection> index);
    [CompilerGeneratedAttribute]
private static SectionIndex`1<IMetadataSection> <.ctor>b__0(KeyValuePair`2<SectionIndex`1<IMetadataSection>, IModuleInfo> kvp);
    [CompilerGeneratedAttribute]
private static IModuleInformation <.ctor>b__1(KeyValuePair`2<SectionIndex`1<IMetadataSection>, IModuleInfo> kvp);
}
public class JetBrains.dotMemory.Model.Metadata.SpecialMetadataMethods : object {
    public static SpecialMetadataMethods NativeCallMethod;
    public static SpecialMetadataMethods UnmanagedCallMethod;
    public static SpecialMetadataMethods UnsafeCallMethod;
    public static IMetadataMethod RootMethod;
    private MetadataToken myToken;
    private string myName;
    private bool myIsUnmanaged;
    private bool myAggressiveInlining;
    public IMetadataSecurityRow[] Security { get; }
    public String[] SecurityAttributesTypeName { get; }
    public bool HasSecurity { get; }
    public IMetadataAssembly Assembly { get; }
    public MetadataToken Token { get; }
    public IMetadataCustomAttribute[] CustomAttributes { get; }
    public MetadataTypeReference[] CustomAttributesTypeNames { get; }
    public bool IsResolved { get; }
    public string Name { get; }
    public IMetadataTypeInfo DeclaringType { get; }
    public bool IsSpecialName { get; }
    public bool IsRuntimeSpecialName { get; }
    public IMetadataReturnValue ReturnValue { get; }
    public IMetadataParameter[] Parameters { get; }
    public IMetadataGenericArgument[] GenericArguments { get; }
    public IList`1<MethodSpecification> ImplementedMethods { get; }
    public MethodSignature Signature { get; }
    public PInvokeInfo PInvokeInfo { get; }
    public CorMethodImpl MethodImplFlags { get; }
    public bool IsPInvokeImpl { get; }
    public CodeType CodeType { get; }
    public UInt32 CodeRva { get; }
    public bool IsForwardRef { get; }
    public bool IsPreserveSig { get; }
    public bool IsInternalCall { get; }
    public bool IsSynchronized { get; }
    public bool NoInlining { get; }
    public bool AggressiveInlining { get; }
    public bool NoOptimization { get; }
    public bool IsAssembly { get; }
    public bool IsPrivate { get; }
    public bool IsPublic { get; }
    public bool IsFamily { get; }
    public bool IsFamilyAndAssembly { get; }
    public bool IsFamilyOrAssembly { get; }
    public bool IsStatic { get; }
    public bool IsAbstract { get; }
    public bool IsExtern { get; }
    public bool IsVirtual { get; }
    public bool IsFinal { get; }
    public bool IsHideBySig { get; }
    public bool IsNewSlot { get; }
    public bool IsStrict { get; }
    public bool IsVarArg { get; }
    public bool IsUnmanaged { get; }
    private SpecialMetadataMethods(MetadataToken token, string name, bool isUnmanaged);
    private static SpecialMetadataMethods();
    public sealed virtual IMetadataSecurityRow[] get_Security();
    public sealed virtual String[] get_SecurityAttributesTypeName();
    public sealed virtual bool get_HasSecurity();
    public sealed virtual bool Equals(IMetadataEntity other);
    public sealed virtual IMetadataAssembly get_Assembly();
    public sealed virtual MetadataToken get_Token();
    public sealed virtual IMetadataCustomAttribute[] get_CustomAttributes();
    public sealed virtual MetadataTypeReference[] get_CustomAttributesTypeNames();
    public sealed virtual IList`1<IMetadataCustomAttribute> GetCustomAttributes(string attributeClassFullyQualifiedName);
    public sealed virtual bool HasCustomAttribute(string attributeClassFullyQualifiedName);
    public sealed virtual bool get_IsResolved();
    public sealed virtual string get_Name();
    public sealed virtual IMetadataTypeInfo get_DeclaringType();
    public sealed virtual bool get_IsSpecialName();
    public sealed virtual bool get_IsRuntimeSpecialName();
    public sealed virtual IMetadataReturnValue get_ReturnValue();
    public sealed virtual IMetadataParameter[] get_Parameters();
    public sealed virtual IMetadataGenericArgument[] get_GenericArguments();
    public sealed virtual IList`1<MethodSpecification> get_ImplementedMethods();
    public sealed virtual MethodSignature get_Signature();
    public sealed virtual PInvokeInfo get_PInvokeInfo();
    public sealed virtual CorMethodImpl get_MethodImplFlags();
    public sealed virtual bool get_IsPInvokeImpl();
    public sealed virtual CodeType get_CodeType();
    public sealed virtual UInt32 get_CodeRva();
    public sealed virtual bool get_IsForwardRef();
    public sealed virtual bool get_IsPreserveSig();
    public sealed virtual bool get_IsInternalCall();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual bool get_NoInlining();
    public sealed virtual bool get_AggressiveInlining();
    public sealed virtual bool get_NoOptimization();
    public sealed virtual bool get_IsAssembly();
    public sealed virtual bool get_IsPrivate();
    public sealed virtual bool get_IsPublic();
    public sealed virtual bool get_IsFamily();
    public sealed virtual bool get_IsFamilyAndAssembly();
    public sealed virtual bool get_IsFamilyOrAssembly();
    public sealed virtual bool get_IsStatic();
    public sealed virtual bool get_IsAbstract();
    public sealed virtual bool get_IsExtern();
    public sealed virtual bool get_IsVirtual();
    public sealed virtual bool get_IsFinal();
    public sealed virtual bool get_IsHideBySig();
    public sealed virtual bool get_IsNewSlot();
    public sealed virtual bool get_IsStrict();
    public sealed virtual bool get_IsVarArg();
    public sealed virtual bool get_IsUnmanaged();
}
internal class JetBrains.dotMemory.Model.Metadata.UnknownAssembly : object {
    public IMetadataAssembly Assembly { get; }
    public MetadataToken Token { get; }
    public IMetadataCustomAttribute[] CustomAttributes { get; }
    public MetadataTypeReference[] CustomAttributesTypeNames { get; }
    private IEnumerable`1<AssemblyNameInfo> JetBrains.Metadata.Reader.API.IMetadataAssembly.ReferencedAssembliesNames { get; }
    public IMetadataCustomAttribute[] ModuleAttributes { get; }
    public bool IsResolved { get; }
    public IMetadataSecurityRow[] Security { get; }
    public String[] SecurityAttributesTypeName { get; }
    public bool HasSecurity { get; }
    public IMetadataAccess MetadataAccess { get; }
    public AssemblyNameInfo AssemblyName { get; }
    public Guid Mvid { get; }
    public AssemblyNameInfo[] ReferencedAssembliesNames { get; }
    public FileSystemPath Location { get; }
    public IMetadataAssemblyInternals Internals { get; }
    public sealed virtual bool Equals(IMetadataEntity other);
    public sealed virtual IMetadataAssembly get_Assembly();
    public sealed virtual MetadataToken get_Token();
    public sealed virtual IMetadataCustomAttribute[] get_CustomAttributes();
    public sealed virtual MetadataTypeReference[] get_CustomAttributesTypeNames();
    public sealed virtual IMetadataTypeInfo GetTypeInfoFromQualifiedName(string name, AssemblyNameInfo assemblyName, bool searchReferencedAssemblies);
    private sealed virtual override IEnumerable`1<AssemblyNameInfo> JetBrains.Metadata.Reader.API.IMetadataAssembly.get_ReferencedAssembliesNames();
    public sealed virtual IMetadataCustomAttribute[] get_ModuleAttributes();
    public sealed virtual IList`1<IMetadataCustomAttribute> GetCustomAttributes(string attributeClassFullyQualifiedName);
    public sealed virtual bool HasCustomAttribute(string attributeClassFullyQualifiedName);
    public sealed virtual bool get_IsResolved();
    public sealed virtual IMetadataSecurityRow[] get_Security();
    public sealed virtual String[] get_SecurityAttributesTypeName();
    public sealed virtual bool get_HasSecurity();
    public IMetadataTypeInfo GetTypeInfoFromQualifiedName(string name, string assemblyName, bool searchReferencedAssemblies);
    public sealed virtual IMetadataAccess get_MetadataAccess();
    public sealed virtual AssemblyNameInfo get_AssemblyName();
    public sealed virtual Guid get_Mvid();
    public AssemblyNameInfo[] get_ReferencedAssembliesNames();
    public sealed virtual FileSystemPath get_Location();
    public sealed virtual IMetadataTypeInfo GetTypeInfoFromQualifiedName(string qualifiedName, bool searchReferencedAssemblies);
    public sealed virtual IMetadataTypeInfo GetTypeInfoFromToken(MetadataToken token);
    public sealed virtual IMetadataType GetTypeFromQualifiedName(string qualifiedName, bool searchReferencedAssemblies);
    public sealed virtual IMetadataTypeInfo[] GetTypes();
    public sealed virtual IMetadataTypeInfo[] GetExportedTypes();
    public sealed virtual IDictionary`2<string, AssemblyNameInfo> GetForwardedTypes();
    public sealed virtual IMetadataManifestResource[] GetManifestResources();
    public sealed virtual IImageBodyReader CreateImageBodyReader();
    public sealed virtual IMethodBodyUsagesFinder CreateUsagesFinder();
    public sealed virtual IMetadataAssemblyInternals get_Internals();
}
internal class JetBrains.dotMemory.Model.Metadata.UnresolvedTypeMetadataTypeInfo : object {
    private string myName;
    public MetadataTypeReference[] CustomAttributesTypeNames { get; }
    public string TypeName { get; }
    public bool IsWindowsRuntime { get; }
    public IMetadataSecurityRow[] Security { get; }
    public String[] SecurityAttributesTypeName { get; }
    public bool HasSecurity { get; }
    public IMetadataAssembly Assembly { get; }
    public MetadataToken Token { get; }
    public IMetadataCustomAttribute[] CustomAttributes { get; }
    public bool IsResolved { get; }
    public string Name { get; }
    public IMetadataTypeInfo DeclaringType { get; }
    public bool IsSpecialName { get; }
    public bool IsRuntimeSpecialName { get; }
    public string FullyQualifiedName { get; }
    public string AssemblyQualifiedName { get; }
    public string NamespaceName { get; }
    public AssemblyNameInfo DeclaringAssemblyName { get; }
    public IMetadataClassType Base { get; }
    public IMetadataClassType[] Interfaces { get; }
    public IMetadataGenericArgument[] GenericParameters { get; }
    public bool IsAbstract { get; }
    public bool IsSealed { get; }
    public bool IsImported { get; }
    public ClassLayoutType Layout { get; }
    public CharSetSpec InteropStringFormat { get; }
    public bool IsBeforeFieldInit { get; }
    public bool IsClass { get; }
    public bool IsInterface { get; }
    public bool IsSerializable { get; }
    public bool IsPublic { get; }
    public bool IsNotPublic { get; }
    public bool IsNested { get; }
    public bool IsNestedPublic { get; }
    public bool IsNestedPrivate { get; }
    public bool IsNestedFamily { get; }
    public bool IsNestedAssembly { get; }
    public bool IsNestedFamilyAndAssembly { get; }
    public bool IsNestedFamilyOrAssembly { get; }
    public int PackingSize { get; }
    public int ClassSize { get; }
    public UnresolvedTypeMetadataTypeInfo(string name);
    public sealed virtual bool HasExtensionMethods();
    public sealed virtual MetadataTypeReference[] get_CustomAttributesTypeNames();
    public sealed virtual string get_TypeName();
    public sealed virtual bool get_IsWindowsRuntime();
    public sealed virtual IMetadataSecurityRow[] get_Security();
    public sealed virtual String[] get_SecurityAttributesTypeName();
    public sealed virtual bool get_HasSecurity();
    public sealed virtual bool Equals(IMetadataEntity other);
    public sealed virtual IMetadataAssembly get_Assembly();
    public sealed virtual MetadataToken get_Token();
    public sealed virtual IMetadataCustomAttribute[] get_CustomAttributes();
    public sealed virtual IList`1<IMetadataCustomAttribute> GetCustomAttributes(string attributeClassFullyQualifiedName);
    public sealed virtual bool HasCustomAttribute(string attributeClassFullyQualifiedName);
    public sealed virtual bool get_IsResolved();
    public sealed virtual string get_Name();
    public sealed virtual IMetadataTypeInfo get_DeclaringType();
    public sealed virtual bool get_IsSpecialName();
    public sealed virtual bool get_IsRuntimeSpecialName();
    public sealed virtual string get_FullyQualifiedName();
    public sealed virtual string get_AssemblyQualifiedName();
    public sealed virtual string get_NamespaceName();
    public sealed virtual AssemblyNameInfo get_DeclaringAssemblyName();
    public sealed virtual IMetadataClassType get_Base();
    public sealed virtual IMetadataClassType[] get_Interfaces();
    public sealed virtual IMetadataGenericArgument[] get_GenericParameters();
    public sealed virtual bool get_IsAbstract();
    public sealed virtual bool get_IsSealed();
    public sealed virtual bool get_IsImported();
    public sealed virtual ClassLayoutType get_Layout();
    public sealed virtual CharSetSpec get_InteropStringFormat();
    public sealed virtual bool get_IsBeforeFieldInit();
    public sealed virtual bool get_IsClass();
    public sealed virtual bool get_IsInterface();
    public sealed virtual bool get_IsSerializable();
    public sealed virtual bool get_IsPublic();
    public sealed virtual bool get_IsNotPublic();
    public sealed virtual bool get_IsNested();
    public sealed virtual bool get_IsNestedPublic();
    public sealed virtual bool get_IsNestedPrivate();
    public sealed virtual bool get_IsNestedFamily();
    public sealed virtual bool get_IsNestedAssembly();
    public sealed virtual bool get_IsNestedFamilyAndAssembly();
    public sealed virtual bool get_IsNestedFamilyOrAssembly();
    public sealed virtual int get_PackingSize();
    public sealed virtual int get_ClassSize();
    public sealed virtual IEnumerable`1<MemberInfo> GetMemberInfos();
    public sealed virtual IMetadataMethod[] GetMethods();
    public sealed virtual IMetadataField[] GetFields();
    public sealed virtual IMetadataProperty[] GetProperties();
    public sealed virtual IMetadataEvent[] GetEvents();
    public sealed virtual IMetadataTypeInfo[] GetNestedTypes();
}
[UsedImplicitlyAttribute]
public class JetBrains.dotMemory.Model.ObjectArrayInfo : object {
    private AdjacencyListEx`1<ArrayDimensionInfo> myAdjacencyList;
    public ObjectArrayInfo(IObjectArrayInfoIndex objectArrayInfoIndex, IObjectArrayDimensions objectArrayDimensions);
    public sealed virtual UInt32 GetArrayRank(ObjectNumber objectNumber);
    [NotNullAttribute]
public sealed virtual IReadOnlyList`1<ArrayDimensionInfo> GetArrayInfo(ObjectNumber objectNumber);
}
[UsedImplicitlyAttribute]
public class JetBrains.dotMemory.Model.ObjectByTypeAggregator : object {
    private IEntityReference`1<IObjectTypeCollection> myObjectTypesReferense;
    private IEntityReference`1<IObjectSizeCollection> myObjectSizesReference;
    [CompilerGeneratedAttribute]
private static Func`2<KeyValuePair`2<TypeId, InternalAggregate>, TypeStatistics> CS$<>9__CachedAnonymousMethodDelegate1;
    public ObjectByTypeAggregator(IEntityReference`1<IObjectTypeCollection> objectTypesReferense, IEntityReference`1<IObjectSizeCollection> objectSizesReference);
    public sealed virtual TypeAggregate Aggregate(IObjectSetReference objectSetReference, IExecutionController executionController);
    [CompilerGeneratedAttribute]
private static TypeStatistics <Aggregate>b__0(KeyValuePair`2<TypeId, InternalAggregate> pair);
}
[UsedImplicitlyAttribute]
public class JetBrains.dotMemory.Model.Objects.PathToRootsExplorer : object {
    private IEntityReference`1<IReverseGraph> myReverseGraphReference;
    private IEntityReference`1<IDirectGraph> myDirectGraphReference;
    private IEntityReference`1<IGraphRootTargetsCollection> myRootsReference;
    public PathToRootsExplorer(IEntityReference`1<IReverseGraph> reverseGraphReference, IEntityReference`1<IDirectGraph> directGraphReference, IEntityReference`1<IGraphRootTargetsCollection> rootsReference);
    public sealed virtual IEnumerable`1<PathInfo> GetDirectShortestSetToSetPaths(IList`1<ObjectNumber> fromSet, IList`1<ObjectNumber> toSet, IExecutionController executionController);
    private static IEnumerable`1<PathInfo> GetShortestSetToSetPaths(IEnumerable`1<ObjectNumber> fromSet, ICollection`1<ObjectNumber> toSet, IGraph forwardReferenceProvider, IExecutionController executionController);
    private static PathInfo CalculateDfsShortestPath(ChunkArray`1<PathNode> objectToMinDistanceArcMap, ObjectNumber toObjectNumber);
    private static ChunkArray`1<PathNode> CalculateObjectToMinDistanceArcMap(IEnumerable`1<ObjectNumber> fromSet, IGraph forwardReferenceProvider);
    public sealed virtual IEnumerable`1<PathInfo> GetAllShortestPathsFromRoots(ObjectNumber objectNumber, IExecutionController executionController);
    private static IEnumerable`1<PathInfo> CalculatePathsToRoots(ObjectNumber objectNumber, IExecutionController executionController, PathToRootsFindResult findResult);
    private static PathToRootsFindResult FindPathsToRoots(ObjectNumber objectNumber, IReverseGraph graph, IEnumerable`1<ObjectNumber> roots, IExecutionController executionController);
}
public class JetBrains.dotMemory.Model.ObjectSetMemoryCache : MemoryCache`1<IObjectSet> {
    private ObjectSetId myId;
    public ObjectSetId Id { get; }
    public ObjectSetMemoryCache(Lifetime lifetime, ObjectSetId id, TimeSpan holdInMemoryPeriod, Func`2<IExecutionController, IEnumerable`1<ObjectNumber>> getObjects);
    private static IObjectSet CreateObjectSet(Func`2<IExecutionController, IEnumerable`1<ObjectNumber>> getObjects, IExecutionController executionController);
    public sealed virtual ObjectSetId get_Id();
}
[UsedImplicitlyAttribute]
public class JetBrains.dotMemory.Model.ObjectSetReferenceFactory : object {
    private TimeSpan myHoldInMemoryPeriod;
    public ObjectSetReferenceFactory(TimeSpan holdInMemoryPeriod);
    [NotNullAttribute]
public sealed virtual IObjectSetReference Create(Lifetime lifetime, IObjectSetReference superSetReference, IObjectSetGenerator objectSetGenerator);
    [NotNullAttribute]
public sealed virtual IObjectSetReference Create(Lifetime lifetime, ObjectSetId id, IObjectSetReference superSetReference, IObjectSetGenerator objectSetGenerator);
}
public class JetBrains.dotMemory.Model.ObjectSetReferenceStub : object {
    private IObjectSet myObjectSet;
    [CompilerGeneratedAttribute]
private ObjectSetId <Id>k__BackingField;
    public ObjectSetId Id { get; private set; }
    public ObjectSetReferenceStub(IObjectSet objectSet);
    public ObjectSetReferenceStub(IReadOnlyCollection`1<ObjectNumber> objects);
    public sealed virtual IObjectSet GetEntity(IExecutionController executionController, Lifetime lifetime);
    [CompilerGeneratedAttribute]
public sealed virtual ObjectSetId get_Id();
    [CompilerGeneratedAttribute]
private void set_Id(ObjectSetId value);
}
[UsedImplicitlyAttribute]
public class JetBrains.dotMemory.Model.ObjectSets.DependencyPropertyLeakObjectSetGenerator : ObjectSetGeneratorMixin`1<DependencyPropertyLeakObjectSetGenerator> {
    private IDependencyPropertyLeakInspection myDependencyPropertyLeakInspection;
    [CompilerGeneratedAttribute]
private static Func`2<RetainedObjectAndDependencyPropertyNames, ObjectNumber> CS$<>9__CachedAnonymousMethodDelegate1;
    public DependencyPropertyLeakObjectSetGenerator(IDependencyPropertyLeakInspection dependencyPropertyLeakInspection, SnapshotId snapshotId);
    public sealed virtual IPersistentFactory`1<IObjectSetGenerator> GetPersistentFactory();
    protected virtual bool EqualsTo(DependencyPropertyLeakObjectSetGenerator other);
    public sealed virtual IEnumerable`1<ObjectNumber> GetObjectSet(IObjectSetReference superSetReference, IExecutionController executionController);
    [CompilerGeneratedAttribute]
private static ObjectNumber <GetObjectSet>b__0(RetainedObjectAndDependencyPropertyNames _);
}
[UsedImplicitlyAttribute]
public class JetBrains.dotMemory.Model.ObjectSets.DuplicatedStringObjectSetGenerator : ObjectSetGeneratorMixin`1<DuplicatedStringObjectSetGenerator> {
    private IDuplicatedStringsInspection myStringsInspection;
    private string myValue;
    public DuplicatedStringObjectSetGenerator(string value, IDuplicatedStringsInspection stringsInspection, SnapshotId snapshotId);
    public sealed virtual IPersistentFactory`1<IObjectSetGenerator> GetPersistentFactory();
    public sealed virtual IEnumerable`1<ObjectNumber> GetObjectSet(IObjectSetReference superSetReference, IExecutionController executionController);
    protected virtual bool EqualsTo(DuplicatedStringObjectSetGenerator other);
}
[UsedImplicitlyAttribute]
public class JetBrains.dotMemory.Model.ObjectSets.EventHandlerLeakObjectSetGenerator : ObjectSetGeneratorMixin`1<EventHandlerLeakObjectSetGenerator> {
    private IEventHandlersInspection myEventHandlersInspection;
    public EventHandlerLeakObjectSetGenerator(IEventHandlersInspection eventHandlersInspection, SnapshotId snapshotId);
    public sealed virtual IPersistentFactory`1<IObjectSetGenerator> GetPersistentFactory();
    protected virtual bool EqualsTo(EventHandlerLeakObjectSetGenerator other);
    public sealed virtual IEnumerable`1<ObjectNumber> GetObjectSet(IObjectSetReference superSetReference, IExecutionController executionController);
}
[UsedImplicitlyAttribute]
public class JetBrains.dotMemory.Model.ObjectSets.ObjectSetCountSizeStatsCalculator : object {
    private IObjectSetReference myObjectSetReference;
    private IEntityReference`1<IObjectSizeCollection> myObjectSizeCollectionReference;
    public ObjectSetCountSizeStatsCalculator(IObjectSetReference objectSetReference, IEntityReference`1<IObjectSizeCollection> objectSizeCollectionReference);
    public sealed virtual CountSizeStats Calculate(IExecutionController executionController);
}
public class JetBrains.dotMemory.Model.ObjectSets.ObjectSetCountSizeStatsDiskCache : object {
    private static string DataName;
    private static Version FormatVersion;
    private IProbingScopeCacheDataStorage myStorage;
    private IObjectSetCountSizeStatsCalculator myRuntimeCalculator;
    [CompilerGeneratedAttribute]
private static Action`3<CountSizeStats, BinaryWriter, IExecutionController> CS$<>9__CachedAnonymousMethodDelegate3;
    [CompilerGeneratedAttribute]
private static Func`3<BinaryReader, IExecutionController, CountSizeStats> CS$<>9__CachedAnonymousMethodDelegate4;
    public ObjectSetCountSizeStatsDiskCache(IProbingScopeCacheDataStorage storage, IObjectSetCountSizeStatsCalculator runtimeCalculator);
    private static ObjectSetCountSizeStatsDiskCache();
    public sealed virtual CountSizeStats Calculate(IExecutionController executionController);
    [CompilerGeneratedAttribute]
private CountSizeStats <Calculate>b__0(IExecutionController controller);
    [CompilerGeneratedAttribute]
private static void <Calculate>b__1(CountSizeStats stats, BinaryWriter writer, IExecutionController _);
    [CompilerGeneratedAttribute]
private static CountSizeStats <Calculate>b__2(BinaryReader reader, IExecutionController _);
}
[UsedImplicitlyAttribute]
public class JetBrains.dotMemory.Model.ObjectSets.SimilarRetentionClusterObjectSetGenerator : ObjectSetGeneratorMixin`1<SimilarRetentionClusterObjectSetGenerator> {
    private UInt32 myClusterHash;
    private ISnapshotScope mySnapshotScope;
    public SimilarRetentionClusterObjectSetGenerator(UInt32 clusterHash, ISnapshotScope snapshotScope, SnapshotId snapshotId);
    public sealed virtual IEnumerable`1<ObjectNumber> GetObjectSet(IObjectSetReference superSetReference, IExecutionController executionController);
    protected virtual bool EqualsTo(SimilarRetentionClusterObjectSetGenerator other);
    public sealed virtual IPersistentFactory`1<IObjectSetGenerator> GetPersistentFactory();
}
[UsedImplicitlyAttribute]
public class JetBrains.dotMemory.Model.ObjectSets.SimilarRetentionPathNodeObjectSetGenerator : ObjectSetGeneratorMixin`1<SimilarRetentionPathNodeObjectSetGenerator> {
    private ILogger myLogger;
    private int myClsuterId;
    private SimilarRetentionPathNodeId myPathNodeId;
    private IEntityReference`1<IShortestPairHashCollection> myShortestPairHashCollection;
    private IEntityReference`1<IShortestPairsCollection> myShortestPairsCollection;
    private IEntityReference`1<IDominatorTreeParentCollection> myDominatorsReference;
    private IEntityReference`1<IShortestRootPathTree> myShortestRootPathTreeReference;
    public SimilarRetentionPathNodeObjectSetGenerator(int clsuterId, SimilarRetentionPathNodeId pathNodeId, IEntityReference`1<IShortestPairHashCollection> shortestPairHashCollection, IEntityReference`1<IShortestPairsCollection> shortestPairsCollection, IEntityReference`1<IDominatorTreeParentCollection> dominatorsReference, IEntityReference`1<IShortestRootPathTree> shortestRootPathTreeReference, SnapshotId snapshotId);
    public sealed virtual IEnumerable`1<ObjectNumber> GetObjectSet(IObjectSetReference superSetReference, IExecutionController executionController);
    private ObjectNumber FindPathNodeObjectNumber(ObjectNumber retainedObjectNumber, IShortestRootPathTree shortestRootPathTree, IShortestPairsCollection shortestPairs, IDominatorTreeParentCollection dominators, IExecutionController executionController);
    protected virtual bool EqualsTo(SimilarRetentionPathNodeObjectSetGenerator other);
    public sealed virtual IPersistentFactory`1<IObjectSetGenerator> GetPersistentFactory();
}
[UsedImplicitlyAttribute]
public class JetBrains.dotMemory.Model.ObjectSets.SingleObjectSet : object {
    private ObjectNumber myObjectNumber;
    public int Count { get; }
    public SingleObjectSet(ObjectNumber objectNumber);
    public sealed virtual IEnumerator`1<ObjectNumber> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual int get_Count();
}
public class JetBrains.dotMemory.Model.ObjectSets.SingleObjectSetReference : object {
    private SingleObjectSet myObjectSet;
    private ObjectSetId myId;
    public ObjectSetId Id { get; }
    public SingleObjectSetReference(ObjectSetId id, ObjectNumber objectNumber);
    public sealed virtual IObjectSet GetEntity(IExecutionController executionController, Lifetime lifetime);
    public sealed virtual ObjectSetId get_Id();
}
[UsedImplicitlyAttribute]
public class JetBrains.dotMemory.Model.ObjectSets.WpfBindingLeakObjectSetGenerator : ObjectSetGeneratorMixin`1<WpfBindingLeakObjectSetGenerator> {
    private string myFieldName;
    private IWpfBindingInspection myWpfBindingInspection;
    [CompilerGeneratedAttribute]
private static Func`2<WpfBindingInfo, ObjectNumber> CS$<>9__CachedAnonymousMethodDelegate3;
    public WpfBindingLeakObjectSetGenerator(string fieldName, SnapshotId snapshotId, IWpfBindingInspection wpfBindingInspection);
    public sealed virtual IPersistentFactory`1<IObjectSetGenerator> GetPersistentFactory();
    public sealed virtual IEnumerable`1<ObjectNumber> GetObjectSet(IObjectSetReference superSetReference, IExecutionController executionController);
    protected virtual bool EqualsTo(WpfBindingLeakObjectSetGenerator other);
    [CompilerGeneratedAttribute]
private bool <GetObjectSet>b__0(WpfBindingInfo root);
    [CompilerGeneratedAttribute]
private static ObjectNumber <GetObjectSet>b__1(WpfBindingInfo root);
}
[UsedImplicitlyAttribute]
public class JetBrains.dotMemory.Model.ObjectSets.WpfCollectionBindingLeakObjectSetGenerator : ObjectSetGeneratorMixin`1<WpfCollectionBindingLeakObjectSetGenerator> {
    private IWpfCollectionBindingInspection myWpfCollectionBindingInspection;
    public WpfCollectionBindingLeakObjectSetGenerator(IWpfCollectionBindingInspection wpfCollectionBindingInspection, SnapshotId snapshotId);
    public sealed virtual IPersistentFactory`1<IObjectSetGenerator> GetPersistentFactory();
    protected virtual bool EqualsTo(WpfCollectionBindingLeakObjectSetGenerator other);
    public sealed virtual IEnumerable`1<ObjectNumber> GetObjectSet(IObjectSetReference superSetReference, IExecutionController executionController);
}
public class JetBrains.dotMemory.Model.ObjectSets.XNameWpfLeakObjectSetGenerator : ObjectSetGeneratorMixin`1<XNameWpfLeakObjectSetGenerator> {
    private IXNameWpfInspection myXNameWpfInspection;
    [CompilerGeneratedAttribute]
private static Func`2<XNameInfo, ObjectNumber> CS$<>9__CachedAnonymousMethodDelegate1;
    public XNameWpfLeakObjectSetGenerator(SnapshotId snapshotId, IXNameWpfInspection xNameWpfInspection);
    public sealed virtual IPersistentFactory`1<IObjectSetGenerator> GetPersistentFactory();
    protected virtual bool EqualsTo(XNameWpfLeakObjectSetGenerator other);
    public sealed virtual IEnumerable`1<ObjectNumber> GetObjectSet(IObjectSetReference superSetReference, IExecutionController controller);
    [CompilerGeneratedAttribute]
private static ObjectNumber <GetObjectSet>b__0(XNameInfo obj);
}
[UsedImplicitlyAttribute]
public class JetBrains.dotMemory.Model.ObjectSetStatisticsCalculator : object {
    private IEntityReference`1<IObjectSizeCollection> myObjectSizeReference;
    public ObjectSetStatisticsCalculator(IEntityReference`1<IObjectSizeCollection> objectSizeReference);
    public sealed virtual ObjectSetStatistic Calculate(IObjectSetReference objectSetReference, IExecutionController controller);
}
[UsedImplicitlyAttribute]
public class JetBrains.dotMemory.Model.ObjectTagging.GlobalObjectTaggingService : object {
    private ISharedStateSettings myStateSettings;
    private ListEvents`1<TaggedGlobalObject> myTaggedObjectsList;
    [CompilerGeneratedAttribute]
private static Comparison`1<TaggedGlobalObject> CS$<>9__CachedAnonymousMethodDelegate1;
    public IReadonlyListEvents`1<TaggedGlobalObject> TaggedObjectsList { get; }
    public GlobalObjectTaggingService(ISharedStateSettings stateSettings);
    public sealed virtual void SetTag(GlobalObjectNumber globalObjectNumber, ObjectTag tag);
    public sealed virtual IReadonlyListEvents`1<TaggedGlobalObject> get_TaggedObjectsList();
    [CompilerGeneratedAttribute]
private static int <.ctor>b__0(TaggedGlobalObject l, TaggedGlobalObject r);
}
public class JetBrains.dotMemory.Model.ObjectTagging.ObjectTaggingService : object {
    private static string DebugId;
    private IGlobalObjectTaggingService myGlobalObjectTaggingService;
    private IGlobalObjectNumbersCollection myGlobalObjectNumberOf;
    private IReadonlyListEvents`1<TaggedObject> myTaggedObjectsProvider;
    private ListEvents`1<TaggedObject> myTaggedObjectsList;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) mySynchronizationOff;
    [CompilerGeneratedAttribute]
private static Comparison`1<TaggedObject> CS$<>9__CachedAnonymousMethodDelegate17;
    public IReadonlyListEvents`1<TaggedObject> TaggedObjectsProvider { get; }
    public ObjectTaggingService(Lifetime lifetime, IGlobalObjectTaggingService globalObjectTaggingService, IGlobalObjectNumbersCollection globalObjectNumberOf, IAsyncTaskDispatcher asyncTaskDispatcher);
    private static ObjectTaggingService();
    public sealed virtual void SetTag(ObjectNumber objectNumber, ObjectTag tag);
    public sealed virtual IReadonlyListEvents`1<TaggedObject> get_TaggedObjectsProvider();
    [CompilerGeneratedAttribute]
private static int <SetTag>b__14(TaggedObject l, TaggedObject r);
    [CompilerGeneratedAttribute]
private void <SetTag>b__15();
    [CompilerGeneratedAttribute]
private void <SetTag>b__16();
}
public class JetBrains.dotMemory.Model.Path : ChunkList`1<GraphReferenceId> {
}
[UsedImplicitlyAttribute]
public class JetBrains.dotMemory.Model.PathFinder : object {
    private IEntityReference`1<IReverseGraph> myReverseGraphEntityReference;
    private IObjectRootReferencesCollection myObjectRootReferencesCollection;
    public PathFinder(IEntityReference`1<IReverseGraph> reverseGraphEntityReference, IObjectRootReferencesCollection objectRootReferencesCollection);
    public sealed virtual IEnumerable`1<ObjectNumber> FindPathFromClosestRoot(ObjectNumber objectNumber, IEnumerable`1<ObjectNumber> objectsToExclude, IExecutionController executionController);
}
[UsedImplicitlyAttribute]
public class JetBrains.dotMemory.Model.PerformanceCounterValuePipelineBuilder : object {
    private static int CounterCreationRetryCount;
    private static double CounterInvalidValue;
    private static TimeSpan CheckForValuePeriod;
    private Lifetime myLifetime;
    private IPerformanceCountersFactory myPerformanceCountersFactory;
    private PerformanceCounterId myPerformanceCounterId;
    private int myCheckingState;
    [CanBeNullAttribute]
private Timer myTimer;
    private IPerformanceCounter`1<double> myCounter;
    private IDataController`1<int> myCurrentValueInput;
    private IDataController`1<bool> myIsValueAvailableInput;
    public IDataProvider`1<int> CurrentValue;
    public IDataProvider`1<bool> IsValueAvailable;
    private bool IsActive { get; }
    public PerformanceCounterValuePipelineBuilder(Lifetime lifetime, IPerformanceCountersFactory performanceCountersFactory, PerformanceCounterId performanceCounterId);
    private static PerformanceCounterValuePipelineBuilder();
    private double GetCounterValueSafe();
    private static bool IsValueValid(double value);
    private void HandleCurrentState();
    private void WriteCounterValue(double value);
    private void WriteCounterAvailable(bool isAvailable);
    private void WriteCounter(double value);
    private bool get_IsActive();
    private void Activate();
    private void Deactivate();
    private void TryActivate();
    private void TryDeactivate();
    [CompilerGeneratedAttribute]
private void <.ctor>b__0(bool isActive);
    [CompilerGeneratedAttribute]
private void <Activate>b__2(object _);
}
public interface JetBrains.dotMemory.Model.Persistence.IValuePersistentFactory {
    public abstract virtual object GetValue();
}
[DataContractAttribute]
public class JetBrains.dotMemory.Model.Persistence.PersistentFactory`1 : object {
    [DataMemberAttribute]
private Object[] myValues;
    public PersistentFactory`1(Object[] values);
    public sealed virtual T Instantiate(IFactory factory, Object[] parameters);
}
public static class JetBrains.dotMemory.Model.Persistence.ValuePersistentFactory : object {
    public static IPersistentFactory`1<T> Create(T value);
}
[DataContractAttribute]
public class JetBrains.dotMemory.Model.Persistence.ValuePersistentFactory`1 : object {
    [DataMemberAttribute]
private T myValue;
    public ValuePersistentFactory`1(T value);
    public sealed virtual T Instantiate(IFactory factory, Object[] parameters);
    public sealed virtual object GetValue();
}
public class JetBrains.dotMemory.Model.ProfilingProcessModel : ProfilingProcess {
    private IMemoryCoreHostProfile myMemoryCoreHostProfile;
    public IMemoryCoreHostProfile MemoryCoreHostProfile { get; }
    public ProfilingProcessModel(IMemoryCoreHostProfile memoryCoreHostProfile);
    public IMemoryCoreHostProfile get_MemoryCoreHostProfile();
}
[UsedImplicitlyAttribute]
public class JetBrains.dotMemory.Model.Queries.AllocatedFromGCObjectSetGenerator : ObjectSetGeneratorMixin`1<AllocatedFromGCObjectSetGenerator> {
    private ISnapshotScope mySnapshotScope;
    private ICuttedSessionDetector myCuttedSessionDetector;
    private GCNumber myFromGC;
    public AllocatedFromGCObjectSetGenerator(GCNumber fromGC, ISnapshotScope snapshotScope, ICuttedSessionDetector cuttedSessionDetector);
    protected virtual bool EqualsTo(AllocatedFromGCObjectSetGenerator other);
    public sealed virtual IPersistentFactory`1<IObjectSetGenerator> GetPersistentFactory();
    public sealed virtual IEnumerable`1<ObjectNumber> GetObjectSet(IObjectSetReference superSetReference, IExecutionController executionController);
}
[UsedImplicitlyAttribute]
public class JetBrains.dotMemory.Model.Queries.AllocatedInFunctionObjectSetGenerator : ObjectSetGeneratorMixin`1<AllocatedInFunctionObjectSetGenerator> {
    private Nullable`1<MethodId> myMethodId;
    private bool myIsSkipped;
    private IAllocationPointsService myAllocationPointsService;
    private ISnapshotScope mySnapshotScope;
    private IAllocationCallstackService myCallstackService;
    [CompilerGeneratedAttribute]
private static Func`2<IObjectsByAllocationRootGroup, IEnumerable`1<ObjectNumber>> CS$<>9__CachedAnonymousMethodDelegate3;
    public AllocatedInFunctionObjectSetGenerator(Nullable`1<MethodId> methodId, bool isSkipped, IAllocationPointsService allocationPointsService, ISnapshotScope snapshotScope, SnapshotId snapshotId, IAllocationCallstackService callstackService);
    public sealed virtual IEnumerable`1<ObjectNumber> GetObjectSet(IObjectSetReference superSetReference, IExecutionController executionController);
    protected virtual bool EqualsTo(AllocatedInFunctionObjectSetGenerator other);
    public sealed virtual IPersistentFactory`1<IObjectSetGenerator> GetPersistentFactory();
    [CompilerGeneratedAttribute]
private bool <GetObjectSet>b__0(IObjectsByAllocationRootGroup _);
    [CompilerGeneratedAttribute]
private static IEnumerable`1<ObjectNumber> <GetObjectSet>b__1(IObjectsByAllocationRootGroup _);
}
[UsedImplicitlyAttribute]
public class JetBrains.dotMemory.Model.Queries.AllocatedInFunctionTreeObjectSetGenerator : ObjectSetGeneratorMixin`1<AllocatedInFunctionTreeObjectSetGenerator> {
    private DfsInfoLink[] myDfsInfoLinks;
    private bool myIsOwn;
    private IObjectsByCallTreeGrouper myByCallTreeGrouper;
    private IObjectToCallTreeNodeLinker myObjectToCallTreeNodeLinker;
    private ISnapshotScope mySnapshotScope;
    [CompilerGeneratedAttribute]
private static Comparison`1<ObjectNumber> CS$<>9__CachedAnonymousMethodDelegate3;
    public AllocatedInFunctionTreeObjectSetGenerator(bool isOwn, IEnumerable`1<DfsInfoLink> callTreeLinks, IObjectsByCallTreeGrouper byCallTreeGrouper, IObjectToCallTreeNodeLinker objectToCallTreeNodeLinker, ISnapshotScope snapshotScope);
    public sealed virtual IEnumerable`1<ObjectNumber> GetObjectSet(IObjectSetReference superSetReference, IExecutionController executionController);
    protected virtual bool EqualsTo(AllocatedInFunctionTreeObjectSetGenerator other);
    public sealed virtual IPersistentFactory`1<IObjectSetGenerator> GetPersistentFactory();
    [CompilerGeneratedAttribute]
private static int <GetObjectSet>b__2(ObjectNumber l, ObjectNumber r);
}
[UsedImplicitlyAttribute]
public class JetBrains.dotMemory.Model.Queries.AllocatedOnStackTraceObjectSetGenerator : ObjectSetGeneratorMixin`1<AllocatedOnStackTraceObjectSetGenerator> {
    private CallTreeLink[] myAllocationRoots;
    private IAllocationPointsService myAllocationPointsService;
    private ISnapshotScope mySnapshotScope;
    [CompilerGeneratedAttribute]
private static Func`2<IAllocationPoint, ObjectNumber> CS$<>9__CachedAnonymousMethodDelegate2;
    public AllocatedOnStackTraceObjectSetGenerator(CallTreeLink[] allocationRoots, IAllocationPointsService allocationPointsService, ISnapshotScope snapshotScope, SnapshotId snapshotId);
    protected virtual bool EqualsTo(AllocatedOnStackTraceObjectSetGenerator other);
    public sealed virtual IPersistentFactory`1<IObjectSetGenerator> GetPersistentFactory();
    public sealed virtual IEnumerable`1<ObjectNumber> GetObjectSet(IObjectSetReference superSetReference, IExecutionController executionController);
    private static bool ContainsLinkToAllocationPoint(ICollection`1<CallTreeLink> searchableRoots, IAllocationPoint allocationPoint);
    [CompilerGeneratedAttribute]
private static ObjectNumber <GetObjectSet>b__1(IAllocationPoint _);
}
[UsedImplicitlyAttribute]
public class JetBrains.dotMemory.Model.Queries.AssemblyProperty : object {
    private IFactory myFactory;
    public AssemblyProperty(IFactory factory);
    public sealed virtual IQueryClause Like(IReadOnlyCollection`1<string> assemblies);
    public sealed virtual IQueryClause NotLike(IReadOnlyCollection`1<string> assemblies);
}
public class JetBrains.dotMemory.Model.Queries.AtDominationPathByTypeObjectSetGenerator : ObjectSetGeneratorMixin`1<AtDominationPathByTypeObjectSetGenerator> {
    private IReadOnlyList`1<TypeId> myDominationPath;
    private ISet`1<TypeId> myTypes;
    private IEntityReference`1<IDominatorTreeParentCollection> myDominatorParentsRef;
    private IEntityReference`1<IObjectTypeCollection> myObjectTypesRef;
    public AtDominationPathByTypeObjectSetGenerator(IReadOnlyList`1<TypeId> dominationPath, ISet`1<TypeId> types, IEntityReference`1<IDominatorTreeParentCollection> dominatorParentsRef, IEntityReference`1<IObjectTypeCollection> objectTypesRef, SnapshotId snapshotId);
    public sealed virtual IEnumerable`1<ObjectNumber> GetObjectSet(IObjectSetReference superSetReference, IExecutionController executionController);
    protected virtual bool EqualsTo(AtDominationPathByTypeObjectSetGenerator other);
    public sealed virtual IPersistentFactory`1<IObjectSetGenerator> GetPersistentFactory();
}
public class JetBrains.dotMemory.Model.Queries.AtDominationPathObjectSetGenerator : ObjectSetGeneratorMixin`1<AtDominationPathObjectSetGenerator> {
    private IReadOnlyList`1<TypeId> myDominationPath;
    private IEntityReference`1<IDominatorTreeParentCollection> myDominatorParentsRef;
    private IEntityReference`1<IObjectTypeCollection> myObjectTypesRef;
    public AtDominationPathObjectSetGenerator(IReadOnlyList`1<TypeId> dominationPath, IEntityReference`1<IDominatorTreeParentCollection> dominatorParentsRef, IEntityReference`1<IObjectTypeCollection> objectTypesRef, SnapshotId snapshotId);
    public sealed virtual IEnumerable`1<ObjectNumber> GetObjectSet(IObjectSetReference superSetReference, IExecutionController executionController);
    protected virtual bool EqualsTo(AtDominationPathObjectSetGenerator other);
    public sealed virtual IPersistentFactory`1<IObjectSetGenerator> GetPersistentFactory();
}
public class JetBrains.dotMemory.Model.Queries.ByAssemblyObjectSetGenerator : ObjectSetGeneratorMixin`1<ByAssemblyObjectSetGenerator> {
    private String[] myAssemblies;
    private IEntityReference`1<IMetadataService> myMetadataServiceReference;
    private IEntityReference`1<IObjectTypeCollection> myObjectTypeCollectionReference;
    private bool myEqual;
    [CompilerGeneratedAttribute]
private static Func`2<string, bool> CS$<>9__CachedAnonymousMethodDelegate4;
    [CompilerGeneratedAttribute]
private static Func`2<string, bool> CS$<>9__CachedAnonymousMethodDelegate5;
    public ByAssemblyObjectSetGenerator(IEnumerable`1<string> assemblies, bool equal, SnapshotId snapshotId, IEntityReference`1<IMetadataService> metadataServiceReference, IEntityReference`1<IObjectTypeCollection> objectTypeCollectionReference);
    public sealed virtual IEnumerable`1<ObjectNumber> GetObjectSet(IObjectSetReference superSetReference, IExecutionController executionController);
    private static bool IsWildcardMatched(string pattern, string objectAssembly);
    protected virtual bool EqualsTo(ByAssemblyObjectSetGenerator other);
    public sealed virtual IPersistentFactory`1<IObjectSetGenerator> GetPersistentFactory();
    [CompilerGeneratedAttribute]
private static bool <GetObjectSet>b__0(string _);
    [CompilerGeneratedAttribute]
private static bool <GetObjectSet>b__1(string _);
}
public class JetBrains.dotMemory.Model.Queries.ComparableObjectProperty`2 : object {
    private IEntityReference`1<TData> myDataReference;
    public ComparableObjectProperty`2(IEntityReference`1<TData> dataReference);
    public sealed virtual Func`2<IObjectSetReference, IObjectSetGenerator> EqualTo(TProperty value);
    public sealed virtual Func`2<IObjectSetReference, IObjectSetGenerator> NotEqualTo(TProperty value);
    public sealed virtual Func`2<IObjectSetReference, IObjectSetGenerator> GreaterThan(TProperty value);
    public sealed virtual Func`2<IObjectSetReference, IObjectSetGenerator> GreaterThanOrEqual(TProperty value);
    public sealed virtual Func`2<IObjectSetReference, IObjectSetGenerator> LessThan(TProperty value);
    public sealed virtual Func`2<IObjectSetReference, IObjectSetGenerator> LessThanOrEqual(TProperty value);
    protected Func`2<IObjectSetReference, IObjectSetGenerator> CreateProvider(TProperty value, PredicateType predicateType);
}
[DataContractAttribute]
public class JetBrains.dotMemory.Model.Queries.ComparisonObjectSetDeserializer`1 : object {
    [DataMemberAttribute]
private SnapshotId mySnapshotId1;
    [DataMemberAttribute]
private SnapshotId mySnapshotId2;
    public ComparisonObjectSetDeserializer`1(SnapshotId snapshotId1, SnapshotId snapshotId2);
    public sealed virtual T Instantiate(IFactory factory, Object[] parameters);
    [CompilerGeneratedAttribute]
private bool <Instantiate>b__0(ISnapshotScope _);
    [CompilerGeneratedAttribute]
private bool <Instantiate>b__1(ISnapshotScope _);
}
[UsedImplicitlyAttribute]
public class JetBrains.dotMemory.Model.Queries.DeadObjectSetGenerator : ObjectSetGeneratorMixin`1<DeadObjectSetGenerator> {
    private IComparisonDescription myComparisonDescription;
    [CompilerGeneratedAttribute]
private static Func`2<IntersectionNode`1<ObjectNumber>, bool> CS$<>9__CachedAnonymousMethodDelegate5;
    [CompilerGeneratedAttribute]
private static Func`2<IntersectionNode`1<ObjectNumber>, ObjectNumber> CS$<>9__CachedAnonymousMethodDelegate6;
    public DeadObjectSetGenerator(IComparisonDescription comparisonDescription);
    public sealed virtual IEnumerable`1<ObjectNumber> GetObjectSet(IObjectSetReference superSetReference, IExecutionController executionController);
    protected virtual bool EqualsTo(DeadObjectSetGenerator other);
    public sealed virtual IPersistentFactory`1<IObjectSetGenerator> GetPersistentFactory();
    [CompilerGeneratedAttribute]
private static bool <GetObjectSet>b__3(IntersectionNode`1<ObjectNumber> _);
    [CompilerGeneratedAttribute]
private static ObjectNumber <GetObjectSet>b__4(IntersectionNode`1<ObjectNumber> _);
}
public class JetBrains.dotMemory.Model.Queries.DominatedViaPathByTypeObjectSetGenerator : ObjectSetGeneratorMixin`1<DominatedViaPathByTypeObjectSetGenerator> {
    private IReadOnlyList`1<TypeId> myDominationPath;
    private ISet`1<TypeId> myTypes;
    private IEntityReference`1<IDominatorTreeParentCollection> myDominatorParentsRef;
    private IEntityReference`1<IObjectTypeCollection> myObjectTypesRef;
    public DominatedViaPathByTypeObjectSetGenerator(IReadOnlyList`1<TypeId> dominationPath, ISet`1<TypeId> types, IEntityReference`1<IDominatorTreeParentCollection> dominatorParentsRef, IEntityReference`1<IObjectTypeCollection> objectTypesRef, SnapshotId snapshotId);
    public sealed virtual IEnumerable`1<ObjectNumber> GetObjectSet(IObjectSetReference superSetReference, IExecutionController executionController);
    protected virtual bool EqualsTo(DominatedViaPathByTypeObjectSetGenerator other);
    public sealed virtual IPersistentFactory`1<IObjectSetGenerator> GetPersistentFactory();
}
[UsedImplicitlyAttribute]
public class JetBrains.dotMemory.Model.Queries.DominatedViaPathObjectSetGenerator : ObjectSetGeneratorMixin`1<DominatedViaPathObjectSetGenerator> {
    private IReadOnlyList`1<TypeId> myDominationPath;
    private IEntityReference`1<IDominatorTreeParentCollection> myDominatorParentsRef;
    private IEntityReference`1<IObjectTypeCollection> myObjectTypesRef;
    public DominatedViaPathObjectSetGenerator(IReadOnlyList`1<TypeId> dominationPath, IEntityReference`1<IDominatorTreeParentCollection> dominatorParentsRef, IEntityReference`1<IObjectTypeCollection> objectTypesRef, SnapshotId snapshotId);
    public sealed virtual IEnumerable`1<ObjectNumber> GetObjectSet(IObjectSetReference superSetReference, IExecutionController executionController);
    protected virtual bool EqualsTo(DominatedViaPathObjectSetGenerator other);
    public sealed virtual IPersistentFactory`1<IObjectSetGenerator> GetPersistentFactory();
}
public class JetBrains.dotMemory.Model.Queries.EquatableObjectProperty`2 : ObjectProperty`2<TProperty, TData> {
    public EquatableObjectProperty`2(IEntityReference`1<TData> dataReference, IFactory factory);
    public sealed virtual IQueryClause EqualTo(TProperty value);
    public sealed virtual IQueryClause NotEqualTo(TProperty value);
}
public class JetBrains.dotMemory.Model.Queries.FilterObjectSetGenerator : ObjectSetGeneratorMixin`1<FilterObjectSetGenerator> {
    private IObjectFilter myObjectFilter;
    public FilterObjectSetGenerator(IObjectFilter objectFilter, SnapshotId snapshotId);
    public sealed virtual IEnumerable`1<ObjectNumber> GetObjectSet(IObjectSetReference superSetReference, IExecutionController executionController);
    protected virtual bool EqualsTo(FilterObjectSetGenerator other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual IPersistentFactory`1<IObjectSetGenerator> GetPersistentFactory();
}
public class JetBrains.dotMemory.Model.Queries.GCRangeObjectSetGenerator : ObjectSetGeneratorMixin`1<GCRangeObjectSetGenerator> {
    private IEntityReference`1<IObjectAllocationGCNumberCollection> myGCNumberCollectionReference;
    private GCNumber myMinGC;
    private GCNumber myMaxGC;
    public GCRangeObjectSetGenerator(SnapshotId snapshotId, IEntityReference`1<IObjectAllocationGCNumberCollection> gcNumberCollectionReference, GCNumber minGC, GCNumber maxGC);
    public sealed virtual IPersistentFactory`1<IObjectSetGenerator> GetPersistentFactory();
    protected virtual bool EqualsTo(GCRangeObjectSetGenerator other);
    public sealed virtual IEnumerable`1<ObjectNumber> GetObjectSet(IObjectSetReference superSetReference, IExecutionController executionController);
}
[UsedImplicitlyAttribute]
public class JetBrains.dotMemory.Model.Queries.HeapGenerationObjectSetGenerator : ObjectSetGeneratorMixin`1<HeapGenerationObjectSetGenerator> {
    private GenerationMark myGenerationMark;
    private IEntityReference`1<IReadOnlyList`1<HeapDescription>> myHeapsReference;
    private IEntityReference`1<IObjectAddressCollection> myObjectAddressCollectionReference;
    public HeapGenerationObjectSetGenerator(GenerationMark generationMark, IEntityReference`1<IHeapsCollection> heapsReference, IEntityReference`1<IObjectAddressCollection> objectAddressCollectionReference, SnapshotId snapshotId);
    public sealed virtual IEnumerable`1<ObjectNumber> GetObjectSet(IObjectSetReference superSetReference, IExecutionController executionController);
    protected virtual bool EqualsTo(HeapGenerationObjectSetGenerator other);
    public sealed virtual IPersistentFactory`1<IObjectSetGenerator> GetPersistentFactory();
}
[UsedImplicitlyAttribute]
public class JetBrains.dotMemory.Model.Queries.HeapGenerationObjectSetGenerator2 : ObjectSetGeneratorMixin`1<HeapGenerationObjectSetGenerator2> {
    private GenerationMark[] myGenerationMarks;
    private IEntityReference`1<IReadOnlyList`1<HeapDescription>> myHeapsReference;
    private IEntityReference`1<IObjectAddressCollection> myObjectAddressCollectionReference;
    private bool myEqual;
    public HeapGenerationObjectSetGenerator2(bool equal, GenerationMark[] generationMarks, IEntityReference`1<IHeapsCollection> heapsReference, IEntityReference`1<IObjectAddressCollection> objectAddressCollectionReference, SnapshotId snapshotId);
    public sealed virtual IEnumerable`1<ObjectNumber> GetObjectSet(IObjectSetReference superSetReference, IExecutionController executionController);
    private bool IsInList(GenerationMark generationMark);
    protected virtual bool EqualsTo(HeapGenerationObjectSetGenerator2 other);
    public sealed virtual IPersistentFactory`1<IObjectSetGenerator> GetPersistentFactory();
}
public class JetBrains.dotMemory.Model.Queries.HeapObjectSetGenerator : ObjectSetGeneratorMixin`1<HeapObjectSetGenerator> {
    private int myHeapIndex;
    private IEntityReference`1<IHeapsCollection> myHeapsReference;
    private IEntityReference`1<IObjectAddressCollection> myAddressesReference;
    public HeapObjectSetGenerator(int heapIndex, IEntityReference`1<IHeapsCollection> heapsReference, IEntityReference`1<IObjectAddressCollection> addressesReference, SnapshotId snapshotId);
    public sealed virtual IEnumerable`1<ObjectNumber> GetObjectSet(IObjectSetReference superSetReference, IExecutionController executionController);
    protected virtual bool EqualsTo(HeapObjectSetGenerator other);
    public sealed virtual IPersistentFactory`1<IObjectSetGenerator> GetPersistentFactory();
}
[UsedImplicitlyAttribute]
public class JetBrains.dotMemory.Model.Queries.IsOfTypeObjectSetGenerator : ObjectSetGeneratorMixin`1<IsOfTypeObjectSetGenerator> {
    private TypeId[] myTypeIdCollection;
    private bool myEqual;
    private IEntityReference`1<IObjectTypeCollection> myObjectTypeCollection;
    public IsOfTypeObjectSetGenerator(IEnumerable`1<TypeId> typeIdCollection, bool equal, IEntityReference`1<IObjectTypeCollection> objectTypeCollection, SnapshotId snapshotId);
    public sealed virtual IEnumerable`1<ObjectNumber> GetObjectSet(IObjectSetReference superSetReference, IExecutionController executionController);
    protected virtual bool EqualsTo(IsOfTypeObjectSetGenerator other);
    public sealed virtual IPersistentFactory`1<IObjectSetGenerator> GetPersistentFactory();
}
[UsedImplicitlyAttribute]
public class JetBrains.dotMemory.Model.Queries.NamespaceObjectSetGenerator : ObjectSetGeneratorMixin`1<NamespaceObjectSetGenerator> {
    private IReadOnlyCollection`1<IReadOnlyCollection`1<string>> myNamespacesCollection;
    private bool myIsEqual;
    private IPersistentFactory`1<IObjectSetGenerator> myPersistentFactory;
    private IEntityReference`1<IObjectTypeCollection> myObjectTypeCollectionReference;
    private IEntityReference`1<ITypeService> myTypeServiceReference;
    [CompilerGeneratedAttribute]
private static Func`2<IReadOnlyCollection`1<string>, bool> CS$<>9__CachedAnonymousMethodDelegate9;
    [CompilerGeneratedAttribute]
private static Func`2<IGrouping`2<bool, IReadOnlyCollection`1<string>>, bool> CS$<>9__CachedAnonymousMethodDelegatea;
    [CompilerGeneratedAttribute]
private static Func`2<IGrouping`2<bool, IReadOnlyCollection`1<string>>, IEnumerable`1<string>> CS$<>9__CachedAnonymousMethodDelegateb;
    [CompilerGeneratedAttribute]
private static Func`2<string, Wildcard> CS$<>9__CachedAnonymousMethodDelegatec;
    [CompilerGeneratedAttribute]
private static Func`2<string, bool> CS$<>9__CachedAnonymousMethodDelegatef;
    [CompilerGeneratedAttribute]
private static Func`2<IReadOnlyCollection`1<string>, string> CS$<>9__CachedAnonymousMethodDelegate10;
    public NamespaceObjectSetGenerator(IReadOnlyCollection`1<IReadOnlyCollection`1<string>> namespacesCollection, bool isEqual, IEntityReference`1<IObjectTypeCollection> objectTypeCollectionReference, IEntityReference`1<ITypeService> typeServiceReference, SnapshotId snapshotId);
    public sealed virtual IEnumerable`1<ObjectNumber> GetObjectSet(IObjectSetReference superSetReference, IExecutionController executionController);
    protected virtual bool EqualsTo(NamespaceObjectSetGenerator other);
    public sealed virtual IPersistentFactory`1<IObjectSetGenerator> GetPersistentFactory();
    [CompilerGeneratedAttribute]
private static bool <GetObjectSet>b__0(IReadOnlyCollection`1<string> _);
    [CompilerGeneratedAttribute]
private static bool <GetObjectSet>b__2(IGrouping`2<bool, IReadOnlyCollection`1<string>> _);
    [CompilerGeneratedAttribute]
private static IEnumerable`1<string> <GetObjectSet>b__3(IGrouping`2<bool, IReadOnlyCollection`1<string>> value);
    [CompilerGeneratedAttribute]
private static Wildcard <GetObjectSet>b__5(string _);
    [CompilerGeneratedAttribute]
private static bool <GetObjectSet>b__1(string part);
    [CompilerGeneratedAttribute]
private static string <GetObjectSet>b__4(IReadOnlyCollection`1<string> ns);
}
[UsedImplicitlyAttribute]
public class JetBrains.dotMemory.Model.Queries.NamespaceProperty : object {
    private IFactory myFactory;
    public NamespaceProperty(IFactory factory);
    public sealed virtual IQueryClause Like(IReadOnlyCollection`1[] namespaces);
    public sealed virtual IQueryClause NotLike(IReadOnlyCollection`1[] namespaces);
}
[UsedImplicitlyAttribute]
public class JetBrains.dotMemory.Model.Queries.NewObjectSetGenerator : ObjectSetGeneratorMixin`1<NewObjectSetGenerator> {
    private IComparisonDescription myComparisonDescription;
    public NewObjectSetGenerator(IComparisonDescription comparisonDescription);
    public sealed virtual IEnumerable`1<ObjectNumber> GetObjectSet(IObjectSetReference superSetReference, IExecutionController executionController);
    protected virtual bool EqualsTo(NewObjectSetGenerator other);
    public sealed virtual IPersistentFactory`1<IObjectSetGenerator> GetPersistentFactory();
}
public class JetBrains.dotMemory.Model.Queries.NotDominatedObjectSetGenerator : ObjectSetGeneratorMixin`1<NotDominatedObjectSetGenerator> {
    private IEntityReference`1<IDominatorTreeParentCollection> myDominatorTreeReference;
    public NotDominatedObjectSetGenerator(IEntityReference`1<IDominatorTreeParentCollection> dominatorTreeReference, SnapshotId snapshotId);
    public sealed virtual IEnumerable`1<ObjectNumber> GetObjectSet(IObjectSetReference superSetReference, IExecutionController executionController);
    public sealed virtual IPersistentFactory`1<IObjectSetGenerator> GetPersistentFactory();
    protected virtual bool EqualsTo(NotDominatedObjectSetGenerator other);
}
public class JetBrains.dotMemory.Model.Queries.ObjectComparablePropertyFilter`2 : ObjectPropertyFilterBase`2<TProperty, TData> {
    public ObjectComparablePropertyFilter`2(TProperty matchValue, IEntityReference`1<TData> dataReference, PredicateType predicateType);
    protected virtual IPersistentFactory`1<IObjectFilter> GetPersistentData(PredicateType predicateType, TProperty value);
    public virtual bool Equals(IObjectFilter other);
}
public class JetBrains.dotMemory.Model.Queries.ObjectEquatablePropertyFilter`2 : ObjectPropertyFilterBase`2<TProperty, TData> {
    public ObjectEquatablePropertyFilter`2(TProperty matchValue, IEntityReference`1<TData> dataReference, PredicateType predicateType);
    protected virtual IPersistentFactory`1<IObjectFilter> GetPersistentData(PredicateType predicateType, TProperty value);
    public virtual bool Equals(IObjectFilter other);
}
public class JetBrains.dotMemory.Model.Queries.ObjectProperty`2 : object {
    protected IEntityReference`1<TData> DataReference;
    protected IFactory Factory;
    public ObjectProperty`2(IEntityReference`1<TData> dataReference, IFactory factory);
}
public abstract class JetBrains.dotMemory.Model.Queries.ObjectPropertyFilterBase`2 : object {
    protected TProperty MatchValue;
    private IEntityReference`1<TData> myDataReference;
    protected PredicateType PredicateType;
    protected Func`3<TProperty, TProperty, bool> Predicate;
    protected ObjectPropertyFilterBase`2(TProperty matchValue, IEntityReference`1<TData> dataReference, PredicateType predicateType);
    public sealed virtual IObjectMatcher GetMatcher(IExecutionController controller, Lifetime lifetime);
    public sealed virtual IPersistentFactory`1<IObjectFilter> GetPersistentFactory();
    protected abstract virtual IPersistentFactory`1<IObjectFilter> GetPersistentData(PredicateType predicateType, TProperty value);
    public abstract virtual bool Equals(IObjectFilter other);
}
public abstract class JetBrains.dotMemory.Model.Queries.ObjectSetGeneratorMixin`1 : object {
    private SnapshotId mySnapshotId;
    public SnapshotId SnapshotId { get; }
    protected ObjectSetGeneratorMixin`1(SnapshotId snapshotId);
    public sealed virtual SnapshotId get_SnapshotId();
    public sealed virtual bool Equals(IObjectSetGenerator other);
    protected abstract virtual bool EqualsTo(T other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class JetBrains.dotMemory.Model.Queries.ObjectSetGeneratorSequence : ObjectSetGeneratorMixin`1<ObjectSetGeneratorSequence> {
    private IObjectSetGenerator[] myGenerators;
    public ObjectSetGeneratorSequence(IObjectSetGenerator[] generators, SnapshotId snapshotId);
    public sealed virtual IEnumerable`1<ObjectNumber> GetObjectSet(IObjectSetReference superSetReference, IExecutionController executionController);
    protected virtual bool EqualsTo(ObjectSetGeneratorSequence other);
    public sealed virtual IPersistentFactory`1<IObjectSetGenerator> GetPersistentFactory();
}
[UsedImplicitlyAttribute]
internal class JetBrains.dotMemory.Model.Queries.PinnedObjectSetGenerator : ObjectSetGeneratorMixin`1<PinnedObjectSetGenerator> {
    private IEntityReference`1<IGraphRootCollection> myRootSectionReference;
    private IEntityReference`1<IObjectRootReferencesCollection> myObjectRootReferencesReference;
    public PinnedObjectSetGenerator(SnapshotId snapshotId, IEntityReference`1<IGraphRootCollection> rootSectionReference, IEntityReference`1<IObjectRootReferencesCollection> objectRootReferencesReference);
    protected virtual bool EqualsTo(PinnedObjectSetGenerator other);
    public sealed virtual IPersistentFactory`1<IObjectSetGenerator> GetPersistentFactory();
    public sealed virtual IEnumerable`1<ObjectNumber> GetObjectSet(IObjectSetReference superSetReference, IExecutionController executionController);
}
[UsedImplicitlyAttribute]
public class JetBrains.dotMemory.Model.Queries.QueryService : object {
    private IFactory myFactory;
    private IQuerySyntaxSugar mySyntaxSugar;
    public QueryService(IQuerySyntaxSugar syntaxSugar, IFactory factory);
    public sealed virtual IObjectSetGenerator Select(Func`2[] sequence);
    [CompilerGeneratedAttribute]
private IObjectSetGenerator <Select>b__0(Func`2<IQuerySyntaxSugar, IQueryClause> func);
}
[UsedImplicitlyAttribute]
public class JetBrains.dotMemory.Model.Queries.QuerySyntaxSugar : object {
    private IFactory myFactory;
    private TypeIdProperty myTypeId;
    private NamespaceProperty myNamespaceProperty;
    private AssemblyProperty myAssemblyProperty;
    public ITypeIdProperty TypeId { get; }
    public INamespaceProperty Namespace { get; }
    public IAssemblyProperty Assembly { get; }
    public IQueryClause RetainedObjectsSet { get; }
    public QuerySyntaxSugar(TypeIdProperty typeId, NamespaceProperty namespaceProperty, AssemblyProperty assemblyProperty, IFactory factory);
    public sealed virtual ITypeIdProperty get_TypeId();
    public sealed virtual INamespaceProperty get_Namespace();
    public sealed virtual IAssemblyProperty get_Assembly();
    public sealed virtual IQueryClause GenerationIs(GenerationMark generationMarks);
    public sealed virtual IQueryClause GenerationIs2(GenerationMark[] generationMarks);
    public sealed virtual IQueryClause GenerationIsNot2(GenerationMark[] generationMarks);
    public sealed virtual IQueryClause HeapIs(int heapIndex);
    public sealed virtual IQueryClause IsNotDominated();
    public sealed virtual IQueryClause DominatedViaPath(IReadOnlyList`1<TypeId> dominationPath);
    public sealed virtual IQueryClause DominatedViaPath(IReadOnlyList`1<TypeId> dominationPath, ISet`1<TypeId> types);
    public sealed virtual IQueryClause AtDominationPath(IReadOnlyList`1<TypeId> dominationPath);
    public sealed virtual IQueryClause AtDominationPath(IReadOnlyList`1<TypeId> dominationPath, ISet`1<TypeId> types);
    public sealed virtual IQueryClause SimilarRetentionClusterIs(UInt32 clusterId);
    public sealed virtual IQueryClause SimilarRetentionPathNode(int clusterId, SimilarRetentionPathNodeId nodeId);
    public sealed virtual IQueryClause get_RetainedObjectsSet();
    public sealed virtual IQueryClause DeadObjectsSet(IComparisonDescription comparisonDescription);
    public sealed virtual IQueryClause NewObjectsSet(IComparisonDescription comparisonDescription);
    public sealed virtual IQueryClause SurvivedObjectsSet(SurvivedObjectsOrigin survivedObjectsOrigin, IComparisonDescription comparisonDescription);
    public sealed virtual IQueryClause AllocatedAfterGCNumber(GCNumber fromGC);
    public sealed virtual IQueryClause AllocatedInFunction(Nullable`1<MethodId> functionId, bool isSkipped);
    public sealed virtual IQueryClause AllocatedInFunctionTree(IEnumerable`1<DfsInfoLink> callTreeLinks, bool ownAllocatedObjects);
    public sealed virtual IQueryClause AllocatedOnStackOf(CallTreeLink[] origins);
    public sealed virtual IQueryClause EventHandlersDescendants();
    public sealed virtual IQueryClause WpfBindingInspectionLeakRoots(string fieldName);
    public sealed virtual IQueryClause XNameWpfLeakRoots();
    public sealed virtual IQueryClause WpfCollectionBindingLeakRoots();
    public sealed virtual IQueryClause DuplicatedStringValueIs(string value);
    public sealed virtual IQueryClause DependencyPropertyLeakRoots();
    public sealed virtual IQueryClause PinnedObjects();
    [CompilerGeneratedAttribute]
private IObjectSetGenerator <IsNotDominated>b__c();
    [CompilerGeneratedAttribute]
private IObjectSetGenerator <get_RetainedObjectsSet>b__1f();
    [CompilerGeneratedAttribute]
private IObjectSetGenerator <EventHandlersDescendants>b__35();
    [CompilerGeneratedAttribute]
private IObjectSetGenerator <XNameWpfLeakRoots>b__39();
    [CompilerGeneratedAttribute]
private IObjectSetGenerator <WpfCollectionBindingLeakRoots>b__3a();
    [CompilerGeneratedAttribute]
private IObjectSetGenerator <DependencyPropertyLeakRoots>b__3e();
    [CompilerGeneratedAttribute]
private IObjectSetGenerator <PinnedObjects>b__3f();
}
public class JetBrains.dotMemory.Model.Queries.RetainedObjectSetGenerator : ObjectSetGeneratorMixin`1<RetainedObjectSetGenerator> {
    private IObjectGraphService myGraphService;
    public RetainedObjectSetGenerator(IObjectGraphService graphService, SnapshotId snapshotId);
    public sealed virtual IEnumerable`1<ObjectNumber> GetObjectSet(IObjectSetReference superSetReference, IExecutionController executionController);
    protected virtual bool EqualsTo(RetainedObjectSetGenerator other);
    public sealed virtual IPersistentFactory`1<IObjectSetGenerator> GetPersistentFactory();
}
public class JetBrains.dotMemory.Model.Queries.SimpleObjectMatcher`1 : object {
    private T myExpected;
    private IReadOnlyList`1<T> myData;
    private Func`3<T, T, bool> myPredicate;
    public SimpleObjectMatcher`1(T expected, IReadOnlyList`1<T> data, Func`3<T, T, bool> predicate);
    public sealed virtual bool Matches(ObjectNumber objectNumber);
}
[UsedImplicitlyAttribute]
public class JetBrains.dotMemory.Model.Queries.SurvivedObjectSetGenerator : ObjectSetGeneratorMixin`1<SurvivedObjectSetGenerator> {
    private SurvivedObjectsOrigin mySurvivedObjectsOrigin;
    private IComparisonDescription myComparisonDescription;
    [CompilerGeneratedAttribute]
private static Func`2<IntersectionNode`1<ObjectNumber>, bool> CS$<>9__CachedAnonymousMethodDelegate5;
    [CompilerGeneratedAttribute]
private static Func`2<IntersectionNode`1<ObjectNumber>, ObjectNumber> CS$<>9__CachedAnonymousMethodDelegate6;
    public SurvivedObjectSetGenerator(SurvivedObjectsOrigin survivedObjectsOrigin, IComparisonDescription comparisonDescription);
    public sealed virtual IEnumerable`1<ObjectNumber> GetObjectSet(IObjectSetReference superSetReference, IExecutionController executionController);
    protected virtual bool EqualsTo(SurvivedObjectSetGenerator other);
    public sealed virtual IPersistentFactory`1<IObjectSetGenerator> GetPersistentFactory();
    [CompilerGeneratedAttribute]
private static bool <GetObjectSet>b__3(IntersectionNode`1<ObjectNumber> _);
    [CompilerGeneratedAttribute]
private static ObjectNumber <GetObjectSet>b__4(IntersectionNode`1<ObjectNumber> _);
}
[UsedImplicitlyAttribute]
public class JetBrains.dotMemory.Model.Queries.TypeIdProperty : EquatableObjectProperty`2<TypeId, IObjectTypeCollection> {
    public TypeIdProperty(IEntityReference`1<IObjectTypeCollection> dataReference, IFactory factory);
    public sealed virtual IQueryClause BelongsTo(IEnumerable`1<TypeId> collection);
    public sealed virtual IQueryClause NotBelongsTo(IEnumerable`1<TypeId> collection);
}
[UsedImplicitlyAttribute]
public class JetBrains.dotMemory.Model.Realtime.DroppedRealtimeSnapshotFilter : object {
    [CompilerGeneratedAttribute]
private IReadonlyCollectionEvents`1<IRealtimeChartSnapshotMark> <SnapshotMarks>k__BackingField;
    [CompilerGeneratedAttribute]
private static Func`2<IRealtimeChartSnapshotMark, IRealtimeChartSnapshotMark> CS$<>9__CachedAnonymousMethodDelegate2;
    public IReadonlyCollectionEvents`1<IRealtimeChartSnapshotMark> SnapshotMarks { get; private set; }
    public DroppedRealtimeSnapshotFilter(IRealtimeChartSnapshotsData storage, IProfilingSessionDescriptor profilingSessionDescriptor, Lifetime lifetime);
    [CompilerGeneratedAttribute]
public sealed virtual IReadonlyCollectionEvents`1<IRealtimeChartSnapshotMark> get_SnapshotMarks();
    [CompilerGeneratedAttribute]
private void set_SnapshotMarks(IReadonlyCollectionEvents`1<IRealtimeChartSnapshotMark> value);
    private static bool ProfilingSesssionContainsSnapshot(IProfilingSessionDescriptor profilingSessionDescriptor, SnapshotId snapshotId);
    [CompilerGeneratedAttribute]
private static IRealtimeChartSnapshotMark <.ctor>b__0(IRealtimeChartSnapshotMark _);
}
[UsedImplicitlyAttribute]
public class JetBrains.dotMemory.Model.Realtime.RealtimeStateNotifier : object {
    private IDataProvider`1<PerformanceCountersState> myState;
    [CompilerGeneratedAttribute]
private static Func`2<AsyncPerformanceCountersStateNotifier, IDataProvider`1<PerformanceCountersState>> CS$<>9__CachedAnonymousMethodDelegate2;
    public IDataProvider`1<PerformanceCountersState> State { get; }
    public RealtimeStateNotifier(Lifetime lifetime, ProcessType processType, IDotNetMemoryPerformanceCountersFactory dotNetMemoryFactory, IProcessPerformanceCountersFactory processFactory, IProfilingSessionDescriptor profilingSessionDescriptor, IThreading threading);
    public IDataProvider`1<PerformanceCountersState> get_State();
    [CompilerGeneratedAttribute]
private static IDataProvider`1<PerformanceCountersState> <.ctor>b__1(AsyncPerformanceCountersStateNotifier _);
}
[UsedImplicitlyAttribute]
internal class JetBrains.dotMemory.Model.RootService : object {
    private IObjectRootReferencesCollection myRootReferencesCollection;
    private IGraphRootCollection myGraphRootCollection;
    private IStaticReferencesCollection myStaticReferencesCollection;
    public RootService(IObjectRootReferencesCollection rootReferencesCollection, IGraphRootCollection graphRootCollection, IStaticReferencesCollection staticReferencesCollection);
    public sealed virtual bool IsRoot(ObjectNumber objectNumber);
    public sealed virtual IReadOnlyCollection`1<IGraphRoot> GetRootReferences(ObjectNumber objectNumber);
    public sealed virtual IStaticReference GetStaticReferenceFrom(IGraphRoot staticGraphRoot);
}
[UsedImplicitlyAttribute]
public class JetBrains.dotMemory.Model.Services.Allocations.AllocationCallstackService : object {
    private IEntityReference`1<IObjectSizeCollection> mySizesExtractor;
    private ICallTreeForestShort myShortCallTreeForest;
    [CompilerGeneratedAttribute]
private static Func`2<MetadataId, MethodId> CS$<>9__CachedAnonymousMethodDelegate1;
    [CompilerGeneratedAttribute]
private static Func`3<Nullable`1<MethodId>, bool, ObjectsByAllocationRootGroup> CS$<>9__CachedAnonymousMethodDelegate4;
    [CompilerGeneratedAttribute]
private static Func`1<MethodIdToObjectsByAllocationRootGroupMap> CS$<>9__CachedAnonymousMethodDelegate5;
    public AllocationCallstackService(IEntityReference`1<IObjectSizeCollection> sizesExtractor, ICallTreeForestShort shortCallTreeForest);
    public sealed virtual IEnumerable`1<MethodId> GetCallstack(IAllocationPoint allocationPoint, IExecutionController executionController);
    public sealed virtual IReadOnlyCollection`1<IObjectsByAllocationRootGroup> AggregateObjectsByAllocationRoot(IEnumerable`1<IAllocationPoint> allocationPoints, IExecutionController executionController);
    private IEnumerable`1<TGroup> AggregateByAllocationRoot(IEnumerable`1<IAllocationPoint> allocationPoints, Func`1<TMethodIdToGroupMap> createMethodIdToGroupMap, Func`3<Nullable`1<MethodId>, bool, TGroup> createGroup, IExecutionController executionController);
    private IEntityReference`1<ICallTree> GetCallTreeReference(ISnapshot snapshot, int callTreeNumber);
    private ICallTree GetLazyCallTree(ISnapshot snapshot, int callTreeNumber, Lifetime lifetime);
    [CompilerGeneratedAttribute]
private static MethodId <GetCallstack>b__0(MetadataId mid);
    [CompilerGeneratedAttribute]
private static ObjectsByAllocationRootGroup <AggregateObjectsByAllocationRoot>b__2(Nullable`1<MethodId> fid, bool isSkipped);
    [CompilerGeneratedAttribute]
private static MethodIdToObjectsByAllocationRootGroupMap <AggregateObjectsByAllocationRoot>b__3();
}
[UsedImplicitlyAttribute]
public class JetBrains.dotMemory.Model.Services.Allocations.AllocationInfoAggregator : object {
    private IAllocationPointsService myAllocationPointsService;
    private IEntityReference`1<IObjectSizeCollection> mySizeReference;
    private IFuidToMetadataIdConverter myFuidToMetadataIdConverter;
    [CompilerGeneratedAttribute]
private static Func`1<AllocationsInfoLinksBag`1<BactraceTreeLink>> CS$<>9__CachedAnonymousMethodDelegate2;
    [CompilerGeneratedAttribute]
private static Func`2<KeyValuePair`2<MetadataId, AllocationsInfoLinksBag`1<BactraceTreeLink>>, FunctionStatistics`1<BactraceTreeLink>> CS$<>9__CachedAnonymousMethodDelegate9;
    public AllocationInfoAggregator(IAllocationPointsService allocationPointsService, IEntityReference`1<IObjectSizeCollection> sizeReference, IFuidToMetadataIdConverter fuidToMetadataIdConverter);
    public sealed virtual FunctionAggregate`1<BactraceTreeLink> Aggregate(ISnapshotScope snapshotScope, IReadOnlyCollection`1<ObjectNumber> objectNumbers, IExecutionController executionController);
    public sealed virtual FunctionAggregate`1<BactraceTreeLink> Aggregate(IReadOnlyCollection`1<IAllocationPoint> allocationPoints, IExecutionController executionController);
    private static BactraceTreeLink NewBactraceTreeLink(IAllocationPoint allocationPoint, ulong objectSize);
    private static IReadOnlyCollection`1<FunctionStatistics`1<BactraceTreeLink>> ToFunctionGroups(IDictionary`2<MetadataId, AllocationsInfoLinksBag`1<BactraceTreeLink>> aggregationMap);
    [CompilerGeneratedAttribute]
private static AllocationsInfoLinksBag`1<BactraceTreeLink> <Aggregate>b__0();
    [CompilerGeneratedAttribute]
private static FunctionStatistics`1<BactraceTreeLink> <ToFunctionGroups>b__8(KeyValuePair`2<MetadataId, AllocationsInfoLinksBag`1<BactraceTreeLink>> pair);
}
public class JetBrains.dotMemory.Model.Services.Allocations.AllocationPoint : object {
    [CompilerGeneratedAttribute]
private ObjectNumber <ObjectNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <CallTreeNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <CallTreeNodePtr>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Fuid>k__BackingField;
    [CompilerGeneratedAttribute]
private ISnapshot <Snapshot>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPreviousToProfilation>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsSkippedAllocation>k__BackingField;
    public ObjectNumber ObjectNumber { get; private set; }
    public UInt32 CallTreeNumber { get; private set; }
    public UInt32 CallTreeNodePtr { get; private set; }
    public UInt32 Fuid { get; private set; }
    public ISnapshot Snapshot { get; private set; }
    public bool IsPreviousToProfilation { get; private set; }
    public bool IsSkippedAllocation { get; private set; }
    public AllocationPoint(UInt32 callTreeNumber, UInt32 callTreeNodePtr, UInt32 fuid, ISnapshot snapshot, ObjectNumber objectNumber, bool isPreviousToProfilation, bool isSkipped);
    [CompilerGeneratedAttribute]
public sealed virtual ObjectNumber get_ObjectNumber();
    [CompilerGeneratedAttribute]
private void set_ObjectNumber(ObjectNumber value);
    [CompilerGeneratedAttribute]
public sealed virtual UInt32 get_CallTreeNumber();
    [CompilerGeneratedAttribute]
private void set_CallTreeNumber(UInt32 value);
    [CompilerGeneratedAttribute]
public sealed virtual UInt32 get_CallTreeNodePtr();
    [CompilerGeneratedAttribute]
private void set_CallTreeNodePtr(UInt32 value);
    [CompilerGeneratedAttribute]
public sealed virtual UInt32 get_Fuid();
    [CompilerGeneratedAttribute]
private void set_Fuid(UInt32 value);
    [CompilerGeneratedAttribute]
public sealed virtual ISnapshot get_Snapshot();
    [CompilerGeneratedAttribute]
private void set_Snapshot(ISnapshot value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsPreviousToProfilation();
    [CompilerGeneratedAttribute]
private void set_IsPreviousToProfilation(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsSkippedAllocation();
    [CompilerGeneratedAttribute]
private void set_IsSkippedAllocation(bool value);
    public static IAllocationPoint PreviousToProfilation(ObjectNumber objectNumber);
    public static IAllocationPoint SkippedAllocation(ObjectNumber objectNumber);
}
[UsedImplicitlyAttribute]
public class JetBrains.dotMemory.Model.Services.Allocations.AllocationPointsService : object {
    private IReadOnlyList`1<ISnapshot> mySnapshots;
    private ISnapshotServiceLocator mySnapshotServiceLocator;
    private ICuttedSessionDetector myCuttedSessionDetector;
    [CompilerGeneratedAttribute]
private static Func`2<FinalizedObject, Allocation> CS$<>9__CachedAnonymousMethodDelegate7;
    [CompilerGeneratedAttribute]
private static Func`2<Allocation, GCNumber> CS$<>9__CachedAnonymousMethodDelegatea;
    public AllocationPointsService(IReadOnlyList`1<ISnapshot> snapshots, ISnapshotServiceLocator snapshotServiceLocator, ICuttedSessionDetector cuttedSessionDetector);
    [NotNullAttribute]
public sealed virtual IReadOnlyCollection`1<IAllocationPoint> GetAllocationPoints(ISnapshotScope snapshotScope, IObjectSetReference objectSetReference, IExecutionController executionController);
    [NotNullAttribute]
public sealed virtual IReadOnlyCollection`1<IAllocationPoint> GetAllocationPoints(ISnapshotScope snapshotScope, IReadOnlyCollection`1<ObjectNumber> objectNumbers, IExecutionController executionController);
    [NotNullAttribute]
public sealed virtual IReadOnlyCollection`1<IAllocationPoint> GetAllocationPoints(ISnapshotScope snapshotScope, IReadOnlyCollection`1<FinalizedObject> finalizedObjects, IExecutionController executionController);
    private IEnumerable`1<IAllocationPoint> GetAllocationPoints(ISnapshotScope snapshotScope, IEnumerable`1<Allocation> objectAllocations, IExecutionController progressIndicator);
    [CompilerGeneratedAttribute]
private static Allocation <GetAllocationPoints>b__6(FinalizedObject x);
    [CompilerGeneratedAttribute]
private static GCNumber <GetAllocationPoints>b__8(Allocation x);
}
public class JetBrains.dotMemory.Model.Services.Allocations.AllocationRootGroup : object {
    private bool myIsSkipped;
    [CompilerGeneratedAttribute]
private Nullable`1<MethodId> <FunctionId>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <TotalAllocatedObjectsCount>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <TotalAllocatedObjectsSize>k__BackingField;
    public bool IsPreviousToProfilation { get; }
    public bool IsSkipped { get; }
    public Nullable`1<MethodId> FunctionId { get; private set; }
    public ulong TotalAllocatedObjectsCount { get; private set; }
    public ulong TotalAllocatedObjectsSize { get; private set; }
    public AllocationRootGroup(Nullable`1<MethodId> function, bool isSkipped);
    public sealed virtual bool get_IsPreviousToProfilation();
    public sealed virtual bool get_IsSkipped();
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<MethodId> get_FunctionId();
    [CompilerGeneratedAttribute]
private void set_FunctionId(Nullable`1<MethodId> value);
    [CompilerGeneratedAttribute]
public sealed virtual ulong get_TotalAllocatedObjectsCount();
    [CompilerGeneratedAttribute]
private void set_TotalAllocatedObjectsCount(ulong value);
    [CompilerGeneratedAttribute]
public sealed virtual ulong get_TotalAllocatedObjectsSize();
    [CompilerGeneratedAttribute]
private void set_TotalAllocatedObjectsSize(ulong value);
    public sealed virtual void AddObject(ulong size, ObjectNumber number);
}
[UsedImplicitlyAttribute]
public class JetBrains.dotMemory.Model.Services.Allocations.AllocationTreeNodeExpander : object {
    private IObjectToCallTreeNodeLinker myObjectToNodeLinker;
    private IObjectsByCallTreeGrouper myObjectsByCallTreeGrouper;
    private ISnapshotScope mySnapshotScope;
    private ICallTreeForestShort myCallTreeForestShort;
    private IObjectSetReference myObjectSetReference;
    private IEntityReference`1<IObjectSizeCollection> mySizesReference;
    private ICuttedSessionDetector myCuttedSessionDetector;
    private IReadOnlyList`1<ISnapshot> mySnapshots;
    private Func`2<SnapshotId, int> myGetSnapshotSequenceNumber;
    [CompilerGeneratedAttribute]
private static Func`2<ISnapshot, SnapshotId> CS$<>9__CachedAnonymousMethodDelegate3;
    [CompilerGeneratedAttribute]
private static Func`2<ISnapshot, int> CS$<>9__CachedAnonymousMethodDelegate4;
    [CompilerGeneratedAttribute]
private static Func`2<ISnapshot, int> CS$<>9__CachedAnonymousMethodDelegateb;
    public AllocationTreeNodeExpander(IReadOnlyList`1<ISnapshot> snapshots, IObjectToCallTreeNodeLinker objectToNodeLinker, IObjectsByCallTreeGrouper objectsByCallTreeGrouper, ISnapshotScope snapshotScope, ICallTreeForestShort callTreeForestShort, IObjectSetReference objectSetReference, IEntityReference`1<IObjectSizeCollection> sizesReference, ICuttedSessionDetector cuttedSessionDetector);
    public sealed virtual IReadOnlyCollection`1<ITreeNodeStatistics> ExpandNode(ITreeNodeStatistics parent, IExecutionController executionController);
    [CompilerGeneratedAttribute]
private static SnapshotId <.ctor>b__0(ISnapshot _);
    [CompilerGeneratedAttribute]
private static int <.ctor>b__1(ISnapshot _);
    [CompilerGeneratedAttribute]
private static int <ExpandNode>b__9(ISnapshot s);
}
[UsedImplicitlyAttribute]
public class JetBrains.dotMemory.Model.Services.Allocations.BacktraceNodeExpander : object {
    [CompilerGeneratedAttribute]
private static Func`1<AllocationsInfoLinksBag`1<BactraceTreeLink>> CS$<>9__CachedAnonymousMethodDelegate3;
    [CompilerGeneratedAttribute]
private static Func`2<KeyValuePair`2<MetadataId, AllocationsInfoLinksBag`1<BactraceTreeLink>>, FunctionStatistics`1<BactraceTreeLink>> CS$<>9__CachedAnonymousMethodDelegate4;
    public sealed virtual IReadOnlyCollection`1<FunctionStatistics`1<BactraceTreeLink>> Expand(IReadOnlyCollection`1<BactraceTreeLink> nodeLinks, ICallTreeForestLong callTreeForestLong, IExecutionController executionController);
    public sealed virtual bool HasChildren(IReadOnlyCollection`1<BactraceTreeLink> nodeLinks, ICallTreeForestLong forestLong);
    [CompilerGeneratedAttribute]
private static AllocationsInfoLinksBag`1<BactraceTreeLink> <Expand>b__0();
    [CompilerGeneratedAttribute]
private static FunctionStatistics`1<BactraceTreeLink> <Expand>b__2(KeyValuePair`2<MetadataId, AllocationsInfoLinksBag`1<BactraceTreeLink>> pair);
}
[UsedImplicitlyAttribute]
public class JetBrains.dotMemory.Model.Services.Allocations.CallTreeForestLong : object {
    private IEnumerable`1<ISnapshotScope> mySnapshotScopes;
    private Lifetime myLifetime;
    private Dictionary`2<SnapshotId, Dictionary`2<UInt32, ICallTree>> myCallTreesMap;
    [CompilerGeneratedAttribute]
private static Func`1<Dictionary`2<UInt32, ICallTree>> CS$<>9__CachedAnonymousMethodDelegate5;
    public CallTreeForestLong(Lifetime lifetime, IReadonlyCollectionEvents`1<ISnapshotScope> snapshotScopes);
    public sealed virtual ICallTree GetCallTree(SnapshotId snapshotId, UInt32 callTreeNumber);
    [CompilerGeneratedAttribute]
private void <.ctor>b__0();
    [CompilerGeneratedAttribute]
private static Dictionary`2<UInt32, ICallTree> <GetCallTree>b__2();
}
[UsedImplicitlyAttribute]
public class JetBrains.dotMemory.Model.Services.Allocations.CallTreeForestShort : object {
    private IEnumerable`1<ISnapshotScope> mySnapshotScopes;
    public CallTreeForestShort(IReadonlyCollectionEvents`1<ISnapshotScope> snapshotScopes);
    public sealed virtual IEntityReference`1<ICallTree> GetCallTreeReference(SnapshotId snapshotId, int callTreeNumber);
    public sealed virtual ICallTree GetCallTree(SnapshotId snapshotId, int callTreeNumber, Lifetime lifetime);
    public sealed virtual IReadOnlyList`1<FuidToCallPointIndex> GetCallPointIndices(SnapshotId snapshotId, int callTreeNumber, IExecutionController controller);
    public sealed virtual IFuidCallPointsExtractor GetFuidCallPointsExtractor(SnapshotId snapshotId, int callTreeNunmer);
    private ISnapshotScope GetSnapshotScope(SnapshotId snapshotId);
}
[UsedImplicitlyAttribute]
public class JetBrains.dotMemory.Model.Services.Allocations.CallTreeProvider : object {
    private IFactory myFactory;
    private int myCallTreeCount;
    public int CallTreeCount { get; }
    public CallTreeProvider(IFactory factory, int callTreeCount);
    public sealed virtual int get_CallTreeCount();
    public sealed virtual ICallTree GetCallTree(int callTreeIndex, Lifetime lifetime);
    public sealed virtual IEntityReference`1<ICallTree> GetCallTreeReference(int callTreeIndex);
}
public interface JetBrains.dotMemory.Model.Services.Allocations.IChangebleAllocationRootGroup {
    public abstract virtual void AddObject(ulong size, ObjectNumber number);
}
public class JetBrains.dotMemory.Model.Services.Allocations.ObjectsByAllocationRootGroup : object {
    private bool myIsSkipped;
    private HashSet`1<ObjectNumber> myAllocatedObjects;
    [CompilerGeneratedAttribute]
private Nullable`1<MethodId> <FunctionId>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <TotalAllocatedObjectsSize>k__BackingField;
    public Nullable`1<MethodId> FunctionId { get; private set; }
    public IEnumerable`1<ObjectNumber> AllocatedObjects { get; }
    public ulong TotalAllocatedObjectsCount { get; }
    public ulong TotalAllocatedObjectsSize { get; private set; }
    public bool IsPreviousToProfilation { get; }
    public bool IsSkipped { get; }
    public ObjectsByAllocationRootGroup(Nullable`1<MethodId> functionId, bool isSkipped);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<MethodId> get_FunctionId();
    [CompilerGeneratedAttribute]
private void set_FunctionId(Nullable`1<MethodId> value);
    public sealed virtual IEnumerable`1<ObjectNumber> get_AllocatedObjects();
    public sealed virtual ulong get_TotalAllocatedObjectsCount();
    [CompilerGeneratedAttribute]
public sealed virtual ulong get_TotalAllocatedObjectsSize();
    [CompilerGeneratedAttribute]
private void set_TotalAllocatedObjectsSize(ulong value);
    public sealed virtual bool get_IsPreviousToProfilation();
    public sealed virtual bool get_IsSkipped();
    public sealed virtual void AddObject(ulong size, ObjectNumber number);
}
public class JetBrains.dotMemory.Model.Services.Allocations.ObjectsByCallTreeGroup : object {
    private SnapshotId mySnapshotId;
    private ChunkList`1<ObjectNumberCallTreeEntranceTime> myCallTreeEntranceTimes;
    [CompilerGeneratedAttribute]
private UInt32 <CallTreeNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private static Comparison`1<ObjectNumberCallTreeEntranceTime> CS$<>9__CachedAnonymousMethodDelegate1;
    public UInt32 CallTreeNumber { get; private set; }
    public SnapshotId SnapshotId { get; }
    public IReadOnlyList`1<ObjectNumberCallTreeEntranceTime> Group { get; }
    public ObjectsByCallTreeGroup(SnapshotId snapshotId, UInt32 callTreeNumber);
    [CompilerGeneratedAttribute]
public sealed virtual UInt32 get_CallTreeNumber();
    [CompilerGeneratedAttribute]
private void set_CallTreeNumber(UInt32 value);
    public sealed virtual SnapshotId get_SnapshotId();
    public sealed virtual IReadOnlyList`1<ObjectNumberCallTreeEntranceTime> get_Group();
    public void AddEntranceTime(ObjectNumberCallTreeEntranceTime entranceTime);
    public void SortByTime();
    [CompilerGeneratedAttribute]
private static int <SortByTime>b__0(ObjectNumberCallTreeEntranceTime l, ObjectNumberCallTreeEntranceTime r);
}
[UsedImplicitlyAttribute]
public class JetBrains.dotMemory.Model.Services.Allocations.ObjectsByCallTreeGrouper : object {
    private IAllocationPointsService myAllocationPointsService;
    private ICallTreeForestShort myCallTreeForestShort;
    public ObjectsByCallTreeGrouper(IAllocationPointsService allocationPointsService, ICallTreeForestShort callTreeForestShort);
    public sealed virtual IReadOnlyCollection`1<IObjectsByCallTreeGroup> Group(ISnapshotScope snapshotScope, IObjectSetReference objectSetReference, IExecutionController executionController);
}
[UsedImplicitlyAttribute]
public class JetBrains.dotMemory.Model.Services.Allocations.ObjectsByCallTreeGrouperDiskCache : object {
    private static string StorageKeyTemplate;
    private static Version DataFormatVersion;
    private ObjectSetId mySetId;
    private IObjectsByCallTreeGrouper myGroupService;
    private IProbingScopeCacheDataStorage myDataStorage;
    public ObjectsByCallTreeGrouperDiskCache(ObjectSetId setId, IObjectsByCallTreeGrouper groupService, IProbingScopeCacheDataStorage dataStorage);
    private static ObjectsByCallTreeGrouperDiskCache();
    public sealed virtual IReadOnlyCollection`1<IObjectsByCallTreeGroup> Group(ISnapshotScope snapshotScope, IObjectSetReference objectSetReference, IExecutionController executionController);
    private static void WriteData(IReadOnlyCollection`1<IObjectsByCallTreeGroup> groups, BinaryWriter writer, IExecutionController writeController);
    private static IReadOnlyCollection`1<IObjectsByCallTreeGroup> ReadData(BinaryReader reader, IExecutionController readController);
    private string GetStorageKey();
}
[UsedImplicitlyAttribute]
public class JetBrains.dotMemory.Model.Services.Allocations.ObjectsByCallTreeGrouperMemoryCache : object {
    private IObjectsByCallTreeGrouper myGroupService;
    private TimeSpan myHoldInMemoryPeriod;
    private Lifetime myLifetime;
    private object myCacheAccess;
    private IEntityReference`1 modreq(System.Runtime.CompilerServices.IsVolatile) myGroupsCache;
    public ObjectsByCallTreeGrouperMemoryCache(IObjectsByCallTreeGrouper groupService, TimeSpan holdInMemoryPeriod, Lifetime lifetime);
    public sealed virtual IReadOnlyCollection`1<IObjectsByCallTreeGroup> Group(ISnapshotScope snapshotScope, IObjectSetReference objectSetReference, IExecutionController executionController);
}
[UsedImplicitlyAttribute]
public class JetBrains.dotMemory.Model.Services.Allocations.ObjectToCallTreeNodeLinker : object {
    public sealed virtual void LinkObjectsToNode(IObjectsByCallTreeGroup objectGroup, UInt32 nodeEnterTime, UInt32 nodeExitTime, Action`2<bool, ObjectNumber> linkAction);
}
[UsedImplicitlyAttribute]
public class JetBrains.dotMemory.Model.Services.Allocations.TreeFindByNameIndexBuilder : object {
    private IReadOnlyList`1<ISnapshot> mySnapshots;
    private IFuidToMetadataIdConverter myFuidToMetadataIdConverter;
    private ICallTreeForestShort myCallTreeForestShort;
    [CompilerGeneratedAttribute]
private static Func`2<ObjectNumberCallTreeEntranceTime, UInt32> CS$<>9__CachedAnonymousMethodDelegate3;
    [CompilerGeneratedAttribute]
private static Func`1<ChunkList`1<ITreeFindByNameIndexEntryData>> CS$<>9__CachedAnonymousMethodDelegate4;
    public TreeFindByNameIndexBuilder(IReadOnlyList`1<ISnapshot> snapshots, IFuidToMetadataIdConverter fuidToMetadataIdConverter, ICallTreeForestShort callTreeForestShort);
    public sealed virtual IReadOnlyCollection`1<ITreeFindByNameIndexEntry> BuildSearchIndex(IReadOnlyCollection`1<IObjectsByCallTreeGroup> objectGroups, IExecutionController executionController);
    private static IEnumerable`1<UInt32> GetFilteredCallPointDfsEnters(UInt32[] objectsEntrancesFilter, IEnumerable`1<FuidCallPoint> fuidCallPoints);
    [CompilerGeneratedAttribute]
private static UInt32 <BuildSearchIndex>b__1(ObjectNumberCallTreeEntranceTime t);
    [CompilerGeneratedAttribute]
private static ChunkList`1<ITreeFindByNameIndexEntryData> <BuildSearchIndex>b__2();
}
[UsedImplicitlyAttribute]
public class JetBrains.dotMemory.Model.Services.Allocations.TreeFindByNameIndexBuilderDiskCache : object {
    private static string StorageKeyTemplate;
    private static Version DataFormatVersion;
    private ObjectSetId mySetId;
    private ITreeFindByNameIndexBuilder myIndexService;
    private IProbingScopeCacheDataStorage myDataStorage;
    public TreeFindByNameIndexBuilderDiskCache(ObjectSetId setId, ITreeFindByNameIndexBuilder indexService, IProbingScopeCacheDataStorage dataStorage);
    private static TreeFindByNameIndexBuilderDiskCache();
    public sealed virtual IReadOnlyCollection`1<ITreeFindByNameIndexEntry> BuildSearchIndex(IReadOnlyCollection`1<IObjectsByCallTreeGroup> objectGroups, IExecutionController executionController);
    private static void WriteData(IReadOnlyCollection`1<ITreeFindByNameIndexEntry> index, BinaryWriter writer, IExecutionController writeController);
    private static IReadOnlyCollection`1<ITreeFindByNameIndexEntry> ReadData(BinaryReader reader, IExecutionController readController);
    private string GetStorageKey();
}
[UsedImplicitlyAttribute]
public class JetBrains.dotMemory.Model.Services.Allocations.TreeFindByNameIndexBuilderMemoryCache : object {
    private ITreeFindByNameIndexBuilder myIndexService;
    private TimeSpan myHoldInMemoryPeriod;
    private Lifetime myLifetime;
    private object myCacheAccess;
    private IEntityReference`1 modreq(System.Runtime.CompilerServices.IsVolatile) myIndexCache;
    public TreeFindByNameIndexBuilderMemoryCache(ITreeFindByNameIndexBuilder indexService, TimeSpan holdInMemoryPeriod, Lifetime lifetime);
    public sealed virtual IReadOnlyCollection`1<ITreeFindByNameIndexEntry> BuildSearchIndex(IReadOnlyCollection`1<IObjectsByCallTreeGroup> objectGroups, IExecutionController executionController);
}
public class JetBrains.dotMemory.Model.Services.Allocations.TreeFindByNameIndexEntry : object {
    [CompilerGeneratedAttribute]
private MethodId <Method>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<ITreeFindByNameIndexEntryData> <Groups>k__BackingField;
    public MethodId Method { get; private set; }
    public IReadOnlyList`1<ITreeFindByNameIndexEntryData> Groups { get; private set; }
    public TreeFindByNameIndexEntry(MethodId method, IReadOnlyList`1<ITreeFindByNameIndexEntryData> groups);
    [CompilerGeneratedAttribute]
public sealed virtual MethodId get_Method();
    [CompilerGeneratedAttribute]
private void set_Method(MethodId value);
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyList`1<ITreeFindByNameIndexEntryData> get_Groups();
    [CompilerGeneratedAttribute]
private void set_Groups(IReadOnlyList`1<ITreeFindByNameIndexEntryData> value);
}
public class JetBrains.dotMemory.Model.Services.Allocations.TreeFindByNameIndexEntryData : object {
    [CompilerGeneratedAttribute]
private SnapshotId <SnapshotId>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <CallTreeNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<UInt32> <DfsEnterTimes>k__BackingField;
    public SnapshotId SnapshotId { get; private set; }
    public UInt32 CallTreeNumber { get; private set; }
    public IReadOnlyList`1<UInt32> DfsEnterTimes { get; private set; }
    public TreeFindByNameIndexEntryData(SnapshotId snapshotId, UInt32 callTreeNumber, IReadOnlyList`1<UInt32> dfsEnterTimes);
    [CompilerGeneratedAttribute]
public sealed virtual SnapshotId get_SnapshotId();
    [CompilerGeneratedAttribute]
private void set_SnapshotId(SnapshotId value);
    [CompilerGeneratedAttribute]
public sealed virtual UInt32 get_CallTreeNumber();
    [CompilerGeneratedAttribute]
private void set_CallTreeNumber(UInt32 value);
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyList`1<UInt32> get_DfsEnterTimes();
    [CompilerGeneratedAttribute]
private void set_DfsEnterTimes(IReadOnlyList`1<UInt32> value);
}
public class JetBrains.dotMemory.Model.Services.Allocations.TreeNodeStatistics : object {
    private static string NoSnapshotLinkExceptionText;
    private static string NoCallTreeLinkExceptionText;
    private int mySnapshotIndexOffset;
    private Func`2<SnapshotId, int> myGetSnapshotSequenceNumber;
    private UInt32 myOwnAllocatedObjectsCount;
    private ulong myOwnAllocatedObjectsSize;
    private UInt32 mySubTreeAllocatedObjectsCount;
    private ulong mySubTreeAllocatedObjectsSize;
    private bool myAllObjectsAllocatedInNode;
    private CallTreeNodeDescription[][] myCallTreePtrsMap;
    private SnapshotId[] mySnapshotIds;
    private PropertyChangedEventHandler PropertyChanged;
    [CompilerGeneratedAttribute]
private MethodId <FunctionId>k__BackingField;
    public UInt32 OwnAllocatedObjectsCount { get; }
    public ulong OwnAllocatedObjectsSize { get; }
    public UInt32 SubTreeAllocatedObjectsCount { get; }
    public ulong SubTreeAllocatedObjectsSize { get; }
    public MethodId FunctionId { get; private set; }
    public bool AllObjectsAllocatedInNode { get; }
    public TreeNodeStatistics(MethodId fid, int snapshotIndexOffset, int snapshotsCount, Func`2<SnapshotId, int> getSnapshotSequenceNumber, Int32[] callTreePerSnapshotCounts);
    public sealed virtual UInt32 get_OwnAllocatedObjectsCount();
    public sealed virtual ulong get_OwnAllocatedObjectsSize();
    public sealed virtual UInt32 get_SubTreeAllocatedObjectsCount();
    public sealed virtual ulong get_SubTreeAllocatedObjectsSize();
    [CompilerGeneratedAttribute]
public sealed virtual MethodId get_FunctionId();
    [CompilerGeneratedAttribute]
private void set_FunctionId(MethodId value);
    public sealed virtual UInt32 GetCallTreePtr(SnapshotId snapshotId, UInt32 callTreeNumber);
    public sealed virtual bool ContainsLinkToCallTree(SnapshotId snapshotId, UInt32 callTreeNumber);
    public sealed virtual bool get_AllObjectsAllocatedInNode();
    public sealed virtual IEnumerable`1<DfsInfoLink> GetCallTreeLinks();
    public void AddObject(ulong objectSize, bool isOwn, SnapshotId snapshotId, UInt32 callTreeNumber, UInt32 nodeEnterTime, UInt32 nodeExitTime, UInt32 nodePtr);
    public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
}
[UsedImplicitlyAttribute]
public class JetBrains.dotMemory.Model.Services.SnapshotServiceLocator : object {
    private IEnumerable`1<ISnapshotScope> mySnapshotScopes;
    public SnapshotServiceLocator(IReadonlyCollectionEvents`1<ISnapshotScope> snapshotScopes);
    public sealed virtual T Get(ISnapshot snapshot, Lifetime lt);
    private ISnapshotScope GetSnapshotScope(SnapshotId snapshotId);
}
[UsedImplicitlyAttribute]
public class JetBrains.dotMemory.Model.ShortestPairsFinder : object {
    private IDirectGraph myDirectGraph;
    private IReverseGraph myReverseGraph;
    private IReadOnlyList`1<int> myDirectToReverseReferenceMap;
    private IReadOnlyList`1<ObjectNumber> myRoots;
    private BfsData myBfsData;
    private DfsData myDfsData;
    private Graph myTreeGraph;
    private ChunkArray`1<bool> myProcessedVertices;
    private ChunkArray`1<int> myIncidentIndex;
    private ChunkArray`1<int> myIncidentsCount;
    private ChunkArray`1<Reference> myIncedent;
    private BinaryHeap`1<Pair`2<int, ObjectNumber>> myHeap;
    private ChunkArray`1<int> myDistance;
    private ChunkArray`1<GraphReferenceId> myP;
    private ChunkArray`1<ObjectNumber> myQ;
    private ChunkArray`1<ObjectNumber> myDominator;
    [CompilerGeneratedAttribute]
private static Comparison`1<Pair`2<int, ObjectNumber>> CS$<>9__CachedAnonymousMethodDelegate1;
    private IDominatorTreeParentCollection Dominators { get; }
    public ShortestPairsFinder(IDirectGraph directGraph, IReverseGraph reverseGraph, IReadOnlyList`1<int> directToReverseReferenceMap, IReadOnlyList`1<ObjectNumber> roots);
    private IDominatorTreeParentCollection get_Dominators();
    public sealed virtual ShortestPairsFinderResult FindAllPairs(IExecutionController executionController);
    private void InitIncedents();
    private void ProcessDestination(ObjectNumber destination, IEnumerable`1<ObjectNumber> destinationChildren);
    private void ProcessSubTree(ObjectNumber subTreeRoot, ObjectNumber qVertex, int distance);
    private void CheckDistance(Reference reference, int fromVertex, ObjectNumber qVertex, int distance);
    [CompilerGeneratedAttribute]
private static int <.ctor>b__0(Pair`2<int, ObjectNumber> l, Pair`2<int, ObjectNumber> r);
    [CompilerGeneratedAttribute]
private bool <FindAllPairs>b__2(ObjectNumber _);
}
public class JetBrains.dotMemory.Model.ShortestPairsHashCalculator : object {
    public static UInt32 ObjectSelfWeight;
    public sealed virtual IReadOnlyList`1<UInt32> CalculateHashes(ShortestPairsFinderResult shortestPairsFinderResult, IReadOnlyList`1<UInt32> bfsRollingHash, IDfsData dfsData);
}
[UsedImplicitlyAttribute]
public class JetBrains.dotMemory.Model.SnapshotByTrigger.SnapshotByTriggerPipelineBuilder : object {
    private static int Mb;
    private static int TimerTriggerDefaultMinutesInterval;
    private static int MemoryAbsoluteDefaultValue;
    private static int MemoryPercentageDefaultValue;
    private static int DefaultSnapshotsLimit;
    public ICommandContainer ChangeActiveStateCommand;
    public IDataNotifier`1<SnapshotByTriggerState> SnapshotByTriggerState;
    public IWriteableDataNotifier`1<bool> IsSnapshotsLimitIsEnabled;
    public IWriteableDataNotifier`1<int> SnapshotsLimit;
    public IntValueBasedTriggerPipes TimerTriggerParameters;
    public IntValueBasedTriggerPipes MemoryAbsoluteIncreaseTriggerParameters;
    public IntValueBasedTriggerPipes MemoryPercentageIncreaseTriggerParameters;
    public IDataNotifier`1<bool> IsTotalMemoryValueAvaliableProvider;
    [CompilerGeneratedAttribute]
private static Func`3<bool, bool, SnapshotByTriggerState> CS$<>9__CachedAnonymousMethodDelegate6;
    [CompilerGeneratedAttribute]
private static Func`2<int, string> CS$<>9__CachedAnonymousMethodDelegate8;
    [CompilerGeneratedAttribute]
private static Func`2<bool, bool> CS$<>9__CachedAnonymousMethodDelegateb;
    [CompilerGeneratedAttribute]
private static Func`3<int, int, bool> CS$<>9__CachedAnonymousMethodDelegatef;
    [CompilerGeneratedAttribute]
private static Func`2<int, bool> CS$<>9__CachedAnonymousMethodDelegate15;
    [CompilerGeneratedAttribute]
private static Func`2<IntValueBasedTriggerPipes, IDataProvider`1<bool>> CS$<>9__CachedAnonymousMethodDelegate16;
    [CompilerGeneratedAttribute]
private static Func`2<IntValueBasedTriggerPipes, IDataProvider`1<bool>> CS$<>9__CachedAnonymousMethodDelegate17;
    [CompilerGeneratedAttribute]
private static Predicate`1<int> CS$<>9__CachedAnonymousMethodDelegate20;
    [CompilerGeneratedAttribute]
private static Func`2<bool, bool> CS$<>9__CachedAnonymousMethodDelegate21;
    [CompilerGeneratedAttribute]
private static Func`2<int, bool> CS$<>9__CachedAnonymousMethodDelegate22;
    [CompilerGeneratedAttribute]
private static Predicate`1<int> CS$<>9__CachedAnonymousMethodDelegate2f;
    [CompilerGeneratedAttribute]
private static Func`2<bool, bool> CS$<>9__CachedAnonymousMethodDelegate30;
    [CompilerGeneratedAttribute]
private static Func`3<int, int, bool> CS$<>9__CachedAnonymousMethodDelegate31;
    [CompilerGeneratedAttribute]
private static Func`2<int, int> CS$<>9__CachedAnonymousMethodDelegate32;
    [CompilerGeneratedAttribute]
private static Func`3<int, int, bool> CS$<>9__CachedAnonymousMethodDelegate33;
    [CompilerGeneratedAttribute]
private static Func`3<int, int, bool> CS$<>9__CachedAnonymousMethodDelegate34;
    [CompilerGeneratedAttribute]
private static Func`2<int, bool> CS$<>9__CachedAnonymousMethodDelegate35;
    [CompilerGeneratedAttribute]
private static Predicate`1<int> CS$<>9__CachedAnonymousMethodDelegate3f;
    [CompilerGeneratedAttribute]
private static Func`2<bool, bool> CS$<>9__CachedAnonymousMethodDelegate40;
    [CompilerGeneratedAttribute]
private static Func`3<Pair`2<int, int>, int, bool> CS$<>9__CachedAnonymousMethodDelegate41;
    [CompilerGeneratedAttribute]
private static Func`2<int, bool> CS$<>9__CachedAnonymousMethodDelegate42;
    public SnapshotByTriggerPipelineBuilder(IDataProvider`1<int> totalMemoryValueProvider, IDataProvider`1<bool> isTotalMemoryValueAvaliableProvider, IProfilingSessionCommands profilingSessionCommands, IProfilingSessionDescriptor profilingSessionDescriptor);
    private static IDataNotifier`1<SnapshotByTriggerState> CreateSnapshotsByTriggerState(IDataProvider`1<bool> isProfilingSessionActive, IDataProvider`1<bool> isStartedProvider, IDataProvider`1<bool> isSnapshotByTriggerActive);
    private static IWriteableDataNotifier`1<int> CreateSnapshotsLimitPipeout(IDataProvider`1<bool> isProfilingSessionActive, IDataController`1<int> snapshotsLimitProvider);
    private static IDataProvider`1<bool> CreateIsSnapshotByTriggerActiveProvider(IDataProvider`1<bool> isStartedProvider, IDataProvider`1<bool> limitIsReachedProvider);
    private static void CreateResetSnaphsotsCountSubscription(IDataProvider`1<bool> isProfilingSessionActive, IDataProvider`1<bool> isStartedProvider, IDataController`1<int> snaphsotsCountTakenByTrigger);
    private static IDataProvider`1<bool> CreateSnapshotCountLimitIsReachedProvider(IDataProvider`1<bool> isSnapshotsCountLimitedProvider, IDataProvider`1<int> snapshotsLimitProvider, IDataProvider`1<int> snaphsotsCountTakenByTrigger);
    private static ICommandContainer CreateChangeActiveCommand(IDataController`1<bool> isStartedInput, IDataProvider`1<bool> isSnapshotsCountLimitedProvider, IDataProvider`1<int> snapshotsLimitProvider, IntValueBasedTriggerPipes[] triggerPipes);
    private static IntValueBasedTriggerPipes CreateTimerTriggerPipes(IDataProvider`1<bool> isProfilingSessionActive, IDataProvider`1<bool> isSnapshotByTriggerActive, Action takeSnapshot);
    private static IntValueBasedTriggerPipes CreateMemoryAbsoluteIncreaseTriggerPipes(IDataProvider`1<bool> isProfilingSessionActive, IDataProvider`1<bool> isSnapshotByTriggerActive, IDataProvider`1<int> totalMemoryValueProvider, Action takeSnapshot);
    private static IntValueBasedTriggerPipes CreateMemoryPercentageIncreaseTriggerPipes(IDataProvider`1<bool> isProfilingSessionActive, IDataProvider`1<bool> isSnapshotByTriggerActive, IDataProvider`1<int> totalMemoryValueProvider, Action takeSnapshot);
    private static void TakeSnapshot(IProfilingSessionCommands profilingSessionCommands, IDataController`1<int> snaphsotsCountTakenByTriggerInput);
    [CompilerGeneratedAttribute]
private static SnapshotByTriggerState <CreateSnapshotsByTriggerState>b__5(bool isStarted, bool isWorking);
    [CompilerGeneratedAttribute]
private static string <CreateSnapshotsLimitPipeout>b__7(int value);
    [CompilerGeneratedAttribute]
private static bool <CreateResetSnaphsotsCountSubscription>b__9(bool isStarted);
    [CompilerGeneratedAttribute]
private static bool <CreateSnapshotCountLimitIsReachedProvider>b__e(int snapshotsCount, int limit);
    [CompilerGeneratedAttribute]
private static bool <CreateChangeActiveCommand>b__10(int count);
    [CompilerGeneratedAttribute]
private static IDataProvider`1<bool> <CreateChangeActiveCommand>b__11(IntValueBasedTriggerPipes _);
    [CompilerGeneratedAttribute]
private static IDataProvider`1<bool> <CreateChangeActiveCommand>b__12(IntValueBasedTriggerPipes _);
    [CompilerGeneratedAttribute]
private static bool <CreateTimerTriggerPipes>b__1a(int value);
    [CompilerGeneratedAttribute]
private static bool <CreateTimerTriggerPipes>b__1c(bool isWorking);
    [CompilerGeneratedAttribute]
private static bool <CreateTimerTriggerPipes>b__1e(int value);
    [CompilerGeneratedAttribute]
private static bool <CreateMemoryAbsoluteIncreaseTriggerPipes>b__25(int value);
    [CompilerGeneratedAttribute]
private static bool <CreateMemoryAbsoluteIncreaseTriggerPipes>b__26(bool isWorking);
    [CompilerGeneratedAttribute]
private static bool <CreateMemoryAbsoluteIncreaseTriggerPipes>b__28(int currentValue, int _);
    [CompilerGeneratedAttribute]
private static int <CreateMemoryAbsoluteIncreaseTriggerPipes>b__2a(int memoryInMb);
    [CompilerGeneratedAttribute]
private static bool <CreateMemoryAbsoluteIncreaseTriggerPipes>b__2b(int diff, int _);
    [CompilerGeneratedAttribute]
private static bool <CreateMemoryAbsoluteIncreaseTriggerPipes>b__2c(int diff, int trigger);
    [CompilerGeneratedAttribute]
private static bool <CreateMemoryAbsoluteIncreaseTriggerPipes>b__2d(int currentValue);
    [CompilerGeneratedAttribute]
private static bool <CreateMemoryPercentageIncreaseTriggerPipes>b__38(int value);
    [CompilerGeneratedAttribute]
private static bool <CreateMemoryPercentageIncreaseTriggerPipes>b__39(bool isWorking);
    [CompilerGeneratedAttribute]
private static bool <CreateMemoryPercentageIncreaseTriggerPipes>b__3b(Pair`2<int, int> pair, int _);
    [CompilerGeneratedAttribute]
private static bool <CreateMemoryPercentageIncreaseTriggerPipes>b__3d(int currentValue);
}
[UsedImplicitlyAttribute]
public class JetBrains.dotMemory.Model.Snapshots.Snapshot : object {
    private SnapshotId mySnapshotId;
    private ISnapshotScope mySnapshotScope;
    private int mySnapshotSequenceNumber;
    private DateTime mySnapshotTakenTime;
    private string mySnapshotIndexFile;
    private bool myIsAllocationCollected;
    private bool myIsTrafficCollected;
    private bool myIsFinalizerCollected;
    private int myObjectsCount;
    private ulong myTotalSize;
    [CompilerGeneratedAttribute]
private int <CallTreeCount>k__BackingField;
    [CompilerGeneratedAttribute]
private GCNumber <GCNumber>k__BackingField;
    public int SnapshotIndex { get; }
    public string SnapshotIndexFile { get; }
    public DateTime SnapshotTakenTime { get; }
    public int CallTreeCount { get; private set; }
    public SnapshotId SnapshotId { get; }
    public GCNumber GCNumber { get; private set; }
    public int ObjectsCount { get; }
    public bool IsAllocationCollected { get; }
    public bool IsTrafficCollected { get; }
    public bool IsFinalizerCollected { get; }
    public Snapshot(SnapshotId snapshotId, IAccessibilityMask accessibilityMask, ISnapshotScope snapshotScope, ICallTreeProvider callTreeProvider, Lifetime lifetime, int snapshotSequenceNumber, string snapshotIndexFile, GCNumber snapshotGCNumber, DateTime snapshotTakenTime, bool isTrafficCollected, bool isFinalizerCollected);
    public sealed virtual int get_SnapshotIndex();
    public sealed virtual ulong GetObjectsSize(IExecutionController ec);
    public sealed virtual string get_SnapshotIndexFile();
    public sealed virtual DateTime get_SnapshotTakenTime();
    [CompilerGeneratedAttribute]
public sealed virtual int get_CallTreeCount();
    [CompilerGeneratedAttribute]
private void set_CallTreeCount(int value);
    public sealed virtual SnapshotId get_SnapshotId();
    [CompilerGeneratedAttribute]
public sealed virtual GCNumber get_GCNumber();
    [CompilerGeneratedAttribute]
private void set_GCNumber(GCNumber value);
    public sealed virtual int get_ObjectsCount();
    public sealed virtual bool get_IsAllocationCollected();
    public sealed virtual bool get_IsTrafficCollected();
    public sealed virtual bool get_IsFinalizerCollected();
    public sealed virtual IObjectSet GetRoots(Lifetime lifetime);
    public sealed virtual IObjectSet GetAllObjects(IExecutionController executionController, Lifetime lifetime);
}
[UsedImplicitlyAttribute]
public class JetBrains.dotMemory.Model.Snapshots.SnapshotSummaryCalculator : object {
    private IAllObjectsSetReference myAllObjectsSetReference;
    private IEntityReference`1<IObjectSizeCollection> myObjectSizeCollectionReference;
    private IEntityReference`1<IHeapsCollection> myHeapsReference;
    public SnapshotSummaryCalculator(IAllObjectsSetReference allObjectsSetReference, IEntityReference`1<IObjectSizeCollection> objectSizeCollectionReference, IEntityReference`1<IHeapsCollection> heapsReference);
    public sealed virtual SnapshotSummary Calculate(IExecutionController executionController);
}
[UsedImplicitlyAttribute]
public class JetBrains.dotMemory.Model.Snapshots.SnapshotSummaryDiskCache : object {
    private static string DataName;
    private static Version FormatVersion;
    private ISnapshotSummaryCalculator myCalculator;
    private ISharedCacheDataStorage myStorage;
    [CompilerGeneratedAttribute]
private static Action`3<SnapshotSummary, BinaryWriter, IExecutionController> CS$<>9__CachedAnonymousMethodDelegate3;
    [CompilerGeneratedAttribute]
private static Func`3<BinaryReader, IExecutionController, SnapshotSummary> CS$<>9__CachedAnonymousMethodDelegate4;
    public SnapshotSummaryDiskCache(ISnapshotSummaryCalculator calculator, ISharedCacheDataStorage storage);
    private static SnapshotSummaryDiskCache();
    public sealed virtual SnapshotSummary Calculate(IExecutionController executionController);
    [CompilerGeneratedAttribute]
private SnapshotSummary <Calculate>b__0(IExecutionController controller);
    [CompilerGeneratedAttribute]
private static void <Calculate>b__1(SnapshotSummary summary, BinaryWriter writer, IExecutionController controller);
    [CompilerGeneratedAttribute]
private static SnapshotSummary <Calculate>b__2(BinaryReader reader, IExecutionController controller);
}
public class JetBrains.dotMemory.Model.SnapshotTopTypesService : object {
    private IEntityReference`1<IObjectTypeCollection> myTypesReference;
    private IEntityReference`1<IObjectSizeCollection> mySizesReference;
    private ITypeSection myTypeSection;
    private ISnapshot mySnapshot;
    [CompilerGeneratedAttribute]
private static Comparison`1<TypeStatistics> CS$<>9__CachedAnonymousMethodDelegate1;
    public SnapshotTopTypesService(IEntityReference`1<IObjectTypeCollection> typesReference, IEntityReference`1<IObjectSizeCollection> sizesReference, ITypeSection typeSection, ISnapshot snapshot);
    public sealed virtual IReadOnlyCollection`1<TypeStatistics> GetTopTypes(int topTypesCount, IExecutionController executionController);
    [CompilerGeneratedAttribute]
private static int <GetTopTypes>b__0(TypeStatistics first, TypeStatistics second);
}
[UsedImplicitlyAttribute]
public class JetBrains.dotMemory.Model.SourceCodeRangesExtractor : object {
    private ISymbolsProvidersManager mySymbolsProvidersManager;
    public SourceCodeRangesExtractor(ISymbolsProvidersManager symbolsProvidersManager);
    [CanBeNullAttribute]
public sealed virtual SourceCodeRange GetSourceCodeRanges(IMetadataAssembly assembly, MetadataToken token);
}
[SettingsIndexedKeyAttribute("System.Reflection.Missing", "ObjectTagState", "System.Int32")]
public class JetBrains.dotMemory.Model.StatePersistence.ObjectTagState : object {
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "Tag text")]
public string Text;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "Tag")]
public int Tag;
    public ObjectTagState(string text, int tag);
}
public class JetBrains.dotMemory.Model.SunburstDiagramGenerator`1 : object {
    private static double CenterRadius;
    private static int MaxLevel;
    public sealed virtual ISunburstDiagramNode`1<TModelNode> GenerateSunburstDiagram(IReadOnlyCollection`1<TModelNode> treeRoots, ulong totalSize, string rootName, Func`2<TModelNode, IEnumerable`1<TModelNode>> getChildren, Func`2<TModelNode, ulong> getSubTreeSize, Func`2<TModelNode, ulong> getOwnSize, Func`2<TModelNode, string> getTitle, IExecutionController executionController);
}
public class JetBrains.dotMemory.Model.SunburstDiagramNode`1 : object {
    private T myModelNode;
    private AnnularSector myGeometry;
    private IList`1<ISunburstDiagramNode> myChildren;
    private ulong myOwnSize;
    private ulong mySubTreeSize;
    private string myTitle;
    public T ModelNode { get; }
    public AnnularSector Geometry { get; }
    public IEnumerable`1<ISunburstDiagramNode> Children { get; }
    public string Title { get; }
    public ulong OwnSize { get; }
    public ulong SubTreeSize { get; }
    public SunburstDiagramNode`1(T modelNode, AnnularSector geometry, ulong ownSize, ulong subTreeSize, string title);
    public sealed virtual T get_ModelNode();
    public sealed virtual AnnularSector get_Geometry();
    public sealed virtual IEnumerable`1<ISunburstDiagramNode> get_Children();
    public sealed virtual string get_Title();
    public sealed virtual ulong get_OwnSize();
    public sealed virtual ulong get_SubTreeSize();
    public sealed virtual void AddChild(ISunburstDiagramNode`1<T> child);
}
[UsedImplicitlyAttribute]
public class JetBrains.dotMemory.Model.Timeline.InMemoryTimelineChartStorage : InMemoryChartStorage {
    public InMemoryTimelineChartStorage(IList`1<int> eventTypes, IDiskStorageChartWriter writer, Lifetime lifetime);
    private static IList`1<double> CreateXValues();
    private static IList`1[] CreateYValues(IList`1<int> eventTypes);
}
public class JetBrains.dotMemory.Model.Timeline.InMemoryTimelineChartStorageReadonly : InMemoryChartStorage {
    public InMemoryTimelineChartStorageReadonly(MultiChartData multiChartData);
}
[UsedImplicitlyAttribute]
public class JetBrains.dotMemory.Model.Traffic.FunctionTrafficAggregator : object {
    private IReadOnlyList`1<ISnapshot> mySnapshots;
    private ISnapshotServiceLocator mySnapshotServiceLocator;
    private ICuttedSessionDetector myCuttedSessionDetector;
    [CompilerGeneratedAttribute]
private static Func`1<AllocationsInfoLinksBag`1<BactraceTreeLink>> CS$<>9__CachedAnonymousMethodDelegate4;
    [CompilerGeneratedAttribute]
private static Func`2<KeyValuePair`2<MetadataId, AllocationsInfoLinksBag`1<BactraceTreeLink>>, FunctionStatistics`1<BactraceTreeLink>> CS$<>9__CachedAnonymousMethodDelegate5;
    public FunctionTrafficAggregator(IReadOnlyList`1<ISnapshot> snapshots, ICallTreeForestShort callTreeForestShort, ISnapshotServiceLocator snapshotServiceLocator, ICuttedSessionDetector cuttedSessionDetector);
    public sealed virtual FunctionAggregate`1<BactraceTreeLink> Aggregate(GCNumber fromGC, GCNumber toGC, IExecutionController executionController);
    public sealed virtual FunctionAggregate`1<BactraceTreeLink> AggregateForTypes(IEnumerable`1<TypeId> typeIds, GCNumber fromGC, GCNumber toGC, IExecutionController executionController);
    private FunctionAggregate`1<BactraceTreeLink> Aggregate(FunctionStatisticMatcher matcher, GCNumber fromGC, GCNumber toGC, IExecutionController executionController);
    private static void AssertSnapshot(ISnapshot snapshot, GCNumber from, GCNumber to);
    [CompilerGeneratedAttribute]
private static AllocationsInfoLinksBag`1<BactraceTreeLink> <Aggregate>b__1();
    [CompilerGeneratedAttribute]
private static FunctionStatistics`1<BactraceTreeLink> <Aggregate>b__3(KeyValuePair`2<MetadataId, AllocationsInfoLinksBag`1<BactraceTreeLink>> pair);
}
[UsedImplicitlyAttribute]
public class JetBrains.dotMemory.Model.Traffic.TrafficService : object {
    private IReadOnlyList`1<ISnapshot> mySnapshots;
    private ISnapshotServiceLocator mySnapshotServiceLocator;
    private ICuttedSessionDetector myCuttedSessionDetector;
    public TrafficService(IReadOnlyList`1<ISnapshot> snapshots, ISnapshotServiceLocator snapshotServiceLocator, ICuttedSessionDetector cuttedSessionDetector);
    public sealed virtual bool CanBeCalculated(GCNumber fromGC, GCNumber toGC, IExecutionController executionController);
    private void AssertSnapshot(ISnapshot snapshot, GCNumber from, GCNumber to);
}
[UsedImplicitlyAttribute]
public class JetBrains.dotMemory.Model.Traffic.TypeTrafficAggregator : object {
    private IReadOnlyList`1<ISnapshot> mySnapshots;
    private ISnapshotServiceLocator mySnapshotServiceLocator;
    private ICuttedSessionDetector myCuttedSessionDetector;
    [CompilerGeneratedAttribute]
private static Func`2<KeyValuePair`2<TypeId, TypeTrafficStatistics>, TypeStatistics> CS$<>9__CachedAnonymousMethodDelegate3;
    public TypeTrafficAggregator(IReadOnlyList`1<ISnapshot> snapshots, ISnapshotServiceLocator snapshotServiceLocator, ICuttedSessionDetector cuttedSessionDetector);
    public sealed virtual TypeAggregate Aggregate(GCNumber fromGC, GCNumber toGC, IExecutionController executionController);
    public sealed virtual TypeAggregate AggregateForFunction(IEnumerable`1<CallTreeLink> allocationOrigins, GCNumber fromGC, GCNumber toGC, IExecutionController executionController);
    private TypeAggregate Aggregate(GCNumber fromGC, GCNumber toGC, TypeStatisticMatcher matcher, IExecutionController executionController);
    private static void AssertSnapshot(ISnapshot snapshot, GCNumber from, GCNumber to);
    [CompilerGeneratedAttribute]
private static TypeStatistics <Aggregate>b__2(KeyValuePair`2<TypeId, TypeTrafficStatistics> pair);
}
public class JetBrains.dotMemory.Model.TwoWayDominatorsSection : Path {
}
public class JetBrains.dotMemory.Model.TwoWayParallelPathsSection : object {
    private Path myLeftPath;
    private Path myRightPath;
    public IReversePath LeftPath { get; }
    public IReversePath RightPath { get; }
    public sealed virtual IReversePath get_LeftPath();
    public void AddToLeft(GraphReferenceId referenceId);
    public void AddToRight(GraphReferenceId referenceId);
    public sealed virtual IReversePath get_RightPath();
}
public class JetBrains.dotMemory.Model.TwoWayPathBuilder : object {
    private IShortestPairsCollection myShortestPairs;
    private IDominatorTreeParentCollection myDominators;
    private IShortestRootPathTree myShortestRootPathTree;
    public TwoWayPathBuilder(IShortestPairsCollection shortestPairs, IDominatorTreeParentCollection dominators, IShortestRootPathTree shortestRootPathTree);
    public sealed virtual IReadOnlyList`1<ITwoWayPathSection> BuildTwoWayPath(ObjectNumber objectNumber, IExecutionController executionController);
}
public class JetBrains.dotMemory.Model.TypeNameModel.CachingTypeService : object {
    private ITypeService myOriginalService;
    private ITypeNameCache myTypeNameCache;
    public CachingTypeService(ITypeService originalService, ITypeNameCache typeNameCache);
    public sealed virtual ITypeName GetTypeName(TypeId typeId);
    public sealed virtual ITypeName GetTypeName(IMetadataTypeInfo metadataTypeInfo);
    public sealed virtual ITypeName GetTypeName(IMetadataType metadataType);
    [CompilerGeneratedAttribute]
private ITypeName <GetTypeName>b__0(TypeId _);
}
public interface JetBrains.dotMemory.Model.TypeNameModel.INamespaceTree {
    [NotNullAttribute]
public abstract virtual INamespaceNode GetNamespaceNode(string fullNamespace);
}
[DebuggerDisplayAttribute("{ParentNamespace}.{Name}")]
public class JetBrains.dotMemory.Model.TypeNameModel.NamespaceNode : object {
    public static INamespaceNode Unknown;
    public static INamespaceNode Global;
    private string myName;
    private NamespaceNode myParentNamespace;
    private Dictionary`2<string, NamespaceNode> mySubNamespaces;
    private object mySubNamespacesAccess;
    private IReadOnlyList`1<string> myFullNamespace;
    private PropertyChangedEventHandler PropertyChanged;
    [CanBeNullAttribute]
public INamespaceNode ParentNamespace { get; }
    [NotNullAttribute]
public string Name { get; }
    [NotNullAttribute]
public IReadOnlyList`1<string> FullNamespace { get; }
    internal NamespaceNode(string name, NamespaceNode parentNamespace);
    private static NamespaceNode();
    public sealed virtual INamespaceNode get_ParentNamespace();
    public sealed virtual string get_Name();
    public sealed virtual IReadOnlyList`1<string> get_FullNamespace();
    [CanBeNullAttribute]
public NamespaceNode GetSubNamespaceNode(string subNamespace);
    public virtual NamespaceNode AddSubNamespace(string namespacePart);
    protected NamespaceNode AddSubNamespaceNode(string namespacePart, NamespaceNode parentNamespace);
    public sealed virtual int CompareTo(INamespaceNode other);
    public sealed virtual int CompareTo(NamespaceNode other);
    public sealed virtual bool Equals(INamespaceNode other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
}
[UsedImplicitlyAttribute]
public class JetBrains.dotMemory.Model.TypeNameModel.NamespaceTree : NamespaceNode {
    public virtual NamespaceNode AddSubNamespace(string namespacePart);
    [NotNullAttribute]
public sealed virtual INamespaceNode GetNamespaceNode(string fullNamespace);
}
internal class JetBrains.dotMemory.Model.TypeNameModel.TypeName : object {
    public static TypeName WantingTypeName;
    private TypeId myTypeId;
    private string myName;
    private INamespaceNode myNamespaceNode;
    private IReadOnlyList`1<ITypeName> myGenericArguments;
    private Int32[] myArrayRanks;
    private string myArrayPostfix;
    private static object ourArrayPostfixDictionaryAccess;
    private static Dictionary`2<Int32[], string> ourArrayPostfixDictionary;
    private PropertyChangedEventHandler PropertyChanged;
    [CompilerGeneratedAttribute]
private static Func`2<Int32[], string> CS$<>9__CachedAnonymousMethodDelegate2;
    public TypeId TypeId { get; }
    [NotNullAttribute]
public string Name { get; }
    [NotNullAttribute]
public INamespaceNode NamespaceNode { get; }
    [NotNullAttribute]
public IReadOnlyList`1<string> Namespace { get; }
    public IReadOnlyList`1<ITypeName> GenericArguments { get; }
    public string ArrayPostfix { get; }
    [NotNullAttribute]
public Int32[] ArrayRanks { get; }
    public TypeName(TypeId typeId, string name, INamespaceNode namespaceNode, IReadOnlyList`1<ITypeName> genericArguments, Int32[] arrayRanks);
    private static TypeName();
    public sealed virtual TypeId get_TypeId();
    public sealed virtual string get_Name();
    public sealed virtual INamespaceNode get_NamespaceNode();
    public sealed virtual IReadOnlyList`1<string> get_Namespace();
    public sealed virtual IReadOnlyList`1<ITypeName> get_GenericArguments();
    public sealed virtual string get_ArrayPostfix();
    public sealed virtual Int32[] get_ArrayRanks();
    public sealed virtual int CompareTo(ITypeName other);
    private int CompareGenericArguments(ITypeName other);
    [CanBeNullAttribute]
private static string GetArrayPostfix(Int32[] dimensions);
    public sealed virtual int CompareTo(object obj);
    public sealed virtual bool Equals(ITypeName other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
private static string <GetArrayPostfix>b__1(Int32[] arrayInfo);
}
[UsedImplicitlyAttribute]
public class JetBrains.dotMemory.Model.TypeNameModel.TypeNameCache : object {
    private object myTypeNameCacheAccess;
    private Dictionary`2<TypeId, ITypeName> myTypeNameCache;
    [NotNullAttribute]
public sealed virtual ITypeName GetOrCreate(TypeId typeId, Func`2<TypeId, ITypeName> createTypeName);
}
[UsedImplicitlyAttribute]
public class JetBrains.dotMemory.Model.TypeNameModel.TypeService : object {
    private ITypeSection myTypeSection;
    private IMetadataSectionAssemblyProvider myMetadataProvider;
    private INamespaceTree myNamespaceTree;
    private object myMetadataAccess;
    [CompilerGeneratedAttribute]
private static Func`2<ObjectType, int> CS$<>9__CachedAnonymousMethodDelegate5;
    [CompilerGeneratedAttribute]
private static Func`2<ObjectType, ObjectType> CS$<>9__CachedAnonymousMethodDelegate7;
    [CompilerGeneratedAttribute]
private static Func`2<IMetadataArrayType, int> CS$<>9__CachedAnonymousMethodDelegated;
    [CompilerGeneratedAttribute]
private static Func`2<IMetadataArrayType, IMetadataType> CS$<>9__CachedAnonymousMethodDelegatee;
    [CompilerGeneratedAttribute]
private static Func`2<IMetadataType, IMetadataArrayType> CS$<>9__CachedAnonymousMethodDelegatef;
    [CompilerGeneratedAttribute]
private static Func`2<IMetadataGenericArgument, TypeName> CS$<>9__CachedAnonymousMethodDelegate12;
    public TypeService(ITypeSection typeSection, IMetadataSectionAssemblyProvider metadataProvider, INamespaceTree namespaceTree);
    public sealed virtual ITypeName GetTypeName(TypeId typeId);
    private static string GetTypeNameWithoutGenericPostfix(IMetadataTypeInfo typeInfo);
    public sealed virtual ITypeName GetTypeName(IMetadataType metadataType);
    private static TElement CollectArrayDimensions(TArray array, Func`2<TArray, int> getArrayRank, Func`2<TArray, TElement> getArrayElementType, Func`2<TElement, TArray> getArray, ICollection`1<int> dimensionsAggregator);
    public sealed virtual ITypeName GetTypeName(IMetadataTypeInfo metadataTypeInfo);
    private static string GetNormalizedTypeName(IMetadataTypeInfo typeInfo);
    private ITypeName GetTypeName(TypeId typeId, IMetadataTypeInfo metadataTypeInfo, IReadOnlyList`1<ITypeName> genericArguments, Int32[] arrayDimensions, Func`1<string> getUnresolvedTypeName);
    [CompilerGeneratedAttribute]
private static int <GetTypeName>b__1(ObjectType array);
    [CompilerGeneratedAttribute]
private ObjectType <GetTypeName>b__2(ObjectType array);
    [CompilerGeneratedAttribute]
private static ObjectType <GetTypeName>b__3(ObjectType element);
    [CompilerGeneratedAttribute]
private static int <GetTypeName>b__a(IMetadataArrayType array);
    [CompilerGeneratedAttribute]
private static IMetadataType <GetTypeName>b__b(IMetadataArrayType array);
    [CompilerGeneratedAttribute]
private static IMetadataArrayType <GetTypeName>b__c(IMetadataType element);
    [CompilerGeneratedAttribute]
private static TypeName <GetTypeName>b__10(IMetadataGenericArgument ga);
}
[UsedImplicitlyAttribute]
public class JetBrains.dotMemory.Model.TypeResolvingService : object {
    private IFactory myFactory;
    private Lifetime myLifetime;
    public TypeResolvingService(IFactory factory, Lifetime lifetime);
    public sealed virtual TypeId GetTypeId(string typeName);
}
[UsedImplicitlyAttribute]
public class JetBrains.dotMemory.Model.VSNavigationManager : object {
    private object myNavigationAccess;
    private string myTitle;
    private EndpointAddress myDestination;
    public bool HasDestination { get; }
    public string Title { get; }
    public EndpointAddress Destination { get; }
    public sealed virtual void StoreNavigationResult(string title, EndpointAddress endpointAddress);
    public sealed virtual void ClearNavigationResult();
    public sealed virtual bool get_HasDestination();
    public sealed virtual string get_Title();
    public sealed virtual EndpointAddress get_Destination();
}
[ZoneMarkerAttribute]
public class JetBrains.dotMemory.Model.ZoneMarker : object {
}
