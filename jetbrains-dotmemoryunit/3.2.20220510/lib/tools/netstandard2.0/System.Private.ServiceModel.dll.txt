internal static class FxResources.System.Private.ServiceModel.SR : object {
}
internal static class System.__HResults : object {
    internal static int APPMODEL_ERROR_NO_PACKAGE;
    internal static int CLDB_E_FILE_CORRUPT;
    internal static int CLDB_E_FILE_OLDVER;
    internal static int CLDB_E_INDEX_NOTFOUND;
    internal static int CLR_E_BIND_ASSEMBLY_NOT_FOUND;
    internal static int CLR_E_BIND_ASSEMBLY_PUBLIC_KEY_MISMATCH;
    internal static int CLR_E_BIND_ASSEMBLY_VERSION_TOO_LOW;
    internal static int CLR_E_BIND_TYPE_NOT_FOUND;
    internal static int CLR_E_BIND_UNRECOGNIZED_IDENTITY_FORMAT;
    internal static int COR_E_ABANDONEDMUTEX;
    internal static int COR_E_AMBIGUOUSMATCH;
    internal static int COR_E_APPDOMAINUNLOADED;
    internal static int COR_E_APPLICATION;
    internal static int COR_E_ARGUMENT;
    internal static int COR_E_ARGUMENTOUTOFRANGE;
    internal static int COR_E_ARITHMETIC;
    internal static int COR_E_ARRAYTYPEMISMATCH;
    internal static int COR_E_ASSEMBLYEXPECTED;
    internal static int COR_E_BADIMAGEFORMAT;
    internal static int COR_E_CANNOTUNLOADAPPDOMAIN;
    internal static int COR_E_CODECONTRACTFAILED;
    internal static int COR_E_CONTEXTMARSHAL;
    internal static int COR_E_CUSTOMATTRIBUTEFORMAT;
    internal static int COR_E_DATAMISALIGNED;
    internal static int COR_E_DIVIDEBYZERO;
    internal static int COR_E_DLLNOTFOUND;
    internal static int COR_E_DUPLICATEWAITOBJECT;
    internal static int COR_E_ENTRYPOINTNOTFOUND;
    internal static int COR_E_EXCEPTION;
    internal static int COR_E_EXECUTIONENGINE;
    internal static int COR_E_FIELDACCESS;
    internal static int COR_E_FIXUPSINEXE;
    internal static int COR_E_FORMAT;
    internal static int COR_E_INDEXOUTOFRANGE;
    internal static int COR_E_INSUFFICIENTEXECUTIONSTACK;
    internal static int COR_E_INVALIDCAST;
    internal static int COR_E_INVALIDCOMOBJECT;
    internal static int COR_E_INVALIDFILTERCRITERIA;
    internal static int COR_E_INVALIDOLEVARIANTTYPE;
    internal static int COR_E_INVALIDOPERATION;
    internal static int COR_E_INVALIDPROGRAM;
    internal static int COR_E_KEYNOTFOUND;
    internal static int COR_E_LOADING_REFERENCE_ASSEMBLY;
    internal static int COR_E_MARSHALDIRECTIVE;
    internal static int COR_E_MEMBERACCESS;
    internal static int COR_E_METHODACCESS;
    internal static int COR_E_MISSINGFIELD;
    internal static int COR_E_MISSINGMANIFESTRESOURCE;
    internal static int COR_E_MISSINGMEMBER;
    internal static int COR_E_MISSINGMETHOD;
    internal static int COR_E_MISSINGSATELLITEASSEMBLY;
    internal static int COR_E_MODULE_HASH_CHECK_FAILED;
    internal static int COR_E_MULTICASTNOTSUPPORTED;
    internal static int COR_E_NEWER_RUNTIME;
    internal static int COR_E_NOTFINITENUMBER;
    internal static int COR_E_NOTSUPPORTED;
    internal static int COR_E_NULLREFERENCE;
    internal static int COR_E_OBJECTDISPOSED;
    internal static int COR_E_OPERATIONCANCELED;
    internal static int COR_E_OUTOFMEMORY;
    internal static int COR_E_OVERFLOW;
    internal static int COR_E_PLATFORMNOTSUPPORTED;
    internal static int COR_E_RANK;
    internal static int COR_E_REFLECTIONTYPELOAD;
    internal static int COR_E_REMOTING;
    internal static int COR_E_RUNTIMEWRAPPED;
    internal static int COR_E_SAFEARRAYRANKMISMATCH;
    internal static int COR_E_SAFEARRAYTYPEMISMATCH;
    internal static int COR_E_SECURITY;
    internal static int COR_E_SERIALIZATION;
    internal static int COR_E_SERVER;
    internal static int COR_E_STACKOVERFLOW;
    internal static int COR_E_SYNCHRONIZATIONLOCK;
    internal static int COR_E_SYSTEM;
    internal static int COR_E_TARGET;
    internal static int COR_E_TARGETINVOCATION;
    internal static int COR_E_TARGETPARAMCOUNT;
    internal static int COR_E_THREADABORTED;
    internal static int COR_E_THREADINTERRUPTED;
    internal static int COR_E_THREADSTART;
    internal static int COR_E_THREADSTATE;
    internal static int COR_E_TIMEOUT;
    internal static int COR_E_TYPEACCESS;
    internal static int COR_E_TYPEINITIALIZATION;
    internal static int COR_E_TYPELOAD;
    internal static int COR_E_TYPEUNLOADED;
    internal static int COR_E_UNAUTHORIZEDACCESS;
    internal static int COR_E_VERIFICATION;
    internal static int COR_E_WAITHANDLECANNOTBEOPENED;
    internal static int CORSEC_E_CRYPTO;
    internal static int CORSEC_E_CRYPTO_UNEX_OPER;
    internal static int CORSEC_E_INVALID_IMAGE_FORMAT;
    internal static int CORSEC_E_INVALID_PUBLICKEY;
    internal static int CORSEC_E_INVALID_STRONGNAME;
    internal static int CORSEC_E_MIN_GRANT_FAIL;
    internal static int CORSEC_E_MISSING_STRONGNAME;
    internal static int CORSEC_E_NO_EXEC_PERM;
    internal static int CORSEC_E_POLICY_EXCEPTION;
    internal static int CORSEC_E_SIGNATURE_MISMATCH;
    internal static int CORSEC_E_XMLSYNTAX;
    internal static int CTL_E_DEVICEIOERROR;
    internal static int CTL_E_DIVISIONBYZERO;
    internal static int CTL_E_FILENOTFOUND;
    internal static int CTL_E_OUTOFMEMORY;
    internal static int CTL_E_OUTOFSTACKSPACE;
    internal static int CTL_E_OVERFLOW;
    internal static int CTL_E_PATHFILEACCESSERROR;
    internal static int CTL_E_PATHNOTFOUND;
    internal static int CTL_E_PERMISSIONDENIED;
    internal static int E_ELEMENTNOTAVAILABLE;
    internal static int E_ELEMENTNOTENABLED;
    internal static int E_FAIL;
    internal static int E_ILLEGAL_DELEGATE_ASSIGNMENT;
    internal static int E_ILLEGAL_METHOD_CALL;
    internal static int E_ILLEGAL_STATE_CHANGE;
    internal static int E_LAYOUTCYCLE;
    internal static int E_NOTIMPL;
    internal static int E_OUTOFMEMORY;
    internal static int E_POINTER;
    internal static int E_XAMLPARSEFAILED;
    internal static int ERROR_BAD_EXE_FORMAT;
    internal static int ERROR_BAD_NET_NAME;
    internal static int ERROR_BAD_NETPATH;
    internal static int ERROR_DISK_CORRUPT;
    internal static int ERROR_DLL_INIT_FAILED;
    internal static int ERROR_DLL_NOT_FOUND;
    internal static int ERROR_EXE_MARKED_INVALID;
    internal static int ERROR_FILE_CORRUPT;
    internal static int ERROR_FILE_INVALID;
    internal static int ERROR_FILE_NOT_FOUND;
    internal static int ERROR_INVALID_DLL;
    internal static int ERROR_INVALID_NAME;
    internal static int ERROR_INVALID_ORDINAL;
    internal static int ERROR_INVALID_PARAMETER;
    internal static int ERROR_LOCK_VIOLATION;
    internal static int ERROR_MOD_NOT_FOUND;
    internal static int ERROR_NO_UNICODE_TRANSLATION;
    internal static int ERROR_NOACCESS;
    internal static int ERROR_NOT_READY;
    internal static int ERROR_OPEN_FAILED;
    internal static int ERROR_PATH_NOT_FOUND;
    internal static int ERROR_SHARING_VIOLATION;
    internal static int ERROR_TOO_MANY_OPEN_FILES;
    internal static int ERROR_UNRECOGNIZED_VOLUME;
    internal static int ERROR_WRONG_TARGET_NAME;
    internal static int FUSION_E_ASM_MODULE_MISSING;
    internal static int FUSION_E_CACHEFILE_FAILED;
    internal static int FUSION_E_CODE_DOWNLOAD_DISABLED;
    internal static int FUSION_E_HOST_GAC_ASM_MISMATCH;
    internal static int FUSION_E_INVALID_NAME;
    internal static int FUSION_E_INVALID_PRIVATE_ASM_LOCATION;
    internal static int FUSION_E_LOADFROM_BLOCKED;
    internal static int FUSION_E_PRIVATE_ASM_DISALLOWED;
    internal static int FUSION_E_REF_DEF_MISMATCH;
    internal static int FUSION_E_SIGNATURE_CHECK_FAILED;
    internal static int INET_E_CANNOT_CONNECT;
    internal static int INET_E_CONNECTION_TIMEOUT;
    internal static int INET_E_DATA_NOT_AVAILABLE;
    internal static int INET_E_DOWNLOAD_FAILURE;
    internal static int INET_E_OBJECT_NOT_FOUND;
    internal static int INET_E_RESOURCE_NOT_FOUND;
    internal static int INET_E_UNKNOWN_PROTOCOL;
    internal static int ISS_E_ALLOC_TOO_LARGE;
    internal static int ISS_E_BLOCK_SIZE_TOO_SMALL;
    internal static int ISS_E_CALLER;
    internal static int ISS_E_CORRUPTED_STORE_FILE;
    internal static int ISS_E_CREATE_DIR;
    internal static int ISS_E_CREATE_MUTEX;
    internal static int ISS_E_DEPRECATE;
    internal static int ISS_E_FILE_NOT_MAPPED;
    internal static int ISS_E_FILE_WRITE;
    internal static int ISS_E_GET_FILE_SIZE;
    internal static int ISS_E_ISOSTORE;
    internal static int ISS_E_LOCK_FAILED;
    internal static int ISS_E_MACHINE;
    internal static int ISS_E_MACHINE_DACL;
    internal static int ISS_E_MAP_VIEW_OF_FILE;
    internal static int ISS_E_OPEN_FILE_MAPPING;
    internal static int ISS_E_OPEN_STORE_FILE;
    internal static int ISS_E_PATH_LENGTH;
    internal static int ISS_E_SET_FILE_POINTER;
    internal static int ISS_E_STORE_NOT_OPEN;
    internal static int ISS_E_STORE_VERSION;
    internal static int ISS_E_TABLE_ROW_NOT_FOUND;
    internal static int ISS_E_USAGE_WILL_EXCEED_QUOTA;
    internal static int META_E_BAD_SIGNATURE;
    internal static int META_E_CA_FRIENDS_SN_REQUIRED;
    internal static int MSEE_E_ASSEMBLYLOADINPROGRESS;
    internal static int RO_E_CLOSED;
    internal static int E_BOUNDS;
    internal static int RO_E_METADATA_NAME_NOT_FOUND;
    internal static int SECURITY_E_INCOMPATIBLE_EVIDENCE;
    internal static int SECURITY_E_INCOMPATIBLE_SHARE;
    internal static int SECURITY_E_UNVERIFIABLE;
    internal static int STG_E_PATHNOTFOUND;
    public static int COR_E_DIRECTORYNOTFOUND;
    public static int COR_E_ENDOFSTREAM;
    public static int COR_E_FILELOAD;
    public static int COR_E_FILENOTFOUND;
    public static int COR_E_IO;
    public static int COR_E_PATHTOOLONG;
}
public class System.Collections.Generic.KeyedByTypeCollection`1 : KeyedCollection`2<Type, TItem> {
    public KeyedByTypeCollection`1(IEnumerable`1<TItem> items);
    public T Find();
    public T Remove();
    private T Find(bool remove);
    public Collection`1<T> FindAll();
    public Collection`1<T> RemoveAll();
    private Collection`1<T> FindAll(bool remove);
    protected virtual Type GetKeyForItem(TItem item);
    protected virtual void InsertItem(int index, TItem item);
    protected virtual void SetItem(int index, TItem item);
}
[DefaultMemberAttribute("Item")]
[ComVisibleAttribute("False")]
public class System.Collections.Generic.SynchronizedCollection`1 : object {
    private List`1<T> _items;
    private object _sync;
    public int Count { get; }
    protected List`1<T> Items { get; }
    public object SyncRoot { get; }
    public T Item { get; public set; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private object System.Collections.IList.Item { get; private set; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    public SynchronizedCollection`1(object syncRoot);
    public SynchronizedCollection`1(object syncRoot, IEnumerable`1<T> list);
    public SynchronizedCollection`1(object syncRoot, T[] list);
    public sealed virtual int get_Count();
    protected List`1<T> get_Items();
    public object get_SyncRoot();
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual void CopyTo(T[] array, int index);
    public sealed virtual bool Contains(T item);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    public sealed virtual int IndexOf(T item);
    public sealed virtual void Insert(int index, T item);
    private int InternalIndexOf(T item);
    public sealed virtual bool Remove(T item);
    public sealed virtual void RemoveAt(int index);
    protected virtual void ClearItems();
    protected virtual void InsertItem(int index, T item);
    protected virtual void RemoveItem(int index);
    protected virtual void SetItem(int index, T item);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private static void VerifyValueType(object value);
}
[DefaultMemberAttribute("Item")]
[ComVisibleAttribute("False")]
public abstract class System.Collections.Generic.SynchronizedKeyedCollection`2 : SynchronizedCollection`1<T> {
    private static int defaultThreshold;
    private IEqualityComparer`1<K> _comparer;
    private Dictionary`2<K, T> _dictionary;
    private int _keyCount;
    private int _threshold;
    public T Item { get; }
    protected IDictionary`2<K, T> Dictionary { get; }
    protected SynchronizedKeyedCollection`2(object syncRoot);
    protected SynchronizedKeyedCollection`2(object syncRoot, IEqualityComparer`1<K> comparer);
    protected SynchronizedKeyedCollection`2(object syncRoot, IEqualityComparer`1<K> comparer, int dictionaryCreationThreshold);
    public T get_Item(K key);
    protected IDictionary`2<K, T> get_Dictionary();
    private void AddKey(K key, T item);
    protected void ChangeItemKey(T item, K newKey);
    protected virtual void ClearItems();
    public bool Contains(K key);
    private bool ContainsItem(T item);
    private void CreateDictionary();
    protected abstract virtual K GetKeyForItem(T item);
    protected virtual void InsertItem(int index, T item);
    public bool Remove(K key);
    protected virtual void RemoveItem(int index);
    private void RemoveKey(K key);
    protected virtual void SetItem(int index, T item);
}
[DefaultMemberAttribute("Item")]
[ComVisibleAttribute("False")]
public class System.Collections.Generic.SynchronizedReadOnlyCollection`1 : object {
    private IList`1<T> _items;
    private object _sync;
    public int Count { get; }
    protected IList`1<T> Items { get; }
    public T Item { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    private T System.Collections.Generic.IList<T>.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public SynchronizedReadOnlyCollection`1(object syncRoot);
    public SynchronizedReadOnlyCollection`1(object syncRoot, IEnumerable`1<T> list);
    public SynchronizedReadOnlyCollection`1(object syncRoot, T[] list);
    internal SynchronizedReadOnlyCollection`1(object syncRoot, List`1<T> list, bool makeCopy);
    public sealed virtual int get_Count();
    protected IList`1<T> get_Items();
    public T get_Item(int index);
    public sealed virtual bool Contains(T value);
    public sealed virtual void CopyTo(T[] array, int index);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    public sealed virtual int IndexOf(T value);
    private void ThrowReadOnly();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override T System.Collections.Generic.IList<T>.get_Item(int index);
    private sealed virtual override void System.Collections.Generic.IList<T>.set_Item(int index, T value);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T value);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.Remove(T value);
    private sealed virtual override void System.Collections.Generic.IList<T>.Insert(int index, T value);
    private sealed virtual override void System.Collections.Generic.IList<T>.RemoveAt(int index);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override void System.Collections.IList.Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
    private static void VerifyValueType(object value);
}
internal static class System.FxTrace : object {
    private static string baseEventSourceName;
    private static string EventSourceVersion;
    private static Guid s_etwProviderId;
    private static string s_eventSourceName;
    private static EtwDiagnosticTrace s_diagnosticTrace;
    private static ExceptionTrace s_exceptionTrace;
    private static object s_lockObject;
    public static ExceptionTrace Exception { get; }
    public static EtwDiagnosticTrace Trace { get; }
    private static string EventSourceName { get; }
    private static FxTrace();
    public static ExceptionTrace get_Exception();
    public static EtwDiagnosticTrace get_Trace();
    private static string get_EventSourceName();
    private static EtwDiagnosticTrace InitializeTracing();
    private static void EnsureEtwProviderInitialized();
}
internal abstract class System.IdentityModel.CanonicalFormWriter : object {
    internal static Encoding Utf8WithoutPreamble;
    private static CanonicalFormWriter();
    protected static void EncodeAndWrite(Stream stream, Byte[] workBuffer, string s);
    protected static void EncodeAndWrite(Stream stream, Byte[] workBuffer, Char[] chars);
    protected static void EncodeAndWrite(Stream stream, Byte[] workBuffer, Char[] chars, int count);
    private static void EncodeAndWrite(Stream stream, string s);
    private static void EncodeAndWrite(Stream stream, Char[] chars, int count);
}
[DataContractAttribute]
public class System.IdentityModel.Claims.Claim : object {
    private static Claim s_system;
    [DataMemberAttribute]
private string _claimType;
    [DataMemberAttribute]
private object _resource;
    [DataMemberAttribute]
private string _right;
    private IEqualityComparer`1<Claim> _comparer;
    public static IEqualityComparer`1<Claim> DefaultComparer { get; }
    public static Claim System { get; }
    public object Resource { get; }
    public string ClaimType { get; }
    public string Right { get; }
    private Claim(string claimType, object resource, string right, IEqualityComparer`1<Claim> comparer);
    public Claim(string claimType, object resource, string right);
    public static IEqualityComparer`1<Claim> get_DefaultComparer();
    public static Claim get_System();
    public object get_Resource();
    public string get_ClaimType();
    public string get_Right();
    public static Claim CreateDnsClaim(string dns);
    public static Claim CreateHashClaim(Byte[] hash);
    public static Claim CreateNameClaim(string name);
    public static Claim CreateSpnClaim(string spn);
    public static Claim CreateThumbprintClaim(Byte[] thumbprint);
    public static Claim CreateUpnClaim(string upn);
    public static Claim CreateUriClaim(Uri uri);
    public static Claim CreateWindowsSidClaim(SecurityIdentifier sid);
    public static Claim CreateX500DistinguishedNameClaim(X500DistinguishedName x500DistinguishedName);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
internal class System.IdentityModel.Claims.ClaimComparer : object {
    private static IEqualityComparer`1<Claim> s_defaultComparer;
    private static IEqualityComparer`1<Claim> s_hashComparer;
    private static IEqualityComparer`1<Claim> s_dnsComparer;
    private static IEqualityComparer`1<Claim> s_rsaComparer;
    private static IEqualityComparer`1<Claim> s_thumbprintComparer;
    private static IEqualityComparer`1<Claim> s_upnComparer;
    private static IEqualityComparer`1<Claim> s_x500DistinguishedNameComparer;
    private IEqualityComparer _resourceComparer;
    public static IEqualityComparer`1<Claim> Default { get; }
    public static IEqualityComparer`1<Claim> Dns { get; }
    public static IEqualityComparer`1<Claim> Hash { get; }
    public static IEqualityComparer`1<Claim> Rsa { get; }
    public static IEqualityComparer`1<Claim> Thumbprint { get; }
    public static IEqualityComparer`1<Claim> Upn { get; }
    public static IEqualityComparer`1<Claim> X500DistinguishedName { get; }
    private ClaimComparer(IEqualityComparer resourceComparer);
    public static IEqualityComparer`1<Claim> GetComparer(string claimType);
    public static IEqualityComparer`1<Claim> get_Default();
    public static IEqualityComparer`1<Claim> get_Dns();
    public static IEqualityComparer`1<Claim> get_Hash();
    public static IEqualityComparer`1<Claim> get_Rsa();
    public static IEqualityComparer`1<Claim> get_Thumbprint();
    public static IEqualityComparer`1<Claim> get_Upn();
    public static IEqualityComparer`1<Claim> get_X500DistinguishedName();
    public sealed virtual bool Equals(Claim claim1, Claim claim2);
    public sealed virtual int GetHashCode(Claim claim);
}
[DefaultMemberAttribute("Item")]
[DataContractAttribute]
public abstract class System.IdentityModel.Claims.ClaimSet : object {
    private static ClaimSet s_system;
    private static ClaimSet s_windows;
    private static ClaimSet s_anonymous;
    public static ClaimSet System { get; }
    public static ClaimSet Windows { get; }
    internal static ClaimSet Anonymous { get; }
    public Claim Item { get; }
    public int Count { get; }
    public ClaimSet Issuer { get; }
    public static ClaimSet get_System();
    public static ClaimSet get_Windows();
    internal static ClaimSet get_Anonymous();
    internal static bool SupportedRight(string right);
    public virtual bool ContainsClaim(Claim claim, IEqualityComparer`1<Claim> comparer);
    public virtual bool ContainsClaim(Claim claim);
    public abstract virtual Claim get_Item(int index);
    public abstract virtual int get_Count();
    public abstract virtual ClaimSet get_Issuer();
    public abstract virtual IEnumerable`1<Claim> FindClaims(string claimType, string right);
    public abstract virtual IEnumerator`1<Claim> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public static class System.IdentityModel.Claims.ClaimTypes : object {
    private static string claimTypeNamespace;
    private static string anonymous;
    private static string dns;
    private static string email;
    private static string hash;
    private static string name;
    private static string rsa;
    private static string sid;
    private static string denyOnlySid;
    private static string spn;
    private static string system;
    private static string thumbprint;
    private static string upn;
    private static string uri;
    private static string x500DistinguishedName;
    private static string givenname;
    private static string surname;
    private static string streetaddress;
    private static string locality;
    private static string stateorprovince;
    private static string postalcode;
    private static string country;
    private static string homephone;
    private static string otherphone;
    private static string mobilephone;
    private static string dateofbirth;
    private static string gender;
    private static string ppid;
    private static string webpage;
    private static string nameidentifier;
    private static string authentication;
    private static string authorizationdecision;
    public static string Anonymous { get; }
    public static string DenyOnlySid { get; }
    public static string Dns { get; }
    public static string Email { get; }
    public static string Hash { get; }
    public static string Name { get; }
    public static string Rsa { get; }
    public static string Sid { get; }
    public static string Spn { get; }
    public static string System { get; }
    public static string Thumbprint { get; }
    public static string Upn { get; }
    public static string Uri { get; }
    public static string X500DistinguishedName { get; }
    public static string NameIdentifier { get; }
    public static string Authentication { get; }
    public static string AuthorizationDecision { get; }
    public static string GivenName { get; }
    public static string Surname { get; }
    public static string StreetAddress { get; }
    public static string Locality { get; }
    public static string StateOrProvince { get; }
    public static string PostalCode { get; }
    public static string Country { get; }
    public static string HomePhone { get; }
    public static string OtherPhone { get; }
    public static string MobilePhone { get; }
    public static string DateOfBirth { get; }
    public static string Gender { get; }
    public static string PPID { get; }
    public static string Webpage { get; }
    public static string get_Anonymous();
    public static string get_DenyOnlySid();
    public static string get_Dns();
    public static string get_Email();
    public static string get_Hash();
    public static string get_Name();
    public static string get_Rsa();
    public static string get_Sid();
    public static string get_Spn();
    public static string get_System();
    public static string get_Thumbprint();
    public static string get_Upn();
    public static string get_Uri();
    public static string get_X500DistinguishedName();
    public static string get_NameIdentifier();
    public static string get_Authentication();
    public static string get_AuthorizationDecision();
    public static string get_GivenName();
    public static string get_Surname();
    public static string get_StreetAddress();
    public static string get_Locality();
    public static string get_StateOrProvince();
    public static string get_PostalCode();
    public static string get_Country();
    public static string get_HomePhone();
    public static string get_OtherPhone();
    public static string get_MobilePhone();
    public static string get_DateOfBirth();
    public static string get_Gender();
    public static string get_PPID();
    public static string get_Webpage();
}
[DefaultMemberAttribute("Item")]
[DataContractAttribute]
public class System.IdentityModel.Claims.DefaultClaimSet : ClaimSet {
    [DataMemberAttribute]
private ClaimSet _issuer;
    [DataMemberAttribute]
private IList`1<Claim> _claims;
    public Claim Item { get; }
    public int Count { get; }
    public ClaimSet Issuer { get; }
    public DefaultClaimSet(Claim[] claims);
    public DefaultClaimSet(IList`1<Claim> claims);
    public DefaultClaimSet(ClaimSet issuer, Claim[] claims);
    public DefaultClaimSet(ClaimSet issuer, IList`1<Claim> claims);
    public virtual Claim get_Item(int index);
    public virtual int get_Count();
    public virtual ClaimSet get_Issuer();
    public virtual bool ContainsClaim(Claim claim);
    [IteratorStateMachineAttribute("System.IdentityModel.Claims.DefaultClaimSet/<FindClaims>d__13")]
public virtual IEnumerable`1<Claim> FindClaims(string claimType, string right);
    public virtual IEnumerator`1<Claim> GetEnumerator();
    protected void Initialize(ClaimSet issuer, IList`1<Claim> claims);
    public virtual string ToString();
}
public static class System.IdentityModel.Claims.Rights : object {
    private static string rightNamespace;
    private static string identity;
    private static string possessProperty;
    public static string Identity { get; }
    public static string PossessProperty { get; }
    public static string get_Identity();
    public static string get_PossessProperty();
}
[DefaultMemberAttribute("Item")]
public class System.IdentityModel.Claims.WindowsClaimSet : ClaimSet {
    internal static bool DefaultIncludeWindowsGroups;
    private WindowsIdentity _windowsIdentity;
    private DateTime _expirationTime;
    private bool _includeWindowsGroups;
    private IList`1<Claim> _claims;
    private bool _disposed;
    private string _authenticationType;
    public Claim Item { get; }
    public int Count { get; }
    private IIdentity System.IdentityModel.Policy.IIdentityInfo.Identity { get; }
    public WindowsIdentity WindowsIdentity { get; }
    public ClaimSet Issuer { get; }
    public DateTime ExpirationTime { get; }
    public WindowsClaimSet(WindowsIdentity windowsIdentity);
    public WindowsClaimSet(WindowsIdentity windowsIdentity, bool includeWindowsGroups);
    public WindowsClaimSet(WindowsIdentity windowsIdentity, DateTime expirationTime);
    public WindowsClaimSet(WindowsIdentity windowsIdentity, bool includeWindowsGroups, DateTime expirationTime);
    public WindowsClaimSet(WindowsIdentity windowsIdentity, string authenticationType, bool includeWindowsGroups, DateTime expirationTime);
    internal WindowsClaimSet(WindowsIdentity windowsIdentity, string authenticationType, bool includeWindowsGroups, bool clone);
    internal WindowsClaimSet(WindowsIdentity windowsIdentity, string authenticationType, bool includeWindowsGroups, DateTime expirationTime, bool clone);
    private WindowsClaimSet(WindowsClaimSet from);
    public virtual Claim get_Item(int index);
    public virtual int get_Count();
    private sealed virtual override IIdentity System.IdentityModel.Policy.IIdentityInfo.get_Identity();
    public WindowsIdentity get_WindowsIdentity();
    public virtual ClaimSet get_Issuer();
    public DateTime get_ExpirationTime();
    internal WindowsClaimSet Clone();
    public sealed virtual void Dispose();
    private IList`1<Claim> InitializeClaimsCore();
    private void EnsureClaims();
    private void ThrowIfDisposed();
    private static bool SupportedClaimType(string claimType);
    [IteratorStateMachineAttribute("System.IdentityModel.Claims.WindowsClaimSet/<FindClaims>d__33")]
public virtual IEnumerable`1<Claim> FindClaims(string claimType, string right);
    public virtual IEnumerator`1<Claim> GetEnumerator();
    public virtual string ToString();
    public static bool TryCreateWindowsSidClaim(WindowsIdentity windowsIdentity, Claim& claim);
}
[DefaultMemberAttribute("Item")]
public class System.IdentityModel.Claims.X509CertificateClaimSet : ClaimSet {
    private X509Certificate2 _certificate;
    private DateTime _expirationTime;
    private ClaimSet _issuer;
    private X509Identity _identity;
    private X509ChainElementCollection _elements;
    private IList`1<Claim> _claims;
    private int _index;
    private bool _disposed;
    public Claim Item { get; }
    public int Count { get; }
    private IIdentity System.IdentityModel.Policy.IIdentityInfo.Identity { get; }
    public DateTime ExpirationTime { get; }
    public ClaimSet Issuer { get; }
    public X509Certificate2 X509Certificate { get; }
    public X509CertificateClaimSet(X509Certificate2 certificate);
    internal X509CertificateClaimSet(X509Certificate2 certificate, bool clone);
    private X509CertificateClaimSet(X509CertificateClaimSet from);
    private X509CertificateClaimSet(X509ChainElementCollection elements, int index);
    public virtual Claim get_Item(int index);
    public virtual int get_Count();
    private sealed virtual override IIdentity System.IdentityModel.Policy.IIdentityInfo.get_Identity();
    public DateTime get_ExpirationTime();
    public virtual ClaimSet get_Issuer();
    public X509Certificate2 get_X509Certificate();
    internal X509CertificateClaimSet Clone();
    public sealed virtual void Dispose();
    private IList`1<Claim> InitializeClaimsCore();
    private void EnsureClaims();
    private static bool SupportedClaimType(string claimType);
    [IteratorStateMachineAttribute("System.IdentityModel.Claims.X509CertificateClaimSet/<FindClaims>d__29")]
public virtual IEnumerable`1<Claim> FindClaims(string claimType, string right);
    private static String[] GetDnsFromExtensions(X509Certificate2 cert);
    public virtual IEnumerator`1<Claim> GetEnumerator();
    public virtual string ToString();
    private void ThrowIfDisposed();
}
internal class System.IdentityModel.Claims.X509Identity : GenericIdentity {
    private static string X509;
    private static string Thumbprint;
    private X500DistinguishedName _x500DistinguishedName;
    private X509Certificate2 _certificate;
    private string _name;
    private bool _disposed;
    private bool _disposable;
    public string Name { get; }
    public X509Identity(X509Certificate2 certificate);
    public X509Identity(X500DistinguishedName x500DistinguishedName);
    internal X509Identity(X509Certificate2 certificate, bool clone, bool disposable);
    public virtual string get_Name();
    private string GetName();
    public virtual ClaimsIdentity Clone();
    public sealed virtual void Dispose();
    private void ThrowIfDisposed();
}
internal static class System.IdentityModel.Claims.XsiConstants : object {
    public static string Namespace;
    public static string System;
}
internal static class System.IdentityModel.CryptoHelper : object {
    internal static bool IsSymmetricAlgorithm(string algorithm);
    internal static Byte[] UnwrapKey(Byte[] wrappingKey, Byte[] wrappedKey, string algorithm);
    internal static Byte[] WrapKey(Byte[] wrappingKey, Byte[] keyToBeWrapped, string algorithm);
    internal static Byte[] GenerateDerivedKey(Byte[] key, string algorithm, Byte[] label, Byte[] nonce, int derivedKeySize, int position);
    internal static int GetIVSize(string algorithm);
    internal static ICryptoTransform CreateDecryptor(Byte[] key, Byte[] iv, string algorithm);
    internal static ICryptoTransform CreateEncryptor(Byte[] key, Byte[] iv, string algorithm);
    internal static KeyedHashAlgorithm CreateKeyedHashAlgorithm(Byte[] key, string algorithm);
    internal static SymmetricAlgorithm GetSymmetricAlgorithm(Byte[] key, string algorithm);
    internal static bool IsAsymmetricAlgorithm(string algorithm);
    internal static bool IsSymmetricSupportedAlgorithm(string algorithm, int keySize);
}
internal class System.IdentityModel.DictionaryManager : object {
    private SamlDictionary _samlDictionary;
    private XmlSignatureDictionary _sigantureDictionary;
    private UtilityDictionary _utilityDictionary;
    private ExclusiveC14NDictionary _exclusiveC14NDictionary;
    private SecurityAlgorithmDec2005Dictionary _securityAlgorithmDec2005Dictionary;
    private SecurityAlgorithmDictionary _securityAlgorithmDictionary;
    private SecurityJan2004Dictionary _securityJan2004Dictionary;
    private SecurityXXX2005Dictionary _securityJanXXX2005Dictionary;
    private SecureConversationDec2005Dictionary _secureConversationDec2005Dictionary;
    private SecureConversationFeb2005Dictionary _secureConversationFeb2005Dictionary;
    private TrustFeb2005Dictionary _trustFeb2005Dictionary;
    private TrustDec2005Dictionary _trustDec2005Dictionary;
    private XmlEncryptionDictionary _xmlEncryptionDictionary;
    private IXmlDictionary _parentDictionary;
    public SamlDictionary SamlDictionary { get; public set; }
    public XmlSignatureDictionary XmlSignatureDictionary { get; public set; }
    public UtilityDictionary UtilityDictionary { get; public set; }
    public ExclusiveC14NDictionary ExclusiveC14NDictionary { get; public set; }
    public SecurityAlgorithmDec2005Dictionary SecurityAlgorithmDec2005Dictionary { get; public set; }
    public SecurityAlgorithmDictionary SecurityAlgorithmDictionary { get; public set; }
    public SecurityJan2004Dictionary SecurityJan2004Dictionary { get; public set; }
    public SecurityXXX2005Dictionary SecurityJanXXX2005Dictionary { get; public set; }
    public SecureConversationDec2005Dictionary SecureConversationDec2005Dictionary { get; public set; }
    public SecureConversationFeb2005Dictionary SecureConversationFeb2005Dictionary { get; public set; }
    public TrustDec2005Dictionary TrustDec2005Dictionary { get; public set; }
    public TrustFeb2005Dictionary TrustFeb2005Dictionary { get; public set; }
    public XmlEncryptionDictionary XmlEncryptionDictionary { get; public set; }
    public IXmlDictionary ParentDictionary { get; public set; }
    public DictionaryManager(IXmlDictionary parentDictionary);
    public SamlDictionary get_SamlDictionary();
    public void set_SamlDictionary(SamlDictionary value);
    public XmlSignatureDictionary get_XmlSignatureDictionary();
    public void set_XmlSignatureDictionary(XmlSignatureDictionary value);
    public UtilityDictionary get_UtilityDictionary();
    public void set_UtilityDictionary(UtilityDictionary value);
    public ExclusiveC14NDictionary get_ExclusiveC14NDictionary();
    public void set_ExclusiveC14NDictionary(ExclusiveC14NDictionary value);
    public SecurityAlgorithmDec2005Dictionary get_SecurityAlgorithmDec2005Dictionary();
    public void set_SecurityAlgorithmDec2005Dictionary(SecurityAlgorithmDec2005Dictionary value);
    public SecurityAlgorithmDictionary get_SecurityAlgorithmDictionary();
    public void set_SecurityAlgorithmDictionary(SecurityAlgorithmDictionary value);
    public SecurityJan2004Dictionary get_SecurityJan2004Dictionary();
    public void set_SecurityJan2004Dictionary(SecurityJan2004Dictionary value);
    public SecurityXXX2005Dictionary get_SecurityJanXXX2005Dictionary();
    public void set_SecurityJanXXX2005Dictionary(SecurityXXX2005Dictionary value);
    public SecureConversationDec2005Dictionary get_SecureConversationDec2005Dictionary();
    public void set_SecureConversationDec2005Dictionary(SecureConversationDec2005Dictionary value);
    public SecureConversationFeb2005Dictionary get_SecureConversationFeb2005Dictionary();
    public void set_SecureConversationFeb2005Dictionary(SecureConversationFeb2005Dictionary value);
    public TrustDec2005Dictionary get_TrustDec2005Dictionary();
    public void set_TrustDec2005Dictionary(TrustDec2005Dictionary value);
    public TrustFeb2005Dictionary get_TrustFeb2005Dictionary();
    public void set_TrustFeb2005Dictionary(TrustFeb2005Dictionary value);
    public XmlEncryptionDictionary get_XmlEncryptionDictionary();
    public void set_XmlEncryptionDictionary(XmlEncryptionDictionary value);
    public IXmlDictionary get_ParentDictionary();
    public void set_ParentDictionary(IXmlDictionary value);
}
internal static class System.IdentityModel.EmptyReadOnlyCollection`1 : object {
    public static ReadOnlyCollection`1<T> Instance;
    private static EmptyReadOnlyCollection`1();
}
internal class System.IdentityModel.ExclusiveC14NDictionary : object {
    public XmlDictionaryString Namespace;
    public XmlDictionaryString PrefixList;
    public XmlDictionaryString InclusiveNamespaces;
    public XmlDictionaryString Prefix;
    public ExclusiveC14NDictionary(IdentityModelDictionary dictionary);
    public ExclusiveC14NDictionary(IXmlDictionary dictionary);
    private XmlDictionaryString LookupDictionaryString(IXmlDictionary dictionary, string value);
}
internal static class System.IdentityModel.ExclusiveC14NStrings : object {
    public static string Namespace;
    public static string PrefixList;
    public static string InclusiveNamespaces;
    public static string Prefix;
}
internal class System.IdentityModel.HashStream : Stream {
    private bool _disposed;
    private MemoryStream _logStream;
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public bool CanSeek { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public HashStream(HashAlgorithm hash);
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual bool get_CanSeek();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Flush();
    public void FlushHash();
    public void FlushHash(MemoryStream preCanonicalBytes);
    public Byte[] FlushHashAndGetValue();
    public Byte[] FlushHashAndGetValue(MemoryStream preCanonicalBytes);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public void Reset();
    public void Reset(HashAlgorithm hash);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long length);
    protected virtual void Dispose(bool disposing);
}
internal class System.IdentityModel.IdentityModelDictionary : object {
    public static IdentityModelDictionary Version1;
    private IdentityModelStrings _strings;
    private int _count;
    private XmlDictionaryString[] _dictionaryStrings;
    private Dictionary`2<string, int> _dictionary;
    private XmlDictionaryString[] _versionedDictionaryStrings;
    public static IdentityModelDictionary CurrentVersion { get; }
    public IdentityModelDictionary(IdentityModelStrings strings);
    private static IdentityModelDictionary();
    public static IdentityModelDictionary get_CurrentVersion();
    public XmlDictionaryString CreateString(string value, int key);
    public sealed virtual bool TryLookup(string key, XmlDictionaryString& value);
    public sealed virtual bool TryLookup(int key, XmlDictionaryString& value);
    public sealed virtual bool TryLookup(XmlDictionaryString key, XmlDictionaryString& value);
}
[DefaultMemberAttribute("Item")]
internal abstract class System.IdentityModel.IdentityModelStrings : object {
    public int Count { get; }
    public string Item { get; }
    public abstract virtual int get_Count();
    public abstract virtual string get_Item(int index);
}
[DefaultMemberAttribute("Item")]
internal class System.IdentityModel.IdentityModelStringsVersion1 : IdentityModelStrings {
    public static string String0;
    public static string String1;
    public static string String2;
    public static string String3;
    public static string String4;
    public static string String5;
    public static string String6;
    public static string String7;
    public static string String8;
    public static string String9;
    public static string String10;
    public static string String11;
    public static string String12;
    public static string String13;
    public static string String14;
    public static string String15;
    public static string String16;
    public static string String17;
    public static string String18;
    public static string String19;
    public static string String20;
    public static string String21;
    public static string String22;
    public static string String23;
    public static string String24;
    public static string String25;
    public static string String26;
    public static string String27;
    public static string String28;
    public static string String29;
    public static string String30;
    public static string String31;
    public static string String32;
    public static string String33;
    public static string String34;
    public static string String35;
    public static string String36;
    public static string String37;
    public static string String38;
    public static string String39;
    public static string String40;
    public static string String41;
    public static string String42;
    public static string String43;
    public static string String44;
    public static string String45;
    public static string String46;
    public static string String47;
    public static string String48;
    public static string String49;
    public static string String50;
    public static string String51;
    public static string String52;
    public static string String53;
    public static string String54;
    public static string String55;
    public static string String56;
    public static string String57;
    public static string String58;
    public static string String59;
    public static string String60;
    public static string String61;
    public static string String62;
    public static string String63;
    public static string String64;
    public static string String65;
    public static string String66;
    public static string String67;
    public static string String68;
    public static string String69;
    public static string String70;
    public static string String71;
    public static string String72;
    public static string String73;
    public static string String74;
    public static string String75;
    public static string String76;
    public static string String77;
    public static string String78;
    public static string String79;
    public static string String80;
    public static string String81;
    public static string String82;
    public static string String83;
    public static string String84;
    public static string String85;
    public static string String86;
    public static string String87;
    public static string String88;
    public static string String89;
    public static string String90;
    public static string String91;
    public static string String92;
    public static string String93;
    public static string String94;
    public static string String95;
    public static string String96;
    public static string String97;
    public static string String98;
    public static string String99;
    public static string String100;
    public static string String101;
    public static string String102;
    public static string String103;
    public static string String104;
    public static string String105;
    public static string String106;
    public static string String107;
    public static string String108;
    public static string String109;
    public static string String110;
    public static string String111;
    public static string String112;
    public static string String113;
    public static string String114;
    public static string String115;
    public static string String116;
    public static string String117;
    public static string String118;
    public static string String119;
    public static string String120;
    public static string String121;
    public static string String122;
    public static string String123;
    public static string String124;
    public static string String125;
    public static string String126;
    public static string String127;
    public static string String128;
    public static string String129;
    public static string String130;
    public static string String131;
    public static string String132;
    public static string String133;
    public static string String134;
    public static string String135;
    public static string String136;
    public static string String137;
    public static string String138;
    public static string String139;
    public static string String140;
    public static string String141;
    public static string String142;
    public static string String143;
    public static string String144;
    public static string String145;
    public static string String146;
    public static string String147;
    public static string String148;
    public static string String149;
    public static string String150;
    public static string String151;
    public static string String152;
    public static string String153;
    public static string String154;
    public static string String155;
    public static string String156;
    public static string String157;
    public static string String158;
    public static string String159;
    public static string String160;
    public static string String161;
    public static string String162;
    public static string String163;
    public static string String164;
    public static string String165;
    public static string String166;
    public static string String167;
    public static string String168;
    public static string String169;
    public static string String170;
    public static string String171;
    public static string String172;
    public static string String173;
    public static string String174;
    public static string String175;
    public static string String176;
    public static string String177;
    public static string String178;
    public static string String179;
    public static string String180;
    public static string String181;
    public static string String182;
    public static string String183;
    public static string String184;
    public static string String185;
    public static string String186;
    public static string String187;
    public static string String188;
    public static string String189;
    public static string String190;
    public static string String191;
    public static string String192;
    public static string String193;
    public static string String194;
    public static string String195;
    public static string String196;
    public static string String197;
    public static string String198;
    public static string String199;
    public static string String200;
    public static string String201;
    public static string String202;
    public static string String203;
    public static string String204;
    public static string String205;
    public static string String206;
    public static string String207;
    public static string String208;
    public static string String209;
    public static string String210;
    public static string String211;
    public static string String212;
    public static string String213;
    public static string String214;
    public static string String215;
    public static string String216;
    public static string String217;
    public static string String218;
    public static string String219;
    public static string String220;
    public static string String221;
    public static string String222;
    public static string String223;
    public static string String224;
    public static string String225;
    public static string String226;
    public static string String227;
    public static string String228;
    public static string String229;
    public static string String230;
    public static string String231;
    public static string String232;
    public static string String233;
    public static string String234;
    public static string String235;
    public static string String236;
    public static string String237;
    public static string String238;
    public static string String239;
    public static string String240;
    public static string String241;
    public static string String242;
    public static string String243;
    public static string String244;
    public static string String245;
    public static string String246;
    public static string String247;
    public static string String248;
    public static string String249;
    public static string String250;
    public static string String251;
    public static string String252;
    public static string String253;
    public static string String254;
    public static string String255;
    public static string String256;
    public static string String257;
    public static string String258;
    public static string String259;
    public static string String260;
    public static string String261;
    public static string String262;
    public static string String263;
    public static string String264;
    public static string String265;
    public static string String266;
    public static string String267;
    public static string String268;
    public static string String269;
    public static string String270;
    public static string String271;
    public static string String272;
    public static string String273;
    public static string String274;
    public static string String275;
    public static string String276;
    public static string String277;
    public static string String278;
    public int Count { get; }
    public string Item { get; }
    public virtual int get_Count();
    public virtual string get_Item(int index);
}
internal interface System.IdentityModel.ISecurityElement {
    public bool HasId { get; }
    public string Id { get; }
    public abstract virtual bool get_HasId();
    public abstract virtual string get_Id();
    public abstract virtual void WriteTo(XmlDictionaryWriter writer, DictionaryManager dictionaryManager);
}
internal interface System.IdentityModel.ISignatureValueSecurityElement {
    public abstract virtual Byte[] GetSignatureValue();
}
public abstract class System.IdentityModel.Policy.AuthorizationContext : object {
    public string Id { get; }
    public ReadOnlyCollection`1<ClaimSet> ClaimSets { get; }
    public DateTime ExpirationTime { get; }
    public IDictionary`2<string, object> Properties { get; }
    public abstract virtual string get_Id();
    public abstract virtual ReadOnlyCollection`1<ClaimSet> get_ClaimSets();
    public abstract virtual DateTime get_ExpirationTime();
    public abstract virtual IDictionary`2<string, object> get_Properties();
    public static AuthorizationContext CreateDefaultAuthorizationContext(IList`1<IAuthorizationPolicy> authorizationPolicies);
}
internal class System.IdentityModel.Policy.DefaultAuthorizationContext : AuthorizationContext {
    private static DefaultAuthorizationContext s_empty;
    private SecurityUniqueId _id;
    private ReadOnlyCollection`1<ClaimSet> _claimSets;
    private DateTime _expirationTime;
    private IDictionary`2<string, object> _properties;
    public static DefaultAuthorizationContext Empty { get; }
    public string Id { get; }
    public ReadOnlyCollection`1<ClaimSet> ClaimSets { get; }
    public DateTime ExpirationTime { get; }
    public IDictionary`2<string, object> Properties { get; }
    public DefaultAuthorizationContext(DefaultEvaluationContext evaluationContext);
    public static DefaultAuthorizationContext get_Empty();
    public virtual string get_Id();
    public virtual ReadOnlyCollection`1<ClaimSet> get_ClaimSets();
    public virtual DateTime get_ExpirationTime();
    public virtual IDictionary`2<string, object> get_Properties();
}
internal class System.IdentityModel.Policy.DefaultEvaluationContext : EvaluationContext {
    private List`1<ClaimSet> _claimSets;
    private Dictionary`2<string, object> _properties;
    private DateTime _expirationTime;
    private int _generation;
    private ReadOnlyCollection`1<ClaimSet> _readOnlyClaimSets;
    public int Generation { get; }
    public ReadOnlyCollection`1<ClaimSet> ClaimSets { get; }
    public IDictionary`2<string, object> Properties { get; }
    public DateTime ExpirationTime { get; }
    public virtual int get_Generation();
    public virtual ReadOnlyCollection`1<ClaimSet> get_ClaimSets();
    public virtual IDictionary`2<string, object> get_Properties();
    public DateTime get_ExpirationTime();
    public virtual void AddClaimSet(IAuthorizationPolicy policy, ClaimSet claimSet);
    public virtual void RecordExpirationTime(DateTime expirationTime);
}
public abstract class System.IdentityModel.Policy.EvaluationContext : object {
    public ReadOnlyCollection`1<ClaimSet> ClaimSets { get; }
    public IDictionary`2<string, object> Properties { get; }
    public int Generation { get; }
    public abstract virtual ReadOnlyCollection`1<ClaimSet> get_ClaimSets();
    public abstract virtual IDictionary`2<string, object> get_Properties();
    public abstract virtual int get_Generation();
    public abstract virtual void AddClaimSet(IAuthorizationPolicy policy, ClaimSet claimSet);
    public abstract virtual void RecordExpirationTime(DateTime expirationTime);
}
public interface System.IdentityModel.Policy.IAuthorizationComponent {
    public string Id { get; }
    public abstract virtual string get_Id();
}
public interface System.IdentityModel.Policy.IAuthorizationPolicy {
    public ClaimSet Issuer { get; }
    public abstract virtual ClaimSet get_Issuer();
    public abstract virtual bool Evaluate(EvaluationContext evaluationContext, Object& state);
}
internal interface System.IdentityModel.Policy.IIdentityInfo {
    public IIdentity Identity { get; }
    public abstract virtual IIdentity get_Identity();
}
internal class System.IdentityModel.Policy.UnconditionalPolicy : object {
    private SecurityUniqueId _id;
    private ClaimSet _issuer;
    private ClaimSet _issuance;
    private ReadOnlyCollection`1<ClaimSet> _issuances;
    private DateTime _expirationTime;
    private IIdentity _primaryIdentity;
    private bool _disposable;
    private bool _disposed;
    public string Id { get; }
    public ClaimSet Issuer { get; }
    internal IIdentity PrimaryIdentity { get; }
    internal ReadOnlyCollection`1<ClaimSet> Issuances { get; }
    public DateTime ExpirationTime { get; }
    internal bool IsDisposable { get; }
    public UnconditionalPolicy(ClaimSet issuance);
    public UnconditionalPolicy(ClaimSet issuance, DateTime expirationTime);
    public UnconditionalPolicy(ReadOnlyCollection`1<ClaimSet> issuances, DateTime expirationTime);
    internal UnconditionalPolicy(IIdentity primaryIdentity, ClaimSet issuance);
    internal UnconditionalPolicy(IIdentity primaryIdentity, ClaimSet issuance, DateTime expirationTime);
    internal UnconditionalPolicy(IIdentity primaryIdentity, ReadOnlyCollection`1<ClaimSet> issuances, DateTime expirationTime);
    private UnconditionalPolicy(UnconditionalPolicy from);
    private void Initialize(ClaimSet issuer, ClaimSet issuance, ReadOnlyCollection`1<ClaimSet> issuances, DateTime expirationTime);
    public sealed virtual string get_Id();
    public sealed virtual ClaimSet get_Issuer();
    internal IIdentity get_PrimaryIdentity();
    internal ReadOnlyCollection`1<ClaimSet> get_Issuances();
    public DateTime get_ExpirationTime();
    internal bool get_IsDisposable();
    internal UnconditionalPolicy Clone();
    public virtual void Dispose();
    private void ThrowIfDisposed();
    public virtual bool Evaluate(EvaluationContext evaluationContext, Object& state);
}
internal class System.IdentityModel.SamlDictionary : object {
    public XmlDictionaryString Access;
    public XmlDictionaryString AccessDecision;
    public XmlDictionaryString Action;
    public XmlDictionaryString Advice;
    public XmlDictionaryString Assertion;
    public XmlDictionaryString AssertionId;
    public XmlDictionaryString AssertionIdReference;
    public XmlDictionaryString Attribute;
    public XmlDictionaryString AttributeName;
    public XmlDictionaryString AttributeNamespace;
    public XmlDictionaryString AttributeStatement;
    public XmlDictionaryString AttributeValue;
    public XmlDictionaryString Audience;
    public XmlDictionaryString AudienceRestrictionCondition;
    public XmlDictionaryString AuthenticationInstant;
    public XmlDictionaryString AuthenticationMethod;
    public XmlDictionaryString AuthenticationStatement;
    public XmlDictionaryString AuthorityBinding;
    public XmlDictionaryString AuthorityKind;
    public XmlDictionaryString AuthorizationDecisionStatement;
    public XmlDictionaryString Binding;
    public XmlDictionaryString Condition;
    public XmlDictionaryString Conditions;
    public XmlDictionaryString Decision;
    public XmlDictionaryString DoNotCacheCondition;
    public XmlDictionaryString Evidence;
    public XmlDictionaryString IssueInstant;
    public XmlDictionaryString Issuer;
    public XmlDictionaryString Location;
    public XmlDictionaryString MajorVersion;
    public XmlDictionaryString MinorVersion;
    public XmlDictionaryString Namespace;
    public XmlDictionaryString NameIdentifier;
    public XmlDictionaryString NameIdentifierFormat;
    public XmlDictionaryString NameIdentifierNameQualifier;
    public XmlDictionaryString ActionNamespaceAttribute;
    public XmlDictionaryString NotBefore;
    public XmlDictionaryString NotOnOrAfter;
    public XmlDictionaryString PreferredPrefix;
    public XmlDictionaryString Statement;
    public XmlDictionaryString Subject;
    public XmlDictionaryString SubjectConfirmation;
    public XmlDictionaryString SubjectConfirmationData;
    public XmlDictionaryString SubjectConfirmationMethod;
    public XmlDictionaryString HolderOfKey;
    public XmlDictionaryString SenderVouches;
    public XmlDictionaryString SubjectLocality;
    public XmlDictionaryString SubjectLocalityDNSAddress;
    public XmlDictionaryString SubjectLocalityIPAddress;
    public XmlDictionaryString SubjectStatement;
    public XmlDictionaryString UnspecifiedAuthenticationMethod;
    public XmlDictionaryString NamespaceAttributePrefix;
    public XmlDictionaryString Resource;
    public XmlDictionaryString UserName;
    public XmlDictionaryString UserNameNamespace;
    public XmlDictionaryString EmailName;
    public XmlDictionaryString EmailNamespace;
    public SamlDictionary(IdentityModelDictionary dictionary);
    public SamlDictionary(IXmlDictionary dictionary);
    private XmlDictionaryString LookupDictionaryString(IXmlDictionary dictionary, string value);
}
internal static class System.IdentityModel.SamlStrings : object {
    public static string Access;
    public static string AccessDecision;
    public static string Action;
    public static string Advice;
    public static string Assertion;
    public static string AssertionId;
    public static string AssertionIdReference;
    public static string Attribute;
    public static string AttributeName;
    public static string AttributeNamespace;
    public static string AttributeStatement;
    public static string AttributeValue;
    public static string Audience;
    public static string AudienceRestrictionCondition;
    public static string AuthenticationInstant;
    public static string AuthenticationMethod;
    public static string AuthenticationStatement;
    public static string AuthorityBinding;
    public static string AuthorityKind;
    public static string AuthorizationDecisionStatement;
    public static string Binding;
    public static string Condition;
    public static string Conditions;
    public static string Decision;
    public static string DoNotCacheCondition;
    public static string Evidence;
    public static string IssueInstant;
    public static string Issuer;
    public static string Location;
    public static string MajorVersion;
    public static string MinorVersion;
    public static string Namespace;
    public static string NameIdentifier;
    public static string NameIdentifierFormat;
    public static string NameIdentifierNameQualifier;
    public static string ActionNamespaceAttribute;
    public static string NotBefore;
    public static string NotOnOrAfter;
    public static string PreferredPrefix;
    public static string Statement;
    public static string Subject;
    public static string SubjectConfirmation;
    public static string SubjectConfirmationData;
    public static string SubjectConfirmationMethod;
    public static string HolderOfKey;
    public static string SenderVouches;
    public static string SubjectLocality;
    public static string SubjectLocalityDNSAddress;
    public static string SubjectLocalityIPAddress;
    public static string SubjectStatement;
    public static string UnspecifiedAuthenticationMethod;
    public static string NamespaceAttributePrefix;
    public static string Resource;
    public static string UserName;
    public static string UserNameNamespace;
    public static string EmailName;
    public static string EmailNamespace;
}
internal class System.IdentityModel.SecureConversationDec2005Dictionary : SecureConversationDictionary {
    public SecureConversationDec2005Dictionary(IdentityModelDictionary dictionary);
    public SecureConversationDec2005Dictionary(IXmlDictionary dictionary);
    private XmlDictionaryString LookupDictionaryString(IXmlDictionary dictionary, string value);
}
internal static class System.IdentityModel.SecureConversationDec2005Strings : object {
    public static string SecurityContextToken;
    public static string AlgorithmAttribute;
    public static string Generation;
    public static string Label;
    public static string Offset;
    public static string Properties;
    public static string Identifier;
    public static string Cookie;
    public static string RenewNeededFaultCode;
    public static string BadContextTokenFaultCode;
    public static string Prefix;
    public static string DerivedKeyTokenType;
    public static string SecurityContextTokenType;
    public static string SecurityContextTokenReferenceValueType;
    public static string RequestSecurityContextIssuance;
    public static string RequestSecurityContextIssuanceResponse;
    public static string RequestSecurityContextRenew;
    public static string RequestSecurityContextRenewResponse;
    public static string RequestSecurityContextClose;
    public static string RequestSecurityContextCloseResponse;
    public static string Namespace;
    public static string DerivedKeyToken;
    public static string Nonce;
    public static string Length;
    public static string Instance;
}
internal class System.IdentityModel.SecureConversationDictionary : object {
    public XmlDictionaryString Namespace;
    public XmlDictionaryString DerivedKeyToken;
    public XmlDictionaryString Nonce;
    public XmlDictionaryString Length;
    public XmlDictionaryString SecurityContextToken;
    public XmlDictionaryString AlgorithmAttribute;
    public XmlDictionaryString Generation;
    public XmlDictionaryString Label;
    public XmlDictionaryString Offset;
    public XmlDictionaryString Properties;
    public XmlDictionaryString Identifier;
    public XmlDictionaryString Cookie;
    public XmlDictionaryString RenewNeededFaultCode;
    public XmlDictionaryString BadContextTokenFaultCode;
    public XmlDictionaryString Prefix;
    public XmlDictionaryString DerivedKeyTokenType;
    public XmlDictionaryString SecurityContextTokenType;
    public XmlDictionaryString SecurityContextTokenReferenceValueType;
    public XmlDictionaryString RequestSecurityContextIssuance;
    public XmlDictionaryString RequestSecurityContextIssuanceResponse;
    public XmlDictionaryString RequestSecurityContextRenew;
    public XmlDictionaryString RequestSecurityContextRenewResponse;
    public XmlDictionaryString RequestSecurityContextClose;
    public XmlDictionaryString RequestSecurityContextCloseResponse;
    public XmlDictionaryString Instance;
    public SecureConversationDictionary(IdentityModelDictionary dictionary);
    public SecureConversationDictionary(IXmlDictionary dictionary);
    private XmlDictionaryString LookupDictionaryString(IXmlDictionary dictionary, string value);
}
internal class System.IdentityModel.SecureConversationFeb2005Dictionary : SecureConversationDictionary {
    public SecureConversationFeb2005Dictionary(IdentityModelDictionary dictionary);
    public SecureConversationFeb2005Dictionary(IXmlDictionary dictionary);
    private XmlDictionaryString LookupDictionaryString(IXmlDictionary dictionary, string value);
}
internal static class System.IdentityModel.SecureConversationFeb2005Strings : object {
    public static string Namespace;
    public static string DerivedKeyToken;
    public static string Nonce;
    public static string Length;
    public static string SecurityContextToken;
    public static string AlgorithmAttribute;
    public static string Generation;
    public static string Label;
    public static string Offset;
    public static string Properties;
    public static string Identifier;
    public static string Cookie;
    public static string RenewNeededFaultCode;
    public static string BadContextTokenFaultCode;
    public static string Prefix;
    public static string DerivedKeyTokenType;
    public static string SecurityContextTokenType;
    public static string SecurityContextTokenReferenceValueType;
    public static string RequestSecurityContextIssuance;
    public static string RequestSecurityContextIssuanceResponse;
    public static string RequestSecurityContextRenew;
    public static string RequestSecurityContextRenewResponse;
    public static string RequestSecurityContextClose;
    public static string RequestSecurityContextCloseResponse;
}
internal static class System.IdentityModel.SecureConversationStrings : object {
}
internal class System.IdentityModel.SecurityAlgorithmDec2005Dictionary : object {
    public XmlDictionaryString Psha1KeyDerivationDec2005;
    public SecurityAlgorithmDec2005Dictionary(IdentityModelDictionary dictionary);
    public SecurityAlgorithmDec2005Dictionary(IXmlDictionary dictionary);
    private XmlDictionaryString LookupDictionaryString(IXmlDictionary dictionary, string value);
}
internal static class System.IdentityModel.SecurityAlgorithmDec2005Strings : object {
    public static string Psha1KeyDerivationDec2005;
}
internal class System.IdentityModel.SecurityAlgorithmDictionary : object {
    public XmlDictionaryString Aes128Encryption;
    public XmlDictionaryString Aes128KeyWrap;
    public XmlDictionaryString Aes192Encryption;
    public XmlDictionaryString Aes192KeyWrap;
    public XmlDictionaryString Aes256Encryption;
    public XmlDictionaryString Aes256KeyWrap;
    public XmlDictionaryString DesEncryption;
    public XmlDictionaryString DsaSha1Signature;
    public XmlDictionaryString ExclusiveC14n;
    public XmlDictionaryString ExclusiveC14nWithComments;
    public XmlDictionaryString HmacSha1Signature;
    public XmlDictionaryString HmacSha256Signature;
    public XmlDictionaryString Psha1KeyDerivation;
    public XmlDictionaryString Ripemd160Digest;
    public XmlDictionaryString RsaOaepKeyWrap;
    public XmlDictionaryString RsaSha1Signature;
    public XmlDictionaryString RsaSha256Signature;
    public XmlDictionaryString RsaV15KeyWrap;
    public XmlDictionaryString Sha1Digest;
    public XmlDictionaryString Sha256Digest;
    public XmlDictionaryString Sha512Digest;
    public XmlDictionaryString TripleDesEncryption;
    public XmlDictionaryString TripleDesKeyWrap;
    public XmlDictionaryString TlsSspiKeyWrap;
    public XmlDictionaryString WindowsSspiKeyWrap;
    public SecurityAlgorithmDictionary(IdentityModelDictionary dictionary);
    public SecurityAlgorithmDictionary(IXmlDictionary dictionary);
    private XmlDictionaryString LookupDictionaryString(IXmlDictionary dictionary, string value);
}
internal static class System.IdentityModel.SecurityAlgorithmStrings : object {
    public static string Aes128Encryption;
    public static string Aes128KeyWrap;
    public static string Aes192Encryption;
    public static string Aes192KeyWrap;
    public static string Aes256Encryption;
    public static string Aes256KeyWrap;
    public static string DesEncryption;
    public static string DsaSha1Signature;
    public static string ExclusiveC14n;
    public static string ExclusiveC14nWithComments;
    public static string HmacSha1Signature;
    public static string HmacSha256Signature;
    public static string Psha1KeyDerivation;
    public static string Ripemd160Digest;
    public static string RsaOaepKeyWrap;
    public static string RsaSha1Signature;
    public static string RsaSha256Signature;
    public static string RsaV15KeyWrap;
    public static string Sha1Digest;
    public static string Sha256Digest;
    public static string Sha512Digest;
    public static string TripleDesEncryption;
    public static string TripleDesKeyWrap;
    public static string TlsSspiKeyWrap;
    public static string WindowsSspiKeyWrap;
    public static string StrTransform;
}
internal class System.IdentityModel.SecurityJan2004Dictionary : object {
    public XmlDictionaryString Prefix;
    public XmlDictionaryString NonceElement;
    public XmlDictionaryString PasswordElement;
    public XmlDictionaryString PasswordTextName;
    public XmlDictionaryString UserNameElement;
    public XmlDictionaryString UserNameTokenElement;
    public XmlDictionaryString BinarySecurityToken;
    public XmlDictionaryString EncodingType;
    public XmlDictionaryString Reference;
    public XmlDictionaryString URI;
    public XmlDictionaryString KeyIdentifier;
    public XmlDictionaryString EncodingTypeValueBase64Binary;
    public XmlDictionaryString EncodingTypeValueHexBinary;
    public XmlDictionaryString EncodingTypeValueText;
    public XmlDictionaryString X509SKIValueType;
    public XmlDictionaryString KerberosTokenTypeGSS;
    public XmlDictionaryString KerberosTokenType1510;
    public XmlDictionaryString SamlAssertionIdValueType;
    public XmlDictionaryString SamlAssertion;
    public XmlDictionaryString SamlUri;
    public XmlDictionaryString RelAssertionValueType;
    public XmlDictionaryString FailedAuthenticationFaultCode;
    public XmlDictionaryString InvalidSecurityTokenFaultCode;
    public XmlDictionaryString InvalidSecurityFaultCode;
    public XmlDictionaryString SecurityTokenReference;
    public XmlDictionaryString Namespace;
    public XmlDictionaryString Security;
    public XmlDictionaryString ValueType;
    public XmlDictionaryString TypeAttribute;
    public XmlDictionaryString KerberosHashValueType;
    public SecurityJan2004Dictionary(IdentityModelDictionary dictionary);
    public SecurityJan2004Dictionary(IXmlDictionary dictionary);
    private XmlDictionaryString LookupDictionaryString(IXmlDictionary dictionary, string value);
}
internal static class System.IdentityModel.SecurityJan2004Strings : object {
    public static string Prefix;
    public static string NonceElement;
    public static string PasswordElement;
    public static string PasswordTextName;
    public static string UserNameElement;
    public static string UserNameTokenElement;
    public static string BinarySecurityToken;
    public static string EncodingType;
    public static string Reference;
    public static string URI;
    public static string KeyIdentifier;
    public static string EncodingTypeValueBase64Binary;
    public static string EncodingTypeValueHexBinary;
    public static string EncodingTypeValueText;
    public static string X509SKIValueType;
    public static string KerberosTokenTypeGSS;
    public static string KerberosTokenType1510;
    public static string SamlAssertionIdValueType;
    public static string SamlAssertion;
    public static string SamlUri;
    public static string RelAssertionValueType;
    public static string FailedAuthenticationFaultCode;
    public static string InvalidSecurityTokenFaultCode;
    public static string InvalidSecurityFaultCode;
    public static string SecurityTokenReference;
    public static string Namespace;
    public static string Security;
    public static string ValueType;
    public static string TypeAttribute;
    public static string KerberosHashValueType;
    public static string SecurityProfileNamespace;
    public static string X509TokenProfileNamespace;
    public static string UPTokenProfileNamespace;
    public static string SamlTokenProfileNamespace;
    public static string KerberosTokenProfileNamespace;
    public static string UPTokenType;
    public static string X509TokenType;
    public static string UPTokenPasswordTextValue;
}
public class System.IdentityModel.SecurityMessageSerializationException : Exception {
    public SecurityMessageSerializationException(string message);
    public SecurityMessageSerializationException(string message, Exception innerException);
    protected SecurityMessageSerializationException(SerializationInfo info, StreamingContext context);
}
internal class System.IdentityModel.SecurityUniqueId : object {
    private static long s_nextId;
    private static string s_commonPrefix;
    private long _id;
    private string _prefix;
    private string _val;
    public string Value { get; }
    private SecurityUniqueId(string prefix, long id);
    private static SecurityUniqueId();
    public static SecurityUniqueId Create();
    public static SecurityUniqueId Create(string prefix);
    public string get_Value();
}
internal static class System.IdentityModel.SecurityUtils : object {
    public static string Identities;
    private static IIdentity s_anonymousIdentity;
    public static string AuthTypeNTLM;
    public static string AuthTypeNegotiate;
    public static string AuthTypeKerberos;
    public static string AuthTypeAnonymous;
    public static string AuthTypeCertMap;
    public static string AuthTypeBasic;
    internal static IIdentity AnonymousIdentity { get; }
    public static DateTime MaxUtcDateTime { get; }
    public static DateTime MinUtcDateTime { get; }
    internal static IIdentity get_AnonymousIdentity();
    public static DateTime get_MaxUtcDateTime();
    public static DateTime get_MinUtcDateTime();
    internal static IIdentity CreateIdentity(string name, string authenticationType);
    internal static IIdentity CreateIdentity(string name);
    internal static Byte[] CloneBuffer(Byte[] buffer);
    internal static Byte[] CloneBuffer(Byte[] buffer, int offset, int len);
    internal static bool MatchesBuffer(Byte[] src, Byte[] dst);
    internal static bool MatchesBuffer(Byte[] src, int srcOffset, Byte[] dst, int dstOffset);
    internal static ReadOnlyCollection`1<IAuthorizationPolicy> CreateAuthorizationPolicies(ClaimSet claimSet);
    internal static ReadOnlyCollection`1<IAuthorizationPolicy> CreateAuthorizationPolicies(ClaimSet claimSet, DateTime expirationTime);
    internal static AuthorizationContext CreateDefaultAuthorizationContext(IList`1<IAuthorizationPolicy> authorizationPolicies);
    internal static string ClaimSetToString(ClaimSet claimSet);
    internal static IIdentity CloneIdentityIfNecessary(IIdentity identity);
    internal static WindowsIdentity CloneWindowsIdentityIfNecessary(WindowsIdentity wid);
    internal static WindowsIdentity CloneWindowsIdentityIfNecessary(WindowsIdentity wid, string authenticationType);
    private static IntPtr UnsafeGetWindowsIdentityToken(WindowsIdentity wid);
    private static WindowsIdentity UnsafeCreateWindowsIdentityFromToken(IntPtr token, string authenticationType);
    internal static ClaimSet CloneClaimSetIfNecessary(ClaimSet claimSet);
    internal static ReadOnlyCollection`1<ClaimSet> CloneClaimSetsIfNecessary(ReadOnlyCollection`1<ClaimSet> claimSets);
    internal static void DisposeClaimSetIfNecessary(ClaimSet claimSet);
    internal static void DisposeClaimSetsIfNecessary(ReadOnlyCollection`1<ClaimSet> claimSets);
    internal static string GetCertificateId(X509Certificate2 certificate);
    internal static void AppendCertificateIdentityName(StringBuilder str, X509Certificate2 certificate);
    internal static ReadOnlyCollection`1<IAuthorizationPolicy> CloneAuthorizationPoliciesIfNecessary(ReadOnlyCollection`1<IAuthorizationPolicy> authorizationPolicies);
    public static void DisposeAuthorizationPoliciesIfNecessary(ReadOnlyCollection`1<IAuthorizationPolicy> authorizationPolicies);
    public static void DisposeIfNecessary(IDisposable obj);
    internal static void ResetAllCertificates(X509Certificate2Collection certificates);
    internal static void ResetCertificate(X509Certificate2 certificate);
}
internal class System.IdentityModel.SecurityXXX2005Dictionary : object {
    public XmlDictionaryString Prefix;
    public XmlDictionaryString SignatureConfirmation;
    public XmlDictionaryString ValueAttribute;
    public XmlDictionaryString TokenTypeAttribute;
    public XmlDictionaryString ThumbprintSha1ValueType;
    public XmlDictionaryString EncryptedKeyTokenType;
    public XmlDictionaryString EncryptedKeyHashValueType;
    public XmlDictionaryString SamlTokenType;
    public XmlDictionaryString Saml20TokenType;
    public XmlDictionaryString Saml11AssertionValueType;
    public XmlDictionaryString EncryptedHeader;
    public XmlDictionaryString Namespace;
    public SecurityXXX2005Dictionary(IdentityModelDictionary dictionary);
    public SecurityXXX2005Dictionary(IXmlDictionary dictionary);
    private XmlDictionaryString LookupDictionaryString(IXmlDictionary dictionary, string value);
}
internal static class System.IdentityModel.SecurityXXX2005Strings : object {
    public static string Prefix;
    public static string SignatureConfirmation;
    public static string ValueAttribute;
    public static string TokenTypeAttribute;
    public static string ThumbprintSha1ValueType;
    public static string EncryptedKeyTokenType;
    public static string EncryptedKeyHashValueType;
    public static string SamlTokenType;
    public static string Saml20TokenType;
    public static string Saml11AssertionValueType;
    public static string EncryptedHeader;
    public static string Namespace;
    public static string SecurityProfileNamespace;
    public static string SamlTokenProfileNamespace;
    public static string X509TokenProfileNamespace;
}
public class System.IdentityModel.Selectors.KerberosSecurityTokenProvider : SecurityTokenProvider {
    private string _servicePrincipalName;
    private TokenImpersonationLevel _tokenImpersonationLevel;
    private NetworkCredential _networkCredential;
    public string ServicePrincipalName { get; }
    public TokenImpersonationLevel TokenImpersonationLevel { get; }
    public NetworkCredential NetworkCredential { get; }
    public KerberosSecurityTokenProvider(string servicePrincipalName);
    public KerberosSecurityTokenProvider(string servicePrincipalName, TokenImpersonationLevel tokenImpersonationLevel);
    public KerberosSecurityTokenProvider(string servicePrincipalName, TokenImpersonationLevel tokenImpersonationLevel, NetworkCredential networkCredential);
    public string get_ServicePrincipalName();
    public TokenImpersonationLevel get_TokenImpersonationLevel();
    public NetworkCredential get_NetworkCredential();
    internal SecurityToken GetToken(CancellationToken cancellationToken, ChannelBinding channelbinding);
    protected virtual Task`1<SecurityToken> GetTokenCoreAsync(CancellationToken cancellationToken);
}
public abstract class System.IdentityModel.Selectors.SecurityTokenAuthenticator : object {
    public bool CanValidateToken(SecurityToken token);
    public ReadOnlyCollection`1<IAuthorizationPolicy> ValidateToken(SecurityToken token);
    protected abstract virtual bool CanValidateTokenCore(SecurityToken token);
    protected abstract virtual ReadOnlyCollection`1<IAuthorizationPolicy> ValidateTokenCore(SecurityToken token);
}
public abstract class System.IdentityModel.Selectors.SecurityTokenManager : object {
    public abstract virtual SecurityTokenProvider CreateSecurityTokenProvider(SecurityTokenRequirement tokenRequirement);
    public abstract virtual SecurityTokenSerializer CreateSecurityTokenSerializer(SecurityTokenVersion version);
    public abstract virtual SecurityTokenAuthenticator CreateSecurityTokenAuthenticator(SecurityTokenRequirement tokenRequirement, SecurityTokenResolver& outOfBandTokenResolver);
}
public abstract class System.IdentityModel.Selectors.SecurityTokenProvider : object {
    public bool SupportsTokenRenewal { get; }
    public bool SupportsTokenCancellation { get; }
    public virtual bool get_SupportsTokenRenewal();
    public virtual bool get_SupportsTokenCancellation();
    [AsyncStateMachineAttribute("System.IdentityModel.Selectors.SecurityTokenProvider/<GetTokenAsync>d__5")]
public Task`1<SecurityToken> GetTokenAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.IdentityModel.Selectors.SecurityTokenProvider/<RenewTokenAsync>d__6")]
public Task`1<SecurityToken> RenewTokenAsync(CancellationToken cancellationToken, SecurityToken tokenToBeRenewed);
    [AsyncStateMachineAttribute("System.IdentityModel.Selectors.SecurityTokenProvider/<CancelTokenAsync>d__7")]
public Task CancelTokenAsync(CancellationToken cancellationToken, SecurityToken securityToken);
    protected abstract virtual Task`1<SecurityToken> GetTokenCoreAsync(CancellationToken cancellationToken);
    protected virtual Task`1<SecurityToken> RenewTokenCoreAsync(CancellationToken cancellationToken, SecurityToken tokenToBeRenewed);
    protected virtual Task CancelTokenCoreAsync(CancellationToken cancellationToken, SecurityToken token);
}
public class System.IdentityModel.Selectors.SecurityTokenRequirement : object {
    private static string Namespace;
    private static string tokenTypeProperty;
    private static string keyUsageProperty;
    private static string keyTypeProperty;
    private static string keySizeProperty;
    private static string requireCryptographicTokenProperty;
    private static string peerAuthenticationMode;
    private static string isOptionalTokenProperty;
    private static bool defaultRequireCryptographicToken;
    private static SecurityKeyUsage defaultKeyUsage;
    private static SecurityKeyType defaultKeyType;
    private static int defaultKeySize;
    private static bool defaultIsOptionalToken;
    private Dictionary`2<string, object> _properties;
    public static string TokenTypeProperty { get; }
    public static string KeyUsageProperty { get; }
    public static string KeyTypeProperty { get; }
    public static string KeySizeProperty { get; }
    public static string RequireCryptographicTokenProperty { get; }
    public static string PeerAuthenticationMode { get; }
    public static string IsOptionalTokenProperty { get; }
    public string TokenType { get; public set; }
    internal bool IsOptionalToken { get; internal set; }
    public bool RequireCryptographicToken { get; public set; }
    public SecurityKeyUsage KeyUsage { get; public set; }
    public SecurityKeyType KeyType { get; public set; }
    public int KeySize { get; public set; }
    public IDictionary`2<string, object> Properties { get; }
    public static string get_TokenTypeProperty();
    public static string get_KeyUsageProperty();
    public static string get_KeyTypeProperty();
    public static string get_KeySizeProperty();
    public static string get_RequireCryptographicTokenProperty();
    public static string get_PeerAuthenticationMode();
    public static string get_IsOptionalTokenProperty();
    public string get_TokenType();
    public void set_TokenType(string value);
    internal bool get_IsOptionalToken();
    internal void set_IsOptionalToken(bool value);
    public bool get_RequireCryptographicToken();
    public void set_RequireCryptographicToken(bool value);
    public SecurityKeyUsage get_KeyUsage();
    public void set_KeyUsage(SecurityKeyUsage value);
    public SecurityKeyType get_KeyType();
    public void set_KeyType(SecurityKeyType value);
    public int get_KeySize();
    public void set_KeySize(int value);
    public IDictionary`2<string, object> get_Properties();
    private void Initialize();
    public TValue GetProperty(string propertyName);
    public bool TryGetProperty(string propertyName, TValue& result);
}
public abstract class System.IdentityModel.Selectors.SecurityTokenResolver : object {
}
public abstract class System.IdentityModel.Selectors.SecurityTokenSerializer : object {
    public bool CanReadToken(XmlReader reader);
    public bool CanWriteToken(SecurityToken token);
    public bool CanReadKeyIdentifier(XmlReader reader);
    public bool CanWriteKeyIdentifier(SecurityKeyIdentifier keyIdentifier);
    public bool CanReadKeyIdentifierClause(XmlReader reader);
    public bool CanWriteKeyIdentifierClause(SecurityKeyIdentifierClause keyIdentifierClause);
    public SecurityToken ReadToken(XmlReader reader, SecurityTokenResolver tokenResolver);
    public void WriteToken(XmlWriter writer, SecurityToken token);
    public SecurityKeyIdentifier ReadKeyIdentifier(XmlReader reader);
    public void WriteKeyIdentifier(XmlWriter writer, SecurityKeyIdentifier keyIdentifier);
    public SecurityKeyIdentifierClause ReadKeyIdentifierClause(XmlReader reader);
    public void WriteKeyIdentifierClause(XmlWriter writer, SecurityKeyIdentifierClause keyIdentifierClause);
    protected abstract virtual bool CanReadTokenCore(XmlReader reader);
    protected abstract virtual bool CanWriteTokenCore(SecurityToken token);
    protected abstract virtual bool CanReadKeyIdentifierCore(XmlReader reader);
    protected abstract virtual bool CanWriteKeyIdentifierCore(SecurityKeyIdentifier keyIdentifier);
    protected abstract virtual bool CanReadKeyIdentifierClauseCore(XmlReader reader);
    protected abstract virtual bool CanWriteKeyIdentifierClauseCore(SecurityKeyIdentifierClause keyIdentifierClause);
    protected abstract virtual SecurityToken ReadTokenCore(XmlReader reader, SecurityTokenResolver tokenResolver);
    protected abstract virtual void WriteTokenCore(XmlWriter writer, SecurityToken token);
    protected abstract virtual SecurityKeyIdentifier ReadKeyIdentifierCore(XmlReader reader);
    protected abstract virtual void WriteKeyIdentifierCore(XmlWriter writer, SecurityKeyIdentifier keyIdentifier);
    protected abstract virtual SecurityKeyIdentifierClause ReadKeyIdentifierClauseCore(XmlReader reader);
    protected abstract virtual void WriteKeyIdentifierClauseCore(XmlWriter writer, SecurityKeyIdentifierClause keyIdentifierClause);
}
public abstract class System.IdentityModel.Selectors.SecurityTokenVersion : object {
    public abstract virtual ReadOnlyCollection`1<string> GetSecuritySpecifications();
}
public class System.IdentityModel.Selectors.UserNameSecurityTokenProvider : SecurityTokenProvider {
    private UserNameSecurityToken _userNameToken;
    public UserNameSecurityTokenProvider(string userName, string password);
    protected virtual Task`1<SecurityToken> GetTokenCoreAsync(CancellationToken cancellationToken);
}
public class System.IdentityModel.Selectors.WindowsSecurityTokenAuthenticator : SecurityTokenAuthenticator {
    private bool _includeWindowsGroups;
    public WindowsSecurityTokenAuthenticator(bool includeWindowsGroups);
    protected virtual bool CanValidateTokenCore(SecurityToken token);
    protected virtual ReadOnlyCollection`1<IAuthorizationPolicy> ValidateTokenCore(SecurityToken token);
}
internal class System.IdentityModel.Selectors.X509CertificateChain : object {
    public static UInt32 DefaultChainPolicyOID;
}
public abstract class System.IdentityModel.Selectors.X509CertificateValidator : object {
    private static X509CertificateValidator s_peerTrust;
    private static X509CertificateValidator s_chainTrust;
    private static X509CertificateValidator s_peerOrChainTrust;
    private static X509CertificateValidator s_none;
    public static X509CertificateValidator None { get; }
    public static X509CertificateValidator PeerTrust { get; }
    public static X509CertificateValidator ChainTrust { get; }
    public static X509CertificateValidator PeerOrChainTrust { get; }
    public static X509CertificateValidator get_None();
    public static X509CertificateValidator get_PeerTrust();
    public static X509CertificateValidator get_ChainTrust();
    public static X509CertificateValidator get_PeerOrChainTrust();
    public static X509CertificateValidator CreateChainTrustValidator(bool useMachineContext, X509ChainPolicy chainPolicy);
    public static X509CertificateValidator CreatePeerOrChainTrustValidator(bool useMachineContext, X509ChainPolicy chainPolicy);
    public abstract virtual void Validate(X509Certificate2 certificate);
}
public class System.IdentityModel.Selectors.X509SecurityTokenAuthenticator : SecurityTokenAuthenticator {
    private X509CertificateValidator _validator;
    private bool _mapToWindows;
    private bool _includeWindowsGroups;
    private bool _cloneHandle;
    public X509SecurityTokenAuthenticator(X509CertificateValidator validator);
    public X509SecurityTokenAuthenticator(X509CertificateValidator validator, bool mapToWindows);
    public X509SecurityTokenAuthenticator(X509CertificateValidator validator, bool mapToWindows, bool includeWindowsGroups);
    internal X509SecurityTokenAuthenticator(X509CertificateValidator validator, bool mapToWindows, bool includeWindowsGroups, bool cloneHandle);
    protected virtual bool CanValidateTokenCore(SecurityToken token);
    protected virtual ReadOnlyCollection`1<IAuthorizationPolicy> ValidateTokenCore(SecurityToken token);
}
public class System.IdentityModel.Selectors.X509SecurityTokenProvider : SecurityTokenProvider {
    private X509Certificate2 _certificate;
    private bool _clone;
    public X509SecurityTokenProvider(X509Certificate2 certificate);
    internal X509SecurityTokenProvider(X509Certificate2 certificate, bool clone);
    protected virtual Task`1<SecurityToken> GetTokenCoreAsync(CancellationToken cancellationToken);
    public sealed virtual void Dispose();
}
internal class System.IdentityModel.SignatureResourcePool : object {
}
internal class System.IdentityModel.SignedXml : object {
    public bool HasId { get; }
    public string Id { get; public set; }
    public sealed virtual Byte[] GetSignatureValue();
    public sealed virtual bool get_HasId();
    public sealed virtual string get_Id();
    public void set_Id(string value);
    public sealed virtual void WriteTo(XmlDictionaryWriter writer, DictionaryManager dictionaryManager);
}
internal class System.IdentityModel.SimpleAuthorizationContext : AuthorizationContext {
    private SecurityUniqueId _id;
    private UnconditionalPolicy _policy;
    private IDictionary`2<string, object> _properties;
    public string Id { get; }
    public ReadOnlyCollection`1<ClaimSet> ClaimSets { get; }
    public DateTime ExpirationTime { get; }
    public IDictionary`2<string, object> Properties { get; }
    public SimpleAuthorizationContext(IList`1<IAuthorizationPolicy> authorizationPolicies);
    public virtual string get_Id();
    public virtual ReadOnlyCollection`1<ClaimSet> get_ClaimSets();
    public virtual DateTime get_ExpirationTime();
    public virtual IDictionary`2<string, object> get_Properties();
}
public abstract class System.IdentityModel.Tokens.BinaryKeyIdentifierClause : SecurityKeyIdentifierClause {
    private Byte[] _identificationData;
    protected BinaryKeyIdentifierClause(string clauseType, Byte[] identificationData, bool cloneBuffer);
    protected BinaryKeyIdentifierClause(string clauseType, Byte[] identificationData, bool cloneBuffer, Byte[] derivationNonce, int derivationLength);
    public Byte[] GetBuffer();
    protected Byte[] GetRawBuffer();
    public virtual bool Matches(SecurityKeyIdentifierClause keyIdentifierClause);
    public bool Matches(Byte[] data);
    public bool Matches(Byte[] data, int offset);
    internal string ToBase64String();
}
public class System.IdentityModel.Tokens.EncryptedKeyIdentifierClause : BinaryKeyIdentifierClause {
    private string _carriedKeyName;
    private string _encryptionMethod;
    private SecurityKeyIdentifier _encryptingKeyIdentifier;
    public string CarriedKeyName { get; }
    public SecurityKeyIdentifier EncryptingKeyIdentifier { get; }
    public string EncryptionMethod { get; }
    public EncryptedKeyIdentifierClause(Byte[] encryptedKey, string encryptionMethod);
    public EncryptedKeyIdentifierClause(Byte[] encryptedKey, string encryptionMethod, SecurityKeyIdentifier encryptingKeyIdentifier);
    public EncryptedKeyIdentifierClause(Byte[] encryptedKey, string encryptionMethod, SecurityKeyIdentifier encryptingKeyIdentifier, string carriedKeyName);
    public EncryptedKeyIdentifierClause(Byte[] encryptedKey, string encryptionMethod, SecurityKeyIdentifier encryptingKeyIdentifier, string carriedKeyName, Byte[] derivationNonce, int derivationLength);
    internal EncryptedKeyIdentifierClause(Byte[] encryptedKey, string encryptionMethod, SecurityKeyIdentifier encryptingKeyIdentifier, string carriedKeyName, bool cloneBuffer, Byte[] derivationNonce, int derivationLength);
    public string get_CarriedKeyName();
    public SecurityKeyIdentifier get_EncryptingKeyIdentifier();
    public string get_EncryptionMethod();
    public virtual bool Matches(SecurityKeyIdentifierClause keyIdentifierClause);
    public bool Matches(Byte[] encryptedKey, string encryptionMethod, string carriedKeyName);
    public Byte[] GetEncryptedKey();
    public virtual string ToString();
}
internal class System.IdentityModel.Tokens.InMemorySymmetricSecurityKey : SymmetricSecurityKey {
    private int _keySize;
    private Byte[] _symmetricKey;
    public int KeySize { get; }
    public InMemorySymmetricSecurityKey(Byte[] symmetricKey);
    public InMemorySymmetricSecurityKey(Byte[] symmetricKey, bool cloneBuffer);
    public virtual int get_KeySize();
    public virtual Byte[] DecryptKey(string algorithm, Byte[] keyData);
    public virtual Byte[] EncryptKey(string algorithm, Byte[] keyData);
    public virtual Byte[] GenerateDerivedKey(string algorithm, Byte[] label, Byte[] nonce, int derivedKeyLength, int offset);
    public virtual ICryptoTransform GetDecryptionTransform(string algorithm, Byte[] iv);
    public virtual ICryptoTransform GetEncryptionTransform(string algorithm, Byte[] iv);
    public virtual int GetIVSize(string algorithm);
    public virtual KeyedHashAlgorithm GetKeyedHashAlgorithm(string algorithm);
    public virtual SymmetricAlgorithm GetSymmetricAlgorithm(string algorithm);
    public virtual Byte[] GetSymmetricKey();
    public virtual bool IsAsymmetricAlgorithm(string algorithm);
    public virtual bool IsSupportedAlgorithm(string algorithm);
    public virtual bool IsSymmetricAlgorithm(string algorithm);
}
public class System.IdentityModel.Tokens.KerberosRequestorSecurityToken : SecurityToken {
    private string _id;
    private string _servicePrincipalName;
    private DateTime _effectiveTime;
    private DateTime _expirationTime;
    public string Id { get; }
    public ReadOnlyCollection`1<SecurityKey> SecurityKeys { get; }
    public DateTime ValidFrom { get; }
    public DateTime ValidTo { get; }
    public string ServicePrincipalName { get; }
    internal KerberosRequestorSecurityToken(string servicePrincipalName, TokenImpersonationLevel tokenImpersonationLevel, NetworkCredential networkCredential, string id);
    public virtual string get_Id();
    public virtual ReadOnlyCollection`1<SecurityKey> get_SecurityKeys();
    public virtual DateTime get_ValidFrom();
    public virtual DateTime get_ValidTo();
    public string get_ServicePrincipalName();
}
public class System.IdentityModel.Tokens.LocalIdKeyIdentifierClause : SecurityKeyIdentifierClause {
    private string _localId;
    private Type[] _ownerTypes;
    public string LocalId { get; }
    public Type OwnerType { get; }
    public LocalIdKeyIdentifierClause(string localId);
    public LocalIdKeyIdentifierClause(string localId, Type ownerType);
    public LocalIdKeyIdentifierClause(string localId, Byte[] derivationNonce, int derivationLength, Type ownerType);
    internal LocalIdKeyIdentifierClause(string localId, Type[] ownerTypes);
    internal LocalIdKeyIdentifierClause(string localId, Byte[] derivationNonce, int derivationLength, Type[] ownerTypes);
    public string get_LocalId();
    public Type get_OwnerType();
    public virtual bool Matches(SecurityKeyIdentifierClause keyIdentifierClause);
    public bool Matches(string localId, Type ownerType);
    public virtual string ToString();
}
public class System.IdentityModel.Tokens.SamlSerializer : object {
}
public static class System.IdentityModel.Tokens.SecurityAlgorithms : object {
    public static string Psha1KeyDerivation;
    public static string Psha1KeyDerivationDec2005;
}
public abstract class System.IdentityModel.Tokens.SecurityKey : object {
    public int KeySize { get; }
    public abstract virtual int get_KeySize();
    public abstract virtual Byte[] DecryptKey(string algorithm, Byte[] keyData);
    public abstract virtual Byte[] EncryptKey(string algorithm, Byte[] keyData);
    public abstract virtual bool IsAsymmetricAlgorithm(string algorithm);
    public abstract virtual bool IsSupportedAlgorithm(string algorithm);
    public abstract virtual bool IsSymmetricAlgorithm(string algorithm);
}
[DefaultMemberAttribute("Item")]
public class System.IdentityModel.Tokens.SecurityKeyIdentifier : object {
    private static int InitialSize;
    private List`1<SecurityKeyIdentifierClause> _clauses;
    private bool _isReadOnly;
    public SecurityKeyIdentifierClause Item { get; }
    public bool CanCreateKey { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public SecurityKeyIdentifier(SecurityKeyIdentifierClause[] clauses);
    public SecurityKeyIdentifierClause get_Item(int index);
    public bool get_CanCreateKey();
    public int get_Count();
    public bool get_IsReadOnly();
    public void Add(SecurityKeyIdentifierClause clause);
    public SecurityKey CreateKey();
    public TClause Find();
    public sealed virtual IEnumerator`1<SecurityKeyIdentifierClause> GetEnumerator();
    public void MakeReadOnly();
    public virtual string ToString();
    public bool TryFind(TClause& clause);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public abstract class System.IdentityModel.Tokens.SecurityKeyIdentifierClause : object {
    private string _clauseType;
    private Byte[] _derivationNonce;
    private int _derivationLength;
    private string _id;
    public bool CanCreateKey { get; }
    public string ClauseType { get; }
    public string Id { get; public set; }
    public int DerivationLength { get; }
    protected SecurityKeyIdentifierClause(string clauseType);
    protected SecurityKeyIdentifierClause(string clauseType, Byte[] nonce, int length);
    public virtual bool get_CanCreateKey();
    public string get_ClauseType();
    public string get_Id();
    public void set_Id(string value);
    public virtual SecurityKey CreateKey();
    public virtual bool Matches(SecurityKeyIdentifierClause keyIdentifierClause);
    public Byte[] GetDerivationNonce();
    public int get_DerivationLength();
}
public enum System.IdentityModel.Tokens.SecurityKeyType : Enum {
    public int value__;
    public static SecurityKeyType SymmetricKey;
    public static SecurityKeyType AsymmetricKey;
    public static SecurityKeyType BearerKey;
}
internal static class System.IdentityModel.Tokens.SecurityKeyTypeHelper : object {
    internal static bool IsDefined(SecurityKeyType value);
    internal static void Validate(SecurityKeyType value);
}
public enum System.IdentityModel.Tokens.SecurityKeyUsage : Enum {
    public int value__;
    public static SecurityKeyUsage Exchange;
    public static SecurityKeyUsage Signature;
}
internal static class System.IdentityModel.Tokens.SecurityKeyUsageHelper : object {
    internal static bool IsDefined(SecurityKeyUsage value);
    internal static void Validate(SecurityKeyUsage value);
}
public abstract class System.IdentityModel.Tokens.SecurityToken : object {
    public string Id { get; }
    public ReadOnlyCollection`1<SecurityKey> SecurityKeys { get; }
    public DateTime ValidFrom { get; }
    public DateTime ValidTo { get; }
    public abstract virtual string get_Id();
    public abstract virtual ReadOnlyCollection`1<SecurityKey> get_SecurityKeys();
    public abstract virtual DateTime get_ValidFrom();
    public abstract virtual DateTime get_ValidTo();
}
public class System.IdentityModel.Tokens.SecurityTokenException : Exception {
    public SecurityTokenException(string message);
    public SecurityTokenException(string message, Exception innerException);
    protected SecurityTokenException(SerializationInfo info, StreamingContext context);
}
public static class System.IdentityModel.Tokens.SecurityTokenTypes : object {
    private static string Namespace;
    private static string userName;
    private static string x509Certificate;
    private static string kerberos;
    private static string saml;
    private static string rsa;
    internal static string SamlTokenProfile11;
    internal static string Saml2TokenProfile11;
    internal static string OasisWssSamlTokenProfile11;
    internal static string OasisWssSaml2TokenProfile11;
    public static string UserName { get; }
    public static string X509Certificate { get; }
    public static string Kerberos { get; }
    public static string Saml { get; }
    public static string Rsa { get; }
    public static string get_UserName();
    public static string get_X509Certificate();
    public static string get_Kerberos();
    public static string get_Saml();
    public static string get_Rsa();
}
public class System.IdentityModel.Tokens.SecurityTokenValidationException : SecurityTokenException {
    public SecurityTokenValidationException(string message);
    public SecurityTokenValidationException(string message, Exception innerException);
    protected SecurityTokenValidationException(SerializationInfo info, StreamingContext context);
}
internal abstract class System.IdentityModel.Tokens.SymmetricSecurityKey : SecurityKey {
    public abstract virtual Byte[] GenerateDerivedKey(string algorithm, Byte[] label, Byte[] nonce, int derivedKeyLength, int offset);
    public abstract virtual ICryptoTransform GetDecryptionTransform(string algorithm, Byte[] iv);
    public abstract virtual ICryptoTransform GetEncryptionTransform(string algorithm, Byte[] iv);
    public abstract virtual int GetIVSize(string algorithm);
    public abstract virtual KeyedHashAlgorithm GetKeyedHashAlgorithm(string algorithm);
    public abstract virtual SymmetricAlgorithm GetSymmetricAlgorithm(string algorithm);
    public abstract virtual Byte[] GetSymmetricKey();
}
public class System.IdentityModel.Tokens.UserNameSecurityToken : SecurityToken {
    private string _id;
    private string _password;
    private string _userName;
    private DateTime _effectiveTime;
    public string Id { get; }
    public ReadOnlyCollection`1<SecurityKey> SecurityKeys { get; }
    public DateTime ValidFrom { get; }
    public DateTime ValidTo { get; }
    public string UserName { get; }
    public string Password { get; }
    public UserNameSecurityToken(string userName, string password);
    public UserNameSecurityToken(string userName, string password, string id);
    public virtual string get_Id();
    public virtual ReadOnlyCollection`1<SecurityKey> get_SecurityKeys();
    public virtual DateTime get_ValidFrom();
    public virtual DateTime get_ValidTo();
    public string get_UserName();
    public string get_Password();
}
public class System.IdentityModel.Tokens.WindowsSecurityToken : SecurityToken {
    private string _authenticationType;
    private string _id;
    private DateTime _effectiveTime;
    private DateTime _expirationTime;
    private WindowsIdentity _windowsIdentity;
    private bool _disposed;
    public string Id { get; }
    public string AuthenticationType { get; }
    public DateTime ValidFrom { get; }
    public DateTime ValidTo { get; }
    public WindowsIdentity WindowsIdentity { get; }
    public ReadOnlyCollection`1<SecurityKey> SecurityKeys { get; }
    public WindowsSecurityToken(WindowsIdentity windowsIdentity);
    public WindowsSecurityToken(WindowsIdentity windowsIdentity, string id);
    public WindowsSecurityToken(WindowsIdentity windowsIdentity, string id, string authenticationType);
    protected void Initialize(string id, DateTime effectiveTime, DateTime expirationTime, WindowsIdentity windowsIdentity, bool clone);
    protected void Initialize(string id, string authenticationType, DateTime effectiveTime, DateTime expirationTime, WindowsIdentity windowsIdentity, bool clone);
    public virtual string get_Id();
    public string get_AuthenticationType();
    public virtual DateTime get_ValidFrom();
    public virtual DateTime get_ValidTo();
    public virtual WindowsIdentity get_WindowsIdentity();
    public virtual ReadOnlyCollection`1<SecurityKey> get_SecurityKeys();
    public virtual void Dispose();
    protected void ThrowIfDisposed();
}
public class System.IdentityModel.Tokens.X509SecurityToken : SecurityToken {
    private string _id;
    private X509Certificate2 _certificate;
    private DateTime _effectiveTime;
    private DateTime _expirationTime;
    private bool _disposed;
    private bool _disposable;
    public string Id { get; }
    public ReadOnlyCollection`1<SecurityKey> SecurityKeys { get; }
    public DateTime ValidFrom { get; }
    public DateTime ValidTo { get; }
    public X509Certificate2 Certificate { get; }
    public X509SecurityToken(X509Certificate2 certificate);
    public X509SecurityToken(X509Certificate2 certificate, string id);
    internal X509SecurityToken(X509Certificate2 certificate, bool clone);
    internal X509SecurityToken(X509Certificate2 certificate, bool clone, bool disposable);
    internal X509SecurityToken(X509Certificate2 certificate, string id, bool clone);
    internal X509SecurityToken(X509Certificate2 certificate, string id, bool clone, bool disposable);
    public virtual string get_Id();
    public virtual ReadOnlyCollection`1<SecurityKey> get_SecurityKeys();
    public virtual DateTime get_ValidFrom();
    public virtual DateTime get_ValidTo();
    public X509Certificate2 get_Certificate();
    public virtual void Dispose();
    protected void ThrowIfDisposed();
}
internal class System.IdentityModel.TrustDec2005Dictionary : TrustDictionary {
    public TrustDec2005Dictionary(IdentityModelDictionary dictionary);
    public TrustDec2005Dictionary(IXmlDictionary dictionary);
    private XmlDictionaryString LookupDictionaryString(IXmlDictionary dictionary, string value);
}
internal static class System.IdentityModel.TrustDec2005Strings : object {
    public static string CombinedHashLabel;
    public static string RequestSecurityTokenResponse;
    public static string TokenType;
    public static string KeySize;
    public static string RequestedTokenReference;
    public static string AppliesTo;
    public static string Authenticator;
    public static string CombinedHash;
    public static string BinaryExchange;
    public static string Lifetime;
    public static string RequestedSecurityToken;
    public static string Entropy;
    public static string RequestedProofToken;
    public static string ComputedKey;
    public static string RequestSecurityToken;
    public static string RequestType;
    public static string Context;
    public static string BinarySecret;
    public static string Type;
    public static string SpnegoValueTypeUri;
    public static string TlsnegoValueTypeUri;
    public static string Prefix;
    public static string RequestSecurityTokenIssuance;
    public static string RequestSecurityTokenIssuanceResponse;
    public static string RequestTypeIssue;
    public static string AsymmetricKeyBinarySecret;
    public static string SymmetricKeyBinarySecret;
    public static string NonceBinarySecret;
    public static string Psha1ComputedKeyUri;
    public static string KeyType;
    public static string SymmetricKeyType;
    public static string PublicKeyType;
    public static string Claims;
    public static string InvalidRequestFaultCode;
    public static string FailedAuthenticationFaultCode;
    public static string UseKey;
    public static string SignWith;
    public static string EncryptWith;
    public static string EncryptionAlgorithm;
    public static string CanonicalizationAlgorithm;
    public static string ComputedKeyAlgorithm;
    public static string RequestSecurityTokenResponseCollection;
    public static string Namespace;
    public static string BinarySecretClauseType;
    public static string RequestSecurityTokenCollectionIssuanceFinalResponse;
    public static string RequestSecurityTokenRenewal;
    public static string RequestSecurityTokenRenewalResponse;
    public static string RequestSecurityTokenCollectionRenewalFinalResponse;
    public static string RequestSecurityTokenCancellation;
    public static string RequestSecurityTokenCancellationResponse;
    public static string RequestSecurityTokenCollectionCancellationFinalResponse;
    public static string RequestTypeRenew;
    public static string RequestTypeClose;
    public static string RenewTarget;
    public static string CloseTarget;
    public static string RequestedTokenClosed;
    public static string RequestedAttachedReference;
    public static string RequestedUnattachedReference;
    public static string IssuedTokensHeader;
    public static string KeyWrapAlgorithm;
    public static string BearerKeyType;
    public static string SecondaryParameters;
    public static string Dialect;
    public static string DialectType;
}
internal class System.IdentityModel.TrustDictionary : object {
    public XmlDictionaryString RequestSecurityTokenResponseCollection;
    public XmlDictionaryString Namespace;
    public XmlDictionaryString BinarySecretClauseType;
    public XmlDictionaryString CombinedHashLabel;
    public XmlDictionaryString RequestSecurityTokenResponse;
    public XmlDictionaryString TokenType;
    public XmlDictionaryString KeySize;
    public XmlDictionaryString RequestedTokenReference;
    public XmlDictionaryString AppliesTo;
    public XmlDictionaryString Authenticator;
    public XmlDictionaryString CombinedHash;
    public XmlDictionaryString BinaryExchange;
    public XmlDictionaryString Lifetime;
    public XmlDictionaryString RequestedSecurityToken;
    public XmlDictionaryString Entropy;
    public XmlDictionaryString RequestedProofToken;
    public XmlDictionaryString ComputedKey;
    public XmlDictionaryString RequestSecurityToken;
    public XmlDictionaryString RequestType;
    public XmlDictionaryString Context;
    public XmlDictionaryString BinarySecret;
    public XmlDictionaryString Type;
    public XmlDictionaryString SpnegoValueTypeUri;
    public XmlDictionaryString TlsnegoValueTypeUri;
    public XmlDictionaryString Prefix;
    public XmlDictionaryString RequestSecurityTokenIssuance;
    public XmlDictionaryString RequestSecurityTokenIssuanceResponse;
    public XmlDictionaryString RequestTypeIssue;
    public XmlDictionaryString SymmetricKeyBinarySecret;
    public XmlDictionaryString Psha1ComputedKeyUri;
    public XmlDictionaryString NonceBinarySecret;
    public XmlDictionaryString RenewTarget;
    public XmlDictionaryString CloseTarget;
    public XmlDictionaryString RequestedTokenClosed;
    public XmlDictionaryString RequestedAttachedReference;
    public XmlDictionaryString RequestedUnattachedReference;
    public XmlDictionaryString IssuedTokensHeader;
    public XmlDictionaryString RequestTypeRenew;
    public XmlDictionaryString RequestTypeClose;
    public XmlDictionaryString KeyType;
    public XmlDictionaryString SymmetricKeyType;
    public XmlDictionaryString PublicKeyType;
    public XmlDictionaryString Claims;
    public XmlDictionaryString InvalidRequestFaultCode;
    public XmlDictionaryString FailedAuthenticationFaultCode;
    public XmlDictionaryString UseKey;
    public XmlDictionaryString SignWith;
    public XmlDictionaryString EncryptWith;
    public XmlDictionaryString EncryptionAlgorithm;
    public XmlDictionaryString CanonicalizationAlgorithm;
    public XmlDictionaryString ComputedKeyAlgorithm;
    public XmlDictionaryString AsymmetricKeyBinarySecret;
    public XmlDictionaryString RequestSecurityTokenCollectionIssuanceFinalResponse;
    public XmlDictionaryString RequestSecurityTokenRenewal;
    public XmlDictionaryString RequestSecurityTokenRenewalResponse;
    public XmlDictionaryString RequestSecurityTokenCollectionRenewalFinalResponse;
    public XmlDictionaryString RequestSecurityTokenCancellation;
    public XmlDictionaryString RequestSecurityTokenCancellationResponse;
    public XmlDictionaryString RequestSecurityTokenCollectionCancellationFinalResponse;
    public XmlDictionaryString KeyWrapAlgorithm;
    public XmlDictionaryString BearerKeyType;
    public XmlDictionaryString SecondaryParameters;
    public XmlDictionaryString Dialect;
    public XmlDictionaryString DialectType;
    public TrustDictionary(IdentityModelDictionary dictionary);
    public TrustDictionary(IXmlDictionary dictionary);
    private XmlDictionaryString LookupDictionaryString(IXmlDictionary dictionary, string value);
}
internal class System.IdentityModel.TrustFeb2005Dictionary : TrustDictionary {
    public TrustFeb2005Dictionary(IdentityModelDictionary dictionary);
    public TrustFeb2005Dictionary(IXmlDictionary dictionary);
    private XmlDictionaryString LookupDictionaryString(IXmlDictionary dictionary, string value);
}
internal static class System.IdentityModel.TrustFeb2005Strings : object {
    public static string RequestSecurityTokenResponseCollection;
    public static string Namespace;
    public static string BinarySecretClauseType;
    public static string CombinedHashLabel;
    public static string RequestSecurityTokenResponse;
    public static string TokenType;
    public static string KeySize;
    public static string RequestedTokenReference;
    public static string AppliesTo;
    public static string Authenticator;
    public static string CombinedHash;
    public static string BinaryExchange;
    public static string Lifetime;
    public static string RequestedSecurityToken;
    public static string Entropy;
    public static string RequestedProofToken;
    public static string ComputedKey;
    public static string RequestSecurityToken;
    public static string RequestType;
    public static string Context;
    public static string BinarySecret;
    public static string Type;
    public static string SpnegoValueTypeUri;
    public static string TlsnegoValueTypeUri;
    public static string Prefix;
    public static string RequestSecurityTokenIssuance;
    public static string RequestSecurityTokenIssuanceResponse;
    public static string RequestTypeIssue;
    public static string SymmetricKeyBinarySecret;
    public static string Psha1ComputedKeyUri;
    public static string NonceBinarySecret;
    public static string RenewTarget;
    public static string CloseTarget;
    public static string RequestedTokenClosed;
    public static string RequestedAttachedReference;
    public static string RequestedUnattachedReference;
    public static string IssuedTokensHeader;
    public static string RequestTypeRenew;
    public static string RequestTypeClose;
    public static string KeyType;
    public static string SymmetricKeyType;
    public static string PublicKeyType;
    public static string Claims;
    public static string InvalidRequestFaultCode;
    public static string FailedAuthenticationFaultCode;
    public static string UseKey;
    public static string SignWith;
    public static string EncryptWith;
    public static string EncryptionAlgorithm;
    public static string CanonicalizationAlgorithm;
    public static string ComputedKeyAlgorithm;
}
internal static class System.IdentityModel.TrustStrings : object {
}
internal class System.IdentityModel.UtilityDictionary : object {
    public XmlDictionaryString IdAttribute;
    public XmlDictionaryString Namespace;
    public XmlDictionaryString Timestamp;
    public XmlDictionaryString CreatedElement;
    public XmlDictionaryString ExpiresElement;
    public XmlDictionaryString Prefix;
    public UtilityDictionary(IdentityModelDictionary dictionary);
    public UtilityDictionary(IXmlDictionary dictionary);
    private XmlDictionaryString LookupDictionaryString(IXmlDictionary dictionary, string value);
}
internal static class System.IdentityModel.UtilityStrings : object {
    public static string IdAttribute;
    public static string Namespace;
    public static string Timestamp;
    public static string CreatedElement;
    public static string ExpiresElement;
    public static string Prefix;
}
internal static class System.IdentityModel.XD : object {
    private static ExclusiveC14NDictionary s_exclusiveC14NDictionary;
    private static SamlDictionary s_samlDictionary;
    private static SecureConversationDec2005Dictionary s_secureConversationDec2005Dictionary;
    private static SecureConversationFeb2005Dictionary s_secureConversationFeb2005Dictionary;
    private static SecurityAlgorithmDictionary s_securityAlgorithmDictionary;
    private static SecurityAlgorithmDec2005Dictionary s_securityAlgorithmDec2005Dictionary;
    private static SecurityJan2004Dictionary s_securityJan2004Dictionary;
    private static SecurityXXX2005Dictionary s_securityXXX2005Dictionary;
    private static TrustDec2005Dictionary s_trustDec2005Dictionary;
    private static TrustFeb2005Dictionary s_trustFeb2005Dictionary;
    private static UtilityDictionary s_utilityDictionary;
    private static XmlEncryptionDictionary s_xmlEncryptionDictionary;
    private static XmlSignatureDictionary s_xmlSignatureDictionary;
    public static IdentityModelDictionary Dictionary { get; }
    public static ExclusiveC14NDictionary ExclusiveC14NDictionary { get; }
    public static SamlDictionary SamlDictionary { get; }
    public static SecureConversationDec2005Dictionary SecureConversationDec2005Dictionary { get; }
    public static SecureConversationFeb2005Dictionary SecureConversationFeb2005Dictionary { get; }
    public static SecurityAlgorithmDictionary SecurityAlgorithmDictionary { get; }
    public static SecurityAlgorithmDec2005Dictionary SecurityAlgorithmDec2005Dictionary { get; }
    public static SecurityJan2004Dictionary SecurityJan2004Dictionary { get; }
    public static SecurityXXX2005Dictionary SecurityXXX2005Dictionary { get; }
    public static TrustDec2005Dictionary TrustDec2005Dictionary { get; }
    public static TrustFeb2005Dictionary TrustFeb2005Dictionary { get; }
    public static UtilityDictionary UtilityDictionary { get; }
    public static XmlEncryptionDictionary XmlEncryptionDictionary { get; }
    public static XmlSignatureDictionary XmlSignatureDictionary { get; }
    public static IdentityModelDictionary get_Dictionary();
    public static ExclusiveC14NDictionary get_ExclusiveC14NDictionary();
    public static SamlDictionary get_SamlDictionary();
    public static SecureConversationDec2005Dictionary get_SecureConversationDec2005Dictionary();
    public static SecureConversationFeb2005Dictionary get_SecureConversationFeb2005Dictionary();
    public static SecurityAlgorithmDictionary get_SecurityAlgorithmDictionary();
    public static SecurityAlgorithmDec2005Dictionary get_SecurityAlgorithmDec2005Dictionary();
    public static SecurityJan2004Dictionary get_SecurityJan2004Dictionary();
    public static SecurityXXX2005Dictionary get_SecurityXXX2005Dictionary();
    public static TrustDec2005Dictionary get_TrustDec2005Dictionary();
    public static TrustFeb2005Dictionary get_TrustFeb2005Dictionary();
    public static UtilityDictionary get_UtilityDictionary();
    public static XmlEncryptionDictionary get_XmlEncryptionDictionary();
    public static XmlSignatureDictionary get_XmlSignatureDictionary();
}
internal class System.IdentityModel.XmlBuffer : object {
    private Exception CreateInvalidStateException();
}
internal class System.IdentityModel.XmlEncryptionDictionary : object {
    public XmlDictionaryString Namespace;
    public XmlDictionaryString DataReference;
    public XmlDictionaryString EncryptedData;
    public XmlDictionaryString EncryptionMethod;
    public XmlDictionaryString CipherData;
    public XmlDictionaryString CipherValue;
    public XmlDictionaryString ReferenceList;
    public XmlDictionaryString Encoding;
    public XmlDictionaryString MimeType;
    public XmlDictionaryString Type;
    public XmlDictionaryString Id;
    public XmlDictionaryString CarriedKeyName;
    public XmlDictionaryString Recipient;
    public XmlDictionaryString EncryptedKey;
    public XmlDictionaryString URI;
    public XmlDictionaryString KeyReference;
    public XmlDictionaryString Prefix;
    public XmlDictionaryString ElementType;
    public XmlDictionaryString ContentType;
    public XmlDictionaryString AlgorithmAttribute;
    public XmlEncryptionDictionary(IdentityModelDictionary dictionary);
    public XmlEncryptionDictionary(IXmlDictionary dictionary);
    private XmlDictionaryString LookupDictionaryString(IXmlDictionary dictionary, string value);
}
internal static class System.IdentityModel.XmlEncryptionStrings : object {
    public static string Namespace;
    public static string DataReference;
    public static string EncryptedData;
    public static string EncryptionMethod;
    public static string CipherData;
    public static string CipherValue;
    public static string ReferenceList;
    public static string Encoding;
    public static string MimeType;
    public static string Type;
    public static string Id;
    public static string CarriedKeyName;
    public static string Recipient;
    public static string EncryptedKey;
    public static string URI;
    public static string KeyReference;
    public static string Prefix;
    public static string ElementType;
    public static string ContentType;
    public static string AlgorithmAttribute;
}
internal class System.IdentityModel.XmlSignatureDictionary : object {
    public XmlDictionaryString Algorithm;
    public XmlDictionaryString URI;
    public XmlDictionaryString Reference;
    public XmlDictionaryString Transforms;
    public XmlDictionaryString Transform;
    public XmlDictionaryString DigestMethod;
    public XmlDictionaryString DigestValue;
    public XmlDictionaryString Namespace;
    public XmlDictionaryString EnvelopedSignature;
    public XmlDictionaryString KeyInfo;
    public XmlDictionaryString Signature;
    public XmlDictionaryString SignedInfo;
    public XmlDictionaryString CanonicalizationMethod;
    public XmlDictionaryString SignatureMethod;
    public XmlDictionaryString SignatureValue;
    public XmlDictionaryString KeyName;
    public XmlDictionaryString Type;
    public XmlDictionaryString MgmtData;
    public XmlDictionaryString Prefix;
    public XmlDictionaryString KeyValue;
    public XmlDictionaryString RsaKeyValue;
    public XmlDictionaryString Modulus;
    public XmlDictionaryString Exponent;
    public XmlDictionaryString X509Data;
    public XmlDictionaryString X509IssuerSerial;
    public XmlDictionaryString X509IssuerName;
    public XmlDictionaryString X509SerialNumber;
    public XmlDictionaryString X509Certificate;
    public XmlSignatureDictionary(IdentityModelDictionary dictionary);
    public XmlSignatureDictionary(IXmlDictionary dictionary);
    private XmlDictionaryString LookupDictionaryString(IXmlDictionary dictionary, string value);
}
internal static class System.IdentityModel.XmlSignatureStrings : object {
    public static string Algorithm;
    public static string URI;
    public static string Reference;
    public static string Transforms;
    public static string Transform;
    public static string DigestMethod;
    public static string DigestValue;
    public static string Namespace;
    public static string EnvelopedSignature;
    public static string KeyInfo;
    public static string Signature;
    public static string SignedInfo;
    public static string CanonicalizationMethod;
    public static string SignatureMethod;
    public static string SignatureValue;
    public static string KeyName;
    public static string Type;
    public static string MgmtData;
    public static string Prefix;
    public static string KeyValue;
    public static string RsaKeyValue;
    public static string Modulus;
    public static string Exponent;
    public static string X509Data;
    public static string X509IssuerSerial;
    public static string X509IssuerName;
    public static string X509SerialNumber;
    public static string X509Certificate;
    public static string SecurityJan2004Namespace;
    public static string SecurityJan2004Prefix;
    public static string X509Ski;
    public static string TransformationParameters;
}
internal static class System.NotImplemented : object {
    internal static Exception ByDesign { get; }
    internal static Exception get_ByDesign();
    internal static Exception ByDesignWithMessage(string message);
}
internal abstract class System.Runtime.ActionItem : object {
    private bool _isScheduled;
    private bool _lowPriority;
    public bool LowPriority { get; protected set; }
    public bool get_LowPriority();
    protected void set_LowPriority(bool value);
    public static void Schedule(Action`1<object> callback, object state);
    [SecurityCriticalAttribute]
protected abstract virtual void Invoke();
    [SecurityCriticalAttribute]
protected void Schedule();
    [SecurityCriticalAttribute]
private void ScheduleCallback(Action`1<object> callback);
}
internal static class System.Runtime.AssertHelper : object {
    internal static void FireAssert(string message);
    [SecuritySafeCriticalAttribute]
private static void InternalFireAssert(String& message);
}
public enum System.Runtime.AsyncCompletionResult : Enum {
    public int value__;
    public static AsyncCompletionResult Queued;
    public static AsyncCompletionResult Completed;
}
internal abstract class System.Runtime.AsyncResult : object {
    private static AsyncCallback s_asyncCompletionWrapperCallback;
    private AsyncCallback _callback;
    private bool _completedSynchronously;
    private bool _endCalled;
    private Exception _exception;
    private bool _isCompleted;
    private AsyncCompletion _nextAsyncCompletion;
    private object _state;
    private Action _beforePrepareAsyncCompletionAction;
    private Func`2<IAsyncResult, bool> _checkSyncValidationFunc;
    private ManualResetEvent _manualResetEvent;
    private object _thisLock;
    [CompilerGeneratedAttribute]
private Action`2<AsyncResult, Exception> <OnCompleting>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`2<AsyncCallback, IAsyncResult> <VirtualCallback>k__BackingField;
    public object AsyncState { get; }
    public WaitHandle AsyncWaitHandle { get; }
    public bool CompletedSynchronously { get; }
    public bool HasCallback { get; }
    public bool IsCompleted { get; }
    protected Action`2<AsyncResult, Exception> OnCompleting { get; protected set; }
    private object ThisLock { get; }
    protected Action`2<AsyncCallback, IAsyncResult> VirtualCallback { get; protected set; }
    protected AsyncResult(AsyncCallback callback, object state);
    public sealed virtual object get_AsyncState();
    public sealed virtual WaitHandle get_AsyncWaitHandle();
    public sealed virtual bool get_CompletedSynchronously();
    public bool get_HasCallback();
    public sealed virtual bool get_IsCompleted();
    [CompilerGeneratedAttribute]
protected Action`2<AsyncResult, Exception> get_OnCompleting();
    [CompilerGeneratedAttribute]
protected void set_OnCompleting(Action`2<AsyncResult, Exception> value);
    private object get_ThisLock();
    [CompilerGeneratedAttribute]
protected Action`2<AsyncCallback, IAsyncResult> get_VirtualCallback();
    [CompilerGeneratedAttribute]
protected void set_VirtualCallback(Action`2<AsyncCallback, IAsyncResult> value);
    protected void Complete(bool completedSynchronously);
    protected void Complete(bool completedSynchronously, Exception exception);
    private static void AsyncCompletionWrapperCallback(IAsyncResult result);
    protected virtual bool OnContinueAsyncCompletion(IAsyncResult result);
    protected void SetBeforePrepareAsyncCompletionAction(Action beforePrepareAsyncCompletionAction);
    protected void SetCheckSyncValidationFunc(Func`2<IAsyncResult, bool> checkSyncValidationFunc);
    protected AsyncCallback PrepareAsyncCompletion(AsyncCompletion callback);
    protected bool CheckSyncContinue(IAsyncResult result);
    protected bool SyncContinue(IAsyncResult result);
    private bool TryContinueHelper(IAsyncResult result, AsyncCompletion& callback);
    private AsyncCompletion GetNextCompletion();
    protected static void ThrowInvalidAsyncResult(IAsyncResult result);
    protected static void ThrowInvalidAsyncResult(string debugText);
    protected static TAsyncResult End(IAsyncResult result);
}
internal class System.Runtime.BufferedOutputStream : Stream {
    private InternalBufferManager _bufferManager;
    private Byte[][] _chunks;
    private int _chunkCount;
    private Byte[] _currentChunk;
    private int _currentChunkSize;
    private int _maxSize;
    private int _maxSizeQuota;
    private int _totalSize;
    private bool _callerReturnsBuffer;
    private bool _bufferReturned;
    private bool _initialized;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public BufferedOutputStream(int initialSize, int maxSize, InternalBufferManager bufferManager);
    public BufferedOutputStream(int maxSize);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public void Reinitialize(int initialSize, int maxSizeQuota, InternalBufferManager bufferManager);
    public void Reinitialize(int initialSize, int maxSizeQuota, int effectiveMaxSize, InternalBufferManager bufferManager);
    private void AllocNextChunk(int minimumChunkSize);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int size, AsyncCallback callback, object state);
    public virtual int EndRead(IAsyncResult result);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int size, AsyncCallback callback, object state);
    public virtual void EndWrite(IAsyncResult result);
    public void Clear();
    public virtual void Close();
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int size);
    public virtual int ReadByte();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public MemoryStream ToMemoryStream();
    public Byte[] ToArray(Int32& bufferSize);
    public void Skip(int size);
    public virtual void Write(Byte[] buffer, int offset, int size);
    protected virtual Exception CreateQuotaExceededException(int maxSizeQuota);
    private void WriteCore(Byte[] buffer, int offset, int size);
    public virtual void WriteByte(byte value);
}
internal class System.Runtime.CallbackException : FatalException {
    public CallbackException(string message, Exception innerException);
}
internal class System.Runtime.CompletedAsyncResult : AsyncResult {
    public CompletedAsyncResult(AsyncCallback callback, object state);
    public static void End(IAsyncResult result);
}
internal class System.Runtime.CompletedAsyncResult`1 : AsyncResult {
    private T _data;
    public CompletedAsyncResult`1(T data, AsyncCallback callback, object state);
    public static T End(IAsyncResult result);
}
internal class System.Runtime.CompletedAsyncResult`2 : AsyncResult {
    private TResult _resultData;
    private TParameter _parameter;
    public CompletedAsyncResult`2(TResult resultData, TParameter parameter, AsyncCallback callback, object state);
    public static TResult End(IAsyncResult result, TParameter& parameter);
}
public class System.Runtime.DefaultTaskSchedulerAwaiter : ValueType {
    public static DefaultTaskSchedulerAwaiter Singleton;
    public bool IsCompleted { get; }
    private static DefaultTaskSchedulerAwaiter();
    public bool get_IsCompleted();
    public sealed virtual void OnCompleted(Action continuation);
    public void GetResult();
    public DefaultTaskSchedulerAwaiter GetAwaiter();
}
internal abstract class System.Runtime.Diagnostics.DiagnosticTraceBase : object {
    protected static string DefaultTraceListenerName;
    protected static string TraceRecordVersion;
    protected static string AppDomainFriendlyName;
    private static ushort TracingEventLogCategory;
    private object _thisLock;
    protected string TraceSourceName;
    [SecurityCriticalAttribute]
private string _eventSourceName;
    [CompilerGeneratedAttribute]
private DateTime <LastFailure>k__BackingField;
    protected DateTime LastFailure { get; protected set; }
    protected string EventSourceName { get; protected set; }
    public bool TracingEnabled { get; }
    protected static string ProcessName { get; }
    protected static int ProcessId { get; }
    public static Guid ActivityId { get; public set; }
    public DiagnosticTraceBase(string traceSourceName);
    private static DiagnosticTraceBase();
    [CompilerGeneratedAttribute]
protected DateTime get_LastFailure();
    [CompilerGeneratedAttribute]
protected void set_LastFailure(DateTime value);
    [SecuritySafeCriticalAttribute]
protected string get_EventSourceName();
    [SecurityCriticalAttribute]
protected void set_EventSourceName(string value);
    public bool get_TracingEnabled();
    [SecuritySafeCriticalAttribute]
protected static string get_ProcessName();
    [SecuritySafeCriticalAttribute]
protected static int get_ProcessId();
    public static string XmlEncode(string text);
    [SecuritySafeCriticalAttribute]
protected void AddDomainEventHandlersForCleanup();
    private void ExitOrUnloadEventHandler(object sender, EventArgs e);
    protected static string CreateSourceString(object source);
    internal static string CreateDefaultSourceString(object source);
    protected static void AddExceptionToTraceString(XmlWriter xml, Exception exception);
    protected static string StackTraceString(Exception exception);
    [SecuritySafeCriticalAttribute]
protected void LogTraceFailure(string traceString, Exception exception);
    [SecuritySafeCriticalAttribute]
public static Guid get_ActivityId();
    [SecuritySafeCriticalAttribute]
public static void set_ActivityId(Guid value);
    public abstract virtual bool IsEnabled();
}
internal class System.Runtime.Diagnostics.DictionaryTraceRecord : TraceRecord {
    private IDictionary _dictionary;
    internal string EventId { get; }
    internal DictionaryTraceRecord(IDictionary dictionary);
    internal virtual string get_EventId();
    internal virtual void WriteTo(XmlWriter xml);
}
internal class System.Runtime.Diagnostics.EtwDiagnosticTrace : DiagnosticTraceBase {
    private static int XmlBracketsLength;
    private static int MaxExceptionStringLength;
    private static int MaxExceptionDepth;
    private static Guid s_defaultEtwProviderId;
    public static Guid DefaultEtwProviderId { get; public set; }
    public bool IsEtwProviderEnabled { get; }
    public bool IsEnd2EndActivityTracingEnabled { get; }
    private bool EtwTracingEnabled { get; }
    [SecurityCriticalAttribute]
private static EtwDiagnosticTrace();
    [SecurityCriticalAttribute]
public EtwDiagnosticTrace(string traceSourceName, Guid etwProviderId);
    [SecuritySafeCriticalAttribute]
public static Guid get_DefaultEtwProviderId();
    [SecurityCriticalAttribute]
public static void set_DefaultEtwProviderId(Guid value);
    [SecuritySafeCriticalAttribute]
public bool get_IsEtwProviderEnabled();
    [SecuritySafeCriticalAttribute]
public bool get_IsEnd2EndActivityTracingEnabled();
    [SecuritySafeCriticalAttribute]
private bool get_EtwTracingEnabled();
    [SecuritySafeCriticalAttribute]
public void SetEnd2EndActivityTracingEnabled(bool isEnd2EndTracingEnabled);
    [SecurityCriticalAttribute]
public void Event(EventDescriptor& eventDescriptor, string description);
    public void SetAndTraceTransfer(Guid newId, bool emitTransfer);
    [SecuritySafeCriticalAttribute]
public void TraceTransfer(Guid newId);
    [SecurityCriticalAttribute]
public void WriteTraceSource(EventDescriptor& eventDescriptor, string description, TracePayload payload);
    private static string LookupChannel(TraceChannel traceChannel);
    public TracePayload GetSerializedPayload(object source, TraceRecord traceRecord, Exception exception);
    public TracePayload GetSerializedPayload(object source, TraceRecord traceRecord, Exception exception, bool getServiceReference);
    [SecuritySafeCriticalAttribute]
public bool IsEtwEventEnabled(EventDescriptor& eventDescriptor);
    [SecuritySafeCriticalAttribute]
public bool IsEtwEventEnabled(EventDescriptor& eventDescriptor, bool fullCheck);
    public virtual bool IsEnabled();
    internal static string ExceptionToTraceString(Exception exception, int maxTraceStringLength);
    private static void WriteExceptionToTraceString(XmlWriter xml, Exception exception, int remainingLength, int remainingAllowedRecursionDepth);
    private static string GetInnerException(Exception exception, int remainingLength, int remainingAllowedRecursionDepth);
    private static string GetExceptionData(Exception exception);
    private static bool WriteStartElement(XmlWriter xml, string localName, Int32& remainingLength);
    private static bool WriteXmlElementString(XmlWriter xml, string localName, string value, Int32& remainingLength);
}
internal class System.Runtime.Diagnostics.EventDescriptor : ValueType {
    private ushort _id;
    private byte _version;
    private byte _channel;
    private byte _level;
    private byte _opcode;
    private ushort _task;
    private long _keywords;
    public int EventId { get; }
    public byte Version { get; }
    public byte Channel { get; }
    public byte Level { get; }
    public byte Opcode { get; }
    public int Task { get; }
    public long Keywords { get; }
    public EventDescriptor(int id, byte version, byte channel, byte level, byte opcode, int task, long keywords);
    public int get_EventId();
    public byte get_Version();
    public byte get_Channel();
    public byte get_Level();
    public byte get_Opcode();
    public int get_Task();
    public long get_Keywords();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public bool Equals(EventDescriptor other);
    public static bool op_Equality(EventDescriptor event1, EventDescriptor event2);
    public static bool op_Inequality(EventDescriptor event1, EventDescriptor event2);
}
internal enum System.Runtime.Diagnostics.EventFacility : Enum {
    public UInt32 value__;
    public static EventFacility Tracing;
    public static EventFacility ServiceModel;
    public static EventFacility TransactionBridge;
    public static EventFacility SMSvcHost;
    public static EventFacility InfoCards;
    public static EventFacility SecurityAudit;
}
internal enum System.Runtime.Diagnostics.EventLogCategory : Enum {
    public ushort value__;
    public static EventLogCategory ServiceAuthorization;
    public static EventLogCategory MessageAuthentication;
    public static EventLogCategory ObjectAccess;
    public static EventLogCategory Tracing;
    public static EventLogCategory WebHost;
    public static EventLogCategory FailFast;
    public static EventLogCategory MessageLogging;
    public static EventLogCategory PerformanceCounter;
    public static EventLogCategory Wmi;
    public static EventLogCategory ComPlus;
    public static EventLogCategory StateMachine;
    public static EventLogCategory Wsat;
    public static EventLogCategory SharingService;
    public static EventLogCategory ListenerAdapter;
}
internal enum System.Runtime.Diagnostics.EventLogEventId : Enum {
    public UInt32 value__;
    public static EventLogEventId FailedToSetupTracing;
    public static EventLogEventId FailedToInitializeTraceSource;
    public static EventLogEventId FailFast;
    public static EventLogEventId FailFastException;
    public static EventLogEventId FailedToTraceEvent;
    public static EventLogEventId FailedToTraceEventWithException;
    public static EventLogEventId InvariantAssertionFailed;
    public static EventLogEventId PiiLoggingOn;
    public static EventLogEventId PiiLoggingNotAllowed;
    public static EventLogEventId WebHostUnhandledException;
    public static EventLogEventId WebHostHttpError;
    public static EventLogEventId WebHostFailedToProcessRequest;
    public static EventLogEventId WebHostFailedToListen;
    public static EventLogEventId FailedToLogMessage;
    public static EventLogEventId RemovedBadFilter;
    public static EventLogEventId FailedToCreateMessageLoggingTraceSource;
    public static EventLogEventId MessageLoggingOn;
    public static EventLogEventId MessageLoggingOff;
    public static EventLogEventId FailedToLoadPerformanceCounter;
    public static EventLogEventId FailedToRemovePerformanceCounter;
    public static EventLogEventId WmiGetObjectFailed;
    public static EventLogEventId WmiPutInstanceFailed;
    public static EventLogEventId WmiDeleteInstanceFailed;
    public static EventLogEventId WmiCreateInstanceFailed;
    public static EventLogEventId WmiExecQueryFailed;
    public static EventLogEventId WmiExecMethodFailed;
    public static EventLogEventId WmiRegistrationFailed;
    public static EventLogEventId WmiUnregistrationFailed;
    public static EventLogEventId WmiAdminTypeMismatch;
    public static EventLogEventId WmiPropertyMissing;
    public static EventLogEventId ComPlusServiceHostStartingServiceError;
    public static EventLogEventId ComPlusDllHostInitializerStartingError;
    public static EventLogEventId ComPlusTLBImportError;
    public static EventLogEventId ComPlusInvokingMethodFailed;
    public static EventLogEventId ComPlusInstanceCreationError;
    public static EventLogEventId ComPlusInvokingMethodFailedMismatchedTransactions;
    public static EventLogEventId WebHostNotLoggingInsufficientMemoryExceptionsOnActivationForNextTimeInterval;
    public static EventLogEventId UnhandledStateMachineExceptionRecordDescription;
    public static EventLogEventId FatalUnexpectedStateMachineEvent;
    public static EventLogEventId ParticipantRecoveryLogEntryCorrupt;
    public static EventLogEventId CoordinatorRecoveryLogEntryCorrupt;
    public static EventLogEventId CoordinatorRecoveryLogEntryCreationFailure;
    public static EventLogEventId ParticipantRecoveryLogEntryCreationFailure;
    public static EventLogEventId ProtocolInitializationFailure;
    public static EventLogEventId ProtocolStartFailure;
    public static EventLogEventId ProtocolRecoveryBeginningFailure;
    public static EventLogEventId ProtocolRecoveryCompleteFailure;
    public static EventLogEventId TransactionBridgeRecoveryFailure;
    public static EventLogEventId ProtocolStopFailure;
    public static EventLogEventId NonFatalUnexpectedStateMachineEvent;
    public static EventLogEventId PerformanceCounterInitializationFailure;
    public static EventLogEventId ProtocolRecoveryComplete;
    public static EventLogEventId ProtocolStopped;
    public static EventLogEventId ThumbPrintNotFound;
    public static EventLogEventId ThumbPrintNotValidated;
    public static EventLogEventId SslNoPrivateKey;
    public static EventLogEventId SslNoAccessiblePrivateKey;
    public static EventLogEventId MissingNecessaryKeyUsage;
    public static EventLogEventId MissingNecessaryEnhancedKeyUsage;
    public static EventLogEventId StartErrorPublish;
    public static EventLogEventId BindingError;
    public static EventLogEventId LAFailedToListenForApp;
    public static EventLogEventId UnknownListenerAdapterError;
    public static EventLogEventId WasDisconnected;
    public static EventLogEventId WasConnectionTimedout;
    public static EventLogEventId ServiceStartFailed;
    public static EventLogEventId MessageQueueDuplicatedSocketLeak;
    public static EventLogEventId MessageQueueDuplicatedPipeLeak;
    public static EventLogEventId SharingUnhandledException;
    public static EventLogEventId ServiceAuthorizationSuccess;
    public static EventLogEventId ServiceAuthorizationFailure;
    public static EventLogEventId MessageAuthenticationSuccess;
    public static EventLogEventId MessageAuthenticationFailure;
    public static EventLogEventId SecurityNegotiationSuccess;
    public static EventLogEventId SecurityNegotiationFailure;
    public static EventLogEventId TransportAuthenticationSuccess;
    public static EventLogEventId TransportAuthenticationFailure;
    public static EventLogEventId ImpersonationSuccess;
    public static EventLogEventId ImpersonationFailure;
}
internal enum System.Runtime.Diagnostics.EventSeverity : Enum {
    public UInt32 value__;
    public static EventSeverity Success;
    public static EventSeverity Informational;
    public static EventSeverity Warning;
    public static EventSeverity Error;
}
public class System.Runtime.Diagnostics.EventTraceActivity : object {
    public Guid ActivityId;
    private static EventTraceActivity s_empty;
    public static EventTraceActivity Empty { get; }
    public static string Name { get; }
    public EventTraceActivity(bool setOnThread);
    public EventTraceActivity(Guid guid, bool setOnThread);
    public static EventTraceActivity get_Empty();
    public static string get_Name();
    [SecuritySafeCriticalAttribute]
public static EventTraceActivity GetFromThreadOrCreate(bool clearIdOnThread);
    [SecuritySafeCriticalAttribute]
public static Guid GetActivityIdFromThread();
    public void SetActivityId(Guid guid);
    [SecuritySafeCriticalAttribute]
private void SetActivityIdOnThread();
}
internal interface System.Runtime.Diagnostics.ITraceSourceStringProvider {
    public abstract virtual string GetSourceString();
}
internal class System.Runtime.Diagnostics.StringTraceRecord : TraceRecord {
    private string _elementName;
    private string _content;
    internal string EventId { get; }
    internal StringTraceRecord(string elementName, string content);
    internal virtual string get_EventId();
    internal virtual void WriteTo(XmlWriter writer);
}
public class System.Runtime.Diagnostics.TraceRecord : object {
    protected static string EventIdBase;
    protected static string NamespaceSuffix;
    internal string EventId { get; }
    internal virtual string get_EventId();
    internal virtual void WriteTo(XmlWriter writer);
    protected string BuildEventId(string eventId);
    protected string XmlEncode(string text);
}
internal static class System.Runtime.DiagnosticStrings : object {
    internal static string AppDomain;
    internal static string ChannelTag;
    internal static string Description;
    internal static string DataTag;
    internal static string DataItemsTag;
    internal static string DescriptionTag;
    internal static string ExceptionTag;
    internal static string ExceptionTypeTag;
    internal static string ExceptionStringTag;
    internal static string ExtendedDataTag;
    internal static string InnerExceptionTag;
    internal static string KeyTag;
    internal static string MessageTag;
    internal static string NamespaceTag;
    internal static string NativeErrorCodeTag;
    internal static string Separator;
    internal static string SeverityTag;
    internal static string SourceTag;
    internal static string StackTraceTag;
    internal static string Task;
    internal static string TraceCodeTag;
    internal static string TraceRecordTag;
    internal static string ValueTag;
}
internal class System.Runtime.ExceptionTrace : object {
    private static ushort FailFastEventLogCategory;
    private string _eventSourceName;
    private EtwDiagnosticTrace _diagnosticTrace;
    public ExceptionTrace(string eventSourceName, EtwDiagnosticTrace diagnosticTrace);
    public void AsInformation(Exception exception);
    public void AsWarning(Exception exception);
    public Exception AsError(Exception exception);
    public Exception AsError(Exception exception, string eventSource);
    public Exception AsError(TargetInvocationException targetInvocationException, string eventSource);
    public Exception AsError(AggregateException aggregateException);
    public Exception AsError(AggregateException aggregateException, string eventSource);
    public ArgumentException Argument(string paramName, string message);
    public ArgumentNullException ArgumentNull(string paramName);
    public ArgumentNullException ArgumentNull(string paramName, string message);
    public ArgumentException ArgumentNullOrEmpty(string paramName);
    public ArgumentOutOfRangeException ArgumentOutOfRange(string paramName, object actualValue, string message);
    public ObjectDisposedException ObjectDisposed(string message);
    public void TraceUnhandledException(Exception exception);
    public void TraceEtwException(Exception exception, EventLevel eventLevel);
    private TException TraceException(TException exception);
    [SecuritySafeCriticalAttribute]
private TException TraceException(TException exception, string eventSource);
    [SecuritySafeCriticalAttribute]
private void BreakOnException(Exception exception);
    internal void TraceFailFast(string message);
}
internal class System.Runtime.FatalException : Exception {
    public FatalException(string message);
    public FatalException(string message, Exception innerException);
    protected FatalException(SerializationInfo info, StreamingContext context);
}
public static class System.Runtime.Fx : object {
    private static string defaultEventSource;
    private static ExceptionTrace s_exceptionTrace;
    private static EtwDiagnosticTrace s_diagnosticTrace;
    [SecurityCriticalAttribute]
private static ExceptionHandler s_asynchronousThreadExceptionHandler;
    internal static ExceptionTrace Exception { get; }
    internal static EtwDiagnosticTrace Trace { get; }
    public static ExceptionHandler AsynchronousThreadExceptionHandler { get; public set; }
    internal static bool AssertsFailFast { get; }
    internal static Type[] BreakOnExceptionTypes { get; }
    internal static bool StealthDebugger { get; }
    internal static ExceptionTrace get_Exception();
    internal static EtwDiagnosticTrace get_Trace();
    [SecuritySafeCriticalAttribute]
private static EtwDiagnosticTrace InitializeTracing();
    [SecuritySafeCriticalAttribute]
public static ExceptionHandler get_AsynchronousThreadExceptionHandler();
    [SecurityCriticalAttribute]
public static void set_AsynchronousThreadExceptionHandler(ExceptionHandler value);
    [ConditionalAttribute("DEBUG")]
public static void Assert(bool condition, string description);
    [ConditionalAttribute("DEBUG")]
public static void Assert(string description);
    public static void AssertAndThrow(bool condition, string description);
    public static Exception AssertAndThrow(string description);
    public static void AssertAndThrowFatal(bool condition, string description);
    public static Exception AssertAndThrowFatal(string description);
    public static void AssertAndFailFast(bool condition, string description);
    [SecuritySafeCriticalAttribute]
public static Exception AssertAndFailFast(string description);
    public static bool IsFatal(Exception exception);
    internal static bool get_AssertsFailFast();
    internal static Type[] get_BreakOnExceptionTypes();
    internal static bool get_StealthDebugger();
    public static AsyncCallback ThunkCallback(AsyncCallback callback);
    public static Action`1<T1> ThunkCallback(Action`1<T1> callback);
    public static Guid CreateGuid(string guidString);
    public static bool TryCreateGuid(string guidString, Guid& result);
    public static Byte[] AllocateByteArray(int size);
    public static Char[] AllocateCharArray(int size);
    private static void TraceExceptionNoThrow(Exception exception);
    private static bool HandleAtThreadBase(Exception exception);
    private static void UpdateLevel(EtwDiagnosticTrace trace);
    private static void UpdateLevel();
}
internal static class System.Runtime.FxCop : object {
}
internal class System.Runtime.InputQueue`1 : object {
    private static Action`1<object> s_completeOutstandingReadersCallback;
    private static Action`1<object> s_completeWaitersFalseCallback;
    private static Action`1<object> s_completeWaitersTrueCallback;
    private static Action`1<object> s_onDispatchCallback;
    private static Action`1<object> s_onInvokeDequeuedCallback;
    private QueueState<T> _queueState;
    private ItemQueue<T> _itemQueue;
    private Queue`1<IQueueReader<T>> _readerQueue;
    private List`1<IQueueWaiter<T>> _waiterList;
    [CompilerGeneratedAttribute]
private Action`1<T> <DisposeItemCallback>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`1<Action`2<AsyncCallback, IAsyncResult>> <AsyncCallbackGenerator>k__BackingField;
    public int PendingCount { get; }
    public Action`1<T> DisposeItemCallback { get; public set; }
    private Func`1<Action`2<AsyncCallback, IAsyncResult>> AsyncCallbackGenerator { get; private set; }
    private object ThisLock { get; }
    public InputQueue`1(Func`1<Action`2<AsyncCallback, IAsyncResult>> asyncCallbackGenerator);
    public int get_PendingCount();
    [CompilerGeneratedAttribute]
public Action`1<T> get_DisposeItemCallback();
    [CompilerGeneratedAttribute]
public void set_DisposeItemCallback(Action`1<T> value);
    [CompilerGeneratedAttribute]
private Func`1<Action`2<AsyncCallback, IAsyncResult>> get_AsyncCallbackGenerator();
    [CompilerGeneratedAttribute]
private void set_AsyncCallbackGenerator(Func`1<Action`2<AsyncCallback, IAsyncResult>> value);
    private object get_ThisLock();
    public IAsyncResult BeginDequeue(TimeSpan timeout, AsyncCallback callback, object state);
    public IAsyncResult BeginWaitForItem(TimeSpan timeout, AsyncCallback callback, object state);
    public void Close();
    public T Dequeue(TimeSpan timeout);
    public bool Dequeue(TimeSpan timeout, T& value);
    public void Dispatch();
    public bool EndDequeue(IAsyncResult result, T& value);
    public T EndDequeue(IAsyncResult result);
    public bool EndWaitForItem(IAsyncResult result);
    public void EnqueueAndDispatch(T item);
    public void EnqueueAndDispatch(T item, Action dequeuedCallback);
    public void EnqueueAndDispatch(Exception exception, Action dequeuedCallback, bool canDispatchOnThisThread);
    public void EnqueueAndDispatch(T item, Action dequeuedCallback, bool canDispatchOnThisThread);
    public bool EnqueueWithoutDispatch(T item, Action dequeuedCallback);
    public bool EnqueueWithoutDispatch(Exception exception, Action dequeuedCallback);
    public void Shutdown();
    public void Shutdown(Func`1<Exception> pendingExceptionGenerator);
    public bool WaitForItem(TimeSpan timeout);
    public sealed virtual void Dispose();
    private void DisposeItem(Item<T> item);
    private static void CompleteOutstandingReadersCallback(object state);
    private static void CompleteWaiters(bool itemAvailable, IQueueWaiter[] waiters);
    private static void CompleteWaitersFalseCallback(object state);
    private static void CompleteWaitersLater(bool itemAvailable, IQueueWaiter[] waiters);
    private static void CompleteWaitersTrueCallback(object state);
    private static void InvokeDequeuedCallback(Action dequeuedCallback);
    private static void InvokeDequeuedCallbackLater(Action dequeuedCallback);
    private static void OnDispatchCallback(object state);
    private static void OnInvokeDequeuedCallback(object state);
    private void EnqueueAndDispatch(Item<T> item, bool canDispatchOnThisThread);
    private bool EnqueueWithoutDispatch(Item<T> item);
    private void GetWaiters(IQueueWaiter[]& waiters);
    private bool RemoveReader(IQueueReader<T> reader);
}
internal abstract class System.Runtime.InternalBufferManager : object {
    public abstract virtual Byte[] TakeBuffer(int bufferSize);
    public abstract virtual void ReturnBuffer(Byte[] buffer);
    public abstract virtual void Clear();
    public static InternalBufferManager Create(long maxBufferPoolSize, int maxBufferSize);
}
internal class System.Runtime.InternalSR : object {
    internal static string ActionItemIsAlreadyScheduled;
    internal static string AsyncCallbackThrewException;
    internal static string AsyncResultAlreadyEnded;
    internal static string BufferIsNotRightSizeForBufferManager;
    internal static string InvalidAsyncResult;
    internal static string InvalidAsyncResultImplementationGeneric;
    internal static string InvalidNullAsyncResult;
    internal static string InvalidSemaphoreExit;
    internal static string ReadNotSupported;
    internal static string SeekNotSupported;
    internal static string ValueMustBeNonNegative;
    internal static string AsyncResultCompletedTwice;
    private static InternalSR();
    internal static string ArgumentNullOrEmpty(object param0);
    internal static string BufferedOutputStreamQuotaExceeded(object param0);
    internal static string FailFastMessage(object param0);
    internal static string InvalidAsyncResultImplementation(object param0);
    internal static string ShipAssertExceptionMessage(object param0);
    internal static string TaskTimedOutError(object param0);
    internal static string TimeoutInputQueueDequeue(object param0);
    internal static string TimeoutMustBeNonNegative(object param0, object param1);
    internal static string TimeoutMustBePositive(object param0, object param1);
}
internal class System.Runtime.IOThreadScheduler : object {
    private static int MaximumCapacity;
    private static IOThreadScheduler current;
    private Slot[] slots;
    private int headTail;
    private int SlotMask { get; }
    private IOThreadScheduler(int capacity);
    private static IOThreadScheduler();
    public static void ScheduleCallbackNoFlow(SendOrPostCallback callback, object state);
    public static void IOCallback(object scheduler);
    private bool ScheduleCallbackHelper(SendOrPostCallback callback, object state);
    private void CompletionCallback(SendOrPostCallback& callback, Object& state);
    private bool TryCoalesce(SendOrPostCallback& callback, Object& state);
    private int get_SlotMask();
    protected virtual override void Finalize();
    private void Cleanup();
}
internal class System.Runtime.IOTimer`1 : object {
    private Action`1<TState> _callback;
    private TState _state;
    private Timer _timer;
    private bool _enabled;
    private DateTime _dueDateTime;
    private static double MaxSkew;
    public IOTimer`1(Action`1<TState> callback, TState state);
    public void Cancel();
    public void ScheduleAfter(TimeSpan delay);
    private void OnTimer(object state);
    public sealed virtual void Dispose();
}
public class System.Runtime.MruCache`2 : object {
    private LinkedList`1<TKey> _mruList;
    private Dictionary`2<TKey, CacheEntry<TKey, TValue>> _items;
    private int _lowWatermark;
    private int _highWatermark;
    private CacheEntry<TKey, TValue> _mruEntry;
    public int Count { get; }
    public MruCache`2(int watermark);
    public MruCache`2(int lowWatermark, int highWatermark);
    public MruCache`2(int lowWatermark, int highWatermark, IEqualityComparer`1<TKey> comparer);
    public int get_Count();
    public void Add(TKey key, TValue value);
    public void Clear();
    public bool Remove(TKey key);
    protected virtual void OnSingleItemRemoved(TValue item);
    protected virtual void OnItemAgedOutOfCache(TValue item);
    public bool TryGetValue(TKey key, TValue& value);
}
public class System.Runtime.OutWrapper`1 : object {
    [CompilerGeneratedAttribute]
private T <Value>k__BackingField;
    public T Value { get; public set; }
    [CompilerGeneratedAttribute]
public T get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(T value);
    public static T op_Implicit(OutWrapper`1<T> wrapper);
}
internal abstract class System.Runtime.ScheduleActionItemAsyncResult : AsyncResult {
    private static Action`1<object> s_doWork;
    protected ScheduleActionItemAsyncResult(AsyncCallback callback, object state);
    private static ScheduleActionItemAsyncResult();
    protected void Schedule();
    private static void DoWork(object state);
    protected abstract virtual void OnDoWork();
    public static void End(IAsyncResult result);
}
public class System.Runtime.Serialization.GeneratedXmlSerializers : object {
    private static Dictionary`2<string, Type> s_generatedSerializers;
    public static bool IsInitialized { get; }
    private static GeneratedXmlSerializers();
    public static Dictionary`2<string, Type> GetGeneratedSerializers();
    public static bool get_IsInitialized();
}
public class System.Runtime.ServiceModelSynchronizationContext : SynchronizationContext {
    public static ServiceModelSynchronizationContext Instance;
    private static ServiceModelSynchronizationContext();
    public virtual void Post(SendOrPostCallback d, object state);
}
internal class System.Runtime.SignalGate : object {
    private int _state;
    internal bool IsLocked { get; }
    internal bool IsSignalled { get; }
    internal bool get_IsLocked();
    internal bool get_IsSignalled();
    public bool Signal();
    public bool Unlock();
    private void ThrowInvalidSignalGateState();
}
internal class System.Runtime.SignalGate`1 : SignalGate {
    private T _result;
    public bool Signal(T result);
    public bool Unlock(T& result);
}
internal class System.Runtime.SynchronizedPool`1 : object {
    private static int maxPendingEntries;
    private static int maxPromotionFailures;
    private static int maxReturnsBeforePromotion;
    private static int maxThreadItemsPerProcessor;
    private Entry[] _entries;
    private GlobalPool<T> _globalPool;
    private int _maxCount;
    private PendingEntry[] _pending;
    private int _promotionFailures;
    private object ThisLock { get; }
    public SynchronizedPool`1(int maxCount);
    private object get_ThisLock();
    public void Clear();
    private void HandlePromotionFailure(int thisThreadID);
    private bool PromoteThread(int thisThreadID);
    private void RecordReturnToGlobalPool(int thisThreadID);
    private void RecordTakeFromGlobalPool(int thisThreadID);
    public bool Return(T value);
    private bool ReturnToPerThreadPool(int thisThreadID, T value);
    private bool ReturnToGlobalPool(int thisThreadID, T value);
    public T Take();
    private T TakeFromPerThreadPool(int thisThreadID);
    private T TakeFromGlobalPool(int thisThreadID);
}
[ExtensionAttribute]
public static class System.Runtime.TaskHelpers : object {
    public static Action`1<object> OnAsyncCompletionCallback;
    private static TaskHelpers();
    [AsyncStateMachineAttribute("System.Runtime.TaskHelpers/<AsyncWait>d__0`1")]
[ExtensionAttribute]
public static Task AsyncWait(Task task);
    [ExtensionAttribute]
public static Task`1<TResult> ToApm(Task`1<TResult> task, AsyncCallback callback, object state);
    [ExtensionAttribute]
public static Task ToApm(Task task, AsyncCallback callback, object state);
    [ExtensionAttribute]
public static TResult ToApmEnd(IAsyncResult iar);
    [ExtensionAttribute]
public static void ToApmEnd(IAsyncResult iar);
    [AsyncStateMachineAttribute("System.Runtime.TaskHelpers/<AwaitWithTimeout>d__5")]
[ExtensionAttribute]
public static Task`1<bool> AwaitWithTimeout(Task task, TimeSpan timeout);
    [ExtensionAttribute]
public static void WaitForCompletion(Task task);
    [ExtensionAttribute]
public static void WaitForCompletionNoSpin(Task task);
    [ExtensionAttribute]
public static TResult WaitForCompletion(Task`1<TResult> task);
    [ExtensionAttribute]
public static TResult WaitForCompletionNoSpin(Task`1<TResult> task);
    [ExtensionAttribute]
public static bool WaitForCompletionNoSpin(Task task, TimeSpan timeout);
    [ExtensionAttribute]
public static void Wait(Task task, TimeSpan timeout, Action`3<Exception, TimeSpan, string> exceptionConverter, string operationType);
    public static Task CompletedTask();
    public static DefaultTaskSchedulerAwaiter EnsureDefaultTaskScheduler();
    private static void OnAsyncCompletion(object state);
    public static IDisposable RunTaskContinuationsOnOurThreads();
    [AsyncStateMachineAttribute("System.Runtime.TaskHelpers/<CallActionAsync>d__17`1")]
public static Task CallActionAsync(Action`1<TArg> action, TArg argument);
}
internal static class System.Runtime.Ticks : object {
    public static long Now { get; }
    [SecuritySafeCriticalAttribute]
public static long get_Now();
    public static long FromMilliseconds(int milliseconds);
    public static int ToMilliseconds(long ticks);
    public static long FromTimeSpan(TimeSpan duration);
    public static TimeSpan ToTimeSpan(long ticks);
    public static long Add(long firstTicks, long secondTicks);
}
public class System.Runtime.TimeoutHelper : ValueType {
    public static TimeSpan MaxWait;
    private static CancellationToken s_precancelledToken;
    private bool _cancellationTokenInitialized;
    private bool _deadlineSet;
    private CancellationToken _cancellationToken;
    private DateTime _deadline;
    private TimeSpan _originalTimeout;
    public TimeSpan OriginalTimeout { get; }
    public TimeoutHelper(TimeSpan timeout);
    private static TimeoutHelper();
    public CancellationToken GetCancellationToken();
    [AsyncStateMachineAttribute("System.Runtime.TimeoutHelper/<GetCancellationTokenAsync>d__9")]
public Task`1<CancellationToken> GetCancellationTokenAsync();
    public TimeSpan get_OriginalTimeout();
    public static bool IsTooLarge(TimeSpan timeout);
    public static TimeSpan FromMilliseconds(int milliseconds);
    public static int ToMilliseconds(TimeSpan timeout);
    public static TimeSpan Min(TimeSpan val1, TimeSpan val2);
    public static TimeSpan Add(TimeSpan timeout1, TimeSpan timeout2);
    public static DateTime Add(DateTime time, TimeSpan timeout);
    public static DateTime Subtract(DateTime time, TimeSpan timeout);
    public static TimeSpan Divide(TimeSpan timeout, int factor);
    public TimeSpan RemainingTime();
    public TimeSpan ElapsedTime();
    private void SetDeadline();
    public static void ThrowIfNegativeArgument(TimeSpan timeout);
    public static void ThrowIfNegativeArgument(TimeSpan timeout, string argumentName);
    public static void ThrowIfNonPositiveArgument(TimeSpan timeout);
    public static void ThrowIfNonPositiveArgument(TimeSpan timeout, string argumentName);
    public static bool WaitOne(WaitHandle waitHandle, TimeSpan timeout);
    internal static TimeoutException CreateEnterTimedOutException(TimeSpan timeout);
}
internal static class System.Runtime.TimeoutTokenSource : object {
    private static int CoalescingFactor;
    private static int GranularityFactor;
    private static int SegmentationFactor;
    private static ConcurrentDictionary`2<long, Task`1<CancellationToken>> s_tokenCache;
    private static Action`1<object> s_deregisterToken;
    private static TimeoutTokenSource();
    public static CancellationToken FromTimeout(int millisecondsTimeout);
    public static Task`1<CancellationToken> FromTimeoutAsync(int millisecondsTimeout);
}
internal enum System.Runtime.TraceChannel : Enum {
    public int value__;
    public static TraceChannel Admin;
    public static TraceChannel Operational;
    public static TraceChannel Analytic;
    public static TraceChannel Debug;
    public static TraceChannel Perf;
    public static TraceChannel Application;
}
internal class System.Runtime.TraceCore : object {
    private static ResourceManager resourceManager;
    private static CultureInfo resourceCulture;
    private static object syncLock;
    private static ResourceManager ResourceManager { get; }
    internal static CultureInfo Culture { get; internal set; }
    private static TraceCore();
    private static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static bool HandledExceptionIsEnabled(EtwDiagnosticTrace trace);
    internal static void HandledException(EtwDiagnosticTrace trace, string param0, Exception exception);
    internal static void ShipAssertExceptionMessage(EtwDiagnosticTrace trace, string param0);
    internal static bool ThrowingExceptionIsEnabled(EtwDiagnosticTrace trace);
    internal static void ThrowingException(EtwDiagnosticTrace trace, string param0, string param1, Exception exception);
    internal static bool UnhandledExceptionIsEnabled(EtwDiagnosticTrace trace);
    internal static void UnhandledException(EtwDiagnosticTrace trace, string param0, Exception exception);
    internal static bool TraceCodeEventLogCriticalIsEnabled(EtwDiagnosticTrace trace);
    internal static void TraceCodeEventLogCritical(EtwDiagnosticTrace trace, TraceRecord traceRecord);
    internal static bool TraceCodeEventLogErrorIsEnabled(EtwDiagnosticTrace trace);
    internal static void TraceCodeEventLogError(EtwDiagnosticTrace trace, TraceRecord traceRecord);
    internal static bool TraceCodeEventLogInfoIsEnabled(EtwDiagnosticTrace trace);
    internal static void TraceCodeEventLogInfo(EtwDiagnosticTrace trace, TraceRecord traceRecord);
    internal static bool TraceCodeEventLogVerboseIsEnabled(EtwDiagnosticTrace trace);
    internal static void TraceCodeEventLogVerbose(EtwDiagnosticTrace trace, TraceRecord traceRecord);
    internal static bool TraceCodeEventLogWarningIsEnabled(EtwDiagnosticTrace trace);
    internal static void TraceCodeEventLogWarning(EtwDiagnosticTrace trace, TraceRecord traceRecord);
    internal static bool HandledExceptionWarningIsEnabled(EtwDiagnosticTrace trace);
    internal static void HandledExceptionWarning(EtwDiagnosticTrace trace, string param0, Exception exception);
    internal static bool BufferPoolAllocationIsEnabled(EtwDiagnosticTrace trace);
    internal static void BufferPoolAllocation(EtwDiagnosticTrace trace, int Size);
    internal static bool BufferPoolChangeQuotaIsEnabled(EtwDiagnosticTrace trace);
    internal static void BufferPoolChangeQuota(EtwDiagnosticTrace trace, int PoolSize, int Delta);
    internal static bool ActionItemScheduledIsEnabled(EtwDiagnosticTrace trace);
    internal static void ActionItemScheduled(EtwDiagnosticTrace trace, EventTraceActivity eventTraceActivity);
    internal static bool ActionItemCallbackInvokedIsEnabled(EtwDiagnosticTrace trace);
    internal static void ActionItemCallbackInvoked(EtwDiagnosticTrace trace, EventTraceActivity eventTraceActivity);
    internal static bool HandledExceptionErrorIsEnabled(EtwDiagnosticTrace trace);
    internal static void HandledExceptionError(EtwDiagnosticTrace trace, string param0, Exception exception);
    internal static bool HandledExceptionVerboseIsEnabled(EtwDiagnosticTrace trace);
    internal static void HandledExceptionVerbose(EtwDiagnosticTrace trace, string param0, Exception exception);
    internal static bool EtwUnhandledExceptionIsEnabled(EtwDiagnosticTrace trace);
    internal static void EtwUnhandledException(EtwDiagnosticTrace trace, string param0, Exception exception);
    internal static bool ThrowingEtwExceptionIsEnabled(EtwDiagnosticTrace trace);
    internal static void ThrowingEtwException(EtwDiagnosticTrace trace, string param0, string param1, Exception exception);
    internal static bool ThrowingEtwExceptionVerboseIsEnabled(EtwDiagnosticTrace trace);
    internal static void ThrowingEtwExceptionVerbose(EtwDiagnosticTrace trace, string param0, string param1, Exception exception);
    internal static bool ThrowingExceptionVerboseIsEnabled(EtwDiagnosticTrace trace);
    internal static void ThrowingExceptionVerbose(EtwDiagnosticTrace trace, string param0, string param1, Exception exception);
}
internal class System.Runtime.TracePayload : ValueType {
    private string _serializedException;
    private string _eventSource;
    private string _appDomainFriendlyName;
    private string _extendedData;
    private string _hostReference;
    public string SerializedException { get; }
    public string EventSource { get; }
    public string AppDomainFriendlyName { get; }
    public string ExtendedData { get; }
    public string HostReference { get; }
    public TracePayload(string serializedException, string eventSource, string appDomainFriendlyName, string extendedData, string hostReference);
    public string get_SerializedException();
    public string get_EventSource();
    public string get_AppDomainFriendlyName();
    public string get_ExtendedData();
    public string get_HostReference();
}
internal static class System.Runtime.UrlUtility : object {
    private static Encoding s_asciiEncoding;
    private static Encoding AsciiEncoding { get; }
    private static Encoding get_AsciiEncoding();
    public static NameValueCollection ParseQueryString(string query);
    public static NameValueCollection ParseQueryString(string query, Encoding encoding);
    public static string UrlEncode(string str);
    public static string UrlPathEncode(string str);
    public static string UrlEncode(string str, Encoding encoding);
    public static string UrlEncodeUnicode(string str);
    private static string UrlEncodeUnicodeStringToStringInternal(string s, bool ignoreAscii);
    private static string UrlEncodeNonAscii(string str, Encoding e);
    private static string UrlEncodeSpaces(string str);
    public static Byte[] UrlEncodeToBytes(string str, Encoding e);
    public static string UrlDecode(string str, Encoding e);
    private static Byte[] UrlEncodeBytesToBytesInternal(Byte[] bytes, int offset, int count, bool alwaysCreateReturnValue);
    private static bool IsNonAsciiByte(byte b);
    private static Byte[] UrlEncodeBytesToBytesInternalNonAscii(Byte[] bytes, int offset, int count, bool alwaysCreateReturnValue);
    private static string UrlDecodeStringFromStringInternal(string s, Encoding e);
    private static int HexToInt(char h);
    private static char IntToHex(int n);
    internal static bool IsSafe(char ch);
}
internal static class System.Runtime.WaitCallbackActionItem : object {
    [CompilerGeneratedAttribute]
private static bool <ShouldUseActivity>k__BackingField;
    internal static bool ShouldUseActivity { get; internal set; }
    [CompilerGeneratedAttribute]
internal static bool get_ShouldUseActivity();
    [CompilerGeneratedAttribute]
internal static void set_ShouldUseActivity(bool value);
}
[EventSourceAttribute]
internal class System.Runtime.WcfEventSource : EventSource {
    public static WcfEventSource Instance;
    private static WcfEventSource();
    public bool BufferPoolAllocationIsEnabled();
    [EventAttribute("131")]
public void BufferPoolAllocation(int Size, string AppDomain);
    [NonEventAttribute]
public void BufferPoolAllocation(int Size);
    public bool BufferPoolChangeQuotaIsEnabled();
    [EventAttribute("132")]
public void BufferPoolChangeQuota(int PoolSize, int Delta, string AppDomain);
    [NonEventAttribute]
public void BufferPoolChangeQuota(int PoolSize, int Delta);
    public bool ActionItemScheduledIsEnabled();
    [EventAttribute("133")]
public void ActionItemScheduled(string AppDomain);
    [NonEventAttribute]
public void ActionItemScheduled();
    public bool ActionItemCallbackInvokedIsEnabled();
    [EventAttribute("134")]
public void ActionItemCallbackInvoked(string AppDomain);
    [NonEventAttribute]
public void ActionItemCallbackInvoked();
    public bool ClientMessageInspectorAfterReceiveInvokedIsEnabled();
    [EventAttribute("201")]
public void ClientMessageInspectorAfterReceiveInvoked(string TypeName, string HostReference, string AppDomain);
    [NonEventAttribute]
public void ClientMessageInspectorAfterReceiveInvoked(EventTraceActivity eventTraceActivity, string TypeName);
    public bool ClientMessageInspectorBeforeSendInvokedIsEnabled();
    [EventAttribute("202")]
public void ClientMessageInspectorBeforeSendInvoked(string TypeName, string HostReference, string AppDomain);
    [NonEventAttribute]
public void ClientMessageInspectorBeforeSendInvoked(EventTraceActivity eventTraceActivity, string TypeName);
    public bool ClientParameterInspectorAfterCallInvokedIsEnabled();
    [EventAttribute("203")]
public void ClientParameterInspectorAfterCallInvoked(string TypeName, string HostReference, string AppDomain);
    [NonEventAttribute]
public void ClientParameterInspectorAfterCallInvoked(EventTraceActivity eventTraceActivity, string TypeName);
    public bool ClientParameterInspectorBeforeCallInvokedIsEnabled();
    [EventAttribute("204")]
public void ClientParameterInspectorBeforeCallInvoked(string TypeName, string HostReference, string AppDomain);
    [NonEventAttribute]
public void ClientParameterInspectorBeforeCallInvoked(EventTraceActivity eventTraceActivity, string TypeName);
    public bool OperationInvokedIsEnabled();
    [EventAttribute("205")]
public void OperationInvoked(string MethodName, string CallerInfo, string HostReference, string AppDomain);
    [NonEventAttribute]
public void OperationInvoked(EventTraceActivity eventTraceActivity, string MethodName, string CallerInfo);
    public bool ErrorHandlerInvokedIsEnabled();
    [EventAttribute("206")]
public void ErrorHandlerInvoked(string TypeName, bool Handled, string ExceptionTypeName, string HostReference, string AppDomain);
    [NonEventAttribute]
public void ErrorHandlerInvoked(string TypeName, bool Handled, string ExceptionTypeName);
    public bool FaultProviderInvokedIsEnabled();
    [EventAttribute("207")]
public void FaultProviderInvoked(string TypeName, string ExceptionTypeName, string HostReference, string AppDomain);
    [NonEventAttribute]
public void FaultProviderInvoked(string TypeName, string ExceptionTypeName);
    public bool ParameterInspectorAfterCallInvokedIsEnabled();
    [EventAttribute("211")]
public void ParameterInspectorAfterCallInvoked(string TypeName, string HostReference, string AppDomain);
    [NonEventAttribute]
public void ParameterInspectorAfterCallInvoked(EventTraceActivity eventTraceActivity, string TypeName);
    public bool ParameterInspectorBeforeCallInvokedIsEnabled();
    [EventAttribute("212")]
public void ParameterInspectorBeforeCallInvoked(string TypeName, string HostReference, string AppDomain);
    [NonEventAttribute]
public void ParameterInspectorBeforeCallInvoked(EventTraceActivity eventTraceActivity, string TypeName);
    public bool OperationCompletedIsEnabled();
    [EventAttribute("214")]
public void OperationCompleted(string MethodName, long Duration, string HostReference, string AppDomain);
    [NonEventAttribute]
public void OperationCompleted(EventTraceActivity eventTraceActivity, string MethodName, long Duration);
    public bool MessageReceivedByTransportIsEnabled();
    [EventAttribute("215")]
public void MessageReceivedByTransport(string ListenAddress, string HostReference, string AppDomain);
    [NonEventAttribute]
public void MessageReceivedByTransport(EventTraceActivity eventTraceActivity, string ListenAddress, Guid relatedActivityId);
    public bool MessageSentByTransportIsEnabled();
    [EventAttribute("216")]
public void MessageSentByTransport(string DestinationAddress, string HostReference, string AppDomain);
    [NonEventAttribute]
public void MessageSentByTransport(EventTraceActivity eventTraceActivity, string DestinationAddress);
    public bool ClientOperationPreparedIsEnabled();
    [EventAttribute("217")]
public void ClientOperationPrepared(string Action, string ContractName, string Destination, string HostReference, string AppDomain);
    [NonEventAttribute]
public void ClientOperationPrepared(EventTraceActivity eventTraceActivity, string Action, string ContractName, string Destination, Guid relatedActivityId);
    public bool ServiceChannelCallStopIsEnabled();
    [EventAttribute("218")]
public void ServiceChannelCallStop(string Action, string ContractName, string Destination, string HostReference, string AppDomain);
    [NonEventAttribute]
public void ServiceChannelCallStop(EventTraceActivity eventTraceActivity, string Action, string ContractName, string Destination);
    public bool ServiceExceptionIsEnabled();
    [EventAttribute("219")]
public void ServiceException(string ExceptionToString, string ExceptionTypeName, string HostReference, string AppDomain);
    [NonEventAttribute]
public void ServiceException(string ExceptionToString, string ExceptionTypeName);
    public bool MessageSentToTransportIsEnabled();
    [EventAttribute("220")]
public void MessageSentToTransport(Guid CorrelationId, string HostReference, string AppDomain);
    [NonEventAttribute]
public void MessageSentToTransport(EventTraceActivity eventTraceActivity, Guid CorrelationId);
    public bool MessageReceivedFromTransportIsEnabled();
    [EventAttribute("221")]
public void MessageReceivedFromTransport(Guid CorrelationId, string HostReference, string AppDomain);
    [NonEventAttribute]
public void MessageReceivedFromTransport(EventTraceActivity eventTraceActivity, Guid CorrelationId, string HostReference);
    public bool OperationFailedIsEnabled();
    [EventAttribute("222")]
public void OperationFailed(string MethodName, long Duration, string HostReference, string AppDomain);
    [NonEventAttribute]
public void OperationFailed(EventTraceActivity eventTraceActivity, string MethodName, long Duration);
    public bool OperationFaultedIsEnabled();
    [EventAttribute("223")]
public void OperationFaulted(string MethodName, long Duration, string HostReference, string AppDomain);
    [NonEventAttribute]
public void OperationFaulted(EventTraceActivity eventTraceActivity, string MethodName, long Duration);
    public bool ServiceChannelOpenStartIsEnabled();
    [EventAttribute("701")]
public void ServiceChannelOpenStart(string AppDomain);
    [NonEventAttribute]
public void ServiceChannelOpenStart(EventTraceActivity eventTraceActivity);
    public bool ServiceChannelOpenStopIsEnabled();
    [EventAttribute("702")]
public void ServiceChannelOpenStop(string AppDomain);
    [NonEventAttribute]
public void ServiceChannelOpenStop(EventTraceActivity eventTraceActivity);
    public bool ServiceChannelCallStartIsEnabled();
    [EventAttribute("703")]
public void ServiceChannelCallStart(string AppDomain);
    [NonEventAttribute]
public void ServiceChannelCallStart(EventTraceActivity eventTraceActivity);
    [EventAttribute("704")]
public void ServiceChannelBeginCallStart(string AppDomain);
    [NonEventAttribute]
public void ServiceChannelBeginCallStart(EventTraceActivity eventTraceActivity);
    public bool DispatchMessageStartIsEnabled();
    [EventAttribute("709")]
public void DispatchMessageStart(string HostReference, string AppDomain);
    [NonEventAttribute]
public void DispatchMessageStart(EventTraceActivity eventTraceActivity);
    public bool DispatchMessageStopIsEnabled();
    [EventAttribute("712")]
public void DispatchMessageStop(string AppDomain);
    [NonEventAttribute]
public void DispatchMessageStop(EventTraceActivity eventTraceActivity);
    public bool ClientChannelOpenStartIsEnabled();
    [EventAttribute("715")]
public void ClientChannelOpenStart(string AppDomain);
    [NonEventAttribute]
public void ClientChannelOpenStart(EventTraceActivity eventTraceActivity);
    public bool ClientChannelOpenStopIsEnabled();
    [EventAttribute("716")]
public void ClientChannelOpenStop(string AppDomain);
    [NonEventAttribute]
public void ClientChannelOpenStop(EventTraceActivity eventTraceActivity);
    [EventAttribute("1032")]
public void ScheduleRuntimeWorkItem(string data1, string data2, string data3, string AppDomain);
    public bool CloseTimeoutIsEnabled();
    [EventAttribute("1401")]
public void CloseTimeout(string data1, string AppDomain);
    [NonEventAttribute]
public void CloseTimeout(string data1);
    public bool IdleTimeoutIsEnabled();
    [EventAttribute("1402")]
public void IdleTimeout(string msg, string key, string AppDomain);
    [NonEventAttribute]
public void IdleTimeout(string msg, string key);
    public bool LeaseTimeoutIsEnabled();
    [EventAttribute("1403")]
public void LeaseTimeout(string msg, string key, string AppDomain);
    [NonEventAttribute]
public void LeaseTimeout(string msg, string key);
    public bool ReceiveTimeoutIsEnabled();
    [EventAttribute("1406")]
public void ReceiveTimeout(string data1, string AppDomain);
    [NonEventAttribute]
public void ReceiveTimeout(string data1);
    public bool MaxReceivedMessageSizeExceededIsEnabled();
    [EventAttribute("1416")]
public void MaxReceivedMessageSizeExceeded(string data1, string AppDomain);
    [NonEventAttribute]
public void MaxReceivedMessageSizeExceeded(string data1);
    public bool MaxSentMessageSizeExceededIsEnabled();
    [EventAttribute("1417")]
public void MaxSentMessageSizeExceeded(string data1, string AppDomain);
    [NonEventAttribute]
public void MaxSentMessageSizeExceeded(string data1);
    public bool MaxOutboundConnectionsPerEndpointExceededIsEnabled();
    [EventAttribute("1418")]
public void MaxOutboundConnectionsPerEndpointExceeded(string data1, string AppDomain);
    [NonEventAttribute]
public void MaxOutboundConnectionsPerEndpointExceeded(string data1);
    public bool OutboundConnectionsPerEndpointRatioIsEnabled();
    [EventAttribute("1433")]
public void OutboundConnectionsPerEndpointRatio(int cur, int max, string AppDomain);
    [NonEventAttribute]
public void OutboundConnectionsPerEndpointRatio(int cur, int max);
    public bool MaxSessionSizeReachedIsEnabled();
    [EventAttribute("1441")]
public void MaxSessionSizeReached(string data1, string AppDomain);
    [NonEventAttribute]
public void MaxSessionSizeReached(string data1);
    public bool ReadPoolMissIsEnabled();
    [EventAttribute("1445")]
public void ReadPoolMiss(string itemTypeName, string AppDomain);
    [NonEventAttribute]
public void ReadPoolMiss(string itemTypeName);
    public bool WritePoolMissIsEnabled();
    [EventAttribute("1446")]
public void WritePoolMiss(string itemTypeName, string AppDomain);
    [NonEventAttribute]
public void WritePoolMiss(string itemTypeName);
    public bool MessageReadByEncoderIsEnabled();
    [EventAttribute("3312")]
public void MessageReadByEncoder(int Size, string EventSource, string AppDomain);
    [NonEventAttribute]
public void MessageReadByEncoder(EventTraceActivity eventTraceActivity, int Size, object source);
    public bool MessageWrittenByEncoderIsEnabled();
    [EventAttribute("3313")]
public void MessageWrittenByEncoder(int Size, string EventSource, string AppDomain);
    [NonEventAttribute]
public void MessageWrittenByEncoder(EventTraceActivity eventTraceActivity, int Size, object source);
    public bool SessionIdleTimeoutIsEnabled();
    [EventAttribute("3314")]
public void SessionIdleTimeout(string RemoteAddress, string AppDomain);
    [NonEventAttribute]
public void SessionIdleTimeout(string RemoteAddress);
    public bool ConnectionPoolMissIsEnabled();
    [EventAttribute("3321")]
public void ConnectionPoolMiss(string PoolKey, int busy, string AppDomain);
    [NonEventAttribute]
public void ConnectionPoolMiss(string PoolKey, int busy);
    public bool DispatchFormatterDeserializeRequestStartIsEnabled();
    [EventAttribute("3322")]
public void DispatchFormatterDeserializeRequestStart(string AppDomain);
    [NonEventAttribute]
public void DispatchFormatterDeserializeRequestStart(EventTraceActivity eventTraceActivity);
    public bool DispatchFormatterDeserializeRequestStopIsEnabled();
    [EventAttribute("3323")]
public void DispatchFormatterDeserializeRequestStop(string AppDomain);
    [NonEventAttribute]
public void DispatchFormatterDeserializeRequestStop(EventTraceActivity eventTraceActivity);
    public bool DispatchFormatterSerializeReplyStartIsEnabled();
    [EventAttribute("3324")]
public void DispatchFormatterSerializeReplyStart(string AppDomain);
    [NonEventAttribute]
public void DispatchFormatterSerializeReplyStart(EventTraceActivity eventTraceActivity);
    public bool DispatchFormatterSerializeReplyStopIsEnabled();
    [EventAttribute("3325")]
public void DispatchFormatterSerializeReplyStop(string AppDomain);
    [NonEventAttribute]
public void DispatchFormatterSerializeReplyStop(EventTraceActivity eventTraceActivity);
    public bool ClientFormatterSerializeRequestStartIsEnabled();
    [EventAttribute("3326")]
public void ClientFormatterSerializeRequestStart(string AppDomain);
    [NonEventAttribute]
public void ClientFormatterSerializeRequestStart(EventTraceActivity eventTraceActivity);
    public bool ClientFormatterSerializeRequestStopIsEnabled();
    [EventAttribute("3327")]
public void ClientFormatterSerializeRequestStop(string AppDomain);
    [NonEventAttribute]
public void ClientFormatterSerializeRequestStop(EventTraceActivity eventTraceActivity);
    public bool ClientFormatterDeserializeReplyStartIsEnabled();
    [EventAttribute("3328")]
public void ClientFormatterDeserializeReplyStart(string AppDomain);
    [NonEventAttribute]
public void ClientFormatterDeserializeReplyStart(EventTraceActivity eventTraceActivity);
    public bool ClientFormatterDeserializeReplyStopIsEnabled();
    [EventAttribute("3329")]
public void ClientFormatterDeserializeReplyStop(string AppDomain);
    [NonEventAttribute]
public void ClientFormatterDeserializeReplyStop(EventTraceActivity eventTraceActivity);
    public bool GetServiceInstanceStartIsEnabled();
    [EventAttribute("3335")]
public void GetServiceInstanceStart(string AppDomain);
    [NonEventAttribute]
public void GetServiceInstanceStart(EventTraceActivity eventTraceActivity);
    public bool GetServiceInstanceStopIsEnabled();
    [EventAttribute("3336")]
public void GetServiceInstanceStop(string AppDomain);
    [NonEventAttribute]
public void GetServiceInstanceStop(EventTraceActivity eventTraceActivity);
    public bool ChannelReceiveStartIsEnabled();
    [EventAttribute("3337")]
public void ChannelReceiveStart(int ChannelId, string AppDomain);
    [NonEventAttribute]
public void ChannelReceiveStart(EventTraceActivity eventTraceActivity, int ChannelId);
    public bool ChannelReceiveStopIsEnabled();
    [EventAttribute("3338")]
public void ChannelReceiveStop(int ChannelId, string AppDomain);
    [NonEventAttribute]
public void ChannelReceiveStop(EventTraceActivity eventTraceActivity, int ChannelId);
    public bool ChannelFactoryCreatedIsEnabled();
    [EventAttribute("3339")]
public void ChannelFactoryCreated(string EventSource, string AppDomain);
    [NonEventAttribute]
public void ChannelFactoryCreated(object source);
    public bool ListenerOpenStartIsEnabled();
    [EventAttribute("3349")]
public void ListenerOpenStart(string Uri, string AppDomain);
    [NonEventAttribute]
public void ListenerOpenStart(EventTraceActivity eventTraceActivity, string Uri, Guid relatedActivityId);
    public bool ListenerOpenStopIsEnabled();
    [EventAttribute("3350")]
public void ListenerOpenStop(string AppDomain);
    [NonEventAttribute]
public void ListenerOpenStop(EventTraceActivity eventTraceActivity);
    public bool SecurityIdentityVerificationFailureIsEnabled();
    [EventAttribute("3357")]
public void SecurityIdentityVerificationFailure(string AppDomain);
    [NonEventAttribute]
public void SecurityIdentityVerificationFailure(EventTraceActivity eventTraceActivity);
    public bool SslOnInitiateUpgradeIsEnabled();
    [EventAttribute("3368")]
public void SslOnInitiateUpgrade(string AppDomain);
    [NonEventAttribute]
public void SslOnInitiateUpgrade();
    public bool SslOnAcceptUpgradeIsEnabled();
    [EventAttribute("3369")]
public void SslOnAcceptUpgrade(string AppDomain);
    [NonEventAttribute]
public void SslOnAcceptUpgrade(EventTraceActivity eventTraceActivity);
    public bool BinaryMessageEncodingStartIsEnabled();
    [EventAttribute("3370")]
public void BinaryMessageEncodingStart(string AppDomain);
    [NonEventAttribute]
public void BinaryMessageEncodingStart(EventTraceActivity eventTraceActivity);
    public bool TextMessageEncodingStartIsEnabled();
    [EventAttribute("3372")]
public void TextMessageEncodingStart(string AppDomain);
    [NonEventAttribute]
public void TextMessageEncodingStart(EventTraceActivity eventTraceActivity);
    public bool BinaryMessageDecodingStartIsEnabled();
    [EventAttribute("3373")]
public void BinaryMessageDecodingStart(string AppDomain);
    [NonEventAttribute]
public void BinaryMessageDecodingStart();
    public bool TextMessageDecodingStartIsEnabled();
    [EventAttribute("3375")]
public void TextMessageDecodingStart(string AppDomain);
    [NonEventAttribute]
public void TextMessageDecodingStart();
    public bool SocketReadStopIsEnabled();
    [EventAttribute("3377")]
public void SocketReadStop(int SocketId, int Size, string Endpoint, string AppDomain);
    [NonEventAttribute]
public void SocketReadStop(int SocketId, int Size, string Endpoint);
    public bool SocketAsyncReadStopIsEnabled();
    [EventAttribute("3378")]
public void SocketAsyncReadStop(int SocketId, int Size, string Endpoint, string AppDomain);
    [NonEventAttribute]
public void SocketAsyncReadStop(int SocketId, int Size, string Endpoint);
    public bool SocketWriteStartIsEnabled();
    [EventAttribute("3379")]
public void SocketWriteStart(int SocketId, int Size, string Endpoint, string AppDomain);
    [NonEventAttribute]
public void SocketWriteStart(int SocketId, int Size, string Endpoint);
    public bool SocketAsyncWriteStartIsEnabled();
    [EventAttribute("3380")]
public void SocketAsyncWriteStart(int SocketId, int Size, string Endpoint, string AppDomain);
    [NonEventAttribute]
public void SocketAsyncWriteStart(int SocketId, int Size, string Endpoint);
    public bool WindowsStreamSecurityOnInitiateUpgradeIsEnabled();
    [EventAttribute("3384")]
public void WindowsStreamSecurityOnInitiateUpgrade(string AppDomain);
    [NonEventAttribute]
public void WindowsStreamSecurityOnInitiateUpgrade();
    public bool WindowsStreamSecurityOnAcceptUpgradeIsEnabled();
    [EventAttribute("3385")]
public void WindowsStreamSecurityOnAcceptUpgrade(string AppDomain);
    [NonEventAttribute]
public void WindowsStreamSecurityOnAcceptUpgrade(EventTraceActivity eventTraceActivity);
    public bool StreamedMessageReadByEncoderIsEnabled();
    [EventAttribute("3393")]
public void StreamedMessageReadByEncoder(string AppDomain);
    [NonEventAttribute]
public void StreamedMessageReadByEncoder(EventTraceActivity eventTraceActivity);
    public bool StreamedMessageWrittenByEncoderIsEnabled();
    [EventAttribute("3394")]
public void StreamedMessageWrittenByEncoder(string AppDomain);
    [NonEventAttribute]
public void StreamedMessageWrittenByEncoder(EventTraceActivity eventTraceActivity);
    public bool WebSocketConnectionRequestSendStartIsEnabled();
    [EventAttribute("3415")]
public void WebSocketConnectionRequestSendStart(string remoteAddress, string AppDomain);
    [NonEventAttribute]
public void WebSocketConnectionRequestSendStart(EventTraceActivity eventTraceActivity, string remoteAddress);
    public bool WebSocketConnectionRequestSendStopIsEnabled();
    [EventAttribute("3416")]
public void WebSocketConnectionRequestSendStop(int websocketId, string AppDomain);
    [NonEventAttribute]
public void WebSocketConnectionRequestSendStop(EventTraceActivity eventTraceActivity, int websocketId);
    public bool WebSocketConnectionFailedIsEnabled();
    [EventAttribute("3420")]
public void WebSocketConnectionFailed(string errorMessage, string AppDomain);
    [NonEventAttribute]
public void WebSocketConnectionFailed(EventTraceActivity eventTraceActivity, string errorMessage);
    public bool WebSocketConnectionAbortedIsEnabled();
    [EventAttribute("3421")]
public void WebSocketConnectionAborted(int websocketId, string AppDomain);
    [NonEventAttribute]
public void WebSocketConnectionAborted(EventTraceActivity eventTraceActivity, int websocketId);
    public bool WebSocketAsyncWriteStartIsEnabled();
    [EventAttribute("3422")]
public void WebSocketAsyncWriteStart(int websocketId, int byteCount, string remoteAddress, string AppDomain);
    [NonEventAttribute]
public void WebSocketAsyncWriteStart(int websocketId, int byteCount, string remoteAddress);
    public bool WebSocketAsyncWriteStopIsEnabled();
    [EventAttribute("3423")]
public void WebSocketAsyncWriteStop(int websocketId, string AppDomain);
    [NonEventAttribute]
public void WebSocketAsyncWriteStop(int websocketId);
    public bool WebSocketAsyncReadStartIsEnabled();
    [EventAttribute("3424")]
public void WebSocketAsyncReadStart(int websocketId, string AppDomain);
    [NonEventAttribute]
public void WebSocketAsyncReadStart(int websocketId);
    public bool WebSocketAsyncReadStopIsEnabled();
    [EventAttribute("3425")]
public void WebSocketAsyncReadStop(int websocketId, int byteCount, string remoteAddress, string AppDomain);
    [NonEventAttribute]
public void WebSocketAsyncReadStop(int websocketId, int byteCount, string remoteAddress);
    public bool WebSocketCloseSentIsEnabled();
    [EventAttribute("3426")]
public void WebSocketCloseSent(int websocketId, string remoteAddress, string closeStatus, string AppDomain);
    [NonEventAttribute]
public void WebSocketCloseSent(int websocketId, string remoteAddress, string closeStatus);
    public bool WebSocketCloseOutputSentIsEnabled();
    [EventAttribute("3427")]
public void WebSocketCloseOutputSent(int websocketId, string remoteAddress, string closeStatus, string AppDomain);
    [NonEventAttribute]
public void WebSocketCloseOutputSent(int websocketId, string remoteAddress, string closeStatus);
    public bool WebSocketConnectionClosedIsEnabled();
    [EventAttribute("3428")]
public void WebSocketConnectionClosed(int websocketId, string AppDomain);
    [NonEventAttribute]
public void WebSocketConnectionClosed(int websocketId);
    public bool WebSocketCloseStatusReceivedIsEnabled();
    [EventAttribute("3429")]
public void WebSocketCloseStatusReceived(int websocketId, string closeStatus, string AppDomain);
    [NonEventAttribute]
public void WebSocketCloseStatusReceived(int websocketId, string closeStatus);
    public bool WebSocketCreateClientWebSocketWithFactoryIsEnabled();
    [EventAttribute("3431")]
public void WebSocketCreateClientWebSocketWithFactory(string clientWebSocketFactoryType, string AppDomain);
    [NonEventAttribute]
public void WebSocketCreateClientWebSocketWithFactory(EventTraceActivity eventTraceActivity, string clientWebSocketFactoryType);
    public bool TokenValidationStartedIsEnabled();
    [EventAttribute("5402")]
public void TokenValidationStarted(string tokenType, string tokenID, string HostReference, string AppDomain);
    [NonEventAttribute]
public void TokenValidationStarted(EventTraceActivity eventTraceActivity, string tokenType, string tokenID);
    public bool TokenValidationSuccessIsEnabled();
    [EventAttribute("5403")]
public void TokenValidationSuccess(string tokenType, string tokenID, string HostReference, string AppDomain);
    [NonEventAttribute]
public void TokenValidationSuccess(EventTraceActivity eventTraceActivity, string tokenType, string tokenID);
    public bool TokenValidationFailureIsEnabled();
    [EventAttribute("5404")]
public void TokenValidationFailure(string tokenType, string tokenID, string errorMessage, string HostReference, string AppDomain);
    [NonEventAttribute]
public void TokenValidationFailure(EventTraceActivity eventTraceActivity, string tokenType, string tokenID, string errorMessage);
    public bool HandledExceptionIsEnabled();
    [EventAttribute("57394")]
public void HandledException(string data1, string SerializedException, string AppDomain);
    [NonEventAttribute]
public void HandledException(string data1, string SerializedException);
    public bool ShipAssertExceptionMessageIsEnabled();
    [EventAttribute("57395")]
public void ShipAssertExceptionMessage(string data1, string AppDomain);
    [NonEventAttribute]
public void ShipAssertExceptionMessage(string data1);
    public bool ThrowingExceptionIsEnabled();
    [EventAttribute("57396")]
public void ThrowingException(string data1, string data2, string SerializedException, string AppDomain);
    [NonEventAttribute]
public void ThrowingException(string data1, string data2, string SerializedException);
    public bool UnhandledExceptionIsEnabled();
    [EventAttribute("57397")]
public void UnhandledException(string data1, string SerializedException, string AppDomain);
    [NonEventAttribute]
public void UnhandledException(string data1, string SerializedException);
    public bool TraceCodeEventLogCriticalIsEnabled();
    [EventAttribute("57399")]
public void TraceCodeEventLogCritical(string ExtendedData, string AppDomain);
    [NonEventAttribute]
public void TraceCodeEventLogCritical(string ExtendedData);
    public bool TraceCodeEventLogErrorIsEnabled();
    [EventAttribute("57400")]
public void TraceCodeEventLogError(string ExtendedData, string AppDomain);
    [NonEventAttribute]
public void TraceCodeEventLogError(string ExtendedData);
    public bool TraceCodeEventLogInfoIsEnabled();
    [EventAttribute("57401")]
public void TraceCodeEventLogInfo(string ExtendedData, string AppDomain);
    [NonEventAttribute]
public void TraceCodeEventLogInfo(string ExtendedData);
    public bool TraceCodeEventLogVerboseIsEnabled();
    [EventAttribute("57402")]
public void TraceCodeEventLogVerbose(string ExtendedData, string AppDomain);
    [NonEventAttribute]
public void TraceCodeEventLogVerbose(string ExtendedData);
    public bool TraceCodeEventLogWarningIsEnabled();
    [EventAttribute("57403")]
public void TraceCodeEventLogWarning(string ExtendedData, string AppDomain);
    [NonEventAttribute]
public void TraceCodeEventLogWarning(string ExtendedData);
    public bool HandledExceptionWarningIsEnabled();
    [EventAttribute("57404")]
public void HandledExceptionWarning(string data1, string SerializedException, string AppDomain);
    [NonEventAttribute]
public void HandledExceptionWarning(string data1, string SerializedException);
    public bool HandledExceptionErrorIsEnabled();
    [EventAttribute("57405")]
public void HandledExceptionError(string data1, string SerializedException, string AppDomain);
    [NonEventAttribute]
public void HandledExceptionError(string data1, string SerializedException);
    public bool HandledExceptionVerboseIsEnabled();
    [EventAttribute("57406")]
public void HandledExceptionVerbose(string data1, string SerializedException, string AppDomain);
    [NonEventAttribute]
public void HandledExceptionVerbose(string data1, string SerializedException);
    public bool ThrowingExceptionVerboseIsEnabled();
    [EventAttribute("57407")]
public void ThrowingExceptionVerbose(string data1, string data2, string SerializedException, string AppDomain);
    [NonEventAttribute]
public void ThrowingExceptionVerbose(string data1, string data2, string SerializedException);
    public bool EtwUnhandledExceptionIsEnabled();
    [EventAttribute("57408")]
public void EtwUnhandledException(string data1, string SerializedException, string AppDomain);
    [NonEventAttribute]
public void EtwUnhandledException(string data1, string SerializedException);
    public bool ThrowingEtwExceptionVerboseIsEnabled();
    [EventAttribute("57409")]
public void ThrowingEtwExceptionVerbose(string data1, string data2, string SerializedException, string AppDomain);
    [NonEventAttribute]
public void ThrowingEtwExceptionVerbose(string data1, string data2, string SerializedException);
    public bool ThrowingEtwExceptionIsEnabled();
    [EventAttribute("57410")]
public void ThrowingEtwException(string data1, string data2, string SerializedException, string AppDomain);
    [NonEventAttribute]
public void ThrowingEtwException(string data1, string data2, string SerializedException);
    [NonEventAttribute]
private void SetActivityId(EventTraceActivity eventTraceActivity);
    [NonEventAttribute]
private void TransferActivityId(EventTraceActivity eventTraceActivity);
}
internal class System.ServiceModel.ActionMismatchAddressingException : ProtocolException {
    private string _httpActionHeader;
    private string _soapActionHeader;
    public string HttpActionHeader { get; }
    public string SoapActionHeader { get; }
    public ActionMismatchAddressingException(string message, string soapActionHeader, string httpActionHeader);
    protected ActionMismatchAddressingException(SerializationInfo info, StreamingContext context);
    public string get_HttpActionHeader();
    public string get_SoapActionHeader();
    internal Message ProvideFault(MessageVersion messageVersion);
}
public class System.ServiceModel.ActionNotSupportedException : CommunicationException {
    public ActionNotSupportedException(string message);
    public ActionNotSupportedException(string message, Exception innerException);
    protected ActionNotSupportedException(SerializationInfo info, StreamingContext context);
    internal Message ProvideFault(MessageVersion messageVersion);
}
internal class System.ServiceModel.ActivityIdFlowDictionary : object {
    public XmlDictionaryString ActivityId;
    public XmlDictionaryString ActivityIdNamespace;
    public ActivityIdFlowDictionary(ServiceModelDictionary dictionary);
}
internal static class System.ServiceModel.ActivityIdFlowStrings : object {
    public static string ActivityId;
    public static string ActivityIdNamespace;
}
internal class System.ServiceModel.Addressing10Dictionary : object {
    public XmlDictionaryString Namespace;
    public XmlDictionaryString Anonymous;
    public XmlDictionaryString FaultAction;
    public XmlDictionaryString ReplyRelationship;
    public XmlDictionaryString NoneAddress;
    public XmlDictionaryString Metadata;
    public Addressing10Dictionary(ServiceModelDictionary dictionary);
}
internal static class System.ServiceModel.Addressing10Strings : object {
    public static string Namespace;
    public static string Anonymous;
    public static string FaultAction;
    public static string ReplyRelationship;
    public static string NoneAddress;
    public static string Metadata;
    public static string MessageAddressingHeaderRequired;
    public static string InvalidAddressingHeader;
    public static string InvalidCardinality;
    public static string ActionMismatch;
    public static string ProblemHeaderQName;
    public static string FaultDetail;
    public static string DefaultFaultAction;
}
internal static class System.ServiceModel.Addressing200408Strings : object {
    public static string Namespace;
    public static string Anonymous;
    public static string FaultAction;
    public static string InvalidMessageInformationHeader;
    public static string MessageInformationHeaderRequired;
    public static string DefaultFaultAction;
}
internal class System.ServiceModel.AddressingDictionary : object {
    public XmlDictionaryString Action;
    public XmlDictionaryString To;
    public XmlDictionaryString RelatesTo;
    public XmlDictionaryString MessageId;
    public XmlDictionaryString Address;
    public XmlDictionaryString ReplyTo;
    public XmlDictionaryString Empty;
    public XmlDictionaryString From;
    public XmlDictionaryString FaultTo;
    public XmlDictionaryString EndpointReference;
    public XmlDictionaryString PortType;
    public XmlDictionaryString ServiceName;
    public XmlDictionaryString PortName;
    public XmlDictionaryString ReferenceProperties;
    public XmlDictionaryString RelationshipType;
    public XmlDictionaryString Reply;
    public XmlDictionaryString Prefix;
    public XmlDictionaryString IdentityExtensionNamespace;
    public XmlDictionaryString Identity;
    public XmlDictionaryString Spn;
    public XmlDictionaryString Upn;
    public XmlDictionaryString Rsa;
    public XmlDictionaryString Dns;
    public XmlDictionaryString X509v3Certificate;
    public XmlDictionaryString ReferenceParameters;
    public XmlDictionaryString IsReferenceParameter;
    public AddressingDictionary(ServiceModelDictionary dictionary);
}
internal class System.ServiceModel.AddressingNoneDictionary : object {
    public XmlDictionaryString Namespace;
    public AddressingNoneDictionary(ServiceModelDictionary dictionary);
}
internal static class System.ServiceModel.AddressingNoneStrings : object {
    public static string Namespace;
}
internal static class System.ServiceModel.AddressingStrings : object {
    public static string Action;
    public static string To;
    public static string RelatesTo;
    public static string MessageId;
    public static string Address;
    public static string ReplyTo;
    public static string Empty;
    public static string From;
    public static string FaultTo;
    public static string EndpointReference;
    public static string PortType;
    public static string ServiceName;
    public static string PortName;
    public static string ReferenceProperties;
    public static string RelationshipType;
    public static string Reply;
    public static string Prefix;
    public static string IdentityExtensionNamespace;
    public static string Identity;
    public static string Spn;
    public static string Upn;
    public static string Rsa;
    public static string Dns;
    public static string X509v3Certificate;
    public static string ReferenceParameters;
    public static string IsReferenceParameter;
    public static string EndpointUnavailable;
    public static string ActionNotSupported;
    public static string EndpointReferenceType;
    public static string Request;
    public static string DestinationUnreachable;
    public static string AnonymousUri;
    public static string NoneUri;
    public static string IndigoNamespace;
    public static string ChannelTerminated;
}
internal static class System.ServiceModel.AtomicTransactionExternal10Strings : object {
    public static string Namespace;
    public static string CompletionUri;
    public static string Durable2PCUri;
    public static string Volatile2PCUri;
    public static string CommitAction;
    public static string RollbackAction;
    public static string CommittedAction;
    public static string AbortedAction;
    public static string PrepareAction;
    public static string PreparedAction;
    public static string ReadOnlyAction;
    public static string ReplayAction;
    public static string FaultAction;
}
internal class System.ServiceModel.AtomicTransactionExternal11Dictionary : object {
    public XmlDictionaryString Namespace;
    public XmlDictionaryString CompletionUri;
    public XmlDictionaryString Durable2PCUri;
    public XmlDictionaryString Volatile2PCUri;
    public XmlDictionaryString CommitAction;
    public XmlDictionaryString RollbackAction;
    public XmlDictionaryString CommittedAction;
    public XmlDictionaryString AbortedAction;
    public XmlDictionaryString PrepareAction;
    public XmlDictionaryString PreparedAction;
    public XmlDictionaryString ReadOnlyAction;
    public XmlDictionaryString ReplayAction;
    public XmlDictionaryString FaultAction;
    public XmlDictionaryString UnknownTransaction;
    public AtomicTransactionExternal11Dictionary(XmlDictionary dictionary);
}
internal static class System.ServiceModel.AtomicTransactionExternal11Strings : object {
    public static string Namespace;
    public static string CompletionUri;
    public static string Durable2PCUri;
    public static string Volatile2PCUri;
    public static string CommitAction;
    public static string RollbackAction;
    public static string CommittedAction;
    public static string AbortedAction;
    public static string PrepareAction;
    public static string PreparedAction;
    public static string ReadOnlyAction;
    public static string ReplayAction;
    public static string FaultAction;
    public static string UnknownTransaction;
}
internal static class System.ServiceModel.AtomicTransactionExternalStrings : object {
    public static string Prefix;
    public static string Prepare;
    public static string Prepared;
    public static string ReadOnly;
    public static string Commit;
    public static string Rollback;
    public static string Committed;
    public static string Aborted;
    public static string Replay;
    public static string CompletionCoordinatorPortType;
    public static string CompletionParticipantPortType;
    public static string CoordinatorPortType;
    public static string ParticipantPortType;
    public static string InconsistentInternalState;
}
public enum System.ServiceModel.AuditLevel : Enum {
    public int value__;
    public static AuditLevel None;
    public static AuditLevel Success;
    public static AuditLevel Failure;
    public static AuditLevel SuccessOrFailure;
}
internal static class System.ServiceModel.AuditLevelHelper : object {
    public static bool IsDefined(AuditLevel auditLevel);
    public static void Validate(AuditLevel value);
}
public enum System.ServiceModel.AuditLogLocation : Enum {
    public int value__;
    public static AuditLogLocation Default;
    public static AuditLogLocation Application;
    public static AuditLogLocation Security;
}
internal static class System.ServiceModel.AuditLogLocationHelper : object {
    public static bool IsDefined(AuditLogLocation auditLogLocation);
    public static void Validate(AuditLogLocation value);
}
public class System.ServiceModel.BasicHttpBinding : HttpBindingBase {
    private WSMessageEncoding _messageEncoding;
    private BasicHttpSecurity _basicHttpSecurity;
    internal WSMessageEncoding MessageEncoding { get; internal set; }
    public BasicHttpSecurity Security { get; public set; }
    internal BasicHttpSecurity BasicHttpSecurity { get; }
    public BasicHttpBinding(BasicHttpSecurityMode securityMode);
    internal WSMessageEncoding get_MessageEncoding();
    internal void set_MessageEncoding(WSMessageEncoding value);
    public BasicHttpSecurity get_Security();
    public void set_Security(BasicHttpSecurity value);
    internal virtual BasicHttpSecurity get_BasicHttpSecurity();
    internal virtual EnvelopeVersion GetEnvelopeVersion();
    public virtual IChannelFactory`1<TChannel> BuildChannelFactory(BindingParameterCollection parameters);
    public virtual BindingElementCollection CreateBindingElements();
    private void Initialize();
}
public enum System.ServiceModel.BasicHttpMessageCredentialType : Enum {
    public int value__;
    public static BasicHttpMessageCredentialType UserName;
    public static BasicHttpMessageCredentialType Certificate;
}
internal static class System.ServiceModel.BasicHttpMessageCredentialTypeHelper : object {
    internal static bool IsDefined(BasicHttpMessageCredentialType value);
}
public class System.ServiceModel.BasicHttpsBinding : HttpBindingBase {
    private WSMessageEncoding _messageEncoding;
    private BasicHttpsSecurity _basicHttpsSecurity;
    internal WSMessageEncoding MessageEncoding { get; internal set; }
    public BasicHttpsSecurity Security { get; public set; }
    internal BasicHttpSecurity BasicHttpSecurity { get; }
    public BasicHttpsBinding(BasicHttpsSecurityMode securityMode);
    internal WSMessageEncoding get_MessageEncoding();
    internal void set_MessageEncoding(WSMessageEncoding value);
    public BasicHttpsSecurity get_Security();
    public void set_Security(BasicHttpsSecurity value);
    internal virtual BasicHttpSecurity get_BasicHttpSecurity();
    internal virtual EnvelopeVersion GetEnvelopeVersion();
    public virtual IChannelFactory`1<TChannel> BuildChannelFactory(BindingParameterCollection parameters);
    public virtual BindingElementCollection CreateBindingElements();
}
public class System.ServiceModel.BasicHttpSecurity : object {
    internal static BasicHttpSecurityMode DefaultMode;
    private BasicHttpSecurityMode _mode;
    private HttpTransportSecurity _transportSecurity;
    public BasicHttpSecurityMode Mode { get; public set; }
    public HttpTransportSecurity Transport { get; public set; }
    private BasicHttpSecurity(BasicHttpSecurityMode mode, HttpTransportSecurity transportSecurity);
    public BasicHttpSecurityMode get_Mode();
    public void set_Mode(BasicHttpSecurityMode value);
    public HttpTransportSecurity get_Transport();
    public void set_Transport(HttpTransportSecurity value);
    internal void EnableTransportSecurity(HttpsTransportBindingElement https);
    internal static void EnableTransportSecurity(HttpsTransportBindingElement https, HttpTransportSecurity transportSecurity);
    internal void EnableTransportAuthentication(HttpTransportBindingElement http);
    internal static bool IsEnabledTransportAuthentication(HttpTransportBindingElement http, HttpTransportSecurity transportSecurity);
    internal void DisableTransportAuthentication(HttpTransportBindingElement http);
    internal SecurityBindingElement CreateMessageSecurity();
}
public enum System.ServiceModel.BasicHttpSecurityMode : Enum {
    public int value__;
    public static BasicHttpSecurityMode None;
    public static BasicHttpSecurityMode Transport;
    public static BasicHttpSecurityMode Message;
    public static BasicHttpSecurityMode TransportWithMessageCredential;
    public static BasicHttpSecurityMode TransportCredentialOnly;
}
internal static class System.ServiceModel.BasicHttpSecurityModeHelper : object {
    internal static bool IsDefined(BasicHttpSecurityMode value);
    internal static BasicHttpSecurityMode ToSecurityMode(UnifiedSecurityMode value);
}
public class System.ServiceModel.BasicHttpsSecurity : object {
    internal static BasicHttpsSecurityMode DefaultMode;
    private BasicHttpSecurity _basicHttpSecurity;
    public BasicHttpsSecurityMode Mode { get; public set; }
    public HttpTransportSecurity Transport { get; public set; }
    internal BasicHttpSecurity BasicHttpSecurity { get; }
    private BasicHttpsSecurity(BasicHttpsSecurityMode mode, HttpTransportSecurity transportSecurity);
    public BasicHttpsSecurityMode get_Mode();
    public void set_Mode(BasicHttpsSecurityMode value);
    public HttpTransportSecurity get_Transport();
    public void set_Transport(HttpTransportSecurity value);
    internal BasicHttpSecurity get_BasicHttpSecurity();
    internal static BasicHttpSecurity ToBasicHttpSecurity(BasicHttpsSecurity basicHttpsSecurity);
    internal static BasicHttpsSecurity ToBasicHttpsSecurity(BasicHttpSecurity basicHttpSecurity);
    internal static void EnableTransportSecurity(HttpsTransportBindingElement https, HttpTransportSecurity transportSecurity);
    internal static bool IsEnabledTransportAuthentication(HttpTransportBindingElement http, HttpTransportSecurity transportSecurity);
    internal void EnableTransportSecurity(HttpsTransportBindingElement https);
    internal void EnableTransportAuthentication(HttpTransportBindingElement http);
    internal void DisableTransportAuthentication(HttpTransportBindingElement http);
    internal SecurityBindingElement CreateMessageSecurity();
}
public enum System.ServiceModel.BasicHttpsSecurityMode : Enum {
    public int value__;
    public static BasicHttpsSecurityMode Transport;
    public static BasicHttpsSecurityMode TransportWithMessageCredential;
}
internal static class System.ServiceModel.BasicHttpsSecurityModeHelper : object {
    internal static bool IsDefined(BasicHttpsSecurityMode value);
    internal static BasicHttpsSecurityMode ToSecurityMode(UnifiedSecurityMode value);
    internal static BasicHttpsSecurityMode ToBasicHttpsSecurityMode(BasicHttpSecurityMode mode);
    internal static BasicHttpSecurityMode ToBasicHttpSecurityMode(BasicHttpsSecurityMode mode);
}
[AttributeUsageAttribute("4")]
public class System.ServiceModel.CallbackBehaviorAttribute : Attribute {
    private ConcurrencyMode _concurrencyMode;
    private bool _automaticSessionShutdown;
    private bool _useSynchronizationContext;
    public bool AutomaticSessionShutdown { get; public set; }
    public bool UseSynchronizationContext { get; public set; }
    public bool get_AutomaticSessionShutdown();
    public void set_AutomaticSessionShutdown(bool value);
    public bool get_UseSynchronizationContext();
    public void set_UseSynchronizationContext(bool value);
    private sealed virtual override void System.ServiceModel.Description.IEndpointBehavior.Validate(ServiceEndpoint serviceEndpoint);
    private sealed virtual override void System.ServiceModel.Description.IEndpointBehavior.AddBindingParameters(ServiceEndpoint serviceEndpoint, BindingParameterCollection parameters);
    private sealed virtual override void System.ServiceModel.Description.IEndpointBehavior.ApplyClientBehavior(ServiceEndpoint serviceEndpoint, ClientRuntime clientRuntime);
    private sealed virtual override void System.ServiceModel.Description.IEndpointBehavior.ApplyDispatchBehavior(ServiceEndpoint serviceEndpoint, EndpointDispatcher endpointDispatcher);
}
public abstract class System.ServiceModel.ChannelFactory : CommunicationObject {
    private string _configurationName;
    private IChannelFactory _innerFactory;
    private ServiceEndpoint _serviceEndpoint;
    private ClientCredentials _readOnlyClientCredentials;
    private object _openLock;
    [CompilerGeneratedAttribute]
private bool <UseActiveAutoClose>k__BackingField;
    public ClientCredentials Credentials { get; }
    protected TimeSpan DefaultCloseTimeout { get; }
    protected TimeSpan DefaultOpenTimeout { get; }
    public ServiceEndpoint Endpoint { get; }
    internal IChannelFactory InnerFactory { get; }
    internal bool UseActiveAutoClose { get; internal set; }
    public ClientCredentials get_Credentials();
    protected virtual TimeSpan get_DefaultCloseTimeout();
    protected virtual TimeSpan get_DefaultOpenTimeout();
    public ServiceEndpoint get_Endpoint();
    internal IChannelFactory get_InnerFactory();
    [CompilerGeneratedAttribute]
internal bool get_UseActiveAutoClose();
    [CompilerGeneratedAttribute]
internal void set_UseActiveAutoClose(bool value);
    protected internal void EnsureOpened();
    protected virtual void ApplyConfiguration(string configurationName);
    protected abstract virtual ServiceEndpoint CreateDescription();
    internal EndpointAddress CreateEndpointAddress(ServiceEndpoint endpoint);
    protected virtual IChannelFactory CreateFactory();
    private sealed virtual override void System.IDisposable.Dispose();
    private void EnsureSecurityCredentialsManager(ServiceEndpoint endpoint);
    private ClientCredentials EnsureCredentials(ServiceEndpoint endpoint);
    public sealed virtual T GetProperty();
    internal bool HasDuplexOperations();
    protected void InitializeEndpoint(string configurationName, EndpointAddress address);
    protected void InitializeEndpoint(ServiceEndpoint endpoint);
    protected void InitializeEndpoint(Binding binding, EndpointAddress address);
    protected virtual void OnOpened();
    protected virtual void OnAbort();
    protected virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndClose(IAsyncResult result);
    [AsyncStateMachineAttribute("System.ServiceModel.ChannelFactory/<OnCloseAsync>d__37")]
protected internal virtual Task OnCloseAsync(TimeSpan timeout);
    protected virtual IAsyncResult OnBeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndOpen(IAsyncResult result);
    [AsyncStateMachineAttribute("System.ServiceModel.ChannelFactory/<OnOpenAsync>d__40")]
protected internal virtual Task OnOpenAsync(TimeSpan timeout);
    protected virtual void OnClose(TimeSpan timeout);
    protected virtual void OnOpen(TimeSpan timeout);
    protected virtual void OnOpening();
}
public class System.ServiceModel.ChannelFactory`1 : ChannelFactory {
    private InstanceContext _callbackInstance;
    private Type _channelType;
    private TypeLoader _typeLoader;
    private Type _callbackType;
    internal InstanceContext CallbackInstance { get; internal set; }
    internal Type CallbackType { get; internal set; }
    internal ServiceChannelFactory ServiceChannelFactory { get; }
    internal TypeLoader TypeLoader { get; }
    protected ChannelFactory`1(Type channelType);
    public ChannelFactory`1(string endpointConfigurationName);
    public ChannelFactory`1(string endpointConfigurationName, EndpointAddress remoteAddress);
    public ChannelFactory`1(Binding binding);
    public ChannelFactory`1(Binding binding, string remoteAddress);
    public ChannelFactory`1(Binding binding, EndpointAddress remoteAddress);
    public ChannelFactory`1(ServiceEndpoint endpoint);
    internal InstanceContext get_CallbackInstance();
    internal void set_CallbackInstance(InstanceContext value);
    internal Type get_CallbackType();
    internal void set_CallbackType(Type value);
    internal ServiceChannelFactory get_ServiceChannelFactory();
    internal TypeLoader get_TypeLoader();
    public sealed virtual TChannel CreateChannel(EndpointAddress address);
    public virtual TChannel CreateChannel(EndpointAddress address, Uri via);
    public TChannel CreateChannel();
    protected virtual ServiceEndpoint CreateDescription();
    private void ReflectOnCallbackInstance(ServiceEndpoint endpoint);
    protected static TChannel CreateChannel(string endpointConfigurationName);
    public static TChannel CreateChannel(Binding binding, EndpointAddress endpointAddress);
    public static TChannel CreateChannel(Binding binding, EndpointAddress endpointAddress, Uri via);
    internal static void SetFactoryToAutoClose(TChannel channel);
}
internal class System.ServiceModel.Channels.ActionHeader : AddressingHeader {
    private string _action;
    private static bool mustUnderstandValue;
    public string Action { get; }
    public bool MustUnderstand { get; }
    public XmlDictionaryString DictionaryName { get; }
    private ActionHeader(string action, AddressingVersion version);
    public string get_Action();
    public virtual bool get_MustUnderstand();
    public virtual XmlDictionaryString get_DictionaryName();
    public static ActionHeader Create(string action, AddressingVersion addressingVersion);
    public static ActionHeader Create(XmlDictionaryString dictionaryAction, AddressingVersion addressingVersion);
    protected virtual void OnWriteHeaderContents(XmlDictionaryWriter writer, MessageVersion messageVersion);
    public static string ReadHeaderValue(XmlDictionaryReader reader, AddressingVersion addressingVersion);
    public static ActionHeader ReadHeader(XmlDictionaryReader reader, AddressingVersion version, string actor, bool mustUnderstand, bool relay);
}
public abstract class System.ServiceModel.Channels.AddressHeader : object {
    private ParameterHeader _header;
    internal bool IsReferenceProperty { get; }
    public string Name { get; }
    public string Namespace { get; }
    internal bool get_IsReferenceProperty();
    public abstract virtual string get_Name();
    public abstract virtual string get_Namespace();
    public static AddressHeader CreateAddressHeader(object value);
    public static AddressHeader CreateAddressHeader(object value, XmlObjectSerializer serializer);
    public static AddressHeader CreateAddressHeader(string name, string ns, object value);
    internal static AddressHeader CreateAddressHeader(XmlDictionaryString name, XmlDictionaryString ns, object value);
    public static AddressHeader CreateAddressHeader(string name, string ns, object value, XmlObjectSerializer serializer);
    private static Type GetObjectType(object value);
    public virtual bool Equals(object obj);
    internal string GetComparableForm();
    internal string GetComparableForm(StringBuilder builder);
    public virtual int GetHashCode();
    public T GetValue();
    public T GetValue(XmlObjectSerializer serializer);
    public virtual XmlDictionaryReader GetAddressHeaderReader();
    private XmlDictionaryReader GetComparableReader();
    protected virtual void OnWriteStartAddressHeader(XmlDictionaryWriter writer);
    protected abstract virtual void OnWriteAddressHeaderContents(XmlDictionaryWriter writer);
    public MessageHeader ToMessageHeader();
    public void WriteAddressHeader(XmlWriter writer);
    public void WriteAddressHeader(XmlDictionaryWriter writer);
    public void WriteStartAddressHeader(XmlDictionaryWriter writer);
    public void WriteAddressHeaderContents(XmlDictionaryWriter writer);
}
public class System.ServiceModel.Channels.AddressHeaderCollection : ReadOnlyCollection`1<AddressHeader> {
    private static AddressHeaderCollection s_emptyHeaderCollection;
    internal static AddressHeaderCollection EmptyHeaderCollection { get; }
    private int InternalCount { get; }
    internal bool HasReferenceProperties { get; }
    internal bool HasNonReferenceProperties { get; }
    public AddressHeaderCollection(IEnumerable`1<AddressHeader> addressHeaders);
    private static AddressHeaderCollection();
    internal static AddressHeaderCollection get_EmptyHeaderCollection();
    private int get_InternalCount();
    public void AddHeadersTo(Message message);
    public AddressHeader[] FindAll(string name, string ns);
    public AddressHeader FindHeader(string name, string ns);
    internal bool IsEquivalent(AddressHeaderCollection col);
    internal void PopulateHeaderDictionary(StringBuilder builder, Dictionary`2<string, int> headers);
    internal static AddressHeaderCollection ReadServiceParameters(XmlDictionaryReader reader);
    internal static AddressHeaderCollection ReadServiceParameters(XmlDictionaryReader reader, bool isReferenceProperty);
    internal bool get_HasReferenceProperties();
    internal bool get_HasNonReferenceProperties();
    internal void WriteReferencePropertyContentsTo(XmlDictionaryWriter writer);
    internal void WriteNonReferencePropertyContentsTo(XmlDictionaryWriter writer);
    internal void WriteContentsTo(XmlDictionaryWriter writer);
}
internal abstract class System.ServiceModel.Channels.AddressingHeader : DictionaryHeader {
    private AddressingVersion _version;
    internal AddressingVersion Version { get; }
    private XmlDictionaryString System.ServiceModel.Channels.IMessageHeaderWithSharedNamespace.SharedPrefix { get; }
    private XmlDictionaryString System.ServiceModel.Channels.IMessageHeaderWithSharedNamespace.SharedNamespace { get; }
    public XmlDictionaryString DictionaryNamespace { get; }
    protected AddressingHeader(AddressingVersion version);
    internal AddressingVersion get_Version();
    private sealed virtual override XmlDictionaryString System.ServiceModel.Channels.IMessageHeaderWithSharedNamespace.get_SharedPrefix();
    private sealed virtual override XmlDictionaryString System.ServiceModel.Channels.IMessageHeaderWithSharedNamespace.get_SharedNamespace();
    public virtual XmlDictionaryString get_DictionaryNamespace();
}
public class System.ServiceModel.Channels.AddressingVersion : object {
    private string _ns;
    private XmlDictionaryString _dictionaryNs;
    private MessagePartSpecification _signedMessageParts;
    private string _toStringFormat;
    private string _anonymous;
    private XmlDictionaryString _dictionaryAnonymous;
    private Uri _anonymousUri;
    private Uri _noneUri;
    private string _faultAction;
    private string _defaultFaultAction;
    private static string AddressingNoneToStringFormat;
    private static string Addressing10ToStringFormat;
    private static AddressingVersion s_none;
    private static AddressingVersion s_addressing10;
    private static MessagePartSpecification s_addressing10SignedMessageParts;
    public static AddressingVersion WSAddressing10 { get; }
    public static AddressingVersion None { get; }
    internal string Namespace { get; }
    private static MessagePartSpecification Addressing10SignedMessageParts { get; }
    internal XmlDictionaryString DictionaryNamespace { get; }
    internal string Anonymous { get; }
    internal XmlDictionaryString DictionaryAnonymous { get; }
    internal Uri AnonymousUri { get; }
    internal Uri NoneUri { get; }
    internal string FaultAction { get; }
    internal string DefaultFaultAction { get; }
    internal MessagePartSpecification SignedMessageParts { get; }
    private AddressingVersion(string ns, XmlDictionaryString dictionaryNs, string toStringFormat, MessagePartSpecification signedMessageParts, string anonymous, XmlDictionaryString dictionaryAnonymous, string none, string faultAction, string defaultFaultAction);
    private static AddressingVersion();
    public static AddressingVersion get_WSAddressing10();
    public static AddressingVersion get_None();
    internal string get_Namespace();
    private static MessagePartSpecification get_Addressing10SignedMessageParts();
    internal XmlDictionaryString get_DictionaryNamespace();
    internal string get_Anonymous();
    internal XmlDictionaryString get_DictionaryAnonymous();
    internal Uri get_AnonymousUri();
    internal Uri get_NoneUri();
    internal string get_FaultAction();
    internal string get_DefaultFaultAction();
    internal MessagePartSpecification get_SignedMessageParts();
    public virtual string ToString();
}
public class System.ServiceModel.Channels.ApplicationContainerSettings : object {
    public static int CurrentSession;
    public static int ServiceSession;
    private static string GroupNameSuffixFormat;
    private int _sessionId;
    [CompilerGeneratedAttribute]
private string <PackageFullName>k__BackingField;
    public string PackageFullName { get; public set; }
    public int SessionId { get; public set; }
    internal bool TargetingAppContainer { get; }
    private ApplicationContainerSettings(ApplicationContainerSettings source);
    [CompilerGeneratedAttribute]
public string get_PackageFullName();
    [CompilerGeneratedAttribute]
public void set_PackageFullName(string value);
    public int get_SessionId();
    public void set_SessionId(int value);
    internal bool get_TargetingAppContainer();
    internal ApplicationContainerSettings Clone();
    internal bool IsMatch(ApplicationContainerSettings applicationContainerSettings);
}
public static class System.ServiceModel.Channels.ApplicationContainerSettingsDefaults : object {
    public static string CurrentUserSessionDefaultString;
    public static string Session0ServiceSessionString;
    public static string PackageFullNameDefaultString;
    public static int CurrentSession;
    public static int ServiceSession;
}
internal static class System.ServiceModel.Channels.AuthenticationLevelHelper : object {
    internal static string ToString(AuthenticationLevel authenticationLevel);
}
[ExtensionAttribute]
internal static class System.ServiceModel.Channels.AuthenticationSchemesHelper : object {
    [ExtensionAttribute]
public static bool IsSingleton(AuthenticationSchemes v);
    [ExtensionAttribute]
public static bool IsSet(AuthenticationSchemes thisPtr, AuthenticationSchemes authenticationSchemes);
    [ExtensionAttribute]
public static bool IsNotSet(AuthenticationSchemes thisPtr, AuthenticationSchemes authenticationSchemes);
    internal static string ToString(AuthenticationSchemes authScheme);
}
public static class System.ServiceModel.Channels.BasicHttpBindingDefaults : object {
    public static BasicHttpMessageCredentialType MessageSecurityClientCredentialType;
    public static WSMessageEncoding MessageEncoding;
    public static TransferMode TransferMode;
    public static Encoding TextEncoding { get; }
    public static Encoding get_TextEncoding();
}
public static class System.ServiceModel.Channels.BinaryEncoderDefaults : object {
    public static int MaxSessionSize;
    public static EnvelopeVersion EnvelopeVersion { get; }
    public static BinaryVersion BinaryVersion { get; }
    public static EnvelopeVersion get_EnvelopeVersion();
    public static BinaryVersion get_BinaryVersion();
}
internal class System.ServiceModel.Channels.BinaryFormatBuilder : object {
    private List`1<byte> _bytes;
    public int Count { get; }
    public int get_Count();
    public void AppendPrefixDictionaryElement(char prefix, int key);
    public void AppendDictionaryXmlnsAttribute(char prefix, int key);
    public void AppendPrefixDictionaryAttribute(char prefix, int key, char value);
    public void AppendDictionaryAttribute(char prefix, int key, char value);
    public void AppendDictionaryTextWithEndElement(int key);
    public void AppendDictionaryTextWithEndElement();
    public void AppendUniqueIDWithEndElement();
    public void AppendEndElement();
    private void AppendKey(int key);
    private void AppendNode(XmlBinaryNodeType value);
    private void AppendByte(int value);
    private void AppendUtf8(char value);
    public int GetStaticKey(int value);
    public int GetSessionKey(int value);
    private int GetPrefixOffset(char prefix);
    public Byte[] ToByteArray();
}
internal static class System.ServiceModel.Channels.BinaryFormatParser : object {
    public static bool IsSessionKey(int value);
    public static int GetSessionKey(int value);
    public static int GetStaticKey(int value);
    public static int ParseInt32(Byte[] buffer, int offset, int size);
    public static int ParseKey(Byte[] buffer, int offset, int size);
    public static UniqueId ParseUniqueID(Byte[] buffer, int offset, int size);
    public static int MatchBytes(Byte[] buffer, int offset, int size, Byte[] buffer2);
    public static bool MatchAttributeNode(Byte[] buffer, int offset, int size);
    public static int MatchKey(Byte[] buffer, int offset, int size);
    public static int MatchInt32(Byte[] buffer, int offset, int size);
    public static int MatchUniqueID(Byte[] buffer, int offset, int size);
}
internal class System.ServiceModel.Channels.BinaryMessageEncoderFactory : MessageEncoderFactory {
    private static int maxPooledXmlReaderPerMessage;
    private BinaryMessageEncoder _messageEncoder;
    private MessageVersion _messageVersion;
    private int _maxReadPoolSize;
    private int _maxWritePoolSize;
    private CompressionFormat _compressionFormat;
    private SynchronizedPool`1 modreq(System.Runtime.CompilerServices.IsVolatile) _bufferedDataPool;
    private SynchronizedPool`1 modreq(System.Runtime.CompilerServices.IsVolatile) _bufferedWriterPool;
    private SynchronizedPool`1 modreq(System.Runtime.CompilerServices.IsVolatile) _recycledStatePool;
    private object _thisLock;
    private int _maxSessionSize;
    private XmlDictionaryReaderQuotas _readerQuotas;
    private XmlDictionaryReaderQuotas _bufferedReadReaderQuotas;
    private BinaryVersion _binaryVersion;
    [CompilerGeneratedAttribute]
private long <MaxReceivedMessageSize>k__BackingField;
    public static IXmlDictionary XmlDictionary { get; }
    public MessageEncoder Encoder { get; }
    public MessageVersion MessageVersion { get; }
    public int MaxWritePoolSize { get; }
    public XmlDictionaryReaderQuotas ReaderQuotas { get; }
    public int MaxReadPoolSize { get; }
    public int MaxSessionSize { get; }
    public CompressionFormat CompressionFormat { get; }
    private long MaxReceivedMessageSize { get; private set; }
    private object ThisLock { get; }
    private SynchronizedPool`1<RecycledMessageState> RecycledStatePool { get; }
    public BinaryMessageEncoderFactory(MessageVersion messageVersion, int maxReadPoolSize, int maxWritePoolSize, int maxSessionSize, XmlDictionaryReaderQuotas readerQuotas, long maxReceivedMessageSize, BinaryVersion version, CompressionFormat compressionFormat);
    public static IXmlDictionary get_XmlDictionary();
    public virtual MessageEncoder get_Encoder();
    public virtual MessageVersion get_MessageVersion();
    public int get_MaxWritePoolSize();
    public XmlDictionaryReaderQuotas get_ReaderQuotas();
    public int get_MaxReadPoolSize();
    public int get_MaxSessionSize();
    public CompressionFormat get_CompressionFormat();
    [CompilerGeneratedAttribute]
private long get_MaxReceivedMessageSize();
    [CompilerGeneratedAttribute]
private void set_MaxReceivedMessageSize(long value);
    private object get_ThisLock();
    private SynchronizedPool`1<RecycledMessageState> get_RecycledStatePool();
    public virtual MessageEncoder CreateSessionEncoder();
    private XmlDictionaryWriter TakeStreamedWriter(Stream stream);
    private void ReturnStreamedWriter(XmlDictionaryWriter xmlWriter);
    private BinaryBufferedMessageWriter TakeBufferedWriter();
    private void ReturnMessageWriter(BinaryBufferedMessageWriter messageWriter);
    private XmlDictionaryReader TakeStreamedReader(Stream stream);
    private BinaryBufferedMessageData TakeBufferedData(BinaryMessageEncoder messageEncoder);
    private void ReturnBufferedData(BinaryBufferedMessageData messageData);
}
public class System.ServiceModel.Channels.BinaryMessageEncodingBindingElement : MessageEncodingBindingElement {
    private int _maxReadPoolSize;
    private int _maxWritePoolSize;
    private XmlDictionaryReaderQuotas _readerQuotas;
    private int _maxSessionSize;
    private BinaryVersion _binaryVersion;
    private MessageVersion _messageVersion;
    private CompressionFormat _compressionFormat;
    private long _maxReceivedMessageSize;
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public CompressionFormat CompressionFormat { get; public set; }
    private BinaryVersion BinaryVersion { get; private set; }
    public MessageVersion MessageVersion { get; public set; }
    [DefaultValueAttribute("64")]
public int MaxReadPoolSize { get; public set; }
    [DefaultValueAttribute("16")]
public int MaxWritePoolSize { get; public set; }
    public XmlDictionaryReaderQuotas ReaderQuotas { get; public set; }
    [DefaultValueAttribute("2048")]
public int MaxSessionSize { get; public set; }
    private BinaryMessageEncodingBindingElement(BinaryMessageEncodingBindingElement elementToBeCloned);
    public CompressionFormat get_CompressionFormat();
    public void set_CompressionFormat(CompressionFormat value);
    private BinaryVersion get_BinaryVersion();
    private void set_BinaryVersion(BinaryVersion value);
    public virtual MessageVersion get_MessageVersion();
    public virtual void set_MessageVersion(MessageVersion value);
    public int get_MaxReadPoolSize();
    public void set_MaxReadPoolSize(int value);
    public int get_MaxWritePoolSize();
    public void set_MaxWritePoolSize(int value);
    public XmlDictionaryReaderQuotas get_ReaderQuotas();
    public void set_ReaderQuotas(XmlDictionaryReaderQuotas value);
    public int get_MaxSessionSize();
    public void set_MaxSessionSize(int value);
    private void VerifyCompression(BindingContext context);
    private void SetMaxReceivedMessageSizeFromTransport(BindingContext context);
    public virtual IChannelFactory`1<TChannel> BuildChannelFactory(BindingContext context);
    public virtual BindingElement Clone();
    public virtual MessageEncoderFactory CreateMessageEncoderFactory();
    public virtual T GetProperty(BindingContext context);
    internal virtual bool IsMatch(BindingElement b);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeReaderQuotas();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeMessageVersion();
}
public class System.ServiceModel.Channels.BinaryVersion : object {
    public static BinaryVersion Version1;
    public static BinaryVersion GZipVersion1;
    public static BinaryVersion DeflateVersion1;
    private string _contentType;
    private string _sessionContentType;
    private IXmlDictionary _dictionary;
    public static BinaryVersion CurrentVersion { get; }
    public string ContentType { get; }
    public string SessionContentType { get; }
    public IXmlDictionary Dictionary { get; }
    private BinaryVersion(string contentType, string sessionContentType, IXmlDictionary dictionary);
    private static BinaryVersion();
    public static BinaryVersion get_CurrentVersion();
    public string get_ContentType();
    public string get_SessionContentType();
    public IXmlDictionary get_Dictionary();
}
public abstract class System.ServiceModel.Channels.Binding : object {
    private TimeSpan _closeTimeout;
    private string _name;
    private string _namespaceIdentifier;
    private TimeSpan _openTimeout;
    private TimeSpan _receiveTimeout;
    private TimeSpan _sendTimeout;
    internal static string DefaultNamespace;
    public TimeSpan CloseTimeout { get; public set; }
    public string Name { get; public set; }
    public string Namespace { get; public set; }
    public TimeSpan OpenTimeout { get; public set; }
    public TimeSpan ReceiveTimeout { get; public set; }
    public string Scheme { get; }
    public MessageVersion MessageVersion { get; }
    public TimeSpan SendTimeout { get; public set; }
    protected Binding(string name, string ns);
    public sealed virtual TimeSpan get_CloseTimeout();
    public void set_CloseTimeout(TimeSpan value);
    public string get_Name();
    public void set_Name(string value);
    public string get_Namespace();
    public void set_Namespace(string value);
    public sealed virtual TimeSpan get_OpenTimeout();
    public void set_OpenTimeout(TimeSpan value);
    public sealed virtual TimeSpan get_ReceiveTimeout();
    public void set_ReceiveTimeout(TimeSpan value);
    public abstract virtual string get_Scheme();
    public MessageVersion get_MessageVersion();
    public sealed virtual TimeSpan get_SendTimeout();
    public void set_SendTimeout(TimeSpan value);
    public IChannelFactory`1<TChannel> BuildChannelFactory(Object[] parameters);
    public virtual IChannelFactory`1<TChannel> BuildChannelFactory(BindingParameterCollection parameters);
    private void ValidateSecurityCapabilities(ISecurityCapabilities runtimeSecurityCapabilities, BindingParameterCollection parameters);
    public bool CanBuildChannelFactory(Object[] parameters);
    public virtual bool CanBuildChannelFactory(BindingParameterCollection parameters);
    public abstract virtual BindingElementCollection CreateBindingElements();
    public T GetProperty(BindingParameterCollection parameters);
    private void EnsureInvariants();
    internal void EnsureInvariants(string contractName);
    internal void CopyTimeouts(IDefaultCommunicationTimeouts source);
}
public class System.ServiceModel.Channels.BindingContext : object {
    private CustomBinding _binding;
    private BindingParameterCollection _bindingParameters;
    private Uri _listenUriBaseAddress;
    private ListenUriMode _listenUriMode;
    private string _listenUriRelativeAddress;
    private BindingElementCollection _remainingBindingElements;
    public CustomBinding Binding { get; }
    public BindingParameterCollection BindingParameters { get; }
    public Uri ListenUriBaseAddress { get; public set; }
    public ListenUriMode ListenUriMode { get; public set; }
    public string ListenUriRelativeAddress { get; public set; }
    public BindingElementCollection RemainingBindingElements { get; }
    public BindingContext(CustomBinding binding, BindingParameterCollection parameters);
    private BindingContext(CustomBinding binding, BindingElementCollection remainingBindingElements, BindingParameterCollection parameters);
    private void Initialize(CustomBinding binding, BindingElementCollection remainingBindingElements, BindingParameterCollection parameters);
    public CustomBinding get_Binding();
    public BindingParameterCollection get_BindingParameters();
    public Uri get_ListenUriBaseAddress();
    public void set_ListenUriBaseAddress(Uri value);
    public ListenUriMode get_ListenUriMode();
    public void set_ListenUriMode(ListenUriMode value);
    public string get_ListenUriRelativeAddress();
    public void set_ListenUriRelativeAddress(string value);
    public BindingElementCollection get_RemainingBindingElements();
    public IChannelFactory`1<TChannel> BuildInnerChannelFactory();
    public bool CanBuildInnerChannelFactory();
    public T GetInnerProperty();
    public BindingContext Clone();
    private BindingElement RemoveNextElement();
    internal void ValidateBindingElementsConsumed();
}
public abstract class System.ServiceModel.Channels.BindingElement : object {
    protected BindingElement(BindingElement elementToBeCloned);
    public abstract virtual BindingElement Clone();
    public virtual IChannelFactory`1<TChannel> BuildChannelFactory(BindingContext context);
    public virtual bool CanBuildChannelFactory(BindingContext context);
    public abstract virtual T GetProperty(BindingContext context);
    internal T GetIndividualProperty();
    internal virtual bool IsMatch(BindingElement b);
}
public class System.ServiceModel.Channels.BindingElementCollection : Collection`1<BindingElement> {
    public BindingElementCollection(IEnumerable`1<BindingElement> elements);
    public BindingElementCollection(BindingElement[] elements);
    public BindingElementCollection Clone();
    public void AddRange(BindingElement[] elements);
    public bool Contains(Type bindingElementType);
    public T Find();
    public T Remove();
    private T Find(bool remove);
    public Collection`1<T> FindAll();
    public Collection`1<T> RemoveAll();
    private Collection`1<T> FindAll(bool remove);
    protected virtual void InsertItem(int index, BindingElement item);
    protected virtual void SetItem(int index, BindingElement item);
}
public class System.ServiceModel.Channels.BindingParameterCollection : KeyedByTypeCollection`1<object> {
    internal BindingParameterCollection(Object[] parameters);
    internal BindingParameterCollection(BindingParameterCollection parameters);
}
public abstract class System.ServiceModel.Channels.BodyWriter : object {
    private bool _isBuffered;
    private bool _canWrite;
    private object _thisLock;
    public bool IsBuffered { get; }
    internal bool IsEmpty { get; }
    internal bool IsFault { get; }
    protected BodyWriter(bool isBuffered);
    public bool get_IsBuffered();
    internal virtual bool get_IsEmpty();
    internal virtual bool get_IsFault();
    public BodyWriter CreateBufferedCopy(int maxBufferSize);
    protected virtual BodyWriter OnCreateBufferedCopy(int maxBufferSize);
    internal BodyWriter OnCreateBufferedCopy(int maxBufferSize, XmlDictionaryReaderQuotas quotas);
    protected abstract virtual void OnWriteBodyContents(XmlDictionaryWriter writer);
    protected virtual Task OnWriteBodyContentsAsync(XmlDictionaryWriter writer);
    protected virtual IAsyncResult OnBeginWriteBodyContents(XmlDictionaryWriter writer, AsyncCallback callback, object state);
    protected virtual void OnEndWriteBodyContents(IAsyncResult result);
    private void EnsureWriteBodyContentsState(XmlDictionaryWriter writer);
    public void WriteBodyContents(XmlDictionaryWriter writer);
    internal Task WriteBodyContentsAsync(XmlDictionaryWriter writer);
    public IAsyncResult BeginWriteBodyContents(XmlDictionaryWriter writer, AsyncCallback callback, object state);
    public void EndWriteBodyContents(IAsyncResult result);
}
internal class System.ServiceModel.Channels.BodyWriterMessage : Message {
    private MessageProperties _properties;
    private MessageHeaders _headers;
    private BodyWriter _bodyWriter;
    public bool IsFault { get; }
    public bool IsEmpty { get; }
    public MessageHeaders Headers { get; }
    public MessageProperties Properties { get; }
    public MessageVersion Version { get; }
    protected internal BodyWriter BodyWriter { get; }
    private BodyWriterMessage(BodyWriter bodyWriter);
    public BodyWriterMessage(MessageVersion version, string action, BodyWriter bodyWriter);
    public BodyWriterMessage(MessageVersion version, ActionHeader actionHeader, BodyWriter bodyWriter);
    public BodyWriterMessage(MessageHeaders headers, KeyValuePair`2[] properties, BodyWriter bodyWriter);
    public virtual bool get_IsFault();
    public virtual bool get_IsEmpty();
    public virtual MessageHeaders get_Headers();
    public virtual MessageProperties get_Properties();
    public virtual MessageVersion get_Version();
    protected virtual MessageBuffer OnCreateBufferedCopy(int maxBufferSize);
    protected virtual void OnClose();
    protected virtual void OnWriteBodyContents(XmlDictionaryWriter writer);
    protected virtual Task OnWriteBodyContentsAsync(XmlDictionaryWriter writer);
    protected virtual IAsyncResult OnBeginWriteMessage(XmlDictionaryWriter writer, AsyncCallback callback, object state);
    protected virtual void OnEndWriteMessage(IAsyncResult result);
    protected virtual IAsyncResult OnBeginWriteBodyContents(XmlDictionaryWriter writer, AsyncCallback callback, object state);
    protected virtual void OnEndWriteBodyContents(IAsyncResult result);
    protected virtual void OnBodyToString(XmlDictionaryWriter writer);
    protected internal BodyWriter get_BodyWriter();
}
internal class System.ServiceModel.Channels.BodyWriterMessageBuffer : MessageBuffer {
    private BodyWriter _bodyWriter;
    private KeyValuePair`2[] _properties;
    private MessageHeaders _headers;
    private bool _closed;
    private object _thisLock;
    protected object ThisLock { get; }
    public int BufferSize { get; }
    protected BodyWriter BodyWriter { get; }
    protected MessageHeaders Headers { get; }
    protected KeyValuePair`2[] Properties { get; }
    protected bool Closed { get; }
    public BodyWriterMessageBuffer(MessageHeaders headers, KeyValuePair`2[] properties, BodyWriter bodyWriter);
    protected object get_ThisLock();
    public virtual int get_BufferSize();
    public virtual void Close();
    public virtual Message CreateMessage();
    protected BodyWriter get_BodyWriter();
    protected MessageHeaders get_Headers();
    protected KeyValuePair`2[] get_Properties();
    protected bool get_Closed();
}
internal class System.ServiceModel.Channels.BufferedAddressHeader : AddressHeader {
    private string _name;
    private string _ns;
    private XmlBuffer _buffer;
    private bool _isReferenceProperty;
    public bool IsReferencePropertyHeader { get; }
    public string Name { get; }
    public string Namespace { get; }
    public BufferedAddressHeader(XmlDictionaryReader reader);
    public BufferedAddressHeader(XmlDictionaryReader reader, bool isReferenceProperty);
    public bool get_IsReferencePropertyHeader();
    public virtual string get_Name();
    public virtual string get_Namespace();
    public virtual XmlDictionaryReader GetAddressHeaderReader();
    protected virtual void OnWriteStartAddressHeader(XmlDictionaryWriter writer);
    protected virtual void OnWriteAddressHeaderContents(XmlDictionaryWriter writer);
}
internal class System.ServiceModel.Channels.BufferedConnection : DelegatingConnection {
    private Byte[] _writeBuffer;
    private int _writeBufferSize;
    private int _pendingWriteSize;
    private Exception _pendingWriteException;
    private Timer _flushTimer;
    private TimeSpan _flushTimeout;
    private TimeSpan _pendingTimeout;
    private static int maxFlushSkew;
    private object ThisLock { get; }
    public BufferedConnection(IConnection connection, TimeSpan flushTimeout, int writeBufferSize);
    private object get_ThisLock();
    public virtual void Close(TimeSpan timeout, bool asyncAndLinger);
    private void CancelFlushTimer();
    private void Flush(TimeSpan timeout);
    private void FlushCore(TimeSpan timeout);
    private void OnFlushTimer(object state);
    private void SetFlushTimer();
    public virtual void Write(Byte[] buffer, int offset, int size, bool immediate, TimeSpan timeout, BufferManager bufferManager);
    public virtual void Write(Byte[] buffer, int offset, int size, bool immediate, TimeSpan timeout);
    private void WriteNow(Byte[] buffer, int offset, int size, TimeSpan timeout);
    private void WriteNow(Byte[] buffer, int offset, int size, TimeSpan timeout, BufferManager bufferManager);
    private void WriteLater(Byte[] buffer, int offset, int size, TimeSpan timeout);
    public virtual AsyncCompletionResult BeginWrite(Byte[] buffer, int offset, int size, bool immediate, TimeSpan timeout, Action`1<object> callback, object state);
    public virtual void EndWrite();
    private void ThrowPendingWriteException();
}
internal class System.ServiceModel.Channels.BufferedConnectionInitiator : object {
    private int _writeBufferSize;
    private TimeSpan _flushTimeout;
    private IConnectionInitiator _connectionInitiator;
    protected TimeSpan FlushTimeout { get; }
    protected int WriteBufferSize { get; }
    public BufferedConnectionInitiator(IConnectionInitiator connectionInitiator, TimeSpan flushTimeout, int writeBufferSize);
    protected TimeSpan get_FlushTimeout();
    protected int get_WriteBufferSize();
    public sealed virtual IConnection Connect(Uri uri, TimeSpan timeout);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.BufferedConnectionInitiator/<ConnectAsync>d__9")]
public sealed virtual Task`1<IConnection> ConnectAsync(Uri uri, TimeSpan timeout);
}
internal class System.ServiceModel.Channels.BufferedHeader : ReadableMessageHeader {
    private MessageVersion _version;
    private XmlBuffer _buffer;
    private int _bufferIndex;
    private string _actor;
    private bool _relay;
    private bool _mustUnderstand;
    private string _name;
    private string _ns;
    private bool _streamed;
    private bool _isRefParam;
    public string Actor { get; }
    public bool IsReferenceParameter { get; }
    public string Name { get; }
    public string Namespace { get; }
    public bool MustUnderstand { get; }
    public bool Relay { get; }
    public BufferedHeader(MessageVersion version, XmlBuffer buffer, int bufferIndex, string name, string ns, bool mustUnderstand, string actor, bool relay, bool isRefParam);
    public BufferedHeader(MessageVersion version, XmlBuffer buffer, int bufferIndex, MessageHeaderInfo headerInfo);
    public BufferedHeader(MessageVersion version, XmlBuffer buffer, XmlDictionaryReader reader, XmlAttributeHolder[] envelopeAttributes, XmlAttributeHolder[] headerAttributes);
    public virtual string get_Actor();
    public virtual bool get_IsReferenceParameter();
    public virtual string get_Name();
    public virtual string get_Namespace();
    public virtual bool get_MustUnderstand();
    public virtual bool get_Relay();
    public virtual bool IsMessageVersionSupported(MessageVersion messageVersion);
    public virtual XmlDictionaryReader GetHeaderReader();
}
internal class System.ServiceModel.Channels.BufferedMessage : ReceivedMessage {
    private MessageHeaders _headers;
    private MessageProperties _properties;
    private IBufferedMessageData _messageData;
    private RecycledMessageState _recycledMessageState;
    private XmlDictionaryReader _reader;
    private XmlAttributeHolder[] _bodyAttributes;
    public MessageHeaders Headers { get; }
    internal IBufferedMessageData MessageData { get; }
    public MessageProperties Properties { get; }
    internal RecycledMessageState RecycledMessageState { get; }
    public MessageVersion Version { get; }
    public BufferedMessage(IBufferedMessageData messageData, RecycledMessageState recycledMessageState);
    public BufferedMessage(IBufferedMessageData messageData, RecycledMessageState recycledMessageState, Boolean[] understoodHeaders, bool understoodHeadersModified);
    public virtual MessageHeaders get_Headers();
    internal IBufferedMessageData get_MessageData();
    public virtual MessageProperties get_Properties();
    internal virtual RecycledMessageState get_RecycledMessageState();
    public virtual MessageVersion get_Version();
    protected virtual XmlDictionaryReader OnGetReaderAtBodyContents();
    internal virtual XmlDictionaryReader GetReaderAtHeader();
    public XmlDictionaryReader GetBufferedReaderAtBody();
    public XmlDictionaryReader GetMessageReader();
    protected virtual void OnBodyToString(XmlDictionaryWriter writer);
    protected virtual void OnClose();
    protected virtual void OnWriteStartEnvelope(XmlDictionaryWriter writer);
    protected virtual void OnWriteStartHeaders(XmlDictionaryWriter writer);
    protected virtual void OnWriteStartBody(XmlDictionaryWriter writer);
    protected virtual MessageBuffer OnCreateBufferedCopy(int maxBufferSize);
    protected virtual string OnGetBodyAttribute(string localName, string ns);
}
internal class System.ServiceModel.Channels.BufferedMessageBuffer : MessageBuffer {
    private IBufferedMessageData _messageData;
    private KeyValuePair`2[] _properties;
    private bool _closed;
    private object _thisLock;
    private Boolean[] _understoodHeaders;
    private bool _understoodHeadersModified;
    public int BufferSize { get; }
    public string MessageContentType { get; }
    private object ThisLock { get; }
    public BufferedMessageBuffer(IBufferedMessageData messageData, KeyValuePair`2[] properties, Boolean[] understoodHeaders, bool understoodHeadersModified);
    public virtual int get_BufferSize();
    public virtual void WriteMessage(Stream stream);
    public virtual string get_MessageContentType();
    private object get_ThisLock();
    public virtual void Close();
    public virtual Message CreateMessage();
}
internal class System.ServiceModel.Channels.BufferedMessageContent : MessageContent {
    private bool _disposed;
    private bool _messageEncoded;
    private ArraySegment`1<byte> _buffer;
    private Nullable`1<long> _contentLength;
    public BufferedMessageContent(Message message, MessageEncoder messageEncoder, BufferManager bufferManager);
    protected virtual Task`1<Stream> CreateContentReadStreamAsync();
    private void EnsureMessageEncoded();
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.BufferedMessageContent/<SerializeToStreamAsync>d__7")]
protected virtual Task SerializeToStreamAsync(Stream stream, TransportContext context);
    protected virtual bool TryComputeLength(Int64& length);
    protected virtual void Dispose(bool disposing);
}
internal abstract class System.ServiceModel.Channels.BufferedMessageData : object {
    private ArraySegment`1<byte> _buffer;
    private BufferManager _bufferManager;
    private int _refCount;
    private int _outstandingReaders;
    private bool _multipleUsers;
    private RecycledMessageState _messageState;
    private SynchronizedPool`1<RecycledMessageState> _messageStatePool;
    public ArraySegment`1<byte> Buffer { get; }
    public BufferManager BufferManager { get; }
    public XmlDictionaryReaderQuotas Quotas { get; }
    public MessageEncoder MessageEncoder { get; }
    private object ThisLock { get; }
    public BufferedMessageData(SynchronizedPool`1<RecycledMessageState> messageStatePool);
    public sealed virtual ArraySegment`1<byte> get_Buffer();
    public BufferManager get_BufferManager();
    public virtual XmlDictionaryReaderQuotas get_Quotas();
    public abstract virtual MessageEncoder get_MessageEncoder();
    private object get_ThisLock();
    public sealed virtual void EnableMultipleUsers();
    public sealed virtual void Close();
    private void DoClose();
    public void DoReturnMessageState(RecycledMessageState messageState);
    private void DoReturnXmlReader(XmlDictionaryReader reader);
    public RecycledMessageState DoTakeMessageState();
    private XmlDictionaryReader DoTakeXmlReader();
    public sealed virtual XmlDictionaryReader GetMessageReader();
    public void OnXmlReaderClosed(XmlDictionaryReader reader);
    protected virtual void OnClosed();
    public sealed virtual RecycledMessageState TakeMessageState();
    protected abstract virtual XmlDictionaryReader TakeXmlReader();
    public sealed virtual void Open();
    public void Open(ArraySegment`1<byte> buffer, BufferManager bufferManager);
    protected abstract virtual void ReturnXmlReader(XmlDictionaryReader xmlReader);
    public sealed virtual void ReturnMessageState(RecycledMessageState messageState);
}
internal abstract class System.ServiceModel.Channels.BufferedMessageWriter : object {
    private Int32[] _sizeHistory;
    private int _sizeHistoryIndex;
    private static int sizeHistoryCount;
    private static int expectedSizeVariance;
    private BufferManagerOutputStream _stream;
    protected abstract virtual XmlDictionaryWriter TakeXmlWriter(Stream stream);
    protected abstract virtual void ReturnXmlWriter(XmlDictionaryWriter writer);
    public ArraySegment`1<byte> WriteMessage(Message message, BufferManager bufferManager, int initialOffset, int maxSizeQuota);
    protected virtual void OnWriteStartMessage(XmlDictionaryWriter writer);
    protected virtual void OnWriteEndMessage(XmlDictionaryWriter writer);
    private void InitMessagePredicter();
    private int PredictMessageSize();
    private void RecordActualMessageSize(int size);
}
public class System.ServiceModel.Channels.BufferedReadStream : Stream {
    private static int DefaultBufferSize;
    private Stream _stream;
    private Byte[] _buffer;
    private int _bufferSize;
    private int _readPos;
    private int _readLen;
    private Task`1<int> _lastSyncCompletedReadTask;
    private BufferManager _bufferManager;
    private SemaphoreSlim _sem;
    public static string BufferedReadStreamPropertyName;
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public bool CanSeek { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public bool IsBufferEmpty { get; }
    public BufferedReadStream(Stream stream);
    public BufferedReadStream(Stream stream, BufferManager bufferManager);
    public BufferedReadStream(Stream stream, BufferManager bufferManager, int bufferSize);
    private void EnsureNotClosed();
    private void EnsureCanRead();
    private void EnsureBufferAllocated();
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual bool get_CanSeek();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    protected virtual void Dispose(bool disposing);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    private int ReadFromBuffer(Byte[] array, int offset, int count);
    private int ReadFromBuffer(Byte[] array, int offset, int count, Exception& error);
    public virtual int Read(Byte[] array, int offset, int count);
    private Task`1<int> LastSyncCompletedReadTask(int val);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.BufferedReadStream/<PreReadBufferAsync>d__34")]
public Task PreReadBufferAsync(byte preBufferedByte, CancellationToken cancellationToken);
    public Task PreReadBufferAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.BufferedReadStream/<PreReadBufferAsyncInternal>d__36")]
private Task PreReadBufferAsyncInternal(CancellationToken cancellationToken);
    public bool get_IsBufferEmpty();
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.BufferedReadStream/<ReadFromUnderlyingStreamAsync>d__40")]
private Task`1<int> ReadFromUnderlyingStreamAsync(Byte[] array, int offset, int count, CancellationToken cancellationToken, int bytesAlreadySatisfied, Task semaphoreLockTask);
    public virtual int ReadByte();
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual void WriteByte(byte value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
}
internal class System.ServiceModel.Channels.BufferedWriteStream : Stream {
    public static int DefaultBufferSize;
    private Stream _stream;
    private BufferManager _bufferManager;
    private Byte[] _buffer;
    private int _bufferSize;
    private int _writePos;
    private SemaphoreSlim _sem;
    private static int MaxShadowBufferSize;
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public bool CanSeek { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public BufferedWriteStream(Stream stream);
    public BufferedWriteStream(Stream stream, BufferManager bufferManager);
    public BufferedWriteStream(Stream stream, BufferManager bufferManager, int bufferSize);
    private void EnsureNotClosed();
    private void EnsureCanWrite();
    private void EnsureShadowBufferAllocated();
    private void EnsureBufferAllocated();
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual bool get_CanSeek();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    protected virtual void Dispose(bool disposing);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.BufferedWriteStream/<FlushAsyncInternal>d__29")]
private Task FlushAsyncInternal(CancellationToken cancellationToken);
    private void FlushWrite();
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.BufferedWriteStream/<FlushWriteAsync>d__31")]
private Task FlushWriteAsync(CancellationToken cancellationToken);
    public virtual int Read(Byte[] array, int offset, int count);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual int ReadByte();
    private void WriteToBuffer(Byte[] array, Int32& offset, Int32& count);
    private void WriteToBuffer(Byte[] array, Int32& offset, Int32& count, Exception& error);
    public virtual void Write(Byte[] array, int offset, int count);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.BufferedWriteStream/<WriteToUnderlyingStreamAsync>d__39")]
private Task WriteToUnderlyingStreamAsync(Byte[] array, int offset, int count, CancellationToken cancellationToken, Task semaphoreLockTask);
    public virtual void WriteByte(byte value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
}
public abstract class System.ServiceModel.Channels.BufferManager : object {
    public abstract virtual Byte[] TakeBuffer(int bufferSize);
    public abstract virtual void ReturnBuffer(Byte[] buffer);
    public abstract virtual void Clear();
    public static BufferManager CreateBufferManager(long maxBufferPoolSize, int maxBufferSize);
    internal static InternalBufferManager GetInternalBufferManager(BufferManager bufferManager);
}
internal class System.ServiceModel.Channels.BufferManagerOutputStream : BufferedOutputStream {
    private string _quotaExceededString;
    public BufferManagerOutputStream(string quotaExceededString);
    public BufferManagerOutputStream(string quotaExceededString, int maxSize);
    public BufferManagerOutputStream(string quotaExceededString, int initialSize, int maxSize, BufferManager bufferManager);
    public void Init(int initialSize, int maxSizeQuota, BufferManager bufferManager);
    public void Init(int initialSize, int maxSizeQuota, int effectiveMaxSize, BufferManager bufferManager);
    protected virtual Exception CreateQuotaExceededException(int maxSizeQuota);
}
internal class System.ServiceModel.Channels.ChainedAsyncResult : AsyncResult {
    private ChainedBeginHandler _begin2;
    private ChainedEndHandler _end1;
    private ChainedEndHandler _end2;
    private TimeoutHelper _timeoutHelper;
    private static AsyncCallback s_begin1Callback;
    private static AsyncCallback s_begin2Callback;
    protected ChainedAsyncResult(TimeSpan timeout, AsyncCallback callback, object state);
    public ChainedAsyncResult(TimeSpan timeout, AsyncCallback callback, object state, ChainedBeginHandler begin1, ChainedEndHandler end1, ChainedBeginHandler begin2, ChainedEndHandler end2);
    private static ChainedAsyncResult();
    protected void Begin(ChainedBeginHandler begin1, ChainedEndHandler end1, ChainedBeginHandler begin2, ChainedEndHandler end2);
    private static void Begin1Callback(IAsyncResult result);
    private bool Begin1Completed(IAsyncResult result);
    private static void Begin2Callback(IAsyncResult result);
    public static void End(IAsyncResult result);
}
internal class System.ServiceModel.Channels.ChainedBeginHandler : MulticastDelegate {
    public ChainedBeginHandler(object object, IntPtr method);
    public virtual IAsyncResult Invoke(TimeSpan timeout, AsyncCallback asyncCallback, object state);
    public virtual IAsyncResult BeginInvoke(TimeSpan timeout, AsyncCallback asyncCallback, object state, AsyncCallback callback, object object);
    public virtual IAsyncResult EndInvoke(IAsyncResult result);
}
internal class System.ServiceModel.Channels.ChainedCloseAsyncResult : ChainedAsyncResult {
    private IList`1<ICommunicationObject> _collection;
    public ChainedCloseAsyncResult(TimeSpan timeout, AsyncCallback callback, object state, ChainedBeginHandler begin1, ChainedEndHandler end1, IList`1<ICommunicationObject> collection);
    public ChainedCloseAsyncResult(TimeSpan timeout, AsyncCallback callback, object state, ChainedBeginHandler begin1, ChainedEndHandler end1, ICommunicationObject[] objs);
    private IAsyncResult BeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    private void EndClose(IAsyncResult result);
}
internal class System.ServiceModel.Channels.ChainedEndHandler : MulticastDelegate {
    public ChainedEndHandler(object object, IntPtr method);
    public virtual void Invoke(IAsyncResult result);
    public virtual IAsyncResult BeginInvoke(IAsyncResult result, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.ServiceModel.Channels.ChainedOpenAsyncResult : ChainedAsyncResult {
    private IList`1<ICommunicationObject> _collection;
    public ChainedOpenAsyncResult(TimeSpan timeout, AsyncCallback callback, object state, ChainedBeginHandler begin1, ChainedEndHandler end1, IList`1<ICommunicationObject> collection);
    public ChainedOpenAsyncResult(TimeSpan timeout, AsyncCallback callback, object state, ChainedBeginHandler begin1, ChainedEndHandler end1, ICommunicationObject[] objs);
    private IAsyncResult BeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    private void EndOpen(IAsyncResult result);
}
public abstract class System.ServiceModel.Channels.ChannelBase : CommunicationObject {
    private ChannelManagerBase _channelManager;
    private TimeSpan System.ServiceModel.IDefaultCommunicationTimeouts.CloseTimeout { get; }
    private TimeSpan System.ServiceModel.IDefaultCommunicationTimeouts.OpenTimeout { get; }
    private TimeSpan System.ServiceModel.IDefaultCommunicationTimeouts.ReceiveTimeout { get; }
    private TimeSpan System.ServiceModel.IDefaultCommunicationTimeouts.SendTimeout { get; }
    protected TimeSpan DefaultCloseTimeout { get; }
    protected TimeSpan DefaultOpenTimeout { get; }
    protected TimeSpan DefaultReceiveTimeout { get; }
    protected TimeSpan DefaultSendTimeout { get; }
    protected ChannelManagerBase Manager { get; }
    protected ChannelBase(ChannelManagerBase channelManager);
    private sealed virtual override TimeSpan System.ServiceModel.IDefaultCommunicationTimeouts.get_CloseTimeout();
    private sealed virtual override TimeSpan System.ServiceModel.IDefaultCommunicationTimeouts.get_OpenTimeout();
    private sealed virtual override TimeSpan System.ServiceModel.IDefaultCommunicationTimeouts.get_ReceiveTimeout();
    private sealed virtual override TimeSpan System.ServiceModel.IDefaultCommunicationTimeouts.get_SendTimeout();
    protected virtual TimeSpan get_DefaultCloseTimeout();
    protected virtual TimeSpan get_DefaultOpenTimeout();
    protected TimeSpan get_DefaultReceiveTimeout();
    protected TimeSpan get_DefaultSendTimeout();
    protected ChannelManagerBase get_Manager();
    public virtual T GetProperty();
    protected virtual void OnClosed();
}
internal class System.ServiceModel.Channels.ChannelBindingMessageProperty : object {
    private static string propertyName;
    private ChannelBinding _channelBinding;
    private object _thisLock;
    private bool _ownsCleanup;
    private int _refCount;
    public static string Name { get; }
    private bool IsDisposed { get; }
    public ChannelBinding ChannelBinding { get; }
    public ChannelBindingMessageProperty(ChannelBinding channelBinding, bool ownsCleanup);
    public static string get_Name();
    private bool get_IsDisposed();
    public ChannelBinding get_ChannelBinding();
    public static bool TryGet(Message message, ChannelBindingMessageProperty& property);
    public static bool TryGet(MessageProperties properties, ChannelBindingMessageProperty& property);
    public void AddTo(Message message);
    public void AddTo(MessageProperties properties);
    public sealed virtual IMessageProperty CreateCopy();
    public sealed virtual void Dispose();
    private void ThrowIfDisposed();
}
internal static class System.ServiceModel.Channels.ChannelBindingUtility : object {
    public static ChannelBinding GetToken(SslStream stream);
    public static ChannelBinding GetToken(TransportContext context);
    public static void TryAddToMessage(ChannelBinding channelBindingToken, Message message, bool messagePropertyOwnsCleanup);
    public static void Dispose(ChannelBinding& channelBinding);
}
internal class System.ServiceModel.Channels.ChannelBuilder : object {
    private CustomBinding _binding;
    private BindingContext _context;
    private BindingParameterCollection _bindingParameters;
    public CustomBinding Binding { get; public set; }
    public BindingParameterCollection BindingParameters { get; public set; }
    public ChannelBuilder(BindingContext context, bool addChannelDemuxerIfRequired);
    public ChannelBuilder(Binding binding, BindingParameterCollection bindingParameters, bool addChannelDemuxerIfRequired);
    public ChannelBuilder(ChannelBuilder channelBuilder);
    public CustomBinding get_Binding();
    public void set_Binding(CustomBinding value);
    public BindingParameterCollection get_BindingParameters();
    public void set_BindingParameters(BindingParameterCollection value);
    public IChannelFactory`1<TChannel> BuildChannelFactory();
    public bool CanBuildChannelFactory();
}
public abstract class System.ServiceModel.Channels.ChannelFactoryBase : ChannelManagerBase {
    private TimeSpan _closeTimeout;
    private TimeSpan _openTimeout;
    private TimeSpan _receiveTimeout;
    private TimeSpan _sendTimeout;
    protected TimeSpan DefaultCloseTimeout { get; }
    protected TimeSpan DefaultOpenTimeout { get; }
    protected TimeSpan DefaultReceiveTimeout { get; }
    protected TimeSpan DefaultSendTimeout { get; }
    protected ChannelFactoryBase(IDefaultCommunicationTimeouts timeouts);
    protected virtual TimeSpan get_DefaultCloseTimeout();
    protected virtual TimeSpan get_DefaultOpenTimeout();
    protected virtual TimeSpan get_DefaultReceiveTimeout();
    protected virtual TimeSpan get_DefaultSendTimeout();
    public virtual T GetProperty();
    protected virtual void OnAbort();
    protected virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    protected internal virtual Task OnCloseAsync(TimeSpan timeout);
    protected virtual void OnClose(TimeSpan timeout);
    protected virtual void OnEndClose(IAsyncResult result);
    private void InitializeTimeouts(IDefaultCommunicationTimeouts timeouts);
}
public abstract class System.ServiceModel.Channels.ChannelFactoryBase`1 : ChannelFactoryBase {
    private CommunicationObjectManager`1<IChannel> _channels;
    protected ChannelFactoryBase`1(IDefaultCommunicationTimeouts timeouts);
    public sealed virtual TChannel CreateChannel(EndpointAddress address);
    public sealed virtual TChannel CreateChannel(EndpointAddress address, Uri via);
    private TChannel InternalCreateChannel(EndpointAddress address, Uri via);
    protected abstract virtual TChannel OnCreateChannel(EndpointAddress address, Uri via);
    protected void ValidateCreateChannel();
    protected virtual void OnAbort();
    protected virtual void OnClose(TimeSpan timeout);
    protected internal virtual Task OnCloseAsync(TimeSpan timeout);
    protected virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndClose(IAsyncResult result);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.ChannelFactoryBase`1/<OnCloseAsyncInternal>d__13")]
private Task OnCloseAsyncInternal(TimeSpan timeout);
}
public abstract class System.ServiceModel.Channels.ChannelManagerBase : CommunicationObject {
    protected TimeSpan DefaultReceiveTimeout { get; }
    protected TimeSpan DefaultSendTimeout { get; }
    internal TimeSpan InternalReceiveTimeout { get; }
    internal TimeSpan InternalSendTimeout { get; }
    private TimeSpan System.ServiceModel.IDefaultCommunicationTimeouts.CloseTimeout { get; }
    private TimeSpan System.ServiceModel.IDefaultCommunicationTimeouts.OpenTimeout { get; }
    private TimeSpan System.ServiceModel.IDefaultCommunicationTimeouts.ReceiveTimeout { get; }
    private TimeSpan System.ServiceModel.IDefaultCommunicationTimeouts.SendTimeout { get; }
    protected abstract virtual TimeSpan get_DefaultReceiveTimeout();
    protected abstract virtual TimeSpan get_DefaultSendTimeout();
    internal TimeSpan get_InternalReceiveTimeout();
    internal TimeSpan get_InternalSendTimeout();
    private sealed virtual override TimeSpan System.ServiceModel.IDefaultCommunicationTimeouts.get_CloseTimeout();
    private sealed virtual override TimeSpan System.ServiceModel.IDefaultCommunicationTimeouts.get_OpenTimeout();
    private sealed virtual override TimeSpan System.ServiceModel.IDefaultCommunicationTimeouts.get_ReceiveTimeout();
    private sealed virtual override TimeSpan System.ServiceModel.IDefaultCommunicationTimeouts.get_SendTimeout();
    internal Exception CreateChannelTypeNotSupportedException(Type type);
}
public class System.ServiceModel.Channels.ChannelParameterCollection : Collection`1<object> {
    private IChannel _channel;
    protected IChannel Channel { get; }
    public ChannelParameterCollection(IChannel channel);
    protected virtual IChannel get_Channel();
    public void PropagateChannelParameters(IChannel innerChannel);
    protected virtual void ClearItems();
    protected virtual void InsertItem(int index, object item);
    protected virtual void RemoveItem(int index);
    protected virtual void SetItem(int index, object item);
    private void ThrowIfDisposedOrImmutable();
    private void ThrowIfMutable();
}
internal class System.ServiceModel.Channels.ChannelRequirements : ValueType {
    public bool usesInput;
    public bool usesReply;
    public bool usesOutput;
    public bool usesRequest;
    public SessionMode sessionMode;
    public static void ComputeContractRequirements(ContractDescription contractDescription, ChannelRequirements& requirements);
    public static Type[] ComputeRequiredChannels(ChannelRequirements& requirements);
    public static bool IsSessionful(Type channelType);
    public static bool IsOneWay(Type channelType);
    public static bool IsRequestReply(Type channelType);
    public static bool IsDuplex(Type channelType);
    public static Exception CantCreateListenerException(IEnumerable`1<Type> supportedChannels, IEnumerable`1<Type> requiredChannels, string bindingName);
    public static Exception CantCreateChannelException(IEnumerable`1<Type> supportedChannels, IEnumerable`1<Type> requiredChannels, string bindingName);
    public static Exception BindingContractMismatchException(IEnumerable`1<Type> supportedChannels, IEnumerable`1<Type> requiredChannels, string bindingName, String& contractChannelTypesString, String& bindingChannelTypesString);
}
internal class System.ServiceModel.Channels.ClientDuplexConnectionReader : SessionConnectionReader {
    private ClientDuplexDecoder _decoder;
    private int _maxBufferSize;
    private BufferManager _bufferManager;
    private MessageEncoder _messageEncoder;
    private ClientFramingDuplexSessionChannel _channel;
    public ClientDuplexConnectionReader(ClientFramingDuplexSessionChannel channel, IConnection connection, ClientDuplexDecoder decoder, IConnectionOrientedTransportFactorySettings settings, MessageEncoder messageEncoder);
    protected virtual void EnsureDecoderAtEof();
    private static IDisposable CreateProcessActionActivity();
    protected virtual Message DecodeMessage(Byte[] buffer, Int32& offset, Int32& size, Boolean& isAtEOF, TimeSpan timeout);
}
internal class System.ServiceModel.Channels.ClientDuplexDecoder : ClientFramingDecoder {
    private IntDecoder _sizeDecoder;
    private FaultStringDecoder _faultDecoder;
    private int _envelopeBytesNeeded;
    private int _envelopeSize;
    public int EnvelopeSize { get; }
    public string Fault { get; }
    public ClientDuplexDecoder(long streamPosition);
    public int get_EnvelopeSize();
    public virtual string get_Fault();
    public virtual int Decode(Byte[] bytes, int offset, int size);
}
internal class System.ServiceModel.Channels.ClientDuplexEncoder : SessionEncoder {
    public static Byte[] ModeBytes;
    private static ClientDuplexEncoder();
}
internal abstract class System.ServiceModel.Channels.ClientFramingDecoder : FramingDecoder {
    private ClientFramingDecoderState _currentState;
    public ClientFramingDecoderState CurrentState { get; protected set; }
    protected string CurrentStateAsString { get; }
    public string Fault { get; }
    protected ClientFramingDecoder(long streamPosition);
    public ClientFramingDecoderState get_CurrentState();
    protected void set_CurrentState(ClientFramingDecoderState value);
    protected virtual string get_CurrentStateAsString();
    public abstract virtual string get_Fault();
    public abstract virtual int Decode(Byte[] bytes, int offset, int size);
}
internal enum System.ServiceModel.Channels.ClientFramingDecoderState : Enum {
    public int value__;
    public static ClientFramingDecoderState ReadingUpgradeRecord;
    public static ClientFramingDecoderState ReadingUpgradeMode;
    public static ClientFramingDecoderState UpgradeResponse;
    public static ClientFramingDecoderState ReadingAckRecord;
    public static ClientFramingDecoderState Start;
    public static ClientFramingDecoderState ReadingFault;
    public static ClientFramingDecoderState ReadingFaultString;
    public static ClientFramingDecoderState Fault;
    public static ClientFramingDecoderState ReadingEnvelopeRecord;
    public static ClientFramingDecoderState ReadingEnvelopeSize;
    public static ClientFramingDecoderState EnvelopeStart;
    public static ClientFramingDecoderState ReadingEnvelopeBytes;
    public static ClientFramingDecoderState EnvelopeEnd;
    public static ClientFramingDecoderState ReadingEndRecord;
    public static ClientFramingDecoderState End;
}
internal class System.ServiceModel.Channels.ClientFramingDuplexSessionChannel : FramingDuplexSessionChannel {
    private IConnectionOrientedTransportChannelFactorySettings _settings;
    private ClientDuplexDecoder _decoder;
    private StreamUpgradeProvider _upgrade;
    private ConnectionPoolHelper _connectionPoolHelper;
    private bool _flowIdentity;
    public ClientFramingDuplexSessionChannel(ChannelManagerBase factory, IConnectionOrientedTransportChannelFactorySettings settings, EndpointAddress remoteAddresss, Uri via, IConnectionInitiator connectionInitiator, ConnectionPool connectionPool, bool exposeConnectionProperty, bool flowIdentity);
    private ArraySegment`1<byte> CreatePreamble();
    protected virtual IAsyncResult OnBeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndOpen(IAsyncResult result);
    public virtual T GetProperty();
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.ClientFramingDuplexSessionChannel/<SendPreambleAsync>d__10")]
private Task`1<IConnection> SendPreambleAsync(IConnection connection, ArraySegment`1<byte> preamble, TimeSpan timeout);
    private IConnection SendPreamble(IConnection connection, ArraySegment`1<byte> preamble, TimeoutHelper& timeoutHelper);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.ClientFramingDuplexSessionChannel/<OnOpenAsync>d__12")]
protected internal virtual Task OnOpenAsync(TimeSpan timeout);
    protected virtual void OnOpen(TimeSpan timeout);
    protected virtual void ReturnConnectionIfNecessary(bool abort, TimeSpan timeout);
    private void AcceptConnection(IConnection connection);
    private void SetRemoteSecurity(StreamUpgradeInitiator upgradeInitiator);
    protected virtual void PrepareMessage(Message message);
}
internal class System.ServiceModel.Channels.ClientSimplexEncoder : SessionEncoder {
    public static Byte[] ModeBytes;
    private static ClientSimplexEncoder();
}
internal class System.ServiceModel.Channels.ClientSingletonDecoder : ClientFramingDecoder {
    private FaultStringDecoder _faultDecoder;
    public string Fault { get; }
    public ClientSingletonDecoder(long streamPosition);
    public virtual string get_Fault();
    public virtual int Decode(Byte[] bytes, int offset, int size);
}
internal class System.ServiceModel.Channels.ClientSingletonEncoder : SingletonEncoder {
    public static Byte[] PreambleEndBytes;
    public static Byte[] ModeBytes;
    private static ClientSingletonEncoder();
    public static int CalcStartSize(EncodedVia via, EncodedContentType contentType);
    public static void EncodeStart(Byte[] buffer, int offset, EncodedVia via, EncodedContentType contentType);
}
public abstract class System.ServiceModel.Channels.ClientWebSocketFactory : object {
    public abstract virtual Task`1<WebSocket> CreateWebSocketAsync(Uri address, WebHeaderCollection headers, ICredentials credentials, WebSocketTransportSettings settings, TimeoutHelper timeoutHelper);
    public static ClientWebSocketFactory GetFactory();
}
internal class System.ServiceModel.Channels.ClientWebSocketTransportDuplexSessionChannel : WebSocketTransportDuplexSessionChannel {
    private ClientWebSocketFactory _connectionFactory;
    private HttpChannelFactory`1<IDuplexSessionChannel> _channelFactory;
    private SecurityTokenProviderContainer _webRequestTokenProvider;
    private SecurityTokenProviderContainer _webRequestProxyTokenProvider;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _cleanupStarted;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _cleanupIdentity;
    protected bool IsStreamedOutput { get; }
    public ClientWebSocketTransportDuplexSessionChannel(HttpChannelFactory`1<IDuplexSessionChannel> channelFactory, ClientWebSocketFactory connectionFactory, EndpointAddress remoteAddresss, Uri via);
    protected virtual bool get_IsStreamedOutput();
    protected virtual IAsyncResult OnBeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndOpen(IAsyncResult result);
    protected virtual void OnOpen(TimeSpan timeout);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.ClientWebSocketTransportDuplexSessionChannel/<OnOpenAsync>d__12")]
protected internal virtual Task OnOpenAsync(TimeSpan timeout);
    protected virtual void OnCleanup();
    private static void TryConvertAndThrow(WebSocketException ex);
    private void CleanupOnError();
    private void CleanupTokenProviders();
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.ClientWebSocketTransportDuplexSessionChannel/<CreateWebSocketWithFactoryAsync>d__17")]
private Task`1<WebSocket> CreateWebSocketWithFactoryAsync(X509Certificate2 certificate, TimeoutHelper timeoutHelper);
}
internal class System.ServiceModel.Channels.CloseCommunicationAsyncResult : AsyncResult {
    private object _mutex;
    private CommunicationWaitResult _result;
    private Timer _timer;
    private TimeoutHelper _timeoutHelper;
    private TimeSpan _timeout;
    private object ThisLock { get; }
    public CloseCommunicationAsyncResult(TimeSpan timeout, AsyncCallback callback, object state, object mutex);
    private object get_ThisLock();
    public sealed virtual void Dispose();
    public static void End(IAsyncResult result);
    public sealed virtual void Signal();
    private void Timeout();
    private static void TimeoutCallback(object state);
    public sealed virtual CommunicationWaitResult Wait(TimeSpan timeout, bool aborting);
}
public abstract class System.ServiceModel.Channels.CommunicationObject : object {
    private bool _aborted;
    private bool _closeCalled;
    private object _mutex;
    private bool _onClosingCalled;
    private bool _onClosedCalled;
    private bool _onOpeningCalled;
    private bool _onOpenedCalled;
    private bool _raisedClosed;
    private bool _raisedClosing;
    private bool _raisedFaulted;
    private bool _traceOpenAndClose;
    private object _eventSender;
    private CommunicationState _state;
    internal bool _isSynchronousOpen;
    internal bool _isSynchronousClose;
    private bool _supportsAsyncOpenClose;
    private bool _supportsAsyncOpenCloseSet;
    [CompilerGeneratedAttribute]
private EventHandler Closed;
    [CompilerGeneratedAttribute]
private EventHandler Closing;
    [CompilerGeneratedAttribute]
private EventHandler Faulted;
    [CompilerGeneratedAttribute]
private EventHandler Opened;
    [CompilerGeneratedAttribute]
private EventHandler Opening;
    internal bool SupportsAsyncOpenClose { get; internal set; }
    internal bool Aborted { get; }
    internal object EventSender { get; internal set; }
    protected bool IsDisposed { get; }
    public CommunicationState State { get; }
    protected object ThisLock { get; }
    protected TimeSpan DefaultCloseTimeout { get; }
    protected TimeSpan DefaultOpenTimeout { get; }
    internal TimeSpan InternalCloseTimeout { get; }
    internal TimeSpan InternalOpenTimeout { get; }
    internal bool TraceOpenAndClose { get; internal set; }
    protected CommunicationObject(object mutex);
    internal bool get_SupportsAsyncOpenClose();
    internal void set_SupportsAsyncOpenClose(bool value);
    internal bool get_Aborted();
    internal object get_EventSender();
    internal void set_EventSender(object value);
    protected bool get_IsDisposed();
    public sealed virtual CommunicationState get_State();
    protected object get_ThisLock();
    protected abstract virtual TimeSpan get_DefaultCloseTimeout();
    protected abstract virtual TimeSpan get_DefaultOpenTimeout();
    internal TimeSpan get_InternalCloseTimeout();
    internal TimeSpan get_InternalOpenTimeout();
    [CompilerGeneratedAttribute]
public sealed virtual void add_Closed(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Closed(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_Closing(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Closing(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_Faulted(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Faulted(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_Opened(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Opened(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_Opening(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Opening(EventHandler value);
    public sealed virtual void Abort();
    public sealed virtual IAsyncResult BeginClose(AsyncCallback callback, object state);
    public sealed virtual IAsyncResult BeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual IAsyncResult BeginOpen(AsyncCallback callback, object state);
    public sealed virtual IAsyncResult BeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual void Close();
    public sealed virtual void Close(TimeSpan timeout);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.CommunicationObject/<CloseAsyncInternal>d__63")]
private Task CloseAsyncInternal(TimeSpan timeout);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.CommunicationObject/<System-ServiceModel-IAsyncCommunicationObject-CloseAsync>d__64")]
private sealed virtual override Task System.ServiceModel.IAsyncCommunicationObject.CloseAsync(TimeSpan timeout);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.CommunicationObject/<OnCloseAsyncInternal>d__65")]
private Task OnCloseAsyncInternal(TimeSpan timeout);
    private Exception CreateNotOpenException();
    private Exception CreateImmutableException();
    private Exception CreateBaseClassMethodNotCalledException(string method);
    internal Exception CreateClosedException();
    internal Exception CreateFaultedException();
    internal Exception CreateAbortedException();
    internal bool DoneReceivingInCurrentState();
    public sealed virtual void EndClose(IAsyncResult result);
    public sealed virtual void EndOpen(IAsyncResult result);
    protected void Fault();
    public sealed virtual void Open();
    public sealed virtual void Open(TimeSpan timeout);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.CommunicationObject/<OpenAsyncInternal>d__78")]
private Task OpenAsyncInternal(TimeSpan timeout);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.CommunicationObject/<System-ServiceModel-IAsyncCommunicationObject-OpenAsync>d__79")]
private sealed virtual override Task System.ServiceModel.IAsyncCommunicationObject.OpenAsync(TimeSpan timeout);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.CommunicationObject/<OnOpenAsyncInternal>d__80")]
private Task OnOpenAsyncInternal(TimeSpan timeout);
    protected virtual void OnClosed();
    protected virtual void OnClosing();
    protected virtual void OnFaulted();
    protected virtual void OnOpened();
    protected virtual void OnOpening();
    internal void ThrowIfFaulted();
    internal void ThrowIfAborted();
    internal bool get_TraceOpenAndClose();
    internal void set_TraceOpenAndClose(bool value);
    internal void ThrowIfClosed();
    protected virtual Type GetCommunicationObjectType();
    protected internal void ThrowIfDisposed();
    internal void ThrowIfClosedOrOpened();
    protected internal void ThrowIfDisposedOrImmutable();
    protected internal void ThrowIfDisposedOrNotOpen();
    internal void ThrowIfNotOpened();
    internal void ThrowIfClosedOrNotOpen();
    internal void ThrowPending();
    protected abstract virtual void OnAbort();
    protected abstract virtual void OnClose(TimeSpan timeout);
    protected abstract virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    protected abstract virtual void OnEndClose(IAsyncResult result);
    protected abstract virtual void OnOpen(TimeSpan timeout);
    protected abstract virtual IAsyncResult OnBeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    protected abstract virtual void OnEndOpen(IAsyncResult result);
    protected internal virtual Task OnCloseAsync(TimeSpan timeout);
    protected internal virtual Task OnOpenAsync(TimeSpan timeout);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.CommunicationObject/<OpenOtherAsync>d__109")]
internal Task OpenOtherAsync(ICommunicationObject other, TimeSpan timeout);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.CommunicationObject/<CloseOtherAsync>d__110")]
internal Task CloseOtherAsync(ICommunicationObject other, TimeSpan timeout);
}
[ExtensionAttribute]
public static class System.ServiceModel.Channels.CommunicationObjectInternal : object {
    public static void ThrowIfClosed(CommunicationObject communicationObject);
    public static void ThrowIfClosedOrOpened(CommunicationObject communicationObject);
    public static void ThrowIfDisposedOrNotOpen(CommunicationObject communicationObject);
    public static void ThrowIfDisposed(CommunicationObject communicationObject);
    [ExtensionAttribute]
public static TimeSpan GetInternalCloseTimeout(CommunicationObject communicationObject);
    public static void OnClose(CommunicationObject communicationObject, TimeSpan timeout);
    public static IAsyncResult OnBeginClose(CommunicationObject communicationObject, TimeSpan timeout, AsyncCallback callback, object state);
    public static void OnEnd(IAsyncResult result);
    public static void OnOpen(CommunicationObject communicationObject, TimeSpan timeout);
    public static IAsyncResult OnBeginOpen(CommunicationObject communicationObject, TimeSpan timeout, AsyncCallback callback, object state);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.CommunicationObjectInternal/<OnCloseAsyncInternal>d__10")]
public static Task OnCloseAsyncInternal(CommunicationObject communicationObject, TimeSpan timeout);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.CommunicationObjectInternal/<OnOpenAsyncInternal>d__11")]
public static Task OnOpenAsyncInternal(CommunicationObject communicationObject, TimeSpan timeout);
}
internal class System.ServiceModel.Channels.CommunicationObjectManager`1 : LifetimeManager {
    private bool _inputClosed;
    private HashSet`1<ItemType> _table;
    public CommunicationObjectManager`1(object mutex);
    public void Add(ItemType item);
    public void CloseInput();
    public void DecrementActivityCount();
    public void IncrementActivityCount();
    private void OnItemClosed(object sender, EventArgs args);
    public void Remove(ItemType item);
    public ItemType[] ToArray();
}
public abstract class System.ServiceModel.Channels.CommunicationPool`2 : object {
    private Dictionary`2<TKey, EndpointConnectionPool<TKey, TItem>> _endpointPools;
    private int _maxCount;
    private int _openCount;
    private int _pruneAccrual;
    private static int pruneThreshold;
    public int MaxIdleConnectionPoolCount { get; }
    protected object ThisLock { get; }
    protected CommunicationPool`2(int maxCount);
    public int get_MaxIdleConnectionPoolCount();
    protected object get_ThisLock();
    protected abstract virtual void AbortItem(TItem item);
    protected abstract virtual void CloseItem(TItem item, TimeSpan timeout);
    protected abstract virtual void CloseItemAsync(TItem item, TimeSpan timeout);
    protected abstract virtual TKey GetPoolKey(EndpointAddress address, Uri via);
    protected virtual EndpointConnectionPool<TKey, TItem> CreateEndpointConnectionPool(TKey key);
    public bool Close(TimeSpan timeout);
    private List`1<TItem> PruneIfNecessary();
    private EndpointConnectionPool<TKey, TItem> GetEndpointPool(TKey key, TimeSpan timeout);
    public bool TryOpen();
    protected virtual void OnClosed();
    private void OnClose(TimeSpan timeout);
    public void AddConnection(TKey key, TItem connection, TimeSpan timeout);
    public TItem TakeConnection(EndpointAddress address, Uri via, TimeSpan timeout, TKey& key);
    public void ReturnConnection(TKey key, TItem connection, bool connectionIsStillGood, TimeSpan timeout);
}
internal enum System.ServiceModel.Channels.CommunicationWaitResult : Enum {
    public int value__;
    public static CommunicationWaitResult Waiting;
    public static CommunicationWaitResult Succeeded;
    public static CommunicationWaitResult Expired;
    public static CommunicationWaitResult Aborted;
}
public enum System.ServiceModel.Channels.CompressionFormat : Enum {
    public int value__;
    public static CompressionFormat None;
    public static CompressionFormat GZip;
    public static CompressionFormat Deflate;
}
internal class System.ServiceModel.Channels.ConnectionBufferPool : QueuedObjectPool`1<Byte[]> {
    private static int SingleBatchSize;
    private static int MaxBatchCount;
    private static int MaxFreeCountFactor;
    private int _bufferSize;
    public int BufferSize { get; }
    public ConnectionBufferPool(int bufferSize);
    public ConnectionBufferPool(int bufferSize, int maxFreeCount);
    private void Initialize(int bufferSize, int batchCount, int maxFreeCount);
    public int get_BufferSize();
    protected virtual Byte[] Create();
    private static int ComputeBatchCount(int bufferSize);
}
[ExtensionAttribute]
internal static class System.ServiceModel.Channels.ConnectionHelpers.IConnectionExtensions : object {
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.ConnectionHelpers.IConnectionExtensions/<WriteAsync>d__0")]
[ExtensionAttribute]
internal static Task WriteAsync(IConnection connection, Byte[] buffer, int offset, int size, bool immediate, TimeSpan timeout);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.ConnectionHelpers.IConnectionExtensions/<ReadAsync>d__1")]
[ExtensionAttribute]
internal static Task`1<int> ReadAsync(IConnection connection, int offset, int size, TimeSpan timeout);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.ConnectionHelpers.IConnectionExtensions/<ReadAsync>d__2")]
[ExtensionAttribute]
internal static Task`1<int> ReadAsync(IConnection connection, Byte[] buffer, int offset, int size, TimeSpan timeout);
    private static void OnIoComplete(object state);
}
internal class System.ServiceModel.Channels.ConnectionMessageProperty : object {
    private IConnection _connection;
    public static string Name { get; }
    public IConnection Connection { get; }
    public ConnectionMessageProperty(IConnection connection);
    public static string get_Name();
    public IConnection get_Connection();
}
public abstract class System.ServiceModel.Channels.ConnectionOrientedTransportBindingElement : TransportBindingElement {
    private int _connectionBufferSize;
    private bool _exposeConnectionProperty;
    private TimeSpan _maxOutputDelay;
    private int _maxBufferSize;
    private bool _maxBufferSizeInitialized;
    private TransferMode _transferMode;
    [DefaultValueAttribute("8192")]
public int ConnectionBufferSize { get; public set; }
    internal bool ExposeConnectionProperty { get; internal set; }
    [DefaultValueAttribute("65536")]
public int MaxBufferSize { get; public set; }
    internal TimeSpan MaxOutputDelay { get; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public TransferMode TransferMode { get; public set; }
    internal ConnectionOrientedTransportBindingElement(ConnectionOrientedTransportBindingElement elementToBeCloned);
    public int get_ConnectionBufferSize();
    public void set_ConnectionBufferSize(int value);
    internal bool get_ExposeConnectionProperty();
    internal void set_ExposeConnectionProperty(bool value);
    public int get_MaxBufferSize();
    public void set_MaxBufferSize(int value);
    internal TimeSpan get_MaxOutputDelay();
    public TransferMode get_TransferMode();
    public void set_TransferMode(TransferMode value);
    public virtual bool CanBuildChannelFactory(BindingContext context);
    public virtual T GetProperty(BindingContext context);
    internal virtual bool IsMatch(BindingElement b);
    private MessageEncodingBindingElement FindMessageEncodingBindingElement(BindingElementCollection bindingElements, Boolean& createdNew);
}
internal abstract class System.ServiceModel.Channels.ConnectionOrientedTransportChannelFactory`1 : TransportChannelFactory`1<TChannel> {
    private int _connectionBufferSize;
    private IConnectionInitiator _connectionInitiator;
    private ConnectionPool _connectionPool;
    private string _connectionPoolGroupName;
    private bool _exposeConnectionProperty;
    private TimeSpan _idleTimeout;
    private int _maxBufferSize;
    private int _maxOutboundConnectionsPerEndpoint;
    private TimeSpan _maxOutputDelay;
    private TransferMode _transferMode;
    private ISecurityCapabilities _securityCapabilities;
    private StreamUpgradeProvider _upgrade;
    private bool _flowIdentity;
    public int ConnectionBufferSize { get; }
    internal IConnectionInitiator ConnectionInitiator { get; }
    public string ConnectionPoolGroupName { get; }
    public TimeSpan IdleTimeout { get; }
    public int MaxBufferSize { get; }
    public int MaxOutboundConnectionsPerEndpoint { get; }
    public TimeSpan MaxOutputDelay { get; }
    public StreamUpgradeProvider Upgrade { get; }
    public TransferMode TransferMode { get; }
    private int System.ServiceModel.Channels.IConnectionOrientedTransportFactorySettings.MaxBufferSize { get; }
    private TransferMode System.ServiceModel.Channels.IConnectionOrientedTransportFactorySettings.TransferMode { get; }
    private StreamUpgradeProvider System.ServiceModel.Channels.IConnectionOrientedTransportFactorySettings.Upgrade { get; }
    internal ConnectionOrientedTransportChannelFactory`1(ConnectionOrientedTransportBindingElement bindingElement, BindingContext context, string connectionPoolGroupName, TimeSpan idleTimeout, int maxOutboundConnectionsPerEndpoint, bool supportsImpersonationDuringAsyncOpen);
    public sealed virtual int get_ConnectionBufferSize();
    internal IConnectionInitiator get_ConnectionInitiator();
    public sealed virtual string get_ConnectionPoolGroupName();
    public sealed virtual TimeSpan get_IdleTimeout();
    public int get_MaxBufferSize();
    public sealed virtual int get_MaxOutboundConnectionsPerEndpoint();
    public sealed virtual TimeSpan get_MaxOutputDelay();
    public StreamUpgradeProvider get_Upgrade();
    public TransferMode get_TransferMode();
    private sealed virtual override int System.ServiceModel.Channels.IConnectionOrientedTransportFactorySettings.get_MaxBufferSize();
    private sealed virtual override TransferMode System.ServiceModel.Channels.IConnectionOrientedTransportFactorySettings.get_TransferMode();
    private sealed virtual override StreamUpgradeProvider System.ServiceModel.Channels.IConnectionOrientedTransportFactorySettings.get_Upgrade();
    public virtual T GetProperty();
    public virtual int GetMaxBufferSize();
    internal abstract virtual IConnectionInitiator GetConnectionInitiator();
    internal abstract virtual ConnectionPool GetConnectionPool();
    internal abstract virtual void ReleaseConnectionPool(ConnectionPool pool, TimeSpan timeout);
    protected virtual TChannel OnCreateChannel(EndpointAddress address, Uri via);
    private bool GetUpgradeAndConnectionPool(StreamUpgradeProvider& upgradeCopy, ConnectionPool& poolCopy);
    protected virtual void OnAbort();
    protected virtual void OnClose(TimeSpan timeout);
    protected virtual void OnOpening();
    protected virtual IAsyncResult OnBeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndOpen(IAsyncResult result);
    protected virtual void OnOpen(TimeSpan timeout);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.ConnectionOrientedTransportChannelFactory`1/<OnOpenAsync>d__51")]
protected internal virtual Task OnOpenAsync(TimeSpan timeout);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.ConnectionOrientedTransportChannelFactory`1/<OnCloseAsync>d__52")]
protected internal virtual Task OnCloseAsync(TimeSpan timeout);
    protected virtual bool SupportsUpgrade(StreamUpgradeBindingElement upgradeBindingElement);
}
public static class System.ServiceModel.Channels.ConnectionOrientedTransportDefaults : object {
    public static bool AllowNtlm;
    public static int ConnectionBufferSize;
    public static string ConnectionPoolGroupName;
    public static HostNameComparisonMode HostNameComparisonMode;
    public static string IdleTimeoutString;
    public static string ChannelInitializationTimeoutString;
    public static int MaxContentTypeSize;
    public static int MaxOutboundConnectionsPerEndpoint;
    public static int MaxPendingConnectionsConst;
    public static string MaxOutputDelayString;
    public static int MaxPendingAcceptsConst;
    public static int MaxViaSize;
    public static ProtectionLevel ProtectionLevel;
    public static TransferMode TransferMode;
    public static TimeSpan IdleTimeout { get; }
    public static TimeSpan ChannelInitializationTimeout { get; }
    public static TimeSpan MaxOutputDelay { get; }
    public static TimeSpan get_IdleTimeout();
    public static TimeSpan get_ChannelInitializationTimeout();
    public static TimeSpan get_MaxOutputDelay();
    public static int GetMaxConnections();
    public static int GetMaxPendingConnections();
    public static int GetMaxPendingAccepts();
}
public abstract class System.ServiceModel.Channels.ConnectionPool : IdlingCommunicationPool`2<string, IConnection> {
    private int _connectionBufferSize;
    private TimeSpan _maxOutputDelay;
    private string _name;
    public string Name { get; }
    protected ConnectionPool(IConnectionOrientedTransportChannelFactorySettings settings, TimeSpan leaseTimeout);
    public string get_Name();
    protected virtual void AbortItem(IConnection item);
    protected virtual void CloseItem(IConnection item, TimeSpan timeout);
    protected virtual void CloseItemAsync(IConnection item, TimeSpan timeout);
    public virtual bool IsCompatible(IConnectionOrientedTransportChannelFactorySettings settings);
}
internal abstract class System.ServiceModel.Channels.ConnectionPoolHelper : object {
    private IConnectionInitiator _connectionInitiator;
    private ConnectionPool _connectionPool;
    private Uri _via;
    private bool _closed;
    private string _connectionKey;
    private bool _isConnectionFromPool;
    private IConnection _rawConnection;
    private IConnection _upgradedConnection;
    private object ThisLock { get; }
    public ConnectionPoolHelper(ConnectionPool connectionPool, IConnectionInitiator connectionInitiator, Uri via);
    private object get_ThisLock();
    protected abstract virtual IConnection AcceptPooledConnection(IConnection connection, TimeoutHelper& timeoutHelper);
    protected abstract virtual Task`1<IConnection> AcceptPooledConnectionAsync(IConnection connection, TimeoutHelper& timeoutHelper);
    protected abstract virtual TimeoutException CreateNewConnectionTimeoutException(TimeSpan timeout, TimeoutException innerException);
    private IConnection TakeConnection(TimeSpan timeout);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.ConnectionPoolHelper/<EstablishConnectionAsync>d__15")]
public Task`1<IConnection> EstablishConnectionAsync(TimeSpan timeout);
    public IConnection EstablishConnection(TimeSpan timeout);
    private void SnapshotConnection(IConnection upgradedConnection, IConnection rawConnection, bool isConnectionFromPool);
    public void Abort();
    public void Close(TimeSpan timeout);
    private void ReleaseConnection(bool abort, TimeSpan timeout);
}
public abstract class System.ServiceModel.Channels.ConnectionPoolRegistry : object {
    private Dictionary`2<string, List`1<ConnectionPool>> _registry;
    private object ThisLock { get; }
    private object get_ThisLock();
    public ConnectionPool Lookup(IConnectionOrientedTransportChannelFactorySettings settings);
    protected abstract virtual ConnectionPool CreatePool(IConnectionOrientedTransportChannelFactorySettings settings);
    public void Release(ConnectionPool pool, TimeSpan timeout);
}
internal class System.ServiceModel.Channels.ConnectionStream : Stream {
    private TimeSpan _closeTimeout;
    private int _readTimeout;
    private int _writeTimeout;
    private IConnection _connection;
    private bool _immediate;
    private static Action`1<object> s_onWriteComplete;
    private static Action`1<object> s_onReadComplete;
    public IConnection Connection { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanTimeout { get; }
    public bool CanWrite { get; }
    public TimeSpan CloseTimeout { get; public set; }
    public int ReadTimeout { get; public set; }
    public int WriteTimeout { get; public set; }
    public bool Immediate { get; public set; }
    public long Length { get; }
    public long Position { get; public set; }
    public ConnectionStream(IConnection connection, IDefaultCommunicationTimeouts defaultTimeouts);
    private static ConnectionStream();
    public IConnection get_Connection();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanTimeout();
    public virtual bool get_CanWrite();
    public TimeSpan get_CloseTimeout();
    public void set_CloseTimeout(TimeSpan value);
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
    public bool get_Immediate();
    public void set_Immediate(bool value);
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public void Abort();
    protected virtual void Dispose(bool disposing);
    public virtual void Flush();
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    private static void OnWriteComplete(object state);
    public virtual void Write(Byte[] buffer, int offset, int count);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.ConnectionStream/<ReadAsync>d__41")]
public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    private static void OnReadComplete(object state);
    public virtual int Read(Byte[] buffer, int offset, int count);
    protected int Read(Byte[] buffer, int offset, int count, TimeSpan timeout);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
}
internal class System.ServiceModel.Channels.ConnectionUpgradeHelper : object {
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.ConnectionUpgradeHelper/<DecodeFramingFaultAsync>d__0")]
public static Task DecodeFramingFaultAsync(ClientFramingDecoder decoder, IConnection connection, Uri via, string contentType, TimeSpan timeout);
    public static void DecodeFramingFault(ClientFramingDecoder decoder, IConnection connection, Uri via, string contentType, TimeoutHelper& timeoutHelper);
    public static bool InitiateUpgrade(StreamUpgradeInitiator upgradeInitiator, IConnection& connection, ClientFramingDecoder decoder, IDefaultCommunicationTimeouts defaultTimeouts, TimeoutHelper& timeoutHelper);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.ConnectionUpgradeHelper/<InitiateUpgradeAsync>d__3")]
public static Task`1<bool> InitiateUpgradeAsync(StreamUpgradeInitiator upgradeInitiator, OutWrapper`1<IConnection> connectionWrapper, ClientFramingDecoder decoder, IDefaultCommunicationTimeouts defaultTimeouts, TimeSpan timeout);
    private static void ValidateReadingFaultString(ClientFramingDecoder decoder);
    public static bool ValidatePreambleResponse(Byte[] buffer, int count, ClientFramingDecoder decoder, Uri via);
    private static bool ValidateUpgradeResponse(Byte[] buffer, int count, ClientFramingDecoder decoder);
}
internal static class System.ServiceModel.Channels.ConnectionUtilities : object {
    internal static void CloseNoThrow(IConnection connection, TimeSpan timeout);
    internal static void ValidateBufferBounds(ArraySegment`1<byte> buffer);
    internal static void ValidateBufferBounds(Byte[] buffer, int offset, int size);
    internal static void ValidateBufferBounds(int bufferSize, int offset, int size);
}
internal abstract class System.ServiceModel.Channels.ContentOnlyMessage : Message {
    private MessageHeaders _headers;
    private MessageProperties _properties;
    public MessageHeaders Headers { get; }
    public MessageProperties Properties { get; }
    public MessageVersion Version { get; }
    public virtual MessageHeaders get_Headers();
    public virtual MessageProperties get_Properties();
    public virtual MessageVersion get_Version();
    protected virtual void OnBodyToString(XmlDictionaryWriter writer);
}
internal class System.ServiceModel.Channels.ContentTypeStringDecoder : StringDecoder {
    public ContentTypeStringDecoder(int sizeQuota);
    protected virtual Exception OnSizeQuotaExceeded(int size);
    public static string GetString(FramingEncodingType type);
}
internal class System.ServiceModel.Channels.CoreClrClientWebSocketFactory : ClientWebSocketFactory {
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.CoreClrClientWebSocketFactory/<CreateWebSocketAsync>d__0")]
public virtual Task`1<WebSocket> CreateWebSocketAsync(Uri address, WebHeaderCollection headers, ICredentials credentials, WebSocketTransportSettings settings, TimeoutHelper timeoutHelper);
}
internal class System.ServiceModel.Channels.CoreClrSocketConnection : SocketConnection {
    private static EventHandler`1<SocketAsyncEventArgs> s_onReceiveAsyncCompleted;
    private static EventHandler`1<SocketAsyncEventArgs> s_onSocketSendCompleted;
    private Socket _socket;
    private bool _noDelay;
    private static Action`1<object> s_onWaitForFinComplete;
    private SocketAsyncEventArgs _asyncReadEventArgs;
    private TimeSpan _readFinTimeout;
    private SocketAsyncEventArgs _asyncWriteEventArgs;
    private IOTimer`1<SocketConnection> _receiveTimer;
    private static Action`1<SocketConnection> s_onReceiveTimeout;
    private IOTimer`1<SocketConnection> _sendTimer;
    private static Action`1<SocketConnection> s_onSendTimeout;
    private IOTimer`1<SocketConnection> SendTimer { get; }
    private IOTimer`1<SocketConnection> ReceiveTimer { get; }
    protected IPEndPoint RemoteEndPoint { get; }
    public CoreClrSocketConnection(Socket socket, ConnectionBufferPool connectionBufferPool);
    private static CoreClrSocketConnection();
    private IOTimer`1<SocketConnection> get_SendTimer();
    private IOTimer`1<SocketConnection> get_ReceiveTimer();
    protected virtual IPEndPoint get_RemoteEndPoint();
    private static void OnReceiveAsyncCompleted(object sender, SocketAsyncEventArgs e);
    private static void OnSendAsyncCompleted(object sender, SocketAsyncEventArgs e);
    private static void OnWaitForFinComplete(object state);
    protected virtual void Abort(int traceEventType, string timeoutErrorString, TransferOperation transferOperation);
    protected virtual void AbortRead();
    private void CancelReceiveTimer();
    private void CancelSendTimer();
    private void CloseAsyncAndLinger();
    protected virtual void CloseCore(bool asyncAndLinger);
    private void CloseSync();
    private void ContinueClose(TimeSpan timeout);
    protected virtual void ShutdownCore(TimeSpan timeout);
    protected virtual AsyncCompletionResult BeginWriteCore(Byte[] buffer, int offset, int size, bool immediate, TimeSpan timeout, Action`1<object> callback, object state);
    protected virtual void EndWriteCore();
    private void OnSendAsync(object sender, SocketAsyncEventArgs eventArgs);
    private void HandleSendAsyncCompleted();
    private void DisposeWriteEventArgs();
    private void DisposeSendTimer();
    private void AbortWrite();
    protected virtual void WriteCore(Byte[] buffer, int offset, int size, bool immediate, TimeSpan timeout);
    protected virtual void TraceWriteStart(int size, bool async);
    protected virtual int ReadCore(Byte[] buffer, int offset, int size, TimeSpan timeout, bool closing);
    protected virtual void TraceSocketReadStop(int bytesRead, bool async);
    protected virtual AsyncCompletionResult BeginReadCore(int offset, int size, TimeSpan timeout, Action`1<object> callback, object state);
    private bool ReceiveAsync();
    private void OnReceiveAsync(object sender, SocketAsyncEventArgs eventArgs);
    private void HandleReceiveAsyncCompleted();
    protected virtual int EndReadCore();
    private void DisposeReadEventArgs();
    private void DisposeReceiveTimer();
    private void SetUserToken(SocketAsyncEventArgs args, object userToken);
    private void SetImmediate(bool immediate);
    private void SetReadTimeout(TimeSpan timeout, bool synchronous, bool closing);
    private void SetWriteTimeout(TimeSpan timeout, bool synchronous);
    private bool UpdateTimeout(TimeSpan oldTimeout, TimeSpan newTimeout);
    private void EnsureReadEventArgs();
    private void EnsureWriteEventArgs();
    public virtual object GetCoreTransport();
}
internal class System.ServiceModel.Channels.CoreClrSocketConnectionInitiator : SocketConnectionInitiator {
    public CoreClrSocketConnectionInitiator(int bufferSize);
    protected virtual IConnection CreateConnection(IPAddress address, int port);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.CoreClrSocketConnectionInitiator/<CreateConnectionAsync>d__2")]
protected virtual Task`1<IConnection> CreateConnectionAsync(IPAddress address, int port);
}
public class System.ServiceModel.Channels.CustomBinding : Binding {
    private BindingElementCollection _bindingElements;
    public BindingElementCollection Elements { get; }
    public string Scheme { get; }
    public CustomBinding(BindingElement[] bindingElementsInTopDownChannelStackOrder);
    public CustomBinding(string name, string ns, BindingElement[] bindingElementsInTopDownChannelStackOrder);
    public CustomBinding(IEnumerable`1<BindingElement> bindingElementsInTopDownChannelStackOrder);
    internal CustomBinding(BindingElementCollection bindingElements);
    public CustomBinding(Binding binding);
    internal CustomBinding(Binding binding, BindingElementCollection elements);
    private static BindingElementCollection SafeCreateBindingElements(Binding binding);
    public BindingElementCollection get_Elements();
    public virtual BindingElementCollection CreateBindingElements();
    public virtual string get_Scheme();
}
internal static class System.ServiceModel.Channels.DecoderHelper : object {
    public static void ValidateSize(int size);
}
internal class System.ServiceModel.Channels.DefaultMessageBuffer : MessageBuffer {
    private XmlBuffer _msgBuffer;
    private KeyValuePair`2[] _properties;
    private Boolean[] _understoodHeaders;
    private bool _closed;
    private MessageVersion _version;
    private Uri _to;
    private string _action;
    private bool _isNullMessage;
    private object ThisLock { get; }
    public int BufferSize { get; }
    public DefaultMessageBuffer(Message message, XmlBuffer msgBuffer);
    private object get_ThisLock();
    public virtual int get_BufferSize();
    public virtual void Close();
    public virtual Message CreateMessage();
}
internal abstract class System.ServiceModel.Channels.DelegatingConnection : object {
    private IConnection _connection;
    public Byte[] AsyncReadBuffer { get; }
    public int AsyncReadBufferSize { get; }
    protected IConnection Connection { get; }
    protected DelegatingConnection(IConnection connection);
    public virtual Byte[] get_AsyncReadBuffer();
    public virtual int get_AsyncReadBufferSize();
    protected IConnection get_Connection();
    public virtual void Abort();
    public virtual void Close(TimeSpan timeout, bool asyncAndLinger);
    public virtual AsyncCompletionResult BeginWrite(Byte[] buffer, int offset, int size, bool immediate, TimeSpan timeout, Action`1<object> callback, object state);
    public virtual void EndWrite();
    public virtual void Write(Byte[] buffer, int offset, int size, bool immediate, TimeSpan timeout);
    public virtual void Write(Byte[] buffer, int offset, int size, bool immediate, TimeSpan timeout, BufferManager bufferManager);
    public virtual int Read(Byte[] buffer, int offset, int size, TimeSpan timeout);
    public virtual AsyncCompletionResult BeginRead(int offset, int size, TimeSpan timeout, Action`1<object> callback, object state);
    public virtual int EndRead();
    public virtual object GetCoreTransport();
}
public abstract class System.ServiceModel.Channels.DelegatingStream : Stream {
    private Stream _stream;
    private bool _disposed;
    protected Stream BaseStream { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanTimeout { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public int ReadTimeout { get; public set; }
    public int WriteTimeout { get; public set; }
    protected DelegatingStream(Stream stream);
    protected Stream get_BaseStream();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanTimeout();
    public virtual bool get_CanWrite();
    protected virtual void Dispose(bool disposing);
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
    public virtual Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual int ReadByte();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual void WriteByte(byte value);
}
internal abstract class System.ServiceModel.Channels.DetectEofStream : DelegatingStream {
    private bool _isAtEof;
    protected bool IsAtEof { get; }
    protected DetectEofStream(Stream stream);
    protected bool get_IsAtEof();
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.DetectEofStream/<ReadAsync>d__4")]
public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual int ReadByte();
    public virtual int Read(Byte[] buffer, int offset, int count);
    private void ReceivedEof();
    protected virtual void OnReceivedEof();
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<int> <>n__0(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
}
internal abstract class System.ServiceModel.Channels.DictionaryHeader : MessageHeader {
    public string Name { get; }
    public string Namespace { get; }
    public XmlDictionaryString DictionaryName { get; }
    public XmlDictionaryString DictionaryNamespace { get; }
    public virtual string get_Name();
    public virtual string get_Namespace();
    public abstract virtual XmlDictionaryString get_DictionaryName();
    public abstract virtual XmlDictionaryString get_DictionaryNamespace();
    protected virtual void OnWriteStartHeader(XmlDictionaryWriter writer, MessageVersion messageVersion);
}
internal static class System.ServiceModel.Channels.DnsCache : object {
    private static int mruWatermark;
    private static MruCache`2<string, DnsCacheEntry> s_resolveCache;
    private static TimeSpan s_cacheTimeout;
    private static String modreq(System.Runtime.CompilerServices.IsVolatile) s_machineName;
    private static object ThisLock { get; }
    public static string MachineName { get; }
    private static DnsCache();
    private static object get_ThisLock();
    public static string get_MachineName();
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.DnsCache/<ResolveAsync>d__8")]
public static Task`1<IPAddress[]> ResolveAsync(Uri uri);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.DnsCache/<LookupHostName>d__9")]
internal static Task`1<IPAddress[]> LookupHostName(string hostName);
}
internal class System.ServiceModel.Channels.EmptyBodyWriter : BodyWriter {
    private static EmptyBodyWriter s_value;
    public static EmptyBodyWriter Value { get; }
    internal bool IsEmpty { get; }
    public static EmptyBodyWriter get_Value();
    internal virtual bool get_IsEmpty();
    protected virtual void OnWriteBodyContents(XmlDictionaryWriter writer);
}
internal class System.ServiceModel.Channels.EncodedContentType : EncodedFramingRecord {
    private EncodedContentType(FramingEncodingType encodingType);
    private EncodedContentType(string contentType);
    public static EncodedContentType Create(string contentType);
}
internal class System.ServiceModel.Channels.EncodedFault : EncodedFramingRecord {
    public EncodedFault(string fault);
}
internal abstract class System.ServiceModel.Channels.EncodedFramingRecord : object {
    private Byte[] _encodedBytes;
    public Byte[] EncodedBytes { get; }
    protected EncodedFramingRecord(Byte[] encodedBytes);
    internal EncodedFramingRecord(FramingRecordType recordType, string value);
    public Byte[] get_EncodedBytes();
    protected void SetEncodedBytes(Byte[] encodedBytes);
    public virtual int GetHashCode();
    public virtual bool Equals(object o);
    public bool Equals(EncodedFramingRecord other);
}
internal class System.ServiceModel.Channels.EncodedUpgrade : EncodedFramingRecord {
    public EncodedUpgrade(string contentType);
}
internal class System.ServiceModel.Channels.EncodedVia : EncodedFramingRecord {
    public EncodedVia(string via);
}
public static class System.ServiceModel.Channels.EncoderDefaults : object {
    public static int MaxReadPoolSize;
    public static int MaxWritePoolSize;
    public static int MaxDepth;
    public static int MaxStringContentLength;
    public static int MaxArrayLength;
    public static int MaxBytesPerRead;
    public static int MaxNameTableCharCount;
    public static int BufferedReadDefaultMaxDepth;
    public static int BufferedReadDefaultMaxStringContentLength;
    public static int BufferedReadDefaultMaxArrayLength;
    public static int BufferedReadDefaultMaxBytesPerRead;
    public static int BufferedReadDefaultMaxNameTableCharCount;
    public static CompressionFormat DefaultCompressionFormat;
    public static XmlDictionaryReaderQuotas ReaderQuotas;
    private static EncoderDefaults();
    public static bool IsDefaultReaderQuotas(XmlDictionaryReaderQuotas quotas);
}
internal static class System.ServiceModel.Channels.EncoderHelpers : object {
    internal static XmlDictionaryReaderQuotas GetBufferedReadQuotas(XmlDictionaryReaderQuotas encoderQuotas);
    private static bool IsDefaultQuota(XmlDictionaryReaderQuotas quotas, XmlDictionaryReaderQuotaTypes quotaType);
}
internal class System.ServiceModel.Channels.FaultBodyWriter : BodyWriter {
    private MessageFault _fault;
    private EnvelopeVersion _version;
    internal bool IsFault { get; }
    public FaultBodyWriter(MessageFault fault, EnvelopeVersion version);
    internal virtual bool get_IsFault();
    protected virtual void OnWriteBodyContents(XmlDictionaryWriter writer);
}
public abstract class System.ServiceModel.Channels.FaultConverter : object {
    public static FaultConverter GetDefaultFaultConverter(MessageVersion version);
    protected abstract virtual bool OnTryCreateException(Message message, MessageFault fault, Exception& exception);
    protected abstract virtual bool OnTryCreateFaultMessage(Exception exception, Message& message);
    public bool TryCreateException(Message message, MessageFault fault, Exception& exception);
    public bool TryCreateFaultMessage(Exception exception, Message& message);
}
internal class System.ServiceModel.Channels.FaultStringDecoder : StringDecoder {
    internal static int FaultSizeQuota;
    protected virtual Exception OnSizeQuotaExceeded(int size);
    public static Exception GetFaultException(string faultString, string via, string contentType);
}
internal class System.ServiceModel.Channels.FaultToHeader : AddressingHeader {
    private EndpointAddress _faultTo;
    private static bool mustUnderstandValue;
    public EndpointAddress FaultTo { get; }
    public XmlDictionaryString DictionaryName { get; }
    public bool MustUnderstand { get; }
    private FaultToHeader(EndpointAddress faultTo, AddressingVersion version);
    public EndpointAddress get_FaultTo();
    public virtual XmlDictionaryString get_DictionaryName();
    public virtual bool get_MustUnderstand();
    protected virtual void OnWriteHeaderContents(XmlDictionaryWriter writer, MessageVersion messageVersion);
    public static FaultToHeader Create(EndpointAddress faultTo, AddressingVersion addressingVersion);
    public static FaultToHeader ReadHeader(XmlDictionaryReader reader, AddressingVersion version, string actor, bool mustUnderstand, bool relay);
    public static EndpointAddress ReadHeaderValue(XmlDictionaryReader reader, AddressingVersion version);
}
internal abstract class System.ServiceModel.Channels.FramingDecoder : object {
    private long _streamPosition;
    protected string CurrentStateAsString { get; }
    public long StreamPosition { get; public set; }
    protected FramingDecoder(long streamPosition);
    protected abstract virtual string get_CurrentStateAsString();
    public long get_StreamPosition();
    public void set_StreamPosition(long value);
    protected void ValidateFramingMode(FramingMode mode);
    protected void ValidateRecordType(FramingRecordType expectedType, FramingRecordType foundType);
    protected void ValidatePreambleAck(FramingRecordType foundType);
    private Exception CreateInvalidRecordTypeException(FramingRecordType expectedType, FramingRecordType foundType);
    protected void ValidateMajorVersion(int majorVersion);
    public Exception CreatePrematureEOFException();
    protected Exception CreateException(InvalidDataException innerException, string framingFault);
    protected Exception CreateException(InvalidDataException innerException);
}
internal abstract class System.ServiceModel.Channels.FramingDuplexSessionChannel : TransportDuplexSessionChannel {
    private static EndpointAddress s_anonymousEndpointAddress;
    private IConnection _connection;
    private bool _exposeConnectionProperty;
    protected IConnection Connection { get; protected set; }
    protected bool IsStreamedOutput { get; }
    private FramingDuplexSessionChannel(ChannelManagerBase manager, IConnectionOrientedTransportFactorySettings settings, EndpointAddress localAddress, Uri localVia, EndpointAddress remoteAddresss, Uri via, bool exposeConnectionProperty);
    protected FramingDuplexSessionChannel(ChannelManagerBase factory, IConnectionOrientedTransportFactorySettings settings, EndpointAddress remoteAddresss, Uri via, bool exposeConnectionProperty);
    private static FramingDuplexSessionChannel();
    protected IConnection get_Connection();
    protected void set_Connection(IConnection value);
    protected virtual bool get_IsStreamedOutput();
    protected virtual void CloseOutputSessionCore(TimeSpan timeout);
    protected virtual Task CloseOutputSessionCoreAsync(TimeSpan timeout);
    protected virtual void CompleteClose(TimeSpan timeout);
    protected virtual void PrepareMessage(Message message);
    protected virtual void OnSendCore(Message message, TimeSpan timeout);
    protected virtual AsyncCompletionResult BeginCloseOutput(TimeSpan timeout, Action`1<object> callback, object state);
    protected virtual void FinishWritingMessage();
    protected virtual AsyncCompletionResult StartWritingBufferedMessage(Message message, ArraySegment`1<byte> messageData, bool allowOutputBatching, TimeSpan timeout, Action`1<object> callback, object state);
    protected virtual AsyncCompletionResult StartWritingStreamedMessage(Message message, TimeSpan timeout, Action`1<object> callback, object state);
    protected virtual ArraySegment`1<byte> EncodeMessage(Message message);
}
internal static class System.ServiceModel.Channels.FramingEncodingString : object {
    public static string Soap11Utf8;
    public static string Soap11Utf16;
    public static string Soap11Utf16FFFE;
    public static string Soap12Utf8;
    public static string Soap12Utf16;
    public static string Soap12Utf16FFFE;
    public static string MTOM;
    public static string Binary;
    public static string BinarySession;
    public static string ExtendedBinaryGZip;
    public static string ExtendedBinarySessionGZip;
    public static string ExtendedBinaryDeflate;
    public static string ExtendedBinarySessionDeflate;
    public static string NamespaceUri;
    private static string FaultBaseUri;
    public static string ContentTypeInvalidFault;
    public static string ContentTypeTooLongFault;
    public static string ConnectionDispatchFailedFault;
    public static string EndpointNotFoundFault;
    public static string EndpointUnavailableFault;
    public static string MaxMessageSizeExceededFault;
    public static string ServerTooBusyFault;
    public static string ServiceActivationFailedFault;
    public static string UnsupportedModeFault;
    public static string UnsupportedVersionFault;
    public static string UpgradeInvalidFault;
    public static string ViaTooLongFault;
    private static string ExceptionKey;
    public static bool TryGetFaultString(Exception exception, String& framingFault);
    public static void AddFaultString(Exception exception, string framingFault);
}
internal enum System.ServiceModel.Channels.FramingEncodingType : Enum {
    public int value__;
    public static FramingEncodingType Soap11Utf8;
    public static FramingEncodingType Soap11Utf16;
    public static FramingEncodingType Soap11Utf16FFFE;
    public static FramingEncodingType Soap12Utf8;
    public static FramingEncodingType Soap12Utf16;
    public static FramingEncodingType Soap12Utf16FFFE;
    public static FramingEncodingType MTOM;
    public static FramingEncodingType Binary;
    public static FramingEncodingType BinarySession;
}
internal enum System.ServiceModel.Channels.FramingMode : Enum {
    public int value__;
    public static FramingMode Singleton;
    public static FramingMode Duplex;
    public static FramingMode Simplex;
    public static FramingMode SingletonSized;
}
internal enum System.ServiceModel.Channels.FramingRecordType : Enum {
    public int value__;
    public static FramingRecordType Version;
    public static FramingRecordType Mode;
    public static FramingRecordType Via;
    public static FramingRecordType KnownEncoding;
    public static FramingRecordType ExtensibleEncoding;
    public static FramingRecordType UnsizedEnvelope;
    public static FramingRecordType SizedEnvelope;
    public static FramingRecordType End;
    public static FramingRecordType Fault;
    public static FramingRecordType UpgradeRequest;
    public static FramingRecordType UpgradeResponse;
    public static FramingRecordType PreambleAck;
    public static FramingRecordType PreambleEnd;
}
internal static class System.ServiceModel.Channels.FramingUpgradeString : object {
    public static string SslOrTls;
    public static string Negotiate;
}
internal static class System.ServiceModel.Channels.FramingVersion : object {
    public static int Major;
    public static int Minor;
}
internal class System.ServiceModel.Channels.FromHeader : AddressingHeader {
    private EndpointAddress _from;
    private static bool mustUnderstandValue;
    public EndpointAddress From { get; }
    public XmlDictionaryString DictionaryName { get; }
    public bool MustUnderstand { get; }
    private FromHeader(EndpointAddress from, AddressingVersion version);
    public EndpointAddress get_From();
    public virtual XmlDictionaryString get_DictionaryName();
    public virtual bool get_MustUnderstand();
    public static FromHeader Create(EndpointAddress from, AddressingVersion addressingVersion);
    protected virtual void OnWriteHeaderContents(XmlDictionaryWriter writer, MessageVersion messageVersion);
    public static FromHeader ReadHeader(XmlDictionaryReader reader, AddressingVersion version, string actor, bool mustUnderstand, bool relay);
    public static EndpointAddress ReadHeaderValue(XmlDictionaryReader reader, AddressingVersion addressingVersion);
}
internal class System.ServiceModel.Channels.HeaderInfoCache : object {
    private static int maxHeaderInfos;
    private HeaderInfo[] _headerInfos;
    private int _index;
    public MessageHeaderInfo TakeHeaderInfo(XmlDictionaryReader reader, string actor, bool mustUnderstand, bool relay, bool isRefParam);
    public void ReturnHeaderInfo(MessageHeaderInfo headerInfo);
}
internal enum System.ServiceModel.Channels.HttpAbortReason : Enum {
    public int value__;
    public static HttpAbortReason None;
    public static HttpAbortReason Aborted;
    public static HttpAbortReason TimedOut;
}
internal class System.ServiceModel.Channels.HttpChannelFactory`1 : TransportChannelFactory`1<TChannel> {
    private static CacheControlHeaderValue s_requestCacheHeader;
    protected ClientWebSocketFactory _clientWebSocketFactory;
    private bool _allowCookies;
    private AuthenticationSchemes _authenticationScheme;
    private HttpCookieContainerManager _httpCookieContainerManager;
    private HttpClient _httpClient;
    private MruCache`2 modreq(System.Runtime.CompilerServices.IsVolatile) _credentialHashCache;
    private MruCache`2 modreq(System.Runtime.CompilerServices.IsVolatile) _httpClientCache;
    private int _maxBufferSize;
    private IWebProxy _proxy;
    private WebProxyFactory<TChannel> _proxyFactory;
    private SecurityCredentialsManager _channelCredentials;
    private SecurityTokenManager _securityTokenManager;
    private TransferMode _transferMode;
    private ISecurityCapabilities _securityCapabilities;
    private WebSocketTransportSettings _webSocketSettings;
    private bool _useDefaultWebProxy;
    private Lazy`1<string> _webSocketSoapContentType;
    private SHA512 _hashAlgorithm;
    public bool AllowCookies { get; }
    public AuthenticationSchemes AuthenticationScheme { get; }
    public bool IsChannelBindingSupportEnabled { get; }
    public SecurityTokenManager SecurityTokenManager { get; }
    public int MaxBufferSize { get; }
    public TransferMode TransferMode { get; }
    public string Scheme { get; }
    public WebSocketTransportSettings WebSocketSettings { get; }
    internal string WebSocketSoapContentType { get; }
    private HashAlgorithm HashAlgorithm { get; }
    protected ClientWebSocketFactory ClientWebSocketFactory { get; }
    internal HttpChannelFactory`1(HttpTransportBindingElement bindingElement, BindingContext context);
    private static HttpChannelFactory`1();
    public bool get_AllowCookies();
    public AuthenticationSchemes get_AuthenticationScheme();
    public virtual bool get_IsChannelBindingSupportEnabled();
    public SecurityTokenManager get_SecurityTokenManager();
    public sealed virtual int get_MaxBufferSize();
    public sealed virtual TransferMode get_TransferMode();
    public virtual string get_Scheme();
    public WebSocketTransportSettings get_WebSocketSettings();
    internal string get_WebSocketSoapContentType();
    [SecurityCriticalAttribute]
private HashAlgorithm get_HashAlgorithm();
    protected ClientWebSocketFactory get_ClientWebSocketFactory();
    public virtual T GetProperty();
    private HttpCookieContainerManager GetHttpCookieContainerManager();
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.HttpChannelFactory`1/<GetHttpClientAsync>d__44")]
internal Task`1<HttpClient> GetHttpClientAsync(EndpointAddress to, SecurityTokenProviderContainer tokenProvider, SecurityTokenProviderContainer proxyTokenProvider, SecurityTokenContainer clientCertificateToken, CancellationToken cancellationToken);
    internal virtual ServiceModelHttpMessageHandler GetHttpMessageHandler(EndpointAddress to, SecurityTokenContainer clientCertificateToken);
    internal ICredentials GetCredentials();
    internal Exception CreateToMustEqualViaException(Uri to, Uri via);
    public virtual int GetMaxBufferSize();
    private SecurityTokenProviderContainer CreateAndOpenTokenProvider(TimeSpan timeout, AuthenticationSchemes authenticationScheme, EndpointAddress target, Uri via, ChannelParameterCollection channelParameters);
    protected virtual void ValidateCreateChannelParameters(EndpointAddress remoteAddress, Uri via);
    protected virtual TChannel OnCreateChannel(EndpointAddress remoteAddress, Uri via);
    protected virtual TChannel OnCreateChannelCore(EndpointAddress remoteAddress, Uri via);
    protected void ValidateWebSocketTransportUsage();
    private void InitializeSecurityTokenManager();
    protected virtual bool IsSecurityTokenManagerRequired();
    protected virtual IAsyncResult OnBeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndOpen(IAsyncResult result);
    protected virtual void OnOpen(TimeSpan timeout);
    protected internal virtual Task OnOpenAsync(TimeSpan timeout);
    protected internal virtual Task OnCloseAsync(TimeSpan timeout);
    protected virtual void OnClosed();
    private string AppendWindowsAuthenticationInfo(string inputString, NetworkCredential credential, AuthenticationLevel authenticationLevel, TokenImpersonationLevel impersonationLevel);
    protected virtual string OnGetConnectionGroupPrefix(SecurityTokenContainer clientCertificateToken);
    internal static bool IsWindowsAuth(AuthenticationSchemes authScheme);
    private string GetConnectionGroupName(NetworkCredential credential, AuthenticationLevel authenticationLevel, TokenImpersonationLevel impersonationLevel, SecurityTokenContainer clientCertificateToken);
    internal HttpRequestMessage GetHttpRequestMessage(Uri via);
    private void ApplyManualAddressing(EndpointAddress& to, Uri& via, Message message);
    private void CreateAndOpenTokenProvidersCore(EndpointAddress to, Uri via, ChannelParameterCollection channelParameters, TimeSpan timeout, SecurityTokenProviderContainer& tokenProvider, SecurityTokenProviderContainer& proxyTokenProvider);
    internal void CreateAndOpenTokenProviders(EndpointAddress to, Uri via, ChannelParameterCollection channelParameters, TimeSpan timeout, SecurityTokenProviderContainer& tokenProvider, SecurityTokenProviderContainer& proxyTokenProvider);
    internal static bool MapIdentity(EndpointAddress target, AuthenticationSchemes authenticationScheme);
    private bool MapIdentity(EndpointAddress target);
    [CompilerGeneratedAttribute]
private string <.ctor>b__19_0();
}
internal static class System.ServiceModel.Channels.HttpChannelUtilities : object {
    internal static string HttpStatusCodeExceptionKey;
    internal static string HttpStatusDescriptionExceptionKey;
    internal static string HttpRequestHeadersTypeName;
    internal static int ResponseStreamExcerptSize;
    internal static string MIMEVersionHeader;
    internal static string ContentEncodingHeader;
    internal static UInt32 CURLE_SSL_CERTPROBLEM;
    internal static UInt32 CURLE_SSL_CACERT;
    internal static UInt32 WININET_E_NAME_NOT_RESOLVED;
    internal static UInt32 WININET_E_CONNECTION_RESET;
    internal static UInt32 WININET_E_INCORRECT_HANDLE_STATE;
    internal static UInt32 ERROR_WINHTTP_SECURE_FAILURE;
    public static Task`1<NetworkCredential> GetCredentialAsync(AuthenticationSchemes authenticationScheme, SecurityTokenProviderContainer credentialProvider, OutWrapper`1<TokenImpersonationLevel> impersonationLevelWrapper, OutWrapper`1<AuthenticationLevel> authenticationLevelWrapper, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.HttpChannelUtilities/<GetCredentialCoreAsync>d__14")]
private static Task`1<NetworkCredential> GetCredentialCoreAsync(AuthenticationSchemes authenticationScheme, SecurityTokenProviderContainer credentialProvider, OutWrapper`1<TokenImpersonationLevel> impersonationLevelWrapper, OutWrapper`1<AuthenticationLevel> authenticationLevelWrapper, CancellationToken cancellationToken);
    public static HttpResponseMessage ProcessGetResponseWebException(HttpRequestException requestException, HttpRequestMessage request, HttpAbortReason abortReason);
    public static Exception ConvertHttpRequestException(HttpRequestException exception, HttpRequestMessage request, HttpAbortReason abortReason);
    internal static Exception CreateUnexpectedResponseException(HttpResponseMessage response);
    internal static string GetResponseStreamExcerptString(Stream responseStream, Int32& bytesToRead);
    internal static Exception TraceResponseException(Exception exception);
    internal static ProtocolException CreateHttpProtocolException(string message, HttpStatusCode statusCode, string statusDescription);
}
internal class System.ServiceModel.Channels.HttpCookieContainerManager : object {
    private CookieContainer _cookieContainer;
    [CompilerGeneratedAttribute]
private bool <IsInitialized>k__BackingField;
    public bool IsInitialized { get; private set; }
    public CookieContainer CookieContainer { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_IsInitialized();
    [CompilerGeneratedAttribute]
private void set_IsInitialized(bool value);
    public sealed virtual CookieContainer get_CookieContainer();
    public sealed virtual void set_CookieContainer(CookieContainer value);
}
public class System.ServiceModel.Channels.HttpMessageHandlerFactory : object {
    private static Type s_delegatingHandlerType;
    private Type[] _httpMessageHandlers;
    private ConstructorInfo[] _handlerCtors;
    private Func`1<IEnumerable`1<DelegatingHandler>> _handlerFunc;
    public HttpMessageHandlerFactory(Type[] handlers);
    public HttpMessageHandlerFactory(Func`1<IEnumerable`1<DelegatingHandler>> handlers);
    private static HttpMessageHandlerFactory();
    public HttpMessageHandler Create(HttpMessageHandler innerChannel);
    protected virtual HttpMessageHandler OnCreate(HttpMessageHandler innerChannel);
    private static string GetFuncDetails(Func`1<IEnumerable`1<DelegatingHandler>> func);
}
[ExtensionAttribute]
public static class System.ServiceModel.Channels.HttpRequestMessageExtensionMethods : object {
    private static string MessageHeadersPropertyKey;
    internal static HashSet`1<string> WellKnownContentHeaders;
    private static HttpRequestMessageExtensionMethods();
    [ExtensionAttribute]
internal static void CopyPropertiesFromMessage(HttpRequestMessage httpRequestMessage, Message message);
    [ExtensionAttribute]
internal static void AddHeaderWithoutValidation(HttpHeaders httpHeaders, KeyValuePair`2<string, IEnumerable`1<string>> header);
    private static void CopyProperties(MessageProperties messageProperties, IDictionary`2<string, object> properties);
    [ExtensionAttribute]
public static bool CreateContentIfNull(HttpRequestMessage httpRequestMessage);
    [ExtensionAttribute]
internal static void MergeWebHeaderCollection(HttpRequestMessage requestMessage, WebHeaderCollection headersToMerge);
    internal static void MergeWebHeaderCollectionWithHttpHeaders(WebHeaderCollection headersToMerge, HttpHeaders mainHeaders, HttpHeaders contentHeaders);
    [ExtensionAttribute]
internal static WebHeaderCollection ToWebHeaderCollection(HttpRequestMessage httpRequest);
    [ExtensionAttribute]
internal static WebHeaderCollection ToWebHeaderCollection(IEnumerable`1<KeyValuePair`2<string, IEnumerable`1<string>>> headers);
}
public class System.ServiceModel.Channels.HttpRequestMessageProperty : object {
    private TraditionalHttpRequestMessageProperty _traditionalProperty;
    private HttpRequestMessageBackedProperty _httpBackedProperty;
    private bool _initialCopyPerformed;
    private bool _useHttpBackedProperty;
    public static string Name { get; }
    public WebHeaderCollection Headers { get; }
    public string Method { get; public set; }
    public string QueryString { get; public set; }
    public bool SuppressEntityBody { get; public set; }
    public HttpRequestMessage HttpRequestMessage { get; }
    internal HttpRequestMessageProperty(WebHeaderCollection originalHeaders);
    internal HttpRequestMessageProperty(HttpRequestMessage httpRequestMessage);
    public static string get_Name();
    public WebHeaderCollection get_Headers();
    public string get_Method();
    public void set_Method(string value);
    public string get_QueryString();
    public void set_QueryString(string value);
    public bool get_SuppressEntityBody();
    public void set_SuppressEntityBody(bool value);
    public HttpRequestMessage get_HttpRequestMessage();
    internal static HttpRequestMessage GetHttpRequestMessageFromMessage(Message message);
    private sealed virtual override IMessageProperty System.ServiceModel.Channels.IMessageProperty.CreateCopy();
    private sealed virtual override bool System.ServiceModel.Channels.IMergeEnabledMessageProperty.TryMergeWithProperty(object propertyToMerge);
}
[ExtensionAttribute]
internal static class System.ServiceModel.Channels.HttpResponseMessageExtensionMethods : object {
    [ExtensionAttribute]
internal static void CopyPropertiesFromMessage(HttpResponseMessage httpResponseMessage, Message message);
    [ExtensionAttribute]
internal static bool CreateContentIfNull(HttpResponseMessage httpResponseMessage);
    [ExtensionAttribute]
internal static void MergeWebHeaderCollection(HttpResponseMessage responseMessage, WebHeaderCollection headersToMerge);
    [ExtensionAttribute]
internal static WebHeaderCollection ToWebHeaderCollection(HttpResponseMessage httpResponse);
}
internal class System.ServiceModel.Channels.HttpResponseMessageHelper : object {
    private HttpChannelFactory`1<IRequestChannel> _factory;
    private MessageEncoder _encoder;
    private HttpRequestMessage _httpRequestMessage;
    private HttpResponseMessage _httpResponseMessage;
    private string _contentType;
    private long _contentLength;
    public HttpResponseMessageHelper(HttpResponseMessage httpResponseMessage, HttpChannelFactory`1<IRequestChannel> factory);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.HttpResponseMessageHelper/<ParseIncomingResponse>d__7")]
internal Task`1<Message> ParseIncomingResponse(TimeoutHelper timeoutHelper);
    private Exception ProcessHttpAddressing(Message message);
    private void AddProperties(Message message);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.HttpResponseMessageHelper/<ValidateContentTypeAsync>d__10")]
private Task`1<bool> ValidateContentTypeAsync();
    private Task`1<Message> ReadStreamAsMessageAsync(TimeoutHelper timeoutHelper);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.HttpResponseMessageHelper/<ReadChunkedBufferedMessageAsync>d__12")]
private Task`1<Message> ReadChunkedBufferedMessageAsync(Task`1<Stream> inputStreamTask, TimeoutHelper timeoutHelper);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.HttpResponseMessageHelper/<ReadBufferedMessageAsync>d__13")]
private Task`1<Message> ReadBufferedMessageAsync(Task`1<Stream> inputStreamTask);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.HttpResponseMessageHelper/<ReadStreamedMessageAsync>d__14")]
private Task`1<Message> ReadStreamedMessageAsync(Task`1<Stream> inputStreamTask);
    private void ThrowMaxReceivedMessageSizeExceeded();
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.HttpResponseMessageHelper/<DecodeBufferedMessageAsync>d__16")]
private Task`1<Message> DecodeBufferedMessageAsync(ArraySegment`1<byte> buffer, Stream inputStream);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.HttpResponseMessageHelper/<GetStreamAsync>d__17")]
private Task`1<Stream> GetStreamAsync();
    private void ValidateResponseStatusCode();
    private void ValidateAuthentication();
}
public class System.ServiceModel.Channels.HttpResponseMessageProperty : object {
    private TraditionalHttpResponseMessageProperty _traditionalProperty;
    private HttpResponseMessageBackedProperty _httpBackedProperty;
    private bool _useHttpBackedProperty;
    private bool _initialCopyPerformed;
    public static string Name { get; }
    public WebHeaderCollection Headers { get; }
    public HttpStatusCode StatusCode { get; public set; }
    internal bool HasStatusCodeBeenSet { get; }
    public string StatusDescription { get; public set; }
    public bool SuppressEntityBody { get; public set; }
    public bool SuppressPreamble { get; public set; }
    public HttpResponseMessage HttpResponseMessage { get; }
    internal HttpResponseMessageProperty(WebHeaderCollection originalHeaders);
    internal HttpResponseMessageProperty(HttpResponseMessage httpResponseMessage);
    public static string get_Name();
    public WebHeaderCollection get_Headers();
    public HttpStatusCode get_StatusCode();
    public void set_StatusCode(HttpStatusCode value);
    internal bool get_HasStatusCodeBeenSet();
    public string get_StatusDescription();
    public void set_StatusDescription(string value);
    public bool get_SuppressEntityBody();
    public void set_SuppressEntityBody(bool value);
    public bool get_SuppressPreamble();
    public void set_SuppressPreamble(bool value);
    public HttpResponseMessage get_HttpResponseMessage();
    internal static HttpResponseMessage GetHttpResponseMessageFromMessage(Message message);
    private sealed virtual override IMessageProperty System.ServiceModel.Channels.IMessageProperty.CreateCopy();
    private sealed virtual override bool System.ServiceModel.Channels.IMergeEnabledMessageProperty.TryMergeWithProperty(object propertyToMerge);
}
internal class System.ServiceModel.Channels.HttpsChannelFactory`1 : HttpChannelFactory`1<TChannel> {
    private bool _requireClientCertificate;
    private X509CertificateValidator _sslCertificateValidator;
    private Func`5<HttpRequestMessage, X509Certificate2, X509Chain, SslPolicyErrors, bool> _remoteCertificateValidationCallback;
    public string Scheme { get; }
    public bool RequireClientCertificate { get; }
    public bool IsChannelBindingSupportEnabled { get; }
    internal HttpsChannelFactory`1(HttpsTransportBindingElement httpsBindingElement, BindingContext context);
    public virtual string get_Scheme();
    public bool get_RequireClientCertificate();
    public virtual bool get_IsChannelBindingSupportEnabled();
    public virtual T GetProperty();
    protected virtual void ValidateCreateChannelParameters(EndpointAddress remoteAddress, Uri via);
    protected virtual TChannel OnCreateChannelCore(EndpointAddress address, Uri via);
    protected virtual bool IsSecurityTokenManagerRequired();
    private void OnOpenCore();
    protected virtual void OnEndOpen(IAsyncResult result);
    protected virtual void OnOpen(TimeSpan timeout);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.HttpsChannelFactory`1/<OnOpenAsync>d__17")]
protected internal virtual Task OnOpenAsync(TimeSpan timeout);
    internal SecurityTokenProvider CreateAndOpenCertificateTokenProvider(EndpointAddress target, Uri via, ChannelParameterCollection channelParameters, TimeSpan timeout);
    internal SecurityTokenContainer GetCertificateSecurityToken(SecurityTokenProvider certificateProvider, EndpointAddress to, Uri via, ChannelParameterCollection channelParameters, TimeoutHelper& timeoutHelper);
    private void AddServerCertMappingOrSetRemoteCertificateValidationCallback(ServiceModelHttpMessageHandler messageHandler, EndpointAddress to);
    private bool RemoteCertificateValidationCallback(HttpRequestMessage sender, X509Certificate2 certificate, X509Chain chain, SslPolicyErrors sslPolicyErrors);
    internal virtual ServiceModelHttpMessageHandler GetHttpMessageHandler(EndpointAddress to, SecurityTokenContainer clientCertificateToken);
    private static void SetCertificate(ServiceModelHttpMessageHandler handler, SecurityTokenContainer clientCertificateToken);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__0(TimeSpan timeout);
}
public class System.ServiceModel.Channels.HttpsTransportBindingElement : HttpTransportBindingElement {
    private bool _requireClientCertificate;
    private MessageSecurityVersion _messageSecurityVersion;
    [DefaultValueAttribute("False")]
public bool RequireClientCertificate { get; public set; }
    public string Scheme { get; }
    internal MessageSecurityVersion MessageSecurityVersion { get; internal set; }
    protected HttpsTransportBindingElement(HttpsTransportBindingElement elementToBeCloned);
    private HttpsTransportBindingElement(HttpTransportBindingElement elementToBeCloned);
    public bool get_RequireClientCertificate();
    public void set_RequireClientCertificate(bool value);
    public virtual string get_Scheme();
    public virtual BindingElement Clone();
    internal virtual bool GetSupportsClientAuthenticationImpl(AuthenticationSchemes effectiveAuthenticationSchemes);
    internal virtual bool GetSupportsClientWindowsIdentityImpl(AuthenticationSchemes effectiveAuthenticationSchemes);
    internal MessageSecurityVersion get_MessageSecurityVersion();
    internal void set_MessageSecurityVersion(MessageSecurityVersion value);
    public virtual IChannelFactory`1<TChannel> BuildChannelFactory(BindingContext context);
    internal static HttpsTransportBindingElement CreateFromHttpBindingElement(HttpTransportBindingElement elementToBeCloned);
    public virtual T GetProperty(BindingContext context);
}
public class System.ServiceModel.Channels.HttpTransportBindingElement : TransportBindingElement {
    private bool _allowCookies;
    private AuthenticationSchemes _authenticationScheme;
    private bool _bypassProxyOnLocal;
    private bool _decompressionEnabled;
    private HostNameComparisonMode _hostNameComparisonMode;
    private bool _keepAliveEnabled;
    private bool _inheritBaseAddressSettings;
    private int _maxBufferSize;
    private bool _maxBufferSizeInitialized;
    private string _method;
    private Uri _proxyAddress;
    private AuthenticationSchemes _proxyAuthenticationScheme;
    private string _realm;
    private TimeSpan _requestInitializationTimeout;
    private TransferMode _transferMode;
    private bool _unsafeConnectionNtlmAuthentication;
    private bool _useDefaultWebProxy;
    private WebSocketTransportSettings _webSocketSettings;
    private ExtendedProtectionPolicy _extendedProtectionPolicy;
    private HttpMessageHandlerFactory _httpMessageHandlerFactory;
    private int _maxPendingAccepts;
    [DefaultValueAttribute("False")]
public bool AllowCookies { get; public set; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public AuthenticationSchemes AuthenticationScheme { get; public set; }
    [DefaultValueAttribute("False")]
public bool BypassProxyOnLocal { get; public set; }
    [DefaultValueAttribute("True")]
public bool DecompressionEnabled { get; public set; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public HostNameComparisonMode HostNameComparisonMode { get; public set; }
    public HttpMessageHandlerFactory MessageHandlerFactory { get; public set; }
    public ExtendedProtectionPolicy ExtendedProtectionPolicy { get; public set; }
    internal bool InheritBaseAddressSettings { get; internal set; }
    [DefaultValueAttribute("True")]
public bool KeepAliveEnabled { get; public set; }
    [DefaultValueAttribute("65536")]
public int MaxBufferSize { get; public set; }
    [DefaultValueAttribute("0")]
public int MaxPendingAccepts { get; public set; }
    internal string Method { get; internal set; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
[TypeConverterAttribute("System.UriTypeConverter")]
public Uri ProxyAddress { get; public set; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public AuthenticationSchemes ProxyAuthenticationScheme { get; public set; }
    [DefaultValueAttribute("")]
public string Realm { get; public set; }
    [DefaultValueAttribute("System.TimeSpan", "00:00:00")]
public TimeSpan RequestInitializationTimeout { get; public set; }
    public string Scheme { get; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public TransferMode TransferMode { get; public set; }
    public WebSocketTransportSettings WebSocketSettings { get; public set; }
    [DefaultValueAttribute("False")]
public bool UnsafeConnectionNtlmAuthentication { get; public set; }
    [DefaultValueAttribute("True")]
public bool UseDefaultWebProxy { get; public set; }
    protected HttpTransportBindingElement(HttpTransportBindingElement elementToBeCloned);
    public bool get_AllowCookies();
    public void set_AllowCookies(bool value);
    public AuthenticationSchemes get_AuthenticationScheme();
    public void set_AuthenticationScheme(AuthenticationSchemes value);
    public bool get_BypassProxyOnLocal();
    public void set_BypassProxyOnLocal(bool value);
    public bool get_DecompressionEnabled();
    public void set_DecompressionEnabled(bool value);
    public HostNameComparisonMode get_HostNameComparisonMode();
    public void set_HostNameComparisonMode(HostNameComparisonMode value);
    public HttpMessageHandlerFactory get_MessageHandlerFactory();
    public void set_MessageHandlerFactory(HttpMessageHandlerFactory value);
    public ExtendedProtectionPolicy get_ExtendedProtectionPolicy();
    public void set_ExtendedProtectionPolicy(ExtendedProtectionPolicy value);
    internal bool get_InheritBaseAddressSettings();
    internal void set_InheritBaseAddressSettings(bool value);
    public bool get_KeepAliveEnabled();
    public void set_KeepAliveEnabled(bool value);
    public int get_MaxBufferSize();
    public void set_MaxBufferSize(int value);
    public int get_MaxPendingAccepts();
    public void set_MaxPendingAccepts(int value);
    internal string get_Method();
    internal void set_Method(string value);
    public Uri get_ProxyAddress();
    public void set_ProxyAddress(Uri value);
    public AuthenticationSchemes get_ProxyAuthenticationScheme();
    public void set_ProxyAuthenticationScheme(AuthenticationSchemes value);
    public string get_Realm();
    public void set_Realm(string value);
    public TimeSpan get_RequestInitializationTimeout();
    public void set_RequestInitializationTimeout(TimeSpan value);
    public virtual string get_Scheme();
    public TransferMode get_TransferMode();
    public void set_TransferMode(TransferMode value);
    public WebSocketTransportSettings get_WebSocketSettings();
    public void set_WebSocketSettings(WebSocketTransportSettings value);
    internal virtual bool GetSupportsClientAuthenticationImpl(AuthenticationSchemes effectiveAuthenticationSchemes);
    internal virtual bool GetSupportsClientWindowsIdentityImpl(AuthenticationSchemes effectiveAuthenticationSchemes);
    public bool get_UnsafeConnectionNtlmAuthentication();
    public void set_UnsafeConnectionNtlmAuthentication(bool value);
    public bool get_UseDefaultWebProxy();
    public void set_UseDefaultWebProxy(bool value);
    internal string GetWsdlTransportUri(bool useWebSocketTransport);
    public virtual BindingElement Clone();
    public virtual T GetProperty(BindingContext context);
    public virtual bool CanBuildChannelFactory(BindingContext context);
    public virtual IChannelFactory`1<TChannel> BuildChannelFactory(BindingContext context);
    internal virtual bool IsMatch(BindingElement b);
    private MessageEncodingBindingElement FindMessageEncodingBindingElement(BindingElementCollection bindingElements, Boolean& createdNew);
}
internal static class System.ServiceModel.Channels.HttpTransportDefaults : object {
    internal static bool AllowCookies;
    internal static AuthenticationSchemes AuthenticationScheme;
    internal static bool BypassProxyOnLocal;
    internal static bool DecompressionEnabled;
    internal static HostNameComparisonMode HostNameComparisonMode;
    internal static bool KeepAliveEnabled;
    internal static Uri ProxyAddress;
    internal static AuthenticationSchemes ProxyAuthenticationScheme;
    internal static string Realm;
    internal static TransferMode TransferMode;
    internal static bool UnsafeConnectionNtlmAuthentication;
    internal static bool UseDefaultWebProxy;
    internal static string UpgradeHeader;
    internal static string ConnectionHeader;
    internal static HttpMessageHandlerFactory MessageHandlerFactory;
    internal static string RequestInitializationTimeoutString;
    internal static int DefaultMaxPendingAccepts;
    internal static int MaxPendingAcceptsUpperLimit;
    internal static TimeSpan RequestInitializationTimeout { get; }
    internal static TimeSpan get_RequestInitializationTimeout();
    internal static WebSocketTransportSettings GetDefaultWebSocketTransportSettings();
    internal static MessageEncoderFactory GetDefaultMessageEncoderFactory();
}
internal static class System.ServiceModel.Channels.HttpTransportSecurityHelpers : object {
    private static Dictionary`2<string, int> s_targetNameCounter;
    private static Dictionary`2<HttpRequestMessage, string> s_serverCertMap;
    private static HttpTransportSecurityHelpers();
    public static bool AddIdentityMapping(Uri via, EndpointAddress target);
    public static void RemoveIdentityMapping(Uri via, EndpointAddress target, bool validateState);
    public static void AddServerCertMapping(HttpRequestMessage request, EndpointAddress to);
    private static void AddServerCertMapping(HttpRequestMessage request, string thumbprint);
    public static void SetServerCertificateValidationCallback(ServiceModelHttpMessageHandler handler);
    private static Func`5<HttpRequestMessage, X509Certificate2, X509Chain, SslPolicyErrors, bool> ChainValidator(Func`5<HttpRequestMessage, X509Certificate2, X509Chain, SslPolicyErrors, bool> previousValidator);
    private static bool OnValidateServerCertificate(HttpRequestMessage request, X509Certificate2 certificate, X509Chain chain, SslPolicyErrors sslPolicyErrors);
    public static void RemoveServerCertMapping(HttpRequestMessage request);
    private static void ValidateServerCertificate(X509Certificate2 certificate, string thumbprint);
}
public interface System.ServiceModel.Channels.IAsyncChannelFactory {
}
public interface System.ServiceModel.Channels.IAsyncRequest {
    public abstract virtual Task SendRequestAsync(Message message, TimeoutHelper timeoutHelper);
    public abstract virtual Task`1<Message> ReceiveReplyAsync(TimeoutHelper timeoutHelper);
}
internal interface System.ServiceModel.Channels.IAsyncRequestChannel {
    public abstract virtual Task`1<Message> RequestAsync(Message message);
    public abstract virtual Task`1<Message> RequestAsync(Message message, TimeSpan timeout);
}
public interface System.ServiceModel.Channels.IBindingDeliveryCapabilities {
    public bool AssuresOrderedDelivery { get; }
    public bool QueuedDelivery { get; }
    public abstract virtual bool get_AssuresOrderedDelivery();
    public abstract virtual bool get_QueuedDelivery();
}
public interface System.ServiceModel.Channels.IBindingMulticastCapabilities {
    public bool IsMulticast { get; }
    public abstract virtual bool get_IsMulticast();
}
public interface System.ServiceModel.Channels.IBindingRuntimePreferences {
    public bool ReceiveSynchronously { get; }
    public abstract virtual bool get_ReceiveSynchronously();
}
internal interface System.ServiceModel.Channels.IBufferedMessageData {
    public MessageEncoder MessageEncoder { get; }
    public ArraySegment`1<byte> Buffer { get; }
    public XmlDictionaryReaderQuotas Quotas { get; }
    public abstract virtual MessageEncoder get_MessageEncoder();
    public abstract virtual ArraySegment`1<byte> get_Buffer();
    public abstract virtual XmlDictionaryReaderQuotas get_Quotas();
    public abstract virtual void Close();
    public abstract virtual void EnableMultipleUsers();
    public abstract virtual XmlDictionaryReader GetMessageReader();
    public abstract virtual void Open();
    public abstract virtual void ReturnMessageState(RecycledMessageState messageState);
    public abstract virtual RecycledMessageState TakeMessageState();
}
public interface System.ServiceModel.Channels.IChannel {
    public abstract virtual T GetProperty();
}
internal interface System.ServiceModel.Channels.IChannelAcceptor`1 {
    public abstract virtual TChannel AcceptChannel(TimeSpan timeout);
    public abstract virtual IAsyncResult BeginAcceptChannel(TimeSpan timeout, AsyncCallback callback, object state);
    public abstract virtual TChannel EndAcceptChannel(IAsyncResult result);
    public abstract virtual bool WaitForChannel(TimeSpan timeout);
    public abstract virtual IAsyncResult BeginWaitForChannel(TimeSpan timeout, AsyncCallback callback, object state);
    public abstract virtual bool EndWaitForChannel(IAsyncResult result);
}
internal interface System.ServiceModel.Channels.IChannelBindingProvider {
    public bool IsChannelBindingSupportEnabled { get; }
    public abstract virtual void EnableChannelBindingSupport();
    public abstract virtual bool get_IsChannelBindingSupportEnabled();
}
public interface System.ServiceModel.Channels.IChannelFactory {
    public abstract virtual T GetProperty();
}
public interface System.ServiceModel.Channels.IChannelFactory`1 {
    public abstract virtual TChannel CreateChannel(EndpointAddress to);
    public abstract virtual TChannel CreateChannel(EndpointAddress to, Uri via);
}
public interface System.ServiceModel.Channels.IChannelListener {
    public Uri Uri { get; }
    public abstract virtual Uri get_Uri();
    public abstract virtual T GetProperty();
    public abstract virtual bool WaitForChannel(TimeSpan timeout);
    public abstract virtual IAsyncResult BeginWaitForChannel(TimeSpan timeout, AsyncCallback callback, object state);
    public abstract virtual bool EndWaitForChannel(IAsyncResult result);
}
public interface System.ServiceModel.Channels.IChannelListener`1 {
    public abstract virtual TChannel AcceptChannel();
    public abstract virtual TChannel AcceptChannel(TimeSpan timeout);
    public abstract virtual IAsyncResult BeginAcceptChannel(AsyncCallback callback, object state);
    public abstract virtual IAsyncResult BeginAcceptChannel(TimeSpan timeout, AsyncCallback callback, object state);
    public abstract virtual TChannel EndAcceptChannel(IAsyncResult result);
}
internal interface System.ServiceModel.Channels.ICommunicationWaiter {
    public abstract virtual void Signal();
    public abstract virtual CommunicationWaitResult Wait(TimeSpan timeout, bool aborting);
}
internal interface System.ServiceModel.Channels.ICompressedMessageEncoder {
    public bool CompressionEnabled { get; }
    public abstract virtual bool get_CompressionEnabled();
    public abstract virtual void SetSessionContentType(string contentType);
    public abstract virtual void AddCompressedMessageProperties(Message message, string supportedCompressionTypes);
}
public interface System.ServiceModel.Channels.IConnection {
    public Byte[] AsyncReadBuffer { get; }
    public int AsyncReadBufferSize { get; }
    public abstract virtual Byte[] get_AsyncReadBuffer();
    public abstract virtual int get_AsyncReadBufferSize();
    public abstract virtual void Abort();
    public abstract virtual void Close(TimeSpan timeout, bool asyncAndLinger);
    public abstract virtual AsyncCompletionResult BeginWrite(Byte[] buffer, int offset, int size, bool immediate, TimeSpan timeout, Action`1<object> callback, object state);
    public abstract virtual void EndWrite();
    public abstract virtual void Write(Byte[] buffer, int offset, int size, bool immediate, TimeSpan timeout);
    public abstract virtual void Write(Byte[] buffer, int offset, int size, bool immediate, TimeSpan timeout, BufferManager bufferManager);
    public abstract virtual int Read(Byte[] buffer, int offset, int size, TimeSpan timeout);
    public abstract virtual AsyncCompletionResult BeginRead(int offset, int size, TimeSpan timeout, Action`1<object> callback, object state);
    public abstract virtual int EndRead();
    public abstract virtual object GetCoreTransport();
}
public interface System.ServiceModel.Channels.IConnectionInitiator {
    public abstract virtual IConnection Connect(Uri uri, TimeSpan timeout);
    public abstract virtual Task`1<IConnection> ConnectAsync(Uri uri, TimeSpan timeout);
}
public interface System.ServiceModel.Channels.IConnectionOrientedConnectionSettings {
    public int ConnectionBufferSize { get; }
    public TimeSpan MaxOutputDelay { get; }
    public TimeSpan IdleTimeout { get; }
    public abstract virtual int get_ConnectionBufferSize();
    public abstract virtual TimeSpan get_MaxOutputDelay();
    public abstract virtual TimeSpan get_IdleTimeout();
}
internal interface System.ServiceModel.Channels.IConnectionOrientedListenerSettings {
    public TimeSpan ChannelInitializationTimeout { get; }
    public int MaxPendingConnections { get; }
    public int MaxPendingAccepts { get; }
    public int MaxPooledConnections { get; }
    public abstract virtual TimeSpan get_ChannelInitializationTimeout();
    public abstract virtual int get_MaxPendingConnections();
    public abstract virtual int get_MaxPendingAccepts();
    public abstract virtual int get_MaxPooledConnections();
}
public interface System.ServiceModel.Channels.IConnectionOrientedTransportChannelFactorySettings {
    public string ConnectionPoolGroupName { get; }
    public int MaxOutboundConnectionsPerEndpoint { get; }
    public abstract virtual string get_ConnectionPoolGroupName();
    public abstract virtual int get_MaxOutboundConnectionsPerEndpoint();
}
public interface System.ServiceModel.Channels.IConnectionOrientedTransportFactorySettings {
    public int MaxBufferSize { get; }
    public StreamUpgradeProvider Upgrade { get; }
    public TransferMode TransferMode { get; }
    public abstract virtual int get_MaxBufferSize();
    public abstract virtual StreamUpgradeProvider get_Upgrade();
    public abstract virtual TransferMode get_TransferMode();
}
internal interface System.ServiceModel.Channels.ICorrelatorKey {
    public Key RequestCorrelatorKey { get; public set; }
    public abstract virtual Key get_RequestCorrelatorKey();
    public abstract virtual void set_RequestCorrelatorKey(Key value);
}
public abstract class System.ServiceModel.Channels.IdlingCommunicationPool`2 : CommunicationPool`2<TKey, TItem> {
    private TimeSpan _idleTimeout;
    private TimeSpan _leaseTimeout;
    public TimeSpan IdleTimeout { get; }
    protected TimeSpan LeaseTimeout { get; }
    protected IdlingCommunicationPool`2(int maxCount, TimeSpan idleTimeout, TimeSpan leaseTimeout);
    public TimeSpan get_IdleTimeout();
    protected TimeSpan get_LeaseTimeout();
    protected virtual void CloseItemAsync(TItem item, TimeSpan timeout);
    protected virtual EndpointConnectionPool<TKey, TItem> CreateEndpointConnectionPool(TKey key);
}
public interface System.ServiceModel.Channels.IDuplexChannel {
}
public interface System.ServiceModel.Channels.IDuplexSession {
    public abstract virtual void CloseOutputSession();
    public abstract virtual void CloseOutputSession(TimeSpan timeout);
    public abstract virtual IAsyncResult BeginCloseOutputSession(AsyncCallback callback, object state);
    public abstract virtual IAsyncResult BeginCloseOutputSession(TimeSpan timeout, AsyncCallback callback, object state);
    public abstract virtual void EndCloseOutputSession(IAsyncResult result);
}
public interface System.ServiceModel.Channels.IDuplexSessionChannel {
}
public interface System.ServiceModel.Channels.IHttpCookieContainerManager {
    public CookieContainer CookieContainer { get; public set; }
    public abstract virtual CookieContainer get_CookieContainer();
    public abstract virtual void set_CookieContainer(CookieContainer value);
}
internal interface System.ServiceModel.Channels.IHttpTransportFactorySettings {
    public int MaxBufferSize { get; }
    public TransferMode TransferMode { get; }
    public abstract virtual int get_MaxBufferSize();
    public abstract virtual TransferMode get_TransferMode();
}
public interface System.ServiceModel.Channels.IInputChannel {
    public EndpointAddress LocalAddress { get; }
    public abstract virtual EndpointAddress get_LocalAddress();
    public abstract virtual Message Receive();
    public abstract virtual Message Receive(TimeSpan timeout);
    public abstract virtual IAsyncResult BeginReceive(AsyncCallback callback, object state);
    public abstract virtual IAsyncResult BeginReceive(TimeSpan timeout, AsyncCallback callback, object state);
    public abstract virtual Message EndReceive(IAsyncResult result);
    public abstract virtual bool TryReceive(TimeSpan timeout, Message& message);
    public abstract virtual IAsyncResult BeginTryReceive(TimeSpan timeout, AsyncCallback callback, object state);
    public abstract virtual bool EndTryReceive(IAsyncResult result, Message& message);
    public abstract virtual bool WaitForMessage(TimeSpan timeout);
    public abstract virtual IAsyncResult BeginWaitForMessage(TimeSpan timeout, AsyncCallback callback, object state);
    public abstract virtual bool EndWaitForMessage(IAsyncResult result);
}
public interface System.ServiceModel.Channels.IInputSession {
}
public interface System.ServiceModel.Channels.IInputSessionChannel {
}
internal interface System.ServiceModel.Channels.IMergeEnabledMessageProperty {
    public abstract virtual bool TryMergeWithProperty(object propertyToMerge);
}
internal interface System.ServiceModel.Channels.IMessageHeaderWithSharedNamespace {
    public XmlDictionaryString SharedNamespace { get; }
    public XmlDictionaryString SharedPrefix { get; }
    public abstract virtual XmlDictionaryString get_SharedNamespace();
    public abstract virtual XmlDictionaryString get_SharedPrefix();
}
public interface System.ServiceModel.Channels.IMessageProperty {
    public abstract virtual IMessageProperty CreateCopy();
}
public interface System.ServiceModel.Channels.IMessageSource {
    public abstract virtual Task`1<Message> ReceiveAsync(TimeSpan timeout);
    public abstract virtual Message Receive(TimeSpan timeout);
    public abstract virtual Task`1<bool> WaitForMessageAsync(TimeSpan timeout);
    public abstract virtual bool WaitForMessage(TimeSpan timeout);
}
internal class System.ServiceModel.Channels.IntDecoder : ValueType {
    private int _value;
    private short _index;
    private bool _isValueDecoded;
    private static int LastIndex;
    public int Value { get; }
    public bool IsValueDecoded { get; }
    public int get_Value();
    public bool get_IsValueDecoded();
    public void Reset();
    public int Decode(Byte[] buffer, int offset, int size);
}
internal static class System.ServiceModel.Channels.IntEncoder : object {
    public static int MaxEncodedSize;
    public static int Encode(int value, Byte[] bytes, int offset);
    public static int GetEncodedSize(int value);
}
public interface System.ServiceModel.Channels.IOutputChannel {
    public EndpointAddress RemoteAddress { get; }
    public Uri Via { get; }
    public abstract virtual EndpointAddress get_RemoteAddress();
    public abstract virtual Uri get_Via();
    public abstract virtual void Send(Message message);
    public abstract virtual void Send(Message message, TimeSpan timeout);
    public abstract virtual IAsyncResult BeginSend(Message message, AsyncCallback callback, object state);
    public abstract virtual IAsyncResult BeginSend(Message message, TimeSpan timeout, AsyncCallback callback, object state);
    public abstract virtual void EndSend(IAsyncResult result);
}
public interface System.ServiceModel.Channels.IOutputSession {
}
public interface System.ServiceModel.Channels.IOutputSessionChannel {
}
internal interface System.ServiceModel.Channels.IPipeTransportFactorySettings {
    public NamedPipeSettings PipeSettings { get; }
    public abstract virtual NamedPipeSettings get_PipeSettings();
}
public interface System.ServiceModel.Channels.IReceiveContextSettings {
    public bool Enabled { get; public set; }
    public TimeSpan ValidityDuration { get; }
    public abstract virtual bool get_Enabled();
    public abstract virtual void set_Enabled(bool value);
    public abstract virtual TimeSpan get_ValidityDuration();
}
public interface System.ServiceModel.Channels.IReplyChannel {
    public EndpointAddress LocalAddress { get; }
    public abstract virtual EndpointAddress get_LocalAddress();
    public abstract virtual RequestContext ReceiveRequest();
    public abstract virtual RequestContext ReceiveRequest(TimeSpan timeout);
    public abstract virtual IAsyncResult BeginReceiveRequest(AsyncCallback callback, object state);
    public abstract virtual IAsyncResult BeginReceiveRequest(TimeSpan timeout, AsyncCallback callback, object state);
    public abstract virtual RequestContext EndReceiveRequest(IAsyncResult result);
    public abstract virtual bool TryReceiveRequest(TimeSpan timeout, RequestContext& context);
    public abstract virtual IAsyncResult BeginTryReceiveRequest(TimeSpan timeout, AsyncCallback callback, object state);
    public abstract virtual bool EndTryReceiveRequest(IAsyncResult result, RequestContext& context);
    public abstract virtual bool WaitForRequest(TimeSpan timeout);
    public abstract virtual IAsyncResult BeginWaitForRequest(TimeSpan timeout, AsyncCallback callback, object state);
    public abstract virtual bool EndWaitForRequest(IAsyncResult result);
}
public interface System.ServiceModel.Channels.IReplySessionChannel {
}
public interface System.ServiceModel.Channels.IRequestBase {
    public abstract virtual void Abort(RequestChannel requestChannel);
    public abstract virtual void Fault(RequestChannel requestChannel);
    public abstract virtual void OnReleaseRequest();
}
public interface System.ServiceModel.Channels.IRequestChannel {
    public EndpointAddress RemoteAddress { get; }
    public Uri Via { get; }
    public abstract virtual EndpointAddress get_RemoteAddress();
    public abstract virtual Uri get_Via();
    public abstract virtual Message Request(Message message);
    public abstract virtual Message Request(Message message, TimeSpan timeout);
    public abstract virtual IAsyncResult BeginRequest(Message message, AsyncCallback callback, object state);
    public abstract virtual IAsyncResult BeginRequest(Message message, TimeSpan timeout, AsyncCallback callback, object state);
    public abstract virtual Message EndRequest(IAsyncResult result);
}
internal interface System.ServiceModel.Channels.IRequestReplyCorrelator {
    public abstract virtual void Add(Message request, T state);
    public abstract virtual T Find(Message reply, bool remove);
}
public interface System.ServiceModel.Channels.IRequestSessionChannel {
}
public interface System.ServiceModel.Channels.ISecurityCapabilities {
    public ProtectionLevel SupportedRequestProtectionLevel { get; }
    public ProtectionLevel SupportedResponseProtectionLevel { get; }
    public bool SupportsClientAuthentication { get; }
    public bool SupportsClientWindowsIdentity { get; }
    public bool SupportsServerAuthentication { get; }
    public abstract virtual ProtectionLevel get_SupportedRequestProtectionLevel();
    public abstract virtual ProtectionLevel get_SupportedResponseProtectionLevel();
    public abstract virtual bool get_SupportsClientAuthentication();
    public abstract virtual bool get_SupportsClientWindowsIdentity();
    public abstract virtual bool get_SupportsServerAuthentication();
}
public interface System.ServiceModel.Channels.ISession {
    public string Id { get; }
    public abstract virtual string get_Id();
}
public interface System.ServiceModel.Channels.ISessionChannel`1 {
    public TSession Session { get; }
    public abstract virtual TSession get_Session();
}
internal interface System.ServiceModel.Channels.IStreamedMessageEncoder {
    public abstract virtual Stream GetResponseMessageStream(Message message);
}
internal interface System.ServiceModel.Channels.IStreamUpgradeChannelBindingProvider {
    public abstract virtual ChannelBinding GetChannelBinding(StreamUpgradeInitiator upgradeInitiator, ChannelBindingKind kind);
}
public interface System.ServiceModel.Channels.ITcpChannelFactorySettings {
    public TimeSpan LeaseTimeout { get; }
    public abstract virtual TimeSpan get_LeaseTimeout();
}
public interface System.ServiceModel.Channels.ITransportCompressionSupport {
    public abstract virtual bool IsCompressionFormatSupported(CompressionFormat compressionFormat);
}
public interface System.ServiceModel.Channels.ITransportFactorySettings {
    public bool ManualAddressing { get; }
    public BufferManager BufferManager { get; }
    public long MaxReceivedMessageSize { get; }
    public MessageEncoderFactory MessageEncoderFactory { get; }
    public MessageVersion MessageVersion { get; }
    public abstract virtual bool get_ManualAddressing();
    public abstract virtual BufferManager get_BufferManager();
    public abstract virtual long get_MaxReceivedMessageSize();
    public abstract virtual MessageEncoderFactory get_MessageEncoderFactory();
    public abstract virtual MessageVersion get_MessageVersion();
}
internal abstract class System.ServiceModel.Channels.LayeredChannel`1 : ChannelBase {
    private TInnerChannel _innerChannel;
    private EventHandler _onInnerChannelFaulted;
    protected TInnerChannel InnerChannel { get; }
    protected LayeredChannel`1(ChannelManagerBase channelManager, TInnerChannel innerChannel);
    protected TInnerChannel get_InnerChannel();
    public virtual T GetProperty();
    protected virtual void OnClosing();
    protected virtual void OnAbort();
    protected virtual void OnClose(TimeSpan timeout);
    protected virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndClose(IAsyncResult result);
    protected virtual void OnOpen(TimeSpan timeout);
    protected virtual IAsyncResult OnBeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndOpen(IAsyncResult result);
    private void OnInnerChannelFaulted(object sender, EventArgs e);
}
internal abstract class System.ServiceModel.Channels.LayeredChannelFactory`1 : ChannelFactoryBase`1<TChannel> {
    private IChannelFactory _innerChannelFactory;
    protected IChannelFactory InnerChannelFactory { get; }
    public LayeredChannelFactory`1(IDefaultCommunicationTimeouts timeouts, IChannelFactory innerChannelFactory);
    protected IChannelFactory get_InnerChannelFactory();
    public virtual T GetProperty();
    protected virtual IAsyncResult OnBeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndOpen(IAsyncResult result);
    protected virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndClose(IAsyncResult result);
    protected virtual void OnClose(TimeSpan timeout);
    protected virtual void OnOpen(TimeSpan timeout);
    protected virtual void OnAbort();
}
internal class System.ServiceModel.Channels.LayeredDuplexChannel : LayeredInputChannel {
    private IOutputChannel _innerOutputChannel;
    private EndpointAddress _localAddress;
    private EventHandler _onInnerOutputChannelFaulted;
    public EndpointAddress LocalAddress { get; }
    public EndpointAddress RemoteAddress { get; }
    public Uri Via { get; }
    public LayeredDuplexChannel(ChannelManagerBase channelManager, IInputChannel innerInputChannel, EndpointAddress localAddress, IOutputChannel innerOutputChannel);
    public virtual EndpointAddress get_LocalAddress();
    public sealed virtual EndpointAddress get_RemoteAddress();
    public sealed virtual Uri get_Via();
    protected virtual void OnClosing();
    protected virtual void OnAbort();
    protected virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndClose(IAsyncResult result);
    protected virtual void OnClose(TimeSpan timeout);
    protected virtual IAsyncResult OnBeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndOpen(IAsyncResult result);
    protected virtual void OnOpen(TimeSpan timeout);
    public sealed virtual void Send(Message message);
    public sealed virtual void Send(Message message, TimeSpan timeout);
    public sealed virtual IAsyncResult BeginSend(Message message, AsyncCallback callback, object state);
    public sealed virtual IAsyncResult BeginSend(Message message, TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual void EndSend(IAsyncResult result);
    private void OnInnerOutputChannelFaulted(object sender, EventArgs e);
}
internal class System.ServiceModel.Channels.LayeredInputChannel : LayeredChannel`1<IInputChannel> {
    public EndpointAddress LocalAddress { get; }
    public LayeredInputChannel(ChannelManagerBase channelManager, IInputChannel innerChannel);
    public virtual EndpointAddress get_LocalAddress();
    private void InternalOnReceive(Message message);
    protected virtual void OnReceive(Message message);
    public sealed virtual Message Receive();
    public sealed virtual Message Receive(TimeSpan timeout);
    public sealed virtual IAsyncResult BeginReceive(AsyncCallback callback, object state);
    public sealed virtual IAsyncResult BeginReceive(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual Message EndReceive(IAsyncResult result);
    public sealed virtual IAsyncResult BeginTryReceive(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual bool EndTryReceive(IAsyncResult result, Message& message);
    public sealed virtual bool TryReceive(TimeSpan timeout, Message& message);
    public sealed virtual bool WaitForMessage(TimeSpan timeout);
    public sealed virtual IAsyncResult BeginWaitForMessage(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual bool EndWaitForMessage(IAsyncResult result);
}
internal class System.ServiceModel.Channels.LifetimeManager : object {
    private bool _aborted;
    private int _busyCount;
    private ICommunicationWaiter _busyWaiter;
    private int _busyWaiterCount;
    private object _mutex;
    private LifetimeState _state;
    public int BusyCount { get; }
    protected LifetimeState State { get; }
    protected object ThisLock { get; }
    public LifetimeManager(object mutex);
    public int get_BusyCount();
    protected LifetimeState get_State();
    protected object get_ThisLock();
    public void Abort();
    private void ThrowIfNotOpened();
    public IAsyncResult BeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    public void Close(TimeSpan timeout);
    private CommunicationWaitResult CloseCore(TimeSpan timeout, bool aborting);
    protected void DecrementBusyCount();
    public void EndClose(IAsyncResult result);
    protected virtual void IncrementBusyCount();
    protected virtual void IncrementBusyCountWithoutLock();
    protected virtual void OnAbort();
    protected virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnClose(TimeSpan timeout);
    protected virtual void OnEmpty();
    protected virtual void OnEndClose(IAsyncResult result);
}
internal enum System.ServiceModel.Channels.LifetimeState : Enum {
    public int value__;
    public static LifetimeState Opened;
    public static LifetimeState Closing;
    public static LifetimeState Closed;
}
public class System.ServiceModel.Channels.LocalClientSecuritySettings : object {
    private bool _detectReplays;
    private int _replayCacheSize;
    private TimeSpan _replayWindow;
    private TimeSpan _maxClockSkew;
    private bool _cacheCookies;
    private TimeSpan _maxCookieCachingTime;
    private TimeSpan _sessionKeyRenewalInterval;
    private TimeSpan _sessionKeyRolloverInterval;
    private bool _reconnectTransportOnFailure;
    private TimeSpan _timestampValidityDuration;
    private IdentityVerifier _identityVerifier;
    private int _cookieRenewalThresholdPercentage;
    private NonceCache _nonceCache;
    public bool DetectReplays { get; public set; }
    public int ReplayCacheSize { get; public set; }
    public TimeSpan ReplayWindow { get; public set; }
    public TimeSpan MaxClockSkew { get; public set; }
    public NonceCache NonceCache { get; public set; }
    public TimeSpan TimestampValidityDuration { get; public set; }
    public bool CacheCookies { get; public set; }
    public TimeSpan MaxCookieCachingTime { get; public set; }
    public int CookieRenewalThresholdPercentage { get; public set; }
    public TimeSpan SessionKeyRenewalInterval { get; public set; }
    public TimeSpan SessionKeyRolloverInterval { get; public set; }
    public bool ReconnectTransportOnFailure { get; public set; }
    public IdentityVerifier IdentityVerifier { get; public set; }
    private LocalClientSecuritySettings(LocalClientSecuritySettings other);
    public bool get_DetectReplays();
    public void set_DetectReplays(bool value);
    public int get_ReplayCacheSize();
    public void set_ReplayCacheSize(int value);
    public TimeSpan get_ReplayWindow();
    public void set_ReplayWindow(TimeSpan value);
    public TimeSpan get_MaxClockSkew();
    public void set_MaxClockSkew(TimeSpan value);
    public NonceCache get_NonceCache();
    public void set_NonceCache(NonceCache value);
    public TimeSpan get_TimestampValidityDuration();
    public void set_TimestampValidityDuration(TimeSpan value);
    public bool get_CacheCookies();
    public void set_CacheCookies(bool value);
    public TimeSpan get_MaxCookieCachingTime();
    public void set_MaxCookieCachingTime(TimeSpan value);
    public int get_CookieRenewalThresholdPercentage();
    public void set_CookieRenewalThresholdPercentage(int value);
    public TimeSpan get_SessionKeyRenewalInterval();
    public void set_SessionKeyRenewalInterval(TimeSpan value);
    public TimeSpan get_SessionKeyRolloverInterval();
    public void set_SessionKeyRolloverInterval(TimeSpan value);
    public bool get_ReconnectTransportOnFailure();
    public void set_ReconnectTransportOnFailure(bool value);
    public IdentityVerifier get_IdentityVerifier();
    public void set_IdentityVerifier(IdentityVerifier value);
    public LocalClientSecuritySettings Clone();
}
public class System.ServiceModel.Channels.MaxMessageSizeStream : DelegatingStream {
    private long _maxMessageSize;
    private long _totalBytesRead;
    private long _bytesWritten;
    public MaxMessageSizeStream(Stream stream, long maxMessageSize);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.MaxMessageSizeStream/<ReadAsync>d__4")]
public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte value);
    public static Exception CreateMaxReceivedMessageSizeExceededException(long maxMessageSize);
    internal static Exception CreateMaxSentMessageSizeExceededException(long maxMessageSize);
    private int PrepareRead(int bytesToRead);
    private int FinishRead(int bytesRead);
    private void PrepareWrite(int bytesToWrite);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<int> <>n__0(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
}
public abstract class System.ServiceModel.Channels.Message : object {
    private MessageState _state;
    internal static int InitialBufferSize;
    public MessageHeaders Headers { get; }
    protected bool IsDisposed { get; }
    public bool IsFault { get; }
    public bool IsEmpty { get; }
    public MessageProperties Properties { get; }
    public MessageVersion Version { get; }
    internal RecycledMessageState RecycledMessageState { get; }
    public MessageState State { get; }
    public abstract virtual MessageHeaders get_Headers();
    protected bool get_IsDisposed();
    public virtual bool get_IsFault();
    public virtual bool get_IsEmpty();
    public abstract virtual MessageProperties get_Properties();
    public abstract virtual MessageVersion get_Version();
    internal virtual RecycledMessageState get_RecycledMessageState();
    public MessageState get_State();
    internal void BodyToString(XmlDictionaryWriter writer);
    public void Close();
    public MessageBuffer CreateBufferedCopy(int maxBufferSize);
    private static Type GetObjectType(object value);
    public static Message CreateMessage(MessageVersion version, string action, object body);
    public static Message CreateMessage(MessageVersion version, string action, object body, XmlObjectSerializer serializer);
    public static Message CreateMessage(MessageVersion version, string action, XmlReader body);
    public static Message CreateMessage(MessageVersion version, string action, XmlDictionaryReader body);
    public static Message CreateMessage(MessageVersion version, string action, BodyWriter body);
    internal static Message CreateMessage(MessageVersion version, ActionHeader actionHeader, BodyWriter body);
    public static Message CreateMessage(MessageVersion version, string action);
    internal static Message CreateMessage(MessageVersion version, ActionHeader actionHeader);
    public static Message CreateMessage(XmlReader envelopeReader, int maxSizeOfHeaders, MessageVersion version);
    public static Message CreateMessage(XmlDictionaryReader envelopeReader, int maxSizeOfHeaders, MessageVersion version);
    public static Message CreateMessage(MessageVersion version, FaultCode faultCode, string reason, string action);
    public static Message CreateMessage(MessageVersion version, FaultCode faultCode, string reason, object detail, string action);
    public static Message CreateMessage(MessageVersion version, MessageFault fault, string action);
    internal Exception CreateMessageDisposedException();
    private sealed virtual override void System.IDisposable.Dispose();
    public T GetBody();
    protected virtual T OnGetBody(XmlDictionaryReader reader);
    public T GetBody(XmlObjectSerializer serializer);
    private T GetBodyCore(XmlDictionaryReader reader, XmlObjectSerializer serializer);
    internal virtual XmlDictionaryReader GetReaderAtHeader();
    public XmlDictionaryReader GetReaderAtBodyContents();
    internal void EnsureReadMessageState();
    internal void InitializeReply(Message request);
    internal static bool IsFaultStartElement(XmlDictionaryReader reader, EnvelopeVersion version);
    protected virtual void OnBodyToString(XmlDictionaryWriter writer);
    protected virtual MessageBuffer OnCreateBufferedCopy(int maxBufferSize);
    internal MessageBuffer OnCreateBufferedCopy(int maxBufferSize, XmlDictionaryReaderQuotas quotas);
    protected virtual void OnClose();
    protected virtual XmlDictionaryReader OnGetReaderAtBodyContents();
    protected virtual void OnWriteStartBody(XmlDictionaryWriter writer);
    public void WriteBodyContents(XmlDictionaryWriter writer);
    public Task WriteBodyContentsAsync(XmlDictionaryWriter writer);
    public IAsyncResult BeginWriteBodyContents(XmlDictionaryWriter writer, AsyncCallback callback, object state);
    public void EndWriteBodyContents(IAsyncResult result);
    protected abstract virtual void OnWriteBodyContents(XmlDictionaryWriter writer);
    protected virtual Task OnWriteBodyContentsAsync(XmlDictionaryWriter writer);
    protected virtual IAsyncResult OnBeginWriteBodyContents(XmlDictionaryWriter writer, AsyncCallback callback, object state);
    protected virtual void OnEndWriteBodyContents(IAsyncResult result);
    public void WriteStartEnvelope(XmlDictionaryWriter writer);
    protected virtual void OnWriteStartEnvelope(XmlDictionaryWriter writer);
    protected virtual void OnWriteStartHeaders(XmlDictionaryWriter writer);
    public virtual string ToString();
    internal void ToString(XmlDictionaryWriter writer);
    public string GetBodyAttribute(string localName, string ns);
    protected virtual string OnGetBodyAttribute(string localName, string ns);
    internal void ReadFromBodyContentsToEnd(XmlDictionaryReader reader);
    private static void ReadFromBodyContentsToEnd(XmlDictionaryReader reader, EnvelopeVersion envelopeVersion);
    internal static bool ReadStartBody(XmlDictionaryReader reader, EnvelopeVersion envelopeVersion, Boolean& isFault, Boolean& isEmpty);
    public void WriteBody(XmlWriter writer);
    public void WriteBody(XmlDictionaryWriter writer);
    public void WriteStartBody(XmlWriter writer);
    public void WriteStartBody(XmlDictionaryWriter writer);
    internal void WriteStartHeaders(XmlDictionaryWriter writer);
    public void WriteMessage(XmlWriter writer);
    public void WriteMessage(XmlDictionaryWriter writer);
    public virtual Task WriteMessageAsync(XmlWriter writer);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.Message/<WriteMessageAsync>d__78")]
public virtual Task WriteMessageAsync(XmlDictionaryWriter writer);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.Message/<OnWriteMessageAsync>d__79")]
public virtual Task OnWriteMessageAsync(XmlDictionaryWriter writer);
    private void EnsureWriteMessageState(XmlDictionaryWriter writer);
    public IAsyncResult BeginWriteMessage(XmlDictionaryWriter writer, AsyncCallback callback, object state);
    public void EndWriteMessage(IAsyncResult result);
    protected virtual void OnWriteMessage(XmlDictionaryWriter writer);
    internal void WriteMessagePreamble(XmlDictionaryWriter writer);
    internal void WriteMessagePostamble(XmlDictionaryWriter writer);
    protected virtual IAsyncResult OnBeginWriteMessage(XmlDictionaryWriter writer, AsyncCallback callback, object state);
    protected virtual void OnEndWriteMessage(IAsyncResult result);
    private void WriteSharedHeaderPrefixes(XmlDictionaryWriter writer);
}
public abstract class System.ServiceModel.Channels.MessageBuffer : object {
    public int BufferSize { get; }
    public string MessageContentType { get; }
    public abstract virtual int get_BufferSize();
    private sealed virtual override void System.IDisposable.Dispose();
    public abstract virtual void Close();
    public virtual void WriteMessage(Stream stream);
    public virtual string get_MessageContentType();
    public abstract virtual Message CreateMessage();
    internal Exception CreateBufferDisposedException();
}
internal abstract class System.ServiceModel.Channels.MessageContent : HttpContent {
    protected Message _message;
    protected MessageEncoder _messageEncoder;
    protected BufferManager _bufferManager;
    protected Stream _stream;
    private bool _disposed;
    protected TaskCompletionSource`1<bool> _writeCompletedTcs;
    public Message Message { get; }
    internal Task WriteCompletionTask { get; }
    public MessageContent(Message message, MessageEncoder messageEncoder, BufferManager bufferManager);
    public Message get_Message();
    internal Task get_WriteCompletionTask();
    private void PrepareContentHeaders();
    private bool SetContentType(string contentType);
    protected virtual void Dispose(bool disposing);
    internal static HttpContent Create(HttpChannelFactory`1<IRequestChannel> factory, Message request, TimeoutHelper _timeoutHelper);
}
public abstract class System.ServiceModel.Channels.MessageEncoder : object {
    public string ContentType { get; }
    public string MediaType { get; }
    public MessageVersion MessageVersion { get; }
    public abstract virtual string get_ContentType();
    public abstract virtual string get_MediaType();
    public abstract virtual MessageVersion get_MessageVersion();
    public virtual T GetProperty();
    public Message ReadMessage(Stream stream, int maxSizeOfHeaders);
    public virtual Task`1<Message> ReadMessageAsync(Stream stream, int maxSizeOfHeaders, string contentType);
    public virtual Task`1<Message> ReadMessageAsync(ArraySegment`1<byte> buffer, BufferManager bufferManager, string contentType);
    public abstract virtual Message ReadMessage(Stream stream, int maxSizeOfHeaders, string contentType);
    public Message ReadMessage(ArraySegment`1<byte> buffer, BufferManager bufferManager);
    public abstract virtual Message ReadMessage(ArraySegment`1<byte> buffer, BufferManager bufferManager, string contentType);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.MessageEncoder/<BufferMessageStreamAsync>d__13")]
internal Task`1<ArraySegment`1<byte>> BufferMessageStreamAsync(Stream stream, BufferManager bufferManager, int maxBufferSize, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.MessageEncoder/<ReadMessageAsync>d__14")]
internal virtual Task`1<Message> ReadMessageAsync(Stream stream, BufferManager bufferManager, int maxBufferSize, string contentType, CancellationToken cancellationToken);
    public virtual string ToString();
    public abstract virtual void WriteMessage(Message message, Stream stream);
    public virtual IAsyncResult BeginWriteMessage(Message message, Stream stream, AsyncCallback callback, object state);
    public virtual void EndWriteMessage(IAsyncResult result);
    public ArraySegment`1<byte> WriteMessage(Message message, int maxMessageSize, BufferManager bufferManager);
    public abstract virtual ArraySegment`1<byte> WriteMessage(Message message, int maxMessageSize, BufferManager bufferManager, int messageOffset);
    public virtual Task WriteMessageAsync(Message message, Stream stream);
    public virtual Task`1<ArraySegment`1<byte>> WriteMessageAsync(Message message, int maxMessageSize, BufferManager bufferManager, int messageOffset);
    public virtual bool IsContentTypeSupported(string contentType);
    internal bool IsContentTypeSupported(string contentType, string supportedContentType, string supportedMediaType);
    internal virtual bool IsCharSetSupported(string charset);
    internal void ThrowIfMismatchedMessageVersion(Message message);
}
internal static class System.ServiceModel.Channels.MessageEncoderCompressionHandler : object {
    internal static string GZipContentEncoding;
    internal static string DeflateContentEncoding;
    private static int DecompressBlockSize;
    internal static void DecompressBuffer(ArraySegment`1& buffer, BufferManager bufferManager, CompressionFormat compressionFormat, long maxReceivedMessageSize);
    internal static void CompressBuffer(ArraySegment`1& buffer, BufferManager bufferManager, CompressionFormat compressionFormat);
    internal static Stream GetDecompressStream(Stream compressedStream, CompressionFormat compressionFormat);
    internal static Stream GetCompressStream(Stream uncompressedStream, CompressionFormat compressionFormat);
}
public abstract class System.ServiceModel.Channels.MessageEncoderFactory : object {
    public MessageEncoder Encoder { get; }
    public MessageVersion MessageVersion { get; }
    public abstract virtual MessageEncoder get_Encoder();
    public abstract virtual MessageVersion get_MessageVersion();
    public virtual MessageEncoder CreateSessionEncoder();
}
public abstract class System.ServiceModel.Channels.MessageEncodingBindingElement : BindingElement {
    public MessageVersion MessageVersion { get; public set; }
    internal bool IsWsdlExportable { get; }
    protected MessageEncodingBindingElement(MessageEncodingBindingElement elementToBeCloned);
    public abstract virtual MessageVersion get_MessageVersion();
    public abstract virtual void set_MessageVersion(MessageVersion value);
    internal virtual bool get_IsWsdlExportable();
    internal IChannelFactory`1<TChannel> InternalBuildChannelFactory(BindingContext context);
    internal bool InternalCanBuildChannelFactory(BindingContext context);
    public abstract virtual MessageEncoderFactory CreateMessageEncoderFactory();
    public virtual T GetProperty(BindingContext context);
    internal virtual bool CheckEncodingVersion(EnvelopeVersion version);
    internal virtual bool IsMatch(BindingElement b);
}
public abstract class System.ServiceModel.Channels.MessageFault : object {
    private static MessageFault s_defaultMessageFault;
    internal static MessageFault Default { get; }
    public string Actor { get; }
    public FaultCode Code { get; }
    public bool IsMustUnderstandFault { get; }
    public string Node { get; }
    public bool HasDetail { get; }
    public FaultReason Reason { get; }
    public static MessageFault CreateFault(FaultCode code, string reason);
    public static MessageFault CreateFault(FaultCode code, FaultReason reason);
    public static MessageFault CreateFault(FaultCode code, FaultReason reason, object detail);
    public static MessageFault CreateFault(FaultCode code, FaultReason reason, object detail, XmlObjectSerializer serializer);
    public static MessageFault CreateFault(FaultCode code, FaultReason reason, object detail, XmlObjectSerializer serializer, string actor);
    public static MessageFault CreateFault(FaultCode code, FaultReason reason, object detail, XmlObjectSerializer serializer, string actor, string node);
    public static MessageFault CreateFault(Message message, int maxBufferSize);
    internal static MessageFault get_Default();
    public virtual string get_Actor();
    public abstract virtual FaultCode get_Code();
    public bool get_IsMustUnderstandFault();
    public virtual string get_Node();
    public abstract virtual bool get_HasDetail();
    public abstract virtual FaultReason get_Reason();
    public T GetDetail();
    public T GetDetail(XmlObjectSerializer serializer);
    public XmlDictionaryReader GetReaderAtDetailContents();
    protected virtual void OnWriteDetail(XmlDictionaryWriter writer, EnvelopeVersion version);
    protected virtual void OnWriteStartDetail(XmlDictionaryWriter writer, EnvelopeVersion version);
    protected abstract virtual void OnWriteDetailContents(XmlDictionaryWriter writer);
    protected virtual XmlDictionaryReader OnGetReaderAtDetailContents();
    public static bool WasHeaderNotUnderstood(MessageHeaders headers, string name, string ns);
    public void WriteTo(XmlWriter writer, EnvelopeVersion version);
    public void WriteTo(XmlDictionaryWriter writer, EnvelopeVersion version);
    private void WriteToNone(XmlDictionaryWriter writer);
    private void WriteTo12Driver(XmlDictionaryWriter writer, EnvelopeVersion version);
    private void WriteFaultCode12Driver(XmlDictionaryWriter writer, FaultCode faultCode, EnvelopeVersion version);
    private void WriteTo12(XmlDictionaryWriter writer);
    private void WriteTo11(XmlDictionaryWriter writer);
}
public abstract class System.ServiceModel.Channels.MessageHeader : MessageHeaderInfo {
    private static bool DefaultRelayValue;
    private static bool DefaultMustUnderstandValue;
    private static string DefaultActorValue;
    public string Actor { get; }
    public bool IsReferenceParameter { get; }
    public bool MustUnderstand { get; }
    public bool Relay { get; }
    public virtual string get_Actor();
    public virtual bool get_IsReferenceParameter();
    public virtual bool get_MustUnderstand();
    public virtual bool get_Relay();
    public virtual bool IsMessageVersionSupported(MessageVersion messageVersion);
    public virtual string ToString();
    public void WriteHeader(XmlWriter writer, MessageVersion messageVersion);
    public void WriteHeader(XmlDictionaryWriter writer, MessageVersion messageVersion);
    public void WriteStartHeader(XmlDictionaryWriter writer, MessageVersion messageVersion);
    protected virtual void OnWriteStartHeader(XmlDictionaryWriter writer, MessageVersion messageVersion);
    public void WriteHeaderContents(XmlDictionaryWriter writer, MessageVersion messageVersion);
    protected abstract virtual void OnWriteHeaderContents(XmlDictionaryWriter writer, MessageVersion messageVersion);
    protected void WriteHeaderAttributes(XmlDictionaryWriter writer, MessageVersion messageVersion);
    public static MessageHeader CreateHeader(string name, string ns, object value);
    public static MessageHeader CreateHeader(string name, string ns, object value, bool mustUnderstand);
    public static MessageHeader CreateHeader(string name, string ns, object value, bool mustUnderstand, string actor);
    public static MessageHeader CreateHeader(string name, string ns, object value, bool mustUnderstand, string actor, bool relay);
    public static MessageHeader CreateHeader(string name, string ns, object value, XmlObjectSerializer serializer);
    public static MessageHeader CreateHeader(string name, string ns, object value, XmlObjectSerializer serializer, bool mustUnderstand);
    public static MessageHeader CreateHeader(string name, string ns, object value, XmlObjectSerializer serializer, bool mustUnderstand, string actor);
    public static MessageHeader CreateHeader(string name, string ns, object value, XmlObjectSerializer serializer, bool mustUnderstand, string actor, bool relay);
    internal static void GetHeaderAttributes(XmlDictionaryReader reader, MessageVersion version, String& actor, Boolean& mustUnderstand, Boolean& relay, Boolean& isReferenceParameter);
    private static bool ToBoolean(string value);
}
public abstract class System.ServiceModel.Channels.MessageHeaderInfo : object {
    public string Actor { get; }
    public bool IsReferenceParameter { get; }
    public string Name { get; }
    public string Namespace { get; }
    public bool MustUnderstand { get; }
    public bool Relay { get; }
    public abstract virtual string get_Actor();
    public abstract virtual bool get_IsReferenceParameter();
    public abstract virtual string get_Name();
    public abstract virtual string get_Namespace();
    public abstract virtual bool get_MustUnderstand();
    public abstract virtual bool get_Relay();
}
[DefaultMemberAttribute("Item")]
public class System.ServiceModel.Channels.MessageHeaders : object {
    private int _collectionVersion;
    private int _headerCount;
    private Header[] _headers;
    private MessageVersion _version;
    private IBufferedMessageData _bufferedMessageData;
    private UnderstoodHeaders _understoodHeaders;
    private static int InitialHeaderCount;
    private static int MaxRecycledArrayLength;
    private static XmlDictionaryString[] s_localNames;
    internal static string WildcardAction;
    private static int MaxBufferedHeaderNodes;
    private static int MaxBufferedHeaderAttributes;
    private int _nodeCount;
    private int _attrCount;
    private bool _understoodHeadersModified;
    public string Action { get; public set; }
    internal bool CanRecycle { get; }
    internal bool ContainsOnlyBufferedMessageHeaders { get; }
    internal int CollectionVersion { get; }
    public int Count { get; }
    public EndpointAddress FaultTo { get; public set; }
    public EndpointAddress From { get; public set; }
    internal bool HasMustUnderstandBeenModified { get; }
    public UniqueId MessageId { get; public set; }
    public MessageVersion MessageVersion { get; }
    public UniqueId RelatesTo { get; public set; }
    public EndpointAddress ReplyTo { get; public set; }
    public Uri To { get; public set; }
    public UnderstoodHeaders UnderstoodHeaders { get; }
    public MessageHeaderInfo Item { get; }
    public MessageHeaders(MessageVersion version, int initialSize);
    public MessageHeaders(MessageVersion version);
    internal MessageHeaders(MessageVersion version, XmlDictionaryReader reader, XmlAttributeHolder[] envelopeAttributes, XmlAttributeHolder[] headerAttributes, Int32& maxSizeOfHeaders);
    internal MessageHeaders(MessageVersion version, XmlDictionaryReader reader, IBufferedMessageData bufferedMessageData, RecycledMessageState recycledMessageState, Boolean[] understoodHeaders, bool understoodHeadersModified);
    internal MessageHeaders(MessageVersion version, MessageHeaders headers, IBufferedMessageData bufferedMessageData);
    public MessageHeaders(MessageHeaders collection);
    public string get_Action();
    public void set_Action(string value);
    internal bool get_CanRecycle();
    internal bool get_ContainsOnlyBufferedMessageHeaders();
    internal int get_CollectionVersion();
    public int get_Count();
    public EndpointAddress get_FaultTo();
    public void set_FaultTo(EndpointAddress value);
    public EndpointAddress get_From();
    public void set_From(EndpointAddress value);
    internal bool get_HasMustUnderstandBeenModified();
    public UniqueId get_MessageId();
    public void set_MessageId(UniqueId value);
    public MessageVersion get_MessageVersion();
    public UniqueId get_RelatesTo();
    public void set_RelatesTo(UniqueId value);
    public EndpointAddress get_ReplyTo();
    public void set_ReplyTo(EndpointAddress value);
    public Uri get_To();
    public void set_To(Uri value);
    public UnderstoodHeaders get_UnderstoodHeaders();
    public MessageHeaderInfo get_Item(int index);
    public void Add(MessageHeader header);
    internal void AddActionHeader(ActionHeader actionHeader);
    internal void AddMessageIDHeader(MessageIDHeader messageIDHeader);
    internal void AddRelatesToHeader(RelatesToHeader relatesToHeader);
    internal void AddReplyToHeader(ReplyToHeader replyToHeader);
    internal void AddToHeader(ToHeader toHeader);
    private void Add(MessageHeader header, HeaderKind kind);
    private void AddHeader(Header header);
    internal void AddUnderstood(int i);
    internal void AddUnderstood(MessageHeaderInfo headerInfo);
    private void CaptureBufferedHeaders();
    private void CaptureBufferedHeaders(int exceptIndex);
    private BufferedHeader CaptureBufferedHeader(XmlDictionaryReader reader, MessageHeaderInfo headerInfo);
    private BufferedHeader CaptureBufferedHeader(IBufferedMessageData bufferedMessageData, MessageHeaderInfo headerInfo, int bufferedMessageHeaderIndex);
    private BufferedHeader CaptureWriteableHeader(MessageHeader writeableHeader);
    public void Clear();
    public void CopyHeaderFrom(Message message, int headerIndex);
    public void CopyHeaderFrom(MessageHeaders collection, int headerIndex);
    public void CopyHeadersFrom(Message message);
    public void CopyHeadersFrom(MessageHeaders collection);
    public void CopyTo(MessageHeaderInfo[] array, int index);
    private Exception CreateDuplicateHeaderException(HeaderKind kind);
    public int FindHeader(string name, string ns);
    private int FindAddressingHeader(string name, string ns);
    private int FindNonAddressingHeader(string name, string ns, String[] actors);
    public int FindHeader(string name, string ns, String[] actors);
    private int FindHeaderProperty(HeaderKind kind);
    private int FindRelatesTo(Uri relationshipType, UniqueId& messageId);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IEnumerator`1<MessageHeaderInfo> GetEnumerator();
    private IEnumerator`1<MessageHeaderInfo> GetEnumerator(MessageHeaderInfo[] headers);
    internal IEnumerator`1<MessageHeaderInfo> GetUnderstoodEnumerator();
    private static XmlDictionaryReader GetBufferedMessageHeaderReaderAtHeaderContents(IBufferedMessageData bufferedMessageData);
    private XmlDictionaryReader GetBufferedMessageHeaderReader(IBufferedMessageData bufferedMessageData, int bufferedMessageHeaderIndex);
    private void Skip(XmlDictionaryReader reader);
    public T GetHeader(string name, string ns);
    public T GetHeader(string name, string ns, String[] actors);
    public T GetHeader(string name, string ns, XmlObjectSerializer serializer);
    public T GetHeader(int index);
    public T GetHeader(int index, XmlObjectSerializer serializer);
    private HeaderKind GetHeaderKind(MessageHeaderInfo headerInfo);
    private void ValidateHeaderKind(HeaderKind headerKind);
    public XmlDictionaryReader GetReaderAtHeader(int headerIndex);
    internal UniqueId GetRelatesTo(Uri relationshipType);
    private void GetRelatesToValues(int index, Uri& relationshipType, UniqueId& messageId);
    internal String[] GetHeaderAttributes(string localName, string ns);
    internal MessageHeader GetMessageHeader(int index);
    internal Collection`1<MessageHeaderInfo> GetHeadersNotUnderstood();
    public bool HaveMandatoryHeadersBeenUnderstood();
    public bool HaveMandatoryHeadersBeenUnderstood(String[] actors);
    internal void Init(MessageVersion version, int initialSize);
    internal void Init(MessageVersion version);
    internal void Init(MessageVersion version, XmlDictionaryReader reader, IBufferedMessageData bufferedMessageData, RecycledMessageState recycledMessageState, Boolean[] understoodHeaders, bool understoodHeadersModified);
    public void Insert(int headerIndex, MessageHeader header);
    private void Insert(int headerIndex, MessageHeader header, HeaderKind kind);
    private void InsertHeader(int headerIndex, Header header);
    internal bool IsUnderstood(int i);
    internal bool IsUnderstood(MessageHeaderInfo headerInfo);
    private void ReadBufferedHeader(XmlDictionaryReader reader, RecycledMessageState recycledMessageState, XmlDictionaryString[] localNames, bool understood);
    internal void Recycle(HeaderInfoCache headerInfoCache);
    internal void RemoveUnderstood(MessageHeaderInfo headerInfo);
    public void RemoveAll(string name, string ns);
    public void RemoveAt(int headerIndex);
    internal void ReplaceAt(int headerIndex, MessageHeader header);
    private void ReplaceAt(int headerIndex, MessageHeader header, HeaderKind kind);
    public void SetAction(XmlDictionaryString action);
    internal void SetActionHeader(ActionHeader actionHeader);
    internal void SetFaultToHeader(FaultToHeader faultToHeader);
    internal void SetFromHeader(FromHeader fromHeader);
    internal void SetMessageIDHeader(MessageIDHeader messageIDHeader);
    internal void SetRelatesTo(Uri relationshipType, UniqueId messageId);
    private void SetRelatesTo(Uri relationshipType, RelatesToHeader relatesToHeader);
    internal void SetReplyToHeader(ReplyToHeader replyToHeader);
    internal void SetToHeader(ToHeader toHeader);
    private void SetHeaderProperty(HeaderKind kind, MessageHeader header);
    public void WriteHeader(int headerIndex, XmlWriter writer);
    public void WriteHeader(int headerIndex, XmlDictionaryWriter writer);
    public void WriteStartHeader(int headerIndex, XmlWriter writer);
    public void WriteStartHeader(int headerIndex, XmlDictionaryWriter writer);
    public void WriteHeaderContents(int headerIndex, XmlWriter writer);
    public void WriteHeaderContents(int headerIndex, XmlDictionaryWriter writer);
    private static void TraceUnderstood(MessageHeaderInfo info);
    private void WriteBufferedMessageHeader(IBufferedMessageData bufferedMessageData, int bufferedMessageHeaderIndex, XmlWriter writer);
    private void WriteStartBufferedMessageHeader(IBufferedMessageData bufferedMessageData, int bufferedMessageHeaderIndex, XmlWriter writer);
    private void WriteBufferedMessageHeaderContents(IBufferedMessageData bufferedMessageData, int bufferedMessageHeaderIndex, XmlWriter writer);
}
internal class System.ServiceModel.Channels.MessageIDHeader : AddressingHeader {
    private UniqueId _messageId;
    private static bool mustUnderstandValue;
    public XmlDictionaryString DictionaryName { get; }
    public UniqueId MessageId { get; }
    public bool MustUnderstand { get; }
    private MessageIDHeader(UniqueId messageId, AddressingVersion version);
    public virtual XmlDictionaryString get_DictionaryName();
    public UniqueId get_MessageId();
    public virtual bool get_MustUnderstand();
    public static MessageIDHeader Create(UniqueId messageId, AddressingVersion addressingVersion);
    protected virtual void OnWriteHeaderContents(XmlDictionaryWriter writer, MessageVersion messageVersion);
    public static UniqueId ReadHeaderValue(XmlDictionaryReader reader, AddressingVersion version);
    public static MessageIDHeader ReadHeader(XmlDictionaryReader reader, AddressingVersion version, string actor, bool mustUnderstand, bool relay);
}
internal class System.ServiceModel.Channels.MessagePatterns : object {
    private static Byte[] s_commonFragment;
    private static Byte[] s_requestFragment1;
    private static Byte[] s_requestFragment2;
    private static Byte[] s_responseFragment1;
    private static Byte[] s_responseFragment2;
    private static Byte[] s_bodyFragment;
    private static int ToValueSessionKey;
    private IXmlDictionary _dictionary;
    private XmlBinaryReaderSession _readerSession;
    private ToHeader _toHeader;
    private MessageVersion _messageVersion;
    private static MessagePatterns();
    public MessagePatterns(IXmlDictionary dictionary, XmlBinaryReaderSession readerSession, MessageVersion messageVersion);
    public Message TryCreateMessage(Byte[] buffer, int offset, int size, BufferManager bufferManager, BufferedMessageData messageData);
    private bool TryLookupKey(int key, XmlDictionaryString& result);
}
[DefaultMemberAttribute("Item")]
public class System.ServiceModel.Channels.MessageProperties : object {
    private Property[] _properties;
    private int _propertyCount;
    private MessageEncoder _encoder;
    private Uri _via;
    private object _allowOutputBatching;
    private SecurityMessageProperty _security;
    private bool _disposed;
    private static int InitialPropertyCount;
    private static int MaxRecycledArrayLength;
    private static string ViaKey;
    private static string AllowOutputBatchingKey;
    private static string SecurityKey;
    private static string EncoderKey;
    private static int NotFoundIndex;
    private static int ViaIndex;
    private static int AllowOutputBatchingIndex;
    private static int SecurityIndex;
    private static int EncoderIndex;
    private static object s_trueBool;
    private static object s_falseBool;
    public object Item { get; public set; }
    internal bool CanRecycle { get; }
    public int Count { get; }
    public MessageEncoder Encoder { get; public set; }
    public bool AllowOutputBatching { get; public set; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public ICollection`1<string> Keys { get; }
    public SecurityMessageProperty Security { get; public set; }
    public ICollection`1<object> Values { get; }
    public Uri Via { get; public set; }
    public MessageProperties(MessageProperties properties);
    internal MessageProperties(KeyValuePair`2[] array);
    private static MessageProperties();
    private void ThrowDisposed();
    public sealed virtual object get_Item(string name);
    public sealed virtual void set_Item(string name, object value);
    internal bool get_CanRecycle();
    public sealed virtual int get_Count();
    public MessageEncoder get_Encoder();
    public void set_Encoder(MessageEncoder value);
    public bool get_AllowOutputBatching();
    public void set_AllowOutputBatching(bool value);
    public bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual ICollection`1<string> get_Keys();
    public SecurityMessageProperty get_Security();
    public void set_Security(SecurityMessageProperty value);
    public sealed virtual ICollection`1<object> get_Values();
    public Uri get_Via();
    public void set_Via(Uri value);
    public sealed virtual void Add(string name, object property);
    private void AdjustPropertyCount(bool oldValueIsNull, bool newValueIsNull);
    public sealed virtual void Clear();
    public void CopyProperties(MessageProperties properties);
    internal void MergeProperties(MessageProperties properties);
    internal void CopyProperties(KeyValuePair`2[] array);
    public sealed virtual bool ContainsKey(string name);
    private object CreateCopyOfPropertyValue(object propertyValue);
    public sealed virtual void Dispose();
    private int FindProperty(string name);
    internal void Recycle();
    public sealed virtual bool Remove(string name);
    public sealed virtual bool TryGetValue(string name, Object& value);
    internal bool TryGetValue(string name, TProperty& property);
    internal TProperty GetValue(string name);
    internal TProperty GetValue(string name, bool ensureTypeMatch);
    private void UpdateProperty(string name, object value, bool mustNotExist);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.CopyTo(KeyValuePair`2[] array, int index);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.Add(KeyValuePair`2<string, object> pair);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.Contains(KeyValuePair`2<string, object> pair);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IEnumerator`1<KeyValuePair`2<string, object>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.GetEnumerator();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.Remove(KeyValuePair`2<string, object> pair);
}
public enum System.ServiceModel.Channels.MessageState : Enum {
    public int value__;
    public static MessageState Created;
    public static MessageState Read;
    public static MessageState Written;
    public static MessageState Copied;
    public static MessageState Closed;
}
public class System.ServiceModel.Channels.MessageVersion : object {
    private EnvelopeVersion _envelope;
    private AddressingVersion _addressing;
    private static MessageVersion s_none;
    private static MessageVersion s_soap11;
    private static MessageVersion s_soap12;
    private static MessageVersion s_soap11Addressing10;
    private static MessageVersion s_soap12Addressing10;
    private static string MessageVersionToStringFormat;
    public AddressingVersion Addressing { get; }
    public static MessageVersion Default { get; }
    public EnvelopeVersion Envelope { get; }
    public static MessageVersion None { get; }
    public static MessageVersion Soap12WSAddressing10 { get; }
    public static MessageVersion Soap11WSAddressing10 { get; }
    public static MessageVersion Soap11 { get; }
    public static MessageVersion Soap12 { get; }
    private static MessageVersion();
    private MessageVersion(EnvelopeVersion envelopeVersion, AddressingVersion addressingVersion);
    public static MessageVersion CreateVersion(EnvelopeVersion envelopeVersion);
    public static MessageVersion CreateVersion(EnvelopeVersion envelopeVersion, AddressingVersion addressingVersion);
    public AddressingVersion get_Addressing();
    public static MessageVersion get_Default();
    public EnvelopeVersion get_Envelope();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static MessageVersion get_None();
    public static MessageVersion get_Soap12WSAddressing10();
    public static MessageVersion get_Soap11WSAddressing10();
    public static MessageVersion get_Soap11();
    public static MessageVersion get_Soap12();
    public virtual string ToString();
    internal bool IsMatch(MessageVersion messageVersion);
}
internal class System.ServiceModel.Channels.MethodCall : object {
    [CompilerGeneratedAttribute]
private MethodBase <MethodBase>k__BackingField;
    [CompilerGeneratedAttribute]
private Object[] <Args>k__BackingField;
    public MethodBase MethodBase { get; private set; }
    public Object[] Args { get; private set; }
    public MethodCall(Object[] args);
    public MethodCall(MethodBase methodBase, Object[] args);
    [CompilerGeneratedAttribute]
public MethodBase get_MethodBase();
    [CompilerGeneratedAttribute]
private void set_MethodBase(MethodBase value);
    [CompilerGeneratedAttribute]
public Object[] get_Args();
    [CompilerGeneratedAttribute]
private void set_Args(Object[] value);
}
public class System.ServiceModel.Channels.NamedPipeSettings : object {
    [CompilerGeneratedAttribute]
private ApplicationContainerSettings <ApplicationContainerSettings>k__BackingField;
    public ApplicationContainerSettings ApplicationContainerSettings { get; private set; }
    private NamedPipeSettings(NamedPipeSettings elementToBeCloned);
    [CompilerGeneratedAttribute]
public ApplicationContainerSettings get_ApplicationContainerSettings();
    [CompilerGeneratedAttribute]
private void set_ApplicationContainerSettings(ApplicationContainerSettings value);
    internal NamedPipeSettings Clone();
    internal bool IsMatch(NamedPipeSettings pipeSettings);
}
public static class System.ServiceModel.Channels.NetHttpBindingDefaults : object {
    public static NetHttpMessageEncoding MessageEncoding;
    public static WebSocketTransportUsage TransportUsage;
}
public static class System.ServiceModel.Channels.NetTcpDefaults : object {
    public static MessageCredentialType MessageSecurityClientCredentialType;
}
internal class System.ServiceModel.Channels.NullMessage : StringMessage {
}
public static class System.ServiceModel.Channels.OneWayDefaults : object {
    public static string IdleTimeoutString;
    public static int MaxOutboundChannelsPerEndpoint;
    public static string LeaseTimeoutString;
    public static int MaxAcceptedChannels;
    public static bool PacketRoutable;
    public static TimeSpan IdleTimeout { get; }
    public static TimeSpan LeaseTimeout { get; }
    public static TimeSpan get_IdleTimeout();
    public static TimeSpan get_LeaseTimeout();
}
public abstract class System.ServiceModel.Channels.OutputChannel : ChannelBase {
    public EndpointAddress RemoteAddress { get; }
    public Uri Via { get; }
    protected OutputChannel(ChannelManagerBase manager);
    public abstract virtual EndpointAddress get_RemoteAddress();
    public abstract virtual Uri get_Via();
    public sealed virtual IAsyncResult BeginSend(Message message, AsyncCallback callback, object state);
    public sealed virtual IAsyncResult BeginSend(Message message, TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual void EndSend(IAsyncResult result);
    public virtual T GetProperty();
    protected abstract virtual void OnSend(Message message, TimeSpan timeout);
    protected abstract virtual Task OnSendAsync(Message message, TimeSpan timeout);
    public sealed virtual void Send(Message message);
    public sealed virtual void Send(Message message, TimeSpan timeout);
    private void EmitTrace(Message message);
    protected virtual void AddHeadersTo(Message message);
}
internal static class System.ServiceModel.Channels.PeerStrings : object {
    public static string Namespace;
    public static string HopCountElementName;
    public static string HopCountElementNamespace;
}
internal class System.ServiceModel.Channels.PreReadConnection : DelegatingConnection {
    private int _asyncBytesRead;
    private Byte[] _preReadData;
    private int _preReadOffset;
    private int _preReadCount;
    public PreReadConnection(IConnection innerConnection, Byte[] initialData);
    public PreReadConnection(IConnection innerConnection, Byte[] initialData, int initialOffset, int initialSize);
    public void AddPreReadData(Byte[] initialData, int initialOffset, int initialSize);
    public virtual int Read(Byte[] buffer, int offset, int size, TimeSpan timeout);
    public virtual AsyncCompletionResult BeginRead(int offset, int size, TimeSpan timeout, Action`1<object> callback, object state);
    public virtual int EndRead();
}
internal class System.ServiceModel.Channels.ProducerConsumerStream : Stream {
    private TaskCompletionSource`1<WriteBufferWrapper> _buffer;
    private TaskCompletionSource`1<int> _dataAvail;
    private WriteBufferWrapper _currentBuffer;
    private bool _disposed;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.ProducerConsumerStream/<ReadAsync>d__13")]
public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual void Write(Byte[] buffer, int offset, int count);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.ProducerConsumerStream/<WriteAsync>d__15")]
public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    protected virtual void Dispose(bool disposing);
    private static void CancelAndDispose(object state);
}
internal abstract class System.ServiceModel.Channels.QueuedObjectPool`1 : object {
    private Queue`1<T> _objectQueue;
    private bool _isClosed;
    private int _batchAllocCount;
    private int _maxFreeCount;
    private object ThisLock { get; }
    protected void Initialize(int batchAllocCount, int maxFreeCount);
    private object get_ThisLock();
    public virtual bool Return(T value);
    public T Take();
    public void Close();
    protected virtual void CleanupItem(T item);
    protected abstract virtual T Create();
    private void AllocObjects();
}
internal abstract class System.ServiceModel.Channels.ReadableMessageHeader : MessageHeader {
    public abstract virtual XmlDictionaryReader GetHeaderReader();
    protected virtual void OnWriteStartHeader(XmlDictionaryWriter writer, MessageVersion messageVersion);
    protected virtual void OnWriteHeaderContents(XmlDictionaryWriter writer, MessageVersion messageVersion);
}
internal class System.ServiceModel.Channels.ReceivedFault : MessageFault {
    private FaultCode _code;
    private FaultReason _reason;
    private string _actor;
    private string _node;
    private XmlBuffer _detail;
    private bool _hasDetail;
    private EnvelopeVersion _receivedVersion;
    public string Actor { get; }
    public FaultCode Code { get; }
    public bool HasDetail { get; }
    public string Node { get; }
    public FaultReason Reason { get; }
    private ReceivedFault(FaultCode code, FaultReason reason, string actor, string node, XmlBuffer detail, EnvelopeVersion version);
    public virtual string get_Actor();
    public virtual FaultCode get_Code();
    public virtual bool get_HasDetail();
    public virtual string get_Node();
    public virtual FaultReason get_Reason();
    private bool InferHasDetail(XmlBuffer detail);
    protected virtual void OnWriteDetail(XmlDictionaryWriter writer, EnvelopeVersion version);
    protected virtual void OnWriteStartDetail(XmlDictionaryWriter writer, EnvelopeVersion version);
    protected virtual void OnWriteDetailContents(XmlDictionaryWriter writer);
    protected virtual XmlDictionaryReader OnGetReaderAtDetailContents();
    private bool ShouldWriteDetailAttribute(EnvelopeVersion targetVersion, string prefix, string localName, string attributeValue);
    public static ReceivedFault CreateFaultNone(XmlDictionaryReader reader, int maxBufferSize);
    private static ReceivedFault CreateFault12Driver(XmlDictionaryReader reader, int maxBufferSize, EnvelopeVersion version);
    private static FaultCode ReadFaultCode12Driver(XmlDictionaryReader reader, EnvelopeVersion version);
    public static ReceivedFault CreateFault12(XmlDictionaryReader reader, int maxBufferSize);
    private static FaultReasonText ReadTranslation12(XmlDictionaryReader reader);
    public static ReceivedFault CreateFault11(XmlDictionaryReader reader, int maxBufferSize);
}
internal abstract class System.ServiceModel.Channels.ReceivedMessage : Message {
    private bool _isFault;
    private bool _isEmpty;
    public bool IsEmpty { get; }
    public bool IsFault { get; }
    public virtual bool get_IsEmpty();
    public virtual bool get_IsFault();
    protected static bool HasHeaderElement(XmlDictionaryReader reader, EnvelopeVersion envelopeVersion);
    protected virtual void OnWriteBodyContents(XmlDictionaryWriter writer);
    protected bool ReadStartBody(XmlDictionaryReader reader);
    protected static EnvelopeVersion ReadStartEnvelope(XmlDictionaryReader reader);
    protected static void VerifyStartBody(XmlDictionaryReader reader, EnvelopeVersion version);
}
internal class System.ServiceModel.Channels.RecycledMessageState : object {
    private MessageHeaders _recycledHeaders;
    private MessageProperties _recycledProperties;
    private UriCache _uriCache;
    private HeaderInfoCache _headerInfoCache;
    public HeaderInfoCache HeaderInfoCache { get; }
    public UriCache UriCache { get; }
    public HeaderInfoCache get_HeaderInfoCache();
    public UriCache get_UriCache();
    public MessageProperties TakeProperties();
    public void ReturnProperties(MessageProperties properties);
    public MessageHeaders TakeHeaders();
    public void ReturnHeaders(MessageHeaders headers);
}
internal class System.ServiceModel.Channels.RelatesToHeader : AddressingHeader {
    private UniqueId _messageId;
    private static bool mustUnderstandValue;
    internal static Uri ReplyRelationshipType;
    public XmlDictionaryString DictionaryName { get; }
    public UniqueId UniqueId { get; }
    public bool MustUnderstand { get; }
    public Uri RelationshipType { get; }
    private RelatesToHeader(UniqueId messageId, AddressingVersion version);
    private static RelatesToHeader();
    public virtual XmlDictionaryString get_DictionaryName();
    public UniqueId get_UniqueId();
    public virtual bool get_MustUnderstand();
    public virtual Uri get_RelationshipType();
    public static RelatesToHeader Create(UniqueId messageId, AddressingVersion addressingVersion);
    public static RelatesToHeader Create(UniqueId messageId, AddressingVersion addressingVersion, Uri relationshipType);
    protected virtual void OnWriteHeaderContents(XmlDictionaryWriter writer, MessageVersion messageVersion);
    public static void ReadHeaderValue(XmlDictionaryReader reader, AddressingVersion version, Uri& relationshipType, UniqueId& messageId);
    public static RelatesToHeader ReadHeader(XmlDictionaryReader reader, AddressingVersion version, string actor, bool mustUnderstand, bool relay);
}
internal class System.ServiceModel.Channels.ReplyToHeader : AddressingHeader {
    private EndpointAddress _replyTo;
    private static bool mustUnderstandValue;
    private static ReplyToHeader s_anonymousReplyToHeader10;
    public EndpointAddress ReplyTo { get; }
    public XmlDictionaryString DictionaryName { get; }
    public bool MustUnderstand { get; }
    public static ReplyToHeader AnonymousReplyTo10 { get; }
    private ReplyToHeader(EndpointAddress replyTo, AddressingVersion version);
    public EndpointAddress get_ReplyTo();
    public virtual XmlDictionaryString get_DictionaryName();
    public virtual bool get_MustUnderstand();
    public static ReplyToHeader get_AnonymousReplyTo10();
    public static ReplyToHeader Create(EndpointAddress replyTo, AddressingVersion addressingVersion);
    protected virtual void OnWriteHeaderContents(XmlDictionaryWriter writer, MessageVersion messageVersion);
    public static ReplyToHeader ReadHeader(XmlDictionaryReader reader, AddressingVersion version, string actor, bool mustUnderstand, bool relay);
    public static EndpointAddress ReadHeaderValue(XmlDictionaryReader reader, AddressingVersion version);
}
public abstract class System.ServiceModel.Channels.RequestChannel : ChannelBase {
    private bool _manualAddressing;
    private List`1<IRequestBase> _outstandingRequests;
    private EndpointAddress _to;
    private Uri _via;
    private TaskCompletionSource`1<object> _closedTcs;
    private bool _closed;
    private int _outstandRequestCloseCount;
    protected bool ManualAddressing { get; }
    public EndpointAddress RemoteAddress { get; }
    public Uri Via { get; }
    protected RequestChannel(ChannelManagerBase channelFactory, EndpointAddress to, Uri via, bool manualAddressing);
    protected bool get_ManualAddressing();
    public sealed virtual EndpointAddress get_RemoteAddress();
    public sealed virtual Uri get_Via();
    protected void AbortPendingRequests();
    private void FinishClose();
    private IRequestBase[] SetupWaitForPendingRequests();
    protected void WaitForPendingRequests(TimeSpan timeout);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.RequestChannel/<WaitForPendingRequestsAsync>d__18")]
protected internal Task WaitForPendingRequestsAsync(TimeSpan timeout);
    private IRequestBase[] CopyPendingRequests(bool createTcsIfNecessary);
    protected void FaultPendingRequests();
    public virtual T GetProperty();
    protected virtual void OnAbort();
    private void ReleaseRequest(IRequestBase request);
    private void TrackRequest(IRequestBase request);
    public sealed virtual IAsyncResult BeginRequest(Message message, AsyncCallback callback, object state);
    public sealed virtual IAsyncResult BeginRequest(Message message, TimeSpan timeout, AsyncCallback callback, object state);
    protected abstract virtual IAsyncRequest CreateAsyncRequest(Message message);
    public sealed virtual Message EndRequest(IAsyncResult result);
    public sealed virtual Message Request(Message message);
    public sealed virtual Message Request(Message message, TimeSpan timeout);
    public sealed virtual Task`1<Message> RequestAsync(Message message);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.RequestChannel/<RequestAsyncInternal>d__32")]
private Task`1<Message> RequestAsyncInternal(Message message, TimeSpan timeout);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.RequestChannel/<RequestAsync>d__33")]
public sealed virtual Task`1<Message> RequestAsync(Message message, TimeSpan timeout);
    protected virtual void AddHeadersTo(Message message);
}
public abstract class System.ServiceModel.Channels.RequestContext : object {
    public Message RequestMessage { get; }
    public abstract virtual Message get_RequestMessage();
    public abstract virtual void Abort();
    public abstract virtual void Close();
    public abstract virtual void Close(TimeSpan timeout);
    public abstract virtual void Reply(Message message);
    public abstract virtual void Reply(Message message, TimeSpan timeout);
    public abstract virtual IAsyncResult BeginReply(Message message, AsyncCallback callback, object state);
    public abstract virtual IAsyncResult BeginReply(Message message, TimeSpan timeout, AsyncCallback callback, object state);
    public abstract virtual void EndReply(IAsyncResult result);
    private sealed virtual override void System.IDisposable.Dispose();
    protected virtual void Dispose(bool disposing);
}
internal abstract class System.ServiceModel.Channels.RequestContextBase : RequestContext {
    private TimeSpan _defaultSendTimeout;
    private TimeSpan _defaultCloseTimeout;
    private CommunicationState _state;
    private Message _requestMessage;
    private Exception _requestMessageException;
    private bool _replySent;
    private bool _replyInitiated;
    private bool _aborted;
    private object _thisLock;
    public Message RequestMessage { get; }
    protected bool ReplyInitiated { get; }
    protected object ThisLock { get; }
    public bool Aborted { get; }
    public TimeSpan DefaultCloseTimeout { get; }
    public TimeSpan DefaultSendTimeout { get; }
    protected RequestContextBase(Message requestMessage, TimeSpan defaultCloseTimeout, TimeSpan defaultSendTimeout);
    public void ReInitialize(Message requestMessage);
    public virtual Message get_RequestMessage();
    protected void SetRequestMessage(Message requestMessage);
    protected void SetRequestMessage(Exception requestMessageException);
    protected bool get_ReplyInitiated();
    protected object get_ThisLock();
    public bool get_Aborted();
    public TimeSpan get_DefaultCloseTimeout();
    public TimeSpan get_DefaultSendTimeout();
    public virtual void Abort();
    public virtual void Close();
    public virtual void Close(TimeSpan timeout);
    protected virtual void Dispose(bool disposing);
    protected abstract virtual void OnAbort();
    protected abstract virtual void OnClose(TimeSpan timeout);
    protected abstract virtual void OnReply(Message message, TimeSpan timeout);
    protected abstract virtual IAsyncResult OnBeginReply(Message message, TimeSpan timeout, AsyncCallback callback, object state);
    protected abstract virtual void OnEndReply(IAsyncResult result);
    protected void ThrowIfInvalidReply();
    protected bool TryInitiateReply();
    public virtual IAsyncResult BeginReply(Message message, AsyncCallback callback, object state);
    public virtual IAsyncResult BeginReply(Message message, TimeSpan timeout, AsyncCallback callback, object state);
    public virtual void EndReply(IAsyncResult result);
    public virtual void Reply(Message message);
    public virtual void Reply(Message message, TimeSpan timeout);
    protected void SetReplySent();
}
internal class System.ServiceModel.Channels.RequestContextMessageProperty : object {
    private RequestContext _context;
    private object _thisLock;
    public static string Name { get; }
    public RequestContextMessageProperty(RequestContext context);
    public static string get_Name();
    private sealed virtual override void System.IDisposable.Dispose();
}
internal class System.ServiceModel.Channels.RequestReplyCorrelator : object {
    private Dictionary`2<Key, object> _states;
    private sealed virtual override void System.ServiceModel.Channels.IRequestReplyCorrelator.Add(Message request, T state);
    private sealed virtual override T System.ServiceModel.Channels.IRequestReplyCorrelator.Find(Message reply, bool remove);
    internal void RemoveRequest(ICorrelatorKey request);
    private UniqueId GetRelatesTo(Message reply);
    internal static bool AddressReply(Message reply, Message request);
    internal static bool AddressReply(Message reply, ReplyToInfo info);
    internal static ReplyToInfo ExtractReplyToInfo(Message message);
    internal static void PrepareRequest(Message request);
    internal static void PrepareReply(Message reply, UniqueId messageId);
    internal static void PrepareReply(Message reply, Message request);
}
public abstract class System.ServiceModel.Channels.SecurityBindingElement : BindingElement {
    internal static bool defaultIncludeTimestamp;
    internal static bool defaultAllowInsecureTransport;
    internal static bool defaultRequireSignatureConfirmation;
    internal static bool defaultEnableUnsecuredResponse;
    internal static bool defaultProtectTokens;
    private SupportingTokenParameters _endpointSupportingTokenParameters;
    private bool _includeTimestamp;
    private LocalClientSecuritySettings _localClientSettings;
    private MessageSecurityVersion _messageSecurityVersion;
    private SecurityHeaderLayout _securityHeaderLayout;
    private long _maxReceivedMessageSize;
    private XmlDictionaryReaderQuotas _readerQuotas;
    private bool _protectTokens;
    public SupportingTokenParameters EndpointSupportingTokenParameters { get; }
    public SecurityHeaderLayout SecurityHeaderLayout { get; public set; }
    public MessageSecurityVersion MessageSecurityVersion { get; public set; }
    public bool IncludeTimestamp { get; public set; }
    public LocalClientSecuritySettings LocalClientSettings { get; }
    internal bool SessionMode { get; }
    internal bool SupportsDuplex { get; }
    internal bool SupportsRequestReply { get; }
    internal long MaxReceivedMessageSize { get; internal set; }
    internal XmlDictionaryReaderQuotas ReaderQuotas { get; internal set; }
    internal SecurityBindingElement(SecurityBindingElement elementToBeCloned);
    public SupportingTokenParameters get_EndpointSupportingTokenParameters();
    public SecurityHeaderLayout get_SecurityHeaderLayout();
    public void set_SecurityHeaderLayout(SecurityHeaderLayout value);
    public MessageSecurityVersion get_MessageSecurityVersion();
    public void set_MessageSecurityVersion(MessageSecurityVersion value);
    public bool get_IncludeTimestamp();
    public void set_IncludeTimestamp(bool value);
    public LocalClientSecuritySettings get_LocalClientSettings();
    internal virtual bool get_SessionMode();
    internal virtual bool get_SupportsDuplex();
    internal virtual bool get_SupportsRequestReply();
    internal long get_MaxReceivedMessageSize();
    internal void set_MaxReceivedMessageSize(long value);
    internal XmlDictionaryReaderQuotas get_ReaderQuotas();
    internal void set_ReaderQuotas(XmlDictionaryReaderQuotas value);
    private void GetSupportingTokensCapabilities(ICollection`1<SecurityTokenParameters> parameters, Boolean& supportsClientAuth, Boolean& supportsWindowsIdentity);
    private void GetSupportingTokensCapabilities(SupportingTokenParameters requirements, Boolean& supportsClientAuth, Boolean& supportsWindowsIdentity);
    internal void GetSupportingTokensCapabilities(Boolean& supportsClientAuth, Boolean& supportsWindowsIdentity);
    protected static void SetIssuerBindingContextIfRequired(SecurityTokenParameters parameters, BindingContext issuerBindingContext);
    internal bool RequiresChannelDemuxer(SecurityTokenParameters parameters);
    internal virtual bool RequiresChannelDemuxer();
    public virtual IChannelFactory`1<TChannel> BuildChannelFactory(BindingContext context);
    protected abstract virtual IChannelFactory`1<TChannel> BuildChannelFactoryCore(BindingContext context);
    public virtual bool CanBuildChannelFactory(BindingContext context);
    private bool CanBuildSessionChannelFactory(BindingContext context);
    public virtual void SetKeyDerivation(bool requireDerivedKeys);
    internal virtual bool IsSetKeyDerivation(bool requireDerivedKeys);
    public virtual T GetProperty(BindingContext context);
    internal abstract virtual ISecurityCapabilities GetIndividualISecurityCapabilities();
    private ISecurityCapabilities GetSecurityCapabilities(BindingContext context);
    public static SecurityBindingElement CreateMutualCertificateBindingElement();
    internal static bool IsMutualCertificateBinding(SecurityBindingElement sbe);
    public static SecurityBindingElement CreateMutualCertificateBindingElement(MessageSecurityVersion version);
    public static SecurityBindingElement CreateMutualCertificateBindingElement(MessageSecurityVersion version, bool allowSerializedSigningTokenOnReply);
    internal static bool IsMutualCertificateBinding(SecurityBindingElement sbe, bool allowSerializedSigningTokenOnReply);
    public static TransportSecurityBindingElement CreateUserNameOverTransportBindingElement();
    internal static bool IsUserNameOverTransportBinding(SecurityBindingElement sbe);
    public static TransportSecurityBindingElement CreateCertificateOverTransportBindingElement(MessageSecurityVersion version);
    internal static bool IsCertificateOverTransportBinding(SecurityBindingElement sbe);
    public static SecurityBindingElement CreateSecureConversationBindingElement(SecurityBindingElement bootstrapSecurity);
    public virtual string ToString();
}
public class System.ServiceModel.Channels.SecurityCapabilities : object {
    internal bool supportsServerAuth;
    internal bool supportsClientAuth;
    internal bool supportsClientWindowsIdentity;
    internal ProtectionLevel requestProtectionLevel;
    internal ProtectionLevel responseProtectionLevel;
    public ProtectionLevel SupportedRequestProtectionLevel { get; }
    public ProtectionLevel SupportedResponseProtectionLevel { get; }
    public bool SupportsClientAuthentication { get; }
    public bool SupportsClientWindowsIdentity { get; }
    public bool SupportsServerAuthentication { get; }
    public static SecurityCapabilities None { get; }
    public SecurityCapabilities(bool supportsClientAuth, bool supportsServerAuth, bool supportsClientWindowsIdentity, ProtectionLevel requestProtectionLevel, ProtectionLevel responseProtectionLevel);
    public sealed virtual ProtectionLevel get_SupportedRequestProtectionLevel();
    public sealed virtual ProtectionLevel get_SupportedResponseProtectionLevel();
    public sealed virtual bool get_SupportsClientAuthentication();
    public sealed virtual bool get_SupportsClientWindowsIdentity();
    public sealed virtual bool get_SupportsServerAuthentication();
    public static SecurityCapabilities get_None();
    public static bool IsEqual(ISecurityCapabilities capabilities1, ISecurityCapabilities capabilities2);
}
internal class System.ServiceModel.Channels.SecurityChannelFaultConverter : FaultConverter {
    private IChannel _innerChannel;
    internal SecurityChannelFaultConverter(IChannel innerChannel);
    protected virtual bool OnTryCreateException(Message message, MessageFault fault, Exception& exception);
    protected virtual bool OnTryCreateFaultMessage(Exception exception, Message& message);
}
public enum System.ServiceModel.Channels.SecurityHeaderLayout : Enum {
    public int value__;
    public static SecurityHeaderLayout Strict;
    public static SecurityHeaderLayout Lax;
    public static SecurityHeaderLayout LaxTimestampFirst;
    public static SecurityHeaderLayout LaxTimestampLast;
}
internal static class System.ServiceModel.Channels.SecurityHeaderLayoutHelper : object {
    public static bool IsDefined(SecurityHeaderLayout value);
    public static void Validate(SecurityHeaderLayout value);
}
internal abstract class System.ServiceModel.Channels.ServerSessionEncoder : SessionEncoder {
    public static Byte[] AckResponseBytes;
    public static Byte[] UpgradeResponseBytes;
    private static ServerSessionEncoder();
}
internal class System.ServiceModel.Channels.ServerSingletonEncoder : SingletonEncoder {
    public static Byte[] AckResponseBytes;
    public static Byte[] UpgradeResponseBytes;
    private static ServerSingletonEncoder();
}
internal class System.ServiceModel.Channels.ServiceChannel : CommunicationObject {
    private int _activityCount;
    private bool _allowInitializationUI;
    private bool _allowOutputBatching;
    private bool _autoClose;
    private CallOnceManager _autoDisplayUIManager;
    private CallOnceManager _autoOpenManager;
    private IChannelBinder _binder;
    private ChannelDispatcher _channelDispatcher;
    private ClientRuntime _clientRuntime;
    private bool _closeBinder;
    private bool _closeFactory;
    private bool _didInteractiveInitialization;
    private bool _doneReceiving;
    private EndpointDispatcher _endpointDispatcher;
    private bool _explicitlyOpened;
    private ExtensionCollection`1<IContextChannel> _extensions;
    private ServiceChannelFactory _factory;
    private bool _hasSession;
    private SessionIdleManager _idleManager;
    private InstanceContext _instanceContext;
    private bool _isPending;
    private bool _isReplyChannel;
    private EndpointAddress _localAddress;
    private MessageVersion _messageVersion;
    private bool _openBinder;
    private TimeSpan _operationTimeout;
    private object _proxy;
    private string _terminatingOperationName;
    private bool _hasChannelStartedAutoClosing;
    private bool _hasCleanedUpChannelCollections;
    private EventTraceActivity _eventActivity;
    private EventHandler`1<UnknownMessageReceivedEventArgs> _unknownMessageReceived;
    private CallOnceManager AutoOpenManager { get; }
    private CallOnceManager AutoDisplayUIManager { get; }
    internal EventTraceActivity EventActivity { get; }
    internal bool CloseFactory { get; internal set; }
    protected TimeSpan DefaultCloseTimeout { get; }
    protected TimeSpan DefaultOpenTimeout { get; }
    internal DispatchRuntime DispatchRuntime { get; }
    internal MessageVersion MessageVersion { get; }
    internal IChannelBinder Binder { get; }
    internal TimeSpan CloseTimeout { get; }
    internal ChannelDispatcher ChannelDispatcher { get; }
    internal EndpointDispatcher EndpointDispatcher { get; internal set; }
    internal ServiceChannelFactory Factory { get; }
    internal IChannel InnerChannel { get; }
    internal bool IsPending { get; internal set; }
    internal bool HasSession { get; }
    internal bool IsClient { get; }
    internal bool IsReplyChannel { get; }
    public Uri ListenUri { get; }
    public EndpointAddress LocalAddress { get; }
    internal TimeSpan OpenTimeout { get; }
    public TimeSpan OperationTimeout { get; public set; }
    internal object Proxy { get; internal set; }
    internal ClientRuntime ClientRuntime { get; }
    public EndpointAddress RemoteAddress { get; }
    private ProxyOperationRuntime UnhandledProxyOperation { get; }
    public Uri Via { get; }
    internal InstanceContext InstanceContext { get; internal set; }
    private bool System.ServiceModel.IDuplexContextChannel.AutomaticInputSessionShutdown { get; private set; }
    private bool System.ServiceModel.IClientChannel.AllowInitializationUI { get; private set; }
    private bool System.ServiceModel.IContextChannel.AllowOutputBatching { get; private set; }
    private bool System.ServiceModel.IClientChannel.DidInteractiveInitialization { get; }
    private IExtensionCollection`1<IContextChannel> System.ServiceModel.IExtensibleObject<System.ServiceModel.IContextChannel>.Extensions { get; }
    private InstanceContext System.ServiceModel.IDuplexContextChannel.CallbackInstance { get; private set; }
    private IInputSession System.ServiceModel.IContextChannel.InputSession { get; }
    private IOutputSession System.ServiceModel.IContextChannel.OutputSession { get; }
    private string System.ServiceModel.IContextChannel.SessionId { get; }
    private ServiceChannel(IChannelBinder binder, MessageVersion messageVersion, IDefaultCommunicationTimeouts timeouts);
    internal ServiceChannel(ServiceChannelFactory factory, IChannelBinder binder);
    internal ServiceChannel(IChannelBinder binder, EndpointDispatcher endpointDispatcher, ChannelDispatcher channelDispatcher, SessionIdleManager idleManager);
    private CallOnceManager get_AutoOpenManager();
    private CallOnceManager get_AutoDisplayUIManager();
    internal EventTraceActivity get_EventActivity();
    internal bool get_CloseFactory();
    internal void set_CloseFactory(bool value);
    protected virtual TimeSpan get_DefaultCloseTimeout();
    protected virtual TimeSpan get_DefaultOpenTimeout();
    internal DispatchRuntime get_DispatchRuntime();
    internal MessageVersion get_MessageVersion();
    internal IChannelBinder get_Binder();
    internal TimeSpan get_CloseTimeout();
    internal ChannelDispatcher get_ChannelDispatcher();
    internal EndpointDispatcher get_EndpointDispatcher();
    internal void set_EndpointDispatcher(EndpointDispatcher value);
    internal ServiceChannelFactory get_Factory();
    internal IChannel get_InnerChannel();
    internal bool get_IsPending();
    internal void set_IsPending(bool value);
    internal bool get_HasSession();
    internal bool get_IsClient();
    internal bool get_IsReplyChannel();
    public sealed virtual Uri get_ListenUri();
    public sealed virtual EndpointAddress get_LocalAddress();
    internal TimeSpan get_OpenTimeout();
    public sealed virtual TimeSpan get_OperationTimeout();
    public sealed virtual void set_OperationTimeout(TimeSpan value);
    internal object get_Proxy();
    internal void set_Proxy(object value);
    internal ClientRuntime get_ClientRuntime();
    public sealed virtual EndpointAddress get_RemoteAddress();
    private ProxyOperationRuntime get_UnhandledProxyOperation();
    public sealed virtual Uri get_Via();
    internal InstanceContext get_InstanceContext();
    internal void set_InstanceContext(InstanceContext value);
    private void SetupInnerChannelFaultHandler();
    private void BindDuplexCallbacks();
    internal bool CanCastTo(Type t);
    internal void CompletedIOOperation();
    private void EnsureAutoOpenManagers();
    private void EnsureDisplayUI();
    private IAsyncResult BeginEnsureDisplayUI(AsyncCallback callback, object state);
    private void EndEnsureDisplayUI(IAsyncResult result);
    private void EnsureOpened(TimeSpan timeout);
    private IAsyncResult BeginEnsureOpened(TimeSpan timeout, AsyncCallback callback, object state);
    private void EndEnsureOpened(IAsyncResult result);
    public sealed virtual T GetProperty();
    private void PrepareCall(ProxyOperationRuntime operation, bool oneway, ProxyRpc& rpc);
    private void TraceClientOperationPrepared(ProxyRpc& rpc);
    internal static IAsyncResult BeginCall(ServiceChannel channel, ProxyOperationRuntime operation, Object[] ins, AsyncCallback callback, object asyncState);
    internal IAsyncResult BeginCall(string action, bool oneway, ProxyOperationRuntime operation, Object[] ins, AsyncCallback callback, object asyncState);
    internal IAsyncResult BeginCall(string action, bool oneway, ProxyOperationRuntime operation, Object[] ins, TimeSpan timeout, AsyncCallback callback, object asyncState);
    internal object Call(string action, bool oneway, ProxyOperationRuntime operation, Object[] ins, Object[] outs);
    internal object Call(string action, bool oneway, ProxyOperationRuntime operation, Object[] ins, Object[] outs, TimeSpan timeout);
    internal object EndCall(string action, Object[] outs, IAsyncResult result);
    internal void DecrementActivity();
    internal void FireUnknownMessageReceived(Message message);
    private TimeoutException GetOpenTimeoutException(TimeSpan timeout);
    internal void HandleReceiveComplete(RequestContext context);
    private void HandleReply(ProxyOperationRuntime operation, ProxyRpc& rpc);
    private void TerminateIfNecessary(ProxyRpc& rpc);
    private void ThrowIfFaultUnderstood(Message reply, MessageFault fault, string action, MessageVersion version, FaultConverter faultConverter);
    private void ThrowIfIdleAborted(ProxyOperationRuntime operation);
    private void ThrowIfIsConnectionOpened(ProxyOperationRuntime operation);
    private void ThrowIfInitializationUINotCalled();
    private void ThrowIfDisallowedInitializationUI();
    private void ThrowIfDisallowedInitializationUICore();
    private void ThrowIfOpening();
    internal void IncrementActivity();
    private void OnInnerChannelFaulted(object sender, EventArgs e);
    private void AddMessageProperties(Message message, OperationContext context);
    public sealed virtual void Send(Message message);
    public sealed virtual void Send(Message message, TimeSpan timeout);
    public sealed virtual IAsyncResult BeginSend(Message message, AsyncCallback callback, object state);
    public sealed virtual IAsyncResult BeginSend(Message message, TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual void EndSend(IAsyncResult result);
    public sealed virtual Message Request(Message message);
    public sealed virtual Message Request(Message message, TimeSpan timeout);
    public sealed virtual IAsyncResult BeginRequest(Message message, AsyncCallback callback, object state);
    public sealed virtual IAsyncResult BeginRequest(Message message, TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual Message EndRequest(IAsyncResult result);
    protected virtual void OnAbort();
    protected virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndClose(IAsyncResult result);
    protected virtual void OnClose(TimeSpan timeout);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.ServiceChannel/<OnCloseAsync>d__147")]
protected internal virtual Task OnCloseAsync(TimeSpan timeout);
    protected virtual IAsyncResult OnBeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndOpen(IAsyncResult result);
    protected virtual void OnOpen(TimeSpan timeout);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.ServiceChannel/<OnOpenAsync>d__151")]
protected internal virtual Task OnOpenAsync(TimeSpan timeout);
    private void CleanupChannelCollections();
    private sealed virtual override bool System.ServiceModel.IDuplexContextChannel.get_AutomaticInputSessionShutdown();
    private sealed virtual override void System.ServiceModel.IDuplexContextChannel.set_AutomaticInputSessionShutdown(bool value);
    private sealed virtual override bool System.ServiceModel.IClientChannel.get_AllowInitializationUI();
    private sealed virtual override void System.ServiceModel.IClientChannel.set_AllowInitializationUI(bool value);
    private sealed virtual override bool System.ServiceModel.IContextChannel.get_AllowOutputBatching();
    private sealed virtual override void System.ServiceModel.IContextChannel.set_AllowOutputBatching(bool value);
    private sealed virtual override bool System.ServiceModel.IClientChannel.get_DidInteractiveInitialization();
    private sealed virtual override IAsyncResult System.ServiceModel.IDuplexContextChannel.BeginCloseOutputSession(TimeSpan timeout, AsyncCallback callback, object state);
    private sealed virtual override void System.ServiceModel.IDuplexContextChannel.EndCloseOutputSession(IAsyncResult result);
    private sealed virtual override void System.ServiceModel.IDuplexContextChannel.CloseOutputSession(TimeSpan timeout);
    private IDuplexSession GetDuplexSessionOrThrow();
    private sealed virtual override IExtensionCollection`1<IContextChannel> System.ServiceModel.IExtensibleObject<System.ServiceModel.IContextChannel>.get_Extensions();
    private sealed virtual override InstanceContext System.ServiceModel.IDuplexContextChannel.get_CallbackInstance();
    private sealed virtual override void System.ServiceModel.IDuplexContextChannel.set_CallbackInstance(InstanceContext value);
    private sealed virtual override IInputSession System.ServiceModel.IContextChannel.get_InputSession();
    private sealed virtual override IOutputSession System.ServiceModel.IContextChannel.get_OutputSession();
    private sealed virtual override string System.ServiceModel.IContextChannel.get_SessionId();
    private sealed virtual override void System.ServiceModel.IClientChannel.add_UnknownMessageReceived(EventHandler`1<UnknownMessageReceivedEventArgs> value);
    private sealed virtual override void System.ServiceModel.IClientChannel.remove_UnknownMessageReceived(EventHandler`1<UnknownMessageReceivedEventArgs> value);
    public sealed virtual void DisplayInitializationUI();
    public sealed virtual IAsyncResult BeginDisplayInitializationUI(AsyncCallback callback, object state);
    public sealed virtual void EndDisplayInitializationUI(IAsyncResult result);
    private sealed virtual override void System.IDisposable.Dispose();
    private void TraceChannelOpenStarted();
    private void TraceChannelOpenCompleted();
    private static void TraceServiceChannelCallStart(EventTraceActivity eventTraceActivity, bool isSynchronous);
}
internal abstract class System.ServiceModel.Channels.ServiceChannelFactory : ChannelFactoryBase {
    private string _bindingName;
    private List`1<IChannel> _channelsList;
    private ClientRuntime _clientRuntime;
    private RequestReplyCorrelator _requestReplyCorrelator;
    private IDefaultCommunicationTimeouts _timeouts;
    private MessageVersion _messageVersion;
    public ClientRuntime ClientRuntime { get; }
    internal RequestReplyCorrelator RequestReplyCorrelator { get; }
    protected TimeSpan DefaultCloseTimeout { get; }
    protected TimeSpan DefaultReceiveTimeout { get; }
    protected TimeSpan DefaultOpenTimeout { get; }
    protected TimeSpan DefaultSendTimeout { get; }
    public MessageVersion MessageVersion { get; }
    public ServiceChannelFactory(ClientRuntime clientRuntime, Binding binding);
    public ClientRuntime get_ClientRuntime();
    internal RequestReplyCorrelator get_RequestReplyCorrelator();
    protected virtual TimeSpan get_DefaultCloseTimeout();
    protected virtual TimeSpan get_DefaultReceiveTimeout();
    protected virtual TimeSpan get_DefaultOpenTimeout();
    protected virtual TimeSpan get_DefaultSendTimeout();
    public MessageVersion get_MessageVersion();
    public static ServiceChannelFactory BuildChannelFactory(ChannelBuilder channelBuilder, ClientRuntime clientRuntime);
    public static ServiceChannelFactory BuildChannelFactory(ServiceEndpoint serviceEndpoint);
    public static ServiceChannelFactory BuildChannelFactory(ServiceEndpoint serviceEndpoint, bool useActiveAutoClose);
    protected virtual void OnAbort();
    protected virtual void OnClose(TimeSpan timeout);
    protected virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndClose(IAsyncResult result);
    protected internal virtual Task OnCloseAsync(TimeSpan timeout);
    protected virtual void OnOpened();
    public void ChannelCreated(IChannel channel);
    public void ChannelDisposed(IChannel channel);
    public virtual ServiceChannel CreateServiceChannel(EndpointAddress address, Uri via);
    public TChannel CreateChannel(EndpointAddress address);
    public TChannel CreateChannel(EndpointAddress address, Uri via);
    public abstract virtual bool CanCreateChannel();
    internal static object CreateProxy(Type interfaceType, Type proxiedType, MessageDirection direction, ServiceChannel serviceChannel);
    internal static object CreateProxy(MessageDirection direction, ServiceChannel serviceChannel);
    internal static ServiceChannel GetServiceChannel(object transparentProxy);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.ServiceChannelFactory/<OnCloseAsyncInternal>d__39")]
private Task OnCloseAsyncInternal(TimeSpan timeout);
    protected abstract virtual IChannelBinder CreateInnerChannelBinder(EndpointAddress address, Uri via);
}
public class System.ServiceModel.Channels.ServiceChannelProxy : DispatchProxy {
    private static string activityIdSlotName;
    private Type _proxiedType;
    private ServiceChannel _serviceChannel;
    private ImmutableClientRuntime _proxyRuntime;
    private MethodDataCache _methodDataCache;
    private CommunicationState System.ServiceModel.ICommunicationObject.State { get; }
    private bool System.ServiceModel.IClientChannel.AllowInitializationUI { get; private set; }
    private bool System.ServiceModel.IClientChannel.DidInteractiveInitialization { get; }
    private Uri System.ServiceModel.IClientChannel.Via { get; }
    private bool System.ServiceModel.IContextChannel.AllowOutputBatching { get; private set; }
    private IInputSession System.ServiceModel.IContextChannel.InputSession { get; }
    private EndpointAddress System.ServiceModel.IContextChannel.LocalAddress { get; }
    private TimeSpan System.ServiceModel.IContextChannel.OperationTimeout { get; private set; }
    private IOutputSession System.ServiceModel.IContextChannel.OutputSession { get; }
    private EndpointAddress System.ServiceModel.Channels.IOutputChannel.RemoteAddress { get; }
    private Uri System.ServiceModel.Channels.IOutputChannel.Via { get; }
    private EndpointAddress System.ServiceModel.IContextChannel.RemoteAddress { get; }
    private string System.ServiceModel.IContextChannel.SessionId { get; }
    private IExtensionCollection`1<IContextChannel> System.ServiceModel.IExtensibleObject<System.ServiceModel.IContextChannel>.Extensions { get; }
    private EndpointAddress System.ServiceModel.Channels.IRequestChannel.RemoteAddress { get; }
    private Uri System.ServiceModel.Channels.IRequestChannel.Via { get; }
    private Uri System.ServiceModel.IServiceChannel.ListenUri { get; }
    public bool AutomaticInputSessionShutdown { get; public set; }
    public InstanceContext CallbackInstance { get; public set; }
    internal static TChannel CreateProxy(MessageDirection direction, ServiceChannel serviceChannel);
    public virtual string ToString();
    private MethodData GetMethodData(MethodCall methodCall);
    internal ServiceChannel GetServiceChannel();
    protected virtual object Invoke(MethodInfo targetMethod, Object[] args);
    private object InvokeTaskService(MethodCall methodCall, ProxyOperationRuntime operation);
    private object InvokeChannel(MethodCall methodCall);
    private object InvokeGetType(MethodCall methodCall);
    private object InvokeBeginService(MethodCall methodCall, ProxyOperationRuntime operation);
    private object InvokeEndService(MethodCall methodCall, ProxyOperationRuntime operation);
    private object InvokeService(MethodCall methodCall, ProxyOperationRuntime operation);
    private object ExecuteMessage(object target, MethodCall methodCall);
    private sealed virtual override T System.ServiceModel.Channels.IChannel.GetProperty();
    private sealed virtual override CommunicationState System.ServiceModel.ICommunicationObject.get_State();
    private sealed virtual override void System.ServiceModel.ICommunicationObject.add_Closed(EventHandler value);
    private sealed virtual override void System.ServiceModel.ICommunicationObject.remove_Closed(EventHandler value);
    private sealed virtual override void System.ServiceModel.ICommunicationObject.add_Closing(EventHandler value);
    private sealed virtual override void System.ServiceModel.ICommunicationObject.remove_Closing(EventHandler value);
    private sealed virtual override void System.ServiceModel.ICommunicationObject.add_Faulted(EventHandler value);
    private sealed virtual override void System.ServiceModel.ICommunicationObject.remove_Faulted(EventHandler value);
    private sealed virtual override void System.ServiceModel.ICommunicationObject.add_Opened(EventHandler value);
    private sealed virtual override void System.ServiceModel.ICommunicationObject.remove_Opened(EventHandler value);
    private sealed virtual override void System.ServiceModel.ICommunicationObject.add_Opening(EventHandler value);
    private sealed virtual override void System.ServiceModel.ICommunicationObject.remove_Opening(EventHandler value);
    private sealed virtual override void System.ServiceModel.ICommunicationObject.Abort();
    private sealed virtual override void System.ServiceModel.ICommunicationObject.Close();
    private sealed virtual override void System.ServiceModel.ICommunicationObject.Close(TimeSpan timeout);
    private sealed virtual override IAsyncResult System.ServiceModel.ICommunicationObject.BeginClose(AsyncCallback callback, object state);
    private sealed virtual override IAsyncResult System.ServiceModel.ICommunicationObject.BeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    private sealed virtual override void System.ServiceModel.ICommunicationObject.EndClose(IAsyncResult result);
    private sealed virtual override void System.ServiceModel.ICommunicationObject.Open();
    private sealed virtual override void System.ServiceModel.ICommunicationObject.Open(TimeSpan timeout);
    private sealed virtual override IAsyncResult System.ServiceModel.ICommunicationObject.BeginOpen(AsyncCallback callback, object state);
    private sealed virtual override IAsyncResult System.ServiceModel.ICommunicationObject.BeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    private sealed virtual override void System.ServiceModel.ICommunicationObject.EndOpen(IAsyncResult result);
    private sealed virtual override bool System.ServiceModel.IClientChannel.get_AllowInitializationUI();
    private sealed virtual override void System.ServiceModel.IClientChannel.set_AllowInitializationUI(bool value);
    private sealed virtual override bool System.ServiceModel.IClientChannel.get_DidInteractiveInitialization();
    private sealed virtual override Uri System.ServiceModel.IClientChannel.get_Via();
    private sealed virtual override void System.ServiceModel.IClientChannel.add_UnknownMessageReceived(EventHandler`1<UnknownMessageReceivedEventArgs> value);
    private sealed virtual override void System.ServiceModel.IClientChannel.remove_UnknownMessageReceived(EventHandler`1<UnknownMessageReceivedEventArgs> value);
    private sealed virtual override IAsyncResult System.ServiceModel.IClientChannel.BeginDisplayInitializationUI(AsyncCallback callback, object state);
    private sealed virtual override void System.ServiceModel.IClientChannel.DisplayInitializationUI();
    private sealed virtual override void System.ServiceModel.IClientChannel.EndDisplayInitializationUI(IAsyncResult result);
    private sealed virtual override void System.IDisposable.Dispose();
    private sealed virtual override bool System.ServiceModel.IContextChannel.get_AllowOutputBatching();
    private sealed virtual override void System.ServiceModel.IContextChannel.set_AllowOutputBatching(bool value);
    private sealed virtual override IInputSession System.ServiceModel.IContextChannel.get_InputSession();
    private sealed virtual override EndpointAddress System.ServiceModel.IContextChannel.get_LocalAddress();
    private sealed virtual override TimeSpan System.ServiceModel.IContextChannel.get_OperationTimeout();
    private sealed virtual override void System.ServiceModel.IContextChannel.set_OperationTimeout(TimeSpan value);
    private sealed virtual override IOutputSession System.ServiceModel.IContextChannel.get_OutputSession();
    private sealed virtual override EndpointAddress System.ServiceModel.Channels.IOutputChannel.get_RemoteAddress();
    private sealed virtual override Uri System.ServiceModel.Channels.IOutputChannel.get_Via();
    private sealed virtual override EndpointAddress System.ServiceModel.IContextChannel.get_RemoteAddress();
    private sealed virtual override string System.ServiceModel.IContextChannel.get_SessionId();
    private sealed virtual override IExtensionCollection`1<IContextChannel> System.ServiceModel.IExtensibleObject<System.ServiceModel.IContextChannel>.get_Extensions();
    private sealed virtual override IAsyncResult System.ServiceModel.Channels.IOutputChannel.BeginSend(Message message, AsyncCallback callback, object state);
    private sealed virtual override IAsyncResult System.ServiceModel.Channels.IOutputChannel.BeginSend(Message message, TimeSpan timeout, AsyncCallback callback, object state);
    private sealed virtual override void System.ServiceModel.Channels.IOutputChannel.EndSend(IAsyncResult result);
    private sealed virtual override void System.ServiceModel.Channels.IOutputChannel.Send(Message message);
    private sealed virtual override void System.ServiceModel.Channels.IOutputChannel.Send(Message message, TimeSpan timeout);
    private sealed virtual override Message System.ServiceModel.Channels.IRequestChannel.Request(Message message);
    private sealed virtual override Message System.ServiceModel.Channels.IRequestChannel.Request(Message message, TimeSpan timeout);
    private sealed virtual override IAsyncResult System.ServiceModel.Channels.IRequestChannel.BeginRequest(Message message, AsyncCallback callback, object state);
    private sealed virtual override IAsyncResult System.ServiceModel.Channels.IRequestChannel.BeginRequest(Message message, TimeSpan timeout, AsyncCallback callback, object state);
    private sealed virtual override Message System.ServiceModel.Channels.IRequestChannel.EndRequest(IAsyncResult result);
    public sealed virtual IAsyncResult BeginCloseOutputSession(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual void EndCloseOutputSession(IAsyncResult result);
    public sealed virtual void CloseOutputSession(TimeSpan timeout);
    private sealed virtual override EndpointAddress System.ServiceModel.Channels.IRequestChannel.get_RemoteAddress();
    private sealed virtual override Uri System.ServiceModel.Channels.IRequestChannel.get_Via();
    private sealed virtual override Uri System.ServiceModel.IServiceChannel.get_ListenUri();
    public sealed virtual bool get_AutomaticInputSessionShutdown();
    public sealed virtual void set_AutomaticInputSessionShutdown(bool value);
    public sealed virtual InstanceContext get_CallbackInstance();
    public sealed virtual void set_CallbackInstance(InstanceContext value);
}
public class System.ServiceModel.Channels.ServiceModelHttpMessageHandler : DelegatingHandler {
    private WinHttpHandler _innerHandler;
    [CompilerGeneratedAttribute]
private bool <UseProxy>k__BackingField;
    public ICredentials Credentials { get; public set; }
    public bool UseCookies { get; public set; }
    public bool UseDefaultCredentials { get; public set; }
    public bool UseProxy { get; public set; }
    public bool CheckCertificateRevocationList { get; public set; }
    public X509CertificateCollection ClientCertificates { get; }
    public Func`5<HttpRequestMessage, X509Certificate2, X509Chain, SslPolicyErrors, bool> ServerCertificateValidationCallback { get; public set; }
    public bool SupportsProxy { get; }
    public IWebProxy Proxy { get; public set; }
    public bool SupportsClientCertificates { get; }
    public bool SupportsCertificateValidationCallback { get; }
    public DecompressionMethods AutomaticDecompression { get; public set; }
    public bool PreAuthenticate { get; public set; }
    public CookieContainer CookieContainer { get; public set; }
    public ICredentials get_Credentials();
    public void set_Credentials(ICredentials value);
    public bool get_UseCookies();
    public void set_UseCookies(bool value);
    public bool get_UseDefaultCredentials();
    public void set_UseDefaultCredentials(bool value);
    [CompilerGeneratedAttribute]
public bool get_UseProxy();
    [CompilerGeneratedAttribute]
public void set_UseProxy(bool value);
    public bool get_CheckCertificateRevocationList();
    public void set_CheckCertificateRevocationList(bool value);
    public X509CertificateCollection get_ClientCertificates();
    public Func`5<HttpRequestMessage, X509Certificate2, X509Chain, SslPolicyErrors, bool> get_ServerCertificateValidationCallback();
    public void set_ServerCertificateValidationCallback(Func`5<HttpRequestMessage, X509Certificate2, X509Chain, SslPolicyErrors, bool> value);
    public bool get_SupportsProxy();
    public IWebProxy get_Proxy();
    public void set_Proxy(IWebProxy value);
    public bool get_SupportsClientCertificates();
    public bool get_SupportsCertificateValidationCallback();
    public DecompressionMethods get_AutomaticDecompression();
    public void set_AutomaticDecompression(DecompressionMethods value);
    public bool get_PreAuthenticate();
    public void set_PreAuthenticate(bool value);
    public CookieContainer get_CookieContainer();
    public void set_CookieContainer(CookieContainer value);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.ServiceModelHttpMessageHandler/<SendAsync>d__41")]
protected virtual Task`1<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<HttpResponseMessage> <>n__0(HttpRequestMessage request, CancellationToken cancellationToken);
}
internal abstract class System.ServiceModel.Channels.SessionConnectionReader : object {
    private bool _isAtEOF;
    private bool _usingAsyncReadBuffer;
    private IConnection _connection;
    private Byte[] _buffer;
    private int _offset;
    private int _size;
    private Byte[] _envelopeBuffer;
    private int _envelopeOffset;
    private int _envelopeSize;
    private bool _readIntoEnvelopeBuffer;
    private Message _pendingMessage;
    private Exception _pendingException;
    private SecurityMessageProperty _security;
    private IConnection _rawConnection;
    protected Byte[] EnvelopeBuffer { get; protected set; }
    protected int EnvelopeOffset { get; protected set; }
    protected int EnvelopeSize { get; protected set; }
    protected SessionConnectionReader(IConnection connection, IConnection rawConnection, int offset, int size, SecurityMessageProperty security);
    private Message DecodeMessage(TimeSpan timeout);
    protected abstract virtual Message DecodeMessage(Byte[] buffer, Int32& offset, Int32& size, Boolean& isAtEof, TimeSpan timeout);
    protected Byte[] get_EnvelopeBuffer();
    protected void set_EnvelopeBuffer(Byte[] value);
    protected int get_EnvelopeOffset();
    protected void set_EnvelopeOffset(int value);
    protected int get_EnvelopeSize();
    protected void set_EnvelopeSize(int value);
    public IConnection GetRawConnection();
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.SessionConnectionReader/<ReceiveAsync>d__27")]
public sealed virtual Task`1<Message> ReceiveAsync(TimeSpan timeout);
    public sealed virtual Message Receive(TimeSpan timeout);
    public Message EndReceive();
    private Message GetPendingMessage();
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.SessionConnectionReader/<WaitForMessageAsync>d__31")]
public sealed virtual Task`1<bool> WaitForMessageAsync(TimeSpan timeout);
    public sealed virtual bool WaitForMessage(TimeSpan timeout);
    protected abstract virtual void EnsureDecoderAtEof();
    private void HandleReadComplete(int bytesRead, bool readIntoEnvelopeBuffer);
    protected virtual void PrepareMessage(Message message);
}
internal abstract class System.ServiceModel.Channels.SessionEncoder : object {
    public static int MaxMessageFrameSize;
    public static Byte[] PreambleEndBytes;
    public static Byte[] EndBytes;
    private static SessionEncoder();
    public static int CalcStartSize(EncodedVia via, EncodedContentType contentType);
    public static void EncodeStart(Byte[] buffer, int offset, EncodedVia via, EncodedContentType contentType);
    public static ArraySegment`1<byte> EncodeMessageFrame(ArraySegment`1<byte> messageFrame);
}
internal abstract class System.ServiceModel.Channels.SingletonConnectionReader : object {
    private IConnection _connection;
    private bool _doneReceiving;
    private bool _doneSending;
    private bool _isAtEof;
    private bool _isClosed;
    private SecurityMessageProperty _security;
    private object _thisLock;
    private int _offset;
    private int _size;
    private IConnectionOrientedTransportFactorySettings _transportSettings;
    private Uri _via;
    private Stream _inputStream;
    protected IConnection Connection { get; }
    protected object ThisLock { get; }
    protected string ContentType { get; }
    protected long StreamPosition { get; }
    protected SingletonConnectionReader(IConnection connection, int offset, int size, SecurityMessageProperty security, IConnectionOrientedTransportFactorySettings transportSettings, Uri via);
    protected IConnection get_Connection();
    protected object get_ThisLock();
    protected virtual string get_ContentType();
    protected abstract virtual long get_StreamPosition();
    public void Abort();
    public void DoneReceiving(bool atEof);
    private void DoneReceiving(bool atEof, TimeSpan timeout);
    public void Close(TimeSpan timeout);
    protected abstract virtual void OnClose(TimeSpan timeout);
    public void DoneSending(TimeSpan timeout);
    protected abstract virtual bool DecodeBytes(Byte[] buffer, Int32& offset, Int32& size, Boolean& isAtEof);
    protected virtual void PrepareMessage(Message message);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.SingletonConnectionReader/<ReceiveAsync>d__29")]
public Task`1<Message> ReceiveAsync(TimeoutHelper timeoutHelper);
}
internal abstract class System.ServiceModel.Channels.SingletonEncoder : object {
    public static Byte[] EnvelopeStartBytes;
    public static Byte[] EnvelopeEndBytes;
    public static Byte[] EnvelopeEndFramingEndBytes;
    public static Byte[] EndBytes;
    private static SingletonEncoder();
    public static ArraySegment`1<byte> EncodeMessageFrame(ArraySegment`1<byte> messageFrame);
}
internal class System.ServiceModel.Channels.SingletonMessageDecoder : FramingDecoder {
    private IntDecoder _sizeDecoder;
    private int _chunkBytesNeeded;
    private int _chunkSize;
    private State _currentState;
    public State CurrentState { get; }
    protected string CurrentStateAsString { get; }
    public int ChunkSize { get; }
    public SingletonMessageDecoder(long streamPosition);
    public void Reset();
    public State get_CurrentState();
    protected virtual string get_CurrentStateAsString();
    public int get_ChunkSize();
    public int Decode(Byte[] bytes, int offset, int size);
}
internal abstract class System.ServiceModel.Channels.SocketConnection : object {
    protected TimeSpan _sendTimeout;
    protected TimeSpan _receiveTimeout;
    protected CloseState _closeState;
    protected bool _aborted;
    protected TimeoutHelper _closeTimeoutHelper;
    private bool _isShutdown;
    protected int _asyncReadSize;
    protected Byte[] _readBuffer;
    protected int _asyncReadBufferSize;
    protected object _asyncReadState;
    protected Action`1<object> _asyncReadCallback;
    protected Exception _asyncReadException;
    protected bool _asyncReadPending;
    protected object _asyncWriteState;
    protected Action`1<object> _asyncWriteCallback;
    protected Exception _asyncWriteException;
    protected bool _asyncWritePending;
    protected string _timeoutErrorString;
    protected TransferOperation _timeoutErrorTransferOperation;
    private ConnectionBufferPool _connectionBufferPool;
    private string _remoteEndpointAddressString;
    public int AsyncReadBufferSize { get; }
    public Byte[] AsyncReadBuffer { get; }
    protected object ThisLock { get; }
    protected IPEndPoint RemoteEndPoint { get; }
    protected string RemoteEndpointAddressString { get; }
    public SocketConnection(ConnectionBufferPool connectionBufferPool);
    public sealed virtual int get_AsyncReadBufferSize();
    public sealed virtual Byte[] get_AsyncReadBuffer();
    protected object get_ThisLock();
    protected abstract virtual IPEndPoint get_RemoteEndPoint();
    protected string get_RemoteEndpointAddressString();
    protected static void OnReceiveTimeout(SocketConnection socketConnection);
    protected static void OnSendTimeout(SocketConnection socketConnection);
    public sealed virtual void Abort();
    protected void Abort(string timeoutErrorString, TransferOperation transferOperation);
    protected void Abort(int traceEventType);
    protected abstract virtual void Abort(int traceEventType, string timeoutErrorString, TransferOperation transferOperation);
    protected abstract virtual void AbortRead();
    public sealed virtual void Close(TimeSpan timeout, bool asyncAndLinger);
    protected abstract virtual void CloseCore(bool asyncAndLinger);
    private void Shutdown(TimeSpan timeout);
    protected abstract virtual void ShutdownCore(TimeSpan timeout);
    protected void ThrowIfNotOpen();
    protected void ThrowIfClosed();
    protected Exception ConvertSendException(SocketException socketException, TimeSpan remainingTime);
    protected Exception ConvertReceiveException(SocketException socketException, TimeSpan remainingTime);
    internal static Exception ConvertTransferException(SocketException socketException, TimeSpan timeout, Exception originalException);
    protected Exception ConvertObjectDisposedException(ObjectDisposedException originalException, TransferOperation transferOperation);
    private static Exception ConvertTransferException(SocketException socketException, TimeSpan timeout, Exception originalException, TransferOperation transferOperation, bool aborted, string timeoutErrorString, TransferOperation timeoutErrorTransferOperation, SocketConnection socketConnection, TimeSpan remainingTime);
    private static Exception ConvertTimeoutErrorException(Exception originalException, TransferOperation transferOperation, string timeoutErrorString, TransferOperation timeoutErrorTransferOperation);
    public sealed virtual AsyncCompletionResult BeginWrite(Byte[] buffer, int offset, int size, bool immediate, TimeSpan timeout, Action`1<object> callback, object state);
    protected abstract virtual void TraceWriteStart(int size, bool async);
    protected abstract virtual AsyncCompletionResult BeginWriteCore(Byte[] buffer, int offset, int size, bool immediate, TimeSpan timeout, Action`1<object> callback, object state);
    public sealed virtual void EndWrite();
    protected abstract virtual void EndWriteCore();
    protected void FinishWrite();
    public sealed virtual void Write(Byte[] buffer, int offset, int size, bool immediate, TimeSpan timeout);
    protected abstract virtual void WriteCore(Byte[] buffer, int offset, int size, bool immediate, TimeSpan timeout);
    public sealed virtual void Write(Byte[] buffer, int offset, int size, bool immediate, TimeSpan timeout, BufferManager bufferManager);
    public sealed virtual int Read(Byte[] buffer, int offset, int size, TimeSpan timeout);
    protected abstract virtual int ReadCore(Byte[] buffer, int offset, int size, TimeSpan timeout, bool closing);
    public virtual AsyncCompletionResult BeginRead(int offset, int size, TimeSpan timeout, Action`1<object> callback, object state);
    protected abstract virtual void TraceSocketReadStop(int bytesRead, bool async);
    protected abstract virtual AsyncCompletionResult BeginReadCore(int offset, int size, TimeSpan timeout, Action`1<object> callback, object state);
    protected void FinishRead();
    public sealed virtual int EndRead();
    protected abstract virtual int EndReadCore();
    protected void ReturnReadBuffer();
    protected void TryReturnReadBuffer();
    public abstract virtual object GetCoreTransport();
}
internal abstract class System.ServiceModel.Channels.SocketConnectionInitiator : object {
    private int _bufferSize;
    protected ConnectionBufferPool _connectionBufferPool;
    public SocketConnectionInitiator(int bufferSize);
    protected abstract virtual IConnection CreateConnection(IPAddress address, int port);
    protected abstract virtual Task`1<IConnection> CreateConnectionAsync(IPAddress address, int port);
    public static Exception ConvertConnectException(SocketException socketException, Uri remoteUri, TimeSpan timeSpent, Exception innerException);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.SocketConnectionInitiator/<GetIPAddressesAsync>d__6")]
private static Task`1<IPAddress[]> GetIPAddressesAsync(Uri uri);
    private static TimeoutException CreateTimeoutException(Uri uri, TimeSpan timeout, IPAddress[] addresses, int invalidAddressCount, SocketException innerException);
    public sealed virtual IConnection Connect(Uri uri, TimeSpan timeout);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.SocketConnectionInitiator/<ConnectAsync>d__9")]
public sealed virtual Task`1<IConnection> ConnectAsync(Uri uri, TimeSpan timeout);
}
public class System.ServiceModel.Channels.SslStreamSecurityBindingElement : StreamUpgradeBindingElement {
    private IdentityVerifier _identityVerifier;
    private bool _requireClientCertificate;
    private SslProtocols _sslProtocols;
    public IdentityVerifier IdentityVerifier { get; public set; }
    [DefaultValueAttribute("False")]
internal bool RequireClientCertificate { get; internal set; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public SslProtocols SslProtocols { get; public set; }
    protected SslStreamSecurityBindingElement(SslStreamSecurityBindingElement elementToBeCloned);
    public IdentityVerifier get_IdentityVerifier();
    public void set_IdentityVerifier(IdentityVerifier value);
    internal bool get_RequireClientCertificate();
    internal void set_RequireClientCertificate(bool value);
    public SslProtocols get_SslProtocols();
    public void set_SslProtocols(SslProtocols value);
    public virtual IChannelFactory`1<TChannel> BuildChannelFactory(BindingContext context);
    public virtual bool CanBuildChannelFactory(BindingContext context);
    public virtual BindingElement Clone();
    public virtual T GetProperty(BindingContext context);
    public virtual StreamUpgradeProvider BuildClientStreamUpgradeProvider(BindingContext context);
    internal virtual bool IsMatch(BindingElement b);
}
internal class System.ServiceModel.Channels.SslStreamSecurityUpgradeInitiator : StreamSecurityUpgradeInitiatorBase {
    private SslStreamSecurityUpgradeProvider _parent;
    private SecurityMessageProperty _serverSecurity;
    private SecurityTokenProvider _clientCertificateProvider;
    private X509SecurityToken _clientToken;
    private SecurityTokenAuthenticator _serverCertificateAuthenticator;
    private ChannelBinding _channelBindingToken;
    private static LocalCertificateSelectionCallback s_clientCertificateSelectionCallback;
    private static LocalCertificateSelectionCallback ClientCertificateSelectionCallback { get; }
    internal ChannelBinding ChannelBinding { get; }
    internal bool IsChannelBindingSupportEnabled { get; }
    public SslStreamSecurityUpgradeInitiator(SslStreamSecurityUpgradeProvider parent, EndpointAddress remoteAddress, Uri via);
    private static LocalCertificateSelectionCallback get_ClientCertificateSelectionCallback();
    internal ChannelBinding get_ChannelBinding();
    internal bool get_IsChannelBindingSupportEnabled();
    internal virtual void Open(TimeSpan timeout);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.SslStreamSecurityUpgradeInitiator/<OpenAsync>d__15")]
internal virtual Task OpenAsync(TimeSpan timeout);
    internal virtual void Close(TimeSpan timeout);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.SslStreamSecurityUpgradeInitiator/<CloseAsync>d__17")]
internal virtual Task CloseAsync(TimeSpan timeout);
    protected virtual Stream OnInitiateUpgrade(Stream stream, SecurityMessageProperty& remoteSecurity);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.SslStreamSecurityUpgradeInitiator/<OnInitiateUpgradeAsync>d__19")]
protected virtual Task`1<Stream> OnInitiateUpgradeAsync(Stream stream, OutWrapper`1<SecurityMessageProperty> remoteSecurityWrapper);
    private static X509Certificate SelectClientCertificate(object sender, string targetHost, X509CertificateCollection localCertificates, X509Certificate remoteCertificate, String[] acceptableIssuers);
    private bool ValidateRemoteCertificate(object sender, X509Certificate certificate, X509Chain chain, SslPolicyErrors sslPolicyErrors);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__0(TimeSpan timeout);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__1(TimeSpan timeout);
}
internal class System.ServiceModel.Channels.SslStreamSecurityUpgradeProvider : StreamSecurityUpgradeProvider {
    private SecurityTokenAuthenticator _clientCertificateAuthenticator;
    private SecurityTokenManager _clientSecurityTokenManager;
    private SecurityTokenProvider _serverTokenProvider;
    private EndpointIdentity _identity;
    private IdentityVerifier _identityVerifier;
    private X509Certificate2 _serverCertificate;
    private bool _requireClientCertificate;
    private string _scheme;
    private SslProtocols _sslProtocols;
    private bool _enableChannelBinding;
    public EndpointIdentity Identity { get; }
    public IdentityVerifier IdentityVerifier { get; }
    public bool RequireClientCertificate { get; }
    public X509Certificate2 ServerCertificate { get; }
    public SecurityTokenAuthenticator ClientCertificateAuthenticator { get; }
    public SecurityTokenManager ClientSecurityTokenManager { get; }
    public string Scheme { get; }
    public SslProtocols SslProtocols { get; }
    private bool System.ServiceModel.Channels.IChannelBindingProvider.IsChannelBindingSupportEnabled { get; }
    private SslStreamSecurityUpgradeProvider(IDefaultCommunicationTimeouts timeouts, SecurityTokenManager clientSecurityTokenManager, bool requireClientCertificate, string scheme, IdentityVerifier identityVerifier, SslProtocols sslProtocols);
    private SslStreamSecurityUpgradeProvider(IDefaultCommunicationTimeouts timeouts, SecurityTokenProvider serverTokenProvider, bool requireClientCertificate, SecurityTokenAuthenticator clientCertificateAuthenticator, string scheme, IdentityVerifier identityVerifier, SslProtocols sslProtocols);
    public static SslStreamSecurityUpgradeProvider CreateClientProvider(SslStreamSecurityBindingElement bindingElement, BindingContext context);
    public virtual EndpointIdentity get_Identity();
    public IdentityVerifier get_IdentityVerifier();
    public bool get_RequireClientCertificate();
    public X509Certificate2 get_ServerCertificate();
    public SecurityTokenAuthenticator get_ClientCertificateAuthenticator();
    public SecurityTokenManager get_ClientSecurityTokenManager();
    public string get_Scheme();
    public SslProtocols get_SslProtocols();
    public virtual T GetProperty();
    private sealed virtual override ChannelBinding System.ServiceModel.Channels.IStreamUpgradeChannelBindingProvider.GetChannelBinding(StreamUpgradeInitiator upgradeInitiator, ChannelBindingKind kind);
    private sealed virtual override void System.ServiceModel.Channels.IChannelBindingProvider.EnableChannelBindingSupport();
    private sealed virtual override bool System.ServiceModel.Channels.IChannelBindingProvider.get_IsChannelBindingSupportEnabled();
    public virtual StreamUpgradeInitiator CreateUpgradeInitiator(EndpointAddress remoteAddress, Uri via);
    protected virtual void OnAbort();
    protected virtual void OnClose(TimeSpan timeout);
    protected internal virtual Task OnCloseAsync(TimeSpan timeout);
    protected virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndClose(IAsyncResult result);
    private void SetupServerCertificate(SecurityToken token);
    private void CleanupServerCertificate();
    protected virtual void OnOpen(TimeSpan timeout);
    protected internal virtual Task OnOpenAsync(TimeSpan timeout);
    protected virtual IAsyncResult OnBeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndOpen(IAsyncResult result);
}
internal class System.ServiceModel.Channels.StreamConnection : object {
    private Byte[] _asyncReadBuffer;
    private int _bytesRead;
    private ConnectionStream _innerStream;
    private Action`2<Task`1<int>, object> _onRead;
    private Action`2<Task, object> _onWrite;
    private Task`1<int> _readResult;
    private Task _writeResult;
    private Action`1<object> _readCallback;
    private Action`1<object> _writeCallback;
    private Stream _stream;
    public Byte[] AsyncReadBuffer { get; }
    public int AsyncReadBufferSize { get; }
    public Stream Stream { get; }
    public object ThisLock { get; }
    public IPEndPoint RemoteIPEndPoint { get; }
    public StreamConnection(Stream stream, ConnectionStream innerStream);
    public sealed virtual Byte[] get_AsyncReadBuffer();
    public sealed virtual int get_AsyncReadBufferSize();
    public Stream get_Stream();
    public object get_ThisLock();
    public IPEndPoint get_RemoteIPEndPoint();
    public sealed virtual void Abort();
    private Exception ConvertIOException(IOException ioException);
    public sealed virtual void Close(TimeSpan timeout, bool asyncAndLinger);
    public sealed virtual AsyncCompletionResult BeginWrite(Byte[] buffer, int offset, int size, bool immediate, TimeSpan timeout, Action`1<object> callback, object state);
    public sealed virtual void EndWrite();
    private void OnWrite(Task antecedant, object state);
    public sealed virtual void Write(Byte[] buffer, int offset, int size, bool immediate, TimeSpan timeout);
    public sealed virtual void Write(Byte[] buffer, int offset, int size, bool immediate, TimeSpan timeout, BufferManager bufferManager);
    private void SetReadTimeout(TimeSpan timeout);
    private void SetWriteTimeout(TimeSpan timeout);
    public sealed virtual int Read(Byte[] buffer, int offset, int size, TimeSpan timeout);
    public sealed virtual AsyncCompletionResult BeginRead(int offset, int size, TimeSpan timeout, Action`1<object> callback, object state);
    public sealed virtual int EndRead();
    private void OnRead(Task`1<int> antecedant, object state);
    public virtual object GetCoreTransport();
}
internal class System.ServiceModel.Channels.StreamedFramingRequestChannel : RequestChannel {
    internal IConnectionInitiator _connectionInitiator;
    internal ConnectionPool _connectionPool;
    private MessageEncoder _messageEncoder;
    private IConnectionOrientedTransportFactorySettings _settings;
    private Byte[] _startBytes;
    private StreamUpgradeProvider _upgrade;
    private ChannelBinding _channelBindingToken;
    private Byte[] Preamble { get; }
    public StreamedFramingRequestChannel(ChannelManagerBase factory, IConnectionOrientedTransportChannelFactorySettings settings, EndpointAddress remoteAddresss, Uri via, IConnectionInitiator connectionInitiator, ConnectionPool connectionPool);
    private Byte[] get_Preamble();
    protected internal virtual Task OnOpenAsync(TimeSpan timeout);
    protected virtual IAsyncResult OnBeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndOpen(IAsyncResult result);
    protected virtual void OnOpen(TimeSpan timeout);
    protected virtual void OnOpened();
    protected virtual IAsyncRequest CreateAsyncRequest(Message message);
    internal IConnection SendPreamble(IConnection connection, TimeoutHelper& timeoutHelper, ClientFramingDecoder decoder, SecurityMessageProperty& remoteSecurity);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.StreamedFramingRequestChannel/<SendPreambleAsync>d__17")]
internal Task`1<IConnection> SendPreambleAsync(IConnection connection, TimeoutHelper timeoutHelper, ClientFramingDecoder decoder);
    protected virtual void OnClose(TimeSpan timeout);
    protected virtual void OnClosed();
    protected internal virtual Task OnCloseAsync(TimeSpan timeout);
    protected virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndClose(IAsyncResult result);
}
internal class System.ServiceModel.Channels.StreamedMessage : ReceivedMessage {
    private MessageHeaders _headers;
    private XmlAttributeHolder[] _envelopeAttributes;
    private XmlAttributeHolder[] _headerAttributes;
    private XmlAttributeHolder[] _bodyAttributes;
    private string _envelopePrefix;
    private string _headerPrefix;
    private string _bodyPrefix;
    private MessageProperties _properties;
    private XmlDictionaryReader _reader;
    private XmlDictionaryReaderQuotas _quotas;
    public MessageHeaders Headers { get; }
    public MessageVersion Version { get; }
    public MessageProperties Properties { get; }
    public StreamedMessage(XmlDictionaryReader reader, int maxSizeOfHeaders, MessageVersion desiredVersion);
    public virtual MessageHeaders get_Headers();
    public virtual MessageVersion get_Version();
    public virtual MessageProperties get_Properties();
    protected virtual void OnBodyToString(XmlDictionaryWriter writer);
    protected virtual void OnClose();
    protected virtual XmlDictionaryReader OnGetReaderAtBodyContents();
    protected virtual MessageBuffer OnCreateBufferedCopy(int maxBufferSize);
    protected virtual void OnWriteStartBody(XmlDictionaryWriter writer);
    protected virtual void OnWriteStartEnvelope(XmlDictionaryWriter writer);
    protected virtual void OnWriteStartHeaders(XmlDictionaryWriter writer);
    protected virtual string OnGetBodyAttribute(string localName, string ns);
}
internal class System.ServiceModel.Channels.StreamedMessageContent : MessageContent {
    public StreamedMessageContent(Message message, MessageEncoder messageEncoder, BufferManager bufferManager);
    protected virtual Task`1<Stream> CreateContentReadStreamAsync();
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.StreamedMessageContent/<SerializeToStreamAsync>d__2")]
protected virtual Task SerializeToStreamAsync(Stream stream, TransportContext context);
    protected virtual bool TryComputeLength(Int64& length);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.StreamedMessageContent/<<CreateContentReadStreamAsync>b__1_0>d")]
[CompilerGeneratedAttribute]
private Task <CreateContentReadStreamAsync>b__1_0(object content);
}
internal static class System.ServiceModel.Channels.StreamingConnectionHelper : object {
    public static void WriteMessage(Message message, IConnection connection, bool isRequest, IConnectionOrientedTransportFactorySettings settings, TimeoutHelper& timeoutHelper);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.StreamingConnectionHelper/<WriteMessageAsync>d__1")]
public static Task WriteMessageAsync(Message message, IConnection connection, bool isRequest, IConnectionOrientedTransportFactorySettings settings, TimeoutHelper timeoutHelper);
}
public abstract class System.ServiceModel.Channels.StreamSecurityUpgradeInitiator : StreamUpgradeInitiator {
    public abstract virtual SecurityMessageProperty GetRemoteSecurity();
    internal static SecurityMessageProperty GetRemoteSecurity(StreamUpgradeInitiator upgradeInitiator);
}
internal abstract class System.ServiceModel.Channels.StreamSecurityUpgradeInitiatorBase : StreamSecurityUpgradeInitiator {
    private EndpointAddress _remoteAddress;
    private Uri _via;
    private SecurityMessageProperty _remoteSecurity;
    private bool _securityUpgraded;
    private string _nextUpgrade;
    private bool _isOpen;
    protected EndpointAddress RemoteAddress { get; }
    protected Uri Via { get; }
    protected StreamSecurityUpgradeInitiatorBase(string upgradeString, EndpointAddress remoteAddress, Uri via);
    protected EndpointAddress get_RemoteAddress();
    protected Uri get_Via();
    public virtual string GetNextUpgrade();
    public virtual SecurityMessageProperty GetRemoteSecurity();
    public virtual Stream InitiateUpgrade(Stream stream);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.StreamSecurityUpgradeInitiatorBase/<InitiateUpgradeAsync>d__14")]
internal virtual Task`1<Stream> InitiateUpgradeAsync(Stream stream);
    internal virtual void Open(TimeSpan timeout);
    internal virtual Task OpenAsync(TimeSpan timeout);
    internal virtual void Close(TimeSpan timeout);
    internal virtual Task CloseAsync(TimeSpan timeout);
    protected abstract virtual Stream OnInitiateUpgrade(Stream stream, SecurityMessageProperty& remoteSecurity);
    protected abstract virtual Task`1<Stream> OnInitiateUpgradeAsync(Stream stream, OutWrapper`1<SecurityMessageProperty> remoteSecurity);
}
public abstract class System.ServiceModel.Channels.StreamSecurityUpgradeProvider : StreamUpgradeProvider {
    public EndpointIdentity Identity { get; }
    protected StreamSecurityUpgradeProvider(IDefaultCommunicationTimeouts timeouts);
    public abstract virtual EndpointIdentity get_Identity();
}
public abstract class System.ServiceModel.Channels.StreamUpgradeBindingElement : BindingElement {
    protected StreamUpgradeBindingElement(StreamUpgradeBindingElement elementToBeCloned);
    public abstract virtual StreamUpgradeProvider BuildClientStreamUpgradeProvider(BindingContext context);
}
public abstract class System.ServiceModel.Channels.StreamUpgradeInitiator : object {
    public abstract virtual string GetNextUpgrade();
    public abstract virtual Stream InitiateUpgrade(Stream stream);
    internal abstract virtual Task`1<Stream> InitiateUpgradeAsync(Stream stream);
    internal abstract virtual void Open(TimeSpan timeout);
    internal abstract virtual Task OpenAsync(TimeSpan timeout);
    internal abstract virtual void Close(TimeSpan timeout);
    internal abstract virtual Task CloseAsync(TimeSpan timeout);
}
public abstract class System.ServiceModel.Channels.StreamUpgradeProvider : CommunicationObject {
    private TimeSpan _closeTimeout;
    private TimeSpan _openTimeout;
    protected TimeSpan DefaultCloseTimeout { get; }
    protected TimeSpan DefaultOpenTimeout { get; }
    protected StreamUpgradeProvider(IDefaultCommunicationTimeouts timeouts);
    protected virtual TimeSpan get_DefaultCloseTimeout();
    protected virtual TimeSpan get_DefaultOpenTimeout();
    public virtual T GetProperty();
    public abstract virtual StreamUpgradeInitiator CreateUpgradeInitiator(EndpointAddress remoteAddress, Uri via);
}
internal abstract class System.ServiceModel.Channels.StringDecoder : object {
    private int _encodedSize;
    private Byte[] _encodedBytes;
    private int _bytesNeeded;
    private string _value;
    private State _currentState;
    private IntDecoder _sizeDecoder;
    private int _sizeQuota;
    private int _valueLengthInBytes;
    public bool IsValueDecoded { get; }
    public string Value { get; }
    public StringDecoder(int sizeQuota);
    public bool get_IsValueDecoded();
    public string get_Value();
    public int Decode(Byte[] buffer, int offset, int size);
    protected virtual void OnComplete(string value);
    private static bool CompareBuffers(Byte[] buffer1, Byte[] buffer2, int offset);
    protected abstract virtual Exception OnSizeQuotaExceeded(int size);
    public void Reset();
}
internal class System.ServiceModel.Channels.StringMessage : ContentOnlyMessage {
    private string _data;
    public bool IsEmpty { get; }
    public StringMessage(string data);
    public virtual bool get_IsEmpty();
    protected virtual void OnWriteBodyContents(XmlDictionaryWriter writer);
}
public enum System.ServiceModel.Channels.SupportedAddressingMode : Enum {
    public int value__;
    public static SupportedAddressingMode Anonymous;
    public static SupportedAddressingMode NonAnonymous;
    public static SupportedAddressingMode Mixed;
}
internal static class System.ServiceModel.Channels.SupportedAddressingModeHelper : object {
    internal static bool IsDefined(SupportedAddressingMode value);
}
internal class System.ServiceModel.Channels.SyncCommunicationWaiter : object {
    private bool _closed;
    private object _mutex;
    private CommunicationWaitResult _result;
    private ManualResetEvent _waitHandle;
    private object ThisLock { get; }
    public SyncCommunicationWaiter(object mutex);
    private object get_ThisLock();
    public sealed virtual void Dispose();
    public sealed virtual void Signal();
    public sealed virtual CommunicationWaitResult Wait(TimeSpan timeout, bool aborting);
}
internal class System.ServiceModel.Channels.SynchronizedMessageSource : object {
    private IMessageSource _source;
    private SemaphoreSlim _sourceLock;
    public SynchronizedMessageSource(IMessageSource source);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.SynchronizedMessageSource/<WaitForMessageAsync>d__3")]
public Task`1<bool> WaitForMessageAsync(TimeSpan timeout);
    public bool WaitForMessage(TimeSpan timeout);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.SynchronizedMessageSource/<ReceiveAsync>d__5")]
public Task`1<Message> ReceiveAsync(TimeSpan timeout);
    public Message Receive(TimeSpan timeout);
}
internal class System.ServiceModel.Channels.TcpChannelFactory`1 : ConnectionOrientedTransportChannelFactory`1<TChannel> {
    private static TcpConnectionPoolRegistry s_connectionPoolRegistry;
    private TimeSpan _leaseTimeout;
    public TimeSpan LeaseTimeout { get; }
    public string Scheme { get; }
    public TcpChannelFactory`1(TcpTransportBindingElement bindingElement, BindingContext context);
    private static TcpChannelFactory`1();
    public sealed virtual TimeSpan get_LeaseTimeout();
    public virtual string get_Scheme();
    internal virtual IConnectionInitiator GetConnectionInitiator();
    internal virtual ConnectionPool GetConnectionPool();
    internal virtual void ReleaseConnectionPool(ConnectionPool pool, TimeSpan timeout);
}
internal class System.ServiceModel.Channels.TcpConnectionPoolRegistry : ConnectionPoolRegistry {
    protected virtual ConnectionPool CreatePool(IConnectionOrientedTransportChannelFactorySettings settings);
}
public class System.ServiceModel.Channels.TcpConnectionPoolSettings : object {
    private string _groupName;
    private TimeSpan _idleTimeout;
    private TimeSpan _leaseTimeout;
    private int _maxOutboundConnectionsPerEndpoint;
    public string GroupName { get; public set; }
    public TimeSpan IdleTimeout { get; public set; }
    public TimeSpan LeaseTimeout { get; public set; }
    public int MaxOutboundConnectionsPerEndpoint { get; public set; }
    internal TcpConnectionPoolSettings(TcpConnectionPoolSettings tcp);
    public string get_GroupName();
    public void set_GroupName(string value);
    public TimeSpan get_IdleTimeout();
    public void set_IdleTimeout(TimeSpan value);
    public TimeSpan get_LeaseTimeout();
    public void set_LeaseTimeout(TimeSpan value);
    public int get_MaxOutboundConnectionsPerEndpoint();
    public void set_MaxOutboundConnectionsPerEndpoint(int value);
    internal TcpConnectionPoolSettings Clone();
    internal bool IsMatch(TcpConnectionPoolSettings tcp);
}
public class System.ServiceModel.Channels.TcpTransportBindingElement : ConnectionOrientedTransportBindingElement {
    private TcpConnectionPoolSettings _connectionPoolSettings;
    public TcpConnectionPoolSettings ConnectionPoolSettings { get; }
    public string Scheme { get; }
    protected TcpTransportBindingElement(TcpTransportBindingElement elementToBeCloned);
    public TcpConnectionPoolSettings get_ConnectionPoolSettings();
    public virtual string get_Scheme();
    public virtual BindingElement Clone();
    public virtual IChannelFactory`1<TChannel> BuildChannelFactory(BindingContext context);
    public virtual T GetProperty(BindingContext context);
    internal virtual bool IsMatch(BindingElement b);
}
public static class System.ServiceModel.Channels.TcpTransportDefaults : object {
    public static int ListenBacklogConst;
    public static string ConnectionLeaseTimeoutString;
    public static bool PortSharingEnabled;
    public static bool TeredoEnabled;
    private static int ListenBacklogPre45;
    public static TimeSpan ConnectionLeaseTimeout { get; }
    public static TimeSpan get_ConnectionLeaseTimeout();
    public static int GetListenBacklog();
}
internal static class System.ServiceModel.Channels.TcpUri : object {
    public static int DefaultPort;
}
public static class System.ServiceModel.Channels.TextEncoderDefaults : object {
    public static Encoding Encoding;
    public static string EncodingString;
    public static Encoding[] SupportedEncodings;
    public static string MessageVersionString;
    public static CharSetEncoding[] CharSetEncodings;
    private static TextEncoderDefaults();
    public static void ValidateEncoding(Encoding encoding);
    public static string EncodingToCharSet(Encoding encoding);
    public static bool TryGetEncoding(string charSet, Encoding& encoding);
}
internal class System.ServiceModel.Channels.TextMessageEncoderFactory : MessageEncoderFactory {
    private TextMessageEncoder _messageEncoder;
    internal static ContentEncoding[] Soap11Content;
    internal static ContentEncoding[] Soap12Content;
    internal static ContentEncoding[] SoapNoneContent;
    internal static string Soap11MediaType;
    internal static string Soap12MediaType;
    private static string XmlMediaType;
    public MessageEncoder Encoder { get; }
    public MessageVersion MessageVersion { get; }
    public int MaxWritePoolSize { get; }
    public int MaxReadPoolSize { get; }
    public XmlDictionaryReaderQuotas ReaderQuotas { get; }
    public TextMessageEncoderFactory(MessageVersion version, Encoding writeEncoding, int maxReadPoolSize, int maxWritePoolSize, XmlDictionaryReaderQuotas quotas);
    private static TextMessageEncoderFactory();
    public virtual MessageEncoder get_Encoder();
    public virtual MessageVersion get_MessageVersion();
    public int get_MaxWritePoolSize();
    public int get_MaxReadPoolSize();
    public static Encoding[] GetSupportedEncodings();
    public XmlDictionaryReaderQuotas get_ReaderQuotas();
    internal static string GetMediaType(MessageVersion version);
    internal static string GetContentType(string mediaType, Encoding encoding);
    private static ContentEncoding[] GetContentEncodingMap(MessageVersion version);
    internal static Encoding GetEncodingFromContentType(string contentType, ContentEncoding[] contentMap);
    internal static bool TryGetEncodingFromCharSet(string charSet, Encoding& encoding);
}
public class System.ServiceModel.Channels.TextMessageEncodingBindingElement : MessageEncodingBindingElement {
    private int _maxReadPoolSize;
    private int _maxWritePoolSize;
    private XmlDictionaryReaderQuotas _readerQuotas;
    private MessageVersion _messageVersion;
    private Encoding _writeEncoding;
    [DefaultValueAttribute("64")]
public int MaxReadPoolSize { get; public set; }
    [DefaultValueAttribute("16")]
public int MaxWritePoolSize { get; public set; }
    public XmlDictionaryReaderQuotas ReaderQuotas { get; public set; }
    public MessageVersion MessageVersion { get; public set; }
    public Encoding WriteEncoding { get; public set; }
    public TextMessageEncodingBindingElement(MessageVersion messageVersion, Encoding writeEncoding);
    private TextMessageEncodingBindingElement(TextMessageEncodingBindingElement elementToBeCloned);
    public int get_MaxReadPoolSize();
    public void set_MaxReadPoolSize(int value);
    public int get_MaxWritePoolSize();
    public void set_MaxWritePoolSize(int value);
    public XmlDictionaryReaderQuotas get_ReaderQuotas();
    public void set_ReaderQuotas(XmlDictionaryReaderQuotas value);
    public virtual MessageVersion get_MessageVersion();
    public virtual void set_MessageVersion(MessageVersion value);
    public Encoding get_WriteEncoding();
    public void set_WriteEncoding(Encoding value);
    public virtual IChannelFactory`1<TChannel> BuildChannelFactory(BindingContext context);
    public virtual BindingElement Clone();
    public virtual MessageEncoderFactory CreateMessageEncoderFactory();
    public virtual T GetProperty(BindingContext context);
    internal virtual bool CheckEncodingVersion(EnvelopeVersion version);
    internal virtual bool IsMatch(BindingElement b);
}
internal class System.ServiceModel.Channels.TimeoutStream : DelegatingStream {
    private TimeoutHelper _timeoutHelper;
    private bool _disposed;
    private Byte[] _oneByteArray;
    public TimeoutStream(Stream stream, TimeSpan timeout);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.TimeoutStream/<ReadAsync>d__6")]
public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.TimeoutStream/<ReadAsyncInternal>d__7")]
private Task`1<int> ReadAsyncInternal(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte value);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.TimeoutStream/<WriteAsync>d__10")]
public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.TimeoutStream/<WriteAsyncInternal>d__11")]
private Task WriteAsyncInternal(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    protected virtual void Dispose(bool disposing);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<int> <>n__0(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__1(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
}
internal class System.ServiceModel.Channels.ToHeader : AddressingHeader {
    private Uri _to;
    private static bool mustUnderstandValue;
    private static ToHeader s_anonymousToHeader10;
    private static ToHeader AnonymousTo10 { get; }
    public XmlDictionaryString DictionaryName { get; }
    public bool MustUnderstand { get; }
    public Uri To { get; }
    protected ToHeader(Uri to, AddressingVersion version);
    private static ToHeader get_AnonymousTo10();
    public virtual XmlDictionaryString get_DictionaryName();
    public virtual bool get_MustUnderstand();
    public Uri get_To();
    public static ToHeader Create(Uri toUri, XmlDictionaryString dictionaryTo, AddressingVersion addressingVersion);
    public static ToHeader Create(Uri to, AddressingVersion addressingVersion);
    protected virtual void OnWriteHeaderContents(XmlDictionaryWriter writer, MessageVersion messageVersion);
    public static Uri ReadHeaderValue(XmlDictionaryReader reader, AddressingVersion version);
    public static Uri ReadHeaderValue(XmlDictionaryReader reader, AddressingVersion version, UriCache uriCache);
    public static ToHeader ReadHeader(XmlDictionaryReader reader, AddressingVersion version, UriCache uriCache, string actor, bool mustUnderstand, bool relay);
}
public abstract class System.ServiceModel.Channels.TransportBindingElement : BindingElement {
    private bool _manualAddressing;
    private long _maxBufferPoolSize;
    private long _maxReceivedMessageSize;
    [DefaultValueAttribute("False")]
public bool ManualAddressing { get; public set; }
    [DefaultValueAttribute("524288")]
public long MaxBufferPoolSize { get; public set; }
    [DefaultValueAttribute("65536")]
public long MaxReceivedMessageSize { get; public set; }
    public string Scheme { get; }
    protected TransportBindingElement(TransportBindingElement elementToBeCloned);
    public virtual bool get_ManualAddressing();
    public virtual void set_ManualAddressing(bool value);
    public virtual long get_MaxBufferPoolSize();
    public virtual void set_MaxBufferPoolSize(long value);
    public virtual long get_MaxReceivedMessageSize();
    public virtual void set_MaxReceivedMessageSize(long value);
    public abstract virtual string get_Scheme();
    internal static IChannelFactory`1<TChannel> CreateChannelFactory(TransportBindingElement transport);
    public virtual T GetProperty(BindingContext context);
    private ChannelProtectionRequirements GetProtectionRequirements(AddressingVersion addressingVersion);
    internal ChannelProtectionRequirements GetProtectionRequirements(BindingContext context);
    internal virtual bool IsMatch(BindingElement b);
}
public abstract class System.ServiceModel.Channels.TransportChannelFactory`1 : ChannelFactoryBase`1<TChannel> {
    private BufferManager _bufferManager;
    private long _maxBufferPoolSize;
    private long _maxReceivedMessageSize;
    private MessageEncoderFactory _messageEncoderFactory;
    private bool _manualAddressing;
    private MessageVersion _messageVersion;
    public BufferManager BufferManager { get; }
    public long MaxBufferPoolSize { get; }
    public long MaxReceivedMessageSize { get; }
    public MessageEncoderFactory MessageEncoderFactory { get; }
    public MessageVersion MessageVersion { get; }
    public bool ManualAddressing { get; }
    public string Scheme { get; }
    private long System.ServiceModel.Channels.ITransportFactorySettings.MaxReceivedMessageSize { get; }
    private BufferManager System.ServiceModel.Channels.ITransportFactorySettings.BufferManager { get; }
    private bool System.ServiceModel.Channels.ITransportFactorySettings.ManualAddressing { get; }
    private MessageEncoderFactory System.ServiceModel.Channels.ITransportFactorySettings.MessageEncoderFactory { get; }
    protected TransportChannelFactory`1(TransportBindingElement bindingElement, BindingContext context);
    protected TransportChannelFactory`1(TransportBindingElement bindingElement, BindingContext context, MessageEncoderFactory defaultMessageEncoderFactory);
    public BufferManager get_BufferManager();
    public long get_MaxBufferPoolSize();
    public long get_MaxReceivedMessageSize();
    public MessageEncoderFactory get_MessageEncoderFactory();
    public sealed virtual MessageVersion get_MessageVersion();
    public bool get_ManualAddressing();
    public abstract virtual string get_Scheme();
    public virtual T GetProperty();
    protected virtual void OnAbort();
    protected virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnClose(TimeSpan timeout);
    protected internal virtual Task OnCloseAsync(TimeSpan timeout);
    private void OnCloseOrAbort();
    public virtual int GetMaxBufferSize();
    protected virtual void OnOpening();
    public void ValidateScheme(Uri via);
    private sealed virtual override long System.ServiceModel.Channels.ITransportFactorySettings.get_MaxReceivedMessageSize();
    private sealed virtual override BufferManager System.ServiceModel.Channels.ITransportFactorySettings.get_BufferManager();
    private sealed virtual override bool System.ServiceModel.Channels.ITransportFactorySettings.get_ManualAddressing();
    private sealed virtual override MessageEncoderFactory System.ServiceModel.Channels.ITransportFactorySettings.get_MessageEncoderFactory();
}
public static class System.ServiceModel.Channels.TransportDefaults : object {
    public static bool ExtractGroupsForWindowsAccounts;
    public static HostNameComparisonMode HostNameComparisonMode;
    public static TokenImpersonationLevel ImpersonationLevel;
    public static bool ManualAddressing;
    public static long MaxReceivedMessageSize;
    public static int MaxDrainSize;
    public static long MaxBufferPoolSize;
    public static int MaxBufferSize;
    public static bool RequireClientCertificate;
    public static int MaxFaultSize;
    public static int MaxSecurityFaultSize;
    public static SslProtocols SslProtocols;
    public static int MaxRMFaultSize;
    public static MessageEncoderFactory GetDefaultMessageEncoderFactory();
}
public abstract class System.ServiceModel.Channels.TransportDuplexSessionChannel : TransportOutputChannel {
    private BufferManager _bufferManager;
    private IDuplexSession _duplexSession;
    private bool _isInputSessionClosed;
    private bool _isOutputSessionClosed;
    private MessageEncoder _messageEncoder;
    private SynchronizedMessageSource _messageSource;
    private SecurityMessageProperty _remoteSecurity;
    private EndpointAddress _localAddress;
    private SemaphoreSlim _sendLock;
    private Uri _localVia;
    private static Action`1<object> s_onWriteComplete;
    public EndpointAddress LocalAddress { get; }
    public SecurityMessageProperty RemoteSecurity { get; protected set; }
    public IDuplexSession Session { get; protected set; }
    protected BufferManager BufferManager { get; }
    protected MessageEncoder MessageEncoder { get; protected set; }
    internal SynchronizedMessageSource MessageSource { get; }
    protected bool IsStreamedOutput { get; }
    protected TransportDuplexSessionChannel(ChannelManagerBase manager, ITransportFactorySettings settings, EndpointAddress localAddress, Uri localVia, EndpointAddress remoteAddresss, Uri via);
    private static TransportDuplexSessionChannel();
    public sealed virtual EndpointAddress get_LocalAddress();
    public SecurityMessageProperty get_RemoteSecurity();
    protected void set_RemoteSecurity(SecurityMessageProperty value);
    public sealed virtual IDuplexSession get_Session();
    protected void set_Session(IDuplexSession value);
    protected BufferManager get_BufferManager();
    protected MessageEncoder get_MessageEncoder();
    protected void set_MessageEncoder(MessageEncoder value);
    internal SynchronizedMessageSource get_MessageSource();
    protected abstract virtual bool get_IsStreamedOutput();
    public sealed virtual Message Receive();
    public sealed virtual Message Receive(TimeSpan timeout);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.TransportDuplexSessionChannel/<ReceiveAsync>d__31")]
public Task`1<Message> ReceiveAsync(TimeSpan timeout);
    public sealed virtual IAsyncResult BeginReceive(AsyncCallback callback, object state);
    public sealed virtual IAsyncResult BeginReceive(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual Message EndReceive(IAsyncResult result);
    public sealed virtual IAsyncResult BeginTryReceive(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual bool EndTryReceive(IAsyncResult result, Message& message);
    public sealed virtual bool TryReceive(TimeSpan timeout, Message& message);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.TransportDuplexSessionChannel/<WaitForMessageAsync>d__38")]
public Task`1<bool> WaitForMessageAsync(TimeSpan timeout);
    public sealed virtual bool WaitForMessage(TimeSpan timeout);
    public sealed virtual IAsyncResult BeginWaitForMessage(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual bool EndWaitForMessage(IAsyncResult result);
    protected void SetMessageSource(IMessageSource messageSource);
    protected abstract virtual Task CloseOutputSessionCoreAsync(TimeSpan timeout);
    protected abstract virtual void CloseOutputSessionCore(TimeSpan timeout);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.TransportDuplexSessionChannel/<CloseOutputSessionAsync>d__45")]
protected Task CloseOutputSessionAsync(TimeSpan timeout);
    protected void CloseOutputSession(TimeSpan timeout);
    protected abstract virtual void ReturnConnectionIfNecessary(bool abort, TimeSpan timeout);
    protected virtual void OnAbort();
    protected virtual void OnFaulted();
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.TransportDuplexSessionChannel/<OnCloseAsync>d__50")]
protected internal virtual Task OnCloseAsync(TimeSpan timeout);
    protected virtual void OnClose(TimeSpan timeout);
    protected virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndClose(IAsyncResult result);
    protected virtual void OnClosed();
    protected virtual void OnReceiveMessage(Message message);
    protected void ApplyChannelBinding(Message message);
    protected virtual void PrepareMessage(Message message);
    protected abstract virtual AsyncCompletionResult StartWritingBufferedMessage(Message message, ArraySegment`1<byte> messageData, bool allowOutputBatching, TimeSpan timeout, Action`1<object> callback, object state);
    protected abstract virtual AsyncCompletionResult BeginCloseOutput(TimeSpan timeout, Action`1<object> callback, object state);
    protected virtual void FinishWritingMessage();
    protected abstract virtual ArraySegment`1<byte> EncodeMessage(Message message);
    protected abstract virtual void OnSendCore(Message message, TimeSpan timeout);
    protected abstract virtual AsyncCompletionResult StartWritingStreamedMessage(Message message, TimeSpan timeout, Action`1<object> callback, object state);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.TransportDuplexSessionChannel/<OnSendAsync>d__64")]
protected virtual Task OnSendAsync(Message message, TimeSpan timeout);
    private static void OnWriteComplete(object state);
    protected virtual void OnSend(Message message, TimeSpan timeout);
    protected abstract virtual void CompleteClose(TimeSpan timeout);
    private void ThrowIfOutputSessionClosed();
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.TransportDuplexSessionChannel/<EnsureInputClosedAsync>d__69")]
private Task EnsureInputClosedAsync(TimeSpan timeout);
    private void EnsureInputClosed(TimeSpan timeout);
    private void OnInputSessionClosed();
    private void OnOutputSessionClosed(TimeoutHelper& timeoutHelper);
}
public abstract class System.ServiceModel.Channels.TransportOutputChannel : OutputChannel {
    private bool _anyHeadersToAdd;
    private bool _manualAddressing;
    private MessageVersion _messageVersion;
    private EndpointAddress _to;
    private Uri _via;
    private ToHeader _toHeader;
    private EventTraceActivity _channelEventTraceActivity;
    protected bool ManualAddressing { get; }
    public MessageVersion MessageVersion { get; }
    public EndpointAddress RemoteAddress { get; }
    public Uri Via { get; }
    public EventTraceActivity EventTraceActivity { get; }
    protected TransportOutputChannel(ChannelManagerBase channelManager, EndpointAddress to, Uri via, bool manualAddressing, MessageVersion messageVersion);
    protected bool get_ManualAddressing();
    public MessageVersion get_MessageVersion();
    public virtual EndpointAddress get_RemoteAddress();
    public virtual Uri get_Via();
    public EventTraceActivity get_EventTraceActivity();
    protected virtual void AddHeadersTo(Message message);
}
internal static class System.ServiceModel.Channels.TransportPolicyConstants : object {
    public static string BasicHttpAuthenticationName;
    public static string CompositeDuplex;
    public static string CompositeDuplexNamespace;
    public static string CompositeDuplexPrefix;
    public static string DigestHttpAuthenticationName;
    public static string DotNetFramingNamespace;
    public static string DotNetFramingPrefix;
    public static string HttpTransportNamespace;
    public static string HttpTransportPrefix;
    public static string HttpTransportUri;
    public static string NamedPipeTransportUri;
    public static string NegotiateHttpAuthenticationName;
    public static string NtlmHttpAuthenticationName;
    public static string PeerTransportUri;
    public static string ProtectionLevelName;
    public static string RequireClientCertificateName;
    public static string SslTransportSecurityName;
    public static string StreamedName;
    public static string TcpTransportUri;
    public static string WebSocketPolicyPrefix;
    public static string WebSocketPolicyNamespace;
    public static string WebSocketTransportUri;
    public static string WebSocketEnabled;
    public static string WindowsTransportSecurityName;
}
public class System.ServiceModel.Channels.TransportSecurityBindingElement : SecurityBindingElement {
    internal bool SessionMode { get; }
    internal bool SupportsDuplex { get; }
    internal bool SupportsRequestReply { get; }
    private TransportSecurityBindingElement(TransportSecurityBindingElement elementToBeCloned);
    internal virtual ISecurityCapabilities GetIndividualISecurityCapabilities();
    internal virtual bool get_SessionMode();
    internal virtual bool get_SupportsDuplex();
    internal virtual bool get_SupportsRequestReply();
    protected virtual IChannelFactory`1<TChannel> BuildChannelFactoryCore(BindingContext context);
    public virtual T GetProperty(BindingContext context);
    public virtual BindingElement Clone();
}
internal static class System.ServiceModel.Channels.TransportSecurityHelpers : object {
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.TransportSecurityHelpers/<GetSspiCredentialAsync>d__0")]
public static Task`1<NetworkCredential> GetSspiCredentialAsync(SecurityTokenProviderContainer tokenProvider, OutWrapper`1<TokenImpersonationLevel> impersonationLevelWrapper, OutWrapper`1<AuthenticationLevel> authenticationLevelWrapper, CancellationToken cancellationToken);
    public static Task`1<NetworkCredential> GetSspiCredentialAsync(SspiSecurityTokenProvider tokenProvider, OutWrapper`1<TokenImpersonationLevel> impersonationLevel, OutWrapper`1<bool> allowNtlm, CancellationToken cancellationToken);
    public static NetworkCredential GetSspiCredential(SecurityTokenManager credentialProvider, SecurityTokenRequirement sspiTokenRequirement, TimeSpan timeout, Boolean& extractGroupsForWindowsAccounts);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.TransportSecurityHelpers/<GetSspiCredentialAsync>d__3")]
public static Task`1<NetworkCredential> GetSspiCredentialAsync(SspiSecurityTokenProvider tokenProvider, OutWrapper`1<bool> extractGroupsForWindowsAccounts, OutWrapper`1<TokenImpersonationLevel> impersonationLevelWrapper, OutWrapper`1<bool> allowNtlmWrapper, CancellationToken cancellationToken);
    internal static SecurityTokenRequirement CreateSspiTokenRequirement(string transportScheme, Uri listenUri);
    internal static SecurityTokenRequirement CreateSspiTokenRequirement(EndpointAddress target, Uri via, string transportScheme);
    public static SspiSecurityTokenProvider GetSspiTokenProvider(SecurityTokenManager tokenManager, EndpointAddress target, Uri via, string transportScheme, AuthenticationSchemes authenticationScheme, ChannelParameterCollection channelParameters);
    public static SspiSecurityTokenProvider GetSspiTokenProvider(SecurityTokenManager tokenManager, EndpointAddress target, Uri via, string transportScheme, IdentityVerifier& identityVerifier);
    public static SecurityTokenProvider GetDigestTokenProvider(SecurityTokenManager tokenManager, EndpointAddress target, Uri via, string transportScheme, AuthenticationSchemes authenticationScheme, ChannelParameterCollection channelParameters);
    public static SecurityTokenProvider GetCertificateTokenProvider(SecurityTokenManager tokenManager, EndpointAddress target, Uri via, string transportScheme, ChannelParameterCollection channelParameters);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.TransportSecurityHelpers/<GetTokenAsync>d__10`1")]
private static Task`1<T> GetTokenAsync(SecurityTokenProvider tokenProvider, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.TransportSecurityHelpers/<GetUserNameCredentialAsync>d__11")]
public static Task`1<NetworkCredential> GetUserNameCredentialAsync(SecurityTokenProviderContainer tokenProvider, CancellationToken cancellationToken);
    public static SecurityTokenProvider GetUserNameTokenProvider(SecurityTokenManager tokenManager, EndpointAddress target, Uri via, string transportScheme, AuthenticationSchemes authenticationScheme, ChannelParameterCollection channelParameters);
    public static Uri GetListenUri(Uri baseAddress, string relativeAddress);
    private static InitiatorServiceModelSecurityTokenRequirement CreateUserNameTokenRequirement(EndpointAddress target, Uri via, string transportScheme);
    private static void FixIpv6Hostname(UriBuilder uriBuilder, Uri originalUri);
}
public class System.ServiceModel.Channels.UnderstoodHeaders : object {
    private MessageHeaders _messageHeaders;
    private bool _modified;
    internal bool Modified { get; internal set; }
    internal UnderstoodHeaders(MessageHeaders messageHeaders, bool modified);
    internal bool get_Modified();
    internal void set_Modified(bool value);
    public void Add(MessageHeaderInfo headerInfo);
    public bool Contains(MessageHeaderInfo headerInfo);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IEnumerator`1<MessageHeaderInfo> GetEnumerator();
    public void Remove(MessageHeaderInfo headerInfo);
}
internal static class System.ServiceModel.Channels.UnsafeNativeMethods : object {
    public static int ERROR_SUCCESS;
    public static int ERROR_FILE_NOT_FOUND;
    public static int ERROR_ACCESS_DENIED;
    public static int ERROR_INVALID_HANDLE;
    public static int ERROR_NOT_ENOUGH_MEMORY;
    public static int ERROR_OUTOFMEMORY;
    public static int ERROR_SHARING_VIOLATION;
    public static int ERROR_NETNAME_DELETED;
    public static int ERROR_INVALID_PARAMETER;
    public static int ERROR_BROKEN_PIPE;
    public static int ERROR_ALREADY_EXISTS;
    public static int ERROR_PIPE_BUSY;
    public static int ERROR_NO_DATA;
    public static int ERROR_MORE_DATA;
    public static int WAIT_TIMEOUT;
    public static int ERROR_PIPE_CONNECTED;
    public static int ERROR_OPERATION_ABORTED;
    public static int ERROR_IO_PENDING;
    public static int ERROR_SERVICE_ALREADY_RUNNING;
    public static int ERROR_SERVICE_DISABLED;
    public static int ERROR_NO_TRACKING_SERVICE;
    public static int ERROR_ALLOTTED_SPACE_EXCEEDED;
    public static int ERROR_NO_SYSTEM_RESOURCES;
    private static int ERROR_INSUFFICIENT_BUFFER;
    public static int STATUS_PENDING;
    public static int WSAACCESS;
    public static int WSAEMFILE;
    public static int WSAEMSGSIZE;
    public static int WSAEADDRINUSE;
    public static int WSAEADDRNOTAVAIL;
    public static int WSAENETDOWN;
    public static int WSAENETUNREACH;
    public static int WSAENETRESET;
    public static int WSAECONNABORTED;
    public static int WSAECONNRESET;
    public static int WSAENOBUFS;
    public static int WSAESHUTDOWN;
    public static int WSAETIMEDOUT;
    public static int WSAECONNREFUSED;
    public static int WSAEHOSTDOWN;
    public static int WSAEHOSTUNREACH;
}
internal class System.ServiceModel.Channels.UriCache : object {
    private static int MaxKeyLength;
    private static int MaxEntries;
    private Entry[] _entries;
    private int _count;
    public Uri CreateUri(string uriString);
    private Uri Get(string key);
    private void Set(string key, Uri value);
}
internal class System.ServiceModel.Channels.UriEx : object {
    public static string UriSchemeHttp;
    public static string UriSchemeHttps;
    public static string UriSchemeNetTcp;
}
internal class System.ServiceModel.Channels.UriGenerator : object {
    private long _id;
    private string _prefix;
    public UriGenerator(string scheme);
    public UriGenerator(string scheme, string delimiter);
    public string Next();
}
internal class System.ServiceModel.Channels.ViaStringDecoder : StringDecoder {
    private Uri _via;
    public Uri ValueAsUri { get; }
    public ViaStringDecoder(int sizeQuota);
    protected virtual Exception OnSizeQuotaExceeded(int size);
    protected virtual void OnComplete(string value);
    public Uri get_ValueAsUri();
}
public static class System.ServiceModel.Channels.WebSocketDefaults : object {
    public static WebSocketTransportUsage TransportUsage;
    public static bool CreateNotificationOnConnection;
    public static string DefaultKeepAliveIntervalString;
    public static TimeSpan DefaultKeepAliveInterval;
    public static int BufferSize;
    public static int MinReceiveBufferSize;
    public static int MinSendBufferSize;
    internal static WebSocketMessageType DefaultWebSocketMessageType;
    public static string SubProtocol;
    public static string WebSocketConnectionHeaderValue;
    public static string WebSocketUpgradeHeaderValue;
    private static WebSocketDefaults();
}
internal static class System.ServiceModel.Channels.WebSocketHelper : object {
    internal static int OperationNotStarted;
    internal static int OperationFinished;
    internal static string SecWebSocketKey;
    internal static string SecWebSocketVersion;
    internal static string SecWebSocketProtocol;
    internal static string SecWebSocketAccept;
    internal static string MaxPendingConnectionsString;
    internal static string WebSocketTransportSettingsString;
    internal static string CloseOperation;
    internal static string SendOperation;
    internal static string ReceiveOperation;
    internal static Char[] ProtocolSeparators;
    private static string SchemeWs;
    private static string SchemeWss;
    private static HashSet`1<char> s_InvalidSeparatorSet;
    private static WebSocketHelper();
    internal static int GetReceiveBufferSize(long maxReceivedMessageSize);
    internal static bool UseWebSocketTransport(WebSocketTransportUsage transportUsage, bool isContractDuplex);
    internal static bool IsWebSocketUri(Uri uri);
    internal static Uri NormalizeHttpSchemeWithWsScheme(Uri uri);
    internal static bool IsSubProtocolInvalid(string protocol, String& invalidChar);
    internal static WebSocketTransportSettings GetRuntimeWebSocketSettings(WebSocketTransportSettings settings);
    internal static void ThrowCorrectException(Exception ex);
    internal static void ThrowCorrectException(Exception ex, TimeSpan timeout, string operation);
    internal static Exception ConvertAndTraceException(Exception ex);
    internal static Exception ConvertAndTraceException(Exception ex, TimeSpan timeout, string operation);
    internal static Exception ConvertAggregateExceptionToCommunicationException(AggregateException ex);
    internal static void ThrowExceptionOnTaskFailure(Task task, TimeSpan timeout, string operation);
    internal static Exception CreateExceptionOnTaskFailure(Task task, TimeSpan timeout, string operation);
    internal static TimeoutException GetTimeoutException(Exception innerException, TimeSpan timeout, string operation);
}
internal abstract class System.ServiceModel.Channels.WebSocketTransportDuplexSessionChannel : TransportDuplexSessionChannel {
    private static AsyncCallback s_streamedWriteCallback;
    private WebSocketTransportSettings _webSocketSettings;
    private TransferMode _transferMode;
    private int _maxBufferSize;
    private ITransportFactorySettings _transportFactorySettings;
    private WebSocketCloseDetails _webSocketCloseDetails;
    private Action`1<object> _waitCallback;
    private WebSocket _webSocket;
    private WebSocketStream _webSocketStream;
    private object _state;
    private int _cleanupStatus;
    private bool _shouldDisposeWebSocketAfterClosed;
    private Exception _pendingWritingMessageException;
    protected WebSocket WebSocket { get; protected set; }
    protected WebSocketTransportSettings WebSocketSettings { get; }
    protected TransferMode TransferMode { get; }
    protected int MaxBufferSize { get; }
    protected ITransportFactorySettings TransportFactorySettings { get; }
    public WebSocketTransportDuplexSessionChannel(HttpChannelFactory`1<IDuplexSessionChannel> channelFactory, EndpointAddress remoteAddresss, Uri via);
    private static WebSocketTransportDuplexSessionChannel();
    protected WebSocket get_WebSocket();
    protected void set_WebSocket(WebSocket value);
    protected WebSocketTransportSettings get_WebSocketSettings();
    protected TransferMode get_TransferMode();
    protected int get_MaxBufferSize();
    protected ITransportFactorySettings get_TransportFactorySettings();
    protected virtual void OnAbort();
    protected virtual void CompleteClose(TimeSpan timeout);
    protected virtual void CloseOutputSessionCore(TimeSpan timeout);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.WebSocketTransportDuplexSessionChannel/<CloseOutputSessionCoreAsync>d__28")]
protected virtual Task CloseOutputSessionCoreAsync(TimeSpan timeout);
    protected virtual void OnClose(TimeSpan timeout);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.WebSocketTransportDuplexSessionChannel/<OnCloseAsync>d__30")]
protected internal virtual Task OnCloseAsync(TimeSpan timeout);
    protected virtual void ReturnConnectionIfNecessary(bool abort, TimeSpan timeout);
    protected virtual AsyncCompletionResult StartWritingBufferedMessage(Message message, ArraySegment`1<byte> messageData, bool allowOutputBatching, TimeSpan timeout, Action`1<object> callback, object state);
    protected virtual void FinishWritingMessage();
    protected virtual AsyncCompletionResult StartWritingStreamedMessage(Message message, TimeSpan timeout, Action`1<object> callback, object state);
    protected virtual AsyncCompletionResult BeginCloseOutput(TimeSpan timeout, Action`1<object> callback, object state);
    protected virtual void OnSendCore(Message message, TimeSpan timeout);
    protected virtual ArraySegment`1<byte> EncodeMessage(Message message);
    protected void Cleanup();
    protected virtual void OnCleanup();
    private static void ThrowOnPendingException(Exception& pendingException);
    private Task CloseAsync();
    private Task CloseOutputAsync(CancellationToken cancellationToken);
    private static WebSocketMessageType GetWebSocketMessageType(Message message);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.WebSocketTransportDuplexSessionChannel/<HandleCloseOutputAsyncCompletion>d__44")]
private void HandleCloseOutputAsyncCompletion(Task task, TimeSpan timeout, Action`1<object> callback, object state);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.WebSocketTransportDuplexSessionChannel/<HandleSendAsyncCompletion>d__45")]
private void HandleSendAsyncCompletion(Task task, TimeSpan timeout, Action`1<object> callback, object state);
    private static void StreamWriteCallback(IAsyncResult ar);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__0(TimeSpan timeout);
}
public class System.ServiceModel.Channels.WebSocketTransportSettings : object {
    public static string ConnectionOpenedAction;
    public static string BinaryMessageReceivedAction;
    public static string TextMessageReceivedAction;
    public static string SoapContentTypeHeader;
    public static string BinaryEncoderTransferModeHeader;
    internal static string WebSocketMethod;
    internal static string SoapSubProtocol;
    internal static string TransportUsageMethodName;
    private WebSocketTransportUsage _transportUsage;
    private TimeSpan _keepAliveInterval;
    private string _subProtocol;
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public WebSocketTransportUsage TransportUsage { get; public set; }
    [DefaultValueAttribute("System.TimeSpan", "00:00:00")]
public TimeSpan KeepAliveInterval { get; public set; }
    [DefaultValueAttribute("")]
public string SubProtocol { get; public set; }
    public bool DisablePayloadMasking { get; public set; }
    private WebSocketTransportSettings(WebSocketTransportSettings settings);
    public WebSocketTransportUsage get_TransportUsage();
    public void set_TransportUsage(WebSocketTransportUsage value);
    public TimeSpan get_KeepAliveInterval();
    public void set_KeepAliveInterval(TimeSpan value);
    public string get_SubProtocol();
    public void set_SubProtocol(string value);
    public bool get_DisablePayloadMasking();
    public void set_DisablePayloadMasking(bool value);
    public sealed virtual bool Equals(WebSocketTransportSettings other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    internal WebSocketTransportSettings Clone();
}
public enum System.ServiceModel.Channels.WebSocketTransportUsage : Enum {
    public int value__;
    public static WebSocketTransportUsage WhenDuplex;
    public static WebSocketTransportUsage Always;
    public static WebSocketTransportUsage Never;
}
internal static class System.ServiceModel.Channels.WebSocketTransportUsageHelper : object {
    internal static bool IsDefined(WebSocketTransportUsage value);
    internal static void Validate(WebSocketTransportUsage value);
}
public class System.ServiceModel.Channels.WindowsStreamSecurityBindingElement : StreamUpgradeBindingElement {
    private ProtectionLevel _protectionLevel;
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public ProtectionLevel ProtectionLevel { get; public set; }
    protected WindowsStreamSecurityBindingElement(WindowsStreamSecurityBindingElement elementToBeCloned);
    public ProtectionLevel get_ProtectionLevel();
    public void set_ProtectionLevel(ProtectionLevel value);
    public virtual BindingElement Clone();
    public virtual IChannelFactory`1<TChannel> BuildChannelFactory(BindingContext context);
    public virtual bool CanBuildChannelFactory(BindingContext context);
    public virtual StreamUpgradeProvider BuildClientStreamUpgradeProvider(BindingContext context);
    public virtual T GetProperty(BindingContext context);
    internal virtual bool IsMatch(BindingElement b);
}
internal class System.ServiceModel.Channels.WindowsStreamSecurityUpgradeProvider : StreamSecurityUpgradeProvider {
    private bool _extractGroupsForWindowsAccounts;
    private EndpointIdentity _identity;
    private IdentityVerifier _identityVerifier;
    private ProtectionLevel _protectionLevel;
    private SecurityTokenManager _securityTokenManager;
    private NetworkCredential _serverCredential;
    private string _scheme;
    private bool _isClient;
    private Uri _listenUri;
    public string Scheme { get; }
    internal bool ExtractGroupsForWindowsAccounts { get; }
    public EndpointIdentity Identity { get; }
    internal IdentityVerifier IdentityVerifier { get; }
    public ProtectionLevel ProtectionLevel { get; }
    private NetworkCredential ServerCredential { get; }
    public WindowsStreamSecurityUpgradeProvider(WindowsStreamSecurityBindingElement bindingElement, BindingContext context, bool isClient);
    public string get_Scheme();
    internal bool get_ExtractGroupsForWindowsAccounts();
    public virtual EndpointIdentity get_Identity();
    internal IdentityVerifier get_IdentityVerifier();
    public ProtectionLevel get_ProtectionLevel();
    private NetworkCredential get_ServerCredential();
    public virtual StreamUpgradeInitiator CreateUpgradeInitiator(EndpointAddress remoteAddress, Uri via);
    protected virtual void OnAbort();
    protected virtual void OnClose(TimeSpan timeout);
    protected internal virtual Task OnCloseAsync(TimeSpan timeout);
    protected virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndClose(IAsyncResult result);
    protected virtual void OnOpen(TimeSpan timeout);
    protected internal virtual Task OnOpenAsync(TimeSpan timeout);
    protected virtual IAsyncResult OnBeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndOpen(IAsyncResult result);
    protected virtual void OnOpened();
}
internal class System.ServiceModel.Channels.XmlAttributeHolder : ValueType {
    private string _prefix;
    private string _ns;
    private string _localName;
    private string _value;
    public static XmlAttributeHolder[] emptyArray;
    public string Prefix { get; }
    public string NamespaceUri { get; }
    public string LocalName { get; }
    public string Value { get; }
    public XmlAttributeHolder(string prefix, string localName, string ns, string value);
    private static XmlAttributeHolder();
    public string get_Prefix();
    public string get_NamespaceUri();
    public string get_LocalName();
    public string get_Value();
    public void WriteTo(XmlWriter writer);
    public static void WriteAttributes(XmlAttributeHolder[] attributes, XmlWriter writer);
    public static XmlAttributeHolder[] ReadAttributes(XmlDictionaryReader reader);
    public static XmlAttributeHolder[] ReadAttributes(XmlDictionaryReader reader, Int32& maxSizeOfHeaders);
    private static void Deduct(string s, Int32& maxSizeOfHeaders);
    public static string GetAttribute(XmlAttributeHolder[] attributes, string localName, string ns);
}
internal class System.ServiceModel.Channels.XmlObjectSerializerBodyWriter : BodyWriter {
    private object _body;
    private XmlObjectSerializer _serializer;
    private object ThisLock { get; }
    public XmlObjectSerializerBodyWriter(object body, XmlObjectSerializer serializer);
    private object get_ThisLock();
    protected virtual void OnWriteBodyContents(XmlDictionaryWriter writer);
}
public class System.ServiceModel.Channels.XmlObjectSerializerFault : MessageFault {
    private FaultCode _code;
    private FaultReason _reason;
    private string _actor;
    private string _node;
    private object _detail;
    private XmlObjectSerializer _serializer;
    public string Actor { get; }
    public FaultCode Code { get; }
    public bool HasDetail { get; }
    public string Node { get; }
    public FaultReason Reason { get; }
    private object ThisLock { get; }
    public XmlObjectSerializerFault(FaultCode code, FaultReason reason, object detail, XmlObjectSerializer serializer, string actor, string node);
    public virtual string get_Actor();
    public virtual FaultCode get_Code();
    public virtual bool get_HasDetail();
    public virtual string get_Node();
    public virtual FaultReason get_Reason();
    private object get_ThisLock();
    protected virtual void OnWriteDetailContents(XmlDictionaryWriter writer);
}
internal class System.ServiceModel.Channels.XmlObjectSerializerHeader : MessageHeader {
    private XmlObjectSerializer _serializer;
    private bool _mustUnderstand;
    private bool _relay;
    private bool _isOneTwoSupported;
    private bool _isOneOneSupported;
    private bool _isNoneSupported;
    private object _objectToSerialize;
    private string _name;
    private string _ns;
    private string _actor;
    private object _syncRoot;
    public string Name { get; }
    public string Namespace { get; }
    public bool MustUnderstand { get; }
    public bool Relay { get; }
    public string Actor { get; }
    private XmlObjectSerializerHeader(XmlObjectSerializer serializer, bool mustUnderstand, string actor, bool relay);
    public XmlObjectSerializerHeader(string name, string ns, object objectToSerialize, XmlObjectSerializer serializer, bool mustUnderstand, string actor, bool relay);
    public virtual bool IsMessageVersionSupported(MessageVersion messageVersion);
    public virtual string get_Name();
    public virtual string get_Namespace();
    public virtual bool get_MustUnderstand();
    public virtual bool get_Relay();
    public virtual string get_Actor();
    protected virtual void OnWriteHeaderContents(XmlDictionaryWriter writer, MessageVersion messageVersion);
}
internal class System.ServiceModel.Channels.XmlReaderBodyWriter : BodyWriter {
    private XmlDictionaryReader _reader;
    private bool _isFault;
    internal bool IsFault { get; }
    public XmlReaderBodyWriter(XmlDictionaryReader reader, EnvelopeVersion version);
    internal virtual bool get_IsFault();
    protected virtual BodyWriter OnCreateBufferedCopy(int maxBufferSize);
    protected virtual void OnWriteBodyContents(XmlDictionaryWriter writer);
}
public class System.ServiceModel.ChannelTerminatedException : CommunicationException {
    public ChannelTerminatedException(string message);
    public ChannelTerminatedException(string message, Exception innerException);
    protected ChannelTerminatedException(SerializationInfo info, StreamingContext context);
}
public abstract class System.ServiceModel.ClientBase`1 : object {
    private TChannel _channel;
    private ChannelFactory`1<TChannel> _channelFactory;
    private object _syncRoot;
    private static AsyncCallback s_onAsyncCallCompleted;
    private object ThisLock { get; }
    protected TChannel Channel { get; }
    public ChannelFactory`1<TChannel> ChannelFactory { get; }
    public ClientCredentials ClientCredentials { get; }
    public CommunicationState State { get; }
    public IClientChannel InnerChannel { get; }
    public ServiceEndpoint Endpoint { get; }
    protected ClientBase`1(string endpointConfigurationName);
    protected ClientBase`1(string endpointConfigurationName, string remoteAddress);
    protected ClientBase`1(string endpointConfigurationName, EndpointAddress remoteAddress);
    protected ClientBase`1(Binding binding, EndpointAddress remoteAddress);
    protected ClientBase`1(InstanceContext callbackInstance, Binding binding, EndpointAddress remoteAddress);
    private static ClientBase`1();
    protected T GetDefaultValueForInitialization();
    private object get_ThisLock();
    protected TChannel get_Channel();
    public ChannelFactory`1<TChannel> get_ChannelFactory();
    public ClientCredentials get_ClientCredentials();
    public sealed virtual CommunicationState get_State();
    public IClientChannel get_InnerChannel();
    public ServiceEndpoint get_Endpoint();
    public sealed virtual void Open();
    public sealed virtual void Abort();
    public sealed virtual void Close();
    private void CreateChannelInternal();
    protected virtual TChannel CreateChannel();
    private sealed virtual override void System.IDisposable.Dispose();
    private sealed virtual override void System.ServiceModel.ICommunicationObject.Open(TimeSpan timeout);
    private sealed virtual override void System.ServiceModel.ICommunicationObject.Close(TimeSpan timeout);
    private sealed virtual override void System.ServiceModel.ICommunicationObject.add_Closed(EventHandler value);
    private sealed virtual override void System.ServiceModel.ICommunicationObject.remove_Closed(EventHandler value);
    private sealed virtual override void System.ServiceModel.ICommunicationObject.add_Closing(EventHandler value);
    private sealed virtual override void System.ServiceModel.ICommunicationObject.remove_Closing(EventHandler value);
    private sealed virtual override void System.ServiceModel.ICommunicationObject.add_Faulted(EventHandler value);
    private sealed virtual override void System.ServiceModel.ICommunicationObject.remove_Faulted(EventHandler value);
    private sealed virtual override void System.ServiceModel.ICommunicationObject.add_Opened(EventHandler value);
    private sealed virtual override void System.ServiceModel.ICommunicationObject.remove_Opened(EventHandler value);
    private sealed virtual override void System.ServiceModel.ICommunicationObject.add_Opening(EventHandler value);
    private sealed virtual override void System.ServiceModel.ICommunicationObject.remove_Opening(EventHandler value);
    private sealed virtual override IAsyncResult System.ServiceModel.ICommunicationObject.BeginClose(AsyncCallback callback, object state);
    private sealed virtual override IAsyncResult System.ServiceModel.ICommunicationObject.BeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    private sealed virtual override void System.ServiceModel.ICommunicationObject.EndClose(IAsyncResult result);
    private sealed virtual override IAsyncResult System.ServiceModel.ICommunicationObject.BeginOpen(AsyncCallback callback, object state);
    private sealed virtual override IAsyncResult System.ServiceModel.ICommunicationObject.BeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    private sealed virtual override void System.ServiceModel.ICommunicationObject.EndOpen(IAsyncResult result);
    internal IAsyncResult BeginFactoryOpen(TimeSpan timeout, AsyncCallback callback, object state);
    internal void EndFactoryOpen(IAsyncResult result);
    internal IAsyncResult BeginChannelOpen(TimeSpan timeout, AsyncCallback callback, object state);
    internal void EndChannelOpen(IAsyncResult result);
    internal IAsyncResult BeginFactoryClose(TimeSpan timeout, AsyncCallback callback, object state);
    internal void EndFactoryClose(IAsyncResult result);
    internal IAsyncResult BeginChannelClose(TimeSpan timeout, AsyncCallback callback, object state);
    internal void EndChannelClose(IAsyncResult result);
    protected void InvokeAsync(BeginOperationDelegate<TChannel> beginOperationDelegate, Object[] inValues, EndOperationDelegate<TChannel> endOperationDelegate, SendOrPostCallback operationCompletedCallback, object userState);
    private static void OnAsyncCallCompleted(IAsyncResult result);
    private static void CompleteAsyncCall(AsyncOperationContext<TChannel> context, Object[] results, Exception error);
}
public class System.ServiceModel.ClientCredentialsSecurityTokenManager : SecurityTokenManager {
    private ClientCredentials _parent;
    public ClientCredentials ClientCredentials { get; }
    public ClientCredentialsSecurityTokenManager(ClientCredentials clientCredentials);
    public ClientCredentials get_ClientCredentials();
    private string GetServicePrincipalName(InitiatorServiceModelSecurityTokenRequirement initiatorRequirement);
    private bool IsDigestAuthenticationScheme(SecurityTokenRequirement requirement);
    protected internal bool IsIssuedSecurityTokenRequirement(SecurityTokenRequirement requirement);
    public virtual SecurityTokenProvider CreateSecurityTokenProvider(SecurityTokenRequirement tokenRequirement);
    public virtual SecurityTokenSerializer CreateSecurityTokenSerializer(SecurityTokenVersion version);
    private X509SecurityTokenAuthenticator CreateServerX509TokenAuthenticator();
    private X509SecurityTokenAuthenticator CreateServerSslX509TokenAuthenticator();
    public virtual SecurityTokenAuthenticator CreateSecurityTokenAuthenticator(SecurityTokenRequirement tokenRequirement, SecurityTokenResolver& outOfBandTokenResolver);
}
internal class System.ServiceModel.CloseCollectionAsyncResult : AsyncResult {
    private bool _completedSynchronously;
    private Exception _exception;
    private static AsyncCallback s_nestedCallback;
    private int _count;
    public CloseCollectionAsyncResult(TimeSpan timeout, AsyncCallback otherCallback, object state, IList`1<ICommunicationObject> collection);
    private static CloseCollectionAsyncResult();
    private void CompleteClose(ICommunicationObject communicationObject, IAsyncResult result);
    private static void Callback(IAsyncResult result);
    private void Decrement(bool completedSynchronously);
    private void Decrement(bool completedSynchronously, Exception exception);
    public static void End(IAsyncResult result);
}
public class System.ServiceModel.CommunicationException : Exception {
    public CommunicationException(string message);
    public CommunicationException(string message, Exception innerException);
    protected CommunicationException(SerializationInfo info, StreamingContext context);
}
public class System.ServiceModel.CommunicationObjectAbortedException : CommunicationException {
    public CommunicationObjectAbortedException(string message);
    public CommunicationObjectAbortedException(string message, Exception innerException);
    protected CommunicationObjectAbortedException(SerializationInfo info, StreamingContext context);
}
public class System.ServiceModel.CommunicationObjectFaultedException : CommunicationException {
    public CommunicationObjectFaultedException(string message);
    public CommunicationObjectFaultedException(string message, Exception innerException);
    protected CommunicationObjectFaultedException(SerializationInfo info, StreamingContext context);
}
public enum System.ServiceModel.CommunicationState : Enum {
    public int value__;
    public static CommunicationState Created;
    public static CommunicationState Opening;
    public static CommunicationState Opened;
    public static CommunicationState Closing;
    public static CommunicationState Closed;
    public static CommunicationState Faulted;
}
public enum System.ServiceModel.ConcurrencyMode : Enum {
    public int value__;
    public static ConcurrencyMode Single;
    public static ConcurrencyMode Reentrant;
    public static ConcurrencyMode Multiple;
}
public static class System.ServiceModel.ConcurrencyModeHelper : object {
    public static bool IsDefined(ConcurrencyMode x);
}
internal static class System.ServiceModel.CoordinationExternal10Strings : object {
    public static string Namespace;
    public static string CreateCoordinationContextAction;
    public static string CreateCoordinationContextResponseAction;
    public static string RegisterAction;
    public static string RegisterResponseAction;
    public static string FaultAction;
}
internal class System.ServiceModel.CoordinationExternal11Dictionary : object {
    public XmlDictionaryString Namespace;
    public XmlDictionaryString CreateCoordinationContextAction;
    public XmlDictionaryString CreateCoordinationContextResponseAction;
    public XmlDictionaryString RegisterAction;
    public XmlDictionaryString RegisterResponseAction;
    public XmlDictionaryString FaultAction;
    public XmlDictionaryString CannotCreateContext;
    public XmlDictionaryString CannotRegisterParticipant;
    public CoordinationExternal11Dictionary(XmlDictionary dictionary);
}
internal static class System.ServiceModel.CoordinationExternal11Strings : object {
    public static string Namespace;
    public static string CreateCoordinationContextAction;
    public static string CreateCoordinationContextResponseAction;
    public static string RegisterAction;
    public static string RegisterResponseAction;
    public static string FaultAction;
    public static string CannotCreateContext;
    public static string CannotRegisterParticipant;
}
internal static class System.ServiceModel.CoordinationExternalStrings : object {
    public static string Prefix;
    public static string CreateCoordinationContext;
    public static string CreateCoordinationContextResponse;
    public static string CoordinationContext;
    public static string CurrentContext;
    public static string CoordinationType;
    public static string RegistrationService;
    public static string Register;
    public static string RegisterResponse;
    public static string Protocol;
    public static string CoordinatorProtocolService;
    public static string ParticipantProtocolService;
    public static string Expires;
    public static string Identifier;
    public static string ActivationCoordinatorPortType;
    public static string RegistrationCoordinatorPortType;
    public static string InvalidState;
    public static string InvalidProtocol;
    public static string InvalidParameters;
    public static string NoActivity;
    public static string ContextRefused;
    public static string AlreadyRegistered;
}
[AttributeUsageAttribute("1092")]
public class System.ServiceModel.DataContractFormatAttribute : Attribute {
    private OperationFormatStyle _style;
    public OperationFormatStyle Style { get; public set; }
    public OperationFormatStyle get_Style();
    public void set_Style(OperationFormatStyle value);
}
public class System.ServiceModel.Description.ClientCredentials : SecurityCredentialsManager {
    private UserNamePasswordClientCredential _userName;
    private X509CertificateInitiatorClientCredential _clientCertificate;
    private X509CertificateRecipientClientCredential _serviceCertificate;
    private WindowsClientCredential _windows;
    private HttpDigestClientCredential _httpDigest;
    private bool _isReadOnly;
    public UserNamePasswordClientCredential UserName { get; }
    public X509CertificateInitiatorClientCredential ClientCertificate { get; }
    public X509CertificateRecipientClientCredential ServiceCertificate { get; }
    public WindowsClientCredential Windows { get; }
    public HttpDigestClientCredential HttpDigest { get; }
    protected ClientCredentials(ClientCredentials other);
    public UserNamePasswordClientCredential get_UserName();
    public X509CertificateInitiatorClientCredential get_ClientCertificate();
    public X509CertificateRecipientClientCredential get_ServiceCertificate();
    public WindowsClientCredential get_Windows();
    public HttpDigestClientCredential get_HttpDigest();
    internal static ClientCredentials CreateDefaultCredentials();
    public virtual SecurityTokenManager CreateSecurityTokenManager();
    protected virtual ClientCredentials CloneCore();
    public ClientCredentials Clone();
    private sealed virtual override void System.ServiceModel.Description.IEndpointBehavior.Validate(ServiceEndpoint serviceEndpoint);
    private sealed virtual override void System.ServiceModel.Description.IEndpointBehavior.AddBindingParameters(ServiceEndpoint serviceEndpoint, BindingParameterCollection bindingParameters);
    private sealed virtual override void System.ServiceModel.Description.IEndpointBehavior.ApplyDispatchBehavior(ServiceEndpoint serviceEndpoint, EndpointDispatcher endpointDispatcher);
    public virtual void ApplyClientBehavior(ServiceEndpoint serviceEndpoint, ClientRuntime behavior);
    internal void MakeReadOnly();
}
[DebuggerDisplayAttribute("Name={_name}, Namespace={_ns}, ContractType={_contractType}")]
public class System.ServiceModel.Description.ContractDescription : object {
    private Type _callbackContractType;
    private string _configurationName;
    private Type _contractType;
    private XmlName _name;
    private string _ns;
    private OperationDescriptionCollection _operations;
    private SessionMode _sessionMode;
    private KeyedByTypeCollection`1<IContractBehavior> _behaviors;
    private ProtectionLevel _protectionLevel;
    private bool _hasProtectionLevel;
    internal string CodeName { get; }
    [DefaultValueAttribute("")]
public string ConfigurationName { get; public set; }
    public Type ContractType { get; public set; }
    public Type CallbackContractType { get; public set; }
    public string Name { get; public set; }
    public string Namespace { get; public set; }
    public OperationDescriptionCollection Operations { get; }
    public ProtectionLevel ProtectionLevel { get; public set; }
    public bool HasProtectionLevel { get; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public SessionMode SessionMode { get; public set; }
    public KeyedCollection`2<Type, IContractBehavior> ContractBehaviors { get; }
    [EditorBrowsableAttribute("1")]
public KeyedByTypeCollection`1<IContractBehavior> Behaviors { get; }
    public ContractDescription(string name);
    public ContractDescription(string name, string ns);
    internal string get_CodeName();
    public string get_ConfigurationName();
    public void set_ConfigurationName(string value);
    public Type get_ContractType();
    public void set_ContractType(Type value);
    public Type get_CallbackContractType();
    public void set_CallbackContractType(Type value);
    public string get_Name();
    public void set_Name(string value);
    public string get_Namespace();
    public void set_Namespace(string value);
    public OperationDescriptionCollection get_Operations();
    public ProtectionLevel get_ProtectionLevel();
    public void set_ProtectionLevel(ProtectionLevel value);
    public bool ShouldSerializeProtectionLevel();
    public bool get_HasProtectionLevel();
    public SessionMode get_SessionMode();
    public void set_SessionMode(SessionMode value);
    public KeyedCollection`2<Type, IContractBehavior> get_ContractBehaviors();
    public KeyedByTypeCollection`1<IContractBehavior> get_Behaviors();
    public static ContractDescription GetContract(Type contractType);
    public static ContractDescription GetContract(Type contractType, Type serviceType);
    public static ContractDescription GetContract(Type contractType, object serviceImplementation);
    public Collection`1<ContractDescription> GetInheritedContracts();
    internal void EnsureInvariants();
    internal bool IsDuplex();
}
internal class System.ServiceModel.Description.CustomAttributeProvider : object {
    private object _attrProvider;
    [CompilerGeneratedAttribute]
private AttributeProviderType <ProviderType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private MemberInfo <MemberInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private MethodInfo <MethodInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private ParameterInfo <ParameterInfo>k__BackingField;
    private AttributeProviderType ProviderType { get; private set; }
    internal Type Type { get; private set; }
    internal MemberInfo MemberInfo { get; private set; }
    internal MethodInfo MethodInfo { get; private set; }
    internal ParameterInfo ParameterInfo { get; private set; }
    private CustomAttributeProvider(object attrProvider);
    [CompilerGeneratedAttribute]
private AttributeProviderType get_ProviderType();
    [CompilerGeneratedAttribute]
private void set_ProviderType(AttributeProviderType value);
    [CompilerGeneratedAttribute]
internal Type get_Type();
    [CompilerGeneratedAttribute]
private void set_Type(Type value);
    [CompilerGeneratedAttribute]
internal MemberInfo get_MemberInfo();
    [CompilerGeneratedAttribute]
private void set_MemberInfo(MemberInfo value);
    [CompilerGeneratedAttribute]
internal MethodInfo get_MethodInfo();
    [CompilerGeneratedAttribute]
private void set_MethodInfo(MethodInfo value);
    [CompilerGeneratedAttribute]
internal ParameterInfo get_ParameterInfo();
    [CompilerGeneratedAttribute]
private void set_ParameterInfo(ParameterInfo value);
    public Object[] GetCustomAttributes(bool inherit);
    public Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public bool IsDefined(Type attributeType, bool inherit);
    public static CustomAttributeProvider op_Implicit(MemberInfo attrProvider);
    public static CustomAttributeProvider op_Implicit(MethodInfo attrProvider);
    public static CustomAttributeProvider op_Implicit(ParameterInfo attrProvider);
    public static CustomAttributeProvider op_Implicit(Type attrProvider);
}
public class System.ServiceModel.Description.DataContractSerializerOperationBehavior : object {
    private bool _builtInOperationBehavior;
    private OperationDescription _operation;
    private DataContractFormatAttribute _dataContractFormatAttribute;
    internal bool ignoreExtensionDataObject;
    private bool _ignoreExtensionDataObjectSetExplicit;
    internal int maxItemsInObjectGraph;
    private bool _maxItemsInObjectGraphSetExplicit;
    private DataContractResolver _dataContractResolver;
    public DataContractFormatAttribute DataContractFormatAttribute { get; }
    internal bool IsBuiltInOperationBehavior { get; }
    public int MaxItemsInObjectGraph { get; public set; }
    internal bool MaxItemsInObjectGraphSetExplicit { get; internal set; }
    public bool IgnoreExtensionDataObject { get; public set; }
    internal bool IgnoreExtensionDataObjectSetExplicit { get; internal set; }
    public DataContractResolver DataContractResolver { get; public set; }
    public DataContractSerializerOperationBehavior(OperationDescription operation);
    public DataContractSerializerOperationBehavior(OperationDescription operation, DataContractFormatAttribute dataContractFormatAttribute);
    internal DataContractSerializerOperationBehavior(OperationDescription operation, DataContractFormatAttribute dataContractFormatAttribute, bool builtInOperationBehavior);
    public DataContractFormatAttribute get_DataContractFormatAttribute();
    internal bool get_IsBuiltInOperationBehavior();
    public int get_MaxItemsInObjectGraph();
    public void set_MaxItemsInObjectGraph(int value);
    internal bool get_MaxItemsInObjectGraphSetExplicit();
    internal void set_MaxItemsInObjectGraphSetExplicit(bool value);
    public bool get_IgnoreExtensionDataObject();
    public void set_IgnoreExtensionDataObject(bool value);
    internal bool get_IgnoreExtensionDataObjectSetExplicit();
    internal void set_IgnoreExtensionDataObjectSetExplicit(bool value);
    public DataContractResolver get_DataContractResolver();
    public void set_DataContractResolver(DataContractResolver value);
    public virtual XmlObjectSerializer CreateSerializer(Type type, string name, string ns, IList`1<Type> knownTypes);
    public virtual XmlObjectSerializer CreateSerializer(Type type, XmlDictionaryString name, XmlDictionaryString ns, IList`1<Type> knownTypes);
    internal object GetFormatter(OperationDescription operation, Boolean& formatRequest, Boolean& formatReply, bool isProxy);
    private sealed virtual override void System.ServiceModel.Description.IOperationBehavior.Validate(OperationDescription description);
    private sealed virtual override void System.ServiceModel.Description.IOperationBehavior.AddBindingParameters(OperationDescription description, BindingParameterCollection parameters);
    private sealed virtual override void System.ServiceModel.Description.IOperationBehavior.ApplyDispatchBehavior(OperationDescription description, DispatchOperation dispatch);
    private sealed virtual override void System.ServiceModel.Description.IOperationBehavior.ApplyClientBehavior(OperationDescription description, ClientOperation proxy);
}
internal class System.ServiceModel.Description.DispatcherBuilder : object {
    internal static ClientRuntime BuildProxyBehavior(ServiceEndpoint serviceEndpoint, BindingParameterCollection& parameters);
    private static void AddBindingParameters(ServiceEndpoint endpoint, BindingParameterCollection parameters);
    private static void BuildProxyOperation(OperationDescription operation, ClientRuntime parent);
    private static void BuildDispatchOperation(OperationDescription operation, DispatchRuntime parent);
    private static void ApplyClientBehavior(ServiceEndpoint serviceEndpoint, ClientRuntime clientRuntime);
    private static void BindOperations(ContractDescription contract, ClientRuntime proxy, DispatchRuntime dispatch);
}
[DebuggerDisplayAttribute("Name={_name}, Action={_action}, DetailType={_detailType}")]
public class System.ServiceModel.Description.FaultDescription : object {
    private string _action;
    private Type _detailType;
    private XmlName _elementName;
    private XmlName _name;
    private string _ns;
    private ProtectionLevel _protectionLevel;
    private bool _hasProtectionLevel;
    public string Action { get; internal set; }
    public Type DetailType { get; public set; }
    public string Name { get; public set; }
    public string Namespace { get; public set; }
    internal XmlName ElementName { get; internal set; }
    public ProtectionLevel ProtectionLevel { get; public set; }
    public bool HasProtectionLevel { get; }
    public FaultDescription(string action);
    public string get_Action();
    internal void set_Action(string value);
    public Type get_DetailType();
    public void set_DetailType(Type value);
    public string get_Name();
    public void set_Name(string value);
    public string get_Namespace();
    public void set_Namespace(string value);
    internal XmlName get_ElementName();
    internal void set_ElementName(XmlName value);
    public ProtectionLevel get_ProtectionLevel();
    public void set_ProtectionLevel(ProtectionLevel value);
    public bool ShouldSerializeProtectionLevel();
    public bool get_HasProtectionLevel();
    internal void ResetProtectionLevel();
    internal void SetNameAndElement(XmlName name);
    internal void SetNameOnly(XmlName name);
}
public class System.ServiceModel.Description.FaultDescriptionCollection : Collection`1<FaultDescription> {
    public FaultDescription Find(string action);
    public Collection`1<FaultDescription> FindAll(string action);
}
public interface System.ServiceModel.Description.IContractBehavior {
    public abstract virtual void Validate(ContractDescription contractDescription, ServiceEndpoint endpoint);
    public abstract virtual void ApplyDispatchBehavior(ContractDescription contractDescription, ServiceEndpoint endpoint, DispatchRuntime dispatchRuntime);
    public abstract virtual void ApplyClientBehavior(ContractDescription contractDescription, ServiceEndpoint endpoint, ClientRuntime clientRuntime);
    public abstract virtual void AddBindingParameters(ContractDescription contractDescription, ServiceEndpoint endpoint, BindingParameterCollection bindingParameters);
}
internal interface System.ServiceModel.Description.IContractResolver {
    public abstract virtual ContractDescription ResolveContract(string contractName);
}
public interface System.ServiceModel.Description.IEndpointBehavior {
    public abstract virtual void Validate(ServiceEndpoint endpoint);
    public abstract virtual void AddBindingParameters(ServiceEndpoint endpoint, BindingParameterCollection bindingParameters);
    public abstract virtual void ApplyDispatchBehavior(ServiceEndpoint endpoint, EndpointDispatcher endpointDispatcher);
    public abstract virtual void ApplyClientBehavior(ServiceEndpoint endpoint, ClientRuntime clientRuntime);
}
public interface System.ServiceModel.Description.IOperationBehavior {
    public abstract virtual void Validate(OperationDescription operationDescription);
    public abstract virtual void ApplyDispatchBehavior(OperationDescription operationDescription, DispatchOperation dispatchOperation);
    public abstract virtual void ApplyClientBehavior(OperationDescription operationDescription, ClientOperation clientOperation);
    public abstract virtual void AddBindingParameters(OperationDescription operationDescription, BindingParameterCollection bindingParameters);
}
public enum System.ServiceModel.Description.ListenUriMode : Enum {
    public int value__;
    public static ListenUriMode Explicit;
    public static ListenUriMode Unique;
}
internal static class System.ServiceModel.Description.ListenUriModeHelper : object {
    public static bool IsDefined(ListenUriMode mode);
}
public class System.ServiceModel.Description.MessageBodyDescription : object {
    private XmlName _wrapperName;
    private string _wrapperNs;
    private MessagePartDescriptionCollection _parts;
    private MessagePartDescription _returnValue;
    public MessagePartDescriptionCollection Parts { get; }
    [DefaultValueAttribute("")]
public MessagePartDescription ReturnValue { get; public set; }
    [DefaultValueAttribute("")]
public string WrapperName { get; public set; }
    [DefaultValueAttribute("")]
public string WrapperNamespace { get; public set; }
    internal MessageBodyDescription(MessageBodyDescription other);
    internal MessageBodyDescription Clone();
    public MessagePartDescriptionCollection get_Parts();
    public MessagePartDescription get_ReturnValue();
    public void set_ReturnValue(MessagePartDescription value);
    public string get_WrapperName();
    public void set_WrapperName(string value);
    public string get_WrapperNamespace();
    public void set_WrapperNamespace(string value);
}
[DebuggerDisplayAttribute("Action={_action}, Direction={_direction}, MessageType={_messageType}")]
public class System.ServiceModel.Description.MessageDescription : object {
    private static Type s_typeOfUntypedMessage;
    private string _action;
    private MessageDirection _direction;
    private MessageDescriptionItems _items;
    private XmlName _messageName;
    private Type _messageType;
    private XmlQualifiedName _xsdType;
    private ProtectionLevel _protectionLevel;
    private bool _hasProtectionLevel;
    public string Action { get; internal set; }
    public MessageBodyDescription Body { get; }
    public MessageDirection Direction { get; }
    public MessageHeaderDescriptionCollection Headers { get; }
    public MessagePropertyDescriptionCollection Properties { get; }
    internal MessageDescriptionItems Items { get; }
    public ProtectionLevel ProtectionLevel { get; public set; }
    public bool HasProtectionLevel { get; }
    internal static Type TypeOfUntypedMessage { get; }
    internal XmlName MessageName { get; internal set; }
    [DefaultValueAttribute("")]
public Type MessageType { get; public set; }
    internal bool IsTypedMessage { get; }
    internal bool IsUntypedMessage { get; }
    internal bool IsVoid { get; }
    internal XmlQualifiedName XsdTypeName { get; internal set; }
    public MessageDescription(string action, MessageDirection direction);
    internal MessageDescription(string action, MessageDirection direction, MessageDescriptionItems items);
    internal MessageDescription(MessageDescription other);
    internal MessageDescription Clone();
    public string get_Action();
    internal void set_Action(string value);
    public MessageBodyDescription get_Body();
    public MessageDirection get_Direction();
    public MessageHeaderDescriptionCollection get_Headers();
    public MessagePropertyDescriptionCollection get_Properties();
    internal MessageDescriptionItems get_Items();
    public ProtectionLevel get_ProtectionLevel();
    public void set_ProtectionLevel(ProtectionLevel value);
    public bool ShouldSerializeProtectionLevel();
    public bool get_HasProtectionLevel();
    internal static Type get_TypeOfUntypedMessage();
    internal XmlName get_MessageName();
    internal void set_MessageName(XmlName value);
    public Type get_MessageType();
    public void set_MessageType(Type value);
    internal bool get_IsTypedMessage();
    internal bool get_IsUntypedMessage();
    internal bool get_IsVoid();
    internal XmlQualifiedName get_XsdTypeName();
    internal void set_XsdTypeName(XmlQualifiedName value);
    internal void ResetProtectionLevel();
}
public class System.ServiceModel.Description.MessageDescriptionCollection : Collection`1<MessageDescription> {
    public MessageDescription Find(string action);
    public Collection`1<MessageDescription> FindAll(string action);
}
internal class System.ServiceModel.Description.MessageDescriptionItems : object {
    private MessageHeaderDescriptionCollection _headers;
    private MessageBodyDescription _body;
    private MessagePropertyDescriptionCollection _properties;
    internal MessageBodyDescription Body { get; internal set; }
    internal MessageHeaderDescriptionCollection Headers { get; }
    internal MessagePropertyDescriptionCollection Properties { get; }
    internal MessageBodyDescription get_Body();
    internal void set_Body(MessageBodyDescription value);
    internal MessageHeaderDescriptionCollection get_Headers();
    internal MessagePropertyDescriptionCollection get_Properties();
}
public enum System.ServiceModel.Description.MessageDirection : Enum {
    public int value__;
    public static MessageDirection Input;
    public static MessageDirection Output;
}
internal static class System.ServiceModel.Description.MessageDirectionHelper : object {
    internal static bool IsDefined(MessageDirection value);
    internal static MessageDirection Opposite(MessageDirection d);
}
public class System.ServiceModel.Description.MessageHeaderDescription : MessagePartDescription {
    private bool _mustUnderstand;
    private bool _relay;
    private string _actor;
    private bool _typedHeader;
    private bool _isUnknownHeader;
    [DefaultValueAttribute("")]
public string Actor { get; public set; }
    [DefaultValueAttribute("False")]
public bool MustUnderstand { get; public set; }
    [DefaultValueAttribute("False")]
public bool Relay { get; public set; }
    [DefaultValueAttribute("False")]
public bool TypedHeader { get; public set; }
    internal bool IsUnknownHeaderCollection { get; internal set; }
    public MessageHeaderDescription(string name, string ns);
    internal MessageHeaderDescription(MessageHeaderDescription other);
    internal virtual MessagePartDescription Clone();
    public string get_Actor();
    public void set_Actor(string value);
    public bool get_MustUnderstand();
    public void set_MustUnderstand(bool value);
    public bool get_Relay();
    public void set_Relay(bool value);
    public bool get_TypedHeader();
    public void set_TypedHeader(bool value);
    internal bool get_IsUnknownHeaderCollection();
    internal void set_IsUnknownHeaderCollection(bool value);
}
public class System.ServiceModel.Description.MessageHeaderDescriptionCollection : KeyedCollection`2<XmlQualifiedName, MessageHeaderDescription> {
    protected virtual XmlQualifiedName GetKeyForItem(MessageHeaderDescription item);
}
[DebuggerDisplayAttribute("Name={_name}, Namespace={_ns}, Type={Type}, Index={_index}}")]
public class System.ServiceModel.Description.MessagePartDescription : object {
    private XmlName _name;
    private string _ns;
    private int _index;
    private Type _type;
    private int _serializationPosition;
    private ProtectionLevel _protectionLevel;
    private bool _hasProtectionLevel;
    private MemberInfo _memberInfo;
    private CustomAttributeProvider _additionalAttributesProvider;
    private bool _multiple;
    private string _baseType;
    private string _uniquePartName;
    internal string BaseType { get; internal set; }
    internal XmlName XmlName { get; }
    internal string CodeName { get; }
    public string Name { get; }
    public string Namespace { get; }
    public Type Type { get; public set; }
    public int Index { get; public set; }
    [DefaultValueAttribute("False")]
public bool Multiple { get; public set; }
    public ProtectionLevel ProtectionLevel { get; public set; }
    public bool HasProtectionLevel { get; }
    public MemberInfo MemberInfo { get; public set; }
    internal CustomAttributeProvider AdditionalAttributesProvider { get; internal set; }
    internal string UniquePartName { get; internal set; }
    internal int SerializationPosition { get; internal set; }
    public MessagePartDescription(string name, string ns);
    internal MessagePartDescription(MessagePartDescription other);
    internal virtual MessagePartDescription Clone();
    internal string get_BaseType();
    internal void set_BaseType(string value);
    internal XmlName get_XmlName();
    internal string get_CodeName();
    public string get_Name();
    public string get_Namespace();
    public Type get_Type();
    public void set_Type(Type value);
    public int get_Index();
    public void set_Index(int value);
    public bool get_Multiple();
    public void set_Multiple(bool value);
    public ProtectionLevel get_ProtectionLevel();
    public void set_ProtectionLevel(ProtectionLevel value);
    public bool get_HasProtectionLevel();
    public MemberInfo get_MemberInfo();
    public void set_MemberInfo(MemberInfo value);
    internal CustomAttributeProvider get_AdditionalAttributesProvider();
    internal void set_AdditionalAttributesProvider(CustomAttributeProvider value);
    internal string get_UniquePartName();
    internal void set_UniquePartName(string value);
    internal int get_SerializationPosition();
    internal void set_SerializationPosition(int value);
    internal void ResetProtectionLevel();
}
public class System.ServiceModel.Description.MessagePartDescriptionCollection : KeyedCollection`2<XmlQualifiedName, MessagePartDescription> {
    protected virtual XmlQualifiedName GetKeyForItem(MessagePartDescription item);
}
public class System.ServiceModel.Description.MessagePropertyDescription : MessagePartDescription {
    public MessagePropertyDescription(string name);
    internal MessagePropertyDescription(MessagePropertyDescription other);
    internal virtual MessagePartDescription Clone();
}
public class System.ServiceModel.Description.MessagePropertyDescriptionCollection : KeyedCollection`2<string, MessagePropertyDescription> {
    protected virtual string GetKeyForItem(MessagePropertyDescription item);
}
public class System.ServiceModel.Description.MetadataConversionError : object {
    private string _message;
    private bool _isWarning;
    public string Message { get; }
    public bool IsWarning { get; }
    public MetadataConversionError(string message);
    public MetadataConversionError(string message, bool isWarning);
    public string get_Message();
    public bool get_IsWarning();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[XmlRootAttribute]
public class System.ServiceModel.Description.MetadataLocation : object {
    private string _location;
    [XmlTextAttribute]
public string Location { get; public set; }
    public MetadataLocation(string location);
    public string get_Location();
    public void set_Location(string value);
}
internal static class System.ServiceModel.Description.MetadataStrings : object {
}
internal static class System.ServiceModel.Description.NamingHelper : object {
    internal static string DefaultNamespace;
    internal static string DefaultServiceName;
    internal static string MSNamespace;
    internal static string CombineUriStrings(string baseUri, string path);
    internal static string TypeName(Type t);
    internal static XmlQualifiedName GetContractName(Type contractType, string name, string ns);
    internal static XmlName GetOperationName(string logicalMethodName, string name);
    internal static string GetMessageAction(OperationDescription operation, bool isResponse);
    internal static string GetMessageAction(XmlQualifiedName contractName, string opname, string action, bool isResponse);
    internal static string GetUniqueName(string baseName, DoesNameExist doesNameExist, object nameCollection);
    internal static void CheckUriProperty(string ns, string propName);
    internal static void CheckUriParameter(string ns, string paramName);
    internal static string XmlName(string name);
    internal static string CodeName(string name);
    private static bool IsAlpha(char ch);
    private static bool IsDigit(char ch);
    private static bool IsAsciiLocalName(string localName);
    internal static bool IsValidNCName(string name);
}
[DebuggerDisplayAttribute("Name={_name}, IsInitiating={_isInitiating}, IsTerminating={_isTerminating}")]
public class System.ServiceModel.Description.OperationDescription : object {
    internal static string SessionOpenedAction;
    private XmlName _name;
    private bool _isInitiating;
    private bool _isTerminating;
    private bool _isSessionOpenNotificationEnabled;
    private ContractDescription _declaringContract;
    private FaultDescriptionCollection _faults;
    private MessageDescriptionCollection _messages;
    private KeyedByTypeCollection`1<IOperationBehavior> _behaviors;
    private Collection`1<Type> _knownTypes;
    private MethodInfo _beginMethod;
    private MethodInfo _endMethod;
    private MethodInfo _syncMethod;
    private MethodInfo _taskMethod;
    private bool _validateRpcWrapperName;
    private bool _hasNoDisposableParameters;
    [CompilerGeneratedAttribute]
private Type <TaskTResult>k__BackingField;
    public KeyedCollection`2<Type, IOperationBehavior> OperationBehaviors { get; }
    [EditorBrowsableAttribute("1")]
public KeyedByTypeCollection`1<IOperationBehavior> Behaviors { get; }
    public MethodInfo TaskMethod { get; public set; }
    public MethodInfo SyncMethod { get; public set; }
    public MethodInfo BeginMethod { get; public set; }
    internal MethodInfo OperationMethod { get; }
    internal bool HasNoDisposableParameters { get; internal set; }
    public MethodInfo EndMethod { get; public set; }
    public ContractDescription DeclaringContract { get; public set; }
    public FaultDescriptionCollection Faults { get; }
    public bool IsOneWay { get; }
    public bool IsInitiating { get; public set; }
    public bool IsTerminating { get; public set; }
    public Collection`1<Type> KnownTypes { get; }
    public MessageDescriptionCollection Messages { get; }
    internal XmlName XmlName { get; }
    internal string CodeName { get; }
    public string Name { get; }
    internal bool IsValidateRpcWrapperName { get; }
    internal Type TaskTResult { get; internal set; }
    internal bool HasOutputParameters { get; }
    internal bool IsSessionOpenNotificationEnabled { get; internal set; }
    public OperationDescription(string name, ContractDescription declaringContract);
    internal OperationDescription(string name, ContractDescription declaringContract, bool validateRpcWrapperName);
    public KeyedCollection`2<Type, IOperationBehavior> get_OperationBehaviors();
    public KeyedByTypeCollection`1<IOperationBehavior> get_Behaviors();
    public MethodInfo get_TaskMethod();
    public void set_TaskMethod(MethodInfo value);
    public MethodInfo get_SyncMethod();
    public void set_SyncMethod(MethodInfo value);
    public MethodInfo get_BeginMethod();
    public void set_BeginMethod(MethodInfo value);
    internal MethodInfo get_OperationMethod();
    internal bool get_HasNoDisposableParameters();
    internal void set_HasNoDisposableParameters(bool value);
    public MethodInfo get_EndMethod();
    public void set_EndMethod(MethodInfo value);
    public ContractDescription get_DeclaringContract();
    public void set_DeclaringContract(ContractDescription value);
    public FaultDescriptionCollection get_Faults();
    public bool get_IsOneWay();
    public bool get_IsInitiating();
    public void set_IsInitiating(bool value);
    internal bool IsServerInitiated();
    public bool get_IsTerminating();
    public void set_IsTerminating(bool value);
    public Collection`1<Type> get_KnownTypes();
    public MessageDescriptionCollection get_Messages();
    internal XmlName get_XmlName();
    internal string get_CodeName();
    public string get_Name();
    internal bool get_IsValidateRpcWrapperName();
    [CompilerGeneratedAttribute]
internal Type get_TaskTResult();
    [CompilerGeneratedAttribute]
internal void set_TaskTResult(Type value);
    internal bool get_HasOutputParameters();
    internal bool get_IsSessionOpenNotificationEnabled();
    internal void set_IsSessionOpenNotificationEnabled(bool value);
    internal void EnsureInvariants();
}
public class System.ServiceModel.Description.OperationDescriptionCollection : Collection`1<OperationDescription> {
    public OperationDescription Find(string name);
    public Collection`1<OperationDescription> FindAll(string name);
    protected virtual void InsertItem(int index, OperationDescription item);
    protected virtual void SetItem(int index, OperationDescription item);
}
public class System.ServiceModel.Description.PolicyVersion : object {
    private string _policyNamespace;
    private static PolicyVersion s_policyVersion12;
    private static PolicyVersion s_policyVersion15;
    public static PolicyVersion Policy12 { get; }
    public static PolicyVersion Policy15 { get; }
    public static PolicyVersion Default { get; }
    public string Namespace { get; }
    private static PolicyVersion();
    private PolicyVersion(string policyNamespace);
    public static PolicyVersion get_Policy12();
    public static PolicyVersion get_Policy15();
    public static PolicyVersion get_Default();
    public string get_Namespace();
    public virtual string ToString();
}
public enum System.ServiceModel.Description.PrincipalPermissionMode : Enum {
    public int value__;
    public static PrincipalPermissionMode None;
    public static PrincipalPermissionMode UseWindowsGroups;
    public static PrincipalPermissionMode UseAspNetRoles;
    public static PrincipalPermissionMode Custom;
    public static PrincipalPermissionMode Always;
}
internal static class System.ServiceModel.Description.PrincipalPermissionModeHelper : object {
    public static bool IsDefined(PrincipalPermissionMode principalPermissionMode);
}
[DebuggerDisplayAttribute("Address={_address}")]
[DebuggerDisplayAttribute("Name={_name}")]
public class System.ServiceModel.Description.ServiceEndpoint : object {
    private EndpointAddress _address;
    private Binding _binding;
    private ContractDescription _contract;
    private Uri _listenUri;
    private ListenUriMode _listenUriMode;
    private KeyedByTypeCollection`1<IEndpointBehavior> _behaviors;
    private string _id;
    private XmlName _name;
    private bool _isEndpointFullyConfigured;
    [CompilerGeneratedAttribute]
private bool <IsSystemEndpoint>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <UnresolvedAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <UnresolvedListenUri>k__BackingField;
    public EndpointAddress Address { get; public set; }
    public KeyedCollection`2<Type, IEndpointBehavior> EndpointBehaviors { get; }
    [EditorBrowsableAttribute("1")]
public KeyedByTypeCollection`1<IEndpointBehavior> Behaviors { get; }
    public Binding Binding { get; public set; }
    public ContractDescription Contract { get; public set; }
    public bool IsSystemEndpoint { get; public set; }
    public string Name { get; public set; }
    public Uri ListenUri { get; public set; }
    public ListenUriMode ListenUriMode { get; public set; }
    internal string Id { get; }
    internal Uri UnresolvedAddress { get; internal set; }
    internal Uri UnresolvedListenUri { get; internal set; }
    internal bool IsFullyConfigured { get; internal set; }
    public ServiceEndpoint(ContractDescription contract);
    public ServiceEndpoint(ContractDescription contract, Binding binding, EndpointAddress address);
    public EndpointAddress get_Address();
    public void set_Address(EndpointAddress value);
    public KeyedCollection`2<Type, IEndpointBehavior> get_EndpointBehaviors();
    public KeyedByTypeCollection`1<IEndpointBehavior> get_Behaviors();
    public Binding get_Binding();
    public void set_Binding(Binding value);
    public ContractDescription get_Contract();
    public void set_Contract(ContractDescription value);
    [CompilerGeneratedAttribute]
public bool get_IsSystemEndpoint();
    [CompilerGeneratedAttribute]
public void set_IsSystemEndpoint(bool value);
    public string get_Name();
    public void set_Name(string value);
    public Uri get_ListenUri();
    public void set_ListenUri(Uri value);
    public ListenUriMode get_ListenUriMode();
    public void set_ListenUriMode(ListenUriMode value);
    internal string get_Id();
    [CompilerGeneratedAttribute]
internal Uri get_UnresolvedAddress();
    [CompilerGeneratedAttribute]
internal void set_UnresolvedAddress(Uri value);
    [CompilerGeneratedAttribute]
internal Uri get_UnresolvedListenUri();
    [CompilerGeneratedAttribute]
internal void set_UnresolvedListenUri(Uri value);
    internal void EnsureInvariants();
    internal void ValidateForClient();
    internal void ValidateForService(bool runOperationValidators);
    internal bool get_IsFullyConfigured();
    internal void set_IsFullyConfigured(bool value);
    private void Validate(bool runOperationValidators, bool isForService);
}
public class System.ServiceModel.Description.ServiceEndpointCollection : Collection`1<ServiceEndpoint> {
    public ServiceEndpoint Find(Type contractType);
    public ServiceEndpoint Find(XmlQualifiedName contractName);
    public ServiceEndpoint Find(Type contractType, XmlQualifiedName bindingName);
    public ServiceEndpoint Find(XmlQualifiedName contractName, XmlQualifiedName bindingName);
    public ServiceEndpoint Find(Uri address);
    public Collection`1<ServiceEndpoint> FindAll(Type contractType);
    public Collection`1<ServiceEndpoint> FindAll(XmlQualifiedName contractName);
    protected virtual void InsertItem(int index, ServiceEndpoint item);
    protected virtual void SetItem(int index, ServiceEndpoint item);
}
internal static class System.ServiceModel.Description.ServiceReflector : object {
    internal static string BeginMethodNamePrefix;
    internal static string EndMethodNamePrefix;
    internal static Type VoidType;
    internal static string AsyncMethodNameSuffix;
    internal static Type taskType;
    internal static Type taskTResultType;
    internal static Type CancellationTokenType;
    internal static Type IProgressType;
    private static Type s_asyncCallbackType;
    private static Type s_asyncResultType;
    private static Type s_objectType;
    private static Type s_OperationContractAttributeType;
    private static ServiceReflector();
    internal static Type GetOperationContractProviderType(MethodInfo method);
    internal static List`1<Type> GetInterfaces(Type service);
    private static Type GetAncestorImplicitContractClass(Type service);
    internal static List`1<Type> GetInheritedContractTypes(Type service);
    internal static Object[] GetCustomAttributes(CustomAttributeProvider attrProvider, Type attrType);
    internal static Object[] GetCustomAttributes(CustomAttributeProvider attrProvider, Type attrType, bool inherit);
    internal static T GetFirstAttribute(CustomAttributeProvider attrProvider);
    internal static T GetSingleAttribute(CustomAttributeProvider attrProvider);
    internal static T GetRequiredSingleAttribute(CustomAttributeProvider attrProvider);
    internal static T GetSingleAttribute(CustomAttributeProvider attrProvider, Type[] attrTypeGroup);
    internal static T GetRequiredSingleAttribute(CustomAttributeProvider attrProvider, Type[] attrTypeGroup);
    internal static Type GetContractType(Type interfaceType);
    internal static Type GetContractTypeAndAttribute(Type interfaceType, ServiceContractAttribute& contractAttribute);
    private static List`1<MethodInfo> GetMethodsInternal(Type interfaceType);
    internal static void ValidateParameterMetadata(MethodInfo methodInfo);
    internal static bool FlowsIn(ParameterInfo paramInfo);
    internal static bool FlowsOut(ParameterInfo paramInfo);
    internal static ParameterInfo[] GetInputParameters(MethodInfo method, bool asyncPattern);
    internal static ParameterInfo[] GetOutputParameters(MethodInfo method, bool asyncPattern);
    internal static bool HasOutputParameters(MethodInfo method, bool asyncPattern);
    private static MethodInfo GetEndMethodInternal(MethodInfo beginMethod);
    internal static MethodInfo GetEndMethod(MethodInfo beginMethod);
    internal static XmlName GetOperationName(MethodInfo method);
    internal static bool HasBeginMethodShape(MethodInfo method);
    internal static bool IsBegin(OperationContractAttribute opSettings, MethodInfo method);
    internal static bool IsTask(MethodInfo method);
    internal static bool IsTask(MethodInfo method, Type& taskTResult);
    internal static bool HasEndMethodShape(MethodInfo method);
    internal static OperationContractAttribute GetOperationContractAttribute(MethodInfo method);
    internal static bool IsBegin(MethodInfo method);
    internal static string GetLogicalName(MethodInfo method);
    internal static string GetLogicalName(MethodInfo method, bool isAsync, bool isTask);
    internal static bool HasNoDisposableParameters(MethodInfo methodInfo);
    internal static bool IsParameterDisposable(Type type);
}
internal class System.ServiceModel.Description.TypeLoader : object {
    private static Type[] s_messageContractMemberAttributes;
    private static Type[] s_formatterAttributes;
    private static Type[] s_knownTypesMethodParamType;
    internal static DataContractFormatAttribute DefaultDataContractFormatAttribute;
    internal static XmlSerializerFormatAttribute DefaultXmlSerializerFormatAttribute;
    private static Type s_OperationContractAttributeType;
    internal static string ReturnSuffix;
    internal static string ResponseSuffix;
    internal static string FaultSuffix;
    internal static BindingFlags DefaultBindingFlags;
    private object _thisLock;
    private Dictionary`2<Type, ContractDescription> _contracts;
    private Dictionary`2<Type, MessageDescriptionItems> _messages;
    private static TypeLoader();
    private ContractDescription LoadContractDescriptionHelper(Type contractType, Type serviceType, object serviceImplementation);
    private void EnsureNoInheritanceWithContractClasses(Type actualContractType);
    private void EnsureNoOperationContractsOnNonServiceContractTypes(Type actualContractType);
    private void EnsureNoOperationContractsOnNonServiceContractTypes_Helper(Type aParentType);
    public ContractDescription LoadContractDescription(Type contractType);
    public ContractDescription LoadContractDescription(Type contractType, Type serviceType);
    public ContractDescription LoadContractDescription(Type contractType, Type serviceType, object serviceImplementation);
    private ContractDescription LoadOutputChannelContractDescription();
    private ContractDescription LoadRequestChannelContractDescription();
    private void AddBehaviors(ContractDescription contractDesc, Type implType, bool implIsCallback, ContractReflectionInfo reflectionInfo);
    private void GetIContractBehaviorsFromInterfaceType(Type interfaceType, KeyedByTypeCollection`1<IContractBehavior> behaviors);
    private static void UpdateContractDescriptionWithAttributesFromServiceType(ContractDescription description, Type serviceType);
    private void UpdateOperationsWithInterfaceAttributes(ContractDescription contractDesc, ContractReflectionInfo reflectionInfo);
    private IEnumerable`1<Type> GetKnownTypes(Object[] knownTypeAttributes, CustomAttributeProvider provider);
    private KeyedByTypeCollection`1<IOperationBehavior> GetIOperationBehaviorAttributesFromType(OperationDescription opDesc, Type targetIface, Type implType);
    private void ProcessOpMethod(MethodInfo opMethod, bool canHaveBehaviors, OperationDescription opDesc, KeyedByTypeCollection`1<IOperationBehavior> result, Type ifaceType, Type implType, bool useImplAttrs);
    private static MethodInfo GetCorrespondingMethodFromType(Type type, MethodInfo methodInfo);
    private static bool MethodsMatch(MethodInfo method1, MethodInfo method2);
    private static bool ParameterInfosMatch(ParameterInfo parameterInfo1, ParameterInfo parameterInfo2);
    internal void AddBehaviorsSFx(ServiceEndpoint serviceEndpoint, Type contractType);
    internal void AddBehaviorsFromImplementationType(ServiceEndpoint serviceEndpoint, Type implementationType);
    internal static int CompareMessagePartDescriptions(MessagePartDescription a, MessagePartDescription b);
    internal static XmlName GetBodyWrapperResponseName(string operationName);
    internal static XmlName GetBodyWrapperResponseName(XmlName operationName);
    private void CreateOperationDescriptions(ContractDescription contractDescription, ContractReflectionInfo reflectionInfo, Type contractToGetMethodsFrom, ContractDescription declaringContract, MessageDirection direction);
    internal static void EnsureCallbackType(Type callbackType);
    internal static void EnsureSubcontract(ServiceContractAttribute svcContractAttr, Type contractType);
    private ContractDescription CreateContractDescription(ServiceContractAttribute contractAttr, Type contractType, Type serviceType, ContractReflectionInfo& reflectionInfo, object serviceImplementation);
    internal static Attribute GetFormattingAttribute(CustomAttributeProvider attrProvider, Attribute defaultFormatAttribute);
    private void VerifyConsistency(OperationConsistencyVerifier verifier);
    private OperationDescription CreateOperationDescription(ContractDescription contractDescription, MethodInfo methodInfo, MessageDirection direction, ContractReflectionInfo reflectionInfo, ContractDescription declaringContract);
    private void CheckDuplicateFaultContract(FaultDescriptionCollection faultDescriptionCollection, FaultDescription fault, string operationName);
    private FaultDescription CreateFaultDescription(FaultContractAttribute attr, XmlQualifiedName contractName, string contractNamespace, XmlName operationName);
    private MessageDescription CreateMessageDescription(MethodInfo methodInfo, bool isAsync, bool isTask, Type taskTResult, XmlName returnValueName, string defaultNS, string action, XmlName wrapperName, string wrapperNamespace, MessageDirection direction);
    private MessageDescription CreateParameterMessageDescription(ParameterInfo[] parameters, Type returnType, CustomAttributeProvider returnAttrProvider, XmlName returnValueName, string methodName, string defaultNS, string action, XmlName wrapperName, string wrapperNamespace, MessageDirection direction);
    private static MessagePartDescription CreateParameterPartDescription(XmlName defaultName, string defaultNS, int index, CustomAttributeProvider attrProvider, Type type);
    internal MessageDescription CreateTypedMessageDescription(Type typedMessageType, CustomAttributeProvider returnAttrProvider, XmlName returnValueName, string defaultNS, string action, MessageDirection direction);
    private static bool IsMethodOverriding(MethodInfo method);
    private MessagePartDescription CreateMessagePartDescription(Type bodyType, CustomAttributeProvider attrProvider, XmlName defaultName, string defaultNS, int parameterIndex, int serializationIndex);
    private MessageHeaderDescription CreateMessageHeaderDescription(Type headerParameterType, CustomAttributeProvider attrProvider, XmlName defaultName, string defaultNS, int parameterIndex, int serializationPosition);
    private MessagePropertyDescription CreateMessagePropertyDescription(CustomAttributeProvider attrProvider, XmlName defaultName, int parameterIndex);
    internal static XmlName GetReturnValueName(XmlName methodName);
    internal static XmlName GetReturnValueName(string methodName);
    internal static Type GetParameterType(ParameterInfo parameterInfo);
    internal static XmlName GetWrapperName(string wrapperName, XmlName defaultName);
    private void AddSortedParts(List`1<T> partDescriptionList, KeyedCollection`2<XmlQualifiedName, T> partDescriptionCollection);
    public static void ApplyServiceInheritance(Type serviceType, TBehaviorCollection descriptionBehaviors, ServiceInheritanceCallback`2<IBehavior, TBehaviorCollection> callback);
    private static void AddBehaviorsAtOneScope(Type type, TBehaviorCollection descriptionBehaviors, ServiceInheritanceCallback`2<IBehavior, TBehaviorCollection> callback);
}
internal class System.ServiceModel.Description.XmlName : object {
    private string _decoded;
    private string _encoded;
    internal string EncodedName { get; }
    internal string DecodedName { get; }
    private bool IsEmpty { get; }
    internal XmlName(string name);
    internal XmlName(string name, bool isEncoded);
    internal string get_EncodedName();
    internal string get_DecodedName();
    private static void ValidateEncodedName(string name, bool allowNull);
    private bool get_IsEmpty();
    internal static bool IsNullOrEmpty(XmlName xmlName);
    private bool Matches(XmlName xmlName);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static bool op_Equality(XmlName a, XmlName b);
    public static bool op_Inequality(XmlName a, XmlName b);
}
internal static class System.ServiceModel.Description.XmlSerializerHelper : object {
    internal static XmlReflectionMember GetXmlReflectionMember(MessagePartDescription part, bool isRpc, bool isEncoded, bool isWrapped);
    internal static XmlReflectionMember GetXmlReflectionMember(XmlName memberName, XmlName elementName, string ns, Type type, ICustomAttributeProvider additionalAttributesProvider, bool isMultiple, bool isEncoded, bool isWrapped);
    private static bool HasNoXmlParameterAttributes(XmlAttributes xmlAttributes);
    public static XmlSerializer[] FromMappings(XmlMapping[] mappings, Type type);
    private static XmlSerializer[] FromMappingsViaReflection(XmlMapping[] mappings, Type type);
}
public class System.ServiceModel.Description.XmlSerializerOperationBehavior : object {
    private OperationReflector _reflector;
    private bool _builtInOperationBehavior;
    internal OperationReflector OperationReflector { get; }
    internal bool IsBuiltInOperationBehavior { get; }
    public XmlSerializerFormatAttribute XmlSerializerFormatAttribute { get; }
    public XmlSerializerOperationBehavior(OperationDescription operation);
    public XmlSerializerOperationBehavior(OperationDescription operation, XmlSerializerFormatAttribute attribute);
    internal XmlSerializerOperationBehavior(OperationDescription operation, XmlSerializerFormatAttribute attribute, Reflector parentReflector);
    private XmlSerializerOperationBehavior(OperationReflector reflector, bool builtInOperationBehavior);
    internal OperationReflector get_OperationReflector();
    internal bool get_IsBuiltInOperationBehavior();
    public XmlSerializerFormatAttribute get_XmlSerializerFormatAttribute();
    internal static XmlSerializerOperationFormatter CreateOperationFormatter(OperationDescription operation);
    internal static XmlSerializerOperationFormatter CreateOperationFormatter(OperationDescription operation, XmlSerializerFormatAttribute attr);
    internal static void AddBehaviors(ContractDescription contract);
    internal static void AddBuiltInBehaviors(ContractDescription contract);
    private static void AddBehaviors(ContractDescription contract, bool builtInOperationBehavior);
    internal XmlSerializerOperationFormatter CreateFormatter();
    private XmlSerializerFaultFormatter CreateFaultFormatter(SynchronizedCollection`1<FaultContractInfo> faultContractInfos);
    private sealed virtual override void System.ServiceModel.Description.IOperationBehavior.Validate(OperationDescription description);
    private sealed virtual override void System.ServiceModel.Description.IOperationBehavior.AddBindingParameters(OperationDescription description, BindingParameterCollection parameters);
    private sealed virtual override void System.ServiceModel.Description.IOperationBehavior.ApplyDispatchBehavior(OperationDescription description, DispatchOperation dispatch);
    private sealed virtual override void System.ServiceModel.Description.IOperationBehavior.ApplyClientBehavior(OperationDescription description, ClientOperation proxy);
    public Collection`1<XmlMapping> GetXmlMappings();
}
internal class System.ServiceModel.Diagnostics.Activity : object {
    protected Guid parentId;
    private Guid _currentId;
    private bool _mustDispose;
    protected Guid Id { get; }
    protected Activity(Guid activityId, Guid parentId);
    internal static Activity CreateActivity(Guid activityId);
    public virtual void Dispose();
    protected Guid get_Id();
}
internal class System.ServiceModel.Diagnostics.ActivityIdHeader : DictionaryHeader {
    private Guid _guid;
    private Guid _headerId;
    public XmlDictionaryString DictionaryName { get; }
    public XmlDictionaryString DictionaryNamespace { get; }
    internal ActivityIdHeader(Guid activityId);
    public virtual XmlDictionaryString get_DictionaryName();
    public virtual XmlDictionaryString get_DictionaryNamespace();
    internal static Guid ExtractActivityId(Message message);
    internal static bool ExtractActivityAndCorrelationId(Message message, Guid& activityId, Guid& correlationId);
    internal void AddTo(Message message);
    protected virtual void OnWriteHeaderContents(XmlDictionaryWriter writer, MessageVersion messageVersion);
}
internal enum System.ServiceModel.Diagnostics.ActivityType : Enum {
    public int value__;
    public static ActivityType Unknown;
    public static ActivityType Close;
    public static ActivityType Construct;
    public static ActivityType ExecuteUserCode;
    public static ActivityType ListenAt;
    public static ActivityType Open;
    public static ActivityType OpenClient;
    public static ActivityType ProcessMessage;
    public static ActivityType ProcessAction;
    public static ActivityType ReceiveBytes;
    public static ActivityType SecuritySetup;
    public static ActivityType TransferToComPlus;
    public static ActivityType WmiGetObject;
    public static ActivityType WmiPutInstance;
    public static ActivityType NumItems;
}
internal static class System.ServiceModel.Diagnostics.DiagnosticStrings : object {
    internal static string DiagnosticsNamespace;
    internal static string ActivityIdName;
    internal static string ActivityId;
    internal static string AppDomain;
    internal static string DataTag;
    internal static string DataItemsTag;
    internal static string DeflateCookieAfterDeflatingTag;
    internal static string DeflateCookieOriginalSizeTag;
    internal static string DescriptionTag;
    internal static string EventLogTag;
    internal static string ExceptionTag;
    internal static string ExceptionTypeTag;
    internal static string ExceptionStringTag;
    internal static string ExtendedDataTag;
    internal static string HeaderTag;
    internal static string InnerExceptionTag;
    internal static string KeyTag;
    internal static string MessageTag;
    internal static string NameTag;
    internal static string NamespaceTag;
    internal static string NativeErrorCodeTag;
    internal static string ProcessId;
    internal static string ProcessName;
    internal static string RoleTag;
    internal static string SeverityTag;
    internal static string SourceTag;
    internal static string StackTraceTag;
    internal static string TraceCodeTag;
    internal static string TraceRecordTag;
    internal static string ValueTag;
    internal static String[][] HeadersPaths;
    internal static String[] PiiList;
    private static DiagnosticStrings();
}
internal static class System.ServiceModel.Diagnostics.EventTraceActivityHelper : object {
    public static bool TryAttachActivity(Message message, EventTraceActivity activity);
    public static EventTraceActivity TryExtractActivity(Message message);
    public static EventTraceActivity TryExtractActivity(Message message, bool createIfNotExist);
    [SecurityCriticalAttribute]
internal static void SetOnThread(EventTraceActivity eventTraceActivity);
    private static bool GetMessageId(Message message, Guid& guid);
}
public class System.ServiceModel.Diagnostics.ExceptionUtility : object {
    private static string ExceptionStackAsStringKey;
    internal static ExceptionUtility mainInstance;
    private ExceptionTrace _exceptionTrace;
    private string _name;
    private string _eventSourceName;
    [ThreadStaticAttribute]
private static Guid s_activityId;
    [ObsoleteAttribute("For SMDiagnostics.dll use only. Call DiagnosticUtility.ExceptionUtility instead")]
internal ExceptionUtility(string name, string eventSourceName, object exceptionTrace);
    public ArgumentException ThrowHelperArgument(string message);
    public ArgumentException ThrowHelperArgument(string paramName, string message);
    public ArgumentNullException ThrowHelperArgumentNull(string paramName);
    public ArgumentNullException ThrowHelperArgumentNull(string paramName, string message);
    public ArgumentException ThrowHelperArgumentNullOrEmptyString(string arg);
    public Exception ThrowHelperFatal(string message, Exception innerException);
    public Exception ThrowHelperInternal(bool fatal);
    public Exception ThrowHelperInvalidOperation(string message);
    public Exception ThrowHelperCallback(string message, Exception innerException);
    public Exception ThrowHelperCallback(Exception innerException);
    public Exception ThrowHelperCritical(Exception exception);
    public Exception ThrowHelperError(Exception exception);
    public Exception ThrowHelperWarning(Exception exception);
    internal Exception ThrowHelper(Exception exception, EventLevel eventLevel);
    internal Exception ThrowHelperXml(XmlReader reader, string message);
    internal Exception ThrowHelperXml(XmlReader reader, string message, Exception inner);
    internal static void UseActivityId(Guid activityId);
    internal static void ClearActivityId();
}
internal static class System.ServiceModel.Diagnostics.MessageLogger : object {
    [CompilerGeneratedAttribute]
private static bool <ShouldLogMalformed>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <LogMessagesAtTransportLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <LogMessagesAtServiceLevel>k__BackingField;
    public static bool LoggingEnabled { get; }
    public static bool ShouldLogMalformed { get; public set; }
    public static bool LogMessagesAtTransportLevel { get; public set; }
    public static bool LogMessagesAtServiceLevel { get; public set; }
    public static bool get_LoggingEnabled();
    internal static void LogMessage(Message& message, int arg1);
    [CompilerGeneratedAttribute]
public static bool get_ShouldLogMalformed();
    [CompilerGeneratedAttribute]
public static void set_ShouldLogMalformed(bool value);
    internal static void LogMessage(Stream stream, MessageLoggingSource messageLoggingSource);
    [CompilerGeneratedAttribute]
public static bool get_LogMessagesAtTransportLevel();
    [CompilerGeneratedAttribute]
public static void set_LogMessagesAtTransportLevel(bool value);
    internal static void LogMessage(Message& message, MessageLoggingSource messageLoggingSource);
    [CompilerGeneratedAttribute]
public static bool get_LogMessagesAtServiceLevel();
    [CompilerGeneratedAttribute]
public static void set_LogMessagesAtServiceLevel(bool value);
    internal static void LogMessage(ArraySegment`1<byte> arraySegment, MessageLoggingSource messageLoggingSource);
    internal static void LogMessage(Message& message, XmlDictionaryReader xmlDictionaryReader, MessageLoggingSource messageLoggingSource);
}
[FlagsAttribute]
internal enum System.ServiceModel.Diagnostics.MessageLoggingSource : Enum {
    public int value__;
    public static MessageLoggingSource None;
    public static MessageLoggingSource TransportReceive;
    public static MessageLoggingSource TransportSend;
    public static MessageLoggingSource Transport;
    public static MessageLoggingSource ServiceLevelReceiveDatagram;
    public static MessageLoggingSource ServiceLevelSendDatagram;
    public static MessageLoggingSource ServiceLevelReceiveRequest;
    public static MessageLoggingSource ServiceLevelSendRequest;
    public static MessageLoggingSource ServiceLevelReceiveReply;
    public static MessageLoggingSource ServiceLevelSendReply;
    public static MessageLoggingSource ServiceLevelReceive;
    public static MessageLoggingSource ServiceLevelSend;
    public static MessageLoggingSource ServiceLevelService;
    public static MessageLoggingSource ServiceLevelProxy;
    public static MessageLoggingSource ServiceLevel;
    public static MessageLoggingSource Malformed;
    public static MessageLoggingSource LastChance;
    public static MessageLoggingSource All;
}
internal class System.ServiceModel.Diagnostics.MessageTraceRecord : TraceRecord {
}
internal class System.ServiceModel.Diagnostics.MessageTransmitTraceRecord : MessageTraceRecord {
}
internal class System.ServiceModel.Diagnostics.SecurityTraceRecord : TraceRecord {
    private string _traceName;
    internal string EventId { get; }
    internal SecurityTraceRecord(string traceName);
    internal virtual string get_EventId();
}
internal static class System.ServiceModel.Diagnostics.SecurityTraceRecordHelper : object {
    internal static void TraceIdentityVerificationSuccess(EventTraceActivity eventTraceActivity, EndpointIdentity identity, Claim claim, Type identityVerifier);
    internal static void TraceIdentityVerificationFailure(EndpointIdentity identity, AuthorizationContext authContext, Type identityVerifier);
    internal static void TraceIdentityDeterminationSuccess(EndpointAddress epr, EndpointIdentity identity, Type identityVerifier);
    internal static void TraceIdentityDeterminationFailure(EndpointAddress epr, Type identityVerifier);
    internal static void TraceSpnToSidMappingFailure(string spn, Exception e);
}
internal class System.ServiceModel.Diagnostics.ServiceModelActivity : object {
    [ThreadStaticAttribute]
private static ServiceModelActivity s_currentActivity;
    private static String[] s_ActivityTypeNames;
    private ServiceModelActivity _previousActivity;
    private static string s_activityBoundaryDescription;
    private ActivityState _lastState;
    private string _name;
    private bool _autoStop;
    private bool _autoResume;
    private Guid _activityId;
    private bool _disposed;
    private bool _isAsync;
    private int _stopCount;
    private static int AsyncStopCount;
    private TransferActivity _activity;
    private ActivityType _activityType;
    private static string ActivityBoundaryDescription { get; }
    internal ActivityType ActivityType { get; }
    internal ServiceModelActivity PreviousActivity { get; }
    internal static ServiceModelActivity Current { get; private set; }
    internal Guid Id { get; }
    private ActivityState LastState { get; private set; }
    internal string Name { get; internal set; }
    private static ServiceModelActivity();
    private ServiceModelActivity(Guid activityId);
    private static string get_ActivityBoundaryDescription();
    internal ActivityType get_ActivityType();
    internal ServiceModelActivity get_PreviousActivity();
    internal static Activity BoundOperation(ServiceModelActivity activity);
    internal static Activity BoundOperation(ServiceModelActivity activity, bool addTransfer);
    private static Activity BoundOperationCore(ServiceModelActivity activity, bool addTransfer);
    internal static ServiceModelActivity CreateActivity();
    internal static ServiceModelActivity CreateActivity(bool autoStop);
    internal static ServiceModelActivity CreateActivity(bool autoStop, string activityName, ActivityType activityType);
    internal static ServiceModelActivity CreateAsyncActivity();
    internal static ServiceModelActivity CreateBoundedActivity();
    internal static ServiceModelActivity CreateBoundedActivity(bool suspendCurrent);
    internal static ServiceModelActivity CreateBoundedActivity(Guid activityId);
    internal static ServiceModelActivity CreateBoundedActivityWithTransferInOnly(Guid activityId);
    internal static ServiceModelActivity CreateLightWeightAsyncActivity(Guid activityId);
    internal static ServiceModelActivity CreateActivity(Guid activityId);
    internal static ServiceModelActivity CreateActivity(Guid activityId, bool autoStop);
    internal static ServiceModelActivity get_Current();
    private static void set_Current(ServiceModelActivity value);
    public sealed virtual void Dispose();
    internal Guid get_Id();
    private ActivityState get_LastState();
    private void set_LastState(ActivityState value);
    internal string get_Name();
    internal void set_Name(string value);
    internal void Resume();
    internal void Resume(string activityName);
    internal static void Start(ServiceModelActivity activity, string activityName, ActivityType activityType);
    internal void Stop();
    internal static void Stop(ServiceModelActivity activity);
    internal void Suspend();
    public virtual string ToString();
}
internal abstract class System.ServiceModel.Diagnostics.TraceAsyncResult : AsyncResult {
    private static Action`2<AsyncCallback, IAsyncResult> s_waitResultCallback;
    [CompilerGeneratedAttribute]
private ServiceModelActivity <CallbackActivity>k__BackingField;
    public ServiceModelActivity CallbackActivity { get; private set; }
    protected TraceAsyncResult(AsyncCallback callback, object state);
    private static TraceAsyncResult();
    [CompilerGeneratedAttribute]
public ServiceModelActivity get_CallbackActivity();
    [CompilerGeneratedAttribute]
private void set_CallbackActivity(ServiceModelActivity value);
    private static void DoCallback(AsyncCallback callback, IAsyncResult result);
}
internal static class System.ServiceModel.Diagnostics.TraceCode : object {
    public static int Administration;
    public static int WmiPut;
    public static int Diagnostics;
    public static int AppDomainUnload;
    public static int EventLog;
    public static int ThrowingException;
    public static int TraceHandledException;
    public static int UnhandledException;
    public static int FailedToAddAnActivityIdHeader;
    public static int FailedToReadAnActivityIdHeader;
    public static int FilterNotMatchedNodeQuotaExceeded;
    public static int MessageCountLimitExceeded;
    public static int DiagnosticsFailedMessageTrace;
    public static int MessageNotLoggedQuotaExceeded;
    public static int TraceTruncatedQuotaExceeded;
    public static int ActivityBoundary;
    public static int Serialization;
    public static int ElementIgnored;
    public static int Channels;
    public static int ConnectionAbandoned;
    public static int ConnectionPoolCloseException;
    public static int ConnectionPoolIdleTimeoutReached;
    public static int ConnectionPoolLeaseTimeoutReached;
    public static int ConnectionPoolMaxOutboundConnectionsPerEndpointQuotaReached;
    public static int ServerMaxPooledConnectionsQuotaReached;
    public static int EndpointListenerClose;
    public static int EndpointListenerOpen;
    public static int HttpResponseReceived;
    public static int HttpChannelConcurrentReceiveQuotaReached;
    public static int HttpChannelMessageReceiveFailed;
    public static int HttpChannelUnexpectedResponse;
    public static int HttpChannelRequestAborted;
    public static int HttpChannelResponseAborted;
    public static int HttpsClientCertificateInvalid;
    public static int HttpsClientCertificateNotPresent;
    public static int NamedPipeChannelMessageReceiveFailed;
    public static int NamedPipeChannelMessageReceived;
    public static int MessageReceived;
    public static int MessageSent;
    public static int RequestChannelReplyReceived;
    public static int TcpChannelMessageReceiveFailed;
    public static int TcpChannelMessageReceived;
    public static int ConnectToIPEndpoint;
    public static int SocketConnectionCreate;
    public static int SocketConnectionClose;
    public static int SocketConnectionAbort;
    public static int SocketConnectionAbortClose;
    public static int PipeConnectionAbort;
    public static int RequestContextAbort;
    public static int ChannelCreated;
    public static int ChannelDisposed;
    public static int ListenerCreated;
    public static int ListenerDisposed;
    public static int PrematureDatagramEof;
    public static int MaxPendingConnectionsReached;
    public static int MaxAcceptedChannelsReached;
    public static int ChannelConnectionDropped;
    public static int HttpAuthFailed;
    public static int NoExistingTransportManager;
    public static int IncompatibleExistingTransportManager;
    public static int InitiatingNamedPipeConnection;
    public static int InitiatingTcpConnection;
    public static int OpenedListener;
    public static int SslClientCertMissing;
    public static int StreamSecurityUpgradeAccepted;
    public static int TcpConnectError;
    public static int FailedAcceptFromPool;
    public static int FailedPipeConnect;
    public static int SystemTimeResolution;
    public static int PeerNeighborCloseFailed;
    public static int PeerNeighborClosingFailed;
    public static int PeerNeighborNotAccepted;
    public static int PeerNeighborNotFound;
    public static int PeerNeighborOpenFailed;
    public static int PeerNeighborStateChanged;
    public static int PeerNeighborStateChangeFailed;
    public static int PeerNeighborMessageReceived;
    public static int PeerNeighborManagerOffline;
    public static int PeerNeighborManagerOnline;
    public static int PeerChannelMessageReceived;
    public static int PeerChannelMessageSent;
    public static int PeerNodeAddressChanged;
    public static int PeerNodeOpening;
    public static int PeerNodeOpened;
    public static int PeerNodeOpenFailed;
    public static int PeerNodeClosing;
    public static int PeerNodeClosed;
    public static int PeerFloodedMessageReceived;
    public static int PeerFloodedMessageNotPropagated;
    public static int PeerFloodedMessageNotMatched;
    public static int PnrpRegisteredAddresses;
    public static int PnrpUnregisteredAddresses;
    public static int PnrpResolvedAddresses;
    public static int PnrpResolveException;
    public static int PeerReceiveMessageAuthenticationFailure;
    public static int PeerNodeAuthenticationFailure;
    public static int PeerNodeAuthenticationTimeout;
    public static int PeerFlooderReceiveMessageQuotaExceeded;
    public static int PeerServiceOpened;
    public static int PeerMaintainerActivity;
    public static int WsrmNegativeElapsedTimeDetected;
    public static int TcpTransferError;
    public static int TcpConnectionResetError;
    public static int TcpConnectionTimedOut;
    public static int ComIntegration;
    public static int ComIntegrationServiceHostStartingService;
    public static int ComIntegrationServiceHostStartedService;
    public static int ComIntegrationServiceHostCreatedServiceContract;
    public static int ComIntegrationServiceHostStartedServiceDetails;
    public static int ComIntegrationServiceHostCreatedServiceEndpoint;
    public static int ComIntegrationServiceHostStoppingService;
    public static int ComIntegrationServiceHostStoppedService;
    public static int ComIntegrationDllHostInitializerStarting;
    public static int ComIntegrationDllHostInitializerAddingHost;
    public static int ComIntegrationDllHostInitializerStarted;
    public static int ComIntegrationDllHostInitializerStopping;
    public static int ComIntegrationDllHostInitializerStopped;
    public static int ComIntegrationTLBImportStarting;
    public static int ComIntegrationTLBImportFromAssembly;
    public static int ComIntegrationTLBImportFromTypelib;
    public static int ComIntegrationTLBImportConverterEvent;
    public static int ComIntegrationTLBImportFinished;
    public static int ComIntegrationInstanceCreationRequest;
    public static int ComIntegrationInstanceCreationSuccess;
    public static int ComIntegrationInstanceReleased;
    public static int ComIntegrationEnteringActivity;
    public static int ComIntegrationExecutingCall;
    public static int ComIntegrationLeftActivity;
    public static int ComIntegrationInvokingMethod;
    public static int ComIntegrationInvokedMethod;
    public static int ComIntegrationInvokingMethodNewTransaction;
    public static int ComIntegrationInvokingMethodContextTransaction;
    public static int ComIntegrationServiceMonikerParsed;
    public static int ComIntegrationWsdlChannelBuilderLoaded;
    public static int ComIntegrationTypedChannelBuilderLoaded;
    public static int ComIntegrationChannelCreated;
    public static int ComIntegrationDispatchMethod;
    public static int ComIntegrationTxProxyTxCommitted;
    public static int ComIntegrationTxProxyTxAbortedByContext;
    public static int ComIntegrationTxProxyTxAbortedByTM;
    public static int ComIntegrationMexMonikerMetadataExchangeComplete;
    public static int ComIntegrationMexChannelBuilderLoaded;
    public static int Security;
    public static int SecurityIdentityVerificationSuccess;
    public static int SecurityIdentityVerificationFailure;
    public static int SecurityIdentityDeterminationSuccess;
    public static int SecurityIdentityDeterminationFailure;
    public static int SecurityIdentityHostNameNormalizationFailure;
    public static int SecurityImpersonationSuccess;
    public static int SecurityImpersonationFailure;
    public static int SecurityNegotiationProcessingFailure;
    public static int IssuanceTokenProviderRemovedCachedToken;
    public static int IssuanceTokenProviderUsingCachedToken;
    public static int IssuanceTokenProviderBeginSecurityNegotiation;
    public static int IssuanceTokenProviderEndSecurityNegotiation;
    public static int IssuanceTokenProviderRedirectApplied;
    public static int IssuanceTokenProviderServiceTokenCacheFull;
    public static int NegotiationTokenProviderAttached;
    public static int SpnegoClientNegotiationCompleted;
    public static int SpnegoServiceNegotiationCompleted;
    public static int SpnegoClientNegotiation;
    public static int SpnegoServiceNegotiation;
    public static int NegotiationAuthenticatorAttached;
    public static int ServiceSecurityNegotiationCompleted;
    public static int SecurityContextTokenCacheFull;
    public static int ExportSecurityChannelBindingEntry;
    public static int ExportSecurityChannelBindingExit;
    public static int ImportSecurityChannelBindingEntry;
    public static int ImportSecurityChannelBindingExit;
    public static int SecurityTokenProviderOpened;
    public static int SecurityTokenProviderClosed;
    public static int SecurityTokenAuthenticatorOpened;
    public static int SecurityTokenAuthenticatorClosed;
    public static int SecurityBindingOutgoingMessageSecured;
    public static int SecurityBindingIncomingMessageVerified;
    public static int SecurityBindingSecureOutgoingMessageFailure;
    public static int SecurityBindingVerifyIncomingMessageFailure;
    public static int SecuritySpnToSidMappingFailure;
    public static int SecuritySessionRedirectApplied;
    public static int SecurityClientSessionCloseSent;
    public static int SecurityClientSessionCloseResponseSent;
    public static int SecurityClientSessionCloseMessageReceived;
    public static int SecuritySessionKeyRenewalFaultReceived;
    public static int SecuritySessionAbortedFaultReceived;
    public static int SecuritySessionClosedResponseReceived;
    public static int SecurityClientSessionPreviousKeyDiscarded;
    public static int SecurityClientSessionKeyRenewed;
    public static int SecurityPendingServerSessionAdded;
    public static int SecurityPendingServerSessionClosed;
    public static int SecurityPendingServerSessionActivated;
    public static int SecurityActiveServerSessionRemoved;
    public static int SecurityNewServerSessionKeyIssued;
    public static int SecurityInactiveSessionFaulted;
    public static int SecurityServerSessionKeyUpdated;
    public static int SecurityServerSessionCloseReceived;
    public static int SecurityServerSessionRenewalFaultSent;
    public static int SecurityServerSessionAbortedFaultSent;
    public static int SecuritySessionCloseResponseSent;
    public static int SecuritySessionServerCloseSent;
    public static int SecurityServerSessionCloseResponseReceived;
    public static int SecuritySessionRenewFaultSendFailure;
    public static int SecuritySessionAbortedFaultSendFailure;
    public static int SecuritySessionClosedResponseSendFailure;
    public static int SecuritySessionServerCloseSendFailure;
    public static int SecuritySessionRequestorStartOperation;
    public static int SecuritySessionRequestorOperationSuccess;
    public static int SecuritySessionRequestorOperationFailure;
    public static int SecuritySessionResponderOperationFailure;
    public static int SecuritySessionDemuxFailure;
    public static int SecurityAuditWrittenSuccess;
    public static int SecurityAuditWrittenFailure;
    public static int ServiceModel;
    public static int AsyncCallbackThrewException;
    public static int CommunicationObjectAborted;
    public static int CommunicationObjectAbortFailed;
    public static int CommunicationObjectCloseFailed;
    public static int CommunicationObjectOpenFailed;
    public static int CommunicationObjectClosing;
    public static int CommunicationObjectClosed;
    public static int CommunicationObjectCreated;
    public static int CommunicationObjectDisposing;
    public static int CommunicationObjectFaultReason;
    public static int CommunicationObjectFaulted;
    public static int CommunicationObjectOpening;
    public static int CommunicationObjectOpened;
    public static int DidNotUnderstandMessageHeader;
    public static int UnderstoodMessageHeader;
    public static int MessageClosed;
    public static int MessageClosedAgain;
    public static int MessageCopied;
    public static int MessageRead;
    public static int MessageWritten;
    public static int BeginExecuteMethod;
    public static int ConfigurationIsReadOnly;
    public static int ConfiguredExtensionTypeNotFound;
    public static int EvaluationContextNotFound;
    public static int EndExecuteMethod;
    public static int ExtensionCollectionDoesNotExist;
    public static int ExtensionCollectionNameNotFound;
    public static int ExtensionCollectionIsEmpty;
    public static int ExtensionElementAlreadyExistsInCollection;
    public static int ElementTypeDoesntMatchConfiguredType;
    public static int ErrorInvokingUserCode;
    public static int GetBehaviorElement;
    public static int GetCommonBehaviors;
    public static int GetConfiguredBinding;
    public static int GetChannelEndpointElement;
    public static int GetConfigurationSection;
    public static int GetDefaultConfiguredBinding;
    public static int GetServiceElement;
    public static int MessageProcessingPaused;
    public static int ManualFlowThrottleLimitReached;
    public static int OverridingDuplicateConfigurationKey;
    public static int RemoveBehavior;
    public static int ServiceChannelLifetime;
    public static int ServiceHostCreation;
    public static int ServiceHostBaseAddresses;
    public static int ServiceHostTimeoutOnClose;
    public static int ServiceHostFaulted;
    public static int ServiceHostErrorOnReleasePerformanceCounter;
    public static int ServiceThrottleLimitReached;
    public static int ServiceOperationMissingReply;
    public static int ServiceOperationMissingReplyContext;
    public static int ServiceOperationExceptionOnReply;
    public static int SkipBehavior;
    public static int TransportListen;
    public static int UnhandledAction;
    public static int PerformanceCounterFailedToLoad;
    public static int PerformanceCountersFailed;
    public static int PerformanceCountersFailedDuringUpdate;
    public static int PerformanceCountersFailedForService;
    public static int PerformanceCountersFailedOnRelease;
    public static int WsmexNonCriticalWsdlExportError;
    public static int WsmexNonCriticalWsdlImportError;
    public static int FailedToOpenIncomingChannel;
    public static int UnhandledExceptionInUserOperation;
    public static int DroppedAMessage;
    public static int CannotBeImportedInCurrentFormat;
    public static int GetConfiguredEndpoint;
    public static int GetDefaultConfiguredEndpoint;
    public static int ExtensionTypeNotFound;
    public static int DefaultEndpointsAdded;
    public static int MetadataExchangeClientSendRequest;
    public static int MetadataExchangeClientReceiveReply;
    public static int WarnHelpPageEnabledNoBaseAddress;
    public static int PortSharing;
    public static int PortSharingClosed;
    public static int PortSharingDuplicatedPipe;
    public static int PortSharingDupHandleGranted;
    public static int PortSharingDuplicatedSocket;
    public static int PortSharingListening;
    public static int SharedManagerServiceEndpointNotExist;
    public static int ServiceModelTransaction;
    public static int TxSourceTxScopeRequiredIsTransactedTransport;
    public static int TxSourceTxScopeRequiredIsTransactionFlow;
    public static int TxSourceTxScopeRequiredIsAttachedTransaction;
    public static int TxSourceTxScopeRequiredIsCreateNewTransaction;
    public static int TxCompletionStatusCompletedForAutocomplete;
    public static int TxCompletionStatusCompletedForError;
    public static int TxCompletionStatusCompletedForSetComplete;
    public static int TxCompletionStatusCompletedForTACOSC;
    public static int TxCompletionStatusCompletedForAsyncAbort;
    public static int TxCompletionStatusRemainsAttached;
    public static int TxCompletionStatusAbortedOnSessionClose;
    public static int TxReleaseServiceInstanceOnCompletion;
    public static int TxAsyncAbort;
    public static int TxFailedToNegotiateOleTx;
    public static int TxSourceTxScopeRequiredUsingExistingTransaction;
    public static int NetFx35;
    public static int ActivatingMessageReceived;
    public static int InstanceContextBoundToDurableInstance;
    public static int InstanceContextDetachedFromDurableInstance;
    public static int ContextChannelFactoryChannelCreated;
    public static int ContextChannelListenerChannelAccepted;
    public static int ContextProtocolContextAddedToMessage;
    public static int ContextProtocolContextRetrievedFromMessage;
    public static int DICPInstanceContextCached;
    public static int DICPInstanceContextRemovedFromCache;
    public static int ServiceDurableInstanceDeleted;
    public static int ServiceDurableInstanceDisposed;
    public static int ServiceDurableInstanceLoaded;
    public static int ServiceDurableInstanceSaved;
    public static int SqlPersistenceProviderSQLCallStart;
    public static int SqlPersistenceProviderSQLCallEnd;
    public static int SqlPersistenceProviderOpenParameters;
    public static int SyncContextSchedulerServiceTimerCancelled;
    public static int SyncContextSchedulerServiceTimerCreated;
    public static int WorkflowDurableInstanceLoaded;
    public static int WorkflowDurableInstanceAborted;
    public static int WorkflowDurableInstanceActivated;
    public static int WorkflowOperationInvokerItemQueued;
    public static int WorkflowRequestContextReplySent;
    public static int WorkflowRequestContextFaultSent;
    public static int WorkflowServiceHostCreated;
    public static int SyndicationReadFeedBegin;
    public static int SyndicationReadFeedEnd;
    public static int SyndicationReadItemBegin;
    public static int SyndicationReadItemEnd;
    public static int SyndicationWriteFeedBegin;
    public static int SyndicationWriteFeedEnd;
    public static int SyndicationWriteItemBegin;
    public static int SyndicationWriteItemEnd;
    public static int SyndicationProtocolElementIgnoredOnRead;
    public static int SyndicationProtocolElementIgnoredOnWrite;
    public static int SyndicationProtocolElementInvalid;
    public static int WebUnknownQueryParameterIgnored;
    public static int WebRequestMatchesOperation;
    public static int WebRequestDoesNotMatchOperations;
    public static int WebRequestRedirect;
    public static int SyndicationReadServiceDocumentBegin;
    public static int SyndicationReadServiceDocumentEnd;
    public static int SyndicationReadCategoriesDocumentBegin;
    public static int SyndicationReadCategoriesDocumentEnd;
    public static int SyndicationWriteServiceDocumentBegin;
    public static int SyndicationWriteServiceDocumentEnd;
    public static int SyndicationWriteCategoriesDocumentBegin;
    public static int SyndicationWriteCategoriesDocumentEnd;
    public static int AutomaticFormatSelectedOperationDefault;
    public static int AutomaticFormatSelectedRequestBased;
    public static int RequestFormatSelectedFromContentTypeMapper;
    public static int RequestFormatSelectedByEncoderDefaults;
    public static int AddingResponseToOutputCache;
    public static int AddingAuthenticatedResponseToOutputCache;
    public static int JsonpCallbackNameSet;
}
public static class System.ServiceModel.Diagnostics.TraceUtility : object {
    private static string ActivityIdKey;
    private static string AsyncOperationActivityKey;
    private static string AsyncOperationStartTimeKey;
    private static long s_messageNumber;
    public static string E2EActivityId;
    public static string TraceApplicationReference;
    public static bool PropagateUserActivity { get; }
    private static bool PropagateUserActivityCore { get; }
    internal static bool ShouldPropagateActivity { get; }
    internal static bool ShouldPropagateActivityGlobal { get; }
    internal static bool ActivityTracing { get; }
    internal static bool MessageFlowTracing { get; }
    internal static bool MessageFlowTracingOnly { get; }
    private static TraceUtility();
    internal static void AddActivityHeader(Message message);
    internal static void AddAmbientActivityToMessage(Message message);
    internal static void CopyActivity(Message source, Message destination);
    internal static long GetUtcBasedDurationForTrace(long startTicks);
    internal static ServiceModelActivity ExtractActivity(Message message);
    internal static Guid ExtractActivityId(Message message);
    internal static Guid GetReceivedActivityId(OperationContext operationContext);
    internal static ServiceModelActivity ExtractAndRemoveActivity(Message message);
    internal static void ProcessIncomingMessage(Message message, EventTraceActivity eventTraceActivity);
    internal static void ProcessOutgoingMessage(Message message, EventTraceActivity eventTraceActivity);
    internal static void SetActivity(Message message, ServiceModelActivity activity);
    internal static void TraceDroppedMessage(Message message, EndpointDispatcher dispatcher);
    private static string GenerateMsdnTraceCode(int traceCode);
    internal static Exception ThrowHelperError(Exception exception, Message message);
    internal static Exception ThrowHelperError(Exception exception, Guid activityId, object source);
    internal static Exception ThrowHelperWarning(Exception exception, Message message);
    internal static ArgumentException ThrowHelperArgument(string paramName, string message, Message msg);
    internal static ArgumentNullException ThrowHelperArgumentNull(string paramName, Message message);
    internal static string CreateSourceString(object source);
    internal static void TraceHttpConnectionInformation(string localEndpoint, string remoteEndpoint, object source);
    internal static void TraceUserCodeException(Exception e, MethodInfo method);
    [SecuritySafeCriticalAttribute]
private static void SetEndToEndTracingFlags();
    public static long RetrieveMessageNumber();
    public static bool get_PropagateUserActivity();
    private static bool get_PropagateUserActivityCore();
    internal static string GetCallerInfo(OperationContext context);
    [SecuritySafeCriticalAttribute]
internal static void SetEtwProviderId();
    internal static void SetActivityId(MessageProperties properties);
    internal static bool get_ShouldPropagateActivity();
    internal static bool get_ShouldPropagateActivityGlobal();
    internal static bool get_ActivityTracing();
    internal static bool get_MessageFlowTracing();
    internal static bool get_MessageFlowTracingOnly();
    internal static void MessageFlowAtMessageSent(Message message, EventTraceActivity eventTraceActivity);
    internal static void MessageFlowAtMessageReceived(Message message, OperationContext context, EventTraceActivity eventTraceActivity, bool createNewActivityId);
    internal static string GetAnnotation(OperationContext context);
    internal static void TransferFromTransport(Message message);
    internal static void UpdateAsyncOperationContextWithActivity(object activity);
    internal static object ExtractAsyncOperationContextActivity();
    internal static void UpdateAsyncOperationContextWithStartTime(EventTraceActivity eventTraceActivity, long startTime);
    internal static void ExtractAsyncOperationStartTime(EventTraceActivity& eventTraceActivity, Int64& startTime);
    internal static AsyncCallback WrapExecuteUserCodeAsyncCallback(AsyncCallback callback);
}
public static class System.ServiceModel.DiagnosticUtility : object {
    private static string TraceSourceName;
    internal static string EventSourceName;
    internal static string DefaultTraceListenerName;
    private static bool s_shouldUseActivity;
    private static object s_lockObject;
    private static ExceptionUtility s_exceptionUtility;
    public static ExceptionUtility ExceptionUtility { get; }
    internal static bool ShouldUseActivity { get; }
    private static DiagnosticUtility();
    private static void UpdateLevel();
    public static ExceptionUtility get_ExceptionUtility();
    private static ExceptionUtility GetExceptionUtility();
    internal static bool get_ShouldUseActivity();
    [ConditionalAttribute("DEBUG")]
internal static void DebugAssert(bool condition, string message);
    [ConditionalAttribute("DEBUG")]
internal static void DebugAssert(string message);
}
internal class System.ServiceModel.Dispatcher.BufferedReceiveBinder : object {
    private static Action`1<object> s_tryReceive;
    private static AsyncCallback s_tryReceiveCallback;
    private IChannelBinder _channelBinder;
    private InputQueue`1<RequestContextWrapper> _inputQueue;
    private int _pendingOperationSemaphore;
    public IChannel Channel { get; }
    public bool HasSession { get; }
    public Uri ListenUri { get; }
    public EndpointAddress LocalAddress { get; }
    public EndpointAddress RemoteAddress { get; }
    public BufferedReceiveBinder(IChannelBinder channelBinder);
    private static BufferedReceiveBinder();
    public sealed virtual IChannel get_Channel();
    public sealed virtual bool get_HasSession();
    public sealed virtual Uri get_ListenUri();
    public sealed virtual EndpointAddress get_LocalAddress();
    public sealed virtual EndpointAddress get_RemoteAddress();
    public sealed virtual void Abort();
    public sealed virtual void CloseAfterFault(TimeSpan timeout);
    public sealed virtual bool TryReceive(TimeSpan timeout, RequestContext& requestContext);
    public sealed virtual IAsyncResult BeginTryReceive(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual bool EndTryReceive(IAsyncResult result, RequestContext& requestContext);
    public sealed virtual RequestContext CreateRequestContext(Message message);
    public sealed virtual void Send(Message message, TimeSpan timeout);
    public sealed virtual IAsyncResult BeginSend(Message message, TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual void EndSend(IAsyncResult result);
    public sealed virtual Message Request(Message message, TimeSpan timeout);
    public sealed virtual IAsyncResult BeginRequest(Message message, TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual Message EndRequest(IAsyncResult result);
    public sealed virtual bool WaitForMessage(TimeSpan timeout);
    public sealed virtual IAsyncResult BeginWaitForMessage(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual bool EndWaitForMessage(IAsyncResult result);
    internal void InjectRequest(RequestContext requestContext);
    private static void TryReceive(object state);
    private static void TryReceiveCallback(IAsyncResult result);
    private static void HandleEndTryReceive(IAsyncResult result);
}
public class System.ServiceModel.Dispatcher.ChannelDispatcher : ChannelDispatcherBase {
    private SynchronizedCollection`1<IChannelInitializer> _channelInitializers;
    private CommunicationObjectManager`1<IChannel> _channels;
    private EndpointDispatcherCollection _endpointDispatchers;
    private Collection`1<IErrorHandler> _errorHandlers;
    private EndpointDispatcherTable _filterTable;
    private bool _receiveContextEnabled;
    private IChannelListener _listener;
    private ListenerHandler _listenerHandler;
    private int _maxTransactedBatchSize;
    private MessageVersion _messageVersion;
    private SynchronizedChannelCollection`1<IChannel> _pendingChannels;
    private bool _receiveSynchronously;
    private bool _sendAsynchronously;
    private int _maxPendingReceives;
    private bool _includeExceptionDetailInFaults;
    private bool _session;
    private SharedRuntimeState _shared;
    private IDefaultCommunicationTimeouts _timeouts;
    private TimeSpan _transactionTimeout;
    private bool _performDefaultCloseInput;
    private EventTraceActivity _eventTraceActivity;
    private ErrorBehavior _errorBehavior;
    [CompilerGeneratedAttribute]
private bool <BufferedReceiveEnabled>k__BackingField;
    protected TimeSpan DefaultCloseTimeout { get; }
    protected TimeSpan DefaultOpenTimeout { get; }
    internal EndpointDispatcherTable EndpointDispatcherTable { get; }
    internal CommunicationObjectManager`1<IChannel> Channels { get; }
    public SynchronizedCollection`1<EndpointDispatcher> Endpoints { get; }
    public Collection`1<IErrorHandler> ErrorHandlers { get; }
    public MessageVersion MessageVersion { get; public set; }
    internal bool EnableFaults { get; internal set; }
    internal bool IsOnServer { get; }
    public bool ReceiveContextEnabled { get; public set; }
    internal bool BufferedReceiveEnabled { get; internal set; }
    public IChannelListener Listener { get; }
    public int MaxTransactedBatchSize { get; public set; }
    public bool ManualAddressing { get; public set; }
    internal SynchronizedChannelCollection`1<IChannel> PendingChannels { get; }
    public bool ReceiveSynchronously { get; public set; }
    public bool SendAsynchronously { get; public set; }
    public int MaxPendingReceives { get; public set; }
    public bool IncludeExceptionDetailInFaults { get; public set; }
    internal IDefaultCommunicationTimeouts DefaultCommunicationTimeouts { get; }
    internal ChannelDispatcher(SharedRuntimeState shared);
    private void Initialize(SharedRuntimeState shared);
    protected virtual TimeSpan get_DefaultCloseTimeout();
    protected virtual TimeSpan get_DefaultOpenTimeout();
    internal EndpointDispatcherTable get_EndpointDispatcherTable();
    internal CommunicationObjectManager`1<IChannel> get_Channels();
    public SynchronizedCollection`1<EndpointDispatcher> get_Endpoints();
    public Collection`1<IErrorHandler> get_ErrorHandlers();
    public MessageVersion get_MessageVersion();
    public void set_MessageVersion(MessageVersion value);
    internal bool get_EnableFaults();
    internal void set_EnableFaults(bool value);
    internal bool get_IsOnServer();
    public bool get_ReceiveContextEnabled();
    public void set_ReceiveContextEnabled(bool value);
    [CompilerGeneratedAttribute]
internal bool get_BufferedReceiveEnabled();
    [CompilerGeneratedAttribute]
internal void set_BufferedReceiveEnabled(bool value);
    public virtual IChannelListener get_Listener();
    public int get_MaxTransactedBatchSize();
    public void set_MaxTransactedBatchSize(int value);
    public bool get_ManualAddressing();
    public void set_ManualAddressing(bool value);
    internal SynchronizedChannelCollection`1<IChannel> get_PendingChannels();
    public bool get_ReceiveSynchronously();
    public void set_ReceiveSynchronously(bool value);
    public bool get_SendAsynchronously();
    public void set_SendAsynchronously(bool value);
    public int get_MaxPendingReceives();
    public void set_MaxPendingReceives(int value);
    public bool get_IncludeExceptionDetailInFaults();
    public void set_IncludeExceptionDetailInFaults(bool value);
    internal IDefaultCommunicationTimeouts get_DefaultCommunicationTimeouts();
    private void AbortPendingChannels();
    internal virtual void CloseInput(TimeSpan timeout);
    public virtual void CloseInput();
    private void OnListenerFaulted(object sender, EventArgs e);
    internal bool HandleError(Exception error);
    internal bool HandleError(Exception error, ErrorHandlerFaultInfo& faultInfo);
    internal void InitializeChannel(IClientChannel channel);
    internal SynchronizedCollection`1<T> NewBehaviorCollection();
    private void OnAddEndpoint(EndpointDispatcher endpoint);
    private void OnRemoveEndpoint(EndpointDispatcher endpoint);
    protected virtual void OnAbort();
    protected virtual void OnClose(TimeSpan timeout);
    protected virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndClose(IAsyncResult result);
    protected virtual void OnClosed();
    protected virtual void OnOpen(TimeSpan timeout);
    protected internal virtual Task OnCloseAsync(TimeSpan timeout);
    protected internal virtual Task OnOpenAsync(TimeSpan timeout);
    private InvalidOperationException CreateOuterExceptionWithEndpointsInformation(InvalidOperationException e);
    internal string CreateContractListString();
    protected virtual IAsyncResult OnBeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndOpen(IAsyncResult result);
    protected virtual void OnOpening();
    protected virtual void OnOpened();
    internal void ProvideFault(Exception e, FaultConverter faultConverter, ErrorHandlerFaultInfo& faultInfo);
    internal void ThrowIfDisposedOrImmutable();
    private void ThrowIfNoMessageVersion();
}
public abstract class System.ServiceModel.Dispatcher.ChannelDispatcherBase : CommunicationObject {
    public IChannelListener Listener { get; }
    public abstract virtual IChannelListener get_Listener();
    public virtual void CloseInput();
    internal virtual void CloseInput(TimeSpan timeout);
}
internal class System.ServiceModel.Dispatcher.ChannelHandler : object {
    public static TimeSpan CloseAfterFaultTimeout;
    public static string MessageBufferPropertyName;
    private IChannelBinder _binder;
    private DuplexChannelBinder _duplexBinder;
    private bool _incrementedActivityCountInConstructor;
    private bool _isCallback;
    private ListenerHandler _listener;
    private SessionIdleManager _idleManager;
    private bool _sendAsynchronously;
    private static AsyncCallback s_onAsyncReplyComplete;
    private static AsyncCallback s_onAsyncReceiveComplete;
    private static Action`1<object> s_onContinueAsyncReceive;
    private static Action`1<object> s_onStartSyncMessagePump;
    private static Action`1<object> s_onStartAsyncMessagePump;
    private static Action`1<object> s_openAndEnsurePump;
    private RequestInfo _requestInfo;
    private ServiceChannel _channel;
    private bool _doneReceiving;
    private bool _hasRegisterBeenCalled;
    private bool _hasSession;
    private int _isPumpAcquired;
    private bool _isChannelTerminated;
    private bool _isConcurrent;
    private bool _isManualAddressing;
    private MessageVersion _messageVersion;
    private ErrorHandlingReceiver _receiver;
    private bool _receiveSynchronously;
    private RequestContext _replied;
    private EventTraceActivity _eventTraceActivity;
    private bool _shouldRejectMessageWithOnOpenActionHeader;
    private object _acquirePumpLock;
    internal IChannelBinder Binder { get; }
    internal ServiceChannel Channel { get; }
    internal bool HasRegisterBeenCalled { get; }
    private bool IsOpen { get; }
    private object ThisLock { get; }
    private EventTraceActivity EventTraceActivity { get; }
    internal ChannelHandler(MessageVersion messageVersion, IChannelBinder binder, ServiceChannel channel);
    internal ChannelHandler(MessageVersion messageVersion, IChannelBinder binder, ListenerHandler listener, SessionIdleManager idleManager);
    private static ChannelHandler();
    internal IChannelBinder get_Binder();
    internal ServiceChannel get_Channel();
    internal bool get_HasRegisterBeenCalled();
    private bool get_IsOpen();
    private object get_ThisLock();
    private EventTraceActivity get_EventTraceActivity();
    internal static void Register(ChannelHandler handler);
    internal static void Register(ChannelHandler handler, RequestContext request);
    private void Register();
    private void AsyncMessagePump();
    private void AsyncMessagePump(IAsyncResult result);
    private IAsyncResult BeginTryReceive();
    private bool DispatchAndReleasePump(RequestContext request, bool cleanThread, OperationContext currentOperationContext);
    internal void DispatchDone();
    private bool EndTryReceive(IAsyncResult result, RequestContext& requestContext);
    private void EnsureChannelAndEndpoint(RequestContext request);
    private void EnsurePump();
    private ServiceChannel GetDatagramChannel(Message message, EndpointDispatcher& endpoint, Boolean& addressMatched);
    private EndpointDispatcher GetEndpointDispatcher(Message message, Boolean& addressMatched);
    private ServiceChannel GetSessionChannel(Message message, EndpointDispatcher& endpoint, Boolean& addressMatched);
    private void InitializeServiceChannel(ServiceChannel channel);
    private void ProvideFault(Exception e, ErrorHandlerFaultInfo& faultInfo);
    internal bool HandleError(Exception e);
    private bool HandleError(Exception e, ErrorHandlerFaultInfo& faultInfo);
    private bool HandleError(Exception e, RequestContext request, ServiceChannel channel);
    private bool HandleErrorContinuation(Exception e, RequestContext request, ServiceChannel channel, ErrorHandlerFaultInfo& faultInfo, bool replied);
    private void HandleReceiveComplete(RequestContext context);
    private bool HandleRequest(RequestContext request, OperationContext currentOperationContext);
    private bool HandleRequestAsReply(RequestContext request);
    private static void OnStartAsyncMessagePump(object state);
    private static void OnStartSyncMessagePump(object state);
    private static void OnAsyncReceiveComplete(IAsyncResult result);
    private static void OnContinueAsyncReceive(object state);
    private static void OpenAndEnsurePump(object state);
    private void OpenAndEnsurePump();
    private bool TryReceive(TimeSpan timeout, RequestContext& requestContext);
    private void ReplyAddressFilterDidNotMatch(RequestContext request);
    private void ReplyContractFilterDidNotMatch(RequestContext request);
    private void ReplyChannelTerminated(RequestContext request);
    private void ReplyFailure(RequestContext request, FaultCode code, string reason);
    private void ReplyFailure(RequestContext request, FaultCode code, string reason, string action);
    private void ReplyFailure(RequestContext request, Message fault, string action, string reason, FaultCode code);
    private void ProvideFaultAndReplyFailure(RequestContext request, Exception exception, ErrorHandlerFaultInfo& faultInfo, Boolean& replied, Boolean& replySentAsync);
    private bool PrepareReply(RequestContext request, Message reply);
    private static void AsyncReplyComplete(IAsyncResult result, ContinuationState state);
    private static void OnAsyncReplyComplete(IAsyncResult result);
    private void ReleasePump();
    private void SyncMessagePump();
    private bool TryRetrievingInstanceContext(RequestContext request);
    private bool TryAcquirePump();
    private EventTraceActivity TraceDispatchMessageStart(Message message);
}
public class System.ServiceModel.Dispatcher.ClientOperation : ClientOperationCompatBase {
    private string _action;
    private SynchronizedCollection`1<FaultContractInfo> _faultContractInfos;
    private bool _serializeRequest;
    private bool _deserializeReply;
    private IClientMessageFormatter _formatter;
    private IClientFaultFormatter _faultFormatter;
    private bool _isInitiating;
    private bool _isOneWay;
    private bool _isTerminating;
    private bool _isSessionOpenNotificationEnabled;
    private string _name;
    private ClientRuntime _parent;
    private string _replyAction;
    private MethodInfo _beginMethod;
    private MethodInfo _endMethod;
    private MethodInfo _syncMethod;
    private MethodInfo _taskMethod;
    private Type _taskTResult;
    private bool _isFaultFormatterSetExplicit;
    public string Action { get; }
    public SynchronizedCollection`1<FaultContractInfo> FaultContractInfos { get; }
    public MethodInfo BeginMethod { get; public set; }
    public MethodInfo EndMethod { get; public set; }
    public MethodInfo SyncMethod { get; public set; }
    public IClientMessageFormatter Formatter { get; public set; }
    internal IClientFaultFormatter FaultFormatter { get; internal set; }
    internal bool IsFaultFormatterSetExplicit { get; }
    internal IClientMessageFormatter InternalFormatter { get; internal set; }
    public bool IsInitiating { get; public set; }
    public bool IsOneWay { get; public set; }
    public bool IsTerminating { get; public set; }
    public string Name { get; }
    public ICollection`1<IParameterInspector> ClientParameterInspectors { get; }
    [EditorBrowsableAttribute("1")]
public SynchronizedCollection`1<IParameterInspector> ParameterInspectors { get; }
    public ClientRuntime Parent { get; }
    public string ReplyAction { get; }
    public bool SerializeRequest { get; public set; }
    public bool DeserializeReply { get; public set; }
    public MethodInfo TaskMethod { get; public set; }
    public Type TaskTResult { get; public set; }
    internal bool IsSessionOpenNotificationEnabled { get; internal set; }
    public ClientOperation(ClientRuntime parent, string name, string action);
    public ClientOperation(ClientRuntime parent, string name, string action, string replyAction);
    public string get_Action();
    public SynchronizedCollection`1<FaultContractInfo> get_FaultContractInfos();
    public MethodInfo get_BeginMethod();
    public void set_BeginMethod(MethodInfo value);
    public MethodInfo get_EndMethod();
    public void set_EndMethod(MethodInfo value);
    public MethodInfo get_SyncMethod();
    public void set_SyncMethod(MethodInfo value);
    public IClientMessageFormatter get_Formatter();
    public void set_Formatter(IClientMessageFormatter value);
    internal IClientFaultFormatter get_FaultFormatter();
    internal void set_FaultFormatter(IClientFaultFormatter value);
    internal bool get_IsFaultFormatterSetExplicit();
    internal IClientMessageFormatter get_InternalFormatter();
    internal void set_InternalFormatter(IClientMessageFormatter value);
    public bool get_IsInitiating();
    public void set_IsInitiating(bool value);
    public bool get_IsOneWay();
    public void set_IsOneWay(bool value);
    public bool get_IsTerminating();
    public void set_IsTerminating(bool value);
    public string get_Name();
    public ICollection`1<IParameterInspector> get_ClientParameterInspectors();
    public SynchronizedCollection`1<IParameterInspector> get_ParameterInspectors();
    public ClientRuntime get_Parent();
    public string get_ReplyAction();
    public bool get_SerializeRequest();
    public void set_SerializeRequest(bool value);
    public bool get_DeserializeReply();
    public void set_DeserializeReply(bool value);
    public MethodInfo get_TaskMethod();
    public void set_TaskMethod(MethodInfo value);
    public Type get_TaskTResult();
    public void set_TaskTResult(Type value);
    internal bool get_IsSessionOpenNotificationEnabled();
    internal void set_IsSessionOpenNotificationEnabled(bool value);
}
[EditorBrowsableAttribute("1")]
public class System.ServiceModel.Dispatcher.ClientOperationCompatBase : object {
    internal SynchronizedCollection`1<IParameterInspector> parameterInspectors;
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This API supports the .NET Framework infrastructure and is not intended to be used directly from your code.", "True")]
public IList`1<IParameterInspector> ParameterInspectors { get; }
    public IList`1<IParameterInspector> get_ParameterInspectors();
}
public class System.ServiceModel.Dispatcher.ClientRuntime : ClientRuntimeCompatBase {
    private bool _addTransactionFlowProperties;
    private Type _callbackProxyType;
    private ProxyBehaviorCollection`1<IChannelInitializer> _channelInitializers;
    private string _contractName;
    private string _contractNamespace;
    private Type _contractProxyType;
    private DispatchRuntime _dispatchRuntime;
    private IdentityVerifier _identityVerifier;
    private ProxyBehaviorCollection`1<IInteractiveChannelInitializer> _interactiveChannelInitializers;
    private IClientOperationSelector _operationSelector;
    private ImmutableClientRuntime _runtime;
    private ClientOperation _unhandled;
    private bool _useSynchronizationContext;
    private Uri _via;
    private SharedRuntimeState _shared;
    private int _maxFaultSize;
    private bool _messageVersionNoneFaultsEnabled;
    internal bool AddTransactionFlowProperties { get; internal set; }
    public Type CallbackClientType { get; public set; }
    public SynchronizedCollection`1<IChannelInitializer> ChannelInitializers { get; }
    public string ContractName { get; }
    public string ContractNamespace { get; }
    public Type ContractClientType { get; public set; }
    internal IdentityVerifier IdentityVerifier { get; internal set; }
    public Uri Via { get; public set; }
    public bool ValidateMustUnderstand { get; public set; }
    public bool MessageVersionNoneFaultsEnabled { get; public set; }
    public DispatchRuntime DispatchRuntime { get; }
    public DispatchRuntime CallbackDispatchRuntime { get; }
    internal bool EnableFaults { get; internal set; }
    public SynchronizedCollection`1<IInteractiveChannelInitializer> InteractiveChannelInitializers { get; }
    public int MaxFaultSize { get; public set; }
    internal bool IsOnServer { get; }
    public bool ManualAddressing { get; public set; }
    internal int MaxParameterInspectors { get; }
    public ICollection`1<IClientMessageInspector> ClientMessageInspectors { get; }
    [EditorBrowsableAttribute("1")]
public SynchronizedCollection`1<IClientMessageInspector> MessageInspectors { get; }
    public ICollection`1<ClientOperation> ClientOperations { get; }
    [EditorBrowsableAttribute("1")]
public SynchronizedKeyedCollection`2<string, ClientOperation> Operations { get; }
    public IClientOperationSelector OperationSelector { get; public set; }
    internal object ThisLock { get; }
    public ClientOperation UnhandledClientOperation { get; }
    internal bool UseSynchronizationContext { get; internal set; }
    internal ClientRuntime(DispatchRuntime dispatchRuntime, SharedRuntimeState shared);
    internal ClientRuntime(string contractName, string contractNamespace);
    private ClientRuntime(string contractName, string contractNamespace, SharedRuntimeState shared);
    internal bool get_AddTransactionFlowProperties();
    internal void set_AddTransactionFlowProperties(bool value);
    public Type get_CallbackClientType();
    public void set_CallbackClientType(Type value);
    public SynchronizedCollection`1<IChannelInitializer> get_ChannelInitializers();
    public string get_ContractName();
    public string get_ContractNamespace();
    public Type get_ContractClientType();
    public void set_ContractClientType(Type value);
    internal IdentityVerifier get_IdentityVerifier();
    internal void set_IdentityVerifier(IdentityVerifier value);
    public Uri get_Via();
    public void set_Via(Uri value);
    public bool get_ValidateMustUnderstand();
    public void set_ValidateMustUnderstand(bool value);
    public bool get_MessageVersionNoneFaultsEnabled();
    public void set_MessageVersionNoneFaultsEnabled(bool value);
    public DispatchRuntime get_DispatchRuntime();
    public DispatchRuntime get_CallbackDispatchRuntime();
    internal bool get_EnableFaults();
    internal void set_EnableFaults(bool value);
    public SynchronizedCollection`1<IInteractiveChannelInitializer> get_InteractiveChannelInitializers();
    public int get_MaxFaultSize();
    public void set_MaxFaultSize(int value);
    internal bool get_IsOnServer();
    public bool get_ManualAddressing();
    public void set_ManualAddressing(bool value);
    internal int get_MaxParameterInspectors();
    public ICollection`1<IClientMessageInspector> get_ClientMessageInspectors();
    public SynchronizedCollection`1<IClientMessageInspector> get_MessageInspectors();
    public ICollection`1<ClientOperation> get_ClientOperations();
    public SynchronizedKeyedCollection`2<string, ClientOperation> get_Operations();
    public IClientOperationSelector get_OperationSelector();
    public void set_OperationSelector(IClientOperationSelector value);
    internal object get_ThisLock();
    public ClientOperation get_UnhandledClientOperation();
    internal bool get_UseSynchronizationContext();
    internal void set_UseSynchronizationContext(bool value);
    internal T[] GetArray(SynchronizedCollection`1<T> collection);
    internal ImmutableClientRuntime GetRuntime();
    internal void InvalidateRuntime();
    internal void LockDownProperties();
    internal SynchronizedCollection`1<T> NewBehaviorCollection();
    internal bool IsFault(Message& reply);
    internal static bool IsMessageVersionNoneFault(Message& message, int maxFaultSize);
}
[EditorBrowsableAttribute("1")]
public class System.ServiceModel.Dispatcher.ClientRuntimeCompatBase : object {
    internal SynchronizedCollection`1<IClientMessageInspector> messageInspectors;
    internal SynchronizedKeyedCollection`2<string, ClientOperation> operations;
    internal KeyedCollection`2<string, ClientOperation> compatOperations;
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This API supports the .NET Framework infrastructure and is not intended to be used directly from your code.", "True")]
public IList`1<IClientMessageInspector> MessageInspectors { get; }
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This API supports the .NET Framework infrastructure and is not intended to be used directly from your code.", "True")]
public KeyedCollection`2<string, ClientOperation> Operations { get; }
    public IList`1<IClientMessageInspector> get_MessageInspectors();
    public KeyedCollection`2<string, ClientOperation> get_Operations();
}
internal class System.ServiceModel.Dispatcher.ConcurrencyBehavior : object {
    private ConcurrencyMode _concurrencyMode;
    private bool _enforceOrderedReceive;
    internal ConcurrencyBehavior(DispatchRuntime runtime);
    internal bool IsConcurrent(MessageRpc& rpc);
    internal static bool IsConcurrent(ConcurrencyMode concurrencyMode, bool ensureOrderedDispatch, bool hasSession);
    internal static bool IsConcurrent(ChannelDispatcher runtime, bool hasSession);
    internal void LockInstance(MessageRpc& rpc);
    internal void UnlockInstance(MessageRpc& rpc);
    internal static void UnlockInstanceBeforeCallout(OperationContext operationContext);
    private static void UnlockInstance(InstanceContext instanceContext);
    internal static void LockInstanceAfterCallout(OperationContext operationContext);
}
internal class System.ServiceModel.Dispatcher.ConcurrencyInstanceContextFacet : object {
    internal bool Locked;
    private Queue`1<IWaiter> _calloutMessageQueue;
    private Queue`1<IWaiter> _newMessageQueue;
    internal bool HasWaiters { get; }
    internal bool get_HasWaiters();
    private IWaiter DequeueFrom(Queue`1<IWaiter> queue);
    internal IWaiter DequeueWaiter();
    internal void EnqueueNewMessage(IWaiter waiter);
    internal void EnqueueCalloutMessage(IWaiter waiter);
}
internal static class System.ServiceModel.Dispatcher.DataContractSerializerDefaults : object {
    internal static bool IgnoreExtensionDataObject;
    internal static int MaxItemsInObjectGraph;
    internal static DataContractSerializer CreateSerializer(Type type, int maxItems);
    internal static DataContractSerializer CreateSerializer(Type type, IList`1<Type> knownTypes, int maxItems);
    internal static DataContractSerializer CreateSerializer(Type type, string rootName, string rootNs, int maxItems);
    internal static DataContractSerializer CreateSerializer(Type type, IList`1<Type> knownTypes, string rootName, string rootNs, int maxItems);
    internal static DataContractSerializer CreateSerializer(Type type, XmlDictionaryString rootName, XmlDictionaryString rootNs, int maxItems);
    internal static DataContractSerializer CreateSerializer(Type type, IList`1<Type> knownTypes, XmlDictionaryString rootName, XmlDictionaryString rootNs, int maxItems);
}
internal class System.ServiceModel.Dispatcher.DataContractSerializerFaultFormatter : FaultFormatter {
    internal DataContractSerializerFaultFormatter(Type[] detailTypes);
    internal DataContractSerializerFaultFormatter(SynchronizedCollection`1<FaultContractInfo> faultContractInfoCollection);
}
internal class System.ServiceModel.Dispatcher.DataContractSerializerOperationFormatter : OperationFormatter {
    private static Type s_typeOfIQueryable;
    private static Type s_typeOfIQueryableGeneric;
    private static Type s_typeOfIEnumerable;
    private static Type s_typeOfIEnumerableGeneric;
    protected MessageInfo requestMessageInfo;
    protected MessageInfo replyMessageInfo;
    private IList`1<Type> _knownTypes;
    private DataContractSerializerOperationBehavior _serializerFactory;
    public DataContractSerializerOperationFormatter(OperationDescription description, DataContractFormatAttribute dataContractFormatAttribute, DataContractSerializerOperationBehavior serializerFactory);
    private static DataContractSerializerOperationFormatter();
    private MessageInfo CreateMessageInfo(DataContractFormatAttribute dataContractFormatAttribute, MessageDescription messageDescription, DataContractSerializerOperationBehavior serializerFactory);
    private void ValidateDataContractType(Type type);
    private PartInfo CreatePartInfo(MessagePartDescription part, OperationFormatStyle style, DataContractSerializerOperationBehavior serializerFactory);
    protected virtual void AddHeadersToMessage(Message message, MessageDescription messageDescription, Object[] parameters, bool isRequest);
    private void AddMessageHeaderForParameter(MessageHeaders headers, PartInfo headerPart, MessageVersion messageVersion, object parameterValue, bool isXmlElement);
    protected virtual void SerializeBody(XmlDictionaryWriter writer, MessageVersion version, string action, MessageDescription messageDescription, object returnValue, Object[] parameters, bool isRequest);
    private void SerializeParameters(XmlDictionaryWriter writer, PartInfo[] parts, Object[] parameters);
    private void SerializeParameter(XmlDictionaryWriter writer, PartInfo part, object graph);
    private void SerializeParameterPart(XmlDictionaryWriter writer, PartInfo part, object graph);
    protected virtual void GetHeadersFromMessage(Message message, MessageDescription messageDescription, Object[] parameters, bool isRequest);
    private object DeserializeHeaderContents(XmlDictionaryReader reader, MessageDescription messageDescription, MessageHeaderDescription headerDescription);
    protected virtual object DeserializeBody(XmlDictionaryReader reader, MessageVersion version, string action, MessageDescription messageDescription, Object[] parameters, bool isRequest);
    private void DeserializeParameters(XmlDictionaryReader reader, PartInfo[] parts, Object[] parameters, bool isRequest);
    private object DeserializeParameter(XmlDictionaryReader reader, PartInfo part, bool isRequest);
    private object DeserializeParameterPart(XmlDictionaryReader reader, PartInfo part, bool isRequest);
    internal static Type GetSubstituteDataContractType(Type type, Boolean& isQueryable);
}
public class System.ServiceModel.Dispatcher.DispatchOperation : object {
    private string _action;
    private SynchronizedCollection`1<FaultContractInfo> _faultContractInfos;
    private IDispatchMessageFormatter _formatter;
    private IDispatchFaultFormatter _faultFormatter;
    private IOperationInvoker _invoker;
    private bool _isTerminating;
    private bool _isSessionOpenNotificationEnabled;
    private string _name;
    private SynchronizedCollection`1<IParameterInspector> _parameterInspectors;
    private DispatchRuntime _parent;
    private string _replyAction;
    private bool _deserializeRequest;
    private bool _serializeReply;
    private bool _isOneWay;
    private bool _autoDisposeParameters;
    private bool _hasNoDisposableParameters;
    private bool _isFaultFormatterSetExplicit;
    public bool IsOneWay { get; }
    public string Action { get; }
    public SynchronizedCollection`1<FaultContractInfo> FaultContractInfos { get; }
    public bool AutoDisposeParameters { get; public set; }
    internal IDispatchMessageFormatter Formatter { get; internal set; }
    internal IDispatchFaultFormatter FaultFormatter { get; internal set; }
    internal bool IsFaultFormatterSetExplicit { get; }
    internal bool HasNoDisposableParameters { get; internal set; }
    internal IDispatchMessageFormatter InternalFormatter { get; internal set; }
    internal IOperationInvoker InternalInvoker { get; internal set; }
    public IOperationInvoker Invoker { get; public set; }
    public bool IsTerminating { get; public set; }
    internal bool IsSessionOpenNotificationEnabled { get; internal set; }
    public string Name { get; }
    public SynchronizedCollection`1<IParameterInspector> ParameterInspectors { get; }
    public DispatchRuntime Parent { get; }
    public string ReplyAction { get; }
    public bool DeserializeRequest { get; public set; }
    public bool SerializeReply { get; public set; }
    public DispatchOperation(DispatchRuntime parent, string name, string action);
    public DispatchOperation(DispatchRuntime parent, string name, string action, string replyAction);
    public bool get_IsOneWay();
    public string get_Action();
    public SynchronizedCollection`1<FaultContractInfo> get_FaultContractInfos();
    public bool get_AutoDisposeParameters();
    public void set_AutoDisposeParameters(bool value);
    internal IDispatchMessageFormatter get_Formatter();
    internal void set_Formatter(IDispatchMessageFormatter value);
    internal IDispatchFaultFormatter get_FaultFormatter();
    internal void set_FaultFormatter(IDispatchFaultFormatter value);
    internal bool get_IsFaultFormatterSetExplicit();
    internal bool get_HasNoDisposableParameters();
    internal void set_HasNoDisposableParameters(bool value);
    internal IDispatchMessageFormatter get_InternalFormatter();
    internal void set_InternalFormatter(IDispatchMessageFormatter value);
    internal IOperationInvoker get_InternalInvoker();
    internal void set_InternalInvoker(IOperationInvoker value);
    public IOperationInvoker get_Invoker();
    public void set_Invoker(IOperationInvoker value);
    public bool get_IsTerminating();
    public void set_IsTerminating(bool value);
    internal bool get_IsSessionOpenNotificationEnabled();
    internal void set_IsSessionOpenNotificationEnabled(bool value);
    public string get_Name();
    public SynchronizedCollection`1<IParameterInspector> get_ParameterInspectors();
    public DispatchRuntime get_Parent();
    public string get_ReplyAction();
    public bool get_DeserializeRequest();
    public void set_DeserializeRequest(bool value);
    public bool get_SerializeReply();
    public void set_SerializeReply(bool value);
}
internal class System.ServiceModel.Dispatcher.DispatchOperationRuntime : object {
    private static AsyncCallback s_invokeCallback;
    private string _action;
    private IDispatchFaultFormatter _faultFormatter;
    private IDispatchMessageFormatter _formatter;
    private IParameterInspector[] _inspectors;
    private IOperationInvoker _invoker;
    private bool _isTerminating;
    private bool _isSessionOpenNotificationEnabled;
    private string _name;
    private ImmutableDispatchRuntime _parent;
    private string _replyAction;
    private bool _deserializeRequest;
    private bool _serializeReply;
    private bool _isOneWay;
    private bool _disposeParameters;
    internal string Action { get; }
    internal bool DisposeParameters { get; }
    internal IDispatchFaultFormatter FaultFormatter { get; }
    internal IDispatchMessageFormatter Formatter { get; }
    internal IOperationInvoker Invoker { get; }
    internal bool IsOneWay { get; }
    internal bool IsTerminating { get; }
    internal string Name { get; }
    internal IParameterInspector[] ParameterInspectors { get; }
    internal ImmutableDispatchRuntime Parent { get; }
    internal string ReplyAction { get; }
    internal DispatchOperationRuntime(DispatchOperation operation, ImmutableDispatchRuntime parent);
    private static DispatchOperationRuntime();
    internal string get_Action();
    internal bool get_DisposeParameters();
    internal IDispatchFaultFormatter get_FaultFormatter();
    internal IDispatchMessageFormatter get_Formatter();
    internal IOperationInvoker get_Invoker();
    internal bool get_IsOneWay();
    internal bool get_IsTerminating();
    internal string get_Name();
    internal IParameterInspector[] get_ParameterInspectors();
    internal ImmutableDispatchRuntime get_Parent();
    internal string get_ReplyAction();
    private void DeserializeInputs(MessageRpc& rpc);
    private void InspectInputs(MessageRpc& rpc);
    private void InspectInputsCore(MessageRpc& rpc);
    private void InspectOutputs(MessageRpc& rpc);
    private void InspectOutputsCore(MessageRpc& rpc);
    internal void InvokeBegin(MessageRpc& rpc);
    private static void InvokeCallback(IAsyncResult result);
    internal void InvokeEnd(MessageRpc& rpc);
    private void SerializeOutputs(MessageRpc& rpc);
    private void ValidateMustUnderstand(MessageRpc& rpc);
}
public class System.ServiceModel.Dispatcher.DispatchRuntime : object {
    private ConcurrencyMode _concurrencyMode;
    private bool _ensureOrderedDispatch;
    private bool _automaticInputSessionShutdown;
    private ChannelDispatcher _channelDispatcher;
    private EndpointDispatcher _endpointDispatcher;
    private IInstanceProvider _instanceProvider;
    private IInstanceContextProvider _instanceContextProvider;
    private OperationCollection _operations;
    private ClientRuntime _proxyRuntime;
    private ImmutableDispatchRuntime _runtime;
    private SynchronizationContext _synchronizationContext;
    private Type _type;
    private DispatchOperation _unhandled;
    private SharedRuntimeState _shared;
    public IInstanceContextProvider InstanceContextProvider { get; public set; }
    public ConcurrencyMode ConcurrencyMode { get; public set; }
    public bool EnsureOrderedDispatch { get; public set; }
    public bool AutomaticInputSessionShutdown { get; public set; }
    public ChannelDispatcher ChannelDispatcher { get; }
    public ClientRuntime CallbackClientRuntime { get; }
    public EndpointDispatcher EndpointDispatcher { get; }
    public IInstanceProvider InstanceProvider { get; public set; }
    public SynchronizedKeyedCollection`2<string, DispatchOperation> Operations { get; }
    public SynchronizationContext SynchronizationContext { get; public set; }
    public Type Type { get; public set; }
    public DispatchOperation UnhandledDispatchOperation { get; public set; }
    internal bool HasMatchAllOperation { get; }
    internal bool EnableFaults { get; }
    internal bool IsOnServer { get; }
    internal bool ManualAddressing { get; }
    internal int MaxParameterInspectors { get; }
    internal ClientRuntime ClientRuntime { get; }
    internal object ThisLock { get; }
    internal DispatchRuntime(ClientRuntime proxyRuntime, SharedRuntimeState shared);
    private DispatchRuntime(SharedRuntimeState shared);
    public IInstanceContextProvider get_InstanceContextProvider();
    public void set_InstanceContextProvider(IInstanceContextProvider value);
    public ConcurrencyMode get_ConcurrencyMode();
    public void set_ConcurrencyMode(ConcurrencyMode value);
    public bool get_EnsureOrderedDispatch();
    public void set_EnsureOrderedDispatch(bool value);
    public bool get_AutomaticInputSessionShutdown();
    public void set_AutomaticInputSessionShutdown(bool value);
    public ChannelDispatcher get_ChannelDispatcher();
    public ClientRuntime get_CallbackClientRuntime();
    public EndpointDispatcher get_EndpointDispatcher();
    public IInstanceProvider get_InstanceProvider();
    public void set_InstanceProvider(IInstanceProvider value);
    public SynchronizedKeyedCollection`2<string, DispatchOperation> get_Operations();
    public SynchronizationContext get_SynchronizationContext();
    public void set_SynchronizationContext(SynchronizationContext value);
    public Type get_Type();
    public void set_Type(Type value);
    public DispatchOperation get_UnhandledDispatchOperation();
    public void set_UnhandledDispatchOperation(DispatchOperation value);
    internal bool get_HasMatchAllOperation();
    internal bool get_EnableFaults();
    internal bool get_IsOnServer();
    internal bool get_ManualAddressing();
    internal int get_MaxParameterInspectors();
    internal ClientRuntime get_ClientRuntime();
    internal object get_ThisLock();
    internal DispatchOperationRuntime GetOperation(Message& message);
    internal ImmutableDispatchRuntime GetRuntime();
    private ImmutableDispatchRuntime GetRuntimeCore();
    internal void InvalidateRuntime();
    internal void LockDownProperties();
    internal SynchronizedCollection`1<T> NewBehaviorCollection();
}
internal class System.ServiceModel.Dispatcher.DuplexChannelBinder : object {
    private IDuplexChannel _channel;
    private IRequestReplyCorrelator _correlator;
    private TimeSpan _defaultCloseTimeout;
    private TimeSpan _defaultSendTimeout;
    private IdentityVerifier _identityVerifier;
    private bool _isSession;
    private Uri _listenUri;
    private int _pending;
    private bool _syncPumpEnabled;
    private List`1<IDuplexRequest> _requests;
    private List`1<ICorrelatorKey> _timedOutRequests;
    private ChannelHandler _channelHandler;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _requestAborted;
    public IChannel Channel { get; }
    public TimeSpan DefaultCloseTimeout { get; public set; }
    internal ChannelHandler ChannelHandler { get; internal set; }
    public TimeSpan DefaultSendTimeout { get; public set; }
    public bool HasSession { get; }
    internal IdentityVerifier IdentityVerifier { get; internal set; }
    public Uri ListenUri { get; }
    public EndpointAddress LocalAddress { get; }
    private bool Pumping { get; }
    public EndpointAddress RemoteAddress { get; }
    private List`1<IDuplexRequest> Requests { get; }
    private List`1<ICorrelatorKey> TimedOutRequests { get; }
    private object ThisLock { get; }
    internal DuplexChannelBinder(IDuplexChannel channel, IRequestReplyCorrelator correlator);
    internal DuplexChannelBinder(IDuplexChannel channel, IRequestReplyCorrelator correlator, Uri listenUri);
    internal DuplexChannelBinder(IDuplexSessionChannel channel, IRequestReplyCorrelator correlator, Uri listenUri);
    internal DuplexChannelBinder(IDuplexSessionChannel channel, IRequestReplyCorrelator correlator, bool useActiveAutoClose);
    public sealed virtual IChannel get_Channel();
    public TimeSpan get_DefaultCloseTimeout();
    public void set_DefaultCloseTimeout(TimeSpan value);
    internal ChannelHandler get_ChannelHandler();
    internal void set_ChannelHandler(ChannelHandler value);
    public TimeSpan get_DefaultSendTimeout();
    public void set_DefaultSendTimeout(TimeSpan value);
    public sealed virtual bool get_HasSession();
    internal IdentityVerifier get_IdentityVerifier();
    internal void set_IdentityVerifier(IdentityVerifier value);
    public sealed virtual Uri get_ListenUri();
    public sealed virtual EndpointAddress get_LocalAddress();
    private bool get_Pumping();
    public sealed virtual EndpointAddress get_RemoteAddress();
    private List`1<IDuplexRequest> get_Requests();
    private List`1<ICorrelatorKey> get_TimedOutRequests();
    private object get_ThisLock();
    private void OnFaulted(object sender, EventArgs e);
    public sealed virtual void Abort();
    public sealed virtual void CloseAfterFault(TimeSpan timeout);
    private void AbortRequests();
    private TimeoutException GetReceiveTimeoutException(TimeSpan timeout);
    internal bool HandleRequestAsReply(Message message);
    private bool HandleRequestAsReplyCore(Message message);
    public void EnsurePumping();
    public sealed virtual IAsyncResult BeginTryReceive(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual bool EndTryReceive(IAsyncResult result, RequestContext& requestContext);
    public sealed virtual RequestContext CreateRequestContext(Message message);
    public sealed virtual IAsyncResult BeginSend(Message message, TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual void EndSend(IAsyncResult result);
    public sealed virtual void Send(Message message, TimeSpan timeout);
    public sealed virtual IAsyncResult BeginRequest(Message message, TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual Message EndRequest(IAsyncResult result);
    public sealed virtual bool TryReceive(TimeSpan timeout, RequestContext& requestContext);
    public sealed virtual Message Request(Message message, TimeSpan timeout);
    private void RequestStarting(Message message, IDuplexRequest request);
    private void RequestCompleting(IDuplexRequest request);
    private void AddToTimedOutRequestList(ICorrelatorKey request);
    private void RemoveFromTimedOutRequestList(ICorrelatorKey request);
    private void DeleteTimedoutRequestsFromCorrelator();
    private void SendCallback(IAsyncResult result);
    public sealed virtual bool WaitForMessage(TimeSpan timeout);
    public sealed virtual IAsyncResult BeginWaitForMessage(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual bool EndWaitForMessage(IAsyncResult result);
}
internal class System.ServiceModel.Dispatcher.EndpointAddressProcessor : object {
    internal static string XsiNs;
    internal static string SerNs;
    internal static string TypeLN;
    internal static string ItemTypeLN;
    internal static string FactoryTypeLN;
    private static EndpointAddressProcessor();
    internal static string GetComparableForm(StringBuilder builder, XmlReader reader);
    private static void AppendString(StringBuilder builder, string s);
    private static void CompleteValue(StringBuilder builder, int startLength);
}
public class System.ServiceModel.Dispatcher.EndpointDispatcher : object {
    private ChannelDispatcher _channelDispatcher;
    private ServiceChannel _datagramChannel;
    private int _filterPriority;
    private Uri _listenUri;
    private EndpointAddress _originalAddress;
    public ChannelDispatcher ChannelDispatcher { get; }
    public string ContractName { get; }
    public string ContractNamespace { get; }
    internal ServiceChannel DatagramChannel { get; internal set; }
    public DispatchRuntime DispatchRuntime { get; }
    public EndpointAddress EndpointAddress { get; }
    public int FilterPriority { get; public set; }
    public ChannelDispatcher get_ChannelDispatcher();
    public string get_ContractName();
    public string get_ContractNamespace();
    internal ServiceChannel get_DatagramChannel();
    internal void set_DatagramChannel(ServiceChannel value);
    public DispatchRuntime get_DispatchRuntime();
    public EndpointAddress get_EndpointAddress();
    public int get_FilterPriority();
    public void set_FilterPriority(int value);
    internal void Attach(ChannelDispatcher channelDispatcher);
    internal void Detach(ChannelDispatcher channelDispatcher);
}
internal class System.ServiceModel.Dispatcher.EndpointDispatcherTable : object {
    private object _thisLock;
    private static int optimizationThreshold;
    private List`1<EndpointDispatcher> _cachedEndpoints;
    private object ThisLock { get; }
    public EndpointDispatcherTable(object thisLock);
    private object get_ThisLock();
    public void AddEndpoint(EndpointDispatcher endpoint);
    public void RemoveEndpoint(EndpointDispatcher endpoint);
    public EndpointDispatcher Lookup(Message message, Boolean& addressMatched);
}
internal class System.ServiceModel.Dispatcher.ErrorBehavior : object {
    private IErrorHandler[] _handlers;
    private bool _debug;
    private bool _isOnServer;
    private MessageVersion _messageVersion;
    internal ErrorBehavior(ChannelDispatcher channelDispatcher);
    private void InitializeFault(MessageRpc& rpc);
    internal void ProvideMessageFault(MessageRpc& rpc);
    private void ProvideMessageFaultCore(MessageRpc& rpc);
    private void ProvideMessageFaultCoreCoda(MessageRpc& rpc);
    internal void ProvideOnlyFaultOfLastResort(MessageRpc& rpc);
    private void ProvideFaultOfLastResort(Exception error, ErrorHandlerFaultInfo& faultInfo);
    internal void ProvideFault(Exception e, FaultConverter faultConverter, ErrorHandlerFaultInfo& faultInfo);
    private void ProvideWellKnownFault(Exception e, FaultConverter faultConverter, ErrorHandlerFaultInfo& faultInfo);
    internal void HandleError(MessageRpc& rpc);
    private void HandleErrorCore(MessageRpc& rpc);
    private bool HandleErrorCommon(Exception error, ErrorHandlerFaultInfo& faultInfo);
    internal bool HandleError(Exception error);
    internal bool HandleError(Exception error, ErrorHandlerFaultInfo& faultInfo);
    internal static bool ShouldRethrowClientSideExceptionAsIs(Exception e);
    internal static void ThrowAndCatch(Exception e, Message message);
    internal static void ThrowAndCatch(Exception e);
}
internal class System.ServiceModel.Dispatcher.ErrorHandlerFaultInfo : ValueType {
    private Message _fault;
    private bool _isConsideredUnhandled;
    private string _defaultFaultAction;
    public Message Fault { get; public set; }
    public string DefaultFaultAction { get; public set; }
    public bool IsConsideredUnhandled { get; public set; }
    public ErrorHandlerFaultInfo(string defaultFaultAction);
    public Message get_Fault();
    public void set_Fault(Message value);
    public string get_DefaultFaultAction();
    public void set_DefaultFaultAction(string value);
    public bool get_IsConsideredUnhandled();
    public void set_IsConsideredUnhandled(bool value);
}
internal class System.ServiceModel.Dispatcher.ErrorHandlingReceiver : object {
    private ChannelDispatcher _dispatcher;
    private IChannelBinder _binder;
    internal ErrorHandlingReceiver(IChannelBinder binder, ChannelDispatcher dispatcher);
    internal void Close();
    private void HandleError(Exception e);
    private void HandleErrorOrAbort(Exception e);
    internal bool TryReceive(TimeSpan timeout, RequestContext& requestContext);
    internal IAsyncResult BeginTryReceive(TimeSpan timeout, AsyncCallback callback, object state);
    internal bool EndTryReceive(IAsyncResult result, RequestContext& requestContext);
}
public class System.ServiceModel.Dispatcher.FaultContractInfo : object {
    private string _action;
    private Type _detail;
    private string _elementName;
    private string _ns;
    private IList`1<Type> _knownTypes;
    private DataContractSerializer _serializer;
    public string Action { get; }
    public Type Detail { get; }
    internal string ElementName { get; }
    internal string ElementNamespace { get; }
    internal IList`1<Type> KnownTypes { get; }
    internal DataContractSerializer Serializer { get; }
    public FaultContractInfo(string action, Type detail);
    internal FaultContractInfo(string action, Type detail, XmlName elementName, string ns, IList`1<Type> knownTypes);
    public string get_Action();
    public Type get_Detail();
    internal string get_ElementName();
    internal string get_ElementNamespace();
    internal IList`1<Type> get_KnownTypes();
    internal DataContractSerializer get_Serializer();
}
public class System.ServiceModel.Dispatcher.FaultFormatter : object {
    private FaultContractInfo[] _faultContractInfos;
    internal FaultFormatter(Type[] detailTypes);
    internal FaultFormatter(SynchronizedCollection`1<FaultContractInfo> faultContractInfoCollection);
    public sealed virtual MessageFault Serialize(FaultException faultException, String& action);
    public sealed virtual FaultException Deserialize(MessageFault messageFault, string action);
    protected virtual XmlObjectSerializer GetSerializer(Type detailType, string faultExceptionAction, String& action);
    protected virtual FaultException CreateFaultException(MessageFault messageFault, string action);
    protected FaultException CreateFaultException(MessageFault messageFault, string action, object detailObj, Type detailType, XmlDictionaryReader detailReader);
    private static FaultContractInfo[] GetSortedArray(List`1<FaultContractInfo> faultContractInfoList);
    private static void AddInfrastructureFaults(List`1<FaultContractInfo> faultContractInfos);
    private static MessageFault CreateMessageFault(XmlObjectSerializer serializer, FaultException faultException, Type detailType);
}
internal interface System.ServiceModel.Dispatcher.IChannelBinder {
    public IChannel Channel { get; }
    public bool HasSession { get; }
    public Uri ListenUri { get; }
    public EndpointAddress LocalAddress { get; }
    public EndpointAddress RemoteAddress { get; }
    public abstract virtual IChannel get_Channel();
    public abstract virtual bool get_HasSession();
    public abstract virtual Uri get_ListenUri();
    public abstract virtual EndpointAddress get_LocalAddress();
    public abstract virtual EndpointAddress get_RemoteAddress();
    public abstract virtual void Abort();
    public abstract virtual void CloseAfterFault(TimeSpan timeout);
    public abstract virtual bool TryReceive(TimeSpan timeout, RequestContext& requestContext);
    public abstract virtual IAsyncResult BeginTryReceive(TimeSpan timeout, AsyncCallback callback, object state);
    public abstract virtual bool EndTryReceive(IAsyncResult result, RequestContext& requestContext);
    public abstract virtual void Send(Message message, TimeSpan timeout);
    public abstract virtual IAsyncResult BeginSend(Message message, TimeSpan timeout, AsyncCallback callback, object state);
    public abstract virtual void EndSend(IAsyncResult result);
    public abstract virtual Message Request(Message message, TimeSpan timeout);
    public abstract virtual IAsyncResult BeginRequest(Message message, TimeSpan timeout, AsyncCallback callback, object state);
    public abstract virtual Message EndRequest(IAsyncResult result);
    public abstract virtual bool WaitForMessage(TimeSpan timeout);
    public abstract virtual IAsyncResult BeginWaitForMessage(TimeSpan timeout, AsyncCallback callback, object state);
    public abstract virtual bool EndWaitForMessage(IAsyncResult result);
    public abstract virtual RequestContext CreateRequestContext(Message message);
}
public interface System.ServiceModel.Dispatcher.IChannelInitializer {
    public abstract virtual void Initialize(IClientChannel channel);
}
internal interface System.ServiceModel.Dispatcher.IClientFaultFormatter {
    public abstract virtual FaultException Deserialize(MessageFault messageFault, string action);
}
public interface System.ServiceModel.Dispatcher.IClientMessageFormatter {
    public abstract virtual Message SerializeRequest(MessageVersion messageVersion, Object[] parameters);
    public abstract virtual object DeserializeReply(Message message, Object[] parameters);
}
public interface System.ServiceModel.Dispatcher.IClientMessageInspector {
    public abstract virtual object BeforeSendRequest(Message& request, IClientChannel channel);
    public abstract virtual void AfterReceiveReply(Message& reply, object correlationState);
}
public interface System.ServiceModel.Dispatcher.IClientOperationSelector {
    public bool AreParametersRequiredForSelection { get; }
    public abstract virtual bool get_AreParametersRequiredForSelection();
    public abstract virtual string SelectOperation(MethodBase method, Object[] parameters);
}
internal interface System.ServiceModel.Dispatcher.IDispatchFaultFormatter {
    public abstract virtual MessageFault Serialize(FaultException faultException, String& action);
}
internal interface System.ServiceModel.Dispatcher.IDispatchMessageFormatter {
    public abstract virtual void DeserializeRequest(Message message, Object[] parameters);
    public abstract virtual Message SerializeReply(MessageVersion messageVersion, Object[] parameters, object result);
}
public interface System.ServiceModel.Dispatcher.IErrorHandler {
    public abstract virtual void ProvideFault(Exception error, MessageVersion version, Message& fault);
    public abstract virtual bool HandleError(Exception error);
}
public interface System.ServiceModel.Dispatcher.IInstanceContextProvider {
    public abstract virtual InstanceContext GetExistingInstanceContext(Message message, IContextChannel channel);
}
public interface System.ServiceModel.Dispatcher.IInstanceProvider {
    public abstract virtual object GetInstance(InstanceContext instanceContext);
    public abstract virtual object GetInstance(InstanceContext instanceContext, Message message);
    public abstract virtual void ReleaseInstance(InstanceContext instanceContext, object instance);
}
public interface System.ServiceModel.Dispatcher.IInteractiveChannelInitializer {
    public abstract virtual IAsyncResult BeginDisplayInitializationUI(IClientChannel channel, AsyncCallback callback, object state);
    public abstract virtual void EndDisplayInitializationUI(IAsyncResult result);
}
internal interface System.ServiceModel.Dispatcher.IInvokeReceivedNotification {
    public abstract virtual void NotifyInvokeReceived();
    public abstract virtual void NotifyInvokeReceived(RequestContext request);
}
internal interface System.ServiceModel.Dispatcher.IListenerBinder {
    public IChannelListener Listener { get; }
    public MessageVersion MessageVersion { get; }
    public abstract virtual IChannelListener get_Listener();
    public abstract virtual MessageVersion get_MessageVersion();
    public abstract virtual IChannelBinder Accept(TimeSpan timeout);
    public abstract virtual IAsyncResult BeginAccept(TimeSpan timeout, AsyncCallback callback, object state);
    public abstract virtual IChannelBinder EndAccept(IAsyncResult result);
}
internal class System.ServiceModel.Dispatcher.ImmutableClientRuntime : object {
    private int _correlationCount;
    private bool _addTransactionFlowProperties;
    private IInteractiveChannelInitializer[] _interactiveChannelInitializers;
    private IClientOperationSelector _operationSelector;
    private IChannelInitializer[] _channelInitializers;
    private IClientMessageInspector[] _messageInspectors;
    private Dictionary`2<string, ProxyOperationRuntime> _operations;
    private ProxyOperationRuntime _unhandled;
    private bool _useSynchronizationContext;
    private bool _validateMustUnderstand;
    internal int MessageInspectorCorrelationOffset { get; }
    internal int ParameterInspectorCorrelationOffset { get; }
    internal int CorrelationCount { get; }
    internal IClientOperationSelector OperationSelector { get; }
    internal ProxyOperationRuntime UnhandledProxyOperation { get; }
    internal bool UseSynchronizationContext { get; }
    internal bool ValidateMustUnderstand { get; internal set; }
    internal ImmutableClientRuntime(ClientRuntime behavior);
    internal int get_MessageInspectorCorrelationOffset();
    internal int get_ParameterInspectorCorrelationOffset();
    internal int get_CorrelationCount();
    internal IClientOperationSelector get_OperationSelector();
    internal ProxyOperationRuntime get_UnhandledProxyOperation();
    internal bool get_UseSynchronizationContext();
    internal bool get_ValidateMustUnderstand();
    internal void set_ValidateMustUnderstand(bool value);
    internal void AfterReceiveReply(ProxyRpc& rpc);
    internal void BeforeSendRequest(ProxyRpc& rpc);
    internal void DisplayInitializationUI(ServiceChannel channel);
    internal IAsyncResult BeginDisplayInitializationUI(ServiceChannel channel, AsyncCallback callback, object state);
    internal void EndDisplayInitializationUI(IAsyncResult result);
    internal void InitializeChannel(IClientChannel channel);
    internal ProxyOperationRuntime GetOperation(MethodBase methodBase, Object[] args, Boolean& canCacheResult);
    internal ProxyOperationRuntime GetOperationByName(string operationName);
}
internal class System.ServiceModel.Dispatcher.ImmutableCommunicationTimeouts : object {
    private TimeSpan _close;
    private TimeSpan _open;
    private TimeSpan _receive;
    private TimeSpan _send;
    private TimeSpan System.ServiceModel.IDefaultCommunicationTimeouts.CloseTimeout { get; }
    private TimeSpan System.ServiceModel.IDefaultCommunicationTimeouts.OpenTimeout { get; }
    private TimeSpan System.ServiceModel.IDefaultCommunicationTimeouts.ReceiveTimeout { get; }
    private TimeSpan System.ServiceModel.IDefaultCommunicationTimeouts.SendTimeout { get; }
    internal ImmutableCommunicationTimeouts(IDefaultCommunicationTimeouts timeouts);
    private sealed virtual override TimeSpan System.ServiceModel.IDefaultCommunicationTimeouts.get_CloseTimeout();
    private sealed virtual override TimeSpan System.ServiceModel.IDefaultCommunicationTimeouts.get_OpenTimeout();
    private sealed virtual override TimeSpan System.ServiceModel.IDefaultCommunicationTimeouts.get_ReceiveTimeout();
    private sealed virtual override TimeSpan System.ServiceModel.IDefaultCommunicationTimeouts.get_SendTimeout();
}
internal class System.ServiceModel.Dispatcher.ImmutableDispatchRuntime : object {
    private int _correlationCount;
    private ConcurrencyBehavior _concurrency;
    private IDemuxer _demuxer;
    private ErrorBehavior _error;
    private bool _enableFaults;
    private InstanceBehavior _instance;
    private bool _manualAddressing;
    private TerminatingOperationBehavior _terminate;
    private ThreadBehavior _thread;
    private bool _validateMustUnderstand;
    private bool _sendAsynchronously;
    private MessageRpcProcessor _processMessage1;
    private MessageRpcProcessor _processMessage11;
    private MessageRpcProcessor _processMessage2;
    private MessageRpcProcessor _processMessage3;
    private MessageRpcProcessor _processMessage31;
    private MessageRpcProcessor _processMessage4;
    private MessageRpcProcessor _processMessage41;
    private MessageRpcProcessor _processMessage5;
    private MessageRpcProcessor _processMessage6;
    private MessageRpcProcessor _processMessage7;
    private MessageRpcProcessor _processMessage8;
    private MessageRpcProcessor _processMessage9;
    private MessageRpcProcessor _processMessageCleanup;
    private MessageRpcProcessor _processMessageCleanupError;
    private static AsyncCallback s_onReplyCompleted;
    internal int CorrelationCount { get; }
    internal bool EnableFaults { get; }
    internal bool ManualAddressing { get; }
    internal bool ValidateMustUnderstand { get; }
    internal ImmutableDispatchRuntime(DispatchRuntime dispatch);
    private static ImmutableDispatchRuntime();
    internal int get_CorrelationCount();
    internal bool get_EnableFaults();
    internal bool get_ManualAddressing();
    internal bool get_ValidateMustUnderstand();
    internal void AfterReceiveRequest(MessageRpc& rpc);
    private void Reply(MessageRpc& rpc);
    private void BeginReply(MessageRpc& rpc);
    internal bool Dispatch(MessageRpc& rpc, bool isOperationContextSet);
    private bool EndReply(MessageRpc& rpc);
    private void SetActivityIdOnThread(MessageRpc& rpc);
    private void TransferChannelFromPendingList(MessageRpc& rpc);
    private void AddMessageProperties(Message message, OperationContext context, ServiceChannel replyChannel);
    private static void OnReplyCompletedCallback(IAsyncResult result);
    private void PrepareReply(MessageRpc& rpc);
    private bool PrepareAndAddressReply(MessageRpc& rpc);
    internal DispatchOperationRuntime GetOperation(Message& message);
    internal bool IsConcurrent(MessageRpc& rpc);
    internal void ProcessMessage1(MessageRpc& rpc);
    internal void ProcessMessage11(MessageRpc& rpc);
    private void ProcessMessage2(MessageRpc& rpc);
    private void ProcessMessage3(MessageRpc& rpc);
    private void ProcessMessage31(MessageRpc& rpc);
    private void ProcessMessage4(MessageRpc& rpc);
    private void ProcessMessage41(MessageRpc& rpc);
    private void ProcessMessage5(MessageRpc& rpc);
    private void ProcessMessage6(MessageRpc& rpc);
    private void ProcessMessage7(MessageRpc& rpc);
    private void ProcessMessage8(MessageRpc& rpc);
    private void ProcessMessage9(MessageRpc& rpc);
    private void ProcessMessageCleanup(MessageRpc& rpc);
    private void ProcessMessageCleanupError(MessageRpc& rpc);
}
internal class System.ServiceModel.Dispatcher.InputChannelBinder : object {
    private IInputChannel _channel;
    private Uri _listenUri;
    public IChannel Channel { get; }
    public bool HasSession { get; }
    public Uri ListenUri { get; }
    public EndpointAddress LocalAddress { get; }
    public EndpointAddress RemoteAddress { get; }
    internal InputChannelBinder(IInputChannel channel, Uri listenUri);
    public sealed virtual IChannel get_Channel();
    public sealed virtual bool get_HasSession();
    public sealed virtual Uri get_ListenUri();
    public sealed virtual EndpointAddress get_LocalAddress();
    public sealed virtual EndpointAddress get_RemoteAddress();
    public sealed virtual void Abort();
    public sealed virtual void CloseAfterFault(TimeSpan timeout);
    public sealed virtual IAsyncResult BeginTryReceive(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual bool EndTryReceive(IAsyncResult result, RequestContext& requestContext);
    public sealed virtual RequestContext CreateRequestContext(Message message);
    public sealed virtual IAsyncResult BeginSend(Message message, TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual void EndSend(IAsyncResult result);
    public sealed virtual void Send(Message message, TimeSpan timeout);
    public sealed virtual bool TryReceive(TimeSpan timeout, RequestContext& requestContext);
    public sealed virtual IAsyncResult BeginRequest(Message message, TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual Message EndRequest(IAsyncResult result);
    public sealed virtual Message Request(Message message, TimeSpan timeout);
    public sealed virtual bool WaitForMessage(TimeSpan timeout);
    public sealed virtual IAsyncResult BeginWaitForMessage(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual bool EndWaitForMessage(IAsyncResult result);
    private RequestContext WrapMessage(Message message);
}
public class System.ServiceModel.Dispatcher.InstanceBehavior : object {
    private IInstanceContextProvider _instanceContextProvider;
    private IInstanceProvider _provider;
    internal IInstanceContextProvider InstanceContextProvider { get; }
    internal InstanceBehavior(DispatchRuntime dispatch, ImmutableDispatchRuntime immutableRuntime);
    internal IInstanceContextProvider get_InstanceContextProvider();
    internal void AfterReply(MessageRpc& rpc, ErrorBehavior error);
    internal void EnsureInstanceContext(MessageRpc& rpc);
    internal object GetInstance(InstanceContext instanceContext);
    internal object GetInstance(InstanceContext instanceContext, Message request);
    internal void EnsureServiceInstance(MessageRpc& rpc);
}
internal abstract class System.ServiceModel.Dispatcher.InstanceContextProviderBase : object {
    private DispatchRuntime _dispatchRuntime;
    internal InstanceContextProviderBase(DispatchRuntime dispatchRuntime);
    internal static bool IsProviderSingleton(IInstanceContextProvider provider);
    internal static bool IsProviderSessionful(IInstanceContextProvider provider);
    internal static IInstanceContextProvider GetProviderForMode(InstanceContextMode instanceMode, DispatchRuntime runtime);
    public abstract virtual InstanceContext GetExistingInstanceContext(Message message, IContextChannel channel);
    internal ServiceChannel GetServiceChannelFromProxy(IContextChannel channel);
}
internal abstract class System.ServiceModel.Dispatcher.InvalidBodyAccessException : Exception {
    protected InvalidBodyAccessException(string message);
    protected InvalidBodyAccessException(string message, Exception innerException);
    protected InvalidBodyAccessException(SerializationInfo info, StreamingContext context);
}
internal class System.ServiceModel.Dispatcher.InvokeDelegate : MulticastDelegate {
    public InvokeDelegate(object object, IntPtr method);
    public virtual object Invoke(object target, Object[] inputs, Object[] outputs);
    public virtual IAsyncResult BeginInvoke(object target, Object[] inputs, Object[] outputs, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
internal class System.ServiceModel.Dispatcher.InvokerUtil : object {
    private CriticalHelper _helper;
    internal InvokeDelegate GenerateInvokeDelegate(MethodInfo method, Int32& inputParameterCount, Int32& outputParameterCount);
}
public interface System.ServiceModel.Dispatcher.IOperationInvoker {
    public abstract virtual Object[] AllocateInputs();
    public abstract virtual IAsyncResult InvokeBegin(object instance, Object[] inputs, AsyncCallback callback, object state);
    public abstract virtual object InvokeEnd(object instance, Object[]& outputs, IAsyncResult result);
}
public interface System.ServiceModel.Dispatcher.IParameterInspector {
    public abstract virtual object BeforeCall(string operationName, Object[] inputs);
    public abstract virtual void AfterCall(string operationName, Object[] outputs, object returnValue, object correlationState);
}
internal interface System.ServiceModel.Dispatcher.IResumeMessageRpc {
    public abstract virtual InstanceContext GetMessageInstanceContext();
    public abstract virtual void Resume();
    public abstract virtual void Resume(Boolean& alreadyResumedNoLock);
    public abstract virtual void Resume(IAsyncResult result);
    public abstract virtual void Resume(object instance);
    public abstract virtual void SignalConditionalResume(IAsyncResult result);
}
internal static class System.ServiceModel.Dispatcher.ListenerBinder : object {
    internal static IListenerBinder GetBinder(IChannelListener listener, MessageVersion messageVersion);
}
internal class System.ServiceModel.Dispatcher.ListenerChannel : object {
    private IChannelBinder _binder;
    public IChannelBinder Binder { get; }
    public ListenerChannel(IChannelBinder binder);
    public IChannelBinder get_Binder();
}
internal class System.ServiceModel.Dispatcher.ListenerHandler : CommunicationObject {
    private static Action`1<object> s_initiateChannelPump;
    private static AsyncCallback s_waitCallback;
    private ChannelDispatcher _channelDispatcher;
    private ListenerChannel _channel;
    private SessionIdleManager _idleManager;
    private bool _acceptedNull;
    private bool _doneAccepting;
    private EndpointDispatcherTable _endpoints;
    private IListenerBinder _listenerBinder;
    private IDefaultCommunicationTimeouts _timeouts;
    internal ChannelDispatcher ChannelDispatcher { get; }
    internal ListenerChannel Channel { get; }
    protected TimeSpan DefaultCloseTimeout { get; }
    protected TimeSpan DefaultOpenTimeout { get; }
    internal EndpointDispatcherTable Endpoints { get; internal set; }
    internal object ThisLock { get; }
    internal ListenerHandler(IListenerBinder listenerBinder, ChannelDispatcher channelDispatcher, IDefaultCommunicationTimeouts timeouts);
    private static ListenerHandler();
    internal ChannelDispatcher get_ChannelDispatcher();
    internal ListenerChannel get_Channel();
    protected virtual TimeSpan get_DefaultCloseTimeout();
    protected virtual TimeSpan get_DefaultOpenTimeout();
    internal EndpointDispatcherTable get_Endpoints();
    internal void set_Endpoints(EndpointDispatcherTable value);
    internal object get_ThisLock();
    protected internal virtual Task OnCloseAsync(TimeSpan timeout);
    protected internal virtual Task OnOpenAsync(TimeSpan timeout);
    protected virtual void OnOpen(TimeSpan timeout);
    protected virtual IAsyncResult OnBeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndOpen(IAsyncResult result);
    protected virtual void OnOpened();
    internal void NewChannelPump();
    private static void InitiateChannelPump(object state);
    private void ChannelPump();
    private static void WaitCallback(IAsyncResult result);
    private void AbortChannels();
    private void CloseChannel(IChannel channel, TimeSpan timeout);
    private static void CloseChannelCallback(IAsyncResult result);
    public void CloseInput(TimeSpan timeout);
    private static void CloseOutputSessionCallback(IAsyncResult result);
    private void CloseChannels(TimeSpan timeout);
    private void Dispatch();
    private void AcceptedNull();
    private void DoneAccepting();
    private bool IsSessionChannel(IChannel channel);
    private void CancelPendingIdleManager();
    protected virtual void OnAbort();
    protected virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnClose(TimeSpan timeout);
    protected virtual void OnEndClose(IAsyncResult result);
    private bool HandleError(Exception e);
}
internal class System.ServiceModel.Dispatcher.MessageOperationFormatter : object {
    private static MessageOperationFormatter s_instance;
    internal static MessageOperationFormatter Instance { get; }
    internal static MessageOperationFormatter get_Instance();
    public sealed virtual object DeserializeReply(Message message, Object[] parameters);
    public sealed virtual void DeserializeRequest(Message message, Object[] parameters);
    public sealed virtual Message SerializeReply(MessageVersion messageVersion, Object[] parameters, object result);
    public sealed virtual Message SerializeRequest(MessageVersion messageVersion, Object[] parameters);
}
internal class System.ServiceModel.Dispatcher.MessageRpc : ValueType {
    internal ServiceChannel Channel;
    internal ChannelHandler channelHandler;
    internal Object[] Correlation;
    internal OperationContext OperationContext;
    internal ServiceModelActivity Activity;
    internal Guid ResponseActivityId;
    internal IAsyncResult AsyncResult;
    internal bool CanSendReply;
    internal bool SuccessfullySendReply;
    internal Object[] InputParameters;
    internal Object[] OutputParameters;
    internal object ReturnParameter;
    internal bool ParametersDisposed;
    internal bool DidDeserializeRequestBody;
    internal Exception Error;
    internal MessageRpcProcessor ErrorProcessor;
    internal ErrorHandlerFaultInfo FaultInfo;
    internal bool HasSecurityContext;
    internal object Instance;
    internal bool MessageRpcOwnsInstanceContextThrottle;
    internal MessageRpcProcessor NextProcessor;
    internal Collection`1<MessageHeaderInfo> NotUnderstoodHeaders;
    internal DispatchOperationRuntime Operation;
    internal Message Request;
    internal RequestContext RequestContext;
    internal bool RequestContextThrewOnReply;
    internal UniqueId RequestID;
    internal Message Reply;
    internal TimeoutHelper ReplyTimeoutHelper;
    internal ReplyToInfo ReplyToInfo;
    internal MessageVersion RequestVersion;
    internal ServiceSecurityContext SecurityContext;
    internal InstanceContext InstanceContext;
    internal bool SuccessfullyBoundInstance;
    internal bool SuccessfullyIncrementedActivity;
    internal bool SuccessfullyLockedInstance;
    internal MessageRpcInvokeNotification InvokeNotification;
    internal EventTraceActivity EventTraceActivity;
    private bool _paused;
    private bool _switchedThreads;
    private bool _isInstanceContextSingleton;
    private SignalGate`1<IAsyncResult> _invokeContinueGate;
    internal bool IsPaused { get; }
    internal bool SwitchedThreads { get; }
    internal MessageRpc(RequestContext requestContext, Message request, DispatchOperationRuntime operation, ServiceChannel channel, ChannelHandler channelHandler, bool cleanThread, OperationContext operationContext, InstanceContext instanceContext, EventTraceActivity eventTraceActivity);
    internal bool get_IsPaused();
    internal bool get_SwitchedThreads();
    internal void Abort();
    private void AbortRequestContext(RequestContext requestContext);
    internal void AbortRequestContext();
    private void TraceCallDurationInDispatcherIfNecessary(bool requestContextWasClosedSuccessfully);
    internal void CloseRequestContext();
    private void DisposeRequestContext(RequestContext context);
    internal void AbortChannel();
    internal void CloseChannel();
    internal void AbortInstanceContext();
    internal void EnsureReceive();
    private bool ProcessError(Exception e);
    internal void DisposeParameters(bool excludeInput);
    internal void DisposeParametersCore(bool excludeInput);
    private void DisposeParameterList(Object[] parameters);
    internal IResumeMessageRpc Pause();
    [SecuritySafeCriticalAttribute]
internal bool Process(bool isOperationContextSet);
    internal void UnPause();
    internal bool UnlockInvokeContinueGate(IAsyncResult& result);
    internal void PrepareInvokeContinueGate();
    private void IncrementBusyCount();
    private void DecrementBusyCount();
}
internal class System.ServiceModel.Dispatcher.MessageRpcInvokeNotification : object {
    private ServiceModelActivity _activity;
    private ChannelHandler _handler;
    [CompilerGeneratedAttribute]
private bool <DidInvokerEnsurePump>k__BackingField;
    public bool DidInvokerEnsurePump { get; public set; }
    public MessageRpcInvokeNotification(ServiceModelActivity activity, ChannelHandler handler);
    [CompilerGeneratedAttribute]
public bool get_DidInvokerEnsurePump();
    [CompilerGeneratedAttribute]
public void set_DidInvokerEnsurePump(bool value);
    public sealed virtual void NotifyInvokeReceived();
    public sealed virtual void NotifyInvokeReceived(RequestContext request);
}
internal class System.ServiceModel.Dispatcher.MessageRpcProcessor : MulticastDelegate {
    public MessageRpcProcessor(object object, IntPtr method);
    public virtual void Invoke(MessageRpc& rpc);
    public virtual IAsyncResult BeginInvoke(MessageRpc& rpc, AsyncCallback callback, object object);
    public virtual void EndInvoke(MessageRpc& rpc, IAsyncResult result);
}
internal class System.ServiceModel.Dispatcher.NetDispatcherFaultException : FaultException {
    public NetDispatcherFaultException(string reason, FaultCode code, Exception innerException);
    public NetDispatcherFaultException(FaultReason reason, FaultCode code, Exception innerException);
}
internal abstract class System.ServiceModel.Dispatcher.OperationFormatter : object {
    private MessageDescription _replyDescription;
    private MessageDescription _requestDescription;
    private XmlDictionaryString _action;
    private XmlDictionaryString _replyAction;
    protected StreamFormatter requestStreamFormatter;
    protected StreamFormatter replyStreamFormatter;
    private XmlDictionary _dictionary;
    private string _operationName;
    internal string RequestAction { get; }
    internal string ReplyAction { get; }
    protected XmlDictionary Dictionary { get; }
    protected string OperationName { get; }
    protected MessageDescription ReplyDescription { get; }
    protected MessageDescription RequestDescription { get; }
    public OperationFormatter(OperationDescription description, bool isRpc, bool isEncoded);
    protected abstract virtual void AddHeadersToMessage(Message message, MessageDescription messageDescription, Object[] parameters, bool isRequest);
    protected abstract virtual void SerializeBody(XmlDictionaryWriter writer, MessageVersion version, string action, MessageDescription messageDescription, object returnValue, Object[] parameters, bool isRequest);
    protected virtual Task SerializeBodyAsync(XmlDictionaryWriter writer, MessageVersion version, string action, MessageDescription messageDescription, object returnValue, Object[] parameters, bool isRequest);
    protected abstract virtual void GetHeadersFromMessage(Message message, MessageDescription messageDescription, Object[] parameters, bool isRequest);
    protected abstract virtual object DeserializeBody(XmlDictionaryReader reader, MessageVersion version, string action, MessageDescription messageDescription, Object[] parameters, bool isRequest);
    protected virtual void WriteBodyAttributes(XmlDictionaryWriter writer, MessageVersion messageVersion);
    internal string get_RequestAction();
    internal string get_ReplyAction();
    protected XmlDictionary get_Dictionary();
    protected string get_OperationName();
    protected MessageDescription get_ReplyDescription();
    protected MessageDescription get_RequestDescription();
    protected XmlDictionaryString AddToDictionary(string s);
    public sealed virtual object DeserializeReply(Message message, Object[] parameters);
    private static object CreateTypedMessageInstance(Type messageContractType);
    public sealed virtual void DeserializeRequest(Message message, Object[] parameters);
    private object DeserializeBodyContents(Message message, Object[] parameters, bool isRequest);
    public sealed virtual Message SerializeRequest(MessageVersion messageVersion, Object[] parameters);
    public sealed virtual Message SerializeReply(MessageVersion messageVersion, Object[] parameters, object result);
    private void SetupStreamAndMessageDescription(bool isRequest, StreamFormatter& streamFormatter, MessageDescription& messageDescription);
    private void SerializeBodyContents(XmlDictionaryWriter writer, MessageVersion version, Object[] parameters, object returnValue, bool isRequest);
    [AsyncStateMachineAttribute("System.ServiceModel.Dispatcher.OperationFormatter/<SerializeBodyContentsAsync>d__36")]
private Task SerializeBodyContentsAsync(XmlDictionaryWriter writer, MessageVersion version, Object[] parameters, object returnValue, bool isRequest);
    private IAsyncResult BeginSerializeBodyContents(XmlDictionaryWriter writer, MessageVersion version, Object[] parameters, object returnValue, bool isRequest, AsyncCallback callback, object state);
    private void EndSerializeBodyContents(IAsyncResult result);
    private void AddPropertiesToMessage(Message message, MessageDescription messageDescription, Object[] parameters);
    private void AddPropertiesToMessageCore(Message message, MessageDescription messageDescription, Object[] parameters);
    private void GetPropertiesFromMessage(Message message, MessageDescription messageDescription, Object[] parameters);
    private void GetPropertiesFromMessageCore(Message message, MessageDescription messageDescription, Object[] parameters);
    internal static object GetContentOfMessageHeaderOfT(MessageHeaderDescription headerDescription, object parameterValue, Boolean& mustUnderstand, Boolean& relay, String& actor);
    internal static bool IsValidReturnValue(MessagePartDescription returnValue);
    internal static XmlDictionaryString AddToDictionary(XmlDictionary dictionary, string s);
    internal static void Validate(OperationDescription operation, bool isRpc, bool isEncoded);
    internal static void GetActions(OperationDescription description, XmlDictionary dictionary, XmlDictionaryString& action, XmlDictionaryString& replyAction);
    internal static NetDispatcherFaultException CreateDeserializationFailedFault(string reason, Exception innerException);
    internal static void TraceAndSkipElement(XmlReader xmlReader);
}
public class System.ServiceModel.Dispatcher.OperationInvokerBehavior : object {
    private sealed virtual override void System.ServiceModel.Description.IOperationBehavior.Validate(OperationDescription description);
    private sealed virtual override void System.ServiceModel.Description.IOperationBehavior.AddBindingParameters(OperationDescription description, BindingParameterCollection parameters);
    private sealed virtual override void System.ServiceModel.Description.IOperationBehavior.ApplyDispatchBehavior(OperationDescription description, DispatchOperation dispatch);
    private sealed virtual override void System.ServiceModel.Description.IOperationBehavior.ApplyClientBehavior(OperationDescription description, ClientOperation proxy);
}
internal class System.ServiceModel.Dispatcher.OperationSelectorBehavior : object {
    private sealed virtual override void System.ServiceModel.Description.IContractBehavior.Validate(ContractDescription description, ServiceEndpoint endpoint);
    private sealed virtual override void System.ServiceModel.Description.IContractBehavior.AddBindingParameters(ContractDescription description, ServiceEndpoint endpoint, BindingParameterCollection parameters);
    private sealed virtual override void System.ServiceModel.Description.IContractBehavior.ApplyDispatchBehavior(ContractDescription description, ServiceEndpoint endpoint, DispatchRuntime dispatch);
    private sealed virtual override void System.ServiceModel.Description.IContractBehavior.ApplyClientBehavior(ContractDescription description, ServiceEndpoint endpoint, ClientRuntime proxy);
}
internal class System.ServiceModel.Dispatcher.OutputChannelBinder : object {
    private IOutputChannel _channel;
    public IChannel Channel { get; }
    public bool HasSession { get; }
    public Uri ListenUri { get; }
    public EndpointAddress LocalAddress { get; }
    public EndpointAddress RemoteAddress { get; }
    internal OutputChannelBinder(IOutputChannel channel);
    public sealed virtual IChannel get_Channel();
    public sealed virtual bool get_HasSession();
    public sealed virtual Uri get_ListenUri();
    public sealed virtual EndpointAddress get_LocalAddress();
    public sealed virtual EndpointAddress get_RemoteAddress();
    public sealed virtual void Abort();
    public sealed virtual void CloseAfterFault(TimeSpan timeout);
    public sealed virtual IAsyncResult BeginTryReceive(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual bool EndTryReceive(IAsyncResult result, RequestContext& requestContext);
    public sealed virtual RequestContext CreateRequestContext(Message message);
    public sealed virtual IAsyncResult BeginSend(Message message, TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual void EndSend(IAsyncResult result);
    public sealed virtual void Send(Message message, TimeSpan timeout);
    public sealed virtual IAsyncResult BeginRequest(Message message, TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual Message EndRequest(IAsyncResult result);
    public sealed virtual bool TryReceive(TimeSpan timeout, RequestContext& requestContext);
    public sealed virtual Message Request(Message message, TimeSpan timeout);
    public sealed virtual bool WaitForMessage(TimeSpan timeout);
    public sealed virtual IAsyncResult BeginWaitForMessage(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual bool EndWaitForMessage(IAsyncResult result);
}
internal class System.ServiceModel.Dispatcher.PerSessionInstanceContextProvider : InstanceContextProviderBase {
    internal PerSessionInstanceContextProvider(DispatchRuntime dispatchRuntime);
    public virtual InstanceContext GetExistingInstanceContext(Message message, IContextChannel channel);
}
internal class System.ServiceModel.Dispatcher.PrimitiveOperationFormatter : object {
    private OperationDescription _operation;
    private MessageDescription _responseMessage;
    private MessageDescription _requestMessage;
    private XmlDictionaryString _action;
    private XmlDictionaryString _replyAction;
    private ActionHeader _actionHeaderNone;
    private ActionHeader _actionHeader10;
    private ActionHeader _replyActionHeaderNone;
    private ActionHeader _replyActionHeader10;
    private XmlDictionaryString _requestWrapperName;
    private XmlDictionaryString _requestWrapperNamespace;
    private XmlDictionaryString _responseWrapperName;
    private XmlDictionaryString _responseWrapperNamespace;
    private PartInfo[] _requestParts;
    private PartInfo[] _responseParts;
    private PartInfo _returnPart;
    private XmlDictionaryString _xsiNilLocalName;
    private XmlDictionaryString _xsiNilNamespace;
    private ActionHeader ActionHeaderNone { get; }
    private ActionHeader ActionHeader10 { get; }
    private ActionHeader ReplyActionHeaderNone { get; }
    private ActionHeader ReplyActionHeader10 { get; }
    public PrimitiveOperationFormatter(OperationDescription description, bool isRpc);
    private ActionHeader get_ActionHeaderNone();
    private ActionHeader get_ActionHeader10();
    private ActionHeader get_ReplyActionHeaderNone();
    private ActionHeader get_ReplyActionHeader10();
    private static XmlDictionaryString AddToDictionary(XmlDictionary dictionary, string s);
    private static PartInfo[] AddToDictionary(XmlDictionary dictionary, MessagePartDescriptionCollection parts, bool isRpc);
    private ActionHeader GetActionHeader(AddressingVersion addressing);
    private ActionHeader GetReplyActionHeader(AddressingVersion addressing);
    private static string GetArrayItemName(Type type);
    private static PartInfo AddToDictionary(XmlDictionary dictionary, MessagePartDescription part, bool isRpc);
    public static bool IsContractSupported(OperationDescription description);
    private static bool AreTypesSupported(MessagePartDescriptionCollection bodyDescriptions);
    private static bool IsTypeSupported(MessagePartDescription bodyDescription);
    private static bool IsArrayTypeSupported(Type type);
    public sealed virtual Message SerializeRequest(MessageVersion messageVersion, Object[] parameters);
    public sealed virtual Message SerializeReply(MessageVersion messageVersion, Object[] parameters, object result);
    public sealed virtual object DeserializeReply(Message message, Object[] parameters);
    public sealed virtual void DeserializeRequest(Message message, Object[] parameters);
    private void DeserializeRequest(XmlDictionaryReader reader, Object[] parameters);
    private object DeserializeResponse(XmlDictionaryReader reader, Object[] parameters);
    private void DeserializeParameters(XmlDictionaryReader reader, PartInfo[] parts, Object[] parameters);
    private bool IsPartElements(XmlDictionaryReader reader, PartInfo[] parts);
    private bool IsPartElement(XmlDictionaryReader reader, PartInfo part);
    private object DeserializeParameter(XmlDictionaryReader reader, PartInfo part);
    private void SerializeParameter(XmlDictionaryWriter writer, PartInfo part, object graph);
    private void SerializeParameters(XmlDictionaryWriter writer, PartInfo[] parts, Object[] parameters);
    private void SerializeRequest(XmlDictionaryWriter writer, Object[] parameters);
    private void SerializeResponse(XmlDictionaryWriter writer, object returnValue, Object[] parameters);
}
internal class System.ServiceModel.Dispatcher.ProxyOperationRuntime : object {
    private IClientMessageFormatter _formatter;
    private bool _isInitiating;
    private bool _isOneWay;
    private bool _isTerminating;
    private bool _isSessionOpenNotificationEnabled;
    private string _name;
    private IParameterInspector[] _parameterInspectors;
    private IClientFaultFormatter _faultFormatter;
    private ImmutableClientRuntime _parent;
    private bool _serializeRequest;
    private bool _deserializeReply;
    private string _action;
    private string _replyAction;
    private MethodInfo _beginMethod;
    private MethodInfo _syncMethod;
    private MethodInfo _taskMethod;
    private ParameterInfo[] _inParams;
    private ParameterInfo[] _outParams;
    private ParameterInfo[] _endOutParams;
    private ParameterInfo _returnParam;
    [CompilerGeneratedAttribute]
private Type <TaskTResult>k__BackingField;
    internal string Action { get; }
    internal IClientFaultFormatter FaultFormatter { get; }
    internal bool IsInitiating { get; }
    internal bool IsOneWay { get; }
    internal bool IsTerminating { get; }
    internal bool IsSessionOpenNotificationEnabled { get; }
    internal string Name { get; }
    internal ImmutableClientRuntime Parent { get; }
    internal string ReplyAction { get; }
    internal bool DeserializeReply { get; }
    internal bool SerializeRequest { get; }
    internal Type TaskTResult { get; internal set; }
    internal ProxyOperationRuntime(ClientOperation operation, ImmutableClientRuntime parent);
    internal string get_Action();
    internal IClientFaultFormatter get_FaultFormatter();
    internal bool get_IsInitiating();
    internal bool get_IsOneWay();
    internal bool get_IsTerminating();
    internal bool get_IsSessionOpenNotificationEnabled();
    internal string get_Name();
    internal ImmutableClientRuntime get_Parent();
    internal string get_ReplyAction();
    internal bool get_DeserializeReply();
    internal bool get_SerializeRequest();
    [CompilerGeneratedAttribute]
internal Type get_TaskTResult();
    [CompilerGeneratedAttribute]
internal void set_TaskTResult(Type value);
    internal void AfterReply(ProxyRpc& rpc);
    internal void BeforeRequest(ProxyRpc& rpc);
    internal static object GetDefaultParameterValue(Type parameterType);
    internal bool IsSyncCall(MethodCall methodCall);
    internal bool IsBeginCall(MethodCall methodCall);
    internal bool IsTaskCall(MethodCall methodCall);
    internal Object[] MapSyncInputs(MethodCall methodCall, Object[]& outs);
    internal Object[] MapAsyncBeginInputs(MethodCall methodCall, AsyncCallback& callback, Object& asyncState);
    internal void MapAsyncEndInputs(MethodCall methodCall, IAsyncResult& result, Object[]& outs);
    internal Object[] MapSyncOutputs(MethodCall methodCall, Object[] outs, Object& ret);
    internal Object[] MapAsyncOutputs(MethodCall methodCall, Object[] outs, Object& ret);
    private Object[] MapOutputs(ParameterInfo[] parameters, MethodCall methodCall, Object[] outs, Object& ret);
    internal static bool IsValidAction(Message message, string action);
}
internal class System.ServiceModel.Dispatcher.ProxyRpc : ValueType {
    internal string Action;
    internal ServiceModelActivity Activity;
    internal Guid ActivityId;
    internal ServiceChannel Channel;
    internal Object[] Correlation;
    internal Object[] InputParameters;
    internal ProxyOperationRuntime Operation;
    internal Object[] OutputParameters;
    internal Message Request;
    internal Message Reply;
    internal object ReturnValue;
    internal MessageVersion MessageVersion;
    internal TimeoutHelper TimeoutHelper;
    private EventTraceActivity _eventTraceActivity;
    internal EventTraceActivity EventTraceActivity { get; internal set; }
    internal ProxyRpc(ServiceChannel channel, ProxyOperationRuntime operation, string action, Object[] inputs, TimeSpan timeout);
    internal EventTraceActivity get_EventTraceActivity();
    internal void set_EventTraceActivity(EventTraceActivity value);
}
internal class System.ServiceModel.Dispatcher.ReplyChannelBinder : object {
    private IReplyChannel _channel;
    private Uri _listenUri;
    public IChannel Channel { get; }
    public bool HasSession { get; }
    public Uri ListenUri { get; }
    public EndpointAddress LocalAddress { get; }
    public EndpointAddress RemoteAddress { get; }
    internal ReplyChannelBinder(IReplyChannel channel, Uri listenUri);
    public sealed virtual IChannel get_Channel();
    public sealed virtual bool get_HasSession();
    public sealed virtual Uri get_ListenUri();
    public sealed virtual EndpointAddress get_LocalAddress();
    public sealed virtual EndpointAddress get_RemoteAddress();
    public sealed virtual void Abort();
    public sealed virtual void CloseAfterFault(TimeSpan timeout);
    public sealed virtual IAsyncResult BeginTryReceive(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual bool EndTryReceive(IAsyncResult result, RequestContext& requestContext);
    public sealed virtual RequestContext CreateRequestContext(Message message);
    public sealed virtual IAsyncResult BeginSend(Message message, TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual void EndSend(IAsyncResult result);
    public sealed virtual void Send(Message message, TimeSpan timeout);
    public sealed virtual IAsyncResult BeginRequest(Message message, TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual Message EndRequest(IAsyncResult result);
    public sealed virtual bool TryReceive(TimeSpan timeout, RequestContext& requestContext);
    public sealed virtual Message Request(Message message, TimeSpan timeout);
    public sealed virtual bool WaitForMessage(TimeSpan timeout);
    public sealed virtual IAsyncResult BeginWaitForMessage(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual bool EndWaitForMessage(IAsyncResult result);
}
internal class System.ServiceModel.Dispatcher.RequestChannelBinder : object {
    private IRequestChannel _channel;
    public IChannel Channel { get; }
    public bool HasSession { get; }
    public Uri ListenUri { get; }
    public EndpointAddress LocalAddress { get; }
    public EndpointAddress RemoteAddress { get; }
    internal RequestChannelBinder(IRequestChannel channel);
    public sealed virtual IChannel get_Channel();
    public sealed virtual bool get_HasSession();
    public sealed virtual Uri get_ListenUri();
    public sealed virtual EndpointAddress get_LocalAddress();
    public sealed virtual EndpointAddress get_RemoteAddress();
    public sealed virtual void Abort();
    public sealed virtual void CloseAfterFault(TimeSpan timeout);
    public sealed virtual IAsyncResult BeginTryReceive(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual bool EndTryReceive(IAsyncResult result, RequestContext& requestContext);
    public sealed virtual RequestContext CreateRequestContext(Message message);
    public sealed virtual IAsyncResult BeginSend(Message message, TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual void EndSend(IAsyncResult result);
    public sealed virtual void Send(Message message, TimeSpan timeout);
    public sealed virtual IAsyncResult BeginRequest(Message message, TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual Message EndRequest(IAsyncResult result);
    public sealed virtual bool TryReceive(TimeSpan timeout, RequestContext& requestContext);
    public sealed virtual Message Request(Message message, TimeSpan timeout);
    private void ValidateNullReply(Message message);
    public sealed virtual bool WaitForMessage(TimeSpan timeout);
    public sealed virtual IAsyncResult BeginWaitForMessage(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual bool EndWaitForMessage(IAsyncResult result);
}
internal class System.ServiceModel.Dispatcher.SharedRuntimeState : object {
    private bool _isImmutable;
    private bool _enableFaults;
    private bool _isOnServer;
    private bool _manualAddressing;
    private bool _validateMustUnderstand;
    internal bool EnableFaults { get; internal set; }
    internal bool IsOnServer { get; }
    internal bool ManualAddressing { get; internal set; }
    internal bool ValidateMustUnderstand { get; internal set; }
    internal SharedRuntimeState(bool isOnServer);
    internal bool get_EnableFaults();
    internal void set_EnableFaults(bool value);
    internal bool get_IsOnServer();
    internal bool get_ManualAddressing();
    internal void set_ManualAddressing(bool value);
    internal bool get_ValidateMustUnderstand();
    internal void set_ValidateMustUnderstand(bool value);
    internal void LockDownProperties();
    internal void ThrowIfImmutable();
}
internal class System.ServiceModel.Dispatcher.StreamFormatter : object {
    private string _wrapperName;
    private string _wrapperNS;
    private string _partName;
    private string _partNS;
    private int _streamIndex;
    private bool _isRequest;
    private string _operationName;
    private static int returnValueIndex;
    internal string WrapperName { get; internal set; }
    internal string WrapperNamespace { get; internal set; }
    internal string PartName { get; }
    internal string PartNamespace { get; }
    private StreamFormatter(MessageDescription messageDescription, MessagePartDescription streamPart, string operationName, bool isRequest);
    internal static StreamFormatter Create(MessageDescription messageDescription, string operationName, bool isRequest);
    internal void Serialize(XmlDictionaryWriter writer, Object[] parameters, object returnValue);
    [AsyncStateMachineAttribute("System.ServiceModel.Dispatcher.StreamFormatter/<SerializeAsync>d__11")]
internal Task SerializeAsync(XmlDictionaryWriter writer, Object[] parameters, object returnValue);
    private Stream GetStreamAndWriteStartWrapperIfNecessary(XmlDictionaryWriter writer, Object[] parameters, object returnValue);
    [AsyncStateMachineAttribute("System.ServiceModel.Dispatcher.StreamFormatter/<GetStreamAndWriteStartWrapperIfNecessaryAsync>d__13")]
private Task`1<Stream> GetStreamAndWriteStartWrapperIfNecessaryAsync(XmlDictionaryWriter writer, Object[] parameters, object returnValue);
    private void WriteEndWrapperIfNecessary(XmlDictionaryWriter writer);
    private Task WriteEndWrapperIfNecessaryAsync(XmlDictionaryWriter writer);
    internal IAsyncResult BeginSerialize(XmlDictionaryWriter writer, Object[] parameters, object returnValue, AsyncCallback callback, object state);
    public void EndSerialize(IAsyncResult result);
    internal void Deserialize(Object[] parameters, Object& retVal, Message message);
    internal string get_WrapperName();
    internal void set_WrapperName(string value);
    internal string get_WrapperNamespace();
    internal void set_WrapperNamespace(string value);
    internal string get_PartName();
    internal string get_PartNamespace();
    private Stream GetStreamValue(Object[] parameters, object returnValue);
    private void SetStreamValue(Object[] parameters, Object& returnValue, Stream streamValue);
    private static MessagePartDescription ValidateAndGetStreamPart(MessageDescription messageDescription, bool isRequest, string operationName);
    private static bool HasStream(MessageDescription messageDescription);
    private static MessagePartDescription GetStreamPart(MessageDescription messageDescription);
    internal static bool IsStream(MessageDescription messageDescription);
}
internal class System.ServiceModel.Dispatcher.SynchronizedChannelCollection`1 : SynchronizedCollection`1<TChannel> {
    private EventHandler _onChannelClosed;
    private EventHandler _onChannelFaulted;
    internal SynchronizedChannelCollection`1(object syncRoot);
    private void AddingChannel(TChannel channel);
    private void RemovingChannel(TChannel channel);
    private void OnChannelClosed(object sender, EventArgs args);
    private void OnChannelFaulted(object sender, EventArgs args);
    protected virtual void ClearItems();
    protected virtual void InsertItem(int index, TChannel item);
    protected virtual void RemoveItem(int index);
    protected virtual void SetItem(int index, TChannel item);
}
public class System.ServiceModel.Dispatcher.SyncMethodInvoker : object {
    private MethodInfo _method;
    private InvokeDelegate _invokeDelegate;
    private int _inputParameterCount;
    private int _outputParameterCount;
    private string _methodName;
    public MethodInfo Method { get; }
    public string MethodName { get; }
    public SyncMethodInvoker(MethodInfo method);
    public MethodInfo get_Method();
    public string get_MethodName();
    public sealed virtual Object[] AllocateInputs();
    public sealed virtual IAsyncResult InvokeBegin(object instance, Object[] inputs, AsyncCallback callback, object state);
    public sealed virtual object InvokeEnd(object instance, Object[]& outputs, IAsyncResult result);
    private Task`1<Tuple`2<object, Object[]>> InvokeAsync(object instance, Object[] inputs);
    private void EnsureIsInitialized();
    private void EnsureIsInitializedCore();
}
public class System.ServiceModel.Dispatcher.TaskMethodInvoker : object {
    private static string ResultMethodName;
    private MethodInfo _taskMethod;
    private InvokeDelegate _invokeDelegate;
    private int _inputParameterCount;
    private int _outputParameterCount;
    private string _methodName;
    private MethodInfo _taskTResultGetMethod;
    private bool _isGenericTask;
    public MethodInfo Method { get; }
    public string MethodName { get; }
    public TaskMethodInvoker(MethodInfo taskMethod, Type taskType);
    public MethodInfo get_Method();
    public string get_MethodName();
    public sealed virtual Object[] AllocateInputs();
    public sealed virtual IAsyncResult InvokeBegin(object instance, Object[] inputs, AsyncCallback callback, object state);
    public sealed virtual object InvokeEnd(object instance, Object[]& outputs, IAsyncResult result);
    [AsyncStateMachineAttribute("System.ServiceModel.Dispatcher.TaskMethodInvoker/<InvokeAsync>d__16")]
private Task`1<Tuple`2<object, Object[]>> InvokeAsync(object instance, Object[] inputs);
    private void EnsureIsInitialized();
    private void EnsureIsInitializedCore();
}
internal class System.ServiceModel.Dispatcher.TerminatingOperationBehavior : object {
    private static TimerCallback s_abortChannelTimerCallback;
    private static TerminatingOperationBehavior();
    private static void AbortChannel(object state);
    public static TerminatingOperationBehavior CreateIfNecessary(DispatchRuntime dispatch);
    private static bool IsTerminatingOperationBehaviorNeeded(DispatchRuntime dispatch);
    internal void AfterReply(MessageRpc& rpc);
    internal static void AfterReply(ProxyRpc& rpc);
}
internal class System.ServiceModel.Dispatcher.ThreadBehavior : object {
    private SendOrPostCallback _threadAffinityStartCallback;
    private SendOrPostCallback _threadAffinityEndCallback;
    private static Action`1<object> s_cleanThreadCallback;
    private SynchronizationContext _context;
    private SendOrPostCallback ThreadAffinityStartCallbackDelegate { get; }
    private SendOrPostCallback ThreadAffinityEndCallbackDelegate { get; }
    private static Action`1<object> CleanThreadCallbackDelegate { get; }
    internal ThreadBehavior(DispatchRuntime dispatch);
    private SendOrPostCallback get_ThreadAffinityStartCallbackDelegate();
    private SendOrPostCallback get_ThreadAffinityEndCallbackDelegate();
    private static Action`1<object> get_CleanThreadCallbackDelegate();
    internal void BindThread(MessageRpc& rpc);
    internal void BindEndThread(MessageRpc& rpc);
    private void BindCore(MessageRpc& rpc, bool startOperation);
    private SynchronizationContext GetSyncContext(InstanceContext instanceContext);
    private void SynchronizationContextStartCallback(object state);
    private void SynchronizationContextEndCallback(object state);
    private void ResumeProcessing(IResumeMessageRpc resume);
    private static void CleanThreadCallback(object state);
    internal static SynchronizationContext GetCurrentSynchronizationContext();
}
internal class System.ServiceModel.Dispatcher.XmlSerializerFaultFormatter : FaultFormatter {
    private SynchronizedCollection`1<XmlSerializerFaultContractInfo> _xmlSerializerFaultContractInfos;
    internal XmlSerializerFaultFormatter(Type[] detailTypes, SynchronizedCollection`1<XmlSerializerFaultContractInfo> xmlSerializerFaultContractInfos);
    internal XmlSerializerFaultFormatter(SynchronizedCollection`1<FaultContractInfo> faultContractInfoCollection, SynchronizedCollection`1<XmlSerializerFaultContractInfo> xmlSerializerFaultContractInfos);
    private void Initialize(SynchronizedCollection`1<XmlSerializerFaultContractInfo> xmlSerializerFaultContractInfos);
    protected virtual XmlObjectSerializer GetSerializer(Type detailType, string faultExceptionAction, String& action);
    protected virtual FaultException CreateFaultException(MessageFault messageFault, string action);
}
internal class System.ServiceModel.Dispatcher.XmlSerializerObjectSerializer : XmlObjectSerializer {
    private XmlSerializer _serializer;
    private Type _rootType;
    private string _rootName;
    private string _rootNamespace;
    private bool _isSerializerSetExplicit;
    internal XmlSerializerObjectSerializer(Type type);
    internal XmlSerializerObjectSerializer(Type type, XmlQualifiedName qualifiedName, XmlSerializer xmlSerializer);
    private void Initialize(Type type, string rootName, string rootNamespace, XmlSerializer xmlSerializer);
    public virtual void WriteObject(XmlDictionaryWriter writer, object graph);
    public virtual void WriteStartObject(XmlDictionaryWriter writer, object graph);
    public virtual void WriteObjectContent(XmlDictionaryWriter writer, object graph);
    public virtual void WriteEndObject(XmlDictionaryWriter writer);
    public virtual object ReadObject(XmlDictionaryReader reader, bool verifyObjectName);
    public virtual bool IsStartObject(XmlDictionaryReader reader);
}
internal class System.ServiceModel.Dispatcher.XmlSerializerOperationFormatter : OperationFormatter {
    private static string soap11Encoding;
    private static string soap12Encoding;
    private MessageInfo _requestMessageInfo;
    private MessageInfo _replyMessageInfo;
    public XmlSerializerOperationFormatter(OperationDescription description, XmlSerializerFormatAttribute xmlSerializerFormatAttribute, MessageInfo requestMessageInfo, MessageInfo replyMessageInfo);
    protected virtual void AddHeadersToMessage(Message message, MessageDescription messageDescription, Object[] parameters, bool isRequest);
    protected virtual void GetHeadersFromMessage(Message message, MessageDescription messageDescription, Object[] parameters, bool isRequest);
    private static void AddUnknownHeader(MessageHeaderDescription unknownHeaderDescription, ArrayList unknownHeaders, XmlDocument xmlDoc, XmlDictionaryWriter bufferWriter, MessageHeaderInfo header, XmlDictionaryReader headerReader);
    protected virtual void WriteBodyAttributes(XmlDictionaryWriter writer, MessageVersion version);
    protected virtual void SerializeBody(XmlDictionaryWriter writer, MessageVersion version, string action, MessageDescription messageDescription, object returnValue, Object[] parameters, bool isRequest);
    private void SerializeBody(XmlDictionaryWriter writer, MessageVersion version, XmlSerializer serializer, MessagePartDescription returnPart, MessagePartDescriptionCollection bodyParts, object returnValue, Object[] parameters);
    protected virtual object DeserializeBody(XmlDictionaryReader reader, MessageVersion version, string action, MessageDescription messageDescription, Object[] parameters, bool isRequest);
    private object DeserializeBody(XmlDictionaryReader reader, MessageVersion version, XmlSerializer serializer, MessagePartDescription returnPart, MessagePartDescriptionCollection bodyParts, Object[] parameters, bool isRequest);
    internal static string GetEncoding(EnvelopeVersion version);
}
public class System.ServiceModel.DnsEndpointIdentity : EndpointIdentity {
    public DnsEndpointIdentity(string dnsName);
    public DnsEndpointIdentity(Claim identity);
    internal virtual void WriteContentsTo(XmlDictionaryWriter writer);
}
internal static class System.ServiceModel.DotNetAddressingStrings : object {
    public static string Namespace;
    public static string RedirectTo;
    public static string Via;
}
internal static class System.ServiceModel.DotNetAtomicTransactionExternalStrings : object {
    public static string Namespace;
    public static string Prefix;
    public static string Enlistment;
    public static string Protocol;
    public static string LocalTransactionId;
    public static string IsolationLevel;
    public static string IsolationFlags;
    public static string Description;
    public static string Loopback;
    public static string RegisterInfo;
    public static string ContextId;
    public static string TokenId;
    public static string AccessDenied;
    public static string InvalidPolicy;
    public static string CoordinatorRegistrationFailed;
    public static string TooManyEnlistments;
    public static string Disabled;
}
internal static class System.ServiceModel.DotNetOneWayStrings : object {
    public static string Namespace;
    public static string HeaderName;
}
internal static class System.ServiceModel.DotNetSecurityStrings : object {
    public static string Namespace;
    public static string Prefix;
    public static string KeyRenewalNeededFault;
    public static string SecuritySessionAbortedFault;
    public static string SecurityServerTooBusyFault;
    public static string SecuritySessionFaultAction;
    public static string SecureConversationCancelNotAllowedFault;
}
public class System.ServiceModel.DuplexChannelFactory`1 : ChannelFactory`1<TChannel> {
    public DuplexChannelFactory`1(Type callbackInstanceType);
    public DuplexChannelFactory`1(Type callbackInstanceType, Binding binding, string remoteAddress);
    public DuplexChannelFactory`1(Type callbackInstanceType, Binding binding, EndpointAddress remoteAddress);
    public DuplexChannelFactory`1(Type callbackInstanceType, Binding binding);
    public DuplexChannelFactory`1(Type callbackInstanceType, string endpointConfigurationName, EndpointAddress remoteAddress);
    public DuplexChannelFactory`1(Type callbackInstanceType, string endpointConfigurationName);
    public DuplexChannelFactory`1(Type callbackInstanceType, ServiceEndpoint endpoint);
    public DuplexChannelFactory`1(InstanceContext callbackInstance);
    public DuplexChannelFactory`1(InstanceContext callbackInstance, Binding binding, string remoteAddress);
    public DuplexChannelFactory`1(InstanceContext callbackInstance, Binding binding, EndpointAddress remoteAddress);
    public DuplexChannelFactory`1(InstanceContext callbackInstance, Binding binding);
    public DuplexChannelFactory`1(InstanceContext callbackInstance, string endpointConfigurationName, EndpointAddress remoteAddress);
    public DuplexChannelFactory`1(InstanceContext callbackInstance, string endpointConfigurationName);
    public DuplexChannelFactory`1(InstanceContext callbackInstance, ServiceEndpoint endpoint);
    public DuplexChannelFactory`1(object callbackObject);
    public DuplexChannelFactory`1(object callbackObject, string endpointConfigurationName);
    public DuplexChannelFactory`1(object callbackObject, string endpointConfigurationName, EndpointAddress remoteAddress);
    public DuplexChannelFactory`1(object callbackObject, Binding binding);
    public DuplexChannelFactory`1(object callbackObject, Binding binding, string remoteAddress);
    public DuplexChannelFactory`1(object callbackObject, Binding binding, EndpointAddress remoteAddress);
    public DuplexChannelFactory`1(object callbackObject, ServiceEndpoint endpoint);
    internal void CheckAndAssignCallbackInstance(object callbackInstance);
    public TChannel CreateChannel(InstanceContext callbackInstance);
    public TChannel CreateChannel(InstanceContext callbackInstance, EndpointAddress address);
    public virtual TChannel CreateChannel(EndpointAddress address, Uri via);
    public virtual TChannel CreateChannel(InstanceContext callbackInstance, EndpointAddress address, Uri via);
    private static InstanceContext GetInstanceContextForObject(object callbackObject);
    public static TChannel CreateChannel(object callbackObject, string endpointConfigurationName);
    public static TChannel CreateChannel(object callbackObject, Binding binding, EndpointAddress endpointAddress);
    public static TChannel CreateChannel(object callbackObject, Binding binding, EndpointAddress endpointAddress, Uri via);
    public static TChannel CreateChannel(InstanceContext callbackInstance, string endpointConfigurationName);
    public static TChannel CreateChannel(InstanceContext callbackInstance, Binding binding, EndpointAddress endpointAddress);
    public static TChannel CreateChannel(InstanceContext callbackInstance, Binding binding, EndpointAddress endpointAddress, Uri via);
}
public abstract class System.ServiceModel.DuplexClientBase`1 : ClientBase`1<TChannel> {
    public IDuplexContextChannel InnerDuplexChannel { get; }
    protected DuplexClientBase`1(InstanceContext callbackInstance);
    protected DuplexClientBase`1(InstanceContext callbackInstance, string endpointConfigurationName);
    protected DuplexClientBase`1(InstanceContext callbackInstance, string endpointConfigurationName, string remoteAddress);
    protected DuplexClientBase`1(InstanceContext callbackInstance, string endpointConfigurationName, EndpointAddress remoteAddress);
    protected DuplexClientBase`1(InstanceContext callbackInstance, Binding binding, EndpointAddress remoteAddress);
    public IDuplexContextChannel get_InnerDuplexChannel();
}
internal static class System.ServiceModel.DXD : object {
    private static AtomicTransactionExternal11Dictionary s_atomicTransactionExternal11Dictionary;
    private static CoordinationExternal11Dictionary s_coordinationExternal11Dictionary;
    private static SecureConversationDec2005Dictionary s_secureConversationDec2005Dictionary;
    private static SecurityAlgorithmDec2005Dictionary s_securityAlgorithmDec2005Dictionary;
    private static TrustDec2005Dictionary s_trustDec2005Dictionary;
    private static Wsrm11Dictionary s_wsrm11Dictionary;
    public static AtomicTransactionExternal11Dictionary AtomicTransactionExternal11Dictionary { get; }
    public static CoordinationExternal11Dictionary CoordinationExternal11Dictionary { get; }
    public static SecureConversationDec2005Dictionary SecureConversationDec2005Dictionary { get; }
    public static SecurityAlgorithmDec2005Dictionary SecurityAlgorithmDec2005Dictionary { get; }
    public static TrustDec2005Dictionary TrustDec2005Dictionary { get; }
    public static Wsrm11Dictionary Wsrm11Dictionary { get; }
    private static DXD();
    public static AtomicTransactionExternal11Dictionary get_AtomicTransactionExternal11Dictionary();
    public static CoordinationExternal11Dictionary get_CoordinationExternal11Dictionary();
    public static SecureConversationDec2005Dictionary get_SecureConversationDec2005Dictionary();
    public static SecurityAlgorithmDec2005Dictionary get_SecurityAlgorithmDec2005Dictionary();
    public static TrustDec2005Dictionary get_TrustDec2005Dictionary();
    public static Wsrm11Dictionary get_Wsrm11Dictionary();
}
internal static class System.ServiceModel.EmptyArray`1 : object {
    internal static T[] Allocate(int n);
    internal static T[] ToArray(IList`1<T> collection);
    internal static T[] ToArray(SynchronizedCollection`1<T> collection);
}
public class System.ServiceModel.EndpointAddress : object {
    private static Uri s_anonymousUri;
    private static Uri s_noneUri;
    private static EndpointAddress s_anonymousAddress;
    private AddressingVersion _addressingVersion;
    private AddressHeaderCollection _headers;
    private EndpointIdentity _identity;
    private Uri _uri;
    private XmlBuffer _buffer;
    private int _extensionSection;
    private int _metadataSection;
    private int _pspSection;
    private bool _isAnonymous;
    private bool _isNone;
    internal static string DummyName;
    internal static string DummyNamespace;
    internal static EndpointAddress AnonymousAddress { get; }
    public static Uri AnonymousUri { get; }
    public static Uri NoneUri { get; }
    internal XmlBuffer Buffer { get; }
    public AddressHeaderCollection Headers { get; }
    public EndpointIdentity Identity { get; }
    public bool IsAnonymous { get; }
    public bool IsNone { get; }
    public Uri Uri { get; }
    private EndpointAddress(AddressingVersion version, Uri uri, EndpointIdentity identity, AddressHeaderCollection headers, XmlBuffer buffer, int metadataSection, int extensionSection, int pspSection);
    public EndpointAddress(string uri);
    public EndpointAddress(Uri uri, AddressHeader[] addressHeaders);
    public EndpointAddress(Uri uri, EndpointIdentity identity, AddressHeader[] addressHeaders);
    internal EndpointAddress(Uri newUri, EndpointAddress oldEndpointAddress);
    internal EndpointAddress(Uri uri, EndpointIdentity identity, AddressHeaderCollection headers, XmlDictionaryReader metadataReader, XmlDictionaryReader extensionReader, XmlDictionaryReader pspReader);
    private void Init(Uri uri, EndpointIdentity identity, AddressHeader[] headers);
    private void Init(Uri uri, EndpointIdentity identity, AddressHeaderCollection headers, XmlBuffer buffer, int metadataSection, int extensionSection, int pspSection);
    private void Init(AddressingVersion version, Uri uri, EndpointIdentity identity, AddressHeaderCollection headers, XmlBuffer buffer, int metadataSection, int extensionSection, int pspSection);
    internal static EndpointAddress get_AnonymousAddress();
    public static Uri get_AnonymousUri();
    public static Uri get_NoneUri();
    internal XmlBuffer get_Buffer();
    public AddressHeaderCollection get_Headers();
    public EndpointIdentity get_Identity();
    public bool get_IsAnonymous();
    public bool get_IsNone();
    public Uri get_Uri();
    public void ApplyTo(Message message);
    internal static bool UriEquals(Uri u1, Uri u2, bool ignoreCase, bool includeHostInComparison);
    internal static bool UriEquals(Uri u1, Uri u2, bool ignoreCase, bool includeHostInComparison, bool includePortInComparison);
    internal static int UriGetHashCode(Uri uri, bool includeHostInComparison);
    internal static int UriGetHashCode(Uri uri, bool includeHostInComparison, bool includePortInComparison);
    internal bool EndpointEquals(EndpointAddress endpointAddress);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    internal XmlDictionaryReader GetReaderAtPsp();
    public XmlDictionaryReader GetReaderAtMetadata();
    public XmlDictionaryReader GetReaderAtExtensions();
    private static XmlDictionaryReader GetReaderAtSection(XmlBuffer buffer, int section);
    private void PossiblyPopulateBuffer(XmlDictionaryReader reader, XmlBuffer& buffer, Int32& section);
    public static EndpointAddress ReadFrom(XmlDictionaryReader reader);
    internal static EndpointAddress ReadFrom(XmlDictionaryReader reader, AddressingVersion& version);
    public static EndpointAddress ReadFrom(AddressingVersion addressingVersion, XmlDictionaryReader reader);
    private static EndpointAddress ReadFromDriver(AddressingVersion addressingVersion, XmlDictionaryReader reader);
    internal static XmlBuffer ReadExtensions(XmlDictionaryReader reader, AddressingVersion version, XmlBuffer buffer, EndpointIdentity& identity, Int32& section);
    private static bool ReadContentsFrom10(XmlDictionaryReader reader, Uri& uri, AddressHeaderCollection& headers, EndpointIdentity& identity, XmlBuffer& buffer, Int32& metadataSection, Int32& extensionSection);
    private static XmlException CreateXmlException(XmlDictionaryReader reader, string message);
    private static bool Done(XmlDictionaryReader reader);
    internal static void Copy(XmlDictionaryWriter writer, XmlDictionaryReader reader);
    public virtual string ToString();
    public void WriteContentsTo(AddressingVersion addressingVersion, XmlDictionaryWriter writer);
    private void WriteContentsToNone(XmlDictionaryWriter writer);
    private void WriteContentsTo10(XmlDictionaryWriter writer);
    public void WriteContentsTo(AddressingVersion addressingVersion, XmlWriter writer);
    public void WriteTo(AddressingVersion addressingVersion, XmlDictionaryWriter writer);
    public void WriteTo(AddressingVersion addressingVersion, XmlDictionaryWriter writer, XmlDictionaryString localName, XmlDictionaryString ns);
    public void WriteTo(AddressingVersion addressingVersion, XmlWriter writer);
    public void WriteTo(AddressingVersion addressingVersion, XmlWriter writer, string localName, string ns);
    public static bool op_Equality(EndpointAddress address1, EndpointAddress address2);
    public static bool op_Inequality(EndpointAddress address1, EndpointAddress address2);
}
public class System.ServiceModel.EndpointAddressBuilder : object {
    private Uri _uri;
    private EndpointIdentity _identity;
    private Collection`1<AddressHeader> _headers;
    private XmlBuffer _extensionBuffer;
    private XmlBuffer _metadataBuffer;
    private bool _hasExtension;
    private bool _hasMetadata;
    private EndpointAddress _epr;
    public Uri Uri { get; public set; }
    public EndpointIdentity Identity { get; public set; }
    public Collection`1<AddressHeader> Headers { get; }
    public EndpointAddressBuilder(EndpointAddress address);
    public Uri get_Uri();
    public void set_Uri(Uri value);
    public EndpointIdentity get_Identity();
    public void set_Identity(EndpointIdentity value);
    public Collection`1<AddressHeader> get_Headers();
    public XmlDictionaryReader GetReaderAtMetadata();
    public void SetMetadataReader(XmlDictionaryReader reader);
    public XmlDictionaryReader GetReaderAtExtensions();
    public void SetExtensionReader(XmlDictionaryReader reader);
    public EndpointAddress ToEndpointAddress();
}
public abstract class System.ServiceModel.EndpointIdentity : object {
    private Claim _identityClaim;
    private IEqualityComparer`1<Claim> _claimComparer;
    public Claim IdentityClaim { get; }
    protected void Initialize(Claim identityClaim);
    protected void Initialize(Claim identityClaim, IEqualityComparer`1<Claim> claimComparer);
    public Claim get_IdentityClaim();
    public static EndpointIdentity CreateIdentity(Claim identity);
    public static EndpointIdentity CreateDnsIdentity(string dnsName);
    public static EndpointIdentity CreateSpnIdentity(string spnName);
    public static EndpointIdentity CreateUpnIdentity(string upnName);
    internal virtual void EnsureIdentityClaim();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    internal bool Matches(Claim claim);
    private IEqualityComparer`1<Claim> GetClaimComparer();
    internal static EndpointIdentity ReadIdentity(XmlDictionaryReader reader);
    internal void WriteTo(XmlDictionaryWriter writer);
    internal virtual void WriteContentsTo(XmlDictionaryWriter writer);
}
public class System.ServiceModel.EndpointNotFoundException : CommunicationException {
    public EndpointNotFoundException(string message);
    public EndpointNotFoundException(string message, Exception innerException);
    protected EndpointNotFoundException(SerializationInfo info, StreamingContext context);
}
public class System.ServiceModel.EnvelopeVersion : object {
    private string _ultimateDestinationActor;
    private String[] _ultimateDestinationActorValues;
    private string _nextDestinationActorValue;
    private string _ns;
    private XmlDictionaryString _dictionaryNs;
    private string _actor;
    private XmlDictionaryString _dictionaryActor;
    private string _toStringFormat;
    private String[] _mustUnderstandActorValues;
    private string _senderFaultName;
    private string _receiverFaultName;
    private static string Soap11ToStringFormat;
    private static string Soap12ToStringFormat;
    private static string EnvelopeNoneToStringFormat;
    private static EnvelopeVersion s_soap11;
    private static EnvelopeVersion s_soap12;
    private static EnvelopeVersion s_none;
    internal string Actor { get; }
    internal XmlDictionaryString DictionaryActor { get; }
    internal string Namespace { get; }
    internal XmlDictionaryString DictionaryNamespace { get; }
    public string NextDestinationActorValue { get; }
    public static EnvelopeVersion None { get; }
    public static EnvelopeVersion Soap11 { get; }
    public static EnvelopeVersion Soap12 { get; }
    internal string ReceiverFaultName { get; }
    internal string SenderFaultName { get; }
    internal String[] MustUnderstandActorValues { get; }
    internal string UltimateDestinationActor { get; }
    internal String[] UltimateDestinationActorValues { get; }
    private EnvelopeVersion(string ultimateReceiverActor, string nextDestinationActorValue, string ns, XmlDictionaryString dictionaryNs, string actor, XmlDictionaryString dictionaryActor, string toStringFormat, string senderFaultName, string receiverFaultName);
    private static EnvelopeVersion();
    internal string get_Actor();
    internal XmlDictionaryString get_DictionaryActor();
    internal string get_Namespace();
    internal XmlDictionaryString get_DictionaryNamespace();
    public string get_NextDestinationActorValue();
    public static EnvelopeVersion get_None();
    public static EnvelopeVersion get_Soap11();
    public static EnvelopeVersion get_Soap12();
    internal string get_ReceiverFaultName();
    internal string get_SenderFaultName();
    internal String[] get_MustUnderstandActorValues();
    internal string get_UltimateDestinationActor();
    public String[] GetUltimateDestinationActorValues();
    internal String[] get_UltimateDestinationActorValues();
    internal bool IsUltimateDestinationActor(string actor);
    public virtual string ToString();
}
[DataContractAttribute]
public class System.ServiceModel.ExceptionDetail : object {
    private string _helpLink;
    private ExceptionDetail _innerException;
    private string _message;
    private string _stackTrace;
    private string _type;
    [DataMemberAttribute]
public string HelpLink { get; public set; }
    [DataMemberAttribute]
public ExceptionDetail InnerException { get; public set; }
    [DataMemberAttribute]
public string Message { get; public set; }
    [DataMemberAttribute]
public string StackTrace { get; public set; }
    [DataMemberAttribute]
public string Type { get; public set; }
    public ExceptionDetail(Exception exception);
    public string get_HelpLink();
    public void set_HelpLink(string value);
    public ExceptionDetail get_InnerException();
    public void set_InnerException(ExceptionDetail value);
    public string get_Message();
    public void set_Message(string value);
    public string get_StackTrace();
    public void set_StackTrace(string value);
    public string get_Type();
    public void set_Type(string value);
    public virtual string ToString();
    private string ToStringHelper(bool isInner);
}
public class System.ServiceModel.ExceptionHelper : object {
    public static string WinsdowsStreamSecurityNotSupported;
    public static Exception AsError(Exception exception);
    public static PlatformNotSupportedException PlatformNotSupported();
    public static PlatformNotSupportedException PlatformNotSupported(string message);
    public static Exception CreateMaxReceivedMessageSizeExceededException(long maxMessageSize);
}
internal static class System.ServiceModel.ExclusiveC14NStrings : object {
    public static string Namespace;
    public static string PrefixList;
    public static string InclusiveNamespaces;
    public static string Prefix;
}
public class System.ServiceModel.ExtensionCollection`1 : SynchronizedCollection`1<IExtension`1<T>> {
    private T _owner;
    private bool System.Collections.Generic.ICollection<System.ServiceModel.IExtension<T>>.IsReadOnly { get; }
    public ExtensionCollection`1(T owner);
    public ExtensionCollection`1(T owner, object syncRoot);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.ServiceModel.IExtension<T>>.get_IsReadOnly();
    protected virtual void ClearItems();
    public sealed virtual E Find();
    public sealed virtual Collection`1<E> FindAll();
    protected virtual void InsertItem(int index, IExtension`1<T> item);
    protected virtual void RemoveItem(int index);
    protected virtual void SetItem(int index, IExtension`1<T> item);
}
public class System.ServiceModel.FaultCode : object {
    private FaultCode _subCode;
    private string _name;
    private string _ns;
    private EnvelopeVersion _version;
    public bool IsPredefinedFault { get; }
    public bool IsSenderFault { get; }
    public bool IsReceiverFault { get; }
    public string Namespace { get; }
    public string Name { get; }
    public FaultCode SubCode { get; }
    public FaultCode(string name);
    public FaultCode(string name, FaultCode subCode);
    public FaultCode(string name, string ns);
    public FaultCode(string name, string ns, FaultCode subCode);
    public bool get_IsPredefinedFault();
    public bool get_IsSenderFault();
    public bool get_IsReceiverFault();
    public string get_Namespace();
    public string get_Name();
    public FaultCode get_SubCode();
    public static FaultCode CreateSenderFaultCode(FaultCode subCode);
    public static FaultCode CreateSenderFaultCode(string name, string ns);
    public static FaultCode CreateReceiverFaultCode(FaultCode subCode);
    public static FaultCode CreateReceiverFaultCode(string name, string ns);
}
internal class System.ServiceModel.FaultCodeConstants : object {
}
[AttributeUsageAttribute("64")]
public class System.ServiceModel.FaultContractAttribute : Attribute {
    private string _action;
    private string _name;
    private string _ns;
    private Type _type;
    private ProtectionLevel _protectionLevel;
    private bool _hasProtectionLevel;
    internal static string ProtectionLevelPropertyName;
    public Type DetailType { get; }
    public string Action { get; public set; }
    public string Name { get; public set; }
    public string Namespace { get; public set; }
    public ProtectionLevel ProtectionLevel { get; public set; }
    public bool HasProtectionLevel { get; }
    public FaultContractAttribute(Type detailType);
    public Type get_DetailType();
    public string get_Action();
    public void set_Action(string value);
    public string get_Name();
    public void set_Name(string value);
    public string get_Namespace();
    public void set_Namespace(string value);
    public ProtectionLevel get_ProtectionLevel();
    public void set_ProtectionLevel(ProtectionLevel value);
    public bool get_HasProtectionLevel();
}
[KnownTypeAttribute("System.ServiceModel.FaultException/FaultCodeData")]
[KnownTypeAttribute("System.ServiceModel.FaultException/FaultCodeData[]")]
[KnownTypeAttribute("System.ServiceModel.FaultException/FaultReasonData")]
[KnownTypeAttribute("System.ServiceModel.FaultException/FaultReasonData[]")]
public class System.ServiceModel.FaultException : CommunicationException {
    internal static string Namespace;
    private string _action;
    private FaultCode _code;
    private FaultReason _reason;
    private MessageFault _fault;
    public string Action { get; }
    public FaultCode Code { get; }
    private static FaultReason DefaultReason { get; }
    private static FaultCode DefaultCode { get; }
    public string Message { get; }
    public FaultReason Reason { get; }
    internal MessageFault Fault { get; }
    public FaultException(string reason);
    public FaultException(FaultReason reason);
    public FaultException(string reason, FaultCode code);
    public FaultException(FaultReason reason, FaultCode code);
    public FaultException(string reason, FaultCode code, string action);
    internal FaultException(string reason, FaultCode code, string action, Exception innerException);
    public FaultException(FaultReason reason, FaultCode code, string action);
    internal FaultException(FaultReason reason, FaultCode code, string action, Exception innerException);
    public FaultException(MessageFault fault);
    public FaultException(MessageFault fault, string action);
    protected FaultException(SerializationInfo info, StreamingContext context);
    public string get_Action();
    public FaultCode get_Code();
    private static FaultReason get_DefaultReason();
    private static FaultCode get_DefaultCode();
    public virtual string get_Message();
    public FaultReason get_Reason();
    internal MessageFault get_Fault();
    private static FaultCode CreateCode(string code);
    public static FaultException CreateFault(MessageFault messageFault, Type[] faultDetailTypes);
    public static FaultException CreateFault(MessageFault messageFault, string action, Type[] faultDetailTypes);
    public virtual MessageFault CreateMessageFault();
    private static FaultReason CreateReason(string reason);
    private static FaultReason GetReason(MessageFault fault);
    internal static string GetSafeReasonText(MessageFault messageFault);
    internal static string GetSafeReasonText(FaultReason reason);
    private static FaultCode EnsureCode(FaultCode code);
    private static FaultReason EnsureReason(FaultReason reason);
}
public class System.ServiceModel.FaultException`1 : FaultException {
    private TDetail _detail;
    public TDetail Detail { get; }
    public FaultException`1(TDetail detail);
    public FaultException`1(TDetail detail, string reason);
    public FaultException`1(TDetail detail, FaultReason reason);
    public FaultException`1(TDetail detail, string reason, FaultCode code);
    public FaultException`1(TDetail detail, FaultReason reason, FaultCode code);
    public FaultException`1(TDetail detail, string reason, FaultCode code, string action);
    public FaultException`1(TDetail detail, FaultReason reason, FaultCode code, string action);
    protected FaultException`1(SerializationInfo info, StreamingContext context);
    public TDetail get_Detail();
    public virtual MessageFault CreateMessageFault();
    public virtual string ToString();
}
public class System.ServiceModel.FaultReason : object {
    private SynchronizedReadOnlyCollection`1<FaultReasonText> _translations;
    public SynchronizedReadOnlyCollection`1<FaultReasonText> Translations { get; }
    public FaultReason(FaultReasonText translation);
    public FaultReason(string text);
    internal FaultReason(string text, string xmlLang);
    internal FaultReason(string text, CultureInfo cultureInfo);
    public FaultReason(IEnumerable`1<FaultReasonText> translations);
    private void Init(FaultReasonText translation);
    private void Init(FaultReasonText[] translations);
    public FaultReasonText GetMatchingTranslation();
    public FaultReasonText GetMatchingTranslation(CultureInfo cultureInfo);
    public SynchronizedReadOnlyCollection`1<FaultReasonText> get_Translations();
    public virtual string ToString();
}
public class System.ServiceModel.FaultReasonText : object {
    private string _xmlLang;
    private string _text;
    public string XmlLang { get; }
    public string Text { get; }
    public FaultReasonText(string text);
    public FaultReasonText(string text, string xmlLang);
    public FaultReasonText(string text, CultureInfo cultureInfo);
    public bool Matches(CultureInfo cultureInfo);
    public string get_XmlLang();
    public string get_Text();
}
public enum System.ServiceModel.HostNameComparisonMode : Enum {
    public int value__;
    public static HostNameComparisonMode StrongWildcard;
    public static HostNameComparisonMode Exact;
    public static HostNameComparisonMode WeakWildcard;
}
public static class System.ServiceModel.HostNameComparisonModeHelper : object {
    public static bool IsDefined(HostNameComparisonMode value);
    public static void Validate(HostNameComparisonMode value);
}
public abstract class System.ServiceModel.HttpBindingBase : Binding {
    private HttpTransportBindingElement _httpTransport;
    private HttpsTransportBindingElement _httpsTransport;
    private TextMessageEncodingBindingElement _textEncoding;
    [DefaultValueAttribute("False")]
public bool AllowCookies { get; public set; }
    [DefaultValueAttribute("False")]
public bool BypassProxyOnLocal { get; public set; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public HostNameComparisonMode HostNameComparisonMode { get; public set; }
    [DefaultValueAttribute("65536")]
public int MaxBufferSize { get; public set; }
    [DefaultValueAttribute("524288")]
public long MaxBufferPoolSize { get; public set; }
    [DefaultValueAttribute("65536")]
public long MaxReceivedMessageSize { get; public set; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
[TypeConverterAttribute("System.UriTypeConverter")]
public Uri ProxyAddress { get; public set; }
    public XmlDictionaryReaderQuotas ReaderQuotas { get; public set; }
    public string Scheme { get; }
    public EnvelopeVersion EnvelopeVersion { get; }
    public Encoding TextEncoding { get; public set; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public TransferMode TransferMode { get; public set; }
    [DefaultValueAttribute("True")]
public bool UseDefaultWebProxy { get; public set; }
    private bool System.ServiceModel.Channels.IBindingRuntimePreferences.ReceiveSynchronously { get; }
    internal TextMessageEncodingBindingElement TextMessageEncodingBindingElement { get; }
    internal BasicHttpSecurity BasicHttpSecurity { get; }
    internal WebSocketTransportSettings InternalWebSocketSettings { get; }
    public bool get_AllowCookies();
    public void set_AllowCookies(bool value);
    public bool get_BypassProxyOnLocal();
    public void set_BypassProxyOnLocal(bool value);
    public HostNameComparisonMode get_HostNameComparisonMode();
    public void set_HostNameComparisonMode(HostNameComparisonMode value);
    public int get_MaxBufferSize();
    public void set_MaxBufferSize(int value);
    public long get_MaxBufferPoolSize();
    public void set_MaxBufferPoolSize(long value);
    public long get_MaxReceivedMessageSize();
    public void set_MaxReceivedMessageSize(long value);
    public Uri get_ProxyAddress();
    public void set_ProxyAddress(Uri value);
    public XmlDictionaryReaderQuotas get_ReaderQuotas();
    public void set_ReaderQuotas(XmlDictionaryReaderQuotas value);
    public virtual string get_Scheme();
    public EnvelopeVersion get_EnvelopeVersion();
    public Encoding get_TextEncoding();
    public void set_TextEncoding(Encoding value);
    public TransferMode get_TransferMode();
    public void set_TransferMode(TransferMode value);
    public bool get_UseDefaultWebProxy();
    public void set_UseDefaultWebProxy(bool value);
    private sealed virtual override bool System.ServiceModel.Channels.IBindingRuntimePreferences.get_ReceiveSynchronously();
    internal TextMessageEncodingBindingElement get_TextMessageEncodingBindingElement();
    internal abstract virtual BasicHttpSecurity get_BasicHttpSecurity();
    internal WebSocketTransportSettings get_InternalWebSocketSettings();
    internal static bool GetSecurityModeFromTransport(HttpTransportBindingElement http, HttpTransportSecurity transportSecurity, UnifiedSecurityMode& mode);
    internal TransportBindingElement GetTransport();
    internal abstract virtual EnvelopeVersion GetEnvelopeVersion();
    internal virtual void SetReaderQuotas(XmlDictionaryReaderQuotas readerQuotas);
    internal virtual void CheckSettings();
}
public enum System.ServiceModel.HttpClientCredentialType : Enum {
    public int value__;
    public static HttpClientCredentialType None;
    public static HttpClientCredentialType Basic;
    public static HttpClientCredentialType Digest;
    public static HttpClientCredentialType Ntlm;
    public static HttpClientCredentialType Windows;
    public static HttpClientCredentialType Certificate;
    public static HttpClientCredentialType InheritedFromHost;
}
internal static class System.ServiceModel.HttpClientCredentialTypeHelper : object {
    internal static bool IsDefined(HttpClientCredentialType value);
    internal static AuthenticationSchemes MapToAuthenticationScheme(HttpClientCredentialType clientCredentialType);
    internal static HttpClientCredentialType MapToClientCredentialType(AuthenticationSchemes authenticationSchemes);
}
public enum System.ServiceModel.HttpProxyCredentialType : Enum {
    public int value__;
    public static HttpProxyCredentialType None;
    public static HttpProxyCredentialType Basic;
    public static HttpProxyCredentialType Digest;
    public static HttpProxyCredentialType Ntlm;
    public static HttpProxyCredentialType Windows;
}
internal static class System.ServiceModel.HttpProxyCredentialTypeHelper : object {
    internal static bool IsDefined(HttpProxyCredentialType value);
}
public class System.ServiceModel.HttpTransportSecurity : object {
    internal static HttpClientCredentialType DefaultClientCredentialType;
    internal static HttpProxyCredentialType DefaultProxyCredentialType;
    internal static string DefaultRealm;
    private HttpClientCredentialType _clientCredentialType;
    private HttpProxyCredentialType _proxyCredentialType;
    private string _realm;
    public HttpClientCredentialType ClientCredentialType { get; public set; }
    public HttpProxyCredentialType ProxyCredentialType { get; public set; }
    public string Realm { get; public set; }
    public HttpClientCredentialType get_ClientCredentialType();
    public void set_ClientCredentialType(HttpClientCredentialType value);
    public HttpProxyCredentialType get_ProxyCredentialType();
    public void set_ProxyCredentialType(HttpProxyCredentialType value);
    public string get_Realm();
    public void set_Realm(string value);
    internal void ConfigureTransportProtectionOnly(HttpsTransportBindingElement https);
    private void ConfigureAuthentication(HttpTransportBindingElement http);
    private static void ConfigureAuthentication(HttpTransportBindingElement http, HttpTransportSecurity transportSecurity);
    private void DisableAuthentication(HttpTransportBindingElement http);
    private static bool IsDisabledAuthentication(HttpTransportBindingElement http);
    internal void ConfigureTransportProtectionAndAuthentication(HttpsTransportBindingElement https);
    internal static void ConfigureTransportProtectionAndAuthentication(HttpsTransportBindingElement https, HttpTransportSecurity transportSecurity);
    internal void ConfigureTransportAuthentication(HttpTransportBindingElement http);
    internal static bool IsConfiguredTransportAuthentication(HttpTransportBindingElement http, HttpTransportSecurity transportSecurity);
    internal void DisableTransportAuthentication(HttpTransportBindingElement http);
    internal static bool IsDisabledTransportAuthentication(HttpTransportBindingElement http);
}
public interface System.ServiceModel.IAsyncCommunicationObject {
    public abstract virtual Task CloseAsync(TimeSpan timeout);
    public abstract virtual Task OpenAsync(TimeSpan timeout);
}
internal interface System.ServiceModel.IChannelBaseProxy {
    public abstract virtual ServiceChannel GetServiceChannel();
}
public interface System.ServiceModel.IClientChannel {
    public bool AllowInitializationUI { get; public set; }
    public bool DidInteractiveInitialization { get; }
    public Uri Via { get; }
    public abstract virtual bool get_AllowInitializationUI();
    public abstract virtual void set_AllowInitializationUI(bool value);
    public abstract virtual bool get_DidInteractiveInitialization();
    public abstract virtual Uri get_Via();
    [CompilerGeneratedAttribute]
public abstract virtual void add_UnknownMessageReceived(EventHandler`1<UnknownMessageReceivedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_UnknownMessageReceived(EventHandler`1<UnknownMessageReceivedEventArgs> value);
    public abstract virtual void DisplayInitializationUI();
    public abstract virtual IAsyncResult BeginDisplayInitializationUI(AsyncCallback callback, object state);
    public abstract virtual void EndDisplayInitializationUI(IAsyncResult result);
}
public interface System.ServiceModel.ICommunicationObject {
    public CommunicationState State { get; }
    public abstract virtual CommunicationState get_State();
    [CompilerGeneratedAttribute]
public abstract virtual void add_Closed(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Closed(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_Closing(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Closing(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_Faulted(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Faulted(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_Opened(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Opened(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_Opening(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Opening(EventHandler value);
    public abstract virtual void Abort();
    public abstract virtual void Close();
    public abstract virtual void Close(TimeSpan timeout);
    public abstract virtual IAsyncResult BeginClose(AsyncCallback callback, object state);
    public abstract virtual IAsyncResult BeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    public abstract virtual void EndClose(IAsyncResult result);
    public abstract virtual void Open();
    public abstract virtual void Open(TimeSpan timeout);
    public abstract virtual IAsyncResult BeginOpen(AsyncCallback callback, object state);
    public abstract virtual IAsyncResult BeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    public abstract virtual void EndOpen(IAsyncResult result);
}
public interface System.ServiceModel.IContextChannel {
    public bool AllowOutputBatching { get; public set; }
    public IInputSession InputSession { get; }
    public EndpointAddress LocalAddress { get; }
    public TimeSpan OperationTimeout { get; public set; }
    public IOutputSession OutputSession { get; }
    public EndpointAddress RemoteAddress { get; }
    public string SessionId { get; }
    public abstract virtual bool get_AllowOutputBatching();
    public abstract virtual void set_AllowOutputBatching(bool value);
    public abstract virtual IInputSession get_InputSession();
    public abstract virtual EndpointAddress get_LocalAddress();
    public abstract virtual TimeSpan get_OperationTimeout();
    public abstract virtual void set_OperationTimeout(TimeSpan value);
    public abstract virtual IOutputSession get_OutputSession();
    public abstract virtual EndpointAddress get_RemoteAddress();
    public abstract virtual string get_SessionId();
}
internal interface System.ServiceModel.IContextSessionProvider {
}
public interface System.ServiceModel.IDefaultCommunicationTimeouts {
    public TimeSpan CloseTimeout { get; }
    public TimeSpan OpenTimeout { get; }
    public TimeSpan ReceiveTimeout { get; }
    public TimeSpan SendTimeout { get; }
    public abstract virtual TimeSpan get_CloseTimeout();
    public abstract virtual TimeSpan get_OpenTimeout();
    public abstract virtual TimeSpan get_ReceiveTimeout();
    public abstract virtual TimeSpan get_SendTimeout();
}
public interface System.ServiceModel.IDuplexContextChannel {
    public bool AutomaticInputSessionShutdown { get; public set; }
    public InstanceContext CallbackInstance { get; public set; }
    public abstract virtual bool get_AutomaticInputSessionShutdown();
    public abstract virtual void set_AutomaticInputSessionShutdown(bool value);
    public abstract virtual InstanceContext get_CallbackInstance();
    public abstract virtual void set_CallbackInstance(InstanceContext value);
    public abstract virtual IAsyncResult BeginCloseOutputSession(TimeSpan timeout, AsyncCallback callback, object state);
    public abstract virtual void EndCloseOutputSession(IAsyncResult result);
    public abstract virtual void CloseOutputSession(TimeSpan timeout);
}
public interface System.ServiceModel.IExtensibleObject`1 {
    public IExtensionCollection`1<T> Extensions { get; }
    public abstract virtual IExtensionCollection`1<T> get_Extensions();
}
public interface System.ServiceModel.IExtension`1 {
    public abstract virtual void Attach(T owner);
    public abstract virtual void Detach(T owner);
}
public interface System.ServiceModel.IExtensionCollection`1 {
    public abstract virtual E Find();
    public abstract virtual Collection`1<E> FindAll();
}
public enum System.ServiceModel.ImpersonationOption : Enum {
    public int value__;
    public static ImpersonationOption NotAllowed;
    public static ImpersonationOption Allowed;
    public static ImpersonationOption Required;
}
internal static class System.ServiceModel.ImpersonationOptionHelper : object {
    public static bool IsDefined(ImpersonationOption option);
    internal static bool AllowedOrRequired(ImpersonationOption option);
}
public class System.ServiceModel.InstanceContext : CommunicationObject {
    private InstanceBehavior _behavior;
    private ConcurrencyInstanceContextFacet _concurrency;
    private ServiceChannelManager _channels;
    private ExtensionCollection`1<InstanceContext> _extensions;
    private object _serviceInstanceLock;
    private SynchronizationContext _synchronizationContext;
    private object _userObject;
    private bool _wellKnown;
    private SynchronizedCollection`1<IChannel> _wmiChannels;
    private bool _isUserCreated;
    internal InstanceBehavior Behavior { get; internal set; }
    internal ConcurrencyInstanceContextFacet Concurrency { get; }
    protected TimeSpan DefaultCloseTimeout { get; }
    protected TimeSpan DefaultOpenTimeout { get; }
    public IExtensionCollection`1<InstanceContext> Extensions { get; }
    public ICollection`1<IChannel> IncomingChannels { get; }
    public ICollection`1<IChannel> OutgoingChannels { get; }
    public SynchronizationContext SynchronizationContext { get; public set; }
    internal object ThisLock { get; }
    internal object UserObject { get; }
    internal ICollection`1<IChannel> WmiChannels { get; }
    public InstanceContext(object implementation);
    internal InstanceContext(object implementation, bool isUserCreated);
    internal InstanceContext(object implementation, bool wellKnown, bool isUserCreated);
    internal InstanceBehavior get_Behavior();
    internal void set_Behavior(InstanceBehavior value);
    internal ConcurrencyInstanceContextFacet get_Concurrency();
    protected virtual TimeSpan get_DefaultCloseTimeout();
    protected virtual TimeSpan get_DefaultOpenTimeout();
    public sealed virtual IExtensionCollection`1<InstanceContext> get_Extensions();
    public ICollection`1<IChannel> get_IncomingChannels();
    public ICollection`1<IChannel> get_OutgoingChannels();
    public SynchronizationContext get_SynchronizationContext();
    public void set_SynchronizationContext(SynchronizationContext value);
    internal object get_ThisLock();
    internal object get_UserObject();
    internal ICollection`1<IChannel> get_WmiChannels();
    protected virtual void OnAbort();
    internal void BindRpc(MessageRpc& rpc);
    internal void FaultInternal();
    public object GetServiceInstance(Message message);
    protected virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndClose(IAsyncResult result);
    protected virtual IAsyncResult OnBeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndOpen(IAsyncResult result);
    protected virtual void OnClose(TimeSpan timeout);
    protected virtual void OnOpen(TimeSpan timeout);
    protected virtual void OnOpened();
    protected virtual void OnOpening();
    protected internal virtual Task OnCloseAsync(TimeSpan timeout);
    protected internal virtual Task OnOpenAsync(TimeSpan timeout);
    private void SetUserObject(object newUserObject);
    internal void UnbindRpc(MessageRpc& rpc);
}
internal class System.ServiceModel.InstanceContextEmptyCallback : MulticastDelegate {
    public InstanceContextEmptyCallback(object object, IntPtr method);
    public virtual void Invoke(InstanceContext instanceContext);
    public virtual IAsyncResult BeginInvoke(InstanceContext instanceContext, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum System.ServiceModel.InstanceContextMode : Enum {
    public int value__;
    public static InstanceContextMode PerSession;
    public static InstanceContextMode PerCall;
    public static InstanceContextMode Single;
}
internal static class System.ServiceModel.InstanceContextModeHelper : object {
    public static bool IsDefined(InstanceContextMode x);
}
public class System.ServiceModel.InvalidMessageContractException : Exception {
    public InvalidMessageContractException(string message);
    public InvalidMessageContractException(string message, Exception innerException);
    protected InvalidMessageContractException(SerializationInfo info, StreamingContext context);
}
internal interface System.ServiceModel.IOperationContractAttributeProvider {
    public abstract virtual OperationContractAttribute GetOperationContractAttribute();
}
public interface System.ServiceModel.IServiceChannel {
    public Uri ListenUri { get; }
    public abstract virtual Uri get_ListenUri();
}
internal class System.ServiceModel.KerberosSecurityTokenProviderWrapper : CommunicationObjectSecurityTokenProvider {
    private KerberosSecurityTokenProvider _innerProvider;
    public KerberosSecurityTokenProviderWrapper(KerberosSecurityTokenProvider innerProvider);
    internal Task`1<SecurityToken> GetTokenAsync(CancellationToken cancellationToken, ChannelBinding channelbinding);
    protected virtual Task`1<SecurityToken> GetTokenCoreAsync(CancellationToken cancellationToken);
}
internal class System.ServiceModel.Message11Dictionary : object {
    public XmlDictionaryString Namespace;
    public XmlDictionaryString Actor;
    public XmlDictionaryString FaultCode;
    public XmlDictionaryString FaultString;
    public XmlDictionaryString FaultActor;
    public XmlDictionaryString FaultDetail;
    public XmlDictionaryString FaultNamespace;
    public Message11Dictionary(ServiceModelDictionary dictionary);
}
internal static class System.ServiceModel.Message11Strings : object {
    public static string Namespace;
    public static string Actor;
    public static string FaultCode;
    public static string FaultString;
    public static string FaultActor;
    public static string FaultDetail;
    public static string FaultNamespace;
}
internal class System.ServiceModel.Message12Dictionary : object {
    public XmlDictionaryString Namespace;
    public XmlDictionaryString Role;
    public XmlDictionaryString Relay;
    public XmlDictionaryString FaultCode;
    public XmlDictionaryString FaultReason;
    public XmlDictionaryString FaultText;
    public XmlDictionaryString FaultNode;
    public XmlDictionaryString FaultRole;
    public XmlDictionaryString FaultDetail;
    public XmlDictionaryString FaultValue;
    public XmlDictionaryString FaultSubcode;
    public XmlDictionaryString NotUnderstood;
    public XmlDictionaryString QName;
    public Message12Dictionary(ServiceModelDictionary dictionary);
}
internal static class System.ServiceModel.Message12Strings : object {
    public static string Namespace;
    public static string Role;
    public static string Relay;
    public static string FaultCode;
    public static string FaultReason;
    public static string FaultText;
    public static string FaultNode;
    public static string FaultRole;
    public static string FaultDetail;
    public static string FaultValue;
    public static string FaultSubcode;
    public static string NotUnderstood;
    public static string QName;
}
[AttributeUsageAttribute("384")]
public class System.ServiceModel.MessageBodyMemberAttribute : MessageContractMemberAttribute {
    private int _order;
    internal static string OrderPropertyName;
    public int Order { get; public set; }
    public int get_Order();
    public void set_Order(int value);
}
[AttributeUsageAttribute("12")]
public class System.ServiceModel.MessageContractAttribute : Attribute {
    private bool _isWrapped;
    private string _wrappedName;
    private string _wrappedNs;
    private ProtectionLevel _protectionLevel;
    private bool _hasProtectionLevel;
    internal static string ProtectionLevelPropertyName;
    public ProtectionLevel ProtectionLevel { get; public set; }
    public bool HasProtectionLevel { get; }
    public bool IsWrapped { get; public set; }
    public string WrapperName { get; public set; }
    public string WrapperNamespace { get; public set; }
    public ProtectionLevel get_ProtectionLevel();
    public void set_ProtectionLevel(ProtectionLevel value);
    public bool get_HasProtectionLevel();
    public bool get_IsWrapped();
    public void set_IsWrapped(bool value);
    public string get_WrapperName();
    public void set_WrapperName(string value);
    public string get_WrapperNamespace();
    public void set_WrapperNamespace(string value);
}
public abstract class System.ServiceModel.MessageContractMemberAttribute : Attribute {
    private string _name;
    private string _ns;
    private bool _isNameSetExplicit;
    private bool _isNamespaceSetExplicit;
    private ProtectionLevel _protectionLevel;
    private bool _hasProtectionLevel;
    internal static string NamespacePropertyName;
    internal static string NamePropertyName;
    internal static string ProtectionLevelPropertyName;
    public string Namespace { get; public set; }
    internal bool IsNamespaceSetExplicit { get; }
    public string Name { get; public set; }
    internal bool IsNameSetExplicit { get; }
    public ProtectionLevel ProtectionLevel { get; public set; }
    public bool HasProtectionLevel { get; }
    public string get_Namespace();
    public void set_Namespace(string value);
    internal bool get_IsNamespaceSetExplicit();
    public string get_Name();
    public void set_Name(string value);
    internal bool get_IsNameSetExplicit();
    public ProtectionLevel get_ProtectionLevel();
    public void set_ProtectionLevel(ProtectionLevel value);
    public bool get_HasProtectionLevel();
}
public enum System.ServiceModel.MessageCredentialType : Enum {
    public int value__;
    public static MessageCredentialType None;
    public static MessageCredentialType Windows;
    public static MessageCredentialType UserName;
    public static MessageCredentialType Certificate;
    public static MessageCredentialType IssuedToken;
}
internal static class System.ServiceModel.MessageCredentialTypeHelper : object {
    internal static bool IsDefined(MessageCredentialType value);
}
internal class System.ServiceModel.MessageDictionary : object {
    public XmlDictionaryString MustUnderstand;
    public XmlDictionaryString Envelope;
    public XmlDictionaryString Header;
    public XmlDictionaryString Body;
    public XmlDictionaryString Prefix;
    public XmlDictionaryString Fault;
    public XmlDictionaryString MustUnderstandFault;
    public XmlDictionaryString Namespace;
    public MessageDictionary(ServiceModelDictionary dictionary);
}
public class System.ServiceModel.MessageHeader`1 : object {
    private string _actor;
    private bool _mustUnderstand;
    private bool _relay;
    private T _content;
    public string Actor { get; public set; }
    public T Content { get; public set; }
    public bool MustUnderstand { get; public set; }
    public bool Relay { get; public set; }
    public MessageHeader`1(T content);
    public MessageHeader`1(T content, bool mustUnderstand, string actor, bool relay);
    public string get_Actor();
    public void set_Actor(string value);
    public T get_Content();
    public void set_Content(T value);
    public bool get_MustUnderstand();
    public void set_MustUnderstand(bool value);
    public bool get_Relay();
    public void set_Relay(bool value);
    internal Type GetGenericArgument();
    public MessageHeader GetUntypedHeader(string name, string ns);
}
[AttributeUsageAttribute("384")]
public class System.ServiceModel.MessageHeaderArrayAttribute : MessageHeaderAttribute {
}
[AttributeUsageAttribute("384")]
public class System.ServiceModel.MessageHeaderAttribute : MessageContractMemberAttribute {
    private bool _mustUnderstand;
    private bool _isMustUnderstandSet;
    private bool _relay;
    private bool _isRelaySet;
    private string _actor;
    public bool MustUnderstand { get; public set; }
    public bool Relay { get; public set; }
    public string Actor { get; public set; }
    internal bool IsMustUnderstandSet { get; }
    internal bool IsRelaySet { get; }
    public bool get_MustUnderstand();
    public void set_MustUnderstand(bool value);
    public bool get_Relay();
    public void set_Relay(bool value);
    public string get_Actor();
    public void set_Actor(string value);
    internal bool get_IsMustUnderstandSet();
    internal bool get_IsRelaySet();
}
public class System.ServiceModel.MessageHeaderException : ProtocolException {
    private string _headerName;
    private string _headerNamespace;
    private bool _isDuplicate;
    public string HeaderName { get; }
    public string HeaderNamespace { get; }
    public bool IsDuplicate { get; }
    public MessageHeaderException(string message);
    public MessageHeaderException(string message, bool isDuplicate);
    public MessageHeaderException(string message, Exception innerException);
    public MessageHeaderException(string message, string headerName, string ns);
    public MessageHeaderException(string message, string headerName, string ns, bool isDuplicate);
    public MessageHeaderException(string message, string headerName, string ns, Exception innerException);
    public MessageHeaderException(string message, string headerName, string ns, bool isDuplicate, Exception innerException);
    protected MessageHeaderException(SerializationInfo info, StreamingContext context);
    public string get_HeaderName();
    public string get_HeaderNamespace();
    public bool get_IsDuplicate();
    internal Message ProvideFault(MessageVersion messageVersion);
}
[AttributeUsageAttribute("10240")]
public class System.ServiceModel.MessageParameterAttribute : Attribute {
    private string _name;
    private bool _isNameSetExplicit;
    internal static string NamePropertyName;
    public string Name { get; public set; }
    internal bool IsNameSetExplicit { get; }
    public string get_Name();
    public void set_Name(string value);
    internal bool get_IsNameSetExplicit();
}
[AttributeUsageAttribute("384")]
public class System.ServiceModel.MessagePropertyAttribute : Attribute {
    private string _name;
    private bool _isNameSetExplicit;
    public string Name { get; public set; }
    internal bool IsNameSetExplicit { get; }
    public string get_Name();
    public void set_Name(string value);
    internal bool get_IsNameSetExplicit();
}
public class System.ServiceModel.MessageSecurityOverTcp : object {
    internal static MessageCredentialType DefaultClientCredentialType;
    private MessageCredentialType _messageCredentialType;
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public MessageCredentialType ClientCredentialType { get; public set; }
    public MessageCredentialType get_ClientCredentialType();
    public void set_ClientCredentialType(MessageCredentialType value);
    internal bool InternalShouldSerialize();
}
public abstract class System.ServiceModel.MessageSecurityVersion : object {
    public static MessageSecurityVersion WSSecurity11WSTrustFebruary2005WSSecureConversationFebruary2005WSSecurityPolicy11 { get; }
    public static MessageSecurityVersion WSSecurity10WSTrustFebruary2005WSSecureConversationFebruary2005WSSecurityPolicy11BasicSecurityProfile10 { get; }
    public static MessageSecurityVersion WSSecurity11WSTrustFebruary2005WSSecureConversationFebruary2005WSSecurityPolicy11BasicSecurityProfile10 { get; }
    public static MessageSecurityVersion WSSecurity11WSTrust13WSSecureConversation13WSSecurityPolicy12 { get; }
    public static MessageSecurityVersion WSSecurity10WSTrust13WSSecureConversation13WSSecurityPolicy12BasicSecurityProfile10 { get; }
    public static MessageSecurityVersion WSSecurity11WSTrust13WSSecureConversation13WSSecurityPolicy12BasicSecurityProfile10 { get; }
    public static MessageSecurityVersion Default { get; }
    internal static MessageSecurityVersion WSSXDefault { get; }
    public SecurityVersion SecurityVersion { get; }
    public TrustVersion TrustVersion { get; }
    public SecureConversationVersion SecureConversationVersion { get; }
    public SecurityTokenVersion SecurityTokenVersion { get; }
    public SecurityPolicyVersion SecurityPolicyVersion { get; }
    public BasicSecurityProfileVersion BasicSecurityProfileVersion { get; }
    internal MessageSecurityTokenVersion MessageSecurityTokenVersion { get; }
    public static MessageSecurityVersion get_WSSecurity11WSTrustFebruary2005WSSecureConversationFebruary2005WSSecurityPolicy11();
    public static MessageSecurityVersion get_WSSecurity10WSTrustFebruary2005WSSecureConversationFebruary2005WSSecurityPolicy11BasicSecurityProfile10();
    public static MessageSecurityVersion get_WSSecurity11WSTrustFebruary2005WSSecureConversationFebruary2005WSSecurityPolicy11BasicSecurityProfile10();
    public static MessageSecurityVersion get_WSSecurity11WSTrust13WSSecureConversation13WSSecurityPolicy12();
    public static MessageSecurityVersion get_WSSecurity10WSTrust13WSSecureConversation13WSSecurityPolicy12BasicSecurityProfile10();
    public static MessageSecurityVersion get_WSSecurity11WSTrust13WSSecureConversation13WSSecurityPolicy12BasicSecurityProfile10();
    public static MessageSecurityVersion get_Default();
    internal static MessageSecurityVersion get_WSSXDefault();
    public SecurityVersion get_SecurityVersion();
    public TrustVersion get_TrustVersion();
    public SecureConversationVersion get_SecureConversationVersion();
    public SecurityTokenVersion get_SecurityTokenVersion();
    public abstract virtual SecurityPolicyVersion get_SecurityPolicyVersion();
    public abstract virtual BasicSecurityProfileVersion get_BasicSecurityProfileVersion();
    internal abstract virtual MessageSecurityTokenVersion get_MessageSecurityTokenVersion();
}
internal static class System.ServiceModel.MessageStrings : object {
    public static string MustUnderstand;
    public static string Envelope;
    public static string Header;
    public static string Body;
    public static string Prefix;
    public static string Fault;
    public static string MustUnderstandFault;
    public static string Namespace;
}
internal class System.ServiceModel.MustUnderstandSoapException : CommunicationException {
    private Collection`1<MessageHeaderInfo> _notUnderstoodHeaders;
    private EnvelopeVersion _envelopeVersion;
    public Collection`1<MessageHeaderInfo> NotUnderstoodHeaders { get; }
    public EnvelopeVersion EnvelopeVersion { get; }
    protected MustUnderstandSoapException(SerializationInfo info, StreamingContext context);
    public MustUnderstandSoapException(Collection`1<MessageHeaderInfo> notUnderstoodHeaders, EnvelopeVersion envelopeVersion);
    public Collection`1<MessageHeaderInfo> get_NotUnderstoodHeaders();
    public EnvelopeVersion get_EnvelopeVersion();
    internal Message ProvideFault(MessageVersion messageVersion);
    private void AddNotUnderstoodHeaders(MessageHeaders headers);
}
public class System.ServiceModel.NetHttpBinding : HttpBindingBase {
    private BinaryMessageEncodingBindingElement _binaryMessageEncodingBindingElement;
    private NetHttpMessageEncoding _messageEncoding;
    private BasicHttpSecurity _basicHttpSecurity;
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public NetHttpMessageEncoding MessageEncoding { get; public set; }
    public BasicHttpSecurity Security { get; public set; }
    public WebSocketTransportSettings WebSocketSettings { get; }
    internal BasicHttpSecurity BasicHttpSecurity { get; }
    public NetHttpBinding(BasicHttpSecurityMode securityMode);
    public NetHttpBinding(string configurationName);
    private NetHttpBinding(BasicHttpSecurity security);
    public NetHttpMessageEncoding get_MessageEncoding();
    public void set_MessageEncoding(NetHttpMessageEncoding value);
    public BasicHttpSecurity get_Security();
    public void set_Security(BasicHttpSecurity value);
    public WebSocketTransportSettings get_WebSocketSettings();
    internal virtual BasicHttpSecurity get_BasicHttpSecurity();
    public virtual IChannelFactory`1<TChannel> BuildChannelFactory(BindingParameterCollection parameters);
    public virtual BindingElementCollection CreateBindingElements();
    internal virtual void SetReaderQuotas(XmlDictionaryReaderQuotas readerQuotas);
    internal virtual EnvelopeVersion GetEnvelopeVersion();
    internal virtual void CheckSettings();
    private void Initialize();
}
public enum System.ServiceModel.NetHttpMessageEncoding : Enum {
    public int value__;
    public static NetHttpMessageEncoding Binary;
    public static NetHttpMessageEncoding Text;
    public static NetHttpMessageEncoding Mtom;
}
internal static class System.ServiceModel.NetHttpMessageEncodingHelper : object {
    internal static bool IsDefined(NetHttpMessageEncoding value);
}
public class System.ServiceModel.NetHttpsBinding : HttpBindingBase {
    private BinaryMessageEncodingBindingElement _binaryMessageEncodingBindingElement;
    private NetHttpMessageEncoding _messageEncoding;
    private BasicHttpsSecurity _basicHttpsSecurity;
    public NetHttpMessageEncoding MessageEncoding { get; public set; }
    public BasicHttpsSecurity Security { get; public set; }
    internal BasicHttpSecurity BasicHttpSecurity { get; }
    public WebSocketTransportSettings WebSocketSettings { get; }
    public NetHttpsBinding(BasicHttpsSecurityMode securityMode);
    public NetHttpMessageEncoding get_MessageEncoding();
    public void set_MessageEncoding(NetHttpMessageEncoding value);
    public BasicHttpsSecurity get_Security();
    public void set_Security(BasicHttpsSecurity value);
    internal virtual BasicHttpSecurity get_BasicHttpSecurity();
    public WebSocketTransportSettings get_WebSocketSettings();
    public virtual IChannelFactory`1<TChannel> BuildChannelFactory(BindingParameterCollection parameters);
    public virtual BindingElementCollection CreateBindingElements();
    internal virtual void SetReaderQuotas(XmlDictionaryReaderQuotas readerQuotas);
    internal virtual EnvelopeVersion GetEnvelopeVersion();
    internal virtual void CheckSettings();
    private void Initialize();
}
public class System.ServiceModel.NetTcpBinding : Binding {
    private TcpTransportBindingElement _transport;
    private BinaryMessageEncodingBindingElement _encoding;
    private long _maxBufferPoolSize;
    private NetTcpSecurity _security;
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public TransferMode TransferMode { get; public set; }
    [DefaultValueAttribute("524288")]
public long MaxBufferPoolSize { get; public set; }
    [DefaultValueAttribute("65536")]
public int MaxBufferSize { get; public set; }
    [DefaultValueAttribute("65536")]
public long MaxReceivedMessageSize { get; public set; }
    public XmlDictionaryReaderQuotas ReaderQuotas { get; public set; }
    public string Scheme { get; }
    public EnvelopeVersion EnvelopeVersion { get; }
    public NetTcpSecurity Security { get; public set; }
    public NetTcpBinding(SecurityMode securityMode);
    public NetTcpBinding(string configurationName);
    private NetTcpBinding(TcpTransportBindingElement transport, BinaryMessageEncodingBindingElement encoding, NetTcpSecurity security);
    public TransferMode get_TransferMode();
    public void set_TransferMode(TransferMode value);
    public long get_MaxBufferPoolSize();
    public void set_MaxBufferPoolSize(long value);
    public int get_MaxBufferSize();
    public void set_MaxBufferSize(int value);
    public long get_MaxReceivedMessageSize();
    public void set_MaxReceivedMessageSize(long value);
    public XmlDictionaryReaderQuotas get_ReaderQuotas();
    public void set_ReaderQuotas(XmlDictionaryReaderQuotas value);
    public virtual string get_Scheme();
    public EnvelopeVersion get_EnvelopeVersion();
    public NetTcpSecurity get_Security();
    public void set_Security(NetTcpSecurity value);
    private void Initialize();
    private bool IsBindingElementsMatch(TcpTransportBindingElement transport, BinaryMessageEncodingBindingElement encoding);
    private void CheckSettings();
    public virtual BindingElementCollection CreateBindingElements();
    private BindingElement CreateTransportSecurity();
    private static UnifiedSecurityMode GetModeFromTransportSecurity(BindingElement transport);
    private static bool SetTransportSecurity(BindingElement transport, SecurityMode mode, TcpTransportSecurity transportSecurity);
    private SecurityBindingElement CreateMessageSecurity();
}
public class System.ServiceModel.NetTcpSecurity : object {
    internal static SecurityMode DefaultMode;
    private SecurityMode _mode;
    private TcpTransportSecurity _transportSecurity;
    private MessageSecurityOverTcp _messageSecurity;
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public SecurityMode Mode { get; public set; }
    public TcpTransportSecurity Transport { get; public set; }
    public MessageSecurityOverTcp Message { get; public set; }
    private NetTcpSecurity(SecurityMode mode, TcpTransportSecurity transportSecurity, MessageSecurityOverTcp messageSecurity);
    public SecurityMode get_Mode();
    public void set_Mode(SecurityMode value);
    public TcpTransportSecurity get_Transport();
    public void set_Transport(TcpTransportSecurity value);
    public MessageSecurityOverTcp get_Message();
    public void set_Message(MessageSecurityOverTcp value);
    internal BindingElement CreateTransportSecurity();
    internal static UnifiedSecurityMode GetModeFromTransportSecurity(BindingElement transport);
    internal static bool SetTransportSecurity(BindingElement transport, SecurityMode mode, TcpTransportSecurity transportSecurity);
}
internal static class System.ServiceModel.OleTxTransactionExternalStrings : object {
    public static string Namespace;
    public static string Prefix;
    public static string OleTxTransaction;
    public static string PropagationToken;
}
internal class System.ServiceModel.OpenCollectionAsyncResult : AsyncResult {
    private bool _completedSynchronously;
    private Exception _exception;
    private static AsyncCallback s_nestedCallback;
    private int _count;
    private TimeoutHelper _timeoutHelper;
    public OpenCollectionAsyncResult(TimeSpan timeout, AsyncCallback otherCallback, object state, IList`1<ICommunicationObject> collection);
    private static OpenCollectionAsyncResult();
    private static void Callback(IAsyncResult result);
    private void Decrement(bool completedSynchronously);
    private void Decrement(bool completedSynchronously, Exception exception);
    public static void End(IAsyncResult result);
}
public class System.ServiceModel.OperationContext : object {
    [ThreadStaticAttribute]
private static Holder s_currentContext;
    private ServiceChannel _channel;
    private Message _clientReply;
    private bool _closeClientReply;
    private ExtensionCollection`1<OperationContext> _extensions;
    private RequestContext _requestContext;
    private Message _request;
    private InstanceContext _instanceContext;
    private bool _isServiceReentrant;
    internal IPrincipal threadPrincipal;
    private MessageProperties _outgoingMessageProperties;
    private MessageHeaders _outgoingMessageHeaders;
    private MessageVersion _outgoingMessageVersion;
    private EndpointDispatcher _endpointDispatcher;
    [CompilerGeneratedAttribute]
private EventHandler OperationCompleted;
    [CompilerGeneratedAttribute]
private ClaimsPrincipal <ClaimsPrincipal>k__BackingField;
    public IContextChannel Channel { get; }
    public static OperationContext Current { get; public set; }
    internal static Holder CurrentHolder { get; }
    public EndpointDispatcher EndpointDispatcher { get; public set; }
    public bool IsUserContext { get; }
    public IExtensionCollection`1<OperationContext> Extensions { get; }
    internal bool IsServiceReentrant { get; internal set; }
    internal Message IncomingMessage { get; }
    internal ServiceChannel InternalServiceChannel { get; internal set; }
    internal bool HasOutgoingMessageHeaders { get; }
    public MessageHeaders OutgoingMessageHeaders { get; }
    internal bool HasOutgoingMessageProperties { get; }
    public MessageProperties OutgoingMessageProperties { get; }
    internal MessageVersion OutgoingMessageVersion { get; }
    public MessageHeaders IncomingMessageHeaders { get; }
    public MessageProperties IncomingMessageProperties { get; }
    public MessageVersion IncomingMessageVersion { get; }
    public InstanceContext InstanceContext { get; }
    public RequestContext RequestContext { get; public set; }
    public string SessionId { get; }
    internal IPrincipal ThreadPrincipal { get; internal set; }
    public ClaimsPrincipal ClaimsPrincipal { get; internal set; }
    public OperationContext(IContextChannel channel);
    internal OperationContext(MessageVersion outgoingMessageVersion);
    internal OperationContext(RequestContext requestContext, Message request, ServiceChannel channel);
    [CompilerGeneratedAttribute]
public void add_OperationCompleted(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_OperationCompleted(EventHandler value);
    public IContextChannel get_Channel();
    public static OperationContext get_Current();
    public static void set_Current(OperationContext value);
    internal static Holder get_CurrentHolder();
    public EndpointDispatcher get_EndpointDispatcher();
    public void set_EndpointDispatcher(EndpointDispatcher value);
    public bool get_IsUserContext();
    public sealed virtual IExtensionCollection`1<OperationContext> get_Extensions();
    internal bool get_IsServiceReentrant();
    internal void set_IsServiceReentrant(bool value);
    internal Message get_IncomingMessage();
    internal ServiceChannel get_InternalServiceChannel();
    internal void set_InternalServiceChannel(ServiceChannel value);
    internal bool get_HasOutgoingMessageHeaders();
    public MessageHeaders get_OutgoingMessageHeaders();
    internal bool get_HasOutgoingMessageProperties();
    public MessageProperties get_OutgoingMessageProperties();
    internal MessageVersion get_OutgoingMessageVersion();
    public MessageHeaders get_IncomingMessageHeaders();
    public MessageProperties get_IncomingMessageProperties();
    public MessageVersion get_IncomingMessageVersion();
    public InstanceContext get_InstanceContext();
    public RequestContext get_RequestContext();
    public void set_RequestContext(RequestContext value);
    public string get_SessionId();
    internal IPrincipal get_ThreadPrincipal();
    internal void set_ThreadPrincipal(IPrincipal value);
    [CompilerGeneratedAttribute]
public ClaimsPrincipal get_ClaimsPrincipal();
    [CompilerGeneratedAttribute]
internal void set_ClaimsPrincipal(ClaimsPrincipal value);
    internal void ClearClientReplyNoThrow();
    internal void FireOperationCompleted();
    public T GetCallbackChannel();
    internal void ReInit(RequestContext requestContext, Message request, ServiceChannel channel);
    internal void Recycle();
    internal void SetClientReply(Message message, bool closeMessage);
    internal void SetInstanceContext(InstanceContext instanceContext);
}
public class System.ServiceModel.OperationContextScope : object {
    [ThreadStaticAttribute]
private static OperationContextScope s_currentScope;
    private OperationContext _currentContext;
    private bool _disposed;
    private OperationContext _originalContext;
    private OperationContextScope _originalScope;
    public OperationContextScope(IContextChannel channel);
    public OperationContextScope(OperationContext context);
    public sealed virtual void Dispose();
    private void PushContext(OperationContext context);
    private void PopContext();
}
[AttributeUsageAttribute("64")]
public class System.ServiceModel.OperationContractAttribute : Attribute {
    private string _name;
    private string _action;
    private string _replyAction;
    private bool _asyncPattern;
    private bool _isInitiating;
    private bool _isTerminating;
    private bool _isOneWay;
    private ProtectionLevel _protectionLevel;
    private bool _hasProtectionLevel;
    internal static string ActionPropertyName;
    internal static string ProtectionLevelPropertyName;
    internal static string ReplyActionPropertyName;
    public string Name { get; public set; }
    public string Action { get; public set; }
    public ProtectionLevel ProtectionLevel { get; public set; }
    public bool HasProtectionLevel { get; }
    public string ReplyAction { get; public set; }
    public bool AsyncPattern { get; public set; }
    public bool IsOneWay { get; public set; }
    public bool IsInitiating { get; public set; }
    public bool IsTerminating { get; public set; }
    internal bool IsSessionOpenNotificationEnabled { get; }
    public string get_Name();
    public void set_Name(string value);
    public string get_Action();
    public void set_Action(string value);
    public ProtectionLevel get_ProtectionLevel();
    public void set_ProtectionLevel(ProtectionLevel value);
    public bool get_HasProtectionLevel();
    public string get_ReplyAction();
    public void set_ReplyAction(string value);
    public bool get_AsyncPattern();
    public void set_AsyncPattern(bool value);
    public bool get_IsOneWay();
    public void set_IsOneWay(bool value);
    public bool get_IsInitiating();
    public void set_IsInitiating(bool value);
    public bool get_IsTerminating();
    public void set_IsTerminating(bool value);
    internal bool get_IsSessionOpenNotificationEnabled();
    internal void EnsureInvariants(MethodInfo methodInfo, string operationName);
}
public enum System.ServiceModel.OperationFormatStyle : Enum {
    public int value__;
    public static OperationFormatStyle Document;
    public static OperationFormatStyle Rpc;
}
internal static class System.ServiceModel.OperationFormatStyleHelper : object {
    public static bool IsDefined(OperationFormatStyle x);
}
public enum System.ServiceModel.OperationFormatUse : Enum {
    public int value__;
    public static OperationFormatUse Literal;
    public static OperationFormatUse Encoded;
}
internal static class System.ServiceModel.OperationFormatUseHelper : object {
    public static bool IsDefined(OperationFormatUse x);
}
[AttributeUsageAttribute("384")]
public class System.ServiceModel.PeerHopCountAttribute : MessageHeaderAttribute {
    public bool MustUnderstand { get; }
    public bool Relay { get; }
    public string Actor { get; }
    public string Namespace { get; }
    public string Name { get; }
    public ProtectionLevel ProtectionLevel { get; }
    public bool get_MustUnderstand();
    public bool get_Relay();
    public string get_Actor();
    public string get_Namespace();
    public string get_Name();
    public ProtectionLevel get_ProtectionLevel();
}
internal static class System.ServiceModel.PeerWireStringsStrings : object {
    public static string FloodAction;
    public static string LinkUtilityAction;
    public static string HopCount;
    public static string HopCountNamespace;
    public static string PeerVia;
    public static string Namespace;
    public static string Demuxer;
    public static string PeerTo;
}
internal static class System.ServiceModel.PolicyStrings : object {
    public static string Namespace;
}
public class System.ServiceModel.Pool`1 : object {
    private T[] _items;
    private int _count;
    public int Count { get; }
    public Pool`1(int maxCount);
    public int get_Count();
    public T Take();
    public bool Return(T item);
    public void Clear();
}
public class System.ServiceModel.ProtocolException : CommunicationException {
    public ProtocolException(string message);
    public ProtocolException(string message, Exception innerException);
    protected ProtocolException(SerializationInfo info, StreamingContext context);
    internal static ProtocolException ReceiveShutdownReturnedNonNull(Message message);
    internal static ProtocolException OneWayOperationReturnedNonNull(Message message);
}
public class System.ServiceModel.QuotaExceededException : Exception {
    public QuotaExceededException(string message);
    public QuotaExceededException(string message, Exception innerException);
    protected QuotaExceededException(SerializationInfo info, StreamingContext context);
}
public enum System.ServiceModel.ReceiveErrorHandling : Enum {
    public int value__;
    public static ReceiveErrorHandling Fault;
    public static ReceiveErrorHandling Drop;
    public static ReceiveErrorHandling Reject;
    public static ReceiveErrorHandling Move;
}
internal static class System.ServiceModel.ReceiveErrorHandlingHelper : object {
    internal static bool IsDefined(ReceiveErrorHandling value);
}
[ExtensionAttribute]
internal static class System.ServiceModel.ReflectionExtensions : object {
    [ExtensionAttribute]
public static Assembly Assembly(Type type);
    [ExtensionAttribute]
public static Type BaseType(Type type);
    [ExtensionAttribute]
public static bool ContainsGenericParameters(Type type);
    [ExtensionAttribute]
public static ConstructorInfo GetConstructor(Type type, Type[] types);
    [ExtensionAttribute]
public static ConstructorInfo GetConstructor(Type type, BindingFlags bindingAttr, object binder, Type[] types, Object[] modifiers);
    [ExtensionAttribute]
public static PropertyInfo GetProperty(Type type, string name, BindingFlags bindingAttr);
    [ExtensionAttribute]
public static Type[] GetGenericArguments(Type type);
    [ExtensionAttribute]
public static Type[] GetInterfaces(Type type);
    [ExtensionAttribute]
public static bool IsAbstract(Type type);
    [ExtensionAttribute]
public static bool IsAssignableFrom(Type type, Type otherType);
    [ExtensionAttribute]
public static bool IsClass(Type type);
    [ExtensionAttribute]
public static bool IsDefined(Type type, Type attributeType, bool inherit);
    [ExtensionAttribute]
public static bool IsEnum(Type type);
    [ExtensionAttribute]
public static bool IsGenericType(Type type);
    [ExtensionAttribute]
public static bool IsInterface(Type type);
    [ExtensionAttribute]
public static bool IsInstanceOfType(Type type, object o);
    [ExtensionAttribute]
public static bool IsMarshalByRef(Type type);
    [ExtensionAttribute]
public static bool IsNotPublic(Type type);
    [ExtensionAttribute]
public static bool IsSealed(Type type);
    [ExtensionAttribute]
public static bool IsValueType(Type type);
    [ExtensionAttribute]
public static InterfaceMapping GetInterfaceMap(Type type, Type interfaceType);
    [ExtensionAttribute]
public static MemberInfo[] GetMember(Type type, string name, BindingFlags bindingAttr);
    [ExtensionAttribute]
public static MemberInfo[] GetMembers(Type type, BindingFlags bindingAttr);
    [ExtensionAttribute]
public static MethodInfo GetMethod(Type type, string name);
    [ExtensionAttribute]
public static MethodInfo GetMethod(Type type, string name, Type[] types);
    [ExtensionAttribute]
public static TypeCode GetTypeCode(Type type);
    [ExtensionAttribute]
public static bool IsPublic(ConstructorInfo ci);
    [ExtensionAttribute]
public static object Invoke(ConstructorInfo ci, BindingFlags invokeAttr, object binder, Object[] parameters, CultureInfo culture);
    [ExtensionAttribute]
public static RuntimeMethodHandle MethodHandle(MethodBase mb);
    [ExtensionAttribute]
public static RuntimeMethodHandle MethodHandle(MethodInfo mi);
    [ExtensionAttribute]
public static Type ReflectedType(MethodInfo mi);
}
internal static class System.ServiceModel.SamlStrings : object {
    public static string Access;
    public static string AccessDecision;
    public static string Action;
    public static string Advice;
    public static string Assertion;
    public static string AssertionId;
    public static string AssertionIdReference;
    public static string Attribute;
    public static string AttributeName;
    public static string AttributeNamespace;
    public static string AttributeStatement;
    public static string AttributeValue;
    public static string Audience;
    public static string AudienceRestrictionCondition;
    public static string AuthenticationInstant;
    public static string AuthenticationMethod;
    public static string AuthenticationStatement;
    public static string AuthorityBinding;
    public static string AuthorityKind;
    public static string AuthorizationDecisionStatement;
    public static string Binding;
    public static string Condition;
    public static string Conditions;
    public static string Decision;
    public static string DoNotCacheCondition;
    public static string Evidence;
    public static string IssueInstant;
    public static string Issuer;
    public static string Location;
    public static string MajorVersion;
    public static string MinorVersion;
    public static string Namespace;
    public static string NameIdentifier;
    public static string NameIdentifierFormat;
    public static string NameIdentifierNameQualifier;
    public static string ActionNamespaceAttribute;
    public static string NotBefore;
    public static string NotOnOrAfter;
    public static string PreferredPrefix;
    public static string Statement;
    public static string Subject;
    public static string SubjectConfirmation;
    public static string SubjectConfirmationData;
    public static string SubjectConfirmationMethod;
    public static string HolderOfKey;
    public static string SenderVouches;
    public static string SubjectLocality;
    public static string SubjectLocalityDNSAddress;
    public static string SubjectLocalityIPAddress;
    public static string SubjectStatement;
    public static string UnspecifiedAuthenticationMethod;
    public static string NamespaceAttributePrefix;
    public static string Resource;
    public static string UserName;
    public static string UserNameNamespace;
    public static string EmailName;
    public static string EmailNamespace;
}
internal static class System.ServiceModel.SecureConversationApr2004Strings : object {
    public static string SecurityContextToken;
    public static string DerivedKeyToken;
    public static string AlgorithmAttribute;
    public static string Generation;
    public static string Label;
    public static string Length;
    public static string Nonce;
    public static string Offset;
    public static string Properties;
    public static string Identifier;
    public static string Cookie;
    public static string Prefix;
    public static string Namespace;
    public static string DerivedKeyTokenType;
    public static string SecurityContextTokenType;
    public static string SecurityContextTokenReferenceValueType;
    public static string RequestSecurityContextIssuance;
    public static string RequestSecurityContextIssuanceResponse;
    public static string RenewNeededFaultCode;
    public static string BadContextTokenFaultCode;
}
internal class System.ServiceModel.SecureConversationDec2005Dictionary : SecureConversationDictionary {
    public XmlDictionaryString RequestSecurityContextRenew;
    public XmlDictionaryString RequestSecurityContextRenewResponse;
    public XmlDictionaryString RequestSecurityContextClose;
    public XmlDictionaryString RequestSecurityContextCloseResponse;
    public XmlDictionaryString Instance;
    public List`1<XmlDictionaryString> SecureConversationDictionaryStrings;
    public SecureConversationDec2005Dictionary(XmlDictionary dictionary);
    public void PopulateSecureConversationDec2005();
}
internal static class System.ServiceModel.SecureConversationDec2005Strings : object {
    public static string SecurityContextToken;
    public static string AlgorithmAttribute;
    public static string Generation;
    public static string Label;
    public static string Offset;
    public static string Properties;
    public static string Identifier;
    public static string Cookie;
    public static string RenewNeededFaultCode;
    public static string BadContextTokenFaultCode;
    public static string Prefix;
    public static string DerivedKeyTokenType;
    public static string SecurityContextTokenType;
    public static string SecurityContextTokenReferenceValueType;
    public static string RequestSecurityContextIssuance;
    public static string RequestSecurityContextIssuanceResponse;
    public static string RequestSecurityContextRenew;
    public static string RequestSecurityContextRenewResponse;
    public static string RequestSecurityContextClose;
    public static string RequestSecurityContextCloseResponse;
    public static string Namespace;
    public static string DerivedKeyToken;
    public static string Nonce;
    public static string Length;
    public static string Instance;
}
internal class System.ServiceModel.SecureConversationDictionary : object {
    public XmlDictionaryString Namespace;
    public XmlDictionaryString DerivedKeyToken;
    public XmlDictionaryString Nonce;
    public XmlDictionaryString Length;
    public XmlDictionaryString SecurityContextToken;
    public XmlDictionaryString AlgorithmAttribute;
    public XmlDictionaryString Generation;
    public XmlDictionaryString Label;
    public XmlDictionaryString Offset;
    public XmlDictionaryString Properties;
    public XmlDictionaryString Identifier;
    public XmlDictionaryString Cookie;
    public XmlDictionaryString Prefix;
    public XmlDictionaryString DerivedKeyTokenType;
    public XmlDictionaryString SecurityContextTokenType;
    public XmlDictionaryString SecurityContextTokenReferenceValueType;
    public XmlDictionaryString RequestSecurityContextIssuance;
    public XmlDictionaryString RequestSecurityContextIssuanceResponse;
    public XmlDictionaryString RenewNeededFaultCode;
    public XmlDictionaryString BadContextTokenFaultCode;
    public SecureConversationDictionary(ServiceModelDictionary dictionary);
}
internal class System.ServiceModel.SecureConversationFeb2005Dictionary : SecureConversationDictionary {
    public XmlDictionaryString RequestSecurityContextRenew;
    public XmlDictionaryString RequestSecurityContextRenewResponse;
    public XmlDictionaryString RequestSecurityContextClose;
    public XmlDictionaryString RequestSecurityContextCloseResponse;
    public SecureConversationFeb2005Dictionary(ServiceModelDictionary dictionary);
}
internal static class System.ServiceModel.SecureConversationFeb2005Strings : object {
    public static string Namespace;
    public static string DerivedKeyToken;
    public static string Nonce;
    public static string Length;
    public static string SecurityContextToken;
    public static string AlgorithmAttribute;
    public static string Generation;
    public static string Label;
    public static string Offset;
    public static string Properties;
    public static string Identifier;
    public static string Cookie;
    public static string RenewNeededFaultCode;
    public static string BadContextTokenFaultCode;
    public static string Prefix;
    public static string DerivedKeyTokenType;
    public static string SecurityContextTokenType;
    public static string SecurityContextTokenReferenceValueType;
    public static string RequestSecurityContextIssuance;
    public static string RequestSecurityContextIssuanceResponse;
    public static string RequestSecurityContextRenew;
    public static string RequestSecurityContextRenewResponse;
    public static string RequestSecurityContextClose;
    public static string RequestSecurityContextCloseResponse;
}
internal static class System.ServiceModel.SecureConversationStrings : object {
}
public class System.ServiceModel.Security.Basic256SecurityAlgorithmSuite : SecurityAlgorithmSuite {
    public string DefaultCanonicalizationAlgorithm { get; }
    public string DefaultDigestAlgorithm { get; }
    public string DefaultEncryptionAlgorithm { get; }
    public int DefaultEncryptionKeyDerivationLength { get; }
    public string DefaultSymmetricKeyWrapAlgorithm { get; }
    public string DefaultAsymmetricKeyWrapAlgorithm { get; }
    public string DefaultSymmetricSignatureAlgorithm { get; }
    public string DefaultAsymmetricSignatureAlgorithm { get; }
    public int DefaultSignatureKeyDerivationLength { get; }
    public int DefaultSymmetricKeyLength { get; }
    internal XmlDictionaryString DefaultCanonicalizationAlgorithmDictionaryString { get; }
    internal XmlDictionaryString DefaultDigestAlgorithmDictionaryString { get; }
    internal XmlDictionaryString DefaultEncryptionAlgorithmDictionaryString { get; }
    internal XmlDictionaryString DefaultSymmetricKeyWrapAlgorithmDictionaryString { get; }
    internal XmlDictionaryString DefaultAsymmetricKeyWrapAlgorithmDictionaryString { get; }
    internal XmlDictionaryString DefaultSymmetricSignatureAlgorithmDictionaryString { get; }
    internal XmlDictionaryString DefaultAsymmetricSignatureAlgorithmDictionaryString { get; }
    public virtual string get_DefaultCanonicalizationAlgorithm();
    public virtual string get_DefaultDigestAlgorithm();
    public virtual string get_DefaultEncryptionAlgorithm();
    public virtual int get_DefaultEncryptionKeyDerivationLength();
    public virtual string get_DefaultSymmetricKeyWrapAlgorithm();
    public virtual string get_DefaultAsymmetricKeyWrapAlgorithm();
    public virtual string get_DefaultSymmetricSignatureAlgorithm();
    public virtual string get_DefaultAsymmetricSignatureAlgorithm();
    public virtual int get_DefaultSignatureKeyDerivationLength();
    public virtual int get_DefaultSymmetricKeyLength();
    public virtual bool IsSymmetricKeyLengthSupported(int length);
    public virtual bool IsAsymmetricKeyLengthSupported(int length);
    internal virtual XmlDictionaryString get_DefaultCanonicalizationAlgorithmDictionaryString();
    internal virtual XmlDictionaryString get_DefaultDigestAlgorithmDictionaryString();
    internal virtual XmlDictionaryString get_DefaultEncryptionAlgorithmDictionaryString();
    internal virtual XmlDictionaryString get_DefaultSymmetricKeyWrapAlgorithmDictionaryString();
    internal virtual XmlDictionaryString get_DefaultAsymmetricKeyWrapAlgorithmDictionaryString();
    internal virtual XmlDictionaryString get_DefaultSymmetricSignatureAlgorithmDictionaryString();
    internal virtual XmlDictionaryString get_DefaultAsymmetricSignatureAlgorithmDictionaryString();
    public virtual string ToString();
}
public abstract class System.ServiceModel.Security.BasicSecurityProfileVersion : object {
    public static BasicSecurityProfileVersion BasicSecurityProfile10 { get; }
    public static BasicSecurityProfileVersion get_BasicSecurityProfile10();
}
internal class System.ServiceModel.Security.BinaryNegotiation : object {
    private Byte[] _negotiationData;
    private XmlDictionaryString _valueTypeUriDictionaryString;
    private string _valueTypeUri;
    public string ValueTypeUri { get; }
    public BinaryNegotiation(string valueTypeUri, Byte[] negotiationData);
    public BinaryNegotiation(XmlDictionaryString valueTypeDictionaryString, Byte[] negotiationData);
    public void Validate(XmlDictionaryString valueTypeUriDictionaryString);
    public void WriteTo(XmlDictionaryWriter writer, string prefix, XmlDictionaryString localName, XmlDictionaryString ns, XmlDictionaryString valueTypeLocalName, XmlDictionaryString valueTypeNs);
    public string get_ValueTypeUri();
    public Byte[] GetNegotiationData();
}
public class System.ServiceModel.Security.ChannelProtectionRequirements : object {
    private ScopedMessagePartSpecification _incomingSignatureParts;
    private ScopedMessagePartSpecification _incomingEncryptionParts;
    private ScopedMessagePartSpecification _outgoingSignatureParts;
    private ScopedMessagePartSpecification _outgoingEncryptionParts;
    private bool _isReadOnly;
    public bool IsReadOnly { get; }
    public ScopedMessagePartSpecification IncomingSignatureParts { get; }
    public ScopedMessagePartSpecification IncomingEncryptionParts { get; }
    public ScopedMessagePartSpecification OutgoingSignatureParts { get; }
    public ScopedMessagePartSpecification OutgoingEncryptionParts { get; }
    public ChannelProtectionRequirements(ChannelProtectionRequirements other);
    internal ChannelProtectionRequirements(ChannelProtectionRequirements other, ProtectionLevel newBodyProtectionLevel);
    public bool get_IsReadOnly();
    public ScopedMessagePartSpecification get_IncomingSignatureParts();
    public ScopedMessagePartSpecification get_IncomingEncryptionParts();
    public ScopedMessagePartSpecification get_OutgoingSignatureParts();
    public ScopedMessagePartSpecification get_OutgoingEncryptionParts();
    public void Add(ChannelProtectionRequirements protectionRequirements);
    public void Add(ChannelProtectionRequirements protectionRequirements, bool channelScopeOnly);
    private static void AddActionParts(ScopedMessagePartSpecification to, ScopedMessagePartSpecification from);
    public void MakeReadOnly();
    public ChannelProtectionRequirements CreateInverse();
    internal static ChannelProtectionRequirements CreateFromContract(ContractDescription contract, ISecurityCapabilities bindingElement, bool isForClient);
    private static MessagePartSpecification UnionMessagePartSpecifications(ScopedMessagePartSpecification actionParts);
    internal static ChannelProtectionRequirements CreateFromContractAndUnionResponseProtectionRequirements(ContractDescription contract, ISecurityCapabilities bindingElement, bool isForClient);
    internal static ChannelProtectionRequirements CreateFromContract(ContractDescription contract, ProtectionLevel defaultRequestProtectionLevel, ProtectionLevel defaultResponseProtectionLevel, bool isForClient);
    private static void AddHeaderProtectionRequirements(MessageHeaderDescription header, MessagePartSpecification signedParts, MessagePartSpecification encryptedParts, ProtectionLevel defaultProtectionLevel);
    private static void AddFaultProtectionRequirements(FaultDescriptionCollection faults, ChannelProtectionRequirements requirements, ProtectionLevel defaultProtectionLevel, bool addToIncoming);
}
internal abstract class System.ServiceModel.Security.CommunicationObjectSecurityTokenAuthenticator : SecurityTokenAuthenticator {
    private WrapperSecurityCommunicationObject _communicationObject;
    protected WrapperSecurityCommunicationObject CommunicationObject { get; }
    public CommunicationState State { get; }
    public TimeSpan DefaultOpenTimeout { get; }
    public TimeSpan DefaultCloseTimeout { get; }
    protected WrapperSecurityCommunicationObject get_CommunicationObject();
    public sealed virtual void add_Closed(EventHandler value);
    public sealed virtual void remove_Closed(EventHandler value);
    public sealed virtual void add_Closing(EventHandler value);
    public sealed virtual void remove_Closing(EventHandler value);
    public sealed virtual void add_Faulted(EventHandler value);
    public sealed virtual void remove_Faulted(EventHandler value);
    public sealed virtual void add_Opened(EventHandler value);
    public sealed virtual void remove_Opened(EventHandler value);
    public sealed virtual void add_Opening(EventHandler value);
    public sealed virtual void remove_Opening(EventHandler value);
    public sealed virtual CommunicationState get_State();
    public virtual TimeSpan get_DefaultOpenTimeout();
    public virtual TimeSpan get_DefaultCloseTimeout();
    public sealed virtual void Abort();
    public sealed virtual void Close();
    public sealed virtual void Close(TimeSpan timeout);
    public sealed virtual IAsyncResult BeginClose(AsyncCallback callback, object state);
    public sealed virtual IAsyncResult BeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual void EndClose(IAsyncResult result);
    public sealed virtual void Open();
    public sealed virtual void Open(TimeSpan timeout);
    public sealed virtual IAsyncResult BeginOpen(AsyncCallback callback, object state);
    public sealed virtual IAsyncResult BeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual void EndOpen(IAsyncResult result);
    public void Dispose();
    public virtual void OnAbort();
    public sealed virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual IAsyncResult OnBeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    public virtual void OnClose(TimeSpan timeout);
    public virtual void OnClosed();
    public virtual void OnClosing();
    public sealed virtual void OnEndClose(IAsyncResult result);
    public sealed virtual void OnEndOpen(IAsyncResult result);
    public virtual void OnFaulted();
    public virtual void OnOpen(TimeSpan timeout);
    public virtual void OnOpened();
    public virtual void OnOpening();
}
internal abstract class System.ServiceModel.Security.CommunicationObjectSecurityTokenProvider : SecurityTokenProvider {
    private EventTraceActivity _eventTraceActivity;
    private WrapperSecurityCommunicationObject _communicationObject;
    internal EventTraceActivity EventTraceActivity { get; }
    protected WrapperSecurityCommunicationObject CommunicationObject { get; }
    public CommunicationState State { get; }
    public TimeSpan DefaultOpenTimeout { get; }
    public TimeSpan DefaultCloseTimeout { get; }
    internal EventTraceActivity get_EventTraceActivity();
    protected WrapperSecurityCommunicationObject get_CommunicationObject();
    public sealed virtual void add_Closed(EventHandler value);
    public sealed virtual void remove_Closed(EventHandler value);
    public sealed virtual void add_Closing(EventHandler value);
    public sealed virtual void remove_Closing(EventHandler value);
    public sealed virtual void add_Faulted(EventHandler value);
    public sealed virtual void remove_Faulted(EventHandler value);
    public sealed virtual void add_Opened(EventHandler value);
    public sealed virtual void remove_Opened(EventHandler value);
    public sealed virtual void add_Opening(EventHandler value);
    public sealed virtual void remove_Opening(EventHandler value);
    public sealed virtual CommunicationState get_State();
    public virtual TimeSpan get_DefaultOpenTimeout();
    public virtual TimeSpan get_DefaultCloseTimeout();
    public sealed virtual void Abort();
    public sealed virtual void Close();
    public sealed virtual void Close(TimeSpan timeout);
    public sealed virtual IAsyncResult BeginClose(AsyncCallback callback, object state);
    public sealed virtual IAsyncResult BeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual void EndClose(IAsyncResult result);
    public sealed virtual void Open();
    public sealed virtual void Open(TimeSpan timeout);
    public sealed virtual IAsyncResult BeginOpen(AsyncCallback callback, object state);
    public sealed virtual IAsyncResult BeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual void EndOpen(IAsyncResult result);
    public void Dispose();
    public virtual void OnAbort();
    public sealed virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual IAsyncResult OnBeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    public virtual void OnClose(TimeSpan timeout);
    public virtual void OnClosed();
    public virtual void OnClosing();
    public sealed virtual void OnEndClose(IAsyncResult result);
    public sealed virtual void OnEndOpen(IAsyncResult result);
    public virtual void OnFaulted();
    public virtual void OnOpen(TimeSpan timeout);
    public virtual void OnOpened();
    public virtual void OnOpening();
}
internal static class System.ServiceModel.Security.EmptyReadOnlyCollection`1 : object {
    public static ReadOnlyCollection`1<T> Instance;
    private static EmptyReadOnlyCollection`1();
}
public class System.ServiceModel.Security.HttpDigestClientCredential : object {
    private NetworkCredential _digestCredentials;
    private bool _isReadOnly;
    public NetworkCredential ClientCredential { get; public set; }
    internal HttpDigestClientCredential(HttpDigestClientCredential other);
    public NetworkCredential get_ClientCredential();
    public void set_ClientCredential(NetworkCredential value);
    internal void MakeReadOnly();
    private void ThrowIfImmutable();
}
public abstract class System.ServiceModel.Security.IdentityVerifier : object {
    public static IdentityVerifier CreateDefault();
    public abstract virtual bool CheckAccess(EndpointIdentity identity, AuthorizationContext authContext);
    public abstract virtual bool TryGetIdentity(EndpointAddress reference, EndpointIdentity& identity);
    private static void AdjustAddress(EndpointAddress& reference, Uri via);
    internal bool TryGetIdentity(EndpointAddress reference, Uri via, EndpointIdentity& identity);
    internal void EnsureOutgoingIdentity(EndpointAddress serviceReference, Uri via, AuthorizationContext authorizationContext);
    internal void EnsureOutgoingIdentity(EndpointAddress serviceReference, ReadOnlyCollection`1<IAuthorizationPolicy> authorizationPolicies);
    private void EnsureIdentity(EndpointAddress serviceReference, AuthorizationContext authorizationContext, string errorString);
    private Exception CreateIdentityCheckException(EndpointIdentity identity, AuthorizationContext authorizationContext, string errorString, EndpointAddress serviceReference);
}
internal class System.ServiceModel.Security.InMemoryNonceCache : NonceCache {
    private NonceCacheImpl _cacheImpl;
    public InMemoryNonceCache(TimeSpan cachingTime, int maxCachedNonces);
    public virtual bool CheckNonce(Byte[] nonce);
    public virtual bool TryAddNonce(Byte[] nonce);
    public virtual string ToString();
}
internal interface System.ServiceModel.Security.ISecurityCommunicationObject {
    public TimeSpan DefaultOpenTimeout { get; }
    public TimeSpan DefaultCloseTimeout { get; }
    public abstract virtual TimeSpan get_DefaultOpenTimeout();
    public abstract virtual TimeSpan get_DefaultCloseTimeout();
    public abstract virtual void OnAbort();
    public abstract virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    public abstract virtual IAsyncResult OnBeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    public abstract virtual void OnClose(TimeSpan timeout);
    public abstract virtual void OnClosed();
    public abstract virtual void OnClosing();
    public abstract virtual void OnEndClose(IAsyncResult result);
    public abstract virtual void OnEndOpen(IAsyncResult result);
    public abstract virtual void OnFaulted();
    public abstract virtual void OnOpen(TimeSpan timeout);
    public abstract virtual void OnOpened();
    public abstract virtual void OnOpening();
}
public interface System.ServiceModel.Security.ISecuritySession {
    public EndpointIdentity RemoteIdentity { get; }
    public abstract virtual EndpointIdentity get_RemoteIdentity();
}
public class System.ServiceModel.Security.MessagePartSpecification : object {
    private List`1<XmlQualifiedName> _headerTypes;
    private bool _isBodyIncluded;
    private bool _isReadOnly;
    private static MessagePartSpecification s_noParts;
    public ICollection`1<XmlQualifiedName> HeaderTypes { get; }
    internal bool HasHeaders { get; }
    public bool IsBodyIncluded { get; public set; }
    public bool IsReadOnly { get; }
    public static MessagePartSpecification NoParts { get; }
    public MessagePartSpecification(bool isBodyIncluded);
    public MessagePartSpecification(XmlQualifiedName[] headerTypes);
    public MessagePartSpecification(bool isBodyIncluded, XmlQualifiedName[] headerTypes);
    public ICollection`1<XmlQualifiedName> get_HeaderTypes();
    internal bool get_HasHeaders();
    public bool get_IsBodyIncluded();
    public void set_IsBodyIncluded(bool value);
    public bool get_IsReadOnly();
    public static MessagePartSpecification get_NoParts();
    public void Clear();
    public void Union(MessagePartSpecification specification);
    public void MakeReadOnly();
    internal bool IsHeaderIncluded(MessageHeader header);
    internal bool IsHeaderIncluded(string name, string ns);
    internal bool IsEmpty();
}
public enum System.ServiceModel.Security.MessageProtectionOrder : Enum {
    public int value__;
    public static MessageProtectionOrder SignBeforeEncrypt;
    public static MessageProtectionOrder SignBeforeEncryptAndEncryptSignature;
    public static MessageProtectionOrder EncryptBeforeSign;
}
internal static class System.ServiceModel.Security.MessageProtectionOrderHelper : object {
    internal static bool IsDefined(MessageProtectionOrder value);
}
public class System.ServiceModel.Security.MessageSecurityException : CommunicationException {
    private MessageFault _fault;
    private bool _isReplay;
    internal bool ReplayDetected { get; }
    internal MessageFault Fault { get; }
    public MessageSecurityException(string message);
    public MessageSecurityException(string message, Exception innerException);
    protected MessageSecurityException(SerializationInfo info, StreamingContext context);
    internal MessageSecurityException(string message, Exception innerException, MessageFault fault);
    internal MessageSecurityException(string message, bool isReplay);
    internal bool get_ReplayDetected();
    internal MessageFault get_Fault();
}
public class System.ServiceModel.Security.MessageSecurityTokenVersion : SecurityTokenVersion {
    private SecurityVersion _securityVersion;
    private TrustVersion _trustVersion;
    private SecureConversationVersion _secureConversationVersion;
    private bool _emitBspRequiredAttributes;
    private string _toString;
    private ReadOnlyCollection`1<string> _supportedSpecs;
    private static string bsp10ns;
    private static MessageSecurityTokenVersion s_wss11;
    private static MessageSecurityTokenVersion s_wss10bsp10;
    private static MessageSecurityTokenVersion s_wss11bsp10;
    private static MessageSecurityTokenVersion s_wss10oasisdec2005bsp10;
    private static MessageSecurityTokenVersion s_wss11oasisdec2005;
    private static MessageSecurityTokenVersion s_wss11oasisdec2005bsp10;
    public static MessageSecurityTokenVersion WSSecurity11WSTrustFebruary2005WSSecureConversationFebruary2005 { get; }
    public static MessageSecurityTokenVersion WSSecurity11WSTrustFebruary2005WSSecureConversationFebruary2005BasicSecurityProfile10 { get; }
    public static MessageSecurityTokenVersion WSSecurity10WSTrustFebruary2005WSSecureConversationFebruary2005BasicSecurityProfile10 { get; }
    public static MessageSecurityTokenVersion WSSecurity10WSTrust13WSSecureConversation13BasicSecurityProfile10 { get; }
    public static MessageSecurityTokenVersion WSSecurity11WSTrust13WSSecureConversation13 { get; }
    public static MessageSecurityTokenVersion WSSecurity11WSTrust13WSSecureConversation13BasicSecurityProfile10 { get; }
    public bool EmitBspRequiredAttributes { get; }
    public SecurityVersion SecurityVersion { get; }
    public TrustVersion TrustVersion { get; }
    public SecureConversationVersion SecureConversationVersion { get; }
    private MessageSecurityTokenVersion(SecurityVersion securityVersion, TrustVersion trustVersion, SecureConversationVersion secureConversationVersion, string toString, bool emitBspRequiredAttributes, String[] supportedSpecs);
    private static MessageSecurityTokenVersion();
    public static MessageSecurityTokenVersion get_WSSecurity11WSTrustFebruary2005WSSecureConversationFebruary2005();
    public static MessageSecurityTokenVersion get_WSSecurity11WSTrustFebruary2005WSSecureConversationFebruary2005BasicSecurityProfile10();
    public static MessageSecurityTokenVersion get_WSSecurity10WSTrustFebruary2005WSSecureConversationFebruary2005BasicSecurityProfile10();
    public static MessageSecurityTokenVersion get_WSSecurity10WSTrust13WSSecureConversation13BasicSecurityProfile10();
    public static MessageSecurityTokenVersion get_WSSecurity11WSTrust13WSSecureConversation13();
    public static MessageSecurityTokenVersion get_WSSecurity11WSTrust13WSSecureConversation13BasicSecurityProfile10();
    public static MessageSecurityTokenVersion GetSecurityTokenVersion(SecurityVersion version, bool emitBspAttributes);
    public bool get_EmitBspRequiredAttributes();
    public SecurityVersion get_SecurityVersion();
    public TrustVersion get_TrustVersion();
    public SecureConversationVersion get_SecureConversationVersion();
    public virtual ReadOnlyCollection`1<string> GetSecuritySpecifications();
    public virtual string ToString();
}
public abstract class System.ServiceModel.Security.NonceCache : object {
    private TimeSpan _cachingTime;
    private int _maxCachedNonces;
    public TimeSpan CachingTimeSpan { get; public set; }
    public int CacheSize { get; public set; }
    public TimeSpan get_CachingTimeSpan();
    public void set_CachingTimeSpan(TimeSpan value);
    public int get_CacheSize();
    public void set_CacheSize(int value);
    public abstract virtual bool TryAddNonce(Byte[] nonce);
    public abstract virtual bool CheckNonce(Byte[] nonce);
}
internal class System.ServiceModel.Security.OperationWithTimeoutAsyncResult : TraceAsyncResult {
    private static Action`1<object> s_scheduledCallback;
    private TimeoutHelper _timeoutHelper;
    private Action`1<TimeSpan> _operationWithTimeout;
    public OperationWithTimeoutAsyncResult(Action`1<TimeSpan> operationWithTimeout, TimeSpan timeout, AsyncCallback callback, object state);
    private static OperationWithTimeoutAsyncResult();
    private static void OnScheduled(object state);
    public static void End(IAsyncResult result);
}
public static class System.ServiceModel.Security.ProtectionLevelHelper : object {
    public static bool IsDefined(ProtectionLevel value);
    public static void Validate(ProtectionLevel value);
    public static bool IsStronger(ProtectionLevel v1, ProtectionLevel v2);
    public static bool IsStrongerOrEqual(ProtectionLevel v1, ProtectionLevel v2);
    public static ProtectionLevel Max(ProtectionLevel v1, ProtectionLevel v2);
    public static int GetOrdinal(Nullable`1<ProtectionLevel> p);
}
internal enum System.ServiceModel.Security.PurgingMode : Enum {
    public int value__;
    public static PurgingMode TimerBasedPurge;
    public static PurgingMode AccessBasedPurge;
}
internal abstract class System.ServiceModel.Security.ReceiveSecurityHeader : SecurityHeader {
    public string Name { get; }
    public string Namespace { get; }
    protected ReceiveSecurityHeader(Message message, string actor, bool mustUnderstand, bool relay, SecurityStandardsManager standardsManager, SecurityAlgorithmSuite algorithmSuite, int headerIndex, MessageDirection direction);
    public virtual string get_Name();
    public virtual string get_Namespace();
    protected virtual void OnWriteHeaderContents(XmlDictionaryWriter writer, MessageVersion messageVersion);
}
[FlagsAttribute]
internal enum System.ServiceModel.Security.ReceiveSecurityHeaderBindingModes : Enum {
    public int value__;
    public static ReceiveSecurityHeaderBindingModes Unknown;
    public static ReceiveSecurityHeaderBindingModes Primary;
    public static ReceiveSecurityHeaderBindingModes Endorsing;
    public static ReceiveSecurityHeaderBindingModes Signed;
    public static ReceiveSecurityHeaderBindingModes SignedEndorsing;
    public static ReceiveSecurityHeaderBindingModes Basic;
}
internal class System.ServiceModel.Security.RequestSecurityToken : BodyWriter {
    private string _context;
    private string _tokenType;
    private string _requestType;
    private BinaryNegotiation _negotiationData;
    private XmlElement _rstXml;
    private IList`1<XmlElement> _requestProperties;
    private ArraySegment`1<byte> _cachedWriteBuffer;
    private int _cachedWriteBufferLength;
    private int _keySize;
    private Message _message;
    private SecurityKeyIdentifierClause _renewTarget;
    private SecurityKeyIdentifierClause _closeTarget;
    private OnGetBinaryNegotiationCallback _onGetBinaryNegotiation;
    private SecurityStandardsManager _standardsManager;
    private bool _isReceiver;
    private bool _isReadOnly;
    private object _appliesTo;
    private DataContractSerializer _appliesToSerializer;
    private Type _appliesToType;
    private object _thisLock;
    public Message Message { get; public set; }
    public string Context { get; public set; }
    public string TokenType { get; public set; }
    public int KeySize { get; public set; }
    public bool IsReadOnly { get; }
    public OnGetBinaryNegotiationCallback OnGetBinaryNegotiation { get; public set; }
    public IEnumerable`1<XmlElement> RequestProperties { get; public set; }
    public string RequestType { get; public set; }
    public SecurityKeyIdentifierClause RenewTarget { get; public set; }
    public SecurityKeyIdentifierClause CloseTarget { get; public set; }
    public XmlElement RequestSecurityTokenXml { get; }
    internal SecurityStandardsManager StandardsManager { get; internal set; }
    internal bool IsReceiver { get; }
    internal object AppliesTo { get; }
    internal DataContractSerializer AppliesToSerializer { get; }
    internal Type AppliesToType { get; }
    protected object ThisLock { get; }
    public RequestSecurityToken(MessageSecurityVersion messageSecurityVersion, SecurityTokenSerializer securityTokenSerializer);
    public RequestSecurityToken(MessageSecurityVersion messageSecurityVersion, SecurityTokenSerializer securityTokenSerializer, XmlElement requestSecurityTokenXml, string context, string tokenType, string requestType, int keySize, SecurityKeyIdentifierClause renewTarget, SecurityKeyIdentifierClause closeTarget);
    public RequestSecurityToken(XmlElement requestSecurityTokenXml, string context, string tokenType, string requestType, int keySize, SecurityKeyIdentifierClause renewTarget, SecurityKeyIdentifierClause closeTarget);
    internal RequestSecurityToken(SecurityStandardsManager standardsManager, XmlElement rstXml, string context, string tokenType, string requestType, int keySize, SecurityKeyIdentifierClause renewTarget, SecurityKeyIdentifierClause closeTarget);
    internal RequestSecurityToken(SecurityStandardsManager standardsManager);
    internal RequestSecurityToken(SecurityStandardsManager standardsManager, bool isBuffered);
    public ChannelBinding GetChannelBinding();
    public Message get_Message();
    public void set_Message(Message value);
    public string get_Context();
    public void set_Context(string value);
    public string get_TokenType();
    public void set_TokenType(string value);
    public int get_KeySize();
    public void set_KeySize(int value);
    public bool get_IsReadOnly();
    public OnGetBinaryNegotiationCallback get_OnGetBinaryNegotiation();
    public void set_OnGetBinaryNegotiation(OnGetBinaryNegotiationCallback value);
    public IEnumerable`1<XmlElement> get_RequestProperties();
    public void set_RequestProperties(IEnumerable`1<XmlElement> value);
    public string get_RequestType();
    public void set_RequestType(string value);
    public SecurityKeyIdentifierClause get_RenewTarget();
    public void set_RenewTarget(SecurityKeyIdentifierClause value);
    public SecurityKeyIdentifierClause get_CloseTarget();
    public void set_CloseTarget(SecurityKeyIdentifierClause value);
    public XmlElement get_RequestSecurityTokenXml();
    internal SecurityStandardsManager get_StandardsManager();
    internal void set_StandardsManager(SecurityStandardsManager value);
    internal bool get_IsReceiver();
    internal object get_AppliesTo();
    internal DataContractSerializer get_AppliesToSerializer();
    internal Type get_AppliesToType();
    protected object get_ThisLock();
    internal void SetBinaryNegotiation(BinaryNegotiation negotiation);
    internal BinaryNegotiation GetBinaryNegotiation();
    public SecurityToken GetRequestorEntropy();
    internal SecurityToken GetRequestorEntropy(SecurityTokenResolver resolver);
    public void SetAppliesTo(T appliesTo, DataContractSerializer serializer);
    public void GetAppliesToQName(String& localName, String& namespaceUri);
    public T GetAppliesTo();
    public T GetAppliesTo(XmlObjectSerializer serializer);
    private void OnWriteTo(XmlWriter writer);
    public void WriteTo(XmlWriter writer);
    public static RequestSecurityToken CreateFrom(XmlReader reader);
    public static RequestSecurityToken CreateFrom(XmlReader reader, MessageSecurityVersion messageSecurityVersion, SecurityTokenSerializer securityTokenSerializer);
    internal static RequestSecurityToken CreateFrom(SecurityStandardsManager standardsManager, XmlReader reader);
    public void MakeReadOnly();
    protected internal virtual void OnWriteCustomAttributes(XmlWriter writer);
    protected internal virtual void OnWriteCustomElements(XmlWriter writer);
    protected internal virtual void OnMakeReadOnly();
    protected virtual void OnWriteBodyContents(XmlDictionaryWriter writer);
}
internal class System.ServiceModel.Security.RequestSecurityTokenResponse : BodyWriter {
    private SecurityStandardsManager _standardsManager;
    private string _context;
    private int _keySize;
    private bool _computeKey;
    private string _tokenType;
    private SecurityKeyIdentifierClause _requestedAttachedReference;
    private SecurityKeyIdentifierClause _requestedUnattachedReference;
    private SecurityToken _issuedToken;
    private SecurityToken _proofToken;
    private XmlElement _rstrXml;
    private DateTime _effectiveTime;
    private DateTime _expirationTime;
    private bool _isLifetimeSet;
    private bool _isReceiver;
    private bool _isReadOnly;
    private ArraySegment`1<byte> _cachedWriteBuffer;
    private int _cachedWriteBufferLength;
    private bool _isRequestedTokenClosed;
    private object _appliesTo;
    private XmlObjectSerializer _appliesToSerializer;
    private Type _appliesToType;
    private object _thisLock;
    private XmlBuffer _issuedTokenBuffer;
    public string Context { get; public set; }
    public string TokenType { get; public set; }
    public SecurityKeyIdentifierClause RequestedAttachedReference { get; public set; }
    public SecurityKeyIdentifierClause RequestedUnattachedReference { get; public set; }
    public DateTime ValidFrom { get; }
    public DateTime ValidTo { get; }
    public bool ComputeKey { get; public set; }
    public int KeySize { get; public set; }
    public bool IsRequestedTokenClosed { get; public set; }
    public bool IsReadOnly { get; }
    protected object ThisLock { get; }
    internal bool IsReceiver { get; }
    internal SecurityStandardsManager StandardsManager { get; internal set; }
    public SecurityToken EntropyToken { get; }
    public SecurityToken RequestedSecurityToken { get; public set; }
    public SecurityToken RequestedProofToken { get; public set; }
    public XmlElement RequestSecurityTokenResponseXml { get; }
    internal object AppliesTo { get; }
    internal XmlObjectSerializer AppliesToSerializer { get; }
    internal Type AppliesToType { get; }
    internal bool IsLifetimeSet { get; }
    public RequestSecurityTokenResponse(MessageSecurityVersion messageSecurityVersion, SecurityTokenSerializer securityTokenSerializer);
    public RequestSecurityTokenResponse(XmlElement requestSecurityTokenResponseXml, string context, string tokenType, int keySize, SecurityKeyIdentifierClause requestedAttachedReference, SecurityKeyIdentifierClause requestedUnattachedReference, bool computeKey, DateTime validFrom, DateTime validTo, bool isRequestedTokenClosed);
    public RequestSecurityTokenResponse(MessageSecurityVersion messageSecurityVersion, SecurityTokenSerializer securityTokenSerializer, XmlElement requestSecurityTokenResponseXml, string context, string tokenType, int keySize, SecurityKeyIdentifierClause requestedAttachedReference, SecurityKeyIdentifierClause requestedUnattachedReference, bool computeKey, DateTime validFrom, DateTime validTo, bool isRequestedTokenClosed);
    internal RequestSecurityTokenResponse(SecurityStandardsManager standardsManager);
    internal RequestSecurityTokenResponse(SecurityStandardsManager standardsManager, XmlElement rstrXml, string context, string tokenType, int keySize, SecurityKeyIdentifierClause requestedAttachedReference, SecurityKeyIdentifierClause requestedUnattachedReference, bool computeKey, DateTime validFrom, DateTime validTo, bool isRequestedTokenClosed, XmlBuffer issuedTokenBuffer);
    public string get_Context();
    public void set_Context(string value);
    public string get_TokenType();
    public void set_TokenType(string value);
    public SecurityKeyIdentifierClause get_RequestedAttachedReference();
    public void set_RequestedAttachedReference(SecurityKeyIdentifierClause value);
    public SecurityKeyIdentifierClause get_RequestedUnattachedReference();
    public void set_RequestedUnattachedReference(SecurityKeyIdentifierClause value);
    public DateTime get_ValidFrom();
    public DateTime get_ValidTo();
    public bool get_ComputeKey();
    public void set_ComputeKey(bool value);
    public int get_KeySize();
    public void set_KeySize(int value);
    public bool get_IsRequestedTokenClosed();
    public void set_IsRequestedTokenClosed(bool value);
    public bool get_IsReadOnly();
    protected object get_ThisLock();
    internal bool get_IsReceiver();
    internal SecurityStandardsManager get_StandardsManager();
    internal void set_StandardsManager(SecurityStandardsManager value);
    public SecurityToken get_EntropyToken();
    public SecurityToken get_RequestedSecurityToken();
    public void set_RequestedSecurityToken(SecurityToken value);
    public SecurityToken get_RequestedProofToken();
    public void set_RequestedProofToken(SecurityToken value);
    public XmlElement get_RequestSecurityTokenResponseXml();
    internal object get_AppliesTo();
    internal XmlObjectSerializer get_AppliesToSerializer();
    internal Type get_AppliesToType();
    internal bool get_IsLifetimeSet();
    internal SecurityToken GetIssuerEntropy(SecurityTokenResolver resolver);
    public void SetLifetime(DateTime validFrom, DateTime validTo);
    public void SetAppliesTo(T appliesTo, XmlObjectSerializer serializer);
    public void GetAppliesToQName(String& localName, String& namespaceUri);
    public T GetAppliesTo();
    public T GetAppliesTo(XmlObjectSerializer serializer);
    private void OnWriteTo(XmlWriter w);
    public void WriteTo(XmlWriter writer);
    public static RequestSecurityTokenResponse CreateFrom(XmlReader reader);
    public static RequestSecurityTokenResponse CreateFrom(XmlReader reader, MessageSecurityVersion messageSecurityVersion, SecurityTokenSerializer securityTokenSerializer);
    internal static RequestSecurityTokenResponse CreateFrom(SecurityStandardsManager standardsManager, XmlReader reader);
    protected virtual void OnWriteBodyContents(XmlDictionaryWriter writer);
    public void MakeReadOnly();
    protected internal virtual void OnWriteCustomAttributes(XmlWriter writer);
    protected internal virtual void OnWriteCustomElements(XmlWriter writer);
    protected virtual void OnMakeReadOnly();
}
internal class System.ServiceModel.Security.RequestSecurityTokenResponseCollection : BodyWriter {
    private IEnumerable`1<RequestSecurityTokenResponse> _rstrCollection;
    private SecurityStandardsManager _standardsManager;
    public IEnumerable`1<RequestSecurityTokenResponse> RstrCollection { get; }
    public RequestSecurityTokenResponseCollection(IEnumerable`1<RequestSecurityTokenResponse> rstrCollection);
    public RequestSecurityTokenResponseCollection(IEnumerable`1<RequestSecurityTokenResponse> rstrCollection, SecurityStandardsManager standardsManager);
    public IEnumerable`1<RequestSecurityTokenResponse> get_RstrCollection();
    public void WriteTo(XmlWriter writer);
    protected virtual void OnWriteBodyContents(XmlDictionaryWriter writer);
}
public class System.ServiceModel.Security.ScopedMessagePartSpecification : object {
    private MessagePartSpecification _channelParts;
    private Dictionary`2<string, MessagePartSpecification> _actionParts;
    private Dictionary`2<string, MessagePartSpecification> _readOnlyNormalizedActionParts;
    private bool _isReadOnly;
    public ICollection`1<string> Actions { get; }
    public MessagePartSpecification ChannelParts { get; }
    public bool IsReadOnly { get; }
    public ScopedMessagePartSpecification(ScopedMessagePartSpecification other);
    internal ScopedMessagePartSpecification(ScopedMessagePartSpecification other, bool newIncludeBody);
    public ICollection`1<string> get_Actions();
    public MessagePartSpecification get_ChannelParts();
    public bool get_IsReadOnly();
    public void AddParts(MessagePartSpecification parts);
    public void AddParts(MessagePartSpecification parts, string action);
    internal void AddParts(MessagePartSpecification parts, XmlDictionaryString action);
    internal bool IsEmpty();
    public bool TryGetParts(string action, bool excludeChannelScope, MessagePartSpecification& parts);
    internal void CopyTo(ScopedMessagePartSpecification target);
    public bool TryGetParts(string action, MessagePartSpecification& parts);
    public void MakeReadOnly();
    private void ThrowIfReadOnly();
}
internal abstract class System.ServiceModel.Security.SecureConversationDriver : object {
    public XmlDictionaryString CloseAction { get; }
    public XmlDictionaryString CloseResponseAction { get; }
    public bool IsSessionSupported { get; }
    public XmlDictionaryString IssueAction { get; }
    public XmlDictionaryString IssueResponseAction { get; }
    public XmlDictionaryString RenewAction { get; }
    public XmlDictionaryString RenewResponseAction { get; }
    public XmlDictionaryString Namespace { get; }
    public XmlDictionaryString RenewNeededFaultCode { get; }
    public XmlDictionaryString BadContextTokenFaultCode { get; }
    public string TokenTypeUri { get; }
    public virtual XmlDictionaryString get_CloseAction();
    public virtual XmlDictionaryString get_CloseResponseAction();
    public virtual bool get_IsSessionSupported();
    public abstract virtual XmlDictionaryString get_IssueAction();
    public abstract virtual XmlDictionaryString get_IssueResponseAction();
    public virtual XmlDictionaryString get_RenewAction();
    public virtual XmlDictionaryString get_RenewResponseAction();
    public abstract virtual XmlDictionaryString get_Namespace();
    public abstract virtual XmlDictionaryString get_RenewNeededFaultCode();
    public abstract virtual XmlDictionaryString get_BadContextTokenFaultCode();
    public abstract virtual string get_TokenTypeUri();
    public abstract virtual UniqueId GetSecurityContextTokenId(XmlDictionaryReader reader);
    public abstract virtual bool IsAtSecurityContextToken(XmlDictionaryReader reader);
}
public abstract class System.ServiceModel.Security.SecureConversationVersion : object {
    private XmlDictionaryString _scNamespace;
    private XmlDictionaryString _prefix;
    public XmlDictionaryString Namespace { get; }
    public XmlDictionaryString Prefix { get; }
    public static SecureConversationVersion Default { get; }
    public static SecureConversationVersion WSSecureConversationFeb2005 { get; }
    public static SecureConversationVersion WSSecureConversation13 { get; }
    internal SecureConversationVersion(XmlDictionaryString ns, XmlDictionaryString prefix);
    public XmlDictionaryString get_Namespace();
    public XmlDictionaryString get_Prefix();
    public static SecureConversationVersion get_Default();
    public static SecureConversationVersion get_WSSecureConversationFeb2005();
    public static SecureConversationVersion get_WSSecureConversation13();
}
public class System.ServiceModel.Security.SecurityAccessDeniedException : CommunicationException {
    public SecurityAccessDeniedException(string message);
    public SecurityAccessDeniedException(string message, Exception innerException);
    protected SecurityAccessDeniedException(SerializationInfo info, StreamingContext context);
}
public abstract class System.ServiceModel.Security.SecurityAlgorithmSuite : object {
    private static SecurityAlgorithmSuite s_basic256;
    public static SecurityAlgorithmSuite Default { get; }
    public static SecurityAlgorithmSuite Basic256 { get; }
    public string DefaultCanonicalizationAlgorithm { get; }
    public string DefaultDigestAlgorithm { get; }
    public string DefaultEncryptionAlgorithm { get; }
    public int DefaultEncryptionKeyDerivationLength { get; }
    public string DefaultSymmetricKeyWrapAlgorithm { get; }
    public string DefaultAsymmetricKeyWrapAlgorithm { get; }
    public string DefaultSymmetricSignatureAlgorithm { get; }
    public string DefaultAsymmetricSignatureAlgorithm { get; }
    public int DefaultSignatureKeyDerivationLength { get; }
    public int DefaultSymmetricKeyLength { get; }
    internal XmlDictionaryString DefaultCanonicalizationAlgorithmDictionaryString { get; }
    internal XmlDictionaryString DefaultDigestAlgorithmDictionaryString { get; }
    internal XmlDictionaryString DefaultEncryptionAlgorithmDictionaryString { get; }
    internal XmlDictionaryString DefaultSymmetricKeyWrapAlgorithmDictionaryString { get; }
    internal XmlDictionaryString DefaultAsymmetricKeyWrapAlgorithmDictionaryString { get; }
    internal XmlDictionaryString DefaultSymmetricSignatureAlgorithmDictionaryString { get; }
    internal XmlDictionaryString DefaultAsymmetricSignatureAlgorithmDictionaryString { get; }
    public static SecurityAlgorithmSuite get_Default();
    public static SecurityAlgorithmSuite get_Basic256();
    public abstract virtual string get_DefaultCanonicalizationAlgorithm();
    public abstract virtual string get_DefaultDigestAlgorithm();
    public abstract virtual string get_DefaultEncryptionAlgorithm();
    public abstract virtual int get_DefaultEncryptionKeyDerivationLength();
    public abstract virtual string get_DefaultSymmetricKeyWrapAlgorithm();
    public abstract virtual string get_DefaultAsymmetricKeyWrapAlgorithm();
    public abstract virtual string get_DefaultSymmetricSignatureAlgorithm();
    public abstract virtual string get_DefaultAsymmetricSignatureAlgorithm();
    public abstract virtual int get_DefaultSignatureKeyDerivationLength();
    public abstract virtual int get_DefaultSymmetricKeyLength();
    internal virtual XmlDictionaryString get_DefaultCanonicalizationAlgorithmDictionaryString();
    internal virtual XmlDictionaryString get_DefaultDigestAlgorithmDictionaryString();
    internal virtual XmlDictionaryString get_DefaultEncryptionAlgorithmDictionaryString();
    internal virtual XmlDictionaryString get_DefaultSymmetricKeyWrapAlgorithmDictionaryString();
    internal virtual XmlDictionaryString get_DefaultAsymmetricKeyWrapAlgorithmDictionaryString();
    internal virtual XmlDictionaryString get_DefaultSymmetricSignatureAlgorithmDictionaryString();
    internal virtual XmlDictionaryString get_DefaultAsymmetricSignatureAlgorithmDictionaryString();
    public virtual bool IsCanonicalizationAlgorithmSupported(string algorithm);
    public virtual bool IsDigestAlgorithmSupported(string algorithm);
    public virtual bool IsEncryptionAlgorithmSupported(string algorithm);
    public virtual bool IsEncryptionKeyDerivationAlgorithmSupported(string algorithm);
    public virtual bool IsSymmetricKeyWrapAlgorithmSupported(string algorithm);
    public virtual bool IsAsymmetricKeyWrapAlgorithmSupported(string algorithm);
    public virtual bool IsSymmetricSignatureAlgorithmSupported(string algorithm);
    public virtual bool IsAsymmetricSignatureAlgorithmSupported(string algorithm);
    public virtual bool IsSignatureKeyDerivationAlgorithmSupported(string algorithm);
    public abstract virtual bool IsSymmetricKeyLengthSupported(int length);
    public abstract virtual bool IsAsymmetricKeyLengthSupported(int length);
}
internal static class System.ServiceModel.Security.SecurityAuditHelper : object {
    public static bool IsSecurityAuditSupported { get; }
    public static bool get_IsSecurityAuditSupported();
}
internal abstract class System.ServiceModel.Security.SecurityChannel`1 : LayeredChannel`1<TChannel> {
    private SecurityProtocol _securityProtocol;
    public SecurityProtocol SecurityProtocol { get; protected set; }
    protected SecurityChannel`1(ChannelManagerBase channelManager, TChannel innerChannel);
    protected SecurityChannel`1(ChannelManagerBase channelManager, TChannel innerChannel, SecurityProtocol securityProtocol);
    public virtual T GetProperty();
    public SecurityProtocol get_SecurityProtocol();
    protected void set_SecurityProtocol(SecurityProtocol value);
    protected virtual void OnAbort();
    protected virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndClose(IAsyncResult result);
    private IAsyncResult BeginCloseSecurityProtocol(TimeSpan timeout, AsyncCallback callback, object state);
    private void EndCloseSecurityProtocol(IAsyncResult result);
    protected virtual void OnClose(TimeSpan timeout);
    protected void ThrowIfDisposedOrNotOpen(Message message);
}
[TypeForwardedFromAttribute("System.ServiceModel, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.ServiceModel.Security.SecurityContextKeyIdentifierClause : SecurityKeyIdentifierClause {
    private UniqueId _contextId;
    private UniqueId _generation;
    public UniqueId ContextId { get; }
    public UniqueId Generation { get; }
    public SecurityContextKeyIdentifierClause(UniqueId contextId);
    public SecurityContextKeyIdentifierClause(UniqueId contextId, UniqueId generation);
    public SecurityContextKeyIdentifierClause(UniqueId contextId, UniqueId generation, Byte[] derivationNonce, int derivationLength);
    public UniqueId get_ContextId();
    public UniqueId get_Generation();
    public virtual bool Matches(SecurityKeyIdentifierClause keyIdentifierClause);
    public bool Matches(UniqueId contextId, UniqueId generation);
    public virtual string ToString();
}
public abstract class System.ServiceModel.Security.SecurityCredentialsManager : object {
    public abstract virtual SecurityTokenManager CreateSecurityTokenManager();
}
internal abstract class System.ServiceModel.Security.SecurityHeader : MessageHeader {
    private string _actor;
    private SecurityAlgorithmSuite _algorithmSuite;
    private bool _encryptedKeyContainsReferenceList;
    private Message _message;
    private bool _mustUnderstand;
    private bool _relay;
    private bool _requireMessageProtection;
    private bool _processingStarted;
    private bool _maintainSignatureConfirmationState;
    private SecurityStandardsManager _standardsManager;
    private MessageDirection _transferDirection;
    private SecurityHeaderLayout _layout;
    public string Actor { get; }
    public SecurityAlgorithmSuite AlgorithmSuite { get; }
    public bool EncryptedKeyContainsReferenceList { get; public set; }
    public bool RequireMessageProtection { get; public set; }
    public bool MaintainSignatureConfirmationState { get; public set; }
    protected Message Message { get; protected set; }
    public bool MustUnderstand { get; }
    public bool Relay { get; }
    public SecurityHeaderLayout Layout { get; public set; }
    public SecurityStandardsManager StandardsManager { get; }
    public MessageDirection MessageDirection { get; }
    protected MessageVersion Version { get; }
    public SecurityHeader(Message message, string actor, bool mustUnderstand, bool relay, SecurityStandardsManager standardsManager, SecurityAlgorithmSuite algorithmSuite, MessageDirection transferDirection);
    public virtual string get_Actor();
    public SecurityAlgorithmSuite get_AlgorithmSuite();
    public bool get_EncryptedKeyContainsReferenceList();
    public void set_EncryptedKeyContainsReferenceList(bool value);
    public bool get_RequireMessageProtection();
    public void set_RequireMessageProtection(bool value);
    public bool get_MaintainSignatureConfirmationState();
    public void set_MaintainSignatureConfirmationState(bool value);
    protected Message get_Message();
    protected void set_Message(Message value);
    public virtual bool get_MustUnderstand();
    public virtual bool get_Relay();
    public SecurityHeaderLayout get_Layout();
    public void set_Layout(SecurityHeaderLayout value);
    public SecurityStandardsManager get_StandardsManager();
    public MessageDirection get_MessageDirection();
    protected MessageVersion get_Version();
    protected void SetProcessingStarted();
    protected void ThrowIfProcessingStarted();
    public virtual string ToString();
}
public enum System.ServiceModel.Security.SecurityKeyEntropyMode : Enum {
    public int value__;
    public static SecurityKeyEntropyMode ClientEntropy;
    public static SecurityKeyEntropyMode ServerEntropy;
    public static SecurityKeyEntropyMode CombinedEntropy;
}
internal class System.ServiceModel.Security.SecurityKeyEntropyModeHelper : object {
    internal static bool IsDefined(SecurityKeyEntropyMode value);
    internal static void Validate(SecurityKeyEntropyMode value);
}
public class System.ServiceModel.Security.SecurityMessageProperty : object {
    private Collection`1<SupportingTokenSpecification> _outgoingSupportingTokens;
    private Collection`1<SupportingTokenSpecification> _incomingSupportingTokens;
    private SecurityTokenSpecification _transportToken;
    private SecurityTokenSpecification _protectionToken;
    private SecurityTokenSpecification _initiatorToken;
    private SecurityTokenSpecification _recipientToken;
    private ServiceSecurityContext _securityContext;
    private ReadOnlyCollection`1<IAuthorizationPolicy> _externalAuthorizationPolicies;
    private string _senderIdPrefix;
    private bool _disposed;
    public ServiceSecurityContext ServiceSecurityContext { get; public set; }
    public ReadOnlyCollection`1<IAuthorizationPolicy> ExternalAuthorizationPolicies { get; public set; }
    public SecurityTokenSpecification ProtectionToken { get; public set; }
    public SecurityTokenSpecification InitiatorToken { get; public set; }
    public SecurityTokenSpecification RecipientToken { get; public set; }
    public SecurityTokenSpecification TransportToken { get; public set; }
    public string SenderIdPrefix { get; public set; }
    public bool HasIncomingSupportingTokens { get; }
    public Collection`1<SupportingTokenSpecification> IncomingSupportingTokens { get; }
    public Collection`1<SupportingTokenSpecification> OutgoingSupportingTokens { get; }
    internal bool HasOutgoingSupportingTokens { get; }
    public ServiceSecurityContext get_ServiceSecurityContext();
    public void set_ServiceSecurityContext(ServiceSecurityContext value);
    public ReadOnlyCollection`1<IAuthorizationPolicy> get_ExternalAuthorizationPolicies();
    public void set_ExternalAuthorizationPolicies(ReadOnlyCollection`1<IAuthorizationPolicy> value);
    public SecurityTokenSpecification get_ProtectionToken();
    public void set_ProtectionToken(SecurityTokenSpecification value);
    public SecurityTokenSpecification get_InitiatorToken();
    public void set_InitiatorToken(SecurityTokenSpecification value);
    public SecurityTokenSpecification get_RecipientToken();
    public void set_RecipientToken(SecurityTokenSpecification value);
    public SecurityTokenSpecification get_TransportToken();
    public void set_TransportToken(SecurityTokenSpecification value);
    public string get_SenderIdPrefix();
    public void set_SenderIdPrefix(string value);
    public bool get_HasIncomingSupportingTokens();
    public Collection`1<SupportingTokenSpecification> get_IncomingSupportingTokens();
    public Collection`1<SupportingTokenSpecification> get_OutgoingSupportingTokens();
    internal bool get_HasOutgoingSupportingTokens();
    public sealed virtual IMessageProperty CreateCopy();
    public static SecurityMessageProperty GetOrCreate(Message message);
    private void AddAuthorizationPolicies(SecurityTokenSpecification spec, Collection`1<IAuthorizationPolicy> policies);
    internal ReadOnlyCollection`1<IAuthorizationPolicy> GetInitiatorTokenAuthorizationPolicies();
    internal ReadOnlyCollection`1<IAuthorizationPolicy> GetInitiatorTokenAuthorizationPolicies(bool includeTransportToken);
    internal ReadOnlyCollection`1<IAuthorizationPolicy> GetInitiatorTokenAuthorizationPolicies(bool includeTransportToken, SecurityContextSecurityToken supportingSessionTokenToExclude);
    public sealed virtual void Dispose();
    private void ThrowIfDisposed();
}
public class System.ServiceModel.Security.SecurityNegotiationException : CommunicationException {
    public SecurityNegotiationException(string message);
    public SecurityNegotiationException(string message, Exception innerException);
    protected SecurityNegotiationException(SerializationInfo info, StreamingContext context);
}
internal static class System.ServiceModel.Security.SecurityPolicyStrings : object {
    public static string SecureConversationBootstrapBindingElementsBelowSecurityKey;
}
public abstract class System.ServiceModel.Security.SecurityPolicyVersion : object {
    private string _spNamespace;
    private string _prefix;
    public string Namespace { get; }
    public string Prefix { get; }
    public static SecurityPolicyVersion WSSecurityPolicy11 { get; }
    public static SecurityPolicyVersion WSSecurityPolicy12 { get; }
    internal SecurityPolicyVersion(string ns, string prefix);
    public string get_Namespace();
    public string get_Prefix();
    public static SecurityPolicyVersion get_WSSecurityPolicy11();
    public static SecurityPolicyVersion get_WSSecurityPolicy12();
}
internal abstract class System.ServiceModel.Security.SecurityProtocol : object {
    private WrapperSecurityCommunicationObject _communicationObject;
    public TimeSpan DefaultCloseTimeout { get; }
    public TimeSpan DefaultOpenTimeout { get; }
    public sealed virtual TimeSpan get_DefaultCloseTimeout();
    public sealed virtual TimeSpan get_DefaultOpenTimeout();
    public sealed virtual void OnAbort();
    public sealed virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual IAsyncResult OnBeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual void OnClose(TimeSpan timeout);
    public sealed virtual void OnClosed();
    public sealed virtual void OnClosing();
    public sealed virtual void OnEndClose(IAsyncResult result);
    public sealed virtual void OnEndOpen(IAsyncResult result);
    public sealed virtual void OnFaulted();
    public sealed virtual void OnOpen(TimeSpan timeout);
    public sealed virtual void OnOpened();
    public sealed virtual void OnOpening();
    public void Close(bool aborted, TimeSpan timeout);
}
internal static class System.ServiceModel.Security.SecurityProtocolFactory : object {
    internal static bool defaultAddTimestamp;
    internal static bool defaultDeriveKeys;
    internal static bool defaultDetectReplays;
    internal static string defaultMaxClockSkewString;
    internal static string defaultReplayWindowString;
    internal static TimeSpan defaultMaxClockSkew;
    internal static TimeSpan defaultReplayWindow;
    internal static int defaultMaxCachedNonces;
    internal static string defaultTimestampValidityDurationString;
    internal static TimeSpan defaultTimestampValidityDuration;
    internal static SecurityHeaderLayout defaultSecurityHeaderLayout;
    private static SecurityProtocolFactory();
}
internal class System.ServiceModel.Security.SecurityStandardsManager : object {
    private static SecurityStandardsManager s_instance;
    private MessageSecurityVersion _messageSecurityVersion;
    private TrustDriver _trustDriver;
    public static SecurityStandardsManager DefaultInstance { get; }
    public SecurityVersion SecurityVersion { get; }
    public MessageSecurityVersion MessageSecurityVersion { get; }
    internal TrustDriver TrustDriver { get; }
    public SecurityStandardsManager(SecurityTokenSerializer tokenSerializer);
    public SecurityStandardsManager(MessageSecurityVersion messageSecurityVersion, SecurityTokenSerializer tokenSerializer);
    public static SecurityStandardsManager get_DefaultInstance();
    public SecurityVersion get_SecurityVersion();
    public MessageSecurityVersion get_MessageSecurityVersion();
    internal TrustDriver get_TrustDriver();
}
public abstract class System.ServiceModel.Security.SecurityStateEncoder : object {
    protected internal abstract virtual Byte[] DecodeSecurityState(Byte[] data);
    protected internal abstract virtual Byte[] EncodeSecurityState(Byte[] data);
}
internal class System.ServiceModel.Security.SecurityTimestamp : object {
    private static string DefaultFormat;
    internal static TimeSpan defaultTimeToLive;
    private Char[] _computedCreationTimeUtc;
    private Char[] _computedExpiryTimeUtc;
    private DateTime _creationTimeUtc;
    private DateTime _expiryTimeUtc;
    private string _id;
    private string _digestAlgorithm;
    private Byte[] _digest;
    public DateTime CreationTimeUtc { get; }
    public DateTime ExpiryTimeUtc { get; }
    public string Id { get; }
    public string DigestAlgorithm { get; }
    public SecurityTimestamp(DateTime creationTimeUtc, DateTime expiryTimeUtc, string id);
    internal SecurityTimestamp(DateTime creationTimeUtc, DateTime expiryTimeUtc, string id, string digestAlgorithm, Byte[] digest);
    private static SecurityTimestamp();
    public DateTime get_CreationTimeUtc();
    public DateTime get_ExpiryTimeUtc();
    public string get_Id();
    public string get_DigestAlgorithm();
    internal Byte[] GetDigest();
    internal Char[] GetCreationTimeChars();
    internal Char[] GetExpiryTimeChars();
    private static Char[] ToChars(DateTime& utcTime);
    private static void ToChars(int n, Char[] buffer, Int32& offset, int count);
    public virtual string ToString();
    internal void ValidateRangeAndFreshness(TimeSpan timeToLive, TimeSpan allowedClockSkew);
    internal void ValidateFreshness(TimeSpan timeToLive, TimeSpan allowedClockSkew);
}
public enum System.ServiceModel.Security.SecurityTokenAttachmentMode : Enum {
    public int value__;
    public static SecurityTokenAttachmentMode Signed;
    public static SecurityTokenAttachmentMode Endorsing;
    public static SecurityTokenAttachmentMode SignedEndorsing;
    public static SecurityTokenAttachmentMode SignedEncrypted;
}
internal static class System.ServiceModel.Security.SecurityTokenAttachmentModeHelper : object {
    internal static bool IsDefined(SecurityTokenAttachmentMode value);
    internal static void Validate(SecurityTokenAttachmentMode value);
    internal static void Categorize(SecurityTokenAttachmentMode value, Boolean& isBasic, Boolean& isSignedButNotBasic, ReceiveSecurityHeaderBindingModes& mode);
}
public class System.ServiceModel.Security.SecurityTokenSpecification : object {
    private SecurityToken _token;
    private ReadOnlyCollection`1<IAuthorizationPolicy> _tokenPolicies;
    public SecurityToken SecurityToken { get; }
    public ReadOnlyCollection`1<IAuthorizationPolicy> SecurityTokenPolicies { get; }
    public SecurityTokenSpecification(SecurityToken token, ReadOnlyCollection`1<IAuthorizationPolicy> tokenPolicies);
    public SecurityToken get_SecurityToken();
    public ReadOnlyCollection`1<IAuthorizationPolicy> get_SecurityTokenPolicies();
}
internal class System.ServiceModel.Security.SecurityUniqueId : ValueType {
    private static long s_nextId;
    private static string s_commonPrefix;
    private long _id;
    private string _prefix;
    private string _val;
    public string Value { get; }
    private SecurityUniqueId(string prefix, long id);
    private static SecurityUniqueId();
    public static SecurityUniqueId Create();
    public static SecurityUniqueId Create(string prefix);
    public string get_Value();
}
internal static class System.ServiceModel.Security.SecurityUtils : object {
    public static string Principal;
    public static string Identities;
    private static IIdentity s_anonymousIdentity;
    private static X509SecurityTokenAuthenticator s_nonValidatingX509Authenticator;
    internal static X509SecurityTokenAuthenticator NonValidatingX509Authenticator { get; }
    internal static IIdentity AnonymousIdentity { get; }
    public static DateTime MaxUtcDateTime { get; }
    public static DateTime MinUtcDateTime { get; }
    internal static X509SecurityTokenAuthenticator get_NonValidatingX509Authenticator();
    internal static IIdentity get_AnonymousIdentity();
    public static DateTime get_MaxUtcDateTime();
    public static DateTime get_MinUtcDateTime();
    internal static IIdentity CreateIdentity(string name);
    internal static EndpointIdentity CreateWindowsIdentity();
    internal static EndpointIdentity CreateWindowsIdentity(NetworkCredential serverCredential);
    private static bool IsSystemAccount(WindowsIdentity self);
    internal static EndpointIdentity CreateWindowsIdentity(bool spnOnly);
    internal static WindowsIdentity CloneWindowsIdentityIfNecessary(WindowsIdentity wid);
    internal static WindowsIdentity CloneWindowsIdentityIfNecessary(WindowsIdentity wid, string authType);
    private static IntPtr UnsafeGetWindowsIdentityToken(WindowsIdentity wid);
    private static WindowsIdentity UnsafeCreateWindowsIdentityFromToken(IntPtr token, string authType);
    internal static string GetSpnFromIdentity(EndpointIdentity identity, EndpointAddress target);
    internal static string GetSpnFromTarget(EndpointAddress target);
    internal static bool IsSupportedAlgorithm(string algorithm, SecurityToken token);
    internal static Claim GetPrimaryIdentityClaim(ReadOnlyCollection`1<IAuthorizationPolicy> authorizationPolicies);
    internal static Claim GetPrimaryIdentityClaim(AuthorizationContext authContext);
    internal static string GenerateId();
    internal static ReadOnlyCollection`1<IAuthorizationPolicy> CreatePrincipalNameAuthorizationPolicies(string principalName);
    internal static string GetIdentityNamesFromContext(AuthorizationContext authContext);
    internal static void AppendCertificateIdentityName(StringBuilder str, X509Certificate2 certificate);
    internal static void AppendIdentityName(StringBuilder str, IIdentity identity);
    internal static void OpenTokenProviderIfRequired(SecurityTokenProvider tokenProvider, TimeSpan timeout);
    internal static void CloseTokenProviderIfRequired(SecurityTokenProvider tokenProvider, TimeSpan timeout);
    internal static void AbortTokenProviderIfRequired(SecurityTokenProvider tokenProvider);
    internal static void OpenTokenAuthenticatorIfRequired(SecurityTokenAuthenticator tokenAuthenticator, TimeSpan timeout);
    internal static void CloseTokenAuthenticatorIfRequired(SecurityTokenAuthenticator tokenAuthenticator, TimeSpan timeout);
    internal static void CloseTokenAuthenticatorIfRequired(SecurityTokenAuthenticator tokenAuthenticator, bool aborted, TimeSpan timeout);
    internal static void AbortTokenAuthenticatorIfRequired(SecurityTokenAuthenticator tokenAuthenticator);
    private static void OpenCommunicationObject(ICommunicationObject obj, TimeSpan timeout);
    private static void CloseCommunicationObject(object obj, bool aborted, TimeSpan timeout);
    internal static SecurityStandardsManager CreateSecurityStandardsManager(MessageSecurityVersion securityVersion, SecurityTokenManager tokenManager);
    internal static SecurityStandardsManager CreateSecurityStandardsManager(SecurityTokenRequirement requirement, SecurityTokenManager tokenManager);
    internal static SecurityStandardsManager CreateSecurityStandardsManager(MessageSecurityVersion securityVersion, SecurityTokenSerializer securityTokenSerializer);
    internal static NetworkCredential GetNetworkCredentialsCopy(NetworkCredential networkCredential);
    internal static NetworkCredential GetNetworkCredentialOrDefault(NetworkCredential credential);
    internal static string AppendWindowsAuthenticationInfo(string inputString, NetworkCredential credential, AuthenticationLevel authenticationLevel, TokenImpersonationLevel impersonationLevel);
    internal static Byte[] CloneBuffer(Byte[] buffer);
    internal static string GetKeyDerivationAlgorithm(SecureConversationVersion version);
    internal static X509Certificate2 GetCertificateFromStore(StoreName storeName, StoreLocation storeLocation, X509FindType findType, object findValue, EndpointAddress target);
    internal static bool TryGetCertificateFromStore(StoreName storeName, StoreLocation storeLocation, X509FindType findType, object findValue, EndpointAddress target, X509Certificate2& certificate);
    private static X509Certificate2 GetCertificateFromStoreCore(StoreName storeName, StoreLocation storeLocation, X509FindType findType, object findValue, EndpointAddress target, bool throwIfMultipleOrNoMatch);
    internal static Exception CreateCertificateLoadException(StoreName storeName, StoreLocation storeLocation, X509FindType findType, object findValue, EndpointAddress target, int certCount);
    internal static void FixNetworkCredential(NetworkCredential& credential);
    public static void ValidateAnonymityConstraint(WindowsIdentity identity, bool allowUnauthenticatedCallers);
    internal static void ResetAllCertificates(X509Certificate2Collection certificates);
    internal static void ResetCertificate(X509Certificate2 certificate);
}
public abstract class System.ServiceModel.Security.SecurityVersion : object {
    private XmlDictionaryString _headerName;
    private XmlDictionaryString _headerNamespace;
    private XmlDictionaryString _headerPrefix;
    internal XmlDictionaryString HeaderName { get; }
    internal XmlDictionaryString HeaderNamespace { get; }
    internal XmlDictionaryString HeaderPrefix { get; }
    internal XmlDictionaryString FailedAuthenticationFaultCode { get; }
    internal XmlDictionaryString InvalidSecurityTokenFaultCode { get; }
    internal XmlDictionaryString InvalidSecurityFaultCode { get; }
    internal bool SupportsSignatureConfirmation { get; }
    public static SecurityVersion WSSecurity10 { get; }
    public static SecurityVersion WSSecurity11 { get; }
    internal static SecurityVersion Default { get; }
    internal SecurityVersion(XmlDictionaryString headerName, XmlDictionaryString headerNamespace, XmlDictionaryString headerPrefix);
    internal XmlDictionaryString get_HeaderName();
    internal XmlDictionaryString get_HeaderNamespace();
    internal XmlDictionaryString get_HeaderPrefix();
    internal abstract virtual XmlDictionaryString get_FailedAuthenticationFaultCode();
    internal abstract virtual XmlDictionaryString get_InvalidSecurityTokenFaultCode();
    internal abstract virtual XmlDictionaryString get_InvalidSecurityFaultCode();
    internal virtual bool get_SupportsSignatureConfirmation();
    public static SecurityVersion get_WSSecurity10();
    public static SecurityVersion get_WSSecurity11();
    internal static SecurityVersion get_Default();
    internal abstract virtual ReceiveSecurityHeader CreateReceiveSecurityHeader(Message message, string actor, bool mustUnderstand, bool relay, SecurityStandardsManager standardsManager, SecurityAlgorithmSuite algorithmSuite, MessageDirection direction, int headerIndex);
    internal abstract virtual SendSecurityHeader CreateSendSecurityHeader(Message message, string actor, bool mustUnderstand, bool relay, SecurityStandardsManager standardsManager, SecurityAlgorithmSuite algorithmSuite, MessageDirection direction);
    internal bool DoesMessageContainSecurityHeader(Message message);
    internal int FindIndexOfSecurityHeader(Message message, String[] actors);
    internal virtual bool IsReaderAtSignatureConfirmation(XmlDictionaryReader reader);
    internal virtual ISignatureValueSecurityElement ReadSignatureConfirmation(XmlDictionaryReader reader);
    internal ReceiveSecurityHeader TryCreateReceiveSecurityHeader(Message message, string actor, SecurityStandardsManager standardsManager, SecurityAlgorithmSuite algorithmSuite, MessageDirection direction);
    internal virtual void WriteSignatureConfirmation(XmlDictionaryWriter writer, string id, Byte[] signatureConfirmation);
    internal void WriteStartHeader(XmlDictionaryWriter writer);
}
internal abstract class System.ServiceModel.Security.SendSecurityHeader : SecurityHeader {
    private XmlDictionaryString System.ServiceModel.Channels.IMessageHeaderWithSharedNamespace.SharedNamespace { get; }
    private XmlDictionaryString System.ServiceModel.Channels.IMessageHeaderWithSharedNamespace.SharedPrefix { get; }
    public string Name { get; }
    public string Namespace { get; }
    protected SendSecurityHeader(Message message, string actor, bool mustUnderstand, bool relay, SecurityStandardsManager standardsManager, SecurityAlgorithmSuite algorithmSuite, MessageDirection transferDirection);
    private sealed virtual override XmlDictionaryString System.ServiceModel.Channels.IMessageHeaderWithSharedNamespace.get_SharedNamespace();
    private sealed virtual override XmlDictionaryString System.ServiceModel.Channels.IMessageHeaderWithSharedNamespace.get_SharedPrefix();
    public virtual string get_Name();
    public virtual string get_Namespace();
    protected virtual void OnWriteHeaderContents(XmlDictionaryWriter writer, MessageVersion messageVersion);
}
internal class System.ServiceModel.Security.SignatureConfirmationElement : object {
    private SecurityVersion _version;
    private string _id;
    private Byte[] _signatureValue;
    public bool HasId { get; }
    public string Id { get; }
    public SignatureConfirmationElement(string id, Byte[] signatureValue, SecurityVersion version);
    public sealed virtual bool get_HasId();
    public sealed virtual string get_Id();
    public sealed virtual Byte[] GetSignatureValue();
    public sealed virtual void WriteTo(XmlDictionaryWriter writer, DictionaryManager dictionaryManager);
}
internal abstract class System.ServiceModel.Security.SignatureTargetIdManager : object {
    public string DefaultIdNamespacePrefix { get; }
    public string DefaultIdNamespaceUri { get; }
    public abstract virtual string get_DefaultIdNamespacePrefix();
    public abstract virtual string get_DefaultIdNamespaceUri();
    public abstract virtual string ExtractId(XmlDictionaryReader reader);
    public abstract virtual void WriteIdAttribute(XmlDictionaryWriter writer, string id);
}
internal static class System.ServiceModel.Security.SslProtocolsHelper : object {
    internal static bool IsDefined(SslProtocols value);
    internal static void Validate(SslProtocols value);
}
public class System.ServiceModel.Security.SspiSecurityTokenProvider : SecurityTokenProvider {
    internal static bool DefaultAllowNtlm;
    internal static bool DefaultExtractWindowsGroupClaims;
    internal static bool DefaultAllowUnauthenticatedCallers;
    private SspiSecurityToken _token;
    public SspiSecurityTokenProvider(NetworkCredential credential, bool allowNtlm, TokenImpersonationLevel impersonationLevel);
    public SspiSecurityTokenProvider(NetworkCredential credential, bool extractGroupsForWindowsAccounts, bool allowUnauthenticatedCallers);
    protected virtual Task`1<SecurityToken> GetTokenCoreAsync(CancellationToken cancellationToken);
}
internal class System.ServiceModel.Security.SupportingTokenAuthenticatorSpecification : object {
    private SecurityTokenAttachmentMode _tokenAttachmentMode;
    private SecurityTokenAuthenticator _tokenAuthenticator;
    private SecurityTokenResolver _tokenResolver;
    private SecurityTokenParameters _tokenParameters;
    private bool _isTokenOptional;
    public SecurityTokenAuthenticator TokenAuthenticator { get; }
    public SecurityTokenResolver TokenResolver { get; }
    public SecurityTokenAttachmentMode SecurityTokenAttachmentMode { get; }
    public SecurityTokenParameters TokenParameters { get; }
    internal bool IsTokenOptional { get; internal set; }
    public SupportingTokenAuthenticatorSpecification(SecurityTokenAuthenticator tokenAuthenticator, SecurityTokenResolver securityTokenResolver, SecurityTokenAttachmentMode attachmentMode, SecurityTokenParameters tokenParameters);
    internal SupportingTokenAuthenticatorSpecification(SecurityTokenAuthenticator tokenAuthenticator, SecurityTokenResolver securityTokenResolver, SecurityTokenAttachmentMode attachmentMode, SecurityTokenParameters tokenParameters, bool isTokenOptional);
    public SecurityTokenAuthenticator get_TokenAuthenticator();
    public SecurityTokenResolver get_TokenResolver();
    public SecurityTokenAttachmentMode get_SecurityTokenAttachmentMode();
    public SecurityTokenParameters get_TokenParameters();
    internal bool get_IsTokenOptional();
    internal void set_IsTokenOptional(bool value);
}
internal class System.ServiceModel.Security.SupportingTokenProviderSpecification : object {
    private SecurityTokenAttachmentMode _tokenAttachmentMode;
    private SecurityTokenProvider _tokenProvider;
    private SecurityTokenParameters _tokenParameters;
    public SecurityTokenProvider TokenProvider { get; }
    public SecurityTokenAttachmentMode SecurityTokenAttachmentMode { get; }
    public SecurityTokenParameters TokenParameters { get; }
    public SupportingTokenProviderSpecification(SecurityTokenProvider tokenProvider, SecurityTokenAttachmentMode attachmentMode, SecurityTokenParameters tokenParameters);
    public SecurityTokenProvider get_TokenProvider();
    public SecurityTokenAttachmentMode get_SecurityTokenAttachmentMode();
    public SecurityTokenParameters get_TokenParameters();
}
public class System.ServiceModel.Security.SupportingTokenSpecification : SecurityTokenSpecification {
    private SecurityTokenAttachmentMode _tokenAttachmentMode;
    private SecurityTokenParameters _tokenParameters;
    public SecurityTokenAttachmentMode SecurityTokenAttachmentMode { get; }
    internal SecurityTokenParameters SecurityTokenParameters { get; }
    public SupportingTokenSpecification(SecurityToken token, ReadOnlyCollection`1<IAuthorizationPolicy> tokenPolicies, SecurityTokenAttachmentMode attachmentMode);
    public SupportingTokenSpecification(SecurityToken token, ReadOnlyCollection`1<IAuthorizationPolicy> tokenPolicies, SecurityTokenAttachmentMode attachmentMode, SecurityTokenParameters tokenParameters);
    public SecurityTokenAttachmentMode get_SecurityTokenAttachmentMode();
    internal SecurityTokenParameters get_SecurityTokenParameters();
}
internal class System.ServiceModel.Security.TimeBoundedCache : object {
    private static Action`1<object> s_purgeCallback;
    private ReaderWriterLockSlim _cacheLock;
    private Hashtable _entries;
    private int _lowWaterMark;
    private int _maxCacheItems;
    private DateTime _nextPurgeTimeUtc;
    private TimeSpan _purgeInterval;
    private PurgingMode _purgingMode;
    private Timer _purgingTimer;
    private bool _doRemoveNotification;
    public int Count { get; }
    private static Action`1<object> PurgeCallback { get; }
    protected int Capacity { get; }
    protected Hashtable Entries { get; }
    protected ReaderWriterLockSlim CacheLock { get; }
    protected TimeBoundedCache(int lowWaterMark, int maxCacheItems, IEqualityComparer keyComparer, PurgingMode purgingMode, TimeSpan purgeInterval, bool doRemoveNotification);
    public int get_Count();
    private static Action`1<object> get_PurgeCallback();
    protected int get_Capacity();
    protected Hashtable get_Entries();
    protected ReaderWriterLockSlim get_CacheLock();
    protected bool TryAddItem(object key, object item, DateTime expirationTime, bool replaceExistingEntry);
    private void CancelTimerIfNeeded();
    private void StartTimerIfNeeded();
    protected bool TryAddItem(object key, IExpirableItem item, bool replaceExistingEntry);
    protected bool TryReplaceItem(object key, object item, DateTime expirationTime);
    protected void ClearItems();
    protected object GetItem(object key);
    protected virtual ArrayList OnQuotaReached(Hashtable cacheTable);
    protected virtual void OnRemove(object item);
    protected bool TryRemoveItem(object key);
    private void EnforceQuota();
    protected object ExtractItem(IExpirableItem val);
    private bool IsExpired(IExpirableItem item);
    private bool ShouldPurge();
    private void PurgeIfNeeded();
    private void PurgeStaleItems();
    private void ThrowQuotaReachedException();
    private static void PurgeCallbackStatic(object state);
}
internal static class System.ServiceModel.Security.TokenImpersonationLevelHelper : object {
    private static TokenImpersonationLevel[] s_TokenImpersonationLevelOrder;
    private static TokenImpersonationLevelHelper();
    internal static bool IsDefined(TokenImpersonationLevel value);
    internal static void Validate(TokenImpersonationLevel value);
    internal static string ToString(TokenImpersonationLevel impersonationLevel);
    internal static bool IsGreaterOrEqual(TokenImpersonationLevel x, TokenImpersonationLevel y);
    internal static int Compare(TokenImpersonationLevel x, TokenImpersonationLevel y);
}
public class System.ServiceModel.Security.Tokens.ClaimTypeRequirement : object {
    internal static bool DefaultIsOptional;
    private string _claimType;
    private bool _isOptional;
    public string ClaimType { get; }
    public bool IsOptional { get; }
    public ClaimTypeRequirement(string claimType);
    public ClaimTypeRequirement(string claimType, bool isOptional);
    public string get_ClaimType();
    public bool get_IsOptional();
}
internal class System.ServiceModel.Security.Tokens.DerivedKeySecurityToken : SecurityToken {
    private static Byte[] s_DefaultLabel;
    public static int DefaultNonceLength;
    public static int DefaultDerivedKeyLength;
    private string _id;
    private Byte[] _key;
    private string _keyDerivationAlgorithm;
    private string _label;
    private int _length;
    private Byte[] _nonce;
    private int _offset;
    private int _generation;
    private SecurityToken _tokenToDerive;
    private SecurityKeyIdentifierClause _tokenToDeriveIdentifier;
    private ReadOnlyCollection`1<SecurityKey> _securityKeys;
    public string Id { get; }
    public DateTime ValidFrom { get; }
    public DateTime ValidTo { get; }
    public string KeyDerivationAlgorithm { get; }
    public int Generation { get; }
    public string Label { get; }
    public int Length { get; }
    internal Byte[] Nonce { get; }
    public int Offset { get; }
    internal SecurityToken TokenToDerive { get; }
    internal SecurityKeyIdentifierClause TokenToDeriveIdentifier { get; }
    public ReadOnlyCollection`1<SecurityKey> SecurityKeys { get; }
    private static DerivedKeySecurityToken();
    public virtual string get_Id();
    public virtual DateTime get_ValidFrom();
    public virtual DateTime get_ValidTo();
    public string get_KeyDerivationAlgorithm();
    public int get_Generation();
    public string get_Label();
    public int get_Length();
    internal Byte[] get_Nonce();
    public int get_Offset();
    internal SecurityToken get_TokenToDerive();
    internal SecurityKeyIdentifierClause get_TokenToDeriveIdentifier();
    public virtual ReadOnlyCollection`1<SecurityKey> get_SecurityKeys();
    public Byte[] GetKeyBytes();
    public Byte[] GetNonce();
    internal bool TryGetSecurityKeys(ReadOnlyCollection`1& keys);
    internal static void EnsureAcceptableOffset(int offset, int generation, int length, int maxOffset);
}
public class System.ServiceModel.Security.Tokens.InitiatorServiceModelSecurityTokenRequirement : ServiceModelSecurityTokenRequirement {
    private HttpHeaders _httpHeaders;
    public EndpointAddress TargetAddress { get; public set; }
    public Uri Via { get; public set; }
    internal bool IsOutOfBandToken { get; internal set; }
    internal bool PreferSslCertificateAuthenticator { get; internal set; }
    internal HttpHeaders HttpHeaders { get; internal set; }
    public EndpointAddress get_TargetAddress();
    public void set_TargetAddress(EndpointAddress value);
    public Uri get_Via();
    public void set_Via(Uri value);
    internal bool get_IsOutOfBandToken();
    internal void set_IsOutOfBandToken(bool value);
    internal bool get_PreferSslCertificateAuthenticator();
    internal void set_PreferSslCertificateAuthenticator(bool value);
    internal HttpHeaders get_HttpHeaders();
    internal void set_HttpHeaders(HttpHeaders value);
    public virtual string ToString();
}
public interface System.ServiceModel.Security.Tokens.ISecurityContextSecurityTokenCache {
    public abstract virtual void AddContext(SecurityContextSecurityToken token);
    public abstract virtual bool TryAddContext(SecurityContextSecurityToken token);
    public abstract virtual void ClearContexts();
    public abstract virtual void RemoveContext(UniqueId contextId, UniqueId generation);
    public abstract virtual void RemoveAllContexts(UniqueId contextId);
    public abstract virtual SecurityContextSecurityToken GetContext(UniqueId contextId, UniqueId generation);
    public abstract virtual Collection`1<SecurityContextSecurityToken> GetAllContexts(UniqueId contextId);
    public abstract virtual void UpdateContextCachingTime(SecurityContextSecurityToken context, DateTime expirationTime);
}
internal interface System.ServiceModel.Security.Tokens.ISecurityContextSecurityTokenCacheProvider {
    public ISecurityContextSecurityTokenCache TokenCache { get; }
    public abstract virtual ISecurityContextSecurityTokenCache get_TokenCache();
}
internal class System.ServiceModel.Security.Tokens.NonValidatingSecurityTokenAuthenticator`1 : SecurityTokenAuthenticator {
    protected virtual bool CanValidateTokenCore(SecurityToken token);
    protected virtual ReadOnlyCollection`1<IAuthorizationPolicy> ValidateTokenCore(SecurityToken token);
}
public class System.ServiceModel.Security.Tokens.RecipientServiceModelSecurityTokenRequirement : ServiceModelSecurityTokenRequirement {
    public Uri ListenUri { get; public set; }
    public Uri get_ListenUri();
    public void set_ListenUri(Uri value);
    public virtual string ToString();
}
public class System.ServiceModel.Security.Tokens.SecureConversationSecurityTokenParameters : SecurityTokenParameters {
    internal static bool defaultRequireCancellation;
    internal static bool defaultCanRenewSession;
    private SecurityBindingElement _bootstrapSecurityBindingElement;
    private bool _requireCancellation;
    private bool _canRenewSession;
    private BindingContext _issuerBindingContext;
    protected internal bool HasAsymmetricKey { get; }
    public SecurityBindingElement BootstrapSecurityBindingElement { get; public set; }
    internal BindingContext IssuerBindingContext { get; internal set; }
    private ISecurityCapabilities BootstrapSecurityCapabilities { get; }
    protected internal bool SupportsClientAuthentication { get; }
    protected internal bool SupportsServerAuthentication { get; }
    protected internal bool SupportsClientWindowsIdentity { get; }
    protected SecureConversationSecurityTokenParameters(SecureConversationSecurityTokenParameters other);
    public SecureConversationSecurityTokenParameters(SecurityBindingElement bootstrapSecurityBindingElement);
    protected internal virtual bool get_HasAsymmetricKey();
    public SecurityBindingElement get_BootstrapSecurityBindingElement();
    public void set_BootstrapSecurityBindingElement(SecurityBindingElement value);
    internal BindingContext get_IssuerBindingContext();
    internal void set_IssuerBindingContext(BindingContext value);
    private ISecurityCapabilities get_BootstrapSecurityCapabilities();
    protected internal virtual bool get_SupportsClientAuthentication();
    protected internal virtual bool get_SupportsServerAuthentication();
    protected internal virtual bool get_SupportsClientWindowsIdentity();
    protected virtual SecurityTokenParameters CloneCore();
    public virtual string ToString();
}
internal class System.ServiceModel.Security.Tokens.SecurityContextCookieSerializer : ValueType {
    private static int SupportedPersistanceVersion;
    private SecurityStateEncoder _securityStateEncoder;
    private IList`1<Type> _knownTypes;
    public SecurityContextCookieSerializer(SecurityStateEncoder securityStateEncoder, IList`1<Type> knownTypes);
    public Byte[] CreateCookieFromSecurityContext(UniqueId contextId, string id, Byte[] key, DateTime tokenEffectiveTime, DateTime tokenExpirationTime, UniqueId keyGeneration, DateTime keyEffectiveTime, DateTime keyExpirationTime, ReadOnlyCollection`1<IAuthorizationPolicy> authorizationPolicies);
}
public class System.ServiceModel.Security.Tokens.SecurityContextSecurityToken : SecurityToken {
    private Byte[] _cookieBlob;
    private UniqueId _contextId;
    private UniqueId _keyGeneration;
    private DateTime _keyEffectiveTime;
    private DateTime _keyExpirationTime;
    private DateTime _tokenEffectiveTime;
    private DateTime _tokenExpirationTime;
    private bool _isCookieMode;
    private Byte[] _key;
    private string _keyString;
    private ReadOnlyCollection`1<IAuthorizationPolicy> _authorizationPolicies;
    private ReadOnlyCollection`1<SecurityKey> _securityKeys;
    private string _id;
    private SecurityMessageProperty _bootstrapMessageProperty;
    private bool _disposed;
    public SecurityMessageProperty BootstrapMessageProperty { get; public set; }
    public string Id { get; }
    public UniqueId ContextId { get; }
    public UniqueId KeyGeneration { get; }
    public DateTime KeyEffectiveTime { get; }
    public DateTime KeyExpirationTime { get; }
    public ReadOnlyCollection`1<IAuthorizationPolicy> AuthorizationPolicies { get; internal set; }
    public ReadOnlyCollection`1<SecurityKey> SecurityKeys { get; }
    public DateTime ValidFrom { get; }
    public DateTime ValidTo { get; }
    internal Byte[] CookieBlob { get; }
    public bool IsCookieMode { get; }
    private DateTime System.ServiceModel.Security.TimeBoundedCache.IExpirableItem.ExpirationTime { get; }
    public SecurityContextSecurityToken(UniqueId contextId, Byte[] key, DateTime validFrom, DateTime validTo);
    public SecurityContextSecurityToken(UniqueId contextId, string id, Byte[] key, DateTime validFrom, DateTime validTo);
    public SecurityContextSecurityToken(UniqueId contextId, string id, Byte[] key, DateTime validFrom, DateTime validTo, ReadOnlyCollection`1<IAuthorizationPolicy> authorizationPolicies);
    public SecurityContextSecurityToken(UniqueId contextId, string id, Byte[] key, DateTime validFrom, DateTime validTo, UniqueId keyGeneration, DateTime keyEffectiveTime, DateTime keyExpirationTime, ReadOnlyCollection`1<IAuthorizationPolicy> authorizationPolicies);
    internal SecurityContextSecurityToken(SecurityContextSecurityToken sourceToken, string id);
    internal SecurityContextSecurityToken(SecurityContextSecurityToken sourceToken, string id, Byte[] key, UniqueId keyGeneration, DateTime keyEffectiveTime, DateTime keyExpirationTime, ReadOnlyCollection`1<IAuthorizationPolicy> authorizationPolicies);
    internal SecurityContextSecurityToken(UniqueId contextId, string id, Byte[] key, DateTime validFrom, DateTime validTo, ReadOnlyCollection`1<IAuthorizationPolicy> authorizationPolicies, bool isCookieMode, Byte[] cookieBlob);
    internal SecurityContextSecurityToken(UniqueId contextId, string id, Byte[] key, DateTime validFrom, DateTime validTo, ReadOnlyCollection`1<IAuthorizationPolicy> authorizationPolicies, bool isCookieMode, Byte[] cookieBlob, UniqueId keyGeneration, DateTime keyEffectiveTime, DateTime keyExpirationTime);
    private SecurityContextSecurityToken(SecurityContextSecurityToken from);
    public SecurityMessageProperty get_BootstrapMessageProperty();
    public void set_BootstrapMessageProperty(SecurityMessageProperty value);
    public virtual string get_Id();
    public UniqueId get_ContextId();
    public UniqueId get_KeyGeneration();
    public DateTime get_KeyEffectiveTime();
    public DateTime get_KeyExpirationTime();
    public ReadOnlyCollection`1<IAuthorizationPolicy> get_AuthorizationPolicies();
    internal void set_AuthorizationPolicies(ReadOnlyCollection`1<IAuthorizationPolicy> value);
    public virtual ReadOnlyCollection`1<SecurityKey> get_SecurityKeys();
    public virtual DateTime get_ValidFrom();
    public virtual DateTime get_ValidTo();
    internal Byte[] get_CookieBlob();
    public bool get_IsCookieMode();
    private sealed virtual override DateTime System.ServiceModel.Security.TimeBoundedCache.IExpirableItem.get_ExpirationTime();
    internal string GetBase64KeyString();
    internal Byte[] GetKeyBytes();
    public virtual string ToString();
    private void Initialize(UniqueId contextId, Byte[] key, DateTime validFrom, DateTime validTo, ReadOnlyCollection`1<IAuthorizationPolicy> authorizationPolicies, bool isCookieMode, UniqueId keyGeneration, DateTime keyEffectiveTime, DateTime keyExpirationTime);
    public static SecurityContextSecurityToken CreateCookieSecurityContextToken(UniqueId contextId, string id, Byte[] key, DateTime validFrom, DateTime validTo, ReadOnlyCollection`1<IAuthorizationPolicy> authorizationPolicies, SecurityStateEncoder securityStateEncoder);
    public static SecurityContextSecurityToken CreateCookieSecurityContextToken(UniqueId contextId, string id, Byte[] key, DateTime validFrom, DateTime validTo, UniqueId keyGeneration, DateTime keyEffectiveTime, DateTime keyExpirationTime, ReadOnlyCollection`1<IAuthorizationPolicy> authorizationPolicies, SecurityStateEncoder securityStateEncoder);
    internal SecurityContextSecurityToken Clone();
    public sealed virtual void Dispose();
    private void ThrowIfDisposed();
}
internal class System.ServiceModel.Security.Tokens.SecurityTokenContainer : object {
    private SecurityToken _token;
    public SecurityToken Token { get; }
    public SecurityTokenContainer(SecurityToken token);
    public SecurityToken get_Token();
}
public enum System.ServiceModel.Security.Tokens.SecurityTokenInclusionMode : Enum {
    public int value__;
    public static SecurityTokenInclusionMode AlwaysToRecipient;
    public static SecurityTokenInclusionMode Never;
    public static SecurityTokenInclusionMode Once;
    public static SecurityTokenInclusionMode AlwaysToInitiator;
}
internal static class System.ServiceModel.Security.Tokens.SecurityTokenInclusionModeHelper : object {
    public static bool IsDefined(SecurityTokenInclusionMode value);
    public static void Validate(SecurityTokenInclusionMode value);
}
public abstract class System.ServiceModel.Security.Tokens.SecurityTokenParameters : object {
    internal static bool defaultRequireDerivedKeys;
    private bool _requireDerivedKeys;
    protected internal bool HasAsymmetricKey { get; }
    public bool RequireDerivedKeys { get; public set; }
    protected internal bool SupportsClientAuthentication { get; }
    protected internal bool SupportsServerAuthentication { get; }
    protected internal bool SupportsClientWindowsIdentity { get; }
    protected SecurityTokenParameters(SecurityTokenParameters other);
    protected internal abstract virtual bool get_HasAsymmetricKey();
    public bool get_RequireDerivedKeys();
    public void set_RequireDerivedKeys(bool value);
    protected internal abstract virtual bool get_SupportsClientAuthentication();
    protected internal abstract virtual bool get_SupportsServerAuthentication();
    protected internal abstract virtual bool get_SupportsClientWindowsIdentity();
    public SecurityTokenParameters Clone();
    protected abstract virtual SecurityTokenParameters CloneCore();
    public virtual string ToString();
}
internal class System.ServiceModel.Security.Tokens.SecurityTokenProviderContainer : object {
    private SecurityTokenProvider _tokenProvider;
    public SecurityTokenProvider TokenProvider { get; }
    public SecurityTokenProviderContainer(SecurityTokenProvider tokenProvider);
    public SecurityTokenProvider get_TokenProvider();
    public void Close(TimeSpan timeout);
    public void Open(TimeSpan timeout);
    public void Abort();
}
public enum System.ServiceModel.Security.Tokens.SecurityTokenReferenceStyle : Enum {
    public int value__;
    public static SecurityTokenReferenceStyle Internal;
    public static SecurityTokenReferenceStyle External;
}
public abstract class System.ServiceModel.Security.Tokens.ServiceModelSecurityTokenRequirement : SecurityTokenRequirement {
    protected static string Namespace;
    private static string securityAlgorithmSuiteProperty;
    private static string securityBindingElementProperty;
    private static string issuerAddressProperty;
    private static string issuerBindingProperty;
    private static string secureConversationSecurityBindingElementProperty;
    private static string supportSecurityContextCancellationProperty;
    private static string messageSecurityVersionProperty;
    private static string defaultMessageSecurityVersionProperty;
    private static string issuerBindingContextProperty;
    private static string transportSchemeProperty;
    private static string isInitiatorProperty;
    private static string targetAddressProperty;
    private static string viaProperty;
    private static string listenUriProperty;
    private static string auditLogLocationProperty;
    private static string suppressAuditFailureProperty;
    private static string messageAuthenticationAuditLevelProperty;
    private static string isOutOfBandTokenProperty;
    private static string preferSslCertificateAuthenticatorProperty;
    private static string supportingTokenAttachmentModeProperty;
    private static string messageDirectionProperty;
    private static string httpAuthenticationSchemeProperty;
    private static string issuedSecurityTokenParametersProperty;
    private static string privacyNoticeUriProperty;
    private static string privacyNoticeVersionProperty;
    private static string duplexClientLocalAddressProperty;
    private static string endpointFilterTableProperty;
    private static string channelParametersCollectionProperty;
    private static string extendedProtectionPolicy;
    private static bool defaultSupportSecurityContextCancellation;
    public static string SecurityAlgorithmSuiteProperty { get; }
    public static string SecurityBindingElementProperty { get; }
    public static string IssuerAddressProperty { get; }
    public static string IssuerBindingProperty { get; }
    public static string SecureConversationSecurityBindingElementProperty { get; }
    public static string SupportSecurityContextCancellationProperty { get; }
    public static string MessageSecurityVersionProperty { get; }
    internal static string DefaultMessageSecurityVersionProperty { get; }
    public static string IssuerBindingContextProperty { get; }
    public static string TransportSchemeProperty { get; }
    public static string IsInitiatorProperty { get; }
    public static string TargetAddressProperty { get; }
    public static string ViaProperty { get; }
    public static string ListenUriProperty { get; }
    public static string AuditLogLocationProperty { get; }
    public static string SuppressAuditFailureProperty { get; }
    public static string MessageAuthenticationAuditLevelProperty { get; }
    public static string IsOutOfBandTokenProperty { get; }
    public static string PreferSslCertificateAuthenticatorProperty { get; }
    public static string SupportingTokenAttachmentModeProperty { get; }
    public static string MessageDirectionProperty { get; }
    public static string HttpAuthenticationSchemeProperty { get; }
    public static string IssuedSecurityTokenParametersProperty { get; }
    public static string PrivacyNoticeUriProperty { get; }
    public static string PrivacyNoticeVersionProperty { get; }
    public static string DuplexClientLocalAddressProperty { get; }
    public static string EndpointFilterTableProperty { get; }
    public static string ChannelParametersCollectionProperty { get; }
    public static string ExtendedProtectionPolicy { get; }
    public bool IsInitiator { get; }
    public SecurityAlgorithmSuite SecurityAlgorithmSuite { get; public set; }
    public SecurityBindingElement SecurityBindingElement { get; public set; }
    public EndpointAddress IssuerAddress { get; public set; }
    public Binding IssuerBinding { get; public set; }
    public SecurityBindingElement SecureConversationSecurityBindingElement { get; public set; }
    public SecurityTokenVersion MessageSecurityVersion { get; public set; }
    internal MessageSecurityVersion DefaultMessageSecurityVersion { get; internal set; }
    public string TransportScheme { get; public set; }
    internal bool SupportSecurityContextCancellation { get; internal set; }
    internal EndpointAddress DuplexClientLocalAddress { get; internal set; }
    public static string get_SecurityAlgorithmSuiteProperty();
    public static string get_SecurityBindingElementProperty();
    public static string get_IssuerAddressProperty();
    public static string get_IssuerBindingProperty();
    public static string get_SecureConversationSecurityBindingElementProperty();
    public static string get_SupportSecurityContextCancellationProperty();
    public static string get_MessageSecurityVersionProperty();
    internal static string get_DefaultMessageSecurityVersionProperty();
    public static string get_IssuerBindingContextProperty();
    public static string get_TransportSchemeProperty();
    public static string get_IsInitiatorProperty();
    public static string get_TargetAddressProperty();
    public static string get_ViaProperty();
    public static string get_ListenUriProperty();
    public static string get_AuditLogLocationProperty();
    public static string get_SuppressAuditFailureProperty();
    public static string get_MessageAuthenticationAuditLevelProperty();
    public static string get_IsOutOfBandTokenProperty();
    public static string get_PreferSslCertificateAuthenticatorProperty();
    public static string get_SupportingTokenAttachmentModeProperty();
    public static string get_MessageDirectionProperty();
    public static string get_HttpAuthenticationSchemeProperty();
    public static string get_IssuedSecurityTokenParametersProperty();
    public static string get_PrivacyNoticeUriProperty();
    public static string get_PrivacyNoticeVersionProperty();
    public static string get_DuplexClientLocalAddressProperty();
    public static string get_EndpointFilterTableProperty();
    public static string get_ChannelParametersCollectionProperty();
    public static string get_ExtendedProtectionPolicy();
    public bool get_IsInitiator();
    public SecurityAlgorithmSuite get_SecurityAlgorithmSuite();
    public void set_SecurityAlgorithmSuite(SecurityAlgorithmSuite value);
    public SecurityBindingElement get_SecurityBindingElement();
    public void set_SecurityBindingElement(SecurityBindingElement value);
    public EndpointAddress get_IssuerAddress();
    public void set_IssuerAddress(EndpointAddress value);
    public Binding get_IssuerBinding();
    public void set_IssuerBinding(Binding value);
    public SecurityBindingElement get_SecureConversationSecurityBindingElement();
    public void set_SecureConversationSecurityBindingElement(SecurityBindingElement value);
    public SecurityTokenVersion get_MessageSecurityVersion();
    public void set_MessageSecurityVersion(SecurityTokenVersion value);
    internal MessageSecurityVersion get_DefaultMessageSecurityVersion();
    internal void set_DefaultMessageSecurityVersion(MessageSecurityVersion value);
    public string get_TransportScheme();
    public void set_TransportScheme(string value);
    internal bool get_SupportSecurityContextCancellation();
    internal void set_SupportSecurityContextCancellation(bool value);
    internal EndpointAddress get_DuplexClientLocalAddress();
    internal void set_DuplexClientLocalAddress(EndpointAddress value);
    internal TValue GetPropertyOrDefault(string propertyName, TValue defaultValue);
    internal string InternalToString();
}
public static class System.ServiceModel.Security.Tokens.ServiceModelSecurityTokenTypes : object {
    private static string Namespace;
    private static string spnego;
    private static string mutualSslnego;
    private static string anonymousSslnego;
    private static string securityContext;
    private static string secureConversation;
    private static string sspiCredential;
    public static string Spnego { get; }
    public static string MutualSslnego { get; }
    public static string AnonymousSslnego { get; }
    public static string SecurityContext { get; }
    public static string SecureConversation { get; }
    public static string SspiCredential { get; }
    public static string get_Spnego();
    public static string get_MutualSslnego();
    public static string get_AnonymousSslnego();
    public static string get_SecurityContext();
    public static string get_SecureConversation();
    public static string get_SspiCredential();
}
public class System.ServiceModel.Security.Tokens.SspiSecurityToken : SecurityToken {
    private string _id;
    private TokenImpersonationLevel _impersonationLevel;
    private bool _allowNtlm;
    private NetworkCredential _networkCredential;
    private bool _extractGroupsForWindowsAccounts;
    private bool _allowUnauthenticatedCallers;
    private DateTime _effectiveTime;
    private DateTime _expirationTime;
    public string Id { get; }
    public DateTime ValidFrom { get; }
    public DateTime ValidTo { get; }
    public bool AllowUnauthenticatedCallers { get; }
    public TokenImpersonationLevel ImpersonationLevel { get; }
    public bool AllowNtlm { get; }
    public NetworkCredential NetworkCredential { get; }
    public bool ExtractGroupsForWindowsAccounts { get; }
    public ReadOnlyCollection`1<SecurityKey> SecurityKeys { get; }
    public SspiSecurityToken(TokenImpersonationLevel impersonationLevel, bool allowNtlm, NetworkCredential networkCredential);
    public SspiSecurityToken(NetworkCredential networkCredential, bool extractGroupsForWindowsAccounts, bool allowUnauthenticatedCallers);
    public virtual string get_Id();
    public virtual DateTime get_ValidFrom();
    public virtual DateTime get_ValidTo();
    public bool get_AllowUnauthenticatedCallers();
    public TokenImpersonationLevel get_ImpersonationLevel();
    public bool get_AllowNtlm();
    public NetworkCredential get_NetworkCredential();
    public bool get_ExtractGroupsForWindowsAccounts();
    public virtual ReadOnlyCollection`1<SecurityKey> get_SecurityKeys();
}
public class System.ServiceModel.Security.Tokens.SupportingTokenParameters : object {
    private Collection`1<SecurityTokenParameters> _signed;
    private Collection`1<SecurityTokenParameters> _signedEncrypted;
    private Collection`1<SecurityTokenParameters> _endorsing;
    private Collection`1<SecurityTokenParameters> _signedEndorsing;
    public Collection`1<SecurityTokenParameters> Endorsing { get; }
    public Collection`1<SecurityTokenParameters> SignedEndorsing { get; }
    public Collection`1<SecurityTokenParameters> Signed { get; }
    public Collection`1<SecurityTokenParameters> SignedEncrypted { get; }
    private SupportingTokenParameters(SupportingTokenParameters other);
    public Collection`1<SecurityTokenParameters> get_Endorsing();
    public Collection`1<SecurityTokenParameters> get_SignedEndorsing();
    public Collection`1<SecurityTokenParameters> get_Signed();
    public Collection`1<SecurityTokenParameters> get_SignedEncrypted();
    public void SetKeyDerivation(bool requireDerivedKeys);
    internal bool IsSetKeyDerivation(bool requireDerivedKeys);
    public virtual string ToString();
    public SupportingTokenParameters Clone();
    protected virtual SupportingTokenParameters CloneCore();
    internal bool IsEmpty();
}
internal static class System.ServiceModel.Security.Tokens.TokenReferenceStyleHelper : object {
    public static bool IsDefined(SecurityTokenReferenceStyle value);
    public static void Validate(SecurityTokenReferenceStyle value);
}
public class System.ServiceModel.Security.Tokens.UserNameSecurityTokenParameters : SecurityTokenParameters {
    protected internal bool HasAsymmetricKey { get; }
    protected internal bool SupportsClientAuthentication { get; }
    protected internal bool SupportsServerAuthentication { get; }
    protected internal bool SupportsClientWindowsIdentity { get; }
    protected UserNameSecurityTokenParameters(UserNameSecurityTokenParameters other);
    protected internal virtual bool get_HasAsymmetricKey();
    protected internal virtual bool get_SupportsClientAuthentication();
    protected internal virtual bool get_SupportsServerAuthentication();
    protected internal virtual bool get_SupportsClientWindowsIdentity();
    protected virtual SecurityTokenParameters CloneCore();
}
internal class System.ServiceModel.Security.Tokens.WindowsSidIdentity : object {
    private SecurityIdentifier _sid;
    private string _name;
    private string _authenticationType;
    public SecurityIdentifier SecurityIdentifier { get; }
    public string AuthenticationType { get; }
    public bool IsAuthenticated { get; }
    public string Name { get; }
    public WindowsSidIdentity(SecurityIdentifier sid);
    public WindowsSidIdentity(SecurityIdentifier sid, string name, string authenticationType);
    public SecurityIdentifier get_SecurityIdentifier();
    public sealed virtual string get_AuthenticationType();
    public sealed virtual bool get_IsAuthenticated();
    public sealed virtual string get_Name();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public enum System.ServiceModel.Security.Tokens.X509KeyIdentifierClauseType : Enum {
    public int value__;
    public static X509KeyIdentifierClauseType Any;
    public static X509KeyIdentifierClauseType Thumbprint;
    public static X509KeyIdentifierClauseType IssuerSerial;
    public static X509KeyIdentifierClauseType SubjectKeyIdentifier;
    public static X509KeyIdentifierClauseType RawDataKeyIdentifier;
}
internal static class System.ServiceModel.Security.Tokens.X509SecurityTokenReferenceStyleHelper : object {
    public static bool IsDefined(X509KeyIdentifierClauseType value);
    public static void Validate(X509KeyIdentifierClauseType value);
}
internal abstract class System.ServiceModel.Security.TrustDriver : object {
    public bool IsIssuedTokensSupported { get; }
    public string IssuedTokensHeaderName { get; }
    public string IssuedTokensHeaderNamespace { get; }
    public bool IsSessionSupported { get; }
    public XmlDictionaryString RequestSecurityTokenAction { get; }
    public XmlDictionaryString RequestSecurityTokenResponseAction { get; }
    public XmlDictionaryString RequestSecurityTokenResponseFinalAction { get; }
    public string RequestTypeClose { get; }
    public string RequestTypeIssue { get; }
    public string RequestTypeRenew { get; }
    public string ComputedKeyAlgorithm { get; }
    public SecurityStandardsManager StandardsManager { get; }
    public XmlDictionaryString Namespace { get; }
    public virtual bool get_IsIssuedTokensSupported();
    public virtual string get_IssuedTokensHeaderName();
    public virtual string get_IssuedTokensHeaderNamespace();
    public virtual bool get_IsSessionSupported();
    public abstract virtual XmlDictionaryString get_RequestSecurityTokenAction();
    public abstract virtual XmlDictionaryString get_RequestSecurityTokenResponseAction();
    public abstract virtual XmlDictionaryString get_RequestSecurityTokenResponseFinalAction();
    public virtual string get_RequestTypeClose();
    public abstract virtual string get_RequestTypeIssue();
    public virtual string get_RequestTypeRenew();
    public abstract virtual string get_ComputedKeyAlgorithm();
    public abstract virtual SecurityStandardsManager get_StandardsManager();
    public abstract virtual XmlDictionaryString get_Namespace();
    public abstract virtual RequestSecurityToken CreateRequestSecurityToken(XmlReader reader);
    public abstract virtual RequestSecurityTokenResponse CreateRequestSecurityTokenResponse(XmlReader reader);
    public abstract virtual RequestSecurityTokenResponseCollection CreateRequestSecurityTokenResponseCollection(XmlReader xmlReader);
    public abstract virtual bool IsAtRequestSecurityTokenResponse(XmlReader reader);
    public abstract virtual bool IsAtRequestSecurityTokenResponseCollection(XmlReader reader);
    public abstract virtual bool IsRequestedSecurityTokenElement(string name, string nameSpace);
    public abstract virtual bool IsRequestedProofTokenElement(string name, string nameSpace);
    public abstract virtual T GetAppliesTo(RequestSecurityToken rst, XmlObjectSerializer serializer);
    public abstract virtual T GetAppliesTo(RequestSecurityTokenResponse rstr, XmlObjectSerializer serializer);
    public abstract virtual void GetAppliesToQName(RequestSecurityToken rst, String& localName, String& namespaceUri);
    public abstract virtual void GetAppliesToQName(RequestSecurityTokenResponse rstr, String& localName, String& namespaceUri);
    public abstract virtual bool IsAppliesTo(string localName, string namespaceUri);
    public abstract virtual Byte[] GetAuthenticator(RequestSecurityTokenResponse rstr);
    public abstract virtual BinaryNegotiation GetBinaryNegotiation(RequestSecurityToken rst);
    public abstract virtual BinaryNegotiation GetBinaryNegotiation(RequestSecurityTokenResponse rstr);
    public abstract virtual SecurityToken GetEntropy(RequestSecurityToken rst, SecurityTokenResolver resolver);
    public abstract virtual SecurityToken GetEntropy(RequestSecurityTokenResponse rstr, SecurityTokenResolver resolver);
    public abstract virtual void OnRSTRorRSTRCMissingException();
    public abstract virtual void WriteRequestSecurityToken(RequestSecurityToken rst, XmlWriter w);
    public abstract virtual void WriteRequestSecurityTokenResponse(RequestSecurityTokenResponse rstr, XmlWriter w);
    public abstract virtual void WriteRequestSecurityTokenResponseCollection(RequestSecurityTokenResponseCollection rstrCollection, XmlWriter writer);
    public abstract virtual IChannelFactory`1<IRequestChannel> CreateFederationProxy(EndpointAddress address, Binding binding, KeyedByTypeCollection`1<IEndpointBehavior> channelBehaviors);
}
public abstract class System.ServiceModel.Security.TrustVersion : object {
    private XmlDictionaryString _trustNamespace;
    private XmlDictionaryString _prefix;
    public XmlDictionaryString Namespace { get; }
    public XmlDictionaryString Prefix { get; }
    public static TrustVersion Default { get; }
    public static TrustVersion WSTrustFeb2005 { get; }
    public static TrustVersion WSTrust13 { get; }
    internal TrustVersion(XmlDictionaryString ns, XmlDictionaryString prefix);
    public XmlDictionaryString get_Namespace();
    public XmlDictionaryString get_Prefix();
    public static TrustVersion get_Default();
    public static TrustVersion get_WSTrustFeb2005();
    public static TrustVersion get_WSTrust13();
}
public class System.ServiceModel.Security.UserNamePasswordClientCredential : object {
    private string _userName;
    private string _password;
    private bool _isReadOnly;
    public string UserName { get; public set; }
    public string Password { get; public set; }
    internal UserNamePasswordClientCredential(UserNamePasswordClientCredential other);
    public string get_UserName();
    public void set_UserName(string value);
    public string get_Password();
    public void set_Password(string value);
    internal void MakeReadOnly();
    private void ThrowIfImmutable();
}
public class System.ServiceModel.Security.WindowsClientCredential : object {
    internal static TokenImpersonationLevel DefaultImpersonationLevel;
    private TokenImpersonationLevel _allowedImpersonationLevel;
    private NetworkCredential _windowsCredentials;
    private bool _allowNtlm;
    private bool _isReadOnly;
    public TokenImpersonationLevel AllowedImpersonationLevel { get; public set; }
    public NetworkCredential ClientCredential { get; public set; }
    [ObsoleteAttribute("This property is deprecated and is maintained for backward compatibility only. The local machine policy will be used to determine if NTLM should be used.")]
public bool AllowNtlm { get; public set; }
    internal WindowsClientCredential(WindowsClientCredential other);
    public TokenImpersonationLevel get_AllowedImpersonationLevel();
    public void set_AllowedImpersonationLevel(TokenImpersonationLevel value);
    public NetworkCredential get_ClientCredential();
    public void set_ClientCredential(NetworkCredential value);
    public bool get_AllowNtlm();
    public void set_AllowNtlm(bool value);
    internal void MakeReadOnly();
    private void ThrowIfImmutable();
}
internal class System.ServiceModel.Security.WrapperSecurityCommunicationObject : CommunicationObject {
    private ISecurityCommunicationObject _innerCommunicationObject;
    protected TimeSpan DefaultCloseTimeout { get; }
    protected TimeSpan DefaultOpenTimeout { get; }
    public WrapperSecurityCommunicationObject(ISecurityCommunicationObject innerCommunicationObject);
    protected virtual Type GetCommunicationObjectType();
    protected virtual TimeSpan get_DefaultCloseTimeout();
    protected virtual TimeSpan get_DefaultOpenTimeout();
    protected virtual void OnAbort();
    protected virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual IAsyncResult OnBeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnClose(TimeSpan timeout);
    protected virtual void OnClosed();
    protected virtual void OnClosing();
    protected virtual void OnEndClose(IAsyncResult result);
    protected virtual void OnEndOpen(IAsyncResult result);
    protected virtual void OnFaulted();
    protected virtual void OnOpen(TimeSpan timeout);
    protected virtual void OnOpened();
    protected virtual void OnOpening();
    internal void ThrowIfDisposedOrImmutable();
    [AsyncStateMachineAttribute("System.ServiceModel.Security.WrapperSecurityCommunicationObject/<OnCloseAsync>d__20")]
protected internal virtual Task OnCloseAsync(TimeSpan timeout);
    [AsyncStateMachineAttribute("System.ServiceModel.Security.WrapperSecurityCommunicationObject/<OnOpenAsync>d__21")]
protected internal virtual Task OnOpenAsync(TimeSpan timeout);
}
internal class System.ServiceModel.Security.WSSecurityOneDotOneReceiveSecurityHeader : WSSecurityOneDotZeroReceiveSecurityHeader {
    public WSSecurityOneDotOneReceiveSecurityHeader(Message message, string actor, bool mustUnderstand, bool relay, SecurityStandardsManager standardsManager, SecurityAlgorithmSuite algorithmSuite, int headerIndex, MessageDirection direction);
}
internal class System.ServiceModel.Security.WSSecurityOneDotOneSendSecurityHeader : WSSecurityOneDotZeroSendSecurityHeader {
    public WSSecurityOneDotOneSendSecurityHeader(Message message, string actor, bool mustUnderstand, bool relay, SecurityStandardsManager standardsManager, SecurityAlgorithmSuite algorithmSuite, MessageDirection direction);
}
internal class System.ServiceModel.Security.WSSecurityOneDotZeroReceiveSecurityHeader : ReceiveSecurityHeader {
    public WSSecurityOneDotZeroReceiveSecurityHeader(Message message, string actor, bool mustUnderstand, bool relay, SecurityStandardsManager standardsManager, SecurityAlgorithmSuite algorithmSuite, int headerIndex, MessageDirection transferDirection);
}
internal class System.ServiceModel.Security.WSSecurityOneDotZeroSendSecurityHeader : SendSecurityHeader {
    public WSSecurityOneDotZeroSendSecurityHeader(Message message, string actor, bool mustUnderstand, bool relay, SecurityStandardsManager standardsManager, SecurityAlgorithmSuite algorithmSuite, MessageDirection direction);
}
internal abstract class System.ServiceModel.Security.WSSecurityPolicy : object {
    public static ContractDescription NullContract;
    public static ServiceEndpoint NullServiceEndpoint;
    public static XmlDocument doc;
    public static string WsspPrefix;
    public static string WspNamespace;
    public static string Wsp15Namespace;
    public static string WspPrefix;
    public static string MsspNamespace;
    public static string MsspPrefix;
    public static string PolicyName;
    public static string OptionalName;
    public static string TrueName;
    public static string FalseName;
    public static string SymmetricBindingName;
    public static string AsymmetricBindingName;
    public static string TransportBindingName;
    public static string OnlySignEntireHeadersAndBodyName;
    public static string ProtectionTokenName;
    public static string InitiatorTokenName;
    public static string RecipientTokenName;
    public static string TransportTokenName;
    public static string AlgorithmSuiteName;
    public static string LaxName;
    public static string LaxTsLastName;
    public static string LaxTsFirstName;
    public static string StrictName;
    public static string IncludeTimestampName;
    public static string EncryptBeforeSigningName;
    public static string ProtectTokens;
    public static string EncryptSignatureName;
    public static string SignedSupportingTokensName;
    public static string EndorsingSupportingTokensName;
    public static string SignedEndorsingSupportingTokensName;
    public static string Wss10Name;
    public static string MustSupportRefKeyIdentifierName;
    public static string MustSupportRefIssuerSerialName;
    public static string MustSupportRefThumbprintName;
    public static string MustSupportRefEncryptedKeyName;
    public static string RequireSignatureConfirmationName;
    public static string MustSupportIssuedTokensName;
    public static string RequireClientEntropyName;
    public static string RequireServerEntropyName;
    public static string Wss11Name;
    public static string Trust10Name;
    public static string Trust13Name;
    public static string RequireAppliesTo;
    public static string SignedPartsName;
    public static string EncryptedPartsName;
    public static string BodyName;
    public static string HeaderName;
    public static string NameName;
    public static string NamespaceName;
    public static string Basic128Name;
    public static string Basic192Name;
    public static string Basic256Name;
    public static string TripleDesName;
    public static string Basic128Rsa15Name;
    public static string Basic192Rsa15Name;
    public static string Basic256Rsa15Name;
    public static string TripleDesRsa15Name;
    public static string Basic128Sha256Name;
    public static string Basic192Sha256Name;
    public static string Basic256Sha256Name;
    public static string TripleDesSha256Name;
    public static string Basic128Sha256Rsa15Name;
    public static string Basic192Sha256Rsa15Name;
    public static string Basic256Sha256Rsa15Name;
    public static string TripleDesSha256Rsa15Name;
    public static string IncludeTokenName;
    public static string KerberosTokenName;
    public static string X509TokenName;
    public static string IssuedTokenName;
    public static string UsernameTokenName;
    public static string RsaTokenName;
    public static string KeyValueTokenName;
    public static string SpnegoContextTokenName;
    public static string SslContextTokenName;
    public static string SecureConversationTokenName;
    public static string WssGssKerberosV5ApReqToken11Name;
    public static string RequireDerivedKeysName;
    public static string RequireIssuerSerialReferenceName;
    public static string RequireKeyIdentifierReferenceName;
    public static string RequireThumbprintReferenceName;
    public static string WssX509V3Token10Name;
    public static string WssUsernameToken10Name;
    public static string RequestSecurityTokenTemplateName;
    public static string RequireExternalReferenceName;
    public static string RequireInternalReferenceName;
    public static string IssuerName;
    public static string RequireClientCertificateName;
    public static string MustNotSendCancelName;
    public static string MustNotSendAmendName;
    public static string MustNotSendRenewName;
    public static string LayoutName;
    public static string BootstrapPolicyName;
    public static string HttpsTokenName;
    public static string HttpBasicAuthenticationName;
    public static string HttpDigestAuthenticationName;
    private static WSSecurityPolicy();
}
public class System.ServiceModel.Security.WSSecurityTokenSerializer : SecurityTokenSerializer {
    private static int DefaultMaximumKeyDerivationOffset;
    private static int DefaultMaximumKeyDerivationLabelLength;
    private static int DefaultMaximumKeyDerivationNonceLength;
    private static WSSecurityTokenSerializer s_instance;
    private List`1<TokenEntry> _tokenEntries;
    public static WSSecurityTokenSerializer DefaultInstance { get; }
    public bool EmitBspRequiredAttributes { get; }
    public SecurityVersion SecurityVersion { get; }
    public int MaximumKeyDerivationOffset { get; }
    public int MaximumKeyDerivationLabelLength { get; }
    public int MaximumKeyDerivationNonceLength { get; }
    public WSSecurityTokenSerializer(bool emitBspRequiredAttributes);
    public WSSecurityTokenSerializer(SecurityVersion securityVersion);
    public WSSecurityTokenSerializer(SecurityVersion securityVersion, bool emitBspRequiredAttributes);
    public WSSecurityTokenSerializer(SecurityVersion securityVersion, bool emitBspRequiredAttributes, SamlSerializer samlSerializer);
    public WSSecurityTokenSerializer(SecurityVersion securityVersion, bool emitBspRequiredAttributes, SamlSerializer samlSerializer, SecurityStateEncoder securityStateEncoder, IEnumerable`1<Type> knownTypes);
    public WSSecurityTokenSerializer(SecurityVersion securityVersion, TrustVersion trustVersion, SecureConversationVersion secureConversationVersion, bool emitBspRequiredAttributes, SamlSerializer samlSerializer, SecurityStateEncoder securityStateEncoder, IEnumerable`1<Type> knownTypes);
    public WSSecurityTokenSerializer(SecurityVersion securityVersion, bool emitBspRequiredAttributes, SamlSerializer samlSerializer, SecurityStateEncoder securityStateEncoder, IEnumerable`1<Type> knownTypes, int maximumKeyDerivationOffset, int maximumKeyDerivationLabelLength, int maximumKeyDerivationNonceLength);
    public WSSecurityTokenSerializer(SecurityVersion securityVersion, TrustVersion trustVersion, SecureConversationVersion secureConversationVersion, bool emitBspRequiredAttributes, SamlSerializer samlSerializer, SecurityStateEncoder securityStateEncoder, IEnumerable`1<Type> knownTypes, int maximumKeyDerivationOffset, int maximumKeyDerivationLabelLength, int maximumKeyDerivationNonceLength);
    public static WSSecurityTokenSerializer get_DefaultInstance();
    public bool get_EmitBspRequiredAttributes();
    public SecurityVersion get_SecurityVersion();
    public int get_MaximumKeyDerivationOffset();
    public int get_MaximumKeyDerivationLabelLength();
    public int get_MaximumKeyDerivationNonceLength();
    private bool ShouldWrapException(Exception e);
    protected virtual bool CanReadTokenCore(XmlReader reader);
    protected virtual SecurityToken ReadTokenCore(XmlReader reader, SecurityTokenResolver tokenResolver);
    protected virtual bool CanWriteTokenCore(SecurityToken token);
    protected virtual void WriteTokenCore(XmlWriter writer, SecurityToken token);
    protected virtual bool CanReadKeyIdentifierCore(XmlReader reader);
    protected virtual SecurityKeyIdentifier ReadKeyIdentifierCore(XmlReader reader);
    protected virtual bool CanWriteKeyIdentifierCore(SecurityKeyIdentifier keyIdentifier);
    protected virtual void WriteKeyIdentifierCore(XmlWriter writer, SecurityKeyIdentifier keyIdentifier);
    protected virtual bool CanReadKeyIdentifierClauseCore(XmlReader reader);
    protected virtual SecurityKeyIdentifierClause ReadKeyIdentifierClauseCore(XmlReader reader);
    protected virtual bool CanWriteKeyIdentifierClauseCore(SecurityKeyIdentifierClause keyIdentifierClause);
    protected virtual void WriteKeyIdentifierClauseCore(XmlWriter writer, SecurityKeyIdentifierClause keyIdentifierClause);
    internal Type[] GetTokenTypes(string tokenTypeUri);
    protected internal virtual string GetTokenTypeUri(Type tokenType);
    public virtual bool TryCreateKeyIdentifierClauseFromTokenXml(XmlElement element, SecurityTokenReferenceStyle tokenReferenceStyle, SecurityKeyIdentifierClause& securityKeyIdentifierClause);
    public virtual SecurityKeyIdentifierClause CreateKeyIdentifierClauseFromTokenXml(XmlElement element, SecurityTokenReferenceStyle tokenReferenceStyle);
}
internal abstract class System.ServiceModel.Security.WSUtilitySpecificationVersion : object {
    internal static String[] AcceptedDateTimeFormats;
    private XmlDictionaryString _namespaceUri;
    public static WSUtilitySpecificationVersion Default { get; }
    internal XmlDictionaryString NamespaceUri { get; }
    public static WSUtilitySpecificationVersion OneDotZero { get; }
    internal WSUtilitySpecificationVersion(XmlDictionaryString namespaceUri);
    private static WSUtilitySpecificationVersion();
    public static WSUtilitySpecificationVersion get_Default();
    internal XmlDictionaryString get_NamespaceUri();
    public static WSUtilitySpecificationVersion get_OneDotZero();
    internal abstract virtual bool IsReaderAtTimestamp(XmlDictionaryReader reader);
    internal abstract virtual SecurityTimestamp ReadTimestamp(XmlDictionaryReader reader, string digestAlgorithm, SignatureResourcePool resourcePool);
    internal abstract virtual void WriteTimestamp(XmlDictionaryWriter writer, SecurityTimestamp timestamp);
    internal abstract virtual void WriteTimestampCanonicalForm(Stream stream, SecurityTimestamp timestamp, Byte[] buffer);
}
public class System.ServiceModel.Security.X509CertificateInitiatorClientCredential : object {
    internal static StoreLocation DefaultStoreLocation;
    internal static StoreName DefaultStoreName;
    internal static X509FindType DefaultFindType;
    private X509Certificate2 _certificate;
    private bool _isReadOnly;
    public X509Certificate2 Certificate { get; public set; }
    internal bool CloneCertificate { get; }
    internal X509CertificateInitiatorClientCredential(X509CertificateInitiatorClientCredential other);
    public X509Certificate2 get_Certificate();
    public void set_Certificate(X509Certificate2 value);
    internal bool get_CloneCertificate();
    public void SetCertificate(StoreLocation storeLocation, StoreName storeName, X509FindType findType, object findValue);
    public void SetCertificate(string subjectName, StoreLocation storeLocation, StoreName storeName);
    internal void MakeReadOnly();
    private void ThrowIfImmutable();
}
public class System.ServiceModel.Security.X509CertificateRecipientClientCredential : object {
    private X509ServiceCertificateAuthentication _authentication;
    private X509ServiceCertificateAuthentication _sslCertificateAuthentication;
    internal static StoreLocation DefaultStoreLocation;
    internal static StoreName DefaultStoreName;
    internal static X509FindType DefaultFindType;
    private X509Certificate2 _defaultCertificate;
    private Dictionary`2<Uri, X509Certificate2> _scopedCertificates;
    private bool _isReadOnly;
    public X509Certificate2 DefaultCertificate { get; public set; }
    public Dictionary`2<Uri, X509Certificate2> ScopedCertificates { get; }
    public X509ServiceCertificateAuthentication Authentication { get; }
    public X509ServiceCertificateAuthentication SslCertificateAuthentication { get; public set; }
    internal X509CertificateRecipientClientCredential(X509CertificateRecipientClientCredential other);
    public X509Certificate2 get_DefaultCertificate();
    public void set_DefaultCertificate(X509Certificate2 value);
    public Dictionary`2<Uri, X509Certificate2> get_ScopedCertificates();
    public X509ServiceCertificateAuthentication get_Authentication();
    public X509ServiceCertificateAuthentication get_SslCertificateAuthentication();
    public void set_SslCertificateAuthentication(X509ServiceCertificateAuthentication value);
    public void SetDefaultCertificate(string subjectName, StoreLocation storeLocation, StoreName storeName);
    public void SetDefaultCertificate(StoreLocation storeLocation, StoreName storeName, X509FindType findType, object findValue);
    public void SetScopedCertificate(string subjectName, StoreLocation storeLocation, StoreName storeName, Uri targetService);
    public void SetScopedCertificate(StoreLocation storeLocation, StoreName storeName, X509FindType findType, object findValue, Uri targetService);
    internal void MakeReadOnly();
    private void ThrowIfImmutable();
}
public enum System.ServiceModel.Security.X509CertificateValidationMode : Enum {
    public int value__;
    public static X509CertificateValidationMode None;
    public static X509CertificateValidationMode PeerTrust;
    public static X509CertificateValidationMode ChainTrust;
    public static X509CertificateValidationMode PeerOrChainTrust;
    public static X509CertificateValidationMode Custom;
}
internal static class System.ServiceModel.Security.X509CertificateValidationModeHelper : object {
    public static bool IsDefined(X509CertificateValidationMode validationMode);
    internal static void Validate(X509CertificateValidationMode value);
}
public class System.ServiceModel.Security.X509ClientCertificateAuthentication : object {
    internal static X509CertificateValidationMode DefaultCertificateValidationMode;
    internal static X509RevocationMode DefaultRevocationMode;
    internal static StoreLocation DefaultTrustedStoreLocation;
    private static X509CertificateValidator s_defaultCertificateValidator;
    internal static X509CertificateValidator DefaultCertificateValidator { get; }
    internal static X509CertificateValidator get_DefaultCertificateValidator();
}
public class System.ServiceModel.Security.X509ServiceCertificateAuthentication : object {
    internal static X509CertificateValidationMode DefaultCertificateValidationMode;
    internal static X509RevocationMode DefaultRevocationMode;
    internal static StoreLocation DefaultTrustedStoreLocation;
    private static X509CertificateValidator s_defaultCertificateValidator;
    private static Oid serverAuthOid;
    private X509CertificateValidationMode _certificateValidationMode;
    private X509RevocationMode _revocationMode;
    private StoreLocation _trustedStoreLocation;
    private X509CertificateValidator _customCertificateValidator;
    private bool _isReadOnly;
    internal static X509CertificateValidator DefaultCertificateValidator { get; }
    public X509CertificateValidationMode CertificateValidationMode { get; public set; }
    public X509RevocationMode RevocationMode { get; public set; }
    public StoreLocation TrustedStoreLocation { get; public set; }
    public X509CertificateValidator CustomCertificateValidator { get; public set; }
    internal X509ServiceCertificateAuthentication(X509ServiceCertificateAuthentication other);
    private static X509ServiceCertificateAuthentication();
    internal static X509CertificateValidator get_DefaultCertificateValidator();
    public X509CertificateValidationMode get_CertificateValidationMode();
    public void set_CertificateValidationMode(X509CertificateValidationMode value);
    public X509RevocationMode get_RevocationMode();
    public void set_RevocationMode(X509RevocationMode value);
    public StoreLocation get_TrustedStoreLocation();
    public void set_TrustedStoreLocation(StoreLocation value);
    public X509CertificateValidator get_CustomCertificateValidator();
    public void set_CustomCertificateValidator(X509CertificateValidator value);
    internal bool TryGetCertificateValidator(X509CertificateValidator& validator);
    internal X509CertificateValidator GetCertificateValidator();
    internal void MakeReadOnly();
    private void ThrowIfImmutable();
}
internal static class System.ServiceModel.Security.XmlHelper : object {
    internal static void AddNamespaceDeclaration(XmlDictionaryWriter writer, string prefix, XmlDictionaryString ns);
    internal static string EnsureNamespaceDefined(XmlDictionaryWriter writer, XmlDictionaryString ns, string defaultPrefix);
    internal static XmlQualifiedName GetAttributeValueAsQName(XmlReader reader, string attributeName);
    internal static XmlElement GetChildElement(XmlElement parent);
    internal static XmlElement GetChildElement(XmlElement parent, string childLocalName, string childNamespace);
    internal static XmlQualifiedName GetValueAsQName(XmlReader reader, string value);
    internal static string GetWhiteSpace(XmlReader reader);
    internal static bool IsWhitespaceOrComment(XmlReader reader);
    internal static void OnChildNodeTypeMissing(string parentName, XmlNodeType expectedNodeType);
    internal static void OnChildNodeTypeMissing(XmlElement parent, XmlNodeType expectedNodeType);
    internal static void OnEmptyElementError(XmlReader r);
    internal static void OnEmptyElementError(XmlElement e);
    internal static void OnEOF();
    internal static void OnNamespaceMissing(string prefix);
    internal static void OnRequiredAttributeMissing(string attrName, string elementName);
    internal static void OnRequiredElementMissing(string elementName, string elementNamespace);
    internal static void OnUnexpectedChildNodeError(string parentName, XmlReader r);
    internal static void OnUnexpectedChildNodeError(XmlElement parent, XmlNode n);
    internal static string ReadEmptyElementAndRequiredAttribute(XmlDictionaryReader reader, XmlDictionaryString name, XmlDictionaryString namespaceUri, XmlDictionaryString attributeName, String& prefix);
    internal static string GetRequiredNonEmptyAttribute(XmlDictionaryReader reader, XmlDictionaryString name, XmlDictionaryString ns);
    internal static Byte[] GetRequiredBase64Attribute(XmlDictionaryReader reader, XmlDictionaryString name, XmlDictionaryString ns);
    internal static void SplitIntoPrefixAndName(string qName, String& prefix, String& name);
    internal static void ValidateIdPrefix(string idPrefix);
    internal static UniqueId GetAttributeAsUniqueId(XmlDictionaryReader reader, XmlDictionaryString localName, XmlDictionaryString ns);
    private static UniqueId GetAttributeAsUniqueId(XmlDictionaryReader reader, string name, string ns);
    public static void WriteAttributeStringAsUniqueId(XmlDictionaryWriter writer, string prefix, XmlDictionaryString localName, XmlDictionaryString ns, UniqueId id);
    public static void WriteElementStringAsUniqueId(XmlWriter writer, string localName, UniqueId id);
    public static void WriteElementStringAsUniqueId(XmlDictionaryWriter writer, XmlDictionaryString localName, XmlDictionaryString ns, UniqueId id);
    public static void WriteElementContentAsInt64(XmlDictionaryWriter writer, XmlDictionaryString localName, XmlDictionaryString ns, long value);
    public static long ReadElementContentAsInt64(XmlDictionaryReader reader);
    public static void WriteStringAsUniqueId(XmlDictionaryWriter writer, UniqueId id);
    public static UniqueId ReadElementStringAsUniqueId(XmlDictionaryReader reader, XmlDictionaryString localName, XmlDictionaryString ns);
    public static UniqueId ReadElementStringAsUniqueId(XmlDictionaryReader reader);
}
internal class System.ServiceModel.SecurityAlgorithmDec2005Dictionary : object {
    public XmlDictionaryString Psha1KeyDerivationDec2005;
    public List`1<XmlDictionaryString> SecurityAlgorithmDictionaryStrings;
    public SecurityAlgorithmDec2005Dictionary(XmlDictionary dictionary);
    public void PopulateSecurityAlgorithmDictionaryString();
}
internal static class System.ServiceModel.SecurityAlgorithmDec2005Strings : object {
    public static string Psha1KeyDerivationDec2005;
}
internal class System.ServiceModel.SecurityAlgorithmDictionary : object {
    public XmlDictionaryString Aes128Encryption;
    public XmlDictionaryString Aes128KeyWrap;
    public XmlDictionaryString Aes192Encryption;
    public XmlDictionaryString Aes192KeyWrap;
    public XmlDictionaryString Aes256Encryption;
    public XmlDictionaryString Aes256KeyWrap;
    public XmlDictionaryString DesEncryption;
    public XmlDictionaryString DsaSha1Signature;
    public XmlDictionaryString ExclusiveC14n;
    public XmlDictionaryString ExclusiveC14nWithComments;
    public XmlDictionaryString HmacSha1Signature;
    public XmlDictionaryString HmacSha256Signature;
    public XmlDictionaryString Psha1KeyDerivation;
    public XmlDictionaryString Ripemd160Digest;
    public XmlDictionaryString RsaOaepKeyWrap;
    public XmlDictionaryString RsaSha1Signature;
    public XmlDictionaryString RsaSha256Signature;
    public XmlDictionaryString RsaV15KeyWrap;
    public XmlDictionaryString Sha1Digest;
    public XmlDictionaryString Sha256Digest;
    public XmlDictionaryString Sha512Digest;
    public XmlDictionaryString TripleDesEncryption;
    public XmlDictionaryString TripleDesKeyWrap;
    public XmlDictionaryString TlsSspiKeyWrap;
    public XmlDictionaryString WindowsSspiKeyWrap;
    public SecurityAlgorithmDictionary(ServiceModelDictionary dictionary);
}
internal static class System.ServiceModel.SecurityAlgorithmStrings : object {
    public static string Aes128Encryption;
    public static string Aes128KeyWrap;
    public static string Aes192Encryption;
    public static string Aes192KeyWrap;
    public static string Aes256Encryption;
    public static string Aes256KeyWrap;
    public static string DesEncryption;
    public static string DsaSha1Signature;
    public static string ExclusiveC14n;
    public static string ExclusiveC14nWithComments;
    public static string HmacSha1Signature;
    public static string HmacSha256Signature;
    public static string Psha1KeyDerivation;
    public static string Ripemd160Digest;
    public static string RsaOaepKeyWrap;
    public static string RsaSha1Signature;
    public static string RsaSha256Signature;
    public static string RsaV15KeyWrap;
    public static string Sha1Digest;
    public static string Sha256Digest;
    public static string Sha512Digest;
    public static string TripleDesEncryption;
    public static string TripleDesKeyWrap;
    public static string TlsSspiKeyWrap;
    public static string WindowsSspiKeyWrap;
    public static string StrTransform;
}
internal class System.ServiceModel.SecurityJan2004Dictionary : object {
    public XmlDictionaryString SecurityTokenReference;
    public XmlDictionaryString Namespace;
    public XmlDictionaryString Security;
    public XmlDictionaryString ValueType;
    public XmlDictionaryString TypeAttribute;
    public XmlDictionaryString Prefix;
    public XmlDictionaryString NonceElement;
    public XmlDictionaryString PasswordElement;
    public XmlDictionaryString PasswordTextName;
    public XmlDictionaryString UserNameElement;
    public XmlDictionaryString UserNameTokenElement;
    public XmlDictionaryString BinarySecurityToken;
    public XmlDictionaryString EncodingType;
    public XmlDictionaryString Reference;
    public XmlDictionaryString URI;
    public XmlDictionaryString KeyIdentifier;
    public XmlDictionaryString EncodingTypeValueBase64Binary;
    public XmlDictionaryString EncodingTypeValueHexBinary;
    public XmlDictionaryString EncodingTypeValueText;
    public XmlDictionaryString X509SKIValueType;
    public XmlDictionaryString KerberosTokenTypeGSS;
    public XmlDictionaryString KerberosTokenType1510;
    public XmlDictionaryString SamlAssertionIdValueType;
    public XmlDictionaryString SamlAssertion;
    public XmlDictionaryString SamlUri;
    public XmlDictionaryString RelAssertionValueType;
    public XmlDictionaryString FailedAuthenticationFaultCode;
    public XmlDictionaryString InvalidSecurityTokenFaultCode;
    public XmlDictionaryString InvalidSecurityFaultCode;
    public XmlDictionaryString KerberosHashValueType;
    public SecurityJan2004Dictionary(ServiceModelDictionary dictionary);
}
internal static class System.ServiceModel.SecurityJan2004Strings : object {
    public static string SecurityTokenReference;
    public static string Namespace;
    public static string Security;
    public static string ValueType;
    public static string TypeAttribute;
    public static string Prefix;
    public static string NonceElement;
    public static string PasswordElement;
    public static string PasswordTextName;
    public static string UserNameElement;
    public static string UserNameTokenElement;
    public static string BinarySecurityToken;
    public static string EncodingType;
    public static string Reference;
    public static string URI;
    public static string KeyIdentifier;
    public static string EncodingTypeValueBase64Binary;
    public static string EncodingTypeValueHexBinary;
    public static string EncodingTypeValueText;
    public static string X509SKIValueType;
    public static string KerberosTokenTypeGSS;
    public static string KerberosTokenType1510;
    public static string SamlAssertionIdValueType;
    public static string SamlAssertion;
    public static string SamlUri;
    public static string RelAssertionValueType;
    public static string FailedAuthenticationFaultCode;
    public static string InvalidSecurityTokenFaultCode;
    public static string InvalidSecurityFaultCode;
    public static string KerberosHashValueType;
    public static string SecurityProfileNamespace;
    public static string X509TokenProfileNamespace;
    public static string UPTokenProfileNamespace;
    public static string SamlTokenProfileNamespace;
    public static string KerberosTokenProfileNamespace;
    public static string UPTokenType;
    public static string X509TokenType;
    public static string UPTokenPasswordTextValue;
}
public enum System.ServiceModel.SecurityMode : Enum {
    public int value__;
    public static SecurityMode None;
    public static SecurityMode Transport;
    public static SecurityMode Message;
    public static SecurityMode TransportWithMessageCredential;
}
public static class System.ServiceModel.SecurityModeHelper : object {
    public static bool IsDefined(SecurityMode value);
    public static SecurityMode ToSecurityMode(UnifiedSecurityMode value);
}
internal class System.ServiceModel.SecurityXXX2005Dictionary : object {
    public XmlDictionaryString EncryptedHeader;
    public XmlDictionaryString Namespace;
    public XmlDictionaryString Prefix;
    public XmlDictionaryString SignatureConfirmation;
    public XmlDictionaryString ValueAttribute;
    public XmlDictionaryString TokenTypeAttribute;
    public XmlDictionaryString ThumbprintSha1ValueType;
    public XmlDictionaryString EncryptedKeyTokenType;
    public XmlDictionaryString EncryptedKeyHashValueType;
    public XmlDictionaryString SamlTokenType;
    public XmlDictionaryString Saml20TokenType;
    public XmlDictionaryString Saml11AssertionValueType;
    public SecurityXXX2005Dictionary(ServiceModelDictionary dictionary);
}
internal static class System.ServiceModel.SecurityXXX2005Strings : object {
    public static string EncryptedHeader;
    public static string Namespace;
    public static string Prefix;
    public static string SignatureConfirmation;
    public static string ValueAttribute;
    public static string TokenTypeAttribute;
    public static string ThumbprintSha1ValueType;
    public static string EncryptedKeyTokenType;
    public static string EncryptedKeyHashValueType;
    public static string SamlTokenType;
    public static string Saml20TokenType;
    public static string Saml11AssertionValueType;
    public static string SecurityProfileNamespace;
    public static string SamlTokenProfileNamespace;
    public static string X509TokenProfileNamespace;
}
internal static class System.ServiceModel.SerializationStrings : object {
    public static string XmlSchemaInstanceNamespace;
    public static string XmlSchemaNamespace;
    public static string Nil;
    public static string Type;
    public static string Char;
    public static string Boolean;
    public static string Byte;
    public static string UnsignedByte;
    public static string Short;
    public static string UnsignedShort;
    public static string Int;
    public static string UnsignedInt;
    public static string Long;
    public static string UnsignedLong;
    public static string Float;
    public static string Double;
    public static string Decimal;
    public static string DateTime;
    public static string String;
    public static string Base64Binary;
    public static string AnyType;
    public static string Duration;
    public static string Guid;
    public static string AnyURI;
    public static string QName;
    public static string Time;
    public static string Date;
    public static string HexBinary;
    public static string GYearMonth;
    public static string GYear;
    public static string GMonthDay;
    public static string GDay;
    public static string GMonth;
    public static string Integer;
    public static string PositiveInteger;
    public static string NegativeInteger;
    public static string NonPositiveInteger;
    public static string NonNegativeInteger;
    public static string NormalizedString;
}
public class System.ServiceModel.ServerTooBusyException : CommunicationException {
    public ServerTooBusyException(string message);
    public ServerTooBusyException(string message, Exception innerException);
    protected ServerTooBusyException(SerializationInfo info, StreamingContext context);
}
public class System.ServiceModel.ServiceActivationException : CommunicationException {
    public ServiceActivationException(string message);
    public ServiceActivationException(string message, Exception innerException);
    protected ServiceActivationException(SerializationInfo info, StreamingContext context);
}
internal class System.ServiceModel.ServiceChannelManager : LifetimeManager {
    private int _activityCount;
    private ICommunicationWaiter _activityWaiter;
    private int _activityWaiterCount;
    private InstanceContextEmptyCallback _emptyCallback;
    private IChannel _firstIncomingChannel;
    private ChannelCollection _incomingChannels;
    private ChannelCollection _outgoingChannels;
    private InstanceContext _instanceContext;
    public int ActivityCount { get; }
    public ICollection`1<IChannel> IncomingChannels { get; }
    public ICollection`1<IChannel> OutgoingChannels { get; }
    public bool IsBusy { get; }
    public ServiceChannelManager(InstanceContext instanceContext);
    public ServiceChannelManager(InstanceContext instanceContext, InstanceContextEmptyCallback emptyCallback);
    public int get_ActivityCount();
    public ICollection`1<IChannel> get_IncomingChannels();
    public ICollection`1<IChannel> get_OutgoingChannels();
    public bool get_IsBusy();
    public void AddIncomingChannel(IChannel channel);
    public IAsyncResult BeginCloseInput(TimeSpan timeout, AsyncCallback callback, object state);
    private void ChannelAdded(IChannel channel);
    private void ChannelRemoved(IChannel channel);
    public void CloseInput(TimeSpan timeout);
    public void DecrementActivityCount();
    public void EndCloseInput(IAsyncResult result);
    private void EnsureIncomingChannelCollection();
    public void IncrementActivityCount();
    protected virtual void IncrementBusyCount();
    protected virtual void OnAbort();
    protected virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    private IAsyncResult OnBeginCloseContinue(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnClose(TimeSpan timeout);
    protected virtual void OnEndClose(IAsyncResult result);
    private void OnEndCloseContinue(IAsyncResult result);
    protected virtual void OnEmpty();
    private void OnChannelClosed(object sender, EventArgs args);
    public bool RemoveChannel(IChannel channel);
    public IChannel[] SnapshotChannels();
}
[AttributeUsageAttribute("1028")]
public class System.ServiceModel.ServiceContractAttribute : Attribute {
    private Type _callbackContract;
    private string _configurationName;
    private string _name;
    private string _ns;
    private SessionMode _sessionMode;
    private ProtectionLevel _protectionLevel;
    private bool _hasProtectionLevel;
    public string ConfigurationName { get; public set; }
    public string Name { get; public set; }
    public string Namespace { get; public set; }
    public ProtectionLevel ProtectionLevel { get; public set; }
    public bool HasProtectionLevel { get; }
    public SessionMode SessionMode { get; public set; }
    public Type CallbackContract { get; public set; }
    public string get_ConfigurationName();
    public void set_ConfigurationName(string value);
    public string get_Name();
    public void set_Name(string value);
    public string get_Namespace();
    public void set_Namespace(string value);
    public ProtectionLevel get_ProtectionLevel();
    public void set_ProtectionLevel(ProtectionLevel value);
    public bool get_HasProtectionLevel();
    public SessionMode get_SessionMode();
    public void set_SessionMode(SessionMode value);
    public Type get_CallbackContract();
    public void set_CallbackContract(Type value);
}
public static class System.ServiceModel.ServiceDefaults : object {
    public static TimeSpan CloseTimeout { get; }
    public static TimeSpan OpenTimeout { get; }
    public static TimeSpan ReceiveTimeout { get; }
    public static TimeSpan SendTimeout { get; }
    public static TimeSpan get_CloseTimeout();
    public static TimeSpan get_OpenTimeout();
    public static TimeSpan get_ReceiveTimeout();
    public static TimeSpan get_SendTimeout();
}
[AttributeUsageAttribute("1092")]
public class System.ServiceModel.ServiceKnownTypeAttribute : Attribute {
    private Type _declaringType;
    private string _methodName;
    private Type _type;
    public Type DeclaringType { get; }
    public string MethodName { get; }
    public Type Type { get; }
    public ServiceKnownTypeAttribute(Type type);
    public ServiceKnownTypeAttribute(string methodName);
    public ServiceKnownTypeAttribute(string methodName, Type declaringType);
    public Type get_DeclaringType();
    public string get_MethodName();
    public Type get_Type();
}
internal static class System.ServiceModel.ServiceModelAttributeTargets : object {
    public static AttributeTargets ServiceContract;
    public static AttributeTargets OperationContract;
    public static AttributeTargets MessageContract;
    public static AttributeTargets MessageMember;
    public static AttributeTargets Parameter;
    public static AttributeTargets ServiceBehavior;
    public static AttributeTargets CallbackBehavior;
    public static AttributeTargets ClientBehavior;
    public static AttributeTargets ContractBehavior;
    public static AttributeTargets OperationBehavior;
}
internal class System.ServiceModel.ServiceModelDictionary : object {
    public static ServiceModelDictionary Version1;
    private ServiceModelStrings _strings;
    private int _count;
    private XmlDictionaryString[] _dictionaryStrings1;
    private XmlDictionaryString[] _dictionaryStrings2;
    private Dictionary`2<string, int> _dictionary;
    private XmlDictionaryString[] _versionedDictionaryStrings;
    public static ServiceModelDictionary CurrentVersion { get; }
    public ServiceModelDictionary(ServiceModelStrings strings);
    private static ServiceModelDictionary();
    public static ServiceModelDictionary get_CurrentVersion();
    public XmlDictionaryString CreateString(string value, int key);
    public sealed virtual bool TryLookup(string key, XmlDictionaryString& value);
    public sealed virtual bool TryLookup(int key, XmlDictionaryString& value);
    public sealed virtual bool TryLookup(XmlDictionaryString key, XmlDictionaryString& value);
}
[DefaultMemberAttribute("Item")]
internal abstract class System.ServiceModel.ServiceModelStrings : object {
    public int Count { get; }
    public string Item { get; }
    public abstract virtual int get_Count();
    public abstract virtual string get_Item(int index);
}
[DefaultMemberAttribute("Item")]
internal class System.ServiceModel.ServiceModelStringsVersion1 : ServiceModelStrings {
    public static string String0;
    public static string String1;
    public static string String2;
    public static string String3;
    public static string String4;
    public static string String5;
    public static string String6;
    public static string String7;
    public static string String8;
    public static string String9;
    public static string String10;
    public static string String11;
    public static string String12;
    public static string String13;
    public static string String14;
    public static string String15;
    public static string String16;
    public static string String17;
    public static string String18;
    public static string String19;
    public static string String20;
    public static string String21;
    public static string String22;
    public static string String23;
    public static string String24;
    public static string String25;
    public static string String26;
    public static string String27;
    public static string String28;
    public static string String29;
    public static string String30;
    public static string String31;
    public static string String32;
    public static string String33;
    public static string String34;
    public static string String35;
    public static string String36;
    public static string String37;
    public static string String38;
    public static string String39;
    public static string String40;
    public static string String41;
    public static string String42;
    public static string String43;
    public static string String44;
    public static string String45;
    public static string String46;
    public static string String47;
    public static string String48;
    public static string String49;
    public static string String50;
    public static string String51;
    public static string String52;
    public static string String53;
    public static string String54;
    public static string String55;
    public static string String56;
    public static string String57;
    public static string String58;
    public static string String59;
    public static string String60;
    public static string String61;
    public static string String62;
    public static string String63;
    public static string String64;
    public static string String65;
    public static string String66;
    public static string String67;
    public static string String68;
    public static string String69;
    public static string String70;
    public static string String71;
    public static string String72;
    public static string String73;
    public static string String74;
    public static string String75;
    public static string String76;
    public static string String77;
    public static string String78;
    public static string String79;
    public static string String80;
    public static string String81;
    public static string String82;
    public static string String83;
    public static string String84;
    public static string String85;
    public static string String86;
    public static string String87;
    public static string String88;
    public static string String89;
    public static string String90;
    public static string String91;
    public static string String92;
    public static string String93;
    public static string String94;
    public static string String95;
    public static string String96;
    public static string String97;
    public static string String98;
    public static string String99;
    public static string String100;
    public static string String101;
    public static string String102;
    public static string String103;
    public static string String104;
    public static string String105;
    public static string String106;
    public static string String107;
    public static string String108;
    public static string String109;
    public static string String110;
    public static string String111;
    public static string String112;
    public static string String113;
    public static string String114;
    public static string String115;
    public static string String116;
    public static string String117;
    public static string String118;
    public static string String119;
    public static string String120;
    public static string String121;
    public static string String122;
    public static string String123;
    public static string String124;
    public static string String125;
    public static string String126;
    public static string String127;
    public static string String128;
    public static string String129;
    public static string String130;
    public static string String131;
    public static string String132;
    public static string String133;
    public static string String134;
    public static string String135;
    public static string String136;
    public static string String137;
    public static string String138;
    public static string String139;
    public static string String140;
    public static string String141;
    public static string String142;
    public static string String143;
    public static string String144;
    public static string String145;
    public static string String146;
    public static string String147;
    public static string String148;
    public static string String149;
    public static string String150;
    public static string String151;
    public static string String152;
    public static string String153;
    public static string String154;
    public static string String155;
    public static string String156;
    public static string String157;
    public static string String158;
    public static string String159;
    public static string String160;
    public static string String161;
    public static string String162;
    public static string String163;
    public static string String164;
    public static string String165;
    public static string String166;
    public static string String167;
    public static string String168;
    public static string String169;
    public static string String170;
    public static string String171;
    public static string String172;
    public static string String173;
    public static string String174;
    public static string String175;
    public static string String176;
    public static string String177;
    public static string String178;
    public static string String179;
    public static string String180;
    public static string String181;
    public static string String182;
    public static string String183;
    public static string String184;
    public static string String185;
    public static string String186;
    public static string String187;
    public static string String188;
    public static string String189;
    public static string String190;
    public static string String191;
    public static string String192;
    public static string String193;
    public static string String194;
    public static string String195;
    public static string String196;
    public static string String197;
    public static string String198;
    public static string String199;
    public static string String200;
    public static string String201;
    public static string String202;
    public static string String203;
    public static string String204;
    public static string String205;
    public static string String206;
    public static string String207;
    public static string String208;
    public static string String209;
    public static string String210;
    public static string String211;
    public static string String212;
    public static string String213;
    public static string String214;
    public static string String215;
    public static string String216;
    public static string String217;
    public static string String218;
    public static string String219;
    public static string String220;
    public static string String221;
    public static string String222;
    public static string String223;
    public static string String224;
    public static string String225;
    public static string String226;
    public static string String227;
    public static string String228;
    public static string String229;
    public static string String230;
    public static string String231;
    public static string String232;
    public static string String233;
    public static string String234;
    public static string String235;
    public static string String236;
    public static string String237;
    public static string String238;
    public static string String239;
    public static string String240;
    public static string String241;
    public static string String242;
    public static string String243;
    public static string String244;
    public static string String245;
    public static string String246;
    public static string String247;
    public static string String248;
    public static string String249;
    public static string String250;
    public static string String251;
    public static string String252;
    public static string String253;
    public static string String254;
    public static string String255;
    public static string String256;
    public static string String257;
    public static string String258;
    public static string String259;
    public static string String260;
    public static string String261;
    public static string String262;
    public static string String263;
    public static string String264;
    public static string String265;
    public static string String266;
    public static string String267;
    public static string String268;
    public static string String269;
    public static string String270;
    public static string String271;
    public static string String272;
    public static string String273;
    public static string String274;
    public static string String275;
    public static string String276;
    public static string String277;
    public static string String278;
    public static string String279;
    public static string String280;
    public static string String281;
    public static string String282;
    public static string String283;
    public static string String284;
    public static string String285;
    public static string String286;
    public static string String287;
    public static string String288;
    public static string String289;
    public static string String290;
    public static string String291;
    public static string String292;
    public static string String293;
    public static string String294;
    public static string String295;
    public static string String296;
    public static string String297;
    public static string String298;
    public static string String299;
    public static string String300;
    public static string String301;
    public static string String302;
    public static string String303;
    public static string String304;
    public static string String305;
    public static string String306;
    public static string String307;
    public static string String308;
    public static string String309;
    public static string String310;
    public static string String311;
    public static string String312;
    public static string String313;
    public static string String314;
    public static string String315;
    public static string String316;
    public static string String317;
    public static string String318;
    public static string String319;
    public static string String320;
    public static string String321;
    public static string String322;
    public static string String323;
    public static string String324;
    public static string String325;
    public static string String326;
    public static string String327;
    public static string String328;
    public static string String329;
    public static string String330;
    public static string String331;
    public static string String332;
    public static string String333;
    public static string String334;
    public static string String335;
    public static string String336;
    public static string String337;
    public static string String338;
    public static string String339;
    public static string String340;
    public static string String341;
    public static string String342;
    public static string String343;
    public static string String344;
    public static string String345;
    public static string String346;
    public static string String347;
    public static string String348;
    public static string String349;
    public static string String350;
    public static string String351;
    public static string String352;
    public static string String353;
    public static string String354;
    public static string String355;
    public static string String356;
    public static string String357;
    public static string String358;
    public static string String359;
    public static string String360;
    public static string String361;
    public static string String362;
    public static string String363;
    public static string String364;
    public static string String365;
    public static string String366;
    public static string String367;
    public static string String368;
    public static string String369;
    public static string String370;
    public static string String371;
    public static string String372;
    public static string String373;
    public static string String374;
    public static string String375;
    public static string String376;
    public static string String377;
    public static string String378;
    public static string String379;
    public static string String380;
    public static string String381;
    public static string String382;
    public static string String383;
    public static string String384;
    public static string String385;
    public static string String386;
    public static string String387;
    public static string String388;
    public static string String389;
    public static string String390;
    public static string String391;
    public static string String392;
    public static string String393;
    public static string String394;
    public static string String395;
    public static string String396;
    public static string String397;
    public static string String398;
    public static string String399;
    public static string String400;
    public static string String401;
    public static string String402;
    public static string String403;
    public static string String404;
    public static string String405;
    public static string String406;
    public static string String407;
    public static string String408;
    public static string String409;
    public static string String410;
    public static string String411;
    public static string String412;
    public static string String413;
    public static string String414;
    public static string String415;
    public static string String416;
    public static string String417;
    public static string String418;
    public static string String419;
    public static string String420;
    public static string String421;
    public static string String422;
    public static string String423;
    public static string String424;
    public static string String425;
    public static string String426;
    public static string String427;
    public static string String428;
    public static string String429;
    public static string String430;
    public static string String431;
    public static string String432;
    public static string String433;
    public static string String434;
    public static string String435;
    public static string String436;
    public static string String437;
    public static string String438;
    public static string String439;
    public static string String440;
    public static string String441;
    public static string String442;
    public static string String443;
    public static string String444;
    public static string String445;
    public static string String446;
    public static string String447;
    public static string String448;
    public static string String449;
    public static string String450;
    public static string String451;
    public static string String452;
    public static string String453;
    public static string String454;
    public static string String455;
    public static string String456;
    public static string String457;
    public static string String458;
    public static string String459;
    public static string String460;
    public static string String461;
    public static string String462;
    public static string String463;
    public static string String464;
    public static string String465;
    public static string String466;
    public static string String467;
    public static string String468;
    public static string String469;
    public static string String470;
    public static string String471;
    public static string String472;
    public static string String473;
    public static string String474;
    public static string String475;
    public static string String476;
    public static string String477;
    public static string String478;
    public static string String479;
    public static string String480;
    public static string String481;
    public static string String482;
    public static string String483;
    public static string String484;
    public static string String485;
    public static string String486;
    public int Count { get; }
    public string Item { get; }
    public virtual int get_Count();
    public virtual string get_Item(int index);
}
public class System.ServiceModel.ServiceSecurityContext : object {
    private static ServiceSecurityContext s_anonymous;
    private ReadOnlyCollection`1<IAuthorizationPolicy> _authorizationPolicies;
    private AuthorizationContext _authorizationContext;
    private IIdentity _primaryIdentity;
    private Claim _identityClaim;
    public static ServiceSecurityContext Anonymous { get; }
    public bool IsAnonymous { get; }
    internal Claim IdentityClaim { get; }
    public IIdentity PrimaryIdentity { get; }
    public ReadOnlyCollection`1<IAuthorizationPolicy> AuthorizationPolicies { get; public set; }
    public AuthorizationContext AuthorizationContext { get; }
    public ServiceSecurityContext(ReadOnlyCollection`1<IAuthorizationPolicy> authorizationPolicies);
    public ServiceSecurityContext(AuthorizationContext authorizationContext);
    public ServiceSecurityContext(AuthorizationContext authorizationContext, ReadOnlyCollection`1<IAuthorizationPolicy> authorizationPolicies);
    public static ServiceSecurityContext get_Anonymous();
    public bool get_IsAnonymous();
    internal Claim get_IdentityClaim();
    public IIdentity get_PrimaryIdentity();
    public ReadOnlyCollection`1<IAuthorizationPolicy> get_AuthorizationPolicies();
    public void set_AuthorizationPolicies(ReadOnlyCollection`1<IAuthorizationPolicy> value);
    public AuthorizationContext get_AuthorizationContext();
    private IList`1<IIdentity> GetIdentities();
}
public enum System.ServiceModel.SessionMode : Enum {
    public int value__;
    public static SessionMode Allowed;
    public static SessionMode Required;
    public static SessionMode NotAllowed;
}
internal static class System.ServiceModel.SessionModeHelper : object {
    public static bool IsDefined(SessionMode sessionMode);
}
public class System.ServiceModel.SpnEndpointIdentity : EndpointIdentity {
    private static TimeSpan s_spnLookupTime;
    public static TimeSpan SpnLookupTime { get; public set; }
    public SpnEndpointIdentity(string spnName);
    public SpnEndpointIdentity(Claim identity);
    private static SpnEndpointIdentity();
    public static TimeSpan get_SpnLookupTime();
    public static void set_SpnLookupTime(TimeSpan value);
}
public enum System.ServiceModel.TcpClientCredentialType : Enum {
    public int value__;
    public static TcpClientCredentialType None;
    public static TcpClientCredentialType Windows;
    public static TcpClientCredentialType Certificate;
}
internal static class System.ServiceModel.TcpClientCredentialTypeHelper : object {
    internal static bool IsDefined(TcpClientCredentialType value);
}
public class System.ServiceModel.TcpTransportSecurity : object {
    internal static TcpClientCredentialType DefaultClientCredentialType;
    internal static ProtectionLevel DefaultProtectionLevel;
    private TcpClientCredentialType _clientCredentialType;
    private ProtectionLevel _protectionLevel;
    private SslProtocols _sslProtocols;
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public TcpClientCredentialType ClientCredentialType { get; public set; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public SslProtocols SslProtocols { get; public set; }
    public TcpClientCredentialType get_ClientCredentialType();
    public void set_ClientCredentialType(TcpClientCredentialType value);
    public SslProtocols get_SslProtocols();
    public void set_SslProtocols(SslProtocols value);
    private SslStreamSecurityBindingElement CreateSslBindingElement(bool requireClientCertificate);
    private static bool IsSslBindingElement(BindingElement element, TcpTransportSecurity transportSecurity, Boolean& requireClientCertificate);
    internal BindingElement CreateTransportProtectionOnly();
    internal static bool SetTransportProtectionOnly(BindingElement transport, TcpTransportSecurity transportSecurity);
    internal BindingElement CreateTransportProtectionAndAuthentication();
    internal static bool SetTransportProtectionAndAuthentication(BindingElement transport, TcpTransportSecurity transportSecurity);
    internal bool InternalShouldSerialize();
}
public static class System.ServiceModel.TimeSpanHelper : object {
    public static TimeSpan FromMinutes(int minutes, string text);
    public static TimeSpan FromSeconds(int seconds, string text);
    public static TimeSpan FromMilliseconds(int ms, string text);
}
public enum System.ServiceModel.TransferMode : Enum {
    public int value__;
    public static TransferMode Buffered;
    public static TransferMode Streamed;
    public static TransferMode StreamedRequest;
    public static TransferMode StreamedResponse;
}
public static class System.ServiceModel.TransferModeHelper : object {
    public static bool IsDefined(TransferMode v);
    public static bool IsRequestStreamed(TransferMode v);
    public static bool IsResponseStreamed(TransferMode v);
    public static void Validate(TransferMode value);
}
internal static class System.ServiceModel.TrustApr2004Strings : object {
    public static string CombinedHashLabel;
    public static string RequestSecurityTokenResponse;
    public static string TokenType;
    public static string KeySize;
    public static string RequestedTokenReference;
    public static string AppliesTo;
    public static string Authenticator;
    public static string CombinedHash;
    public static string BinaryExchange;
    public static string Lifetime;
    public static string RequestedSecurityToken;
    public static string Entropy;
    public static string RequestedProofToken;
    public static string ComputedKey;
    public static string RequestSecurityToken;
    public static string RequestType;
    public static string RequestSecurityTokenResponseCollection;
    public static string Context;
    public static string BinarySecret;
    public static string Type;
    public static string SpnegoValueTypeUri;
    public static string TlsnegoValueTypeUri;
    public static string Prefix;
    public static string Namespace;
    public static string RequestSecurityTokenIssuance;
    public static string RequestSecurityTokenIssuanceResponse;
    public static string RequestTypeIssue;
    public static string Psha1ComputedKeyUri;
    public static string SymmetricKeyBinarySecret;
    public static string NonceBinarySecret;
    public static string KeyType;
    public static string SymmetricKeyType;
    public static string PublicKeyType;
    public static string Claims;
    public static string InvalidRequestFaultCode;
    public static string FailedAuthenticationFaultCode;
    public static string RequestFailedFaultCode;
    public static string SignWith;
    public static string EncryptWith;
    public static string EncryptionAlgorithm;
    public static string CanonicalizationAlgorithm;
    public static string ComputedKeyAlgorithm;
    public static string UseKey;
}
internal class System.ServiceModel.TrustDec2005Dictionary : TrustDictionary {
    public XmlDictionaryString AsymmetricKeyBinarySecret;
    public XmlDictionaryString RequestSecurityTokenCollectionIssuanceFinalResponse;
    public XmlDictionaryString RequestSecurityTokenRenewal;
    public XmlDictionaryString RequestSecurityTokenRenewalResponse;
    public XmlDictionaryString RequestSecurityTokenCollectionRenewalFinalResponse;
    public XmlDictionaryString RequestSecurityTokenCancellation;
    public XmlDictionaryString RequestSecurityTokenCancellationResponse;
    public XmlDictionaryString RequestSecurityTokenCollectionCancellationFinalResponse;
    public XmlDictionaryString KeyWrapAlgorithm;
    public XmlDictionaryString BearerKeyType;
    public XmlDictionaryString SecondaryParameters;
    public XmlDictionaryString Dialect;
    public XmlDictionaryString DialectType;
    public List`1<XmlDictionaryString> Feb2005DictionaryStrings;
    public List`1<XmlDictionaryString> Dec2005DictionaryString;
    public TrustDec2005Dictionary(XmlDictionary dictionary);
    public void PopulateFeb2005DictionaryString();
    public void PopulateDec2005DictionaryStrings();
}
internal static class System.ServiceModel.TrustDec2005Strings : object {
    public static string CombinedHashLabel;
    public static string RequestSecurityTokenResponse;
    public static string TokenType;
    public static string KeySize;
    public static string RequestedTokenReference;
    public static string AppliesTo;
    public static string Authenticator;
    public static string CombinedHash;
    public static string BinaryExchange;
    public static string Lifetime;
    public static string RequestedSecurityToken;
    public static string Entropy;
    public static string RequestedProofToken;
    public static string ComputedKey;
    public static string RequestSecurityToken;
    public static string RequestType;
    public static string Context;
    public static string BinarySecret;
    public static string Type;
    public static string SpnegoValueTypeUri;
    public static string TlsnegoValueTypeUri;
    public static string Prefix;
    public static string RequestSecurityTokenIssuance;
    public static string RequestSecurityTokenIssuanceResponse;
    public static string RequestTypeIssue;
    public static string AsymmetricKeyBinarySecret;
    public static string SymmetricKeyBinarySecret;
    public static string NonceBinarySecret;
    public static string Psha1ComputedKeyUri;
    public static string KeyType;
    public static string SymmetricKeyType;
    public static string PublicKeyType;
    public static string Claims;
    public static string InvalidRequestFaultCode;
    public static string FailedAuthenticationFaultCode;
    public static string UseKey;
    public static string SignWith;
    public static string EncryptWith;
    public static string EncryptionAlgorithm;
    public static string CanonicalizationAlgorithm;
    public static string ComputedKeyAlgorithm;
    public static string RequestSecurityTokenResponseCollection;
    public static string Namespace;
    public static string BinarySecretClauseType;
    public static string RequestSecurityTokenCollectionIssuanceFinalResponse;
    public static string RequestSecurityTokenRenewal;
    public static string RequestSecurityTokenRenewalResponse;
    public static string RequestSecurityTokenCollectionRenewalFinalResponse;
    public static string RequestSecurityTokenCancellation;
    public static string RequestSecurityTokenCancellationResponse;
    public static string RequestSecurityTokenCollectionCancellationFinalResponse;
    public static string RequestTypeRenew;
    public static string RequestTypeClose;
    public static string RenewTarget;
    public static string CloseTarget;
    public static string RequestedTokenClosed;
    public static string RequestedAttachedReference;
    public static string RequestedUnattachedReference;
    public static string IssuedTokensHeader;
    public static string KeyWrapAlgorithm;
    public static string BearerKeyType;
    public static string SecondaryParameters;
    public static string Dialect;
    public static string DialectType;
}
internal class System.ServiceModel.TrustDictionary : object {
    public XmlDictionaryString RequestSecurityTokenResponseCollection;
    public XmlDictionaryString Namespace;
    public XmlDictionaryString BinarySecretClauseType;
    public XmlDictionaryString CombinedHashLabel;
    public XmlDictionaryString RequestSecurityTokenResponse;
    public XmlDictionaryString TokenType;
    public XmlDictionaryString KeySize;
    public XmlDictionaryString RequestedTokenReference;
    public XmlDictionaryString AppliesTo;
    public XmlDictionaryString Authenticator;
    public XmlDictionaryString CombinedHash;
    public XmlDictionaryString BinaryExchange;
    public XmlDictionaryString Lifetime;
    public XmlDictionaryString RequestedSecurityToken;
    public XmlDictionaryString Entropy;
    public XmlDictionaryString RequestedProofToken;
    public XmlDictionaryString ComputedKey;
    public XmlDictionaryString RequestSecurityToken;
    public XmlDictionaryString RequestType;
    public XmlDictionaryString Context;
    public XmlDictionaryString BinarySecret;
    public XmlDictionaryString Type;
    public XmlDictionaryString SpnegoValueTypeUri;
    public XmlDictionaryString TlsnegoValueTypeUri;
    public XmlDictionaryString Prefix;
    public XmlDictionaryString RequestSecurityTokenIssuance;
    public XmlDictionaryString RequestSecurityTokenIssuanceResponse;
    public XmlDictionaryString RequestTypeIssue;
    public XmlDictionaryString Psha1ComputedKeyUri;
    public XmlDictionaryString SymmetricKeyBinarySecret;
    public XmlDictionaryString NonceBinarySecret;
    public XmlDictionaryString KeyType;
    public XmlDictionaryString SymmetricKeyType;
    public XmlDictionaryString PublicKeyType;
    public XmlDictionaryString Claims;
    public XmlDictionaryString InvalidRequestFaultCode;
    public XmlDictionaryString FailedAuthenticationFaultCode;
    public XmlDictionaryString RequestFailedFaultCode;
    public XmlDictionaryString SignWith;
    public XmlDictionaryString EncryptWith;
    public XmlDictionaryString EncryptionAlgorithm;
    public XmlDictionaryString CanonicalizationAlgorithm;
    public XmlDictionaryString ComputedKeyAlgorithm;
    public XmlDictionaryString UseKey;
    public XmlDictionaryString RenewTarget;
    public XmlDictionaryString CloseTarget;
    public XmlDictionaryString RequestedTokenClosed;
    public XmlDictionaryString RequestedAttachedReference;
    public XmlDictionaryString RequestedUnattachedReference;
    public XmlDictionaryString IssuedTokensHeader;
    public XmlDictionaryString RequestTypeRenew;
    public XmlDictionaryString RequestTypeClose;
    public TrustDictionary(ServiceModelDictionary dictionary);
}
internal class System.ServiceModel.TrustFeb2005Dictionary : TrustDictionary {
    public TrustFeb2005Dictionary(ServiceModelDictionary dictionary);
}
internal static class System.ServiceModel.TrustFeb2005Strings : object {
    public static string RequestSecurityTokenResponseCollection;
    public static string Namespace;
    public static string BinarySecretClauseType;
    public static string CombinedHashLabel;
    public static string RequestSecurityTokenResponse;
    public static string TokenType;
    public static string KeySize;
    public static string RequestedTokenReference;
    public static string AppliesTo;
    public static string Authenticator;
    public static string CombinedHash;
    public static string BinaryExchange;
    public static string Lifetime;
    public static string RequestedSecurityToken;
    public static string Entropy;
    public static string RequestedProofToken;
    public static string ComputedKey;
    public static string RequestSecurityToken;
    public static string RequestType;
    public static string Context;
    public static string BinarySecret;
    public static string Type;
    public static string SpnegoValueTypeUri;
    public static string TlsnegoValueTypeUri;
    public static string Prefix;
    public static string RequestSecurityTokenIssuance;
    public static string RequestSecurityTokenIssuanceResponse;
    public static string RequestTypeIssue;
    public static string SymmetricKeyBinarySecret;
    public static string Psha1ComputedKeyUri;
    public static string NonceBinarySecret;
    public static string RenewTarget;
    public static string CloseTarget;
    public static string RequestedTokenClosed;
    public static string RequestedAttachedReference;
    public static string RequestedUnattachedReference;
    public static string IssuedTokensHeader;
    public static string RequestTypeRenew;
    public static string RequestTypeClose;
    public static string KeyType;
    public static string SymmetricKeyType;
    public static string PublicKeyType;
    public static string Claims;
    public static string InvalidRequestFaultCode;
    public static string FailedAuthenticationFaultCode;
    public static string UseKey;
    public static string SignWith;
    public static string EncryptWith;
    public static string EncryptionAlgorithm;
    public static string CanonicalizationAlgorithm;
    public static string ComputedKeyAlgorithm;
}
internal static class System.ServiceModel.TrustStrings : object {
}
internal abstract class System.ServiceModel.TypedHeaderManager : object {
    private static Dictionary`2<Type, TypedHeaderManager> s_cache;
    private static ReaderWriterLockSlim s_cacheLock;
    private static Type s_GenericAdapterType;
    private static TypedHeaderManager();
    internal static object Create(Type t, object content, bool mustUnderstand, bool relay, string actor);
    internal static object GetContent(Type t, object typedHeaderInstance, Boolean& mustUnderstand, Boolean& relay, String& actor);
    internal static Type GetMessageHeaderType(Type contentType);
    internal static Type GetHeaderType(Type headerParameterType);
    private static TypedHeaderManager GetTypedHeaderManager(Type t);
    protected abstract virtual object Create(object content, bool mustUnderstand, bool relay, string actor);
    protected abstract virtual object GetContent(object typedHeaderInstance, Boolean& mustUnderstand, Boolean& relay, String& actor);
    protected abstract virtual Type GetMessageHeaderType();
}
[FlagsAttribute]
public enum System.ServiceModel.UnifiedSecurityMode : Enum {
    public int value__;
    public static UnifiedSecurityMode None;
    public static UnifiedSecurityMode Transport;
    public static UnifiedSecurityMode Message;
    public static UnifiedSecurityMode Both;
    public static UnifiedSecurityMode TransportWithMessageCredential;
    public static UnifiedSecurityMode TransportCredentialOnly;
}
public class System.ServiceModel.UnknownMessageReceivedEventArgs : EventArgs {
    private Message _message;
    public Message Message { get; }
    internal UnknownMessageReceivedEventArgs(Message message);
    public Message get_Message();
}
public class System.ServiceModel.UpnEndpointIdentity : EndpointIdentity {
    private SecurityIdentifier _upnSid;
    private bool _hasUpnSidBeenComputed;
    private WindowsIdentity _windowsIdentity;
    private object _thisLock;
    public UpnEndpointIdentity(string upnName);
    public UpnEndpointIdentity(Claim identity);
    internal UpnEndpointIdentity(WindowsIdentity windowsIdentity);
    internal virtual void EnsureIdentityClaim();
    private string GetUpnFromWindowsIdentity(WindowsIdentity windowsIdentity);
    private bool IsMachineJoinedToDomain();
    private string GetUpnFromDownlevelName(string downlevelName);
    internal virtual void WriteContentsTo(XmlDictionaryWriter writer);
    internal SecurityIdentifier GetUpnSid();
}
public class System.ServiceModel.UriSchemeKeyedCollection : SynchronizedKeyedCollection`2<string, Uri> {
    internal UriSchemeKeyedCollection(object syncRoot);
    public UriSchemeKeyedCollection(Uri[] addresses);
    protected virtual string GetKeyForItem(Uri item);
    protected virtual void InsertItem(int index, Uri item);
    protected virtual void SetItem(int index, Uri item);
    internal static void ValidateBaseAddress(Uri uri, string argumentName);
}
internal class System.ServiceModel.UtilityDictionary : object {
    public XmlDictionaryString IdAttribute;
    public XmlDictionaryString Namespace;
    public XmlDictionaryString Timestamp;
    public XmlDictionaryString CreatedElement;
    public XmlDictionaryString ExpiresElement;
    public XmlDictionaryString Prefix;
    public XmlDictionaryString UniqueEndpointHeaderName;
    public XmlDictionaryString UniqueEndpointHeaderNamespace;
    public UtilityDictionary(ServiceModelDictionary dictionary);
}
internal static class System.ServiceModel.UtilityStrings : object {
    public static string IdAttribute;
    public static string Namespace;
    public static string Timestamp;
    public static string CreatedElement;
    public static string ExpiresElement;
    public static string Prefix;
    public static string UniqueEndpointHeaderName;
    public static string UniqueEndpointHeaderNamespace;
}
internal class System.ServiceModel.WSAddressing10ProblemHeaderQNameFault : MessageFault {
    private FaultCode _code;
    private FaultReason _reason;
    private string _actor;
    private string _node;
    private string _invalidHeaderName;
    public string Actor { get; }
    public FaultCode Code { get; }
    public bool HasDetail { get; }
    public string Node { get; }
    public FaultReason Reason { get; }
    public WSAddressing10ProblemHeaderQNameFault(MessageHeaderException e);
    public WSAddressing10ProblemHeaderQNameFault(ActionMismatchAddressingException e);
    public virtual string get_Actor();
    public virtual FaultCode get_Code();
    public virtual bool get_HasDetail();
    public virtual string get_Node();
    public virtual FaultReason get_Reason();
    protected virtual void OnWriteDetail(XmlDictionaryWriter writer, EnvelopeVersion version);
    protected virtual void OnWriteDetailContents(XmlDictionaryWriter writer);
    public void AddHeaders(MessageHeaders headers);
}
public enum System.ServiceModel.WSMessageEncoding : Enum {
    public int value__;
    public static WSMessageEncoding Text;
}
internal static class System.ServiceModel.WSMessageEncodingHelper : object {
    internal static bool IsDefined(WSMessageEncoding value);
}
internal class System.ServiceModel.Wsrm11Dictionary : object {
    public XmlDictionaryString AckRequestedAction;
    public XmlDictionaryString CloseSequence;
    public XmlDictionaryString CloseSequenceAction;
    public XmlDictionaryString CloseSequenceResponse;
    public XmlDictionaryString CloseSequenceResponseAction;
    public XmlDictionaryString CreateSequenceAction;
    public XmlDictionaryString CreateSequenceResponseAction;
    public XmlDictionaryString DiscardFollowingFirstGap;
    public XmlDictionaryString Endpoint;
    public XmlDictionaryString FaultAction;
    public XmlDictionaryString Final;
    public XmlDictionaryString IncompleteSequenceBehavior;
    public XmlDictionaryString LastMsgNumber;
    public XmlDictionaryString MaxMessageNumber;
    public XmlDictionaryString Namespace;
    public XmlDictionaryString NoDiscard;
    public XmlDictionaryString None;
    public XmlDictionaryString SequenceAcknowledgementAction;
    public XmlDictionaryString SequenceClosed;
    public XmlDictionaryString TerminateSequenceAction;
    public XmlDictionaryString TerminateSequenceResponse;
    public XmlDictionaryString TerminateSequenceResponseAction;
    public XmlDictionaryString UsesSequenceSSL;
    public XmlDictionaryString UsesSequenceSTR;
    public XmlDictionaryString WsrmRequired;
    public Wsrm11Dictionary(XmlDictionary dictionary);
}
internal static class System.ServiceModel.Wsrm11Strings : object {
    public static string AckRequestedAction;
    public static string CloseSequence;
    public static string CloseSequenceAction;
    public static string CloseSequenceResponse;
    public static string CloseSequenceResponseAction;
    public static string CreateSequenceAction;
    public static string CreateSequenceResponseAction;
    public static string DiscardFollowingFirstGap;
    public static string Endpoint;
    public static string FaultAction;
    public static string Final;
    public static string IncompleteSequenceBehavior;
    public static string LastMsgNumber;
    public static string MaxMessageNumber;
    public static string Namespace;
    public static string NoDiscard;
    public static string None;
    public static string SequenceAcknowledgementAction;
    public static string SequenceClosed;
    public static string TerminateSequenceAction;
    public static string TerminateSequenceResponse;
    public static string TerminateSequenceResponseAction;
    public static string UsesSequenceSSL;
    public static string UsesSequenceSTR;
    public static string WsrmRequired;
    public static string DiscardEntireSequence;
}
internal static class System.ServiceModel.WsrmFeb2005Strings : object {
    public static string Identifier;
    public static string Namespace;
    public static string SequenceAcknowledgement;
    public static string AcknowledgementRange;
    public static string Upper;
    public static string Lower;
    public static string BufferRemaining;
    public static string NETNamespace;
    public static string SequenceAcknowledgementAction;
    public static string Sequence;
    public static string MessageNumber;
    public static string AckRequested;
    public static string AckRequestedAction;
    public static string AcksTo;
    public static string Accept;
    public static string CreateSequence;
    public static string CreateSequenceAction;
    public static string CreateSequenceRefused;
    public static string CreateSequenceResponse;
    public static string CreateSequenceResponseAction;
    public static string Expires;
    public static string FaultCode;
    public static string InvalidAcknowledgement;
    public static string LastMessage;
    public static string LastMessageAction;
    public static string LastMessageNumberExceeded;
    public static string MessageNumberRollover;
    public static string Nack;
    public static string NETPrefix;
    public static string Offer;
    public static string Prefix;
    public static string SequenceFault;
    public static string SequenceTerminated;
    public static string TerminateSequence;
    public static string TerminateSequenceAction;
    public static string UnknownSequence;
    public static string ConnectionLimitReached;
}
public class System.ServiceModel.X509CertificateEndpointIdentity : EndpointIdentity {
    private X509Certificate2Collection _certificateCollection;
    public X509Certificate2Collection Certificates { get; }
    public X509CertificateEndpointIdentity(X509Certificate2 certificate);
    public X509CertificateEndpointIdentity(X509Certificate2 primaryCertificate, X509Certificate2Collection supportingCertificates);
    internal X509CertificateEndpointIdentity(XmlDictionaryReader reader);
    public X509Certificate2Collection get_Certificates();
    internal virtual void WriteContentsTo(XmlDictionaryWriter writer);
}
internal static class System.ServiceModel.XD : object {
    private static ActivityIdFlowDictionary s_activityIdFlowDictionary;
    private static AddressingDictionary s_addressingDictionary;
    private static Addressing10Dictionary s_addressing10Dictionary;
    private static AddressingNoneDictionary s_addressingNoneDictionary;
    private static MessageDictionary s_messageDictionary;
    private static Message11Dictionary s_message11Dictionary;
    private static Message12Dictionary s_message12Dictionary;
    private static SecureConversationFeb2005Dictionary s_secureConversationFeb2005Dictionary;
    private static SecurityAlgorithmDictionary s_securityAlgorithmDictionary;
    private static SecurityJan2004Dictionary s_securityJan2004Dictionary;
    private static SecurityXXX2005Dictionary s_securityXXX2005Dictionary;
    private static TrustFeb2005Dictionary s_trustFeb2005Dictionary;
    private static UtilityDictionary s_utilityDictionary;
    private static XmlSignatureDictionary s_xmlSignatureDictionary;
    public static ServiceModelDictionary Dictionary { get; }
    public static ActivityIdFlowDictionary ActivityIdFlowDictionary { get; }
    public static AddressingDictionary AddressingDictionary { get; }
    public static Addressing10Dictionary Addressing10Dictionary { get; }
    public static AddressingNoneDictionary AddressingNoneDictionary { get; }
    public static MessageDictionary MessageDictionary { get; }
    public static Message11Dictionary Message11Dictionary { get; }
    public static Message12Dictionary Message12Dictionary { get; }
    public static SecureConversationFeb2005Dictionary SecureConversationFeb2005Dictionary { get; }
    public static SecurityAlgorithmDictionary SecurityAlgorithmDictionary { get; }
    public static SecurityJan2004Dictionary SecurityJan2004Dictionary { get; }
    public static SecurityXXX2005Dictionary SecurityXXX2005Dictionary { get; }
    public static TrustFeb2005Dictionary TrustFeb2005Dictionary { get; }
    public static UtilityDictionary UtilityDictionary { get; }
    public static XmlSignatureDictionary XmlSignatureDictionary { get; }
    public static ServiceModelDictionary get_Dictionary();
    public static ActivityIdFlowDictionary get_ActivityIdFlowDictionary();
    public static AddressingDictionary get_AddressingDictionary();
    public static Addressing10Dictionary get_Addressing10Dictionary();
    public static AddressingNoneDictionary get_AddressingNoneDictionary();
    public static MessageDictionary get_MessageDictionary();
    public static Message11Dictionary get_Message11Dictionary();
    public static Message12Dictionary get_Message12Dictionary();
    public static SecureConversationFeb2005Dictionary get_SecureConversationFeb2005Dictionary();
    public static SecurityAlgorithmDictionary get_SecurityAlgorithmDictionary();
    public static SecurityJan2004Dictionary get_SecurityJan2004Dictionary();
    public static SecurityXXX2005Dictionary get_SecurityXXX2005Dictionary();
    public static TrustFeb2005Dictionary get_TrustFeb2005Dictionary();
    public static UtilityDictionary get_UtilityDictionary();
    public static XmlSignatureDictionary get_XmlSignatureDictionary();
}
internal class System.ServiceModel.XmlBuffer : object {
    private List`1<Section> _sections;
    private Byte[] _buffer;
    private int _offset;
    private BufferedOutputStream _stream;
    private BufferState _bufferState;
    private XmlDictionaryWriter _writer;
    private XmlDictionaryReaderQuotas _quotas;
    public int BufferSize { get; }
    public int SectionCount { get; }
    public XmlBuffer(int maxBufferSize);
    public int get_BufferSize();
    public int get_SectionCount();
    public XmlDictionaryWriter OpenSection(XmlDictionaryReaderQuotas quotas);
    public void CloseSection();
    public void Close();
    private Exception CreateInvalidStateException();
    public XmlDictionaryReader GetReader(int sectionIndex);
    public void WriteTo(int sectionIndex, XmlWriter writer);
}
internal static class System.ServiceModel.XmlEncryptionStrings : object {
    public static string Namespace;
    public static string DataReference;
    public static string EncryptedData;
    public static string EncryptionMethod;
    public static string CipherData;
    public static string CipherValue;
    public static string ReferenceList;
    public static string Encoding;
    public static string MimeType;
    public static string Type;
    public static string Id;
    public static string CarriedKeyName;
    public static string Recipient;
    public static string EncryptedKey;
    public static string URI;
    public static string KeyReference;
    public static string Prefix;
    public static string ElementType;
    public static string ContentType;
    public static string AlgorithmAttribute;
}
[ExtensionAttribute]
internal static class System.ServiceModel.XmlReaderExtensions : object {
    [ExtensionAttribute]
internal static string ReadElementString(XmlReader reader);
    [ExtensionAttribute]
internal static string ReadElementString(XmlReader reader, string localname, string ns);
}
[AttributeUsageAttribute("1092")]
public class System.ServiceModel.XmlSerializerFormatAttribute : Attribute {
    private bool _supportFaults;
    private OperationFormatStyle _style;
    private bool _isStyleSet;
    private OperationFormatUse _use;
    public bool SupportFaults { get; public set; }
    public OperationFormatStyle Style { get; public set; }
    public OperationFormatUse Use { get; public set; }
    internal bool IsEncoded { get; internal set; }
    public bool get_SupportFaults();
    public void set_SupportFaults(bool value);
    public OperationFormatStyle get_Style();
    public void set_Style(OperationFormatStyle value);
    public OperationFormatUse get_Use();
    public void set_Use(OperationFormatUse value);
    internal bool get_IsEncoded();
    internal void set_IsEncoded(bool value);
    internal static void ValidateOperationFormatStyle(OperationFormatStyle value);
    internal static void ValidateOperationFormatUse(OperationFormatUse value);
}
internal class System.ServiceModel.XmlSignatureDictionary : object {
    public XmlDictionaryString Algorithm;
    public XmlDictionaryString URI;
    public XmlDictionaryString Reference;
    public XmlDictionaryString Transforms;
    public XmlDictionaryString Transform;
    public XmlDictionaryString DigestMethod;
    public XmlDictionaryString DigestValue;
    public XmlDictionaryString Namespace;
    public XmlDictionaryString EnvelopedSignature;
    public XmlDictionaryString KeyInfo;
    public XmlDictionaryString Signature;
    public XmlDictionaryString SignedInfo;
    public XmlDictionaryString CanonicalizationMethod;
    public XmlDictionaryString SignatureMethod;
    public XmlDictionaryString SignatureValue;
    public XmlDictionaryString KeyName;
    public XmlDictionaryString Type;
    public XmlDictionaryString MgmtData;
    public XmlDictionaryString Prefix;
    public XmlDictionaryString KeyValue;
    public XmlDictionaryString RsaKeyValue;
    public XmlDictionaryString Modulus;
    public XmlDictionaryString Exponent;
    public XmlDictionaryString X509Data;
    public XmlDictionaryString X509IssuerSerial;
    public XmlDictionaryString X509IssuerName;
    public XmlDictionaryString X509SerialNumber;
    public XmlDictionaryString X509Certificate;
    public XmlSignatureDictionary(ServiceModelDictionary dictionary);
}
internal static class System.ServiceModel.XmlSignatureStrings : object {
    public static string Algorithm;
    public static string URI;
    public static string Reference;
    public static string Transforms;
    public static string Transform;
    public static string DigestMethod;
    public static string DigestValue;
    public static string Namespace;
    public static string EnvelopedSignature;
    public static string KeyInfo;
    public static string Signature;
    public static string SignedInfo;
    public static string CanonicalizationMethod;
    public static string SignatureMethod;
    public static string SignatureValue;
    public static string KeyName;
    public static string Type;
    public static string MgmtData;
    public static string Prefix;
    public static string KeyValue;
    public static string RsaKeyValue;
    public static string Modulus;
    public static string Exponent;
    public static string X509Data;
    public static string X509IssuerSerial;
    public static string X509IssuerName;
    public static string X509SerialNumber;
    public static string X509Certificate;
    public static string X509Ski;
    public static string TransformationParameters;
}
[ExtensionAttribute]
internal static class System.ServiceModel.XmlUtil : object {
    public static string XmlNs;
    public static string XmlNsNs;
    public static string XmlSerializerSchemaInstanceNamespace;
    public static string XmlSerializerSchemaNamespace;
    public static string GetXmlLangAttribute(XmlReader reader);
    public static bool IsTrue(string booleanValue);
    public static void ReadContentAsQName(XmlReader reader, String& localName, String& ns);
    public static bool IsWhitespace(char ch);
    public static string TrimEnd(string s);
    public static string TrimStart(string s);
    public static string Trim(string s);
    public static void ParseQName(XmlReader reader, string qname, String& localName, String& ns);
    [ExtensionAttribute]
public static DateTime ReadElementContentAsDateTime(XmlDictionaryReader reader);
}
internal static class System.SR : object {
    private static ResourceManager s_resourceManager;
    private static string s_resourcesName;
    private static ResourceManager ResourceManager { get; }
    internal static string NoIPEndpointsFoundForHost { get; }
    internal static string DnsResolveFailed { get; }
    internal static string RequiredAttributeMissing { get; }
    internal static string SecurityTokenManagerCannotCreateProviderForRequirement { get; }
    internal static string SecurityTokenManagerCannotCreateAuthenticatorForRequirement { get; }
    internal static string EncodingBindingElementDoesNotHandleReaderQuotas { get; }
    internal static string ErrorDeserializingKeyIdentifierClauseFromTokenXml { get; }
    internal static string ErrorDeserializingTokenXml { get; }
    internal static string TokenRequirementDoesNotSpecifyTargetAddress { get; }
    internal static string DerivedKeyNotInitialized { get; }
    internal static string MultipleSecurityCredentialsManagersInChannelBindingParameters { get; }
    internal static string DerivedKeyTokenOffsetTooHigh { get; }
    internal static string DerivedKeyTokenGenerationAndLengthTooHigh { get; }
    internal static string Psha1KeyLengthInvalid { get; }
    internal static string CloneNotImplementedCorrectly { get; }
    internal static string NegotiationFailedIO { get; }
    internal static string AnonymousLogonsAreNotAllowed { get; }
    internal static string MultipleSupportingAuthenticatorsOfSameType { get; }
    internal static string SecurityTokenParametersCloneInvalidResult { get; }
    internal static string CertificateUnsupportedForHttpTransportCredentialOnly { get; }
    internal static string NoncesCachedInfinitely { get; }
    internal static string TrustDriverVersionDoesNotSupportSession { get; }
    internal static string TrustDriverVersionDoesNotSupportIssuedTokens { get; }
    internal static string SignatureConfirmationNotSupported { get; }
    internal static string SecureConversationDriverVersionDoesNotSupportSession { get; }
    internal static string OneWayOperationReturnedFault { get; }
    internal static string OneWayOperationReturnedLargeFault { get; }
    internal static string OneWayOperationReturnedMessage { get; }
    internal static string KeyLifetimeNotWithinTokenLifetime { get; }
    internal static string EffectiveGreaterThanExpiration { get; }
    internal static string LengthMustBeGreaterThanZero { get; }
    internal static string OperationCannotBeDoneAfterProcessingIsStarted { get; }
    internal static string ClientCredentialsUnableToCreateLocalTokenProvider { get; }
    internal static string SecurityProtocolCannotDoReplayDetection { get; }
    internal static string CannotReadToken { get; }
    internal static string ExpectedElementMissing { get; }
    internal static string MissingMessageID { get; }
    internal static string OnlyBodyReturnValuesSupported { get; }
    internal static string UnexpectedEndOfFile { get; }
    internal static string TimeStampHasCreationAheadOfExpiry { get; }
    internal static string TimeStampHasExpiryTimeInPast { get; }
    internal static string TimeStampHasCreationTimeInFuture { get; }
    internal static string TimeStampWasCreatedTooLongAgo { get; }
    internal static string ItemNotAvailableInDeserializedRST { get; }
    internal static string ItemAvailableInDeserializedRSTOnly { get; }
    internal static string ItemNotAvailableInDeserializedRSTR { get; }
    internal static string ItemAvailableInDeserializedRSTROnly { get; }
    internal static string Hosting_ServiceActivationFailed { get; }
    internal static string Sharing_ConnectionDispatchFailed { get; }
    internal static string Sharing_EndpointUnavailable { get; }
    internal static string UnexpectedEmptyElementExpectingClaim { get; }
    internal static string UnexpectedElementExpectingElement { get; }
    internal static string UnexpectedDuplicateElement { get; }
    internal static string MultipleIdentities { get; }
    internal static string InvalidUriValue { get; }
    internal static string UnrecognizedIdentityType { get; }
    internal static string InvalidIdentityElement { get; }
    internal static string UnrecognizedClaimTypeForIdentity { get; }
    internal static string SendCannotBeCalledAfterCloseOutputSession { get; }
    internal static string CommunicationObjectCannotBeModifiedInState { get; }
    internal static string CommunicationObjectCannotBeUsed { get; }
    internal static string CommunicationObjectFaulted1 { get; }
    internal static string CommunicationObjectAborted1 { get; }
    internal static string CommunicationObjectBaseClassMethodNotCalled { get; }
    internal static string CommunicationObjectInInvalidState { get; }
    internal static string ChannelFactoryCannotBeUsedToCreateChannels { get; }
    internal static string ChannelParametersCannotBeModified { get; }
    internal static string ChannelParametersCannotBePropagated { get; }
    internal static string ChannelTypeNotSupported { get; }
    internal static string InvalidEnumValue { get; }
    internal static string InvalidDecoderStateMachine { get; }
    internal static string ObjectDisposed { get; }
    internal static string InvalidReaderPositionOnCreateMessage { get; }
    internal static string DuplicateMessageProperty { get; }
    internal static string MessagePropertyNotFound { get; }
    internal static string HeaderAlreadyUnderstood { get; }
    internal static string HeaderAlreadyNotUnderstood { get; }
    internal static string MultipleMessageHeaders { get; }
    internal static string MultipleMessageHeadersWithActor { get; }
    internal static string MultipleRelatesToHeaders { get; }
    internal static string ExtraContentIsPresentInFaultDetail { get; }
    internal static string MessageIsEmpty { get; }
    internal static string MessageClosed { get; }
    internal static string BodyWriterReturnedIsNotBuffered { get; }
    internal static string BodyWriterCanOnlyBeWrittenOnce { get; }
    internal static string RequestMessageDoesNotHaveAMessageID { get; }
    internal static string HeaderNotFound { get; }
    internal static string MessageBufferIsClosed { get; }
    internal static string MessageTextEncodingNotSupported { get; }
    internal static string AtLeastOneFaultReasonMustBeSpecified { get; }
    internal static string NoNullTranslations { get; }
    internal static string FaultDoesNotHaveAnyDetail { get; }
    internal static string InvalidXmlQualifiedName { get; }
    internal static string UnboundPrefixInQName { get; }
    internal static string MessageBodyIsUnknown { get; }
    internal static string MessageBodyIsStream { get; }
    internal static string MessageBodyToStringError { get; }
    internal static string NoMatchingTranslationFoundForFaultText { get; }
    internal static string CannotDetermineSPNBasedOnAddress { get; }
    internal static string XmlLangAttributeMissing { get; }
    internal static string EncoderUnrecognizedCharSet { get; }
    internal static string EncoderUnrecognizedContentType { get; }
    internal static string EncoderBadContentType { get; }
    internal static string EncoderEnvelopeVersionMismatch { get; }
    internal static string EncoderMessageVersionMismatch { get; }
    internal static string SPS_SeekNotSupported { get; }
    internal static string SocketCloseReadTimeout { get; }
    internal static string SocketCloseReadReceivedData { get; }
    internal static string SessionValueInvalid { get; }
    internal static string SocketAbortedReceiveTimedOut { get; }
    internal static string SocketAbortedSendTimedOut { get; }
    internal static string OperationInvalidBeforeSecurityNegotiation { get; }
    internal static string FramingError { get; }
    internal static string FramingPrematureEOF { get; }
    internal static string FramingRecordTypeMismatch { get; }
    internal static string FramingVersionNotSupported { get; }
    internal static string FramingModeNotSupported { get; }
    internal static string FramingSizeTooLarge { get; }
    internal static string FramingViaTooLong { get; }
    internal static string FramingViaNotUri { get; }
    internal static string FramingFaultTooLong { get; }
    internal static string FramingContentTypeTooLong { get; }
    internal static string FramingValueNotAvailable { get; }
    internal static string FramingAtEnd { get; }
    internal static string BinaryEncoderSessionTooLarge { get; }
    internal static string BinaryEncoderSessionInvalid { get; }
    internal static string BinaryEncoderSessionMalformed { get; }
    internal static string ReceiveShutdownReturnedFault { get; }
    internal static string ReceiveShutdownReturnedLargeFault { get; }
    internal static string ReceiveShutdownReturnedMessage { get; }
    internal static string MaxReceivedMessageSizeExceeded { get; }
    internal static string MaxSentMessageSizeExceeded { get; }
    internal static string FramingMaxMessageSizeExceeded { get; }
    internal static string StreamDoesNotSupportTimeout { get; }
    internal static string AddressingVersionNotSupported { get; }
    internal static string MessagePropertyReturnedNullCopy { get; }
    internal static string MessageVersionUnknown { get; }
    internal static string EnvelopeVersionUnknown { get; }
    internal static string EnvelopeVersionNotSupported { get; }
    internal static string CannotDetectAddressingVersion { get; }
    internal static string HeadersCannotBeAddedToEnvelopeVersion { get; }
    internal static string AddressingHeadersCannotBeAddedToAddressingVersion { get; }
    internal static string AddressingExtensionInBadNS { get; }
    internal static string MessageHeaderVersionNotSupported { get; }
    internal static string MessageHasBeenCopied { get; }
    internal static string MessageHasBeenWritten { get; }
    internal static string MessageHasBeenRead { get; }
    internal static string InvalidMessageState { get; }
    internal static string MessageBodyReaderInvalidReadState { get; }
    internal static string XmlBufferQuotaExceeded { get; }
    internal static string XmlBufferInInvalidState { get; }
    internal static string MessageBodyMissing { get; }
    internal static string MessageHeaderVersionMismatch { get; }
    internal static string ManualAddressingRequiresAddressedMessages { get; }
    internal static string ReceiveTimedOut2 { get; }
    internal static string WaitForMessageTimedOut { get; }
    internal static string SendToViaTimedOut { get; }
    internal static string CloseTimedOut { get; }
    internal static string OpenTimedOutEstablishingTransportSession { get; }
    internal static string RequestTimedOutEstablishingTransportSession { get; }
    internal static string TcpConnectingToViaTimedOut { get; }
    internal static string RequestChannelSendTimedOut { get; }
    internal static string RequestChannelWaitForReplyTimedOut { get; }
    internal static string HttpProxyRequiresSingleAuthScheme { get; }
    internal static string UseDefaultWebProxyCantBeUsedWithExplicitProxyAddress { get; }
    internal static string ProxyImpersonationLevelMismatch { get; }
    internal static string ProxyAuthenticationLevelMismatch { get; }
    internal static string HttpIfModifiedSinceParseError { get; }
    internal static string HttpSoapActionMismatch { get; }
    internal static string HttpSoapActionMismatchContentType { get; }
    internal static string HttpContentTypeFormatException { get; }
    internal static string HttpServerTooBusy { get; }
    internal static string HttpRequestTimedOut { get; }
    internal static string HttpResponseTimedOut { get; }
    internal static string HttpReceiveFailure { get; }
    internal static string HttpAuthDoesNotSupportRequestStreaming { get; }
    internal static string ReplyAlreadySent { get; }
    internal static string RequestContextAborted { get; }
    internal static string InnerChannelFactoryWasNotSet { get; }
    internal static string PropertySettingErrorOnProtocolFactory { get; }
    internal static string ProtocolFactoryCouldNotCreateProtocol { get; }
    internal static string IdentityCheckFailedForOutgoingMessage { get; }
    internal static string IdentityCheckFailedForIncomingMessage { get; }
    internal static string DnsIdentityCheckFailedForIncomingMessageLackOfDnsClaim { get; }
    internal static string DnsIdentityCheckFailedForOutgoingMessageLackOfDnsClaim { get; }
    internal static string DnsIdentityCheckFailedForIncomingMessage { get; }
    internal static string DnsIdentityCheckFailedForOutgoingMessage { get; }
    internal static string ClientCertificateNotProvidedOnClientCredentials { get; }
    internal static string UserNamePasswordNotProvidedOnClientCredentials { get; }
    internal static string ObjectIsReadOnly { get; }
    internal static string EmptyXmlElementError { get; }
    internal static string UnexpectedXmlChildNode { get; }
    internal static string InvalidQName { get; }
    internal static string SuiteDoesNotAcceptAlgorithm { get; }
    internal static string CannotFindCert { get; }
    internal static string CannotFindCertForTarget { get; }
    internal static string FoundMultipleCerts { get; }
    internal static string FoundMultipleCertsForTarget { get; }
    internal static string SigningTokenHasNoKeys { get; }
    internal static string SigningTokenHasNoKeysSupportingTheAlgorithmSuite { get; }
    internal static string EmptyBase64Attribute { get; }
    internal static string CouldNotFindNamespaceForPrefix { get; }
    internal static string ChildNodeTypeMissing { get; }
    internal static string SPS_InvalidAsyncResult { get; }
    internal static string NonceLengthTooShort { get; }
    internal static string IncorrectBinaryNegotiationValueType { get; }
    internal static string CreationTimeUtcIsAfterExpiryTime { get; }
    internal static string CacheQuotaReached { get; }
    internal static string UnrecognizedIdentityPropertyType { get; }
    internal static string EndpointNotFound { get; }
    internal static string MaxReceivedMessageSizeMustBeInIntegerRange { get; }
    internal static string MaxBufferSizeMustMatchMaxReceivedMessageSize { get; }
    internal static string MaxBufferSizeMustNotExceedMaxReceivedMessageSize { get; }
    internal static string InValidateIdPrefix { get; }
    internal static string InValidateId { get; }
    internal static string UnexpectedHttpResponseCode { get; }
    internal static string HttpContentLengthIncorrect { get; }
    internal static string MissingContentType { get; }
    internal static string DuplexChannelAbortedDuringOpen { get; }
    internal static string OperationAbortedDuringConnectionEstablishment { get; }
    internal static string HttpAddressingNoneHeaderOnWire { get; }
    internal static string MessageXmlProtocolError { get; }
    internal static string TcpConnectNoBufs { get; }
    internal static string InsufficentMemory { get; }
    internal static string TcpConnectError { get; }
    internal static string TcpConnectErrorWithTimeSpan { get; }
    internal static string TcpTransferError { get; }
    internal static string TcpLocalConnectionAborted { get; }
    internal static string TcpConnectionResetError { get; }
    internal static string TcpConnectionTimedOut { get; }
    internal static string SocketConnectionDisposed { get; }
    internal static string HttpContentTypeHeaderRequired { get; }
    internal static string ResponseContentTypeMismatch { get; }
    internal static string HttpToMustEqualVia { get; }
    internal static string FramingContentTypeMismatch { get; }
    internal static string FramingFaultUnrecognized { get; }
    internal static string FramingContentTypeTooLongFault { get; }
    internal static string FramingViaTooLongFault { get; }
    internal static string FramingModeNotSupportedFault { get; }
    internal static string FramingVersionNotSupportedFault { get; }
    internal static string FramingUpgradeInvalid { get; }
    internal static string ServerTooBusy { get; }
    internal static string PreambleAckIncorrect { get; }
    internal static string PreambleAckIncorrectMaybeHttp { get; }
    internal static string StreamError { get; }
    internal static string ServerRejectedUpgradeRequest { get; }
    internal static string ServerRejectedSessionPreamble { get; }
    internal static string UnableToResolveHost { get; }
    internal static string HttpRequiresSingleAuthScheme { get; }
    internal static string HttpAuthSchemeCannotBeNone { get; }
    internal static string HttpAuthorizationFailed { get; }
    internal static string HttpAuthorizationForbidden { get; }
    internal static string InvalidUriScheme { get; }
    internal static string HttpsServerCertThumbprintMismatch { get; }
    internal static string TrustFailure { get; }
    internal static string StreamMutualAuthNotSatisfied { get; }
    internal static string InvalidTokenProvided { get; }
    internal static string NoUserNameTokenProvided { get; }
    internal static string RemoteIdentityFailedVerification { get; }
    internal static string CredentialDisallowsNtlm { get; }
    internal static string UriGeneratorSchemeMustNotBeEmpty { get; }
    internal static string UnsupportedSslProtectionLevel { get; }
    internal static string TimeoutServiceChannelConcurrentOpen1 { get; }
    internal static string TimeoutServiceChannelConcurrentOpen2 { get; }
    internal static string TimeSpanMustbeGreaterThanTimeSpanZero { get; }
    internal static string AsyncResultCompletedTwice { get; }
    internal static string ValueMustBeNonNegative { get; }
    internal static string ValueMustBePositive { get; }
    internal static string ValueMustBeGreaterThanZero { get; }
    internal static string ValueMustBeInRange { get; }
    internal static string OffsetExceedsBufferSize { get; }
    internal static string SizeExceedsRemainingBufferSpace { get; }
    internal static string SpaceNeededExceedsMessageFrameOffset { get; }
    internal static string FaultConverterDidNotCreateFaultMessage { get; }
    internal static string FaultConverterCreatedFaultMessage { get; }
    internal static string FaultConverterDidNotCreateException { get; }
    internal static string FaultConverterCreatedException { get; }
    internal static string UnsupportedUpgradeInitiator { get; }
    internal static string StreamUpgradeUnsupportedChannelBindingKind { get; }
    internal static string ExtendedProtectionNotSupported { get; }
    internal static string HttpClientCredentialTypeInvalid { get; }
    internal static string TransportDoesNotSupportCompression { get; }
    internal static string UnsupportedSecuritySetting { get; }
    internal static string UnsupportedBindingProperty { get; }
    internal static string HttpMaxPendingAcceptsTooLargeError { get; }
    internal static string UnsupportedTokenImpersonationLevel { get; }
    internal static string TimeoutOnOpen { get; }
    internal static string TimeoutOnRequest { get; }
    internal static string SFxActionDemuxerDuplicate { get; }
    internal static string SFXBindingNameCannotBeNullOrEmpty { get; }
    internal static string SFXUnvalidNamespaceValue { get; }
    internal static string SFXUnvalidNamespaceParam { get; }
    internal static string SFXHeaderNameCannotBeNullOrEmpty { get; }
    internal static string SFxBadByReferenceParameterMetadata { get; }
    internal static string SFxBadByValueParameterMetadata { get; }
    internal static string SFxBindingMustContainTransport2 { get; }
    internal static string SFxBodyCannotBeNull { get; }
    internal static string SFxCallbackBehaviorAttributeOnlyOnDuplex { get; }
    internal static string SFxCallbackRequestReplyInOrder1 { get; }
    internal static string SfxCallbackTypeCannotBeNull { get; }
    internal static string SFxCannotActivateCallbackInstace { get; }
    internal static string SFxCannotCallAutoOpenWhenExplicitOpenCalled { get; }
    internal static string SFxCannotSetExtensionsByIndex { get; }
    internal static string SFxChannelDispatcherNoMessageVersion { get; }
    internal static string SFxChannelDispatcherUnableToOpen1 { get; }
    internal static string SFxChannelDispatcherUnableToOpen2 { get; }
    internal static string SFxChannelFactoryTypeMustBeInterface { get; }
    internal static string SFxChannelFactoryCannotCreateFactoryWithoutDescription { get; }
    internal static string SFxClientOutputSessionAutoClosed { get; }
    internal static string SFxCollectionDoesNotSupportSet0 { get; }
    internal static string SFxCollectionReadOnly { get; }
    internal static string SFxCollectionWrongType2 { get; }
    internal static string SFxContextModifiedInsideScope0 { get; }
    internal static string SFxContractDescriptionNameCannotBeEmpty { get; }
    internal static string SFxContractHasZeroOperations { get; }
    internal static string SFxContractHasZeroInitiatingOperations { get; }
    internal static string SFxContractInheritanceRequiresInterfaces { get; }
    internal static string SFxContractInheritanceRequiresInterfaces2 { get; }
    internal static string SFxCopyToRequiresICollection { get; }
    internal static string SFxCreateDuplexChannel1 { get; }
    internal static string SFxCreateDuplexChannelNoCallback { get; }
    internal static string SFxCreateDuplexChannelNoCallback1 { get; }
    internal static string SFxCreateDuplexChannelNoCallbackUserObject { get; }
    internal static string SFxCreateDuplexChannelBadCallbackUserObject { get; }
    internal static string SFxCreateNonDuplexChannel1 { get; }
    internal static string SFxCustomBindingNeedsTransport1 { get; }
    internal static string SFxDeserializationFailed1 { get; }
    internal static string SFxDisallowedAttributeCombination { get; }
    internal static string SFxInitializationUINotCalled { get; }
    internal static string SFxInitializationUIDisallowed { get; }
    internal static string SFxDocEncodedNotSupported { get; }
    internal static string SFxDuplicateMessageParts { get; }
    internal static string SFXEndpointBehaviorUsedOnWrongSide { get; }
    internal static string SFxEndpointDispatcherMultipleChannelDispatcher0 { get; }
    internal static string SFxEndpointDispatcherDifferentChannelDispatcher0 { get; }
    internal static string SFxErrorDeserializingRequestBody { get; }
    internal static string SFxErrorDeserializingRequestBodyMore { get; }
    internal static string SFxErrorDeserializingReplyBody { get; }
    internal static string SFxErrorDeserializingReplyBodyMore { get; }
    internal static string SFxErrorSerializingBody { get; }
    internal static string SFxErrorDeserializingHeader { get; }
    internal static string SFxErrorSerializingHeader { get; }
    internal static string SFxErrorDeserializingFault { get; }
    internal static string SFxErrorReflectingOnType2 { get; }
    internal static string SFxErrorReflectingOnMethod3 { get; }
    internal static string SFxErrorReflectingOnParameter4 { get; }
    internal static string SFxErrorReflectionOnUnknown1 { get; }
    internal static string SFxExceptionDetailEndOfInner { get; }
    internal static string SFxExceptionDetailFormat { get; }
    internal static string SFxFaultContractDuplicateDetailType { get; }
    internal static string SFxFaultContractDuplicateElement { get; }
    internal static string SFxFaultExceptionToString3 { get; }
    internal static string SFxFaultReason { get; }
    internal static string SFxFaultTypeAnonymous { get; }
    internal static string SFxHeaderNameMismatchInMessageContract { get; }
    internal static string SFxHeaderNameMismatchInOperation { get; }
    internal static string SFxHeaderNamespaceMismatchInMessageContract { get; }
    internal static string SFxHeaderNamespaceMismatchInOperation { get; }
    internal static string SFxHeaderNotUnderstood { get; }
    internal static string SFxImmutableServiceHostBehavior0 { get; }
    internal static string SFxImmutableChannelFactoryBehavior0 { get; }
    internal static string SFxInputParametersToServiceInvalid { get; }
    internal static string SFxInputParametersToServiceNull { get; }
    internal static string SFxInstanceNotInitialized { get; }
    internal static string SFxInterleavedContextScopes0 { get; }
    internal static string SFxInternalServerError { get; }
    internal static string SFxInternalCallbackError { get; }
    internal static string SFxInvalidAsyncResultState0 { get; }
    internal static string SFxInvalidCallbackIAsyncResult { get; }
    internal static string SFxInvalidCallbackContractType { get; }
    internal static string SFxInvalidChannelToOperationContext { get; }
    internal static string SFxInvalidMessageBody { get; }
    internal static string SFxInvalidMessageBodyEmptyMessage { get; }
    internal static string SFxInvalidMessageBodyErrorSerializingParameter { get; }
    internal static string SFxInvalidMessageBodyErrorDeserializingParameter { get; }
    internal static string SFxInvalidMessageBodyErrorDeserializingParameterMore { get; }
    internal static string SFxInvalidMessageContractSignature { get; }
    internal static string SFxInvalidMessageHeaderArrayType { get; }
    internal static string SFxInvalidRequestAction { get; }
    internal static string SFxInvalidReplyAction { get; }
    internal static string SFxInvalidStreamInTypedMessage { get; }
    internal static string SFxInvalidStreamInRequest { get; }
    internal static string SFxInvalidStreamInResponse { get; }
    internal static string SFxInvalidStreamOffsetLength { get; }
    internal static string SFxInvalidUseOfPrimitiveOperationFormatter { get; }
    internal static string SFxInvalidStaticOverloadCalledForDuplexChannelFactory1 { get; }
    internal static string SFxInvalidXmlAttributeInBare { get; }
    internal static string SFxInvalidXmlAttributeInWrapped { get; }
    internal static string SFxKnownTypeAttributeInvalid1 { get; }
    internal static string SFxKnownTypeAttributeReturnType3 { get; }
    internal static string SFxKnownTypeAttributeUnknownMethod3 { get; }
    internal static string SFxKnownTypeNull { get; }
    internal static string SFxMessageContractBaseTypeNotValid { get; }
    internal static string SFxMessageContractRequiresDefaultConstructor { get; }
    internal static string SFxMetadataReferenceInvalidLocation { get; }
    internal static string SFxMethodNotSupported1 { get; }
    internal static string SFxMethodNotSupportedOnCallback1 { get; }
    internal static string SFxMismatchedOperationParent { get; }
    internal static string SFxMissingActionHeader { get; }
    internal static string SFxMultipleCallbackFromSynchronizationContext { get; }
    internal static string SFxMultipleCallbackFromAsyncOperation { get; }
    internal static string SFxMultipleUnknownHeaders { get; }
    internal static string SFxMultipleContractStarOperations0 { get; }
    internal static string SFxNameCannotBeEmpty { get; }
    internal static string SFxConfigurationNameCannotBeEmpty { get; }
    internal static string SFxNeedProxyBehaviorOperationSelector2 { get; }
    internal static string SFxNoDefaultConstructor { get; }
    internal static string SFxNoMostDerivedContract { get; }
    internal static string SFxNullReplyFromFormatter2 { get; }
    internal static string SFxServiceChannelIdleAborted { get; }
    internal static string SFxSetEnableFaultsOnChannelDispatcher0 { get; }
    internal static string SFxSetManualAddresssingOnChannelDispatcher0 { get; }
    internal static string SFxNoServiceObject { get; }
    internal static string SFxNonExceptionThrown { get; }
    internal static string SFxNonInitiatingOperation1 { get; }
    internal static string SFxOneWayMessageToTwoWayMethod0 { get; }
    internal static string SFxOperationContractOnNonServiceContract { get; }
    internal static string SFxOperationContractProviderOnNonServiceContract { get; }
    internal static string SFxOperationDescriptionNameCannotBeEmpty { get; }
    internal static string SFxParameterNameCannotBeNull { get; }
    internal static string SFxOperationMustHaveOneOrTwoMessages { get; }
    internal static string SFxParameterCountMismatch { get; }
    internal static string SFxParameterMustBeMessage { get; }
    internal static string SFxParametersMustBeEmpty { get; }
    internal static string SFxParameterMustBeArrayOfOneElement { get; }
    internal static string SFxRequestHasInvalidReplyToOnClient { get; }
    internal static string SFxRequestHasInvalidFaultToOnClient { get; }
    internal static string SFxRequestReplyNone { get; }
    internal static string SFxRequestTimedOut1 { get; }
    internal static string SFxRequestTimedOut2 { get; }
    internal static string SFxReplyActionMismatch3 { get; }
    internal static string SFxResultMustBeMessage { get; }
    internal static string SFxRpcMessageBodyPartNameInvalid { get; }
    internal static string SFxServerDidNotReply { get; }
    internal static string SFxStaticMessageHeaderPropertiesNotAllowed { get; }
    internal static string SFxStreamIOException { get; }
    internal static string SFxStreamRequestMessageClosed { get; }
    internal static string SFxStreamResponseMessageClosed { get; }
    internal static string SFxTimeoutOutOfRange0 { get; }
    internal static string SFxTimeoutOutOfRangeTooBig { get; }
    internal static string SFxTypedMessageCannotBeNull { get; }
    internal static string SFxTypedMessageCannotBeRpcLiteral { get; }
    internal static string SFxTypedOrUntypedMessageCannotBeMixedWithParameters { get; }
    internal static string SFxTypedOrUntypedMessageCannotBeMixedWithVoidInRpc { get; }
    internal static string SFxUnknownFaultNoMatchingTranslation1 { get; }
    internal static string SFxUnknownFaultNullReason0 { get; }
    internal static string SFxUnknownFaultZeroReasons0 { get; }
    internal static string SFxVersionMismatchInOperationContextAndMessage2 { get; }
    internal static string SFxWrapperNameCannotBeEmpty { get; }
    internal static string SFxXmlArrayNotAllowedForMultiple { get; }
    internal static string SFxXmlSerializerIsNotFound { get; }
    internal static string SFxChannelFactoryEndpointAddressUri { get; }
    internal static string SFxCloseTimedOut1 { get; }
    internal static string SfxCloseTimedOutWaitingForDispatchToComplete { get; }
    internal static string SFxChannelFactoryNoBindingFoundInConfig1 { get; }
    internal static string SFxChannelFactoryNoBindingFoundInConfigOrCode { get; }
    internal static string SFxProxyRuntimeMessageCannotBeNull { get; }
    internal static string SFxDispatchRuntimeMessageCannotBeNull { get; }
    internal static string SFxMessagePartDescriptionMissingType { get; }
    internal static string AChannelServiceEndpointSBindingIsNull0 { get; }
    internal static string AChannelServiceEndpointSContractIsNull0 { get; }
    internal static string AChannelServiceEndpointSContractSNameIsNull0 { get; }
    internal static string AChannelServiceEndpointSContractSNamespace0 { get; }
    internal static string SFxNoEndpointMatchingContract { get; }
    internal static string SFxNoEndpointMatchingAddress { get; }
    internal static string SFxNoEndpointMatchingAddressForConnectionOpeningMessage { get; }
    internal static string SFxServiceChannelCannotBeCalledBecauseIsSessionOpenNotificationEnabled { get; }
    internal static string EndMethodsCannotBeDecoratedWithOperationContractAttribute { get; }
    internal static string DispatchRuntimeRequiresFormatter0 { get; }
    internal static string ClientRuntimeRequiresFormatter0 { get; }
    internal static string RuntimeRequiresInvoker0 { get; }
    internal static string CouldnTCreateChannelForType2 { get; }
    internal static string CouldnTCreateChannelForChannelType2 { get; }
    internal static string EndpointListenerRequirementsCannotBeMetBy3 { get; }
    internal static string UnknownListenerType1 { get; }
    internal static string BindingDoesnTSupportSessionButContractRequires1 { get; }
    internal static string BindingDoesntSupportDatagramButContractRequires { get; }
    internal static string BindingDoesnTSupportOneWayButContractRequires1 { get; }
    internal static string BindingDoesnTSupportTwoWayButContractRequires1 { get; }
    internal static string BindingDoesnTSupportRequestReplyButContract1 { get; }
    internal static string BindingDoesnTSupportDuplexButContractRequires1 { get; }
    internal static string BindingDoesnTSupportAnyChannelTypes1 { get; }
    internal static string ContractIsNotSelfConsistentItHasOneOrMore2 { get; }
    internal static string ContractIsNotSelfConsistentWhenIsSessionOpenNotificationEnabled { get; }
    internal static string SynchronizedCollectionWrongType1 { get; }
    internal static string SynchronizedCollectionWrongTypeNull { get; }
    internal static string CannotAddTwoItemsWithTheSameKeyToSynchronizedKeyedCollection0 { get; }
    internal static string ItemDoesNotExistInSynchronizedKeyedCollection0 { get; }
    internal static string SuppliedMessageIsNotAReplyItHasNoRelatesTo0 { get; }
    internal static string channelIsNotAvailable0 { get; }
    internal static string channelDoesNotHaveADuplexSession0 { get; }
    internal static string UnsupportedEnvelopeVersion { get; }
    internal static string ServicesWithoutAServiceContractAttributeCan2 { get; }
    internal static string tooManyAttributesOfTypeOn2 { get; }
    internal static string couldnTFindRequiredAttributeOfTypeOn2 { get; }
    internal static string AttemptedToGetContractTypeForButThatTypeIs1 { get; }
    internal static string NoEndMethodFoundForAsyncBeginMethod3 { get; }
    internal static string MoreThanOneEndMethodFoundForAsyncBeginMethod3 { get; }
    internal static string InvalidAsyncEndMethodSignatureForMethod2 { get; }
    internal static string InvalidAsyncBeginMethodSignatureForMethod2 { get; }
    internal static string InAContractInheritanceHierarchyIfParentHasCallbackChildMustToo { get; }
    internal static string InAContractInheritanceHierarchyTheServiceContract3_2 { get; }
    internal static string CannotHaveTwoOperationsWithTheSameName3 { get; }
    internal static string CannotInheritTwoOperationsWithTheSameName3 { get; }
    internal static string SyncAsyncMatchConsistency_Parameters5 { get; }
    internal static string SyncTaskMatchConsistency_Parameters5 { get; }
    internal static string TaskAsyncMatchConsistency_Parameters5 { get; }
    internal static string SyncAsyncMatchConsistency_ReturnType5 { get; }
    internal static string SyncTaskMatchConsistency_ReturnType5 { get; }
    internal static string TaskAsyncMatchConsistency_ReturnType5 { get; }
    internal static string SyncAsyncMatchConsistency_Attributes6 { get; }
    internal static string SyncTaskMatchConsistency_Attributes6 { get; }
    internal static string TaskAsyncMatchConsistency_Attributes6 { get; }
    internal static string SyncAsyncMatchConsistency_Property6 { get; }
    internal static string SyncTaskMatchConsistency_Property6 { get; }
    internal static string TaskAsyncMatchConsistency_Property6 { get; }
    internal static string ServiceOperationsMarkedWithIsOneWayTrueMust0 { get; }
    internal static string OneWayOperationShouldNotSpecifyAReplyAction1 { get; }
    internal static string OneWayAndFaultsIncompatible2 { get; }
    internal static string AsyncEndCalledOnWrongChannel { get; }
    internal static string AsyncEndCalledWithAnIAsyncResult { get; }
    internal static string MessageHeaderIsNull0 { get; }
    internal static string MessagePropertiesArraySize0 { get; }
    internal static string DuplicateBehavior1 { get; }
    internal static string CantCreateChannelWithManualAddressing { get; }
    internal static string XDCannotFindValueInDictionaryString { get; }
    internal static string NoChannelBuilderAvailable { get; }
    internal static string InvalidBindingScheme { get; }
    internal static string CustomBindingRequiresTransport { get; }
    internal static string TransportBindingElementMustBeLast { get; }
    internal static string MessageVersionMissingFromBinding { get; }
    internal static string NotAllBindingElementsBuilt { get; }
    internal static string MultipleMebesInParameters { get; }
    internal static string MultipleStreamUpgradeProvidersInParameters { get; }
    internal static string SecurityCapabilitiesMismatched { get; }
    internal static string BaseAddressMustBeAbsolute { get; }
    internal static string BaseAddressDuplicateScheme { get; }
    internal static string BaseAddressCannotHaveUserInfo { get; }
    internal static string BaseAddressCannotHaveQuery { get; }
    internal static string BaseAddressCannotHaveFragment { get; }
    internal static string UriMustBeAbsolute { get; }
    internal static string ClaimTypeCannotBeEmpty { get; }
    internal static string MissingCustomCertificateValidator { get; }
    internal static string SecurityAuditPlatformNotSupported { get; }
    internal static string ActivityCallback { get; }
    internal static string ActivityClose { get; }
    internal static string ActivityConstructChannelFactory { get; }
    internal static string ActivityExecuteMethod { get; }
    internal static string ActivityCloseClientBase { get; }
    internal static string ActivityOpenClientBase { get; }
    internal static string ActivityProcessAction { get; }
    internal static string ActivityProcessingMessage { get; }
    internal static string TraceCodeConnectionPoolIdleTimeoutReached { get; }
    internal static string TraceCodeConnectionPoolLeaseTimeoutReached { get; }
    internal static string TraceCodeConnectionPoolMaxOutboundConnectionsPerEndpointQuotaReached { get; }
    internal static string InputTypeListEmptyError { get; }
    internal static string DelegatingHandlerArrayHasNonNullInnerHandler { get; }
    internal static string DelegatingHandlerArrayFromFuncContainsNullItem { get; }
    internal static string HttpMessageHandlerTypeNotSupported { get; }
    internal static string HttpPipelineNotSupportedOnClientSide { get; }
    internal static string WebSocketInvalidProtocolInvalidCharInProtocolString { get; }
    internal static string WebSocketInvalidProtocolContainsMultipleSubProtocolString { get; }
    internal static string WebSocketInvalidProtocolEmptySubprotocolString { get; }
    internal static string WebSocketUnexpectedCloseMessageError { get; }
    internal static string WebSocketStreamWriteCalledAfterEOMSent { get; }
    internal static string WebSocketCannotCreateRequestClientChannelWithCertainWebSocketTransportUsage { get; }
    internal static string ClientWebSocketFactory_CreateWebSocketFailed { get; }
    internal static string ClientWebSocketFactory_InvalidWebSocket { get; }
    internal static string ClientWebSocketFactory_InvalidSubProtocol { get; }
    internal static string WebSocketSendTimedOut { get; }
    internal static string WebSocketReceiveTimedOut { get; }
    internal static string WebSocketOperationTimedOut { get; }
    internal static string WebSocketVersionMismatchFromServer { get; }
    internal static string WebSocketSubProtocolMismatchFromServer { get; }
    internal static string CopyHttpHeaderFailed { get; }
    internal static string XmlInvalidConversion { get; }
    internal static string XmlInvalidStream { get; }
    internal static string LockTimeoutExceptionMessage { get; }
    internal static string InvalidEnumArgument { get; }
    internal static string InvalidTypedProxyMethodHandle { get; }
    internal static string FailedToCreateTypedProxy { get; }
    internal static string SecurityTokenRequirementDoesNotContainProperty { get; }
    internal static string SecurityTokenRequirementHasInvalidTypeForProperty { get; }
    internal static string TokenCancellationNotSupported { get; }
    internal static string TokenProviderUnableToGetToken { get; }
    internal static string TokenProviderUnableToRenewToken { get; }
    internal static string TokenRenewalNotSupported { get; }
    internal static string UserNameCannotBeEmpty { get; }
    internal static string ActivityBoundary { get; }
    internal static string StringNullOrEmpty { get; }
    internal static string GenericCallbackException { get; }
    internal static string ArgumentCannotBeEmptyString { get; }
    internal static string KeyIdentifierClauseDoesNotSupportKeyCreation { get; }
    internal static string SymmetricKeyLengthTooShort { get; }
    internal static string KeyIdentifierCannotCreateKey { get; }
    internal static string NoKeyIdentifierClauseFound { get; }
    internal static string LocalIdCannotBeEmpty { get; }
    internal static string CannotValidateSecurityTokenType { get; }
    internal static string UnauthorizedAccess_MemStreamBuffer { get; }
    internal static string ConfigurationFilesNotSupported { get; }
    internal static string X509ChainBuildFail { get; }
    internal static string ImpersonationLevelNotSupported { get; }
    internal static string ProvidedNetworkCredentialsForKerberosHasInvalidUserName { get; }
    internal static string SSLProtocolNegotiationFailed { get; }
    internal static string ssl_io_cert_validation { get; }
    internal static string X509InvalidUsageTime { get; }
    internal static string X509IsInUntrustedStore { get; }
    internal static string X509IsNotInTrustedStore { get; }
    internal static string Xml_InvalidNodeType { get; }
    internal static string SFxRpcMessageMustHaveASingleBody { get; }
    internal static string SFxBodyObjectTypeCannotBeInherited { get; }
    internal static string SFxBodyObjectTypeCannotBeInterface { get; }
    internal static string SFxHeadersAreNotSupportedInEncoded { get; }
    internal static string SFxMultiplePartsNotAllowedInEncoded { get; }
    internal static string SFxInvalidSoapAttribute { get; }
    internal static string SFxTerminatingOperationAlreadyCalled1 { get; }
    internal static string SFxChannelTerminated0 { get; }
    internal static string PeerTrustNotSupportedOnOSX { get; }
    internal static Type ResourceType { get; }
    private static ResourceManager get_ResourceManager();
    private static bool UsingResourceKeys();
    internal static string GetResourceString(string resourceKey, string defaultString);
    internal static string Format(string resourceFormat, Object[] args);
    internal static string Format(string resourceFormat, object p1);
    internal static string Format(string resourceFormat, object p1, object p2);
    internal static string Format(string resourceFormat, object p1, object p2, object p3);
    internal static string get_NoIPEndpointsFoundForHost();
    internal static string get_DnsResolveFailed();
    internal static string get_RequiredAttributeMissing();
    internal static string get_SecurityTokenManagerCannotCreateProviderForRequirement();
    internal static string get_SecurityTokenManagerCannotCreateAuthenticatorForRequirement();
    internal static string get_EncodingBindingElementDoesNotHandleReaderQuotas();
    internal static string get_ErrorDeserializingKeyIdentifierClauseFromTokenXml();
    internal static string get_ErrorDeserializingTokenXml();
    internal static string get_TokenRequirementDoesNotSpecifyTargetAddress();
    internal static string get_DerivedKeyNotInitialized();
    internal static string get_MultipleSecurityCredentialsManagersInChannelBindingParameters();
    internal static string get_DerivedKeyTokenOffsetTooHigh();
    internal static string get_DerivedKeyTokenGenerationAndLengthTooHigh();
    internal static string get_Psha1KeyLengthInvalid();
    internal static string get_CloneNotImplementedCorrectly();
    internal static string get_NegotiationFailedIO();
    internal static string get_AnonymousLogonsAreNotAllowed();
    internal static string get_MultipleSupportingAuthenticatorsOfSameType();
    internal static string get_SecurityTokenParametersCloneInvalidResult();
    internal static string get_CertificateUnsupportedForHttpTransportCredentialOnly();
    internal static string get_NoncesCachedInfinitely();
    internal static string get_TrustDriverVersionDoesNotSupportSession();
    internal static string get_TrustDriverVersionDoesNotSupportIssuedTokens();
    internal static string get_SignatureConfirmationNotSupported();
    internal static string get_SecureConversationDriverVersionDoesNotSupportSession();
    internal static string get_OneWayOperationReturnedFault();
    internal static string get_OneWayOperationReturnedLargeFault();
    internal static string get_OneWayOperationReturnedMessage();
    internal static string get_KeyLifetimeNotWithinTokenLifetime();
    internal static string get_EffectiveGreaterThanExpiration();
    internal static string get_LengthMustBeGreaterThanZero();
    internal static string get_OperationCannotBeDoneAfterProcessingIsStarted();
    internal static string get_ClientCredentialsUnableToCreateLocalTokenProvider();
    internal static string get_SecurityProtocolCannotDoReplayDetection();
    internal static string get_CannotReadToken();
    internal static string get_ExpectedElementMissing();
    internal static string get_MissingMessageID();
    internal static string get_OnlyBodyReturnValuesSupported();
    internal static string get_UnexpectedEndOfFile();
    internal static string get_TimeStampHasCreationAheadOfExpiry();
    internal static string get_TimeStampHasExpiryTimeInPast();
    internal static string get_TimeStampHasCreationTimeInFuture();
    internal static string get_TimeStampWasCreatedTooLongAgo();
    internal static string get_ItemNotAvailableInDeserializedRST();
    internal static string get_ItemAvailableInDeserializedRSTOnly();
    internal static string get_ItemNotAvailableInDeserializedRSTR();
    internal static string get_ItemAvailableInDeserializedRSTROnly();
    internal static string get_Hosting_ServiceActivationFailed();
    internal static string get_Sharing_ConnectionDispatchFailed();
    internal static string get_Sharing_EndpointUnavailable();
    internal static string get_UnexpectedEmptyElementExpectingClaim();
    internal static string get_UnexpectedElementExpectingElement();
    internal static string get_UnexpectedDuplicateElement();
    internal static string get_MultipleIdentities();
    internal static string get_InvalidUriValue();
    internal static string get_UnrecognizedIdentityType();
    internal static string get_InvalidIdentityElement();
    internal static string get_UnrecognizedClaimTypeForIdentity();
    internal static string get_SendCannotBeCalledAfterCloseOutputSession();
    internal static string get_CommunicationObjectCannotBeModifiedInState();
    internal static string get_CommunicationObjectCannotBeUsed();
    internal static string get_CommunicationObjectFaulted1();
    internal static string get_CommunicationObjectAborted1();
    internal static string get_CommunicationObjectBaseClassMethodNotCalled();
    internal static string get_CommunicationObjectInInvalidState();
    internal static string get_ChannelFactoryCannotBeUsedToCreateChannels();
    internal static string get_ChannelParametersCannotBeModified();
    internal static string get_ChannelParametersCannotBePropagated();
    internal static string get_ChannelTypeNotSupported();
    internal static string get_InvalidEnumValue();
    internal static string get_InvalidDecoderStateMachine();
    internal static string get_ObjectDisposed();
    internal static string get_InvalidReaderPositionOnCreateMessage();
    internal static string get_DuplicateMessageProperty();
    internal static string get_MessagePropertyNotFound();
    internal static string get_HeaderAlreadyUnderstood();
    internal static string get_HeaderAlreadyNotUnderstood();
    internal static string get_MultipleMessageHeaders();
    internal static string get_MultipleMessageHeadersWithActor();
    internal static string get_MultipleRelatesToHeaders();
    internal static string get_ExtraContentIsPresentInFaultDetail();
    internal static string get_MessageIsEmpty();
    internal static string get_MessageClosed();
    internal static string get_BodyWriterReturnedIsNotBuffered();
    internal static string get_BodyWriterCanOnlyBeWrittenOnce();
    internal static string get_RequestMessageDoesNotHaveAMessageID();
    internal static string get_HeaderNotFound();
    internal static string get_MessageBufferIsClosed();
    internal static string get_MessageTextEncodingNotSupported();
    internal static string get_AtLeastOneFaultReasonMustBeSpecified();
    internal static string get_NoNullTranslations();
    internal static string get_FaultDoesNotHaveAnyDetail();
    internal static string get_InvalidXmlQualifiedName();
    internal static string get_UnboundPrefixInQName();
    internal static string get_MessageBodyIsUnknown();
    internal static string get_MessageBodyIsStream();
    internal static string get_MessageBodyToStringError();
    internal static string get_NoMatchingTranslationFoundForFaultText();
    internal static string get_CannotDetermineSPNBasedOnAddress();
    internal static string get_XmlLangAttributeMissing();
    internal static string get_EncoderUnrecognizedCharSet();
    internal static string get_EncoderUnrecognizedContentType();
    internal static string get_EncoderBadContentType();
    internal static string get_EncoderEnvelopeVersionMismatch();
    internal static string get_EncoderMessageVersionMismatch();
    internal static string get_SPS_SeekNotSupported();
    internal static string get_SocketCloseReadTimeout();
    internal static string get_SocketCloseReadReceivedData();
    internal static string get_SessionValueInvalid();
    internal static string get_SocketAbortedReceiveTimedOut();
    internal static string get_SocketAbortedSendTimedOut();
    internal static string get_OperationInvalidBeforeSecurityNegotiation();
    internal static string get_FramingError();
    internal static string get_FramingPrematureEOF();
    internal static string get_FramingRecordTypeMismatch();
    internal static string get_FramingVersionNotSupported();
    internal static string get_FramingModeNotSupported();
    internal static string get_FramingSizeTooLarge();
    internal static string get_FramingViaTooLong();
    internal static string get_FramingViaNotUri();
    internal static string get_FramingFaultTooLong();
    internal static string get_FramingContentTypeTooLong();
    internal static string get_FramingValueNotAvailable();
    internal static string get_FramingAtEnd();
    internal static string get_BinaryEncoderSessionTooLarge();
    internal static string get_BinaryEncoderSessionInvalid();
    internal static string get_BinaryEncoderSessionMalformed();
    internal static string get_ReceiveShutdownReturnedFault();
    internal static string get_ReceiveShutdownReturnedLargeFault();
    internal static string get_ReceiveShutdownReturnedMessage();
    internal static string get_MaxReceivedMessageSizeExceeded();
    internal static string get_MaxSentMessageSizeExceeded();
    internal static string get_FramingMaxMessageSizeExceeded();
    internal static string get_StreamDoesNotSupportTimeout();
    internal static string get_AddressingVersionNotSupported();
    internal static string get_MessagePropertyReturnedNullCopy();
    internal static string get_MessageVersionUnknown();
    internal static string get_EnvelopeVersionUnknown();
    internal static string get_EnvelopeVersionNotSupported();
    internal static string get_CannotDetectAddressingVersion();
    internal static string get_HeadersCannotBeAddedToEnvelopeVersion();
    internal static string get_AddressingHeadersCannotBeAddedToAddressingVersion();
    internal static string get_AddressingExtensionInBadNS();
    internal static string get_MessageHeaderVersionNotSupported();
    internal static string get_MessageHasBeenCopied();
    internal static string get_MessageHasBeenWritten();
    internal static string get_MessageHasBeenRead();
    internal static string get_InvalidMessageState();
    internal static string get_MessageBodyReaderInvalidReadState();
    internal static string get_XmlBufferQuotaExceeded();
    internal static string get_XmlBufferInInvalidState();
    internal static string get_MessageBodyMissing();
    internal static string get_MessageHeaderVersionMismatch();
    internal static string get_ManualAddressingRequiresAddressedMessages();
    internal static string get_ReceiveTimedOut2();
    internal static string get_WaitForMessageTimedOut();
    internal static string get_SendToViaTimedOut();
    internal static string get_CloseTimedOut();
    internal static string get_OpenTimedOutEstablishingTransportSession();
    internal static string get_RequestTimedOutEstablishingTransportSession();
    internal static string get_TcpConnectingToViaTimedOut();
    internal static string get_RequestChannelSendTimedOut();
    internal static string get_RequestChannelWaitForReplyTimedOut();
    internal static string get_HttpProxyRequiresSingleAuthScheme();
    internal static string get_UseDefaultWebProxyCantBeUsedWithExplicitProxyAddress();
    internal static string get_ProxyImpersonationLevelMismatch();
    internal static string get_ProxyAuthenticationLevelMismatch();
    internal static string get_HttpIfModifiedSinceParseError();
    internal static string get_HttpSoapActionMismatch();
    internal static string get_HttpSoapActionMismatchContentType();
    internal static string get_HttpContentTypeFormatException();
    internal static string get_HttpServerTooBusy();
    internal static string get_HttpRequestTimedOut();
    internal static string get_HttpResponseTimedOut();
    internal static string get_HttpReceiveFailure();
    internal static string get_HttpAuthDoesNotSupportRequestStreaming();
    internal static string get_ReplyAlreadySent();
    internal static string get_RequestContextAborted();
    internal static string get_InnerChannelFactoryWasNotSet();
    internal static string get_PropertySettingErrorOnProtocolFactory();
    internal static string get_ProtocolFactoryCouldNotCreateProtocol();
    internal static string get_IdentityCheckFailedForOutgoingMessage();
    internal static string get_IdentityCheckFailedForIncomingMessage();
    internal static string get_DnsIdentityCheckFailedForIncomingMessageLackOfDnsClaim();
    internal static string get_DnsIdentityCheckFailedForOutgoingMessageLackOfDnsClaim();
    internal static string get_DnsIdentityCheckFailedForIncomingMessage();
    internal static string get_DnsIdentityCheckFailedForOutgoingMessage();
    internal static string get_ClientCertificateNotProvidedOnClientCredentials();
    internal static string get_UserNamePasswordNotProvidedOnClientCredentials();
    internal static string get_ObjectIsReadOnly();
    internal static string get_EmptyXmlElementError();
    internal static string get_UnexpectedXmlChildNode();
    internal static string get_InvalidQName();
    internal static string get_SuiteDoesNotAcceptAlgorithm();
    internal static string get_CannotFindCert();
    internal static string get_CannotFindCertForTarget();
    internal static string get_FoundMultipleCerts();
    internal static string get_FoundMultipleCertsForTarget();
    internal static string get_SigningTokenHasNoKeys();
    internal static string get_SigningTokenHasNoKeysSupportingTheAlgorithmSuite();
    internal static string get_EmptyBase64Attribute();
    internal static string get_CouldNotFindNamespaceForPrefix();
    internal static string get_ChildNodeTypeMissing();
    internal static string get_SPS_InvalidAsyncResult();
    internal static string get_NonceLengthTooShort();
    internal static string get_IncorrectBinaryNegotiationValueType();
    internal static string get_CreationTimeUtcIsAfterExpiryTime();
    internal static string get_CacheQuotaReached();
    internal static string get_UnrecognizedIdentityPropertyType();
    internal static string get_EndpointNotFound();
    internal static string get_MaxReceivedMessageSizeMustBeInIntegerRange();
    internal static string get_MaxBufferSizeMustMatchMaxReceivedMessageSize();
    internal static string get_MaxBufferSizeMustNotExceedMaxReceivedMessageSize();
    internal static string get_InValidateIdPrefix();
    internal static string get_InValidateId();
    internal static string get_UnexpectedHttpResponseCode();
    internal static string get_HttpContentLengthIncorrect();
    internal static string get_MissingContentType();
    internal static string get_DuplexChannelAbortedDuringOpen();
    internal static string get_OperationAbortedDuringConnectionEstablishment();
    internal static string get_HttpAddressingNoneHeaderOnWire();
    internal static string get_MessageXmlProtocolError();
    internal static string get_TcpConnectNoBufs();
    internal static string get_InsufficentMemory();
    internal static string get_TcpConnectError();
    internal static string get_TcpConnectErrorWithTimeSpan();
    internal static string get_TcpTransferError();
    internal static string get_TcpLocalConnectionAborted();
    internal static string get_TcpConnectionResetError();
    internal static string get_TcpConnectionTimedOut();
    internal static string get_SocketConnectionDisposed();
    internal static string get_HttpContentTypeHeaderRequired();
    internal static string get_ResponseContentTypeMismatch();
    internal static string get_HttpToMustEqualVia();
    internal static string get_FramingContentTypeMismatch();
    internal static string get_FramingFaultUnrecognized();
    internal static string get_FramingContentTypeTooLongFault();
    internal static string get_FramingViaTooLongFault();
    internal static string get_FramingModeNotSupportedFault();
    internal static string get_FramingVersionNotSupportedFault();
    internal static string get_FramingUpgradeInvalid();
    internal static string get_ServerTooBusy();
    internal static string get_PreambleAckIncorrect();
    internal static string get_PreambleAckIncorrectMaybeHttp();
    internal static string get_StreamError();
    internal static string get_ServerRejectedUpgradeRequest();
    internal static string get_ServerRejectedSessionPreamble();
    internal static string get_UnableToResolveHost();
    internal static string get_HttpRequiresSingleAuthScheme();
    internal static string get_HttpAuthSchemeCannotBeNone();
    internal static string get_HttpAuthorizationFailed();
    internal static string get_HttpAuthorizationForbidden();
    internal static string get_InvalidUriScheme();
    internal static string get_HttpsServerCertThumbprintMismatch();
    internal static string get_TrustFailure();
    internal static string get_StreamMutualAuthNotSatisfied();
    internal static string get_InvalidTokenProvided();
    internal static string get_NoUserNameTokenProvided();
    internal static string get_RemoteIdentityFailedVerification();
    internal static string get_CredentialDisallowsNtlm();
    internal static string get_UriGeneratorSchemeMustNotBeEmpty();
    internal static string get_UnsupportedSslProtectionLevel();
    internal static string get_TimeoutServiceChannelConcurrentOpen1();
    internal static string get_TimeoutServiceChannelConcurrentOpen2();
    internal static string get_TimeSpanMustbeGreaterThanTimeSpanZero();
    internal static string get_AsyncResultCompletedTwice();
    internal static string get_ValueMustBeNonNegative();
    internal static string get_ValueMustBePositive();
    internal static string get_ValueMustBeGreaterThanZero();
    internal static string get_ValueMustBeInRange();
    internal static string get_OffsetExceedsBufferSize();
    internal static string get_SizeExceedsRemainingBufferSpace();
    internal static string get_SpaceNeededExceedsMessageFrameOffset();
    internal static string get_FaultConverterDidNotCreateFaultMessage();
    internal static string get_FaultConverterCreatedFaultMessage();
    internal static string get_FaultConverterDidNotCreateException();
    internal static string get_FaultConverterCreatedException();
    internal static string get_UnsupportedUpgradeInitiator();
    internal static string get_StreamUpgradeUnsupportedChannelBindingKind();
    internal static string get_ExtendedProtectionNotSupported();
    internal static string get_HttpClientCredentialTypeInvalid();
    internal static string get_TransportDoesNotSupportCompression();
    internal static string get_UnsupportedSecuritySetting();
    internal static string get_UnsupportedBindingProperty();
    internal static string get_HttpMaxPendingAcceptsTooLargeError();
    internal static string get_UnsupportedTokenImpersonationLevel();
    internal static string get_TimeoutOnOpen();
    internal static string get_TimeoutOnRequest();
    internal static string get_SFxActionDemuxerDuplicate();
    internal static string get_SFXBindingNameCannotBeNullOrEmpty();
    internal static string get_SFXUnvalidNamespaceValue();
    internal static string get_SFXUnvalidNamespaceParam();
    internal static string get_SFXHeaderNameCannotBeNullOrEmpty();
    internal static string get_SFxBadByReferenceParameterMetadata();
    internal static string get_SFxBadByValueParameterMetadata();
    internal static string get_SFxBindingMustContainTransport2();
    internal static string get_SFxBodyCannotBeNull();
    internal static string get_SFxCallbackBehaviorAttributeOnlyOnDuplex();
    internal static string get_SFxCallbackRequestReplyInOrder1();
    internal static string get_SfxCallbackTypeCannotBeNull();
    internal static string get_SFxCannotActivateCallbackInstace();
    internal static string get_SFxCannotCallAutoOpenWhenExplicitOpenCalled();
    internal static string get_SFxCannotSetExtensionsByIndex();
    internal static string get_SFxChannelDispatcherNoMessageVersion();
    internal static string get_SFxChannelDispatcherUnableToOpen1();
    internal static string get_SFxChannelDispatcherUnableToOpen2();
    internal static string get_SFxChannelFactoryTypeMustBeInterface();
    internal static string get_SFxChannelFactoryCannotCreateFactoryWithoutDescription();
    internal static string get_SFxClientOutputSessionAutoClosed();
    internal static string get_SFxCollectionDoesNotSupportSet0();
    internal static string get_SFxCollectionReadOnly();
    internal static string get_SFxCollectionWrongType2();
    internal static string get_SFxContextModifiedInsideScope0();
    internal static string get_SFxContractDescriptionNameCannotBeEmpty();
    internal static string get_SFxContractHasZeroOperations();
    internal static string get_SFxContractHasZeroInitiatingOperations();
    internal static string get_SFxContractInheritanceRequiresInterfaces();
    internal static string get_SFxContractInheritanceRequiresInterfaces2();
    internal static string get_SFxCopyToRequiresICollection();
    internal static string get_SFxCreateDuplexChannel1();
    internal static string get_SFxCreateDuplexChannelNoCallback();
    internal static string get_SFxCreateDuplexChannelNoCallback1();
    internal static string get_SFxCreateDuplexChannelNoCallbackUserObject();
    internal static string get_SFxCreateDuplexChannelBadCallbackUserObject();
    internal static string get_SFxCreateNonDuplexChannel1();
    internal static string get_SFxCustomBindingNeedsTransport1();
    internal static string get_SFxDeserializationFailed1();
    internal static string get_SFxDisallowedAttributeCombination();
    internal static string get_SFxInitializationUINotCalled();
    internal static string get_SFxInitializationUIDisallowed();
    internal static string get_SFxDocEncodedNotSupported();
    internal static string get_SFxDuplicateMessageParts();
    internal static string get_SFXEndpointBehaviorUsedOnWrongSide();
    internal static string get_SFxEndpointDispatcherMultipleChannelDispatcher0();
    internal static string get_SFxEndpointDispatcherDifferentChannelDispatcher0();
    internal static string get_SFxErrorDeserializingRequestBody();
    internal static string get_SFxErrorDeserializingRequestBodyMore();
    internal static string get_SFxErrorDeserializingReplyBody();
    internal static string get_SFxErrorDeserializingReplyBodyMore();
    internal static string get_SFxErrorSerializingBody();
    internal static string get_SFxErrorDeserializingHeader();
    internal static string get_SFxErrorSerializingHeader();
    internal static string get_SFxErrorDeserializingFault();
    internal static string get_SFxErrorReflectingOnType2();
    internal static string get_SFxErrorReflectingOnMethod3();
    internal static string get_SFxErrorReflectingOnParameter4();
    internal static string get_SFxErrorReflectionOnUnknown1();
    internal static string get_SFxExceptionDetailEndOfInner();
    internal static string get_SFxExceptionDetailFormat();
    internal static string get_SFxFaultContractDuplicateDetailType();
    internal static string get_SFxFaultContractDuplicateElement();
    internal static string get_SFxFaultExceptionToString3();
    internal static string get_SFxFaultReason();
    internal static string get_SFxFaultTypeAnonymous();
    internal static string get_SFxHeaderNameMismatchInMessageContract();
    internal static string get_SFxHeaderNameMismatchInOperation();
    internal static string get_SFxHeaderNamespaceMismatchInMessageContract();
    internal static string get_SFxHeaderNamespaceMismatchInOperation();
    internal static string get_SFxHeaderNotUnderstood();
    internal static string get_SFxImmutableServiceHostBehavior0();
    internal static string get_SFxImmutableChannelFactoryBehavior0();
    internal static string get_SFxInputParametersToServiceInvalid();
    internal static string get_SFxInputParametersToServiceNull();
    internal static string get_SFxInstanceNotInitialized();
    internal static string get_SFxInterleavedContextScopes0();
    internal static string get_SFxInternalServerError();
    internal static string get_SFxInternalCallbackError();
    internal static string get_SFxInvalidAsyncResultState0();
    internal static string get_SFxInvalidCallbackIAsyncResult();
    internal static string get_SFxInvalidCallbackContractType();
    internal static string get_SFxInvalidChannelToOperationContext();
    internal static string get_SFxInvalidMessageBody();
    internal static string get_SFxInvalidMessageBodyEmptyMessage();
    internal static string get_SFxInvalidMessageBodyErrorSerializingParameter();
    internal static string get_SFxInvalidMessageBodyErrorDeserializingParameter();
    internal static string get_SFxInvalidMessageBodyErrorDeserializingParameterMore();
    internal static string get_SFxInvalidMessageContractSignature();
    internal static string get_SFxInvalidMessageHeaderArrayType();
    internal static string get_SFxInvalidRequestAction();
    internal static string get_SFxInvalidReplyAction();
    internal static string get_SFxInvalidStreamInTypedMessage();
    internal static string get_SFxInvalidStreamInRequest();
    internal static string get_SFxInvalidStreamInResponse();
    internal static string get_SFxInvalidStreamOffsetLength();
    internal static string get_SFxInvalidUseOfPrimitiveOperationFormatter();
    internal static string get_SFxInvalidStaticOverloadCalledForDuplexChannelFactory1();
    internal static string get_SFxInvalidXmlAttributeInBare();
    internal static string get_SFxInvalidXmlAttributeInWrapped();
    internal static string get_SFxKnownTypeAttributeInvalid1();
    internal static string get_SFxKnownTypeAttributeReturnType3();
    internal static string get_SFxKnownTypeAttributeUnknownMethod3();
    internal static string get_SFxKnownTypeNull();
    internal static string get_SFxMessageContractBaseTypeNotValid();
    internal static string get_SFxMessageContractRequiresDefaultConstructor();
    internal static string get_SFxMetadataReferenceInvalidLocation();
    internal static string get_SFxMethodNotSupported1();
    internal static string get_SFxMethodNotSupportedOnCallback1();
    internal static string get_SFxMismatchedOperationParent();
    internal static string get_SFxMissingActionHeader();
    internal static string get_SFxMultipleCallbackFromSynchronizationContext();
    internal static string get_SFxMultipleCallbackFromAsyncOperation();
    internal static string get_SFxMultipleUnknownHeaders();
    internal static string get_SFxMultipleContractStarOperations0();
    internal static string get_SFxNameCannotBeEmpty();
    internal static string get_SFxConfigurationNameCannotBeEmpty();
    internal static string get_SFxNeedProxyBehaviorOperationSelector2();
    internal static string get_SFxNoDefaultConstructor();
    internal static string get_SFxNoMostDerivedContract();
    internal static string get_SFxNullReplyFromFormatter2();
    internal static string get_SFxServiceChannelIdleAborted();
    internal static string get_SFxSetEnableFaultsOnChannelDispatcher0();
    internal static string get_SFxSetManualAddresssingOnChannelDispatcher0();
    internal static string get_SFxNoServiceObject();
    internal static string get_SFxNonExceptionThrown();
    internal static string get_SFxNonInitiatingOperation1();
    internal static string get_SFxOneWayMessageToTwoWayMethod0();
    internal static string get_SFxOperationContractOnNonServiceContract();
    internal static string get_SFxOperationContractProviderOnNonServiceContract();
    internal static string get_SFxOperationDescriptionNameCannotBeEmpty();
    internal static string get_SFxParameterNameCannotBeNull();
    internal static string get_SFxOperationMustHaveOneOrTwoMessages();
    internal static string get_SFxParameterCountMismatch();
    internal static string get_SFxParameterMustBeMessage();
    internal static string get_SFxParametersMustBeEmpty();
    internal static string get_SFxParameterMustBeArrayOfOneElement();
    internal static string get_SFxRequestHasInvalidReplyToOnClient();
    internal static string get_SFxRequestHasInvalidFaultToOnClient();
    internal static string get_SFxRequestReplyNone();
    internal static string get_SFxRequestTimedOut1();
    internal static string get_SFxRequestTimedOut2();
    internal static string get_SFxReplyActionMismatch3();
    internal static string get_SFxResultMustBeMessage();
    internal static string get_SFxRpcMessageBodyPartNameInvalid();
    internal static string get_SFxServerDidNotReply();
    internal static string get_SFxStaticMessageHeaderPropertiesNotAllowed();
    internal static string get_SFxStreamIOException();
    internal static string get_SFxStreamRequestMessageClosed();
    internal static string get_SFxStreamResponseMessageClosed();
    internal static string get_SFxTimeoutOutOfRange0();
    internal static string get_SFxTimeoutOutOfRangeTooBig();
    internal static string get_SFxTypedMessageCannotBeNull();
    internal static string get_SFxTypedMessageCannotBeRpcLiteral();
    internal static string get_SFxTypedOrUntypedMessageCannotBeMixedWithParameters();
    internal static string get_SFxTypedOrUntypedMessageCannotBeMixedWithVoidInRpc();
    internal static string get_SFxUnknownFaultNoMatchingTranslation1();
    internal static string get_SFxUnknownFaultNullReason0();
    internal static string get_SFxUnknownFaultZeroReasons0();
    internal static string get_SFxVersionMismatchInOperationContextAndMessage2();
    internal static string get_SFxWrapperNameCannotBeEmpty();
    internal static string get_SFxXmlArrayNotAllowedForMultiple();
    internal static string get_SFxXmlSerializerIsNotFound();
    internal static string get_SFxChannelFactoryEndpointAddressUri();
    internal static string get_SFxCloseTimedOut1();
    internal static string get_SfxCloseTimedOutWaitingForDispatchToComplete();
    internal static string get_SFxChannelFactoryNoBindingFoundInConfig1();
    internal static string get_SFxChannelFactoryNoBindingFoundInConfigOrCode();
    internal static string get_SFxProxyRuntimeMessageCannotBeNull();
    internal static string get_SFxDispatchRuntimeMessageCannotBeNull();
    internal static string get_SFxMessagePartDescriptionMissingType();
    internal static string get_AChannelServiceEndpointSBindingIsNull0();
    internal static string get_AChannelServiceEndpointSContractIsNull0();
    internal static string get_AChannelServiceEndpointSContractSNameIsNull0();
    internal static string get_AChannelServiceEndpointSContractSNamespace0();
    internal static string get_SFxNoEndpointMatchingContract();
    internal static string get_SFxNoEndpointMatchingAddress();
    internal static string get_SFxNoEndpointMatchingAddressForConnectionOpeningMessage();
    internal static string get_SFxServiceChannelCannotBeCalledBecauseIsSessionOpenNotificationEnabled();
    internal static string get_EndMethodsCannotBeDecoratedWithOperationContractAttribute();
    internal static string get_DispatchRuntimeRequiresFormatter0();
    internal static string get_ClientRuntimeRequiresFormatter0();
    internal static string get_RuntimeRequiresInvoker0();
    internal static string get_CouldnTCreateChannelForType2();
    internal static string get_CouldnTCreateChannelForChannelType2();
    internal static string get_EndpointListenerRequirementsCannotBeMetBy3();
    internal static string get_UnknownListenerType1();
    internal static string get_BindingDoesnTSupportSessionButContractRequires1();
    internal static string get_BindingDoesntSupportDatagramButContractRequires();
    internal static string get_BindingDoesnTSupportOneWayButContractRequires1();
    internal static string get_BindingDoesnTSupportTwoWayButContractRequires1();
    internal static string get_BindingDoesnTSupportRequestReplyButContract1();
    internal static string get_BindingDoesnTSupportDuplexButContractRequires1();
    internal static string get_BindingDoesnTSupportAnyChannelTypes1();
    internal static string get_ContractIsNotSelfConsistentItHasOneOrMore2();
    internal static string get_ContractIsNotSelfConsistentWhenIsSessionOpenNotificationEnabled();
    internal static string get_SynchronizedCollectionWrongType1();
    internal static string get_SynchronizedCollectionWrongTypeNull();
    internal static string get_CannotAddTwoItemsWithTheSameKeyToSynchronizedKeyedCollection0();
    internal static string get_ItemDoesNotExistInSynchronizedKeyedCollection0();
    internal static string get_SuppliedMessageIsNotAReplyItHasNoRelatesTo0();
    internal static string get_channelIsNotAvailable0();
    internal static string get_channelDoesNotHaveADuplexSession0();
    internal static string get_UnsupportedEnvelopeVersion();
    internal static string get_ServicesWithoutAServiceContractAttributeCan2();
    internal static string get_tooManyAttributesOfTypeOn2();
    internal static string get_couldnTFindRequiredAttributeOfTypeOn2();
    internal static string get_AttemptedToGetContractTypeForButThatTypeIs1();
    internal static string get_NoEndMethodFoundForAsyncBeginMethod3();
    internal static string get_MoreThanOneEndMethodFoundForAsyncBeginMethod3();
    internal static string get_InvalidAsyncEndMethodSignatureForMethod2();
    internal static string get_InvalidAsyncBeginMethodSignatureForMethod2();
    internal static string get_InAContractInheritanceHierarchyIfParentHasCallbackChildMustToo();
    internal static string get_InAContractInheritanceHierarchyTheServiceContract3_2();
    internal static string get_CannotHaveTwoOperationsWithTheSameName3();
    internal static string get_CannotInheritTwoOperationsWithTheSameName3();
    internal static string get_SyncAsyncMatchConsistency_Parameters5();
    internal static string get_SyncTaskMatchConsistency_Parameters5();
    internal static string get_TaskAsyncMatchConsistency_Parameters5();
    internal static string get_SyncAsyncMatchConsistency_ReturnType5();
    internal static string get_SyncTaskMatchConsistency_ReturnType5();
    internal static string get_TaskAsyncMatchConsistency_ReturnType5();
    internal static string get_SyncAsyncMatchConsistency_Attributes6();
    internal static string get_SyncTaskMatchConsistency_Attributes6();
    internal static string get_TaskAsyncMatchConsistency_Attributes6();
    internal static string get_SyncAsyncMatchConsistency_Property6();
    internal static string get_SyncTaskMatchConsistency_Property6();
    internal static string get_TaskAsyncMatchConsistency_Property6();
    internal static string get_ServiceOperationsMarkedWithIsOneWayTrueMust0();
    internal static string get_OneWayOperationShouldNotSpecifyAReplyAction1();
    internal static string get_OneWayAndFaultsIncompatible2();
    internal static string get_AsyncEndCalledOnWrongChannel();
    internal static string get_AsyncEndCalledWithAnIAsyncResult();
    internal static string get_MessageHeaderIsNull0();
    internal static string get_MessagePropertiesArraySize0();
    internal static string get_DuplicateBehavior1();
    internal static string get_CantCreateChannelWithManualAddressing();
    internal static string get_XDCannotFindValueInDictionaryString();
    internal static string get_NoChannelBuilderAvailable();
    internal static string get_InvalidBindingScheme();
    internal static string get_CustomBindingRequiresTransport();
    internal static string get_TransportBindingElementMustBeLast();
    internal static string get_MessageVersionMissingFromBinding();
    internal static string get_NotAllBindingElementsBuilt();
    internal static string get_MultipleMebesInParameters();
    internal static string get_MultipleStreamUpgradeProvidersInParameters();
    internal static string get_SecurityCapabilitiesMismatched();
    internal static string get_BaseAddressMustBeAbsolute();
    internal static string get_BaseAddressDuplicateScheme();
    internal static string get_BaseAddressCannotHaveUserInfo();
    internal static string get_BaseAddressCannotHaveQuery();
    internal static string get_BaseAddressCannotHaveFragment();
    internal static string get_UriMustBeAbsolute();
    internal static string get_ClaimTypeCannotBeEmpty();
    internal static string get_MissingCustomCertificateValidator();
    internal static string get_SecurityAuditPlatformNotSupported();
    internal static string get_ActivityCallback();
    internal static string get_ActivityClose();
    internal static string get_ActivityConstructChannelFactory();
    internal static string get_ActivityExecuteMethod();
    internal static string get_ActivityCloseClientBase();
    internal static string get_ActivityOpenClientBase();
    internal static string get_ActivityProcessAction();
    internal static string get_ActivityProcessingMessage();
    internal static string get_TraceCodeConnectionPoolIdleTimeoutReached();
    internal static string get_TraceCodeConnectionPoolLeaseTimeoutReached();
    internal static string get_TraceCodeConnectionPoolMaxOutboundConnectionsPerEndpointQuotaReached();
    internal static string get_InputTypeListEmptyError();
    internal static string get_DelegatingHandlerArrayHasNonNullInnerHandler();
    internal static string get_DelegatingHandlerArrayFromFuncContainsNullItem();
    internal static string get_HttpMessageHandlerTypeNotSupported();
    internal static string get_HttpPipelineNotSupportedOnClientSide();
    internal static string get_WebSocketInvalidProtocolInvalidCharInProtocolString();
    internal static string get_WebSocketInvalidProtocolContainsMultipleSubProtocolString();
    internal static string get_WebSocketInvalidProtocolEmptySubprotocolString();
    internal static string get_WebSocketUnexpectedCloseMessageError();
    internal static string get_WebSocketStreamWriteCalledAfterEOMSent();
    internal static string get_WebSocketCannotCreateRequestClientChannelWithCertainWebSocketTransportUsage();
    internal static string get_ClientWebSocketFactory_CreateWebSocketFailed();
    internal static string get_ClientWebSocketFactory_InvalidWebSocket();
    internal static string get_ClientWebSocketFactory_InvalidSubProtocol();
    internal static string get_WebSocketSendTimedOut();
    internal static string get_WebSocketReceiveTimedOut();
    internal static string get_WebSocketOperationTimedOut();
    internal static string get_WebSocketVersionMismatchFromServer();
    internal static string get_WebSocketSubProtocolMismatchFromServer();
    internal static string get_CopyHttpHeaderFailed();
    internal static string get_XmlInvalidConversion();
    internal static string get_XmlInvalidStream();
    internal static string get_LockTimeoutExceptionMessage();
    internal static string get_InvalidEnumArgument();
    internal static string get_InvalidTypedProxyMethodHandle();
    internal static string get_FailedToCreateTypedProxy();
    internal static string get_SecurityTokenRequirementDoesNotContainProperty();
    internal static string get_SecurityTokenRequirementHasInvalidTypeForProperty();
    internal static string get_TokenCancellationNotSupported();
    internal static string get_TokenProviderUnableToGetToken();
    internal static string get_TokenProviderUnableToRenewToken();
    internal static string get_TokenRenewalNotSupported();
    internal static string get_UserNameCannotBeEmpty();
    internal static string get_ActivityBoundary();
    internal static string get_StringNullOrEmpty();
    internal static string get_GenericCallbackException();
    internal static string get_ArgumentCannotBeEmptyString();
    internal static string get_KeyIdentifierClauseDoesNotSupportKeyCreation();
    internal static string get_SymmetricKeyLengthTooShort();
    internal static string get_KeyIdentifierCannotCreateKey();
    internal static string get_NoKeyIdentifierClauseFound();
    internal static string get_LocalIdCannotBeEmpty();
    internal static string get_CannotValidateSecurityTokenType();
    internal static string get_UnauthorizedAccess_MemStreamBuffer();
    internal static string get_ConfigurationFilesNotSupported();
    internal static string get_X509ChainBuildFail();
    internal static string get_ImpersonationLevelNotSupported();
    internal static string get_ProvidedNetworkCredentialsForKerberosHasInvalidUserName();
    internal static string get_SSLProtocolNegotiationFailed();
    internal static string get_ssl_io_cert_validation();
    internal static string get_X509InvalidUsageTime();
    internal static string get_X509IsInUntrustedStore();
    internal static string get_X509IsNotInTrustedStore();
    internal static string get_Xml_InvalidNodeType();
    internal static string get_SFxRpcMessageMustHaveASingleBody();
    internal static string get_SFxBodyObjectTypeCannotBeInherited();
    internal static string get_SFxBodyObjectTypeCannotBeInterface();
    internal static string get_SFxHeadersAreNotSupportedInEncoded();
    internal static string get_SFxMultiplePartsNotAllowedInEncoded();
    internal static string get_SFxInvalidSoapAttribute();
    internal static string get_SFxTerminatingOperationAlreadyCalled1();
    internal static string get_SFxChannelTerminated0();
    internal static string get_PeerTrustNotSupportedOnOSX();
    internal static Type get_ResourceType();
}
internal enum System.Xml.XmlBinaryNodeType : Enum {
    public int value__;
    public static XmlBinaryNodeType EndElement;
    public static XmlBinaryNodeType Comment;
    public static XmlBinaryNodeType Array;
    public static XmlBinaryNodeType MinAttribute;
    public static XmlBinaryNodeType ShortAttribute;
    public static XmlBinaryNodeType Attribute;
    public static XmlBinaryNodeType ShortDictionaryAttribute;
    public static XmlBinaryNodeType DictionaryAttribute;
    public static XmlBinaryNodeType ShortXmlnsAttribute;
    public static XmlBinaryNodeType XmlnsAttribute;
    public static XmlBinaryNodeType ShortDictionaryXmlnsAttribute;
    public static XmlBinaryNodeType DictionaryXmlnsAttribute;
    public static XmlBinaryNodeType PrefixDictionaryAttributeA;
    public static XmlBinaryNodeType PrefixDictionaryAttributeB;
    public static XmlBinaryNodeType PrefixDictionaryAttributeC;
    public static XmlBinaryNodeType PrefixDictionaryAttributeD;
    public static XmlBinaryNodeType PrefixDictionaryAttributeE;
    public static XmlBinaryNodeType PrefixDictionaryAttributeF;
    public static XmlBinaryNodeType PrefixDictionaryAttributeG;
    public static XmlBinaryNodeType PrefixDictionaryAttributeH;
    public static XmlBinaryNodeType PrefixDictionaryAttributeI;
    public static XmlBinaryNodeType PrefixDictionaryAttributeJ;
    public static XmlBinaryNodeType PrefixDictionaryAttributeK;
    public static XmlBinaryNodeType PrefixDictionaryAttributeL;
    public static XmlBinaryNodeType PrefixDictionaryAttributeM;
    public static XmlBinaryNodeType PrefixDictionaryAttributeN;
    public static XmlBinaryNodeType PrefixDictionaryAttributeO;
    public static XmlBinaryNodeType PrefixDictionaryAttributeP;
    public static XmlBinaryNodeType PrefixDictionaryAttributeQ;
    public static XmlBinaryNodeType PrefixDictionaryAttributeR;
    public static XmlBinaryNodeType PrefixDictionaryAttributeS;
    public static XmlBinaryNodeType PrefixDictionaryAttributeT;
    public static XmlBinaryNodeType PrefixDictionaryAttributeU;
    public static XmlBinaryNodeType PrefixDictionaryAttributeV;
    public static XmlBinaryNodeType PrefixDictionaryAttributeW;
    public static XmlBinaryNodeType PrefixDictionaryAttributeX;
    public static XmlBinaryNodeType PrefixDictionaryAttributeY;
    public static XmlBinaryNodeType PrefixDictionaryAttributeZ;
    public static XmlBinaryNodeType PrefixAttributeA;
    public static XmlBinaryNodeType PrefixAttributeB;
    public static XmlBinaryNodeType PrefixAttributeC;
    public static XmlBinaryNodeType PrefixAttributeD;
    public static XmlBinaryNodeType PrefixAttributeE;
    public static XmlBinaryNodeType PrefixAttributeF;
    public static XmlBinaryNodeType PrefixAttributeG;
    public static XmlBinaryNodeType PrefixAttributeH;
    public static XmlBinaryNodeType PrefixAttributeI;
    public static XmlBinaryNodeType PrefixAttributeJ;
    public static XmlBinaryNodeType PrefixAttributeK;
    public static XmlBinaryNodeType PrefixAttributeL;
    public static XmlBinaryNodeType PrefixAttributeM;
    public static XmlBinaryNodeType PrefixAttributeN;
    public static XmlBinaryNodeType PrefixAttributeO;
    public static XmlBinaryNodeType PrefixAttributeP;
    public static XmlBinaryNodeType PrefixAttributeQ;
    public static XmlBinaryNodeType PrefixAttributeR;
    public static XmlBinaryNodeType PrefixAttributeS;
    public static XmlBinaryNodeType PrefixAttributeT;
    public static XmlBinaryNodeType PrefixAttributeU;
    public static XmlBinaryNodeType PrefixAttributeV;
    public static XmlBinaryNodeType PrefixAttributeW;
    public static XmlBinaryNodeType PrefixAttributeX;
    public static XmlBinaryNodeType PrefixAttributeY;
    public static XmlBinaryNodeType PrefixAttributeZ;
    public static XmlBinaryNodeType MaxAttribute;
    public static XmlBinaryNodeType MinElement;
    public static XmlBinaryNodeType ShortElement;
    public static XmlBinaryNodeType Element;
    public static XmlBinaryNodeType ShortDictionaryElement;
    public static XmlBinaryNodeType DictionaryElement;
    public static XmlBinaryNodeType PrefixDictionaryElementA;
    public static XmlBinaryNodeType PrefixDictionaryElementB;
    public static XmlBinaryNodeType PrefixDictionaryElementC;
    public static XmlBinaryNodeType PrefixDictionaryElementD;
    public static XmlBinaryNodeType PrefixDictionaryElementE;
    public static XmlBinaryNodeType PrefixDictionaryElementF;
    public static XmlBinaryNodeType PrefixDictionaryElementG;
    public static XmlBinaryNodeType PrefixDictionaryElementH;
    public static XmlBinaryNodeType PrefixDictionaryElementI;
    public static XmlBinaryNodeType PrefixDictionaryElementJ;
    public static XmlBinaryNodeType PrefixDictionaryElementK;
    public static XmlBinaryNodeType PrefixDictionaryElementL;
    public static XmlBinaryNodeType PrefixDictionaryElementM;
    public static XmlBinaryNodeType PrefixDictionaryElementN;
    public static XmlBinaryNodeType PrefixDictionaryElementO;
    public static XmlBinaryNodeType PrefixDictionaryElementP;
    public static XmlBinaryNodeType PrefixDictionaryElementQ;
    public static XmlBinaryNodeType PrefixDictionaryElementR;
    public static XmlBinaryNodeType PrefixDictionaryElementS;
    public static XmlBinaryNodeType PrefixDictionaryElementT;
    public static XmlBinaryNodeType PrefixDictionaryElementU;
    public static XmlBinaryNodeType PrefixDictionaryElementV;
    public static XmlBinaryNodeType PrefixDictionaryElementW;
    public static XmlBinaryNodeType PrefixDictionaryElementX;
    public static XmlBinaryNodeType PrefixDictionaryElementY;
    public static XmlBinaryNodeType PrefixDictionaryElementZ;
    public static XmlBinaryNodeType PrefixElementA;
    public static XmlBinaryNodeType PrefixElementB;
    public static XmlBinaryNodeType PrefixElementC;
    public static XmlBinaryNodeType PrefixElementD;
    public static XmlBinaryNodeType PrefixElementE;
    public static XmlBinaryNodeType PrefixElementF;
    public static XmlBinaryNodeType PrefixElementG;
    public static XmlBinaryNodeType PrefixElementH;
    public static XmlBinaryNodeType PrefixElementI;
    public static XmlBinaryNodeType PrefixElementJ;
    public static XmlBinaryNodeType PrefixElementK;
    public static XmlBinaryNodeType PrefixElementL;
    public static XmlBinaryNodeType PrefixElementM;
    public static XmlBinaryNodeType PrefixElementN;
    public static XmlBinaryNodeType PrefixElementO;
    public static XmlBinaryNodeType PrefixElementP;
    public static XmlBinaryNodeType PrefixElementQ;
    public static XmlBinaryNodeType PrefixElementR;
    public static XmlBinaryNodeType PrefixElementS;
    public static XmlBinaryNodeType PrefixElementT;
    public static XmlBinaryNodeType PrefixElementU;
    public static XmlBinaryNodeType PrefixElementV;
    public static XmlBinaryNodeType PrefixElementW;
    public static XmlBinaryNodeType PrefixElementX;
    public static XmlBinaryNodeType PrefixElementY;
    public static XmlBinaryNodeType PrefixElementZ;
    public static XmlBinaryNodeType MaxElement;
    public static XmlBinaryNodeType MinText;
    public static XmlBinaryNodeType ZeroText;
    public static XmlBinaryNodeType OneText;
    public static XmlBinaryNodeType FalseText;
    public static XmlBinaryNodeType TrueText;
    public static XmlBinaryNodeType Int8Text;
    public static XmlBinaryNodeType Int16Text;
    public static XmlBinaryNodeType Int32Text;
    public static XmlBinaryNodeType Int64Text;
    public static XmlBinaryNodeType FloatText;
    public static XmlBinaryNodeType DoubleText;
    public static XmlBinaryNodeType DecimalText;
    public static XmlBinaryNodeType DateTimeText;
    public static XmlBinaryNodeType Chars8Text;
    public static XmlBinaryNodeType Chars16Text;
    public static XmlBinaryNodeType Chars32Text;
    public static XmlBinaryNodeType Bytes8Text;
    public static XmlBinaryNodeType Bytes16Text;
    public static XmlBinaryNodeType Bytes32Text;
    public static XmlBinaryNodeType StartListText;
    public static XmlBinaryNodeType EndListText;
    public static XmlBinaryNodeType EmptyText;
    public static XmlBinaryNodeType DictionaryText;
    public static XmlBinaryNodeType UniqueIdText;
    public static XmlBinaryNodeType TimeSpanText;
    public static XmlBinaryNodeType GuidText;
    public static XmlBinaryNodeType UInt64Text;
    public static XmlBinaryNodeType BoolText;
    public static XmlBinaryNodeType UnicodeChars8Text;
    public static XmlBinaryNodeType UnicodeChars16Text;
    public static XmlBinaryNodeType UnicodeChars32Text;
    public static XmlBinaryNodeType QNameDictionaryText;
    public static XmlBinaryNodeType ZeroTextWithEndElement;
    public static XmlBinaryNodeType OneTextWithEndElement;
    public static XmlBinaryNodeType FalseTextWithEndElement;
    public static XmlBinaryNodeType TrueTextWithEndElement;
    public static XmlBinaryNodeType Int8TextWithEndElement;
    public static XmlBinaryNodeType Int16TextWithEndElement;
    public static XmlBinaryNodeType Int32TextWithEndElement;
    public static XmlBinaryNodeType Int64TextWithEndElement;
    public static XmlBinaryNodeType FloatTextWithEndElement;
    public static XmlBinaryNodeType DoubleTextWithEndElement;
    public static XmlBinaryNodeType DecimalTextWithEndElement;
    public static XmlBinaryNodeType DateTimeTextWithEndElement;
    public static XmlBinaryNodeType Chars8TextWithEndElement;
    public static XmlBinaryNodeType Chars16TextWithEndElement;
    public static XmlBinaryNodeType Chars32TextWithEndElement;
    public static XmlBinaryNodeType Bytes8TextWithEndElement;
    public static XmlBinaryNodeType Bytes16TextWithEndElement;
    public static XmlBinaryNodeType Bytes32TextWithEndElement;
    public static XmlBinaryNodeType StartListTextWithEndElement;
    public static XmlBinaryNodeType EndListTextWithEndElement;
    public static XmlBinaryNodeType EmptyTextWithEndElement;
    public static XmlBinaryNodeType DictionaryTextWithEndElement;
    public static XmlBinaryNodeType UniqueIdTextWithEndElement;
    public static XmlBinaryNodeType TimeSpanTextWithEndElement;
    public static XmlBinaryNodeType GuidTextWithEndElement;
    public static XmlBinaryNodeType UInt64TextWithEndElement;
    public static XmlBinaryNodeType BoolTextWithEndElement;
    public static XmlBinaryNodeType UnicodeChars8TextWithEndElement;
    public static XmlBinaryNodeType UnicodeChars16TextWithEndElement;
    public static XmlBinaryNodeType UnicodeChars32TextWithEndElement;
    public static XmlBinaryNodeType QNameDictionaryTextWithEndElement;
    public static XmlBinaryNodeType MaxText;
}
