public class AssertTrafficException : Exception {
    protected AssertTrafficException(SerializationInfo info, StreamingContext context);
    public AssertTrafficException(string message);
    internal static bool VersionSafeIs(object instance);
}
public class DotMemoryUnitException : Exception {
    [CompilerGeneratedAttribute]
private Exception <PreservedException>k__BackingField;
    internal Exception PreservedException { get; private set; }
    protected DotMemoryUnitException(SerializationInfo info, StreamingContext context);
    public DotMemoryUnitException(string message);
    public DotMemoryUnitException(Exception innerException);
    public DotMemoryUnitException(string message, Exception innerException);
    internal DotMemoryUnitException(string message, Exception formatException, Exception preserveException);
    [CompilerGeneratedAttribute]
internal Exception get_PreservedException();
    [CompilerGeneratedAttribute]
private void set_PreservedException(Exception value);
    private static string FormatMessage(Exception innerException);
    private static string FormatMessage(string message, Exception innerException);
    private static void AppendInnerExceptions(Exception innerException, StringBuilder sb);
}
public class JetBrains.dotMemoryUnit.AssemblyIdentity : object {
}
[AttributeUsageAttribute("64")]
[DataContractAttribute]
public class JetBrains.dotMemoryUnit.AssertTrafficAttribute : Attribute {
    [DataMemberAttribute]
private Nullable`1<long> myAllocatedSizeInBytes;
    [DataMemberAttribute]
private Nullable`1<int> myAllocatedObjectCount;
    [DataMemberAttribute]
private Query myTrafficQuery;
    private String[] myNamespaces;
    private Type[] myTypes;
    private Type[] myInterfaces;
    public bool Valid { get; }
    public long AllocatedSizeInBytes { get; public set; }
    public int AllocatedObjectsCount { get; public set; }
    public Type[] Types { get; public set; }
    public Type[] Interfaces { get; public set; }
    public String[] Namespaces { get; public set; }
    public String[] TypeNames { get; }
    public String[] InterfaceNames { get; }
    public bool get_Valid();
    public long get_AllocatedSizeInBytes();
    public void set_AllocatedSizeInBytes(long value);
    public int get_AllocatedObjectsCount();
    public void set_AllocatedObjectsCount(int value);
    public Type[] get_Types();
    public void set_Types(Type[] value);
    public Type[] get_Interfaces();
    public void set_Interfaces(Type[] value);
    public String[] get_Namespaces();
    public void set_Namespaces(String[] value);
    public String[] get_TypeNames();
    public String[] get_InterfaceNames();
    private String[] GetQueryArguments(Predicate`1<ExpressionType> predicate);
    private Query ReCreateQuery();
    public Traffic CreateQuery(int from, int to);
    [CompilerGeneratedAttribute]
private Query <CreateQuery>b__29_0(TrafficProperty _);
}
[DataContractAttribute]
internal class JetBrains.dotMemoryUnit.ByTypeGrouping.MemoryInfoGroupedByType : object {
    [DataMemberAttribute]
private MemoryInfo myTotalMemoryInfo;
    [DataMemberAttribute]
private ChunkArray myMemoryInfoByTypes;
    [DataMemberAttribute]
private ChunkArray myTypesInfo;
    public MemoryInfo TotalMemoryInfo { get; }
    public ChunkArray MemoryInfoByTypes { get; }
    public ChunkArray TypesInfo { get; }
    internal MemoryInfoGroupedByType(MemoryInfo totalMemoryInfo, ChunkArray memoryInfoByTypes, ChunkArray typesInfo);
    public MemoryInfo get_TotalMemoryInfo();
    public ChunkArray get_MemoryInfoByTypes();
    public ChunkArray get_TypesInfo();
}
[DataContractAttribute]
internal class JetBrains.dotMemoryUnit.ByTypeGrouping.TrafficInfoGroupedByType : object {
    [DataMemberAttribute]
private TrafficInfo myTotalTrafficInfo;
    [DataMemberAttribute]
private ChunkArray myTrafficInfoByTypes;
    [DataMemberAttribute]
private ChunkArray myTypesInfo;
    public TrafficInfo TotalTrafficInfo { get; }
    public ChunkArray TrafficInfoByTypes { get; }
    public ChunkArray TypesInfo { get; }
    internal TrafficInfoGroupedByType(TrafficInfo totalTrafficInfo, ChunkArray trafficInfoByTypes, ChunkArray typesInfo);
    public TrafficInfo get_TotalTrafficInfo();
    public ChunkArray get_TrafficInfoByTypes();
    public ChunkArray get_TypesInfo();
}
[DataContractAttribute]
internal class JetBrains.dotMemoryUnit.ByTypeGrouping.TypeInfo : ValueType {
    [DataMemberAttribute]
private Guid myModuleVersionId;
    [DataMemberAttribute]
private string myFullName;
    [DataMemberAttribute]
private Int32[] myGenericArguments;
    [DataMemberAttribute]
private Int32[] myArrayRanks;
    public Guid ModuleVersionId { get; }
    public string FullName { get; }
    public Int32[] GenericArguments { get; }
    public Int32[] ArrayRanks { get; }
    public TypeInfo(Guid moduleVersionId, string fullName, Int32[] genericArguments, Int32[] arrayRanks);
    public Guid get_ModuleVersionId();
    public string get_FullName();
    public Int32[] get_GenericArguments();
    public Int32[] get_ArrayRanks();
    public virtual string ToString();
}
internal static class JetBrains.dotMemoryUnit.ByTypeGrouping.TypeRestorer : object {
    private static char GenericOpenBrace;
    private static char GenericCloseBrace;
    private static char GenericArgumentsSeparator;
    private static char ArrayOpenBrace;
    private static char ArrayCloseBrace;
    private static char ArrayDimensionsSeparator;
    public static ChunkArray Restore(ChunkArray typesInfo);
    private static TypeWithName RestoreType(TypeInfo typeInfo, ChunkArray restoredTypes, IDictionary`2<Guid, Module> modules);
    private static TypeWithName FindType(Guid moduleVersionId, string typeName, IDictionary`2<Guid, Module> modules);
    private static TypeWithName MakeArrayType(TypeWithName elementType, IEnumerable`1<int> arrayRanks);
    private static TypeWithName MakeGenericType(TypeWithName genericType, Int32[] genericArguments, ChunkArray restoredTypes);
    private static IDictionary`2<Guid, Module> GetModules();
}
internal class JetBrains.dotMemoryUnit.ByTypeGrouping.TypeWithName : ValueType {
    private string myFullyQualifiedName;
    private Type myType;
    public string FullyQualifiedName { get; }
    public Type Type { get; }
    public TypeWithName(string fullyQualifiedName, Type type);
    public string get_FullyQualifiedName();
    public Type get_Type();
    public virtual string ToString();
}
public static class JetBrains.dotMemoryUnit.Client.ClientSerializer : object {
    public static TR Call(T object, Func`2<Byte[], Byte[]> func);
    public static T Cast(object instance);
    public static Byte[] Serialize(T object);
    public static T Deserialize(Byte[] data);
}
public static class JetBrains.dotMemoryUnit.Client.Contract : object {
    private static string FactoryMethodName;
    private static char Separator;
    public static string NetFrameworkProxyFactoryId;
    public static string StandardProxyFactoryId;
    public static void SetDotMemoryUnitFrameworkProxyType(Type type, string factoryId);
    public static void SetDotMemoryUnitFrameworkProxyType(string typeName, string assemblyLocation, string factoryId);
    public static void RemoveDotMemoryUnitFrameworkProxyType();
    private static object CreateDotMemoryUnitClient(string proxyFactoryId);
    private static bool IsRunUnderDotMemory(string proxyFactoryId);
    public static object CreateDotMemoryUnitClient();
}
public class JetBrains.dotMemoryUnit.Client.DotMemoryUnitDataContractSerializer : object {
    private DataContractSerializer mySerializer;
    public void Serialize(Stream stream, object object);
    public T Deserialize(Stream stream);
}
internal class JetBrains.dotMemoryUnit.Client.DotMemoryUnitProxy : object {
    private static string InitialVersionHandshakeMethodName;
    public static string AssertIsActive;
    public static string CollectAllocationsMethodName;
    public static string TestStartMethodName;
    public static string TestEndMethodName;
    public static string GetSnapshotMethodName;
    public static string SaveWorkspaceMethodName;
    public static string SetTestFailedMethodName;
    public static string SetTestFailedOnMemoryAssertMethodName;
    public static string EvaluateObjectSetMethodName;
    public static string EvaluateObjectSetGroupedByTypeMethodName;
    public static string EvaluateTrafficMethodName;
    public static string EvaluateTrafficGroupedByTypeMethodName;
    private static int ManagedThreadId;
    private static Int32 modreq(System.Runtime.CompilerServices.IsVolatile) myIsInsideTest;
    private object myClient;
    private PropertyInfo myCollectAllocations;
    private MethodInfo myTestStart;
    private MethodInfo mySetTestFailed;
    private MethodInfo myTestEnd;
    private MethodInfo myGetSnapshot;
    private MethodInfo mySaveWorkspace;
    private MethodInfo mySetTestFailedOnMemoryAssert;
    private MethodInfo myEvaluateObjectSet;
    private MethodInfo myEvaluateObjectSetGroupedByType;
    private MethodInfo myEvaluateTraffic;
    private MethodInfo myEvaluateTrafficGroupedByType;
    private static IDotMemoryUnitProxyInstance ourInstance;
    public static IDotMemoryUnitProxyInstance CurrentInstance { get; public set; }
    public static bool IsEnabledSilent { get; }
    public static bool IsEnabled { get; }
    public static DotMemoryUnitProxy Instance { get; }
    public static bool CollectAllocations { get; public set; }
    private bool CollectAllocationsInternal { get; private set; }
    private static bool IsInsideTest { get; }
    public DotMemoryUnitProxy(object client);
    private static DotMemoryUnitProxy();
    public static IDotMemoryUnitProxyInstance get_CurrentInstance();
    public static void set_CurrentInstance(IDotMemoryUnitProxyInstance value);
    private void InitialVersionHandshake(Type clientType);
    public static bool get_IsEnabledSilent();
    public static bool get_IsEnabled();
    public static DotMemoryUnitProxy get_Instance();
    public void TestStart(MethodBase testMethod);
    public void SetTestFailed();
    public void SetTestFailedOnMemoryAssert();
    public void TestEnd();
    public static bool get_CollectAllocations();
    public static void set_CollectAllocations(bool value);
    private bool get_CollectAllocationsInternal();
    private void set_CollectAllocationsInternal(bool value);
    public static int GetSnapshot();
    private int GetSnapshotInternal();
    public static void SaveWorkspace(string directory);
    private void SaveWorkspaceInternal(string directory);
    public static MemoryInfo EvaluateObjectSet(Query[] queryLine);
    private MemoryInfo EvaluateObjectSetInternal(Query[] queryLine);
    public static MemoryInfoGroupedByType EvaluateObjectSetGroupedByType(Query[] queryLine);
    private MemoryInfoGroupedByType EvaluateObjectSetGroupedByTypeInternal(Query[] queryLine);
    public static TrafficInfo EvaluateTraffic(Query[] queryLine);
    private TrafficInfo EvaluateTrafficInternal(Query[] queryLine);
    public static TrafficInfoGroupedByType EvaluateTrafficGroupedByType(Query[] queryLine);
    private TrafficInfoGroupedByType EvaluateTrafficGroupedByTypeInternal(Query[] queryLine);
    public static void AssertWithSupport();
    private static void AssertSingleThread();
    private static bool get_IsInsideTest();
    private static void AssertIsInsideTest();
    [CompilerGeneratedAttribute]
private Byte[] <EvaluateObjectSetInternal>b__54_0(Byte[] bytes);
    [CompilerGeneratedAttribute]
private Byte[] <EvaluateObjectSetGroupedByTypeInternal>b__56_0(Byte[] bytes);
    [CompilerGeneratedAttribute]
private Byte[] <EvaluateTrafficInternal>b__58_0(Byte[] bytes);
    [CompilerGeneratedAttribute]
private Byte[] <EvaluateTrafficGroupedByTypeInternal>b__60_0(Byte[] bytes);
}
internal class JetBrains.dotMemoryUnit.Client.DotMemoryUnitProxyInstance : object {
    private DotMemoryUnitException myInitializationIsFailedException;
    private DotMemoryUnitException myNotUnderDmuException;
    private DotMemoryUnitProxy myCachedInstance;
    public DotMemoryUnitProxy Instance { get; }
    public DotMemoryUnitException InitializationIsFailedException { get; }
    public DotMemoryUnitException NotUnderDmuException { get; }
    public sealed virtual DotMemoryUnitProxy get_Instance();
    public sealed virtual DotMemoryUnitException get_InitializationIsFailedException();
    public sealed virtual DotMemoryUnitException get_NotUnderDmuException();
}
internal interface JetBrains.dotMemoryUnit.Client.IDotMemoryUnitProxyInstance {
    public DotMemoryUnitProxy Instance { get; }
    public DotMemoryUnitException InitializationIsFailedException { get; }
    public DotMemoryUnitException NotUnderDmuException { get; }
    public abstract virtual DotMemoryUnitProxy get_Instance();
    public abstract virtual DotMemoryUnitException get_InitializationIsFailedException();
    public abstract virtual DotMemoryUnitException get_NotUnderDmuException();
}
public enum JetBrains.dotMemoryUnit.Client.Interface.ExpressionType : Enum {
    public int value__;
    public static ExpressionType Snapshot;
    public static ExpressionType EventHandlerAutoInspection;
    public static ExpressionType Comparison;
    public static ExpressionType NewMemory;
    public static ExpressionType DeadMemory;
    public static ExpressionType SurvivedMemory;
    public static ExpressionType Traffic;
    public static ExpressionType Assembly;
    public static ExpressionType Type;
    public static ExpressionType TypeLike;
    public static ExpressionType OpenGenericType;
    public static ExpressionType Interface;
    public static ExpressionType OpenGenericInterface;
    public static ExpressionType InterfaceLike;
    public static ExpressionType Namespace;
    public static ExpressionType Generation;
    public static ExpressionType RetainedObjectSet;
    public static ExpressionType Dominated;
}
internal interface JetBrains.dotMemoryUnit.Client.Interface.IDotMemoryUnit {
    public bool CollectAllocations { get; public set; }
    public abstract virtual void AssertIsActive();
    public abstract virtual bool get_CollectAllocations();
    public abstract virtual void set_CollectAllocations(bool value);
    public abstract virtual int GetSnapshot();
    public abstract virtual void SaveWorkspace(string directoryFullPath);
    public abstract virtual Byte[] EvaluateObjectSet(Byte[] queryLine);
    public abstract virtual Byte[] EvaluateObjectSetGroupedByType(Byte[] queryLine);
    public abstract virtual Byte[] EvaluateTraffic(Byte[] queryLine);
    public abstract virtual Byte[] EvaluateTrafficGroupedByType(Byte[] queryLine);
    public abstract virtual void TestStart(MethodBase testMethod);
    public abstract virtual void TestEnd();
    public abstract virtual void SetTestFailed();
    public abstract virtual void SetTestFailedOnMemoryAssert();
}
[DataContractAttribute]
public class JetBrains.dotMemoryUnit.Client.Interface.Intersection : QuerySet`1<Intersection> {
    protected string DebugSign { get; }
    internal Intersection(IEnumerable`1<Query> queries);
    protected virtual string get_DebugSign();
}
public enum JetBrains.dotMemoryUnit.Client.Interface.Operation : Enum {
    public int value__;
    public static Operation None;
    public static Operation Equal;
    public static Operation NotEqual;
}
[DataContractAttribute]
public abstract class JetBrains.dotMemoryUnit.Client.Interface.Query : object {
    public static Query op_BitwiseAnd(Query left, Query right);
    public static Query op_BitwiseOr(Query left, Query right);
}
[DataContractAttribute]
public class JetBrains.dotMemoryUnit.Client.Interface.QueryExpression : Query {
    [DataMemberAttribute]
private object myArgument;
    [DataMemberAttribute]
private Operation myOperation;
    [DataMemberAttribute]
private ExpressionType myExpressionType;
    public object Argument { get; }
    public Operation Operation { get; }
    public ExpressionType ExpressionType { get; }
    internal QueryExpression(object argument, Operation operation, ExpressionType expressionType);
    public object get_Argument();
    public Operation get_Operation();
    public ExpressionType get_ExpressionType();
    public virtual string ToString();
}
[DataContractAttribute]
public abstract class JetBrains.dotMemoryUnit.Client.Interface.QuerySet`1 : Query {
    private string myStringPresentation;
    [DataMemberAttribute]
public IEnumerable`1<Query> Queries;
    protected string DebugSign { get; }
    protected QuerySet`1(IEnumerable`1<Query> queries);
    protected abstract virtual string get_DebugSign();
    public virtual string ToString();
}
[DataContractAttribute]
public class JetBrains.dotMemoryUnit.Client.Interface.SnapshotPair : ValueType {
    [DataMemberAttribute]
private int mySnapshot1Id;
    [DataMemberAttribute]
private int mySnapshot2Id;
    public int Snapshot1Id { get; }
    public int Snapshot2Id { get; }
    internal SnapshotPair(int snapshot1Id, int snapshot2Id);
    public int get_Snapshot1Id();
    public int get_Snapshot2Id();
    public virtual string ToString();
}
[DataContractAttribute]
public class JetBrains.dotMemoryUnit.Client.Interface.Union : QuerySet`1<Union> {
    protected string DebugSign { get; }
    private Union(IEnumerable`1<Query> queries);
    protected virtual string get_DebugSign();
    internal static Query Create(IList`1<Query> queries);
}
[ExtensionAttribute]
internal static class JetBrains.dotMemoryUnit.Client.ReflectionExtension : object {
    [ExtensionAttribute]
public static MethodInfo GetMethodChecked(Type type, string name, Type[] parameterTypes);
    [ExtensionAttribute]
public static PropertyInfo GetPropertyChecked(Type type, string name, Type[] parameterTypes);
    [ExtensionAttribute]
public static void Invoke(object instance, MethodBase method, Object[] args);
    [ExtensionAttribute]
public static T Invoke(object instance, MethodBase method, Object[] args);
    [ExtensionAttribute]
public static T InvokeGetProperty(object instance, PropertyInfo property, Object[] args);
    [ExtensionAttribute]
public static void InvokeSetProperty(object instance, PropertyInfo property, T value, Object[] args);
    private static Exception GetException(TargetInvocationException exception);
}
public static class JetBrains.dotMemoryUnit.Client.StandardSerializer : object {
    private static MemoryStream ourStream;
    private static DotMemoryUnitDataContractSerializer ourInstance;
    private static StandardSerializer();
    public static TR Call(T object, Func`2<Byte[], Byte[]> func);
    public static Byte[] Call(Byte[] data, Func`2<T, TR> func);
    public static Byte[] Serialize(T object);
    public static T Deserialize(Byte[] data);
    public static T Cast(object instance);
}
public static class JetBrains.dotMemoryUnit.Controller.TestController : object {
    public static void TestStart();
    public static void TestFailed();
    public static void TestEnd();
    internal static MethodBase GetTestMethod();
}
public static class JetBrains.dotMemoryUnit.dotMemory : object {
    internal static string CheckMethodName;
    private static dotMemory();
    public static MemoryCheckPoint Check();
    public static MemoryCheckPoint Check(Action`1<Memory> check);
    private static bool FailIfRunWithoutSupport();
}
[DataContractAttribute]
[AttributeUsageAttribute("69")]
public class JetBrains.dotMemoryUnit.DotMemoryUnitAttribute : Attribute {
    internal static int LimitNotSet;
    public static DotMemoryUnitAttribute Default;
    [DataMemberAttribute]
private SavingStrategy mySavingStrategy;
    [DataMemberAttribute]
private int myWorkspaceNumberLimit;
    [DataMemberAttribute]
private long myDiskSpaceLimit;
    [DataMemberAttribute]
private string myDirectory;
    [DataMemberAttribute]
private Nullable`1<bool> myCollectAllocations;
    [DataMemberAttribute]
private Nullable`1<bool> myFailIfRunWithoutSupport;
    internal bool Valid { get; }
    public SavingStrategy SavingStrategy { get; public set; }
    public int WorkspaceNumberLimit { get; public set; }
    public long DiskSpaceLimit { get; public set; }
    public string Directory { get; public set; }
    public bool CollectAllocations { get; public set; }
    public bool FailIfRunWithoutSupport { get; public set; }
    private static DotMemoryUnitAttribute();
    internal bool get_Valid();
    internal Nullable`1<bool> GetCollectAllocations();
    internal Nullable`1<bool> GetFailIfRunWithoutSupport();
    public SavingStrategy get_SavingStrategy();
    public void set_SavingStrategy(SavingStrategy value);
    public int get_WorkspaceNumberLimit();
    public void set_WorkspaceNumberLimit(int value);
    public long get_DiskSpaceLimit();
    public void set_DiskSpaceLimit(long value);
    public string get_Directory();
    public void set_Directory(string value);
    public bool get_CollectAllocations();
    public void set_CollectAllocations(bool value);
    public bool get_FailIfRunWithoutSupport();
    public void set_FailIfRunWithoutSupport(bool value);
    public virtual string ToString();
}
public static class JetBrains.dotMemoryUnit.DotMemoryUnitConstants : object {
    public static string ProductTechnicalName;
    public static string ProductPresentableName;
    public static Version Version;
    private static DotMemoryUnitConstants();
    public static string CreateHelpLink(string page);
}
public static class JetBrains.dotMemoryUnit.DotMemoryUnitController : object {
    public static void TestStart(MethodBase testMethod);
    public static void TestFailed(bool onMemoryAssert);
    public static void TestEnd();
}
public static class JetBrains.dotMemoryUnit.DotMemoryUnitTestOutput : object {
    internal static string SetOutputMethodName;
    private static Action`1<string> ourWriteLine;
    [CompilerGeneratedAttribute]
private static bool <IsOverrided>k__BackingField;
    internal static bool IsOverrided { get; private set; }
    private static DotMemoryUnitTestOutput();
    internal static void AppendLine(string message);
    internal static void WriteLine(string message);
    [CompilerGeneratedAttribute]
internal static bool get_IsOverrided();
    [CompilerGeneratedAttribute]
private static void set_IsOverrided(bool value);
    public static void SetOutputMethod(Action`1<string> writeLine);
}
[AttributeUsageAttribute("1")]
public class JetBrains.dotMemoryUnit.EnableDotMemoryUnitSupportAttribute : Attribute {
}
public static class JetBrains.dotMemoryUnit.Kernel.dotMemoryApi : object {
    internal static string IsEnabledPropertyName;
    public static bool IsEnabled { get; }
    public static bool CollectAllocations { get; public set; }
    private static dotMemoryApi();
    public static bool get_IsEnabled();
    public static bool get_CollectAllocations();
    public static void set_CollectAllocations(bool value);
    public static Snapshot GetSnapshot();
    public static SnapshotDifference GetDifference(Snapshot snapshot1, Snapshot snapshot2);
    public static Traffic GetTrafficBetween(Snapshot snapshot1, Snapshot snapshot2);
    public static void SaveCollectedData(string directoryPath);
}
public class JetBrains.dotMemoryUnit.Kernel.Snapshot : ObjectSetBase {
    internal static int InvalidId;
    internal static Snapshot Invalid;
    private int myID;
    internal int Id { get; }
    internal Snapshot(int id);
    private static Snapshot();
    internal int get_Id();
}
public class JetBrains.dotMemoryUnit.Memory : Snapshot {
    internal Memory(int id);
    public SnapshotDifference GetDifference(MemoryCheckPoint memoryCheckPoint);
    public Traffic GetTrafficFrom(MemoryCheckPoint memoryCheckPoint);
}
public class JetBrains.dotMemoryUnit.MemoryCheckPoint : ValueType {
    internal static MemoryCheckPoint Invalid;
    internal Snapshot Snapshot;
    internal MemoryCheckPoint(Snapshot snapshot);
    private static MemoryCheckPoint();
}
[DataContractAttribute]
public class JetBrains.dotMemoryUnit.MemoryInfo : ValueType {
    [DataMemberAttribute]
private int myObjectsCount;
    [DataMemberAttribute]
private long mySizeInBytes;
    public int ObjectsCount { get; }
    public long SizeInBytes { get; }
    public MemoryInfo(long sizeInBytes, int objectsCount);
    public int get_ObjectsCount();
    public long get_SizeInBytes();
    public virtual string ToString();
}
public class JetBrains.dotMemoryUnit.ObjectSet : ObjectSetBase {
    internal ObjectSet(Query[] expressions);
    public ObjectSet GetExclusivelyRetainedObjects();
}
public abstract class JetBrains.dotMemoryUnit.ObjectSetBase : object {
    private Query[] myExpressions;
    private Nullable`1<MemoryInfo> myMemoryInfo;
    private IReadOnlyCollection`1<TypeMemoryInfo> myTypeMemoryInfo;
    public int ObjectsCount { get; }
    public long SizeInBytes { get; }
    internal Query[] Expressions { get; }
    private MemoryInfo MemoryInfo { get; }
    internal ObjectSetBase(Query[] expressions);
    public ObjectSet GetObjects(Func`2<ObjectProperty, Query> query);
    public ObjectSet GetObjects(ObjectSetQuery objectSetQuery);
    public int get_ObjectsCount();
    public long get_SizeInBytes();
    public IReadOnlyCollection`1<TypeMemoryInfo> GroupByType();
    internal static IReadOnlyCollection`1<TypeMemoryInfo> GetTypeMemoryInfo(MemoryInfoGroupedByType memoryInfoGroupedByType);
    internal Query[] get_Expressions();
    private MemoryInfo get_MemoryInfo();
    public virtual string ToString();
}
public class JetBrains.dotMemoryUnit.ObjectSetQuery : ValueType {
    private Query[] myExpressions;
    internal Query[] Expressions { get; }
    internal ObjectSetQuery(Query[] expressions);
    public ObjectSetQuery GetObjects(Func`2<ObjectProperty, Query> query);
    internal Query[] get_Expressions();
}
public enum JetBrains.dotMemoryUnit.Origin : Enum {
    public int value__;
    public static Origin OldSnapshot;
    public static Origin NewSnapshot;
}
public class JetBrains.dotMemoryUnit.Properties.AssemblyProperty : object {
    public static AssemblyProperty Instance;
    private static AssemblyProperty();
    public static Query op_Equality(AssemblyProperty _, Assembly assembly);
    public static Query op_Inequality(AssemblyProperty _, Assembly assembly);
    public Query Is(Assembly[] assemblies);
    public Query IsNot(Assembly[] assemblies);
    public Query Like(String[] assemblyPattern);
    public Query NotLike(String[] assemblyPattern);
}
public enum JetBrains.dotMemoryUnit.Properties.Generation : Enum {
    public int value__;
    public static Generation Gen1;
    public static Generation Gen2;
    public static Generation LOH;
}
public class JetBrains.dotMemoryUnit.Properties.GenerationProperty : object {
    public static GenerationProperty Instance;
    private static GenerationProperty();
    public static Query op_Equality(GenerationProperty _, Generation generation);
    public static Query op_Inequality(GenerationProperty _, Generation generation);
    public Query Is(Generation[] generations);
    public Query IsNot(Generation[] generations);
}
public class JetBrains.dotMemoryUnit.Properties.InterfaceProperty : TypePropertyBase {
    public static InterfaceProperty Instance;
    protected TypePropertyBase PropertyInstance { get; }
    protected ExpressionType OpenGenericExpressionType { get; }
    protected ExpressionType LikeExpressionType { get; }
    protected ExpressionType ExpressionType { get; }
    private static InterfaceProperty();
    public static Query op_Equality(InterfaceProperty _, Type type);
    public static Query op_Inequality(InterfaceProperty _, Type type);
    protected virtual TypePropertyBase get_PropertyInstance();
    protected virtual void AssertArguments(Type[] typeList);
    protected virtual ExpressionType get_OpenGenericExpressionType();
    protected virtual ExpressionType get_LikeExpressionType();
    protected virtual ExpressionType get_ExpressionType();
}
public class JetBrains.dotMemoryUnit.Properties.NamespaceProperty : object {
    public static NamespaceProperty Instance;
    private static NamespaceProperty();
    public Query Like(String[] namespaceWildcard);
    public Query NotLike(String[] namespaceWildcard);
}
public class JetBrains.dotMemoryUnit.Properties.ObjectProperty : object {
    public static ObjectProperty Instance;
    public TypeProperty Type;
    public InterfaceProperty Interface;
    public NamespaceProperty Namespace;
    public AssemblyProperty Assembly;
    public GenerationProperty Generation;
    private static ObjectProperty();
    public Query LeakedOnEventHandler();
    public Query IsNotDominated();
}
public class JetBrains.dotMemoryUnit.Properties.PublicKey : object {
    public static string Product;
    public static string Mocks;
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
public class JetBrains.dotMemoryUnit.Properties.Resources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
public static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
public static CultureInfo Culture { get; public set; }
    public static string AssertTraffic_Attribute_EmptyNamespacesArray { get; }
    public static string AssertTraffic_Attribute_EmptyNamespaceString { get; }
    public static string CheckIsIgnored_Template { get; }
    public static string DotMemoryUnitAttribute_Invalid_Template { get; }
    public static string DotMemoryUnitAttribute_SavingStrategy_NotSet { get; }
    public static string DotMemoryUnitException_DefaultMessage { get; }
    public static string HelpLink_Template { get; }
    public static string InProcessServer_InitializationFailed { get; }
    public static string InProcessServer_InvalidFactoryMethod { get; }
    public static string InProcessServer_InvalidFormat { get; }
    public static string InterfaceProperty_InvalidTypeException { get; }
    public static string NotInsideTest_Error_Template { get; }
    public static string ParallelRunning_Error { get; }
    public static string QuerySet_Exception { get; }
    public static string RunNotUnderDmu_Exception_Template { get; }
    public static string TestOutput_Prefix { get; }
    public static string TypeProperty_NotTypeException { get; }
    public static string xUnitOutput_Exception_Template { get; }
    public static ResourceManager get_ResourceManager();
    public static CultureInfo get_Culture();
    public static void set_Culture(CultureInfo value);
    public static string get_AssertTraffic_Attribute_EmptyNamespacesArray();
    public static string get_AssertTraffic_Attribute_EmptyNamespaceString();
    public static string get_CheckIsIgnored_Template();
    public static string get_DotMemoryUnitAttribute_Invalid_Template();
    public static string get_DotMemoryUnitAttribute_SavingStrategy_NotSet();
    public static string get_DotMemoryUnitException_DefaultMessage();
    public static string get_HelpLink_Template();
    public static string get_InProcessServer_InitializationFailed();
    public static string get_InProcessServer_InvalidFactoryMethod();
    public static string get_InProcessServer_InvalidFormat();
    public static string get_InterfaceProperty_InvalidTypeException();
    public static string get_NotInsideTest_Error_Template();
    public static string get_ParallelRunning_Error();
    public static string get_QuerySet_Exception();
    public static string get_RunNotUnderDmu_Exception_Template();
    public static string get_TestOutput_Prefix();
    public static string get_TypeProperty_NotTypeException();
    public static string get_xUnitOutput_Exception_Template();
}
public class JetBrains.dotMemoryUnit.Properties.TrafficProperty : object {
    public static TrafficProperty Instance;
    public TypeProperty Type;
    public InterfaceProperty Interface;
    public NamespaceProperty Namespace;
    public AssemblyProperty Assembly;
    private static TrafficProperty();
}
public class JetBrains.dotMemoryUnit.Properties.TypeProperty : TypePropertyBase {
    public static TypeProperty Instance;
    protected TypePropertyBase PropertyInstance { get; }
    protected ExpressionType OpenGenericExpressionType { get; }
    protected ExpressionType LikeExpressionType { get; }
    protected ExpressionType ExpressionType { get; }
    private static TypeProperty();
    public static Query op_Equality(TypeProperty _, Type type);
    public static Query op_Inequality(TypeProperty _, Type type);
    protected virtual TypePropertyBase get_PropertyInstance();
    protected virtual void AssertArguments(Type[] typeList);
    protected virtual ExpressionType get_OpenGenericExpressionType();
    protected virtual ExpressionType get_LikeExpressionType();
    protected virtual ExpressionType get_ExpressionType();
}
public abstract class JetBrains.dotMemoryUnit.Properties.TypePropertyBase : object {
    private static string GenericDetailsSeparator;
    private static string GenericOpenBrace;
    private static string GenericCloseBrace;
    private static string GenericArgumentDelimeter;
    public static string ArrayOpenBrace;
    public static string ArrayCloseBrace;
    public static string ArrayRankDelimiter;
    protected TypePropertyBase PropertyInstance { get; }
    protected ExpressionType OpenGenericExpressionType { get; }
    protected ExpressionType LikeExpressionType { get; }
    protected ExpressionType ExpressionType { get; }
    protected abstract virtual TypePropertyBase get_PropertyInstance();
    protected abstract virtual void AssertArguments(Type[] types);
    protected abstract virtual ExpressionType get_OpenGenericExpressionType();
    protected abstract virtual ExpressionType get_LikeExpressionType();
    protected abstract virtual ExpressionType get_ExpressionType();
    public Query Is();
    public Query IsNot();
    public Query Is(Type[] typeList);
    public Query IsNot(Type[] typeList);
    public Query Like(String[] typeWildcard);
    public Query NotLike(String[] typeWildcard);
    private Query CreateLikeQuery(Operation operation, String[] typeWildcard);
    private Query CreateQuery(Operation operation, Type[] typeList);
    private static String[] TypesToNames(IEnumerable`1<Type> types);
    internal static string GetTypeName(Type type);
    private static string GetDefaultTypeName(Type type);
    private static string GetGenericTypeName(Type type);
    public static string ComposeGenericTypeName(string typeName, String[] genericArgumentNames);
    private static string GetArrayTypeName(Type type);
    public static string GetGenericTypeDefinition(string typeName);
}
public static class JetBrains.dotMemoryUnit.QueryBuilder : object {
    public static ObjectSetQuery GetObjects(Func`2<ObjectProperty, Query> query);
    public static TrafficQuery TrafficQuery(Func`2<TrafficProperty, Query> query);
    internal static Query CreateSnapshotQuery(int id);
    internal static Query CreateComparisonQuery(SnapshotPair snapshotPair);
    internal static Traffic CreateTrafficQuery(int from, int to);
    [ObsoleteAttribute("Need for <= 2.2 where DotMemoryUnitClient calls this method to create query based on AssertTrafficAttribute")]
internal static Traffic CreateTrafficQuery(int from, int to, AssertTrafficAttribute attribute);
}
public enum JetBrains.dotMemoryUnit.SavingStrategy : Enum {
    public int value__;
    public static SavingStrategy NotSet;
    public static SavingStrategy OnCheckFail;
    public static SavingStrategy OnAnyFail;
    public static SavingStrategy Never;
}
public class JetBrains.dotMemoryUnit.SnapshotDifference : ValueType {
    private Query myComparisonExpression;
    internal SnapshotDifference(Snapshot snapshot1, Snapshot snapshot2);
    public ObjectSet GetNewObjects(Func`2<ObjectProperty, Query> query);
    public ObjectSet GetDeadObjects(Func`2<ObjectProperty, Query> query);
    public ObjectSet GetSurvivedObjects(Func`2<ObjectProperty, Query> query);
    public ObjectSet GetSurvivedObjects(Origin from, Func`2<ObjectProperty, Query> query);
}
public static class JetBrains.dotMemoryUnit.SpecialDirectory : object {
    internal static string SpecialFolderSign;
    public static string User;
    public static string LocalAppData;
    public static string CommonAppData;
}
[AttributeUsageAttribute("1")]
public class JetBrains.dotMemoryUnit.SuppressXUnitOutputExceptionAttribute : Attribute {
}
public class JetBrains.dotMemoryUnit.Traffic : ValueType {
    private Query[] myExpressions;
    private Nullable`1<TrafficInfo> myTrafficInfo;
    private IReadOnlyCollection`1<TypeTrafficInfo> myTypeTrafficInfo;
    public MemoryInfo AllocatedMemory { get; }
    public MemoryInfo CollectedMemory { get; }
    internal Query[] Expressions { get; }
    private TrafficInfo Result { get; }
    internal Traffic(Query[] expressions);
    public Traffic Where(Func`2<TrafficProperty, Query> query);
    public Traffic Where(TrafficQuery predicate);
    public MemoryInfo get_AllocatedMemory();
    public MemoryInfo get_CollectedMemory();
    public IReadOnlyCollection`1<TypeTrafficInfo> GroupByType();
    internal static IReadOnlyCollection`1<TypeTrafficInfo> GetTypeTrafficInfo(TrafficInfoGroupedByType trafficInfoGroupedByType);
    internal Query[] get_Expressions();
    private TrafficInfo get_Result();
    public virtual string ToString();
}
[DataContractAttribute]
internal class JetBrains.dotMemoryUnit.TrafficInfo : ValueType {
    [DataMemberAttribute]
private MemoryInfo myAllocated;
    [DataMemberAttribute]
private MemoryInfo myCollected;
    public MemoryInfo Allocated { get; }
    public MemoryInfo Collected { get; }
    public TrafficInfo(MemoryInfo allocated, MemoryInfo collected);
    public MemoryInfo get_Allocated();
    public MemoryInfo get_Collected();
    public virtual string ToString();
}
public class JetBrains.dotMemoryUnit.TrafficQuery : ValueType {
    private Query[] myExpressions;
    internal Query[] Expressions { get; }
    internal TrafficQuery(Query[] expressions);
    public TrafficQuery Where(Func`2<TrafficProperty, Query> query);
    internal Query[] get_Expressions();
}
public class JetBrains.dotMemoryUnit.TypeMemoryInfo : ValueType {
    private MemoryInfo myMemoryInfo;
    private string myTypeFullyQualifiedName;
    private Type myType;
    public int ObjectsCount { get; }
    public long SizeInBytes { get; }
    public string TypeFullyQualifiedName { get; }
    public Type Type { get; }
    internal TypeMemoryInfo(MemoryInfo memoryInfo, string typeFullyQualifiedName, Type type);
    public int get_ObjectsCount();
    public long get_SizeInBytes();
    public string get_TypeFullyQualifiedName();
    public Type get_Type();
    public virtual string ToString();
}
public class JetBrains.dotMemoryUnit.TypeTrafficInfo : ValueType {
    private TrafficInfo myTrafficMemoryInfo;
    private string myTypeFullyQualifiedName;
    private Type myType;
    public MemoryInfo AllocatedMemoryInfo { get; }
    public MemoryInfo CollectedMemoryInfo { get; }
    public string TypeFullyQualifiedName { get; }
    public Type Type { get; }
    internal TypeTrafficInfo(TrafficInfo trafficMemoryInfo, string typeFullyQualifiedName, Type type);
    public MemoryInfo get_AllocatedMemoryInfo();
    public MemoryInfo get_CollectedMemoryInfo();
    public string get_TypeFullyQualifiedName();
    public Type get_Type();
    public virtual string ToString();
}
internal static class JetBrains.dotMemoryUnit.Util.Array : object {
    public static T[] Concat(T[] head, T tail);
    public static T[] Concat(T head, T[] tail);
    public static T[] Concat(T[] head, T[] tail);
}
[ExtensionAttribute]
internal static class JetBrains.dotMemoryUnit.Util.AttributeHelper : object {
    private static Dictionary`2<object, DotMemoryUnitAttribute> DotMemoryUnitAttributesCache;
    private static AttributeHelper();
    [ExtensionAttribute]
public static IEnumerable`1<T> GetCustomAttributes(ICustomAttributeProvider attributeProvider);
    public static TR GetValue(MethodBase method, Func`2<DotMemoryUnitAttribute, TR> getValue, Predicate`1<TR> predicate);
    public static TR GetValue(IEnumerable`1<DotMemoryUnitAttribute> attributes, Func`2<DotMemoryUnitAttribute, TR> getValue, Predicate`1<TR> predicate);
    private static DotMemoryUnitAttribute[] GetAttributesChain(MethodBase method);
}
[DefaultMemberAttribute("Item")]
[DataContractAttribute]
internal class JetBrains.dotMemoryUnit.Util.ChunkArray`1 : object {
    public static int MaxAntiLohSizeInBytes;
    private static int ourChunkSize;
    [DataMemberAttribute]
private int myCount;
    [DataMemberAttribute]
private T[][] myChunks;
    public int Count { get; }
    public T Item { get; public set; }
    public ChunkArray`1(int count);
    public ChunkArray`1(int count, IEnumerable`1<T> enumerable);
    public ChunkArray`1(ICollection`1<T> list);
    private static ChunkArray`1();
    public sealed virtual int get_Count();
    public T get_Item(int index);
    public void set_Item(int index, T value);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public interface JetBrains.dotMemoryUnit.Util.IReadOnlyCollection`1 {
    public int Count { get; }
    public abstract virtual int get_Count();
}
public static class JetBrains.dotMemoryUnit.Util.nameof`1 : object {
    public static string Property(Expression`1<Func`2<T, TV>> property);
}
internal static class JetBrains.dotMemoryUnit.Util.Sizeof : object {
    private static MethodInfo ourGenericMethod;
    private static Sizeof();
    private static int CalculateSizeOf();
    public static int Type();
}
