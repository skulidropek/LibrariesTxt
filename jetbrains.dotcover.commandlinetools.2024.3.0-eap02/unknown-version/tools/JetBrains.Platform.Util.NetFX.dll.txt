[ExtensionAttribute]
public static class JetBrains.Util.NetFX.Extension.IWin32WindowEx : object {
    [ExtensionAttribute]
public static JetPhysicalRect GetBounds(IWin32Window window);
    [ExtensionAttribute]
public static bool IsValidWindow(IWin32Window thіs);
    [ExtensionAttribute]
public static IDisposable PushDisable(IWin32Window window);
}
[ExtensionAttribute]
public static class JetBrains.Util.NetFX.Interop.AvalonAndWinFormsInterop : object {
    [ExtensionAttribute]
[PureAttribute]
public static Matrix ToAvalonMatrix(JetMatrix& m);
    [ExtensionAttribute]
[PureAttribute]
public static Point ToAvalonPoint(JetPoint value);
    [ExtensionAttribute]
[PureAttribute]
public static Rect ToAvalonRect(JetRect value);
    [ExtensionAttribute]
[PureAttribute]
public static Size ToAvalonSize(JetSize value);
    [ExtensionAttribute]
[PureAttribute]
public static Nullable`1<Size> ToAvalonSize(Nullable`1<JetSize> value);
    [ExtensionAttribute]
[PureAttribute]
public static Thickness ToAvalonThickness(JetThickness value);
    [ExtensionAttribute]
[PureAttribute]
public static JetMatrix ToJetMatrix(Matrix& m);
    [ExtensionAttribute]
[PureAttribute]
public static JetMatrix ToJetMatrix(Transform t);
    [ExtensionAttribute]
[PureAttribute]
public static JetPhysicalPoint ToJetPhysicalPoint(Point value);
    [ExtensionAttribute]
[PureAttribute]
public static JetPhysicalPoint ToJetPhysicalPoint(JetPhysicalPoint value);
    [ExtensionAttribute]
[PureAttribute]
public static JetPhysicalRect ToJetPhysicalRect(Rectangle value);
    [ExtensionAttribute]
[PureAttribute]
public static JetPhysicalRect ToJetPhysicalRect(JetPhysicalRect value);
    [ExtensionAttribute]
[PureAttribute]
public static JetPhysicalSize ToJetPhysicalSize(Size value);
    [ExtensionAttribute]
[PureAttribute]
public static JetPhysicalSize ToJetPhysicalSize(JetPhysicalSize value);
    [ExtensionAttribute]
[PureAttribute]
public static JetPoint ToJetPoint(Point value);
    [ExtensionAttribute]
[PureAttribute]
public static JetRect ToJetRect(Rect value);
    [ExtensionAttribute]
[PureAttribute]
public static JetSize ToJetSize(Size value);
    [ExtensionAttribute]
[PureAttribute]
public static JetPoint ToLogicalPointAssumeDefaultResolution(JetPhysicalPoint value);
    [ExtensionAttribute]
[PureAttribute]
public static Padding ToWinFormsPadding(JetPhysicalThickness thickness);
    [ExtensionAttribute]
[PureAttribute]
public static Point ToWinFormsPoint(JetPhysicalPoint value);
    [ExtensionAttribute]
[PureAttribute]
public static Rectangle ToWinFormsRectangle(JetPhysicalRect rect);
    [ExtensionAttribute]
[PureAttribute]
public static Size ToWinFormsSize(JetPhysicalSize size);
}
[ExtensionAttribute]
public static class JetBrains.Util.NetFX.Interop.AvalonEx : object {
    [ExtensionAttribute]
[PureAttribute]
[NotNullAttribute]
public static BitmapSource EditDpiValue(BitmapSource bmpSrc, DpiResolution dpiTarget);
    [ExtensionAttribute]
public static TFreezable Freezed(TFreezable thіs);
    [ExtensionAttribute]
public static DpiResolution GetResolution(BitmapSource bmp);
    [ExtensionAttribute]
public static DpiResolution GetResolution(Bitmap bmp);
    [ExtensionAttribute]
public static Size GetSize(ImageSource thіs);
    [ExtensionAttribute]
public static JetSize GetJetSize(ImageSource thіs);
    [ExtensionAttribute]
public static Size GetSizeLogical(Bitmap thіs);
    [ExtensionAttribute]
public static JetPhysicalSize GetSizePhysical(BitmapSource thіs);
    [ExtensionAttribute]
[NotNullAttribute]
public static Transform InverseTransform(Transform tx);
    [ExtensionAttribute]
[ContractAnnotationAttribute("null=>true")]
public static bool IsNullOrIdentity(GeneralTransform tx);
    [ExtensionAttribute]
[NotNullAttribute]
public static DrawingBrush MakeGeometryBrush(Geometry geometry, SolidColorBrush brush, Pen pen);
    [ExtensionAttribute]
[NotNullAttribute]
public static BitmapSource Rasterize(ImageSource image, DpiResolution resolution, Nullable`1<Size> sizeLogical);
    [ExtensionAttribute]
[NotNullAttribute]
public static RenderTargetBitmap RasterizeDrawing(Drawing drawing, DpiResolution resolution, Nullable`1<Size> size);
    [ExtensionAttribute]
[NotNullAttribute]
public static BitmapSource Resample(BitmapSource bitmap, DpiResolution resolution);
    [ExtensionAttribute]
[NotNullAttribute]
public static Bitmap Resample(Bitmap bitmap, DpiResolution resolution);
    [ExtensionAttribute]
[PureAttribute]
[NotNullAttribute]
public static BitmapSource SetLogicalSize(BitmapSource bmpSrc, Size sizeLogical);
    [ExtensionAttribute]
[NotNullAttribute]
public static Bitmap ToGdiPlusBitmap(BitmapSource bmpAvalon);
    [ExtensionAttribute]
public static Vector Transform(GeneralTransform transform, Vector vector);
}
internal class JetBrains.Util.NetFX.Interop.GraphicsContainers.ControlGraphicsContainer : object {
    [CanBeNullAttribute]
private Control myControl;
    [CanBeNullAttribute]
private Graphics myGraphics;
    private LifetimeDefinition myLifetimeDefinition;
    public Graphics Graphics { get; }
    private IntPtr System.Windows.Forms.IWin32Window.Handle { get; }
    private Result`1<GraphicsDpiRecord> JetBrains.Util.NetFX.Interop.GraphicsContainers.IGraphicsContainerDpi.DpiRecord { get; }
    public ControlGraphicsContainer(Control control);
    public sealed virtual Graphics get_Graphics();
    public static bool IsGoodControl(Control control);
    public sealed virtual void Dispose();
    private sealed virtual override IntPtr System.Windows.Forms.IWin32Window.get_Handle();
    private sealed virtual override Result`1<GraphicsDpiRecord> JetBrains.Util.NetFX.Interop.GraphicsContainers.IGraphicsContainerDpi.get_DpiRecord();
}
internal class JetBrains.Util.NetFX.Interop.GraphicsContainers.GetDcGraphicsContainer : object {
    private bool myDisposed;
    private Graphics myGraphics;
    private Void* myHdc;
    private Void* myHwnd;
    public Graphics Graphics { get; }
    private IntPtr System.Windows.Forms.IWin32Window.Handle { get; }
    public GetDcGraphicsContainer(Void* hwnd);
    public sealed virtual Graphics get_Graphics();
    public sealed virtual void Dispose();
    private void Dispose(bool disposed);
    protected virtual override void Finalize();
    private sealed virtual override IntPtr System.Windows.Forms.IWin32Window.get_Handle();
}
[ExtensionAttribute]
public static class JetBrains.Util.NetFX.Interop.GraphicsContainers.GraphicsContainers : object {
    public static IGraphicsContainer FromGetDc(Void* hwnd);
    [ObsoleteAttribute("Wherever you have a source to know the resolution (Control, HWND, etc), you MUST call another method which would derive the resolution from that source. If you totally have no knowledge of the resolution, call FromGraphicsWithoutResolutionKnown to mark that it's intentional.")]
public static IGraphicsContainer FromGraphics(Graphics g);
    public static IGraphicsContainer FromGraphics(Graphics g, DpiResolution dpi);
    public static IGraphicsContainer FromGraphicsWithoutResolutionKnown(Graphics g);
    public static IGraphicsContainer FromGraphicsOrControl(Graphics g, Control control);
    public static IGraphicsContainer FromNothing();
    [ObsoleteAttribute("I can hardly imagine valid Windows Forms scenarios when you need this. Also, this won't pull thru the DPI context correctly because it binds to HWND not Control inside.")]
public static IGraphicsContainer FromPainting(Control control);
    public static IGraphicsContainer FromPainting(IntPtr hwnd);
    [ObsoleteAttribute("In the dynamic DPI world, this is a useless thing. Always create a context from some window to get its DPI correctly in the painter.")]
public static IGraphicsContainer FromScreen();
    [NotNullAttribute]
public static IGraphicsContainer FromNoControlWithResolution(DpiResolution dpi);
    [ExtensionAttribute]
public static Color GetNearestColor(Graphics graphics, JetRgbaColor color);
    public static IGraphicsContainer FromControl(Control control);
    [ExtensionAttribute]
[NotNullAttribute]
public static Graphics SetHighQuality(Graphics graphics);
    [ExtensionAttribute]
[NotNullAttribute]
public static Graphics SetHighQuality2(Graphics graphics);
}
public class JetBrains.Util.NetFX.Interop.GraphicsContainers.GraphicsDpiCache : object {
    [ThreadStaticAttribute]
[CanBeNullAttribute]
private static WeakToStrongDictionary`2<Graphics, GraphicsDpiRecord> myCache;
    [NotNullAttribute]
public static WeakToStrongDictionary`2<Graphics, GraphicsDpiRecord> Cache { get; }
    public static WeakToStrongDictionary`2<Graphics, GraphicsDpiRecord> get_Cache();
    public static void AdvertiseOriginatingControl(Graphics graphics, Control control);
    public static void AdvertiseOriginatingHwnd(Graphics graphics, Void* hwnd);
    public static void SetDpi(Graphics graphics, DpiResolution resolution);
}
internal class JetBrains.Util.NetFX.Interop.GraphicsContainers.HollowGraphicsContainer : object {
    public Graphics Graphics { get; }
    public sealed virtual Graphics get_Graphics();
    public sealed virtual void Dispose();
}
public interface JetBrains.Util.NetFX.Interop.GraphicsContainers.IGraphicsContainer {
    [NotNullAttribute]
public Graphics Graphics { get; }
    public abstract virtual Graphics get_Graphics();
}
public interface JetBrains.Util.NetFX.Interop.GraphicsContainers.IGraphicsContainerDpi {
    public Result`1<GraphicsDpiRecord> DpiRecord { get; }
    public abstract virtual Result`1<GraphicsDpiRecord> get_DpiRecord();
}
internal class JetBrains.Util.NetFX.Interop.GraphicsContainers.PaintGraphicsContainer : object {
    private bool myDisposed;
    private Graphics myGraphics;
    private Void* myHwnd;
    private PAINTSTRUCT myPaintStruct;
    public Graphics Graphics { get; }
    private IntPtr System.Windows.Forms.IWin32Window.Handle { get; }
    private Result`1<GraphicsDpiRecord> JetBrains.Util.NetFX.Interop.GraphicsContainers.IGraphicsContainerDpi.DpiRecord { get; }
    public PaintGraphicsContainer(Void* hwnd);
    public sealed virtual Graphics get_Graphics();
    public static Graphics op_Implicit(PaintGraphicsContainer pg);
    public sealed virtual void Dispose();
    private sealed virtual override IntPtr System.Windows.Forms.IWin32Window.get_Handle();
    private sealed virtual override Result`1<GraphicsDpiRecord> JetBrains.Util.NetFX.Interop.GraphicsContainers.IGraphicsContainerDpi.get_DpiRecord();
}
public class JetBrains.Util.NetFX.Interop.GraphicsContainers.ScreenGraphics : object {
    private Nullable`1<DpiResolution> myDpi;
    private LocalLazy`2<Graphics, Lifetime> myGraphics;
    private LifetimeDefinition myLifetimeDefinition;
    public Graphics Graphics { get; }
    private Result`1<GraphicsDpiRecord> JetBrains.Util.NetFX.Interop.GraphicsContainers.IGraphicsContainerDpi.DpiRecord { get; }
    public ScreenGraphics(DpiResolution dpi);
    [ObsoleteAttribute("Use GraphicsContainer::From* directly.")]
public ScreenGraphics(Control control);
    public sealed virtual Graphics get_Graphics();
    [NotNullAttribute]
public static Graphics CreateNewScreenGraphics(Lifetime lifetime);
    [ObsoleteAttribute("This class should only be used via an interface.")]
public static Graphics op_Implicit(ScreenGraphics sg);
    private sealed virtual override void System.IDisposable.Dispose();
    private sealed virtual override Result`1<GraphicsDpiRecord> JetBrains.Util.NetFX.Interop.GraphicsContainers.IGraphicsContainerDpi.get_DpiRecord();
}
internal class JetBrains.Util.NetFX.Interop.GraphicsContainers.SimpleGraphicsContainer : object {
    private Graphics myGraphics;
    private Control myControlOriginating;
    private Nullable`1<DpiResolution> myDpiIfKnown;
    public Graphics Graphics { get; }
    private IntPtr System.Windows.Forms.IWin32Window.Handle { get; }
    private Result`1<GraphicsDpiRecord> JetBrains.Util.NetFX.Interop.GraphicsContainers.IGraphicsContainerDpi.DpiRecord { get; }
    public SimpleGraphicsContainer(Graphics graphics, DpiResolution dpi);
    public SimpleGraphicsContainer(Graphics graphics);
    public SimpleGraphicsContainer(Graphics graphics, Control controlOriginating);
    public sealed virtual Graphics get_Graphics();
    public sealed virtual void Dispose();
    private sealed virtual override IntPtr System.Windows.Forms.IWin32Window.get_Handle();
    private sealed virtual override Result`1<GraphicsDpiRecord> JetBrains.Util.NetFX.Interop.GraphicsContainers.IGraphicsContainerDpi.get_DpiRecord();
}
[ExtensionAttribute]
public static class JetBrains.Util.NetFX.Interop.RectsW : object {
    public static Size MaxSize { get; }
    [PureAttribute]
public static Size get_MaxSize();
    [ExtensionAttribute]
[PureAttribute]
public static int AbsMaximum(Size size);
    [PureAttribute]
public static Rectangle AlignedCenter(Rectangle source, Rectangle bounds);
    [PureAttribute]
public static Rect AlignedCenter(Rect source, Rect bounds);
    [PureAttribute]
public static Rectangle AlignedCenter(Size source, Rectangle bounds);
    [PureAttribute]
public static Rect AlignedCenter(Size source, Rect bounds);
    [PureAttribute]
public static Rectangle AlignedCenterAndCropped(Rectangle source, Rectangle bounds);
    [PureAttribute]
public static Rectangle AlignedCenterAndCropped(Size source, Rectangle bounds);
    [PureAttribute]
public static Rect AlignedCenterAndCropped(Rect source, Rect bounds);
    [PureAttribute]
public static Rect AlignedCenterAndCropped(Size source, Rect bounds);
    [PureAttribute]
public static Rectangle AlignedCenterAndDownscaled(Rectangle source, Rectangle bounds);
    [PureAttribute]
public static Rect AlignedCenterAndDownscaled(Rect source, Rect bounds);
    [PureAttribute]
public static Rectangle AlignedCenterAndDownscaled(Size source, Rectangle bounds);
    [PureAttribute]
public static Rect AlignedCenterAndDownscaled(Size source, Rect bounds);
    [ExtensionAttribute]
[PureAttribute]
public static Rect AlignedWithin(Rect source, Rect bounds);
    [ExtensionAttribute]
[PureAttribute]
public static Rectangle AlignedWithinNoResize(Rectangle source, Rectangle bounds);
    [ExtensionAttribute]
[PureAttribute]
public static Rectangle AlignedWithinUsingMinSize(Rectangle source, Rectangle bounds, Size minSize);
    [ExtensionAttribute]
[PureAttribute]
public static Point AssertIsReal(Point pt, string failmessage);
    [ExtensionAttribute]
[PureAttribute]
public static Rect AssertIsReal(Rect rect, string failmessage);
    [ExtensionAttribute]
[PureAttribute]
public static Size AssertIsReal(Size size, string failmessage);
    public static Rectangle Attach(Rectangle& anchor, DockStyle dockstyle, int size);
    public static Rectangle Attach(Rectangle& anchor, DockStyle dockstyle, Size size);
    public static Rect Attach(Rect& anchor, Dock dockstyle, double size);
    public static Rect Attach(Rect& anchor, Dock dockstyle, Size size);
    public static Rectangle Attached(Rectangle anchor, DockStyle dockstyle, int size);
    public static Rectangle Attached(Rectangle anchor, DockStyle dockstyle, Size size);
    public static Rect Attached(Rect anchor, Dock dockstyle, double size);
    public static Rect Attached(Rect anchor, Dock dockstyle, Size size);
    [PureAttribute]
public static Rectangle ClippedSmart(Rectangle source, Rectangle bounds);
    [PureAttribute]
public static Rect ClippedSmart(Rect source, Rect bounds);
    [ExtensionAttribute]
[PureAttribute]
public static Point Collapsed(Rectangle rectangle, Anchoring2D how);
    [ExtensionAttribute]
[PureAttribute]
public static Point Collapsed(Rect rectangle, Anchoring2D how);
    [ExtensionAttribute]
[PureAttribute]
public static Size Constrained(Size source, Size limit);
    [ExtensionAttribute]
[PureAttribute]
public static Size Constrained(Size source, Size limit);
    [ExtensionAttribute]
[PureAttribute]
public static Rectangle Deflated(Rectangle source, int left, int top, int right, int bottom);
    [ExtensionAttribute]
[PureAttribute]
public static Rectangle Deflated(Rectangle source, Size size);
    [ExtensionAttribute]
[PureAttribute]
public static Rect Deflated(Rect source, Size size);
    [ExtensionAttribute]
[PureAttribute]
public static Rectangle Deflated(Rectangle source, Padding padding);
    [ExtensionAttribute]
[PureAttribute]
public static Rect Deflated(Rect source, Thickness thickness);
    public static Rectangle Dock(Rectangle& space, DockStyle dockstyle, int size);
    public static Rect Dock(Rect& space, Nullable`1<Dock> dock, double size);
    public static Rectangle Dock(Rectangle& space, DockStyle dockstyle, Size size);
    public static Rect Dock(Rect& space, Nullable`1<Dock> dock, Size size);
    [ExtensionAttribute]
[PureAttribute]
public static Rectangle Docked(Rectangle space, DockStyle dockstyle, int size);
    [ExtensionAttribute]
[PureAttribute]
public static Rect Docked(Rect space, Nullable`1<Dock> dock, double size);
    [ExtensionAttribute]
[PureAttribute]
public static Rectangle Docked(Rectangle space, DockStyle dockstyle, Size size);
    [ExtensionAttribute]
[PureAttribute]
public static Rect Docked(Rect space, Nullable`1<Dock> dock, Size size);
    [ExtensionAttribute]
[PureAttribute]
public static Size EnsuredEmptySize(Size size);
    [ExtensionAttribute]
[PureAttribute]
public static Size EnsuredEmptySize(Size size);
    [PureAttribute]
public static Rectangle FromLtrbNonnegative(int left, int top, int right, int bottom);
    [PureAttribute]
public static Rect FromLtrbNonnegative(double left, double top, double right, double bottom);
    [ExtensionAttribute]
[PureAttribute]
public static Rectangle[] GetBorder(Rectangle rect, Size dim);
    [ExtensionAttribute]
[PureAttribute]
public static Point GetCenter(Rectangle rect);
    [ExtensionAttribute]
[PureAttribute]
public static Point GetCenter(Rect rect);
    [ExtensionAttribute]
[PureAttribute]
public static Rectangle Inflated(Rectangle source, int left, int top, int right, int bottom);
    [ExtensionAttribute]
[PureAttribute]
public static Rectangle Inflated(Rectangle source, Size size);
    [ExtensionAttribute]
[PureAttribute]
public static Rectangle Inflated(Rectangle source, Padding padding);
    [ExtensionAttribute]
[PureAttribute]
public static Rect Inflated(Rect source, double left, double top, double right, double bottom);
    [ExtensionAttribute]
[PureAttribute]
public static Rect Inflated(Rect source, Size size);
    [ExtensionAttribute]
[PureAttribute]
public static Rect Inflated(Rect source, Thickness padding);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsCollapsed(Size size);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsCollapsed(Size size);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsCollapsed(Rectangle rect);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsCollapsed(Rect rect);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsCollapsed(Nullable`1<Rect> rect);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsConstrained(Size source, Size limit);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsConstrained(Size source, Size limit);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsEmptyArea(Size size);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsEmptyArea(Rectangle rect);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsInfinite(Size rect);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsNanOrInf(Point pt);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsNanOrInf(Size size);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsNanOrInf(Vector vector);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsNanOrInf(Rect rect);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsNormalized(Size size);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsNormalized(Size size);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsNormalized(Rectangle rect);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsNormalized(Rect rect);
    [PureAttribute]
public static Size Max(Size α, Size β);
    [PureAttribute]
public static Size Max(Size α, Size β);
    [ExtensionAttribute]
[PureAttribute]
public static Size MaxValuesToZeros(Size size);
    [PureAttribute]
public static Size Min(Size α, Size β);
    [PureAttribute]
public static Size Min(Size α, Size β);
    [ExtensionAttribute]
[PureAttribute]
public static Vector MultiplyElementWise(Vector vector, Vector other);
    [ExtensionAttribute]
[PureAttribute]
public static Size Negated(Size size);
    [ExtensionAttribute]
[PureAttribute]
public static Rectangle Normalized(Rectangle rect);
    [ExtensionAttribute]
[PureAttribute]
public static Rect Normalized(Rect rect);
    [ExtensionAttribute]
[PureAttribute]
public static Size Normalized(Size size);
    [ExtensionAttribute]
[PureAttribute]
[ObsoleteAttribute("Use Shifted, because its name correctly declares that it's a pure function which does not modify the object, while with Offset it's not clear.")]
public static Rectangle Offset(Rectangle source, Size offset);
    [ExtensionAttribute]
[PureAttribute]
[ObsoleteAttribute("Use Shifted, because its name correctly declares that it's a pure function which does not modify the object, while with Offset it's not clear.")]
public static Rectangle Offset(Rectangle source, Point offset);
    public static void SetBottom(Rectangle& source, int bottom);
    public static void SetBottom(Rect& source, double bottom);
    public static void SetLeft(Rectangle& source, int left);
    public static void SetLeft(Rect& source, double left);
    public static void SetRight(Rectangle& source, int right);
    public static void SetRight(Rect& source, double right);
    public static void SetTop(Rectangle& source, int top);
    public static void SetTop(Rect& source, double top);
    [ExtensionAttribute]
[PureAttribute]
public static Rectangle Shifted(Rectangle source, Size offset);
    [ExtensionAttribute]
[PureAttribute]
public static Rectangle Shifted(Rectangle source, Point offset);
    [PureAttribute]
public static Size Size(int width, int height);
    [PureAttribute]
public static Size Size(double width, double height);
    [PureAttribute]
public static Size Stack(IEnumerable`1<Size> sizes, double gap, Orientation orientation);
    [PureAttribute]
public static Size StackHorizontally(IEnumerable`1<Size> sizes, int gap);
    [PureAttribute]
public static Size StackHorizontally(int gap, Size[] sizes);
    [PureAttribute]
public static Size StackVertically(IEnumerable`1<Size> sizes, int gap);
    [PureAttribute]
public static Size StackVertically(int gap, Size[] sizes);
    [PureAttribute]
public static Rectangle Unioned(Rectangle one, Rectangle two);
    [PureAttribute]
public static Rect Unioned(Rect one, Rect two);
    [PureAttribute]
public static Rectangle UnionedHorizontally(Rectangle source, Rectangle other);
    [PureAttribute]
public static Rect UnionedHorizontally(Rect source, Rect other);
    [PureAttribute]
public static Rectangle UnionedVertically(Rectangle source, Rectangle other);
    [PureAttribute]
public static Rect UnionedVertically(Rect source, Rect other);
    [PureAttribute]
public static Rectangle WithBottom(Rectangle source, int bottom);
    [PureAttribute]
public static Rect WithBottom(Rect source, double bottom);
    [PureAttribute]
public static Rectangle WithLeft(Rectangle source, int left);
    [PureAttribute]
public static Rect WithLeft(Rect source, double left);
    [PureAttribute]
public static Rectangle WithRight(Rectangle source, int right);
    [PureAttribute]
public static Rect WithRight(Rect source, double right);
    [PureAttribute]
public static Rectangle WithTop(Rectangle source, int top);
    [PureAttribute]
public static Rect WithTop(Rect source, double top);
    [ExtensionAttribute]
[PureAttribute]
public static Size WithZerosToMaxValues(Size size);
    [PureAttribute]
private static Size StackImpl(IEnumerable`1<Size> sizes, int gap, bool bHorizontally);
}
[ExtensionAttribute]
public static class JetBrains.Util.NetFX.Interop.SizeAndLength : object {
    [ExtensionAttribute]
[PureAttribute]
public static Point ToAvalonPoint(Point value, DpiResolution resolution);
    [ExtensionAttribute]
[PureAttribute]
public static Point ToAvalonPoint(PointF value, DpiResolution resolution);
    [ExtensionAttribute]
[PureAttribute]
public static Point ToAvalonPoint96(Point value);
    [ExtensionAttribute]
[PureAttribute]
public static Rect ToAvalonRect(Rectangle value, DpiResolution resolution);
    [ExtensionAttribute]
[PureAttribute]
public static Rect ToAvalonRect(RectangleF value, DpiResolution resolution);
    [ExtensionAttribute]
[PureAttribute]
public static Rect ToAvalonRect96(Rectangle value);
    [ExtensionAttribute]
[PureAttribute]
public static Size ToAvalonSize(SizeF value, DpiResolution resolution);
    [ExtensionAttribute]
[PureAttribute]
public static Size ToAvalonSize(Size value, DpiResolution resolution);
    [ExtensionAttribute]
[PureAttribute]
public static Size ToAvalonSize96(Size value);
    [ExtensionAttribute]
[PureAttribute]
public static Thickness ToAvalonThickness(Padding value, DpiResolution resolution);
    [ExtensionAttribute]
[PureAttribute]
public static Vector ToAvalonVector(SizeF value, DpiResolution resolution);
    [ExtensionAttribute]
[PureAttribute]
public static Vector ToAvalonVector(Size value, DpiResolution resolution);
    [ExtensionAttribute]
[PureAttribute]
public static Vector ToAvalonVector96(Size value);
    [ExtensionAttribute]
[PureAttribute]
public static int ToWinFormsHeight(double length, DpiResolution dpi);
    [ExtensionAttribute]
[PureAttribute]
public static Padding ToWinFormsPadding(Thickness value, DpiResolution resolution);
    [ExtensionAttribute]
[PureAttribute]
public static Point ToWinFormsPoint96(Point value);
    [ExtensionAttribute]
[PureAttribute]
public static Point ToWinFormsPointCeiling(Point value, DpiResolution resolution);
    [ExtensionAttribute]
[PureAttribute]
public static PointF ToWinFormsPointF96(Point value);
    [ExtensionAttribute]
[PureAttribute]
public static Point ToWinFormsPointFloor(Point value, DpiResolution resolution);
    [ExtensionAttribute]
[PureAttribute]
public static Point ToWinFormsPointRounded(Point value, DpiResolution resolution);
    [ExtensionAttribute]
[PureAttribute]
public static Rectangle ToWinFormsRectangle(Rect value, DpiResolution dpi);
    [ExtensionAttribute]
[PureAttribute]
public static Rectangle ToWinFormsRectangle96(Rect value);
    [ExtensionAttribute]
[PureAttribute]
public static RectangleF ToWinFormsRectangleF96(Rect value);
    [ExtensionAttribute]
[PureAttribute]
public static Size ToWinFormsSize(Vector value, DpiResolution resolution);
    [ExtensionAttribute]
[PureAttribute]
public static Size ToWinFormsSize(Size value, DpiResolution resolution);
    [ExtensionAttribute]
[PureAttribute]
public static Size ToWinFormsSize96(Size value);
    [ExtensionAttribute]
[PureAttribute]
public static Size ToWinFormsSizeCeiling(Vector value, DpiResolution resolution);
    [ExtensionAttribute]
[PureAttribute]
public static SizeF ToWinFormsSizeF(Vector value, DpiResolution resolution);
    [ExtensionAttribute]
[PureAttribute]
public static SizeF ToWinFormsSizeF(Size value, DpiResolution resolution);
    [ExtensionAttribute]
[PureAttribute]
public static Size ToWinFormsSizeRounded(Size value, DpiResolution resolution);
    [ExtensionAttribute]
[PureAttribute]
public static int ToWinFormsWidth(double length, DpiResolution dpi);
    [PureAttribute]
private static int AvalonLengthToWinFormsLength_Ceiling(double length, double dpi);
    [PureAttribute]
private static int AvalonLengthToWinFormsLength_Floor(double length, double dpi);
    [PureAttribute]
private static int AvalonLengthToWinFormsLength_Round(double length, double dpi);
    [PureAttribute]
private static double WinFormsLengthToAvalonLength(int length, double dpi);
    [PureAttribute]
private static double WinFormsLengthToAvalonLength(float length, double dpi);
}
public class JetBrains.Util.NetFX.Media.Colors.ColorManagementWinUI : object {
    public static Color MakeMonochrome(Color colorSrc, Color colorBias);
    public static BitmapSource MakeMonochrome(BitmapSource bmpSrc, Color colorBias);
    public static Color Mix(Color colorA, Color colorB, double proportion);
    public static UInt32 RGB(Color color);
}
[ExtensionAttribute]
public static class JetBrains.Util.NetFX.Media.Colors.ColorsWinEx : object {
    [ExtensionAttribute]
public static UInt32 BGR(Color color);
    [ExtensionAttribute]
public static Color MixWith(Color first, Color second, float firstpercentage);
    public static Nullable`1<Color> ParseWPFColor(string colorText);
    [ExtensionAttribute]
public static UInt32 RGB(Color color);
    [ExtensionAttribute]
[NotNullAttribute]
public static SolidColorBrush ToAvalonBrush(JetRgbaColor value);
    [ExtensionAttribute]
public static Color ToAvalonColor(Color value);
    [ExtensionAttribute]
public static Color ToAvalonColor(JetRgbaColor value);
    [ExtensionAttribute]
public static JetRgbaColor ToJetRgbaColor(Color value);
    [ExtensionAttribute]
public static JetRgbaColor ToJetRgbaColor(Color value);
    [ExtensionAttribute]
public static JetRgbaColor ToJetRgbaColor(JetRgbaColor value);
    [ExtensionAttribute]
public static Color ToWinFormsColor(Color value);
    [ExtensionAttribute]
public static Color ToWinFormsColor(JetRgbaColor value);
}
public static class JetBrains.Util.NetFX.Media.Colors.JetSystemColors : object {
    public static JetRgbaColor ActiveBorder { get; }
    public static JetRgbaColor ActiveCaption { get; }
    public static JetRgbaColor ActiveCaptionText { get; }
    public static JetRgbaColor AppWorkspace { get; }
    public static JetRgbaColor ButtonFace { get; }
    public static JetRgbaColor ButtonHighlight { get; }
    public static JetRgbaColor ButtonShadow { get; }
    public static JetRgbaColor Control { get; }
    public static JetRgbaColor ControlDark { get; }
    public static JetRgbaColor ControlDarkDark { get; }
    public static JetRgbaColor ControlLight { get; }
    public static JetRgbaColor ControlLightLight { get; }
    public static JetRgbaColor ControlText { get; }
    public static JetRgbaColor Desktop { get; }
    public static JetRgbaColor GradientActiveCaption { get; }
    public static JetRgbaColor GradientInactiveCaption { get; }
    public static JetRgbaColor GrayText { get; }
    public static JetRgbaColor Highlight { get; }
    public static JetRgbaColor HighlightText { get; }
    public static JetRgbaColor HotTrack { get; }
    public static JetRgbaColor InactiveBorder { get; }
    public static JetRgbaColor InactiveCaption { get; }
    public static JetRgbaColor InactiveCaptionText { get; }
    public static JetRgbaColor Info { get; }
    public static JetRgbaColor InfoText { get; }
    public static JetRgbaColor Menu { get; }
    public static JetRgbaColor MenuBar { get; }
    public static JetRgbaColor MenuHighlight { get; }
    public static JetRgbaColor MenuText { get; }
    public static JetRgbaColor ScrollBar { get; }
    public static JetRgbaColor Window { get; }
    public static JetRgbaColor WindowFrame { get; }
    public static JetRgbaColor WindowText { get; }
    public static JetRgbaColor get_ActiveBorder();
    public static JetRgbaColor get_ActiveCaption();
    public static JetRgbaColor get_ActiveCaptionText();
    public static JetRgbaColor get_AppWorkspace();
    public static JetRgbaColor get_ButtonFace();
    public static JetRgbaColor get_ButtonHighlight();
    public static JetRgbaColor get_ButtonShadow();
    public static JetRgbaColor get_Control();
    public static JetRgbaColor get_ControlDark();
    public static JetRgbaColor get_ControlDarkDark();
    public static JetRgbaColor get_ControlLight();
    public static JetRgbaColor get_ControlLightLight();
    public static JetRgbaColor get_ControlText();
    public static JetRgbaColor get_Desktop();
    public static JetRgbaColor get_GradientActiveCaption();
    public static JetRgbaColor get_GradientInactiveCaption();
    public static JetRgbaColor get_GrayText();
    public static JetRgbaColor get_Highlight();
    public static JetRgbaColor get_HighlightText();
    public static JetRgbaColor get_HotTrack();
    public static JetRgbaColor get_InactiveBorder();
    public static JetRgbaColor get_InactiveCaption();
    public static JetRgbaColor get_InactiveCaptionText();
    public static JetRgbaColor get_Info();
    public static JetRgbaColor get_InfoText();
    public static JetRgbaColor get_Menu();
    public static JetRgbaColor get_MenuBar();
    public static JetRgbaColor get_MenuHighlight();
    public static JetRgbaColor get_MenuText();
    public static JetRgbaColor get_ScrollBar();
    public static JetRgbaColor get_Window();
    public static JetRgbaColor get_WindowFrame();
    public static JetRgbaColor get_WindowText();
    private static JetRgbaColor GetSystemColorValue(SystemColorCode code);
}
public static class JetBrains.Util.NetFX.Media.Colors.SystemColorsWin : object {
    public static JetRgbaColor GetSystemColorValue(SystemColorCode code);
}
public static class JetBrains.Util.NetFX.Media.Icons.IconPlaceholderWindows : object {
    private static DrawingImage myIconPlaceholderAvalon;
    private static Bitmap myIconPlaceholderGdip;
    [NotNullAttribute]
public static Bitmap IconPlaceholderGdip { get; }
    [NotNullAttribute]
public static DrawingImage IconPlaceholderAvalon { get; }
    public static Bitmap get_IconPlaceholderGdip();
    public static DrawingImage get_IconPlaceholderAvalon();
}
public static class JetBrains.Util.NetFX.Media.Icons.TiImageConverterAscii : object {
    [NotNullAttribute]
[PureAttribute]
public static IList`1<string> ToAsciiLines(TiImage image, JetPhysicalSize charsize, bool isDarkForeground);
    [NotNullAttribute]
[PureAttribute]
public static string ToAsciiText(TiImage image, JetPhysicalSize charsize, bool isDarkForeground);
}
public static class JetBrains.Util.NetFX.Media.Icons.TiImageConverterAvalon : object {
    [NotNullAttribute]
[PureAttribute]
public static TiRasterImage FromAvalonBitmap(BitmapSource bitmap);
    [NotNullAttribute]
[PureAttribute]
public static TiVectorImage FromAvalonDrawing(Drawing drawing, OnError onerror);
    [NotNullAttribute]
[PureAttribute]
public static TiImage FromAvalonImageSource(ImageSource imagesource, OnError onerror);
    [NotNullAttribute]
[PureAttribute]
public static BitmapSource ToAvalonBitmap(TiRasterImage tiraster);
    [NotNullAttribute]
[PureAttribute]
public static Drawing ToAvalonDrawing(TiVectorImage tiimage);
    [NotNullAttribute]
[PureAttribute]
public static ImageSource ToAvalonImage(TiImage tiimage);
    [NotNullAttribute]
private static PathGeometry FromAvalonDrawing_ConvertToPathAndPremulTransform(Geometry geometryOriginal, Transform transformToOrigin);
    private static TiBrush FromAvalonDrawing_Geometry_Brush(Brush brush, Rect boundsGeometry, OnError onerror);
    private static bool FromAvalonDrawing_Geometry_Brush_IsRelativeTransformRadialTrivial(RadialGradientBrush radial);
    private static void FromAvalonDrawing_GeometryDrawing(GeometryDrawing geometry, Builder<TiPath> paths, TranslateTransform transformToOrigin, OnError onerror);
    private static void FromAvalonDrawing_Match(Drawing drawing, Builder<TiPath> paths, Builder<TiSegment> clipmask, TranslateTransform transformToOrigin, bool isTopLevel, OnError onerror);
    private static ImmutableArray`1<TiSegment> FromAvalonDrawing_PathGeometry(PathGeometry apath, OnError onerror);
    [CanBeNullAttribute]
private static Brush ToAvalonDrawing_Brush(TiBrush fill);
    [NotNullAttribute]
private static StreamGeometry ToAvalonDrawing_StreamGeometry(IList`1<TiSegment> tisegments);
    private static void AssertKnownProperties(DependencyObject dobj, DependencyProperty[] prop, OnError onerror);
}
public static class JetBrains.Util.NetFX.Media.Icons.TiImageConverterGdip : object {
    [NotNullAttribute]
[PureAttribute]
public static Bitmap ToGdipBitmap(TiImage tiimage, DpiResolution resolution, Nullable`1<JetSize> size);
    [NotNullAttribute]
[PureAttribute]
public static Bitmap ToGdipBitmap(TiRasterImage tiraster);
    [NotNullAttribute]
[PureAttribute]
public static Bitmap ToGdipBitmapAvalonRendered(TiImage tiimage, DpiResolution resolution, Nullable`1<JetSize> size);
    [NotNullAttribute]
[PureAttribute]
public static Bitmap ToGdipBitmapManuallyRendered(TiImage tiimage, DpiResolution resolution, Nullable`1<JetSize> size);
    [NotNullAttribute]
[PureAttribute]
public static Action`1<Graphics> ToGdipPainting(TiImage tiimage);
    [NotNullAttribute]
[PureAttribute]
public static TiRasterImage FromGdipBitmap(Bitmap bitmap);
    [NotNullAttribute]
private static ColorBlend ToGdipPainting_Vector_PaintPath_Blend(List`1<TiGradientStop> stops, bool isReversed);
    private static Matrix ToGdipPainting_Vector_PaintPath_Matrix(Matrix m);
    [NotNullAttribute]
private static GraphicsPath ToGdipPainting_GraphicsPath(IList`1<TiSegment> tisegments);
    private static void ToGdipPainting_Vector(TiVectorImage tiimage, Graphics g);
    private static void ToGdipPainting_Vector_PaintPath(TiPath tipath, Graphics graphics);
    [CompilerGeneratedAttribute]
internal static FrugalLocalList`1<TiGradientStop> <ToGdipPainting_Vector_PaintPath>g__AdjustStopTransparencyForGdip|10_0(FrugalLocalList`1& stops);
}
public class JetBrains.Util.NetFX.Reflection.ModalUITypeEditor : UITypeEditor {
    private Func`1<object> myEditFunc;
    public ModalUITypeEditor(Func`1<object> editFunc);
    public virtual UITypeEditorEditStyle GetEditStyle(ITypeDescriptorContext context);
    public virtual object EditValue(ITypeDescriptorContext context, IServiceProvider provider, object value);
    [CompilerGeneratedAttribute]
private object <EditValue>b__3_0();
}
public class JetBrains.Util.NetFX.Reflection.PropertyDescriptorArgs : object {
    public static string DefaultCategoryName;
    [CompilerGeneratedAttribute]
private string <Category>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DisplayName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsReadOnly>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasModalUITypeEditor>k__BackingField;
    [CompilerGeneratedAttribute]
private Attribute[] <CustomAttributes>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <PropertyType>k__BackingField;
    [CompilerGeneratedAttribute]
private object <DefaultValue>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ConverterType>k__BackingField;
    public string Category { get; public set; }
    [NotNullAttribute]
public string Name { get; }
    [NotNullAttribute]
public string DisplayName { get; }
    [NotNullAttribute]
public string Description { get; }
    public bool IsReadOnly { get; public set; }
    public bool HasModalUITypeEditor { get; public set; }
    [CanBeNullAttribute]
public Attribute[] CustomAttributes { get; public set; }
    [NotNullAttribute]
public Type PropertyType { get; }
    [CanBeNullAttribute]
public object DefaultValue { get; public set; }
    [CanBeNullAttribute]
public Type ConverterType { get; public set; }
    public PropertyDescriptorArgs(string name, string displayName, string description, Type propertyType);
    [CompilerGeneratedAttribute]
public string get_Category();
    [CompilerGeneratedAttribute]
public void set_Category(string value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public string get_DisplayName();
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
public bool get_IsReadOnly();
    [CompilerGeneratedAttribute]
public void set_IsReadOnly(bool value);
    [CompilerGeneratedAttribute]
public bool get_HasModalUITypeEditor();
    [CompilerGeneratedAttribute]
public void set_HasModalUITypeEditor(bool value);
    [CompilerGeneratedAttribute]
public Attribute[] get_CustomAttributes();
    [CompilerGeneratedAttribute]
public void set_CustomAttributes(Attribute[] value);
    [CompilerGeneratedAttribute]
public Type get_PropertyType();
    [CompilerGeneratedAttribute]
public object get_DefaultValue();
    [CompilerGeneratedAttribute]
public void set_DefaultValue(object value);
    [CompilerGeneratedAttribute]
public Type get_ConverterType();
    [CompilerGeneratedAttribute]
public void set_ConverterType(Type value);
}
public class JetBrains.Util.NetFX.Reflection.PropertyDescriptorArgs`1 : PropertyDescriptorArgs {
    [CanBeNullAttribute]
public T DefaultValue { get; public set; }
    public PropertyDescriptorArgs`1(string name, string displayName, string description);
    public T get_DefaultValue();
    public void set_DefaultValue(T value);
}
[ExtensionAttribute]
public static class JetBrains.Util.NetFX.Reflection.PropertyDescriptorArgsEx : object {
    [ExtensionAttribute]
public static Attribute[] CreateAttributes(PropertyDescriptorArgs args);
    [ExtensionAttribute]
public static PropertyDescriptorArgs ToPropertyDescriptorArgs(PropertyDescriptor descriptor);
}
public class JetBrains.Util.NetFX.Reflection.SimplePropertyDescriptor : PropertyDescriptor {
    [CanBeNullAttribute]
private Func`2<object, object> myGetValueFunc;
    [CanBeNullAttribute]
private Action`2<object, object> mySetValueFunc;
    [CanBeNullAttribute]
private ModalUITypeEditor myModalUITypeEditor;
    private object myDefaultValue;
    [CompilerGeneratedAttribute]
private bool <IsReadOnly>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <PropertyType>k__BackingField;
    public Type ComponentType { get; }
    public bool IsReadOnly { get; }
    public Type PropertyType { get; }
    public SimplePropertyDescriptor(PropertyDescriptorArgs args, Func`2<object, object> getValueFunc, Action`2<object, object> setValueFunc, ModalUITypeEditor modalUITypeEditor);
    public virtual bool CanResetValue(object component);
    public virtual object GetValue(object component);
    public virtual void ResetValue(object component);
    public virtual void SetValue(object component, object value);
    public virtual bool ShouldSerializeValue(object component);
    public virtual object GetEditor(Type editorBaseType);
    public virtual Type get_ComponentType();
    [CompilerGeneratedAttribute]
public virtual bool get_IsReadOnly();
    [CompilerGeneratedAttribute]
public virtual Type get_PropertyType();
}
public class JetBrains.Util.NetFX.Reflection.SimplePropertyDescriptor`2 : SimplePropertyDescriptor {
    public SimplePropertyDescriptor`2(PropertyDescriptorArgs`1<TProperty> args, Func`2<TComponent, TProperty> getValueFunc, Action`2<TComponent, TProperty> setValueFunc, ModalUITypeEditor modalUITypeEditor);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
