public class JetBrains.Profiler.Windows.SysTools.AttachEnvironmentTools : BaseServiceRemotable`1<SysTools> {
    private static ILogger ourLogger;
    private static string UpidPrefix;
    private static string JBDpaPrefix;
    private static FileSystemPath ourUpidParentDirectory;
    public AttachEnvironmentTools(SysTools root, String[] ids, ServiceCreatorDelegate<SysTools> serviceCreator);
    private static AttachEnvironmentTools();
    [RemotableCallAttribute]
public virtual void CleanAllProcessesEnvironment(CleanEnvironmentProperty[] cleanProperties);
    [RemotableCallAttribute]
public virtual void CleanProcessEnvironment(int processId, CleanEnvironmentProperty[] cleanProperties);
    [RemotableCallAttribute]
public virtual void UpdateProcessEnvironment(int processId, UpdateEnvironmentProperty[] updateProperties);
    [NotNullAttribute]
private string GetDpaDisableEventName(int processId);
    public bool AcquireProfilingEvent(Lifetime lifetime, int processId, int timeout);
    [NotNullAttribute]
private string MakeUpidSubName(int processId, string prefix);
    private static bool UpidPrefixFilter(string name);
    private static void CleanAll(RegistryHiveAccess key);
    [CanBeNullAttribute]
private static string FilterProduct(EnvironmentPropertyType type, string key);
    private static void Clean(RegistryHiveAccess key, string name);
    private static void Update(RegistryHiveAccess key, string name, IEnumerable`1<UpdateEnvironmentProperty> updateProperties);
    private static void Update(FileSystemPath file, IEnumerable`1<UpdateEnvironmentProperty> updateProperties);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class JetBrains.Profiler.Windows.SysTools.AttachTools : BaseServiceRemotable`1<SysTools> {
    private static ILogger ourLogger;
    private Dictionary`2<JetArchitecture, FileSystemPath> myExecutables;
    private ReactiveState`2<ProcessCollection, ProcessCollectContext> myProcesses;
    private bool myPrefetch;
    private double myTickKoeff;
    [CompilerGeneratedAttribute]
private bool <UseAttachHelper>k__BackingField;
    [CompilerGeneratedAttribute]
private ProcessMetricsModes <ProcessMetricsMode>k__BackingField;
    public bool UseAttachHelper { get; public set; }
    public ProcessMetricsModes ProcessMetricsMode { get; public set; }
    public AttachTools(SysTools root, String[] ids, ServiceCreatorDelegate<SysTools> serviceCreator);
    private static AttachTools();
    [CompilerGeneratedAttribute]
[RemotableCallAttribute]
public virtual bool get_UseAttachHelper();
    [CompilerGeneratedAttribute]
[RemotableCallAttribute]
public virtual void set_UseAttachHelper(bool value);
    [CompilerGeneratedAttribute]
[RemotableCallAttribute]
public virtual ProcessMetricsModes get_ProcessMetricsMode();
    [CompilerGeneratedAttribute]
[RemotableCallAttribute]
public virtual void set_ProcessMetricsMode(ProcessMetricsModes value);
    [RemotableCallAttribute]
public virtual void Prepare();
    [RemotableCallAttribute]
public virtual void SetupPrefetch(ProcessCollectContext init);
    private ReactiveState`2<ProcessCollection, ProcessCollectContext> CreateProcessCollection(ProcessCollectContext context, ProcessCollection init);
    [RemotableCallAttribute]
public virtual bool HasExecutable(JetArchitecture architecture);
    [NullableContextAttribute("2")]
[RemotableCallAttribute]
public virtual void SetExecutable(JetArchitecture architecture, string fileName);
    [RemotableLongCallAttribute]
public virtual void AttachProfiling(JetArchitecture architecture, int processId, RuntimeInfo runtime, Guid profileGuid, string profilerDll);
    private static Nullable`1<bool> IsCoreClrLoadedMac(int processId);
    private static Nullable`1<bool> IsCoreClrLoadedLinux(int processId);
    private static Nullable`1<bool> IsCoreClrLoadedInProcess(int processId);
    [RemotableLongCallAttribute]
public virtual IEnumerable`1<ProcessInfo> GetProcessesToAttach2(ProcessCollectContext ctx);
    [RemotableLongCallAttribute]
public virtual IEnumerable`1<ProcessInfo> GetProcessesToAttach(bool native, bool monoVm);
    private ProcessCollection GetProcessesToAttachImpl(ProcessCollection prev, ProcessCollectContext ctx);
    public void UpdateDisplay(AttachArgument argument);
    private ProcessCollection CollectWindowsProcesses(ProcessCollectContext ctx);
    private ProcessCollection CollectWindowsProcessesByArch(JetArchitecture arch, ProcessCollectContext ctx);
    private double GetMachoTicksKoeff();
    private ProcessCollection CollectUnixProcesses(ProcessCollectContext ctx);
    private Nullable`1<ProcessState> GetUnixProcess(int pid, ProcessCollectContext ctx, DateTime now, Func`2<int, bool> monoDetector);
    private void EnrichWithMetrics(ProcessCollection prev, ProcessCollection cur);
    private static FileSystemPath CheckExecutable(FileSystemPath executable);
    private FileSystemPath GetExecutable(JetArchitecture architecture);
    private void RunAttachHelper(JetArchitecture architecture, Func`3<FileSystemPath, Func`1<FileSystemPath>, String[]> getArguments, Func`2<FileSystemPath, Tuple`2<HResults, string>> parseResult);
    private T RunAttachHelper(JetArchitecture architecture, Func`3<FileSystemPath, Func`1<FileSystemPath>, String[]> getArguments, Func`2<FileSystemPath, Tuple`3<HResults, string, T>> parseResult);
    private static bool IsClrSupportAttach(Version version);
    [CompilerGeneratedAttribute]
private ProcessCollection <CreateProcessCollection>b__21_0(ProcessCollection prev, ProcessCollectContext arg);
}
public class JetBrains.Profiler.Windows.SysTools.CleanEnvironmentProperty : object {
    [NotNullAttribute]
public string Key;
    [CanBeNullAttribute]
private object myValue;
    public EnvironmentPropertyType Type;
    public Actions Action { get; }
    [NotNullAttribute]
public String[] StringListValue { get; }
    private CleanEnvironmentProperty(EnvironmentPropertyType type, string key, object value);
    public Actions get_Action();
    public String[] get_StringListValue();
    public bool IsMatch(string key);
    [NotNullAttribute]
public static CleanEnvironmentProperty Create(EnvironmentPropertyType type, string key);
    [NotNullAttribute]
public static CleanEnvironmentProperty CreatePrefix(EnvironmentPropertyType type, string key);
    [CanBeNullAttribute]
public static CleanEnvironmentProperty CreateRemoveFromPathListByWildcard(EnvironmentPropertyType type, string key, String[] value);
    public virtual string ToString();
}
public class JetBrains.Profiler.Windows.SysTools.CommunicationTools : BaseServiceRemotable`1<SysTools> {
    private static int TimeoutExpired;
    private static ILogger ourLogger;
    private WatchedDictionary`1<IListener> myListeners;
    private WatchedDictionary`1<ICommunicationToolsStream> myStreams;
    public CommunicationTools(SysTools root, String[] ids, ServiceCreatorDelegate<SysTools> serviceCreator);
    private static CommunicationTools();
    [NotNullAttribute]
private List`1<Guid> AcceptSocket(Guid listenerId, int timeout);
    protected virtual void OnDispose();
    [NotRemotableAttribute]
[NotNullAttribute]
public virtual IListenerProxy CreateSocketListener(Lifetime lifetime, IPEndPoint endPoint);
    [NotRemotableAttribute]
[NotNullAttribute]
public virtual IListenerProxy CreateNamedPipeListener(Lifetime lifetime);
    [NotRemotableAttribute]
[NotNullAttribute]
public virtual IChannelProxy CreateCoreControl(Lifetime lifetime, Guid streamId);
    [RemotableCallAttribute]
public virtual ushort GetFreeTcpListenPort(IPEndPoint endPoint);
    [RemotableCallAttribute]
public virtual bool CheckForTcpListenPort(IPEndPoint endPoint);
    [RemotableCallAttribute]
public virtual int GetProcessForTcpListenPort(IPEndPoint endPoint);
    [RemotableCallAttribute]
public virtual int GetPortOwningProcess(ushort port);
    [RemotableCallAttribute]
public virtual Guid SocketListener_Create(IPEndPoint endPoint);
    [RemotableCallAttribute]
public virtual Guid NamedPipeListener_Create();
    [RemotableCallAttribute]
public virtual string Listener_GetEndPoint(Guid listenerId);
    [RemotableLongCallAttribute]
public virtual Guid[] Listener_GetNewStreamIds(Guid listenerId, TimeSpan timeout);
    [RemotableLongCallAttribute]
public virtual Guid[] Listener_GetNewStreamIds(Guid listenerId, int timeout);
    [RemotableCallAttribute]
public virtual void Listener_Touch(Guid listenerId);
    [RemotableCallAttribute]
public virtual void Listener_Close(Guid listenerId);
    [RemotableCallAttribute]
public virtual void Listener_InjectProxyStreamFactory(Guid listenerId, Type type, Object[] args);
    [RemotableLongCallAttribute]
public virtual bool Channel_HasDataToRead(Guid streamId, int timeout);
    [NotNullAttribute]
[RemotableCallAttribute]
public virtual Tuple`2<byte, Byte[]> Channel_ReceiveCommand(Guid streamId);
    [RemotableCallAttribute]
public virtual void Channel_SendCommand(Guid streamId, byte command, Byte[] data);
    [RemotableCallAttribute]
public virtual void Channel_Touch(Guid streamId);
    [RemotableCallAttribute]
public virtual void Channel_Close(Guid streamId);
}
public class JetBrains.Profiler.Windows.SysTools.CommunicationToolsBaseStreamProxy : object {
    private ICommunicationToolsStream myBaseStream;
    public CommunicationToolsBaseStreamProxy(ICommunicationToolsStream baseStream);
    public virtual Tuple`2<byte, Byte[]> ReceiveCommand();
    public virtual bool HasDataToRead(int timeout);
    public virtual void SendCommand(byte command, Byte[] data);
    public virtual void Shutdown();
    public virtual void Close();
}
public class JetBrains.Profiler.Windows.SysTools.CommunicationToolsNamedPipeStream : object {
    private NamedPipeServerStream myPipe;
    [CanBeNullAttribute]
private IAsyncResult myWaitForCommandAsyncResult;
    private Byte[] myWaitForCommandAsyncResultBuffer;
    public CommunicationToolsNamedPipeStream(NamedPipeServerStream pipe);
    public sealed virtual Tuple`2<byte, Byte[]> ReceiveCommand();
    public sealed virtual bool HasDataToRead(int timeout);
    public sealed virtual void SendCommand(byte command, Byte[] data);
    public sealed virtual void Shutdown();
    public sealed virtual void Close();
}
public class JetBrains.Profiler.Windows.SysTools.CommunicationToolsSocketStream : object {
    private Socket mySocket;
    public CommunicationToolsSocketStream(Socket socket);
    public sealed virtual Tuple`2<byte, Byte[]> ReceiveCommand();
    public sealed virtual bool HasDataToRead(int timeout);
    public sealed virtual void SendCommand(byte command, Byte[] data);
    public sealed virtual void Shutdown();
    public sealed virtual void Close();
}
public class JetBrains.Profiler.Windows.SysTools.CoreClrTools : BaseServiceRemotable`1<SysTools> {
    private static ILogger ourLogger;
    private static MessageResult ourMessageResult_NoDotNetDetected;
    private static MessageResult ourMessageResult_Communication;
    public CoreClrTools(SysTools root, String[] ids, ServiceCreatorDelegate<SysTools> serviceCreator);
    private static CoreClrTools();
    [CanBeNullAttribute]
[RemotableCallAttribute]
public virtual string TryGetDotNetExecutable();
    [NotRemotableAttribute]
[NotNullAttribute]
public virtual string GetDotNetExecutable();
    [NotRemotableAttribute]
[NotNullAttribute]
public MessageResult IsSupported(HostCompatibilityOptions options);
    [NotNullAttribute]
private static FileSystemPath TryGetDotNetRoot();
    [CompilerGeneratedAttribute]
private MessageResult <IsSupported>b__6_0();
}
public class JetBrains.Profiler.Windows.SysTools.CoreFiles.HandleConverterProxy : CommunicationToolsBaseStreamProxy {
    private static ILogger ourLogger;
    [NotNullAttribute]
private Process mySrcProcess;
    [CanBeNullAttribute]
private Process myCoreProcess;
    private UInt32 myCoreProcessId;
    private Answer myCurrentCommand;
    public HandleConverterProxy(SysTools sysTools, ICommunicationToolsStream baseStream, UInt32 srcProcessId, ILifetimeIdentity lifetimeIdentity);
    private static HandleConverterProxy();
    public virtual Tuple`2<byte, Byte[]> ReceiveCommand();
    public virtual void SendCommand(byte command, Byte[] data);
    [CompilerGeneratedAttribute]
private void <.ctor>b__5_0();
}
public class JetBrains.Profiler.Windows.SysTools.CoreFiles.RemoteAgentFilesProxy : CommunicationToolsBaseStreamProxy {
    private static ILogger ourLogger;
    private static Process ourAgentProcess;
    private static Tuple`2<byte, Byte[]> ourIdleCommand;
    [NotNullAttribute]
private ILifetimeIdentity mySessionLifetimeIdentity;
    [NotNullAttribute]
private SysTools mySysTools;
    [NotNullAttribute]
private FileSystemPath myTempDir;
    [CanBeNullAttribute]
private Process myCoreProcess;
    public RemoteAgentFilesProxy(SysTools sysTools, ICommunicationToolsStream baseStream, ILifetimeIdentity connectionLifetimeIdentity, ILifetimeIdentity sessionLifetimeIdentity);
    private static RemoteAgentFilesProxy();
    public virtual Tuple`2<byte, Byte[]> ReceiveCommand();
    private void SendAnonymousFileHandle(UInt32 correlationId, IntPtr handle, Answer answer);
    private void SendIdentifiedFile(UInt32 correlationId, Guid id, IntPtr handle, Answer answer);
    [CompilerGeneratedAttribute]
private void <.ctor>b__7_0();
}
public class JetBrains.Profiler.Windows.SysTools.CoreInfo : object {
    public Guid Core;
    [NotNullAttribute]
public string Name;
    public CoreInfo(string name, Guid core);
}
public class JetBrains.Profiler.Windows.SysTools.DirectoryTools : BaseServiceRemotable`1<SysTools> {
    public DirectoryTools(SysTools root, String[] ids, ServiceCreatorDelegate<SysTools> serviceCreator);
    [RemotableCallAttribute]
public virtual string GetGlobalTemp();
    [RemotableCallAttribute]
public virtual string GetTemp();
    [RemotableCallAttribute]
public virtual string CreateGlobalTempDirectory(string prefix);
    [RemotableCallAttribute]
public virtual string CreateUserTempDirectory(string prefix);
    [RemotableCallAttribute]
public virtual DirectoryInfo GetInfo(string remotePath);
    [RemotableCallAttribute]
public virtual bool ExistsDirectory(string remotePath);
    [RemotableCallAttribute]
public virtual void CreateDirectory(string remotePath);
    [RemotableCallAttribute]
public virtual void DeleteDirectory(string remotePath);
    [RemotableCallAttribute]
public virtual String[] GetChildDirectories(string remotePath, string searchPattern);
    [RemotableCallAttribute]
public virtual String[] GetChildFiles(string remotePath, string searchPattern);
    [RemotableCallAttribute]
public virtual void CreateSymbolicLink(string remotePath, string remoteTarget);
}
public enum JetBrains.Profiler.Windows.SysTools.EnvironmentPropertyType : Enum {
    public byte value__;
    public static EnvironmentPropertyType Clr;
    public static EnvironmentPropertyType CoreClr;
    public static EnvironmentPropertyType Mono;
    public static EnvironmentPropertyType Profiler;
    public static EnvironmentPropertyType Normal;
}
public class JetBrains.Profiler.Windows.SysTools.EventPipeTools : BaseServiceRemotable`1<SysTools> {
    private static ILogger ourLogger;
    private WatchedDictionary`1<EventPipeParams> myParams;
    public EventPipeTools(SysTools root, String[] ids, ServiceCreatorDelegate<SysTools> serviceCreator);
    private static EventPipeTools();
    [RemotableLongCallAttribute]
public virtual Guid PrepareToStart(EventPipeParams param);
    [RemotableLongCallAttribute]
public virtual bool IsAllowed(Nullable`1<Guid> id);
    [RemotableLongCallAttribute]
public virtual void StartCollector(ILifetimeIdentity lifetimeIdentity, Guid id, int processId, string processName, string args);
}
public class JetBrains.Profiler.Windows.SysTools.EventTools : BaseServiceRemotable`1<SysTools> {
    private static int TimeoutExpired;
    private static ILogger ourLogger;
    private WatchedDictionary`1<IEventWaitHandle> myEvents;
    public EventTools(SysTools root, String[] ids, ServiceCreatorDelegate<SysTools> serviceCreator);
    private static EventTools();
    protected virtual void OnDispose();
    [NotRemotableAttribute]
[NotNullAttribute]
public string GenerateUniqueEventName();
    [NotRemotableAttribute]
[NotNullAttribute]
public IEventProxy CreateEvent(Lifetime lifetime, bool manualReset, bool initialState, string name);
    [NotRemotableAttribute]
[NotNullAttribute]
public IEventProxy CreateEvent(Lifetime lifetime, bool manualReset, bool initialState, string name, Boolean& createdNew);
    [NotRemotableAttribute]
[CanBeNullAttribute]
public IEventProxy TryOpenEvent(Lifetime lifetime, string name);
    [NotRemotableAttribute]
[NotNullAttribute]
public IEventProxy OpenEvent(Lifetime lifetime, string name);
    [NotRemotableAttribute]
public bool HasEvent(string name);
    [RemotableCallAttribute]
public virtual Guid Event_Create(bool manualReset, bool initialState, string name, Boolean& createdNew);
    [RemotableCallAttribute]
public virtual Guid Event_Open(string name);
    [RemotableCallAttribute]
public virtual bool Event_Has(string name);
    [RemotableLongCallAttribute]
public virtual bool Event_WaitOne(Guid id, TimeSpan timeout);
    [RemotableLongCallAttribute]
public virtual bool Event_WaitOne(Guid id, int timeout);
    [RemotableLongCallAttribute]
public virtual bool Event_WaitOne(Guid id);
    [RemotableCallAttribute]
public virtual void Event_Set(Guid id);
    [RemotableCallAttribute]
public virtual void Event_Reset(Guid id);
    [RemotableCallAttribute]
public virtual void Event_Touch(Guid id);
    [RemotableCallAttribute]
public virtual void Event_Close(Guid id);
}
public class JetBrains.Profiler.Windows.SysTools.EverythingEnvironmentTools : BaseServiceRemotable`1<SysTools> {
    private static ILogger ourLogger;
    private static String[] ourHiveSeNames;
    public EverythingEnvironmentTools(SysTools root, String[] ids, ServiceCreatorDelegate<SysTools> serviceCreator);
    private static EverythingEnvironmentTools();
    [RemotableCallAttribute]
public virtual void CleanAllEverythingEnvironment(CleanEnvironmentProperty[] cleanProperties);
    [RemotableCallAttribute]
public virtual void CleanEverythingEnvironment(CleanEnvironmentProperty[] cleanProperties);
    [RemotableCallAttribute]
public virtual void UpdateEverythingEnvironment(UpdateEnvironmentProperty[] updateProperties);
    private static void CleanEnvironmentForCurrentUser(CleanEnvironmentProperty[] cleanProperties);
    private static void SetEnvironmentForCurrentUser(IEnumerable`1<UpdateEnvironmentProperty> properties);
    private void CleanEnvironmentForHiveUsers(CleanEnvironmentProperty[] cleanProperties);
    [CanBeNullAttribute]
private static string FilterProduct(EnvironmentPropertyType type, string key);
    private void CleanEnvironmentForProduct(CleanEnvironmentProperty[] cleanProperties);
    private void UpdateEnvironmentForProduct(UpdateEnvironmentProperty[] updateProperties);
    [CanBeNullAttribute]
private static string FilterMicrosoftRegistry(EnvironmentPropertyType type, string key);
    private void CleanEnvironmentForClr(CleanEnvironmentProperty[] cleanProperties);
    private void UpdateEnvironmentForClr(UpdateEnvironmentProperty[] updateProperties);
    [CanBeNullAttribute]
private static string FilterAllUsersEnvironment(EnvironmentPropertyType type, string key);
    private static void CleanEnvironmentForAllUsers(CleanEnvironmentProperty[] cleanProperties);
    private static void UpdateEnvironmentForAllUsers(IEnumerable`1<UpdateEnvironmentProperty> updateProperties);
}
public class JetBrains.Profiler.Windows.SysTools.EverythingTools : BaseServiceRemotable`1<SysTools> {
    private static ILogger ourLogger;
    private static MessageResult ourMessageResult_InvalidOs;
    private static MessageResult ourMessageResult_AdministrativeRightRequired;
    private static MessageResult ourMessageResult_Communication;
    public EverythingTools(SysTools root, String[] ids, ServiceCreatorDelegate<SysTools> serviceCreator);
    private static EverythingTools();
    [NotRemotableAttribute]
public MessageResult IsSupported(HostCompatibilityOptions options);
}
public class JetBrains.Profiler.Windows.SysTools.ExecutableTools : BaseServiceRemotable`1<SysTools> {
    private static ILogger ourLogger;
    public ExecutableTools(SysTools root, String[] ids, ServiceCreatorDelegate<SysTools> serviceCreator);
    private static ExecutableTools();
    [RemotableCallAttribute]
public virtual bool IsMacBundle(string path, FileSystemPath& bundlePath);
    [RemotableCallAttribute]
public virtual FileSystemPath TryGetExecutableFromMacBundle(FileSystemPath bundlePath);
    [RemotableCallAttribute]
public virtual bool IsValidExecutable(string path, FileSystemPath& resultingPath);
    [RemotableCallAttribute]
public virtual FileSystemPath GetPathToExecutable(string path);
    [RemotableLongCallAttribute]
public virtual Nullable`1<bool> IsSandboxedExecutable(string path);
}
public class JetBrains.Profiler.Windows.SysTools.FileCacheTools : BaseServiceRemotable`1<SysTools> {
    private static ILogger ourLogger;
    public FileCacheTools(SysTools root, String[] ids, ServiceCreatorDelegate<SysTools> serviceCreator);
    private static FileCacheTools();
    [NotNullAttribute]
[NotRemotableAttribute]
public string CacheFiles(string localDir, IReadOnlyCollection`1<string> relativeFiles);
    [RemotableCallAttribute]
public virtual void GrantFile_BuiltinUsers_ReadAndExecute(string file);
    [RemotableCallAttribute]
public virtual void GrantFile_AllAppPackages_ReadAndExecute(string file);
    [RemotableCallAttribute]
public virtual void GrantDirectory_BuiltinUsers_ReadAndExecute(string directory, bool inherit);
    [RemotableCallAttribute]
public virtual void GrantDirectory_AllAppPackages_ReadAndExecute(string directory, bool inherit);
    [RemotableCallAttribute]
public virtual void GrantDirectory_BuiltinUsers_Modify(string directory, bool inherit);
}
public class JetBrains.Profiler.Windows.SysTools.FileStorageTools : BaseServiceRemotable`1<SysTools> {
    private static ILogger ourLogger;
    private WatchedDictionary`1<FileSystemPath> myFiles;
    public FileStorageTools(SysTools root, String[] ids, ServiceCreatorDelegate<SysTools> serviceCreator);
    private static FileStorageTools();
    [RemotableCallAttribute]
public virtual Guid AddFile(string file, ILifetimeIdentity lifetimeIdentity);
    [RemotableCallAttribute]
public virtual string GetFileName(Guid id);
    [RemotableCallAttribute]
public virtual void DeleteFile(Guid id);
}
public class JetBrains.Profiler.Windows.SysTools.FileTools : BaseServiceRemotable`1<SysTools> {
    public FileTools(SysTools root, String[] ids, ServiceCreatorDelegate<SysTools> serviceCreator);
    [RemotableCallAttribute]
public virtual string CreateGlobalTempFile(string prefix);
    [RemotableCallAttribute]
public virtual string CreateUserTempFile(string prefix);
    [RemotableCallAttribute]
public virtual FileInfo GetFileInfo(string remoteFile);
    [RemotableCallAttribute]
public virtual bool ExistsFile(string remoteFile);
    [NotRemotableAttribute]
public Stream Put(string remoteFile);
    [NotRemotableAttribute]
public Stream Get(string remoteFile);
    [RemotableCallAttribute]
public virtual void DeleteFile(string remoteFile);
    [RemotableCallAttribute]
public virtual void CopyFile(string remoteSourceFile, string remoteDestinationFile, CopyFileMode mode);
    [RemotableCallAttribute]
public virtual void MoveFile(string remoteSourceFile, string remoteDestinationFile, MoveFileMode mode);
}
public class JetBrains.Profiler.Windows.SysTools.FrameworkTools : BaseServiceRemotable`1<SysTools> {
    private static string InstallRoot;
    private static string InstallRootArm64;
    private static ILogger ourLogger;
    public FrameworkTools(SysTools root, String[] ids, ServiceCreatorDelegate<SysTools> serviceCreator);
    private static FrameworkTools();
    [RemotableCallAttribute]
[NotNullAttribute]
public virtual string GetRuntimeDirectory(JetArchitecture architecture, Version frameworkVersion);
    [RemotableCallAttribute]
[NotNullAttribute]
public virtual IReadOnlyCollection`1<Version> GetInstalledRuntimeVersions(JetArchitecture architecture);
    [RemotableCallAttribute]
[NotNullAttribute]
public virtual IReadOnlyCollection`1<Version> GetInstalledFrameworkVersions(JetArchitecture architecture, Version runtimeVersion);
    [CompilerGeneratedAttribute]
internal static bool <GetInstalledFrameworkVersions>g__AddIfNeed|6_0(BackSlashSeparatedRelativePath x, string y, <>c__DisplayClass6_0& );
}
public interface JetBrains.Profiler.Windows.SysTools.IChannelProxy {
    public abstract virtual bool WaitForDataToRead(TimeSpan timeout);
    public abstract virtual bool WaitForDataToRead(int timeout);
    [NotNullAttribute]
public abstract virtual Tuple`2<byte, Byte[]> ReceiveCommand();
    public abstract virtual void SendCommand(byte command, Byte[] data);
    public abstract virtual void Close();
}
public interface JetBrains.Profiler.Windows.SysTools.ICommunicationToolsStream {
    [NotNullAttribute]
public abstract virtual Tuple`2<byte, Byte[]> ReceiveCommand();
    public abstract virtual bool HasDataToRead(int timeout);
    public abstract virtual void SendCommand(byte command, Byte[] data);
    public abstract virtual void Shutdown();
    public abstract virtual void Close();
}
public interface JetBrains.Profiler.Windows.SysTools.IEventProxy {
    public abstract virtual void Set();
    public abstract virtual void Reset();
}
public interface JetBrains.Profiler.Windows.SysTools.IEventWaitHandle {
    public abstract virtual bool Reset();
    public abstract virtual bool Set();
    public abstract virtual void Close();
    public abstract virtual bool WaitOne();
    public abstract virtual bool WaitOne(int millisecondsTimeout);
    public abstract virtual bool WaitOne(TimeSpan timeout);
}
public class JetBrains.Profiler.Windows.SysTools.IISExpressTools : BaseServiceRemotable`1<SysTools> {
    private static ILogger ourLogger;
    public IISExpressTools(SysTools root, String[] ids, ServiceCreatorDelegate<SysTools> serviceCreator);
    private static IISExpressTools();
    [NotNullAttribute]
[RemotableLongCallAttribute]
public virtual IEnumerable`1<IISSiteInfo> GetIISExpressSites(string configurationFile);
    [NotNullAttribute]
[RemotableLongCallAttribute]
public virtual IEnumerable`1<IISExpressInfo> GetIISExpresses();
    [NotRemotableAttribute]
public void UpdateDisplay(IISExpressArgument argument);
}
public class JetBrains.Profiler.Windows.SysTools.IISTools : BaseServiceRemotable`1<SysTools> {
    private static ILogger ourLogger;
    private static MessageResult ourMessageResult_InvalidOs;
    private static MessageResult ourMessageResult_AdministrativeRightRequired;
    private static MessageResult ourMessageResult_NoIISDetected;
    private static MessageResult ourMessageResult_Communication;
    public IISTools(SysTools root, String[] ids, ServiceCreatorDelegate<SysTools> serviceCreator);
    private static IISTools();
    [RemotableCallAttribute]
[NotNullAttribute]
public virtual string GetIISServiceName();
    [NotRemotableAttribute]
[NotNullAttribute]
public MessageResult IsSupported(HostCompatibilityOptions options);
    [NotRemotableAttribute]
public void UpdateDisplay(IISArgument argument);
}
public interface JetBrains.Profiler.Windows.SysTools.ILifetimeIdentity {
}
internal interface JetBrains.Profiler.Windows.SysTools.IListener {
    public string LocalEndPoint { get; }
    public abstract virtual List`1<Guid> Accept(int timeout, Func`2<ICommunicationToolsStream, Guid> streamRegistrator);
    public abstract virtual string get_LocalEndPoint();
    public abstract virtual void InjectProxyStreamFactory(Type type, SysTools sysTools, Object[] args);
    public abstract virtual void Close();
}
public interface JetBrains.Profiler.Windows.SysTools.IListenerProxy {
    [NotNullAttribute]
public string EndPoint { get; }
    public abstract virtual string get_EndPoint();
    [NotNullAttribute]
public abstract virtual Guid[] GetNewStreamIds(TimeSpan timeout);
    [NotNullAttribute]
public abstract virtual Guid[] GetNewStreamIds(int timeout);
    public abstract virtual void Close();
    public abstract virtual void InjectProxyStreamFactory(Type type, Object[] args);
}
public class JetBrains.Profiler.Windows.SysTools.Impl.AgentAcceptedHandler : MulticastDelegate {
    public AgentAcceptedHandler(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(object sender, EventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, EventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.Profiler.Windows.SysTools.Impl.AgentProcess : AsyncDisposable {
    [CompilerGeneratedAttribute]
private bool <IsKilled>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ExitCode>k__BackingField;
    private ILogger myLogger;
    private TimeSpan myTermTimeout;
    private ITimeControl myTimeControl;
    private Func`1<Task`1<Tuple`2<Process, IConnection>>> myRunner;
    private CancellationToken myCancel;
    [NullableAttribute("2")]
private Process myProcess;
    [NullableAttribute("2")]
private IConnection myConnection;
    private Nullable`1<int> myPid;
    private int myIsStarted;
    public bool IsKilled { get; private set; }
    public int ExitCode { get; private set; }
    public AgentProcess(Func`1<Task`1<Tuple`2<Process, IConnection>>> runner, CancellationToken cancel, TimeSpan termTimeout, ITimeControl timeControl);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsKilled();
    [CompilerGeneratedAttribute]
private void set_IsKilled(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_ExitCode();
    [CompilerGeneratedAttribute]
private void set_ExitCode(int value);
    public sealed virtual RunningAgent Start();
    [AsyncStateMachineAttribute("JetBrains.Profiler.Windows.SysTools.Impl.AgentProcess/<StartAsync>d__10")]
public sealed virtual Task`1<RunningAgent> StartAsync();
    [AsyncStateMachineAttribute("JetBrains.Profiler.Windows.SysTools.Impl.AgentProcess/<OnDisposeAsync>d__11")]
protected virtual Task OnDisposeAsync();
    [AsyncStateMachineAttribute("JetBrains.Profiler.Windows.SysTools.Impl.AgentProcess/<CloseAsync>d__12")]
private Task CloseAsync();
    private void KillProcess();
    [CompilerGeneratedAttribute]
private void <StartAsync>b__10_0();
}
[ExtensionAttribute]
internal static class JetBrains.Profiler.Windows.SysTools.Impl.ArgumentsUtil : object {
    [NotNullAttribute]
private static String[] ToArgumentsFile(Func`1<FileSystemPath> getArgumentsFile, IEnumerable`1<string> arguments);
    [NotNullAttribute]
public static String[] BuildCoreHelper_List(FileSystemPath resultFile, Func`1<FileSystemPath> getArgumentsFile, bool includeNative);
    [ExtensionAttribute]
private static string GetRuntimeTypeStr(RuntimeType type);
    [NotNullAttribute]
public static String[] BuildCoreHelper_Attach(FileSystemPath resultFile, Func`1<FileSystemPath> getArgumentsFile, int processId, RuntimeInfo runtime, Guid coreGuid, string profilerDll);
    [NotNullAttribute]
public static String[] BuildWinRTHelper_GetPackages(FileSystemPath resultFile);
    [NotNullAttribute]
public static String[] BuildWinRTHelper_GetPackagesForCurrentUser(FileSystemPath resultFile);
    [NotNullAttribute]
public static String[] BuildWinRTHelper_PrepareStartProfiling(FileSystemPath resultFile, Func`1<FileSystemPath> getArgumentsFile, string packageFullName, IEnumerable`1<UpdateEnvironmentProperty> environment);
    [NotNullAttribute]
public static String[] BuildWinRTHelper_CleanStartProfiling(FileSystemPath resultFile, string packageFullName);
    [NotNullAttribute]
public static String[] BuildWinRTHelper_PrepareAttachProfiling(FileSystemPath resultFile, UInt32 sessionId, string packageFullName);
    [NotNullAttribute]
public static String[] BuildWinRTHelper_CleanAttachProfiling(FileSystemPath resultFile, UInt32 sessionId, string packageFullName);
    [NotNullAttribute]
public static String[] BuildWinRTHelper_PrepareEverythingProfiling(FileSystemPath resultFile);
    [NotNullAttribute]
public static String[] BuildWinRTHelper_CleanEverythingProfiling(FileSystemPath resultFile);
    [NotNullAttribute]
public static String[] BuildWinRTHelper_RunProfiling(FileSystemPath resultFile, Func`1<FileSystemPath> getArgumentsFile, string appUserModelId, string arguments);
    [NotNullAttribute]
public static String[] BuildWinRTHelper_CleanProfiling(FileSystemPath resultFile, string packageFullName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class JetBrains.Profiler.Windows.SysTools.Impl.AsyncDictionary`2 : object {
    private Dictionary`2<TKey, TValue> myDict;
    private SemaphoreSlim mySema;
    private SemaphoreSlim myEmpty;
    [AsyncStateMachineAttribute("JetBrains.Profiler.Windows.SysTools.Impl.AsyncDictionary`2/<AddAsync>d__0")]
public Task AddAsync(TKey key, TValue value);
    [AsyncStateMachineAttribute("JetBrains.Profiler.Windows.SysTools.Impl.AsyncDictionary`2/<RemoveAsync>d__1")]
public Task`1<bool> RemoveAsync(TKey key);
    [AsyncStateMachineAttribute("JetBrains.Profiler.Windows.SysTools.Impl.AsyncDictionary`2/<FindAsync>d__2")]
public Task`1<TValue> FindAsync(TKey key);
    [AsyncStateMachineAttribute("JetBrains.Profiler.Windows.SysTools.Impl.AsyncDictionary`2/<WaitEmptyAsync>d__3")]
public Task WaitEmptyAsync();
}
public abstract class JetBrains.Profiler.Windows.SysTools.Impl.AsyncDisposable : object {
    private long myDisposed;
    public bool Disposed { get; }
    public bool get_Disposed();
    public sealed virtual void Dispose();
    [AsyncStateMachineAttribute("JetBrains.Profiler.Windows.SysTools.Impl.AsyncDisposable/<DisposeAsync>d__3")]
public sealed virtual Task DisposeAsync();
    protected void CheckNotDisposed();
    protected abstract virtual Task OnDisposeAsync();
    [AsyncStateMachineAttribute("JetBrains.Profiler.Windows.SysTools.Impl.AsyncDisposable/<<Dispose>b__2_0>d")]
[CompilerGeneratedAttribute]
private Task <Dispose>b__2_0();
}
internal class JetBrains.Profiler.Windows.SysTools.Impl.ChannelProxy : object {
    private static int TimeoutTouch;
    private static ILogger ourLogger;
    private LifetimeDefinition myDestroy;
    private CommunicationTools myCommunicationTools;
    private Guid myStreamId;
    private int myWasDisposed;
    public ChannelProxy(Lifetime lifetime, CommunicationTools communicationTools, bool withTouch, Guid streamId);
    private static ChannelProxy();
    public sealed virtual bool WaitForDataToRead(TimeSpan timeout);
    public sealed virtual bool WaitForDataToRead(int timeout);
    public sealed virtual Tuple`2<byte, Byte[]> ReceiveCommand();
    public sealed virtual void SendCommand(byte command, Byte[] data);
    public sealed virtual void Close();
    private void AssertAlive();
    [CompilerGeneratedAttribute]
private void <.ctor>b__6_0();
    [CompilerGeneratedAttribute]
private void <.ctor>b__6_1(object _);
    [CompilerGeneratedAttribute]
private void <.ctor>b__6_2();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal static class JetBrains.Profiler.Windows.SysTools.Impl.Checksum : object {
    public static UInt32 Calculate(Byte[] data);
    public static void Validate(Byte[] data, UInt32 expected);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.Profiler.Windows.SysTools.Impl.ConfigurableErrorInjector : object {
    private Dictionary`2<string, Exception> myFail;
    private Dictionary`2<string, TimeSpan> myDelay;
    private static ILogger ourLogger;
    private static ConfigurableErrorInjector();
    public void InjectDelay(string tag, TimeSpan delay);
    public void InjectFail(string tag, Exception err);
    public sealed virtual void Fail(string tag);
    [AsyncStateMachineAttribute("JetBrains.Profiler.Windows.SysTools.Impl.ConfigurableErrorInjector/<DelayAsync>d__6")]
public sealed virtual Task DelayAsync(string tag);
    public sealed virtual void Delay(string tag);
}
public abstract class JetBrains.Profiler.Windows.SysTools.Impl.Constraint : object {
    public static void CrashIf(bool cond, string failMsg);
    public static void ExceptionIf(bool cond, string failMsg);
}
internal static class JetBrains.Profiler.Windows.SysTools.Impl.DecoratorUtil : object {
    [NotNullAttribute]
public static Process GetProcessById(int processId);
}
[ExtensionAttribute]
public static class JetBrains.Profiler.Windows.SysTools.Impl.DelegateEx : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static void InvokeDetach(Delegate handler, object sender, EventArgs e);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.Profiler.Windows.SysTools.Impl.DummyErrorInjector : object {
    public sealed virtual void Fail(string tag);
    public sealed virtual Task DelayAsync(string tag);
    public sealed virtual void Delay(string tag);
}
internal class JetBrains.Profiler.Windows.SysTools.Impl.EventProxy : object {
    private static int TimeoutTouch;
    private static ILogger ourLogger;
    private LifetimeDefinition myDestroy;
    private EventTools myEventTools;
    private Guid myId;
    private int myWasDisposed;
    internal EventProxy(Lifetime lifetime, EventTools eventTools, bool withTouch, Guid id);
    private static EventProxy();
    public sealed virtual bool WaitOne(TimeSpan timeout);
    public sealed virtual bool WaitOne(int timeout);
    public sealed virtual bool WaitOne();
    public sealed virtual void Set();
    public sealed virtual void Reset();
    public sealed virtual void Close();
    private void AssertAlive();
    [CompilerGeneratedAttribute]
private void <.ctor>b__6_0();
    [CompilerGeneratedAttribute]
private void <.ctor>b__6_1(object _);
    [CompilerGeneratedAttribute]
private void <.ctor>b__6_2();
}
internal static class JetBrains.Profiler.Windows.SysTools.Impl.EventWaitHandleFactory : object {
    [NotNullAttribute]
public static IEventWaitHandle Create(bool initialState, EventResetMode mode, string name, Boolean& createdNew);
    [NotNullAttribute]
public static IEventWaitHandle OpenExisting(string name);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.Profiler.Windows.SysTools.Impl.HeartbeatFailedArgs : EventArgs {
    [CompilerGeneratedAttribute]
private Exception <Error>k__BackingField;
    public Exception Error { get; }
    public HeartbeatFailedArgs(Exception err);
    [CompilerGeneratedAttribute]
public Exception get_Error();
}
public class JetBrains.Profiler.Windows.SysTools.Impl.HeartbeatFailedHandler : MulticastDelegate {
    public HeartbeatFailedHandler(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(object sender, HeartbeatFailedArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, HeartbeatFailedArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public interface JetBrains.Profiler.Windows.SysTools.Impl.IAgentProcess {
    public bool IsKilled { get; }
    public int ExitCode { get; }
    public abstract virtual bool get_IsKilled();
    public abstract virtual int get_ExitCode();
    [NullableContextAttribute("1")]
public abstract virtual RunningAgent Start();
    [NullableContextAttribute("1")]
public abstract virtual Task`1<RunningAgent> StartAsync();
}
public interface JetBrains.Profiler.Windows.SysTools.Impl.IAsyncDisposable {
    public abstract virtual Task DisposeAsync();
}
public interface JetBrains.Profiler.Windows.SysTools.Impl.IConnection {
    public Stream Stream { get; }
    public abstract virtual Stream get_Stream();
    public abstract virtual void Break();
    public abstract virtual void Close();
}
[NullableContextAttribute("1")]
public interface JetBrains.Profiler.Windows.SysTools.Impl.IErrorInjector {
    public abstract virtual void Fail(string tag);
    public abstract virtual Task DelayAsync(string tag);
    public abstract virtual void Delay(string tag);
}
[NullableContextAttribute("2")]
public interface JetBrains.Profiler.Windows.SysTools.Impl.IProcessAgency {
    [CompilerGeneratedAttribute]
public abstract virtual void add_AgentAccepted(AgentAcceptedHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_AgentAccepted(AgentAcceptedHandler value);
    public abstract virtual void Start();
    [NullableContextAttribute("1")]
public abstract virtual Task StartAsync();
    [NullableContextAttribute("1")]
public abstract virtual IAgentProcess CreateAgent(CancellationToken cancel, string exePath, string args);
}
[NullableContextAttribute("1")]
public interface JetBrains.Profiler.Windows.SysTools.Impl.IRpcSession {
    public string Description { get; }
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public abstract virtual void add_NotAlive(SessionNotAliveHandler value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public abstract virtual void remove_NotAlive(SessionNotAliveHandler value);
    public abstract virtual string get_Description();
    public abstract virtual Task OpenAsync();
    public abstract virtual void Kill();
    public abstract virtual IRpcSession Clone();
    public abstract virtual Task`1<Byte[]> CallAsync(byte methodId, Byte[] args, Nullable`1<TaggedTimeout> timeout, Nullable`1<CancellationToken> cancel);
}
public interface JetBrains.Profiler.Windows.SysTools.Impl.IServerDescriptor {
    public string Type { get; }
    public string Id { get; }
    public string HumanReadable { get; }
    public abstract virtual string get_Type();
    public abstract virtual string get_Id();
    public abstract virtual string get_HumanReadable();
}
public interface JetBrains.Profiler.Windows.SysTools.Impl.IStreamServer {
    public abstract virtual IServerDescriptor Start();
    public abstract virtual Task`1<IConnection> AcceptAsync();
    public abstract virtual void Stop();
}
[NullableContextAttribute("1")]
public interface JetBrains.Profiler.Windows.SysTools.Impl.ITimeControl {
    public DateTime UtcNow { get; }
    public abstract virtual DateTime get_UtcNow();
    public abstract virtual Task`1<bool> WaitSemaAsync(SemaphoreSlim sema, TimeSpan timeout, string name);
    public abstract virtual Task WaitAsync(TimeSpan timeout, string name);
}
public class JetBrains.Profiler.Windows.SysTools.Impl.LifetimeIdentity : object {
    private Guid myId;
    public Guid Id { get; }
    public LifetimeIdentity(Guid id);
    public Guid get_Id();
    public virtual string ToString();
}
internal class JetBrains.Profiler.Windows.SysTools.Impl.ListenerProxy : object {
    private static int TimeoutTouch;
    private static ILogger ourLogger;
    private LifetimeDefinition myDestroy;
    private Guid myListenerId;
    private CommunicationTools myCommunicationTools;
    private int myWasDisposed;
    public string EndPoint { get; }
    public ListenerProxy(Lifetime lifetime, CommunicationTools communicationTools, bool withTouch, Guid listenerId);
    private static ListenerProxy();
    public sealed virtual string get_EndPoint();
    public sealed virtual Guid[] GetNewStreamIds(TimeSpan timeout);
    public sealed virtual Guid[] GetNewStreamIds(int timeout);
    public sealed virtual void Close();
    public sealed virtual void InjectProxyStreamFactory(Type type, Object[] args);
    private void AssertAlive();
    [CompilerGeneratedAttribute]
private void <.ctor>b__6_0();
    [CompilerGeneratedAttribute]
private void <.ctor>b__6_1(object _);
    [CompilerGeneratedAttribute]
private void <.ctor>b__6_2();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.Profiler.Windows.SysTools.Impl.ManualTimeControl : object {
    [CompilerGeneratedAttribute]
private DateTime <UtcNow>k__BackingField;
    private static ILogger ourLogger;
    private Dictionary`2<string, Queue`1<TaskCompletionSource`1<object>>> myPendingTimers;
    private Dictionary`2<string, Queue`1<TaskCompletionSource`1<object>>> myFiredTimers;
    private SemaphoreSlim myTimelineSema;
    public DateTime UtcNow { get; private set; }
    private static ManualTimeControl();
    [CompilerGeneratedAttribute]
public sealed virtual DateTime get_UtcNow();
    [CompilerGeneratedAttribute]
private void set_UtcNow(DateTime value);
    [AsyncStateMachineAttribute("JetBrains.Profiler.Windows.SysTools.Impl.ManualTimeControl/<WaitSemaAsync>d__4")]
public sealed virtual Task`1<bool> WaitSemaAsync(SemaphoreSlim sema, TimeSpan timeout, string name);
    [AsyncStateMachineAttribute("JetBrains.Profiler.Windows.SysTools.Impl.ManualTimeControl/<WaitAsync>d__5")]
public sealed virtual Task WaitAsync(TimeSpan timeout, string name);
    [AsyncStateMachineAttribute("JetBrains.Profiler.Windows.SysTools.Impl.ManualTimeControl/<FireAsync>d__6")]
public Task FireAsync(string timerName, int times);
    [AsyncStateMachineAttribute("JetBrains.Profiler.Windows.SysTools.Impl.ManualTimeControl/<FireAsync>d__7")]
public Task FireAsync(string timerName);
    public void Tick(TimeSpan delta);
}
internal static class JetBrains.Profiler.Windows.SysTools.Impl.MessageUtil : object {
    public static void NotifyAllWindowsAboutEnvironmentChanging();
}
public enum JetBrains.Profiler.Windows.SysTools.Impl.MethodType : Enum {
    public byte value__;
    public static MethodType UserPayload;
    public static MethodType Heartbeat;
    public static MethodType Term;
}
public class JetBrains.Profiler.Windows.SysTools.Impl.NamedPipeAgency : ProcessAgency {
    [NullableContextAttribute("2")]
public NamedPipeAgency(Nullable`1<TimeSpan> termTimeout, Nullable`1<TimeSpan> connectTimeout, ITimeControl timeControl, IErrorInjector errorInjector);
    [NullableContextAttribute("1")]
private static IStreamServer CreateServer();
}
public class JetBrains.Profiler.Windows.SysTools.Impl.NamedPipeConnection : object {
    [CompilerGeneratedAttribute]
private Stream <Stream>k__BackingField;
    private NamedPipeServerStream myPipe;
    public Stream Stream { get; }
    public NamedPipeConnection(NamedPipeServerStream stream);
    [CompilerGeneratedAttribute]
public sealed virtual Stream get_Stream();
    public sealed virtual void Dispose();
    public sealed virtual void Break();
    public sealed virtual void Close();
}
internal class JetBrains.Profiler.Windows.SysTools.Impl.NamedPipeListener : object {
    [NotNullAttribute]
private NamedPipeServerStream myPipe;
    [NotNullAttribute]
private string myPipeName;
    [NotNullAttribute]
private Func`2<NamedPipeServerStream, ICommunicationToolsStream> myStreamFactory;
    public string LocalEndPoint { get; }
    private NamedPipeListener(NamedPipeServerStream pipe, string pipeName);
    public static KeyValuePair`2<Guid, NamedPipeListener> Create(Func`2<IListener, Guid> listenerRegistrator);
    public sealed virtual List`1<Guid> Accept(int timeout, Func`2<ICommunicationToolsStream, Guid> streamRegistrator);
    public sealed virtual string get_LocalEndPoint();
    public sealed virtual void InjectProxyStreamFactory(Type type, SysTools sysTools, Object[] args);
    public sealed virtual void Close();
    private static string GeneratePipeName();
    private static ACL* CreateDiamondDacl(Lifetime lifetime);
    private static ACL* CreateDiamondSacl(Lifetime lifetime);
    private static SECURITY_DESCRIPTOR* CreateSecurityDescriptor(Lifetime lifetime, ACL* dacl, ACL* sacl);
    public static NamedPipeServerStream CreatePipeServer(string name, bool firstInstance);
}
public class JetBrains.Profiler.Windows.SysTools.Impl.NamedPipeServer : object {
    private string myPipeName;
    private int myConnectionCount;
    public NamedPipeServer(string pipeName);
    public sealed virtual IServerDescriptor Start();
    public sealed virtual void Stop();
    [AsyncStateMachineAttribute("JetBrains.Profiler.Windows.SysTools.Impl.NamedPipeServer/<AcceptAsync>d__3")]
public sealed virtual Task`1<IConnection> AcceptAsync();
}
public class JetBrains.Profiler.Windows.SysTools.Impl.NamedPipeServerDescriptor : object {
    [CompilerGeneratedAttribute]
private string <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    public string Type { get; }
    public string Id { get; }
    public string HumanReadable { get; }
    public NamedPipeServerDescriptor(string name);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Type();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Id();
    public sealed virtual string get_HumanReadable();
}
internal static class JetBrains.Profiler.Windows.SysTools.Impl.NativeInterop : object {
    public static int ENOENT;
    public static int EAGAIN;
    public static int EEXIST;
    public static int ETIMEDOUT;
    public static int O_CREAT;
    public static int O_EXCL;
    public static IntPtr SEM_FAILED;
    private static NativeInterop();
    public static IntPtr sem_open(string name, int oflag, UInt32 mode, UInt32 value);
    public static int sem_close(IntPtr sem);
    public static int sem_unlink(string name);
    public static int sem_wait(IntPtr sem);
    public static int sem_timedwait(IntPtr sem, TimeSpec& abs_timeout);
    public static int sem_trywait(IntPtr sem);
    public static int sem_post(IntPtr sem);
    public static int sem_getvalue(IntPtr sem, Int32& sval);
}
internal static class JetBrains.Profiler.Windows.SysTools.Impl.ParseUtil : object {
    private static ILogger ourLogger;
    private static string MicrosoftMauiLibrary;
    private static ParseUtil();
    [NotNullAttribute]
private static XmlElement LoadXml(FileSystemPath resultFile);
    [NotNullAttribute]
public static IISSiteInfo[] ParseIISConfiguration(FileSystemPath configurationFile);
    [NotNullAttribute]
private static Tuple`2<HResults, string> GetResult(XmlElement xmlRoot);
    [CanBeNullAttribute]
private static UserInfo GetUserInfo(XmlElement xmlRoot);
    private static ProcessInfo[] GetProcessList(XmlElement xmlRoot, JetArchitecture architecture);
    [NotNullAttribute]
private static PackageInfo[] GetPackageList(XmlElement xmlRoot);
    [NotNullAttribute]
public static Tuple`2<HResults, string> ParseHelperResult(FileSystemPath resultFile);
    [NotNullAttribute]
public static Tuple`3<HResults, string, ProcessInfo[]> ParseAttachHelperResult_List(JetArchitecture architecture, FileSystemPath resultFile);
    [NotNullAttribute]
public static Tuple`3<HResults, string, UserInfo> ParseWinRTHelperResult_User(FileSystemPath resultFile);
    [NotNullAttribute]
public static Tuple`3<HResults, string, PackageInfo[]> ParseWinRTHelperResult_List(FileSystemPath resultFile);
    [NotNullAttribute]
public static Tuple`3<HResults, string, Tuple`2<UserInfo, PackageInfo[]>> ParseWinRTHelperResult_CurrentUserList(FileSystemPath resultFile);
    public static PackageInfoType GetPackageType(string packageInstalledLocation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.Profiler.Windows.SysTools.Impl.ProcessAgency : AsyncDisposable {
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private AgentAcceptedHandler AgentAccepted;
    private ILogger myLogger;
    private ITimeControl myTimeControl;
    private AsyncDictionary`2<Guid, Action`1<IConnection>> myPendingClients;
    private SemaphoreSlim myAcceptReadySema;
    private IStreamServer myServer;
    private TimeSpan myTermTimeout;
    private TimeSpan myConnectTimeout;
    private SemaphoreSlim myAcceptStoppedSema;
    private long myStarted;
    [NullableAttribute("2")]
private Task myAcceptLoop;
    [NullableAttribute("2")]
private IServerDescriptor myServerDescriptor;
    private IErrorInjector myErrorInjector;
    public ProcessAgency(Func`1<IStreamServer> createServer, string name, Nullable`1<TimeSpan> termTimeout, Nullable`1<TimeSpan> connectTimeout, ITimeControl timeControl, IErrorInjector errorInjector);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual void add_AgentAccepted(AgentAcceptedHandler value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual void remove_AgentAccepted(AgentAcceptedHandler value);
    public sealed virtual void Start();
    [AsyncStateMachineAttribute("JetBrains.Profiler.Windows.SysTools.Impl.ProcessAgency/<StartAsync>d__5")]
public sealed virtual Task StartAsync();
    [AsyncStateMachineAttribute("JetBrains.Profiler.Windows.SysTools.Impl.ProcessAgency/<OnDisposeAsync>d__6")]
protected virtual Task OnDisposeAsync();
    public sealed virtual IAgentProcess CreateAgent(CancellationToken cancel, string exePath, string args);
    [AsyncStateMachineAttribute("JetBrains.Profiler.Windows.SysTools.Impl.ProcessAgency/<RunProcessAsync>d__8")]
private Task`1<Tuple`2<Process, IConnection>> RunProcessAsync(string exePath, string args, CancellationToken cancel);
    [AsyncStateMachineAttribute("JetBrains.Profiler.Windows.SysTools.Impl.ProcessAgency/<AcceptConnectionAsync>d__9")]
private Task`1<Tuple`2<Process, IConnection>> AcceptConnectionAsync(Process proc, Task`1<IConnection> connected, CancellationToken cancel);
    [AsyncStateMachineAttribute("JetBrains.Profiler.Windows.SysTools.Impl.ProcessAgency/<StartClientAcceptLoopAsync>d__10")]
private Task StartClientAcceptLoopAsync();
    [AsyncStateMachineAttribute("JetBrains.Profiler.Windows.SysTools.Impl.ProcessAgency/<HandshakeClientAsync>d__11")]
private Task HandshakeClientAsync(IConnection client);
    private Process StartProcess(ProcessStartInfo info);
    private Nullable`1<int> TryPid(Process proc);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private void <StartProcess>b__12_0(object sender, DataReceivedEventArgs args);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private void <StartProcess>b__12_1(object sender, DataReceivedEventArgs args);
}
internal class JetBrains.Profiler.Windows.SysTools.Impl.ProcessProxy : object {
    private static int TimeoutTouch;
    private static ILogger ourLogger;
    private LifetimeDefinition myDestroy;
    private ProcessTools myProcessTools;
    private RemotableProcessStartInfo myStartInfo;
    private RemotableProcessInfo myProcessInfo;
    private int myWasDisposed;
    public int ProcessId { get; }
    public int SessionId { get; }
    public long AuthenticationId { get; }
    public long StartTimestamp { get; }
    public JetArchitecture Architecture { get; }
    public string ProcessName { get; }
    public int ExitCode { get; }
    public bool HasExited { get; }
    public string PathToExecutable { get; }
    public bool IsStarted { get; }
    private ProcessProxy(Lifetime lifetime, ProcessTools processTools, bool withTouch);
    internal ProcessProxy(Lifetime lifetime, ProcessTools processTools, bool withTouch, RemotableProcessStartInfo startInfo);
    internal ProcessProxy(Lifetime lifetime, ProcessTools processTools, bool withTouch, RemotableProcessInfo processInfo);
    private static ProcessProxy();
    public sealed virtual int get_ProcessId();
    public sealed virtual int get_SessionId();
    public sealed virtual long get_AuthenticationId();
    public sealed virtual long get_StartTimestamp();
    public sealed virtual JetArchitecture get_Architecture();
    public sealed virtual string get_ProcessName();
    public sealed virtual int get_ExitCode();
    public sealed virtual bool get_HasExited();
    public sealed virtual string get_PathToExecutable();
    public sealed virtual bool get_IsStarted();
    public sealed virtual bool Start();
    public sealed virtual bool StartSuspended(Action beforeResume);
    public sealed virtual void Kill();
    public sealed virtual void KillTree();
    public sealed virtual bool CloseMainWindow();
    public sealed virtual void CloseAllWindows();
    public sealed virtual bool WaitForExit(TimeSpan timeout);
    public sealed virtual bool WaitForExit(int timeout);
    public sealed virtual bool WaitForExit();
    public sealed virtual void Close();
    private void AssertAlive();
    private bool StartImpl(Action beforeResume);
    [CompilerGeneratedAttribute]
private void <.ctor>b__7_0();
    [CompilerGeneratedAttribute]
private void <.ctor>b__7_1(object _);
    [CompilerGeneratedAttribute]
private void <.ctor>b__7_2();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.Profiler.Windows.SysTools.Impl.ProcMonClient : object {
    private ILogger myLogger;
    private RpcWatchDog myRpc;
    private JetArchitecture myArch;
    public ProcMonClient(IProcessAgency processAgency, string agentExe, JetArchitecture arch, string agentArgs, ITimeControl tc);
    [AsyncStateMachineAttribute("JetBrains.Profiler.Windows.SysTools.Impl.ProcMonClient/<StartAsync>d__1")]
public Task StartAsync();
    [AsyncStateMachineAttribute("JetBrains.Profiler.Windows.SysTools.Impl.ProcMonClient/<ListProcessesAsync>d__2")]
public Task`1<IEnumerable`1<ProcessInfo>> ListProcessesAsync(bool includeNative);
    [AsyncStateMachineAttribute("JetBrains.Profiler.Windows.SysTools.Impl.ProcMonClient/<AttachToProcessAsync>d__3")]
public Task AttachToProcessAsync(int pid, Guid coreGuid, RuntimeInfo runtime, string profilerDll);
    [AsyncStateMachineAttribute("JetBrains.Profiler.Windows.SysTools.Impl.ProcMonClient/<WinRtGetPackagesForCurrentUserAsync>d__4")]
public Task`1<IEnumerable`1<PackageInfo>> WinRtGetPackagesForCurrentUserAsync();
    [AsyncStateMachineAttribute("JetBrains.Profiler.Windows.SysTools.Impl.ProcMonClient/<WinRtPrepareStartProfilingAsync>d__5")]
public Task WinRtPrepareStartProfilingAsync(string packageFullName, IEnumerable`1<UpdateEnvironmentProperty> env);
    [AsyncStateMachineAttribute("JetBrains.Profiler.Windows.SysTools.Impl.ProcMonClient/<WinRtCleanStartProfilingAsync>d__6")]
public Task WinRtCleanStartProfilingAsync(string packageFullName);
    [AsyncStateMachineAttribute("JetBrains.Profiler.Windows.SysTools.Impl.ProcMonClient/<WinRtRunProfilingAsync>d__7")]
public Task WinRtRunProfilingAsync(string appUserModelId, string arguments);
    [AsyncStateMachineAttribute("JetBrains.Profiler.Windows.SysTools.Impl.ProcMonClient/<WinRtPrepareEverythingProfilingAsync>d__8")]
public Task WinRtPrepareEverythingProfilingAsync();
    [AsyncStateMachineAttribute("JetBrains.Profiler.Windows.SysTools.Impl.ProcMonClient/<WinRtCleanEverythingProfilingAsync>d__9")]
public Task WinRtCleanEverythingProfilingAsync();
    [AsyncStateMachineAttribute("JetBrains.Profiler.Windows.SysTools.Impl.ProcMonClient/<WinRtCleanAttachProfilingAsync>d__10")]
public Task WinRtCleanAttachProfilingAsync(UInt32 sessionId, string packageFullName);
    [AsyncStateMachineAttribute("JetBrains.Profiler.Windows.SysTools.Impl.ProcMonClient/<WinRtPrepareAttachProfilingAsync>d__11")]
public Task WinRtPrepareAttachProfilingAsync(UInt32 sessionId, string packageFullName);
    [AsyncStateMachineAttribute("JetBrains.Profiler.Windows.SysTools.Impl.ProcMonClient/<DisposeAsync>d__12")]
public Task DisposeAsync();
    public sealed virtual void Dispose();
    private static bool TypeFitsWinRt(UpdateEnvironmentProperty prop);
    private PackageInfo ParseWinRtPackage(WinRtPackageInfo package);
    [AsyncStateMachineAttribute("JetBrains.Profiler.Windows.SysTools.Impl.ProcMonClient/<RpcCallAsync>d__16")]
private Task`1<Byte[]> RpcCallAsync(byte methodId, Byte[] arguments, Nullable`1<TaggedTimeout> timeout, Nullable`1<CancellationToken> cancel);
    private void CheckResult(StatusInfo status);
    private ProcessInfo ParseProcessInfo(ProcessInfo proc, JetArchitecture arch);
    [NullableContextAttribute("2")]
private UserInfo ParseUserInfo(Nullable`1<UserInfo> info);
    private List`1<RuntimeInfo> ParseRuntimes(ProcessInfo proc);
    private Version ParseVersion(int pid, RuntimeInfo runtime);
    [NullableContextAttribute("0")]
[AsyncStateMachineAttribute("JetBrains.Profiler.Windows.SysTools.Impl.ProcMonClient/<<Dispose>b__13_0>d")]
[CompilerGeneratedAttribute]
private Task <Dispose>b__13_0();
}
public class JetBrains.Profiler.Windows.SysTools.Impl.ReactiveState`2 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private OnUpdateHandler<TState, TArg> OnUpdate;
    [CompilerGeneratedAttribute]
private TArg <Arg>k__BackingField;
    private static long NOT_UPDATING;
    private static long PENDING_UPDATES;
    private static long UPDATE_IN_PROGRESS;
    private long myPhase;
    [NullableAttribute("1")]
private TaskCompletionSource`1<TState> myState;
    [NullableAttribute("1")]
private TaskCompletionSource`1<TState> myNextState;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`3<TState, TArg, TState> myTransition;
    public TArg Arg { get; }
    public ReactiveState`2(TState init, TArg arg, Func`3<TState, TArg, TState> transition);
    [CompilerGeneratedAttribute]
public void add_OnUpdate(OnUpdateHandler<TState, TArg> value);
    [CompilerGeneratedAttribute]
public void remove_OnUpdate(OnUpdateHandler<TState, TArg> value);
    [CompilerGeneratedAttribute]
public TArg get_Arg();
    public void ScheduleUpdate();
    [NullableContextAttribute("1")]
public TState ForceUpdate();
    [NullableContextAttribute("2")]
public TState TrySnapshot();
    [NullableContextAttribute("1")]
public TState SnapshotUpdate();
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("JetBrains.Profiler.Windows.SysTools.Impl.ReactiveState`2/<UpdateAsync>d__12")]
private Task UpdateAsync();
}
public class JetBrains.Profiler.Windows.SysTools.Impl.RequestSentArgs : EventArgs {
    [CompilerGeneratedAttribute]
private RpcRequestHeader <Request>k__BackingField;
    public RpcRequestHeader Request { get; }
    public RequestSentArgs(RpcRequestHeader request);
    [CompilerGeneratedAttribute]
public RpcRequestHeader get_Request();
}
public class JetBrains.Profiler.Windows.SysTools.Impl.RequestSentHandler : MulticastDelegate {
    public RequestSentHandler(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(object sender, RequestSentArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, RequestSentArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum JetBrains.Profiler.Windows.SysTools.Impl.ReturnCode : Enum {
    public byte value__;
    public static ReturnCode Success;
    public static ReturnCode MethodNotFound;
    public static ReturnCode ExternalException;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.Profiler.Windows.SysTools.Impl.RpcClient : AsyncDisposable {
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private HeartbeatFailedHandler NotResponded;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private RequestSentHandler RequestSent;
    private ILogger myLogger;
    private RpcTransport myTransport;
    private RpcHeartbeat myHeartbeat;
    private TimeSpan myTermTimeout;
    private long myKilled;
    [NullableContextAttribute("2")]
public RpcClient(Nullable`1<UInt32> heartbeatThreshold, Nullable`1<TimeSpan> heartbeatPeriod, Nullable`1<TimeSpan> termTimeout, ITimeControl timeControl, IErrorInjector errorInjector);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void add_NotResponded(HeartbeatFailedHandler value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void remove_NotResponded(HeartbeatFailedHandler value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void add_RequestSent(RequestSentHandler value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void remove_RequestSent(RequestSentHandler value);
    [AsyncStateMachineAttribute("JetBrains.Profiler.Windows.SysTools.Impl.RpcClient/<OnDisposeAsync>d__7")]
protected virtual Task OnDisposeAsync();
    public void Start(Stream io, string desc);
    public void Start(Stream inbound, Stream outbound, string desc);
    public void Kill();
    [AsyncStateMachineAttribute("JetBrains.Profiler.Windows.SysTools.Impl.RpcClient/<CallAsync>d__11")]
public Task`1<Byte[]> CallAsync(byte methodId, Byte[] args, Nullable`1<TaggedTimeout> timeout, Nullable`1<CancellationToken> cancel);
    [AsyncStateMachineAttribute("JetBrains.Profiler.Windows.SysTools.Impl.RpcClient/<TermRemoteSideAsync>d__12")]
private Task TermRemoteSideAsync();
    [CompilerGeneratedAttribute]
private void <.ctor>b__6_0(object sender, RequestSentArgs args);
    [CompilerGeneratedAttribute]
private void <.ctor>b__6_1(object sender, HeartbeatFailedArgs args);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class JetBrains.Profiler.Windows.SysTools.Impl.RpcHeartbeat : AsyncDisposable {
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private HeartbeatFailedHandler Failed;
    private ILogger myLogger;
    private RpcTransport myTransport;
    private TimeSpan myTimeout;
    private TimeSpan myPeriod;
    private UInt32 myThreshold;
    private ITimeControl myTimeControl;
    private CancellationTokenSource myCancelSource;
    private SemaphoreSlim myHeartbeatingFinished;
    private SemaphoreSlim myErrorGuard;
    private CancellationToken myCancel;
    [NullableAttribute("2")]
private Task myHeartbeating;
    private long mySkipNext;
    private UInt32 myHeartbeatMiss;
    [NullableAttribute("2")]
private Exception myError;
    public RpcHeartbeat(RpcTransport transport, Nullable`1<TimeSpan> period, Nullable`1<TimeSpan> timeout, Nullable`1<UInt32> threshold, ITimeControl timeControl);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void add_Failed(HeartbeatFailedHandler value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void remove_Failed(HeartbeatFailedHandler value);
    [AsyncStateMachineAttribute("JetBrains.Profiler.Windows.SysTools.Impl.RpcHeartbeat/<OnDisposeAsync>d__4")]
protected virtual Task OnDisposeAsync();
    public void Start();
    public void SkipNext();
    [AsyncStateMachineAttribute("JetBrains.Profiler.Windows.SysTools.Impl.RpcHeartbeat/<CheckAliveAsync>d__7")]
public Task CheckAliveAsync();
    [AsyncStateMachineAttribute("JetBrains.Profiler.Windows.SysTools.Impl.RpcHeartbeat/<StartHeartbeatingAsync>d__8")]
private Task StartHeartbeatingAsync();
    [AsyncStateMachineAttribute("JetBrains.Profiler.Windows.SysTools.Impl.RpcHeartbeat/<HeartBeat>d__9")]
private Task`1<bool> HeartBeat();
    [AsyncStateMachineAttribute("JetBrains.Profiler.Windows.SysTools.Impl.RpcHeartbeat/<SetFailedAsync>d__10")]
private Task SetFailedAsync(Exception err);
    [AsyncStateMachineAttribute("JetBrains.Profiler.Windows.SysTools.Impl.RpcHeartbeat/<SetAliveAsync>d__11")]
private Task SetAliveAsync();
    [AsyncStateMachineAttribute("JetBrains.Profiler.Windows.SysTools.Impl.RpcHeartbeat/<GetErrorAsync>d__12")]
private Task`1<Exception> GetErrorAsync();
    [AsyncStateMachineAttribute("JetBrains.Profiler.Windows.SysTools.Impl.RpcHeartbeat/<SendHeartbeatRequestAsync>d__13")]
private Task SendHeartbeatRequestAsync();
    [AsyncStateMachineAttribute("JetBrains.Profiler.Windows.SysTools.Impl.RpcHeartbeat/<SetErrorAsync>d__14")]
private Task`1<bool> SetErrorAsync(Exception err);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private Exception <GetErrorAsync>b__12_0();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.Profiler.Windows.SysTools.Impl.RpcLocalSession : AsyncDisposable {
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private SessionNotAliveHandler NotAlive;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    private ILogger myLogger;
    private CancellationTokenSource myCancelSource;
    private IProcessAgency myAgency;
    private Parameters myParams;
    private IAgentProcess myAgent;
    private RpcClient myRpc;
    private long myOpened;
    private long myKilled;
    public string Description { get; }
    public RpcLocalSession(IProcessAgency agency, Parameters param);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual void add_NotAlive(SessionNotAliveHandler value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual void remove_NotAlive(SessionNotAliveHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Description();
    [AsyncStateMachineAttribute("JetBrains.Profiler.Windows.SysTools.Impl.RpcLocalSession/<OnDisposeAsync>d__8")]
protected virtual Task OnDisposeAsync();
    [AsyncStateMachineAttribute("JetBrains.Profiler.Windows.SysTools.Impl.RpcLocalSession/<OpenAsync>d__9")]
public sealed virtual Task OpenAsync();
    public sealed virtual void Kill();
    public sealed virtual IRpcSession Clone();
    [AsyncStateMachineAttribute("JetBrains.Profiler.Windows.SysTools.Impl.RpcLocalSession/<CallAsync>d__12")]
public sealed virtual Task`1<Byte[]> CallAsync(byte methodId, Byte[] args, Nullable`1<TaggedTimeout> timeout, Nullable`1<CancellationToken> cancel);
    private void ForKilledDo(Action action);
    [CompilerGeneratedAttribute]
private void <.ctor>b__7_0(object _, HeartbeatFailedArgs args);
}
public class JetBrains.Profiler.Windows.SysTools.Impl.RpcMethodNotFoundError : RpcServerSideError {
    public RpcMethodNotFoundError(byte method);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.Profiler.Windows.SysTools.Impl.RpcRequestHeader : ValueType {
    public long CallId;
    public UInt32 BodyLength;
    public UInt32 BodyCheckSum;
    public byte MethodId;
    public MethodType Type;
    private byte HeaderCheckSum;
    public static int Size;
    [NullableContextAttribute("2")]
public RpcRequestHeader(long callId, MethodType type, byte methodId, Byte[] body);
    private static RpcRequestHeader();
    public virtual string ToString();
    public Byte[] Serialize();
    private byte CalculateCheckSum();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.Profiler.Windows.SysTools.Impl.RpcResponseHeader : ValueType {
    public long CallId;
    public UInt32 BodyLength;
    public UInt32 BodyCheckSum;
    public ReturnCode ReturnCode;
    private byte HeaderCheckSum;
    public static int Size;
    private static RpcResponseHeader();
    public static RpcResponseHeader Deserialize(Byte[] bytes);
    public virtual string ToString();
    private byte CalculateCheckSum();
    private static void ValidateCheckSum(RpcResponseHeader header);
}
public abstract class JetBrains.Profiler.Windows.SysTools.Impl.RpcSerialization : object {
    [NullableContextAttribute("1")]
public static Byte[] SerializeRequest(RpcRequestHeader header, Byte[] body);
}
public class JetBrains.Profiler.Windows.SysTools.Impl.RpcServerLogicError : RpcServerSideError {
    [NullableContextAttribute("1")]
public RpcServerLogicError(string message);
}
public class JetBrains.Profiler.Windows.SysTools.Impl.RpcServerNoHeartbeatError : Exception {
    [NullableContextAttribute("1")]
public RpcServerNoHeartbeatError(UInt32 limit, Exception innerException);
}
public class JetBrains.Profiler.Windows.SysTools.Impl.RpcServerSideError : Exception {
    [NullableContextAttribute("1")]
public RpcServerSideError(string message);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.Profiler.Windows.SysTools.Impl.RpcSessionNotRecoverable : Exception {
    [CompilerGeneratedAttribute]
private Exception <Error>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RemotePeer>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <Window>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Limit>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Initial>k__BackingField;
    public Exception Error { get; }
    public string RemotePeer { get; }
    public TimeSpan Window { get; }
    public long Limit { get; }
    public bool Initial { get; }
    public RpcSessionNotRecoverable(string remotePeer, long limit, TimeSpan window, Exception err, bool first);
    [CompilerGeneratedAttribute]
public Exception get_Error();
    [CompilerGeneratedAttribute]
public string get_RemotePeer();
    [CompilerGeneratedAttribute]
public TimeSpan get_Window();
    [CompilerGeneratedAttribute]
public long get_Limit();
    [CompilerGeneratedAttribute]
public bool get_Initial();
    public RpcSessionNotRecoverable Clone();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class JetBrains.Profiler.Windows.SysTools.Impl.RpcSessionSwitch : AsyncDisposable {
    [NullableAttribute("2")]
private IRpcSession mySession;
    [NullableAttribute("2")]
private RpcSessionNotRecoverable myError;
    private SemaphoreSlim mySessionGuard;
    private bool myFirstError;
    public RpcSessionSwitch(IRpcSession initSession);
    [AsyncStateMachineAttribute("JetBrains.Profiler.Windows.SysTools.Impl.RpcSessionSwitch/<GetCurrentAsync>d__1")]
public Task`1<IRpcSession> GetCurrentAsync();
    [AsyncStateMachineAttribute("JetBrains.Profiler.Windows.SysTools.Impl.RpcSessionSwitch/<SwitchWith>d__2")]
public Task SwitchWith(Func`3<IRpcSession, Exception, Task`1<Tuple`2<IRpcSession, RpcSessionNotRecoverable>>> switcher, IRpcSession session, Exception reason);
    [AsyncStateMachineAttribute("JetBrains.Profiler.Windows.SysTools.Impl.RpcSessionSwitch/<OnDisposeAsync>d__3")]
protected virtual Task OnDisposeAsync();
    private void CheckError();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private IRpcSession <GetCurrentAsync>b__1_0();
    [AsyncStateMachineAttribute("JetBrains.Profiler.Windows.SysTools.Impl.RpcSessionSwitch/<<OnDisposeAsync>b__3_0>d")]
[CompilerGeneratedAttribute]
private Task <OnDisposeAsync>b__3_0();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class JetBrains.Profiler.Windows.SysTools.Impl.RpcTransport : AsyncDisposable {
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private RequestSentHandler RequestSent;
    private TimeSpan myTermTimeout;
    private IErrorInjector myErrorInjector;
    private ITimeControl myTimeControl;
    private AsyncDictionary`2<long, Action`2<ReturnCode, Byte[]>> myPendingCalls;
    private ILogger myLogger;
    private CancellationTokenSource myCancelSource;
    private CancellationToken myCancel;
    [NullableAttribute("2")]
private Stream myInbound;
    [NullableAttribute("2")]
private Stream myOutbound;
    [NullableAttribute("2")]
private Task`1<bool> myResponseReading;
    private long myNextCallId;
    private long myStarted;
    private long myKilled;
    public bool Started { get; }
    [NullableContextAttribute("2")]
public RpcTransport(Nullable`1<TimeSpan> termTimeout, IErrorInjector errorInjector, ITimeControl timeControl);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void add_RequestSent(RequestSentHandler value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void remove_RequestSent(RequestSentHandler value);
    public bool get_Started();
    public void Start(Stream inbound, Stream outbound);
    public void Kill();
    [AsyncStateMachineAttribute("JetBrains.Profiler.Windows.SysTools.Impl.RpcTransport/<OnDisposeAsync>d__8")]
protected virtual Task OnDisposeAsync();
    [AsyncStateMachineAttribute("JetBrains.Profiler.Windows.SysTools.Impl.RpcTransport/<CallAsync>d__9")]
public Task`1<Byte[]> CallAsync(MethodType type, byte methodId, Byte[] arguments, Nullable`1<TaggedTimeout> timeout, Nullable`1<CancellationToken> cancel);
    [AsyncStateMachineAttribute("JetBrains.Profiler.Windows.SysTools.Impl.RpcTransport/<SendRequestAsync>d__10")]
private Task SendRequestAsync(long callId, MethodType type, byte methodId, Byte[] body);
    private void HandleResponse(byte methodId, ReturnCode returnCode, Byte[] response, TaskCompletionSource`1<Byte[]> resultPromise);
    [AsyncStateMachineAttribute("JetBrains.Profiler.Windows.SysTools.Impl.RpcTransport/<StartResponseReadLoopAsync>d__12")]
private Task`1<bool> StartResponseReadLoopAsync();
    [AsyncStateMachineAttribute("JetBrains.Profiler.Windows.SysTools.Impl.RpcTransport/<StopResponseReadLoopAsync>d__13")]
private Task StopResponseReadLoopAsync();
    [AsyncStateMachineAttribute("JetBrains.Profiler.Windows.SysTools.Impl.RpcTransport/<ReadResponseAsync>d__14")]
private Task`1<bool> ReadResponseAsync();
    [AsyncStateMachineAttribute("JetBrains.Profiler.Windows.SysTools.Impl.RpcTransport/<TryReadResponseHeaderAsync>d__15")]
private Task`1<Nullable`1<RpcResponseHeader>> TryReadResponseHeaderAsync();
    [AsyncStateMachineAttribute("JetBrains.Profiler.Windows.SysTools.Impl.RpcTransport/<ReadResponseBodyAsync>d__16")]
private Task`1<Byte[]> ReadResponseBodyAsync(RpcResponseHeader header);
    private void SetStarted();
}
public class JetBrains.Profiler.Windows.SysTools.Impl.RpcUnknownReturnCodeError : RpcServerSideError {
    public RpcUnknownReturnCodeError(ReturnCode code);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.Profiler.Windows.SysTools.Impl.RpcWatchDog : AsyncDisposable {
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private SessionDisposedHandler SessionDisposed;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private SessionRestoredHandler2 SessionRestored;
    public long RestoreSessionCount;
    private CancellationTokenSource myCancel;
    private List`1<DateTime> myFails;
    private ILogger myLogger;
    private RpcSessionSwitch mySessionSwitch;
    private Nullable`1<long> myLimit;
    private TimeSpan myWindow;
    private TimeSpan myDelay;
    private ITimeControl myTimeControl;
    public RpcWatchDog(IRpcSession session, Nullable`1<long> limit, Nullable`1<TimeSpan> delay, Nullable`1<TimeSpan> window, ITimeControl tc);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void add_SessionDisposed(SessionDisposedHandler value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void remove_SessionDisposed(SessionDisposedHandler value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void add_SessionRestored(SessionRestoredHandler2 value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void remove_SessionRestored(SessionRestoredHandler2 value);
    [AsyncStateMachineAttribute("JetBrains.Profiler.Windows.SysTools.Impl.RpcWatchDog/<OnDisposeAsync>d__8")]
protected virtual Task OnDisposeAsync();
    [AsyncStateMachineAttribute("JetBrains.Profiler.Windows.SysTools.Impl.RpcWatchDog/<OpenAsync>d__9")]
public Task OpenAsync();
    [AsyncStateMachineAttribute("JetBrains.Profiler.Windows.SysTools.Impl.RpcWatchDog/<CallAsync>d__10")]
public Task`1<Byte[]> CallAsync(byte methodId, Byte[] arguments, Nullable`1<TaggedTimeout> timeout, Nullable`1<CancellationToken> cancel);
    private void ObserveSession(IRpcSession session);
    [AsyncStateMachineAttribute("JetBrains.Profiler.Windows.SysTools.Impl.RpcWatchDog/<RestoreSessionAsync>d__12")]
private Task`1<Tuple`2<IRpcSession, RpcSessionNotRecoverable>> RestoreSessionAsync(IRpcSession failedSession, Exception err);
    private bool ContinueRestore();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.Profiler.Windows.SysTools.Impl.RunningAgent : object {
    [CompilerGeneratedAttribute]
private Stream <Channel>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    public Stream Channel { get; }
    public string Description { get; }
    public RunningAgent(Stream channel, string description);
    [CompilerGeneratedAttribute]
public Stream get_Channel();
    [CompilerGeneratedAttribute]
public string get_Description();
}
internal class JetBrains.Profiler.Windows.SysTools.Impl.SemaphoreProxy : object {
    private static int TimeoutTouch;
    private static ILogger ourLogger;
    private LifetimeDefinition myDestroy;
    private Guid myId;
    private SemaphoreTools mySemaphoreTools;
    private int myWasDisposed;
    internal SemaphoreProxy(Lifetime lifetime, SemaphoreTools semaphoreTools, bool withTouch, Guid id);
    private static SemaphoreProxy();
    public sealed virtual bool WaitOne(TimeSpan timeout);
    public sealed virtual bool WaitOne(int timeout);
    public sealed virtual bool WaitOne();
    public sealed virtual int Release();
    public sealed virtual int Release(int times);
    public sealed virtual void Close();
    private void AssertAlive();
    [CompilerGeneratedAttribute]
private void <.ctor>b__6_0();
    [CompilerGeneratedAttribute]
private void <.ctor>b__6_1(object _);
    [CompilerGeneratedAttribute]
private void <.ctor>b__6_2();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class JetBrains.Profiler.Windows.SysTools.Impl.SemaphoreSlimEx : object {
    [ExtensionAttribute]
public static T Lock(SemaphoreSlim sema, Func`1<T> fun);
    [ExtensionAttribute]
public static void Lock(SemaphoreSlim sema, Action fun);
    [AsyncStateMachineAttribute("JetBrains.Profiler.Windows.SysTools.Impl.SemaphoreSlimEx/<LockAsync>d__2`1")]
[ExtensionAttribute]
public static Task`1<T> LockAsync(SemaphoreSlim sema, Func`1<T> fun);
    [AsyncStateMachineAttribute("JetBrains.Profiler.Windows.SysTools.Impl.SemaphoreSlimEx/<LockAsync>d__3")]
[ExtensionAttribute]
public static Task LockAsync(SemaphoreSlim sema, Action fun);
    [AsyncStateMachineAttribute("JetBrains.Profiler.Windows.SysTools.Impl.SemaphoreSlimEx/<LockAsync>d__4`1")]
[ExtensionAttribute]
public static Task`1<T> LockAsync(SemaphoreSlim sema, Func`1<Task`1<T>> fun);
    [AsyncStateMachineAttribute("JetBrains.Profiler.Windows.SysTools.Impl.SemaphoreSlimEx/<LockAsync>d__5")]
[ExtensionAttribute]
public static Task LockAsync(SemaphoreSlim sema, Func`1<Task> fun);
}
internal class JetBrains.Profiler.Windows.SysTools.Impl.ServiceProxy : object {
    private static int TimeoutTouch;
    private static ILogger ourLogger;
    private LifetimeDefinition myDestroy;
    private Guid myId;
    private WindowsServiceTools myWindowsServiceTools;
    private int myWasDisposed;
    public string Name { get; }
    public string DisplayName { get; }
    public ServiceStartMode StartType { get; }
    public ServiceType ServiceType { get; }
    public ServiceControllerStatus Status { get; }
    public bool CanStop { get; }
    public bool CanPauseAndContinue { get; }
    public bool CanShutdown { get; }
    public String[] ServicesDependedOn { get; }
    public String[] DependentServices { get; }
    public String[] SameProcessServices { get; }
    public String[] SameImagePathServices { get; }
    public string SvcHostGroup { get; }
    public String[] SvcHostServices { get; }
    internal ServiceProxy(Lifetime lifetime, WindowsServiceTools windowsServiceTools, bool withTouch, Guid id);
    private static ServiceProxy();
    public sealed virtual string get_Name();
    public sealed virtual string get_DisplayName();
    public sealed virtual ServiceStartMode get_StartType();
    public sealed virtual ServiceType get_ServiceType();
    public sealed virtual ServiceControllerStatus get_Status();
    public sealed virtual bool get_CanStop();
    public sealed virtual bool get_CanPauseAndContinue();
    public sealed virtual bool get_CanShutdown();
    public sealed virtual String[] get_ServicesDependedOn();
    public sealed virtual String[] get_DependentServices();
    public sealed virtual String[] get_SameProcessServices();
    public sealed virtual String[] get_SameImagePathServices();
    public sealed virtual string get_SvcHostGroup();
    public sealed virtual String[] get_SvcHostServices();
    public sealed virtual IProcessProxy GetProcess(Lifetime lifetime);
    public sealed virtual void Start(String[] args);
    public sealed virtual void Stop();
    public sealed virtual void Pause();
    public sealed virtual void Continue();
    public sealed virtual void Close();
    private void AssertAlive();
    [CompilerGeneratedAttribute]
private void <.ctor>b__6_0();
    [CompilerGeneratedAttribute]
private void <.ctor>b__6_1(object _);
    [CompilerGeneratedAttribute]
private void <.ctor>b__6_2();
}
public class JetBrains.Profiler.Windows.SysTools.Impl.SessionDisposedHandler : MulticastDelegate {
    public SessionDisposedHandler(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(object sender, EventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, EventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class JetBrains.Profiler.Windows.SysTools.Impl.SessionNotAliveHandler : MulticastDelegate {
    public SessionNotAliveHandler(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(object sender, EventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, EventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class JetBrains.Profiler.Windows.SysTools.Impl.SessionRestoredHandler2 : MulticastDelegate {
    public SessionRestoredHandler2(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(object sender, EventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, EventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[ExtensionAttribute]
public static class JetBrains.Profiler.Windows.SysTools.Impl.StreamEx : object {
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("JetBrains.Profiler.Windows.SysTools.Impl.StreamEx/<ReadBytesAsync>d__0")]
[ExtensionAttribute]
public static Task`1<Byte[]> ReadBytesAsync(Stream stream, ulong count, Nullable`1<CancellationToken> cancel);
}
public class JetBrains.Profiler.Windows.SysTools.Impl.SystemTimeControl : object {
    public DateTime UtcNow { get; }
    public sealed virtual DateTime get_UtcNow();
    [NullableContextAttribute("1")]
public sealed virtual Task`1<bool> WaitSemaAsync(SemaphoreSlim sema, TimeSpan timeout, string _);
    [NullableContextAttribute("1")]
public sealed virtual Task WaitAsync(TimeSpan timeout, string _);
}
internal static class JetBrains.Profiler.Windows.SysTools.Impl.SysToolsRootRegistryPaths : object {
    public static BackSlashSeparatedRelativePath Profiler;
    public static BackSlashSeparatedRelativePath ProfilerGlobal;
    public static BackSlashSeparatedRelativePath ProfilerTransparentIntegration;
    private static SysToolsRootRegistryPaths();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.Profiler.Windows.SysTools.Impl.TaggedTimeout : ValueType {
    public TimeSpan Value;
    public string Tag;
    public TaggedTimeout(TimeSpan value, string tag);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class JetBrains.Profiler.Windows.SysTools.Impl.TaskEx : object {
    [AsyncStateMachineAttribute("JetBrains.Profiler.Windows.SysTools.Impl.TaskEx/<WithTimeout>d__0`1")]
[ExtensionAttribute]
public static Task`1<T> WithTimeout(Task`1<T> task, Nullable`1<TimeSpan> timeout, ITimeControl tc, string timerName);
    [AsyncStateMachineAttribute("JetBrains.Profiler.Windows.SysTools.Impl.TaskEx/<WithTimeout>d__1")]
[ExtensionAttribute]
public static Task WithTimeout(Task task, Nullable`1<TimeSpan> timeout, ITimeControl tc, string timerName);
    [AsyncStateMachineAttribute("JetBrains.Profiler.Windows.SysTools.Impl.TaskEx/<WithCancel>d__2`1")]
[ExtensionAttribute]
public static Task`1<T> WithCancel(Task`1<T> task, Nullable`1<CancellationToken> cancel);
    [AsyncStateMachineAttribute("JetBrains.Profiler.Windows.SysTools.Impl.TaskEx/<WithCancel>d__3")]
[ExtensionAttribute]
public static Task WithCancel(Task task, Nullable`1<CancellationToken> cancel);
    [AsyncStateMachineAttribute("JetBrains.Profiler.Windows.SysTools.Impl.TaskEx/<Defer>d__4")]
public static Task Defer(Func`1<Task> fun);
    [AsyncStateMachineAttribute("JetBrains.Profiler.Windows.SysTools.Impl.TaskEx/<Defer>d__5`1")]
public static Task`1<T> Defer(Func`1<Task`1<T>> fun);
    [AsyncStateMachineAttribute("JetBrains.Profiler.Windows.SysTools.Impl.TaskEx/<Defer>d__6")]
public static Task Defer(Action fun);
    public static void Detach(Func`1<Task> fun);
    public static void Detach(Action fun);
    public static void RunAwait(Func`1<Task> fun);
    public static T RunAwait(Func`1<Task`1<T>> fun);
    [AsyncStateMachineAttribute("JetBrains.Profiler.Windows.SysTools.Impl.TaskEx/<WithExceptionLogging>d__11")]
[ExtensionAttribute]
public static Task WithExceptionLogging(Task task, ILogger logger, LoggingLevel level, bool rethrow);
}
public class JetBrains.Profiler.Windows.SysTools.Impl.TcpAgency : ProcessAgency {
    [NullableContextAttribute("2")]
public TcpAgency(Nullable`1<TimeSpan> termTimeout, Nullable`1<TimeSpan> connectTimeout, ITimeControl timeControl, IErrorInjector errorInjector);
    [NullableContextAttribute("1")]
private static IStreamServer CreateServer();
}
public class JetBrains.Profiler.Windows.SysTools.Impl.TcpConnection : object {
    [CompilerGeneratedAttribute]
private Stream <Stream>k__BackingField;
    private TcpClient myConnection;
    public Stream Stream { get; }
    public TcpConnection(TcpClient connection);
    [CompilerGeneratedAttribute]
public sealed virtual Stream get_Stream();
    public sealed virtual void Dispose();
    public sealed virtual void Break();
    public sealed virtual void Close();
}
public class JetBrains.Profiler.Windows.SysTools.Impl.TcpLocalServer : object {
    private TcpListener myServer;
    public sealed virtual IServerDescriptor Start();
    public sealed virtual void Stop();
    [AsyncStateMachineAttribute("JetBrains.Profiler.Windows.SysTools.Impl.TcpLocalServer/<AcceptAsync>d__2")]
public sealed virtual Task`1<IConnection> AcceptAsync();
}
public class JetBrains.Profiler.Windows.SysTools.Impl.TcpServerDescriptor : object {
    [CompilerGeneratedAttribute]
private string <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    public string Type { get; }
    public string Id { get; }
    public string HumanReadable { get; }
    public TcpServerDescriptor(int port);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Type();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Id();
    public sealed virtual string get_HumanReadable();
}
internal class JetBrains.Profiler.Windows.SysTools.Impl.UnixEventWaitHandle : object {
    private SafeSemHandle mySem;
    private string mySemName;
    private bool myShouldUnlink;
    private UnixEventWaitHandle(SafeSemHandle sem, string name, bool shouldUnlink);
    [NotNullAttribute]
public static string GenerateUniqueName();
    [NotNullAttribute]
public static UnixEventWaitHandle Create(bool initialState, EventResetMode mode, string name, Boolean& createdNew);
    [NotNullAttribute]
public static UnixEventWaitHandle OpenExisting(string name);
    public sealed virtual bool Reset();
    public sealed virtual bool Set();
    public sealed virtual void Close();
    public sealed virtual bool WaitOne();
    public sealed virtual bool WaitOne(int millisecondsTimeout);
    public sealed virtual bool WaitOne(TimeSpan timeout);
    [CompilerGeneratedAttribute]
private bool <WaitOne>b__11_0();
}
internal class JetBrains.Profiler.Windows.SysTools.Impl.Win32EventWaitHandle : object {
    private EventWaitHandle myEventWaitHandle;
    internal Win32EventWaitHandle(EventWaitHandle ewh);
    public sealed virtual bool Reset();
    public sealed virtual bool Set();
    public sealed virtual void Close();
    public sealed virtual bool WaitOne();
    public sealed virtual bool WaitOne(int millisecondsTimeout);
    public sealed virtual bool WaitOne(TimeSpan timeout);
}
public interface JetBrains.Profiler.Windows.SysTools.IProcessProxy {
    public int ProcessId { get; }
    public int SessionId { get; }
    public long AuthenticationId { get; }
    public long StartTimestamp { get; }
    [CanBeNullAttribute]
public string ProcessName { get; }
    [CanBeNullAttribute]
public string PathToExecutable { get; }
    public int ExitCode { get; }
    public bool HasExited { get; }
    public JetArchitecture Architecture { get; }
    public bool IsStarted { get; }
    public abstract virtual int get_ProcessId();
    public abstract virtual int get_SessionId();
    public abstract virtual long get_AuthenticationId();
    public abstract virtual long get_StartTimestamp();
    public abstract virtual string get_ProcessName();
    public abstract virtual string get_PathToExecutable();
    public abstract virtual int get_ExitCode();
    public abstract virtual bool get_HasExited();
    public abstract virtual JetArchitecture get_Architecture();
    public abstract virtual bool get_IsStarted();
    public abstract virtual bool Start();
    public abstract virtual bool StartSuspended(Action beforeResume);
    public abstract virtual void Kill();
    public abstract virtual void KillTree();
    public abstract virtual bool CloseMainWindow();
    public abstract virtual void CloseAllWindows();
    public abstract virtual bool WaitForExit(TimeSpan timeout);
    public abstract virtual bool WaitForExit(int timeout);
    public abstract virtual bool WaitForExit();
    public abstract virtual void Close();
}
public interface JetBrains.Profiler.Windows.SysTools.ISemaphoreProxy {
    public abstract virtual int Release();
    public abstract virtual int Release(int times);
}
public interface JetBrains.Profiler.Windows.SysTools.IServiceProxy {
    [NotNullAttribute]
public string Name { get; }
    [NotNullAttribute]
public string DisplayName { get; }
    public ServiceStartMode StartType { get; }
    public ServiceType ServiceType { get; }
    public ServiceControllerStatus Status { get; }
    public bool CanStop { get; }
    public bool CanPauseAndContinue { get; }
    public bool CanShutdown { get; }
    [NotNullAttribute]
public String[] ServicesDependedOn { get; }
    [NotNullAttribute]
public String[] DependentServices { get; }
    [NotNullAttribute]
public String[] SameProcessServices { get; }
    [NotNullAttribute]
public String[] SameImagePathServices { get; }
    [CanBeNullAttribute]
public string SvcHostGroup { get; }
    [NotNullAttribute]
public String[] SvcHostServices { get; }
    public abstract virtual string get_Name();
    public abstract virtual string get_DisplayName();
    public abstract virtual ServiceStartMode get_StartType();
    public abstract virtual ServiceType get_ServiceType();
    public abstract virtual ServiceControllerStatus get_Status();
    public abstract virtual bool get_CanStop();
    public abstract virtual bool get_CanPauseAndContinue();
    public abstract virtual bool get_CanShutdown();
    public abstract virtual String[] get_ServicesDependedOn();
    public abstract virtual String[] get_DependentServices();
    public abstract virtual String[] get_SameProcessServices();
    public abstract virtual String[] get_SameImagePathServices();
    public abstract virtual string get_SvcHostGroup();
    public abstract virtual String[] get_SvcHostServices();
    [CanBeNullAttribute]
public abstract virtual IProcessProxy GetProcess(Lifetime lifetime);
    public abstract virtual void Start(String[] args);
    public abstract virtual void Stop();
    public abstract virtual void Pause();
    public abstract virtual void Continue();
    public abstract virtual void Close();
}
public interface JetBrains.Profiler.Windows.SysTools.IWaitHandleProxy {
    public abstract virtual bool WaitOne(TimeSpan timeout);
    public abstract virtual bool WaitOne(int timeout);
    public abstract virtual bool WaitOne();
    public abstract virtual void Close();
}
public class JetBrains.Profiler.Windows.SysTools.LeafTestTools : BaseServiceRemotable`1<SysTools> {
    private static ILogger ourLogger;
    public LeafTestTools(SysTools root, String[] ids, ServiceCreatorDelegate<SysTools> serviceCreator);
    private static LeafTestTools();
    [RemotableCallAttribute]
[NotNullAttribute]
public virtual string SelfCheckCall(string str, String& res);
    [RemotableLongCallAttribute]
[NotNullAttribute]
public virtual string SelfCheckLongCall(string str);
    [RemotableCallAttribute]
[NotNullAttribute]
public virtual string RootSelfCheck(string str, String& res);
}
public class JetBrains.Profiler.Windows.SysTools.LifetimeTools : BaseServiceRemotable`1<SysTools> {
    private static int TimeoutExpired;
    private static int TimeoutTouch;
    private static ILogger ourLogger;
    private WatchedDictionary`1<LifetimeDefinition> myLifetimeDefinitions;
    public LifetimeTools(SysTools root, String[] ids, ServiceCreatorDelegate<SysTools> serviceCreator);
    private static LifetimeTools();
    [NotNullAttribute]
public ILifetimeIdentity CreateLifetime(Lifetime lifetime);
    [NotNullAttribute]
public Lifetime GetLifetime(ILifetimeIdentity lifetimeIdentity);
    [RemotableCallAttribute]
public virtual LifetimeIdentity LifetimeDefinition_Create();
    [RemotableCallAttribute]
public virtual void LifetimeDefinition_TerminateAndClose(LifetimeIdentity lifetimeIdentity);
    [RemotableCallAttribute]
public virtual void LifetimeDefinition_Touch(LifetimeIdentity lifetimeIdentity);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class JetBrains.Profiler.Windows.SysTools.MetroTools : BaseServiceRemotable`1<SysTools> {
    private static ILogger ourLogger;
    private static MessageResult ourMessageResult_InvalidOs;
    private static MessageResult ourMessageResult_InvalidOsVersion;
    private static MessageResult ourMessageResult_UACNotActive;
    private static MessageResult ourMessageResult_Communication;
    private FileSystemPath modreq(System.Runtime.CompilerServices.IsVolatile) myExecutable;
    private ReactiveState`2<IEnumerable`1<PackageInfo>, bool> myPackageList;
    private bool myPrefetchPackages;
    [CompilerGeneratedAttribute]
private bool <UseWinRtHelper>k__BackingField;
    public bool UseWinRtHelper { get; public set; }
    public MetroTools(SysTools root, String[] ids, ServiceCreatorDelegate<SysTools> serviceCreator);
    private static MetroTools();
    public void SetupPrefetch();
    [CompilerGeneratedAttribute]
[RemotableCallAttribute]
public virtual bool get_UseWinRtHelper();
    [CompilerGeneratedAttribute]
[RemotableCallAttribute]
public virtual void set_UseWinRtHelper(bool value);
    [RemotableCallAttribute]
public virtual bool HasExecutable();
    [NullableContextAttribute("2")]
[RemotableCallAttribute]
public virtual void SetExecutable(string fileName);
    [RemotableCallAttribute]
public virtual MessageResult IsSupported();
    [NullableContextAttribute("2")]
[RemotableCallAttribute]
public virtual string GetPackageFullName(int pid);
    public void UpdateDisplay(MetroArgument argument);
    [RemotableLongCallAttribute]
public virtual void PrepareAttachProfiling(UInt32 sessionId, string packageFullName);
    [RemotableLongCallAttribute]
public virtual void CleanAttachProfiling(UInt32 sessionId, string packageFullName);
    [RemotableLongCallAttribute]
public virtual void PrepareStartProfiling(string packageFullName, IEnumerable`1<UpdateEnvironmentProperty> environmentVariables);
    [RemotableLongCallAttribute]
public virtual void CleanStartProfiling(string packageFullName);
    [RemotableLongCallAttribute]
public virtual void RunProfiling(string appUserModelId, string arguments);
    [RemotableLongCallAttribute]
public virtual IEnumerable`1<PackageInfo> GetMetroPackagesForCurrentUser(bool forceUpdate);
    private IEnumerable`1<PackageInfo> GetMetroPackagesForCurrentUserImpl();
    [RemotableLongCallAttribute]
public virtual void PrepareEverythingProfiling();
    [RemotableLongCallAttribute]
public virtual void CleanEverythingProfiling();
    private static FileSystemPath CheckExecutable(FileSystemPath executable);
    private FileSystemPath GetExecutable();
    private void RunWinRtHelper(bool runAsReducedUser, Func`3<FileSystemPath, Func`1<FileSystemPath>, String[]> getArguments, Func`2<FileSystemPath, Tuple`2<HResults, string>> parseResult);
    private T RunWinRtHelper(bool runAsReducedUser, Func`3<FileSystemPath, Func`1<FileSystemPath>, String[]> getArguments, Func`2<FileSystemPath, Tuple`3<HResults, string, T>> parseResult);
    [CompilerGeneratedAttribute]
private IEnumerable`1<PackageInfo> <.ctor>b__8_0(IEnumerable`1<PackageInfo> _, bool _);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private MessageResult <IsSupported>b__16_0();
}
public class JetBrains.Profiler.Windows.SysTools.MonoTools : BaseServiceRemotable`1<SysTools> {
    private static ILogger ourLogger;
    private static Regex ourMonoVersionRegex;
    public MonoTools(SysTools root, String[] ids, ServiceCreatorDelegate<SysTools> serviceCreator);
    private static MonoTools();
    private static Version GetMonoVersion(FileSystemPath executable);
    [NotNullAttribute]
private IEnumerable`1<MonoInfo> GetMonoRuntimes_Windows();
    [NotNullAttribute]
private IEnumerable`1<MonoInfo> GetMonoRuntimes_Linux();
    [NotNullAttribute]
private IEnumerable`1<MonoInfo> GetMonoRuntimes_MacOs();
    [NotNullAttribute]
private IEnumerable`1<MonoInfo> GetMonoRuntimes_Unix(JetArchitecture architecture, IEnumerable`1<FileSystemPath> executablePaths);
    [NotNullAttribute]
[RemotableLongCallAttribute]
public virtual IEnumerable`1<MonoInfo> GetMonoRuntimes();
    [NotNullAttribute]
[RemotableLongCallAttribute]
public virtual string GetFirstSuitableMonoRuntime();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class JetBrains.Profiler.Windows.SysTools.ProcessHelperTools : BaseServiceRemotable`1<SysTools> {
    private static ILogger ourLogger;
    private IProcessAgency myAgency;
    private Dictionary`2<JetArchitecture, Task`1<ProcMonClient>> myAgents;
    public ProcessHelperTools(SysTools root, String[] ids, ServiceCreatorDelegate<SysTools> serviceCreator);
    private static ProcessHelperTools();
    protected virtual void OnDispose();
    [RemotableCallAttribute]
public virtual bool HasExecutable(JetArchitecture architecture);
    [RemotableCallAttribute]
public virtual void SetExecutable(JetArchitecture architecture, string fileName);
    public void AttachToProcess(JetArchitecture arch, int pid, RuntimeInfo runtime, Guid profileGuid, string profilerDll);
    public IEnumerable`1<ProcessInfo> ListProcesses(JetArchitecture arch, bool includeNative);
    public void WinRtPrepareAttachProfiling(UInt32 sessionId, string packageFullName);
    public void WinRtCleanAttachProfiling(UInt32 sessionId, string packageFullName);
    public void WinRtCleanEverythingProfiling();
    public void WinRtPrepareEverythingProfiling();
    public IEnumerable`1<PackageInfo> WinRtGetPackagesForCurrentUser();
    public void WinRtRunProfiling(string appUserModelId, string arguments);
    public void WinRtCleanStartProfiling(string packageFullName);
    public void WinRtPrepareStartProfiling(string packageFullName, IEnumerable`1<UpdateEnvironmentProperty> env);
    private Task`1<ProcMonClient> GetAgent(Nullable`1<JetArchitecture> arch);
    private void CloseAgents();
    [AsyncStateMachineAttribute("JetBrains.Profiler.Windows.SysTools.ProcessHelperTools/<<CloseAgents>b__18_0>d")]
[CompilerGeneratedAttribute]
private Task <CloseAgents>b__18_0();
    [NullableContextAttribute("0")]
[AsyncStateMachineAttribute("JetBrains.Profiler.Windows.SysTools.ProcessHelperTools/<<CloseAgents>b__18_1>d")]
[CompilerGeneratedAttribute]
private Task <CloseAgents>b__18_1();
}
public class JetBrains.Profiler.Windows.SysTools.ProcessTools : BaseServiceRemotable`1<SysTools> {
    private static int TimeoutExpired;
    private static ILogger ourLogger;
    private WatchedDictionary`1<Tuple`2<Process, UInt32>> myProcesses;
    private static int ourUid;
    public ProcessTools(SysTools root, String[] ids, ServiceCreatorDelegate<SysTools> serviceCreator);
    private static ProcessTools();
    protected virtual void OnDispose();
    [NotNullAttribute]
[NotRemotableAttribute]
public IProcessProxy CreateProcess(Lifetime lifetime, RemotableProcessStartInfo startInfo);
    [CanBeNullAttribute]
[NotRemotableAttribute]
public IProcessProxy GetProcessById(Lifetime lifetime, int processId);
    [RemotableLongCallAttribute]
public virtual void ExecuteBrowser(Tuple`2<ProcessInfo, MetroInfo> startInfo);
    [RemotableCallAttribute]
public virtual bool HasByProcessName(string processName);
    [RemotableCallAttribute]
public virtual bool HasByProcessName(string processNamePattern, RegexOptions regexOptions);
    [RemotableLongCallAttribute]
public virtual void KillByProcessName(string processName);
    [RemotableLongCallAttribute]
public virtual void KillByProcessName(string processNamePattern, RegexOptions regexOptions);
    [NotNullAttribute]
[RemotableCallAttribute]
public virtual RemotableProcessInfo Process_GetById(int processId);
    [NotNullAttribute]
[RemotableLongCallAttribute]
public virtual RemotableProcessInfo Process_Start(RemotableProcessStartInfo processStartInfo, bool suspended);
    private static void FixEnvPathUnix(StringDictionary envVars);
    private RemotableProcessInfo Run(ProcessStartInfo startInfo, int uid, bool createNewProcessGroup, bool suspended, bool createNewConsole);
    [RemotableLongCallAttribute]
public virtual void Process_Resume(Guid id);
    [RemotableLongCallAttribute]
public virtual bool Process_WaitForExit(Guid id, TimeSpan timeout);
    [RemotableLongCallAttribute]
public virtual bool Process_WaitForExit(Guid id, int timeout);
    [RemotableLongCallAttribute]
public virtual bool Process_WaitForExit(Guid id);
    [RemotableCallAttribute]
public virtual void Process_Kill(Guid id);
    [RemotableLongCallAttribute]
public virtual void Process_KillTree(Guid id);
    [RemotableLongCallAttribute]
public virtual bool Process_CloseMainWindow(Guid id);
    [RemotableLongCallAttribute]
public virtual void Process_CloseAllWindows(Guid id);
    [RemotableCallAttribute]
public virtual bool Process_HasExited(Guid id);
    [RemotableCallAttribute]
public virtual int Process_ExitCode(Guid id);
    [RemotableCallAttribute]
public virtual string Process_PathToExecutable(Guid id);
    [RemotableCallAttribute]
public virtual void Process_Touch(Guid id);
    [RemotableCallAttribute]
public virtual void Process_Close(Guid id);
}
public class JetBrains.Profiler.Windows.SysTools.RemotableProcessInfo : object {
    public long AuthenticationId;
    public Guid Id;
    public JetArchitecture Architecture;
    [CanBeNullAttribute]
public string Name;
    public int ProcessId;
    public UInt32 ThreadId;
    public int SessionId;
    public long StartTimestamp;
    public RemotableProcessInfo(Guid id, int processId, int sessionId, long authenticationId, long startTimestamp, JetArchitecture architecture, string name);
    public RemotableProcessInfo(Guid id, int processId, UInt32 threadId, int sessionId, long authenticationId, long startTimestamp, JetArchitecture architecture, string name);
}
public class JetBrains.Profiler.Windows.SysTools.RemotableProcessStartInfo : object {
    [CanBeNullAttribute]
public string Arguments;
    public bool CreateNewProcessGroup;
    public bool CreateNoWindow;
    public bool CreateNewConsole;
    public bool DisableFsRedirection;
    [CanBeNullAttribute]
public UpdateEnvironmentProperty[] EnvironmentProperties;
    [CanBeNullAttribute]
public string FileName;
    [CanBeNullAttribute]
public string WorkingDirectory;
}
public class JetBrains.Profiler.Windows.SysTools.RunTools : BaseServiceRemotable`1<SysTools> {
    private static int TimeoutRun;
    private static ILogger ourLogger;
    private static string ScExecutable;
    public RunTools(SysTools root, String[] ids, ServiceCreatorDelegate<SysTools> serviceCreator);
    private static RunTools();
    [RemotableCallAttribute]
public virtual String[] RunListServices();
    [RemotableCallAttribute]
public virtual void RunUninstallService(string serviceName);
    [RemotableCallAttribute]
public virtual void RunInstallService(string serviceName, string remoteServiceFile, WindowsServiceMode mode, IReadOnlyCollection`1<string> dependentOn, string displayName);
    [RemotableLongCallAttribute]
public virtual int RunConsoleExecutable(string executable, String[] arguments, IEnumerable`1<UpdateEnvironmentProperty> environmentProperties);
}
public class JetBrains.Profiler.Windows.SysTools.SemaphoreTools : BaseServiceRemotable`1<SysTools> {
    private static int TimeoutExpired;
    private static ILogger ourLogger;
    private WatchedDictionary`1<Semaphore> mySemaphores;
    public SemaphoreTools(SysTools root, String[] ids, ServiceCreatorDelegate<SysTools> serviceCreator);
    private static SemaphoreTools();
    protected virtual void OnDispose();
    [NotRemotableAttribute]
[NotNullAttribute]
public ISemaphoreProxy CreateSemaphore(Lifetime lifetime, int initValue, int maxValue, string name);
    [NotRemotableAttribute]
[CanBeNullAttribute]
public ISemaphoreProxy TryOpenSemaphore(Lifetime lifetime, string name);
    [NotRemotableAttribute]
[CanBeNullAttribute]
public ISemaphoreProxy OpenSemaphore(Lifetime lifetime, string name);
    [NotRemotableAttribute]
public bool HasSemaphore(string name);
    [RemotableCallAttribute]
public virtual Guid Semaphore_Create(int initValue, int maxValue, string name);
    [RemotableCallAttribute]
public virtual Guid Semaphore_Open(string name);
    [RemotableCallAttribute]
public virtual bool Semaphore_Has(string name);
    [RemotableLongCallAttribute]
public virtual bool Semaphore_WaitOne(Guid id, TimeSpan timeout);
    [RemotableLongCallAttribute]
public virtual bool Semaphore_WaitOne(Guid id, int timeout);
    [RemotableLongCallAttribute]
public virtual bool Semaphore_WaitOne(Guid id);
    [RemotableCallAttribute]
public virtual int Semaphore_Release(Guid id);
    [RemotableCallAttribute]
public virtual int Semaphore_Release(Guid id, int times);
    [RemotableCallAttribute]
public virtual void Semaphore_Touch(Guid id);
    [RemotableCallAttribute]
public virtual void Semaphore_Close(Guid id);
}
internal class JetBrains.Profiler.Windows.SysTools.SocketListener : object {
    [NotNullAttribute]
private Socket mySocket;
    [NotNullAttribute]
private Func`2<Socket, ICommunicationToolsStream> myStreamFactory;
    public string LocalEndPoint { get; }
    private SocketListener(Socket socket);
    public static KeyValuePair`2<Guid, SocketListener> Create(IPEndPoint endPoint, Func`2<IListener, Guid> listenerRegistrator);
    public sealed virtual List`1<Guid> Accept(int timeout, Func`2<ICommunicationToolsStream, Guid> streamRegistrator);
    public sealed virtual string get_LocalEndPoint();
    public sealed virtual void InjectProxyStreamFactory(Type type, SysTools sysTools, Object[] args);
    public sealed virtual void Close();
}
public class JetBrains.Profiler.Windows.SysTools.SysTools : BaseServiceRemotable`1<SysTools> {
    private static ILogger ourLogger;
    [RemotableComponentAttribute]
[NotNullAttribute]
[UsedImplicitlyAttribute]
public AttachEnvironmentTools AttachEnvironmentTools;
    [RemotableComponentAttribute]
[NotNullAttribute]
[UsedImplicitlyAttribute]
public AttachTools AttachTools;
    [RemotableComponentAttribute]
[NotNullAttribute]
[UsedImplicitlyAttribute]
public BrowserTools BrowserTools;
    [RemotableComponentAttribute]
[NotNullAttribute]
[UsedImplicitlyAttribute]
public CleanupTools CleanupTools;
    [RemotableComponentAttribute]
[NotNullAttribute]
[UsedImplicitlyAttribute]
public CoreClrTools CoreClrTools;
    [RemotableComponentAttribute]
[NotNullAttribute]
[UsedImplicitlyAttribute]
public DirectoryTools DirectoryTools;
    [RemotableComponentAttribute]
[NotNullAttribute]
[UsedImplicitlyAttribute]
public EverythingEnvironmentTools EverythingEnvironmentTools;
    [RemotableComponentAttribute]
[NotNullAttribute]
[UsedImplicitlyAttribute]
public EnvironmentTools EnvironmentTools;
    [RemotableComponentAttribute]
[NotNullAttribute]
[UsedImplicitlyAttribute]
public EtwTools EtwTools;
    [RemotableComponentAttribute]
[NotNullAttribute]
[UsedImplicitlyAttribute]
public EventPipeTools EventPipeTools;
    [RemotableComponentAttribute]
[NotNullAttribute]
[UsedImplicitlyAttribute]
public EventTools EventTools;
    [RemotableComponentAttribute]
[NotNullAttribute]
[UsedImplicitlyAttribute]
public EverythingTools EverythingTools;
    [RemotableComponentAttribute]
[NotNullAttribute]
[UsedImplicitlyAttribute]
public ExecutableTools ExecutableTools;
    [RemotableComponentAttribute]
[NotNullAttribute]
[UsedImplicitlyAttribute]
public FileCacheTools FileCacheTools;
    [RemotableComponentAttribute]
[NotNullAttribute]
[UsedImplicitlyAttribute]
public FileTools FileTools;
    [RemotableComponentAttribute]
[NotNullAttribute]
[UsedImplicitlyAttribute]
public FileStorageTools FileStorageTools;
    [RemotableComponentAttribute]
[NotNullAttribute]
[UsedImplicitlyAttribute]
public FrameworkTools FrameworkTools;
    [RemotableComponentAttribute]
[NotNullAttribute]
[UsedImplicitlyAttribute]
public IISExpressTools IISExpressTools;
    [RemotableComponentAttribute]
[NotNullAttribute]
[UsedImplicitlyAttribute]
public IISTools IISTools;
    [RemotableComponentAttribute]
[NotNullAttribute]
[UsedImplicitlyAttribute]
public ArchitectureTools ArchitectureTools;
    [RemotableComponentAttribute]
[NotNullAttribute]
[UsedImplicitlyAttribute]
public MetroTools MetroTools;
    [RemotableComponentAttribute]
[NotNullAttribute]
[UsedImplicitlyAttribute]
public CommunicationTools CommunicationTools;
    [RemotableComponentAttribute]
[NotNullAttribute]
[UsedImplicitlyAttribute]
public ProcessTools ProcessTools;
    [RemotableComponentAttribute]
[NotNullAttribute]
[UsedImplicitlyAttribute]
public RegistryHiveTools RegistryHiveTools;
    [RemotableComponentAttribute]
[NotNullAttribute]
[UsedImplicitlyAttribute]
public RunTools RunTools;
    [RemotableComponentAttribute]
[NotNullAttribute]
[UsedImplicitlyAttribute]
public SemaphoreTools SemaphoreTools;
    [RemotableComponentAttribute]
[NotNullAttribute]
[UsedImplicitlyAttribute]
public TestTools TestTools;
    [RemotableComponentAttribute]
[NotNullAttribute]
[UsedImplicitlyAttribute]
public TransparentIntegrationTools TransparentIntegrationTools;
    [RemotableComponentAttribute]
[NotNullAttribute]
[UsedImplicitlyAttribute]
public WcfHostTools WcfHostTools;
    [RemotableComponentAttribute]
[NotNullAttribute]
[UsedImplicitlyAttribute]
public MonoTools MonoTools;
    [RemotableComponentAttribute]
[NotNullAttribute]
[UsedImplicitlyAttribute]
public WindowsServiceEnvironmentTools WindowsServiceEnvironmentTools;
    [RemotableComponentAttribute]
[NotNullAttribute]
[UsedImplicitlyAttribute]
public WindowsServiceTools WindowsServiceTools;
    [RemotableComponentAttribute]
[NotNullAttribute]
[UsedImplicitlyAttribute]
public LifetimeTools LifetimeTools;
    [RemotableComponentAttribute]
[NotNullAttribute]
[UsedImplicitlyAttribute]
public ProcessHelperTools ProcessHelperTools;
    private Nullable`1<JetPlatform> myRuntimePlatform;
    private OperatingSystem myOSVersion;
    private Nullable`1<bool> myIsElevatedProcess;
    private Nullable`1<bool> myIsUserInteractive;
    [NotRemotableAttribute]
public bool IsRunningUnderWindows { get; }
    [NotRemotableAttribute]
public JetPlatform RuntimePlatform { get; }
    [NotRemotableAttribute]
public OperatingSystem OSVersion { get; }
    [NotRemotableAttribute]
public bool IsElevatedProcess { get; }
    [NotRemotableAttribute]
public bool IsUserInteractive { get; }
    public SysTools(ServiceLocation location, String[] ids, ServiceCreatorDelegate<SysTools> serviceCreator);
    private static SysTools();
    [CanBeNullAttribute]
private static object CreateLocal(SysTools root, String[] ids, Type type);
    [RemotableCallAttribute]
[NotNullAttribute]
public virtual string SelfCheckCall(string str, String& res);
    [RemotableLongCallAttribute]
[NotNullAttribute]
public virtual string SelfCheckLongCall(string str);
    [NotRemotableAttribute]
internal KeyAccessRights CheckRights(KeyAccessRights rights);
    [RemotableCallAttribute]
public virtual void AdjustPrivilege(String[] seName, bool isEnabled);
    [NotRemotableTargetOnlyAttribute]
internal void UnderPrivileges(String[] seNames, Action action);
    protected internal virtual Stream OpenReadFile(string fileName);
    protected internal virtual Stream CreateAppendFile(string fileName);
    [NotRemotableAttribute]
public void AssertIsRunningUnderWindows();
    public bool get_IsRunningUnderWindows();
    public JetPlatform get_RuntimePlatform();
    [RemotableCallAttribute]
public virtual JetPlatform GetPlatform();
    public OperatingSystem get_OSVersion();
    [RemotableCallAttribute]
public virtual OperatingSystem GetOSVersion();
    [NotRemotableAttribute]
public void AssertIsElevatedProcess();
    public bool get_IsElevatedProcess();
    [RemotableCallAttribute]
public virtual bool GetIsElevatedProcess();
    public bool get_IsUserInteractive();
    [RemotableCallAttribute]
public virtual bool GetIsUserInteractive();
}
public class JetBrains.Profiler.Windows.SysTools.TestTools : BaseServiceRemotable`1<SysTools> {
    private static ILogger ourLogger;
    [RemotableComponentAttribute]
[NotNullAttribute]
[UsedImplicitlyAttribute]
public LeafTestTools LeafTestTools;
    public TestTools(SysTools root, String[] ids, ServiceCreatorDelegate<SysTools> serviceCreator);
    private static TestTools();
    [RemotableCallAttribute]
[NotNullAttribute]
public virtual string SelfCheckCall(string str, String& res);
    [RemotableLongCallAttribute]
[NotNullAttribute]
public virtual string SelfCheckLongCall(string str);
    [RemotableCallAttribute]
[NotNullAttribute]
public virtual string RootSelfCheck(string str, String& res);
}
public class JetBrains.Profiler.Windows.SysTools.Tools.ArchitectureTools : BaseServiceRemotable`1<SysTools> {
    private static Dictionary`2<string, CSIDL> ourCsidls;
    private Nullable`1<JetArchitecture> myToolsetArchitecture;
    private IReadOnlyCollection`1<JetArchitecture> myArchitectures;
    [NotRemotableAttribute]
public JetArchitecture ToolsetArchitecture { get; }
    [NotNullAttribute]
[NotRemotableAttribute]
public IReadOnlyCollection`1<JetArchitecture> Architectures { get; }
    public ArchitectureTools(SysTools root, String[] ids, ServiceCreatorDelegate<SysTools> serviceCreator);
    private static ArchitectureTools();
    [NotNullAttribute]
internal static string FixCSIDL(JetArchitecture osArchitecture, JetArchitecture currentProcessArchitecture, JetArchitecture targetProcessArchitecture, CSIDL csidl, Func`2<CSIDL, string> func);
    [NotNullAttribute]
private static string GetFolderPathWindows(Nullable`1<JetArchitecture> architecture, CSIDL csidl);
    [NotRemotableTargetOnlyAttribute]
internal void ForEachKeyAccessRights(Action`2<JetArchitecture, KeyAccessRights> action);
    [NotRemotableAttribute]
public KeyAccessRights GetRegistryRights(JetArchitecture architecture);
    [NotRemotableTargetOnlyAttribute]
internal static JetArchitecture GetArchitecture(Process process);
    [NotRemotableAttribute]
public bool IsRdtscSupported(JetArchitecture architecture);
    [NotNullAttribute]
[RemotableCallAttribute]
public virtual string GetFolderPath(Nullable`1<JetArchitecture> architecture, SpecialFolder folder);
    [ContractAnnotationAttribute("str:null => null")]
[RemotableCallAttribute]
public virtual string ExpandForCurrentUser(Nullable`1<JetArchitecture> architecture, string str);
    private static bool IsSpecialCases();
    public JetArchitecture get_ToolsetArchitecture();
    [RemotableCallAttribute]
public virtual JetArchitecture GetToolsetArchitecture();
    public IReadOnlyCollection`1<JetArchitecture> get_Architectures();
    [NotNullAttribute]
[RemotableCallAttribute]
public virtual IReadOnlyCollection`1<JetArchitecture> GetArchitectures();
}
public abstract class JetBrains.Profiler.Windows.SysTools.Tools.Browser.BrowserInfoProviderBase : object {
    [CompilerGeneratedAttribute]
private SysTools <Root>k__BackingField;
    protected SysTools Root { get; }
    public BrowserInfoProviderBase(SysTools root);
    [CompilerGeneratedAttribute]
protected SysTools get_Root();
    [NotNullAttribute]
public abstract virtual IReadOnlyList`1<InternetBrowserInfo> GetInternetBrowserInfos();
    [CanBeNullAttribute]
public abstract virtual InternetBrowserInfo GetDefaultInternetBrowserInfo();
    [NotNullAttribute]
public abstract virtual Tuple`2<ProcessInfo, MetroInfo> GetBrowserInfos(string browser, string url);
    [NotNullAttribute]
public abstract virtual IProcessProxy GetBrowserProcess(Lifetime lifetime, string browser, Uri url, UpdateEnvironmentProperty[] environmentProperties, String& browserProcessName);
}
public class JetBrains.Profiler.Windows.SysTools.Tools.Browser.BrowserInfoProviderLinux : BrowserInfoProviderBase {
    public BrowserInfoProviderLinux(SysTools root);
    public virtual IReadOnlyList`1<InternetBrowserInfo> GetInternetBrowserInfos();
    public virtual InternetBrowserInfo GetDefaultInternetBrowserInfo();
    public virtual Tuple`2<ProcessInfo, MetroInfo> GetBrowserInfos(string browser, string url);
    public virtual IProcessProxy GetBrowserProcess(Lifetime lifetime, string browser, Uri url, UpdateEnvironmentProperty[] environmentProperties, String& browserProcessName);
    [IteratorStateMachineAttribute("JetBrains.Profiler.Windows.SysTools.Tools.Browser.BrowserInfoProviderLinux/<GetBrowsers>d__6")]
private static IEnumerable`1<BrowserInfo> GetBrowsers();
    [IteratorStateMachineAttribute("JetBrains.Profiler.Windows.SysTools.Tools.Browser.BrowserInfoProviderLinux/<<GetBrowsers>g__RetrieveNonEmptyLines|6_0>d")]
[CompilerGeneratedAttribute]
internal static IEnumerable`1<string> <GetBrowsers>g__RetrieveNonEmptyLines|6_0(CommandResult result);
}
public class JetBrains.Profiler.Windows.SysTools.Tools.Browser.BrowserInfoProviderMacOs : BrowserInfoProviderBase {
    public BrowserInfoProviderMacOs(SysTools root);
    public virtual IReadOnlyList`1<InternetBrowserInfo> GetInternetBrowserInfos();
    public virtual InternetBrowserInfo GetDefaultInternetBrowserInfo();
    public virtual Tuple`2<ProcessInfo, MetroInfo> GetBrowserInfos(string browser, string url);
    public virtual IProcessProxy GetBrowserProcess(Lifetime lifetime, string browser, Uri url, UpdateEnvironmentProperty[] environmentProperties, String& browserProcessName);
    private static IReadOnlyList`1<BrowserInfo> GetBrowsers();
}
public class JetBrains.Profiler.Windows.SysTools.Tools.Browser.BrowserInfoProviderWindows : BrowserInfoProviderBase {
    private static ILogger ourLogger;
    private static RegistryKey[] ourLookupSequence;
    public BrowserInfoProviderWindows(SysTools root);
    private static BrowserInfoProviderWindows();
    public virtual IReadOnlyList`1<InternetBrowserInfo> GetInternetBrowserInfos();
    public virtual InternetBrowserInfo GetDefaultInternetBrowserInfo();
    public virtual IProcessProxy GetBrowserProcess(Lifetime lifetime, string browser, Uri url, UpdateEnvironmentProperty[] environmentProperties, String& browserProcessName);
    public virtual Tuple`2<ProcessInfo, MetroInfo> GetBrowserInfos(string browser, string url);
    [CanBeNullAttribute]
private string GetCommandLine(RegistryHiveAccess access, string progId);
    [CanBeNullAttribute]
private string GetHttpDefaultProgId(KeyAccessRights rights);
    [NotNullAttribute]
private IEnumerable`1<CapabilityBrowserInfo> GetBrowserInfos(KeyAccessRights rights);
    private static InternetBrowserFlags GetFlags(CapabilityBrowserInfo info);
    [NotNullAttribute]
private CapabilityBrowserInfo GetCapabilityBrowserInfo(KeyAccessRights rights, string browser);
    [NotNullAttribute]
private static string GetProgId(KeyAccessRights rights, CapabilityBrowserInfo info, Uri uri);
    [NotNullAttribute]
private static string GetBrowserProcessName(string browser, string processName);
    [CanBeNullAttribute]
private ProcessInfo GetProcessInfo(KeyAccessRights rights, CapabilityBrowserInfo info, string progId, Uri uri);
    [CanBeNullAttribute]
private MetroInfo GetMetroInfo(KeyAccessRights rights, CapabilityBrowserInfo info, string progId, Uri uri);
}
public class JetBrains.Profiler.Windows.SysTools.Tools.BrowserTools : BaseServiceRemotable`1<SysTools> {
    private static ILogger ourLogger;
    private BrowserInfoProviderBase myBrowserInfoProvider;
    public BrowserTools(SysTools root, String[] ids, ServiceCreatorDelegate<SysTools> serviceCreator);
    private static BrowserTools();
    [NotNullAttribute]
[RemotableCallAttribute]
public virtual IEnumerable`1<InternetBrowserInfo> GetInternetBrowserInfos();
    [CanBeNullAttribute]
[RemotableCallAttribute]
public virtual InternetBrowserInfo GetDefaultInternetBrowserInfo();
    [NotNullAttribute]
[NotRemotableAttribute]
public IProcessProxy GetBrowserProcess(Lifetime lifetime, string browser, Uri url, UpdateEnvironmentProperty[] environmentProperties, String& browserProcessName);
    [NotNullAttribute]
[RemotableCallAttribute]
public virtual Tuple`2<ProcessInfo, MetroInfo> GetBrowserInfos(string browser, string url);
    [NotRemotableAttribute]
public void UpdateDisplay(RunBrowserArgument runBrowser);
}
public class JetBrains.Profiler.Windows.SysTools.Tools.CleanupTools : BaseServiceRemotable`1<SysTools> {
    private static string CleanTempFoldersTask;
    private static string CleanRegistryTask;
    private static string CleanTransparentIntegrationTask;
    private static ILogger ourLogger;
    private Dictionary`2<Guid, Queue`1<ProgressData>> myProgressEvents;
    public CleanupTools(SysTools root, String[] ids, ServiceCreatorDelegate<SysTools> serviceCreator);
    private static CleanupTools();
    [NotRemotableAttribute]
private static bool HasTempException(string path);
    [NotRemotableAttribute]
private void CleanupTemp(string path);
    [RemotableCallAttribute]
public virtual Guid BeginCleanup(HostCleanUpFlags hostCleanUpFlags, int timeout);
    [RemotableCallAttribute]
public virtual ProgressData PullCleanupEvent(Guid id);
    [RemotableCallAttribute]
public virtual void EndCleanup(Guid id);
}
public class JetBrains.Profiler.Windows.SysTools.Tools.ClrActivation : object {
    public Guid Core;
    [NotNullAttribute]
public IDictionary`2<JetArchitecture, string> Paths;
    public Nullable`1<JetArchitecture> DefaultArchitecture;
    public ClrActivation(Guid core, Nullable`1<JetArchitecture> defaultArchitecture, IDictionary`2<JetArchitecture, string> paths);
}
public class JetBrains.Profiler.Windows.SysTools.Tools.Common.GlobalNamedAgentLock : WaitHandle {
    public static string GlobalAgentLockPrefix;
    public static string GlobalAgentLockName;
    private Mutex myLock;
    private bool myOwned;
    public GlobalNamedAgentLock(bool acquire, string name);
    protected virtual void Dispose(bool explicitDisposing);
    public virtual void Close();
    public virtual bool WaitOne(TimeSpan timeout);
    public virtual bool WaitOne(int millisecondsTimeout);
    public virtual bool WaitOne();
    public virtual bool WaitOne(TimeSpan timeout, bool exitContext);
    public virtual bool WaitOne(int millisecondsTimeout, bool exitContext);
}
public static class JetBrains.Profiler.Windows.SysTools.Tools.CoreEnvironmentConstants : object {
    public static string PrefixProfilerCore;
    public static string PrefixProfilerCoreChain;
    public static string PrefixProfilerCoreType;
    public static string ProfilerCoreLogMask;
    public static string ProfilerCoreLogFile;
    public static string ProfilerCoreTempPath;
    public static string ProfilerCoreDebug;
    public static string ProfilerCoreFirst;
    public static string ProfilerCoreHost;
    public static string ProfilerCoreHostPipe;
    public static string ProfilerCoreRemote;
    public static string ProfilerCoreGuid;
    public static string ProfilerCorePath32;
    public static string ProfilerCorePath64;
    public static string ProfilerCorePathArm32;
    public static string ProfilerCorePathArm64;
    public static string ProfilerCoreChainGuid;
    public static string ProfilerCoreChainPath32;
    public static string ProfilerCoreChainPath64;
    public static string ProfilerCoreChainPathArm32;
    public static string ProfilerCoreChainPathArm64;
    public static string ProfilerCoreNativeProfParams;
}
[ExtensionAttribute]
public static class JetBrains.Profiler.Windows.SysTools.Tools.EnvironmentPropertiesExtensions : object {
    private static string ourPathListSeparator;
    private static EnvironmentPropertiesExtensions();
    [ExtensionAttribute]
[NotNullAttribute]
public static CleanEnvironmentProperty[] ResolveStartWith(IEnumerable`1<CleanEnvironmentProperty> cleanProperties, Func`1<IEnumerable`1<string>> getterNames);
    [ExtensionAttribute]
public static void ApplyTo(CleanEnvironmentProperty cleanProperties, Func`1<string> getterStr, Action`1<string> setterStr, Func`2<string, string> expander);
    [ExtensionAttribute]
public static void ApplyTo(CleanEnvironmentProperty cleanProperties, Func`1<string> getterStr, Action`1<string> setterStr, Action`1<string> setterExpandStr, Func`2<string, string> expander);
    private static void UpdateAppendToPathList(UpdateEnvironmentProperty updateProperties, Func`1<string> getterExpandStr, Action`1<string> setterExpandStr);
    [ExtensionAttribute]
public static void ApplyTo(UpdateEnvironmentProperty updateProperty, RegistryModes modes, Func`1<string> getterStr, Action`1<string> setterStr, Action`1<string> setterExpandStr, Action`1<UInt32> setterU4, Action`1<ulong> setterU8, Action`1<Byte[]> setterBinary);
    [ExtensionAttribute]
public static void ApplyTo(UpdateEnvironmentProperty updateProperty, Func`1<string> getterStr, Action`1<string> setterStr);
    [ExtensionAttribute]
public static void ApplyToEnvironment(StringDictionary dictionary, IEnumerable`1<UpdateEnvironmentProperty> updateProperties);
    [ExtensionAttribute]
public static void ApplyToEnvironment(IDictionary`2<string, string> dictionary, IEnumerable`1<UpdateEnvironmentProperty> updateProperties);
    [ExtensionAttribute]
[NotNullAttribute]
public static CleanEnvironmentProperty[] ToCleanEnvironmentProperties(IEnumerable`1<UpdateEnvironmentProperty> updateProperties, JetPlatform platform);
}
public class JetBrains.Profiler.Windows.SysTools.Tools.EnvironmentTools : BaseServiceRemotable`1<SysTools> {
    private static ILogger ourLogger;
    private static String[] ourHiveSeNames;
    public EnvironmentTools(SysTools root, String[] ids, ServiceCreatorDelegate<SysTools> serviceCreator);
    private static EnvironmentTools();
    [RemotableCallAttribute]
public virtual void RegisterCore(JetArchitecture architecture, Guid coreGuid, string coreFile);
    [RemotableCallAttribute]
public virtual void UnregisterCore(JetArchitecture architecture, Guid coreGuid);
    private void CheckRegisterCore(JetArchitecture architecture);
    [NotNullAttribute]
[RemotableCallAttribute]
public virtual IEnumerable`1<string> GetUserTempDirs();
    [NotNullAttribute]
[RemotableCallAttribute]
public virtual IDictionary`2<string, string> GetEnvironmentVariables();
    [NotNullAttribute]
[RemotableCallAttribute]
public virtual string GetSymbolPaths();
}
public class JetBrains.Profiler.Windows.SysTools.Tools.EtwActivation : object {
    public FileSystemPath CollectorPath;
    public string CollectorProductName;
    public string CollectorProductDescription;
    public string BridgeEndpoint;
    public bool IsStarted;
    public EtwActivation(FileSystemPath collectorPath, string collectorProductName, string collectorProductDescription, string bridgeEndpoint, bool isStarted);
}
public class JetBrains.Profiler.Windows.SysTools.Tools.EtwTools : BaseServiceRemotable`1<SysTools> {
    private static ILogger ourLogger;
    private LifetimeDefinition myLifetimeDefinition;
    private Exception myException;
    private ProcessElevatorApi myProcessElevator;
    private object myProcessElevatorLock;
    public EtwTools(SysTools root, String[] ids, ServiceCreatorDelegate<SysTools> serviceCreator);
    private static EtwTools();
    [RemotableLongCallAttribute]
public virtual bool IsSupported();
    [RemotableLongCallAttribute]
public virtual void PrepareToStart(bool runHostAllowed, HostLaunchMode collectorHostMode, HostDeleteOptions hostDeleteOptions, FileSystemPath collectorHostPath, FileSystemPath hostLogDir);
    [RemotableLongCallAttribute]
public virtual string Start(FileSystemPath collectorPath, string collectorProductName, string collectorProductDescription, List`1<ICollectorParam> paramsList);
    [RemotableLongCallAttribute]
public virtual void Term();
    [RemotableLongCallAttribute]
public virtual Dictionary`2<DiagnosticFileSource, FileSystemPath> GetLogDirectories(Dictionary`2<DiagnosticFileSource, FileSystemPath> logDirs);
    private void CheckErrors();
    [CompilerGeneratedAttribute]
private void <PrepareToStart>b__8_0();
    [CompilerGeneratedAttribute]
private void <PrepareToStart>b__8_1(string m, UInt32 c);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.Profiler.Windows.SysTools.Tools.EventPipeActivation : object {
    [CompilerGeneratedAttribute]
private Guid <EventPipeParamId>k__BackingField;
    [CompilerGeneratedAttribute]
private Type EqualityContract { get; }
    public Guid EventPipeParamId { get; public set; }
    public EventPipeActivation(Guid EventPipeParamId);
    [CompilerGeneratedAttribute]
private EventPipeActivation(EventPipeActivation original);
    [CompilerGeneratedAttribute]
private Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public Guid get_EventPipeParamId();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_EventPipeParamId(Guid value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(EventPipeActivation left, EventPipeActivation right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(EventPipeActivation left, EventPipeActivation right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(EventPipeActivation other);
    [CompilerGeneratedAttribute]
public EventPipeActivation <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(Guid& EventPipeParamId);
}
[ExtensionAttribute]
internal static class JetBrains.Profiler.Windows.SysTools.Tools.Impl.PropertiesUtil : object {
    [ExtensionAttribute]
public static bool Clean(IEnumerable`1<CleanEnvironmentProperty> cleanProperties, IDictionary`2<string, string> dictionary, Func`3<EnvironmentPropertyType, string, string> filter);
    [ExtensionAttribute]
public static bool Update(IEnumerable`1<UpdateEnvironmentProperty> updateProperties, IDictionary`2<string, string> dictionary, Func`3<EnvironmentPropertyType, string, string> filter);
    [ExtensionAttribute]
public static void Clean(IEnumerable`1<CleanEnvironmentProperty> cleanProperties, RegistryHiveAccess key, BackSlashSeparatedRelativePath subKey, Func`3<EnvironmentPropertyType, string, string> filter);
    [ExtensionAttribute]
public static void Update(IEnumerable`1<UpdateEnvironmentProperty> updateProperties, RegistryHiveAccess key, BackSlashSeparatedRelativePath subKey, RegistryModes modes, Func`3<EnvironmentPropertyType, string, string> filter);
}
public class JetBrains.Profiler.Windows.SysTools.Tools.IntegrationCoreInfo : object {
    public Guid Core;
    [NotNullAttribute]
public IDictionary`2<JetArchitecture, string> Paths;
    public IntegrationCoreInfo(Guid core, IDictionary`2<JetArchitecture, string> paths);
}
public class JetBrains.Profiler.Windows.SysTools.Tools.InvalidCallSequenceException : Exception {
    public InvalidCallSequenceException(string message);
    public InvalidCallSequenceException(string message, Exception innerException);
    protected InvalidCallSequenceException(SerializationInfo info, StreamingContext context);
}
public class JetBrains.Profiler.Windows.SysTools.Tools.MonoActivation : object {
    [NotNullAttribute]
public IDictionary`2<JetArchitecture, string> Paths;
    public MonoActivation(IDictionary`2<JetArchitecture, string> paths);
}
public enum JetBrains.Profiler.Windows.SysTools.Tools.Protect.CoreProtectionType : Enum {
    public byte value__;
    public static CoreProtectionType Shared;
    public static CoreProtectionType Exclusive;
}
internal class JetBrains.Profiler.Windows.SysTools.Tools.Protect.CoreProtector : object {
    private static int SharedType;
    private static int ExclusiveType;
    private CoreProtectionType myCoreProtectionType;
    private ISemaphoreProxy myDataSemaphore;
    private ISemaphoreProxy myLockSemaphore;
    private ISemaphoreProxy myTypeSemaphore;
    private int myOwnValue;
    public CoreProtector(CoreProtectionType coreProtectionType, Func`4<int, int, string, ISemaphoreProxy> createSemaphore);
    public sealed virtual void Dispose();
    public sealed virtual void Enter(Action`1<bool> action);
    public sealed virtual void Leave(Action`1<bool> action);
    public sealed virtual void Touch();
    private void Lock(Action action);
    private bool IsSingle();
    private static int GetDataMaxValue(CoreProtectionType coreProtectionType);
    private static int GetTypeValue(CoreProtectionType coreProtectionType);
    private CoreProtectionType GetCurrentCoreProtectorType();
    [CompilerGeneratedAttribute]
private void <.ctor>b__7_0();
}
public class JetBrains.Profiler.Windows.SysTools.Tools.Protect.GlobalProtection : object {
    private static int TimeoutAbort;
    private static int TimeoutSleep;
    private object myCoreProtectorLock;
    private Func`4<int, int, string, ISemaphoreProxy> myCreateSemaphore;
    private string myPrefix;
    private Thread myThread;
    private ICoreProtector myCoreProtector;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) myStopRequest;
    public GlobalProtection(string prefix, Func`4<int, int, string, ISemaphoreProxy> createSemaphore);
    public sealed virtual void Dispose();
    public void Enter(Action action);
    public void Leave(Action action);
    [CompilerGeneratedAttribute]
private void <.ctor>b__8_0();
    [CompilerGeneratedAttribute]
private void <.ctor>b__8_1();
}
internal interface JetBrains.Profiler.Windows.SysTools.Tools.Protect.ICoreProtector {
    public abstract virtual void Enter(Action`1<bool> action);
    public abstract virtual void Leave(Action`1<bool> action);
    public abstract virtual void Touch();
}
public class JetBrains.Profiler.Windows.SysTools.Tools.RegistryHiveTools : BaseServiceRemotable`1<SysTools> {
    private static ILogger ourLogger;
    private Random myRandom;
    public RegistryHiveTools(SysTools root, String[] ids, ServiceCreatorDelegate<SysTools> serviceCreator);
    private static RegistryHiveTools();
    [NotRemotableTargetOnlyAttribute]
internal void EnumUserHives(Action`2<string, FileSystemPath> action);
    [NotRemotableTargetOnlyAttribute]
internal void UnderUserHive(string sid, FileSystemPath hiveFile, Action`3<RegistryHiveAccess, BackSlashSeparatedRelativePath, bool> action);
}
[FlagsAttribute]
public enum JetBrains.Profiler.Windows.SysTools.Tools.RegistryModes : Enum {
    public byte value__;
    public static RegistryModes None;
    public static RegistryModes DwordToString;
    public static RegistryModes QwordToString;
    public static RegistryModes BinaryToString;
    public static RegistryModes AllToString;
}
public class JetBrains.Profiler.Windows.SysTools.Tools.TransparentIntegrationTools : BaseServiceRemotable`1<SysTools> {
    private static string RegistryPathInProcServer32;
    private static ILogger ourLogger;
    private static string RegistryKeyAttachCoverageProfiler;
    private static string RegistryKeyAttachSamplingPerformanceProfiler;
    private static string RegistryKeyAttachMemoryProfiler;
    private static string RegistryKeyAttachTimelineProfiler;
    private static string RegistryKeyStartCoverageProfiler;
    private static string RegistryKeyStartSamplingPerformanceProfiler;
    private static string RegistryKeyStartTracingPerformanceProfiler;
    private static string RegistryKeyStartTracingInjectPerformanceProfiler;
    private static string RegistryKeyStartMemoryProfiler;
    private static string RegistryKeyStartTimelineProfiler;
    private static string PostfixRegistryFreeActivation;
    private static string PostfixBasePath;
    private static string PostfixPath32;
    private static string PostfixPath64;
    private static string PostfixPathArm32;
    private static string PostfixPathArm64;
    public TransparentIntegrationTools(SysTools root, String[] ids, ServiceCreatorDelegate<SysTools> serviceCreator);
    private static TransparentIntegrationTools();
    [NotNullAttribute]
private IEnumerable`1<FileSystemPath> GetUserConfigFiles();
    [NotNullAttribute]
[NotRemotableAttribute]
public static string GetTransparentIntegrationName(IArgumentFactory argumentFactory, IInfo info);
    [NotNullAttribute]
[NotRemotableAttribute]
public static IReadOnlyCollection`1<string> GetTransparentIntegrationKeys();
    [CanBeNullAttribute]
[RemotableCallAttribute]
public virtual IntegrationCoreInfo MakeIntegrationCoreInfo(string integrationName, bool skipRegistryOnWindows);
    [NotNullAttribute]
private static IDictionary`2<string, string> ReadConfig(FileSystemPath configFile);
    private static void WriteConfig(FileSystemPath file, IEnumerable`1<KeyValuePair`2<string, string>> props);
    [NotNullAttribute]
private static string GetPostfixPath(JetArchitecture architecture);
    private static void CleanIntegration(RegistryHiveAccess key);
    private static void CleanIntegration(FileSystemPath configFile);
    [RemotableCallAttribute]
public virtual void CleanUserIntegration();
    [RemotableCallAttribute]
public virtual void CleanGlobalIntegration();
    private static void SetIntegration(string transparentIntegrationName, Guid integrationGuid, bool registryFreeActivation, IDictionary`2<JetArchitecture, string> integrationPaths, RegistryHiveAccess key);
    private static void SetIntegration(string transparentIntegrationName, Guid integrationGuid, bool registryFreeActivation, IDictionary`2<JetArchitecture, string> integrationPaths, FileSystemPath configFile);
    [RemotableCallAttribute]
public virtual void SetUserIntegration(string transparentIntegrationName, Guid integrationGuid, bool registryFreeActivation, IDictionary`2<JetArchitecture, string> integrationPaths);
    [RemotableCallAttribute]
public virtual void SetGlobalIntegration(string transparentIntegrationName, Guid integrationGuid, bool registryFreeActivation, IDictionary`2<JetArchitecture, string> integrationPaths);
}
[ExtensionAttribute]
public static class JetBrains.Profiler.Windows.SysTools.Tools.VariableUtil : object {
    private static RelativePath ourLinuxGlibcArm64NativeDir;
    private static RelativePath ourLinuxGlibcX64NativeDir;
    private static RelativePath ourLinuxMuslArm64NativeDir;
    private static RelativePath ourLinuxMuslX64NativeDir;
    private static RelativePath ourMacOsArm64NativeDir;
    private static RelativePath ourMacOsX64NativeDir;
    private static RelativePath ourWindowsX64NativeDir;
    private static RelativePath ourWindowsX86NativeDir;
    private static string EnvPostfixEnableProfiling;
    private static string EnvPostfixProfiler;
    private static string EnvPostfixProfilerPath;
    private static string EnvBitness32;
    private static string EnvBitness64;
    private static string EnvArm32;
    private static string EnvArm64;
    private static string EnvCor;
    private static string EnvCorEnableProfiling;
    private static string EnvCorProfiler;
    private static string EnvCorProfilerPath;
    private static string EnvCorProfilerPath32;
    private static string EnvCorProfilerPath64;
    private static string EnvCoreClr;
    private static string EnvDotnet;
    private static string EnvCoreClrEnableProfiling;
    private static string EnvCoreClrProfiler;
    private static string EnvCoreClrProfilerPath;
    private static string EnvCoreClrProfilerPath32;
    private static string EnvCoreClrProfilerPath64;
    private static string EnvCoreClrProfilerPathArm32;
    private static string EnvCoreClrProfilerPathArm64;
    private static string EnvDiagnosticPorts;
    private static string EnvMono;
    private static string EnvMonoEnvOptions;
    private static string EnvJetBrainsMonoEnvOptions;
    private static string EnvMonoConfig;
    private static string EnvMonoCfgDir;
    private static string EnvMonoDebug;
    private static string EnvMonoGacPrefix;
    private static string EnvMonoGcParams;
    private static string EnvMonoLocalMachineCerts;
    private static string EnvMonoPath;
    private static string EnvJetBrainsDpaAgentEnable;
    private static VariableUtil();
    [ExtensionAttribute]
[NotNullAttribute]
private static IEnumerable`1<FileSystemPath> ToNotEmptyPaths(IDictionary`2<JetArchitecture, string> dictionary);
    [ExtensionAttribute]
[NotNullAttribute]
private static IEnumerable`1<FileSystemPath> ToNotEmptyDirs(IDictionary`2<JetArchitecture, string> dictionary);
    [ExtensionAttribute]
[CanBeNullAttribute]
private static string GetPath(ClrActivation clrActivation, Nullable`1<JetArchitecture> architecture, bool useDefaultArchitecture);
    [ExtensionAttribute]
[CanBeNullAttribute]
private static Nullable`1<Guid> GetCore(ClrActivation clrActivation);
    [NotNullAttribute]
public static CleanEnvironmentProperty[] CleanProfileEnvironment(JetPlatform platform);
    [NotNullAttribute]
public static CleanEnvironmentProperty[] CleanProfileEnvironmentChildProcess();
    [NotNullAttribute]
public static UpdateEnvironmentProperty[] MakeProfileEnvironment(JetPlatform platform, IReadOnlyCollection`1<JetArchitecture> architectures, string profilerName, ClrEngine clrEngine, bool disableEnvironmentActivation, ClrActivation clrActivation, ClrActivation integrationClrActivation, MonoActivation monoActivation, IDictionary`2<string, string> additionalEnvironmentVariables, string diagnosticPortPath, bool isUnityMono, bool isMonoCoverage, bool isDpaAgentEnable, CollectorMode etwCollectorMode, string etwCollectorParams, string hostEndPoint, string hostEndPointForNamedPipe, string remoteEndPoint, Nullable`1<CoreLogMask> logMask, string tempPath, CoreDebug coreDebug, ChainCoreInfo chainProfiler);
    [NotNullAttribute]
private static ClrEnvironmentVariables BindPaths(JetPlatform platform, IEnumerable`1<JetArchitecture> architectures);
    private static void ValidateEnvironmentVariableName(string name);
    [NotNullAttribute]
private static string GetLibPath(JetPlatform platform);
    [NotNullAttribute]
private static String[] GetDefaultWildcardableInstallationPathList(JetPlatform platform);
    [CompilerGeneratedAttribute]
internal static void <BindPaths>g__Assign|8_0(Nullable`1& architecture, JetArchitecture value);
}
public class JetBrains.Profiler.Windows.SysTools.UpdateEnvironmentProperty : object {
    [NotNullAttribute]
public string Key;
    [CanBeNullAttribute]
private object myValue;
    public EnvironmentPropertyType Type;
    public Actions Action { get; }
    public RegValueType RegValueType { get; }
    [NotNullAttribute]
public string StringValue { get; }
    [NotNullAttribute]
public String[] StringListValue { get; }
    public UInt32 DWordValue { get; }
    public ulong QWordValue { get; }
    public Byte[] BinaryValue { get; }
    private UpdateEnvironmentProperty(EnvironmentPropertyType type, string key, object value);
    public Actions get_Action();
    public RegValueType get_RegValueType();
    public string get_StringValue();
    public String[] get_StringListValue();
    public UInt32 get_DWordValue();
    public ulong get_QWordValue();
    public Byte[] get_BinaryValue();
    public bool IsMatch(string key);
    [NotNullAttribute]
public static UpdateEnvironmentProperty CreateStr(EnvironmentPropertyType type, string key, string value);
    [NotNullAttribute]
public static UpdateEnvironmentProperty CreateAppendToPathList(EnvironmentPropertyType type, string key, String[] value);
    [NotNullAttribute]
public static UpdateEnvironmentProperty CreateU4(EnvironmentPropertyType type, string key, Nullable`1<UInt32> value);
    [NotNullAttribute]
public static UpdateEnvironmentProperty CreateU8(EnvironmentPropertyType type, string key, Nullable`1<ulong> value);
    [NotNullAttribute]
public static UpdateEnvironmentProperty CreateGuid(EnvironmentPropertyType type, string key, Nullable`1<Guid> value);
    public virtual string ToString();
}
public class JetBrains.Profiler.Windows.SysTools.WcfHostTools : BaseServiceRemotable`1<SysTools> {
    private static string WcfSvcHostPrefix;
    private static Version2 ourRuntimeVersion2;
    private static Version2 ourRuntimeVersion4;
    private static Version2 ourVsVersion10;
    public WcfHostTools(SysTools root, String[] ids, ServiceCreatorDelegate<SysTools> serviceCreator);
    private static WcfHostTools();
    [NotNullAttribute]
[RemotableLongCallAttribute]
public virtual IEnumerable`1<WcfHostInfo> GetWcfHosts();
    [NotNullAttribute]
private static Version2 GetRuntimeVersion(InstalledVs installedVs);
}
public class JetBrains.Profiler.Windows.SysTools.WindowsServiceEnvironmentTools : BaseServiceRemotable`1<SysTools> {
    private static ILogger ourLogger;
    private static string RegistryKeyEnvironment;
    public WindowsServiceEnvironmentTools(SysTools root, String[] ids, ServiceCreatorDelegate<SysTools> serviceCreator);
    private static WindowsServiceEnvironmentTools();
    [RemotableCallAttribute]
public virtual void CleanAllWindowsServicesEnvironment(CleanEnvironmentProperty[] cleanProperties);
    [RemotableCallAttribute]
public virtual void CleanWindowsServiceEnvironment(string serviceName, CleanEnvironmentProperty[] cleanProperties);
    [RemotableCallAttribute]
public virtual void UpdateWindowsServiceEnvironment(string serviceName, UpdateEnvironmentProperty[] updateProperties);
    private static void ProcessMultilineEnvironment(RegistryHiveAccess key, BackSlashSeparatedRelativePath subKey, string name, Func`2<IDictionary`2<string, string>, bool> updateDictionary);
    private static void CleanAll(CleanEnvironmentProperty[] cleanProperties);
    private static void Clean(string serviceName, CleanEnvironmentProperty[] cleanProperties);
    private static void Update(string serviceName, UpdateEnvironmentProperty[] updateProperties);
}
public class JetBrains.Profiler.Windows.SysTools.WindowsServiceTools : BaseServiceRemotable`1<SysTools> {
    private static int TimeoutExpired;
    private static ILogger ourLogger;
    private static MessageResult ourMessageResult_InvalidOs;
    private static MessageResult ourMessageResult_AdministrativeRightRequired;
    private static MessageResult ourMessageResult_Communication;
    private WatchedDictionary`1<ServiceController> myServices;
    public WindowsServiceTools(SysTools root, String[] ids, ServiceCreatorDelegate<SysTools> serviceCreator);
    private static WindowsServiceTools();
    protected virtual void OnDispose();
    [NotRemotableAttribute]
[NotNullAttribute]
public MessageResult IsSupported(HostCompatibilityOptions options);
    [NotRemotableAttribute]
public void UpdateDisplay(WindowsServiceArgument argument);
    [RemotableCallAttribute]
[NotNullAttribute]
public virtual WindowsServiceInfo[] GetServices();
    [NotRemotableAttribute]
[CanBeNullAttribute]
internal IProcessProxy GetServiceProcess(Lifetime lifetime, Guid id);
    private static bool CheckServiceExist(ServiceController sc);
    [NotRemotableAttribute]
[CanBeNullAttribute]
public IServiceProxy TryOpenService(Lifetime lifetime, string name);
    [NotRemotableAttribute]
[NotNullAttribute]
public IServiceProxy OpenService(Lifetime lifetime, string name);
    [NotRemotableAttribute]
public bool HasService(string name);
    [RemotableCallAttribute]
public virtual Guid Service_Open(string name);
    [RemotableCallAttribute]
public virtual bool Service_Has(string name);
    [RemotableCallAttribute]
public virtual ServiceControllerStatus Service_GetStatus(Guid id);
    [RemotableCallAttribute]
public virtual ServiceStartMode Service_GetStartType(Guid id);
    [RemotableCallAttribute]
public virtual ServiceType Service_GetServiceType(Guid id);
    [RemotableCallAttribute]
[NotNullAttribute]
public virtual string Service_GetServiceName(Guid id);
    [RemotableCallAttribute]
[NotNullAttribute]
public virtual string Service_GetDisplayName(Guid id);
    [RemotableCallAttribute]
public virtual bool Service_CanStop(Guid id);
    [RemotableCallAttribute]
public virtual bool Service_CanPauseAndContinue(Guid id);
    [RemotableCallAttribute]
public virtual bool Service_CanShutdown(Guid id);
    [RemotableCallAttribute]
[NotNullAttribute]
public virtual String[] Service_GetServicesDependentOn(Guid id);
    [RemotableCallAttribute]
[NotNullAttribute]
public virtual String[] Service_GetDependentServices(Guid id);
    [RemotableCallAttribute]
[NotNullAttribute]
public virtual String[] Service_GetSameProcessServices(Guid id);
    [RemotableCallAttribute]
[NotNullAttribute]
public virtual String[] Service_GetSameImagePathServices(Guid id);
    [RemotableCallAttribute]
[CanBeNullAttribute]
public virtual string Service_GetSvcHostGroup(Guid id);
    [RemotableCallAttribute]
[NotNullAttribute]
public virtual String[] Service_GetSvcHostServices(Guid id);
    [RemotableCallAttribute]
[CanBeNullAttribute]
public virtual RemotableProcessInfo Service_GetProcessInfo(Guid id);
    [RemotableLongCallAttribute]
public virtual void Service_Start(Guid id, String[] args);
    [RemotableCallAttribute]
public virtual void Service_Stop(Guid id);
    [RemotableCallAttribute]
public virtual void Service_Pause(Guid id);
    [RemotableCallAttribute]
public virtual void Service_Continue(Guid id);
    [RemotableCallAttribute]
public virtual void Service_Touch(Guid id);
    [RemotableCallAttribute]
public virtual void Service_Close(Guid id);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
public class ProcMonRpc.AttachToProcessRequest : ValueType {
    private Table __p;
    public ByteBuffer ByteBuffer { get; }
    public int Pid { get; }
    public int GuidLength { get; }
    public string Dll { get; }
    public UInt32 Timeout { get; }
    public byte Type { get; }
    public string Version { get; }
    public sealed virtual ByteBuffer get_ByteBuffer();
    public static void ValidateVersion();
    public static AttachToProcessRequest GetRootAsAttachToProcessRequest(ByteBuffer _bb);
    public static AttachToProcessRequest GetRootAsAttachToProcessRequest(ByteBuffer _bb, AttachToProcessRequest obj);
    public static bool VerifyAttachToProcessRequest(ByteBuffer _bb);
    public sealed virtual void __init(int _i, ByteBuffer _bb);
    public AttachToProcessRequest __assign(int _i, ByteBuffer _bb);
    public int get_Pid();
    public byte Guid(int j);
    public int get_GuidLength();
    public Nullable`1<ArraySegment`1<byte>> GetGuidBytes();
    public Byte[] GetGuidArray();
    public string get_Dll();
    public Nullable`1<ArraySegment`1<byte>> GetDllBytes();
    public Byte[] GetDllArray();
    public UInt32 get_Timeout();
    public byte get_Type();
    public string get_Version();
    public Nullable`1<ArraySegment`1<byte>> GetVersionBytes();
    public Byte[] GetVersionArray();
    public static Offset`1<AttachToProcessRequest> CreateAttachToProcessRequest(FlatBufferBuilder builder, int pid, VectorOffset guidOffset, StringOffset dllOffset, UInt32 timeout, byte type, StringOffset versionOffset);
    public static void StartAttachToProcessRequest(FlatBufferBuilder builder);
    public static void AddPid(FlatBufferBuilder builder, int pid);
    public static void AddGuid(FlatBufferBuilder builder, VectorOffset guidOffset);
    public static VectorOffset CreateGuidVector(FlatBufferBuilder builder, Byte[] data);
    public static VectorOffset CreateGuidVectorBlock(FlatBufferBuilder builder, Byte[] data);
    public static VectorOffset CreateGuidVectorBlock(FlatBufferBuilder builder, ArraySegment`1<byte> data);
    public static VectorOffset CreateGuidVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes);
    public static void StartGuidVector(FlatBufferBuilder builder, int numElems);
    public static void AddDll(FlatBufferBuilder builder, StringOffset dllOffset);
    public static void AddTimeout(FlatBufferBuilder builder, UInt32 timeout);
    public static void AddType(FlatBufferBuilder builder, byte type);
    public static void AddVersion(FlatBufferBuilder builder, StringOffset versionOffset);
    public static Offset`1<AttachToProcessRequest> EndAttachToProcessRequest(FlatBufferBuilder builder);
    public static void FinishAttachToProcessRequestBuffer(FlatBufferBuilder builder, Offset`1<AttachToProcessRequest> offset);
    public static void FinishSizePrefixedAttachToProcessRequestBuffer(FlatBufferBuilder builder, Offset`1<AttachToProcessRequest> offset);
}
public static class ProcMonRpc.AttachToProcessRequestVerify : object {
    public static bool Verify(Verifier verifier, UInt32 tablePos);
}
public class ProcMonRpc.AttachToProcessResponse : ValueType {
    private Table __p;
    public ByteBuffer ByteBuffer { get; }
    public Nullable`1<StatusInfo> Status { get; }
    public sealed virtual ByteBuffer get_ByteBuffer();
    public static void ValidateVersion();
    public static AttachToProcessResponse GetRootAsAttachToProcessResponse(ByteBuffer _bb);
    public static AttachToProcessResponse GetRootAsAttachToProcessResponse(ByteBuffer _bb, AttachToProcessResponse obj);
    public static bool VerifyAttachToProcessResponse(ByteBuffer _bb);
    public sealed virtual void __init(int _i, ByteBuffer _bb);
    public AttachToProcessResponse __assign(int _i, ByteBuffer _bb);
    public Nullable`1<StatusInfo> get_Status();
    public static Offset`1<AttachToProcessResponse> CreateAttachToProcessResponse(FlatBufferBuilder builder, Offset`1<StatusInfo> statusOffset);
    public static void StartAttachToProcessResponse(FlatBufferBuilder builder);
    public static void AddStatus(FlatBufferBuilder builder, Offset`1<StatusInfo> statusOffset);
    public static Offset`1<AttachToProcessResponse> EndAttachToProcessResponse(FlatBufferBuilder builder);
    public static void FinishAttachToProcessResponseBuffer(FlatBufferBuilder builder, Offset`1<AttachToProcessResponse> offset);
    public static void FinishSizePrefixedAttachToProcessResponseBuffer(FlatBufferBuilder builder, Offset`1<AttachToProcessResponse> offset);
}
public static class ProcMonRpc.AttachToProcessResponseVerify : object {
    public static bool Verify(Verifier verifier, UInt32 tablePos);
}
public class ProcMonRpc.EnvVar : ValueType {
    private Table __p;
    public ByteBuffer ByteBuffer { get; }
    public string Name { get; }
    public string Value { get; }
    public sealed virtual ByteBuffer get_ByteBuffer();
    public static void ValidateVersion();
    public static EnvVar GetRootAsEnvVar(ByteBuffer _bb);
    public static EnvVar GetRootAsEnvVar(ByteBuffer _bb, EnvVar obj);
    public sealed virtual void __init(int _i, ByteBuffer _bb);
    public EnvVar __assign(int _i, ByteBuffer _bb);
    public string get_Name();
    public Nullable`1<ArraySegment`1<byte>> GetNameBytes();
    public Byte[] GetNameArray();
    public string get_Value();
    public Nullable`1<ArraySegment`1<byte>> GetValueBytes();
    public Byte[] GetValueArray();
    public static Offset`1<EnvVar> CreateEnvVar(FlatBufferBuilder builder, StringOffset nameOffset, StringOffset valueOffset);
    public static void StartEnvVar(FlatBufferBuilder builder);
    public static void AddName(FlatBufferBuilder builder, StringOffset nameOffset);
    public static void AddValue(FlatBufferBuilder builder, StringOffset valueOffset);
    public static Offset`1<EnvVar> EndEnvVar(FlatBufferBuilder builder);
}
public static class ProcMonRpc.EnvVarVerify : object {
    public static bool Verify(Verifier verifier, UInt32 tablePos);
}
public class ProcMonRpc.ListProcessesRequest : ValueType {
    private Table __p;
    public ByteBuffer ByteBuffer { get; }
    public bool AllPids { get; }
    public sealed virtual ByteBuffer get_ByteBuffer();
    public static void ValidateVersion();
    public static ListProcessesRequest GetRootAsListProcessesRequest(ByteBuffer _bb);
    public static ListProcessesRequest GetRootAsListProcessesRequest(ByteBuffer _bb, ListProcessesRequest obj);
    public static bool VerifyListProcessesRequest(ByteBuffer _bb);
    public sealed virtual void __init(int _i, ByteBuffer _bb);
    public ListProcessesRequest __assign(int _i, ByteBuffer _bb);
    public bool get_AllPids();
    public static Offset`1<ListProcessesRequest> CreateListProcessesRequest(FlatBufferBuilder builder, bool all_pids);
    public static void StartListProcessesRequest(FlatBufferBuilder builder);
    public static void AddAllPids(FlatBufferBuilder builder, bool allPids);
    public static Offset`1<ListProcessesRequest> EndListProcessesRequest(FlatBufferBuilder builder);
    public static void FinishListProcessesRequestBuffer(FlatBufferBuilder builder, Offset`1<ListProcessesRequest> offset);
    public static void FinishSizePrefixedListProcessesRequestBuffer(FlatBufferBuilder builder, Offset`1<ListProcessesRequest> offset);
}
public static class ProcMonRpc.ListProcessesRequestVerify : object {
    public static bool Verify(Verifier verifier, UInt32 tablePos);
}
public class ProcMonRpc.ListProcessesResponse : ValueType {
    private Table __p;
    public ByteBuffer ByteBuffer { get; }
    public Nullable`1<StatusInfo> Status { get; }
    public int ProcessMapLength { get; }
    public sealed virtual ByteBuffer get_ByteBuffer();
    public static void ValidateVersion();
    public static ListProcessesResponse GetRootAsListProcessesResponse(ByteBuffer _bb);
    public static ListProcessesResponse GetRootAsListProcessesResponse(ByteBuffer _bb, ListProcessesResponse obj);
    public static bool VerifyListProcessesResponse(ByteBuffer _bb);
    public sealed virtual void __init(int _i, ByteBuffer _bb);
    public ListProcessesResponse __assign(int _i, ByteBuffer _bb);
    public Nullable`1<StatusInfo> get_Status();
    public Nullable`1<ProcessInfo> ProcessMap(int j);
    public int get_ProcessMapLength();
    public static Offset`1<ListProcessesResponse> CreateListProcessesResponse(FlatBufferBuilder builder, Offset`1<StatusInfo> statusOffset, VectorOffset process_mapOffset);
    public static void StartListProcessesResponse(FlatBufferBuilder builder);
    public static void AddStatus(FlatBufferBuilder builder, Offset`1<StatusInfo> statusOffset);
    public static void AddProcessMap(FlatBufferBuilder builder, VectorOffset processMapOffset);
    public static VectorOffset CreateProcessMapVector(FlatBufferBuilder builder, Offset`1[] data);
    public static VectorOffset CreateProcessMapVectorBlock(FlatBufferBuilder builder, Offset`1[] data);
    public static VectorOffset CreateProcessMapVectorBlock(FlatBufferBuilder builder, ArraySegment`1<Offset`1<ProcessInfo>> data);
    public static VectorOffset CreateProcessMapVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes);
    public static void StartProcessMapVector(FlatBufferBuilder builder, int numElems);
    public static Offset`1<ListProcessesResponse> EndListProcessesResponse(FlatBufferBuilder builder);
    public static void FinishListProcessesResponseBuffer(FlatBufferBuilder builder, Offset`1<ListProcessesResponse> offset);
    public static void FinishSizePrefixedListProcessesResponseBuffer(FlatBufferBuilder builder, Offset`1<ListProcessesResponse> offset);
}
public static class ProcMonRpc.ListProcessesResponseVerify : object {
    public static bool Verify(Verifier verifier, UInt32 tablePos);
}
public enum ProcMonRpc.Methods : Enum {
    public byte value__;
    public static Methods ListProcesses;
    public static Methods AttachToProcess;
    public static Methods WinRtCleanAttachProfiling;
    public static Methods WinRtCleanEverythingProfiling;
    public static Methods WinRtCleanStartProfiling;
    public static Methods WinRtGetPackagesForCurrentUser;
    public static Methods WinRtPrepareAttachProfiling;
    public static Methods WinRtPrepareEverythingProfiling;
    public static Methods WinRtPrepareStartProfiling;
    public static Methods WinRtRunProfiling;
}
public class ProcMonRpc.ProcessInfo : ValueType {
    private Table __p;
    public ByteBuffer ByteBuffer { get; }
    public int Pid { get; }
    public Nullable`1<StatusInfo> Status { get; }
    public string Name { get; }
    public string Executable { get; }
    public string CommandLine { get; }
    public string Title { get; }
    public Nullable`1<UserInfo> User { get; }
    public int RuntimesLength { get; }
    public string PackageFullName { get; }
    public UInt32 Flags { get; }
    public ulong StartTimeMs { get; }
    public sealed virtual ByteBuffer get_ByteBuffer();
    public static void ValidateVersion();
    public static ProcessInfo GetRootAsProcessInfo(ByteBuffer _bb);
    public static ProcessInfo GetRootAsProcessInfo(ByteBuffer _bb, ProcessInfo obj);
    public sealed virtual void __init(int _i, ByteBuffer _bb);
    public ProcessInfo __assign(int _i, ByteBuffer _bb);
    public int get_Pid();
    public Nullable`1<StatusInfo> get_Status();
    public string get_Name();
    public Nullable`1<ArraySegment`1<byte>> GetNameBytes();
    public Byte[] GetNameArray();
    public string get_Executable();
    public Nullable`1<ArraySegment`1<byte>> GetExecutableBytes();
    public Byte[] GetExecutableArray();
    public string get_CommandLine();
    public Nullable`1<ArraySegment`1<byte>> GetCommandLineBytes();
    public Byte[] GetCommandLineArray();
    public string get_Title();
    public Nullable`1<ArraySegment`1<byte>> GetTitleBytes();
    public Byte[] GetTitleArray();
    public Nullable`1<UserInfo> get_User();
    public Nullable`1<RuntimeInfo> Runtimes(int j);
    public int get_RuntimesLength();
    public string get_PackageFullName();
    public Nullable`1<ArraySegment`1<byte>> GetPackageFullNameBytes();
    public Byte[] GetPackageFullNameArray();
    public UInt32 get_Flags();
    public ulong get_StartTimeMs();
    public static Offset`1<ProcessInfo> CreateProcessInfo(FlatBufferBuilder builder, int pid, Offset`1<StatusInfo> statusOffset, StringOffset nameOffset, StringOffset executableOffset, StringOffset command_lineOffset, StringOffset titleOffset, Offset`1<UserInfo> userOffset, VectorOffset runtimesOffset, StringOffset package_full_nameOffset, UInt32 flags, ulong start_time_ms);
    public static void StartProcessInfo(FlatBufferBuilder builder);
    public static void AddPid(FlatBufferBuilder builder, int pid);
    public static void AddStatus(FlatBufferBuilder builder, Offset`1<StatusInfo> statusOffset);
    public static void AddName(FlatBufferBuilder builder, StringOffset nameOffset);
    public static void AddExecutable(FlatBufferBuilder builder, StringOffset executableOffset);
    public static void AddCommandLine(FlatBufferBuilder builder, StringOffset commandLineOffset);
    public static void AddTitle(FlatBufferBuilder builder, StringOffset titleOffset);
    public static void AddUser(FlatBufferBuilder builder, Offset`1<UserInfo> userOffset);
    public static void AddRuntimes(FlatBufferBuilder builder, VectorOffset runtimesOffset);
    public static VectorOffset CreateRuntimesVector(FlatBufferBuilder builder, Offset`1[] data);
    public static VectorOffset CreateRuntimesVectorBlock(FlatBufferBuilder builder, Offset`1[] data);
    public static VectorOffset CreateRuntimesVectorBlock(FlatBufferBuilder builder, ArraySegment`1<Offset`1<RuntimeInfo>> data);
    public static VectorOffset CreateRuntimesVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes);
    public static void StartRuntimesVector(FlatBufferBuilder builder, int numElems);
    public static void AddPackageFullName(FlatBufferBuilder builder, StringOffset packageFullNameOffset);
    public static void AddFlags(FlatBufferBuilder builder, UInt32 flags);
    public static void AddStartTimeMs(FlatBufferBuilder builder, ulong startTimeMs);
    public static Offset`1<ProcessInfo> EndProcessInfo(FlatBufferBuilder builder);
}
public static class ProcMonRpc.ProcessInfoVerify : object {
    public static bool Verify(Verifier verifier, UInt32 tablePos);
}
public class ProcMonRpc.RuntimeInfo : ValueType {
    private Table __p;
    public ByteBuffer ByteBuffer { get; }
    public byte Type { get; }
    public string Version { get; }
    public sealed virtual ByteBuffer get_ByteBuffer();
    public static void ValidateVersion();
    public static RuntimeInfo GetRootAsRuntimeInfo(ByteBuffer _bb);
    public static RuntimeInfo GetRootAsRuntimeInfo(ByteBuffer _bb, RuntimeInfo obj);
    public sealed virtual void __init(int _i, ByteBuffer _bb);
    public RuntimeInfo __assign(int _i, ByteBuffer _bb);
    public byte get_Type();
    public string get_Version();
    public Nullable`1<ArraySegment`1<byte>> GetVersionBytes();
    public Byte[] GetVersionArray();
    public static Offset`1<RuntimeInfo> CreateRuntimeInfo(FlatBufferBuilder builder, byte type, StringOffset versionOffset);
    public static void StartRuntimeInfo(FlatBufferBuilder builder);
    public static void AddType(FlatBufferBuilder builder, byte type);
    public static void AddVersion(FlatBufferBuilder builder, StringOffset versionOffset);
    public static Offset`1<RuntimeInfo> EndRuntimeInfo(FlatBufferBuilder builder);
}
public static class ProcMonRpc.RuntimeInfoVerify : object {
    public static bool Verify(Verifier verifier, UInt32 tablePos);
}
public class ProcMonRpc.StatusInfo : ValueType {
    private Table __p;
    public ByteBuffer ByteBuffer { get; }
    public int Hresult { get; }
    public string ErrorMsg { get; }
    public sealed virtual ByteBuffer get_ByteBuffer();
    public static void ValidateVersion();
    public static StatusInfo GetRootAsStatusInfo(ByteBuffer _bb);
    public static StatusInfo GetRootAsStatusInfo(ByteBuffer _bb, StatusInfo obj);
    public sealed virtual void __init(int _i, ByteBuffer _bb);
    public StatusInfo __assign(int _i, ByteBuffer _bb);
    public int get_Hresult();
    public string get_ErrorMsg();
    public Nullable`1<ArraySegment`1<byte>> GetErrorMsgBytes();
    public Byte[] GetErrorMsgArray();
    public static Offset`1<StatusInfo> CreateStatusInfo(FlatBufferBuilder builder, int hresult, StringOffset error_msgOffset);
    public static void StartStatusInfo(FlatBufferBuilder builder);
    public static void AddHresult(FlatBufferBuilder builder, int hresult);
    public static void AddErrorMsg(FlatBufferBuilder builder, StringOffset errorMsgOffset);
    public static Offset`1<StatusInfo> EndStatusInfo(FlatBufferBuilder builder);
}
public static class ProcMonRpc.StatusInfoVerify : object {
    public static bool Verify(Verifier verifier, UInt32 tablePos);
}
public class ProcMonRpc.UserInfo : ValueType {
    private Table __p;
    public ByteBuffer ByteBuffer { get; }
    public string Sid { get; }
    public string UserName { get; }
    public sealed virtual ByteBuffer get_ByteBuffer();
    public static void ValidateVersion();
    public static UserInfo GetRootAsUserInfo(ByteBuffer _bb);
    public static UserInfo GetRootAsUserInfo(ByteBuffer _bb, UserInfo obj);
    public sealed virtual void __init(int _i, ByteBuffer _bb);
    public UserInfo __assign(int _i, ByteBuffer _bb);
    public string get_Sid();
    public Nullable`1<ArraySegment`1<byte>> GetSidBytes();
    public Byte[] GetSidArray();
    public string get_UserName();
    public Nullable`1<ArraySegment`1<byte>> GetUserNameBytes();
    public Byte[] GetUserNameArray();
    public static Offset`1<UserInfo> CreateUserInfo(FlatBufferBuilder builder, StringOffset sidOffset, StringOffset user_nameOffset);
    public static void StartUserInfo(FlatBufferBuilder builder);
    public static void AddSid(FlatBufferBuilder builder, StringOffset sidOffset);
    public static void AddUserName(FlatBufferBuilder builder, StringOffset userNameOffset);
    public static Offset`1<UserInfo> EndUserInfo(FlatBufferBuilder builder);
}
public static class ProcMonRpc.UserInfoVerify : object {
    public static bool Verify(Verifier verifier, UInt32 tablePos);
}
public class ProcMonRpc.Version : ValueType {
    private Table __p;
    public ByteBuffer ByteBuffer { get; }
    public ushort Major { get; }
    public ushort Minor { get; }
    public ushort Build { get; }
    public ushort Revision { get; }
    public sealed virtual ByteBuffer get_ByteBuffer();
    public static void ValidateVersion();
    public static Version GetRootAsVersion(ByteBuffer _bb);
    public static Version GetRootAsVersion(ByteBuffer _bb, Version obj);
    public sealed virtual void __init(int _i, ByteBuffer _bb);
    public Version __assign(int _i, ByteBuffer _bb);
    public ushort get_Major();
    public ushort get_Minor();
    public ushort get_Build();
    public ushort get_Revision();
    public static Offset`1<Version> CreateVersion(FlatBufferBuilder builder, ushort major, ushort minor, ushort build, ushort revision);
    public static void StartVersion(FlatBufferBuilder builder);
    public static void AddMajor(FlatBufferBuilder builder, ushort major);
    public static void AddMinor(FlatBufferBuilder builder, ushort minor);
    public static void AddBuild(FlatBufferBuilder builder, ushort build);
    public static void AddRevision(FlatBufferBuilder builder, ushort revision);
    public static Offset`1<Version> EndVersion(FlatBufferBuilder builder);
}
public static class ProcMonRpc.VersionVerify : object {
    public static bool Verify(Verifier verifier, UInt32 tablePos);
}
public class ProcMonRpc.WinRtApplicationInfo : ValueType {
    private Table __p;
    public ByteBuffer ByteBuffer { get; }
    public string DisplayName { get; }
    public string AppUserModelId { get; }
    public sealed virtual ByteBuffer get_ByteBuffer();
    public static void ValidateVersion();
    public static WinRtApplicationInfo GetRootAsWinRtApplicationInfo(ByteBuffer _bb);
    public static WinRtApplicationInfo GetRootAsWinRtApplicationInfo(ByteBuffer _bb, WinRtApplicationInfo obj);
    public sealed virtual void __init(int _i, ByteBuffer _bb);
    public WinRtApplicationInfo __assign(int _i, ByteBuffer _bb);
    public string get_DisplayName();
    public Nullable`1<ArraySegment`1<byte>> GetDisplayNameBytes();
    public Byte[] GetDisplayNameArray();
    public string get_AppUserModelId();
    public Nullable`1<ArraySegment`1<byte>> GetAppUserModelIdBytes();
    public Byte[] GetAppUserModelIdArray();
    public static Offset`1<WinRtApplicationInfo> CreateWinRtApplicationInfo(FlatBufferBuilder builder, StringOffset display_nameOffset, StringOffset app_user_model_idOffset);
    public static void StartWinRtApplicationInfo(FlatBufferBuilder builder);
    public static void AddDisplayName(FlatBufferBuilder builder, StringOffset displayNameOffset);
    public static void AddAppUserModelId(FlatBufferBuilder builder, StringOffset appUserModelIdOffset);
    public static Offset`1<WinRtApplicationInfo> EndWinRtApplicationInfo(FlatBufferBuilder builder);
}
public static class ProcMonRpc.WinRtApplicationInfoVerify : object {
    public static bool Verify(Verifier verifier, UInt32 tablePos);
}
public class ProcMonRpc.WinRtCleanAttachProfilingRequest : ValueType {
    private Table __p;
    public ByteBuffer ByteBuffer { get; }
    public ulong SessionId { get; }
    public string FullName { get; }
    public sealed virtual ByteBuffer get_ByteBuffer();
    public static void ValidateVersion();
    public static WinRtCleanAttachProfilingRequest GetRootAsWinRtCleanAttachProfilingRequest(ByteBuffer _bb);
    public static WinRtCleanAttachProfilingRequest GetRootAsWinRtCleanAttachProfilingRequest(ByteBuffer _bb, WinRtCleanAttachProfilingRequest obj);
    public static bool VerifyWinRtCleanAttachProfilingRequest(ByteBuffer _bb);
    public sealed virtual void __init(int _i, ByteBuffer _bb);
    public WinRtCleanAttachProfilingRequest __assign(int _i, ByteBuffer _bb);
    public ulong get_SessionId();
    public string get_FullName();
    public Nullable`1<ArraySegment`1<byte>> GetFullNameBytes();
    public Byte[] GetFullNameArray();
    public static Offset`1<WinRtCleanAttachProfilingRequest> CreateWinRtCleanAttachProfilingRequest(FlatBufferBuilder builder, ulong session_id, StringOffset full_nameOffset);
    public static void StartWinRtCleanAttachProfilingRequest(FlatBufferBuilder builder);
    public static void AddSessionId(FlatBufferBuilder builder, ulong sessionId);
    public static void AddFullName(FlatBufferBuilder builder, StringOffset fullNameOffset);
    public static Offset`1<WinRtCleanAttachProfilingRequest> EndWinRtCleanAttachProfilingRequest(FlatBufferBuilder builder);
    public static void FinishWinRtCleanAttachProfilingRequestBuffer(FlatBufferBuilder builder, Offset`1<WinRtCleanAttachProfilingRequest> offset);
    public static void FinishSizePrefixedWinRtCleanAttachProfilingRequestBuffer(FlatBufferBuilder builder, Offset`1<WinRtCleanAttachProfilingRequest> offset);
}
public static class ProcMonRpc.WinRtCleanAttachProfilingRequestVerify : object {
    public static bool Verify(Verifier verifier, UInt32 tablePos);
}
public class ProcMonRpc.WinRtCleanAttachProfilingResponse : ValueType {
    private Table __p;
    public ByteBuffer ByteBuffer { get; }
    public Nullable`1<StatusInfo> Status { get; }
    public sealed virtual ByteBuffer get_ByteBuffer();
    public static void ValidateVersion();
    public static WinRtCleanAttachProfilingResponse GetRootAsWinRtCleanAttachProfilingResponse(ByteBuffer _bb);
    public static WinRtCleanAttachProfilingResponse GetRootAsWinRtCleanAttachProfilingResponse(ByteBuffer _bb, WinRtCleanAttachProfilingResponse obj);
    public static bool VerifyWinRtCleanAttachProfilingResponse(ByteBuffer _bb);
    public sealed virtual void __init(int _i, ByteBuffer _bb);
    public WinRtCleanAttachProfilingResponse __assign(int _i, ByteBuffer _bb);
    public Nullable`1<StatusInfo> get_Status();
    public static Offset`1<WinRtCleanAttachProfilingResponse> CreateWinRtCleanAttachProfilingResponse(FlatBufferBuilder builder, Offset`1<StatusInfo> statusOffset);
    public static void StartWinRtCleanAttachProfilingResponse(FlatBufferBuilder builder);
    public static void AddStatus(FlatBufferBuilder builder, Offset`1<StatusInfo> statusOffset);
    public static Offset`1<WinRtCleanAttachProfilingResponse> EndWinRtCleanAttachProfilingResponse(FlatBufferBuilder builder);
    public static void FinishWinRtCleanAttachProfilingResponseBuffer(FlatBufferBuilder builder, Offset`1<WinRtCleanAttachProfilingResponse> offset);
    public static void FinishSizePrefixedWinRtCleanAttachProfilingResponseBuffer(FlatBufferBuilder builder, Offset`1<WinRtCleanAttachProfilingResponse> offset);
}
public static class ProcMonRpc.WinRtCleanAttachProfilingResponseVerify : object {
    public static bool Verify(Verifier verifier, UInt32 tablePos);
}
public class ProcMonRpc.WinRtCleanEverythingProfilingResponse : ValueType {
    private Table __p;
    public ByteBuffer ByteBuffer { get; }
    public Nullable`1<StatusInfo> Status { get; }
    public sealed virtual ByteBuffer get_ByteBuffer();
    public static void ValidateVersion();
    public static WinRtCleanEverythingProfilingResponse GetRootAsWinRtCleanEverythingProfilingResponse(ByteBuffer _bb);
    public static WinRtCleanEverythingProfilingResponse GetRootAsWinRtCleanEverythingProfilingResponse(ByteBuffer _bb, WinRtCleanEverythingProfilingResponse obj);
    public static bool VerifyWinRtCleanEverythingProfilingResponse(ByteBuffer _bb);
    public sealed virtual void __init(int _i, ByteBuffer _bb);
    public WinRtCleanEverythingProfilingResponse __assign(int _i, ByteBuffer _bb);
    public Nullable`1<StatusInfo> get_Status();
    public static Offset`1<WinRtCleanEverythingProfilingResponse> CreateWinRtCleanEverythingProfilingResponse(FlatBufferBuilder builder, Offset`1<StatusInfo> statusOffset);
    public static void StartWinRtCleanEverythingProfilingResponse(FlatBufferBuilder builder);
    public static void AddStatus(FlatBufferBuilder builder, Offset`1<StatusInfo> statusOffset);
    public static Offset`1<WinRtCleanEverythingProfilingResponse> EndWinRtCleanEverythingProfilingResponse(FlatBufferBuilder builder);
    public static void FinishWinRtCleanEverythingProfilingResponseBuffer(FlatBufferBuilder builder, Offset`1<WinRtCleanEverythingProfilingResponse> offset);
    public static void FinishSizePrefixedWinRtCleanEverythingProfilingResponseBuffer(FlatBufferBuilder builder, Offset`1<WinRtCleanEverythingProfilingResponse> offset);
}
public static class ProcMonRpc.WinRtCleanEverythingProfilingResponseVerify : object {
    public static bool Verify(Verifier verifier, UInt32 tablePos);
}
public class ProcMonRpc.WinRtCleanStartProfilingRequest : ValueType {
    private Table __p;
    public ByteBuffer ByteBuffer { get; }
    public string FullName { get; }
    public sealed virtual ByteBuffer get_ByteBuffer();
    public static void ValidateVersion();
    public static WinRtCleanStartProfilingRequest GetRootAsWinRtCleanStartProfilingRequest(ByteBuffer _bb);
    public static WinRtCleanStartProfilingRequest GetRootAsWinRtCleanStartProfilingRequest(ByteBuffer _bb, WinRtCleanStartProfilingRequest obj);
    public static bool VerifyWinRtCleanStartProfilingRequest(ByteBuffer _bb);
    public sealed virtual void __init(int _i, ByteBuffer _bb);
    public WinRtCleanStartProfilingRequest __assign(int _i, ByteBuffer _bb);
    public string get_FullName();
    public Nullable`1<ArraySegment`1<byte>> GetFullNameBytes();
    public Byte[] GetFullNameArray();
    public static Offset`1<WinRtCleanStartProfilingRequest> CreateWinRtCleanStartProfilingRequest(FlatBufferBuilder builder, StringOffset full_nameOffset);
    public static void StartWinRtCleanStartProfilingRequest(FlatBufferBuilder builder);
    public static void AddFullName(FlatBufferBuilder builder, StringOffset fullNameOffset);
    public static Offset`1<WinRtCleanStartProfilingRequest> EndWinRtCleanStartProfilingRequest(FlatBufferBuilder builder);
    public static void FinishWinRtCleanStartProfilingRequestBuffer(FlatBufferBuilder builder, Offset`1<WinRtCleanStartProfilingRequest> offset);
    public static void FinishSizePrefixedWinRtCleanStartProfilingRequestBuffer(FlatBufferBuilder builder, Offset`1<WinRtCleanStartProfilingRequest> offset);
}
public static class ProcMonRpc.WinRtCleanStartProfilingRequestVerify : object {
    public static bool Verify(Verifier verifier, UInt32 tablePos);
}
public class ProcMonRpc.WinRtCleanStartProfilingResponse : ValueType {
    private Table __p;
    public ByteBuffer ByteBuffer { get; }
    public Nullable`1<StatusInfo> Status { get; }
    public sealed virtual ByteBuffer get_ByteBuffer();
    public static void ValidateVersion();
    public static WinRtCleanStartProfilingResponse GetRootAsWinRtCleanStartProfilingResponse(ByteBuffer _bb);
    public static WinRtCleanStartProfilingResponse GetRootAsWinRtCleanStartProfilingResponse(ByteBuffer _bb, WinRtCleanStartProfilingResponse obj);
    public static bool VerifyWinRtCleanStartProfilingResponse(ByteBuffer _bb);
    public sealed virtual void __init(int _i, ByteBuffer _bb);
    public WinRtCleanStartProfilingResponse __assign(int _i, ByteBuffer _bb);
    public Nullable`1<StatusInfo> get_Status();
    public static Offset`1<WinRtCleanStartProfilingResponse> CreateWinRtCleanStartProfilingResponse(FlatBufferBuilder builder, Offset`1<StatusInfo> statusOffset);
    public static void StartWinRtCleanStartProfilingResponse(FlatBufferBuilder builder);
    public static void AddStatus(FlatBufferBuilder builder, Offset`1<StatusInfo> statusOffset);
    public static Offset`1<WinRtCleanStartProfilingResponse> EndWinRtCleanStartProfilingResponse(FlatBufferBuilder builder);
    public static void FinishWinRtCleanStartProfilingResponseBuffer(FlatBufferBuilder builder, Offset`1<WinRtCleanStartProfilingResponse> offset);
    public static void FinishSizePrefixedWinRtCleanStartProfilingResponseBuffer(FlatBufferBuilder builder, Offset`1<WinRtCleanStartProfilingResponse> offset);
}
public static class ProcMonRpc.WinRtCleanStartProfilingResponseVerify : object {
    public static bool Verify(Verifier verifier, UInt32 tablePos);
}
public class ProcMonRpc.WinRtGetPackagesForCurrentUserResponse : ValueType {
    private Table __p;
    public ByteBuffer ByteBuffer { get; }
    public Nullable`1<StatusInfo> Status { get; }
    public int PackagesLength { get; }
    public sealed virtual ByteBuffer get_ByteBuffer();
    public static void ValidateVersion();
    public static WinRtGetPackagesForCurrentUserResponse GetRootAsWinRtGetPackagesForCurrentUserResponse(ByteBuffer _bb);
    public static WinRtGetPackagesForCurrentUserResponse GetRootAsWinRtGetPackagesForCurrentUserResponse(ByteBuffer _bb, WinRtGetPackagesForCurrentUserResponse obj);
    public static bool VerifyWinRtGetPackagesForCurrentUserResponse(ByteBuffer _bb);
    public sealed virtual void __init(int _i, ByteBuffer _bb);
    public WinRtGetPackagesForCurrentUserResponse __assign(int _i, ByteBuffer _bb);
    public Nullable`1<StatusInfo> get_Status();
    public Nullable`1<WinRtPackageInfo> Packages(int j);
    public int get_PackagesLength();
    public static Offset`1<WinRtGetPackagesForCurrentUserResponse> CreateWinRtGetPackagesForCurrentUserResponse(FlatBufferBuilder builder, Offset`1<StatusInfo> statusOffset, VectorOffset packagesOffset);
    public static void StartWinRtGetPackagesForCurrentUserResponse(FlatBufferBuilder builder);
    public static void AddStatus(FlatBufferBuilder builder, Offset`1<StatusInfo> statusOffset);
    public static void AddPackages(FlatBufferBuilder builder, VectorOffset packagesOffset);
    public static VectorOffset CreatePackagesVector(FlatBufferBuilder builder, Offset`1[] data);
    public static VectorOffset CreatePackagesVectorBlock(FlatBufferBuilder builder, Offset`1[] data);
    public static VectorOffset CreatePackagesVectorBlock(FlatBufferBuilder builder, ArraySegment`1<Offset`1<WinRtPackageInfo>> data);
    public static VectorOffset CreatePackagesVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes);
    public static void StartPackagesVector(FlatBufferBuilder builder, int numElems);
    public static Offset`1<WinRtGetPackagesForCurrentUserResponse> EndWinRtGetPackagesForCurrentUserResponse(FlatBufferBuilder builder);
    public static void FinishWinRtGetPackagesForCurrentUserResponseBuffer(FlatBufferBuilder builder, Offset`1<WinRtGetPackagesForCurrentUserResponse> offset);
    public static void FinishSizePrefixedWinRtGetPackagesForCurrentUserResponseBuffer(FlatBufferBuilder builder, Offset`1<WinRtGetPackagesForCurrentUserResponse> offset);
}
public static class ProcMonRpc.WinRtGetPackagesForCurrentUserResponseVerify : object {
    public static bool Verify(Verifier verifier, UInt32 tablePos);
}
public class ProcMonRpc.WinRtPackageInfo : ValueType {
    private Table __p;
    public ByteBuffer ByteBuffer { get; }
    public string DisplayName { get; }
    public string PublisherDisplayName { get; }
    public string Name { get; }
    public string FamilyName { get; }
    public string FullName { get; }
    public bool IsFramework { get; }
    public string InstalledLocation { get; }
    public Nullable`1<Version> Version { get; }
    public ushort Architecture { get; }
    public string Publisher { get; }
    public string PublisherId { get; }
    public int ApplicationsLength { get; }
    public sealed virtual ByteBuffer get_ByteBuffer();
    public static void ValidateVersion();
    public static WinRtPackageInfo GetRootAsWinRtPackageInfo(ByteBuffer _bb);
    public static WinRtPackageInfo GetRootAsWinRtPackageInfo(ByteBuffer _bb, WinRtPackageInfo obj);
    public sealed virtual void __init(int _i, ByteBuffer _bb);
    public WinRtPackageInfo __assign(int _i, ByteBuffer _bb);
    public string get_DisplayName();
    public Nullable`1<ArraySegment`1<byte>> GetDisplayNameBytes();
    public Byte[] GetDisplayNameArray();
    public string get_PublisherDisplayName();
    public Nullable`1<ArraySegment`1<byte>> GetPublisherDisplayNameBytes();
    public Byte[] GetPublisherDisplayNameArray();
    public string get_Name();
    public Nullable`1<ArraySegment`1<byte>> GetNameBytes();
    public Byte[] GetNameArray();
    public string get_FamilyName();
    public Nullable`1<ArraySegment`1<byte>> GetFamilyNameBytes();
    public Byte[] GetFamilyNameArray();
    public string get_FullName();
    public Nullable`1<ArraySegment`1<byte>> GetFullNameBytes();
    public Byte[] GetFullNameArray();
    public bool get_IsFramework();
    public string get_InstalledLocation();
    public Nullable`1<ArraySegment`1<byte>> GetInstalledLocationBytes();
    public Byte[] GetInstalledLocationArray();
    public Nullable`1<Version> get_Version();
    public ushort get_Architecture();
    public string get_Publisher();
    public Nullable`1<ArraySegment`1<byte>> GetPublisherBytes();
    public Byte[] GetPublisherArray();
    public string get_PublisherId();
    public Nullable`1<ArraySegment`1<byte>> GetPublisherIdBytes();
    public Byte[] GetPublisherIdArray();
    public Nullable`1<WinRtApplicationInfo> Applications(int j);
    public int get_ApplicationsLength();
    public static Offset`1<WinRtPackageInfo> CreateWinRtPackageInfo(FlatBufferBuilder builder, StringOffset display_nameOffset, StringOffset publisher_display_nameOffset, StringOffset nameOffset, StringOffset family_nameOffset, StringOffset full_nameOffset, bool is_framework, StringOffset installed_locationOffset, Offset`1<Version> versionOffset, ushort architecture, StringOffset publisherOffset, StringOffset publisher_idOffset, VectorOffset applicationsOffset);
    public static void StartWinRtPackageInfo(FlatBufferBuilder builder);
    public static void AddDisplayName(FlatBufferBuilder builder, StringOffset displayNameOffset);
    public static void AddPublisherDisplayName(FlatBufferBuilder builder, StringOffset publisherDisplayNameOffset);
    public static void AddName(FlatBufferBuilder builder, StringOffset nameOffset);
    public static void AddFamilyName(FlatBufferBuilder builder, StringOffset familyNameOffset);
    public static void AddFullName(FlatBufferBuilder builder, StringOffset fullNameOffset);
    public static void AddIsFramework(FlatBufferBuilder builder, bool isFramework);
    public static void AddInstalledLocation(FlatBufferBuilder builder, StringOffset installedLocationOffset);
    public static void AddVersion(FlatBufferBuilder builder, Offset`1<Version> versionOffset);
    public static void AddArchitecture(FlatBufferBuilder builder, ushort architecture);
    public static void AddPublisher(FlatBufferBuilder builder, StringOffset publisherOffset);
    public static void AddPublisherId(FlatBufferBuilder builder, StringOffset publisherIdOffset);
    public static void AddApplications(FlatBufferBuilder builder, VectorOffset applicationsOffset);
    public static VectorOffset CreateApplicationsVector(FlatBufferBuilder builder, Offset`1[] data);
    public static VectorOffset CreateApplicationsVectorBlock(FlatBufferBuilder builder, Offset`1[] data);
    public static VectorOffset CreateApplicationsVectorBlock(FlatBufferBuilder builder, ArraySegment`1<Offset`1<WinRtApplicationInfo>> data);
    public static VectorOffset CreateApplicationsVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes);
    public static void StartApplicationsVector(FlatBufferBuilder builder, int numElems);
    public static Offset`1<WinRtPackageInfo> EndWinRtPackageInfo(FlatBufferBuilder builder);
}
public static class ProcMonRpc.WinRtPackageInfoVerify : object {
    public static bool Verify(Verifier verifier, UInt32 tablePos);
}
public class ProcMonRpc.WinRtPrepareAttachProfilingRequest : ValueType {
    private Table __p;
    public ByteBuffer ByteBuffer { get; }
    public ulong SessionId { get; }
    public string FullName { get; }
    public sealed virtual ByteBuffer get_ByteBuffer();
    public static void ValidateVersion();
    public static WinRtPrepareAttachProfilingRequest GetRootAsWinRtPrepareAttachProfilingRequest(ByteBuffer _bb);
    public static WinRtPrepareAttachProfilingRequest GetRootAsWinRtPrepareAttachProfilingRequest(ByteBuffer _bb, WinRtPrepareAttachProfilingRequest obj);
    public static bool VerifyWinRtPrepareAttachProfilingRequest(ByteBuffer _bb);
    public sealed virtual void __init(int _i, ByteBuffer _bb);
    public WinRtPrepareAttachProfilingRequest __assign(int _i, ByteBuffer _bb);
    public ulong get_SessionId();
    public string get_FullName();
    public Nullable`1<ArraySegment`1<byte>> GetFullNameBytes();
    public Byte[] GetFullNameArray();
    public static Offset`1<WinRtPrepareAttachProfilingRequest> CreateWinRtPrepareAttachProfilingRequest(FlatBufferBuilder builder, ulong session_id, StringOffset full_nameOffset);
    public static void StartWinRtPrepareAttachProfilingRequest(FlatBufferBuilder builder);
    public static void AddSessionId(FlatBufferBuilder builder, ulong sessionId);
    public static void AddFullName(FlatBufferBuilder builder, StringOffset fullNameOffset);
    public static Offset`1<WinRtPrepareAttachProfilingRequest> EndWinRtPrepareAttachProfilingRequest(FlatBufferBuilder builder);
    public static void FinishWinRtPrepareAttachProfilingRequestBuffer(FlatBufferBuilder builder, Offset`1<WinRtPrepareAttachProfilingRequest> offset);
    public static void FinishSizePrefixedWinRtPrepareAttachProfilingRequestBuffer(FlatBufferBuilder builder, Offset`1<WinRtPrepareAttachProfilingRequest> offset);
}
public static class ProcMonRpc.WinRtPrepareAttachProfilingRequestVerify : object {
    public static bool Verify(Verifier verifier, UInt32 tablePos);
}
public class ProcMonRpc.WinRtPrepareAttachProfilingResponse : ValueType {
    private Table __p;
    public ByteBuffer ByteBuffer { get; }
    public Nullable`1<StatusInfo> Status { get; }
    public sealed virtual ByteBuffer get_ByteBuffer();
    public static void ValidateVersion();
    public static WinRtPrepareAttachProfilingResponse GetRootAsWinRtPrepareAttachProfilingResponse(ByteBuffer _bb);
    public static WinRtPrepareAttachProfilingResponse GetRootAsWinRtPrepareAttachProfilingResponse(ByteBuffer _bb, WinRtPrepareAttachProfilingResponse obj);
    public static bool VerifyWinRtPrepareAttachProfilingResponse(ByteBuffer _bb);
    public sealed virtual void __init(int _i, ByteBuffer _bb);
    public WinRtPrepareAttachProfilingResponse __assign(int _i, ByteBuffer _bb);
    public Nullable`1<StatusInfo> get_Status();
    public static Offset`1<WinRtPrepareAttachProfilingResponse> CreateWinRtPrepareAttachProfilingResponse(FlatBufferBuilder builder, Offset`1<StatusInfo> statusOffset);
    public static void StartWinRtPrepareAttachProfilingResponse(FlatBufferBuilder builder);
    public static void AddStatus(FlatBufferBuilder builder, Offset`1<StatusInfo> statusOffset);
    public static Offset`1<WinRtPrepareAttachProfilingResponse> EndWinRtPrepareAttachProfilingResponse(FlatBufferBuilder builder);
    public static void FinishWinRtPrepareAttachProfilingResponseBuffer(FlatBufferBuilder builder, Offset`1<WinRtPrepareAttachProfilingResponse> offset);
    public static void FinishSizePrefixedWinRtPrepareAttachProfilingResponseBuffer(FlatBufferBuilder builder, Offset`1<WinRtPrepareAttachProfilingResponse> offset);
}
public static class ProcMonRpc.WinRtPrepareAttachProfilingResponseVerify : object {
    public static bool Verify(Verifier verifier, UInt32 tablePos);
}
public class ProcMonRpc.WinRtPrepareEverythingProfilingResponse : ValueType {
    private Table __p;
    public ByteBuffer ByteBuffer { get; }
    public Nullable`1<StatusInfo> Status { get; }
    public sealed virtual ByteBuffer get_ByteBuffer();
    public static void ValidateVersion();
    public static WinRtPrepareEverythingProfilingResponse GetRootAsWinRtPrepareEverythingProfilingResponse(ByteBuffer _bb);
    public static WinRtPrepareEverythingProfilingResponse GetRootAsWinRtPrepareEverythingProfilingResponse(ByteBuffer _bb, WinRtPrepareEverythingProfilingResponse obj);
    public static bool VerifyWinRtPrepareEverythingProfilingResponse(ByteBuffer _bb);
    public sealed virtual void __init(int _i, ByteBuffer _bb);
    public WinRtPrepareEverythingProfilingResponse __assign(int _i, ByteBuffer _bb);
    public Nullable`1<StatusInfo> get_Status();
    public static Offset`1<WinRtPrepareEverythingProfilingResponse> CreateWinRtPrepareEverythingProfilingResponse(FlatBufferBuilder builder, Offset`1<StatusInfo> statusOffset);
    public static void StartWinRtPrepareEverythingProfilingResponse(FlatBufferBuilder builder);
    public static void AddStatus(FlatBufferBuilder builder, Offset`1<StatusInfo> statusOffset);
    public static Offset`1<WinRtPrepareEverythingProfilingResponse> EndWinRtPrepareEverythingProfilingResponse(FlatBufferBuilder builder);
    public static void FinishWinRtPrepareEverythingProfilingResponseBuffer(FlatBufferBuilder builder, Offset`1<WinRtPrepareEverythingProfilingResponse> offset);
    public static void FinishSizePrefixedWinRtPrepareEverythingProfilingResponseBuffer(FlatBufferBuilder builder, Offset`1<WinRtPrepareEverythingProfilingResponse> offset);
}
public static class ProcMonRpc.WinRtPrepareEverythingProfilingResponseVerify : object {
    public static bool Verify(Verifier verifier, UInt32 tablePos);
}
public class ProcMonRpc.WinRtPrepareStartProfilingRequest : ValueType {
    private Table __p;
    public ByteBuffer ByteBuffer { get; }
    public string FullName { get; }
    public int EnvVarsLength { get; }
    public sealed virtual ByteBuffer get_ByteBuffer();
    public static void ValidateVersion();
    public static WinRtPrepareStartProfilingRequest GetRootAsWinRtPrepareStartProfilingRequest(ByteBuffer _bb);
    public static WinRtPrepareStartProfilingRequest GetRootAsWinRtPrepareStartProfilingRequest(ByteBuffer _bb, WinRtPrepareStartProfilingRequest obj);
    public static bool VerifyWinRtPrepareStartProfilingRequest(ByteBuffer _bb);
    public sealed virtual void __init(int _i, ByteBuffer _bb);
    public WinRtPrepareStartProfilingRequest __assign(int _i, ByteBuffer _bb);
    public string get_FullName();
    public Nullable`1<ArraySegment`1<byte>> GetFullNameBytes();
    public Byte[] GetFullNameArray();
    public Nullable`1<EnvVar> EnvVars(int j);
    public int get_EnvVarsLength();
    public static Offset`1<WinRtPrepareStartProfilingRequest> CreateWinRtPrepareStartProfilingRequest(FlatBufferBuilder builder, StringOffset full_nameOffset, VectorOffset env_varsOffset);
    public static void StartWinRtPrepareStartProfilingRequest(FlatBufferBuilder builder);
    public static void AddFullName(FlatBufferBuilder builder, StringOffset fullNameOffset);
    public static void AddEnvVars(FlatBufferBuilder builder, VectorOffset envVarsOffset);
    public static VectorOffset CreateEnvVarsVector(FlatBufferBuilder builder, Offset`1[] data);
    public static VectorOffset CreateEnvVarsVectorBlock(FlatBufferBuilder builder, Offset`1[] data);
    public static VectorOffset CreateEnvVarsVectorBlock(FlatBufferBuilder builder, ArraySegment`1<Offset`1<EnvVar>> data);
    public static VectorOffset CreateEnvVarsVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes);
    public static void StartEnvVarsVector(FlatBufferBuilder builder, int numElems);
    public static Offset`1<WinRtPrepareStartProfilingRequest> EndWinRtPrepareStartProfilingRequest(FlatBufferBuilder builder);
    public static void FinishWinRtPrepareStartProfilingRequestBuffer(FlatBufferBuilder builder, Offset`1<WinRtPrepareStartProfilingRequest> offset);
    public static void FinishSizePrefixedWinRtPrepareStartProfilingRequestBuffer(FlatBufferBuilder builder, Offset`1<WinRtPrepareStartProfilingRequest> offset);
}
public static class ProcMonRpc.WinRtPrepareStartProfilingRequestVerify : object {
    public static bool Verify(Verifier verifier, UInt32 tablePos);
}
public class ProcMonRpc.WinRtPrepareStartProfilingResponse : ValueType {
    private Table __p;
    public ByteBuffer ByteBuffer { get; }
    public Nullable`1<StatusInfo> Status { get; }
    public sealed virtual ByteBuffer get_ByteBuffer();
    public static void ValidateVersion();
    public static WinRtPrepareStartProfilingResponse GetRootAsWinRtPrepareStartProfilingResponse(ByteBuffer _bb);
    public static WinRtPrepareStartProfilingResponse GetRootAsWinRtPrepareStartProfilingResponse(ByteBuffer _bb, WinRtPrepareStartProfilingResponse obj);
    public static bool VerifyWinRtPrepareStartProfilingResponse(ByteBuffer _bb);
    public sealed virtual void __init(int _i, ByteBuffer _bb);
    public WinRtPrepareStartProfilingResponse __assign(int _i, ByteBuffer _bb);
    public Nullable`1<StatusInfo> get_Status();
    public static Offset`1<WinRtPrepareStartProfilingResponse> CreateWinRtPrepareStartProfilingResponse(FlatBufferBuilder builder, Offset`1<StatusInfo> statusOffset);
    public static void StartWinRtPrepareStartProfilingResponse(FlatBufferBuilder builder);
    public static void AddStatus(FlatBufferBuilder builder, Offset`1<StatusInfo> statusOffset);
    public static Offset`1<WinRtPrepareStartProfilingResponse> EndWinRtPrepareStartProfilingResponse(FlatBufferBuilder builder);
    public static void FinishWinRtPrepareStartProfilingResponseBuffer(FlatBufferBuilder builder, Offset`1<WinRtPrepareStartProfilingResponse> offset);
    public static void FinishSizePrefixedWinRtPrepareStartProfilingResponseBuffer(FlatBufferBuilder builder, Offset`1<WinRtPrepareStartProfilingResponse> offset);
}
public static class ProcMonRpc.WinRtPrepareStartProfilingResponseVerify : object {
    public static bool Verify(Verifier verifier, UInt32 tablePos);
}
public class ProcMonRpc.WinRtRunProfilingRequest : ValueType {
    private Table __p;
    public ByteBuffer ByteBuffer { get; }
    public string AppUserModelId { get; }
    public string Arguments { get; }
    public sealed virtual ByteBuffer get_ByteBuffer();
    public static void ValidateVersion();
    public static WinRtRunProfilingRequest GetRootAsWinRtRunProfilingRequest(ByteBuffer _bb);
    public static WinRtRunProfilingRequest GetRootAsWinRtRunProfilingRequest(ByteBuffer _bb, WinRtRunProfilingRequest obj);
    public static bool VerifyWinRtRunProfilingRequest(ByteBuffer _bb);
    public sealed virtual void __init(int _i, ByteBuffer _bb);
    public WinRtRunProfilingRequest __assign(int _i, ByteBuffer _bb);
    public string get_AppUserModelId();
    public Nullable`1<ArraySegment`1<byte>> GetAppUserModelIdBytes();
    public Byte[] GetAppUserModelIdArray();
    public string get_Arguments();
    public Nullable`1<ArraySegment`1<byte>> GetArgumentsBytes();
    public Byte[] GetArgumentsArray();
    public static Offset`1<WinRtRunProfilingRequest> CreateWinRtRunProfilingRequest(FlatBufferBuilder builder, StringOffset app_user_model_idOffset, StringOffset argumentsOffset);
    public static void StartWinRtRunProfilingRequest(FlatBufferBuilder builder);
    public static void AddAppUserModelId(FlatBufferBuilder builder, StringOffset appUserModelIdOffset);
    public static void AddArguments(FlatBufferBuilder builder, StringOffset argumentsOffset);
    public static Offset`1<WinRtRunProfilingRequest> EndWinRtRunProfilingRequest(FlatBufferBuilder builder);
    public static void FinishWinRtRunProfilingRequestBuffer(FlatBufferBuilder builder, Offset`1<WinRtRunProfilingRequest> offset);
    public static void FinishSizePrefixedWinRtRunProfilingRequestBuffer(FlatBufferBuilder builder, Offset`1<WinRtRunProfilingRequest> offset);
}
public static class ProcMonRpc.WinRtRunProfilingRequestVerify : object {
    public static bool Verify(Verifier verifier, UInt32 tablePos);
}
public class ProcMonRpc.WinRtRunProfilingResponse : ValueType {
    private Table __p;
    public ByteBuffer ByteBuffer { get; }
    public Nullable`1<StatusInfo> Status { get; }
    public sealed virtual ByteBuffer get_ByteBuffer();
    public static void ValidateVersion();
    public static WinRtRunProfilingResponse GetRootAsWinRtRunProfilingResponse(ByteBuffer _bb);
    public static WinRtRunProfilingResponse GetRootAsWinRtRunProfilingResponse(ByteBuffer _bb, WinRtRunProfilingResponse obj);
    public static bool VerifyWinRtRunProfilingResponse(ByteBuffer _bb);
    public sealed virtual void __init(int _i, ByteBuffer _bb);
    public WinRtRunProfilingResponse __assign(int _i, ByteBuffer _bb);
    public Nullable`1<StatusInfo> get_Status();
    public static Offset`1<WinRtRunProfilingResponse> CreateWinRtRunProfilingResponse(FlatBufferBuilder builder, Offset`1<StatusInfo> statusOffset);
    public static void StartWinRtRunProfilingResponse(FlatBufferBuilder builder);
    public static void AddStatus(FlatBufferBuilder builder, Offset`1<StatusInfo> statusOffset);
    public static Offset`1<WinRtRunProfilingResponse> EndWinRtRunProfilingResponse(FlatBufferBuilder builder);
    public static void FinishWinRtRunProfilingResponseBuffer(FlatBufferBuilder builder, Offset`1<WinRtRunProfilingResponse> offset);
    public static void FinishSizePrefixedWinRtRunProfilingResponseBuffer(FlatBufferBuilder builder, Offset`1<WinRtRunProfilingResponse> offset);
}
public static class ProcMonRpc.WinRtRunProfilingResponseVerify : object {
    public static bool Verify(Verifier verifier, UInt32 tablePos);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
