internal class DynamicData.Aggregation.AggregateEnumerator`1 : object {
    private IChangeSet`1<T> _source;
    public AggregateEnumerator`1(IChangeSet`1<T> source);
    [IteratorStateMachineAttribute("DynamicData.Aggregation.AggregateEnumerator`1/<GetEnumerator>d__2")]
public sealed virtual IEnumerator`1<AggregateItem`1<T>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class DynamicData.Aggregation.AggregateEnumerator`2 : object {
    private IChangeSet`2<TObject, TKey> _source;
    public AggregateEnumerator`2(IChangeSet`2<TObject, TKey> source);
    [IteratorStateMachineAttribute("DynamicData.Aggregation.AggregateEnumerator`2/<GetEnumerator>d__2")]
public sealed virtual IEnumerator`1<AggregateItem`1<TObject>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[IsReadOnlyAttribute]
public class DynamicData.Aggregation.AggregateItem`1 : ValueType {
    [CompilerGeneratedAttribute]
private AggregateType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private TObject <Item>k__BackingField;
    public AggregateType Type { get; }
    public TObject Item { get; }
    public AggregateItem`1(AggregateType type, TObject item);
    [CompilerGeneratedAttribute]
public AggregateType get_Type();
    [CompilerGeneratedAttribute]
public TObject get_Item();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(AggregateItem`1<TObject> other);
    public virtual int GetHashCode();
    public static bool op_Equality(AggregateItem`1<TObject> left, AggregateItem`1<TObject> right);
    public static bool op_Inequality(AggregateItem`1<TObject> left, AggregateItem`1<TObject> right);
}
public enum DynamicData.Aggregation.AggregateType : Enum {
    public int value__;
    public static AggregateType Add;
    public static AggregateType Remove;
}
[ExtensionAttribute]
public static class DynamicData.Aggregation.AggregationEx : object {
    [ExtensionAttribute]
public static IObservable`1<IAggregateChangeSet`1<TObject>> ForAggregation(IObservable`1<IChangeSet`2<TObject, TKey>> source);
    [ExtensionAttribute]
public static IObservable`1<IAggregateChangeSet`1<TObject>> ForAggregation(IObservable`1<IChangeSet`1<TObject>> source);
    [ExtensionAttribute]
internal static IObservable`1<TResult> Accumlate(IObservable`1<IChangeSet`1<TObject>> source, TResult seed, Func`2<TObject, TResult> accessor, Func`3<TResult, TResult, TResult> addAction, Func`3<TResult, TResult, TResult> removeAction);
    [ExtensionAttribute]
internal static IObservable`1<TResult> Accumlate(IObservable`1<IChangeSet`2<TObject, TKey>> source, TResult seed, Func`2<TObject, TResult> accessor, Func`3<TResult, TResult, TResult> addAction, Func`3<TResult, TResult, TResult> removeAction);
    [ExtensionAttribute]
internal static IObservable`1<TResult> Accumlate(IObservable`1<IAggregateChangeSet`1<TObject>> source, TResult seed, Func`2<TObject, TResult> accessor, Func`3<TResult, TResult, TResult> addAction, Func`3<TResult, TResult, TResult> removeAction);
    [ExtensionAttribute]
public static IObservable`1<T> InvalidateWhen(IObservable`1<T> source, IObservable`1<Unit> invalidate);
    [ExtensionAttribute]
public static IObservable`1<T> InvalidateWhen(IObservable`1<T> source, IObservable`1<TTrigger> invalidate);
}
[IsReadOnlyAttribute]
internal class DynamicData.Aggregation.Avg`1 : ValueType {
    [CompilerGeneratedAttribute]
private int <Count>k__BackingField;
    [CompilerGeneratedAttribute]
private TValue <Sum>k__BackingField;
    public int Count { get; }
    public TValue Sum { get; }
    public Avg`1(int count, TValue sum);
    [CompilerGeneratedAttribute]
public int get_Count();
    [CompilerGeneratedAttribute]
public TValue get_Sum();
}
[ExtensionAttribute]
public static class DynamicData.Aggregation.AvgEx : object {
    [ExtensionAttribute]
public static IObservable`1<double> Avg(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, int> valueSelector, int emptyValue);
    [ExtensionAttribute]
public static IObservable`1<double> Avg(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, Nullable`1<int>> valueSelector, int emptyValue);
    [ExtensionAttribute]
public static IObservable`1<double> Avg(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, long> valueSelector, long emptyValue);
    [ExtensionAttribute]
public static IObservable`1<double> Avg(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, Nullable`1<long>> valueSelector, long emptyValue);
    [ExtensionAttribute]
public static IObservable`1<double> Avg(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, double> valueSelector, double emptyValue);
    [ExtensionAttribute]
public static IObservable`1<double> Avg(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, Nullable`1<double>> valueSelector, double emptyValue);
    [ExtensionAttribute]
public static IObservable`1<decimal> Avg(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, decimal> valueSelector, decimal emptyValue);
    [ExtensionAttribute]
public static IObservable`1<decimal> Avg(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, Nullable`1<decimal>> valueSelector, decimal emptyValue);
    [ExtensionAttribute]
public static IObservable`1<float> Avg(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, float> valueSelector, float emptyValue);
    [ExtensionAttribute]
public static IObservable`1<float> Avg(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, Nullable`1<float>> valueSelector, float emptyValue);
    [ExtensionAttribute]
public static IObservable`1<double> Avg(IObservable`1<IChangeSet`1<T>> source, Func`2<T, int> valueSelector, int emptyValue);
    [ExtensionAttribute]
public static IObservable`1<double> Avg(IObservable`1<IChangeSet`1<T>> source, Func`2<T, Nullable`1<int>> valueSelector, int emptyValue);
    [ExtensionAttribute]
public static IObservable`1<double> Avg(IObservable`1<IChangeSet`1<T>> source, Func`2<T, long> valueSelector, long emptyValue);
    [ExtensionAttribute]
public static IObservable`1<double> Avg(IObservable`1<IChangeSet`1<T>> source, Func`2<T, Nullable`1<long>> valueSelector, long emptyValue);
    [ExtensionAttribute]
public static IObservable`1<double> Avg(IObservable`1<IChangeSet`1<T>> source, Func`2<T, double> valueSelector, double emptyValue);
    [ExtensionAttribute]
public static IObservable`1<double> Avg(IObservable`1<IChangeSet`1<T>> source, Func`2<T, Nullable`1<double>> valueSelector, double emptyValue);
    [ExtensionAttribute]
public static IObservable`1<decimal> Avg(IObservable`1<IChangeSet`1<T>> source, Func`2<T, decimal> valueSelector, decimal emptyValue);
    [ExtensionAttribute]
public static IObservable`1<decimal> Avg(IObservable`1<IChangeSet`1<T>> source, Func`2<T, Nullable`1<decimal>> valueSelector, decimal emptyValue);
    [ExtensionAttribute]
public static IObservable`1<float> Avg(IObservable`1<IChangeSet`1<T>> source, Func`2<T, float> valueSelector, float emptyValue);
    [ExtensionAttribute]
public static IObservable`1<float> Avg(IObservable`1<IChangeSet`1<T>> source, Func`2<T, Nullable`1<float>> valueSelector, float emptyValue);
    [ExtensionAttribute]
public static IObservable`1<double> Avg(IObservable`1<IAggregateChangeSet`1<T>> source, Func`2<T, int> valueSelector, int emptyValue);
    [ExtensionAttribute]
public static IObservable`1<double> Avg(IObservable`1<IAggregateChangeSet`1<T>> source, Func`2<T, Nullable`1<int>> valueSelector, int emptyValue);
    [ExtensionAttribute]
public static IObservable`1<double> Avg(IObservable`1<IAggregateChangeSet`1<T>> source, Func`2<T, long> valueSelector, long emptyValue);
    [ExtensionAttribute]
public static IObservable`1<double> Avg(IObservable`1<IAggregateChangeSet`1<T>> source, Func`2<T, Nullable`1<long>> valueSelector, long emptyValue);
    [ExtensionAttribute]
public static IObservable`1<double> Avg(IObservable`1<IAggregateChangeSet`1<T>> source, Func`2<T, double> valueSelector, double emptyValue);
    [ExtensionAttribute]
public static IObservable`1<double> Avg(IObservable`1<IAggregateChangeSet`1<T>> source, Func`2<T, Nullable`1<double>> valueSelector, double emptyValue);
    [ExtensionAttribute]
public static IObservable`1<decimal> Avg(IObservable`1<IAggregateChangeSet`1<T>> source, Func`2<T, decimal> valueSelector, decimal emptyValue);
    [ExtensionAttribute]
public static IObservable`1<decimal> Avg(IObservable`1<IAggregateChangeSet`1<T>> source, Func`2<T, Nullable`1<decimal>> valueSelector, decimal emptyValue);
    [ExtensionAttribute]
public static IObservable`1<float> Avg(IObservable`1<IAggregateChangeSet`1<T>> source, Func`2<T, float> valueSelector, float emptyValue);
    [ExtensionAttribute]
public static IObservable`1<float> Avg(IObservable`1<IAggregateChangeSet`1<T>> source, Func`2<T, Nullable`1<float>> valueSelector, float emptyValue);
    [ExtensionAttribute]
private static IObservable`1<TResult> AvgCalc(IObservable`1<IAggregateChangeSet`1<TObject>> source, Func`2<TObject, TValue> valueSelector, TResult fallbackValue, Func`3<Avg`1<TValue>, TValue, Avg`1<TValue>> addAction, Func`3<Avg`1<TValue>, TValue, Avg`1<TValue>> removeAction, Func`2<Avg`1<TValue>, TResult> resultAction);
}
[ExtensionAttribute]
public static class DynamicData.Aggregation.CountEx : object {
    [ExtensionAttribute]
public static IObservable`1<int> Count(IObservable`1<IChangeSet`2<TObject, TKey>> source);
    [ExtensionAttribute]
public static IObservable`1<int> Count(IObservable`1<IChangeSet`1<TObject>> source);
    [ExtensionAttribute]
public static IObservable`1<int> Count(IObservable`1<IAggregateChangeSet`1<TObject>> source);
    [ExtensionAttribute]
public static IObservable`1<int> Count(IObservable`1<IDistinctChangeSet`1<TObject>> source);
    [ExtensionAttribute]
public static IObservable`1<bool> IsEmpty(IObservable`1<IChangeSet`2<TObject, TKey>> source);
    [ExtensionAttribute]
public static IObservable`1<bool> NotEmpty(IObservable`1<IChangeSet`2<TObject, TKey>> source);
    [ExtensionAttribute]
public static IObservable`1<bool> IsEmpty(IObservable`1<IChangeSet`1<TObject>> source);
    [ExtensionAttribute]
public static IObservable`1<bool> NotEmpty(IObservable`1<IChangeSet`1<TObject>> source);
}
public interface DynamicData.Aggregation.IAggregateChangeSet`1 {
}
[ExtensionAttribute]
public static class DynamicData.Aggregation.MaxEx : object {
    [ExtensionAttribute]
public static IObservable`1<TResult> Maximum(IObservable`1<IChangeSet`1<TObject>> source, Func`2<TObject, TResult> valueSelector, TResult emptyValue);
    [ExtensionAttribute]
public static IObservable`1<TResult> Maximum(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, TResult> valueSelector, TResult emptyValue);
    [ExtensionAttribute]
public static IObservable`1<TResult> Minimum(IObservable`1<IChangeSet`1<TObject>> source, Func`2<TObject, TResult> valueSelector, TResult emptyValue);
    [ExtensionAttribute]
public static IObservable`1<TResult> Minimum(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, TResult> valueSelector, TResult emptyValue);
    [ExtensionAttribute]
private static IObservable`1<TResult> Calculate(IObservable`1<ChangesAndCollection`1<TObject>> source, Func`2<TObject, TResult> valueSelector, MaxOrMin maxOrMin, TResult emptyValue);
    [ExtensionAttribute]
private static IObservable`1<ChangesAndCollection`1<TObject>> ToChangesAndCollection(IObservable`1<IChangeSet`2<TObject, TKey>> source);
    [ExtensionAttribute]
private static IObservable`1<ChangesAndCollection`1<TObject>> ToChangesAndCollection(IObservable`1<IChangeSet`1<TObject>> source);
}
[IsReadOnlyAttribute]
internal class DynamicData.Aggregation.StdDev`1 : ValueType {
    [CompilerGeneratedAttribute]
private int <Count>k__BackingField;
    [CompilerGeneratedAttribute]
private TValue <SumOfItems>k__BackingField;
    [CompilerGeneratedAttribute]
private TValue <SumOfSquares>k__BackingField;
    public int Count { get; }
    public TValue SumOfItems { get; }
    public TValue SumOfSquares { get; }
    public StdDev`1(int count, TValue sumOfItems, TValue sumOfSquares);
    [CompilerGeneratedAttribute]
public int get_Count();
    [CompilerGeneratedAttribute]
public TValue get_SumOfItems();
    [CompilerGeneratedAttribute]
public TValue get_SumOfSquares();
}
[ExtensionAttribute]
public static class DynamicData.Aggregation.StdDevEx : object {
    [ExtensionAttribute]
public static IObservable`1<double> StdDev(IObservable`1<IChangeSet`1<T>> source, Func`2<T, int> valueSelector, int fallbackValue);
    [ExtensionAttribute]
public static IObservable`1<double> StdDev(IObservable`1<IChangeSet`1<T>> source, Func`2<T, long> valueSelector, long fallbackValue);
    [ExtensionAttribute]
public static IObservable`1<double> StdDev(IObservable`1<IChangeSet`1<T>> source, Func`2<T, double> valueSelector, double fallbackValue);
    [ExtensionAttribute]
public static IObservable`1<double> StdDev(IObservable`1<IChangeSet`1<T>> source, Func`2<T, decimal> valueSelector, decimal fallbackValue);
    [ExtensionAttribute]
public static IObservable`1<double> StdDev(IObservable`1<IChangeSet`1<T>> source, Func`2<T, float> valueSelector, float fallbackValue);
    [ExtensionAttribute]
public static IObservable`1<double> StdDev(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, int> valueSelector, int fallbackValue);
    [ExtensionAttribute]
public static IObservable`1<double> StdDev(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, long> valueSelector, long fallbackValue);
    [ExtensionAttribute]
public static IObservable`1<double> StdDev(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, double> valueSelector, double fallbackValue);
    [ExtensionAttribute]
public static IObservable`1<double> StdDev(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, decimal> valueSelector, decimal fallbackValue);
    [ExtensionAttribute]
public static IObservable`1<double> StdDev(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, float> valueSelector, float fallbackValue);
    [ExtensionAttribute]
public static IObservable`1<double> StdDev(IObservable`1<IAggregateChangeSet`1<T>> source, Func`2<T, int> valueSelector, int fallbackValue);
    [ExtensionAttribute]
public static IObservable`1<double> StdDev(IObservable`1<IAggregateChangeSet`1<T>> source, Func`2<T, long> valueSelector, long fallbackValue);
    [ExtensionAttribute]
public static IObservable`1<double> StdDev(IObservable`1<IAggregateChangeSet`1<T>> source, Func`2<T, decimal> valueSelector, decimal fallbackValue);
    [ExtensionAttribute]
public static IObservable`1<double> StdDev(IObservable`1<IAggregateChangeSet`1<T>> source, Func`2<T, double> valueSelector, double fallbackValue);
    [ExtensionAttribute]
public static IObservable`1<double> StdDev(IObservable`1<IAggregateChangeSet`1<T>> source, Func`2<T, float> valueSelector, float fallbackValue);
    [ExtensionAttribute]
private static IObservable`1<TResult> StdDevCalc(IObservable`1<IAggregateChangeSet`1<TObject>> source, Func`2<TObject, TValue> valueSelector, TResult fallbackValue, Func`3<StdDev`1<TValue>, TValue, StdDev`1<TValue>> addAction, Func`3<StdDev`1<TValue>, TValue, StdDev`1<TValue>> removeAction, Func`2<StdDev`1<TValue>, TResult> resultAction);
}
[ExtensionAttribute]
public static class DynamicData.Aggregation.SumEx : object {
    [ExtensionAttribute]
public static IObservable`1<int> Sum(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, int> valueSelector);
    [ExtensionAttribute]
public static IObservable`1<int> Sum(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, Nullable`1<int>> valueSelector);
    [ExtensionAttribute]
public static IObservable`1<long> Sum(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, long> valueSelector);
    [ExtensionAttribute]
public static IObservable`1<long> Sum(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, Nullable`1<long>> valueSelector);
    [ExtensionAttribute]
public static IObservable`1<double> Sum(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, double> valueSelector);
    [ExtensionAttribute]
public static IObservable`1<double> Sum(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, Nullable`1<double>> valueSelector);
    [ExtensionAttribute]
public static IObservable`1<decimal> Sum(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, decimal> valueSelector);
    [ExtensionAttribute]
public static IObservable`1<decimal> Sum(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, Nullable`1<decimal>> valueSelector);
    [ExtensionAttribute]
public static IObservable`1<float> Sum(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, float> valueSelector);
    [ExtensionAttribute]
public static IObservable`1<float> Sum(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, Nullable`1<float>> valueSelector);
    [ExtensionAttribute]
public static IObservable`1<int> Sum(IObservable`1<IChangeSet`1<T>> source, Func`2<T, int> valueSelector);
    [ExtensionAttribute]
public static IObservable`1<int> Sum(IObservable`1<IChangeSet`1<T>> source, Func`2<T, Nullable`1<int>> valueSelector);
    [ExtensionAttribute]
public static IObservable`1<long> Sum(IObservable`1<IChangeSet`1<T>> source, Func`2<T, long> valueSelector);
    [ExtensionAttribute]
public static IObservable`1<long> Sum(IObservable`1<IChangeSet`1<T>> source, Func`2<T, Nullable`1<long>> valueSelector);
    [ExtensionAttribute]
public static IObservable`1<double> Sum(IObservable`1<IChangeSet`1<T>> source, Func`2<T, double> valueSelector);
    [ExtensionAttribute]
public static IObservable`1<double> Sum(IObservable`1<IChangeSet`1<T>> source, Func`2<T, Nullable`1<double>> valueSelector);
    [ExtensionAttribute]
public static IObservable`1<decimal> Sum(IObservable`1<IChangeSet`1<T>> source, Func`2<T, decimal> valueSelector);
    [ExtensionAttribute]
public static IObservable`1<decimal> Sum(IObservable`1<IChangeSet`1<T>> source, Func`2<T, Nullable`1<decimal>> valueSelector);
    [ExtensionAttribute]
public static IObservable`1<float> Sum(IObservable`1<IChangeSet`1<T>> source, Func`2<T, float> valueSelector);
    [ExtensionAttribute]
public static IObservable`1<float> Sum(IObservable`1<IChangeSet`1<T>> source, Func`2<T, Nullable`1<float>> valueSelector);
    [ExtensionAttribute]
public static IObservable`1<int> Sum(IObservable`1<IAggregateChangeSet`1<T>> source, Func`2<T, int> valueSelector);
    [ExtensionAttribute]
public static IObservable`1<int> Sum(IObservable`1<IAggregateChangeSet`1<T>> source, Func`2<T, Nullable`1<int>> valueSelector);
    [ExtensionAttribute]
public static IObservable`1<long> Sum(IObservable`1<IAggregateChangeSet`1<T>> source, Func`2<T, long> valueSelector);
    [ExtensionAttribute]
public static IObservable`1<long> Sum(IObservable`1<IAggregateChangeSet`1<T>> source, Func`2<T, Nullable`1<long>> valueSelector);
    [ExtensionAttribute]
public static IObservable`1<double> Sum(IObservable`1<IAggregateChangeSet`1<T>> source, Func`2<T, double> valueSelector);
    [ExtensionAttribute]
public static IObservable`1<double> Sum(IObservable`1<IAggregateChangeSet`1<T>> source, Func`2<T, Nullable`1<double>> valueSelector);
    [ExtensionAttribute]
public static IObservable`1<decimal> Sum(IObservable`1<IAggregateChangeSet`1<T>> source, Func`2<T, decimal> valueSelector);
    [ExtensionAttribute]
public static IObservable`1<decimal> Sum(IObservable`1<IAggregateChangeSet`1<T>> source, Func`2<T, Nullable`1<decimal>> valueSelector);
    [ExtensionAttribute]
public static IObservable`1<float> Sum(IObservable`1<IAggregateChangeSet`1<T>> source, Func`2<T, float> valueSelector);
    [ExtensionAttribute]
public static IObservable`1<float> Sum(IObservable`1<IAggregateChangeSet`1<T>> source, Func`2<T, Nullable`1<float>> valueSelector);
}
[ExtensionAttribute]
public static class DynamicData.Alias.ObservableCacheAlias : object {
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> Where(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, bool> filter);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> Where(IObservable`1<IChangeSet`2<TObject, TKey>> source, IObservable`1<Func`2<TObject, bool>> predicateChanged);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> Where(IObservable`1<IChangeSet`2<TObject, TKey>> source, IObservable`1<Unit> reapplyFilter);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> Where(IObservable`1<IChangeSet`2<TObject, TKey>> source, IObservable`1<Func`2<TObject, bool>> predicateChanged, IObservable`1<Unit> reapplyFilter);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TKey>> Select(IObservable`1<IChangeSet`2<TSource, TKey>> source, Func`3<TSource, TKey, TDestination> transformFactory, IObservable`1<Unit> forceTransform);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TKey>> Select(IObservable`1<IChangeSet`2<TSource, TKey>> source, Func`3<TSource, TKey, TDestination> transformFactory, IObservable`1<Func`3<TSource, TKey, bool>> forceTransform);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TKey>> Select(IObservable`1<IChangeSet`2<TSource, TKey>> source, Func`2<TSource, TDestination> transformFactory, IObservable`1<Unit> forceTransform);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TKey>> Select(IObservable`1<IChangeSet`2<TSource, TKey>> source, Func`2<TSource, TDestination> transformFactory, IObservable`1<Func`2<TSource, bool>> forceTransform);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<Node`2<TObject, TKey>, TKey>> SelectTree(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, TKey> pivotOn);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TDestinationKey>> SelectMany(IObservable`1<IChangeSet`2<TSource, TSourceKey>> source, Func`2<TSource, IEnumerable`1<TDestination>> manyselector, Func`2<TDestination, TDestinationKey> keySelector);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TKey>> SelectSafe(IObservable`1<IChangeSet`2<TSource, TKey>> source, Func`2<TSource, TDestination> transformFactory, Action`1<Error`2<TSource, TKey>> errorHandler, IObservable`1<Unit> forceTransform);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TKey>> SelectSafe(IObservable`1<IChangeSet`2<TSource, TKey>> source, Func`2<TSource, TDestination> transformFactory, Action`1<Error`2<TSource, TKey>> errorHandler, IObservable`1<Func`2<TSource, bool>> forceTransform);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TKey>> SelectSafe(IObservable`1<IChangeSet`2<TSource, TKey>> source, Func`3<TSource, TKey, TDestination> transformFactory, Action`1<Error`2<TSource, TKey>> errorHandler, IObservable`1<Func`3<TSource, TKey, bool>> forceTransform);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TKey>> SelectSafe(IObservable`1<IChangeSet`2<TSource, TKey>> source, Func`3<TSource, TKey, TDestination> transformFactory, Action`1<Error`2<TSource, TKey>> errorHandler, IObservable`1<Unit> forceTransform);
}
[ExtensionAttribute]
public static class DynamicData.Alias.ObservableListAlias : object {
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> Where(IObservable`1<IChangeSet`1<T>> source, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> Where(IObservable`1<IChangeSet`1<T>> source, IObservable`1<Func`2<T, bool>> predicate);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<TDestination>> Select(IObservable`1<IChangeSet`1<TSource>> source, Func`2<TSource, TDestination> transformFactory);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<TDestination>> SelectMany(IObservable`1<IChangeSet`1<TSource>> source, Func`2<TSource, IEnumerable`1<TDestination>> manyselector);
}
[AttributeUsageAttribute("4")]
[ConditionalAttribute("JETBRAINS_ANNOTATIONS")]
public class DynamicData.Annotations.AspChildControlTypeAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <TagName>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ControlType>k__BackingField;
    public string TagName { get; private set; }
    public Type ControlType { get; private set; }
    public AspChildControlTypeAttribute(string tagName, Type controlType);
    [CompilerGeneratedAttribute]
public string get_TagName();
    [CompilerGeneratedAttribute]
private void set_TagName(string value);
    [CompilerGeneratedAttribute]
public Type get_ControlType();
    [CompilerGeneratedAttribute]
private void set_ControlType(Type value);
}
[AttributeUsageAttribute("192")]
[ConditionalAttribute("JETBRAINS_ANNOTATIONS")]
public class DynamicData.Annotations.AspDataFieldAttribute : Attribute {
}
[AttributeUsageAttribute("192")]
[ConditionalAttribute("JETBRAINS_ANNOTATIONS")]
public class DynamicData.Annotations.AspDataFieldsAttribute : Attribute {
}
[AttributeUsageAttribute("128")]
[ConditionalAttribute("JETBRAINS_ANNOTATIONS")]
public class DynamicData.Annotations.AspMethodPropertyAttribute : Attribute {
}
[AttributeUsageAttribute("2112")]
[ConditionalAttribute("JETBRAINS_ANNOTATIONS")]
public class DynamicData.Annotations.AspMvcActionAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <AnonymousProperty>k__BackingField;
    public string AnonymousProperty { get; private set; }
    public AspMvcActionAttribute(string anonymousProperty);
    [CompilerGeneratedAttribute]
public string get_AnonymousProperty();
    [CompilerGeneratedAttribute]
private void set_AnonymousProperty(string value);
}
[AttributeUsageAttribute("2176")]
[ConditionalAttribute("JETBRAINS_ANNOTATIONS")]
public class DynamicData.Annotations.AspMvcActionSelectorAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
[ConditionalAttribute("JETBRAINS_ANNOTATIONS")]
public class DynamicData.Annotations.AspMvcAreaAttribute : PathReferenceAttribute {
    [CompilerGeneratedAttribute]
private string <AnonymousProperty>k__BackingField;
    public string AnonymousProperty { get; private set; }
    public AspMvcAreaAttribute(string anonymousProperty);
    [CompilerGeneratedAttribute]
public string get_AnonymousProperty();
    [CompilerGeneratedAttribute]
private void set_AnonymousProperty(string value);
}
[AttributeUsageAttribute("1")]
[ConditionalAttribute("JETBRAINS_ANNOTATIONS")]
public class DynamicData.Annotations.AspMvcAreaMasterLocationFormatAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Format>k__BackingField;
    public string Format { get; private set; }
    public AspMvcAreaMasterLocationFormatAttribute(string format);
    [CompilerGeneratedAttribute]
public string get_Format();
    [CompilerGeneratedAttribute]
private void set_Format(string value);
}
[AttributeUsageAttribute("1")]
[ConditionalAttribute("JETBRAINS_ANNOTATIONS")]
public class DynamicData.Annotations.AspMvcAreaPartialViewLocationFormatAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Format>k__BackingField;
    public string Format { get; private set; }
    public AspMvcAreaPartialViewLocationFormatAttribute(string format);
    [CompilerGeneratedAttribute]
public string get_Format();
    [CompilerGeneratedAttribute]
private void set_Format(string value);
}
[AttributeUsageAttribute("1")]
[ConditionalAttribute("JETBRAINS_ANNOTATIONS")]
public class DynamicData.Annotations.AspMvcAreaViewLocationFormatAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Format>k__BackingField;
    public string Format { get; private set; }
    public AspMvcAreaViewLocationFormatAttribute(string format);
    [CompilerGeneratedAttribute]
public string get_Format();
    [CompilerGeneratedAttribute]
private void set_Format(string value);
}
[AttributeUsageAttribute("2112")]
[ConditionalAttribute("JETBRAINS_ANNOTATIONS")]
public class DynamicData.Annotations.AspMvcControllerAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <AnonymousProperty>k__BackingField;
    public string AnonymousProperty { get; private set; }
    public AspMvcControllerAttribute(string anonymousProperty);
    [CompilerGeneratedAttribute]
public string get_AnonymousProperty();
    [CompilerGeneratedAttribute]
private void set_AnonymousProperty(string value);
}
[AttributeUsageAttribute("2048")]
[ConditionalAttribute("JETBRAINS_ANNOTATIONS")]
public class DynamicData.Annotations.AspMvcDisplayTemplateAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
[ConditionalAttribute("JETBRAINS_ANNOTATIONS")]
public class DynamicData.Annotations.AspMvcEditorTemplateAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
[ConditionalAttribute("JETBRAINS_ANNOTATIONS")]
public class DynamicData.Annotations.AspMvcMasterAttribute : Attribute {
}
[AttributeUsageAttribute("1")]
[ConditionalAttribute("JETBRAINS_ANNOTATIONS")]
public class DynamicData.Annotations.AspMvcMasterLocationFormatAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Format>k__BackingField;
    public string Format { get; private set; }
    public AspMvcMasterLocationFormatAttribute(string format);
    [CompilerGeneratedAttribute]
public string get_Format();
    [CompilerGeneratedAttribute]
private void set_Format(string value);
}
[AttributeUsageAttribute("2048")]
[ConditionalAttribute("JETBRAINS_ANNOTATIONS")]
public class DynamicData.Annotations.AspMvcModelTypeAttribute : Attribute {
}
[AttributeUsageAttribute("2112")]
[ConditionalAttribute("JETBRAINS_ANNOTATIONS")]
public class DynamicData.Annotations.AspMvcPartialViewAttribute : PathReferenceAttribute {
}
[AttributeUsageAttribute("1")]
[ConditionalAttribute("JETBRAINS_ANNOTATIONS")]
public class DynamicData.Annotations.AspMvcPartialViewLocationFormatAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Format>k__BackingField;
    public string Format { get; private set; }
    public AspMvcPartialViewLocationFormatAttribute(string format);
    [CompilerGeneratedAttribute]
public string get_Format();
    [CompilerGeneratedAttribute]
private void set_Format(string value);
}
[AttributeUsageAttribute("68")]
[ConditionalAttribute("JETBRAINS_ANNOTATIONS")]
public class DynamicData.Annotations.AspMvcSupressViewErrorAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
[ConditionalAttribute("JETBRAINS_ANNOTATIONS")]
public class DynamicData.Annotations.AspMvcTemplateAttribute : Attribute {
}
[AttributeUsageAttribute("2112")]
[ConditionalAttribute("JETBRAINS_ANNOTATIONS")]
public class DynamicData.Annotations.AspMvcViewAttribute : PathReferenceAttribute {
}
[AttributeUsageAttribute("1")]
[ConditionalAttribute("JETBRAINS_ANNOTATIONS")]
public class DynamicData.Annotations.AspMvcViewLocationFormatAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Format>k__BackingField;
    public string Format { get; private set; }
    public AspMvcViewLocationFormatAttribute(string format);
    [CompilerGeneratedAttribute]
public string get_Format();
    [CompilerGeneratedAttribute]
private void set_Format(string value);
}
[AttributeUsageAttribute("4")]
[ConditionalAttribute("JETBRAINS_ANNOTATIONS")]
public class DynamicData.Annotations.AspRequiredAttributeAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Attribute>k__BackingField;
    public string Attribute { get; private set; }
    public AspRequiredAttributeAttribute(string attribute);
    [CompilerGeneratedAttribute]
public string get_Attribute();
    [CompilerGeneratedAttribute]
private void set_Attribute(string value);
}
[AttributeUsageAttribute("128")]
[ConditionalAttribute("JETBRAINS_ANNOTATIONS")]
public class DynamicData.Annotations.AspTypePropertyAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <CreateConstructorReferences>k__BackingField;
    public bool CreateConstructorReferences { get; private set; }
    public AspTypePropertyAttribute(bool createConstructorReferences);
    [CompilerGeneratedAttribute]
public bool get_CreateConstructorReferences();
    [CompilerGeneratedAttribute]
private void set_CreateConstructorReferences(bool value);
}
[AttributeUsageAttribute("2048")]
[ConditionalAttribute("JETBRAINS_ANNOTATIONS")]
public class DynamicData.Annotations.AssertionConditionAttribute : Attribute {
    [CompilerGeneratedAttribute]
private AssertionConditionType <ConditionType>k__BackingField;
    public AssertionConditionType ConditionType { get; private set; }
    public AssertionConditionAttribute(AssertionConditionType conditionType);
    [CompilerGeneratedAttribute]
public AssertionConditionType get_ConditionType();
    [CompilerGeneratedAttribute]
private void set_ConditionType(AssertionConditionType value);
}
public enum DynamicData.Annotations.AssertionConditionType : Enum {
    public int value__;
    public static AssertionConditionType IS_TRUE;
    public static AssertionConditionType IS_FALSE;
    public static AssertionConditionType IS_NULL;
    public static AssertionConditionType IS_NOT_NULL;
}
[AttributeUsageAttribute("64")]
[ConditionalAttribute("JETBRAINS_ANNOTATIONS")]
public class DynamicData.Annotations.AssertionMethodAttribute : Attribute {
}
[AttributeUsageAttribute("4")]
[ConditionalAttribute("JETBRAINS_ANNOTATIONS")]
public class DynamicData.Annotations.BaseTypeRequiredAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type <BaseType>k__BackingField;
    public Type BaseType { get; private set; }
    public BaseTypeRequiredAttribute(Type baseType);
    [CompilerGeneratedAttribute]
public Type get_BaseType();
    [CompilerGeneratedAttribute]
private void set_BaseType(Type value);
}
[AttributeUsageAttribute("7104")]
[ConditionalAttribute("JETBRAINS_ANNOTATIONS")]
public class DynamicData.Annotations.CanBeNullAttribute : Attribute {
}
[AttributeUsageAttribute("1036")]
[ConditionalAttribute("JETBRAINS_ANNOTATIONS")]
public class DynamicData.Annotations.CannotApplyEqualityOperatorAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
[ConditionalAttribute("JETBRAINS_ANNOTATIONS")]
public class DynamicData.Annotations.CollectionAccessAttribute : Attribute {
    [CompilerGeneratedAttribute]
private CollectionAccessType <CollectionAccessType>k__BackingField;
    public CollectionAccessType CollectionAccessType { get; private set; }
    public CollectionAccessAttribute(CollectionAccessType collectionAccessType);
    [CompilerGeneratedAttribute]
public CollectionAccessType get_CollectionAccessType();
    [CompilerGeneratedAttribute]
private void set_CollectionAccessType(CollectionAccessType value);
}
[FlagsAttribute]
public enum DynamicData.Annotations.CollectionAccessType : Enum {
    public int value__;
    public static CollectionAccessType None;
    public static CollectionAccessType Read;
    public static CollectionAccessType ModifyExistingContent;
    public static CollectionAccessType UpdatedContent;
}
[AttributeUsageAttribute("64")]
[ConditionalAttribute("JETBRAINS_ANNOTATIONS")]
public class DynamicData.Annotations.ContractAnnotationAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Contract>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ForceFullStates>k__BackingField;
    public string Contract { get; private set; }
    public bool ForceFullStates { get; private set; }
    public ContractAnnotationAttribute(string contract);
    public ContractAnnotationAttribute(string contract, bool forceFullStates);
    [CompilerGeneratedAttribute]
public string get_Contract();
    [CompilerGeneratedAttribute]
private void set_Contract(string value);
    [CompilerGeneratedAttribute]
public bool get_ForceFullStates();
    [CompilerGeneratedAttribute]
private void set_ForceFullStates(bool value);
}
[AttributeUsageAttribute("2432")]
[ConditionalAttribute("JETBRAINS_ANNOTATIONS")]
public class DynamicData.Annotations.HtmlAttributeValueAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; private set; }
    public HtmlAttributeValueAttribute(string name);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
}
[AttributeUsageAttribute("2432")]
[ConditionalAttribute("JETBRAINS_ANNOTATIONS")]
public class DynamicData.Annotations.HtmlElementAttributesAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; private set; }
    public HtmlElementAttributesAttribute(string name);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
}
[FlagsAttribute]
public enum DynamicData.Annotations.ImplicitUseKindFlags : Enum {
    public int value__;
    public static ImplicitUseKindFlags Default;
    public static ImplicitUseKindFlags Access;
    public static ImplicitUseKindFlags Assign;
    public static ImplicitUseKindFlags InstantiatedWithFixedConstructorSignature;
    public static ImplicitUseKindFlags InstantiatedNoFixedConstructorSignature;
}
[FlagsAttribute]
public enum DynamicData.Annotations.ImplicitUseTargetFlags : Enum {
    public int value__;
    public static ImplicitUseTargetFlags Default;
    public static ImplicitUseTargetFlags Itself;
    public static ImplicitUseTargetFlags Members;
    public static ImplicitUseTargetFlags WithMembers;
}
[AttributeUsageAttribute("2048")]
[ConditionalAttribute("JETBRAINS_ANNOTATIONS")]
public class DynamicData.Annotations.InstantHandleAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
[ConditionalAttribute("JETBRAINS_ANNOTATIONS")]
public class DynamicData.Annotations.InvokerParameterNameAttribute : Attribute {
}
[AttributeUsageAttribute("6592")]
[ConditionalAttribute("JETBRAINS_ANNOTATIONS")]
public class DynamicData.Annotations.ItemCanBeNullAttribute : Attribute {
}
[AttributeUsageAttribute("6592")]
[ConditionalAttribute("JETBRAINS_ANNOTATIONS")]
public class DynamicData.Annotations.ItemNotNullAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
[ConditionalAttribute("JETBRAINS_ANNOTATIONS")]
public class DynamicData.Annotations.LinqTunnelAttribute : Attribute {
}
[AttributeUsageAttribute("32767")]
[ConditionalAttribute("JETBRAINS_ANNOTATIONS")]
public class DynamicData.Annotations.LocalizationRequiredAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <Required>k__BackingField;
    public bool Required { get; private set; }
    public LocalizationRequiredAttribute(bool required);
    [CompilerGeneratedAttribute]
public bool get_Required();
    [CompilerGeneratedAttribute]
private void set_Required(bool value);
}
[AttributeUsageAttribute("16388")]
[ConditionalAttribute("JETBRAINS_ANNOTATIONS")]
public class DynamicData.Annotations.MeansImplicitUseAttribute : Attribute {
    [CompilerGeneratedAttribute]
private ImplicitUseKindFlags <UseKindFlags>k__BackingField;
    [CompilerGeneratedAttribute]
private ImplicitUseTargetFlags <TargetFlags>k__BackingField;
    public ImplicitUseKindFlags UseKindFlags { get; private set; }
    public ImplicitUseTargetFlags TargetFlags { get; private set; }
    public MeansImplicitUseAttribute(ImplicitUseKindFlags useKindFlags);
    public MeansImplicitUseAttribute(ImplicitUseTargetFlags targetFlags);
    public MeansImplicitUseAttribute(ImplicitUseKindFlags useKindFlags, ImplicitUseTargetFlags targetFlags);
    [CompilerGeneratedAttribute]
public ImplicitUseKindFlags get_UseKindFlags();
    [CompilerGeneratedAttribute]
private void set_UseKindFlags(ImplicitUseKindFlags value);
    [CompilerGeneratedAttribute]
public ImplicitUseTargetFlags get_TargetFlags();
    [CompilerGeneratedAttribute]
private void set_TargetFlags(ImplicitUseTargetFlags value);
}
[AttributeUsageAttribute("2048")]
[ConditionalAttribute("JETBRAINS_ANNOTATIONS")]
public class DynamicData.Annotations.NoEnumerationAttribute : Attribute {
}
[AttributeUsageAttribute("32767")]
[ConditionalAttribute("JETBRAINS_ANNOTATIONS")]
public class DynamicData.Annotations.NoReorder : Attribute {
}
[AttributeUsageAttribute("64")]
[ConditionalAttribute("JETBRAINS_ANNOTATIONS")]
public class DynamicData.Annotations.NotifyPropertyChangedInvocatorAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; private set; }
    public NotifyPropertyChangedInvocatorAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
    [CompilerGeneratedAttribute]
private void set_ParameterName(string value);
}
[AttributeUsageAttribute("7104")]
[ConditionalAttribute("JETBRAINS_ANNOTATIONS")]
public class DynamicData.Annotations.NotNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
[ConditionalAttribute("JETBRAINS_ANNOTATIONS")]
public class DynamicData.Annotations.PathReferenceAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <BasePath>k__BackingField;
    public string BasePath { get; private set; }
    public PathReferenceAttribute(string basePath);
    [CompilerGeneratedAttribute]
public string get_BasePath();
    [CompilerGeneratedAttribute]
private void set_BasePath(string value);
}
[ConditionalAttribute("JETBRAINS_ANNOTATIONS")]
public class DynamicData.Annotations.PublicAPIAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Comment>k__BackingField;
    public string Comment { get; private set; }
    public PublicAPIAttribute(string comment);
    [CompilerGeneratedAttribute]
public string get_Comment();
    [CompilerGeneratedAttribute]
private void set_Comment(string value);
}
[AttributeUsageAttribute("64")]
[ConditionalAttribute("JETBRAINS_ANNOTATIONS")]
public class DynamicData.Annotations.PureAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
[ConditionalAttribute("JETBRAINS_ANNOTATIONS")]
public class DynamicData.Annotations.RazorHelperCommonAttribute : Attribute {
}
[AttributeUsageAttribute("1")]
[ConditionalAttribute("JETBRAINS_ANNOTATIONS")]
public class DynamicData.Annotations.RazorImportNamespaceAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; private set; }
    public RazorImportNamespaceAttribute(string name);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
}
[AttributeUsageAttribute("1")]
[ConditionalAttribute("JETBRAINS_ANNOTATIONS")]
public class DynamicData.Annotations.RazorInjectionAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FieldName>k__BackingField;
    public string Type { get; private set; }
    public string FieldName { get; private set; }
    public RazorInjectionAttribute(string type, string fieldName);
    [CompilerGeneratedAttribute]
public string get_Type();
    [CompilerGeneratedAttribute]
private void set_Type(string value);
    [CompilerGeneratedAttribute]
public string get_FieldName();
    [CompilerGeneratedAttribute]
private void set_FieldName(string value);
}
[AttributeUsageAttribute("128")]
[ConditionalAttribute("JETBRAINS_ANNOTATIONS")]
public class DynamicData.Annotations.RazorLayoutAttribute : Attribute {
}
[AttributeUsageAttribute("2112")]
[ConditionalAttribute("JETBRAINS_ANNOTATIONS")]
public class DynamicData.Annotations.RazorSectionAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
[ConditionalAttribute("JETBRAINS_ANNOTATIONS")]
public class DynamicData.Annotations.RazorWriteLiteralMethodAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
[ConditionalAttribute("JETBRAINS_ANNOTATIONS")]
public class DynamicData.Annotations.RazorWriteMethodAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
[ConditionalAttribute("JETBRAINS_ANNOTATIONS")]
public class DynamicData.Annotations.RazorWriteMethodParameterAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
[ConditionalAttribute("JETBRAINS_ANNOTATIONS")]
public class DynamicData.Annotations.RegexPatternAttribute : Attribute {
}
[AttributeUsageAttribute("4192")]
[ConditionalAttribute("JETBRAINS_ANNOTATIONS")]
public class DynamicData.Annotations.StringFormatMethodAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <FormatParameterName>k__BackingField;
    public string FormatParameterName { get; private set; }
    public StringFormatMethodAttribute(string formatParameterName);
    [CompilerGeneratedAttribute]
public string get_FormatParameterName();
    [CompilerGeneratedAttribute]
private void set_FormatParameterName(string value);
}
[ObsoleteAttribute("Use [ContractAnnotation('=> halt')] instead")]
[AttributeUsageAttribute("64")]
[ConditionalAttribute("JETBRAINS_ANNOTATIONS")]
public class DynamicData.Annotations.TerminatesProgramAttribute : Attribute {
}
[AttributeUsageAttribute("32767")]
[ConditionalAttribute("JETBRAINS_ANNOTATIONS")]
public class DynamicData.Annotations.UsedImplicitlyAttribute : Attribute {
    [CompilerGeneratedAttribute]
private ImplicitUseKindFlags <UseKindFlags>k__BackingField;
    [CompilerGeneratedAttribute]
private ImplicitUseTargetFlags <TargetFlags>k__BackingField;
    public ImplicitUseKindFlags UseKindFlags { get; private set; }
    public ImplicitUseTargetFlags TargetFlags { get; private set; }
    public UsedImplicitlyAttribute(ImplicitUseKindFlags useKindFlags);
    public UsedImplicitlyAttribute(ImplicitUseTargetFlags targetFlags);
    public UsedImplicitlyAttribute(ImplicitUseKindFlags useKindFlags, ImplicitUseTargetFlags targetFlags);
    [CompilerGeneratedAttribute]
public ImplicitUseKindFlags get_UseKindFlags();
    [CompilerGeneratedAttribute]
private void set_UseKindFlags(ImplicitUseKindFlags value);
    [CompilerGeneratedAttribute]
public ImplicitUseTargetFlags get_TargetFlags();
    [CompilerGeneratedAttribute]
private void set_TargetFlags(ImplicitUseTargetFlags value);
}
[AttributeUsageAttribute("2432")]
[ConditionalAttribute("JETBRAINS_ANNOTATIONS")]
public class DynamicData.Annotations.ValueProviderAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; private set; }
    public ValueProviderAttribute(string name);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
}
[AttributeUsageAttribute("128")]
[ConditionalAttribute("JETBRAINS_ANNOTATIONS")]
public class DynamicData.Annotations.XamlItemBindingOfItemsControlAttribute : Attribute {
}
[AttributeUsageAttribute("4")]
[ConditionalAttribute("JETBRAINS_ANNOTATIONS")]
public class DynamicData.Annotations.XamlItemsControlAttribute : Attribute {
}
public abstract class DynamicData.Binding.AbstractNotifyPropertyChanged : object {
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    protected void OnPropertyChanged(string propertyName);
    protected virtual void SetAndRaise(T& backingField, T newValue, string propertyName);
    protected virtual void SetAndRaise(T& backingField, T newValue, IEqualityComparer`1<T> comparer, string propertyName);
    [ObsoleteAttribute("This never worked properly in the first place")]
public IDisposable SuspendNotifications(bool invokePropertyChangeEventWhenDisposed);
}
public class DynamicData.Binding.BindingListAdaptor`1 : object {
    private BindingList`1<T> _list;
    private int _refreshThreshold;
    private bool _loaded;
    public BindingListAdaptor`1(BindingList`1<T> list, int refreshThreshold);
    public sealed virtual void Adapt(IChangeSet`1<T> changes);
}
public class DynamicData.Binding.BindingListAdaptor`2 : object {
    private BindingList`1<TObject> _list;
    private int _refreshThreshold;
    private bool _loaded;
    private Cache`2<TObject, TKey> _cache;
    public BindingListAdaptor`2(BindingList`1<TObject> list, int refreshThreshold);
    public sealed virtual void Adapt(IChangeSet`2<TObject, TKey> changes);
    private void DoUpdate(IChangeSet`2<TObject, TKey> changes, BindingList`1<TObject> list);
}
internal class DynamicData.Binding.BindingListEventsSuspender`1 : object {
    private IDisposable _cleanUp;
    public BindingListEventsSuspender`1(BindingList`1<T> list);
    public sealed virtual void Dispose();
}
[ExtensionAttribute]
public static class DynamicData.Binding.BindingListEx : object {
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> ToObservableChangeSet(BindingList`1<T> source);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> ToObservableChangeSet(BindingList`1<TObject> source, Func`2<TObject, TKey> keySelector);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> ToObservableChangeSet(TCollection source);
    [ExtensionAttribute]
public static IObservable`1<EventPattern`1<ListChangedEventArgs>> ObserveCollectionChanges(IBindingList source);
}
[ExtensionAttribute]
internal static class DynamicData.Binding.ExpressionBuilder : object {
    [ExtensionAttribute]
internal static string ToCacheKey(Expression`1<Func`2<TObject, TProperty>> expression);
    [IteratorStateMachineAttribute("DynamicData.Binding.ExpressionBuilder/<GetMembers>d__1`2")]
[ExtensionAttribute]
public static IEnumerable`1<MemberExpression> GetMembers(Expression`1<Func`2<TObject, TProperty>> source);
    [IteratorStateMachineAttribute("DynamicData.Binding.ExpressionBuilder/<GetMemberChain>d__2`2")]
[ExtensionAttribute]
internal static IEnumerable`1<MemberExpression> GetMemberChain(Expression`1<Func`2<TObject, TProperty>> expression);
    [ExtensionAttribute]
internal static Func`2<object, object> CreateValueAccessor(MemberExpression source);
    [ExtensionAttribute]
internal static Func`2<object, IObservable`1<Unit>> CreatePropertyChangedFactory(MemberExpression source);
    [ExtensionAttribute]
internal static PropertyInfo GetProperty(Expression`1<Func`2<TObject, TProperty>> expression);
    [ExtensionAttribute]
internal static PropertyInfo GetProperty(MemberExpression expression);
    [ExtensionAttribute]
internal static MemberInfo GetMember(Expression`1<Func`2<TObject, TProperty>> expression);
    private static MemberInfo GetMemberInfo(LambdaExpression lambda);
}
public interface DynamicData.Binding.IEvaluateAware {
    public abstract virtual void Evaluate();
}
public interface DynamicData.Binding.IIndexAware {
    public int Index { get; public set; }
    public abstract virtual int get_Index();
    public abstract virtual void set_Index(int value);
}
public interface DynamicData.Binding.INotifyCollectionChangedSuspender {
    public abstract virtual IDisposable SuspendNotifications();
    public abstract virtual IDisposable SuspendCount();
}
public interface DynamicData.Binding.IObservableCollection`1 {
    public abstract virtual void Move(int oldIndex, int newIndex);
    public abstract virtual void Load(IEnumerable`1<T> items);
}
public interface DynamicData.Binding.IObservableCollectionAdaptor`2 {
    public abstract virtual void Adapt(IChangeSet`2<TObject, TKey> changes, IObservableCollection`1<TObject> collection);
}
[ExtensionAttribute]
public static class DynamicData.Binding.IObservableListEx : object {
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<TObject>> BindToObservableList(IObservable`1<IChangeSet`1<TObject>> source, IObservableList`1& observableList);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> BindToObservableList(IObservable`1<IChangeSet`2<TObject, TKey>> source, IObservableList`1& observableList);
    [ExtensionAttribute]
public static IObservable`1<ISortedChangeSet`2<TObject, TKey>> BindToObservableList(IObservable`1<ISortedChangeSet`2<TObject, TKey>> source, IObservableList`1& observableList);
    [ExtensionAttribute]
private static IChangeSet`1<TObject> RemoveKey(IChangeSet`2<TObject, TKey> changeSetWithKey, IExtendedList`1<TObject> list);
}
public interface DynamicData.Binding.ISortedObservableCollectionAdaptor`2 {
    public abstract virtual void Adapt(ISortedChangeSet`2<TObject, TKey> changes, IObservableCollection`1<TObject> collection);
}
[ExtensionAttribute]
public static class DynamicData.Binding.NotifyPropertyChangedEx : object {
    [ExtensionAttribute]
public static IObservable`1<TObject> WhenAnyPropertyChanged(TObject source, String[] propertiesToMonitor);
    [ExtensionAttribute]
public static IObservable`1<PropertyValue`2<TObject, TProperty>> WhenPropertyChanged(TObject source, Expression`1<Func`2<TObject, TProperty>> propertyAccessor, bool notifyOnInitialValue, Func`1<TProperty> fallbackValue);
    [ExtensionAttribute]
public static IObservable`1<TProperty> WhenValueChanged(TObject source, Expression`1<Func`2<TObject, TProperty>> propertyAccessor, bool notifyOnInitialValue, Func`1<TProperty> fallbackValue);
    [ExtensionAttribute]
public static IObservable`1<TResult> WhenChanged(TObject source, Expression`1<Func`2<TObject, TProperty1>> p1, Func`3<TObject, TProperty1, TResult> resultSelector, Func`1<TProperty1> p1Fallback);
    [ExtensionAttribute]
public static IObservable`1<TResult> WhenChanged(TObject source, Expression`1<Func`2<TObject, TProperty1>> p1, Expression`1<Func`2<TObject, TProperty2>> p2, Func`4<TObject, TProperty1, TProperty2, TResult> resultSelector, Func`1<TProperty1> p1Fallback, Func`1<TProperty2> p2Fallback);
    [ExtensionAttribute]
public static IObservable`1<TResult> WhenChanged(TObject source, Expression`1<Func`2<TObject, TProperty1>> p1, Expression`1<Func`2<TObject, TProperty2>> p2, Expression`1<Func`2<TObject, TProperty3>> p3, Func`5<TObject, TProperty1, TProperty2, TProperty3, TResult> resultSelector, Func`1<TProperty1> p1Fallback, Func`1<TProperty2> p2Fallback, Func`1<TProperty3> p3Fallback);
    [ExtensionAttribute]
public static IObservable`1<TResult> WhenChanged(TObject source, Expression`1<Func`2<TObject, TProperty1>> p1, Expression`1<Func`2<TObject, TProperty2>> p2, Expression`1<Func`2<TObject, TProperty3>> p3, Expression`1<Func`2<TObject, TProperty4>> p4, Func`6<TObject, TProperty1, TProperty2, TProperty3, TProperty4, TResult> resultSelector, Func`1<TProperty1> p1Fallback, Func`1<TProperty2> p2Fallback, Func`1<TProperty3> p3Fallback, Func`1<TProperty4> p4Fallback);
    [ExtensionAttribute]
public static IObservable`1<TResult> WhenChanged(TObject source, Expression`1<Func`2<TObject, TProperty1>> p1, Expression`1<Func`2<TObject, TProperty2>> p2, Expression`1<Func`2<TObject, TProperty3>> p3, Expression`1<Func`2<TObject, TProperty4>> p4, Expression`1<Func`2<TObject, TProperty5>> p5, Func`7<TObject, TProperty1, TProperty2, TProperty3, TProperty4, TProperty5, TResult> resultSelector, Func`1<TProperty1> p1Fallback, Func`1<TProperty2> p2Fallback, Func`1<TProperty3> p3Fallback, Func`1<TProperty4> p4Fallback, Func`1<TProperty5> p5Fallback);
    [ExtensionAttribute]
public static IObservable`1<TResult> WhenChanged(TObject source, Expression`1<Func`2<TObject, TProperty1>> p1, Expression`1<Func`2<TObject, TProperty2>> p2, Expression`1<Func`2<TObject, TProperty3>> p3, Expression`1<Func`2<TObject, TProperty4>> p4, Expression`1<Func`2<TObject, TProperty5>> p5, Expression`1<Func`2<TObject, TProperty6>> p6, Func`8<TObject, TProperty1, TProperty2, TProperty3, TProperty4, TProperty5, TProperty6, TResult> resultSelector, Func`1<TProperty1> p1Fallback, Func`1<TProperty2> p2Fallback, Func`1<TProperty3> p3Fallback, Func`1<TProperty4> p4Fallback, Func`1<TProperty5> p5Fallback, Func`1<TProperty6> p6Fallback);
    [ExtensionAttribute]
internal static IObservable`1<TProperty> WhenChanged(TObject source, Expression`1<Func`2<TObject, TProperty>> expression, bool notifyInitial, Func`1<TProperty> fallbackValue);
    [ExtensionAttribute]
internal static Func`3<TObject, bool, IObservable`1<PropertyValue`2<TObject, TProperty>>> GetFactory(Expression`1<Func`2<TObject, TProperty>> expression);
}
internal static class DynamicData.Binding.Observable`1 : object {
    public static IObservable`1<T> Empty;
    public static IObservable`1<T> Never;
    public static IObservable`1<T> Default;
    private static Observable`1();
}
public class DynamicData.Binding.ObservableCollectionAdaptor`1 : object {
    private IObservableCollection`1<T> _collection;
    private int _refreshThreshold;
    private bool _loaded;
    public ObservableCollectionAdaptor`1(IObservableCollection`1<T> collection, int refreshThreshold);
    public sealed virtual void Adapt(IChangeSet`1<T> changes);
}
public class DynamicData.Binding.ObservableCollectionAdaptor`2 : object {
    private int _refreshThreshold;
    private bool _loaded;
    private Cache`2<TObject, TKey> _cache;
    public ObservableCollectionAdaptor`2(int refreshThreshold);
    public sealed virtual void Adapt(IChangeSet`2<TObject, TKey> changes, IObservableCollection`1<TObject> collection);
    private void DoUpdate(IChangeSet`2<TObject, TKey> updates, IObservableCollection`1<TObject> list);
}
[ExtensionAttribute]
public static class DynamicData.Binding.ObservableCollectionEx : object {
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> ToObservableChangeSet(ObservableCollection`1<T> source);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> ToObservableChangeSet(ObservableCollection`1<TObject> source, Func`2<TObject, TKey> keySelector);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> ToObservableChangeSet(ReadOnlyObservableCollection`1<T> source);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> ToObservableChangeSet(ReadOnlyObservableCollection`1<TObject> source, Func`2<TObject, TKey> keySelector);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> ToObservableChangeSet(TCollection source);
    [ExtensionAttribute]
public static IObservable`1<EventPattern`1<NotifyCollectionChangedEventArgs>> ObserveCollectionChanges(INotifyCollectionChanged source);
}
public class DynamicData.Binding.ObservableCollectionExtended`1 : ObservableCollection`1<T> {
    private bool _suspendNotifications;
    private bool _suspendCount;
    public ObservableCollectionExtended`1(List`1<T> list);
    public ObservableCollectionExtended`1(IEnumerable`1<T> collection);
    public sealed virtual IDisposable SuspendNotifications();
    public sealed virtual IDisposable SuspendCount();
    protected virtual void OnPropertyChanged(PropertyChangedEventArgs e);
    protected virtual void OnCollectionChanged(NotifyCollectionChangedEventArgs e);
    public sealed virtual void Load(IEnumerable`1<T> items);
    public sealed virtual void AddRange(IEnumerable`1<T> collection);
    public sealed virtual void InsertRange(IEnumerable`1<T> collection, int index);
    public sealed virtual void RemoveRange(int index, int count);
    private sealed virtual override void DynamicData.Binding.IObservableCollection<T>.Move(int oldIndex, int newIndex);
    private sealed virtual override void DynamicData.IExtendedList<T>.Move(int original, int destination);
    [CompilerGeneratedAttribute]
private void <SuspendNotifications>b__5_0();
}
internal class DynamicData.Binding.ObservablePropertyFactory`2 : object {
    private Func`3<TObject, bool, IObservable`1<PropertyValue`2<TObject, TProperty>>> _factory;
    public ObservablePropertyFactory`2(Func`2<TObject, TProperty> valueAccessor, ObservablePropertyPart[] chain);
    public ObservablePropertyFactory`2(Expression`1<Func`2<TObject, TProperty>> expression);
    public IObservable`1<PropertyValue`2<TObject, TProperty>> Create(TObject source, bool notifyInitial);
    [IteratorStateMachineAttribute("DynamicData.Binding.ObservablePropertyFactory`2/<GetNotifiers>d__4")]
private static IEnumerable`1<IObservable`1<Unit>> GetNotifiers(TObject source, ObservablePropertyPart[] chain);
    private static PropertyValue`2<TObject, TProperty> GetPropertyValue(TObject source, ObservablePropertyPart[] chain, Func`2<TObject, TProperty> valueAccessor);
}
internal class DynamicData.Binding.ObservablePropertyFactoryCache : object {
    private ConcurrentDictionary`2<string, object> _factories;
    public static ObservablePropertyFactoryCache Instance;
    private static ObservablePropertyFactoryCache();
    public ObservablePropertyFactory`2<TObject, TProperty> GetFactory(Expression`1<Func`2<TObject, TProperty>> expression);
}
[DebuggerDisplayAttribute("ObservablePropertyPart<{_expression}>")]
internal class DynamicData.Binding.ObservablePropertyPart : object {
    private MemberExpression _expression;
    [CompilerGeneratedAttribute]
private Func`2<object, IObservable`1<Unit>> <Factory>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<object, object> <Accessor>k__BackingField;
    public Func`2<object, IObservable`1<Unit>> Factory { get; }
    public Func`2<object, object> Accessor { get; }
    public ObservablePropertyPart(MemberExpression expression);
    [CompilerGeneratedAttribute]
public Func`2<object, IObservable`1<Unit>> get_Factory();
    [CompilerGeneratedAttribute]
public Func`2<object, object> get_Accessor();
}
public class DynamicData.Binding.PropertyValue`2 : object {
    [CompilerGeneratedAttribute]
private TObject <Sender>k__BackingField;
    [CompilerGeneratedAttribute]
private TValue <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UnobtainableValue>k__BackingField;
    public TObject Sender { get; }
    public TValue Value { get; }
    internal bool UnobtainableValue { get; }
    public PropertyValue`2(TObject sender, TValue value);
    internal PropertyValue`2(TObject sender);
    [CompilerGeneratedAttribute]
public TObject get_Sender();
    [CompilerGeneratedAttribute]
public TValue get_Value();
    [CompilerGeneratedAttribute]
internal bool get_UnobtainableValue();
    public sealed virtual bool Equals(PropertyValue`2<TObject, TValue> other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(PropertyValue`2<TObject, TValue> left, PropertyValue`2<TObject, TValue> right);
    public static bool op_Inequality(PropertyValue`2<TObject, TValue> left, PropertyValue`2<TObject, TValue> right);
    public virtual string ToString();
}
public enum DynamicData.Binding.SortDirection : Enum {
    public int value__;
    public static SortDirection Ascending;
    public static SortDirection Descending;
}
public class DynamicData.Binding.SortedBindingListAdaptor`2 : object {
    private BindingList`1<TObject> _list;
    private int _refreshThreshold;
    public SortedBindingListAdaptor`2(BindingList`1<TObject> list, int refreshThreshold);
    public sealed virtual void Adapt(ISortedChangeSet`2<TObject, TKey> changes);
    private void DoUpdate(ISortedChangeSet`2<TObject, TKey> changes);
}
public class DynamicData.Binding.SortedObservableCollectionAdaptor`2 : object {
    private int _refreshThreshold;
    public SortedObservableCollectionAdaptor`2(int refreshThreshold);
    public sealed virtual void Adapt(ISortedChangeSet`2<TObject, TKey> changes, IObservableCollection`1<TObject> collection);
    private void DoUpdate(ISortedChangeSet`2<TObject, TKey> updates, IObservableCollection`1<TObject> list);
}
public class DynamicData.Binding.SortExpression`1 : object {
    [CompilerGeneratedAttribute]
private SortDirection <Direction>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<T, IComparable> <Expression>k__BackingField;
    public SortDirection Direction { get; }
    public Func`2<T, IComparable> Expression { get; }
    public SortExpression`1(Func`2<T, IComparable> expression, SortDirection direction);
    [CompilerGeneratedAttribute]
public SortDirection get_Direction();
    [CompilerGeneratedAttribute]
public Func`2<T, IComparable> get_Expression();
}
public class DynamicData.Binding.SortExpressionComparer`1 : List`1<SortExpression`1<T>> {
    public sealed virtual int Compare(T x, T y);
    public static SortExpressionComparer`1<T> Ascending(Func`2<T, IComparable> expression);
    public static SortExpressionComparer`1<T> Descending(Func`2<T, IComparable> expression);
    public SortExpressionComparer`1<T> ThenByAscending(Func`2<T, IComparable> expression);
    public SortExpressionComparer`1<T> ThenByDescending(Func`2<T, IComparable> expression);
}
internal abstract class DynamicData.Cache.Internal.AbstractFilter`2 : object {
    private ChangeAwareCache`2<TObject, TKey> _cache;
    [CompilerGeneratedAttribute]
private Func`2<TObject, bool> <Filter>k__BackingField;
    public Func`2<TObject, bool> Filter { get; }
    protected AbstractFilter`2(ChangeAwareCache`2<TObject, TKey> cache, Func`2<TObject, bool> filter);
    [CompilerGeneratedAttribute]
public sealed virtual Func`2<TObject, bool> get_Filter();
    public sealed virtual IChangeSet`2<TObject, TKey> Refresh(IEnumerable`1<KeyValuePair`2<TKey, TObject>> items);
    protected abstract virtual IEnumerable`1<Change`2<TObject, TKey>> Refresh(IEnumerable`1<KeyValuePair`2<TKey, TObject>> items, Func`2<KeyValuePair`2<TKey, TObject>, Optional`1<Change`2<TObject, TKey>>> factory);
    public sealed virtual IChangeSet`2<TObject, TKey> Update(IChangeSet`2<TObject, TKey> updates);
    protected abstract virtual IEnumerable`1<UpdateWithFilter<TObject, TKey>> GetChangesWithFilter(IChangeSet`2<TObject, TKey> updates);
    private IChangeSet`2<TObject, TKey> ProcessResult(IEnumerable`1<UpdateWithFilter<TObject, TKey>> source);
    [CompilerGeneratedAttribute]
private Optional`1<Change`2<TObject, TKey>> <Refresh>g__Factory|5_0(KeyValuePair`2<TKey, TObject> kv);
}
internal class DynamicData.Cache.Internal.AnonymousObservableCache`2 : object {
    private IObservableCache`2<TObject, TKey> _cache;
    public IObservable`1<int> CountChanged { get; }
    public IEnumerable`1<TKey> Keys { get; }
    public IEnumerable`1<TObject> Items { get; }
    public int Count { get; }
    public IEnumerable`1<KeyValuePair`2<TKey, TObject>> KeyValues { get; }
    public AnonymousObservableCache`2(IObservable`1<IChangeSet`2<TObject, TKey>> source);
    public AnonymousObservableCache`2(IObservableCache`2<TObject, TKey> cache);
    public sealed virtual IObservable`1<int> get_CountChanged();
    public sealed virtual IObservable`1<Change`2<TObject, TKey>> Watch(TKey key);
    public sealed virtual IObservable`1<IChangeSet`2<TObject, TKey>> Connect(Func`2<TObject, bool> predicate);
    public sealed virtual IObservable`1<IChangeSet`2<TObject, TKey>> Preview(Func`2<TObject, bool> predicate);
    public sealed virtual IEnumerable`1<TKey> get_Keys();
    public sealed virtual IEnumerable`1<TObject> get_Items();
    public sealed virtual int get_Count();
    public sealed virtual IEnumerable`1<KeyValuePair`2<TKey, TObject>> get_KeyValues();
    public sealed virtual Optional`1<TObject> Lookup(TKey key);
    public sealed virtual void Dispose();
}
internal class DynamicData.Cache.Internal.AnonymousQuery`2 : object {
    private Cache`2<TObject, TKey> _cache;
    public int Count { get; }
    public IEnumerable`1<TObject> Items { get; }
    public IEnumerable`1<KeyValuePair`2<TKey, TObject>> KeyValues { get; }
    public IEnumerable`1<TKey> Keys { get; }
    public AnonymousQuery`2(Cache`2<TObject, TKey> cache);
    public sealed virtual int get_Count();
    public sealed virtual IEnumerable`1<TObject> get_Items();
    public sealed virtual IEnumerable`1<KeyValuePair`2<TKey, TObject>> get_KeyValues();
    public sealed virtual IEnumerable`1<TKey> get_Keys();
    public sealed virtual Optional`1<TObject> Lookup(TKey key);
}
internal class DynamicData.Cache.Internal.AutoRefresh`3 : object {
    private IObservable`1<IChangeSet`2<TObject, TKey>> _source;
    private Func`3<TObject, TKey, IObservable`1<TAny>> _reevaluator;
    private Nullable`1<TimeSpan> _buffer;
    private IScheduler _scheduler;
    public AutoRefresh`3(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`3<TObject, TKey, IObservable`1<TAny>> reevaluator, Nullable`1<TimeSpan> buffer, IScheduler scheduler);
    public IObservable`1<IChangeSet`2<TObject, TKey>> Run();
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__5_0(IObserver`1<IChangeSet`2<TObject, TKey>> observer);
    [CompilerGeneratedAttribute]
private IObservable`1<Change`2<TObject, TKey>> <Run>b__5_1(TObject t, TKey k);
}
internal class DynamicData.Cache.Internal.BatchIf`2 : object {
    private IObservable`1<IChangeSet`2<TObject, TKey>> _source;
    private IObservable`1<bool> _pauseIfTrueSelector;
    private Nullable`1<TimeSpan> _timeOut;
    private bool _initialPauseState;
    private IObservable`1<Unit> _intervalTimer;
    private IScheduler _scheduler;
    public BatchIf`2(IObservable`1<IChangeSet`2<TObject, TKey>> source, IObservable`1<bool> pauseIfTrueSelector, Nullable`1<TimeSpan> timeOut, bool initialPauseState, IObservable`1<Unit> intervalTimer, IScheduler scheduler);
    public IObservable`1<ChangeSet`2<TObject, TKey>> Run();
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__7_0(IObserver`1<ChangeSet`2<TObject, TKey>> observer);
}
[DebuggerDisplayAttribute("Cache<{typeof(TObject).Name}, {typeof(TKey).Name}> ({Count Items)")]
internal class DynamicData.Cache.Internal.Cache`2 : object {
    private Dictionary`2<TKey, TObject> _data;
    public static Cache`2<TObject, TKey> Empty;
    public int Count { get; }
    public IEnumerable`1<KeyValuePair`2<TKey, TObject>> KeyValues { get; }
    public IEnumerable`1<TObject> Items { get; }
    public IEnumerable`1<TKey> Keys { get; }
    public Cache`2(int capacity);
    public Cache`2(Dictionary`2<TKey, TObject> data);
    private static Cache`2();
    public sealed virtual int get_Count();
    public sealed virtual IEnumerable`1<KeyValuePair`2<TKey, TObject>> get_KeyValues();
    public sealed virtual IEnumerable`1<TObject> get_Items();
    public sealed virtual IEnumerable`1<TKey> get_Keys();
    public Cache`2<TObject, TKey> Clone();
    public sealed virtual void Clone(IChangeSet`2<TObject, TKey> changes);
    public sealed virtual Optional`1<TObject> Lookup(TKey key);
    public sealed virtual void AddOrUpdate(TObject item, TKey key);
    public sealed virtual void Remove(IEnumerable`1<TKey> keys);
    public sealed virtual void Remove(TKey key);
    public sealed virtual void Clear();
    public sealed virtual void Refresh();
    public sealed virtual void Refresh(IEnumerable`1<TKey> keys);
    public sealed virtual void Refresh(TKey key);
}
[ExtensionAttribute]
internal static class DynamicData.Cache.Internal.CacheEx : object {
    [ExtensionAttribute]
public static IChangeSet`2<TObject, TKey> GetInitialUpdates(ChangeAwareCache`2<TObject, TKey> source, Func`2<TObject, bool> filter);
    [ExtensionAttribute]
public static void Clone(IDictionary`2<TKey, TObject> source, IChangeSet`2<TObject, TKey> changes);
}
internal class DynamicData.Cache.Internal.CacheUpdater`2 : object {
    private ICache`2<TObject, TKey> _cache;
    private Func`2<TObject, TKey> _keySelector;
    public IEnumerable`1<TObject> Items { get; }
    public IEnumerable`1<TKey> Keys { get; }
    public IEnumerable`1<KeyValuePair`2<TKey, TObject>> KeyValues { get; }
    public int Count { get; }
    public CacheUpdater`2(ICache`2<TObject, TKey> cache, Func`2<TObject, TKey> keySelector);
    public CacheUpdater`2(Dictionary`2<TKey, TObject> data, Func`2<TObject, TKey> keySelector);
    public sealed virtual IEnumerable`1<TObject> get_Items();
    public sealed virtual IEnumerable`1<TKey> get_Keys();
    public sealed virtual IEnumerable`1<KeyValuePair`2<TKey, TObject>> get_KeyValues();
    public sealed virtual Optional`1<TObject> Lookup(TKey key);
    public sealed virtual void Load(IEnumerable`1<TObject> items);
    public sealed virtual void AddOrUpdate(IEnumerable`1<TObject> items);
    public sealed virtual void AddOrUpdate(TObject item);
    public sealed virtual void AddOrUpdate(TObject item, IEqualityComparer`1<TObject> comparer);
    public sealed virtual TKey GetKey(TObject item);
    public sealed virtual IEnumerable`1<KeyValuePair`2<TKey, TObject>> GetKeyValues(IEnumerable`1<TObject> items);
    public sealed virtual void AddOrUpdate(IEnumerable`1<KeyValuePair`2<TKey, TObject>> itemsPairs);
    public sealed virtual void AddOrUpdate(KeyValuePair`2<TKey, TObject> item);
    public sealed virtual void AddOrUpdate(TObject item, TKey key);
    public sealed virtual void Refresh();
    public sealed virtual void Refresh(IEnumerable`1<TObject> items);
    public sealed virtual void Refresh(IEnumerable`1<TKey> keys);
    public sealed virtual void Refresh(TObject item);
    [ObsoleteAttribute("Use Refresh: Same thing but better semantics")]
public sealed virtual void Evaluate(IEnumerable`1<TKey> keys);
    [ObsoleteAttribute("Use Refresh: Same thing but better semantics")]
public sealed virtual void Evaluate(IEnumerable`1<TObject> items);
    [ObsoleteAttribute("Use Refresh: Same thing but better semantics")]
public sealed virtual void Evaluate(TObject item);
    public sealed virtual void Refresh(TKey key);
    [ObsoleteAttribute("Use Refresh: Same thing but better semantics")]
public sealed virtual void Evaluate();
    [ObsoleteAttribute("Use Refresh: Same thing but better semantics")]
public sealed virtual void Evaluate(TKey key);
    public sealed virtual void Remove(IEnumerable`1<TObject> items);
    public sealed virtual void Remove(IEnumerable`1<TKey> keys);
    public sealed virtual void RemoveKeys(IEnumerable`1<TKey> keys);
    public sealed virtual void Remove(TObject item);
    public Optional`1<TObject> Lookup(TObject item);
    public sealed virtual void Remove(TKey key);
    public sealed virtual void RemoveKey(TKey key);
    public sealed virtual void Remove(IEnumerable`1<KeyValuePair`2<TKey, TObject>> items);
    public sealed virtual void Remove(KeyValuePair`2<TKey, TObject> item);
    public sealed virtual void Clear();
    public sealed virtual int get_Count();
    public sealed virtual void Update(IChangeSet`2<TObject, TKey> changes);
    public sealed virtual void Clone(IChangeSet`2<TObject, TKey> changes);
    [CompilerGeneratedAttribute]
private KeyValuePair`2<TKey, TObject> <GetKeyValues>b__16_0(TObject t);
}
internal class DynamicData.Cache.Internal.Cast`3 : object {
    private IObservable`1<IChangeSet`2<TSource, TKey>> _source;
    private Func`2<TSource, TDestination> _converter;
    public Cast`3(IObservable`1<IChangeSet`2<TSource, TKey>> source, Func`2<TSource, TDestination> converter);
    public IObservable`1<IChangeSet`2<TDestination, TKey>> Run();
    [CompilerGeneratedAttribute]
private ChangeSet`2<TDestination, TKey> <Run>b__3_0(IChangeSet`2<TSource, TKey> changes);
    [CompilerGeneratedAttribute]
private Change`2<TDestination, TKey> <Run>b__3_1(Change`2<TSource, TKey> change);
}
internal static class DynamicData.Cache.Internal.ChangesReducer : object {
    public static Optional`1<Change`2<TObject, TKey>> Reduce(Optional`1<Change`2<TObject, TKey>> previous, Change`2<TObject, TKey> next);
}
public enum DynamicData.Cache.Internal.CombineOperator : Enum {
    public int value__;
    public static CombineOperator And;
    public static CombineOperator Or;
    public static CombineOperator Xor;
    public static CombineOperator Except;
}
internal class DynamicData.Cache.Internal.Combiner`2 : object {
    private IList`1<Cache`2<TObject, TKey>> _sourceCaches;
    private ChangeAwareCache`2<TObject, TKey> _combinedCache;
    private object _locker;
    private CombineOperator _type;
    private Action`1<IChangeSet`2<TObject, TKey>> _updatedCallback;
    public Combiner`2(CombineOperator type, Action`1<IChangeSet`2<TObject, TKey>> updatedCallback);
    public IDisposable Subscribe(IObservable`1[] source);
    private void Update(Cache`2<TObject, TKey> cache, IChangeSet`2<TObject, TKey> updates);
    private IChangeSet`2<TObject, TKey> UpdateCombined(IChangeSet`2<TObject, TKey> updates);
    private bool MatchesConstraint(TKey key);
}
internal class DynamicData.Cache.Internal.DeferUntilLoaded`2 : object {
    private IObservable`1<IChangeSet`2<TObject, TKey>> _result;
    public DeferUntilLoaded`2(IObservableCache`2<TObject, TKey> source);
    public DeferUntilLoaded`2(IObservable`1<IChangeSet`2<TObject, TKey>> source);
    public IObservable`1<IChangeSet`2<TObject, TKey>> Run();
}
[ExtensionAttribute]
internal static class DynamicData.Cache.Internal.DictionaryExtensions : object {
    [ExtensionAttribute]
internal static IEnumerable`1<T> GetOrEmpty(IDictionary`2<TDictKey, IEnumerable`1<T>> dict, TDictKey key);
}
internal class DynamicData.Cache.Internal.DisposeMany`2 : object {
    private IObservable`1<IChangeSet`2<TObject, TKey>> _source;
    private Action`1<TObject> _removeAction;
    public DisposeMany`2(IObservable`1<IChangeSet`2<TObject, TKey>> source, Action`1<TObject> removeAction);
    public IObservable`1<IChangeSet`2<TObject, TKey>> Run();
    private void RegisterForRemoval(IChangeSet`2<TObject, TKey> changes, Cache`2<TObject, TKey> cache);
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__3_0(IObserver`1<IChangeSet`2<TObject, TKey>> observer);
    [CompilerGeneratedAttribute]
private void <Run>b__3_3(TObject t);
    [CompilerGeneratedAttribute]
private void <RegisterForRemoval>b__4_0(Change`2<TObject, TKey> change);
    [CompilerGeneratedAttribute]
private void <RegisterForRemoval>b__4_1(TObject t);
}
internal class DynamicData.Cache.Internal.DistinctCalculator`3 : object {
    private IObservable`1<IChangeSet`2<TObject, TKey>> _source;
    private Func`2<TObject, TValue> _valueSelector;
    private IDictionary`2<TValue, int> _valueCounters;
    private IDictionary`2<TKey, int> _keyCounters;
    private IDictionary`2<TKey, TValue> _itemCache;
    public DistinctCalculator`3(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, TValue> valueSelector);
    public IObservable`1<DistinctChangeSet`1<TValue>> Run();
    private DistinctChangeSet`1<TValue> Calculate(IChangeSet`2<TObject, TKey> changes);
}
internal class DynamicData.Cache.Internal.DynamicCombiner`2 : object {
    private IObservableList`1<IObservable`1<IChangeSet`2<TObject, TKey>>> _source;
    private CombineOperator _type;
    public DynamicCombiner`2(IObservableList`1<IObservable`1<IChangeSet`2<TObject, TKey>>> source, CombineOperator type);
    public IObservable`1<IChangeSet`2<TObject, TKey>> Run();
    private void UpdateResultList(ChangeAwareCache`2<TObject, TKey> target, MergeContainer[] sourceLists, IChangeSet`2<TObject, TKey> changes);
    private void ProcessChanges(ChangeAwareCache`2<TObject, TKey> target, MergeContainer[] sourceLists, IEnumerable`1<KeyValuePair`2<TKey, TObject>> items);
    private void ProcessItem(ChangeAwareCache`2<TObject, TKey> target, MergeContainer[] sourceLists, TObject item, TKey key);
    private bool MatchesConstraint(MergeContainer[] sources, TKey key);
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__3_0(IObserver`1<IChangeSet`2<TObject, TKey>> observer);
}
internal class DynamicData.Cache.Internal.DynamicFilter`2 : object {
    private IObservable`1<IChangeSet`2<TObject, TKey>> _source;
    private IObservable`1<Func`2<TObject, bool>> _predicateChanged;
    private IObservable`1<Unit> _refilterObservable;
    public DynamicFilter`2(IObservable`1<IChangeSet`2<TObject, TKey>> source, IObservable`1<Func`2<TObject, bool>> predicateChanged, IObservable`1<Unit> refilterObservable);
    public IObservable`1<IChangeSet`2<TObject, TKey>> Run();
    private IObservable`1<Func`2<TObject, bool>> LatestPredicateObservable();
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__4_0(IObserver`1<IChangeSet`2<TObject, TKey>> observer);
    [CompilerGeneratedAttribute]
private IDisposable <LatestPredicateObservable>b__5_0(IObserver`1<Func`2<TObject, bool>> observable);
}
internal class DynamicData.Cache.Internal.EditDiff`2 : object {
    private ISourceCache`2<TObject, TKey> _source;
    private Func`3<TObject, TObject, bool> _areEqual;
    private IEqualityComparer`1<KeyValuePair`2<TKey, TObject>> _keyComparer;
    public EditDiff`2(ISourceCache`2<TObject, TKey> source, Func`3<TObject, TObject, bool> areEqual);
    public void Edit(IEnumerable`1<TObject> items);
}
[IsReadOnlyAttribute]
internal class DynamicData.Cache.Internal.ExpirableItem`2 : ValueType {
    [CompilerGeneratedAttribute]
private TObject <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private TKey <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <ExpireAt>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Index>k__BackingField;
    public TObject Value { get; }
    public TKey Key { get; }
    public DateTime ExpireAt { get; }
    public long Index { get; }
    public ExpirableItem`2(TObject value, TKey key, DateTime dateTime, long index);
    [CompilerGeneratedAttribute]
public TObject get_Value();
    [CompilerGeneratedAttribute]
public TKey get_Key();
    [CompilerGeneratedAttribute]
public DateTime get_ExpireAt();
    [CompilerGeneratedAttribute]
public long get_Index();
    public sealed virtual bool Equals(ExpirableItem`2<TObject, TKey> other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(ExpirableItem`2<TObject, TKey> left, ExpirableItem`2<TObject, TKey> right);
    public static bool op_Inequality(ExpirableItem`2<TObject, TKey> left, ExpirableItem`2<TObject, TKey> right);
    public virtual string ToString();
}
internal class DynamicData.Cache.Internal.FilteredIndexCalculator`2 : object {
    public IList`1<Change`2<TObject, TKey>> Calculate(IKeyValueCollection`2<TObject, TKey> currentItems, IKeyValueCollection`2<TObject, TKey> previousItems, IChangeSet`2<TObject, TKey> sourceUpdates);
    private static int GetInsertPositionLinear(IList`1<KeyValuePair`2<TKey, TObject>> list, KeyValuePair`2<TKey, TObject> item, IComparer`1<KeyValuePair`2<TKey, TObject>> comparer);
}
[ExtensionAttribute]
internal static class DynamicData.Cache.Internal.FilterEx : object {
    [ExtensionAttribute]
public static IChangeSet`2<TObject, TKey> RefreshFilteredFrom(ChangeAwareCache`2<TObject, TKey> filtered, Cache`2<TObject, TKey> allData, Func`2<TObject, bool> predicate);
    [ExtensionAttribute]
public static void FilterChanges(ChangeAwareCache`2<TObject, TKey> cache, IChangeSet`2<TObject, TKey> changes, Func`2<TObject, bool> predicate);
}
[ObsoleteAttribute("Use AutoRefresh(), followed by Filter() instead")]
internal class DynamicData.Cache.Internal.FilterOnProperty`3 : object {
    private IObservable`1<IChangeSet`2<TObject, TKey>> _source;
    private Expression`1<Func`2<TObject, TProperty>> _propertySelector;
    private Func`2<TObject, bool> _predicate;
    private Nullable`1<TimeSpan> _throttle;
    private IScheduler _scheduler;
    public FilterOnProperty`3(IObservable`1<IChangeSet`2<TObject, TKey>> source, Expression`1<Func`2<TObject, TProperty>> propertySelector, Func`2<TObject, bool> predicate, Nullable`1<TimeSpan> throttle, IScheduler scheduler);
    public IObservable`1<IChangeSet`2<TObject, TKey>> Run();
}
internal class DynamicData.Cache.Internal.FinallySafe`1 : object {
    private IObservable`1<T> _source;
    private Action _finallyAction;
    public FinallySafe`1(IObservable`1<T> source, Action finallyAction);
    public IObservable`1<T> Run();
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__3_0(IObserver`1<T> o);
}
internal class DynamicData.Cache.Internal.FullJoin`5 : object {
    private IObservable`1<IChangeSet`2<TLeft, TLeftKey>> _left;
    private IObservable`1<IChangeSet`2<TRight, TRightKey>> _right;
    private Func`2<TRight, TLeftKey> _rightKeySelector;
    private Func`4<TLeftKey, Optional`1<TLeft>, Optional`1<TRight>, TDestination> _resultSelector;
    public FullJoin`5(IObservable`1<IChangeSet`2<TLeft, TLeftKey>> left, IObservable`1<IChangeSet`2<TRight, TRightKey>> right, Func`2<TRight, TLeftKey> rightKeySelector, Func`4<TLeftKey, Optional`1<TLeft>, Optional`1<TRight>, TDestination> resultSelector);
    public IObservable`1<IChangeSet`2<TDestination, TLeftKey>> Run();
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__5_0(IObserver`1<IChangeSet`2<TDestination, TLeftKey>> observer);
}
internal class DynamicData.Cache.Internal.FullJoinMany`5 : object {
    private IObservable`1<IChangeSet`2<TLeft, TLeftKey>> _left;
    private IObservable`1<IChangeSet`2<TRight, TRightKey>> _right;
    private Func`2<TRight, TLeftKey> _rightKeySelector;
    private Func`4<TLeftKey, Optional`1<TLeft>, IGrouping`3<TRight, TRightKey, TLeftKey>, TDestination> _resultSelector;
    public FullJoinMany`5(IObservable`1<IChangeSet`2<TLeft, TLeftKey>> left, IObservable`1<IChangeSet`2<TRight, TRightKey>> right, Func`2<TRight, TLeftKey> rightKeySelector, Func`4<TLeftKey, Optional`1<TLeft>, IGrouping`3<TRight, TRightKey, TLeftKey>, TDestination> resultSelector);
    public IObservable`1<IChangeSet`2<TDestination, TLeftKey>> Run();
}
internal class DynamicData.Cache.Internal.GroupOn`3 : object {
    private IObservable`1<IChangeSet`2<TObject, TKey>> _source;
    private Func`2<TObject, TGroupKey> _groupSelectorKey;
    private IObservable`1<Unit> _regrouper;
    public GroupOn`3(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, TGroupKey> groupSelectorKey, IObservable`1<Unit> regrouper);
    public IObservable`1<IGroupChangeSet`3<TObject, TKey, TGroupKey>> Run();
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__4_0(IObserver`1<IGroupChangeSet`3<TObject, TKey, TGroupKey>> observer);
}
internal class DynamicData.Cache.Internal.GroupOnImmutable`3 : object {
    private IObservable`1<IChangeSet`2<TObject, TKey>> _source;
    private Func`2<TObject, TGroupKey> _groupSelectorKey;
    private IObservable`1<Unit> _regrouper;
    public GroupOnImmutable`3(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, TGroupKey> groupSelectorKey, IObservable`1<Unit> regrouper);
    public IObservable`1<IImmutableGroupChangeSet`3<TObject, TKey, TGroupKey>> Run();
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__4_0(IObserver`1<IImmutableGroupChangeSet`3<TObject, TKey, TGroupKey>> observer);
}
internal class DynamicData.Cache.Internal.GroupOnProperty`3 : object {
    private IObservable`1<IChangeSet`2<TObject, TKey>> _source;
    private Expression`1<Func`2<TObject, TGroup>> _propertySelector;
    private Nullable`1<TimeSpan> _throttle;
    private IScheduler _scheduler;
    private Func`2<TObject, TGroup> _groupSelector;
    public GroupOnProperty`3(IObservable`1<IChangeSet`2<TObject, TKey>> source, Expression`1<Func`2<TObject, TGroup>> groupSelectorKey, Nullable`1<TimeSpan> throttle, IScheduler scheduler);
    public IObservable`1<IGroupChangeSet`3<TObject, TKey, TGroup>> Run();
    [CompilerGeneratedAttribute]
private IObservable`1<IGroupChangeSet`3<TObject, TKey, TGroup>> <Run>b__6_0(IObservable`1<IChangeSet`2<TObject, TKey>> shared);
}
internal class DynamicData.Cache.Internal.GroupOnPropertyWithImmutableState`3 : object {
    private IObservable`1<IChangeSet`2<TObject, TKey>> _source;
    private Expression`1<Func`2<TObject, TGroup>> _propertySelector;
    private Nullable`1<TimeSpan> _throttle;
    private IScheduler _scheduler;
    private Func`2<TObject, TGroup> _groupSelector;
    public GroupOnPropertyWithImmutableState`3(IObservable`1<IChangeSet`2<TObject, TKey>> source, Expression`1<Func`2<TObject, TGroup>> groupSelectorKey, Nullable`1<TimeSpan> throttle, IScheduler scheduler);
    public IObservable`1<IImmutableGroupChangeSet`3<TObject, TKey, TGroup>> Run();
    [CompilerGeneratedAttribute]
private IObservable`1<IImmutableGroupChangeSet`3<TObject, TKey, TGroup>> <Run>b__6_0(IObservable`1<IChangeSet`2<TObject, TKey>> shared);
}
internal interface DynamicData.Cache.Internal.IFilter`2 {
    public Func`2<TObject, bool> Filter { get; }
    public abstract virtual Func`2<TObject, bool> get_Filter();
    public abstract virtual IChangeSet`2<TObject, TKey> Refresh(IEnumerable`1<KeyValuePair`2<TKey, TObject>> items);
    public abstract virtual IChangeSet`2<TObject, TKey> Update(IChangeSet`2<TObject, TKey> updates);
}
internal interface DynamicData.Cache.Internal.IKeySelector`2 {
    public abstract virtual TKey GetKey(TObject item);
}
internal class DynamicData.Cache.Internal.ImmutableGroup`3 : object {
    private ICache`2<TObject, TKey> _cache;
    [CompilerGeneratedAttribute]
private TGroupKey <Key>k__BackingField;
    public TGroupKey Key { get; }
    public int Count { get; }
    public IEnumerable`1<TObject> Items { get; }
    public IEnumerable`1<KeyValuePair`2<TKey, TObject>> KeyValues { get; }
    public IEnumerable`1<TKey> Keys { get; }
    internal ImmutableGroup`3(TGroupKey key, ICache`2<TObject, TKey> cache);
    [CompilerGeneratedAttribute]
public sealed virtual TGroupKey get_Key();
    public sealed virtual int get_Count();
    public sealed virtual IEnumerable`1<TObject> get_Items();
    public sealed virtual IEnumerable`1<KeyValuePair`2<TKey, TObject>> get_KeyValues();
    public sealed virtual IEnumerable`1<TKey> get_Keys();
    public sealed virtual Optional`1<TObject> Lookup(TKey key);
    public sealed virtual bool Equals(ImmutableGroup`3<TObject, TKey, TGroupKey> other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(ImmutableGroup`3<TObject, TKey, TGroupKey> left, ImmutableGroup`3<TObject, TKey, TGroupKey> right);
    public static bool op_Inequality(ImmutableGroup`3<TObject, TKey, TGroupKey> left, ImmutableGroup`3<TObject, TKey, TGroupKey> right);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
private void <.ctor>b__4_0(KeyValuePair`2<TKey, TObject> kvp);
}
internal class DynamicData.Cache.Internal.ImmutableGroupChangeSet`3 : ChangeSet`2<IGrouping`3<TObject, TKey, TGroupKey>, TGroupKey> {
    public static IImmutableGroupChangeSet`3<TObject, TKey, TGroupKey> Empty;
    public ImmutableGroupChangeSet`3(IEnumerable`1<Change`2<IGrouping`3<TObject, TKey, TGroupKey>, TGroupKey>> items);
    private static ImmutableGroupChangeSet`3();
    private sealed virtual override int DynamicData.IChangeSet.get_Capacity();
    private sealed virtual override void DynamicData.IChangeSet.set_Capacity(int value);
}
internal static class DynamicData.Cache.Internal.IndexAndNode : object {
    public static IndexAndNode`1<TNodeValue> Create(int index, LinkedListNode`1<TNodeValue> value);
}
internal class DynamicData.Cache.Internal.IndexAndNode`1 : object {
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private LinkedListNode`1<TNodeValue> <Node>k__BackingField;
    public int Index { get; }
    public LinkedListNode`1<TNodeValue> Node { get; }
    public IndexAndNode`1(int index, LinkedListNode`1<TNodeValue> node);
    [CompilerGeneratedAttribute]
public int get_Index();
    [CompilerGeneratedAttribute]
public LinkedListNode`1<TNodeValue> get_Node();
}
internal class DynamicData.Cache.Internal.IndexCalculator`2 : object {
    private KeyValueComparer`2<TObject, TKey> _comparer;
    private List`1<KeyValuePair`2<TKey, TObject>> _list;
    private SortOptimisations _optimisations;
    public IComparer`1<KeyValuePair`2<TKey, TObject>> Comparer { get; }
    public List`1<KeyValuePair`2<TKey, TObject>> List { get; }
    public IndexCalculator`2(KeyValueComparer`2<TObject, TKey> comparer, SortOptimisations optimisations);
    public IChangeSet`2<TObject, TKey> Load(ChangeAwareCache`2<TObject, TKey> cache);
    public void Reset(ChangeAwareCache`2<TObject, TKey> cache);
    public IChangeSet`2<TObject, TKey> ChangeComparer(KeyValueComparer`2<TObject, TKey> comparer);
    public IChangeSet`2<TObject, TKey> Reorder();
    public IChangeSet`2<TObject, TKey> Calculate(IChangeSet`2<TObject, TKey> changes);
    public IComparer`1<KeyValuePair`2<TKey, TObject>> get_Comparer();
    public List`1<KeyValuePair`2<TKey, TObject>> get_List();
    private int GetCurrentPosition(KeyValuePair`2<TKey, TObject> item);
    private int GetInsertPositionLinear(IList`1<KeyValuePair`2<TKey, TObject>> list, KeyValuePair`2<TKey, TObject> item);
    private int GetInsertPositionBinary(KeyValuePair`2<TKey, TObject> item);
}
internal class DynamicData.Cache.Internal.InnerJoin`5 : object {
    private IObservable`1<IChangeSet`2<TLeft, TLeftKey>> _left;
    private IObservable`1<IChangeSet`2<TRight, TRightKey>> _right;
    private Func`2<TRight, TLeftKey> _rightKeySelector;
    private Func`4<TLeftKey, TLeft, TRight, TDestination> _resultSelector;
    public InnerJoin`5(IObservable`1<IChangeSet`2<TLeft, TLeftKey>> left, IObservable`1<IChangeSet`2<TRight, TRightKey>> right, Func`2<TRight, TLeftKey> rightKeySelector, Func`4<TLeftKey, TLeft, TRight, TDestination> resultSelector);
    public IObservable`1<IChangeSet`2<TDestination, TLeftKey>> Run();
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__5_0(IObserver`1<IChangeSet`2<TDestination, TLeftKey>> observer);
}
internal class DynamicData.Cache.Internal.InnerJoinMany`5 : object {
    private IObservable`1<IChangeSet`2<TLeft, TLeftKey>> _left;
    private IObservable`1<IChangeSet`2<TRight, TRightKey>> _right;
    private Func`2<TRight, TLeftKey> _rightKeySelector;
    private Func`4<TLeftKey, TLeft, IGrouping`3<TRight, TRightKey, TLeftKey>, TDestination> _resultSelector;
    public InnerJoinMany`5(IObservable`1<IChangeSet`2<TLeft, TLeftKey>> left, IObservable`1<IChangeSet`2<TRight, TRightKey>> right, Func`2<TRight, TLeftKey> rightKeySelector, Func`4<TLeftKey, TLeft, IGrouping`3<TRight, TRightKey, TLeftKey>, TDestination> resultSelector);
    public IObservable`1<IChangeSet`2<TDestination, TLeftKey>> Run();
}
internal class DynamicData.Cache.Internal.KeyComparer`2 : object {
    public sealed virtual bool Equals(KeyValuePair`2<TKey, TObject> x, KeyValuePair`2<TKey, TObject> y);
    public sealed virtual int GetHashCode(KeyValuePair`2<TKey, TObject> obj);
}
internal class DynamicData.Cache.Internal.KeySelector`2 : object {
    private Func`2<TObject, TKey> _keySelector;
    public Type Type { get; }
    public KeySelector`2(Func`2<TObject, TKey> keySelector);
    public Type get_Type();
    public sealed virtual TKey GetKey(TObject item);
}
public class DynamicData.Cache.Internal.KeySelectorException : Exception {
    public KeySelectorException(string message);
    public KeySelectorException(string message, Exception innerException);
    protected KeySelectorException(SerializationInfo serializationInfo, StreamingContext streamingContext);
}
[DefaultMemberAttribute("Item")]
internal class DynamicData.Cache.Internal.KeyValueCollection`2 : object {
    private IReadOnlyCollection`1<KeyValuePair`2<TKey, TObject>> _items;
    [CompilerGeneratedAttribute]
private IComparer`1<KeyValuePair`2<TKey, TObject>> <Comparer>k__BackingField;
    [CompilerGeneratedAttribute]
private SortReason <SortReason>k__BackingField;
    [CompilerGeneratedAttribute]
private SortOptimisations <Optimisations>k__BackingField;
    public IComparer`1<KeyValuePair`2<TKey, TObject>> Comparer { get; }
    public int Count { get; }
    public KeyValuePair`2<TKey, TObject> Item { get; }
    public SortReason SortReason { get; }
    public SortOptimisations Optimisations { get; }
    public KeyValueCollection`2(IReadOnlyCollection`1<KeyValuePair`2<TKey, TObject>> items, IComparer`1<KeyValuePair`2<TKey, TObject>> comparer, SortReason sortReason, SortOptimisations optimisations);
    [CompilerGeneratedAttribute]
public sealed virtual IComparer`1<KeyValuePair`2<TKey, TObject>> get_Comparer();
    public sealed virtual int get_Count();
    public sealed virtual KeyValuePair`2<TKey, TObject> get_Item(int index);
    [CompilerGeneratedAttribute]
public sealed virtual SortReason get_SortReason();
    [CompilerGeneratedAttribute]
public sealed virtual SortOptimisations get_Optimisations();
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TObject>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class DynamicData.Cache.Internal.KeyValueComparer`2 : object {
    private IComparer`1<TObject> _comparer;
    public KeyValueComparer`2(IComparer`1<TObject> comparer);
    public sealed virtual int Compare(KeyValuePair`2<TKey, TObject> x, KeyValuePair`2<TKey, TObject> y);
}
internal class DynamicData.Cache.Internal.LeftJoin`5 : object {
    private IObservable`1<IChangeSet`2<TLeft, TLeftKey>> _left;
    private IObservable`1<IChangeSet`2<TRight, TRightKey>> _right;
    private Func`2<TRight, TLeftKey> _rightKeySelector;
    private Func`4<TLeftKey, TLeft, Optional`1<TRight>, TDestination> _resultSelector;
    public LeftJoin`5(IObservable`1<IChangeSet`2<TLeft, TLeftKey>> left, IObservable`1<IChangeSet`2<TRight, TRightKey>> right, Func`2<TRight, TLeftKey> rightKeySelector, Func`4<TLeftKey, TLeft, Optional`1<TRight>, TDestination> resultSelector);
    public IObservable`1<IChangeSet`2<TDestination, TLeftKey>> Run();
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__5_0(IObserver`1<IChangeSet`2<TDestination, TLeftKey>> observer);
}
internal class DynamicData.Cache.Internal.LeftJoinMany`5 : object {
    private IObservable`1<IChangeSet`2<TLeft, TLeftKey>> _left;
    private IObservable`1<IChangeSet`2<TRight, TRightKey>> _right;
    private Func`2<TRight, TLeftKey> _rightKeySelector;
    private Func`4<TLeftKey, TLeft, IGrouping`3<TRight, TRightKey, TLeftKey>, TDestination> _resultSelector;
    public LeftJoinMany`5(IObservable`1<IChangeSet`2<TLeft, TLeftKey>> left, IObservable`1<IChangeSet`2<TRight, TRightKey>> right, Func`2<TRight, TLeftKey> rightKeySelector, Func`4<TLeftKey, TLeft, IGrouping`3<TRight, TRightKey, TLeftKey>, TDestination> resultSelector);
    public IObservable`1<IChangeSet`2<TDestination, TLeftKey>> Run();
}
public class DynamicData.Cache.Internal.LockFreeObservableCache`2 : object {
    private ChangeAwareCache`2<TObject, TKey> _innerCache;
    private ICacheUpdater`2<TObject, TKey> _updater;
    private ISubject`1<IChangeSet`2<TObject, TKey>> _changes;
    private ISubject`1<IChangeSet`2<TObject, TKey>> _changesPreview;
    private ISubject`1<int> _countChanged;
    private IDisposable _cleanUp;
    private bool _isDisposed;
    public IObservable`1<int> CountChanged { get; }
    public IEnumerable`1<TKey> Keys { get; }
    public IEnumerable`1<KeyValuePair`2<TKey, TObject>> KeyValues { get; }
    public IEnumerable`1<TObject> Items { get; }
    public int Count { get; }
    public LockFreeObservableCache`2(IObservable`1<IChangeSet`2<TObject, TKey>> source);
    public sealed virtual IObservable`1<IChangeSet`2<TObject, TKey>> Connect(Func`2<TObject, bool> predicate);
    public sealed virtual IObservable`1<IChangeSet`2<TObject, TKey>> Preview(Func`2<TObject, bool> predicate);
    public sealed virtual IObservable`1<Change`2<TObject, TKey>> Watch(TKey key);
    public void Edit(Action`1<ICacheUpdater`2<TObject, TKey>> editAction);
    public sealed virtual IObservable`1<int> get_CountChanged();
    public sealed virtual Optional`1<TObject> Lookup(TKey key);
    public sealed virtual IEnumerable`1<TKey> get_Keys();
    public sealed virtual IEnumerable`1<KeyValuePair`2<TKey, TObject>> get_KeyValues();
    public sealed virtual IEnumerable`1<TObject> get_Items();
    public sealed virtual int get_Count();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool isDisposing);
    [CompilerGeneratedAttribute]
private ChangeSet`2<TObject, TKey> <.ctor>b__7_0(IChangeSet`2<TObject, TKey> changes);
    [CompilerGeneratedAttribute]
private void <.ctor>b__8_0();
}
internal class DynamicData.Cache.Internal.ManagedGroup`3 : object {
    private IntermediateCache`2<TObject, TKey> _cache;
    [CompilerGeneratedAttribute]
private TGroupKey <Key>k__BackingField;
    internal int Count { get; }
    public TGroupKey Key { get; }
    public IObservableCache`2<TObject, TKey> Cache { get; }
    public ManagedGroup`3(TGroupKey groupKey);
    internal void Update(Action`1<ICacheUpdater`2<TObject, TKey>> updateAction);
    internal int get_Count();
    internal IChangeSet`2<TObject, TKey> GetInitialUpdates();
    [CompilerGeneratedAttribute]
public sealed virtual TGroupKey get_Key();
    public sealed virtual IObservableCache`2<TObject, TKey> get_Cache();
    private bool Equals(ManagedGroup`3<TObject, TKey, TGroupKey> other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual void Dispose();
    public virtual string ToString();
}
internal class DynamicData.Cache.Internal.MergeMany`3 : object {
    private IObservable`1<IChangeSet`2<TObject, TKey>> _source;
    private Func`3<TObject, TKey, IObservable`1<TDestination>> _observableSelector;
    public MergeMany`3(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`3<TObject, TKey, IObservable`1<TDestination>> observableSelector);
    public MergeMany`3(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, IObservable`1<TDestination>> observableSelector);
    public IObservable`1<TDestination> Run();
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__4_0(IObserver`1<TDestination> observer);
}
internal class DynamicData.Cache.Internal.MergeManyItems`3 : object {
    private IObservable`1<IChangeSet`2<TObject, TKey>> _source;
    private Func`3<TObject, TKey, IObservable`1<TDestination>> _observableSelector;
    public MergeManyItems`3(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`3<TObject, TKey, IObservable`1<TDestination>> observableSelector);
    public MergeManyItems`3(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, IObservable`1<TDestination>> observableSelector);
    public IObservable`1<ItemWithValue`2<TObject, TDestination>> Run();
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__4_0(IObserver`1<ItemWithValue`2<TObject, TDestination>> observer);
}
internal class DynamicData.Cache.Internal.ObservableWithValue`2 : object {
    private Optional`1<TValue> _latestValue;
    [CompilerGeneratedAttribute]
private TObject <Item>k__BackingField;
    [CompilerGeneratedAttribute]
private IObservable`1<TValue> <Observable>k__BackingField;
    public TObject Item { get; }
    public Optional`1<TValue> LatestValue { get; }
    public IObservable`1<TValue> Observable { get; }
    public ObservableWithValue`2(TObject item, IObservable`1<TValue> source);
    [CompilerGeneratedAttribute]
public TObject get_Item();
    public Optional`1<TValue> get_LatestValue();
    [CompilerGeneratedAttribute]
public IObservable`1<TValue> get_Observable();
    [CompilerGeneratedAttribute]
private void <.ctor>b__1_0(TValue value);
}
internal class DynamicData.Cache.Internal.Page`2 : object {
    private IObservable`1<ISortedChangeSet`2<TObject, TKey>> _source;
    private IObservable`1<IPageRequest> _pageRequests;
    public Page`2(IObservable`1<ISortedChangeSet`2<TObject, TKey>> source, IObservable`1<IPageRequest> pageRequests);
    public IObservable`1<IPagedChangeSet`2<TObject, TKey>> Run();
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__3_0(IObserver`1<IPagedChangeSet`2<TObject, TKey>> observer);
}
internal class DynamicData.Cache.Internal.QueryWhenChanged`3 : object {
    private IObservable`1<IChangeSet`2<TObject, TKey>> _source;
    private Func`2<TObject, IObservable`1<TValue>> _itemChangedTrigger;
    public QueryWhenChanged`3(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, IObservable`1<TValue>> itemChangedTrigger);
    public IObservable`1<IQuery`2<TObject, TKey>> Run();
    [CompilerGeneratedAttribute]
private IObservable`1<AnonymousQuery`2<TObject, TKey>> <Run>b__3_2(IObservable`1<IChangeSet`2<TObject, TKey>> shared);
}
internal class DynamicData.Cache.Internal.ReaderWriter`2 : object {
    private Func`2<TObject, TKey> _keySelector;
    private Dictionary`2<TKey, TObject> _data;
    private CacheUpdater`2<TObject, TKey> _activeUpdater;
    private object _locker;
    public TKey[] Keys { get; }
    public KeyValuePair`2[] KeyValues { get; }
    public TObject[] Items { get; }
    public int Count { get; }
    public ReaderWriter`2(Func`2<TObject, TKey> keySelector);
    public ChangeSet`2<TObject, TKey> Write(IChangeSet`2<TObject, TKey> changes, Action`1<ChangeSet`2<TObject, TKey>> previewHandler, bool collectChanges);
    public ChangeSet`2<TObject, TKey> Write(Action`1<ICacheUpdater`2<TObject, TKey>> updateAction, Action`1<ChangeSet`2<TObject, TKey>> previewHandler, bool collectChanges);
    public ChangeSet`2<TObject, TKey> Write(Action`1<ISourceUpdater`2<TObject, TKey>> updateAction, Action`1<ChangeSet`2<TObject, TKey>> previewHandler, bool collectChanges);
    private ChangeSet`2<TObject, TKey> DoUpdate(Action`1<CacheUpdater`2<TObject, TKey>> updateAction, Action`1<ChangeSet`2<TObject, TKey>> previewHandler, bool collectChanges);
    internal void WriteNested(Action`1<ISourceUpdater`2<TObject, TKey>> updateAction);
    public ChangeSet`2<TObject, TKey> GetInitialUpdates(Func`2<TObject, bool> filter);
    public TKey[] get_Keys();
    public KeyValuePair`2[] get_KeyValues();
    public TObject[] get_Items();
    public Optional`1<TObject> Lookup(TKey key);
    public int get_Count();
}
internal class DynamicData.Cache.Internal.RefCount`2 : object {
    private IObservable`1<IChangeSet`2<TObject, TKey>> _source;
    private object _locker;
    private int _refCount;
    private IObservableCache`2<TObject, TKey> _cache;
    public RefCount`2(IObservable`1<IChangeSet`2<TObject, TKey>> source);
    public IObservable`1<IChangeSet`2<TObject, TKey>> Run();
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__5_0(IObserver`1<IChangeSet`2<TObject, TKey>> observer);
}
internal class DynamicData.Cache.Internal.RemoveKeyEnumerator`2 : object {
    private IChangeSet`2<TObject, TKey> _source;
    private IExtendedList`1<TObject> _list;
    public RemoveKeyEnumerator`2(IChangeSet`2<TObject, TKey> source, IExtendedList`1<TObject> list);
    [IteratorStateMachineAttribute("DynamicData.Cache.Internal.RemoveKeyEnumerator`2/<GetEnumerator>d__3")]
public sealed virtual IEnumerator`1<Change`1<TObject>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class DynamicData.Cache.Internal.RightJoin`5 : object {
    private IObservable`1<IChangeSet`2<TLeft, TLeftKey>> _left;
    private IObservable`1<IChangeSet`2<TRight, TRightKey>> _right;
    private Func`2<TRight, TLeftKey> _rightKeySelector;
    private Func`4<TLeftKey, Optional`1<TLeft>, TRight, TDestination> _resultSelector;
    public RightJoin`5(IObservable`1<IChangeSet`2<TLeft, TLeftKey>> left, IObservable`1<IChangeSet`2<TRight, TRightKey>> right, Func`2<TRight, TLeftKey> rightKeySelector, Func`4<TLeftKey, Optional`1<TLeft>, TRight, TDestination> resultSelector);
    public IObservable`1<IChangeSet`2<TDestination, TLeftKey>> Run();
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__5_0(IObserver`1<IChangeSet`2<TDestination, TLeftKey>> observer);
}
internal class DynamicData.Cache.Internal.RightJoinMany`5 : object {
    private IObservable`1<IChangeSet`2<TLeft, TLeftKey>> _left;
    private IObservable`1<IChangeSet`2<TRight, TRightKey>> _right;
    private Func`2<TRight, TLeftKey> _rightKeySelector;
    private Func`4<TLeftKey, Optional`1<TLeft>, IGrouping`3<TRight, TRightKey, TLeftKey>, TDestination> _resultSelector;
    public RightJoinMany`5(IObservable`1<IChangeSet`2<TLeft, TLeftKey>> left, IObservable`1<IChangeSet`2<TRight, TRightKey>> right, Func`2<TRight, TLeftKey> rightKeySelector, Func`4<TLeftKey, Optional`1<TLeft>, IGrouping`3<TRight, TRightKey, TLeftKey>, TDestination> resultSelector);
    public IObservable`1<IChangeSet`2<TDestination, TLeftKey>> Run();
    [CompilerGeneratedAttribute]
private TDestination <Run>b__5_1(TLeftKey a, Optional`1<TLeft> b, IGrouping`3<TRight, TRightKey, TLeftKey> c);
}
internal class DynamicData.Cache.Internal.SizeExpirer`2 : object {
    private IObservable`1<IChangeSet`2<TObject, TKey>> _source;
    private int _size;
    public SizeExpirer`2(IObservable`1<IChangeSet`2<TObject, TKey>> source, int size);
    public IObservable`1<IChangeSet`2<TObject, TKey>> Run();
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__3_0(IObserver`1<IChangeSet`2<TObject, TKey>> observer);
}
internal class DynamicData.Cache.Internal.SizeLimiter`2 : object {
    private ChangeAwareCache`2<ExpirableItem`2<TObject, TKey>, TKey> _cache;
    private int _sizeLimit;
    public SizeLimiter`2(int size);
    public IChangeSet`2<TObject, TKey> Change(IChangeSet`2<ExpirableItem`2<TObject, TKey>, TKey> updates);
    public KeyValuePair`2[] CloneAndReturnExpiredOnly(IChangeSet`2<ExpirableItem`2<TObject, TKey>, TKey> updates);
}
internal class DynamicData.Cache.Internal.Sort`2 : object {
    private IObservable`1<IChangeSet`2<TObject, TKey>> _source;
    private IComparer`1<TObject> _comparer;
    private SortOptimisations _sortOptimisations;
    private IObservable`1<IComparer`1<TObject>> _comparerChangedObservable;
    private IObservable`1<Unit> _resorter;
    private int _resetThreshold;
    public Sort`2(IObservable`1<IChangeSet`2<TObject, TKey>> source, IComparer`1<TObject> comparer, SortOptimisations sortOptimisations, IObservable`1<IComparer`1<TObject>> comparerChangedObservable, IObservable`1<Unit> resorter, int resetThreshold);
    public IObservable`1<ISortedChangeSet`2<TObject, TKey>> Run();
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__7_0(IObserver`1<ISortedChangeSet`2<TObject, TKey>> observer);
}
internal class DynamicData.Cache.Internal.SpecifiedGrouper`3 : object {
    private IObservable`1<IChangeSet`2<TObject, TKey>> _source;
    private Func`2<TObject, TGroupKey> _groupSelector;
    private IObservable`1<IDistinctChangeSet`1<TGroupKey>> _resultGroupSource;
    public SpecifiedGrouper`3(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, TGroupKey> groupSelector, IObservable`1<IDistinctChangeSet`1<TGroupKey>> resultGroupSource);
    public IObservable`1<IGroupChangeSet`3<TObject, TKey, TGroupKey>> Run();
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__4_0(IObserver`1<IGroupChangeSet`3<TObject, TKey, TGroupKey>> observer);
}
internal class DynamicData.Cache.Internal.StaticFilter`2 : object {
    private IObservable`1<IChangeSet`2<TObject, TKey>> _source;
    private Func`2<TObject, bool> _filter;
    public StaticFilter`2(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, bool> filter);
    public IObservable`1<IChangeSet`2<TObject, TKey>> Run();
    [CompilerGeneratedAttribute]
private ChangeAwareCache`2<TObject, TKey> <Run>b__3_0(ChangeAwareCache`2<TObject, TKey> cache, IChangeSet`2<TObject, TKey> changes);
}
internal class DynamicData.Cache.Internal.StatusMonitor`1 : object {
    private IObservable`1<T> _source;
    public StatusMonitor`1(IObservable`1<T> source);
    public IObservable`1<ConnectionStatus> Run();
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__2_0(IObserver`1<ConnectionStatus> observer);
}
internal class DynamicData.Cache.Internal.SubscribeMany`2 : object {
    private IObservable`1<IChangeSet`2<TObject, TKey>> _source;
    private Func`3<TObject, TKey, IDisposable> _subscriptionFactory;
    public SubscribeMany`2(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, IDisposable> subscriptionFactory);
    public SubscribeMany`2(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`3<TObject, TKey, IDisposable> subscriptionFactory);
    public IObservable`1<IChangeSet`2<TObject, TKey>> Run();
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__4_0(IObserver`1<IChangeSet`2<TObject, TKey>> observer);
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__4_1(TObject t, TKey k);
}
internal class DynamicData.Cache.Internal.Switch`2 : object {
    private IObservable`1<IObservable`1<IChangeSet`2<TObject, TKey>>> _sources;
    public Switch`2(IObservable`1<IObservable`1<IChangeSet`2<TObject, TKey>>> sources);
    public IObservable`1<IChangeSet`2<TObject, TKey>> Run();
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__2_0(IObserver`1<IChangeSet`2<TObject, TKey>> observer);
}
internal class DynamicData.Cache.Internal.TimeExpirer`2 : object {
    private IObservable`1<IChangeSet`2<TObject, TKey>> _source;
    private Func`2<TObject, Nullable`1<TimeSpan>> _timeSelector;
    private Nullable`1<TimeSpan> _interval;
    private IScheduler _scheduler;
    public TimeExpirer`2(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, Nullable`1<TimeSpan>> timeSelector, Nullable`1<TimeSpan> interval, IScheduler scheduler);
    public IObservable`1<IEnumerable`1<KeyValuePair`2<TKey, TObject>>> ForExpiry();
    public IObservable`1<IChangeSet`2<TObject, TKey>> ExpireAfter();
    [CompilerGeneratedAttribute]
private IDisposable <ForExpiry>b__5_0(IObserver`1<IEnumerable`1<KeyValuePair`2<TKey, TObject>>> observer);
    [CompilerGeneratedAttribute]
private bool <ForExpiry>b__5_7(KeyValuePair`2<TKey, ExpirableItem`2<TObject, TKey>> kv);
    [CompilerGeneratedAttribute]
private IDisposable <ExpireAfter>b__6_0(IObserver`1<IChangeSet`2<TObject, TKey>> observer);
}
internal class DynamicData.Cache.Internal.ToObservableChangeSet`2 : object {
    private IObservable`1<IEnumerable`1<TObject>> _source;
    private Func`2<TObject, TKey> _keySelector;
    private Func`2<TObject, Nullable`1<TimeSpan>> _expireAfter;
    private int _limitSizeTo;
    private IScheduler _scheduler;
    private bool _singleValueSource;
    public ToObservableChangeSet`2(IObservable`1<TObject> source, Func`2<TObject, TKey> keySelector, Func`2<TObject, Nullable`1<TimeSpan>> expireAfter, int limitSizeTo, IScheduler scheduler);
    public ToObservableChangeSet`2(IObservable`1<IEnumerable`1<TObject>> source, Func`2<TObject, TKey> keySelector, Func`2<TObject, Nullable`1<TimeSpan>> expireAfter, int limitSizeTo, IScheduler scheduler, bool singleValueSource);
    public IObservable`1<IChangeSet`2<TObject, TKey>> Run();
    private ExpirableItem`2<TObject, TKey> CreateExpirableItem(TObject item, TKey key, Int64& orderItemWasAdded);
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__8_0(IObserver`1<IChangeSet`2<TObject, TKey>> observer);
    [CompilerGeneratedAttribute]
private ChangeAwareCache`2<TObject, TKey> <Run>b__8_1(ChangeAwareCache`2<TObject, TKey> state, IEnumerable`1<TObject> latest);
    [CompilerGeneratedAttribute]
private IObservable`1<ExpirableItem`2<TObject, TKey>> <Run>b__8_6(ExpirableItem`2<TObject, TKey> grouping);
}
internal class DynamicData.Cache.Internal.Transform`3 : object {
    private IObservable`1<IChangeSet`2<TSource, TKey>> _source;
    private Func`4<TSource, Optional`1<TSource>, TKey, TDestination> _transformFactory;
    private Action`1<Error`2<TSource, TKey>> _exceptionCallback;
    private bool _transformOnRefresh;
    public Transform`3(IObservable`1<IChangeSet`2<TSource, TKey>> source, Func`4<TSource, Optional`1<TSource>, TKey, TDestination> transformFactory, Action`1<Error`2<TSource, TKey>> exceptionCallback, bool transformOnRefresh);
    public IObservable`1<IChangeSet`2<TDestination, TKey>> Run();
    [CompilerGeneratedAttribute]
private ChangeAwareCache`2<TDestination, TKey> <Run>b__5_0(ChangeAwareCache`2<TDestination, TKey> cache, IChangeSet`2<TSource, TKey> changes);
}
internal class DynamicData.Cache.Internal.TransformAsync`3 : object {
    private IObservable`1<IChangeSet`2<TSource, TKey>> _source;
    private Func`4<TSource, Optional`1<TSource>, TKey, Task`1<TDestination>> _transformFactory;
    private IObservable`1<Func`3<TSource, TKey, bool>> _forceTransform;
    private Action`1<Error`2<TSource, TKey>> _exceptionCallback;
    private int _maximumConcurrency;
    public TransformAsync`3(IObservable`1<IChangeSet`2<TSource, TKey>> source, Func`4<TSource, Optional`1<TSource>, TKey, Task`1<TDestination>> transformFactory, Action`1<Error`2<TSource, TKey>> exceptionCallback, int maximumConcurrency, IObservable`1<Func`3<TSource, TKey, bool>> forceTransform);
    public IObservable`1<IChangeSet`2<TDestination, TKey>> Run();
    [AsyncStateMachineAttribute("DynamicData.Cache.Internal.TransformAsync`3/<DoTransform>d__7")]
private Task`1<IChangeSet`2<TDestination, TKey>> DoTransform(ChangeAwareCache`2<TransformedItemContainer<TDestination, TSource, TKey>, TKey> cache, Func`3<TSource, TKey, bool> shouldTransform);
    [AsyncStateMachineAttribute("DynamicData.Cache.Internal.TransformAsync`3/<DoTransform>d__8")]
private Task`1<IChangeSet`2<TDestination, TKey>> DoTransform(ChangeAwareCache`2<TransformedItemContainer<TDestination, TSource, TKey>, TKey> cache, IChangeSet`2<TSource, TKey> changes);
    [AsyncStateMachineAttribute("DynamicData.Cache.Internal.TransformAsync`3/<Transform>d__9")]
private Task`1<TransformResult<TDestination, TSource, TKey>> Transform(Change`2<TSource, TKey> change);
    private IChangeSet`2<TDestination, TKey> ProcessUpdates(ChangeAwareCache`2<TransformedItemContainer<TDestination, TSource, TKey>, TKey> cache, TransformResult[] transformedItems);
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__6_0(IObserver`1<IChangeSet`2<TDestination, TKey>> observer);
    [CompilerGeneratedAttribute]
private void <ProcessUpdates>b__10_1(TransformResult<TDestination, TSource, TKey> t);
}
internal class DynamicData.Cache.Internal.TransformMany`4 : object {
    private IObservable`1<IChangeSet`2<TSource, TSourceKey>> _source;
    private Func`2<TSource, IObservable`1<IChangeSet`2<TDestination, TDestinationKey>>> _childChanges;
    private Func`2<TSource, IEnumerable`1<TDestination>> _manySelector;
    private Func`2<TDestination, TDestinationKey> _keySelector;
    public TransformMany`4(IObservable`1<IChangeSet`2<TSource, TSourceKey>> source, Func`2<TSource, ReadOnlyObservableCollection`1<TDestination>> manySelector, Func`2<TDestination, TDestinationKey> keySelector);
    public TransformMany`4(IObservable`1<IChangeSet`2<TSource, TSourceKey>> source, Func`2<TSource, ObservableCollection`1<TDestination>> manySelector, Func`2<TDestination, TDestinationKey> keySelector);
    public TransformMany`4(IObservable`1<IChangeSet`2<TSource, TSourceKey>> source, Func`2<TSource, IEnumerable`1<TDestination>> manySelector, Func`2<TDestination, TDestinationKey> keySelector, Func`2<TSource, IObservable`1<IChangeSet`2<TDestination, TDestinationKey>>> childChanges);
    public IObservable`1<IChangeSet`2<TDestination, TDestinationKey>> Run();
    private IObservable`1<IChangeSet`2<TDestination, TDestinationKey>> Create();
    private IObservable`1<IChangeSet`2<TDestination, TDestinationKey>> CreateWithChangeset();
    [CompilerGeneratedAttribute]
private ManyContainer<TDestination, TDestinationKey, TSource, TSourceKey> <Create>b__8_0(TSource t, TSourceKey key);
    [CompilerGeneratedAttribute]
private DestinationContainer<TDestination, TDestinationKey, TSource, TSourceKey> <Create>b__8_2(TDestination m);
    [CompilerGeneratedAttribute]
private IDisposable <CreateWithChangeset>b__9_0(IObserver`1<IChangeSet`2<TDestination, TDestinationKey>> observer);
    [CompilerGeneratedAttribute]
private ManyContainer<TDestination, TDestinationKey, TSource, TSourceKey> <CreateWithChangeset>b__9_1(TSource t, TSourceKey key);
    [CompilerGeneratedAttribute]
private DestinationContainer<TDestination, TDestinationKey, TSource, TSourceKey> <CreateWithChangeset>b__9_6(TDestination m);
}
internal class DynamicData.Cache.Internal.TransformWithForcedTransform`3 : object {
    private IObservable`1<IChangeSet`2<TSource, TKey>> _source;
    private Func`4<TSource, Optional`1<TSource>, TKey, TDestination> _transformFactory;
    private IObservable`1<Func`3<TSource, TKey, bool>> _forceTransform;
    private Action`1<Error`2<TSource, TKey>> _exceptionCallback;
    public TransformWithForcedTransform`3(IObservable`1<IChangeSet`2<TSource, TKey>> source, Func`4<TSource, Optional`1<TSource>, TKey, TDestination> transformFactory, IObservable`1<Func`3<TSource, TKey, bool>> forceTransform, Action`1<Error`2<TSource, TKey>> exceptionCallback);
    public IObservable`1<IChangeSet`2<TDestination, TKey>> Run();
    [IteratorStateMachineAttribute("DynamicData.Cache.Internal.TransformWithForcedTransform`3/<CaptureChanges>d__6")]
private static IEnumerable`1<Change`2<TSource, TKey>> CaptureChanges(Cache`2<TSource, TKey> cache, Func`3<TSource, TKey, bool> shouldTransform);
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__5_0(IObserver`1<IChangeSet`2<TDestination, TKey>> observer);
}
internal class DynamicData.Cache.Internal.TreeBuilder`2 : object {
    private IObservable`1<IChangeSet`2<TObject, TKey>> _source;
    private Func`2<TObject, TKey> _pivotOn;
    private IObservable`1<Func`2<Node`2<TObject, TKey>, bool>> _predicateChanged;
    private static Func`2<Node`2<TObject, TKey>, bool> DefaultPredicate;
    public TreeBuilder`2(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, TKey> pivotOn, IObservable`1<Func`2<Node`2<TObject, TKey>, bool>> predicateChanged);
    private static TreeBuilder`2();
    public IObservable`1<IChangeSet`2<Node`2<TObject, TKey>, TKey>> Run();
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__5_0(IObserver`1<IChangeSet`2<Node`2<TObject, TKey>, TKey>> observer);
    [CompilerGeneratedAttribute]
private TKey <Run>b__5_2(Node`2<TObject, TKey> x);
    [CompilerGeneratedAttribute]
private TKey <Run>b__5_9(Change`2<Node`2<TObject, TKey>, TKey> c);
}
internal class DynamicData.Cache.Internal.TrueFor`3 : object {
    private IObservable`1<IChangeSet`2<TObject, TKey>> _source;
    private Func`2<TObject, IObservable`1<TValue>> _observableSelector;
    private Func`2<IEnumerable`1<ObservableWithValue`2<TObject, TValue>>, bool> _collectionMatcher;
    public TrueFor`3(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, IObservable`1<TValue>> observableSelector, Func`2<IEnumerable`1<ObservableWithValue`2<TObject, TValue>>, bool> collectionMatcher);
    public IObservable`1<bool> Run();
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__4_0(IObserver`1<bool> observer);
    [CompilerGeneratedAttribute]
private ObservableWithValue`2<TObject, TValue> <Run>b__4_1(TObject t);
    [CompilerGeneratedAttribute]
private bool <Run>b__4_3(IReadOnlyCollection`1<ObservableWithValue`2<TObject, TValue>> items, TValue inline);
}
internal class DynamicData.Cache.Internal.Virtualise`2 : object {
    private IObservable`1<ISortedChangeSet`2<TObject, TKey>> _source;
    private IObservable`1<IVirtualRequest> _virtualRequests;
    public Virtualise`2(IObservable`1<ISortedChangeSet`2<TObject, TKey>> source, IObservable`1<IVirtualRequest> virtualRequests);
    public IObservable`1<IVirtualChangeSet`2<TObject, TKey>> Run();
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__3_0(IObserver`1<IVirtualChangeSet`2<TObject, TKey>> observer);
}
[ExtensionAttribute]
internal static class DynamicData.CacheChangeSetEx : object {
    [ExtensionAttribute]
public static ChangeSet`2<TObject, TKey> ToConcreteType(IChangeSet`2<TObject, TKey> changeset);
}
public class DynamicData.Change`1 : object {
    [CompilerGeneratedAttribute]
private ListChangeReason <Reason>k__BackingField;
    [CompilerGeneratedAttribute]
private ItemChange`1<T> <Item>k__BackingField;
    [CompilerGeneratedAttribute]
private RangeChange`1<T> <Range>k__BackingField;
    public ListChangeReason Reason { get; }
    public ItemChange`1<T> Item { get; }
    public RangeChange`1<T> Range { get; }
    public ChangeType Type { get; }
    public Change`1(ListChangeReason reason, T current, int index);
    public Change`1(ListChangeReason reason, IEnumerable`1<T> items, int index);
    public Change`1(T current, int currentIndex, int previousIndex);
    public Change`1(ListChangeReason reason, T current, Optional`1<T> previous, int currentIndex, int previousIndex);
    [CompilerGeneratedAttribute]
public ListChangeReason get_Reason();
    [CompilerGeneratedAttribute]
public ItemChange`1<T> get_Item();
    [CompilerGeneratedAttribute]
public RangeChange`1<T> get_Range();
    public ChangeType get_Type();
    public sealed virtual bool Equals(Change`1<T> other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(Change`1<T> left, Change`1<T> right);
    public static bool op_Inequality(Change`1<T> left, Change`1<T> right);
    public virtual string ToString();
}
[IsReadOnlyAttribute]
public class DynamicData.Change`2 : ValueType {
    [CompilerGeneratedAttribute]
private TKey <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private ChangeReason <Reason>k__BackingField;
    [CompilerGeneratedAttribute]
private TObject <Current>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CurrentIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private Optional`1<TObject> <Previous>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PreviousIndex>k__BackingField;
    public TKey Key { get; }
    public ChangeReason Reason { get; }
    public TObject Current { get; }
    public int CurrentIndex { get; }
    public Optional`1<TObject> Previous { get; }
    public int PreviousIndex { get; }
    public Change`2(ChangeReason reason, TKey key, TObject current, int index);
    public Change`2(TKey key, TObject current, int currentIndex, int previousIndex);
    public Change`2(ChangeReason reason, TKey key, TObject current, Optional`1<TObject> previous, int currentIndex, int previousIndex);
    [CompilerGeneratedAttribute]
public TKey get_Key();
    [CompilerGeneratedAttribute]
public ChangeReason get_Reason();
    [CompilerGeneratedAttribute]
public TObject get_Current();
    [CompilerGeneratedAttribute]
public int get_CurrentIndex();
    [CompilerGeneratedAttribute]
public Optional`1<TObject> get_Previous();
    [CompilerGeneratedAttribute]
public int get_PreviousIndex();
    public static bool op_Equality(Change`2<TObject, TKey> left, Change`2<TObject, TKey> right);
    public static bool op_Inequality(Change`2<TObject, TKey> left, Change`2<TObject, TKey> right);
    public sealed virtual bool Equals(Change`2<TObject, TKey> other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class DynamicData.ChangeAwareCache`2 : object {
    private ChangeSet`2<TObject, TKey> _changes;
    private Dictionary`2<TKey, TObject> _data;
    public int Count { get; }
    public IEnumerable`1<KeyValuePair`2<TKey, TObject>> KeyValues { get; }
    public IEnumerable`1<TObject> Items { get; }
    public IEnumerable`1<TKey> Keys { get; }
    public ChangeAwareCache`2(int capacity);
    public ChangeAwareCache`2(Dictionary`2<TKey, TObject> data);
    public sealed virtual int get_Count();
    public sealed virtual IEnumerable`1<KeyValuePair`2<TKey, TObject>> get_KeyValues();
    public sealed virtual IEnumerable`1<TObject> get_Items();
    public sealed virtual IEnumerable`1<TKey> get_Keys();
    public sealed virtual Optional`1<TObject> Lookup(TKey key);
    public void Add(TObject item, TKey key);
    public sealed virtual void AddOrUpdate(TObject item, TKey key);
    public sealed virtual void Remove(IEnumerable`1<TKey> keys);
    public sealed virtual void Remove(TKey key);
    public sealed virtual void Refresh(IEnumerable`1<TKey> keys);
    public sealed virtual void Refresh();
    public sealed virtual void Refresh(TKey key);
    public sealed virtual void Clear();
    public sealed virtual void Clone(IChangeSet`2<TObject, TKey> changes);
    private void EnsureInitialised(int capacity);
    public ChangeSet`2<TObject, TKey> CaptureChanges();
}
[DefaultMemberAttribute("Item")]
public class DynamicData.ChangeAwareList`1 : object {
    private object _lockObject;
    private List`1<T> _innerList;
    private ChangeSet`1<T> _changes;
    private Optional`1<Change`1<T>> Last { get; }
    public int Capacity { get; public set; }
    public int Count { get; }
    public T Item { get; public set; }
    public bool IsReadOnly { get; }
    public ChangeAwareList`1(int capacity);
    public ChangeAwareList`1(IEnumerable`1<T> items);
    public ChangeAwareList`1(ChangeAwareList`1<T> list, bool copyChanges);
    public IChangeSet`1<T> CaptureChanges();
    internal void ClearChanges();
    public sealed virtual void AddRange(IEnumerable`1<T> collection);
    public sealed virtual void InsertRange(IEnumerable`1<T> collection, int index);
    public sealed virtual void RemoveRange(int index, int count);
    public virtual void Clear();
    protected virtual void OnSetItem(int index, T newItem, T oldItem);
    protected virtual void OnInsertItems(int startIndex, IEnumerable`1<T> items);
    protected virtual void OnRemoveItems(int startIndex, IEnumerable`1<T> items);
    public void RefreshAt(int index);
    public void Refresh(T item, int index);
    public bool Refresh(T item);
    private Optional`1<Change`1<T>> get_Last();
    protected virtual void InsertItem(int index, T item);
    protected void RemoveItem(int index);
    protected virtual void RemoveItem(int index, T item);
    protected virtual void SetItem(int index, T item);
    public virtual void Move(T item, int destination);
    public virtual void Move(int original, int destination);
    public int get_Capacity();
    public void set_Capacity(int value);
    public sealed virtual int get_Count();
    public virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual int IndexOf(T item);
    public int IndexOf(T item, IEqualityComparer`1<T> equalityComparer);
    public sealed virtual void Insert(int index, T item);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual void Add(T item);
    public sealed virtual bool Remove(T item);
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual bool get_IsReadOnly();
}
internal class DynamicData.ChangeAwareListWithRefCounts`1 : ChangeAwareList`1<T> {
    private ReferenceCountTracker`1<T> _tracker;
    protected virtual void InsertItem(int index, T item);
    protected virtual void OnInsertItems(int startIndex, IEnumerable`1<T> items);
    protected virtual void RemoveItem(int index, T item);
    protected virtual void OnRemoveItems(int startIndex, IEnumerable`1<T> items);
    protected virtual void OnSetItem(int index, T newItem, T oldItem);
    public virtual bool Contains(T item);
    public virtual void Clear();
    [CompilerGeneratedAttribute]
private void <OnInsertItems>b__2_0(T t);
    [CompilerGeneratedAttribute]
private void <OnRemoveItems>b__4_0(T t);
}
public enum DynamicData.ChangeReason : Enum {
    public int value__;
    public static ChangeReason Add;
    public static ChangeReason Update;
    public static ChangeReason Remove;
    public static ChangeReason Refresh;
    public static ChangeReason Moved;
}
public class DynamicData.ChangeSet`1 : List`1<Change`1<T>> {
    public static IChangeSet`1<T> Empty;
    public int Adds { get; }
    public int Replaced { get; }
    public int Removes { get; }
    public int Refreshes { get; }
    public int Moves { get; }
    public int TotalChanges { get; }
    public ChangeSet`1(IEnumerable`1<Change`1<T>> items);
    private static ChangeSet`1();
    public sealed virtual int get_Adds();
    public sealed virtual int get_Replaced();
    public sealed virtual int get_Removes();
    public sealed virtual int get_Refreshes();
    public sealed virtual int get_Moves();
    public sealed virtual int get_TotalChanges();
    public virtual string ToString();
    private sealed virtual override int DynamicData.IChangeSet.get_Capacity();
    private sealed virtual override void DynamicData.IChangeSet.set_Capacity(int value);
}
public class DynamicData.ChangeSet`2 : List`1<Change`2<TObject, TKey>> {
    public static ChangeSet`2<TObject, TKey> Empty;
    public int Adds { get; }
    public int Updates { get; }
    public int Removes { get; }
    public int Refreshes { get; }
    public int Moves { get; }
    public ChangeSet`2(IEnumerable`1<Change`2<TObject, TKey>> collection);
    public ChangeSet`2(int capacity);
    private static ChangeSet`2();
    public sealed virtual int get_Adds();
    public sealed virtual int get_Updates();
    public sealed virtual int get_Removes();
    public sealed virtual int get_Refreshes();
    public sealed virtual int get_Moves();
    public virtual string ToString();
    private sealed virtual override int DynamicData.IChangeSet.get_Capacity();
    private sealed virtual override void DynamicData.IChangeSet.set_Capacity(int value);
}
[ExtensionAttribute]
public static class DynamicData.ChangeSetEx : object {
    [ExtensionAttribute]
public static IEnumerable`1<Change`1<T>> YieldWithoutIndex(IEnumerable`1<Change`1<T>> source);
    [ExtensionAttribute]
internal static IEnumerable`1<UnifiedChange`1<T>> Unified(IChangeSet`1<T> source);
    [ExtensionAttribute]
public static IEnumerable`1<ItemChange`1<T>> Flatten(IChangeSet`1<T> source);
    [ExtensionAttribute]
public static ChangeType GetChangeType(ListChangeReason source);
    [ExtensionAttribute]
public static IChangeSet`1<TDestination> Transform(IChangeSet`1<TSource> source, Func`2<TSource, TDestination> transformer);
}
public enum DynamicData.ChangeType : Enum {
    public int value__;
    public static ChangeType Item;
    public static ChangeType Range;
}
internal static class DynamicData.Constants : object {
    public static string EvaluateIsDead;
}
public class DynamicData.Diagnostics.ChangeStatistics : object {
    [CompilerGeneratedAttribute]
private int <Adds>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Updates>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Removes>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Refreshes>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Count>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Moves>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <LastUpdated>k__BackingField;
    public int Adds { get; }
    public int Updates { get; }
    public int Removes { get; }
    public int Refreshes { get; }
    public int Count { get; }
    public int Index { get; }
    public int Moves { get; }
    public DateTime LastUpdated { get; }
    public ChangeStatistics(int index, int adds, int updates, int removes, int refreshes, int moves, int count);
    [CompilerGeneratedAttribute]
public int get_Adds();
    [CompilerGeneratedAttribute]
public int get_Updates();
    [CompilerGeneratedAttribute]
public int get_Removes();
    [CompilerGeneratedAttribute]
public int get_Refreshes();
    [CompilerGeneratedAttribute]
public int get_Count();
    [CompilerGeneratedAttribute]
public int get_Index();
    [CompilerGeneratedAttribute]
public int get_Moves();
    [CompilerGeneratedAttribute]
public DateTime get_LastUpdated();
    public sealed virtual bool Equals(ChangeStatistics other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(ChangeStatistics left, ChangeStatistics right);
    public static bool op_Inequality(ChangeStatistics left, ChangeStatistics right);
    public virtual string ToString();
}
public class DynamicData.Diagnostics.ChangeSummary : object {
    private int _index;
    public static ChangeSummary Empty;
    [CompilerGeneratedAttribute]
private ChangeStatistics <Latest>k__BackingField;
    [CompilerGeneratedAttribute]
private ChangeStatistics <Overall>k__BackingField;
    public ChangeStatistics Latest { get; }
    public ChangeStatistics Overall { get; }
    public ChangeSummary(int index, ChangeStatistics latest, ChangeStatistics overall);
    private static ChangeSummary();
    [CompilerGeneratedAttribute]
public ChangeStatistics get_Latest();
    [CompilerGeneratedAttribute]
public ChangeStatistics get_Overall();
    private bool Equals(ChangeSummary other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[ExtensionAttribute]
public static class DynamicData.Diagnostics.DiagnosticOperators : object {
    [ExtensionAttribute]
public static IObservable`1<ChangeSummary> CollectUpdateStats(IObservable`1<IChangeSet`2<TSource, TKey>> source);
    [ExtensionAttribute]
public static IObservable`1<ChangeSummary> CollectUpdateStats(IObservable`1<IChangeSet`1<TSource>> source);
}
internal class DynamicData.DistinctChangeSet`1 : ChangeSet`2<T, T> {
    public DistinctChangeSet`1(IEnumerable`1<Change`2<T, T>> items);
    public DistinctChangeSet`1(int capacity);
    private sealed virtual override int DynamicData.IChangeSet.get_Capacity();
    private sealed virtual override void DynamicData.IChangeSet.set_Capacity(int value);
}
[ExtensionAttribute]
public static class DynamicData.EnumerableEx : object {
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> AsObservableChangeSet(IEnumerable`1<TObject> source, Func`2<TObject, TKey> keySelector, bool completable);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<TObject>> AsObservableChangeSet(IEnumerable`1<TObject> source, bool completable);
}
[ExtensionAttribute]
public static class DynamicData.Experimental.ExperimentalEx : object {
    [ExtensionAttribute]
public static IWatcher`2<TObject, TKey> AsWatcher(IObservable`1<IChangeSet`2<TObject, TKey>> source, IScheduler scheduler);
}
internal interface DynamicData.Experimental.ISubjectWithRefCount`1 {
    public int RefCount { get; }
    public abstract virtual int get_RefCount();
}
public interface DynamicData.Experimental.IWatcher`2 {
    public abstract virtual IObservable`1<Change`2<TObject, TKey>> Watch(TKey key);
}
internal class DynamicData.Experimental.SubjectWithRefCount`1 : object {
    private ISubject`1<T> _subject;
    private int _refCount;
    public int RefCount { get; }
    public SubjectWithRefCount`1(ISubject`1<T> subject);
    public sealed virtual void OnNext(T value);
    public sealed virtual void OnError(Exception error);
    public sealed virtual void OnCompleted();
    public sealed virtual IDisposable Subscribe(IObserver`1<T> observer);
    public sealed virtual int get_RefCount();
}
internal class DynamicData.Experimental.Watcher`2 : object {
    private IntermediateCache`2<SubjectWithRefCount`1<Change`2<TObject, TKey>>, TKey> _subscribers;
    private IObservableCache`2<TObject, TKey> _source;
    private object _locker;
    private IDisposable _disposer;
    public Watcher`2(IObservable`1<IChangeSet`2<TObject, TKey>> source, IScheduler scheduler);
    public sealed virtual IObservable`1<Change`2<TObject, TKey>> Watch(TKey key);
    public sealed virtual void Dispose();
}
internal class DynamicData.GroupChangeSet`3 : ChangeSet`2<IGroup`3<TObject, TKey, TGroupKey>, TGroupKey> {
    public static IGroupChangeSet`3<TObject, TKey, TGroupKey> Empty;
    public GroupChangeSet`3(IEnumerable`1<Change`2<IGroup`3<TObject, TKey, TGroupKey>, TGroupKey>> items);
    private static GroupChangeSet`3();
    private sealed virtual override int DynamicData.IChangeSet.get_Capacity();
    private sealed virtual override void DynamicData.IChangeSet.set_Capacity(int value);
}
public interface DynamicData.ICache`2 {
    public abstract virtual void Clone(IChangeSet`2<TObject, TKey> changes);
    public abstract virtual void AddOrUpdate(TObject item, TKey key);
    public abstract virtual void Remove(TKey key);
    public abstract virtual void Remove(IEnumerable`1<TKey> keys);
    public abstract virtual void Clear();
    public abstract virtual void Refresh();
    public abstract virtual void Refresh(IEnumerable`1<TKey> keys);
    public abstract virtual void Refresh(TKey key);
}
public interface DynamicData.ICacheUpdater`2 {
    public abstract virtual void AddOrUpdate(IEnumerable`1<KeyValuePair`2<TKey, TObject>> keyValuePairs);
    public abstract virtual void AddOrUpdate(KeyValuePair`2<TKey, TObject> item);
    public abstract virtual void AddOrUpdate(TObject item, TKey key);
    public abstract virtual void Refresh();
    public abstract virtual void Refresh(IEnumerable`1<TKey> keys);
    public abstract virtual void Refresh(TKey key);
    [ObsoleteAttribute("Use Refresh: Same thing but better semantics")]
public abstract virtual void Evaluate();
    [ObsoleteAttribute("Use Refresh: Same thing but better semantics")]
public abstract virtual void Evaluate(IEnumerable`1<TKey> keys);
    [ObsoleteAttribute("Use Refresh: Same thing but better semantics")]
public abstract virtual void Evaluate(TKey key);
    public abstract virtual void Remove(IEnumerable`1<TKey> keys);
    public abstract virtual void RemoveKeys(IEnumerable`1<TKey> key);
    public abstract virtual void Remove(TKey key);
    public abstract virtual void RemoveKey(TKey key);
    public abstract virtual void Remove(IEnumerable`1<KeyValuePair`2<TKey, TObject>> items);
    public abstract virtual void Remove(KeyValuePair`2<TKey, TObject> item);
    [ObsoleteAttribute("Use Clone()")]
public abstract virtual void Update(IChangeSet`2<TObject, TKey> changes);
    public abstract virtual void Clone(IChangeSet`2<TObject, TKey> changes);
    public abstract virtual void Clear();
    public abstract virtual TKey GetKey(TObject item);
    public abstract virtual IEnumerable`1<KeyValuePair`2<TKey, TObject>> GetKeyValues(IEnumerable`1<TObject> items);
}
public interface DynamicData.IChangeSet {
    public int Adds { get; }
    public int Removes { get; }
    public int Refreshes { get; }
    public int Moves { get; }
    public int Count { get; }
    public int Capacity { get; public set; }
    public abstract virtual int get_Adds();
    public abstract virtual int get_Removes();
    public abstract virtual int get_Refreshes();
    public abstract virtual int get_Moves();
    public abstract virtual int get_Count();
    public abstract virtual int get_Capacity();
    public abstract virtual void set_Capacity(int value);
}
public interface DynamicData.IChangeSet`1 {
    public int Replaced { get; }
    public int TotalChanges { get; }
    public abstract virtual int get_Replaced();
    public abstract virtual int get_TotalChanges();
}
public interface DynamicData.IChangeSet`2 {
    public int Updates { get; }
    public abstract virtual int get_Updates();
}
public interface DynamicData.IChangeSetAdaptor`1 {
    public abstract virtual void Adapt(IChangeSet`1<T> change);
}
public interface DynamicData.IChangeSetAdaptor`2 {
    public abstract virtual void Adapt(IChangeSet`2<TObject, TKey> change);
}
public interface DynamicData.IConnectableCache`2 {
    public IObservable`1<int> CountChanged { get; }
    public abstract virtual IObservable`1<Change`2<TObject, TKey>> Watch(TKey key);
    public abstract virtual IObservable`1<IChangeSet`2<TObject, TKey>> Connect(Func`2<TObject, bool> predicate);
    public abstract virtual IObservable`1<IChangeSet`2<TObject, TKey>> Preview(Func`2<TObject, bool> predicate);
    public abstract virtual IObservable`1<int> get_CountChanged();
}
public interface DynamicData.IDistinctChangeSet`1 {
}
public interface DynamicData.IExtendedList`1 {
    public abstract virtual void AddRange(IEnumerable`1<T> collection);
    public abstract virtual void InsertRange(IEnumerable`1<T> collection, int index);
    public abstract virtual void RemoveRange(int index, int count);
    public abstract virtual void Move(int original, int destination);
}
public interface DynamicData.IGroup`2 {
    public TGroup GroupKey { get; }
    public IObservableList`1<TObject> List { get; }
    public abstract virtual TGroup get_GroupKey();
    public abstract virtual IObservableList`1<TObject> get_List();
}
public interface DynamicData.IGroup`3 {
    public IObservableCache`2<TObject, TKey> Cache { get; }
    public abstract virtual IObservableCache`2<TObject, TKey> get_Cache();
}
public interface DynamicData.IGroupChangeSet`3 {
}
public interface DynamicData.IGrouping`3 {
    public TGroupKey Key { get; }
    public IEnumerable`1<TKey> Keys { get; }
    public IEnumerable`1<TObject> Items { get; }
    public IEnumerable`1<KeyValuePair`2<TKey, TObject>> KeyValues { get; }
    public int Count { get; }
    public abstract virtual TGroupKey get_Key();
    public abstract virtual IEnumerable`1<TKey> get_Keys();
    public abstract virtual IEnumerable`1<TObject> get_Items();
    public abstract virtual IEnumerable`1<KeyValuePair`2<TKey, TObject>> get_KeyValues();
    public abstract virtual int get_Count();
    public abstract virtual Optional`1<TObject> Lookup(TKey key);
}
public interface DynamicData.IImmutableGroupChangeSet`3 {
}
public interface DynamicData.IIntermediateCache`2 {
    public abstract virtual void Edit(Action`1<ICacheUpdater`2<TObject, TKey>> updateAction);
}
public interface DynamicData.IKey`1 {
    public T Key { get; }
    public abstract virtual T get_Key();
}
public interface DynamicData.IKeyValue`2 {
    public TObject Value { get; }
    public abstract virtual TObject get_Value();
}
[DefaultMemberAttribute("Item")]
public interface DynamicData.IKeyValueCollection`2 {
    public IComparer`1<KeyValuePair`2<TKey, TObject>> Comparer { get; }
    public int Count { get; }
    public SortReason SortReason { get; }
    public SortOptimisations Optimisations { get; }
    public KeyValuePair`2<TKey, TObject> Item { get; }
    public abstract virtual IComparer`1<KeyValuePair`2<TKey, TObject>> get_Comparer();
    public abstract virtual int get_Count();
    public abstract virtual SortReason get_SortReason();
    public abstract virtual SortOptimisations get_Optimisations();
    public abstract virtual KeyValuePair`2<TKey, TObject> get_Item(int index);
}
public class DynamicData.IndexedItem`2 : object {
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private TObject <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private TKey <Key>k__BackingField;
    public int Index { get; }
    public TObject Value { get; }
    public TKey Key { get; }
    public IndexedItem`2(TObject value, TKey key, int index);
    [CompilerGeneratedAttribute]
public int get_Index();
    [CompilerGeneratedAttribute]
public TObject get_Value();
    [CompilerGeneratedAttribute]
public TKey get_Key();
    private bool Equals(IndexedItem`2<TObject, TKey> other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class DynamicData.IntermediateCache`2 : object {
    private ObservableCache`2<TObject, TKey> _innnerCache;
    public IObservable`1<int> CountChanged { get; }
    public int Count { get; }
    public IEnumerable`1<TObject> Items { get; }
    public IEnumerable`1<KeyValuePair`2<TKey, TObject>> KeyValues { get; }
    public IEnumerable`1<TKey> Keys { get; }
    public IntermediateCache`2(IObservable`1<IChangeSet`2<TObject, TKey>> source);
    public sealed virtual void Edit(Action`1<ICacheUpdater`2<TObject, TKey>> updateAction);
    public sealed virtual IObservable`1<int> get_CountChanged();
    public sealed virtual IObservable`1<IChangeSet`2<TObject, TKey>> Connect(Func`2<TObject, bool> predicate);
    public IObservable`1<IChangeSet`2<TObject, TKey>> Connect();
    public sealed virtual IObservable`1<IChangeSet`2<TObject, TKey>> Preview(Func`2<TObject, bool> predicate);
    public sealed virtual IObservable`1<Change`2<TObject, TKey>> Watch(TKey key);
    public sealed virtual int get_Count();
    public sealed virtual IEnumerable`1<TObject> get_Items();
    public sealed virtual IEnumerable`1<KeyValuePair`2<TKey, TObject>> get_KeyValues();
    public sealed virtual IEnumerable`1<TKey> get_Keys();
    public sealed virtual Optional`1<TObject> Lookup(TKey key);
    internal IChangeSet`2<TObject, TKey> GetInitialUpdates(Func`2<TObject, bool> filter);
    public sealed virtual void Dispose();
}
public interface DynamicData.IObservableCache`2 {
    public IEnumerable`1<TKey> Keys { get; }
    public IEnumerable`1<TObject> Items { get; }
    public IEnumerable`1<KeyValuePair`2<TKey, TObject>> KeyValues { get; }
    public int Count { get; }
    public abstract virtual IEnumerable`1<TKey> get_Keys();
    public abstract virtual IEnumerable`1<TObject> get_Items();
    public abstract virtual IEnumerable`1<KeyValuePair`2<TKey, TObject>> get_KeyValues();
    public abstract virtual Optional`1<TObject> Lookup(TKey key);
    public abstract virtual int get_Count();
}
public interface DynamicData.IObservableList`1 {
    public IObservable`1<int> CountChanged { get; }
    public IEnumerable`1<T> Items { get; }
    public int Count { get; }
    public abstract virtual IObservable`1<IChangeSet`1<T>> Connect(Func`2<T, bool> predicate);
    public abstract virtual IObservable`1<IChangeSet`1<T>> Preview(Func`2<T, bool> predicate);
    public abstract virtual IObservable`1<int> get_CountChanged();
    public abstract virtual IEnumerable`1<T> get_Items();
    public abstract virtual int get_Count();
}
public interface DynamicData.IPageChangeSet`1 {
    public IPageResponse Response { get; }
    public abstract virtual IPageResponse get_Response();
}
public interface DynamicData.IPagedChangeSet`2 {
    public IPageResponse Response { get; }
    public abstract virtual IPageResponse get_Response();
}
public interface DynamicData.IPageRequest {
    public int Page { get; }
    public int Size { get; }
    public abstract virtual int get_Page();
    public abstract virtual int get_Size();
}
public interface DynamicData.IQuery`2 {
    public IEnumerable`1<TKey> Keys { get; }
    public IEnumerable`1<TObject> Items { get; }
    public IEnumerable`1<KeyValuePair`2<TKey, TObject>> KeyValues { get; }
    public int Count { get; }
    public abstract virtual Optional`1<TObject> Lookup(TKey key);
    public abstract virtual IEnumerable`1<TKey> get_Keys();
    public abstract virtual IEnumerable`1<TObject> get_Items();
    public abstract virtual IEnumerable`1<KeyValuePair`2<TKey, TObject>> get_KeyValues();
    public abstract virtual int get_Count();
}
public interface DynamicData.ISortedChangeSet`2 {
    public IKeyValueCollection`2<TObject, TKey> SortedItems { get; }
    public abstract virtual IKeyValueCollection`2<TObject, TKey> get_SortedItems();
}
public interface DynamicData.ISortedChangeSetAdaptor`2 {
    public abstract virtual void Adapt(ISortedChangeSet`2<TObject, TKey> change);
}
public interface DynamicData.ISourceCache`2 {
    public Func`2<TObject, TKey> KeySelector { get; }
    public abstract virtual void Edit(Action`1<ISourceUpdater`2<TObject, TKey>> updateAction);
    public abstract virtual Func`2<TObject, TKey> get_KeySelector();
}
public interface DynamicData.ISourceList`1 {
    public abstract virtual void Edit(Action`1<IExtendedList`1<T>> updateAction);
}
public interface DynamicData.ISourceUpdater`2 {
    public abstract virtual void Load(IEnumerable`1<TObject> items);
    public abstract virtual void AddOrUpdate(IEnumerable`1<TObject> items);
    public abstract virtual void AddOrUpdate(TObject item);
    public abstract virtual void AddOrUpdate(TObject item, IEqualityComparer`1<TObject> comparer);
    public abstract virtual void Refresh(IEnumerable`1<TObject> items);
    public abstract virtual void Refresh(TObject item);
    [ObsoleteAttribute("Use Refresh: Same thing but better semantics")]
public abstract virtual void Evaluate(IEnumerable`1<TObject> items);
    [ObsoleteAttribute("Use Refresh: Same thing but better semantics")]
public abstract virtual void Evaluate(TObject item);
    public abstract virtual void Remove(IEnumerable`1<TObject> items);
    public abstract virtual void Remove(TObject item);
}
[IsReadOnlyAttribute]
public class DynamicData.ItemChange`1 : ValueType {
    public static ItemChange`1<T> Empty;
    [CompilerGeneratedAttribute]
private ListChangeReason <Reason>k__BackingField;
    [CompilerGeneratedAttribute]
private T <Current>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CurrentIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private Optional`1<T> <Previous>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PreviousIndex>k__BackingField;
    public ListChangeReason Reason { get; }
    public T Current { get; }
    public int CurrentIndex { get; }
    public Optional`1<T> Previous { get; }
    public int PreviousIndex { get; }
    public ItemChange`1(ListChangeReason reason, T current, Optional`1<T> previous, int currentIndex, int previousIndex);
    public ItemChange`1(ListChangeReason reason, T current, int currentIndex);
    private static ItemChange`1();
    [CompilerGeneratedAttribute]
public ListChangeReason get_Reason();
    [CompilerGeneratedAttribute]
public T get_Current();
    [CompilerGeneratedAttribute]
public int get_CurrentIndex();
    [CompilerGeneratedAttribute]
public Optional`1<T> get_Previous();
    [CompilerGeneratedAttribute]
public int get_PreviousIndex();
    public sealed virtual bool Equals(ItemChange`1<T> other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(ItemChange`1<T> left, ItemChange`1<T> right);
    public static bool op_Inequality(ItemChange`1<T> left, ItemChange`1<T> right);
    public virtual string ToString();
}
public interface DynamicData.IVirtualChangeSet`1 {
    public IVirtualResponse Response { get; }
    public abstract virtual IVirtualResponse get_Response();
}
public interface DynamicData.IVirtualChangeSet`2 {
    public IVirtualResponse Response { get; }
    public abstract virtual IVirtualResponse get_Response();
}
public interface DynamicData.IVirtualRequest {
    public int Size { get; }
    public int StartIndex { get; }
    public abstract virtual int get_Size();
    public abstract virtual int get_StartIndex();
}
public interface DynamicData.IVirtualResponse {
    public int Size { get; }
    public int StartIndex { get; }
    public int TotalSize { get; }
    public abstract virtual int get_Size();
    public abstract virtual int get_StartIndex();
    public abstract virtual int get_TotalSize();
}
public enum DynamicData.Kernel.ConnectionStatus : Enum {
    public int value__;
    public static ConnectionStatus Pending;
    public static ConnectionStatus Loaded;
    public static ConnectionStatus Errored;
    public static ConnectionStatus Completed;
}
public class DynamicData.Kernel.DoubleCheck`1 : object {
    private Func`1<T> _factory;
    private object _locker;
    private T modreq(System.Runtime.CompilerServices.IsVolatile) _value;
    public T Value { get; }
    public DoubleCheck`1(Func`1<T> factory);
    public T get_Value();
}
[ExtensionAttribute]
public static class DynamicData.Kernel.EnumerableEx : object {
    [ExtensionAttribute]
public static T[] AsArray(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static List`1<T> AsList(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static IEnumerable`1<T> Duplicates(IEnumerable`1<T> source, Func`2<T, TValue> valueSelector);
    [ExtensionAttribute]
public static IEnumerable`1<ItemWithIndex`1<T>> IndexOfMany(IEnumerable`1<T> source, IEnumerable`1<T> itemsToFind);
    [ExtensionAttribute]
public static IEnumerable`1<TResult> IndexOfMany(IEnumerable`1<TObject> source, IEnumerable`1<TObject> itemsToFind, Func`3<TObject, int, TResult> resultSelector);
    [ExtensionAttribute]
internal static IEnumerable`1<ItemWithIndex`1<T>> WithIndex(IEnumerable`1<T> source);
    [ExtensionAttribute]
internal static void ForEach(IEnumerable`1<T> source, Action`1<T> action);
    [ExtensionAttribute]
internal static void ForEach(IEnumerable`1<TObject> source, Action`2<TObject, int> action);
    [ExtensionAttribute]
internal static IEnumerable`1<T> EmptyIfNull(IEnumerable`1<T> source);
    [ExtensionAttribute]
internal static HashSet`1<T> ToHashSet(IEnumerable`1<T> source);
    [IteratorStateMachineAttribute("DynamicData.Kernel.EnumerableEx/<EnumerateOne>d__10`1")]
[ExtensionAttribute]
internal static IEnumerable`1<T> EnumerateOne(T source);
}
internal static class DynamicData.Kernel.EnumerableIList : object {
    public static EnumerableIList`1<T> Create(IList`1<T> list);
    public static EnumerableIList`1<Change`2<TObject, TKey>> Create(IChangeSet`2<TObject, TKey> changeset);
}
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
internal class DynamicData.Kernel.EnumerableIList`1 : ValueType {
    private IList`1<T> _list;
    public static EnumerableIList`1<T> Empty;
    public T Item { get; public set; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public EnumerableIList`1(IList`1<T> list);
    private static EnumerableIList`1();
    public sealed virtual EnumeratorIList`1<T> GetEnumerator();
    public static EnumerableIList`1<T> op_Implicit(List`1<T> list);
    public static EnumerableIList`1<T> op_Implicit(T[] array);
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual int IndexOf(T item);
    public sealed virtual void Insert(int index, T item);
    public sealed virtual bool Remove(T item);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
}
internal class DynamicData.Kernel.EnumeratorIList`1 : ValueType {
    private IList`1<T> _list;
    private int _index;
    public T Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    public EnumeratorIList`1(IList`1<T> list);
    public sealed virtual T get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual void Dispose();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual void Reset();
}
public class DynamicData.Kernel.Error`2 : object {
    [CompilerGeneratedAttribute]
private TKey <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private TObject <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    public TKey Key { get; }
    public TObject Value { get; }
    public Exception Exception { get; }
    public Error`2(Exception exception, TObject value, TKey key);
    [CompilerGeneratedAttribute]
public sealed virtual TKey get_Key();
    [CompilerGeneratedAttribute]
public sealed virtual TObject get_Value();
    [CompilerGeneratedAttribute]
public Exception get_Exception();
    public static bool op_Equality(Error`2<TObject, TKey> left, Error`2<TObject, TKey> right);
    public static bool op_Inequality(Error`2<TObject, TKey> left, Error`2<TObject, TKey> right);
    public sealed virtual bool Equals(Error`2<TObject, TKey> other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
internal interface DynamicData.Kernel.IEnumerableIList`1 {
    public abstract virtual EnumeratorIList`1<T> GetEnumerator();
}
[ExtensionAttribute]
public static class DynamicData.Kernel.InternalEx : object {
    [ExtensionAttribute]
public static IObservable`1<TSource> RetryWithBackOff(IObservable`1<TSource> source, Func`3<TException, int, Nullable`1<TimeSpan>> backOffStrategy);
    [ExtensionAttribute]
internal static IObservable`1<Unit> ToUnit(IObservable`1<T> source);
    [ExtensionAttribute]
internal static void OnNext(ISubject`1<Unit> source);
    [ExtensionAttribute]
internal static IObservable`1<TResult> SelectTask(IObservable`1<T> source, Func`2<T, Task`1<TResult>> factory);
    [ExtensionAttribute]
public static IDisposable ScheduleRecurringAction(IScheduler scheduler, TimeSpan interval, Action action);
    [ExtensionAttribute]
public static IDisposable ScheduleRecurringAction(IScheduler scheduler, Func`1<TimeSpan> interval, Action action);
    internal static void Swap(TSwap& t1, TSwap& t2);
}
internal interface DynamicData.Kernel.ISupportsCapcity {
    public int Capacity { get; public set; }
    public int Count { get; }
    public abstract virtual int get_Capacity();
    public abstract virtual void set_Capacity(int value);
    public abstract virtual int get_Count();
}
[IsReadOnlyAttribute]
public class DynamicData.Kernel.ItemWithIndex`1 : ValueType {
    [CompilerGeneratedAttribute]
private T <Item>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    public T Item { get; }
    public int Index { get; }
    public ItemWithIndex`1(T item, int index);
    [CompilerGeneratedAttribute]
public T get_Item();
    [CompilerGeneratedAttribute]
public int get_Index();
    public sealed virtual bool Equals(ItemWithIndex`1<T> other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(ItemWithIndex`1<T> left, ItemWithIndex`1<T> right);
    public static bool op_Inequality(ItemWithIndex`1<T> left, ItemWithIndex`1<T> right);
    public virtual string ToString();
}
[IsReadOnlyAttribute]
public class DynamicData.Kernel.ItemWithValue`2 : ValueType {
    [CompilerGeneratedAttribute]
private TObject <Item>k__BackingField;
    [CompilerGeneratedAttribute]
private TValue <Value>k__BackingField;
    public TObject Item { get; }
    public TValue Value { get; }
    public ItemWithValue`2(TObject item, TValue value);
    [CompilerGeneratedAttribute]
public TObject get_Item();
    [CompilerGeneratedAttribute]
public TValue get_Value();
    public sealed virtual bool Equals(ItemWithValue`2<TObject, TValue> other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(ItemWithValue`2<TObject, TValue> left, ItemWithValue`2<TObject, TValue> right);
    public static bool op_Inequality(ItemWithValue`2<TObject, TValue> left, ItemWithValue`2<TObject, TValue> right);
    public virtual string ToString();
}
public static class DynamicData.Kernel.Optional : object {
    public static Optional`1<T> Some(T value);
    public static Optional`1<T> None();
}
[IsReadOnlyAttribute]
public class DynamicData.Kernel.Optional`1 : ValueType {
    private T _value;
    public static Optional`1<T> None;
    [CompilerGeneratedAttribute]
private bool <HasValue>k__BackingField;
    public bool HasValue { get; }
    public T Value { get; }
    internal Optional`1(T value);
    private static Optional`1();
    public static Optional`1<T> Create(T value);
    [CompilerGeneratedAttribute]
public bool get_HasValue();
    public T get_Value();
    public static Optional`1<T> op_Implicit(T value);
    public static T op_Explicit(Optional`1<T> value);
    public static T FromOptional(Optional`1<T> value);
    public static Optional`1<T> ToOptional(T value);
    public static bool op_Equality(Optional`1<T> left, Optional`1<T> right);
    public static bool op_Inequality(Optional`1<T> left, Optional`1<T> right);
    public sealed virtual bool Equals(Optional`1<T> other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class DynamicData.Kernel.OptionElse : object {
    internal static OptionElse NoAction;
    private bool _shouldRunAction;
    internal OptionElse(bool shouldRunAction);
    private static OptionElse();
    public void Else(Action action);
}
[ExtensionAttribute]
public static class DynamicData.Kernel.OptionExtensions : object {
    [ExtensionAttribute]
public static T ValueOr(Nullable`1<T> source, T defaultValue);
    [ExtensionAttribute]
public static T ValueOr(Optional`1<T> source, Func`1<T> valueSelector);
    [ExtensionAttribute]
public static T ValueOrDefault(Optional`1<T> source);
    [ExtensionAttribute]
public static T ValueOrThrow(Optional`1<T> source, Func`1<Exception> exceptionGenerator);
    [ExtensionAttribute]
public static TDestination ConvertOr(Optional`1<TSource> source, Func`2<TSource, TDestination> converter, Func`1<TDestination> fallbackConverter);
    [ExtensionAttribute]
public static Optional`1<TDestination> Convert(Optional`1<TSource> source, Func`2<TSource, TDestination> converter);
    [ExtensionAttribute]
public static IEnumerable`1<T> SelectValues(IEnumerable`1<Optional`1<T>> source);
    [ExtensionAttribute]
public static Optional`1<TValue> Lookup(IDictionary`2<TKey, TValue> source, TKey key);
    [ExtensionAttribute]
public static bool RemoveIfContained(IDictionary`2<TKey, TValue> source, TKey key);
    [ExtensionAttribute]
public static Optional`1<T> FirstOrOptional(IEnumerable`1<T> source, Func`2<T, bool> selector);
    [ExtensionAttribute]
public static OptionElse IfHasValue(Optional`1<T> source, Action`1<T> action);
}
[ExtensionAttribute]
internal static class DynamicData.Kernel.ParallelEx : object {
    [AsyncStateMachineAttribute("DynamicData.Kernel.ParallelEx/<SelectParallel>d__0`2")]
[ExtensionAttribute]
public static Task`1<IEnumerable`1<TDestination>> SelectParallel(IEnumerable`1<TSource> source, Func`2<TSource, Task`1<TDestination>> selector, int maximumThreads);
}
internal class DynamicData.Kernel.ReadOnlyCollectionLight`1 : object {
    private IList`1<T> _items;
    public static IReadOnlyCollection`1<T> Empty;
    [CompilerGeneratedAttribute]
private int <Count>k__BackingField;
    public int Count { get; }
    public ReadOnlyCollectionLight`1(IEnumerable`1<T> items);
    private static ReadOnlyCollectionLight`1();
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [CompilerGeneratedAttribute]
public sealed virtual int get_Count();
}
internal class DynamicData.Kernel.ReferenceEqualityComparer`1 : object {
    public static IEqualityComparer`1<T> Instance;
    private static ReferenceEqualityComparer`1();
    public sealed virtual bool Equals(T x, T y);
    public sealed virtual int GetHashCode(T obj);
}
public interface DynamicData.List.IGrouping`2 {
    public TGroupKey Key { get; }
    public IEnumerable`1<TObject> Items { get; }
    public int Count { get; }
    public abstract virtual TGroupKey get_Key();
    public abstract virtual IEnumerable`1<TObject> get_Items();
    public abstract virtual int get_Count();
}
internal class DynamicData.List.Internal.AnonymousObservableList`1 : object {
    private ISourceList`1<T> _sourceList;
    public IObservable`1<int> CountChanged { get; }
    public IEnumerable`1<T> Items { get; }
    public int Count { get; }
    public AnonymousObservableList`1(IObservable`1<IChangeSet`1<T>> source);
    public AnonymousObservableList`1(ISourceList`1<T> sourceList);
    public sealed virtual IObservable`1<int> get_CountChanged();
    public sealed virtual IEnumerable`1<T> get_Items();
    public sealed virtual int get_Count();
    public sealed virtual IObservable`1<IChangeSet`1<T>> Connect(Func`2<T, bool> predicate);
    public sealed virtual IObservable`1<IChangeSet`1<T>> Preview(Func`2<T, bool> predicate);
    public sealed virtual void Dispose();
}
internal class DynamicData.List.Internal.AutoRefresh`2 : object {
    private IObservable`1<IChangeSet`1<TObject>> _source;
    private Func`2<TObject, IObservable`1<TAny>> _reevaluator;
    private Nullable`1<TimeSpan> _buffer;
    private IScheduler _scheduler;
    public AutoRefresh`2(IObservable`1<IChangeSet`1<TObject>> source, Func`2<TObject, IObservable`1<TAny>> reevaluator, Nullable`1<TimeSpan> buffer, IScheduler scheduler);
    public IObservable`1<IChangeSet`1<TObject>> Run();
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__5_0(IObserver`1<IChangeSet`1<TObject>> observer);
    [CompilerGeneratedAttribute]
private IObservable`1<TObject> <Run>b__5_1(TObject t);
}
internal class DynamicData.List.Internal.BufferIf`1 : object {
    private IObservable`1<IChangeSet`1<T>> _source;
    private IObservable`1<bool> _pauseIfTrueSelector;
    private bool _initialPauseState;
    private TimeSpan _timeOut;
    private IScheduler _scheduler;
    public BufferIf`1(IObservable`1<IChangeSet`1<T>> source, IObservable`1<bool> pauseIfTrueSelector, bool initialPauseState, Nullable`1<TimeSpan> timeOut, IScheduler scheduler);
    public IObservable`1<IChangeSet`1<T>> Run();
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__6_0(IObserver`1<IChangeSet`1<T>> observer);
}
internal class DynamicData.List.Internal.Combiner`1 : object {
    private object _locker;
    private ICollection`1<IObservable`1<IChangeSet`1<T>>> _source;
    private CombineOperator _type;
    public Combiner`1(ICollection`1<IObservable`1<IChangeSet`1<T>>> source, CombineOperator type);
    public IObservable`1<IChangeSet`1<T>> Run();
    private static void CloneSourceList(ReferenceCountTracker`1<T> tracker, IChangeSet`1<T> changes);
    private IChangeSet`1<T> UpdateResultList(IChangeSet`1<T> changes, List`1<ReferenceCountTracker`1<T>> sourceLists, ChangeAwareListWithRefCounts`1<T> resultList);
    private void UpdateItemMembership(T item, List`1<ReferenceCountTracker`1<T>> sourceLists, ChangeAwareListWithRefCounts`1<T> resultList);
    private bool MatchesConstraint(List`1<ReferenceCountTracker`1<T>> sourceLists, T item);
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__4_0(IObserver`1<IChangeSet`1<T>> observer);
}
internal class DynamicData.List.Internal.DeferUntilLoaded`1 : object {
    private IObservable`1<IChangeSet`1<T>> _source;
    public DeferUntilLoaded`1(IObservable`1<IChangeSet`1<T>> source);
    public IObservable`1<IChangeSet`1<T>> Run();
}
internal class DynamicData.List.Internal.Distinct`2 : object {
    private IObservable`1<IChangeSet`1<T>> _source;
    private Func`2<T, TValue> _valueSelector;
    public Distinct`2(IObservable`1<IChangeSet`1<T>> source, Func`2<T, TValue> valueSelector);
    public IObservable`1<IChangeSet`1<TValue>> Run();
    private static IChangeSet`1<TValue> Process(Dictionary`2<TValue, int> values, ChangeAwareList`1<TValue> result, IChangeSet`1<ItemWithMatch<T, TValue>> changes);
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__3_0(IObserver`1<IChangeSet`1<TValue>> observer);
    [CompilerGeneratedAttribute]
private ItemWithMatch<T, TValue> <Run>b__3_1(T t, Optional`1<ItemWithMatch<T, TValue>> previous, int idx);
}
internal class DynamicData.List.Internal.DynamicCombiner`1 : object {
    private IObservableList`1<IObservable`1<IChangeSet`1<T>>> _source;
    private CombineOperator _type;
    private object _locker;
    public DynamicCombiner`1(IObservableList`1<IObservable`1<IChangeSet`1<T>>> source, CombineOperator type);
    public IObservable`1<IChangeSet`1<T>> Run();
    private IChangeSet`1<T> UpdateResultList(MergeContainer[] sourceLists, ChangeAwareListWithRefCounts`1<T> resultList, IChangeSet`1<T> changes);
    private IChangeSet`1<T> UpdateItemSetMemberships(MergeContainer[] sourceLists, ChangeAwareListWithRefCounts`1<T> resultingList, IEnumerable`1<T> items);
    private void UpdateItemMembership(T item, MergeContainer[] sourceLists, ChangeAwareListWithRefCounts`1<T> resultList);
    private bool MatchesConstraint(MergeContainer[] sourceLists, T item);
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__4_0(IObserver`1<IChangeSet`1<T>> observer);
}
internal class DynamicData.List.Internal.EditDiff`1 : object {
    private ISourceList`1<T> _source;
    private IEqualityComparer`1<T> _equalityComparer;
    public EditDiff`1(ISourceList`1<T> source, IEqualityComparer`1<T> equalityComparer);
    public void Edit(IEnumerable`1<T> items);
}
internal class DynamicData.List.Internal.ExpirableItem`1 : object {
    [CompilerGeneratedAttribute]
private TObject <Item>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <ExpireAt>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Index>k__BackingField;
    public TObject Item { get; }
    public DateTime ExpireAt { get; }
    public long Index { get; }
    public ExpirableItem`1(TObject value, DateTime dateTime, long index);
    [CompilerGeneratedAttribute]
public TObject get_Item();
    [CompilerGeneratedAttribute]
public DateTime get_ExpireAt();
    [CompilerGeneratedAttribute]
public long get_Index();
    public sealed virtual bool Equals(ExpirableItem`1<TObject> other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(ExpirableItem`1<TObject> left, ExpirableItem`1<TObject> right);
    public static bool op_Inequality(ExpirableItem`1<TObject> left, ExpirableItem`1<TObject> right);
    public virtual string ToString();
}
internal class DynamicData.List.Internal.ExpireAfter`1 : object {
    private ISourceList`1<T> _sourceList;
    private Func`2<T, Nullable`1<TimeSpan>> _expireAfter;
    private Nullable`1<TimeSpan> _pollingInterval;
    private IScheduler _scheduler;
    private object _locker;
    public ExpireAfter`1(ISourceList`1<T> sourceList, Func`2<T, Nullable`1<TimeSpan>> expireAfter, Nullable`1<TimeSpan> pollingInterval, IScheduler scheduler, object locker);
    public IObservable`1<IEnumerable`1<T>> Run();
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__6_0(IObserver`1<IEnumerable`1<T>> observer);
    [CompilerGeneratedAttribute]
private bool <Run>b__6_7(ExpirableItem`1<T> ei);
}
internal class DynamicData.List.Internal.Filter`1 : object {
    private ListFilterPolicy _policy;
    private IObservable`1<IChangeSet`1<T>> _source;
    private IObservable`1<Func`2<T, bool>> _predicates;
    private Func`2<T, bool> _predicate;
    public Filter`1(IObservable`1<IChangeSet`1<T>> source, IObservable`1<Func`2<T, bool>> predicates, ListFilterPolicy policy);
    public Filter`1(IObservable`1<IChangeSet`1<T>> source, Func`2<T, bool> predicate, ListFilterPolicy policy);
    public IObservable`1<IChangeSet`1<T>> Run();
    private static IChangeSet`1<ItemWithMatch<T>> Process(ChangeAwareList`1<ItemWithMatch<T>> filtered, IChangeSet`1<ItemWithMatch<T>> changes);
    private IChangeSet`1<ItemWithMatch<T>> Requery(Func`2<T, bool> predicate, List`1<ItemWithMatch<T>> all, ChangeAwareList`1<ItemWithMatch<T>> filtered);
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__6_0(IObserver`1<IChangeSet`1<T>> observer);
}
internal class DynamicData.List.Internal.FilterOnObservable`1 : object {
    private IObservable`1<IChangeSet`1<TObject>> _source;
    private Func`2<TObject, IObservable`1<bool>> _filter;
    private Nullable`1<TimeSpan> _buffer;
    private IScheduler _scheduler;
    public FilterOnObservable`1(IObservable`1<IChangeSet`1<TObject>> source, Func`2<TObject, IObservable`1<bool>> filter, Nullable`1<TimeSpan> buffer, IScheduler scheduler);
    public IObservable`1<IChangeSet`1<TObject>> Run();
    private static IEnumerable`1<TResult> IndexOfMany(IEnumerable`1<TObj> source, IEnumerable`1<TObj> itemsToFind, Func`2<TObj, TObjectProp> objectPropertyFunc, Func`3<TObj, int, TResult> resultSelector);
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__6_0(IObserver`1<IChangeSet`1<TObject>> observer);
    [CompilerGeneratedAttribute]
private IObservable`1<ObjWithFilterValue<TObject>> <Run>b__6_2(ObjWithFilterValue<TObject> v);
}
[ObsoleteAttribute("Use AutoRefresh(), followed by Filter() instead")]
internal class DynamicData.List.Internal.FilterOnProperty`2 : object {
    private Func`2<TObject, bool> _predicate;
    private Nullable`1<TimeSpan> _throttle;
    private IScheduler _scheduler;
    private Expression`1<Func`2<TObject, TProperty>> _propertySelector;
    private IObservable`1<IChangeSet`1<TObject>> _source;
    public FilterOnProperty`2(IObservable`1<IChangeSet`1<TObject>> source, Expression`1<Func`2<TObject, TProperty>> propertySelector, Func`2<TObject, bool> predicate, Nullable`1<TimeSpan> throttle, IScheduler scheduler);
    public IObservable`1<IChangeSet`1<TObject>> Run();
}
internal class DynamicData.List.Internal.FilterStatic`1 : object {
    private IObservable`1<IChangeSet`1<T>> _source;
    private Func`2<T, bool> _predicate;
    public FilterStatic`1(IObservable`1<IChangeSet`1<T>> source, Func`2<T, bool> predicate);
    public IObservable`1<IChangeSet`1<T>> Run();
    private void Process(ChangeAwareList`1<T> filtered, IChangeSet`1<T> changes);
    [CompilerGeneratedAttribute]
private ChangeAwareList`1<T> <Run>b__3_0(ChangeAwareList`1<T> state, IChangeSet`1<T> changes);
    [CompilerGeneratedAttribute]
private bool <Process>b__4_0(T t);
}
internal class DynamicData.List.Internal.Group`2 : object {
    [CompilerGeneratedAttribute]
private ISourceList`1<TObject> <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private TGroup <GroupKey>k__BackingField;
    private ISourceList`1<TObject> Source { get; }
    public TGroup GroupKey { get; }
    public IObservableList`1<TObject> List { get; }
    public Group`2(TGroup groupKey);
    [CompilerGeneratedAttribute]
private ISourceList`1<TObject> get_Source();
    [CompilerGeneratedAttribute]
public sealed virtual TGroup get_GroupKey();
    public sealed virtual IObservableList`1<TObject> get_List();
    public void Edit(Action`1<IList`1<TObject>> editAction);
    public sealed virtual bool Equals(Group`2<TObject, TGroup> other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(Group`2<TObject, TGroup> left, Group`2<TObject, TGroup> right);
    public static bool op_Inequality(Group`2<TObject, TGroup> left, Group`2<TObject, TGroup> right);
    public virtual string ToString();
    public sealed virtual void Dispose();
}
internal class DynamicData.List.Internal.GroupOn`2 : object {
    private IObservable`1<IChangeSet`1<TObject>> _source;
    private Func`2<TObject, TGroupKey> _groupSelector;
    private IObservable`1<Unit> _regrouper;
    public GroupOn`2(IObservable`1<IChangeSet`1<TObject>> source, Func`2<TObject, TGroupKey> groupSelector, IObservable`1<Unit> regrouper);
    public IObservable`1<IChangeSet`1<IGroup`2<TObject, TGroupKey>>> Run();
    private IChangeSet`1<IGroup`2<TObject, TGroupKey>> Regroup(ChangeAwareList`1<IGroup`2<TObject, TGroupKey>> result, IDictionary`2<TGroupKey, Group`2<TObject, TGroupKey>> groupCollection, IReadOnlyCollection`1<ItemWithGroupKey<TObject, TGroupKey>> currentItems);
    private static IChangeSet`1<IGroup`2<TObject, TGroupKey>> Process(ChangeAwareList`1<IGroup`2<TObject, TGroupKey>> result, IDictionary`2<TGroupKey, Group`2<TObject, TGroupKey>> groupCollection, IChangeSet`1<ItemWithGroupKey<TObject, TGroupKey>> changes);
    private static GroupWithAddIndicator<TObject, TGroupKey> GetCache(IDictionary`2<TGroupKey, Group`2<TObject, TGroupKey>> groupCaches, TGroupKey key);
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__4_0(IObserver`1<IChangeSet`1<IGroup`2<TObject, TGroupKey>>> observer);
    [CompilerGeneratedAttribute]
private ItemWithGroupKey<TObject, TGroupKey> <Run>b__4_1(TObject t, Optional`1<ItemWithGroupKey<TObject, TGroupKey>> previous);
}
internal class DynamicData.List.Internal.GroupOnImmutable`2 : object {
    private IObservable`1<IChangeSet`1<TObject>> _source;
    private Func`2<TObject, TGroupKey> _groupSelector;
    private IObservable`1<Unit> _reGrouper;
    public GroupOnImmutable`2(IObservable`1<IChangeSet`1<TObject>> source, Func`2<TObject, TGroupKey> groupSelector, IObservable`1<Unit> reGrouper);
    public IObservable`1<IChangeSet`1<IGrouping`2<TObject, TGroupKey>>> Run();
    private IChangeSet`1<IGrouping`2<TObject, TGroupKey>> Regroup(ChangeAwareList`1<IGrouping`2<TObject, TGroupKey>> result, IDictionary`2<TGroupKey, GroupContainer<TObject, TGroupKey>> allGroupings, IReadOnlyCollection`1<ItemWithGroupKey<TObject, TGroupKey>> currentItems);
    private static IChangeSet`1<IGrouping`2<TObject, TGroupKey>> Process(ChangeAwareList`1<IGrouping`2<TObject, TGroupKey>> result, IDictionary`2<TGroupKey, GroupContainer<TObject, TGroupKey>> allGroupings, IChangeSet`1<ItemWithGroupKey<TObject, TGroupKey>> changes);
    private static IChangeSet`1<IGrouping`2<TObject, TGroupKey>> CreateChangeSet(ChangeAwareList`1<IGrouping`2<TObject, TGroupKey>> result, IDictionary`2<TGroupKey, GroupContainer<TObject, TGroupKey>> allGroupings, IDictionary`2<TGroupKey, IGrouping`2<TObject, TGroupKey>> initialStateOfGroups);
    private static IGrouping`2<TObject, TGroupKey> GetGroupState(GroupContainer<TObject, TGroupKey> grouping);
    private static IGrouping`2<TObject, TGroupKey> GetGroupState(TGroupKey key, IList`1<TObject> list);
    private static GroupContainer<TObject, TGroupKey> GetGroup(IDictionary`2<TGroupKey, GroupContainer<TObject, TGroupKey>> groupCaches, TGroupKey key);
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__4_0(IObserver`1<IChangeSet`1<IGrouping`2<TObject, TGroupKey>>> observer);
    [CompilerGeneratedAttribute]
private ItemWithGroupKey<TObject, TGroupKey> <Run>b__4_1(TObject t, Optional`1<ItemWithGroupKey<TObject, TGroupKey>> previous);
}
internal class DynamicData.List.Internal.GroupOnProperty`2 : object {
    private IObservable`1<IChangeSet`1<TObject>> _source;
    private Expression`1<Func`2<TObject, TGroup>> _propertySelector;
    private Nullable`1<TimeSpan> _throttle;
    private IScheduler _scheduler;
    private Func`2<TObject, TGroup> _groupSelector;
    public GroupOnProperty`2(IObservable`1<IChangeSet`1<TObject>> source, Expression`1<Func`2<TObject, TGroup>> groupSelectorKey, Nullable`1<TimeSpan> throttle, IScheduler scheduler);
    public IObservable`1<IChangeSet`1<IGroup`2<TObject, TGroup>>> Run();
    [CompilerGeneratedAttribute]
private IObservable`1<IChangeSet`1<IGroup`2<TObject, TGroup>>> <Run>b__6_0(IObservable`1<IChangeSet`1<TObject>> shared);
}
internal class DynamicData.List.Internal.GroupOnPropertyWithImmutableState`2 : object {
    private IObservable`1<IChangeSet`1<TObject>> _source;
    private Expression`1<Func`2<TObject, TGroup>> _propertySelector;
    private Nullable`1<TimeSpan> _throttle;
    private IScheduler _scheduler;
    private Func`2<TObject, TGroup> _groupSelector;
    public GroupOnPropertyWithImmutableState`2(IObservable`1<IChangeSet`1<TObject>> source, Expression`1<Func`2<TObject, TGroup>> groupSelectorKey, Nullable`1<TimeSpan> throttle, IScheduler scheduler);
    public IObservable`1<IChangeSet`1<IGrouping`2<TObject, TGroup>>> Run();
    [CompilerGeneratedAttribute]
private IObservable`1<IChangeSet`1<IGrouping`2<TObject, TGroup>>> <Run>b__6_0(IObservable`1<IChangeSet`1<TObject>> shared);
}
internal class DynamicData.List.Internal.ImmutableGroup`2 : object {
    private IReadOnlyCollection`1<TObject> _items;
    [CompilerGeneratedAttribute]
private TGroupKey <Key>k__BackingField;
    public TGroupKey Key { get; }
    public int Count { get; }
    public IEnumerable`1<TObject> Items { get; }
    internal ImmutableGroup`2(TGroupKey key, IList`1<TObject> items);
    [CompilerGeneratedAttribute]
public sealed virtual TGroupKey get_Key();
    public sealed virtual int get_Count();
    public sealed virtual IEnumerable`1<TObject> get_Items();
    public sealed virtual bool Equals(ImmutableGroup`2<TObject, TGroupKey> other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(ImmutableGroup`2<TObject, TGroupKey> left, ImmutableGroup`2<TObject, TGroupKey> right);
    public static bool op_Inequality(ImmutableGroup`2<TObject, TGroupKey> left, ImmutableGroup`2<TObject, TGroupKey> right);
    public virtual string ToString();
}
internal class DynamicData.List.Internal.LimitSizeTo`1 : object {
    private ISourceList`1<T> _sourceList;
    private IScheduler _scheduler;
    private object _locker;
    private int _sizeLimit;
    public LimitSizeTo`1(ISourceList`1<T> sourceList, int sizeLimit, IScheduler scheduler, object locker);
    public IObservable`1<IEnumerable`1<T>> Run();
}
internal class DynamicData.List.Internal.MergeMany`2 : object {
    private IObservable`1<IChangeSet`1<T>> _source;
    private Func`2<T, IObservable`1<TDestination>> _observableSelector;
    public MergeMany`2(IObservable`1<IChangeSet`1<T>> source, Func`2<T, IObservable`1<TDestination>> observableSelector);
    public IObservable`1<TDestination> Run();
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__3_0(IObserver`1<TDestination> observer);
}
internal class DynamicData.List.Internal.OnBeingAdded`1 : object {
    private IObservable`1<IChangeSet`1<T>> _source;
    private Action`1<T> _callback;
    public OnBeingAdded`1(IObservable`1<IChangeSet`1<T>> source, Action`1<T> callback);
    public IObservable`1<IChangeSet`1<T>> Run();
    private void RegisterForAddition(IChangeSet`1<T> changes);
}
internal class DynamicData.List.Internal.OnBeingRemoved`1 : object {
    private IObservable`1<IChangeSet`1<T>> _source;
    private Action`1<T> _callback;
    public OnBeingRemoved`1(IObservable`1<IChangeSet`1<T>> source, Action`1<T> callback);
    public IObservable`1<IChangeSet`1<T>> Run();
    private void RegisterForRemoval(IList`1<T> items, IChangeSet`1<T> changes);
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__3_0(IObserver`1<IChangeSet`1<T>> observer);
    [CompilerGeneratedAttribute]
private void <Run>b__3_3(T t);
    [CompilerGeneratedAttribute]
private void <RegisterForRemoval>b__4_0(T t);
}
internal class DynamicData.List.Internal.Pager`1 : object {
    private IObservable`1<IChangeSet`1<T>> _source;
    private IObservable`1<IPageRequest> _requests;
    public Pager`1(IObservable`1<IChangeSet`1<T>> source, IObservable`1<IPageRequest> requests);
    public IObservable`1<IPageChangeSet`1<T>> Run();
    private static PageChangeSet`1<T> CheckParametersAndPage(List`1<T> all, ChangeAwareList`1<T> paged, IPageRequest request);
    private static PageChangeSet`1<T> Page(List`1<T> all, ChangeAwareList`1<T> paged, IPageRequest request, IChangeSet`1<T> changeset);
    private static int CalculatePages(List`1<T> all, IPageRequest request);
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__3_0(IObserver`1<IPageChangeSet`1<T>> observer);
}
internal class DynamicData.List.Internal.QueryWhenChanged`1 : object {
    private IObservable`1<IChangeSet`1<T>> _source;
    public QueryWhenChanged`1(IObservable`1<IChangeSet`1<T>> source);
    public IObservable`1<IReadOnlyCollection`1<T>> Run();
}
internal class DynamicData.List.Internal.ReaderWriter`1 : object {
    private ChangeAwareList`1<T> _data;
    private object _locker;
    private bool _updateInProgress;
    public T[] Items { get; }
    public int Count { get; }
    public IChangeSet`1<T> Write(IChangeSet`1<T> changes);
    public IChangeSet`1<T> Write(Action`1<IExtendedList`1<T>> updateAction);
    public IChangeSet`1<T> WriteWithPreview(Action`1<IExtendedList`1<T>> updateAction, Action`1<IChangeSet`1<T>> previewHandler);
    public void WriteNested(Action`1<IExtendedList`1<T>> updateAction);
    public T[] get_Items();
    public int get_Count();
}
internal class DynamicData.List.Internal.RefCount`1 : object {
    private IObservable`1<IChangeSet`1<T>> _source;
    private object _locker;
    private int _refCount;
    private IObservableList`1<T> _list;
    public RefCount`1(IObservable`1<IChangeSet`1<T>> source);
    public IObservable`1<IChangeSet`1<T>> Run();
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__5_0(IObserver`1<IChangeSet`1<T>> observer);
}
[DefaultMemberAttribute("Item")]
internal class DynamicData.List.Internal.ReferenceCountTracker`1 : object {
    [CompilerGeneratedAttribute]
private Dictionary`2<T, int> <ReferenceCounts>k__BackingField;
    private Dictionary`2<T, int> ReferenceCounts { get; }
    public IEnumerable`1<T> Items { get; }
    public int Item { get; }
    [CompilerGeneratedAttribute]
private Dictionary`2<T, int> get_ReferenceCounts();
    public IEnumerable`1<T> get_Items();
    public int get_Item(T item);
    public bool Add(T item);
    public void Clear();
    public bool Remove(T item);
    public bool Contains(T item);
}
internal class DynamicData.List.Internal.Sort`1 : object {
    private IObservable`1<IChangeSet`1<T>> _source;
    private SortOptions _sortOptions;
    private int _resetThreshold;
    private IObservable`1<Unit> _resort;
    private IObservable`1<IComparer`1<T>> _comparerObservable;
    private IComparer`1<T> _comparer;
    public Sort`1(IObservable`1<IChangeSet`1<T>> source, IComparer`1<T> comparer, SortOptions sortOptions, IObservable`1<Unit> resort, IObservable`1<IComparer`1<T>> comparerObservable, int resetThreshold);
    public IObservable`1<IChangeSet`1<T>> Run();
    private IChangeSet`1<T> Process(ChangeAwareList`1<T> target, IChangeSet`1<T> changes);
    private IChangeSet`1<T> ProcessImpl(ChangeAwareList`1<T> target, IChangeSet`1<T> changes);
    private IChangeSet`1<T> Reorder(ChangeAwareList`1<T> target);
    private IChangeSet`1<T> ChangeComparer(ChangeAwareList`1<T> target, IComparer`1<T> comparer);
    private IChangeSet`1<T> Reset(List`1<T> original, ChangeAwareList`1<T> target);
    private void Remove(ChangeAwareList`1<T> target, T item);
    private void Insert(ChangeAwareList`1<T> target, T item);
    private int GetInsertPosition(ChangeAwareList`1<T> target, T item);
    private int GetInsertPositionLinear(ChangeAwareList`1<T> target, T item);
    private int GetInsertPositionBinary(ChangeAwareList`1<T> target, T item);
    private int GetCurrentPosition(ChangeAwareList`1<T> target, T item);
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__7_0(IObserver`1<IChangeSet`1<T>> observer);
}
internal class DynamicData.List.Internal.SubscribeMany`1 : object {
    private IObservable`1<IChangeSet`1<T>> _source;
    private Func`2<T, IDisposable> _subscriptionFactory;
    public SubscribeMany`1(IObservable`1<IChangeSet`1<T>> source, Func`2<T, IDisposable> subscriptionFactory);
    public IObservable`1<IChangeSet`1<T>> Run();
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__3_0(IObserver`1<IChangeSet`1<T>> observer);
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__3_1(T t);
}
internal class DynamicData.List.Internal.Switch`1 : object {
    private IObservable`1<IObservable`1<IChangeSet`1<T>>> _sources;
    public Switch`1(IObservable`1<IObservable`1<IChangeSet`1<T>>> sources);
    public IObservable`1<IChangeSet`1<T>> Run();
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__2_0(IObserver`1<IChangeSet`1<T>> observer);
}
internal class DynamicData.List.Internal.ToObservableChangeSet`1 : object {
    private IObservable`1<IEnumerable`1<T>> _source;
    private Func`2<T, Nullable`1<TimeSpan>> _expireAfter;
    private int _limitSizeTo;
    private IScheduler _scheduler;
    public ToObservableChangeSet`1(IObservable`1<T> source, Func`2<T, Nullable`1<TimeSpan>> expireAfter, int limitSizeTo, IScheduler scheduler);
    public ToObservableChangeSet`1(IObservable`1<IEnumerable`1<T>> source, Func`2<T, Nullable`1<TimeSpan>> expireAfter, int limitSizeTo, IScheduler scheduler);
    public IObservable`1<IChangeSet`1<T>> Run();
    private ExpirableItem`1<T> CreateExpirableItem(T latest, Int64& orderItemWasAdded);
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__6_0(IObserver`1<IChangeSet`1<T>> observer);
    [CompilerGeneratedAttribute]
private IObservable`1<IGrouping`2<ExpirableItem`1<T>, DateTime>> <Run>b__6_7(IGrouping`2<ExpirableItem`1<T>, DateTime> grouping);
}
internal class DynamicData.List.Internal.TransformAsync`2 : object {
    private IObservable`1<IChangeSet`1<TSource>> _source;
    private Func`2<TSource, Task`1<TransformedItemContainer<TSource, TDestination>>> _containerFactory;
    public TransformAsync`2(IObservable`1<IChangeSet`1<TSource>> source, Func`2<TSource, Task`1<TDestination>> factory);
    public IObservable`1<IChangeSet`1<TDestination>> Run();
    [AsyncStateMachineAttribute("DynamicData.List.Internal.TransformAsync`2/<Transform>d__4")]
private Task Transform(ChangeAwareList`1<TransformedItemContainer<TSource, TDestination>> transformed, IChangeSet`1<TSource> changes);
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__3_0(IObserver`1<IChangeSet`1<TDestination>> observer);
}
internal class DynamicData.List.Internal.Transformer`2 : object {
    private IObservable`1<IChangeSet`1<TSource>> _source;
    private Func`4<TSource, Optional`1<TDestination>, int, TransformedItemContainer<TSource, TDestination>> _containerFactory;
    private bool _transformOnRefresh;
    public Transformer`2(IObservable`1<IChangeSet`1<TSource>> source, Func`4<TSource, Optional`1<TDestination>, int, TDestination> factory, bool transformOnRefresh);
    public IObservable`1<IChangeSet`1<TDestination>> Run();
    private void Transform(ChangeAwareList`1<TransformedItemContainer<TSource, TDestination>> transformed, IChangeSet`1<TSource> changes);
    [CompilerGeneratedAttribute]
private ChangeAwareList`1<TransformedItemContainer<TSource, TDestination>> <Run>b__4_0(ChangeAwareList`1<TransformedItemContainer<TSource, TDestination>> state, IChangeSet`1<TSource> changes);
}
internal class DynamicData.List.Internal.TransformMany`2 : object {
    private IObservable`1<IChangeSet`1<TSource>> _source;
    private Func`2<TSource, IEnumerable`1<TDestination>> _manyselector;
    private Func`2<TSource, IObservable`1<IChangeSet`1<TDestination>>> _childChanges;
    private IEqualityComparer`1<TDestination> _equalityComparer;
    public TransformMany`2(IObservable`1<IChangeSet`1<TSource>> source, Func`2<TSource, ReadOnlyObservableCollection`1<TDestination>> manyselector, IEqualityComparer`1<TDestination> equalityComparer);
    public TransformMany`2(IObservable`1<IChangeSet`1<TSource>> source, Func`2<TSource, ObservableCollection`1<TDestination>> manyselector, IEqualityComparer`1<TDestination> equalityComparer);
    public TransformMany`2(IObservable`1<IChangeSet`1<TSource>> source, Func`2<TSource, IObservableList`1<TDestination>> manyselector, IEqualityComparer`1<TDestination> equalityComparer);
    public TransformMany`2(IObservable`1<IChangeSet`1<TSource>> source, Func`2<TSource, IEnumerable`1<TDestination>> manyselector, IEqualityComparer`1<TDestination> equalityComparer, Func`2<TSource, IObservable`1<IChangeSet`1<TDestination>>> childChanges);
    public IObservable`1<IChangeSet`1<TDestination>> Run();
    private IObservable`1<IChangeSet`1<TDestination>> CreateWithChangeset();
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__8_0(IObserver`1<IChangeSet`1<TDestination>> observer);
    [CompilerGeneratedAttribute]
private ManyContainer<TSource, TDestination> <Run>b__8_1(TSource item);
    [CompilerGeneratedAttribute]
private IDisposable <CreateWithChangeset>b__9_0(IObserver`1<IChangeSet`1<TDestination>> observer);
    [CompilerGeneratedAttribute]
private ManyContainer<TSource, TDestination> <CreateWithChangeset>b__9_1(TSource t);
    [CompilerGeneratedAttribute]
private ChangeSet`1<TDestination> <CreateWithChangeset>b__9_2(IChangeSet`1<ManyContainer<TSource, TDestination>> changes);
}
[IsReadOnlyAttribute]
internal class DynamicData.List.Internal.UnifiedChange`1 : ValueType {
    [CompilerGeneratedAttribute]
private ListChangeReason <Reason>k__BackingField;
    [CompilerGeneratedAttribute]
private T <Current>k__BackingField;
    [CompilerGeneratedAttribute]
private Optional`1<T> <Previous>k__BackingField;
    public ListChangeReason Reason { get; }
    public T Current { get; }
    public Optional`1<T> Previous { get; }
    public UnifiedChange`1(ListChangeReason reason, T current);
    public UnifiedChange`1(ListChangeReason reason, T current, Optional`1<T> previous);
    [CompilerGeneratedAttribute]
public ListChangeReason get_Reason();
    [CompilerGeneratedAttribute]
public T get_Current();
    [CompilerGeneratedAttribute]
public Optional`1<T> get_Previous();
    public sealed virtual bool Equals(UnifiedChange`1<T> other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(UnifiedChange`1<T> left, UnifiedChange`1<T> right);
    public static bool op_Inequality(UnifiedChange`1<T> left, UnifiedChange`1<T> right);
    public virtual string ToString();
}
internal class DynamicData.List.Internal.Virtualiser`1 : object {
    private IObservable`1<IChangeSet`1<T>> _source;
    private IObservable`1<IVirtualRequest> _requests;
    public Virtualiser`1(IObservable`1<IChangeSet`1<T>> source, IObservable`1<IVirtualRequest> requests);
    public IObservable`1<IVirtualChangeSet`1<T>> Run();
    private static IChangeSet`1<T> CheckParamsAndVirtualise(List`1<T> all, ChangeAwareList`1<T> virtualised, IVirtualRequest request);
    private static IChangeSet`1<T> Virtualise(List`1<T> all, ChangeAwareList`1<T> virtualised, IVirtualRequest request, IChangeSet`1<T> changeset);
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__3_0(IObserver`1<IVirtualChangeSet`1<T>> observer);
}
internal class DynamicData.List.Linq.AddKeyEnumerator`2 : object {
    private IChangeSet`1<TObject> _source;
    private Func`2<TObject, TKey> _keySelector;
    public AddKeyEnumerator`2(IChangeSet`1<TObject> source, Func`2<TObject, TKey> keySelector);
    [IteratorStateMachineAttribute("DynamicData.List.Linq.AddKeyEnumerator`2/<GetEnumerator>d__3")]
public sealed virtual IEnumerator`1<Change`2<TObject, TKey>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class DynamicData.List.Linq.ItemChangeEnumerator`1 : object {
    private IChangeSet`1<T> _changeSet;
    public ItemChangeEnumerator`1(IChangeSet`1<T> changeSet);
    [IteratorStateMachineAttribute("DynamicData.List.Linq.ItemChangeEnumerator`1/<GetEnumerator>d__2")]
public sealed virtual IEnumerator`1<ItemChange`1<T>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class DynamicData.List.Linq.Reverser`1 : object {
    private int _length;
    [IteratorStateMachineAttribute("DynamicData.List.Linq.Reverser`1/<Reverse>d__1")]
public IEnumerable`1<Change`1<T>> Reverse(IChangeSet`1<T> changes);
}
internal class DynamicData.List.Linq.UnifiedChangeEnumerator`1 : object {
    private IChangeSet`1<T> _changeSet;
    public UnifiedChangeEnumerator`1(IChangeSet`1<T> changeSet);
    [IteratorStateMachineAttribute("DynamicData.List.Linq.UnifiedChangeEnumerator`1/<GetEnumerator>d__2")]
public sealed virtual IEnumerator`1<UnifiedChange`1<T>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class DynamicData.List.Linq.WithoutIndexEnumerator`1 : object {
    private IEnumerable`1<Change`1<T>> _changeSet;
    public WithoutIndexEnumerator`1(IEnumerable`1<Change`1<T>> changeSet);
    [IteratorStateMachineAttribute("DynamicData.List.Linq.WithoutIndexEnumerator`1/<GetEnumerator>d__2")]
public sealed virtual IEnumerator`1<Change`1<T>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public enum DynamicData.ListChangeReason : Enum {
    public int value__;
    public static ListChangeReason Add;
    public static ListChangeReason AddRange;
    public static ListChangeReason Replace;
    public static ListChangeReason Remove;
    public static ListChangeReason RemoveRange;
    public static ListChangeReason Refresh;
    public static ListChangeReason Moved;
    public static ListChangeReason Clear;
}
[ExtensionAttribute]
public static class DynamicData.ListEx : object {
    [ExtensionAttribute]
internal static bool MovedWithinRange(Change`1<T> source, int startIndex, int endIndex);
    [ExtensionAttribute]
public static void Clone(IList`1<T> source, IChangeSet`1<T> changes);
    [ExtensionAttribute]
public static void Clone(IList`1<T> source, IChangeSet`1<T> changes, IEqualityComparer`1<T> equalityComparer);
    [ExtensionAttribute]
public static void Clone(IList`1<T> source, IEnumerable`1<Change`1<T>> changes, IEqualityComparer`1<T> equalityComparer);
    [ExtensionAttribute]
private static void Clone(IList`1<T> source, Change`1<T> item, IEqualityComparer`1<T> equalityComparer);
    [ExtensionAttribute]
internal static void ClearOrRemoveMany(IList`1<T> source, Change`1<T> change);
    [ExtensionAttribute]
public static int BinarySearch(IList`1<TItem> list, TItem value);
    [ExtensionAttribute]
public static int BinarySearch(IList`1<TItem> list, TItem value, IComparer`1<TItem> comparer);
    [ExtensionAttribute]
public static int BinarySearch(IList`1<TItem> list, TSearch value, Func`3<TSearch, TItem, int> comparer);
    [ExtensionAttribute]
public static Optional`1<ItemWithIndex`1<T>> IndexOfOptional(IEnumerable`1<T> source, T item, IEqualityComparer`1<T> equalityComparer);
    [ExtensionAttribute]
public static int IndexOf(IEnumerable`1<T> source, T item);
    [ExtensionAttribute]
public static int IndexOf(IEnumerable`1<T> source, T item, IEqualityComparer`1<T> equalityComparer);
    [ExtensionAttribute]
public static void Add(IList`1<T> source, IEnumerable`1<T> items);
    [ExtensionAttribute]
public static void AddRange(IList`1<T> source, IEnumerable`1<T> items);
    [ExtensionAttribute]
public static void AddRange(IList`1<T> source, IEnumerable`1<T> items, int index);
    [ExtensionAttribute]
public static void AddOrInsertRange(IList`1<T> source, IEnumerable`1<T> items, int index);
    [ExtensionAttribute]
public static void RemoveMany(IList`1<T> source, IEnumerable`1<T> itemsToRemove);
    [ExtensionAttribute]
private static void RemoveRange(IList`1<T> source, int index, int count);
    [ExtensionAttribute]
public static void Remove(IList`1<T> source, IEnumerable`1<T> items);
    [ExtensionAttribute]
public static void Replace(IList`1<T> source, T original, T replacewith);
    [ExtensionAttribute]
public static void ReplaceOrAdd(IList`1<T> source, T original, T replacewith);
    [ExtensionAttribute]
public static void Replace(IList`1<T> source, T original, T replaceWith, IEqualityComparer`1<T> comparer);
}
public enum DynamicData.ListFilterPolicy : Enum {
    public int value__;
    public static ListFilterPolicy ClearAndReplace;
    public static ListFilterPolicy CalculateDiff;
}
public class DynamicData.MissingKeyException : Exception {
    public MissingKeyException(string message);
    public MissingKeyException(string message, Exception innerException);
    protected MissingKeyException(SerializationInfo serializationInfo, StreamingContext streamingContext);
}
public class DynamicData.Node`2 : object {
    private ISourceCache`2<Node`2<TObject, TKey>, TKey> _children;
    private IDisposable _cleanUp;
    private bool _isDisposed;
    [CompilerGeneratedAttribute]
private TObject <Item>k__BackingField;
    [CompilerGeneratedAttribute]
private TKey <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private Optional`1<Node`2<TObject, TKey>> <Parent>k__BackingField;
    [CompilerGeneratedAttribute]
private IObservableCache`2<Node`2<TObject, TKey>, TKey> <Children>k__BackingField;
    public TObject Item { get; }
    public TKey Key { get; }
    public Optional`1<Node`2<TObject, TKey>> Parent { get; internal set; }
    public IObservableCache`2<Node`2<TObject, TKey>, TKey> Children { get; }
    public bool IsRoot { get; }
    public int Depth { get; }
    public Node`2(TObject item, TKey key);
    public Node`2(TObject item, TKey key, Optional`1<Node`2<TObject, TKey>> parent);
    [CompilerGeneratedAttribute]
public TObject get_Item();
    [CompilerGeneratedAttribute]
public TKey get_Key();
    [CompilerGeneratedAttribute]
public Optional`1<Node`2<TObject, TKey>> get_Parent();
    [CompilerGeneratedAttribute]
internal void set_Parent(Optional`1<Node`2<TObject, TKey>> value);
    [CompilerGeneratedAttribute]
public IObservableCache`2<Node`2<TObject, TKey>, TKey> get_Children();
    public bool get_IsRoot();
    public int get_Depth();
    internal void Update(Action`1<ISourceUpdater`2<Node`2<TObject, TKey>, TKey>> updateAction);
    public sealed virtual bool Equals(Node`2<TObject, TKey> other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(Node`2<TObject, TKey> left, Node`2<TObject, TKey> right);
    public static bool op_Inequality(Node`2<TObject, TKey> left, Node`2<TObject, TKey> right);
    public virtual string ToString();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool isDisposing);
}
internal class DynamicData.ObservableCache`2 : object {
    private Subject`1<ChangeSet`2<TObject, TKey>> _changes;
    private Subject`1<ChangeSet`2<TObject, TKey>> _changesPreview;
    private Lazy`1<ISubject`1<int>> _countChanged;
    private ReaderWriter`2<TObject, TKey> _readerWriter;
    private IDisposable _cleanUp;
    private object _locker;
    private int _editLevel;
    public IObservable`1<int> CountChanged { get; }
    public IEnumerable`1<TKey> Keys { get; }
    public IEnumerable`1<KeyValuePair`2<TKey, TObject>> KeyValues { get; }
    public IEnumerable`1<TObject> Items { get; }
    public int Count { get; }
    public ObservableCache`2(IObservable`1<IChangeSet`2<TObject, TKey>> source);
    public ObservableCache`2(Func`2<TObject, TKey> keySelector);
    internal void UpdateFromIntermediate(Action`1<ICacheUpdater`2<TObject, TKey>> updateAction);
    internal void UpdateFromSource(Action`1<ISourceUpdater`2<TObject, TKey>> updateAction);
    private void InvokePreview(ChangeSet`2<TObject, TKey> changes);
    private void InvokeNext(ChangeSet`2<TObject, TKey> changes);
    public sealed virtual IObservable`1<int> get_CountChanged();
    public sealed virtual IObservable`1<Change`2<TObject, TKey>> Watch(TKey key);
    public sealed virtual IObservable`1<IChangeSet`2<TObject, TKey>> Connect(Func`2<TObject, bool> predicate);
    public sealed virtual IObservable`1<IChangeSet`2<TObject, TKey>> Preview(Func`2<TObject, bool> predicate);
    internal ChangeSet`2<TObject, TKey> GetInitialUpdates(Func`2<TObject, bool> filter);
    public sealed virtual Optional`1<TObject> Lookup(TKey key);
    public sealed virtual IEnumerable`1<TKey> get_Keys();
    public sealed virtual IEnumerable`1<KeyValuePair`2<TKey, TObject>> get_KeyValues();
    public sealed virtual IEnumerable`1<TObject> get_Items();
    public sealed virtual int get_Count();
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
private void <.ctor>b__7_0();
    [CompilerGeneratedAttribute]
private void <.ctor>b__7_1(IChangeSet`2<TObject, TKey> changeset);
    [CompilerGeneratedAttribute]
private void <.ctor>b__7_2(Exception ex);
    [CompilerGeneratedAttribute]
private void <.ctor>b__8_0();
    [CompilerGeneratedAttribute]
private IDisposable <get_CountChanged>b__14_0(IObserver`1<int> observer);
}
[ExtensionAttribute]
public static class DynamicData.ObservableCacheEx : object {
    private static int DefaultSortResetThreshold;
    [ExtensionAttribute]
[ObsoleteAttribute("This can cause unhandled exception issues so do not use")]
public static IObservable`1<T> FinallySafe(IObservable`1<T> source, Action finallyAction);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> RefCount(IObservable`1<IChangeSet`2<TObject, TKey>> source);
    [ExtensionAttribute]
public static IObservable`1<ConnectionStatus> MonitorStatus(IObservable`1<T> source);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> NotEmpty(IObservable`1<IChangeSet`2<TObject, TKey>> source);
    [ExtensionAttribute]
internal static IObservable`1<IChangeSet`2<TObject, TKey>> NotEmpty_Experiment(IObservable`1<IChangeSet`2<TObject, TKey>> source);
    [ExtensionAttribute]
public static IObservable`1<Change`2<TObject, TKey>> Flatten(IObservable`1<IChangeSet`2<TObject, TKey>> source);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> ForEachChange(IObservable`1<IChangeSet`2<TObject, TKey>> source, Action`1<Change`2<TObject, TKey>> action);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> IgnoreSameReferenceUpdate(IObservable`1<IChangeSet`2<TObject, TKey>> source);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> IgnoreUpdateWhen(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`3<TObject, TObject, bool> ignoreFunction);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> IncludeUpdateWhen(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`3<TObject, TObject, bool> includeFunction);
    [ExtensionAttribute]
public static IObservable`1<ItemWithValue`2<TObject, TDestination>> MergeManyItems(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, IObservable`1<TDestination>> observableSelector);
    [ExtensionAttribute]
public static IObservable`1<ItemWithValue`2<TObject, TDestination>> MergeManyItems(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`3<TObject, TKey, IObservable`1<TDestination>> observableSelector);
    [ExtensionAttribute]
public static IObservable`1<TDestination> MergeMany(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, IObservable`1<TDestination>> observableSelector);
    [ExtensionAttribute]
public static IObservable`1<TDestination> MergeMany(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`3<TObject, TKey, IObservable`1<TDestination>> observableSelector);
    [ExtensionAttribute]
public static IObservable`1<TValue> WhenValueChanged(IObservable`1<IChangeSet`2<TObject, TKey>> source, Expression`1<Func`2<TObject, TValue>> propertyAccessor, bool notifyOnInitialValue);
    [ExtensionAttribute]
public static IObservable`1<PropertyValue`2<TObject, TValue>> WhenPropertyChanged(IObservable`1<IChangeSet`2<TObject, TKey>> source, Expression`1<Func`2<TObject, TValue>> propertyAccessor, bool notifyOnInitialValue);
    [ExtensionAttribute]
public static IObservable`1<TObject> WhenAnyPropertyChanged(IObservable`1<IChangeSet`2<TObject, TKey>> source, String[] propertiesToMonitor);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> SubscribeMany(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, IDisposable> subscriptionFactory);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> SubscribeMany(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`3<TObject, TKey, IDisposable> subscriptionFactory);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> OnItemAdded(IObservable`1<IChangeSet`2<TObject, TKey>> source, Action`1<TObject> addAction);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> OnItemRemoved(IObservable`1<IChangeSet`2<TObject, TKey>> source, Action`1<TObject> removeAction);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> OnItemUpdated(IObservable`1<IChangeSet`2<TObject, TKey>> source, Action`2<TObject, TObject> updateAction);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> DisposeMany(IObservable`1<IChangeSet`2<TObject, TKey>> source);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> WhereReasonsAre(IObservable`1<IChangeSet`2<TObject, TKey>> source, ChangeReason[] reasons);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> WhereReasonsAreNot(IObservable`1<IChangeSet`2<TObject, TKey>> source, ChangeReason[] reasons);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> AutoRefresh(IObservable`1<IChangeSet`2<TObject, TKey>> source, Nullable`1<TimeSpan> changeSetBuffer, Nullable`1<TimeSpan> propertyChangeThrottle, IScheduler scheduler);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> AutoRefresh(IObservable`1<IChangeSet`2<TObject, TKey>> source, Expression`1<Func`2<TObject, TProperty>> propertyAccessor, Nullable`1<TimeSpan> changeSetBuffer, Nullable`1<TimeSpan> propertyChangeThrottle, IScheduler scheduler);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> AutoRefreshOnObservable(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, IObservable`1<TAny>> reevaluator, Nullable`1<TimeSpan> changeSetBuffer, IScheduler scheduler);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> AutoRefreshOnObservable(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`3<TObject, TKey, IObservable`1<TAny>> reevaluator, Nullable`1<TimeSpan> changeSetBuffer, IScheduler scheduler);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> SupressRefresh(IObservable`1<IChangeSet`2<TObject, TKey>> source);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> StartWithEmpty(IObservable`1<IChangeSet`2<TObject, TKey>> source);
    [ExtensionAttribute]
public static IObservable`1<ISortedChangeSet`2<TObject, TKey>> StartWithEmpty(IObservable`1<ISortedChangeSet`2<TObject, TKey>> source);
    [ExtensionAttribute]
public static IObservable`1<IVirtualChangeSet`2<TObject, TKey>> StartWithEmpty(IObservable`1<IVirtualChangeSet`2<TObject, TKey>> source);
    [ExtensionAttribute]
public static IObservable`1<IPagedChangeSet`2<TObject, TKey>> StartWithEmpty(IObservable`1<IPagedChangeSet`2<TObject, TKey>> source);
    [ExtensionAttribute]
public static IObservable`1<IGroupChangeSet`3<TObject, TKey, TGroupKey>> StartWithEmpty(IObservable`1<IGroupChangeSet`3<TObject, TKey, TGroupKey>> source);
    [ExtensionAttribute]
public static IObservable`1<IImmutableGroupChangeSet`3<TObject, TKey, TGroupKey>> StartWithEmpty(IObservable`1<IImmutableGroupChangeSet`3<TObject, TKey, TGroupKey>> source);
    [ExtensionAttribute]
public static IObservable`1<IReadOnlyCollection`1<T>> StartWithEmpty(IObservable`1<IReadOnlyCollection`1<T>> source);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<TObject>> RemoveKey(IObservable`1<IChangeSet`2<TObject, TKey>> source);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TDestinationKey>> ChangeKey(IObservable`1<IChangeSet`2<TObject, TSourceKey>> source, Func`2<TObject, TDestinationKey> keySelector);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TDestinationKey>> ChangeKey(IObservable`1<IChangeSet`2<TObject, TSourceKey>> source, Func`3<TSourceKey, TObject, TDestinationKey> keySelector);
    [ExtensionAttribute]
[ObsoleteAttribute("This was an experiment that did not work. Use Transform instead")]
public static IObservable`1<IChangeSet`2<TDestination, TKey>> Convert(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, TDestination> conversionFactory);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TKey>> Cast(IObservable`1<IChangeSet`2<TSource, TKey>> source, Func`2<TSource, TDestination> converter);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> BufferInitial(IObservable`1<IChangeSet`2<TObject, TKey>> source, TimeSpan initalBuffer, IScheduler scheduler);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> Batch(IObservable`1<IChangeSet`2<TObject, TKey>> source, TimeSpan timeSpan, IScheduler scheduler);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> FlattenBufferResult(IObservable`1<IList`1<IChangeSet`2<TObject, TKey>>> source);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> BatchIf(IObservable`1<IChangeSet`2<TObject, TKey>> source, IObservable`1<bool> pauseIfTrueSelector, IScheduler scheduler);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> BatchIf(IObservable`1<IChangeSet`2<TObject, TKey>> source, IObservable`1<bool> pauseIfTrueSelector, bool intialPauseState, IScheduler scheduler);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> BatchIf(IObservable`1<IChangeSet`2<TObject, TKey>> source, IObservable`1<bool> pauseIfTrueSelector, Nullable`1<TimeSpan> timeOut, IScheduler scheduler);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> BatchIf(IObservable`1<IChangeSet`2<TObject, TKey>> source, IObservable`1<bool> pauseIfTrueSelector, bool intialPauseState, Nullable`1<TimeSpan> timeOut, IScheduler scheduler);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> BatchIf(IObservable`1<IChangeSet`2<TObject, TKey>> source, IObservable`1<bool> pauseIfTrueSelector, bool intialPauseState, IObservable`1<Unit> timer, IScheduler scheduler);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> SkipInitial(IObservable`1<IChangeSet`2<TObject, TKey>> source);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> DeferUntilLoaded(IObservable`1<IChangeSet`2<TObject, TKey>> source);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> DeferUntilLoaded(IObservableCache`2<TObject, TKey> source);
    [ExtensionAttribute]
public static IObservable`1<bool> TrueForAll(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, IObservable`1<TValue>> observableSelector, Func`2<TValue, bool> equalityCondition);
    [ExtensionAttribute]
public static IObservable`1<bool> TrueForAll(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, IObservable`1<TValue>> observableSelector, Func`3<TObject, TValue, bool> equalityCondition);
    [ExtensionAttribute]
public static IObservable`1<bool> TrueForAny(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, IObservable`1<TValue>> observableSelector, Func`3<TObject, TValue, bool> equalityCondition);
    [ExtensionAttribute]
public static IObservable`1<bool> TrueForAny(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, IObservable`1<TValue>> observableSelector, Func`2<TValue, bool> equalityCondition);
    [ExtensionAttribute]
private static IObservable`1<bool> TrueFor(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, IObservable`1<TValue>> observableSelector, Func`2<IEnumerable`1<ObservableWithValue`2<TObject, TValue>>, bool> collectionMatcher);
    [ExtensionAttribute]
public static IObservable`1<TDestination> QueryWhenChanged(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<IQuery`2<TObject, TKey>, TDestination> resultSelector);
    [ExtensionAttribute]
public static IObservable`1<IQuery`2<TObject, TKey>> QueryWhenChanged(IObservable`1<IChangeSet`2<TObject, TKey>> source);
    [ExtensionAttribute]
public static IObservable`1<IQuery`2<TObject, TKey>> QueryWhenChanged(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, IObservable`1<TValue>> itemChangedTrigger);
    [ExtensionAttribute]
public static IObservable`1<IReadOnlyCollection`1<TObject>> ToCollection(IObservable`1<IChangeSet`2<TObject, TKey>> source);
    [ExtensionAttribute]
public static IObservable`1<IReadOnlyCollection`1<TObject>> ToSortedCollection(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, TSortKey> sort, SortDirection sortOrder);
    [ExtensionAttribute]
public static IObservable`1<IReadOnlyCollection`1<TObject>> ToSortedCollection(IObservable`1<IChangeSet`2<TObject, TKey>> source, IComparer`1<TObject> comparer);
    [ExtensionAttribute]
public static IObservable`1<TObject> WatchValue(IObservableCache`2<TObject, TKey> source, TKey key);
    [ExtensionAttribute]
public static IObservable`1<TObject> WatchValue(IObservable`1<IChangeSet`2<TObject, TKey>> source, TKey key);
    [ExtensionAttribute]
public static IObservable`1<Change`2<TObject, TKey>> Watch(IObservable`1<IChangeSet`2<TObject, TKey>> source, TKey key);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> Clone(IObservable`1<IChangeSet`2<TObject, TKey>> source, ICollection`1<TObject> target);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> ExpireAfter(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, Nullable`1<TimeSpan>> timeSelector);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> ExpireAfter(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, Nullable`1<TimeSpan>> timeSelector, IScheduler scheduler);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> ExpireAfter(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, Nullable`1<TimeSpan>> timeSelector, Nullable`1<TimeSpan> pollingInterval);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> ExpireAfter(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, Nullable`1<TimeSpan>> timeSelector, Nullable`1<TimeSpan> pollingInterval, IScheduler scheduler);
    [ExtensionAttribute]
internal static IObservable`1<IEnumerable`1<KeyValuePair`2<TKey, TObject>>> ForExpiry(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, Nullable`1<TimeSpan>> timeSelector, Nullable`1<TimeSpan> interval, IScheduler scheduler);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> LimitSizeTo(IObservable`1<IChangeSet`2<TObject, TKey>> source, int size);
    [ExtensionAttribute]
public static IObservable`1<IPagedChangeSet`2<TObject, TKey>> Page(IObservable`1<ISortedChangeSet`2<TObject, TKey>> source, IObservable`1<IPageRequest> pageRequests);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> Filter(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, bool> filter);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> Filter(IObservable`1<IChangeSet`2<TObject, TKey>> source, IObservable`1<Func`2<TObject, bool>> predicateChanged);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> Filter(IObservable`1<IChangeSet`2<TObject, TKey>> source, IObservable`1<Unit> reapplyFilter);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> Filter(IObservable`1<IChangeSet`2<TObject, TKey>> source, IObservable`1<Func`2<TObject, bool>> predicateChanged, IObservable`1<Unit> reapplyFilter);
    [ExtensionAttribute]
[ObsoleteAttribute("Use AutoRefresh(), followed by Filter() instead")]
public static IObservable`1<IChangeSet`2<TObject, TKey>> FilterOnProperty(IObservable`1<IChangeSet`2<TObject, TKey>> source, Expression`1<Func`2<TObject, TProperty>> propertySelector, Func`2<TObject, bool> predicate, Nullable`1<TimeSpan> propertyChangedThrottle, IScheduler scheduler);
    [ExtensionAttribute]
public static IObservable`1<ISortedChangeSet`2<TObject, TKey>> UpdateIndex(IObservable`1<ISortedChangeSet`2<TObject, TKey>> source);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> InvokeEvaluate(IObservable`1<IChangeSet`2<TObject, TKey>> source);
    [ExtensionAttribute]
public static IObservable`1<ISortedChangeSet`2<TObject, TKey>> Sort(IObservable`1<IChangeSet`2<TObject, TKey>> source, IComparer`1<TObject> comparer, SortOptimisations sortOptimisations, int resetThreshold);
    [ExtensionAttribute]
public static IObservable`1<ISortedChangeSet`2<TObject, TKey>> Sort(IObservable`1<IChangeSet`2<TObject, TKey>> source, IObservable`1<IComparer`1<TObject>> comparerObservable, SortOptimisations sortOptimisations, int resetThreshold);
    [ExtensionAttribute]
public static IObservable`1<ISortedChangeSet`2<TObject, TKey>> Sort(IObservable`1<IChangeSet`2<TObject, TKey>> source, IObservable`1<IComparer`1<TObject>> comparerObservable, IObservable`1<Unit> resorter, SortOptimisations sortOptimisations, int resetThreshold);
    [ExtensionAttribute]
public static IObservable`1<ISortedChangeSet`2<TObject, TKey>> Sort(IObservable`1<IChangeSet`2<TObject, TKey>> source, IComparer`1<TObject> comparer, IObservable`1<Unit> resorter, SortOptimisations sortOptimisations, int resetThreshold);
    [ExtensionAttribute]
public static IObservable`1<ISortedChangeSet`2<TObject, TKey>> TreatMovesAsRemoveAdd(IObservable`1<ISortedChangeSet`2<TObject, TKey>> source);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> And(IObservable`1<IChangeSet`2<TObject, TKey>> source, IObservable`1[] others);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> And(ICollection`1<IObservable`1<IChangeSet`2<TObject, TKey>>> sources);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> And(IObservableList`1<IObservable`1<IChangeSet`2<TObject, TKey>>> sources);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> And(IObservableList`1<IObservableCache`2<TObject, TKey>> sources);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> And(IObservableList`1<ISourceCache`2<TObject, TKey>> sources);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> Or(IObservable`1<IChangeSet`2<TObject, TKey>> source, IObservable`1[] others);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> Or(ICollection`1<IObservable`1<IChangeSet`2<TObject, TKey>>> sources);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> Or(IObservableList`1<IObservable`1<IChangeSet`2<TObject, TKey>>> sources);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> Or(IObservableList`1<IObservableCache`2<TObject, TKey>> sources);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> Or(IObservableList`1<ISourceCache`2<TObject, TKey>> sources);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> Xor(IObservable`1<IChangeSet`2<TObject, TKey>> source, IObservable`1[] others);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> Xor(ICollection`1<IObservable`1<IChangeSet`2<TObject, TKey>>> sources);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> Xor(IObservableList`1<IObservable`1<IChangeSet`2<TObject, TKey>>> sources);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> Xor(IObservableList`1<IObservableCache`2<TObject, TKey>> sources);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> Xor(IObservableList`1<ISourceCache`2<TObject, TKey>> sources);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> Except(IObservable`1<IChangeSet`2<TObject, TKey>> source, IObservable`1[] others);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> Except(ICollection`1<IObservable`1<IChangeSet`2<TObject, TKey>>> sources);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> Except(IObservableList`1<IObservable`1<IChangeSet`2<TObject, TKey>>> sources);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> Except(IObservableList`1<IObservableCache`2<TObject, TKey>> sources);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> Except(IObservableList`1<ISourceCache`2<TObject, TKey>> sources);
    [ExtensionAttribute]
private static IObservable`1<IChangeSet`2<TObject, TKey>> Combine(IObservableList`1<IObservableCache`2<TObject, TKey>> source, CombineOperator type);
    [ExtensionAttribute]
private static IObservable`1<IChangeSet`2<TObject, TKey>> Combine(IObservableList`1<ISourceCache`2<TObject, TKey>> source, CombineOperator type);
    [ExtensionAttribute]
private static IObservable`1<IChangeSet`2<TObject, TKey>> Combine(IObservableList`1<IObservable`1<IChangeSet`2<TObject, TKey>>> source, CombineOperator type);
    [ExtensionAttribute]
private static IObservable`1<IChangeSet`2<TObject, TKey>> Combine(ICollection`1<IObservable`1<IChangeSet`2<TObject, TKey>>> sources, CombineOperator type);
    [ExtensionAttribute]
private static IObservable`1<IChangeSet`2<TObject, TKey>> Combine(IObservable`1<IChangeSet`2<TObject, TKey>> source, CombineOperator type, IObservable`1[] combinetarget);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> StartWithItem(IObservable`1<IChangeSet`2<TObject, TKey>> source, TObject item);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> StartWithItem(IObservable`1<IChangeSet`2<TObject, TKey>> source, TObject item, TKey key);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TKey>> Transform(IObservable`1<IChangeSet`2<TSource, TKey>> source, Func`2<TSource, TDestination> transformFactory, bool transformOnRefresh);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TKey>> Transform(IObservable`1<IChangeSet`2<TSource, TKey>> source, Func`3<TSource, TKey, TDestination> transformFactory, bool transformOnRefresh);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TKey>> Transform(IObservable`1<IChangeSet`2<TSource, TKey>> source, Func`4<TSource, Optional`1<TSource>, TKey, TDestination> transformFactory, bool transformOnRefresh);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TKey>> Transform(IObservable`1<IChangeSet`2<TSource, TKey>> source, Func`2<TSource, TDestination> transformFactory, IObservable`1<Func`2<TSource, bool>> forceTransform);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TKey>> Transform(IObservable`1<IChangeSet`2<TSource, TKey>> source, Func`3<TSource, TKey, TDestination> transformFactory, IObservable`1<Func`3<TSource, TKey, bool>> forceTransform);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TKey>> Transform(IObservable`1<IChangeSet`2<TSource, TKey>> source, Func`4<TSource, Optional`1<TSource>, TKey, TDestination> transformFactory, IObservable`1<Func`3<TSource, TKey, bool>> forceTransform);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TKey>> Transform(IObservable`1<IChangeSet`2<TSource, TKey>> source, Func`2<TSource, TDestination> transformFactory, IObservable`1<Unit> forceTransform);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TKey>> Transform(IObservable`1<IChangeSet`2<TSource, TKey>> source, Func`3<TSource, TKey, TDestination> transformFactory, IObservable`1<Unit> forceTransform);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TKey>> Transform(IObservable`1<IChangeSet`2<TSource, TKey>> source, Func`4<TSource, Optional`1<TSource>, TKey, TDestination> transformFactory, IObservable`1<Unit> forceTransform);
    [ExtensionAttribute]
private static IObservable`1<Func`3<TSource, TKey, bool>> ForForced(IObservable`1<Unit> source);
    [ExtensionAttribute]
private static IObservable`1<Func`3<TSource, TKey, bool>> ForForced(IObservable`1<Func`2<TSource, bool>> source);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TKey>> TransformAsync(IObservable`1<IChangeSet`2<TSource, TKey>> source, Func`2<TSource, Task`1<TDestination>> transformFactory, IObservable`1<Func`3<TSource, TKey, bool>> forceTransform, int maximumConcurrency);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TKey>> TransformAsync(IObservable`1<IChangeSet`2<TSource, TKey>> source, Func`3<TSource, TKey, Task`1<TDestination>> transformFactory, int maximumConcurrency, IObservable`1<Func`3<TSource, TKey, bool>> forceTransform);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TKey>> TransformAsync(IObservable`1<IChangeSet`2<TSource, TKey>> source, Func`4<TSource, Optional`1<TSource>, TKey, Task`1<TDestination>> transformFactory, int maximumConcurrency, IObservable`1<Func`3<TSource, TKey, bool>> forceTransform);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TDestinationKey>> TransformMany(IObservable`1<IChangeSet`2<TSource, TSourceKey>> source, Func`2<TSource, IEnumerable`1<TDestination>> manyselector, Func`2<TDestination, TDestinationKey> keySelector);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TDestinationKey>> TransformMany(IObservable`1<IChangeSet`2<TSource, TSourceKey>> source, Func`2<TSource, ObservableCollection`1<TDestination>> manyselector, Func`2<TDestination, TDestinationKey> keySelector);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TDestinationKey>> TransformMany(IObservable`1<IChangeSet`2<TSource, TSourceKey>> source, Func`2<TSource, ReadOnlyObservableCollection`1<TDestination>> manyselector, Func`2<TDestination, TDestinationKey> keySelector);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TKey>> TransformSafe(IObservable`1<IChangeSet`2<TSource, TKey>> source, Func`2<TSource, TDestination> transformFactory, Action`1<Error`2<TSource, TKey>> errorHandler, IObservable`1<Func`2<TSource, bool>> forceTransform);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TKey>> TransformSafe(IObservable`1<IChangeSet`2<TSource, TKey>> source, Func`3<TSource, TKey, TDestination> transformFactory, Action`1<Error`2<TSource, TKey>> errorHandler, IObservable`1<Func`3<TSource, TKey, bool>> forceTransform);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TKey>> TransformSafe(IObservable`1<IChangeSet`2<TSource, TKey>> source, Func`4<TSource, Optional`1<TSource>, TKey, TDestination> transformFactory, Action`1<Error`2<TSource, TKey>> errorHandler, IObservable`1<Func`3<TSource, TKey, bool>> forceTransform);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TKey>> TransformSafe(IObservable`1<IChangeSet`2<TSource, TKey>> source, Func`2<TSource, TDestination> transformFactory, Action`1<Error`2<TSource, TKey>> errorHandler, IObservable`1<Unit> forceTransform);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TKey>> TransformSafe(IObservable`1<IChangeSet`2<TSource, TKey>> source, Func`3<TSource, TKey, TDestination> transformFactory, Action`1<Error`2<TSource, TKey>> errorHandler, IObservable`1<Unit> forceTransform);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TKey>> TransformSafe(IObservable`1<IChangeSet`2<TSource, TKey>> source, Func`4<TSource, Optional`1<TSource>, TKey, TDestination> transformFactory, Action`1<Error`2<TSource, TKey>> errorHandler, IObservable`1<Unit> forceTransform);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TKey>> TransformSafeAsync(IObservable`1<IChangeSet`2<TSource, TKey>> source, Func`2<TSource, Task`1<TDestination>> transformFactory, Action`1<Error`2<TSource, TKey>> errorHandler, IObservable`1<Func`3<TSource, TKey, bool>> forceTransform, int maximumConcurrency);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TKey>> TransformSafeAsync(IObservable`1<IChangeSet`2<TSource, TKey>> source, Func`3<TSource, TKey, Task`1<TDestination>> transformFactory, Action`1<Error`2<TSource, TKey>> errorHandler, int maximumConcurrency, IObservable`1<Func`3<TSource, TKey, bool>> forceTransform);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TKey>> TransformSafeAsync(IObservable`1<IChangeSet`2<TSource, TKey>> source, Func`4<TSource, Optional`1<TSource>, TKey, Task`1<TDestination>> transformFactory, Action`1<Error`2<TSource, TKey>> errorHandler, int maximumConcurrency, IObservable`1<Func`3<TSource, TKey, bool>> forceTransform);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<Node`2<TObject, TKey>, TKey>> TransformToTree(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, TKey> pivotOn, IObservable`1<Func`2<Node`2<TObject, TKey>, bool>> predicateChanged);
    [ExtensionAttribute]
public static IObservable`1<IDistinctChangeSet`1<TValue>> DistinctValues(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, TValue> valueSelector);
    [ExtensionAttribute]
public static IObservable`1<IGroupChangeSet`3<TObject, TKey, TGroupKey>> Group(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, TGroupKey> groupSelector, IObservable`1<IDistinctChangeSet`1<TGroupKey>> resultGroupSource);
    [ExtensionAttribute]
public static IObservable`1<IGroupChangeSet`3<TObject, TKey, TGroupKey>> Group(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, TGroupKey> groupSelectorKey);
    [ExtensionAttribute]
public static IObservable`1<IGroupChangeSet`3<TObject, TKey, TGroupKey>> Group(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, TGroupKey> groupSelectorKey, IObservable`1<Unit> regrouper);
    [ExtensionAttribute]
public static IObservable`1<IImmutableGroupChangeSet`3<TObject, TKey, TGroupKey>> GroupWithImmutableState(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, TGroupKey> groupSelectorKey, IObservable`1<Unit> regrouper);
    [ExtensionAttribute]
public static IObservable`1<IGroupChangeSet`3<TObject, TKey, TGroupKey>> GroupOnProperty(IObservable`1<IChangeSet`2<TObject, TKey>> source, Expression`1<Func`2<TObject, TGroupKey>> propertySelector, Nullable`1<TimeSpan> propertyChangedThrottle, IScheduler scheduler);
    [ExtensionAttribute]
public static IObservable`1<IImmutableGroupChangeSet`3<TObject, TKey, TGroupKey>> GroupOnPropertyWithImmutableState(IObservable`1<IChangeSet`2<TObject, TKey>> source, Expression`1<Func`2<TObject, TGroupKey>> propertySelector, Nullable`1<TimeSpan> propertyChangedThrottle, IScheduler scheduler);
    [ExtensionAttribute]
public static IObservable`1<IVirtualChangeSet`2<TObject, TKey>> Top(IObservable`1<ISortedChangeSet`2<TObject, TKey>> source, int size);
    [ExtensionAttribute]
public static IObservable`1<IVirtualChangeSet`2<TObject, TKey>> Top(IObservable`1<IChangeSet`2<TObject, TKey>> source, IComparer`1<TObject> comparer, int size);
    [ExtensionAttribute]
public static IObservable`1<IVirtualChangeSet`2<TObject, TKey>> Virtualise(IObservable`1<ISortedChangeSet`2<TObject, TKey>> source, IObservable`1<IVirtualRequest> virtualRequests);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> Bind(IObservable`1<IChangeSet`2<TObject, TKey>> source, IObservableCollection`1<TObject> destination);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> Bind(IObservable`1<IChangeSet`2<TObject, TKey>> source, IObservableCollection`1<TObject> destination, IObservableCollectionAdaptor`2<TObject, TKey> updater);
    [ExtensionAttribute]
public static IObservable`1<ISortedChangeSet`2<TObject, TKey>> Bind(IObservable`1<ISortedChangeSet`2<TObject, TKey>> source, IObservableCollection`1<TObject> destination);
    [ExtensionAttribute]
public static IObservable`1<ISortedChangeSet`2<TObject, TKey>> Bind(IObservable`1<ISortedChangeSet`2<TObject, TKey>> source, IObservableCollection`1<TObject> destination, ISortedObservableCollectionAdaptor`2<TObject, TKey> updater);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> Bind(IObservable`1<ISortedChangeSet`2<TObject, TKey>> source, ReadOnlyObservableCollection`1& readOnlyObservableCollection, int resetThreshold, ISortedObservableCollectionAdaptor`2<TObject, TKey> adaptor);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> Bind(IObservable`1<IChangeSet`2<TObject, TKey>> source, ReadOnlyObservableCollection`1& readOnlyObservableCollection, int resetThreshold, IObservableCollectionAdaptor`2<TObject, TKey> adaptor);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> Bind(IObservable`1<IChangeSet`2<TObject, TKey>> source, BindingList`1<TObject> bindingList, int resetThreshold);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> Bind(IObservable`1<ISortedChangeSet`2<TObject, TKey>> source, BindingList`1<TObject> bindingList, int resetThreshold);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> Adapt(IObservable`1<IChangeSet`2<TObject, TKey>> source, IChangeSetAdaptor`2<TObject, TKey> adaptor);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> Adapt(IObservable`1<ISortedChangeSet`2<TObject, TKey>> source, ISortedChangeSetAdaptor`2<TObject, TKey> adaptor);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TLeftKey>> InnerJoin(IObservable`1<IChangeSet`2<TLeft, TLeftKey>> left, IObservable`1<IChangeSet`2<TRight, TRightKey>> right, Func`2<TRight, TLeftKey> rightKeySelector, Func`3<TLeft, TRight, TDestination> resultSelector);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TLeftKey>> InnerJoin(IObservable`1<IChangeSet`2<TLeft, TLeftKey>> left, IObservable`1<IChangeSet`2<TRight, TRightKey>> right, Func`2<TRight, TLeftKey> rightKeySelector, Func`4<TLeftKey, TLeft, TRight, TDestination> resultSelector);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TLeftKey>> InnerJoinMany(IObservable`1<IChangeSet`2<TLeft, TLeftKey>> left, IObservable`1<IChangeSet`2<TRight, TRightKey>> right, Func`2<TRight, TLeftKey> rightKeySelector, Func`3<TLeft, IGrouping`3<TRight, TRightKey, TLeftKey>, TDestination> resultSelector);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TLeftKey>> InnerJoinMany(IObservable`1<IChangeSet`2<TLeft, TLeftKey>> left, IObservable`1<IChangeSet`2<TRight, TRightKey>> right, Func`2<TRight, TLeftKey> rightKeySelector, Func`4<TLeftKey, TLeft, IGrouping`3<TRight, TRightKey, TLeftKey>, TDestination> resultSelector);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TLeftKey>> FullJoin(IObservable`1<IChangeSet`2<TLeft, TLeftKey>> left, IObservable`1<IChangeSet`2<TRight, TRightKey>> right, Func`2<TRight, TLeftKey> rightKeySelector, Func`3<Optional`1<TLeft>, Optional`1<TRight>, TDestination> resultSelector);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TLeftKey>> FullJoin(IObservable`1<IChangeSet`2<TLeft, TLeftKey>> left, IObservable`1<IChangeSet`2<TRight, TRightKey>> right, Func`2<TRight, TLeftKey> rightKeySelector, Func`4<TLeftKey, Optional`1<TLeft>, Optional`1<TRight>, TDestination> resultSelector);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TLeftKey>> FullJoinMany(IObservable`1<IChangeSet`2<TLeft, TLeftKey>> left, IObservable`1<IChangeSet`2<TRight, TRightKey>> right, Func`2<TRight, TLeftKey> rightKeySelector, Func`3<Optional`1<TLeft>, IGrouping`3<TRight, TRightKey, TLeftKey>, TDestination> resultSelector);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TLeftKey>> FullJoinMany(IObservable`1<IChangeSet`2<TLeft, TLeftKey>> left, IObservable`1<IChangeSet`2<TRight, TRightKey>> right, Func`2<TRight, TLeftKey> rightKeySelector, Func`4<TLeftKey, Optional`1<TLeft>, IGrouping`3<TRight, TRightKey, TLeftKey>, TDestination> resultSelector);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TLeftKey>> LeftJoin(IObservable`1<IChangeSet`2<TLeft, TLeftKey>> left, IObservable`1<IChangeSet`2<TRight, TRightKey>> right, Func`2<TRight, TLeftKey> rightKeySelector, Func`3<TLeft, Optional`1<TRight>, TDestination> resultSelector);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TLeftKey>> LeftJoin(IObservable`1<IChangeSet`2<TLeft, TLeftKey>> left, IObservable`1<IChangeSet`2<TRight, TRightKey>> right, Func`2<TRight, TLeftKey> rightKeySelector, Func`4<TLeftKey, TLeft, Optional`1<TRight>, TDestination> resultSelector);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TLeftKey>> LeftJoinMany(IObservable`1<IChangeSet`2<TLeft, TLeftKey>> left, IObservable`1<IChangeSet`2<TRight, TRightKey>> right, Func`2<TRight, TLeftKey> rightKeySelector, Func`3<TLeft, IGrouping`3<TRight, TRightKey, TLeftKey>, TDestination> resultSelector);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TLeftKey>> LeftJoinMany(IObservable`1<IChangeSet`2<TLeft, TLeftKey>> left, IObservable`1<IChangeSet`2<TRight, TRightKey>> right, Func`2<TRight, TLeftKey> rightKeySelector, Func`4<TLeftKey, TLeft, IGrouping`3<TRight, TRightKey, TLeftKey>, TDestination> resultSelector);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TLeftKey>> RightJoin(IObservable`1<IChangeSet`2<TLeft, TLeftKey>> left, IObservable`1<IChangeSet`2<TRight, TRightKey>> right, Func`2<TRight, TLeftKey> rightKeySelector, Func`3<Optional`1<TLeft>, TRight, TDestination> resultSelector);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TLeftKey>> RightJoin(IObservable`1<IChangeSet`2<TLeft, TLeftKey>> left, IObservable`1<IChangeSet`2<TRight, TRightKey>> right, Func`2<TRight, TLeftKey> rightKeySelector, Func`4<TLeftKey, Optional`1<TLeft>, TRight, TDestination> resultSelector);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TLeftKey>> RightJoinMany(IObservable`1<IChangeSet`2<TLeft, TLeftKey>> left, IObservable`1<IChangeSet`2<TRight, TRightKey>> right, Func`2<TRight, TLeftKey> rightKeySelector, Func`3<Optional`1<TLeft>, IGrouping`3<TRight, TRightKey, TLeftKey>, TDestination> resultSelector);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TLeftKey>> RightJoinMany(IObservable`1<IChangeSet`2<TLeft, TLeftKey>> left, IObservable`1<IChangeSet`2<TRight, TRightKey>> right, Func`2<TRight, TLeftKey> rightKeySelector, Func`4<TLeftKey, Optional`1<TLeft>, IGrouping`3<TRight, TRightKey, TLeftKey>, TDestination> resultSelector);
    [ExtensionAttribute]
public static IDisposable PopulateInto(IObservable`1<IChangeSet`2<TObject, TKey>> source, ISourceCache`2<TObject, TKey> detination);
    [ExtensionAttribute]
public static IDisposable PopulateInto(IObservable`1<IChangeSet`2<TObject, TKey>> source, IIntermediateCache`2<TObject, TKey> detination);
    [ExtensionAttribute]
public static IDisposable PopulateFrom(ISourceCache`2<TObject, TKey> source, IObservable`1<IEnumerable`1<TObject>> observable);
    [ExtensionAttribute]
public static IDisposable PopulateFrom(ISourceCache`2<TObject, TKey> source, IObservable`1<TObject> observable);
    [ExtensionAttribute]
public static IObservableCache`2<TObject, TKey> AsObservableCache(IObservableCache`2<TObject, TKey> source);
    [ExtensionAttribute]
public static IObservableCache`2<TObject, TKey> AsObservableCache(IObservable`1<IChangeSet`2<TObject, TKey>> source, bool applyLocking);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> ToObservableChangeSet(IObservable`1<TObject> source, Func`2<TObject, TKey> keySelector, Func`2<TObject, Nullable`1<TimeSpan>> expireAfter, int limitSizeTo, IScheduler scheduler);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> ToObservableChangeSet(IObservable`1<IEnumerable`1<TObject>> source, Func`2<TObject, TKey> keySelector, Func`2<TObject, Nullable`1<TimeSpan>> expireAfter, int limitSizeTo, IScheduler scheduler);
    [ExtensionAttribute]
public static IObservable`1<IEnumerable`1<KeyValuePair`2<TKey, TObject>>> LimitSizeTo(ISourceCache`2<TObject, TKey> source, int sizeLimit, IScheduler scheduler);
    [ExtensionAttribute]
public static IObservable`1<IEnumerable`1<KeyValuePair`2<TKey, TObject>>> ExpireAfter(ISourceCache`2<TObject, TKey> source, Func`2<TObject, Nullable`1<TimeSpan>> timeSelector, IScheduler scheduler);
    [ExtensionAttribute]
public static IObservable`1<IEnumerable`1<KeyValuePair`2<TKey, TObject>>> ExpireAfter(ISourceCache`2<TObject, TKey> source, Func`2<TObject, Nullable`1<TimeSpan>> timeSelector, Nullable`1<TimeSpan> interval);
    [ExtensionAttribute]
public static IObservable`1<IEnumerable`1<KeyValuePair`2<TKey, TObject>>> ExpireAfter(ISourceCache`2<TObject, TKey> source, Func`2<TObject, Nullable`1<TimeSpan>> timeSelector, Nullable`1<TimeSpan> pollingInterval, IScheduler scheduler);
    [ExtensionAttribute]
public static void EditDiff(ISourceCache`2<TObject, TKey> source, IEnumerable`1<TObject> alltems, IEqualityComparer`1<TObject> equalityComparer);
    [ExtensionAttribute]
public static void EditDiff(ISourceCache`2<TObject, TKey> source, IEnumerable`1<TObject> alltems, Func`3<TObject, TObject, bool> areItemsEqual);
    [ExtensionAttribute]
public static void AddOrUpdate(ISourceCache`2<TObject, TKey> source, TObject item);
    [ExtensionAttribute]
public static void AddOrUpdate(ISourceCache`2<TObject, TKey> source, TObject item, IEqualityComparer`1<TObject> equalityComparer);
    [ExtensionAttribute]
public static void AddOrUpdate(ISourceCache`2<TObject, TKey> source, IEnumerable`1<TObject> items);
    [ExtensionAttribute]
public static void Remove(ISourceCache`2<TObject, TKey> source, TObject item);
    [ExtensionAttribute]
public static void Remove(ISourceCache`2<TObject, TKey> source, TKey key);
    [ExtensionAttribute]
public static void RemoveKey(ISourceCache`2<TObject, TKey> source, TKey key);
    [ExtensionAttribute]
public static void Remove(ISourceCache`2<TObject, TKey> source, IEnumerable`1<TObject> items);
    [ExtensionAttribute]
public static void Remove(ISourceCache`2<TObject, TKey> source, IEnumerable`1<TKey> keys);
    [ExtensionAttribute]
public static void RemoveKeys(ISourceCache`2<TObject, TKey> source, IEnumerable`1<TKey> keys);
    [ExtensionAttribute]
public static void Clear(ISourceCache`2<TObject, TKey> source);
    [ExtensionAttribute]
public static void Refresh(ISourceCache`2<TObject, TKey> source, TObject item);
    [ExtensionAttribute]
public static void Refresh(ISourceCache`2<TObject, TKey> source, IEnumerable`1<TObject> items);
    [ExtensionAttribute]
public static void Refresh(ISourceCache`2<TObject, TKey> source);
    [ExtensionAttribute]
[ObsoleteAttribute("Use Refresh: Same thing but better semantics")]
public static void Evaluate(ISourceCache`2<TObject, TKey> source, TObject item);
    [ExtensionAttribute]
[ObsoleteAttribute("Use Refresh: Same thing but better semantics")]
public static void Evaluate(ISourceCache`2<TObject, TKey> source, IEnumerable`1<TObject> items);
    [ExtensionAttribute]
public static void AddOrUpdate(IIntermediateCache`2<TObject, TKey> source, TObject item, TKey key);
    [ExtensionAttribute]
[ObsoleteAttribute("Use Refresh: Same thing but better semantics")]
public static void Evaluate(ISourceCache`2<TObject, TKey> source);
    [ExtensionAttribute]
public static void Remove(IIntermediateCache`2<TObject, TKey> source, TKey key);
    [ExtensionAttribute]
public static void Remove(IIntermediateCache`2<TObject, TKey> source, IEnumerable`1<TKey> keys);
    [ExtensionAttribute]
public static void Clear(IIntermediateCache`2<TObject, TKey> source);
    [ExtensionAttribute]
public static void Clear(LockFreeObservableCache`2<TObject, TKey> source);
    [ExtensionAttribute]
public static IDisposable PopulateInto(IObservable`1<IChangeSet`2<TObject, TKey>> source, LockFreeObservableCache`2<TObject, TKey> detination);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> Switch(IObservable`1<IObservableCache`2<TObject, TKey>> sources);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> Switch(IObservable`1<IObservable`1<IChangeSet`2<TObject, TKey>>> sources);
    [IteratorStateMachineAttribute("DynamicData.ObservableCacheEx/<<TreatMovesAsRemoveAdd>g__ReplaceMoves|87_0>d`2")]
[CompilerGeneratedAttribute]
internal static IEnumerable`1<Change`2<TObject, TKey>> <TreatMovesAsRemoveAdd>g__ReplaceMoves|87_0(IChangeSet`2<TObject, TKey> items);
    [CompilerGeneratedAttribute]
internal static bool <ForForced>g__Transformer|124_1(TSource item, TKey key);
}
public static class DynamicData.ObservableChangeSet : object {
    public static IObservable`1<IChangeSet`2<TObject, TKey>> Create(Func`2<ISourceCache`2<TObject, TKey>, Action> subscribe, Func`2<TObject, TKey> keySelector);
    public static IObservable`1<IChangeSet`2<TObject, TKey>> Create(Func`2<ISourceCache`2<TObject, TKey>, IDisposable> subscribe, Func`2<TObject, TKey> keySelector);
    public static IObservable`1<IChangeSet`2<TObject, TKey>> Create(Func`2<ISourceCache`2<TObject, TKey>, Task`1<IDisposable>> subscribe, Func`2<TObject, TKey> keySelector);
    public static IObservable`1<IChangeSet`2<TObject, TKey>> Create(Func`3<ISourceCache`2<TObject, TKey>, CancellationToken, Task`1<IDisposable>> subscribe, Func`2<TObject, TKey> keySelector);
    public static IObservable`1<IChangeSet`2<TObject, TKey>> Create(Func`2<ISourceCache`2<TObject, TKey>, Task`1<Action>> subscribe, Func`2<TObject, TKey> keySelector);
    public static IObservable`1<IChangeSet`2<TObject, TKey>> Create(Func`3<ISourceCache`2<TObject, TKey>, CancellationToken, Task`1<Action>> subscribe, Func`2<TObject, TKey> keySelector);
    public static IObservable`1<IChangeSet`2<TObject, TKey>> Create(Func`2<ISourceCache`2<TObject, TKey>, Task> subscribe, Func`2<TObject, TKey> keySelector);
    public static IObservable`1<IChangeSet`2<TObject, TKey>> Create(Func`3<ISourceCache`2<TObject, TKey>, CancellationToken, Task> subscribe, Func`2<TObject, TKey> keySelector);
    public static IObservable`1<IChangeSet`1<T>> Create(Func`2<ISourceList`1<T>, Action> subscribe);
    public static IObservable`1<IChangeSet`1<T>> Create(Func`2<ISourceList`1<T>, IDisposable> subscribe);
    public static IObservable`1<IChangeSet`1<T>> Create(Func`2<ISourceList`1<T>, Task`1<IDisposable>> subscribe);
    public static IObservable`1<IChangeSet`1<T>> Create(Func`3<ISourceList`1<T>, CancellationToken, Task`1<IDisposable>> subscribe);
    public static IObservable`1<IChangeSet`1<T>> Create(Func`2<ISourceList`1<T>, Task`1<Action>> subscribe);
    public static IObservable`1<IChangeSet`1<T>> Create(Func`3<ISourceList`1<T>, CancellationToken, Task`1<Action>> subscribe);
    public static IObservable`1<IChangeSet`1<T>> Create(Func`2<ISourceList`1<T>, Task> subscribe);
    public static IObservable`1<IChangeSet`1<T>> Create(Func`3<ISourceList`1<T>, CancellationToken, Task> subscribe);
}
[ExtensionAttribute]
public static class DynamicData.ObservableListEx : object {
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> ToObservableChangeSet(IObservable`1<T> source, IScheduler scheduler);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> ToObservableChangeSet(IObservable`1<T> source, Func`2<T, Nullable`1<TimeSpan>> expireAfter, IScheduler scheduler);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> ToObservableChangeSet(IObservable`1<T> source, int limitSizeTo, IScheduler scheduler);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> ToObservableChangeSet(IObservable`1<T> source, Func`2<T, Nullable`1<TimeSpan>> expireAfter, int limitSizeTo, IScheduler scheduler);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> ToObservableChangeSet(IObservable`1<IEnumerable`1<T>> source, IScheduler scheduler);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> ToObservableChangeSet(IObservable`1<IEnumerable`1<T>> source, int limitSizeTo, IScheduler scheduler);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> ToObservableChangeSet(IObservable`1<IEnumerable`1<T>> source, Func`2<T, Nullable`1<TimeSpan>> expireAfter, IScheduler scheduler);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> ToObservableChangeSet(IObservable`1<IEnumerable`1<T>> source, Func`2<T, Nullable`1<TimeSpan>> expireAfter, int limitSizeTo, IScheduler scheduler);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<TObject>> AutoRefresh(IObservable`1<IChangeSet`1<TObject>> source, Nullable`1<TimeSpan> changeSetBuffer, Nullable`1<TimeSpan> propertyChangeThrottle, IScheduler scheduler);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<TObject>> AutoRefresh(IObservable`1<IChangeSet`1<TObject>> source, Expression`1<Func`2<TObject, TProperty>> propertyAccessor, Nullable`1<TimeSpan> changeSetBuffer, Nullable`1<TimeSpan> propertyChangeThrottle, IScheduler scheduler);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<TObject>> AutoRefreshOnObservable(IObservable`1<IChangeSet`1<TObject>> source, Func`2<TObject, IObservable`1<TAny>> reevaluator, Nullable`1<TimeSpan> changeSetBuffer, IScheduler scheduler);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> SupressRefresh(IObservable`1<IChangeSet`1<T>> source);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> RemoveIndex(IObservable`1<IChangeSet`1<T>> source);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> AddKey(IObservable`1<IChangeSet`1<TObject>> source, Func`2<TObject, TKey> keySelector);
    [ExtensionAttribute]
[ObsoleteAttribute("Prefer Cast as it is does the same thing but is semantically correct")]
public static IObservable`1<IChangeSet`1<TDestination>> Convert(IObservable`1<IChangeSet`1<TObject>> source, Func`2<TObject, TDestination> conversionFactory);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<object>> CastToObject(IObservable`1<IChangeSet`1<T>> source);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<TDestination>> Cast(IObservable`1<IChangeSet`1<object>> source);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<TDestination>> Cast(IObservable`1<IChangeSet`1<TSource>> source, Func`2<TSource, TDestination> conversionFactory);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> Bind(IObservable`1<IChangeSet`1<T>> source, IObservableCollection`1<T> targetCollection, int resetThreshold);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> Bind(IObservable`1<IChangeSet`1<T>> source, ReadOnlyObservableCollection`1& readOnlyObservableCollection, int resetThreshold);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> Bind(IObservable`1<IChangeSet`1<T>> source, BindingList`1<T> bindingList, int resetThreshold);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> Adapt(IObservable`1<IChangeSet`1<T>> source, IChangeSetAdaptor`1<T> adaptor);
    [ExtensionAttribute]
public static IDisposable PopulateInto(IObservable`1<IChangeSet`1<T>> source, ISourceList`1<T> destination);
    [ExtensionAttribute]
public static IObservableList`1<T> AsObservableList(ISourceList`1<T> source);
    [ExtensionAttribute]
public static IObservableList`1<T> AsObservableList(IObservable`1<IChangeSet`1<T>> source);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> RefCount(IObservable`1<IChangeSet`1<T>> source);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> Filter(IObservable`1<IChangeSet`1<T>> source, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> Filter(IObservable`1<IChangeSet`1<T>> source, IObservable`1<Func`2<T, bool>> predicate, ListFilterPolicy filterPolicy);
    [ExtensionAttribute]
[ObsoleteAttribute("Use AutoRefresh(), followed by Filter() instead")]
public static IObservable`1<IChangeSet`1<TObject>> FilterOnProperty(IObservable`1<IChangeSet`1<TObject>> source, Expression`1<Func`2<TObject, TProperty>> propertySelector, Func`2<TObject, bool> predicate, Nullable`1<TimeSpan> propertyChangedThrottle, IScheduler scheduler);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<TObject>> FilterOnObservable(IObservable`1<IChangeSet`1<TObject>> source, Func`2<TObject, IObservable`1<bool>> objectFilterObservable, Nullable`1<TimeSpan> propertyChangedThrottle, IScheduler scheduler);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> Reverse(IObservable`1<IChangeSet`1<T>> source);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<TDestination>> Transform(IObservable`1<IChangeSet`1<TSource>> source, Func`2<TSource, TDestination> transformFactory, bool transformOnRefresh);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<TDestination>> Transform(IObservable`1<IChangeSet`1<TSource>> source, Func`3<TSource, int, TDestination> transformFactory, bool transformOnRefresh);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<TDestination>> Transform(IObservable`1<IChangeSet`1<TSource>> source, Func`3<TSource, Optional`1<TDestination>, TDestination> transformFactory, bool transformOnRefresh);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<TDestination>> Transform(IObservable`1<IChangeSet`1<TSource>> source, Func`4<TSource, Optional`1<TDestination>, int, TDestination> transformFactory, bool transformOnRefresh);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<TDestination>> TransformAsync(IObservable`1<IChangeSet`1<TSource>> source, Func`2<TSource, Task`1<TDestination>> transformFactory);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<TDestination>> TransformMany(IObservable`1<IChangeSet`1<TSource>> source, Func`2<TSource, IEnumerable`1<TDestination>> manyselector, IEqualityComparer`1<TDestination> equalityComparer);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<TDestination>> TransformMany(IObservable`1<IChangeSet`1<TSource>> source, Func`2<TSource, ObservableCollection`1<TDestination>> manyselector, IEqualityComparer`1<TDestination> equalityComparer);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<TDestination>> TransformMany(IObservable`1<IChangeSet`1<TSource>> source, Func`2<TSource, ReadOnlyObservableCollection`1<TDestination>> manyselector, IEqualityComparer`1<TDestination> equalityComparer);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<TDestination>> TransformMany(IObservable`1<IChangeSet`1<TSource>> source, Func`2<TSource, IObservableList`1<TDestination>> manyselector, IEqualityComparer`1<TDestination> equalityComparer);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<TValue>> DistinctValues(IObservable`1<IChangeSet`1<TObject>> source, Func`2<TObject, TValue> valueSelector);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<IGroup`2<TObject, TGroup>>> GroupOn(IObservable`1<IChangeSet`1<TObject>> source, Func`2<TObject, TGroup> groupSelector, IObservable`1<Unit> regrouper);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<IGrouping`2<TObject, TGroupKey>>> GroupWithImmutableState(IObservable`1<IChangeSet`1<TObject>> source, Func`2<TObject, TGroupKey> groupSelectorKey, IObservable`1<Unit> regrouper);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<IGroup`2<TObject, TGroup>>> GroupOnProperty(IObservable`1<IChangeSet`1<TObject>> source, Expression`1<Func`2<TObject, TGroup>> propertySelector, Nullable`1<TimeSpan> propertyChangedThrottle, IScheduler scheduler);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<IGrouping`2<TObject, TGroup>>> GroupOnPropertyWithImmutableState(IObservable`1<IChangeSet`1<TObject>> source, Expression`1<Func`2<TObject, TGroup>> propertySelector, Nullable`1<TimeSpan> propertyChangedThrottle, IScheduler scheduler);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> NotEmpty(IObservable`1<IChangeSet`1<T>> source);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> Clone(IObservable`1<IChangeSet`1<T>> source, IList`1<T> target);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> Sort(IObservable`1<IChangeSet`1<T>> source, IComparer`1<T> comparer, SortOptions options, IObservable`1<Unit> resort, IObservable`1<IComparer`1<T>> comparerChanged, int resetThreshold);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> Sort(IObservable`1<IChangeSet`1<T>> source, IObservable`1<IComparer`1<T>> comparerChanged, SortOptions options, IObservable`1<Unit> resort, int resetThreshold);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<TObject>> ForEachChange(IObservable`1<IChangeSet`1<TObject>> source, Action`1<Change`1<TObject>> action);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<TObject>> ForEachItemChange(IObservable`1<IChangeSet`1<TObject>> source, Action`1<ItemChange`1<TObject>> action);
    [ExtensionAttribute]
public static IObservable`1<TDestination> MergeMany(IObservable`1<IChangeSet`1<T>> source, Func`2<T, IObservable`1<TDestination>> observableSelector);
    [ExtensionAttribute]
public static IObservable`1<TValue> WhenValueChanged(IObservable`1<IChangeSet`1<TObject>> source, Expression`1<Func`2<TObject, TValue>> propertyAccessor, bool notifyOnInitialValue);
    [ExtensionAttribute]
public static IObservable`1<PropertyValue`2<TObject, TValue>> WhenPropertyChanged(IObservable`1<IChangeSet`1<TObject>> source, Expression`1<Func`2<TObject, TValue>> propertyAccessor, bool notifyOnInitialValue);
    [ExtensionAttribute]
public static IObservable`1<TObject> WhenAnyPropertyChanged(IObservable`1<IChangeSet`1<TObject>> source, String[] propertiesToMonitor);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> SubscribeMany(IObservable`1<IChangeSet`1<T>> source, Func`2<T, IDisposable> subscriptionFactory);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> DisposeMany(IObservable`1<IChangeSet`1<T>> source);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> OnItemRemoved(IObservable`1<IChangeSet`1<T>> source, Action`1<T> removeAction);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> OnItemAdded(IObservable`1<IChangeSet`1<T>> source, Action`1<T> addAction);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> WhereReasonsAre(IObservable`1<IChangeSet`1<T>> source, ListChangeReason[] reasons);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> WhereReasonsAreNot(IObservable`1<IChangeSet`1<T>> source, ListChangeReason[] reasons);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<TObject>> BufferInitial(IObservable`1<IChangeSet`1<TObject>> source, TimeSpan initalBuffer, IScheduler scheduler);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> FlattenBufferResult(IObservable`1<IList`1<IChangeSet`1<T>>> source);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> BufferIf(IObservable`1<IChangeSet`1<T>> source, IObservable`1<bool> pauseIfTrueSelector, IScheduler scheduler);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> BufferIf(IObservable`1<IChangeSet`1<T>> source, IObservable`1<bool> pauseIfTrueSelector, bool intialPauseState, IScheduler scheduler);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> BufferIf(IObservable`1<IChangeSet`1<T>> source, IObservable`1<bool> pauseIfTrueSelector, Nullable`1<TimeSpan> timeOut, IScheduler scheduler);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> BufferIf(IObservable`1<IChangeSet`1<T>> source, IObservable`1<bool> pauseIfTrueSelector, bool intialPauseState, Nullable`1<TimeSpan> timeOut, IScheduler scheduler);
    [ExtensionAttribute]
public static IObservable`1<TDestination> QueryWhenChanged(IObservable`1<IChangeSet`1<TObject>> source, Func`2<IReadOnlyCollection`1<TObject>, TDestination> resultSelector);
    [ExtensionAttribute]
public static IObservable`1<IReadOnlyCollection`1<T>> QueryWhenChanged(IObservable`1<IChangeSet`1<T>> source);
    [ExtensionAttribute]
public static IObservable`1<IReadOnlyCollection`1<TObject>> ToCollection(IObservable`1<IChangeSet`1<TObject>> source);
    [ExtensionAttribute]
public static IObservable`1<IReadOnlyCollection`1<TObject>> ToSortedCollection(IObservable`1<IChangeSet`1<TObject>> source, Func`2<TObject, TSortKey> sort, SortDirection sortOrder);
    [ExtensionAttribute]
public static IObservable`1<IReadOnlyCollection`1<TObject>> ToSortedCollection(IObservable`1<IChangeSet`1<TObject>> source, IComparer`1<TObject> comparer);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> SkipInitial(IObservable`1<IChangeSet`1<T>> source);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> DeferUntilLoaded(IObservable`1<IChangeSet`1<T>> source);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> DeferUntilLoaded(IObservableList`1<T> source);
    [ExtensionAttribute]
public static IObservable`1<IVirtualChangeSet`1<T>> Virtualise(IObservable`1<IChangeSet`1<T>> source, IObservable`1<IVirtualRequest> requests);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> Top(IObservable`1<IChangeSet`1<T>> source, int numberOfItems);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> Page(IObservable`1<IChangeSet`1<T>> source, IObservable`1<IPageRequest> requests);
    [ExtensionAttribute]
public static IObservable`1<IEnumerable`1<T>> LimitSizeTo(ISourceList`1<T> source, int sizeLimit, IScheduler scheduler);
    [ExtensionAttribute]
public static IObservable`1<IEnumerable`1<T>> ExpireAfter(ISourceList`1<T> source, Func`2<T, Nullable`1<TimeSpan>> timeSelector, IScheduler scheduler);
    [ExtensionAttribute]
public static IObservable`1<IEnumerable`1<T>> ExpireAfter(ISourceList`1<T> source, Func`2<T, Nullable`1<TimeSpan>> timeSelector, Nullable`1<TimeSpan> pollingInterval, IScheduler scheduler);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> Or(ICollection`1<IObservable`1<IChangeSet`1<T>>> sources);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> Or(IObservable`1<IChangeSet`1<T>> source, IObservable`1[] others);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> Or(IObservableList`1<IObservable`1<IChangeSet`1<T>>> sources);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> Or(IObservableList`1<IObservableList`1<T>> sources);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> Or(IObservableList`1<ISourceList`1<T>> sources);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> Xor(IObservable`1<IChangeSet`1<T>> source, IObservable`1[] others);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> Xor(ICollection`1<IObservable`1<IChangeSet`1<T>>> sources);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> Xor(IObservableList`1<IObservable`1<IChangeSet`1<T>>> sources);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> Xor(IObservableList`1<IObservableList`1<T>> sources);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> Xor(IObservableList`1<ISourceList`1<T>> sources);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> And(IObservable`1<IChangeSet`1<T>> source, IObservable`1[] others);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> And(ICollection`1<IObservable`1<IChangeSet`1<T>>> sources);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> And(IObservableList`1<IObservable`1<IChangeSet`1<T>>> sources);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> And(IObservableList`1<IObservableList`1<T>> sources);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> And(IObservableList`1<ISourceList`1<T>> sources);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> Except(IObservable`1<IChangeSet`1<T>> source, IObservable`1[] others);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> Except(ICollection`1<IObservable`1<IChangeSet`1<T>>> sources);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> Except(IObservableList`1<IObservable`1<IChangeSet`1<T>>> sources);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> Except(IObservableList`1<IObservableList`1<T>> sources);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> Except(IObservableList`1<ISourceList`1<T>> sources);
    [ExtensionAttribute]
private static IObservable`1<IChangeSet`1<T>> Combine(ICollection`1<IObservable`1<IChangeSet`1<T>>> sources, CombineOperator type);
    [ExtensionAttribute]
private static IObservable`1<IChangeSet`1<T>> Combine(IObservable`1<IChangeSet`1<T>> source, CombineOperator type, IObservable`1[] others);
    [ExtensionAttribute]
private static IObservable`1<IChangeSet`1<T>> Combine(IObservableList`1<ISourceList`1<T>> sources, CombineOperator type);
    [ExtensionAttribute]
private static IObservable`1<IChangeSet`1<T>> Combine(IObservableList`1<IObservableList`1<T>> sources, CombineOperator type);
    [ExtensionAttribute]
private static IObservable`1<IChangeSet`1<T>> Combine(IObservableList`1<IObservable`1<IChangeSet`1<T>>> sources, CombineOperator type);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> Switch(IObservable`1<IObservableList`1<T>> sources);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> Switch(IObservable`1<IObservable`1<IChangeSet`1<T>>> sources);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> StartWithEmpty(IObservable`1<IChangeSet`1<T>> source);
}
public static class DynamicData.ObsoleteEx : object {
}
public interface DynamicData.Operators.IPageResponse {
    public int PageSize { get; }
    public int Page { get; }
    public int Pages { get; }
    public int TotalSize { get; }
    public abstract virtual int get_PageSize();
    public abstract virtual int get_Page();
    public abstract virtual int get_Pages();
    public abstract virtual int get_TotalSize();
}
internal class DynamicData.PageChangeSet`1 : object {
    private IChangeSet`1<T> _virtualChangeSet;
    [CompilerGeneratedAttribute]
private IPageResponse <Response>k__BackingField;
    public IPageResponse Response { get; }
    private int DynamicData.IChangeSet.Adds { get; }
    private int DynamicData.IChangeSet.Removes { get; }
    private int DynamicData.IChangeSet.Moves { get; }
    public int Count { get; }
    private int DynamicData.IChangeSet.Capacity { get; private set; }
    private int DynamicData.IChangeSet<T>.Replaced { get; }
    private int DynamicData.IChangeSet<T>.TotalChanges { get; }
    public int Refreshes { get; }
    public PageChangeSet`1(IChangeSet`1<T> virtualChangeSet, IPageResponse response);
    [CompilerGeneratedAttribute]
public sealed virtual IPageResponse get_Response();
    private sealed virtual override int DynamicData.IChangeSet.get_Adds();
    private sealed virtual override int DynamicData.IChangeSet.get_Removes();
    private sealed virtual override int DynamicData.IChangeSet.get_Moves();
    public sealed virtual int get_Count();
    private sealed virtual override int DynamicData.IChangeSet.get_Capacity();
    private sealed virtual override void DynamicData.IChangeSet.set_Capacity(int value);
    private sealed virtual override int DynamicData.IChangeSet<T>.get_Replaced();
    private sealed virtual override int DynamicData.IChangeSet<T>.get_TotalChanges();
    public sealed virtual int get_Refreshes();
    public sealed virtual IEnumerator`1<Change`1<T>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class DynamicData.PagedChangeSet`2 : ChangeSet`2<TObject, TKey> {
    public static IPagedChangeSet`2<TObject, TKey> Empty;
    [CompilerGeneratedAttribute]
private IKeyValueCollection`2<TObject, TKey> <SortedItems>k__BackingField;
    [CompilerGeneratedAttribute]
private IPageResponse <Response>k__BackingField;
    public IKeyValueCollection`2<TObject, TKey> SortedItems { get; }
    public IPageResponse Response { get; }
    public PagedChangeSet`2(IKeyValueCollection`2<TObject, TKey> sortedItems, IEnumerable`1<Change`2<TObject, TKey>> updates, IPageResponse response);
    private static PagedChangeSet`2();
    [CompilerGeneratedAttribute]
public sealed virtual IKeyValueCollection`2<TObject, TKey> get_SortedItems();
    [CompilerGeneratedAttribute]
public sealed virtual IPageResponse get_Response();
    public bool Equals(PagedChangeSet`2<TObject, TKey> other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    private sealed virtual override int DynamicData.IChangeSet.get_Capacity();
    private sealed virtual override void DynamicData.IChangeSet.set_Capacity(int value);
}
public class DynamicData.PageRequest : object {
    public static IPageRequest Default;
    public static IPageRequest Empty;
    [CompilerGeneratedAttribute]
private int <Page>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Size>k__BackingField;
    private static IEqualityComparer`1<IPageRequest> _pageSizeComparerInstance;
    public int Page { get; }
    public int Size { get; }
    public IEqualityComparer`1<IPageRequest> DefaultComparer { get; }
    public PageRequest(int page, int size);
    private static PageRequest();
    [CompilerGeneratedAttribute]
public sealed virtual int get_Page();
    [CompilerGeneratedAttribute]
public sealed virtual int get_Size();
    public sealed virtual bool Equals(IPageRequest other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public IEqualityComparer`1<IPageRequest> get_DefaultComparer();
    public virtual string ToString();
}
internal class DynamicData.PageResponse : object {
    [CompilerGeneratedAttribute]
private int <PageSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Page>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Pages>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TotalSize>k__BackingField;
    [CompilerGeneratedAttribute]
private static IEqualityComparer`1<IPageResponse> <DefaultComparer>k__BackingField;
    public int PageSize { get; }
    public int Page { get; }
    public int Pages { get; }
    public int TotalSize { get; }
    public static IEqualityComparer`1<IPageResponse> DefaultComparer { get; }
    public PageResponse(int pageSize, int totalSize, int page, int pages);
    private static PageResponse();
    [CompilerGeneratedAttribute]
public sealed virtual int get_PageSize();
    [CompilerGeneratedAttribute]
public sealed virtual int get_Page();
    [CompilerGeneratedAttribute]
public sealed virtual int get_Pages();
    [CompilerGeneratedAttribute]
public sealed virtual int get_TotalSize();
    public sealed virtual bool Equals(IPageResponse other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public static IEqualityComparer`1<IPageResponse> get_DefaultComparer();
    public virtual string ToString();
}
[ExtensionAttribute]
internal static class DynamicData.PLinq.ParallelEx : object {
    [ExtensionAttribute]
internal static bool ShouldParallelise(IChangeSet`2<TObject, TKey> source, ParallelisationOptions option);
    [ExtensionAttribute]
internal static ParallelQuery`1<Change`2<TObject, TKey>> Parallelise(IChangeSet`2<TObject, TKey> source, ParallelisationOptions option);
    [ExtensionAttribute]
internal static bool ShouldParallelise(IEnumerable`1<KeyValuePair`2<TKey, TObject>> source, ParallelisationOptions option);
    [ExtensionAttribute]
internal static ParallelQuery`1<KeyValuePair`2<TKey, TObject>> Parallelise(IEnumerable`1<KeyValuePair`2<TKey, TObject>> source, ParallelisationOptions option);
    [ExtensionAttribute]
internal static IEnumerable`1<T> Parallelise(IEnumerable`1<T> source, ParallelisationOptions option);
}
public class DynamicData.PLinq.ParallelisationOptions : object {
    public static ParallelisationOptions Default;
    public static ParallelisationOptions None;
    [CompilerGeneratedAttribute]
private ParallelType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Threshold>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxDegreeOfParallisation>k__BackingField;
    public ParallelType Type { get; }
    public int Threshold { get; }
    public int MaxDegreeOfParallisation { get; }
    public ParallelisationOptions(ParallelType type, int threshold, int maxDegreeOfParallisation);
    private static ParallelisationOptions();
    [CompilerGeneratedAttribute]
public ParallelType get_Type();
    [CompilerGeneratedAttribute]
public int get_Threshold();
    [CompilerGeneratedAttribute]
public int get_MaxDegreeOfParallisation();
}
[ExtensionAttribute]
public static class DynamicData.PLinq.ParallelOperators : object {
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> SubscribeMany(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, IDisposable> subscriptionFactory, ParallelisationOptions parallelisationOptions);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> SubscribeMany(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`3<TObject, TKey, IDisposable> subscriptionFactory, ParallelisationOptions parallelisationOptions);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TKey>> Transform(IObservable`1<IChangeSet`2<TSource, TKey>> source, Func`3<TSource, TKey, TDestination> transformFactory, ParallelisationOptions parallelisationOptions);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TKey>> Transform(IObservable`1<IChangeSet`2<TSource, TKey>> source, Func`2<TSource, TDestination> transformFactory, ParallelisationOptions parallelisationOptions);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TKey>> TransformSafe(IObservable`1<IChangeSet`2<TSource, TKey>> source, Func`2<TSource, TDestination> transformFactory, Action`1<Error`2<TSource, TKey>> errorHandler, ParallelisationOptions parallelisationOptions);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TKey>> TransformSafe(IObservable`1<IChangeSet`2<TSource, TKey>> source, Func`3<TSource, TKey, TDestination> transformFactory, Action`1<Error`2<TSource, TKey>> errorHandler, ParallelisationOptions parallelisationOptions);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> Filter(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, bool> filter, ParallelisationOptions parallelisationOptions);
}
public enum DynamicData.PLinq.ParallelType : Enum {
    public int value__;
    public static ParallelType None;
    public static ParallelType Parallelise;
    public static ParallelType Ordered;
}
internal class DynamicData.PLinq.PFilter`2 : object {
    private IObservable`1<IChangeSet`2<TObject, TKey>> _source;
    private Func`2<TObject, bool> _filter;
    private ParallelisationOptions _parallelisationOptions;
    public PFilter`2(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, bool> filter, ParallelisationOptions parallelisationOptions);
    public IObservable`1<IChangeSet`2<TObject, TKey>> Run();
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__4_0(IObserver`1<IChangeSet`2<TObject, TKey>> observer);
}
internal class DynamicData.PLinq.PSubscribeMany`2 : object {
    private ParallelisationOptions _parallelisationOptions;
    private IObservable`1<IChangeSet`2<TObject, TKey>> _source;
    private Func`3<TObject, TKey, IDisposable> _subscriptionFactory;
    public PSubscribeMany`2(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`3<TObject, TKey, IDisposable> subscriptionFactory, ParallelisationOptions parallelisationOptions);
    public IObservable`1<IChangeSet`2<TObject, TKey>> Run();
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__4_0(IObserver`1<IChangeSet`2<TObject, TKey>> observer);
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__4_1(TObject t, TKey k);
}
internal class DynamicData.PLinq.PTransform`3 : object {
    private IObservable`1<IChangeSet`2<TSource, TKey>> _source;
    private Func`4<TSource, Optional`1<TSource>, TKey, TDestination> _transformFactory;
    private ParallelisationOptions _parallelisationOptions;
    private Action`1<Error`2<TSource, TKey>> _exceptionCallback;
    public PTransform`3(IObservable`1<IChangeSet`2<TSource, TKey>> source, Func`4<TSource, Optional`1<TSource>, TKey, TDestination> transformFactory, ParallelisationOptions parallelisationOptions, Action`1<Error`2<TSource, TKey>> exceptionCallback);
    public IObservable`1<IChangeSet`2<TDestination, TKey>> Run();
    private IChangeSet`2<TDestination, TKey> DoTransform(ChangeAwareCache`2<TDestination, TKey> cache, IChangeSet`2<TSource, TKey> changes);
    private TransformResult<TDestination, TSource, TKey> ToDestination(Change`2<TSource, TKey> change);
    private IChangeSet`2<TDestination, TKey> ProcessUpdates(ChangeAwareCache`2<TDestination, TKey> cache, IEnumerable`1<TransformResult<TDestination, TSource, TKey>> transformedItems);
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__5_0(IObserver`1<IChangeSet`2<TDestination, TKey>> observer);
}
public class DynamicData.RangeChange`1 : object {
    private List`1<T> _items;
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    public int Count { get; }
    public int Index { get; private set; }
    public RangeChange`1(IEnumerable`1<T> items, int index);
    public void Add(T item);
    public void Insert(int index, T item);
    public void SetStartingIndex(int index);
    public int get_Count();
    [CompilerGeneratedAttribute]
public int get_Index();
    [CompilerGeneratedAttribute]
private void set_Index(int value);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual string ToString();
}
internal class DynamicData.SortedChangeSet`2 : ChangeSet`2<TObject, TKey> {
    public static ISortedChangeSet`2<TObject, TKey> Empty;
    [CompilerGeneratedAttribute]
private IKeyValueCollection`2<TObject, TKey> <SortedItems>k__BackingField;
    public IKeyValueCollection`2<TObject, TKey> SortedItems { get; }
    public SortedChangeSet`2(IKeyValueCollection`2<TObject, TKey> sortedItems, IEnumerable`1<Change`2<TObject, TKey>> updates);
    private static SortedChangeSet`2();
    [CompilerGeneratedAttribute]
public sealed virtual IKeyValueCollection`2<TObject, TKey> get_SortedItems();
    public bool Equals(SortedChangeSet`2<TObject, TKey> other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    private sealed virtual override int DynamicData.IChangeSet.get_Capacity();
    private sealed virtual override void DynamicData.IChangeSet.set_Capacity(int value);
}
public class DynamicData.SortException : Exception {
    public SortException(string message);
    public SortException(string message, Exception innerException);
    protected SortException(SerializationInfo serializationInfo, StreamingContext streamingContext);
}
[FlagsAttribute]
public enum DynamicData.SortOptimisations : Enum {
    public int value__;
    public static SortOptimisations None;
    public static SortOptimisations ComparesImmutableValuesOnly;
    public static SortOptimisations IgnoreEvaluates;
    [ObsoleteAttribute("This is no longer being used. Use one of the other options instead.")]
public static SortOptimisations InsertAtEndThenSort;
}
public enum DynamicData.SortOptions : Enum {
    public int value__;
    public static SortOptions None;
    public static SortOptions UseBinarySearch;
}
public enum DynamicData.SortReason : Enum {
    public int value__;
    public static SortReason InitialLoad;
    public static SortReason ComparerChanged;
    public static SortReason DataChanged;
    public static SortReason Reorder;
    public static SortReason Reset;
}
public class DynamicData.SourceCache`2 : object {
    private ObservableCache`2<TObject, TKey> _innerCache;
    private bool _isDisposed;
    [CompilerGeneratedAttribute]
private Func`2<TObject, TKey> <KeySelector>k__BackingField;
    public IObservable`1<int> CountChanged { get; }
    public int Count { get; }
    public IEnumerable`1<TObject> Items { get; }
    public IEnumerable`1<KeyValuePair`2<TKey, TObject>> KeyValues { get; }
    public IEnumerable`1<TKey> Keys { get; }
    public Func`2<TObject, TKey> KeySelector { get; }
    public SourceCache`2(Func`2<TObject, TKey> keySelector);
    public sealed virtual void Edit(Action`1<ISourceUpdater`2<TObject, TKey>> updateAction);
    public sealed virtual IObservable`1<int> get_CountChanged();
    public sealed virtual IObservable`1<IChangeSet`2<TObject, TKey>> Connect(Func`2<TObject, bool> predicate);
    public sealed virtual IObservable`1<IChangeSet`2<TObject, TKey>> Preview(Func`2<TObject, bool> predicate);
    public sealed virtual IObservable`1<Change`2<TObject, TKey>> Watch(TKey key);
    public sealed virtual int get_Count();
    public sealed virtual IEnumerable`1<TObject> get_Items();
    public sealed virtual IEnumerable`1<KeyValuePair`2<TKey, TObject>> get_KeyValues();
    public sealed virtual IEnumerable`1<TKey> get_Keys();
    [CompilerGeneratedAttribute]
public sealed virtual Func`2<TObject, TKey> get_KeySelector();
    public sealed virtual Optional`1<TObject> Lookup(TKey key);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool isDisposing);
}
[ExtensionAttribute]
public static class DynamicData.SourceCacheEx : object {
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TKey>> Cast(IObservableCache`2<TSource, TKey> source, Func`2<TSource, TDestination> converter);
}
public class DynamicData.SourceList`1 : object {
    private ISubject`1<IChangeSet`1<T>> _changes;
    private Subject`1<IChangeSet`1<T>> _changesPreview;
    private Lazy`1<ISubject`1<int>> _countChanged;
    private ReaderWriter`1<T> _readerWriter;
    private IDisposable _cleanUp;
    private object _locker;
    private int _editLevel;
    public IEnumerable`1<T> Items { get; }
    public int Count { get; }
    public IObservable`1<int> CountChanged { get; }
    public SourceList`1(IObservable`1<IChangeSet`1<T>> source);
    private IDisposable LoadFromSource(IObservable`1<IChangeSet`1<T>> source);
    public sealed virtual void Edit(Action`1<IExtendedList`1<T>> updateAction);
    private void InvokeNextPreview(IChangeSet`1<T> changes);
    private void InvokeNext(IChangeSet`1<T> changes);
    private void OnCompleted();
    private void OnError(Exception exception);
    public sealed virtual IEnumerable`1<T> get_Items();
    public sealed virtual int get_Count();
    public sealed virtual IObservable`1<int> get_CountChanged();
    public sealed virtual IObservable`1<IChangeSet`1<T>> Connect(Func`2<T, bool> predicate);
    public sealed virtual IObservable`1<IChangeSet`1<T>> Preview(Func`2<T, bool> predicate);
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
private IDisposable <get_CountChanged>b__19_0(IObserver`1<int> observer);
    [CompilerGeneratedAttribute]
private IDisposable <Connect>b__20_0(IObserver`1<IChangeSet`1<T>> observer);
}
[ExtensionAttribute]
public static class DynamicData.SourceListEditConvenienceEx : object {
    [ExtensionAttribute]
public static void EditDiff(ISourceList`1<T> source, IEnumerable`1<T> allItems, IEqualityComparer`1<T> equalityComparer);
    [ExtensionAttribute]
public static void Clear(ISourceList`1<T> source);
    [ExtensionAttribute]
public static void Add(ISourceList`1<T> source, T item);
    [ExtensionAttribute]
public static void Insert(ISourceList`1<T> source, int index, T item);
    [ExtensionAttribute]
public static void AddRange(ISourceList`1<T> source, IEnumerable`1<T> items);
    [ExtensionAttribute]
public static void InsertRange(ISourceList`1<T> source, IEnumerable`1<T> items, int index);
    [ExtensionAttribute]
public static bool Remove(ISourceList`1<T> source, T item);
    [ExtensionAttribute]
public static void RemoveMany(ISourceList`1<T> source, IEnumerable`1<T> itemsToRemove);
    [ExtensionAttribute]
public static void Move(ISourceList`1<T> source, int original, int destination);
    [ExtensionAttribute]
public static void RemoveRange(ISourceList`1<T> source, int index, int count);
    [ExtensionAttribute]
public static void RemoveAt(ISourceList`1<T> source, int index);
    [ExtensionAttribute]
public static void Replace(ISourceList`1<T> source, T original, T destination);
    [ExtensionAttribute]
public static void ReplaceAt(ISourceList`1<T> source, int index, T item);
}
[ExtensionAttribute]
public static class DynamicData.SourceListEx : object {
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<TDestination>> Cast(ISourceList`1<TSource> source, Func`2<TSource, TDestination> conversionFactory);
}
public class DynamicData.Tests.ChangeSetAggregator`1 : object {
    private IDisposable _disposer;
    private IList`1<IChangeSet`1<TObject>> _messages;
    private Exception _error;
    private bool _isDisposed;
    [CompilerGeneratedAttribute]
private IObservableList`1<TObject> <Data>k__BackingField;
    public IObservableList`1<TObject> Data { get; }
    public IList`1<IChangeSet`1<TObject>> Messages { get; }
    public ChangeSetAggregator`1(IObservable`1<IChangeSet`1<TObject>> source);
    [CompilerGeneratedAttribute]
public IObservableList`1<TObject> get_Data();
    public IList`1<IChangeSet`1<TObject>> get_Messages();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool isDisposing);
    [CompilerGeneratedAttribute]
private void <.ctor>b__4_0(IChangeSet`1<TObject> updates);
    [CompilerGeneratedAttribute]
private void <.ctor>b__4_1(Exception ex);
}
public class DynamicData.Tests.ChangeSetAggregator`2 : object {
    private IDisposable _disposer;
    private bool _isDisposed;
    [CompilerGeneratedAttribute]
private IObservableCache`2<TObject, TKey> <Data>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<IChangeSet`2<TObject, TKey>> <Messages>k__BackingField;
    [CompilerGeneratedAttribute]
private ChangeSummary <Summary>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <Error>k__BackingField;
    public IObservableCache`2<TObject, TKey> Data { get; }
    public IList`1<IChangeSet`2<TObject, TKey>> Messages { get; }
    public ChangeSummary Summary { get; private set; }
    public Exception Error { get; private set; }
    public ChangeSetAggregator`2(IObservable`1<IChangeSet`2<TObject, TKey>> source);
    [CompilerGeneratedAttribute]
public IObservableCache`2<TObject, TKey> get_Data();
    [CompilerGeneratedAttribute]
public IList`1<IChangeSet`2<TObject, TKey>> get_Messages();
    [CompilerGeneratedAttribute]
public ChangeSummary get_Summary();
    [CompilerGeneratedAttribute]
private void set_Summary(ChangeSummary value);
    [CompilerGeneratedAttribute]
public Exception get_Error();
    [CompilerGeneratedAttribute]
private void set_Error(Exception value);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool isDisposing);
    [CompilerGeneratedAttribute]
private void <.ctor>b__2_0(IChangeSet`2<TObject, TKey> updates);
    [CompilerGeneratedAttribute]
private void <.ctor>b__2_1(Exception ex);
    [CompilerGeneratedAttribute]
private void <.ctor>b__2_2(ChangeSummary summary);
}
public class DynamicData.Tests.DistinctChangeSetAggregator`1 : object {
    private IDisposable _disposer;
    private ChangeSummary _summary;
    private Exception _error;
    private bool _isDisposed;
    [CompilerGeneratedAttribute]
private IObservableCache`2<TValue, TValue> <Data>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<IChangeSet`2<TValue, TValue>> <Messages>k__BackingField;
    public IObservableCache`2<TValue, TValue> Data { get; }
    public IList`1<IChangeSet`2<TValue, TValue>> Messages { get; }
    public ChangeSummary Summary { get; }
    public Exception Error { get; }
    public DistinctChangeSetAggregator`1(IObservable`1<IDistinctChangeSet`1<TValue>> source);
    [CompilerGeneratedAttribute]
public IObservableCache`2<TValue, TValue> get_Data();
    [CompilerGeneratedAttribute]
public IList`1<IChangeSet`2<TValue, TValue>> get_Messages();
    public ChangeSummary get_Summary();
    public Exception get_Error();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool isDisposing);
    [CompilerGeneratedAttribute]
private void <.ctor>b__4_1(Exception ex);
    [CompilerGeneratedAttribute]
private void <.ctor>b__4_2(IDistinctChangeSet`1<TValue> updates);
    [CompilerGeneratedAttribute]
private void <.ctor>b__4_3(ChangeSummary summary);
}
[ExtensionAttribute]
public static class DynamicData.Tests.ListTextEx : object {
    [ExtensionAttribute]
public static ChangeSetAggregator`1<T> AsAggregator(IObservable`1<IChangeSet`1<T>> source);
}
public class DynamicData.Tests.PagedChangeSetAggregator`2 : object {
    private IDisposable _disposer;
    private Exception _error;
    private ChangeSummary _summary;
    private bool _isDisposed;
    [CompilerGeneratedAttribute]
private IObservableCache`2<TObject, TKey> <Data>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<IPagedChangeSet`2<TObject, TKey>> <Messages>k__BackingField;
    public IObservableCache`2<TObject, TKey> Data { get; }
    public IList`1<IPagedChangeSet`2<TObject, TKey>> Messages { get; }
    public ChangeSummary Summary { get; }
    public Exception Error { get; }
    public PagedChangeSetAggregator`2(IObservable`1<IPagedChangeSet`2<TObject, TKey>> source);
    [CompilerGeneratedAttribute]
public IObservableCache`2<TObject, TKey> get_Data();
    [CompilerGeneratedAttribute]
public IList`1<IPagedChangeSet`2<TObject, TKey>> get_Messages();
    public ChangeSummary get_Summary();
    public Exception get_Error();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool isDisposing);
    [CompilerGeneratedAttribute]
private void <.ctor>b__4_1(Exception ex);
    [CompilerGeneratedAttribute]
private void <.ctor>b__4_2(IPagedChangeSet`2<TObject, TKey> updates);
    [CompilerGeneratedAttribute]
private void <.ctor>b__4_3(ChangeSummary summary);
}
public class DynamicData.Tests.SortedChangeSetAggregator`2 : object {
    private IDisposable _disposer;
    private bool _isDisposed;
    [CompilerGeneratedAttribute]
private IObservableCache`2<TObject, TKey> <Data>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<ISortedChangeSet`2<TObject, TKey>> <Messages>k__BackingField;
    [CompilerGeneratedAttribute]
private ChangeSummary <Summary>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <Error>k__BackingField;
    public IObservableCache`2<TObject, TKey> Data { get; }
    public IList`1<ISortedChangeSet`2<TObject, TKey>> Messages { get; }
    public ChangeSummary Summary { get; private set; }
    public Exception Error { get; private set; }
    public SortedChangeSetAggregator`2(IObservable`1<ISortedChangeSet`2<TObject, TKey>> source);
    [CompilerGeneratedAttribute]
public IObservableCache`2<TObject, TKey> get_Data();
    [CompilerGeneratedAttribute]
public IList`1<ISortedChangeSet`2<TObject, TKey>> get_Messages();
    [CompilerGeneratedAttribute]
public ChangeSummary get_Summary();
    [CompilerGeneratedAttribute]
private void set_Summary(ChangeSummary value);
    [CompilerGeneratedAttribute]
public Exception get_Error();
    [CompilerGeneratedAttribute]
private void set_Error(Exception value);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool isDisposing);
    [CompilerGeneratedAttribute]
private void <.ctor>b__2_1(Exception ex);
    [CompilerGeneratedAttribute]
private void <.ctor>b__2_2(ISortedChangeSet`2<TObject, TKey> updates);
    [CompilerGeneratedAttribute]
private void <.ctor>b__2_3(ChangeSummary summary);
}
[ExtensionAttribute]
public static class DynamicData.Tests.TestEx : object {
    [ExtensionAttribute]
public static ChangeSetAggregator`2<TObject, TKey> AsAggregator(IObservable`1<IChangeSet`2<TObject, TKey>> source);
    [ExtensionAttribute]
public static DistinctChangeSetAggregator`1<TValue> AsAggregator(IObservable`1<IDistinctChangeSet`1<TValue>> source);
    [ExtensionAttribute]
public static SortedChangeSetAggregator`2<TObject, TKey> AsAggregator(IObservable`1<ISortedChangeSet`2<TObject, TKey>> source);
    [ExtensionAttribute]
public static VirtualChangeSetAggregator`2<TObject, TKey> AsAggregator(IObservable`1<IVirtualChangeSet`2<TObject, TKey>> source);
    [ExtensionAttribute]
public static PagedChangeSetAggregator`2<TObject, TKey> AsAggregator(IObservable`1<IPagedChangeSet`2<TObject, TKey>> source);
}
public class DynamicData.Tests.VirtualChangeSetAggregator`2 : object {
    private IDisposable _disposer;
    private bool _isDisposed;
    [CompilerGeneratedAttribute]
private IObservableCache`2<TObject, TKey> <Data>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<IVirtualChangeSet`2<TObject, TKey>> <Messages>k__BackingField;
    [CompilerGeneratedAttribute]
private ChangeSummary <Summary>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <Error>k__BackingField;
    public IObservableCache`2<TObject, TKey> Data { get; }
    public IList`1<IVirtualChangeSet`2<TObject, TKey>> Messages { get; }
    public ChangeSummary Summary { get; private set; }
    public Exception Error { get; private set; }
    public VirtualChangeSetAggregator`2(IObservable`1<IVirtualChangeSet`2<TObject, TKey>> source);
    [CompilerGeneratedAttribute]
public IObservableCache`2<TObject, TKey> get_Data();
    [CompilerGeneratedAttribute]
public IList`1<IVirtualChangeSet`2<TObject, TKey>> get_Messages();
    [CompilerGeneratedAttribute]
public ChangeSummary get_Summary();
    [CompilerGeneratedAttribute]
private void set_Summary(ChangeSummary value);
    [CompilerGeneratedAttribute]
public Exception get_Error();
    [CompilerGeneratedAttribute]
private void set_Error(Exception value);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool isDisposing);
    [CompilerGeneratedAttribute]
private void <.ctor>b__2_1(Exception ex);
    [CompilerGeneratedAttribute]
private void <.ctor>b__2_2(IVirtualChangeSet`2<TObject, TKey> updates);
    [CompilerGeneratedAttribute]
private void <.ctor>b__2_3(ChangeSummary summary);
}
public class DynamicData.UnspecifiedIndexException : Exception {
    public UnspecifiedIndexException(string message);
    public UnspecifiedIndexException(string message, Exception innerException);
    protected UnspecifiedIndexException(SerializationInfo serializationInfo, StreamingContext streamingContext);
}
internal class DynamicData.VirtualChangeSet`1 : object {
    private IChangeSet`1<T> _virtualChangeSet;
    [CompilerGeneratedAttribute]
private IVirtualResponse <Response>k__BackingField;
    public IVirtualResponse Response { get; }
    private int DynamicData.IChangeSet.Adds { get; }
    private int DynamicData.IChangeSet.Removes { get; }
    private int DynamicData.IChangeSet.Moves { get; }
    private int DynamicData.IChangeSet.Count { get; }
    private int DynamicData.IChangeSet.Capacity { get; private set; }
    private int DynamicData.IChangeSet<T>.Replaced { get; }
    private int DynamicData.IChangeSet<T>.TotalChanges { get; }
    public int Refreshes { get; }
    public VirtualChangeSet`1(IChangeSet`1<T> virtualChangeSet, IVirtualResponse response);
    [CompilerGeneratedAttribute]
public sealed virtual IVirtualResponse get_Response();
    private sealed virtual override int DynamicData.IChangeSet.get_Adds();
    private sealed virtual override int DynamicData.IChangeSet.get_Removes();
    private sealed virtual override int DynamicData.IChangeSet.get_Moves();
    private sealed virtual override int DynamicData.IChangeSet.get_Count();
    private sealed virtual override int DynamicData.IChangeSet.get_Capacity();
    private sealed virtual override void DynamicData.IChangeSet.set_Capacity(int value);
    private sealed virtual override int DynamicData.IChangeSet<T>.get_Replaced();
    private sealed virtual override int DynamicData.IChangeSet<T>.get_TotalChanges();
    public sealed virtual int get_Refreshes();
    public sealed virtual IEnumerator`1<Change`1<T>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class DynamicData.VirtualChangeSet`2 : ChangeSet`2<TObject, TKey> {
    public static IVirtualChangeSet`2<TObject, TKey> Empty;
    [CompilerGeneratedAttribute]
private IKeyValueCollection`2<TObject, TKey> <SortedItems>k__BackingField;
    [CompilerGeneratedAttribute]
private IVirtualResponse <Response>k__BackingField;
    public IKeyValueCollection`2<TObject, TKey> SortedItems { get; }
    public IVirtualResponse Response { get; }
    public VirtualChangeSet`2(IEnumerable`1<Change`2<TObject, TKey>> items, IKeyValueCollection`2<TObject, TKey> sortedItems, IVirtualResponse response);
    private static VirtualChangeSet`2();
    [CompilerGeneratedAttribute]
public sealed virtual IKeyValueCollection`2<TObject, TKey> get_SortedItems();
    [CompilerGeneratedAttribute]
public sealed virtual IVirtualResponse get_Response();
    public sealed virtual bool Equals(VirtualChangeSet`2<TObject, TKey> other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(VirtualChangeSet`2<TObject, TKey> left, VirtualChangeSet`2<TObject, TKey> right);
    public static bool op_Inequality(VirtualChangeSet`2<TObject, TKey> left, VirtualChangeSet`2<TObject, TKey> right);
    private sealed virtual override int DynamicData.IChangeSet.get_Capacity();
    private sealed virtual override void DynamicData.IChangeSet.set_Capacity(int value);
}
public class DynamicData.VirtualRequest : object {
    public static VirtualRequest Default;
    [CompilerGeneratedAttribute]
private int <Size>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StartIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private static IEqualityComparer`1<IVirtualRequest> <StartIndexSizeComparer>k__BackingField;
    public int Size { get; }
    public int StartIndex { get; }
    public static IEqualityComparer`1<IVirtualRequest> StartIndexSizeComparer { get; }
    public VirtualRequest(int startIndex, int size);
    private static VirtualRequest();
    [CompilerGeneratedAttribute]
public sealed virtual int get_Size();
    [CompilerGeneratedAttribute]
public sealed virtual int get_StartIndex();
    [CompilerGeneratedAttribute]
public static IEqualityComparer`1<IVirtualRequest> get_StartIndexSizeComparer();
    public sealed virtual bool Equals(IVirtualRequest other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
internal class DynamicData.VirtualResponse : object {
    [CompilerGeneratedAttribute]
private int <Size>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StartIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TotalSize>k__BackingField;
    private static IEqualityComparer`1<IVirtualResponse> STotalSizeStartIndexSizeComparerInstance;
    public int Size { get; }
    public int StartIndex { get; }
    public int TotalSize { get; }
    public static IEqualityComparer`1<IVirtualResponse> DefaultComparer { get; }
    public VirtualResponse(int size, int startIndex, int totalSize);
    private static VirtualResponse();
    [CompilerGeneratedAttribute]
public sealed virtual int get_Size();
    [CompilerGeneratedAttribute]
public sealed virtual int get_StartIndex();
    [CompilerGeneratedAttribute]
public sealed virtual int get_TotalSize();
    public sealed virtual bool Equals(IVirtualResponse other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static IEqualityComparer`1<IVirtualResponse> get_DefaultComparer();
    public virtual string ToString();
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
[GeneratedCodeAttribute("Nerdbank.GitVersioning.Tasks", "3.2.31.56335")]
[ExcludeFromCodeCoverageAttribute]
internal static class ThisAssembly : object {
    internal static string AssemblyVersion;
    internal static string AssemblyFileVersion;
    internal static string AssemblyInformationalVersion;
    internal static string AssemblyName;
    internal static string AssemblyTitle;
    internal static string AssemblyConfiguration;
    internal static string GitCommitId;
    internal static string PublicKey;
    internal static string PublicKeyToken;
    internal static bool IsPublicRelease;
    internal static bool IsPrerelease;
    internal static DateTime GitCommitDate;
    internal static string RootNamespace;
    private static ThisAssembly();
}
