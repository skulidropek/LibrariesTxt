public class JetBrains.Common.Timeline.Framework.Interface.ChartMarkersViewModel : AAutomation {
    [CompilerGeneratedAttribute]
private IDataNotifier`1<ScreenRangeInt> <SolidBorderRange>k__BackingField;
    [CompilerGeneratedAttribute]
private IDataProvider`1<IEnumerable`1<MarkerScreenRange>> <Ranges>k__BackingField;
    [CompilerGeneratedAttribute]
private IDataProvider`1<IEnumerable`1<ScreenRangeInt>> <Fade>k__BackingField;
    [CompilerGeneratedAttribute]
private HighlightedChartMarker <HighlightedMarker>k__BackingField;
    [CompilerGeneratedAttribute]
private IMouseController <MouseController>k__BackingField;
    [CompilerGeneratedAttribute]
private IHitTestProvider <HitTestProvider>k__BackingField;
    public IDataNotifier`1<ScreenRangeInt> SolidBorderRange { get; public set; }
    public IDataProvider`1<IEnumerable`1<MarkerScreenRange>> Ranges { get; public set; }
    public IDataProvider`1<IEnumerable`1<ScreenRangeInt>> Fade { get; public set; }
    public HighlightedChartMarker HighlightedMarker { get; public set; }
    public IMouseController MouseController { get; public set; }
    public IHitTestProvider HitTestProvider { get; public set; }
    [CompilerGeneratedAttribute]
public IDataNotifier`1<ScreenRangeInt> get_SolidBorderRange();
    [CompilerGeneratedAttribute]
public void set_SolidBorderRange(IDataNotifier`1<ScreenRangeInt> value);
    [CompilerGeneratedAttribute]
public IDataProvider`1<IEnumerable`1<MarkerScreenRange>> get_Ranges();
    [CompilerGeneratedAttribute]
public void set_Ranges(IDataProvider`1<IEnumerable`1<MarkerScreenRange>> value);
    [CompilerGeneratedAttribute]
public IDataProvider`1<IEnumerable`1<ScreenRangeInt>> get_Fade();
    [CompilerGeneratedAttribute]
public void set_Fade(IDataProvider`1<IEnumerable`1<ScreenRangeInt>> value);
    [CompilerGeneratedAttribute]
public HighlightedChartMarker get_HighlightedMarker();
    [CompilerGeneratedAttribute]
public void set_HighlightedMarker(HighlightedChartMarker value);
    [CompilerGeneratedAttribute]
public IMouseController get_MouseController();
    [CompilerGeneratedAttribute]
public void set_MouseController(IMouseController value);
    [CompilerGeneratedAttribute]
public IHitTestProvider get_HitTestProvider();
    [CompilerGeneratedAttribute]
public void set_HitTestProvider(IHitTestProvider value);
}
public class JetBrains.Common.Timeline.Framework.Interface.Charts.DefaultMultiChartStyler : object {
    public sealed virtual Brush GetBrush(FrameworkElement element, int eventType);
    public sealed virtual Pen GetPen(FrameworkElement element, int eventType);
}
public class JetBrains.Common.Timeline.Framework.Interface.Charts.HorizontalGridLinesViewModel : object {
    [CompilerGeneratedAttribute]
private int <EventType>k__BackingField;
    [CompilerGeneratedAttribute]
private IDataNotifier`1<double> <TotalValue>k__BackingField;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    public int EventType { get; }
    public IDataNotifier`1<double> TotalValue { get; }
    public HorizontalGridLinesViewModel(int eventType, IDataProvider`1<double> totalValue);
    [CompilerGeneratedAttribute]
public int get_EventType();
    [CompilerGeneratedAttribute]
public IDataNotifier`1<double> get_TotalValue();
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
}
public interface JetBrains.Common.Timeline.Framework.Interface.Charts.IInterpolatedMultiSeriesChartData {
    public double DataLeft { get; public set; }
    public double DataStep { get; public set; }
    public Double[0...,0...] Values { get; }
    public int Width { get; }
    public int SeriesNum { get; }
    public Int32[] EventTypes { get; }
    public abstract virtual double get_DataLeft();
    public abstract virtual void set_DataLeft(double value);
    public abstract virtual double get_DataStep();
    public abstract virtual void set_DataStep(double value);
    public abstract virtual Double[0...,0...] get_Values();
    public abstract virtual int get_Width();
    public abstract virtual int get_SeriesNum();
    public abstract virtual Int32[] get_EventTypes();
    public abstract virtual void SetPeak(int i, double value);
    public abstract virtual double GetPeak(int i);
    public abstract virtual void Init(Int32[] eventTypes, int screenWidth);
}
public interface JetBrains.Common.Timeline.Framework.Interface.Charts.ILineChartViewModel {
    public int EventType { get; }
    public abstract virtual int get_EventType();
}
public interface JetBrains.Common.Timeline.Framework.Interface.Charts.IMultiChartStyler {
    public abstract virtual Brush GetBrush(FrameworkElement element, int eventType);
    public abstract virtual Pen GetPen(FrameworkElement element, int eventType);
}
public interface JetBrains.Common.Timeline.Framework.Interface.Charts.IMultiChartStylerBase {
}
public interface JetBrains.Common.Timeline.Framework.Interface.Charts.IMultiSeriesPixelChartViewModel {
    public double ScreenHeight { get; public set; }
    public abstract virtual double get_ScreenHeight();
    public abstract virtual void set_ScreenHeight(double value);
}
public class JetBrains.Common.Timeline.Framework.Interface.Charts.InterpolatedMultiSeriesChartData : object {
    private Double[] myPeaks;
    private Double[0...,0...] myValues;
    [CompilerGeneratedAttribute]
private double <DataLeft>k__BackingField;
    [CompilerGeneratedAttribute]
private double <DataStep>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Width>k__BackingField;
    [CompilerGeneratedAttribute]
private Int32[] <EventTypes>k__BackingField;
    public double DataLeft { get; public set; }
    public double DataStep { get; public set; }
    public Double[0...,0...] Values { get; }
    public int Width { get; private set; }
    [CanBeNullAttribute]
public Int32[] EventTypes { get; private set; }
    public int SeriesNum { get; }
    protected InterpolatedMultiSeriesChartData(SerializationInfo info, StreamingContext context);
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public sealed virtual double get_DataLeft();
    [CompilerGeneratedAttribute]
public sealed virtual void set_DataLeft(double value);
    [CompilerGeneratedAttribute]
public sealed virtual double get_DataStep();
    [CompilerGeneratedAttribute]
public sealed virtual void set_DataStep(double value);
    public sealed virtual Double[0...,0...] get_Values();
    [CompilerGeneratedAttribute]
public sealed virtual int get_Width();
    [CompilerGeneratedAttribute]
private void set_Width(int value);
    [CompilerGeneratedAttribute]
public sealed virtual Int32[] get_EventTypes();
    [CompilerGeneratedAttribute]
private void set_EventTypes(Int32[] value);
    public sealed virtual void Init(Int32[] eventTypes, int width);
    public sealed virtual void SetPeak(int i, double value);
    public sealed virtual double GetPeak(int i);
    public sealed virtual int get_SeriesNum();
    public sealed virtual void CopyStateFrom(IInterpolatedMultiSeriesChartData source);
}
public interface JetBrains.Common.Timeline.Framework.Interface.Charts.IPixelChartViewModel {
    public SingleChartTypes ChartType { get; }
    public double ScaleFactor { get; }
    public abstract virtual SingleChartTypes get_ChartType();
    public abstract virtual double get_ScaleFactor();
}
public interface JetBrains.Common.Timeline.Framework.Interface.Charts.IPointsChartViewModel {
    public bool DrawZeroValue { get; public set; }
    public int EventType { get; }
    public abstract virtual bool get_DrawZeroValue();
    public abstract virtual void set_DrawZeroValue(bool value);
    public abstract virtual int get_EventType();
}
public class JetBrains.Common.Timeline.Framework.Interface.Charts.MultiChartData : object {
    [CompilerGeneratedAttribute]
private IList`1[] <XValues>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1[] <YValues>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<int> <EventTypes>k__BackingField;
    public IList`1[] XValues { get; }
    public IList`1[] YValues { get; }
    public IList`1<int> EventTypes { get; }
    public MultiChartData(IList`1<int> eventTypes, int capacity);
    public MultiChartData(IList`1<int> eventTypes, IList`1<double> xValues, IList`1[] yValues);
    public MultiChartData(IList`1<int> eventTypes, IList`1[] xValues, IList`1[] yValues);
    [CompilerGeneratedAttribute]
public IList`1[] get_XValues();
    [CompilerGeneratedAttribute]
public IList`1[] get_YValues();
    [CompilerGeneratedAttribute]
public IList`1<int> get_EventTypes();
}
[ExtensionAttribute]
public static class JetBrains.Common.Timeline.Framework.Interface.Charts.MultiChartDataExtensions : object {
    [ExtensionAttribute]
public static IDataProvider`1<IEnumerable`1<Point>> ToPointsProvider(IDataProvider`1<MultiChartData> provider, int eventType, IList`1<int> availableEventTypes);
    private static IEnumerable`1<Point> ToEnumerablePoints(MultiChartData data, int index);
}
public static class JetBrains.Common.Timeline.Framework.Interface.Charts.MultiChartStylerProvider : object {
    [CompilerGeneratedAttribute]
private static IMultiChartStylerBase <Instance>k__BackingField;
    public static IMultiChartStylerBase Instance { get; public set; }
    private static MultiChartStylerProvider();
    [CompilerGeneratedAttribute]
public static IMultiChartStylerBase get_Instance();
    [CompilerGeneratedAttribute]
public static void set_Instance(IMultiChartStylerBase value);
}
public class JetBrains.Common.Timeline.Framework.Interface.Charts.MultiChartViewModel : object {
    private MultiChartData myChartData;
    private Rect myViewport;
    [CompilerGeneratedAttribute]
private IMultiChartStylerBase <Styler>k__BackingField;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    [CanBeNullAttribute]
public MultiChartData ChartData { get; private set; }
    public Rect Viewport { get; private set; }
    [NotNullAttribute]
public IMultiChartStylerBase Styler { get; }
    public MultiChartViewModel(Lifetime lifetime, IDataProvider`1<MultiChartData> chartData, IViewport viewport, IDataProvider`1<double> maxValue, IMultiChartStylerBase styler);
    public MultiChartViewModel(Lifetime lifetime, IDataProvider`1<MultiChartData> chartData, IViewport viewport, IDataProvider`1<double> maxValue);
    public MultiChartData get_ChartData();
    private void set_ChartData(MultiChartData value);
    public Rect get_Viewport();
    private void set_Viewport(Rect value);
    [CompilerGeneratedAttribute]
public IMultiChartStylerBase get_Styler();
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
private void <.ctor>b__2_0(MultiChartData x);
    [CompilerGeneratedAttribute]
private void <.ctor>b__2_1(IViewport v);
    [CompilerGeneratedAttribute]
private void <.ctor>b__2_2(double y);
}
public class JetBrains.Common.Timeline.Framework.Interface.Charts.MultiSeriesPixelChartViewData : object {
    public Double[0...,0...] Values;
    public Double[] Peaks;
    public Int32[] EventTypes;
    public int Width;
    public int SeriesNum { get; }
    public void Init(Int32[] eventTypes, int width);
    public double GetTotalValue(int x, int y);
    public int get_SeriesNum();
    public sealed virtual void CopyStateFrom(MultiSeriesPixelChartViewData source);
}
public class JetBrains.Common.Timeline.Framework.Interface.Charts.PixelChartData : ValueType {
    public Func`2<int, double> GetValue;
    public int Width;
    public int EventType;
    public double Peak;
    public PixelChartData(int eventType, int width, double peak, Func`2<int, double> getValue);
    public static bool op_Equality(PixelChartData left, PixelChartData right);
    public static bool op_Inequality(PixelChartData left, PixelChartData right);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(PixelChartData other);
}
public class JetBrains.Common.Timeline.Framework.Interface.Charts.PointsChartViewData : ValueType {
    public IEnumerable`1<Point> Points;
    public double MaxValue;
    public PointsChartViewData(double maxValue, IEnumerable`1<Point> points);
}
public enum JetBrains.Common.Timeline.Framework.Interface.Charts.SingleChartTypes : Enum {
    public int value__;
    public static SingleChartTypes Chart;
    public static SingleChartTypes Worm;
    public static SingleChartTypes SplittedChart;
}
public class JetBrains.Common.Timeline.Framework.Interface.Charts.StackDiagramElement : object {
    [CompilerGeneratedAttribute]
private int <EventType>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Value>k__BackingField;
    public int EventType { get; }
    public double Value { get; public set; }
    public StackDiagramElement(int eventType, double value);
    [CompilerGeneratedAttribute]
public int get_EventType();
    [CompilerGeneratedAttribute]
public double get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(double value);
}
public class JetBrains.Common.Timeline.Framework.Interface.Charts.StackDiagramViewModel : object {
    private IList`1<StackDiagramElement> myElements;
    [CompilerGeneratedAttribute]
private IDataSink`1<double> <MaxSumValueSink>k__BackingField;
    [CompilerGeneratedAttribute]
private IDataProvider`1<IEnumerable`1<StackDiagramElement>> <ElementsProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TotalEventType>k__BackingField;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    public IDataSink`1<double> MaxSumValueSink { get; }
    public IDataProvider`1<IEnumerable`1<StackDiagramElement>> ElementsProvider { get; }
    public int TotalEventType { get; }
    public StackDiagramViewModel(IDataProvider`1<Double[]> valuesProvider, IDataSink`1<double> maxSumValueSink, IEnumerable`1<int> eventTypes, int totalEventType);
    [CompilerGeneratedAttribute]
public IDataSink`1<double> get_MaxSumValueSink();
    [CompilerGeneratedAttribute]
public IDataProvider`1<IEnumerable`1<StackDiagramElement>> get_ElementsProvider();
    [CompilerGeneratedAttribute]
public int get_TotalEventType();
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    private IEnumerable`1<StackDiagramElement> UpdateValues(Double[] newValues);
}
public static class JetBrains.Common.Timeline.Framework.Interface.ColorModifiers : object {
    public static int None;
    public static int Border;
    public static int Background;
    public static int Selected;
    public static int ChartBackground;
    public static int Text;
    public static int SelectionBorder;
}
public class JetBrains.Common.Timeline.Framework.Interface.CommandViewModel : object {
    [CompilerGeneratedAttribute]
private ICommand <Command>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Content>k__BackingField;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    public ICommand Command { get; }
    public object Content { get; }
    public CommandViewModel(ICommand command, object content);
    [CompilerGeneratedAttribute]
public ICommand get_Command();
    [CompilerGeneratedAttribute]
public object get_Content();
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
}
public class JetBrains.Common.Timeline.Framework.Interface.ControlPosition : ValueType {
    public double Top;
    public double Bottom;
    public bool IsVisible;
    public bool IsValid { get; }
    public ControlPosition(double top, double bottom, bool isVisible);
    public bool get_IsValid();
}
[ExtensionAttribute]
public static class JetBrains.Common.Timeline.Framework.Interface.DataProviderEx : object {
    [ExtensionAttribute]
public static IThreadSwitch`1<T> SwitchRecycle(IDataProvider`1<T> provider);
}
public class JetBrains.Common.Timeline.Framework.Interface.EventTypeWithModifier : ValueType {
    [CompilerGeneratedAttribute]
private int <EventType>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ColorModifier>k__BackingField;
    public static EventTypeWithModifier CpuUsage;
    public static EventTypeWithModifier CpuUsageBorder;
    public static EventTypeWithModifier CpuUsageChartBackground;
    public static EventTypeWithModifier TotalMemory;
    public static EventTypeWithModifier TotalMemoryBorder;
    public static EventTypeWithModifier TotalMemoryChartBackground;
    public int EventType { get; public set; }
    public int ColorModifier { get; public set; }
    public EventTypeWithModifier(int EventType, int ColorModifier);
    private static EventTypeWithModifier();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_EventType();
    [CompilerGeneratedAttribute]
public void set_EventType(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_ColorModifier();
    [CompilerGeneratedAttribute]
public void set_ColorModifier(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(EventTypeWithModifier left, EventTypeWithModifier right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(EventTypeWithModifier left, EventTypeWithModifier right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(EventTypeWithModifier other);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public void Deconstruct(Int32& EventType, Int32& ColorModifier);
}
public class JetBrains.Common.Timeline.Framework.Interface.HighlightedChartMarker : AAutomation {
    [CompilerGeneratedAttribute]
private IDataNotifier`1<bool> <IsVisible>k__BackingField;
    [CompilerGeneratedAttribute]
private IDataNotifier`1<int> <Left>k__BackingField;
    [CompilerGeneratedAttribute]
private IDataNotifier`1<int> <Width>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EventType>k__BackingField;
    public IDataNotifier`1<bool> IsVisible { get; public set; }
    public IDataNotifier`1<int> Left { get; public set; }
    public IDataNotifier`1<int> Width { get; public set; }
    public int EventType { get; public set; }
    [CompilerGeneratedAttribute]
public IDataNotifier`1<bool> get_IsVisible();
    [CompilerGeneratedAttribute]
public void set_IsVisible(IDataNotifier`1<bool> value);
    [CompilerGeneratedAttribute]
public IDataNotifier`1<int> get_Left();
    [CompilerGeneratedAttribute]
public void set_Left(IDataNotifier`1<int> value);
    [CompilerGeneratedAttribute]
public IDataNotifier`1<int> get_Width();
    [CompilerGeneratedAttribute]
public void set_Width(IDataNotifier`1<int> value);
    [CompilerGeneratedAttribute]
public int get_EventType();
    [CompilerGeneratedAttribute]
public void set_EventType(int value);
}
public interface JetBrains.Common.Timeline.Framework.Interface.ICopyStateFrom`1 {
    public abstract virtual void CopyStateFrom(T source);
}
public interface JetBrains.Common.Timeline.Framework.Interface.IFiltersHeaderVm {
    public object FiltersMenu { get; }
    public ICommandContainer ClearFilters { get; }
    public abstract virtual object get_FiltersMenu();
    public abstract virtual ICommandContainer get_ClearFilters();
}
public interface JetBrains.Common.Timeline.Framework.Interface.IHitTestProvider {
    public abstract virtual bool HitTest(Point p);
}
public interface JetBrains.Common.Timeline.Framework.Interface.IKeyboardModifiersProvider {
    public IDataProvider`1<bool> IsShiftPressed { get; }
    public IDataProvider`1<bool> IsCtrlPressed { get; }
    public IDataProvider`1<bool> AreCtrlAltPressed { get; }
    public abstract virtual IDataProvider`1<bool> get_IsShiftPressed();
    public abstract virtual IDataProvider`1<bool> get_IsCtrlPressed();
    public abstract virtual IDataProvider`1<bool> get_AreCtrlAltPressed();
}
public interface JetBrains.Common.Timeline.Framework.Interface.IMouseController {
    public IDataProvider`1<bool> IsMouseOver { get; }
    public abstract virtual void MouseMove(Point screenPoint);
    public abstract virtual void MouseClick();
    public abstract virtual void MouseUp();
    public abstract virtual void MouseDown();
    public abstract virtual void MouseLeave();
    public abstract virtual IDataProvider`1<bool> get_IsMouseOver();
}
public interface JetBrains.Common.Timeline.Framework.Interface.IMouseDragController {
    public abstract virtual void StartDrag(Point screenPoint);
    public abstract virtual void Drag(Point screenPoint);
    public abstract virtual void StopDrag();
}
public interface JetBrains.Common.Timeline.Framework.Interface.ITimelineElementViewModel`1 {
    public IDataProvider`1<T> ViewDataProvider { get; }
    public abstract virtual IDataProvider`1<T> get_ViewDataProvider();
}
[ZoneDefinitionAttribute]
public interface JetBrains.Common.Timeline.Framework.Interface.ITimelineFrameworkZone {
}
public interface JetBrains.Common.Timeline.Framework.Interface.ITimeScaleViewModel {
    public PeriodAndOffset LittleTicks { get; }
    public PeriodAndOffset LargeTicks { get; }
    public PeriodAndOffset MiddleTicks { get; }
    public ICollection`1<PositionedFormattableContent> SmallLabels { get; }
    public ICollection`1<PositionedFormattableContent> BigLabels { get; }
    public bool AlignToTop { get; }
    public abstract virtual PeriodAndOffset get_LittleTicks();
    public abstract virtual PeriodAndOffset get_LargeTicks();
    public abstract virtual PeriodAndOffset get_MiddleTicks();
    public abstract virtual ICollection`1<PositionedFormattableContent> get_SmallLabels();
    public abstract virtual ICollection`1<PositionedFormattableContent> get_BigLabels();
    public abstract virtual bool get_AlignToTop();
}
public class JetBrains.Common.Timeline.Framework.Interface.Markers.FilledRangeViewModel : AAutomation {
    [CompilerGeneratedAttribute]
private IDataNotifier`1<ScreenRange> <Range>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EventType>k__BackingField;
    public IDataNotifier`1<ScreenRange> Range { get; public set; }
    public int EventType { get; public set; }
    public FilledRangeViewModel(int eventType, IDataProvider`1<ScreenRange> range);
    [CompilerGeneratedAttribute]
public IDataNotifier`1<ScreenRange> get_Range();
    [CompilerGeneratedAttribute]
public void set_Range(IDataNotifier`1<ScreenRange> value);
    [CompilerGeneratedAttribute]
public int get_EventType();
    [CompilerGeneratedAttribute]
public void set_EventType(int value);
}
public interface JetBrains.Common.Timeline.Framework.Interface.Markers.IMarkersViewModel {
    public MarkerEventDisplayMode EventDisplayMode { get; }
    public MarkerGroupDisplayMode GroupDisplayMode { get; }
    public EventTypeWithModifier EventType { get; }
    public bool AddShadow { get; }
    public int HitTestMargin { get; }
    public abstract virtual MarkerEventDisplayMode get_EventDisplayMode();
    public abstract virtual MarkerGroupDisplayMode get_GroupDisplayMode();
    public abstract virtual EventTypeWithModifier get_EventType();
    public abstract virtual bool get_AddShadow();
    public abstract virtual int get_HitTestMargin();
}
public class JetBrains.Common.Timeline.Framework.Interface.Markers.IntervalsViewModel : object {
    [CompilerGeneratedAttribute]
private IDataProvider`1<IEnumerable`1<ScreenRangeInt>> <ViewDataProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private IDataNotifier`1<EventTypeWithModifier> <EventType>k__BackingField;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    public IDataProvider`1<IEnumerable`1<ScreenRangeInt>> ViewDataProvider { get; }
    public IDataNotifier`1<EventTypeWithModifier> EventType { get; }
    public IntervalsViewModel(IDataProvider`1<IEnumerable`1<ScreenRangeInt>> viewDataProvider, int eventType, int modifier);
    public IntervalsViewModel(IDataProvider`1<IEnumerable`1<ScreenRangeInt>> viewDataProvider, IDataProvider`1<EventTypeWithModifier> eventType);
    [CompilerGeneratedAttribute]
public IDataProvider`1<IEnumerable`1<ScreenRangeInt>> get_ViewDataProvider();
    [CompilerGeneratedAttribute]
public IDataNotifier`1<EventTypeWithModifier> get_EventType();
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
}
public enum JetBrains.Common.Timeline.Framework.Interface.Markers.MarkerEventDisplayMode : Enum {
    public int value__;
    public static MarkerEventDisplayMode Fill;
    public static MarkerEventDisplayMode Hide;
    public static MarkerEventDisplayMode Borders;
}
public enum JetBrains.Common.Timeline.Framework.Interface.Markers.MarkerGroupDisplayMode : Enum {
    public int value__;
    public static MarkerGroupDisplayMode Normal;
    public static MarkerGroupDisplayMode Hide;
    public static MarkerGroupDisplayMode Borders;
}
public class JetBrains.Common.Timeline.Framework.Interface.Markers.MarkerScreenRange : ValueType {
    public ScreenRangeInt ScreenRange;
    private ulong myModelLeft;
    private ulong myModelRight;
    public int Count;
    public ulong TotalLength;
    public bool SingleEvent { get; }
    public ulong ModelLeft { get; public set; }
    public ulong ModelRight { get; public set; }
    public ModelRange ModelRange { get; }
    public MarkerScreenRange(ScreenRangeInt screenRange, int count, ulong totalLength, ModelRange modelRange);
    public bool get_SingleEvent();
    public ulong get_ModelLeft();
    public void set_ModelLeft(ulong value);
    public ulong get_ModelRight();
    public void set_ModelRight(ulong value);
    public ModelRange get_ModelRange();
}
public class JetBrains.Common.Timeline.Framework.Interface.Markers.SelectableMarkersViewModel : object {
    [CompilerGeneratedAttribute]
private IDataProvider`1<IEnumerable`1<MarkerScreenRange>> <Ranges>k__BackingField;
    [CompilerGeneratedAttribute]
private IDataProvider`1<IEnumerable`1<MarkerScreenRange>> <SelectedRanges>k__BackingField;
    [CompilerGeneratedAttribute]
private IMouseController <MouseController>k__BackingField;
    [CompilerGeneratedAttribute]
private IHitTestProvider <HitTestProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private EventTypeWithModifier <EventType>k__BackingField;
    [CompilerGeneratedAttribute]
private object <PositionCursor>k__BackingField;
    [CompilerGeneratedAttribute]
private EventTypeWithModifier <SelectedEventType>k__BackingField;
    [CompilerGeneratedAttribute]
private double <MarkersHeight>k__BackingField;
    [CompilerGeneratedAttribute]
private double <HitTestBottomMargin>k__BackingField;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    public IDataProvider`1<IEnumerable`1<MarkerScreenRange>> Ranges { get; public set; }
    public IDataProvider`1<IEnumerable`1<MarkerScreenRange>> SelectedRanges { get; public set; }
    public IMouseController MouseController { get; public set; }
    public IHitTestProvider HitTestProvider { get; public set; }
    public EventTypeWithModifier EventType { get; public set; }
    public object PositionCursor { get; public set; }
    public EventTypeWithModifier SelectedEventType { get; public set; }
    public double MarkersHeight { get; public set; }
    public double HitTestBottomMargin { get; public set; }
    [CompilerGeneratedAttribute]
public IDataProvider`1<IEnumerable`1<MarkerScreenRange>> get_Ranges();
    [CompilerGeneratedAttribute]
public void set_Ranges(IDataProvider`1<IEnumerable`1<MarkerScreenRange>> value);
    [CompilerGeneratedAttribute]
public IDataProvider`1<IEnumerable`1<MarkerScreenRange>> get_SelectedRanges();
    [CompilerGeneratedAttribute]
public void set_SelectedRanges(IDataProvider`1<IEnumerable`1<MarkerScreenRange>> value);
    [CompilerGeneratedAttribute]
public IMouseController get_MouseController();
    [CompilerGeneratedAttribute]
public void set_MouseController(IMouseController value);
    [CompilerGeneratedAttribute]
public IHitTestProvider get_HitTestProvider();
    [CompilerGeneratedAttribute]
public void set_HitTestProvider(IHitTestProvider value);
    [CompilerGeneratedAttribute]
public EventTypeWithModifier get_EventType();
    [CompilerGeneratedAttribute]
public void set_EventType(EventTypeWithModifier value);
    [CompilerGeneratedAttribute]
public object get_PositionCursor();
    [CompilerGeneratedAttribute]
public void set_PositionCursor(object value);
    [CompilerGeneratedAttribute]
public EventTypeWithModifier get_SelectedEventType();
    [CompilerGeneratedAttribute]
public void set_SelectedEventType(EventTypeWithModifier value);
    [CompilerGeneratedAttribute]
public double get_MarkersHeight();
    [CompilerGeneratedAttribute]
public void set_MarkersHeight(double value);
    [CompilerGeneratedAttribute]
public double get_HitTestBottomMargin();
    [CompilerGeneratedAttribute]
public void set_HitTestBottomMargin(double value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
}
public class JetBrains.Common.Timeline.Framework.Interface.Markers.SplittersViewModel : object {
    [CompilerGeneratedAttribute]
private EventTypeWithModifier <EventType>k__BackingField;
    [CompilerGeneratedAttribute]
private IDataProvider`1<IEnumerable`1<int>> <ViewDataProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    public EventTypeWithModifier EventType { get; }
    public IDataProvider`1<IEnumerable`1<int>> ViewDataProvider { get; }
    public SplittersViewModel(IDataProvider`1<IEnumerable`1<int>> viewDataProvider, int eventType, int modifier);
    [CompilerGeneratedAttribute]
public EventTypeWithModifier get_EventType();
    [CompilerGeneratedAttribute]
public sealed virtual IDataProvider`1<IEnumerable`1<int>> get_ViewDataProvider();
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
}
public class JetBrains.Common.Timeline.Framework.Interface.PositionedFormattableContent : object {
    [CompilerGeneratedAttribute]
private IFormattable <Content>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Position>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Centered>k__BackingField;
    public IFormattable Content { get; }
    public double Position { get; }
    public bool Centered { get; }
    public PositionedFormattableContent(IFormattable content, double position, bool centered);
    [CompilerGeneratedAttribute]
public IFormattable get_Content();
    [CompilerGeneratedAttribute]
public double get_Position();
    [CompilerGeneratedAttribute]
public bool get_Centered();
}
[ExtensionAttribute]
public static class JetBrains.Common.Timeline.Framework.Interface.RangesEx : object {
    [ExtensionAttribute]
public static ScreenRangeInt CastToScreenInt(ScreenRange range);
    [ExtensionAttribute]
public static ScreenRange Shift(ScreenRange range, double offset);
    [ExtensionAttribute]
public static ScreenRangeInt Round(ScreenRange range);
    [ExtensionAttribute]
public static int DistanceTo(ScreenRangeInt range, int x);
    [ExtensionAttribute]
public static double ConstraintPoint(ModelRangeDouble range, double x);
}
public class JetBrains.Common.Timeline.Framework.Interface.Realtime.ChartRange : ValueType {
    private double myLeft;
    private double myLength;
    public double Left { get; }
    public double Length { get; }
    public double Right { get; }
    public ChartRange(double left, double length);
    public double get_Left();
    public double get_Length();
    public double get_Right();
}
public class JetBrains.Common.Timeline.Framework.Interface.Realtime.ChartWithCurrentValueViewModel : object {
    [CompilerGeneratedAttribute]
private object <Chart>k__BackingField;
    [CompilerGeneratedAttribute]
private CurrentValueViewModel <CurrentValue>k__BackingField;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    public object Chart { get; }
    public CurrentValueViewModel CurrentValue { get; }
    public ChartWithCurrentValueViewModel(object chart, CurrentValueViewModel currentValue);
    [CompilerGeneratedAttribute]
public object get_Chart();
    [CompilerGeneratedAttribute]
public CurrentValueViewModel get_CurrentValue();
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
}
public class JetBrains.Common.Timeline.Framework.Interface.Realtime.CurrentValueViewModel : object {
    [CompilerGeneratedAttribute]
private string <Header>k__BackingField;
    [CompilerGeneratedAttribute]
private IUntypedDataNotifier <FormattedValue>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EventType>k__BackingField;
    [CompilerGeneratedAttribute]
private IDataNotifier`1<double> <Position>k__BackingField;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    public string Header { get; }
    public IUntypedDataNotifier FormattedValue { get; }
    public int EventType { get; }
    public IDataNotifier`1<double> Position { get; }
    public CurrentValueViewModel(string header, IUntypedDataNotifier value, int eventType, IDataProvider`1<double> position);
    [CompilerGeneratedAttribute]
public string get_Header();
    [CompilerGeneratedAttribute]
public IUntypedDataNotifier get_FormattedValue();
    [CompilerGeneratedAttribute]
public int get_EventType();
    [CompilerGeneratedAttribute]
public IDataNotifier`1<double> get_Position();
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
}
public class JetBrains.Common.Timeline.Framework.Interface.Realtime.HorizontalContentPositioningVM : object {
    private double myModelPosition;
    private double myPosition;
    [CompilerGeneratedAttribute]
private object <Content>k__BackingField;
    [CompilerGeneratedAttribute]
private PositioningControlChildPosition <ElementAlignment>k__BackingField;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    public object Content { get; }
    public double Position { get; private set; }
    public PositioningControlChildPosition ElementAlignment { get; }
    public HorizontalContentPositioningVM(double modelPosition, IViewport viewport, object content, Lifetime lifetime, PositioningControlChildPosition elementAlignment);
    [CompilerGeneratedAttribute]
public object get_Content();
    public double get_Position();
    private void set_Position(double value);
    [CompilerGeneratedAttribute]
public PositioningControlChildPosition get_ElementAlignment();
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    private void OnViewportUpdated(IViewport viewport);
}
public interface JetBrains.Common.Timeline.Framework.Interface.Realtime.IChartRangeProvider {
    public ChartRange AvailableRange { get; }
    public abstract virtual ChartRange get_AvailableRange();
}
public interface JetBrains.Common.Timeline.Framework.Interface.Realtime.IDifferedStartTickProvider {
    public abstract virtual void Start();
}
public interface JetBrains.Common.Timeline.Framework.Interface.Realtime.IProcessMonitorDataProvider {
    public IDataProvider`1<bool> HasCounters { get; }
    public abstract virtual IAsyncDataProvider`1<RealtimeDataEntry> SelectEventTypes(IList`1<KnownEventTypes> eventTypes);
    public abstract virtual IDataProvider`1<bool> get_HasCounters();
}
public interface JetBrains.Common.Timeline.Framework.Interface.Realtime.IRealtimeDataFactory {
    public abstract virtual IDataProvider`1<RealtimeDataEntry> CreateCurrentDataProvider(IList`1<int> eventTypes);
    public abstract virtual IDataProvider`1<double> CreateMaxSumProvider(IList`1<int> eventTypes);
    public abstract virtual IDataProvider`1<MultiChartData> CreateChartDataProvider(IList`1<int> eventTypes, IDataProvider`1<ChartRange> rangeProvider, int maxPointsToProvide);
}
public interface JetBrains.Common.Timeline.Framework.Interface.Realtime.ITickHolder {
    public ulong Tick { get; }
    public abstract virtual ulong get_Tick();
}
public interface JetBrains.Common.Timeline.Framework.Interface.Realtime.ITickProvider {
    public IAsyncDataProvider`1<ulong> Provider { get; }
    public abstract virtual IAsyncDataProvider`1<ulong> get_Provider();
}
public interface JetBrains.Common.Timeline.Framework.Interface.Realtime.IViewportFactory {
    public abstract virtual IViewport CreateViewportAlignedToRight(Lifetime lifetime, TimeSpan visibleRange);
    public abstract virtual IViewport CreateViewport(Lifetime lifetime);
    public abstract virtual IViewport CreateViewport(Lifetime lifetime, ulong startTick);
}
public enum JetBrains.Common.Timeline.Framework.Interface.Realtime.PositioningControlChildPosition : Enum {
    public int value__;
    public static PositioningControlChildPosition Right;
    public static PositioningControlChildPosition Left;
    public static PositioningControlChildPosition Center;
}
public class JetBrains.Common.Timeline.Framework.Interface.Realtime.RealtimeDataEntry : ValueType {
    public ulong Tick;
    public Double[] Values;
    public RealtimeDataEntry(ulong tick, Double[] values);
    public RealtimeDataEntry(int size);
}
[ExtensionAttribute]
public static class JetBrains.Common.Timeline.Framework.Interface.Realtime.RealtimeDataFactoryExtensions : object {
    [ExtensionAttribute]
public static IEnumerable`1<IDataProvider`1<PointsChartViewData>> CreatePointsChartViewDataProviders(IRealtimeDataFactory realtimeDataFactory, IList`1<RealtimeEventType> eventTypes, IDataProvider`1<ChartRange> rangeProvider, int pointsToProvide);
    private static IDataProvider`1<PointsChartViewData> CreatePointsChartViewDataProvider(IRealtimeDataFactory realtimeDataFactory, RealtimeEventType eventType, IList`1<int> availableEventTypes, IDataProvider`1<MultiChartData> chartProvider);
}
public class JetBrains.Common.Timeline.Framework.Interface.Realtime.RealtimeEventType : ValueType {
    public int EventType;
    public Nullable`1<double> MaxValue;
    public RealtimeEventType(int eventType, Nullable`1<double> maxValue);
}
public class JetBrains.Common.Timeline.Framework.Interface.Realtime.RealtimeSessionContext : object {
    public object ViewModel;
    public IDataProvider`1<bool> IsRecording;
    public RealtimeSessionContext(object viewModel, IDataProvider`1<bool> isRecording);
}
public class JetBrains.Common.Timeline.Framework.Interface.Realtime.RealtimeViewModel : object {
    [CompilerGeneratedAttribute]
private IViewport <RangeScrollBarViewport>k__BackingField;
    [CompilerGeneratedAttribute]
private object <RangeScrollBarContent>k__BackingField;
    [CompilerGeneratedAttribute]
private object <ForegroundContent>k__BackingField;
    [CompilerGeneratedAttribute]
private object <BackgroundContent>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<ChartWithCurrentValueViewModel> <Series>k__BackingField;
    [CompilerGeneratedAttribute]
private IViewport <Viewport>k__BackingField;
    [CompilerGeneratedAttribute]
private IWriteableDataNotifier`1<bool> <IsRecordingSnapshot>k__BackingField;
    [CompilerGeneratedAttribute]
private ITimeScaleViewModel <TimeScale>k__BackingField;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    public IViewport RangeScrollBarViewport { get; }
    public object RangeScrollBarContent { get; }
    public object ForegroundContent { get; }
    public object BackgroundContent { get; }
    public IEnumerable`1<ChartWithCurrentValueViewModel> Series { get; }
    public IViewport Viewport { get; }
    public IWriteableDataNotifier`1<bool> IsRecordingSnapshot { get; }
    public ITimeScaleViewModel TimeScale { get; }
    public RealtimeViewModel(IViewport viewport, IEnumerable`1<ChartWithCurrentValueViewModel> series, object foregroundContent, IWriteableDataNotifier`1<bool> collectingSnapshot, ITimeScaleViewModel timeScale, object backgroundContent, object rangeScrollBarContent, IViewport rangeScrollBarViewport);
    [CompilerGeneratedAttribute]
public IViewport get_RangeScrollBarViewport();
    [CompilerGeneratedAttribute]
public object get_RangeScrollBarContent();
    [CompilerGeneratedAttribute]
public object get_ForegroundContent();
    [CompilerGeneratedAttribute]
public object get_BackgroundContent();
    [CompilerGeneratedAttribute]
public IEnumerable`1<ChartWithCurrentValueViewModel> get_Series();
    [CompilerGeneratedAttribute]
public IViewport get_Viewport();
    [CompilerGeneratedAttribute]
public IWriteableDataNotifier`1<bool> get_IsRecordingSnapshot();
    [CompilerGeneratedAttribute]
public ITimeScaleViewModel get_TimeScale();
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
}
public class JetBrains.Common.Timeline.Framework.Interface.Realtime.StorableChartData : object {
    [CompilerGeneratedAttribute]
private MultiChartData <Data>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <StartTime>k__BackingField;
    public MultiChartData Data { get; }
    public DateTime StartTime { get; }
    public StorableChartData(MultiChartData data, DateTime startTime);
    [CompilerGeneratedAttribute]
public MultiChartData get_Data();
    [CompilerGeneratedAttribute]
public DateTime get_StartTime();
}
public class JetBrains.Common.Timeline.Framework.Interface.Realtime.VerticalContentProgressVM : object {
    [CompilerGeneratedAttribute]
private object <Content>k__BackingField;
    [CompilerGeneratedAttribute]
private IProperty`1<double> <Progress>k__BackingField;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    public object Content { get; }
    public IProperty`1<double> Progress { get; }
    public VerticalContentProgressVM(object content, IProperty`1<double> progress);
    [CompilerGeneratedAttribute]
public object get_Content();
    [CompilerGeneratedAttribute]
public IProperty`1<double> get_Progress();
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
}
[ExtensionAttribute]
public static class JetBrains.Common.Timeline.Framework.Interface.Realtime.ViewportExtensions : object {
    [ExtensionAttribute]
public static IDataProvider`1<ChartRange> ToChartRangeProvider(IViewport viewport);
    private static ChartRange ViewportToChartRange(IViewport viewport);
}
public class JetBrains.Common.Timeline.Framework.Interface.ScreenRangeInt : ValueType {
    private int myLeft;
    private int myRight;
    public int Left { get; public set; }
    public int Right { get; public set; }
    public bool Empty { get; }
    public UInt32 Length { get; }
    public ScreenRangeInt(int left, UInt32 length);
    public int get_Left();
    public void set_Left(int value);
    public int get_Right();
    public void set_Right(int value);
    public bool get_Empty();
    public UInt32 get_Length();
    public static ScreenRangeInt FromBorders(int left, int right);
    public ModelRangeDouble CastToModelDouble();
    [LocalizableAttribute("False")]
public virtual string ToString();
    public ScreenRangeInt Intersect(ScreenRangeInt range);
    public bool Contains(ScreenRangeInt desiredRange);
    public bool Contains(int x);
}
public interface JetBrains.Common.Timeline.Framework.Interface.SelectionHosts.IChartBordersSelectionHost {
    public int EventType { get; }
    public abstract virtual int get_EventType();
}
public interface JetBrains.Common.Timeline.Framework.Interface.SelectionHosts.ICompactRangeSelectionHost {
}
public interface JetBrains.Common.Timeline.Framework.Interface.SelectionHosts.IPointsChartSelectionHost {
    public IPointsChartViewModel Owner { get; }
    public abstract virtual IPointsChartViewModel get_Owner();
}
public interface JetBrains.Common.Timeline.Framework.Interface.SelectionHosts.IRangeSelectionHost {
    public IWriteableDataNotifier`1<ScreenRange> ScreenRangeNotifier { get; }
    public IDataController`1<ScreenRange> ScreenRange { get; }
    public IDataController`1<ModelRange> ModelRange { get; }
    public IDataNotifier`1<ModelRange> ModelRangeNotifier { get; }
    public bool IsInteractive { get; public set; }
    public abstract virtual IWriteableDataNotifier`1<ScreenRange> get_ScreenRangeNotifier();
    public abstract virtual IDataController`1<ScreenRange> get_ScreenRange();
    public abstract virtual IDataController`1<ModelRange> get_ModelRange();
    public abstract virtual IDataNotifier`1<ModelRange> get_ModelRangeNotifier();
    public abstract virtual bool get_IsInteractive();
    public abstract virtual void set_IsInteractive(bool value);
    public abstract virtual void SetScreenAndModelRanges(ScreenRange screenRange, ModelRange modelRange);
}
public interface JetBrains.Common.Timeline.Framework.Interface.SelectionHosts.ISelectionHost {
    public IDataController`1<bool> IsActive { get; }
    public IDataNotifier`1<bool> IsActiveNotifier { get; }
    public IMouseController MouseController { get; public set; }
    public abstract virtual void CopyFrom(ISelectionHost selection);
    public abstract virtual IDataController`1<bool> get_IsActive();
    public abstract virtual IDataNotifier`1<bool> get_IsActiveNotifier();
    public abstract virtual IMouseController get_MouseController();
    public abstract virtual void set_MouseController(IMouseController value);
    public abstract virtual IDataProvider`1<ISelectionHost> AsProvider();
}
public interface JetBrains.Common.Timeline.Framework.Interface.SelectionHosts.IWormSelectionHost {
    public SingleChartTypes ChartType { get; }
    public abstract virtual SingleChartTypes get_ChartType();
}
public enum JetBrains.Common.Timeline.Framework.Interface.StringKeys : Enum {
    public int value__;
    public static StringKeys NativeThread;
    public static StringKeys MainThread;
    public static StringKeys ThreadPoolWorker;
    public static StringKeys ThreadPoolIO;
    public static StringKeys GCThread;
    public static StringKeys FinalizerThread;
    public static StringKeys OtherCLRThread;
    public static StringKeys UserThread;
}
public class JetBrains.Common.Timeline.Framework.Interface.Theming.CommonThemeBrushes : object {
    public static object SnapshotArrowBrushKey;
    public static object TimeScaleThicsBrushKey;
    public static object TimeScaleFrameBorder;
    public static object TimeScaleFrameThicks;
    public static object SmallTimeScaleText;
    public static object LargeTimeScaleText;
    private static CommonThemeBrushes();
}
public class JetBrains.Common.Timeline.Framework.Interface.Theming.EventTypeThemeColor : DualThemeColor {
    private static string NamePrefix;
    protected static IList`1<EventTypeThemeColor> AllColorsList;
    private static IDictionary`2<EventTypeWithModifier, EventTypeThemeColor> EventTypeToColor;
    public static Color ChartBackgroundDark;
    private static Color OurStub;
    public static EventTypeThemeColor Unknown;
    public static EventTypeThemeColor UnknownBorder;
    public static EventTypeThemeColor GC;
    public static EventTypeThemeColor GCBackground;
    public static EventTypeThemeColor GCChartBackground;
    public static EventTypeThemeColor GCBorder;
    public static EventTypeThemeColor GCSelectionBorder;
    public static EventTypeThemeColor ThreadActivation;
    public static EventTypeThemeColor Contention;
    public static EventTypeThemeColor ContentionText;
    public static EventTypeThemeColor ContentionChartBackground;
    public static EventTypeThemeColor ContentionSelectionBorder;
    public static EventTypeThemeColor UnknownState;
    public static EventTypeThemeColor RuntimeRunning;
    public static EventTypeThemeColor Running;
    public static EventTypeThemeColor RunningBackground;
    public static EventTypeThemeColor RunningBorder;
    public static EventTypeThemeColor Idle;
    public static EventTypeThemeColor Preemption;
    public static EventTypeThemeColor Exception;
    public static EventTypeThemeColor ExceptionText;
    public static EventTypeThemeColor ExceptionSelectionBorder;
    public static EventTypeThemeColor Finalizers;
    public static EventTypeThemeColor OtherSuspends;
    public static EventTypeThemeColor Sleep;
    public static EventTypeThemeColor Attaching;
    public static EventTypeThemeColor DiskIO;
    public static EventTypeThemeColor PageLoading;
    public static EventTypeThemeColor FileIO;
    public static EventTypeThemeColor FileIOBorder;
    public static EventTypeThemeColor FileIOSelectionBorder;
    public static EventTypeThemeColor FileIOChartBackground;
    public static EventTypeThemeColor Dead;
    public static EventTypeThemeColor AllocationTick;
    public static EventTypeThemeColor AllocationTickSelectionBorder;
    public static EventTypeThemeColor IORead;
    public static EventTypeThemeColor IOWrite;
    public static EventTypeThemeColor Gen0;
    public static EventTypeThemeColor Gen1;
    public static EventTypeThemeColor Gen2;
    public static EventTypeThemeColor GenLoh;
    public static EventTypeThemeColor LohAllocations;
    public static EventTypeThemeColor EtwEventCallStack;
    public static EventTypeThemeColor EtwSample;
    public static EventTypeThemeColor EtwSampleSelected;
    public static EventTypeThemeColor CallStackInversion;
    public static EventTypeThemeColor CustomEvent;
    public static EventTypeThemeColor ApiEvent;
    public static EventTypeThemeColor DelegatesExecution;
    public static EventTypeThemeColor ConversionErrors;
    public static EventTypeThemeColor Lost;
    public static EventTypeThemeColor MessageCheckDelay;
    public static EventTypeThemeColor UiFreezeTickChartBackground;
    public static EventTypeThemeColor UiFreezeTick;
    public static EventTypeThemeColor UiFreezeInterval;
    public static EventTypeThemeColor UiFreezeIntervalBackground;
    public static EventTypeThemeColor UiFreezeIntervalSelected;
    public static EventTypeThemeColor MemoryManagement;
    public static EventTypeThemeColor MemoryUsage;
    public static EventTypeThemeColor MemoryUsageChartBackground;
    public static EventTypeThemeColor SnapshotBackground;
    public static EventTypeThemeColor SnapshotBorder;
    public static EventTypeThemeColor Splitters1;
    public static EventTypeThemeColor Splitters2;
    public static EventTypeThemeColor Splitters3;
    public static EventTypeThemeColor ThreadSelectionStroke;
    public static EventTypeThemeColor TimeSelection;
    public static EventTypeThemeColor TimeSelectionHover;
    public static EventTypeThemeColor TimeSelectionBorder;
    public static EventTypeThemeColor FileIOText;
    public static EventTypeThemeColor PreemptionText;
    public static EventTypeThemeColor ExternalBorders;
    public static EventTypeThemeColor MainBackground;
    public static EventTypeThemeColor ThreadLifetimeBorder;
    public static EventTypeThemeColor CurrentIntervalSet;
    public static EventTypeThemeColor CurrentIntervalSetSelected;
    public static EventTypeThemeColor CurrentIntervalSetSelectedBackground;
    public static EventTypeThemeColor HighlightedMarker;
    public static EventTypeThemeColor CpuUsage;
    public static EventTypeThemeColor CpuUsageBorder;
    public static EventTypeThemeColor CpuUsageChartBackground;
    public static EventTypeThemeColor TotalMemory;
    public static EventTypeThemeColor TotalMemoryBorder;
    public static EventTypeThemeColor TotalMemoryChartBackground;
    public static EventTypeThemeColor TotalNetMemory;
    public static EventTypeThemeColor FreeMemory;
    public static EventTypeThemeColor UnmanagedMemory;
    public static EventTypeThemeColor MemorySnapshot;
    public static IEnumerable`1<EventTypeThemeColor> All { get; }
    public EventTypeThemeColor(string name, Color lightColor, Color darkColor, KnownEventTypes eventType, int modifier);
    public EventTypeThemeColor(string name, Color color, KnownEventTypes eventType, int modifier);
    public EventTypeThemeColor(string name, KnownEventTypes eventType, int modifier);
    public EventTypeThemeColor(string name, DualThemeColor other, KnownEventTypes eventType, int modifier);
    private static EventTypeThemeColor();
    public static IEnumerable`1<EventTypeThemeColor> get_All();
    [NotNullAttribute]
public static EventTypeThemeColor Resolve(int eventType, int modifier);
    [CanBeNullAttribute]
public static EventTypeThemeColor TryResolve(int eventType, int modifier);
}
public static class JetBrains.Common.Timeline.Framework.Interface.Theming.TimelineCommonBrushes : object {
    public static object FilterHeaderForeground;
    public static object ToolWindowForeground;
    public static object ControlDefaultBorderBrush;
    public static object TimelineHover;
    public static object TimelineSelection;
    public static object TimelineSelectionStroke;
    public static object TimelineSelectionStrokeLight;
    public static object VSFilterHeaderDashForeground;
    private static TimelineCommonBrushes();
}
public class JetBrains.Common.Timeline.Framework.Interface.Theming.TimelineThemeColor : DualThemeColor {
    protected static IList`1<TimelineThemeColor> AllColorsList;
    public static TimelineThemeColor VSChartsToolWindowBackground;
    public static TimelineThemeColor PanelBackground;
    public static TimelineThemeColor VSFilterHeaderDashForeground;
    public static TimelineThemeColor ChartMarkersBorder;
    public static TimelineThemeColor ChartMarkersBorderLight;
    public static TimelineThemeColor ChartMarkersFillBlock;
    public static TimelineThemeColor ChartMarkersFillBlockLight;
    public static TimelineThemeColor TimelineHighlightStroke;
    public static TimelineThemeColor PositionCursorFill;
    public static TimelineThemeColor MarkerHover;
    public static TimelineThemeColor PinnedHighlightingColor;
    public static TimelineThemeColor Fade;
    public static TimelineThemeColor RangeScrollBarFade;
    public static TimelineThemeColor RangeScrollBarHover;
    public static TimelineThemeColor RangeScrollBarBorder;
    public static TimelineThemeColor RangeScrollBarHandle;
    public static TimelineThemeColor TimelineHover;
    public static TimelineThemeColor CallTreeTransitionArrowFill;
    public static TimelineThemeColor CallTreeTransitionArrowStroke;
    public static Color TimelineSelectionRawColor;
    public static TimelineThemeColor TimelineSelection;
    public static TimelineThemeColor IntervalTooltipBackground;
    public static TimelineThemeColor TimelineSelectionStroke;
    public static Color TimelineSelectionStrokeLightRawColor;
    public static TimelineThemeColor TimelineSelectionStrokeLight;
    public static TimelineThemeColor TimelineHoverAtSelection;
    public static TimelineThemeColor SystemFrameForeground;
    public static TimelineThemeColor ArrowFill;
    public static TimelineThemeColor ArrowStroke;
    public static TimelineThemeColor ArrowFillHover;
    public static TimelineThemeColor ArrowStrokeHover;
    public static TimelineThemeColor HeaderSelectionBackground;
    public static TimelineThemeColor SummaryChartBorder;
    public static TimelineThemeColor SummaryChartInternalBorder;
    public static TimelineThemeColor SummaryChartBackground;
    public static TimelineThemeColor PositionCursor;
    public static TimelineThemeColor SelectionBorders;
    public static TimelineThemeColor SelectionBordersStroke;
    public static TimelineThemeColor PositionCursorTooltipBackground;
    public static TimelineThemeColor PositionCursorTooltipBorder;
    public static TimelineThemeColor TableAlternativeRowColor;
    public static TimelineThemeColor TableRowBorderColor;
    public static TimelineThemeColor TablePopupBackground;
    public static TimelineThemeColor TablePopupForeground;
    public static TimelineThemeColor TablePopupButtonBorder;
    public static TimelineThemeColor TablePopupButtonInvertedBorder;
    public static TimelineThemeColor TablePopupButtonBackground;
    public static TimelineThemeColor TablePopupButtonInvertedBackground;
    public static TimelineThemeColor TableFilteredRowBackground;
    public static TimelineThemeColor MarkedFunctionHeaderCountForeground;
    public static TimelineThemeColor MarkedFunctionHeaderBackground;
    public static TimelineThemeColor MarkedSelectedFunctionBackground;
    public static TimelineThemeColor RecursionHighligtingBackground;
    public static TimelineThemeColor RecursionHighligtingBorder;
    public static TimelineThemeColor BlinkingDotsForeground;
    public static TimelineThemeColor PayloadForeground;
    public static TimelineThemeColor PayloadPlusForeground;
    public static TimelineThemeColor PayloadMinusForeground;
    public static TimelineThemeColor OwnPayloadForeground;
    public static TimelineThemeColor PayloadWhenExcludedForeground;
    public static TimelineThemeColor ExcludedCallTreePathForeground;
    public static TimelineThemeColor MinorTextForeground;
    public static TimelineThemeColor ColumnHeaderForeground;
    public static TimelineThemeColor KeywordForeground;
    public static TimelineThemeColor AppliedFilterForeground;
    public static TimelineThemeColor AppliedFilterForegroundHover;
    public static TimelineThemeColor CrossForeground;
    public static TimelineThemeColor FilterFocusBackground;
    public static TimelineThemeColor ExpanderHeaderDefaultBackground;
    public static TimelineThemeColor TimelineHeaderHoverBorder;
    public static TimelineThemeColor FilterHeaderForeground;
    public static TimelineThemeColor VSFilterCheckboxHoverBackground;
    public static TimelineThemeColor VSFilterCheckboxHoverBorder;
    public static TimelineThemeColor FilterHeaderHoverForeground;
    public static TimelineThemeColor CallTreePopRootButton;
    public static TimelineThemeColor CallTreeSearchIconBackgroundHover;
    public static TimelineThemeColor CallTreeSearchIconBackgroundHoverVs;
    public static TimelineThemeColor ControlDefaultBorderBrush;
    public static TimelineThemeColor AppliedFiltersBackground;
    public static TimelineThemeColor EventTableDetailHeaderBackground;
    public static TimelineThemeColor TimelineScrollBarBackground;
    public static TimelineThemeColor TimelineScrollBarBorder;
    public static TimelineThemeColor TimelineScrollBarThumb;
    public static TimelineThemeColor TimelineScrollBarThumbHovered;
    public static TimelineThemeColor TimelineScrollBarThumbPressed;
    public static TimelineThemeColor TimelineScrollBarButtonForeground;
    public static TimelineThemeColor TimelineScrollBarButtonForegroundPressed;
    public static TimelineThemeColor TimelineScrollBarButtonForegroundHovered;
    public static TimelineThemeColor TimelineScrollBarButtonBackgroundHovered;
    public static TimelineThemeColor TimelineScrollBarButtonBackgroundPressed;
    public static TimelineThemeColor ProcessingErrorsBackground;
    public static TimelineThemeColor ProcessingWarningForeground;
    public static TimelineThemeColor ProcessingErrorForeground;
    public static TimelineThemeColor HyperlinkButtonNotSelectedForeground;
    public static TimelineThemeColor SnapshotArrow;
    public static TimelineThemeColor TimeScaleThicks;
    public static TimelineThemeColor SmallTimeScaleText;
    public static TimelineThemeColor LargeTimeScaleText;
    public static TimelineThemeColor TimeScaleFrameBorder;
    public static TimelineThemeColor TimeScaleFrameThicks;
    public static TimelineThemeColor ProgressBackground;
    public static TimelineThemeColor ProgessForeground;
    public static TimelineThemeColor TimelineCallTreeSelectedChildrenBackground;
    public static TimelineThemeColor SnapshotProcessingProgressBackground;
    public static TimelineThemeColor SnapshotProcessingProgressForground;
    public static TimelineThemeColor SnapshotProcessingCancelButtonBackground;
    public static TimelineThemeColor SnapshotProcessingCancelButtonHoverBackground;
    public static TimelineThemeColor SnapshotProcessingCancelButtonBorder;
    public static TimelineThemeColor SnapshotProcessingCancelButtonHoverBorder;
    public static TimelineThemeColor SnapshotProcessingCancellButtonPressedBackground;
    public static TimelineThemeColor SnapshotProcessingCancellButtonPressedBorder;
    public static TimelineThemeColor ZoomSliderBackground;
    public static TimelineThemeColor ZoomSliderThumb;
    public static TimelineThemeColor ZoomSliderThumbHover;
    public static TimelineThemeColor ZoomSliderThumbPressed;
    public static TimelineThemeColor SortArrowForeground;
    public static TimelineThemeColor ThreadsButtonBackground;
    public static TimelineThemeColor ThreadsButtonBackgroundHover;
    public static TimelineThemeColor ThreadsButtonBackgroundPressed;
    public static TimelineThemeColor ThreadsButtonBorder;
    public static TimelineThemeColor ThreadsButtonBorderHover;
    public static TimelineThemeColor ThreadsButtonBorderPressed;
    public static TimelineThemeColor ThreadsButtonPopupBackground;
    public static TimelineThemeColor GrayedTextForeground;
    public static TimelineThemeColor SearchBoxBackground;
    public static TimelineThemeColor TableBackground;
    public static TimelineThemeColor TableHeaderBackground;
    public static TimelineThemeColor SearchBoxWatermarkForeground;
    public static TimelineThemeColor EventTableDetailsMethodForeground;
    public static TimelineThemeColor EventTableDetailsTypeForeground;
    public static TimelineThemeColor CallTreeTransitionsPanelBackground;
    public static TimelineThemeColor CallTreePrefixItemBackground;
    public static TimelineThemeColor LinkButtonForeground;
    public static TimelineThemeColor LinkButtonHoverForeground;
    public static TimelineThemeColor ToolWindowHeaderBackground;
    public static TimelineThemeColor ToolWindowHeaderBackgroundInactive;
    public static TimelineThemeColor ToolWindowHeaderForeground;
    public static TimelineThemeColor ToolWindowHeaderForegroundInactive;
    public static TimelineThemeColor DocumentTabHeaderBackgroundSelected;
    public static TimelineThemeColor DocumentTabHeaderBackgroundHover;
    public static TimelineThemeColor DocumentTabHeaderBackgroundInactive;
    public static TimelineThemeColor DocumentTabHeaderBackgroundDisabled;
    public static TimelineThemeColor DocumentTabHeaderForegroundSelected;
    public static TimelineThemeColor DocumentTabHeaderForegroundInactive;
    public static TimelineThemeColor DocumentTabHeaderForegroundDisabled;
    public static TimelineThemeColor DocumentTabHeaderForegroundHover;
    public static TimelineThemeColor ToolTabHeaderBackgroundSelected;
    public static TimelineThemeColor ToolTabHeaderBackgroundHover;
    public static TimelineThemeColor ToolTabHeaderBackgroundInactive;
    public static TimelineThemeColor ToolTabHeaderBackgroundDisabled;
    public static TimelineThemeColor ToolTabHeaderForegroundSelected;
    public static TimelineThemeColor ToolTabHeaderForegroundInactive;
    public static TimelineThemeColor ToolTabHeaderForegroundDisabled;
    public static TimelineThemeColor ToolTabHeaderForegroundHover;
    public static TimelineThemeColor ToolWindowButton;
    public static TimelineThemeColor ToolWindowButtonHover;
    public static TimelineThemeColor ToolWindowButtonPressed;
    public static TimelineThemeColor Transparent;
    public static TimelineThemeColor PropertiesDialogBackground;
    public static TimelineThemeColor PropertiesDialogBorder;
    public static TimelineThemeColor PropertiesDialogTablesSeparator;
    public static IEnumerable`1<TimelineThemeColor> All { get; }
    public TimelineThemeColor(string name, Color lightColor, Color darkColor);
    public TimelineThemeColor(string name, Color color);
    public TimelineThemeColor(string name, DualThemeColor other);
    private static TimelineThemeColor();
    public static IEnumerable`1<TimelineThemeColor> get_All();
}
public class JetBrains.Common.Timeline.Framework.Interface.TimeScaleFrame : AAutomation {
    [CompilerGeneratedAttribute]
private IDataNotifier`1<PeriodAndOffset> <MiddleTicks>k__BackingField;
    [CompilerGeneratedAttribute]
private IDataNotifier`1<PeriodAndOffset> <LargeTicks>k__BackingField;
    public IDataNotifier`1<PeriodAndOffset> MiddleTicks { get; }
    public IDataNotifier`1<PeriodAndOffset> LargeTicks { get; }
    public TimeScaleFrame(IDataNotifier`1<PeriodAndOffset> middleTicks, IDataNotifier`1<PeriodAndOffset> largeTicks);
    [CompilerGeneratedAttribute]
public IDataNotifier`1<PeriodAndOffset> get_MiddleTicks();
    [CompilerGeneratedAttribute]
public IDataNotifier`1<PeriodAndOffset> get_LargeTicks();
}
[ExtensionAttribute]
public static class JetBrains.Common.Timeline.Framework.Interface.UtilExtensions : object {
    [ExtensionAttribute]
public static bool IsDefault(T value, IEqualityComparer`1<T> comparer);
}
public class JetBrains.Common.Timeline.Framework.Interface.Wrappers.AdornedViewModel : object {
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    [CompilerGeneratedAttribute]
private object <Content>k__BackingField;
    [CompilerGeneratedAttribute]
private object <AdornedContent>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <BindWidth>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <BindHeight>k__BackingField;
    public object Content { get; public set; }
    public object AdornedContent { get; public set; }
    public bool BindWidth { get; public set; }
    public bool BindHeight { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public object get_Content();
    [CompilerGeneratedAttribute]
public void set_Content(object value);
    [CompilerGeneratedAttribute]
public object get_AdornedContent();
    [CompilerGeneratedAttribute]
public void set_AdornedContent(object value);
    [CompilerGeneratedAttribute]
public bool get_BindWidth();
    [CompilerGeneratedAttribute]
public void set_BindWidth(bool value);
    [CompilerGeneratedAttribute]
public bool get_BindHeight();
    [CompilerGeneratedAttribute]
public void set_BindHeight(bool value);
}
public class JetBrains.Common.Timeline.Framework.Interface.Wrappers.AlignedViewModel : object {
    [CompilerGeneratedAttribute]
private VertAlignment <VerticalAlignment>k__BackingField;
    [CompilerGeneratedAttribute]
private HorizontalAlignment <HorizontalAlignment>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Content>k__BackingField;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    public VertAlignment VerticalAlignment { get; public set; }
    public HorizontalAlignment HorizontalAlignment { get; public set; }
    public object Content { get; }
    public AlignedViewModel(object content, VertAlignment verticalAlignment, HorizontalAlignment horizontalAlignment);
    [CompilerGeneratedAttribute]
public VertAlignment get_VerticalAlignment();
    [CompilerGeneratedAttribute]
public void set_VerticalAlignment(VertAlignment value);
    [CompilerGeneratedAttribute]
public HorizontalAlignment get_HorizontalAlignment();
    [CompilerGeneratedAttribute]
public void set_HorizontalAlignment(HorizontalAlignment value);
    [CompilerGeneratedAttribute]
public object get_Content();
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
}
public class JetBrains.Common.Timeline.Framework.Interface.Wrappers.ClickDragController : ValueType {
    [CompilerGeneratedAttribute]
private IMouseDragController <MouseDragController>k__BackingField;
    [CompilerGeneratedAttribute]
private IMouseController <MouseController>k__BackingField;
    public IMouseDragController MouseDragController { get; }
    public IMouseController MouseController { get; }
    public ClickDragController(IMouseController mouseController, IMouseDragController mouseDragController);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public IMouseDragController get_MouseDragController();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public IMouseController get_MouseController();
}
public class JetBrains.Common.Timeline.Framework.Interface.Wrappers.ClippedViewModel : object {
    [CompilerGeneratedAttribute]
private object <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private IDataProvider`1<IEnumerable`1<ScreenRangeInt>> <ClipProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    public object Source { get; }
    public IDataProvider`1<IEnumerable`1<ScreenRangeInt>> ClipProvider { get; }
    public ClippedViewModel(object source, IDataProvider`1<IEnumerable`1<ScreenRangeInt>> clipProvider);
    [CompilerGeneratedAttribute]
public object get_Source();
    [CompilerGeneratedAttribute]
public IDataProvider`1<IEnumerable`1<ScreenRangeInt>> get_ClipProvider();
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
}
public class JetBrains.Common.Timeline.Framework.Interface.Wrappers.FontModifierViewModel : object {
    [CompilerGeneratedAttribute]
private object <Content>k__BackingField;
    [CompilerGeneratedAttribute]
private FontWeight <FontWeight>k__BackingField;
    [CompilerGeneratedAttribute]
private FontStyle <FontStyle>k__BackingField;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    public object Content { get; }
    public FontWeight FontWeight { get; public set; }
    public FontStyle FontStyle { get; public set; }
    public FontModifierViewModel(object content);
    [CompilerGeneratedAttribute]
public object get_Content();
    [CompilerGeneratedAttribute]
public FontWeight get_FontWeight();
    [CompilerGeneratedAttribute]
public void set_FontWeight(FontWeight value);
    [CompilerGeneratedAttribute]
public FontStyle get_FontStyle();
    [CompilerGeneratedAttribute]
public void set_FontStyle(FontStyle value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
}
public enum JetBrains.Common.Timeline.Framework.Interface.Wrappers.HideMode : Enum {
    public int value__;
    public static HideMode Slide;
    public static HideMode Collapse;
    public static HideMode FadeOut;
}
public enum JetBrains.Common.Timeline.Framework.Interface.Wrappers.HorizontalAlignment : Enum {
    public int value__;
    public static HorizontalAlignment Left;
    public static HorizontalAlignment Center;
    public static HorizontalAlignment Right;
    public static HorizontalAlignment Stretch;
}
public interface JetBrains.Common.Timeline.Framework.Interface.Wrappers.IHideableViewModel {
    public object Content { get; }
    public IDataNotifier`1<bool> IsVisible { get; }
    public HideMode Mode { get; }
    public abstract virtual object get_Content();
    public abstract virtual IDataNotifier`1<bool> get_IsVisible();
    public abstract virtual HideMode get_Mode();
}
public interface JetBrains.Common.Timeline.Framework.Interface.Wrappers.ISimpleOverlappedViewModels {
    public IEnumerable Models { get; }
    public abstract virtual IEnumerable get_Models();
}
public class JetBrains.Common.Timeline.Framework.Interface.Wrappers.MarginsViewModel : object {
    [CompilerGeneratedAttribute]
private double <Margin>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Content>k__BackingField;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    public double Margin { get; }
    public object Content { get; }
    public MarginsViewModel(object content, double margin);
    [CompilerGeneratedAttribute]
public double get_Margin();
    [CompilerGeneratedAttribute]
public object get_Content();
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
}
public class JetBrains.Common.Timeline.Framework.Interface.Wrappers.MouseControllerViewModel : object {
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    [CompilerGeneratedAttribute]
private IMouseController <Controller>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HandCursor>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Content>k__BackingField;
    public IMouseController Controller { get; public set; }
    public bool HandCursor { get; public set; }
    public object Content { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public IMouseController get_Controller();
    [CompilerGeneratedAttribute]
public void set_Controller(IMouseController value);
    [CompilerGeneratedAttribute]
public bool get_HandCursor();
    [CompilerGeneratedAttribute]
public void set_HandCursor(bool value);
    [CompilerGeneratedAttribute]
public object get_Content();
    [CompilerGeneratedAttribute]
public void set_Content(object value);
}
public class JetBrains.Common.Timeline.Framework.Interface.Wrappers.NotHittestableViewModel : object {
    private object myContent;
    [CompilerGeneratedAttribute]
private IDataNotifier`1<bool> <IsHitTestable>k__BackingField;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    public IDataNotifier`1<bool> IsHitTestable { get; }
    public object Content { get; }
    public NotHittestableViewModel(object content, IDataNotifier`1<bool> isHitTestable);
    [CompilerGeneratedAttribute]
public IDataNotifier`1<bool> get_IsHitTestable();
    public object get_Content();
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
}
public class JetBrains.Common.Timeline.Framework.Interface.Wrappers.OverlappedViewModel : object {
    private object myModel1;
    private object myModel2;
    [CompilerGeneratedAttribute]
private VertAlignment <VertAlignment>k__BackingField;
    [CompilerGeneratedAttribute]
private HorizontalAlignment <HorizontalAlignment>k__BackingField;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    public VertAlignment VertAlignment { get; public set; }
    public HorizontalAlignment HorizontalAlignment { get; public set; }
    public object Model1 { get; }
    public object Model2 { get; }
    public OverlappedViewModel(object model1, object model2);
    [CompilerGeneratedAttribute]
public VertAlignment get_VertAlignment();
    [CompilerGeneratedAttribute]
public void set_VertAlignment(VertAlignment value);
    [CompilerGeneratedAttribute]
public HorizontalAlignment get_HorizontalAlignment();
    [CompilerGeneratedAttribute]
public void set_HorizontalAlignment(HorizontalAlignment value);
    public object get_Model1();
    public object get_Model2();
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
}
[ObsoleteAttribute("Use ViewModelsCollection instead")]
public class JetBrains.Common.Timeline.Framework.Interface.Wrappers.OverlappedViewModels : object {
    [CompilerGeneratedAttribute]
private VertAlignment <VertAlignment>k__BackingField;
    [CompilerGeneratedAttribute]
private HorizontalAlignment <HorizontalAlignment>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable <Models>k__BackingField;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    public VertAlignment VertAlignment { get; public set; }
    public HorizontalAlignment HorizontalAlignment { get; public set; }
    public IEnumerable Models { get; }
    public OverlappedViewModels(IEnumerable models);
    public OverlappedViewModels(Object[] models);
    [CompilerGeneratedAttribute]
public VertAlignment get_VertAlignment();
    [CompilerGeneratedAttribute]
public void set_VertAlignment(VertAlignment value);
    [CompilerGeneratedAttribute]
public HorizontalAlignment get_HorizontalAlignment();
    [CompilerGeneratedAttribute]
public void set_HorizontalAlignment(HorizontalAlignment value);
    [CompilerGeneratedAttribute]
public IEnumerable get_Models();
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
}
public class JetBrains.Common.Timeline.Framework.Interface.Wrappers.ResizeableHeightViewModel : object {
    [CompilerGeneratedAttribute]
private object <Content>k__BackingField;
    [CompilerGeneratedAttribute]
private IWriteableDataNotifier`1<double> <Height>k__BackingField;
    [CompilerGeneratedAttribute]
private IDataNotifier`1<double> <MinHeight>k__BackingField;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    public object Content { get; }
    public IWriteableDataNotifier`1<double> Height { get; }
    public IDataNotifier`1<double> MinHeight { get; }
    public ResizeableHeightViewModel(object content, IDataProvider`1<double> defaultHeight, IDataController`1<double> userHeight);
    [CompilerGeneratedAttribute]
public object get_Content();
    [CompilerGeneratedAttribute]
public IWriteableDataNotifier`1<double> get_Height();
    [CompilerGeneratedAttribute]
public IDataNotifier`1<double> get_MinHeight();
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
}
public class JetBrains.Common.Timeline.Framework.Interface.Wrappers.SimpleOverlappedViewModels : SimpleOverlappedViewModelsBase {
    public SimpleOverlappedViewModels(Object[] models);
    public SimpleOverlappedViewModels(IEnumerable models);
    public void Add(object obj);
}
public class JetBrains.Common.Timeline.Framework.Interface.Wrappers.SimpleOverlappedViewModelsBase : object {
    private ObservableCollection`1<object> myModels;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    public IEnumerable Models { get; }
    public SimpleOverlappedViewModelsBase(Object[] models);
    public SimpleOverlappedViewModelsBase(IEnumerable models);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    public sealed virtual IEnumerable get_Models();
    protected void AddViewModel(object obj);
    protected void RemoveWhere(Func`2<object, bool> predicate);
}
public enum JetBrains.Common.Timeline.Framework.Interface.Wrappers.VertAlignment : Enum {
    public int value__;
    public static VertAlignment Top;
    public static VertAlignment Center;
    public static VertAlignment Bottom;
    public static VertAlignment Stretch;
}
public abstract class JetBrains.Common.Timeline.Framework.Interface.Wrappers.ViewModelsCollection : object {
    private ObservableCollection`1<AlignedViewModel> myItems;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    public ICollection`1<AlignedViewModel> Items { get; }
    public ICollection`1<AlignedViewModel> get_Items();
    public void Add(object viewModel, VertAlignment verticalAlignment, HorizontalAlignment horizontalAlignment);
    public void AddRange(IEnumerable viewModels, VertAlignment verticalAlignment, HorizontalAlignment horizontalAlignment);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
}
public class JetBrains.Common.Timeline.Framework.Interface.Wrappers.ViewModelsGrid : ViewModelsCollection {
}
public class JetBrains.Common.Timeline.Framework.Interface.Wrappers.ViewModelsVerticalStack : ViewModelsCollection {
}
public class JetBrains.Common.Timeline.Framework.Interface.Wrappers.ViewModelWrapper : object {
    [CompilerGeneratedAttribute]
private object <Content>k__BackingField;
    public object Content { get; }
    public ViewModelWrapper(object content);
    [CompilerGeneratedAttribute]
public object get_Content();
}
public class JetBrains.Common.Timeline.Framework.Interface.Wrappers.WrapPanelItems : object {
    [CompilerGeneratedAttribute]
private ObservableCollection`1<object> <ViewModels>k__BackingField;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    public ObservableCollection`1<object> ViewModels { get; }
    public WrapPanelItems(Object[] viewModels);
    [CompilerGeneratedAttribute]
public ObservableCollection`1<object> get_ViewModels();
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
}
[ZoneMarkerAttribute]
public class JetBrains.Common.Timeline.Framework.Interface.ZoneMarker : object {
}
public class JetBrains.Common.UI.WPF.Theming.ColorThemeType : EnumPattern {
    public static ColorThemeType Light;
    public static ColorThemeType Dark;
    protected ColorThemeType(string name);
    private static ColorThemeType();
}
public class JetBrains.Common.UI.WPF.Theming.DualThemeColor : ThemeColor {
    [CompilerGeneratedAttribute]
private Color <DarkColor>k__BackingField;
    public static DualThemeColor Stub;
    public Color DarkColor { get; public set; }
    public Color LightColor { get; }
    public DualThemeColor(string name, Color lightColor, Color darkColor, bool isBrushNeeded);
    private static DualThemeColor();
    [CompilerGeneratedAttribute]
public Color get_DarkColor();
    [CompilerGeneratedAttribute]
public void set_DarkColor(Color value);
    public Color get_LightColor();
}
[ExtensionAttribute]
public static class JetBrains.Common.UI.WPF.Theming.WPFColorExtensions : object {
    [ExtensionAttribute]
public static Color ToGDIColor(Color wpfColor);
}
public interface JetBrains.Common.Util.ViewModel.Transforms.IViewport {
    public ModelRangeDouble VisibleRange { get; public set; }
    public ModelRangeDouble TotalRange { get; }
    public double ScreenWidth { get; public set; }
    public double UnitsPerPixel { get; }
    public double MinUnitsPerPixel { get; }
    public Transform Transform { get; }
    public abstract virtual ModelRangeDouble get_VisibleRange();
    public abstract virtual void set_VisibleRange(ModelRangeDouble value);
    public abstract virtual void SetVisibleRangeCentered(ModelRangeDouble range, double centerPoint);
    public abstract virtual ModelRangeDouble get_TotalRange();
    public abstract virtual double get_ScreenWidth();
    public abstract virtual void set_ScreenWidth(double value);
    public abstract virtual double get_UnitsPerPixel();
    public abstract virtual double get_MinUnitsPerPixel();
    public abstract virtual Transform get_Transform();
    [CompilerGeneratedAttribute]
public abstract virtual void add_Changed(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Changed(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_ScreenWidthChanged(Action value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ScreenWidthChanged(Action value);
}
public interface JetBrains.Common.Util.ViewModel.Transforms.IViewportZoomer {
    public Nullable`1<double> MousePosition { get; }
    public abstract virtual bool CanZoom(double ratio);
    public abstract virtual void Zoom(Nullable`1<double> position, double ratio);
    public abstract virtual bool CanZoomToRange(ModelRangeDouble range);
    public abstract virtual bool ZoomToRange(ModelRangeDouble range);
    public abstract virtual Nullable`1<double> get_MousePosition();
}
public class JetBrains.Common.Util.ViewModel.Transforms.MatrixAnimation : MatrixAnimationBase {
    public static DependencyProperty FromProperty;
    public static DependencyProperty ToProperty;
    public Nullable`1<Matrix> From { get; public set; }
    public Nullable`1<Matrix> To { get; public set; }
    public MatrixAnimation(Matrix toValue, Duration duration);
    public MatrixAnimation(Matrix toValue, Duration duration, FillBehavior fillBehavior);
    public MatrixAnimation(Matrix fromValue, Matrix toValue, Duration duration);
    public MatrixAnimation(Matrix fromValue, Matrix toValue, Duration duration, FillBehavior fillBehavior);
    private static MatrixAnimation();
    public void set_From(Nullable`1<Matrix> value);
    public Nullable`1<Matrix> get_From();
    public void set_To(Nullable`1<Matrix> value);
    public Nullable`1<Matrix> get_To();
    protected virtual Freezable CreateInstanceCore();
    protected virtual Matrix GetCurrentValueCore(Matrix defaultOriginValue, Matrix defaultDestinationValue, AnimationClock animationClock);
    public static double QuadraticEasyInOut(double t);
}
public class JetBrains.Common.Util.ViewModel.Transforms.Viewport : object {
    private IDataControllerContainer`1<ModelRangeDouble> myVisibleRange;
    private IDataController`1<ModelRangeDouble> myTotalRange;
    private double myMinUnitsPerPixel;
    private double myScreenWidth;
    private MatrixTransform myTransform;
    private double myUnitsPerPixel;
    [CompilerGeneratedAttribute]
private EventHandler Changed;
    [CompilerGeneratedAttribute]
private Action ScreenWidthChanged;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    public double MinVisibleRangeLength { get; }
    public ModelRangeDouble VisibleRange { get; public set; }
    public ModelRangeDouble TotalRange { get; public set; }
    public double ScreenWidth { get; public set; }
    public double UnitsPerPixel { get; }
    public Transform Transform { get; }
    public double MinUnitsPerPixel { get; }
    public Viewport(double minUnitsPerPixel, IDataControllerContainer`1<ModelRangeDouble> visibleRange, IDataController`1<ModelRangeDouble> totalRange);
    public double get_MinVisibleRangeLength();
    public sealed virtual ModelRangeDouble get_VisibleRange();
    public sealed virtual void set_VisibleRange(ModelRangeDouble value);
    private ModelRangeDouble AdjustVisibleRange(ModelRangeDouble visibleRange);
    protected ModelRangeDouble AdjustVisibleRange(ModelRangeDouble visibleRange, double centerPoint);
    public void SetVisibleAndTotalRanges(ModelRangeDouble totalRange, ModelRangeDouble visibleRange);
    public sealed virtual void SetVisibleRangeCentered(ModelRangeDouble range, double centerPoint);
    public sealed virtual ModelRangeDouble get_TotalRange();
    public void set_TotalRange(ModelRangeDouble value);
    public sealed virtual double get_ScreenWidth();
    public sealed virtual void set_ScreenWidth(double value);
    public sealed virtual double get_UnitsPerPixel();
    public sealed virtual Transform get_Transform();
    public sealed virtual double get_MinUnitsPerPixel();
    [CompilerGeneratedAttribute]
public sealed virtual void add_Changed(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Changed(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_ScreenWidthChanged(Action value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_ScreenWidthChanged(Action value);
    private void UpdateTransform();
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
private void <.ctor>b__6_0(ModelRangeDouble vr);
    [CompilerGeneratedAttribute]
private void <.ctor>b__6_1(ModelRangeDouble tr);
}
public class JetBrains.Common.Util.ViewModel.Transforms.ViewportData : ValueType {
    public ModelRangeDouble VisibleRange;
    public ModelRangeDouble TotalRange;
    public double ScreenWidth;
}
public static class JetBrains.Common.Util.ViewModel.Transforms.ViewportDataConstants : object {
    public static DataConstant`1<IViewportZoomer> Zoomer;
    private static ViewportDataConstants();
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.ViewModel.Transforms.ViewportDataEx : object {
    [ExtensionAttribute]
public static ViewportData GetViewportData(IViewport vp);
    [ExtensionAttribute]
public static void SetViewportData(Viewport vp, ViewportData data);
    [ExtensionAttribute]
public static IDataProvider`1<ViewportData> GetViewportData(IDataProvider`1<IViewport> vp);
    [ExtensionAttribute]
public static IDataProvider`1<IViewport> ToViewport(IDataProvider`1<ViewportData> data);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.ViewModel.Transforms.ViewportDataProviderEx : object {
    [ExtensionAttribute]
public static IDataProvider`1<IViewport> ToDataProvider(IViewport viewport);
    [ExtensionAttribute]
public static IDataProvider`1<ViewportRanges> ToRangesProvider(IViewport viewport);
    [ExtensionAttribute]
public static IDataProvider`1<double> ToScreenWidthProvider(IViewport viewport);
    [ExtensionAttribute]
public static IDataProvider`1<Nullable`1<ulong>> ScreenToData(IDataProvider`1<IViewport> viewport, IDataProvider`1<Nullable`1<double>> screenPoint);
    [ExtensionAttribute]
public static IDataProvider`1<double> DataToScreen(IDataProvider`1<IViewport> viewport, IDataProvider`1<double> dataPoint);
    [ExtensionAttribute]
public static IDataProvider`1<int> DataToScreen(IDataProvider`1<IViewport> viewport, IDataProvider`1<Nullable`1<ulong>> dataPoint);
    [ExtensionAttribute]
public static IDataProvider`1<ScreenRange> DataToScreen(IDataProvider`1<IViewport> viewport, IDataProvider`1<ModelRangeDouble> range);
    [ExtensionAttribute]
public static IDataProvider`1<Nullable`1<ScreenRange>> DataToScreen(IDataProvider`1<IViewport> viewport, IDataProvider`1<Nullable`1<ModelRange>> range);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.ViewModel.Transforms.ViewportExtensions : object {
    [ExtensionAttribute]
public static double DataToScreen(IViewport viewport, double unit);
    [ExtensionAttribute]
public static double ScreenToData(IViewport viewport, double x);
    [ExtensionAttribute]
public static double ScreenLengthToData(IViewport viewport, double len);
    [ExtensionAttribute]
public static double DataLengthToScreen(IViewport viewport, double len);
    [ExtensionAttribute]
public static bool CouldZoomTo(IViewport viewport, double len);
    [ExtensionAttribute]
public static bool CouldZoomTo(IViewport viewport, ModelRangeDouble range);
    [ExtensionAttribute]
public static ModelRangeDouble ScreenToData(IViewport viewport, ScreenRange range);
    [ExtensionAttribute]
public static ScreenRange DataToScreen(IViewport viewport, ModelRangeDouble range);
    [ExtensionAttribute]
public static ScreenRange DataToScreen(IViewport viewport, ModelRange range);
    [ExtensionAttribute]
public static bool IsValid(IViewport viewport);
    [ExtensionAttribute]
public static Matrix GetTransformationMatrix(IViewport viewport);
    [ExtensionAttribute]
public static IViewport ToTotalViewport(IViewport viewport);
    [ExtensionAttribute]
public static void ZoomToRange(IViewport viewport, ModelRangeDouble selectedScreenRange);
    [ExtensionAttribute]
public static double DataToScreenShiftInvariant(IViewport viewport, double dataX);
    [ExtensionAttribute]
public static ScreenRange DataToScreenShiftInvariant(IViewport viewport, ModelRange range);
}
public class JetBrains.Common.Util.ViewModel.Transforms.ViewportRanges : ValueType {
    public ModelRangeDouble TotalRange;
    public ModelRangeDouble VisibleRange;
    public ViewportRanges(ModelRangeDouble totalRange, ModelRangeDouble visibleRange);
}
public class JetBrains.Common.Util.ViewModel.Transforms.ViewportZoomer : object {
    private IViewport myViewport;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <MousePosition>k__BackingField;
    public Nullable`1<double> MousePosition { get; }
    public ViewportZoomer(IViewport viewport, Nullable`1<double> center);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<double> get_MousePosition();
    public sealed virtual bool CanZoom(double ratio);
    public sealed virtual void Zoom(Nullable`1<double> position, double ratio);
    public sealed virtual bool CanZoomToRange(ModelRangeDouble range);
    public sealed virtual bool ZoomToRange(ModelRangeDouble range);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
