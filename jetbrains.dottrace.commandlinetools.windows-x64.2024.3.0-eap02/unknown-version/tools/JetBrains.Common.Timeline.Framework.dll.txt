public abstract class JetBrains.Common.RealtimeChart.DataModel.AppBrowserRealtimeSettings : object {
    private Int32[] myEventTypesToCollect;
    public ulong TicksPerSecond { get; }
    public double CountersUpdateSnapsInSeconds { get; }
    public string ChartDataFilename { get; }
    public string SnapshotsDataFilename { get; }
    public IList`1<int> EventTypesToCollect { get; }
    public IList`1<RealtimeEventType> EventTypesToDisplay { get; }
    public double ViewportUpdateSpanInSecons { get; }
    public int MaxPointsToShowOnChart { get; }
    public sealed virtual ulong get_TicksPerSecond();
    public sealed virtual double get_CountersUpdateSnapsInSeconds();
    public sealed virtual string get_ChartDataFilename();
    public sealed virtual string get_SnapshotsDataFilename();
    public sealed virtual IList`1<int> get_EventTypesToCollect();
    public abstract virtual IList`1<RealtimeEventType> get_EventTypesToDisplay();
    public abstract virtual double get_ViewportUpdateSpanInSecons();
    public abstract virtual int get_MaxPointsToShowOnChart();
}
public class JetBrains.Common.RealtimeChart.DataModel.ControllableRealtimeChartModel : object {
    private IInMemoryChartStorage myChartStorage;
    private ProcessMonitorDataProvider myProcessMonitorDataProvider;
    [CompilerGeneratedAttribute]
private IDataProvider`1<bool> <HasCounters>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<int> <EventTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <StartTime>k__BackingField;
    [CompilerGeneratedAttribute]
private IRealtimeDataFactory <RealtimeDataFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private IViewportFactory <ViewportFactory>k__BackingField;
    public double LastChartTick { get; }
    public IDataProvider`1<bool> HasCounters { get; }
    public IList`1<int> EventTypes { get; }
    public DateTime StartTime { get; }
    public IRealtimeDataFactory RealtimeDataFactory { get; }
    public IViewportFactory ViewportFactory { get; }
    public ControllableRealtimeChartModel(Lifetime lifetime, IRealtimeSettings realtimeSettings, IDispatcherTimerFactory dispatcherTimerFactory, int pid);
    public double get_LastChartTick();
    [CompilerGeneratedAttribute]
public IDataProvider`1<bool> get_HasCounters();
    [CompilerGeneratedAttribute]
public sealed virtual IList`1<int> get_EventTypes();
    [CompilerGeneratedAttribute]
public sealed virtual DateTime get_StartTime();
    [CompilerGeneratedAttribute]
public sealed virtual IRealtimeDataFactory get_RealtimeDataFactory();
    [CompilerGeneratedAttribute]
public sealed virtual IViewportFactory get_ViewportFactory();
    public sealed virtual void SwitchProcess(int processId);
    private IRealtimeDataFactory CreateRealtimeFactory(Lifetime lifetime, IProcessMonitorDataProvider countersDataProvider, IInMemoryChartStorage storage);
}
public class JetBrains.Common.RealtimeChart.DataModel.DotTraceRealtimeSettings : AppBrowserRealtimeSettings {
    public static DotTraceRealtimeSettings Instance;
    private RealtimeEventType[] myEventTypesToDisplay;
    public IList`1<RealtimeEventType> EventTypesToDisplay { get; }
    public double ViewportUpdateSpanInSecons { get; }
    public int MaxPointsToShowOnChart { get; }
    private static DotTraceRealtimeSettings();
    public virtual IList`1<RealtimeEventType> get_EventTypesToDisplay();
    public virtual double get_ViewportUpdateSpanInSecons();
    public virtual int get_MaxPointsToShowOnChart();
}
public interface JetBrains.Common.RealtimeChart.DataModel.IControllableRealtimeChartModel {
    public abstract virtual void SwitchProcess(int processId);
}
public interface JetBrains.Common.RealtimeChart.DataModel.IRealtimeChartModel {
    public IRealtimeDataFactory RealtimeDataFactory { get; }
    public IViewportFactory ViewportFactory { get; }
    public IList`1<int> EventTypes { get; }
    public DateTime StartTime { get; }
    public abstract virtual IRealtimeDataFactory get_RealtimeDataFactory();
    public abstract virtual IViewportFactory get_ViewportFactory();
    public abstract virtual IList`1<int> get_EventTypes();
    public abstract virtual DateTime get_StartTime();
}
public interface JetBrains.Common.RealtimeChart.DataModel.IRealtimeSettings {
    public int MaxPointsToShowOnChart { get; }
    public ulong TicksPerSecond { get; }
    public double ViewportUpdateSpanInSecons { get; }
    public double CountersUpdateSnapsInSeconds { get; }
    public string ChartDataFilename { get; }
    public string SnapshotsDataFilename { get; }
    public IList`1<int> EventTypesToCollect { get; }
    public IList`1<RealtimeEventType> EventTypesToDisplay { get; }
    public abstract virtual int get_MaxPointsToShowOnChart();
    public abstract virtual ulong get_TicksPerSecond();
    public abstract virtual double get_ViewportUpdateSpanInSecons();
    public abstract virtual double get_CountersUpdateSnapsInSeconds();
    public abstract virtual string get_ChartDataFilename();
    public abstract virtual string get_SnapshotsDataFilename();
    public abstract virtual IList`1<int> get_EventTypesToCollect();
    public abstract virtual IList`1<RealtimeEventType> get_EventTypesToDisplay();
}
public interface JetBrains.Common.RealtimeChart.DataModel.IRealtimeSnapshotController {
    public abstract virtual void StartSnapshot(object id, ulong begin);
    public abstract virtual void FinishSnapshot(object id, ulong end);
    public abstract virtual void DropSnapshot(object id);
}
public class JetBrains.Common.RealtimeChart.DataModel.RealtimeReadingModel : object {
    [CompilerGeneratedAttribute]
private IRealtimeDataFactory <RealtimeDataFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private IViewportFactory <ViewportFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<int> <EventTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <StartTime>k__BackingField;
    public IRealtimeDataFactory RealtimeDataFactory { get; }
    public IViewportFactory ViewportFactory { get; }
    public IList`1<int> EventTypes { get; }
    public DateTime StartTime { get; }
    public RealtimeReadingModel(BinaryReader chartStream);
    [CompilerGeneratedAttribute]
public sealed virtual IRealtimeDataFactory get_RealtimeDataFactory();
    [CompilerGeneratedAttribute]
public sealed virtual IViewportFactory get_ViewportFactory();
    [CompilerGeneratedAttribute]
public sealed virtual IList`1<int> get_EventTypes();
    [CompilerGeneratedAttribute]
public sealed virtual DateTime get_StartTime();
}
public class JetBrains.Common.RealtimeChart.DataModel.RealtimeSnapshotController : object {
    private object myLock;
    private IListEvents`1<RealtimeSnapshot> mySnapshots;
    private IList`1<Tuple`2<object, RealtimeSnapshot>> myMarkedSnapshots;
    public IListEvents`1<RealtimeSnapshot> Snapshots { get; }
    public IListEvents`1<RealtimeSnapshot> get_Snapshots();
    public sealed virtual void StartSnapshot(object id, ulong begin);
    private int GetIndex(object id);
    public sealed virtual void FinishSnapshot(object id, ulong end);
    public sealed virtual void DropSnapshot(object id);
    private RealtimeSnapshot RemoveSnapshotKey(object id);
    private int GetLevel(double snapshotBegin);
}
public static class JetBrains.Common.RealtimeChart.DataModel.RealtimeSnapshotStorage : object {
    private static int HeaderSize;
    private static int RowSize;
    public static IList`1<RealtimeSnapshot> Read(FileStream stream);
    public static void Write(ICollection`1<RealtimeSnapshot> snapshots, FileStream stream);
}
public class JetBrains.Common.RealtimeChart.RealtimeSnapshot : object {
    [CompilerGeneratedAttribute]
private double <Begin>k__BackingField;
    [CompilerGeneratedAttribute]
private double <End>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsFinished>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Level>k__BackingField;
    public double Begin { get; }
    public double End { get; private set; }
    public bool IsFinished { get; private set; }
    public int Level { get; }
    public RealtimeSnapshot(double begin, double end, bool isFinished, int level);
    public RealtimeSnapshot(double begin, int level);
    [CompilerGeneratedAttribute]
public double get_Begin();
    [CompilerGeneratedAttribute]
public double get_End();
    [CompilerGeneratedAttribute]
private void set_End(double value);
    [CompilerGeneratedAttribute]
public bool get_IsFinished();
    [CompilerGeneratedAttribute]
private void set_IsFinished(bool value);
    [CompilerGeneratedAttribute]
public int get_Level();
    public void Finish(double endTick);
}
public static class JetBrains.Common.RealtimeChart.ViewModel.RealtimeModelBuilder : object {
    public static IRealtimeChartModel ReadModel(BinaryReader chartDataFile);
}
public interface JetBrains.Common.Timeline.Framework.Borders.ITimelineElementSelector`1 {
    public ISetProvider`1<bool> IsActive { get; }
    public abstract virtual ISetProvider`1<bool> get_IsActive();
    public abstract virtual void AutoSelect(Point screenPoint, T selection);
    [CompilerGeneratedAttribute]
public abstract virtual void add_Updated(Action value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Updated(Action value);
}
public interface JetBrains.Common.Timeline.Framework.Charts.IChartConfigurator {
    public bool HasPeaks { get; }
    public PlotCalculatorType CalculatorType { get; }
    public double ScreenLoadStep { get; }
    public abstract virtual double GetPeak(IEventLog log, TimelineStatistics statistics, byte level);
    public abstract virtual bool get_HasPeaks();
    public abstract virtual TimelineStatistics[] GetStatistics(IEventLog log);
    public abstract virtual PlotCalculatorType get_CalculatorType();
    public abstract virtual double get_ScreenLoadStep();
}
public class JetBrains.Common.Timeline.Framework.Charts.Model.ChartBlockData : object {
    private int myStartIndex;
    private int myLength;
    private ChartModelDataStorage myStorage;
    public int SeriesNum { get; }
    public ModelRange Range { get; }
    public int PointsNum { get; }
    public double MaxValue { get; }
    public ChartBlockData(ChartModelDataStorage storage, int startIndex, int length);
    public int get_SeriesNum();
    public ulong GetPoint(int index);
    public double GetValue(int index, int serie);
    public sealed virtual ModelRange get_Range();
    public int get_PointsNum();
    public double get_MaxValue();
    public ChartBlockData CopyForNewStorage(ChartModelDataStorage storage);
}
public class JetBrains.Common.Timeline.Framework.Charts.Model.ChartCalculator : object {
    private TimelineStatistics[] myStatistics;
    private TimelineStatistics[] myAllStatistics;
    private Accumulator[] myAccumulators;
    private Accumulator[] myBlockAccumulators;
    private Accumulator[] myHelperAccumulators;
    private UInt64[] myBlockValues;
    private Func`4<ulong, TimelineStatistics, ModelRange, double> myGetFinalValue;
    public ChartCalculator(PlotCalculatorType type, TimelineStatistics[] statistics, TimelineStatistics[] allStatistics);
    private void CalculateValues(IEnumeratorWithEnd`1<EventOrChunk> items, ulong minLength, Accumulator[] accumulators, UInt64& rightTick);
    private void CalculateEventValues(EventInfo eventItem, ChartModelDataStorage storage, int index);
    private ChartEventData CreateEvent(EventInfo eventItem, ChartModelDataStorage storage);
    private bool IsLongEvent(EventOrChunk event, ulong minLength);
    private void InitializeAccumulators();
    private void Aggregate(EventOrChunk i);
    private void DumpValues();
    [IteratorStateMachineAttribute("JetBrains.Common.Timeline.Framework.Charts.Model.ChartCalculator/<EnumerateBlock>d__15")]
private IEnumerable`1<EventOrChunk> EnumerateBlock(IEnumeratorWithEnd`1<EventOrChunk> baseEnumerator, ulong minLength, IExecutionController executionController);
    public void Calculate(IEnumerable`1<EventOrChunk> items, byte level, ChartModelData modelData, IExecutionController executionController);
    private ChartBlockData CreateBlock(IEnumerable`1<EventOrChunk> items, ulong minLength, ChartModelDataStorage storage);
}
public class JetBrains.Common.Timeline.Framework.Charts.Model.ChartEventData : EventData {
    private int myIndex;
    private ChartModelDataStorage myStorage;
    public ChartEventData(EventInfoShort info, int index, ChartModelDataStorage storage);
    public double GetValue(int serie);
    public ChartEventData CopyForNewStorage(ChartModelDataStorage storage);
}
public static class JetBrains.Common.Timeline.Framework.Charts.Model.ChartIntegratedValueProvider : object {
    public static IDataProvider`1<Double[]> Create(IDataProvider`1<ChartModelData> modelDataProvider, IViewport viewport);
    private static void Integrate(ModelRangeData`2<ChartEventData, ChartBlockData> range, double left, double right, Double[] result);
    private static void UpdateViewData(ChartModelData modelData, IViewport viewport, Double[]& viewData);
}
public class JetBrains.Common.Timeline.Framework.Charts.Model.ChartModelData : FlatModelData`2<ChartEventData, ChartBlockData> {
    [CompilerGeneratedAttribute]
private Int32[] <EventTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private Double[] <Peaks>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ArePeaksLocal>k__BackingField;
    public ChartModelDataStorage Storage;
    public Int32[] EventTypes { get; private set; }
    public Double[] Peaks { get; private set; }
    public bool ArePeaksLocal { get; private set; }
    public int SeriesNum { get; }
    [CompilerGeneratedAttribute]
public sealed virtual Int32[] get_EventTypes();
    [CompilerGeneratedAttribute]
private void set_EventTypes(Int32[] value);
    [CompilerGeneratedAttribute]
public sealed virtual Double[] get_Peaks();
    [CompilerGeneratedAttribute]
private void set_Peaks(Double[] value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_ArePeaksLocal();
    [CompilerGeneratedAttribute]
private void set_ArePeaksLocal(bool value);
    public int get_SeriesNum();
    public sealed virtual IChartModelDataPointer CreatePointer();
    public void Init(Int32[] eventTypes, Double[] peaks, bool peaksLocal);
    public double GetLocalMax();
    public void Normalize();
    public sealed virtual void CopyStateFrom(ChartModelData source);
}
public class JetBrains.Common.Timeline.Framework.Charts.Model.ChartModelDataStorage : object {
    public List`1<ulong> Points;
    public List`1[] Values;
    public int SeriesNum { get; }
    public int Count { get; }
    public ChartModelDataStorage(int seriesNum);
    public int get_SeriesNum();
    public int get_Count();
    public int AddOne();
    public void Clear();
}
public interface JetBrains.Common.Timeline.Framework.Charts.Model.IChartModelData {
    public Double[] Peaks { get; }
    public bool ArePeaksLocal { get; }
    public bool IsEmpty { get; }
    public Int32[] EventTypes { get; }
    public ModelRange Range { get; }
    public abstract virtual Double[] get_Peaks();
    public abstract virtual bool get_ArePeaksLocal();
    public abstract virtual IChartModelDataPointer CreatePointer();
    public abstract virtual bool get_IsEmpty();
    public abstract virtual Int32[] get_EventTypes();
    public abstract virtual ModelRange get_Range();
}
public enum JetBrains.Common.Timeline.Framework.Charts.Model.PlotCalculatorType : Enum {
    public int value__;
    public static PlotCalculatorType Density;
    public static PlotCalculatorType Point;
}
internal class JetBrains.Common.Timeline.Framework.Charts.RemoteChartData : ValueType {
    public ChartModelData ModelData;
    public double NoiseReduction;
    public IViewport Viewport;
}
[ExtensionAttribute]
public static class JetBrains.Common.Timeline.Framework.Charts.RemoteChartLoader : object {
    [ExtensionAttribute]
public static IRemotableReference`1<IEventLog> CreateRemotableReference(IEventLog log, IRemotablePair`1<ILogStorage> logStorage);
    public static IDataProvider`1<MultiSeriesPixelChartViewData> LoadChart(IRemoteCommunicator comm, IRemotableReference`1<IEventLog> log, IChartConfigurator configurator, bool normalize, IDataProvider`1<IViewport> viewport, IDataProvider`1<double> noiseReductionProvider, IRemotableReference`1<DataPipeLifetime> lifetime);
    private static IThreadSwitch`1<IInterpolatedMultiSeriesChartData> LoadRemoteChart(IRemoteCommunicator comm, IRemotableReference`1<IEventLog> log, IChartConfigurator configurator, bool normalize, IRemotableReference`1<DataPipeLifetime> lifetime, IRemotableReference`1<IDataProvider`1<ViewportData>> remoteViewportData, IRemotableReference`1<IDataProvider`1<double>> remoteNoiseReduction);
    private static IThreadSwitch`1<InterpolatedMultiSeriesChartData> LoadLocalChart(IEventLog log, IChartConfigurator configurator, bool normalize, IDataProvider`1<IViewport> viewport, IDataProvider`1<double> noiseReductionProvider, DataPipeLifetime lifetime);
}
public class JetBrains.Common.Timeline.Framework.Charts.ViewModel.ChartModelDataPointer : object {
    private int myRangeIndex;
    private int myPointIndex;
    private ChartModelData myData;
    private ulong myTick;
    private int mySeriesNum;
    private Double[] myValues;
    private bool myValuesAreValid;
    public ulong Tick { get; private set; }
    private int PointIndex { get; }
    public ModelRangeData`2<ChartEventData, ChartBlockData> RangeData { get; }
    public bool AtEnd { get; }
    private ulong LeftAlignedTick { get; }
    private ulong NextAlignedTick { get; }
    public ChartModelDataPointer(ChartModelData data);
    public sealed virtual void UpdateValues();
    public sealed virtual void GoTo(IChartModelDataPointer other);
    public sealed virtual bool GoTo(ulong tick);
    public sealed virtual ulong get_Tick();
    private void set_Tick(ulong value);
    private int get_PointIndex();
    public sealed virtual ModelRangeData`2<ChartEventData, ChartBlockData> get_RangeData();
    public sealed virtual bool get_AtEnd();
    private ulong get_LeftAlignedTick();
    private ulong get_NextAlignedTick();
    public sealed virtual void Increment();
    public sealed virtual void Integrate(ulong targetTick, Double[] output, int sign, Predicate`1<EventInfoShort> stopAtEvent);
}
[ExtensionAttribute]
public static class JetBrains.Common.Timeline.Framework.Charts.ViewModel.ChartModelDataPointerEx : object {
    [ExtensionAttribute]
public static void IntegratePlus(IChartModelDataPointer pointer, ulong targetTick, Double[] values);
    [ExtensionAttribute]
public static void IntegrateMinus(IChartModelDataPointer pointer, ulong targetTick, Double[] values);
}
[ExtensionAttribute]
public static class JetBrains.Common.Timeline.Framework.Charts.ViewModel.ChartModelToPointsDataProvider : object {
    [ExtensionAttribute]
public static IDataProvider`1<PointsChartViewData> ToPointsViewData(IDataProvider`1<ChartModelData> modelDataProvider, int serieIndex, int eventType);
    [IteratorStateMachineAttribute("JetBrains.Common.Timeline.Framework.Charts.ViewModel.ChartModelToPointsDataProvider/<EnumeratePoints>d__1")]
private static IEnumerable`1<Point> EnumeratePoints(IEnumerable`1<ModelRangeData`2<ChartEventData, ChartBlockData>> modelData, int serieIndex, int eventType);
}
public static class JetBrains.Common.Timeline.Framework.Charts.ViewModel.ChartTimeSplitter : object {
    private static double Average(Double[] inputArray, int startIndex, int size, bool cycle);
    private static IList`1<int> EnumCalculateErrors(IEnumerable`1<double> inputArray, int inputSize, double maxInput);
    private static int MakeEdgeHist(List`1<int> inputList);
    private static List`1<int> ClusterValues(List`1<KeyValuePair`2<int, double>> inputList, int edge);
    private static IEnumerable`1<int> ProcessCluster(List`1<KeyValuePair`2<int, double>> cluster, double edge);
    public static IEnumerable`1<int> GetSplitters(IEnumerable`1<double> inputList, int inputSize);
}
public interface JetBrains.Common.Timeline.Framework.Charts.ViewModel.IChartModelDataPointer {
    public ulong Tick { get; }
    public bool AtEnd { get; }
    public ModelRangeData`2<ChartEventData, ChartBlockData> RangeData { get; }
    public abstract virtual void UpdateValues();
    public abstract virtual void GoTo(IChartModelDataPointer other);
    public abstract virtual bool GoTo(ulong tick);
    public abstract virtual ulong get_Tick();
    public abstract virtual bool get_AtEnd();
    public abstract virtual ModelRangeData`2<ChartEventData, ChartBlockData> get_RangeData();
    public abstract virtual void Increment();
    public abstract virtual void Integrate(ulong targetTick, Double[] output, int sign, Predicate`1<EventInfoShort> stopAtEvent);
}
public class JetBrains.Common.Timeline.Framework.Charts.ViewModel.LineChartViewModel : object {
    [CompilerGeneratedAttribute]
private IDataProvider`1<PointsChartViewData> <ViewDataProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EventType>k__BackingField;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    public IDataProvider`1<PointsChartViewData> ViewDataProvider { get; }
    public int EventType { get; }
    public LineChartViewModel(IDataProvider`1<PointsChartViewData> viewDataProvider, int eventType);
    [CompilerGeneratedAttribute]
public sealed virtual IDataProvider`1<PointsChartViewData> get_ViewDataProvider();
    [CompilerGeneratedAttribute]
public sealed virtual int get_EventType();
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
}
[ExtensionAttribute]
public static class JetBrains.Common.Timeline.Framework.Charts.ViewModel.MultiSeriesPixelCharts : object {
    public static IDataProvider`1<MultiSeriesPixelChartViewData> Interpolate(DataPipeLifetime lifetime, IDataProvider`1<ChartModelData> modelDataProvider, IViewport viewport, IDataProvider`1<double> noiseReductionProvider);
    [ExtensionAttribute]
internal static IDataProvider`1<IViewport> ExpandVisibleRangeAndKeepResolution(IDataProvider`1<IViewport> viewportProvider, double factor);
    public static IThreadSwitch`1<InterpolatedMultiSeriesChartData> InterpolateChart(DataPipeLifetime lifetime, IDataProvider`1<ChartModelData> modelDataProvider, IDataProvider`1<double> noiseReductionProvider, IDataProvider`1<IViewport> viewportProvider);
    [ExtensionAttribute]
public static IDataProvider`1<MultiSeriesPixelChartViewData> TransformWithViewport(IDataProvider`1<IInterpolatedMultiSeriesChartData> data, IDataProvider`1<IViewport> viewport);
    private static void TransformViewData(IInterpolatedMultiSeriesChartData data, IViewport viewport, MultiSeriesPixelChartViewData result);
}
public class JetBrains.Common.Timeline.Framework.Charts.ViewModel.MultiSeriesPixelChartViewModel : object {
    private IDataProvider`1<MultiSeriesPixelChartViewData> myPixelDataProvider;
    private static int DefaultChartHeight;
    private double myScreenHeight;
    private IDataController`1<double> myNoiseReduction;
    private static double NoiseReductionPixelSize;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    public IDataProvider`1<double> NoiseReductionProvider { get; }
    public double ScreenHeight { get; public set; }
    public IDataProvider`1<MultiSeriesPixelChartViewData> ViewDataProvider { get; }
    public MultiSeriesPixelChartViewModel(IDataProvider`1<MultiSeriesPixelChartViewData> pixelDataProvider);
    public IDataProvider`1<double> get_NoiseReductionProvider();
    public sealed virtual double get_ScreenHeight();
    public sealed virtual void set_ScreenHeight(double value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    public sealed virtual IDataProvider`1<MultiSeriesPixelChartViewData> get_ViewDataProvider();
}
public static class JetBrains.Common.Timeline.Framework.Charts.ViewModel.PixelChartDataProvider : object {
    public static IDataProvider`1<PixelChartData> Create(IDataProvider`1<MultiSeriesPixelChartViewData> provider, int index);
}
public class JetBrains.Common.Timeline.Framework.Charts.ViewModel.PixelChartSelector : TimelineElementSelectorBase`2<PixelChartData, WormSelectionHost> {
    private SingleChartTypes myChartType;
    public PixelChartSelector(IDataProvider`1<PixelChartData> viewDataProvider, SingleChartTypes chartType);
    public virtual void AutoSelect(Point screenPoint, WormSelectionHost selection);
}
public static class JetBrains.Common.Timeline.Framework.Charts.ViewModel.PixelChartViewDataCalculator : object {
    private static double IntegrationWindowScreenSize;
    private static int PreserveLengthSize;
    private static int AdjustBlockToModelPositionPixels;
    private static void Clear(IInterpolatedMultiSeriesChartData data);
    private static void Clear(IInterpolatedMultiSeriesChartData data, int left, int rightExcluding, int seriesNum);
    private static int DataToScreenShiftInvariantInt(IViewport viewport, double dataX);
    private static int DataLengthToScreenInt(IViewport viewport, double dataLength);
    public static void UpdateViewData(IInterpolatedMultiSeriesChartData viewData, IViewport viewport, IChartModelData modelData, double minValue, IExecutionController controller);
    private static int CalculateScreenRight(int screenLeft, IViewport viewport, ulong dataRight, ulong dataLeft);
    private static void SetPeaks(IChartModelData modelData, IInterpolatedMultiSeriesChartData viewData, int seriesNum);
    private static void Clear(Double[] values);
    private static void SetNormalizedValues(Double[] aggregatedValues, int x, ulong dataWidth, double valueThreshold, IInterpolatedMultiSeriesChartData viewData);
    private static void DrawBlock(IChartModelDataPointer leftPointer, IChartModelDataPointer rightPointer, ulong rightTick, int left, int right, IInterpolatedMultiSeriesChartData viewData, double minValue, Double[] valuesBuffer, double leftModelFromScreen, double unitsPerPixel);
    private static void DrawBlockPixel(int screenX, double modelX, IChartModelDataPointer leftPointer, IChartModelDataPointer rightPointer, ulong leftBlockTick, ulong rightBlockTick, int screenRightBlockBorder, IInterpolatedMultiSeriesChartData viewData, double valueThreshold, Double[] valuesBuffer, double unitsPerPixel, double dataStep);
    private static void DrawEvent(ChartEventData eventData, int left, int right, int seriesNum, IInterpolatedMultiSeriesChartData viewData);
}
public class JetBrains.Common.Timeline.Framework.Charts.ViewModel.PixelChartViewModel : object {
    private IDataProvider`1<PixelChartData> myViewDataProvider;
    [CompilerGeneratedAttribute]
private SingleChartTypes <ChartType>k__BackingField;
    [CompilerGeneratedAttribute]
private double <ScaleFactor>k__BackingField;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    public SingleChartTypes ChartType { get; }
    public double ScaleFactor { get; public set; }
    public IDataProvider`1<PixelChartData> ViewDataProvider { get; }
    public PixelChartViewModel(IDataProvider`1<PixelChartData> viewDataProvider, SingleChartTypes chartType);
    [CompilerGeneratedAttribute]
public sealed virtual SingleChartTypes get_ChartType();
    [CompilerGeneratedAttribute]
public sealed virtual double get_ScaleFactor();
    [CompilerGeneratedAttribute]
public void set_ScaleFactor(double value);
    public sealed virtual IDataProvider`1<PixelChartData> get_ViewDataProvider();
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
}
public class JetBrains.Common.Timeline.Framework.Charts.ViewModel.PointsChartViewModel : object {
    [CompilerGeneratedAttribute]
private IDataProvider`1<PointsChartViewData> <ViewDataProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DrawZeroValue>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EventType>k__BackingField;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    public IDataProvider`1<PointsChartViewData> ViewDataProvider { get; }
    public bool DrawZeroValue { get; public set; }
    public int EventType { get; }
    public PointsChartViewModel(IDataProvider`1<PointsChartViewData> dataProvider, int eventType);
    [CompilerGeneratedAttribute]
public sealed virtual IDataProvider`1<PointsChartViewData> get_ViewDataProvider();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_DrawZeroValue();
    [CompilerGeneratedAttribute]
public sealed virtual void set_DrawZeroValue(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_EventType();
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
}
public class JetBrains.Common.Timeline.Framework.CurrentTickHolder : object {
    private ulong myStartTick;
    private DateTime myStartTime;
    private ITickTimeConverter myTickTimeConverter;
    public ulong Tick { get; }
    public CurrentTickHolder(ITickTimeConverter tickTimeConverter, ulong startTick);
    public CurrentTickHolder(ITickTimeConverter tickTimeConverter, DateTime startTime, ulong startTick);
    public sealed virtual ulong get_Tick();
}
[ExtensionAttribute]
public static class JetBrains.Common.Timeline.Framework.DataEx.DataProviderEx : object {
    [ExtensionAttribute]
public static IDataProvider`1<HashSet`1<T>> ToHashSet(IDataProvider`1<IEnumerable`1<T>> provider);
    [ExtensionAttribute]
public static IDataProvider`1<IReadOnlyCollection`1<T>> Readonly(IDataProvider`1<ICollection`1<T>> provider);
    [ExtensionAttribute]
public static IThreadSwitch`1<JetHashSet`1<T>> SwitchRecycleToHashSet(IDataProvider`1<IEnumerable`1<T>> provider);
    [ExtensionAttribute]
public static IDataProvider`1<Pair`2<TA, TB>> Combine(IDataProvider`1<TA> self, ICollectionEvents`1<TB> collection, Predicate`1<TB> itemSelector);
    [ExtensionAttribute]
public static IDataProvider`1<T> ToNewItemProvider(ICollectionEvents`1<T> collection, Predicate`1<T> itemSelector);
}
[ExtensionAttribute]
public static class JetBrains.Common.Timeline.Framework.DataEx.ElementsExtensions : object {
    private static double MarkerLoadScreenStep;
    private static double ChartLoadScreenStep;
    private static double ChartLoadBufferFactor;
    [ExtensionAttribute]
public static IEnumerable`1<ScreenRangeInt> GetEvents(IEnumerable`1<ModelRangeData`2<TEvent, TBlock>> data, IViewport viewport, int minEventLength, Func`2<int, bool> eventTypeFilter);
    [ExtensionAttribute]
public static IEnumerable`1<ModelRangeData`2<TEvent, TBlock>> ConvertSmallEventsIntoBlocks(IEnumerable`1<ModelRangeData`2<TEvent, TBlock>> items, ulong minLength, Func`2<TEvent, TBlock> eventConverter);
    [IteratorStateMachineAttribute("JetBrains.Common.Timeline.Framework.DataEx.ElementsExtensions/<MergeSmallBlocks>d__2`2")]
[ExtensionAttribute]
public static IEnumerable`1<ModelRangeData`2<TEvent, TBlock>> MergeSmallBlocks(IEnumerable`1<ModelRangeData`2<TEvent, TBlock>> items, ulong maxBlockLength, Func`3<TBlock, TBlock, TBlock> blockMerger, ulong minEventLength, Func`3<TBlock, TEvent, TBlock> blockEventMerger);
    [ExtensionAttribute]
public static IDataProvider`1<IEnumerable`1<ScreenRangeInt>> GetEvents(IDataProvider`1<ChartModelData> data, IDataProvider`1<IViewport> viewport, int minEventLength, Func`2<int, bool> eventTypeFilter);
    [ExtensionAttribute]
public static IDataProvider`1<IEnumerable`1<ScreenRangeInt>> GetEvents(IDataProvider`1<IEnumerable`1<ModelRangeData`2<EventData, MarkersBlockData>>> data, IDataProvider`1<IViewport> viewport, int minEventLength, Func`2<int, bool> eventTypeFilter);
    [ExtensionAttribute]
public static IDataProvider`1<IEnumerable`1<MarkerScreenRange>> MarkersToScreen(IDataProvider`1<IEnumerable`1<ModelRangeData`2<EventData, MarkersBlockData>>> data, IDataProvider`1<IViewport> viewport);
    [ExtensionAttribute]
public static IDataProvider`1<IEnumerable`1<ScreenRangeInt>> RangesToScreen(IDataProvider`1<IEnumerable`1<ModelRange>> data, IDataProvider`1<IViewport> viewport);
    [ExtensionAttribute]
public static IDataProvider`1<IEnumerable`1<MarkerScreenRange>> ChartMarkersToScreen(IDataProvider`1<IEnumerable`1<ModelRangeData`2<EventData, MarkersBlockData>>> data, IDataProvider`1<IViewport> viewport);
    [ExtensionAttribute]
private static IEnumerable`1<MarkerScreenRange> ToScreen(IEnumerable`1<ModelRangeData`2<EventData, MarkersBlockData>> data, IViewport viewport);
    [ExtensionAttribute]
private static IEnumerable`1<ScreenRangeInt> ToScreen(IEnumerable`1<ModelRange> data, IViewport viewport);
    [ExtensionAttribute]
private static IDataProvider`1<BoundedDataRequest> ToRequest(IDataProvider`1<RangeAndResolution> source, double screenLoadStep);
    [ExtensionAttribute]
private static BoundedDataRequest ExpandRequest(BoundedDataRequest boundedRequest, double factor);
    [ExtensionAttribute]
private static IAsyncDataProvider`1<BoundedDataRequest> Buffer(IDataProvider`1<BoundedDataRequest> source, DataPipeLifetime lifetime, double factor);
    [ExtensionAttribute]
private static IAsyncDataProvider`1<T> LoadAsync(IDataProvider`1<RangeAndResolution> source, DataPipeLifetime lifetime, double loadStep, double bufferFactor, Func`3<BoundedDataRequest, IExecutionController, T> loader);
    [ExtensionAttribute]
public static IAsyncDataProvider`1<IEnumerable`1<ModelRangeData`2<EventData, MarkersBlockData>>> LoadMarkers(IDataProvider`1<RangeAndResolution> resolutionProvider, DataPipeLifetime lifetime, IEventLog log, int eventType);
    [IteratorStateMachineAttribute("JetBrains.Common.Timeline.Framework.DataEx.ElementsExtensions/<CropEvents>d__17")]
[ExtensionAttribute]
private static IEnumerable`1<ModelRangeData`2<EventData, MarkersBlockData>> CropEvents(IEnumerable`1<ModelRangeData`2<EventData, MarkersBlockData>> data, ModelRange range);
    [ExtensionAttribute]
private static IAsyncDataProvider`1<EventsAndRequest> LoadChartRanges(IDataProvider`1<RangeAndResolution> resolutionProvider, DataPipeLifetime lifetime, IEventLog log);
    [ExtensionAttribute]
public static IThreadSwitch`1<ChartModelData> LoadChartAndSync(IDataProvider`1<RangeAndResolution> resolutionProvider, DataPipeLifetime lifetime, IEventLog log, IChartConfigurator configurator, bool normalize);
}
public static class JetBrains.Common.Timeline.Framework.DataEx.ModelToScreenIntervalsProvider : object {
    public static DataPipe`2<IEnumerable`1<ModelRange>, IEnumerable`1<ScreenRangeInt>> Create(IViewport viewport);
}
public class JetBrains.Common.Timeline.Framework.DataEx.RangeAndResolution : ValueType {
    public ModelRange Range;
    public double TicksPerPixel;
    public ModelRange TotalRange;
    public RangeAndResolution(ModelRange range, double ticksPerPixel, ModelRange totalRange);
}
[ExtensionAttribute]
public static class JetBrains.Common.Timeline.Framework.DataEx.ViewportProviderEx : object {
    [ExtensionAttribute]
public static IDataProvider`1<RangeAndResolution> ToRangeAndResolutionProvider(IDataProvider`1<IViewport> viewportProvider);
}
public class JetBrains.Common.Timeline.Framework.DelegatedHitTestProvider : object {
    private Func`2<Point, bool> myHitTest;
    public DelegatedHitTestProvider(Func`2<Point, bool> hitTest);
    public sealed virtual bool HitTest(Point p);
}
public class JetBrains.Common.Timeline.Framework.EventData : object {
    public EventInfoShort Info;
    public EventData(EventInfoShort info);
}
public class JetBrains.Common.Timeline.Framework.EventLogs.DataRequest : ValueType {
    public ModelRange Range;
    public byte Level;
    public DataRequest(ModelRange range, byte level);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [PureAttribute]
public bool Contains(DataRequest request);
    public sealed virtual bool Equals(DataRequest other);
}
[ExtensionAttribute]
public static class JetBrains.Common.Timeline.Framework.EventLogs.Extensions : object {
    [ExtensionAttribute]
public static IEnumerable`1<EventOrChunk> GetItems(IEventTreeExplorer explorer, DataRequest request);
    [ExtensionAttribute]
public static IEnumerable`1<EventOrChunk> GetItemsForceFinishAtChunk(IEventTreeExplorer explorer, DataRequest request);
}
[ExtensionAttribute]
public static class JetBrains.Common.Timeline.Framework.Extensions : object {
    [ExtensionAttribute]
public static T CurrentOrDefault(IEnumeratorWithEnd`1<T> src);
    [ExtensionAttribute]
public static double ToTicks(ITickTimeConverter converter, TimeSpan interval);
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Common.Timeline.Framework.FlatModelData`2 : object {
    private IList`1<ModelRangeData`2<TEvent, TBlock>> myRanges;
    public ulong LeftTick { get; }
    public ulong RightTick { get; }
    public ModelRange Range { get; }
    public bool IsEmpty { get; }
    public IEnumerable`1<TBlock> Blocks { get; }
    public int Count { get; }
    public ModelRangeData`2<TEvent, TBlock> Item { get; public set; }
    public ulong get_LeftTick();
    public ulong get_RightTick();
    public sealed virtual ModelRange get_Range();
    public sealed virtual bool get_IsEmpty();
    public IEnumerable`1<TBlock> get_Blocks();
    public void Clear();
    public void Add(ModelRangeData`2<TEvent, TBlock> rangeData);
    public void Add(TBlock data);
    public void Add(TEvent data);
    public sealed virtual IEnumerator`1<ModelRangeData`2<TEvent, TBlock>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual int get_Count();
    public sealed virtual ModelRangeData`2<TEvent, TBlock> get_Item(int index);
    public void set_Item(int index, ModelRangeData`2<TEvent, TBlock> value);
}
public interface JetBrains.Common.Timeline.Framework.IInMemoryChartStorage {
    public IList`1<int> EventTypes { get; }
    public int Count { get; }
    public abstract virtual IList`1<int> get_EventTypes();
    public abstract virtual int get_Count();
    public abstract virtual void Write(RealtimeDataEntry entry);
    public abstract virtual void Read(MultiChartData destination, IList`1<int> eventTypes, ChartRange range, int pointsToRead);
    public abstract virtual double GetXValue(int index);
    public abstract virtual double MaxYSumValue(IList`1<int> eventTypes);
}
public interface JetBrains.Common.Timeline.Framework.IMouseTracker {
    public IDataProvider`1<bool> IsMouseDown { get; }
    public IDataProvider`1<bool> IsMouseDownDelayed { get; }
    public IDataProvider`1<Nullable`1<Point>> PositionOver { get; }
    public IDataProvider`1<Point> Position { get; }
    public IDataProvider`1<bool> IsMouseOver { get; }
    public bool IsMouseDownValue { get; }
    public Nullable`1<Point> PositionValue { get; }
    public abstract virtual IDataProvider`1<bool> get_IsMouseDown();
    public abstract virtual IDataProvider`1<bool> get_IsMouseDownDelayed();
    public abstract virtual IDataProvider`1<Nullable`1<Point>> get_PositionOver();
    public abstract virtual IDataProvider`1<Point> get_Position();
    public abstract virtual IDataProvider`1<bool> get_IsMouseOver();
    public abstract virtual bool get_IsMouseDownValue();
    public abstract virtual Nullable`1<Point> get_PositionValue();
}
public interface JetBrains.Common.Timeline.Framework.IRangeData {
    public ModelRange Range { get; }
    public abstract virtual ModelRange get_Range();
}
public interface JetBrains.Common.Timeline.Framework.IRangeDataCalculator`2 {
    public abstract virtual IEnumerable`1<ModelRangeData`2<TEvent, TBlock>> Calculate(IEnumerable`1<EventOrChunk> items, ulong minLength, Predicate`1<EventOrChunk> filter);
}
public class JetBrains.Common.Timeline.Framework.Markers.MarkersBlockData : object {
    public int Count;
    public ulong TotalLength;
    [CompilerGeneratedAttribute]
private ModelRange <Range>k__BackingField;
    public ModelRange Range { get; public set; }
    public MarkersBlockData(ModelRange range, int count, ulong totalLength);
    [CompilerGeneratedAttribute]
public sealed virtual ModelRange get_Range();
    [CompilerGeneratedAttribute]
public void set_Range(ModelRange value);
}
public class JetBrains.Common.Timeline.Framework.Markers.MarkersCalculator : RangeDataCalculatorBase`2<EventData, MarkersBlockData> {
    [NotNullAttribute]
private TimelineStatistics myCounterStatistics;
    [CanBeNullAttribute]
private TimelineStatistics myLengthStatistics;
    public MarkersCalculator(TimelineStatistics counterStatistics, TimelineStatistics lengthStatistics);
    protected virtual EventData CreateEvent(EventInfo eventItem);
    protected virtual MarkersBlockData CreateBlock(IEnumerable`1<EventOrChunk> items, ulong leftTick);
    protected virtual MarkersBlockData MergeBlocks(MarkersBlockData src1, MarkersBlockData src2);
}
public class JetBrains.Common.Timeline.Framework.Markers.MarkersModelData : FlatModelData`2<EventData, MarkersBlockData> {
}
[ExtensionAttribute]
public static class JetBrains.Common.Timeline.Framework.Markers.MarkersViewDataCalculator : object {
    private static int MinScreenLength;
    [ExtensionAttribute]
private static IEnumerable`1<DesiredMarkerScreenData> GetActualScreenPositions(IEnumerable`1<ModelRangeData`2<EventData, MarkersBlockData>> modelData, IViewport viewport);
    [ExtensionAttribute]
private static void MergeInto(DesiredMarkerScreenData range, DesiredMarkerScreenData& target);
    private static int MaxScreenLength(DesiredMarkerScreenData data);
    private static int GetMaxBlockLength(int count);
    [IteratorStateMachineAttribute("JetBrains.Common.Timeline.Framework.Markers.MarkersViewDataCalculator/<MergeNeighbourBlocks>d__6")]
[ExtensionAttribute]
private static IEnumerable`1<DesiredMarkerScreenData> MergeNeighbourBlocks(IEnumerable`1<DesiredMarkerScreenData> ranges);
    [IteratorStateMachineAttribute("JetBrains.Common.Timeline.Framework.Markers.MarkersViewDataCalculator/<SetDesiredRanges>d__7")]
[ExtensionAttribute]
private static IEnumerable`1<DesiredMarkerScreenData> SetDesiredRanges(IEnumerable`1<DesiredMarkerScreenData> data);
    [IteratorStateMachineAttribute("JetBrains.Common.Timeline.Framework.Markers.MarkersViewDataCalculator/<SetSuggestedFromDesired>d__8")]
[ExtensionAttribute]
private static IEnumerable`1<DesiredMarkerScreenData> SetSuggestedFromDesired(IEnumerable`1<DesiredMarkerScreenData> data);
    private static ScreenRange GetDesiredScreenRange(DesiredMarkerScreenData range);
    [IteratorStateMachineAttribute("JetBrains.Common.Timeline.Framework.Markers.MarkersViewDataCalculator/<ShrinkToDesiredRanges>d__10")]
[ExtensionAttribute]
private static IEnumerable`1<DesiredMarkerScreenData> ShrinkToDesiredRanges(IEnumerable`1<DesiredMarkerScreenData> data);
    [IteratorStateMachineAttribute("JetBrains.Common.Timeline.Framework.Markers.MarkersViewDataCalculator/<ExpandToDesiredRanges>d__11")]
[ExtensionAttribute]
private static IEnumerable`1<DesiredMarkerScreenData> ExpandToDesiredRanges(IEnumerable`1<DesiredMarkerScreenData> data);
    [IteratorStateMachineAttribute("JetBrains.Common.Timeline.Framework.Markers.MarkersViewDataCalculator/<MergeOverlappingRanges>d__12")]
[ExtensionAttribute]
private static IEnumerable`1<DesiredMarkerScreenData> MergeOverlappingRanges(IEnumerable`1<DesiredMarkerScreenData> data);
    [ExtensionAttribute]
private static IEnumerable`1<MarkerScreenRange> ToMarkerScreenRanges(IEnumerable`1<DesiredMarkerScreenData> data, IViewport viewport);
    [IteratorStateMachineAttribute("JetBrains.Common.Timeline.Framework.Markers.MarkersViewDataCalculator/<Validate>d__14")]
[ExtensionAttribute]
private static IEnumerable`1<MarkerScreenRange> Validate(IEnumerable`1<MarkerScreenRange> ranges);
    public static IEnumerable`1<MarkerScreenRange> Update(IEnumerable`1<ModelRangeData`2<EventData, MarkersBlockData>> modelData, IViewport viewport);
    [IteratorStateMachineAttribute("JetBrains.Common.Timeline.Framework.Markers.MarkersViewDataCalculator/<AdjustMarkerBorders>d__16")]
public static IEnumerable`1<MarkerScreenRange> AdjustMarkerBorders(IEnumerable`1<MarkerScreenRange> ranges);
    [IteratorStateMachineAttribute("JetBrains.Common.Timeline.Framework.Markers.MarkersViewDataCalculator/<AdjustChartMarkerBorders>d__17")]
public static IEnumerable`1<MarkerScreenRange> AdjustChartMarkerBorders(IEnumerable`1<MarkerScreenRange> ranges);
}
public class JetBrains.Common.Timeline.Framework.Markers.MarkersViewModel : object {
    private IDataProvider`1<IEnumerable`1<MarkerScreenRange>> myViewDataProvider;
    [CompilerGeneratedAttribute]
private MarkerEventDisplayMode <EventDisplayMode>k__BackingField;
    [CompilerGeneratedAttribute]
private MarkerGroupDisplayMode <GroupDisplayMode>k__BackingField;
    [CompilerGeneratedAttribute]
private EventTypeWithModifier <EventType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AddShadow>k__BackingField;
    [CompilerGeneratedAttribute]
private int <HitTestMargin>k__BackingField;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    public MarkerEventDisplayMode EventDisplayMode { get; public set; }
    public MarkerGroupDisplayMode GroupDisplayMode { get; public set; }
    public EventTypeWithModifier EventType { get; public set; }
    public bool AddShadow { get; public set; }
    public int HitTestMargin { get; public set; }
    public IDataProvider`1<IEnumerable`1<MarkerScreenRange>> ViewDataProvider { get; }
    public MarkersViewModel(IDataProvider`1<IEnumerable`1<MarkerScreenRange>> viewDataProvider);
    [CompilerGeneratedAttribute]
public sealed virtual MarkerEventDisplayMode get_EventDisplayMode();
    [CompilerGeneratedAttribute]
public void set_EventDisplayMode(MarkerEventDisplayMode value);
    [CompilerGeneratedAttribute]
public sealed virtual MarkerGroupDisplayMode get_GroupDisplayMode();
    [CompilerGeneratedAttribute]
public void set_GroupDisplayMode(MarkerGroupDisplayMode value);
    [CompilerGeneratedAttribute]
public sealed virtual EventTypeWithModifier get_EventType();
    [CompilerGeneratedAttribute]
public void set_EventType(EventTypeWithModifier value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_AddShadow();
    [CompilerGeneratedAttribute]
public void set_AddShadow(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_HitTestMargin();
    [CompilerGeneratedAttribute]
public void set_HitTestMargin(int value);
    public sealed virtual IDataProvider`1<IEnumerable`1<MarkerScreenRange>> get_ViewDataProvider();
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
}
public class JetBrains.Common.Timeline.Framework.ModelRangeData`2 : ValueType {
    public TEvent Event;
    public TBlock Block;
    public ModelRange Range { get; }
    public bool IsBlock { get; }
    public bool IsEvent { get; }
    public ModelRangeData`2(TEvent event);
    public ModelRangeData`2(TBlock block);
    public ModelRange get_Range();
    public bool get_IsBlock();
    public bool get_IsEvent();
}
public class JetBrains.Common.Timeline.Framework.MouseTracker : object {
    private static TimeSpan ourDelayForSwitchToDraggingController;
    [CompilerGeneratedAttribute]
private Action`1<Point> Click;
    private IDataController`1<bool> myIsMouseDown;
    [CompilerGeneratedAttribute]
private IDataProvider`1<bool> <IsMouseDownDelayed>k__BackingField;
    private IDataController`1<Point> myPoint;
    private IDataController`1<bool> myIsMouseOver;
    private IDataProvider`1<Nullable`1<Point>> myPositionOver;
    public IDataProvider`1<bool> IsMouseDown { get; }
    public IDataProvider`1<bool> IsMouseDownDelayed { get; }
    public IDataProvider`1<Nullable`1<Point>> PositionOver { get; }
    public IDataProvider`1<Point> Position { get; }
    public bool IsMouseDownValue { get; }
    public Nullable`1<Point> PositionValue { get; }
    public IDataProvider`1<bool> IsMouseOver { get; }
    private static MouseTracker();
    [CompilerGeneratedAttribute]
public void add_Click(Action`1<Point> value);
    [CompilerGeneratedAttribute]
public void remove_Click(Action`1<Point> value);
    public sealed virtual IDataProvider`1<bool> get_IsMouseDown();
    [CompilerGeneratedAttribute]
public sealed virtual IDataProvider`1<bool> get_IsMouseDownDelayed();
    public sealed virtual IDataProvider`1<Nullable`1<Point>> get_PositionOver();
    public sealed virtual IDataProvider`1<Point> get_Position();
    public sealed virtual bool get_IsMouseDownValue();
    public sealed virtual Nullable`1<Point> get_PositionValue();
    public sealed virtual void MouseMove(Point screenPoint);
    public sealed virtual void MouseClick();
    public sealed virtual void MouseUp();
    private sealed virtual override void JetBrains.Common.Timeline.Framework.Interface.IMouseController.MouseDown();
    public sealed virtual void MouseLeave();
    public sealed virtual IDataProvider`1<bool> get_IsMouseOver();
}
public abstract class JetBrains.Common.Timeline.Framework.RangeDataCalculatorBase`2 : object {
    protected abstract virtual TEvent CreateEvent(EventInfo eventItem);
    protected abstract virtual TBlock CreateBlock(IEnumerable`1<EventOrChunk> items, ulong leftTick);
    private bool IsLongEvent(EventOrChunk event, ulong minLength);
    [IteratorStateMachineAttribute("JetBrains.Common.Timeline.Framework.RangeDataCalculatorBase`2/<EnumerateBlock>d__3")]
private IEnumerable`1<EventOrChunk> EnumerateBlock(IEnumeratorWithEnd`1<EventOrChunk> baseEnumerator, ulong minLength, Predicate`1<EventOrChunk> filter);
    [IteratorStateMachineAttribute("JetBrains.Common.Timeline.Framework.RangeDataCalculatorBase`2/<MergeBlocks>d__4")]
private IEnumerable`1<ModelRangeData`2<TEvent, TBlock>> MergeBlocks(IEnumerable`1<ModelRangeData`2<TEvent, TBlock>> items, ulong minLength);
    protected abstract virtual TBlock MergeBlocks(TBlock src1, TBlock src2);
    public sealed virtual IEnumerable`1<ModelRangeData`2<TEvent, TBlock>> Calculate(IEnumerable`1<EventOrChunk> items, ulong minLength, Predicate`1<EventOrChunk> filter);
    [IteratorStateMachineAttribute("JetBrains.Common.Timeline.Framework.RangeDataCalculatorBase`2/<GetLongEventsOrBlocks>d__7")]
private IEnumerable`1<ModelRangeData`2<TEvent, TBlock>> GetLongEventsOrBlocks(IEnumerable`1<EventOrChunk> items, ulong minLength, Predicate`1<EventOrChunk> filter);
}
public class JetBrains.Common.Timeline.Framework.Realtime.AllValuesInMemoryChartStorage : InMemoryChartStorage {
    public AllValuesInMemoryChartStorage(IList`1<int> eventTypes);
    public AllValuesInMemoryChartStorage(MultiChartData multiChartData);
    private static IList`1<double> CreateXValues();
    private static IList`1[] CreateYValues(IList`1<int> eventTypes);
}
public class JetBrains.Common.Timeline.Framework.Realtime.BadChartFormatException : ApplicationException {
    public BadChartFormatException(string message);
}
public static class JetBrains.Common.Timeline.Framework.Realtime.ChartPointsViewDataProvider : object {
    public static IDataProvider`1<PointsChartViewData> Create(IDataProvider`1<IList`1<Point>> pointsProvider);
}
public class JetBrains.Common.Timeline.Framework.Realtime.ChartRangeDataProvider : object {
    private MultiChartData myData;
    private IInMemoryChartStorage myDataStorage;
    private IList`1<int> myEventTypes;
    private int myPointsToProvide;
    [CompilerGeneratedAttribute]
private IDataProvider`1<MultiChartData> <Provider>k__BackingField;
    public IDataProvider`1<MultiChartData> Provider { get; }
    public ChartRangeDataProvider(IInMemoryChartStorage dataStorage, IDataProvider`1<ChartRange> rangeProvider, IList`1<int> eventTypes, int pointsToProvide);
    [CompilerGeneratedAttribute]
public IDataProvider`1<MultiChartData> get_Provider();
    private MultiChartData OnViewportUpdated(ChartRange chartRange);
    private void ExtrapolateLastPoint(MultiChartData data, ChartRange range);
}
[UsedImplicitlyAttribute]
public class JetBrains.Common.Timeline.Framework.Realtime.ChartRangeProvider : object {
    private IInMemoryChartStorage myStorage;
    public ChartRange AvailableRange { get; }
    public ChartRangeProvider(IInMemoryChartStorage storage);
    public sealed virtual ChartRange get_AvailableRange();
}
[UsedImplicitlyAttribute]
public class JetBrains.Common.Timeline.Framework.Realtime.DataGenerationViewportFactory : object {
    private IChartRangeProvider myChartRangeProvider;
    private ITickProvider myTickProvider;
    private ITickTimeConverter myTickTimeConverter;
    private double myViewportMinTicksPerPixel;
    public DataGenerationViewportFactory(ITickProvider tickProvider, ITickTimeConverter tickTimeConverter, IChartRangeProvider chartRangeProvider, double viewportMinTicksPerPixel);
    public sealed virtual IViewport CreateViewportAlignedToRight(Lifetime lifetime, TimeSpan visibleRange);
    public sealed virtual IViewport CreateViewport(Lifetime lifetime);
    public sealed virtual IViewport CreateViewport(Lifetime lifetime, ulong startTick);
    private RealtimeViewportAnimator CreateAnimator(Lifetime lifetime, ulong startTick);
}
public static class JetBrains.Common.Timeline.Framework.Realtime.DataModel.RealtimePathConstants : object {
    public static string Chart;
    public static string Snapshots;
}
[UsedImplicitlyAttribute]
public class JetBrains.Common.Timeline.Framework.Realtime.DataReadingViewportFactory : object {
    private IInMemoryChartStorage myStorage;
    private double myViewportMinTicksPerPixel;
    public DataReadingViewportFactory(IInMemoryChartStorage storage, double viewportMinTicksPerPixel);
    public sealed virtual IViewport CreateViewportAlignedToRight(Lifetime lifetime, TimeSpan visibleRange);
    public sealed virtual IViewport CreateViewport(Lifetime lifetime);
    public sealed virtual IViewport CreateViewport(Lifetime lifetime, ulong startTick);
    private ModelRangeDouble CreateAllDataScreenRange(ulong startTick);
}
public class JetBrains.Common.Timeline.Framework.Realtime.DiskStorageChartReader : object {
    private BinaryReader myBinaryReader;
    private static int HeaderSize;
    private static int OptionalSize;
    public DiskStorageChartReader(BinaryReader binaryReader);
    public StorableChartData Read();
    private static int ExpectedFileSizeInBytes(int dimensionsCount, int valuesCount);
}
public abstract class JetBrains.Common.Timeline.Framework.Realtime.InMemoryChartStorage : object {
    private IList`1<int> myEventTypes;
    private object myLock;
    private IList`1<double> myXValues;
    private IList`1[] myYValues;
    public IList`1<int> EventTypes { get; }
    public int Count { get; }
    protected InMemoryChartStorage(IList`1<int> eventTypes, IList`1<double> xValues, IList`1[] yValues);
    protected InMemoryChartStorage(MultiChartData multiChartData);
    public sealed virtual IList`1<int> get_EventTypes();
    public sealed virtual int get_Count();
    public sealed virtual void Write(RealtimeDataEntry entry);
    public sealed virtual void Read(MultiChartData destination, IList`1<int> eventTypes, ChartRange range, int pointsToRead);
    public sealed virtual double GetXValue(int index);
    public sealed virtual double MaxYSumValue(IList`1<int> eventTypes);
    private void CopyData(IList`1<double> source, IList`1<double> destination, int leftIndex, int rightIndex, int pointsToRead);
    private Pair`2<int, int> GetRangeIndices(ChartRange range);
    private Int32[] GetEventTypesIndices(IList`1<int> requestedEventTypes);
    [CompilerGeneratedAttribute]
private bool <GetEventTypesIndices>b__16_0(int i);
    [CompilerGeneratedAttribute]
private int <GetEventTypesIndices>b__16_1(int i);
}
public interface JetBrains.Common.Timeline.Framework.Realtime.IRealtimeViewportAnimator {
    public IViewport Viewport { get; }
    public abstract virtual IViewport get_Viewport();
}
[UsedImplicitlyAttribute]
public class JetBrains.Common.Timeline.Framework.Realtime.ProcessMonitorDataProvider : object {
    private ITickProvider myTickProvider;
    private IDataController`1<bool> myHasCounters;
    private IProcessMonitor myProcessMonitor;
    public IDataProvider`1<bool> HasCounters { get; }
    public ProcessMonitorDataProvider(ITickProvider tickProvider, int processId);
    public sealed virtual IDataProvider`1<bool> get_HasCounters();
    public void SwitchProcess(int processId);
    public sealed virtual IAsyncDataProvider`1<RealtimeDataEntry> SelectEventTypes(IList`1<KnownEventTypes> eventTypes);
}
[UsedImplicitlyAttribute]
public class JetBrains.Common.Timeline.Framework.Realtime.RealtimeDataGeneratorFactory : object {
    private IProcessMonitorDataProvider myCountersDataProvider;
    private IInMemoryChartStorage myStorage;
    public RealtimeDataGeneratorFactory(IProcessMonitorDataProvider countersProvider, IInMemoryChartStorage storage);
    public sealed virtual IDataProvider`1<RealtimeDataEntry> CreateCurrentDataProvider(IList`1<int> eventTypes);
    public sealed virtual IDataProvider`1<double> CreateMaxSumProvider(IList`1<int> eventTypes);
    public sealed virtual IDataProvider`1<MultiChartData> CreateChartDataProvider(IList`1<int> eventTypes, IDataProvider`1<ChartRange> rangeProvider, int maxPointsToProvide);
}
[UsedImplicitlyAttribute]
public class JetBrains.Common.Timeline.Framework.Realtime.RealtimeDataReaderFactory : object {
    private IInMemoryChartStorage myStorage;
    public RealtimeDataReaderFactory(IInMemoryChartStorage storage);
    public sealed virtual IDataProvider`1<RealtimeDataEntry> CreateCurrentDataProvider(IList`1<int> eventTypes);
    public sealed virtual IDataProvider`1<double> CreateMaxSumProvider(IList`1<int> eventTypes);
    public sealed virtual IDataProvider`1<MultiChartData> CreateChartDataProvider(IList`1<int> eventTypes, IDataProvider`1<ChartRange> rangeProvider, int maxPointsToProvide);
}
public class JetBrains.Common.Timeline.Framework.Realtime.RealtimeViewportAnimator : object {
    private ITickTimeConverter myTickTimeConverter;
    private static double DefaultSpeedPixelsPerSecond;
    private Viewport myViewport;
    private ulong myCurrentModelTick;
    private ulong myStartTick;
    private SnappingMode mySnappingMode;
    [CompilerGeneratedAttribute]
private bool <AutoSnapping>k__BackingField;
    private bool myIgnoreViewportChange;
    private double myPreviousScreenWidth;
    private bool myVisibleRangeForced;
    public bool AutoSnapping { get; public set; }
    public SnappingMode Snapping { get; public set; }
    public ulong StartTick { get; }
    public IViewport Viewport { get; }
    public RealtimeViewportAnimator(Lifetime lifetime, ITickProvider currentTickProvider, ITickTimeConverter tickTimeConverter, ulong startTick, double minUnitsPerPixel);
    [CompilerGeneratedAttribute]
public bool get_AutoSnapping();
    [CompilerGeneratedAttribute]
public void set_AutoSnapping(bool value);
    public SnappingMode get_Snapping();
    public void set_Snapping(SnappingMode value);
    public ulong get_StartTick();
    private void CurrentTickProviderOnUpdated(ulong tick);
    private void ViewportOnChanged(object sender, EventArgs eventArgs);
    private void ViewportOnScreenWidthChanged();
    public sealed virtual IViewport get_Viewport();
    public void ForceSetVisibleRange(ModelRangeDouble range);
    private double GetDefaultSpeedVisibleRangeWidth();
    private void UpdateViewportAlignedToRight(double visibleRangeLength);
    private void UpdateViewport();
}
public class JetBrains.Common.Timeline.Framework.Realtime.SnapshotIntervalsProvider : object {
    private MarkersModelData myData;
    private IDataController`1<MarkersModelData> myController;
    public IDataProvider`1<MarkersModelData> Provider { get; }
    public IDataProvider`1<MarkersModelData> get_Provider();
    public void BeginSnapshot(ulong tick);
    public void EndSnapshot(ulong tick);
}
public class JetBrains.Common.Timeline.Framework.Realtime.TickProvider : object {
    private TickDataController myTickController;
    private IDispatcherTimer myTimer;
    public IAsyncDataProvider`1<ulong> Provider { get; }
    public TickProvider(ITickHolder tickHolder, TimeSpan timeSpan, Lifetime lifetime, IDispatcherTimerFactory dispatcherTimerFactory);
    public sealed virtual IAsyncDataProvider`1<ulong> get_Provider();
    private void OnTimer(object sender, EventArgs e);
    [CompilerGeneratedAttribute]
private void <.ctor>b__2_0();
    [CompilerGeneratedAttribute]
private void <.ctor>b__2_1();
}
public static class JetBrains.Common.Timeline.Framework.Realtime.VisiblePointsDataProvider : object {
    [IteratorStateMachineAttribute("JetBrains.Common.Timeline.Framework.Realtime.VisiblePointsDataProvider/<SubList>d__0`1")]
private static IEnumerable`1<T> SubList(IList`1<T> list, int index, int count);
    private static void FindBorders(IList`1<Point> list, IViewport viewport, Double& maxValue, Int32& leftIndex, Int32& rightIndex);
    public static IDataProvider`1<PointsChartViewData> Create(IDataProvider`1<IList`1<Point>> pointsProvider, IViewport viewport, double maxValue);
}
public class JetBrains.Common.Timeline.Framework.SelectionHosts.CompactRangeSelectionHost : RangeSelectionHostBase {
    public CompactRangeSelectionHost(Lifetime lifetime, IViewport viewport);
}
[ExtensionAttribute]
public static class JetBrains.Common.Timeline.Framework.SelectionHosts.Extensions : object {
    [ExtensionAttribute]
public static IDataProvider`1<THost> HostToDataProvider(THost host);
    [ExtensionAttribute]
public static IDataProvider`1<Nullable`1<ScreenRange>> ToScreenRangeProvider(IRangeSelectionHost host);
}
public class JetBrains.Common.Timeline.Framework.SelectionHosts.PointsChartSelectionHost : RangeSelectionHostBase {
    [CompilerGeneratedAttribute]
private IPointsChartViewModel <Owner>k__BackingField;
    public IPointsChartViewModel Owner { get; }
    public PointsChartSelectionHost(Lifetime lifetime, IViewport viewport, IPointsChartViewModel owner);
    [CompilerGeneratedAttribute]
public sealed virtual IPointsChartViewModel get_Owner();
}
public class JetBrains.Common.Timeline.Framework.SelectionHosts.RangeSelectionHostBase : SelectionHostBase {
    private IViewport myViewport;
    private bool myIsInteractive;
    private bool myUpdateModelRangeFromScreenRange;
    private bool myUpdateScreenRangeFromModelRange;
    [CompilerGeneratedAttribute]
private IDataController`1<ScreenRange> <ScreenRange>k__BackingField;
    [CompilerGeneratedAttribute]
private IDataController`1<ModelRange> <ModelRange>k__BackingField;
    protected IViewport Viewport { get; }
    public IWriteableDataNotifier`1<ScreenRange> ScreenRangeNotifier { get; }
    public IDataController`1<ScreenRange> ScreenRange { get; }
    public IDataController`1<ModelRange> ModelRange { get; }
    public IDataNotifier`1<ModelRange> ModelRangeNotifier { get; }
    public bool IsInteractive { get; public set; }
    protected RangeSelectionHostBase(Lifetime lifetime, IViewport viewport);
    public virtual IDataProvider`1<ISelectionHost> AsProvider();
    public virtual void CopyFrom(ISelectionHost selection);
    protected IViewport get_Viewport();
    private void ViewportOnChanged(object sender, EventArgs eventArgs);
    public sealed virtual void SetScreenAndModelRanges(ScreenRange screenRange, ModelRange modelRange);
    protected virtual void UpdateScreenRangeFromModelRange();
    protected void UpdateModelRangeFromScreenRange();
    public sealed virtual IWriteableDataNotifier`1<ScreenRange> get_ScreenRangeNotifier();
    private void SetModelRangeOnly(ModelRange range);
    protected void SetScreenRangeOnly(ScreenRange range);
    [CompilerGeneratedAttribute]
public sealed virtual IDataController`1<ScreenRange> get_ScreenRange();
    [CompilerGeneratedAttribute]
public sealed virtual IDataController`1<ModelRange> get_ModelRange();
    public sealed virtual IDataNotifier`1<ModelRange> get_ModelRangeNotifier();
    public sealed virtual bool get_IsInteractive();
    public sealed virtual void set_IsInteractive(bool value);
    [CompilerGeneratedAttribute]
private RangeSelectionHostBase <AsProvider>b__4_0(ModelRange _);
    [CompilerGeneratedAttribute]
private void <.ctor>b__8_0(ScreenRange r);
    [CompilerGeneratedAttribute]
private void <.ctor>b__8_1(ModelRange r);
    [CompilerGeneratedAttribute]
private void <.ctor>b__8_2();
}
public abstract class JetBrains.Common.Timeline.Framework.SelectionHosts.SelectionHostBase : object {
    private IDataController`1<bool> myIsActiveController;
    [CompilerGeneratedAttribute]
private IMouseController <MouseController>k__BackingField;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    public IDataController`1<bool> IsActive { get; }
    public IDataNotifier`1<bool> IsActiveNotifier { get; }
    public IMouseController MouseController { get; public set; }
    public sealed virtual IDataController`1<bool> get_IsActive();
    public sealed virtual IDataNotifier`1<bool> get_IsActiveNotifier();
    [CompilerGeneratedAttribute]
public sealed virtual IMouseController get_MouseController();
    [CompilerGeneratedAttribute]
public sealed virtual void set_MouseController(IMouseController value);
    protected void RaisePropertyChanged(Expression`1<Func`1<T>> property);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    public virtual void CopyFrom(ISelectionHost selection);
    protected virtual void OnDeactivated();
    public virtual IDataProvider`1<ISelectionHost> AsProvider();
    [CompilerGeneratedAttribute]
private void <.ctor>b__9_0(bool a);
}
public class JetBrains.Common.Timeline.Framework.SelectionHosts.WormSelectionHost : RangeSelectionHostBase {
    private IDataProvider`1<PixelChartData> myViewData;
    [CompilerGeneratedAttribute]
private SingleChartTypes <ChartType>k__BackingField;
    public IDataProvider`1<PixelChartData> ViewDataProvider { get; }
    public SingleChartTypes ChartType { get; private set; }
    public WormSelectionHost(Lifetime lifetime, IViewport viewport, IDataProvider`1<PixelChartData> viewDataProvider);
    public void Update(ScreenRange range, SingleChartTypes chartType);
    public sealed virtual IDataProvider`1<PixelChartData> get_ViewDataProvider();
    [CompilerGeneratedAttribute]
public sealed virtual SingleChartTypes get_ChartType();
    [CompilerGeneratedAttribute]
private void set_ChartType(SingleChartTypes value);
}
[UsedImplicitlyAttribute]
public class JetBrains.Common.Timeline.Framework.SeparateThreadTickProvider : object {
    private Lifetime myLifetime;
    private TickDataController myTickController;
    private IAsyncDataController`1<ulong> myProvider;
    private TimeSpan myTimeSpan;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) myIsTerminated;
    private Thread myThread;
    public IAsyncDataProvider`1<ulong> Provider { get; }
    public SeparateThreadTickProvider(ITickHolder tickHolder, TimeSpan timeSpan, Lifetime lifetime);
    public sealed virtual IAsyncDataProvider`1<ulong> get_Provider();
    public sealed virtual void Start();
    private void StartThread();
    private void StopThread();
    private void ThreadLogic();
    [CompilerGeneratedAttribute]
private void <.ctor>b__6_0();
}
public class JetBrains.Common.Timeline.Framework.TickDataController : object {
    private ITickHolder myCurrentTickHolder;
    private IDataControllerBase`1<ulong> myDataController;
    private IAsyncDataProvider`1<ulong> myDataProvider;
    public IAsyncDataProvider`1<ulong> Provider { get; }
    public ulong Value { get; }
    public TickDataController(ITickHolder currentTickHolder, Mode mode);
    public IAsyncDataProvider`1<ulong> get_Provider();
    public void NextValue();
    public ulong get_Value();
}
public abstract class JetBrains.Common.Timeline.Framework.TimelineElementSelectorBase`2 : object {
    [CompilerGeneratedAttribute]
private ISetProvider`1<bool> <IsActive>k__BackingField;
    [CompilerGeneratedAttribute]
private Action Updated;
    private TData myViewData;
    public ISetProvider`1<bool> IsActive { get; }
    protected TData ViewData { get; }
    protected TimelineElementSelectorBase`2(IDataProvider`1<TData> viewDataProvider);
    [CompilerGeneratedAttribute]
public sealed virtual ISetProvider`1<bool> get_IsActive();
    public abstract virtual void AutoSelect(Point screenPoint, THost selection);
    [CompilerGeneratedAttribute]
public sealed virtual void add_Updated(Action value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Updated(Action value);
    protected TData get_ViewData();
    [CompilerGeneratedAttribute]
private void <.ctor>b__8_0(TData value);
}
public static class JetBrains.Common.Timeline.Framework.TimeScale.TimeScaleData : object {
    public static UnitScale`1<TimeUnits> TickScale;
    public static UnitScale`1<TimeUnits> LabelScale;
    private static TimeScaleData();
    public static double GetFirstTick(ulong nsPeriod, double nsLeft);
    public static PeriodAndOffset CalculatePixelPeriodAndOffset(ulong nsPeriod, double nsLeft, double nsPerPixel);
    public static UnitValue`1<TimeUnits> ToMajorPart(double nsTime);
}
public class JetBrains.Common.Timeline.Framework.TimeScale.TimeScaleViewModel : object {
    private IViewport myViewport;
    private IList`1<PositionedFormattableContent> mySmallLabels;
    private IList`1<PositionedFormattableContent> myBigLabels;
    private ITickTimeConverter myTickTimeConverter;
    private double myZeroTick;
    [CompilerGeneratedAttribute]
private bool <CenterLabels>k__BackingField;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    [CompilerGeneratedAttribute]
private PeriodAndOffset <LittleTicks>k__BackingField;
    [CompilerGeneratedAttribute]
private PeriodAndOffset <LargeTicks>k__BackingField;
    [CompilerGeneratedAttribute]
private PeriodAndOffset <MiddleTicks>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AlignToTop>k__BackingField;
    public bool CenterLabels { get; public set; }
    public PeriodAndOffset LittleTicks { get; private set; }
    public PeriodAndOffset LargeTicks { get; private set; }
    public PeriodAndOffset MiddleTicks { get; private set; }
    public ICollection`1<PositionedFormattableContent> SmallLabels { get; }
    public ICollection`1<PositionedFormattableContent> BigLabels { get; }
    public bool AlignToTop { get; public set; }
    public TimeScaleViewModel(IViewport viewport, ITickTimeConverter tickTimeConverter);
    public TimeScaleViewModel(IViewport viewport, ITickTimeConverter tickTimeConverter, double zeroTick);
    [CompilerGeneratedAttribute]
public bool get_CenterLabels();
    [CompilerGeneratedAttribute]
public void set_CenterLabels(bool value);
    private void ViewportOnPropertyChanged(object sender, EventArgs eventArgs);
    private void Update();
    private static UnitValue`1<TimeUnits> ToMajorPart(double nsTime);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual PeriodAndOffset get_LittleTicks();
    [CompilerGeneratedAttribute]
private void set_LittleTicks(PeriodAndOffset value);
    [CompilerGeneratedAttribute]
public sealed virtual PeriodAndOffset get_LargeTicks();
    [CompilerGeneratedAttribute]
private void set_LargeTicks(PeriodAndOffset value);
    [CompilerGeneratedAttribute]
public sealed virtual PeriodAndOffset get_MiddleTicks();
    [CompilerGeneratedAttribute]
private void set_MiddleTicks(PeriodAndOffset value);
    public sealed virtual ICollection`1<PositionedFormattableContent> get_SmallLabels();
    public sealed virtual ICollection`1<PositionedFormattableContent> get_BigLabels();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_AlignToTop();
    [CompilerGeneratedAttribute]
public void set_AlignToTop(bool value);
}
public class JetBrains.Common.Timeline.Framework.Wrappers.HideableViewModel : object {
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    [CompilerGeneratedAttribute]
private object <Content>k__BackingField;
    [CompilerGeneratedAttribute]
private IDataNotifier`1<bool> <IsVisible>k__BackingField;
    [CompilerGeneratedAttribute]
private HideMode <Mode>k__BackingField;
    public object Content { get; }
    public IDataNotifier`1<bool> IsVisible { get; }
    public HideMode Mode { get; public set; }
    public HideableViewModel(object content, IDataProvider`1<bool> isVisible);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual object get_Content();
    [CompilerGeneratedAttribute]
public sealed virtual IDataNotifier`1<bool> get_IsVisible();
    [CompilerGeneratedAttribute]
public sealed virtual HideMode get_Mode();
    [CompilerGeneratedAttribute]
public void set_Mode(HideMode value);
}
[ZoneMarkerAttribute]
public class JetBrains.Common.Timeline.Framework.ZoneMarker : object {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
