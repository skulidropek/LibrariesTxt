[ExtensionAttribute]
public static class JetBrains.Common.Util.Shell.Actions.DefaultDataRules : object {
    private static Dictionary`2<Type, IDataConstant> ourMap;
    private static DefaultDataRules();
    private static DataConstant`1<T> GetConstant();
    public static IDataRule Create(T obj);
    public static IDataRule Create(T obj, Lifetime lifetime);
    public static IDataRule Create(Func`2<IDataContext, T> getValue);
    public static IDataRule Create(Func`2<IDataContext, T> getValue, Lifetime lifetime);
    public static IDataRule CreateStruct(T obj);
    public static IDataRule CreateStruct(T obj, Lifetime lifetime);
    public static IDataRule CreateStruct(Func`1<T> getValue);
    public static IDataRule CreateStruct(Func`1<T> getValue, Lifetime lifetime);
    [ExtensionAttribute]
public static T GetData(IDataContext context);
    [ExtensionAttribute]
public static Nullable`1<T> GetDataStruct(IDataContext context);
    [ExtensionAttribute]
[PureAttribute]
public static IDataRule CreateDataRule(DataConstant`1<T> constant, T value);
    [ExtensionAttribute]
[PureAttribute]
public static IDataRule CreateDataRule(DataConstant`1<StructWrapper`1<T>> constant, T value);
    [ExtensionAttribute]
[PureAttribute]
public static IDataRule CreateDataRule(DataConstant`1<T> constant, Func`2<IDataContext, T> value);
}
public interface JetBrains.Common.Util.Shell.Actions.IActionInterceptor {
    public int Priority { get; }
    public abstract virtual int get_Priority();
    public abstract virtual void DoBeforeExecute(Type actionType);
}
public abstract class JetBrains.Common.Util.Shell.Actions.InterceptableAction`1 : object {
    private IEnumerable`1<TInterceptor> myActionInterceptors;
    public sealed virtual bool Update(IDataContext context, ActionPresentation presentation, DelegateUpdate nextUpdate);
    public sealed virtual void Execute(IDataContext context, DelegateExecute nextExecute);
    protected abstract virtual bool PerformUpdate(IDataContext context, ActionPresentation presentation, DelegateUpdate nextUpdate);
    protected abstract virtual void PerformExecute(IDataContext context, DelegateExecute nextExecute);
    private IEnumerable`1<TInterceptor> GetActionInterceptors(IDataContext context);
}
public class JetBrains.Common.Util.Shell.Actions.ViewModelAction : object {
    private Func`3<IDataContext, ActionPresentation, bool> myCanExecute;
    private Action`1<IDataContext> myExecute;
    protected ViewModelAction(Func`1<bool> canExecute, Action execute);
    protected ViewModelAction(Func`2<IDataContext, bool> canExecute, Action`1<IDataContext> execute);
    protected ViewModelAction(Func`3<IDataContext, ActionPresentation, bool> canExecute, Action`1<IDataContext> execute);
    public sealed virtual bool Update(IDataContext context, ActionPresentation presentation, DelegateUpdate nextUpdate);
    public sealed virtual void Execute(IDataContext context, DelegateExecute nextExecute);
}
public class JetBrains.Common.Util.Shell.Actions.ViewModelAction`1 : ViewModelActionBase`1<T> {
    protected ViewModelAction`1(Func`2<T, bool> canExecute, Action`1<T> execute);
    protected ViewModelAction`1(Func`3<T, IDataContext, bool> canExecute, Action`2<T, IDataContext> execute);
    protected ViewModelAction`1(Func`4<T, IDataContext, ActionPresentation, bool> canExecute, Action`2<T, IDataContext> execute);
}
public class JetBrains.Common.Util.Shell.Actions.ViewModelActionBase`1 : object {
    private Func`4<T, IDataContext, ActionPresentation, bool> myCanExecute;
    private Action`2<T, IDataContext> myExecute;
    private Func`2<IDataContext, T> myComponentResolver;
    protected ViewModelActionBase`1(Func`4<T, IDataContext, ActionPresentation, bool> canExecute, Action`2<T, IDataContext> execute, Func`2<IDataContext, T> componentResolver);
    public sealed virtual bool Update(IDataContext context, ActionPresentation presentation, DelegateUpdate nextUpdate);
    public sealed virtual void Execute(IDataContext context, DelegateExecute nextExecute);
}
public class JetBrains.Common.Util.Shell.Actions.WpfCommandActionHandler`1 : object {
    private Func`2<TComponent, ICommand> myProperty;
    public WpfCommandActionHandler`1(Func`2<TComponent, ICommand> property);
    private ICommand GetCommand(IDataContext context);
    public sealed virtual bool Update(IDataContext context, ActionPresentation presentation, DelegateUpdate nextUpdate);
    public sealed virtual void Execute(IDataContext context, DelegateExecute nextExecute);
}
public class JetBrains.Common.Util.Shell.AggressivelyFlushedContextBoundSettingsFileLive : object {
    private Lifetime myLifetime;
    private IThreading myThreading;
    private IContextBoundSettingsStoreLive mySettings;
    private Action myFlush;
    [CompilerGeneratedAttribute]
private IProperty`1<FileSystemPath> <FilePath>k__BackingField;
    public IProperty`1<FileSystemPath> FilePath { get; }
    public bool IsIgnoringReadonlyFlag { get; public set; }
    public ISettingsStore SettingsStore { get; }
    public ISettingsSchema Schema { get; }
    public ISignal`1<SettingsStoreChangeArgs> Changed { get; }
    private ImmutableContextBoundMountPoints JetBrains.Application.Settings.IContextBoundSettingsStore.InvolvedMountPoints { get; }
    private ILiveMountPointsInContext JetBrains.Application.Settings.IContextBoundSettingsStoreLive.InvolvedMountPointsLive { get; }
    private BindToContextFlags JetBrains.Application.Settings.IContextBoundSettingsStore.BindToContextFlags { get; }
    public AggressivelyFlushedContextBoundSettingsFileLive(Lifetime lifetime, IProperty`1<FileSystemPath> filePath, IThreading threading, Action flush, IContextBoundSettingsStoreLive settings);
    [CompilerGeneratedAttribute]
public sealed virtual IProperty`1<FileSystemPath> get_FilePath();
    public sealed virtual void Flush();
    public sealed virtual TEntryValue GetValue(Expression`1<Func`2<TKeyClass, TEntryValue>> lambdaExpression);
    public sealed virtual object GetValue(SettingsScalarEntry entry, IDictionary`2<SettingsKey, object> keyIndices);
    public sealed virtual Object[] GetValues(IList`1<SettingsScalarEntry> entries, IDictionary`2<SettingsKey, object> keyIndices);
    public sealed virtual void SetValue(SettingsScalarEntry entry, object value, IDictionary`2<SettingsKey, object> keyIndices);
    public sealed virtual void ResetValue(SettingsScalarEntry entry, IDictionary`2<SettingsKey, object> keyIndices);
    public sealed virtual object GetIndexedValue(SettingsIndexedEntry entry, object entryIndex, IDictionary`2<SettingsKey, object> keyIndices);
    public sealed virtual void SetIndexedValue(SettingsIndexedEntry entry, object entryIndex, IDictionary`2<SettingsKey, object> keyIndices, object value);
    public sealed virtual void RemoveIndexedValue(SettingsIndexedEntry entry, object entryIndex, IDictionary`2<SettingsKey, object> keyIndices);
    public sealed virtual void CreateIndexedKey(SettingsIndexedKey key, IDictionary`2<SettingsKey, object> keyIndices);
    public sealed virtual void DeleteIndexedKey(SettingsIndexedKey key, IDictionary`2<SettingsKey, object> keyIndices);
    public sealed virtual bool IsIndexedKeyDefined(SettingsKey key, IDictionary`2<SettingsKey, object> keyIndices);
    public bool get_IsIgnoringReadonlyFlag();
    public void set_IsIgnoringReadonlyFlag(bool value);
    public sealed virtual ISettingsStore get_SettingsStore();
    public sealed virtual ISettingsSchema get_Schema();
    public sealed virtual SettingsStoreChangeArgs GetSnapshot(SettingsKey keyRoot, IDictionary`2<SettingsKey, object> keyIndices);
    public sealed virtual IDictionary`2<object, object> EnumIndexedValues(SettingsIndexedEntry entry, IDictionary`2<SettingsKey, object> keyIndices);
    public sealed virtual IEnumerable`1<object> EnumIndexedKey(SettingsIndexedKey key, IDictionary`2<SettingsKey, object> parentKeyIndices, bool isIgnoringKeyIsDefined);
    public sealed virtual ISignal`1<SettingsStoreChangeArgs> get_Changed();
    public sealed virtual IProperty`1<TValue> GetValueProperty(Lifetime lifetime, SettingsScalarEntry entry, IDictionary`2<SettingsKey, object> keyIndices);
    private sealed virtual override ImmutableContextBoundMountPoints JetBrains.Application.Settings.IContextBoundSettingsStore.get_InvolvedMountPoints();
    private sealed virtual override void JetBrains.Application.Settings.ISettingsChangedEventSource.AdviseAsyncChanged(Lifetime lifetime, AsyncChangedSinkDelegate sink);
    private sealed virtual override ILiveMountPointsInContext JetBrains.Application.Settings.IContextBoundSettingsStoreLive.get_InvolvedMountPointsLive();
    private sealed virtual override IProperty`1<TValue> JetBrains.Application.Settings.IContextBoundSettingsStoreLive.GetValueProperty2(Lifetime lifetime, SettingsScalarEntry entry, IDictionary`2<SettingsKey, object> keyIndices, ApartmentForNotifications apartmentForNotifications);
    private sealed virtual override BindToContextFlags JetBrains.Application.Settings.IContextBoundSettingsStore.get_BindToContextFlags();
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.Shell.APM.AsyncOperationExtensionsShell : object {
    [ExtensionAttribute]
public static void WaitWithJetDispatcher(IAsyncOperation operation);
    [ExtensionAttribute]
public static void WaitWithJetDispatcherAndLifetime(IAsyncOperation operation, Lifetime lifetime);
}
[ZoneDefinitionAttribute]
public interface JetBrains.Common.Util.Shell.BuildScript.IAsyncParallelInitializationEnvZone {
}
[ZoneDefinitionAttribute]
public interface JetBrains.Common.Util.Shell.BuildScript.ILegacyInitializationEnvZone {
}
[EnvironmentComponentAttribute("10")]
[ZoneMarkerAttribute]
public class JetBrains.Common.Util.Shell.ConsoleHelpers.CompactConsoleLogger : object {
    private CustomLoggerListener myListener;
    public bool Debug { get; public set; }
    public CompactConsoleLogger(ConsoleLoggerMixin logger, ConsoleApplicationExitCode exitCode);
    public bool get_Debug();
    public void set_Debug(bool value);
}
public class JetBrains.Common.Util.Shell.ConsoleHelpers.ConsoleApplicationExitCode : object {
    [CompilerGeneratedAttribute]
private Nullable`1<int> <ExitCode>k__BackingField;
    public Nullable`1<int> ExitCode { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_ExitCode();
    [CompilerGeneratedAttribute]
public void set_ExitCode(Nullable`1<int> value);
}
public class JetBrains.Common.Util.Shell.ConsoleHelpers.InsertObjectToComponentContianerMixIn : object {
    private object myOptions;
    public InsertObjectToComponentContianerMixIn(object options);
    public sealed virtual void Fill(ComponentContainer container, EnvironmentPartCatalogSet catalogsetContainer);
}
public class JetBrains.Common.Util.Shell.ConsoleHelpers.UnblockFileManager : object {
    public static int STGM_READ;
    public static int STGM_WRITE;
    public static int STGM_READWRITE;
    public static int STGM_SHARE_EXCLUSIVE;
    private IZoneIdentifier myZoneId;
    private IPersistFile myFile;
    public UnblockFileManager(Lifetime lifetime);
    public bool IsSupported();
    public SecurityZone GetFileZone(FileSystemPath fullFilename);
    public void SetFileZone(FileSystemPath fullFilename, SecurityZone zoneId);
    public void RemoveZoneId(FileSystemPath fullFilename);
    [CompilerGeneratedAttribute]
private void <.ctor>b__6_0();
}
public class JetBrains.Common.Util.Shell.ContextBoundSettingsFileLive : object {
    private IContextBoundSettingsStoreLive mySettings;
    private Action myFlush;
    [CompilerGeneratedAttribute]
private IProperty`1<FileSystemPath> <FilePath>k__BackingField;
    public IProperty`1<FileSystemPath> FilePath { get; }
    private ImmutableContextBoundMountPoints JetBrains.Application.Settings.IContextBoundSettingsStore.InvolvedMountPoints { get; }
    private ILiveMountPointsInContext JetBrains.Application.Settings.IContextBoundSettingsStoreLive.InvolvedMountPointsLive { get; }
    public ISettingsStore SettingsStore { get; }
    public ISettingsSchema Schema { get; }
    public ISignal`1<SettingsStoreChangeArgs> Changed { get; }
    private BindToContextFlags JetBrains.Application.Settings.IContextBoundSettingsStore.BindToContextFlags { get; }
    public ContextBoundSettingsFileLive(IProperty`1<FileSystemPath> filePath, Action flush, IContextBoundSettingsStoreLive settings);
    [CompilerGeneratedAttribute]
public sealed virtual IProperty`1<FileSystemPath> get_FilePath();
    public sealed virtual void Flush();
    public sealed virtual TEntryValue GetValue(Expression`1<Func`2<TKeyClass, TEntryValue>> lambdaExpression);
    public sealed virtual object GetValue(SettingsScalarEntry entry, IDictionary`2<SettingsKey, object> keyIndices);
    public sealed virtual Object[] GetValues(IList`1<SettingsScalarEntry> entries, IDictionary`2<SettingsKey, object> keyIndices);
    public sealed virtual void SetValue(SettingsScalarEntry entry, object value, IDictionary`2<SettingsKey, object> keyIndices);
    public sealed virtual void ResetValue(SettingsScalarEntry entry, IDictionary`2<SettingsKey, object> keyIndices);
    public sealed virtual object GetIndexedValue(SettingsIndexedEntry entry, object entryIndex, IDictionary`2<SettingsKey, object> keyIndices);
    public sealed virtual void SetIndexedValue(SettingsIndexedEntry entry, object entryIndex, IDictionary`2<SettingsKey, object> keyIndices, object value);
    public sealed virtual void RemoveIndexedValue(SettingsIndexedEntry entry, object entryIndex, IDictionary`2<SettingsKey, object> keyIndices);
    public sealed virtual void CreateIndexedKey(SettingsIndexedKey key, IDictionary`2<SettingsKey, object> keyIndices);
    public sealed virtual void DeleteIndexedKey(SettingsIndexedKey key, IDictionary`2<SettingsKey, object> keyIndices);
    public sealed virtual bool IsIndexedKeyDefined(SettingsKey key, IDictionary`2<SettingsKey, object> keyIndices);
    private sealed virtual override ImmutableContextBoundMountPoints JetBrains.Application.Settings.IContextBoundSettingsStore.get_InvolvedMountPoints();
    private sealed virtual override ILiveMountPointsInContext JetBrains.Application.Settings.IContextBoundSettingsStoreLive.get_InvolvedMountPointsLive();
    public sealed virtual ISettingsStore get_SettingsStore();
    public sealed virtual ISettingsSchema get_Schema();
    public sealed virtual SettingsStoreChangeArgs GetSnapshot(SettingsKey keyRoot, IDictionary`2<SettingsKey, object> keyIndices);
    public sealed virtual IDictionary`2<object, object> EnumIndexedValues(SettingsIndexedEntry entry, IDictionary`2<SettingsKey, object> keyIndices);
    public sealed virtual IEnumerable`1<object> EnumIndexedKey(SettingsIndexedKey key, IDictionary`2<SettingsKey, object> parentKeyIndices, bool isIgnoringKeyIsDefined);
    public sealed virtual ISignal`1<SettingsStoreChangeArgs> get_Changed();
    public sealed virtual IProperty`1<TValue> GetValueProperty(Lifetime lifetime, SettingsScalarEntry entry, IDictionary`2<SettingsKey, object> keyIndices);
    private sealed virtual override void JetBrains.Application.Settings.ISettingsChangedEventSource.AdviseAsyncChanged(Lifetime lifetime, AsyncChangedSinkDelegate sink);
    private sealed virtual override IProperty`1<TValue> JetBrains.Application.Settings.IContextBoundSettingsStoreLive.GetValueProperty2(Lifetime lifetime, SettingsScalarEntry entry, IDictionary`2<SettingsKey, object> keyIndices, ApartmentForNotifications apartmentForNotifications);
    private sealed virtual override BindToContextFlags JetBrains.Application.Settings.IContextBoundSettingsStore.get_BindToContextFlags();
}
public static class JetBrains.Common.Util.Shell.DmSettingsContext : object {
    public static DataConstant`1<object> SettingsFileId;
    private static DmSettingsContext();
}
[EnvironmentComponentAttribute("16")]
[ZoneMarkerAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class JetBrains.Common.Util.Shell.Environment.AsyncParallelInitializationStrategyProvider : InitializationStrategyProvider {
    private static string CommandLineKey;
    private bool myUseAsyncStrategy;
    public AsyncParallelInitializationStrategyProvider(IThreading threading, IProductCommandLine commandLine, IAsyncComposeManager asyncComposeManager);
    public virtual IInitializationStrategy InitializationStrategy(Lifetime lifetime);
}
[EnvironmentComponentAttribute("9")]
public class JetBrains.Common.Util.Shell.Environment.DataProvidersComponent : object {
}
[EnvironmentComponentAttribute("16")]
[ZoneMarkerAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class JetBrains.Common.Util.Shell.Environment.LegacyInitializationStrategyProvider : InitializationStrategyProvider {
    public LegacyInitializationStrategyProvider(IThreading threading, IAsyncComposeManager asyncComposeManager);
    public virtual IInitializationStrategy InitializationStrategy(Lifetime lifetime);
}
[ShellComponentAttribute("16")]
public class JetBrains.Common.Util.Shell.IconExtractor.DummyAppIconExtractor : object {
    public virtual IDataProvider`1<object> GetAppIcon(Lifetime lifetime, FileSystemPath path, IconId fallBackIcon);
}
public interface JetBrains.Common.Util.Shell.IconExtractor.IAsyncAppIconExtractor {
    public abstract virtual IDataProvider`1<object> GetAppIcon(Lifetime lifetime, FileSystemPath path, IconId fallBackIcon);
}
[ZoneDefinitionAttribute]
public interface JetBrains.Common.Util.Shell.IDotCommonSharedZone {
}
public class JetBrains.Common.Util.Shell.IndexKeysChanges : object {
    [CompilerGeneratedAttribute]
private IEnumerable`1<SettingsKeyInstance> <Changed>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<SettingsKeyInstance> <Added>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<SettingsKeyInstance> <Removed>k__BackingField;
    public IEnumerable`1<SettingsKeyInstance> Changed { get; }
    public IEnumerable`1<SettingsKeyInstance> Added { get; }
    public IEnumerable`1<SettingsKeyInstance> Removed { get; }
    public IndexKeysChanges(IEnumerable`1<SettingsKeyInstance> changed, IEnumerable`1<SettingsKeyInstance> added, IEnumerable`1<SettingsKeyInstance> removed);
    [CompilerGeneratedAttribute]
public IEnumerable`1<SettingsKeyInstance> get_Changed();
    [CompilerGeneratedAttribute]
public IEnumerable`1<SettingsKeyInstance> get_Added();
    [CompilerGeneratedAttribute]
public IEnumerable`1<SettingsKeyInstance> get_Removed();
    public bool IsEmpty();
}
public interface JetBrains.Common.Util.Shell.ISettingsFactory {
    public abstract virtual SettingsFileLiveWithMountPoints OpenLiveSettingsFile(FileSystemPath settingsFilePath, Lifetime lifetime, SettingsFactoryOptions options);
}
[ZoneDefinitionAttribute]
public interface JetBrains.Common.Util.Shell.IStandaloneCmdWithDotCommonConsoleHelpersEnvironmentZone {
}
[ZoneDefinitionAttribute]
public interface JetBrains.Common.Util.Shell.IViewerOpenerZone {
}
public static class JetBrains.Common.Util.Shell.KnownToolWindowIds : object {
    public static string SourceView;
}
internal class JetBrains.Common.Util.Shell.Launcher.ComponentContainerMixin : object {
    private IRemoteCommunicator myComm;
    private static ILogger ourLogger;
    private IDataProxy`1<IComponentContainer> myDataProxy;
    public IDataProvider`1<IComponentContainer> Data { get; }
    public ComponentContainerMixin(IRemoteCommunicator comm);
    private static ComponentContainerMixin();
    public void SetValue(IComponentContainer container);
    public IDataProvider`1<IComponentContainer> get_Data();
    private sealed virtual override void JetBrains.Application.Environment.HostParameters.IHaveEnvironmentComponentsHostMixin.Fill(ComponentContainer container, EnvironmentPartCatalogSet catalogsetContainer);
}
[ZoneDefinitionAttribute]
public interface JetBrains.Common.Util.Shell.Launcher.IExternalStorageEnvironmentZone {
}
[ShellComponentAttribute("10")]
internal class JetBrains.Common.Util.Shell.Launcher.ShellComponents.ComponentContainerExtractorComponent : object {
    public ComponentContainerExtractorComponent(IComponentContainer container, ComponentContainerMixin mixin);
}
[ZoneMarkerAttribute]
public class JetBrains.Common.Util.Shell.Launcher.ShellComponents.ZoneMarker : object {
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.Shell.Launcher.ShellLauncher : object {
    public static IDataProvider`1<IComponentContainer> BeginRun(IRemoteCommunicator comm, Type zone);
    public static IDataProvider`1<IComponentContainer> BeginRun(IRemoteCommunicator comm);
    private static void StartShell(ComponentContainerMixin componentContainerMixin, Type zone);
    [ExtensionAttribute]
public static IRemotableReference`1<IComponentContainer> StartRemoteShell(IRemoteCommunicator comm);
    [ExtensionAttribute]
public static IRemotableReference`1<IComponentContainer> StartRemoteShell(IRemoteCommunicator comm, Type zone);
}
[UsedImplicitlyAttribute]
public class JetBrains.Common.Util.Shell.LiveSettings : object {
    private IContextBoundSettingsStoreLive mySettings;
    public LiveSettings(IContextBoundSettingsStoreLive settings);
    public sealed virtual void CreateIndexedKey(Type settingKeyType, object indexKey, IDictionary`2<Type, object> parentIndex);
    public sealed virtual void DeleteIndexedKey(Type settingKeyType, object indexKey, IDictionary`2<Type, object> parentIndex);
    public sealed virtual void SetKey(Type settingKeyType, object value, object indexKey, IDictionary`2<Type, object> parentIndexKeys);
    public sealed virtual object GetKey(Type settingKeyType, object indexKey, IDictionary`2<Type, object> parentIndexKeys);
    public sealed virtual TEntryValue GetIndexedValue(Expression`1<Func`2<TKey, IIndexedEntry`2<TEntryIndex, TEntryValue>>> lambda, TEntryIndex entryIndex, object indexKey, IDictionary`2<Type, object> parentIndexKeys);
    public sealed virtual void SetIndexedValue(Expression`1<Func`2<TKey, IIndexedEntry`2<TEntryIndex, TEntryValue>>> lambda, TEntryIndex entryIndex, TEntryValue value, object indexKey, IDictionary`2<Type, object> parentIndexKeys);
    public sealed virtual void RemoveIndexedValue(Expression`1<Func`2<TKey, IIndexedEntry`2<TEntryIndex, TEntryValue>>> lambda, TEntryIndex entryIndex, object indexKey, IDictionary`2<Type, object> parentIndexKeys);
    public sealed virtual IEnumerable`1<Pair`2<TEntryIndex, TEntryValue>> EnumerateIndexedValues(Expression`1<Func`2<TKey, IIndexedEntry`2<TEntryIndex, TEntryValue>>> lambda, object indexKey, IDictionary`2<Type, object> parentIndexKeys);
    public bool IsIndexedKeyDefined(object indexKey, IDictionary`2<Type, object> parentIndexKeys);
    public sealed virtual void ResetValue(Expression`1<Func`2<TKey, TProperty>> lambda, object indexKey);
    public sealed virtual IProperty`1<TProperty> GetProperty(Expression`1<Func`2<TKey, TProperty>> lambda, object indexKey, Lifetime lifetime, IDictionary`2<Type, object> parentIndexKeys);
    public sealed virtual IEnumerable`1<object> EnumKeyIndices(Type settingKeyType, IDictionary`2<Type, object> parentIndexKeys);
    public IEnumerable`1<Pair`2<TIndexKey, TKey>> EnumIndexedKeys(IDictionary`2<Type, object> parentIndexKeys);
    [IteratorStateMachineAttribute("JetBrains.Common.Util.Shell.LiveSettings/<EnumerateIndexedKeys>d__15")]
public sealed virtual IEnumerable`1<Pair`2<object, object>> EnumerateIndexedKeys(Type settingKeyType, IDictionary`2<Type, object> parentIndexKeys, bool ignoreKeyIsDefined);
    public sealed virtual void AdviseChange(Action callback, Type settingKeyType, Lifetime lifetime);
    public sealed virtual void AdviseChange(Expression`1<Func`2<TKey, TValue>> lambdaexpression, Action callback, Lifetime lifetime);
    private IDictionary`2<SettingsKey, object> MakeKeyIndices(SettingsKey settingsKey, object indexKey, IEnumerable`1<KeyValuePair`2<Type, object>> parentIndexKeys);
}
public abstract class JetBrains.Common.Util.Shell.Options.IgnoreEnvironmentOptionPages : OptionPagesList {
    private HashSet`1<string> myDisabledPageIds;
    private HashSet`1<string> myExplicitlyEnabledPageIds;
    protected IgnoreEnvironmentOptionPages(ShellPartCatalogSet catalogueSet, ProductConfigurations productConfigurations, IEnumerable`1<string> explicitlyEnabledPageIds);
    protected virtual IEnumerable`1<OptionsPageEntity> GetAllOptionsPageEntities();
    protected virtual bool IsPageInConfiguration(OptionsPageAttribute attribute, ProductConfigurations productConfigurations);
    private bool IsDisabled(OptionsPageAttribute attribute);
    protected HashSet`1<string> GetExplicitlyEnabledPageIds();
}
public class JetBrains.Common.Util.Shell.Properties.ExemptFromZoningValidation : object {
    [IteratorStateMachineAttribute("JetBrains.Common.Util.Shell.Properties.ExemptFromZoningValidation/<SuppressZoneValidation>d__0")]
[BuildStepAttribute]
public static IEnumerable`1<SuppressMissingRequirementValidation> SuppressZoneValidation();
}
public class JetBrains.Common.Util.Shell.Remoting.Helpers.ExternalStorageWithShell : ValueType {
    public IRemoteCommunicator Comm;
    public IRemotableReference`1<IComponentContainer> ComponentContainer;
}
public class JetBrains.Common.Util.Shell.Remoting.Helpers.RemotableReferenceToExternalStorageComponentValueResolver : object {
    private Dictionary`2<Type, IValueDescriptor> myReferencesCache;
    private IRemotableReference`1<IComponentContainer> myRemoteComponentContainer;
    [CanBeNullAttribute]
private IContainerThreading myThreading;
    public RemotableReferenceToExternalStorageComponentValueResolver(IRemotableReference`1<IComponentContainer> remoteComponentContainer, ITaskHost taskHost);
    public RemotableReferenceToExternalStorageComponentValueResolver(IRemotableReference`1<IComponentContainer> remoteComponentContainer, IContainerThreading threading);
    public sealed virtual IValueDescriptor Resolve(ResolveRequest request, ValueResolveFlags flags, IValueResolveContext context);
    [NotNullAttribute]
private IValueDescriptor Create(Type underType, IRemotableReference`1<IComponentContainer> remoteComponentContainer);
}
public class JetBrains.Common.Util.Shell.Remoting.Helpers.RemotableReferenceToLocalComponentValueResolver : object {
    private IContainerThreading myThreading;
    public RemotableReferenceToLocalComponentValueResolver(ITaskHost taskHost);
    public RemotableReferenceToLocalComponentValueResolver(IContainerThreading threading);
    public sealed virtual IValueDescriptor Resolve(ResolveRequest request, ValueResolveFlags flags, IValueResolveContext context);
    [NotNullAttribute]
private static IValueDescriptor Create(Type underType, IValueDescriptor underDescriptor, IContainerThreading threading);
}
public interface JetBrains.Common.Util.Shell.Remoting.Interfaces.IExternalStoragePool {
    public abstract virtual ExternalStorageWithShell GetStorage(Lifetime lifetime);
}
public interface JetBrains.Common.Util.Shell.Remoting.Interfaces.IUseExternalStorage {
    public IDataSink`1<bool> UseExternalStorage { get; }
    public abstract virtual IDataSink`1<bool> get_UseExternalStorage();
}
[SettingsKeyAttribute("System.Reflection.Missing", "JetBrains.Common.Util.Shell.Resources.Strings", "RemoteStorageSettingDescription")]
public class JetBrains.Common.Util.Shell.Remoting.Settings.RemoteStorageSettings : object {
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.Common.Util.Shell.Resources.Strings", "UseLocalStorageSettingDescription")]
public bool AllowRemoteStorage;
}
[ShellComponentAttribute("16")]
public class JetBrains.Common.Util.Shell.Remoting.ShellComponents.ExternalStoragePool : object {
    private static int MaxLogFiles;
    private static ILogger ourLogger;
    private Lifetime myLifetime;
    private IExternalStorage myExternalStorage;
    private IRemotableReference`1<IComponentContainer> myExternalShell;
    private LifetimeDefinition myExternalStorageLifetime;
    private Dispatcher myDispatcher;
    private Queue`1<FileSystemPath> myExternalStorageLogFiles;
    public ExternalStoragePool(IUseExternalStorage settings, Lifetime lifetime, IThreading threading);
    private static ExternalStoragePool();
    protected virtual Type EnvironmentZone();
    private void OnCommTerminated(IRemoteCommunicator comm);
    private ExternalStorageLogFileOrigin BuildExternalStorageLogFileOrigin();
    private void InitStorage();
    private void DisposeStorage();
    public IEnumerable`1<FileSystemPath> GetAdditionalLogFiles();
    public sealed virtual ExternalStorageWithShell GetStorage(Lifetime lifetime);
    [CompilerGeneratedAttribute]
private void <.ctor>b__8_0(bool remote);
    [CompilerGeneratedAttribute]
private void <InitStorage>b__12_0(IRemoteCommunicator c);
}
[ShellComponentAttribute("18")]
public class JetBrains.Common.Util.Shell.Remoting.ShellComponents.UseExternalStorageSettingComponent : object {
    [CompilerGeneratedAttribute]
private IDataSink`1<bool> <UseExternalStorage>k__BackingField;
    public IDataSink`1<bool> UseExternalStorage { get; protected set; }
    public UseExternalStorageSettingComponent(Lifetime lifetime, ISettingsStore settings, IThreading threading);
    [CompilerGeneratedAttribute]
public sealed virtual IDataSink`1<bool> get_UseExternalStorage();
    [CompilerGeneratedAttribute]
protected void set_UseExternalStorage(IDataSink`1<bool> value);
}
[ZoneMarkerAttribute]
public class JetBrains.Common.Util.Shell.Remoting.ShellComponents.ZoneMarker : object {
}
[ZoneDefinitionAttribute]
public interface JetBrains.Common.Util.Shell.Remoting.Zones.ILocalSideZone {
}
[ZoneDefinitionAttribute]
public interface JetBrains.Common.Util.Shell.Remoting.Zones.IRemoteEnvironmentZone {
}
[ZoneDefinitionAttribute]
public interface JetBrains.Common.Util.Shell.Remoting.Zones.IRemoteSideZone {
}
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
public static class JetBrains.Common.Util.Shell.Resources.Strings : object {
    private static ILogger ourLog;
    private static Lazy`1<JetResourceManager> ourResourceManager;
    [EditorBrowsableAttribute("2")]
public static JetResourceManager ResourceManager { get; }
    public static string RemoteStorageSettingDescription { get; }
    public static string UseLocalStorageSettingDescription { get; }
    public static string SettingsFactory_StandaloneLayer_DisplayName { get; }
    private static Strings();
    public static JetResourceManager get_ResourceManager();
    public static string Choice(string format, Object[] args);
    public static string get_RemoteStorageSettingDescription();
    public static string get_UseLocalStorageSettingDescription();
    public static string get_SettingsFactory_StandaloneLayer_DisplayName();
}
[UsedImplicitlyAttribute]
[ShellComponentAttribute("16")]
public class JetBrains.Common.Util.Shell.SettingsFactory : object {
    private static ILogger ourLogger;
    private InternKeyPathComponent myInternKeyPathComponent;
    private IFileSystemTracker myFileSystemTracker;
    private ISettingsStore mySettingsStore;
    private ProductConfigurations myProductConfigurations;
    private IThreading myUIThreading;
    public SettingsFactory(InternKeyPathComponent internKeyPathComponent, IFileSystemTracker fileSystemTracker, ISettingsStore settingsStore, ProductConfigurations productConfigurations, IThreading uiThreading);
    private static SettingsFactory();
    public sealed virtual SettingsFileLiveWithMountPoints OpenLiveSettingsFile(FileSystemPath settingsFilePath, Lifetime lifetime, SettingsFactoryOptions options);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.Shell.SettingsFactoryEx : object {
    [ExtensionAttribute]
public static IndexKeysChanges ExtractIndexKeysChanges(SettingsStoreChangeArgs args, SettingsFileLive settingsFile);
    [ExtensionAttribute]
public static IContextBoundSettingsFileLive OpenLiveFile(ISettingsFactory settingsFactory, FileSystemPath settingsFilePath, Lifetime lifetime, SettingsFactoryOptions options);
    [ExtensionAttribute]
[ObsoleteAttribute("This method returns SettingsFileLive which works in OneWay mode. Changes from file will not be propagated to requested IProperty<>. That`s completely wrong usage of SettingsFileLive and works only because of bug. Use OpenLiveSettingsFile which works two way.")]
public static SettingsFileLive OpenLiveSettingsFileOneWayAggressiveFlushing(ISettingsFactory settingsFactory, FileSystemPath settingsFilePath, Lifetime lifetime);
    [ExtensionAttribute]
[ObsoleteAttribute("This method returns IContextBoundSettingsFileLive which works in OneWay mode. Changes from file will not be propagated to requested IProperty<>. That`s completely wrong usage of SettingsFileLive and works only because of bug. Use OpenLiveFile which works two way.")]
public static IContextBoundSettingsFileLive OpenLiveFileOneWayAggressiveFlushing(ISettingsFactory settingsFactory, FileSystemPath settingsFilePath, Lifetime lifetime);
}
[FlagsAttribute]
public enum JetBrains.Common.Util.Shell.SettingsFactoryOptions : Enum {
    public int value__;
    public static SettingsFactoryOptions Default;
    public static SettingsFactoryOptions ExcludeFromResetAllSettings;
    public static SettingsFactoryOptions AggressiveFlushingStrategy;
    [ObsoleteAttribute("OneWay behavior is unexpected for LiveSettings and later can cause errors to be thrown.")]
public static SettingsFactoryOptions DoNotRegisterMountPoint;
}
public class JetBrains.Common.Util.Shell.SettingsFileLive : LiveSettings {
    private IContextBoundSettingsFileLive mySettingsFile;
    public IProperty`1<FileSystemPath> SettingsFilePath { get; }
    public ISignal`1<SettingsStoreChangeArgs> Changed { get; }
    public SettingsFileLive(IContextBoundSettingsFileLive settingsFile);
    public sealed virtual IProperty`1<FileSystemPath> get_SettingsFilePath();
    public ISignal`1<SettingsStoreChangeArgs> get_Changed();
    public sealed virtual void Flush();
}
public class JetBrains.Common.Util.Shell.SettingsFileLiveWithMountPoints : SettingsFileLive {
    [NotNullAttribute]
public IContextBoundSettingsFileLive SettingsFile;
    public ILiveMountPointsInContext MountPoints;
    public SettingsFileLiveWithMountPoints(IContextBoundSettingsFileLive settingsFile, ILiveMountPointsInContext mountPoints);
}
public class JetBrains.Common.Util.Shell.ViewerHelpers.ActiveViewer : ValueType {
    [CompilerGeneratedAttribute]
private int <PID>k__BackingField;
    [CompilerGeneratedAttribute]
private ActiveViewerState <State>k__BackingField;
    public int PID { get; public set; }
    public ActiveViewerState State { get; public set; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_PID();
    [CompilerGeneratedAttribute]
public void set_PID(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ActiveViewerState get_State();
    [CompilerGeneratedAttribute]
public void set_State(ActiveViewerState value);
}
public enum JetBrains.Common.Util.Shell.ViewerHelpers.ActiveViewerState : Enum {
    public int value__;
    public static ActiveViewerState Normal;
    public static ActiveViewerState Processing;
    public static ActiveViewerState Starting;
}
[DerivedComponentsInstantiationRequirementAttribute("1")]
public interface JetBrains.Common.Util.Shell.ViewerHelpers.IIdeIndicator {
}
public interface JetBrains.Common.Util.Shell.ViewerHelpers.ILegacyRemoteInstanceManager {
    public IRemoteInstance ThisInstance { get; }
    public ICollection`1<IRemoteInstance> OtherInstances { get; }
    public abstract virtual void AddRemotePropertyProvider(Lifetime lifetime, ILegacyRemotePropertyProvider propertyProvider);
    public abstract virtual IRemoteInstance get_ThisInstance();
    public abstract virtual ICollection`1<IRemoteInstance> get_OtherInstances();
}
public interface JetBrains.Common.Util.Shell.ViewerHelpers.ILegacyRemotePropertyProvider {
    public string Key { get; }
    public abstract virtual string get_Key();
    public abstract virtual string GetValue(string propertyName);
}
public interface JetBrains.Common.Util.Shell.ViewerHelpers.ILegacyRemotePropertyRegistrator {
    public abstract virtual void Register(Lifetime lifetime, string key, Func`1<string> valueGetter);
}
public interface JetBrains.Common.Util.Shell.ViewerHelpers.IRemoteInstance {
    public int PID { get; }
    public bool IsIde { get; }
    public abstract virtual int get_PID();
    public abstract virtual bool get_IsIde();
    public abstract virtual string GetSingleValue(string property);
    public abstract virtual IReadOnlyCollection`1<string> GetMultipleValue(string property);
}
public interface JetBrains.Common.Util.Shell.ViewerHelpers.IRemoteInstanceManager {
    public ICollection`1<IRemoteInstance> AllInstances { get; }
    public IRemoteInstance LocalInstance { get; }
    public ICollection`1<IRemoteInstance> RemoteInstances { get; }
    public abstract virtual ICollection`1<IRemoteInstance> get_AllInstances();
    public abstract virtual IRemoteInstance get_LocalInstance();
    public abstract virtual ICollection`1<IRemoteInstance> get_RemoteInstances();
}
[DerivedComponentsInstantiationRequirementAttribute("1")]
public interface JetBrains.Common.Util.Shell.ViewerHelpers.IRemotePropertyRegistrator {
    public abstract virtual void RegisterProperty(Lifetime lifetime, string propertyName, IProperty`1<string> property);
}
[DerivedComponentsInstantiationRequirementAttribute("1")]
public interface JetBrains.Common.Util.Shell.ViewerHelpers.ISnapshotViewer {
    [CanBeNullAttribute]
public FileSystemPath Executable { get; }
    public double Priority { get; }
    public abstract virtual bool SnapshotSupported(FileSystemPath path);
    public abstract virtual void Open(FileSystemPath path, string presentableName, string reason);
    public abstract virtual FileSystemPath get_Executable();
    public abstract virtual ValueTuple`2<string, string> ExportSnapshotExtensionAndDescription(FileSystemPath path);
    public abstract virtual double get_Priority();
}
public class JetBrains.Common.Util.Shell.ViewerHelpers.MultipleSnapshotViewersTracker : object {
    private IRemoteInstanceManager myRemoteInstancesManager;
    private IOneToManyMap`3<FileSystemPath, Process, IList`1<Process>> mySnapshotToProcessMap;
    private TimeSpan myMaximumOpeningTime;
    private static ILogger Log;
    public MultipleSnapshotViewersTracker(IRemoteInstanceManager remoteInstancesManager);
    private static MultipleSnapshotViewersTracker();
    public IReadOnlyCollection`1<ActiveViewer> GetConflictingViewersBySnapshot(FileSystemPath path);
    private bool ProcessRecordExpired(Process p);
    private bool ViewerIsOpeningRightNow(FileSystemPath path, Int32& pid);
    public void RegisterStartedInstance(FileSystemPath path, Process process);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.Shell.ViewerHelpers.RemoteInstanceProperties : object {
    public static string ViewerKind;
    public static string SnapshotPath;
    public static string SnapshotPathLocked;
    public static string SnapshotIsLocked;
    [ExtensionAttribute]
public static IReadOnlyCollection`1<string> GetSnapshotPaths(IRemoteInstance remoteInstance);
    [ExtensionAttribute]
public static IReadOnlyCollection`1<string> GetLockedSnapshotPaths(IRemoteInstance remoteInstance);
    [ExtensionAttribute]
public static bool GetSnapshotIsLocked(IRemoteInstance remoteInstance);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.Shell.ViewerHelpers.RemoteInstancesManagerEx : object {
    private static ILogger Log;
    private static RemoteInstancesManagerEx();
    [ExtensionAttribute]
public static bool SnapshotAlreadyOpened(IRemoteInstanceManager remoteInstancesManager, FileSystemPath indexFile);
    [ExtensionAttribute]
public static IEnumerable`1<IRemoteInstance> InstancesWithSnapshot(IRemoteInstanceManager remoteInstancesManager, FileSystemPath indexFile);
    [IteratorStateMachineAttribute("JetBrains.Common.Util.Shell.ViewerHelpers.RemoteInstancesManagerEx/<InstancesWithSnapshotAndLocked>d__3")]
[ExtensionAttribute]
public static IEnumerable`1<ValueTuple`2<IRemoteInstance, bool>> InstancesWithSnapshotAndLocked(IRemoteInstanceManager remoteInstancesManager, FileSystemPath indexFile);
    [ExtensionAttribute]
public static bool TryFindInstanceWithSnapshot(IRemoteInstanceManager remoteInstancesManager, FileSystemPath indexFile, IRemoteInstance& instance);
    [ExtensionAttribute]
public static bool TryActivateExisting(IRemoteInstanceManager remoteInstancesManager, FileSystemPath path, Action`1<Action> scheduleActivation);
}
public abstract class JetBrains.Common.Util.Shell.ViewerHelpers.SnapshotViewerBase : object {
    public static string PresentableSnapshotNameOptionKey;
    public static string PresentableReasonOptionKey;
    public static string LauncherCommandLineNamespace;
    public static string LauncherCommandLineParameter;
    private FileSystemPath myCachedViewerAppPath;
    private ParamsForInheritedSnapshotViewerComponent myParamsForInheritedSnapshotViewer;
    private InstalledProductsDiscoveryComponent myProductsDiscovery;
    private string myInstallationHostName;
    private MultipleSnapshotViewersTracker myInstancesTracker;
    private IApplicationHost myApplicationHost;
    private static ILogger ourLog;
    private IComparer`1<UInt32> myBestCompatibilityComparer;
    [CompilerGeneratedAttribute]
private IRemoteInstanceManager <RemoteInstancesManager>k__BackingField;
    protected IRemoteInstanceManager RemoteInstancesManager { get; }
    protected string HostName { get; }
    public FileSystemPath Executable { get; }
    public double Priority { get; }
    protected SnapshotViewerBase(Lifetime lifetime, ParamsForInheritedSnapshotViewerComponent paramsForInheritedSnapshotViewer, InstalledProductsDiscoveryComponent productsDiscovery, string installationHostName, IRemoteInstanceManager remoteInstancesManager, IApplicationHost applicationHost);
    private static SnapshotViewerBase();
    [CompilerGeneratedAttribute]
protected IRemoteInstanceManager get_RemoteInstancesManager();
    protected abstract virtual string get_HostName();
    public sealed virtual bool SnapshotSupported(FileSystemPath path);
    protected abstract virtual bool SnapshotSupportedCore(FileSystemPath path);
    public sealed virtual void Open(FileSystemPath path, string presentableName, string reason);
    protected virtual IReadOnlyCollection`1<ActiveViewer> GetConflictingViewersBySnapshot(FileSystemPath path);
    private void StartNewViewerInstance(FileSystemPath path, string presentableName, string reason, FileSystemPath executable);
    [IteratorStateMachineAttribute("JetBrains.Common.Util.Shell.ViewerHelpers.SnapshotViewerBase/<BuildCommandLineParams>d__23")]
[LocalizableAttribute("False")]
private IEnumerable`1<string> BuildCommandLineParams(FileSystemPath path, string presentableName, string reason);
    public sealed virtual FileSystemPath get_Executable();
    public abstract virtual ValueTuple`2<string, string> ExportSnapshotExtensionAndDescription(FileSystemPath path);
    public abstract virtual double get_Priority();
    private FileSystemPath GetViewerPath();
    private FileSystemPath GetToolboxInstalledPathToExecutable(string hostName);
    private FileSystemPath GetInstalledPathToExecutable(string hostName);
    private FileSystemPath BuildPathToExecutable(FileSystemPath binaryFolder);
    [CompilerGeneratedAttribute]
private void <.ctor>b__15_0();
    [CompilerGeneratedAttribute]
private int <.ctor>b__15_1(UInt32 wave1, UInt32 wave2);
    [CompilerGeneratedAttribute]
private FileSystemPath <GetViewerPath>g__GetViewerPathCore|29_0();
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.Shell.ViewerHelpers.SnapshotViewerEx : object {
    [ExtensionAttribute]
public static bool IsAvailable(ISnapshotViewer viewer);
    public static RelativePath TryGetExecutableFileNameByHost(string host);
}
[ShellComponentAttribute("10")]
[ZoneMarkerAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class JetBrains.Common.Util.Shell.Viewers.InstanceManager.LegacyRemoteInstancesManager : object {
    private static BindingFlags Flags;
    private static string MonikerPrefix;
    private IRemoteInstance myInstance;
    private List`1<ILegacyRemotePropertyProvider> myPropertyProviders;
    private string myMonikerName;
    private static ILogger Log;
    public IRemoteInstance ThisInstance { get; }
    public ICollection`1<IRemoteInstance> OtherInstances { get; }
    public LegacyRemoteInstancesManager(Lifetime lifetime, IIdeIndicator isIde);
    private static LegacyRemoteInstancesManager();
    public sealed virtual void AddRemotePropertyProvider(Lifetime lifetime, ILegacyRemotePropertyProvider propertyProvider);
    public sealed virtual IRemoteInstance get_ThisInstance();
    public sealed virtual ICollection`1<IRemoteInstance> get_OtherInstances();
    [CompilerGeneratedAttribute]
private bool <get_OtherInstances>b__11_0(string name);
}
[ShellComponentAttribute("0")]
[ZoneMarkerAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class JetBrains.Common.Util.Shell.Viewers.InstanceManager.LegacyRemotePropertyRegistrator : object {
    private static ILogger Log;
    private ILegacyRemoteInstanceManager myRemoteInstancesManager;
    public LegacyRemotePropertyRegistrator(ILegacyRemoteInstanceManager remoteInstancesManager);
    private static LegacyRemotePropertyRegistrator();
    public sealed virtual void Register(Lifetime lifetime, string key, Func`1<string> valueGetter);
}
internal class JetBrains.Common.Util.Shell.Viewers.InstanceManager.ProcessRemoteInstancesData : object {
    [CompilerGeneratedAttribute]
private Dictionary`2<string, List`1<string>> <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsIde>k__BackingField;
    public Dictionary`2<string, List`1<string>> Properties { get; public set; }
    public bool IsIde { get; public set; }
    public ProcessRemoteInstancesData(bool isIde, IEnumerable`1<RegisteredProperty> properties);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, List`1<string>> get_Properties();
    [CompilerGeneratedAttribute]
public void set_Properties(Dictionary`2<string, List`1<string>> value);
    [CompilerGeneratedAttribute]
public bool get_IsIde();
    [CompilerGeneratedAttribute]
public void set_IsIde(bool value);
}
internal class JetBrains.Common.Util.Shell.Viewers.InstanceManager.RegisteredProperty : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private IProperty`1<string> <Property>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public string Name { get; public set; }
    public IProperty`1<string> Property { get; public set; }
    public RegisteredProperty(string Name, IProperty`1<string> Property);
    [CompilerGeneratedAttribute]
protected RegisteredProperty(RegisteredProperty original);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Name(string value);
    [CompilerGeneratedAttribute]
public IProperty`1<string> get_Property();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Property(IProperty`1<string> value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(RegisteredProperty left, RegisteredProperty right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(RegisteredProperty left, RegisteredProperty right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(RegisteredProperty other);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual RegisteredProperty <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(String& Name, IProperty`1& Property);
}
public class JetBrains.Common.Util.Shell.Viewers.InstanceManager.RemoteInstanceData : object {
    private IReadOnlyDictionary`2<string, IReadOnlyCollection`1<string>> myProperties;
    [CompilerGeneratedAttribute]
private int <PID>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsIde>k__BackingField;
    public int PID { get; }
    public bool IsIde { get; }
    public RemoteInstanceData(int pid, bool isIde, IReadOnlyDictionary`2<string, IReadOnlyCollection`1<string>> properties);
    [CompilerGeneratedAttribute]
public sealed virtual int get_PID();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsIde();
    public sealed virtual string GetSingleValue(string property);
    public sealed virtual IReadOnlyCollection`1<string> GetMultipleValue(string property);
}
[ShellComponentAttribute("16")]
public class JetBrains.Common.Util.Shell.Viewers.InstanceManager.RemoteInstanceManager : object {
    private static string MapName;
    private static Lazy`1<int> ourPid;
    private static ILogger ourLog;
    private bool myIsIde;
    private List`1<RegisteredProperty> myProperties;
    private ProcessSharedData`1<ProcessRemoteInstancesData> mySharedData;
    private ICollection`1<IRemoteInstance> JetBrains.Common.Util.Shell.ViewerHelpers.IRemoteInstanceManager.AllInstances { get; }
    private IRemoteInstance JetBrains.Common.Util.Shell.ViewerHelpers.IRemoteInstanceManager.LocalInstance { get; }
    private ICollection`1<IRemoteInstance> JetBrains.Common.Util.Shell.ViewerHelpers.IRemoteInstanceManager.RemoteInstances { get; }
    public RemoteInstanceManager(Lifetime lifetime, IIdeIndicator isIde);
    private static RemoteInstanceManager();
    private sealed virtual override ICollection`1<IRemoteInstance> JetBrains.Common.Util.Shell.ViewerHelpers.IRemoteInstanceManager.get_AllInstances();
    private sealed virtual override IRemoteInstance JetBrains.Common.Util.Shell.ViewerHelpers.IRemoteInstanceManager.get_LocalInstance();
    private sealed virtual override ICollection`1<IRemoteInstance> JetBrains.Common.Util.Shell.ViewerHelpers.IRemoteInstanceManager.get_RemoteInstances();
    private static ICollection`1<IRemoteInstance> Convert(IReadOnlyDictionary`2<int, ProcessRemoteInstancesData> data);
    private sealed virtual override void JetBrains.Common.Util.Shell.ViewerHelpers.IRemotePropertyRegistrator.RegisterProperty(Lifetime lifetime, string propertyName, IProperty`1<string> property);
}
[ShellComponentAttribute("16")]
public class JetBrains.Common.Util.Shell.Viewers.OpenSnapshotUtil : object {
    private IEnumerable`1<ISnapshotViewer> myViewers;
    public IEnumerable`1<FileSystemPath> Executables { get; }
    public OpenSnapshotUtil(IEnumerable`1<ISnapshotViewer> viewers);
    public bool CanOpenInExternalViewer(FileSystemPath path);
    public Result OpenInExternalViewer(FileSystemPath path, string presentableName, string reason, ISnapshotViewer specificViewer);
    public IEnumerable`1<FileSystemPath> get_Executables();
    public static bool AskForSwitchingToProcess();
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.Shell.Viewers.OpenSnapshotUtilEx : object {
    [ExtensionAttribute]
public static Result OpenInExternalViewerOrShowError(OpenSnapshotUtil openSnapshotUtil, FileSystemPath path, string presentableName, string reason, ISnapshotViewer specificViewer);
    public static void ShowErrorIfAny(Result result, FileSystemPath path);
    public static Result OpenInExternalViewer(IEnumerable`1<ISnapshotViewer> snapshotViewers, FileSystemPath path, string presentableName, string reason);
}
[ShellComponentAttribute("16")]
public class JetBrains.Common.Util.Shell.Viewers.ParamsForInheritedSnapshotViewerComponent : object {
    private IProductCommandLine myCommandLine;
    private ICollection`1<string> myParamsForPassToInheritor;
    public ICollection`1<string> ParamsForPassToInheritor { get; }
    public ParamsForInheritedSnapshotViewerComponent(IProductCommandLine commandLine);
    public ICollection`1<string> get_ParamsForPassToInheritor();
    [IteratorStateMachineAttribute("JetBrains.Common.Util.Shell.Viewers.ParamsForInheritedSnapshotViewerComponent/<GetParamsForInheritor>d__5")]
public IEnumerable`1<string> GetParamsForInheritor();
}
[ZoneMarkerAttribute]
public class JetBrains.Common.Util.Shell.Viewers.ZoneMarker : object {
}
[ZoneMarkerAttribute]
public class JetBrains.Common.Util.Shell.ZoneMarker : object {
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.Shell.Zoning.ZoneFilterHelpers : object {
    private static ILogger ourLogger;
    private static ZoneFilterHelpers();
    [ExtensionAttribute]
public static IPartCatalogSet FilterCatalogSetWithExtraZones(IPartCatalogSet inputCatalogueSet, Lifetime lifetime, ProductConfigurations configurations, string newCatalogSetId, Type[] zones);
    [LocalizableAttribute("False")]
public static string GetDump(IPartCatalogSet catalogSet, Type attributeType);
    public static ComponentContainer CreateChainedComponentContainerWithExtraZones(Lifetime lifetime, string id, FullPartCatalogSet catalogSet, IComponentContainer parentContainer, IValueResolver resolver, Type[] zones);
}
[ShellComponentAttribute("16")]
[DerivedComponentsInstantiationRequirementAttribute("0")]
public class JetBrains.SourceView.SourceModel.ShellComponents.SelectedSourceNodeProviderBase : object {
    public IDataProvider`1<TreeNodeInfo> CurrentNode { get; }
    public IDataProvider`1<Nullable`1<DateTime>> SnapshotTakenDate { get; }
    protected virtual IDataProvider`1<TreeNodeInfo> GetCurrentNodeProvider();
    protected virtual IDataProvider`1<Nullable`1<DateTime>> GetSnapshotTakenDateProvider();
    public sealed virtual IDataProvider`1<TreeNodeInfo> get_CurrentNode();
    public sealed virtual IDataProvider`1<Nullable`1<DateTime>> get_SnapshotTakenDate();
}
[ZoneMarkerAttribute]
public class JetBrains.SourceView.SourceModel.ShellComponents.ZoneMarker : object {
}
[ZoneDefinitionAttribute]
public interface JetBrains.SourceView.SourceServices.Interface.IDotCommonSourceViewZone {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
