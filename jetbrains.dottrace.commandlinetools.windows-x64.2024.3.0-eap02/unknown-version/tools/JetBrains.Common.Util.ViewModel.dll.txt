public class JetBrains.Common.Util.ViewModel.APM.AsyncLoaderViewModel : object {
    private IAsyncOperation myCurrentOperation;
    private IAsyncOperation myViewOperation;
    private object myContent;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    public IAsyncOperation Operation { get; }
    public bool IsProcessing { get; }
    public object Content { get; }
    public void SetContent(object content);
    [ObsoleteAttribute("Use overload with exceptionContentBuilder param instead")]
public void SetOperation(IAsyncOperation operation, Func`1<object> contentBuilder, Lifetime lifetime);
    public void SetOperation(IAsyncOperation operation, Func`1<object> contentBuilder, Func`2<Exception, object> exceptionContentBuilder, Lifetime lifetime);
    protected virtual void SetViewContent(object viewModel);
    protected virtual void SetViewOperation(IAsyncOperation operation);
    private void NotifyListeners();
    public sealed virtual IAsyncOperation get_Operation();
    public sealed virtual bool get_IsProcessing();
    public sealed virtual object get_Content();
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.ViewModel.APM.AsyncTaskExtensionsWPF : object {
    [ExtensionAttribute]
[NotNullAttribute]
public static IAsyncOperation`1<T> OnFinished(IAsyncOperation`1<T> task, Action`2<T, Exception> action);
    [ExtensionAttribute]
[NotNullAttribute]
public static IAsyncOperation OnFinished(IAsyncOperation task, Action`1<Exception> action);
    private static void OnFinishedRoutine(IAsyncOperation task, Action`1<Exception> action);
    [ExtensionAttribute]
[NotNullAttribute]
public static ITask`1<TResult> OnSuccessfullyFinished(ITask`1<TResult> task, Action`1<TResult> action);
    [ExtensionAttribute]
public static bool IsSuccessfullyFinished(ITask`1<TResult> task);
    [ExtensionAttribute]
[NotNullAttribute]
public static IAsyncOperation`1<TResult> OnSuccessfullyFinished(IAsyncOperation`1<TResult> asyncOperation, Action`1<TResult> action);
    [ExtensionAttribute]
[NotNullAttribute]
public static IAsyncOperation OnSuccessfullyFinished(IAsyncOperation task, Action action);
    private static void OnSuccessfullyFinishedRoutine(IAsyncOperation task, Action action);
    [ExtensionAttribute]
[NotNullAttribute]
public static ITask`1<T> OnFinishedSynchronized(ITask`1<T> task, Action`1<T> action, Action`1<Exception> catch, Lifetime lifetime);
    [ExtensionAttribute]
[NotNullAttribute]
public static IAsyncOperation`1<T> OnFinishedSynchronized(IAsyncOperation`1<T> task, Action`1<T> action, Action`1<Exception> catch, Lifetime lifetime);
    [ExtensionAttribute]
[NotNullAttribute]
public static T OnFinishedSynchronized(T task, Action action, Action`1<Exception> catch, Lifetime lifetime);
    private static void OnFinishedSynchronizedRoutine(IAsyncOperation task, Action action, Action`1<Exception> catch, Lifetime lifetime);
    [ExtensionAttribute]
public static ITask OnSuccessfullyFinishedSynchronized(ITask task, Action action, Lifetime lifetime);
    [ExtensionAttribute]
public static IAsyncOperation OnSuccessfullyFinishedSynchronized(IAsyncOperation task, Action action, Lifetime lifetime);
    [ExtensionAttribute]
public static ITask`1<T> OnSuccessfullyFinishedSynchronized(ITask`1<T> task, Lifetime lifetime, Action`1<T> action);
    [ExtensionAttribute]
public static ITask`1<T> OnSuccessfullyFinishedSynchronized(ITask`1<T> task, Action`1<T> action, Lifetime lifetime);
    [ExtensionAttribute]
public static IAsyncOperation`1<T> OnSuccessfullyFinishedSynchronized(IAsyncOperation`1<T> task, Action`1<T> action, Lifetime lifetime);
    private static void OnSuccessfullyFinishedSynchronizedRoutine(IAsyncOperation task, Action action, Lifetime lifetime);
    private static bool LifetimeIsFinished(Lifetime lifetime);
}
public interface JetBrains.Common.Util.ViewModel.APM.IAsyncLoaderViewModel {
    public IAsyncOperation Operation { get; }
    public bool IsProcessing { get; }
    public object Content { get; }
    public abstract virtual IAsyncOperation get_Operation();
    public abstract virtual bool get_IsProcessing();
    public abstract virtual object get_Content();
}
public class JetBrains.Common.Util.ViewModel.APM.NoFlickeringAsyncLoaderViewModel : AsyncLoaderViewModel {
    private int myMaxProgress;
    private DispatcherTimer myDispatcherTimer;
    private bool myLastItteration;
    private IAsyncOperation myLastSavedOperation;
    public NoFlickeringAsyncLoaderViewModel(int msDelay, int maxProgress);
    private void DispatcherTimerOnTick(object sender, EventArgs eventArgs);
    protected virtual void SetViewContent(object viewModel);
    protected virtual void SetViewOperation(IAsyncOperation operation);
    private void StopTimer();
    private void StartTimer(IAsyncOperation operation);
}
public class JetBrains.Common.Util.ViewModel.CheckedTreeView.CheckedTreeItemGroupViewModel : CheckedTreeItemViewModelBase {
    private bool myValidateSetValue;
    [CompilerGeneratedAttribute]
private List`1<CheckedTreeItemViewModelBase> <Children>k__BackingField;
    public List`1<CheckedTreeItemViewModelBase> Children { get; }
    protected IEnumerable`1<CheckedTreeItemViewModelBase> InternalChildren { get; }
    public CheckedTreeItemGroupViewModel(object content, bool validateSetValue);
    [CompilerGeneratedAttribute]
public List`1<CheckedTreeItemViewModelBase> get_Children();
    protected virtual IEnumerable`1<CheckedTreeItemViewModelBase> get_InternalChildren();
    public virtual void Initialize();
    internal virtual void SetIsCheckedCore(Nullable`1<bool> value);
    private Nullable`1<bool> GetExpectedState(IEnumerable`1<Nullable`1<bool>> childStates);
    [CompilerGeneratedAttribute]
private void <Initialize>b__7_1(Nullable`1<bool> v);
}
public class JetBrains.Common.Util.ViewModel.CheckedTreeView.CheckedTreeItemLeafViewModel : CheckedTreeItemViewModelBase {
    private Action`1<bool> mySetIsChecked;
    protected IEnumerable`1<CheckedTreeItemViewModelBase> InternalChildren { get; }
    public CheckedTreeItemLeafViewModel(object content, IDataProvider`1<bool> isChecked, Action`1<bool> setIsChecked, bool validateSetValue);
    protected virtual IEnumerable`1<CheckedTreeItemViewModelBase> get_InternalChildren();
    internal virtual void SetIsCheckedCore(Nullable`1<bool> value);
}
public abstract class JetBrains.Common.Util.ViewModel.CheckedTreeView.CheckedTreeItemViewModelBase : object {
    [CompilerGeneratedAttribute]
private bool <IsInitiallySelected>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Content>k__BackingField;
    [CompilerGeneratedAttribute]
private IWriteableDataNotifier`1<Nullable`1<bool>> <IsChecked>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsExpanded>k__BackingField;
    [CompilerGeneratedAttribute]
private IDataProvider`1<Nullable`1<bool>> <IsCheckedProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    public bool IsInitiallySelected { get; public set; }
    protected IEnumerable`1<CheckedTreeItemViewModelBase> InternalChildren { get; }
    private IEnumerable`1<ICheckedTreeItemViewModel> JetBrains.Common.Util.ViewModel.CheckedTreeView.ICheckedTreeItemViewModel.Children { get; }
    public object Content { get; }
    public IWriteableDataNotifier`1<Nullable`1<bool>> IsChecked { get; protected set; }
    public bool IsExpanded { get; public set; }
    public IDataProvider`1<Nullable`1<bool>> IsCheckedProvider { get; public set; }
    protected CheckedTreeItemViewModelBase(object content);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsInitiallySelected();
    [CompilerGeneratedAttribute]
public sealed virtual void set_IsInitiallySelected(bool value);
    protected abstract virtual IEnumerable`1<CheckedTreeItemViewModelBase> get_InternalChildren();
    private sealed virtual override IEnumerable`1<ICheckedTreeItemViewModel> JetBrains.Common.Util.ViewModel.CheckedTreeView.ICheckedTreeItemViewModel.get_Children();
    [CompilerGeneratedAttribute]
public sealed virtual object get_Content();
    [CompilerGeneratedAttribute]
public sealed virtual IWriteableDataNotifier`1<Nullable`1<bool>> get_IsChecked();
    [CompilerGeneratedAttribute]
protected void set_IsChecked(IWriteableDataNotifier`1<Nullable`1<bool>> value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsExpanded();
    [CompilerGeneratedAttribute]
public sealed virtual void set_IsExpanded(bool value);
    [CompilerGeneratedAttribute]
public IDataProvider`1<Nullable`1<bool>> get_IsCheckedProvider();
    [CompilerGeneratedAttribute]
public void set_IsCheckedProvider(IDataProvider`1<Nullable`1<bool>> value);
    public virtual void Initialize();
    internal abstract virtual void SetIsCheckedCore(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
}
public class JetBrains.Common.Util.ViewModel.CheckedTreeView.CheckedTreeViewModel : object {
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    [CompilerGeneratedAttribute]
private IList`1<ICheckedTreeItemViewModel> <Root>k__BackingField;
    public IList`1<ICheckedTreeItemViewModel> Root { get; }
    public CheckedTreeViewModel(CheckedTreeItemGroupViewModel root);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public IList`1<ICheckedTreeItemViewModel> get_Root();
}
public interface JetBrains.Common.Util.ViewModel.CheckedTreeView.ICheckedTreeItemViewModel {
    public bool IsInitiallySelected { get; public set; }
    public IEnumerable`1<ICheckedTreeItemViewModel> Children { get; }
    public object Content { get; }
    public IWriteableDataNotifier`1<Nullable`1<bool>> IsChecked { get; }
    public bool IsExpanded { get; public set; }
    public abstract virtual bool get_IsInitiallySelected();
    public abstract virtual void set_IsInitiallySelected(bool value);
    public abstract virtual IEnumerable`1<ICheckedTreeItemViewModel> get_Children();
    public abstract virtual object get_Content();
    public abstract virtual IWriteableDataNotifier`1<Nullable`1<bool>> get_IsChecked();
    public abstract virtual bool get_IsExpanded();
    public abstract virtual void set_IsExpanded(bool value);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.ViewModel.ColorExtensions : object {
    [ExtensionAttribute]
public static int ToBgra32(Color color);
    [ExtensionAttribute]
public static int ConvertColor(Color color);
    [ExtensionAttribute]
public static Color SetAlpha(Color color, double alpha);
    [ExtensionAttribute]
[ObsoleteAttribute("Do not use HSB colorspace, it's inadequate. Look for LAB or HumanPerceptibleColor.")]
public static Color AdjustBrightness(Color color, double brightnessFactor);
}
public abstract class JetBrains.Common.Util.ViewModel.Commands.AbstractCommand : object {
    private IStaThreadDispatcher myStaDispatcher;
    private Action`1<object> myExecute;
    private bool myCanExecute;
    [CompilerGeneratedAttribute]
private EventHandler CanExecuteChanged;
    unknown bool CanExecute {public set; }
    protected AbstractCommand(IStaThreadDispatcher staDispatcher, Action`1<object> execute, bool canExecute);
    protected AbstractCommand(Action`1<object> execute, bool canExecute);
    public void set_CanExecute(bool value);
    private sealed virtual override bool System.Windows.Input.ICommand.CanExecute(object parameter);
    private sealed virtual override void System.Windows.Input.ICommand.Execute(object parameter);
    [CompilerGeneratedAttribute]
public sealed virtual void add_CanExecuteChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_CanExecuteChanged(EventHandler value);
    private void SetCanExecute(bool value);
}
public abstract class JetBrains.Common.Util.ViewModel.Commands.Command`1 : CommandMixin {
    public abstract virtual void Execute(T parameter);
    public abstract virtual bool CanExecute(T parameter);
    private sealed virtual override void System.Windows.Input.ICommand.Execute(object parameter);
    private sealed virtual override bool System.Windows.Input.ICommand.CanExecute(object parameter);
}
public class JetBrains.Common.Util.ViewModel.Commands.Command2 : AbstractCommand {
    public Command2(IStaThreadDispatcher staDispatcher, Action execute, bool canExecute);
    public Command2(Action`1<object> execute, bool canExecute);
    public Command2(Action execute, bool canExecute);
    public Command2(Lifetime lifetime, Func`1<Task> executeAsync, bool canExecute);
}
public class JetBrains.Common.Util.ViewModel.Commands.Command2`1 : AbstractCommand {
    public Command2`1(IStaThreadDispatcher staDispatcher, Action`1<T> execute, bool canExecute);
    public Command2`1(Action`1<T> execute, bool canExecute);
    public Command2`1(Lifetime lifetime, Func`2<T, Task> executeAsync, bool canExecute);
    private sealed virtual override void JetBrains.Common.Util.ViewModel.Commands.ICommand<T>.Execute(T param);
    private sealed virtual override bool JetBrains.Common.Util.ViewModel.Commands.ICommand<T>.CanExecute(T param);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.ViewModel.Commands.CommandExtension : object {
    [ExtensionAttribute]
public static ICommand CreateFlowing(ICommand`1<T> source, Lifetime lifetime, Func`1<T> getParameter);
}
public abstract class JetBrains.Common.Util.ViewModel.Commands.CommandMixin : object {
    private bool myFreeThreaded;
    private JetDispatcher myUIDispatcher;
    private IStaThreadDispatcher myStaDispatcher;
    [CompilerGeneratedAttribute]
private EventHandler CanExecuteChanged;
    protected CommandMixin(bool freeThreaded, JetDispatcher uiDispatcher);
    [CompilerGeneratedAttribute]
public sealed virtual void add_CanExecuteChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_CanExecuteChanged(EventHandler value);
    public void RaiseCanExecuteChanged();
    protected void RaiseCanExecuteChangedOnCorrectThread();
    private bool CheckAccess();
    private void BeginInvoke(Action action);
}
public class JetBrains.Common.Util.ViewModel.Commands.DelegateCommand : CommandMixin {
    private Action`1<object> myExecute;
    private Predicate`1<object> myCanExecute;
    public DelegateCommand(Action`1<object> execute, Predicate`1<object> canExecute);
    public DelegateCommand(Action execute, Func`1<bool> canExecute);
    public sealed virtual bool CanExecute(object parameter);
    public sealed virtual void Execute(object parameter);
    public void RaiseCanExecuteChanged();
}
public class JetBrains.Common.Util.ViewModel.Commands.DelegateCommand`1 : Command`1<T> {
    private Action`1<T> myExecute;
    private Predicate`1<T> myCanExecute;
    public DelegateCommand`1(Action`1<T> execute, Predicate`1<T> canExecute);
    public virtual void Execute(T parameter);
    public virtual bool CanExecute(T parameter);
}
public interface JetBrains.Common.Util.ViewModel.Commands.ICommand`1 {
    public abstract virtual void Execute(T param);
    public abstract virtual bool CanExecute(T param);
}
public class JetBrains.Common.Util.ViewModel.Commands.SimpleAsyncCommand : SimpleCommand {
    public SimpleAsyncCommand(Func`1<Task> executeAsync, bool canExecute, bool freeThreaded);
}
public class JetBrains.Common.Util.ViewModel.Commands.SimpleCommand : CommandMixin {
    private Action`1<object> myExecute;
    private bool myCanExecute;
    private bool CanExecute { get; public set; }
    public SimpleCommand(Action execute, bool canExecute, bool freeThreaded, JetDispatcher uiDispatcher);
    public SimpleCommand(Action`1<object> execute, bool canExecute, bool freeThreaded, JetDispatcher uiDispatcher);
    private sealed virtual override void System.Windows.Input.ICommand.Execute(object parameter);
    private sealed virtual override bool System.Windows.Input.ICommand.CanExecute(object parameter);
    private bool get_CanExecute();
    public void set_CanExecute(bool value);
}
public class JetBrains.Common.Util.ViewModel.Commands.SimpleCommand`1 : CommandMixin {
    private ICommand`1<T> myThis;
    private Action`1<T> myAction;
    private bool myCanExecute;
    private bool CanExecute { get; public set; }
    public SimpleCommand`1(Action`1<T> action, bool canExecute);
    private sealed virtual override void JetBrains.Common.Util.ViewModel.Commands.ICommand<T>.Execute(T param);
    private sealed virtual override bool JetBrains.Common.Util.ViewModel.Commands.ICommand<T>.CanExecute(T param);
    private sealed virtual override void System.Windows.Input.ICommand.Execute(object parameter);
    private sealed virtual override bool System.Windows.Input.ICommand.CanExecute(object parameter);
    private bool get_CanExecute();
    public void set_CanExecute(bool value);
}
public class JetBrains.Common.Util.ViewModel.CommandWithVisibilityVM : object {
    private ICommand myCommand;
    private IProperty`1<bool> myIsVisible;
    public ICommand Command { get; }
    public IProperty`1<bool> IsVisible { get; }
    public CommandWithVisibilityVM(ICommand command, IProperty`1<bool> isVisible);
    public ICommand get_Command();
    public IProperty`1<bool> get_IsVisible();
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Common.Util.ViewModel.CompositeObservableCollection`1 : object {
    private object mySyncRoot;
    private IEnumerable`1[] myCollections;
    private ImplStategyBase<T> myImplStategy;
    [CompilerGeneratedAttribute]
private NotifyCollectionChangedEventHandler CollectionChanged;
    public int Count { get; }
    public object SyncRoot { get; }
    public bool IsSynchronized { get; }
    public object Item { get; public set; }
    public bool IsReadOnly { get; }
    public bool IsFixedSize { get; }
    private CompositeObservableCollection`1(ImplStategyBase<T> implStategy, IEnumerable`1[] collections);
    public CompositeObservableCollection`1(IList`1[] collections);
    public CompositeObservableCollection`1(IReadOnlyList`1[] collections);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private void OnCollectionChanged(object sender, NotifyCollectionChangedEventArgs e);
    [CompilerGeneratedAttribute]
public sealed virtual void add_CollectionChanged(NotifyCollectionChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_CollectionChanged(NotifyCollectionChangedEventHandler value);
    public sealed virtual int get_Count();
    public sealed virtual object get_SyncRoot();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual bool Contains(object value);
    public sealed virtual int IndexOf(object value);
    public sealed virtual object get_Item(int index);
    public sealed virtual void set_Item(int index, object value);
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual void CopyTo(Array array, int index);
    public sealed virtual int Add(object value);
    public sealed virtual void Clear();
    public sealed virtual void Insert(int index, object value);
    public sealed virtual void Remove(object value);
    public sealed virtual void RemoveAt(int index);
    [CompilerGeneratedAttribute]
private int <get_Count>b__16_0(IEnumerable`1<T> c);
    [CompilerGeneratedAttribute]
private bool <get_IsSynchronized>b__20_0(IEnumerable`1<T> c);
}
public static class JetBrains.Common.Util.ViewModel.DpiUtils : object {
    private static double DefaultDpi;
    public static void GetDpi(Visual visual, Double& dpiX, Double& dpiY);
}
public interface JetBrains.Common.Util.ViewModel.DragAndDrop.IDragable {
    public Type DataType { get; }
    public abstract virtual Type get_DataType();
    public abstract virtual void NotifyDataDropped();
}
public interface JetBrains.Common.Util.ViewModel.DragAndDrop.IDropable {
    [NotNullAttribute]
public Type AcceptableDataType { get; }
    public abstract virtual Type get_AcceptableDataType();
    public abstract virtual void Drop(object dragable);
}
public class JetBrains.Common.Util.ViewModel.EditableStringVM : object {
    private IProperty`1<bool> myIsEditing;
    private IProperty`1<string> myStoredText;
    private IProperty`1<string> myText;
    private ICommand mySaveChanges;
    private ICommand myDiscardChanges;
    private bool myCommandExecuting;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    public IProperty`1<bool> IsEditing { get; }
    public IProperty`1<string> Text { get; }
    public ICommand SaveChanges { get; }
    public ICommand DiscardChanges { get; }
    public EditableStringVM(IProperty`1<string> text, Func`1<bool> isReadonly, Lifetime lifetime);
    private void ExecuteSaveChanges();
    private void ExecuteDiscardChanges();
    private void IsEditingChanged(PropertyChangedEventArgs`1<bool> args);
    public IProperty`1<bool> get_IsEditing();
    public IProperty`1<string> get_Text();
    public ICommand get_SaveChanges();
    public ICommand get_DiscardChanges();
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
private void <ExecuteSaveChanges>b__7_0();
    [CompilerGeneratedAttribute]
private void <ExecuteDiscardChanges>b__8_0();
}
public static class JetBrains.Common.Util.ViewModel.Handle`1 : object {
    public static PropertyChangedEventHandler PropertyChanging(Expression`1<Func`1<T>> property, Action`2<TSender, T> handler);
    public static PropertyChangedEventHandler PropertyChanging(Expression`1<Func`1<T>> property, Action`1<TSender> handler);
}
public enum JetBrains.Common.Util.ViewModel.HeaderType : Enum {
    public int value__;
    public static HeaderType Bar;
    public static HeaderType Transparent;
    public static HeaderType Overlapped;
}
public class JetBrains.Common.Util.ViewModel.HeightFactor : ValueType {
    public double Value;
    public static HeightFactor None;
    public bool IsNone { get; }
    public HeightFactor(double value);
    private static HeightFactor();
    public bool Equals(HeightFactor other);
    public static bool op_Equality(HeightFactor left, HeightFactor right);
    public static bool op_Inequality(HeightFactor left, HeightFactor right);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public bool get_IsNone();
}
public class JetBrains.Common.Util.ViewModel.Helpers.CancelActionViewModel : object {
    [CompilerGeneratedAttribute]
private object <Content>k__BackingField;
    [CompilerGeneratedAttribute]
private ICommand <CancelCommand>k__BackingField;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    public object Content { get; }
    public ICommand CancelCommand { get; }
    public CancelActionViewModel(object content, Action cancelAction);
    [CompilerGeneratedAttribute]
public object get_Content();
    [CompilerGeneratedAttribute]
public ICommand get_CancelCommand();
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.ViewModel.Helpers.CommonViewModelHelpers : object {
    [ExtensionAttribute]
public static FixedSizeIconViewModel ToFixedSizeIcon(IconId icon, int size);
    [ExtensionAttribute]
public static FixedSizeIconWithTooltipViewModel ToFixedSizeIconWithTooltip(IconId icon, string tooltipText, int size);
    [ExtensionAttribute]
public static HumanReadableDateAndTimeViewModel ToHumanReadable(DateTime datetime);
    [ExtensionAttribute]
public static HumanReadableFileSizeViewModel ToHumanReadableSize(long size);
    [ExtensionAttribute]
public static HumanReadableTimeSpanViewModel ToHumanReadable(TimeSpan timeSpan);
    [ExtensionAttribute]
public static DoubleClickAndEnterActionViewModel AddDoubleClickAndEnterAction(INotifyPropertyChanged viewModel);
    [ExtensionAttribute]
public static CancelActionViewModel AddCancelAction(INotifyPropertyChanged viewModel, Action cancelAction);
    [ExtensionAttribute]
public static ContextMenuViewModel AddContextMenu(INotifyPropertyChanged viewModel);
}
public class JetBrains.Common.Util.ViewModel.Helpers.ContextMenuViewModel : object {
    [CompilerGeneratedAttribute]
private object <Content>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ContextMenuActionGroupType>k__BackingField;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    public object Content { get; }
    public Type ContextMenuActionGroupType { get; }
    public ContextMenuViewModel(object content, Type contextMenuActionGroupType);
    [CompilerGeneratedAttribute]
public object get_Content();
    [CompilerGeneratedAttribute]
public Type get_ContextMenuActionGroupType();
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
}
public class JetBrains.Common.Util.ViewModel.Helpers.DoubleClickAndEnterActionViewModel : object {
    [CompilerGeneratedAttribute]
private object <Content>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <DoubleClickAndEnterActionType>k__BackingField;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    public object Content { get; }
    public Type DoubleClickAndEnterActionType { get; }
    public DoubleClickAndEnterActionViewModel(object content, Type doubleClickAndEnterActionType);
    [CompilerGeneratedAttribute]
public object get_Content();
    [CompilerGeneratedAttribute]
public Type get_DoubleClickAndEnterActionType();
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
}
public class JetBrains.Common.Util.ViewModel.Helpers.FixedSizeIconViewModel : object {
    [CompilerGeneratedAttribute]
private IconId <Icon>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Size>k__BackingField;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    public IconId Icon { get; }
    public int Size { get; }
    public FixedSizeIconViewModel(IconId icon, int size);
    [CompilerGeneratedAttribute]
public IconId get_Icon();
    [CompilerGeneratedAttribute]
public int get_Size();
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
}
public class JetBrains.Common.Util.ViewModel.Helpers.FixedSizeIconWithTooltipViewModel : object {
    [CompilerGeneratedAttribute]
private IconId <Icon>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Size>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TooltipText>k__BackingField;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    public IconId Icon { get; }
    public int Size { get; }
    public string TooltipText { get; }
    public FixedSizeIconWithTooltipViewModel(IconId icon, int size, string tooltipText);
    [CompilerGeneratedAttribute]
public IconId get_Icon();
    [CompilerGeneratedAttribute]
public int get_Size();
    [CompilerGeneratedAttribute]
public string get_TooltipText();
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
}
public class JetBrains.Common.Util.ViewModel.Helpers.HumanReadableDateAndTimeViewModel : object {
    private DateTime myDateTime;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    [ObsoleteAttribute("Vm mustn't expose data layer entities")]
public DateTime RawDateTime { get; }
    public HumanReadableDateAndTimeViewModel(DateTime dateTime);
    public DateTime get_RawDateTime();
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(HumanReadableDateAndTimeViewModel other);
    public virtual string ToString();
    public sealed virtual int CompareTo(HumanReadableDateAndTimeViewModel other);
    public sealed virtual int CompareTo(object obj);
}
public class JetBrains.Common.Util.ViewModel.Helpers.HumanReadableFileSizeViewModel : object {
    private long mySize;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    public HumanReadableFileSizeViewModel(long size);
    public sealed virtual bool Equals(HumanReadableFileSizeViewModel other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    public virtual string ToString();
    public sealed virtual int CompareTo(HumanReadableFileSizeViewModel other);
    public sealed virtual int CompareTo(object obj);
}
public class JetBrains.Common.Util.ViewModel.Helpers.HumanReadableTimeSpanViewModel : object {
    private TimeSpan myTimeSpan;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    public HumanReadableTimeSpanViewModel(TimeSpan timeSpan);
    public sealed virtual bool Equals(HumanReadableTimeSpanViewModel other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    public virtual string ToString();
    public sealed virtual int CompareTo(HumanReadableTimeSpanViewModel other);
    public sealed virtual int CompareTo(object obj);
}
public interface JetBrains.Common.Util.ViewModel.IActivatableEntity {
    public bool IsActive { get; public set; }
    public abstract virtual bool get_IsActive();
    public abstract virtual void set_IsActive(bool value);
}
public class JetBrains.Common.Util.ViewModel.IciclePlot.IcicleFolderDescriptor : ValueType {
    [CompilerGeneratedAttribute]
private ulong <Left>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <Right>k__BackingField;
    public ulong Left { get; }
    public ulong Right { get; }
    public IcicleFolderDescriptor(ulong left, ulong right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ulong get_Left();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ulong get_Right();
}
[TypeConverterAttribute("JetBrains.Common.Util.ViewModel.IciclePlot.IcicleNodeDescriptorTypeConverter")]
public class JetBrains.Common.Util.ViewModel.IciclePlot.IcicleNodeDescriptor : ValueType {
    public static IcicleNodeDescriptor Invalid;
    [CompilerGeneratedAttribute]
private ulong <Left>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <Right>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Level>k__BackingField;
    public ulong Left { get; }
    public ulong Right { get; }
    public int Level { get; }
    public IcicleNodeDescriptor(ulong left, ulong right, int level);
    private static IcicleNodeDescriptor();
    public static bool op_Equality(IcicleNodeDescriptor l, IcicleNodeDescriptor r);
    public static bool op_Inequality(IcicleNodeDescriptor l, IcicleNodeDescriptor r);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ulong get_Left();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ulong get_Right();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Level();
    private bool Equals(IcicleNodeDescriptor other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class JetBrains.Common.Util.ViewModel.IciclePlot.IcicleNodeDescriptorTypeConverter : TypeConverter {
    private static char Separator;
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public enum JetBrains.Common.Util.ViewModel.IciclePlot.IcicleNodeKind : Enum {
    public int value__;
    public static IcicleNodeKind Simple;
    public static IcicleNodeKind Composite;
    public static IcicleNodeKind Folded;
}
public interface JetBrains.Common.Util.ViewModel.IciclePlot.IIcicleColorScheme {
    public abstract virtual JetRgbaColor GetNodeColor(IIciclePlotNode iciclePlotNode, ulong totalSize);
}
public interface JetBrains.Common.Util.ViewModel.IciclePlot.IIciclePlotNode {
    public IcicleNodeKind Kind { get; }
    public ulong Payload { get; }
    public ulong Coord { get; }
    public object Content { get; }
    public int Level { get; }
    public IReadOnlyCollection`1<object> AggregatedNodes { get; }
    public abstract virtual IcicleNodeKind get_Kind();
    public abstract virtual ulong get_Payload();
    public abstract virtual ulong get_Coord();
    public abstract virtual object get_Content();
    public abstract virtual int get_Level();
    public abstract virtual IReadOnlyCollection`1<object> get_AggregatedNodes();
}
public interface JetBrains.Common.Util.ViewModel.IciclePlot.IIcicleViewModel {
    public IDataProvider`1<ITreeStructureProvider> TreeStructureProvider { get; }
    public IProperty`1<IIciclePlotNode> SelectedItemProperty { get; }
    public IProperty`1<IcicleNodeDescriptor> DesiredSelectedNodeProperty { get; }
    public IProperty`1<IcicleNodeDescriptor> ViewFocusNodeProperty { get; }
    unknown IEnumerable`1<IIciclePlotNode> SelectedStackTrace {public set; }
    public IExclusiveTaskScheduler TaskScheduler { get; }
    public IIcicleColorScheme ColorScheme { get; }
    public abstract virtual IDataProvider`1<ITreeStructureProvider> get_TreeStructureProvider();
    public abstract virtual IProperty`1<IIciclePlotNode> get_SelectedItemProperty();
    public abstract virtual IProperty`1<IcicleNodeDescriptor> get_DesiredSelectedNodeProperty();
    public abstract virtual IProperty`1<IcicleNodeDescriptor> get_ViewFocusNodeProperty();
    public abstract virtual void set_SelectedStackTrace(IEnumerable`1<IIciclePlotNode> value);
    public abstract virtual IExclusiveTaskScheduler get_TaskScheduler();
    public abstract virtual IIcicleColorScheme get_ColorScheme();
}
public interface JetBrains.Common.Util.ViewModel.IFocusProvider {
    [CompilerGeneratedAttribute]
public abstract virtual void add_Focused(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Focused(EventHandler value);
}
public interface JetBrains.Common.Util.ViewModel.IIdentifiable {
    public ulong Id { get; }
    public abstract virtual ulong get_Id();
}
public interface JetBrains.Common.Util.ViewModel.IItemExpandedNotifier {
    [CompilerGeneratedAttribute]
public abstract virtual void add_ItemExpanded(EventHandler`1<ItemExpandedArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ItemExpanded(EventHandler`1<ItemExpandedArgs> value);
}
public interface JetBrains.Common.Util.ViewModel.IRequireSynchronizedInitialize {
    public abstract virtual void Initialize();
}
public interface JetBrains.Common.Util.ViewModel.IScrollToItemNotifier {
    [CompilerGeneratedAttribute]
public abstract virtual void add_ScrollToChanged(EventHandler`1<ScrollToItemArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ScrollToChanged(EventHandler`1<ScrollToItemArgs> value);
}
public class JetBrains.Common.Util.ViewModel.ItemExpandedArgs : EventArgs {
    [CompilerGeneratedAttribute]
private object <Item>k__BackingField;
    public object Item { get; }
    public ItemExpandedArgs(object item);
    [CompilerGeneratedAttribute]
public object get_Item();
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Common.Util.ViewModel.ListChangingNotifier`1 : object {
    public static ListChangingNotifier`1<T> Empty;
    private IList`1<T> myList;
    [CompilerGeneratedAttribute]
private NotifyCollectionChangedEventHandler CollectionChanged;
    public int Count { get; }
    public T Item { get; }
    public ListChangingNotifier`1(IList`1<T> list);
    private static ListChangingNotifier`1();
    public void Clear();
    public void ChangeCollection(Action`1<IList`1<T>> action);
    public void ChangeCollection(Action`1<IList`1<T>> action, NotifyCollectionChangedEventArgs changedEventArgs);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [CompilerGeneratedAttribute]
public sealed virtual void add_CollectionChanged(NotifyCollectionChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_CollectionChanged(NotifyCollectionChangedEventHandler value);
    public sealed virtual int get_Count();
    public sealed virtual T get_Item(int index);
    public sealed virtual int IndexOf(T item);
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Common.Util.ViewModel.ListWrapper`1 : object {
    private IList`1<T> mySource;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public T Item { get; public set; }
    public ListWrapper`1(IList`1<T> source);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual bool Remove(T item);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual int IndexOf(T item);
    public sealed virtual void Insert(int index, T item);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
}
public interface JetBrains.Common.Util.ViewModel.ModalWindows.IEditableWindowViewModel {
    public ICommand CancelCommand { get; }
    public ICommand SaveCommand { get; }
    public abstract virtual ICommand get_CancelCommand();
    public abstract virtual ICommand get_SaveCommand();
}
public interface JetBrains.Common.Util.ViewModel.ModalWindows.IModalDialogController {
    public abstract virtual void ShowDialog(IModalWindowViewModel viewModel, ControlWrapper sender);
    public abstract virtual void ShowDialog(IModalWindowViewModel windowController, object viewModel, ControlWrapper sender);
    public abstract virtual Task ShowDialogAsync(IModalWindowViewModel viewModel, ControlWrapper sender);
    public abstract virtual Task ShowDialogAsync(IModalWindowViewModel windowController, object viewModel, ControlWrapper sender);
}
public interface JetBrains.Common.Util.ViewModel.ModalWindows.IModalWindowViewModel {
    public WindowLocation WindowStartupLocation { get; }
    public WindowStoreType WindowPositionStoreLogic { get; }
    public WindowState WindowState { get; public set; }
    public SizeToContent SizeToContent { get; }
    public double DefaultWidth { get; }
    public double DefaultHeight { get; }
    public string Title { get; }
    public bool Topmost { get; }
    public bool ShowInTaskbar { get; }
    public bool AdjustMinSize { get; }
    public bool DisableResize { get; }
    public abstract virtual bool Closing();
    public abstract virtual WindowLocation get_WindowStartupLocation();
    public abstract virtual WindowStoreType get_WindowPositionStoreLogic();
    public abstract virtual WindowState get_WindowState();
    public abstract virtual void set_WindowState(WindowState value);
    public abstract virtual SizeToContent get_SizeToContent();
    public abstract virtual double get_DefaultWidth();
    public abstract virtual double get_DefaultHeight();
    public abstract virtual string get_Title();
    [CompilerGeneratedAttribute]
public abstract virtual void add_CloseRequest(EventHandler`1<EventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_CloseRequest(EventHandler`1<EventArgs> value);
    public abstract virtual bool get_Topmost();
    public abstract virtual bool get_ShowInTaskbar();
    public abstract virtual bool get_AdjustMinSize();
    public abstract virtual bool get_DisableResize();
}
public abstract class JetBrains.Common.Util.ViewModel.ModalWindows.Impl.CloseOnlyWindowViewModel : WindowViewModelBase {
    private DelegateCommand myCloseCommand;
    public ICommand CloseCommand { get; }
    public ICommand get_CloseCommand();
}
public abstract class JetBrains.Common.Util.ViewModel.ModalWindows.Impl.EditWindowViewModel`1 : WindowViewModelBase {
    private DelegateCommand mySaveCommand;
    private DelegateCommand myCancelCommand;
    private T myOriginal;
    private bool myEditState;
    [CompilerGeneratedAttribute]
private IObservable`1<Unit> <CloseRequested>k__BackingField;
    public ICommand CancelCommand { get; }
    public ICommand SaveCommand { get; }
    public IObservable`1<Unit> CloseRequested { get; }
    protected EditWindowViewModel`1(T itemToEdit);
    protected void StartEdit(T itemToEdit);
    public sealed virtual ICommand get_CancelCommand();
    public sealed virtual ICommand get_SaveCommand();
    [CompilerGeneratedAttribute]
public IObservable`1<Unit> get_CloseRequested();
    protected abstract virtual bool CanSave();
    protected virtual void RaiseCanExecuteChanged();
    protected abstract virtual void CopyToSource(T original);
    private void EndEdit();
    private void CancelEdit();
    protected void AssertInEditState();
    [CompilerGeneratedAttribute]
private void <.ctor>b__4_0(EventHandler`1<EventArgs> handler);
    [CompilerGeneratedAttribute]
private void <.ctor>b__4_1(EventHandler`1<EventArgs> handler);
}
public abstract class JetBrains.Common.Util.ViewModel.ModalWindows.Impl.WindowViewModelBase : object {
    private string myTitle;
    private bool myTopmost;
    private bool myShowInTaskbar;
    private WindowState myWindowState;
    [CompilerGeneratedAttribute]
private EventHandler`1<EventArgs> CloseRequest;
    [CompilerGeneratedAttribute]
private bool <DisableResize>k__BackingField;
    [CompilerGeneratedAttribute]
private SizeToContent <SizeToContent>k__BackingField;
    [CompilerGeneratedAttribute]
private double <DefaultWidth>k__BackingField;
    [CompilerGeneratedAttribute]
private double <DefaultHeight>k__BackingField;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    public bool Topmost { get; public set; }
    public WindowLocation WindowStartupLocation { get; }
    public WindowStoreType WindowPositionStoreLogic { get; }
    public bool ShowInTaskbar { get; public set; }
    public bool AdjustMinSize { get; }
    public bool DisableResize { get; public set; }
    public WindowState WindowState { get; public set; }
    public SizeToContent SizeToContent { get; protected set; }
    public double DefaultWidth { get; protected set; }
    public double DefaultHeight { get; protected set; }
    public string Title { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual void add_CloseRequest(EventHandler`1<EventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_CloseRequest(EventHandler`1<EventArgs> value);
    public sealed virtual bool get_Topmost();
    public void set_Topmost(bool value);
    public abstract virtual WindowLocation get_WindowStartupLocation();
    public abstract virtual WindowStoreType get_WindowPositionStoreLogic();
    public sealed virtual bool get_ShowInTaskbar();
    public void set_ShowInTaskbar(bool value);
    public virtual bool get_AdjustMinSize();
    [CompilerGeneratedAttribute]
public virtual bool get_DisableResize();
    [CompilerGeneratedAttribute]
public virtual void set_DisableResize(bool value);
    public sealed virtual WindowState get_WindowState();
    public sealed virtual void set_WindowState(WindowState value);
    [CompilerGeneratedAttribute]
public sealed virtual SizeToContent get_SizeToContent();
    [CompilerGeneratedAttribute]
protected void set_SizeToContent(SizeToContent value);
    [CompilerGeneratedAttribute]
public sealed virtual double get_DefaultWidth();
    [CompilerGeneratedAttribute]
protected void set_DefaultWidth(double value);
    [CompilerGeneratedAttribute]
public sealed virtual double get_DefaultHeight();
    [CompilerGeneratedAttribute]
protected void set_DefaultHeight(double value);
    public sealed virtual string get_Title();
    public void set_Title(string value);
    public virtual bool Closing();
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    protected void Close();
    protected void RaisePropertyChanged(Expression`1<Func`1<V>> property);
}
public enum JetBrains.Common.Util.ViewModel.ModalWindows.SizeToContent : Enum {
    public int value__;
    public static SizeToContent Manual;
    public static SizeToContent Width;
    public static SizeToContent Height;
    public static SizeToContent WidthAndHeight;
}
public enum JetBrains.Common.Util.ViewModel.ModalWindows.WindowLocation : Enum {
    public int value__;
    public static WindowLocation Manual;
    public static WindowLocation CenterScreen;
    public static WindowLocation CenterOwner;
}
public enum JetBrains.Common.Util.ViewModel.ModalWindows.WindowState : Enum {
    public int value__;
    public static WindowState Normal;
    public static WindowState Minimized;
    public static WindowState Maximized;
}
public enum JetBrains.Common.Util.ViewModel.ModalWindows.WindowStoreType : Enum {
    public int value__;
    public static WindowStoreType None;
    public static WindowStoreType Size;
    public static WindowStoreType Position;
    public static WindowStoreType SizeAndPosition;
    public static WindowStoreType NoResize;
}
public class JetBrains.Common.Util.ViewModel.NotifyCollectionChangedCaster`2 : object {
    private IReadOnlyCollection`1<TFrom> mySource;
    private INotifyCollectionChanged myEventSource;
    [CompilerGeneratedAttribute]
private NotifyCollectionChangedEventHandler CollectionChanged;
    public int Count { get; }
    public NotifyCollectionChangedCaster`2(IReadOnlyCollection`1<TFrom> source);
    public sealed virtual int get_Count();
    private void RaiseCollectionChanged(NotifyCollectionChangedEventArgs args);
    public sealed virtual IEnumerator`1<TTo> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [CompilerGeneratedAttribute]
public sealed virtual void add_CollectionChanged(NotifyCollectionChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_CollectionChanged(NotifyCollectionChangedEventHandler value);
    [CompilerGeneratedAttribute]
private void <.ctor>b__2_0(object sender, NotifyCollectionChangedEventArgs args);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.ViewModel.NotifyPropetyChangedExtension : object {
    [ExtensionAttribute]
public static void AdvisePropertyChanged(INotifyPropertyChanged obj, Expression`1<Func`2<TType, TProperty>> property, Action`1<TType> action, Lifetime lifetime);
}
public class JetBrains.Common.Util.ViewModel.ObservableReadOnlyCollection`1 : object {
    private IEnumerable`1<T> mySource;
    private int myCount;
    public int Count { get; }
    public ObservableReadOnlyCollection`1(IEnumerable`1<T> source);
    public ObservableReadOnlyCollection`1(IEnumerable`1<T> source, int count);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    public sealed virtual int get_Count();
    public sealed virtual void add_CollectionChanged(NotifyCollectionChangedEventHandler value);
    public sealed virtual void remove_CollectionChanged(NotifyCollectionChangedEventHandler value);
    public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
}
internal class JetBrains.Common.Util.ViewModel.OverviewTree.CompositeOverviewTreeNode : object {
    private Stack`1<ISimpleOverviewTreeNode> myIncludedNodes;
    private ulong mySize;
    [CompilerGeneratedAttribute]
private ulong <Coordinate>k__BackingField;
    public ulong Size { get; }
    public IEnumerable`1<IOverviewTreeNode> Children { get; }
    public ulong Coordinate { get; private set; }
    public ISimpleOverviewTreeNode MaxIncludedNode { get; }
    public int IncludedNodesCount { get; }
    public IReadOnlyCollection`1<object> ModelNodes { get; }
    public CompositeOverviewTreeNode(IEnumerable`1<ISimpleOverviewTreeNode> orderedSubChildren, ulong coordinate);
    public void PushNode(ISimpleOverviewTreeNode simpleNode);
    public sealed virtual ulong get_Size();
    public sealed virtual IEnumerable`1<IOverviewTreeNode> get_Children();
    [CompilerGeneratedAttribute]
public sealed virtual ulong get_Coordinate();
    [CompilerGeneratedAttribute]
private void set_Coordinate(ulong value);
    public ISimpleOverviewTreeNode get_MaxIncludedNode();
    public int get_IncludedNodesCount();
    public ISimpleOverviewTreeNode PopMaxNode();
    public sealed virtual IReadOnlyCollection`1<object> get_ModelNodes();
}
public interface JetBrains.Common.Util.ViewModel.OverviewTree.ICompositeOverviewTreeNode {
    public IReadOnlyCollection`1<object> ModelNodes { get; }
    public abstract virtual IReadOnlyCollection`1<object> get_ModelNodes();
}
public interface JetBrains.Common.Util.ViewModel.OverviewTree.IOverviewTree {
    public IOverviewTreeNode PseudoRoot { get; }
    public abstract virtual IOverviewTreeNode get_PseudoRoot();
    public abstract virtual void ActualizeNodeChildren(IOverviewTreeNode node, ulong minVisibleNodeSize, IExecutionController executionController);
    public abstract virtual void InitTree(IExecutionController executionController);
}
public interface JetBrains.Common.Util.ViewModel.OverviewTree.IOverviewTreeNode {
    public ulong Size { get; }
    public IEnumerable`1<IOverviewTreeNode> Children { get; }
    public ulong Coordinate { get; }
    public abstract virtual ulong get_Size();
    public abstract virtual IEnumerable`1<IOverviewTreeNode> get_Children();
    public abstract virtual ulong get_Coordinate();
}
public interface JetBrains.Common.Util.ViewModel.OverviewTree.ISimpleOverviewTreeNode {
    public object ModelNode { get; }
    public abstract virtual object get_ModelNode();
}
public class JetBrains.Common.Util.ViewModel.OverviewTree.OverviewTree : object {
    private ITreeStructureProvider myTreeStructureProvider;
    private IOverviewTreeNode myPseudoRoot;
    public IOverviewTreeNode PseudoRoot { get; }
    public OverviewTree(ITreeStructureProvider treeStructureProvider);
    public sealed virtual void InitTree(IExecutionController executionController);
    private void CreateChildren(SimpleOverviewTreeNode parent, ulong minVisibleNodeSize, IExecutionController executionController);
    private SimpleOverviewTreeNode CreateChild(object node, UInt64& leftCoord, IExecutionController executionController);
    private void UpdateChildren(SimpleOverviewTreeNode parent, ulong minVisibleNodeSize, IExecutionController executionController);
    private SimpleOverviewTreeNode CreateSimpleNode(object modelNode, ulong leftCoord, IExecutionController controller);
    public sealed virtual IOverviewTreeNode get_PseudoRoot();
    public sealed virtual void ActualizeNodeChildren(IOverviewTreeNode node, ulong minVisibleNodeSize, IExecutionController executionController);
}
internal class JetBrains.Common.Util.ViewModel.OverviewTree.SimpleOverviewTreeNode : object {
    private List`1<ISimpleOverviewTreeNode> mySimpleChildren;
    [CompilerGeneratedAttribute]
private ulong <Size>k__BackingField;
    [CompilerGeneratedAttribute]
private object <ModelNode>k__BackingField;
    [CompilerGeneratedAttribute]
private ICompositeOverviewTreeNode <CompositeChildNode>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <Coordinate>k__BackingField;
    public ulong Size { get; }
    public object ModelNode { get; }
    public ISimpleOverviewTreeNode SmallestSimpleChild { get; }
    public ICompositeOverviewTreeNode CompositeChildNode { get; public set; }
    public IEnumerable`1<IOverviewTreeNode> Children { get; }
    public ulong Coordinate { get; }
    public int SimpleChildrenCount { get; }
    public SimpleOverviewTreeNode(object modelNode, ulong size, ulong coordinate);
    [CompilerGeneratedAttribute]
public sealed virtual ulong get_Size();
    [CompilerGeneratedAttribute]
public sealed virtual object get_ModelNode();
    public ISimpleOverviewTreeNode get_SmallestSimpleChild();
    [CompilerGeneratedAttribute]
public ICompositeOverviewTreeNode get_CompositeChildNode();
    [CompilerGeneratedAttribute]
public void set_CompositeChildNode(ICompositeOverviewTreeNode value);
    public sealed virtual IEnumerable`1<IOverviewTreeNode> get_Children();
    [CompilerGeneratedAttribute]
public sealed virtual ulong get_Coordinate();
    public int get_SimpleChildrenCount();
    public void AddSimpleChild(ISimpleOverviewTreeNode child);
    public ISimpleOverviewTreeNode ExcludeSmalestChild();
    public void ReplaceChild(ISimpleOverviewTreeNode oldChild, ISimpleOverviewTreeNode newChild);
}
public interface JetBrains.Common.Util.ViewModel.PlainTreeCollecion.IPlainTreeItemCollection {
    [CanBeNullAttribute]
public IEnumerable Source { get; public set; }
    [NotNullAttribute]
public ITreeStructureProvider TreeStructureProvider { get; }
    public abstract virtual void Reload();
    public abstract virtual void ReloadChildren(object item);
    public abstract virtual bool VerifyChildren(object item);
    public abstract virtual bool IsExpanded(object item);
    public abstract virtual void Collapse(object item);
    public abstract virtual void Expand(object item);
    [CanBeNullAttribute]
public abstract virtual object GetParent(object item);
    public abstract virtual int GetLevel(object item);
    public abstract virtual IEnumerable get_Source();
    public abstract virtual void set_Source(IEnumerable value);
    public abstract virtual ITreeStructureProvider get_TreeStructureProvider();
    [CompilerGeneratedAttribute]
public abstract virtual void add_BeginBatchUpdate(Action value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_BeginBatchUpdate(Action value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_EndBatchUpdate(Action value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_EndBatchUpdate(Action value);
}
public interface JetBrains.Common.Util.ViewModel.PlainTreeCollecion.ITreeStructureProvider {
    public abstract virtual bool IsExpanded(object item);
    public abstract virtual IEnumerable GetChildren(object item);
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Common.Util.ViewModel.PlainTreeCollecion.PlainTreeItemCollection2 : object {
    private static ILogger ourLogger;
    private List`1<object> myList;
    private Dictionary`2<object, TreeInfo> myTreeInfoMap;
    private ITreeStructureProvider myTreeStructureProvider;
    private Dispatcher myDispatcher;
    private IEnumerable myRootSource;
    private bool myIsUpdating;
    [CompilerGeneratedAttribute]
private NotifyCollectionChangedEventHandler CollectionChanged;
    [CompilerGeneratedAttribute]
private Action BeginBatchUpdate;
    [CompilerGeneratedAttribute]
private Action EndBatchUpdate;
    public ITreeStructureProvider TreeStructureProvider { get; }
    public IEnumerable Source { get; public set; }
    public int Count { get; }
    public object Item { get; }
    public PlainTreeItemCollection2(ITreeStructureProvider treeStructureProvider, Dispatcher dispatcher);
    private static PlainTreeItemCollection2();
    public sealed virtual ITreeStructureProvider get_TreeStructureProvider();
    public sealed virtual IEnumerable get_Source();
    public sealed virtual void set_Source(IEnumerable value);
    public sealed virtual int get_Count();
    public sealed virtual object get_Item(int index);
    public sealed virtual bool IsExpanded(object item);
    public sealed virtual void Expand(object item);
    public sealed virtual void Collapse(object item);
    public sealed virtual bool VerifyChildren(object item);
    public sealed virtual void ReloadChildren(object item);
    public sealed virtual void Reload();
    public sealed virtual object GetParent(object item);
    public sealed virtual int GetLevel(object item);
    public sealed virtual IEnumerator`1<object> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [CompilerGeneratedAttribute]
public sealed virtual void add_CollectionChanged(NotifyCollectionChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_CollectionChanged(NotifyCollectionChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_BeginBatchUpdate(Action value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_BeginBatchUpdate(Action value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_EndBatchUpdate(Action value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_EndBatchUpdate(Action value);
    private sealed virtual override bool System.Windows.IWeakEventListener.ReceiveWeakEvent(Type managerType, object sender, EventArgs evt);
    private void OnCollectionChanged(object sender);
    private void VerifyAccess();
    private void BeginUpdate();
    private void EndUpdate();
    [CanBeNullAttribute]
private IEnumerable GetProvidedChildren(object item);
    [IteratorStateMachineAttribute("JetBrains.Common.Util.ViewModel.PlainTreeCollecion.PlainTreeItemCollection2/<GetExpandedDirectChildren>d__44")]
[NotNullAttribute]
private IEnumerable`1<object> GetExpandedDirectChildren(int index, TreeInfo treeInfo);
    private void BatchCreateChildren(int index, TreeInfo treeInfo, List`1<object> children);
    private void BatchFinishCreate(int index, List`1<object> children);
    private void BatchRemoveChildren(int index, TreeInfo treeInfo, List`1<object> children);
    private void BatchFinishRemove(int index, List`1<object> children);
    private void BatchFinishReplace(int index, List`1<object> removedChildren, List`1<object> addedChildren);
    private void BatchFinishReset(List`1<object> children);
    private void ResetInternalState();
    private void RaiseCollectionChanged(NotifyCollectionChangedEventArgs args);
    [CompilerGeneratedAttribute]
private void <ResetInternalState>b__51_0();
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.ViewModel.PlainTreeCollecion.PlainTreeItemCollectionExtensions : object {
    [ExtensionAttribute]
public static bool IsAncestorOf(IPlainTreeItemCollection collection, object ancestor, object descendant);
}
public class JetBrains.Common.Util.ViewModel.ResourceDictionaryId : EnumPattern {
    public ResourceDictionaryId(string name);
}
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
public static class JetBrains.Common.Util.ViewModel.Resources.Strings : object {
    private static ILogger ourLog;
    private static Lazy`1<JetResourceManager> ourResourceManager;
    [EditorBrowsableAttribute("2")]
public static JetResourceManager ResourceManager { get; }
    public static string DirectionSettingDescription { get; }
    public static string KeySettingDescription { get; }
    public static string SorterVmStateSettingDescription { get; }
    private static Strings();
    public static JetResourceManager get_ResourceManager();
    public static string Choice(string format, Object[] args);
    public static string get_DirectionSettingDescription();
    public static string get_KeySettingDescription();
    public static string get_SorterVmStateSettingDescription();
}
public class JetBrains.Common.Util.ViewModel.ScrollToItemArgs : EventArgs {
    [CompilerGeneratedAttribute]
private object <Item>k__BackingField;
    public object Item { get; }
    public ScrollToItemArgs(object item);
    [CompilerGeneratedAttribute]
public object get_Item();
}
public interface JetBrains.Common.Util.ViewModel.Sorting.ISorter`1 {
    public ICommand`1<TSortKey> SortCommand { get; }
    public SortState`1<TSortKey> SortState { get; }
    public abstract virtual ICommand`1<TSortKey> get_SortCommand();
    public abstract virtual SortState`1<TSortKey> get_SortState();
}
public interface JetBrains.Common.Util.ViewModel.Sorting.ISorterVm`1 {
}
[ObsoleteAttribute("Consider using re-worked FilterVm/SorterVm instead.")]
public class JetBrains.Common.Util.ViewModel.Sorting.Sorter`2 : object {
    private IDataController`1<Comparison`1<TSortedItem>> myCurrentComparisonProvider;
    private Dictionary`2<TSortKey, Tuple`2<ListSortDirection, Comparison`1<TSortedItem>>> myComparisons;
    private SortState`1<TSortKey> mySortState;
    [CompilerGeneratedAttribute]
private ICommand`1<TSortKey> <SortCommand>k__BackingField;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    public IDataProvider`1<Comparison`1<TSortedItem>> CurrentComparisonProvider { get; }
    public Comparison`1<TSortedItem> CurrentComparison { get; private set; }
    public ICommand`1<TSortKey> SortCommand { get; }
    public SortState`1<TSortKey> SortState { get; private set; }
    public Sorter`2(Action`1<Comparison`1<TSortedItem>> sortAction);
    private Sorter`2(bool internal, Action`1<Comparison`1<TSortedItem>> sortAction);
    public IDataProvider`1<Comparison`1<TSortedItem>> get_CurrentComparisonProvider();
    public Sorter`2<TSortKey, TSortedItem> AddSortKey(TSortKey sortKey, Comparison`1<TSortedItem> defaultComparison, ListSortDirection sortDirection);
    public Sorter`2<TSortKey, TSortedItem> AddSortKey(TSortKey sortKey, Func`2<TSortedItem, T> getProperty, ListSortDirection sortDirection);
    public Sorter`2<TSortKey, TSortedItem> SetSortKey(TSortKey sortKey);
    public void SetSortState(SortState`1<TSortKey> sortState);
    public Comparison`1<TSortedItem> get_CurrentComparison();
    private void set_CurrentComparison(Comparison`1<TSortedItem> value);
    private static ListSortDirection Invert(ListSortDirection sortDirection);
    [CompilerGeneratedAttribute]
public sealed virtual ICommand`1<TSortKey> get_SortCommand();
    public sealed virtual SortState`1<TSortKey> get_SortState();
    private void set_SortState(SortState`1<TSortKey> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.ViewModel.Sorting.SorterExtensions : object {
    [ExtensionAttribute]
public static void SortByCurrentSortKey(Sorter`2<TKey, TItem> sorter, Action`1<Comparison`1<TItem>> sortAction);
    [ExtensionAttribute]
public static void SortByCurrentSortKey(Sorter`2<TKey, TItem> sorter, IList`1<TItem> list);
}
public class JetBrains.Common.Util.ViewModel.Sorting.SorterVm`2 : object {
    private Dictionary`2<TSortKey, Pair`2<ListSortDirection, Comparison`1<TSortedItem>>> mySortKeys;
    private IDataController`1<Comparison`1<TSortedItem>> myComparisonPipe;
    private ISettings mySettings;
    private string mySettingId;
    private Command2`1<TSortKey> mySortCommand;
    private IIndexedKey`1<SorterVmState> myPersistentKey;
    private TSortKey myComplementaryKey;
    private TSortKey myDefaultKey;
    private Comparison`1<TSortedItem> myDemarcator;
    private SortState`1<TSortKey> myState;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    public SortState`1<TSortKey> SortState { get; public set; }
    public ICommand`1<TSortKey> SortCommand { get; }
    public IDataProvider`1<Comparison`1<TSortedItem>> ComparisonPipe { get; }
    public Comparison`1<TSortedItem> CurrentComparison { get; }
    public SorterVm`2(ISettings settings, string settingId);
    public sealed virtual void Initialize();
    public void ForceResort();
    public sealed virtual SortState`1<TSortKey> get_SortState();
    public void set_SortState(SortState`1<TSortKey> value);
    public sealed virtual ICommand`1<TSortKey> get_SortCommand();
    public IDataProvider`1<Comparison`1<TSortedItem>> get_ComparisonPipe();
    public Comparison`1<TSortedItem> get_CurrentComparison();
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    public SorterVm`2<TSortKey, TSortedItem> WithAscKey(TSortKey sortKey, Comparison`1<TSortedItem> comparison);
    public SorterVm`2<TSortKey, TSortedItem> WithDescKey(TSortKey sortKey, Comparison`1<TSortedItem> comparison);
    public SorterVm`2<TSortKey, TSortedItem> UsingComplementary(TSortKey sortKey);
    public SorterVm`2<TSortKey, TSortedItem> UsingDefault(TSortKey sortKey);
    public SorterVm`2<TSortKey, TSortedItem> InitializeUsingDefault(TSortKey sortKey);
    public SorterVm`2<TSortKey, TSortedItem> UsingDemarcator(Comparison`1<TSortedItem> comparison);
    private void ToggleSort(TSortKey sortKey);
    private Comparison`1<TSortedItem> GetComparison(SortState`1<TSortKey> state);
}
[SettingsIndexedKeyAttribute("System.Reflection.Missing", "JetBrains.Common.Util.ViewModel.Resources.Strings", "SorterVmStateSettingDescription", "System.String")]
public class JetBrains.Common.Util.ViewModel.Sorting.SorterVmState : object {
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.Common.Util.ViewModel.Resources.Strings", "DirectionSettingDescription")]
public ListSortDirection Direction;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.Common.Util.ViewModel.Resources.Strings", "KeySettingDescription")]
public int Key;
    public SorterVmState(ListSortDirection direction, int key);
}
public class JetBrains.Common.Util.ViewModel.Sorting.SortKeyAndDirectionProviders`1 : object {
    private Dictionary`2<TSortKey, ListSortDirection> myFirstDirections;
    private SortState`1<TSortKey> mySortState;
    private IDataController`1<TSortKey> mySortKey;
    private IDataController`1<ListSortDirection> mySortDirection;
    [CompilerGeneratedAttribute]
private ICommand`1<TSortKey> <SortCommand>k__BackingField;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    public IDataProvider`1<TSortKey> SortKey { get; }
    public IDataProvider`1<ListSortDirection> SortDirection { get; }
    public ICommand`1<TSortKey> SortCommand { get; }
    public SortState`1<TSortKey> SortState { get; private set; }
    public SortKeyAndDirectionProviders`1(TSortKey defaultSortKey, ListSortDirection defaultSortDirection);
    public IDataProvider`1<TSortKey> get_SortKey();
    public IDataProvider`1<ListSortDirection> get_SortDirection();
    public SortKeyAndDirectionProviders`1<TSortKey> SetFirstSortDirection(TSortKey key, ListSortDirection direction);
    [CompilerGeneratedAttribute]
public sealed virtual ICommand`1<TSortKey> get_SortCommand();
    public sealed virtual SortState`1<TSortKey> get_SortState();
    private void set_SortState(SortState`1<TSortKey> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
private void <.ctor>b__9_0(TSortKey column);
}
public enum JetBrains.Common.Util.ViewModel.Sorting.SortOrder : Enum {
    public int value__;
    public static SortOrder None;
    public static SortOrder Ascending;
    public static SortOrder Descending;
}
public class JetBrains.Common.Util.ViewModel.Sorting.SortState : object {
    [CompilerGeneratedAttribute]
private ListSortDirection <SortDirection>k__BackingField;
    [CompilerGeneratedAttribute]
private object <SortKey>k__BackingField;
    public ListSortDirection SortDirection { get; }
    [NotNullAttribute]
public object SortKey { get; }
    public SortState(ListSortDirection sortDirection, object sortKey);
    [CompilerGeneratedAttribute]
public ListSortDirection get_SortDirection();
    [CompilerGeneratedAttribute]
public object get_SortKey();
}
public class JetBrains.Common.Util.ViewModel.Sorting.SortState`1 : SortState {
    public TSortKey SortKey { get; }
    public SortState`1(ListSortDirection sortDirection, TSortKey sortKey);
    public TSortKey get_SortKey();
}
public interface JetBrains.Common.Util.ViewModel.Sunburst2.ISunburstColorScheme {
    public abstract virtual JetRgbaColor GetColor(float angle, int level, bool isDark);
}
public interface JetBrains.Common.Util.ViewModel.Sunburst2.ISunburstDataSource {
    [CanBeNullAttribute]
public object CoreNode { get; }
    public abstract virtual object get_CoreNode();
    [NotNullAttribute]
public abstract virtual ISunburstNode GetSunburstNode(object node);
    [CompilerGeneratedAttribute]
public abstract virtual void add_CoreNodeZoomedIn(EventHandler`1<SunburstZoomedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_CoreNodeZoomedIn(EventHandler`1<SunburstZoomedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_CoreNodeZoomedOut(EventHandler`1<SunburstZoomedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_CoreNodeZoomedOut(EventHandler`1<SunburstZoomedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_CoreNodeFiltered(EventHandler`1<SunburstChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_CoreNodeFiltered(EventHandler`1<SunburstChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_CoreNodeMoved(EventHandler`1<SunburstChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_CoreNodeMoved(EventHandler`1<SunburstChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_CoreNodeChanged(EventHandler`1<SunburstChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_CoreNodeChanged(EventHandler`1<SunburstChangedEventArgs> value);
}
public interface JetBrains.Common.Util.ViewModel.Sunburst2.ISunburstNode {
    [NotNullAttribute]
public object Origin { get; }
    [NotNullAttribute]
public IEnumerable Children { get; }
    public float AngularOffset { get; }
    public float AngularSize { get; }
    public int Level { get; }
    public bool IsTail { get; }
    public bool IsFilled { get; }
    public abstract virtual object get_Origin();
    public abstract virtual IEnumerable get_Children();
    public abstract virtual float get_AngularOffset();
    public abstract virtual float get_AngularSize();
    public abstract virtual int get_Level();
    public abstract virtual bool get_IsTail();
    public abstract virtual bool get_IsFilled();
}
public class JetBrains.Common.Util.ViewModel.Sunburst2.SunburstChangedEventArgs : EventArgs {
    [CanBeNullAttribute]
public object Node;
    public SunburstChangedEventArgs(object node);
}
public class JetBrains.Common.Util.ViewModel.Sunburst2.SunburstHsbColorScheme : object {
    public static JetRgbaColor LightColorCore;
    public static JetRgbaColor DarkColorCore;
    private static SunburstHsbColorScheme();
    public sealed virtual JetRgbaColor GetColor(float angle, int level, bool isDark);
}
public class JetBrains.Common.Util.ViewModel.Sunburst2.SunburstZoomedEventArgs : EventArgs {
    [NotNullAttribute]
public object FromNode;
    [NotNullAttribute]
public object ToNode;
    [NotNullAttribute]
public IReadOnlyList`1<object> ZoomPath;
    public SunburstZoomedEventArgs(object fromNode, object toNode, IReadOnlyList`1<object> zoomPath);
}
public interface JetBrains.Common.Util.ViewModel.TreeDiagram.ITreeDiagramDataSource {
    public object Root { get; }
    public abstract virtual object get_Root();
    public abstract virtual object GetChildAt(object node, int index);
    public abstract virtual int GetChildrenCount(object node);
}
public interface JetBrains.Common.Util.ViewModel.TreeDiagram.ITreeDiagramDataSource`1 {
    public TNode Root { get; }
    public abstract virtual TNode get_Root();
    public abstract virtual TNode GetChildAt(TNode node, int index);
    public abstract virtual int GetChildrenCount(TNode node);
}
public interface JetBrains.Common.Util.ViewModel.TreeDiagram.ITreeDiagramDataSourceBase {
    [CompilerGeneratedAttribute]
public abstract virtual void add_Updated(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Updated(EventHandler value);
}
public interface JetBrains.Common.Util.ViewModel.TreeDiagram.ITreeDiagramNodeSizeEvaluator {
    public abstract virtual JetSize GetNodeSize(object node);
}
public interface JetBrains.Common.Util.ViewModel.TreeDiagram.ITreeDiagramNodeSizeEvaluator`1 {
    public abstract virtual JetSize GetNodeSize(TNode node);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.ViewModel.TreeDiagram.TreeDiagramExtensions : object {
    [ExtensionAttribute]
public static ITreeDiagramNodeSizeEvaluator ToNonGeneric(ITreeDiagramNodeSizeEvaluator`1<TNode> that);
    [ExtensionAttribute]
public static ITreeDiagramDataSource ToNonGeneric(ITreeDiagramDataSource`1<TNode> that);
}
public interface JetBrains.Common.Util.ViewModel.TreeProviders.ITreeFoldingManager {
    public abstract virtual bool IsFolded(object treeNode, IExecutionController executionController);
    public abstract virtual bool CanBeFolded(object treeNode, IExecutionController executionController);
    public abstract virtual object Fold(object treeNode, IExecutionController executionController);
    public abstract virtual object Unfold(object treeNode, IExecutionController executionController);
}
public interface JetBrains.Common.Util.ViewModel.TreeProviders.ITreeStructureProvider {
    [CanBeNullAttribute]
public ITreeFoldingManager TreeFoldingManager { get; }
    public IProperty`1<TreeRootsState> RootsState { get; }
    [NotNullAttribute]
public abstract virtual IEnumerable GetChildren(object treeNode, IExecutionController executionController);
    public abstract virtual ulong GetPayload(object treeNode, IExecutionController executionController);
    public abstract virtual string GetName(object treeNode);
    [NotNullAttribute]
public abstract virtual IEnumerable GetRoots(IExecutionController executionController);
    public abstract virtual object AggregateNodes(IEnumerable`1<object> nodes);
    public abstract virtual ITreeFoldingManager get_TreeFoldingManager();
    public abstract virtual IProperty`1<TreeRootsState> get_RootsState();
    [CompilerGeneratedAttribute]
public abstract virtual void add_TreeUpdate(Action`1<object> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_TreeUpdate(Action`1<object> value);
}
public enum JetBrains.Common.Util.ViewModel.TreeProviders.TreeRootsState : Enum {
    public int value__;
    public static TreeRootsState NotRequested;
    public static TreeRootsState RequestedEmpty;
    public static TreeRootsState RequestedExist;
}
public class JetBrains.Common.Util.ViewModel.TreeProviders.TreeStructureProviderWrapper`1 : object {
    private ITreeStructureProvider myTreeStructureProvider;
    private Func`2<object, T> myFConvert;
    private Func`2<T, object> myGetOriginal;
    [CompilerGeneratedAttribute]
private ITreeFoldingManager <TreeFoldingManager>k__BackingField;
    [CompilerGeneratedAttribute]
private IProperty`1<TreeRootsState> <RootsState>k__BackingField;
    public ITreeFoldingManager TreeFoldingManager { get; private set; }
    public IProperty`1<TreeRootsState> RootsState { get; private set; }
    public TreeStructureProviderWrapper`1(ITreeStructureProvider treeStructureProvider, Func`2<object, T> fConvert, Func`2<T, object> getOriginal);
    public sealed virtual IEnumerable GetChildren(object treeNode, IExecutionController executionController);
    public sealed virtual ulong GetPayload(object treeNode, IExecutionController executionController);
    public sealed virtual string GetName(object treeNode);
    public sealed virtual IEnumerable GetRoots(IExecutionController executionController);
    public sealed virtual object AggregateNodes(IEnumerable`1<object> nodes);
    [CompilerGeneratedAttribute]
public sealed virtual ITreeFoldingManager get_TreeFoldingManager();
    [CompilerGeneratedAttribute]
private void set_TreeFoldingManager(ITreeFoldingManager value);
    [CompilerGeneratedAttribute]
public sealed virtual IProperty`1<TreeRootsState> get_RootsState();
    [CompilerGeneratedAttribute]
private void set_RootsState(IProperty`1<TreeRootsState> value);
    public sealed virtual void add_TreeUpdate(Action`1<object> value);
    public sealed virtual void remove_TreeUpdate(Action`1<object> value);
    [CompilerGeneratedAttribute]
private T <GetChildren>b__4_0(object _);
    [CompilerGeneratedAttribute]
private T <GetRoots>b__7_0(object _);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.ViewModel.WritableBitmapExtensions : object {
    [ExtensionAttribute]
public static void SetPixel(WriteableBitmap bitmap, int row, int column, int color);
    [ExtensionAttribute]
public static void FillBitmap(WriteableBitmap bitmap, int color);
    [ExtensionAttribute]
public static void Invalidate(WriteableBitmap bitmap);
    [ExtensionAttribute]
public static void FillRect(WriteableBitmap bitmap, int x1, int y1, int x2, int y2, int color, bool markDirty);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
