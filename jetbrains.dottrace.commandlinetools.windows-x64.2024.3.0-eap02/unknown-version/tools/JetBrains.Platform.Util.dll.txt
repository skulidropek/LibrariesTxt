[ObsoleteAttribute("No usages in ReSharper")]
[ThreadUnsafeAttribute]
public static class JetBrains.ActivityCollector.ActivityCollector : object {
    private static byte THREAD_RECORD_ID;
    private static byte ACTIVITY_RECORD_ID;
    private static BinaryWriter myBinaryWriter;
    private static object myLock;
    private static Dictionary`2<int, ActivityEndpoint> myRegisteredThreads;
    private static ActivityCollector();
    public static ActivityEndpoint GetEndpoint();
    public static void Flush();
    private static void EnsureWriter();
    private static void EnsureThread();
    private static void RegisterThread(int id, string name);
    private static void WriteActivity(Activity activity);
}
public class JetBrains.ActivityCollector.Key : object {
    private string myName;
    public string Name { get; }
    public Key(string name);
    public string get_Name();
}
public interface JetBrains.Application.ISorter`1 {
    public abstract virtual ICollection`1<T> Sort(ICollection`1<T> unsorted);
}
[LocalizableAttribute("False")]
public class JetBrains.Application.platforms.FrameworkIdentifier : object {
    public static string NET_FRAMEWORK_ID;
    public static string NET_CORE;
    public static string NET_PORTABLE_ID;
    public static string SILVERLIGHT;
    public static FrameworkIdentifier NetFramework;
    public static FrameworkIdentifier NetMicroFramework;
    public static FrameworkIdentifier Silverlight;
    public static FrameworkIdentifier NetCore;
    public static FrameworkIdentifier NetCoreApp;
    public static FrameworkIdentifier NetCorePlatforms;
    public static FrameworkIdentifier Portable;
    public static FrameworkIdentifier XamarinIos;
    public static FrameworkIdentifier MonoTouch;
    public static FrameworkIdentifier MonoAndroid;
    public static FrameworkIdentifier NetStandart;
    [NotNullAttribute]
private string myIdentifier;
    private static Dictionary`2<string, string> ourPresentableNamesDictionary;
    private static IEqualityComparer`1<string> ID_COMPARER;
    [NotNullAttribute]
public string Identifier { get; }
    [NotNullAttribute]
public string PresentableName { get; }
    public FrameworkIdentifier(string identifier);
    private static FrameworkIdentifier();
    [IteratorStateMachineAttribute("JetBrains.Application.platforms.FrameworkIdentifier/<GetWellKnownIdentifiers>d__16")]
public static IEnumerable`1<FrameworkIdentifier> GetWellKnownIdentifiers();
    public string get_Identifier();
    public string get_PresentableName();
    public sealed virtual bool Equals(FrameworkIdentifier other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static bool op_Equality(FrameworkIdentifier left, FrameworkIdentifier right);
    public static bool op_Inequality(FrameworkIdentifier left, FrameworkIdentifier right);
    public void WriteFrameworkIdentifier(BinaryWriter writer);
    public void WriteFrameworkIdentifier(UnsafeWriter writer);
}
[LocalizableAttribute("False")]
public class JetBrains.Application.platforms.ProfileIdentifier : object {
    public static ProfileIdentifier WindowsPhone;
    public static ProfileIdentifier WindowsPhone71;
    public static ProfileIdentifier Client;
    public static ProfileIdentifier Runtime;
    public static ProfileIdentifier Default;
    [NotNullAttribute]
private string myIdentifier;
    private static Dictionary`2<string, string> ourPresentableNamesDictionary;
    [NotNullAttribute]
public string Identifier { get; }
    [NotNullAttribute]
public string PresentableName { get; }
    public ProfileIdentifier(string identifier);
    private static ProfileIdentifier();
    public bool Equals(ProfileIdentifier other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public string get_Identifier();
    public string get_PresentableName();
    public static bool op_Equality(ProfileIdentifier left, ProfileIdentifier right);
    public static bool op_Inequality(ProfileIdentifier left, ProfileIdentifier right);
    public virtual string ToString();
    public bool IsDefault();
    public bool IsRuntime();
    public void WriteProfileIdentifier(BinaryWriter writer);
    public void WriteProfileIdentifier(UnsafeWriter writer);
}
public class JetBrains.Application.Progress.CombinedProgressIndicator : object {
    [NotNullAttribute]
private IEnumerable`1<IProgressIndicator> myChildIndicators;
    public string CurrentItemText { get; public set; }
    public bool IsCanceled { get; }
    public string TaskName { get; public set; }
    public CombinedProgressIndicator(IReadOnlyCollection`1<IProgressIndicator> childIndicators);
    public sealed virtual void Dispose();
    public sealed virtual string get_CurrentItemText();
    public sealed virtual void set_CurrentItemText(string value);
    public sealed virtual bool get_IsCanceled();
    public sealed virtual string get_TaskName();
    public sealed virtual void set_TaskName(string value);
    public sealed virtual void Advance(double units);
    public sealed virtual void Start(int totalWorkUnits);
    public sealed virtual void Stop();
}
public class JetBrains.Application.Progress.LiveCombinedProgressIndicator : object {
    [NotNullAttribute]
private IProgressIndicator[] modreq(System.Runtime.CompilerServices.IsVolatile) myIndicators;
    [CanBeNullAttribute]
private string myCurrentItemText;
    private string myTaskName;
    private int myTotalUnit;
    private double myProgress;
    private object myLock;
    private bool myIsCancelled;
    public string CurrentItemText { get; public set; }
    public bool IsCanceled { get; }
    public string TaskName { get; public set; }
    public LiveCombinedProgressIndicator(Lifetime lifetime);
    public void Add(Lifetime lifetime, IProgressIndicator indicator);
    public void Cancel();
    public bool Remove(IProgressIndicator item);
    public sealed virtual void Dispose();
    public sealed virtual string get_CurrentItemText();
    public sealed virtual void set_CurrentItemText(string value);
    public sealed virtual bool get_IsCanceled();
    public sealed virtual string get_TaskName();
    public sealed virtual void set_TaskName(string value);
    public sealed virtual void Advance(double units);
    public sealed virtual void Start(int totalWorkUnits);
    public sealed virtual void Stop();
}
public class JetBrains.Application.Progress.NullProgressIndicator : ProgressIndicatorBase {
    [NotNullAttribute]
[ObsoleteAttribute("This property always creates a new instance, so should better be using the Create() method.")]
public static IProgressIndicator Instance { get; }
    [DebuggerStepThroughAttribute]
public static IProgressIndicator get_Instance();
    [NotNullAttribute]
[PureAttribute]
[DebuggerStepThroughAttribute]
public static IProgressIndicator Create();
    [NotNullAttribute]
[PureAttribute]
[DebuggerStepThroughAttribute]
public static IProgressIndicator Create(Lifetime lifetime);
    [NotNullAttribute]
[PureAttribute]
[DebuggerStepThroughAttribute]
public static ICancellableProgressIndicator CreateCancellable(Lifetime lifetime);
}
public static class JetBrains.BooleanUtil : object {
    [NotNullAttribute]
[PureAttribute]
public static Func`2<string, bool> SafeParseBool(bool defaultValue);
    [PureAttribute]
public static bool SafeParseBool(string value, bool defaultValue);
}
[ExtensionAttribute]
public static class JetBrains.Common.Util.EventExtensions : object {
    [ExtensionAttribute]
public static void Raise(EventHandler`1<TEventArgs> event, object sender, TEventArgs args);
    [ExtensionAttribute]
public static void Raise(PropertyChangedEventHandler event, object sender, Expression`1<Func`1<T>> property);
    [ExtensionAttribute]
public static void Raise(PropertyChangedEventHandler event, object sender, Expression`1<Func`2<T, TProperty>> property);
    [ExtensionAttribute]
public static void Raise(PropertyChangedEventHandler event, object sender, string propertyName);
    [ExtensionAttribute]
public static void Raise(PropertyChangedEventHandler event, object sender, PropertyChangedEventArgs args);
    [ExtensionAttribute]
public static void Raise(EventHandler`1<EventArgs`1<T>> event, object sender, T args);
    [ExtensionAttribute]
public static void RaiseAsync(EventHandler`1<EventArgs`1<T>> event, object sender, T args);
    [ExtensionAttribute]
public static void Raise(EventHandler`2<T, EventArgs> event, T sender);
    [ExtensionAttribute]
public static void Raise(EventHandler`2<T, EventArgs`1<TValue>> event, T sender, TValue value);
    [ExtensionAttribute]
public static void Raise(EventHandler`2<T, TArgs> event, T sender, TArgs args);
    [ExtensionAttribute]
public static void Raise(EventHandler event, object sender);
    [ExtensionAttribute]
public static void Raise(EventHandler event, object sender, EventArgs eventArgs);
    [ExtensionAttribute]
public static void Raise(Action action);
    [ExtensionAttribute]
public static void Raise(Action`1<T> action, T arg);
}
public class JetBrains.Common.Util.EventHandler`2 : MulticastDelegate {
    public EventHandler`2(object object, IntPtr method);
    public virtual void Invoke(T sender, TArgs args);
    public virtual IAsyncResult BeginInvoke(T sender, TArgs args, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class JetBrains.Compression.IntegerDecoder : object {
    private static Byte[] SPEEDY;
    private Byte[] myBuffer;
    private int myBitPosition;
    public long FilePointer { get; }
    public int Limit { get; }
    public IntegerDecoder(Byte[] buff);
    public IntegerDecoder(IntegerEncoder integerEncoder);
    private static IntegerDecoder();
    public long get_FilePointer();
    public void Jump(long bits);
    public void Load(long fromBit);
    public void FullBuff(long fromBit);
    public void Close();
    public int Read();
    public byte Read0();
    public int ReadBit();
    public int ReadUnary();
    public int ReadBinary(int len);
    public int ReadGamma();
    public long ReadPack7();
    public int ReadPack7I();
    public int ReadGolomb(int b);
    public int get_Limit();
    protected int ENSURE();
    private int Shift();
    private int Gimme();
}
public class JetBrains.Compression.IntegerEncoder : object {
    internal static Int32[] INVONE;
    private Byte[] myBuff;
    private int myBitPosition;
    public long WrittenBits { get; }
    public int ByteLength { get; }
    public IntegerEncoder(int bufferSize);
    private static IntegerEncoder();
    public long get_WrittenBits();
    public Byte[] GetBytes();
    public void Close();
    public void Write(Byte[] b, int off, int len);
    public void FlushByte();
    public int get_ByteLength();
    public void Flush();
    public void Write(int b);
    public void WriteBit(int b);
    public void WriteUnary(int k);
    private void EnsureBuffer(int bytePos);
    public void WriteBinary(int val, int len);
    public void WriteGamma(int val);
    public void WritePack7(long val);
    public void WritePack7I(int val);
    public void WriteGolomb(int val, int b);
}
public class JetBrains.DataFlow.BidirectionalCompositeProperty`3 : CompositeProperty`3<TSourceOne, TSourceTwo, TTarget> {
    private object _cookie;
    protected BidirectionalCompositeProperty`3(Lifetime lifetime, IProperty`1<TSourceOne> propertySourceOne, IProperty`1<TSourceTwo> propertySourceTwo, ComposerDelegate<TSourceOne, TSourceTwo, TTarget> composer, Func`2<TTarget, TSourceOne> decomposerOne, Func`2<TTarget, TSourceTwo> decomposerTwo);
    protected virtual Property`1<TTarget> DecorateProperty(Lifetime lifetime, Property`1<TTarget> property);
    public static IProperty`1<TTarget> Create(Lifetime lifetime, IProperty`1<TSourceOne> propertySourceOne, IProperty`1<TSourceTwo> propertySourceTwo, ComposerDelegate<TSourceOne, TSourceTwo, TTarget> composer, Func`2<TTarget, TSourceOne> decomposerOne, Func`2<TTarget, TSourceTwo> decomposerTwo);
}
[ExtensionAttribute]
public static class JetBrains.DataFlow.BidirectionalCompositePropertyEx : object {
    [ExtensionAttribute]
public static IProperty`1<Pair`2<T1, T2>> Compose(IProperty`1<T1> p1, Lifetime lifetime, IProperty`1<T2> p2);
}
[ExtensionAttribute]
public static class JetBrains.DataFlow.ICollectionEventsInUtilEx : object {
    [ExtensionAttribute]
[NotNullAttribute]
public static IListEvents`1<TItem> OrderByLive(IReadonlyCollectionEvents`1<TItem> this, Lifetime lifetime, IComparer`1<TItem> comparer, Func`2<TItem, bool> filter, bool bUniqueItems);
    [ExtensionAttribute]
public static ListEvents`1<T> LiveFilter(IListEvents`1<T> source, Lifetime lifetime, Func`2<T, IProperty`1<bool>> funcFilter, ListEvents`1<T> target);
}
[DefaultMemberAttribute("Item")]
[DebuggerStepThroughAttribute]
public class JetBrains.DataFlow.ListEvents`1 : CollectionEvents`1<TValue> {
    private static string ValueNameListStorage;
    private SignalWithDelegates`1<AddRemoveIndexEventArgs`1<TValue>> mySignalAddRemove;
    private SignalWithDelegates`1<BeforeAddRemoveIndexEventArgs`1<TValue>> mySignalBeforeAddRemove;
    [NotNullAttribute]
private IList`1<TValue> myStorage;
    [CanBeNullAttribute]
private Csa<TValue> myCsa;
    private object System.Collections.IList.Item { get; private set; }
    private bool System.Collections.IList.IsFixedSize { get; }
    public TValue Item { get; public set; }
    public ISignal`1<AddRemoveIndexEventArgs`1<TValue>> AddRemove { get; }
    public ISignal`1<BeforeAddRemoveIndexEventArgs`1<TValue>> BeforeAddRemove { get; }
    public ListEvents`1(PropertyId`1<TValue> id, IList`1<TValue> storage, bool bUniqueItems, ILogger logger);
    [ObsoleteAttribute("Use overloads without lifetime.")]
[EditorBrowsableAttribute("1")]
public ListEvents`1(Lifetime lifetime, PropertyId`1<TValue> id, IList`1<TValue> storage, bool bUniqueItems, ILogger logger);
    public ListEvents`1(PropertyId`1<TValue> id, IList`1<TValue> storage, bool bUniqueItems);
    public ListEvents`1(string id, IList`1<TValue> storage, bool bUniqueItems);
    [ObsoleteAttribute("Use overloads without lifetime.")]
[EditorBrowsableAttribute("1")]
public ListEvents`1(Lifetime lifetime, string id, IList`1<TValue> storage, bool bUniqueItems);
    public ListEvents`1(string id);
    [ObsoleteAttribute("Use overloads without lifetime.")]
[EditorBrowsableAttribute("1")]
public ListEvents`1(Lifetime lifetime, string id);
    public ListEvents`1(string id, bool bUniqueItems);
    public ListEvents`1(PropertyId`1<TValue> id, bool bUniqueItems);
    [ObsoleteAttribute("Use overloads without lifetime.")]
[EditorBrowsableAttribute("1")]
public ListEvents`1(Lifetime lifetime, string id, bool bUniqueItems);
    protected ListEvents`1(SerializationInfo info, StreamingContext context);
    private static ListEvents`1();
    protected void FireAddRemove(AddRemove action, TValue value, int index, object cookie);
    protected bool FireBeforeAddRemove(AddRemove action, TValue value, int index, object cookie);
    protected virtual bool ListAddCore(TValue value, int nIndexOrEnd, object cookie);
    protected virtual bool ListRemoveCore(int index, object cookie);
    private void OnAcknowledgeSinkAddRemove_Add(Action`1<AddRemoveIndexEventArgs`1<TValue>> handler);
    private void OnAcknowledgeSinkAddRemove_Remove(Action`1<AddRemoveIndexEventArgs`1<TValue>> handler);
    private bool OnAcknowledgeSinkBeforeAddRemove(Action`1<BeforeAddRemoveIndexEventArgs`1<TValue>> handler);
    protected virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    protected virtual bool CollectionAddCore(TValue value, object cookie);
    protected virtual bool CollectionRemoveCore(TValue value, object cookie);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object value);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string text);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    public sealed virtual TValue get_Item(int index);
    public sealed virtual void set_Item(int index, TValue value);
    public sealed virtual int IndexOf(TValue item);
    public sealed virtual void Insert(int index, TValue item);
    public bool Insert(int index, TValue item, object cookie);
    public sealed virtual bool Modify(AddRemove action, TValue item, int index, object cookie);
    public sealed virtual bool Modify(AddRemove action, Func`1<TValue> funcGetItemIfAdding, int index, object cookie);
    public sealed virtual void RemoveAt(int index);
    public bool RemoveAt(int index, object cookie);
    public sealed virtual ISignal`1<AddRemoveIndexEventArgs`1<TValue>> get_AddRemove();
    public sealed virtual ISignal`1<BeforeAddRemoveIndexEventArgs`1<TValue>> get_BeforeAddRemove();
    [CompilerGeneratedAttribute]
internal static ArgumentException <ListAddCore>g__ErrorAlreadyPresent|18_0(PropertyId`1<TValue> id, TValue value);
    [CompilerGeneratedAttribute]
internal static ArgumentException <CollectionRemoveCore>g__ErrorMissing|25_0(TValue value, PropertyId`1<TValue> id);
    [CompilerGeneratedAttribute]
internal static InvalidOperationException <CollectionRemoveCore>g__ErrorUnknown|25_1(TValue value, PropertyId`1<TValue> id);
}
[DebuggerStepThroughAttribute]
[ObsoleteAttribute("remove and use the one-type-param PropertyChangedEventArgs")]
public class JetBrains.DataFlow.PropertyChangedEventArgs`2 : EventArgs {
    [CanBeNullAttribute]
private TIdentity myIdentity;
    [CanBeNullAttribute]
private TValue myNew;
    [CanBeNullAttribute]
private TValue myOld;
    [CanBeNullAttribute]
public TIdentity Identity { get; }
    [CanBeNullAttribute]
public TValue New { get; }
    [CanBeNullAttribute]
public TValue Old { get; }
    public PropertyChangedEventArgs`2(TIdentity identity, TValue old, TValue new);
    public TIdentity get_Identity();
    public TValue get_New();
    public TValue get_Old();
}
public static class JetBrains.DataFlow.RegistryValueProperty : object {
    public static IProperty`1<TValue> CreatePassive(Lifetime lifetime, RegistryKey keyRoot, string sKeyPath, string sDataName, TValue defvalue);
}
public class JetBrains.DataStructures.CyclicBuffer : object {
    private int _end;
    private InputStream _input;
    private OutputStream _output;
    private int _start;
    private Byte[] _storage;
    public int Capacity { get; public set; }
    [NotNullAttribute]
public InputStream Input { get; }
    public OutputStream Output { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public int get_Capacity();
    public void set_Capacity(int value);
    public InputStream get_Input();
    public OutputStream get_Output();
    private int ReadCore(Byte[] arTarget, int nTargetOffset, int nTargetCount, BehaviorFlags behavior, bool bAdvanceReadPosition);
    private void Resize(int nNewSize);
    private void WriteCore(Byte[] arSource, int nSourceOffset, int nSourceCount, BehaviorFlags behavior);
    public sealed virtual void Add(byte item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(byte item);
    public sealed virtual void CopyTo(Byte[] array, int arrayIndex);
    [IteratorStateMachineAttribute("JetBrains.DataStructures.CyclicBuffer/<GetEnumerator>d__20")]
public sealed virtual IEnumerator`1<byte> GetEnumerator();
    public sealed virtual bool Remove(byte item);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
}
public static class JetBrains.DataStructures.StreamPipe : object {
    public static void Run(Action`1<Stream> funcWriter, Action`1<Stream> funcReader, ITaskHost tasker);
}
public static class JetBrains.DataStructures.StreamPipeXml : object {
    public static void Run(Action`1<XmlWriter> FInput, Action`1<XmlReader> FOutput, ITaskHost tasker);
    public static void Run(Action`1<XmlWriter> FInput, Action`2<XmlReader, XmlWriter> FTransform, Action`1<XmlReader> FOutput, ITaskHost tasker);
}
[ExtensionAttribute]
public static class JetBrains.Extension.DateTimeEx : object {
    public static DateTime UnixEpoch;
    private static DateTimeEx();
    [ExtensionAttribute]
public static string ToRelativeTime(DateTime dateTime);
    private static string Decorate(string delta, DateTime dateTime);
}
[ExtensionAttribute]
public static class JetBrains.Extension.SupportInitializeExtensions : object {
    [ExtensionAttribute]
public static IDisposable InitScope(ISupportInitialize component);
}
public class JetBrains.SlruCache`2 : object {
    private static Statistics Statistics;
    private static Func`4<K, V, TimeSpan, bool> EvictNever;
    [NotNullAttribute]
private Func`2<K, V> myProducer;
    [NotNullAttribute]
private Entry[] myEntries;
    [NotNullAttribute]
private Int32[] myProbationaryQueue;
    [NotNullAttribute]
private Int32[] myProtectedQueue;
    [CanBeNullAttribute]
private IEqualityComparer`1<K> myComparer;
    private int myProbationarySize;
    private int myProtectedSize;
    private int myEntriesSize;
    private int myFirstFreeEntry;
    private TimeSpan myEvictPeriod;
    private Func`4<K, V, TimeSpan, bool> myEvictPredicate;
    private DateTime myLastEvict;
    public int Count { get; }
    public SlruCache`2(int capacity);
    public SlruCache`2(int capacity, Func`4<K, V, TimeSpan, bool> evictPredicate, TimeSpan evictionPeriod);
    public SlruCache`2(int probationaryCapacity, int protectedCapacity);
    public SlruCache`2(IEqualityComparer`1<K> comparer, int probationaryCapacity, int protectedCapacity);
    public SlruCache`2(Func`2<K, V> producer);
    public SlruCache`2(Func`2<K, V> producer, int capacity);
    public SlruCache`2(Func`2<K, V> producer, int probationaryCapacity, int protectedCapacity);
    public SlruCache`2(Func`2<K, V> producer, IEqualityComparer`1<K> equalityComparer, int probationaryCapacity, int protectedCapacity, Func`4<K, V, TimeSpan, bool> evictPredicate, TimeSpan evictionPeriod);
    private static SlruCache`2();
    private void Initialize();
    public void EvictConditionally();
    private void EvictFromQueue(Int32[] queue, Int32& size, DateTime now);
    public int get_Count();
    public void Invalidate(K key);
    private void InvalidateImpl(K key);
    private bool RemoveKey(K key, Int32[] queue, Int32& size);
    public void Clear();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [IteratorStateMachineAttribute("JetBrains.SlruCache`2/<GetEnumerator>d__32")]
public sealed virtual IEnumerator`1<KeyValuePair`2<K, V>> GetEnumerator();
    public bool Lookup(K key, V& value);
    public void Provide(K key, V value);
    public V GetValue(K key);
    private void ProtectedHit(int i);
    private void ProbationaryHit(int i);
    private V CacheMiss(K key);
    private bool KeysEqual(K x, K y);
    private static V EmptyProducer(K k);
}
public class JetBrains.TextChange : object {
    [CompilerGeneratedAttribute]
private TextRange <Range>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NewText>k__BackingField;
    public TextRange Range { get; }
    public string NewText { get; }
    private int LengthDelta { get; }
    public TextChange(TextRange range, string newText);
    [CompilerGeneratedAttribute]
public TextRange get_Range();
    [CompilerGeneratedAttribute]
public string get_NewText();
    private int get_LengthDelta();
    private TextChange Shift(int offset);
    public static void ApplyChanges(IEnumerable`1<TextChange> changes, Action`1<TextChange> makeChange);
    public static int TranslateOffset(IEnumerable`1<TextChange> changes, int offset);
    private static List`1<TextChange> GetSortedChanges(IEnumerable`1<TextChange> changes);
}
public enum JetBrains.UI.Anchoring : Enum {
    public int value__;
    public static Anchoring NearWithout;
    public static Anchoring NearWithin;
    public static Anchoring MiddleWithin;
    public static Anchoring FarWithin;
    public static Anchoring FarWithout;
}
public class JetBrains.UI.Anchoring2D : ValueType {
    public static int BitsPerDim;
    public static int DimMask;
    public static int HorizontalMask;
    public static int HorizontalShift;
    public static int VerticalMask;
    public static int VerticalShift;
    public static Anchoring2D Empty;
    private static Anchoring2D[] myAnchorAside;
    private static Anchoring2D[] myAnchorBottomOrTop;
    private static Anchoring2D[] myAnchorLeftOrRightOnly;
    private static Anchoring2D[] myAnchorTop;
    private static Anchoring2D[] myAnchorTopOrBottom;
    public int Value;
    public static Anchoring2D[] AnchorAside { get; }
    public static Anchoring2D[] AnchorAsideNonCentered { get; }
    public static Anchoring2D[] AnchorBottomOrTop { get; }
    public static Anchoring2D[] AnchorLeftOrRightOnly { get; }
    public static Anchoring2D[] AnchorTop { get; }
    public static Anchoring2D[] AnchorTopOrBottom { get; }
    public Anchoring Horizontal { get; public set; }
    public bool IsInside { get; }
    public Anchoring Vertical { get; public set; }
    public Anchoring2D(int value);
    public Anchoring2D(Anchoring horizontal, Anchoring vertical);
    private static Anchoring2D();
    public static Anchoring2D[] get_AnchorAside();
    public static Anchoring2D[] get_AnchorAsideNonCentered();
    public static Anchoring2D[] get_AnchorBottomOrTop();
    public static Anchoring2D[] get_AnchorLeftOrRightOnly();
    public static Anchoring2D[] get_AnchorTop();
    public static Anchoring2D[] get_AnchorTopOrBottom();
    public Anchoring get_Horizontal();
    public void set_Horizontal(Anchoring value);
    public bool get_IsInside();
    public Anchoring get_Vertical();
    public void set_Vertical(Anchoring value);
    public static bool IsFar(Anchoring anchoring);
    public static bool IsNear(Anchoring anchoring);
    [NotNullAttribute]
public Anchoring2D[] ToArray();
    public sealed virtual bool Equals(Anchoring2D other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static bool op_Equality(Anchoring2D α, Anchoring2D β);
    public static int op_Implicit(Anchoring2D anchoring);
    public static Anchoring2D op_Implicit(int value);
    public static bool op_Inequality(Anchoring2D ξ, Anchoring2D η);
}
public enum JetBrains.UI.ExpectedBackgroundColorHintMode : Enum {
    public int value__;
    public static ExpectedBackgroundColorHintMode Semblance;
    public static ExpectedBackgroundColorHintMode Contrast;
}
[ExtensionAttribute]
public static class JetBrains.UI.Interop.HResultsEx : object {
    [ExtensionAttribute]
public static void Assert(HResults hresult);
    [ExtensionAttribute]
public static void Assert(HResults hresult, string comment);
    [ExtensionAttribute]
public static void AssertSucceeded(int hresult, string comment);
    [ExtensionAttribute]
public static void AssertSucceeded(UInt32 hresult, string comment);
    [ExtensionAttribute]
public static void AssertSucceeded(int hresult);
    [ExtensionAttribute]
public static bool Failed(HResults hresult);
    [ExtensionAttribute]
public static bool Succeeded(HResults hresult);
    [ExtensionAttribute]
[SourceTemplateAttribute]
public static void hr(int hresult);
}
public class JetBrains.UI.RenderParams : object {
    [CanBeNullAttribute]
private JetFont myFontOverride;
    private Nullable`1<JetFontStyles> myFontStyleOverride;
    private JetRgbaColor myNeutralForegroundColor;
    private JetRgbaColor myNeutralBackgroundColor;
    private ExpectedBackgroundColorHintMode myExpectedBackgroundColorHintMode;
    private JetRgbaColor myExpectedBackgroundColorHint;
    private JetTextLineTrimming myTrimming;
    private MnemonicRendering myMnemonics;
    private JetRgbaColor myOverrideForegroundColor;
    private JetRgbaColor myOverrideBackgroundColor;
    private EffectStyle myEffect;
    private JetRgbaColor myEffectColor;
    private TextRenderingMethod myTextRenderingMethod;
    private bool myReadonly;
    [CanBeNullAttribute]
private static RenderParams myEmpty;
    private static TextRenderingMethod myDefaultTextRenderingMethod;
    [CanBeNullAttribute]
public JetFont FontOverride { get; public set; }
    public Nullable`1<JetFontStyles> FontStyleOverride { get; public set; }
    public JetRgbaColor NeutralForegroundColor { get; public set; }
    public JetRgbaColor NeutralBackgroundColor { get; public set; }
    public JetRgbaColor ExpectedBackgroundColorHint { get; public set; }
    public ExpectedBackgroundColorHintMode ExpectedBackgroundColorHintMode { get; public set; }
    public JetTextLineTrimming Trimming { get; public set; }
    public MnemonicRendering Mnemonics { get; public set; }
    public JetRgbaColor OverrideForegroundColor { get; public set; }
    public JetRgbaColor OverrideBackgroundColor { get; public set; }
    public EffectStyle Effect { get; public set; }
    public JetRgbaColor EffectColor { get; public set; }
    public TextRenderingMethod TextRenderingMethod { get; public set; }
    public static RenderParams Empty { get; }
    public static TextRenderingMethod DefaultTextRenderingMethod { get; }
    public bool Readonly { get; }
    private RenderParams(bool readonly);
    private static RenderParams();
    public JetFont get_FontOverride();
    public void set_FontOverride(JetFont value);
    public Nullable`1<JetFontStyles> get_FontStyleOverride();
    public void set_FontStyleOverride(Nullable`1<JetFontStyles> value);
    public JetRgbaColor get_NeutralForegroundColor();
    public void set_NeutralForegroundColor(JetRgbaColor value);
    public JetRgbaColor get_NeutralBackgroundColor();
    public void set_NeutralBackgroundColor(JetRgbaColor value);
    public JetRgbaColor get_ExpectedBackgroundColorHint();
    public void set_ExpectedBackgroundColorHint(JetRgbaColor value);
    public ExpectedBackgroundColorHintMode get_ExpectedBackgroundColorHintMode();
    public void set_ExpectedBackgroundColorHintMode(ExpectedBackgroundColorHintMode value);
    public JetTextLineTrimming get_Trimming();
    public void set_Trimming(JetTextLineTrimming value);
    public MnemonicRendering get_Mnemonics();
    public void set_Mnemonics(MnemonicRendering value);
    public JetRgbaColor get_OverrideForegroundColor();
    public void set_OverrideForegroundColor(JetRgbaColor value);
    public JetRgbaColor get_OverrideBackgroundColor();
    public void set_OverrideBackgroundColor(JetRgbaColor value);
    public EffectStyle get_Effect();
    public void set_Effect(EffectStyle value);
    public JetRgbaColor get_EffectColor();
    public void set_EffectColor(JetRgbaColor value);
    public TextRenderingMethod get_TextRenderingMethod();
    public void set_TextRenderingMethod(TextRenderingMethod value);
    public static RenderParams get_Empty();
    public static TextRenderingMethod get_DefaultTextRenderingMethod();
    public bool get_Readonly();
    public RenderParams Clone();
    private sealed virtual override object System.ICloneable.Clone();
    public void DumpToXaml(XmlWriter writer);
    public void ResetColors();
    public void SetReadonly();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[FlagsAttribute]
public enum JetBrains.UI.RichText.JetFontStyles : Enum {
    public int value__;
    public static JetFontStyles Regular;
    public static JetFontStyles Bold;
    public static JetFontStyles Italic;
}
[ExtensionAttribute]
public static class JetBrains.UI.RichText.LocalizedRichTextExtension : object {
    [ExtensionAttribute]
public static RichText NON_LOCALIZABLE(RichText self);
    [ExtensionAttribute]
public static RichText TODO(RichText self);
    [ExtensionAttribute]
public static RichText IMPORTANT_TODO(RichText self);
}
[DebuggerDisplayAttribute("Offset: {Offset} "{Text}"")]
public class JetBrains.UI.RichText.RichString : object {
    [DebuggerBrowsableAttribute("0")]
private int myOffset;
    [DebuggerBrowsableAttribute("0")]
private int myLength;
    private RichText myRichText;
    [CompilerGeneratedAttribute]
private TextStyle <Style>k__BackingField;
    public string Text { get; }
    [DebuggerBrowsableAttribute("3")]
public TextStyle Style { get; public set; }
    public int Offset { get; internal set; }
    public int Length { get; internal set; }
    [DebuggerBrowsableAttribute("0")]
public RichText RichText { get; internal set; }
    public int EndOffset { get; }
    public RichString(int offset, int length, TextStyle style, RichText richText);
    public RichString(TextRange range, TextStyle style, RichText richText);
    public string get_Text();
    [CompilerGeneratedAttribute]
public TextStyle get_Style();
    [CompilerGeneratedAttribute]
public void set_Style(TextStyle value);
    public int get_Offset();
    internal void set_Offset(int value);
    public int get_Length();
    internal void set_Length(int value);
    public RichText get_RichText();
    internal void set_RichText(RichText value);
    public int get_EndOffset();
    public static TextStyle OverrideTextStyle(RenderParams renderparams, TextStyle localstyle);
    public static JetFontStyles OverrideFontStyle(RenderParams renderParams, TextStyle localStyle);
    [ConditionalAttribute("JET_MODE_ASSERT")]
public void AssertValid();
    public void Dump(XmlWriter writer);
    public sealed virtual int CompareTo(object obj);
    public virtual string ToString();
}
[DebuggerDisplayAttribute("{ToDebugString()}")]
public class JetBrains.UI.RichText.RichText : object {
    internal static bool OptionTrace;
    [DebuggerBrowsableAttribute("0")]
internal FrugalLocalList`1<RichString> myParts;
    [DebuggerBrowsableAttribute("0")]
internal RenderCache myRenderCache;
    [DebuggerBrowsableAttribute("0")]
private StringBuilder myStringBuilder;
    private static Char[] ourBraceCharacters;
    private static Regex ourFormatItemRegex;
    private RichString[] Parts { get; }
    [NotNullAttribute]
public static RichText Empty { get; }
    [DebuggerBrowsableAttribute("0")]
public JetRgbaColor BackgroundColor { get; }
    [DebuggerBrowsableAttribute("0")]
public JetRgbaColor ForegroundColor { get; }
    [DebuggerBrowsableAttribute("0")]
public bool IsEmpty { get; }
    public int Length { get; }
    [NotNullAttribute]
public string Text { get; public set; }
    public RichText(string text, TextStyle style);
    public RichText(string text);
    public RichText(RichTextInterpolatedStringHandler interpolatedStringHandler);
    internal RichText(string text, FrugalLocalList`1<RichString> parts);
    private static RichText();
    private RichString[] get_Parts();
    public static RichText get_Empty();
    public JetRgbaColor get_BackgroundColor();
    public JetRgbaColor get_ForegroundColor();
    public bool get_IsEmpty();
    public int get_Length();
    public string get_Text();
    public void set_Text(string value);
    [NotNullAttribute]
[PureAttribute]
public string GetText(int start, int length);
    [PureAttribute]
public char GetCharAt(int offset);
    public char SetCharAt(int offset, char c);
    [PureAttribute]
public static bool IsNullOrEmpty(RichText richText);
    [NotNullAttribute]
public RichText Append(string s, TextStyle style);
    [NotNullAttribute]
public RichText Insert(int offset, RichText s);
    [NotNullAttribute]
public RichText Append(char c);
    [NotNullAttribute]
public RichText Append(char c, TextStyle style);
    [NotNullAttribute]
public RichText Append(char c, int repeatCount);
    [NotNullAttribute]
public RichText AppendLine(string s);
    [NotNullAttribute]
public RichText AppendLine(string s, TextStyle style);
    [NotNullAttribute]
public RichText AppendLine();
    [NotNullAttribute]
public RichText Append(string s);
    [NotNullAttribute]
public RichText AppendWithLastStyle(string s);
    [NotNullAttribute]
public RichText Append(RichTextInterpolatedStringHandler interpolatedStringHandler);
    [NotNullAttribute]
public RichText AppendLine(RichTextInterpolatedStringHandler interpolatedStringHandler);
    [NotNullAttribute]
public RichText Append(RichText richText);
    [NotNullAttribute]
public RichText Remove(int start, int length);
    [NotNullAttribute]
public RichText Remove(TextRange textRange);
    [ConditionalAttribute("JET_MODE_ASSERT")]
public void AssertValid();
    public void Clear();
    [NotNullAttribute]
[PureAttribute]
public RichText Clone();
    [NotNullAttribute]
public string DumpToString();
    public void DumpToXaml(XmlWriter writer);
    [NotNullAttribute]
[PureAttribute]
public IList`1<RichString> GetFormattedParts();
    [NotNullAttribute]
public RichText Prepend(string s, TextStyle style);
    [NotNullAttribute]
public RichText Prepend(string s);
    [NotNullAttribute]
public RichText PrependWithFirstStyle(string s);
    [NotNullAttribute]
public RichText Prepend(RichText richText);
    public void SetBackColor(JetRgbaColor backColor, int startOffset, int length);
    public void SetBackColor(JetRgbaColor backColor);
    public void SetColors(JetRgbaColor foreColor, JetRgbaColor backColor);
    public void SetColors(JetRgbaColor foreColor, JetRgbaColor backColor, int startOffset, int length);
    public void SetForeColor(JetRgbaColor foreColor);
    public void SetForeColor(JetRgbaColor foreColor, int startOffset, int length);
    public void SetAttributeId(string attributeId);
    public void SetAttributeId(string attributeId, int startOffset, int length);
    public void SetStyle(TextStyle style, int startOffset, int length);
    private void CheckStartAndLength(int startOffset, int length);
    public void SetStyle(JetFontStyles style, int startOffset, int length);
    public void SetStyle(EffectStyle effect, int startOffset, int length, Nullable`1<JetRgbaColor> effectColor);
    public void SetStyle(JetFontStyles style);
    public void SetStyle(TextStyle style);
    public void SetStyle(EffectStyle effect, JetRgbaColor effectColor, int startOffset, int length);
    public void SetStyle(EffectStyle effect, JetRgbaColor effectColor);
    [NotNullAttribute]
public RichText[] Split(int offset);
    [MustUseReturnValueAttribute]
[NotNullAttribute]
public RichText TransformTextStyles(TState state, Func`3<TextStyle, TState, TextStyle> transformStyle);
    [PureAttribute]
[NotNullAttribute]
public RichText SubRichText(int start, int length);
    [PureAttribute]
[NotNullAttribute]
public RichText SubRichText(int start);
    [PureAttribute]
[NotNullAttribute]
public RichText Trim(Char[] trimChars);
    [PureAttribute]
[NotNullAttribute]
public RichText Trim(Func`2<char, bool> isTrimChar);
    [PureAttribute]
[NotNullAttribute]
public RichText TrimEnd(Char[] trimChars);
    [PureAttribute]
[NotNullAttribute]
public RichText TrimEnd(Func`2<char, bool> isTrimChar);
    public void TrimEndInplace(Func`2<char, bool> isTrimChar);
    public void TrimToSingleLineWithMaxLength(int maxLength, string ellipsis);
    [PureAttribute]
[NotNullAttribute]
public RichText TrimStart(Char[] trimChars);
    [PureAttribute]
[NotNullAttribute]
public RichText TrimStart(Func`2<char, bool> isTrimChar);
    [NotNullAttribute]
private IList`1<RichString> BreakString(RichString partSrc, int nLocalOffset, bool bModifyPartsCollection);
    [NotNullAttribute]
public RichText Replace(char a, char b);
    public void Replace(int index, int length, string text);
    private FrugalLocalList`1<RichString> GetPartsFromRangeAndSplit(int startOffset, int length);
    public virtual string ToString();
    [NotNullAttribute]
public string ToStringWithPartDecoration(Func`2<RichString, string> partDecoration);
    public string ToDebugString();
    [ContractAnnotationAttribute("a:null => null; b:null => null; a:notnull, b:notnull => notnull")]
public static RichText op_Addition(RichText a, RichText b);
    [ContractAnnotationAttribute("a:null => null; b:null => null; a:notnull, b:notnull => notnull")]
public static RichText op_Addition(RichText a, string b);
    [ContractAnnotationAttribute("a:null => null; b:null => null; a:notnull, b:notnull => notnull")]
public static RichText op_Addition(string a, RichText b);
    [ContractAnnotationAttribute("null => null; notnull => notnull")]
public static RichText op_Implicit(string text);
    private sealed virtual override object System.ICloneable.Clone();
    public sealed virtual bool Equals(RichText otherRichText);
    public virtual int GetHashCode();
    private sealed virtual override int System.IComparable<JetBrains.UI.RichText.RichText>.CompareTo(RichText other);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    [NotNullAttribute]
[PureAttribute]
[StringFormatMethodAttribute("format")]
[ObsoleteAttribute("To be removed, only an approximation of the string.Format()")]
public static RichText LegacyFormat(RichText format, RichText[] args);
    [NotNullAttribute]
[PureAttribute]
[StringFormatMethodAttribute("format")]
public static RichText Format(string format, Object[] args);
    [NotNullAttribute]
[PureAttribute]
[StringFormatMethodAttribute("format")]
public static RichText Format(RichText format, Object[] args);
    private static RichText RichFormatImpl(string formatText, Object[] args, Action`4<string, int, int, RichText> appendToResult);
    [CompilerGeneratedAttribute]
internal static Nullable`1<int> <Format>g__TryGetAlignment|102_0(Match match);
    [CompilerGeneratedAttribute]
internal static Nullable`1<int> <RichFormatImpl>g__TryGetAlignment|103_0(Match match);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{Text,nq}")]
public class JetBrains.UI.RichText.RichTextBlock : object {
    [DebuggerBrowsableAttribute("0")]
private List`1<RichText> myLines;
    [CompilerGeneratedAttribute]
private RichTextBlockParameters <Parameters>k__BackingField;
    [DebuggerBrowsableAttribute("3")]
public IList`1<RichText> Lines { get; }
    public RichTextBlockParameters Parameters { get; public set; }
    public RichText RichText { get; public set; }
    public string Text { get; public set; }
    public RichTextBlock(RichTextBlockParameters parameters);
    public RichTextBlock(string text);
    public RichTextBlock(string text, RichTextBlockParameters parameters);
    public RichTextBlock(RichText richText);
    public RichTextBlock(RichText richText, RichTextBlockParameters parameters);
    public RichTextBlock(RichTextBlock block);
    public IList`1<RichText> get_Lines();
    [CompilerGeneratedAttribute]
public RichTextBlockParameters get_Parameters();
    [CompilerGeneratedAttribute]
public void set_Parameters(RichTextBlockParameters value);
    public RichText get_RichText();
    public void set_RichText(RichText value);
    public string get_Text();
    public void set_Text(string value);
    [NullableContextAttribute("2")]
public static bool IsNullOrEmpty(RichTextBlock text);
    [NullableContextAttribute("2")]
public static bool IsNullOrWhiteSpace(RichTextBlock text);
    public void SplitAndAdd(RichText value);
    public int Add(RichText line);
    public void AddLines(RichTextBlock lines);
    public void AddLines(IEnumerable`1<RichText> lines);
    public void AddLinesCloned(RichTextBlock lines);
    public RichTextBlock Clone();
    public void DumpToXaml(XmlWriter writer);
    public void InsertLine(RichText line, int index);
    public void RemoveLine(RichText line);
    public void RemoveLineAt(int index);
    public string ToStringWithPartDecoration(Func`2<RichString, string> partDecoration);
    public virtual string ToString();
    [NullableContextAttribute("2")]
[ContractAnnotationAttribute("null => null; notnull => notnull")]
public static RichText op_Explicit(RichTextBlock value);
    [NullableContextAttribute("2")]
[ContractAnnotationAttribute("null => null; notnull => notnull")]
public static RichTextBlock op_Explicit(RichText value);
    [NullableContextAttribute("2")]
[ContractAnnotationAttribute("null => null; notnull => notnull")]
public static string op_Explicit(RichTextBlock value);
    [NullableContextAttribute("2")]
[ContractAnnotationAttribute("null => null; notnull => notnull")]
public static RichTextBlock op_Explicit(string value);
    public sealed virtual IEnumerator GetEnumerator();
    [CompilerGeneratedAttribute]
internal static RichText <SplitAndAdd>g__Substring|22_0(string inputText, FrugalLocalList`1<RichString> inputParts, TextRange range, Int32& partIndex);
}
public class JetBrains.UI.RichText.RichTextBlockParameters : ValueType {
    [CompilerGeneratedAttribute]
private ContentAlignment <Alignment>k__BackingField;
    [CompilerGeneratedAttribute]
private int <InterlineSpacing>k__BackingField;
    public static RichTextBlockParameters Default { get; }
    public ContentAlignment Alignment { get; public set; }
    public int InterlineSpacing { get; public set; }
    public RichTextBlockParameters(int interlineSpacing, ContentAlignment alignment);
    public RichTextBlockParameters(int interlineSpacing);
    public static RichTextBlockParameters get_Default();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ContentAlignment get_Alignment();
    [CompilerGeneratedAttribute]
public void set_Alignment(ContentAlignment value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_InterlineSpacing();
    [CompilerGeneratedAttribute]
public void set_InterlineSpacing(int value);
    [NullableContextAttribute("1")]
public void DumpToXaml(XmlWriter writer);
    [NullableContextAttribute("1")]
public virtual string ToString();
}
[ExtensionAttribute]
public static class JetBrains.UI.RichText.RichTextBlockToHtml : object {
    [ExtensionAttribute]
[ContractAnnotationAttribute("null => null; notnull => notnull")]
public static string ToHtml(RichTextBlock block);
}
[ExtensionAttribute]
public static class JetBrains.UI.RichText.RichTextEx : object {
    [ExtensionAttribute]
[ContractAnnotationAttribute("null=>true")]
public static bool IsNullOrEmpty(RichText thіs);
    [ExtensionAttribute]
[PureAttribute]
public static RichText Join(IEnumerable`1<RichText> texts, RichText separator);
    [ExtensionAttribute]
public static RichText Capitalize(RichText richText);
    [ExtensionAttribute]
[ContractAnnotationAttribute("null=>true")]
public static bool IsNullOrEmpty(RichTextBlock thіs);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static RichText ReadRichText(UnsafeReader unreader);
    [ExtensionAttribute]
public static void WriteRichText(UnsafeWriter unwriter, RichText value);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static RichTextBlock ReadRichTextBlock(UnsafeReader unreader);
    [ExtensionAttribute]
public static void WriteRichTextBlock(UnsafeWriter unwriter, RichTextBlock value);
}
public class JetBrains.UI.RichText.TextStyle : ValueType {
    [DebuggerBrowsableAttribute("0")]
private JetFontStyles myFontStyle;
    [DebuggerBrowsableAttribute("0")]
private JetRgbaColor myForegroundColor;
    [DebuggerBrowsableAttribute("0")]
private JetRgbaColor myBackgroundColor;
    [DebuggerBrowsableAttribute("0")]
private EffectStyle myEffect;
    [DebuggerBrowsableAttribute("0")]
private JetRgbaColor myEffectColor;
    [CompilerGeneratedAttribute]
private string <AttributeId>k__BackingField;
    [CompilerGeneratedAttribute]
private static TextStyle <Default>k__BackingField;
    [CompilerGeneratedAttribute]
private static TextStyle <Hidden>k__BackingField;
    public JetFontStyles FontStyle { get; public set; }
    public JetRgbaColor ForegroundColor { get; public set; }
    public JetRgbaColor BackgroundColor { get; public set; }
    public EffectStyle Effect { get; public set; }
    public JetRgbaColor EffectColor { get; public set; }
    [CanBeNullAttribute]
public string AttributeId { get; public set; }
    public static TextStyle Default { get; }
    public static TextStyle Hidden { get; }
    public static JetRgbaColor DefaultForegroundColor { get; }
    public static JetRgbaColor DefaultBackgroundColor { get; }
    public TextStyle(JetFontStyles fontStyle, JetRgbaColor foregroundColor, JetRgbaColor backgroundColor);
    public TextStyle(JetFontStyles fontStyle, JetRgbaColor foregroundColor);
    public TextStyle(JetFontStyles fontStyle, JetRgbaColor foregroundColor, JetRgbaColor backgroundColor, EffectStyle effect, JetRgbaColor effectColor, string attributeId);
    public TextStyle(JetFontStyles fontStyle);
    public TextStyle(EffectStyle effect);
    public TextStyle(JetRgbaColor foregroundColor, JetRgbaColor backgroundColor);
    public TextStyle(string attributeId);
    private static TextStyle();
    [PureAttribute]
public static TextStyle FromBackColor(JetRgbaColor color);
    [PureAttribute]
public static TextStyle FromForeColor(JetRgbaColor color);
    public JetFontStyles get_FontStyle();
    public void set_FontStyle(JetFontStyles value);
    public JetRgbaColor get_ForegroundColor();
    public void set_ForegroundColor(JetRgbaColor value);
    public JetRgbaColor get_BackgroundColor();
    public void set_BackgroundColor(JetRgbaColor value);
    public EffectStyle get_Effect();
    public void set_Effect(EffectStyle value);
    public JetRgbaColor get_EffectColor();
    public void set_EffectColor(JetRgbaColor value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_AttributeId();
    [CompilerGeneratedAttribute]
public void set_AttributeId(string value);
    [CompilerGeneratedAttribute]
public static TextStyle get_Default();
    [CompilerGeneratedAttribute]
public static TextStyle get_Hidden();
    public static JetRgbaColor get_DefaultForegroundColor();
    public static JetRgbaColor get_DefaultBackgroundColor();
    public void Dump(XmlWriter writer);
    public sealed virtual bool Equals(TextStyle other);
    [PureAttribute]
public sealed virtual TextStyle Clone();
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private sealed virtual override object System.ICloneable.Clone();
    public static bool op_Equality(TextStyle left, TextStyle right);
    public static bool op_Inequality(TextStyle left, TextStyle right);
    private sealed virtual override int System.IComparable<JetBrains.UI.RichText.TextStyle>.CompareTo(TextStyle other);
}
public class JetBrains.Util.AlphanumericComparer : object {
    public sealed virtual int Compare(string x, string y);
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Util.Alternative`1 : ValueType {
    private T myForTrue;
    private T myForFalse;
    public T Item { get; }
    public Alternative`1(T forTrue, T forFalse);
    public T get_Item(bool value);
}
public class JetBrains.Util.Anonymisation.AnonymizerUtil : object {
    public static string Anonymize(string salt, string data);
    public static string Anonymize(Byte[] salt, string data);
    [NotNullAttribute]
private static string ToHexString(Byte[] bytes);
    public static string Anonymize(SByte[] salt, string data);
}
public class JetBrains.Util.Anonymisation.MachineIdManager : object {
    private static int IOREG_COMMAND_TIMEOUT_MS;
    private static Regex ourMacMachineIdPattern;
    private static List`1<string> ourLinuxMachineIdPaths;
    private static ILogger ourLogger;
    private static MachineIdManager();
    [CanBeNullAttribute]
public static string GetAnonymizedMachineId(string purpose, string salt);
    private static string GetMachineId();
    private static string GetLinuxMachineId();
    [CanBeNullAttribute]
private static string GetMacOsMachineId();
}
public class JetBrains.Util.AppDomainDumper : object {
    public static void DumpDomain();
    public static void DumpDomain(FileSystemPath path);
    public static void DumpDomain(AppDomain domain, TextWriter writer);
    private static void DumpAssembly(TextWriter writer, Assembly assembly, Dictionary`2<AssemblyNameInfo, Assembly> loadedAssemblies, HashSet`1<AssemblyNameInfo> seen, int indent);
    private static string GetCodeBaseSafe(Assembly assembly);
    private static void Indent(TextWriter writer, int indent);
}
[LocalizableAttribute("False")]
public static class JetBrains.Util.AssertionWithSensitiveData : object {
    [ContractAnnotationAttribute("condition:false=>void")]
[AssertionMethodAttribute]
[ConditionalAttribute("JET_MODE_ASSERT")]
public static void Assert(bool condition, string message, Pair`2[] sensitiveData);
    [ContractAnnotationAttribute("condition:false=>void")]
[AssertionMethodAttribute]
[ConditionalAttribute("JET_MODE_ASSERT")]
public static void Assert(bool condition, string message, Pair`2<string, object> d1);
    [ContractAnnotationAttribute("condition:false=>void")]
[AssertionMethodAttribute]
[ConditionalAttribute("JET_MODE_ASSERT")]
public static void Assert(bool condition, string message, Pair`2<string, object> d1, Pair`2<string, object> d2);
    [ContractAnnotationAttribute("condition:false=>void")]
[AssertionMethodAttribute]
[ConditionalAttribute("JET_MODE_ASSERT")]
public static void Assert(bool condition, string message, Pair`2<string, object> d1, Pair`2<string, object> d2, Pair`2<string, object> d3);
    [ContractAnnotationAttribute("condition:false=>void")]
[AssertionMethodAttribute]
[StringFormatMethodAttribute("message")]
[ConditionalAttribute("JET_MODE_ASSERT")]
public static void Assert(bool condition, string message, Pair`2[] sensitiveData, T arg);
    [ContractAnnotationAttribute("condition:false=>void")]
[AssertionMethodAttribute]
[StringFormatMethodAttribute("message")]
[ConditionalAttribute("JET_MODE_ASSERT")]
public static void Assert(bool condition, string message, Pair`2<string, object> d1, T arg);
    [ContractAnnotationAttribute("condition:false=>void")]
[AssertionMethodAttribute]
[StringFormatMethodAttribute("message")]
[ConditionalAttribute("JET_MODE_ASSERT")]
public static void Assert(bool condition, string message, Pair`2<string, object> d1, Pair`2<string, object> d2, T arg);
    [ContractAnnotationAttribute("condition:false=>void")]
[AssertionMethodAttribute]
[StringFormatMethodAttribute("message")]
[ConditionalAttribute("JET_MODE_ASSERT")]
public static void Assert(bool condition, string message, Pair`2[] sensitiveData, T1 arg1, T2 arg2);
    [ContractAnnotationAttribute("condition:false=>void")]
[AssertionMethodAttribute]
[StringFormatMethodAttribute("message")]
[ConditionalAttribute("JET_MODE_ASSERT")]
public static void Assert(bool condition, string message, Pair`2<string, object> d1, T1 arg1, T2 arg2);
    [ContractAnnotationAttribute("condition:false=>void")]
[AssertionMethodAttribute]
[StringFormatMethodAttribute("message")]
[ConditionalAttribute("JET_MODE_ASSERT")]
public static void Assert(bool condition, string message, Pair`2<string, object> d1, Pair`2<string, object> d2, T1 arg1, T2 arg2);
    [ContractAnnotationAttribute("condition:false=>void")]
[AssertionMethodAttribute]
[StringFormatMethodAttribute("message")]
[ConditionalAttribute("JET_MODE_ASSERT")]
public static void Assert(bool condition, string message, Pair`2[] sensitiveData, T1 arg1, T2 arg2, T3 arg3);
    [ContractAnnotationAttribute("condition:false=>void")]
[AssertionMethodAttribute]
[StringFormatMethodAttribute("message")]
[ConditionalAttribute("JET_MODE_ASSERT")]
public static void Assert(bool condition, string message, Pair`2[] sensitiveData, T1 arg1, T2 arg2, T3 arg3, T4 arg4);
    [ContractAnnotationAttribute("condition:false=>void")]
[AssertionMethodAttribute]
[StringFormatMethodAttribute("message")]
[ConditionalAttribute("JET_MODE_ASSERT")]
public static void Assert(bool condition, string message, Pair`2[] sensitiveData, Object[] args);
    [ContractAnnotationAttribute("=>void")]
[AssertionMethodAttribute]
public static void Fail(string message, Pair`2[] sensitiveData);
    [ContractAnnotationAttribute("condition:null=>void")]
[AssertionMethodAttribute]
[ConditionalAttribute("JET_MODE_ASSERT")]
public static void AssertNotNull(object condition, string message, Pair`2[] sensitiveData);
    [ContractAnnotationAttribute("condition:null=>void")]
[AssertionMethodAttribute]
[ConditionalAttribute("JET_MODE_ASSERT")]
public static void AssertNotNull(object condition, string message, Pair`2[] sensitiveData, object arg1);
    [ContractAnnotationAttribute("condition:null=>void")]
[AssertionMethodAttribute]
[ConditionalAttribute("JET_MODE_ASSERT")]
public static void AssertNotNull(object condition, string message, Pair`2[] sensitiveData, object arg1, object arg2);
    [ContractAnnotationAttribute("condition:null=>void")]
[AssertionMethodAttribute]
[ConditionalAttribute("JET_MODE_ASSERT")]
public static void AssertNotNull(object condition, string message, Pair`2[] sensitiveData, object arg1, object arg2, object arg3);
    [ContractAnnotationAttribute("condition:null=>void")]
[AssertionMethodAttribute]
[ConditionalAttribute("JET_MODE_ASSERT")]
public static void AssertNotNull(object condition, string message, Pair`2[] sensitiveData, Object[] args);
    [ContractAnnotationAttribute("condition:null=>void")]
[AssertionMethodAttribute]
[ConditionalAttribute("JET_MODE_ASSERT")]
public static void AssertNotNull(object condition, string message, Pair`2<string, object> d1);
    [ContractAnnotationAttribute("condition:null=>void")]
[AssertionMethodAttribute]
[ConditionalAttribute("JET_MODE_ASSERT")]
public static void AssertNotNull(object condition, string message, Pair`2<string, object> d1, object arg1);
    [ContractAnnotationAttribute("condition:null=>void")]
[AssertionMethodAttribute]
[ConditionalAttribute("JET_MODE_ASSERT")]
public static void AssertNotNull(object condition, string message, Pair`2<string, object> d1, object arg1, object arg2);
    [ContractAnnotationAttribute("condition:null=>void")]
[AssertionMethodAttribute]
[ConditionalAttribute("JET_MODE_ASSERT")]
public static void AssertNotNull(object condition, string message, Pair`2<string, object> d1, object arg1, object arg2, object arg3);
    [ContractAnnotationAttribute("condition:null=>void")]
[AssertionMethodAttribute]
[ConditionalAttribute("JET_MODE_ASSERT")]
public static void AssertNotNull(object condition, string message, Pair`2<string, object> d1, Object[] args);
    [ContractAnnotationAttribute("condition:null=>void")]
[AssertionMethodAttribute]
[ConditionalAttribute("JET_MODE_ASSERT")]
public static void AssertNotNull(object condition, string message, Pair`2<string, object> d1, Pair`2<string, object> d2);
    [ContractAnnotationAttribute("condition:null=>void")]
[AssertionMethodAttribute]
[ConditionalAttribute("JET_MODE_ASSERT")]
public static void AssertNotNull(object condition, string message, Pair`2<string, object> d1, Pair`2<string, object> d2, object arg1);
    [ContractAnnotationAttribute("condition:null=>void")]
[AssertionMethodAttribute]
[ConditionalAttribute("JET_MODE_ASSERT")]
public static void AssertNotNull(object condition, string message, Pair`2<string, object> d1, Pair`2<string, object> d2, object arg1, object arg2);
    [ContractAnnotationAttribute("condition:null=>void")]
[AssertionMethodAttribute]
[ConditionalAttribute("JET_MODE_ASSERT")]
public static void AssertNotNull(object condition, string message, Pair`2<string, object> d1, Pair`2<string, object> d2, object arg1, object arg2, object arg3);
    [ContractAnnotationAttribute("condition:null=>void")]
[AssertionMethodAttribute]
[ConditionalAttribute("JET_MODE_ASSERT")]
public static void AssertNotNull(object condition, string message, Pair`2<string, object> d1, Pair`2<string, object> d2, Object[] args);
    [ContractAnnotationAttribute("condition:null=>void")]
[AssertionMethodAttribute]
[ConditionalAttribute("JET_MODE_ASSERT")]
public static void AssertNotNull(object condition, string message, Pair`2<string, object> d1, Pair`2<string, object> d2, Pair`2<string, object> d3);
    [ContractAnnotationAttribute("condition:null=>void")]
[AssertionMethodAttribute]
[ConditionalAttribute("JET_MODE_ASSERT")]
public static void AssertNotNull(object condition, string message, Pair`2<string, object> d1, Pair`2<string, object> d2, Pair`2<string, object> d3, object arg1);
    [ContractAnnotationAttribute("condition:null=>void")]
[AssertionMethodAttribute]
[ConditionalAttribute("JET_MODE_ASSERT")]
public static void AssertNotNull(object condition, string message, Pair`2<string, object> d1, Pair`2<string, object> d2, Pair`2<string, object> d3, object arg1, object arg2);
    [ContractAnnotationAttribute("condition:null=>void")]
[AssertionMethodAttribute]
[ConditionalAttribute("JET_MODE_ASSERT")]
public static void AssertNotNull(object condition, string message, Pair`2<string, object> d1, Pair`2<string, object> d2, Pair`2<string, object> d3, object arg1, object arg2, object arg3);
    [ContractAnnotationAttribute("condition:null=>void")]
[AssertionMethodAttribute]
[ConditionalAttribute("JET_MODE_ASSERT")]
public static void AssertNotNull(object condition, string message, Pair`2<string, object> d1, Pair`2<string, object> d2, Pair`2<string, object> d3, Object[] args);
}
public static class JetBrains.Util.AsyncLazy : object {
    [NotNullAttribute]
[PureAttribute]
public static AsyncLazy`1<T> Create(Func`1<T> value);
    [NotNullAttribute]
[PureAttribute]
public static AsyncLazy`1<T> Create(Func`1<Task`1<T>> value);
    [NotNullAttribute]
[PureAttribute]
public static AsyncLazy`1<T> Create(T value);
}
public class JetBrains.Util.AsyncLazy`1 : object {
    private static Func`1<Task`1<TValue>> myAfactoryBusyMarker;
    [CanBeNullAttribute]
private Func`1<Task`1<TValue>> myAfactory;
    [CanBeNullAttribute]
private Task`1<TValue> myValue;
    public AsyncLazy`1(Task`1<TValue> value);
    [ObsoleteAttribute("This overload is incorrect because it ignores the Jet tasks pool and does not specify the lifetime. Use the overload with Lifetime and ITaskHost.")]
public AsyncLazy`1(Func`1<TValue> factory);
    public AsyncLazy`1(Lifetime lifetime, Func`1<TValue> factory, ITaskHost tasker);
    public AsyncLazy`1(Func`1<Task`1<TValue>> afactory);
    private static AsyncLazy`1();
    [UsedImplicitlyAttribute]
public TaskAwaiter`1<TValue> GetAwaiter();
    [NotNullAttribute]
public Task`1<TValue> GetValueAsync();
    [NotNullAttribute]
[HandleProcessCorruptedStateExceptionsAttribute]
private Task`1<TValue> GetValueCold();
    [NotNullAttribute]
protected virtual Task`1<TValue> OnCustomGetValue();
}
public class JetBrains.Util.AsyncStreamReader : object {
    internal static int DefaultBufferSize;
    private static int MinBufferSize;
    private Stream myStream;
    private Encoding myEncoding;
    private Decoder myDecoder;
    private Byte[] myByteBuffer;
    private Char[] myCharBuffer;
    private int myMaxCharsPerBuffer;
    private Action`1<string> myUserCallBack;
    private bool myCancelOperation;
    private ManualResetEvent myEofEvent;
    private Queue myMessageQueue;
    private StringBuilder mySb;
    private bool myBLastCarriageReturn;
    public Encoding CurrentEncoding { get; }
    public Stream BaseStream { get; }
    public AsyncStreamReader(Stream stream, Action`1<string> callback, Encoding encoding);
    internal AsyncStreamReader(Stream stream, Action`1<string> callback, Encoding encoding, int bufferSize);
    private void Init(Stream stream, Action`1<string> callback, Encoding encoding, int bufferSize);
    public virtual void Close();
    private sealed virtual override void System.IDisposable.Dispose();
    protected virtual void Dispose(bool disposing);
    public virtual Encoding get_CurrentEncoding();
    public virtual Stream get_BaseStream();
    public void BeginReadLine();
    internal void CancelOperation();
    private void ReadBuffer(IAsyncResult ar);
    private void GetLinesFromStringBuilder();
    private void FlushMessageQueue();
    public bool WaitUntilEof(int millisecondsTimeout);
}
[ObsoleteAttribute("The implementation has been switched from Dictionary to CompactMap some time ago. This relieved mem pressure in some scenarios, but impaired performance (got a few times slower). Pls choose specifically between BidirectionalMapOnDictionary (if targeting perf without large mem use) or BidirectionalMapOnCompactMap (if hi mem use but not so perf critical).")]
public class JetBrains.Util.BidirectionalMap`2 : object {
    private CompactMap`2<TLeft, TRight> myLeftToRightMap;
    private CompactMap`2<TRight, TLeft> myRightToLeftMap;
    public int Count { get; }
    public ICollection`1<TLeft> LeftKeys { get; }
    public IDictionary`2<TLeft, TRight> LeftToRight { get; }
    public ICollection`1<TRight> RightKeys { get; }
    public IDictionary`2<TRight, TLeft> RightToLeft { get; }
    public BidirectionalMap`2(int capacity);
    public BidirectionalMap`2(int capacity, IEqualityComparer`1<TLeft> leftComparer, IEqualityComparer`1<TRight> rightComparer);
    public BidirectionalMap`2(IEqualityComparer`1<TLeft> leftComparer, IEqualityComparer`1<TRight> rightComparer);
    public int get_Count();
    public ICollection`1<TLeft> get_LeftKeys();
    public IDictionary`2<TLeft, TRight> get_LeftToRight();
    public ICollection`1<TRight> get_RightKeys();
    public IDictionary`2<TRight, TLeft> get_RightToLeft();
    public void Add(TLeft left, TRight right);
    public void Clear();
    public bool ContainsLeft(TLeft left);
    public bool ContainsRight(TRight right);
    public TLeft GetLeftByRight(TRight right);
    public TRight GetRightByLeft(TLeft left);
    public void RemoveLeft(TLeft left);
    public void RemoveMapping(TLeft left, TRight right);
    public void RemoveRight(TRight right);
    public void SetMapping(TLeft left, TRight right, bool bIgnoreConflicts);
    private static ArgumentException CreateDuplicateRightKeysException(TLeft left, TRight right, TLeft oldLeft);
    private static ArgumentException CreateDuplicateLeftKeysException(TLeft left, TRight right, TRight oldRight);
    public bool TryGetLeftByRight(TRight right, TLeft& left);
    public bool TryGetRightByLeft(TLeft left, TRight& right);
    public TLeft GetOrCreateLeftByRight(TRight right, Func`2<TRight, TLeft> factory);
    public TRight GetOrCreateRightByLeft(TLeft left, Func`2<TLeft, TRight> factory);
    public sealed virtual IEnumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<KeyValuePair`2<TLeft, TRight>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TLeft,TRight>>.GetEnumerator();
}
public static class JetBrains.Util.BinarySerializers : object {
    public static Dictionary`2<string, string> ReadStringDictionary(UnsafeReader reader);
    public static void WriteStringOneToList(UnsafeWriter writer, CompactOneToListMap`2<string, string> map);
    public static CompactOneToListMap`2<string, string> ReadStringOneToList(UnsafeReader reader);
    public static void WriteNullCollection(UnsafeWriter writer);
    public static void WriteStringDictionary(UnsafeWriter writer, IDictionary`2<string, string> dict);
    public static void WriteStringCollection(UnsafeWriter writer, ICollection`1<string> strings);
    public static String[] ReadStringCollection(UnsafeReader reader);
}
public class JetBrains.Util.BitArrayUtil : object {
    public static BitArray FromSet(short count, Int16[] values);
    public static Boolean[] BoolArrayFromSet(short count, Int16[] values);
}
public class JetBrains.Util.BitsIncreasedHandler : MulticastDelegate {
    public BitsIncreasedHandler(object object, IntPtr method);
    public virtual void Invoke(int oldBitsCount, int newBitsCount);
    public virtual IAsyncResult BeginInvoke(int oldBitsCount, int newBitsCount, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public static class JetBrains.Util.BooleanBoxes : object {
    [NotNullAttribute]
public static object True;
    [NotNullAttribute]
public static object False;
    private static BooleanBoxes();
}
public static class JetBrains.Util.Build.BuildConstants : object {
    public static Regex ExcludedSystemAssembliesNameRegex;
    public static ImmutableArray`1<string> ReferenceAssembliesForNetFxPrefixes;
    private static BuildConstants();
}
[ExtensionAttribute]
public static class JetBrains.Util.BuildExtensions : object {
    [ExtensionAttribute]
[NotNullAttribute]
public static string GetAssemblyCustomBuildProperty_SemanticVersion(Assembly assembly);
    [ExtensionAttribute]
[NotNullAttribute]
public static string GetAssemblyCustomBuildProperty_WaveMarketingName(Assembly assembly);
    [ExtensionAttribute]
[NotNullAttribute]
public static string GetAssemblyCustomBuildProperty_WaveMarketingNameCompressed(Assembly assembly);
    [ExtensionAttribute]
[NotNullAttribute]
private static string GetAssemblyCustomBuildProperty(Assembly assembly, string key);
}
public class JetBrains.Util.CachedFileSystemData : object {
    [CompilerGeneratedAttribute]
private bool <ExceptionIsFiredOnLastLoad>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <LastWriteTimeUtc>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <AccessTimeUtc>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <CreationTimeUtc>k__BackingField;
    [CompilerGeneratedAttribute]
private FileAttributes <FileAttributes>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FileExists>k__BackingField;
    [CompilerGeneratedAttribute]
private long <FileLength>k__BackingField;
    public bool ExceptionIsFiredOnLastLoad { get; private set; }
    public DateTime LastWriteTimeUtc { get; public set; }
    public DateTime AccessTimeUtc { get; public set; }
    public DateTime CreationTimeUtc { get; public set; }
    public FileAttributes FileAttributes { get; public set; }
    public bool FileExists { get; public set; }
    public long FileLength { get; public set; }
    public CachedFileSystemData(VirtualFileSystemPath location);
    public CachedFileSystemData(DateTime lastWriteTimeUtc, DateTime accessTimeUtc, DateTime creationTimeUtc, FileAttributes fileAttributes, bool fileExists, long fileLength);
    public CachedFileSystemData(VirtualDirectoryEntryData directoryEntryData);
    [CompilerGeneratedAttribute]
public bool get_ExceptionIsFiredOnLastLoad();
    [CompilerGeneratedAttribute]
private void set_ExceptionIsFiredOnLastLoad(bool value);
    [CompilerGeneratedAttribute]
public DateTime get_LastWriteTimeUtc();
    [CompilerGeneratedAttribute]
public void set_LastWriteTimeUtc(DateTime value);
    [CompilerGeneratedAttribute]
public DateTime get_AccessTimeUtc();
    [CompilerGeneratedAttribute]
public void set_AccessTimeUtc(DateTime value);
    [CompilerGeneratedAttribute]
public DateTime get_CreationTimeUtc();
    [CompilerGeneratedAttribute]
public void set_CreationTimeUtc(DateTime value);
    [CompilerGeneratedAttribute]
public FileAttributes get_FileAttributes();
    [CompilerGeneratedAttribute]
public void set_FileAttributes(FileAttributes value);
    [CompilerGeneratedAttribute]
public bool get_FileExists();
    [CompilerGeneratedAttribute]
public void set_FileExists(bool value);
    [CompilerGeneratedAttribute]
public long get_FileLength();
    [CompilerGeneratedAttribute]
public void set_FileLength(long value);
    public void Load(VirtualFileSystemPath path);
}
[FlagsAttribute]
public enum JetBrains.Util.CachedFileSystemDataChangeType : Enum {
    public int value__;
    public static CachedFileSystemDataChangeType None;
    public static CachedFileSystemDataChangeType LastWriteTime;
    public static CachedFileSystemDataChangeType AccessTime;
    public static CachedFileSystemDataChangeType CreationTime;
    public static CachedFileSystemDataChangeType Exists;
    public static CachedFileSystemDataChangeType Size;
    public static CachedFileSystemDataChangeType Attributes;
}
[ExtensionAttribute]
public static class JetBrains.Util.CachedFileSystemDataEx : object {
    [ExtensionAttribute]
public static bool IsFile(CachedFileSystemData data);
    [ExtensionAttribute]
public static bool IsDirectory(CachedFileSystemData data);
    [ExtensionAttribute]
public static CachedFileSystemDataChangeType Compare(CachedFileSystemData data, CachedFileSystemData other);
    [ExtensionAttribute]
public static Pair`2<CachedFileSystemData, CachedFileSystemDataChangeType> RefreshAndGetOld(CachedFileSystemData data, VirtualFileSystemPath path);
}
[ObsoleteAttribute("No usages in ReSharper")]
public class JetBrains.Util.CollectionAdapter`1 : object {
    private ICollection`1<T> myGenericCollection;
    private object mySentry;
    public int Count { get; }
    public object SyncRoot { get; }
    public bool IsSynchronized { get; }
    public CollectionAdapter`1(ICollection`1<T> genericcollection);
    public sealed virtual void CopyTo(Array array, int index);
    public sealed virtual int get_Count();
    public sealed virtual object get_SyncRoot();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual IEnumerator GetEnumerator();
}
public class JetBrains.Util.Collections.AlphanumComparatorFast : object {
    public static IComparer`1<string> Instance;
    private static AlphanumComparatorFast();
    public sealed virtual int Compare(string s1, string s2);
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Util.Collections.CachedEnumerable`1 : object {
    [NotNullAttribute]
private List`1<T> myCache;
    [CanBeNullAttribute]
private IEnumerable`1<T> mySourceEnumerable;
    [CanBeNullAttribute]
private IEnumerator`1<T> myEnumerator;
    private int myCount;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public T Item { get; }
    public CachedEnumerable`1(IEnumerable`1<T> enumerable, int count);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    [IteratorStateMachineAttribute("JetBrains.Util.Collections.CachedEnumerable`1/<EnumerateAndCache>d__6")]
private IEnumerator`1<T> EnumerateAndCache();
    public sealed virtual void Dispose();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual int get_Count();
    public bool get_IsReadOnly();
    public sealed virtual T get_Item(int index);
    private void FillUntil(int index);
}
[ObsoleteAttribute("No usages in ReSharper")]
public class JetBrains.Util.Collections.ComparisonListSorter`1 : object {
    [NotNullAttribute]
private Comparison`1<T> myComparison;
    public ComparisonListSorter`1(Comparison`1<T> comparison);
    public sealed virtual T[] Sort(List`1<T> list);
}
[DefaultMemberAttribute("Item")]
[ThreadUnsafeAttribute]
public class JetBrains.Util.Collections.CountingMultiMap`2 : object {
    private Dictionary`2<TKey, CountingSet`1<TValue>> myMap;
    public IEnumerable`1<TValue> Item { get; }
    public ICollection`1<TKey> Keys { get; }
    public CountingMultiMap`2(int capacity);
    public CountingMultiMap`2(int capacity, IEqualityComparer`1<TKey> comparer);
    private CountingMultiMap`2(Dictionary`2<TKey, CountingSet`1<TValue>> map);
    public int Add(TKey key, TValue value);
    public int Remove(TKey key, TValue value);
    public void Clear();
    public IEnumerable`1<TValue> get_Item(TKey key);
    public ICollection`1<TKey> get_Keys();
}
[ThreadUnsafeAttribute]
public class JetBrains.Util.Collections.CountingSet`1 : object {
    [NotNullAttribute]
private Dictionary`2<T, int> mySet;
    public int Count { get; }
    public CountingSet`1(int capacity);
    public CountingSet`1(int capacity, IEqualityComparer`1<T> comparer);
    public CountingSet`1(CountingSet`1<T> set);
    private CountingSet`1(Dictionary`2<T, int> set);
    public int Add(T item);
    public int Add(T item, int count);
    public int Remove(T item);
    public int RemoveAll(T item);
    public int Remove(T item, int count);
    public void Clear();
    public sealed virtual int GetCount(T item);
    public sealed virtual bool Contains(T item);
    public IEnumerable`1<T> GetItems();
    public Enumerator<T, int> GetEnumerator();
    private sealed virtual override IEnumerator`1<KeyValuePair`2<T, int>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<T,System.Int32>>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual int get_Count();
}
[ThreadUnsafeAttribute]
public class JetBrains.Util.Collections.CountingSetAllowingNegativesNums`1 : object {
    [NotNullAttribute]
private HashMap`2<T, int> mySet;
    public int Count { get; }
    public CountingSetAllowingNegativesNums`1(int capacity);
    public CountingSetAllowingNegativesNums`1(int capacity, IEqualityComparer`1<T> comparer);
    public CountingSetAllowingNegativesNums`1(CountingSetAllowingNegativesNums`1<T> set);
    private CountingSetAllowingNegativesNums`1(HashMap`2<T, int> set);
    public int Increment(T item);
    public int Decrement(T item);
    public int Increment(T item, int count);
    public void Clear();
    public int GetCount(T item);
    public IEnumerable`1<T> GetItems();
    public PairEnumerator<T, int> GetEnumerator();
    private sealed virtual override IEnumerator`1<KeyValuePair`2<T, int>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<T,System.Int32>>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public int get_Count();
}
public class JetBrains.Util.Collections.EmptyWeakRefRetainerCache`1 : object {
    public int Count { get; }
    public IList`1<T> Items { get; }
    public sealed virtual bool Touch(T item);
    public sealed virtual bool Remove(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual int get_Count();
    public sealed virtual int Evict();
    public sealed virtual IList`1<T> get_Items();
}
public class JetBrains.Util.Collections.EnumerableCollection`1 : object {
    [NotNullAttribute]
public static ICollection`1<T> Empty;
    [NotNullAttribute]
private IEnumerable`1<T> myEnumerable;
    private int myCount;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public EnumerableCollection`1(IEnumerable`1<T> enumerable, int count);
    private static EnumerableCollection`1();
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual bool Remove(T item);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[ExtensionAttribute]
public static class JetBrains.Util.Collections.EnumeratorExt : object {
    [ExtensionAttribute]
public static bool AnyElem(TEnumerator source);
    [ExtensionAttribute]
public static bool CountEq(TEnumerator source, int expectedCount);
    [ExtensionAttribute]
public static bool CountLeq(TEnumerator source, int expectedCount);
    [ExtensionAttribute]
public static IEnumeratorWithEnd`1<T> WithEnd(IEnumerator`1<T> src);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class JetBrains.Util.Collections.EqualityComparer : object {
    [PureAttribute]
public static IEqualityComparer`1<T> Create(Func`3<T, T, bool> equals, Func`2<T, int> getHashCode);
    [PureAttribute]
public static IEqualityComparer`1<TSource> Create(Func`2<TSource, TKey> keySelector, IEqualityComparer`1<TKey> keyEqualityComparer);
    [PureAttribute]
public static IEqualityComparer`1<T> DefaultOrReference();
    [PureAttribute]
public static IEqualityComparer`1<IReadOnlyList`1<T>> StructuralForReadOnlyListOf(IEqualityComparer`1<T> itemComparer);
}
[ObsoleteAttribute("No usages in ReSharper")]
public interface JetBrains.Util.Collections.IListSorter`1 {
    public abstract virtual T[] Sort(List`1<T> list);
}
public interface JetBrains.Util.Collections.IReadonlyCountingSet`1 {
    public int Count { get; }
    [PureAttribute]
public abstract virtual int GetCount(T value);
    [PureAttribute]
public abstract virtual bool Contains(T value);
    public abstract virtual int get_Count();
}
[FlagsAttribute]
public enum JetBrains.Util.Collections.JetBinaryTree.AdvancedMatchingResults : Enum {
    public int value__;
    public static AdvancedMatchingResults NoAction;
    public static AdvancedMatchingResults Match;
    public static AdvancedMatchingResults VisitLeft;
    public static AdvancedMatchingResults VisitRight;
    public static AdvancedMatchingResults MatchLast;
    public static AdvancedMatchingResults MatchAndStop;
}
public enum JetBrains.Util.Collections.JetBinaryTree.FindStrategy : Enum {
    public int value__;
    public static FindStrategy Exactly;
    public static FindStrategy NearestBelow;
    public static FindStrategy NearestAbove;
}
public interface JetBrains.Util.Collections.JetBinaryTree.IJetSortedStringDictionary`1 {
    public abstract virtual FrugalLocalList`1<KeyValuePair`2<string, TDataType>> FindEntriesByPrefix(string prefix);
    public abstract virtual FrugalLocalList`1<KeyValuePair`2<string, TDataType>> FindEntriesByPrefix(string prefix, int position, int length);
    public abstract virtual FrugalLocalList`1<TDataType> FindValuesByPrefix(string prefix);
}
[DefaultMemberAttribute("Item")]
[ThreadUnsafeAttribute]
public class JetBrains.Util.Collections.JetBinaryTree.JetBinaryTree`2 : object {
    protected IComparer`1<TKeyType> myComparer;
    private JetBinaryTreeNode`2<TKeyType, TDataType> myJetBinaryTreeTree;
    private int myCount;
    private JetBinaryTreeNode`2<TKeyType, TDataType> mySentinelNode;
    private JetBinaryTreeNode`2<TKeyType, TDataType> myLastNodeFound;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public TDataType Item { get; public set; }
    private IEnumerable`1<TKeyType> System.Collections.Generic.IReadOnlyDictionary<TKeyType,TDataType>.Keys { get; }
    private IEnumerable`1<TDataType> System.Collections.Generic.IReadOnlyDictionary<TKeyType,TDataType>.Values { get; }
    private ICollection`1<TKeyType> System.Collections.Generic.IDictionary<TKeyType,TDataType>.Keys { get; }
    private ICollection`1<TDataType> System.Collections.Generic.IDictionary<TKeyType,TDataType>.Values { get; }
    public JetBinaryTree`2(IComparer`1<TKeyType> comparer);
    protected JetBinaryTree`2(JetBinaryTree`2<TKeyType, TDataType> copyFrom);
    public sealed virtual int get_Count();
    public sealed virtual void Clear();
    public bool IsEmpty();
    public TKeyType GetMinKey();
    private JetBinaryTreeNode`2<TKeyType, TDataType> GetMinNode();
    public TKeyType GetMaxKey();
    public JetBinaryTreeNode`2<TKeyType, TDataType> GetMaxNode();
    public TDataType GetMinValue();
    public TDataType GetMaxValue();
    public ValueTuple`2<TKeyType, TDataType> GetMinPair();
    public ValueTuple`2<TKeyType, TDataType> GetMaxPair();
    [CanBeNullAttribute]
protected JetBinaryTreeNode`2<TKeyType, TDataType> FindNode(TKeyType key);
    [CanBeNullAttribute]
protected JetBinaryTreeNode`2<TKeyType, TDataType> GetFloorNode(TKeyType key, bool inclusive);
    private JetBinaryTreeNode`2<TKeyType, TDataType> GetFloorNode(JetBinaryTreeNode`2<TKeyType, TDataType> node, TKeyType key, bool inclusive);
    [CanBeNullAttribute]
protected JetBinaryTreeNode`2<TKeyType, TDataType> GetCeilingNode(TKeyType key, bool inclusive);
    private JetBinaryTreeNode`2<TKeyType, TDataType> GetCeilingNode(JetBinaryTreeNode`2<TKeyType, TDataType> node, TKeyType key, bool inclusive);
    [NotNullAttribute]
protected JetBinaryTreeNode`2<TKeyType, TDataType> GetNode(TKeyType key);
    public TDataType GetData(TKeyType key);
    public bool TryGetFloorData(TKeyType key, bool inclusive, TDataType& result);
    public bool TryGetCeilingData(TKeyType key, bool inclusive, TDataType& result);
    private bool IterateTree(TParam param, Func`3<TParam, TKeyType, AdvancedMatchingResults> comparer, JetBinaryTreeNode`2<TKeyType, TDataType> treeNode, FrugalLocalList`1& list);
    public FrugalLocalList`1<TDataType> FindData(TParam param, Func`3<TParam, TKeyType, AdvancedMatchingResults> comparer);
    private bool IterateTreePairs(TParam param, Func`3<TParam, TKeyType, AdvancedMatchingResults> comparer, JetBinaryTreeNode`2<TKeyType, TDataType> treeNode, FrugalLocalList`1& list);
    private bool IterateTreePairsWithAction(TParam1 param1, TParam2& param2, Func`3<TParam1, TKeyType, AdvancedMatchingResults> comparer, JetBinaryTreeNode`2<TKeyType, TDataType> treeNode, bool reverse, PairProcessor`1<TKeyType, TDataType, TParam2> action);
    public FrugalLocalList`1<KeyValuePair`2<TKeyType, TDataType>> FindPairs(TParam param, Func`3<TParam, TKeyType, AdvancedMatchingResults> comparer);
    public bool IteratePairsInInterval(TKeyType from, TKeyType to, bool inclusiveFrom, bool inclusiveTo, TParam& param, PairProcessor`1<TKeyType, TDataType, TParam> processor);
    public TDataType FindData(TKeyType key, FindStrategy strategy, TDataType defaultData);
    public void InplaceReplace(TKeyType oldKey, TKeyType newKey, TDataType newData);
    public sealed virtual void Add(TKeyType key, TDataType data);
    private void AddOrReplace(TKeyType key, TDataType data, bool allowReplace);
    protected void RotateLeft(JetBinaryTreeNode`2<TKeyType, TDataType> x);
    protected void RotateRight(JetBinaryTreeNode`2<TKeyType, TDataType> x);
    public sealed virtual bool Remove(TKeyType key);
    [IteratorStateMachineAttribute("JetBrains.Util.Collections.JetBinaryTree.JetBinaryTree`2/<Nodes>d__42")]
public IEnumerable`1<JetBinaryTreeNode`2<TKeyType, TDataType>> Nodes(bool ascending);
    [IteratorStateMachineAttribute("JetBrains.Util.Collections.JetBinaryTree.JetBinaryTree`2/<Keys>d__43")]
public IEnumerable`1<TKeyType> Keys(bool ascending);
    [IteratorStateMachineAttribute("JetBrains.Util.Collections.JetBinaryTree.JetBinaryTree`2/<Values>d__44")]
public IEnumerable`1<TDataType> Values(bool ascending);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private JetBinaryTreeEnumerator`2<TKeyType, TDataType> Elements(bool ascending);
    private void RestoreAfterInsert(JetBinaryTreeNode`2<TKeyType, TDataType> x);
    private void RestoreAfterDelete(JetBinaryTreeNode`2<TKeyType, TDataType> x);
    private void Delete(JetBinaryTreeNode`2<TKeyType, TDataType> node);
    private JetBinaryTreeNode`2<TKeyType, TDataType> CloneNode(JetBinaryTreeNode`2<TKeyType, TDataType> treeNode, JetBinaryTree`2<TKeyType, TDataType> targetTree, JetBinaryTreeNode`2<TKeyType, TDataType> targetParent);
    public sealed virtual JetBinaryTree`2<TKeyType, TDataType> Clone();
    private sealed virtual override object System.ICloneable.Clone();
    [IteratorStateMachineAttribute("JetBrains.Util.Collections.JetBinaryTree.JetBinaryTree`2/<KeyValuePairs>d__53")]
private IEnumerable`1<KeyValuePair`2<TKeyType, TDataType>> KeyValuePairs(bool ascending);
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKeyType, TDataType>> GetEnumerator();
    public sealed virtual void Add(KeyValuePair`2<TKeyType, TDataType> item);
    public sealed virtual bool Remove(KeyValuePair`2<TKeyType, TDataType> item);
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool Contains(KeyValuePair`2<TKeyType, TDataType> item);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual bool ContainsKey(TKeyType key);
    [ContractAnnotationAttribute("=> false, value: null; => true")]
[PureAttribute]
public sealed virtual bool TryGetValue(TKeyType key, TDataType& value);
    public sealed virtual TDataType get_Item(TKeyType key);
    public sealed virtual void set_Item(TKeyType key, TDataType value);
    private sealed virtual override IEnumerable`1<TKeyType> System.Collections.Generic.IReadOnlyDictionary<TKeyType,TDataType>.get_Keys();
    private sealed virtual override IEnumerable`1<TDataType> System.Collections.Generic.IReadOnlyDictionary<TKeyType,TDataType>.get_Values();
    private sealed virtual override ICollection`1<TKeyType> System.Collections.Generic.IDictionary<TKeyType,TDataType>.get_Keys();
    private sealed virtual override ICollection`1<TDataType> System.Collections.Generic.IDictionary<TKeyType,TDataType>.get_Values();
    public FrugalLocalList`1<TDataType> FindDataInRange(TKeyType from, TKeyType until);
    [CompilerGeneratedAttribute]
private bool <IterateTreePairsWithAction>g__VisitLeft|31_0(TParam2& param2, <>c__DisplayClass31_0`2& );
    [CompilerGeneratedAttribute]
private bool <IterateTreePairsWithAction>g__VisitRight|31_1(TParam2& param2, <>c__DisplayClass31_0`2& );
    [CompilerGeneratedAttribute]
private AdvancedMatchingResults <IteratePairsInInterval>b__34_0(ValueTuple`4<TKeyType, TKeyType, bool, bool> tuple, TKeyType value);
    [CompilerGeneratedAttribute]
private AdvancedMatchingResults <FindData>b__35_0(Pair`2<TKeyType, FindStrategy> param, TKeyType value);
    [CompilerGeneratedAttribute]
private AdvancedMatchingResults <FindDataInRange>b__74_0(ValueTuple`2<TKeyType, TKeyType> range, TKeyType key);
}
public class JetBrains.Util.Collections.JetBinaryTree.JetBinaryTreeEnumerator`2 : object {
    private bool myAscending;
    private JetBinaryTreeNode`2<TKeyType, TDataType> mySentinelNode;
    private Stack`1<JetBinaryTreeNode`2<TKeyType, TDataType>> myStack;
    [CompilerGeneratedAttribute]
private TKeyType <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private TDataType <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private JetBinaryTreeNode`2<TKeyType, TDataType> <Node>k__BackingField;
    public TKeyType Key { get; public set; }
    public TDataType Value { get; public set; }
    public JetBinaryTreeNode`2<TKeyType, TDataType> Node { get; public set; }
    public JetBinaryTreeEnumerator`2(JetBinaryTreeNode`2<TKeyType, TDataType> node, bool ascending, JetBinaryTreeNode`2<TKeyType, TDataType> sentinelNode);
    [CompilerGeneratedAttribute]
public TKeyType get_Key();
    [CompilerGeneratedAttribute]
public void set_Key(TKeyType value);
    [CompilerGeneratedAttribute]
public TDataType get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(TDataType value);
    [CompilerGeneratedAttribute]
public JetBinaryTreeNode`2<TKeyType, TDataType> get_Node();
    [CompilerGeneratedAttribute]
public void set_Node(JetBinaryTreeNode`2<TKeyType, TDataType> value);
    private void InsertNewNode(JetBinaryTreeNode`2<TKeyType, TDataType> node);
    public TDataType NextElement();
    public bool HasMoreElements();
    public bool MoveNext();
}
public class JetBrains.Util.Collections.JetBinaryTree.JetBinaryTreeException : Exception {
    public JetBinaryTreeException(string message);
}
public class JetBrains.Util.Collections.JetBinaryTree.JetBinaryTreeNode`2 : object {
    [CompilerGeneratedAttribute]
private NodeColor <Color>k__BackingField;
    [CompilerGeneratedAttribute]
private JetBinaryTreeNode`2<TKeyType, TDataType> <Left>k__BackingField;
    [CompilerGeneratedAttribute]
private JetBinaryTreeNode`2<TKeyType, TDataType> <Right>k__BackingField;
    [CompilerGeneratedAttribute]
private JetBinaryTreeNode`2<TKeyType, TDataType> <Parent>k__BackingField;
    [CompilerGeneratedAttribute]
private TKeyType <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private TDataType <Data>k__BackingField;
    public NodeColor Color { get; public set; }
    public JetBinaryTreeNode`2<TKeyType, TDataType> Left { get; public set; }
    public JetBinaryTreeNode`2<TKeyType, TDataType> Right { get; public set; }
    public JetBinaryTreeNode`2<TKeyType, TDataType> Parent { get; public set; }
    public TKeyType Key { get; public set; }
    public TDataType Data { get; public set; }
    [CompilerGeneratedAttribute]
public NodeColor get_Color();
    [CompilerGeneratedAttribute]
public void set_Color(NodeColor value);
    [CompilerGeneratedAttribute]
public JetBinaryTreeNode`2<TKeyType, TDataType> get_Left();
    [CompilerGeneratedAttribute]
public void set_Left(JetBinaryTreeNode`2<TKeyType, TDataType> value);
    [CompilerGeneratedAttribute]
public JetBinaryTreeNode`2<TKeyType, TDataType> get_Right();
    [CompilerGeneratedAttribute]
public void set_Right(JetBinaryTreeNode`2<TKeyType, TDataType> value);
    [CompilerGeneratedAttribute]
public JetBinaryTreeNode`2<TKeyType, TDataType> get_Parent();
    [CompilerGeneratedAttribute]
public void set_Parent(JetBinaryTreeNode`2<TKeyType, TDataType> value);
    [CompilerGeneratedAttribute]
public TKeyType get_Key();
    [CompilerGeneratedAttribute]
public void set_Key(TKeyType value);
    [CompilerGeneratedAttribute]
public TDataType get_Data();
    [CompilerGeneratedAttribute]
public void set_Data(TDataType value);
}
public class JetBrains.Util.Collections.JetBinaryTree.JetNugetFrameworkTree`1 : JetBinaryTree`2<NuGetFramework, TValue> {
}
public class JetBrains.Util.Collections.JetBinaryTree.JetPathPrefixTree`2 : JetBinaryTree`2<TPath, TValue> {
    private static AdvancedMatchingResults Comparer(TPath root, TPath path);
    public ReadOnlyFrugalLocalList`1<TValue> FindData(TPath root);
    public ReadOnlyFrugalLocalList`1<KeyValuePair`2<TPath, TValue>> FindPairs(TPath root);
}
public class JetBrains.Util.Collections.JetBinaryTree.JetRelativePathPrefixTree`1 : JetPathPrefixTree`2<RelativePath, TValue> {
}
public class JetBrains.Util.Collections.JetBinaryTree.JetSortedStringDictionary`1 : JetBinaryTree`2<string, TDataType> {
    private StringComparison myComparison;
    private Func`3<string, string, AdvancedMatchingResults> myFFindByPrefix;
    private Func`3<StringSlice, string, AdvancedMatchingResults> myFFindBySubstring;
    public JetSortedStringDictionary`1(StringComparison comparison);
    private AdvancedMatchingResults FindByPrefix(string prefix1, string key);
    private AdvancedMatchingResults FindByPrefixEx(StringSlice prefix, string key);
    public sealed virtual FrugalLocalList`1<KeyValuePair`2<string, TDataType>> FindEntriesByPrefix(string prefix);
    public sealed virtual FrugalLocalList`1<KeyValuePair`2<string, TDataType>> FindEntriesByPrefix(string prefix, int position, int length);
    public sealed virtual FrugalLocalList`1<TDataType> FindValuesByPrefix(string prefix);
}
[ExtensionAttribute]
public static class JetBrains.Util.Collections.JetBinaryTree.JetSortedStringDictionaryUtil : object {
    [ExtensionAttribute]
public static IJetSortedStringDictionary`1<TElement> ToJetSortedStringDictionary(IEnumerable`1<TSource> source, Func`2<TSource, string> keySelector, Func`2<TSource, TElement> elementSelector, StringComparison comparison);
}
public enum JetBrains.Util.Collections.JetBinaryTree.NodeColor : Enum {
    public int value__;
    public static NodeColor Red;
    public static NodeColor Black;
}
public class JetBrains.Util.Collections.JetBinaryTree.TextRangeTree`1 : JetBinaryTree`2<TextRange, TData> {
    protected TextRangeTree`1(TextRangeTree`1<TData> treeTextRangeTree);
    public FrugalLocalList`1<TData> FindRangeByOffset(int offset);
    public FrugalLocalList`1<TData> FindIntersectingRanges(TextRange rangeToCompare, bool strict);
    public FrugalLocalList`1<TData> FindCoveredRanges(TextRange rangeToCompare);
    public FrugalLocalList`1<TData> FindCoveringRanges(TextRange rangeToCompare);
    public sealed virtual TextRangeTree`1<TData> Clone();
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Util.Collections.JetBitArray : object {
    private static int SlotSizeInBytes;
    private static int SlotSizeInBits;
    private int myFlagsCapacity;
    private Int32[] myInnerArray;
    private int mySetFlagsCount;
    public int Size { get; }
    public int Length { get; }
    public int Count { get; }
    public bool Item { get; public set; }
    public JetBitArray(int length);
    public int get_Size();
    public int get_Length();
    public int get_Count();
    public bool get_Item(int index);
    public void set_Item(int index, bool value);
    public bool Set(int index, bool value);
    public Enumerator GetEnumerator();
    public void Clear();
    private sealed virtual override IEnumerator`1<int> System.Collections.Generic.IEnumerable<System.Int32>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public static class JetBrains.Util.Collections.JetEqualityComparer : object {
    [NotNullAttribute]
[PureAttribute]
public static IEqualityComparer`1<TWrapped> FromAnotherComparer(Func`2<TWrapped, TNested> keySelector, IEqualityComparer`1<TNested> nestedComparer);
    [NotNullAttribute]
[PureAttribute]
public static IEqualityComparer`1<T> FromFunctions(Func`3<T, T, bool> equals, Func`2<T, int> getHashCode);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.Util.Collections.LimitedDictionary`2 : object {
    private ConcurrentDictionary`2<TKey, TValue> myItems;
    private ConcurrentQueue`1<TKey> myRecentItems;
    private int myCount;
    private int myMaxCount;
    public LimitedDictionary`2(int maxCount);
    [MustUseReturnValueAttribute]
public TValue GetItemWithCache(TKey key, Func`2<TKey, TValue> eval);
    public bool TryGetItem(TKey key, TValue& value);
}
public class JetBrains.Util.Collections.MultiTypeEqualityComparer : object {
    [NotNullAttribute]
private List`1<ITypeComparer> myTypeComparers;
    [NotNullAttribute]
private ConcurrentDictionary`2<Type, ITypeComparer> myCachedComparers;
    public void RegisterComparer(IEqualityComparer`1<T> comparer);
    public sealed virtual int GetHashCode(object obj);
    private sealed virtual override bool System.Collections.Generic.IEqualityComparer<System.Object>.Equals(object x, object y);
    [NotNullAttribute]
private IEqualityComparer`1<object> GetComparer(object obj);
}
public class JetBrains.Util.Collections.ObjectPool`1 : object {
    private int myMaxObjectsCount;
    private Func`1<T> myCreateObject;
    private object myQueueAccess;
    private Queue`1<T> myQueue;
    private object myObjectsCountAccess;
    private int myObjectsCount;
    private HashSet`1<object> myObjectsSet;
    public ObjectPool`1(IReadOnlyCollection`1<T> initialPool);
    public ObjectPool`1(Func`1<T> createObject);
    public ObjectPool`1(Func`1<T> createObject, IEnumerable`1<T> initialPool);
    public ObjectPool`1(Func`1<T> createObject, int maxObjectsCount);
    public ObjectPool`1(Func`1<T> createObject, IEnumerable`1<T> initialPool, int maxObjectsCount);
    private void Enqueue(T object);
    [ConditionalAttribute("JET_MODE_ASSERT")]
private void AssertCanAddObjectInThePool(T object);
    [ConditionalAttribute("JET_MODE_ASSERT")]
private void AssertCanRemoveObjectFromThePool(T object);
    public T GetObject(Lifetime lifetime);
    public T GetObject();
    private T Dequeue();
    public T CreateAndGetObject(Lifetime lifetime);
    public void AddObjectToPool(T object);
    private T CreateNewObject();
    private void IncreaseObjectsCount();
    private void HangEntityOnLifetime(Lifetime lifetime, T entity);
    public void ReturnObject(T object);
    private static int GetInitialPoolSize(IReadOnlyCollection`1<T> initialPool);
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Util.Collections.OneToCompactCountingSet`2 : object {
    private IEqualityComparer`1<TValue> myComparer;
    private CompactMap`2<TKey, CompactCountingSet<TKey, TValue>> myMap;
    [NotNullAttribute]
public static IReadonlyCountingSet`1<TValue> Empty;
    public IReadonlyCountingSet`1<TValue> Item { get; }
    public IEnumerable`1<TKey> Keys { get; }
    public int Count { get; }
    public OneToCompactCountingSet`2(IEqualityComparer`1<TValue> comparer);
    private static OneToCompactCountingSet`2();
    public int Add(TKey key, TValue item, int count);
    public int Remove(TKey key, TValue item, int count);
    public bool Remove(TKey key);
    public TValue[] GetValues(TKey key);
    public bool ContainsKey(TKey key);
    public int GetCount(TKey key, TValue value);
    public IReadonlyCountingSet`1<TValue> get_Item(TKey key);
    public bool TryGetValue(TKey key, IReadonlyCountingSet`1& value);
    public IEnumerable`1<TKey> get_Keys();
    public IReadonlyCountingSet`1<TValue> GetOrEmpty(TKey key);
    public int get_Count();
    public void Clear();
    [IteratorStateMachineAttribute("JetBrains.Util.Collections.OneToCompactCountingSet`2/<GetEnumerator>d__20")]
public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, IReadonlyCountingSet`1<TValue>>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class JetBrains.Util.Collections.PartialSorter : object {
    [MustUseReturnValueAttribute]
[NotNullAttribute]
public static IEnumerable`1<T> LazySortInplace(IList`1<T> list, Func`3<T, T, int> comparer);
    [IteratorStateMachineAttribute("JetBrains.Util.Collections.PartialSorter/<LazySortInplace>d__1`1")]
[MustUseReturnValueAttribute]
[NotNullAttribute]
private static IEnumerable`1<T> LazySortInplace(IList`1<T> list, int left, int right, Func`3<T, T, int> comparer);
    private static void Swap(IList`1<T> list, int i, int j);
    private static void InsertionSort(IList`1<T> list, int left, int right, Func`3<T, T, int> comparer);
    [MustUseReturnValueAttribute]
private static int Partition(IList`1<T> list, int low, int high, Func`3<T, T, int> comparer);
}
[ExtensionAttribute]
public static class JetBrains.Util.Collections.TimeExtensions : object {
    [ExtensionAttribute]
public static TimeSpan Day(double value);
    [ExtensionAttribute]
public static TimeSpan Days(double value);
    [ExtensionAttribute]
public static TimeSpan Hour(double value);
    [ExtensionAttribute]
public static TimeSpan Hours(double value);
    [ExtensionAttribute]
public static TimeSpan Minute(double value);
    [ExtensionAttribute]
public static TimeSpan Minutes(double value);
    [ExtensionAttribute]
public static TimeSpan Second(double value);
    [ExtensionAttribute]
public static TimeSpan Seconds(double value);
    [ExtensionAttribute]
public static TimeSpan Milliseconds(double value);
    [ExtensionAttribute]
public static TimeSpan Day(int value);
    [ExtensionAttribute]
public static TimeSpan Days(int value);
    [ExtensionAttribute]
public static TimeSpan Hour(int value);
    [ExtensionAttribute]
public static TimeSpan Hours(int value);
    [ExtensionAttribute]
public static TimeSpan Minute(int value);
    [ExtensionAttribute]
public static TimeSpan Minutes(int value);
    [ExtensionAttribute]
public static TimeSpan Second(int value);
    [ExtensionAttribute]
public static TimeSpan Seconds(int value);
    [ExtensionAttribute]
public static TimeSpan Milliseconds(int value);
    [ExtensionAttribute]
public static DateTime Ago(TimeSpan value);
    [ExtensionAttribute]
public static DateTime Hence(TimeSpan value);
    [ExtensionAttribute]
public static DateTime Before(TimeSpan value, DateTime date);
    [ExtensionAttribute]
public static DateTime After(TimeSpan value, DateTime date);
}
[DefaultMemberAttribute("Item")]
[DebuggerTypeProxyAttribute("JetBrains.Util.Collections.UnsafeBitArrayDebugView")]
public class JetBrains.Util.Collections.UnsafeBitArray : ValueType {
    private Int32* myPtr;
    private int myLengthBits;
    public int LengthBits { get; }
    public bool Item { get; public set; }
    private int LengthBytes { get; }
    private int LengthInt { get; }
    public UnsafeBitArray(Void* ptr, int lengthBits);
    public int get_LengthBits();
    public static void Raise(Void* ptr, int index);
    public static void Lower(Void* ptr, int index);
    public static bool Set(Void* ptr, int index, bool value);
    public bool get_Item(int index);
    public void set_Item(int index, bool value);
    public void Raise(int index);
    public void Lower(int index);
    public bool Set(int index, bool value);
    public Enumerator GetEnumerator();
    public void Clear();
    private int get_LengthBytes();
    private int get_LengthInt();
}
internal class JetBrains.Util.Collections.UnsafeBitArrayDebugView : object {
    private UnsafeBitArray myBitArray;
    public Int32[] Values { get; }
    public int LengthBits { get; }
    public UnsafeBitArrayDebugView(UnsafeBitArray bitArray);
    public Int32[] get_Values();
    public int get_LengthBits();
}
public static class JetBrains.Util.Collections.WeakCollectionsManager : object {
    public static Statistics Statistics;
    private static WeakCollectionsManager();
}
public static class JetBrains.Util.ColorParsing : object {
    private static Dictionary`2<string, UInt32> NamedColors;
    private static ColorParsing();
    public static Nullable`1<JetRgbaColor> GetNamedColor(string name);
    [CanBeNullAttribute]
public static string GetColorName(JetRgbaColor color);
    public static Nullable`1<JetRgbaColor> FromHexOrNamed(string color, bool allowThreeDigitsFormat);
    public static Nullable`1<JetRgbaColor> GetColorFromHexString(string hexFormattedColor);
    public static Nullable`1<JetRgbaColor> GetColorFromHexString(string hexFormattedColor, bool allowThreeDigitsFormat);
    public static UInt32 ToUint(double a, double r, double g, double b);
    public static string Hex(JetRgbaColor rgbColor);
    public static string HexNoAlpha(JetRgbaColor rgbColor);
    public static string HexAlphaAndColor(JetRgbaColor rgbColor);
    public static string FindFirstColorNameOccurrence(string sentence);
}
public class JetBrains.Util.CommandLineBuilderJet : object {
    private StringBuilder myStringBuilder;
    [NotNullAttribute]
public CommandLineBuilderJet AppendFileName(FileSystemPath path);
    [NotNullAttribute]
public CommandLineBuilderJet AppendFileName(RelativePath path);
    [NotNullAttribute]
public CommandLineBuilderJet AppendFileName(string path);
    [NotNullAttribute]
public CommandLineBuilderJet AppendFileNameIfNotNull(FileSystemPath path);
    [NotNullAttribute]
public CommandLineBuilderJet AppendFileNameIfNotNull(RelativePath path);
    [NotNullAttribute]
public CommandLineBuilderJet AppendFileNameIfNotNull(string fullpath);
    [NotNullAttribute]
public CommandLineBuilderJet AppendParameterWithQuoting(string parameter);
    [NotNullAttribute]
public CommandLineBuilderJet AppendSpaceIfNotEmpty();
    [NotNullAttribute]
public CommandLineBuilderJet AppendSwitch(string switchname);
    [NotNullAttribute]
public CommandLineBuilderJet AppendSwitchIfNotNull(string switchname, string parameter);
    [NotNullAttribute]
public CommandLineBuilderJet AppendSwitchIfNotNull(string switchname, FileSystemPath path);
    [NotNullAttribute]
public CommandLineBuilderJet AppendSwitchIfNotNull(string switchname, RelativePath path);
    public CommandLineBuilderJet AppendSwitchIfNotNull(string switchname, IPath path);
    [ContractAnnotationAttribute("value:null => null; notnull => notnull")]
public static string op_Implicit(CommandLineBuilderJet value);
    public virtual string ToString();
    [NotNullAttribute]
private CommandLineBuilderJet AppendTextUnquotedRaw(string switchname);
    [NotNullAttribute]
private CommandLineBuilderJet AppendTextWithQuotingRaw(string parameter);
}
[MeansImplicitUseAttribute]
[AttributeUsageAttribute("384")]
public abstract class JetBrains.Util.CommandLineMapper.Attributes.AbstractGroupAttribute : AbstractMapperAttribute {
    [CompilerGeneratedAttribute]
private string <SymbolicName>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<Type> <KnownTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRequired>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HelpText>k__BackingField;
    [NotNullAttribute]
public string SymbolicName { get; }
    public IReadOnlyList`1<Type> KnownTypes { get; }
    public bool IsRequired { get; public set; }
    [CanBeNullAttribute]
public string HelpText { get; public set; }
    public bool IsMultipleAllowed { get; }
    [NotNullAttribute]
public Type GroupDefinitionAttributeType { get; }
    protected AbstractGroupAttribute(string symbolicName, Type knownType, Type[] otherKnownTypes);
    [CompilerGeneratedAttribute]
public string get_SymbolicName();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<Type> get_KnownTypes();
    [CompilerGeneratedAttribute]
public bool get_IsRequired();
    [CompilerGeneratedAttribute]
public void set_IsRequired(bool value);
    [CompilerGeneratedAttribute]
public string get_HelpText();
    [CompilerGeneratedAttribute]
public void set_HelpText(string value);
    public virtual bool get_IsMultipleAllowed();
    public abstract virtual Type get_GroupDefinitionAttributeType();
    [IteratorStateMachineAttribute("JetBrains.Util.CommandLineMapper.Attributes.AbstractGroupAttribute/<GetKnownGroupNames>d__19")]
[NotNullAttribute]
public virtual IEnumerable`1<string> GetKnownGroupNames();
    [NotNullAttribute]
public virtual string GetGroupName(Type groupType);
    [CanBeNullAttribute]
public virtual KeyDefinition GetKeyDefinition();
    [NotNullAttribute]
public abstract virtual IEnumerable`1<Type> GetSuitableTypes(ICommandLineInternal commandLine);
    [IteratorStateMachineAttribute("JetBrains.Util.CommandLineMapper.Attributes.AbstractGroupAttribute/<GetKnownValues>d__23")]
[NotNullAttribute]
public IEnumerable`1<string> GetKnownValues();
}
[MeansImplicitUseAttribute]
[AttributeUsageAttribute("4")]
public abstract class JetBrains.Util.CommandLineMapper.Attributes.AbstractGroupDefinitionAttribute : AbstractMapperAttribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HelpText>k__BackingField;
    public string Name { get; }
    public string HelpText { get; public set; }
    protected AbstractGroupDefinitionAttribute(string name);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public string get_HelpText();
    [CompilerGeneratedAttribute]
public void set_HelpText(string value);
    [NotNullAttribute]
public abstract virtual GroupSignature GetGroupSignature(Type type);
}
public abstract class JetBrains.Util.CommandLineMapper.Attributes.AbstractMapperAttribute : Attribute {
}
[MeansImplicitUseAttribute]
[AttributeUsageAttribute("384")]
public abstract class JetBrains.Util.CommandLineMapper.Attributes.AbstractOptionAttribute : AbstractMapperAttribute {
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private char <Shortcut>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NonKeyedIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsNonKeyedTail>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRequired>k__BackingField;
    [CompilerGeneratedAttribute]
private object <DefaultValue>k__BackingField;
    [CompilerGeneratedAttribute]
private object <EmptyValue>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Alias>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SymbolicValue>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HelpText>k__BackingField;
    [CompilerGeneratedAttribute]
private char <Separator>k__BackingField;
    public bool IsKeyed { get; }
    [CanBeNullAttribute]
public string Key { get; }
    public char Shortcut { get; }
    public int NonKeyedIndex { get; }
    public bool IsNonKeyedTail { get; public set; }
    public bool IsRequired { get; public set; }
    public object DefaultValue { get; public set; }
    public object EmptyValue { get; public set; }
    [CanBeNullAttribute]
public string Alias { get; public set; }
    [NotNullAttribute]
public string SymbolicValue { get; public set; }
    [CanBeNullAttribute]
public string HelpText { get; public set; }
    public char Separator { get; public set; }
    [NotNullAttribute]
public Type ValueType { get; }
    [CanBeNullAttribute]
public Type MultiValueType { get; }
    protected AbstractOptionAttribute(string key, char shortcut, int nonKeyedIndex);
    protected AbstractOptionAttribute(string key);
    protected AbstractOptionAttribute(string key, char shortcut);
    protected AbstractOptionAttribute(char shortcut);
    protected AbstractOptionAttribute(int nonKeyedIndex, string symbolicValue);
    public bool get_IsKeyed();
    [CompilerGeneratedAttribute]
public string get_Key();
    [CompilerGeneratedAttribute]
public char get_Shortcut();
    [CompilerGeneratedAttribute]
public int get_NonKeyedIndex();
    [CompilerGeneratedAttribute]
public bool get_IsNonKeyedTail();
    [CompilerGeneratedAttribute]
public void set_IsNonKeyedTail(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsRequired();
    [CompilerGeneratedAttribute]
public void set_IsRequired(bool value);
    [CompilerGeneratedAttribute]
[CanBeNullAttribute]
public object get_DefaultValue();
    [CompilerGeneratedAttribute]
[NotNullAttribute]
public void set_DefaultValue(object value);
    [CompilerGeneratedAttribute]
[CanBeNullAttribute]
public object get_EmptyValue();
    [CompilerGeneratedAttribute]
[NotNullAttribute]
public void set_EmptyValue(object value);
    [CompilerGeneratedAttribute]
public string get_Alias();
    [CompilerGeneratedAttribute]
public void set_Alias(string value);
    [CompilerGeneratedAttribute]
public string get_SymbolicValue();
    [CompilerGeneratedAttribute]
public void set_SymbolicValue(string value);
    [CompilerGeneratedAttribute]
public string get_HelpText();
    [CompilerGeneratedAttribute]
public void set_HelpText(string value);
    [CompilerGeneratedAttribute]
public char get_Separator();
    [CompilerGeneratedAttribute]
public void set_Separator(char value);
    public abstract virtual Type get_ValueType();
    public virtual Type get_MultiValueType();
    [CanBeNullAttribute]
public virtual KeyDefinition GetKeyDefinition();
    [NotNullAttribute]
public IEnumerable`1<string> FormatValues(object value, bool forceDefaultValue);
    [CanBeNullAttribute]
protected virtual string FormatValue(object value);
    [CanBeNullAttribute]
public virtual object TryMap(ICommandLineInternal commandLine, Type type);
    [NotNullAttribute]
private IReadOnlyList`1<CommandLineArgument> GetMyArguments(ICommandLineInternal commandLine);
    [CanBeNullAttribute]
private object MapDefaultValue(Type type);
    [NotNullAttribute]
private object MapEmptyValue(Type type);
    [NotNullAttribute]
private object MapArguments(IReadOnlyList`1<CommandLineArgument> arguments, Type type);
    [NotNullAttribute]
protected abstract virtual object ConvertValue(string value, Type type);
    [CompilerGeneratedAttribute]
private object <MapDefaultValue>b__57_0(string x);
    [CompilerGeneratedAttribute]
private object <MapEmptyValue>b__58_0(string x);
    [CompilerGeneratedAttribute]
private object <MapArguments>b__59_0(string x);
}
[MeansImplicitUseAttribute]
[AttributeUsageAttribute("388")]
public abstract class JetBrains.Util.CommandLineMapper.Attributes.AbstractOptionFilterAttribute : AbstractMapperAttribute {
    protected abstract virtual bool IsSupported();
    internal static bool IsTypeSupported(Type type);
    internal static bool IsMemberSupported(MemberInfo memberInfo);
    public static bool IsValueSupported(object value);
    public static bool IsUsageExampleSupported(UsageExample example);
    private static bool IsSupportedCore(AbstractOptionFilterAttribute attribute);
}
[AttributeUsageAttribute("4")]
public class JetBrains.Util.CommandLineMapper.Attributes.AdvancedOptionsAttribute : AbstractMapperAttribute {
    private string mySymbolicName;
    [CompilerGeneratedAttribute]
private string <HelpText>k__BackingField;
    public string SymbolicName { get; }
    [CanBeNullAttribute]
public string HelpText { get; public set; }
    public AdvancedOptionsAttribute(string symbolicName);
    public string get_SymbolicName();
    [CompilerGeneratedAttribute]
public string get_HelpText();
    [CompilerGeneratedAttribute]
public void set_HelpText(string value);
}
[AttributeUsageAttribute("4")]
public class JetBrains.Util.CommandLineMapper.Attributes.AppNameAttribute : AbstractMapperAttribute {
    private Type myOptionFilterTypeAttribute;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; }
    public bool IsSupported { get; }
    public AppNameAttribute(string nameWithoutExt, Type optionFilterTypeAttribute);
    [CompilerGeneratedAttribute]
public string get_Name();
    public bool get_IsSupported();
}
public class JetBrains.Util.CommandLineMapper.Attributes.BoolOptionAttribute : AbstractOptionAttribute {
    public bool DefaultValue { get; }
    public bool EmptyValue { get; }
    public Type ValueType { get; }
    public Type MultiValueType { get; }
    private BoolOptionAttribute(string key, char shortcut, int nonKeyedIndex);
    public BoolOptionAttribute(string key);
    public BoolOptionAttribute(string key, char shortcut);
    public BoolOptionAttribute(char shortcut);
    public bool get_DefaultValue();
    public bool get_EmptyValue();
    public virtual Type get_ValueType();
    public virtual Type get_MultiValueType();
    public virtual KeyDefinition GetKeyDefinition();
    protected virtual string FormatValue(object value);
    protected virtual object ConvertValue(string value, Type type);
}
public class JetBrains.Util.CommandLineMapper.Attributes.CommandDefinitionAttribute : AbstractGroupDefinitionAttribute {
    public CommandDefinitionAttribute(string name);
    public virtual GroupSignature GetGroupSignature(Type type);
}
public class JetBrains.Util.CommandLineMapper.Attributes.CommandGroupAttribute : AbstractGroupAttribute {
    public Type GroupDefinitionAttributeType { get; }
    public string HelpText { get; }
    public CommandGroupAttribute(Type knownType, Type[] otherKnownTypes);
    public virtual Type get_GroupDefinitionAttributeType();
    public string get_HelpText();
    public virtual IEnumerable`1<Type> GetSuitableTypes(ICommandLineInternal commandLine);
}
public class JetBrains.Util.CommandLineMapper.Attributes.DirectoryOptionAttribute : AbstractOptionAttribute {
    [CompilerGeneratedAttribute]
private bool <MustExist>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <MustNotExist>k__BackingField;
    public bool MustExist { get; public set; }
    public bool MustNotExist { get; public set; }
    public Type ValueType { get; }
    private DirectoryOptionAttribute(string key, char shortcut, int nonKeyedIndex);
    public DirectoryOptionAttribute(string key);
    public DirectoryOptionAttribute(string key, char shortcut);
    public DirectoryOptionAttribute(char shortcut);
    public DirectoryOptionAttribute(int nonKeyedIndex, string symbolicName);
    [CompilerGeneratedAttribute]
public bool get_MustExist();
    [CompilerGeneratedAttribute]
public void set_MustExist(bool value);
    [CompilerGeneratedAttribute]
public bool get_MustNotExist();
    [CompilerGeneratedAttribute]
public void set_MustNotExist(bool value);
    public virtual Type get_ValueType();
    protected virtual object ConvertValue(string value, Type type);
}
public class JetBrains.Util.CommandLineMapper.Attributes.EnumOptionAttribute : AbstractOptionAttribute {
    private Type myEnumType;
    private Dictionary`2<FieldInfo, DisplayAttribute> myFieldInfos;
    public Type ValueType { get; }
    private EnumOptionAttribute(string key, char shortcut, int nonKeyedIndex, Type enumType);
    public EnumOptionAttribute(string key, Type enumType);
    public EnumOptionAttribute(string key, char shortcut, Type enumType);
    public EnumOptionAttribute(char shortcut, Type enumType);
    public EnumOptionAttribute(int nonKeyedIndex, Type enumType);
    public virtual Type get_ValueType();
    protected virtual object ConvertValue(string value, Type type);
    private object ParseEnum(string value);
    private object GetValueFromName(string name);
    private String[] GetEnumNames(Type enumType);
    private string GetValueName(object value);
    private TAttribute GetEnumValueAttribute(object value);
}
public class JetBrains.Util.CommandLineMapper.Attributes.ExplicitGroupAttribute : AbstractGroupAttribute {
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private char <Shortcut>k__BackingField;
    public string Key { get; }
    public char Shortcut { get; }
    public Type GroupDefinitionAttributeType { get; }
    public ExplicitGroupAttribute(string symbolicName, string key, char shortcut, Type knownType, Type[] otherKnownTypes);
    public ExplicitGroupAttribute(string symbolicName, string key, Type knownType, Type[] otherKnownTypes);
    [CompilerGeneratedAttribute]
public string get_Key();
    [CompilerGeneratedAttribute]
public char get_Shortcut();
    public virtual Type get_GroupDefinitionAttributeType();
    public virtual IEnumerable`1<Type> GetSuitableTypes(ICommandLineInternal commandLine);
    public virtual KeyDefinition GetKeyDefinition();
    private static bool IsMatchValue(Type groupType, string value);
    private static bool IsDefault(Type groupType);
}
public class JetBrains.Util.CommandLineMapper.Attributes.ExplicitGroupDefinitionAttribute : AbstractGroupDefinitionAttribute {
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDefault>k__BackingField;
    [NotNullAttribute]
public string Key { get; }
    [NotNullAttribute]
public object Value { get; }
    public bool IsDefault { get; public set; }
    public ExplicitGroupDefinitionAttribute(string key, object value);
    [CompilerGeneratedAttribute]
public string get_Key();
    [CompilerGeneratedAttribute]
public object get_Value();
    [CompilerGeneratedAttribute]
public bool get_IsDefault();
    [CompilerGeneratedAttribute]
public void set_IsDefault(bool value);
    public virtual GroupSignature GetGroupSignature(Type type);
}
public class JetBrains.Util.CommandLineMapper.Attributes.FileOptionAttribute : AbstractOptionAttribute {
    [CompilerGeneratedAttribute]
private bool <MustExist>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <MustNotExist>k__BackingField;
    public bool MustExist { get; public set; }
    public bool MustNotExist { get; public set; }
    public Type ValueType { get; }
    private FileOptionAttribute(string key, char shortcut, int nonKeyedIndex);
    public FileOptionAttribute(string key);
    public FileOptionAttribute(string key, char shortcut);
    public FileOptionAttribute(char shortcut);
    public FileOptionAttribute(int nonKeyedIndex, string symbolicName);
    [CompilerGeneratedAttribute]
public bool get_MustExist();
    [CompilerGeneratedAttribute]
public void set_MustExist(bool value);
    [CompilerGeneratedAttribute]
public bool get_MustNotExist();
    [CompilerGeneratedAttribute]
public void set_MustNotExist(bool value);
    public virtual Type get_ValueType();
    protected virtual object ConvertValue(string value, Type type);
}
public class JetBrains.Util.CommandLineMapper.Attributes.FileSetOptionAttribute : AbstractOptionAttribute {
    private static Char[] ourDirectorySeparators;
    private static Char[] ourWildcard;
    public Type ValueType { get; }
    private FileSetOptionAttribute(string key, char shortcut, int nonKeyedIndex);
    public FileSetOptionAttribute(string key);
    public FileSetOptionAttribute(string key, char shortcut);
    public FileSetOptionAttribute(char shortcut);
    public FileSetOptionAttribute(int nonKeyedIndex, string symbolicName);
    private static FileSetOptionAttribute();
    public virtual Type get_ValueType();
    protected virtual object ConvertValue(string source, Type type);
}
[MeansImplicitUseAttribute]
[AttributeUsageAttribute("64")]
public class JetBrains.Util.CommandLineMapper.Attributes.HelpEpilogAttribute : AbstractMapperAttribute {
}
[MeansImplicitUseAttribute]
[AttributeUsageAttribute("64")]
public class JetBrains.Util.CommandLineMapper.Attributes.HelpPrologAttribute : AbstractMapperAttribute {
}
[MeansImplicitUseAttribute]
[AttributeUsageAttribute("64")]
public class JetBrains.Util.CommandLineMapper.Attributes.HelpTopicAttribute : AbstractMapperAttribute {
    private string myName;
    public string Name { get; }
    public HelpTopicAttribute(string name);
    public string get_Name();
}
public class JetBrains.Util.CommandLineMapper.Attributes.ImplicitGroupAttribute : AbstractGroupAttribute {
    public bool IsMultipleAllowed { get; }
    public Type GroupDefinitionAttributeType { get; }
    public ImplicitGroupAttribute(string symbolicName, Type knownType, Type[] otherKnownTypes);
    public virtual bool get_IsMultipleAllowed();
    public virtual Type get_GroupDefinitionAttributeType();
    public virtual IEnumerable`1<Type> GetSuitableTypes(ICommandLineInternal commandLine);
}
public class JetBrains.Util.CommandLineMapper.Attributes.ImplicitGroupDefinitionAttribute : AbstractGroupDefinitionAttribute {
    [CompilerGeneratedAttribute]
private int <Weight>k__BackingField;
    public int Weight { get; public set; }
    public ImplicitGroupDefinitionAttribute(string name);
    [CompilerGeneratedAttribute]
public int get_Weight();
    [CompilerGeneratedAttribute]
public void set_Weight(int value);
    public virtual GroupSignature GetGroupSignature(Type type);
}
public class JetBrains.Util.CommandLineMapper.Attributes.IntOptionAttribute : AbstractOptionAttribute {
    [CompilerGeneratedAttribute]
private bool <MustBeNonNegative>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <MustBePositive>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <MustBeInRange>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MinValue>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxValue>k__BackingField;
    public bool MustBeNonNegative { get; public set; }
    public bool MustBePositive { get; public set; }
    public bool MustBeInRange { get; public set; }
    public int MinValue { get; public set; }
    public int MaxValue { get; public set; }
    public Type ValueType { get; }
    private IntOptionAttribute(string key, char shortcut, int nonKeyedIndex);
    public IntOptionAttribute(string key);
    public IntOptionAttribute(string key, char shortcut);
    public IntOptionAttribute(char shortcut);
    public IntOptionAttribute(int nonKeyedIndex, string symbolicValue);
    [CompilerGeneratedAttribute]
public bool get_MustBeNonNegative();
    [CompilerGeneratedAttribute]
public void set_MustBeNonNegative(bool value);
    [CompilerGeneratedAttribute]
public bool get_MustBePositive();
    [CompilerGeneratedAttribute]
public void set_MustBePositive(bool value);
    [CompilerGeneratedAttribute]
public bool get_MustBeInRange();
    [CompilerGeneratedAttribute]
public void set_MustBeInRange(bool value);
    [CompilerGeneratedAttribute]
public int get_MinValue();
    [CompilerGeneratedAttribute]
public void set_MinValue(int value);
    [CompilerGeneratedAttribute]
public int get_MaxValue();
    [CompilerGeneratedAttribute]
public void set_MaxValue(int value);
    public virtual Type get_ValueType();
    protected virtual object ConvertValue(string value, Type type);
}
public class JetBrains.Util.CommandLineMapper.Attributes.NixOptionFilterAttribute : AbstractOptionFilterAttribute {
    protected virtual bool IsSupported();
}
public class JetBrains.Util.CommandLineMapper.Attributes.NonKeyedTailAttribute : AbstractOptionAttribute {
    public Type ValueType { get; }
    public Type MultiValueType { get; }
    public string DefaultValue { get; }
    public string EmptyValue { get; }
    public bool IsNonKeyedTail { get; }
    public NonKeyedTailAttribute(int startNonKeyedIndex);
    public virtual Type get_ValueType();
    public virtual Type get_MultiValueType();
    public string get_DefaultValue();
    public string get_EmptyValue();
    public bool get_IsNonKeyedTail();
    public virtual object TryMap(ICommandLineInternal commandLine, Type type);
    protected virtual object ConvertValue(string value, Type type);
}
public class JetBrains.Util.CommandLineMapper.Attributes.OptionDefaultValueAttribute : OptionSpecialValueAttribute {
    public OptionDefaultValueAttribute(object value, Type filterType);
    internal static void Apply(AbstractOptionAttribute optionAttribute, IMappedMember member);
}
public class JetBrains.Util.CommandLineMapper.Attributes.OptionEmptyValueAttribute : OptionSpecialValueAttribute {
    public OptionEmptyValueAttribute(object value, Type filterType);
    internal static void Apply(AbstractOptionAttribute optionAttribute, IMappedMember member);
}
[AttributeUsageAttribute("384")]
public class JetBrains.Util.CommandLineMapper.Attributes.OptionOrderAttribute : AbstractMapperAttribute {
    public int Order;
    public OptionOrderAttribute(int order);
}
[AttributeUsageAttribute("384")]
public abstract class JetBrains.Util.CommandLineMapper.Attributes.OptionSpecialValueAttribute : AbstractMapperAttribute {
    private object myValue;
    private Type myFilterType;
    protected OptionSpecialValueAttribute(object value, Type filterType);
    protected static object GetValue(IEnumerable`1<OptionSpecialValueAttribute> specialValueAttrs);
}
public class JetBrains.Util.CommandLineMapper.Attributes.PathOptionAttribute : AbstractOptionAttribute {
    public Type ValueType { get; }
    private PathOptionAttribute(string key, char shortcut, int nonKeyedIndex);
    public PathOptionAttribute(string key);
    public PathOptionAttribute(string key, char shortcut);
    public PathOptionAttribute(char shortcut);
    public PathOptionAttribute(int nonKeyedIndex, string symbolicName);
    public virtual Type get_ValueType();
    protected virtual object ConvertValue(string value, Type type);
}
public class JetBrains.Util.CommandLineMapper.Attributes.StringOptionAttribute : AbstractOptionAttribute {
    [CompilerGeneratedAttribute]
private bool <MustNotBeEmpty>k__BackingField;
    public Type ValueType { get; }
    public bool MustNotBeEmpty { get; public set; }
    public StringOptionAttribute(string key);
    public StringOptionAttribute(string key, char shortcut);
    public StringOptionAttribute(char shortcut);
    public StringOptionAttribute(int nonKeyedIndex, string symbolicName);
    public virtual Type get_ValueType();
    [CompilerGeneratedAttribute]
public bool get_MustNotBeEmpty();
    [CompilerGeneratedAttribute]
public void set_MustNotBeEmpty(bool value);
    protected virtual object ConvertValue(string value, Type type);
}
[MeansImplicitUseAttribute]
[AttributeUsageAttribute("384")]
public class JetBrains.Util.CommandLineMapper.Attributes.SubOptionsAttribute : AbstractMapperAttribute {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CanBeNullAttribute]
public Type Type { get; }
    public SubOptionsAttribute(Type type);
    [CompilerGeneratedAttribute]
public Type get_Type();
}
[AttributeUsageAttribute("4")]
public class JetBrains.Util.CommandLineMapper.Attributes.SupportsHelpCommandAttribute : AbstractMapperAttribute {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <Names>k__BackingField;
    public IReadOnlyList`1<string> Names { get; }
    public SupportsHelpCommandAttribute(string name, String[] otherNames);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_Names();
}
[AttributeUsageAttribute("4")]
public class JetBrains.Util.CommandLineMapper.Attributes.SupportsHelpKeysAttribute : AbstractMapperAttribute {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <Keys>k__BackingField;
    public IReadOnlyList`1<string> Keys { get; }
    public SupportsHelpKeysAttribute(string key, String[] otherKeys);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_Keys();
    public IEnumerable`1<KeyDefinition> GetKeyDefinitions();
}
public class JetBrains.Util.CommandLineMapper.Attributes.TimeSpanOptionAttribute : AbstractOptionAttribute {
    private static long Day;
    private static long Hour;
    private static long Minute;
    private static long Second;
    private static Dictionary`2<string, long> ourUnitMarks;
    public Type ValueType { get; }
    private TimeSpanOptionAttribute(string key, char shortcut, int nonKeyedIndex);
    public TimeSpanOptionAttribute(string key);
    public TimeSpanOptionAttribute(string key, char shortcut);
    public TimeSpanOptionAttribute(char shortcut);
    public TimeSpanOptionAttribute(int nonKeyedIndex);
    private static TimeSpanOptionAttribute();
    public virtual Type get_ValueType();
    protected virtual string FormatValue(object value);
    protected virtual object ConvertValue(string value, Type type);
}
public class JetBrains.Util.CommandLineMapper.Attributes.UnavailableOptionFilterAttribute : AbstractOptionFilterAttribute {
    protected virtual bool IsSupported();
}
[MeansImplicitUseAttribute]
[AttributeUsageAttribute("64")]
public class JetBrains.Util.CommandLineMapper.Attributes.UsageExamplesAttribute : AbstractMapperAttribute {
}
public class JetBrains.Util.CommandLineMapper.Attributes.WindowsAndLinuxOptionFilterAttribute : AbstractOptionFilterAttribute {
    protected virtual bool IsSupported();
}
public class JetBrains.Util.CommandLineMapper.Attributes.WindowsOptionFilterAttribute : AbstractOptionFilterAttribute {
    protected virtual bool IsSupported();
}
public static class JetBrains.Util.CommandLineMapper.CLI : object {
    [CompilerGeneratedAttribute]
private static FileSystemPath <StartupDirectory>k__BackingField;
    public static FileSystemPath StartupDirectory { get; public set; }
    private static CLI();
    [CompilerGeneratedAttribute]
public static FileSystemPath get_StartupDirectory();
    [CompilerGeneratedAttribute]
public static void set_StartupDirectory(FileSystemPath value);
    [NotNullAttribute]
public static string GetCommandName(object command);
    [NotNullAttribute]
public static string GetAppName();
    [NotNullAttribute]
public static string GreetingOf(string toolName, int sinceYear);
}
public class JetBrains.Util.CommandLineMapper.CommandLineArgument : object {
    private string myKey;
    private string myValue;
    public bool HasKey { get; }
    [NotNullAttribute]
public string Key { get; }
    public bool HasValue { get; }
    [NotNullAttribute]
public string Value { get; }
    private CommandLineArgument(string key, string value);
    public bool get_HasKey();
    public string get_Key();
    public bool get_HasValue();
    public string get_Value();
    public virtual string ToString();
    public static CommandLineArgument Keyed(string key, string value);
    public static CommandLineArgument Keyed(string key);
    public static CommandLineArgument NonKeyed(string value);
    public static CommandLineArgument Adopt(string key, string value);
}
public class JetBrains.Util.CommandLineMapper.CommandLineException : Exception {
    [CompilerGeneratedAttribute]
private string <LocalizationKey>k__BackingField;
    [CanBeNullAttribute]
public string LocalizationKey { get; }
    protected CommandLineException(string localizationKey, string defaultMessage);
    protected CommandLineException(string message);
    [CompilerGeneratedAttribute]
public string get_LocalizationKey();
    public static CommandLineException Localized(string message);
    [StringFormatMethodAttribute("format")]
public static CommandLineException Localized(string format, Object[] args);
    public static CommandLineException Aggregated(IEnumerable`1<CommandLineException> exceptions);
}
public class JetBrains.Util.CommandLineMapper.CommandMissingException : CommandLineException {
}
[FlagsAttribute]
public enum JetBrains.Util.CommandLineMapper.ExampleFormatFlags : Enum {
    public int value__;
    public static ExampleFormatFlags AppName;
    public static ExampleFormatFlags AppNameDotExe;
    public static ExampleFormatFlags Arguments;
}
public class JetBrains.Util.CommandLineMapper.FormattedTextBuilder : object {
    private IDictionary`2<string, string> myMacros;
    private StringBuilder myText;
    private int myIndent;
    private int myAlignPosition;
    public bool IsEmpty { get; }
    public int Indent { get; }
    public int AlignPosition { get; }
    public IDictionary`2<string, string> Macros { get; }
    public bool get_IsEmpty();
    public int get_Indent();
    public int get_AlignPosition();
    public IDictionary`2<string, string> get_Macros();
    public virtual string ToString();
    public FormattedTextBuilder IncreaseIndent();
    public FormattedTextBuilder DecreaseIndent();
    public FormattedTextBuilder Break();
    public FormattedTextBuilder Separator();
    public FormattedTextBuilder NewLine();
    public FormattedTextBuilder Space();
    public FormattedTextBuilder AlignTo(int position);
    private static int FindLastLineOffset(StringBuilder text);
    public FormattedTextBuilder AlignEnd();
    public FormattedTextBuilder Text(string text);
    public FormattedTextBuilder Text(object value);
    public FormattedTextBuilder LocalizedText(string text, int width);
    private static string ExpandMacros(string text, IDictionary`2<string, string> macros);
    public FormattedTextBuilder Char(char ch);
    public FormattedTextBuilder Define(string macro, string value);
    public FormattedTextBuilder Undefine(string macro);
    private static string Localize(string text);
}
[ExtensionAttribute]
public static class JetBrains.Util.CommandLineMapper.FormattedTextBuilderExtension : object {
    [ExtensionAttribute]
[NotNullAttribute]
public static FormattedTextBuilder Usage(FormattedTextBuilder builder);
    [ExtensionAttribute]
[NotNullAttribute]
public static FormattedTextBuilder Example(FormattedTextBuilder builder);
    [ExtensionAttribute]
[NotNullAttribute]
public static FormattedTextBuilder AppName(FormattedTextBuilder builder, Type optionsType);
}
public class JetBrains.Util.CommandLineMapper.GroupSignature : object {
    private string myArgs;
    private int myWeight;
    private GroupSignature(string args, int weight);
    public virtual string ToString();
    public sealed virtual bool Equals(GroupSignature other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual int CompareTo(GroupSignature other);
}
public interface JetBrains.Util.CommandLineMapper.ICommandLineBuilder`1 {
    [NotNullAttribute]
public RelativePath AppNameDotExe { get; }
    public abstract virtual RelativePath get_AppNameDotExe();
    [NotNullAttribute]
public abstract virtual string BuildArguments(TOptions options);
}
public interface JetBrains.Util.CommandLineMapper.ICommandLineMapper`1 {
    public IHelpGenerator HelpGenerator { get; }
    public abstract virtual IHelpGenerator get_HelpGenerator();
    [NotNullAttribute]
public abstract virtual KeyDefinitionSet GetKeyDefinitions();
    [CanBeNullAttribute]
public abstract virtual TOptions Map(ICommandLineParser parser, Action`1<string> displayHelp);
    [CanBeNullAttribute]
public abstract virtual TOptions Map(ICommandLineParser parser);
}
public interface JetBrains.Util.CommandLineMapper.ICommandLineParser {
    [NotNullAttribute]
public abstract virtual IEnumerable`1<CommandLineArgument> GetArguments(KeyDefinitionSet keyDefinitions);
}
public interface JetBrains.Util.CommandLineMapper.IExampleFormatter {
    [NotNullAttribute]
public abstract virtual string Format(object options, ExampleFormatFlags flags);
}
public interface JetBrains.Util.CommandLineMapper.IHelpGenerator {
    [NotNullAttribute]
public IOptionFormatter OptionFormatter { get; }
    [NotNullAttribute]
public IExampleFormatter ExampleFormatter { get; }
    public abstract virtual IOptionFormatter get_OptionFormatter();
    public abstract virtual IExampleFormatter get_ExampleFormatter();
    [NotNullAttribute]
public abstract virtual string GenerateHelp();
    [NotNullAttribute]
public abstract virtual string GenerateHelp(string groupName);
}
[DebuggerDisplayAttribute("{Name}")]
internal abstract class JetBrains.Util.CommandLineMapper.Impl.AbstractMappedMember : object {
    private int myOrder;
    protected MemberInfo MemberInfo { get; }
    public int Order { get; }
    public string Name { get; }
    public Type DeclaringType { get; }
    public Type Type { get; }
    public bool IsReadable { get; }
    public bool IsWriteable { get; }
    public bool IsStatic { get; }
    protected AbstractMappedMember(MemberInfo memberInfo);
    protected abstract virtual MemberInfo get_MemberInfo();
    public sealed virtual int get_Order();
    public sealed virtual string get_Name();
    public sealed virtual Type get_DeclaringType();
    public sealed virtual TAttribute GetAttribute();
    public sealed virtual IEnumerable`1<TAttribute> GetAttributes();
    public abstract virtual Type get_Type();
    public abstract virtual bool get_IsReadable();
    public abstract virtual bool get_IsWriteable();
    public abstract virtual bool get_IsStatic();
    public abstract virtual object GetValue(object instance);
    public abstract virtual void SetValue(object instance, object value);
    [CanBeNullAttribute]
public static IMappedMember TryCreate(MemberInfo memberInfo);
}
public abstract class JetBrains.Util.CommandLineMapper.Impl.AbstractOptionsIntrospector : object {
    [CompilerGeneratedAttribute]
private bool <IsCancelled>k__BackingField;
    protected bool IsCancelled { get; private set; }
    protected BindingFlags BindingFlags { get; }
    public void Introspect(Type optionsType);
    protected virtual void Begin(Type type);
    protected virtual void End(Type type);
    protected virtual void End();
    protected virtual void OnOption(AbstractOptionAttribute optionAttribute, IMappedMember member);
    protected virtual void BeginGroup(AbstractGroupAttribute groupAttribute, IMappedMember member);
    protected virtual void EndGroup(AbstractGroupAttribute groupAttribute, IMappedMember member);
    protected virtual void EndGroup();
    protected virtual void OnGroupDefinition(AbstractGroupDefinitionAttribute groupDefinitionAttribute, Type type);
    protected virtual IEnumerable`1<Type> GroupTypesOf(AbstractGroupAttribute groupAttribute, IMappedMember member);
    protected virtual void OnSubOptions(IMappedMember member, Type type);
    [CompilerGeneratedAttribute]
protected bool get_IsCancelled();
    [CompilerGeneratedAttribute]
private void set_IsCancelled(bool value);
    protected void Cancel();
    protected virtual BindingFlags get_BindingFlags();
    private static void GetMappedMembers(Type type, BindingFlags bindingFlags, List`1<IMappedMember> outMembers);
    internal static IEnumerable`1<IMappedMember> GetMappedMembersOrdered(Type type, BindingFlags bindingFlags);
}
public abstract class JetBrains.Util.CommandLineMapper.Impl.AbstractParser : object {
    private IReadOnlyList`1<string> myRawArguments;
    private string myRawCommandLine;
    private CommandLineParserSettings mySettings;
    [CompilerGeneratedAttribute]
private Char[] <ValueSeparators>k__BackingField;
    private List`1<string> mySortedKeyMarks;
    private string myDefaultKeyMarker;
    private Nullable`1<char> myDefaultShortcutMarker;
    private string myDefaultNonKeyedMarker;
    private Nullable`1<char> myDefaultValueSeparator;
    private HashSet`1<char> myKeyOrShortcutMarkers;
    protected Char[] ValueSeparators { get; }
    protected Char[] ShortcutMarks { get; }
    protected String[] KeyMarks { get; }
    protected string NonKeyedMarker { get; }
    private IList`1<string> SortedKeyMarks { get; }
    public string DefaultKeyMarker { get; }
    public char DefaultShortcutMarker { get; }
    public string DefaultNonKeyedMarker { get; }
    public char DefaultValueSeparator { get; }
    protected AbstractParser(IReadOnlyList`1<string> rawArguments, CommandLineParserSettings settings);
    protected AbstractParser(string rawCommandLine, CommandLineParserSettings settings);
    public sealed virtual string GetNonKeyedTailRaw(int startNonKeyedParamIndex);
    public sealed virtual IEnumerable`1<CommandLineArgument> GetArguments(KeyDefinitionSet keyDefinitions);
    protected virtual void ParseKey(KeyDefinitionSet keyDefinitions, RawArgumentIterator rawArgumentIt, IList`1<CommandLineArgument> outParsedArguments);
    protected virtual void ParseShortcuts(KeyDefinitionSet keyDefinitions, RawArgumentIterator rawArgumentIt, IList`1<CommandLineArgument> outParsedArguments);
    protected virtual void ParseValue(RawArgumentIterator rawArgumentIt, IList`1<CommandLineArgument> outParsedArguments);
    protected virtual KeyValuePair`2<string, string> ToKeyValue(string argument);
    protected virtual KeyValuePair`2<string, string> ToShortcutValue(string argument);
    [CompilerGeneratedAttribute]
protected virtual Char[] get_ValueSeparators();
    protected abstract virtual Char[] get_ShortcutMarks();
    protected abstract virtual String[] get_KeyMarks();
    protected virtual string get_NonKeyedMarker();
    private IList`1<string> get_SortedKeyMarks();
    private bool IsShortcut(string rawArgument);
    private bool IsKey(string rawArgument);
    private bool IsNonKeyedMarker(string rawArgument);
    private string TrimKeyMark(string rawArgument);
    private string TrimShortcutMark(string rawArgument);
    public sealed virtual string get_DefaultKeyMarker();
    public sealed virtual char get_DefaultShortcutMarker();
    public sealed virtual string get_DefaultNonKeyedMarker();
    public sealed virtual char get_DefaultValueSeparator();
    public sealed virtual bool IsKeyOrShortcutMarker(char ch);
}
internal static class JetBrains.Util.CommandLineMapper.Impl.AppNameUtils : object {
    [NotNullAttribute]
public static string GetAppName(Type optionsType);
}
public class JetBrains.Util.CommandLineMapper.Impl.BackwardCompatibilityParser : AbstractParser {
    [CompilerGeneratedAttribute]
private String[] <KeyMarks>k__BackingField;
    protected Char[] ShortcutMarks { get; }
    protected String[] KeyMarks { get; }
    public BackwardCompatibilityParser(IReadOnlyList`1<string> rawArguments, CommandLineParserSettings settings);
    public BackwardCompatibilityParser(string rawCommandLine, CommandLineParserSettings settings);
    protected virtual Char[] get_ShortcutMarks();
    [CompilerGeneratedAttribute]
protected virtual String[] get_KeyMarks();
}
public class JetBrains.Util.CommandLineMapper.Impl.CommandLineBuilder`1 : object {
    private IExampleFormatter myExampleFormatter;
    public RelativePath AppNameDotExe { get; }
    public CommandLineBuilder`1(IOptionFormatter optionFormatter);
    public sealed virtual RelativePath get_AppNameDotExe();
    public sealed virtual string BuildArguments(TOptions options);
}
public class JetBrains.Util.CommandLineMapper.Impl.CommandLineInternal : object {
    private ICommandLineParser myParser;
    private List`1<CommandLineArgument> myArgs;
    private OneToListMap`2<string, CommandLineArgument> myKeyedArgs;
    private List`1<CommandLineArgument> myNonKeyedArgs;
    private HashSet`1<CommandLineArgument> myMappedArgs;
    private CommandLineInternal myParent;
    public ICommandLineParser Parser { get; }
    public bool IsEmpty { get; }
    public bool HasMapped { get; }
    public CommandLineInternal(ICommandLineParser parser, KeyDefinitionSet keyDefinitions);
    private CommandLineInternal(CommandLineInternal commandLine);
    public sealed virtual ICommandLineParser get_Parser();
    public sealed virtual bool get_IsEmpty();
    public sealed virtual bool get_HasMapped();
    public sealed virtual IEnumerable`1<CommandLineArgument> GetArguments(string key);
    [IteratorStateMachineAttribute("JetBrains.Util.CommandLineMapper.Impl.CommandLineInternal/<GetArguments>d__15")]
public sealed virtual IEnumerable`1<CommandLineArgument> GetArguments(int nonKeyedIndex, int count);
    public sealed virtual IEnumerable`1<CommandLineArgument> GetArguments();
    public sealed virtual int IndexOf(CommandLineArgument argument);
    public sealed virtual void MarkAsMapped(CommandLineArgument argument);
    public sealed virtual ICommandLineInternal BeginMapping();
    public sealed virtual void RemoveMapped();
    private void RemoveMapped(OneToListMap`2<TKey, CommandLineArgument> keyedArgs);
    private void RemoveMapped(List`1<CommandLineArgument> nonkeyedArgs);
}
public class JetBrains.Util.CommandLineMapper.Impl.CommandLineMapper`1 : object {
    private OneToListMap`2<string, CommandLineException> myMappingErrors;
    private CommandLineMapperSettings mySettings;
    private KeyDefinitionSet myKeyDefinitions;
    public IHelpGenerator HelpGenerator { get; }
    public CommandLineMapper`1(CommandLineMapperSettings settings);
    public sealed virtual IHelpGenerator get_HelpGenerator();
    public sealed virtual KeyDefinitionSet GetKeyDefinitions();
    public sealed virtual TOptions Map(ICommandLineParser parser, Action`1<string> displayHelp);
    public sealed virtual TOptions Map(ICommandLineParser parser);
    private TOptions Map(ICommandLineInternal commandLine);
    private bool TryMapHelp(ICommandLineInternal commandLine, Action`1<string> displayHelp);
    [NotNullAttribute]
private object Map(ICommandLineInternal commandLine, Type optionsType, int depth);
    [CanBeNullAttribute]
private object Map(ICommandLineInternal commandLine, Type type, AbstractGroupAttribute groupAttribute, int depth);
    private string Format(AbstractOptionAttribute optionAttribute);
    private string Format(AbstractGroupAttribute groupAttribute);
}
public class JetBrains.Util.CommandLineMapper.Impl.CommandLineMapperSettings : object {
    public static IOptionMarkers UniversalStyleMarkers;
    public static IOptionMarkers UnixStyleMarkers;
    [CompilerGeneratedAttribute]
private StringComparer <KeyComparer>k__BackingField;
    [CompilerGeneratedAttribute]
private IHelpGenerator <HelpGenerator>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreExcessiveArguments>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ValidateHelpText>k__BackingField;
    [NotNullAttribute]
public StringComparer KeyComparer { get; private set; }
    [NotNullAttribute]
public IHelpGenerator HelpGenerator { get; private set; }
    public bool IgnoreExcessiveArguments { get; private set; }
    public bool ValidateHelpText { get; private set; }
    private static CommandLineMapperSettings();
    [CompilerGeneratedAttribute]
public StringComparer get_KeyComparer();
    [CompilerGeneratedAttribute]
private void set_KeyComparer(StringComparer value);
    [CompilerGeneratedAttribute]
public IHelpGenerator get_HelpGenerator();
    [CompilerGeneratedAttribute]
private void set_HelpGenerator(IHelpGenerator value);
    [CompilerGeneratedAttribute]
public bool get_IgnoreExcessiveArguments();
    [CompilerGeneratedAttribute]
private void set_IgnoreExcessiveArguments(bool value);
    [CompilerGeneratedAttribute]
public bool get_ValidateHelpText();
    [CompilerGeneratedAttribute]
private void set_ValidateHelpText(bool value);
}
public class JetBrains.Util.CommandLineMapper.Impl.CommandLineParserSettings : object {
    [CompilerGeneratedAttribute]
private Action`2<string, string> <OnKeyFound>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`2<string, string> <OnUndefinedKeyFound>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`3<string, char, string> <OnShortcutFound>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`2<string, char> <OnUndefinedShortcutFound>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`3<string, string, string> <OnAliasFound>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TreatUndefinedKeyAsIs>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TreatSpaceAsValueSeparator>k__BackingField;
    [CanBeNullAttribute]
public Action`2<string, string> OnKeyFound { get; private set; }
    [CanBeNullAttribute]
public Action`2<string, string> OnUndefinedKeyFound { get; private set; }
    [CanBeNullAttribute]
public Action`3<string, char, string> OnShortcutFound { get; private set; }
    [CanBeNullAttribute]
public Action`2<string, char> OnUndefinedShortcutFound { get; private set; }
    [CanBeNullAttribute]
public Action`3<string, string, string> OnAliasFound { get; private set; }
    public bool TreatUndefinedKeyAsIs { get; private set; }
    public bool TreatSpaceAsValueSeparator { get; private set; }
    [CompilerGeneratedAttribute]
public Action`2<string, string> get_OnKeyFound();
    [CompilerGeneratedAttribute]
private void set_OnKeyFound(Action`2<string, string> value);
    [CompilerGeneratedAttribute]
public Action`2<string, string> get_OnUndefinedKeyFound();
    [CompilerGeneratedAttribute]
private void set_OnUndefinedKeyFound(Action`2<string, string> value);
    [CompilerGeneratedAttribute]
public Action`3<string, char, string> get_OnShortcutFound();
    [CompilerGeneratedAttribute]
private void set_OnShortcutFound(Action`3<string, char, string> value);
    [CompilerGeneratedAttribute]
public Action`2<string, char> get_OnUndefinedShortcutFound();
    [CompilerGeneratedAttribute]
private void set_OnUndefinedShortcutFound(Action`2<string, char> value);
    [CompilerGeneratedAttribute]
public Action`3<string, string, string> get_OnAliasFound();
    [CompilerGeneratedAttribute]
private void set_OnAliasFound(Action`3<string, string, string> value);
    [CompilerGeneratedAttribute]
public bool get_TreatUndefinedKeyAsIs();
    [CompilerGeneratedAttribute]
private void set_TreatUndefinedKeyAsIs(bool value);
    [CompilerGeneratedAttribute]
public bool get_TreatSpaceAsValueSeparator();
    [CompilerGeneratedAttribute]
private void set_TreatSpaceAsValueSeparator(bool value);
}
public class JetBrains.Util.CommandLineMapper.Impl.CompactHelpGenerator : object {
    private Type myOptionsType;
    private IOptionFormatter myOptionFormatter;
    private int myOptionColumnWidth;
    private int myDescriptionColumnWidth;
    public IOptionFormatter OptionFormatter { get; }
    public IExampleFormatter ExampleFormatter { get; }
    public CompactHelpGenerator(Type optionsType, IOptionFormatter optionFormatter, int optionColumnWidth, int descriptionColumnWidth);
    public sealed virtual IOptionFormatter get_OptionFormatter();
    public sealed virtual IExampleFormatter get_ExampleFormatter();
    public sealed virtual string GenerateHelp();
    public sealed virtual string GenerateHelp(string groupName);
}
public class JetBrains.Util.CommandLineMapper.Impl.DefaultHelpGenerator : object {
    private Type myOptionsType;
    private IOptionFormatter myOptionFormatter;
    private IExampleFormatter myExampleFormatter;
    private int myOptionColumnWidth;
    private int myDescriptionColumnWidth;
    public IOptionFormatter OptionFormatter { get; }
    public IExampleFormatter ExampleFormatter { get; }
    public DefaultHelpGenerator(Type optionsType, IOptionFormatter optionFormatter, int optionColumnWidth, int descriptionColumnWidth);
    public sealed virtual IOptionFormatter get_OptionFormatter();
    public sealed virtual IExampleFormatter get_ExampleFormatter();
    public sealed virtual string GenerateHelp();
    public sealed virtual string GenerateHelp(string groupName);
    private void DefineGlobalMacros(FormattedTextBuilder help, Type optionsType);
}
public class JetBrains.Util.CommandLineMapper.Impl.ExampleFormatter : object {
    private Type myOptionsType;
    private IOptionFormatter myOptionFormatter;
    public ExampleFormatter(Type optionsType, IOptionFormatter optionFormatter);
    public sealed virtual string Format(object options, ExampleFormatFlags flags);
}
[ExtensionAttribute]
internal static class JetBrains.Util.CommandLineMapper.Impl.HelpGeneratorUtils : object {
    public static BindingFlags BindingFlags;
    private static HelpGeneratorUtils();
    [ExtensionAttribute]
[NotNullAttribute]
public static IEnumerable`1<UsageExample> GetExamples(Type optionsType);
    [ExtensionAttribute]
public static bool AppendHelpPrologIfAny(Type optionsType, FormattedTextBuilder text, IOptionFormatter optionFormatter, int optionColumnWidth, int descriptionColumnWidth);
    [ExtensionAttribute]
public static bool AppendHelpEpilogIfAny(Type optionsType, FormattedTextBuilder text, IOptionFormatter optionFormatter, int optionColumnWidth, int descriptionColumnWidth);
    [ExtensionAttribute]
public static bool AppendHelpTopicIfAny(Type optionsType, string name, FormattedTextBuilder text, IOptionFormatter optionFormatter, int optionColumnWidth, int descriptionColumnWidth);
    private static void AppendHelp(MethodInfo method, FormattedTextBuilder text, IOptionFormatter optionFormatter, int optionColumnWidth, int descriptionColumnWidth);
}
public interface JetBrains.Util.CommandLineMapper.Impl.ICommandLineInternal {
    public bool IsEmpty { get; }
    public bool HasMapped { get; }
    [NotNullAttribute]
public ICommandLineParser Parser { get; }
    public abstract virtual bool get_IsEmpty();
    public abstract virtual bool get_HasMapped();
    public abstract virtual ICommandLineParser get_Parser();
    [NotNullAttribute]
public abstract virtual IEnumerable`1<CommandLineArgument> GetArguments(string key);
    [NotNullAttribute]
public abstract virtual IEnumerable`1<CommandLineArgument> GetArguments(int nonKeyedIndex, int count);
    [NotNullAttribute]
public abstract virtual IEnumerable`1<CommandLineArgument> GetArguments();
    public abstract virtual int IndexOf(CommandLineArgument argument);
    [NotNullAttribute]
public abstract virtual ICommandLineInternal BeginMapping();
    public abstract virtual void MarkAsMapped(CommandLineArgument argument);
    public abstract virtual void RemoveMapped();
}
public interface JetBrains.Util.CommandLineMapper.Impl.IMappedMember {
    public int Order { get; }
    [NotNullAttribute]
public string Name { get; }
    [NotNullAttribute]
public Type Type { get; }
    public bool IsReadable { get; }
    public bool IsWriteable { get; }
    public bool IsStatic { get; }
    [NotNullAttribute]
public Type DeclaringType { get; }
    public abstract virtual int get_Order();
    public abstract virtual string get_Name();
    public abstract virtual Type get_Type();
    public abstract virtual bool get_IsReadable();
    public abstract virtual bool get_IsWriteable();
    public abstract virtual bool get_IsStatic();
    public abstract virtual Type get_DeclaringType();
    [CanBeNullAttribute]
public abstract virtual object GetValue(object instance);
    public abstract virtual void SetValue(object instance, object value);
    public abstract virtual TAttribute GetAttribute();
    public abstract virtual IEnumerable`1<TAttribute> GetAttributes();
}
public interface JetBrains.Util.CommandLineMapper.Impl.IOptionMarkers {
    [NotNullAttribute]
public string DefaultKeyMarker { get; }
    public char DefaultShortcutMarker { get; }
    [NotNullAttribute]
public string DefaultNonKeyedMarker { get; }
    public char DefaultValueSeparator { get; }
    public abstract virtual string get_DefaultKeyMarker();
    public abstract virtual char get_DefaultShortcutMarker();
    public abstract virtual string get_DefaultNonKeyedMarker();
    public abstract virtual char get_DefaultValueSeparator();
    public abstract virtual bool IsKeyOrShortcutMarker(char ch);
}
internal class JetBrains.Util.CommandLineMapper.Impl.MappedField : AbstractMappedMember {
    private FieldInfo myField;
    protected MemberInfo MemberInfo { get; }
    public Type Type { get; }
    public bool IsReadable { get; }
    public bool IsWriteable { get; }
    public bool IsStatic { get; }
    public MappedField(FieldInfo field);
    protected virtual MemberInfo get_MemberInfo();
    public virtual Type get_Type();
    public virtual bool get_IsReadable();
    public virtual bool get_IsWriteable();
    public virtual bool get_IsStatic();
    public virtual object GetValue(object instance);
    public virtual void SetValue(object instance, object value);
}
internal class JetBrains.Util.CommandLineMapper.Impl.MappedProperty : AbstractMappedMember {
    private PropertyInfo myProperty;
    protected MemberInfo MemberInfo { get; }
    public Type Type { get; }
    public bool IsReadable { get; }
    public bool IsWriteable { get; }
    public bool IsStatic { get; }
    public MappedProperty(PropertyInfo property);
    protected virtual MemberInfo get_MemberInfo();
    public virtual Type get_Type();
    public virtual bool get_IsReadable();
    public virtual bool get_IsWriteable();
    public virtual bool get_IsStatic();
    public virtual object GetValue(object instance);
    public virtual void SetValue(object instance, object value);
}
[ExtensionAttribute]
internal static class JetBrains.Util.CommandLineMapper.Impl.MultiValueUtils : object {
    [ExtensionAttribute]
public static bool IsEnumerableOfAny(Type type);
    [ExtensionAttribute]
public static bool IsEnumerableOfAny(Type type, Type& itemType);
    [ExtensionAttribute]
public static bool IsEnumerableOf(Type type, Type itemType);
    [ExtensionAttribute]
private static bool IsEnumerable(Type type, Type& itemType);
    [NotNullAttribute]
public static IEnumerable`1<string> Split(string value, char separator);
    [ExtensionAttribute]
[NotNullAttribute]
public static object ToTypedArray(IReadOnlyList`1<object> items, Type itemType);
    public static bool Equals(object one, object other);
}
public class JetBrains.Util.CommandLineMapper.Impl.OptionFormatter : object {
    private IOptionMarkers myOptionMarkers;
    public string KeyMarker { get; }
    public char ShortcutMarker { get; }
    public string NonKeyedMarker { get; }
    public char ValueSeparator { get; }
    public OptionFormatter(IOptionMarkers optionMarkers);
    public static bool IsKeyOrShortcutMarker(char c);
    public sealed virtual string get_KeyMarker();
    public sealed virtual char get_ShortcutMarker();
    public sealed virtual string get_NonKeyedMarker();
    public sealed virtual char get_ValueSeparator();
    public sealed virtual string Format(AbstractOptionAttribute optionAttribute, bool isMultiValued);
    public sealed virtual string Format(AbstractGroupAttribute groupAttribute, bool isMultipleAllowed);
    public sealed virtual string Format(AbstractGroupDefinitionAttribute groupDefinitionAttribute);
    public sealed virtual string Format(AbstractOptionAttribute optionAttribute, object value, Boolean& nonKeyedMarkerRequired);
    private bool IsNonKeyedMarkerRequired(string formattedValue, bool isRaw);
    public sealed virtual string FormatName(AbstractOptionAttribute optionAttribute);
    public sealed virtual string FormatName(AbstractGroupAttribute groupAttribute);
    [UsedImplicitlyAttribute]
private string FormatGroup(AbstractGroupAttribute groupAttribute, bool isMultipleAllowed);
    [UsedImplicitlyAttribute]
private string FormatGroup(ExplicitGroupAttribute groupAttribute, bool isMultipleAllowed);
    [UsedImplicitlyAttribute]
private static string FormatGroupDefinition(AbstractGroupDefinitionAttribute groupDefinition);
    [UsedImplicitlyAttribute]
private static string FormatGroupDefinition(CommandDefinitionAttribute commandDefinition);
    [UsedImplicitlyAttribute]
private static string FormatGroupDefinition(ImplicitGroupDefinitionAttribute implicitGroupDefinition);
    [UsedImplicitlyAttribute]
private string FormatGroupDefinition(ExplicitGroupDefinitionAttribute explicitGroupDefinition);
}
public class JetBrains.Util.CommandLineMapper.Impl.OptionsValidator : AbstractOptionsIntrospector {
    private bool myValidateTextHelp;
    private UniqueContext myCurrentUniqueContext;
    private UniqueContext myParentUniqueContext;
    private bool myCurrentGroupIsMultiple;
    private bool myIsCommandFound;
    private bool myIsInsideCommand;
    protected BindingFlags BindingFlags { get; }
    public OptionsValidator(StringComparer comparer, bool validateTextHelp);
    protected virtual BindingFlags get_BindingFlags();
    protected virtual void Begin(Type type);
    protected virtual void End(Type type);
    protected virtual void OnOption(AbstractOptionAttribute optionAttribute, IMappedMember member);
    protected virtual void BeginGroup(AbstractGroupAttribute groupAttribute, IMappedMember member);
    [UsedImplicitlyAttribute]
private void ValidateGroup(AbstractGroupAttribute groupAttribute, IMappedMember member);
    [UsedImplicitlyAttribute]
private void ValidateGroup(CommandGroupAttribute commandAttribute, IMappedMember member);
    protected virtual void EndGroup();
    protected virtual void OnGroupDefinition(AbstractGroupDefinitionAttribute groupDefinitionAttribute, Type type);
    private void ValidateConstructor(Type type);
    private void ValidateDeclaration(IMappedMember member);
    private void ValidateOptionUnique(AbstractOptionAttribute optionAttribute, IMappedMember member);
    private void ValidateKeyUnique(string key, IMappedMember member);
    private void ValidateShortcutUnique(char shortcut, IMappedMember member);
    private void ValidateAliasUnique(string alias, IMappedMember member);
    private void ValidateNonKeyedIndexUnique(int nonKeyedIndex, bool isTail, IMappedMember member);
    private void ValidateOptionPosition(IMappedMember member);
    private void ValidateOptionMultiValueType(AbstractOptionAttribute optionAttribute, IMappedMember member);
    private void ValidateOptionValueType(AbstractOptionAttribute optionAttribute, IMappedMember member);
    private void ValidateOptionDefaultValue(AbstractOptionAttribute optionAttribute, IMappedMember member);
    private void ValidateOptionEmptyValue(AbstractOptionAttribute optionAttribute, IMappedMember member);
    private void ValidateMultiGroupType(AbstractGroupAttribute groupAttribute, IMappedMember member, Type groupType);
    private void ValidateGroupKnownTypes(AbstractGroupAttribute groupAttribute, IMappedMember member, Type groupType);
    private void ValidateExamples(Type type);
    private void ValidateCustomHelp(Type type);
    private void ValidateHelpText(AbstractOptionAttribute optionAttribute, IMappedMember member);
    [StringFormatMethodAttribute("format")]
private static Exception ValidationException(IMappedMember member, string format, Object[] args);
    [StringFormatMethodAttribute("format")]
private static Exception ValidationException(MethodInfo method, string format, Object[] args);
    [StringFormatMethodAttribute("format")]
private static Exception ValidationException(string format, Object[] args);
    private static string FormatLong(IMappedMember member);
    private static string FormatShort(IMappedMember member);
    private static string FormatType(Type type);
    private static StringBuilder FormatType(StringBuilder sb, Type type);
}
public static class JetBrains.Util.CommandLineMapper.Impl.PathParserUtils : object {
    public static string ExpandVariables(string path);
    public static FileSystemPath ParseExpandablePath(string value, bool mustExist);
    public static FileSystemPath ParseExpandableDirectory(string value, bool mustExist, bool mustNotExist);
    public static FileSystemPath ParseExpandableFile(string value, bool mustExist, bool mustNotExist);
    public static FileSystemPath ParsePath(string value, bool mustExist);
    public static FileSystemPath ParseDirectory(string value, bool mustExist, bool mustNotExist);
    public static FileSystemPath ParseFile(string value, bool mustExist, bool mustNotExist);
    private static FileSystemPath ParseExpandablePathCore(string value, bool mustExist, bool mustNotExist, PathEntity pathEntity);
    private static FileSystemPath ParsePathCore(string value, bool mustExist, bool mustNotExist, PathEntity pathEntity);
    private static CommandLineException GetInvalidPathException(PathEntity pathEntity, string path);
    private static CommandLineException GetPathExistsException(PathEntity pathEntity, string path);
    private static CommandLineException GetPathExistsException(PathEntity expectedEntity, PathEntity actualEntity, string path);
    private static CommandLineException GetPathDoesntExistsException(PathEntity pathEntity, string path);
    private static bool Exists(PathEntity pathEntity, FileSystemPath path);
}
public class JetBrains.Util.CommandLineMapper.Impl.UniversalParser : AbstractParser {
    [CompilerGeneratedAttribute]
private Char[] <ShortcutMarks>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <KeyMarks>k__BackingField;
    protected Char[] ShortcutMarks { get; }
    protected String[] KeyMarks { get; }
    public UniversalParser(IReadOnlyList`1<string> rawArguments, CommandLineParserSettings settings);
    public UniversalParser(string rawCommandLine, CommandLineParserSettings settings);
    [CompilerGeneratedAttribute]
protected virtual Char[] get_ShortcutMarks();
    [CompilerGeneratedAttribute]
protected virtual String[] get_KeyMarks();
}
public class JetBrains.Util.CommandLineMapper.Impl.UnixStyleParser : AbstractParser {
    [CompilerGeneratedAttribute]
private Char[] <ShortcutMarks>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <KeyMarks>k__BackingField;
    protected Char[] ShortcutMarks { get; }
    protected String[] KeyMarks { get; }
    public UnixStyleParser(IReadOnlyList`1<string> rawArguments, CommandLineParserSettings settings);
    public UnixStyleParser(string rawCommandLine, CommandLineParserSettings settings);
    [CompilerGeneratedAttribute]
protected virtual Char[] get_ShortcutMarks();
    [CompilerGeneratedAttribute]
protected virtual String[] get_KeyMarks();
}
public interface JetBrains.Util.CommandLineMapper.IOptionFormatter {
    [NotNullAttribute]
public string KeyMarker { get; }
    public char ShortcutMarker { get; }
    [NotNullAttribute]
public string NonKeyedMarker { get; }
    public char ValueSeparator { get; }
    public abstract virtual string get_KeyMarker();
    public abstract virtual char get_ShortcutMarker();
    public abstract virtual string get_NonKeyedMarker();
    public abstract virtual char get_ValueSeparator();
    [NotNullAttribute]
public abstract virtual string Format(AbstractOptionAttribute optionAttribute, bool isMultiValued);
    [NotNullAttribute]
public abstract virtual string Format(AbstractGroupAttribute groupAttribute, bool isMultipleAllowed);
    [NotNullAttribute]
public abstract virtual string Format(AbstractGroupDefinitionAttribute groupDefinitionAttribute);
    [NotNullAttribute]
public abstract virtual string Format(AbstractOptionAttribute optionAttribute, object value, Boolean& nonKeyedMarkerRequired);
    [NotNullAttribute]
public abstract virtual string FormatName(AbstractOptionAttribute optionAttribute);
    [NotNullAttribute]
public abstract virtual string FormatName(AbstractGroupAttribute groupAttribute);
}
public interface JetBrains.Util.CommandLineMapper.ISupportRawCommandLine {
    [NotNullAttribute]
public abstract virtual string GetNonKeyedTailRaw(int startNonKeyedParamIndex);
}
public interface JetBrains.Util.CommandLineMapper.ISupportRawValueFormat {
}
public class JetBrains.Util.CommandLineMapper.KeyDefinition : object {
    private string myKey;
    private char myShortcut;
    private string myAlias;
    private bool myIsValueExpected;
    private bool myIsValueRequired;
    [NotNullAttribute]
public string Key { get; }
    public bool HasShortcut { get; }
    public char Shortcut { get; }
    public bool HasAlias { get; }
    [NotNullAttribute]
public string Alias { get; }
    public bool IsValueExpected { get; }
    public bool IsValueRequired { get; }
    public KeyDefinition(string key, char shortcut, string alias, bool isValueExpected, bool isValueRequired);
    public string get_Key();
    public bool get_HasShortcut();
    public char get_Shortcut();
    public bool get_HasAlias();
    public string get_Alias();
    public bool get_IsValueExpected();
    public bool get_IsValueRequired();
    public virtual string ToString();
    public sealed virtual bool Equals(KeyDefinition other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class JetBrains.Util.CommandLineMapper.KeyDefinitionSet : object {
    private Dictionary`2<char, KeyDefinition> myShortcutsMap;
    private Dictionary`2<string, KeyDefinition> myKeysMap;
    private Dictionary`2<string, KeyDefinition> myAliasesMap;
    private KeyDefinitionSet(StringComparer keyComparer);
    [CanBeNullAttribute]
public KeyDefinition TryGetByKey(string key);
    [CanBeNullAttribute]
public KeyDefinition TryGetByShortcut(char shortcut);
    [CanBeNullAttribute]
public KeyDefinition TryGetByAlias(string alias);
    public ISet`1<KeyDefinition> ToSet();
    public static Builder CaseSensitive();
    public static Builder CaseInsensitive();
}
[ExtensionAttribute]
public static class JetBrains.Util.CommandLineMapper.OptionFormatterExtension : object {
    [ExtensionAttribute]
public static string FormatKey(IOptionFormatter formatter, string key, char shortcut);
    [ExtensionAttribute]
[NotNullAttribute]
public static string FormatName(IOptionFormatter formatter, Expression`1<Func`2<TOptions, TValue>> fieldPicker);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static string TryFormatName(IOptionFormatter formatter, Expression`1<Func`2<TOptions, TValue>> fieldPicker);
    [ExtensionAttribute]
public static string FormatNameAndValue(IOptionFormatter formatter, Expression`1<Func`2<TOptions, TValue>> fieldPicker, TValue value);
    [ExtensionAttribute]
public static bool IsKeyed(IOptionFormatter formatter, string argument);
    private static IMappedMember GetMappedMember(Expression`1<Func`2<TOptions, TValue>> memberPicker);
}
public class JetBrains.Util.CommandLineMapper.PredefinedOptionsOrder : object {
    public static int RequiredNonKeyed;
    public static int OptionalNonKeyed;
    public static int RequiredKeyed;
    public static int OptionalKeyed;
    public static int Command;
    public static int NonKeyedTail;
}
public class JetBrains.Util.CommandLineMapper.UsageExample : object {
    [CompilerGeneratedAttribute]
private object <Options>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HelpText>k__BackingField;
    [CompilerGeneratedAttribute]
private AbstractOptionFilterAttribute <Filter>k__BackingField;
    [CanBeNullAttribute]
public object Options { get; }
    [CanBeNullAttribute]
public string HelpText { get; }
    [CanBeNullAttribute]
public AbstractOptionFilterAttribute Filter { get; }
    public UsageExample(object options, string helpText, AbstractOptionFilterAttribute filter);
    [CompilerGeneratedAttribute]
public object get_Options();
    [CompilerGeneratedAttribute]
public string get_HelpText();
    [CompilerGeneratedAttribute]
public AbstractOptionFilterAttribute get_Filter();
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Util.CommandLineMapper.WildcardedPath : object {
    private string myValue;
    public int Count { get; }
    public FileSystemPath Item { get; }
    public WildcardedPath(string value);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IEnumerator`1<FileSystemPath> GetEnumerator();
    public sealed virtual int get_Count();
    public sealed virtual FileSystemPath get_Item(int index);
    public virtual string ToString();
}
public static class JetBrains.Util.CompanySpecificFolderLocations : object {
    public static string JET_LOCAL_APPDATA_DIR;
    public static string JET_ROAMING_APPDATA_DIR;
    public static string JET_TEMP_DIR;
    private static Lazy`1<FileSystemPath> ourLocalAppData;
    private static Lazy`1<FileSystemPath> ourRoamingAppData;
    private static Lazy`1<FileSystemPath> ourTemp;
    [NotNullAttribute]
public static FileSystemPath LocalAppdata { get; }
    [NotNullAttribute]
public static FileSystemPath RoamingAppdata { get; }
    [NotNullAttribute]
public static FileSystemPath TempFolder { get; }
    private static CompanySpecificFolderLocations();
    public static FileSystemPath get_LocalAppdata();
    public static FileSystemPath get_RoamingAppdata();
    public static FileSystemPath get_TempFolder();
}
public class JetBrains.Util.Comparator`1 : MulticastDelegate {
    public Comparator`1(object object, IntPtr method);
    public virtual int Invoke(T x, T y);
    public virtual IAsyncResult BeginInvoke(T x, T y, AsyncCallback callback, object object);
    public virtual int EndInvoke(IAsyncResult result);
}
public static class JetBrains.Util.Compression.Crc32Helper : object {
    private static UInt32[] ourTable;
    private static Crc32Helper();
    public static UInt32 CalculateCrc32(Byte[] bytes, int start, int count);
    public static UInt32 UpdateCrc32(UInt32 crc32, Byte[] bytes, int start, int count);
}
public class JetBrains.Util.Console.ConsoleLoggerListener : object {
    [ObsoleteAttribute("Has no effect - always write verbose and trace to output if listener is configured with such logging level")]
public bool WriteVerboseAndTraceToOutput;
    [CompilerGeneratedAttribute]
private IFilter[] <Filters>k__BackingField;
    [CompilerGeneratedAttribute]
private ILayout <Layout>k__BackingField;
    public IFilter[] Filters { get; public set; }
    public ILayout Layout { get; public set; }
    public sealed virtual void OnLogEvent(LogEvent logEvent);
    [CompilerGeneratedAttribute]
public sealed virtual IFilter[] get_Filters();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Filters(IFilter[] value);
    [CompilerGeneratedAttribute]
public sealed virtual ILayout get_Layout();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Layout(ILayout value);
}
public static class JetBrains.Util.Console.CrossAppDomainSynchronizedConsole : object {
    private static string ourLockFileNameFormat;
    public static TextWriter Out;
    public static TextWriter Error;
    private static CrossAppDomainSynchronizedConsole();
}
public static class JetBrains.Util.Console.OutputUtil : object {
    private static object ourSync;
    private static OutputUtil();
    public static void WriteLineOutput(string text, Object[] args);
    public static void WriteLineError(string error, Object[] args);
    public static void WriteLineWarning(string warning, Object[] args);
    private static void WriteColoredLineToStdErr(ConsoleColor color, string message, Object[] args);
    private static ConsoleColor GetCurrentColor();
    private static void SetCurrentColor(TextWriter writer, ConsoleColor color);
    private static string ColorToEscapeSequence(ConsoleColor color);
    [MustDisposeResourceAttribute]
public static LocalRefDisposable`1<TextWriter> ReplaceOut(TextWriter writer, TextWriter& prevOutput);
    [MustDisposeResourceAttribute]
public static LocalRefDisposable`1<TextWriter> ReplaceError(TextWriter writer, TextWriter& prevError);
}
public abstract class JetBrains.Util.ConvertableEnumPattern`1 : EnumPattern {
    private static ConcurrentDictionary`2<string, T> ourConstants;
    protected static ConcurrentDictionary`2<string, T> Constants { get; }
    protected ConvertableEnumPattern`1(string name);
    private static ConvertableEnumPattern`1();
    protected static ConcurrentDictionary`2<string, T> get_Constants();
    public static T GetOrCreate(string name, Func`2<string, T> factory);
    public static T GetOrCreate(string name, Func`3<string, TFactoryArg, T> factory, TFactoryArg arg);
    [CanBeNullAttribute]
public static T TryGet(string name);
    [CanBeNullAttribute]
[ObsoleteAttribute("Replace usage with TryGet if you read a remarks regarding EnumPatterns in ConvertableEnumPattern class")]
public static T FromString(string name);
}
public class JetBrains.Util.ConvertableEnumPatternConverter`1 : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object source);
}
public class JetBrains.Util.Converters.JetSemanticVersionJSonConvertor : JsonConverter {
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual bool CanConvert(Type objectType);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
}
public class JetBrains.Util.Converters.VersionJSonConvertor : JsonConverter {
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual bool CanConvert(Type objectType);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
}
public static class JetBrains.Util.Crossgen.CrossgenUtil : object {
    public static bool IsNI(RelativePath path);
    public static bool IsNI(FileSystemPath path);
}
public class JetBrains.Util.Crossgen.InstructionSetSupport : object {
    public bool Aes;
    public bool Avx;
    public bool Avx2;
    public bool AvxVnni;
    public bool Bmi1;
    public bool Bmi2;
    public bool Fma;
    public bool Lzcnt;
    public bool Pclmulqdq;
    public bool Popcnt;
    public bool Sse;
    public bool Sse2;
    public bool Sse3;
    public bool Sse41;
    public bool Sse42;
    public bool Ssse3;
    public bool AdvSimd;
    public bool Crc32;
    public bool Dp;
    public bool Rdm;
    public bool Sha1;
    public bool Sha256;
    public static InstructionSetSupport Current();
    private static bool IsSupported(string typeName);
}
public class JetBrains.Util.CsvHelper : object {
    public static String[][] Parse(string text, char separator, bool forceUnwrap);
    public static string Unwrap(string value, bool unwrapIfContainsLineBreaks, char separator, bool forceUnwrap);
    public static string Wrap(string value, string separator, bool force);
}
public class JetBrains.Util.CultureCookie : object {
    public static CultureInfo TURKISH;
    private CultureInfo myOldCulture;
    private CultureCookie(CultureInfo newCulture);
    private static CultureCookie();
    public static IDisposable SetCulture(CultureInfo newCulture);
    public static IDisposable SetInvariantCulture();
    public static void SetInvariantCulture(Lifetime lifetime);
    public sealed virtual void Dispose();
}
[ExtensionAttribute]
public static class JetBrains.Util.DataFlow.Extension.ListValidator : object {
    [ExtensionAttribute]
[NotNullAttribute]
public static ListEvents`1<TValue> EnsureReadonly(ListEvents`1<TValue> thіs, ReadonlyToken token);
    [ExtensionAttribute]
[NotNullAttribute]
public static ListEvents`1<TValue> EnsureReadonly(ListEvents`1<TValue> thіs, Lifetime lifetime, ReadonlyToken token);
    [ExtensionAttribute]
[NotNullAttribute]
public static ListEvents`1<TItem> EnsureThisThread(ListEvents`1<TItem> thіs);
    [ExtensionAttribute]
[NotNullAttribute]
public static ListEvents`1<TItem> EnsureThisThread(ListEvents`1<TItem> thіs, Lifetime lifetime);
}
public class JetBrains.Util.dataStructures.AggregatedSet`2 : object {
    private object myLockObject;
    private OneToSetMap`2<T, TProvider> myData;
    private Dictionary`2<TProvider, HashSet`1<T>> myProviderData;
    [CompilerGeneratedAttribute]
private ISignal`1<ChangedArgs<T, TProvider>> <Changed>k__BackingField;
    public ISignal`1<ChangedArgs<T, TProvider>> Changed { get; }
    public AggregatedSet`2(Lifetime lifetime);
    [CompilerGeneratedAttribute]
public ISignal`1<ChangedArgs<T, TProvider>> get_Changed();
    public HashSet`1<T> GetData();
    public void OnProviderDataChanged(TProvider provider, HashSet`1<T> newData);
    private bool AddProviderItem(T item, TProvider provider);
    private bool RemoveProviderItem(T item, TProvider provider);
    [CompilerGeneratedAttribute]
private void <.ctor>b__7_0();
    [CompilerGeneratedAttribute]
private void <.ctor>b__7_1();
}
[ExtensionAttribute]
public static class JetBrains.Util.dataStructures.AggregatedSetEx : object {
    [ExtensionAttribute]
public static void OnProviderDataChanged(AggregatedSet`2<T, TProvider> aggregatedSet, TProvider provider, T[] newData);
    [ExtensionAttribute]
public static void OnProviderDataChanged(AggregatedSet`2<T, TProvider> aggregatedSet, TProvider provider, IEnumerable`1<T> newData);
}
public class JetBrains.Util.dataStructures.BankSwitchingMemoryStreamSimple : object {
    public static UInt32 DefaultBankSizeExponent;
    public static UInt32 DefaultOpenBanksLimit;
    private UInt32 myBankSizeExponent;
    [NotNullAttribute]
private BankSwitcher myBankSwitcher;
    private GlobalStateFlags myGlobalStateFlags;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private StrongToWeakDictionary`2<ValueTuple`2<ulong, ulong>, ImmutableSubstream> myImmutableSubstreamsWeak;
    private ulong myLengthLimit;
    private Lifetime myLifetime;
    private LockObject myLockStreamsList;
    [CanBeNullAttribute]
private Substream mySubstreamAppending;
    private List`1<StreamAccessData> mySubstreamsFixedLengthLifetimed;
    private ulong myWrittenLengthExceptForActiveAppending;
    public ILogger Logger;
    public bool CanOpenSubstreamForAppendingNow { get; }
    public ulong CommittedLength { get; }
    public ulong LengthLimit { get; }
    public ulong UncommittedLength { get; }
    private bool JetBrains.Util.Collections.IFreezable.IsFrozen { get; }
    public BankSwitchingMemoryStreamSimple(Lifetime lifetime, ulong qwLengthLimit, BankSpec bankspec);
    private BankSwitchingMemoryStreamSimple(Lifetime lifetime, Void* hExternalMmf, ulong qwLengthLimit, ulong qwWrittenLength, BankSpec bankspec);
    private static BankSwitchingMemoryStreamSimple();
    public bool get_CanOpenSubstreamForAppendingNow();
    public ulong get_CommittedLength();
    public ulong get_LengthLimit();
    public ulong get_UncommittedLength();
    [NotNullAttribute]
public Substream AppendSubstreamFixedLength(Lifetime lifetime, ulong length);
    [NotNullAttribute]
public static BankSwitchingMemoryStreamSimple Attach(Lifetime lifetime, Void* hExistingMmf, ulong qwMmfSize, ulong qwWrittenLength, BankSpec bankspec);
    [NotNullAttribute]
public static Void* CreateStandardMmf(Lifetime lifetime, ulong qwLengthLimit);
    [NotNullAttribute]
public Substream OpenFullStream(Lifetime lifetime);
    [NotNullAttribute]
public ImmutableByteStream OpenImmutableStreamWithGc(ulong start, ulong length);
    [NotNullAttribute]
public ImmutableByteStream OpenImmutableSubstreamWithLifetime(Lifetime lifetime, ulong start, ulong length);
    [NotNullAttribute]
public Substream OpenSubstreamFixedLength(Lifetime lifetime, ulong start, ulong length, ReadWrite rw);
    [NotNullAttribute]
public Substream OpenSubstreamForAppending(Lifetime lifetime);
    public UInt32 ReadAt(ulong ulOffset, Void* pv, UInt32 cb);
    public void ReleaseBanks();
    private sealed virtual override void JetBrains.Util.Collections.IFreezable.Freeze();
    private sealed virtual override bool JetBrains.Util.Collections.IFreezable.get_IsFrozen();
    [CompilerGeneratedAttribute]
private void <.ctor>b__13_0();
}
public class JetBrains.Util.dataStructures.BidirectionalMapOnCompactMap`2 : object {
    private CompactMap`2<TLeft, TRight> myLeftToRightMap;
    private CompactMap`2<TRight, TLeft> myRightToLeftMap;
    public int Count { get; }
    public ICollection`1<TLeft> LeftKeys { get; }
    public IDictionary`2<TLeft, TRight> LeftToRight { get; }
    public ICollection`1<TRight> RightKeys { get; }
    public IDictionary`2<TRight, TLeft> RightToLeft { get; }
    public BidirectionalMapOnCompactMap`2(int capacity);
    public BidirectionalMapOnCompactMap`2(int capacity, IEqualityComparer`1<TLeft> leftComparer, IEqualityComparer`1<TRight> rightComparer);
    public BidirectionalMapOnCompactMap`2(IEqualityComparer`1<TLeft> leftComparer, IEqualityComparer`1<TRight> rightComparer);
    public int get_Count();
    public ICollection`1<TLeft> get_LeftKeys();
    public IDictionary`2<TLeft, TRight> get_LeftToRight();
    public ICollection`1<TRight> get_RightKeys();
    public IDictionary`2<TRight, TLeft> get_RightToLeft();
    public void Add(TLeft left, TRight right);
    public void Clear();
    public bool ContainsLeft(TLeft left);
    public bool ContainsRight(TRight right);
    public sealed virtual IEnumerator GetEnumerator();
    public TLeft GetLeftByRight(TRight right);
    public TRight GetRightByLeft(TLeft left);
    public void RemoveLeft(TLeft left);
    public void RemoveMapping(TLeft left, TRight right);
    public void RemoveRight(TRight right);
    public void SetMapping(TLeft left, TRight right, bool bIgnoreConflicts);
    public bool TryGetLeftByRight(TRight right, TLeft& left);
    public bool TryGetRightByLeft(TLeft left, TRight& right);
    private static ArgumentException CreateDuplicateLeftKeysException(TLeft left, TRight right, TRight oldRight);
    private static ArgumentException CreateDuplicateRightKeysException(TLeft left, TRight right, TLeft oldLeft);
    private sealed virtual override IEnumerator`1<KeyValuePair`2<TLeft, TRight>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TLeft,TRight>>.GetEnumerator();
}
public enum JetBrains.Util.dataStructures.Bit : Enum {
    public int value__;
    public static Bit Zero;
    public static Bit One;
}
public static class JetBrains.Util.dataStructures.Boxed : object {
    public static int Compare(Boxed`1<T> n1, Boxed`1<T> n2);
    [ComVisibleAttribute("True")]
public static bool Equals(Boxed`1<T> n1, Boxed`1<T> n2);
    public static Boxed`1<T> From(T t);
    public static Type TryGetUnderlyingType(Type boxedtype);
}
public class JetBrains.Util.dataStructures.Boxed`1 : object {
    [CanBeNullAttribute]
public T Value;
    public Boxed`1(T value);
    public sealed virtual bool Equals(Boxed`1<T> other);
    public sealed virtual int CompareTo(Boxed`1<T> other);
    [NotNullAttribute]
public static Boxed`1<T> op_Explicit(T value);
    public static T op_Explicit(Boxed`1<T> value);
    public static bool op_Equality(Boxed`1<T> left, Boxed`1<T> right);
    public static bool op_Inequality(Boxed`1<T> left, Boxed`1<T> right);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public enum JetBrains.Util.dataStructures.CapacityPolicy : Enum {
    public int value__;
    public static CapacityPolicy ExactFit;
    public static CapacityPolicy FibGrow;
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Util.DataStructures.ChunkHashMap`2 : object {
    private static Statistics Statistics;
    private IEqualityComparer`1<TKey> myComparer;
    private LocalChunkArray`1<Entry<TKey, TValue>> myEntries;
    private LocalChunkArray`1<int> myHashToEntryIndex;
    private int myEntriesUsed;
    private int myFirstFreeIndex;
    private int myFreeCount;
    private KeyCollection<TKey, TValue> myKeys;
    private ValueCollection<TKey, TValue> myValues;
    private int myVersion;
    public IEqualityComparer`1<TKey> Comparer { get; }
    private ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.Keys { get; }
    private ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.Values { get; }
    public KeyCollection<TKey, TValue> Keys { get; }
    public ValueCollection<TKey, TValue> Values { get; }
    private IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Keys { get; }
    private IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Values { get; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.IsReadOnly { get; }
    public TValue Item { get; public set; }
    public ChunkHashMap`2(IDictionary`2<TKey, TValue> dictionary);
    public ChunkHashMap`2(IEqualityComparer`1<TKey> comparer);
    public ChunkHashMap`2(int capacity);
    public ChunkHashMap`2(IDictionary`2<TKey, TValue> dictionary, IEqualityComparer`1<TKey> comparer);
    public ChunkHashMap`2(int capacity, IEqualityComparer`1<TKey> comparer);
    private static ChunkHashMap`2();
    public IEqualityComparer`1<TKey> get_Comparer();
    private sealed virtual override ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.get_Keys();
    private sealed virtual override ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.get_Values();
    public KeyCollection<TKey, TValue> get_Keys();
    public ValueCollection<TKey, TValue> get_Values();
    private sealed virtual override IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Keys();
    private sealed virtual override IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Values();
    public sealed virtual int get_Count();
    public sealed virtual void Add(TKey key, TValue value);
    public sealed virtual bool Remove(TKey key);
    public sealed virtual void Clear();
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Add(KeyValuePair`2<TKey, TValue> item);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Contains(KeyValuePair`2<TKey, TValue> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.CopyTo(KeyValuePair`2[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Remove(KeyValuePair`2<TKey, TValue> item);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.get_IsReadOnly();
    public sealed virtual bool ContainsKey(TKey key);
    public bool ContainsValue(TValue value);
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    public bool IsEmpty();
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    private sealed virtual override IEnumerator`1<KeyValuePair`2<TKey, TValue>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TValue>>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public Enumerator<TKey, TValue> GetEnumerator();
    private void RemoveEntry(int entryIndex, int prevIndex);
    private bool CompareKey(TKey key, int entryIndex);
    private int GetEntryIndex(TKey key);
    private void Initialize(int capacity);
    private void Insert(TKey key, TValue value, bool add);
    public void Compact();
    private void Expand();
    private void Resize(int newCapacity);
}
[DebuggerTypeProxyAttribute("JetBrains.Util.DataStructures.ChunkHashSetDebugView`1")]
[DebuggerDisplayAttribute("Count = {Count}")]
public class JetBrains.Util.DataStructures.ChunkHashSet`1 : object {
    private static Statistics Statistics;
    [NotNullAttribute]
private IEqualityComparer`1<T> myComparer;
    [NotNullAttribute]
private Func`2<T, int> myComparerGetHashCode;
    [NotNullAttribute]
private Func`3<T, T, bool> myComparerEquals;
    private LocalChunkArray`1<Entry<T>> myEntries;
    private LocalChunkArray`1<int> myHashToEntryIndex;
    private int myEntriesUsed;
    private int myFirstFreeIndex;
    private int myFreeCount;
    private int myVersion;
    [NotNullAttribute]
public IEqualityComparer`1<T> Comparer { get; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    public ChunkHashSet`1(IEnumerable`1<T> enumerable);
    public ChunkHashSet`1(IEqualityComparer`1<T> comparer);
    public ChunkHashSet`1(int capacity);
    public ChunkHashSet`1(IEnumerable`1<T> enumerable, IEqualityComparer`1<T> comparer);
    [EditorBrowsableAttribute("1")]
public ChunkHashSet`1(ICollection`1<T> collection, IEqualityComparer`1<T> comparer);
    public ChunkHashSet`1(int capacity, IEqualityComparer`1<T> comparer);
    private static ChunkHashSet`1();
    public IEqualityComparer`1<T> get_Comparer();
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    public bool Add(T element);
    protected bool AddImpl(TSource element, Func`2<TSource, int> getHashCode, Func`3<TSource, T, bool> equals, Func`2<TSource, T> elementConverter, T& storedElement);
    public sealed virtual bool Remove(T element);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T element);
    public T GetValue(T key);
    public T Intern(T key, Func`2<T, T> elementFactory);
    public bool TryGetValue(T key, T& value);
    public void CopyTo(T[] array);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public void CopyTo(T[] array, int arrayIndex, int count);
    public void UnionWith(IEnumerable`1<T> other);
    private void IntersectWith(ICollection`1<T> other);
    private bool IsSubsetOf(ICollection`1<T> other);
    public void IntersectWith(IEnumerable`1<T> other);
    public bool SetEquals(IEnumerable`1<T> other);
    [EditorBrowsableAttribute("1")]
public bool SetEquals(ChunkHashSet`1<T> other);
    private bool SetEqualsImpl(IEnumerable`1<T> other);
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public ElementEnumerator<T> GetEnumerator();
    public int RemoveWhere(Func`2<T, bool> predicate);
    public bool IsSubsetOf(IEnumerable`1<T> other);
    public bool IsSupersetOf(IEnumerable`1<T> other);
    [EditorBrowsableAttribute("1")]
public bool IsSupersetOf(ICollection`1<T> other);
    [EditorBrowsableAttribute("1")]
public bool IsSupersetOf(ChunkHashSet`1<T> other);
    private bool IsSupersetOfImpl(IEnumerable`1<T> other);
    private bool IsGreaterSet(ChunkHashSet`1<T> set);
    public bool Overlaps(IEnumerable`1<T> other);
    private static bool CollectionContainsAll(ICollection`1<T> collection, IEnumerable`1<T> other);
    public void ExceptWith(IEnumerable`1<T> other);
    private void RemoveEntry(int entryIndex, int prevIndex);
    private int GetEntryIndex(T key);
    private void Initialize(int capacity);
    public void Compact();
    private void Expand();
    private void Resize(int newCapacity);
    [NotNullAttribute]
public T[] ToArray();
}
[DebuggerTypeProxyAttribute("JetBrains.Util.DataStructures.ChunkHashSetDebugView`1")]
[DebuggerDisplayAttribute("Count = {Count}")]
public class JetBrains.Util.DataStructures.ChunkHashSetConversionIntern`2 : ChunkHashSet`1<T> {
    private Func`2<TSource, int> myGetHashCode;
    private Func`3<TSource, T, bool> myEquals;
    public ChunkHashSetConversionIntern`2(IChunkHashSetRawInternEqualityComparer`2<TSource, T> comparer);
    public ChunkHashSetConversionIntern`2(int capacity, IChunkHashSetRawInternEqualityComparer`2<TSource, T> comparer);
    public T Intern(TSource key, Func`2<TSource, T> convert);
}
internal class JetBrains.Util.DataStructures.ChunkHashSetDebugView`1 : object {
    private ChunkHashSet`1<T> myHashSet;
    [DebuggerBrowsableAttribute("3")]
public T[] Items { get; }
    public ChunkHashSetDebugView`1(ChunkHashSet`1<T> set);
    public T[] get_Items();
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Util.DataStructures.ChunkPackedIntArray : object {
    private static int MAX_CHUNK_SIZE;
    private int myLength;
    private int myValueBits;
    private int myStandardChunkLength;
    private UncheckedPackedIntArray[] myChunks;
    public UInt32[] Item { get; public set; }
    public int Length { get; }
    public int ValueBits { get; }
    public int ValueInts { get; }
    public ChunkPackedIntArray(int length, int valueBits);
    public UInt32[] get_Item(int index);
    public void set_Item(int index, UInt32[] value);
    public UInt32 GetItem(int index, int iSubIndex);
    public int get_Length();
    public int get_ValueBits();
    public int get_ValueInts();
    public static ChunkPackedIntArray IncreaseValueBits(ChunkPackedIntArray oldArray, int newValueBits);
    public void Clear();
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Util.DataStructures.ChunkSparseArray`1 : object {
    private static int myChunkSize;
    private int myCount;
    private T[][] myChunks;
    private int myLastChunkSize;
    public T Item { get; public set; }
    public ChunkSparseArray`1(int initialSize);
    public T get_Item(int index);
    public void set_Item(int index, T value);
}
public class JetBrains.Util.DataStructures.CompactIntToIntMap : CompactMapBase`4<int, int, CompactIntToIntMapStorage, object> {
    public CompactIntToIntMap(int intialSlotCount, double maxLoadFactor);
    protected virtual CompactIntToIntMapStorage CreateStorage(int slotCount);
    protected virtual SlotState<int, int, CompactIntToIntMapStorage, object> GetSlotState(CompactIntToIntMapStorage storage, int index, Int32& key);
    protected virtual object GetSlotData(CompactIntToIntMapStorage storage, int index);
    protected virtual int GetValue(CompactIntToIntMapStorage storage, int index, object data);
    protected virtual void SetValue(CompactIntToIntMapStorage storage, int index, int value);
    protected virtual void SetKeyAndValue(CompactIntToIntMapStorage storage, int index, int key, int value);
    protected virtual void RemoveValue(CompactIntToIntMapStorage storage, int index);
    protected virtual void ClearStorage(CompactIntToIntMapStorage storage);
}
public class JetBrains.Util.DataStructures.CompactIntToIntMapStorage : ValueType {
    public ChunkArray`1<int> Keys;
    public ChunkArray`1<int> Values;
    public ChunkArray`1<int> SlotStates;
    public CompactIntToIntMapStorage(int length);
    public int GetSlotState(int index);
    public void SetSlotState(int index, int state);
}
public class JetBrains.Util.dataStructures.CompactionPolicy : ValueType {
    public static CompactionPolicy DefaultFibGrow;
    public static CompactionPolicy DefaultExactFit;
    private float myFreeToAllSizeRatio;
    private int myFreeCount;
    private CompactionPolicyEnum myFlags;
    public float FreeToAllSizeRatio { get; }
    public int FreeCount { get; }
    public CompactionPolicyEnum Flags { get; }
    public bool CompactToExactSizeOnManualCompact { get; }
    public CompactionPolicy(CompactionPolicyEnum flags, int freeCount);
    public CompactionPolicy(CompactionPolicyEnum flags, float freeToAllSizeRatio);
    private static CompactionPolicy();
    public float get_FreeToAllSizeRatio();
    public int get_FreeCount();
    public CompactionPolicyEnum get_Flags();
    public bool get_CompactToExactSizeOnManualCompact();
}
[FlagsAttribute]
public enum JetBrains.Util.dataStructures.CompactionPolicyEnum : Enum {
    public int value__;
    public static CompactionPolicyEnum Manual;
    public static CompactionPolicyEnum Auto;
    public static CompactionPolicyEnum CompactWhenEmptyToAllRatioTooHigh;
    public static CompactionPolicyEnum CompactWhenFreeCountTooHigh;
    public static CompactionPolicyEnum CompactLastChunkOnManualCompact;
    public static CompactionPolicyEnum CompactToExactFitOnManualCompact;
}
public class JetBrains.Util.dataStructures.ConcatCollection`1 : ValueType {
    [NotNullAttribute]
private IReadOnlyCollection`1<TValue> myFirstCollection;
    [NotNullAttribute]
private IReadOnlyCollection`1<TValue> mySecondCollection;
    public int Count { get; }
    public ConcatCollection`1(IReadOnlyCollection`1<TValue> firstCollection, IReadOnlyCollection`1<TValue> secondCollection);
    [IteratorStateMachineAttribute("JetBrains.Util.dataStructures.ConcatCollection`1/<GetEnumerator>d__3")]
public sealed virtual IEnumerator`1<TValue> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual int get_Count();
}
public class JetBrains.Util.dataStructures.ConciseBitArray : SafeDisposable {
    public static int DefaultCapacity;
    public static int DefaultCompactifyThreshold;
    private static int BytesInChunk;
    private static int BitsInChunk;
    private static int BitsInCompressedChunk;
    private static int FillBit;
    private static int EmptyChunkMarkerMask;
    private static int BitsForPollution;
    private static int CompressBitMask;
    private static int FillBitMask;
    private static int ChunksNumberMask;
    private static int PollutionMask;
    private static int PollutionShift;
    private static int FillBitShift;
    public static int MaxSize;
    private int myArrayCapacity;
    private Int32* myArray;
    private int myNumberOfChunksAddedSinceLastCompactify;
    [CompilerGeneratedAttribute]
private int <CompactifyThreshold>k__BackingField;
    public static IUnsafeMarshaller`1<ConciseBitArray> Marshaller;
    public int CompactifyThreshold { get; public set; }
    public int Capacity { get; }
    public Int32* Ptr { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    private ConciseBitArray(int initialCapacity);
    private static ConciseBitArray();
    [CompilerGeneratedAttribute]
public int get_CompactifyThreshold();
    [CompilerGeneratedAttribute]
public void set_CompactifyThreshold(int value);
    public int get_Capacity();
    public Int32* get_Ptr();
    public static ConciseBitArray CreateEmpty(int initialCapacity);
    public static ConciseBitArray CreateFromExisting(int capacity, Int32* array);
    private static int ProduceLiteralWord(int word);
    private static int ProduceFillWord(int numOfChunks, Bit fill, int pollution);
    private static int MultiplyToBitsInCompressedChunk(int x);
    public bool Get(int i);
    public bool GetAndSet(int i);
    public bool GetAndUnset(int i);
    public void Set(int i);
    public void Unset(int i);
    private void Set(int i, Bit bit);
    private bool GetAndSet(int i, Bit bit);
    private void ReplaceByLiteral(Int32* ptr, int compressedChunksInThisFillChunk, int literal, int chunkNumber);
    private void ShiftChunksRight(Int32* ptr);
    private void ShiftChunksRight2(Int32* ptr);
    private void EnsureCapacity();
    public int Compactify(bool reduceCapacity);
    public int Cardinality();
    private void Realloc(int newCapacity);
    public int NumberOfChunks();
    protected virtual void DisposeUnmanagedResources();
    public IEnumerable`1<int> AsZeroEnumerable();
    public sealed virtual IEnumerator`1<int> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private static string Fmt(int x, int space);
    private static string ChunkToString(int chunk);
    public sealed virtual void Add(int item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(int item);
    public sealed virtual void CopyTo(Int32[] array, int arrayIndex);
    public sealed virtual bool Remove(int item);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public static void Write(UnsafeWriter writer, ConciseBitArray value);
    public static ConciseBitArray Read(UnsafeReader reader);
}
public class JetBrains.Util.dataStructures.ConcurrentCachingEnumerable`1 : object {
    private object myLockObject;
    private IEnumerable`1<T> myEnumerable;
    private IEnumerator`1<T> myEnumerator;
    private LocalList`1<T> myCachedItems;
    public ConcurrentCachingEnumerable`1(IEnumerable`1<T> enumerable);
    private bool TryEnsureItemAt(int index);
    private T GetItemAt(int index);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[ExtensionAttribute]
public static class JetBrains.Util.dataStructures.ConcurrentCachingEnumerableEx : object {
    [ExtensionAttribute]
public static ConcurrentCachingEnumerable`1<T> ToCachingEnumerable(IEnumerable`1<T> enumerable);
}
public class JetBrains.Util.DataStructures.ConvertedCollection`2 : ConvertedEnumerable`2<T1, T2> {
    private ICollection`1<T1> myOriginal;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public ConvertedCollection`2(ICollection`1<T1> original, Converter`2<T1, T2> converter);
    public sealed virtual void Add(T2 item);
    public sealed virtual void Clear();
    public sealed virtual bool Remove(T2 item);
    public sealed virtual bool Contains(T2 item);
    public sealed virtual void CopyTo(T2[] array, int arrayIndex);
    private static void CopyTo(IEnumerable`1<T> collection, T[] array, int index);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
}
public class JetBrains.Util.DataStructures.ConvertedEnumerable`2 : object {
    private IEnumerator`1<T1> myOriginal;
    private Converter`2<T1, T2> myConverter;
    public ConvertedEnumerable`2(IEnumerator`1<T1> original, Converter`2<T1, T2> converter);
    public ConvertedEnumerable`2(IEnumerable`1<T1> original, Converter`2<T1, T2> converter);
    public sealed virtual IEnumerator`1<T2> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class JetBrains.Util.DataStructures.ConvertedEnumerator`2 : object {
    private IEnumerator`1<T1> myOriginal;
    private Converter`2<T1, T2> myConverter;
    public T2 Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    public ConvertedEnumerator`2(IEnumerator`1<T1> original, Converter`2<T1, T2> converter);
    public sealed virtual void Dispose();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
    public sealed virtual T2 get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
}
public class JetBrains.Util.DataStructures.DataIntern`1 : object {
    private ChunkHashSet`1<T> myIntern;
    public DataIntern`1(IEqualityComparer`1<T> comparer);
    public DataIntern`1(int capacity, IEqualityComparer`1<T> comparer);
    public T Intern(T data);
    public bool TryGet(T data, T& internedData);
    public void Compact();
    public bool IsEmpty();
    public void Clear();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.Util.DataStructures.EnumeratorWithEnd`1 : object {
    private IEnumerator`1<T> myUnderlyingEnumerator;
    [CompilerGeneratedAttribute]
private bool <AtEnd>k__BackingField;
    [NullableAttribute("2")]
private object System.Collections.IEnumerator.Current { get; }
    public T Current { get; }
    public bool AtEnd { get; private set; }
    public EnumeratorWithEnd`1(IEnumerator`1<T> underlyingEnumerator);
    public sealed virtual void Dispose();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
    [NullableContextAttribute("2")]
private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual T get_Current();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_AtEnd();
    [CompilerGeneratedAttribute]
private void set_AtEnd(bool value);
}
public static class JetBrains.Util.dataStructures.FibFinder : object {
    public static Int32[] FibSeq;
    private static FibFinder();
    private static int SearchHiIndexFor(int x, int lo, int hi);
    public static int NextFib(int x);
    public static int NextFibIndex(int x);
}
public static class JetBrains.Util.dataStructures.FinalizerManager : object {
    public static Statistics Statistics;
    private static FinalizerManager();
}
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
public class JetBrains.Util.DataStructures.HybridCollection`1 : ValueType {
    public static HybridCollection`1<T> Empty;
    private T myItem;
    private IList`1<T> myItems;
    public bool IsEmpty { get; }
    public int Count { get; }
    [CanBeNullAttribute]
public T SingleItem { get; }
    [NotNullAttribute]
public T Item { get; }
    public HybridCollection`1(T item);
    private HybridCollection`1(IList`1<T> itemsList, IEnumerable`1<T> items);
    public HybridCollection`1(IEnumerable`1<T> items);
    public HybridCollection`1(IList`1<T> items);
    public HybridCollection`1(T[] items);
    public HybridCollection`1(HybridCollection`1& other);
    public bool get_IsEmpty();
    public int get_Count();
    public T get_SingleItem();
    public T get_Item(int index);
    [PureAttribute]
public int IndexOf(T item);
    [PureAttribute]
public bool Contains(T item);
    [PureAttribute]
public HybridCollection`1<T> Add(T item);
    [PureAttribute]
public HybridCollection`1<T> Add(HybridCollection`1<T> collection);
    [PureAttribute]
public HybridCollection`1<T> Add(IList`1<T> collection);
    [PureAttribute]
public HybridCollection`1<TCast> OfType();
    [NotNullAttribute]
[PureAttribute]
public IEnumerable`1<TResult> Select(Func`2<T, TResult> selector);
    [NotNullAttribute]
[PureAttribute]
public IEnumerable`1<TResult> SelectNotNull(Func`2<T, TResult> selector);
    [NotNullAttribute]
[PureAttribute]
public IEnumerable`1<TResult> SelectMany(Func`2<T, IEnumerable`1<TResult>> selector);
    [PureAttribute]
public bool Any();
    [PureAttribute]
public bool Any(Func`2<T, bool> predicate);
    [PureAttribute]
public bool All(Func`2<T, bool> predicate);
    [PureAttribute]
[NotNullAttribute]
public T First();
    [PureAttribute]
[NotNullAttribute]
public T Last();
    [PureAttribute]
[CanBeNullAttribute]
public T FirstOrDefault();
    [CanBeNullAttribute]
[PureAttribute]
public T FirstOrDefault(Func`2<T, bool> predicate);
    [CanBeNullAttribute]
[PureAttribute]
public T LastOrDefault();
    [PureAttribute]
[CanBeNullAttribute]
public T LastOrDefault(Func`2<T, bool> predicate);
    [PureAttribute]
[NotNullAttribute]
public IList`1<T> ResultingList();
    [PureAttribute]
[NotNullAttribute]
public IReadOnlyList`1<T> ReadOnlyList();
    [PureAttribute]
[NotNullAttribute]
public T[] ToArray();
    [PureAttribute]
public HybridCollectionEnumerator`1<T> GetEnumerator();
    private static T ThrowOutOfRange();
    private static T ThrowEmpty();
    public sealed virtual bool Equals(HybridCollection`1<T> other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class JetBrains.Util.DataStructures.HybridCollectionEnumerator`1 : ValueType {
    private HybridCollection`1<T> myOwner;
    private int myIndex;
    private T myCurrent;
    [NotNullAttribute]
public T Current { get; }
    internal HybridCollectionEnumerator`1(HybridCollection`1& owner);
    public bool MoveNext();
    public T get_Current();
    [ConditionalAttribute("JET_MODE_ASSERT")]
private void AssertIndex();
}
public class JetBrains.Util.DataStructures.HybridDistinctCollection`1 : ValueType {
    public static HybridDistinctCollection`1<T> Empty;
    [NotNullAttribute]
private static EqualityComparer`1<T> Comparer;
    private static int LinearThreshold;
    private object myData;
    public int Count { get; }
    public T SingleItem { get; }
    public bool IsEmpty { get; }
    public HybridDistinctCollection`1(T data);
    private static HybridDistinctCollection`1();
    [PureAttribute]
private bool ArrayContains(T[] array, T item);
    public bool Add(T item);
    public void Clear();
    public int get_Count();
    [PureAttribute]
public HybridDistinctCollection`1<T> Clone();
    [PureAttribute]
public bool Contains(T item);
    public T First();
    [PureAttribute]
[NotNullAttribute]
public T[] ToArray();
    [PureAttribute]
[NotNullAttribute]
public List`1<T> ToList();
    [NotNullAttribute]
public IReadOnlyCollection`1<T> ReadOnlyCollection();
    [NotNullAttribute]
public ICollection`1<T> ResultingCollection();
    public T get_SingleItem();
    public bool SetEquals(HybridDistinctCollection`1& other);
    [PureAttribute]
private static bool SetAndArrayEquals(T[] array, JetHashSet`1<T> set);
    public bool get_IsEmpty();
    public bool Remove(T item);
    [PureAttribute]
public Enumerator<T> GetEnumerator();
    private static T ThrowEmpty();
}
public interface JetBrains.Util.DataStructures.IChunkHashSetRawInternEqualityComparer`2 {
    public abstract virtual int GetHashCode(TRaw obj);
    public abstract virtual bool Equals(TRaw x, T y);
}
public interface JetBrains.Util.DataStructures.IEnumeratorWithEnd`1 {
    public bool AtEnd { get; }
    public abstract virtual bool get_AtEnd();
}
public class JetBrains.Util.DataStructures.ImmutableStack`1 : object {
    private T myHead;
    [CanBeNullAttribute]
private ImmutableStack`1<T> myTail;
    [NotNullAttribute]
public static ImmutableStack`1<T> Empty;
    public bool IsEmpty { get; }
    private ImmutableStack`1(T head, ImmutableStack`1<T> tail);
    private static ImmutableStack`1();
    public bool get_IsEmpty();
    public int GetCount();
    [PureAttribute]
public T Peek();
    [NotNullAttribute]
[PureAttribute]
public ImmutableStack`1<T> Pop();
    [NotNullAttribute]
[PureAttribute]
public ImmutableStack`1<T> Push(T value);
    [ContractAnnotationAttribute("=> halt")]
private static void ThrowEmptyStack();
    [PureAttribute]
public Enumerator<T> GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [IteratorStateMachineAttribute("JetBrains.Util.DataStructures.ImmutableStack`1/<GetEnumeratorImpl>d__16")]
[NotNullAttribute]
[PureAttribute]
private IEnumerator`1<T> GetEnumeratorImpl();
}
public class JetBrains.Util.dataStructures.IntSet : object {
    public static IntSet Empty;
    public static int DefaultMarker;
    private static int NextBucketShift;
    private static double LoadFactor;
    private Int32[] myArray;
    private int myCount;
    private int myVersion;
    private int myCapacity;
    private int myMarker;
    private bool myTreatMarkerAsSetElement;
    public static IUnsafeMarshaller`1<IntSet> Marshaller;
    public int Count { get; }
    public int Capacity { get; }
    public bool IsReadOnly { get; }
    private IntSet(int count, int marker, bool treatMarkerAsSetElement, Int32[] array);
    private IntSet(IntSet toClone);
    public IntSet(int expectedNumberOfElements, int marker, bool treatMarkerAsSetElement);
    private static IntSet();
    public static IntSet Read(UnsafeReader reader);
    public static void Write(UnsafeWriter writer, IntSet value);
    private void Init(int expectedCapacity);
    private void FillByMarker();
    private int InitBucket(int x);
    private int NextBucket(int prevBucket);
    private void Resize();
    private void EnsureCapacity();
    private bool AddInternal(int item);
    public sealed virtual void Add(int item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(int item);
    public sealed virtual void CopyTo(Int32[] array, int arrayIndex);
    public sealed virtual bool Remove(int item);
    public sealed virtual int get_Count();
    public int get_Capacity();
    public sealed virtual bool get_IsReadOnly();
    public IntSet Clone();
    public IntSetEnumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<int> System.Collections.Generic.IEnumerable<System.Int32>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[ExtensionAttribute]
public static class JetBrains.Util.dataStructures.IntSetExtensions : object {
    [ExtensionAttribute]
public static bool ContainsAll(IntSet intSet, Int32[] values);
}
public interface JetBrains.Util.DataStructures.ISettingsTable {
    public abstract virtual bool GetBoolean(string settingName);
    public abstract virtual bool GetBoolean(string settingName, bool defaultVal);
    public abstract virtual int GetInteger(string settingName);
    public abstract virtual int GetInteger(string settingName, int defaultVal);
    public abstract virtual string GetString(string settingName);
    public abstract virtual string GetString(string settingName, string defaultVal);
    public abstract virtual void SetBoolean(string settingName, bool val);
    public abstract virtual void SetInteger(string settingName, int val);
    public abstract virtual void SetString(string settingName, string val);
}
public interface JetBrains.Util.dataStructures.IValueConsumer`2 {
    public abstract virtual bool Consume(TValue value, TParameter parameter);
}
[DefaultMemberAttribute("Item")]
internal class JetBrains.Util.dataStructures.KeyToEntryMap`1 : object {
    private KeyValuePair`2[] myEntries;
    private int myEntriesCountMask;
    private IEqualityComparer`1<TKey> myEqualityComparer;
    private static int NextBucketShift;
    private static double LoadFactor;
    private static int MinCapacity;
    [CompilerGeneratedAttribute]
private int <Count>k__BackingField;
    private int myRemovedCount;
    internal int Count { get; private set; }
    internal ValueRefEntry Item { get; }
    internal IEnumerable`1<TKey> Keys { get; }
    internal IEnumerable`1<ValueRefEntry> Values { get; }
    internal KeyToEntryMap`1(int capacity, IEqualityComparer`1<TKey> equalityComparer);
    [CompilerGeneratedAttribute]
internal int get_Count();
    [CompilerGeneratedAttribute]
private void set_Count(int value);
    private void InitializeByDesiredCapacity(int desiredCapacity);
    private void InitEntries();
    internal ValueRefEntry get_Item(TKey key);
    internal ValueRefEntry GetEntryByIndex(int index);
    internal void SetByIndex(int index, ValueRefEntry newEntry);
    internal void RemoveByIndex(int index);
    internal bool ContainsKey(TKey key);
    private int GetBucket(TKey key);
    private int NextBucket(int prevBucket);
    internal bool TryGetValue(TKey key, ValueRefEntry& value, Int32& index);
    internal void Clear();
    private int Add0(TKey key, ValueRefEntry entry);
    internal void Add(TKey key, ValueRefEntry entry, Int32& lastIndex);
    internal bool ConditionallyResize(Int32& lastIndex, bool allowTrim);
    [IteratorStateMachineAttribute("JetBrains.Util.dataStructures.KeyToEntryMap`1/<get_Keys>d__28")]
internal IEnumerable`1<TKey> get_Keys();
    [IteratorStateMachineAttribute("JetBrains.Util.dataStructures.KeyToEntryMap`1/<get_Values>d__30")]
internal IEnumerable`1<ValueRefEntry> get_Values();
    internal KeyValuePair`2[] IdxToValues();
    internal TKey GetKeyByIndex(int index);
}
[DefaultMemberAttribute("Item")]
internal class JetBrains.Util.DataStructures.LocalChunkArray`1 : ValueType {
    private T[][] myArray;
    private static int MaxChunkSizeInBytes;
    private int myIndexInChunkMask;
    private int myChunkLengthLog2;
    private int myChunkLength;
    private int myLength;
    public int Length { get; }
    public T Item { get; public set; }
    public LocalChunkArray`1(int length, int chunkLength);
    public LocalChunkArray`1(int length);
    private LocalChunkArray`1(int length, int chunkLength, bool throwIfAllocatedInLoh);
    public LocalChunkArray`1(LocalChunkArray`1<T> source);
    private static int GetAntiLohChunkLength();
    public int get_Length();
    public T get_Item(int index);
    public void set_Item(int index, T value);
    public void Fill(T item);
    private static int CalculateSizeofNode();
    private static int GetNearestLessPowOf2(int number);
    private static int GetPowOf2(int number);
    public Location<T> GetLocation(int index);
    public void Resize(int newLength);
    private void ExpandLastChunk(int size);
    public void Clear();
    public Enumerator<T> GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class JetBrains.Util.DataStructures.MergedEnumerable`1 : object {
    private IEnumerable`1[] myEnumerables;
    public MergedEnumerable`1(IEnumerable`1[] enumerables);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class JetBrains.Util.DataStructures.MergedEnumerator : object {
    private IEnumerator[] myEnumerators;
    private int myCurrentEnumeratorIndex;
    private IEnumerator myCurrentEnumerator;
    private object System.Collections.IEnumerator.Current { get; }
    public MergedEnumerator(IEnumerator[] enumerators);
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    private sealed virtual override void System.IDisposable.Dispose();
    private sealed virtual override bool System.Collections.IEnumerator.MoveNext();
    private sealed virtual override void System.Collections.IEnumerator.Reset();
}
public class JetBrains.Util.DataStructures.MergedEnumerator`1 : object {
    private IEnumerator`1[] myEnumerators;
    private int myCurrentEnumeratorIndex;
    private IEnumerator`1<T> myCurrentEnumerator;
    public T Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    public MergedEnumerator`1(IEnumerator`1[] enumerators);
    public sealed virtual T get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    private sealed virtual override void System.IDisposable.Dispose();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
}
[DefaultMemberAttribute("Item")]
internal class JetBrains.Util.dataStructures.MultimapStorage`1 : object {
    private int myChunkOffset;
    private int myChunkMask;
    private int myChunkCount;
    private TValue[][] myChunks;
    private int ChunkSize { get; }
    internal int Capacity { get; }
    internal TValue Item { get; internal set; }
    internal MultimapStorage`1(int chunkSizeLog2, int initialCapacity);
    private int get_ChunkSize();
    internal int get_Capacity();
    internal TValue get_Item(int index);
    internal void set_Item(int index, TValue value);
    internal void SetInternal(int index, TValue value);
    private void EnsureCapacity(int index);
    internal void CompactToNewCount(int newCount);
}
public class JetBrains.Util.dataStructures.MultimapValueCollection`2 : ValueType {
    public static MultimapValueCollection`2<TKey, TValue> EmptyInstance;
    private OneToListMultimap`2<TKey, TValue> myMultimap;
    private TKey myKey;
    private ValueRefEntry Entry { get; }
    internal TKey Key { get; }
    internal OneToListMultimap`2<TKey, TValue> Multimap { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    internal MultimapValueCollection`2(OneToListMultimap`2<TKey, TValue> multimap, TKey key);
    private static MultimapValueCollection`2();
    private ValueRefEntry get_Entry();
    internal TKey get_Key();
    internal OneToListMultimap`2<TKey, TValue> get_Multimap();
    public MultimapValueCollectionEnumerator`1<TValue> GetEnumerator();
    private sealed virtual override IEnumerator`1<TValue> System.Collections.Generic.IEnumerable<TValue>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Add(TValue item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(TValue item);
    public sealed virtual void CopyTo(TValue[] array, int arrayIndex);
    public sealed virtual bool Remove(TValue item);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
}
public class JetBrains.Util.dataStructures.MultimapValueCollectionEnumerator`1 : ValueType {
    private int myIndex;
    private int myRestCount;
    private MultimapStorage`1<TValue> myStorage;
    public TValue Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    internal MultimapValueCollectionEnumerator`1(ValueRefEntry entry, MultimapStorage`1<TValue> storage);
    public sealed virtual void Dispose();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
    public sealed virtual TValue get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
}
public class JetBrains.Util.dataStructures.NaturalSort : object {
    [NotNullAttribute]
public static IComparer`1<string> Comparer;
    [NotNullAttribute]
public static IEqualityComparer`1<string> EqualityComparer;
    private static NaturalSort();
    private sealed virtual override int System.Collections.Generic.IComparer<System.String>.Compare(string black, string white);
    private sealed virtual override int System.Collections.IComparer.Compare(object black, object white);
    private sealed virtual override bool System.Collections.IEqualityComparer.Equals(object black, object white);
    private sealed virtual override bool System.Collections.Generic.IEqualityComparer<System.String>.Equals(string black, string white);
    private sealed virtual override int System.Collections.IEqualityComparer.GetHashCode(object o);
    private sealed virtual override int System.Collections.Generic.IEqualityComparer<System.String>.GetHashCode(string s);
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Util.dataStructures.OneToListMultimap`2 : object {
    [CompilerGeneratedAttribute]
private KeyToEntryMap`1<TKey> <BaseMap>k__BackingField;
    private IEqualityComparer`1<TKey> myKeyComparer;
    [CompilerGeneratedAttribute]
private IEqualityComparer`1<TValue> <ValueComparer>k__BackingField;
    private CapacityPolicy myCapacityPolicy;
    internal MultimapStorage`1<TValue> ValueStorage;
    private int myNextWritePosition;
    private int myLastKeyIndex;
    private int myEmptyCellCount;
    public static int DefaultKeysCapacity;
    [CompilerGeneratedAttribute]
private CompactionPolicy <CompactionPolicy>k__BackingField;
    internal KeyToEntryMap`1<TKey> BaseMap { get; }
    internal IEqualityComparer`1<TValue> ValueComparer { get; }
    public CompactionPolicy CompactionPolicy { get; public set; }
    public MultimapValueCollection`2<TKey, TValue> Item { get; public set; }
    public ICollection`1<TKey> Keys { get; }
    private IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,JetBrains.Util.dataStructures.MultimapValueCollection<TKey,TValue>>.Keys { get; }
    public IEnumerable`1<TKey> KeysLazy { get; }
    public ICollection`1<MultimapValueCollection`2<TKey, TValue>> Values { get; }
    private IEnumerable`1<MultimapValueCollection`2<TKey, TValue>> System.Collections.Generic.IReadOnlyDictionary<TKey,JetBrains.Util.dataStructures.MultimapValueCollection<TKey,TValue>>.Values { get; }
    public IEnumerable`1<TValue> AllValuesLazy { get; }
    public int Count { get; }
    public int ValuesCapacity { get; }
    public bool IsReadOnly { get; }
    public OneToListMultimap`2(int keyCapacity, IEqualityComparer`1<TKey> keyComparer, IEqualityComparer`1<TValue> valueComparer, CapacityPolicy capacityPolicy, int valueCapacity);
    [CompilerGeneratedAttribute]
internal KeyToEntryMap`1<TKey> get_BaseMap();
    [CompilerGeneratedAttribute]
internal IEqualityComparer`1<TValue> get_ValueComparer();
    [CompilerGeneratedAttribute]
public CompactionPolicy get_CompactionPolicy();
    [CompilerGeneratedAttribute]
public void set_CompactionPolicy(CompactionPolicy value);
    private void Reset(int valueCapacity);
    private void TryAutoCompact();
    private int CompactInternal();
    private void NonoverlappingCopyWithClean(int indexFrom, int size, int indexTo);
    private void AdvanceNextWritePositionAccordingPolicy();
    public void AddValue(TKey key, TValue value);
    public bool RemoveValue(TKey key, TValue value);
    public int RemoveValueAll(TKey key, Predicate`1<TValue> match);
    public int RemoveValueRange(TKey key, IEnumerable`1<TValue> valuesEnumerable);
    public void AddValueRange(TKey key, IEnumerable`1<TValue> valuesEnumerable);
    public void SetValueRange(TKey key, IEnumerable`1<TValue> valuesEnumerable);
    public int Compact();
    public int CompactConditionally();
    public sealed virtual bool ContainsKey(TKey key);
    public sealed virtual void Add(TKey key, MultimapValueCollection`2<TKey, TValue> value);
    public sealed virtual bool Remove(TKey key);
    public sealed virtual bool TryGetValue(TKey key, MultimapValueCollection`2& value);
    public sealed virtual MultimapValueCollection`2<TKey, TValue> get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, MultimapValueCollection`2<TKey, TValue> value);
    public sealed virtual ICollection`1<TKey> get_Keys();
    private sealed virtual override IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,JetBrains.Util.dataStructures.MultimapValueCollection<TKey,TValue>>.get_Keys();
    public IEnumerable`1<TKey> get_KeysLazy();
    public sealed virtual ICollection`1<MultimapValueCollection`2<TKey, TValue>> get_Values();
    private sealed virtual override IEnumerable`1<MultimapValueCollection`2<TKey, TValue>> System.Collections.Generic.IReadOnlyDictionary<TKey,JetBrains.Util.dataStructures.MultimapValueCollection<TKey,TValue>>.get_Values();
    [IteratorStateMachineAttribute("JetBrains.Util.dataStructures.OneToListMultimap`2/<get_AllValuesLazy>d__49")]
public IEnumerable`1<TValue> get_AllValuesLazy();
    public IEnumerator`1<KeyValuePair`2<TKey, MultimapValueCollection`2<TKey, TValue>>> GetEnumerator();
    private sealed virtual override IEnumerator`1<KeyValuePair`2<TKey, MultimapValueCollection`2<TKey, TValue>>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,JetBrains.Util.dataStructures.MultimapValueCollection<TKey,TValue>>>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public bool FindAndConsume(TKey keyToFind, IValueConsumer`2<TValue, TParameter> consumer, TParameter parameter, Action interruptChecker);
    public sealed virtual MultimapValueCollection`2<TKey, TValue> GetValuesSafe(TKey key);
    public sealed virtual void Add(TKey key, TValue value);
    public sealed virtual bool Remove(TKey key, TValue value);
    public sealed virtual void Add(KeyValuePair`2<TKey, MultimapValueCollection`2<TKey, TValue>> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<TKey, MultimapValueCollection`2<TKey, TValue>> item);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual bool Remove(KeyValuePair`2<TKey, MultimapValueCollection`2<TKey, TValue>> item);
    public sealed virtual int get_Count();
    public int get_ValuesCapacity();
    public sealed virtual bool get_IsReadOnly();
    public string DebugPrintOrdered();
    public int StatValueStorageUsed();
    public int StatEmptyCount();
    [CompilerGeneratedAttribute]
private MultimapValueCollection`2<TKey, TValue> <get_Values>b__45_1(TKey key);
    [CompilerGeneratedAttribute]
private KeyValuePair`2<TKey, MultimapValueCollection`2<TKey, TValue>> <GetEnumerator>b__50_0(IEnumerator`1<TKey> keyEnum);
}
[ExtensionAttribute]
public static class JetBrains.Util.dataStructures.OneToManyEquivalenceComparerEx : object {
    [ExtensionAttribute]
public static bool IsEquivalentTo(OneToListMultimap`2<TKey, TValue> x, OneToListMultimap`2<TKey, TValue> y);
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Util.DataStructures.OrderedDictionary`2 : object {
    [NotNullAttribute]
private Dictionary`2<TKey, TValue> myDictionary;
    [NotNullAttribute]
private List`1<TKey> myList;
    public TValue Item { get; public set; }
    public ICollection`1<TKey> Keys { get; }
    private IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Keys { get; }
    public ICollection`1<TValue> Values { get; }
    private IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Values { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public OrderedDictionary`2(IEqualityComparer`1<TKey> comparer);
    public sealed virtual bool ContainsKey(TKey key);
    public sealed virtual void Add(TKey key, TValue value);
    public KeyValuePair`2<TKey, TValue> At(int index);
    public void Insert(int index, TKey key, TValue value);
    public sealed virtual bool Remove(TKey key);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    public sealed virtual ICollection`1<TKey> get_Keys();
    private sealed virtual override IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Keys();
    public sealed virtual ICollection`1<TValue> get_Values();
    private sealed virtual override IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Values();
    public sealed virtual void Add(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    private static void CopyTo(ICollection`1<T> collection, T[] array, int index);
    public sealed virtual bool Remove(KeyValuePair`2<TKey, TValue> item);
    public void Sort(Comparison`1<TKey> comparison);
    public void Sort(IComparer`1<TKey> comparer);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    [IteratorStateMachineAttribute("JetBrains.Util.DataStructures.OrderedDictionary`2/<GetEnumerator>d__33")]
public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Util.DataStructures.PackedIntArray : ValueType {
    private int myLength;
    private int myValueBits;
    private UncheckedPackedIntArray myArray;
    public UInt32[] Item { get; public set; }
    public int Length { get; }
    public int ValueBits { get; }
    public int ValueInts { get; }
    public PackedIntArray(int length, int valueBits);
    private PackedIntArray(int length, int valueBits, UncheckedPackedIntArray array);
    public UInt32[] get_Item(int index);
    public void set_Item(int index, UInt32[] value);
    public int get_Length();
    public int get_ValueBits();
    public int get_ValueInts();
    public void CopyTo(PackedIntArray array, int count);
    public static PackedIntArray IncreaseValueBits(PackedIntArray oldArray, int newValueBits);
    public void Clear();
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Util.DataStructures.PackedIntArrayList : ValueType {
    private UncheckedPackedIntArray myArray;
    private UInt32 Item { get; private set; }
    public PackedIntArrayList(int valueBits, int initialCapacity);
    private PackedIntArrayList(UncheckedPackedIntArray array);
    [PureAttribute]
public int GetCount(int valueBits);
    private void SetCount(int count, int valueBits);
    public PackedIntArrayList SetCapacity(int capacity, int valueBits);
    public PackedIntArrayList Add(UInt32 value, int valueBits);
    public bool Remove(UInt32 value, int valueBits);
    private UInt32 get_Item(int index, int valueBits);
    private void set_Item(int index, int valueBits, UInt32 value);
    [ConditionalAttribute("JET_MODE_ASSERT")]
private void AssertIndexInRange(int index, int valueBits);
    public bool Contains(UInt32 value, int valueBits);
    public PackedIntArrayList IncreaseValueBits(int oldValueBits, int newValueBits);
    public IList`1<UInt32> AsReadOnlyList(int valueBits);
    public static bool op_Equality(PackedIntArrayList list1, PackedIntArrayList list2);
    public static bool op_Inequality(PackedIntArrayList list1, PackedIntArrayList list2);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
public class JetBrains.Util.DataStructures.PackedIntKeyMap`1 : CompactMapBase`4<UInt32, TValue, PackedIntKeyMapStorage`1<TValue>, UInt32> {
    private int myKeyBits;
    private UInt32 myKeyMask;
    private UInt32 mySlotOccupiedMask;
    private UInt32[] myRemovedValue;
    public PackedIntKeyMap`1(int keyBits);
    public PackedIntKeyMap`1(int keyBits, int intialSlotCount, double maxLoadFactor);
    protected virtual void DoValidateKey(UInt32 key);
    protected virtual PackedIntKeyMapStorage`1<TValue> CreateStorage(int slotCount);
    protected virtual SlotState<UInt32, TValue, PackedIntKeyMapStorage`1<TValue>, UInt32> GetSlotState(PackedIntKeyMapStorage`1<TValue> storage, int index, UInt32& key);
    protected virtual UInt32 GetSlotData(PackedIntKeyMapStorage`1<TValue> storage, int index);
    protected virtual TValue GetValue(PackedIntKeyMapStorage`1<TValue> storage, int index, UInt32 data);
    protected virtual void SetValue(PackedIntKeyMapStorage`1<TValue> storage, int index, TValue value);
    protected virtual void SetKeyAndValue(PackedIntKeyMapStorage`1<TValue> storage, int index, UInt32 key, TValue value);
    protected virtual void RemoveValue(PackedIntKeyMapStorage`1<TValue> storage, int index);
    protected virtual void ClearStorage(PackedIntKeyMapStorage`1<TValue> storage);
}
public class JetBrains.Util.DataStructures.PackedIntKeyMapStorage`1 : ValueType {
    public ChunkPackedIntArray PackedArray;
    public TValue[] Values;
    public PackedIntKeyMapStorage`1(int length, int keyBits);
}
public class JetBrains.Util.DataStructures.PackedIntSet : object {
    private PackedIntSetInternal myImpl;
    public static double DEFAULT_MAX_LOAD_FACTOR;
    public static int DEFAULT_INITIAL_SLOT_COUNT;
    public double MaxLoadFactor { get; }
    public int Count { get; }
    public int SlotCount { get; }
    public bool IsReadOnly { get; }
    public PackedIntSet(int keyBits);
    public PackedIntSet(int keyBits, int intialSlotCount, double maxLoadFactor);
    public double get_MaxLoadFactor();
    public sealed virtual void Add(UInt32 item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(UInt32 item);
    public sealed virtual void CopyTo(UInt32[] array, int arrayIndex);
    private static void CopyTo(IEnumerable`1<T> collection, T[] array, int index);
    public sealed virtual bool Remove(UInt32 item);
    public sealed virtual int get_Count();
    public int get_SlotCount();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual IEnumerator`1<UInt32> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public void Compact();
}
public class JetBrains.Util.DataStructures.PackedIntSetInternal : CompactMapBase`4<UInt32, object, ChunkPackedIntArray, object> {
    private int myKeyBits;
    private UInt32 myKeyMask;
    private UInt32 mySlotOccupiedMask;
    private static UInt32[] REMOVED_VALUE;
    public PackedIntSetInternal(int keyBits);
    public PackedIntSetInternal(int keyBits, int intialSlotCount, double maxLoadFactor);
    private static PackedIntSetInternal();
    protected virtual void DoValidateKey(UInt32 key);
    protected virtual ChunkPackedIntArray CreateStorage(int slotCount);
    protected virtual SlotState<UInt32, object, ChunkPackedIntArray, object> GetSlotState(ChunkPackedIntArray storage, int index, UInt32& key);
    protected virtual object GetSlotData(ChunkPackedIntArray storage, int index);
    protected virtual object GetValue(ChunkPackedIntArray storage, int index, object data);
    protected virtual void SetValue(ChunkPackedIntArray storage, int index, object value);
    protected virtual void SetKeyAndValue(ChunkPackedIntArray storage, int index, UInt32 key, object value);
    protected virtual void RemoveValue(ChunkPackedIntArray storage, int index);
    protected virtual void ClearStorage(ChunkPackedIntArray storage);
}
public class JetBrains.Util.DataStructures.PackedIntToIntMap : CompactMapBase`4<UInt32, UInt32[], ChunkPackedIntArray, UInt32[]> {
    private int myKeyBits;
    private int myValueBits;
    private UInt32 myKeyMask;
    private UInt32 mySlotOccupiedMask;
    private UInt32[] myRemovedValue;
    private int myValueInts;
    private UInt32 myLastValueIntMask;
    public int ValueBits { get; }
    public int ValueInts { get; }
    public PackedIntToIntMap(int keyBits, int valueBits);
    public PackedIntToIntMap(int keyBits, int valueBits, int intialSlotCount, double maxLoadFactor);
    protected virtual void DoValidateKey(UInt32 key);
    public int get_ValueBits();
    public int get_ValueInts();
    protected virtual ChunkPackedIntArray CreateStorage(int slotCount);
    protected virtual SlotState<UInt32, UInt32[], ChunkPackedIntArray, UInt32[]> GetSlotState(ChunkPackedIntArray storage, int index, UInt32& key);
    protected virtual UInt32[] GetSlotData(ChunkPackedIntArray storage, int index);
    protected virtual UInt32[] GetValue(ChunkPackedIntArray storage, int index, UInt32[] data);
    protected virtual void SetValue(ChunkPackedIntArray storage, int index, UInt32[] value);
    protected virtual void SetKeyAndValue(ChunkPackedIntArray storage, int index, UInt32 key, UInt32[] value);
    protected virtual void RemoveValue(ChunkPackedIntArray storage, int index);
    private UInt32 GetDataAtWithoutOccupiedBit(UInt32[] data, int index);
    private void SetValueWhenCleared(UInt32[] data, UInt32[] value);
    protected virtual void ClearStorage(ChunkPackedIntArray storage);
}
public class JetBrains.Util.DataStructures.ProxySettingsTable : SettingsTable {
    [CompilerGeneratedAttribute]
private object <LockObject>k__BackingField;
    private ISettingsTable myOriginalTable;
    protected object LockObject { get; }
    public ProxySettingsTable(ISettingsTable originalTable);
    [CompilerGeneratedAttribute]
protected object get_LockObject();
    public virtual bool GetBoolean(string settingName);
    public virtual bool GetBoolean(string settingName, bool defaultVal);
    public virtual int GetInteger(string settingName);
    public virtual int GetInteger(string settingName, int defaultVal);
    public virtual string GetString(string settingName);
    public virtual string GetString(string settingName, string defaultVal);
    public virtual void SetBoolean(string settingName, bool val);
    public virtual void SetInteger(string settingName, int val);
    public virtual void SetString(string settingName, string val);
}
public class JetBrains.Util.DataStructures.RawStringIntern : object {
    private ChunkHashSetConversionIntern`2<RawString, string> myIntern;
    public sealed virtual string Intern(RawString raw);
    public string Intern(string s);
    public bool IsInterned(string s);
}
public class JetBrains.Util.DataStructures.RegistrySettingsTable : ProxySettingsTable {
    private static string INTS;
    private static string BOOLS;
    private static string STRINGS;
    private static string LICENSE_SETTINGS_SUB;
    [NotNullAttribute]
private string myRootFullKeyName;
    [NotNullAttribute]
private string myEnvironmentSuffixWithLeadingSlash;
    private RegistryKey myRegistryKey;
    private static Action`1<Version> DO_NOTHING;
    private static Regex ourVersionRegex;
    public RegistrySettingsTable(RegistryKey registryKey, string rootFullKeyName, string environmentSuffixWithLeadingSlash, ISettingsTable settings);
    private static RegistrySettingsTable();
    private static void Load(IDictionary`2<string, TSetting> dict, string keyName, RegistryKey rootKey, Converter`2<TValue, TSetting> converter);
    private void Save(IDictionary`2<string, TSetting> dict, string keyName, RegistryKey rootKey, Converter`2<TSetting, TValue> converter);
    private Version GetVersion(string key);
    public bool Load(Action`1<Version> onLoadFromVersion);
    private bool TryLoadFromProductVersion(string productVersionRootKeyName);
    private bool TryLoadFrom(string keyName);
    public bool Save();
}
public class JetBrains.Util.dataStructures.SafeUnmanagedMemory : ValueType {
    private IntPtr myPtr;
    public IntPtr Ptr { get; }
    public Byte* RawPtr { get; }
    private SafeUnmanagedMemory(int size);
    public IntPtr get_Ptr();
    public Byte* get_RawPtr();
    public static SafeUnmanagedMemory Alloc(int size);
    public sealed virtual void Dispose();
}
public class JetBrains.Util.DataStructures.SettingsTable : object {
    private Dictionary`2<string, bool> myBools;
    private Dictionary`2<string, int> myInts;
    private Dictionary`2<string, string> myStrings;
    protected Dictionary`2<string, bool> Bools { get; }
    protected Dictionary`2<string, int> Ints { get; }
    protected Dictionary`2<string, string> Strings { get; }
    public SettingsTable(SettingsTable settings);
    protected Dictionary`2<string, bool> get_Bools();
    protected Dictionary`2<string, int> get_Ints();
    protected Dictionary`2<string, string> get_Strings();
    public virtual bool GetBoolean(string settingName);
    public virtual bool GetBoolean(string settingName, bool defaultVal);
    public virtual int GetInteger(string settingName);
    public virtual int GetInteger(string settingName, int defaultVal);
    public virtual string GetString(string settingName);
    public virtual string GetString(string settingName, string defaultVal);
    public virtual void SetBoolean(string settingName, bool val);
    public virtual void SetInteger(string settingName, int val);
    public virtual void SetString(string settingName, string val);
    protected static T GetValue(IDictionary`2<string, T> dict, string settingName);
    protected static T GetValue(IDictionary`2<string, T> dict, string settingName, T defautValue);
    protected static void SetValue(IDictionary`2<string, T> dict, string settingName, T value);
}
public class JetBrains.Util.dataStructures.SimpleTrie`2 : object {
    private TrieNode<TKey, TValue> myRootNode;
    public bool IsEmpty { get; }
    [NotNullAttribute]
public TrieNode<TKey, TValue> RootNode { get; }
    public bool get_IsEmpty();
    public TrieNode<TKey, TValue> get_RootNode();
    public void AddOrUpdateValue(KeyEnumerator`2<TKey, TValue, TContext, TState> keys, AddOrUpdateHandler`1<TKey, TValue, TContext> value, TContext context);
    public bool Remove(IList`1<TKey> keys);
    public void RemoveAllKeyPrefixes(IList`1<TKey> keys);
    public void SetValue(KeyEnumerator`2<TKey, TValue, TContext, TState> keys, TValue value, TContext context);
    public void SetValue(IList`1<TKey> keys, TValue value);
    public bool TryGetValue(KeyEnumerator`2<TKey, TValue, TContext, TState> keys, TValue& value, TContext context);
    public bool TryGetValue(IList`1<TKey> keys, TValue& value);
}
internal enum JetBrains.Util.dataStructures.SlotState : Enum {
    public int value__;
    public static SlotState Free;
    public static SlotState Removed;
    public static SlotState Occupied;
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Util.dataStructures.StringConcat : ValueType {
    [NotNullAttribute]
private String[] myParts;
    private int myLength;
    [NotNullAttribute]
public String[] Parts { get; }
    public int Length { get; }
    public char Item { get; }
    public StringConcat(String[] parts);
    public String[] get_Parts();
    public virtual string ToString();
    public sealed virtual int get_Length();
    [SkipLocalsInitAttribute]
public sealed virtual string GetText();
    [ConditionalAttribute("JET_MODE_ASSERT")]
private void Assert(int startOffset, int endOffset, int len);
    [SkipLocalsInitAttribute]
public sealed virtual string GetText(TextRange range);
    public sealed virtual void AppendTextTo(StringBuilder builder, TextRange range);
    public sealed virtual char get_Item(int index);
    public sealed virtual void CopyTo(int sourceIndex, Char[] destinationArray, int destinationIndex, int length);
    public bool EqualTo(string s);
    public bool Contains(string s, int start);
    public bool StartsWith(string s);
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Util.dataStructures.StringDotConcat : ValueType {
    [NotNullAttribute]
private string myPart1;
    [CanBeNullAttribute]
private string myPart2;
    public int Length { get; }
    public char Item { get; }
    public StringDotConcat(string part1);
    public StringDotConcat(string part1, string part2);
    public virtual string ToString();
    public sealed virtual int get_Length();
    [SkipLocalsInitAttribute]
public sealed virtual string GetText();
    [ConditionalAttribute("JET_MODE_ASSERT")]
private void Assert(int startOffset, int endOffset, int len);
    [SkipLocalsInitAttribute]
public sealed virtual string GetText(TextRange range);
    public sealed virtual void AppendTextTo(StringBuilder builder, TextRange range);
    public sealed virtual char get_Item(int index);
    public sealed virtual void CopyTo(int sourceIndex, Char[] destinationArray, int destinationIndex, int length);
    public bool EqualTo(string s);
    public bool StartsWith(string s);
}
public class JetBrains.Util.dataStructures.SubStream : Stream {
    private Nullable`1<long> myLength;
    private FileAccess myRwfilter;
    private long myStart;
    [NotNullAttribute]
private Stream myStream;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public SubStream(Stream stream, long start, Nullable`1<long> length, FileAccess rwfilter);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    [NotNullAttribute]
public static SubStream Append(Stream stream);
    public virtual void Close();
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual string ToString();
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte value);
}
public class JetBrains.Util.DataStructures.ToStringComparer : object {
    public static ToStringComparer INSTANCE;
    private static ToStringComparer();
    public sealed virtual int Compare(object x, object y);
}
public class JetBrains.Util.DataStructures.ToStringComparer`1 : object {
    public static ToStringComparer`1<T> INSTANCE;
    private static ToStringComparer`1();
    public sealed virtual int Compare(T x, T y);
}
[IsReadOnlyAttribute]
public class JetBrains.Util.dataStructures.TypedIntrinsics.Int32`1 : ValueType {
    private int Value;
    public static Int32`1<TType> I;
    public static Int32`1<TType> MaxValue;
    public static Int32`1<TType> MinValue;
    public static Int32`1<TType> O;
    private Int32`1(int value);
    private static Int32`1();
    [PureAttribute]
public static Int32`1<TType> Abs(Int32`1<TType> a);
    [PureAttribute]
public static Int32`1<TType> Max(Int32`1<TType> a, Int32`1<TType> b);
    [PureAttribute]
public static Int32`1<TType> Min(Int32`1<TType> a, Int32`1<TType> b);
    [PureAttribute]
public static Int32`1<TType> Parse(string s);
    [PureAttribute]
public static Int32`1<TType> Parse(string s, NumberStyles style);
    [PureAttribute]
public static Int32`1<TType> Parse(string s, IFormatProvider provider);
    [PureAttribute]
public static Int32`1<TType> Parse(string s, NumberStyles style, IFormatProvider provider);
    public static bool TryParse(string s, Int32`1& result);
    public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, Int32`1& result);
    public static Int32`1<TType> op_Addition(Int32`1<TType> a, Int32`1<TType> b);
    public static Int32`1<TType> op_Decrement(Int32`1<TType> a);
    [ObsoleteAttribute("You can't divide one dimension by another and get a dimension: the units would cancel")]
public static Int32`1<TType> op_Division(Int32`1<TType> a, Int32`1<TType> b);
    public static Int32`1<TType> op_Division(Int32`1<TType> a, int b);
    public static bool op_Equality(Int32`1<TType> left, Int32`1<TType> right);
    public static int op_Explicit(Int32`1<TType> other);
    public static Int32`1<TType> op_Explicit(int other);
    public static UInt32 op_Explicit(Int32`1<TType> other);
    public static Int32`1<TType> op_Explicit(UInt32 other);
    public static double op_Explicit(Int32`1<TType> other);
    public static bool op_GreaterThan(Int32`1<TType> a, Int32`1<TType> b);
    public static bool op_GreaterThanOrEqual(Int32`1<TType> a, Int32`1<TType> b);
    public static Int32`1<TType> op_Increment(Int32`1<TType> a);
    public static bool op_Inequality(Int32`1<TType> left, Int32`1<TType> right);
    public static Int32`1<TType> op_LeftShift(Int32`1<TType> a, int b);
    public static bool op_LessThan(Int32`1<TType> a, Int32`1<TType> b);
    public static bool op_LessThanOrEqual(Int32`1<TType> a, Int32`1<TType> b);
    public static Int32`1<TType> op_Multiply(Int32`1<TType> a, Int32`1<TType> b);
    public static Int32`1<TType> op_RightShift(Int32`1<TType> a, int b);
    public static Int32`1<TType> op_Subtraction(Int32`1<TType> a, Int32`1<TType> b);
    [PureAttribute]
public Int32`1<TType> Limited(Int32`1<TType> minInclusive, Int32`1<TType> maxExclusive);
    [PureAttribute]
public Int32`1<TType> Minus1();
    [PureAttribute]
public Int32`1<TType> Plus1();
    [PureAttribute]
public Int32`1<TType> AtMost(Int32`1<TType> maxvalue);
    [PureAttribute]
public Int32`1<TType> AtLeast(Int32`1<TType> minvalue);
    [NotNullAttribute]
[PureAttribute]
public string ToString(string format);
    [NotNullAttribute]
[PureAttribute]
public string ToString(IFormatProvider provider);
    [NotNullAttribute]
[PureAttribute]
public string ToString(string format, IFormatProvider provider);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    private sealed virtual override int System.IComparable<JetBrains.Util.dataStructures.TypedIntrinsics.Int32<TType>>.CompareTo(Int32`1<TType> other);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    public sealed virtual bool Equals(Int32`1<TType> other);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider formatProvider);
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Util.DataStructures.UncheckedPackedIntArray : ValueType {
    private static UInt32 ALL_1_BIT_MASK;
    private UInt32[] myData;
    public UInt32[] Data { get; }
    public UInt32[] Item { get; public set; }
    public UncheckedPackedIntArray(int length, int valueBits);
    public UncheckedPackedIntArray(UInt32[] data);
    public static int GetCapacityByLength(int length, int valueBits);
    public UInt32[] get_Data();
    [PureAttribute]
public UInt32 GetItem(int index, int valueBits, int iSubItem);
    public UInt32[] get_Item(int index, int valueBits);
    public void set_Item(int index, int valueBits, UInt32[] value);
    [PureAttribute]
public int GetCapacity(int valueBits);
    private static UInt32 LastIntMask(int valueBits, int valueInts);
    public static int ValueInts(int valueBits);
    public void CopyTo(UncheckedPackedIntArray array, int count, int valueBits);
    public static UncheckedPackedIntArray IncreaseValueBits(UncheckedPackedIntArray oldArray, int length, int oldValueBits, int newValueBits);
    public static bool op_Equality(UncheckedPackedIntArray array1, UncheckedPackedIntArray array2);
    public static bool op_Inequality(UncheckedPackedIntArray array1, UncheckedPackedIntArray array2);
    public void Clear();
    public sealed virtual bool Equals(UncheckedPackedIntArray uncheckedPackedIntArray);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class JetBrains.Util.dataStructures.UncloseableStream : Stream {
    private Stream myStream;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanTimeout { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public int ReadTimeout { get; public set; }
    public int WriteTimeout { get; public set; }
    public UncloseableStream(Stream stream);
    public object GetLifetimeService();
    public virtual object InitializeLifetimeService();
    public virtual void Close();
    public virtual void Flush();
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte value);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanTimeout();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
}
internal class JetBrains.Util.dataStructures.ValueRefEntry : ValueType {
    public static ValueRefEntry FreeMarker;
    public static ValueRefEntry RemovedMarker;
    private static int RemovedMarkerIndex;
    private static int ExactFitCapacity;
    private static int SizeNBits;
    private static int SizeMask;
    private static int CapacityNBits;
    private static int CapacityOffset;
    private static int CapacityMask;
    private int myIndex;
    private int myLen;
    internal SlotState State { get; }
    internal int Index { get; }
    internal int Capacity { get; }
    internal bool IsExactFit { get; }
    internal int Count { get; }
    internal bool IsFull { get; }
    internal ValueRefEntry(CapacityPolicy capacityPolicy, int index, int size);
    private static ValueRefEntry();
    private static ValueRefEntry CreateMarker(int index);
    internal SlotState get_State();
    internal int get_Index();
    internal int get_Capacity();
    internal bool get_IsExactFit();
    internal int get_Count();
    internal bool get_IsFull();
    internal ValueRefEntry WithIndex(int newIndex);
    internal ValueRefEntry WithCount(int newCount);
    internal ValueRefEntry WithReducedCount(int reduceCount);
    internal ValueRefEntry WithAdvancedCount();
    private void IncreaseCapacityConditionally();
    private void SetFibCapacity(int cnt);
    public void TrimCapacity();
}
public enum JetBrains.Util.DefaultAction : Enum {
    public int value__;
    public static DefaultAction Commit;
    public static DefaultAction Rollback;
}
public class JetBrains.Util.DelegateComparer : object {
    private Comparison myComparison;
    public DelegateComparer(Comparison comparison);
    public sealed virtual int Compare(object x, object y);
}
public class JetBrains.Util.DelegatingComparer`2 : object {
    private IComparer`1<TTarget> mySourceComparer;
    private Func`2<TSource, TTarget> myTransformation;
    private DelegatingComparer`2(IComparer`1<TTarget> sourceComparer, Func`2<TSource, TTarget> transformation);
    public static DelegatingComparer`2<TSource, TTarget> Create(Func`2<TSource, TTarget> transformation, IComparer`1<TTarget> targetComparer);
    public static DelegatingComparer`2<TSource, TTarget> Create(Func`2<TSource, TTarget> transformation);
    public sealed virtual int Compare(TSource x, TSource y);
}
public static class JetBrains.Util.DependentEntitiesSortUtil : object {
    public static bool Sort(IList entities, Entity& failedOn);
    private static int FindEntityToLoad(IList entities, int startIndex, ICollection`1<object> loadedIds, ICollection`1<object> allDeclaredIds);
    private static bool CanLoadEntity(Entity entity, ICollection`1<object> loadedIds, ICollection`1<object> allDeclaredIds);
}
public static class JetBrains.Util.DevEnv.DevenvHostDiscovery : object {
    private static ILogger Logger;
    public static string DevEnvExeName;
    public static string PrivateRegistryDetourFileInLocalAppData_Vs15lt_Build_2016_03_17;
    public static string PrivateRegistryUserDetourFileInLocalAppData_Vs15_Win7;
    private static string RegConfigHiveSuffix;
    private static Regex RegexParseVsVersion;
    private static string RegValueInstallDir;
    private static string SubfolderMicrosoft;
    private static string SubfolderVisualStudio;
    public static BackSlashSeparatedRelativePath VisualStudioRegistryPathNoHive;
    [NotNullAttribute]
public static RelativePath[] VsOutOfGacAssemblyFoldersUnderInstalldir;
    private static Version2[] VsClassicVersionsWhiteList;
    private static DevenvHostDiscovery();
    [NotNullAttribute]
public static IReadOnlyList`1<InstalledVs> EnumInstalledVs();
    [NotNullAttribute]
public static IReadOnlyList`1<InstalledVs> EnumInstalledVs(EnumInstalledVsFlags flags);
    [NotNullAttribute]
public static FileSystemPath GetMsEnvDllPath();
    [NotNullAttribute]
public static BackSlashSeparatedRelativePath GetVsRegistryPath(VsHive vsHive);
    [NotNullAttribute]
public static BackSlashSeparatedRelativePath GetVsRegistryConfigPath(VsHive vsHive);
    [NotNullAttribute]
public static FileSystemPath GetVsAppDataPath(SpecialFolder spec, VsHive vsHive);
    [NotNullAttribute]
public static FileSystemPath GetVsAppDataRootPath(SpecialFolder spec);
    [CanBeNullAttribute]
public static FileSystemPath GetVsInstallDir(VsHive hive, OnError onerror);
    private static FileSystemPath GetVsInstallDirFromRegistryRaw(BackSlashSeparatedRelativePath relLocalRegistryRoot, OnError onerror);
    [NotNullAttribute]
public static Version GetVsVersion4();
    public static bool IsVsInstalled(VsHive hive);
    public static bool IsRegistryHiveDetourRequired(VsHive vshive);
    public static Nullable`1<RegistryHiveAccess> OpenRegistryHiveDetourForVs15lt(Lifetime lifetime, VsHive vshive, bool isForceCreateMissingFile);
    [NotNullAttribute]
public static FileSystemPath GetRegistryHiveDetourFileForVs15(VsHive vshive);
    [CanBeNullAttribute]
public static Version TryGetVsVersionFromDllVersion();
    public static string VsVersionToYearString(Version2 ver);
    public static string GetDefaultVsPresentationShort(Version2 ver);
    public static string GetDefaultVsPresentationShort(VsHive vsHive, bool isPreview);
    public static string GetDefaultVsPresentationLong(Version2 ver);
    public static string GetDefaultVsPresentationLong(VsHive vsHive);
    public static string PresentVsLong(VsHive hive, IReadOnlyList`1<InstalledVs> installedVs);
    public static HResults IsSinceVs15DiscoveryAvailable();
    [CanBeNullAttribute]
public static InstalledVs TryGetCurrentInstanceSinceVs15(EnumInstalledVsFlags flags, OnError onerror);
    [NotNullAttribute]
private static IReadOnlyList`1<InstalledVs> EnumInstalledVsCore(EnumInstalledVsFlags flags, OnError onerror);
    private static void EnumInstalledVsCore_Classic(ICollection`1<InstalledVs> retval, OnError onerror);
    [PublicAPIAttribute]
private static IList`1<InstalledVs> GetInstalledVs15Lightweight_Build_2016_03_17(OnError onerror);
    [PublicAPIAttribute]
private static IList`1<InstalledVs> GetInstalledVs15Lightweight_Build_2016_07_07(OnError onerror);
}
[ObsoleteAttribute("Use DevenvHostDiscovery.")]
public static class JetBrains.Util.DevEnv.DevEnvUtil : object {
    private static string VsRegistryKey;
    private static string InstallDirValueName;
    private static string SettingsFileValueName;
    private static string LocationValueName;
    private static OnError ourOnError;
    private static Version[] ourInstalledVersions;
    private static Version ourHighestVersion;
    public static Version[] SupportedVersions;
    public static Version[] InstalledVersions { get; }
    [CanBeNullAttribute]
public static Version HighestInstalledVersion { get; }
    private static DevEnvUtil();
    public static Version[] get_InstalledVersions();
    public static Version get_HighestInstalledVersion();
    [CanBeNullAttribute]
public static FileSystemPath TryGetInstallDir(Version ver);
    [CanBeNullAttribute]
public static string TryGetDataLocation(Version ver);
    [CanBeNullAttribute]
public static string TryGetSettingsFilePath(Version ver);
    [NotNullAttribute]
public static string GetRegistryRootKey(Version ver, string hive);
    [NotNullAttribute]
public static string ExpandVsVariables(string str, Version ver);
}
public static class JetBrains.Util.DevEnv.EnvDteUtil : object {
    private static OnError ourOnError;
    private static EnvDteUtil();
    [HandleProcessCorruptedStateExceptionsAttribute]
[NotNullAttribute]
public static IDictionary`2<int, object> GetRunningDteInstances();
    [NotNullAttribute]
public static IDictionary`2<int, object> GetRunningDteInstancesWithGeneratedSolution();
    public static bool ExecuteCommandWithBestDte(string command);
    [HandleProcessCorruptedStateExceptionsAttribute]
public static bool ExecuteDteCommand(object dte, string command, string args);
    [HandleProcessCorruptedStateExceptionsAttribute]
public static Void* TryGetMainWindowHandle(object dte);
    private static bool IsGeneratedSolution(int procid);
    [HandleProcessCorruptedStateExceptionsAttribute]
private static bool IterateParentProcesses(Func`2<int, bool> predicate);
}
public interface JetBrains.Util.DevEnv.IVsEnvironmentInformation {
    [NotNullAttribute]
public abstract virtual BackSlashSeparatedRelativePath GetVsRegistryKey(BackSlashSeparatedRelativePath subkey);
    [NotNullAttribute]
public abstract virtual FileSystemPath GetVsAppDataPath(SpecialFolder spec);
}
public interface JetBrains.Util.DevEnv.IVsEnvironmentStaticInformation {
    [NotNullAttribute]
public FileSystemPath DevEnvInstallDir { get; }
    [NotNullAttribute]
public VsHive VsHive { get; }
    [NotNullAttribute]
public Version2 VsVersion2 { get; }
    [NotNullAttribute]
public Version VsVersion4 { get; }
    [NotNullAttribute]
public string VsDisplayNameLong { get; }
    [NotNullAttribute]
public string VsDisplayVersion { get; }
    public bool IsPreview { get; }
    [NotNullAttribute]
public BackSlashSeparatedRelativePath VisualStudioGlobalRegistryPath { get; }
    public abstract virtual FileSystemPath get_DevEnvInstallDir();
    public abstract virtual VsHive get_VsHive();
    public abstract virtual Version2 get_VsVersion2();
    public abstract virtual Version get_VsVersion4();
    public abstract virtual string get_VsDisplayNameLong();
    public abstract virtual string get_VsDisplayVersion();
    public abstract virtual bool get_IsPreview();
    public abstract virtual BackSlashSeparatedRelativePath get_VisualStudioGlobalRegistryPath();
}
public class JetBrains.Util.DevEnv.VsEnvironmentInformationEmulated : object {
    [NotNullAttribute]
private VsHive myHive;
    private bool myIsPreview;
    [CanBeNullAttribute]
private BackSlashSeparatedRelativePath myVisualStudioGlobalRegistryPath;
    [CanBeNullAttribute]
private FileSystemPath myGetVsInstallDir;
    [CanBeNullAttribute]
private Version myVsVersion4;
    [CanBeNullAttribute]
private string myDefaultVsPresentationLong;
    [CanBeNullAttribute]
private string myVsDisplayVersion;
    private IVsEnvironmentInformation ThisAsInfo { get; }
    private BackSlashSeparatedRelativePath JetBrains.Util.DevEnv.IVsEnvironmentStaticInformation.VisualStudioGlobalRegistryPath { get; }
    private FileSystemPath JetBrains.Util.DevEnv.IVsEnvironmentStaticInformation.DevEnvInstallDir { get; }
    private VsHive JetBrains.Util.DevEnv.IVsEnvironmentStaticInformation.VsHive { get; }
    private Version2 JetBrains.Util.DevEnv.IVsEnvironmentStaticInformation.VsVersion2 { get; }
    private Version JetBrains.Util.DevEnv.IVsEnvironmentStaticInformation.VsVersion4 { get; }
    private string JetBrains.Util.DevEnv.IVsEnvironmentStaticInformation.VsDisplayNameLong { get; }
    private string JetBrains.Util.DevEnv.IVsEnvironmentStaticInformation.VsDisplayVersion { get; }
    private bool JetBrains.Util.DevEnv.IVsEnvironmentStaticInformation.IsPreview { get; }
    public VsEnvironmentInformationEmulated(VsHive vsHive, bool isPreview);
    private IVsEnvironmentInformation get_ThisAsInfo();
    private sealed virtual override BackSlashSeparatedRelativePath JetBrains.Util.DevEnv.IVsEnvironmentStaticInformation.get_VisualStudioGlobalRegistryPath();
    private sealed virtual override FileSystemPath JetBrains.Util.DevEnv.IVsEnvironmentInformation.GetVsAppDataPath(SpecialFolder spec);
    private sealed virtual override BackSlashSeparatedRelativePath JetBrains.Util.DevEnv.IVsEnvironmentInformation.GetVsRegistryKey(BackSlashSeparatedRelativePath subkey);
    private sealed virtual override FileSystemPath JetBrains.Util.DevEnv.IVsEnvironmentStaticInformation.get_DevEnvInstallDir();
    private sealed virtual override VsHive JetBrains.Util.DevEnv.IVsEnvironmentStaticInformation.get_VsHive();
    private sealed virtual override Version2 JetBrains.Util.DevEnv.IVsEnvironmentStaticInformation.get_VsVersion2();
    private sealed virtual override Version JetBrains.Util.DevEnv.IVsEnvironmentStaticInformation.get_VsVersion4();
    private sealed virtual override string JetBrains.Util.DevEnv.IVsEnvironmentStaticInformation.get_VsDisplayNameLong();
    private sealed virtual override string JetBrains.Util.DevEnv.IVsEnvironmentStaticInformation.get_VsDisplayVersion();
    private sealed virtual override bool JetBrains.Util.DevEnv.IVsEnvironmentStaticInformation.get_IsPreview();
    public virtual string ToString();
}
[ValueSerializerAttribute("JetBrains.Util.DevEnv.VsHive/HiveSerializer")]
[TypeConverterAttribute("JetBrains.Util.DevEnv.VsHive/HiveConverter")]
public class JetBrains.Util.DevEnv.VsHive : object {
    private static ILogger ourLogger;
    [NotNullAttribute]
public Version2 Version;
    [NotNullAttribute]
public string InstanceId;
    [NotNullAttribute]
public string RootSuffix;
    [NotNullAttribute]
public string HiveString { get; }
    public string InstanceIdString { get; }
    public VsHive(Version2 version);
    public VsHive(Version2 version, string rootSuffix, string instanceId);
    private static VsHive();
    public string get_HiveString();
    public string get_InstanceIdString();
    public VsHive NewWithRootSuffix(string rootSuffix);
    public sealed virtual int CompareTo(VsHive other);
    public sealed virtual bool Equals(VsHive other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(VsHive left, VsHive right);
    public static bool op_Inequality(VsHive left, VsHive right);
    public virtual string ToString();
    [NotNullAttribute]
public static VsHive Parse(string hiveString);
    public static Pair`2<VsHive, string> TryParse(string hiveString);
    [NotNullAttribute]
public static VsHive FromVersionAndHive(Version2 version, string sInstanceIdAndRootSuffix);
    public static Pair`2<string, string> ParseInstanceIdAndRootSuffix(string source);
}
[DefaultMemberAttribute("Item")]
[ThreadUnsafeAttribute]
[ObsoleteAttribute("No usages in ReSharper")]
public class JetBrains.Util.DictionaryWrapper`2 : object {
    private static Statistics Statistics;
    private Dictionary`2<TKey, TValue> myDictionary;
    public IEqualityComparer`1<TKey> Comparer { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public ICollection`1<TKey> Keys { get; }
    public ICollection`1<TValue> Values { get; }
    private IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Keys { get; }
    private IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Values { get; }
    public TValue Item { get; public set; }
    protected DictionaryWrapper`2(SerializationInfo info, StreamingContext context);
    public DictionaryWrapper`2(IDictionary`2<TKey, TValue> dictionary);
    public DictionaryWrapper`2(IDictionary`2<TKey, TValue> dictionary, IEqualityComparer`1<TKey> comparer);
    public DictionaryWrapper`2(IEqualityComparer`1<TKey> comparer);
    public DictionaryWrapper`2(int capacity, IEqualityComparer`1<TKey> comparer);
    public DictionaryWrapper`2(int capacity);
    private static DictionaryWrapper`2();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public void CopyTo(Array array, int index);
    public sealed virtual void Add(TKey key, TValue value);
    public sealed virtual void Add(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual bool Remove(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual bool ContainsKey(TKey key);
    public bool ContainsValue(TValue value);
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    public sealed virtual bool Remove(TKey key);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    public IEqualityComparer`1<TKey> get_Comparer();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual ICollection`1<TKey> get_Keys();
    public sealed virtual ICollection`1<TValue> get_Values();
    private sealed virtual override IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Keys();
    private sealed virtual override IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Values();
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public sealed virtual void OnDeserialization(object sender);
}
public static class JetBrains.Util.Diff.Diff : object {
    [NullableContextAttribute("1")]
public static IList`1<DiffFragment> Calc(int oldLength, int newLength, DiffComparer comparer);
}
public class JetBrains.Util.Diff.DiffComparer : MulticastDelegate {
    public DiffComparer(object object, IntPtr method);
    public virtual bool Invoke(int x, int y);
    public virtual IAsyncResult BeginInvoke(int x, int y, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
[IsReadOnlyAttribute]
public class JetBrains.Util.Diff.DiffFragment : ValueType {
    [DebuggerBrowsableAttribute("0")]
private TextRange myRangeOld;
    [DebuggerBrowsableAttribute("0")]
private TextRange myRangeNew;
    [DebuggerBrowsableAttribute("0")]
private DiffFragmentType myDiffFragmentType;
    public TextRange RangeOld { get; }
    public TextRange RangeNew { get; }
    public DiffFragmentType Type { get; }
    public DiffFragment(TextRange rangeOld, TextRange rangeNew, DiffFragmentType fragmentType);
    public TextRange get_RangeOld();
    public TextRange get_RangeNew();
    public DiffFragmentType get_Type();
    public virtual string ToString();
    public static bool op_Equality(DiffFragment f1, DiffFragment f2);
    public static bool op_Inequality(DiffFragment f1, DiffFragment f2);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public enum JetBrains.Util.Diff.DiffFragmentType : Enum {
    public int value__;
    public static DiffFragmentType EQUAL;
    public static DiffFragmentType ADDED;
    public static DiffFragmentType DELETED;
    public static DiffFragmentType MODIFIED;
}
internal class JetBrains.Util.Diff.FragmentBuilder : object {
    private int myPosOld;
    private int myPosNew;
    private List`1<DiffFragment> myFragments;
    public IList`1<DiffFragment> Fragments { get; }
    public FragmentBuilder(int lengthOld, int lengthNew);
    public IList`1<DiffFragment> get_Fragments();
    public sealed virtual void AddEqual(int length);
    public sealed virtual void AddChange(int first, int second);
}
internal interface JetBrains.Util.Diff.IDiffBuilder {
    public abstract virtual void AddEqual(int length);
    public abstract virtual void AddChange(int first, int second);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class JetBrains.Util.Diff.LinkedDiffPaths : object {
    private static int VERTICAL_DIRECTION_FLAG;
    private static int DISTANCE_MASK;
    private int myMaxX;
    private int myMaxY;
    private ChunkList`1<Step> mySteps;
    private int myCornerIndex;
    public LinkedDiffPaths(int maxX, int maxY);
    public void DecodePath(IDiffBuilder builder);
    public int EncodeStep(int x, int y, int diagLength, bool afterVertical, int prevIndex);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class JetBrains.Util.Diff.LongestCommonSubsequence : object {
    private int myMaxX;
    private int myMaxY;
    private DiffComparer myComparer;
    private LinkedDiffPaths myPathsMatrix;
    private Int32[] myPrevPathKey;
    private Int32[] myPrevEnds;
    private Int32[] myCurrentEnds;
    public LinkedDiffPaths Paths { get; }
    public LongestCommonSubsequence(int maxX, int maxY, DiffComparer comparer);
    public LinkedDiffPaths get_Paths();
    public int Run();
    private int FindDiagonalEnd(int prevDiagonal, int prevEnd, bool isVertical);
    private int EncodeStep(int prevEnd, int diagLength, int tDiagonal, bool afterVertical);
    private static int CalcBound(int bound, int d);
    private int SkipSnake(int x, int y);
}
public class JetBrains.Util.DirectoryScanner : object {
    private IList`1<string> myExcludePatterns;
    private IList`1<string> myIncludePatterns;
    public IList`1<string> IncludePatterns { get; public set; }
    public IList`1<string> ExcludePatterns { get; public set; }
    public IList`1<string> get_IncludePatterns();
    public void set_IncludePatterns(IList`1<string> value);
    public IList`1<string> get_ExcludePatterns();
    public void set_ExcludePatterns(IList`1<string> value);
    private static Wildcard[] ParsePattern(IFileSystem fs, IEnumerable`1<Wildcard> rootPrefix, bool caseSensitive, string pattern);
    public ImmutableArray`1<FileSystemPath> FindFiles(IFileSystem fs, IDirectoryEntry root, bool caseSensitive);
    public ImmutableArray`1<FileSystemPath> FindFiles(FileSystemPath root, bool caseSensitive);
    private static bool Any(AntPatternState[] state, string component, Predicate`1<MatchResult> predicate, AntPatternState[]& newState);
    private static void FindFilesRec(IDirectoryEntry directory, IList`1<FileSystemPath> result, AntPatternState[] includeState, AntPatternState[] excludeState);
}
public class JetBrains.Util.DnsAPI.AAAARecord : ValueType {
    public IP6Address Address;
    public virtual string ToString();
}
public class JetBrains.Util.DnsAPI.ARecord : ValueType {
    public UInt32 Address;
    public virtual string ToString();
}
public class JetBrains.Util.DnsAPI.ATMARecord : ValueType {
    public byte AddressType;
    public string Address;
    public virtual string ToString();
}
public class JetBrains.Util.DnsAPI.DnsException : ApplicationException {
    private UInt32 errcode;
    public UInt32 ErrorCode { get; }
    public DnsException(string message);
    public DnsException(string message, UInt32 errcode);
    public DnsException(string message, Exception innerException);
    public DnsException(SerializationInfo info, StreamingContext context);
    public UInt32 get_ErrorCode();
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
}
internal enum JetBrains.Util.DnsAPI.DnsFreeType : Enum {
    public UInt32 value__;
    public static DnsFreeType FreeFlat;
    public static DnsFreeType FreeRecordList;
}
public enum JetBrains.Util.DnsAPI.DnsQueryReturnCode : Enum {
    public ulong value__;
    public static DnsQueryReturnCode SUCCESS;
    public static DnsQueryReturnCode UNSPECIFIED_ERROR;
    public static DnsQueryReturnCode MASK;
    public static DnsQueryReturnCode FORMAT_ERROR;
    public static DnsQueryReturnCode SERVER_FAILURE;
    public static DnsQueryReturnCode NAME_ERROR;
    public static DnsQueryReturnCode NOT_IMPLEMENTED;
    public static DnsQueryReturnCode REFUSED;
    public static DnsQueryReturnCode YXDOMAIN;
    public static DnsQueryReturnCode YXRRSET;
    public static DnsQueryReturnCode NXRRSET;
    public static DnsQueryReturnCode NOTAUTH;
    public static DnsQueryReturnCode NOTZONE;
    public static DnsQueryReturnCode BADSIG;
    public static DnsQueryReturnCode BADKEY;
    public static DnsQueryReturnCode BADTIME;
    public static DnsQueryReturnCode PACKET_FMT_BASE;
    public static DnsQueryReturnCode NO_RECORDS;
    public static DnsQueryReturnCode BAD_PACKET;
    public static DnsQueryReturnCode NO_PACKET;
    public static DnsQueryReturnCode RCODE;
    public static DnsQueryReturnCode UNSECURE_PACKET;
}
[FlagsAttribute]
internal enum JetBrains.Util.DnsAPI.DnsQueryType : Enum {
    public UInt32 value__;
    public static DnsQueryType STANDARD;
    public static DnsQueryType ACCEPT_TRUNCATED_RESPONSE;
    public static DnsQueryType USE_TCP_ONLY;
    public static DnsQueryType NO_RECURSION;
    public static DnsQueryType BYPASS_CACHE;
    public static DnsQueryType NO_WIRE_QUERY;
    public static DnsQueryType NO_LOCAL_NAME;
    public static DnsQueryType NO_HOSTS_FILE;
    public static DnsQueryType NO_NETBT;
    public static DnsQueryType WIRE_ONLY;
    public static DnsQueryType TREAT_AS_FQDN;
    [ObsoleteAttribute]
public static DnsQueryType ALLOW_EMPTY_AUTH_RESP;
    public static DnsQueryType DONT_RESET_TTL_VALUES;
    public static DnsQueryType RESERVED;
    [ObsoleteAttribute("use NO_WIRE_QUERY instead")]
public static DnsQueryType CACHE_ONLY;
    public static DnsQueryType RETURN_MESSAGE;
}
internal class JetBrains.Util.DnsAPI.DnsRecord : ValueType {
    public IntPtr Next;
    public string Name;
    public DnsRecordType RecordType;
    public ushort DataLength;
    public DnsRecordFlags Flags;
    public UInt32 Ttl;
    public UInt32 Reserved;
}
[FlagsAttribute]
public enum JetBrains.Util.DnsAPI.DnsRecordType : Enum {
    public ushort value__;
    public static DnsRecordType A;
    public static DnsRecordType NS;
    [ObsoleteAttribute]
public static DnsRecordType MD;
    [ObsoleteAttribute]
public static DnsRecordType MF;
    public static DnsRecordType CNAME;
    public static DnsRecordType SOA;
    public static DnsRecordType MB;
    public static DnsRecordType MG;
    public static DnsRecordType MR;
    public static DnsRecordType NULL;
    public static DnsRecordType WKS;
    public static DnsRecordType PTR;
    public static DnsRecordType HINFO;
    public static DnsRecordType MINFO;
    public static DnsRecordType MX;
    public static DnsRecordType TEXT;
    public static DnsRecordType RP;
    public static DnsRecordType AFSDB;
    public static DnsRecordType X25;
    public static DnsRecordType ISDN;
    public static DnsRecordType RT;
    public static DnsRecordType NSAP;
    [ObsoleteAttribute]
public static DnsRecordType NSAPPTR;
    public static DnsRecordType SIG;
    public static DnsRecordType KEY;
    public static DnsRecordType PX;
    [ObsoleteAttribute]
public static DnsRecordType GPOS;
    public static DnsRecordType AAAA;
    public static DnsRecordType LOC;
    public static DnsRecordType NXT;
    public static DnsRecordType SRV;
    public static DnsRecordType ATMA;
    public static DnsRecordType TKEY;
    public static DnsRecordType TSIG;
    public static DnsRecordType IXFR;
    public static DnsRecordType AXFR;
    public static DnsRecordType MAILB;
    public static DnsRecordType MAILA;
    public static DnsRecordType ALL;
    public static DnsRecordType ANY;
    public static DnsRecordType WINS;
    public static DnsRecordType WINSR;
    public static DnsRecordType NBSTAT;
}
public class JetBrains.Util.DnsAPI.DnsRequest : object {
    private DnsQueryType QueryType;
    private string domain;
    private DnsServerCollection servers;
    public DnsServerCollection Servers { get; }
    public bool UseTCPOnly { get; public set; }
    public bool AcceptTruncatedResponse { get; public set; }
    public bool NoRecursion { get; public set; }
    public bool BypassCache { get; public set; }
    public bool QueryCacheOnly { get; public set; }
    public bool WireOnly { get; public set; }
    public bool NoLocalName { get; public set; }
    public bool NoHostsFile { get; public set; }
    public bool NoNetbt { get; public set; }
    public bool QueryReturnMessage { get; public set; }
    public bool TreatAsFQDN { get; public set; }
    public bool DontResetTTLValues { get; public set; }
    public string Domain { get; public set; }
    public DnsRequest(string domain);
    private static UInt32 DnsQuery(string Name, DnsRecordType Type, DnsQueryType Options, IntPtr Servers, IntPtr& QueryResultsSet, IntPtr Reserved);
    private static void DnsRecordListFree(IntPtr RecordList, DnsFreeType FreeType);
    public DnsServerCollection get_Servers();
    public bool get_UseTCPOnly();
    public void set_UseTCPOnly(bool value);
    public bool get_AcceptTruncatedResponse();
    public void set_AcceptTruncatedResponse(bool value);
    public bool get_NoRecursion();
    public void set_NoRecursion(bool value);
    public bool get_BypassCache();
    public void set_BypassCache(bool value);
    public bool get_QueryCacheOnly();
    public void set_QueryCacheOnly(bool value);
    public bool get_WireOnly();
    public void set_WireOnly(bool value);
    public bool get_NoLocalName();
    public void set_NoLocalName(bool value);
    public bool get_NoHostsFile();
    public void set_NoHostsFile(bool value);
    public bool get_NoNetbt();
    public void set_NoNetbt(bool value);
    public bool get_QueryReturnMessage();
    public void set_QueryReturnMessage(bool value);
    public bool get_TreatAsFQDN();
    public void set_TreatAsFQDN(bool value);
    public bool get_DontResetTTLValues();
    public void set_DontResetTTLValues(bool value);
    private bool GetSetting(DnsQueryType type);
    private void SetSetting(DnsQueryType type, bool newvalue);
    public string get_Domain();
    public void set_Domain(string value);
    private void Initialize(string domain);
    public DnsResponse GetResponse();
    private DnsResponse GetResponseWindows();
    private void GetData(IntPtr ptr, DnsRecord& dnsrec, Object& Data);
    public DnsResponse GetResponseUnix();
}
public class JetBrains.Util.DnsAPI.DnsResponse : object {
    private DnsWrapperCollection rawrecords;
    public DnsWrapperCollection RawRecords { get; }
    public ARecord[] ARecords { get; }
    public MXRecord[] MXRecords { get; }
    public PTRRecord[] NSRecords { get; }
    public DnsWrapperCollection get_RawRecords();
    public ArrayList GetRecords(DnsRecordType type);
    public ARecord[] get_ARecords();
    public MXRecord[] get_MXRecords();
    public PTRRecord[] get_NSRecords();
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Util.DnsAPI.DnsServerCollection : CollectionBase {
    public IPAddress Item { get; }
    internal IP4_Array ToIP4_Array();
    public void Add(string host);
    public IPAddress get_Item(int idx);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class JetBrains.Util.DnsAPI.DnsWrapper : ValueType {
    public DnsRecordType RecordType;
    public object RecordData;
    public bool Equals(DnsRecordType type);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual int CompareTo(object obj);
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Util.DnsAPI.DnsWrapperCollection : ReadOnlyCollectionBase {
    public DnsWrapper Item { get; }
    internal bool Contains(DnsWrapper w);
    internal void Add(DnsWrapper w);
    public DnsWrapper get_Item(int i);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class JetBrains.Util.DnsAPI.IP4_Array : ValueType {
    public int AddrCount;
    public Int32[] AddrArray;
}
public class JetBrains.Util.DnsAPI.IP6Address : ValueType {
    public UInt32 IPFrag1;
    public UInt32 IPFrag2;
    public UInt32 IPFrag3;
    public UInt32 IPFrag4;
    public UInt32 IPFrag5;
    public UInt32 IPFrag6;
    public UInt32 IPFrag7;
    public UInt32 IPFrag8;
    public virtual string ToString();
}
public class JetBrains.Util.DnsAPI.KEYRecord : ValueType {
    public ushort Flags;
    public byte Protocol;
    public byte Algorithm;
    public byte Key;
    public virtual string ToString();
}
public class JetBrains.Util.DnsAPI.LOCRecord : ValueType {
    public ushort Version;
    public ushort Size;
    public ushort HorPrec;
    public ushort VerPrec;
    public UInt32 Latitude;
    public UInt32 Longitude;
    public UInt32 Altitude;
}
public class JetBrains.Util.DnsAPI.MINFORecord : ValueType {
    public string Mailbox;
    public string ErrorsMailbox;
    public virtual string ToString();
}
public class JetBrains.Util.DnsAPI.MXRecord : ValueType {
    public string Exchange;
    public ushort Preference;
    public ushort Pad;
    public virtual string ToString();
}
public class JetBrains.Util.DnsAPI.NULLRecord : ValueType {
    public UInt32 ByteCount;
    public string Data;
    public virtual string ToString();
}
public class JetBrains.Util.DnsAPI.NXTRecord : ValueType {
    public string NameNext;
    public byte TypeBitMap;
    public virtual string ToString();
}
public class JetBrains.Util.DnsAPI.PTRRecord : ValueType {
    public string HostName;
    public virtual string ToString();
}
public class JetBrains.Util.DnsAPI.SIGRecord : ValueType {
    public string Signer;
    public ushort TypeCovered;
    public byte Algorithm;
    public byte LabelCount;
    public UInt32 OriginalTtl;
    public UInt32 Expiration;
    public UInt32 TimeSigned;
    public ushort KeyTag;
    public ushort Pad;
    public byte Signature;
}
public class JetBrains.Util.DnsAPI.SOARecord : ValueType {
    public string PrimaryServer;
    public string Administrator;
    public UInt32 SerialNo;
    public UInt32 Refresh;
    public UInt32 Retry;
    public UInt32 Expire;
    public UInt32 DefaultTtl;
    public virtual string ToString();
}
public class JetBrains.Util.DnsAPI.SRVRecord : ValueType {
    public string NameNext;
    public ushort Priority;
    public ushort Weight;
    public ushort Port;
    public ushort Pad;
    public virtual string ToString();
}
public class JetBrains.Util.DnsAPI.TKEYRecord : ValueType {
    public string Algorithm;
    public IntPtr AlgorithmPacket;
    public IntPtr Key;
    public IntPtr OtherData;
    public UInt32 CreateTime;
    public UInt32 ExpireTime;
    public ushort Mode;
    public ushort Error;
    public ushort KeyLength;
    public ushort OtherLength;
    public char AlgNameLength;
    public bool PacketPointers;
}
public class JetBrains.Util.DnsAPI.TSIGRecord : ValueType {
    public string Algorithm;
    public IntPtr AlgorithmPacket;
    public IntPtr Key;
    public IntPtr OtherData;
    public long CreateTime;
    public ushort FudgeTime;
    public ushort OriginalXid;
    public ushort Error;
    public ushort KeyLength;
    public ushort OtherLength;
    public char AlgNameLength;
    public bool PacketPointers;
}
public class JetBrains.Util.DnsAPI.TXTRecord : ValueType {
    public UInt32 StringCount;
    public string StringArray;
    public virtual string ToString();
}
public class JetBrains.Util.DnsAPI.WINSRecord : ValueType {
    public UInt32 MappingFlag;
    public UInt32 LookupTimeout;
    public UInt32 CacheTimeout;
    public UInt32 ServerCount;
    public IntPtr WinsServers;
    public virtual string ToString();
}
public class JetBrains.Util.DnsAPI.WINSRRecord : ValueType {
    public UInt32 MappingFlag;
    public UInt32 LookupTimeout;
    public UInt32 CacheTimeout;
    public string ResultDomain;
    public virtual string ToString();
}
public class JetBrains.Util.DnsAPI.WKSRecord : ValueType {
    public UInt32 IpAddress;
    public char Protocol;
    public byte BitMask;
    public virtual string ToString();
}
public class JetBrains.Util.Dotnet.Internal.GacFolderUtil : object {
    private static Dictionary`2<VirtualFileSystemPath, FolderContentCache> ourGacFolderCaches;
    private static GacFolderUtil();
    public static FolderContentCache CreateCache(Lifetime lifetime, VirtualFileSystemPath gacRootPath);
    private static IEnumerable`1<VirtualFileSystemPath> GetChildDirectories(VirtualFileSystemPath gacRootPath, VirtualFileSystemPath folderPath);
    public static bool FileExists(VirtualFileSystemPath gacRootPath, VirtualFileSystemPath filePath);
    public static bool DirectoryExists(VirtualFileSystemPath gacRootPath, VirtualFileSystemPath folderPath);
    public static void GetCandidatesFromGac(VirtualFileSystemPath gacPath, VirtualFileSystemPath assemblyFolder, string name, LocalList`1& result);
}
public static class JetBrains.Util.Dotnet.Internal.SystemRuntimeVersioningBinaryCompatibility : object {
    [NotNullAttribute]
public static JObject ReportBinaryCompatibilityFlags();
}
public static class JetBrains.Util.Dotnet.MicrosoftDotNet.DotNetFrameworkGac : object {
    public static String[] GacFolders;
    private static String[] ourGacFolders40;
    private static HashSet`1<string> ourBlessedGacAssemblies;
    private static DotNetFrameworkGac();
    public static VirtualFileSystemPath ResolveInGac(AssemblyNameInfo assemblyName, VirtualFileSystemPath gacRootPath);
    public static VirtualFileSystemPath GetGacPath(IInteractionContext context);
    [CanBeNullAttribute]
public static VirtualFileSystemPath GetGacPath40(IInteractionContext context);
    public static VirtualFileSystemPath ResolveInGac40(AssemblyNameInfo assemblyName, string platform, VirtualFileSystemPath gacPath);
    [NotNullAttribute]
private static IList`1<VirtualFileSystemPath> GetCandidatesFromGacCore(string name, VirtualFileSystemPath gacPath, String[] gacfolders);
    [NotNullAttribute]
public static IList`1<VirtualFileSystemPath> GetCandidatesFromGac(string name, VirtualFileSystemPath gacPath);
    [NotNullAttribute]
public static IList`1<VirtualFileSystemPath> GetCandidatesFromGac40(string name, VirtualFileSystemPath gacPath);
}
public class JetBrains.Util.Dotnet.MicrosoftDotNet.DotNetGac : object {
    [CompilerGeneratedAttribute]
private VirtualFileSystemPath <GacPath>k__BackingField;
    [CompilerGeneratedAttribute]
private VirtualFileSystemPath <GacPath40>k__BackingField;
    private static DotNetGac ourLocalGac;
    private static Key`1<DotNetGac> ourGacKey;
    public VirtualFileSystemPath GacPath { get; }
    public VirtualFileSystemPath GacPath40 { get; }
    public DotNetGac(IInteractionContext context);
    private static DotNetGac();
    [CompilerGeneratedAttribute]
public VirtualFileSystemPath get_GacPath();
    [CompilerGeneratedAttribute]
public VirtualFileSystemPath get_GacPath40();
    public static DotNetGac GetInstance(IInteractionContext context);
}
public class JetBrains.Util.Dotnet.MicrosoftDotNet.DotNetRuntimes : object {
    private static DotNetRuntimes ourInstance;
    private static DotNetRuntimes ourInstances32;
    [CompilerGeneratedAttribute]
private IList`1<DotNetRuntime> <AllRuntimes>k__BackingField;
    private static string MsCorLib;
    private static RelativePath ourRegistryPathNDP;
    private static RelativePath ourRegistryPathWowNDP;
    private static BackSlashSeparatedRelativePath ourRegistryPathFramework;
    public IList`1<DotNetRuntime> AllRuntimes { get; }
    [UsedImplicitlyAttribute]
public static DotNetRuntimes Instance { get; }
    [UsedImplicitlyAttribute]
public static DotNetRuntimes Instances32 { get; }
    private DotNetRuntimes(IList`1<DotNetRuntime> allRuntimes);
    private static DotNetRuntimes();
    [CompilerGeneratedAttribute]
public IList`1<DotNetRuntime> get_AllRuntimes();
    public static DotNetRuntimes get_Instance();
    public static DotNetRuntimes get_Instances32();
    private static DotNetRuntimes GetDotNetRuntimes();
    private static DotNetRuntime GetRuntime(Func`2<FrameworkRegistryData, bool> versionFilter, string folderPrefix, string fileToCheck, RelativePath aspNetCompilerPath, RelativePath temporaryASPFilesFile);
    [CanBeNullAttribute]
public static VirtualFileSystemPath FindDotNetFrameworkPath(string prefix, string requiredFile);
    private static VirtualFileSystemPath GetInstallRoot();
    [CanBeNullAttribute]
public DotNetRuntime GetByTargetPlatformId(TargetFrameworkId targetFrameworkId);
    [CanBeNullAttribute]
public DotNetRuntime GetByTargetNuGetFramework(NuGetFramework nugetFramework);
    public DotNetRuntime GetByTargetFrameworkVersion(Version targetVersion);
}
[PublicAPIAttribute]
public class JetBrains.Util.Dotnet.MicrosoftDotNet.ReferenceAssemblies : object {
    private IInteractionContext myContext;
    [CompilerGeneratedAttribute]
private List`1<ReferenceAssemblyFolder> <ReferenceAssemblyFolders>k__BackingField;
    [CompilerGeneratedAttribute]
private ILookup`2<Version, ReferenceAssemblyFolder> <ReferenceAssemblyFoldersLookup>k__BackingField;
    private static ReferenceAssemblies ourInstance;
    [PublicAPIAttribute]
public List`1<ReferenceAssemblyFolder> ReferenceAssemblyFolders { get; private set; }
    [PublicAPIAttribute]
public ILookup`2<Version, ReferenceAssemblyFolder> ReferenceAssemblyFoldersLookup { get; private set; }
    public static ReferenceAssemblies Instance { get; }
    public ReferenceAssemblies(IInteractionContext context);
    private static ReferenceAssemblies();
    [CompilerGeneratedAttribute]
public List`1<ReferenceAssemblyFolder> get_ReferenceAssemblyFolders();
    [CompilerGeneratedAttribute]
private void set_ReferenceAssemblyFolders(List`1<ReferenceAssemblyFolder> value);
    [CompilerGeneratedAttribute]
public ILookup`2<Version, ReferenceAssemblyFolder> get_ReferenceAssemblyFoldersLookup();
    [CompilerGeneratedAttribute]
private void set_ReferenceAssemblyFoldersLookup(ILookup`2<Version, ReferenceAssemblyFolder> value);
    public static ReferenceAssemblies get_Instance();
    public void Refresh();
    private IList`1<ReferenceAssemblyFolder> GetReferenceAssembliesVersion3Folder();
    private static List`1<ReferenceAssemblyFolder> AddRuntimeFolders(IInteractionContext interactionContext);
    public IList`1<ReferenceAssemblyFolder> GetReferenceAssembliesFolder();
    [NotNullAttribute]
private VirtualFileSystemPath GetProgramFiles86(IInteractionContext context);
    [NotNullAttribute]
public VirtualFileSystemPath GetMicrosoftReferenceAssembliesRoot();
    [NotNullAttribute]
private VirtualFileSystemPath GetReferencedAssembliesDir();
    [CanBeNullAttribute]
private VirtualFileSystemPath GetReferenceAssembliesDirectory(string directoryName);
}
public static class JetBrains.Util.Dotnet.Mono.MonoDiscoveryUtil : object {
    public static List`1<MonoInstance> InstancesFromDefaultLocation;
    private static MonoDiscoveryUtil();
    [CanBeNullAttribute]
public static MonoInstance TryGetMonoRuntimeFromFolder(FileSystemPath rootFolder);
    [NotNullAttribute]
public static List`1<MonoInstance> MonoInstancesFromDefaultLocation();
    [NotNullAttribute]
private static List`1<MonoInstance> TryGetMonoRuntimeFromFolders(IEnumerable`1<FileSystemPath> rootFolders);
}
public class JetBrains.Util.Dotnet.Mono.MonoInstance : object {
    private IList`1<MonoRuntime> myMonoRuntimes;
    [CompilerGeneratedAttribute]
private FileSystemPath <RootFolder>k__BackingField;
    public FileSystemPath RootFolder { get; }
    public IList`1<MonoRuntime> MonoRuntimes { get; }
    public MonoInstance(FileSystemPath rootFolder);
    [CompilerGeneratedAttribute]
public FileSystemPath get_RootFolder();
    public IList`1<MonoRuntime> get_MonoRuntimes();
    private IEnumerable`1<MonoRuntime> GetRuntimes();
}
public class JetBrains.Util.Dotnet.Mono.MonoRuntime : object {
    [CanBeNullAttribute]
public static MonoRuntime ExecutingRuntime;
    [CompilerGeneratedAttribute]
private FileSystemPath <RuntimePath>k__BackingField;
    [CompilerGeneratedAttribute]
private FileSystemPath <GacPath>k__BackingField;
    [CompilerGeneratedAttribute]
private FileSystemPath <GacPathOverride>k__BackingField;
    public FileSystemPath RuntimePath { get; }
    public FileSystemPath GacPath { get; }
    public FileSystemPath GacPathOverride { get; }
    internal MonoRuntime(FileSystemPath gacPath, FileSystemPath gacPathOverride, FileSystemPath runtimePath);
    private static MonoRuntime();
    [CompilerGeneratedAttribute]
public FileSystemPath get_RuntimePath();
    [CompilerGeneratedAttribute]
public FileSystemPath get_GacPath();
    [CompilerGeneratedAttribute]
public FileSystemPath get_GacPathOverride();
    [CanBeNullAttribute]
private static MonoRuntime InitFromCurrentRuntime();
    private static string GetMonoGacDir();
    public virtual string ToString();
}
[ExtensionAttribute]
public static class JetBrains.Util.Dotnet.NuGetFrameworkEx : object {
    public static string UnitySubset;
    public static string UnityFull;
    [ExtensionAttribute]
[CanBeNullAttribute]
public static Version TryGetUnitySubsetVersion(NuGetFramework nuGetFramework);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static Version TryGetUnityFullVersion(NuGetFramework nuGetFramework);
    [CanBeNullAttribute]
private static Version TryGetUnityVersion(NuGetFramework nuGetFramework, string unityPrefix);
    [ExtensionAttribute]
public static bool IsNet8OrLaterTargetFrameworkWithPlatformBuildAndZeroRevision(NuGetFramework nf);
    [ExtensionAttribute]
private static NuGetFramework AddPlatformRevisionToNugetFramework(NuGetFramework nf, int revision);
    [ExtensionAttribute]
public static string GetNugetFrameworkStringWithAppendedRevisionIfNecessary(NuGetFramework nf, Func`2<NuGetFramework, string> getStringFunc);
}
public class JetBrains.Util.Dotnet.TargetFrameworkIds.TargetFrameworkId : object {
    public static TargetFrameworkId Default;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetFramework <NuGetFramework>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowedToReferenceDefaultTargetFramework>k__BackingField;
    [NotNullAttribute]
private static HashSet`1<TargetFrameworkId> ourAllKnownIds;
    [NotNullAttribute]
private static Dictionary`2<string, TargetFrameworkId> ourIntern;
    [NotNullAttribute]
private static ReaderWriterLockSlim ourReaderWriterLock;
    private static string netCoreRcVersionString;
    private static Dictionary`2<string, NuGetFramework> TargetFrameworkMapping;
    [CompilerGeneratedAttribute]
private string <UniqueString>k__BackingField;
    [NotNullAttribute]
public string Name { get; }
    [NotNullAttribute]
public Version Version { get; }
    [NotNullAttribute]
public NuGetFramework NuGetFramework { get; }
    public bool AllowedToReferenceDefaultTargetFramework { get; }
    [NotNullAttribute]
public static IEnumerable`1<TargetFrameworkId> AllKnownIds { get; }
    public string PresentableString { get; }
    public string UniqueString { get; }
    public bool IsDNX { get; }
    public bool IsDNXCore { get; }
    public bool IsNetFramework { get; }
    public bool IsNetPlatform { get; }
    public bool IsNetCore { get; }
    public bool IsNetCoreApp { get; }
    public bool IsNetStandard { get; }
    public bool IsUAP { get; }
    public bool IsWindowsPhone { get; }
    public bool IsWindowsStoreApp { get; }
    public bool IsSilverlight { get; }
    public bool IsXamarinAndroid { get; }
    public bool IsXamarinMacios { get; }
    public bool IsXamarinIOS { get; }
    public bool IsXamarinMac { get; }
    public bool IsXamarinWatchOS { get; }
    public bool IsXamarinTVOS { get; }
    public bool IsXamarinMacCatalyst { get; }
    public bool IsWindowsPlatform { get; }
    private TargetFrameworkId(string name, Version version, NuGetFramework nugetFramework, bool allowedToReferenceDefaultTargetFramework);
    private static TargetFrameworkId();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public Version get_Version();
    [CompilerGeneratedAttribute]
public NuGetFramework get_NuGetFramework();
    [CompilerGeneratedAttribute]
public bool get_AllowedToReferenceDefaultTargetFramework();
    public static IEnumerable`1<TargetFrameworkId> get_AllKnownIds();
    private static ValueTuple`2<string, Version> GetNameAndVersion(string raw);
    [NotNullAttribute]
public static TargetFrameworkId Create(FrameworkIdentifier frameworkIdentifier, Version version);
    [NotNullAttribute]
public static TargetFrameworkId Create(FrameworkIdentifier frameworkIdentifier, Version version, ProfileIdentifier profileIdentifier);
    [NotNullAttribute]
public static TargetFrameworkId Create(FrameworkIdentifier frameworkIdentifier, Version version, string profile);
    [NotNullAttribute]
public static TargetFrameworkId Create(string frameworkIdentifier, Version version, string profile);
    private static Nullable`1<bool> AssertAndFixAllowedToReferenceDefaultTargetFramework(string name, Nullable`1<bool> allowedToReferenceDefaultTargetFramework);
    [NotNullAttribute]
public static TargetFrameworkId Create(string originalName, Nullable`1<bool> allowedToReferenceDefaultTargetFramework);
    [NotNullAttribute]
private static TargetFrameworkId Create(NuGetFramework nugetFramework, ValueTuple`2<string, Version> nameAndVersion, Nullable`1<bool> allowedToReferenceDefaultTargetFramework);
    [NotNullAttribute]
public static TargetFrameworkId Create(NuGetFramework nugetFramework);
    public sealed virtual int CompareTo(TargetFrameworkId other);
    public virtual string ToString();
    public string get_PresentableString();
    [CompilerGeneratedAttribute]
public string get_UniqueString();
    [NotNullAttribute]
private string CalculateUniqueString();
    [CanBeNullAttribute]
public string TryGetShortIdentifier();
    public static bool op_Equality(TargetFrameworkId left, TargetFrameworkId right);
    public static bool op_Inequality(TargetFrameworkId left, TargetFrameworkId right);
    public sealed virtual bool Equals(TargetFrameworkId other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public bool get_IsDNX();
    public bool get_IsDNXCore();
    public bool get_IsNetFramework();
    public bool get_IsNetPlatform();
    public bool get_IsNetCore();
    public bool get_IsNetCoreApp();
    public bool get_IsNetStandard();
    public bool get_IsUAP();
    public bool get_IsWindowsPhone();
    public bool get_IsWindowsStoreApp();
    public bool get_IsSilverlight();
    public bool get_IsXamarinAndroid();
    public bool get_IsXamarinMacios();
    public bool get_IsXamarinIOS();
    public bool get_IsXamarinMac();
    public bool get_IsXamarinWatchOS();
    public bool get_IsXamarinTVOS();
    public bool get_IsXamarinMacCatalyst();
    public bool get_IsWindowsPlatform();
    public static bool IsDnxName(string name);
    public static bool IsDnxCoreName(string name);
    public static bool IsNetPlatformName(string name);
    public static bool IsNetFrameworkName(string name);
    public static bool IsNetCoreAppName(string name);
    public static bool IsNetCoreName(string name);
    public static bool IsNetStandardName(string name);
    public static bool IsUAPName(string name);
    public static bool IsWindowsPhoneName(string name);
    public static bool IsSilverlightName(string name);
    public static bool IsWindowsStoreAppName(string name);
    [NotNullAttribute]
public static TargetFrameworkId Read(BinaryReader reader);
    [NotNullAttribute]
public static TargetFrameworkId Read(UnsafeReader reader);
    public void Write(BinaryWriter writer);
    public void Write(UnsafeWriter writer);
    [CompilerGeneratedAttribute]
private string <CalculateUniqueString>b__37_0();
    [CompilerGeneratedAttribute]
private string <TryGetShortIdentifier>b__38_0();
}
[ExtensionAttribute]
public static class JetBrains.Util.Dotnet.TargetFrameworkIds.TargetFrameworkIdEx : object {
    [ExtensionAttribute]
[ContractAnnotationAttribute("null => true")]
public static bool IsNullOrDefault(TargetFrameworkId thIs);
    [ExtensionAttribute]
public static bool IsReferenceAllowedRelaxed(TargetFrameworkId fromTargetFrameworkId, TargetFrameworkId referenceTargetFrameworkId);
    [ExtensionAttribute]
public static bool IsReferenceAllowedEx(TargetFrameworkId fromTargetFrameworkId, TargetFrameworkId referenceTargetFrameworkId);
    [ExtensionAttribute]
public static bool IsReferenceAllowed(TargetFrameworkId fromTargetFrameworkId, TargetFrameworkId referenceTargetFrameworkId);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static TargetFrameworkId SelectTargetFrameworkIdToReference(TargetFrameworkId fromTargetFrameworkId, IEnumerable`1<TargetFrameworkId> candidates);
    private static Nullable`1<int> CompareForNet60WithSuffix(TargetFrameworkId id1, TargetFrameworkId id2);
    [ExtensionAttribute]
public static Pair`2<string, Version> TryGetDotNetPlatformInfo(TargetFrameworkId targetFrameworkId);
    [ExtensionAttribute]
public static bool IsNet50WithSuffix(TargetFrameworkId targetFrameworkId);
    [ExtensionAttribute]
public static bool IsNet60WithSuffix(TargetFrameworkId targetFrameworkId);
    public static IReadOnlyCollection`1<TargetFrameworkId> GetTargetFrameworksFromString(string targetFrameworks);
    [CanBeNullAttribute]
public static NuGetFramework GetNuGetProjectFramework(string projectFilePath, string targetFrameworkMoniker, string targetPlatformMoniker, string targetPlatformMinVersion);
    [ExtensionAttribute]
public static string GetShortFolderName(TargetFrameworkId id);
    [ExtensionAttribute]
public static void Dump(IEnumerable`1<TargetFrameworkId> ids, TextWriter writer);
    [ExtensionAttribute]
public static FrameworkIdentifier GetFrameworkIdentifier(TargetFrameworkId targetFrameworkId);
    [ExtensionAttribute]
public static ProfileIdentifier GetProfileIdentifier(TargetFrameworkId targetFrameworkId);
    [ExtensionAttribute]
public static FrameworkName GetFrameworkName(TargetFrameworkId targetFrameworkId);
    [ExtensionAttribute]
public static TargetFrameworkId CopyWithProfile(TargetFrameworkId targetFrameworkId, string profileName);
    [ExtensionAttribute]
public static TargetFrameworkId CopyWithVersion(TargetFrameworkId targetFrameworkId, Version version);
    [ExtensionAttribute]
public static string GetPlatformIdLikeFullName(TargetFrameworkId targetFrameworkId);
    [ExtensionAttribute]
[NotNullAttribute]
public static string GetUIPresentation(TargetFrameworkId targetFrameworkId);
    [ExtensionAttribute]
public static TargetFrameworkUIPresentationSections GetUIPresentationSections(TargetFrameworkId targetFrameworkId, bool omitFullZeroVersion);
    private static string GetFrameworkStringName(TargetFrameworkId targetFrameworkId);
    private static string FrameworkVersionToString(Version version);
}
public class JetBrains.Util.Dotnet.TargetFrameworkIds.TargetFrameworkUIPresentationSections : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Profile>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Platform>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PlatformVersion>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public string Name { get; public set; }
    public string Version { get; public set; }
    public string Profile { get; public set; }
    public string Platform { get; public set; }
    public string PlatformVersion { get; public set; }
    public TargetFrameworkUIPresentationSections(string Name, string Version, string Profile, string Platform, string PlatformVersion);
    [CompilerGeneratedAttribute]
protected TargetFrameworkUIPresentationSections(TargetFrameworkUIPresentationSections original);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Version();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Version(string value);
    [CompilerGeneratedAttribute]
public string get_Profile();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Profile(string value);
    [CompilerGeneratedAttribute]
public string get_Platform();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Platform(string value);
    [CompilerGeneratedAttribute]
public string get_PlatformVersion();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PlatformVersion(string value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(TargetFrameworkUIPresentationSections left, TargetFrameworkUIPresentationSections right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(TargetFrameworkUIPresentationSections left, TargetFrameworkUIPresentationSections right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(TargetFrameworkUIPresentationSections other);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual TargetFrameworkUIPresentationSections <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(String& Name, String& Version, String& Profile, String& Platform, String& PlatformVersion);
}
public static class JetBrains.Util.Dotnet.TargetFrameworkIds.TargetFrameworkUtil : object {
    [CanBeNullAttribute]
public static TargetFrameworkId TryGetTargetFrameworId(string projectName, string contextName);
    [CanBeNullAttribute]
public static string TryGetTargetFrameworkName(string projectName, string contextName);
    public static Pair`2<StringSlice, StringSlice> TryGetNameAndTargetFrameworkNameSlices(string projectName, string contextName);
}
public class JetBrains.Util.DynamicTypeEmitter : object {
    private static List`1<MethodInfo> ourRegisteredMethods;
    private MethodInfo myGetRegisteredMethodMethod;
    private MethodInfo myDynamicInvokeMethod;
    private MethodInfo myLogMethod;
    private Type myObjectType;
    private ConstructorInfo myObjectConstructor;
    private Type myDynamicType;
    private Type myLoggerType;
    private ConstructorInfo myIgnoresAccessChecksAttributeConstr;
    private static DynamicTypeEmitter();
    public static MethodInfo GetRegisteredMethod(int index);
    public Type CreateProxyType(IEnumerable`1<Type> interfaces, string typeName);
}
public class JetBrains.Util.ElementCreator`2 : MulticastDelegate {
    public ElementCreator`2(object object, IntPtr method);
    public virtual TElement Invoke(TKey key);
    public virtual IAsyncResult BeginInvoke(TKey key, AsyncCallback callback, object object);
    public virtual TElement EndInvoke(IAsyncResult result);
}
public class JetBrains.Util.ElementsCache`2 : object {
    private ReaderWriterLock myCacheLock;
    private ElementCreator`2<TKey, TElement> myElementCreator;
    private Dictionary`2<TKey, TElement> myElements;
    public ElementCreator`2<TKey, TElement> ElementCreator { get; }
    public ICollection`1<TKey> Keys { get; }
    public ElementsCache`2(ElementCreator`2<TKey, TElement> elementCreator);
    public ElementCreator`2<TKey, TElement> get_ElementCreator();
    public ICollection`1<TKey> get_Keys();
    public TElement Get(TKey key);
    protected virtual void OnAfterElementCreated(TKey key, TElement element);
    public bool TryGet(TKey key, TElement& element);
    public bool Contains(TKey key);
    public virtual void Drop(TKey key);
    public virtual void Reset();
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Util.EmptyDictionary`2 : object {
    [NotNullAttribute]
public static EmptyDictionary`2<TKey, TValue> Instance;
    [NotNullAttribute]
public static IDictionary`2<TKey, TValue> InstanceDictionary;
    [NotNullAttribute]
public static IReadOnlyDictionary`2<TKey, TValue> InstanceReadOnly;
    [NotNullAttribute]
private static CollectionReadOnlyException ReadOnly { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public ICollection`1<TKey> Keys { get; }
    public ICollection`1<TValue> Values { get; }
    private IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Keys { get; }
    private IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Values { get; }
    public TValue Item { get; public set; }
    private static EmptyDictionary`2();
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Add(TKey key, TValue value);
    public sealed virtual void Add(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual bool Remove(TKey key);
    public sealed virtual bool Remove(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual bool ContainsKey(TKey key);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    private static CollectionReadOnlyException get_ReadOnly();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual ICollection`1<TKey> get_Keys();
    public sealed virtual ICollection`1<TValue> get_Values();
    private sealed virtual override IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Keys();
    private sealed virtual override IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Values();
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
}
[ExtensionAttribute]
public static class JetBrains.Util.EncryptionUtil : object {
    public static string DES_KEY;
    private static string PREFIX;
    [ContractAnnotationAttribute("null => null; notnull=>notnull")]
[CanBeNullAttribute]
public static string Encrypt(string settingValue);
    [ContractAnnotationAttribute("null => null; notnull=>notnull")]
[CanBeNullAttribute]
public static string Decrypt(string encryptedValue);
    public static string SetEncryptedString(string value);
    [ExtensionAttribute]
public static void SetEncryptedString(ISettingsTable settingsTable, string settingName, string value);
    public static string GetEncryptedString(string value);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static string GetEncryptedString(ISettingsTable settingsTable, string settingName);
    [ExtensionAttribute]
public static string GetEncryptedString(ISettingsTable settingsTable, string settingName, string defaultValue);
    [ObsoleteAttribute("Slow, use version from ArrayUtil.")]
public static string ToHexString(Byte[] buf);
    [ExtensionAttribute]
public static string SHA1(string input);
    [ExtensionAttribute]
public static string SHA1(Byte[] input);
}
public enum JetBrains.Util.Endianness : Enum {
    public int value__;
    public static Endianness Little;
    public static Endianness Big;
}
public class JetBrains.Util.EndiannessAwareBinaryReader : BinaryReader {
    [CompilerGeneratedAttribute]
private Endianness <Endianness>k__BackingField;
    private Byte[] myBuffer;
    public Endianness Endianness { get; public set; }
    public bool IsBigEndian { get; }
    public EndiannessAwareBinaryReader(Stream input, Endianness endianness);
    public EndiannessAwareBinaryReader(Stream input, Encoding encoding, Endianness endianness);
    public EndiannessAwareBinaryReader(Stream input, Encoding encoding, bool leaveOpen, Endianness endianness);
    [CompilerGeneratedAttribute]
public Endianness get_Endianness();
    [CompilerGeneratedAttribute]
public void set_Endianness(Endianness value);
    public bool get_IsBigEndian();
    private ReadOnlySpan`1<byte> ReadBytesIntoBuffer(int cnt);
    public virtual short ReadInt16();
    public virtual ushort ReadUInt16();
    public virtual int ReadInt32();
    public virtual UInt32 ReadUInt32();
    public virtual long ReadInt64();
    public virtual ulong ReadUInt64();
}
public enum JetBrains.Util.EnsureWritableResult : Enum {
    public int value__;
    public static EnsureWritableResult SUCCESS;
    public static EnsureWritableResult FAILURE;
    public static EnsureWritableResult CHANGES_DETECTED;
    public static EnsureWritableResult CANCELLED;
}
public abstract class JetBrains.Util.EnumPattern : object {
    [NotNullAttribute]
private string myName;
    protected EnumPattern(string name);
    public virtual string ToString();
    public static bool op_Equality(EnumPattern p1, EnumPattern p2);
    public static bool op_Inequality(EnumPattern p1, EnumPattern p2);
    [DebuggerStepThroughAttribute]
public sealed virtual bool Equals(object obj);
    [DebuggerStepThroughAttribute]
public sealed virtual int GetHashCode();
}
[ExtensionAttribute]
public static class JetBrains.Util.EnvironmentVariablesHelper : object {
    [ExtensionAttribute]
public static IDictionary GetEnvironmentVariables(Process process);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class JetBrains.Util.EquatableList`1 : object {
    private IList`1<TItem> myStorage;
    public TItem Item { get; public set; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<TItem>.IsReadOnly { get; }
    public EquatableList`1(IList`1<TItem> storage);
    [MustDisposeResourceAttribute]
private sealed virtual override IEnumerator`1<TItem> System.Collections.Generic.IEnumerable<TItem>.GetEnumerator();
    [MustDisposeResourceAttribute]
private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.Generic.ICollection<TItem>.Add(TItem item);
    private sealed virtual override void System.Collections.Generic.ICollection<TItem>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<TItem>.Remove(TItem item);
    private sealed virtual override void System.Collections.Generic.IList<TItem>.Insert(int index, TItem item);
    private sealed virtual override void System.Collections.Generic.IList<TItem>.RemoveAt(int index);
    public sealed virtual TItem get_Item(int index);
    public sealed virtual void set_Item(int index, TItem value);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<TItem>.get_IsReadOnly();
    private sealed virtual override int System.Collections.Generic.IList<TItem>.IndexOf(TItem item);
    private sealed virtual override bool System.Collections.Generic.ICollection<TItem>.Contains(TItem item);
    private sealed virtual override void System.Collections.Generic.ICollection<TItem>.CopyTo(TItem[] array, int arrayIndex);
    public sealed virtual bool Equals(EquatableList`1<TItem> other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(EquatableList`1<TItem> left, EquatableList`1<TItem> right);
    public static bool op_Inequality(EquatableList`1<TItem> left, EquatableList`1<TItem> right);
}
[ExtensionAttribute]
public static class JetBrains.Util.EventBus.EventBusExtensions : object {
    [ExtensionAttribute]
public static void Fire(IEventContext context, EventId`1<T> eventId, T args);
    [ExtensionAttribute]
public static void Fire(EventId`1<T> eventId, IEventContext context, T args);
    [ExtensionAttribute]
public static void Subscribe(IEventBus bus, Lifetime lifetime, Action`1<TEventArgs> action);
    [ExtensionAttribute]
public static void Subscribe(IEventBus bus, Lifetime lifetime, Action`2<EventId, TEventArgs> action);
    [ExtensionAttribute]
public static void Subscribe(IEventBus bus, Lifetime lifetime, ExecutionMode executionMode, Action`1<TEventArgs> action);
    [ExtensionAttribute]
public static void Subscribe(IEventBus bus, Lifetime lifetime, ExecutionMode executionMode, Action`2<EventId, TEventArgs> action);
    [ExtensionAttribute]
public static void Subscribe(IEventBus bus, Lifetime lifetime, EventId`1<TEventArgs> eventId, Action`1<TEventArgs> action);
    [ExtensionAttribute]
public static void Subscribe(IEventBus bus, Lifetime lifetime, EventId`1<TEventArgs> eventId, Action`2<EventId, TEventArgs> action);
    [ExtensionAttribute]
public static void Subscribe(IEventBus bus, Lifetime lifetime, EventId`1<TEventArgs> eventId, ExecutionMode executionMode, Action`1<TEventArgs> action);
    [ExtensionAttribute]
public static void Subscribe(IEventBus bus, Lifetime lifetime, EventId`1<TEventArgs> eventId, ExecutionMode executionMode, Action`2<EventId, TEventArgs> action);
    [ExtensionAttribute]
public static bool IsSubEventOf(EventId id, EventId parent);
}
public abstract class JetBrains.Util.EventBus.EventId : object {
    protected string myEventName;
    protected EventId myParentEvent;
    public string EventName { get; }
    public EventId ParentEvent { get; }
    internal EventId(string eventName);
    public string get_EventName();
    public EventId get_ParentEvent();
    public bool Equals(EventId other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public abstract virtual Type GetEventArgsType();
    public virtual string ToString();
}
public class JetBrains.Util.EventBus.EventId`1 : EventId {
    public EventId`1(string eventName);
    public EventId`1<TSubEventType> CreateSubEvent(string eventName);
    public virtual Type GetEventArgsType();
    public bool Equals(EventId`1<TEventArgs> other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public abstract class JetBrains.Util.EventBus.Execution.ExecutionMode : object {
    public static ExecutionMode Simple;
    public static ExecutionMode ThreadPool;
    private static ExecutionMode();
    public abstract virtual void Execute(Action`2<EventId, T> action, EventId eventId, T argument);
    public ExecutionMode Grouping(TimeSpan minimumTimespan);
    public ExecutionMode Grouping(TimeSpan minimumTimespan, bool skipFirst);
}
public class JetBrains.Util.EventBus.Execution.FreeThreadedExecutionMode : ExecutionMode {
    public virtual void Execute(Action`2<EventId, T> action, EventId eventId, T argument);
}
public class JetBrains.Util.EventBus.Execution.GroupingExecutionMode : ExecutionMode {
    private object myLock;
    private TimeSpan myMinimumInterval;
    private DateTime myInitialDate;
    private Dictionary`2<EventId, DateTime> myLastExecuted;
    private ExecutionMode myParentExecutionMode;
    public GroupingExecutionMode(ExecutionMode parentExecutionMode, TimeSpan minimumInterval, bool skipFirst);
    public virtual void Execute(Action`2<EventId, T> action, EventId eventId, T argument);
}
public interface JetBrains.Util.EventBus.Execution.IWork {
    public abstract virtual void Execute();
}
public class JetBrains.Util.EventBus.Execution.SimpleExecutionMode : ExecutionMode {
    public virtual void Execute(Action`2<EventId, T> action, EventId eventId, T argument);
}
public class JetBrains.Util.EventBus.Execution.SingleFreeThreadExecutionMode : ExecutionMode {
    private ThreadUtil myThreadUtil;
    public SingleFreeThreadExecutionMode(Lifetime lifetime, string threadName);
    public void EnsureThread(Action action);
    private void Enqueue(Action action);
    public virtual void Execute(Action`2<EventId, T> action, EventId eventId, T argument);
    public bool CheckAccess();
    public void AssertAccess();
}
public class JetBrains.Util.EventBus.Execution.ThreadUtil : object {
    [NotNullAttribute]
private string myName;
    private object myLock;
    private Queue`1<IWork> myQueue;
    private AutoResetEvent myEvent;
    private Thread myThread;
    public ThreadUtil(Lifetime lifetime, string name);
    public bool CheckThread();
    public void Enqueue(IWork work);
    private void ThreadBody();
    public void AssertAccess();
    [CompilerGeneratedAttribute]
private void <.ctor>b__5_0();
    [CompilerGeneratedAttribute]
private void <.ctor>b__5_1();
}
public interface JetBrains.Util.EventBus.IEvent`1 {
    public abstract virtual void Raise(T eventArgs);
}
public interface JetBrains.Util.EventBus.IEventBus {
    public abstract virtual IEventRef`1<T> Event(EventId`1<T> eventId);
    public abstract virtual IEventRef`1<T> Event();
}
public interface JetBrains.Util.EventBus.IEventContext {
    public abstract virtual void Invoke(EventId`1<T> eventId, T args);
    public abstract virtual IEventContext InvokeStartFinish(EventId`1<TStartArgs> startEventId, EventId`1<TFinishArgs> finishEventId, TStartArgs args, Func`1<TFinishArgs> finishArgs);
}
public interface JetBrains.Util.EventBus.IEventRef`1 {
    public abstract virtual void Subscribe(Lifetime lifetime, Action`1<T> handler);
    public abstract virtual void Subscribe(Lifetime lifetime, Action`2<EventId, T> handler);
    public abstract virtual void Subscribe(Lifetime lifetime, ExecutionMode mode, Action`1<T> handler);
    public abstract virtual void Subscribe(Lifetime lifetime, ExecutionMode mode, Action`2<EventId, T> handler);
}
public interface JetBrains.Util.EventBus.IEventSubscription {
    public abstract virtual void Invoke(EventId eventId, object eventArgs);
}
public interface JetBrains.Util.EventBus.IEventSubscription`1 {
    public abstract virtual void Invoke(EventId eventId, T eventArgs);
}
public class JetBrains.Util.EventBus.Impl.EventBusException : Exception {
    public EventBusException(string message);
}
public class JetBrains.Util.EventBus.Impl.EventBusImpl : object {
    private object mySync;
    private Dictionary`2<EventId, List`1<IEventSubscription>> myEventIdToSubscriptions;
    private Dictionary`2<Type, List`1<IEventSubscription>> myArgTypeToSubscriptions;
    public sealed virtual IEventRef`1<T> Event(EventId`1<T> eventId);
    public sealed virtual IEventRef`1<T> Event();
    private List`1<EventId> GetEventIds(EventId`1<T> id);
    private bool IsParentEvent(EventId childEvent, EventId parentEvent);
    private List`1<EventId> GetEventIdsByType();
    private static bool IsMatchByType(Type eventType, Type subscriberType);
    private void AddEventSubscription(EventId eventId, IEventSubscription eventSubscription);
    private void RemoveEventSubscribtion(EventId eventId, IEventSubscription subscription);
    private void InvokeEventNow(EventId eventId, object eventArgs);
    private void RegisterEventInternal(EventId`1<T> eventId);
    public sealed virtual void Invoke(EventId`1<T> eventId, T args);
    private void RegisterEvent(EventId`1<T> eventId);
    public sealed virtual IEventContext InvokeStartFinish(EventId`1<TStartArgs> startEventId, EventId`1<TFinishArgs> finishEventId, TStartArgs args, Func`1<TFinishArgs> finishArgs);
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
private void <Event>b__4_0(IEventSubscription`1<T> s);
    [CompilerGeneratedAttribute]
private void <Event>b__4_1(IEventSubscription`1<T> s);
}
public class JetBrains.Util.EventBus.Impl.EventImpl`1 : object {
    private EventId`1<TEventArgs> myEventId;
    private Action`2<EventImpl`1<TEventArgs>, TEventArgs> myInvoke;
    private bool myIsDisposed;
    public EventId`1<TEventArgs> EventId { get; }
    internal EventImpl`1(EventId`1<TEventArgs> eventId, Action`2<EventImpl`1<TEventArgs>, TEventArgs> invoke);
    [DebuggerStepThroughAttribute]
public EventId`1<TEventArgs> get_EventId();
    public sealed virtual void Raise(TEventArgs eventArgs);
}
public class JetBrains.Util.EventBus.Impl.EventQueueItem : ValueType {
    public EventId EventId;
    public object Args;
    public EventQueueItem(EventId eventId, object args);
}
internal class JetBrains.Util.EventBus.Impl.EventRef`1 : object {
    private Action`1<IEventSubscription`1<TEventArgs>> myAddSubscribtion;
    private Action`1<IEventSubscription`1<TEventArgs>> myRemoveSubscribtion;
    public EventRef`1(Action`1<IEventSubscription`1<TEventArgs>> addSubscribtion, Action`1<IEventSubscription`1<TEventArgs>> removeSubscribtion);
    public sealed virtual void Subscribe(Lifetime lifetime, Action`1<TEventArgs> handler);
    public sealed virtual void Subscribe(Lifetime lifetime, Action`2<EventId, TEventArgs> handler);
    public sealed virtual void Subscribe(Lifetime lifetime, ExecutionMode mode, Action`1<TEventArgs> handler);
    public sealed virtual void Subscribe(Lifetime lifetime, ExecutionMode mode, Action`2<EventId, TEventArgs> handler);
    [CompilerGeneratedAttribute]
private void <Subscribe>b__6_0(EventSubscriptionImpl`1<TEventArgs> impl);
}
public class JetBrains.Util.EventBus.Impl.EventSubContextImpl`1 : object {
    private IEventContext myContext;
    private EventId`1<TEventArgs> myFinishEventId;
    private Func`1<TEventArgs> myFnishArgs;
    public EventSubContextImpl`1(IEventContext context, EventId`1<TEventArgs> finishEventId, Func`1<TEventArgs> fnishArgs);
    public sealed virtual void Dispose();
    public sealed virtual void Invoke(EventId`1<T> eventId, T args);
    public sealed virtual IEventContext InvokeStartFinish(EventId`1<TStartArgs> startEventId, EventId`1<TFinishArgs> finishEventId, TStartArgs args, Func`1<TFinishArgs> finishArgs);
}
public class JetBrains.Util.EventBus.Impl.EventSubscriptionImpl`1 : object {
    private Action`2<EventId, T> myAction;
    private ExecutionMode myExecutionMode;
    private Action`1<EventSubscriptionImpl`1<T>> myDisposed;
    public EventSubscriptionImpl`1(Action`2<EventId, T> action, ExecutionMode executionMode, Action`1<EventSubscriptionImpl`1<T>> disposed);
    [DebuggerStepThroughAttribute]
public sealed virtual void Invoke(EventId eventId, T eventArgs);
    public sealed virtual void Dispose();
    [DebuggerStepThroughAttribute]
private sealed virtual override void JetBrains.Util.EventBus.IEventSubscription.Invoke(EventId eventId, object eventArgs);
}
public interface JetBrains.Util.EventBus.ISubscribtionCookie {
}
public class JetBrains.Util.ExitProcessHandler : MulticastDelegate {
    public ExitProcessHandler(object object, IntPtr method);
    public virtual void Invoke(IPreparedProcess process, int exitCode);
    public virtual IAsyncResult BeginInvoke(IPreparedProcess process, int exitCode, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public static class JetBrains.Util.ExprHelper`1 : object {
    public static PropertyInfo PropertyInfoOf(Expression`1<Func`2<TEntity, TResult>> expr);
    public static MemberInfo InfoOf(Expression`1<Func`2<TEntity, TResult>> expr);
    public static string NameOf(Expression`1<Func`2<TEntity, TResult>> expr);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class JetBrains.Util.Extension.AppDomainEx : object {
    private static ILogger Logger;
    private static AppDomainEx();
    public static AppDomain CreateTemporaryAppDomain(Lifetime lifetime, string basename, JetAppDomainSetup adsetup, Evidence evidence);
    public static void InvokeCtorInAppdomain(AppDomain appdomain, Expression`1<Func`1<T>> exprInvokeCtor);
    public static void WithTemporaryAppDomain(string basename, Action`1<AppDomain> F, JetAppDomainSetup adsetup, Evidence evidence);
    private static string NameFromBaseName(string basename, Nullable`1<JetAppDomainSetup> adsetup);
    private static AppDomain ReflectInvokeCreateDomain(string name, Evidence evidence, JetAppDomainSetup jetsetup);
}
[ExtensionAttribute]
public static class JetBrains.Util.Extension.BinaryReaderWriterEx : object {
    [ExtensionAttribute]
public static void WriteNullableString(BinaryWriter writer, string s);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static string ReadNullableString(BinaryReader reader);
    [ExtensionAttribute]
public static void WriteEnum(BinaryWriter writer, T enumValue);
    [ExtensionAttribute]
public static Nullable`1<T> ReadEnum(BinaryReader reader);
    [ExtensionAttribute]
public static T ReadEnum(BinaryReader reader, T defaultValue);
    [ExtensionAttribute]
public static TCollection ReadCollection(BinaryReader reader, Func`2<int, TCollection> createCollectionFunc, Func`2<BinaryReader, U> readFunc);
    [IteratorStateMachineAttribute("JetBrains.Util.Extension.BinaryReaderWriterEx/<Read>d__6`1")]
[ExtensionAttribute]
public static IEnumerable`1<T> Read(BinaryReader reader, Func`2<BinaryReader, T> readFunc);
    [ExtensionAttribute]
public static void Write(BinaryWriter writer, ICollection`1<T> items, Action`2<BinaryWriter, T> writeAction);
    [ExtensionAttribute]
public static void Write(BinaryWriter writer, FrugalLocalList`1<T> items, Action`2<BinaryWriter, T> writeAction);
    [ExtensionAttribute]
public static void Write(BinaryWriter writer, CompactList`1<T> items, Action`2<BinaryWriter, T> writeAction);
}
[ExtensionAttribute]
public static class JetBrains.Util.Extension.HttpWebRequestEx : object {
    [ExtensionAttribute]
[NotNullAttribute]
public static Task`1<HttpWebResponse> GetHttpResponseAsync(HttpWebRequest request);
}
[ExtensionAttribute]
public static class JetBrains.Util.Extension.JavaCompatibilityStringExtensions : object {
    [ExtensionAttribute]
public static string ToRegistryValue(string javaName);
    [ExtensionAttribute]
public static string FromRegistryValue(string windowsName);
}
[ExtensionAttribute]
public static class JetBrains.Util.Extension.ReflectionExtensions : object {
    [ExtensionAttribute]
[CanBeNullAttribute]
public static TAttribute GetAttribute(Enum enumValue);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static ICustomAttributeProvider GetAttributeProvider(Enum enumValue);
}
[ExtensionAttribute]
public static class JetBrains.Util.Extension.ServiceProviderExtensions : object {
    [ExtensionAttribute]
[NotNullAttribute]
public static TService GetService(IServiceProvider serviceProvider);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static TService TryGetService(IServiceProvider serviceProvider);
    [ExtensionAttribute]
public static bool TryGetService(IServiceProvider provider, T& service);
    [ExtensionAttribute]
public static void AddService(IServiceProvider serviceProvider, TService service);
}
[ExtensionAttribute]
public static class JetBrains.Util.Extension.StreamReaderEx : object {
    [IteratorStateMachineAttribute("JetBrains.Util.Extension.StreamReaderEx/<SelectManyLines>d__0")]
[ExtensionAttribute]
[NotNullAttribute]
public static IEnumerable`1<string> SelectManyLines(StreamReader thіs);
}
[ExtensionAttribute]
public static class JetBrains.Util.Extension.StringExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
public static String[] Split(string value, String[] separator);
    [ExtensionAttribute]
public static StringSlice Slice(string s, int start, int length);
    [ExtensionAttribute]
public static StringSlicesEnumerable Split(string source, char separator);
    [ExtensionAttribute]
public static StringSlicesEnumerable Split(string source, char separator, StringSplitOptions options);
    [ExtensionAttribute]
public static StringSlicesEnumerable Split(string source, Char[] separator);
    [ExtensionAttribute]
public static StringSlicesEnumerable Split(string source, Char[] separator, StringSplitOptions options);
    [ExtensionAttribute]
[PureAttribute]
public static bool Contains(string original, string value, StringComparison comparisonType);
    [ExtensionAttribute]
[PureAttribute]
public static string SubstringBefore(string original, string value);
    [ExtensionAttribute]
[PureAttribute]
public static string SubstringBefore(string original, string value, StringComparison comparisonType);
    [ExtensionAttribute]
[PureAttribute]
public static string SubstringBefore(string original, String[] values, StringComparison comparisonType);
    [ExtensionAttribute]
[PureAttribute]
public static string SubstringBeforeLast(string original, string value);
    [ExtensionAttribute]
[PureAttribute]
public static string SubstringBeforeLast(string original, string value, StringComparison comparisonType);
    [ExtensionAttribute]
private static string SubstringBefore(string original, int index);
    [ExtensionAttribute]
[PureAttribute]
public static string SubstringAfter(string original, string value);
    [ExtensionAttribute]
[PureAttribute]
public static string SubstringAfter(string original, string value, StringComparison comparisonType);
    [ExtensionAttribute]
[PureAttribute]
public static string SubstringAfterLast(string original, string value);
    [ExtensionAttribute]
[PureAttribute]
public static string SubstringAfterLast(string original, string value, StringComparison comparisonType);
    [ExtensionAttribute]
private static string SubstringAfter(string original, int index, int length);
    [ExtensionAttribute]
[PureAttribute]
public static string RemoveStart(string original, string prefix);
    [ExtensionAttribute]
[PureAttribute]
public static string RemoveStart(string original, string prefix, StringComparison comparison);
    [ExtensionAttribute]
[PureAttribute]
public static string RemoveEnd(string original, string suffix);
    [ExtensionAttribute]
[PureAttribute]
public static string RemoveEnd(string original, string suffix, StringComparison comparison);
    [ExtensionAttribute]
[PureAttribute]
public static string FormatWith(string formatString, Object[] args);
    [ExtensionAttribute]
[PureAttribute]
public static string ToBase64(string text);
    [ExtensionAttribute]
[PureAttribute]
public static string FromBase64(string text);
    [ExtensionAttribute]
[PureAttribute]
public static string Truncate(string value, int maxLength, string truncationSuffix);
}
[ExtensionAttribute]
public static class JetBrains.Util.Extension.StringXorExtensions : object {
    private static string DefaultSecret;
    private static Byte[] XorBytes(Byte[] str, Byte[] secret);
    [ExtensionAttribute]
public static string XorEncode(string str, string secret);
    [ExtensionAttribute]
public static string XorDecode(string base64String, string secret);
}
[ExtensionAttribute]
public static class JetBrains.Util.Extension.ZipEntryEx : object {
    public static int UnixFileAttributesShift;
    [ExtensionAttribute]
[NotNullAttribute]
public static ImmutableFileItem AsFileItem(ZipEntry entry, Lifetime lifetime, ZipFile file);
    [ExtensionAttribute]
[NotNullAttribute]
public static ImmutableByteStream GetImmutableStream(ZipEntry entry, Lifetime lifetime, ZipFile file);
    [ExtensionAttribute]
public static void SetUnixFileAttributes(ZipEntry entry, UnixFileModes mode, UnixFileModes type);
    [ExtensionAttribute]
public static int UnixFileAttributes(ZipEntry entry);
}
public static class JetBrains.Util.ExternalProcess.ExternalProcess : object {
    private static string ProcessUpEventName;
    private static string AbortProcessEventName;
    public static EventWaitHandle CreateProcessUpEvent(string instanceName);
    public static EventWaitHandle CreateAbortUpEvent(string instanceName);
}
[ExtensionAttribute]
public static class JetBrains.Util.FEx : object {
    [ExtensionAttribute]
public static Func`1<TY> Beta(Func`2<TX, TY> func, TX value);
    [ExtensionAttribute]
public static Func`1<TY> Beta(Func`2<TX, TY> FToBeta, Func`1<TX> FGetValue);
    [ExtensionAttribute]
public static Func`2<TY, TResult> Beta(Func`3<TX, TY, TResult> func, TX value);
    [ExtensionAttribute]
public static Func`2<TX, TResult> Beta(Func`3<TX, TY, TResult> func, TY value);
    [ExtensionAttribute]
public static Func`2<TX, TResult> BetaX(Func`4<TX, TY, TZ, TResult> func, TY y, TZ z);
    [ExtensionAttribute]
public static Action`2<TY, TZ> BetaX(Action`3<TX, TY, TZ> func, TX x);
    [ExtensionAttribute]
public static Action`1<TY> BetaX(Action`2<TX, TY> func, TX x);
    [ExtensionAttribute]
public static Action`1<TZ> BetaXY(Action`3<TX, TY, TZ> func, TX x, TY y);
    [ExtensionAttribute]
public static Action`1<TY> BetaXZ(Action`3<TX, TY, TZ> func, TX x, TZ z);
    [ExtensionAttribute]
public static Func`2<TY, TResult> BetaY(Func`4<TX, TY, TZ, TResult> func, TX x, TZ z);
    [ExtensionAttribute]
public static Action`2<TX, TZ> BetaY(Action`3<TX, TY, TZ> func, TY y);
    [ExtensionAttribute]
public static Action`1<TX> BetaY(Action`2<TX, TY> func, TY y);
    [ExtensionAttribute]
public static Action`1<TX> BetaYZ(Action`3<TX, TY, TZ> func, TY y, TZ z);
    [ExtensionAttribute]
public static Func`2<TZ, TResult> BetaZ(Func`4<TX, TY, TZ, TResult> func, TX x, TY y);
    [ExtensionAttribute]
public static Action`2<TX, TY> BetaZ(Action`3<TX, TY, TZ> func, TZ z);
    public static T Return(Action`1<Func`2<Func`1<T>, Action>> FOuter);
}
public class JetBrains.Util.FilePersistence.SafeFileThrowAwayAccess : object {
    [NotNullAttribute]
private FileSystemPath myOwnerDirectory;
    [NotNullAttribute]
private FileSystemPath myFileName;
    public SafeFileThrowAwayAccess(FileSystemPath fileName);
    public void SaveStream(Action`1<Stream> write);
    public bool LoadStream(Action`1<Stream> read);
    public void Save(Action`1<BinaryWriter> write);
    public bool Load(Action`1<BinaryReader> read);
    private void SafeSafe(Action write);
    private bool SafeLoad(Action read);
    public void DeleteFile();
    [CompilerGeneratedAttribute]
private void <DeleteFile>b__9_0();
}
public class JetBrains.Util.FileSystemPathTrie`1 : QualifiedNamesTrieBase`2<T, VirtualFileSystemPath> {
    [ObsoleteAttribute("Use FileSystemDefinition.PathStringSliceEquality for pathes instead of relying on bool flag")]
public FileSystemPathTrie`1(bool ignoreCase);
    public FileSystemPathTrie`1(IEqualityComparer`1<StringSlice> comparer);
    public bool Contains(VirtualFileSystemPath fsp);
    public IList`1<T> GetChildrenData(VirtualFileSystemPath fsp);
    public IList`1<T> GetSubTreeData(VirtualFileSystemPath fsp);
    public List`1<T> FindAndProcessAllPrefixes(VirtualFileSystemPath fsp);
    public bool Remove(VirtualFileSystemPath fsp);
    protected virtual string GetDelimeter(IInteractionContext context);
    protected virtual char GetDelimeterChar(IInteractionContext context);
    protected bool IsContextNode(TrieEntry<T, VirtualFileSystemPath> entry, IInteractionContext& virtualPathContext);
    protected virtual bool IsEmpty(VirtualFileSystemPath qualifiedName);
    public virtual bool GetNextSlice(VirtualFileSystemPath qualifiedName, int startIndex, StringSlice& slice, Int32& nextPos);
    protected virtual Node<T, VirtualFileSystemPath> FindParentNode(VirtualFileSystemPath qualifiedName, String& childName);
}
public class JetBrains.Util.FilteringEnumerator`1 : object {
    private IEnumerator`1<T> myBaseEnumerator;
    private Predicate`1<T> myPredicate;
    private T myCurrent;
    private T System.Collections.Generic.IEnumerator<T>.Current { get; }
    public object Current { get; }
    public FilteringEnumerator`1(IEnumerator`1<T> baseEnumerator, Predicate`1<T> predicate);
    private sealed virtual override T System.Collections.Generic.IEnumerator<T>.get_Current();
    public sealed virtual void Dispose();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
    public sealed virtual object get_Current();
}
public class JetBrains.Util.FolderContentCache : object {
    public VirtualFileSystemPath FolderPath;
    private ConcurrentDictionary`2<VirtualFileSystemPath, Existence> myExistence;
    private ConcurrentDictionary`2<VirtualFileSystemPath, List`1<VirtualFileSystemPath>> myChildDirectories;
    public FolderContentCache(VirtualFileSystemPath folderPath);
    public void Clear();
    public IList`1<VirtualFileSystemPath> GetChildDirectories(VirtualFileSystemPath folderPath);
    public Existence Exists(VirtualFileSystemPath path);
    public bool FileExists(VirtualFileSystemPath path);
    public bool DirectoryExists(VirtualFileSystemPath path);
}
public static class JetBrains.Util.Formats.AsmConfigFile : object {
    [NotNullAttribute]
public static XmlNamespaceManager CreateNamespaceManager(XmlDocument xmlDoc);
    public static void EnsureConfigFileElements(XmlDocument xmlDoc);
    [NotNullAttribute]
public static XmlElement GetAssemblyBindingVersionlessElement(XmlDocument xmlConfig);
    [NotNullAttribute]
public static string MakeFileUriStringForAppConfigCodebaseHref(FileSystemPath path);
    [NotNullAttribute]
public static ImmutableByteStream GenerateConfigurationFile(IEnumerable`1<AssemblyBindingRedirections> policies);
}
public static class JetBrains.Util.FormattingHelpers : object {
    public static char GetNumericListSeparator(IFormatProvider provider);
}
public static class JetBrains.Util.Frameworks.FrameworkDetectionUtils : object {
    public static string MscorlibDllName;
    public static string MSBuildExeName;
    private static string WCFServiceModel;
    private static BackSlashSeparatedRelativePath ourRegistryPathNDP;
    private static BackSlashSeparatedRelativePath ourRegistryPathFramework;
    private static string Framework64;
    private static string Framework32;
    private static FrameworkDetectionUtils();
    public static VirtualFileSystemPath GetInstallRoot(IInteractionContext context, KeyAccessRights keyAccessRights);
    private static UInt32 GetDwordValue(IInteractionContext context, BackSlashSeparatedRelativePath path, string keyName, KeyAccessRights keyAccessRights);
    [CanBeNullAttribute]
public static VirtualFileSystemPath FindDotNetFrameworkPath(IInteractionContext interactionContext, string prefix, string requiredFile);
    public static VirtualFileSystemPath GetPathToDotNetFrameworkV20(IInteractionContext interactionContext);
    [CanBeNullAttribute]
public static Version ExtractExactVersion(string name);
    public static VirtualFileSystemPath GetPathToDotNetFrameworkV30(IInteractionContext interactionContext);
    public static VirtualFileSystemPath GetPathToDotNetFrameworkV35(IInteractionContext interactionContext);
    public static VirtualFileSystemPath GetPathToDotNetFrameworkV4X(IInteractionContext interactionContext);
    private static VirtualFileSystemPath GetSecondaryPath(VirtualFileSystemPath path);
    public static VirtualFileSystemPath GetSecondaryPathToDotNetFrameworkV20(IInteractionContext context);
    public static VirtualFileSystemPath GetSecondaryPathToDotNetFrameworkV30(IInteractionContext context);
    public static VirtualFileSystemPath GetSecondaryPathToDotNetFrameworkV35(IInteractionContext context);
    public static VirtualFileSystemPath GetSecondaryPathToDotNetFrameworkV4X(IInteractionContext context);
    [CanBeNullAttribute]
public static string TryGetDotNetFrameworkVersionString(IInteractionContext interactionContext);
    public static UInt32 GetDotNetFrameworkReleaseNumber(IInteractionContext interactionContext);
    public static Version GetDotNetFrameworkVersionByReleaseNumber(UInt32 dwRelease);
    [NotNullAttribute]
public static string GetDotNetFrameworkVersionAndReleaseString(IInteractionContext context);
}
internal class JetBrains.Util.Frameworks.FrameworkRegistryData : object {
    private static IList`1<FrameworkRegistryData> ourFrameworks;
    [CompilerGeneratedAttribute]
private Version <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<UInt32> <Release>k__BackingField;
    private static BackSlashSeparatedRelativePath ourRegistryPathNDP;
    private static Tuple`2[] ourAnchorVersionsOfdotNet4;
    public static IList`1<FrameworkRegistryData> Frameworks { get; }
    public Version Version { get; }
    public Nullable`1<UInt32> Release { get; }
    public FrameworkRegistryData(Version version, Nullable`1<UInt32> release);
    private static FrameworkRegistryData();
    public static IList`1<FrameworkRegistryData> get_Frameworks();
    [NotNullAttribute]
public static IEnumerable`1<FrameworkRegistryData> EnumerateInstalledNetFrameworksRegistryData(KeyAccessRights keyAccessRights);
    [CompilerGeneratedAttribute]
public Version get_Version();
    [CompilerGeneratedAttribute]
public Nullable`1<UInt32> get_Release();
    public sealed virtual bool Equals(FrameworkRegistryData other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [CanBeNullAttribute]
private static Version ExtractMajorMinorVersion(string name);
    [CanBeNullAttribute]
private static Version ExtractExactVersion(string name);
    public Version MarketingVersion();
    [CompilerGeneratedAttribute]
private bool <MarketingVersion>b__17_0(Tuple`2<int, Version> x);
}
public static class JetBrains.Util.GcUtil : object {
    private static IDisposable CreateSuppressGcCookie();
}
public static class JetBrains.Util.GenericIComparableCache : object {
    private static MethodInfo ComparerHelperMethodGenericDefinition;
    private static Func`2<Type, Type[]> myFGetComparableSpecializations;
    private static Func`2<Type, CompareToDelegate> myFGetInvocation;
    [ThreadStaticAttribute]
private static IDictionary`2<Type, Type[]> myComparableSpecializations;
    [ThreadStaticAttribute]
private static IDictionary`2<Type, CompareToDelegate> myCompareInvocationsCache;
    private static GenericIComparableCache();
    public static Nullable`1<int> TryCompare(object ɑ, object β);
    [NotNullAttribute]
private static ICollection`1<Type> GetComparableSpecializations(Type type);
    [NotNullAttribute]
private static CompareToDelegate GetInvocation(Type type);
    private static int InvokeCompareTo(object comparable, object other);
}
public class JetBrains.Util.HashedPair`2 : ValueType {
    public T1 First;
    public T2 Second;
    private int myHashCode;
    [NotNullAttribute]
public static IEqualityComparer`1<HashedPair`2<T1, T2>> EqualityComparer;
    [NotNullAttribute]
public static IComparer`1<HashedPair`2<T1, T2>> Comparer;
    [DebuggerStepThroughAttribute]
public HashedPair`2(T1 first, T2 second);
    public HashedPair`2(T1 first, T2 second, Func`3<T1, T2, int> getHashCodeFunc);
    private static HashedPair`2();
    [PureAttribute]
[DebuggerStepThroughAttribute]
public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(HashedPair`2<T1, T2> other);
    public sealed virtual int CompareTo(HashedPair`2<T1, T2> other);
    [PureAttribute]
[DebuggerStepThroughAttribute]
public HashedPair`2<T2, T1> Reverse();
    public virtual string ToString();
}
public interface JetBrains.Util.IAsyncUndoRedo {
    [GuardAttribute("1")]
public abstract virtual void Undo();
    [GuardAttribute("1")]
public abstract virtual void Redo();
}
public static class JetBrains.Util.Icons.Emitters.GeometryHelpers : object {
    public static ArcInCenterCoordinates ArcPathToCenterCoordinates(ArcInPathCoordinates arc, bool isFallbackImpossibleArcs);
    public static BézierCubicCurve[] ArcToBézierCurves(ArcInCenterCoordinates arc);
    public static JetRect BézierCurveBoundingBox(BézierCubicCurve& curve);
    public static BézierCubicCurve BézierElevateDegreeQuadraticToCubic(BézierQuadraticCurve& quadratic);
    public static Nullable`1<BézierQuadraticCurve> BézierTryDecreaseDegreeCubicToQuadratic(BézierCubicCurve cubic);
    [NotNullAttribute]
public static BézierCubicCurve[] RoundRectToBézierCurvesForCorners(JetRect rect, JetSize radii);
    public static BézierCubicCurve SmallArcToBézierCurve(ArcInCenterCoordinates arc);
    private static double DegToRad(double deg);
    private static double RadToDeg(double rad);
}
[ExtensionAttribute]
[NoReorderAttribute]
public static class JetBrains.Util.Icons.Emitters.SvgCssGrammar : object {
    public static Parser`1<string> Property;
    public static Parser`1<int> UnaryOperator;
    public static Parser`1<string> Hexcolor;
    public static Parser`1<DimWithSign> TermDim;
    public static Parser`1<string> TermNonDim;
    public static Parser`1<object> Term;
    public static Parser`1<char> Operator;
    public static Parser`1<object> Expr;
    public static Parser`1<ParsedDeclaration> Declaration;
    public static Parser`1<ICollection`1<ParsedDeclaration>> InlineRuleset;
    private static SvgCssGrammar();
    [ExtensionAttribute]
public static Parser`1<T> ThenS(Parser`1<T> main);
}
public static class JetBrains.Util.Icons.Emitters.SvgFile : object {
}
[NoReorderAttribute]
public static class JetBrains.Util.Icons.Emitters.SvgGrammar : object {
    public static Parser`1<char> Wsp;
    private static Parser`1<IOption`1<IEnumerable`1<char>>> WspStar;
    public static Parser`1<char> Digit;
    public static Parser`1<string> DigitSequence;
    public static Parser`1<string> Sign;
    public static Parser`1<string> Exponent;
    public static Parser`1<string> FractionalConstant;
    public static Parser`1<string> FloatingPointConstant;
    public static Parser`1<string> IntegerConstant;
    public static Parser`1<char> Comma;
    public static Parser`1<char> CommaWsp;
    public static Parser`1<bool> Flag;
    public static Parser`1<double> Number;
    public static Parser`1<double> NonnegativeNumber;
    public static Parser`1<double> Coordinate;
    public static Parser`1<JetPoint> CoordinatePair;
    public static Parser`1<S> EllipticalArcArgument;
    public static Parser`1<ICollection`1<S>> EllipticalArc;
    public static Parser`1<ICollection`1<S>> VerticalLineto;
    public static Parser`1<ICollection`1<S>> HorizontalLineto;
    public static Parser`1<ICollection`1<S>> Moveto;
    public static Parser`1<ICollection`1<S>> Lineto;
    public static Parser`1<S> CurvetoArgument;
    public static Parser`1<ICollection`1<S>> Curveto;
    public static Parser`1<S> SmoothCurvetoArgument;
    public static Parser`1<ICollection`1<S>> SmoothCurveto;
    public static Parser`1<S> QuadraticBezierCurvetoArgument;
    public static Parser`1<ICollection`1<S>> QuadraticBezierCurveto;
    public static Parser`1<S> SmoothQuadraticBezierCurvetoArgument;
    public static Parser`1<ICollection`1<S>> SmoothQuadraticBezierCurveto;
    public static Parser`1<SZ> Closepath;
    public static Parser`1<ICollection`1<S>> DrawtoCommand;
    public static Parser`1<ICollection`1<S>> DrawtoCommands;
    public static Parser`1<ICollection`1<S>> MovetoDrawtoCommandGroup;
    public static Parser`1<ICollection`1<S>> MovetoDrawtoCommandGroups;
    public static Parser`1<ICollection`1<S>> SvgPath;
    public static Parser`1<ICollection`1<JetPoint>> CoordinatePairs;
    public static Parser`1<ICollection`1<JetPoint>> ListOfPoints;
    public static Parser`1<string> BdtName;
    public static Parser`1<byte> BdtHexDigit;
    public static Parser`1<JetRgbaColor> BdtColorRgb;
    public static Parser`1<JetRgbaColor> BdtColorArgb;
    public static Parser`1<JetRgbaColor> BdtColorRrggbb;
    public static Parser`1<JetRgbaColor> BdtColorAarrggbb;
    public static Parser`1<JetRgbaColor> BdtColor;
    public static Parser`1<string> BdtFuncIri;
    public static Parser`1<Nullable`1<ColorOrIri>> Paint;
    public static Parser`1<JetMatrix> Matrix;
    public static Parser`1<JetMatrix> Translate;
    public static Parser`1<JetMatrix> Scale;
    public static Parser`1<JetMatrix> Rotate;
    public static Parser`1<JetMatrix> SkewX;
    public static Parser`1<JetMatrix> SkewY;
    public static Parser`1<JetMatrix> Transform;
    public static Parser`1<JetMatrix> Transforms;
    public static Parser`1<JetMatrix> TransformList;
    public static Parser`1<JetRect> ViewBox;
    private static SvgGrammar();
    private static Parser`1<ICollection`1<TItem>> ParseCommand(char ch, Parser`1<TItem> ParseItem);
    private static Parser`1<ICollection`1<TItem>> CommaWspSequence(Parser`1<TItem> ParseItem);
    public static ImmutableArray`1<TiSegment> ParsePolygonPointsToSegments(string sPolygonPoints, OnError onerror);
    public static ImmutableArray`1<TiSegment> ParsePathDataToSegments(string sPathData, OnError onerror);
    [NotNullAttribute]
private static S[] SvgPathCommandsApplyImplicitConversions(IResult`1<ICollection`1<S>> parsed);
    private static JetMatrix CombineTransforms(JetMatrix& first, IOption`1<IEnumerable`1<JetMatrix>> tail);
}
public static class JetBrains.Util.Icons.IconPlaceholder : object {
    public static int DefaultSizeDim;
    private static TiVectorImage myIconPlaceholderTi;
    [NotNullAttribute]
public static TiVectorImage IconPlaceholderTi { get; }
    private static IconPlaceholder();
    public static TiVectorImage get_IconPlaceholderTi();
}
public static class JetBrains.Util.Icons.Serializers.TiImageSerializerCsexp : object {
    private static string BrushLinear;
    private static string BrushNull;
    private static string BrushRadial;
    private static string BrushSolid;
    private static string ImageKindRaster;
    private static string ImageKindVector;
    private static string MainHeader;
    private static string V1;
    private static TiImageSerializerCsexp();
    public static void Serialize(TiImage tiimage, Stream stream);
    [NotNullAttribute]
public static TiImage Serialize(Stream stream);
    public static void Serialize(CsexpArchive ar, TiImage& value);
    private static TiSegmentKind SegmentKindFromCode(string code);
    [NotNullAttribute]
private static string SegmentKindToCode(TiSegmentKind kind);
    private static void Serialize(CsexpArchive ar, TiPath& tiPath);
    private static void Serialize(CsexpArchive ar, TiSegment& tiSegment);
    private static void Serialize(CsexpArchive ar, TiBrush& value);
    private static void SerializeBody(CsexpArchive ar, TiVectorImage& value);
    private static void SerializeBody(CsexpArchive ar, TiRasterImage& value);
    private static void SerializeBody(CsexpArchive ar, TiSolidColorBrush& tisolid);
    private static void SerializeBody(CsexpArchive ar, TiLinearGradientBrush& tilinear);
    private static void SerializeBody(CsexpArchive ar, TiRadialGradientBrush& tiradial);
    private static void SerializeBody(CsexpArchive ar, TiGradientStop& tistop);
}
public static class JetBrains.Util.Icons.Serializers.TiImageSerializerSvg : object {
    [NotNullAttribute]
public static TiImage Parse(string text, OnError onerror);
    [NotNullAttribute]
public static TiImage Parse(ReadOnlySpan`1<char> text, OnError onerror);
    [NotNullAttribute]
public static string ToString(TiImage tiimage, OnError onerror);
}
public static class JetBrains.Util.Icons.Serializers.TiImageSerializerSvgExperimental : object {
    [NotNullAttribute]
[ObsoleteAttribute("Incomplete. Use Parse().")]
public static TiImage Serialize(Stream stream, OnError onerror);
    [NotNullAttribute]
[ObsoleteAttribute("Does not roundtrip, use TiImageSerializerSvg::ToString().")]
public static string ToString(TiImage tiimage, OnError onerror);
    [NotNullAttribute]
[ObsoleteAttribute("Does not roundtrip, use ToString().")]
public static XDocument Serialize(TiImage tiimage, OnError onerror);
    private static XElement SerializeBody(TiRasterImage tiraster, OnError onerror);
    private static XElement SerializeBody(TiVectorImage tivector, OnError onerror);
    private static XElement SerializeBodyPolymorphic(TiImage tiimage, OnError onerror);
    private static void SerializeStops(TiGradientBrush tiLinear, XElement xeParent);
    private static void SetColor(JetRgbaColor color, XElement xe, Attribute attrColor, Attribute attrOpacity);
    [CompilerGeneratedAttribute]
internal static string <SerializeBody>g__FGetName|4_0(XElement xeIdentity, <>c__DisplayClass4_0& );
}
internal static class JetBrains.Util.Icons.Serializers.TiSvgV1StringReader : object {
    private static TiVectorImage FakeImage;
    private static TiSvgV1StringReader();
    public static TiImage ReadRoot(UInt16* pch, OnError onerror);
    private static UInt32 PeekChar(UInt32 lookahead, Context ctx);
    [MustUseReturnValueAttribute]
private static bool Read(char sample, Context ctx);
    [MustUseReturnValueAttribute]
private static bool Read(string sample, Context ctx);
    private static void Read_Error(char sample, Context ctx, UInt32 ch);
    private static void Read_ReportError(string sample, Context ctx, UInt16* pchPos);
    private static TiImage ReadBodyRaster(JetSize sizeLogical, Context ctx);
    private static TiImage ReadBodyVector(JetSize sizeLogical, Context ctx);
    private static bool ReadDouble(Context ctx, Double& value);
    private static void ReadDouble_ErrorFormat(Context ctx, UInt32 nLen);
    private static void ReadDouble_ErrorZeroLen(Context ctx);
    private static bool ReadGradientStops(Context ctx, FrugalLocalList`1& stops);
    private static bool ReadId(Context ctx, StringRange& value);
    private static void ReadId_ZeroLen(Context ctx, StringRange& value, UInt16* pch);
    private static Nullable`1<ImmutableArray`1<TiSegment>> ReadPathData(Context ctx, bool isPathFillRuleNonZero);
    private static bool ReadRgb(Context ctx, JetRgbaColor& color);
    private static void ReadRgb_ErrorHash(Context ctx);
    private static void ReadRgb_ErrorHex(Context ctx);
    private static TiImage ReadRoot(Context ctx);
    private static bool ReadStringTill(ushort chTill, Context ctx, String& s);
    private static void ReadStringTill_Error(ushort chTill, Context ctx);
    [CompilerGeneratedAttribute]
internal static TiImage <ReadBodyVector>g__AssembleImage|8_0(<>c__DisplayClass8_0& );
}
internal static class JetBrains.Util.Icons.Serializers.TiSvgV1StringWriter : object {
    public static string MakeRasterImageDataUri(TiRasterImage tiraster);
    public static string WriteRoot(TiImage tiimage, OnError onerror);
    private static void WriteAttribute(StringBuilder sb, string name, double value);
    private static void WriteAttribute(StringBuilder sb, Attribute name, double value);
    private static void WriteAttribute(StringBuilder sb, Attribute name, string value);
    private static void WriteAttribute(StringBuilder sb, string name, string value);
    private static void WriteAttributeNs(StringBuilder sb, string nsprefix, string name, string value);
    private static void WriteBodyRaster(TiRasterImage tiraster, StringBuilder sb, OnError onerror);
    private static void WriteBodyVector(TiVectorImage tivector, StringBuilder sb, OnError onerror);
    private static void WriteGradientStops(TiGradientBrush tiLinear, StringBuilder sb);
}
public abstract class JetBrains.Util.Icons.TiBrush : object {
    public abstract virtual void AssertValid(string sOrigin, UInt32 nOriginIndex, OnError onerror);
}
public abstract class JetBrains.Util.Icons.TiGradientBrush : TiBrush {
    public FrugalLocalList`1<TiGradientStop> Stops;
    protected TiGradientBrush(FrugalLocalList`1& stops);
    public virtual void AssertValid(string sOrigin, UInt32 nOriginIndex, OnError onerror);
    protected bool Equals(TiGradientBrush other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[IsReadOnlyAttribute]
public class JetBrains.Util.Icons.TiGradientStop : ValueType {
    public JetRgbaColor Color;
    public float Offset;
    public TiGradientStop(JetRgbaColor color, float offset);
    [PureAttribute]
private sealed virtual override bool System.IEquatable<JetBrains.Util.Icons.TiGradientStop>.Equals(TiGradientStop other);
    [PureAttribute]
public bool Equals(TiGradientStop& other);
    [PureAttribute]
public virtual bool Equals(object obj);
    [PureAttribute]
public virtual int GetHashCode();
    [PureAttribute]
public static bool op_Equality(TiGradientStop& left, TiGradientStop& right);
    [PureAttribute]
public static bool op_Inequality(TiGradientStop& left, TiGradientStop& right);
    public virtual string ToString();
}
public abstract class JetBrains.Util.Icons.TiImage : object {
    public abstract virtual JetSize GetLogicalSize();
    public virtual string ToString();
}
public static class JetBrains.Util.Icons.TiImageComparer : object {
    public static double Epsilon;
    private static TiImageComparer();
    public static bool DeepEquals(TiImage a, TiImage b);
    private static bool DeepEqualsPath(TiPath a, TiPath b);
    private static bool DeepEqualsPathSegment(TiSegment a, TiSegment b);
    private static bool DeepEqualsRaster(TiRasterImage a, TiRasterImage b);
    private static bool DeepEqualsVector(TiVectorImage a, TiVectorImage b);
    private static bool DeepEqualsBrush(TiBrush a, TiBrush b);
}
public static class JetBrains.Util.Icons.TiImageConverter : object {
    public static bool OptionCheckTiBoundBoxCalculation;
    private static TiImageConverter();
    [NotNullAttribute]
[PureAttribute]
public static TiImage FromCanonicalSExpression(Byte[] data);
    [NotNullAttribute]
[PureAttribute]
public static TiImage FromCanonicalSExpression(UInt32[] data);
    [NotNullAttribute]
[PureAttribute]
public static TiImage FromCanonicalSExpressionAsciiString(string text);
    [NotNullAttribute]
[PureAttribute]
public static TiImage FromTiSvg(string text);
    [NotNullAttribute]
[PureAttribute]
public static string ToTiSvg(TiImage tiimage, OnError onerror);
    [NotNullAttribute]
public static TiRasterImage FromNativeBitmap(JetSize sizeLogical, Byte[] bmpbuffer);
    public static Byte[] ToNativeBitmap(TiRasterImage tiraster);
}
public class JetBrains.Util.Icons.TiLinearGradientBrush : TiGradientBrush {
    public JetPoint EndPoint;
    public JetPoint StartPoint;
    public TiLinearGradientBrush(FrugalLocalList`1& stops, JetPoint& startPoint, JetPoint& endPoint);
    public virtual void AssertValid(string sOrigin, UInt32 nOriginIndex, OnError onerror);
    private bool Equals(TiLinearGradientBrush other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class JetBrains.Util.Icons.TiNullBrush : TiBrush {
    public static TiNullBrush Instance;
    private static TiNullBrush();
    public virtual void AssertValid(string sOrigin, UInt32 nOriginIndex, OnError onerror);
}
[IsReadOnlyAttribute]
public class JetBrains.Util.Icons.TiPath : ValueType {
    [NotNullAttribute]
public TiBrush Fill;
    public ImmutableArray`1<TiSegment> Segments;
    public TiPath(TiBrush fill, ImmutableArray`1<TiSegment> segments);
    public void AssertValid(string sPathOrigin, UInt32 nPathIndex, OnError onerror);
    public JetRect CalculateBounds();
    public static TiPath FromRect(JetRect rect, TiBrush fill);
    public static TiPath FromRoundedRect(JetRect rect, JetSize radii, TiBrush fill);
    public bool Equals(TiPath other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class JetBrains.Util.Icons.TiRadialGradientBrush : TiGradientBrush {
    public JetPoint Start;
    public JetMatrix Transform;
    public TiRadialGradientBrush(FrugalLocalList`1& stops, JetPoint& start, JetMatrix& transform);
    public virtual void AssertValid(string sOrigin, UInt32 nOriginIndex, OnError onerror);
    private bool Equals(TiRadialGradientBrush other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class JetBrains.Util.Icons.TiRasterImage : TiImage {
    public ushort DeviceHeight;
    public ushort DeviceWidth;
    public DpiResolution Dpi;
    public ImmutableArray`1<JetRgbaColor> Pixels;
    public TiRasterImage(ushort width, ushort height, ImmutableArray`1<JetRgbaColor> pixels, DpiResolution dpi);
    public virtual JetSize GetLogicalSize();
}
[IsReadOnlyAttribute]
public class JetBrains.Util.Icons.TiSegment : ValueType {
    public JetPoint Target;
    public JetPoint Ctrl1;
    public JetPoint Ctrl2;
    public TiSegmentKind Kind;
    public TiSegment(TiSegmentKind kind, JetPoint ctrl1, JetPoint ctrl2, JetPoint target);
    public void Deconstruct(TiSegmentKind& kind, JetPoint& ctrl1, JetPoint& ctrl2, JetPoint& target);
    public static TiSegment BézierTo(JetPoint ctrl1, JetPoint ctrl2, JetPoint next);
    public static TiSegment LineTo(JetPoint point);
    public static TiSegment BeginFigure(JetPoint startpoint, bool isFillRuleNonzero, bool isFigureClosed);
    private sealed virtual override bool System.IEquatable<JetBrains.Util.Icons.TiSegment>.Equals(TiSegment other);
    [PureAttribute]
public bool Equals(TiSegment& other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [PureAttribute]
public static bool op_Equality(TiSegment& left, TiSegment& right);
    [PureAttribute]
public static bool op_Inequality(TiSegment& left, TiSegment& right);
    [PureAttribute]
public bool IsFigureClosed();
    [PureAttribute]
public bool IsFillRuleNonzero();
    [PureAttribute]
public virtual string ToString();
    public void AssertValid(string sPathOrigin, UInt32 nPathIndex, UInt32 nSegmentIndex, OnError onerror);
    [PureAttribute]
public static JetRect CalculateBounds(IList`1<TiSegment> segments);
    public static TiSegment Transform(TiSegment& tiseg, JetMatrix transform);
}
public enum JetBrains.Util.Icons.TiSegmentKind : Enum {
    public ushort value__;
    public static TiSegmentKind BeginFigure;
    public static TiSegmentKind LineTo;
    public static TiSegmentKind BézierTo;
}
public class JetBrains.Util.Icons.TiSolidColorBrush : TiBrush {
    public JetRgbaColor Color;
    public TiSolidColorBrush(JetRgbaColor color);
    public virtual void AssertValid(string sOrigin, UInt32 nOriginIndex, OnError onerror);
    private bool Equals(TiSolidColorBrush other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class JetBrains.Util.Icons.TiVectorImage : TiImage {
    public JetSize LogicalSize;
    public ImmutableArray`1<TiPath> Paths;
    public TiVectorImage(JetSize logicalSize, ImmutableArray`1<TiPath> paths);
    public void AssertValid(OnError onerror);
    public virtual JetSize GetLogicalSize();
}
public class JetBrains.Util.IdsMap`1 : object {
    private CompactMap`2<TItem, UInt32> myIdsMap;
    private CompactMap`2<UInt32, TItem> myItemsMap;
    private UInt32 myLastId;
    private int myIdBits;
    [CompilerGeneratedAttribute]
private BitsIncreasedHandler OnIdBitsIncreased;
    public int IdBits { get; }
    public int Count { get; }
    public IdsMap`1(UInt32 minId, int expectedFilesCount);
    [CompilerGeneratedAttribute]
public void add_OnIdBitsIncreased(BitsIncreasedHandler value);
    [CompilerGeneratedAttribute]
public void remove_OnIdBitsIncreased(BitsIncreasedHandler value);
    public int get_IdBits();
    public int get_Count();
    public TItem GetItemById(UInt32 id);
    public UInt32 GetIdByItem(TItem item);
    public bool HasId(TItem item);
}
public interface JetBrains.Util.IDynamicHandler {
    public abstract virtual object Invoke(MethodInfo method, Object[] parameters);
}
[NullableContextAttribute("1")]
[DefaultMemberAttribute("Item")]
public interface JetBrains.Util.IEquatableList`1 {
    public TItem Item { get; }
    public int Count { get; }
    public abstract virtual TItem get_Item(int index);
    public abstract virtual int get_Count();
}
[AttributeUsageAttribute("396")]
public class JetBrains.Util.ImmutableAttribute : Attribute {
}
[ExtensionAttribute]
public static class JetBrains.Util.IndentedTextWriterEx : object {
    [ExtensionAttribute]
public static LocalDisposable`1<IndentedTextWriter> Indent(IndentedTextWriter indentedTextWriter);
}
public class JetBrains.Util.IndexComparer`1 : object {
    private IList`1<T> myList;
    public IndexComparer`1(IList`1<T> list);
    public IndexComparer`1(T[] array);
    public sealed virtual int Compare(T x, T y);
}
[ExtensionAttribute]
public static class JetBrains.Util.Int32Util : object {
    [ExtensionAttribute]
[NotNullAttribute]
public static T[] Times(int count, Func`2<int, T> generator);
}
public class JetBrains.Util.InternalErrorException : ApplicationException {
    private string myClassName;
    public InternalErrorException(string details);
    public InternalErrorException(string format, Object[] args);
    protected InternalErrorException(SerializationInfo info, StreamingContext context);
    public virtual string ToString();
    private string GetClassName();
}
public static class JetBrains.Util.Interop.ClrHelpers : object {
    private static string ProfileOptimizationDirName;
    private static string ProfileOptimizationScenario;
    private static ClrHelpers();
    public static void EnableMultithreadedJit();
}
public static class JetBrains.Util.Interop.Com : object {
    public static TInterface QueryInteface(object comobj);
    public static TInterface QueryInteface(Void* punk);
    [NotNullAttribute]
public static Void* UnknownAddRef(object comobj);
    public static void UnknownRelease(Void* punk);
    public static ReleaseToken UsingReference(Void** punk);
}
[IsReadOnlyAttribute]
[ValueSerializerAttribute("JetBrains.Util.Interop.DpiResolution/DpiResolutionSerializer")]
public class JetBrains.Util.Interop.DpiResolution : ValueType {
    private double myDpiX;
    private double myDpiY;
    public static DpiResolution DeviceIndependent96Dpi;
    public static DpiResolution NotSure;
    public static int DeviceIndependent96DpiValue;
    public double DpiX { get; }
    public double DpiY { get; }
    public DpiResolution(double dpiX, double dpiY);
    private static DpiResolution();
    public double get_DpiX();
    public double get_DpiY();
    public static bool op_Equality(DpiResolution left, DpiResolution right);
    public static bool op_Inequality(DpiResolution left, DpiResolution right);
    public static DpiResolution op_Addition(DpiResolution black, DpiResolution white);
    public static DpiResolution op_Subtraction(DpiResolution black, DpiResolution white);
    public static DpiResolution op_Multiply(DpiResolution dpi, double factor);
    public static DpiResolution op_Division(DpiResolution dpi, double factor);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public sealed virtual bool Equals(DpiResolution other);
    private sealed virtual override int System.IComparable<JetBrains.Util.Interop.DpiResolution>.CompareTo(DpiResolution other);
}
public static class JetBrains.Util.Interop.DpiResolutionEx : object {
    [PureAttribute]
public static double FromDeviceToDeviceIndependentLength(int length, double dpi);
    [PureAttribute]
public static double FromDeviceToDeviceIndependentLength(double length, double dpi);
}
[ObsoleteAttribute("Use DpiUtil from Shell.")]
public static class JetBrains.Util.Interop.DpiUtilObsoleteNonInteractive : object {
    private static Nullable`1<DpiResolution> ourBootTimeScreenDpi;
    [ObsoleteAttribute("Use DpiUtil::BootTimeStaticDpi.")]
public static DpiResolution GetBootTimeScreenDpi();
}
public class JetBrains.Util.Interop.ErrorLevelException : ApplicationException {
    private UInt32 myErrorlevel;
    public HResults ErrorlevelHresult { get; }
    public int ErrorlevelInt { get; }
    public UInt32 ErrorlevelUint { get; }
    public bool IsComFailed { get; }
    public bool IsComSucceeded { get; }
    public bool IsNonZero { get; }
    public bool IsZero { get; }
    public ErrorLevelException(int errorlevel);
    public ErrorLevelException(UInt32 errorlevel);
    public ErrorLevelException(HResults errorlevel);
    protected ErrorLevelException(SerializationInfo info, StreamingContext context);
    public HResults get_ErrorlevelHresult();
    public int get_ErrorlevelInt();
    public UInt32 get_ErrorlevelUint();
    public bool get_IsComFailed();
    public bool get_IsComSucceeded();
    public bool get_IsNonZero();
    public bool get_IsZero();
    public static string FormatErrorIntsAndNames(UInt32 errorlevel);
    public static string FormatErrorMessageIntsAndNames(int errorlevel);
    public static string FormatErrorMessageIntsAndNames(HResults hr);
    public static string FormatErrorMessageIntsAndNames(WinError winerror);
    public static string FormatErrorMessageIntsAndNames(UInt32 errorlevel);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public static void ThrowIfComFailed(int errorlevel);
    public static void ThrowIfComFailed(UInt32 errorlevel);
    public static void ThrowIfComFailed(HResults errorlevel);
    public static void ThrowIfNonZero(int errorlevel);
    public static void ThrowIfNonZero(UInt32 errorlevel);
    public static void ThrowIfNonZero(HResults errorlevel);
    private static void IntsAndNamesCore(UInt32 errorlevel, StringBuilder sb);
}
public class JetBrains.Util.Interop.FixedBuffer : object {
    private bool bInFinalizationQueue;
    private IntPtr myBufferAddress;
    private int myBufferLength;
    private string myOriginatingStackTrace;
    public IntPtr Address { get; }
    public bool IsAllocated { get; }
    public int Length { get; }
    public FixedBuffer(int nLengthToAllocateInBytes);
    public IntPtr get_Address();
    public bool get_IsAllocated();
    public int get_Length();
    public void Allocate(int nLengthInBytes);
    public sealed virtual void Dispose();
}
internal interface JetBrains.Util.Interop.IDllLoader {
    public abstract virtual IntPtr LoadLibrary(FileSystemPath absoluteDllPath);
    public abstract virtual void FreeLibrary(IntPtr handle);
    public abstract virtual IntPtr GetProcAddress(IntPtr handle, string methodName);
    public abstract virtual bool IsLoaded(FileSystemPath absoluteDllPath);
}
public static class JetBrains.Util.Interop.ImportAddressTableHook : object {
    private static int IterationLimit;
    private static List`1<Delegate> myDelegateReferences;
    private static ImportAddressTableHook();
    public static void Install(string sFuncMod, string sFuncName, Void* hCallingMod, Delegate pNewFunction);
    public static void Install(string sFuncMod, string sFuncName, string sCallingMod, Delegate pNewFunction);
    public static void InstallCore(string sFuncMod, string sFuncName, Void* hCallingMod, string sCallingMod, Delegate pNewFunction);
    private static void AssertNoWin32Error();
    private static void DelegateAddRef(Delegate function);
}
public class JetBrains.Util.Interop.JavaPropertiesFile : Dictionary`2<string, string> {
    public void Load(Stream stream);
    public void Load(TextReader reader);
    private void Load0(LineReader lineReader);
    private string loadConvert(Char[] array, int i, int num, Char[] array2);
}
[ExtensionAttribute]
public static class JetBrains.Util.Interop.LpwstrHelper : object {
    [ExtensionAttribute]
[NotNullAttribute]
public static string GetString(GetLpcwstrDelegate2Safe func, string faultmsg, bool treatAsNullTerminated);
    [ExtensionAttribute]
[NotNullAttribute]
public static string GetString(GetLpcwstrDelegate2Safe func, int startIndex, int length, string faultmsg, bool treatAsNullTerminated);
    [ExtensionAttribute]
[NotNullAttribute]
public static string GetString(GetLpcwstrDelegate2SafeShort func, string faultmsg, bool treatAsNullTerminated);
    [ExtensionAttribute]
[NotNullAttribute]
public static string GetString(GetLpcwstrDelegate2 func, string faultmsg, bool treatAsNullTerminated);
    [NotNullAttribute]
public static string GetString(GetLpcwstrDelegate func, string faultmsg, bool treatAsNullTerminated);
    private static string GetString(GetLpcwstrDelegate func, Nullable`1<ValueTuple`2<int, int>> range, string faultmsg, bool treatAsNullTerminated);
    private static string NormalizeString(UInt16* pBuffer, UInt32 actualLength, bool treatAsNullTerminated);
}
public class JetBrains.Util.Interop.NativeDll : object {
    [NotNullAttribute]
public Void* Handle;
    [NotNullAttribute]
internal NativeDllKey Key;
    [NotNullAttribute]
private IDllLoader DllLoader;
    [NotNullAttribute]
internal FileSystemPath File;
    private Dictionary`2<string, Delegate> myMethods;
    internal NativeDll(Void* handle, NativeDllKey key, FileSystemPath file, IDllLoader dllLoader);
    [NotNullAttribute]
public TDelegate ImportMethod(string methodName);
    [NotNullAttribute]
public IntPtr GetFunctionPointer(string methodName);
    [NotNullAttribute]
public ComObject CreateComObject(Guid guidClsid);
    [NotNullAttribute]
public ComObject CreateComObject();
}
internal class JetBrains.Util.Interop.NativeDllKey : object {
    public bool Debug;
    [NotNullAttribute]
public IPath Path;
    public NativeDllKey(IPath path, bool debug);
    public sealed virtual bool Equals(NativeDllKey other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public static class JetBrains.Util.Interop.NativeDllsLoader : object {
    private static FileSystemPath ourDllDirectory;
    private static FileSystemPath ourDebugDllDirectory;
    private static Dictionary`2<NativeDllKey, NativeDll> ourLoadedDlls;
    private static IDllLoader ourDllLoader;
    private static string WindowsDynamicLibrarySuffix;
    private static string LinuxDynamicLibrarySuffix;
    private static string MacOsDynamicLibrarySuffix;
    private static List`1<string> DynamicLibrariesSuffixes;
    private static NativeDllsLoader();
    [NotNullAttribute]
public static NativeDll LoadDll(Lifetime lifetime, RelativePath relativePathWithoutSuffix, Options options);
    [NotNullAttribute]
public static NativeDll LoadDll(Lifetime lifetime, RelativePath relativePathWithoutSuffix, FileSystemPath root, Options options);
    public static FileSystemPath GetDllPath(RelativePath relativePath, bool debug);
    public static FileSystemPath GetDllPath(RelativePath relativePath, FileSystemPath root, bool debug);
    private static NativeDll LoadDllCore(Lifetime lifetime, RelativePath relativePathWithoutSuffix, Options options, Func`2<bool, FileSystemPath> rootPathProvider);
    private static NativeDll LoadDllCore(Lifetime lifetime, NativeDllKey key, IPath pathForDiagnostics, FileSystemPath file);
    [NotNullAttribute]
public static NativeDll LoadDllExact(Lifetime lifetime, FileSystemPath pathExact);
    private static RelativePath StripExistingDynamicLibrarySuffix(RelativePath relativePath);
    private static RelativePath AddDynamicLibrarySuffix(RelativePath relativePath);
    private static string GetSuffix();
    [NotNullAttribute]
private static FileSystemPath GetDllDirectory(bool debug);
    [NotNullAttribute]
private static FileSystemPath GetDllDirectory(FileSystemPath root, bool debug);
}
public static class JetBrains.Util.Interop.OsVersionUtil : object {
    [ObsoleteAttribute("This has not been updated to Win10. As this change might affect behavior of existing code, I'm not doing it yet. Lift the Obsolete mark whenif you update it.")]
public static Windows GetWindowsVersion();
    [NotNullAttribute]
public static OperatingSystem GetEnvironmentOsVersionNonVirtualized();
}
public static class JetBrains.Util.Interop.ShellLinkHelper : object {
    [NotNullAttribute]
public static string ExtensionNoDot;
    [NotNullAttribute]
public static string ExtensionWithDot;
    private static ShellLinkHelper();
    public static void CreateLink(FileSystemPath pathLnkFile, FileSystemPath pathLinkTarget);
    [NotNullAttribute]
public static IShellLinkW CreateShellLinkComObject();
    [NotNullAttribute]
public static FileSystemPath ResolveLinkTarget(FileSystemPath pathLnk);
}
internal class JetBrains.Util.Interop.UnixDllLoader : object {
    private static int RTLD_NOW;
    private static int RTLD_NOLOAD;
    private static UnixDllLoader();
    public sealed virtual IntPtr LoadLibrary(FileSystemPath absoluteDllPath);
    public sealed virtual void FreeLibrary(IntPtr handle);
    public sealed virtual IntPtr GetProcAddress(IntPtr handle, string methodName);
    public sealed virtual bool IsLoaded(FileSystemPath absoluteDllPath);
    private static void ThrowError(string message);
    private static void ResetLastError();
    private static IntPtr dlopen(string fileName, int flags);
    private static IntPtr dlsym(IntPtr handle, string symbol);
    private static int dlclose(IntPtr handle);
    private static IntPtr dlerror();
}
internal class JetBrains.Util.Interop.WindowsDllLoader : object {
    public sealed virtual IntPtr LoadLibrary(FileSystemPath absoluteDllPath);
    public sealed virtual void FreeLibrary(IntPtr handle);
    public sealed virtual IntPtr GetProcAddress(IntPtr handle, string methodName);
    public sealed virtual bool IsLoaded(FileSystemPath absoluteDllPath);
}
public static class JetBrains.Util.InvokeChildProcess : object {
    private static Regex RegexOriginCategoryCodeTextExpression;
    public static TimeSpan TimeoutChildProcess;
    private static InvokeChildProcess();
    public static UInt32 InvokeChildProcessIntoLogger(FileSystemPath target, CommandLineBuilderJet cmdline, LoggingLevel levelDefault, Nullable`1<TimeSpan> timeout, TreatStderr treatStderr, FileSystemPath dirCurrent, IEnumerable`1<KeyValuePair`2<string, string>> environmentVariables, Nullable`1<ProcessPriorityClass> priorityClass);
    public static UInt32 InvokeChildProcessIntoStdout(FileSystemPath target, CommandLineBuilderJet cmdline, Nullable`1<TimeSpan> timeout, TreatStderr treatStderr, bool forceHighLevel, FileSystemPath dirCurrent, IEnumerable`1<KeyValuePair`2<string, string>> environmentVariables, Nullable`1<ProcessPriorityClass> priorityClass);
    public static Task`1<UInt32> InvokeCore(OuterLifetime lifetime, StartInfo startinfo, SyncAsync syncasync, ILogger maybeLogger);
    public static Task`1<UInt32> InvokeCore_Managed(OuterLifetime lifetime, StartInfo startinfo, SyncAsync syncasync, ILogger maybeLogger);
    public static UInt32 InvokeSync(FileSystemPath target, CommandLineBuilderJet cmdline, PipeStreams pipe, Nullable`1<TimeSpan> timeout, FileSystemPath dirCurrent, IEnumerable`1<KeyValuePair`2<string, string>> environmentVariables, Nullable`1<ProcessPriorityClass> priorityClass, ILogger logger);
    [NotNullAttribute]
public static Process InvokeCore_Managed_CreateProcess(Lifetime lifetime, StartInfo startinfo, ILogger logger);
    public static Task`1<UInt32> InvokeCore_Managed(OuterLifetime lifeOuter, SyncAsync syncasync, Func`3<LifetimeDefinition, ILogger, Process> FCreateProcess, Nullable`1<TimeSpan> maybeTimeout, ILogger logger);
    public static Task`1<UInt32> InvokeCore_Native(OuterLifetime lifeOuter, StartInfo startinfo, SyncAsync syncasync, ILogger logger);
    private static void InvokeCore_Native_JobObject(Lifetime lifetime, PROCESS_INFORMATION* pProcessInfo, bool ignoreJobErrors, ILogger logger);
    [NotNullAttribute]
[HandleProcessCorruptedStateExceptionsAttribute]
private static IList`1<ProcessIdHandleName> InvokeCore_Native_JobObject_ListProcesses(Lifetime lifeTerminating, Void* hJob, Action`2<Exception, string> FLogErrorOrWarning, OnError onErrorOrWarn);
    private static void InvokeCore_Native_PumpStream(Lifetime lifeCp, Void* hFile, PipeStreams pipestreams, bool isErrNotOut, ILogger logger);
}
public static class JetBrains.Util.IO.DirectoryAcl : object {
    public static DirectorySecurity GetAccessControl(FileSystemPath path);
    public static DirectorySecurity GetAccessControl(FileSystemPath path, AccessControlSections sections);
    public static void SetAccessControl(FileSystemPath path, DirectorySecurity directorySecurity);
}
public static class JetBrains.Util.IO.FileAcl : object {
    public static FileSecurity GetAccessControl(FileSystemPath path);
    public static FileSecurity GetAccessControl(FileSystemPath path, AccessControlSections sections);
    public static void SetAccessControl(FileSystemPath path, FileSecurity fileSecurity);
}
public static class JetBrains.Util.IOUtil : object {
    private static HashSet`1<string> ourReservedDosNames;
    private static IOUtil();
    [ContractAnnotationAttribute("null=>false")]
public static bool IsValidPath(string path);
    public static bool IsSystemReservedName(string name);
}
public interface JetBrains.Util.IPairEnumerator`2 {
    public TKey CurrentKey { get; }
    public TValue CurrentValue { get; }
    public abstract virtual TKey get_CurrentKey();
    public abstract virtual TValue get_CurrentValue();
}
public interface JetBrains.Util.IPreparedProcess {
    public int ProcessId { get; }
    public int ExitCode { get; }
    public string ProcessName { get; }
    public string ProcessArgs { get; }
    public bool IsRunning { get; }
    [CompilerGeneratedAttribute]
public abstract virtual void add_Exited(ExitProcessHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Exited(ExitProcessHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_OutputLineRead(LineReadHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_OutputLineRead(LineReadHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_ErrorLineRead(LineReadHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ErrorLineRead(LineReadHandler value);
    public abstract virtual int get_ProcessId();
    public abstract virtual int get_ExitCode();
    public abstract virtual string get_ProcessName();
    public abstract virtual string get_ProcessArgs();
    public abstract virtual bool get_IsRunning();
    public abstract virtual void Start();
    public abstract virtual bool WaitForExit(Nullable`1<TimeSpan> timeout);
    public abstract virtual void Kill();
}
public interface JetBrains.Util.IPresentableStructureElement {
    public object PresentationObject { get; }
    public abstract virtual object get_PresentationObject();
}
public enum JetBrains.Util.IsDisposedState : Enum {
    public int value__;
    public static IsDisposedState Live;
    public static IsDisposedState Disposing;
    public static IsDisposedState Disposed;
}
public interface JetBrains.Util.ITransactionCookie {
    [NullableContextAttribute("1")]
public abstract virtual TransactionCommitResult Commit(IProgressIndicator progressIndicator);
    public abstract virtual void Rollback();
}
public interface JetBrains.Util.IWorkingDirectory {
    [NotNullAttribute]
public FileSystemPath Path { get; }
    public abstract virtual FileSystemPath get_Path();
}
public static class JetBrains.Util.JetPredicate`1 : object {
    [NotNullAttribute]
public static Predicate`1<T> True;
    [NotNullAttribute]
public static Predicate`1<T> False;
    private static JetPredicate`1();
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Util.JetReadOnlyList`1 : object {
    private IList`1<T> myList;
    public int Count { get; }
    public T Item { get; public set; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    public JetReadOnlyList`1(IList`1<T> list);
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual int get_Count();
    public sealed virtual JetReadonlyListEnumerator`1<T> GetEnumerator();
    [MustDisposeResourceAttribute]
private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    public sealed virtual int IndexOf(T item);
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    [MustDisposeResourceAttribute]
private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.Remove(T item);
    private sealed virtual override void System.Collections.Generic.IList<T>.Insert(int index, T item);
    private sealed virtual override void System.Collections.Generic.IList<T>.RemoveAt(int index);
}
[ValueSerializerAttribute("JetBrains.Util.JetSemanticVersion/JetSemanticVersionSerializer")]
[TypeConverterAttribute("JetBrains.Util.JetSemanticVersion/JetSemanticVersionConverter")]
public class JetBrains.Util.JetSemanticVersion : object {
    public static JetSemanticVersion Empty;
    private static Regex ourSemanticVersionRegex;
    private static Regex ourRegexPrereleaseMetadata;
    private static Regex ourRegexBuildMetadata;
    [CanBeNullAttribute]
private string myOriginalString;
    [NotNullAttribute]
private Version myVersion;
    [CompilerGeneratedAttribute]
private string <PrereleaseMetadata>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BuildMetadata>k__BackingField;
    public bool IsVersionNumberOnly { get; }
    public int Major { get; }
    public int Minor { get; }
    public int Patch { get; }
    public int LegacyRevision { get; }
    public string PrereleaseMetadata { get; private set; }
    public string BuildMetadata { get; private set; }
    private JetSemanticVersion(string originalString, Version version, string prerelease, string build);
    public JetSemanticVersion(UInt32 major, UInt32 minor, UInt32 build, UInt32 revision, string prereleasemeta, string buildmeta);
    public JetSemanticVersion(int major, int minor, int build, int revision, string prereleasemeta, string buildmeta);
    public JetSemanticVersion(Version version, string prerelease, string build);
    private static JetSemanticVersion();
    public static bool TryParse(string versionString, JetSemanticVersion& semanticVersion);
    [NotNullAttribute]
public static JetSemanticVersion Parse(string versionString);
    [ContractAnnotationAttribute("version:null => null; notnull => notnull")]
public static JetSemanticVersion FromVersion4(Version version);
    public Version ToVersion4Lossy();
    public Version2 ToVersion2Lossy();
    public Version ToVersion4Exact();
    public bool get_IsVersionNumberOnly();
    public int get_Major();
    public int get_Minor();
    public int get_Patch();
    public int get_LegacyRevision();
    [CompilerGeneratedAttribute]
public string get_PrereleaseMetadata();
    [CompilerGeneratedAttribute]
private void set_PrereleaseMetadata(string value);
    [CompilerGeneratedAttribute]
public string get_BuildMetadata();
    [CompilerGeneratedAttribute]
private void set_BuildMetadata(string value);
    public sealed virtual int CompareTo(object other);
    public sealed virtual int CompareTo(JetSemanticVersion other);
    private static int ComparePrereleaseMetadata(string prereleaseMetadata, string otherPrereleaseMetadata);
    private static int CompareIdentifier(string identifier, string otherIdentifier);
    public sealed virtual bool Equals(JetSemanticVersion other);
    private bool VersionEquals(Version a, Version b);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public string ToNormalizedString();
    public static bool op_Equality(JetSemanticVersion version1, JetSemanticVersion version2);
    public static bool op_Inequality(JetSemanticVersion version1, JetSemanticVersion version2);
    public static bool op_LessThan(JetSemanticVersion version1, JetSemanticVersion version2);
    public static bool op_GreaterThan(JetSemanticVersion version1, JetSemanticVersion version2);
    public static bool op_LessThanOrEqual(JetSemanticVersion version1, JetSemanticVersion version2);
    public static bool op_GreaterThanOrEqual(JetSemanticVersion version1, JetSemanticVersion version2);
    [ContractAnnotationAttribute("value:null => null; notnull => notnull")]
public static string op_Explicit(JetSemanticVersion value);
    [ContractAnnotationAttribute("value:null => null; notnull => notnull")]
public static JetSemanticVersion op_Explicit(string value);
    [ContractAnnotationAttribute("value:null => null; notnull => notnull")]
public static JetSemanticVersion op_Explicit(Version value);
}
public class JetBrains.Util.LineReadHandler : MulticastDelegate {
    public LineReadHandler(object object, IntPtr method);
    public virtual void Invoke(string line);
    public virtual IAsyncResult BeginInvoke(string line, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[ExtensionAttribute]
public static class JetBrains.Util.ListUtil : object {
    public static List`1<T> SubtractSortedInplace(List`1<T> minuend, List`1<T> subtrahend);
    public static string ToSortedString(ICollection`1<T> list);
    [ExtensionAttribute]
public static TValue ValueOrDefault(IDictionary`2<TKey, TValue> dictionary, TKey key);
    [ExtensionAttribute]
public static void Insert(IList`1<TItem> thіs, Lifetime lifetime, int index, TItem item);
    [ExtensionAttribute]
public static void Insert(IList thіs, Lifetime lifetime, int index, object item);
    [ExtensionAttribute]
public static void Move(IList thіs, int oldIndex, int newIndex, int count);
    [ExtensionAttribute]
public static void Shuffle(IList`1<TElement> list, Random rnd);
}
[ObsoleteAttribute("Use Name property from System.ComponentModel.DataAnnotations.DisplayAttribute that is localizable out of the box. Note that LocalizedDescription isn't used as description but a display name, i.e. shown in directly in UI and not in tooltips or accompanying text. See JetBrains.Application.UI.Controls.EnumDescriptionCache.Presentation")]
public class JetBrains.Util.LocalizedDescriptionAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <DescriptionResourceType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DescriptionResourceName>k__BackingField;
    public string Description { get; }
    public Type DescriptionResourceType { get; public set; }
    public string DescriptionResourceName { get; public set; }
    public LocalizedDescriptionAttribute(string description);
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
public Type get_DescriptionResourceType();
    [CompilerGeneratedAttribute]
public void set_DescriptionResourceType(Type value);
    [CompilerGeneratedAttribute]
public string get_DescriptionResourceName();
    [CompilerGeneratedAttribute]
public void set_DescriptionResourceName(string value);
}
public class JetBrains.Util.LocalUserDataHolder : ValueType {
    [CanBeNullAttribute]
private UserDataHolder myHolder;
    public sealed virtual void PutData(Key`1<T> key, T value);
    public sealed virtual T GetData(Key`1<T> key);
    public sealed virtual T GetOrCreateDataUnderLock(Key`1<T> key, Func`1<T> factory);
    public sealed virtual T GetOrCreateDataUnderLock(Key`1<T> key, TState state, Func`2<TState, T> factory);
    public sealed virtual IEnumerable`1<KeyValuePair`2<object, object>> EnumerateData();
    private UserDataHolder EnsureHolder();
}
public class JetBrains.Util.LocateFileUtil : object {
    private static Lazy`1<Tuple`2<string, string>> ourLinuxFileManagerApp;
    [CanBeNullAttribute]
public static string LinuxFileManagerName { get; }
    private static LocateFileUtil();
    public static void OpenFile(FileSystemPath file);
    public static void OpenFile(string filePath);
    public static void LocateFile(FileSystemPath file);
    private static void LocateFileOnLinux(FileSystemPath file);
    private static void LocateFileOnWindows(FileSystemPath file);
    private static void LocateFileOnMacOs(FileSystemPath file);
    public static string get_LinuxFileManagerName();
}
public static class JetBrains.Util.Logging.LoggingHelpers : object {
    [ObsoleteAttribute("Use the new overload without the tasker parameter.")]
public static Task`1<TResult> WithLoggingProgressMessagesAsync(OuterLifetime lifetime, string sTaskDisplayName, ITaskHost tasker, ILogger logger, Func`1<Task`1<TResult>> λWork, Func`1<string> λProgressMessage);
    [ObsoleteAttribute("Use the new overload without the tasker parameter.")]
public static Task`1<TResult> WithLoggingProgressMessagesAsync2(OuterLifetime lifetime, string sTaskDisplayName, ITaskHost tasker, ILogger logger, LoggingLevel loglevel, Func`1<Task`1<TResult>> λWork, Func`1<string> λProgressMessageExtra, Nullable`1<TimeSpan> timeoutFirstProgressReport, Nullable`1<TimeSpan> timeoutPeriodicProgressReport);
    [AsyncStateMachineAttribute("JetBrains.Util.Logging.LoggingHelpers/<WithLoggingProgressMessagesAsync3>d__2`1")]
public static Task`1<TResult> WithLoggingProgressMessagesAsync3(OuterLifetime lifetime, string sTaskDisplayName, ILogger logger, LoggingLevel loglevel, Func`1<Task`1<TResult>> λWork, Func`1<string> λProgressMessageExtra, Nullable`1<TimeSpan> timeoutFirstProgressReport, Nullable`1<TimeSpan> timeoutPeriodicProgressReport);
}
public static class JetBrains.Util.LogUtil : object {
    [NotNullAttribute]
public static string GetUserFriendlyShortName(object obj);
}
public static class JetBrains.Util.Mac.IOSUsbCommunication : object {
    private static ILogger ourLogger;
    private static IOSUsbCommunication();
    private static int USBMuxConnectByPort(int connectionId, short iPhonePort, Int32* outHandle);
    private static int AMDeviceGetConnectionID(Void* device);
    private static int AMDeviceNotificationSubscribe(DeviceCallbackDelegate callback, int u0, int u1, int u2, Void** u3);
    private static IntPtr AMDeviceCopyDeviceIdentifier(Void* device);
    private static void CFRunLoopRun();
    private static void CFRunLoopStop(IntPtr loopRef);
    private static IntPtr CFRunLoopGetCurrent();
    private static int write(int fd, Byte* buf, int count);
    private static int read(int fd, Byte* buf, int nbyte);
    private static string CfStringToString(IntPtr intPtr);
    public static Stream GetHandle(int port, string targetUdid, long waitTimeoutMillis);
    private static void DiscardLoop(Boolean& initialized);
}
public enum JetBrains.Util.MbButton : Enum {
    public UInt32 value__;
    public static MbButton MB_OK;
    public static MbButton MB_OKCANCEL;
    public static MbButton MB_ABORTRETRYIGNORE;
    public static MbButton MB_YESNOCANCEL;
    public static MbButton MB_YESNO;
    public static MbButton MB_RETRYCANCEL;
    public static MbButton MB_CANCELTRYCONTINUE;
}
public enum JetBrains.Util.MbIcon : Enum {
    public UInt32 value__;
    public static MbIcon MB_ICONHAND;
    public static MbIcon MB_ICONQUESTION;
    public static MbIcon MB_ICONEXCLAMATION;
    public static MbIcon MB_ICONASTERISK;
}
public class JetBrains.Util.Media.ColorAdjustment : object {
    private HumanPerceptibleColor myColor;
    private bool IsLight { get; }
    public ColorAdjustment(JetRgbaColor color);
    public ColorAdjustment Shade(double offset);
    public ColorAdjustment Lighter(double offset);
    public ColorAdjustment Darker(double offset);
    public ColorAdjustment Brightness(double brightness);
    public ColorAdjustment Brightness(JetRgbaColor brightness);
    public ColorAdjustment Lightest();
    public ColorAdjustment Darkest();
    public ColorAdjustment Saturate(double offset);
    public ColorAdjustment Desaturate(double offset);
    public ColorAdjustment Saturation(double saturation);
    public ColorAdjustment Saturation(JetRgbaColor saturation);
    public ColorAdjustment Tingle(double offset);
    public ColorAdjustment Tint(double hue);
    public ColorAdjustment Tint(JetRgbaColor hue);
    public ColorAdjustment Fade(double offset);
    public ColorAdjustment Opacity(double opacity);
    public ColorAdjustment Accent(JetRgbaColor accent, double strange);
    public ColorAdjustment Admix(JetRgbaColor other, double strange, bool affectAlpha);
    private static double Clamp(double value, double from, double to);
    private static bool IsInRange(double value, double from, double to, bool inclusive);
    private static void VerifyInRange(double value, double from, double to, bool inclusive);
    private bool get_IsLight();
    public static JetRgbaColor op_Implicit(ColorAdjustment adjustment);
    public JetRgbaColor ToColor();
    public HumanPerceptibleColor ToHumanPerceptibleColor();
}
[ExtensionAttribute]
public static class JetBrains.Util.Media.ColorAdjustmentExtensions : object {
    [ExtensionAttribute]
public static ColorAdjustment Adjust(JetRgbaColor color);
}
public static class JetBrains.Util.Media.ColorManagement : object {
    private static byte c_nMaxHLS;
    private static byte c_nMaxRGB;
    private static byte c_nUndefinedHue;
    public static float LumaRed;
    public static float LumaGreen;
    public static float LumaBlue;
    public static byte MaxHLS { get; }
    public static byte MaxRGB { get; }
    public static byte UndefinedHue { get; }
    private static ColorManagement();
    public static byte get_MaxHLS();
    public static byte get_MaxRGB();
    public static byte get_UndefinedHue();
    public static void RGBtoHLS(UInt32 lRGBColor, Byte& H, Byte& L, Byte& S);
    public static ushort HueToRGB(ushort n1, ushort n2, ushort hue);
    public static void HLStoRGB(ushort H, ushort L, ushort S, Byte& R, Byte& G, Byte& B);
    public static JetRgbaColor HLStoRGB(ushort H, ushort L, ushort S);
    public static UInt32 HLStoBGR(ushort hue, ushort lum, ushort sat);
    public static UInt32 Mix(UInt32 colorA, UInt32 colorB, double fA);
    public static JetRgbaColor Mix(JetRgbaColor colorA, JetRgbaColor colorB, double proportion);
    public static UInt32 RGB2BGR(UInt32 color);
    public static UInt32 BlendTwo(UInt32 rgbA, UInt32 rgbB);
    public static JetRgbaColor GetAlphaBlendedColor(JetRgbaColor src, JetRgbaColor dest, int alpha);
    public static byte GetRValue(UInt32 RGB);
    public static byte GetGValue(UInt32 RGB);
    public static byte GetBValue(UInt32 RGB);
    public static UInt32 RGB(byte R, byte G, byte B);
    public static UInt32 RGBA(byte A, byte R, byte G, byte B);
    public static UInt32 RGB(JetRgbaColor color);
    public static UInt32 BGR(JetRgbaColor color);
    public static byte ConstrainHls(int value);
    public static JetRgbaColor GetContrastedForeground(JetRgbaColor background, JetRgbaColor foreground, double contrast, double margin, double whiteBalance);
    private static JetRgbaColor RangeColor(JetRgbaColor source, int rangeStart, int rangeEnd, int grayValue);
    public static JetRgbaColor MakeMonochrome(JetRgbaColor colorSrc, JetRgbaColor colorBias);
    public static JetRgbaColor MakeSimilarColor(JetRgbaColor color, JetRgbaColor pattern, double threshold, double offset);
    public static JetRgbaColor AdjustForeground(JetRgbaColor baseColor, Nullable`1<JetRgbaColor> background, Nullable`1<JetRgbaColor> foreground);
    public static JetRgbaColor Invert(JetRgbaColor color);
    public static JetRgbaColor GetSimilarForeground(JetRgbaColor foreground, JetRgbaColor goodForeground);
    public static JetRgbaColor GetDarkerColor(JetRgbaColor color, double value);
    public static JetRgbaColor GetLighterColor(JetRgbaColor color, double value);
    public static JetRgbaColor BlendColors(JetRgbaColor a, JetRgbaColor b, double proportion);
}
public class JetBrains.Util.Media.ColorSpaces.CIELab : ValueType {
    public static CIELab Empty;
    private double l;
    private double a;
    private double b;
    public double L { get; public set; }
    public double A { get; public set; }
    public double B { get; public set; }
    public CIELab(double l, double a, double b);
    private static CIELab();
    public static bool op_Equality(CIELab item1, CIELab item2);
    public static bool op_Inequality(CIELab item1, CIELab item2);
    public double get_L();
    public void set_L(double value);
    public double get_A();
    public void set_A(double value);
    public double get_B();
    public void set_B(double value);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class JetBrains.Util.Media.ColorSpaces.CIEXYZ : ValueType {
    public static CIEXYZ Empty;
    public static CIEXYZ D65;
    private double x;
    private double y;
    private double z;
    public double X { get; public set; }
    public double Y { get; public set; }
    public double Z { get; public set; }
    public CIEXYZ(double x, double y, double z);
    private static CIEXYZ();
    public static bool op_Equality(CIEXYZ item1, CIEXYZ item2);
    public static bool op_Inequality(CIEXYZ item1, CIEXYZ item2);
    public double get_X();
    public void set_X(double value);
    public double get_Y();
    public void set_Y(double value);
    public double get_Z();
    public void set_Z(double value);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class JetBrains.Util.Media.ColorSpaces.CMYK : ValueType {
    public static CMYK Empty;
    private double c;
    private double m;
    private double y;
    private double k;
    public double Cyan { get; public set; }
    public double Magenta { get; public set; }
    public double Yellow { get; public set; }
    public double Black { get; public set; }
    public CMYK(double c, double m, double y, double k);
    private static CMYK();
    public static bool op_Equality(CMYK item1, CMYK item2);
    public static bool op_Inequality(CMYK item1, CMYK item2);
    public double get_Cyan();
    public void set_Cyan(double value);
    public double get_Magenta();
    public void set_Magenta(double value);
    public double get_Yellow();
    public void set_Yellow(double value);
    public double get_Black();
    public void set_Black(double value);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public static class JetBrains.Util.Media.ColorSpaces.ColorSpace : object {
    public static double GetColorDistance(double r1, double g1, double b1, double r2, double g2, double b2);
    public static double GetColorDistance(Double[] color1, Double[] color2);
    public static double GetColorDistance(JetRgbaColor c1, JetRgbaColor c2);
    private static int GetIntFromHex(string strHex);
    [ObsoleteAttribute("A very oops method. Use smth more optimal.")]
public static JetRgbaColor HexToColor(string hexColor);
    public static string RGBToHex(int r, int g, int b);
    public static string RGBToHex(JetRgbaColor c);
    public static RGB HSBtoRGB(HSB hsb);
    public static RGB HSBtoRGB(double h, double s, double b);
    public static JetRgbaColor HSBtoColor(HSB hsb);
    public static JetRgbaColor HSBtoColor(double h, double s, double b);
    public static JetRgbaColor HSBtoColor(int h, int s, int b);
    public static HSL HSBtoHSL(double h, double s, double b);
    public static CMYK HSBtoCMYK(double h, double s, double b);
    public static YUV HSBtoYUV(double h, double s, double b);
    public static RGB HSLtoRGB(double h, double s, double l);
    public static RGB HSLtoRGB(HSL hsl);
    public static JetRgbaColor HSLtoColor(double h, double s, double l);
    public static JetRgbaColor HSLtoColor(HSL hsl);
    public static HSB HSLtoHSB(double h, double s, double l);
    public static CMYK HSLtoCMYK(double h, double s, double l);
    public static YUV HSLtoYUV(double h, double s, double l);
    public static HSL RGBtoHSL(int red, int green, int blue);
    public static HSL RGBtoHSL(RGB rgb);
    public static HSL RGBtoHSL(JetRgbaColor c);
    public static HSB RGBtoHSB(int red, int green, int blue);
    public static HSB RGBtoHSB(RGB rgb);
    public static HSB RGBtoHSB(JetRgbaColor c);
    public static CMYK RGBtoCMYK(int red, int green, int blue);
    public static CMYK RGBtoCMYK(JetRgbaColor c);
    public static CMYK RGBtoCMYK(RGB rgb);
    public static YUV RGBtoYUV(int red, int green, int blue);
    public static YUV RGBtoYUV(JetRgbaColor c);
    public static YUV RGBtoYUV(RGB rgb);
    public static CIEXYZ RGBtoXYZ(int red, int green, int blue);
    public static CIEXYZ RGBtoXYZ(RGB rgb);
    public static CIEXYZ RGBtoXYZ(JetRgbaColor c);
    public static CIELab RGBtoLab(int red, int green, int blue);
    public static CIELab RGBtoLab(RGB rgb);
    public static CIELab RGBtoLab(JetRgbaColor color);
    public static JetRgbaColor CMYKtoColor(float c, float m, float y, float k);
    public static JetRgbaColor CMYKtoColor(double c, double m, double y, double k);
    public static JetRgbaColor CMYKtoColor(CMYK cmyk);
    public static RGB CMYKtoRGB(double c, double m, double y, double k);
    public static RGB CMYKtoRGB(CMYK cmyk);
    public static HSL CMYKtoHSL(double c, double m, double y, double k);
    public static HSB CMYKtoHSB(double c, double m, double y, double k);
    public static YUV CMYKtoYUV(double c, double m, double y, double k);
    public static RGB YUVtoRGB(double y, double u, double v);
    public static RGB YUVtoRGB(YUV yuv);
    public static JetRgbaColor YUVtoColor(double y, double u, double v);
    public static JetRgbaColor YUVtoColor(YUV yuv);
    public static HSL YUVtoHSL(double y, double u, double v);
    public static HSB YUVtoHSB(double y, double u, double v);
    public static CMYK YUVtoCMYK(double y, double u, double v);
    public static RGB XYZtoRGB(double x, double y, double z);
    public static RGB XYZtoRGB(CIEXYZ xyz);
    private static double Fxyz(double t);
    public static CIELab XYZtoLab(double x, double y, double z);
    public static CIELab XYZtoLab(CIEXYZ xyz);
    public static CIEXYZ LabtoXYZ(double l, double a, double b);
    public static CIEXYZ LabtoXYZ(CIELab lab);
    public static RGB LabtoRGB(double l, double a, double b);
    public static RGB LabtoRGB(CIELab lab);
    public static JetRgbaColor RGBtoColor(RGB rGB);
}
public class JetBrains.Util.Media.ColorSpaces.HSB : ValueType {
    public static HSB Empty;
    private double hue;
    private double saturation;
    private double brightness;
    [DescriptionAttribute("Hue component")]
public double Hue { get; public set; }
    [DescriptionAttribute("Saturation component")]
public double Saturation { get; public set; }
    [DescriptionAttribute("Brightness component")]
public double Brightness { get; public set; }
    public HSB(double h, double s, double b);
    private static HSB();
    public static bool op_Equality(HSB item1, HSB item2);
    public static bool op_Inequality(HSB item1, HSB item2);
    public double get_Hue();
    public void set_Hue(double value);
    public double get_Saturation();
    public void set_Saturation(double value);
    public double get_Brightness();
    public void set_Brightness(double value);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class JetBrains.Util.Media.ColorSpaces.HSL : ValueType {
    public static HSL Empty;
    private double hue;
    private double saturation;
    private double luminance;
    [DescriptionAttribute("Hue component")]
public double Hue { get; public set; }
    [DescriptionAttribute("Saturation component")]
public double Saturation { get; public set; }
    [DescriptionAttribute("Luminance component")]
public double Luminance { get; public set; }
    public HSL(double h, double s, double l);
    private static HSL();
    public static bool op_Equality(HSL item1, HSL item2);
    public static bool op_Inequality(HSL item1, HSL item2);
    public double get_Hue();
    public void set_Hue(double value);
    public double get_Saturation();
    public void set_Saturation(double value);
    public double get_Luminance();
    public void set_Luminance(double value);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class JetBrains.Util.Media.ColorSpaces.RGB : ValueType {
    public static RGB Empty;
    private int red;
    private int green;
    private int blue;
    [DescriptionAttribute("Red component.")]
public int Red { get; public set; }
    [DescriptionAttribute("Green component.")]
public int Green { get; public set; }
    [DescriptionAttribute("Blue component.")]
public int Blue { get; public set; }
    public RGB(int R, int G, int B);
    private static RGB();
    public static bool op_Equality(RGB item1, RGB item2);
    public static bool op_Inequality(RGB item1, RGB item2);
    public int get_Red();
    public void set_Red(int value);
    public int get_Green();
    public void set_Green(int value);
    public int get_Blue();
    public void set_Blue(int value);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class JetBrains.Util.Media.ColorSpaces.YUV : ValueType {
    public static YUV Empty;
    private double y;
    private double u;
    private double v;
    public double Y { get; public set; }
    public double U { get; public set; }
    public double V { get; public set; }
    public YUV(double y, double u, double v);
    private static YUV();
    public static bool op_Equality(YUV item1, YUV item2);
    public static bool op_Inequality(YUV item1, YUV item2);
    public double get_Y();
    public void set_Y(double value);
    public double get_U();
    public void set_U(double value);
    public double get_V();
    public void set_V(double value);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class JetBrains.Util.Media.Descriptors.BrushDescriptor : object {
    [CompilerGeneratedAttribute]
private JetRgbaColor <Color>k__BackingField;
    public JetRgbaColor Color { get; public set; }
    public BrushDescriptor(JetRgbaColor color);
    [CompilerGeneratedAttribute]
public JetRgbaColor get_Color();
    [CompilerGeneratedAttribute]
public void set_Color(JetRgbaColor value);
    public static BrushDescriptor op_Implicit(JetRgbaColor color);
}
public class JetBrains.Util.Media.Descriptors.TileBrushDescriptor : BrushDescriptor {
    [CompilerGeneratedAttribute]
private JetRgbaColor <FirstColor>k__BackingField;
    [CompilerGeneratedAttribute]
private JetRect <Viewport>k__BackingField;
    [CompilerGeneratedAttribute]
private JetPoint[] <FirstPath>k__BackingField;
    [CompilerGeneratedAttribute]
private JetPoint[] <SecondPath>k__BackingField;
    [CompilerGeneratedAttribute]
private double <RotateAngle>k__BackingField;
    [CompilerGeneratedAttribute]
private JetPoint <RotateCenter>k__BackingField;
    public JetRgbaColor FirstColor { get; public set; }
    public JetRgbaColor SecondColor { get; public set; }
    public JetRect Viewport { get; public set; }
    public JetPoint[] FirstPath { get; public set; }
    public JetPoint[] SecondPath { get; public set; }
    public double RotateAngle { get; public set; }
    public JetPoint RotateCenter { get; public set; }
    [CompilerGeneratedAttribute]
public JetRgbaColor get_FirstColor();
    [CompilerGeneratedAttribute]
public void set_FirstColor(JetRgbaColor value);
    public JetRgbaColor get_SecondColor();
    public void set_SecondColor(JetRgbaColor value);
    [CompilerGeneratedAttribute]
public JetRect get_Viewport();
    [CompilerGeneratedAttribute]
public void set_Viewport(JetRect value);
    [CompilerGeneratedAttribute]
public JetPoint[] get_FirstPath();
    [CompilerGeneratedAttribute]
public void set_FirstPath(JetPoint[] value);
    [CompilerGeneratedAttribute]
public JetPoint[] get_SecondPath();
    [CompilerGeneratedAttribute]
public void set_SecondPath(JetPoint[] value);
    [CompilerGeneratedAttribute]
public double get_RotateAngle();
    [CompilerGeneratedAttribute]
public void set_RotateAngle(double value);
    [CompilerGeneratedAttribute]
public JetPoint get_RotateCenter();
    [CompilerGeneratedAttribute]
public void set_RotateCenter(JetPoint value);
}
[ObsoleteAttribute("Use structs from JetBrains.Util.Colors.ColorSpaces")]
public class JetBrains.Util.Media.HslColor : ValueType {
    private double myH;
    private double myS;
    private double myL;
    public double H { get; public set; }
    public double S { get; public set; }
    public double L { get; public set; }
    public static HslColor FromRGB(JetRgbaColor rgb);
    public JetRgbaColor ToRgb();
    public double get_H();
    public void set_H(double value);
    public double get_S();
    public void set_S(double value);
    public double get_L();
    public void set_L(double value);
    public static JetRgbaColor HslToRgb(double alpha, double h, double s, double l);
    public static void RgbToHsl(JetRgbaColor rgbColor, Double& hue, Double& sat, Double& lum);
}
public class JetBrains.Util.Media.HumanPerceptibleColor : ValueType {
    private static double Pr;
    private static double Pg;
    private static double Pb;
    private double myHue;
    private double mySaturation;
    private double myBrightness;
    private double myAlpha;
    public double Hue { get; public set; }
    public double Saturation { get; public set; }
    public double Brightness { get; public set; }
    public double Alpha { get; public set; }
    public bool IsLight { get; }
    public bool IsDark { get; }
    public HumanPerceptibleColor(double a, double h, double s, double b);
    public double get_Hue();
    public void set_Hue(double value);
    public double get_Saturation();
    public void set_Saturation(double value);
    public double get_Brightness();
    public void set_Brightness(double value);
    public double get_Alpha();
    public void set_Alpha(double value);
    public bool get_IsLight();
    public bool get_IsDark();
    public static HumanPerceptibleColor FromColor(JetRgbaColor color);
    public static HumanPerceptibleColor FromArgb(int a, int r, int g, int b);
    public static HumanPerceptibleColor FromArgb(double a, double r, double g, double b);
    public JetRgbaColor ToColor(bool hue);
    public Double[] ToArgb(bool hue);
    private static double Clamp(double value);
}
[ExtensionAttribute]
public static class JetBrains.Util.Media.Icons.Emitters.SvgThemedIconsTransferFormatParser : object {
    private static TiSolidColorBrush BrushFailedToParse;
    private static String[] myAttributeStringNames;
    private static SvgThemedIconsTransferFormatParser();
    [NotNullAttribute]
public static TiBrush GetBrushFromResource(string refid, ParseContext ctx, IList`1<TiSegment> tiSegmentsNoShapeTransform, IList`1<TiSegment> tiSegmentsWithShapeTransform, JetMatrix transformSegmentsInWorldCoords, OnError onerror);
    public static TiPath MakeTiPathForShape(XElement xe, ImmutableArray`1<TiSegment> tiSegmentsOriginal, IDictionary`2<string, Property> props, ParseContext ctx, OnError onerror);
    [NotNullAttribute]
public static TiImage ParseImage(ImmutableByteStream stream, OnError onerror);
    [NotNullAttribute]
private static TiBrush ApplyBrushOpacity(TiBrush brush, double fOpacity, OnError onerror);
    private static JetRgbaColor ApplyBrushOpacity_Color(JetRgbaColor color, double fOpacity);
    private static FrugalLocalList`1<TiGradientStop> ApplyBrushOpacity_Stops(FrugalLocalList`1& stops, double fOpacity);
    private static void AssertKnownAttributes(XElement xmlElem, Attribute[] known, OnError onerror);
    private static void AssertNoNontrivialStroke(IDictionary`2<string, Property> props, OnError onerror);
    private static GradientUnits ChooseGradientUnits(IDictionary`2<string, Property> props, NumberResult[] numbersFromCoordinates, OnError onerror);
    private static void Circle(XElement xe, Builder<TiPath> tipaths, ParseContext ctx, OnError onerror);
    private static JetMatrix CreateWorldToBoundsRelativeTransform(IList`1<TiSegment> tiSegments, OnError onerror);
    private static void Defs(XElement xeDef, ParseContext ctx, OnError onerror);
    private static void Ellipse(XElement xe, Builder<TiPath> tipaths, ParseContext ctx, OnError onerror);
    private static TiBrush GetBrushFromResource_LinearGradient(string refid, Resource resource, IList`1<TiSegment> tiSegmentsNoShapeTransform, IList`1<TiSegment> tiSegmentsWithShapeTransform, JetMatrix transformSegmentsInWorldCoords, OnError onerror);
    private static TiBrush GetBrushFromResource_RadialGradient(string refid, Resource resource, IList`1<TiSegment> tiSegmentsNoShapeTransform, IList`1<TiSegment> tiSegmentsWithShapeTransform, JetMatrix transformSegmentsInWorldCoords, OnError onerror);
    [NotNullAttribute]
private static TiBrush GetFill(IDictionary`2<string, Property> props, ParseContext ctx, IList`1<TiSegment> tiSegmentsNoShapeTransform, IList`1<TiSegment> tiSegmentsWithShapeTransform, JetMatrix transformSegmentsInWorldCoords, OnError onerror);
    [ExtensionAttribute]
private static NumberResult GetNumberEx(IDictionary`2<string, Property> props, Attribute attr, OnError onerror);
    [ExtensionAttribute]
private static NumberResult GetNumberEx(Property prop, OnError onerror);
    [ExtensionAttribute]
private static double GetNumberOrZero(IDictionary`2<string, Property> props, Attribute attr, OnError onerror, GetNumberFlags flags);
    [ExtensionAttribute]
private static double GetNumberOrZero(Property prop, OnError onerror, GetNumberFlags flags);
    private static IDictionary`2<string, Property> GetPropertiesFromAttributesAndStyle(XElement xe, Attribute[] attrsKnown, OnError onerror);
    private static ImmutableArray`1<TiSegment> GetTiSegmentsForEllipse(JetPoint center, JetSize axes);
    private static FrugalLocalList`1<TiGradientStop> GradientStops(IReadOnlyList`1<XElement> xeCollection, OnError onerror);
    private static JetMatrix GradientTransform(IDictionary`2<string, Property> props, OnError onerror);
    private static void Group(XElement xe, Builder<TiPath> tipaths, ParseContext ctxOuter, OnError onerror);
    private static JetSize ParseImage_LogicalSize(IDictionary`2<string, Property> props, OnError onerror);
    private static void ParseResources(XElement xeSvg, ParseContext ctx, OnError onerror);
    private static JetMatrix ParseTransformValue(string sTransformText, XElement xeForContext, OnError onerror);
    private static void Path(XElement xe, Builder<TiPath> tipaths, ParseContext ctx, OnError onerror);
    private static void Polygon(XElement xe, Builder<TiPath> tipaths, ParseContext ctx, OnError onerror);
    private static JetMatrix ReadShapeTransformProperty(IDictionary`2<string, Property> props, ParseContext ctx, OnError onerror);
    private static void Rect(XElement xe, Builder<TiPath> tipaths, ParseContext ctx, OnError onerror);
    private static string ReportElement(XElement xe);
    [ExtensionAttribute]
[NotNullAttribute]
private static string ToAttributeString(Attribute attr);
    [ExtensionAttribute]
[CanBeNullAttribute]
private static Property TryGet(IDictionary`2<string, Property> props, Attribute attr);
    [ExtensionAttribute]
private static Nullable`1<FillRule> TryGetFillRule(IDictionary`2<string, Property> props, OnError onerror);
    private static bool TryHandleGraphicsElement(XElement xe, Builder<TiPath> tipaths, ParseContext ctx, OnError onerror);
    private static bool TrySkipDef(XElement xe);
    [PureAttribute]
private static ImmutableArray`1<TiSegment> WithShapeFillRule(ImmutableArray`1<TiSegment> tiSegments, IDictionary`2<string, Property> props, ParseContext ctx, OnError onerror);
    [PureAttribute]
private static ImmutableArray`1<TiSegment> WithShapeTransform(ImmutableArray`1<TiSegment> tiSegments, JetMatrix transform);
}
public class JetBrains.Util.Media.Imaging.BitmapSourceBytes : object {
    [CompilerGeneratedAttribute]
private ImmutableByteStream <Bytes>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public ImmutableByteStream Bytes { get; public set; }
    public BitmapSourceBytes(ImmutableByteStream Bytes);
    [CompilerGeneratedAttribute]
protected BitmapSourceBytes(BitmapSourceBytes original);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public ImmutableByteStream get_Bytes();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Bytes(ImmutableByteStream value);
    [NotNullAttribute]
public static BitmapSourceBytes FromFile(ImmutableFileItem fi);
    [CanBeNullAttribute]
public static BitmapSourceBytes FromFileOrNull(ImmutableFileItem fi);
    [NotNullAttribute]
public static BitmapSourceBytes FromStream(ImmutableByteStream stream);
    [CanBeNullAttribute]
public static BitmapSourceBytes FromStreamOrNull(ImmutableByteStream stream);
    [CanBeNullAttribute]
public static BitmapSourceBytes op_Explicit(ImmutableByteStream stream);
    [CanBeNullAttribute]
public static BitmapSourceBytes op_Explicit(ImmutableFileItem fi);
    [CanBeNullAttribute]
public static ImmutableByteStream op_Explicit(BitmapSourceBytes bsb);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(BitmapSourceBytes left, BitmapSourceBytes right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(BitmapSourceBytes left, BitmapSourceBytes right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(BitmapSourceBytes other);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual BitmapSourceBytes <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(ImmutableByteStream& Bytes);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.Util.Media.Imaging.ByteArrayIconGroup : object {
    [NullableAttribute("0")]
public ImmutableArray`1<byte> RawBytes;
    [NullableContextAttribute("0")]
public ByteArrayIconGroup(ImmutableArray`1<byte> bytes);
    public ByteArrayIconGroup(Stream iconBytes);
    public static ByteArrayIconGroup ReadFromStream(Stream stream);
    public ImmutableByteStream ToStream();
    public void Save(Stream stream);
    [NullableContextAttribute("0")]
public static ByteArrayIconGroup FromBytes(ImmutableArray`1<byte> bytes);
    public static ByteArrayIconGroup FromBytes(Byte[] bytes);
}
public class JetBrains.Util.Media.Imaging.RasterDeviceImages : object {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<ValueTuple`2<ImmutableByteStream, DpiResolution>> Images;
    public RasterDeviceImages(ImmutableArray`1<ValueTuple`2<ImmutableByteStream, DpiResolution>> images);
    public ValueTuple`2<ImmutableByteStream, DpiResolution> FindNearest(DpiResolution resolution);
    [NotNullAttribute]
public static RasterDeviceImages FromTwoResx(UnmanagedMemoryStream stream96, UnmanagedMemoryStream stream192);
    [NotNullAttribute]
public static RasterDeviceImages FromTwoStreams(ImmutableByteStream stream96, ImmutableByteStream stream192);
    [CanBeNullAttribute]
public ImmutableByteStream TryGetExact(DpiResolution resolution);
    [CompilerGeneratedAttribute]
internal static double <FindNearest>g__Diameter|2_1(DpiResolution res);
}
public enum JetBrains.Util.Media.JetDockStyle : Enum {
    public int value__;
    public static JetDockStyle Left;
    public static JetDockStyle Top;
    public static JetDockStyle Right;
    public static JetDockStyle Bottom;
}
[IsReadOnlyAttribute]
[ValueSerializerAttribute("JetBrains.Util.Media.JetMatrix/Serializer")]
public class JetBrains.Util.Media.JetMatrix : ValueType {
    private static int c_identityHashCode;
    internal double _m11;
    internal double _m12;
    internal double _m21;
    internal double _m22;
    internal double _offsetX;
    internal double _offsetY;
    internal MatrixTypes _type;
    private static JetMatrix s_identity;
    public double Determinant { get; }
    public bool HasInverse { get; }
    public static JetMatrix Identity { get; }
    public bool IsIdentity { get; }
    public bool IsNullOrIdentity { get; }
    public double M11 { get; }
    public double M12 { get; }
    public double M21 { get; }
    public double M22 { get; }
    public double OffsetX { get; }
    public double OffsetY { get; }
    private bool IsDistinguishedIdentity { get; }
    public JetMatrix(double m11, double m12, double m21, double m22, double offsetX, double offsetY);
    private JetMatrix(double m11, double m12, double m21, double m22, double offsetX, double offsetY, MatrixTypes knowntype);
    private static JetMatrix();
    public double get_Determinant();
    public bool get_HasInverse();
    public static JetMatrix get_Identity();
    public bool get_IsIdentity();
    public bool get_IsNullOrIdentity();
    public double get_M11();
    public double get_M12();
    public double get_M21();
    public double get_M22();
    public double get_OffsetX();
    public double get_OffsetY();
    [PureAttribute]
public JetMatrix Append(JetMatrix& matrix);
    [PureAttribute]
public static JetMatrix CreateRotationDegrees(double deg, double centerX, double centerY);
    [PureAttribute]
public static JetMatrix CreateRotationRadians(double angleRad, double centerX, double centerY);
    [PureAttribute]
public static JetMatrix CreateScaling(double scaleX, double scaleY, double centerX, double centerY);
    [PureAttribute]
public static JetMatrix CreateScaling(double scaleX, double scaleY);
    public static JetMatrix CreateSkewDegrees(double skewDegX, double skewDegY);
    [PureAttribute]
public static JetMatrix CreateSkewRadians(double skewRadX, double skewRadY);
    [PureAttribute]
public static JetMatrix CreateTranslation(double offsetX, double offsetY);
    [PureAttribute]
public static JetMatrix CreateTranslation(JetVector& vector);
    [PureAttribute]
public void Deconstruct(Double& m11, Double& m12, Double& m21, Double& m22, Double& offsetX, Double& offsetY);
    [PureAttribute]
public static bool Equals(JetMatrix& matrix1, JetMatrix& matrix2);
    [PureAttribute]
public virtual bool Equals(object o);
    [PureAttribute]
public bool Equals(JetMatrix& value);
    [PureAttribute]
public virtual int GetHashCode();
    [PureAttribute]
public JetMatrix Inverse();
    [PureAttribute]
public static JetMatrix Multiply(JetMatrix& trans1, JetMatrix& trans2);
    [PureAttribute]
public static bool op_Equality(JetMatrix& matrix1, JetMatrix& matrix2);
    [PureAttribute]
public static bool op_Inequality(JetMatrix& matrix1, JetMatrix& matrix2);
    [PureAttribute]
public static JetMatrix op_Multiply(JetMatrix& trans1, JetMatrix& trans2);
    [PureAttribute]
public static JetMatrix Parse(string source);
    [PureAttribute]
public JetMatrix Prepended(JetMatrix& matrix);
    [PureAttribute]
public JetMatrix Rotated(double deg);
    [PureAttribute]
public JetMatrix RotatedAt(double deg, double centerX, double centerY);
    [PureAttribute]
public JetMatrix RotatedAtPrepend(double deg, double centerX, double centerY);
    [PureAttribute]
public JetMatrix RotatedPrepend(double deg);
    [PureAttribute]
public JetMatrix Scaled(double scaleX, double scaleY);
    [PureAttribute]
public JetMatrix ScaledAt(double scaleX, double scaleY, double centerX, double centerY);
    [PureAttribute]
public JetMatrix ScaledAtPrepend(double scaleX, double scaleY, double centerX, double centerY);
    [PureAttribute]
public JetMatrix ScaledPrepend(double scaleX, double scaleY);
    [PureAttribute]
public JetMatrix Skewed(double degX, double degY);
    [PureAttribute]
public JetMatrix SkewedPrepend(double degX, double degY);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    [PureAttribute]
public JetPoint Transform(JetPoint& point);
    [PureAttribute]
public JetVector Transform(JetVector& vector);
    public JetRect Transform(JetRect& rect);
    [PureAttribute]
public JetMatrix Translated(double offsetX, double offsetY);
    [PureAttribute]
public JetMatrix TranslatedPrepend(double offsetX, double offsetY);
    [PureAttribute]
internal string ConvertToString(string format, IFormatProvider provider);
    [ConditionalAttribute("JET_MODE_ASSERT")]
private void Debug_CheckType();
    private sealed virtual override bool System.IEquatable<JetBrains.Util.Media.JetMatrix>.Equals(JetMatrix other);
    private bool get_IsDistinguishedIdentity();
    [PureAttribute]
internal static JetMatrix MultiplyMatrix(JetMatrix& matrix1, JetMatrix& matrix2);
    internal void MultiplyPoint(Double& x, Double& y);
    internal void MultiplyVector(Double& x, Double& y);
    [PureAttribute]
private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
}
[IsReadOnlyAttribute]
[ValueSerializerAttribute("JetBrains.Util.Media.JetPhysicalPoint/Serializer")]
public class JetBrains.Util.Media.JetPhysicalPoint : ValueType {
    private int _x;
    private int _y;
    public int X { get; }
    public int Y { get; }
    public JetPhysicalPoint(int x, int y);
    public int get_X();
    public int get_Y();
    [PureAttribute]
public static JetPhysicalPoint Add(JetPhysicalPoint& point, JetPhysicalVector& vector);
    public void Deconstruct(Int32& x, Int32& y);
    [PureAttribute]
public static bool Equals(JetPhysicalPoint& point1, JetPhysicalPoint& point2);
    public virtual bool Equals(object o);
    [PureAttribute]
public bool Equals(JetPhysicalPoint& value);
    public virtual int GetHashCode();
    [PureAttribute]
public JetPhysicalPoint Offset(int offsetX, int offsetY);
    [PureAttribute]
public static JetPhysicalPoint op_Addition(JetPhysicalPoint& point, JetPhysicalVector& vector);
    [PureAttribute]
public static bool op_Equality(JetPhysicalPoint& point1, JetPhysicalPoint& point2);
    [PureAttribute]
public static JetPhysicalSize op_Explicit(JetPhysicalPoint& point);
    [PureAttribute]
public static JetPhysicalVector op_Explicit(JetPhysicalPoint& point);
    [PureAttribute]
public static bool op_Inequality(JetPhysicalPoint& point1, JetPhysicalPoint& point2);
    [PureAttribute]
public static JetPhysicalPoint op_Subtraction(JetPhysicalPoint& point, JetPhysicalVector& vector);
    [PureAttribute]
public static JetPhysicalVector op_Subtraction(JetPhysicalPoint& point1, JetPhysicalPoint& point2);
    [PureAttribute]
public static JetPhysicalPoint Parse(string source);
    [PureAttribute]
public static JetPhysicalPoint Subtract(JetPhysicalPoint& point, JetPhysicalVector& vector);
    [PureAttribute]
public static JetPhysicalVector Subtract(JetPhysicalPoint& point1, JetPhysicalPoint& point2);
    [PureAttribute]
public JetPoint ToLogicalPoint(DpiResolution resolution);
    [PureAttribute]
public virtual string ToString();
    [PureAttribute]
public string ToString(IFormatProvider provider);
    [PureAttribute]
public JetPhysicalPoint WithX(int x);
    [PureAttribute]
public JetPhysicalPoint WithY(int y);
    [PureAttribute]
internal string ConvertToString(string format, IFormatProvider provider);
    private sealed virtual override bool System.IEquatable<JetBrains.Util.Media.JetPhysicalPoint>.Equals(JetPhysicalPoint other);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
}
[IsReadOnlyAttribute]
[ValueSerializerAttribute("JetBrains.Util.Media.JetPhysicalRect/Serializer")]
public class JetBrains.Util.Media.JetPhysicalRect : ValueType {
    private static JetPhysicalRect s_empty;
    private int _height;
    private int _width;
    private int _x;
    private int _y;
    public int Bottom { get; }
    public JetPhysicalPoint BottomLeft { get; }
    public JetPhysicalPoint BottomRight { get; }
    public JetPhysicalPoint Center { get; }
    public static JetPhysicalRect Empty { get; }
    public int Height { get; }
    public bool IsEmpty { get; }
    public int Left { get; }
    public JetPhysicalPoint Location { get; }
    public int Right { get; }
    public JetPhysicalSize Size { get; }
    public int Top { get; }
    public JetPhysicalPoint TopLeft { get; }
    public JetPhysicalPoint TopRight { get; }
    public int Width { get; }
    public int X { get; }
    public int Y { get; }
    public JetPhysicalRect(JetPhysicalPoint location, JetPhysicalSize size);
    public JetPhysicalRect(int x, int y, int width, int height);
    public JetPhysicalRect(JetPhysicalPoint point1, JetPhysicalPoint point2);
    public JetPhysicalRect(JetPhysicalPoint point, JetPhysicalVector vector);
    public JetPhysicalRect(JetPhysicalSize size);
    private JetPhysicalRect(Missing _);
    private static JetPhysicalRect();
    public int get_Bottom();
    public JetPhysicalPoint get_BottomLeft();
    public JetPhysicalPoint get_BottomRight();
    public JetPhysicalPoint get_Center();
    public static JetPhysicalRect get_Empty();
    public int get_Height();
    public bool get_IsEmpty();
    public int get_Left();
    public JetPhysicalPoint get_Location();
    public int get_Right();
    public JetPhysicalSize get_Size();
    public int get_Top();
    public JetPhysicalPoint get_TopLeft();
    public JetPhysicalPoint get_TopRight();
    public int get_Width();
    public int get_X();
    public int get_Y();
    [PureAttribute]
public bool Contains(JetPhysicalPoint point);
    [PureAttribute]
public bool Contains(int x, int y);
    [PureAttribute]
public bool Contains(JetPhysicalRect& rect);
    public void Deconstruct(JetPhysicalPoint& location, JetPhysicalSize& size);
    [PureAttribute]
public static bool Equals(JetPhysicalRect& rect1, JetPhysicalRect& rect2);
    public virtual bool Equals(object o);
    [PureAttribute]
public bool Equals(JetPhysicalRect& value);
    [PureAttribute]
public static JetPhysicalRect FromLTRB(int left, int top, int right, int bottom);
    public virtual int GetHashCode();
    [PureAttribute]
public JetPhysicalRect Inflated(JetPhysicalSize size);
    [PureAttribute]
public JetPhysicalRect Inflated(int width, int height);
    [PureAttribute]
public JetPhysicalRect Intersected(JetPhysicalRect& rect);
    public bool IntersectsWith(JetPhysicalRect& rect);
    [PureAttribute]
public JetPhysicalRect Offset(JetPhysicalVector& offsetVector);
    [PureAttribute]
public JetPhysicalRect Offset(int offsetX, int offsetY);
    [PureAttribute]
public static bool op_Equality(JetPhysicalRect& rect1, JetPhysicalRect& rect2);
    [PureAttribute]
public static bool op_Inequality(JetPhysicalRect& rect1, JetPhysicalRect& rect2);
    [PureAttribute]
public static JetPhysicalRect Parse(string source);
    [PureAttribute]
public JetPhysicalRect Scaled(int scaleX, int scaleY);
    [PureAttribute]
public JetRect ToLogicalRect(DpiResolution resolution);
    public virtual string ToString();
    [PureAttribute]
public string ToString(IFormatProvider provider);
    [PureAttribute]
public JetPhysicalRect Unioned(JetPhysicalRect& rect);
    [PureAttribute]
public JetPhysicalRect Unioned(JetPhysicalPoint point);
    [PureAttribute]
public JetPhysicalRect WithLocation(JetPhysicalPoint location);
    [PureAttribute]
public JetPhysicalRect WithSize(JetPhysicalSize size);
    [PureAttribute]
private bool ContainsInternal(int x, int y);
    [PureAttribute]
internal string ConvertToString(string format, IFormatProvider provider);
    private sealed virtual override bool System.IEquatable<JetBrains.Util.Media.JetPhysicalRect>.Equals(JetPhysicalRect other);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
}
[IsReadOnlyAttribute]
[ValueSerializerAttribute("JetBrains.Util.Media.JetPhysicalSize/Serializer")]
public class JetBrains.Util.Media.JetPhysicalSize : ValueType {
    private static JetPhysicalSize s_empty;
    internal int _height;
    internal int _width;
    public static JetPhysicalSize Empty { get; }
    public int Height { get; }
    public bool IsEmpty { get; }
    public int Width { get; }
    public JetPhysicalSize(int width, int height);
    private JetPhysicalSize(Missing _);
    private static JetPhysicalSize();
    public static JetPhysicalSize get_Empty();
    public int get_Height();
    public bool get_IsEmpty();
    public int get_Width();
    public void Deconstruct(Int32& width, Int32& height);
    [PureAttribute]
public static bool Equals(JetPhysicalSize size1, JetPhysicalSize size2);
    public virtual bool Equals(object o);
    [PureAttribute]
public sealed virtual bool Equals(JetPhysicalSize value);
    public virtual int GetHashCode();
    public static JetPhysicalSize op_Addition(JetPhysicalSize size1, JetPhysicalSize size2);
    [PureAttribute]
public static bool op_Equality(JetPhysicalSize size1, JetPhysicalSize size2);
    [PureAttribute]
public static JetPhysicalVector op_Explicit(JetPhysicalSize size);
    [PureAttribute]
public static JetPhysicalPoint op_Explicit(JetPhysicalSize size);
    [PureAttribute]
public static bool op_Inequality(JetPhysicalSize size1, JetPhysicalSize size2);
    public static JetPhysicalSize op_Subtraction(JetPhysicalSize size1, JetPhysicalSize size2);
    [PureAttribute]
public static JetPhysicalSize Parse(string source);
    [PureAttribute]
public JetSize ToLogicalSize(DpiResolution resolution);
    public virtual string ToString();
    [PureAttribute]
public string ToString(IFormatProvider provider);
    public JetPhysicalSize WithHeight(int height);
    public JetPhysicalSize WithWidth(int width);
    [PureAttribute]
internal string ConvertToString(string format, IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
}
[IsReadOnlyAttribute]
[ValueSerializerAttribute("JetBrains.Util.Reflection.SimpleValueSerializer`1<JetBrains.Util.Media.JetPhysicalThickness>")]
public class JetBrains.Util.Media.JetPhysicalThickness : ValueType {
    public static JetPhysicalThickness Empty;
    private int _Bottom;
    private int _Left;
    private int _Right;
    private int _Top;
    public int Bottom { get; }
    public bool IsNonnegative { get; }
    public bool IsUniform { get; }
    public bool IsZero { get; }
    public int Left { get; }
    public int Right { get; }
    public int Top { get; }
    public JetPhysicalSize TotalSize { get; }
    public JetPhysicalThickness(string text);
    public JetPhysicalThickness(int uniformLength);
    public JetPhysicalThickness(int left, int top, int right, int bottom);
    public JetPhysicalThickness(int leftright, int topbottom);
    private static JetPhysicalThickness();
    public int get_Bottom();
    [PureAttribute]
public bool get_IsNonnegative();
    [PureAttribute]
public bool get_IsUniform();
    [PureAttribute]
public bool get_IsZero();
    public int get_Left();
    public int get_Right();
    public int get_Top();
    public JetPhysicalSize get_TotalSize();
    public void Deconstruct(Int32& left, Int32& top, Int32& right, Int32& bottom);
    public virtual bool Equals(object obj);
    public bool Equals(JetPhysicalThickness& thickness);
    public virtual int GetHashCode();
    [PureAttribute]
public static JetPhysicalThickness op_Addition(JetPhysicalThickness& t1, JetPhysicalThickness& t2);
    [PureAttribute]
public static bool op_Equality(JetPhysicalThickness& t1, JetPhysicalThickness& t2);
    [PureAttribute]
public static bool op_Inequality(JetPhysicalThickness& t1, JetPhysicalThickness& t2);
    [PureAttribute]
public static JetPhysicalThickness op_Subtraction(JetPhysicalThickness& t1, JetPhysicalThickness& t2);
    [PureAttribute]
public static JetPhysicalThickness op_UnaryNegation(JetPhysicalThickness& t1);
    [PureAttribute]
public JetThickness ToLogicalThickness(DpiResolution resolution);
    public virtual string ToString();
    private sealed virtual override bool System.IEquatable<JetBrains.Util.Media.JetPhysicalThickness>.Equals(JetPhysicalThickness other);
    [PureAttribute]
private static string ToString(JetPhysicalThickness& th, CultureInfo cultureInfo);
}
[IsReadOnlyAttribute]
[ValueSerializerAttribute("JetBrains.Util.Media.JetPhysicalVector/Serializer")]
public class JetBrains.Util.Media.JetPhysicalVector : ValueType {
    private int _x;
    private int _y;
    public int LengthSquared { get; }
    public int X { get; }
    public int Y { get; }
    public JetPhysicalVector(int x, int y);
    public int get_LengthSquared();
    public int get_X();
    public int get_Y();
    public static JetPhysicalVector Add(JetPhysicalVector vector1, JetPhysicalVector vector2);
    public static JetPhysicalPoint Add(JetPhysicalVector vector, JetPhysicalPoint point);
    public static int CrossProduct(JetPhysicalVector vector1, JetPhysicalVector vector2);
    public void Deconstruct(Int32& x, Int32& y);
    public static int Determinant(JetPhysicalVector vector1, JetPhysicalVector vector2);
    public static JetPhysicalVector Divide(JetPhysicalVector vector, double scalar);
    public static bool Equals(JetPhysicalVector vector1, JetPhysicalVector vector2);
    public virtual bool Equals(object o);
    public sealed virtual bool Equals(JetPhysicalVector value);
    public virtual int GetHashCode();
    public static JetPhysicalVector Multiply(JetPhysicalVector vector, double scalar);
    public static JetPhysicalVector Multiply(double scalar, JetPhysicalVector vector);
    public static double Multiply(JetPhysicalVector vector1, JetPhysicalVector vector2);
    public JetPhysicalVector Negated();
    public static JetPhysicalVector op_Addition(JetPhysicalVector vector1, JetPhysicalVector vector2);
    public static JetPhysicalPoint op_Addition(JetPhysicalVector vector, JetPhysicalPoint point);
    public static JetPhysicalVector op_Division(JetPhysicalVector vector, double scalar);
    public static bool op_Equality(JetPhysicalVector vector1, JetPhysicalVector vector2);
    public static JetPhysicalSize op_Explicit(JetPhysicalVector vector);
    public static JetPhysicalPoint op_Explicit(JetPhysicalVector vector);
    public static bool op_Inequality(JetPhysicalVector vector1, JetPhysicalVector vector2);
    public static JetPhysicalVector op_Multiply(JetPhysicalVector vector, double scalar);
    public static JetPhysicalVector op_Multiply(double scalar, JetPhysicalVector vector);
    public static int op_Multiply(JetPhysicalVector vector1, JetPhysicalVector vector2);
    public static JetPhysicalVector op_Subtraction(JetPhysicalVector vector1, JetPhysicalVector vector2);
    public static JetPhysicalVector op_UnaryNegation(JetPhysicalVector vector);
    public static JetPhysicalVector Parse(string source);
    public static JetPhysicalVector Subtract(JetPhysicalVector vector1, JetPhysicalVector vector2);
    [PureAttribute]
public JetVector ToLogicalVector(DpiResolution resolution);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    internal string ConvertToString(string format, IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
}
[IsReadOnlyAttribute]
[ValueSerializerAttribute("JetBrains.Util.Media.JetPoint/Serializer")]
public class JetBrains.Util.Media.JetPoint : ValueType {
    private double _x;
    private double _y;
    public double X { get; }
    public double Y { get; }
    public JetPoint(double x, double y);
    public double get_X();
    public double get_Y();
    [PureAttribute]
public static JetPoint Add(JetPoint& point, JetVector& vector);
    public void Deconstruct(Double& x, Double& y);
    [PureAttribute]
public static bool Equals(JetPoint& point1, JetPoint& point2);
    public virtual bool Equals(object o);
    [PureAttribute]
public bool Equals(JetPoint& value);
    public virtual int GetHashCode();
    [PureAttribute]
public static JetPoint Multiply(JetPoint& point, JetMatrix& matrix);
    [PureAttribute]
public JetPoint Offset(double offsetX, double offsetY);
    [PureAttribute]
public static JetPoint op_Addition(JetPoint& point, JetVector& vector);
    [PureAttribute]
public static bool op_Equality(JetPoint& point1, JetPoint& point2);
    [PureAttribute]
public static JetSize op_Explicit(JetPoint& point);
    [PureAttribute]
public static JetVector op_Explicit(JetPoint& point);
    [PureAttribute]
public static bool op_Inequality(JetPoint& point1, JetPoint& point2);
    [PureAttribute]
public static JetPoint op_Multiply(JetPoint& point, JetMatrix& matrix);
    [PureAttribute]
public static JetPoint op_Subtraction(JetPoint& point, JetVector& vector);
    [PureAttribute]
public static JetVector op_Subtraction(JetPoint& point1, JetPoint& point2);
    [PureAttribute]
public static JetPoint Parse(string source);
    [PureAttribute]
public static JetPoint Subtract(JetPoint& point, JetVector& vector);
    [PureAttribute]
public static JetVector Subtract(JetPoint& point1, JetPoint& point2);
    [PureAttribute]
public JetPhysicalPoint ToPhysicalPointCeiling(DpiResolution resolution);
    [PureAttribute]
public JetPhysicalPoint ToPhysicalPointFloor(DpiResolution resolution);
    [PureAttribute]
public JetPhysicalPoint ToPhysicalPointRounded(DpiResolution resolution);
    [PureAttribute]
public virtual string ToString();
    [PureAttribute]
public string ToString(IFormatProvider provider);
    [PureAttribute]
public JetPoint WithX(double x);
    [PureAttribute]
public JetPoint WithY(double y);
    [PureAttribute]
internal string ConvertToString(string format, IFormatProvider provider);
    private sealed virtual override bool System.IEquatable<JetBrains.Util.Media.JetPoint>.Equals(JetPoint other);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
}
[IsReadOnlyAttribute]
[ValueSerializerAttribute("JetBrains.Util.Media.JetRect/Serializer")]
public class JetBrains.Util.Media.JetRect : ValueType {
    private static JetRect s_empty;
    private double _height;
    private double _width;
    private double _x;
    private double _y;
    public double Bottom { get; }
    public JetPoint BottomLeft { get; }
    public JetPoint BottomRight { get; }
    public JetPoint Center { get; }
    public static JetRect Empty { get; }
    public double Height { get; }
    public bool IsEmpty { get; }
    public double Left { get; }
    public JetPoint Location { get; }
    public double Right { get; }
    public JetSize Size { get; }
    public double Top { get; }
    public JetPoint TopLeft { get; }
    public JetPoint TopRight { get; }
    public double Width { get; }
    public double X { get; }
    public double Y { get; }
    public JetRect(JetPoint location, JetSize size);
    public JetRect(double x, double y, double width, double height);
    public JetRect(JetPoint point1, JetPoint point2);
    public JetRect(JetPoint point, JetVector vector);
    public JetRect(JetSize size);
    private JetRect(Missing _);
    private static JetRect();
    public double get_Bottom();
    public JetPoint get_BottomLeft();
    public JetPoint get_BottomRight();
    public JetPoint get_Center();
    public static JetRect get_Empty();
    public double get_Height();
    public bool get_IsEmpty();
    public double get_Left();
    public JetPoint get_Location();
    public double get_Right();
    public JetSize get_Size();
    public double get_Top();
    public JetPoint get_TopLeft();
    public JetPoint get_TopRight();
    public double get_Width();
    public double get_X();
    public double get_Y();
    [PureAttribute]
public bool Contains(JetPoint point);
    [PureAttribute]
public bool Contains(double x, double y);
    [PureAttribute]
public bool Contains(JetRect& rect);
    public void Deconstruct(JetPoint& location, JetSize& size);
    [PureAttribute]
public static bool Equals(JetRect& rect1, JetRect& rect2);
    public virtual bool Equals(object o);
    [PureAttribute]
public bool Equals(JetRect& value);
    [PureAttribute]
public static JetRect FromLTRB(double left, double top, double right, double bottom);
    public virtual int GetHashCode();
    [PureAttribute]
public JetRect Inflated(JetSize size);
    [PureAttribute]
public JetRect Inflated(double width, double height);
    [PureAttribute]
public JetRect Intersected(JetRect& rect);
    public bool IntersectsWith(JetRect& rect);
    [PureAttribute]
public JetRect Offset(JetVector& offsetVector);
    [PureAttribute]
public JetRect Offset(double offsetX, double offsetY);
    [PureAttribute]
public static bool op_Equality(JetRect& rect1, JetRect& rect2);
    [PureAttribute]
public static bool op_Inequality(JetRect& rect1, JetRect& rect2);
    [PureAttribute]
public static JetRect Parse(string source);
    [PureAttribute]
public JetRect Scaled(double scaleX, double scaleY);
    [PureAttribute]
public JetPhysicalRect ToPhysicalRectCeiling(DpiResolution resolution);
    [PureAttribute]
public JetPhysicalRect ToPhysicalRectFloor(DpiResolution resolution);
    [PureAttribute]
public JetPhysicalRect ToPhysicalRectRounded(DpiResolution resolution);
    public virtual string ToString();
    [PureAttribute]
public string ToString(IFormatProvider provider);
    [PureAttribute]
public JetRect Transformed(JetMatrix& matrix);
    [PureAttribute]
public JetRect Unioned(JetRect& rect);
    [PureAttribute]
public JetRect Unioned(JetPoint point);
    [PureAttribute]
public JetRect WithLocation(JetPoint location);
    [PureAttribute]
public JetRect WithSize(JetSize size);
    [PureAttribute]
private bool ContainsInternal(double x, double y);
    [PureAttribute]
internal string ConvertToString(string format, IFormatProvider provider);
    private sealed virtual override bool System.IEquatable<JetBrains.Util.Media.JetRect>.Equals(JetRect other);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
}
[ExtensionAttribute]
public static class JetBrains.Util.Media.JetRects : object {
    public static ImmutableArray`1<JetDockStyle> AllSides;
    private static JetRects();
    [PureAttribute]
public static JetRect AlignedCenter(JetRect source, JetRect bounds);
    [PureAttribute]
public static JetRect AlignedCenter(JetSize source, JetRect bounds);
    [PureAttribute]
public static JetPhysicalRect AlignedCenter(JetPhysicalRect source, JetPhysicalRect bounds);
    [PureAttribute]
public static JetPhysicalRect AlignedCenter(JetPhysicalSize source, JetPhysicalRect bounds);
    [PureAttribute]
public static JetPhysicalRect AlignedCenterAndCropped(JetPhysicalRect source, JetPhysicalRect bounds);
    [PureAttribute]
public static JetPhysicalRect AlignedCenterAndCropped(JetPhysicalSize source, JetPhysicalRect bounds);
    [PureAttribute]
public static JetRect AlignedCenterAndCropped(JetRect source, JetRect bounds);
    [PureAttribute]
public static JetRect AlignedCenterAndCropped(JetSize source, JetRect bounds);
    [PureAttribute]
public static JetPhysicalRect AlignedCenterAndDownscaled(JetPhysicalRect source, JetPhysicalRect bounds);
    [PureAttribute]
public static JetRect AlignedCenterAndDownscaled(JetRect source, JetRect bounds);
    [PureAttribute]
public static JetPhysicalRect AlignedCenterAndDownscaled(JetPhysicalSize source, JetPhysicalRect bounds);
    [PureAttribute]
public static JetRect AlignedCenterAndDownscaled(JetSize source, JetRect bounds);
    [ExtensionAttribute]
[PureAttribute]
public static JetPhysicalRect AlignedWithinNoResize(JetPhysicalRect source, JetPhysicalRect bounds);
    [ExtensionAttribute]
[PureAttribute]
public static JetPhysicalRect AlignedWithinUsingMinSize(JetPhysicalRect source, JetPhysicalRect bounds, JetPhysicalSize minSize);
    [ExtensionAttribute]
[PureAttribute]
public static JetSize AssertIsReal(JetSize size, string failmessage);
    [ExtensionAttribute]
[PureAttribute]
public static JetRect AssertIsReal(JetRect rect, string failmessage);
    [ExtensionAttribute]
[PureAttribute]
public static JetSize AtLeast(JetSize source, JetSize minimum);
    [ExtensionAttribute]
[PureAttribute]
public static JetPhysicalSize AtLeast(JetPhysicalSize source, JetPhysicalSize minimum);
    [ExtensionAttribute]
[PureAttribute]
public static JetSize AtMost(JetSize source, JetSize maximum);
    [ExtensionAttribute]
[PureAttribute]
public static JetPhysicalSize AtMost(JetPhysicalSize source, JetPhysicalSize maximum);
    public static JetRect Attach(JetRect& anchor, JetDockStyle dockstyle, double size);
    public static JetRect Attach(JetRect& anchor, JetDockStyle dockstyle, JetSize size);
    [PureAttribute]
public static JetRect ClippedSmart(JetRect source, JetRect bounds);
    [PureAttribute]
public static JetPhysicalRect ClippedSmart(JetPhysicalRect source, JetPhysicalRect bounds);
    [PureAttribute]
public static double Collapse_Linear(double first, double second, Anchoring how);
    [PureAttribute]
public static int Collapse_Linear(int first, int second, Anchoring how);
    [ExtensionAttribute]
[PureAttribute]
public static JetPhysicalPoint Collapsed(JetPhysicalRect rectangle, Anchoring2D how);
    [ExtensionAttribute]
[PureAttribute]
public static JetPoint Collapsed(JetRect rectangle, Anchoring2D how);
    [ExtensionAttribute]
[PureAttribute]
public static JetSize Constrained(JetSize source, JetSize limit);
    [ExtensionAttribute]
[PureAttribute]
public static JetPhysicalSize Constrained(JetPhysicalSize source, JetPhysicalSize limit);
    [ExtensionAttribute]
[PureAttribute]
public static JetRect Deflated(JetRect source, JetThickness thickness);
    [ExtensionAttribute]
[PureAttribute]
public static JetPhysicalRect Deflated(JetPhysicalRect source, JetPhysicalThickness thickness);
    public static JetPhysicalRect Dock(JetPhysicalRect& space, JetDockStyle dock, int size);
    public static JetPhysicalRect Dock(JetPhysicalRect& space, Nullable`1<JetDockStyle> dock, JetPhysicalSize size);
    public static JetPhysicalRect Dock(JetPhysicalRect& space, Nullable`1<JetDockStyle> dock, JetPhysicalThickness thickness);
    public static JetRect Dock(JetRect& space, Nullable`1<JetDockStyle> dock, double size);
    public static JetRect Dock(JetRect& space, Nullable`1<JetDockStyle> dock, JetSize size);
    public static JetRect Dock(JetRect& space, Nullable`1<JetDockStyle> dock, JetThickness thickness);
    [ExtensionAttribute]
[PureAttribute]
public static JetPhysicalRect Docked(JetPhysicalRect space, JetDockStyle dockstyle, int size);
    [ExtensionAttribute]
[PureAttribute]
public static JetRect Docked(JetRect space, Nullable`1<JetDockStyle> dock, double size);
    [ExtensionAttribute]
[PureAttribute]
public static JetPhysicalRect Docked(JetPhysicalRect space, JetDockStyle dockstyle, JetPhysicalSize size);
    [ExtensionAttribute]
[PureAttribute]
public static JetRect Docked(JetRect space, Nullable`1<JetDockStyle> dock, JetSize size);
    [ExtensionAttribute]
[PureAttribute]
public static JetSize EnsuredEmptySize(JetSize size);
    [ExtensionAttribute]
[PureAttribute]
public static JetPhysicalSize EnsuredEmptySize(JetPhysicalSize size);
    [PureAttribute]
public static JetRect FromLtrbNonnegative(double left, double top, double right, double bottom);
    [PureAttribute]
public static JetPhysicalRect FromLtrbNonnegativePhysical(int left, int top, int right, int bottom);
    [ExtensionAttribute]
[PureAttribute]
public static JetPoint GetCenter(JetRect rect);
    [ExtensionAttribute]
[PureAttribute]
public static JetPhysicalPoint GetCenter(JetPhysicalRect rect);
    [ExtensionAttribute]
[PureAttribute]
public static JetPhysicalPoint GetCenter(RECT rect);
    [ExtensionAttribute]
[PureAttribute]
public static JetRect Inflated(JetRect source, JetThickness thickness);
    [ExtensionAttribute]
[PureAttribute]
public static JetPhysicalRect Inflated(JetPhysicalRect source, JetPhysicalThickness thickness);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsCollapsed(JetRect rect);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsCollapsed(Nullable`1<JetRect> rect);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsCollapsed(JetPhysicalRect rect);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsCollapsed(Nullable`1<JetPhysicalRect> rect);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsCollapsed(JetPhysicalSize size);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsCollapsed(JetSize size);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsCollapsed(RECT rect);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsNanOrInf(JetRect rect);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsNanOrInf(JetPoint pt);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsNanOrInf(JetSize size);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsNormalized(JetRect rect);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsNormalized(JetPhysicalSize size);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsNormalized(JetSize size);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsNormalized(JetPhysicalRect rect);
    [ExtensionAttribute]
[PureAttribute]
public static JetVector LeftTop(JetThickness thickness);
    [ExtensionAttribute]
[PureAttribute]
public static JetPhysicalVector LeftTop(JetPhysicalThickness thickness);
    [PureAttribute]
public static JetSize Max(JetSize α, JetSize β);
    [PureAttribute]
public static SIZE Max(SIZE α, SIZE β);
    [PureAttribute]
public static JetSize Min(JetSize α, JetSize β);
    [PureAttribute]
public static JetPhysicalSize Min(JetPhysicalSize α, JetPhysicalSize β);
    [ExtensionAttribute]
[PureAttribute]
public static JetRect Normalized(JetRect rect);
    [ExtensionAttribute]
[PureAttribute]
public static JetPhysicalRect Normalized(JetPhysicalRect rect);
    [ExtensionAttribute]
[PureAttribute]
public static JetSize Normalized(JetSize size);
    [ExtensionAttribute]
[PureAttribute]
public static JetPhysicalSize Normalized(JetPhysicalSize size);
    [PureAttribute]
public static JetPhysicalSize PhysicalSize(int width, int height);
    [PureAttribute]
public static JetSize Size(double width, double height);
    [PureAttribute]
public static SIZE SIZE(int width, int height);
    [PureAttribute]
public static JetSize StackHorizontally(double gap, JetSize[] sizes);
    [PureAttribute]
public static JetPhysicalSize StackHorizontally(int gap, JetPhysicalSize[] sizes);
    [PureAttribute]
public static JetSize StackVertically(double gap, JetSize[] sizes);
    [PureAttribute]
public static JetPhysicalSize StackVertically(int gap, JetPhysicalSize[] sizes);
    [PureAttribute]
public static JetPhysicalRect UnionedHorizontally(JetPhysicalRect source, JetPhysicalRect other);
    [PureAttribute]
public static JetRect UnionedHorizontally(JetRect source, JetRect other);
    [PureAttribute]
public static JetPhysicalRect UnionedVertically(JetPhysicalRect source, JetPhysicalRect other);
    [PureAttribute]
public static JetRect UnionedVertically(JetRect source, JetRect other);
    [ExtensionAttribute]
[PureAttribute]
public static JetRect WithBottom(JetRect& rect, double bottom);
    [ExtensionAttribute]
[PureAttribute]
public static JetPhysicalRect WithBottom(JetPhysicalRect& rect, int bottom);
    [ExtensionAttribute]
[PureAttribute]
public static JetRect WithHeight(JetRect& rect, double height);
    [ExtensionAttribute]
[PureAttribute]
public static JetPhysicalRect WithHeight(JetPhysicalRect& rect, int height);
    [ExtensionAttribute]
[PureAttribute]
public static JetRect WithLeft(JetRect& rect, double left);
    [ExtensionAttribute]
[PureAttribute]
public static JetPhysicalRect WithLeft(JetPhysicalRect& rect, int left);
    [ExtensionAttribute]
[PureAttribute]
public static JetRect WithRight(JetRect& rect, double right);
    [ExtensionAttribute]
[PureAttribute]
public static JetPhysicalRect WithRight(JetPhysicalRect& rect, int right);
    [ExtensionAttribute]
[PureAttribute]
public static JetRect WithTop(JetRect& rect, double top);
    [ExtensionAttribute]
[PureAttribute]
public static JetPhysicalRect WithTop(JetPhysicalRect& rect, int top);
    [ExtensionAttribute]
[PureAttribute]
public static JetRect WithWidth(JetRect& rect, double width);
    [ExtensionAttribute]
[PureAttribute]
public static JetPhysicalRect WithWidth(JetPhysicalRect& rect, int width);
    [ExtensionAttribute]
[PureAttribute]
public static JetRect WithX(JetRect& rect, double x);
    [ExtensionAttribute]
[PureAttribute]
public static JetPhysicalRect WithX(JetPhysicalRect& rect, int x);
    [ExtensionAttribute]
[PureAttribute]
public static JetRect WithY(JetRect& rect, double y);
    [ExtensionAttribute]
[PureAttribute]
public static JetPhysicalRect WithY(JetPhysicalRect& rect, int y);
    [PureAttribute]
internal static int LogicalToPhysicalLength_Ceiling(double length, double dpi);
    [PureAttribute]
internal static int LogicalToPhysicalLength_Floor(double length, double dpi);
    [PureAttribute]
internal static int LogicalToPhysicalLength_Round(double length, double dpi);
    [PureAttribute]
internal static double PhysicalToLogicalLength(int length, double dpi);
    [PureAttribute]
private static JetPhysicalSize StackImplJPS(IEnumerable`1<JetPhysicalSize> sizes, int gap, bool isHorizontallyNotVertically);
    [PureAttribute]
private static JetSize StackImplJS(IEnumerable`1<JetSize> sizes, double gap, bool isHorizontallyNotVertically);
}
[IsReadOnlyAttribute]
[ValueSerializerAttribute("JetBrains.Util.Media.JetRgbaColor/Serializer")]
public class JetBrains.Util.Media.JetRgbaColor : ValueType {
    [NotNullAttribute]
public static Comparers Comparer;
    public byte B;
    public byte G;
    public byte R;
    public byte A;
    public JetRgbaColor(byte r, byte g, byte b, byte a);
    private static JetRgbaColor();
    [PureAttribute]
public sealed virtual bool Equals(JetRgbaColor other);
    [PureAttribute]
public virtual bool Equals(object obj);
    [PureAttribute]
public virtual int GetHashCode();
    [PureAttribute]
public static bool op_Equality(JetRgbaColor left, JetRgbaColor right);
    [PureAttribute]
public static bool op_Inequality(JetRgbaColor left, JetRgbaColor right);
    [PureAttribute]
public sealed virtual int CompareTo(JetRgbaColor other);
    [PureAttribute]
private sealed virtual override int System.IComparable.CompareTo(object obj);
    [PureAttribute]
public void Deconstruct(Byte& r, Byte& g, Byte& b, Byte& a);
    [PureAttribute]
public static UInt32 op_Explicit(JetRgbaColor color);
    [PureAttribute]
public static JetRgbaColor op_Explicit(UInt32 dword);
    [PureAttribute]
public static string op_Explicit(JetRgbaColor color);
    [PureAttribute]
public static JetRgbaColor op_Explicit(ReadOnlySpan`1<char> text);
    [PureAttribute]
public static bool TryParseAny(ReadOnlySpan`1& text, JetRgbaColor& parsed);
    [PureAttribute]
public static bool TryParseHex(ReadOnlySpan`1& text, JetRgbaColor& parsed);
    [PureAttribute]
public static JetRgbaColor op_Explicit(string text);
    [PureAttribute]
public virtual string ToString();
    [PureAttribute]
public static JetRgbaColor FromArgb(byte a, byte r, byte g, byte b);
    [PureAttribute]
public static JetRgbaColor From_BB_GG_RR_AA(UInt32 binary);
    [PureAttribute]
public static JetRgbaColor From_BB_GG_RR(UInt32 binary);
    [PureAttribute]
public UInt32 To_BB_GG_RR_AA();
    [PureAttribute]
public static JetRgbaColor FromRgb(byte r, byte g, byte b);
    [PureAttribute]
public static JetRgbaColor FromRgba(byte r, byte g, byte b, byte a);
    [PureAttribute]
public JetRgbaColor WithA(byte a);
    [PureAttribute]
public JetRgbaColor WithR(byte r);
    [PureAttribute]
public JetRgbaColor WithG(byte g);
    [PureAttribute]
public JetRgbaColor WithB(byte b);
}
public static class JetBrains.Util.Media.JetRgbaColors : object {
    public static JetRgbaColor AliceBlue { get; }
    public static JetRgbaColor AntiqueWhite { get; }
    public static JetRgbaColor Aqua { get; }
    public static JetRgbaColor Aquamarine { get; }
    public static JetRgbaColor Azure { get; }
    public static JetRgbaColor Beige { get; }
    public static JetRgbaColor Bisque { get; }
    public static JetRgbaColor Black { get; }
    public static JetRgbaColor BlanchedAlmond { get; }
    public static JetRgbaColor Blue { get; }
    public static JetRgbaColor BlueViolet { get; }
    public static JetRgbaColor Brown { get; }
    public static JetRgbaColor BurlyWood { get; }
    public static JetRgbaColor CadetBlue { get; }
    public static JetRgbaColor Chartreuse { get; }
    public static JetRgbaColor Chocolate { get; }
    public static JetRgbaColor Coral { get; }
    public static JetRgbaColor CornflowerBlue { get; }
    public static JetRgbaColor Cornsilk { get; }
    public static JetRgbaColor Crimson { get; }
    public static JetRgbaColor Cyan { get; }
    public static JetRgbaColor DarkBlue { get; }
    public static JetRgbaColor DarkCyan { get; }
    public static JetRgbaColor DarkGoldenrod { get; }
    public static JetRgbaColor DarkGray { get; }
    public static JetRgbaColor DarkGreen { get; }
    public static JetRgbaColor DarkKhaki { get; }
    public static JetRgbaColor DarkMagenta { get; }
    public static JetRgbaColor DarkOliveGreen { get; }
    public static JetRgbaColor DarkOrange { get; }
    public static JetRgbaColor DarkOrchid { get; }
    public static JetRgbaColor DarkRed { get; }
    public static JetRgbaColor DarkSalmon { get; }
    public static JetRgbaColor DarkSeaGreen { get; }
    public static JetRgbaColor DarkSlateBlue { get; }
    public static JetRgbaColor DarkSlateGray { get; }
    public static JetRgbaColor DarkTurquoise { get; }
    public static JetRgbaColor DarkViolet { get; }
    public static JetRgbaColor DeepPink { get; }
    public static JetRgbaColor DeepSkyBlue { get; }
    public static JetRgbaColor DimGray { get; }
    public static JetRgbaColor DodgerBlue { get; }
    public static JetRgbaColor Firebrick { get; }
    public static JetRgbaColor FloralWhite { get; }
    public static JetRgbaColor ForestGreen { get; }
    public static JetRgbaColor Fuchsia { get; }
    public static JetRgbaColor Gainsboro { get; }
    public static JetRgbaColor GhostWhite { get; }
    public static JetRgbaColor Gold { get; }
    public static JetRgbaColor Goldenrod { get; }
    public static JetRgbaColor Gray { get; }
    public static JetRgbaColor Green { get; }
    public static JetRgbaColor GreenYellow { get; }
    public static JetRgbaColor Honeydew { get; }
    public static JetRgbaColor HotPink { get; }
    public static JetRgbaColor IndianRed { get; }
    public static JetRgbaColor Indigo { get; }
    public static JetRgbaColor Ivory { get; }
    public static JetRgbaColor Khaki { get; }
    public static JetRgbaColor Lavender { get; }
    public static JetRgbaColor LavenderBlush { get; }
    public static JetRgbaColor LawnGreen { get; }
    public static JetRgbaColor LemonChiffon { get; }
    public static JetRgbaColor LightBlue { get; }
    public static JetRgbaColor LightCoral { get; }
    public static JetRgbaColor LightCyan { get; }
    public static JetRgbaColor LightGoldenrodYellow { get; }
    public static JetRgbaColor LightGray { get; }
    public static JetRgbaColor LightGreen { get; }
    public static JetRgbaColor LightPink { get; }
    public static JetRgbaColor LightSalmon { get; }
    public static JetRgbaColor LightSeaGreen { get; }
    public static JetRgbaColor LightSkyBlue { get; }
    public static JetRgbaColor LightSlateGray { get; }
    public static JetRgbaColor LightSteelBlue { get; }
    public static JetRgbaColor LightYellow { get; }
    public static JetRgbaColor Lime { get; }
    public static JetRgbaColor LimeGreen { get; }
    public static JetRgbaColor Linen { get; }
    public static JetRgbaColor Magenta { get; }
    public static JetRgbaColor Maroon { get; }
    public static JetRgbaColor MediumAquamarine { get; }
    public static JetRgbaColor MediumBlue { get; }
    public static JetRgbaColor MediumOrchid { get; }
    public static JetRgbaColor MediumPurple { get; }
    public static JetRgbaColor MediumSeaGreen { get; }
    public static JetRgbaColor MediumSlateBlue { get; }
    public static JetRgbaColor MediumSpringGreen { get; }
    public static JetRgbaColor MediumTurquoise { get; }
    public static JetRgbaColor MediumVioletRed { get; }
    public static JetRgbaColor MidnightBlue { get; }
    public static JetRgbaColor MintCream { get; }
    public static JetRgbaColor MistyRose { get; }
    public static JetRgbaColor Moccasin { get; }
    public static JetRgbaColor NavajoWhite { get; }
    public static JetRgbaColor Navy { get; }
    public static JetRgbaColor OldLace { get; }
    public static JetRgbaColor Olive { get; }
    public static JetRgbaColor OliveDrab { get; }
    public static JetRgbaColor Orange { get; }
    public static JetRgbaColor OrangeRed { get; }
    public static JetRgbaColor Orchid { get; }
    public static JetRgbaColor PaleGoldenrod { get; }
    public static JetRgbaColor PaleGreen { get; }
    public static JetRgbaColor PaleTurquoise { get; }
    public static JetRgbaColor PaleVioletRed { get; }
    public static JetRgbaColor PapayaWhip { get; }
    public static JetRgbaColor PeachPuff { get; }
    public static JetRgbaColor Peru { get; }
    public static JetRgbaColor Pink { get; }
    public static JetRgbaColor Plum { get; }
    public static JetRgbaColor PowderBlue { get; }
    public static JetRgbaColor Purple { get; }
    public static JetRgbaColor Red { get; }
    public static JetRgbaColor RosyBrown { get; }
    public static JetRgbaColor RoyalBlue { get; }
    public static JetRgbaColor SaddleBrown { get; }
    public static JetRgbaColor Salmon { get; }
    public static JetRgbaColor SandyBrown { get; }
    public static JetRgbaColor SeaGreen { get; }
    public static JetRgbaColor SeaShell { get; }
    public static JetRgbaColor Sienna { get; }
    public static JetRgbaColor Silver { get; }
    public static JetRgbaColor SkyBlue { get; }
    public static JetRgbaColor SlateBlue { get; }
    public static JetRgbaColor SlateGray { get; }
    public static JetRgbaColor Snow { get; }
    public static JetRgbaColor SpringGreen { get; }
    public static JetRgbaColor SteelBlue { get; }
    public static JetRgbaColor Tan { get; }
    public static JetRgbaColor Teal { get; }
    public static JetRgbaColor Thistle { get; }
    public static JetRgbaColor Tomato { get; }
    public static JetRgbaColor Transparent { get; }
    public static JetRgbaColor Turquoise { get; }
    public static JetRgbaColor Violet { get; }
    public static JetRgbaColor Wheat { get; }
    public static JetRgbaColor White { get; }
    public static JetRgbaColor WhiteSmoke { get; }
    public static JetRgbaColor Yellow { get; }
    public static JetRgbaColor YellowGreen { get; }
    public static JetRgbaColor get_AliceBlue();
    public static JetRgbaColor get_AntiqueWhite();
    public static JetRgbaColor get_Aqua();
    public static JetRgbaColor get_Aquamarine();
    public static JetRgbaColor get_Azure();
    public static JetRgbaColor get_Beige();
    public static JetRgbaColor get_Bisque();
    public static JetRgbaColor get_Black();
    public static JetRgbaColor get_BlanchedAlmond();
    public static JetRgbaColor get_Blue();
    public static JetRgbaColor get_BlueViolet();
    public static JetRgbaColor get_Brown();
    public static JetRgbaColor get_BurlyWood();
    public static JetRgbaColor get_CadetBlue();
    public static JetRgbaColor get_Chartreuse();
    public static JetRgbaColor get_Chocolate();
    public static JetRgbaColor get_Coral();
    public static JetRgbaColor get_CornflowerBlue();
    public static JetRgbaColor get_Cornsilk();
    public static JetRgbaColor get_Crimson();
    public static JetRgbaColor get_Cyan();
    public static JetRgbaColor get_DarkBlue();
    public static JetRgbaColor get_DarkCyan();
    public static JetRgbaColor get_DarkGoldenrod();
    public static JetRgbaColor get_DarkGray();
    public static JetRgbaColor get_DarkGreen();
    public static JetRgbaColor get_DarkKhaki();
    public static JetRgbaColor get_DarkMagenta();
    public static JetRgbaColor get_DarkOliveGreen();
    public static JetRgbaColor get_DarkOrange();
    public static JetRgbaColor get_DarkOrchid();
    public static JetRgbaColor get_DarkRed();
    public static JetRgbaColor get_DarkSalmon();
    public static JetRgbaColor get_DarkSeaGreen();
    public static JetRgbaColor get_DarkSlateBlue();
    public static JetRgbaColor get_DarkSlateGray();
    public static JetRgbaColor get_DarkTurquoise();
    public static JetRgbaColor get_DarkViolet();
    public static JetRgbaColor get_DeepPink();
    public static JetRgbaColor get_DeepSkyBlue();
    public static JetRgbaColor get_DimGray();
    public static JetRgbaColor get_DodgerBlue();
    public static JetRgbaColor get_Firebrick();
    public static JetRgbaColor get_FloralWhite();
    public static JetRgbaColor get_ForestGreen();
    public static JetRgbaColor get_Fuchsia();
    public static JetRgbaColor get_Gainsboro();
    public static JetRgbaColor get_GhostWhite();
    public static JetRgbaColor get_Gold();
    public static JetRgbaColor get_Goldenrod();
    public static JetRgbaColor get_Gray();
    public static JetRgbaColor get_Green();
    public static JetRgbaColor get_GreenYellow();
    public static JetRgbaColor get_Honeydew();
    public static JetRgbaColor get_HotPink();
    public static JetRgbaColor get_IndianRed();
    public static JetRgbaColor get_Indigo();
    public static JetRgbaColor get_Ivory();
    public static JetRgbaColor get_Khaki();
    public static JetRgbaColor get_Lavender();
    public static JetRgbaColor get_LavenderBlush();
    public static JetRgbaColor get_LawnGreen();
    public static JetRgbaColor get_LemonChiffon();
    public static JetRgbaColor get_LightBlue();
    public static JetRgbaColor get_LightCoral();
    public static JetRgbaColor get_LightCyan();
    public static JetRgbaColor get_LightGoldenrodYellow();
    public static JetRgbaColor get_LightGray();
    public static JetRgbaColor get_LightGreen();
    public static JetRgbaColor get_LightPink();
    public static JetRgbaColor get_LightSalmon();
    public static JetRgbaColor get_LightSeaGreen();
    public static JetRgbaColor get_LightSkyBlue();
    public static JetRgbaColor get_LightSlateGray();
    public static JetRgbaColor get_LightSteelBlue();
    public static JetRgbaColor get_LightYellow();
    public static JetRgbaColor get_Lime();
    public static JetRgbaColor get_LimeGreen();
    public static JetRgbaColor get_Linen();
    public static JetRgbaColor get_Magenta();
    public static JetRgbaColor get_Maroon();
    public static JetRgbaColor get_MediumAquamarine();
    public static JetRgbaColor get_MediumBlue();
    public static JetRgbaColor get_MediumOrchid();
    public static JetRgbaColor get_MediumPurple();
    public static JetRgbaColor get_MediumSeaGreen();
    public static JetRgbaColor get_MediumSlateBlue();
    public static JetRgbaColor get_MediumSpringGreen();
    public static JetRgbaColor get_MediumTurquoise();
    public static JetRgbaColor get_MediumVioletRed();
    public static JetRgbaColor get_MidnightBlue();
    public static JetRgbaColor get_MintCream();
    public static JetRgbaColor get_MistyRose();
    public static JetRgbaColor get_Moccasin();
    public static JetRgbaColor get_NavajoWhite();
    public static JetRgbaColor get_Navy();
    public static JetRgbaColor get_OldLace();
    public static JetRgbaColor get_Olive();
    public static JetRgbaColor get_OliveDrab();
    public static JetRgbaColor get_Orange();
    public static JetRgbaColor get_OrangeRed();
    public static JetRgbaColor get_Orchid();
    public static JetRgbaColor get_PaleGoldenrod();
    public static JetRgbaColor get_PaleGreen();
    public static JetRgbaColor get_PaleTurquoise();
    public static JetRgbaColor get_PaleVioletRed();
    public static JetRgbaColor get_PapayaWhip();
    public static JetRgbaColor get_PeachPuff();
    public static JetRgbaColor get_Peru();
    public static JetRgbaColor get_Pink();
    public static JetRgbaColor get_Plum();
    public static JetRgbaColor get_PowderBlue();
    public static JetRgbaColor get_Purple();
    public static JetRgbaColor get_Red();
    public static JetRgbaColor get_RosyBrown();
    public static JetRgbaColor get_RoyalBlue();
    public static JetRgbaColor get_SaddleBrown();
    public static JetRgbaColor get_Salmon();
    public static JetRgbaColor get_SandyBrown();
    public static JetRgbaColor get_SeaGreen();
    public static JetRgbaColor get_SeaShell();
    public static JetRgbaColor get_Sienna();
    public static JetRgbaColor get_Silver();
    public static JetRgbaColor get_SkyBlue();
    public static JetRgbaColor get_SlateBlue();
    public static JetRgbaColor get_SlateGray();
    public static JetRgbaColor get_Snow();
    public static JetRgbaColor get_SpringGreen();
    public static JetRgbaColor get_SteelBlue();
    public static JetRgbaColor get_Tan();
    public static JetRgbaColor get_Teal();
    public static JetRgbaColor get_Thistle();
    public static JetRgbaColor get_Tomato();
    public static JetRgbaColor get_Transparent();
    public static JetRgbaColor get_Turquoise();
    public static JetRgbaColor get_Violet();
    public static JetRgbaColor get_Wheat();
    public static JetRgbaColor get_White();
    public static JetRgbaColor get_WhiteSmoke();
    public static JetRgbaColor get_Yellow();
    public static JetRgbaColor get_YellowGreen();
    public static Nullable`1<JetRgbaColor> FromKnownColorName(string name);
}
[IsReadOnlyAttribute]
[ValueSerializerAttribute("JetBrains.Util.Media.JetSize/Serializer")]
public class JetBrains.Util.Media.JetSize : ValueType {
    private static JetSize s_empty;
    internal double _height;
    internal double _width;
    public static JetSize Empty { get; }
    public double Height { get; }
    public bool IsEmpty { get; }
    public double Width { get; }
    public JetSize(double width, double height);
    private JetSize(Missing _);
    private static JetSize();
    public static JetSize get_Empty();
    public double get_Height();
    public bool get_IsEmpty();
    public double get_Width();
    public void Deconstruct(Double& width, Double& height);
    [PureAttribute]
public static bool Equals(JetSize size1, JetSize size2);
    public virtual bool Equals(object o);
    [PureAttribute]
public sealed virtual bool Equals(JetSize value);
    public static JetSize FromDeviceDependent(double widthDevice, double heightDevice, DpiResolution dpi);
    public virtual int GetHashCode();
    public static JetSize op_Addition(JetSize size1, JetSize size2);
    [PureAttribute]
public static bool op_Equality(JetSize size1, JetSize size2);
    [PureAttribute]
public static JetVector op_Explicit(JetSize size);
    [PureAttribute]
public static JetPoint op_Explicit(JetSize size);
    [PureAttribute]
public static bool op_Inequality(JetSize size1, JetSize size2);
    public static JetSize op_Subtraction(JetSize size1, JetSize size2);
    [PureAttribute]
public static JetSize Parse(string source);
    [PureAttribute]
public JetPhysicalSize ToPhysicalSizeCeiling(DpiResolution resolution);
    [PureAttribute]
public JetPhysicalSize ToPhysicalSizeFloor(DpiResolution resolution);
    [PureAttribute]
public JetPhysicalSize ToPhysicalSizeRounded(DpiResolution resolution);
    public virtual string ToString();
    [PureAttribute]
public string ToString(IFormatProvider provider);
    public JetSize WithHeight(double height);
    public JetSize WithWidth(double width);
    [PureAttribute]
internal string ConvertToString(string format, IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
}
[IsReadOnlyAttribute]
[ValueSerializerAttribute("JetBrains.Util.Reflection.SimpleValueSerializer`1<JetBrains.Util.Media.JetThickness>")]
public class JetBrains.Util.Media.JetThickness : ValueType {
    public static JetThickness Empty;
    private double _Bottom;
    private double _Left;
    private double _Right;
    private double _Top;
    public double Bottom { get; }
    public bool IsNonnegative { get; }
    public bool IsUniform { get; }
    public bool IsZero { get; }
    public double Left { get; }
    public double Right { get; }
    public double Top { get; }
    public JetSize TotalSize { get; }
    public JetThickness(string text);
    public JetThickness(double uniformLength);
    public JetThickness(double leftright, double topbottom);
    public JetThickness(double left, double top, double right, double bottom);
    private static JetThickness();
    public double get_Bottom();
    [PureAttribute]
public bool get_IsNonnegative();
    [PureAttribute]
public bool get_IsUniform();
    [PureAttribute]
public bool get_IsZero();
    public double get_Left();
    public double get_Right();
    public double get_Top();
    public JetSize get_TotalSize();
    public void Deconstruct(Double& left, Double& top, Double& right, Double& bottom);
    public virtual bool Equals(object obj);
    public bool Equals(JetThickness& thickness);
    public virtual int GetHashCode();
    [PureAttribute]
public static JetThickness op_Addition(JetThickness& t1, JetThickness& t2);
    [PureAttribute]
public static bool op_Equality(JetThickness& t1, JetThickness& t2);
    [PureAttribute]
public static bool op_Inequality(JetThickness& t1, JetThickness& t2);
    [PureAttribute]
public static JetThickness op_Subtraction(JetThickness& t1, JetThickness& t2);
    [PureAttribute]
public static JetThickness op_UnaryNegation(JetThickness& t1);
    [PureAttribute]
public JetPhysicalThickness ToPhysicalThicknessCeiling(DpiResolution resolution);
    [PureAttribute]
public JetPhysicalThickness ToPhysicalThicknessFloor(DpiResolution resolution);
    [PureAttribute]
public JetPhysicalThickness ToPhysicalThicknessRounded(DpiResolution resolution);
    public virtual string ToString();
    [PureAttribute]
internal static bool AreClose(JetThickness& thickness0, JetThickness& thickness1);
    private sealed virtual override bool System.IEquatable<JetBrains.Util.Media.JetThickness>.Equals(JetThickness other);
    [PureAttribute]
private bool IsClose(JetThickness& thickness);
    [PureAttribute]
internal bool IsValid(bool allowNegative, bool allowNaN, bool allowPositiveInfinity, bool allowNegativeInfinity);
    [PureAttribute]
private static string ToString(JetThickness& th, CultureInfo cultureInfo);
}
[IsReadOnlyAttribute]
[ValueSerializerAttribute("JetBrains.Util.Media.JetVector/Serializer")]
public class JetBrains.Util.Media.JetVector : ValueType {
    private double _x;
    private double _y;
    public double Length { get; }
    public double LengthSquared { get; }
    public double X { get; }
    public double Y { get; }
    public JetVector(double x, double y);
    public double get_Length();
    public double get_LengthSquared();
    public double get_X();
    public double get_Y();
    public static JetVector Add(JetVector vector1, JetVector vector2);
    public static JetPoint Add(JetVector vector, JetPoint point);
    public static double AngleBetweenInDeg(JetVector vector1, JetVector vector2);
    public static double CrossProduct(JetVector vector1, JetVector vector2);
    public void Deconstruct(Double& x, Double& y);
    public static double Determinant(JetVector vector1, JetVector vector2);
    public static JetVector Divide(JetVector vector, double scalar);
    public static bool Equals(JetVector vector1, JetVector vector2);
    public virtual bool Equals(object o);
    public sealed virtual bool Equals(JetVector value);
    public virtual int GetHashCode();
    public static JetVector Multiply(JetVector vector, double scalar);
    public static JetVector Multiply(double scalar, JetVector vector);
    public static JetVector Multiply(JetVector vector, JetMatrix matrix);
    public static double Multiply(JetVector vector1, JetVector vector2);
    public JetVector Negated();
    public JetVector Normalized();
    public static JetVector op_Addition(JetVector vector1, JetVector vector2);
    public static JetPoint op_Addition(JetVector vector, JetPoint point);
    public static JetVector op_Division(JetVector vector, double scalar);
    public static bool op_Equality(JetVector vector1, JetVector vector2);
    public static JetSize op_Explicit(JetVector vector);
    public static JetPoint op_Explicit(JetVector vector);
    public static bool op_Inequality(JetVector vector1, JetVector vector2);
    public static JetVector op_Multiply(JetVector vector, double scalar);
    public static JetVector op_Multiply(double scalar, JetVector vector);
    public static JetVector op_Multiply(JetVector vector, JetMatrix matrix);
    public static double op_Multiply(JetVector vector1, JetVector vector2);
    public static JetVector op_Subtraction(JetVector vector1, JetVector vector2);
    public static JetVector op_UnaryNegation(JetVector vector);
    public static JetVector Parse(string source);
    public static JetVector Subtract(JetVector vector1, JetVector vector2);
    [PureAttribute]
public JetPhysicalVector ToPhysicalVectorCeiling(DpiResolution resolution);
    [PureAttribute]
public JetPhysicalVector ToPhysicalVectorFloor(DpiResolution resolution);
    [PureAttribute]
public JetPhysicalVector ToPhysicalVectorRounded(DpiResolution resolution);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    internal string ConvertToString(string format, IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
}
[ExtensionAttribute]
public static class JetBrains.Util.Media.WinApiInterop : object {
    [ExtensionAttribute]
[PureAttribute]
public static JetPhysicalPoint ToJetPhysicalPoint(POINT pt);
    [ExtensionAttribute]
[PureAttribute]
public static Nullable`1<JetPhysicalPoint> ToJetPhysicalPoint(Nullable`1<POINT> pt);
    [ExtensionAttribute]
[PureAttribute]
public static JetPhysicalRect ToJetPhysicalRect(RECT rc);
    [ExtensionAttribute]
[PureAttribute]
public static JetPhysicalSize ToJetPhysicalSize(SIZE size);
    [ExtensionAttribute]
[PureAttribute]
public static POINT ToWinApiPOINT(POINT pt);
    [ExtensionAttribute]
[PureAttribute]
public static POINT ToWinApiPOINT(JetPhysicalPoint pt);
    [ExtensionAttribute]
[PureAttribute]
public static RECT ToWinApiRECT(JetPhysicalRect rect);
    [ExtensionAttribute]
[PureAttribute]
public static RECT ToWinApiRECT(RECT rect);
    [ExtensionAttribute]
[PureAttribute]
public static SIZE ToWinApiSIZE(SIZE size);
    [ExtensionAttribute]
[PureAttribute]
public static SIZE ToWinApiSIZE(JetPhysicalSize size);
}
public interface JetBrains.Util.Memory.IMemoryGrave {
    public int SurvivorsCount { get; }
    public abstract virtual void AddObject(object obj);
    public abstract virtual int get_SurvivorsCount();
}
public interface JetBrains.Util.Memory.IMemoryGraveProvider {
    [NotNullAttribute]
public abstract virtual IMemoryGrave GetOrCreateMemoryGrave();
}
public static class JetBrains.Util.Memory.LeakWatchdog : object {
    private static IDictionaryEvents`2<Lifetime, Grave> ourLifetimesToGraves;
    private static ICollectionEvents`1<Grave> ourWaitingGraves;
    private static ICollectionEvents`1<Grave> ourSurvivedGraves;
    private static SpinWaitLock ourLock;
    private static TimeSpan ourTimerInterval;
    private static TimeSpan ourGcInterval;
    [CanBeNullAttribute]
private static object ourTimerCookie;
    private static bool ourIsShutdown;
    private static int ourIsCallbackExecuted;
    private static int ourLastGcCount;
    private static DateTime ourLastGcDateTime;
    private static ILogger ourLogger;
    private static LeakWatchdog();
    [NotNullAttribute]
public static IMemoryGrave GetOrCreateGrave(Lifetime lifetime, string graveName);
    public static void RegisterObject(Lifetime lifetime, object obj, string graveName);
    public static void RegisterTerminatedObject(object obj, TimeSpan timeout, Mode mode, Action`1<bool> onFinish);
    public static ICollection`1<IMemoryGrave> GeSurvivedGraves();
    public static void ClearSurvivedGraves();
    public static void DumpSurvivors(StringBuilder sb);
    public static void ShutDown();
    [HandleProcessCorruptedStateExceptionsAttribute]
private static void OurTimerCallback(object cookie);
    private static bool SweepWaitingGraves();
    private static void SweepSurvivedGraves();
    private static void LogGrave(Grave grave, string message);
    private static int GetCurrentGcCount();
    private static void ForceGc();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.Util.Memory.MemoryInfoUtil : object {
    [NullableContextAttribute("2")]
public static void AddMemoryInfoToOutOfMemoryException(Exception ex);
    public static string GetGlobalMemoryStatusString();
    [LocalizableAttribute("False")]
public static ValueTuple`2<Nullable`1<PROCESS_MEMORY_COUNTERS_EX>, string> GetProcessMemoryInfo();
    public static string GetProcessMemoryInfoString();
    [CompilerGeneratedAttribute]
internal static string <GetGlobalMemoryStatusString>g__FormatSize|1_0(ulong val);
    [CompilerGeneratedAttribute]
internal static string <GetProcessMemoryInfoString>g__FormatSize|3_0(UIntPtr val);
}
public class JetBrains.Util.Memory.SystemMemoryInfo : object {
    [CompilerGeneratedAttribute]
private ulong <PhysicalTotal>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <PhysicalAvailable>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <SwappableTotal>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <SwappableAvailable>k__BackingField;
    private static IMemoryInfoProvider ourImpl;
    public ulong PhysicalTotal { get; }
    public ulong PhysicalAvailable { get; }
    public ulong SwappableTotal { get; }
    public ulong SwappableAvailable { get; }
    private SystemMemoryInfo(ulong physicalTotal, ulong physicalAvailable, ulong swappableTotal, ulong swappableAvailable);
    private static SystemMemoryInfo();
    [CompilerGeneratedAttribute]
public ulong get_PhysicalTotal();
    [CompilerGeneratedAttribute]
public ulong get_PhysicalAvailable();
    [CompilerGeneratedAttribute]
public ulong get_SwappableTotal();
    [CompilerGeneratedAttribute]
public ulong get_SwappableAvailable();
    public static SystemMemoryInfo Get();
}
public class JetBrains.Util.MemoryMappedFileSharedMemory : SharedMemory {
    private Func`2<MemoryMappedFileSharedMemory, long> myGetConfiguredSize;
    private MemoryMappedFile myMemoryMappedFile;
    private MemoryMappedViewAccessor myAccessor;
    public long ConfiguredSize { get; }
    public MemoryMappedFileSharedMemory(Lifetime lifetime, Lifetime globalLifetime, string uniqueIdentifier, long maxSize, Func`2<MemoryMappedFileSharedMemory, long> getConfiguredSize);
    public virtual long get_ConfiguredSize();
    protected virtual Byte* MapImpl(long size);
    protected virtual void UnmapImpl();
    protected virtual void DeleteImpl();
}
public static class JetBrains.Util.MessageBox : object {
    public static DialogBoxCommandId ShowCore(Void* window, string text, string caption, MessageBoxFlags flags);
    public static void ShowError(string text, string caption);
    public static void ShowError(string text, string caption, IntPtr window);
    public static void ShowExclamation(string text, string caption);
    public static void ShowExclamation(string text, string caption, IntPtr window);
    public static void ShowInfo(string text, string caption);
    public static void ShowInfo(string text, string caption, IntPtr window);
    public static DialogBoxCommandId ShowMessageBox(string text, string caption, IntPtr window, MbButton button, MbIcon icon);
    public static DialogBoxCommandId ShowMessageBox(string text, string caption, MbButton button, MbIcon icon);
    public static DialogBoxCommandId ShowMessageBox(string text, MbButton button, MbIcon icon);
    public static bool ShowOKCancel(string text, string caption);
    public static bool ShowOKCancel(string text, string caption, IntPtr window);
    public static bool ShowOKCancel(string text, string caption, IntPtr window, bool defaultButton);
    public static bool ShowYesNo(string text, string caption, bool alwaysOnTop);
    public static bool ShowYesNo(string text, string caption, IntPtr window, bool alwaysOnTop);
    public static bool ShowYesNo(string text, string caption, IntPtr window, bool defaultButton, bool alwaysOnTop);
    public static Nullable`1<bool> ShowYesNoCancel(string text, string caption);
    public static Nullable`1<bool> ShowYesNoCancel(string text, string caption, IntPtr window);
    public static Nullable`1<bool> ShowYesNoCancel(string text, string caption, IntPtr window, Nullable`1<bool> defaultButton);
}
public static class JetBrains.Util.MessageBoxHandlers : object {
    public static ListEvents`1<MessageBoxHandlerDelegate> MessageBoxHandlersStack;
    private static MessageBoxHandlers();
    [NotNullAttribute]
public static MessageBoxHandlerDelegate GetHandlerSilent(ILogger logger);
    [NotNullAttribute]
public static MessageBoxHandlerDelegate GetHandlerWinNT();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class JetBrains.Util.ModificationCookie : object {
    private bool myIsDisposed;
    [CompilerGeneratedAttribute]
private EventHandler ModificationFinished;
    [CompilerGeneratedAttribute]
private EnsureWritableResult <EnsureWritableResult>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    public EnsureWritableResult EnsureWritableResult { get; }
    public string Message { get; }
    public ModificationCookie(EnsureWritableResult ensureWritableResult);
    public ModificationCookie(EnsureWritableResult ensureWritableResult, string message);
    [CompilerGeneratedAttribute]
public void add_ModificationFinished(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_ModificationFinished(EventHandler value);
    [CompilerGeneratedAttribute]
public EnsureWritableResult get_EnsureWritableResult();
    [CompilerGeneratedAttribute]
public string get_Message();
    public sealed virtual void Dispose();
}
public class JetBrains.Util.MultiTypeComparer : object {
    [NotNullAttribute]
private TypeHierarchyMap`1<IComparer> myComparers;
    [NotNullAttribute]
private ConcurrentDictionary`2<Type, Type> myTypeCache;
    [CompilerGeneratedAttribute]
private List`1<Type> <TypeLinearOrder>k__BackingField;
    [NotNullAttribute]
protected List`1<Type> TypeLinearOrder { get; }
    public MultiTypeComparer(IEnumerable`1<Type> typeLinearOrder);
    [CompilerGeneratedAttribute]
protected List`1<Type> get_TypeLinearOrder();
    public sealed virtual int Compare(object x, object y);
    private Type GetRegisteredType(Type type);
    protected virtual Type DisambiguateTypeConflict(Type t1, Type t2);
    protected static Type DisambiguateRule(Type candidate1, Type candidate2, Type winner, Type loser);
    public void Compare();
    public void Compare(Comparator`1<T> callback);
    protected virtual object Unwrap(object wrapper);
}
public class JetBrains.Util.NamedAutoResetEvent : WaitHandle {
    public NamedAutoResetEvent(string name, bool initialState);
    public void Reset();
    public void Set();
    private static IntPtr CreateEvent(IntPtr lpEventAttributes, bool bManualReset, bool bInitialState, string lpName);
    private static bool ResetEvent(IntPtr hEvent);
    private static bool SetEvent(IntPtr hEvent);
}
public class JetBrains.Util.NamedPipes.AsyncMessageStreamReader : object {
    private static int DefaultBufferSize;
    private static int MinBufferSize;
    [NotNullAttribute]
private Byte[] myBuffer;
    private int myBufferSize;
    [CanBeNullAttribute]
private ManualResetEvent myEventEof;
    [NotNullAttribute]
private Func`1<bool> myFIsMessageComplete;
    private bool myIsCanceled;
    private ChunkList`1<Byte[]> myPreviousPartBuffers;
    [NotNullAttribute]
private Stream myStream;
    [NotNullAttribute]
public ISignal`1<Stream> MessageReceived;
    [NotNullAttribute]
public Stream BaseStream { get; }
    public AsyncMessageStreamReader(Lifetime lifetime, Stream stream, Func`1<bool> FIsCompleteMessageReceived);
    public AsyncMessageStreamReader(Lifetime lifetime, Stream stream, Func`1<bool> FIsCompleteMessageReceived, int bufferSize);
    private static AsyncMessageStreamReader();
    public Stream get_BaseStream();
    public void BeginReadMessage();
    public void CancelOperation();
    public void WaitUtilEOF();
    private void FireMessageReceivedIfComplete(int nBytesInCurrentChunk);
    private void OnBeginReadCompleted(IAsyncResult ar);
    [CompilerGeneratedAttribute]
private void <.ctor>b__10_0();
    [CompilerGeneratedAttribute]
private void <.ctor>b__10_1();
}
public class JetBrains.Util.NamedPipes.AsyncServerPipeMessageReader : object {
    private Lifetime myLifetime;
    private NamedPipeServerStream myPipe;
    private AsyncMessageStreamReader myReaderNested;
    [NotNullAttribute]
public ISignal`1<Stream> MessageReceived { get; }
    public AsyncServerPipeMessageReader(Lifetime lifetime, NamedPipeServerStream pipe);
    public ISignal`1<Stream> get_MessageReceived();
    public void BeginReadMessage();
    [CompilerGeneratedAttribute]
private void <BeginReadMessage>b__6_0(IAsyncResult result);
}
public class JetBrains.Util.NamedPipes.AsyncServerPipeObjectReader`1 : object {
    [NotNullAttribute]
private AsyncServerPipeMessageReader myNestedReader;
    private NamedPipeServerStream myPipe;
    public ISignal`1<TObject> ObjectReceived;
    public AsyncServerPipeObjectReader`1(Lifetime lifetime, NamedPipeServerStream pipe);
    public AsyncServerPipeObjectReader`1(Lifetime lifetime, NamedPipeServerStream pipe, Func`2<Stream, TObject> FDeserializeObject);
    public void BeginReadMessage();
}
public class JetBrains.Util.NamedPipes.ChannelReader : ValueType {
    private string myChannelName;
    private Func`1<Task> myFTaskRemainingMessagesRead;
    [NotNullAttribute]
public string ChannelName { get; }
    internal ChannelReader(string sChannelName, Task taskRemainingMessagesRead);
    internal ChannelReader(string sChannelName, Func`1<Task> FTaskRemainingMessagesRead);
    public string get_ChannelName();
    public void ReadRemainingMessages();
    [NotNullAttribute]
public Task ReadRemainingMessagesAsync();
}
public class JetBrains.Util.NamedPipes.ChannelWriter`1 : ValueType {
    private Action`1<TItem> myFWrite;
    internal ChannelWriter`1(Action`1<TItem> FWrite);
    public void Write(TItem item);
}
public class JetBrains.Util.NamedPipes.DiskFileBasedPipeEmulationChannel : object {
    [NotNullAttribute]
public static IPipeMessageChannel Factory;
    private static DiskFileBasedPipeEmulationChannel();
    private sealed virtual override ChannelReader JetBrains.Util.NamedPipes.IPipeMessageChannel.CreateReader(Lifetime lifetime, Action`3<Byte[], UInt32, UInt32> FOnRead, ILogger logger);
    private sealed virtual override ChannelWriter`1<TItem> JetBrains.Util.NamedPipes.IPipeMessageChannel.CreateWriter(Lifetime lifetime, string sChannelName, ItemSerializer<TItem> serializer, ILogger logger);
    private FileSystemPath GetFilePathFromName(string sChannelName);
}
public interface JetBrains.Util.NamedPipes.IPipeMessageChannel {
    public abstract virtual ChannelReader CreateReader(Lifetime lifetime, Action`3<Byte[], UInt32, UInt32> FOnRead, ILogger logger);
    public abstract virtual ChannelWriter`1<TItem> CreateWriter(Lifetime lifetime, string sChannelName, ItemSerializer<TItem> serializer, ILogger logger);
}
public class JetBrains.Util.NamedPipes.NamedPipeMessageChannel : object {
    [NotNullAttribute]
public static IPipeMessageChannel Factory;
    private static int PipeBufferSize;
    private static NamedPipeMessageChannel();
    private sealed virtual override ChannelReader JetBrains.Util.NamedPipes.IPipeMessageChannel.CreateReader(Lifetime lifetime, Action`3<Byte[], UInt32, UInt32> FOnRead, ILogger logger);
    private sealed virtual override ChannelWriter`1<TItem> JetBrains.Util.NamedPipes.IPipeMessageChannel.CreateWriter(Lifetime lifetime, string sChannelName, ItemSerializer<TItem> serializer, ILogger logger);
}
public class JetBrains.Util.NamedPipes.NamedPipeNativeMessageChannel : object {
    private static string ChannelNameSerializationPrefix;
    [NotNullAttribute]
public static IPipeMessageChannel Factory;
    private static UInt32 PipeBufferSize;
    private static NamedPipeNativeMessageChannel();
    private sealed virtual override ChannelReader JetBrains.Util.NamedPipes.IPipeMessageChannel.CreateReader(Lifetime lifetime, Action`3<Byte[], UInt32, UInt32> FOnRead, ILogger logger);
    private sealed virtual override ChannelWriter`1<TItem> JetBrains.Util.NamedPipes.IPipeMessageChannel.CreateWriter(Lifetime lifetime, string sChannelName, ItemSerializer<TItem> serializer, ILogger logger);
    private static Void* DeserializeHandleFromChannelName(Lifetime lifetime, string name);
    private static string SerializeHandleToChannelName(Void* handle);
}
public static class JetBrains.Util.NamedPipes.NamedPipeUtils : object {
    private static string Win32PipesLocation;
    public static List`1<string> GetNamedPipeNames(string mask);
}
public class JetBrains.Util.Networking.HttpClientHandlerPatcher : object {
    private ILogger myLogger;
    protected Func`5<HttpRequestMessage, X509Certificate2, X509Chain, SslPolicyErrors, bool> ServerCertificateCustomValidationCallback { get; }
    public HttpClientHandlerPatcher(ILogger logger);
    protected virtual Func`5<HttpRequestMessage, X509Certificate2, X509Chain, SslPolicyErrors, bool> get_ServerCertificateCustomValidationCallback();
    public HttpClientHandler CreateHttpClientHandler();
    public HttpClient CreateHttpClient();
    public HttpClientHandler Patch(HttpClientHandler httpClientHandler);
}
public static class JetBrains.Util.Networking.HttpDownload : object {
    private static TaskSemaphore ParallelAttemptsLimit;
    public static UInt32 ServicePointConnectionLimit;
    private static HttpDownload();
    [AsyncStateMachineAttribute("JetBrains.Util.Networking.HttpDownload/<HttpDownloadReliable>d__2")]
public static Task`1<Stream> HttpDownloadReliable(OuterLifetime lifetime, Uri uri, Stream streamOut, DownloadProgress dlprogress, IWebProxy webproxy, Flags flags);
    [AsyncStateMachineAttribute("JetBrains.Util.Networking.HttpDownload/<BeginBackgroundLoggingAsync>d__3")]
private static Task BeginBackgroundLoggingAsync(Lifetime lifetime, DownloadProgress dlprogress, RetryOracle retry, string sDownloadTaskName, ILogger logger);
    [AsyncStateMachineAttribute("JetBrains.Util.Networking.HttpDownload/<HttpDownloadReliableAttempt>d__4")]
private static Task`1<bool> HttpDownloadReliableAttempt(OuterLifetime lifeAllAttempts, Uri uri, Stream streamOut, IWebProxy webproxy, Flags flags, RetryOracle retry, DownloadProgress dlprogress, ILogger logger);
}
[ExtensionAttribute]
public static class JetBrains.Util.Networking.MonoCertificateValidator : object {
    private static X509Certificate2[] ourTrustedRoots;
    private static bool ourPatched;
    private static Lazy`1<NuGetCertificatePatcher> ourNuGetCertificatePatcher;
    private static MonoCertificateValidator();
    private static void LoadTrustedRoot();
    private static X509ChainPolicy CreatePolicy(X509ChainElementCollection certificateChain);
    [ExtensionAttribute]
private static bool HasOnlyUntrustedRoot(X509ChainStatus[] statuses);
    [ExtensionAttribute]
private static X509Certificate2 GetRootCertificate(X509Chain chain);
    public static bool IsValid(X509ChainElementCollection certificateChain);
    public static SourceRepository CreateSourceProvider(PackageSource packageSource);
    public static ISourceRepositoryProvider CreateCachingSourceProvider(IPackageSourceProvider packageSourceProvider);
    public static void PatchNuGetStatic();
    public static void PatchWebRequestIfApplicable(HttpWebRequest request);
}
public class JetBrains.Util.Networking.NuGetCertificatePatcher : object {
    private ILogger myLogger;
    private HttpClientHandlerPatcher myPatcher;
    public NuGetCertificatePatcher(ILogger logger, HttpClientHandlerPatcher patcher);
    public CachingSourceProvider CreateCachingSourceProvider(IPackageSourceProvider packageSourceProvider);
    public SourceRepository CreateSourceRepository(PackageSource source);
    public IEnumerable`1<Lazy`1<INuGetResourceProvider>> GetProviders();
    private IEnumerable`1<Lazy`1<INuGetResourceProvider>> Patch(IEnumerable`1<Lazy`1<INuGetResourceProvider>> lazyProviders);
    private INuGetResourceProvider Patch(Lazy`1<INuGetResourceProvider> lazyProvider);
    public void ApplyPatching();
    [CompilerGeneratedAttribute]
private Lazy`1<INuGetResourceProvider> <Patch>b__6_0(Lazy`1<INuGetResourceProvider> lazyProvider);
    [CompilerGeneratedAttribute]
private IEnumerable`1<Lazy`1<INuGetResourceProvider>> <ApplyPatching>b__9_0();
}
public class JetBrains.Util.Networking.StandaloneHttpClientHandlerPatcher : HttpClientHandlerPatcher {
    [CompilerGeneratedAttribute]
private Func`5<HttpRequestMessage, X509Certificate2, X509Chain, SslPolicyErrors, bool> <ServerCertificateCustomValidationCallback>k__BackingField;
    protected Func`5<HttpRequestMessage, X509Certificate2, X509Chain, SslPolicyErrors, bool> ServerCertificateCustomValidationCallback { get; }
    public StandaloneHttpClientHandlerPatcher(ILogger logger, Func`5<HttpRequestMessage, X509Certificate2, X509Chain, SslPolicyErrors, bool> callback);
    [CompilerGeneratedAttribute]
protected virtual Func`5<HttpRequestMessage, X509Certificate2, X509Chain, SslPolicyErrors, bool> get_ServerCertificateCustomValidationCallback();
}
public static class JetBrains.Util.NetworkUtil : object {
    public static int GetFreePort();
    public static IPEndPoint ParseIPEndPoint(string endPoint);
}
[ExtensionAttribute]
public static class JetBrains.Util.NotifyPropertyChangedExtensions : object {
    [ExtensionAttribute]
public static void Advise_NoAcknowledgement(INotifyPropertyChanged source, Lifetime lifetime, PropertyChangedEventHandler handler);
    [ExtensionAttribute]
public static void Advise_NoAcknowledgement(T source, Lifetime lifetime, Expression`1<Func`2<T, TValue>> propertySelector, Action`1<TValue> handler);
}
public static class JetBrains.Util.NumberUtilParsing : object {
    public static bool TryParseFloatingPoint(Byte* pchAscii, UInt32 cbText, Double* pNumber);
    public static bool TryParseFloatingPoint(UInt16* pchWide, UInt32 cbText, Double* pNumber, DataBuffer sharedbuffer);
    public static bool TryParseFloatingPoint(string text, Double& number);
    private static bool TryExtractFloatingPointData(Byte* pchAscii, UInt32 cbText, FloatingData* pNumber);
    private static bool TryExtractFloatingPointData(UInt16* pchWide, UInt32 cbText, FloatingData* pNumber);
    private static bool TryMatchNonNumbers(Byte* pchAscii, UInt32 cbText, Double* pNumber);
    private static bool TryMatchNonNumbers(UInt16* pchWide, UInt32 cbText, Double* pNumber);
}
public class JetBrains.Util.NunitUpgradeProcess : object {
    public static string IgnoreTestMissedReason;
}
public class JetBrains.Util.ObservableRangeCollection`1 : ObservableCollection`1<T> {
    public ObservableRangeCollection`1(IEnumerable`1<T> collection);
    public void AddRange(IList`1<T> collection);
    public void RemoveRange(IList`1<T> collection);
    public void Replace(T item);
    public void ReplaceRange(IEnumerable`1<T> collection);
}
public class JetBrains.Util.OperationResult : object {
    [CompilerGeneratedAttribute]
private OperationResultType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    public OperationResultType Type { get; }
    public string Message { get; }
    public OperationResult(OperationResultType type, string message);
    public static OperationResult Success();
    public static OperationResult Fail(string failReason);
    [CompilerGeneratedAttribute]
public OperationResultType get_Type();
    [CompilerGeneratedAttribute]
public string get_Message();
}
public enum JetBrains.Util.OperationResultType : Enum {
    public int value__;
    public static OperationResultType Success;
    public static OperationResultType Fail;
}
public class JetBrains.Util.PairEnumerator`2 : object {
    private IEnumerator`1<KeyValuePair`2<TKey, TValue>> myEnumerator;
    public KeyValuePair`2<TKey, TValue> Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    public TKey CurrentKey { get; }
    public TValue CurrentValue { get; }
    public PairEnumerator`2(IEnumerator`1<KeyValuePair`2<TKey, TValue>> enumerator);
    public sealed virtual void Dispose();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
    public sealed virtual KeyValuePair`2<TKey, TValue> get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual TKey get_CurrentKey();
    public sealed virtual TValue get_CurrentValue();
}
public class JetBrains.Util.PartialSorter`1 : object {
    private List`1<T> myOrder;
    private List`1<T> myContent;
    public ICollection`1<T> OrderedContent { get; }
    public ICollection`1<T> get_OrderedContent();
    public void SetContent(ICollection`1<T> content);
    public void MoveUp(T item);
    public void MoveDown(T item);
    private T MoveUpInContent(T item);
    private T MoveDownInContent(T item);
    private void MoveUpInOrder(T item);
    private void MoveDownInOrder(T item);
}
public class JetBrains.Util.PaternMatching.Match : ValueType {
    public bool Success;
    public object Value;
}
public class JetBrains.Util.PaternMatching.MatchFailureException : Exception {
    public MatchFailureException(string message);
}
public class JetBrains.Util.PaternMatching.PatternMatcher`1 : object {
    private Func`1<Match> myMatcher;
    public PatternMatcher`1(Func`1<Match> matcher);
    public PatternMatcher`1<T> WithOpenGeneric(Type openGenericType, Func`2<object, object> f);
    public PatternMatcher`1<T> Default(Func`2<T, object> defaultAction, bool allowNullValue);
    public PatternMatcher`1<T> With(Func`2<TPattern, object> f);
    public PatternMatcher`1<T> WithOpenGeneric(Type openGenericType, Func`2<object, bool> predicate, Func`2<object, object> f);
    public PatternMatcher`1<T> With(Func`2<TPattern, bool> predicate, Func`2<TPattern, object> f);
    private PatternMatcher`1<T> With(Func`2<TPattern, bool> predicate, Func`2<TPattern, object> f, bool allowNullValue);
    private static Match Fail(Match obj);
    private static Match Success(Func`2<TPattern, object> f, Match obj);
    public PatternMatcher`1<T> Any(Func`1<object> f);
    public TResult Return();
}
[ExtensionAttribute]
public static class JetBrains.Util.PaternMatching.PatternMatchingExtensions : object {
    [ExtensionAttribute]
public static PatternMatcher`1<T> Match(T obj);
}
[IsReadOnlyAttribute]
public class JetBrains.Util.PathMap : ValueType {
    [CompilerGeneratedAttribute]
private static PathMap <Empty>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    public static PathMap Empty { get; }
    public string Key { get; }
    public string Value { get; }
    public bool IsEmpty { get; }
    public PathMap(string key, string value);
    private static PathMap();
    [CompilerGeneratedAttribute]
public static PathMap get_Empty();
    [CompilerGeneratedAttribute]
public string get_Key();
    [CompilerGeneratedAttribute]
public string get_Value();
    public bool get_IsEmpty();
    public virtual string ToString();
    public static PathMap TryParse(string pathMap);
    public KeyValuePair`2<string, string> ToKeyValuePair();
    public PathMap From(KeyValuePair`2<string, string> pair);
}
public static class JetBrains.Util.PebUtil : object {
    private static int MaxEnvSize;
    public static IDictionary GetEnvironmentVariables(Process process);
    private static Byte[] GetEnvironmentVariablesBytes(Process process);
    private static UniPtr GetEnvironmentPtr(Process process);
    private static UniPtr GetEnvironmentPtrAddress(Process process);
    private static UniPtr GetProcessParametersPtr(Process process);
    private static UniPtr GetProcessParametersPtrAddress(Process process);
    private static UniPtr GetPebBasePtr(Process process);
    private static bool TryGetRange(Process process, UniPtr uniPtr, Int32& size);
    private static Dictionary`2<string, string> ParseEnvVariables(Byte[] env);
    private static bool TryReadUniPtr(Process process, UniPtr ptr, UniPtr& readPtr);
    [CompilerGeneratedAttribute]
internal static UniPtr <GetPebBasePtr>g__GetPeb64|7_0(<>c__DisplayClass7_0& );
    [CompilerGeneratedAttribute]
internal static IntPtr <GetPebBasePtr>g__GetPeb32|7_1(<>c__DisplayClass7_0& );
    [CompilerGeneratedAttribute]
internal static IntPtr <GetPebBasePtr>g__GetPebNative|7_2(<>c__DisplayClass7_0& );
    [CompilerGeneratedAttribute]
internal static bool <TryReadUniPtr>g__TryReadIntPtr32|10_0(UniPtr& readed, <>c__DisplayClass10_0& );
    [CompilerGeneratedAttribute]
internal static bool <TryReadUniPtr>g__TryReadIntPtr|10_1(UniPtr& readed, <>c__DisplayClass10_0& );
    [CompilerGeneratedAttribute]
internal static bool <TryReadUniPtr>g__TryReadIntAs64FromOther|10_2(int dataSize, UniPtr& readed, <>c__DisplayClass10_0& );
    [CompilerGeneratedAttribute]
internal static bool <TryReadUniPtr>g__TryReadIntPtrWow64|10_3(Int64& readed, <>c__DisplayClass10_0& );
}
[ExtensionAttribute]
public static class JetBrains.Util.PersistentMap.UnsafeReaderWriterHybridCollectionEx : object {
    [ExtensionAttribute]
public static void WriteHybridCollection(UnsafeWriter me, HybridCollection`1<T> value, WriteDelegate`1<T> writeDelegate);
    [ExtensionAttribute]
public static HybridCollection`1<T> ReadHybridCollection(UnsafeReader me, ReadDelegate`1<T> readDelegate, Func`2<T, bool> filter);
}
public class JetBrains.Util.PosixSharedMemory : SharedMemory {
    private string myName;
    private int myShmFd;
    public long ConfiguredSize { get; }
    public PosixSharedMemory(Lifetime lifetime, string uniqueIdentifier, long maxSize);
    public virtual long get_ConfiguredSize();
    protected virtual Byte* MapImpl(long size);
    protected virtual void UnmapImpl();
    protected virtual void DeleteImpl();
    private long GetSize();
}
public static class JetBrains.Util.Predicate : object {
    public static bool True();
    public static bool False();
}
[ExtensionAttribute]
public static class JetBrains.Util.PresentationEx : object {
    [ExtensionAttribute]
[NotNullAttribute]
public static string ToKibibytePresentation(long value);
    [ExtensionAttribute]
[NotNullAttribute]
public static string ToKibibytePresentation(ulong value);
    [ExtensionAttribute]
[NotNullAttribute]
public static string ToKibibitPresentation(long value);
    [ExtensionAttribute]
[NotNullAttribute]
public static string ToKibibitPresentation(ulong value);
}
public static class JetBrains.Util.Processes.ActivateWindow : object {
    public static void ByPID(int processId);
    public static void ByWindowHandle(IntPtr mainWindowHandle);
}
public class JetBrains.Util.Processes.CommandLineToolsRunnerHelpers : object {
    public static bool RerunCltUnderWindowsArm64(FileSystemPath mainModuleModulePath, String[] args, Int32& exitCode);
    [CompilerGeneratedAttribute]
internal static void <RerunCltUnderWindowsArm64>g__OnCancelKeyPress|0_0(object sender, ConsoleCancelEventArgs args);
}
[ExtensionAttribute]
public static class JetBrains.Util.Processes.ConsoleRunner : object {
    public static CommandResult RunCommand(string file, string arguments, Nullable`1<TimeSpan> timeout, Action`1<TimeSpan> onWait, string workingDirectory);
    public static string GetFullPath(string file);
    [ExtensionAttribute]
public static string GetFullOutputString(CommandResult result);
    [ExtensionAttribute]
public static IReadOnlyList`1<string> GetStdOutLines(CommandResult result);
    [ExtensionAttribute]
public static IReadOnlyList`1<string> GetStdErrLines(CommandResult result);
    public static Process StartScript(string script, string workingFolder);
    [AsyncStateMachineAttribute("JetBrains.Util.Processes.ConsoleRunner/<RunScript>d__7")]
public static Task RunScript(string script, string workingFolder);
}
public static class JetBrains.Util.Processes.DotNetGlobalToolsRunnerHelpers : object {
    private static string ourDotnetExecutable;
    private static DotNetGlobalToolsRunnerHelpers();
    public static int RunCltWithCustomRuntimeConfig(FileSystemPath assemblyPath, string commandLine, string runtimeConfigSuffix);
    public static int RerunCltIfNeeded(Func`2<String[], int> mainMethod, FileSystemPath mainModuleModulePath, String[] args, string runtimeConfigSuffix, Action`1<string> errorMessageLogger, int failureReturnCode);
    [CanBeNullAttribute]
private static SafeJobHandle CreateJobSafe(string sJobName);
    [NotNullAttribute]
private static SafeJobHandle CreateJob(string sJobName);
    private static void AssignJobToProcessSafe(SafeJobHandle jobHandle, IntPtr processHandle);
    private static void AssignJobToProcess(SafeJobHandle jobHandle, IntPtr processHandle);
    private static FileSystemPath TryFindDotnetExe();
    [CompilerGeneratedAttribute]
internal static void <RunCltWithCustomRuntimeConfig>g__OnConsoleOnCancelKeyPress|0_0(object sender, ConsoleCancelEventArgs args);
}
public interface JetBrains.Util.Processes.IPreparedProcessWithCachedOutput {
    public string Output { get; }
    public Nullable`1<DateTime> StartTime { get; }
    public Nullable`1<DateTime> ExitTime { get; }
    public abstract virtual string get_Output();
    public abstract virtual Nullable`1<DateTime> get_StartTime();
    public abstract virtual Nullable`1<DateTime> get_ExitTime();
}
public class JetBrains.Util.Processes.PreparedProcessWithCachedOutput : object {
    [NotNullAttribute]
private IPreparedProcess myInner;
    [NotNullAttribute]
private CircularBuffer`1<string> myOutput;
    [CompilerGeneratedAttribute]
private ExitProcessHandler Exited;
    [CompilerGeneratedAttribute]
private LineReadHandler OutputLineRead;
    [CompilerGeneratedAttribute]
private LineReadHandler ErrorLineRead;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <StartTime>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <ExitTime>k__BackingField;
    public int ProcessId { get; }
    public int ExitCode { get; }
    public bool IsRunning { get; }
    public string ProcessName { get; }
    public string ProcessArgs { get; }
    public Nullable`1<DateTime> StartTime { get; private set; }
    public Nullable`1<DateTime> ExitTime { get; private set; }
    public string Output { get; }
    public PreparedProcessWithCachedOutput(IPreparedProcess inner);
    [CompilerGeneratedAttribute]
public sealed virtual void add_Exited(ExitProcessHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Exited(ExitProcessHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_OutputLineRead(LineReadHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_OutputLineRead(LineReadHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_ErrorLineRead(LineReadHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_ErrorLineRead(LineReadHandler value);
    public sealed virtual int get_ProcessId();
    public sealed virtual int get_ExitCode();
    public sealed virtual bool get_IsRunning();
    public sealed virtual string get_ProcessName();
    public sealed virtual string get_ProcessArgs();
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<DateTime> get_StartTime();
    [CompilerGeneratedAttribute]
private void set_StartTime(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<DateTime> get_ExitTime();
    [CompilerGeneratedAttribute]
private void set_ExitTime(Nullable`1<DateTime> value);
    public sealed virtual string get_Output();
    public sealed virtual void Start();
    private void InnerOnErrorLineRead(string line);
    private void InnerOnOutputLineRead(string line);
    private void InnerOnExited(IPreparedProcess process, int exitCode);
    public sealed virtual bool WaitForExit(Nullable`1<TimeSpan> timeout);
    public sealed virtual void Kill();
    public sealed virtual void Dispose();
}
[ExtensionAttribute]
public static class JetBrains.Util.Processes.PreparedProcessWithCachedOutputExtensions : object {
    [ExtensionAttribute]
[NotNullAttribute]
public static IPreparedProcessWithCachedOutput WithCachedOutput(IPreparedProcess process);
}
[ExtensionAttribute]
public static class JetBrains.Util.ProcessExtensions : object {
    [ExtensionAttribute]
public static bool RunAndWait(IPreparedProcess process, Nullable`1<TimeSpan> timeout);
    [ExtensionAttribute]
[NotNullAttribute]
public static Task`1<int> RunAndWaitAsync(IPreparedProcess process, CancellationToken token);
    [AsyncStateMachineAttribute("JetBrains.Util.ProcessExtensions/<WaitForExitAsync>d__2")]
[ExtensionAttribute]
[NotNullAttribute]
public static Task`1<int> WaitForExitAsync(IPreparedProcess process, TimeSpan timeout);
    [AsyncStateMachineAttribute("JetBrains.Util.ProcessExtensions/<WaitForExitAsync>d__3")]
[ExtensionAttribute]
[NotNullAttribute]
public static Task`1<int> WaitForExitAsync(IPreparedProcess process, CancellationToken token);
}
public class JetBrains.Util.ProcessSharedData`1 : object {
    private static int Version;
    private static int ReservedAreaSize;
    private int myProcessId;
    private long myProcessTimestamp;
    private string myUserId;
    private Lifetime myLifetime;
    private static object ourThreadLock;
    private string myUniqueIdentifier;
    private static long MaxBytes { get; }
    public ProcessSharedData`1(Lifetime lifetime, string uniqueIdentifier);
    private static ProcessSharedData`1();
    private static long get_MaxBytes();
    private SharedMemory CreateSharedMemory(Lifetime lifetime, string uniqueIdentifier, int id, long maxSize);
    public void Write(T data);
    public IReadOnlyDictionary`2<int, T> ReadAll();
    public IReadOnlyDictionary`2<int, T> ReadOther();
    public T ReadCurrent();
    private static long GetConfiguredSize(SharedMemory sharedMemory);
    private IReadOnlyDictionary`2<int, T> Sync(T newItem, bool update, bool returnCurrent, bool returnOther);
    private static bool ProcessExists(ProcessData<T> process);
    private List`1<ProcessData<T>> ReadMemory(SharedMemory memory);
    private void WriteMemory(SharedMemory memory, IReadOnlyCollection`1<ProcessData<T>> data);
}
[ExtensionAttribute]
public static class JetBrains.Util.ProcessUtil : object {
    private static ILogger ourLogger;
    private static string myMainModuleName;
    private static ProcessUtil();
    [ExtensionAttribute]
[NotNullAttribute]
public static List`1<Process> GetChildren(Process process);
    [ExtensionAttribute]
public static bool Is64BitProcess(Process process);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static Process GetParent(Process process);
    [ExtensionAttribute]
private static bool IsMatch(Process process, string processName);
    [ExtensionAttribute]
private static bool IsMatch(Process process, Regex regex);
    public static bool HasByProcessName(string processName);
    public static bool HasByProcessName(string processNamePattern, RegexOptions regexOptions);
    public static void KillByProcessName(String[] processNames);
    public static void KillByProcessName(string processNamePattern, RegexOptions regexOptions);
    [ExtensionAttribute]
public static IEnumerable`1<UInt32> GetDescendantProcesses(Process process, ISet`1<UInt32> pidsToExclude);
    [ExtensionAttribute]
public static IEnumerable`1<ProcessInfo> GetDescendantProcessesInfo(Process process);
    public static IEnumerable`1<UInt32> GetAllPids();
    [ExtensionAttribute]
public static void KillTree(Process process, ISet`1<UInt32> pidsToExclude);
    public static void KillTree(UInt32 pid, ISet`1<UInt32> pidsToExclude);
    [ExtensionAttribute]
public static bool ShutdownGracefully(Process process, ShutdownFlags flags, TimeSpan waitTimeout, ILogger logger);
    [ObsoleteAttribute("Use PlatformUtil.IsRunningUnderWindows and PlatformUtilWindows.IsRunningElevated directly")]
public static bool IsRunningElevated();
    public static TValue UnderDisableFsRedirection(bool disableIfNeed, Func`1<TValue> func);
    [NotNullAttribute]
public static Process Start(ProcessStartInfo startInfo);
    [NotNullAttribute]
public static Tuple`2<Process, UInt32> Start_SuspendedNoHandleInheritance(ProcessStartInfo startInfo, bool createNewProcessGroup, bool createNewConsole);
    [NotNullAttribute]
public static Process Start_NoHandleInheritance(ProcessStartInfo startInfo, Nullable`1<MachineId> machineId, bool createNewProcessGroup, bool createNewConsole);
    [NotNullAttribute]
public static Process Start_NoHandleInheritance(ProcessStartInfo startInfo, bool createNewProcessGroup, bool createNewConsole);
    public static void ResumeThread(UInt32 threadId);
    public static void SuspendThread(UInt32 threadId);
    public static string GetEnvironmentString(IEnumerable`1<KeyValuePair`2<string, string>> environment);
    public static Byte[] EncodeEnvironmentString(IEnumerable`1<KeyValuePair`2<string, string>> environment);
    public static void EncodeEnvironmentString(IEnumerable`1<KeyValuePair`2<string, string>> environment, Cookie writeout);
    public static Byte[] EncodeEnvironmentStringMbcs(IEnumerable`1<KeyValuePair`2<string, string>> environment, Encoding encoding);
    public static Byte[] EncodeEnvironmentString(StringDictionary environment);
    [NotNullAttribute]
public static Task`1<TValue> Start_NoHandleInheritance(Lifetime lifetime, ProcessStartInfo startInfo, Func`3<Lifetime, Process, Task`1<TValue>> beforeResume, bool createNewProcessGroup, bool createNewConsole);
    public static TValue Start_NoHandleInheritance(ProcessStartInfo startInfo, Func`2<Process, TValue> beforeResume, bool createNewProcessGroup, bool createNewConsole, Nullable`1<Lifetime> lifetime);
    [NotNullAttribute]
public static TValue Start_NoHandleInheritance(ProcessStartInfo startInfo, Nullable`1<MachineId> machineId, Func`2<Process, TValue> beforeResume, bool createNewProcessGroup, bool createNewConsole, Nullable`1<Lifetime> lifetime);
    [NotNullAttribute]
public static TValue Start_NoHandleInheritance(ProcessStartInfo startInfo, Func`3<Process, UInt32, TValue> beforeResume, bool createNewProcessGroup, bool leaveSuspended, bool createNewConsole, Nullable`1<Lifetime> lifetime, Nullable`1<MachineId> machineId);
    [NotNullAttribute]
public static TValue Start_CustomHandleInheritance(ProcessStartInfo startInfo, Func`3<Process, UInt32, TValue> beforeResume, bool inheritStandardIoHandles, bool createNewProcessGroup, bool leaveSuspended, bool createNewConsole, Nullable`1<Lifetime> lifetime, Nullable`1<MachineId> machineId);
    public static TValue CreateProcess(LifetimeDefinition definition, CreateProcessInfo`1<TValue> cretinfo);
    private static Pipes CreateProcess_SetupStreamRedirects(Lifetime lifetime, Lifetime createProcessLifetime, CreateProcessInfo`1<TValue> startInfo, STARTUPINFO* si);
    private static void CreateProcess_SetupStreamRedirects_CreatePipe(Lifetime lifetime, Lifetime createProcessLifetime, string sStreamName, bool isParentReadNotWrite, Void*& hParentUninh, Void*& hChild);
    private static void CreateProcess_SyncTermination(LifetimeDefinition definition, PROCESS_INFORMATION pi);
    [NotNullAttribute]
public static Process GetProcessById(int pid);
    [NotNullAttribute]
public static Process GetProcessById(UInt32 pid);
    public static Nullable`1<bool> IsProcessAlive(int processId);
    public static Result`1<long> GetProcessStartTimestamp(UInt32 pid);
    public static UInt32 GetProcessParentId(UInt32 pid);
    [NotNullAttribute]
public static Task`1<Nullable`1<UInt32>> WaitForProcessExitAsync(UInt32 pid, int millisecondsTimeout);
    [ExtensionAttribute]
[NotNullAttribute]
public static Task`1<Nullable`1<UInt32>> WaitForExitAsync(Process process);
    public static FrugalLocalList`1<UInt32> EnumerateJobProcessIds(Void* hJob, OnError onerror);
    [NotNullAttribute]
public static string GetMainModuleName();
    private static int GetInt(Byte[] buffer, int offset);
    private static IntPtr GetIntPtr(Byte[] buffer, int offset);
    [NotNullAttribute]
public static IReadOnlyCollection`1<ProcessInfo> GetProcessInfos();
    [NotNullAttribute]
private static IReadOnlyCollection`1<ProcessInfo> GetProcessInfos_Toolhelp32();
    [NotNullAttribute]
private static IReadOnlyCollection`1<ProcessInfo> GetProcessInfos_Managed();
    [ExtensionAttribute]
private static void SendShutdownControl(Process process);
    private static List`1<ProcessTreeNode> BuildProcessTree(IList`1<ProcessInfo> processes);
    public static string DumpProcessTree();
}
public static class JetBrains.Util.ProductHeadline : object {
    public static string Copyright;
    public static string CopyrightUtfMark;
    public static string CopyrightAnsiMark;
    public static string Build;
    public static string Of(string productName, int sinceYear, bool useAnsiCopyrightMark);
}
public class JetBrains.Util.ProfileUtil : object {
    private static Hashtable ourClock;
    private static Hashtable ourStartTimes;
    private static Hashtable ourWorkingTimers;
    private static Hashtable ourCallCounter;
    private static ProfileUtil();
    public static void Clear();
    public static void Dump(double minimalTime);
    public static void StartTimer(object key);
    public static void StopTimer(object key);
    public static bool TimerWorks(object key);
}
public class JetBrains.Util.QualifiedNamesTrie`1 : QualifiedNamesTrieBase`2<T, string> {
    private char myDelimiter;
    public QualifiedNamesTrie`1(bool ignoreCase, char delimiter);
    protected virtual bool IsEmpty(string qualifiedName);
    public virtual bool GetNextSlice(string qualifiedName, int startIndex, StringSlice& slice, Int32& nextPos);
    protected virtual Node<T, string> FindParentNode(string qualifiedName, String& childName);
}
[DefaultMemberAttribute("Item")]
public abstract class JetBrains.Util.QualifiedNamesTrieBase`2 : object {
    private IEqualityComparer`1<StringSlice> myComparer;
    protected Node<T, TQualifiedName> myRoot;
    public T Item { get; public set; }
    public QualifiedNamesTrieBase`2(IEqualityComparer`1<StringSlice> comparer);
    public T get_Item(TQualifiedName qualification);
    public void set_Item(TQualifiedName qualification, T value);
    private static bool IsValid(TQualifiedName qualification);
    protected abstract virtual bool IsEmpty(TQualifiedName qualifiedName);
    public abstract virtual bool GetNextSlice(TQualifiedName qualifiedName, int startIndex, StringSlice& slice, Int32& nextPos);
    public T GetOrCreate(TQualifiedName qualification, Func`1<T> creator);
    public ITrieNode<T, TQualifiedName> GetOrCreateNode(TQualifiedName qualification, Func`4<ITrieNode<T, TQualifiedName>, ITrieNode<T, TQualifiedName>, StringSlice, T> creator, ITrieNodeVisitor<T, TQualifiedName> parentVisitor);
    protected Node<T, TQualifiedName> GetOrCreate(TQualifiedName qualification, Func`4<Node<T, TQualifiedName>, Node<T, TQualifiedName>, StringSlice, T> creator, ITrieNodeVisitor<T, TQualifiedName> parentsVisitor);
    public bool Add(TQualifiedName qualification, T data);
    private bool Add(TQualifiedName qualification, T data, bool overwrite);
    public void ClearData(TQualifiedName qualification);
    [CanBeNullAttribute]
protected Node<T, TQualifiedName> FindNode(TQualifiedName qualification);
    private Node<T, TQualifiedName> FindLongestPrefixNode(TQualifiedName qualification);
    [CanBeNullAttribute]
public ITrieNode<T, TQualifiedName> FindTrieNode(TQualifiedName qualification);
    [CanBeNullAttribute]
public T Find(TQualifiedName qualification);
    [CanBeNullAttribute]
public T FindLongestPrefix(TQualifiedName qualification);
    [CanBeNullAttribute]
protected abstract virtual Node<T, TQualifiedName> FindParentNode(TQualifiedName qualifiedName, String& childName);
    public void MoveSubtree(TQualifiedName oldQualifiedName, TQualifiedName newQualifiedName);
    [NotNullAttribute]
public TrieEntry[] GetChildren(TQualifiedName qualification);
    public void FindAndProcessAllPrefixes(TQualifiedName qualification, IDataConsumer<T, TQualifiedName> consumer);
    public void CollectChildrenData(TQualifiedName qualification, IDataConsumer<T, TQualifiedName> consumer);
    public void CollectSubTreeData(TQualifiedName qualification, IDataConsumer<T, TQualifiedName> consumer);
    public bool RemoveKey(TQualifiedName qualification);
    public bool RemoveSubtree(TQualifiedName qualification);
    public void Dump(TextWriter to, Func`2<T, string> dataPresenter);
    public static string DefaultDataConverter(T data);
    private void MergeWith(Node<T, TQualifiedName> currNode, Node<T, TQualifiedName> otherCurrNode, QualifiedNamesTrieBase`2<T, TQualifiedName> otherTrie, NodeMergeHandler<T, TQualifiedName> mergeHandler);
    public void MergeWith(QualifiedNamesTrieBase`2<T, TQualifiedName> otherTrie, NodeMergeHandler<T, TQualifiedName> mergeHandler);
}
[ExtensionAttribute]
public static class JetBrains.Util.ReaderWriterLockHelper : object {
    [ExtensionAttribute]
public static DisposeReaderLock GetReaderLock(ReaderWriterLock readerWriterLock);
    [ExtensionAttribute]
public static DisposeWriterLock GetWriterLock(ReaderWriterLock readerWriterLock);
    [ExtensionAttribute]
public static IDisposable UpgradeToWriterLock(ReaderWriterLock readerWriterLock);
}
public class JetBrains.Util.RecentItemsList`1 : object {
    public static int UNLIMITED;
    private int myMaxCount;
    private List`1<T> myItems;
    private T[] mySnapshot;
    private Func`2<T, bool> myItemValidator;
    [CompilerGeneratedAttribute]
private ISimpleSignal <Changed>k__BackingField;
    public ISimpleSignal Changed { get; }
    public int MaxCount { get; public set; }
    public int Count { get; }
    public IReadOnlyList`1<T> Items { get; }
    public T RecentItem { get; }
    public RecentItemsList`1(int maxCount, Func`2<T, bool> itemValidator);
    [CompilerGeneratedAttribute]
public ISimpleSignal get_Changed();
    public int get_MaxCount();
    public void set_MaxCount(int value);
    public int get_Count();
    public IReadOnlyList`1<T> get_Items();
    public void Add(T item);
    public void Remove(T item);
    public T get_RecentItem();
    private void RemoveExceedingItems();
    private void OnChanged();
    private T[] GetOrCreateSnapshot();
    private void RemoveInvalidItems();
    public void Clear();
    public bool Contains(T file);
}
public class JetBrains.Util.RecursiveFileSystemPathTrieVisitior`1 : RecursiveQualifiedNamesTrieVisitiorBase`2<T, VirtualFileSystemPath> {
}
public class JetBrains.Util.RecursiveQualifiedNamesTrieVisitior`1 : RecursiveQualifiedNamesTrieVisitiorBase`2<T, string> {
}
public abstract class JetBrains.Util.RecursiveQualifiedNamesTrieVisitiorBase`2 : object {
    [CompilerGeneratedAttribute]
private EventHandler`1<EventArgs`1<TrieEntry<T, TQualificationName>>> VisitingChildEntry;
    [CompilerGeneratedAttribute]
private EventHandler`1<EventArgs`1<ITrieNode<T, TQualificationName>>> VisitingNode;
    [CompilerGeneratedAttribute]
private EventHandler`1<EventArgs`1<ITrieNode<T, TQualificationName>>> VisitedNode;
    [CompilerGeneratedAttribute]
public void add_VisitingChildEntry(EventHandler`1<EventArgs`1<TrieEntry<T, TQualificationName>>> value);
    [CompilerGeneratedAttribute]
public void remove_VisitingChildEntry(EventHandler`1<EventArgs`1<TrieEntry<T, TQualificationName>>> value);
    [CompilerGeneratedAttribute]
public void add_VisitingNode(EventHandler`1<EventArgs`1<ITrieNode<T, TQualificationName>>> value);
    [CompilerGeneratedAttribute]
public void remove_VisitingNode(EventHandler`1<EventArgs`1<ITrieNode<T, TQualificationName>>> value);
    [CompilerGeneratedAttribute]
public void add_VisitedNode(EventHandler`1<EventArgs`1<ITrieNode<T, TQualificationName>>> value);
    [CompilerGeneratedAttribute]
public void remove_VisitedNode(EventHandler`1<EventArgs`1<ITrieNode<T, TQualificationName>>> value);
    public virtual void Visit(ITrieNode<T, TQualificationName> trieNode);
    protected virtual void ProcessBeforeChildren(ITrieNode<T, TQualificationName> trieNode);
    protected virtual void ProcessChild(TrieEntry<T, TQualificationName> childEntry);
    protected virtual void ProcessAfterChildren(ITrieNode<T, TQualificationName> trieNode);
}
public class JetBrains.Util.Reflection.LoggerTypeDescriptorContext : object {
    private ILogger myLogger;
    [NotNullAttribute]
protected ILogger Logger { get; }
    private IContainer System.ComponentModel.ITypeDescriptorContext.Container { get; }
    private object System.ComponentModel.ITypeDescriptorContext.Instance { get; }
    private PropertyDescriptor System.ComponentModel.ITypeDescriptorContext.PropertyDescriptor { get; }
    public LoggerTypeDescriptorContext(ILogger logger);
    private sealed virtual override object System.IServiceProvider.GetService(Type serviceType);
    protected ILogger get_Logger();
    private sealed virtual override bool System.ComponentModel.ITypeDescriptorContext.OnComponentChanging();
    private sealed virtual override void System.ComponentModel.ITypeDescriptorContext.OnComponentChanged();
    private sealed virtual override IContainer System.ComponentModel.ITypeDescriptorContext.get_Container();
    private sealed virtual override object System.ComponentModel.ITypeDescriptorContext.get_Instance();
    private sealed virtual override PropertyDescriptor System.ComponentModel.ITypeDescriptorContext.get_PropertyDescriptor();
    private sealed virtual override ValueSerializer System.Windows.Markup.IValueSerializerContext.GetValueSerializerFor(Type type);
    private sealed virtual override ValueSerializer System.Windows.Markup.IValueSerializerContext.GetValueSerializerFor(PropertyDescriptor descriptor);
}
public static class JetBrains.Util.Reflection.PlatformCommonBindingRedirects : object {
    public static AssemblyNameInfo SystemRuntimeCompilerServicesUnsafeV6000;
    public static ImmutableHashSet`1<AssemblyNameInfo> PlatformMandatoryBindingRedirectsTargets;
    public static ImmutableArray`1<AssemblyBindingRedirections> PlatformMandatoryBindingRedirectPolicies;
    public static Lazy`1<ImmutableByteStream> DefaultConfigurationFileForPlatform;
    private static PlatformCommonBindingRedirects();
}
[ExtensionAttribute]
public static class JetBrains.Util.RegistryKeyEx : object {
    [ExtensionAttribute]
[CanBeNullAttribute]
public static RegistryKey OpenSubKey(RegistryKey root, Lifetime lifetime, string subKeyName);
}
public class JetBrains.Util.RegistryUtil : object {
    [ObsoleteAttribute("See RegistryHiveAccess class which has registry-view-bound helper methods.")]
[CanBeNullAttribute]
public static RegistryKey OpenSoftwareKey(Lifetime lifetime);
    [NotNullAttribute]
public static string GetMimeType(string sExtensionWithDot);
}
public static class JetBrains.Util.ReinterpretCast : object {
    public static TTo ValueTypeOrNullable(TFrom original);
}
[ExtensionAttribute]
public static class JetBrains.Util.ResultExtensions : object {
    [ExtensionAttribute]
public static bool IsSuccess(OperationResult result);
    [ExtensionAttribute]
public static bool IsFail(OperationResult result);
}
[EditorBrowsableAttribute("1")]
public static class JetBrains.Util.RichText.ImplementationDetailsForRichText : object {
    public static RenderCacheAccessor RenderCaches;
    public static FrugalLocalList`1<RichString> GetRawParts(RichText instance);
}
public class JetBrains.Util.RichText.JetFont : object {
    [CompilerGeneratedAttribute]
private double <EmSizeInDip>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FontFamilyName>k__BackingField;
    [CompilerGeneratedAttribute]
private JetFontStyles <FontStyle>k__BackingField;
    public double EmSizeInDip { get; }
    [NotNullAttribute]
public string FontFamilyName { get; }
    public JetFontStyles FontStyle { get; }
    public JetFont(string fontFamilyName, double emSizeInDip, JetFontStyles fontstyle);
    [CompilerGeneratedAttribute]
public double get_EmSizeInDip();
    [CompilerGeneratedAttribute]
public string get_FontFamilyName();
    [CompilerGeneratedAttribute]
public JetFontStyles get_FontStyle();
    public sealed virtual bool Equals(JetFont other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(JetFont left, JetFont right);
    public static bool op_Inequality(JetFont left, JetFont right);
    public virtual string ToString();
}
public enum JetBrains.Util.RichText.JetTextLineTrimming : Enum {
    public int value__;
    public static JetTextLineTrimming None;
    public static JetTextLineTrimming EllipsisCharacter;
    public static JetTextLineTrimming EllipsisWord;
    public static JetTextLineTrimming EllipsisPath;
}
[FlagsAttribute]
public enum JetBrains.Util.RichText.MnemonicRendering : Enum {
    public int value__;
    public static MnemonicRendering No;
    public static MnemonicRendering RemoveAmpersand;
    public static MnemonicRendering UnderlineByAmpersand;
}
public static class JetBrains.Util.RichText.RichTextFromSimpleMarkdown : object {
    public static RichText Convert(string str);
    [CompilerGeneratedAttribute]
internal static void <Convert>g__DropCurrentPart|0_0(<>c__DisplayClass0_0& );
}
public class JetBrains.Util.Runnable : MulticastDelegate {
    public Runnable(object object, IntPtr method);
    public virtual void Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class JetBrains.Util.SeparateThreadRunner : object {
    private Thread myWorkThread;
    private Thread myWaitThread;
    private int myWorkThreadId;
    private int myWaitThreadId;
    private static ILogger ourLogger;
    public SeparateThreadRunner(Lifetime lifetime, string name, Action`1<SeparateThreadRunner> actionToPerform, Action`1<SeparateThreadRunner> actionOnTimeout, TimeSpan timeout);
    private static SeparateThreadRunner();
    private static void AbortThread(Thread thread, int threadId, TimeSpan abortTimeout);
    private static bool TerminateThread(int threadId, string threadName);
}
public class JetBrains.Util.Serialization.CsexpArchive : object {
    [CanBeNullAttribute]
private CsexpReader myReader;
    [CanBeNullAttribute]
private CsexpWriter myWriter;
    public bool IsStoring { get; }
    public CsexpArchive(CsexpReader reader);
    public CsexpArchive(CsexpWriter writer);
    public bool get_IsStoring();
    public AutoEndSerializeList BeginSerializeList();
    public AutoEndSerializeList BeginSerializeNamedList(string name);
    [NotNullAttribute]
public CsexpReader GetReader();
    [NotNullAttribute]
public CsexpWriter GetWriter();
    public static CsexpArchive op_Implicit(CsexpReader reader);
    public static CsexpArchive op_Implicit(CsexpWriter writer);
    public void SerializeNamedListItems(string listname, ICollection`1<TItem> items, Action`2<TItem, CsexpArchive> FSerializeItem);
    public void SerializeNamedListItems(string listname, FrugalLocalList`1& items, Action`2<TItem, CsexpArchive> FSerializeItem);
    public void SerializeNamedListItems(string listname, ICollection`1<TItem> items, Func`2<CsexpReader, TItem> FRead, Action`2<TItem, CsexpWriter> FWrite);
    public void SerializeNamedListItemsByRef(string listname, ICollection`1& items, SerializeItemDelegate`1<TItem> FSerializeItem);
    public void SerializeNamedListItemsByRef(string listname, ICollection`1& items);
    public void SerializeNamedListItemsByRef(string listname, IList`1& items, SerializeItemDelegate`1<TItem> FSerializeItem);
    public void SerializeNamedListItemsByRef(string listname, IList`1& items);
    public void SerializeNamedListItemsByRef(string listname, FrugalLocalList`1& items, SerializeItemDelegate`1<TItem> FSerializeItem);
    public void SerializeNamedListItemsByRef(string listname, ImmutableArray`1& items, SerializeItemDelegate`1<TItem> FSerializeItem);
    public void SerializeNamedListItemsByRef(string listname, FrugalLocalList`1& items);
    public void SerializeNamedValue(string name, TValue& value);
    public void SerializeNamedValue(string name, String& value);
    public void SerializeValue(TValue& value);
    public void SerializeValue(String& value);
    public virtual string ToString();
}
[ExtensionAttribute]
public static class JetBrains.Util.Serialization.CsexpArchiveEx : object {
    [ExtensionAttribute]
public static void SerializeDoubleTextValue(CsexpArchive ar, Double& value);
}
public class JetBrains.Util.Serialization.CsexpReader : object {
    private static int BuffersCbSize;
    [CanBeNullAttribute]
private DelayedListCloseError myDelayedError;
    private Stream myInStream;
    private UInt32 myLevel;
    private Byte[] myPrecache;
    private UInt32 myPrecacheDataEnd;
    private UInt32 myPrecacheDataStart;
    private ulong myReadTillNextToken;
    private Byte[] myTmpBuffer;
    private CsexpTokenKind myTokenKind;
    public UInt32 Level { get; }
    public CsexpTokenKind TokenKind { get; }
    public CsexpReader(Stream instream);
    public UInt32 get_Level();
    public CsexpTokenKind get_TokenKind();
    public ulong GetCurrentStringTokenCbSize();
    [NotNullAttribute]
public Byte[] ReadBufferValue();
    public UInt32 ReadBufferValue(Byte[] buffer, UInt32 position);
    public void ReadBufferValue(Cookie writeout);
    public ulong ReadDecValue();
    public ulong ReadHexValue();
    public void ReadStreamValue(Stream outstream);
    [NotNullAttribute]
public string ReadStringValue(string assertThisValue);
    public void ReportDelayedError(Exception ex);
    public CsexpTokenKind Skip();
    private void BeginReadNextToken();
    private void ColdThrowDelayedError();
    private void FillCache();
    private long GetUnderlyingStreamPosition();
    private void ReadBufferValueSlow(Byte[] buffer, UInt32 position, UInt32 dwRemaining);
    private void ReadBufferValueSlow(Cookie writeout, UInt32 dwRemaining);
    private byte ReadByte();
    private byte ReadByteSlow();
    [NotNullAttribute]
private string ReadStringValueLarge(string assertThisValue);
    private void SkipUnreadBytes();
    private void ThrowDelayedError();
}
[ExtensionAttribute]
public static class JetBrains.Util.Serialization.CsexpReaderEx : object {
    [ExtensionAttribute]
public static AutoEndReadList BeginReadList(CsexpReader reader);
    [ExtensionAttribute]
public static AutoEndReadList BeginReadNamedList(CsexpReader reader, string name);
    [ExtensionAttribute]
public static void EndReadList(CsexpReader reader, string sListNameIfKnown);
    [ExtensionAttribute]
public static double ReadDoubleTextValue(CsexpReader reader);
    [ExtensionAttribute]
[NotNullAttribute]
public static string ReadNamedValue(CsexpReader reader, string name);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static TValue ReadNamedValue(CsexpReader reader, string name);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static TValue ReadValue(CsexpReader reader);
    private static void ColdReportEndReadListViolation(CsexpReader reader, string sListNameIfKnown);
    private static void ColdThrowBeginReadListTokenKind(CsexpReader reader);
    private static void ColdThrowBeginReadNamedListNameTokenKind(CsexpReader reader, string name);
    private static void ReadDoubleTextValue_Throw(HResults hr, Cookie buffer, int nBytes);
    private static double ReadDoubleTextValue_ToString(Cookie buffer);
}
public static class JetBrains.Util.Serialization.CsexpSerialization : object {
    public static string DefaultFileExtension;
    public static Encoding TransportEncoding;
    private static CsexpSerialization();
}
public enum JetBrains.Util.Serialization.CsexpTokenKind : Enum {
    public int value__;
    public static CsexpTokenKind End;
    public static CsexpTokenKind ListOpen;
    public static CsexpTokenKind ListClose;
    public static CsexpTokenKind String;
}
public class JetBrains.Util.Serialization.CsexpWriter : object {
    private Byte[] myBuffer;
    [NotNullAttribute]
private Stream myOutStream;
    [CompilerGeneratedAttribute]
private bool <IsOuterListClosed>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Level>k__BackingField;
    public bool IsOuterListClosed { get; private set; }
    public UInt32 Level { get; private set; }
    public CsexpWriter(Stream stream);
    [CompilerGeneratedAttribute]
public bool get_IsOuterListClosed();
    [CompilerGeneratedAttribute]
private void set_IsOuterListClosed(bool value);
    [CompilerGeneratedAttribute]
public UInt32 get_Level();
    [CompilerGeneratedAttribute]
private void set_Level(UInt32 value);
    public void CloseNestedList();
    public void OpenNestedList();
    public void WriteBuffer(Byte[] value);
    public void WriteBuffer(ByteBuffer& buffer);
    public void WriteBuffer(Void* pbuffer, UInt32 length);
    public void WriteDecValue(ulong value);
    public void WriteHexValue(ulong value);
    public void WriteStream(Stream instream);
    public void WriteString(string value);
}
[ExtensionAttribute]
public static class JetBrains.Util.Serialization.CsexpWriterEx : object {
    [ExtensionAttribute]
public static AutoEndWriteList BeginWriteList(CsexpWriter writer);
    [ExtensionAttribute]
public static AutoEndWriteList BeginWriteNamedList(CsexpWriter writer, string name);
    [ExtensionAttribute]
public static void WriteDoubleTextValue(CsexpWriter writer, double value);
    [ExtensionAttribute]
public static void WriteNameValue(CsexpWriter writer, string name, string value);
    [ExtensionAttribute]
public static void WriteNameValue(CsexpWriter writer, string name, TValue value);
    [ExtensionAttribute]
public static void WriteSpan(CsexpWriter writer, Span`1<byte> buffer);
    [ExtensionAttribute]
public static void WriteValue(CsexpWriter writer, TValue value);
}
public class JetBrains.Util.Serialization.JsonTypeConverter`1 : TypeConverterBase`1<T> {
    private static DataContractJsonSerializer ourJsonSerializer;
    private static JsonTypeConverter`1();
    private static string SerializeToString(ITypeDescriptorContext typeDescriptorContext, CultureInfo cultureInfo, T value);
    private static T DeserializeFromString(ITypeDescriptorContext typeDescriptorContext, CultureInfo cultureInfo, string value);
}
public class JetBrains.Util.Serialization.JsonTypeConverterNewtonsoft`1 : TypeConverterBase`1<T> {
    private static Func`4<ITypeDescriptorContext, CultureInfo, string, T> λFromString;
    private static Func`4<ITypeDescriptorContext, CultureInfo, T, string> λToString;
    private static JsonTypeConverterNewtonsoft`1();
}
public class JetBrains.Util.Serialization.JsonValueSerializer`1 : ValueSerializerBase`1<T> {
    private static DataContractJsonSerializer ourJsonSerializer;
    private static JsonValueSerializer`1();
    private static T FFromString(IValueSerializerContext valueSerializerContext, string value);
    private static string FToString(IValueSerializerContext valueSerializerContext, T value);
}
public class JetBrains.Util.Serialization.JsonValueSerializerNewtonsoft`1 : ValueSerializerBase`1<T> {
    private static Func`3<IValueSerializerContext, string, T> λFromString;
    private static Func`3<IValueSerializerContext, T, string> λToString;
    private static JsonValueSerializerNewtonsoft`1();
}
[AttributeUsageAttribute("28")]
public class JetBrains.Util.Serialization.MemberwiseSerializableAttribute : Attribute {
}
[AttributeUsageAttribute("28")]
public class JetBrains.Util.Serialization.XamlSerializableAttribute : Attribute {
}
public abstract class JetBrains.Util.SharedMemory : object {
    [CompilerGeneratedAttribute]
private Byte* <Address>k__BackingField;
    [CompilerGeneratedAttribute]
private long <MappedSize>k__BackingField;
    [CompilerGeneratedAttribute]
private long <MaxSize>k__BackingField;
    public Byte* Address { get; private set; }
    public long MappedSize { get; private set; }
    public long MaxSize { get; }
    public long ConfiguredSize { get; }
    protected SharedMemory(Lifetime lifetime, long maxSize);
    [CompilerGeneratedAttribute]
public Byte* get_Address();
    [CompilerGeneratedAttribute]
private void set_Address(Byte* value);
    [CompilerGeneratedAttribute]
public long get_MappedSize();
    [CompilerGeneratedAttribute]
private void set_MappedSize(long value);
    [CompilerGeneratedAttribute]
public long get_MaxSize();
    public abstract virtual long get_ConfiguredSize();
    public IDisposable Map(long size);
    private void Unmap();
    public void Delete();
    protected abstract virtual Byte* MapImpl(long size);
    protected abstract virtual void UnmapImpl();
    protected abstract virtual void DeleteImpl();
}
[IsReadOnlyAttribute]
[PublicAPIAttribute]
public class JetBrains.Util.SharedStopwatch : ValueType {
    private long myStartedTicks;
    private static Stopwatch ourStopwatch;
    public TimeSpan Elapsed { get; }
    public long ElapsedMilliseconds { get; }
    public long ElapsedTicks { get; }
    private SharedStopwatch(long startedTicks);
    private static SharedStopwatch();
    public TimeSpan get_Elapsed();
    public long get_ElapsedMilliseconds();
    public long get_ElapsedTicks();
    [MustUseReturnValueAttribute]
public static SharedStopwatch StartNew();
}
[IsReadOnlyAttribute]
public class JetBrains.Util.ShortName : ValueType {
    public string Name;
    public int HashCode;
    [CompilerGeneratedAttribute]
private static IEqualityComparer`1<ShortName> <EqualityComparer>k__BackingField;
    public static IEqualityComparer`1<ShortName> EqualityComparer { get; }
    private ShortName(string shortName);
    private static ShortName();
    [PureAttribute]
public static ShortName Create(FileSystemPath path);
    [PureAttribute]
public static ShortName Create(string path);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ShortName other);
    public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public static IEqualityComparer`1<ShortName> get_EqualityComparer();
    public virtual string ToString();
}
public class JetBrains.Util.SimpleTextDiff : object {
    [CompilerGeneratedAttribute]
private Range <LinesRange>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <NewLines>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <OldLines>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public Range LinesRange { get; public set; }
    public String[] NewLines { get; public set; }
    public String[] OldLines { get; public set; }
    public SimpleTextDiff(Range LinesRange, String[] NewLines, String[] OldLines);
    [CompilerGeneratedAttribute]
protected SimpleTextDiff(SimpleTextDiff original);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public Range get_LinesRange();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_LinesRange(Range value);
    [CompilerGeneratedAttribute]
public String[] get_NewLines();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_NewLines(String[] value);
    [CompilerGeneratedAttribute]
public String[] get_OldLines();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_OldLines(String[] value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(SimpleTextDiff left, SimpleTextDiff right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(SimpleTextDiff left, SimpleTextDiff right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(SimpleTextDiff other);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual SimpleTextDiff <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(Range& LinesRange, String[]& NewLines, String[]& OldLines);
}
public class JetBrains.Util.SimpleTextDiffConflictException : ApplicationException {
    [CompilerGeneratedAttribute]
private string <CurrentText>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OldText>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NewText>k__BackingField;
    public string CurrentText { get; }
    public string OldText { get; }
    public string NewText { get; }
    public SimpleTextDiffConflictException(SimpleTextDiff diff, IReadOnlyList`1<string> currentLines);
    [CompilerGeneratedAttribute]
public string get_CurrentText();
    [CompilerGeneratedAttribute]
public string get_OldText();
    [CompilerGeneratedAttribute]
public string get_NewText();
    public virtual string ToString();
}
[ExtensionAttribute]
public static class JetBrains.Util.SimpleTextDiffUtil : object {
    private static char EOF;
    private static ILogger ourLogger;
    private static Dictionary`2<char, string> ourEscapedSymbols;
    private static SimpleTextDiffUtil();
    public static SimpleTextDiff CalculateDiffInLines(string oldContent, string newContent);
    [ExtensionAttribute]
public static bool IsEmpty(SimpleTextDiff diff);
    public static void ApplyDiff(SimpleTextDiff diff, VirtualFileSystemPath location, Encoding oldEncoding, Encoding newEncoding);
    [ExtensionAttribute]
public static SimpleTextDiff ResolveConflictIfAny(SimpleTextDiff diff, List`1<string> currentLines);
    [ExtensionAttribute]
public static SimpleTextDiff[] OptimizeDiff(SimpleTextDiff diff);
    public static List`1<string> ReadLinesWithLineEndings(string string);
    [ExtensionAttribute]
public static SimpleTextDiff UnifyLineEndings(SimpleTextDiff diff, LineEnding lineEnding);
    [ExtensionAttribute]
private static ValueTuple`2<int, int> GetContextSize(SimpleTextDiff diff);
    [ExtensionAttribute]
private static SimpleTextDiff ThrowAwayContext(SimpleTextDiff diff);
    private static SimpleTextDiff DoesMatchAtLine(SimpleTextDiff diff, IList`1<string> currentLines, int startLineIndex, bool allowMidStringSearch);
    private static Nullable`1<LineAndChar> DoesMatchAtLineAndChar(SimpleTextDiff diff, IList`1<string> currentLines, LineAndChar startIndex, int prefixSize);
    private static SimpleTextDiff ResolveDiff(SimpleTextDiff diff, IList`1<string> currentLines, LineAndChar startIndex);
    private static string FetchLine(IList`1<string> lines, LineAndChar index);
    private static bool EqualsIgnoreFormatting(string currentLine, string newLine, bool requireLineEnding);
    private static bool AreSameSymbols(string line1, Int32& i1, string line2, Int32& i2);
    private static bool IsEscapedSymbolAt(string line, int i, string escapedSymbol);
    private static ValueTuple`2<int, int> FindDiffStart(string oldContent, string newContent);
    private static ValueTuple`2<int, int> FindPrefixStart(string content, ValueTuple`2<int, int> diffStart);
    private static int FindDiffEnd(string oldContent, string newContent, int stopOffset);
    private static int FindPostfixEnd(string content, int diffEndOffsetFromRight);
    private static Range GetReplaceWholeFileRange();
    private static String[] SplitByLines(StringSlice content);
    private static bool IsLineEndedAt(string content, int i);
    private static bool IsLineEndedAt(StringSlice content, int i);
    private static List`1<string> ReadLinesWithLineEndings(StreamReader reader);
    [NotNullAttribute]
private static List`1<string> ReadLinesWithLineEndings(IReader reader);
}
[DefaultMemberAttribute("Item")]
[DebuggerTypeProxyAttribute("JetBrains.Util.SortedOneToListMap`2/OneToListMapDebugView")]
[DebuggerDisplayAttribute("Count = {Count}")]
public class JetBrains.Util.SortedOneToListMap`2 : object {
    private static Statistics Statistics;
    private SortedDictionary`2<TKey, List`1<TValue>> myMap;
    public int Count { get; }
    public ICollection`1<TKey> Keys { get; }
    [NotNullAttribute]
public IList`1<TValue> Item { get; }
    public SortedOneToListMap`2(IEnumerable`1<KeyValuePair`2<TKey, IList`1<TValue>>> enumerable, IComparer`1<TKey> comparer);
    public SortedOneToListMap`2(IComparer`1<TKey> comparer);
    private static SortedOneToListMap`2();
    public int get_Count();
    public void Clear();
    public ICollection`1<TKey> get_Keys();
    public IList`1<TValue> get_Item(TKey key);
    public void Add(TKey key, TValue value);
    public void AddValue(TKey key, TValue value);
    public void AddValueRange(TKey key, IEnumerable`1<TValue> list);
    public bool RemoveValue(TKey key, TValue value);
    public bool RemoveKey(TKey key);
    public bool ContainsKey(TKey key);
    public bool ContainsValue(TValue value);
    public bool ContainsPair(TKey key, TValue value);
    [CanBeNullAttribute]
private List`1<TValue> GetValues(TKey key);
    [IteratorStateMachineAttribute("JetBrains.Util.SortedOneToListMap`2/<GetEnumerator>d__21")]
public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, IList`1<TValue>>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public void ClearKey(TKey key);
}
public class JetBrains.Util.StackTrace.MethodParameterInfoModel : object {
    [NotNullAttribute]
public string Name;
    [NotNullAttribute]
public string Type;
    public MethodParameterInfoModel(ParameterInfo p);
}
public class JetBrains.Util.StackTrace.StackFrameModel : object {
    [CanBeNullAttribute]
public string MethodName;
    [CanBeNullAttribute]
public string DeclaredTypeFullName;
    [CanBeNullAttribute]
public MethodParameterInfoModel[] Parameters;
    public int IlOffset;
    [CanBeNullAttribute]
public string FileName;
    public int ColumnNumber;
    public int LineNumber;
    public bool HasMethod { get; }
    public StackFrameModel(StackFrame frame);
    public bool get_HasMethod();
}
public class JetBrains.Util.StackTrace.StackTraceModel : object {
    [NotNullAttribute]
public StackFrameModel[] Frames;
    public StackTraceModel(StackTrace trace);
    public StackTraceModel(IEnumerable`1<StackFrame> frames);
}
public static class JetBrains.Util.StackTrace.StackTraceModelUtil : object {
    [NotNullAttribute]
public static string StackFrameToString(StackFrameModel frame);
    [NotNullAttribute]
public static RichText StackFrameToRichString(StackFrameModel frame, double opacity);
}
public class JetBrains.Util.StackTraceParser.CompositeNode : StackTraceNode {
    private List`1<StackTraceNode> myNodes;
    public List`1<StackTraceNode> Nodes { get; }
    public CompositeNode(TextRange range);
    public void AppendNode(StackTraceNode node);
    public List`1<StackTraceNode> get_Nodes();
    public virtual void Dump(TextWriter writer);
    public virtual void Accept(StackTraceNodeVisitor visitor);
    protected bool Equals(CompositeNode other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class JetBrains.Util.StackTraceParser.IdentifierNode : StackTraceNode {
    private string myName;
    private IdentifierNode myQualifier;
    private IList`1<IdentifierNode> myTypeParameters;
    public string Name { get; public set; }
    public IdentifierNode Qualifier { get; public set; }
    public IList`1<IdentifierNode> TypeParameters { get; public set; }
    public IdentifierNode(string fullName, TextRange range);
    public string get_Name();
    public void set_Name(string value);
    public IdentifierNode get_Qualifier();
    public void set_Qualifier(IdentifierNode value);
    public IList`1<IdentifierNode> get_TypeParameters();
    public void set_TypeParameters(IList`1<IdentifierNode> value);
    public void DumpQualifier(TextWriter writer);
    public virtual void Dump(TextWriter writer);
    public virtual void Accept(StackTraceNodeVisitor visitor);
    protected bool Equals(IdentifierNode other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class JetBrains.Util.StackTraceParser.Java.JavaStackTraceParser : object {
    private JavaStackTraceLexer myLexer;
    private CompositeNode myRootNode;
    public CompositeNode RootNode { get; }
    public JavaStackTraceParser(JavaStackTraceLexer lexer);
    public JavaStackTraceParser(string text);
    public CompositeNode get_RootNode();
    public void Parse();
    private bool ParseExceptions(CompositeNode compositeNode);
    private bool ParseMethod(CompositeNode parentNode);
    private bool ParsePath(CompositeNode parentNode);
    private IdentifierNode ParseIdentifier();
    private IdentifierNode ProcessQualifier(IdentifierNode current);
}
public class JetBrains.Util.StackTraceParser.JavaStackTraceLexer : object {
    private static int YY_F;
    private static int YY_NO_STATE;
    private static int YY_NOT_ACCEPT;
    private static int YY_START;
    private static int YY_END;
    private static int YY_NO_ANCHOR;
    private static int YY_BOL;
    private static int YY_EOF;
    protected StackTokenTypes currTokenType;
    private int yy_buffer_index;
    private int yy_buffer_start;
    private int yy_buffer_end;
    private IBuffer yy_buffer;
    private int yy_eof_pos;
    private bool yy_at_bol;
    private int yy_lexical_state;
    protected static int YYINITIAL;
    private static Int32[] yy_state_dtrans;
    private static int YY_E_INTERNAL;
    private static int YY_E_MATCH;
    private static String[] yy_error_string;
    private static Int32[] yy_acpt;
    private static Int32[] yy_cmap;
    private static Int32[] yy_rmap;
    private static Int32[0...,0...] yy_nxt;
    public UInt32 LexerState { get; }
    public StackTokenTypes TokenType { get; }
    public int TokenStart { get; }
    public int TokenEnd { get; }
    public string TokenText { get; }
    public int LexemIndent { get; }
    public IBuffer Buffer { get; }
    public static short NStates { get; }
    protected int BufferIndex { get; protected set; }
    protected int BufferStart { get; protected set; }
    protected int BufferEnd { get; protected set; }
    protected int EOFPos { get; protected set; }
    protected int LexicalState { get; protected set; }
    public JavaStackTraceLexer(IBuffer buffer);
    public JavaStackTraceLexer(IBuffer buffer, int startOffset, int endOffset);
    private static JavaStackTraceLexer();
    protected StackTokenTypes makeToken(StackTokenTypes type);
    public void Start();
    public void Start(int startOffset, int endOffset, UInt32 state);
    public void Advance();
    public UInt32 get_LexerState();
    public State SaveState();
    public void RestoreState(State pos);
    public StackTokenTypes get_TokenType();
    public int get_TokenStart();
    public int get_TokenEnd();
    public string get_TokenText();
    public int get_LexemIndent();
    public IBuffer get_Buffer();
    protected virtual void locateToken();
    public static short get_NStates();
    protected int get_BufferIndex();
    protected void set_BufferIndex(int value);
    protected int get_BufferStart();
    protected void set_BufferStart(int value);
    protected int get_BufferEnd();
    protected void set_BufferEnd(int value);
    protected int get_EOFPos();
    protected void set_EOFPos(int value);
    protected int get_LexicalState();
    protected void set_LexicalState(int value);
    private void yybegin(int state);
    private int yy_advance();
    private void yy_move_end();
    private void yy_mark_start();
    private void yy_mark_end();
    private void yy_to_mark();
    internal string yytext();
    private int yylength();
    private void yy_error(int code, bool fatal);
    public StackTokenTypes _locateToken();
}
public class JetBrains.Util.StackTraceParser.MethodNode : StackTraceNode {
    private IdentifierNode myName;
    private ParameterListNode myParameterList;
    public IdentifierNode Name { get; }
    public ParameterListNode ParameterList { get; public set; }
    public MethodNode(IdentifierNode fullName, TextRange range);
    public IdentifierNode get_Name();
    public ParameterListNode get_ParameterList();
    public void set_ParameterList(ParameterListNode value);
    public virtual void Dump(TextWriter writer);
    public virtual void Accept(StackTraceNodeVisitor visitor);
    protected bool Equals(MethodNode other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public enum JetBrains.Util.StackTraceParser.ParameterKind : Enum {
    public int value__;
    public static ParameterKind ByVal;
    public static ParameterKind ByRef;
    public static ParameterKind Pointer;
}
public class JetBrains.Util.StackTraceParser.ParameterListNode : CompositeNode {
    public ParameterListNode(TextRange range);
    public virtual void Dump(TextWriter writer);
    public virtual void Accept(StackTraceNodeVisitor visitor);
}
public class JetBrains.Util.StackTraceParser.ParameterNode : StackTraceNode {
    private IdentifierNode myType;
    private IdentifierNode myName;
    private TextNode myValue;
    private ParameterKind myKind;
    private int myArrayBounds;
    public ParameterKind Kind { get; }
    public int ArrayBounds { get; }
    public IdentifierNode Type { get; }
    public IdentifierNode Name { get; }
    public TextNode Value { get; }
    public ParameterNode(TextRange range, IdentifierNode type, IdentifierNode name, ParameterKind kind, int arrayBounds, TextNode value);
    public ParameterKind get_Kind();
    public int get_ArrayBounds();
    public IdentifierNode get_Type();
    public IdentifierNode get_Name();
    public TextNode get_Value();
    public virtual void Dump(TextWriter writer);
    public virtual void Accept(StackTraceNodeVisitor visitor);
}
public class JetBrains.Util.StackTraceParser.PathNode : StackTraceNode {
    private string myPath;
    private int myLine;
    private int myColumn;
    public string Path { get; }
    public int Line { get; public set; }
    public int Column { get; public set; }
    public PathNode(TextRange range, string path);
    public string get_Path();
    public int get_Line();
    public void set_Line(int value);
    public int get_Column();
    public void set_Column(int value);
    public virtual void Dump(TextWriter writer);
    public virtual void Accept(StackTraceNodeVisitor visitor);
}
internal class JetBrains.Util.StackTraceParser.Replacement : object {
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Length>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ReplacementString>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public int Index { get; public set; }
    public int Length { get; public set; }
    public string ReplacementString { get; public set; }
    public Replacement(int Index, int Length, string ReplacementString);
    [CompilerGeneratedAttribute]
protected Replacement(Replacement original);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public int get_Index();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Index(int value);
    [CompilerGeneratedAttribute]
public int get_Length();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Length(int value);
    [CompilerGeneratedAttribute]
public string get_ReplacementString();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ReplacementString(string value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(Replacement left, Replacement right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(Replacement left, Replacement right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(Replacement other);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual Replacement <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(Int32& Index, Int32& Length, String& ReplacementString);
}
public enum JetBrains.Util.StackTraceParser.StackTokenTypes : Enum {
    public int value__;
    public static StackTokenTypes UNDEFINED;
    public static StackTokenTypes WHITESPACE;
    public static StackTokenTypes IDENTIFIER;
    public static StackTokenTypes WORD;
    public static StackTokenTypes NUMBER;
    public static StackTokenTypes PATH_SEPARATOR;
    public static StackTokenTypes LPARENTH;
    public static StackTokenTypes RPARENTH;
    public static StackTokenTypes DOT;
    public static StackTokenTypes COMMA;
    public static StackTokenTypes AMPERSAND;
    public static StackTokenTypes ASTERISK;
    public static StackTokenTypes LBRACKET;
    public static StackTokenTypes RBRACKET;
    public static StackTokenTypes LANGLE;
    public static StackTokenTypes RANGLE;
    public static StackTokenTypes COLON;
    public static StackTokenTypes EXCLAMATION;
    public static StackTokenTypes EQUALS;
    public static StackTokenTypes LBRACE;
    public static StackTokenTypes RBRACE;
    public static StackTokenTypes QUOTATION;
    public static StackTokenTypes MINUS;
}
public class JetBrains.Util.StackTraceParser.StackTraceLexer : object {
    private static int YY_F;
    private static int YY_NO_STATE;
    private static int YY_NOT_ACCEPT;
    private static int YY_START;
    private static int YY_END;
    private static int YY_NO_ANCHOR;
    private static int YY_BOL;
    private static int YY_EOF;
    protected StackTokenTypes currTokenType;
    private int yy_buffer_index;
    private int yy_buffer_start;
    private int yy_buffer_end;
    private IBuffer yy_buffer;
    private int yy_eof_pos;
    private bool yy_at_bol;
    private int yy_lexical_state;
    protected static int YYINITIAL;
    private static Int32[] yy_state_dtrans;
    private static int YY_E_INTERNAL;
    private static int YY_E_MATCH;
    private static String[] yy_error_string;
    private static Int32[] yy_acpt;
    private static Int32[] yy_cmap;
    private static Int32[] yy_rmap;
    private static Int32[0...,0...] yy_nxt;
    public UInt32 LexerState { get; }
    public StackTokenTypes TokenType { get; }
    public int TokenStart { get; }
    public int TokenEnd { get; }
    public string TokenText { get; }
    public int LexemIndent { get; }
    public IBuffer Buffer { get; }
    public static short NStates { get; }
    protected int BufferIndex { get; protected set; }
    protected int BufferStart { get; protected set; }
    protected int BufferEnd { get; protected set; }
    protected int EOFPos { get; protected set; }
    protected int LexicalState { get; protected set; }
    public StackTraceLexer(IBuffer buffer);
    public StackTraceLexer(IBuffer buffer, int startOffset, int endOffset);
    private static StackTraceLexer();
    protected StackTokenTypes makeToken(StackTokenTypes type);
    public void Start();
    public void Start(int startOffset, int endOffset, UInt32 state);
    public void Advance();
    public UInt32 get_LexerState();
    public State SaveState();
    public void RestoreState(State pos);
    public StackTokenTypes get_TokenType();
    public int get_TokenStart();
    public int get_TokenEnd();
    public string get_TokenText();
    public int get_LexemIndent();
    public IBuffer get_Buffer();
    protected virtual void locateToken();
    public static short get_NStates();
    protected int get_BufferIndex();
    protected void set_BufferIndex(int value);
    protected int get_BufferStart();
    protected void set_BufferStart(int value);
    protected int get_BufferEnd();
    protected void set_BufferEnd(int value);
    protected int get_EOFPos();
    protected void set_EOFPos(int value);
    protected int get_LexicalState();
    protected void set_LexicalState(int value);
    private void yybegin(int state);
    private int yy_advance();
    private void yy_move_end();
    private void yy_mark_start();
    private void yy_mark_end();
    private void yy_to_mark();
    internal string yytext();
    private int yylength();
    private void yy_error(int code, bool fatal);
    public StackTokenTypes _locateToken();
}
public static class JetBrains.Util.StackTraceParser.StackTraceLexerUtil : object {
    public static string Normalize(string text);
}
public abstract class JetBrains.Util.StackTraceParser.StackTraceNode : object {
    private TextRange myRange;
    public TextRange Range { get; }
    protected StackTraceNode(TextRange range);
    public TextRange get_Range();
    public void UnionRange(TextRange range);
    public abstract virtual void Dump(TextWriter writer);
    public abstract virtual void Accept(StackTraceNodeVisitor visitor);
}
public class JetBrains.Util.StackTraceParser.StackTraceNodeVisitor : object {
    public virtual void VisitText(TextNode node);
    public virtual void VisitParameter(ParameterNode node);
    public virtual void VisitPath(PathNode node);
    public virtual void VisitMethod(MethodNode node);
    public virtual void VisitIdentifier(IdentifierNode node);
    public virtual void VisitCompositeNode(CompositeNode node);
    public virtual void VisitParameterList(ParameterListNode node);
}
[ObsoleteAttribute("Consider using JetBrains.ReSharper.Feature.Services.StackTraces.StackTrace.Parsers.StackTraceParser instead")]
public class JetBrains.Util.StackTraceParser.StackTraceParser : object {
    private StackTraceLexer myLexer;
    private String[] myInvalidPathChars;
    private bool myCheckForInvalidChars;
    private bool myParsePath;
    private CompositeNode myRootNode;
    public CompositeNode RootNode { get; }
    public StackTraceParser(StackTraceLexer lexer);
    public StackTraceParser(StackTraceLexer lexer, bool checkForInvalidChars, bool parsePath);
    public CompositeNode get_RootNode();
    public void Parse();
    private bool ParseMethod(CompositeNode node);
    private static string CleanPath(string path);
    private bool ParsePath(CompositeNode parentNode);
    private bool ParsePathSlow(CompositeNode parentNode);
    private bool ParsePathFast();
    private int ParseCoordinate();
    private void ParseCoordinates(PathNode node);
    private IdentifierNode ParseIdentifier();
    private IdentifierNode ProcessQualifiee(IdentifierNode current);
    private bool ParseParameters(MethodNode node);
    private void SkipWhiteSpace();
    private TextNode ParseParameterValue();
    private TextNode ParseStringConstant();
    private TextNode ParseNumericConstant();
    private TextNode CreateNonEmptyTextNode(int start, int end);
}
public class JetBrains.Util.StackTraceParser.TextNode : StackTraceNode {
    private string myText;
    public string Text { get; }
    public TextNode(TextRange range, string text);
    public string get_Text();
    public virtual void Dump(TextWriter writer);
    public virtual void Accept(StackTraceNodeVisitor visitor);
}
public static class JetBrains.Util.StandardFolderLocationsStatic : object {
    [NotNullAttribute]
public static FileSystemPath LocalAppdata { get; }
    [NotNullAttribute]
public static FileSystemPath RoamingAppdata { get; }
    [NotNullAttribute]
public static FileSystemPath TempFolder { get; }
    [NotNullAttribute]
public static FileSystemPath TransientAppdata { get; }
    [NotNullAttribute]
public static FileSystemPath TransientAppdataShortened { get; }
    public static FileSystemPath get_LocalAppdata();
    public static FileSystemPath get_RoamingAppdata();
    public static FileSystemPath get_TempFolder();
    public static FileSystemPath get_TransientAppdata();
    public static FileSystemPath get_TransientAppdataShortened();
    [NotNullAttribute]
private static RelativePath GetRelativeHostFolder();
}
public class JetBrains.Util.Statistics : object {
    private static Statistics Empty;
    private static IDictionary`2<string, long> EmptyCounters;
    private static IDictionary`2<string, Func`1<object>> EmptyCalculators;
    private static Dictionary`2<string, TimeSpan> EmptyActivities;
    public IDictionary`2<string, long> Counters { get; }
    public IDictionary`2<string, Func`1<object>> Calculators { get; }
    public Dictionary`2<string, TimeSpan> Activities { get; }
    private static Statistics();
    public IDictionary`2<string, long> get_Counters();
    public IDictionary`2<string, Func`1<object>> get_Calculators();
    public Dictionary`2<string, TimeSpan> get_Activities();
    public IDisposable Suspend();
    [ConditionalAttribute("NEVER")]
public void Resume();
    public static Statistics Allocate(string key);
    public static Statistics Allocate(Type type);
    public static IEnumerable`1<StatisticsNode> Enumerate();
    public static bool HasBreakpoint(string key, string name);
    [ConditionalAttribute("NEVER")]
public static void ToggleBreakpoint(string key, string name);
    [ConditionalAttribute("NEVER")]
public void Calculate(string name, Func`1<object> calculator);
    [ConditionalAttribute("NEVER")]
public void CalculateRatio(string name, string numerator, string denominator);
    public StatisticsActivityCookie Activity(string name);
    [StringFormatMethodAttribute("format")]
[ConditionalAttribute("NEVER")]
public void DecrementFormat(string format, Object[] args);
    [ConditionalAttribute("NEVER")]
public void Decrement(string name);
    [ConditionalAttribute("NEVER")]
public void Decrement(string name, long value);
    [ConditionalAttribute("NEVER")]
public void Increment(string name);
    [StringFormatMethodAttribute("format")]
[ConditionalAttribute("NEVER")]
public void IncrementFormat(string format, Object[] args);
    [ConditionalAttribute("NEVER")]
public void Increment(string name, long value);
    [ConditionalAttribute("NEVER")]
public void Clear();
    [ConditionalAttribute("NEVER")]
public static void ClearAll();
    [ConditionalAttribute("NEVER")]
public void Dump(TextWriter writer);
}
public class JetBrains.Util.StatisticsActivity : StatisticsNode {
    private TimeSpan myTimeSpan;
    public TimeSpan Time { get; }
    public StatisticsActivity(string key, string name, TimeSpan stopwatch);
    public TimeSpan get_Time();
}
public class JetBrains.Util.StatisticsCalculator : StatisticsNode {
    private Func`1<object> myCalculator;
    public object Value { get; }
    public StatisticsCalculator(string key, string name, Func`1<object> calculator);
    public object get_Value();
}
public class JetBrains.Util.StatisticsCounter : StatisticsNode {
    private long myCount;
    public long Count { get; }
    public StatisticsCounter(string key, string name, long value);
    public long get_Count();
}
public class JetBrains.Util.StatisticsGroup : object {
    private string myKey;
    public string Key { get; }
    public RichText ShortName { get; }
    public StatisticsGroup(string key);
    public string get_Key();
    public RichText get_ShortName();
    public bool Equals(StatisticsGroup obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public abstract class JetBrains.Util.StatisticsNode : object {
    private string myKey;
    private string myName;
    public string Key { get; }
    public IEnumerable`1<StatisticsGroup> Groups { get; }
    public string Name { get; }
    protected StatisticsNode(string key, string name);
    public string get_Key();
    [IteratorStateMachineAttribute("JetBrains.Util.StatisticsNode/<get_Groups>d__6")]
public IEnumerable`1<StatisticsGroup> get_Groups();
    public string get_Name();
}
[ExtensionAttribute]
public static class JetBrains.Util.Storage.DistributedCacheEx : object {
    [AsyncStateMachineAttribute("JetBrains.Util.Storage.DistributedCacheEx/<DoSingleStreamAsync>d__0")]
[ExtensionAttribute]
[NotNullAttribute]
public static Task`1<ImmutableByteStream> DoSingleStreamAsync(DistributedCache distrocache, IHasher hasher, Func`1<Task`1<ImmutableByteStream>> generator);
    public static string TmpRotateHashes(string hash);
}
public class JetBrains.Util.Storage.FileItemSet : object {
    public ImmutableArray`1<ImmutableFileItem> Files;
    public FileItemSet(ImmutableArray`1<ImmutableFileItem> files);
    public FileItemSet(IStructuredStorage sstg);
    public virtual string ToString();
    private sealed virtual override void JetBrains.Util.Storage.StructuredStorage.IStructuredStorageSerializable.GetObjectData(IStructuredStorage storage);
    private static ImmutableArray`1<ImmutableFileItem> ReadFiles(IStructuredStorage sstg);
}
[ExtensionAttribute]
public static class JetBrains.Util.Storage.IHasherEx : object {
    [ExtensionAttribute]
[NotNullAttribute]
public static IHasher AppendManyBlittable(IHasher hasher, ReadOnlySpan`1<TData> data);
    [ExtensionAttribute]
[NotNullAttribute]
public static IHasher AppendBlittable(IHasher hasher, TData data);
    [ExtensionAttribute]
[NotNullAttribute]
public static IHasher AppendBlob(IHasher hasher, ImmutableArray`1<byte> data);
    [ExtensionAttribute]
[NotNullAttribute]
public static IHasher AppendFileItem(IHasher hasher, ImmutableFileItem fi);
    [ExtensionAttribute]
[NotNullAttribute]
public static IHasher AppendFileItemsSet(IHasher hasher, IEnumerable`1<ImmutableFileItem> fileitems);
    [ExtensionAttribute]
[NotNullAttribute]
public static IHasher AppendFileItemsSet(IHasher hasher, IReadOnlyCollection`1<ImmutableFileItem> fileitems);
}
public interface JetBrains.Util.Storage.IInMemoryStream {
    public abstract virtual IntPtr GetBufferFromPosition(long startPosition, SeekOrigin origin, int needBytes, Int32& availableBytes);
    public abstract virtual IntPtr GetBufferEndAtPosition(long endOffset, SeekOrigin origin, int needBytes, Int32& availableBytes);
}
public class JetBrains.Util.Storage.ImmutableFileItem : object {
    private static ILogger Logger;
    private static string myNameFileContent;
    private static string myNameRelPath;
    [NotNullAttribute]
private ImmutableByteStream myFileContent;
    [NotNullAttribute]
private RelativePath myRelativePath;
    [ObsoleteAttribute("Use FileContent.Digest directly.")]
public Byte[] ContentHash { get; }
    [NotNullAttribute]
public ImmutableByteStream FileContent { get; }
    [NotNullAttribute]
public RelativePath RelativePath { get; }
    public ImmutableFileItem(RelativePath relativePath, ImmutableByteStream fileContent);
    public ImmutableFileItem(RelativePath relativePath, ChunkedMemoryStream fileContent);
    public ImmutableFileItem(ImmutableFileItem sample);
    public ImmutableFileItem(IStructuredStorage sstg);
    private static ImmutableFileItem();
    public Byte[] get_ContentHash();
    public ImmutableByteStream get_FileContent();
    public RelativePath get_RelativePath();
    public static Byte[] ComputeHash(Stream stream);
    [NotNullAttribute]
public static ImmutableFileItem CreateFromDisk(FileSystemPath path);
    [NotNullAttribute]
public static ImmutableFileItem CreateFromStream(RelativePath relativePath, Action`1<Stream> λWriteStream);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ImmutableFileItem other);
    public virtual int GetHashCode();
    public static bool op_Equality(ImmutableFileItem left, ImmutableFileItem right);
    public static bool op_Inequality(ImmutableFileItem left, ImmutableFileItem right);
    public virtual string ToString();
    private sealed virtual override int System.IComparable<JetBrains.Util.Storage.ImmutableFileItem>.CompareTo(ImmutableFileItem other);
    [NotNullAttribute]
private static ImmutableByteStream CtorMakeImmutable(ChunkedMemoryStream fileContent, RelativePath relativePath);
    private sealed virtual override void JetBrains.Util.Storage.StructuredStorage.IStructuredStorageSerializable.GetObjectData(IStructuredStorage sstg);
}
[ExtensionAttribute]
public static class JetBrains.Util.Storage.ImmutableFileItemEx : object {
    private static ILogger Logger;
    private static ImmutableFileItemEx();
    [ExtensionAttribute]
public static bool IsUnixExecutable(ImmutableFileItem fi);
    [ExtensionAttribute]
[NotNullAttribute]
public static FileSystemPath RealizeOnDisk(ImmutableFileItem thіs, Lifetime lifetimeFileAvailability, IWorkingDirectory workdir);
    [ExtensionAttribute]
[NotNullAttribute]
public static ImmutableFileItem WithNoLifetime(ImmutableFileItem fi);
    [ExtensionAttribute]
[NotNullAttribute]
public static ImmutableFileItem WithRelativePath(ImmutableFileItem fi, RelativePath relNew);
    [ExtensionAttribute]
[NotNullAttribute]
public static ImmutableFileItem WithRelativePath(ImmutableFileItem fi, Func`2<RelativePath, RelativePath> λChangePath);
    [ExtensionAttribute]
[ObsoleteAttribute("Use WriteToDirectoryIfDirtyWithMoveAside.")]
public static void WriteIfDirty(ImmutableFileItem fi, FileSystemPath directory, ILogger logger);
    [ExtensionAttribute]
[NotNullAttribute]
public static FileSystemPath WriteToDirectoryIfDirtyWithMoveAside(ImmutableFileItem fi, FileSystemPath directory, ILogger logger, FileCheck check);
}
public interface JetBrains.Util.Storage.MemoryMappedStream.IMemoryMappedFileApi {
    public abstract virtual IMemoryMappedFileHandle CreateFromFile(FileSystemPath path, FileShare fileShare);
    public abstract virtual IMemoryMappedFileHandle CreateNew(string mapName, long capacity, bool isReadOnly);
    public abstract virtual void CloseMemoryMapping(IMemoryMappedFileHandle handle);
    public abstract virtual IntPtr MapViewOfFile(IMemoryMappedFileHandle handle, long offset, UInt32 size, bool isReadOnly);
    public abstract virtual void UnmapViewOfFile(IMemoryMappedFileHandle handle, IntPtr buffer);
}
public interface JetBrains.Util.Storage.MemoryMappedStream.IMemoryMappedFileHandle {
}
public class JetBrains.Util.Storage.MemoryMappedStream.MemoryMappedException : IOException {
    protected MemoryMappedException(SerializationInfo info, StreamingContext context);
    public MemoryMappedException(string moniker);
}
public static class JetBrains.Util.Storage.MemoryMappedStream.MemoryMappedFileApi : object {
    public static IMemoryMappedFileApi Instance;
    private static MemoryMappedFileApi();
}
internal class JetBrains.Util.Storage.MemoryMappedStream.MemoryMappedFileClrApi : object {
    public sealed virtual IMemoryMappedFileHandle CreateFromFile(FileSystemPath path, FileShare fileShare);
    public sealed virtual IMemoryMappedFileHandle CreateNew(string mapName, long capacity, bool isReadOnly);
    public sealed virtual void CloseMemoryMapping(IMemoryMappedFileHandle handle);
    public sealed virtual IntPtr MapViewOfFile(IMemoryMappedFileHandle handle, long offset, UInt32 size, bool isReadOnly);
    public sealed virtual void UnmapViewOfFile(IMemoryMappedFileHandle handle, IntPtr buffer);
}
internal static class JetBrains.Util.Storage.MemoryMappedStream.MemoryMappedFilesManager : object {
    private static object LockObject;
    private static IDictionary`2<FileSystemPath, SafeMemoryMappedHandler> FilePathToMemoryHandleDictionary;
    private static IDictionary`2<SafeMemoryMappedHandler, FileSystemPath> MemoryHandleToFilePathDictionary;
    private static IDictionary`2<SafeMemoryMappedHandler, int> MemoryHandleToRefCountDictionary;
    private static IDictionary`2<SafeMemoryMappedHandler, SafeFileHandle> MemoryHandleToFileHandleDictionary;
    private static MemoryMappedFilesManager();
    public static SafeMemoryMappedHandler GetMemoryMapping(FileSystemPath path, FileShare fileShare);
    public static void ReleaseMemoryMapping(SafeMemoryMappedHandler memoryHandle);
}
internal class JetBrains.Util.Storage.MemoryMappedStream.MemoryMappedFileWin32Api : object {
    public sealed virtual IMemoryMappedFileHandle CreateFromFile(FileSystemPath path, FileShare fileShare);
    public sealed virtual IMemoryMappedFileHandle CreateNew(string mapName, long capacity, bool isReadOnly);
    public sealed virtual void CloseMemoryMapping(IMemoryMappedFileHandle handle);
    public sealed virtual IntPtr MapViewOfFile(IMemoryMappedFileHandle handle, long offset, UInt32 size, bool isReadOnly);
    public sealed virtual void UnmapViewOfFile(IMemoryMappedFileHandle handle, IntPtr buffer);
}
internal static class JetBrains.Util.Storage.MemoryMappedStream.MemoryMappedWinApi : object {
    [ObsoleteAttribute("Use stuff from Kernel32Dll class.")]
internal static SafeMemoryMappedHandler CreateFileMapping(SafeFileHandle handle, IntPtr lpFileMappingAttributes, FileMapProtection flProtect, UInt32 dwMaximumSizeHigh, UInt32 dwMaximumSizeLow, string lpName);
    [ObsoleteAttribute("Use stuff from Kernel32Dll class.")]
internal static SafeMemoryMappedHandler OpenFileMapping(FileMapAccess dwDesiredAccess, bool bInheritHandle, string lpName);
    [ObsoleteAttribute("Use stuff from Kernel32Dll class.")]
internal static IntPtr MapViewOfFile(SafeMemoryMappedHandler hFileMappingObject, FileMapAccess dwDesiredAccess, UInt32 dwFileOffsetHigh, UInt32 dwFileOffsetLow, UIntPtr dwNumberOfBytesToMap);
    [ObsoleteAttribute("Use stuff from Kernel32Dll class.")]
internal static bool UnmapViewOfFile(IntPtr lpBaseAddress);
}
public class JetBrains.Util.Storage.MemoryMappedStream.ReadonlyMemoryMappedStream : Stream {
    private static byte PageBitSize;
    private static int PageSize;
    private static ulong PageMask;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) myDisposed;
    private long myLength;
    private IMemoryMappedFileHandle myHandle;
    private int myBufferSize;
    private long myPosition;
    private long myBufferStartPosition;
    private IntPtr myBuffer;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public ReadonlyMemoryMappedStream(FileSystemPath path, int pagesInBuffer);
    public ReadonlyMemoryMappedStream(FileSystemPath path, FileShare fileShare, int pagesInBuffer);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual int Read(Byte[] buffer, int offset, int count);
    private IntPtr GetBufferFromCurrentPosition(int needBytes, bool reverse, Int32& size);
    private void ChangeBufferRightAlign();
    private void ChangeBuffer();
    public virtual void Flush();
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void SetLength(long value);
    protected virtual void Dispose(bool disposing);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public sealed virtual IntPtr GetBufferFromPosition(long startPosition, SeekOrigin origin, int needBytes, Int32& availableBytes);
    public sealed virtual IntPtr GetBufferEndAtPosition(long endOffset, SeekOrigin origin, int needBytes, Int32& availableBytes);
}
public class JetBrains.Util.Storage.MemoryMappedStream.SafeMemoryMappedHandler : SafeHandleZeroOrMinusOneIsInvalid {
    public SafeMemoryMappedHandler(IntPtr preexistingHandle, bool ownsHandle);
    protected virtual bool ReleaseHandle();
    private static bool CloseHandle(IntPtr hObject);
}
public class JetBrains.Util.Storage.Packages.GetPackageStatus : object {
    public ulong BytesDownloaded;
    public Nullable`1<EPath> Path;
    public bool IsDownloadingFromSource { get; }
    public bool get_IsDownloadingFromSource();
}
public interface JetBrains.Util.Storage.Packages.IHaveJetNugetPackage {
    [NotNullAttribute]
public IJetNugetPackage Package { get; }
    public abstract virtual IJetNugetPackage get_Package();
}
[ExtensionAttribute]
public static class JetBrains.Util.Storage.Packages.IHaveJetNugetPackageEx : object {
    [ExtensionAttribute]
[NotNullAttribute]
public static string GetFullNameWDot(IHaveJetNugetPackage thіs);
    [ExtensionAttribute]
[NotNullAttribute]
public static string GetFullNameWSlash(IHaveJetNugetPackage thіs);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static string GetNupkgFileName(IHaveJetNugetPackage pkg);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static JetPackageIdentity GetPackageIdentity(IHaveJetNugetPackage thіs);
}
public interface JetBrains.Util.Storage.Packages.IJetNugetPackage {
    [NotNullAttribute]
public JetPackageIdentity Identity { get; }
    [NotNullAttribute]
public JetNugetPackageMetadata Manifest { get; }
    public ImmutableArray`1<ImmutableFileItem> PackageParts { get; }
    public abstract virtual JetPackageIdentity get_Identity();
    public abstract virtual JetNugetPackageMetadata get_Manifest();
    public abstract virtual ImmutableArray`1<ImmutableFileItem> get_PackageParts();
    public abstract virtual ImmutableArray`1<ImmutableFileItem> FilterPackageParts(JetNugetFilterFlags flags, JetNugetTargetFramework targetfx);
    [NotNullAttribute]
public abstract virtual NugetPackageFileItem GetNugetPackageFile();
}
[ExtensionAttribute]
public static class JetBrains.Util.Storage.Packages.IJetNugetPackageEx : object {
    [ExtensionAttribute]
[NotNullAttribute]
public static string CalcDigestOnParts(IJetNugetPackage nupkg);
    public static int Compare(IJetNugetPackage x, IJetNugetPackage y);
    public static bool Equals(IJetNugetPackage x, IJetNugetPackage y);
    [ExtensionAttribute]
public static ImmutableArray`1<JetNugetEntry> GetContentEntriesInDefaultTfx(IJetNugetPackage nupkg);
    [ExtensionAttribute]
public static ImmutableArray`1<ImmutableFileItem> GetContentItemsInDefaultTfx(IJetNugetPackage nupkg);
    [ExtensionAttribute]
public static ImmutableArray`1<JetNugetEntry> GetEntries(IJetNugetPackage nupkg, Nullable`1<Lifetime> lifetime, JetNugetFilterFlags flags, JetNugetTargetFramework targetfx);
    [ExtensionAttribute]
[NotNullAttribute]
[ObsoleteAttribute("Use PackageParts.")]
public static IReadOnlyCollection`1<JetNugetEntry> GetEntriesUnfiltered(IJetNugetPackage nupkg);
    [ExtensionAttribute]
[NotNullAttribute]
public static ImmutableFileItem GetFileItemOfEitherFormat(IJetNugetPackage nupkg);
    [ExtensionAttribute]
[NotNullAttribute]
[ObsoleteAttribute("A proxy method which marks usages which plan to be upgraded to the interface use to avoid perf costs.")]
public static NugetPackageFileItem GetNugetPackageFileTodoRemove(IJetNugetPackage nupkg);
    [ExtensionAttribute]
[NotNullAttribute]
public static ImmutableFileItem GetNupkgFileItem(IJetNugetPackage nupkg);
    [ExtensionAttribute]
[NotNullAttribute]
public static ImmutableFileItem GetSomethingToCheckPackagesEqual(IJetNugetPackage nupkg);
    public static NugetPackageFileItem MakeRealPackage(JetNugetPackageMetadata jetNugetPackageMetadata, ImmutableArray`1<ImmutableFileItem> parts);
    [ExtensionAttribute]
[NotNullAttribute]
public static TReturn WithEntries(IJetNugetPackage nupkg, JetNugetFilterFlags flags, JetNugetTargetFramework targetfx, Func`2<ImmutableArray`1<JetNugetEntry>, TReturn> λ);
    [ExtensionAttribute]
[NotNullAttribute]
public static TReturn WithEntriesUnfiltered(IJetNugetPackage nupkg, Func`2<ImmutableArray`1<JetNugetEntry>, TReturn> λ);
}
public interface JetBrains.Util.Storage.Packages.IJetNugetPackageManager {
    [CanBeNullAttribute]
public ImmutableFileItem NugetConfigFile { get; }
    public abstract virtual ImmutableFileItem get_NugetConfigFile();
    [NotNullAttribute]
public abstract virtual Task`1<IJetNugetPackage> GetPackageAsync(OuterLifetime lifetime, JetPackageIdentity package, OnError onerror, IProperty`1<GetPackageStatus> status);
}
[IsReadOnlyAttribute]
public class JetBrains.Util.Storage.Packages.JetNugetEntry : ValueType {
    private ImmutableFileItem myPart;
    public NugetPartPaths Paths;
    public Nullable`1<long> CompressedLength { get; }
    public bool IsNull { get; }
    public long UncompressedLength { get; }
    public JetNugetEntry(ImmutableFileItem part);
    public Nullable`1<long> get_CompressedLength();
    public bool get_IsNull();
    public long get_UncompressedLength();
    [NotNullAttribute]
[PureAttribute]
public ImmutableFileItem CreateEffectivePathFileItem();
    [NotNullAttribute]
[PureAttribute]
public ImmutableFileItem CreatePartPathFileItem();
    [NotNullAttribute]
public Stream OpenSequentialStream(Lifetime lifetime);
    public TValue ReadRandomAccessStream(Func`2<Stream, TValue> FWithStream);
    public TValue ReadSequentialStream(Func`2<Stream, TValue> FWithStream);
    public virtual string ToString();
}
[FlagsAttribute]
public enum JetBrains.Util.Storage.Packages.JetNugetFilterFlags : Enum {
    public int value__;
    public static JetNugetFilterFlags JetContentItemsOnly;
    [ObsoleteAttribute("We now do not skip these files by default and return them, otherwise the folders disappear and this affects TFX preference. The content-items extraction (JetContentItemsOnly) skips them on content filtering phase; in raw modes, you should do this yourself.")]
public static JetNugetFilterFlags DoNotSkipEmptyFolderFileMarker;
    public static JetNugetFilterFlags ContentPreferReferencesFolder;
    public static JetNugetFilterFlags ContentPreferRuntimesFolder;
    public static JetNugetFilterFlags ContentIncludeRuntimesFolder;
}
public class JetBrains.Util.Storage.Packages.JetNugetPackageMetadata : object {
    [NotNullAttribute]
public JetPackageIdentity Identity;
    [NotNullAttribute]
public IPackageMetadata Metadata;
    public JetNugetPackageMetadata(IStructuredStorage sstg);
    public JetNugetPackageMetadata(IPackageMetadata metadata);
    private sealed virtual override void JetBrains.Util.Storage.StructuredStorage.IStructuredStorageSerializable.GetObjectData(IStructuredStorage storage);
    [CompilerGeneratedAttribute]
private void <JetBrains.Util.Storage.StructuredStorage.IStructuredStorageSerializable.GetObjectData>b__4_0(Stream stream);
}
public static class JetBrains.Util.Storage.Packages.JetNugetPackages : object {
    [NotNullAttribute]
public static IJetNugetPackage FromFileItemOfEitherFormat(ImmutableFileItem file);
    [NotNullAttribute]
public static IJetNugetPackage FromNupkgFileItem(ImmutableFileItem file);
    [NotNullAttribute]
public static IJetNugetPackage FromPackageBuilder(PackageBuilder nubuilder);
}
public class JetBrains.Util.Storage.Packages.JetNuGetSettingsV2 : object {
    private XDocument _config;
    private IFileSystem _fileSystem;
    private string _fileName;
    private JetNuGetSettingsV2 _next;
    private int _priority;
    private bool _isMachineWideSettings;
    public bool IsMachineWideSettings { get; }
    public string ConfigFilePath { get; }
    private JetNuGetSettingsV2(IFileSystem fileSystem);
    public JetNuGetSettingsV2(IFileSystem fileSystem, string fileName, bool isMachineWideSettings);
    public static NuGetSettingWrapper Create(FileSystemPath rootDir);
    private static XDocument GetOrCreateDocument(XName rootName, IFileSystem fileSystem, string path);
    private static XDocument CreateDocument(XName rootName, IFileSystem fileSystem, string path);
    private static XDocument GetDocument(IFileSystem fileSystem, string path);
    public bool get_IsMachineWideSettings();
    public string get_ConfigFilePath();
    public static NuGetSettingWrapper LoadDefaultSettings(IFileSystem fileSystem, string configFileName);
    public static NuGetSettingWrapper LoadDefaultSettings(FileSystemPath rootDir, string configFileName);
    private static void LoadUserSpecificSettings(List`1<JetNuGetSettingsV2> validSettingFiles, IFileSystem fileSystem, string configFileName);
    public sealed virtual string GetValue(string section, string key, bool isPath);
    private string ApplyEnvironmentTransform(string configValue);
    private static string ResolvePath(string configDirectory, string value);
    private string ElementToValue(XElement element, bool isPath);
    private XElement GetValueInternal(string section, string key, XElement curr);
    public sealed virtual IList`1<SettingValue> GetValues(string section, bool isPath);
    private void PopulateValues(string section, List`1<SettingValue> current, bool isPath);
    public sealed virtual IList`1<SettingValue> GetNestedValues(string section, string subsection);
    private void PopulateNestedValues(string section, string subsection, List`1<SettingValue> current);
    public sealed virtual void SetValue(string section, string key, string value);
    public sealed virtual void SetValues(string section, IList`1<SettingValue> values);
    public sealed virtual void UpdateSections(string section, IList`1<SettingValue> values);
    private static void SetElementValues(XElement element, string key, string value, IDictionary`2<string, string> attributes);
    public sealed virtual void SetNestedValues(string section, string key, IList`1<KeyValuePair`2<string, string>> values);
    private void SetValueInternal(XElement sectionElement, string key, string value, IDictionary`2<string, string> attributes);
    public sealed virtual bool DeleteValue(string section, string key);
    public sealed virtual bool DeleteSection(string section);
    private void ReadSection(XContainer sectionElement, ICollection`1<SettingValue> values, bool isPath);
    private void Save();
    private SettingValue ReadSettingsValue(XElement element, bool isPath);
    private static XElement GetSection(XElement parentElement, string section);
    private static XElement GetOrCreateSection(XElement parentElement, string sectionName);
    private static XElement FindElementByKey(XElement sectionElement, string key, XElement curr);
    [IteratorStateMachineAttribute("JetBrains.Util.Storage.Packages.JetNuGetSettingsV2/<GetSettingsFileNames>d__42")]
private static IEnumerable`1<string> GetSettingsFileNames(IFileSystem fileSystem);
    [IteratorStateMachineAttribute("JetBrains.Util.Storage.Packages.JetNuGetSettingsV2/<GetSettingsFilePaths>d__43")]
private static IEnumerable`1<string> GetSettingsFilePaths(IFileSystem fileSystem);
    private static JetNuGetSettingsV2 ReadSettings(IFileSystem fileSystem, string settingsPath);
    private static JetNuGetSettingsV2 ReadSettings(IFileSystem fileSystem, string settingsPath, bool isMachineWideSettings);
    private void ExecuteSynchronized(Action ioOperation);
    [CompilerGeneratedAttribute]
private bool <UpdateSections>b__30_0(SettingValue v);
    [CompilerGeneratedAttribute]
private bool <UpdateSections>b__30_1(SettingValue v);
    [CompilerGeneratedAttribute]
private void <Save>b__37_0();
}
public static class JetBrains.Util.Storage.Packages.JetNuGetSettingsV4 : object {
    private static object ourLoadingSync;
    private static JetNuGetSettingsV4();
    [PublicAPIAttribute]
public static ISettings LoadDefaultSettings(string root, string configFileName, IMachineWideSettings machineWideSettings);
    [PublicAPIAttribute]
public static ISettings LoadDefaultSettings(string root);
    [PublicAPIAttribute]
public static ISettings LoadDefaultSettings(FileSystemPath root);
    [PublicAPIAttribute]
public static ISettings LoadDefaultSettings();
}
[IsReadOnlyAttribute]
public class JetBrains.Util.Storage.Packages.JetNugetTargetFramework : ValueType {
    public static JetNugetTargetFramework DontFilter;
    public static JetNugetTargetFramework ToolsetDefault;
    private bool myIsDontFilter;
    [CanBeNullAttribute]
private FrameworkName myTargetfx;
    public static JetNugetTargetFramework CurrentNetCore { get; }
    public bool IsFiltering { get; }
    private JetNugetTargetFramework(bool isDontFilter, FrameworkName targetfx);
    private static JetNugetTargetFramework();
    public static JetNugetTargetFramework get_CurrentNetCore();
    public bool get_IsFiltering();
    public static JetNugetTargetFramework Custom(FrameworkName targetfx);
    [NotNullAttribute]
[PureAttribute]
public FrameworkName GetTargetFrameworkName();
    public virtual string ToString();
}
public class JetBrains.Util.Storage.Packages.JetPackageBuilder : object {
    private static DateTime Timestamp;
    private static Uri DefaultUri;
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetVersion <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private RepositoryMetadata <Repository>k__BackingField;
    [CompilerGeneratedAttribute]
private LicenseMetadata <LicenseMetadata>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasSnapshotVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <IconUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Icon>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <LicenseUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <ProjectUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RequireLicenseAcceptance>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Serviceable>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DevelopmentDependency>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Summary>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ReleaseNotes>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Language>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Copyright>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <MinClientVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<string> <Authors>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<string> <Owners>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<string> <Tags>k__BackingField;
    [CompilerGeneratedAttribute]
private Collection`1<PackageDependencyGroup> <DependencyGroups>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<IPackageFile> <Files>k__BackingField;
    [CompilerGeneratedAttribute]
private Collection`1<FrameworkAssemblyReference> <FrameworkReferences>k__BackingField;
    [CompilerGeneratedAttribute]
private Collection`1<FrameworkReferenceGroup> <FrameworkReferenceGroups>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<ManifestContentFiles> <ContentFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<PackageReferenceSet> <PackageAssemblyReferences>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<PackageType> <PackageTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Readme>k__BackingField;
    public string Id { get; public set; }
    public NuGetVersion Version { get; public set; }
    public RepositoryMetadata Repository { get; public set; }
    public LicenseMetadata LicenseMetadata { get; public set; }
    public bool HasSnapshotVersion { get; public set; }
    public string Title { get; public set; }
    public Uri IconUrl { get; public set; }
    public string Icon { get; public set; }
    public Uri LicenseUrl { get; public set; }
    public Uri ProjectUrl { get; public set; }
    public bool RequireLicenseAcceptance { get; public set; }
    public bool Serviceable { get; public set; }
    public bool DevelopmentDependency { get; public set; }
    public string Description { get; public set; }
    public string Summary { get; public set; }
    public string ReleaseNotes { get; public set; }
    public string Language { get; public set; }
    public string Copyright { get; public set; }
    public Version MinClientVersion { get; public set; }
    public ISet`1<string> Authors { get; }
    public ISet`1<string> Owners { get; }
    public ISet`1<string> Tags { get; }
    public Collection`1<PackageDependencyGroup> DependencyGroups { get; }
    public ICollection`1<IPackageFile> Files { get; }
    public Collection`1<FrameworkAssemblyReference> FrameworkReferences { get; }
    public Collection`1<FrameworkReferenceGroup> FrameworkReferenceGroups { get; }
    public ICollection`1<ManifestContentFiles> ContentFiles { get; private set; }
    public ICollection`1<PackageReferenceSet> PackageAssemblyReferences { get; public set; }
    public ICollection`1<PackageType> PackageTypes { get; public set; }
    private IEnumerable`1<string> NuGet.Packaging.IPackageMetadata.Authors { get; }
    private IEnumerable`1<string> NuGet.Packaging.IPackageMetadata.Owners { get; }
    private string NuGet.Packaging.IPackageMetadata.Tags { get; }
    private IEnumerable`1<PackageReferenceSet> NuGet.Packaging.IPackageMetadata.PackageAssemblyReferences { get; }
    private IEnumerable`1<PackageDependencyGroup> NuGet.Packaging.IPackageMetadata.DependencyGroups { get; }
    private IEnumerable`1<FrameworkAssemblyReference> NuGet.Packaging.IPackageMetadata.FrameworkReferences { get; }
    private IEnumerable`1<ManifestContentFiles> NuGet.Packaging.IPackageMetadata.ContentFiles { get; }
    private IEnumerable`1<PackageType> NuGet.Packaging.IPackageMetadata.PackageTypes { get; }
    private IEnumerable`1<FrameworkReferenceGroup> NuGet.Packaging.IPackageMetadata.FrameworkReferenceGroups { get; }
    public string Readme { get; public set; }
    private static JetPackageBuilder();
    private void ValidateFiles();
    public IJetNugetPackage Build();
    public void Save(Stream stream);
    public ImmutableFileItem Save();
    public static JetPackageBuilder Load(Stream stream);
    public static JetPackageBuilder Load(ImmutableFileItem file);
    public static JetPackageBuilder FromNuget(IJetNugetPackage nuget);
    private void Populate(IPackageMetadata packageMetadata);
    private static IEnumerable`1<string> ParseTags(string tags);
    private static string GetStringForPartUri(string escapedPath);
    private static string CreatePartEntryName(string path);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
    [CompilerGeneratedAttribute]
public sealed virtual NuGetVersion get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(NuGetVersion value);
    [CompilerGeneratedAttribute]
public sealed virtual RepositoryMetadata get_Repository();
    [CompilerGeneratedAttribute]
public void set_Repository(RepositoryMetadata value);
    [CompilerGeneratedAttribute]
public sealed virtual LicenseMetadata get_LicenseMetadata();
    [CompilerGeneratedAttribute]
public void set_LicenseMetadata(LicenseMetadata value);
    [CompilerGeneratedAttribute]
public bool get_HasSnapshotVersion();
    [CompilerGeneratedAttribute]
public void set_HasSnapshotVersion(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Title();
    [CompilerGeneratedAttribute]
public void set_Title(string value);
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_IconUrl();
    [CompilerGeneratedAttribute]
public void set_IconUrl(Uri value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Icon();
    [CompilerGeneratedAttribute]
public void set_Icon(string value);
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_LicenseUrl();
    [CompilerGeneratedAttribute]
public void set_LicenseUrl(Uri value);
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_ProjectUrl();
    [CompilerGeneratedAttribute]
public void set_ProjectUrl(Uri value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_RequireLicenseAcceptance();
    [CompilerGeneratedAttribute]
public void set_RequireLicenseAcceptance(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_Serviceable();
    [CompilerGeneratedAttribute]
public void set_Serviceable(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_DevelopmentDependency();
    [CompilerGeneratedAttribute]
public void set_DevelopmentDependency(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Description();
    [CompilerGeneratedAttribute]
public void set_Description(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Summary();
    [CompilerGeneratedAttribute]
public void set_Summary(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ReleaseNotes();
    [CompilerGeneratedAttribute]
public void set_ReleaseNotes(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Language();
    [CompilerGeneratedAttribute]
public void set_Language(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Copyright();
    [CompilerGeneratedAttribute]
public void set_Copyright(string value);
    [CompilerGeneratedAttribute]
public sealed virtual Version get_MinClientVersion();
    [CompilerGeneratedAttribute]
public void set_MinClientVersion(Version value);
    [CompilerGeneratedAttribute]
public ISet`1<string> get_Authors();
    [CompilerGeneratedAttribute]
public ISet`1<string> get_Owners();
    [CompilerGeneratedAttribute]
public ISet`1<string> get_Tags();
    [CompilerGeneratedAttribute]
public Collection`1<PackageDependencyGroup> get_DependencyGroups();
    [CompilerGeneratedAttribute]
public ICollection`1<IPackageFile> get_Files();
    [CompilerGeneratedAttribute]
public Collection`1<FrameworkAssemblyReference> get_FrameworkReferences();
    [CompilerGeneratedAttribute]
public Collection`1<FrameworkReferenceGroup> get_FrameworkReferenceGroups();
    [CompilerGeneratedAttribute]
public ICollection`1<ManifestContentFiles> get_ContentFiles();
    [CompilerGeneratedAttribute]
private void set_ContentFiles(ICollection`1<ManifestContentFiles> value);
    [CompilerGeneratedAttribute]
public ICollection`1<PackageReferenceSet> get_PackageAssemblyReferences();
    [CompilerGeneratedAttribute]
public void set_PackageAssemblyReferences(ICollection`1<PackageReferenceSet> value);
    [CompilerGeneratedAttribute]
public ICollection`1<PackageType> get_PackageTypes();
    [CompilerGeneratedAttribute]
public void set_PackageTypes(ICollection`1<PackageType> value);
    private sealed virtual override IEnumerable`1<string> NuGet.Packaging.IPackageMetadata.get_Authors();
    private sealed virtual override IEnumerable`1<string> NuGet.Packaging.IPackageMetadata.get_Owners();
    private sealed virtual override string NuGet.Packaging.IPackageMetadata.get_Tags();
    private sealed virtual override IEnumerable`1<PackageReferenceSet> NuGet.Packaging.IPackageMetadata.get_PackageAssemblyReferences();
    private sealed virtual override IEnumerable`1<PackageDependencyGroup> NuGet.Packaging.IPackageMetadata.get_DependencyGroups();
    private sealed virtual override IEnumerable`1<FrameworkAssemblyReference> NuGet.Packaging.IPackageMetadata.get_FrameworkReferences();
    private sealed virtual override IEnumerable`1<ManifestContentFiles> NuGet.Packaging.IPackageMetadata.get_ContentFiles();
    private sealed virtual override IEnumerable`1<PackageType> NuGet.Packaging.IPackageMetadata.get_PackageTypes();
    private sealed virtual override IEnumerable`1<FrameworkReferenceGroup> NuGet.Packaging.IPackageMetadata.get_FrameworkReferenceGroups();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Readme();
    [CompilerGeneratedAttribute]
public void set_Readme(string value);
}
[ValueSerializerAttribute("JetBrains.Util.Storage.Packages.JetPackageIdentity/PackageIdentitySerializer")]
[TypeConverterAttribute("JetBrains.Util.Storage.Packages.JetPackageIdentity/PackageIdentityConverter")]
public class JetBrains.Util.Storage.Packages.JetPackageIdentity : object {
    public static Regex RegexPackageNameAndSemanticVersion;
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private JetSemanticVersion <Version>k__BackingField;
    [NotNullAttribute]
public string Id { get; }
    [NotNullAttribute]
public JetSemanticVersion Version { get; }
    public JetPackageIdentity(string id, JetSemanticVersion version);
    private static JetPackageIdentity();
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public JetSemanticVersion get_Version();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(JetPackageIdentity other);
    public virtual int GetHashCode();
    public static bool op_Equality(JetPackageIdentity left, JetPackageIdentity right);
    public static bool op_Inequality(JetPackageIdentity left, JetPackageIdentity right);
    [NotNullAttribute]
public static JetPackageIdentity Parse(string text);
    [NotNullAttribute]
public string ToDotString();
    [NotNullAttribute]
public string ToSlashString();
    public virtual string ToString();
    [CanBeNullAttribute]
public static JetPackageIdentity TryParse(string text);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    private sealed virtual override int System.IComparable<JetBrains.Util.Storage.Packages.JetPackageIdentity>.CompareTo(JetPackageIdentity other);
}
[ExtensionAttribute]
public static class JetBrains.Util.Storage.Packages.JetPackageIdentityExtensions : object {
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static string GetNupkgFileName(JetPackageIdentity name);
    [ExtensionAttribute]
[ContractAnnotationAttribute("thіs:null => null; notnull => notnull")]
public static PackageIdentity ToNu4Identity(JetPackageIdentity thіs);
    [ExtensionAttribute]
[ContractAnnotationAttribute("thіs:null => null; notnull => notnull")]
public static PackageIdentity ToNu4LegacyIdentity(JetPackageIdentity thіs);
    [ExtensionAttribute]
public static string ToV2PackageNameFileName(JetPackageIdentity identity);
    [ExtensionAttribute]
public static string ToV2PackageNameFullName(JetPackageIdentity identity);
    [ExtensionAttribute]
[NotNullAttribute]
public static RelativePath GetExpandedPackageDirectoryName(JetPackageIdentity pkgname);
}
public class JetBrains.Util.Storage.Packages.JetPackageRepositoryFactory : PackageRepositoryFactory {
    public static IPackageRepositoryFactory Default;
    private static JetPackageRepositoryFactory();
    public virtual IPackageRepository CreateRepository(string packageSource);
}
public class JetBrains.Util.Storage.Packages.JetPathFileSystem : object {
    private ILogger _logger;
    private FileSystemPath _root;
    public string Root { get; }
    public ILogger Logger { get; public set; }
    public JetPathFileSystem(FileSystemPath root);
    public sealed virtual string get_Root();
    public sealed virtual ILogger get_Logger();
    public sealed virtual void set_Logger(ILogger value);
    private sealed virtual override string NuGet.IFileSystem.GetFullPath(string path);
    public virtual FileSystemPath GetFullPath(string path);
    public virtual void AddFile(string path, Stream stream);
    public virtual void AddFile(string path, Action`1<Stream> writeToStream);
    public virtual void AddFiles(IEnumerable`1<IPackageFile> files, string rootDir);
    private void AddFileCore(string path, Action`1<Stream> writeToStream);
    private void WriteAddedFileAndDirectory(FileSystemPath path);
    public virtual void DeleteFile(string path);
    [IteratorStateMachineAttribute("JetBrains.Util.Storage.Packages.JetPathFileSystem/<GetParentComponents>d__16")]
private static IEnumerable`1<RelativePath> GetParentComponents(RelativePath path);
    private static void DoSafeAction(Action action, ILogger logger);
    private static void Attempt(Action action, int retries, int delayBeforeRetry);
    private static IEnumerable`1<string> GetDirectoriesSafe(IFileSystem fileSystem, string path);
    private static IEnumerable`1<string> GetFilesSafe(IFileSystem fileSystem, string path, string filter);
    private static void DeleteDirectorySafe(IFileSystem fileSystem, string path, bool recursive);
    private static void DeleteFileSafe(IFileSystem fileSystem, string path);
    private static void DeleteFiles(IFileSystem fileSystem, IEnumerable`1<IPackageFile> files, FileSystemPath rootDir);
    public virtual void DeleteFiles(IEnumerable`1<IPackageFile> files, string rootDir);
    public virtual void DeleteDirectory(string path);
    public virtual void DeleteDirectory(string path, bool recursive);
    public virtual IEnumerable`1<string> GetFiles(string path, bool recursive);
    public virtual IEnumerable`1<string> GetFiles(string path, string filter, bool recursive);
    public virtual IEnumerable`1<string> GetFiles(FileSystemPath path, string filter, bool recursive);
    public virtual IEnumerable`1<string> GetDirectories(string path);
    public virtual IEnumerable`1<string> GetDirectories(FileSystemPath path);
    public virtual DateTimeOffset GetLastModified(string path);
    public sealed virtual DateTimeOffset GetCreated(string path);
    public sealed virtual DateTimeOffset GetLastAccessed(string path);
    public virtual bool FileExists(string path);
    public virtual bool DirectoryExists(string path);
    public virtual Stream OpenFile(string path);
    public virtual Stream CreateFile(string path);
    protected RelativePath MakeRelativePath(FileSystemPath fullPath);
    protected virtual void EnsureDirectory(FileSystemPath filePath);
    public sealed virtual void MakeFileWritable(string path);
    public virtual void MoveFile(string source, string destination);
    [CompilerGeneratedAttribute]
private string <GetFiles>b__29_0(DirectoryEntryData _);
    [CompilerGeneratedAttribute]
private string <GetDirectories>b__31_0(FileSystemPath _);
}
public class JetBrains.Util.Storage.Packages.LegacyNuGetVersion : NuGetVersion {
    [CompilerGeneratedAttribute]
private bool <IsLegacyVersion>k__BackingField;
    public bool IsLegacyVersion { get; }
    private LegacyNuGetVersion(NuGetVersion version);
    [CompilerGeneratedAttribute]
public virtual bool get_IsLegacyVersion();
    private bool CalcIsLegacyVersion();
    public static LegacyNuGetVersion ParseLegacy(string version);
    public static LegacyNuGetVersion ParseLegacy(JetSemanticVersion version);
    public static LegacyNuGetVersion ParseLegacy(NuGetVersion version);
    public static VersionRange ToBackwardCompatibleVersionRange(string version);
    public virtual string ToString();
    public virtual string ToNormalizedString();
    public virtual string ToFullString();
}
public class JetBrains.Util.Storage.Packages.LocalPackagesMeta : object {
    public static UInt32 CurrentVersionIndex;
    public static string PackagesMetadataFileName;
    public static string SinglePackageMetadataFileName;
    public IDictionary`2<PkgIdString, PackageRecord> Records;
    private LocalPackagesMeta(IDictionary`2<PkgIdString, PackageRecord> records);
    private static LocalPackagesMeta();
    public static LocalPackagesMeta Load(Stream stream);
    [NotNullAttribute]
public static LocalPackagesMeta OpenInFolder(Lifetime lifetime, FileSystemPath dirPackages);
    public void Save(Stream stream);
}
public class JetBrains.Util.Storage.Packages.LocalRestoreNugetPackagesCentralCache : object {
    private static string CacheDirName;
    public static FileSystemPath DefaultCacheDir;
    private static string EnvironmentVariableNameForForceNuGetDownload;
    private static TimeSpan ExpirationAgeLimit;
    [CanBeNullAttribute]
public FileSystemPath CacheDirectory;
    public bool ForceNuGetDownload;
    private LocalRestoreNugetPackagesCentralCache(FileSystemPath cacheDirectory);
    private static LocalRestoreNugetPackagesCentralCache();
    [AsyncStateMachineAttribute("JetBrains.Util.Storage.Packages.LocalRestoreNugetPackagesCentralCache/<CleanupExpiredFolders>d__7")]
public static Task CleanupExpiredFolders(OuterLifetime lifeParent, FileSystemPath dirToCleanup, ITaskHost myTasker, ILogger logger);
    [NotNullAttribute]
public static LocalRestoreNugetPackagesCentralCache Create(FileSystemPath cacheDirectory);
    [NotNullAttribute]
public static LocalRestoreNugetPackagesCentralCache CreateIfSoftLinksSupported(FileSystemPath pathCache);
    [NotNullAttribute]
public static LocalRestoreNugetPackagesCentralCache CreateInLocalAppDataIfSoftLinksSupported();
    public virtual string ToString();
}
public class JetBrains.Util.Storage.Packages.LocalRestoreNugetPackagesSession : object {
    public static string EnvironmentVariableNameForNoNugetValidation;
    public static double OptionNugetExpandedFilesCompressionRatioThreshold;
    public static RelativePath PackagesBacklogFolder;
    private FileSystemPath myBacklogPackagesDir;
    private FileSystemPath myCentralCacheDirectory;
    private ConcurrentDictionary`2<string, RestoredPackage> myFolderLocalNames;
    private ILogger myLogger;
    private Lifetime mySessionLifetime;
    private TaskSemaphore mySubstantialDiskWriteSemaphore;
    [NotNullAttribute]
private ITaskHost myTasker;
    public static int IsEnvironmentVariableForNoNugetValidation;
    [NotNullAttribute]
public FileSystemPath PackagesDir;
    public BacklogBehavior UnusedPackages;
    public LocalRestoreNugetPackagesSession(Lifetime lifetime, FileSystemPath dirPackages, ITaskHost tasker, LocalRestoreNugetPackagesCentralCache centralcache);
    private static LocalRestoreNugetPackagesSession();
    public Task BacklogDirectoryCleanupAsync();
    public void BacklogUnusedPackages();
    [ObsoleteAttribute("Use LocalRestoreAsync.")]
public RestoredPackage LocalRestore(IJetNugetPackage package, OnError onerror);
    [AsyncStateMachineAttribute("JetBrains.Util.Storage.Packages.LocalRestoreNugetPackagesSession/<LocalRestoreAsync>d__17")]
public Task`1<RestoredPackage> LocalRestoreAsync(IJetNugetPackage nupkg, OnError onerror, PerPackageCustomization custom);
    private static void ChooseExpandDirectoryCompression(IJetNugetPackage nupkg, FileSystemPath dirExpand, ILogger logger);
    [AsyncStateMachineAttribute("JetBrains.Util.Storage.Packages.LocalRestoreNugetPackagesSession/<EnsureValidExpandedAsync>d__19")]
private static Task`1<ValidatedAndExpanded> EnsureValidExpandedAsync(Lifetime lifeSinglePackageExpand, IJetNugetPackage nupkg, FileSystemPath dirExpand, Boxed`1<PackageRecord> metabox, bool isWritable, FileSystemPath dirExpandedBacklog, ITaskHost taskHost, TaskSemaphore substantialDiskWriteSemaphore, OnError onerror, ILogger logger);
    private void EnumUnusedPackageLikeFolders(UInt32& nUnuseds, UInt32& nTotalPackageLikeFolders, Action`1<FileSystemPath> FWithUnusedDir);
    private static void FixExpandedFileMode(FileSystemPath file, ILogger logger);
    private static bool IsNoNugetValidation(ILogger logger);
    private static bool IsPackageFilesWorthCompressing(IJetNugetPackage pkg, ILogger logger);
    private void MoveUnusedPackageDirsToBacklog();
    [NotNullAttribute]
private RestoredPackage RegisterExpandedPackage(IJetNugetPackage nupkg, FileSystemPath dirExpandedLocal, ValidatedAndExpanded validatedAndExpanded);
    private bool TryFindAlreadyRestoredByFolderName(IJetNugetPackage nupkg, string sExpandedDirName, RestoredPackage& already);
    [CanBeNullAttribute]
private static PackageRecord TryGetMetadataRecordForPackage(JetPackageIdentity pkgid, FileSystemPath dirExpanded, LocalPackagesMeta meta);
    [CompilerGeneratedAttribute]
private void <.ctor>b__10_0();
    [CompilerGeneratedAttribute]
private void <.ctor>b__10_1();
    [CompilerGeneratedAttribute]
private void <MoveUnusedPackageDirsToBacklog>b__24_0(FileSystemPath dir);
}
[ExtensionAttribute]
public static class JetBrains.Util.Storage.Packages.NugetHelpers : object {
    public static ILogger Logger;
    public static TaskSemaphore NugetBulkOperationWithProgressSemaphore;
    public static Lazy`1<NuGetLogger> NugetLogger;
    public static string ProgramDatabasePackageIdAppendix;
    public static TimeSpan TimeoutFirstProgressReport;
    public static TimeSpan TimeoutPeriodicProgressReport;
    private static NugetHelpers();
    [ExtensionAttribute]
[NotNullAttribute]
public static Uri CreateOpcPartUri(RelativePath path);
    [ExtensionAttribute]
[NotNullAttribute]
public static PriorityPackageRepository CreateSourceRepository(NuGetSettingWrapper settings);
    [ExtensionAttribute]
[NotNullAttribute]
public static AggregateRepository CreateSourceRepositoryNoMachineCache(NuGetSettingWrapper settings);
    [CanBeNullAttribute]
public static JetPackageIdentity ExactIdentityForVersionRange(string id, VersionRange versionRange, JetSemanticVersion jetSemanticVersion, OnError onerror);
    public static FrugalLocalList`1<PackageDependencyGroup> FilterDependencyGroup(IEnumerable`1<PackageDependencyGroup> depsetsAll);
    [NotNullAttribute]
public static TPackage FindPackage(IEnumerable`1<TPackage> packages, string idPackage);
    [NotNullAttribute]
public static List`1<TPackage> FindPackageAndItsReferences(IEnumerable`1<TPackage> packages, string idPackage, OnError onError);
    [NotNullAttribute]
public static List`1<TPackage> FindPackages(IEnumerable`1<TPackage> packages, IEnumerable`1<string> idsPackage);
    [NotNullAttribute]
public static List`1<TPackage> FindPackagesAndTheirReferences(IEnumerable`1<TPackage> packages, IEnumerable`1<string> idsPackage, OnError onError);
    [NotNullAttribute]
public static List`1<TPackage> FindPackagesCore(IEnumerable`1<TPackage> packages, IEnumerable`1<string> idsPackage, bool isTraversingReferences, Predicate`1<string> λDependecyPredicate, OnError onError, Func`3<IHaveJetNugetPackage, IEnumerable`1<PackageDependency>, IEnumerable`1<PackageDependency>> filterDependencies);
    [NotNullAttribute]
public static List`1<TPackage> FindPackagesWithNativeImages(IReadOnlyCollection`1<TPackage> packagesWithBinaries, IEnumerable`1<TPackage> allpackages, ValueTuple`2<JetClrImplementation, JetRuntimeId> runtime);
    [NotNullAttribute]
public static List`1<TPackage> FindPackagesWithSymbols(IReadOnlyCollection`1<TPackage> packagesWithBinaries, IEnumerable`1<TPackage> allpackages);
    [NotNullAttribute]
public static string FormatNativeImageCompanionPackageId(JetPackageIdentity pkgid, ValueTuple`2<JetClrImplementation, JetRuntimeId> runtime);
    [NotNullAttribute]
public static string FormatNugetIdSuffixForClrRuntime(JetRuntimeId runtimeId, Nullable`1<JetClrImplementation> clrImplementation);
    [ExtensionAttribute]
[NotNullAttribute]
public static RelativePath GetJetOrNugetEffectivePath(IPackageFile thіs);
    public static NuGetSettingWrapper GetNugetSettingsFromDirectory(FileSystemPath dir);
    [NotNullAttribute]
[PureAttribute]
[ObsoleteAttribute("Nuget v2 API")]
public static string GetNupkgFileName(IPackageName name);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static string GetNupkgFileNameForMetadata(IPackageMetadata name);
    [AsyncStateMachineAttribute("JetBrains.Util.Storage.Packages.NugetHelpers/<GetPackagesWithProgressAsync>d__24")]
public static Task`1<IJetNugetPackage[]> GetPackagesWithProgressAsync(OuterLifetime lifetime, IEnumerable`1<GetPackageRequest> requests, string sTaskDisplayName, IJetNugetPackageManager packman, ITaskHost tasker, ILogger loggerOuter);
    [AsyncStateMachineAttribute("JetBrains.Util.Storage.Packages.NugetHelpers/<LocalRestorePackagesWithProgressAsync>d__25")]
[ItemNotNullAttribute]
public static Task`1<RestoredPackage[]> LocalRestorePackagesWithProgressAsync(Lifetime lifetime, LocalRestoreNugetPackagesSession session, IEnumerable`1<IJetNugetPackage> packages, string sTaskDisplayName, ITaskHost tasker, OnError onerror, Func`2<IJetNugetPackage, PerPackageCustomization> perPackageCustomization);
    [AsyncStateMachineAttribute("JetBrains.Util.Storage.Packages.NugetHelpers/<LocalRestorePackagesWithProgressAsync>d__26")]
public static Task`1<RestoredPackage> LocalRestorePackagesWithProgressAsync(OuterLifetime lifetime, IJetNugetPackage packageIfSingle, FileSystemPath dirForRestore, BacklogBehavior onUnusedPackages, string sTaskDisplayName, ITaskHost tasker, OnError onerror, string subfolderForPackage);
    [AsyncStateMachineAttribute("JetBrains.Util.Storage.Packages.NugetHelpers/<LocalRestorePackagesWithProgressAsync>d__27")]
public static Task`1<RestoredPackage[]> LocalRestorePackagesWithProgressAsync(OuterLifetime lifetime, IEnumerable`1<IJetNugetPackage> packages, FileSystemPath dirForRestore, BacklogBehavior onUnusedPackages, string sTaskDisplayName, ITaskHost tasker, OnError onerror, Func`2<IJetNugetPackage, PerPackageCustomization> perPackageCustomization);
    [ObsoleteAttribute("The old Nuget2-based retrieval routine. Modern code should use IJetNugetPackageManager/JetNugetPackageManagerForBuild.")]
public static IJetNugetPackage RetrievePackageCore(Func`2<bool, IPackage> λRetrieveCoreCachedOrNot, object pkgidForDiagnostyx, OnError onerror);
    [ExtensionAttribute]
[ObsoleteAttribute("Use GetPackageAsync or GetPackagesAsync")]
public static IJetNugetPackage RetrievePackageExact(IJetNugetPackageManager thіs, JetPackageIdentity pkgid, OnError onerror);
    [ExtensionAttribute]
[NotNullAttribute]
public static IPackageBuilder SanitizePackageBuilder(IPackageBuilder builder);
    [ExtensionAttribute]
[NotNullAttribute]
public static ImmutableFileItem ToFileItem(IPackageFile thіs);
    [ExtensionAttribute]
[ContractAnnotationAttribute("thіs:null => null; notnull => notnull")]
public static JetSemanticVersion ToJetSemanticVersion(SemanticVersion thіs);
    [ExtensionAttribute]
[ContractAnnotationAttribute("thіs:null => null; notnull => notnull")]
public static JetSemanticVersion ToJetSemanticVersion4(NuGetVersion thіs);
    [ExtensionAttribute]
[ContractAnnotationAttribute("thіs:null => null; notnull => notnull")]
public static NuGetVersion ToNu4Version4(JetSemanticVersion thіs);
    [ExtensionAttribute]
[ContractAnnotationAttribute("thіs:null => null; notnull => notnull")]
public static NuGetVersion ToNuGet4Version(JetSemanticVersion thіs);
    [ExtensionAttribute]
public static NuGetFramework ToNuGetFramework(FrameworkName frameworkName);
    [ExtensionAttribute]
[NotNullAttribute]
private static string GetNugetIdSuffix(JetClrImplementation clr);
    [ExtensionAttribute]
[ContractAnnotationAttribute("thіs:null => null; notnull => notnull")]
public static SemanticVersion ToNuSemanticVersion(JetSemanticVersion thіs);
    [ExtensionAttribute]
public static VersionRange ToVersionRangeExact(JetSemanticVersion thіs);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static RelativePath TryGetJetEffectivePath(IPackageFile thіs);
    private static void RetrievePackageCore_AddToMachineCache(IPackage package);
}
public static class JetBrains.Util.Storage.Packages.NuGetHttpCachePathHelper : object {
    private static string HttpCacheEnvironmentKey;
    public static void SetCachePath(Lifetime lifetime, FileSystemPath path);
    public static void SetCachePathWindowsOnly(Lifetime lifetime, FileSystemPath path);
    public static void SetCachePathToWindowsTempWindowsOnly(Lifetime lifetime);
}
public class JetBrains.Util.Storage.Packages.NuGetLogger : object {
    private ILogger myLogger;
    private string myName;
    public NuGetLogger(ILogger logger, Type caller);
    public NuGetLogger(ILogger logger, string name);
    public sealed virtual void Log(MessageLevel level, string message, Object[] args);
    public sealed virtual FileConflictResolution ResolveFileConflict(string message);
}
[ExtensionAttribute]
public static class JetBrains.Util.Storage.Packages.NuGetManifestExtensions : object {
    [ExtensionAttribute]
public static Manifest MakeBackwardCompatible(Manifest manifest);
}
[ExtensionAttribute]
public static class JetBrains.Util.Storage.Packages.NuGetMetadataV2V4Converter : object {
    [ExtensionAttribute]
public static ManifestMetadata ToV2ToV4(IPackageMetadata metadataV4);
    [ExtensionAttribute]
public static ManifestMetadata ToV4(ManifestMetadata metadataV2);
    private static String[] GetCommaSeparatedValues(string values);
    private static List`1<PackageDependencyGroup> CreateDependencySets(ManifestMetadata metadata);
    private static IEnumerable`1<PackageDependency> CreateDependencies(List`1<ManifestDependency> dependencies);
    private static List`1<FrameworkAssemblyReference> CreateFrameworkAssemblyReferences(ManifestMetadata metadata);
    private static List`1<PackageReferenceSet> CreateReferenceSets(ManifestMetadata metadata);
}
[ExtensionAttribute]
public static class JetBrains.Util.Storage.Packages.NuGetMetadataV4V2Converter : object {
    [ExtensionAttribute]
public static ManifestMetadata ToV2(IPackageMetadata metadata);
    private static string GetCommaSeparatedString(IEnumerable`1<string> values);
    private static string ConvertUrlToStringSafe(Uri url);
    private static List`1<ManifestDependencySet> CreateDependencySets(IPackageMetadata metadata);
    private static List`1<ManifestDependency> CreateDependencies(IEnumerable`1<PackageDependency> dependencies);
    private static List`1<ManifestFrameworkAssembly> CreateFrameworkAssemblies(IPackageMetadata metadata);
    private static List`1<ManifestReferenceSet> CreateReferenceSets(IPackageMetadata metadata);
    private static List`1<ManifestReference> CreateReferences(PackageReferenceSet referenceSet);
}
[ExtensionAttribute]
public static class JetBrains.Util.Storage.Packages.NuGetPackageDependencyV2V4Converter : object {
    [ExtensionAttribute]
public static PackageDependency ToV4(PackageDependency dependency);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static VersionRange ToV4(IVersionSpec versionSpec);
    private static String[] GetCommaSeparatedValues(string values);
}
[ExtensionAttribute]
public static class JetBrains.Util.Storage.Packages.NuGetPackageDependencyV4V2Converter : object {
    [ExtensionAttribute]
public static PackageDependency ToV2(PackageDependency dependency);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static IVersionSpec ToV2(VersionRange range);
    private static string GetCommaSeparatedString(IEnumerable`1<string> values);
}
[ExtensionAttribute]
public static class JetBrains.Util.Storage.Packages.NugetPackageFileFormatIntrospection : object {
    private static ILogger Logger;
    private static OnError OnErrorLogger;
    private static NugetPackageFileFormatIntrospection();
    [ExtensionAttribute]
[NotNullAttribute]
public static Byte[] GetNameBytes(ZipEntry entry);
    [NotNullAttribute]
public static IReadOnlyList`1<JetNugetEntry> GetNugetEntriesCore(Nullable`1<Lifetime> lifetime, ImmutableArray`1<ImmutableFileItem> parts, JetNugetFilterFlags flags, JetNugetTargetFramework targetfx);
    public static string GetNugetManifestPartName(ZipFile zipfile, object oPackageNameForContext, OnError onerror);
    public static ImmutableArray`1<ImmutableFileItem> GetNupkgParts(ImmutableFileItem fiNugetPackage);
    public static JetNugetPackageMetadata GetPackageManifestFast(ImmutableFileItem fiNuget);
    public static Manifest GetPackageManifestFast_SystemPackaging(ImmutableFileItem fiNuget);
    public static Manifest GetPackageManifestFast_Zip(ImmutableFileItem fiNuget);
    public static ImmutableArray`1<ImmutableFileItem> FilterNupkgPartsByTargetFxOrFolder(ImmutableArray`1<ImmutableFileItem> unfiltered, JetNugetFilterFlags flags, JetNugetTargetFramework targetfx);
    private static NuGetFramework GetFramework(String[] parts);
    private static ValueTuple`2[] GetNugetEntriesCore_GetFolderPreferenceOrder(JetNugetFilterFlags flags);
    private static bool IsNetStandardOrNetCore(string tfm);
}
public class JetBrains.Util.Storage.Packages.NugetPackageFileItem : object {
    private Lazy`1<ImmutableArray`1<ImmutableFileItem>> myLazyPackageParts;
    [NotNullAttribute]
public ImmutableFileItem File;
    [CompilerGeneratedAttribute]
private JetPackageIdentity <Identity>k__BackingField;
    [CompilerGeneratedAttribute]
private JetNugetPackageMetadata <Manifest>k__BackingField;
    public JetPackageIdentity Identity { get; }
    public JetNugetPackageMetadata Manifest { get; }
    private IJetNugetPackage JetBrains.Util.Storage.Packages.IHaveJetNugetPackage.Package { get; }
    private ImmutableArray`1<ImmutableFileItem> JetBrains.Util.Storage.Packages.IJetNugetPackage.PackageParts { get; }
    public NugetPackageFileItem(JetNugetPackageMetadata manifest, ImmutableFileItem file);
    public NugetPackageFileItem(IStructuredStorage sstg);
    public NugetPackageFileItem(ImmutableFileItem file);
    [CompilerGeneratedAttribute]
public sealed virtual JetPackageIdentity get_Identity();
    [CompilerGeneratedAttribute]
public sealed virtual JetNugetPackageMetadata get_Manifest();
    public sealed virtual bool Equals(NugetPackageFileItem other);
    public virtual bool Equals(object obj);
    public sealed virtual ImmutableArray`1<ImmutableFileItem> FilterPackageParts(JetNugetFilterFlags flags, JetNugetTargetFramework targetfx);
    public virtual int GetHashCode();
    public sealed virtual void GetObjectData(IStructuredStorage sstg);
    public static bool op_Equality(NugetPackageFileItem left, NugetPackageFileItem right);
    public static bool op_Inequality(NugetPackageFileItem left, NugetPackageFileItem right);
    public virtual string ToString();
    private sealed virtual override int System.IComparable<JetBrains.Util.Storage.Packages.NugetPackageFileItem>.CompareTo(NugetPackageFileItem other);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    private sealed virtual override int System.IComparable<JetBrains.Util.Storage.Packages.IJetNugetPackage>.CompareTo(IJetNugetPackage other);
    private sealed virtual override bool System.IEquatable<JetBrains.Util.Storage.Packages.IJetNugetPackage>.Equals(IJetNugetPackage other);
    private sealed virtual override NugetPackageFileItem JetBrains.Util.Storage.Packages.IJetNugetPackage.GetNugetPackageFile();
    private sealed virtual override IJetNugetPackage JetBrains.Util.Storage.Packages.IHaveJetNugetPackage.get_Package();
    private sealed virtual override ImmutableArray`1<ImmutableFileItem> JetBrains.Util.Storage.Packages.IJetNugetPackage.get_PackageParts();
}
[ExtensionAttribute]
public static class JetBrains.Util.Storage.Packages.NugetPackageLegacyConversion : object {
    [ExtensionAttribute]
[NotNullAttribute]
public static IPackage LoadWithNuget2(IJetNugetPackage item);
    [ExtensionAttribute]
public static IJetNugetPackage ToJetNugetPackage(IPackage package);
}
public class JetBrains.Util.Storage.Packages.NugetPackagePromise : object {
    private static string SerializedPartStreamPrefix;
    private JetPackageIdentity myIdentity;
    private Lazy`1<NugetPackageFileItem> myLazyPackage;
    private JetNugetPackageMetadata myManifest;
    private ImmutableArray`1<ImmutableFileItem> myParts;
    private JetPackageIdentity JetBrains.Util.Storage.Packages.IJetNugetPackage.Identity { get; }
    private JetNugetPackageMetadata JetBrains.Util.Storage.Packages.IJetNugetPackage.Manifest { get; }
    private IJetNugetPackage JetBrains.Util.Storage.Packages.IHaveJetNugetPackage.Package { get; }
    private ImmutableArray`1<ImmutableFileItem> JetBrains.Util.Storage.Packages.IJetNugetPackage.PackageParts { get; }
    public NugetPackagePromise(JetNugetPackageMetadata manifest, ImmutableArray`1<ImmutableFileItem> parts);
    public NugetPackagePromise(IStructuredStorage sstg);
    private static NugetPackagePromise();
    private sealed virtual override int System.IComparable<JetBrains.Util.Storage.Packages.IJetNugetPackage>.CompareTo(IJetNugetPackage other);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    private static ImmutableArray`1<ImmutableFileItem> DeserializeParts(IStructuredStorage sstg);
    private sealed virtual override bool System.IEquatable<JetBrains.Util.Storage.Packages.IJetNugetPackage>.Equals(IJetNugetPackage other);
    [NotNullAttribute]
private static string EscapePartPathForSerialization(RelativePath rel);
    private sealed virtual override ImmutableArray`1<ImmutableFileItem> JetBrains.Util.Storage.Packages.IJetNugetPackage.FilterPackageParts(JetNugetFilterFlags flags, JetNugetTargetFramework targetfx);
    private sealed virtual override NugetPackageFileItem JetBrains.Util.Storage.Packages.IJetNugetPackage.GetNugetPackageFile();
    private sealed virtual override void JetBrains.Util.Storage.StructuredStorage.IStructuredStorageSerializable.GetObjectData(IStructuredStorage sstg);
    private sealed virtual override JetPackageIdentity JetBrains.Util.Storage.Packages.IJetNugetPackage.get_Identity();
    private sealed virtual override JetNugetPackageMetadata JetBrains.Util.Storage.Packages.IJetNugetPackage.get_Manifest();
    private sealed virtual override IJetNugetPackage JetBrains.Util.Storage.Packages.IHaveJetNugetPackage.get_Package();
    private sealed virtual override ImmutableArray`1<ImmutableFileItem> JetBrains.Util.Storage.Packages.IJetNugetPackage.get_PackageParts();
    [NotNullAttribute]
private static RelativePath UnescapePartPathForDeserialization(string flat);
}
public static class JetBrains.Util.Storage.Packages.NuGetPackagesConfigHelper : object {
    [NotNullAttribute]
[ItemNotNullAttribute]
public static IEnumerable`1<PackageReference> GetPackageReferences(FileSystemPath packagesConfigPath, bool allowDuplicatePackageIds);
}
[IsReadOnlyAttribute]
public class JetBrains.Util.Storage.Packages.NugetPartPaths : ValueType {
    [CompilerGeneratedAttribute]
private RelativePath <PartPath>k__BackingField;
    [CompilerGeneratedAttribute]
private RelativePath <EffectivePathJet>k__BackingField;
    public RelativePath PartPath { get; public set; }
    public RelativePath EffectivePathJet { get; public set; }
    public NugetPartPaths(RelativePath PartPath, RelativePath EffectivePathJet);
    [CompilerGeneratedAttribute]
public RelativePath get_PartPath();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PartPath(RelativePath value);
    [CompilerGeneratedAttribute]
public RelativePath get_EffectivePathJet();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_EffectivePathJet(RelativePath value);
    public static NugetPartPaths FromPartPath(RelativePath partpath);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(NugetPartPaths left, NugetPartPaths right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(NugetPartPaths left, NugetPartPaths right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(NugetPartPaths other);
    [CompilerGeneratedAttribute]
public void Deconstruct(RelativePath& PartPath, RelativePath& EffectivePathJet);
}
public class JetBrains.Util.Storage.Packages.NuGetSettingWrapper : object {
    private ISettings mySettings;
    public NuGetSettingWrapper(ISettings settings);
    public PackageSourceProvider CreatePackageSourceProvider();
}
public static class JetBrains.Util.Storage.Packages.NuGetUtil : object {
    [PureAttribute]
public static bool HasDependencyOn(IJetNugetPackage nupkgFile, string packageId);
}
[ExtensionAttribute]
public static class JetBrains.Util.Storage.Packages.NuGetVersionRangeExtensions : object {
    [ExtensionAttribute]
[CanBeNullAttribute]
public static IVersionSpec ToVersionSpec(VersionRange versionRange);
}
[ExtensionAttribute]
public static class JetBrains.Util.Storage.Packages.PackageIdentityExtensions : object {
    [ExtensionAttribute]
public static JetPackageIdentity ToJet(PackageIdentity identity);
}
public static class JetBrains.Util.Storage.Packages.SubplatformPackageLayoutConstants : object {
    public static string JetBrainsContentFilesFolder;
    [NotNullAttribute]
public static string JetMetadataInApplicationPackageExt;
    public static string NugetLibFolder;
    public static string NugetRefFolder;
    public static string NugetRuntimesFolder;
    public static string PackageEmptyFileName;
    public static string SubplatformPlatformCoreShellPackageId;
    private static SubplatformPackageLayoutConstants();
    public static bool IsPackageFileEffectivePathSuitableForManagedReference(RelativePath pathEffective, bool isNoCheckFolderLevel, bool isNoCheckFileExtension, bool isNoCheckRuntimesFolder);
    [CanBeNullAttribute]
public static RelativePath TryGetJetEffectivePath(RelativePath relOpcPartPath);
}
public class JetBrains.Util.Storage.SimpleFileItemPackageFile : object {
    public ImmutableFileItem FileItem;
    private string NuGet.Packaging.IPackageFile.Path { get; }
    private string NuGet.Packaging.IPackageFile.EffectivePath { get; }
    private FrameworkName NuGet.Packaging.IPackageFile.TargetFramework { get; }
    public NuGetFramework NuGetFramework { get; }
    private DateTimeOffset NuGet.Packaging.IPackageFile.LastWriteTime { get; }
    public SimpleFileItemPackageFile(ImmutableFileItem file);
    public virtual string ToString();
    private string GetOsDependentPath();
    private sealed virtual override Stream NuGet.Packaging.IPackageFile.GetStream();
    private sealed virtual override string NuGet.Packaging.IPackageFile.get_Path();
    private sealed virtual override string NuGet.Packaging.IPackageFile.get_EffectivePath();
    private sealed virtual override FrameworkName NuGet.Packaging.IPackageFile.get_TargetFramework();
    public sealed virtual NuGetFramework get_NuGetFramework();
    private sealed virtual override DateTimeOffset NuGet.Packaging.IPackageFile.get_LastWriteTime();
}
public class JetBrains.Util.Storage.StructuredStorage.AnonymousStructuredStorageCollection`1 : object {
    private Func`1<Nullable`1<int>> myFCount;
    private Func`2<string, TItem> myFCreate;
    private Func`1<IEnumerable`1<TItem>> myFEnum;
    private Func`2<TItem, bool> myFRemove;
    [CanBeNullAttribute]
private Func`3<TItem, OnError, bool> myFTryAdd;
    [NotNullAttribute]
private Func`2<string, TItem> myFTryGet;
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<TItem>.IsReadOnly { get; }
    private TItem JetBrains.Util.Storage.StructuredStorage.IStructuredStorageCollection<TItem>.Item { get; }
    public AnonymousStructuredStorageCollection`1(Func`1<IEnumerable`1<TItem>> FEnum, Func`1<Nullable`1<int>> FCount, Func`2<TItem, bool> FRemove, Func`2<string, TItem> FCreate, Func`2<string, TItem> FTryGet, Func`3<TItem, OnError, bool> FTryAdd);
    public sealed virtual int get_Count();
    private sealed virtual override void System.Collections.Generic.ICollection<TItem>.Add(TItem item);
    private sealed virtual override void System.Collections.Generic.ICollection<TItem>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<TItem>.Contains(TItem item);
    private sealed virtual override void System.Collections.Generic.ICollection<TItem>.CopyTo(TItem[] array, int arrayIndex);
    private sealed virtual override TItem JetBrains.Util.Storage.StructuredStorage.IStructuredStorageCollection<TItem>.Create(string name);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IEnumerator`1<TItem> System.Collections.Generic.IEnumerable<TItem>.GetEnumerator();
    private sealed virtual override bool System.Collections.Generic.ICollection<TItem>.get_IsReadOnly();
    private sealed virtual override TItem JetBrains.Util.Storage.StructuredStorage.IStructuredStorageCollection<TItem>.get_Item(string name);
    private sealed virtual override bool System.Collections.Generic.ICollection<TItem>.Remove(TItem item);
    private sealed virtual override bool JetBrains.Util.Storage.StructuredStorage.IStructuredStorageCollection<TItem>.TryAdd(TItem item, OnError onerror);
    private sealed virtual override TItem JetBrains.Util.Storage.StructuredStorage.IStructuredStorageCollection<TItem>.TryGetItem(string name);
}
public class JetBrains.Util.Storage.StructuredStorage.AnonymousStructuredStorageCollectionClosureFree`2 : object {
    private TCtx myCtx;
    private Func`2<TCtx, Nullable`1<int>> myFCount;
    private Func`3<TCtx, string, TItem> myFCreate;
    private Func`2<TCtx, IEnumerable`1<TItem>> myFEnum;
    [CanBeNullAttribute]
private Func`3<TCtx, TItem, string> myFGetItemName;
    private Func`3<TCtx, TItem, bool> myFRemove;
    [CanBeNullAttribute]
private Func`4<TCtx, TItem, OnError, bool> myFTryAdd;
    [CanBeNullAttribute]
private Func`3<TCtx, string, TItem> myFTryGet;
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<TItem>.IsReadOnly { get; }
    private TItem JetBrains.Util.Storage.StructuredStorage.IStructuredStorageCollection<TItem>.Item { get; }
    public AnonymousStructuredStorageCollectionClosureFree`2(TCtx ctx, Func`2<TCtx, IEnumerable`1<TItem>> FEnum, Func`2<TCtx, Nullable`1<int>> FCount, Func`3<TCtx, TItem, bool> FRemove, Func`3<TCtx, string, TItem> FCreate, Func`3<TCtx, string, TItem> FTryGet, Func`3<TCtx, TItem, string> FGetItemName, Func`4<TCtx, TItem, OnError, bool> FTryAdd);
    public sealed virtual int get_Count();
    private sealed virtual override void System.Collections.Generic.ICollection<TItem>.Add(TItem item);
    private sealed virtual override void System.Collections.Generic.ICollection<TItem>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<TItem>.Contains(TItem item);
    private sealed virtual override void System.Collections.Generic.ICollection<TItem>.CopyTo(TItem[] array, int arrayIndex);
    private sealed virtual override TItem JetBrains.Util.Storage.StructuredStorage.IStructuredStorageCollection<TItem>.Create(string name);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IEnumerator`1<TItem> System.Collections.Generic.IEnumerable<TItem>.GetEnumerator();
    private sealed virtual override bool System.Collections.Generic.ICollection<TItem>.get_IsReadOnly();
    private sealed virtual override TItem JetBrains.Util.Storage.StructuredStorage.IStructuredStorageCollection<TItem>.get_Item(string name);
    private sealed virtual override bool System.Collections.Generic.ICollection<TItem>.Remove(TItem item);
    private sealed virtual override bool JetBrains.Util.Storage.StructuredStorage.IStructuredStorageCollection<TItem>.TryAdd(TItem item, OnError onerror);
    private sealed virtual override TItem JetBrains.Util.Storage.StructuredStorage.IStructuredStorageCollection<TItem>.TryGetItem(string name);
    private TItem TryGetItemCore(string name);
}
public class JetBrains.Util.Storage.StructuredStorage.AnonymousStructuredStorageStream : object {
    private Func`3<Lifetime, StreamOpenFlags, Stream> myFOpen;
    private string myName;
    private string JetBrains.Util.Storage.StructuredStorage.INamedItem.Name { get; }
    public AnonymousStructuredStorageStream(string name, Func`3<Lifetime, StreamOpenFlags, Stream> FOpen);
    private sealed virtual override string JetBrains.Util.Storage.StructuredStorage.INamedItem.get_Name();
    private sealed virtual override Stream JetBrains.Util.Storage.StructuredStorage.IStructuredStorageStream.Open(Lifetime lifetime, StreamOpenFlags flags);
}
public class JetBrains.Util.Storage.StructuredStorage.BankSwitchingStructuredStorageSimple : object {
    private Stg myRoot;
    private IStructuredStorageCollection`1<ImmutableFileItem> JetBrains.Util.Storage.StructuredStorage.IImmutableStreamsStorage.ImmutableStreams { get; }
    private string JetBrains.Util.Storage.StructuredStorage.INamedItem.Name { get; }
    private IStructuredStorageCollection`1<IStructuredStorage> JetBrains.Util.Storage.StructuredStorage.IStructuredStorage.Storages { get; }
    private IStructuredStorageCollection`1<IStructuredStorageStream> JetBrains.Util.Storage.StructuredStorage.IStructuredStorage.Streams { get; }
    public BankSwitchingStructuredStorageSimple(BankSwitchingMemoryStreamSimple mainstream, ReadWrite rw);
    private sealed virtual override IStructuredStorageCollection`1<ImmutableFileItem> JetBrains.Util.Storage.StructuredStorage.IImmutableStreamsStorage.get_ImmutableStreams();
    private sealed virtual override string JetBrains.Util.Storage.StructuredStorage.INamedItem.get_Name();
    private sealed virtual override IStructuredStorageCollection`1<IStructuredStorage> JetBrains.Util.Storage.StructuredStorage.IStructuredStorage.get_Storages();
    private sealed virtual override IStructuredStorageCollection`1<IStructuredStorageStream> JetBrains.Util.Storage.StructuredStorage.IStructuredStorage.get_Streams();
}
public class JetBrains.Util.Storage.StructuredStorage.ComStructuredStorage : object {
    private static Guid LongNamesPropertySetFmtId;
    private OpenStoragesPool myOpenStoragesPool;
    private RelativePath myPath;
    private IStructuredStorageCollection`1<IStructuredStorage> myStoragesCollection;
    private IStructuredStorageCollection`1<IStructuredStorageStream> myStreamsCollection;
    private string JetBrains.Util.Storage.StructuredStorage.INamedItem.Name { get; }
    private IStructuredStorageCollection`1<IStructuredStorage> JetBrains.Util.Storage.StructuredStorage.IStructuredStorage.Storages { get; }
    private IStructuredStorageCollection`1<IStructuredStorageStream> JetBrains.Util.Storage.StructuredStorage.IStructuredStorage.Streams { get; }
    public ComStructuredStorage(Lifetime lifetime, IStorage storage, ImplementationFlags implflags);
    private ComStructuredStorage(RelativePath path, OpenStoragesPool openStoragesPool);
    private static ComStructuredStorage();
    private int CountElements(STGTY stgty);
    private IStructuredStorageStream CreateChildStream(string sName, OpenOrCreate openorcreate);
    private AnonymousStructuredStorageCollection`1<IStructuredStorage> Ctor_Storages();
    private IStructuredStorageCollection`1<IStructuredStorageStream> Ctor_Streams();
    private IEnumerable`1<TInterface> EnumElements();
    [NotNullAttribute]
private OpenStorageRecord OpenMyStorageNoLock();
    private sealed virtual override string JetBrains.Util.Storage.StructuredStorage.INamedItem.get_Name();
    private sealed virtual override IStructuredStorageCollection`1<IStructuredStorage> JetBrains.Util.Storage.StructuredStorage.IStructuredStorage.get_Storages();
    private sealed virtual override IStructuredStorageCollection`1<IStructuredStorageStream> JetBrains.Util.Storage.StructuredStorage.IStructuredStorage.get_Streams();
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Ctor_Storages>b__9_0();
    [CompilerGeneratedAttribute]
private bool <Ctor_Storages>b__9_1(IStructuredStorage substorage);
    [CompilerGeneratedAttribute]
private IStructuredStorage <Ctor_Storages>b__9_2(string name);
    [CompilerGeneratedAttribute]
private IStructuredStorage <Ctor_Storages>b__9_3(string name);
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Ctor_Streams>b__10_0();
    [CompilerGeneratedAttribute]
private bool <Ctor_Streams>b__10_1(IStructuredStorageStream substream);
    [CompilerGeneratedAttribute]
private IStructuredStorageStream <Ctor_Streams>b__10_2(string name);
    [CompilerGeneratedAttribute]
private IStructuredStorageStream <Ctor_Streams>b__10_3(string name);
}
public static class JetBrains.Util.Storage.StructuredStorage.ComStructuredStorages : object {
    private static STGC DefaultCommitFlags;
    private static ComStructuredStorages();
    public static void CreateDiskFile(FileSystemPath file, ComStorageFormat format, Action`1<IStructuredStorage> λWrite);
    [NotNullAttribute]
public static ChunkedMemoryStream CreateMemoryStream(ComStorageFormat format, Action`1<IStructuredStorage> λWrite);
    public static void CreateOnLockBytes(ILockBytes lockbytes, ComStorageFormat format, Action`1<IStructuredStorage> λWrite);
    [NotNullAttribute]
public static ComStructuredStorage CreateOnLockBytes(Lifetime lifetime, ILockBytes lockbytes, ComStorageFormat format);
    [NotNullAttribute]
public static ComStructuredStorage CreateOnStream(Lifetime lifetime, Stream stream, ComStorageFormat format);
    public static void ModifyLockBytes(ILockBytes lockbytes, ComStorageFormat format, Action`1<IStructuredStorage> λModify);
    public static TValue OpenDiskFile(FileSystemPath file, ComStorageFormat format, Func`2<IStructuredStorage, TValue> λRead);
    [NotNullAttribute]
public static ComStructuredStorage OpenLockBytes(Lifetime lifetime, ILockBytes lockbytes, ComStorageFormat format, ReadWrite rw);
    [NotNullAttribute]
public static ComStructuredStorage OpenStream(Lifetime lifetime, Stream stream, ComStorageFormat format);
    [NotNullAttribute]
public static TValue ReadLockBytes(ILockBytes lockbytes, ComStorageFormat format, Func`2<IStructuredStorage, TValue> λRead);
    [NotNullAttribute]
public static TValue ReadStream(Stream stream, ComStorageFormat format, Func`2<IStructuredStorage, TValue> λRead);
}
public class JetBrains.Util.Storage.StructuredStorage.DiskFolderStructuredStorage : object {
    private FileSystemPath myFolder;
    private IStructuredStorageCollection`1<IStructuredStorage> myStoragesCollection;
    private IStructuredStorageCollection`1<IStructuredStorageStream> myStreamsCollection;
    private string JetBrains.Util.Storage.StructuredStorage.INamedItem.Name { get; }
    private IStructuredStorageCollection`1<IStructuredStorage> JetBrains.Util.Storage.StructuredStorage.IStructuredStorage.Storages { get; }
    private IStructuredStorageCollection`1<IStructuredStorageStream> JetBrains.Util.Storage.StructuredStorage.IStructuredStorage.Streams { get; }
    public DiskFolderStructuredStorage(FileSystemPath pathFolder);
    private sealed virtual override string JetBrains.Util.Storage.StructuredStorage.INamedItem.get_Name();
    private sealed virtual override IStructuredStorageCollection`1<IStructuredStorage> JetBrains.Util.Storage.StructuredStorage.IStructuredStorage.get_Storages();
    private sealed virtual override IStructuredStorageCollection`1<IStructuredStorageStream> JetBrains.Util.Storage.StructuredStorage.IStructuredStorage.get_Streams();
    [CompilerGeneratedAttribute]
internal static IEnumerable`1<IStructuredStorage> <.ctor>g__StgEnum|3_2(FileSystemPath pathFolder);
    [CompilerGeneratedAttribute]
internal static bool <.ctor>g__StgRemove|3_3(FileSystemPath pathFolder, IStructuredStorage storage);
    [CompilerGeneratedAttribute]
internal static IStructuredStorage <.ctor>g__StgCreate|3_4(FileSystemPath pathFolder, string name);
    [CompilerGeneratedAttribute]
internal static IStructuredStorage <.ctor>g__StgTryGet|3_5(FileSystemPath pathFolder, string name);
    [CompilerGeneratedAttribute]
internal static IStructuredStorageStream <.ctor>g__FWrapFile|3_6(FileSystemPath pathFile);
    [CompilerGeneratedAttribute]
internal static IEnumerable`1<IStructuredStorageStream> <.ctor>g__StmEnum|3_7(FileSystemPath pathFolder);
    [CompilerGeneratedAttribute]
internal static bool <.ctor>g__StmRemove|3_8(FileSystemPath pathFolder, IStructuredStorageStream stream);
    [CompilerGeneratedAttribute]
internal static IStructuredStorageStream <.ctor>g__StmCreate|3_9(FileSystemPath pathFolder, string name);
    [CompilerGeneratedAttribute]
internal static IStructuredStorageStream <.ctor>g__StmTryGet|3_10(FileSystemPath pathFolder, string name);
}
public interface JetBrains.Util.Storage.StructuredStorage.IImmutableStreamsStorage {
    [NotNullAttribute]
public IStructuredStorageCollection`1<ImmutableFileItem> ImmutableStreams { get; }
    public abstract virtual IStructuredStorageCollection`1<ImmutableFileItem> get_ImmutableStreams();
}
public interface JetBrains.Util.Storage.StructuredStorage.INamedItem {
    [NotNullAttribute]
public string Name { get; }
    public abstract virtual string get_Name();
}
public interface JetBrains.Util.Storage.StructuredStorage.IStructuredStorage {
    [NotNullAttribute]
public IStructuredStorageCollection`1<IStructuredStorage> Storages { get; }
    [NotNullAttribute]
public IStructuredStorageCollection`1<IStructuredStorageStream> Streams { get; }
    public abstract virtual IStructuredStorageCollection`1<IStructuredStorage> get_Storages();
    public abstract virtual IStructuredStorageCollection`1<IStructuredStorageStream> get_Streams();
}
[DefaultMemberAttribute("Item")]
public interface JetBrains.Util.Storage.StructuredStorage.IStructuredStorageCollection`1 {
    public int Count { get; }
    [NotNullAttribute]
public TItem Item { get; }
    public abstract virtual int get_Count();
    public abstract virtual TItem get_Item(string name);
    [NotNullAttribute]
public abstract virtual TItem Create(string name);
    public abstract virtual bool TryAdd(TItem item, OnError onerror);
    [CanBeNullAttribute]
public abstract virtual TItem TryGetItem(string name);
}
[ExtensionAttribute]
public static class JetBrains.Util.Storage.StructuredStorage.IStructuredStorageEx : object {
    [ExtensionAttribute]
public static void AddFileItem(IStructuredStorage thіs, ImmutableFileItem fi);
    [ExtensionAttribute]
public static bool Contains(IStructuredStorageCollection`1<TItem> thіs, string name);
    [ExtensionAttribute]
public static void CopyTo(IStructuredStorage thіs, IStructuredStorage dest);
    [ExtensionAttribute]
public static bool Remove(IStructuredStorageCollection`1<TItem> thіs, string name);
    [CompilerGeneratedAttribute]
internal static IEnumerable`1<ValueTuple`2<IStructuredStorage, IStructuredStorage>> <CopyTo>g__CreateChildStorages|2_0(ValueTuple`2<IStructuredStorage, IStructuredStorage> t);
    [CompilerGeneratedAttribute]
internal static void <CopyTo>g__CopyStreams|2_1(ValueTuple`2<IStructuredStorage, IStructuredStorage> t);
}
[ComVisibleAttribute("True")]
public interface JetBrains.Util.Storage.StructuredStorage.IStructuredStorageSerializable {
    public abstract virtual void GetObjectData(IStructuredStorage storage);
}
public interface JetBrains.Util.Storage.StructuredStorage.IStructuredStorageStream {
    [NotNullAttribute]
public abstract virtual Stream Open(Lifetime lifetime, StreamOpenFlags flags);
}
[ObsoleteAttribute("OPC .NET API is slow and does not have benefits over an explicit ZIP storage, use ZIP instead.")]
public class JetBrains.Util.Storage.StructuredStorage.PackageStructuredStorage : object {
    public static CompressionOption CompressionOption;
    private string myName;
    private IStructuredStorageCollection`1<IStructuredStorage> myStoragesCollection;
    private IStructuredStorageCollection`1<IStructuredStorageStream> myStreamsCollection;
    private string JetBrains.Util.Storage.StructuredStorage.INamedItem.Name { get; }
    private IStructuredStorageCollection`1<IStructuredStorage> JetBrains.Util.Storage.StructuredStorage.IStructuredStorage.Storages { get; }
    private IStructuredStorageCollection`1<IStructuredStorageStream> JetBrains.Util.Storage.StructuredStorage.IStructuredStorage.Streams { get; }
    public PackageStructuredStorage(string name, Package package);
    private static PackageStructuredStorage();
    [NotNullAttribute]
public static ChunkedMemoryStream CreateMemoryStream(Action`1<IStructuredStorage> FWrite);
    [NotNullAttribute]
public static PackageStructuredStorage CreateOnStream(Lifetime lifetime, Stream stream);
    public static void OpenStream(Stream stream, Action`1<IStructuredStorage> FRead);
    [NotNullAttribute]
public static PackageStructuredStorage OpenStream(Lifetime lifetime, Stream stream);
    public static TReturn OpenStream(Stream stream, Func`2<IStructuredStorage, TReturn> FRead);
    [NotNullAttribute]
private static RelativePath GetPartPath(PackagePart part);
    private static Uri GetPartUri(RelativePath path);
    private sealed virtual override string JetBrains.Util.Storage.StructuredStorage.INamedItem.get_Name();
    private sealed virtual override IStructuredStorageCollection`1<IStructuredStorage> JetBrains.Util.Storage.StructuredStorage.IStructuredStorage.get_Storages();
    private sealed virtual override IStructuredStorageCollection`1<IStructuredStorageStream> JetBrains.Util.Storage.StructuredStorage.IStructuredStorage.get_Streams();
}
public class JetBrains.Util.Storage.StructuredStorage.RuntimeStructuredStorage : object {
    private static Func`2<Dictionary`2<string, Stm>, Nullable`1<int>> FiCount;
    private static Func`3<Dictionary`2<string, Stm>, string, ImmutableFileItem> FiCreate;
    private static Func`2<Dictionary`2<string, Stm>, IEnumerable`1<ImmutableFileItem>> FiEnum;
    private static Func`3<Dictionary`2<string, Stm>, ImmutableFileItem, string> FiGetItemName;
    private static Func`3<Dictionary`2<string, Stm>, ImmutableFileItem, bool> FiRemove;
    private static Func`4<Dictionary`2<string, Stm>, ImmutableFileItem, OnError, bool> FiTryAdd;
    private static Func`3<Dictionary`2<string, Stm>, string, ImmutableFileItem> FiTryGet;
    private static string RootStorageName;
    private static Func`2<IDictionary`2<string, IStructuredStorage>, Nullable`1<int>> StgCount;
    private static Func`3<IDictionary`2<string, IStructuredStorage>, string, IStructuredStorage> StgCreate;
    private static Func`2<IDictionary`2<string, IStructuredStorage>, IEnumerable`1<IStructuredStorage>> StgEnum;
    private static Func`3<IDictionary`2<string, IStructuredStorage>, IStructuredStorage, bool> StgRemove;
    private static Func`3<IDictionary`2<string, IStructuredStorage>, string, IStructuredStorage> StgTryGet;
    private static Func`2<Dictionary`2<string, Stm>, Nullable`1<int>> StmCount;
    private static Func`3<Dictionary`2<string, Stm>, string, IStructuredStorageStream> StmCreate;
    private static Func`2<Dictionary`2<string, Stm>, IEnumerable`1<IStructuredStorageStream>> StmEnum;
    private static Func`3<Dictionary`2<string, Stm>, IStructuredStorageStream, bool> StmRemove;
    private static Func`3<Dictionary`2<string, Stm>, string, IStructuredStorageStream> StmTryGet;
    [CanBeNullAttribute]
private IStructuredStorageCollection`1<ImmutableFileItem> myImmutableStreamsCollection;
    private FrugalLocalLazy`1<Dictionary`2<string, Stm>> myMapStreamsAndImmutableStreams;
    private string myName;
    [CanBeNullAttribute]
private IStructuredStorageCollection`1<IStructuredStorage> myStoragesCollection;
    [CanBeNullAttribute]
private IStructuredStorageCollection`1<IStructuredStorageStream> myStreamsCollection;
    private IStructuredStorageCollection`1<ImmutableFileItem> JetBrains.Util.Storage.StructuredStorage.IImmutableStreamsStorage.ImmutableStreams { get; }
    private string JetBrains.Util.Storage.StructuredStorage.INamedItem.Name { get; }
    private IStructuredStorageCollection`1<IStructuredStorage> JetBrains.Util.Storage.StructuredStorage.IStructuredStorage.Storages { get; }
    private IStructuredStorageCollection`1<IStructuredStorageStream> JetBrains.Util.Storage.StructuredStorage.IStructuredStorage.Streams { get; }
    public RuntimeStructuredStorage(string name);
    private static RuntimeStructuredStorage();
    public void EnsureNotLifetimed();
    private sealed virtual override IStructuredStorageCollection`1<ImmutableFileItem> JetBrains.Util.Storage.StructuredStorage.IImmutableStreamsStorage.get_ImmutableStreams();
    private sealed virtual override string JetBrains.Util.Storage.StructuredStorage.INamedItem.get_Name();
    private sealed virtual override IStructuredStorageCollection`1<IStructuredStorage> JetBrains.Util.Storage.StructuredStorage.IStructuredStorage.get_Storages();
    private sealed virtual override IStructuredStorageCollection`1<IStructuredStorageStream> JetBrains.Util.Storage.StructuredStorage.IStructuredStorage.get_Streams();
    [IteratorStateMachineAttribute("JetBrains.Util.Storage.StructuredStorage.RuntimeStructuredStorage/<<EnsureNotLifetimed>g__GetChildStorages|24_0>d")]
[CompilerGeneratedAttribute]
internal static IEnumerable`1<RuntimeStructuredStorage> <EnsureNotLifetimed>g__GetChildStorages|24_0(RuntimeStructuredStorage sstg);
    [CompilerGeneratedAttribute]
internal static void <EnsureNotLifetimed>g__DoStreams|24_1(RuntimeStructuredStorage sstg);
}
public enum JetBrains.Util.Storage.StructuredStorage.StreamOpenFlags.Exists : Enum {
    public byte value__;
    public static Exists DontCare;
    public static Exists MustExist;
    public static Exists MustNotExist;
}
[FlagsAttribute]
public enum JetBrains.Util.Storage.StructuredStorage.StreamOpenFlags.ReadWrite : Enum {
    public byte value__;
    public static ReadWrite Read;
    public static ReadWrite Write;
    public static ReadWrite ReadWrite;
}
public enum JetBrains.Util.Storage.StructuredStorage.StreamOpenFlags.Seek : Enum {
    public byte value__;
    public static Seek Begin;
    public static Seek End;
}
public class JetBrains.Util.Storage.StructuredStorage.StreamOpenFlags.StreamOpenFlags : ValueType {
    public Exists Exists;
    public ReadWrite ReadWrite;
    public Seek Seek;
    public Truncate Truncate;
    public static StreamOpenFlags ReadExisting { get; }
    public static StreamOpenFlags WriteNewContent { get; }
    public StreamOpenFlags(ReadWrite readWrite, Seek seek, Exists exists, Truncate truncate);
    public static StreamOpenFlags get_ReadExisting();
    public static StreamOpenFlags get_WriteNewContent();
    public static bool op_Equality(StreamOpenFlags left, StreamOpenFlags right);
    public static bool op_Inequality(StreamOpenFlags left, StreamOpenFlags right);
    public bool IsValidCombination(OnError onerror);
    public FileAccess ToFileAccess();
    public FileMode ToFileMode();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public sealed virtual bool Equals(StreamOpenFlags other);
}
public enum JetBrains.Util.Storage.StructuredStorage.StreamOpenFlags.Truncate : Enum {
    public int value__;
    public static Truncate KeepSize;
    public static Truncate ZeroSize;
}
[ExtensionAttribute]
public static class JetBrains.Util.Storage.StructuredStorage.StructuredStorageHelpers : object {
    private static string EmptyNameEscapeString;
    private static EscapeChars EscapeToValidNameEscapeChars;
    private static ILogger Logger;
    private static StructuredStorageHelpers();
    public static string EscapeToValidName(string name);
    [ExtensionAttribute]
[NotNullAttribute]
public static TItem GetItem(IStructuredStorageCollection`1<TItem> thіs, string name);
    [ExtensionAttribute]
[NotNullAttribute]
public static TItem GetOrCreateItem(IStructuredStorageCollection`1<TItem> thіs, string name);
    public static bool IsNameValid(string name, OnError onerror);
    [ExtensionAttribute]
public static void ReadStream(IStructuredStorageStream thіs, Action`1<Stream> FRead);
    [ExtensionAttribute]
public static TValue ReadStream(IStructuredStorageStream thіs, Func`2<Stream, TValue> FRead);
    [ExtensionAttribute]
public static void ReadStream(IStructuredStorageCollection`1<IStructuredStorageStream> thіs, string name, Action`1<Stream> FRead);
    [ExtensionAttribute]
public static TValue ReadStream(IStructuredStorageCollection`1<IStructuredStorageStream> thіs, string name, Func`2<Stream, TValue> FRead);
    [ExtensionAttribute]
[NotNullAttribute]
public static string ReadUtf8(IStructuredStorageCollection`1<IStructuredStorageStream> thіs, string name);
    [ExtensionAttribute]
[NotNullAttribute]
public static string ReadUtf8(IStructuredStorageStream thіs);
    [ExtensionAttribute]
public static void ReadUtf8(IStructuredStorageStream thіs, Action`1<StreamReader> λRead);
    [ExtensionAttribute]
public static TValue ReadUtf8(IStructuredStorageStream thіs, Func`2<StreamReader, TValue> λRead);
    public static string ReverseEscapeToValidName(string name);
    [ExtensionAttribute]
public static void WriteCsexp(IStructuredStorageStream thіs, Action`1<CsexpWriter> λWrite);
    [ExtensionAttribute]
public static void WriteStream(IStructuredStorageStream thіs, Action`1<Stream> FWrite);
    [ExtensionAttribute]
public static void WriteStream(IStructuredStorageStream thіs, Stream streamCopyFrom);
    [ExtensionAttribute]
public static void WriteStream(IStructuredStorageCollection`1<IStructuredStorageStream> thіs, string name, Action`1<Stream> FWrite);
    [ExtensionAttribute]
public static void WriteUtf8(IStructuredStorageCollection`1<IStructuredStorageStream> thіs, string name, string value);
    [ExtensionAttribute]
public static void WriteUtf8(IStructuredStorageStream thіs, string value);
    [ExtensionAttribute]
public static void WriteUtf8(IStructuredStorageStream thіs, Action`1<StreamWriter> λWrite);
}
public static class JetBrains.Util.Storage.StructuredStorage.StructuredStorages : object {
    public static Format DefaultStorageFormat;
    private static ImmutableArray`1<Header> Headers;
    public static Format PublicFilesPreferredFormat;
    public static string UniversalStorageExtension;
    private static StructuredStorages();
    [NotNullAttribute]
public static ChunkedMemoryStream CreateMemoryStream(Action`1<IStructuredStorage> λ, Nullable`1<Format> formatIfPreferred);
    public static void CreateOnStream(Stream stream, Action`1<IStructuredStorage> λ, Nullable`1<Format> formatIfPreferred);
    public static IStructuredStorage CreateOnStream(Lifetime lifetime, Stream stream, Format format, OnError onerror);
    public static TReturn OpenStream(Stream stream, Func`2<IStructuredStorage, TReturn> λ, Nullable`1<Format> formatIfKnown);
    public static void OpenStream(Stream stream, Action`1<IStructuredStorage> λ, Nullable`1<Format> formatIfKnown);
    public static IStructuredStorage OpenStream(Lifetime lifetime, Stream stream, OnError onerror, Nullable`1<Format> formatIfKnown);
    private static Nullable`1<Format> DetectStreamFormat(Stream stream, OnError onerror);
    private static HResults StgIsStorageILockBytes(Stream stream);
    private static void RestoreStreamPosition(Stream stream, long position, OnError onerror);
}
public class JetBrains.Util.Storage.StructuredStorage.ZipStructuredStorage : object {
    public static EscapeChars EscapeRules;
    private IStructuredStorage myRoot;
    private string JetBrains.Util.Storage.StructuredStorage.INamedItem.Name { get; }
    private IStructuredStorageCollection`1<IStructuredStorage> JetBrains.Util.Storage.StructuredStorage.IStructuredStorage.Storages { get; }
    private IStructuredStorageCollection`1<IStructuredStorageStream> JetBrains.Util.Storage.StructuredStorage.IStructuredStorage.Streams { get; }
    public ZipStructuredStorage(Lifetime lifetime, ZipFile package);
    private static ZipStructuredStorage();
    [NotNullAttribute]
public static ZipStructuredStorage CreateOnStream(Lifetime lifetime, Stream stream);
    public static void OpenStream(Stream stream, Action`1<IStructuredStorage> fRead);
    [NotNullAttribute]
public static ZipStructuredStorage OpenStream(Lifetime lifetime, Stream stream);
    public static TReturn OpenStream(Stream stream, Func`2<IStructuredStorage, TReturn> fRead);
    private sealed virtual override string JetBrains.Util.Storage.StructuredStorage.INamedItem.get_Name();
    private sealed virtual override IStructuredStorageCollection`1<IStructuredStorage> JetBrains.Util.Storage.StructuredStorage.IStructuredStorage.get_Storages();
    private sealed virtual override IStructuredStorageCollection`1<IStructuredStorageStream> JetBrains.Util.Storage.StructuredStorage.IStructuredStorage.get_Streams();
}
public class JetBrains.Util.StreamUnderLifetime : Stream {
    private LifetimeDefinition myLifetimeDefinition;
    private Stream myStream;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanTimeout { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public int ReadTimeout { get; public set; }
    public int WriteTimeout { get; public set; }
    public StreamUnderLifetime(OuterLifetime outerlifetime, Func`2<Lifetime, Stream> FGetStream);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void Close();
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte value);
    protected virtual void Dispose(bool disposing);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanTimeout();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
}
public class JetBrains.Util.StringEncryption : object {
    private SymmetricAlgorithm myCryptoService;
    public StringEncryption(StringEncryptionMethod method);
    public StringEncryption(SymmetricAlgorithm serviceProvider);
    private Byte[] GetLegalKey(string key);
    public string Encrypt(string source, string key);
    public string Decrypt(string source, string key);
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.Util.StringSearcher : object {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static DirectMappedCache`2<ValueTuple`2<string, bool>, StringSearcher> ourCache;
    private int myPatternLength;
    private Int32[] mySearchTable;
    private Char[] myPatternArray;
    private bool myCaseSensitive;
    public StringSearcher(string pattern, bool caseSensitive);
    private static StringSearcher();
    public static StringSearcher GetOrCreateCached(string pattern, bool caseSensitive);
    public int Find(IBuffer buffer);
    public int Find(IBuffer buffer, int startOffset, int endOffset);
    public IList`1<int> FindAll(IBuffer buffer);
    public IList`1<int> FindAll(IBuffer buffer, int startOffset, int endOffset);
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Util.StrongToWeakDictionary`2 : object {
    private static Statistics Statistics;
    private static object NullObject;
    private IEqualityComparer`1<TKey> myComparer;
    private Entry[] myEntries;
    private int myEntriesUsed;
    private int myFirstFreeIndex;
    private int myFreeCount;
    private Int32[] myHashToEntryIndex;
    private KeyCollection<TKey, TValue> myKeys;
    private ValueCollection<TKey, TValue> myValues;
    private int myVersion;
    public IEqualityComparer`1<TKey> Comparer { get; }
    public KeyCollection<TKey, TValue> Keys { get; }
    public ValueCollection<TKey, TValue> Values { get; }
    public int Capacity { get; }
    public TValue Item { get; public set; }
    [ObsoleteAttribute("Use an overload with lifetime.")]
public StrongToWeakDictionary`2(IDictionary`2<TKey, TValue> dictionary);
    [ObsoleteAttribute("Use an overload with lifetime.")]
public StrongToWeakDictionary`2(IEqualityComparer`1<TKey> comparer);
    [ObsoleteAttribute("Use an overload with lifetime.")]
public StrongToWeakDictionary`2(int capacity);
    [ObsoleteAttribute("Use an overload with lifetime.")]
public StrongToWeakDictionary`2(IDictionary`2<TKey, TValue> dictionary, IEqualityComparer`1<TKey> comparer);
    [ObsoleteAttribute("Use an overload with lifetime.")]
public StrongToWeakDictionary`2(int capacity, IEqualityComparer`1<TKey> comparer);
    public StrongToWeakDictionary`2(Lifetime lifetime);
    public StrongToWeakDictionary`2(Lifetime lifetime, IDictionary`2<TKey, TValue> dictionary);
    public StrongToWeakDictionary`2(Lifetime lifetime, IEqualityComparer`1<TKey> comparer);
    public StrongToWeakDictionary`2(Lifetime lifetime, int capacity);
    public StrongToWeakDictionary`2(Lifetime lifetime, IDictionary`2<TKey, TValue> dictionary, IEqualityComparer`1<TKey> comparer);
    public StrongToWeakDictionary`2(Lifetime lifetime, int capacity, IEqualityComparer`1<TKey> comparer);
    private static StrongToWeakDictionary`2();
    public IEqualityComparer`1<TKey> get_Comparer();
    public KeyCollection<TKey, TValue> get_Keys();
    public ValueCollection<TKey, TValue> get_Values();
    public int get_Capacity();
    public void Add(TKey key, TValue value);
    public void Clear();
    public bool ContainsKey(TKey key);
    public bool ContainsValue(TValue value);
    public bool Remove(TKey key);
    public TValue get_Item(TKey key);
    public void set_Item(TKey key, TValue value);
    public bool TryGetValue(TKey key, TValue& value);
    private sealed virtual override IEnumerator`1<KeyValuePair`2<TKey, TValue>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TValue>>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public PairEnumerator<TKey, TValue> GetEnumerator();
    public sealed virtual void Dispose();
    protected virtual override void Finalize();
    private static TValue FixValue(object value);
    private void RemoveEntry(int entryIndex);
    private bool CompareKeyOptionallyRemoveIfDead(TKey key, int entryIndex, TValue& value, bool removeIfDead);
    private int FindEntry(TKey key, TValue& value);
    private void Initialize(int capacity);
    private void Insert(TKey key, TValue value, bool add);
    private void Resize();
    public void Sweep();
}
public class JetBrains.Util.SystemObjectEqualityComparer`1 : object {
    public static SystemObjectEqualityComparer`1<T> Instance;
    private static SystemObjectEqualityComparer`1();
    private sealed virtual override bool System.Collections.IEqualityComparer.Equals(object x, object y);
    private sealed virtual override int System.Collections.IEqualityComparer.GetHashCode(object obj);
    private sealed virtual override bool System.Collections.Generic.IEqualityComparer<T>.Equals(T x, T y);
    private sealed virtual override int System.Collections.Generic.IEqualityComparer<T>.GetHashCode(T obj);
}
public class JetBrains.Util.SystemVSharedMemory : SharedMemory {
    private int myShmKey;
    private int myShmId;
    public long ConfiguredSize { get; }
    private static int Enoent { get; }
    public SystemVSharedMemory(Lifetime lifetime, string uniqueIdentifier, int id, long maxSize);
    public virtual long get_ConfiguredSize();
    protected virtual Byte* MapImpl(long size);
    protected virtual void UnmapImpl();
    protected virtual void DeleteImpl();
    private static int get_Enoent();
    private Nullable`1<long> GetSize();
}
public static class JetBrains.Util.TeamCity.TeamCityDetector : object {
    public static bool IsUnderTeamCity();
}
public class JetBrains.Util.TemporaryDirectoryCookie : object {
    [CompilerGeneratedAttribute]
private FileSystemPath <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <LogExceptionSilentlyOnDispose>k__BackingField;
    public FileSystemPath Path { get; }
    public bool LogExceptionSilentlyOnDispose { get; public set; }
    private TemporaryDirectoryCookie(FileSystemPath path);
    [CompilerGeneratedAttribute]
public sealed virtual FileSystemPath get_Path();
    [CompilerGeneratedAttribute]
public bool get_LogExceptionSilentlyOnDispose();
    [CompilerGeneratedAttribute]
public void set_LogExceptionSilentlyOnDispose(bool value);
    public sealed virtual void Dispose();
    private void Remove();
    public static TemporaryDirectoryCookie CreateFolder(FileSystemPath parentFolder, string prefix);
    [NotNullAttribute]
public static TemporaryDirectoryCookie CreateFolderEx(Lifetime lifetime, FileSystemPath parentFolder, string prefix, bool logExceptionSilentlyOnDispose);
    [NotNullAttribute]
public static FileSystemPath CreateFolder(Lifetime lifetime, FileSystemPath parentFolder, string prefix, bool logExceptionSilentlyOnDispose);
    public static TemporaryDirectoryCookie UseFolder(FileSystemPath folderPath);
    [CompilerGeneratedAttribute]
private object <Remove>b__9_0();
}
public class JetBrains.Util.TestPresentationMap : object {
    [NotNullAttribute]
private ConcurrentDictionary`2<Pair`2<Type, int>, string> myTestPresentations;
    [CanBeNullAttribute]
private static TestPresentationMap modreq(System.Runtime.CompilerServices.IsVolatile) ourInstance;
    [NotNullAttribute]
private static ILogger ourLogger;
    private static int ourRequestCount;
    public static bool Available { get; }
    private static TestPresentationMap();
    public static void Setup();
    public static void Acquire();
    public static void Release();
    public static IDisposable Cookie();
    public static bool get_Available();
    public static void RegisterTestPresentation(T t, string presentation);
    private static string HashToStr(int hash);
    public static string ToString(T t);
}
[ExtensionAttribute]
public static class JetBrains.Util.TextReaderEx : object {
    [ExtensionAttribute]
public static void SkipWhitespace(TextReader stream);
    private static bool IsWhitespace(int ch);
    [ExtensionAttribute]
public static int ReadInt(TextReader stream);
    [ExtensionAttribute]
public static string ReadWord(TextReader stream);
}
[ObsoleteAttribute("Inconsistent treatment of line endings due to TextUtil::ReadToEnd, don't use unless you absolutely wish to kill them.")]
public class JetBrains.Util.TextStreamReader : StreamReader {
    public TextStreamReader(FileSystemPath fileName);
    public TextStreamReader(VirtualFileSystemPath fileName);
    public virtual string ReadToEnd();
}
[ObsoleteAttribute("Inconsistent treatment of line endings due to TextUtil::ReadToEnd, don't use unless you absolutely wish to kill them.")]
public class JetBrains.Util.TextStringReader : StringReader {
    public TextStringReader(string buffer);
    public virtual string ReadToEnd();
}
[ObsoleteAttribute("Inconsistent treatment of line endings, don't use unless you absolutely wish to kill them.")]
public class JetBrains.Util.TextUtil : object {
    [ObsoleteAttribute("Inconsistent treatment of line endings, don't use unless you absolutely wish to kill them.")]
public static string ReadToEnd(TextReader reader);
}
public class JetBrains.Util.TimestampedValue`1 : object {
    private T myValue;
    private DateTime myLastEvaluated;
    private TimeSpan myUpdatePeriod;
    private Func`1<T> myEvaluator;
    public T Value { get; }
    public TimestampedValue`1(Func`1<T> evaluator, TimeSpan updatePeriod);
    public T get_Value();
}
public static class JetBrains.Util.ToolsetInfo : object {
    [NotNullAttribute]
public static string FullFrameworkIdentifier;
    [NotNullAttribute]
public static FrameworkName CurrentDefaultTargetFx;
    private static ToolsetInfo();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.Util.TransactionCommitResult : object {
    [CompilerGeneratedAttribute]
private EnsureWritableResult <EnsureWritableResult>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EnsureWritableMessage>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Successful>k__BackingField;
    public EnsureWritableResult EnsureWritableResult { get; }
    public string EnsureWritableMessage { get; }
    public bool Successful { get; }
    [ObsoleteAttribute("Use 'Succeeded' instead")]
public bool Succeded { get; }
    public TransactionCommitResult(EnsureWritableResult ensureWritableResult, string ensureWritableMessage, bool successful);
    [CompilerGeneratedAttribute]
public EnsureWritableResult get_EnsureWritableResult();
    [CompilerGeneratedAttribute]
public string get_EnsureWritableMessage();
    [CompilerGeneratedAttribute]
public bool get_Successful();
    public bool get_Succeded();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class JetBrains.Util.TraverseUtil : object {
    [IteratorStateMachineAttribute("JetBrains.Util.TraverseUtil/<TraverseAcross>d__0`1")]
[ExtensionAttribute]
public static IEnumerable`1<T> TraverseAcross(T first, Func`2<T, T> next);
    [IteratorStateMachineAttribute("JetBrains.Util.TraverseUtil/<Traverse>d__1`1")]
[ExtensionAttribute]
public static IEnumerable`1<T> Traverse(IEnumerable`1<T> source, Func`2<T, IEnumerable`1<T>> selectChildren);
    [ExtensionAttribute]
public static TAccumulate TraverseAggregate(IEnumerable`1<T> source, Func`2<T, IEnumerable`1<T>> selectChildren, TAccumulate seed, Func`3<TAccumulate, T, TAccumulate> func);
}
public class JetBrains.Util.TypeHierarchyMap`1 : object {
    [NotNullAttribute]
private Dictionary`2<Type, TValue> myElements;
    [NotNullAttribute]
private Dictionary`2<Type, int> myRegistrationOrder;
    private int myLastRegistrationIndex;
    [NotNullAttribute]
private ConcurrentDictionary`2<Type, TValue> myLookupCache;
    [ContractAnnotationAttribute("=> false, value: null; => true")]
[PureAttribute]
public bool TryGetValue(Type type, TValue& value);
    public void Add(Type type, TValue value);
    [ContractAnnotationAttribute("=> false, value: null; => true")]
private bool SlowLookup(Type type, TValue& value);
    [CompilerGeneratedAttribute]
private bool <SlowLookup>g__ShouldReplaceBestType|6_0(Type candidateType, <>c__DisplayClass6_0& );
    [CompilerGeneratedAttribute]
private void <SlowLookup>g__ChooseBestCandidate|6_1(Type candidateType, <>c__DisplayClass6_0& );
}
[ExtensionAttribute]
public static class JetBrains.Util.TypeHierarchyMapExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
[CanBeNullAttribute]
public static TValue TryGetValue(TypeHierarchyMap`1<TValue> map, Type type);
}
[ExtensionAttribute]
public static class JetBrains.Util.UriUtil : object {
    [ExtensionAttribute]
[NotNullAttribute]
public static Uri ToDirectoryUri(Uri uri);
    [ExtensionAttribute]
public static bool IsHttp(Uri uri);
    [ExtensionAttribute]
public static bool IsHttps(Uri uri);
    [ExtensionAttribute]
public static bool IsHttpOrHttps(Uri uri);
    [ExtensionAttribute]
[NotNullAttribute]
public static Uri WithCacheRedirector(Uri uri);
}
public static class JetBrains.Util.UrlUtil : object {
    public static string Encode(string s, Encoding encoding);
    public static bool IsUnsafe(byte b);
    public static string Decode(string s, Encoding encoding);
    [CompilerGeneratedAttribute]
internal static void <Decode>g__AppendEncodedBytes|2_0(<>c__DisplayClass2_0& );
}
public static class JetBrains.Util.Uuid : object {
    public static Guid NewUuid(Guid namespaceGuid, string value);
}
[PublicAPIAttribute]
[ValueSerializerAttribute("JetBrains.Util.Version2/Version2Serializer")]
[TypeConverterAttribute("JetBrains.Util.Version2/Version2Converter")]
public class JetBrains.Util.Version2 : object {
    private UInt32 major;
    private UInt32 minor;
    public UInt32 Major { get; }
    public UInt32 Minor { get; }
    public Version2(UInt32 nMajor, UInt32 nMinor);
    public Version2(Version version4);
    public UInt32 get_Major();
    public UInt32 get_Minor();
    public sealed virtual object Clone();
    public sealed virtual int CompareTo(Version2 value);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Version2 other);
    public virtual int GetHashCode();
    public sealed virtual int CompareTo(object obj);
    public static bool op_Equality(Version2 v1, Version2 v2);
    [ContractAnnotationAttribute("ver2:null => null; notnull => notnull")]
public static Version op_Explicit(Version2 ver2);
    [ContractAnnotationAttribute("ver:null => null; notnull => notnull")]
public static Version2 op_Explicit(Version ver);
    public static bool op_GreaterThan(Version2 v1, Version2 v2);
    public static bool op_GreaterThanOrEqual(Version2 v1, Version2 v2);
    public static bool op_Inequality(Version2 v1, Version2 v2);
    public static bool op_LessThan(Version2 v1, Version2 v2);
    public static bool op_LessThanOrEqual(Version2 v1, Version2 v2);
    public static Version2 Parse(string s);
    public virtual string ToString();
    [NotNullAttribute]
public Version ToVersion4WithMinusOnes();
    [NotNullAttribute]
public Version ToVersion4WithZeros();
    [CanBeNullAttribute]
public static Version2 TryParse(string s);
}
[ExtensionAttribute]
public static class JetBrains.Util.VersionExtensions : object {
    public static Version Empty;
    public static Version2 Empty2;
    private static VersionExtensions();
    [ExtensionAttribute]
public static bool IsNullOrEmpty(Version version);
    [ExtensionAttribute]
public static bool IsNullOrEmpty(Version2 version);
    [CanBeNullAttribute]
public static Version TryParseVersion(string str);
    [CanBeNullAttribute]
public static Version2 TryParseVersion2(string str);
    [ExtensionAttribute]
public static Version Clone(Version version, int fieldCount);
    [ExtensionAttribute]
public static string ToStringWithNoZerosForBuildAndRevision(Version version);
    [ExtensionAttribute]
public static Version ToVersionWithNoZeroesForBuildAndRevision(Version version);
    [ExtensionAttribute]
public static Version ToVersionWithZeroesForBuildAndRevision(Version version);
    [NotNullAttribute]
public static Version MakeDateTimeVersion(Version2 ver2, Nullable`1<DateTime> datetime);
    [NotNullAttribute]
public static Version MakeDateTimeVersionRough(Version2 ver2, DateTime datetime, TimeSpan roughness);
}
public class JetBrains.Util.WaveInfo : object {
    private static UInt32 CurrentWaveTechnicalNumber;
    public static string PackageName;
    public static WaveInfo Current;
    public UInt32 Number;
    public WaveInfo(UInt32 number);
    private static WaveInfo();
    public Version2 AsVersion2();
    public Version AsVersion4();
    public JetSemanticVersion AsVersionSemantic();
    public virtual string ToString();
}
[ExtensionAttribute]
public static class JetBrains.Util.WaveInfoEx : object {
    public static UInt32 MajorVersionFixed;
    private static WaveInfoEx();
    [ExtensionAttribute]
[NotNullAttribute]
public static Version2 GetDefaultAssemblyVersion(WaveInfo thіs);
    [ExtensionAttribute]
[NotNullAttribute]
public static Version2 GetDefaultSubplatformVersion(WaveInfo thіs);
}
public class JetBrains.Util.WeakCollection`1 : object {
    private static Statistics Statistics;
    private WeakHolder`1[] myArray;
    private int myFirstFreeIndex;
    private int myNextSize;
    private int myVersion;
    public int Capacity { get; }
    public bool IsEmpty { get; }
    [ObsoleteAttribute("Use an overload with lifetime.")]
public WeakCollection`1(ICollection`1<T> collection);
    public WeakCollection`1(Lifetime lifetime);
    public WeakCollection`1(Lifetime lifetime, ICollection`1<T> collection);
    private static WeakCollection`1();
    public int get_Capacity();
    public bool get_IsEmpty();
    public int CountLive();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    public ElementEnumerator<T> GetEnumerator();
    public void Add(T item);
    public bool Remove(T item);
    public bool Contains(T item);
    public T[] ToArray();
    public List`1<T> ToList();
    public void CopyTo(T[] array, int arrayIndex);
    public void Clear();
    public sealed virtual void Dispose();
    protected virtual override void Finalize();
    public T First();
    public T First(Func`2<T, bool> predicate);
    public T Last();
    public T Last(Func`2<T, bool> predicate);
    private void SweepCore();
    public void Sweep();
}
public class JetBrains.Util.WeakHashSet`1 : object {
    private static Statistics Statistics;
    private IEqualityComparer`1<T> myComparer;
    private Entry[] myEntries;
    private int myEntriesUsed;
    private int myFirstFreeIndex;
    private int myFreeCount;
    private Int32[] myHashToEntryIndex;
    private int myVersion;
    public IEqualityComparer`1<T> Comparer { get; }
    public int Capacity { get; }
    public WeakHashSet`1(IEnumerable`1<T> enumerable);
    public WeakHashSet`1(IEqualityComparer`1<T> comparer);
    public WeakHashSet`1(int capacity);
    public WeakHashSet`1(IEnumerable`1<T> enumerable, IEqualityComparer`1<T> comparer);
    [EditorBrowsableAttribute("1")]
public WeakHashSet`1(ICollection`1<T> enumerable, IEqualityComparer`1<T> comparer);
    public WeakHashSet`1(int capacity, IEqualityComparer`1<T> comparer);
    private static WeakHashSet`1();
    public IEqualityComparer`1<T> get_Comparer();
    public int get_Capacity();
    public ElementEnumerator<T> GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public bool Add(T key);
    public bool Remove(T key);
    public void Clear();
    public bool Contains(T key);
    [CanBeNullAttribute]
public T TryGetExisting(T key);
    public void Sweep();
    public sealed virtual void Dispose();
    protected virtual override void Finalize();
    private void RemoveEntry(int entryIndex);
    private bool CompareKeyRemoveIfDead(T key, int entryIndex);
    private int FindEntry(T key);
    private void Initialize(int capacity);
    private void Resize();
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Util.WeakToStrongDictionary`2 : object {
    private static Statistics Statistics;
    private IEqualityComparer`1<TKey> myComparer;
    private Entry[] myEntries;
    private int myEntriesUsed;
    private int myFirstFreeIndex;
    private int myFreeCount;
    private Int32[] myHashToEntryIndex;
    private KeyCollection<TKey, TValue> myKeys;
    private ValueCollection<TKey, TValue> myValues;
    private int myVersion;
    public IEqualityComparer`1<TKey> Comparer { get; }
    public KeyCollection<TKey, TValue> Keys { get; }
    [NotNullAttribute]
public ValueCollection<TKey, TValue> Values { get; }
    public int Capacity { get; }
    public TValue Item { get; public set; }
    public WeakToStrongDictionary`2(IDictionary`2<TKey, TValue> dictionary);
    public WeakToStrongDictionary`2(IEqualityComparer`1<TKey> comparer);
    public WeakToStrongDictionary`2(int capacity);
    public WeakToStrongDictionary`2(IDictionary`2<TKey, TValue> dictionary, IEqualityComparer`1<TKey> comparer);
    public WeakToStrongDictionary`2(int capacity, IEqualityComparer`1<TKey> comparer);
    private static WeakToStrongDictionary`2();
    public IEqualityComparer`1<TKey> get_Comparer();
    public KeyCollection<TKey, TValue> get_Keys();
    public ValueCollection<TKey, TValue> get_Values();
    public int get_Capacity();
    public void Add(TKey key, TValue value);
    public bool Remove(TKey key);
    public void Clear();
    public bool ContainsKey(TKey key);
    public bool ContainsValue(TValue value);
    public TValue get_Item(TKey key);
    public void set_Item(TKey key, TValue value);
    public bool TryGetValue(TKey key, TValue& value);
    public void Sweep();
    public sealed virtual void Dispose();
    private sealed virtual override IEnumerator`1<KeyValuePair`2<TKey, TValue>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TValue>>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public PairEnumerator<TKey, TValue> GetEnumerator();
    protected virtual override void Finalize();
    private void RemoveEntry(int entryIndex);
    private bool CompareKeyRemoveIfDead(TKey key, int entryIndex);
    private int FindEntry(TKey key);
    private void Initialize(int capacity);
    private void Insert(TKey key, TValue value, bool add);
    private void Resize();
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Util.WeakToWeakDictionary`2 : object {
    private static Statistics Statistics;
    private static object NullObject;
    private IEqualityComparer`1<TKey> myComparer;
    private Entry[] myEntries;
    private int myEntriesUsed;
    private int myFirstFreeIndex;
    private int myFreeCount;
    private Int32[] myHashToEntryIndex;
    private KeyCollection<TKey, TValue> myKeys;
    private ValueCollection<TKey, TValue> myValues;
    private int myVersion;
    public IEqualityComparer`1<TKey> Comparer { get; }
    public KeyCollection<TKey, TValue> Keys { get; }
    public ValueCollection<TKey, TValue> Values { get; }
    public int Capacity { get; }
    public TValue Item { get; public set; }
    public WeakToWeakDictionary`2(IDictionary`2<TKey, TValue> dictionary);
    public WeakToWeakDictionary`2(IEqualityComparer`1<TKey> comparer);
    public WeakToWeakDictionary`2(int capacity);
    public WeakToWeakDictionary`2(IDictionary`2<TKey, TValue> dictionary, IEqualityComparer`1<TKey> comparer);
    public WeakToWeakDictionary`2(int capacity, IEqualityComparer`1<TKey> comparer);
    private static WeakToWeakDictionary`2();
    public IEqualityComparer`1<TKey> get_Comparer();
    public KeyCollection<TKey, TValue> get_Keys();
    public ValueCollection<TKey, TValue> get_Values();
    public int get_Capacity();
    public void Add(TKey key, TValue value);
    public void Clear();
    public bool ContainsKey(TKey key);
    public bool ContainsValue(TValue value);
    public bool Remove(TKey key);
    public TValue get_Item(TKey key);
    public void set_Item(TKey key, TValue value);
    public bool TryGetValue(TKey key, TValue& value);
    private sealed virtual override IEnumerator`1<KeyValuePair`2<TKey, TValue>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TValue>>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public PairEnumerator<TKey, TValue> GetEnumerator();
    public sealed virtual void Dispose();
    protected virtual override void Finalize();
    private static TValue FixValue(object value);
    private void RemoveEntry(int entryIndex);
    private bool CompareKeyOptionallyRemoveIfDead(TKey key, int entryIndex, bool removeIfDead, TValue& value);
    private int FindEntry(TKey key, TValue& value);
    private void Initialize(int capacity);
    private void Insert(TKey key, TValue value, bool add);
    private void Resize();
    public void Sweep();
}
public static class JetBrains.Util.WindowsExplorer : object {
    private static ILogger ourLog;
    private static WindowsExplorer();
    public static void SelectItem(FileSystemPath path);
    public static void SelectItem(VirtualFileSystemPath path);
    public static void SelectItems(FileSystemPath directory, IEnumerable`1<FileSystemPath> items);
    public static void OpenFolder(VirtualFileSystemPath directory);
    public static void OpenFolder(FileSystemPath directory);
    private static void OpenExplorer();
    public static void OpenOrSelect(FileSystemPath path);
    [CanBeNullAttribute]
private static FileSystemPath FindNearestDirectory(FileSystemPath path);
}
public enum JetBrains.Util.WindowsServiceMode : Enum {
    public int value__;
    public static WindowsServiceMode Own;
    public static WindowsServiceMode Share;
    public static WindowsServiceMode SvcHost;
}
public static class JetBrains.Util.WindowsSettingsChecker : object {
    public static bool IsStrongNameValidationEnabled();
}
public class JetBrains.Util.XMath.BigInteger : object {
    public static BigInteger Zero;
    private static int maxLength;
    public static Int32[] primesBelow100000;
    private UInt32[] data;
    public int dataLength;
    public BigInteger(long value);
    public BigInteger(ulong value);
    public BigInteger(BigInteger bi);
    public BigInteger(string value, int radix);
    public BigInteger(Byte[] inData);
    public BigInteger(Byte[] inData, int inLen);
    public BigInteger(UInt32[] inData);
    private static BigInteger();
    public static BigInteger op_Implicit(long value);
    public static BigInteger op_Implicit(ulong value);
    public static BigInteger op_Implicit(int value);
    public static BigInteger op_Implicit(UInt32 value);
    public static BigInteger op_Addition(BigInteger bi1, BigInteger bi2);
    public static BigInteger op_Increment(BigInteger bi1);
    public static BigInteger op_Subtraction(BigInteger bi1, BigInteger bi2);
    public static BigInteger op_Decrement(BigInteger bi1);
    public static BigInteger op_Multiply(BigInteger bi1, BigInteger bi2);
    public static BigInteger op_LeftShift(BigInteger bi1, int shiftVal);
    private static int shiftLeft(UInt32[] buffer, int shiftVal);
    public static BigInteger op_RightShift(BigInteger bi1, int shiftVal);
    private static int shiftRight(UInt32[] buffer, int shiftVal);
    public static BigInteger op_OnesComplement(BigInteger bi1);
    public static BigInteger op_UnaryNegation(BigInteger bi1);
    public static bool op_Equality(BigInteger bi1, BigInteger bi2);
    public static bool op_Inequality(BigInteger bi1, BigInteger bi2);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public static bool op_GreaterThan(BigInteger bi1, BigInteger bi2);
    public static bool op_LessThan(BigInteger bi1, BigInteger bi2);
    public static bool op_GreaterThanOrEqual(BigInteger bi1, BigInteger bi2);
    public static bool op_LessThanOrEqual(BigInteger bi1, BigInteger bi2);
    private static void multiByteDivide(BigInteger bi1, BigInteger bi2, BigInteger outQuotient, BigInteger outRemainder);
    private static void singleByteDivide(BigInteger bi1, BigInteger bi2, BigInteger outQuotient, BigInteger outRemainder);
    public static BigInteger op_Division(BigInteger bi1, BigInteger bi2);
    public static BigInteger op_Modulus(BigInteger bi1, BigInteger bi2);
    public static BigInteger op_BitwiseAnd(BigInteger bi1, BigInteger bi2);
    public static BigInteger op_BitwiseOr(BigInteger bi1, BigInteger bi2);
    public static BigInteger op_ExclusiveOr(BigInteger bi1, BigInteger bi2);
    public BigInteger max(BigInteger bi);
    public BigInteger min(BigInteger bi);
    public BigInteger abs();
    public virtual string ToString();
    public string ToString(int radix);
    public string ToHexString();
    public BigInteger modPow(BigInteger exp, BigInteger n);
    private BigInteger BarrettReduction(BigInteger x, BigInteger n, BigInteger constant);
    public BigInteger gcd(BigInteger bi);
    public void genRandomBits(int bits, Random rand);
    public int bitCount();
    public bool FermatLittleTest(int confidence);
    public bool RabinMillerTest(int confidence);
    public bool SolovayStrassenTest(int confidence);
    public bool LucasStrongTest();
    private bool LucasStrongTestHelper(BigInteger thisVal);
    public bool isProbablePrime(int confidence);
    public bool isProbablePrime();
    public static bool IsDivisibleByFirstPrimes(BigInteger thisVal);
    public int IntValue();
    public long LongValue();
    public static int Jacobi(BigInteger a, BigInteger b);
    public static BigInteger genPseudoPrime(int bits, int confidence, Random rand);
    public BigInteger genCoPrime(int bits, Random rand);
    public BigInteger modInverse(BigInteger modulus);
    public Byte[] getBytes();
    public void setBit(UInt32 bitNum);
    public void unsetBit(UInt32 bitNum);
    public BigInteger sqrt();
    public static BigInteger[] LucasSequence(BigInteger P, BigInteger Q, BigInteger k, BigInteger n);
    private static BigInteger[] LucasSequenceHelper(BigInteger P, BigInteger Q, BigInteger k, BigInteger n, BigInteger constant, int s);
    public static void MulDivTest(int rounds);
    public static void RSATest(int rounds);
    public static void RSATest2(int rounds);
    public static void SqrtTest(int rounds);
}
public static class JetBrains.Util.XMath.StringToBytesConverter : object {
    public static Byte[] Unicode(string s);
    public static Byte[] Utf8(string s);
    public static Byte[] Ascii(string s);
    public static Byte[] Old(string s);
}
[ExtensionAttribute]
public static class JetBrains.Util.XmlEscape : object {
    [CanBeNullAttribute]
[PureAttribute]
private static string EscapeChar(char c);
    [NotNullAttribute]
[PureAttribute]
public static string AttributeValue(string value, char quotes);
    [NotNullAttribute]
[PureAttribute]
public static string Content(string value);
    [NotNullAttribute]
[PureAttribute]
public static string MarkupExtensionAttributeValue(string value, bool wrapInQuotes);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static StringBuilder AppendXmlAttributeValue(StringBuilder builder, string value);
}
[ExtensionAttribute]
public static class JetBrains.Util.XmlReaderEx : object {
    [ExtensionAttribute]
public static void AssertAtElement(XmlReader reader, string sElementName);
    [ExtensionAttribute]
public static void AssertAtElement(XmlReader reader, string sElementName, string sNamespaceUri);
    [ExtensionAttribute]
public static void KeepDepth(XmlReader reader, Action action);
    [ExtensionAttribute]
public static void KeepParentDepth(XmlReader reader, Action action);
    [ExtensionAttribute]
public static void ReadElement(XmlReader reader, Action`1<XmlReader> funcElem);
    [ExtensionAttribute]
public static void ReadElementChildren(XmlReader reader, Action`1<XmlReader> funcChild);
    [ExtensionAttribute]
public static void ReadSiblingElements(XmlReader reader, Action`1<XmlReader> funcElem);
    [ExtensionAttribute]
public static void ReadSubElements(XmlReader reader, Action`1<XmlReader> action);
    [ExtensionAttribute]
public static bool ReadToElementStart(XmlReader reader);
    [ExtensionAttribute]
public static bool ReadToElementStart(XmlReader reader, int depth);
    private static void KeepReaderDepthCore(XmlReader reader, Action action, int depth);
    [ExtensionAttribute]
public static void ReadXml(Stream stream, Action`1<XmlReader> FRead);
    [ExtensionAttribute]
public static TResult ReadXml(Stream stream, Func`2<XmlReader, TResult> FRead);
    [ExtensionAttribute]
public static void ReadXml(Stream stream, XmlReaderSettings settings, Action`1<XmlReader> FRead);
    [ExtensionAttribute]
public static TResult ReadXml(Stream stream, XmlReaderSettings settings, Func`2<XmlReader, TResult> FRead);
    [ExtensionAttribute]
public static void AddLineColumnData(IXmlLineInfo thіs, Exception ex);
    [ExtensionAttribute]
public static void AddLineColumnData(XmlReader thіs, Exception ex);
}
public static class JetBrains.Util.XmlUnescape : object {
    [PureAttribute]
private static char UnescapeChar(string str, int index, Int32& length);
    [NotNullAttribute]
[PureAttribute]
public static string Value(string value);
    [NotNullAttribute]
[PureAttribute]
public static string MarkupExtensionValue(string value);
}
internal class Microsoft.Build.Shared.DirectoryExists : MulticastDelegate {
    public DirectoryExists(object object, IntPtr method);
    public virtual bool Invoke(string path);
    public virtual IAsyncResult BeginInvoke(string path, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
internal static class Microsoft.Build.Shared.ErrorUtilities : object {
    public static void VerifyThrow(bool b, string fmt, Object[] args);
}
internal static class Microsoft.Build.Shared.ExceptionHandling : object {
    public static bool IsIoRelatedException(Exception exception);
}
public static class Microsoft.Build.Shared.FileMatcher : object {
    private static string recursiveDirectoryMatch;
    private static string dotdot;
    private static string s_directorySeparator;
    private static string s_altDirectorySeparator;
    private static Char[] s_wildcardCharacters;
    private static Char[] s_wildcardAndSemicolonCharacters;
    internal static Char[] directorySeparatorCharacters;
    private static GetFileSystemEntries s_defaultGetFileSystemEntries;
    private static DirectoryExists s_defaultDirectoryExists;
    private static Char[] s_invalidPathChars;
    public static Char[] WildcardCharacters { get; }
    private static FileMatcher();
    public static Char[] get_WildcardCharacters();
    public static bool HasWildcards(string filespec);
    public static bool HasWildcardsOrSemicolon(string filespec);
    public static bool HasWildcardsOrSemicolon(StringSlice filespec);
    internal static bool HasWildcardsSemicolonItemOrPropertyReferences(string filespec);
    private static String[] GetAccessibleFileSystemEntries(FileSystemEntity entityType, string path, string pattern, string projectDirectory, bool stripProjectDirectory);
    private static String[] GetAccessibleFilesAndDirectories(string path, string pattern);
    private static String[] GetAccessibleFiles(string path, string filespec, string projectDirectory, bool stripProjectDirectory);
    private static String[] GetAccessibleDirectories(string path, string pattern);
    internal static string GetLongPathName(string path);
    internal static string GetLongPathName(string path, GetFileSystemEntries getFileSystemEntries);
    internal static void SplitFileSpec(string filespec, String& fixedDirectoryPart, String& wildcardDirectoryPart, String& filenamePart, GetFileSystemEntries getFileSystemEntries);
    private static void PreprocessFileSpecForSplitting(string filespec, String& fixedDirectoryPart, String& wildcardDirectoryPart, String& filenamePart);
    private static void RemoveInitialDotSlash(String[] paths);
    internal static bool IsDirectorySeparator(char c);
    internal static void RemoveProjectDirectory(String[] paths, string projectDirectory);
    private static void GetFilesRecursive(IList listOfFiles, string baseDirectory, string remainingWildcardDirectory, string filespec, int extensionLengthToEnforce, Regex regexFileMatch, bool needsRecursion, string projectDirectory, bool stripProjectDirectory, bool doReturnFolders, GetFileSystemEntries getFileSystemEntries);
    private static string RegularExpressionFromFileSpec(string fixedDirectoryPart, string wildcardDirectoryPart, string filenamePart, Boolean& isLegalFileSpec);
    internal static void GetFileSpecInfo(string filespec, Regex& regexFileMatch, Boolean& needsRecursion, Boolean& isLegalFileSpec, GetFileSystemEntries getFileSystemEntries);
    private static void GetFileSpecInfo(string filespec, String& fixedDirectoryPart, String& wildcardDirectoryPart, String& filenamePart, String& matchFileExpression, Boolean& needsRecursion, Boolean& isLegalFileSpec, GetFileSystemEntries getFileSystemEntries);
    internal static Result FileMatch(string filespec, string fileToMatch);
    public static String[] GetFiles(FileMatcherInputString projectDirectoryUnescaped, FileMatcherInputString filespecUnescaped, bool doReturnFolders, IInteractionContext interactionContext);
    [ObsoleteAttribute("Use the overload with FileMatchedInputString")]
public static String[] GetFiles(string projectDirectoryUnescaped, string filespecUnescaped, bool doReturnFolders);
    internal static String[] GetFiles(string projectDirectoryUnescaped, string filespecUnescaped, GetFileSystemEntries getFileSystemEntries, DirectoryExists directoryExists, bool doReturnFolders);
}
public class Microsoft.Build.Shared.FileMatcherInputString : ValueType {
    private string myRawString;
    public FileMatcherInputString(string rawString);
    public string GetRawString();
    public string GetNormalizedString(IInteractionContext interactionContext);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[GuidAttribute("6380BCFF-41D3-4B2E-8B2E-BF8A6810C848")]
[InterfaceTypeAttribute("1")]
[NoReorderAttribute]
internal interface Microsoft.VisualStudio.Setup.Configuration.IEnumSetupInstances {
    public abstract virtual void Next(int celt, ISetupInstance[] rgelt, Int32& pceltFetched);
    public abstract virtual void Skip(int celt);
    public abstract virtual void Reset();
    public abstract virtual IEnumSetupInstances Clone();
}
[FlagsAttribute]
[NoReorderAttribute]
internal enum Microsoft.VisualStudio.Setup.Configuration.InstanceState : Enum {
    public UInt32 value__;
    public static InstanceState None;
    public static InstanceState Local;
    public static InstanceState Registered;
    public static InstanceState NoRebootRequired;
    public static InstanceState NoErrors;
    public static InstanceState Complete;
}
[GuidAttribute("42843719-DB4C-46C2-8E7C-64F1816EFD5B")]
[InterfaceTypeAttribute("1")]
[NoReorderAttribute]
internal interface Microsoft.VisualStudio.Setup.Configuration.ISetupConfiguration {
    public abstract virtual IEnumSetupInstances EnumInstances();
    public abstract virtual ISetupInstance GetInstanceForCurrentProcess();
    public abstract virtual ISetupInstance GetInstanceForPath(string path);
}
[GuidAttribute("26AAB78C-4A60-49D6-AF3B-3C35BC93365D")]
[InterfaceTypeAttribute("1")]
[NoReorderAttribute]
internal interface Microsoft.VisualStudio.Setup.Configuration.ISetupConfiguration2 {
    public abstract virtual IEnumSetupInstances EnumInstances();
    public abstract virtual ISetupInstance GetInstanceForCurrentProcess();
    public abstract virtual ISetupInstance GetInstanceForPath(string path);
    public abstract virtual IEnumSetupInstances EnumAllInstances();
}
[GuidAttribute("46DCCD94-A287-476A-851E-DFBC2FFDBC20")]
[InterfaceTypeAttribute("1")]
[NoReorderAttribute]
internal interface Microsoft.VisualStudio.Setup.Configuration.ISetupErrorState {
    public abstract virtual ISetupFailedPackageReference[] GetFailedPackages();
    public abstract virtual ISetupPackageReference[] GetSkippedPackages();
}
[GuidAttribute("E73559CD-7003-4022-B134-27DC650B280F")]
[InterfaceTypeAttribute("1")]
[NoReorderAttribute]
internal interface Microsoft.VisualStudio.Setup.Configuration.ISetupFailedPackageReference {
    public abstract virtual string GetId();
    public abstract virtual string GetVersion();
    public abstract virtual string GetChip();
    public abstract virtual string GetLanguage();
    public abstract virtual string GetBranch();
    public abstract virtual string GetType();
    public abstract virtual string GetUniqueId();
    public abstract virtual bool GetIsExtension();
}
[GuidAttribute("42B21B78-6192-463E-87BF-D577838F1D5C")]
[InterfaceTypeAttribute("1")]
[NoReorderAttribute]
internal interface Microsoft.VisualStudio.Setup.Configuration.ISetupHelper {
    public abstract virtual ulong ParseVersion(string version);
    public abstract virtual void ParseVersionRange(string versionRange, UInt64& minVersion, UInt64& maxVersion);
}
[GuidAttribute("B41463C3-8866-43B5-BC33-2B0676F7F42E")]
[InterfaceTypeAttribute("1")]
[NoReorderAttribute]
internal interface Microsoft.VisualStudio.Setup.Configuration.ISetupInstance {
    public abstract virtual string GetInstanceId();
    public abstract virtual FILETIME GetInstallDate();
    public abstract virtual string GetInstallationName();
    public abstract virtual string GetInstallationPath();
    public abstract virtual string GetInstallationVersion();
    public abstract virtual string GetDisplayName(int lcid);
    public abstract virtual string GetDescription(int lcid);
    public abstract virtual string ResolvePath(string pwszRelativePath);
}
[GuidAttribute("89143C9A-05AF-49B0-B717-72E218A2185C")]
[InterfaceTypeAttribute("1")]
[NoReorderAttribute]
internal interface Microsoft.VisualStudio.Setup.Configuration.ISetupInstance2 {
    public abstract virtual string GetInstanceId();
    public abstract virtual FILETIME GetInstallDate();
    public abstract virtual string GetInstallationName();
    public abstract virtual string GetInstallationPath();
    public abstract virtual string GetInstallationVersion();
    public abstract virtual string GetDisplayName(int lcid);
    public abstract virtual string GetDescription(int lcid);
    public abstract virtual string ResolvePath(string pwszRelativePath);
    public abstract virtual InstanceState GetState();
    public abstract virtual ISetupPackageReference[] GetPackages();
    public abstract virtual ISetupPackageReference GetProduct();
    public abstract virtual string GetProductPath();
    public abstract virtual ISetupErrorState GetErrors();
    public abstract virtual bool IsLaunchable();
    public abstract virtual bool IsComplete();
    public abstract virtual ISetupPropertyStore GetProperties();
    public abstract virtual string GetEnginePath();
}
[GuidAttribute("9AD8E40F-39A2-40F1-BF64-0A6C50DD9EEB")]
[InterfaceTypeAttribute("1")]
[NoReorderAttribute]
internal interface Microsoft.VisualStudio.Setup.Configuration.ISetupInstanceCatalog {
    public abstract virtual ISetupPropertyStore GetCatalogInfo();
    public abstract virtual bool IsPrerelease();
}
[GuidAttribute("DA8D8A16-B2B6-4487-A2F1-594CCCCD6BF5")]
[InterfaceTypeAttribute("1")]
[NoReorderAttribute]
internal interface Microsoft.VisualStudio.Setup.Configuration.ISetupPackageReference {
    public abstract virtual string GetId();
    public abstract virtual string GetVersion();
    public abstract virtual string GetChip();
    public abstract virtual string GetLanguage();
    public abstract virtual string GetBranch();
    public abstract virtual string GetType();
    public abstract virtual string GetUniqueId();
    public abstract virtual bool GetIsExtension();
}
[GuidAttribute("c601c175-a3be-44bc-91f6-4568d230fc83")]
[InterfaceTypeAttribute("1")]
[NoReorderAttribute]
internal interface Microsoft.VisualStudio.Setup.Configuration.ISetupPropertyStore {
    public abstract virtual String[] GetNames();
    public abstract virtual object GetValue(string pwszName);
}
[GuidAttribute("42843719-DB4C-46C2-8E7C-64F1816EFD5B")]
[CoClassAttribute("Microsoft.VisualStudio.Setup.Configuration.SetupConfigurationClass")]
[TypeLibImportClassAttribute("Microsoft.VisualStudio.Setup.Configuration.SetupConfigurationClass")]
[NoReorderAttribute]
internal interface Microsoft.VisualStudio.Setup.Configuration.SetupConfiguration {
}
[GuidAttribute("177F0C4A-1CD3-4DE7-A32C-71DBBB9FA36D")]
[ClassInterfaceAttribute("0")]
[NoReorderAttribute]
internal class Microsoft.VisualStudio.Setup.Configuration.SetupConfigurationClass : object {
}
public static class MimeTypes.MimeTypeMap : object {
    private static Lazy`1<IDictionary`2<string, string>> _mappings;
    private static MimeTypeMap();
    private static IDictionary`2<string, string> BuildMappings();
    [CanBeNullAttribute]
public static string GetMimeType(string extension);
    public static string GetExtension(string mimeType);
}
[FlagsAttribute]
public enum System.GAC.ASM_CACHE_FLAGS : Enum {
    public int value__;
    public static ASM_CACHE_FLAGS ASM_CACHE_ZAP;
    public static ASM_CACHE_FLAGS ASM_CACHE_GAC;
    public static ASM_CACHE_FLAGS ASM_CACHE_DOWNLOAD;
}
[FlagsAttribute]
public enum System.GAC.ASM_CMP_FLAGS : Enum {
    public int value__;
    public static ASM_CMP_FLAGS NAME;
    public static ASM_CMP_FLAGS MAJOR_VERSION;
    public static ASM_CMP_FLAGS MINOR_VERSION;
    public static ASM_CMP_FLAGS BUILD_NUMBER;
    public static ASM_CMP_FLAGS REVISION_NUMBER;
    public static ASM_CMP_FLAGS PUBLIC_KEY_TOKEN;
    public static ASM_CMP_FLAGS CULTURE;
    public static ASM_CMP_FLAGS CUSTOM;
    public static ASM_CMP_FLAGS ALL;
    public static ASM_CMP_FLAGS DEFAULT;
}
[FlagsAttribute]
public enum System.GAC.ASM_DISPLAY_FLAGS : Enum {
    public int value__;
    public static ASM_DISPLAY_FLAGS VERSION;
    public static ASM_DISPLAY_FLAGS CULTURE;
    public static ASM_DISPLAY_FLAGS PUBLIC_KEY_TOKEN;
    public static ASM_DISPLAY_FLAGS PUBLIC_KEY;
    public static ASM_DISPLAY_FLAGS CUSTOM;
    public static ASM_DISPLAY_FLAGS PROCESSORARCHITECTURE;
    public static ASM_DISPLAY_FLAGS LANGUAGEID;
}
public enum System.GAC.ASM_NAME : Enum {
    public int value__;
    public static ASM_NAME ASM_NAME_PUBLIC_KEY;
    public static ASM_NAME ASM_NAME_PUBLIC_KEY_TOKEN;
    public static ASM_NAME ASM_NAME_HASH_VALUE;
    public static ASM_NAME ASM_NAME_NAME;
    public static ASM_NAME ASM_NAME_MAJOR_VERSION;
    public static ASM_NAME ASM_NAME_MINOR_VERSION;
    public static ASM_NAME ASM_NAME_BUILD_NUMBER;
    public static ASM_NAME ASM_NAME_REVISION_NUMBER;
    public static ASM_NAME ASM_NAME_CULTURE;
    public static ASM_NAME ASM_NAME_PROCESSOR_ID_ARRAY;
    public static ASM_NAME ASM_NAME_OSINFO_ARRAY;
    public static ASM_NAME ASM_NAME_HASH_ALGID;
    public static ASM_NAME ASM_NAME_ALIAS;
    public static ASM_NAME ASM_NAME_CODEBASE_URL;
    public static ASM_NAME ASM_NAME_CODEBASE_LASTMOD;
    public static ASM_NAME ASM_NAME_NULL_PUBLIC_KEY;
    public static ASM_NAME ASM_NAME_NULL_PUBLIC_KEY_TOKEN;
    public static ASM_NAME ASM_NAME_CUSTOM;
    public static ASM_NAME ASM_NAME_NULL_CUSTOM;
    public static ASM_NAME ASM_NAME_MVID;
    public static ASM_NAME ASM_NAME_MAX_PARAMS;
}
public class System.GAC.ASSEMBLY_INFO : ValueType {
    public UInt32 cbAssemblyInfo;
    public UInt32 dwAssemblyFlags;
    public ulong uliAssemblySizeInKB;
    public string pszCurrentAssemblyPathBuf;
    public UInt32 cchBuf;
}
public class System.GAC.AssemblyCache : object {
    public static Guid FUSION_REFCOUNT_UNINSTALL_SUBKEY_GUID { get; }
    public static Guid FUSION_REFCOUNT_FILEPATH_GUID { get; }
    public static Guid FUSION_REFCOUNT_OPAQUE_STRING_GUID { get; }
    public static Guid FUSION_REFCOUNT_MSI_GUID { get; }
    private static void CreateAssemblyCache(IAssemblyCache& ppAsmCache, UInt32 dwReserved);
    private static void CreateAssemblyNameObject(IAssemblyName& ppAssemblyNameObj, string szAssemblyName, UInt32 dwFlags, IntPtr pvReserved);
    private static void CreateAssemblyEnum(IAssemblyEnum& pEnum, IntPtr pUnkReserved, IAssemblyName pName, ASM_CACHE_FLAGS dwFlags, IntPtr pvReserved);
    private static void CreateInstallReferenceEnum(IInstallReferenceEnum& ppRefEnum, IAssemblyName pName, UInt32 dwFlags, IntPtr pvReserved);
    private static void GetCachePath(ASM_CACHE_FLAGS dwCacheFlags, StringBuilder pwzCachePath, UInt32& pcchPath);
    public static Guid get_FUSION_REFCOUNT_UNINSTALL_SUBKEY_GUID();
    public static Guid get_FUSION_REFCOUNT_FILEPATH_GUID();
    public static Guid get_FUSION_REFCOUNT_OPAQUE_STRING_GUID();
    public static Guid get_FUSION_REFCOUNT_MSI_GUID();
    public static IAssemblyCache CreateAssemblyCache();
    public static IAssemblyName CreateAssemblyName(string name);
    public static string GetDisplayName(IAssemblyName name, ASM_DISPLAY_FLAGS which);
    public static string GetName(IAssemblyName name);
    public static Version GetVersion(IAssemblyName name);
    public static Byte[] GetPublicKeyToken(IAssemblyName name);
    public static Byte[] GetPublicKey(IAssemblyName name);
    public static CultureInfo GetCulture(IAssemblyName name);
    public static IAssemblyEnum CreateGACEnum();
    public static int GetNextAssembly(IAssemblyEnum enumerator, IAssemblyName& name);
    public static string GetGACPath();
    public static string GetZapPath();
    public static string GetDownloadPath();
}
public enum System.GAC.CREATE_ASM_NAME_OBJ_FLAGS : Enum {
    public int value__;
    public static CREATE_ASM_NAME_OBJ_FLAGS CANOF_PARSE_DISPLAY_NAME;
    public static CREATE_ASM_NAME_OBJ_FLAGS CANOF_SET_DEFAULT_VALUES;
}
public class System.GAC.FUSION_INSTALL_REFERENCE : ValueType {
    public UInt32 cbSize;
    public UInt32 dwFlags;
    public Guid guidScheme;
    public string szIdentifier;
    public string szNonCannonicalData;
}
[GuidAttribute("e707dcde-d1cd-11d2-bab9-00c04f8eceae")]
[InterfaceTypeAttribute("1")]
public interface System.GAC.IAssemblyCache {
    public abstract virtual int UninstallAssembly(UInt32 dwFlags, string pszAssemblyName, FUSION_INSTALL_REFERENCE[] pRefData, UInt32& pulDisposition);
    public abstract virtual int QueryAssemblyInfo(UInt32 dwFlags, string pszAssemblyName, ASSEMBLY_INFO& pAsmInfo);
    public abstract virtual int CreateAssemblyCacheItem(UInt32 dwFlags, IntPtr pvReserved, IAssemblyCacheItem& ppAsmItem, string pszAssemblyName);
    public abstract virtual int CreateAssemblyScavenger(Object& ppAsmScavenger);
    public abstract virtual int InstallAssembly(UInt32 dwFlags, string pszManifestFilePath, FUSION_INSTALL_REFERENCE[] pRefData);
}
public enum System.GAC.IASSEMBLYCACHE_INSTALL_FLAG : Enum {
    public int value__;
    public static IASSEMBLYCACHE_INSTALL_FLAG IASSEMBLYCACHE_INSTALL_FLAG_REFRESH;
    public static IASSEMBLYCACHE_INSTALL_FLAG IASSEMBLYCACHE_INSTALL_FLAG_FORCE_REFRESH;
}
public enum System.GAC.IASSEMBLYCACHE_UNINSTALL_DISPOSITION : Enum {
    public int value__;
    public static IASSEMBLYCACHE_UNINSTALL_DISPOSITION IASSEMBLYCACHE_UNINSTALL_DISPOSITION_UNINSTALLED;
    public static IASSEMBLYCACHE_UNINSTALL_DISPOSITION IASSEMBLYCACHE_UNINSTALL_DISPOSITION_STILL_IN_USE;
    public static IASSEMBLYCACHE_UNINSTALL_DISPOSITION IASSEMBLYCACHE_UNINSTALL_DISPOSITION_ALREADY_UNINSTALLED;
    public static IASSEMBLYCACHE_UNINSTALL_DISPOSITION IASSEMBLYCACHE_UNINSTALL_DISPOSITION_DELETE_PENDING;
    public static IASSEMBLYCACHE_UNINSTALL_DISPOSITION IASSEMBLYCACHE_UNINSTALL_DISPOSITION_HAS_INSTALL_REFERENCES;
    public static IASSEMBLYCACHE_UNINSTALL_DISPOSITION IASSEMBLYCACHE_UNINSTALL_DISPOSITION_REFERENCE_NOT_FOUND;
}
[GuidAttribute("9E3AAEB4-D1CD-11D2-BAB9-00C04F8ECEAE")]
[InterfaceTypeAttribute("1")]
public interface System.GAC.IAssemblyCacheItem {
    public abstract virtual void CreateStream(UInt32 dwFlags, string pszStreamName, UInt32 dwFormat, UInt32 dwFormatFlags, IStream& ppIStream, Int64& puliMaxSize);
    public abstract virtual void Commit(UInt32 dwFlags, Int64& pulDisposition);
    public abstract virtual void AbortItem();
}
[GuidAttribute("21b8916c-f28e-11d2-a473-00c04f8ef448")]
[InterfaceTypeAttribute("1")]
public interface System.GAC.IAssemblyEnum {
    public abstract virtual int GetNextAssembly(IntPtr pvReserved, IAssemblyName& ppName, UInt32 dwFlags);
    public abstract virtual int Reset();
    public abstract virtual int Clone(IAssemblyEnum& ppEnum);
}
[GuidAttribute("CD193BC0-B4BC-11d2-9833-00C04FC31D2E")]
[InterfaceTypeAttribute("1")]
public interface System.GAC.IAssemblyName {
    public abstract virtual int SetProperty(ASM_NAME propertyId, IntPtr pvProperty, UInt32 cbProperty);
    public abstract virtual int GetProperty(ASM_NAME propertyId, IntPtr pvProperty, UInt32& pcbProperty);
    public abstract virtual int Finalize();
    public abstract virtual int GetDisplayName(StringBuilder szDisplayName, UInt32& pccDisplayName, ASM_DISPLAY_FLAGS dwDisplayFlags);
    public abstract virtual int BindToObject(Guid& refIID, object pUnkSink, object pUnkContext, string szCodeBase, long llFlags, IntPtr pvReserved, UInt32 cbReserved, IntPtr& ppv);
    public abstract virtual int GetName(UInt32& lpcwBuffer, StringBuilder pwzName);
    public abstract virtual int GetVersion(UInt32& pdwVersionHi, UInt32& pdwVersionLow);
    public abstract virtual int IsEqual(IAssemblyName pName, ASM_CMP_FLAGS dwCmpFlags);
    public abstract virtual int Clone(IAssemblyName& pName);
}
[GuidAttribute("56b1a988-7c0c-4aa2-8639-c3eb5a90226f")]
[InterfaceTypeAttribute("1")]
public interface System.GAC.IInstallReferenceEnum {
    public abstract virtual int GetNextInstallReferenceItem(IInstallReferenceItem& ppRefItem, UInt32 dwFlags, IntPtr pvReserved);
}
[GuidAttribute("582dac66-e678-449f-aba6-6faaec8a9394")]
[InterfaceTypeAttribute("1")]
public interface System.GAC.IInstallReferenceItem {
    public abstract virtual int GetReference(FUSION_INSTALL_REFERENCE[]& ppRefData, UInt32 dwFlags, IntPtr pvReserved);
}
public enum System.GAC.QUERYASMINFO_FLAG : Enum {
    public int value__;
    public static QUERYASMINFO_FLAG QUERYASMINFO_FLAG_VALIDATE;
    public static QUERYASMINFO_FLAG QUERYASMINFO_FLAG_GETSIZE;
}
public class System.JetAction`5 : MulticastDelegate {
    public JetAction`5(object object, IntPtr method);
    public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[AttributeUsageAttribute("1")]
public class System.Runtime.CompilerServices.IgnoresAccessChecksToAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <AssemblyName>k__BackingField;
    public string AssemblyName { get; }
    public IgnoresAccessChecksToAttribute(string assemblyName);
    [CompilerGeneratedAttribute]
public string get_AssemblyName();
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsUnmanagedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NativeIntegerAttribute : Attribute {
    public Boolean[] TransformFlags;
    public NativeIntegerAttribute(Boolean[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
