[CounterUsagesCollectorAttribute("16")]
public class JetBrains.ReSharper.Features.Navigation.Features.GoToDeclaredElement.ActionLatencyUsageCollector : CounterUsagesCollector {
    private EventLogGroup myGroup;
    private EventId1`1<Type> myActionNotReadyEvent;
    public ActionLatencyUsageCollector(FeatureUsageLogger featureUsageLogger);
    public virtual EventLogGroup GetGroup();
    public void LogActionNotReady(Type type);
}
[ActionAttribute("JetBrains.Application.Resources.Strings", "AddGroupToEventsTestSchemeActionText")]
public class JetBrains.UsageStatistics.Actions.AddGroupToTestSchemeAction : object {
    public sealed virtual bool Update(IDataContext context, ActionPresentation presentation, DelegateUpdate nextUpdate);
    public sealed virtual void Execute(IDataContext context, DelegateExecute nextExecute);
    [CanBeNullAttribute]
private static ValidationTestRulesPersistedStorage GetTestStorage(IDataContext context);
}
[ActionAttribute("JetBrains.Application.Resources.Strings", "DumpStatisticsSchemaActionText")]
public class JetBrains.UsageStatistics.Actions.DumpStatisticsSchemaAction : object {
    public sealed virtual bool Update(IDataContext context, ActionPresentation presentation, DelegateUpdate nextUpdate);
    private static List`1<GroupDescriptor> BuildEventsScheme(IDataContext context);
    public sealed virtual void Execute(IDataContext context, DelegateExecute nextExecute);
}
[ActionAttribute("JetBrains.Application.Resources.Strings", "OpenEventLogFolderActionText")]
public class JetBrains.UsageStatistics.Actions.OpenEventLogFolderAction : object {
    public sealed virtual bool Update(IDataContext context, ActionPresentation presentation, DelegateUpdate nextUpdate);
    public sealed virtual void Execute(IDataContext context, DelegateExecute nextExecute);
}
[ZoneMarkerAttribute]
public class JetBrains.UsageStatistics.Actions.ZoneMarker : object {
}
public class JetBrains.UsageStatistics.ActivityLogsSubmitter : object {
    private TimeSpan mySubmitLogsInterval;
    private UsageDbManager myCountersStorage;
    private DateTime myLastSubmitTimeUtc;
    private SingleThreadExecutor myExecutor;
    private PermanentDeviceId myPermanentId;
    public ActivityLogsSubmitter(Lifetime lifetime, TimeSpan submitLogsInterval, UsageDbManager countersStorage, IThreading threading, PermanentDeviceId permanentId);
    private static void InMutexContext(Action action);
    public void ProcessGaps(IWebProxy proxy, bool submitFiles, UInt32 currentGapId);
    private void ProccessSingleGap(UInt32 gapId, Nullable`1<GapUploadInfo> gapInfo, IWebProxy proxy, Lazy`1<JObject> configLazy);
    private JObject GetStatConfig(IWebProxy proxy);
}
[ShellComponentAttribute("0")]
public class JetBrains.UsageStatistics.ActivityTracking : object {
    private Lifetime myLifetime;
    private UsageDbManager myCounterStorage;
    private IThreading myThreading;
    private ISignal`1<CounterChangedArgs> myCounterChangedSignal;
    private HashMap`2<ActivityDescriptor, LiveCounterEntry> myLiveCounters;
    private SpinWaitLock myLiveCountersLock;
    private ActivityLogsSubmitter mySubmitter;
    private Timer myTimer;
    private UInt32 myCurrentGapId;
    private ActivityTrackingDefaultSettings mySettings;
    private object myLock;
    private JObject myCurrentLog;
    public IProperty`1<bool> IsAvailable { get; }
    public ActivityTracking(Lifetime lifetime, ActivityTrackingSettings activityTrackingSettings, UsageDbManager counterStorage, IThreading threading, PermanentDeviceId permanentId);
    private bool IsSessionOpen();
    public sealed virtual IProperty`1<bool> get_IsAvailable();
    public virtual void TrackAction(string actionId);
    public virtual void TrackActivity(string activityGroup, string activityId, int count);
    private void TrackActivityInternal(string activityGroup, string activityId, int count, UsageDb db, UInt32 localGapId);
    public void AdviseCounterChanged(Lifetime lifetime, Action`1<CounterChangedArgs> action);
    public void GetCurrentItems(string groupName, Action`1<IEnumerable`1<ItemDBRecord>> handler);
    public sealed virtual IProperty`1<int> GetActivityUsageCounter(Lifetime lifetime, ActivityDescriptor activityDescriptor);
    private void UpdateLiveCounterIfExists(string activityGroup, string activityId, int newValue);
    [CanBeNullAttribute]
public string GetItemName(Guid itemId);
    public sealed virtual void EnsureSessionStarted();
    private void StartSession(bool justEnsure);
    public void StopSession();
    [CanBeNullAttribute]
public void RestartSession();
    private void StopSessionInternal();
    private void WithLock(Action`1<JObject> handler);
    [CompilerGeneratedAttribute]
private void <StartSession>b__27_0(UsageDb db);
    [CompilerGeneratedAttribute]
private void <StopSessionInternal>b__30_0(UsageDb db);
}
public class JetBrains.UsageStatistics.ActivityTrackingDefaultSettings : object {
    [CompilerGeneratedAttribute]
private IProperty`1<bool> <ActivityTrackingEnabled>k__BackingField;
    public IProperty`1<bool> ActivityTrackingEnabled { get; protected set; }
    public TimeSpan DumpLogsInterval { get; }
    public TimeSpan SubmitLogsInterval { get; }
    public ActivityTrackingDefaultSettings(Lifetime lifetime);
    [CanBeNullAttribute]
public virtual IWebProxy GetProxy();
    public virtual Task`1<bool> GetIsSubmittingLogsEnabled();
    [CompilerGeneratedAttribute]
public IProperty`1<bool> get_ActivityTrackingEnabled();
    [CompilerGeneratedAttribute]
protected void set_ActivityTrackingEnabled(IProperty`1<bool> value);
    public virtual TimeSpan get_DumpLogsInterval();
    public virtual TimeSpan get_SubmitLogsInterval();
}
[ShellComponentAttribute("16")]
public class JetBrains.UsageStatistics.ActivityTrackingSettings : ActivityTrackingDefaultSettings {
    private WebProxySettingsReader myProxySettings;
    private ISettingsStore myStore;
    public ActivityTrackingSettings(Lifetime lifetime, WebProxySettingsReader proxySettings, ISettingsStore store);
    public virtual Task`1<bool> GetIsSubmittingLogsEnabled();
    public virtual IWebProxy GetProxy();
}
[ShellComponentAttribute("10")]
public class JetBrains.UsageStatistics.ApplicationFocusTracking : object {
    private Nullable`1<DateTime> myCurrentFocusStart;
    [CompilerGeneratedAttribute]
private CollectionEvents`1<FocusEvent> <FocusEvents>k__BackingField;
    private ReadonlyToken myReadonlyToken;
    public CollectionEvents`1<FocusEvent> FocusEvents { get; }
    public ApplicationFocusTracking(Lifetime lifetime, IUIApplicationSimple application);
    [CompilerGeneratedAttribute]
public CollectionEvents`1<FocusEvent> get_FocusEvents();
    private void StartCurrentFocus();
    private void EndCurrentFocus();
    [CompilerGeneratedAttribute]
private void <.ctor>b__5_0(PropertyChangedEventArgs`1<bool> args);
}
[ShellComponentAttribute("0")]
public class JetBrains.UsageStatistics.Collectors.ApplicationSettingsUsagesCollector : ApplicationUsagesCollector {
    private SettingsUsagesCollector myCollector;
    public ApplicationSettingsUsagesCollector(FeatureUsageLogger featureUsageLogger, IShellLocks locks, ISettingsStore settingsStore, UserFriendlySettingsLayers userFriendlySettingsLayers, UserInjectedSettingsLayers userInjectedSettingsLayers, GlobalSettings globalSettings);
    public virtual EventLogGroup GetGroup();
    public virtual Task`1<ISet`1<MetricEvent>> GetMetricsAsync(Lifetime lifetime);
    public sealed virtual bool AreWeSafe();
}
[ShellComponentAttribute("0")]
public class JetBrains.UsageStatistics.Collectors.I18NUsagesCollector : ApplicationUsagesCollector {
    private ShellCultureOptionsReader myCultureReader;
    private EventLogGroup myGroup;
    private String[] LOCALES;
    private EventId1`1<string> myCultureEvent;
    public I18NUsagesCollector(FeatureUsageLogger featureUsageLogger, ShellCultureOptionsReader cultureReader);
    public virtual EventLogGroup GetGroup();
    public virtual Task`1<ISet`1<MetricEvent>> GetMetricsAsync(Lifetime lifetime);
}
public interface JetBrains.UsageStatistics.Collectors.ISettingsUsagesCollectorShellProtector {
    public abstract virtual bool AreWeSafe();
}
[ShellComponentAttribute("20")]
public class JetBrains.UsageStatistics.Collectors.ProcessDiagReporter : object {
    private ProcessUsagesCollector myUsagesCollector;
    public ProcessDiagReporter(Lifetime lifetime, ILogger logger, ProcessUsagesCollector usagesCollector, ProductSettingsLocation settingsLocation);
    private void CheckAndReportNgen();
}
[CounterUsagesCollectorAttribute("16")]
public class JetBrains.UsageStatistics.Collectors.ProcessUsagesCollector : CounterUsagesCollector {
    private EventLogGroup myGroup;
    private EventId myCrashEvent;
    private EventId1`1<bool> myNgenEvent;
    public ProcessUsagesCollector(FeatureUsageLogger featureUsageLogger);
    public virtual EventLogGroup GetGroup();
    public void LogNgenDetected(bool isNgend);
    public void LogCrashDetected();
}
public class JetBrains.UsageStatistics.Collectors.SettingsUsagesCollector : object {
    private IShellLocks myLocks;
    private ISettingsStore mySettingsStore;
    private UserFriendlySettingsLayers myUserFriendlySettingsLayers;
    private UserInjectedSettingsLayers myUserInjectedSettingsLayers;
    private Dictionary`2<Identity, LayerType> myCustomLayerMapping;
    private EventLogGroup myGroup;
    private VarargEventId myEntryEvent;
    private JetHashSet`1<SettingsKey> myBannedKeys;
    private Identity myProductGlobalLayerId;
    private EnumEventField`1<LayerType> myLayerTypeField;
    private EnumEventField`1<LayerType> myLayerHostTypeField;
    private StringEventField mySettingsKeyField;
    private StringEventField mySettingsEntryField;
    private StringEventField mySettingsValueField;
    public SettingsUsagesCollector(FeatureUsageLogger featureUsageLogger, IShellLocks locks, ISettingsStore settingsStore, UserFriendlySettingsLayers userFriendlySettingsLayers, UserInjectedSettingsLayers userInjectedSettingsLayers, GlobalSettings globalSettings, Dictionary`2<Identity, LayerType> customLayerMapping);
    private LayerType GetLayerType(UserFriendlySettingsLayer layer);
    private LayerType GetLayerType(Identity id);
    private bool CanBeReported(SettingsScalarEntry candidateEntry);
    private string FormatSettingsKey(SettingsKey key);
    [AsyncStateMachineAttribute("JetBrains.UsageStatistics.Collectors.SettingsUsagesCollector/<GetMetricsAsync>d__20")]
public Task`1<ISet`1<MetricEvent>> GetMetricsAsync(Lifetime lifetime);
    public EventLogGroup GetGroup();
}
[ShellComponentAttribute("0")]
public class JetBrains.UsageStatistics.Collectors.SystemDataCollector : ApplicationUsagesCollector {
    private SubProducts mySubProducts;
    private ILicense2CheckComponent myLicense2CheckComponent;
    private ICurrentRegion myCurrentRegion;
    private static string Windows;
    private static string Mac;
    private static string Linux;
    private static string Other;
    private String[] OS_NAMES;
    private String[] LOCALES;
    private String[] myProductNames;
    private String[] myLicensedEntitiesNames;
    private EventLogGroup myGroup;
    private StringEventField myOSName;
    private StringEventField myOSLang;
    private StringEventField myOSTz;
    private VarargEventId mySystemEvent;
    private Version2Field myVersion2;
    private IntEventField myProcessors;
    private EventId1`1<string> myProductEvent;
    private EventId2`2<string, IList`1<string>> myLicensedEntityEvent;
    private VarargEventId myLicenseEvent;
    private IntEventField myOsBuildNumber;
    private StringEventField myOsArch;
    private StringEventField myMetadataField;
    private BooleanEventField myIsJbTeamField;
    private StringListEventField myProductsField;
    private EnumEventField`1<LicenseType> myLicenseValueField;
    private BoundedIntEventField myTotalRam;
    private EventId1`1<Region> myRegionEvent;
    private static ulong GB;
    public SystemDataCollector(FeatureUsageLogger featureUsageLogger, SubProducts subProducts, ILicense2CheckComponent license2CheckComponent, ICurrentRegion currentRegion);
    public virtual EventLogGroup GetGroup();
    private string FormatTimeZone(TimeSpan span);
    public virtual Task`1<ISet`1<MetricEvent>> GetMetricsAsync(Lifetime lifetime);
    [IteratorStateMachineAttribute("JetBrains.UsageStatistics.Collectors.SystemDataCollector/<ExtractLicenseMetadatas>d__36")]
public static IEnumerable`1<StatisticsLicenseMetadata> ExtractLicenseMetadatas(ILicenseViewSubmodel submodel);
    private static bool IsJbTeam(string licensee);
    [CanBeNullAttribute]
private static StatisticsLicenseMetadata ExtractLicenseMetadata(INewLicenseData newLicenseData, Dictionary`2<string, ILicensedEntity> allowedProducts);
    private static LicenseType ExtractLicenseValue(INewLicenseData newLicenseData);
    private string GetOsName();
}
[SettingsKeyAttribute("JetBrains.Application.Settings.WellKnownRootKeys.EnvironmentSettings", "JetBrains.UsageStatistics.Resources.Strings", "FeedbackSettingsSettingDescription")]
public class JetBrains.UsageStatistics.FeedbackSettings : object {
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.UsageStatistics.Resources.Strings", "WhetherSendActivityLogsOrNotSettingDescription")]
public bool SendActivityLogs;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.UsageStatistics.Resources.Strings", "WhetherToPromptUserToSubmitFeedbackOrNotSettingDescription")]
public bool ShouldPrompt;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.UsageStatistics.Resources.Strings", "WhetherToCollectTimingForEachActionSettingDescription")]
public bool CollectActionTiming;
}
[GlobalSettingsUpgraderAttribute("16")]
public class JetBrains.UsageStatistics.FeedbackSettingsUpgrader : SettingTablesUpgrader {
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
private bool myShouldPrompt;
    public FeedbackSettingsUpgrader(ProductConfigurations productConfigurations);
    protected virtual void DoUpgrade(IComponentSettingsProvider legacySettingsProvider, IContextBoundSettingsStore boundSettingsStore, Lifetime upgradeLifetime, SettingsTableBase workspaceSettingsTable, SettingsTableBase globalSettingsTable);
    public sealed virtual void ReadFromXml(XmlElement element);
}
public static class JetBrains.UsageStatistics.FileUploadUtil : object {
    private static char GroupSeparator;
    private static char GroupsSeparator;
    private static char GroupValueSeparator;
    public static string URLEncodeStats(IEnumerable`1<KeyValuePair`2<string, ICollection`1<Pair`2<string, int>>>> groupedStatValues);
    private static string URLEncodeGroupValues(IEnumerable`1<Pair`2<string, int>> records);
    public static string EnsureProperKey(string key);
    [CanBeNullAttribute]
public static string GetStatConfiguration(IWebProxy proxy);
    public static bool SendStatsPacket(GapUploadInfo gapInfo, string destinationUrl, IWebProxy proxy, PermanentDeviceId permanentId);
}
public abstract class JetBrains.UsageStatistics.FUS.Collectors.ApplicationUsagesCollector : FeatureUsagesCollector {
    public sealed virtual string GroupType();
    [NotNullAttribute]
public virtual Task`1<ISet`1<MetricEvent>> GetMetricsAsync(Lifetime lifetime);
}
public abstract class JetBrains.UsageStatistics.FUS.Collectors.CounterUsagesCollector : FeatureUsagesCollector {
    public sealed virtual string GroupType();
}
[AttributeUsageAttribute("4")]
[MeansImplicitUseAttribute]
[BaseTypeRequiredAttribute("JetBrains.UsageStatistics.FUS.Collectors.CounterUsagesCollector")]
public class JetBrains.UsageStatistics.FUS.Collectors.CounterUsagesCollectorAttribute : ShellComponentAttribute {
    public CounterUsagesCollectorAttribute(Instantiation instantiation);
}
public abstract class JetBrains.UsageStatistics.FUS.Collectors.FeatureUsagesCollector : object {
    private static string GROUP_ID_PATTERN;
    private static FeatureUsagesCollector();
    public abstract virtual string GroupType();
    public virtual bool IsValid();
    public abstract virtual EventLogGroup GetGroup();
}
[ShellComponentAttribute("20")]
public class JetBrains.UsageStatistics.FUS.Collectors.FUCounterUsageLogger : object {
    private IComponentContainer myComponentContainer;
    private FeatureUsageLogger myFeatureUsageLogger;
    private static int LOG_REGISTERED_DELAY_MIN;
    private static int LOG_REGISTERED_INITIAL_DELAY_MIN;
    public FUCounterUsageLogger(Lifetime lifetime, IComponentContainer componentContainer, IThreading threading, FeatureUsageLogger featureUsageLogger, StatisticsActivator activator);
    private void LogRegisteredGroups();
}
[ShellComponentAttribute("16")]
public class JetBrains.UsageStatistics.FUS.Collectors.FuStateUsagesLogger : object {
    private Lifetime myLifetime;
    private ILogger myLogger;
    private IComponentContainer myComponentContainer;
    private FeatureUsageLogger myFeatureUsageLogger;
    public FuStateUsagesLogger(Lifetime lifetime, ILogger logger, IComponentContainer componentContainer, FeatureUsageLogger featureUsageLogger);
    public void LogApplicationStates(Lifetime lifetime);
    private void LogMetricsOrError(EventLogGroup group, ISet`1<MetricEvent> metrics);
    private void LogUsagesAsStateEvents(EventLogGroup group, ISet`1<MetricEvent> metrics);
    [CanBeNullAttribute]
public static FeatureUsageData MergeWithEventData(FeatureUsageData groupData, FeatureUsageData data);
}
public class JetBrains.UsageStatistics.FUS.Config.EventLogBucketRange : object {
    private int myFrom;
    private int myTo;
    public EventLogBucketRange(int from, int to);
    public bool Contains(int bucket);
    private bool Equals(EventLogBucketRange other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class JetBrains.UsageStatistics.FUS.Config.EventLogConfigFilterCondition : object {
    [CanBeNullAttribute]
public string ReleaseType;
    public int From;
    public int To;
    public EventLogBucketRange GetBucketRange();
    private bool IsValid();
}
public class JetBrains.UsageStatistics.FUS.Config.EventLogConfigParserException : Exception {
    public EventLogConfigParserException(Exception exception);
}
public class JetBrains.UsageStatistics.FUS.Config.EventLogConfigVersions : object {
    [CanBeNullAttribute]
public EventLogMajorVersionBorders MajorBuildVersionBorders;
    [CanBeNullAttribute]
public HashMap`2<string, string> Endpoints;
    [CanBeNullAttribute]
public HashMap`2<string, string> Options;
    [CanBeNullAttribute]
public List`1<EventLogConfigFilterCondition> ReleaseFilters;
    [NotNullAttribute]
public IDictionary`2<string, string> GetEndpoints();
    [NotNullAttribute]
public IDictionary`2<string, string> GetOptions();
    [NotNullAttribute]
public IList`1<EventLogConfigFilterCondition> GetFilters();
}
public class JetBrains.UsageStatistics.FUS.Config.EventLogExternalSendSettings : object {
    private IDictionary`2<string, string> myEndpoints;
    private IDictionary`2<EventLogBuildType, EventLogSendConfiguration> myConfigurations;
    private IDictionary`2<string, string> myOptions;
    public EventLogExternalSendSettings(IDictionary`2<string, string> endpoints, IDictionary`2<string, string> options, IDictionary`2<EventLogBuildType, EventLogSendConfiguration> configurations);
    public bool IsSendEnabled();
    [CanBeNullAttribute]
public EventLogSendConfiguration GetConfiguration(EventLogBuildType type);
    [CanBeNullAttribute]
public string GetEndpoint(string name);
    public IDictionary`2<string, string> GetOptions();
}
public class JetBrains.UsageStatistics.FUS.Config.EventLogExternalSettings : object {
    public static EventLogExternalSendSettings EMPTY;
    public string ProductCode;
    public List`1<EventLogConfigVersions> Versions;
    private static EventLogExternalSettings();
    [NotNullAttribute]
public static EventLogExternalSendSettings ParseSendSettings(string json, string version);
    [NotNullAttribute]
private EventLogExternalSendSettings ToSendSettings(string productVersion);
    [CanBeNullAttribute]
private EventLogConfigVersions FindMajorVersion(string productVersion);
}
public class JetBrains.UsageStatistics.FUS.Config.EventLogMajorVersionBorders : object {
    [CanBeNullAttribute]
public string From;
    [CanBeNullAttribute]
public string To;
    public bool Accept(string current);
    private static bool IsValidMajorVersion(EventLogMajorVersion build);
}
public class JetBrains.UsageStatistics.FUS.Config.EventLogOptions : object {
    public static string DATA_THRESHOLD;
    public static string GROUP_THRESHOLD;
    public static string GROUP_ALERT_THRESHOLD;
    public static string MACHINE_ID_SALT;
    public static string MACHINE_ID_SALT_REVISION;
    public static string MACHINE_ID_DISABLED;
    public static string MACHINE_ID_UNKNOWN;
    public static int DEFAULT_ID_REVISION;
    private IDictionary`2<string, string> myOptions;
    public EventLogOptions(IDictionary`2<string, string> options);
    public int GetThreshold();
    public int GetGroupThreshold();
    public int GetGroupAlertThreshold();
    public int GetMachineIdRevision();
    public string GetMachineIdSalt();
    private int GetOptionAsInt(string name);
    public static int TryParseInt(string value);
}
public class JetBrains.UsageStatistics.FUS.Config.EventLogSendConfiguration : object {
    [CompilerGeneratedAttribute]
private IList`1<EventLogBucketRange> <Buckets>k__BackingField;
    public IList`1<EventLogBucketRange> Buckets { get; }
    public EventLogSendConfiguration(IList`1<EventLogBucketRange> buckets);
    [CompilerGeneratedAttribute]
public IList`1<EventLogBucketRange> get_Buckets();
    public void AddBucketRange(EventLogBucketRange range);
    protected bool Equals(EventLogSendConfiguration other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class JetBrains.UsageStatistics.FUS.EventLog.Connection.EventLogBasicConnectionSettings : object {
    private StatsProxyInfo NO_PROXY;
    private string myUserAgent;
    public EventLogBasicConnectionSettings(string userAgent);
    public sealed virtual string GetUserAgent();
    public sealed virtual StatsProxyInfo SelectProxy(string url);
}
public abstract class JetBrains.UsageStatistics.FUS.EventLog.Connection.EventLogResultDecoratorBase : object {
    public virtual void OnLogsLoaded(int localFiles);
    public abstract virtual void OnSucceed(LogEventRecordRequest request, string content, string logPath);
    public abstract virtual void OnFailed(LogEventRecordRequest request, int error, string content);
    public abstract virtual StatisticsResult OnFinished();
}
public class JetBrains.UsageStatistics.FUS.EventLog.Connection.EventLogStatisticsService : object {
    private static int MAX_FILES_TO_SEND;
    private DeviceConfiguration myDeviceConfiguration;
    private IEventLogSettingsService mySettingsService;
    private IEventLogRecorderConfig myRecorderConfiguration;
    private Action`3<ICollection`1<string>, ICollection`1<int>, int> mySendListener;
    public EventLogStatisticsService(DeviceConfiguration device, IEventLogRecorderConfig config, IEventLogApplicationInfo application, Action`3<ICollection`1<string>, ICollection`1<int>, int> listener);
    public sealed virtual Task`1<StatisticsResult> SendAsync(bool enforceRollover);
    public Task`1<StatisticsResult> SendAsync(IEventLogResultDecorator decorator, bool enforceRollover);
    [AsyncStateMachineAttribute("JetBrains.UsageStatistics.FUS.EventLog.Connection.EventLogStatisticsService/<SendAsync>d__8")]
public static Task`1<StatisticsResult> SendAsync(DeviceConfiguration device, IEventLogRecorderConfig config, IEventLogSettingsService settings, IEventLogResultDecorator decorator, bool enforceRollover);
    private static MachineId GetMachineId(DeviceConfiguration device, IEventLogSettingsService settings);
    [NotNullAttribute]
private static EventLogBuildType GetDefaultBuildType(IEventLogApplicationInfo info);
    [NotNullAttribute]
private static string LoadAndLogResponse(ILogger logger, StatsHttpResponse response, FileSystemPath file);
    [CanBeNullAttribute]
private static ValidationErrorInfo Validate(LogEventRecordRequest request, FileSystemPath file);
    [AsyncStateMachineAttribute("JetBrains.UsageStatistics.FUS.EventLog.Connection.EventLogStatisticsService/<GetLogFilesAsync>d__13")]
[NotNullAttribute]
protected static Task`1<IList`1<EventLogFile>> GetLogFilesAsync(IEventLogRecorderConfig provider, bool enforceRollover);
    private static void CleanupEventLogFiles(IList`1<EventLogFile> toRemove);
    private static void CleanupFiles(List`1<FileSystemPath> toRemove);
}
public class JetBrains.UsageStatistics.FUS.EventLog.Connection.EventLogUploadSettingsService : SettingsConnectionService {
    private static string SEND;
    private static string METADATA;
    private static string DICTIONARY;
    [NotNullAttribute]
private IEventLogApplicationInfo myApplicationInfo;
    public EventLogUploadSettingsService(string recorderId, IEventLogApplicationInfo appInfo);
    public EventLogUploadSettingsService(string recorderId, IEventLogApplicationInfo appInfo, long settingsCacheTimeoutMs);
    [NotNullAttribute]
private static string GetConfigUrl(string recorderId, string productCode, string templateUrl, bool isTest);
    [CanBeNullAttribute]
public sealed virtual string GetServiceUrl();
    [CanBeNullAttribute]
public sealed virtual string GetDictionaryServiceUrl();
    public sealed virtual bool IsSettingsReachable();
    public sealed virtual bool IsSendEnabled();
    public sealed virtual ILogEventFilter GetBaseEventFilter();
    public sealed virtual ILogEventFilter GetEventFilter(ILogEventFilter baseFilter, EventLogBuildType type);
    public sealed virtual IEventLogApplicationInfo GetApplicationInfo();
    [CanBeNullAttribute]
protected EventGroupsFilterRules`1<EventLogBuild> LoadApprovedGroupsRules();
    [CanBeNullAttribute]
public string GetMetadataProductUrl();
}
public interface JetBrains.UsageStatistics.FUS.EventLog.Connection.IEventLogConnectionSettings {
    public abstract virtual string GetUserAgent();
    public abstract virtual StatsProxyInfo SelectProxy(string url);
}
public interface JetBrains.UsageStatistics.FUS.EventLog.Connection.IEventLogResultDecorator {
    public abstract virtual void OnLogsLoaded(int localFiles);
    public abstract virtual void OnSucceed(LogEventRecordRequest request, string content, string logPath);
    public abstract virtual void OnFailed(LogEventRecordRequest request, int error, string content);
    [NotNullAttribute]
public abstract virtual StatisticsResult OnFinished();
}
public interface JetBrains.UsageStatistics.FUS.EventLog.Connection.IEventLogSettingsService {
    [CanBeNullAttribute]
public abstract virtual string GetServiceUrl();
    [CanBeNullAttribute]
public abstract virtual string GetDictionaryServiceUrl();
    public abstract virtual bool IsSettingsReachable();
    public abstract virtual bool IsSendEnabled();
    [NotNullAttribute]
public abstract virtual ILogEventFilter GetBaseEventFilter();
    [NotNullAttribute]
public abstract virtual ILogEventFilter GetEventFilter(ILogEventFilter baseFilter, EventLogBuildType type);
    [NotNullAttribute]
public abstract virtual IEventLogApplicationInfo GetApplicationInfo();
    [NotNullAttribute]
public abstract virtual IDictionary`2<string, string> GetOptions();
}
public interface JetBrains.UsageStatistics.FUS.EventLog.Connection.IStatisticsService {
    public abstract virtual Task`1<StatisticsResult> SendAsync(bool enforceRollover);
}
public class JetBrains.UsageStatistics.FUS.EventLog.Connection.Metadata.BuildRange`1 : object {
    private T myFrom;
    private T myTo;
    public BuildRange`1(T from, T to);
    [NotNullAttribute]
public static BuildRange`1<P> Create(string from, string to, IEventLogBuildParser`1<P> buildProducer);
    public bool Contains(T build);
    protected bool Equals(BuildRange`1<T> other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class JetBrains.UsageStatistics.FUS.EventLog.Connection.Metadata.EventGroupFilterRules`1 : object {
    private List`1<BuildRange`1<T>> builds;
    private List`1<VersionRange> versions;
    public EventGroupFilterRules`1(List`1<BuildRange`1<T>> builds, List`1<VersionRange> versions);
    public static EventGroupFilterRules`1<P> Create(EventGroupRemoteDescriptor group, IEventLogBuildParser`1<P> buildProducer);
    [NotNullAttribute]
private static EventGroupFilterRules`1<P> Create(List`1<GroupBuildRange> builds, List`1<GroupVersionRange> versions, IEventLogBuildParser`1<P> buildProducer);
    [NotNullAttribute]
private static List`1<BuildRange`1<P>> ToBuildRanges(List`1<GroupBuildRange> builds, IEventLogBuildParser`1<P> buildProducer);
    [NotNullAttribute]
private static List`1<VersionRange> ToVersionRanges(List`1<GroupVersionRange> versions);
    public bool Accepts(T build, int version);
    public bool Accepts(T build);
    private bool AcceptsBuild(T build);
    private bool AcceptsVersion(int version);
    private bool IsValid();
    protected bool Equals(EventGroupFilterRules`1<T> other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class JetBrains.UsageStatistics.FUS.EventLog.Connection.Metadata.EventGroupRemoteDescriptors : object {
    [NotNullAttribute]
public List`1<EventGroupRemoteDescriptor> groups;
    [CanBeNullAttribute]
public GroupRemoteRule rules;
    [CanBeNullAttribute]
public string version;
}
public class JetBrains.UsageStatistics.FUS.EventLog.Connection.Metadata.EventGroupsFilterRules`1 : object {
    private IDictionary`2<string, EventGroupFilterRules`1<T>> myGroups;
    private IEventLogBuildParser`1<T> myBuildProducer;
    private EventGroupsFilterRules`1(IDictionary`2<string, EventGroupFilterRules`1<T>> groups, IEventLogBuildParser`1<T> producer);
    public static EventGroupsFilterRules`1<P> Create(IDictionary`2<string, EventGroupFilterRules`1<P>> groups, IEventLogBuildParser`1<P> buildProducer);
    [NotNullAttribute]
public static EventGroupsFilterRules`1<EventLogBuild> Empty();
    public bool Accepts(string groupId, string version, string build);
    public int GetSize();
    public bool IsEmpty();
    private static int TryToParse(string value);
    protected bool Equals(EventGroupsFilterRules`1<T> other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [NotNullAttribute]
public static EventGroupsFilterRules`1<P> Create(EventGroupRemoteDescriptors groups, IEventLogBuildParser`1<P> buildProducer);
}
public enum JetBrains.UsageStatistics.FUS.EventLog.Connection.Metadata.EventLogMetadataLoadErrorType : Enum {
    public int value__;
    public static EventLogMetadataLoadErrorType EMPTY_SERVICE_URL;
    public static EventLogMetadataLoadErrorType UNREACHABLE_SERVICE;
    public static EventLogMetadataLoadErrorType EMPTY_RESPONSE_BODY;
    public static EventLogMetadataLoadErrorType ERROR_ON_LOAD;
}
public class JetBrains.UsageStatistics.FUS.EventLog.Connection.Metadata.EventLogMetadataLoadException : Exception {
    private int myErrorCode;
    public EventLogMetadataLoadException(EventLogMetadataLoadErrorType type);
    public EventLogMetadataLoadException(EventLogMetadataLoadErrorType type, Exception e);
    public EventLogMetadataLoadException(EventLogMetadataLoadErrorType type, int errorCode);
    public sealed virtual string GetErrorType();
    public sealed virtual int GetErrorCode();
    public sealed virtual EventLogMetadataUpdateStage GetUpdateStage();
}
public enum JetBrains.UsageStatistics.FUS.EventLog.Connection.Metadata.EventLogMetadataParseErrorType : Enum {
    public int value__;
    public static EventLogMetadataParseErrorType EMPTY_CONTENT;
    public static EventLogMetadataParseErrorType INVALID_JSON;
    public static EventLogMetadataParseErrorType UNKNOWN;
}
public class JetBrains.UsageStatistics.FUS.EventLog.Connection.Metadata.EventLogMetadataParseException : Exception {
    public EventLogMetadataParseException(EventLogMetadataParseErrorType type);
    public EventLogMetadataParseException(EventLogMetadataParseErrorType type, Exception throwable);
    public sealed virtual string GetErrorType();
    public sealed virtual int GetErrorCode();
    public sealed virtual EventLogMetadataUpdateStage GetUpdateStage();
}
public enum JetBrains.UsageStatistics.FUS.EventLog.Connection.Metadata.EventLogMetadataUpdateStage : Enum {
    public int value__;
    public static EventLogMetadataUpdateStage LOADING;
    public static EventLogMetadataUpdateStage PARSING;
}
public static class JetBrains.UsageStatistics.FUS.EventLog.Connection.Metadata.EventLogMetadataUtils : object {
    public static EventGroupsFilterRules`1<EventLogBuild> LoadAndParseGroupsFilterRules(string serviceUrl, IEventLogConnectionSettings settings);
    [NotNullAttribute]
public static EventGroupRemoteDescriptors ParseGroupRemoteDescriptors(string content);
    [NotNullAttribute]
public static string LoadMetadataFromServer(string serviceUrl, IEventLogConnectionSettings settings);
    public static long LastModifiedMetadata(string serviceUrl, IEventLogConnectionSettings settings);
}
public interface JetBrains.UsageStatistics.FUS.EventLog.Connection.Metadata.IEventLogBuildParser`1 {
    [CanBeNullAttribute]
public abstract virtual T Parse(string build);
}
public interface JetBrains.UsageStatistics.FUS.EventLog.Connection.Metadata.IEventLogMetadataUpdateError {
    public abstract virtual string GetErrorType();
    public abstract virtual int GetErrorCode();
    public abstract virtual EventLogMetadataUpdateStage GetUpdateStage();
}
public class JetBrains.UsageStatistics.FUS.EventLog.Connection.Metadata.VersionRange : object {
    private int myFrom;
    private int myTo;
    public VersionRange(int from, int to);
    [NotNullAttribute]
public static VersionRange Create(string from, string to);
    private static int TryToParse(string value, int defaultValue);
    public bool Contains(int current);
    protected bool Equals(VersionRange other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public static class JetBrains.UsageStatistics.FUS.EventLog.Connection.Request.StatsHttpRequests : object {
    public static StatsRequestBuilder Request(string url, IEventLogConnectionSettings settings);
    public static StatsRequestBuilder Head(string url, IEventLogConnectionSettings settings);
    public static StatsRequestBuilder Post(string url, IEventLogConnectionSettings settings);
}
public class JetBrains.UsageStatistics.FUS.EventLog.Connection.Request.StatsHttpResponse : object {
    private HttpWebResponse myResponse;
    private HttpStatusCode myCode;
    public StatsHttpResponse(HttpWebResponse response, HttpStatusCode code);
    public HttpStatusCode GetStatusCode();
    [CanBeNullAttribute]
public Nullable`1<DateTime> LastModified();
    [CanBeNullAttribute]
public string ReadAsString();
    [CanBeNullAttribute]
public Stream Read();
    public sealed virtual void Dispose();
}
public class JetBrains.UsageStatistics.FUS.EventLog.Connection.Request.StatsProxyInfo : object {
    private IWebProxy myProxy;
    public StatsProxyInfo(IWebProxy proxy);
    public bool IsNoProxy();
    [CanBeNullAttribute]
public IWebProxy GetProxy();
}
public class JetBrains.UsageStatistics.FUS.EventLog.Connection.Request.StatsRequestBuilder : object {
    private static HashSet`1<HttpStatusCode> CAN_RETRY_CODES;
    private static int MAX_RETRIES;
    private static int RETRY_INTERVAL;
    private string myMethod;
    private string myUrl;
    private string myUserAgent;
    private StatsProxyInfo myProxyInfo;
    private string myContent;
    private string myContentType;
    private Encoding myCharset;
    private Action`2<StatsHttpResponse, HttpStatusCode> myOnSucceed;
    private Action`2<StatsHttpResponse, HttpStatusCode> myOnFail;
    public StatsRequestBuilder(string method, string url, IEventLogConnectionSettings settings);
    private static StatsRequestBuilder();
    [NotNullAttribute]
public StatsRequestBuilder WithBody(string body, string contentType, Encoding charset);
    [NotNullAttribute]
public StatsRequestBuilder Fail(Action`2<StatsHttpResponse, HttpStatusCode> processor);
    [NotNullAttribute]
public StatsRequestBuilder Succeed(Action`2<StatsHttpResponse, HttpStatusCode> processor);
    [NotNullAttribute]
private HttpWebRequest NewRequest();
    public void Send();
    public StatsRequestResult`1<T> Send(Func`2<StatsHttpResponse, T> onSucceed);
    private HttpWebResponse TrySend(HttpWebRequest request);
    private HttpWebResponse TrySend(HttpWebRequest request, int retryCounter);
    [CompilerGeneratedAttribute]
private bool <Send>b__17_0(StatsHttpResponse response);
}
public class JetBrains.UsageStatistics.FUS.EventLog.Connection.Request.StatsRequestResult`1 : object {
    private T myResult;
    private HttpStatusCode myErrorCode;
    public StatsRequestResult`1(T result, HttpStatusCode errorCode);
    public static StatsRequestResult`1<T> Succeed(T result);
    public static StatsRequestResult`1<T> Error(HttpStatusCode error);
    public T GetResult();
    public HttpStatusCode GetError();
    public bool IsSucceed();
}
public class JetBrains.UsageStatistics.FUS.EventLog.Connection.Request.StatsResponseException : Exception {
    public StatsResponseException(Exception innerException);
}
public abstract class JetBrains.UsageStatistics.FUS.EventLog.Connection.SettingsConnectionService : object {
    private IEventLogApplicationInfo myApplicationInfo;
    private long mySettingsCacheTimeoutMs;
    private string myConfigUrl;
    private EventLogExternalSendSettings myExternalSettings;
    private DateTimeOffset myExternalSettingsValidity;
    private object mySettingsLock;
    public SettingsConnectionService(string settingsUrl, IEventLogApplicationInfo applicationInfo, long settingsCacheTimeoutMs);
    [CanBeNullAttribute]
protected EventLogSendConfiguration GetConfiguration(EventLogBuildType type);
    [CanBeNullAttribute]
protected string GetEndpointValue(string attribute);
    [NotNullAttribute]
public sealed virtual IDictionary`2<string, string> GetOptions();
    [CanBeNullAttribute]
protected EventLogExternalSendSettings GetExternalSettings();
    [CanBeNullAttribute]
public EventLogExternalSendSettings LoadSettings(string configUrl, string appVersion);
    private void LogError(Exception e);
}
public class JetBrains.UsageStatistics.FUS.EventLog.Connection.StatisticsResult : object {
    [CompilerGeneratedAttribute]
private ResultCode <Code>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    public ResultCode Code { get; }
    public string Description { get; }
    public StatisticsResult(ResultCode code, string description);
    [CompilerGeneratedAttribute]
public ResultCode get_Code();
    [CompilerGeneratedAttribute]
public string get_Description();
}
public class JetBrains.UsageStatistics.FUS.EventLog.Connection.StatServiceException : ApplicationException {
    public StatServiceException(string message, Exception exception);
}
public class JetBrains.UsageStatistics.FUS.EventLog.DefaultEventLogFilesProvider : object {
    private FileSystemPath myDir;
    private Func`1<string> myActiveFileProvider;
    private Action myRolloverCallback;
    public DefaultEventLogFilesProvider(FileSystemPath dir, Func`1<string> activeFileProvider, Action rolloverCallback);
    public sealed virtual FileSystemPath GetLogFilesDir();
    public sealed virtual IList`1<EventLogFile> GetLogFiles();
    public sealed virtual void Rollover();
}
public class JetBrains.UsageStatistics.FUS.EventLog.DeviceConfiguration : object {
    [CompilerGeneratedAttribute]
private string <DeviceId>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Bucket>k__BackingField;
    [CompilerGeneratedAttribute]
private MachineId <MachineId>k__BackingField;
    public string DeviceId { get; }
    public int Bucket { get; }
    public MachineId MachineId { get; }
    public DeviceConfiguration(string deviceId, int bucket, MachineId machineId);
    [CompilerGeneratedAttribute]
public string get_DeviceId();
    [CompilerGeneratedAttribute]
public int get_Bucket();
    [CompilerGeneratedAttribute]
public MachineId get_MachineId();
}
public class JetBrains.UsageStatistics.FUS.EventLog.EmptyEventLogFilesProvider : object {
    public static EmptyEventLogFilesProvider Instance;
    private static EmptyEventLogFilesProvider();
    public sealed virtual FileSystemPath GetLogFilesDir();
    public sealed virtual IList`1<EventLogFile> GetLogFiles();
    public sealed virtual void Rollover();
}
internal class JetBrains.UsageStatistics.FUS.EventLog.EmptyStatisticsEventLogger : object {
    public sealed virtual EventLogFile GetActiveLogFile();
    public sealed virtual IEventLogFilesProvider GetLogFilesProvider();
    public sealed virtual void Cleanup();
    public sealed virtual void RollOver();
    public sealed virtual Task LogAsync(EventLogGroup group, string eventId, IDictionary`2<string, object> data, bool isState);
}
internal class JetBrains.UsageStatistics.FUS.EventLog.EmptyStatisticsEventLoggerProvider : StatisticsEventLoggerProvider {
    public EmptyStatisticsEventLoggerProvider(Lifetime lifetime, string recorderId, EventLogConfiguration eventLogConfiguration, EventLogConfigOptionsService eventLogConfigOptionsService, EventLogThresholdConfigOptionsListener eventLogThresholdConfigOptionsListener, IStatisticsSystemEventIdProvider statisticsSystemEventIdProvider, DotnetSensitiveDataValidatorProvider dotnetSensitiveDataValidatorProvider, IThreading threading);
    public virtual Task`1<IStatisticsEventLogger> GetLoggerAsync();
    public virtual Task`1<bool> IsRecordEnabledAsync();
    public virtual Task`1<bool> IsSendEnabledAsync();
}
public class JetBrains.UsageStatistics.FUS.EventLog.EventLogAppConnectionSettings : object {
    private ActivityTrackingSettings myActivityTrackingSettings;
    public EventLogAppConnectionSettings(ActivityTrackingSettings activityTrackingSettings);
    public sealed virtual string GetUserAgent();
    public sealed virtual StatsProxyInfo SelectProxy(string url);
}
public class JetBrains.UsageStatistics.FUS.EventLog.EventLogBuild : object {
    public static int SNAPSHOT_VALUE;
    public static IEventLogBuildParser`1<EventLogBuild> EVENT_LOG_BUILD_PRODUCER;
    private Int32[] myComponents;
    public EventLogBuild(Int32[] components);
    private static EventLogBuild();
    public Int32[] GetComponents();
    [CanBeNullAttribute]
public static EventLogBuild FromString(string version);
    private static Int32[] ToIntArray(String[] components);
    [NotNullAttribute]
private static string RemoveProductCode(string version);
    private static int TryParseInt(string version);
    public sealed virtual int CompareTo(EventLogBuild other);
    private bool Equals(EventLogBuild other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class JetBrains.UsageStatistics.FUS.EventLog.EventLogBuildType : EnumPattern {
    public static EventLogBuildType EAP;
    public static EventLogBuildType RELEASE;
    public static EventLogBuildType UNKNOWN;
    private static EventLogBuildType[] ourValues;
    private static string ALL;
    private EventLogBuildType(string name);
    private static EventLogBuildType();
    [NotNullAttribute]
public static EventLogBuildType[] GetTypesByString(string type);
}
[ShellComponentAttribute("16")]
public class JetBrains.UsageStatistics.FUS.EventLog.EventLogConfigOptionsService : object {
    private IImmutableList`1<IEventLogConfigOptionsListener> myListeners;
    private EventLogMetadataSettingsPersistence myPersisted;
    private static JetHashSet`1<string> ourOptions;
    public EventLogConfigOptionsService(IImmutableList`1<IEventLogConfigOptionsListener> listeners, EventLogMetadataSettingsPersistence persisted);
    private static EventLogConfigOptionsService();
    public void UpdateOptions(string recorderId, IEventLogMetadataLoader loader);
    [NotNullAttribute]
public EventLogOptions GetOptions(string recorderId);
}
[ShellComponentAttribute("16")]
public class JetBrains.UsageStatistics.FUS.EventLog.EventLogConfiguration : object {
    private ProductSettingsLocation myProductSettingsLocation;
    private EventLogConfigOptionsService myConfigOptionsService;
    private EventLogRecorderConfigOptionsListener myListener;
    private EventLogConfigurationValueProvider myValueProvider;
    private PermanentDeviceId myPermanentDeviceId;
    internal static ILogger LOG;
    internal static string UNDEFINED_DEVICE_ID;
    private static string FUS_RECORDER;
    private static string SALT_PREFERENCE_KEY;
    private EventLogRecorderConfiguration myDefaultConfiguration;
    private IDictionary`2<string, EventLogRecorderConfiguration> myConfigurations;
    public EventLogConfiguration(ProductSettingsLocation productSettingsLocation, EventLogConfigOptionsService configOptionsService, EventLogRecorderConfigOptionsListener listener, EventLogConfigurationValueProvider valueProvider, PermanentDeviceId permanentDeviceId);
    private static EventLogConfiguration();
    public string GetBuild();
    internal static Byte[] GetOrGenerateSalt(string recorderId, DataAccess dataAccess);
    public EventLogRecorderConfiguration GetOrCreate(string recorderId);
    public FileSystemPath GetEventLogDataPath();
    internal static string GetSaltPropertyKey(string recorderId);
    private static bool IsDefaultRecorderId(string recorderId);
    [CompilerGeneratedAttribute]
private EventLogRecorderConfiguration <GetOrCreate>b__14_0(string s);
}
[ShellComponentAttribute("16")]
public class JetBrains.UsageStatistics.FUS.EventLog.EventLogConfigurationValueProvider : object {
    private DataAccess myDataAccess;
    public EventLogConfigurationValueProvider(DataAccess dataAccess);
    [CanBeNullAttribute]
public virtual string ProvideSessionId(string recorderId);
    [CanBeNullAttribute]
public virtual Byte[] ProvideSalt(string recorderId);
    private static string ToShortedUUID(string str);
    public virtual string ProvideBuildNumber();
    [CanBeNullAttribute]
public virtual Nullable`1<int> ProvideBucket();
}
public class JetBrains.UsageStatistics.FUS.EventLog.EventLogFile : object {
    [CompilerGeneratedAttribute]
private FileSystemPath <File>k__BackingField;
    public FileSystemPath File { get; }
    public EventLogFile(FileSystemPath file);
    [CompilerGeneratedAttribute]
public FileSystemPath get_File();
    public static EventLogFile Create(FileSystemPath dir, EventLogBuildType buildType, string suffix);
    private static string NewName(EventLogBuildType buildType, string suffix);
    public EventLogBuildType getType(EventLogBuildType defaultType);
    private string parseType();
}
[LocalizableAttribute("False")]
public class JetBrains.UsageStatistics.FUS.EventLog.EventLogGroup : object {
    [CompilerGeneratedAttribute]
private string <description>k__BackingField;
    public string id;
    public int version;
    private FeatureUsageLogger myFeatureUsageLogger;
    private ISet`1<string> registeredEventIds;
    private IList`1<BaseEventId> registeredEvents;
    public string description { get; }
    public IEnumerable`1<BaseEventId> Events { get; }
    public EventLogGroup(string id, string description, int version, FeatureUsageLogger featureUsageLogger);
    [CompilerGeneratedAttribute]
public string get_description();
    public IEnumerable`1<BaseEventId> get_Events();
    private void AddToRegisteredEvents(BaseEventId eventId);
    public EventId RegisterEvent(string eventId, string eventDescription);
    public EventId1`1<T1> RegisterEvent(string eventId, string eventDescription, EventField`1<T1> eventField1);
    public EventId2`2<T1, T2> RegisterEvent(string eventId, string eventDescription, EventField`1<T1> eventField1, EventField`1<T2> eventField2);
    public EventId3`3<T1, T2, T3> RegisterEvent(string eventId, string eventDescription, EventField`1<T1> eventField1, EventField`1<T2> eventField2, EventField`1<T3> eventField3);
    public VarargEventId RegisterVarargEvent(string eventId, string eventDescription, EventField[] fields);
    public void ValidateEventId(string eventId);
    private bool IsEventIdValid(string eventId);
}
public class JetBrains.UsageStatistics.FUS.EventLog.EventLogInternalApplicationInfo : object {
    private static ILogger LOG;
    private bool myIsTest;
    private EventLogAppConnectionSettings myConnectionSettings;
    private string myRecorderId;
    private StatisticsUploadAssistant myStatisticsUploadAssistant;
    public EventLogInternalApplicationInfo(string recorderId, bool isTest, ActivityTrackingSettings activityTrackingSettings, StatisticsUploadAssistant statisticsUploadAssistant);
    private static EventLogInternalApplicationInfo();
    public sealed virtual string GetTemplateUrl();
    public sealed virtual string GetProductCode();
    public sealed virtual string GetProductVersion();
    public sealed virtual IEventLogConnectionSettings GetConnectionSettings();
    public sealed virtual bool IsInternal();
    public sealed virtual bool IsTest();
    public sealed virtual bool IsEAP();
    public sealed virtual ILogger GetLogger();
}
public class JetBrains.UsageStatistics.FUS.EventLog.EventLogInternalRecorderConfig : object {
    private string myRecorderId;
    private StatisticsEventLogProviderUtil myProviderUtil;
    public string RecorderId { get; }
    public EventLogInternalRecorderConfig(string recorderId, StatisticsEventLogProviderUtil providerUtil);
    public sealed virtual string get_RecorderId();
    public sealed virtual Task`1<bool> IsSendEnabledAsync();
    public sealed virtual Task`1<IEventLogFilesProvider> GetLogFilesProviderAsync();
}
public class JetBrains.UsageStatistics.FUS.EventLog.EventLogMajorVersion : object {
    public static int SNAPSHOT_VALUE;
    private Int32[] myComponents;
    public EventLogMajorVersion(Int32[] components);
    public Int32[] GetComponents();
    [CanBeNullAttribute]
public static EventLogMajorVersion FromString(string version);
    private static Int32[] ToIntArray(IReadOnlyList`1<string> components);
    private static int TryParseInt(string version);
    public sealed virtual int CompareTo(EventLogMajorVersion o);
    protected bool Equals(EventLogMajorVersion other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[ShellComponentAttribute("16")]
public class JetBrains.UsageStatistics.FUS.EventLog.EventLogRecorderConfigOptionsListener : object {
    private ILogger myLogger;
    private Dictionary`2<string, Action`2<string, int>> myHandlers;
    public EventLogRecorderConfigOptionsListener(ILogger logger);
    public sealed virtual void OptionsChanged(string recorderId, IDictionary`2<string, string> options);
    public void AdviseMachineIdConfigurationChanged(string recorderId, Action`2<string, int> onChange);
}
public class JetBrains.UsageStatistics.FUS.EventLog.EventLogRecorderConfiguration : object {
    private string myRecorderId;
    private EventLogConfiguration myEventLogConfiguration;
    private EventLogConfigOptionsService myConfigOptionsService;
    [CompilerGeneratedAttribute]
private string <DeviceId>k__BackingField;
    public string SessionId;
    [CompilerGeneratedAttribute]
private int <Bucket>k__BackingField;
    private Byte[] mySalt;
    private ConcurrentDictionary`2<string, string> myAnonymizedCache;
    private Lazy`1<MachineId> machineIdReference;
    public string DeviceId { get; }
    public int Bucket { get; }
    public MachineId MachineId { get; }
    internal EventLogRecorderConfiguration(string recorderId, EventLogConfiguration eventLogConfiguration, EventLogConfigOptionsService configOptionsService, EventLogRecorderConfigOptionsListener listener, EventLogConfigurationValueProvider eventLogConfigurationValueProvider, PermanentDeviceId permanentDeviceId);
    [CompilerGeneratedAttribute]
public string get_DeviceId();
    [CompilerGeneratedAttribute]
public int get_Bucket();
    public MachineId get_MachineId();
    private MachineId GenerateMachineId(string machineIdSalt, int value);
    public string Anonymize(string data);
    private int GetDeviceIdAsBucket(string deviceId);
    private static int NonNegativeAbs(int a);
    [CompilerGeneratedAttribute]
private void <.ctor>b__6_1(string salt, int revision);
}
public static class JetBrains.UsageStatistics.FUS.EventLog.EventLogSystemEvents : object {
    public static string COLLECTOR_REGISTERED;
    public static string STATE_COLLECTOR_INVOKED;
    public static string STATE_COLLECTOR_FAILED;
    public static string TOO_MANY_EVENTS_ALERT;
    public static string TOO_MANY_EVENTS;
    public static ISet`1<string> SYSTEM_EVENTS;
    private static EventLogSystemEvents();
}
[ShellComponentAttribute("16")]
public class JetBrains.UsageStatistics.FUS.EventLog.EventLogThresholdConfigOptionsListener : object {
    private Dictionary`2<string, ThresholdHandlers> myHandlers;
    public sealed virtual void OptionsChanged(string recorderId, IDictionary`2<string, string> options);
    public void AdviseChanges(Lifetime lifetime, string recorderId, Action`1<int> onThresholdChanged, Action`1<int> onGroupThresholdChanged, Action`1<int> onGroupAlertThresholdChanged);
}
public class JetBrains.UsageStatistics.FUS.EventLog.EventRateThrottleResult : EnumPattern {
    [CompilerGeneratedAttribute]
private bool <IsAccept>k__BackingField;
    public static EventRateThrottleResult ACCEPT;
    public static EventRateThrottleResult ALERT;
    public static EventRateThrottleResult DENY_AND_REPORT;
    public static EventRateThrottleResult DENY;
    public bool IsAccept { get; }
    public EventRateThrottleResult(string name, bool isAccept);
    private static EventRateThrottleResult();
    [CompilerGeneratedAttribute]
public bool get_IsAccept();
}
public abstract class JetBrains.UsageStatistics.FUS.EventLog.Events.BaseEventId : object {
    [CompilerGeneratedAttribute]
private FeatureUsageLogger <FeatureUsageLogger>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EventId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    public FeatureUsageLogger FeatureUsageLogger { get; }
    public string EventId { get; }
    public string Description { get; }
    protected BaseEventId(string eventId, string description, FeatureUsageLogger featureUsageLogger);
    [CompilerGeneratedAttribute]
public FeatureUsageLogger get_FeatureUsageLogger();
    [CompilerGeneratedAttribute]
public string get_EventId();
    [CompilerGeneratedAttribute]
public string get_Description();
    public abstract virtual IList`1<EventField> GetFields();
}
public class JetBrains.UsageStatistics.FUS.EventLog.Events.BooleanEventField : PrimitiveEventField`1<bool> {
    public BooleanEventField(string name, string description);
    public virtual void AddData(FeatureUsageData fuData, bool value);
}
public class JetBrains.UsageStatistics.FUS.EventLog.Events.BoundedIntEventField : PrimitiveEventField`1<int> {
    private Int32[] myBounds;
    public BoundedIntEventField(string name, string description, Int32[] bounds);
    public virtual void AddData(FeatureUsageData fuData, int value);
    public int RoundValue(int value);
}
public class JetBrains.UsageStatistics.FUS.EventLog.Events.DoubleEventField : PrimitiveEventField`1<double> {
    public DoubleEventField(string name, string description);
    public virtual void AddData(FeatureUsageData fuData, double value);
}
public class JetBrains.UsageStatistics.FUS.EventLog.Events.EnumEventField`1 : PrimitiveEventField`1<TE> {
    private Func`2<TE, string> myTransform;
    public EnumEventField`1(string name, string description, Func`2<TE, string> transform);
    public virtual void AddData(FeatureUsageData fuData, TE value);
}
public class JetBrains.UsageStatistics.FUS.EventLog.Events.EnumListEventField`1 : ListEventField`1<T> {
    public EnumListEventField`1(string name, string description);
    public virtual void AddData(FeatureUsageData fuData, IList`1<T> value);
}
public interface JetBrains.UsageStatistics.FUS.EventLog.Events.EventField {
    public string Name { get; }
    public string Description { get; }
    public abstract virtual string get_Name();
    public abstract virtual string get_Description();
}
public abstract class JetBrains.UsageStatistics.FUS.EventLog.Events.EventField`1 : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    public string Name { get; protected set; }
    public string Description { get; protected set; }
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
protected void set_Name(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Description();
    [CompilerGeneratedAttribute]
protected void set_Description(string value);
    public abstract virtual void AddData(FeatureUsageData fuData, T value);
}
[ExtensionAttribute]
public static class JetBrains.UsageStatistics.FUS.EventLog.Events.EventFieldEx : object {
    [ExtensionAttribute]
public static EventPair`1<T> With(EventField`1<T> field, T data);
}
[LocalizableAttribute("False")]
public static class JetBrains.UsageStatistics.FUS.EventLog.Events.EventFields : object {
    public static LongEventField DurationMs;
    private static EventFields();
    public static StringEventField StringValidatedByRegexp(string name, string description, string regexpRef);
    public static StringEventField StringValidatedByEnum(string name, string description, string enumRef);
    public static StringEventField StringValidatedByCustomRule(string name, string description, string customRuleId);
    public static StringEventField String(string name, string description, IEnumerable`1<string> allowedValues);
    public static IntEventField Int(string name, string description);
    public static RoundedIntEventField RoundedInt(string name, string description);
    public static BoundedIntEventField BoundedInt(string name, string description, Int32[] bounds);
    public static LongEventField Long(string name, string description);
    public static RoundedLongEventField RoundedLong(string name, string description);
    public static FloatEventField Float(string name, string description);
    public static DoubleEventField Double(string name, string description);
    public static BooleanEventField Boolean(string name, string description);
    public static TypeEventField Type(string name, string description);
    public static EnumEventField`1<T> Enum(string name, string description);
    public static EnumEventField`1<T> Enum(string name, string description, Func`2<T, string> transform);
    public static StringListEventField StringListValidatedByCustomRule(string name, string description, string customRuleId);
    public static StringListEventField StringListValidatedByEnum(string name, string description, string enumRef);
    public static StringListEventField StringListValidatedByRegexp(string name, string description, string regexpRef);
    public static StringListEventField StringList(string name, string description, IList`1<string> allowedValues);
    public static EnumListEventField`1<T> EnumList(string name, string description);
    public static LongListEventField LongList(string name, string description);
    public static StringEventField StringValidatedByInlineRegexp(string name, string description, string regexp);
    public static StringListEventField StringListValidatedByInlineRegexp(string name, string description, string regexp);
    public static AnonymizedIdField AnonymizedId(EventLogConfiguration eventLogConfiguration, string name, string description);
    public static Version2Field Version2(string name, string description);
    public static Version4Field Version4(string name, string description);
    public static IntEventField Count();
}
public class JetBrains.UsageStatistics.FUS.EventLog.Events.EventId : BaseEventId {
    [CompilerGeneratedAttribute]
private EventLogGroup <Group>k__BackingField;
    public EventLogGroup Group { get; }
    public EventId(EventLogGroup group, string eventId, string description, FeatureUsageLogger featureUsageLogger);
    [CompilerGeneratedAttribute]
public EventLogGroup get_Group();
    public void Log();
    public MetricEvent Metric();
    public virtual IList`1<EventField> GetFields();
}
public class JetBrains.UsageStatistics.FUS.EventLog.Events.EventId1`1 : BaseEventId {
    [CompilerGeneratedAttribute]
private EventLogGroup <Group>k__BackingField;
    private EventField`1<T> myField1;
    public EventLogGroup Group { get; }
    public EventId1`1(EventLogGroup group, string eventId, string description, EventField`1<T> field1, FeatureUsageLogger featureUsageLogger);
    [CompilerGeneratedAttribute]
public EventLogGroup get_Group();
    public void Log(T value1);
    public MetricEvent Metric(T value1);
    public FeatureUsageData BuildUsageData(T value1);
    public virtual IList`1<EventField> GetFields();
}
public class JetBrains.UsageStatistics.FUS.EventLog.Events.EventId2`2 : BaseEventId {
    [CompilerGeneratedAttribute]
private EventLogGroup <Group>k__BackingField;
    private EventField`1<T1> myField1;
    private EventField`1<T2> myField2;
    public EventLogGroup Group { get; }
    public EventId2`2(EventLogGroup group, string eventId, string description, EventField`1<T1> field1, EventField`1<T2> field2, FeatureUsageLogger featureUsageLogger);
    [CompilerGeneratedAttribute]
public EventLogGroup get_Group();
    public void Log(T1 value1, T2 value2);
    public MetricEvent Metric(T1 value1, T2 value2);
    public FeatureUsageData BuildUsageData(T1 value1, T2 value2);
    public virtual IList`1<EventField> GetFields();
}
public class JetBrains.UsageStatistics.FUS.EventLog.Events.EventId3`3 : BaseEventId {
    [CompilerGeneratedAttribute]
private EventLogGroup <Group>k__BackingField;
    private EventField`1<T1> myField1;
    private EventField`1<T2> myField2;
    private EventField`1<T3> myField3;
    public EventLogGroup Group { get; }
    public EventId3`3(EventLogGroup group, string eventId, string description, EventField`1<T1> field1, EventField`1<T2> field2, EventField`1<T3> field3, FeatureUsageLogger featureUsageLogger);
    [CompilerGeneratedAttribute]
public EventLogGroup get_Group();
    public void Log(T1 value1, T2 value2, T3 value3);
    public MetricEvent Metric(T1 value1, T2 value2, T3 value3);
    public FeatureUsageData BuildUsageData(T1 value1, T2 value2, T3 value3);
    public virtual IList`1<EventField> GetFields();
}
public abstract class JetBrains.UsageStatistics.FUS.EventLog.Events.EventPair : object {
    [CompilerGeneratedAttribute]
private EventField <Field>k__BackingField;
    public EventField Field { get; }
    protected EventPair(EventField field);
    [CompilerGeneratedAttribute]
public EventField get_Field();
    public abstract virtual void AddData(FeatureUsageData featureUsageData);
}
public class JetBrains.UsageStatistics.FUS.EventLog.Events.EventPair`1 : EventPair {
    [CompilerGeneratedAttribute]
private EventField`1<T> <Field>k__BackingField;
    [CompilerGeneratedAttribute]
private T <Data>k__BackingField;
    public EventField`1<T> Field { get; }
    public T Data { get; }
    public EventPair`1(EventField`1<T> field, T data);
    [CompilerGeneratedAttribute]
public EventField`1<T> get_Field();
    [CompilerGeneratedAttribute]
public T get_Data();
    public virtual void AddData(FeatureUsageData featureUsageData);
}
public class JetBrains.UsageStatistics.FUS.EventLog.Events.FloatEventField : PrimitiveEventField`1<float> {
    public FloatEventField(string name, string description);
    public virtual void AddData(FeatureUsageData fuData, float value);
}
public class JetBrains.UsageStatistics.FUS.EventLog.Events.IntEventField : PrimitiveEventField`1<int> {
    public IntEventField(string name, string description);
    public virtual void AddData(FeatureUsageData fuData, int value);
}
public interface JetBrains.UsageStatistics.FUS.EventLog.Events.ListEventField {
    public IList`1<string> ValidationRule { get; }
    public abstract virtual IList`1<string> get_ValidationRule();
}
public abstract class JetBrains.UsageStatistics.FUS.EventLog.Events.ListEventField`1 : EventField`1<IList`1<T>> {
    [CompilerGeneratedAttribute]
private IList`1<string> <ValidationRule>k__BackingField;
    public IList`1<string> ValidationRule { get; protected set; }
    [CompilerGeneratedAttribute]
public sealed virtual IList`1<string> get_ValidationRule();
    [CompilerGeneratedAttribute]
protected void set_ValidationRule(IList`1<string> value);
}
public class JetBrains.UsageStatistics.FUS.EventLog.Events.LongEventField : PrimitiveEventField`1<long> {
    public LongEventField(string name, string description);
    public virtual void AddData(FeatureUsageData fuData, long value);
}
public class JetBrains.UsageStatistics.FUS.EventLog.Events.LongListEventField : ListEventField`1<long> {
    public LongListEventField(string name, string description);
    public virtual void AddData(FeatureUsageData fuData, IList`1<long> value);
}
public class JetBrains.UsageStatistics.FUS.EventLog.Events.MetricEvent : object {
    private string myEventId;
    [CanBeNullAttribute]
private FeatureUsageData myData;
    public string EventId { get; }
    [CanBeNullAttribute]
public FeatureUsageData Data { get; }
    public MetricEvent(string eventId, FeatureUsageData data);
    public string get_EventId();
    public FeatureUsageData get_Data();
    public virtual string ToString();
    protected bool Equals(MetricEvent other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public abstract class JetBrains.UsageStatistics.FUS.EventLog.Events.ObjectDescription : object {
    public EventField[] GetFields();
}
public class JetBrains.UsageStatistics.FUS.EventLog.Events.ObjectEventData : object {
    private IList`1<EventPair> myValues;
    public ObjectEventData(IList`1<EventPair> values);
    public ObjectEventData(EventPair[] values);
    public IDictionary`2<string, object> BuildObjectData(EventField[] allowedFields);
}
public class JetBrains.UsageStatistics.FUS.EventLog.Events.ObjectEventField : EventField`1<ObjectEventData> {
    private EventField[] myFields;
    public ObjectEventField(string name, string description, EventField[] fields);
    public ObjectEventField(string name, string fieldDescription, ObjectDescription description);
    public virtual void AddData(FeatureUsageData fuData, ObjectEventData value);
}
public class JetBrains.UsageStatistics.FUS.EventLog.Events.ObjectListEventField : EventField`1<List`1<ObjectEventData>> {
    private EventField[] myFields;
    public ObjectListEventField(string name, string description, EventField[] fields);
    public virtual void AddData(FeatureUsageData fuData, List`1<ObjectEventData> value);
    [CompilerGeneratedAttribute]
private IDictionary`2<string, object> <AddData>b__2_0(ObjectEventData it);
}
public interface JetBrains.UsageStatistics.FUS.EventLog.Events.PrimitiveEventField {
    public IList`1<string> ValidationRule { get; }
    public abstract virtual IList`1<string> get_ValidationRule();
}
public abstract class JetBrains.UsageStatistics.FUS.EventLog.Events.PrimitiveEventField`1 : EventField`1<T> {
    [CompilerGeneratedAttribute]
private IList`1<string> <ValidationRule>k__BackingField;
    public IList`1<string> ValidationRule { get; protected set; }
    [CompilerGeneratedAttribute]
public sealed virtual IList`1<string> get_ValidationRule();
    [CompilerGeneratedAttribute]
protected void set_ValidationRule(IList`1<string> value);
}
public class JetBrains.UsageStatistics.FUS.EventLog.Events.RoundedIntEventField : PrimitiveEventField`1<int> {
    public RoundedIntEventField(string name, string description);
    public virtual void AddData(FeatureUsageData fuData, int value);
}
public class JetBrains.UsageStatistics.FUS.EventLog.Events.RoundedLongEventField : PrimitiveEventField`1<long> {
    public RoundedLongEventField(string name, string description);
    public virtual void AddData(FeatureUsageData fuData, long value);
}
public abstract class JetBrains.UsageStatistics.FUS.EventLog.Events.StringEventField : PrimitiveEventField`1<string> {
    protected StringEventField(string name, string description);
    public virtual void AddData(FeatureUsageData fuData, string value);
}
public abstract class JetBrains.UsageStatistics.FUS.EventLog.Events.StringListEventField : ListEventField`1<string> {
    protected StringListEventField(string name, string description);
    public virtual void AddData(FeatureUsageData fuData, IList`1<string> value);
}
public class JetBrains.UsageStatistics.FUS.EventLog.Events.TypeEventField : PrimitiveEventField`1<Type> {
    public TypeEventField(string name, string description);
    public virtual void AddData(FeatureUsageData fuData, Type value);
}
public class JetBrains.UsageStatistics.FUS.EventLog.Events.VarargEventId : BaseEventId {
    private List`1<EventField> myFields;
    [CompilerGeneratedAttribute]
private EventLogGroup <Group>k__BackingField;
    public EventLogGroup Group { get; }
    public VarargEventId(EventLogGroup group, string eventId, string description, FeatureUsageLogger featureUsageLogger, EventField[] fields);
    [CompilerGeneratedAttribute]
public EventLogGroup get_Group();
    public virtual IList`1<EventField> GetFields();
    public void Log(EventPair[] pairs);
    public void Log(IEnumerable`1<EventPair> pairs);
    public MetricEvent Metric(EventPair[] pairs);
    public MetricEvent Metric(IEnumerable`1<EventPair> pairs);
    public FeatureUsageData BuildUsageData(IEnumerable`1<EventPair> pairs);
}
public static class JetBrains.UsageStatistics.FUS.EventLog.EventsSchemeBuilder : object {
    private static ISet`1<FieldDescriptor> FieldSchema(EventField field, string eventName, string groupId);
    private static void ValidateRegexp(string regexp);
    public static List`1<GroupDescriptor> CollectGroupsFromExtensions(string groupType, IEnumerable`1<FeatureUsagesCollector> collectors);
    private static ISet`1<FieldDescriptor> BuildFields(List`1<BaseEventId> events, string eventName, string groupId);
    private static FieldDataType DefineDataType(IReadOnlyCollection`1<FieldDescriptor> values, string name, string eventName, string groupId);
}
public class JetBrains.UsageStatistics.FUS.EventLog.FeatureUsageData : object {
    private static ILogger LOG;
    [CompilerGeneratedAttribute]
private string <RecorderId>k__BackingField;
    private IDictionary`2<string, object> data;
    public static IList`1<string> PlatformDataKeys;
    public string RecorderId { get; }
    public FeatureUsageData(string recorderId);
    private static FeatureUsageData();
    [CompilerGeneratedAttribute]
public string get_RecorderId();
    public void SetDataValue(string key, object value);
    public FeatureUsageData AddVersion2ByString(string version, string name);
    public FeatureUsageData AddVersion4ByString(string version, string name);
    public FeatureUsageData AddVersion2(Version version, string name);
    public FeatureUsageData AddVersion4(Version version, string name);
    public FeatureUsageData AddAnonymizedPath(string path, EventLogConfiguration eventLogConfiguration);
    public FeatureUsageData AddAnonymizedId(string key, string id, EventLogConfiguration eventLogConfiguration);
    public FeatureUsageData AddAnonymizedValue(string key, string value, EventLogConfiguration eventLogConfiguration);
    public FeatureUsageData AddEnabled(bool enabled);
    public FeatureUsageData AddCount(int count);
    public FeatureUsageData AddData(string key, bool value);
    public FeatureUsageData AddData(string key, int value);
    public FeatureUsageData AddData(string key, long value);
    public FeatureUsageData AddData(string key, float value);
    public FeatureUsageData AddData(string key, double value);
    public FeatureUsageData AddData(string key, string value);
    public FeatureUsageData AddData(string key, IList`1<string> value);
    internal FeatureUsageData AddListLongData(string key, IList`1<long> value);
    internal FeatureUsageData AddObjectData(string key, IDictionary`2<string, object> value);
    internal FeatureUsageData AddListObjectData(string key, List`1<IDictionary`2<string, object>> value);
    private FeatureUsageData AddDataInternal(string key, object value);
    public IDictionary`2<string, object> Build();
    public FeatureUsageData AddAll(FeatureUsageData from);
    public FeatureUsageData Merge(FeatureUsageData next, string prefix);
    public FeatureUsageData Copy();
    protected bool Equals(FeatureUsageData other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class JetBrains.UsageStatistics.FUS.EventLog.FilteredEventMergeStrategy : object {
    private ISet`1<string> myIgnoredFields;
    public FilteredEventMergeStrategy(ISet`1<string> ignoredFields);
    public sealed virtual bool ShouldMerge(LogEvent lastEvent, LogEvent newEvent);
    private bool ShouldMergeEvents(LogEventAction lastEvent, LogEventAction newEvent);
}
public interface JetBrains.UsageStatistics.FUS.EventLog.Filters.ILogEventFilter {
    public abstract virtual bool Accepts(LogEvent ev);
}
public class JetBrains.UsageStatistics.FUS.EventLog.Filters.LogEventBucketsFilter : object {
    private IList`1<EventLogBucketRange> myBuckets;
    public LogEventBucketsFilter(IList`1<EventLogBucketRange> buckets);
    public sealed virtual bool Accepts(LogEvent ev);
}
public class JetBrains.UsageStatistics.FUS.EventLog.Filters.LogEventCompositeFilter : object {
    private ILogEventFilter[] myFilters;
    public LogEventCompositeFilter(ILogEventFilter[] filters);
    public sealed virtual bool Accepts(LogEvent ev);
}
public class JetBrains.UsageStatistics.FUS.EventLog.Filters.LogEventFalseFilter : object {
    public static LogEventFalseFilter INSTANCE;
    private static LogEventFalseFilter();
    public sealed virtual bool Accepts(LogEvent ev);
}
public class JetBrains.UsageStatistics.FUS.EventLog.Filters.LogEventMetadataFilter`1 : object {
    private EventGroupsFilterRules`1<T> myFilterRules;
    public LogEventMetadataFilter`1(EventGroupsFilterRules`1<T> filterRules);
    public sealed virtual bool Accepts(LogEvent ev);
}
public class JetBrains.UsageStatistics.FUS.EventLog.Filters.LogEventSnapshotBuildFilter : object {
    public static LogEventSnapshotBuildFilter INSTANCE;
    private static LogEventSnapshotBuildFilter();
    public sealed virtual bool Accepts(LogEvent ev);
}
public class JetBrains.UsageStatistics.FUS.EventLog.Filters.LogEventTrueFilter : object {
    public sealed virtual bool Accepts(LogEvent ev);
}
[ShellComponentAttribute("16")]
public class JetBrains.UsageStatistics.FUS.EventLog.Fus.FeatureUsageEventLoggerProvider : StatisticsEventLoggerProvider {
    private StatisticsUploadAssistant myStatisticsUploadAssistant;
    public FeatureUsageEventLoggerProvider(Lifetime lifetime, EventLogConfiguration eventLogConfiguration, EventLogConfigOptionsService eventLogConfigOptionsService, EventLogThresholdConfigOptionsListener eventLogThresholdConfigOptionsListener, StatisticsUploadAssistant statisticsUploadAssistant, IStatisticsSystemEventIdProvider statisticsSystemEventIdProvider, DotnetSensitiveDataValidatorProvider dotnetSensitiveDataValidatorProvider, IThreading threading);
    public virtual Task`1<bool> IsRecordEnabledAsync();
    [AsyncStateMachineAttribute("JetBrains.UsageStatistics.FUS.EventLog.Fus.FeatureUsageEventLoggerProvider/<IsSendEnabledAsync>d__3")]
public virtual Task`1<bool> IsSendEnabledAsync();
}
[ShellComponentAttribute("16")]
public class JetBrains.UsageStatistics.FUS.EventLog.Fus.FeatureUsageLogger : object {
    private ILogger myLogger;
    [CompilerGeneratedAttribute]
private StatisticsEventLoggerProvider <LoggerProvider>k__BackingField;
    public StatisticsEventLoggerProvider LoggerProvider { get; public set; }
    public FeatureUsageLogger(StatisticsEventLogProviderUtil statisticsEventLogProviderUtil, ILogger logger);
    [CompilerGeneratedAttribute]
public StatisticsEventLoggerProvider get_LoggerProvider();
    [CompilerGeneratedAttribute]
public void set_LoggerProvider(StatisticsEventLoggerProvider value);
    public void Log(EventLogGroup group, string action);
    public void Log(EventLogGroup group, string action, IDictionary`2<string, object> data);
    public void Log(EventLogGroup group, string action, Func`1<IDictionary`2<string, object>> data);
    protected virtual void WithLogger(Func`2<IStatisticsEventLogger, Task> logAsync);
    public void LogState(EventLogGroup group, string action);
    public void LogState(EventLogGroup group, string action, IDictionary`2<string, object> data);
}
public interface JetBrains.UsageStatistics.FUS.EventLog.IEventLogApplicationInfo {
    [NotNullAttribute]
public abstract virtual string GetTemplateUrl();
    [NotNullAttribute]
public abstract virtual string GetProductCode();
    [NotNullAttribute]
public abstract virtual string GetProductVersion();
    [NotNullAttribute]
public abstract virtual IEventLogConnectionSettings GetConnectionSettings();
    public abstract virtual bool IsInternal();
    public abstract virtual bool IsTest();
    public abstract virtual bool IsEAP();
    [NotNullAttribute]
public abstract virtual ILogger GetLogger();
}
[DerivedComponentsInstantiationRequirementAttribute("1")]
public interface JetBrains.UsageStatistics.FUS.EventLog.IEventLogConfigOptionsListener {
    public abstract virtual void OptionsChanged(string recorderId, IDictionary`2<string, string> options);
}
public interface JetBrains.UsageStatistics.FUS.EventLog.IEventLogFilesProvider {
    [CanBeNullAttribute]
public abstract virtual FileSystemPath GetLogFilesDir();
    public abstract virtual IList`1<EventLogFile> GetLogFiles();
    public abstract virtual void Rollover();
}
public interface JetBrains.UsageStatistics.FUS.EventLog.IEventLogRecorderConfig {
    public string RecorderId { get; }
    public abstract virtual string get_RecorderId();
    public abstract virtual Task`1<bool> IsSendEnabledAsync();
    public abstract virtual Task`1<IEventLogFilesProvider> GetLogFilesProviderAsync();
}
public interface JetBrains.UsageStatistics.FUS.EventLog.IStatisticsEventLogger {
    public abstract virtual Task LogAsync(EventLogGroup group, string eventId, IDictionary`2<string, object> data, bool isState);
    [CanBeNullAttribute]
public abstract virtual EventLogFile GetActiveLogFile();
    public abstract virtual IEventLogFilesProvider GetLogFilesProvider();
    public abstract virtual void Cleanup();
    public abstract virtual void RollOver();
}
public interface JetBrains.UsageStatistics.FUS.EventLog.IStatisticsEventLogWriter {
    public abstract virtual void Log(LogEvent logEvent);
    [CanBeNullAttribute]
public abstract virtual EventLogFile GetActiveFile();
    public abstract virtual IEventLogFilesProvider GetLogFilesProvider();
    public abstract virtual void Cleanup();
    public abstract virtual void RollOver();
}
public interface JetBrains.UsageStatistics.FUS.EventLog.IStatisticsEventMergeStrategy {
    public abstract virtual bool ShouldMerge(LogEvent lastEvent, LogEvent newEvent);
}
public interface JetBrains.UsageStatistics.FUS.EventLog.IStatisticsSystemEventIdProvider {
    public abstract virtual long GetSystemEventId(string recorderId);
    public abstract virtual void SetSystemEventId(string recorderId, long eventId);
}
public class JetBrains.UsageStatistics.FUS.EventLog.LogEvent : object {
    [CompilerGeneratedAttribute]
private long <Time>k__BackingField;
    [CompilerGeneratedAttribute]
private LogEventAction <Event>k__BackingField;
    [CompilerGeneratedAttribute]
private LogEventGroup <Group>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Build>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Bucket>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RecorderVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Session>k__BackingField;
    public long Time { get; }
    public LogEventAction Event { get; }
    public LogEventGroup Group { get; }
    public string Build { get; }
    public string Bucket { get; }
    [JsonPropertyAttribute("recorder_version")]
public string RecorderVersion { get; }
    public string Session { get; }
    public LogEvent(string session, string build, string bucket, long eventTime, string groupId, string groupVersion, string recorderVersion, LogEventAction eventAction);
    [CompilerGeneratedAttribute]
public long get_Time();
    [CompilerGeneratedAttribute]
public LogEventAction get_Event();
    [CompilerGeneratedAttribute]
public LogEventGroup get_Group();
    [CompilerGeneratedAttribute]
public string get_Build();
    [CompilerGeneratedAttribute]
public string get_Bucket();
    [CompilerGeneratedAttribute]
public string get_RecorderVersion();
    [CompilerGeneratedAttribute]
public string get_Session();
    public static LogEvent NewLogEvent(string session, string build, string bucket, long time, string groupId, string groupVersion, string recorderVersion, LogEventAction ev);
    public static LogEvent NewLogEvent(string session, string build, string bucket, long time, string groupId, string groupVersion, string recorderVersion, string eventId, bool isState, IDictionary`2<string, object> eventData);
    protected bool Equals(LogEvent other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class JetBrains.UsageStatistics.FUS.EventLog.LogEventAction : object {
    public string Id;
    public bool State;
    public int Count;
    public IDictionary`2<string, object> Data;
    public LogEventAction(string id, bool state, int count);
    public void Increment();
    public bool IsEventGroup();
    public bool ShouldMerge(LogEventAction next);
    public void AddData(string key, object value);
    private object EscapeValue(object value);
    protected bool Equals(LogEventAction other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
private object <EscapeValue>b__9_0(object it);
}
public class JetBrains.UsageStatistics.FUS.EventLog.LogEventDeserializer : object {
    private ILogger myLogger;
    public LogEventDeserializer(ILogger logger);
    public LogEvent FromString(string line);
    private object TransformNumbers(object value);
    private LogEventAction CreateAction(JObject obj);
    [CompilerGeneratedAttribute]
private object <TransformNumbers>b__3_0(JToken it);
    [CompilerGeneratedAttribute]
private object <TransformNumbers>b__3_1(object it);
}
public class JetBrains.UsageStatistics.FUS.EventLog.LogEventGroup : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    public string Id { get; }
    public string Version { get; }
    public LogEventGroup(string id, string version);
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public string get_Version();
    protected bool Equals(LogEventGroup other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class JetBrains.UsageStatistics.FUS.EventLog.LogEventRecord : object {
    [CompilerGeneratedAttribute]
private IList`1<LogEvent> <Events>k__BackingField;
    public IList`1<LogEvent> Events { get; }
    public LogEventRecord(IList`1<LogEvent> events);
    [CompilerGeneratedAttribute]
public IList`1<LogEvent> get_Events();
    protected bool Equals(LogEventRecord other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class JetBrains.UsageStatistics.FUS.EventLog.LogEventRecordRequest : object {
    internal string recorder;
    internal string product;
    internal string device;
    public List`1<LogEventRecord> records;
    internal bool internal;
    private static int RECORD_SIZE;
    public LogEventRecordRequest(string recorder, string product, string device, List`1<LogEventRecord> records, bool internal);
    public static LogEventRecordRequest Create(FileSystemPath file, string recorder, string product, string deviceId, ILogEventFilter filter, bool isInternal, ILogger logger, MachineId machineId);
    public static LogEventRecordRequest Create(FileSystemPath file, string recorder, string product, string user, int maxRecordSize, ILogEventFilter filter, bool isInternal, ILogger logger, MachineId machineId);
    [CanBeNullAttribute]
private static string FillNextBatch(StreamReader reader, string firstLine, List`1<LogEvent> events, LogEventDeserializer deserializer, LogEventRecordSizeEstimator estimator, int maxRecordSize, ILogEventFilter filter, MachineId machineId);
    public static void FillMachineId(LogEvent ev, MachineId machineId);
    protected bool Equals(LogEventRecordRequest other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class JetBrains.UsageStatistics.FUS.EventLog.LogEventRecordSizeEstimator : object {
    private int myFormatAdditionalSize;
    public LogEventRecordSizeEstimator(string product, string user);
    public int Estimate(string line);
}
public class JetBrains.UsageStatistics.FUS.EventLog.LogEventSerializer : object {
    public static string GetString(LogEventRecordRequest request);
    public static JObject ToJson(LogEvent ev);
    public static string GetString(LogEvent ev);
}
public class JetBrains.UsageStatistics.FUS.EventLog.MachineId : object {
    [CompilerGeneratedAttribute]
private string <ID>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Revision>k__BackingField;
    public static MachineId DISABLED;
    public static MachineId UNKNOWN;
    public string ID { get; }
    public int Revision { get; }
    public MachineId(string id, int revision);
    private static MachineId();
    [CompilerGeneratedAttribute]
public string get_ID();
    protected bool Equals(MachineId other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public int get_Revision();
    public virtual string ToString();
}
[ShellComponentAttribute("16")]
public class JetBrains.UsageStatistics.FUS.EventLog.PopulateBuildForFus : object {
    public double Priority { get; }
    public string ClipboardData { get; }
    public RichText DisplayText { get; }
    public sealed virtual double get_Priority();
    public sealed virtual string get_ClipboardData();
    public sealed virtual RichText get_DisplayText();
}
public static class JetBrains.UsageStatistics.FUS.EventLog.StatisticsEventEscaper : object {
    private static string SYMBOLS_TO_REPLACE;
    private static string SYMBOLS_TO_REPLACE_FIELD_NAME;
    private static StatisticsEventEscaper();
    [NotNullAttribute]
public static string EscapeEventIdOrFieldValue(string str);
    [NotNullAttribute]
public static string Escape(string str);
    [NotNullAttribute]
public static string EscapeFieldName(string str);
    [CanBeNullAttribute]
public static string CleanupForLegacyRulesIfNeeded(string str);
    [NotNullAttribute]
private static string EscapeInternal(string str, string toReplace, bool allowSpaces);
    [NotNullAttribute]
private static string Replace(string value, string toReplace, bool allowSpaces);
    private static bool ContainsSystemSymbols(string value, string toReplace);
    private static bool IsAscii(char c);
    private static bool IsSymbolToReplace(char c, string toReplace);
    public static bool IsWhiteSpaceToReplace(char c);
    private static bool IsAsciiControl(char c);
    private static bool IsProhibitedSymbol(char c);
    private static bool ContainsChar(string str, char c);
}
public class JetBrains.UsageStatistics.FUS.EventLog.StatisticsEventLogFileAppender : object {
    protected long maxFileAge;
    protected long maxFileSize;
    private long nextRollover;
    protected long oldestExistingFile;
    private string mySuffix;
    private EventLogBuildType myBuildType;
    private FileSystemPath myLogDirectory;
    private Func`1<ICollection`1<AppenderFilePath>> myFilesProducer;
    private ILogger myLogger;
    private SequentialLifetimes myWriterSequence;
    private object myFileLock;
    private CurrentLog myCurrentLog;
    public string ActiveLogName { get; }
    protected StatisticsEventLogFileAppender(FileSystemPath path, ICollection`1<AppenderFilePath> files);
    public StatisticsEventLogFileAppender(Lifetime lifetime, FileSystemPath dir, string suffix, EventLogBuildType buildType, FileSystemPath filename);
    public string get_ActiveLogName();
    public static StatisticsEventLogFileAppender Create(Lifetime lifetime, FileSystemPath dir, string suffix, bool isEap);
    [CanBeNullAttribute]
public virtual string GetActiveLogName();
    public void SetMaxFileAge(long maxAge);
    public void SetMaxFileSize(string value);
    private long ToFileSize(string value, long defValue);
    public void SetFile(FileSystemPath fileName);
    protected void SubAppend(string evt);
    public void RollOver();
    public virtual void CleanUpOldFiles();
    public virtual void CleanUpOldFiles(long oldestAcceptable);
    public void CleanUp();
    public void Log(string s);
}
public class JetBrains.UsageStatistics.FUS.EventLog.StatisticsEventLogFileWriter : object {
    private EventLogConfiguration myEventLogConfiguration;
    private string myRecorderId;
    [CanBeNullAttribute]
private StatisticsEventLogFileAppender myFileAppender;
    private ILogger myLogger;
    private LifetimeDefinition myLifetimeDefinition;
    public StatisticsEventLogFileWriter(Lifetime lifetime, EventLogConfiguration eventLogConfiguration, string recorderId, string maxFileSize, bool isEap, string prefix);
    private FileSystemPath GetEventLogDir();
    public sealed virtual void Log(LogEvent logEvent);
    public sealed virtual EventLogFile GetActiveFile();
    public sealed virtual IEventLogFilesProvider GetLogFilesProvider();
    public sealed virtual void Cleanup();
    public sealed virtual void RollOver();
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
private string <GetLogFilesProvider>b__9_0();
}
[ExtensionAttribute]
public static class JetBrains.UsageStatistics.FUS.EventLog.StatisticsEventLoggerEx : object {
    [ExtensionAttribute]
public static Task LogAsync(IStatisticsEventLogger t, EventLogGroup group, string eventId, bool isState);
}
public abstract class JetBrains.UsageStatistics.FUS.EventLog.StatisticsEventLoggerProvider : object {
    private Lifetime myLifetime;
    private string myMaxFileSize;
    private EventLogConfiguration myEventLogConfiguration;
    private EventLogConfigOptionsService myEventLogConfigOptionsService;
    [CompilerGeneratedAttribute]
private string <RecorderId>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private long <SendFrequencyMs>k__BackingField;
    private AsyncLazy`1<IStatisticsEventLogger> myLogger;
    private EventLogThresholdConfigOptionsListener myEventLogThresholdConfigOptionsListener;
    private IStatisticsSystemEventIdProvider myStatisticsSystemEventIdProvider;
    private IThreading myThreading;
    private DotnetSensitiveDataValidatorProvider myDotnetSensitiveDataValidatorProvider;
    public string RecorderId { get; }
    public int Version { get; }
    public long SendFrequencyMs { get; }
    protected StatisticsEventLoggerProvider(Lifetime lifetime, EventLogConfiguration eventLogConfiguration, EventLogConfigOptionsService eventLogConfigOptionsService, EventLogThresholdConfigOptionsListener eventLogThresholdConfigOptionsListener, IStatisticsSystemEventIdProvider statisticsSystemEventIdProvider, DotnetSensitiveDataValidatorProvider dotnetSensitiveDataValidatorProvider, IThreading threading, string recorderId, int version, long sendFrequencyMs, string maxFileSize);
    [CompilerGeneratedAttribute]
public string get_RecorderId();
    [CompilerGeneratedAttribute]
public int get_Version();
    [CompilerGeneratedAttribute]
public long get_SendFrequencyMs();
    public virtual Task`1<IStatisticsEventLogger> GetLoggerAsync();
    [AsyncStateMachineAttribute("JetBrains.UsageStatistics.FUS.EventLog.StatisticsEventLoggerProvider/<CreateLoggerAsync>d__20")]
protected virtual Task`1<IStatisticsEventLogger> CreateLoggerAsync();
    public abstract virtual Task`1<bool> IsRecordEnabledAsync();
    public abstract virtual Task`1<bool> IsSendEnabledAsync();
    [AsyncStateMachineAttribute("JetBrains.UsageStatistics.FUS.EventLog.StatisticsEventLoggerProvider/<GetActiveLogFileAsync>d__23")]
[CanBeNullAttribute]
public Task`1<EventLogFile> GetActiveLogFileAsync();
    [AsyncStateMachineAttribute("JetBrains.UsageStatistics.FUS.EventLog.StatisticsEventLoggerProvider/<GetLogFilesProviderAsync>d__24")]
public Task`1<IEventLogFilesProvider> GetLogFilesProviderAsync();
}
[ShellComponentAttribute("16")]
public class JetBrains.UsageStatistics.FUS.EventLog.StatisticsEventLogProviderUtil : object {
    private Lifetime myLifetime;
    private IEnumerable`1<StatisticsEventLoggerProvider> myProviders;
    private ILogger myLog;
    private EventLogConfiguration myEventLogConfiguration;
    private EventLogConfigOptionsService myEventLogConfigOptionsService;
    private EventLogThresholdConfigOptionsListener myEventLogThresholdConfigOptionsListener;
    private IStatisticsSystemEventIdProvider myStatisticsSystemEventIdProvider;
    private DotnetSensitiveDataValidatorProvider myDotnetSensitiveDataValidatorProvider;
    private IThreading myThreading;
    public StatisticsEventLogProviderUtil(Lifetime lifetime, IEnumerable`1<StatisticsEventLoggerProvider> providers, ILogger logger, EventLogConfiguration eventLogConfiguration, EventLogConfigOptionsService eventLogConfigOptionsService, EventLogThresholdConfigOptionsListener eventLogThresholdConfigOptionsListener, IStatisticsSystemEventIdProvider statisticsSystemEventIdProvider, DotnetSensitiveDataValidatorProvider dotnetSensitiveDataValidatorProvider, IThreading threading);
    public StatisticsEventLoggerProvider GetEventLogProvider(string recorderId);
    private bool IsJetBrainsProduct();
    private bool IsProviderApplicable(bool isJetBrainsProduct, string recorderId, StatisticsEventLoggerProvider extension);
    public IEnumerable`1<StatisticsEventLoggerProvider> GetEventLogProviders();
}
public class JetBrains.UsageStatistics.FUS.EventLog.StatisticsEventLogThrottleWriter : object {
    private string myRecorderVersion;
    private IStatisticsEventLogWriter myInnerWriter;
    private object myLock;
    private EventsRateWindowThrottle myThrottle;
    private EventsIdentityWindowThrottle myGroupThrottle;
    public StatisticsEventLogThrottleWriter(Lifetime lifetime, EventLogConfigOptionsService configOptionsService, string recorderId, string recorderVersion, IStatisticsEventLogWriter innerWriter, EventLogThresholdConfigOptionsListener eventLogThresholdConfigOptionsListener);
    private int GetOrDefault(int value, int defaultValue);
    public sealed virtual void Log(LogEvent logEvent);
    private LogEvent CopyEvent(string eventId, string groupId, string groupVersion, LogEvent logEvent);
    private EventsRateResult TryPass(string group, long now);
    public sealed virtual EventLogFile GetActiveFile();
    public sealed virtual IEventLogFilesProvider GetLogFilesProvider();
    public sealed virtual void Cleanup();
    public sealed virtual void RollOver();
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
private void <.ctor>b__5_0(int newValue);
    [CompilerGeneratedAttribute]
private void <.ctor>b__5_1(int newValue);
    [CompilerGeneratedAttribute]
private void <.ctor>b__5_2(int newValue);
}
public class JetBrains.UsageStatistics.FUS.EventLog.StatisticsFileEventLogger : object {
    private string myRecorderId;
    private string mySessionId;
    private bool myHeadless;
    private string myBuild;
    private string myBucket;
    private string myRecorderVersion;
    private IStatisticsEventLogWriter myWriter;
    private IStatisticsSystemEventIdProvider mySystemEventIdProvider;
    private DotnetSensitiveDataValidatorProvider myValidatorProvider;
    private long myEventMergeTimeoutMs;
    private ILogger myLogger;
    private LifetimeDefinition myLifetimeDefinition;
    private bool myIsSyncOnly;
    private object myActiveLock;
    [CanBeNullAttribute]
private FusEvent lastEvent;
    private long lastEventTime;
    private long lastEventCreatedTime;
    private IStatisticsEventMergeStrategy mergeStrategy;
    private bool myIsActive;
    private SingleThreadExecutor myExecutor;
    private Nullable`1<bool> myIsEnvVarEnabled;
    public StatisticsFileEventLogger(string recorderId, string sessionId, bool headless, string build, string bucket, string recorderVersion, IStatisticsEventLogWriter writer, IStatisticsSystemEventIdProvider systemEventIdProvider, DotnetSensitiveDataValidatorProvider validatorProvider, IThreading locks);
    private void Log(LogEvent evt, long createdTime, string rawEventId, IDictionary`2<string, object> rawData);
    private void LogLastEvent();
    private void QueueFlush();
    public virtual void Dispose();
    public sealed virtual Task LogAsync(EventLogGroup group, string eventId, IDictionary`2<string, object> data, bool isState);
    public sealed virtual EventLogFile GetActiveLogFile();
    public sealed virtual IEventLogFilesProvider GetLogFilesProvider();
    public sealed virtual void Cleanup();
    public sealed virtual void RollOver();
    [CompilerGeneratedAttribute]
private void <.ctor>b__14_0(Task task);
    [CompilerGeneratedAttribute]
private void <Dispose>b__23_0();
    [CompilerGeneratedAttribute]
private void <Dispose>b__23_1();
}
public class JetBrains.UsageStatistics.FUS.EventLog.Validator.GroupValidators`1 : object {
    [CanBeNullAttribute]
public EventGroupRules eventGroupRules;
    [CanBeNullAttribute]
public EventGroupsFilterRules`1<T> versionFilter;
    public GroupValidators`1(EventGroupRules eventGroupRules, EventGroupsFilterRules`1<T> versionFilter);
}
public interface JetBrains.UsageStatistics.FUS.EventLog.Validator.IValidationRuleStorage {
    public abstract virtual bool IsUnreachable();
    public abstract virtual bool VersionAccepts(string groupId, string groupVersion, string build);
    [CanBeNullAttribute]
public abstract virtual EventGroupRules GetGroupRules(string groupId);
}
public class JetBrains.UsageStatistics.FUS.EventLog.Validator.Rules.AcceptedFusRule : ConstantFusRule {
}
public class JetBrains.UsageStatistics.FUS.EventLog.Validator.Rules.ConstantFusRule : object {
    private ValidationResultType myResult;
    public ConstantFusRule(ValidationResultType result);
    public sealed virtual ValidationResultType Validate(string data, EventContext context);
}
public class JetBrains.UsageStatistics.FUS.EventLog.Validator.Rules.EventContext : object {
    public string eventId;
    public IDictionary`2<string, object> eventData;
    public IDictionary`2<string, object> myPayload;
    private EventContext(string eventId, IDictionary`2<string, object> eventData);
    [NotNullAttribute]
public static IDictionary`2<string, object> UnmodifiableOrEmptyMap(IDictionary`2<string, object> original);
    public static EventContext Create(string eventId, IDictionary`2<string, object> eventData);
    [CanBeNullAttribute]
public T GetPayload(PayloadKey`1<T> key);
    public void SetPayload(PayloadKey`1<T> key, T value);
}
public class JetBrains.UsageStatistics.FUS.EventLog.Validator.Rules.EventDataField : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    public string Name { get; }
    public object Value { get; }
    public EventDataField(string name, object value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public object get_Value();
    public void Deconstruct(String& name, Object& value);
}
public class JetBrains.UsageStatistics.FUS.EventLog.Validator.Rules.EventGroupContextData : object {
    public static EventGroupContextData EMPTY;
    [CanBeNullAttribute]
private IDictionary`2<string, ISet`1<string>> myEnums;
    [CanBeNullAttribute]
private IDictionary`2<string, string> myRegexps;
    [CanBeNullAttribute]
private GlobalRulesHolder myGlobalRulesHolder;
    public EventGroupContextData(IDictionary`2<string, ISet`1<string>> enums, IDictionary`2<string, string> regexps, GlobalRulesHolder globalRulesHolder);
    private static EventGroupContextData();
    [NotNullAttribute]
public EnumValidationRule GetEnumValidationRule(string enumRef);
    [NotNullAttribute]
public RegexpValidationRule GetRegexpValidationRule(string regexpRef);
}
public class JetBrains.UsageStatistics.FUS.EventLog.Validator.Rules.EventGroupRules : object {
    public static EventGroupRules EMPTY;
    private FUSRule[] myEventIdRules;
    private IDictionary`2<string, FUSRule[]> myEventDataRules;
    private IList`1<string> VALIDATION_TYPES;
    private IList`1<string> myExcludedFields;
    private EventGroupRules(ISet`1<string> eventIdRules, IDictionary`2<string, ISet`1<string>> eventDataRules, EventGroupContextData contextData, ValidationSimpleRuleFactory factory, IList`1<string> excludedFields);
    private static EventGroupRules();
    public FUSRule[] GetEventIdRules();
    public IDictionary`2<string, FUSRule[]> GetEventDataRules();
    public bool AreEventIdRulesDefined();
    public ValidationResultType ValidateEventId(EventContext context);
    public EventDataField ValidateEventData(string key, object data, EventContext context);
    private EventDataField ValidateEventData(string key, object data, EventContext context, string fieldName);
    private static object ValidateValue(object data, EventContext context, FUSRule[] rules);
    private static ValidationResultType AcceptRule(string ruleData, EventContext context, FUSRule[] rules);
    [NotNullAttribute]
public static EventGroupRules Create(EventGroupRemoteDescriptor group, GlobalRulesHolder globalRulesHolder, ValidationSimpleRuleFactory factory, IList`1<string> excludedFields);
}
public interface JetBrains.UsageStatistics.FUS.EventLog.Validator.Rules.FUSRule {
    [NotNullAttribute]
public abstract virtual ValidationResultType Validate(string data, EventContext context);
}
public static class JetBrains.UsageStatistics.FUS.EventLog.Validator.Rules.FUSRuleUtils : object {
    public static FUSRule[] EMPTY_ARRAY;
    public static FUSRule TRUE;
    public static FUSRule FALSE;
    private static FUSRuleUtils();
}
public interface JetBrains.UsageStatistics.FUS.EventLog.Validator.Rules.IFusRegexpAwareRule {
    [NotNullAttribute]
public abstract virtual string AsRegexp();
}
[ShellComponentAttribute("16")]
public class JetBrains.UsageStatistics.FUS.EventLog.Validator.Rules.Impl.ActionIdValidationRule : CustomValidationRule {
    private ILazy`1<ActionManager> myActionManager;
    public ActionIdValidationRule(ILazy`1<ActionManager> actionManager);
    protected virtual ValidationResultType DoValidate(string data, EventContext context);
    public virtual bool AcceptRuleId(string ruleId);
}
[ShellComponentAttribute("16")]
public class JetBrains.UsageStatistics.FUS.EventLog.Validator.Rules.Impl.ClassNameValidationRule : CustomValidationRule {
    public static PayloadKey`1<string> Key;
    private static ClassNameValidationRule();
    protected virtual ValidationResultType DoValidate(string data, EventContext context);
    public virtual bool AcceptRuleId(string ruleId);
}
public abstract class JetBrains.UsageStatistics.FUS.EventLog.Validator.Rules.Impl.CustomValidationRule : PerformanceCareRule {
    public abstract virtual bool AcceptRuleId(string ruleId);
    [NotNullAttribute]
protected static ValidationResultType AcceptWhenReportedByPluginFromPluginRepository(EventContext context);
    protected static bool IsThirdPartyValue(string data);
    [CanBeNullAttribute]
protected string GetEventDataField(EventContext context, string name);
}
public class JetBrains.UsageStatistics.FUS.EventLog.Validator.Rules.Impl.EnumValidationRule : PerformanceCareRule {
    private IReadOnlyCollection`1<string> myEnumValues;
    public EnumValidationRule(ICollection`1<string> strings);
    protected virtual ValidationResultType DoValidate(string data, EventContext context);
    public sealed virtual string AsRegexp();
    public virtual string ToString();
}
public class JetBrains.UsageStatistics.FUS.EventLog.Validator.Rules.Impl.ExpressionValidationRule : PerformanceCareRule {
    [NotNullAttribute]
private FUSRule myRule;
    [NotNullAttribute]
private string myPrefix;
    [NotNullAttribute]
private string mySuffix;
    public ExpressionValidationRule(FUSRule rule, string prefix, string suffix);
    protected virtual ValidationResultType DoValidate(string data, EventContext context);
    [NotNullAttribute]
private ValidationResultType ValidateEscaped(string escapedData, EventContext context);
    private bool AcceptPrefix(string data);
    private bool AcceptSuffix(string data);
    public virtual string ToString();
}
public interface JetBrains.UsageStatistics.FUS.EventLog.Validator.Rules.Impl.IUtilValidationRule {
}
public static class JetBrains.UsageStatistics.FUS.EventLog.Validator.Rules.Impl.JetBrainsSettingsSchemaCache : object {
    private static ConcurrentDictionary`2<string, SettingsKey> ourSettingsKeys;
    private static JetBrainsSettingsSchemaCache();
    [CanBeNullAttribute]
public static SettingsKey GetValidatedSettingsKeyFromPath(string path, ISettingsStore settingsStore);
}
public abstract class JetBrains.UsageStatistics.FUS.EventLog.Validator.Rules.Impl.LocalEnumCustomValidationRule`1 : CustomValidationRule {
    [NotNullAttribute]
private string myRule;
    protected LocalEnumCustomValidationRule`1(string rule);
    public virtual bool AcceptRuleId(string ruleId);
    protected virtual ValidationResultType DoValidate(string data, EventContext context);
}
public class JetBrains.UsageStatistics.FUS.EventLog.Validator.Rules.Impl.RegexpValidationRule : PerformanceCareRule {
    [CanBeNullAttribute]
private string regexp;
    private Lazy`1<Regex> myPattern;
    private static JetHashSet`1<char> ESCAPE_FROM;
    public RegexpValidationRule(string regexp);
    private static RegexpValidationRule();
    protected virtual ValidationResultType DoValidate(string data, EventContext context);
    public sealed virtual string AsRegexp();
    public virtual string ToString();
    private Regex ComputePattern(string regexp);
    public static string EscapeText(string text);
}
[ShellComponentAttribute("16")]
public class JetBrains.UsageStatistics.FUS.EventLog.Validator.Rules.Impl.SettingsEntryValidationRule : CustomValidationRule {
    public static PayloadKey`1<SettingsEntry> Key;
    private static SettingsEntryValidationRule();
    protected virtual ValidationResultType DoValidate(string data, EventContext context);
    public virtual bool AcceptRuleId(string ruleId);
}
[ShellComponentAttribute("16")]
public class JetBrains.UsageStatistics.FUS.EventLog.Validator.Rules.Impl.SettingsKeyValidationRule : CustomValidationRule {
    private ISettingsStore mySettingsStore;
    public static PayloadKey`1<SettingsKey> Key;
    public SettingsKeyValidationRule(ISettingsStore settingsStore);
    private static SettingsKeyValidationRule();
    protected virtual ValidationResultType DoValidate(string data, EventContext context);
    public virtual bool AcceptRuleId(string ruleId);
}
[ShellComponentAttribute("16")]
public class JetBrains.UsageStatistics.FUS.EventLog.Validator.Rules.Impl.SettingsValueValidationRule : CustomValidationRule {
    protected virtual ValidationResultType DoValidate(string data, EventContext context);
    public virtual bool AcceptRuleId(string ruleId);
}
[ShellComponentAttribute("16")]
public class JetBrains.UsageStatistics.FUS.EventLog.Validator.Rules.Impl.TestModeValidationRule : CustomValidationRule {
    private bool myTestMode;
    public virtual bool AcceptRuleId(string ruleId);
    protected virtual ValidationResultType DoValidate(string data, EventContext context);
}
public class JetBrains.UsageStatistics.FUS.EventLog.Validator.Rules.PayloadKey`1 : object {
    private string myKey;
    public PayloadKey`1(string key);
    public string GetKey();
}
public abstract class JetBrains.UsageStatistics.FUS.EventLog.Validator.Rules.PerformanceCareRule : object {
    private static int EXPECTED_TIME_MSEC;
    private static int MAX_ATTEMPTS;
    private int failed;
    public sealed virtual ValidationResultType Validate(string data, EventContext context);
    [NotNullAttribute]
protected abstract virtual ValidationResultType DoValidate(string data, EventContext context);
}
public class JetBrains.UsageStatistics.FUS.EventLog.Validator.Rules.RejectedFusRule : ConstantFusRule {
}
public class JetBrains.UsageStatistics.FUS.EventLog.Validator.Rules.Utils.BooleanRuleProducer : object {
    private static string RULE_PREFIX;
    private static BooleanRuleProducer();
    public sealed virtual FUSRule CreateValidationRule(string value, EventGroupContextData contextData);
    public sealed virtual string GetPrefix();
}
public class JetBrains.UsageStatistics.FUS.EventLog.Validator.Rules.Utils.CustomRuleProducer : UtilRuleProducer {
    private IEnumerable`1<CustomValidationRule> myRules;
    private bool myTestMode;
    public CustomRuleProducer(string recorderId, IEnumerable`1<CustomValidationRule> rules);
    public virtual IUtilValidationRule CreateValidationRule(string value, EventGroupContextData contextData);
    private bool IsAcceptedRule(FUSRule extension);
    private static bool IsDevelopedByJetBrains(FUSRule extension);
}
public class JetBrains.UsageStatistics.FUS.EventLog.Validator.Rules.Utils.EnumReferenceRuleProducer : object {
    private static string ENUM_REF_PREFIX;
    private static EnumReferenceRuleProducer();
    public sealed virtual EnumValidationRule CreateValidationRule(string value, EventGroupContextData contextData);
    public sealed virtual string GetPrefix();
}
public class JetBrains.UsageStatistics.FUS.EventLog.Validator.Rules.Utils.EnumRuleProducer : object {
    private static string ENUM_PREFIX;
    private static char ENUM_SEPARATOR;
    private static EnumRuleProducer();
    public sealed virtual EnumValidationRule CreateValidationRule(string value, EventGroupContextData contextData);
    public sealed virtual string GetPrefix();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class JetBrains.UsageStatistics.FUS.EventLog.Validator.Rules.Utils.IsJetBrainsTypeCache : object {
    private static ConcurrentDictionary`2<string, bool> ourIsJetBrainsFqn;
    private static ConcurrentDictionary`2<Assembly, bool> ourIsJetBrainsAssembly;
    private static JetHashSet`1<string> ourCompanyNames;
    private static IsJetBrainsTypeCache();
    [ExtensionAttribute]
[PureAttribute]
public static bool IsTypeFromJetBrainsAssembly(Type type);
    [PureAttribute]
public static bool IsFqnFromJetBrainsAssembly(string fqn);
    [PureAttribute]
public static Type GetTypeFromAllAssemblies(string fqn);
}
public interface JetBrains.UsageStatistics.FUS.EventLog.Validator.Rules.Utils.IValidationRuleProducer`1 {
    [CanBeNullAttribute]
public abstract virtual T CreateValidationRule(string value, EventGroupContextData contextData);
    [NotNullAttribute]
public abstract virtual string GetPrefix();
}
public class JetBrains.UsageStatistics.FUS.EventLog.Validator.Rules.Utils.RegexpReferenceRuleProducer : object {
    private static string REGEXP_REF_PREFIX;
    private static RegexpReferenceRuleProducer();
    public sealed virtual RegexpValidationRule CreateValidationRule(string value, EventGroupContextData contextData);
    public sealed virtual string GetPrefix();
}
public class JetBrains.UsageStatistics.FUS.EventLog.Validator.Rules.Utils.RegexpRuleProducer : object {
    private static string REGEXP_PREFIX;
    private static RegexpRuleProducer();
    public sealed virtual RegexpValidationRule CreateValidationRule(string value, EventGroupContextData contextData);
    public sealed virtual string GetPrefix();
}
public class JetBrains.UsageStatistics.FUS.EventLog.Validator.Rules.Utils.RejectingUtilRule : object {
    public sealed virtual ValidationResultType Validate(string data, EventContext context);
}
public class JetBrains.UsageStatistics.FUS.EventLog.Validator.Rules.Utils.RejectingUtilRuleProducer : UtilRuleProducer {
    public virtual IUtilValidationRule CreateValidationRule(string value, EventGroupContextData contextData);
}
public abstract class JetBrains.UsageStatistics.FUS.EventLog.Validator.Rules.Utils.UtilRuleProducer : object {
    public abstract virtual IUtilValidationRule CreateValidationRule(string value, EventGroupContextData contextData);
    public sealed virtual string GetPrefix();
}
public class JetBrains.UsageStatistics.FUS.EventLog.Validator.Rules.Utils.ValidationSimpleRuleFactory : object {
    public static string UTIL_PREFIX;
    private static string START;
    private static string END;
    private static IList`1<IValidationRuleProducer`1<FUSRule>> RULE_PRODUCERS;
    public static UtilRuleProducer REJECTING_UTIL_URL_PRODUCER;
    private List`1<IValidationRuleProducer`1<FUSRule>> myRuleProducers;
    public static FUSRule UNPARSED_EXPRESSION;
    public ValidationSimpleRuleFactory(UtilRuleProducer utilRuleProducer);
    private static ValidationSimpleRuleFactory();
    [NotNullAttribute]
public FUSRule[] GetRules(ISet`1<string> rules, EventGroupContextData contextData);
    [NotNullAttribute]
private static Comparison`1<FUSRule> GetRulesComparison();
    [NotNullAttribute]
private FUSRule CreateRule(string rule, EventGroupContextData contextData);
    [CanBeNullAttribute]
private FUSRule CreateSimpleRule(string rule, EventGroupContextData contextData);
    [NotNullAttribute]
private FUSRule CreateExpressionRule(string rule, EventGroupContextData contextData);
    [NotNullAttribute]
private FUSRule CreateExpressionValidationRule(string rule, EventGroupContextData contextData);
    private FUSRule CreateExpressionUtilRule(IList`1<string> nodes);
    [NotNullAttribute]
public static IList`1<string> ParseSimpleExpression(string s);
    private static void AddNonEmpty(IList`1<string> nodes, string s);
    private static bool IsExpressionNode(string node);
    [NotNullAttribute]
private static string UnwrapRuleNode(string rule);
}
public class JetBrains.UsageStatistics.FUS.EventLog.Validator.SensitiveDataValidator`1 : object {
    [CompilerGeneratedAttribute]
private S <ValidationRulesStorage>k__BackingField;
    public S ValidationRulesStorage { get; }
    public SensitiveDataValidator`1(S validationRulesStorage);
    [CompilerGeneratedAttribute]
public S get_ValidationRulesStorage();
    [CanBeNullAttribute]
public LogEvent ValidateEvent(LogEvent ev);
    public LogEvent Validate(string groupId, string groupVersion, string build, string sessionId, string bucket, long eventTime, string recorderVersion, string eventId, IDictionary`2<string, object> data, bool isState, int count);
    protected virtual string GuaranteeCorrectEventId(EventContext context, EventGroupRules groupRules);
    public virtual IDictionary`2<string, object> GuaranteeCorrectEventData(EventContext context, EventGroupRules groupRules);
    public EventDataField ValidateEventData(EventContext context, EventGroupRules groupRules, string key, object entryValue);
    public static ValidationResultType ValidateEvent(EventContext context, EventGroupRules groupRules);
}
public class JetBrains.UsageStatistics.FUS.EventLog.Validator.SimpleValidationRuleStorage`1 : ValidationRuleStorage`1<T> {
    private EventGroupRemoteDescriptors myInitialMetadata;
    private IEventLogBuildParser`1<T> myBuildParser;
    private UtilRuleProducer myUtilRulesProducer;
    private IList`1<string> myExcludedFields;
    private ValidationSimpleRuleFactory myValidationRuleFactory;
    private IDictionary`2<string, EventGroupRules> myEventsValidators;
    private EventGroupsFilterRules`1<T> myFilterRules;
    private object myLock;
    public SimpleValidationRuleStorage`1(EventGroupRemoteDescriptors initialMetadata, IEventLogBuildParser`1<T> buildParser, IList`1<string> excludedFields, UtilRuleProducer utilRulesProducer);
    public void Update(EventGroupRemoteDescriptors metadata);
    private void UpdateEventGroupRules(EventGroupRemoteDescriptors descriptors);
    private IDictionary`2<string, EventGroupRules> CreateValidators(EventGroupRemoteDescriptors descriptors);
    public virtual GroupValidators`1<T> GetGroupValidators(string groupId);
    public virtual bool IsUnreachable();
}
public class JetBrains.UsageStatistics.FUS.EventLog.Validator.Storage.BlindSensitiveDataValidator : DotnetSensitiveDataValidator {
    public BlindSensitiveDataValidator(DotnetValidationRulesStorage storage, string recorderId);
    public virtual bool IsGroupAllowed(EventLogGroup group);
    public virtual IDictionary`2<string, object> GuaranteeCorrectEventData(EventContext context, EventGroupRules groupRules);
    protected virtual string GuaranteeCorrectEventId(EventContext context, EventGroupRules groupRules);
}
public class JetBrains.UsageStatistics.FUS.EventLog.Validator.Storage.CompositeValidationRulesStorage : DotnetValidationRulesStorage {
    private DotnetValidationRulesStorage myRulesStorage;
    private ValidationTestRulesPersistedStorage myTestRulesStorage;
    public CompositeValidationRulesStorage(DotnetValidationRulesStorage rulesStorage, ValidationTestRulesPersistedStorage testRulesStorage);
    [CanBeNullAttribute]
public virtual EventGroupRules GetGroupRules(string groupId);
    public virtual bool IsUnreachable();
    public virtual void Update();
    public virtual void Reload();
    [NotNullAttribute]
public sealed virtual ValidationTestRulesPersistedStorage GetTestGroupStorage();
}
public class JetBrains.UsageStatistics.FUS.EventLog.Validator.Storage.DotnetSensitiveDataValidator : SensitiveDataValidator`1<DotnetValidationRulesStorage> {
    private string myRecorderId;
    protected internal DotnetSensitiveDataValidator(DotnetValidationRulesStorage storage, string recorderId);
    public virtual bool IsGroupAllowed(EventLogGroup group);
    [NotNullAttribute]
public virtual IDictionary`2<string, object> GuaranteeCorrectEventData(EventContext context, EventGroupRules groupRules);
    private bool IsTestModeEnabled(EventGroupRules rule);
    public void Update();
    public void Reload();
}
[ShellComponentAttribute("16")]
public class JetBrains.UsageStatistics.FUS.EventLog.Validator.Storage.DotnetSensitiveDataValidatorProvider : object {
    private ValidationRulesStorageProvider myRulesStorageProvider;
    private ConcurrentDictionary`2<string, DotnetSensitiveDataValidator> ourInstances;
    public DotnetSensitiveDataValidatorProvider(ValidationRulesStorageProvider rulesStorageProvider);
    [NotNullAttribute]
public DotnetSensitiveDataValidator GetInstance(string recorderId);
    protected virtual DotnetSensitiveDataValidator CreateInstance(DotnetValidationRulesStorage storage, string recorderId);
    [CanBeNullAttribute]
public DotnetSensitiveDataValidator GetIfInitialized(string recorderId);
}
public abstract class JetBrains.UsageStatistics.FUS.EventLog.Validator.Storage.DotnetValidationRulesStorage : ValidationRuleStorage`1<EventLogBuild> {
    public abstract virtual void Update();
    public abstract virtual void Reload();
    public virtual GroupValidators`1<EventLogBuild> GetGroupValidators(string groupId);
}
public class JetBrains.UsageStatistics.FUS.EventLog.Validator.Storage.EventLogServerMetadataLoader : object {
    private EventLogUploadSettingsService mySettingsService;
    public EventLogServerMetadataLoader(string recorderId, StatisticsUploadAssistant statisticsUploadAssistant);
    public sealed virtual long GetLastModifiedOnServer();
    public sealed virtual string LoadMetadataFromServer();
    public sealed virtual IDictionary`2<string, string> GetOptionValues();
}
[ShellComponentAttribute("10")]
public class JetBrains.UsageStatistics.FUS.EventLog.Validator.Storage.EventLogSystemEventsListener : object {
    private static string DEFAULT_RECORDER;
    private FeatureUsageLogger myFeatureUsageLogger;
    private ConcurrentDictionary`2<string, EventLogGroup> myGroups;
    public EventLogSystemEventsListener(Lifetime lifetime, FeatureUsageLogger featureUsageLogger, EventLogSystemLogger eventLogSystemLogger);
    [CanBeNullAttribute]
private EventLogGroup GetGroup(string groupId);
    [CanBeNullAttribute]
private string GetGroupId(string recorderId);
}
[ShellComponentAttribute("16")]
public class JetBrains.UsageStatistics.FUS.EventLog.Validator.Storage.EventLogSystemLogger : object {
    private EventLogConfiguration myEventLogConfiguration;
    public static string GROUP;
    private Signal`1<ValueTuple`3<string, string, FeatureUsageData>> myLogSignal;
    public EventLogSystemLogger(Lifetime lifetime, EventLogConfiguration eventLogConfiguration);
    public void LogMetadataLoad(string recorderId, string version);
    public void LogMetadataUpdated(string recorderId, string version);
    public void LogMetadataErrorOnLoad(string recorderId, IEventLogMetadataUpdateError error);
    public void LogMetadataErrorOnUpdate(string recorderId, IEventLogMetadataUpdateError error);
    private void LogMetadataError(string recorderId, string eventId, IEventLogMetadataUpdateError error);
    public void LogFilesSend(string recorderId, int total, int succeed, int failed, bool external, ICollection`1<string> successfullySentFiles, ICollection`1<int> errors);
    private void LogEvent(string recorderId, string eventId, FeatureUsageData data);
    public void AdviseLogSignal(Lifetime lifetime, Action`1<ValueTuple`3<string, string, FeatureUsageData>> action);
}
public class JetBrains.UsageStatistics.FUS.EventLog.Validator.Storage.GlobalRulesHolder : object {
    [CanBeNullAttribute]
private IDictionary`2<string, ISet`1<string>> myGlobalEnums;
    [CanBeNullAttribute]
private IDictionary`2<string, string> myGlobalRegexps;
    private IDictionary`2<string, RegexpValidationRule> myGlobalRegexpsCache;
    private IDictionary`2<string, EnumValidationRule> myGlobalEnumsCache;
    public GlobalRulesHolder(IDictionary`2<string, ISet`1<string>> globalEnums, IDictionary`2<string, string> globalRegexps);
    public GlobalRulesHolder(GroupRemoteRule globalRules);
    [CanBeNullAttribute]
public EnumValidationRule GetEnumValidationRules(string enumRef);
    [CanBeNullAttribute]
public RegexpValidationRule GetRegexpValidationRules(string regexpRef);
}
public class JetBrains.UsageStatistics.FUS.EventLog.Validator.Storage.GroupValidationTestRule : object {
    public static string EMPTY_RULES;
    [CompilerGeneratedAttribute]
private string <groupId>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <useCustomRules>k__BackingField;
    [CompilerGeneratedAttribute]
private string <customRules>k__BackingField;
    public string groupId { get; }
    public bool useCustomRules { get; }
    public string customRules { get; }
    public GroupValidationTestRule(string groupId, bool useCustomRules, string customRules);
    private static GroupValidationTestRule();
    [CompilerGeneratedAttribute]
public string get_groupId();
    [CompilerGeneratedAttribute]
public bool get_useCustomRules();
    [CompilerGeneratedAttribute]
public string get_customRules();
}
public interface JetBrains.UsageStatistics.FUS.EventLog.Validator.Storage.IEventLogMetadataLoader {
    public abstract virtual long GetLastModifiedOnServer();
    [NotNullAttribute]
public abstract virtual string LoadMetadataFromServer();
    [NotNullAttribute]
public abstract virtual IDictionary`2<string, string> GetOptionValues();
}
public interface JetBrains.UsageStatistics.FUS.EventLog.Validator.Storage.IValidationTestRulesStorageHolder {
    public abstract virtual ValidationTestRulesPersistedStorage GetTestGroupStorage();
}
public abstract class JetBrains.UsageStatistics.FUS.EventLog.Validator.Storage.Persistense.BaseEventLogMetadataPersistence : object {
    protected AnyProductSettingsLocation myProductSettingsLocation;
    private static ILogger LOG;
    public static string FUS_METADATA_DIR;
    protected BaseEventLogMetadataPersistence(AnyProductSettingsLocation productSettingsLocation);
    private static BaseEventLogMetadataPersistence();
    [CanBeNullAttribute]
public abstract virtual string GetCachedEventsScheme();
    public FileSystemPath GetDefaultMetadataFile(string recorderId, string fileName);
    [NotNullAttribute]
private FileSystemPath GetMetadataByDir(string dir, string recorderId, string fileName);
    [NotNullAttribute]
private FileSystemPath GetMetadataConfigRoot(string dir);
}
public class JetBrains.UsageStatistics.FUS.EventLog.Validator.Storage.Persistense.EventLogMetadataPersistence : BaseEventLogMetadataPersistence {
    public static string EVENTS_SCHEME_FILE;
    private static ILogger LOG;
    [NotNullAttribute]
private string myRecorderId;
    private EventLogMetadataSettingsPersistence myEventLogMetadataSettingsPersistence;
    private StatisticsActivator myStatisticsActivator;
    public EventLogMetadataPersistence(string recorderId, AnyProductSettingsLocation productSettingsLocation, EventLogMetadataSettingsPersistence eventLogMetadataSettingsPersistence, StatisticsActivator statisticsActivator);
    private static EventLogMetadataPersistence();
    public virtual string GetCachedEventsScheme();
    [NotNullAttribute]
private FileSystemPath GetEventsSchemeFile();
    public virtual void CacheEventsScheme(string eventsSchemeJson, long lastModified);
    private void InitBuiltinMetadata(FileSystemPath file);
    public virtual long GetLastModified();
    [NotNullAttribute]
public FileSystemPath GetDefaultFile();
}
[ShellComponentAttribute("16")]
public class JetBrains.UsageStatistics.FUS.EventLog.Validator.Storage.Persistense.EventLogMetadataSettingsPersistence : object {
    private ILogger myLogger;
    private IAnyProductSettingsLocation myProductSettingsLocation;
    private Dictionary`2<string, long> myLastModifications;
    private Dictionary`2<string, EventsSchemePathSettings> myRecorderToPathSettings;
    private Dictionary`2<string, EventLogExternalOptions> myOptions;
    private static string MODIFY;
    private static string OPTIONS;
    private object myOptionsLock;
    public EventLogMetadataSettingsPersistence(Lifetime lifetime, ILogger logger, IAnyProductSettingsLocation productSettingsLocation, ILazy`1<StatisticsSwarmManager> swarmManager);
    [AsyncStateMachineAttribute("JetBrains.UsageStatistics.FUS.EventLog.Validator.Storage.Persistense.EventLogMetadataSettingsPersistence/<ScheduleSaveState>d__6")]
private Task ScheduleSaveState(Lifetime lifetime, ILazy`1<StatisticsSwarmManager> lazySwarmManager);
    private FileSystemPath GetStateFile();
    [NotNullAttribute]
public IDictionary`2<string, string> GetOptions(string recorderId);
    public void SetOptions(string recorderId, IDictionary`2<string, string> options);
    [NotNullAttribute]
public IDictionary`2<string, string> UpdateOptions(string recorderId, IDictionary`2<string, string> newOptions);
    public long GetLastModified(string recorderId);
    public void SetLastModified(string recorderId, long lastUpdate);
    [CanBeNullAttribute]
public EventsSchemePathSettings GetPathSettings(string recorderId);
    public void SetPathSettings(string recorderId, EventsSchemePathSettings settings);
    private void LoadState();
    public void SaveState();
}
public class JetBrains.UsageStatistics.FUS.EventLog.Validator.Storage.Persistense.EventLogTestMetadataPersistence : BaseEventLogMetadataPersistence {
    private static ILogger LOG;
    public static string TEST_RULE;
    private static string TEST_EVENTS_SCHEME_FILE;
    [NotNullAttribute]
private string myRecorderId;
    public EventLogTestMetadataPersistence(string recorderId, AnyProductSettingsLocation productSettingsLocation);
    private static EventLogTestMetadataPersistence();
    public virtual string GetCachedEventsScheme();
    public void Cleanup();
    [NotNullAttribute]
public EventGroupRemoteDescriptor CreateGroupWithCustomRules(string groupId, string rules);
    public void AddTestGroup(string recorderId, GroupValidationTestRule group);
    private void AddNewGroup(string recorderId, EventGroupRemoteDescriptor group);
    public void SaveNewGroup(EventGroupRemoteDescriptor group, EventGroupRemoteDescriptors approvedGroups, FileSystemPath file);
    [NotNullAttribute]
public EventGroupRemoteDescriptors LoadCachedEventGroupsSchemes(BaseEventLogMetadataPersistence persistence);
    [NotNullAttribute]
public EventGroupRemoteDescriptor CreateTestGroup(string groupId, ISet`1<string> eventData);
    [NotNullAttribute]
public FileSystemPath GetEventsTestSchemeFile();
}
public class JetBrains.UsageStatistics.FUS.EventLog.Validator.Storage.Persistense.EventsSchemePathSettings : object {
    [CompilerGeneratedAttribute]
private string <CustomPath>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseCustomPath>k__BackingField;
    [NotNullAttribute]
public string CustomPath { get; }
    public bool UseCustomPath { get; }
    public EventsSchemePathSettings(string customPath, bool useCustomPath);
    [CompilerGeneratedAttribute]
public string get_CustomPath();
    [CompilerGeneratedAttribute]
public bool get_UseCustomPath();
}
public class JetBrains.UsageStatistics.FUS.EventLog.Validator.Storage.ValidationRulesInMemoryStorage : DotnetValidationRulesStorage {
    public static ValidationRulesInMemoryStorage INSTANCE;
    public Dictionary`2<string, EventGroupRules> eventsValidators;
    private static ValidationRulesInMemoryStorage();
    public virtual bool IsUnreachable();
    public virtual void Update();
    public virtual void Reload();
    public virtual EventGroupRules GetGroupRules(string groupId);
}
public class JetBrains.UsageStatistics.FUS.EventLog.Validator.Storage.ValidationRulesPersistedStorage : DotnetValidationRulesStorage {
    private static ILogger LOG;
    protected ConcurrentDictionary`2<string, EventGroupRules> eventsValidators;
    [NotNullAttribute]
private Semaphore mySemaphore;
    [NotNullAttribute]
private string myRecorderId;
    [CanBeNullAttribute]
private string myVersion;
    [NotNullAttribute]
private EventLogMetadataPersistence myMetadataPersistence;
    [NotNullAttribute]
private IEventLogMetadataLoader myMetadataLoader;
    [NotNullAttribute]
private EventLogConfiguration myEventLogConfiguration;
    [NotNullAttribute]
private IEnumerable`1<CustomValidationRule> myRules;
    [NotNullAttribute]
private EventLogConfigOptionsService myEventLogConfigOptionsService;
    [NotNullAttribute]
private EventLogSystemLogger myEventLogSystemLogger;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) myIsInitialized;
    public ValidationRulesPersistedStorage(string recorderId, AnyProductSettingsLocation productSettingsLocation, EventLogConfiguration eventLogConfiguration, EventLogMetadataSettingsPersistence eventLogMetadataSettingsPersistence, StatisticsUploadAssistant statisticsUploadAssistant, IEnumerable`1<CustomValidationRule> rules, EventLogConfigOptionsService eventLogConfigOptionsService, EventLogSystemLogger eventLogSystemLogger, StatisticsActivator activator);
    protected ValidationRulesPersistedStorage(string recorderId, EventLogMetadataPersistence persistence, IEventLogMetadataLoader loader, EventLogConfiguration eventLogConfiguration, IEnumerable`1<CustomValidationRule> rules, EventLogConfigOptionsService eventLogConfigOptionsService, EventLogSystemLogger eventLogSystemLogger);
    private static ValidationRulesPersistedStorage();
    [CanBeNullAttribute]
public virtual EventGroupRules GetGroupRules(string groupId);
    [CanBeNullAttribute]
protected string LoadValidatorsFromLocalCache(string recorderId);
    [CanBeNullAttribute]
protected string UpdateValidators(string rawEventsScheme);
    public virtual void Update();
    public virtual void Reload();
    public virtual bool IsUnreachable();
    [NotNullAttribute]
protected virtual IDictionary`2<string, EventGroupRules> CreateValidators(EventLogBuild build, EventGroupRemoteDescriptors groups);
    [NotNullAttribute]
public IDictionary`2<string, EventGroupRules> CreateValidators(EventLogBuild build, EventGroupRemoteDescriptors groups, GlobalRulesHolder globalRulesHolder, string recorderId);
    public static IDictionary`2<string, EventGroupRules> CreateValidators(EventLogBuild build, EventGroupRemoteDescriptors groups, GlobalRulesHolder globalRulesHolder, string recorderId, IEnumerable`1<CustomValidationRule> customRules);
}
[ShellComponentAttribute("16")]
public class JetBrains.UsageStatistics.FUS.EventLog.Validator.Storage.ValidationRulesStorageProvider : object {
    private AnyProductSettingsLocation myProductSettingsLocation;
    private ProductConfigurations myProductConfigurations;
    private EventLogConfiguration myEventLogConfiguration;
    private IEnumerable`1<CustomValidationRule> myRules;
    private EventLogMetadataSettingsPersistence myEventLogMetadataSettingsPersistence;
    private StatisticsUploadAssistant myStatisticsUploadAssistant;
    private EventLogConfigOptionsService myEventLogConfigOptionsService;
    private EventLogSystemLogger myEventLogSystemLogger;
    private StatisticsActivator myStatisticsActivator;
    public ValidationRulesStorageProvider(AnyProductSettingsLocation productSettingsLocation, ProductConfigurations productConfigurations, EventLogConfiguration eventLogConfiguration, IEnumerable`1<CustomValidationRule> rules, EventLogMetadataSettingsPersistence eventLogMetadataSettingsPersistence, StatisticsUploadAssistant statisticsUploadAssistant, EventLogConfigOptionsService eventLogConfigOptionsService, EventLogSystemLogger eventLogSystemLogger, StatisticsActivator statisticsActivator);
    [NotNullAttribute]
public DotnetValidationRulesStorage NewStorage(string recorderId);
    protected virtual bool IsCompositeStorageNeeded();
    [NotNullAttribute]
protected virtual DotnetValidationRulesStorage CreateStorageInternal(string recorderId);
}
public class JetBrains.UsageStatistics.FUS.EventLog.Validator.Storage.ValidationTestRulesPersistedStorage : DotnetValidationRulesStorage {
    private ConcurrentDictionary`2<string, EventGroupRules> myEventsValidators;
    private object myLock;
    [NotNullAttribute]
private EventLogTestMetadataPersistence myTestMetadataPersistence;
    [NotNullAttribute]
private EventLogMetadataPersistence myMetadataPersistence;
    [NotNullAttribute]
private string myRecorderId;
    private EventLogConfiguration myEventLogConfiguration;
    private bool myIsInitialized;
    private IEnumerable`1<CustomValidationRule> myRules;
    public ValidationTestRulesPersistedStorage(string recorderId, AnyProductSettingsLocation productSettingsLocation, EventLogConfiguration eventLogConfiguration, IEnumerable`1<CustomValidationRule> rules, EventLogMetadataSettingsPersistence eventLogMetadataSettingsPersistence, StatisticsActivator activator);
    public virtual EventGroupRules GetGroupRules(string groupId);
    public virtual void Update();
    public virtual void Reload();
    public virtual bool IsUnreachable();
    private void UpdateValidators();
    [NotNullAttribute]
private IDictionary`2<string, EventGroupRules> CreateValidators(EventGroupRemoteDescriptors groups, GroupRemoteRule productionRules);
    public void AddTestGroup(GroupValidationTestRule group);
    private void Cleanup();
    [CanBeNullAttribute]
private static GroupRemoteRule Merge(GroupRemoteRule testRules, GroupRemoteRule productionTestRules);
    private static void CopyRules(GroupRemoteRule to, GroupRemoteRule from);
    public static void CleanupAll(StatisticsEventLogProviderUtil logProviderUtil, DotnetSensitiveDataValidatorProvider provider);
    public static void CleanupAll(IEnumerable`1<string> recorders, DotnetSensitiveDataValidatorProvider provider);
    [CanBeNullAttribute]
public static ValidationTestRulesPersistedStorage GetTestStorage(DotnetSensitiveDataValidatorProvider provider, string recorderId, bool initIfNeeded);
}
public class JetBrains.UsageStatistics.FUS.EventLog.Validator.ValidationResultType : EnumPattern {
    [CompilerGeneratedAttribute]
private static IList`1<ValidationResultType> <Values>k__BackingField;
    public static ValidationResultType ACCEPTED;
    public static ValidationResultType THIRD_PARTY;
    public static ValidationResultType REJECTED;
    public static ValidationResultType INCORRECT_RULE;
    public static ValidationResultType UNDEFINED_RULE;
    public static ValidationResultType UNREACHABLE_METADATA;
    public static ValidationResultType PERFORMANCE_ISSUE;
    [NotNullAttribute]
private string myName;
    private bool myIsFinal;
    public static IList`1<ValidationResultType> Values { get; }
    private ValidationResultType(string name, bool isFinal);
    private static ValidationResultType();
    [CompilerGeneratedAttribute]
public static IList`1<ValidationResultType> get_Values();
    public string GetDescription();
    public bool IsFinal();
}
public abstract class JetBrains.UsageStatistics.FUS.EventLog.Validator.ValidationRuleStorage`1 : object {
    public abstract virtual GroupValidators`1<T> GetGroupValidators(string groupId);
    public abstract virtual bool IsUnreachable();
    public sealed virtual bool VersionAccepts(string groupId, string groupVersion, string build);
    public virtual EventGroupRules GetGroupRules(string groupId);
}
[ShellComponentAttribute("16")]
public class JetBrains.UsageStatistics.FUS.Persistence.UsageStatisticsPersistenceComponent : object {
    private Dictionary`2<string, long> myRecorderToSystemEventIds;
    public sealed virtual long GetSystemEventId(string recorderId);
    public sealed virtual void SetSystemEventId(string recorderId, long eventId);
}
[ShellComponentAttribute("16")]
public class JetBrains.UsageStatistics.FUS.StatisticsActivator : object {
    public bool IsActive { get; }
    [CanBeNullAttribute]
public string ProductCode { get; }
    public virtual bool get_IsActive();
    public virtual string get_ProductCode();
    [CanBeNullAttribute]
public virtual Stream GetBuiltInMetadataStream(Lifetime lifetime, string recorderId);
    [CanBeNullAttribute]
public virtual Nullable`1<long> GetOverridenSendFrequencyMs(string recorderId);
}
[ShellComponentAttribute("36")]
public class JetBrains.UsageStatistics.FUS.StatisticsJobsScheduler : object {
    private Lifetime myLifetime;
    private IThreading myThreading;
    private StatisticsEventLogProviderUtil myStatisticsEventLogProviderUtil;
    private DotnetSensitiveDataValidatorProvider myDotnetSensitiveDataValidatorProvider;
    private StatisticsServiceProvider myStatisticsServiceProvider;
    private StatisticsActivator myActivator;
    private ILogger myLogger;
    private StatisticsUploadAssistant myStatisticsUploadAssistant;
    private FuStateUsagesLogger myStateLogger;
    private SequentialLifetimes myCollectSequence;
    private static int SEND_STATISTICS_INITIAL_DELAY_IN_MILLIS;
    private static int CHECK_STATISTICS_PROVIDERS_DELAY_IN_MIN;
    private static int CHECK_EXTERNAL_UPLOADER_DELAY_IN_MIN;
    public static int LOG_APPLICATION_STATES_INITIAL_DELAY_IN_MIN;
    public static int LOG_APPLICATION_STATES_DELAY_IN_MIN;
    public StatisticsJobsScheduler(Lifetime lifetime, IThreading threading, StatisticsEventLogProviderUtil statisticsEventLogProviderUtil, DotnetSensitiveDataValidatorProvider dotnetSensitiveDataValidatorProvider, StatisticsServiceProvider statisticsServiceProvider, StatisticsActivator activator, ILogger logger, StatisticsSwarmManager swarmManager, StatisticsUploadAssistant statisticsUploadAssistant, FuStateUsagesLogger stateLogger);
    private void RunValidationRulesUpdate();
    private void RunEventLogStatisticsService();
    private void RunStatesLogging();
    private void RunStatisticsServiceWithDelay(IStatisticsService statisticsService, long delayInMs, bool enforceRollover);
    [CompilerGeneratedAttribute]
private void <RunValidationRulesUpdate>b__16_0();
    [AsyncStateMachineAttribute("JetBrains.UsageStatistics.FUS.StatisticsJobsScheduler/<<RunValidationRulesUpdate>b__16_1>d")]
[CompilerGeneratedAttribute]
private Task <RunValidationRulesUpdate>b__16_1();
    [CompilerGeneratedAttribute]
private void <RunEventLogStatisticsService>b__17_0();
    [AsyncStateMachineAttribute("JetBrains.UsageStatistics.FUS.StatisticsJobsScheduler/<<RunEventLogStatisticsService>b__17_1>d")]
[CompilerGeneratedAttribute]
private Task <RunEventLogStatisticsService>b__17_1();
    [CompilerGeneratedAttribute]
private void <RunStatesLogging>b__18_0();
    [AsyncStateMachineAttribute("JetBrains.UsageStatistics.FUS.StatisticsJobsScheduler/<<RunStatesLogging>b__18_1>d")]
[CompilerGeneratedAttribute]
private Task <RunStatesLogging>b__18_1();
    [CompilerGeneratedAttribute]
private void <RunStatesLogging>b__18_2(Lifetime l);
}
[ShellComponentAttribute("40")]
public class JetBrains.UsageStatistics.FUS.StatisticsSwarmManager : object {
    private static Guid ourGuid;
    [CompilerGeneratedAttribute]
private bool <IsPrimaryInstance>k__BackingField;
    public bool IsPrimaryInstance { get; private set; }
    public StatisticsSwarmManager(Lifetime lifetime, ProductSettingsLocation productSettingsLocation, ILogger logger, StatisticsActivator activator);
    private static StatisticsSwarmManager();
    [CompilerGeneratedAttribute]
public bool get_IsPrimaryInstance();
    [CompilerGeneratedAttribute]
private void set_IsPrimaryInstance(bool value);
}
public class JetBrains.UsageStatistics.FUS.Utils.EventsIdentityWindowThrottle : object {
    private int myThreshold;
    private int myAlertThreshold;
    private long myPeriodMs;
    private Dictionary`2<string, EventDescriptor> myKeyToCount;
    public EventsIdentityWindowThrottle(int threshold, int alertThreshold, long periodMs);
    public void SetThreshold(int newThreshold);
    public void SetAlertThreshold(int newThreshold);
    public EventRateThrottleResult TryPass(string key, long now);
    private bool IsAlert(EventDescriptor descriptor);
}
public class JetBrains.UsageStatistics.FUS.Utils.EventsRateWindowThrottle : object {
    [CompilerGeneratedAttribute]
private long <StartTime>k__BackingField;
    private int myThreshold;
    private long myPeriodMs;
    private int myCount;
    private long myLastPeriod;
    public long StartTime { get; }
    public EventsRateWindowThrottle(int threshold, long periodMs, long startTime);
    [CompilerGeneratedAttribute]
public long get_StartTime();
    public void SetThreshold(int newThreshold);
    private void IncrementCounter();
    private void ResetCounter(long period);
    public EventRateThrottleResult TryPass(long now);
}
public static class JetBrains.UsageStatistics.FUS.Utils.StatisticsRecorderUtil : object {
    private static String[] BUILT_IN_RECORDERS;
    private static Nullable`1<bool> ourIsEnvVarEnabled;
    private static StatisticsRecorderUtil();
    public static bool IsBuildInRecorder(string recorderId);
    public static bool IsTestModeEnabled(string recorderId);
    private static bool IsFusInternalTestMode();
    public static bool IsAnyTestModeEnabled();
}
[ShellComponentAttribute("16")]
public class JetBrains.UsageStatistics.FUS.Utils.StatisticsServiceProvider : object {
    private ILogger myLogger;
    private ActivityTrackingSettings myActivityTrackingSettings;
    private EventLogConfiguration myEventLogConfiguration;
    private StatisticsEventLogProviderUtil myProviderUtil;
    private PermanentDeviceId myPermanentDeviceId;
    private StatisticsUploadAssistant myStatisticsUploadAssistant;
    private EventLogSystemLogger myEventLogSystemLogger;
    public StatisticsServiceProvider(ILogger logger, ActivityTrackingSettings activityTrackingSettings, EventLogConfiguration eventLogConfiguration, StatisticsEventLogProviderUtil providerUtil, PermanentDeviceId permanentDeviceId, StatisticsUploadAssistant statisticsUploadAssistant, EventLogSystemLogger eventLogSystemLogger);
    [NotNullAttribute]
public IStatisticsService GetEventLogStatisticsService(string recorderId);
}
[ShellComponentAttribute("16")]
public class JetBrains.UsageStatistics.FUS.Utils.StatisticsUploadAssistant : object {
    private ILogger myLogger;
    private ActivityTrackingSettings myActivityTrackingSettings;
    private StatisticsActivator myActivator;
    public StatisticsUploadAssistant(ILogger logger, ActivityTrackingSettings activityTrackingSettings, StatisticsActivator activator);
    public bool IsTestStatisticsEnabled();
    public EventLogUploadSettingsService CreateExternalSettings(string recorderId, bool isTest, long cacheTimeoutMs);
    public bool IsTeamcityDetected();
    public bool IsLocalStatisticsWithoutReport();
    public Task`1<bool> IsCollectAllowedAsync();
    public Task`1<bool> IsSendAllowedAsync();
    public string GetProductCode();
}
public class JetBrains.UsageStatistics.FUS.Utils.StatisticsUtil : object {
    private static int kilo;
    private static int mega;
    public static int GetNextPowerOfTwo(int x);
    public static long GetNextPowerOfTwo(long x);
    private static int CoerceIn(int value, int min, int max);
    public static string GetCurrentHourInUTC(Nullable`1<DateTimeOffset> dt);
    public static int RoundToUpperBound(int value, Int32[] bounds);
    public static string GetCountingStepName(int value, IList`1<int> steps);
    private static string Humanize(int number);
}
public class JetBrains.UsageStatistics.GapUploadInfo : ValueType {
    public ICollection`1<KeyValuePair`2<string, ICollection`1<Pair`2<string, int>>>> Data;
    public DateTime Created;
    public DateTime Closed;
    public Byte[] Binary;
    public string GetContents();
}
public interface JetBrains.UsageStatistics.IActivityTrackingImpl {
    public abstract virtual void EnsureSessionStarted();
}
public class JetBrains.UsageStatistics.ItemDBRecord : object {
    public Guid Id;
    public string Name;
    public string Group;
    public int Counter;
}
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
public static class JetBrains.UsageStatistics.Resources.Strings : object {
    private static ILogger ourLog;
    private static Lazy`1<JetResourceManager> ourResourceManager;
    [EditorBrowsableAttribute("2")]
public static JetResourceManager ResourceManager { get; }
    public static string FeedbackSettingsSettingDescription { get; }
    public static string WhetherSendActivityLogsOrNotSettingDescription { get; }
    public static string WhetherToCollectTimingForEachActionSettingDescription { get; }
    public static string WhetherToPromptUserToSubmitFeedbackOrNotSettingDescription { get; }
    private static Strings();
    public static JetResourceManager get_ResourceManager();
    public static string Choice(string format, Object[] args);
    public static string get_FeedbackSettingsSettingDescription();
    public static string get_WhetherSendActivityLogsOrNotSettingDescription();
    public static string get_WhetherToCollectTimingForEachActionSettingDescription();
    public static string get_WhetherToPromptUserToSubmitFeedbackOrNotSettingDescription();
}
public class JetBrains.UsageStatistics.Resources.UsageStatisticsThemedIcons : object {
}
[ShellComponentAttribute("10")]
[ZoneMarkerAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class JetBrains.UsageStatistics.SendAnonymousFeedbackBuiltInOptionProvider : BuiltInConsentOptionsProviderFromResourceWithSetting`1<FeedbackSettings> {
    public SendAnonymousFeedbackBuiltInOptionProvider(Lifetime lifetime, ISettingsStore settingsStore, IConsentOptions consentOptions, ILogger logger);
}
[CounterUsagesCollectorAttribute("16")]
public class JetBrains.UsageStatistics.SuspendResumeCollector : CounterUsagesCollector {
    private EventLogGroup myGroup;
    private EventId mySuspendedEvent;
    private EventId myResumedEvent;
    public SuspendResumeCollector(Lifetime lifetime, FeatureUsageLogger featureUsageLogger);
    public virtual EventLogGroup GetGroup();
    public void LogSuspended();
    public void LogResumed();
}
[ShellComponentAttribute("10")]
public class JetBrains.UsageStatistics.SuspendResumeStatisticsProvider : object {
    public SuspendResumeStatisticsProvider(Lifetime lifetime, SuspendResume suspendResume, ResumeLatch resumeLatch, SuspendResumeCollector suspendResumeCollector);
}
public class JetBrains.UsageStatistics.UsageDb : object {
    private static ILogger ourLogger;
    [CompilerGeneratedAttribute]
private bool <IsPrimary>k__BackingField;
    private Lifetime myLifetime;
    private LevelDbDriver myDriver;
    private IKeyValueDb myDb;
    [CompilerGeneratedAttribute]
private bool <IsOperational>k__BackingField;
    private IPersistentSortedMap`2<Guid, string> myItemNamesMap;
    private IPersistentSortedMap`2<Guid, string> myItemGroupsMap;
    private IPersistentSortedMap`2<Guid, int> myAggregatedCounters;
    private IPersistentSortedMap`2<UInt32, long> myGapCreated;
    private IPersistentSortedMap`2<UInt32, long> myGapUpdated;
    private IPersistentSortedMap`2<GapRecordId, int> myGapRecords;
    private IPersistentSortedMap`2<string, UInt32> myServiceMap;
    private IPersistentSortedMap`2<int, JetHashSet`1<Guid>> myItemIdIndex;
    private IPersistentSortedMap`2<UInt32, Byte[]> myGapData;
    public bool IsPrimary { get; }
    public bool IsOperational { get; }
    public UsageDb(Lifetime lifetime, ITaskHost taskHost, FileSystemPath path, bool isPrimary);
    private static UsageDb();
    [CompilerGeneratedAttribute]
public bool get_IsPrimary();
    [CompilerGeneratedAttribute]
public bool get_IsOperational();
    public IKeyValueDb GetDb();
    private IPersistentSortedMap`2<TK, TV> GetMap(string mapId, IUnsafeMarshaller`1<TK> keyMarshaller, IUnsafeMarshaller`1<TV> valMarshaller);
    public TimeSpan GetGapDuration(UInt32 gapId);
    public Guid GetOrCreateItem(string groupName, string itemName);
    public int IncrementAggregatedCounter(UInt32 currentGapId, Guid itemId, int increment);
    private Guid GetItemId(string groupName, string itemName);
    [CanBeNullAttribute]
public string GetItemName(Guid itemId);
    [CanBeNullAttribute]
private string GetItemGroup(Guid itemId);
    [IteratorStateMachineAttribute("JetBrains.UsageStatistics.UsageDb/<GetAllItems>d__28")]
public IEnumerable`1<ItemDBRecord> GetAllItems(string groupName);
    public Nullable`1<int> GetItemCounterValue(string groupName, string itemName);
    public IEnumerable`1<UInt32> EnumerateGaps();
    private int CalculateItemHash(string groupName, string itemName);
    private Guid CreateNewItem(string groupName, string itemName);
    public UInt32 CreateGap();
    public GapUploadInfo FillGapData(UInt32 gapId);
    public void DropGap(UInt32 gapId);
    public void StoreLog(UInt32 gapId, JObject log);
    [CanBeNullAttribute]
public JObject ReadLog(UInt32 gapId);
    private static JObject DeserializeGapData(Byte[] data);
    [CanBeNullAttribute]
private Byte[] GetGapData(UInt32 gapId);
    public void ImportGapData(GapUploadInfo gapData);
    public void Dump(StreamWriter writer);
}
[ShellComponentAttribute("0")]
public class JetBrains.UsageStatistics.UsageDbManager : object {
    private Lifetime myLifetime;
    private ProductSettingsLocation myProductSettingsLocation;
    private IThreading myTaskHost;
    private ILogger myLogger;
    private UsageDb myDb;
    public IProperty`1<bool> IsDbPrimaryAndReady;
    protected bool myTriedToOpen;
    private SingleThreadExecutor myExecutor;
    private static string DatabaseDirBaseName;
    private static ReadonlyToken ourReadonlyToken;
    public bool IsActive { get; }
    public UsageDbManager(Lifetime lifetime, ProductSettingsLocation productSettingsLocation, IThreading taskHost, ILogger logger, EventRecordsProvider eventRecordsProvider);
    private static UsageDbManager();
    public bool get_IsActive();
    protected virtual void OpenDb();
    private static void EnumerateAndImportSecondaries(ITaskHost taskHost, FileSystemPath dbFolder, UsageDb db);
    private FileSystemPath CreateSecondaryPath(FileSystemPath basePath);
    public void WithDb(Action`1<UsageDb> action, bool sync);
    [CompilerGeneratedAttribute]
private void <.ctor>b__12_2(Task task);
    [CompilerGeneratedAttribute]
private EventRecord <.ctor>b__12_1();
}
[ShellComponentAttribute("10")]
public class JetBrains.UsageStatistics.Vs.ActionActivityTracking : object {
    public ActionActivityTracking(Lifetime lifetime, ActionEvents actionEvents, UsageStatistics usageStatistics, ActionsCounterCollector actionsCounterCollectors, IComponentContainer componentContainer);
}
[CounterUsagesCollectorAttribute("16")]
public class JetBrains.UsageStatistics.Vs.ActionsCounterCollector : CounterUsagesCollector {
    private EventLogGroup myGroup;
    protected EventId2`2<string, string> ActionEvent;
    public ActionsCounterCollector(FeatureUsageLogger featureUsageLogger);
    public virtual void RegisterAction(ActionEventArgs args);
    public virtual EventLogGroup GetGroup();
}
[ZoneMarkerAttribute]
internal class JetBrains.UsageStatistics.ZoneMarker : object {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
