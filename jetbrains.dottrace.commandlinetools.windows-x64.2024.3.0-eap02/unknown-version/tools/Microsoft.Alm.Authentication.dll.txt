public enum Microsoft.Alm.Authentication.AcquireCredentialResult : Enum {
    public int value__;
    public static AcquireCredentialResult Unknown;
    public static AcquireCredentialResult Failed;
    public static AcquireCredentialResult Suceeded;
}
public class Microsoft.Alm.Authentication.AcquireCredentialsDelegate : MulticastDelegate {
    public AcquireCredentialsDelegate(object object, IntPtr method);
    public virtual Credential Invoke(TargetUri targetUri);
    public virtual IAsyncResult BeginInvoke(TargetUri targetUri, AsyncCallback callback, object object);
    public virtual Credential EndInvoke(IAsyncResult result);
}
public class Microsoft.Alm.Authentication.AcquireResultDelegate : MulticastDelegate {
    public AcquireResultDelegate(object object, IntPtr method);
    public virtual void Invoke(TargetUri targetUri, AcquireCredentialResult result);
    public virtual IAsyncResult BeginInvoke(TargetUri targetUri, AcquireCredentialResult result, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public abstract class Microsoft.Alm.Authentication.Base : object {
    private RuntimeContext _context;
    protected RuntimeContext Context { get; }
    protected INetwork Network { get; }
    protected ISettings Settings { get; }
    protected IStorage Storage { get; }
    protected ITrace Trace { get; }
    protected IWhere Where { get; }
    protected Base(RuntimeContext context);
    protected RuntimeContext get_Context();
    protected INetwork get_Network();
    protected ISettings get_Settings();
    protected IStorage get_Storage();
    protected ITrace get_Trace();
    protected IWhere get_Where();
    protected IEnumerable`1<IRuntimeService> EnumerateServices();
    protected T GetService();
    protected void SetService(T service);
}
public abstract class Microsoft.Alm.Authentication.BaseAuthentication : Base {
    protected BaseAuthentication(RuntimeContext context);
    public abstract virtual Task`1<bool> DeleteCredentials(TargetUri targetUri);
    public virtual Task`1<bool> DeleteCredentials(TargetUri targetUri, string username);
    public abstract virtual Task`1<Credential> GetCredentials(TargetUri targetUri);
    public abstract virtual Task`1<bool> SetCredentials(TargetUri targetUri, Credential credentials);
}
public abstract class Microsoft.Alm.Authentication.BaseSecureStore : Base {
    public static int AttributeMaxLengh;
    public static int PasswordMaxLength;
    public static int StringMaxLength;
    public static int UsernameMaxLength;
    public static Char[] IllegalCharacters;
    protected BaseSecureStore(RuntimeContext context);
    private static BaseSecureStore();
    protected bool Delete(string targetName);
    [IteratorStateMachineAttribute("Microsoft.Alm.Authentication.BaseSecureStore/<EnumerateCredentials>d__7")]
protected IEnumerable`1<Secret> EnumerateCredentials(string namespace);
    protected abstract virtual string GetTargetName(TargetUri targetUri);
    protected void PurgeCredentials(string namespace);
    protected Credential ReadCredentials(string targetName);
    protected Token ReadToken(string targetName);
    protected bool WriteCredential(string targetName, Credential credentials);
    protected bool WriteToken(string targetName, Token token);
    public static void ValidateTargetUri(TargetUri targetUri);
}
public class Microsoft.Alm.Authentication.BasicAuthentication : BaseAuthentication {
    public static Credential NtlmCredentials;
    private AcquireCredentialsDelegate _acquireCredentials;
    private AcquireResultDelegate _acquireResult;
    private ICredentialStore _credentialStore;
    private IReadOnlyList`1<AuthenticationHeaderValue> _httpAuthenticateOptions;
    private NtlmSupport _ntlmSupport;
    public NtlmSupport NtlmSupport { get; }
    internal ICredentialStore CredentialStore { get; }
    public BasicAuthentication(RuntimeContext context, ICredentialStore credentialStore, NtlmSupport ntlmSupport, AcquireCredentialsDelegate acquireCredentialsCallback, AcquireResultDelegate acquireResultCallback);
    public BasicAuthentication(RuntimeContext context, ICredentialStore credentialStore);
    private static BasicAuthentication();
    public NtlmSupport get_NtlmSupport();
    internal ICredentialStore get_CredentialStore();
    [AsyncStateMachineAttribute("Microsoft.Alm.Authentication.BasicAuthentication/<AcquireCredentials>d__12")]
public Task`1<Credential> AcquireCredentials(TargetUri targetUri);
    [AsyncStateMachineAttribute("Microsoft.Alm.Authentication.BasicAuthentication/<DeleteCredentials>d__13")]
public virtual Task`1<bool> DeleteCredentials(TargetUri targetUri);
    [AsyncStateMachineAttribute("Microsoft.Alm.Authentication.BasicAuthentication/<GetCredentials>d__14")]
public virtual Task`1<Credential> GetCredentials(TargetUri targetUri);
    [AsyncStateMachineAttribute("Microsoft.Alm.Authentication.BasicAuthentication/<SetCredentials>d__15")]
public virtual Task`1<bool> SetCredentials(TargetUri targetUri, Credential credentials);
}
public class Microsoft.Alm.Authentication.Credential : Secret {
    [SuppressMessageAttribute("Microsoft.Security", "CA2104:DoNotDeclareReadOnlyMutableReferenceTypes")]
public static Credential Empty;
    private string _password;
    private string _username;
    public string Password { get; }
    public string Username { get; }
    public Credential(string username, string password);
    public Credential(string username);
    private static Credential();
    public string get_Password();
    public string get_Username();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Credential other);
    public virtual int GetHashCode();
    public string ToBase64String();
    public static bool op_Equality(Credential lhs, Credential rhs);
    public static bool op_Inequality(Credential lhs, Credential rhs);
}
[DefaultMemberAttribute("Item")]
public class Microsoft.Alm.Authentication.Git.Configuration : Base {
    private static char HostSplitCharacter;
    private static Regex CommentRegex;
    private static Regex KeyValueRegex;
    private static Regex SectionRegex;
    private Dictionary`2<ConfigurationLevel, Dictionary`2<string, string>> _values;
    public static IEnumerable`1<ConfigurationLevel> Levels { get; }
    public string Item { get; }
    public int Count { get; }
    internal Configuration(RuntimeContext context);
    internal Configuration(RuntimeContext context, Dictionary`2<ConfigurationLevel, Dictionary`2<string, string>> values);
    private static Configuration();
    [IteratorStateMachineAttribute("Microsoft.Alm.Authentication.Git.Configuration/<get_Levels>d__8")]
public static IEnumerable`1<ConfigurationLevel> get_Levels();
    public virtual string get_Item(string key);
    public virtual int get_Count();
    public virtual bool ContainsKey(string key);
    public virtual bool ContainsKey(ConfigurationLevel levels, string key);
    [IteratorStateMachineAttribute("Microsoft.Alm.Authentication.Git.Configuration/<EnumerateEntriesByLevel>d__15")]
public virtual IEnumerator`1<Entry> EnumerateEntriesByLevel(ConfigurationLevel desiredLevels);
    public virtual IEnumerator`1<Entry> GetEnumerator();
    public static bool PaserBoolean(string value);
    [AsyncStateMachineAttribute("Microsoft.Alm.Authentication.Git.Configuration/<LoadGitConfiguration>d__18")]
public virtual Task LoadGitConfiguration(string worktreePath, ConfigurationLevel types);
    [AsyncStateMachineAttribute("Microsoft.Alm.Authentication.Git.Configuration/<ReadConfiuration>d__19")]
public static Task`1<Configuration> ReadConfiuration(RuntimeContext context, string worktreePath, bool loadLocal, bool loadSystem);
    public virtual bool TryGetEntry(string prefix, string key, string suffix, Entry& entry);
    public virtual bool TryGetEntry(string prefix, Uri targetUri, string key, Entry& entry);
    [AsyncStateMachineAttribute("Microsoft.Alm.Authentication.Git.Configuration/<ParseGitConfig>d__22")]
[SuppressMessageAttribute("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes")]
[SuppressMessageAttribute("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal static Task ParseGitConfig(RuntimeContext context, TextReader reader, IDictionary`2<string, string> destination);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [AsyncStateMachineAttribute("Microsoft.Alm.Authentication.Git.Configuration/<ParseGitConfig>d__24")]
private Task ParseGitConfig(ConfigurationLevel level, string configPath);
}
internal class Microsoft.Alm.Authentication.Git.ConfigurationEntryComparer : object {
    public sealed virtual bool Equals(Entry lhs, Entry rhs);
    public sealed virtual int GetHashCode(Entry obj);
}
[SuppressMessageAttribute("Microsoft.Naming", "CA1714:FlagsEnumsShouldHavePluralNames")]
[FlagsAttribute]
public enum Microsoft.Alm.Authentication.Git.ConfigurationLevel : Enum {
    public int value__;
    public static ConfigurationLevel None;
    public static ConfigurationLevel Portable;
    public static ConfigurationLevel System;
    public static ConfigurationLevel Xdg;
    public static ConfigurationLevel Global;
    public static ConfigurationLevel Local;
    public static ConfigurationLevel All;
    public static ConfigurationLevel NoLocal;
    public static ConfigurationLevel NoSystem;
    public static ConfigurationLevel UserOnly;
}
public class Microsoft.Alm.Authentication.Git.Installation : Base {
    [SuppressMessageAttribute("Microsoft.Security", "CA2104:DoNotDeclareReadOnlyMutableReferenceTypes")]
public static IEqualityComparer`1<Installation> Comparer;
    internal static string GitExeName;
    internal static string AllVersionCmdPath;
    internal static string AllVersionGitPath;
    internal static string AllVersionShPath;
    internal static string AllVersionBinGitPath;
    internal static string Version1Config32Path;
    internal static string Version2Config32Path;
    internal static string Version2Config64Path;
    internal static string Version1Doc32Path;
    internal static string Version2Doc32Path;
    internal static string Version2Doc64Path;
    internal static string Version1Libexec32Path;
    internal static string Version2Libexec32Path;
    internal static string Version2Libexec64Path;
    [SuppressMessageAttribute("Microsoft.Security", "CA2104:DoNotDeclareReadOnlyMutableReferenceTypes")]
public static IReadOnlyDictionary`2<KnownDistribution, string> CommonCmdPaths;
    [SuppressMessageAttribute("Microsoft.Security", "CA2104:DoNotDeclareReadOnlyMutableReferenceTypes")]
public static IReadOnlyDictionary`2<KnownDistribution, string> CommonConfigPaths;
    [SuppressMessageAttribute("Microsoft.Security", "CA2104:DoNotDeclareReadOnlyMutableReferenceTypes")]
public static IReadOnlyDictionary`2<KnownDistribution, string> CommonGitPaths;
    [SuppressMessageAttribute("Microsoft.Security", "CA2104:DoNotDeclareReadOnlyMutableReferenceTypes")]
public static IReadOnlyDictionary`2<KnownDistribution, string> CommonLibexecPaths;
    [SuppressMessageAttribute("Microsoft.Security", "CA2104:DoNotDeclareReadOnlyMutableReferenceTypes")]
public static IReadOnlyDictionary`2<KnownDistribution, string> CommonShPaths;
    [SuppressMessageAttribute("Microsoft.Security", "CA2104:DoNotDeclareReadOnlyMutableReferenceTypes")]
public static IReadOnlyDictionary`2<KnownDistribution, string> CommonDocPaths;
    private string _config;
    private string _cmd;
    private string _doc;
    private string _git;
    private string _libexec;
    private string _sh;
    private string _path;
    private KnownDistribution _distribution;
    public string Config { get; }
    public string Cmd { get; }
    public string Doc { get; }
    public string Git { get; }
    public string Libexec { get; }
    public string Path { get; }
    public string Sh { get; }
    public KnownDistribution Version { get; }
    internal Installation(RuntimeContext context, string path, KnownDistribution version);
    private static Installation();
    public string get_Config();
    public string get_Cmd();
    public string get_Doc();
    public string get_Git();
    public string get_Libexec();
    public string get_Path();
    public string get_Sh();
    public KnownDistribution get_Version();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Installation other);
    public virtual int GetHashCode();
    public virtual string ToString();
    internal bool IsValid();
    public static bool op_Equality(Installation lhs, Installation rhs);
    public static bool op_Inequality(Installation lhs, Installation rhs);
}
public class Microsoft.Alm.Authentication.Git.InstallationComparer : object {
    [SuppressMessageAttribute("Microsoft.Security", "CA2104:DoNotDeclareReadOnlyMutableReferenceTypes")]
public static StringComparer PathComparer;
    private static InstallationComparer();
    [SuppressMessageAttribute("Microsoft.Naming", "CA1725:ParameterNamesShouldMatchBaseDeclaration")]
[SuppressMessageAttribute("Microsoft.Naming", "CA1725:ParameterNamesShouldMatchBaseDeclaration")]
public sealed virtual bool Equals(Installation lhs, Installation rhs);
    [SuppressMessageAttribute("Microsoft.Naming", "CA1725:ParameterNamesShouldMatchBaseDeclaration")]
public sealed virtual int GetHashCode(Installation value);
}
public interface Microsoft.Alm.Authentication.Git.ITrace {
    public abstract virtual void AddListener(TextWriter listener);
    public abstract virtual void Flush();
    [SuppressMessageAttribute("Microsoft.Design", "CA1026:DefaultParametersShouldNotBeUsed")]
public abstract virtual void WriteException(Exception exception, string filePath, int lineNumber, string memberName);
    [SuppressMessageAttribute("Microsoft.Design", "CA1026:DefaultParametersShouldNotBeUsed")]
public abstract virtual void WriteLine(string message, string filePath, int lineNumber, string memberName);
}
public interface Microsoft.Alm.Authentication.Git.IUtilities {
    public abstract virtual bool TryReadGitRemoteHttpDetails(String& commandLine, String& imagePath);
}
public interface Microsoft.Alm.Authentication.Git.IWhere {
    public abstract virtual bool FindApp(string name, String& path);
    public abstract virtual bool FindGitInstallation(string path, KnownDistribution distro, Installation& installation);
    public abstract virtual bool FindGitInstallations(List`1& installations);
    public abstract virtual bool GitGlobalConfig(String& path);
    public abstract virtual bool GitLocalConfig(String& path);
    public abstract virtual bool GitLocalConfig(string startingDirectory, String& path);
    public abstract virtual bool GitPortableConfig(String& path);
    public abstract virtual bool GitSystemConfig(Installation installation, String& path);
    public abstract virtual bool GitXdgConfig(String& path);
    public abstract virtual string Home();
}
public enum Microsoft.Alm.Authentication.Git.KnownDistribution : Enum {
    public int value__;
    public static KnownDistribution GitForWindows32v1;
    public static KnownDistribution GitForWindows32v2;
    public static KnownDistribution GitForWindows64v2;
}
internal class Microsoft.Alm.Authentication.Git.Trace : Base {
    private object _syncpoint;
    private List`1<TextWriter> _writers;
    public Type ServiceType { get; }
    public Trace(RuntimeContext context);
    protected virtual override void Finalize();
    public sealed virtual Type get_ServiceType();
    public sealed virtual void AddListener(TextWriter listener);
    public sealed virtual void Dispose();
    public sealed virtual void Flush();
    [SuppressMessageAttribute("Microsoft.Design", "CA1026:DefaultParametersShouldNotBeUsed")]
public sealed virtual void WriteException(Exception exception, string filePath, int lineNumber, string memberName);
    [SuppressMessageAttribute("Microsoft.Design", "CA1026:DefaultParametersShouldNotBeUsed")]
public sealed virtual void WriteLine(string message, string filePath, int lineNumber, string memberName);
    private void Dispose(bool finalizing);
    private static string FormatText(string message, string filePath, int lineNumber, string memberName);
}
internal class Microsoft.Alm.Authentication.Git.Utilities : Base {
    public Type ServiceType { get; }
    public Utilities(RuntimeContext context);
    public sealed virtual Type get_ServiceType();
    [SuppressMessageAttribute("Microsoft.Performance", "CA1804:RemoveUnusedLocals")]
public sealed virtual bool TryReadGitRemoteHttpDetails(String& commandLine, String& imagePath);
    internal static IEnumerable`1<ProcessEntry32> EnumerateParentProcesses();
    internal bool ReadProcessMemory(SafeProcessHandle processHandle, String& commandLine, String& imagePath);
}
internal class Microsoft.Alm.Authentication.Git.Where : Base {
    public Type ServiceType { get; }
    public Where(RuntimeContext context);
    public sealed virtual Type get_ServiceType();
    public sealed virtual bool FindApp(string name, String& path);
    public sealed virtual bool FindGitInstallation(string path, KnownDistribution distro, Installation& installation);
    public sealed virtual bool FindGitInstallations(List`1& installations);
    public sealed virtual string Home();
    public sealed virtual bool GitGlobalConfig(String& path);
    [SuppressMessageAttribute("Microsoft.Performance", "CA1800:DoNotCastUnnecessarily")]
[SuppressMessageAttribute("Microsoft.Usage", "CA2202:Do not dispose objects multiple times")]
public sealed virtual bool GitLocalConfig(string startingDirectory, String& path);
    public sealed virtual bool GitLocalConfig(String& path);
    public sealed virtual bool GitPortableConfig(String& path);
    public sealed virtual bool GitSystemConfig(Installation installation, String& path);
    public sealed virtual bool GitXdgConfig(String& path);
    [CompilerGeneratedAttribute]
private void <FindGitInstallations>g__ScanApplicationData|5_0(IList`1<Installation> output);
    [CompilerGeneratedAttribute]
private void <FindGitInstallations>g__ScanProgramFiles|5_1(IList`1<Installation> output);
    [CompilerGeneratedAttribute]
private void <FindGitInstallations>g__ScanRegistry|5_2(IList`1<Installation> output);
    [CompilerGeneratedAttribute]
private void <FindGitInstallations>g__ScanShellPath|5_3(IList`1<Installation> output);
    [CompilerGeneratedAttribute]
private string <GitLocalConfig>g__hasOdb|8_0(string dir);
}
public static class Microsoft.Alm.Authentication.Global : object {
    public static int MaxAutomaticRedirections;
    private static int _requestTimeout;
    private static object _syncpoint;
    private static string _useragent;
    public static string UserAgent { get; public set; }
    public static int RequestTimeout { get; public set; }
    private static Global();
    public static string get_UserAgent();
    public static void set_UserAgent(string value);
    public static int get_RequestTimeout();
    public static void set_RequestTimeout(int value);
    private static string BuildDefaultUserAgent(RuntimeContext context);
}
public interface Microsoft.Alm.Authentication.IAuthentication {
    public abstract virtual Task`1<bool> DeleteCredentials(TargetUri targetUri);
    public abstract virtual Task`1<Credential> GetCredentials(TargetUri targetUri);
    public abstract virtual Task`1<bool> SetCredentials(TargetUri targetUri, Credential credentials);
}
public interface Microsoft.Alm.Authentication.ICredentialStore {
    public abstract virtual Task`1<bool> DeleteCredentials(TargetUri targetUri);
    public abstract virtual Task`1<Credential> ReadCredentials(TargetUri targetUri);
    public abstract virtual Task`1<bool> WriteCredentials(TargetUri targetUri, Credential credentials);
}
public interface Microsoft.Alm.Authentication.INetwork {
    public abstract virtual Task`1<INetworkResponseMessage> HttpGetAsync(TargetUri targetUri, NetworkRequestOptions options);
    public abstract virtual Task`1<INetworkResponseMessage> HttpGetAsync(TargetUri targetUri);
    public abstract virtual Task`1<INetworkResponseMessage> HttpHeadAsync(TargetUri targetUri, NetworkRequestOptions options);
    public abstract virtual Task`1<INetworkResponseMessage> HttpHeadAsync(TargetUri targetUri);
    public abstract virtual Task`1<INetworkResponseMessage> HttpPostAsync(TargetUri targetUri, HttpContent content, NetworkRequestOptions options);
    public abstract virtual Task`1<INetworkResponseMessage> HttpPostAsync(TargetUri targetUri, StringContent content);
}
public interface Microsoft.Alm.Authentication.INetworkResponseContent {
    public Byte[] AsByteArray { get; }
    public string AsString { get; }
    public bool IsByteArray { get; }
    public bool IsString { get; }
    public string MediaType { get; }
    public abstract virtual Byte[] get_AsByteArray();
    public abstract virtual string get_AsString();
    public abstract virtual bool get_IsByteArray();
    public abstract virtual bool get_IsString();
    public abstract virtual string get_MediaType();
}
public interface Microsoft.Alm.Authentication.INetworkResponseHeaders {
    public IEnumerable`1<AuthenticationHeaderValue> WwwAuthenticate { get; }
    public abstract virtual IEnumerable`1<AuthenticationHeaderValue> get_WwwAuthenticate();
    public abstract virtual bool TryGetValues(string name, IEnumerable`1& values);
}
public interface Microsoft.Alm.Authentication.INetworkResponseMessage {
    public INetworkResponseContent Content { get; }
    public HttpStatusCode StatusCode { get; }
    public INetworkResponseHeaders Headers { get; }
    public bool IsSuccessStatusCode { get; }
    public abstract virtual INetworkResponseContent get_Content();
    public abstract virtual HttpStatusCode get_StatusCode();
    public abstract virtual INetworkResponseHeaders get_Headers();
    public abstract virtual bool get_IsSuccessStatusCode();
}
public interface Microsoft.Alm.Authentication.IRuntimeService {
    public Type ServiceType { get; }
    public abstract virtual Type get_ServiceType();
}
public interface Microsoft.Alm.Authentication.ISecretStore {
    public string Namespace { get; }
    public UriNameConversionDelegate UriNameConversion { get; public set; }
    public abstract virtual string get_Namespace();
    public abstract virtual UriNameConversionDelegate get_UriNameConversion();
    public abstract virtual void set_UriNameConversion(UriNameConversionDelegate value);
}
public interface Microsoft.Alm.Authentication.ISettings {
    public string CommandLine { get; }
    public string CurrentDirectory { get; }
    public bool Is64BitOperatingSystem { get; }
    public string MachineName { get; }
    public string NewLine { get; }
    public OperatingSystem OsVersion { get; }
    public Version Version { get; }
    public abstract virtual string get_CommandLine();
    public abstract virtual string get_CurrentDirectory();
    public abstract virtual bool get_Is64BitOperatingSystem();
    public abstract virtual string get_MachineName();
    public abstract virtual string get_NewLine();
    public abstract virtual OperatingSystem get_OsVersion();
    public abstract virtual Version get_Version();
    public abstract virtual string ExpandEnvironmentVariables(string name);
    public abstract virtual void Exit(int exitCode);
    public abstract virtual String[] GetCommandLineArgs();
    public abstract virtual IDictionary`2<string, string> GetEnvironmentVariables(EnvironmentVariableTarget target);
    public abstract virtual IDictionary`2<string, string> GetEnvironmentVariables();
    public abstract virtual string GetEnvironmentVariable(string variable, EnvironmentVariableTarget target);
    public abstract virtual string GetEnvironmentVariable(string variable);
    public abstract virtual string GetFolderPath(SpecialFolder folder);
}
public interface Microsoft.Alm.Authentication.IStorage {
    public abstract virtual void CreateDirectory(string path);
    public abstract virtual bool DirectoryExists(string path);
    public abstract virtual IEnumerable`1<string> EnumerateFileSystemEntries(string path, string pattern, SearchOption options);
    public abstract virtual IEnumerable`1<string> EnumerateFileSystemEntries(string path);
    public abstract virtual IEnumerable`1<SecureData> EnumerateSecureData(string prefix);
    public abstract virtual void FileCopy(string sourcePath, string targetPath, bool overwrite);
    public abstract virtual void FileCopy(string sourcePath, string targetPath);
    public abstract virtual void FileDelete(string path);
    public abstract virtual bool FileExists(string path);
    public abstract virtual Stream FileOpen(string path, FileMode mode, FileAccess access, FileShare share);
    public abstract virtual Byte[] FileReadAllBytes(string path);
    public abstract virtual string FileReadAllText(string path, Encoding encoding);
    public abstract virtual string FileReadAllText(string path);
    public abstract virtual void FileWriteAllBytes(string path, Byte[] data);
    public abstract virtual void FileWriteAllText(string path, string contents, Encoding encoding);
    public abstract virtual void FileWriteAllText(string path, string contents);
    public abstract virtual String[] GetDriveRoots();
    public abstract virtual string GetFileName(string path);
    public abstract virtual string GetFullPath(string path);
    public abstract virtual string GetParent(string path);
    public abstract virtual string RegistryReadString(RegistryHive registryHive, RegistryView registryView, string registryPath, string keyName);
    public abstract virtual string RegistryReadString(RegistryHive registryHive, string registryPath, string keyName);
    public abstract virtual string RegistryReadString(string registryPath, string keyName);
    public abstract virtual int TryPurgeSecureData(string prefix);
    public abstract virtual bool TryReadSecureData(string key, String& name, Byte[]& data);
    public abstract virtual bool TryWriteSecureData(string key, string name, Byte[] data);
}
public interface Microsoft.Alm.Authentication.ITokenStore {
    public abstract virtual Task`1<bool> DeleteToken(TargetUri targetUri);
    public abstract virtual Task`1<Token> ReadToken(TargetUri targetUri);
    public abstract virtual Task`1<bool> WriteToken(TargetUri targetUri, Token token);
}
internal static class Microsoft.Alm.Authentication.NativeMethods : object {
    private static string Advapi32;
    private static string Kernel32;
    internal static bool CredDelete(string targetName, CredentialType type, UInt32 flags);
    internal static void CredFree(IntPtr credential);
    internal static bool CredRead(string targetName, CredentialType type, UInt32 flags, IntPtr& credential);
    internal static bool CredWrite(Credential& credential, UInt32 flags);
    internal static bool CredEnumerate(string targetNameFilter, CredentialEnumerateFlags flags, Int32& count, IntPtr& credenitalsArrayPtr);
    public static bool CloseHandle(IntPtr handle);
    public static bool CloseHandle(SafeHandle handle);
}
internal class Microsoft.Alm.Authentication.Network : Base {
    [SuppressMessageAttribute("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields")]
private static AuthenticationHeaderValue[] NullResult;
    public Type ServiceType { get; }
    public Network(RuntimeContext context);
    private static Network();
    public sealed virtual Type get_ServiceType();
    public sealed virtual Task`1<INetworkResponseMessage> HttpGetAsync(TargetUri targetUri, NetworkRequestOptions options);
    public sealed virtual Task`1<INetworkResponseMessage> HttpGetAsync(TargetUri targetUri);
    public sealed virtual Task`1<INetworkResponseMessage> HttpHeadAsync(TargetUri targetUri, NetworkRequestOptions options);
    public sealed virtual Task`1<INetworkResponseMessage> HttpHeadAsync(TargetUri targetUri);
    public sealed virtual Task`1<INetworkResponseMessage> HttpPostAsync(TargetUri targetUri, HttpContent content, NetworkRequestOptions options);
    public sealed virtual Task`1<INetworkResponseMessage> HttpPostAsync(TargetUri targetUri, StringContent content);
    [SuppressMessageAttribute("Microsoft.Reliability", "CA2000:Dispose objects before losing scope")]
private static HttpMessageHandler GetHttpMessageHandler(TargetUri targetUri, NetworkRequestOptions options);
    [SuppressMessageAttribute("Microsoft.Reliability", "CA2000:Dispose objects before losing scope")]
[SuppressMessageAttribute("Microsoft.Usage", "CA1801:ReviewUnusedParameters")]
private HttpClient GetHttpClient(TargetUri targetUri, HttpMessageHandler handler, NetworkRequestOptions options);
    private static IWebProxy GetHttpWebProxy(TargetUri targetUri);
}
[FlagsAttribute]
public enum Microsoft.Alm.Authentication.NetworkRequestOptionFlags : Enum {
    public int value__;
    public static NetworkRequestOptionFlags None;
    public static NetworkRequestOptionFlags AllowRedirections;
    public static NetworkRequestOptionFlags PreAuthenticate;
    public static NetworkRequestOptionFlags UseCookies;
    public static NetworkRequestOptionFlags UseCredentials;
    public static NetworkRequestOptionFlags UseProxy;
}
public class Microsoft.Alm.Authentication.NetworkRequestOptions : object {
    internal static string AcceptName;
    internal static string AcceptValue;
    internal static string AcceptEncodingName;
    internal static string AcceptEncodingDeflate;
    internal static string AcceptEncodingGzip;
    internal static string CacheControlName;
    internal static string CacheControlValue;
    private Secret _authentication;
    private CookieContainer _cookieContainer;
    private NetworkRequestOptionFlags _flags;
    private HttpRequestHeaders _headers;
    private int _maxRedirections;
    private TimeSpan _timeout;
    public Secret Authorization { get; public set; }
    public CookieContainer CookieContainer { get; public set; }
    public static NetworkRequestOptions Default { get; }
    public NetworkRequestOptionFlags Flags { get; public set; }
    public HttpRequestHeaders Headers { get; }
    public int MaxRedirections { get; public set; }
    public TimeSpan Timeout { get; public set; }
    public NetworkRequestOptions(bool setDefaults);
    public Secret get_Authorization();
    public void set_Authorization(Secret value);
    public CookieContainer get_CookieContainer();
    public void set_CookieContainer(CookieContainer value);
    public static NetworkRequestOptions get_Default();
    public NetworkRequestOptionFlags get_Flags();
    public void set_Flags(NetworkRequestOptionFlags value);
    public HttpRequestHeaders get_Headers();
    public int get_MaxRedirections();
    public void set_MaxRedirections(int value);
    public TimeSpan get_Timeout();
    public void set_Timeout(TimeSpan value);
}
internal class Microsoft.Alm.Authentication.NetworkResponseContent : object {
    public static string AcceptEncodingDeflate;
    public static string AcceptEncodingGzip;
    private Byte[] _byteArray;
    private string _mediaType;
    private string _string;
    private object _syncpoint;
    public Byte[] AsByteArray { get; }
    public string AsString { get; }
    public bool IsByteArray { get; }
    public bool IsString { get; }
    public string MediaType { get; }
    internal string DebuggerDisplay { get; }
    public sealed virtual Byte[] get_AsByteArray();
    public sealed virtual string get_AsString();
    public sealed virtual bool get_IsByteArray();
    public sealed virtual bool get_IsString();
    public sealed virtual string get_MediaType();
    internal string get_DebuggerDisplay();
    [AsyncStateMachineAttribute("Microsoft.Alm.Authentication.NetworkResponseContent/<SetContent>d__18")]
public Task SetContent(HttpContent content);
    public virtual string ToString();
}
internal class Microsoft.Alm.Authentication.NetworkResponseHeaders : object {
    private Dictionary`2<string, List`1<string>> _lookup;
    public IEnumerable`1<AuthenticationHeaderValue> WwwAuthenticate { get; }
    public sealed virtual IEnumerable`1<AuthenticationHeaderValue> get_WwwAuthenticate();
    [IteratorStateMachineAttribute("Microsoft.Alm.Authentication.NetworkResponseHeaders/<GetEnumerator>d__3")]
public sealed virtual IEnumerator`1<KeyValuePair`2<string, IEnumerable`1<string>>> GetEnumerator();
    public void SetHeaders(IEnumerable`1<string> data);
    public void SetHeaders(HttpResponseHeaders data);
    public sealed virtual bool TryGetValues(string name, IEnumerable`1& values);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class Microsoft.Alm.Authentication.NetworkResponseMessage : object {
    private INetworkResponseContent _content;
    private INetworkResponseHeaders _headers;
    private HttpResponseMessage _message;
    private HttpStatusCode _status;
    private object _syncpoint;
    public INetworkResponseContent Content { get; }
    public HttpStatusCode StatusCode { get; }
    public INetworkResponseHeaders Headers { get; }
    public bool IsSuccessStatusCode { get; }
    public NetworkResponseMessage(INetworkResponseContent content, INetworkResponseHeaders headers, HttpStatusCode status);
    public NetworkResponseMessage(HttpResponseMessage httpMessage);
    protected virtual override void Finalize();
    public sealed virtual INetworkResponseContent get_Content();
    public sealed virtual HttpStatusCode get_StatusCode();
    public sealed virtual INetworkResponseHeaders get_Headers();
    public sealed virtual bool get_IsSuccessStatusCode();
    public sealed virtual void Dispose();
    private void Dispose(bool finalizing);
    [AsyncStateMachineAttribute("Microsoft.Alm.Authentication.NetworkResponseMessage/<SetContent>d__19")]
public Task SetContent(HttpContent httpContent);
}
public enum Microsoft.Alm.Authentication.NtlmSupport : Enum {
    public int value__;
    public static NtlmSupport Auto;
    public static NtlmSupport Never;
    public static NtlmSupport Always;
}
[SuppressMessageAttribute("Microsoft.Design", "CA1001:TypesThatOwnDisposableFieldsShouldBeDisposable")]
[DebuggerDisplayAttribute("{DebuggerDisplay, nq}")]
public class Microsoft.Alm.Authentication.RuntimeContext : object {
    [SuppressMessageAttribute("Microsoft.Security", "CA2104:DoNotDeclareReadOnlyMutableReferenceTypes")]
public static RuntimeContext Default;
    private static int _count;
    private int _id;
    private Dictionary`2<Type, IRuntimeService> _services;
    private object _syncpoint;
    public int Id { get; }
    public INetwork Network { get; internal set; }
    public ISettings Settings { get; internal set; }
    public IStorage Storage { get; internal set; }
    public ITrace Trace { get; internal set; }
    public IUtilities Utilities { get; internal set; }
    public IWhere Where { get; internal set; }
    internal string DebuggerDisplay { get; }
    public RuntimeContext(INetwork network, ISettings settings, IStorage storage, ITrace trace, IUtilities utilities, IWhere where);
    private static RuntimeContext();
    public int get_Id();
    public INetwork get_Network();
    internal void set_Network(INetwork value);
    public ISettings get_Settings();
    internal void set_Settings(ISettings value);
    public IStorage get_Storage();
    internal void set_Storage(IStorage value);
    public ITrace get_Trace();
    internal void set_Trace(ITrace value);
    public IUtilities get_Utilities();
    internal void set_Utilities(IUtilities value);
    public IWhere get_Where();
    internal void set_Where(IWhere value);
    internal string get_DebuggerDisplay();
    [SuppressMessageAttribute("Microsoft.Reliability", "CA2000:Dispose objects before losing scope")]
public static RuntimeContext Create();
    internal IEnumerable`1<IRuntimeService> EnumerateServices();
    internal T GetService();
    internal void SetService(T service);
}
public abstract class Microsoft.Alm.Authentication.Secret : object {
    public static string UriToName(TargetUri targetUri, string namespace);
    public static string UriToIdentityUrl(TargetUri targetUri, string namespace);
}
public class Microsoft.Alm.Authentication.SecretCache : Base {
    public static StringComparer KeyComparer;
    private Dictionary`2<string, Secret> _cache;
    private UriNameConversionDelegate _getTargetName;
    private string _namespace;
    public string Namespace { get; }
    public UriNameConversionDelegate UriNameConversion { get; public set; }
    public SecretCache(RuntimeContext context, string namespace, UriNameConversionDelegate getTargetName);
    public SecretCache(RuntimeContext context, string namespace);
    internal SecretCache(RuntimeContext context, ICredentialStore credentialStore);
    private SecretCache(RuntimeContext context);
    private static SecretCache();
    public sealed virtual string get_Namespace();
    public sealed virtual UriNameConversionDelegate get_UriNameConversion();
    public sealed virtual void set_UriNameConversion(UriNameConversionDelegate value);
    public sealed virtual Task`1<bool> DeleteCredentials(TargetUri targetUri);
    public sealed virtual Task`1<bool> DeleteToken(TargetUri targetUri);
    public IEnumerable`1<NamedSecret> EnumerateSecrets();
    public sealed virtual Task`1<Credential> ReadCredentials(TargetUri targetUri);
    public sealed virtual Task`1<Token> ReadToken(TargetUri targetUri);
    public sealed virtual Task`1<bool> WriteCredentials(TargetUri targetUri, Credential credentials);
    public sealed virtual Task`1<bool> WriteToken(TargetUri targetUri, Token token);
    private string GetTargetName(TargetUri targetUri);
}
public class Microsoft.Alm.Authentication.SecretStore : BaseSecureStore {
    private string _namespace;
    private ICredentialStore _credentialCache;
    private UriNameConversionDelegate _getTargetName;
    private ITokenStore _tokenCache;
    public string Namespace { get; }
    public UriNameConversionDelegate UriNameConversion { get; public set; }
    public SecretStore(RuntimeContext context, string namespace, ICredentialStore credentialCache, ITokenStore tokenCache, UriNameConversionDelegate getTargetName);
    public SecretStore(RuntimeContext context, string namespace, UriNameConversionDelegate getTargetName);
    public SecretStore(RuntimeContext context, string namespace);
    public sealed virtual string get_Namespace();
    public sealed virtual UriNameConversionDelegate get_UriNameConversion();
    public sealed virtual void set_UriNameConversion(UriNameConversionDelegate value);
    [AsyncStateMachineAttribute("Microsoft.Alm.Authentication.SecretStore/<DeleteCredentials>d__12")]
public sealed virtual Task`1<bool> DeleteCredentials(TargetUri targetUri);
    [AsyncStateMachineAttribute("Microsoft.Alm.Authentication.SecretStore/<DeleteToken>d__13")]
public sealed virtual Task`1<bool> DeleteToken(TargetUri targetUri);
    public Task PurgeCredentials();
    [AsyncStateMachineAttribute("Microsoft.Alm.Authentication.SecretStore/<ReadCredentials>d__15")]
public sealed virtual Task`1<Credential> ReadCredentials(TargetUri targetUri);
    [AsyncStateMachineAttribute("Microsoft.Alm.Authentication.SecretStore/<ReadToken>d__16")]
public sealed virtual Task`1<Token> ReadToken(TargetUri targetUri);
    [AsyncStateMachineAttribute("Microsoft.Alm.Authentication.SecretStore/<WriteCredentials>d__17")]
public sealed virtual Task`1<bool> WriteCredentials(TargetUri targetUri, Credential credentials);
    [AsyncStateMachineAttribute("Microsoft.Alm.Authentication.SecretStore/<WriteToken>d__18")]
public sealed virtual Task`1<bool> WriteToken(TargetUri targetUri, Token token);
    protected virtual string GetTargetName(TargetUri targetUri);
}
[DebuggerDisplayAttribute("{DebuggerDisplay, nq}")]
public class Microsoft.Alm.Authentication.SecureData : ValueType {
    internal static SecureDataComparer Comparer;
    private Byte[] _data;
    private string _key;
    private string _name;
    [SuppressMessageAttribute("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays")]
public Byte[] Data { get; }
    public string Key { get; }
    public string Name { get; }
    internal string DebuggerDisplay { get; }
    internal SecureData(string key, string name, Byte[] data);
    private static SecureData();
    public Byte[] get_Data();
    public string get_Key();
    public string get_Name();
    internal string get_DebuggerDisplay();
    public sealed virtual bool Equals(SecureData other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(SecureData lhs, SecureData rhs);
    public static bool op_Inequality(SecureData lhs, SecureData rhs);
}
internal class Microsoft.Alm.Authentication.SecureDataComparer : object {
    public static SecureDataComparer Instance;
    private static SecureDataComparer();
    public sealed virtual bool Equals(SecureData lhs, SecureData rhs);
    public sealed virtual int GetHashCode(SecureData obj);
}
internal class Microsoft.Alm.Authentication.Settings : Base {
    public string CommandLine { get; }
    public string CurrentDirectory { get; }
    public Type ServiceType { get; }
    public bool Is64BitOperatingSystem { get; }
    public string MachineName { get; }
    public string NewLine { get; }
    public OperatingSystem OsVersion { get; }
    public Version Version { get; }
    public Settings(RuntimeContext context);
    public sealed virtual string get_CommandLine();
    public sealed virtual string get_CurrentDirectory();
    public sealed virtual Type get_ServiceType();
    public sealed virtual bool get_Is64BitOperatingSystem();
    public sealed virtual string get_MachineName();
    public sealed virtual string get_NewLine();
    public sealed virtual OperatingSystem get_OsVersion();
    public sealed virtual Version get_Version();
    public sealed virtual void Exit(int exitCode);
    public sealed virtual string ExpandEnvironmentVariables(string name);
    public sealed virtual String[] GetCommandLineArgs();
    public sealed virtual IDictionary`2<string, string> GetEnvironmentVariables(EnvironmentVariableTarget target);
    internal IDictionary`2<string, string> DeduplicateStringDictionary(IDictionary variables);
    public sealed virtual IDictionary`2<string, string> GetEnvironmentVariables();
    public sealed virtual string GetEnvironmentVariable(string variable, EnvironmentVariableTarget target);
    public sealed virtual string GetEnvironmentVariable(string variable);
    public sealed virtual string GetFolderPath(SpecialFolder folder);
}
internal class Microsoft.Alm.Authentication.Storage : Base {
    public Type ServiceType { get; }
    public Storage(RuntimeContext context);
    public sealed virtual Type get_ServiceType();
    public sealed virtual void CreateDirectory(string path);
    public sealed virtual bool DirectoryExists(string path);
    public sealed virtual IEnumerable`1<string> EnumerateFileSystemEntries(string path, string pattern, SearchOption options);
    public sealed virtual IEnumerable`1<string> EnumerateFileSystemEntries(string path);
    [IteratorStateMachineAttribute("Microsoft.Alm.Authentication.Storage/<EnumerateSecureData>d__7")]
public sealed virtual IEnumerable`1<SecureData> EnumerateSecureData(string prefix);
    public sealed virtual void FileCopy(string sourcePath, string destinationPath);
    public sealed virtual void FileCopy(string sourcePath, string destinationPath, bool overwrite);
    public sealed virtual void FileDelete(string path);
    public sealed virtual bool FileExists(string path);
    public sealed virtual Stream FileOpen(string path, FileMode mode, FileAccess access, FileShare share);
    public sealed virtual Byte[] FileReadAllBytes(string path);
    public sealed virtual string FileReadAllText(string path, Encoding encoding);
    public sealed virtual string FileReadAllText(string path);
    public sealed virtual void FileWriteAllBytes(string path, Byte[] bytes);
    public sealed virtual void FileWriteAllText(string path, string contents, Encoding encoding);
    public sealed virtual void FileWriteAllText(string path, string contents);
    public sealed virtual String[] GetDriveRoots();
    public sealed virtual string GetFileName(string path);
    public sealed virtual string GetFullPath(string path);
    public sealed virtual string GetParent(string path);
    public sealed virtual string RegistryReadString(RegistryHive registryHive, RegistryView registryView, string registryPath, string keyName);
    public sealed virtual string RegistryReadString(RegistryHive registryHive, string registryPath, string keyName);
    public sealed virtual string RegistryReadString(string registryPath, string keyName);
    public sealed virtual int TryPurgeSecureData(string prefix);
    public sealed virtual bool TryReadSecureData(string key, String& name, Byte[]& data);
    public sealed virtual bool TryWriteSecureData(string key, string name, Byte[] data);
}
public class Microsoft.Alm.Authentication.TargetUri : object {
    private Uri _actualUri;
    private Uri _proxyUri;
    private Uri _queryUri;
    public string AbsolutePath { get; }
    public Uri ActualUri { get; }
    public bool ContainsUserInfo { get; }
    public string DnsSafeHost { get; }
    public bool HasPath { get; }
    public string Host { get; }
    [SuppressMessageAttribute("Microsoft.Performance", "CA1822:MarkMembersAsStatic")]
public bool IsAbsoluteUri { get; }
    public bool IsDefaultPort { get; }
    public int Port { get; }
    public Uri ProxyUri { get; }
    public Uri QueryUri { get; }
    public string Scheme { get; }
    public string UserInfo { get; }
    public TargetUri(Uri queryUri, Uri proxyUri, Uri actualUri);
    public TargetUri(Uri queryUri, Uri proxyUri);
    public TargetUri(Uri target);
    public TargetUri(string queryUrl, string proxyUrl, string actualUrl);
    public TargetUri(string targetUrl, string proxyUrl);
    public TargetUri(string targetUrl);
    public string get_AbsolutePath();
    public Uri get_ActualUri();
    public bool get_ContainsUserInfo();
    public string get_DnsSafeHost();
    public bool get_HasPath();
    public string get_Host();
    public bool get_IsAbsoluteUri();
    public bool get_IsDefaultPort();
    public int get_Port();
    public Uri get_ProxyUri();
    public Uri get_QueryUri();
    public string get_Scheme();
    public string get_UserInfo();
    [SuppressMessageAttribute("Microsoft.Design", "CA1026:DefaultParametersShouldNotBeUsed")]
public TargetUri CreateWith(string queryUrl, string proxyUrl, string actualUrl);
    [SuppressMessageAttribute("Microsoft.Design", "CA1026:DefaultParametersShouldNotBeUsed")]
public TargetUri CreateWith(Uri queryUri, Uri proxyUri, Uri actualUri);
    public TargetUri GetPerUserTargetUri(string username);
    public bool IsBaseOf(Uri uri);
    public bool IsBaseOf(TargetUri targetUri);
    public virtual string ToString();
    public string ToString(bool username, bool port, bool path);
    public static Uri op_Implicit(TargetUri targetUri);
    public static TargetUri op_Implicit(Uri uri);
}
public class Microsoft.Alm.Authentication.Token : Secret {
    public static StringComparer TokenComparer;
    private TokenType _type;
    private string _value;
    private Guid _targetIdentity;
    [SuppressMessageAttribute("Microsoft.Naming", "CA1721:PropertyNamesShouldNotMatchGetMethods")]
public TokenType Type { get; }
    public string Value { get; }
    public Guid TargetIdentity { get; public set; }
    public Token(string value, TokenType type);
    public Token(string value, string typeName);
    public Token(string value, Guid tenantId, TokenType type);
    private static Token();
    public TokenType get_Type();
    public string get_Value();
    public Guid get_TargetIdentity();
    public void set_TargetIdentity(Guid value);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Token other);
    public static bool GetFriendlyNameFromType(TokenType type, String& name);
    public static bool GetTypeFromFriendlyName(string name, TokenType& type);
    public virtual int GetHashCode();
    public virtual string ToString();
    internal static bool Deserialize(RuntimeContext context, Byte[] bytes, TokenType type, Token& token);
    internal static bool Serialize(RuntimeContext context, Token token, Byte[]& bytes);
    public static Credential op_Explicit(Token token);
    public static bool op_Equality(Token lhs, Token rhs);
    public static bool op_Inequality(Token lhs, Token rhs);
}
public abstract class Microsoft.Alm.Authentication.TokenScope : object {
    protected IReadOnlyList`1<string> _scopes;
    public string Value { get; }
    protected TokenScope(string value);
    protected TokenScope(String[] values);
    protected TokenScope(HashSet`1<string> set);
    public string get_Value();
    protected static bool Equals(TokenScope lhs, TokenScope rhs);
    protected static bool Equals(TokenScope lhs, object rhs);
    public sealed virtual bool Equals(TokenScope other);
    public virtual bool Equals(object obj);
    protected static HashSet`1<string> ExceptWith(TokenScope lhs, TokenScope rhs);
    protected static int GetHashCode(TokenScope value);
    public virtual int GetHashCode();
    protected static HashSet`1<string> IntersectWith(TokenScope lhs, TokenScope rhs);
    protected static HashSet`1<string> SymmetricExceptWith(TokenScope lhs, TokenScope rhs);
    public virtual string ToString();
    protected static HashSet`1<string> UnionWith(TokenScope lhs, TokenScope rhs);
    public static bool op_Equality(TokenScope lhs, TokenScope rhs);
    public static bool op_Inequality(TokenScope lhs, TokenScope rhs);
}
public enum Microsoft.Alm.Authentication.TokenType : Enum {
    public int value__;
    public static TokenType Unknown;
    [DescriptionAttribute("Azure Directory Access Token")]
public static TokenType AzureAccess;
    [ObsoleteAttribute("Azure Directory no longer directly supports Refresh tokens.", "True")]
[DescriptionAttribute("Azure Directory Refresh Token")]
public static TokenType AzureRefresh;
    [DescriptionAttribute("Federated Authentication Token")]
public static TokenType AzureFederated;
    [DescriptionAttribute("Personal Access Token")]
public static TokenType Personal;
    [DescriptionAttribute("Test-only Token")]
public static TokenType Test;
    [DescriptionAttribute("Bitbucket Access Token")]
public static TokenType BitbucketAccess;
    [DescriptionAttribute("Bitbucket Refresh Token")]
public static TokenType BitbucketRefresh;
}
internal class Microsoft.Alm.Authentication.WwwAuthenticateHelper : object {
    public static Credential Credentials;
    public static AuthenticationHeaderValue NtlmHeader;
    public static AuthenticationHeaderValue NegotiateHeader;
    private static AuthenticationHeaderValue[] NullResult;
    private static WwwAuthenticateHelper();
    [AsyncStateMachineAttribute("Microsoft.Alm.Authentication.WwwAuthenticateHelper/<GetHeaderValues>d__4")]
public static Task`1<AuthenticationHeaderValue[]> GetHeaderValues(RuntimeContext context, TargetUri targetUri);
    public static bool IsNtlm(AuthenticationHeaderValue value);
}
internal enum Microsoft.Alm.Win32.DesiredAccess : Enum {
    public UInt32 value__;
    public static DesiredAccess Unchanged;
    public static DesiredAccess Terminate;
    public static DesiredAccess CreateThread;
    public static DesiredAccess VirtualMemoryOperation;
    public static DesiredAccess VirtualMemoryRead;
    public static DesiredAccess VirtualMemoryWrite;
    public static DesiredAccess DuplicateHandle;
    public static DesiredAccess CreateProcess;
    public static DesiredAccess SetQuota;
    public static DesiredAccess SetInformation;
    public static DesiredAccess QueryInformation;
    public static DesiredAccess SuspendResume;
    public static DesiredAccess QueryLimitedInformation;
    public static DesiredAccess Synchronize;
    public static DesiredAccess AllAccess;
}
[FlagsAttribute]
internal enum Microsoft.Alm.Win32.DuplicateHandleOptions : Enum {
    public UInt32 value__;
    public static DuplicateHandleOptions None;
    public static DuplicateHandleOptions CloseSource;
    public static DuplicateHandleOptions SameAccess;
}
internal enum Microsoft.Alm.Win32.ErrorCode : Enum {
    public int value__;
    public static ErrorCode Success;
    public static ErrorCode InvalidFunction;
    public static ErrorCode FileNotFound;
    public static ErrorCode PathNotFound;
    public static ErrorCode TooManyOpenFiles;
    public static ErrorCode AccessDenied;
    public static ErrorCode InvalidHandle;
    public static ErrorCode BadFormat;
    public static ErrorCode BadLength;
    public static ErrorCode InvalidParameter;
    public static ErrorCode BrokenPipe;
    public static ErrorCode InsufficientBuffer;
    public static ErrorCode AlreadyExists;
    public static ErrorCode MachineTypeMismatch;
    public static ErrorCode PipeLocal;
    public static ErrorCode BadPipe;
    public static ErrorCode PipeBusy;
    public static ErrorCode NoData;
    public static ErrorCode PipeNotConnected;
    public static ErrorCode MoreData;
    public static ErrorCode PartialCopy;
    public static ErrorCode InvalidAddress;
    public static ErrorCode PipeConnected;
    public static ErrorCode IoIncomplete;
    public static ErrorCode IoPending;
    public static ErrorCode NoAccess;
    public static ErrorCode InvalidFlags;
    public static ErrorCode NoToken;
    public static ErrorCode NotFound;
    public static ErrorCode NoSuchLogonSession;
    public static ErrorCode PrivilegeNotHeld;
    public static ErrorCode CommitLimit;
    public static ErrorCode NotEnoughQuota;
    public static ErrorCode BadUserName;
}
internal enum Microsoft.Alm.Win32.Hresult : Enum {
    public UInt32 value__;
    public static Hresult Ok;
    public static Hresult NotImplemented;
    public static Hresult NoInterface;
    public static Hresult InvalidPointer;
    public static Hresult Abort;
    public static Hresult Fail;
    public static Hresult Unexpected;
    public static Hresult AccessDenied;
    public static Hresult InvalidHandle;
    public static Hresult OutOfMemory;
    public static Hresult InvalidArgument;
    public static Hresult DiskFull;
}
internal static class Microsoft.Alm.Win32.Kernel32 : object {
    public static IntPtr InvalidHandleValue;
    public static string Name;
    private static Kernel32();
    public static bool CloseHandle(IntPtr handle);
    public static SafeSnapshotHandle CreateToolhelp32Snapshot(ToolhelpSnapshotFlags flags, UInt32 processId);
    public static ErrorCode GetLastError();
    public static SafeProcessHandle GetCurrentProcess();
    public static UInt32 GetCurrentProcessId();
    public static UInt32 GetProcessId(SafeProcessHandle processHandle);
    public static UInt32 GetProcessId(IntPtr processHandle);
    public static SafeProcessHandle OpenProcess(DesiredAccess desiredAccess, bool inheritHandle, UInt32 processId);
    public static bool Process32First(SafeSnapshotHandle snapshotHandle, ProcessEntry32& processEntry);
    public static bool Process32Next(SafeSnapshotHandle snapshotHandle, ProcessEntry32& processEntry);
    private static bool _ReadProcessMemory(SafeProcessHandle processHandle, Void* baseAddress, Void* buffer, IntPtr bufferSize, IntPtr& bytesRead);
    public static bool ReadProcessMemory(SafeProcessHandle processHandle, Void* baseAddress, Void* buffer, int bufferSize, Int32& bytesRead);
}
internal static class Microsoft.Alm.Win32.Ntdll : object {
    public static IntPtr InvalidHandleValue;
    public static string Name;
    private static Ntdll();
    public static Hresult QueryInformationProcess(SafeProcessHandle processHandle, ProcessInformationClass processInformationClass, ProcessBasicInformation* processInformation, int processInformationLength, Int64* returnLength);
}
internal class Microsoft.Alm.Win32.PebProcessParameters : ValueType {
    [FixedBufferAttribute("System.Byte", "128")]
private <_>e__FixedBuffer _;
    public UnicodeString CommandLine { get; }
    public UnicodeString ImagePathName { get; }
    public UnicodeString get_CommandLine();
    public UnicodeString get_ImagePathName();
}
internal class Microsoft.Alm.Win32.ProcessBasicInformation : ValueType {
    private Void* _reserved1;
    private Void* _pebBaseAddress;
    private Void* _reserved2;
    private Void* _reserved3;
    private UInt32* _uniqueProcessId;
    private Void* _reserved4;
    public Void* ProcessEnvironmentBlock { get; }
    public UInt32* UniqueProcessId { get; }
    public Void* get_ProcessEnvironmentBlock();
    public UInt32* get_UniqueProcessId();
}
internal class Microsoft.Alm.Win32.ProcessEntry32 : ValueType {
    public int Size;
    public UInt32 Usage;
    public UInt32 ProcessId;
    public UIntPtr DefaultHeapId;
    public UInt32 ModuleId;
    public UInt32 Threads;
    public UInt32 ParentProcessId;
    public int PriClassBase;
    public UInt32 Flags;
    public string ExeFileName;
}
internal class Microsoft.Alm.Win32.ProcessEnvironmentBlock : ValueType {
    [FixedBufferAttribute("System.Byte", "256")]
private <_>e__FixedBuffer _;
    public bool IsBeingDebugged { get; }
    public PebProcessParameters* ProcessParameters { get; }
    public bool get_IsBeingDebugged();
    public PebProcessParameters* get_ProcessParameters();
}
internal enum Microsoft.Alm.Win32.ProcessInformationClass : Enum {
    public UInt32 value__;
    public static ProcessInformationClass BasicInformation;
    public static ProcessInformationClass Default;
    public static ProcessInformationClass DebugPort;
    public static ProcessInformationClass Wow64Information;
    public static ProcessInformationClass ImageFileName;
    public static ProcessInformationClass BreakOnTermination;
    public static ProcessInformationClass SubsystemInformation;
}
internal class Microsoft.Alm.Win32.SafeProcessHandle : SafeHandle {
    public static SafeProcessHandle CurrentProcessHandle;
    public static SafeProcessHandle Null;
    public bool IsCurrentProcess { get; }
    public bool IsInvalid { get; }
    public SafeProcessHandle(IntPtr handle);
    private SafeProcessHandle(IntPtr handle, bool ownsHandle);
    private static SafeProcessHandle();
    public bool get_IsCurrentProcess();
    public virtual bool get_IsInvalid();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(SafeProcessHandle other);
    public virtual int GetHashCode();
    protected virtual bool ReleaseHandle();
    public static bool op_Equality(SafeProcessHandle left, SafeProcessHandle right);
    public static bool op_Inequality(SafeProcessHandle left, SafeProcessHandle right);
}
internal class Microsoft.Alm.Win32.SafeSnapshotHandle : SafeHandleZeroOrMinusOneIsInvalid {
    protected virtual bool ReleaseHandle();
}
[FlagsAttribute]
internal enum Microsoft.Alm.Win32.ToolhelpSnapshotFlags : Enum {
    public UInt32 value__;
    public static ToolhelpSnapshotFlags HeapList;
    public static ToolhelpSnapshotFlags Process;
    public static ToolhelpSnapshotFlags Thread;
    public static ToolhelpSnapshotFlags Module;
    public static ToolhelpSnapshotFlags Module32;
    public static ToolhelpSnapshotFlags Inherit;
    public static ToolhelpSnapshotFlags All;
}
[DebuggerDisplayAttribute("{DebuggerDisplay, nq}")]
internal class Microsoft.Alm.Win32.UnicodeString : ValueType {
    [FixedBufferAttribute("System.Byte", "16")]
private <_>e__FixedBuffer _;
    public Char* Buffer { get; }
    public int Length { get; }
    public int MaximumSize { get; }
    internal string DebuggerDisplay { get; }
    public Char* get_Buffer();
    public int get_Length();
    public int get_MaximumSize();
    internal string get_DebuggerDisplay();
    public virtual string ToString();
}
