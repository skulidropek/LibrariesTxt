internal class EnumerableAsync`1 : object {
    private SearchFilter _filter;
    private ILogger _logger;
    private string _searchTerm;
    private int _skip;
    private int _take;
    private CancellationToken _token;
    private IV2FeedParser _feedParser;
    private bool _isSearchAvailable;
    private bool _allVersions;
    public EnumerableAsync`1(IV2FeedParser feedParser, string searchTerm, SearchFilter filter, int skip, int take, bool isSearchAvailable, bool allVersions, ILogger logger, CancellationToken token);
    public sealed virtual IEnumeratorAsync`1<T> GetEnumeratorAsync();
}
internal class EnumeratorAsync : object {
    private SearchFilter _filter;
    private ILogger _logger;
    private string _searchTerm;
    private int _skip;
    private int _take;
    private CancellationToken _token;
    private IV2FeedParser _feedParser;
    private bool _isSearchAvailable;
    private bool _allVersions;
    private IEnumerator`1<IPackageSearchMetadata> _currentEnumerator;
    private V2FeedPage _currentPage;
    public IPackageSearchMetadata Current { get; }
    public EnumeratorAsync(IV2FeedParser feedParser, string searchTerm, SearchFilter filter, int skip, int take, bool isSearchAvailable, bool allVersions, ILogger logger, CancellationToken token);
    public sealed virtual IPackageSearchMetadata get_Current();
    [AsyncStateMachineAttribute("EnumeratorAsync/<MoveNextAsync>d__14")]
public sealed virtual Task`1<bool> MoveNextAsync();
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class NuGet.NoAllocEnumerateExtensions : object {
    [ExtensionAttribute]
public static OptimisticallyNonAllocatingListEnumerable`1<T> NoAllocEnumerate(IList`1<T> list);
    [ExtensionAttribute]
public static OptimisticallyNonAllocatingEnumerable`1<T> NoAllocEnumerate(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static OptimisticallyNonAllocatingDictionaryEnumerable`2<TKey, TValue> NoAllocEnumerate(IDictionary`2<TKey, TValue> dictionary);
}
public class NuGet.Protocol.AlternatePackageMetadata : object {
    [CompilerGeneratedAttribute]
private string <PackageId>k__BackingField;
    [CompilerGeneratedAttribute]
private VersionRange <Range>k__BackingField;
    [JsonPropertyAttribute]
public string PackageId { get; internal set; }
    [JsonPropertyAttribute]
public VersionRange Range { get; internal set; }
    [CompilerGeneratedAttribute]
public string get_PackageId();
    [CompilerGeneratedAttribute]
internal void set_PackageId(string value);
    [CompilerGeneratedAttribute]
public VersionRange get_Range();
    [CompilerGeneratedAttribute]
internal void set_Range(VersionRange value);
}
public class NuGet.Protocol.AmbientAuthenticationState : object {
    internal static int MaxAuthRetries;
    [CompilerGeneratedAttribute]
private bool <IsBlocked>k__BackingField;
    [CompilerGeneratedAttribute]
private int <AuthenticationRetriesCount>k__BackingField;
    public bool IsBlocked { get; private set; }
    public int AuthenticationRetriesCount { get; private set; }
    [CompilerGeneratedAttribute]
public bool get_IsBlocked();
    [CompilerGeneratedAttribute]
private void set_IsBlocked(bool value);
    [CompilerGeneratedAttribute]
public int get_AuthenticationRetriesCount();
    [CompilerGeneratedAttribute]
private void set_AuthenticationRetriesCount(int value);
    public void Block();
    public void Increment();
}
public class NuGet.Protocol.AutoCompleteResourceV2Feed : AutoCompleteResource {
    private HttpSource _httpSource;
    private Uri _baseUri;
    public AutoCompleteResourceV2Feed(HttpSourceResource httpSourceResource, string baseAddress, PackageSource packageSource);
    [AsyncStateMachineAttribute("NuGet.Protocol.AutoCompleteResourceV2Feed/<IdStartsWith>d__3")]
public virtual Task`1<IEnumerable`1<string>> IdStartsWith(string packageIdPrefix, bool includePrerelease, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.AutoCompleteResourceV2Feed/<VersionStartsWith>d__4")]
public virtual Task`1<IEnumerable`1<NuGetVersion>> VersionStartsWith(string packageId, string versionPrefix, bool includePrerelease, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.AutoCompleteResourceV2Feed/<GetResults>d__5")]
private Task`1<IEnumerable`1<string>> GetResults(Uri apiEndpointUri, ILogger logger, CancellationToken token);
}
public class NuGet.Protocol.AutoCompleteResourceV2FeedProvider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.AutoCompleteResourceV2FeedProvider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
public class NuGet.Protocol.AutoCompleteResourceV3 : AutoCompleteResource {
    private RegistrationResourceV3 _regResource;
    private ServiceIndexResourceV3 _serviceIndex;
    private HttpSource _client;
    public AutoCompleteResourceV3(HttpSource client, ServiceIndexResourceV3 serviceIndex, RegistrationResourceV3 regResource);
    [AsyncStateMachineAttribute("NuGet.Protocol.AutoCompleteResourceV3/<IdStartsWith>d__4")]
public virtual Task`1<IEnumerable`1<string>> IdStartsWith(string packageIdPrefix, bool includePrerelease, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.AutoCompleteResourceV3/<VersionStartsWith>d__5")]
public virtual Task`1<IEnumerable`1<NuGetVersion>> VersionStartsWith(string packageId, string versionPrefix, bool includePrerelease, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
}
public class NuGet.Protocol.AutoCompleteResourceV3Provider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.AutoCompleteResourceV3Provider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
public class NuGet.Protocol.CachingSourceProvider : object {
    private IPackageSourceProvider _packageSourceProvider;
    private List`1<Lazy`1<INuGetResourceProvider>> _resourceProviders;
    private List`1<SourceRepository> _repositories;
    private ConcurrentDictionary`2<string, SourceRepository> _cachedSources;
    public IPackageSourceProvider PackageSourceProvider { get; }
    public CachingSourceProvider(IPackageSourceProvider packageSourceProvider);
    public sealed virtual IEnumerable`1<SourceRepository> GetRepositories();
    public SourceRepository CreateRepository(string source);
    public sealed virtual SourceRepository CreateRepository(PackageSource source);
    public sealed virtual SourceRepository CreateRepository(PackageSource source, FeedType type);
    public void AddSourceRepository(SourceRepository source);
    public sealed virtual IPackageSourceProvider get_PackageSourceProvider();
}
public static class NuGet.Protocol.CachingUtility : object {
    public static int BufferSize;
    private static int HashLength;
    public static string ComputeHash(string value, bool addIdentifiableCharacters);
    public static Stream ReadCacheFile(TimeSpan maxAge, string cacheFile);
    public static bool IsFileAlreadyOpen(string filePath);
    public static string RemoveInvalidFileNameChars(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class NuGet.Protocol.Converters.PackageVulnerabilityInfoConverter : JsonConverter`1<PackageVulnerabilityInfo> {
    public virtual PackageVulnerabilityInfo ReadJson(JsonReader reader, Type objectType, PackageVulnerabilityInfo existingValue, bool hasExistingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter writer, PackageVulnerabilityInfo value, JsonSerializer serializer);
}
internal class NuGet.Protocol.Converters.V3SearchResultsConverter : JsonConverter {
    private UInt32 _take;
    public bool CanWrite { get; }
    public V3SearchResultsConverter(UInt32 take);
    public virtual bool get_CanWrite();
    public virtual bool CanConvert(Type objectType);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class NuGet.Protocol.Converters.VersionRangeStjConverter : JsonConverter`1<VersionRange> {
    public virtual VersionRange Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, VersionRange value, JsonSerializerOptions options);
}
public abstract class NuGet.Protocol.Core.Types.AutoCompleteResource : object {
    public abstract virtual Task`1<IEnumerable`1<string>> IdStartsWith(string packageIdPrefix, bool includePrerelease, ILogger log, CancellationToken token);
    public abstract virtual Task`1<IEnumerable`1<NuGetVersion>> VersionStartsWith(string packageId, string versionPrefix, bool includePrerelease, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
}
public abstract class NuGet.Protocol.Core.Types.DependencyInfoResource : object {
    public abstract virtual Task`1<SourcePackageDependencyInfo> ResolvePackage(PackageIdentity package, NuGetFramework projectFramework, SourceCacheContext cacheContext, ILogger log, CancellationToken token);
    public abstract virtual Task`1<IEnumerable`1<SourcePackageDependencyInfo>> ResolvePackages(string packageId, NuGetFramework projectFramework, SourceCacheContext cacheContext, ILogger log, CancellationToken token);
    public virtual Task`1<IEnumerable`1<RemoteSourceDependencyInfo>> ResolvePackages(string packageId, SourceCacheContext cacheContext, ILogger log, CancellationToken token);
}
public abstract class NuGet.Protocol.Core.Types.DownloadResource : object {
    public abstract virtual Task`1<DownloadResourceResult> GetDownloadResourceResultAsync(PackageIdentity identity, PackageDownloadContext downloadContext, string globalPackagesFolder, ILogger logger, CancellationToken token);
}
public class NuGet.Protocol.Core.Types.DownloadResourceResult : object {
    private bool _isDisposed;
    private Stream _stream;
    private PackageReaderBase _packageReader;
    private string _packageSource;
    [CompilerGeneratedAttribute]
private DownloadResourceResultStatus <Status>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SignatureVerified>k__BackingField;
    public DownloadResourceResultStatus Status { get; }
    public bool SignatureVerified { get; public set; }
    public Stream PackageStream { get; }
    public string PackageSource { get; }
    public PackageReaderBase PackageReader { get; }
    public DownloadResourceResult(DownloadResourceResultStatus status);
    public DownloadResourceResult(Stream stream, string source);
    public DownloadResourceResult(Stream stream, PackageReaderBase packageReader, string source);
    public DownloadResourceResult(PackageReaderBase packageReader, string source);
    [CompilerGeneratedAttribute]
public DownloadResourceResultStatus get_Status();
    [CompilerGeneratedAttribute]
public bool get_SignatureVerified();
    [CompilerGeneratedAttribute]
public void set_SignatureVerified(bool value);
    public Stream get_PackageStream();
    public string get_PackageSource();
    public PackageReaderBase get_PackageReader();
    public sealed virtual void Dispose();
}
public enum NuGet.Protocol.Core.Types.DownloadResourceResultStatus : Enum {
    public int value__;
    public static DownloadResourceResultStatus Available;
    public static DownloadResourceResultStatus AvailableWithoutStream;
    public static DownloadResourceResultStatus NotFound;
    public static DownloadResourceResultStatus Cancelled;
}
public class NuGet.Protocol.Core.Types.FatalProtocolException : NuGetProtocolException {
    public FatalProtocolException(string message);
    public FatalProtocolException(string message, Exception innerException);
    protected FatalProtocolException(SerializationInfo info, StreamingContext context);
}
public class NuGet.Protocol.Core.Types.FindPackageByIdDependencyInfo : object {
    [CompilerGeneratedAttribute]
private PackageIdentity <PackageIdentity>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<PackageDependencyGroup> <DependencyGroups>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<FrameworkSpecificGroup> <FrameworkReferenceGroups>k__BackingField;
    public PackageIdentity PackageIdentity { get; }
    public IReadOnlyList`1<PackageDependencyGroup> DependencyGroups { get; }
    public IReadOnlyList`1<FrameworkSpecificGroup> FrameworkReferenceGroups { get; }
    public FindPackageByIdDependencyInfo(PackageIdentity packageIdentity, IEnumerable`1<PackageDependencyGroup> dependencyGroups, IEnumerable`1<FrameworkSpecificGroup> frameworkReferenceGroups);
    [CompilerGeneratedAttribute]
public PackageIdentity get_PackageIdentity();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<PackageDependencyGroup> get_DependencyGroups();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<FrameworkSpecificGroup> get_FrameworkReferenceGroups();
}
public abstract class NuGet.Protocol.Core.Types.FindPackageByIdResource : object {
    public abstract virtual Task`1<IEnumerable`1<NuGetVersion>> GetAllVersionsAsync(string id, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    public abstract virtual Task`1<FindPackageByIdDependencyInfo> GetDependencyInfoAsync(string id, NuGetVersion version, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    public abstract virtual Task`1<bool> CopyNupkgToStreamAsync(string id, NuGetVersion version, Stream destination, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    public abstract virtual Task`1<IPackageDownloader> GetPackageDownloaderAsync(PackageIdentity packageIdentity, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    public abstract virtual Task`1<bool> DoesPackageExistAsync(string id, NuGetVersion version, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    protected static FindPackageByIdDependencyInfo GetDependencyInfo(NuspecReader reader);
}
public abstract class NuGet.Protocol.Core.Types.HttpHandlerResource : object {
    public HttpClientHandler ClientHandler { get; }
    public HttpMessageHandler MessageHandler { get; }
    public abstract virtual HttpClientHandler get_ClientHandler();
    public abstract virtual HttpMessageHandler get_MessageHandler();
}
public class NuGet.Protocol.Core.Types.HttpSourceCacheContext : object {
    [CompilerGeneratedAttribute]
private TimeSpan <MaxAge>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DirectDownload>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RootTempFolder>k__BackingField;
    [CompilerGeneratedAttribute]
private SourceCacheContext <SourceCacheContext>k__BackingField;
    public TimeSpan MaxAge { get; }
    public bool DirectDownload { get; }
    public string RootTempFolder { get; }
    public SourceCacheContext SourceCacheContext { get; }
    private HttpSourceCacheContext(string rootTempFolder, TimeSpan maxAge, bool directDownload, SourceCacheContext cacheContext);
    [CompilerGeneratedAttribute]
public TimeSpan get_MaxAge();
    [CompilerGeneratedAttribute]
public bool get_DirectDownload();
    [CompilerGeneratedAttribute]
public string get_RootTempFolder();
    [CompilerGeneratedAttribute]
public SourceCacheContext get_SourceCacheContext();
    public static HttpSourceCacheContext Create(SourceCacheContext cacheContext, int retryCount);
    public static HttpSourceCacheContext Create(SourceCacheContext cacheContext, bool isFirstAttempt);
}
public interface NuGet.Protocol.Core.Types.ILegacyFeedCapabilityResource {
    public abstract virtual Task`1<bool> SupportsIsAbsoluteLatestVersionAsync(ILogger log, CancellationToken token);
    public abstract virtual Task`1<bool> SupportsSearchAsync(ILogger log, CancellationToken token);
}
public interface NuGet.Protocol.Core.Types.INuGetResource {
}
[NullableContextAttribute("1")]
public interface NuGet.Protocol.Core.Types.INuGetResourceProvider {
    public Type ResourceType { get; }
    public string Name { get; }
    public IEnumerable`1<string> Before { get; }
    public IEnumerable`1<string> After { get; }
    public abstract virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
    public abstract virtual Type get_ResourceType();
    public abstract virtual string get_Name();
    public abstract virtual IEnumerable`1<string> get_Before();
    public abstract virtual IEnumerable`1<string> get_After();
}
public interface NuGet.Protocol.Core.Types.IPackageSearchMetadata {
    public string Authors { get; }
    public IEnumerable`1<PackageDependencyGroup> DependencySets { get; }
    public string Description { get; }
    public Nullable`1<long> DownloadCount { get; }
    public Uri IconUrl { get; }
    public PackageIdentity Identity { get; }
    public Uri LicenseUrl { get; }
    public Uri ProjectUrl { get; }
    public Uri ReadmeUrl { get; }
    public Uri ReportAbuseUrl { get; }
    public Uri PackageDetailsUrl { get; }
    public Nullable`1<DateTimeOffset> Published { get; }
    public IReadOnlyList`1<string> OwnersList { get; }
    public string Owners { get; }
    public bool RequireLicenseAcceptance { get; }
    public string Summary { get; }
    public string Tags { get; }
    public string Title { get; }
    public bool IsListed { get; }
    public bool PrefixReserved { get; }
    public LicenseMetadata LicenseMetadata { get; }
    public IEnumerable`1<PackageVulnerabilityMetadata> Vulnerabilities { get; }
    public abstract virtual string get_Authors();
    public abstract virtual IEnumerable`1<PackageDependencyGroup> get_DependencySets();
    public abstract virtual string get_Description();
    public abstract virtual Nullable`1<long> get_DownloadCount();
    public abstract virtual Uri get_IconUrl();
    public abstract virtual PackageIdentity get_Identity();
    public abstract virtual Uri get_LicenseUrl();
    public abstract virtual Uri get_ProjectUrl();
    public abstract virtual Uri get_ReadmeUrl();
    public abstract virtual Uri get_ReportAbuseUrl();
    public abstract virtual Uri get_PackageDetailsUrl();
    public abstract virtual Nullable`1<DateTimeOffset> get_Published();
    public abstract virtual IReadOnlyList`1<string> get_OwnersList();
    public abstract virtual string get_Owners();
    public abstract virtual bool get_RequireLicenseAcceptance();
    public abstract virtual string get_Summary();
    public abstract virtual string get_Tags();
    public abstract virtual string get_Title();
    public abstract virtual bool get_IsListed();
    public abstract virtual bool get_PrefixReserved();
    public abstract virtual LicenseMetadata get_LicenseMetadata();
    public abstract virtual Task`1<PackageDeprecationMetadata> GetDeprecationMetadataAsync();
    public abstract virtual Task`1<IEnumerable`1<VersionInfo>> GetVersionsAsync();
    public abstract virtual IEnumerable`1<PackageVulnerabilityMetadata> get_Vulnerabilities();
}
public interface NuGet.Protocol.Core.Types.ISourceRepositoryProvider {
    public IPackageSourceProvider PackageSourceProvider { get; }
    public abstract virtual IEnumerable`1<SourceRepository> GetRepositories();
    public abstract virtual SourceRepository CreateRepository(PackageSource source);
    public abstract virtual SourceRepository CreateRepository(PackageSource source, FeedType type);
    public abstract virtual IPackageSourceProvider get_PackageSourceProvider();
}
public abstract class NuGet.Protocol.Core.Types.LegacyFeedCapabilityResource : object {
    public abstract virtual Task`1<bool> SupportsSearchAsync(ILogger log, CancellationToken token);
    public abstract virtual Task`1<bool> SupportsIsAbsoluteLatestVersionAsync(ILogger log, CancellationToken token);
}
public abstract class NuGet.Protocol.Core.Types.ListResource : object {
    public string Source { get; }
    public abstract virtual Task`1<IEnumerableAsync`1<IPackageSearchMetadata>> ListAsync(string searchTerm, bool prerelease, bool allVersions, bool includeDelisted, ILogger log, CancellationToken token);
    public abstract virtual string get_Source();
}
public abstract class NuGet.Protocol.Core.Types.MetadataResource : object {
    [AsyncStateMachineAttribute("NuGet.Protocol.Core.Types.MetadataResource/<GetVersions>d__0")]
public Task`1<IEnumerable`1<NuGetVersion>> GetVersions(string packageId, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
    public abstract virtual Task`1<IEnumerable`1<NuGetVersion>> GetVersions(string packageId, bool includePrerelease, bool includeUnlisted, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.Core.Types.MetadataResource/<Exists>d__2")]
public Task`1<bool> Exists(PackageIdentity identity, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
    public abstract virtual Task`1<bool> Exists(PackageIdentity identity, bool includeUnlisted, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.Core.Types.MetadataResource/<Exists>d__4")]
public Task`1<bool> Exists(string packageId, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
    public abstract virtual Task`1<bool> Exists(string packageId, bool includePrerelease, bool includeUnlisted, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
    public abstract virtual Task`1<IEnumerable`1<KeyValuePair`2<string, NuGetVersion>>> GetLatestVersions(IEnumerable`1<string> packageIds, bool includePrerelease, bool includeUnlisted, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.Core.Types.MetadataResource/<GetLatestVersion>d__7")]
public Task`1<NuGetVersion> GetLatestVersion(string packageId, bool includePrerelease, bool includeUnlisted, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
}
public abstract class NuGet.Protocol.Core.Types.NuGetProtocolException : Exception {
    public NuGetProtocolException(string message);
    public NuGetProtocolException(string message, Exception innerException);
    protected NuGetProtocolException(SerializationInfo info, StreamingContext context);
}
public class NuGet.Protocol.Core.Types.NuGetResourceProviderPositions : object {
    public static string First;
    public static string Last;
}
public static class NuGet.Protocol.Core.Types.NuGetTestMode : object {
    private static string _testModeEnvironmentVariableName;
    public static string NuGetTestClientName;
    [CompilerGeneratedAttribute]
private static bool <Enabled>k__BackingField;
    public static bool Enabled { get; private set; }
    private static NuGetTestMode();
    [CompilerGeneratedAttribute]
public static bool get_Enabled();
    [CompilerGeneratedAttribute]
private static void set_Enabled(bool value);
    private static bool FromEnvironmentVariable();
    public static T InvokeTestFunctionAgainstTestMode(Func`1<T> function, bool testModeEnabled);
}
public class NuGet.Protocol.Core.Types.NullSourceCacheContext : SourceCacheContext {
    private static SourceCacheContext _instance;
    public static SourceCacheContext Instance { get; }
    public string GeneratedTempFolder { get; }
    public static SourceCacheContext get_Instance();
    public virtual string get_GeneratedTempFolder();
    public virtual SourceCacheContext WithRefreshCacheTrue();
    public virtual SourceCacheContext Clone();
}
public class NuGet.Protocol.Core.Types.OfflineFeedAddContext : object {
    [CompilerGeneratedAttribute]
private string <PackagePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private ILogger <Logger>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ThrowIfSourcePackageIsInvalid>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ThrowIfPackageExistsAndInvalid>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ThrowIfPackageExists>k__BackingField;
    [CompilerGeneratedAttribute]
private PackageExtractionContext <ExtractionContext>k__BackingField;
    public string PackagePath { get; }
    public string Source { get; }
    public ILogger Logger { get; }
    public bool ThrowIfSourcePackageIsInvalid { get; }
    public bool ThrowIfPackageExistsAndInvalid { get; }
    public bool ThrowIfPackageExists { get; }
    public PackageExtractionContext ExtractionContext { get; }
    public OfflineFeedAddContext(string packagePath, string source, ILogger logger, bool throwIfSourcePackageIsInvalid, bool throwIfPackageExistsAndInvalid, bool throwIfPackageExists, PackageExtractionContext extractionContext);
    [CompilerGeneratedAttribute]
public string get_PackagePath();
    [CompilerGeneratedAttribute]
public string get_Source();
    [CompilerGeneratedAttribute]
public ILogger get_Logger();
    [CompilerGeneratedAttribute]
public bool get_ThrowIfSourcePackageIsInvalid();
    [CompilerGeneratedAttribute]
public bool get_ThrowIfPackageExistsAndInvalid();
    [CompilerGeneratedAttribute]
public bool get_ThrowIfPackageExists();
    [CompilerGeneratedAttribute]
public PackageExtractionContext get_ExtractionContext();
}
public static class NuGet.Protocol.Core.Types.OfflineFeedUtility : object {
    public static bool PackageExists(PackageIdentity packageIdentity, string offlineFeed, Boolean& isValidPackage);
    public static string GetPackageDirectory(PackageIdentity packageIdentity, string offlineFeed);
    public static void ThrowIfInvalid(string path);
    public static void ThrowIfInvalidOrNotFound(string path, bool isDirectory, string resourceString);
    [AsyncStateMachineAttribute("NuGet.Protocol.Core.Types.OfflineFeedUtility/<AddPackageToSource>d__4")]
public static Task AddPackageToSource(OfflineFeedAddContext offlineFeedAddContext, CancellationToken token);
    private static string GetHash(string nupkgFilePath);
}
public class NuGet.Protocol.Core.Types.PackageDownloadContext : object {
    [CompilerGeneratedAttribute]
private SourceCacheContext <SourceCacheContext>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DirectDownload>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DirectDownloadDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <ParentId>k__BackingField;
    [CompilerGeneratedAttribute]
private ClientPolicyContext <ClientPolicyContext>k__BackingField;
    [CompilerGeneratedAttribute]
private PackageSourceMapping <PackageSourceMapping>k__BackingField;
    public SourceCacheContext SourceCacheContext { get; }
    public bool DirectDownload { get; }
    public string DirectDownloadDirectory { get; }
    public Guid ParentId { get; public set; }
    public ClientPolicyContext ClientPolicyContext { get; public set; }
    public PackageSourceMapping PackageSourceMapping { get; }
    public PackageDownloadContext(SourceCacheContext sourceCacheContext);
    public PackageDownloadContext(SourceCacheContext sourceCacheContext, string directDownloadDirectory, bool directDownload);
    public PackageDownloadContext(SourceCacheContext sourceCacheContext, string directDownloadDirectory, bool directDownload, PackageSourceMapping packageSourceMappingConfiguration);
    [CompilerGeneratedAttribute]
public SourceCacheContext get_SourceCacheContext();
    [CompilerGeneratedAttribute]
public bool get_DirectDownload();
    [CompilerGeneratedAttribute]
public string get_DirectDownloadDirectory();
    [CompilerGeneratedAttribute]
public Guid get_ParentId();
    [CompilerGeneratedAttribute]
public void set_ParentId(Guid value);
    [CompilerGeneratedAttribute]
public ClientPolicyContext get_ClientPolicyContext();
    [CompilerGeneratedAttribute]
public void set_ClientPolicyContext(ClientPolicyContext value);
    [CompilerGeneratedAttribute]
public PackageSourceMapping get_PackageSourceMapping();
}
public abstract class NuGet.Protocol.Core.Types.PackageMetadataResource : object {
    public abstract virtual Task`1<IEnumerable`1<IPackageSearchMetadata>> GetMetadataAsync(string packageId, bool includePrerelease, bool includeUnlisted, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
    public abstract virtual Task`1<IPackageSearchMetadata> GetMetadataAsync(PackageIdentity package, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
}
public class NuGet.Protocol.Core.Types.PackageProgressEventArgs : EventArgs {
    private PackageIdentity _identity;
    private PackageSource _source;
    private double _complete;
    public PackageIdentity PackageIdentity { get; }
    public PackageSource PackageSource { get; }
    public double Complete { get; }
    public bool IsComplete { get; }
    public bool HasPackageSource { get; }
    public PackageProgressEventArgs(PackageIdentity identity, PackageSource source, double complete);
    public PackageIdentity get_PackageIdentity();
    public PackageSource get_PackageSource();
    public double get_Complete();
    public bool get_IsComplete();
    public bool get_HasPackageSource();
}
public class NuGet.Protocol.Core.Types.PackageSearchMetadataBuilder : object {
    private IPackageSearchMetadata _metadata;
    private AsyncLazy`1<IEnumerable`1<VersionInfo>> _lazyVersionsFactory;
    private AsyncLazy`1<PackageDeprecationMetadata> _lazyDeprecationFactory;
    private PackageSearchMetadataBuilder(IPackageSearchMetadata metadata);
    public PackageSearchMetadataBuilder WithVersions(AsyncLazy`1<IEnumerable`1<VersionInfo>> lazyVersionsFactory);
    public PackageSearchMetadataBuilder WithDeprecation(AsyncLazy`1<PackageDeprecationMetadata> lazyDeprecationFactory);
    public IPackageSearchMetadata Build();
    public static PackageSearchMetadataBuilder FromMetadata(IPackageSearchMetadata metadata);
    public static PackageSearchMetadataBuilder FromIdentity(PackageIdentity identity);
}
[ExtensionAttribute]
public static class NuGet.Protocol.Core.Types.PackageSearchMetadataExtensions : object {
    [ExtensionAttribute]
public static IPackageSearchMetadata WithVersions(IPackageSearchMetadata metadata, IEnumerable`1<VersionInfo> versions);
    [ExtensionAttribute]
public static IPackageSearchMetadata WithVersions(IPackageSearchMetadata metadata, Func`1<Task`1<IEnumerable`1<VersionInfo>>> asyncValueFactory);
    [ExtensionAttribute]
public static IPackageSearchMetadata WithVersions(IPackageSearchMetadata metadata, Func`1<IEnumerable`1<VersionInfo>> valueFactory);
}
public abstract class NuGet.Protocol.Core.Types.PackageSearchResource : object {
    public abstract virtual Task`1<IEnumerable`1<IPackageSearchMetadata>> SearchAsync(string searchTerm, SearchFilter filters, int skip, int take, ILogger log, CancellationToken cancellationToken);
}
public class NuGet.Protocol.Core.Types.PackageUpdateResource : object {
    private static string ServiceEndpoint;
    private static string ApiKeyHeader;
    private static string InvalidApiKey;
    private static string TempApiKeyServiceEndpoint;
    private HttpSource _httpSource;
    private string _source;
    private bool _disableBuffering;
    [CompilerGeneratedAttribute]
private ISettings <Settings>k__BackingField;
    public ISettings Settings { get; public set; }
    public Uri SourceUri { get; }
    public PackageUpdateResource(string source, HttpSource httpSource);
    [CompilerGeneratedAttribute]
public ISettings get_Settings();
    [CompilerGeneratedAttribute]
public void set_Settings(ISettings value);
    public Uri get_SourceUri();
    [AsyncStateMachineAttribute("NuGet.Protocol.Core.Types.PackageUpdateResource/<Push>d__14")]
public Task Push(IList`1<string> packagePaths, string symbolSource, int timeoutInSecond, bool disableBuffering, Func`2<string, string> getApiKey, Func`2<string, string> getSymbolApiKey, bool noServiceEndpoint, bool skipDuplicate, SymbolPackageUpdateResourceV3 symbolPackageUpdateResource, ILogger log);
    [AsyncStateMachineAttribute("NuGet.Protocol.Core.Types.PackageUpdateResource/<Push>d__15")]
public Task Push(IList`1<string> packagePaths, string symbolSource, int timeoutInSecond, bool disableBuffering, Func`2<string, string> getApiKey, Func`2<string, string> getSymbolApiKey, bool noServiceEndpoint, bool skipDuplicate, SymbolPackageUpdateResourceV3 symbolPackageUpdateResource, bool allowInsecureConnections, ILogger log);
    [ObsoleteAttribute("Use Push method which takes multiple package paths.")]
public Task Push(string packagePath, string symbolSource, int timeoutInSecond, bool disableBuffering, Func`2<string, string> getApiKey, Func`2<string, string> getSymbolApiKey, bool noServiceEndpoint, bool skipDuplicate, SymbolPackageUpdateResourceV3 symbolPackageUpdateResource, ILogger log);
    [AsyncStateMachineAttribute("NuGet.Protocol.Core.Types.PackageUpdateResource/<Push>d__17")]
[ObsoleteAttribute("Consolidating to one PackageUpdateResource.Push method which has all parameters defined.")]
public Task Push(string packagePath, string symbolSource, int timeoutInSecond, bool disableBuffering, Func`2<string, string> getApiKey, Func`2<string, string> getSymbolApiKey, bool noServiceEndpoint, ILogger log);
    [AsyncStateMachineAttribute("NuGet.Protocol.Core.Types.PackageUpdateResource/<Delete>d__18")]
public Task Delete(string packageId, string packageVersion, Func`2<string, string> getApiKey, Func`2<string, bool> confirm, bool noServiceEndpoint, ILogger log);
    [AsyncStateMachineAttribute("NuGet.Protocol.Core.Types.PackageUpdateResource/<Delete>d__19")]
public Task Delete(string packageId, string packageVersion, Func`2<string, string> getApiKey, Func`2<string, bool> confirm, bool noServiceEndpoint, bool allowInsecureConnections, ILogger log);
    [AsyncStateMachineAttribute("NuGet.Protocol.Core.Types.PackageUpdateResource/<PushSymbolsPath>d__20")]
private Task PushSymbolsPath(string packagePath, string symbolSource, string apiKey, bool noServiceEndpoint, bool skipDuplicate, SymbolPackageUpdateResourceV3 symbolPackageUpdateResource, bool allowInsecureConnections, TimeSpan requestTimeout, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.Core.Types.PackageUpdateResource/<PushPackagePath>d__21")]
private Task PushPackagePath(string packagePath, string source, string symbolSource, string apiKey, Func`2<string, string> getSymbolApiKey, bool noServiceEndpoint, bool skipDuplicate, SymbolPackageUpdateResourceV3 symbolPackageUpdateResource, bool allowInsecureConnections, TimeSpan requestTimeout, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.Core.Types.PackageUpdateResource/<PushPackageCore>d__22")]
private Task`1<bool> PushPackageCore(string source, string apiKey, string packageToPush, bool noServiceEndpoint, bool skipDuplicate, TimeSpan requestTimeout, bool warnForHttpSources, bool allowInsecureConnections, ILogger log, CancellationToken token);
    private static string GetSourceDisplayName(string source);
    private bool IsFileSource();
    private static string GetSymbolsPath(string packagePath, bool isSnupkg);
    [AsyncStateMachineAttribute("NuGet.Protocol.Core.Types.PackageUpdateResource/<PushPackageToServer>d__26")]
private Task`1<bool> PushPackageToServer(string source, string apiKey, string pathToPackage, bool noServiceEndpoint, bool skipDuplicate, TimeSpan requestTimeout, bool warnForHttpSources, bool allowInsecureConnections, ILogger logger, CancellationToken token);
    private static Nullable`1<HttpStatusCode> EnsureSuccessStatusCode(HttpResponseMessage response, Nullable`1<HttpStatusCode> codeNotToThrow, ILogger logger);
    private static bool DetectAndLogSkippedErrorOccurrence(Nullable`1<HttpStatusCode> skippedErrorStatusCode, string source, string packageIdentity, string reasonMessage, ILogger logger);
    private static void AdvertiseAvailableOptionToIgnore(HttpStatusCode errorCodeThatOccurred, ILogger logger);
    private Nullable`1<HttpStatusCode> ConvertSkipDuplicateParamToHttpStatusCode(bool skipDuplicate);
    private HttpRequestMessage CreateRequest(Uri serviceEndpointUrl, string pathToPackage, string apiKey, ILogger log);
    [AsyncStateMachineAttribute("NuGet.Protocol.Core.Types.PackageUpdateResource/<PushPackageToFileSystem>d__32")]
private Task PushPackageToFileSystem(Uri sourceUri, string pathToPackage, bool skipDuplicate, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.Core.Types.PackageUpdateResource/<DeletePackage>d__33")]
private Task DeletePackage(string source, string apiKey, string packageId, string packageVersion, bool noServiceEndpoint, bool allowInsecureConnections, ILogger logger, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.Core.Types.PackageUpdateResource/<DeletePackageFromServer>d__34")]
private Task DeletePackageFromServer(string source, string apiKey, string packageId, string packageVersion, bool noServiceEndpoint, ILogger logger, CancellationToken token);
    private void DeletePackageFromFileSystem(string source, string packageId, string packageVersion);
    private void ForceDeleteFile(string fullPath);
    public static void ForceDeleteDirectory(string path);
    private Uri GetServiceEndpointUrl(string source, string path, bool noServiceEndpoint);
    private static Uri EnsureTrailingSlash(string value);
    private bool IsV2LocalRepository(string root);
    [AsyncStateMachineAttribute("NuGet.Protocol.Core.Types.PackageUpdateResource/<GetSecureApiKey>d__41")]
private Task`1<string> GetSecureApiKey(PackageIdentity packageIdentity, string apiKey, bool noServiceEndpoint, TimeSpan requestTimeout, ILogger logger, CancellationToken token);
    private bool IsSourceNuGetSymbolServer(string source);
}
public class NuGet.Protocol.Core.Types.PluginFindPackageByIdResource : FindPackageByIdResource {
    private ConcurrentDictionary`2<string, AsyncLazy`1<SortedDictionary`2<NuGetVersion, PackageInfo>>> _packageInfoCache;
    private PackageSource _packageSource;
    private IPlugin _plugin;
    private IPluginMulticlientUtilities _utilities;
    private static string ResourceTypeName;
    private static string ThisTypeName;
    public PluginFindPackageByIdResource(IPlugin plugin, IPluginMulticlientUtilities utilities, PackageSource packageSource);
    public virtual Task`1<bool> CopyNupkgToStreamAsync(string id, NuGetVersion version, Stream destination, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    public virtual Task`1<IPackageDownloader> GetPackageDownloaderAsync(PackageIdentity packageIdentity, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.Core.Types.PluginFindPackageByIdResource/<GetAllVersionsAsync>d__9")]
public virtual Task`1<IEnumerable`1<NuGetVersion>> GetAllVersionsAsync(string id, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.Core.Types.PluginFindPackageByIdResource/<GetDependencyInfoAsync>d__10")]
public virtual Task`1<FindPackageByIdDependencyInfo> GetDependencyInfoAsync(string id, NuGetVersion version, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.Core.Types.PluginFindPackageByIdResource/<DoesPackageExistAsync>d__11")]
public virtual Task`1<bool> DoesPackageExistAsync(string id, NuGetVersion version, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.Core.Types.PluginFindPackageByIdResource/<EnsurePackagesAsync>d__12")]
private Task`1<SortedDictionary`2<NuGetVersion, PackageInfo>> EnsurePackagesAsync(string id, SourceCacheContext cacheContext, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.Core.Types.PluginFindPackageByIdResource/<FindPackagesByIdAsync>d__13")]
private Task`1<SortedDictionary`2<NuGetVersion, PackageInfo>> FindPackagesByIdAsync(string id, CancellationToken cancellationToken);
    private SortedDictionary`2<NuGetVersion, PackageInfo> ParsePackageVersions(IEnumerable`1<string> versions, string id, string baseUri);
    private PackageInfo CreatePackageInfo(string baseUri, string id, string version);
    private void AddOrUpdateLogger(IPlugin plugin, ILogger logger);
    [AsyncStateMachineAttribute("NuGet.Protocol.Core.Types.PluginFindPackageByIdResource/<SetLogLevelAsync>d__17")]
private Task SetLogLevelAsync(ILogger logger, CancellationToken cancellationToken);
}
public class NuGet.Protocol.Core.Types.PluginResource : object {
    private static string _basicAuthenticationType;
    private ICredentialService _credentialService;
    private PackageSource _packageSource;
    private IReadOnlyList`1<PluginCreationResult> _pluginCreationResults;
    public PluginResource(IEnumerable`1<PluginCreationResult> pluginCreationResults, PackageSource packageSource, ICredentialService credentialService);
    [AsyncStateMachineAttribute("NuGet.Protocol.Core.Types.PluginResource/<GetPluginAsync>d__5")]
public Task`1<GetPluginResult> GetPluginAsync(OperationClaim requiredClaim, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.Core.Types.PluginResource/<SetPackageSourceCredentialsAsync>d__6")]
private Task SetPackageSourceCredentialsAsync(IPlugin plugin, CancellationToken cancellationToken);
    private SetCredentialsRequest CreateRequest();
    private bool TryGetCachedCredentials(Uri uri, bool isProxy, ICredentials& credentials);
}
public class NuGet.Protocol.Core.Types.PluginResourceProvider : ResourceProvider {
    private IPluginManager _pluginManager;
    public PluginResourceProvider(IPluginManager pluginManager);
    [AsyncStateMachineAttribute("NuGet.Protocol.Core.Types.PluginResourceProvider/<TryCreate>d__3")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken cancellationToken);
}
internal class NuGet.Protocol.Core.Types.ProviderComparer : object {
    [CompilerGeneratedAttribute]
private static ProviderComparer <Instance>k__BackingField;
    public static ProviderComparer Instance { get; }
    private static ProviderComparer();
    [CompilerGeneratedAttribute]
public static ProviderComparer get_Instance();
    public sealed virtual int Compare(INuGetResourceProvider providerA, INuGetResourceProvider providerB);
}
public class NuGet.Protocol.Core.Types.RemoteSourceDependencyInfo : object {
    [CompilerGeneratedAttribute]
private PackageIdentity <Identity>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Listed>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<PackageDependencyGroup> <DependencyGroups>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContentUri>k__BackingField;
    public PackageIdentity Identity { get; }
    public bool Listed { get; }
    public IEnumerable`1<PackageDependencyGroup> DependencyGroups { get; }
    public string ContentUri { get; public set; }
    public RemoteSourceDependencyInfo(PackageIdentity identity, bool listed, IEnumerable`1<PackageDependencyGroup> dependencyGroups, string contentUri);
    [CompilerGeneratedAttribute]
public PackageIdentity get_Identity();
    [CompilerGeneratedAttribute]
public bool get_Listed();
    [CompilerGeneratedAttribute]
public IEnumerable`1<PackageDependencyGroup> get_DependencyGroups();
    [CompilerGeneratedAttribute]
public string get_ContentUri();
    [CompilerGeneratedAttribute]
public void set_ContentUri(string value);
    public sealed virtual bool Equals(RemoteSourceDependencyInfo other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public static class NuGet.Protocol.Core.Types.Repository : object {
    private static ProviderFactory _providerFactory;
    [CompilerGeneratedAttribute]
private static RepositoryFactory <Factory>k__BackingField;
    public static RepositoryFactory Factory { get; }
    public static ProviderFactory Provider { get; public set; }
    private static Repository();
    [CompilerGeneratedAttribute]
public static RepositoryFactory get_Factory();
    public static ProviderFactory get_Provider();
    public static void set_Provider(ProviderFactory value);
    [ObsoleteAttribute("https://github.com/NuGet/Home/issues/8479")]
public static ISourceRepositoryProvider CreateProvider(IEnumerable`1<INuGetResourceProvider> resourceProviders);
    [ObsoleteAttribute("https://github.com/NuGet/Home/issues/8479")]
public static ISourceRepositoryProvider CreateProvider(IEnumerable`1<INuGetResourceProvider> resourceProviders, string rootPath);
    public static SourceRepository CreateSource(IEnumerable`1<Lazy`1<INuGetResourceProvider>> resourceProviders, string sourceUrl);
    public static SourceRepository CreateSource(IEnumerable`1<Lazy`1<INuGetResourceProvider>> resourceProviders, string sourceUrl, FeedType type);
    public static SourceRepository CreateSource(IEnumerable`1<Lazy`1<INuGetResourceProvider>> resourceProviders, PackageSource source);
    public static SourceRepository CreateSource(IEnumerable`1<Lazy`1<INuGetResourceProvider>> resourceProviders, PackageSource source, FeedType type);
    private static IEnumerable`1<Lazy`1<INuGetResourceProvider>> CreateLazy(IEnumerable`1<INuGetResourceProvider> providers);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class NuGet.Protocol.Core.Types.ResourceProvider : object {
    private Type _resourceType;
    private string _name;
    private IEnumerable`1<string> _after;
    private IEnumerable`1<string> _before;
    public IEnumerable`1<string> After { get; }
    public IEnumerable`1<string> Before { get; }
    public string Name { get; }
    public Type ResourceType { get; }
    public ResourceProvider(Type resourceType);
    public ResourceProvider(Type resourceType, string name);
    public ResourceProvider(Type resourceType, string name, string before);
    public ResourceProvider(Type resourceType, string name, IEnumerable`1<string> before, IEnumerable`1<string> after);
    public virtual IEnumerable`1<string> get_After();
    public virtual IEnumerable`1<string> get_Before();
    public virtual string get_Name();
    public virtual Type get_ResourceType();
    public abstract virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
    private static IEnumerable`1<string> ToArray(string s);
}
public class NuGet.Protocol.Core.Types.RetriableProtocolException : NuGetProtocolException {
    public RetriableProtocolException(string message);
    public RetriableProtocolException(string message, Exception innerException);
    protected RetriableProtocolException(SerializationInfo info, StreamingContext context);
}
public class NuGet.Protocol.Core.Types.SearchFilter : object {
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <SupportedFrameworks>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludePrerelease>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeDelisted>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <PackageTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<SearchFilterType> <Filter>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<SearchOrderBy> <OrderBy>k__BackingField;
    public IEnumerable`1<string> SupportedFrameworks { get; public set; }
    public bool IncludePrerelease { get; }
    public bool IncludeDelisted { get; public set; }
    public IEnumerable`1<string> PackageTypes { get; public set; }
    public Nullable`1<SearchFilterType> Filter { get; }
    public Nullable`1<SearchOrderBy> OrderBy { get; public set; }
    public SearchFilter(bool includePrerelease);
    public SearchFilter(bool includePrerelease, Nullable`1<SearchFilterType> filter);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_SupportedFrameworks();
    [CompilerGeneratedAttribute]
public void set_SupportedFrameworks(IEnumerable`1<string> value);
    [CompilerGeneratedAttribute]
public bool get_IncludePrerelease();
    [CompilerGeneratedAttribute]
public bool get_IncludeDelisted();
    [CompilerGeneratedAttribute]
public void set_IncludeDelisted(bool value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_PackageTypes();
    [CompilerGeneratedAttribute]
public void set_PackageTypes(IEnumerable`1<string> value);
    [CompilerGeneratedAttribute]
public Nullable`1<SearchFilterType> get_Filter();
    [CompilerGeneratedAttribute]
public Nullable`1<SearchOrderBy> get_OrderBy();
    [CompilerGeneratedAttribute]
public void set_OrderBy(Nullable`1<SearchOrderBy> value);
}
public enum NuGet.Protocol.Core.Types.SearchFilterType : Enum {
    public int value__;
    public static SearchFilterType IsLatestVersion;
    public static SearchFilterType IsAbsoluteLatestVersion;
}
public enum NuGet.Protocol.Core.Types.SearchOrderBy : Enum {
    public int value__;
    public static SearchOrderBy Id;
}
public class NuGet.Protocol.Core.Types.SourceCacheContext : object {
    private string _generatedTempFolder;
    private static TimeSpan DefaultMaxAge;
    [CompilerGeneratedAttribute]
private bool <NoCache>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DirectDownload>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <MaxAge>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RefreshMemoryCache>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <SessionId>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreFailedSources>k__BackingField;
    public bool NoCache { get; public set; }
    public bool DirectDownload { get; public set; }
    public Nullable`1<DateTimeOffset> MaxAge { get; public set; }
    public bool RefreshMemoryCache { get; public set; }
    public Guid SessionId { get; public set; }
    public TimeSpan MaxAgeTimeSpan { get; }
    public string GeneratedTempFolder { get; public set; }
    public bool IgnoreFailedSources { get; public set; }
    private static SourceCacheContext();
    [CompilerGeneratedAttribute]
public bool get_NoCache();
    [CompilerGeneratedAttribute]
public void set_NoCache(bool value);
    [CompilerGeneratedAttribute]
public bool get_DirectDownload();
    [CompilerGeneratedAttribute]
public void set_DirectDownload(bool value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_MaxAge();
    [CompilerGeneratedAttribute]
public void set_MaxAge(Nullable`1<DateTimeOffset> value);
    [CompilerGeneratedAttribute]
public bool get_RefreshMemoryCache();
    [CompilerGeneratedAttribute]
public void set_RefreshMemoryCache(bool value);
    [CompilerGeneratedAttribute]
public Guid get_SessionId();
    [CompilerGeneratedAttribute]
public void set_SessionId(Guid value);
    public TimeSpan get_MaxAgeTimeSpan();
    private TimeSpan GetCacheTime(Nullable`1<DateTimeOffset> maxAge, TimeSpan defaultTime);
    public virtual string get_GeneratedTempFolder();
    public virtual void set_GeneratedTempFolder(string value);
    [CompilerGeneratedAttribute]
public bool get_IgnoreFailedSources();
    [CompilerGeneratedAttribute]
public void set_IgnoreFailedSources(bool value);
    public virtual SourceCacheContext Clone();
    public virtual SourceCacheContext WithRefreshCacheTrue();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
public class NuGet.Protocol.Core.Types.SourcePackageDependencyInfo : PackageDependencyInfo {
    [CompilerGeneratedAttribute]
private bool <Listed>k__BackingField;
    [CompilerGeneratedAttribute]
private SourceRepository <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <DownloadUri>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PackageHash>k__BackingField;
    public bool Listed { get; }
    public SourceRepository Source { get; }
    public Uri DownloadUri { get; }
    public string PackageHash { get; }
    public SourcePackageDependencyInfo(string id, NuGetVersion version, IEnumerable`1<PackageDependency> dependencies, bool listed, SourceRepository source);
    public SourcePackageDependencyInfo(string id, NuGetVersion version, IEnumerable`1<PackageDependency> dependencies, bool listed, SourceRepository source, Uri downloadUri, string packageHash);
    public SourcePackageDependencyInfo(PackageIdentity identity, IEnumerable`1<PackageDependency> dependencies, bool listed, SourceRepository source, Uri downloadUri, string packageHash);
    [CompilerGeneratedAttribute]
public bool get_Listed();
    [CompilerGeneratedAttribute]
public SourceRepository get_Source();
    [CompilerGeneratedAttribute]
public Uri get_DownloadUri();
    [CompilerGeneratedAttribute]
public string get_PackageHash();
}
public class NuGet.Protocol.Core.Types.SourceRepository : object {
    private Dictionary`2<Type, INuGetResourceProvider[]> _providerCache;
    private PackageSource _source;
    [CompilerGeneratedAttribute]
private FeedType <FeedTypeOverride>k__BackingField;
    public FeedType FeedTypeOverride { get; }
    public PackageSource PackageSource { get; }
    public SourceRepository(PackageSource source, IEnumerable`1<INuGetResourceProvider> providers);
    public SourceRepository(PackageSource source, IEnumerable`1<Lazy`1<INuGetResourceProvider>> providers);
    public SourceRepository(PackageSource source, IEnumerable`1<Lazy`1<INuGetResourceProvider>> providers, FeedType feedTypeOverride);
    [CompilerGeneratedAttribute]
public FeedType get_FeedTypeOverride();
    public virtual string ToString();
    public virtual PackageSource get_PackageSource();
    [AsyncStateMachineAttribute("NuGet.Protocol.Core.Types.SourceRepository/<GetFeedType>d__12")]
public virtual Task`1<FeedType> GetFeedType(CancellationToken token);
    public virtual T GetResource();
    public virtual T GetResource(CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.Core.Types.SourceRepository/<GetResourceAsync>d__15`1")]
public virtual Task`1<T> GetResourceAsync();
    [AsyncStateMachineAttribute("NuGet.Protocol.Core.Types.SourceRepository/<GetResourceAsync>d__16`1")]
public virtual Task`1<T> GetResourceAsync(CancellationToken token);
    private static Dictionary`2<Type, INuGetResourceProvider[]> Init(IEnumerable`1<Lazy`1<INuGetResourceProvider>> providers);
    private static INuGetResourceProvider[] Sort(IEnumerable`1<Lazy`1<INuGetResourceProvider>> group);
    private static FeedType GetFeedType(PackageSource source);
}
public class NuGet.Protocol.Core.Types.SourceRepositoryProvider : object {
    private IPackageSourceProvider _packageSourceProvider;
    private IEnumerable`1<Lazy`1<INuGetResourceProvider>> _resourceProviders;
    private List`1<SourceRepository> _repositories;
    public IPackageSourceProvider PackageSourceProvider { get; }
    [ObsoleteAttribute("https://github.com/NuGet/Home/issues/8479")]
public SourceRepositoryProvider(ISettings settings, IEnumerable`1<Lazy`1<INuGetResourceProvider>> resourceProviders);
    public SourceRepositoryProvider(IPackageSourceProvider packageSourceProvider, IEnumerable`1<Lazy`1<INuGetResourceProvider>> resourceProviders);
    public sealed virtual IEnumerable`1<SourceRepository> GetRepositories();
    public sealed virtual SourceRepository CreateRepository(PackageSource source);
    public sealed virtual SourceRepository CreateRepository(PackageSource source, FeedType type);
    public sealed virtual IPackageSourceProvider get_PackageSourceProvider();
    private void Init();
    [CompilerGeneratedAttribute]
private void <.ctor>b__4_0(object sender, EventArgs e);
}
public class NuGet.Protocol.Core.Types.SymbolPackageUpdateResourceV3 : object {
    private HttpSource _httpSource;
    private string _source;
    public Uri SourceUri { get; }
    public SymbolPackageUpdateResourceV3(string source, HttpSource httpSource);
    public Uri get_SourceUri();
}
public static class NuGet.Protocol.Core.Types.UserAgent : object {
    [CompilerGeneratedAttribute]
private static string <UserAgentString>k__BackingField;
    public static string UserAgentString { get; private set; }
    private static UserAgent();
    public static void SetUserAgentString(UserAgentStringBuilder builder);
    [CompilerGeneratedAttribute]
public static string get_UserAgentString();
    [CompilerGeneratedAttribute]
private static void set_UserAgentString(string value);
    public static void SetUserAgent(HttpClient client);
}
public class NuGet.Protocol.Core.Types.UserAgentStringBuilder : object {
    public static string DefaultNuGetClientName;
    private static string UserAgentWithOSDescriptionAndVisualStudioSKUTemplate;
    private static string UserAgentWithOSDescriptionTemplate;
    private static string UserAgentTemplate;
    private string _clientName;
    private string _vsInfo;
    private string _osInfo;
    [CompilerGeneratedAttribute]
private string <NuGetClientVersion>k__BackingField;
    public string NuGetClientVersion { get; }
    public UserAgentStringBuilder(string clientName);
    private static UserAgentStringBuilder();
    [CompilerGeneratedAttribute]
public string get_NuGetClientVersion();
    [ObsoleteAttribute("This value is now ignored")]
public UserAgentStringBuilder WithOSDescription(string osInfo);
    public UserAgentStringBuilder WithVisualStudioSKU(string vsInfo);
    public string Build();
    internal static string GetOS();
}
public class NuGet.Protocol.Core.Types.VersionInfo : object {
    [CompilerGeneratedAttribute]
private NuGetVersion <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <DownloadCount>k__BackingField;
    [CompilerGeneratedAttribute]
private IPackageSearchMetadata <PackageSearchMetadata>k__BackingField;
    public NuGetVersion Version { get; private set; }
    public Nullable`1<long> DownloadCount { get; private set; }
    public IPackageSearchMetadata PackageSearchMetadata { get; public set; }
    public VersionInfo(NuGetVersion version);
    public VersionInfo(NuGetVersion version, string downloadCount);
    public VersionInfo(NuGetVersion version, Nullable`1<long> downloadCount);
    [CompilerGeneratedAttribute]
public NuGetVersion get_Version();
    [CompilerGeneratedAttribute]
private void set_Version(NuGetVersion value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_DownloadCount();
    [CompilerGeneratedAttribute]
private void set_DownloadCount(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public IPackageSearchMetadata get_PackageSearchMetadata();
    [CompilerGeneratedAttribute]
public void set_PackageSearchMetadata(IPackageSearchMetadata value);
}
internal class NuGet.Protocol.DedicatedAsynchronousProcessingThread : object {
    private Task _processingThread;
    private bool _isDisposed;
    private bool _isClosed;
    private TimeSpan _pollingDelay;
    private ConcurrentQueue`1<Func`1<Task>> _taskQueue;
    public DedicatedAsynchronousProcessingThread(TimeSpan pollingDelay);
    internal void Start();
    internal void Enqueue(Func`1<Task> task);
    [AsyncStateMachineAttribute("NuGet.Protocol.DedicatedAsynchronousProcessingThread/<ProcessAsync>d__8")]
private Task ProcessAsync();
    public sealed virtual void Dispose();
    private void ThrowIfAlreadyStarted();
    private void ThrowIfNotAlreadyStarted();
    private void ThrowIfDisposed();
}
internal class NuGet.Protocol.DependencyInfo : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private VersionRange <Range>k__BackingField;
    [CompilerGeneratedAttribute]
private RegistrationInfo <RegistrationInfo>k__BackingField;
    public string Id { get; public set; }
    public VersionRange Range { get; public set; }
    public RegistrationInfo RegistrationInfo { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
    [CompilerGeneratedAttribute]
public VersionRange get_Range();
    [CompilerGeneratedAttribute]
public void set_Range(VersionRange value);
    [CompilerGeneratedAttribute]
public RegistrationInfo get_RegistrationInfo();
    [CompilerGeneratedAttribute]
public void set_RegistrationInfo(RegistrationInfo value);
    public virtual string ToString();
}
public class NuGet.Protocol.DependencyInfoResourceV2Feed : DependencyInfoResource {
    private V2FeedParser _feedParser;
    private FrameworkReducer _frameworkReducer;
    private SourceRepository _source;
    public DependencyInfoResourceV2Feed(V2FeedParser feedParser, SourceRepository source);
    [AsyncStateMachineAttribute("NuGet.Protocol.DependencyInfoResourceV2Feed/<ResolvePackage>d__4")]
public virtual Task`1<SourcePackageDependencyInfo> ResolvePackage(PackageIdentity package, NuGetFramework projectFramework, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.DependencyInfoResourceV2Feed/<ResolvePackages>d__5")]
public virtual Task`1<IEnumerable`1<SourcePackageDependencyInfo>> ResolvePackages(string packageId, NuGetFramework projectFramework, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
    private SourcePackageDependencyInfo CreateDependencyInfo(V2FeedPackageInfo packageVersion, NuGetFramework projectFramework);
}
public class NuGet.Protocol.DependencyInfoResourceV2FeedProvider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.DependencyInfoResourceV2FeedProvider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
public class NuGet.Protocol.DependencyInfoResourceV3 : DependencyInfoResource {
    private HttpSource _client;
    private RegistrationResourceV3 _regResource;
    private SourceRepository _source;
    public DependencyInfoResourceV3(HttpSource client, RegistrationResourceV3 regResource, SourceRepository source);
    [AsyncStateMachineAttribute("NuGet.Protocol.DependencyInfoResourceV3/<ResolvePackage>d__4")]
public virtual Task`1<SourcePackageDependencyInfo> ResolvePackage(PackageIdentity package, NuGetFramework projectFramework, SourceCacheContext cacheContext, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.DependencyInfoResourceV3/<ResolvePackages>d__5")]
public virtual Task`1<IEnumerable`1<SourcePackageDependencyInfo>> ResolvePackages(string packageId, NuGetFramework projectFramework, SourceCacheContext cacheContext, ILogger log, CancellationToken token);
    public virtual Task`1<IEnumerable`1<RemoteSourceDependencyInfo>> ResolvePackages(string packageId, SourceCacheContext cacheContext, ILogger log, CancellationToken token);
    [IteratorStateMachineAttribute("NuGet.Protocol.DependencyInfoResourceV3/<GetPackagesFromRegistration>d__7")]
private IEnumerable`1<SourcePackageDependencyInfo> GetPackagesFromRegistration(RegistrationInfo registration, CancellationToken token);
}
public class NuGet.Protocol.DependencyInfoResourceV3Provider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.DependencyInfoResourceV3Provider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
public class NuGet.Protocol.DownloadResourcePlugin : DownloadResource {
    private IPlugin _plugin;
    private PackageSource _packageSource;
    private IPluginMulticlientUtilities _utilities;
    public DownloadResourcePlugin(IPlugin plugin, IPluginMulticlientUtilities utilities, PackageSource packageSource);
    [AsyncStateMachineAttribute("NuGet.Protocol.DownloadResourcePlugin/<GetDownloadResourceResultAsync>d__4")]
public virtual Task`1<DownloadResourceResult> GetDownloadResourceResultAsync(PackageIdentity identity, PackageDownloadContext downloadContext, string globalPackagesFolder, ILogger logger, CancellationToken cancellationToken);
    private void AddOrUpdateLogger(IPlugin plugin, ILogger logger);
    [AsyncStateMachineAttribute("NuGet.Protocol.DownloadResourcePlugin/<SetLogLevelAsync>d__6")]
private Task SetLogLevelAsync(ILogger logger, CancellationToken cancellationToken);
}
public class NuGet.Protocol.DownloadResourcePluginProvider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.DownloadResourcePluginProvider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken cancellationToken);
    private static void AddOrUpdateGetCredentialsRequestHandler(IPlugin plugin, SourceRepository source, HttpHandlerResource httpHandlerResource);
    private static void AddOrUpdateGetServiceIndexRequestHandler(IPlugin plugin, SourceRepository source);
}
public class NuGet.Protocol.DownloadResourceV2Feed : DownloadResource {
    private V2FeedParser _feedParser;
    private string _source;
    [ObsoleteAttribute("Use constructor with source parameter")]
public DownloadResourceV2Feed(V2FeedParser feedParser);
    public DownloadResourceV2Feed(V2FeedParser feedParser, string source);
    [AsyncStateMachineAttribute("NuGet.Protocol.DownloadResourceV2Feed/<GetDownloadResourceResultAsync>d__4")]
public virtual Task`1<DownloadResourceResult> GetDownloadResourceResultAsync(PackageIdentity identity, PackageDownloadContext downloadContext, string globalPackagesFolder, ILogger logger, CancellationToken token);
}
public class NuGet.Protocol.DownloadResourceV2FeedProvider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.DownloadResourceV2FeedProvider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
public class NuGet.Protocol.DownloadResourceV3 : DownloadResource {
    private string _source;
    private RegistrationResourceV3 _regResource;
    private HttpSource _client;
    private string _packageBaseAddressUrl;
    [ObsoleteAttribute("Use constructor with source parameter")]
public DownloadResourceV3(HttpSource client, RegistrationResourceV3 regResource);
    public DownloadResourceV3(string source, HttpSource client, RegistrationResourceV3 regResource);
    [ObsoleteAttribute("Use constructor with source parameter")]
public DownloadResourceV3(HttpSource client, string packageBaseAddress);
    public DownloadResourceV3(string source, HttpSource client, string packageBaseAddress);
    private DownloadResourceV3(HttpSource client);
    [AsyncStateMachineAttribute("NuGet.Protocol.DownloadResourceV3/<GetDownloadUrl>d__9")]
private Task`1<Uri> GetDownloadUrl(PackageIdentity identity, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.DownloadResourceV3/<GetDownloadResourceResultAsync>d__10")]
public virtual Task`1<DownloadResourceResult> GetDownloadResourceResultAsync(PackageIdentity identity, PackageDownloadContext downloadContext, string globalPackagesFolder, ILogger logger, CancellationToken token);
}
public class NuGet.Protocol.DownloadResourceV3Provider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.DownloadResourceV3Provider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
public class NuGet.Protocol.DownloadTimeoutStream : Stream {
    private string _downloadName;
    private Stream _networkStream;
    private TimeSpan _timeout;
    [CompilerGeneratedAttribute]
private bool <CanRead>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanSeek>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanWrite>k__BackingField;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public DownloadTimeoutStream(string downloadName, Stream networkStream, TimeSpan timeout);
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual int EndRead(IAsyncResult asyncResult);
    [AsyncStateMachineAttribute("NuGet.Protocol.DownloadTimeoutStream/<ReadAsync>d__8")]
public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    protected virtual void Dispose(bool disposing);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    [CompilerGeneratedAttribute]
public virtual bool get_CanRead();
    [CompilerGeneratedAttribute]
public virtual bool get_CanSeek();
    [CompilerGeneratedAttribute]
public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
}
public class NuGet.Protocol.DownloadTimeoutStreamContent : StreamContent {
    public DownloadTimeoutStreamContent(string downloadName, Stream networkStream, TimeSpan timeout);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NuGet.Protocol.EnhancedHttpRetryHelper : object {
    public static int DefaultDelayMilliseconds;
    public static bool DefaultEnabled;
    public static int DefaultRetryCount;
    public static bool DefaultRetry429;
    public static bool DefaultObserveRetryAfter;
    public static string DelayInMillisecondsEnvironmentVariableName;
    public static string IsEnabledEnvironmentVariableName;
    public static string RetryCountEnvironmentVariableName;
    public static string Retry429EnvironmentVariableName;
    public static string ObserveRetryAfterEnvironmentVariableName;
    public static string MaximumRetryAfterDurationEnvironmentVariableName;
    private IEnvironmentVariableReader _environmentVariableReader;
    private Lazy`1<bool> _isEnabled;
    private Lazy`1<int> _retryCount;
    private Lazy`1<int> _delayInMilliseconds;
    private Lazy`1<bool> _retry429;
    private Lazy`1<bool> _observeRetryAfter;
    private Lazy`1<TimeSpan> _maxRetyAfterDelay;
    internal bool IsEnabled { get; }
    internal int RetryCount { get; }
    internal int DelayInMilliseconds { get; }
    internal bool Retry429 { get; }
    internal bool ObserveRetryAfter { get; }
    internal TimeSpan MaxRetryAfterDelay { get; }
    public EnhancedHttpRetryHelper(IEnvironmentVariableReader environmentVariableReader);
    internal bool get_IsEnabled();
    internal int get_RetryCount();
    internal int get_DelayInMilliseconds();
    internal bool get_Retry429();
    internal bool get_ObserveRetryAfter();
    internal TimeSpan get_MaxRetryAfterDelay();
    private static bool GetBoolFromEnvironmentVariable(string variableName, bool defaultValue, IEnvironmentVariableReader environmentVariableReader);
    private static int GetIntFromEnvironmentVariable(string variableName, int defaultValue, IEnvironmentVariableReader environmentVariableReader);
    [CompilerGeneratedAttribute]
private bool <.ctor>b__18_0();
    [CompilerGeneratedAttribute]
private int <.ctor>b__18_1();
    [CompilerGeneratedAttribute]
private int <.ctor>b__18_2();
    [CompilerGeneratedAttribute]
private bool <.ctor>b__18_3();
    [CompilerGeneratedAttribute]
private bool <.ctor>b__18_4();
    [CompilerGeneratedAttribute]
private TimeSpan <.ctor>b__18_5();
}
public class NuGet.Protocol.Events.ProtocolDiagnosticHttpEvent : ProtocolDiagnosticHttpEventBase {
    [CompilerGeneratedAttribute]
private DateTime <Timestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <EventDuration>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Bytes>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsSuccess>k__BackingField;
    public DateTime Timestamp { get; }
    public TimeSpan EventDuration { get; }
    public long Bytes { get; }
    public bool IsSuccess { get; }
    internal ProtocolDiagnosticHttpEvent(DateTime timestamp, string source, Uri url, Nullable`1<TimeSpan> headerDuration, TimeSpan eventDuration, long bytes, Nullable`1<int> httpStatusCode, bool isSuccess, bool isRetry, bool isCancelled, bool isLastAttempt);
    internal ProtocolDiagnosticHttpEvent(DateTime timestamp, TimeSpan eventDuration, long bytes, bool isSuccess, ProtocolDiagnosticHttpEventBase eventBase);
    [CompilerGeneratedAttribute]
public DateTime get_Timestamp();
    [CompilerGeneratedAttribute]
public TimeSpan get_EventDuration();
    [CompilerGeneratedAttribute]
public long get_Bytes();
    [CompilerGeneratedAttribute]
public bool get_IsSuccess();
}
public abstract class NuGet.Protocol.Events.ProtocolDiagnosticHttpEventBase : object {
    [CompilerGeneratedAttribute]
private string <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <Url>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <HeaderDuration>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <HttpStatusCode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRetry>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsCancelled>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsLastAttempt>k__BackingField;
    public string Source { get; }
    public Uri Url { get; }
    public Nullable`1<TimeSpan> HeaderDuration { get; }
    public Nullable`1<int> HttpStatusCode { get; }
    public bool IsRetry { get; }
    public bool IsCancelled { get; }
    public bool IsLastAttempt { get; }
    protected ProtocolDiagnosticHttpEventBase(ProtocolDiagnosticHttpEventBase other);
    protected ProtocolDiagnosticHttpEventBase(string source, Uri url, Nullable`1<TimeSpan> headerDuration, Nullable`1<int> httpStatusCode, bool isRetry, bool isCancelled, bool isLastAttempt);
    [CompilerGeneratedAttribute]
public string get_Source();
    [CompilerGeneratedAttribute]
public Uri get_Url();
    [CompilerGeneratedAttribute]
public Nullable`1<TimeSpan> get_HeaderDuration();
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_HttpStatusCode();
    [CompilerGeneratedAttribute]
public bool get_IsRetry();
    [CompilerGeneratedAttribute]
public bool get_IsCancelled();
    [CompilerGeneratedAttribute]
public bool get_IsLastAttempt();
}
internal class NuGet.Protocol.Events.ProtocolDiagnosticInProgressHttpEvent : ProtocolDiagnosticHttpEventBase {
    internal ProtocolDiagnosticInProgressHttpEvent(string source, Uri url, Nullable`1<TimeSpan> headerDuration, Nullable`1<int> httpStatusCode, bool isRetry, bool isCancelled, bool isLastAttempt);
}
public class NuGet.Protocol.Events.ProtocolDiagnosticNupkgCopiedEvent : object {
    [CompilerGeneratedAttribute]
private string <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private long <FileSize>k__BackingField;
    public string Source { get; }
    public long FileSize { get; }
    public ProtocolDiagnosticNupkgCopiedEvent(string source, long fileSize);
    [CompilerGeneratedAttribute]
public string get_Source();
    [CompilerGeneratedAttribute]
public long get_FileSize();
}
public class NuGet.Protocol.Events.ProtocolDiagnosticResourceEvent : object {
    [CompilerGeneratedAttribute]
private string <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ResourceType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Method>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <Duration>k__BackingField;
    public string Source { get; }
    public string ResourceType { get; }
    public string Type { get; }
    public string Method { get; }
    public TimeSpan Duration { get; }
    public ProtocolDiagnosticResourceEvent(string source, string resourceType, string type, string method, TimeSpan duration);
    [CompilerGeneratedAttribute]
public string get_Source();
    [CompilerGeneratedAttribute]
public string get_ResourceType();
    [CompilerGeneratedAttribute]
public string get_Type();
    [CompilerGeneratedAttribute]
public string get_Method();
    [CompilerGeneratedAttribute]
public TimeSpan get_Duration();
}
public static class NuGet.Protocol.Events.ProtocolDiagnostics : object {
    [CompilerGeneratedAttribute]
private static ProtocolDiagnosticHttpEventHandler HttpEvent;
    [CompilerGeneratedAttribute]
private static ProtocolDiagnosticResourceEventHandler ResourceEvent;
    [CompilerGeneratedAttribute]
private static ProtocolDiagnosticsNupkgCopiedEventHandler NupkgCopiedEvent;
    [CompilerGeneratedAttribute]
public static void add_HttpEvent(ProtocolDiagnosticHttpEventHandler value);
    [CompilerGeneratedAttribute]
public static void remove_HttpEvent(ProtocolDiagnosticHttpEventHandler value);
    [CompilerGeneratedAttribute]
public static void add_ResourceEvent(ProtocolDiagnosticResourceEventHandler value);
    [CompilerGeneratedAttribute]
public static void remove_ResourceEvent(ProtocolDiagnosticResourceEventHandler value);
    [CompilerGeneratedAttribute]
public static void add_NupkgCopiedEvent(ProtocolDiagnosticsNupkgCopiedEventHandler value);
    [CompilerGeneratedAttribute]
public static void remove_NupkgCopiedEvent(ProtocolDiagnosticsNupkgCopiedEventHandler value);
    internal static void RaiseEvent(ProtocolDiagnosticHttpEvent pdEvent);
    internal static void RaiseEvent(ProtocolDiagnosticResourceEvent pdrEvent);
    internal static void RaiseEvent(ProtocolDiagnosticNupkgCopiedEvent ncEvent);
}
internal class NuGet.Protocol.Events.ProtocolDiagnosticsStream : Stream {
    private Stream _baseStream;
    private ProtocolDiagnosticInProgressHttpEvent _inProgressEvent;
    private Stopwatch _stopwatch;
    private long _bytes;
    private Action`1<ProtocolDiagnosticHttpEvent> _diagnosticEvent;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    internal ProtocolDiagnosticsStream(Stream baseStream, ProtocolDiagnosticInProgressHttpEvent inProgressEvent, Stopwatch stopwatch, Action`1<ProtocolDiagnosticHttpEvent> diagnosticEvent);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    [AsyncStateMachineAttribute("NuGet.Protocol.Events.ProtocolDiagnosticsStream/<ReadAsync>d__19")]
public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    protected virtual void Dispose(bool disposing);
    private void RaiseDiagnosticEvent(bool isSuccess);
}
[ExtensionAttribute]
internal static class NuGet.Protocol.Extensions.VersionRangeExtensions : object {
    [ExtensionAttribute]
public static bool DoesRangeSatisfy(VersionRange dependencyRange, NuGetVersion catalogItemLower, NuGetVersion catalogItemUpper);
}
[ExtensionAttribute]
public static class NuGet.Protocol.FactoryExtensionsV3 : object {
    public static Func`1<IEnumerable`1<Lazy`1<INuGetResourceProvider>>> V3ProvidersCreator;
    private static FactoryExtensionsV3();
    [ExtensionAttribute]
public static SourceRepository GetCoreV3(RepositoryFactory factory, string source, FeedType type);
    [ExtensionAttribute]
public static SourceRepository GetCoreV3(RepositoryFactory factory, string source);
    [ExtensionAttribute]
public static SourceRepository GetCoreV3(RepositoryFactory factory, PackageSource source);
    [ExtensionAttribute]
public static SourceRepository GetCoreV2(RepositoryFactory factory, PackageSource source);
    [ExtensionAttribute]
public static IEnumerable`1<Lazy`1<INuGetResourceProvider>> GetCoreV3Default(ProviderFactory factory);
    [ExtensionAttribute]
public static IEnumerable`1<Lazy`1<INuGetResourceProvider>> GetCoreV3(ProviderFactory factory);
}
public enum NuGet.Protocol.FeedType : Enum {
    public int value__;
    public static FeedType Undefined;
    public static FeedType HttpV2;
    public static FeedType HttpV3;
    public static FeedType FileSystemV2;
    public static FeedType FileSystemV3;
    public static FeedType FileSystemUnzipped;
    public static FeedType FileSystemPackagesConfig;
    public static FeedType FileSystemUnknown;
}
public class NuGet.Protocol.FeedTypePackageSource : PackageSource {
    [CompilerGeneratedAttribute]
private FeedType <FeedType>k__BackingField;
    public FeedType FeedType { get; }
    public FeedTypePackageSource(string source, FeedType feedType);
    [CompilerGeneratedAttribute]
public FeedType get_FeedType();
}
public class NuGet.Protocol.FeedTypeResource : object {
    [CompilerGeneratedAttribute]
private FeedType <FeedType>k__BackingField;
    public FeedType FeedType { get; }
    public FeedTypeResource(FeedType feedType);
    [CompilerGeneratedAttribute]
public FeedType get_FeedType();
}
public class NuGet.Protocol.FeedTypeResourceProvider : ResourceProvider {
    private ConcurrentDictionary`2<PackageSource, FeedTypeResource> _feedTypeCache;
    private object _accessLock;
    public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
public static class NuGet.Protocol.FeedTypeUtility : object {
    public static FeedType GetFeedType(PackageSource packageSource);
}
public abstract class NuGet.Protocol.FindLocalPackagesResource : object {
    [CompilerGeneratedAttribute]
private string <Root>k__BackingField;
    public string Root { get; protected set; }
    [CompilerGeneratedAttribute]
public string get_Root();
    [CompilerGeneratedAttribute]
protected void set_Root(string value);
    public virtual bool Exists(PackageIdentity identity, ILogger logger, CancellationToken token);
    public virtual bool Exists(string packageId, ILogger logger, CancellationToken token);
    public abstract virtual LocalPackageInfo GetPackage(Uri path, ILogger logger, CancellationToken token);
    public abstract virtual LocalPackageInfo GetPackage(PackageIdentity identity, ILogger logger, CancellationToken token);
    public abstract virtual IEnumerable`1<LocalPackageInfo> FindPackagesById(string id, ILogger logger, CancellationToken token);
    public abstract virtual IEnumerable`1<LocalPackageInfo> GetPackages(ILogger logger, CancellationToken token);
}
public class NuGet.Protocol.FindLocalPackagesResourcePackagesConfig : FindLocalPackagesResource {
    public FindLocalPackagesResourcePackagesConfig(string root);
    public virtual IEnumerable`1<LocalPackageInfo> FindPackagesById(string id, ILogger logger, CancellationToken token);
    public virtual LocalPackageInfo GetPackage(Uri path, ILogger logger, CancellationToken token);
    public virtual LocalPackageInfo GetPackage(PackageIdentity identity, ILogger logger, CancellationToken token);
    public virtual IEnumerable`1<LocalPackageInfo> GetPackages(ILogger logger, CancellationToken token);
}
public class NuGet.Protocol.FindLocalPackagesResourcePackagesConfigProvider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.FindLocalPackagesResourcePackagesConfigProvider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
public class NuGet.Protocol.FindLocalPackagesResourceUnzipped : FindLocalPackagesResource {
    private Lazy`1<IReadOnlyList`1<LocalPackageInfo>> _packages;
    private Lazy`1<Dictionary`2<PackageIdentity, LocalPackageInfo>> _index;
    private Lazy`1<Dictionary`2<Uri, LocalPackageInfo>> _pathIndex;
    public FindLocalPackagesResourceUnzipped(string root);
    public virtual IEnumerable`1<LocalPackageInfo> FindPackagesById(string id, ILogger logger, CancellationToken token);
    public virtual LocalPackageInfo GetPackage(Uri path, ILogger logger, CancellationToken token);
    public virtual LocalPackageInfo GetPackage(PackageIdentity identity, ILogger logger, CancellationToken token);
    public virtual IEnumerable`1<LocalPackageInfo> GetPackages(ILogger logger, CancellationToken token);
    public virtual bool Exists(PackageIdentity identity, ILogger logger, CancellationToken token);
    private static Dictionary`2<PackageIdentity, LocalPackageInfo> GetIndex(Lazy`1<IReadOnlyList`1<LocalPackageInfo>> packages);
    private static Dictionary`2<Uri, LocalPackageInfo> GetPathIndex(Lazy`1<IReadOnlyList`1<LocalPackageInfo>> packages);
    private static IReadOnlyList`1<LocalPackageInfo> GetPackagesCore(string root);
    private static PackageReaderBase GetPackage(DirectoryInfo root, string name);
    private static NuspecReader GetNuspec(DirectoryInfo root, string name);
}
public class NuGet.Protocol.FindLocalPackagesResourceUnzippedProvider : ResourceProvider {
    private ConcurrentDictionary`2<PackageSource, FindLocalPackagesResourceUnzipped> _cache;
    [AsyncStateMachineAttribute("NuGet.Protocol.FindLocalPackagesResourceUnzippedProvider/<TryCreate>d__2")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
public class NuGet.Protocol.FindLocalPackagesResourceV2 : FindLocalPackagesResource {
    public FindLocalPackagesResourceV2(string root);
    public virtual IEnumerable`1<LocalPackageInfo> FindPackagesById(string id, ILogger logger, CancellationToken token);
    public virtual LocalPackageInfo GetPackage(Uri path, ILogger logger, CancellationToken token);
    public virtual LocalPackageInfo GetPackage(PackageIdentity identity, ILogger logger, CancellationToken token);
    public virtual IEnumerable`1<LocalPackageInfo> GetPackages(ILogger logger, CancellationToken token);
}
public class NuGet.Protocol.FindLocalPackagesResourceV2Provider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.FindLocalPackagesResourceV2Provider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
public class NuGet.Protocol.FindLocalPackagesResourceV3 : FindLocalPackagesResource {
    public FindLocalPackagesResourceV3(string root);
    public virtual IEnumerable`1<LocalPackageInfo> FindPackagesById(string id, ILogger logger, CancellationToken token);
    public virtual LocalPackageInfo GetPackage(Uri path, ILogger logger, CancellationToken token);
    public virtual LocalPackageInfo GetPackage(PackageIdentity identity, ILogger logger, CancellationToken token);
    public virtual IEnumerable`1<LocalPackageInfo> GetPackages(ILogger logger, CancellationToken token);
}
public class NuGet.Protocol.FindLocalPackagesResourceV3Provider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.FindLocalPackagesResourceV3Provider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
public class NuGet.Protocol.FindPackagesByIdNupkgDownloader : object {
    private TaskResultCache`2<string, CacheEntry> _cacheEntries;
    private object _nuspecReadersLock;
    private ConcurrentDictionary`2<string, NuspecReader> _nuspecReaders;
    private HttpSource _httpSource;
    private EnhancedHttpRetryHelper _enhancedHttpRetryHelper;
    public FindPackagesByIdNupkgDownloader(HttpSource httpSource);
    internal FindPackagesByIdNupkgDownloader(HttpSource httpSource, IEnvironmentVariableReader environmentVariableReader);
    [AsyncStateMachineAttribute("NuGet.Protocol.FindPackagesByIdNupkgDownloader/<GetNuspecReaderFromNupkgAsync>d__7")]
public Task`1<NuspecReader> GetNuspecReaderFromNupkgAsync(PackageIdentity identity, string url, SourceCacheContext cacheContext, ILogger logger, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.FindPackagesByIdNupkgDownloader/<CopyNupkgToStreamAsync>d__8")]
public Task`1<bool> CopyNupkgToStreamAsync(PackageIdentity identity, string url, Stream destination, SourceCacheContext cacheContext, ILogger logger, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.FindPackagesByIdNupkgDownloader/<ProcessNupkgStreamAsync>d__9")]
private Task`1<bool> ProcessNupkgStreamAsync(PackageIdentity identity, string url, Func`2<Stream, Task> processStreamAsync, SourceCacheContext cacheContext, ILogger logger, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.FindPackagesByIdNupkgDownloader/<ProcessStreamAndGetCacheEntryAsync>d__10")]
private Task`1<CacheEntry> ProcessStreamAndGetCacheEntryAsync(PackageIdentity identity, string url, Func`2<Stream, Task> processStreamAsync, SourceCacheContext cacheContext, ILogger logger, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.FindPackagesByIdNupkgDownloader/<ProcessHttpSourceResultAsync>d__11`1")]
private Task`1<T> ProcessHttpSourceResultAsync(PackageIdentity identity, string url, Func`2<HttpSourceResult, Task`1<T>> processAsync, SourceCacheContext cacheContext, ILogger logger, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.FindPackagesByIdNupkgDownloader/<ProcessCacheEntryAsync>d__12")]
private Task`1<bool> ProcessCacheEntryAsync(CacheEntry cacheEntry, Func`2<Stream, Task> processStreamAsync, CancellationToken token);
}
public class NuGet.Protocol.FingerprintsConverter : JsonConverter {
    public bool CanWrite { get; }
    public virtual bool CanConvert(Type objectType);
    public virtual bool get_CanWrite();
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
}
public static class NuGet.Protocol.GetDownloadResultUtility : object {
    private static int BufferSize;
    private static string DirectDownloadExtension;
    private static string DirectDownloadPattern;
    [AsyncStateMachineAttribute("NuGet.Protocol.GetDownloadResultUtility/<GetDownloadResultAsync>d__3")]
public static Task`1<DownloadResourceResult> GetDownloadResultAsync(HttpSource client, PackageIdentity identity, Uri uri, PackageDownloadContext downloadContext, string globalPackagesFolder, ILogger logger, CancellationToken token);
    public static void CleanUpDirectDownloads(PackageDownloadContext downloadContext);
    [AsyncStateMachineAttribute("NuGet.Protocol.GetDownloadResultUtility/<DirectDownloadAsync>d__5")]
private static Task`1<DownloadResourceResult> DirectDownloadAsync(string source, PackageIdentity packageIdentity, Stream packageStream, PackageDownloadContext downloadContext, CancellationToken token);
}
public static class NuGet.Protocol.GlobalPackagesFolderUtility : object {
    private static int BufferSize;
    public static DownloadResourceResult GetPackage(PackageIdentity packageIdentity, string globalPackagesFolder);
    private static DownloadResourceResult CreateDownloadResourceResult(string nupkgPath, string installPath);
    [AsyncStateMachineAttribute("NuGet.Protocol.GlobalPackagesFolderUtility/<AddPackageAsync>d__3")]
public static Task`1<DownloadResourceResult> AddPackageAsync(string source, PackageIdentity packageIdentity, Stream packageStream, string globalPackagesFolder, Guid parentId, ClientPolicyContext clientPolicyContext, ILogger logger, CancellationToken token);
}
public class NuGet.Protocol.HttpCacheResult : object {
    [CompilerGeneratedAttribute]
private TimeSpan <MaxAge>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NewFile>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CacheFile>k__BackingField;
    [CompilerGeneratedAttribute]
private Stream <Stream>k__BackingField;
    public TimeSpan MaxAge { get; }
    public string NewFile { get; }
    public string CacheFile { get; }
    public Stream Stream { get; public set; }
    public HttpCacheResult(TimeSpan maxAge, string newFile, string cacheFule);
    [CompilerGeneratedAttribute]
public TimeSpan get_MaxAge();
    [CompilerGeneratedAttribute]
public string get_NewFile();
    [CompilerGeneratedAttribute]
public string get_CacheFile();
    [CompilerGeneratedAttribute]
public Stream get_Stream();
    [CompilerGeneratedAttribute]
public void set_Stream(Stream value);
}
public static class NuGet.Protocol.HttpCacheUtility : object {
    private static int BufferSize;
    public static HttpCacheResult InitializeHttpCacheResult(string httpCacheDirectory, Uri sourceUri, string cacheKey, HttpSourceCacheContext context);
    [AsyncStateMachineAttribute("NuGet.Protocol.HttpCacheUtility/<CreateCacheFileAsync>d__2")]
public static Task CreateCacheFileAsync(HttpCacheResult result, HttpResponseMessage response, Action`1<Stream> ensureValidContents, CancellationToken cancellationToken);
}
public class NuGet.Protocol.HttpFileSystemBasedFindPackageByIdResource : FindPackageByIdResource {
    private static int DefaultMaxRetries;
    private int _maxRetries;
    private HttpSource _httpSource;
    private ConcurrentDictionary`2<string, AsyncLazy`1<SortedDictionary`2<NuGetVersion, PackageInfo>>> _packageInfoCache;
    private IReadOnlyList`1<Uri> _baseUris;
    private FindPackagesByIdNupkgDownloader _nupkgDownloader;
    private EnhancedHttpRetryHelper _enhancedHttpRetryHelper;
    private static string ResourceTypeName;
    private static string ThisTypeName;
    public HttpFileSystemBasedFindPackageByIdResource(IReadOnlyList`1<Uri> baseUris, HttpSource httpSource);
    internal HttpFileSystemBasedFindPackageByIdResource(IReadOnlyList`1<Uri> baseUris, HttpSource httpSource, IEnvironmentVariableReader environmentVariableReader);
    [AsyncStateMachineAttribute("NuGet.Protocol.HttpFileSystemBasedFindPackageByIdResource/<GetAllVersionsAsync>d__11")]
public virtual Task`1<IEnumerable`1<NuGetVersion>> GetAllVersionsAsync(string id, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.HttpFileSystemBasedFindPackageByIdResource/<GetDependencyInfoAsync>d__12")]
public virtual Task`1<FindPackageByIdDependencyInfo> GetDependencyInfoAsync(string id, NuGetVersion version, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.HttpFileSystemBasedFindPackageByIdResource/<CopyNupkgToStreamAsync>d__13")]
public virtual Task`1<bool> CopyNupkgToStreamAsync(string id, NuGetVersion version, Stream destination, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.HttpFileSystemBasedFindPackageByIdResource/<GetPackageDownloaderAsync>d__14")]
public virtual Task`1<IPackageDownloader> GetPackageDownloaderAsync(PackageIdentity packageIdentity, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.HttpFileSystemBasedFindPackageByIdResource/<DoesPackageExistAsync>d__15")]
public virtual Task`1<bool> DoesPackageExistAsync(string id, NuGetVersion version, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.HttpFileSystemBasedFindPackageByIdResource/<EnsurePackagesAsync>d__16")]
private Task`1<SortedDictionary`2<NuGetVersion, PackageInfo>> EnsurePackagesAsync(string id, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.HttpFileSystemBasedFindPackageByIdResource/<FindPackagesByIdAsync>d__17")]
private Task`1<SortedDictionary`2<NuGetVersion, PackageInfo>> FindPackagesByIdAsync(string id, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.HttpFileSystemBasedFindPackageByIdResource/<ConsumeFlatContainerIndexAsync>d__18")]
private Task`1<SortedDictionary`2<NuGetVersion, PackageInfo>> ConsumeFlatContainerIndexAsync(Stream stream, string id, string baseUri, CancellationToken token);
    private PackageInfo BuildModel(string baseUri, string id, string version);
}
public class NuGet.Protocol.HttpFileSystemBasedFindPackageByIdResourceProvider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.HttpFileSystemBasedFindPackageByIdResourceProvider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository sourceRepository, CancellationToken token);
}
public class NuGet.Protocol.HttpHandlerResourceV3 : HttpHandlerResource {
    private HttpClientHandler _clientHandler;
    private HttpMessageHandler _messageHandler;
    [CompilerGeneratedAttribute]
private static Lazy`1<ICredentialService> <CredentialService>k__BackingField;
    [CompilerGeneratedAttribute]
private static Action`2<Uri, ICredentials> <CredentialsSuccessfullyUsed>k__BackingField;
    public HttpClientHandler ClientHandler { get; }
    public HttpMessageHandler MessageHandler { get; }
    public static Lazy`1<ICredentialService> CredentialService { get; public set; }
    public static Action`2<Uri, ICredentials> CredentialsSuccessfullyUsed { get; public set; }
    public HttpHandlerResourceV3(HttpClientHandler clientHandler, HttpMessageHandler messageHandler);
    public virtual HttpClientHandler get_ClientHandler();
    public virtual HttpMessageHandler get_MessageHandler();
    [CompilerGeneratedAttribute]
public static Lazy`1<ICredentialService> get_CredentialService();
    [CompilerGeneratedAttribute]
public static void set_CredentialService(Lazy`1<ICredentialService> value);
    [CompilerGeneratedAttribute]
public static Action`2<Uri, ICredentials> get_CredentialsSuccessfullyUsed();
    [CompilerGeneratedAttribute]
public static void set_CredentialsSuccessfullyUsed(Action`2<Uri, ICredentials> value);
}
public class NuGet.Protocol.HttpHandlerResourceV3Provider : ResourceProvider {
    private IProxyCache _proxyCache;
    internal HttpHandlerResourceV3Provider(IProxyCache proxyCache);
    public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
    private HttpHandlerResourceV3 CreateResource(PackageSource packageSource);
}
public class NuGet.Protocol.HttpRequestMessageConfiguration : object {
    public static HttpRequestMessageConfiguration Default;
    [CompilerGeneratedAttribute]
private ILogger <Logger>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PromptOn403>k__BackingField;
    public ILogger Logger { get; }
    public bool PromptOn403 { get; }
    public HttpRequestMessageConfiguration(ILogger logger, bool promptOn403);
    private static HttpRequestMessageConfiguration();
    [CompilerGeneratedAttribute]
public ILogger get_Logger();
    [CompilerGeneratedAttribute]
public bool get_PromptOn403();
}
[ExtensionAttribute]
public static class NuGet.Protocol.HttpRequestMessageExtensions : object {
    private static string NuGetConfigurationKey;
    [ExtensionAttribute]
internal static HttpRequestMessage Clone(HttpRequestMessage request);
    [ExtensionAttribute]
public static HttpRequestMessageConfiguration GetOrCreateConfiguration(HttpRequestMessage request);
    [ExtensionAttribute]
public static void SetConfiguration(HttpRequestMessage request, HttpRequestMessageConfiguration configuration);
    [ExtensionAttribute]
private static T GetProperty(HttpRequestMessage request, string key);
}
public static class NuGet.Protocol.HttpRequestMessageFactory : object {
    public static HttpRequestMessage Create(HttpMethod method, string requestUri, ILogger log);
    public static HttpRequestMessage Create(HttpMethod method, Uri requestUri, ILogger log);
    public static HttpRequestMessage Create(HttpMethod method, string requestUri, HttpRequestMessageConfiguration configuration);
    public static HttpRequestMessage Create(HttpMethod method, Uri requestUri, HttpRequestMessageConfiguration configuration);
}
[ExtensionAttribute]
public static class NuGet.Protocol.HttpResponseMessageExtensions : object {
    [ExtensionAttribute]
public static void LogServerWarning(HttpResponseMessage response, ILogger log);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NuGet.Protocol.HttpRetryHandler : object {
    private EnhancedHttpRetryHelper _enhancedHttpRetryHelper;
    internal static string StopwatchPropertyName;
    internal HttpRetryHandler(IEnvironmentVariableReader environmentVariableReader);
    public sealed virtual Task`1<HttpResponseMessage> SendAsync(HttpRetryHandlerRequest request, ILogger log, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.HttpRetryHandler/<SendAsync>d__5")]
public sealed virtual Task`1<HttpResponseMessage> SendAsync(HttpRetryHandlerRequest request, string source, ILogger log, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
private static Nullable`1<TimeSpan> GetRetryAfter(RetryConditionHeaderValue retryAfter);
}
public class NuGet.Protocol.HttpRetryHandlerRequest : object {
    public static int DefaultMaxTries;
    public static TimeSpan DefaultDownloadTimeout;
    [CompilerGeneratedAttribute]
private HttpClient <HttpClient>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`1<HttpRequestMessage> <RequestFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private HttpCompletionOption <CompletionOption>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxTries>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <RequestTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <RetryDelay>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <DownloadTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<KeyValuePair`2<string, IEnumerable`1<string>>> <AddHeaders>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRetry>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsLastAttempt>k__BackingField;
    public HttpClient HttpClient { get; }
    public Func`1<HttpRequestMessage> RequestFactory { get; }
    public HttpCompletionOption CompletionOption { get; public set; }
    public int MaxTries { get; public set; }
    public TimeSpan RequestTimeout { get; public set; }
    public TimeSpan RetryDelay { get; public set; }
    public TimeSpan DownloadTimeout { get; public set; }
    public IList`1<KeyValuePair`2<string, IEnumerable`1<string>>> AddHeaders { get; public set; }
    public bool IsRetry { get; public set; }
    public bool IsLastAttempt { get; public set; }
    public HttpRetryHandlerRequest(HttpClient httpClient, Func`1<HttpRequestMessage> requestFactory);
    private static HttpRetryHandlerRequest();
    [CompilerGeneratedAttribute]
public HttpClient get_HttpClient();
    [CompilerGeneratedAttribute]
public Func`1<HttpRequestMessage> get_RequestFactory();
    [CompilerGeneratedAttribute]
public HttpCompletionOption get_CompletionOption();
    [CompilerGeneratedAttribute]
public void set_CompletionOption(HttpCompletionOption value);
    [CompilerGeneratedAttribute]
public int get_MaxTries();
    [CompilerGeneratedAttribute]
public void set_MaxTries(int value);
    [CompilerGeneratedAttribute]
public TimeSpan get_RequestTimeout();
    [CompilerGeneratedAttribute]
public void set_RequestTimeout(TimeSpan value);
    [CompilerGeneratedAttribute]
public TimeSpan get_RetryDelay();
    [CompilerGeneratedAttribute]
public void set_RetryDelay(TimeSpan value);
    [CompilerGeneratedAttribute]
public TimeSpan get_DownloadTimeout();
    [CompilerGeneratedAttribute]
public void set_DownloadTimeout(TimeSpan value);
    [CompilerGeneratedAttribute]
public IList`1<KeyValuePair`2<string, IEnumerable`1<string>>> get_AddHeaders();
    [CompilerGeneratedAttribute]
public void set_AddHeaders(IList`1<KeyValuePair`2<string, IEnumerable`1<string>>> value);
    [CompilerGeneratedAttribute]
public bool get_IsRetry();
    [CompilerGeneratedAttribute]
public void set_IsRetry(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsLastAttempt();
    [CompilerGeneratedAttribute]
public void set_IsLastAttempt(bool value);
}
public class NuGet.Protocol.HttpSource : object {
    private Func`1<Task`1<HttpHandlerResource>> _messageHandlerFactory;
    private Uri _sourceUri;
    private HttpClient _httpClient;
    private string _httpCacheDirectory;
    private PackageSource _packageSource;
    private IThrottle _throttle;
    private bool _disposed;
    private SemaphoreSlim _httpClientLock;
    [CompilerGeneratedAttribute]
private IHttpRetryHandler <RetryHandler>k__BackingField;
    public IHttpRetryHandler RetryHandler { get; public set; }
    public string PackageSource { get; }
    public string HttpCacheDirectory { get; public set; }
    public HttpSource(PackageSource packageSource, Func`1<Task`1<HttpHandlerResource>> messageHandlerFactory, IThrottle throttle);
    [CompilerGeneratedAttribute]
public IHttpRetryHandler get_RetryHandler();
    [CompilerGeneratedAttribute]
public void set_RetryHandler(IHttpRetryHandler value);
    public string get_PackageSource();
    [AsyncStateMachineAttribute("NuGet.Protocol.HttpSource/<GetAsync>d__15`1")]
public virtual Task`1<T> GetAsync(HttpSourceCachedRequest request, Func`2<HttpSourceResult, Task`1<T>> processAsync, ILogger log, CancellationToken token);
    public Task`1<T> ProcessStreamAsync(HttpSourceRequest request, Func`2<Stream, Task`1<T>> processAsync, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.HttpSource/<ProcessHttpStreamAsync>d__17`1")]
internal Task`1<T> ProcessHttpStreamAsync(HttpSourceRequest request, Func`2<HttpResponseMessage, Task`1<T>> processAsync, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.HttpSource/<ProcessStreamAsync>d__18`1")]
public Task`1<T> ProcessStreamAsync(HttpSourceRequest request, Func`2<Stream, Task`1<T>> processAsync, SourceCacheContext cacheContext, ILogger log, CancellationToken token);
    public Task`1<T> ProcessResponseAsync(HttpSourceRequest request, Func`2<HttpResponseMessage, Task`1<T>> processAsync, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.HttpSource/<ProcessResponseAsync>d__20`1")]
public Task`1<T> ProcessResponseAsync(HttpSourceRequest request, Func`2<HttpResponseMessage, Task`1<T>> processAsync, SourceCacheContext cacheContext, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.HttpSource/<GetJObjectAsync>d__21")]
public Task`1<JObject> GetJObjectAsync(HttpSourceRequest request, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.HttpSource/<GetThrottledResponse>d__22")]
private Task`1<ThrottledResponse> GetThrottledResponse(Func`1<HttpRequestMessage> requestFactory, TimeSpan requestTimeout, TimeSpan downloadTimeout, int maxTries, bool isRetry, bool isLastAttempt, Guid sessionId, ILogger log, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.HttpSource/<EnsureHttpClientAsync>d__23")]
private Task EnsureHttpClientAsync();
    [AsyncStateMachineAttribute("NuGet.Protocol.HttpSource/<CreateHttpClientAsync>d__24")]
private Task`1<HttpClient> CreateHttpClientAsync();
    public string get_HttpCacheDirectory();
    public void set_HttpCacheDirectory(string value);
    protected virtual Stream TryReadCacheFile(string uri, TimeSpan maxAge, string cacheFile);
    public static HttpSource Create(SourceRepository source);
    public static HttpSource Create(SourceRepository source, IThrottle throttle);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    [CompilerGeneratedAttribute]
private Task`1<ThrottledResponse> <ProcessResponseAsync>g__throttledResponseFactory|20_0(<>c__DisplayClass20_0`1& );
}
public class NuGet.Protocol.HttpSourceAuthenticationHandler : DelegatingHandler {
    public static int MaxAuthRetries;
    private static SemaphoreSlim _credentialPromptLock;
    private PackageSource _packageSource;
    private HttpClientHandler _clientHandler;
    private ICredentialService _credentialService;
    private SemaphoreSlim _httpClientLock;
    private Dictionary`2<string, AmbientAuthenticationState> _authStates;
    private HttpSourceCredentials _credentials;
    private bool _isDisposed;
    public HttpSourceAuthenticationHandler(PackageSource packageSource, HttpClientHandler clientHandler, ICredentialService credentialService);
    private static HttpSourceAuthenticationHandler();
    [AsyncStateMachineAttribute("NuGet.Protocol.HttpSourceAuthenticationHandler/<SendAsync>d__10")]
protected virtual Task`1<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.HttpSourceAuthenticationHandler/<AcquireCredentialsAsync>d__11")]
private Task`1<ICredentials> AcquireCredentialsAsync(HttpStatusCode statusCode, Guid credentialsVersion, ILogger log, bool areLastKnownGoodCredentialsTried, CancellationToken cancellationToken);
    private AmbientAuthenticationState GetAuthenticationState();
    [AsyncStateMachineAttribute("NuGet.Protocol.HttpSourceAuthenticationHandler/<PromptForCredentialsAsync>d__13")]
private Task`1<ICredentials> PromptForCredentialsAsync(CredentialRequestType type, string message, AmbientAuthenticationState authState, ILogger log, CancellationToken token);
    private void CredentialsSuccessfullyUsed(Uri uri, ICredentials credentials);
    protected virtual void Dispose(bool disposing);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<HttpResponseMessage> <>n__0(HttpRequestMessage request, CancellationToken cancellationToken);
}
public class NuGet.Protocol.HttpSourceCachedRequest : object {
    [CompilerGeneratedAttribute]
private string <Uri>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CacheKey>k__BackingField;
    [CompilerGeneratedAttribute]
private HttpSourceCacheContext <CacheContext>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<MediaTypeWithQualityHeaderValue> <AcceptHeaderValues>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreNotFounds>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxTries>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`1<Stream> <EnsureValidContents>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <RequestTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <DownloadTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRetry>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsLastAttempt>k__BackingField;
    public string Uri { get; }
    public string CacheKey { get; }
    public HttpSourceCacheContext CacheContext { get; }
    public IList`1<MediaTypeWithQualityHeaderValue> AcceptHeaderValues { get; }
    public bool IgnoreNotFounds { get; public set; }
    public int MaxTries { get; public set; }
    public Action`1<Stream> EnsureValidContents { get; public set; }
    public TimeSpan RequestTimeout { get; public set; }
    public TimeSpan DownloadTimeout { get; public set; }
    public bool IsRetry { get; public set; }
    public bool IsLastAttempt { get; public set; }
    public HttpSourceCachedRequest(string uri, string cacheKey, HttpSourceCacheContext cacheContext);
    [CompilerGeneratedAttribute]
public string get_Uri();
    [CompilerGeneratedAttribute]
public string get_CacheKey();
    [CompilerGeneratedAttribute]
public HttpSourceCacheContext get_CacheContext();
    [CompilerGeneratedAttribute]
public IList`1<MediaTypeWithQualityHeaderValue> get_AcceptHeaderValues();
    [CompilerGeneratedAttribute]
public bool get_IgnoreNotFounds();
    [CompilerGeneratedAttribute]
public void set_IgnoreNotFounds(bool value);
    [CompilerGeneratedAttribute]
public int get_MaxTries();
    [CompilerGeneratedAttribute]
public void set_MaxTries(int value);
    [CompilerGeneratedAttribute]
public Action`1<Stream> get_EnsureValidContents();
    [CompilerGeneratedAttribute]
public void set_EnsureValidContents(Action`1<Stream> value);
    [CompilerGeneratedAttribute]
public TimeSpan get_RequestTimeout();
    [CompilerGeneratedAttribute]
public void set_RequestTimeout(TimeSpan value);
    [CompilerGeneratedAttribute]
public TimeSpan get_DownloadTimeout();
    [CompilerGeneratedAttribute]
public void set_DownloadTimeout(TimeSpan value);
    [CompilerGeneratedAttribute]
public bool get_IsRetry();
    [CompilerGeneratedAttribute]
public void set_IsRetry(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsLastAttempt();
    [CompilerGeneratedAttribute]
public void set_IsLastAttempt(bool value);
}
public class NuGet.Protocol.HttpSourceCredentials : CredentialCache {
    private VersionedCredentials modreq(System.Runtime.CompilerServices.IsVolatile) _credentials;
    public ICredentials Credentials { get; public set; }
    public Guid Version { get; }
    public HttpSourceCredentials(ICredentials credentials);
    public ICredentials get_Credentials();
    public void set_Credentials(ICredentials value);
    public Guid get_Version();
    private sealed virtual override NetworkCredential System.Net.ICredentials.GetCredential(Uri uri, string authType);
}
public class NuGet.Protocol.HttpSourceRequest : object {
    public static TimeSpan DefaultRequestTimeout;
    [CompilerGeneratedAttribute]
private Func`1<HttpRequestMessage> <RequestFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreNotFounds>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <RequestTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxTries>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <DownloadTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRetry>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsLastAttempt>k__BackingField;
    public Func`1<HttpRequestMessage> RequestFactory { get; }
    public bool IgnoreNotFounds { get; public set; }
    public TimeSpan RequestTimeout { get; public set; }
    public int MaxTries { get; public set; }
    public TimeSpan DownloadTimeout { get; public set; }
    public bool IsRetry { get; public set; }
    public bool IsLastAttempt { get; public set; }
    public HttpSourceRequest(string uri, ILogger log);
    public HttpSourceRequest(Uri uri, ILogger log);
    public HttpSourceRequest(Func`1<HttpRequestMessage> requestFactory);
    private static HttpSourceRequest();
    [CompilerGeneratedAttribute]
public Func`1<HttpRequestMessage> get_RequestFactory();
    [CompilerGeneratedAttribute]
public bool get_IgnoreNotFounds();
    [CompilerGeneratedAttribute]
public void set_IgnoreNotFounds(bool value);
    [CompilerGeneratedAttribute]
public TimeSpan get_RequestTimeout();
    [CompilerGeneratedAttribute]
public void set_RequestTimeout(TimeSpan value);
    [CompilerGeneratedAttribute]
public int get_MaxTries();
    [CompilerGeneratedAttribute]
public void set_MaxTries(int value);
    [CompilerGeneratedAttribute]
public TimeSpan get_DownloadTimeout();
    [CompilerGeneratedAttribute]
public void set_DownloadTimeout(TimeSpan value);
    [CompilerGeneratedAttribute]
public bool get_IsRetry();
    [CompilerGeneratedAttribute]
public void set_IsRetry(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsLastAttempt();
    [CompilerGeneratedAttribute]
public void set_IsLastAttempt(bool value);
}
public class NuGet.Protocol.HttpSourceResource : object {
    [CompilerGeneratedAttribute]
private HttpSource <HttpSource>k__BackingField;
    public HttpSource HttpSource { get; }
    public HttpSourceResource(HttpSource httpSource);
    [CompilerGeneratedAttribute]
public HttpSource get_HttpSource();
}
public class NuGet.Protocol.HttpSourceResourceProvider : ResourceProvider {
    private static int DefaultMaxHttpRequestsPerSource;
    private ConcurrentDictionary`2<PackageSource, HttpSourceResource> _cache;
    [CompilerGeneratedAttribute]
private static IThrottle <Throttle>k__BackingField;
    public static IThrottle Throttle { get; public set; }
    [CompilerGeneratedAttribute]
public static IThrottle get_Throttle();
    [CompilerGeneratedAttribute]
public static void set_Throttle(IThrottle value);
    public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
public class NuGet.Protocol.HttpSourceResult : object {
    private bool _disposed;
    [CompilerGeneratedAttribute]
private Stream <Stream>k__BackingField;
    [CompilerGeneratedAttribute]
private HttpSourceResultStatus <Status>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CacheFile>k__BackingField;
    public Stream Stream { get; private set; }
    public HttpSourceResultStatus Status { get; }
    public string CacheFile { get; }
    public HttpSourceResult(HttpSourceResultStatus status);
    public HttpSourceResult(HttpSourceResultStatus status, string cacheFileName, Stream stream);
    [CompilerGeneratedAttribute]
public Stream get_Stream();
    [CompilerGeneratedAttribute]
private void set_Stream(Stream value);
    [CompilerGeneratedAttribute]
public HttpSourceResultStatus get_Status();
    [CompilerGeneratedAttribute]
public string get_CacheFile();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
public enum NuGet.Protocol.HttpSourceResultStatus : Enum {
    public int value__;
    public static HttpSourceResultStatus NotFound;
    public static HttpSourceResultStatus NoContent;
    public static HttpSourceResultStatus OpenedFromDisk;
    public static HttpSourceResultStatus OpenedFromNetwork;
}
public static class NuGet.Protocol.HttpStreamValidation : object {
    public static void ValidateJObject(string uri, Stream stream);
    public static void ValidateNupkg(string uri, Stream stream);
    public static void ValidateXml(string uri, Stream stream);
}
public interface NuGet.Protocol.IHttpRetryHandler {
    public abstract virtual Task`1<HttpResponseMessage> SendAsync(HttpRetryHandlerRequest request, ILogger log, CancellationToken cancellationToken);
    public abstract virtual Task`1<HttpResponseMessage> SendAsync(HttpRetryHandlerRequest request, string sourceUri, ILogger log, CancellationToken cancellationToken);
}
public abstract class NuGet.Protocol.InvalidCacheProtocolException : FatalProtocolException {
    public InvalidCacheProtocolException(string message);
    public InvalidCacheProtocolException(string message, Exception innerException);
    protected InvalidCacheProtocolException(SerializationInfo info, StreamingContext context);
}
public interface NuGet.Protocol.IThrottle {
    public abstract virtual Task WaitAsync();
    public abstract virtual void Release();
}
public interface NuGet.Protocol.IV2FeedParser {
    public abstract virtual Task`1<V2FeedPage> GetPackagesPageAsync(string searchTerm, SearchFilter filters, int skip, int take, ILogger log, CancellationToken token);
    public abstract virtual Task`1<V2FeedPage> GetSearchPageAsync(string searchTerm, SearchFilter filters, int skip, int take, ILogger log, CancellationToken token);
}
public interface NuGet.Protocol.IVulnerabilityInfoResource {
    [NullableContextAttribute("1")]
public abstract virtual Task`1<GetVulnerabilityInfoResult> GetVulnerabilityInfoAsync(SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
}
[ExtensionAttribute]
public static class NuGet.Protocol.JsonExtensions : object {
    public static int JsonSerializationMaxDepth;
    public static JsonSerializerSettings ObjectSerializationSettings;
    internal static JsonSerializer JsonObjectSerializer;
    internal static JsonSerializerOptions JsonSerializerOptions;
    private static JsonExtensions();
    private static JsonSerializerOptions CreateJsonSerializerOptions();
    [ExtensionAttribute]
public static string ToJson(object obj, Formatting formatting);
    [ExtensionAttribute]
public static T FromJson(string json);
    [ExtensionAttribute]
public static T FromJson(string json, JsonSerializerSettings settings);
    [ExtensionAttribute]
public static object FromJson(string json, Type type);
    [ExtensionAttribute]
public static JToken ToJToken(object obj);
    [ExtensionAttribute]
public static T FromJToken(JToken jtoken);
    [ExtensionAttribute]
public static object FromJToken(JToken jtoken, Type type);
    [ExtensionAttribute]
public static T GetJObjectProperty(JObject jobject, string propertyName);
    [ExtensionAttribute]
public static Nullable`1<bool> GetBoolean(JObject json, string propertyName);
}
public static class NuGet.Protocol.JsonProperties : object {
    public static string Data;
    public static string SubjectId;
    public static string Type;
    public static string PackageId;
    public static string Version;
    public static string Title;
    public static string Summary;
    public static string Description;
    public static string Authors;
    public static string Owners;
    public static string IconUrl;
    public static string LicenseUrl;
    public static string LicenseExpression;
    public static string LicenseExpressionVersion;
    public static string ProjectUrl;
    public static string ReadmeUrl;
    public static string Tags;
    public static string DownloadCount;
    public static string Created;
    public static string LastEdited;
    public static string Published;
    public static string RequireLicenseAcceptance;
    public static string DependencyGroups;
    public static string LatestVersion;
    public static string TargetFramework;
    public static string Dependencies;
    public static string Range;
    public static string MinimumClientVersion;
    public static string Language;
    public static string PackageContent;
    public static string Versions;
    public static string PrefixReserved;
    public static string Listed;
    public static string Subject;
    public static string Issuer;
    public static string NotBefore;
    public static string NotAfter;
    public static string ContentUrl;
    public static string SigningCertificates;
    public static string AllRepositorySigned;
    public static string Fingerprints;
    public static string Deprecation;
    public static string DeprecationMessage;
    public static string DeprecationReasons;
    public static string AlternatePackage;
    public static string Vulnerabilities;
    public static string AdvisoryUrl;
    public static string Severity;
    public static string Url;
}
internal static class NuGet.Protocol.JsonUtility : object {
    internal static JsonLoadSettings DefaultLoadSettings;
    private static JsonUtility();
    internal static JObject LoadJson(TextReader reader);
    internal static JObject LoadJson(JsonReader jsonReader);
}
public class NuGet.Protocol.LegacyFeedCapabilityResourceV2Feed : LegacyFeedCapabilityResource {
    private static ConcurrentDictionary`2<string, Task`1<Capabilities>> CachedCapabilities;
    private static string MetadataUriFormat;
    private string _metadataUri;
    private V2FeedParser _feedParser;
    public LegacyFeedCapabilityResourceV2Feed(V2FeedParser feedParser, string baseAddress);
    private static LegacyFeedCapabilityResourceV2Feed();
    [AsyncStateMachineAttribute("NuGet.Protocol.LegacyFeedCapabilityResourceV2Feed/<SupportsIsAbsoluteLatestVersionAsync>d__5")]
public virtual Task`1<bool> SupportsIsAbsoluteLatestVersionAsync(ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.LegacyFeedCapabilityResourceV2Feed/<SupportsSearchAsync>d__6")]
public virtual Task`1<bool> SupportsSearchAsync(ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.LegacyFeedCapabilityResourceV2Feed/<GetCachedCapabilitiesAsync>d__7")]
private Task`1<Capabilities> GetCachedCapabilitiesAsync(ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.LegacyFeedCapabilityResourceV2Feed/<GetCapabilitiesAsync>d__8")]
private Task`1<Capabilities> GetCapabilitiesAsync(string metadataUri, ILogger log, CancellationToken token);
}
public class NuGet.Protocol.LocalAutoCompleteResource : AutoCompleteResource {
    private FindLocalPackagesResource _localResource;
    public LocalAutoCompleteResource(FindLocalPackagesResource localResource);
    public virtual Task`1<IEnumerable`1<string>> IdStartsWith(string packageIdPrefix, bool includePrerelease, ILogger log, CancellationToken token);
    public virtual Task`1<IEnumerable`1<NuGetVersion>> VersionStartsWith(string packageId, string versionPrefix, bool includePrerelease, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.LocalAutoCompleteResource/<GetPackageIdsFromLocalPackageRepository>d__4")]
private Task`1<IEnumerable`1<string>> GetPackageIdsFromLocalPackageRepository(string searchFilter, bool includePrerelease, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.LocalAutoCompleteResource/<GetPackageVersionsFromLocalPackageRepository>d__5")]
protected Task`1<IEnumerable`1<NuGetVersion>> GetPackageVersionsFromLocalPackageRepository(string packageId, string versionPrefix, bool includePrerelease, ILogger log, CancellationToken token);
}
public class NuGet.Protocol.LocalAutoCompleteResourceProvider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.LocalAutoCompleteResourceProvider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
public class NuGet.Protocol.LocalDependencyInfoResource : DependencyInfoResource {
    private FindLocalPackagesResource _localResource;
    private SourceRepository _source;
    public LocalDependencyInfoResource(FindLocalPackagesResource localResource, SourceRepository source);
    public virtual Task`1<SourcePackageDependencyInfo> ResolvePackage(PackageIdentity package, NuGetFramework projectFramework, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
    public virtual Task`1<IEnumerable`1<SourcePackageDependencyInfo>> ResolvePackages(string packageId, NuGetFramework projectFramework, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
    private SourcePackageDependencyInfo CreateDependencyInfo(LocalPackageInfo package, NuGetFramework projectFramework);
}
public class NuGet.Protocol.LocalDependencyInfoResourceProvider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.LocalDependencyInfoResourceProvider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
public class NuGet.Protocol.LocalDownloadResource : DownloadResource {
    private FindLocalPackagesResource _localResource;
    private string _source;
    [ObsoleteAttribute("Use constructor with source parameter")]
public LocalDownloadResource(FindLocalPackagesResource localResource);
    public LocalDownloadResource(string source, FindLocalPackagesResource localResource);
    public virtual Task`1<DownloadResourceResult> GetDownloadResourceResultAsync(PackageIdentity identity, PackageDownloadContext downloadContext, string globalPackagesFolder, ILogger logger, CancellationToken token);
}
public class NuGet.Protocol.LocalDownloadResourceProvider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.LocalDownloadResourceProvider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
public static class NuGet.Protocol.LocalFolderUtility : object {
    private static string NupkgFilter;
    private static LocalFolderUtility();
    public static LocalPackageInfo GetPackage(Uri path, ILogger log);
    public static IEnumerable`1<LocalPackageInfo> GetPackagesV2(string root, ILogger log);
    public static IEnumerable`1<LocalPackageInfo> GetPackagesV2(string root, ILogger log, CancellationToken cancellationToken);
    public static IEnumerable`1<LocalPackageInfo> GetPackagesV2(string root, string id, ILogger log);
    [IteratorStateMachineAttribute("NuGet.Protocol.LocalFolderUtility/<GetPackagesV2>d__5")]
public static IEnumerable`1<LocalPackageInfo> GetPackagesV2(string root, string id, ILogger log, CancellationToken cancellationToken);
    public static LocalPackageInfo GetPackageV2(string root, string id, NuGetVersion version, ILogger log);
    public static LocalPackageInfo GetPackageV2(string root, string id, NuGetVersion version, ILogger log, CancellationToken cancellationToken);
    public static LocalPackageInfo GetPackageV2(string root, PackageIdentity identity, ILogger log);
    public static LocalPackageInfo GetPackageV2(string root, PackageIdentity identity, ILogger log, CancellationToken cancellationToken);
    public static IEnumerable`1<LocalPackageInfo> GetPackagesConfigFolderPackages(string root, ILogger log);
    [IteratorStateMachineAttribute("NuGet.Protocol.LocalFolderUtility/<GetPackagesConfigFolderPackages>d__11")]
public static IEnumerable`1<LocalPackageInfo> GetPackagesConfigFolderPackages(string root, ILogger log, CancellationToken cancellationToken);
    [IteratorStateMachineAttribute("NuGet.Protocol.LocalFolderUtility/<GetPackagesConfigFolderPackages>d__12")]
public static IEnumerable`1<LocalPackageInfo> GetPackagesConfigFolderPackages(string root, string id, ILogger log);
    public static LocalPackageInfo GetPackagesConfigFolderPackage(string root, PackageIdentity identity, ILogger log);
    private static string GetPackagesConfigFolderSearchPattern(string id);
    public static LocalPackageInfo GetPackagesConfigFolderPackage(string root, string id, NuGetVersion version, ILogger log);
    private static LocalPackageInfo GetPackagesConfigFolderPackage(DirectoryInfo dir, ILogger log);
    public static bool IsPossiblePackageMatch(FileInfo file, PackageIdentity identity);
    public static bool IsPossiblePackageMatch(FileInfo file, string id);
    public static PackageIdentity GetIdentityFromNupkgPath(FileInfo file, string id);
    public static NuGetVersion GetVersionFromFileName(string fileName, string id, string extension);
    private static NuGetVersion GetVersionFromIdVersionString(string idVersionString, string id);
    public static LocalPackageInfo GetPackageV3(string root, string id, NuGetVersion version, ILogger log);
    public static LocalPackageInfo GetPackageV3(string root, PackageIdentity identity, ILogger log);
    public static IEnumerable`1<FileInfo> GetNupkgsFromFlatFolder(string root, ILogger log);
    [IteratorStateMachineAttribute("NuGet.Protocol.LocalFolderUtility/<GetNupkgsFromFlatFolder>d__25")]
public static IEnumerable`1<FileInfo> GetNupkgsFromFlatFolder(string root, ILogger log, CancellationToken cancellationToken);
    public static FeedType GetLocalFeedType(string root, ILogger log);
    public static DirectoryInfo GetAndVerifyRootDirectory(string root);
    private static FileInfo GetAndVerifyFileInfo(Uri fileUri);
    [IteratorStateMachineAttribute("NuGet.Protocol.LocalFolderUtility/<GetNupkgsFromFlatFolderChunked>d__29")]
private static IEnumerable`1<List`1<FileInfo>> GetNupkgsFromFlatFolderChunked(DirectoryInfo root, ILogger log, CancellationToken cancellationToken);
    public static IEnumerable`1<FileInfo> GetNupkgsFromFlatFolder(string root, string id, ILogger log);
    [IteratorStateMachineAttribute("NuGet.Protocol.LocalFolderUtility/<GetNupkgsFromFlatFolder>d__31")]
public static IEnumerable`1<FileInfo> GetNupkgsFromFlatFolder(string root, string id, ILogger log, CancellationToken cancellationToken);
    public static IEnumerable`1<LocalPackageInfo> GetPackagesV3(string root, ILogger log);
    [IteratorStateMachineAttribute("NuGet.Protocol.LocalFolderUtility/<GetPackagesV3>d__33")]
public static IEnumerable`1<LocalPackageInfo> GetPackagesV3(string root, ILogger log, CancellationToken cancellationToken);
    public static IEnumerable`1<LocalPackageInfo> GetPackagesV3(string root, string id, ILogger log);
    [IteratorStateMachineAttribute("NuGet.Protocol.LocalFolderUtility/<GetPackagesV3>d__35")]
public static IEnumerable`1<LocalPackageInfo> GetPackagesV3(string root, string id, ILogger log, CancellationToken cancellationToken);
    public static IEnumerable`1<string> ResolvePackageFromPath(string packagePath, bool isSnupkg);
    private static string EnsurePackageExtension(string packagePath, bool isSnupkg);
    public static void EnsurePackageFileExists(string packagePath, IEnumerable`1<string> matchingPackagePaths);
    [IteratorStateMachineAttribute("NuGet.Protocol.LocalFolderUtility/<GetDistinctPackages>d__39")]
public static IEnumerable`1<LocalPackageInfo> GetDistinctPackages(IEnumerable`1<LocalPackageInfo> packages);
    private static List`1<DirectoryInfo> GetDirectoriesSafe(DirectoryInfo root, ILogger log, CancellationToken cancellationToken);
    private static List`1<DirectoryInfo> GetDirectoriesSafe(DirectoryInfo root, string filter, SearchOption searchOption, ILogger log, CancellationToken cancellationToken);
    internal static List`1<FileInfo> GetFilesSafe(DirectoryInfo root, string filter, ILogger log, CancellationToken cancellationToken);
    private static IEnumerable`1<LocalPackageInfo> GetPackagesFromNupkgs(IEnumerable`1<FileInfo> files, CancellationToken cancellationToken);
    private static LocalPackageInfo GetPackageFromNupkg(FileInfo nupkgFile);
    private static List`1<FileInfo> GetNupkgsFromDirectory(DirectoryInfo root, ILogger log, CancellationToken cancellationToken);
    private static LocalPackageInfo GetPackageV3(string root, string id, string version, ILogger log);
    private static FileInfo CreateFileInfoIfValidOrNull(string localPath, ILogger log);
    public static void GenerateNupkgMetadataFile(string nupkgPath, string installPath, string hashPath, string nupkgMetadataPath);
    [IteratorStateMachineAttribute("NuGet.Protocol.LocalFolderUtility/<CancellableYieldEnumeration>d__49`1")]
private static IEnumerable`1<T> CancellableYieldEnumeration(IEnumerable`1<T> enumerable, CancellationToken cancellationToken);
}
public class NuGet.Protocol.LocalMetadataResource : MetadataResource {
    private FindLocalPackagesResource _localResource;
    public LocalMetadataResource(FindLocalPackagesResource localResource);
    [AsyncStateMachineAttribute("NuGet.Protocol.LocalMetadataResource/<GetLatestVersions>d__2")]
public virtual Task`1<IEnumerable`1<KeyValuePair`2<string, NuGetVersion>>> GetLatestVersions(IEnumerable`1<string> packageIds, bool includePrerelease, bool includeUnlisted, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
    public virtual Task`1<IEnumerable`1<NuGetVersion>> GetVersions(string packageId, bool includePrerelease, bool includeUnlisted, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
    public virtual Task`1<bool> Exists(PackageIdentity identity, bool includeUnlisted, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
    public virtual Task`1<bool> Exists(string packageId, bool includePrerelease, bool includeUnlisted, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
}
public class NuGet.Protocol.LocalMetadataResourceProvider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.LocalMetadataResourceProvider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
public class NuGet.Protocol.LocalPackageArchiveDownloader : object {
    private Func`2<Exception, Task`1<bool>> _handleExceptionAsync;
    private bool _isDisposed;
    private ILogger _logger;
    private string _packageFilePath;
    private PackageIdentity _packageIdentity;
    private Lazy`1<PackageArchiveReader> _packageReader;
    private Lazy`1<FileStream> _sourceStream;
    private SemaphoreSlim _throttle;
    [CompilerGeneratedAttribute]
private string <Source>k__BackingField;
    public IAsyncPackageContentReader ContentReader { get; }
    public IAsyncPackageCoreReader CoreReader { get; }
    public ISignedPackageReader SignedPackageReader { get; }
    public string Source { get; }
    public LocalPackageArchiveDownloader(string source, string packageFilePath, PackageIdentity packageIdentity, ILogger logger);
    public sealed virtual IAsyncPackageContentReader get_ContentReader();
    public sealed virtual IAsyncPackageCoreReader get_CoreReader();
    public sealed virtual ISignedPackageReader get_SignedPackageReader();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Source();
    public sealed virtual void Dispose();
    [AsyncStateMachineAttribute("NuGet.Protocol.LocalPackageArchiveDownloader/<CopyNupkgFileToAsync>d__19")]
public sealed virtual Task`1<bool> CopyNupkgFileToAsync(string destinationFilePath, CancellationToken cancellationToken);
    public sealed virtual Task`1<string> GetPackageHashAsync(string hashAlgorithm, CancellationToken cancellationToken);
    public sealed virtual void SetExceptionHandler(Func`2<Exception, Task`1<bool>> handleExceptionAsync);
    public sealed virtual void SetThrottle(SemaphoreSlim throttle);
    private PackageArchiveReader GetPackageReader();
    private FileStream GetSourceStream();
    private void ThrowIfDisposed();
}
public class NuGet.Protocol.LocalPackageFileCache : object {
    private ConcurrentDictionary`2<string, Lazy`1<NuspecReader>> _nuspecCache;
    private ConcurrentDictionary`2<string, Lazy`1<IReadOnlyList`1<string>>> _filesCache;
    private ConcurrentDictionary`2<string, Lazy`1<string>> _sha512Cache;
    private ConcurrentDictionary`2<string, bool> _fileExistsCache;
    private ConcurrentDictionary`2<string, Lazy`1<RuntimeGraph>> _runtimeCache;
    private ConcurrentDictionary`2<string, bool> _metadataFileCache;
    public virtual Lazy`1<NuspecReader> GetOrAddNuspec(string manifestPath, string expandedPath);
    public virtual Lazy`1<IReadOnlyList`1<string>> GetOrAddFiles(string expandedPath);
    public virtual Lazy`1<string> GetOrAddSha512(string sha512Path);
    public virtual bool Sha512Exists(string sha512Path);
    public void UpdateLastAccessTime(string nupkgMetadataPath);
    public virtual Lazy`1<RuntimeGraph> GetOrAddRuntimeGraph(string expandedPath);
    private static IReadOnlyList`1<string> GetFiles(string expandedPath);
    private static bool IsAllowedLibraryFile(string path);
    private static NuspecReader GetNuspec(string manifestPath, string expandedPath);
    private RuntimeGraph GetRuntimeGraph(string expandedPath);
    [CompilerGeneratedAttribute]
private Lazy`1<RuntimeGraph> <GetOrAddRuntimeGraph>b__12_0(string p);
}
public class NuGet.Protocol.LocalPackageInfo : object {
    private Lazy`1<NuspecReader> _nuspecHelper;
    private Func`1<PackageReaderBase> _getPackageReader;
    [CompilerGeneratedAttribute]
private PackageIdentity <Identity>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <LastWriteTimeUtc>k__BackingField;
    public PackageIdentity Identity { get; }
    public string Path { get; }
    public DateTime LastWriteTimeUtc { get; }
    public NuspecReader Nuspec { get; }
    public bool IsNupkg { get; }
    [ObsoleteAttribute("use other constructor")]
public LocalPackageInfo(PackageIdentity identity, string path, DateTime lastWriteTimeUtc, Lazy`1<NuspecReader> nuspec, Func`1<PackageReaderBase> getPackageReader);
    public LocalPackageInfo(PackageIdentity identity, string path, DateTime lastWriteTimeUtc, Lazy`1<NuspecReader> nuspec, bool useFolder);
    [CompilerGeneratedAttribute]
public virtual PackageIdentity get_Identity();
    [CompilerGeneratedAttribute]
public virtual string get_Path();
    [CompilerGeneratedAttribute]
public virtual DateTime get_LastWriteTimeUtc();
    public virtual PackageReaderBase GetReader();
    public virtual NuspecReader get_Nuspec();
    public virtual bool get_IsNupkg();
}
public class NuGet.Protocol.LocalPackageListResource : ListResource {
    private PackageSearchResource _localPackageSearchResource;
    private string _baseAddress;
    public string Source { get; }
    public LocalPackageListResource(PackageSearchResource localPackageSearchResource, string baseAddress);
    public virtual string get_Source();
    public virtual Task`1<IEnumerableAsync`1<IPackageSearchMetadata>> ListAsync(string searchTerm, bool prerelease, bool allVersions, bool includeDelisted, ILogger logger, CancellationToken token);
}
public class NuGet.Protocol.LocalPackageMetadataResource : PackageMetadataResource {
    private FindLocalPackagesResource _localResource;
    public LocalPackageMetadataResource(FindLocalPackagesResource localResource);
    public virtual Task`1<IEnumerable`1<IPackageSearchMetadata>> GetMetadataAsync(string packageId, bool includePrerelease, bool includeUnlisted, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
    public virtual Task`1<IPackageSearchMetadata> GetMetadataAsync(PackageIdentity package, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
    private static IPackageSearchMetadata GetPackageMetadata(LocalPackageInfo package);
}
public class NuGet.Protocol.LocalPackageMetadataResourceProvider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.LocalPackageMetadataResourceProvider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
public class NuGet.Protocol.LocalPackageSearchMetadata : object {
    private NuspecReader _nuspec;
    private LocalPackageInfo _package;
    private IReadOnlyList`1<string> _ownersList;
    private static int FiveMegabytes;
    public string Authors { get; }
    public IEnumerable`1<PackageDependencyGroup> DependencySets { get; }
    public string Description { get; }
    public Nullable`1<long> DownloadCount { get; }
    public Uri IconUrl { get; }
    public PackageIdentity Identity { get; }
    public Uri LicenseUrl { get; }
    public IReadOnlyList`1<string> OwnersList { get; }
    public string Owners { get; }
    public Uri ProjectUrl { get; }
    public Nullable`1<DateTimeOffset> Published { get; }
    public Uri ReadmeUrl { get; }
    public Uri ReportAbuseUrl { get; }
    public Uri PackageDetailsUrl { get; }
    public bool RequireLicenseAcceptance { get; }
    public string Summary { get; }
    public string Tags { get; }
    public string Title { get; }
    public Func`1<PackageReaderBase> PackageReader { get; }
    public bool IsListed { get; }
    public bool PrefixReserved { get; }
    public LicenseMetadata LicenseMetadata { get; }
    public IEnumerable`1<PackageVulnerabilityMetadata> Vulnerabilities { get; }
    public string PackagePath { get; }
    public LocalPackageSearchMetadata(LocalPackageInfo package);
    public sealed virtual string get_Authors();
    public sealed virtual IEnumerable`1<PackageDependencyGroup> get_DependencySets();
    public sealed virtual string get_Description();
    public sealed virtual Nullable`1<long> get_DownloadCount();
    public sealed virtual Uri get_IconUrl();
    public sealed virtual PackageIdentity get_Identity();
    public sealed virtual Uri get_LicenseUrl();
    public sealed virtual IReadOnlyList`1<string> get_OwnersList();
    public sealed virtual string get_Owners();
    public sealed virtual Uri get_ProjectUrl();
    public sealed virtual Nullable`1<DateTimeOffset> get_Published();
    public sealed virtual Uri get_ReadmeUrl();
    public sealed virtual Uri get_ReportAbuseUrl();
    public sealed virtual Uri get_PackageDetailsUrl();
    public sealed virtual bool get_RequireLicenseAcceptance();
    public sealed virtual string get_Summary();
    public sealed virtual string get_Tags();
    public sealed virtual string get_Title();
    public Func`1<PackageReaderBase> get_PackageReader();
    public sealed virtual Task`1<IEnumerable`1<VersionInfo>> GetVersionsAsync();
    private static Uri Convert(string uri);
    public sealed virtual bool get_IsListed();
    public sealed virtual bool get_PrefixReserved();
    public sealed virtual LicenseMetadata get_LicenseMetadata();
    public sealed virtual Task`1<PackageDeprecationMetadata> GetDeprecationMetadataAsync();
    public sealed virtual IEnumerable`1<PackageVulnerabilityMetadata> get_Vulnerabilities();
    public string get_PackagePath();
    public string LoadFileAsText(string path);
    private Uri GetIconUri();
    [CompilerGeneratedAttribute]
private PackageReaderBase <get_PackageReader>b__41_0();
}
public class NuGet.Protocol.LocalPackageSearchResource : PackageSearchResource {
    private FindLocalPackagesResource _localResource;
    public LocalPackageSearchResource(FindLocalPackagesResource localResource);
    [AsyncStateMachineAttribute("NuGet.Protocol.LocalPackageSearchResource/<SearchAsync>d__2")]
public virtual Task`1<IEnumerable`1<IPackageSearchMetadata>> SearchAsync(string searchTerm, SearchFilter filters, int skip, int take, ILogger log, CancellationToken token);
    private static bool ContainsAnyTerm(String[] terms, LocalPackageInfo package);
    private static bool ContainsTerm(string search, string property);
    private IPackageSearchMetadata CreatePackageSearchResult(LocalPackageInfo package, SearchFilter filter, ILogger log, CancellationToken cancellationToken);
    private static List`1<VersionInfo> GetVersions(FindLocalPackagesResource localResource, LocalPackageInfo package, SearchFilter filter, ILogger log, CancellationToken token);
    private static bool IsLocalOrUNC(string currentSource);
    [IteratorStateMachineAttribute("NuGet.Protocol.LocalPackageSearchResource/<CollapseToHighestVersion>d__8")]
private static IEnumerable`1<LocalPackageInfo> CollapseToHighestVersion(IEnumerable`1<LocalPackageInfo> source);
}
public class NuGet.Protocol.LocalPackageSearchResourceProvider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.LocalPackageSearchResourceProvider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
public class NuGet.Protocol.LocalRepositories.LocalPackageListResourceProvider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.LocalRepositories.LocalPackageListResourceProvider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
public class NuGet.Protocol.LocalV2FindPackageByIdResource : FindPackageByIdResource {
    private ConcurrentDictionary`2<string, IReadOnlyList`1<LocalPackageInfo>> _packageInfoCache;
    private string _source;
    private static string ResourceTypeName;
    private static string ThisTypeName;
    public LocalV2FindPackageByIdResource(PackageSource packageSource);
    public virtual Task`1<IEnumerable`1<NuGetVersion>> GetAllVersionsAsync(string id, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.LocalV2FindPackageByIdResource/<CopyNupkgToStreamAsync>d__6")]
public virtual Task`1<bool> CopyNupkgToStreamAsync(string id, NuGetVersion version, Stream destination, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    public virtual Task`1<FindPackageByIdDependencyInfo> GetDependencyInfoAsync(string id, NuGetVersion version, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    private LocalPackageInfo GetPackageInfo(string id, NuGetVersion version, SourceCacheContext cacheContext, ILogger logger);
    public virtual Task`1<IPackageDownloader> GetPackageDownloaderAsync(PackageIdentity packageIdentity, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    public virtual Task`1<bool> DoesPackageExistAsync(string id, NuGetVersion version, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    private IReadOnlyList`1<LocalPackageInfo> GetPackageInfos(string id, SourceCacheContext cacheContext, ILogger logger);
    private IReadOnlyList`1<LocalPackageInfo> GetPackageInfosCore(string id, ILogger logger);
}
public class NuGet.Protocol.LocalV2FindPackageByIdResourceProvider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.LocalV2FindPackageByIdResourceProvider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
public class NuGet.Protocol.LocalV3FindPackageByIdResource : FindPackageByIdResource {
    private ConcurrentDictionary`2<string, List`1<NuGetVersion>> _cache;
    private string _source;
    private VersionFolderPathResolver _resolver;
    private LocalPackageFileCache _packageFileCache;
    private Lazy`1<bool> _rootExists;
    private bool _isFallbackFolder;
    private static string ResourceTypeName;
    private static string ThisTypeName;
    public LocalPackageFileCache PackageFileCache { get; public set; }
    public bool IsFallbackFolder { get; public set; }
    public LocalV3FindPackageByIdResource(PackageSource packageSource);
    public LocalPackageFileCache get_PackageFileCache();
    public void set_PackageFileCache(LocalPackageFileCache value);
    public bool get_IsFallbackFolder();
    public void set_IsFallbackFolder(bool value);
    public virtual Task`1<IEnumerable`1<NuGetVersion>> GetAllVersionsAsync(string id, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.LocalV3FindPackageByIdResource/<CopyNupkgToStreamAsync>d__16")]
public virtual Task`1<bool> CopyNupkgToStreamAsync(string id, NuGetVersion version, Stream destination, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    public virtual Task`1<FindPackageByIdDependencyInfo> GetDependencyInfoAsync(string id, NuGetVersion version, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    public virtual Task`1<IPackageDownloader> GetPackageDownloaderAsync(PackageIdentity packageIdentity, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    public virtual Task`1<bool> DoesPackageExistAsync(string id, NuGetVersion version, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    private T ProcessNuspecReader(string id, NuGetVersion version, Func`2<NuspecReader, T> process);
    private bool DoesVersionExist(string id, NuGetVersion version);
    private List`1<NuGetVersion> GetVersions(string id, SourceCacheContext cacheContext, ILogger logger);
    private List`1<NuGetVersion> GetVersionsCore(string id, ILogger logger);
    [CompilerGeneratedAttribute]
private bool <.ctor>b__14_0();
}
public class NuGet.Protocol.LocalV3FindPackageByIdResourceProvider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.LocalV3FindPackageByIdResourceProvider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
public class NuGet.Protocol.MetadataFieldConverter : JsonConverter {
    public bool CanWrite { get; }
    public virtual bool CanConvert(Type objectType);
    public virtual bool get_CanWrite();
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
}
public class NuGet.Protocol.MetadataReferenceCache : object {
    private Dictionary`2<string, string> _stringCache;
    private Dictionary`2<Type, PropertyInfo[]> _propertyCache;
    private Dictionary`2<string, NuGetVersion> _versionCache;
    private Type _metadataReferenceCacheType;
    private static IDictionary`2<Type, string> CachableTypesMap;
    [CompilerGeneratedAttribute]
private Dictionary`2<Type, MethodInfo> <CachableMethodTypes>k__BackingField;
    internal static IEnumerable`1<Type> CachableTypes { get; }
    internal Dictionary`2<Type, MethodInfo> CachableMethodTypes { get; }
    private static MetadataReferenceCache();
    public string GetString(string s);
    public NuGetVersion GetVersion(string s);
    internal static IEnumerable`1<Type> get_CachableTypes();
    [CompilerGeneratedAttribute]
internal Dictionary`2<Type, MethodInfo> get_CachableMethodTypes();
    public T GetObject(T input);
}
public class NuGet.Protocol.MetadataResourceV2Feed : MetadataResource {
    private V2FeedParser _feedParser;
    private SourceRepository _source;
    public MetadataResourceV2Feed(V2FeedParser feedParser, SourceRepository source);
    [AsyncStateMachineAttribute("NuGet.Protocol.MetadataResourceV2Feed/<GetLatestVersions>d__3")]
public virtual Task`1<IEnumerable`1<KeyValuePair`2<string, NuGetVersion>>> GetLatestVersions(IEnumerable`1<string> packageIds, bool includePrerelease, bool includeUnlisted, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.MetadataResourceV2Feed/<GetVersions>d__4")]
public virtual Task`1<IEnumerable`1<NuGetVersion>> GetVersions(string packageId, bool includePrerelease, bool includeUnlisted, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.MetadataResourceV2Feed/<Exists>d__5")]
public virtual Task`1<bool> Exists(PackageIdentity identity, bool includeUnlisted, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.MetadataResourceV2Feed/<Exists>d__6")]
public virtual Task`1<bool> Exists(string packageId, bool includePrerelease, bool includeUnlisted, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
}
public class NuGet.Protocol.MetadataResourceV2FeedProvider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.MetadataResourceV2FeedProvider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
public class NuGet.Protocol.MetadataResourceV3 : MetadataResource {
    private RegistrationResourceV3 _regResource;
    public MetadataResourceV3(RegistrationResourceV3 regResource);
    [AsyncStateMachineAttribute("NuGet.Protocol.MetadataResourceV3/<GetLatestVersions>d__2")]
public virtual Task`1<IEnumerable`1<KeyValuePair`2<string, NuGetVersion>>> GetLatestVersions(IEnumerable`1<string> packageIds, bool includePrerelease, bool includeUnlisted, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.MetadataResourceV3/<Exists>d__3")]
public virtual Task`1<bool> Exists(PackageIdentity identity, bool includeUnlisted, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.MetadataResourceV3/<Exists>d__4")]
public virtual Task`1<bool> Exists(string packageId, bool includePrerelease, bool includeUnlisted, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.MetadataResourceV3/<GetVersions>d__5")]
public virtual Task`1<IEnumerable`1<NuGetVersion>> GetVersions(string packageId, bool includePrerelease, bool includeUnlisted, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
}
public class NuGet.Protocol.MetadataResourceV3Provider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.MetadataResourceV3Provider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
internal class NuGet.Protocol.MetadataStringOrArrayConverter : JsonConverter {
    public bool CanWrite { get; }
    public virtual bool CanConvert(Type objectType);
    public virtual bool get_CanWrite();
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
}
internal class NuGet.Protocol.Model.CaseInsensitiveDictionary`1 : Dictionary`2<string, TValue> {
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class NuGet.Protocol.Model.GetVulnerabilityInfoResult : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IReadOnlyList`1<IReadOnlyDictionary`2<string, IReadOnlyList`1<PackageVulnerabilityInfo>>> <KnownVulnerabilities>k__BackingField;
    [CompilerGeneratedAttribute]
private AggregateException <Exceptions>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IReadOnlyList`1<IReadOnlyDictionary`2<string, IReadOnlyList`1<PackageVulnerabilityInfo>>> KnownVulnerabilities { get; }
    public AggregateException Exceptions { get; }
    public GetVulnerabilityInfoResult(IReadOnlyList`1<IReadOnlyDictionary`2<string, IReadOnlyList`1<PackageVulnerabilityInfo>>> knownVulnerabilities, AggregateException exceptions);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<IReadOnlyDictionary`2<string, IReadOnlyList`1<PackageVulnerabilityInfo>>> get_KnownVulnerabilities();
    [CompilerGeneratedAttribute]
public AggregateException get_Exceptions();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NuGet.Protocol.Model.PackageVulnerabilityInfo : object {
    [CompilerGeneratedAttribute]
private Uri <Url>k__BackingField;
    [CompilerGeneratedAttribute]
private PackageVulnerabilitySeverity <Severity>k__BackingField;
    [CompilerGeneratedAttribute]
private VersionRange <Versions>k__BackingField;
    [JsonPropertyNameAttribute("url")]
public Uri Url { get; }
    [JsonPropertyNameAttribute("severity")]
public PackageVulnerabilitySeverity Severity { get; }
    [JsonPropertyNameAttribute("versions")]
public VersionRange Versions { get; }
    [JsonConstructorAttribute]
public PackageVulnerabilityInfo(Uri url, PackageVulnerabilitySeverity severity, VersionRange versions);
    [CompilerGeneratedAttribute]
public Uri get_Url();
    [CompilerGeneratedAttribute]
public PackageVulnerabilitySeverity get_Severity();
    [CompilerGeneratedAttribute]
public VersionRange get_Versions();
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(PackageVulnerabilityInfo other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class NuGet.Protocol.Model.RegistrationIndex : object {
    [CompilerGeneratedAttribute]
private List`1<RegistrationPage> <Items>k__BackingField;
    [JsonPropertyAttribute("items")]
public List`1<RegistrationPage> Items { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<RegistrationPage> get_Items();
    [CompilerGeneratedAttribute]
public void set_Items(List`1<RegistrationPage> value);
}
internal class NuGet.Protocol.Model.RegistrationLeafItem : object {
    [CompilerGeneratedAttribute]
private PackageSearchMetadataRegistration <CatalogEntry>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <PackageContent>k__BackingField;
    [JsonPropertyAttribute("catalogEntry")]
public PackageSearchMetadataRegistration CatalogEntry { get; public set; }
    [JsonPropertyAttribute]
public Uri PackageContent { get; public set; }
    [CompilerGeneratedAttribute]
public PackageSearchMetadataRegistration get_CatalogEntry();
    [CompilerGeneratedAttribute]
public void set_CatalogEntry(PackageSearchMetadataRegistration value);
    [CompilerGeneratedAttribute]
public Uri get_PackageContent();
    [CompilerGeneratedAttribute]
public void set_PackageContent(Uri value);
}
internal class NuGet.Protocol.Model.RegistrationPage : object {
    [CompilerGeneratedAttribute]
private string <Url>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<RegistrationLeafItem> <Items>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Lower>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Upper>k__BackingField;
    [JsonPropertyAttribute("@id")]
public string Url { get; public set; }
    [JsonPropertyAttribute("items")]
public List`1<RegistrationLeafItem> Items { get; public set; }
    [JsonPropertyAttribute("lower")]
public string Lower { get; public set; }
    [JsonPropertyAttribute("upper")]
public string Upper { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Url();
    [CompilerGeneratedAttribute]
public void set_Url(string value);
    [CompilerGeneratedAttribute]
public List`1<RegistrationLeafItem> get_Items();
    [CompilerGeneratedAttribute]
public void set_Items(List`1<RegistrationLeafItem> value);
    [CompilerGeneratedAttribute]
public string get_Lower();
    [CompilerGeneratedAttribute]
public void set_Lower(string value);
    [CompilerGeneratedAttribute]
public string get_Upper();
    [CompilerGeneratedAttribute]
public void set_Upper(string value);
}
internal class NuGet.Protocol.Model.V3SearchResults : object {
    [CompilerGeneratedAttribute]
private long <TotalHits>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<PackageSearchMetadata> <Data>k__BackingField;
    [JsonPropertyAttribute("totalHits")]
public long TotalHits { get; public set; }
    [JsonPropertyAttribute("data")]
public List`1<PackageSearchMetadata> Data { get; private set; }
    [CompilerGeneratedAttribute]
public long get_TotalHits();
    [CompilerGeneratedAttribute]
public void set_TotalHits(long value);
    [CompilerGeneratedAttribute]
public List`1<PackageSearchMetadata> get_Data();
    [CompilerGeneratedAttribute]
private void set_Data(List`1<PackageSearchMetadata> value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NuGet.Protocol.Model.V3VulnerabilityIndexEntry : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <Url>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Updated>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Comment>k__BackingField;
    [JsonPropertyNameAttribute("@name")]
public string Name { get; }
    [JsonPropertyNameAttribute("@id")]
public Uri Url { get; }
    [JsonPropertyNameAttribute("@updated")]
public string Updated { get; }
    [NullableAttribute("2")]
[JsonPropertyNameAttribute("comment")]
public string Comment { get; }
    public V3VulnerabilityIndexEntry(string name, Uri url, string updated, string comment);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public Uri get_Url();
    [CompilerGeneratedAttribute]
public string get_Updated();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Comment();
}
public class NuGet.Protocol.NuGetVersionConverter : JsonConverter {
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual bool CanConvert(Type objectType);
}
public class NuGet.Protocol.NullThrottle : object {
    private static NullThrottle _instance;
    public static NullThrottle Instance { get; }
    private static NullThrottle();
    public static NullThrottle get_Instance();
    public sealed virtual Task WaitAsync();
    public sealed virtual void Release();
}
public class NuGet.Protocol.ODataServiceDocumentResourceV2 : object {
    private string _baseAddress;
    private DateTime _requestTime;
    public DateTime RequestTime { get; }
    public string BaseAddress { get; }
    public ODataServiceDocumentResourceV2(string baseAddress, DateTime requestTime);
    public virtual DateTime get_RequestTime();
    public string get_BaseAddress();
}
public class NuGet.Protocol.ODataServiceDocumentResourceV2Provider : ResourceProvider {
    private static TimeSpan _defaultCacheDuration;
    private ConcurrentDictionary`2<string, ODataServiceDocumentCacheInfo> _cache;
    private SemaphoreSlim _semaphore;
    [CompilerGeneratedAttribute]
private TimeSpan <MaxCacheDuration>k__BackingField;
    public TimeSpan MaxCacheDuration { get; protected set; }
    private static ODataServiceDocumentResourceV2Provider();
    [CompilerGeneratedAttribute]
public TimeSpan get_MaxCacheDuration();
    [CompilerGeneratedAttribute]
protected void set_MaxCacheDuration(TimeSpan value);
    [AsyncStateMachineAttribute("NuGet.Protocol.ODataServiceDocumentResourceV2Provider/<TryCreate>d__8")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
public class NuGet.Protocol.PackageDependencyGroupConverter : JsonConverter {
    public bool CanWrite { get; }
    public virtual bool CanConvert(Type objectType);
    public virtual bool get_CanWrite();
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    private static PackageDependency LoadDependency(JToken dependency);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
}
public class NuGet.Protocol.PackageDeprecationMetadata : object {
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <Reasons>k__BackingField;
    [CompilerGeneratedAttribute]
private AlternatePackageMetadata <AlternatePackage>k__BackingField;
    [JsonPropertyAttribute]
public string Message { get; internal set; }
    [JsonPropertyAttribute]
public IEnumerable`1<string> Reasons { get; internal set; }
    [JsonPropertyAttribute]
public AlternatePackageMetadata AlternatePackage { get; internal set; }
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
internal void set_Message(string value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_Reasons();
    [CompilerGeneratedAttribute]
internal void set_Reasons(IEnumerable`1<string> value);
    [CompilerGeneratedAttribute]
public AlternatePackageMetadata get_AlternatePackage();
    [CompilerGeneratedAttribute]
internal void set_AlternatePackage(AlternatePackageMetadata value);
}
public class NuGet.Protocol.PackageDetailsUriResourceV3 : object {
    private string _template;
    private PackageDetailsUriResourceV3(string template);
    public static PackageDetailsUriResourceV3 CreateOrNull(string uriTemplate);
    private static bool IsValidUriTemplate(string uriTemplate);
    public Uri GetUri(string id, NuGetVersion version);
}
public class NuGet.Protocol.PackageDetailsUriResourceV3Provider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.PackageDetailsUriResourceV3Provider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
internal class NuGet.Protocol.PackageInfo : object {
    [CompilerGeneratedAttribute]
private RegistrationInfo <Registration>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Listed>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetVersion <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <PackageContent>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<DependencyInfo> <Dependencies>k__BackingField;
    public RegistrationInfo Registration { get; public set; }
    public bool Listed { get; public set; }
    public NuGetVersion Version { get; public set; }
    public Uri PackageContent { get; public set; }
    public IList`1<DependencyInfo> Dependencies { get; private set; }
    [CompilerGeneratedAttribute]
public RegistrationInfo get_Registration();
    [CompilerGeneratedAttribute]
public void set_Registration(RegistrationInfo value);
    [CompilerGeneratedAttribute]
public bool get_Listed();
    [CompilerGeneratedAttribute]
public void set_Listed(bool value);
    [CompilerGeneratedAttribute]
public NuGetVersion get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(NuGetVersion value);
    [CompilerGeneratedAttribute]
public Uri get_PackageContent();
    [CompilerGeneratedAttribute]
public void set_PackageContent(Uri value);
    [CompilerGeneratedAttribute]
public IList`1<DependencyInfo> get_Dependencies();
    [CompilerGeneratedAttribute]
private void set_Dependencies(IList`1<DependencyInfo> value);
    public virtual string ToString();
}
public class NuGet.Protocol.PackageMetadataResourceV2Feed : PackageMetadataResource {
    private HttpSource _httpSource;
    private PackageSource _packageSource;
    private V2FeedParser _feedParser;
    public PackageMetadataResourceV2Feed(HttpSourceResource httpSourceResource, string baseAddress, PackageSource packageSource);
    [AsyncStateMachineAttribute("NuGet.Protocol.PackageMetadataResourceV2Feed/<GetMetadataAsync>d__4")]
public virtual Task`1<IEnumerable`1<IPackageSearchMetadata>> GetMetadataAsync(string packageId, bool includePrerelease, bool includeUnlisted, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.PackageMetadataResourceV2Feed/<GetMetadataAsync>d__5")]
public virtual Task`1<IPackageSearchMetadata> GetMetadataAsync(PackageIdentity package, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
}
public class NuGet.Protocol.PackageMetadataResourceV2FeedProvider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.PackageMetadataResourceV2FeedProvider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
public class NuGet.Protocol.PackageMetadataResourceV3 : PackageMetadataResource {
    private RegistrationResourceV3 _regResource;
    private ReportAbuseResourceV3 _reportAbuseResource;
    private PackageDetailsUriResourceV3 _packageDetailsUriResource;
    private HttpSource _client;
    public PackageMetadataResourceV3(HttpSource client, RegistrationResourceV3 regResource, ReportAbuseResourceV3 reportAbuseResource, PackageDetailsUriResourceV3 packageDetailsUriResource);
    [AsyncStateMachineAttribute("NuGet.Protocol.PackageMetadataResourceV3/<GetMetadataAsync>d__5")]
public virtual Task`1<IEnumerable`1<IPackageSearchMetadata>> GetMetadataAsync(string packageId, bool includePrerelease, bool includeUnlisted, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.PackageMetadataResourceV3/<GetMetadataAsync>d__6")]
public virtual Task`1<IPackageSearchMetadata> GetMetadataAsync(PackageIdentity package, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.PackageMetadataResourceV3/<GetMetadataAsync>d__7")]
private Task`1<IEnumerable`1<IPackageSearchMetadata>> GetMetadataAsync(string packageId, bool includePrerelease, bool includeUnlisted, VersionRange range, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.PackageMetadataResourceV3/<DeserializeStreamDataAsync>d__8`1")]
private Task`1<T> DeserializeStreamDataAsync(Stream stream, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.PackageMetadataResourceV3/<LoadRegistrationIndexAsync>d__9")]
private Task`1<ValueTuple`2<RegistrationIndex, HttpSourceCacheContext>> LoadRegistrationIndexAsync(HttpSource httpSource, Uri registrationUri, string packageId, SourceCacheContext cacheContext, Func`2<HttpSourceResult, Task`1<RegistrationIndex>> processAsync, ILogger log, CancellationToken token);
    private Task`1<RegistrationPage> GetRegistratioIndexPageAsync(HttpSource httpSource, string rangeUri, string packageId, NuGetVersion lower, NuGetVersion upper, HttpSourceCacheContext httpSourceCacheContext, ILogger log, CancellationToken token);
    private void ProcessRegistrationPage(RegistrationPage registrationPage, List`1<PackageSearchMetadataRegistration> results, VersionRange range, bool includePrerelease, bool includeUnlisted, MetadataReferenceCache metadataCache);
}
public class NuGet.Protocol.PackageMetadataResourceV3Provider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.PackageMetadataResourceV3Provider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
public class NuGet.Protocol.PackageNotFoundProtocolException : InvalidCacheProtocolException {
    [CompilerGeneratedAttribute]
private PackageIdentity <PackageIdentity>k__BackingField;
    public PackageIdentity PackageIdentity { get; }
    public PackageNotFoundProtocolException(PackageIdentity package);
    public PackageNotFoundProtocolException(PackageIdentity package, Exception innerException);
    [CompilerGeneratedAttribute]
public PackageIdentity get_PackageIdentity();
    private static string GetMessage(PackageIdentity package);
}
public class NuGet.Protocol.PackageSearchMetadata : object {
    [CompilerGeneratedAttribute]
private string <Authors>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<PackageDependencyGroup> <DependencySetsInternal>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <DownloadCount>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <IconUrl>k__BackingField;
    private PackageIdentity _packageIdentity;
    [CompilerGeneratedAttribute]
private Uri <LicenseUrl>k__BackingField;
    private IReadOnlyList`1<string> _ownersList;
    private string _owners;
    [CompilerGeneratedAttribute]
private string <PackageId>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <ProjectUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <Published>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <ReadmeUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <ReportAbuseUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <PackageDetailsUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RequireLicenseAcceptance>k__BackingField;
    private string _summaryValue;
    [CompilerGeneratedAttribute]
private string <Tags>k__BackingField;
    private string _titleValue;
    [CompilerGeneratedAttribute]
private NuGetVersion <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private VersionInfo[] <ParsedVersions>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PrefixReserved>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LicenseExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LicenseExpressionVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsListed>k__BackingField;
    [CompilerGeneratedAttribute]
private PackageDeprecationMetadata <DeprecationMetadata>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<PackageVulnerabilityMetadata> <Vulnerabilities>k__BackingField;
    [JsonPropertyAttribute]
[JsonConverterAttribute("NuGet.Protocol.MetadataFieldConverter")]
public string Authors { get; private set; }
    [JsonPropertyAttribute]
public IEnumerable`1<PackageDependencyGroup> DependencySetsInternal { get; private set; }
    [JsonIgnoreAttribute]
public IEnumerable`1<PackageDependencyGroup> DependencySets { get; }
    [JsonPropertyAttribute]
public string Description { get; private set; }
    [JsonPropertyAttribute]
public Nullable`1<long> DownloadCount { get; private set; }
    [JsonPropertyAttribute]
public Uri IconUrl { get; private set; }
    [JsonIgnoreAttribute]
public PackageIdentity Identity { get; }
    [JsonPropertyAttribute]
[JsonConverterAttribute("NuGet.Protocol.SafeUriConverter")]
public Uri LicenseUrl { get; private set; }
    [JsonPropertyAttribute]
[JsonConverterAttribute("NuGet.Protocol.MetadataStringOrArrayConverter")]
public IReadOnlyList`1<string> OwnersList { get; private set; }
    public string Owners { get; }
    [JsonPropertyAttribute]
public string PackageId { get; private set; }
    [JsonPropertyAttribute]
[JsonConverterAttribute("NuGet.Protocol.SafeUriConverter")]
public Uri ProjectUrl { get; private set; }
    [JsonPropertyAttribute]
public Nullable`1<DateTimeOffset> Published { get; private set; }
    [JsonPropertyAttribute]
[JsonConverterAttribute("NuGet.Protocol.SafeUriConverter")]
public Uri ReadmeUrl { get; private set; }
    [JsonIgnoreAttribute]
public Uri ReportAbuseUrl { get; public set; }
    [JsonIgnoreAttribute]
public Uri PackageDetailsUrl { get; public set; }
    [JsonPropertyAttribute]
[DefaultValueAttribute("False")]
[JsonConverterAttribute("NuGet.Protocol.SafeBoolConverter")]
public bool RequireLicenseAcceptance { get; private set; }
    [JsonPropertyAttribute]
public string Summary { get; private set; }
    [JsonPropertyAttribute]
[JsonConverterAttribute("NuGet.Protocol.MetadataFieldConverter")]
public string Tags { get; private set; }
    [JsonPropertyAttribute]
public string Title { get; private set; }
    [JsonPropertyAttribute]
public NuGetVersion Version { get; private set; }
    [JsonPropertyAttribute]
public VersionInfo[] ParsedVersions { get; private set; }
    [JsonPropertyAttribute]
public bool PrefixReserved { get; private set; }
    [JsonPropertyAttribute]
public string LicenseExpression { get; private set; }
    [JsonPropertyAttribute]
public string LicenseExpressionVersion { get; private set; }
    [JsonIgnoreAttribute]
public LicenseMetadata LicenseMetadata { get; }
    [JsonPropertyAttribute]
public bool IsListed { get; private set; }
    [JsonPropertyAttribute]
public PackageDeprecationMetadata DeprecationMetadata { get; private set; }
    [JsonPropertyAttribute]
public IEnumerable`1<PackageVulnerabilityMetadata> Vulnerabilities { get; private set; }
    [CompilerGeneratedAttribute]
public sealed virtual string get_Authors();
    [CompilerGeneratedAttribute]
private void set_Authors(string value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<PackageDependencyGroup> get_DependencySetsInternal();
    [CompilerGeneratedAttribute]
private void set_DependencySetsInternal(IEnumerable`1<PackageDependencyGroup> value);
    public sealed virtual IEnumerable`1<PackageDependencyGroup> get_DependencySets();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Description();
    [CompilerGeneratedAttribute]
private void set_Description(string value);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<long> get_DownloadCount();
    [CompilerGeneratedAttribute]
private void set_DownloadCount(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_IconUrl();
    [CompilerGeneratedAttribute]
private void set_IconUrl(Uri value);
    public sealed virtual PackageIdentity get_Identity();
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_LicenseUrl();
    [CompilerGeneratedAttribute]
private void set_LicenseUrl(Uri value);
    public sealed virtual IReadOnlyList`1<string> get_OwnersList();
    private void set_OwnersList(IReadOnlyList`1<string> value);
    public sealed virtual string get_Owners();
    [CompilerGeneratedAttribute]
public string get_PackageId();
    [CompilerGeneratedAttribute]
private void set_PackageId(string value);
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_ProjectUrl();
    [CompilerGeneratedAttribute]
private void set_ProjectUrl(Uri value);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<DateTimeOffset> get_Published();
    [CompilerGeneratedAttribute]
private void set_Published(Nullable`1<DateTimeOffset> value);
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_ReadmeUrl();
    [CompilerGeneratedAttribute]
private void set_ReadmeUrl(Uri value);
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_ReportAbuseUrl();
    [CompilerGeneratedAttribute]
public void set_ReportAbuseUrl(Uri value);
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_PackageDetailsUrl();
    [CompilerGeneratedAttribute]
public void set_PackageDetailsUrl(Uri value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_RequireLicenseAcceptance();
    [CompilerGeneratedAttribute]
private void set_RequireLicenseAcceptance(bool value);
    public sealed virtual string get_Summary();
    private void set_Summary(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Tags();
    [CompilerGeneratedAttribute]
private void set_Tags(string value);
    public sealed virtual string get_Title();
    private void set_Title(string value);
    [CompilerGeneratedAttribute]
public NuGetVersion get_Version();
    [CompilerGeneratedAttribute]
private void set_Version(NuGetVersion value);
    [CompilerGeneratedAttribute]
public VersionInfo[] get_ParsedVersions();
    [CompilerGeneratedAttribute]
private void set_ParsedVersions(VersionInfo[] value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_PrefixReserved();
    [CompilerGeneratedAttribute]
private void set_PrefixReserved(bool value);
    [CompilerGeneratedAttribute]
public string get_LicenseExpression();
    [CompilerGeneratedAttribute]
private void set_LicenseExpression(string value);
    [CompilerGeneratedAttribute]
public string get_LicenseExpressionVersion();
    [CompilerGeneratedAttribute]
private void set_LicenseExpressionVersion(string value);
    public sealed virtual LicenseMetadata get_LicenseMetadata();
    private static IList`1<string> GetNonStandardLicenseIdentifiers(NuGetLicenseExpression expression);
    public sealed virtual Task`1<IEnumerable`1<VersionInfo>> GetVersionsAsync();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsListed();
    [CompilerGeneratedAttribute]
private void set_IsListed(bool value);
    [CompilerGeneratedAttribute]
public PackageDeprecationMetadata get_DeprecationMetadata();
    [CompilerGeneratedAttribute]
private void set_DeprecationMetadata(PackageDeprecationMetadata value);
    public sealed virtual Task`1<PackageDeprecationMetadata> GetDeprecationMetadataAsync();
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<PackageVulnerabilityMetadata> get_Vulnerabilities();
    [CompilerGeneratedAttribute]
private void set_Vulnerabilities(IEnumerable`1<PackageVulnerabilityMetadata> value);
}
public class NuGet.Protocol.PackageSearchMetadataRegistration : PackageSearchMetadata {
    [CompilerGeneratedAttribute]
private Uri <CatalogUri>k__BackingField;
    [JsonPropertyAttribute]
public Uri CatalogUri { get; private set; }
    [CompilerGeneratedAttribute]
public Uri get_CatalogUri();
    [CompilerGeneratedAttribute]
private void set_CatalogUri(Uri value);
}
public class NuGet.Protocol.PackageSearchMetadataV2Feed : object {
    [CompilerGeneratedAttribute]
private string <Authors>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<PackageDependencyGroup> <DependencySets>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <DownloadCount>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <IconUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <LicenseUrl>k__BackingField;
    private IReadOnlyList`1<string> _ownersList;
    [CompilerGeneratedAttribute]
private string <Owners>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PackageId>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <ProjectUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <Created>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <LastEdited>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <Published>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <ReadmeUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <ReportAbuseUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <PackageDetailsUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RequireLicenseAcceptance>k__BackingField;
    private string _summaryValue;
    [CompilerGeneratedAttribute]
private string <Tags>k__BackingField;
    private string _titleValue;
    [CompilerGeneratedAttribute]
private LicenseMetadata <LicenseMetadata>k__BackingField;
    [CompilerGeneratedAttribute]
private PackageDeprecationMetadata <DeprecationMetadata>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetVersion <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<PackageVulnerabilityMetadata> <Vulnerabilities>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsListed>k__BackingField;
    public string Authors { get; private set; }
    public IEnumerable`1<PackageDependencyGroup> DependencySets { get; private set; }
    public string Description { get; private set; }
    public Nullable`1<long> DownloadCount { get; private set; }
    public Uri IconUrl { get; private set; }
    public PackageIdentity Identity { get; }
    public Uri LicenseUrl { get; private set; }
    public IReadOnlyList`1<string> OwnersList { get; }
    public string Owners { get; private set; }
    public string PackageId { get; private set; }
    public Uri ProjectUrl { get; private set; }
    public bool PrefixReserved { get; }
    public Nullable`1<DateTimeOffset> Created { get; private set; }
    public Nullable`1<DateTimeOffset> LastEdited { get; private set; }
    public Nullable`1<DateTimeOffset> Published { get; private set; }
    public Uri ReadmeUrl { get; }
    public Uri ReportAbuseUrl { get; private set; }
    public Uri PackageDetailsUrl { get; private set; }
    public bool RequireLicenseAcceptance { get; private set; }
    public string Summary { get; private set; }
    public string Tags { get; private set; }
    public string Title { get; private set; }
    public LicenseMetadata LicenseMetadata { get; }
    public PackageDeprecationMetadata DeprecationMetadata { get; }
    public NuGetVersion Version { get; private set; }
    public IEnumerable`1<PackageVulnerabilityMetadata> Vulnerabilities { get; }
    public bool IsListed { get; }
    public PackageSearchMetadataV2Feed(V2FeedPackageInfo package);
    public PackageSearchMetadataV2Feed(V2FeedPackageInfo package, MetadataReferenceCache metadataCache);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Authors();
    [CompilerGeneratedAttribute]
private void set_Authors(string value);
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<PackageDependencyGroup> get_DependencySets();
    [CompilerGeneratedAttribute]
private void set_DependencySets(IEnumerable`1<PackageDependencyGroup> value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Description();
    [CompilerGeneratedAttribute]
private void set_Description(string value);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<long> get_DownloadCount();
    [CompilerGeneratedAttribute]
private void set_DownloadCount(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_IconUrl();
    [CompilerGeneratedAttribute]
private void set_IconUrl(Uri value);
    public sealed virtual PackageIdentity get_Identity();
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_LicenseUrl();
    [CompilerGeneratedAttribute]
private void set_LicenseUrl(Uri value);
    public sealed virtual IReadOnlyList`1<string> get_OwnersList();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Owners();
    [CompilerGeneratedAttribute]
private void set_Owners(string value);
    [CompilerGeneratedAttribute]
public string get_PackageId();
    [CompilerGeneratedAttribute]
private void set_PackageId(string value);
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_ProjectUrl();
    [CompilerGeneratedAttribute]
private void set_ProjectUrl(Uri value);
    public sealed virtual bool get_PrefixReserved();
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_Created();
    [CompilerGeneratedAttribute]
private void set_Created(Nullable`1<DateTimeOffset> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_LastEdited();
    [CompilerGeneratedAttribute]
private void set_LastEdited(Nullable`1<DateTimeOffset> value);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<DateTimeOffset> get_Published();
    [CompilerGeneratedAttribute]
private void set_Published(Nullable`1<DateTimeOffset> value);
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_ReadmeUrl();
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_ReportAbuseUrl();
    [CompilerGeneratedAttribute]
private void set_ReportAbuseUrl(Uri value);
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_PackageDetailsUrl();
    [CompilerGeneratedAttribute]
private void set_PackageDetailsUrl(Uri value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_RequireLicenseAcceptance();
    [CompilerGeneratedAttribute]
private void set_RequireLicenseAcceptance(bool value);
    public sealed virtual string get_Summary();
    private void set_Summary(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Tags();
    [CompilerGeneratedAttribute]
private void set_Tags(string value);
    public sealed virtual string get_Title();
    private void set_Title(string value);
    [CompilerGeneratedAttribute]
public sealed virtual LicenseMetadata get_LicenseMetadata();
    [CompilerGeneratedAttribute]
public PackageDeprecationMetadata get_DeprecationMetadata();
    [CompilerGeneratedAttribute]
public NuGetVersion get_Version();
    [CompilerGeneratedAttribute]
private void set_Version(NuGetVersion value);
    public sealed virtual Task`1<IEnumerable`1<VersionInfo>> GetVersionsAsync();
    private static Uri GetUriSafe(string url);
    public sealed virtual Task`1<PackageDeprecationMetadata> GetDeprecationMetadataAsync();
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<PackageVulnerabilityMetadata> get_Vulnerabilities();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsListed();
}
public class NuGet.Protocol.PackageSearchResourceV2Feed : PackageSearchResource {
    private HttpSource _httpSource;
    private PackageSource _packageSource;
    private V2FeedParser _feedParser;
    public PackageSearchResourceV2Feed(HttpSourceResource httpSourceResource, string baseAddress, PackageSource packageSource);
    [AsyncStateMachineAttribute("NuGet.Protocol.PackageSearchResourceV2Feed/<SearchAsync>d__4")]
public virtual Task`1<IEnumerable`1<IPackageSearchMetadata>> SearchAsync(string searchTerm, SearchFilter filters, int skip, int take, ILogger log, CancellationToken cancellationToken);
}
public class NuGet.Protocol.PackageSearchResourceV2FeedProvider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.PackageSearchResourceV2FeedProvider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
public class NuGet.Protocol.PackageSearchResourceV3 : PackageSearchResource {
    private HttpSource _client;
    private Uri[] _searchEndpoints;
    private RawSearchResourceV3 _rawSearchResource;
    [ObsoleteAttribute("Use PackageSearchResource instead (via SourceRepository.GetResourceAsync<PackageSearchResource>")]
public PackageSearchResourceV3(RawSearchResourceV3 searchResource);
    internal PackageSearchResourceV3(HttpSource client, IEnumerable`1<Uri> searchEndpoints);
    [AsyncStateMachineAttribute("NuGet.Protocol.PackageSearchResourceV3/<SearchAsync>d__5")]
public virtual Task`1<IEnumerable`1<IPackageSearchMetadata>> SearchAsync(string searchTerm, SearchFilter filter, int skip, int take, ILogger log, CancellationToken cancellationToken);
    private static IEnumerable`1<VersionInfo> GetVersions(PackageSearchMetadata metadata, SearchFilter filter);
    [AsyncStateMachineAttribute("NuGet.Protocol.PackageSearchResourceV3/<SearchPage>d__7`1")]
private Task`1<T> SearchPage(Func`2<Uri, Task`1<T>> getResultAsync, string searchTerm, SearchFilter filters, int skip, int take, ILogger log, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.PackageSearchResourceV3/<Search>d__8`1")]
private Task`1<T> Search(Func`3<HttpSource, Uri, Task`1<T>> getResultAsync, string searchTerm, SearchFilter filters, int skip, int take, ILogger log, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.PackageSearchResourceV3/<Search>d__9")]
internal Task`1<IEnumerable`1<PackageSearchMetadata>> Search(string searchTerm, SearchFilter filters, int skip, int take, ILogger log, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.PackageSearchResourceV3/<ProcessHttpStreamTakeCountedItemAsync>d__10")]
internal Task`1<IEnumerable`1<PackageSearchMetadata>> ProcessHttpStreamTakeCountedItemAsync(HttpResponseMessage httpInitialResponse, int take, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.PackageSearchResourceV3/<ProcessHttpStreamWithoutBufferingAsync>d__11")]
private Task`1<V3SearchResults> ProcessHttpStreamWithoutBufferingAsync(HttpResponseMessage httpInitialResponse, UInt32 take, CancellationToken token);
}
public class NuGet.Protocol.PackageSearchResourceV3Provider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.PackageSearchResourceV3Provider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
public class NuGet.Protocol.PackageUpdateResourceV2Provider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.PackageUpdateResourceV2Provider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
public class NuGet.Protocol.PackageUpdateResourceV3Provider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.PackageUpdateResourceV3Provider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
internal static class NuGet.Protocol.PackageUtilities : object {
    internal static NuspecReader OpenNuspecFromNupkg(string id, Stream nupkgStream, ILogger log);
}
public class NuGet.Protocol.PackageVulnerabilityMetadata : object {
    [CompilerGeneratedAttribute]
private Uri <AdvisoryUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Severity>k__BackingField;
    [JsonPropertyAttribute]
public Uri AdvisoryUrl { get; internal set; }
    [JsonPropertyAttribute]
public int Severity { get; internal set; }
    [CompilerGeneratedAttribute]
public Uri get_AdvisoryUrl();
    [CompilerGeneratedAttribute]
internal void set_AdvisoryUrl(Uri value);
    [CompilerGeneratedAttribute]
public int get_Severity();
    [CompilerGeneratedAttribute]
internal void set_Severity(int value);
}
public enum NuGet.Protocol.PackageVulnerabilitySeverity : Enum {
    public int value__;
    public static PackageVulnerabilitySeverity Low;
    public static PackageVulnerabilitySeverity Moderate;
    public static PackageVulnerabilitySeverity High;
    public static PackageVulnerabilitySeverity Critical;
    public static PackageVulnerabilitySeverity Unknown;
}
public class NuGet.Protocol.PluginFindPackageByIdResourceProvider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.PluginFindPackageByIdResourceProvider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken cancellationToken);
    private static void AddOrUpdateGetCredentialsRequestHandler(IPlugin plugin, SourceRepository source, HttpHandlerResource httpHandlerResource);
    private static void AddOrUpdateGetServiceIndexRequestHandler(IPlugin plugin, SourceRepository source);
}
public class NuGet.Protocol.Plugins.AssemblyLogMessage : PluginLogMessage {
    private string _fileVersion;
    private string _fullName;
    private string _informationalVersion;
    private string _entryAssemblyFullName;
    public AssemblyLogMessage(DateTimeOffset now);
    public virtual string ToString();
}
public class NuGet.Protocol.Plugins.AutomaticProgressReporter : object {
    private CancellationToken _cancellationToken;
    private CancellationTokenSource _cancellationTokenSource;
    private IConnection _connection;
    private bool _isDisposed;
    private Message _request;
    private SemaphoreSlim _semaphore;
    private Timer _timer;
    private AutomaticProgressReporter(IConnection connection, Message request, TimeSpan interval, CancellationToken cancellationToken);
    public sealed virtual void Dispose();
    public static AutomaticProgressReporter Create(IConnection connection, Message request, TimeSpan interval, CancellationToken cancellationToken);
    private void OnTimer(object state);
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.AutomaticProgressReporter/<<OnTimer>b__10_0>d")]
[CompilerGeneratedAttribute]
private Task <OnTimer>b__10_0();
}
public class NuGet.Protocol.Plugins.CloseRequestHandler : object {
    private bool _isDisposed;
    private IPlugin _plugin;
    public CancellationToken CancellationToken { get; }
    public CloseRequestHandler(IPlugin plugin);
    public sealed virtual CancellationToken get_CancellationToken();
    public sealed virtual void Dispose();
    public sealed virtual Task HandleResponseAsync(IConnection connection, Message request, IResponseHandler responseHandler, CancellationToken cancellationToken);
}
internal class NuGet.Protocol.Plugins.CommunicationLogMessage : PluginLogMessage {
    private MessageMethod _method;
    private string _requestId;
    private MessageState _state;
    private MessageType _type;
    internal CommunicationLogMessage(DateTimeOffset now, string requestId, MessageMethod method, MessageType type, MessageState state);
    public virtual string ToString();
}
public class NuGet.Protocol.Plugins.Connection : object {
    private bool _isDisposed;
    private IReceiver _receiver;
    private ISender _sender;
    private IPluginLogger _logger;
    private int _state;
    [CompilerGeneratedAttribute]
private EventHandler`1<ProtocolErrorEventArgs> Faulted;
    [CompilerGeneratedAttribute]
private EventHandler`1<MessageEventArgs> MessageReceived;
    [CompilerGeneratedAttribute]
private IMessageDispatcher <MessageDispatcher>k__BackingField;
    [CompilerGeneratedAttribute]
private ConnectionOptions <Options>k__BackingField;
    [CompilerGeneratedAttribute]
private SemanticVersion <ProtocolVersion>k__BackingField;
    public ConnectionState State { get; }
    public IMessageDispatcher MessageDispatcher { get; }
    public ConnectionOptions Options { get; }
    public SemanticVersion ProtocolVersion { get; private set; }
    public Connection(IMessageDispatcher dispatcher, ISender sender, IReceiver receiver, ConnectionOptions options);
    internal Connection(IMessageDispatcher dispatcher, ISender sender, IReceiver receiver, ConnectionOptions options, IPluginLogger logger);
    public ConnectionState get_State();
    [CompilerGeneratedAttribute]
public sealed virtual void add_Faulted(EventHandler`1<ProtocolErrorEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Faulted(EventHandler`1<ProtocolErrorEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_MessageReceived(EventHandler`1<MessageEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_MessageReceived(EventHandler`1<MessageEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual IMessageDispatcher get_MessageDispatcher();
    [CompilerGeneratedAttribute]
public sealed virtual ConnectionOptions get_Options();
    [CompilerGeneratedAttribute]
public sealed virtual SemanticVersion get_ProtocolVersion();
    [CompilerGeneratedAttribute]
private void set_ProtocolVersion(SemanticVersion value);
    public sealed virtual void Dispose();
    public sealed virtual void Close();
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.Connection/<ConnectAsync>d__27")]
public Task ConnectAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.Connection/<SendAsync>d__28")]
public sealed virtual Task SendAsync(Message message, CancellationToken cancellationToken);
    public sealed virtual Task`1<TInbound> SendRequestAndReceiveResponseAsync(MessageMethod method, TOutbound payload, CancellationToken cancellationToken);
    private void OnMessageReceived(object sender, MessageEventArgs e);
    private void OnFaulted(object sender, ProtocolErrorEventArgs e);
}
public class NuGet.Protocol.Plugins.ConnectionOptions : object {
    [CompilerGeneratedAttribute]
private TimeSpan <HandshakeTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private SemanticVersion <MinimumProtocolVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private SemanticVersion <ProtocolVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <RequestTimeout>k__BackingField;
    public TimeSpan HandshakeTimeout { get; }
    public SemanticVersion MinimumProtocolVersion { get; }
    public SemanticVersion ProtocolVersion { get; }
    public TimeSpan RequestTimeout { get; private set; }
    public ConnectionOptions(SemanticVersion protocolVersion, SemanticVersion minimumProtocolVersion, TimeSpan handshakeTimeout, TimeSpan requestTimeout);
    [CompilerGeneratedAttribute]
public TimeSpan get_HandshakeTimeout();
    [CompilerGeneratedAttribute]
public SemanticVersion get_MinimumProtocolVersion();
    [CompilerGeneratedAttribute]
public SemanticVersion get_ProtocolVersion();
    [CompilerGeneratedAttribute]
public TimeSpan get_RequestTimeout();
    [CompilerGeneratedAttribute]
private void set_RequestTimeout(TimeSpan value);
    public void SetRequestTimeout(TimeSpan requestTimeout);
    public static ConnectionOptions CreateDefault(IEnvironmentVariableReader reader);
}
public enum NuGet.Protocol.Plugins.ConnectionState : Enum {
    public int value__;
    public static ConnectionState FailedToHandshake;
    public static ConnectionState Closing;
    public static ConnectionState Closed;
    public static ConnectionState ReadyToConnect;
    public static ConnectionState Connecting;
    public static ConnectionState Handshaking;
    public static ConnectionState Connected;
}
public class NuGet.Protocol.Plugins.CopyFilesInPackageRequest : object {
    [CompilerGeneratedAttribute]
private string <DestinationFolderPath>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <FilesInPackage>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PackageId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PackageSourceRepository>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PackageVersion>k__BackingField;
    [JsonRequiredAttribute]
public string DestinationFolderPath { get; }
    [JsonRequiredAttribute]
public IEnumerable`1<string> FilesInPackage { get; }
    [JsonRequiredAttribute]
public string PackageId { get; }
    [JsonRequiredAttribute]
public string PackageSourceRepository { get; }
    [JsonRequiredAttribute]
public string PackageVersion { get; }
    [JsonConstructorAttribute]
public CopyFilesInPackageRequest(string packageSourceRepository, string packageId, string packageVersion, IEnumerable`1<string> filesInPackage, string destinationFolderPath);
    [CompilerGeneratedAttribute]
public string get_DestinationFolderPath();
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_FilesInPackage();
    [CompilerGeneratedAttribute]
public string get_PackageId();
    [CompilerGeneratedAttribute]
public string get_PackageSourceRepository();
    [CompilerGeneratedAttribute]
public string get_PackageVersion();
}
public class NuGet.Protocol.Plugins.CopyFilesInPackageResponse : object {
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <CopiedFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private MessageResponseCode <ResponseCode>k__BackingField;
    public IEnumerable`1<string> CopiedFiles { get; }
    [JsonRequiredAttribute]
public MessageResponseCode ResponseCode { get; }
    [JsonConstructorAttribute]
public CopyFilesInPackageResponse(MessageResponseCode responseCode, IEnumerable`1<string> copiedFiles);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_CopiedFiles();
    [CompilerGeneratedAttribute]
public MessageResponseCode get_ResponseCode();
}
public class NuGet.Protocol.Plugins.CopyNupkgFileRequest : object {
    [CompilerGeneratedAttribute]
private string <DestinationFilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PackageId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PackageSourceRepository>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PackageVersion>k__BackingField;
    [JsonRequiredAttribute]
public string DestinationFilePath { get; }
    [JsonRequiredAttribute]
public string PackageId { get; }
    [JsonRequiredAttribute]
public string PackageSourceRepository { get; }
    [JsonRequiredAttribute]
public string PackageVersion { get; }
    [JsonConstructorAttribute]
public CopyNupkgFileRequest(string packageSourceRepository, string packageId, string packageVersion, string destinationFilePath);
    [CompilerGeneratedAttribute]
public string get_DestinationFilePath();
    [CompilerGeneratedAttribute]
public string get_PackageId();
    [CompilerGeneratedAttribute]
public string get_PackageSourceRepository();
    [CompilerGeneratedAttribute]
public string get_PackageVersion();
}
public class NuGet.Protocol.Plugins.CopyNupkgFileResponse : object {
    [CompilerGeneratedAttribute]
private MessageResponseCode <ResponseCode>k__BackingField;
    [JsonRequiredAttribute]
public MessageResponseCode ResponseCode { get; }
    [JsonConstructorAttribute]
public CopyNupkgFileResponse(MessageResponseCode responseCode);
    [CompilerGeneratedAttribute]
public MessageResponseCode get_ResponseCode();
}
public abstract class NuGet.Protocol.Plugins.EmbeddedSignatureVerifier : object {
    public abstract virtual bool IsValid(string filePath);
    public static EmbeddedSignatureVerifier Create();
}
internal static class NuGet.Protocol.Plugins.EnvironmentVariableConstants : object {
    internal static string EnableLog;
    internal static string LogDirectoryPath;
    internal static string HandshakeTimeout;
    internal static string IdleTimeout;
    internal static string PluginPaths;
    internal static string RequestTimeout;
    internal static string DesktopPluginPaths;
    internal static string CorePluginPaths;
}
public class NuGet.Protocol.Plugins.EnvironmentVariablesLogMessage : PluginLogMessage {
    private Nullable`1<int> _handshakeTimeout;
    private Nullable`1<int> _idleTimeout;
    private Nullable`1<int> _requestTimeout;
    public EnvironmentVariablesLogMessage(DateTimeOffset now, IEnvironmentVariableReader environmentVariableReader);
    public virtual string ToString();
    private static Nullable`1<int> Read(IEnvironmentVariableReader reader, string variableName);
}
public class NuGet.Protocol.Plugins.FallbackEmbeddedSignatureVerifier : EmbeddedSignatureVerifier {
    public virtual bool IsValid(string filePath);
}
public class NuGet.Protocol.Plugins.Fault : object {
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [JsonRequiredAttribute]
public string Message { get; }
    [JsonConstructorAttribute]
public Fault(string message);
    [CompilerGeneratedAttribute]
public string get_Message();
}
public class NuGet.Protocol.Plugins.FaultedPluginEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    [CompilerGeneratedAttribute]
private IPlugin <Plugin>k__BackingField;
    public Exception Exception { get; }
    public IPlugin Plugin { get; }
    public FaultedPluginEventArgs(IPlugin plugin, Exception exception);
    [CompilerGeneratedAttribute]
public Exception get_Exception();
    [CompilerGeneratedAttribute]
public IPlugin get_Plugin();
}
public class NuGet.Protocol.Plugins.GetAuthenticationCredentialsRequest : object {
    [CompilerGeneratedAttribute]
private Uri <Uri>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRetry>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsNonInteractive>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanShowDialog>k__BackingField;
    [JsonRequiredAttribute]
public Uri Uri { get; }
    [JsonRequiredAttribute]
public bool IsRetry { get; }
    [JsonRequiredAttribute]
public bool IsNonInteractive { get; }
    [JsonRequiredAttribute]
public bool CanShowDialog { get; }
    [JsonConstructorAttribute]
public GetAuthenticationCredentialsRequest(Uri uri, bool isRetry, bool isNonInteractive, bool canShowDialog);
    [CompilerGeneratedAttribute]
public Uri get_Uri();
    [CompilerGeneratedAttribute]
public bool get_IsRetry();
    [CompilerGeneratedAttribute]
public bool get_IsNonInteractive();
    [CompilerGeneratedAttribute]
public bool get_CanShowDialog();
}
public class NuGet.Protocol.Plugins.GetAuthenticationCredentialsResponse : object {
    [CompilerGeneratedAttribute]
private string <Username>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Password>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<string> <AuthenticationTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private MessageResponseCode <ResponseCode>k__BackingField;
    public string Username { get; }
    public string Password { get; }
    public string Message { get; }
    public IList`1<string> AuthenticationTypes { get; }
    [JsonRequiredAttribute]
public MessageResponseCode ResponseCode { get; }
    [JsonConstructorAttribute]
public GetAuthenticationCredentialsResponse(string username, string password, string message, IList`1<string> authenticationTypes, MessageResponseCode responseCode);
    [CompilerGeneratedAttribute]
public string get_Username();
    [CompilerGeneratedAttribute]
public string get_Password();
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public IList`1<string> get_AuthenticationTypes();
    [CompilerGeneratedAttribute]
public MessageResponseCode get_ResponseCode();
    public bool IsValid();
}
public class NuGet.Protocol.Plugins.GetCredentialsRequest : object {
    [CompilerGeneratedAttribute]
private string <PackageSourceRepository>k__BackingField;
    [CompilerGeneratedAttribute]
private HttpStatusCode <StatusCode>k__BackingField;
    [JsonRequiredAttribute]
public string PackageSourceRepository { get; }
    [JsonRequiredAttribute]
public HttpStatusCode StatusCode { get; }
    [JsonConstructorAttribute]
public GetCredentialsRequest(string packageSourceRepository, HttpStatusCode statusCode);
    [CompilerGeneratedAttribute]
public string get_PackageSourceRepository();
    [CompilerGeneratedAttribute]
public HttpStatusCode get_StatusCode();
}
public class NuGet.Protocol.Plugins.GetCredentialsRequestHandler : object {
    private static string _basicAuthenticationType;
    private ICredentialService _credentialService;
    private bool _isDisposed;
    private IPlugin _plugin;
    private IWebProxy _proxy;
    private ConcurrentDictionary`2<string, SourceRepository> _repositories;
    public CancellationToken CancellationToken { get; }
    public GetCredentialsRequestHandler(IPlugin plugin, IWebProxy proxy, ICredentialService credentialService);
    public sealed virtual CancellationToken get_CancellationToken();
    public sealed virtual void Dispose();
    public void AddOrUpdateSourceRepository(SourceRepository sourceRepository);
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.GetCredentialsRequestHandler/<HandleResponseAsync>d__11")]
public sealed virtual Task HandleResponseAsync(IConnection connection, Message request, IResponseHandler responseHandler, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.GetCredentialsRequestHandler/<GetCredentialAsync>d__12")]
private Task`1<ICredentials> GetCredentialAsync(PackageSource packageSource, HttpStatusCode statusCode, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.GetCredentialsRequestHandler/<GetPackageSourceCredential>d__13")]
private Task`1<ICredentials> GetPackageSourceCredential(CredentialRequestType requestType, PackageSource packageSource, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.GetCredentialsRequestHandler/<GetProxyCredentialAsync>d__14")]
private Task`1<ICredentials> GetProxyCredentialAsync(PackageSource packageSource, CancellationToken cancellationToken);
    private static CredentialRequestType GetCredentialRequestType(HttpStatusCode statusCode);
    private PackageSource GetPackageSource(string packageSourceRepository);
}
public class NuGet.Protocol.Plugins.GetCredentialsResponse : object {
    [CompilerGeneratedAttribute]
private string <Password>k__BackingField;
    [CompilerGeneratedAttribute]
private MessageResponseCode <ResponseCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Username>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <AuthenticationTypes>k__BackingField;
    public string Password { get; }
    [JsonRequiredAttribute]
public MessageResponseCode ResponseCode { get; }
    public string Username { get; }
    public IReadOnlyList`1<string> AuthenticationTypes { get; }
    [JsonConstructorAttribute]
public GetCredentialsResponse(MessageResponseCode responseCode, string username, string password, IReadOnlyList`1<string> authenticationTypes);
    [CompilerGeneratedAttribute]
public string get_Password();
    [CompilerGeneratedAttribute]
public MessageResponseCode get_ResponseCode();
    [CompilerGeneratedAttribute]
public string get_Username();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_AuthenticationTypes();
}
public class NuGet.Protocol.Plugins.GetFilesInPackageRequest : object {
    [CompilerGeneratedAttribute]
private string <PackageId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PackageSourceRepository>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PackageVersion>k__BackingField;
    [JsonRequiredAttribute]
public string PackageId { get; }
    [JsonRequiredAttribute]
public string PackageSourceRepository { get; }
    [JsonRequiredAttribute]
public string PackageVersion { get; }
    [JsonConstructorAttribute]
public GetFilesInPackageRequest(string packageSourceRepository, string packageId, string packageVersion);
    [CompilerGeneratedAttribute]
public string get_PackageId();
    [CompilerGeneratedAttribute]
public string get_PackageSourceRepository();
    [CompilerGeneratedAttribute]
public string get_PackageVersion();
}
public class NuGet.Protocol.Plugins.GetFilesInPackageResponse : object {
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <Files>k__BackingField;
    [CompilerGeneratedAttribute]
private MessageResponseCode <ResponseCode>k__BackingField;
    public IEnumerable`1<string> Files { get; }
    [JsonRequiredAttribute]
public MessageResponseCode ResponseCode { get; }
    [JsonConstructorAttribute]
public GetFilesInPackageResponse(MessageResponseCode responseCode, IEnumerable`1<string> files);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_Files();
    [CompilerGeneratedAttribute]
public MessageResponseCode get_ResponseCode();
}
public class NuGet.Protocol.Plugins.GetOperationClaimsRequest : object {
    [CompilerGeneratedAttribute]
private string <PackageSourceRepository>k__BackingField;
    [CompilerGeneratedAttribute]
private JObject <ServiceIndex>k__BackingField;
    public string PackageSourceRepository { get; }
    public JObject ServiceIndex { get; }
    [JsonConstructorAttribute]
public GetOperationClaimsRequest(string packageSourceRepository, JObject serviceIndex);
    [CompilerGeneratedAttribute]
public string get_PackageSourceRepository();
    [CompilerGeneratedAttribute]
public JObject get_ServiceIndex();
}
public class NuGet.Protocol.Plugins.GetOperationClaimsResponse : object {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<OperationClaim> <Claims>k__BackingField;
    [JsonRequiredAttribute]
public IReadOnlyList`1<OperationClaim> Claims { get; }
    [JsonConstructorAttribute]
public GetOperationClaimsResponse(IEnumerable`1<OperationClaim> claims);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<OperationClaim> get_Claims();
}
public class NuGet.Protocol.Plugins.GetPackageHashRequest : object {
    [CompilerGeneratedAttribute]
private string <HashAlgorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PackageId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PackageSourceRepository>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PackageVersion>k__BackingField;
    [JsonRequiredAttribute]
public string HashAlgorithm { get; }
    [JsonRequiredAttribute]
public string PackageId { get; }
    [JsonRequiredAttribute]
public string PackageSourceRepository { get; }
    [JsonRequiredAttribute]
public string PackageVersion { get; }
    [JsonConstructorAttribute]
public GetPackageHashRequest(string packageSourceRepository, string packageId, string packageVersion, string hashAlgorithm);
    [CompilerGeneratedAttribute]
public string get_HashAlgorithm();
    [CompilerGeneratedAttribute]
public string get_PackageId();
    [CompilerGeneratedAttribute]
public string get_PackageSourceRepository();
    [CompilerGeneratedAttribute]
public string get_PackageVersion();
}
public class NuGet.Protocol.Plugins.GetPackageHashResponse : object {
    [CompilerGeneratedAttribute]
private string <Hash>k__BackingField;
    [CompilerGeneratedAttribute]
private MessageResponseCode <ResponseCode>k__BackingField;
    public string Hash { get; }
    [JsonRequiredAttribute]
public MessageResponseCode ResponseCode { get; }
    [JsonConstructorAttribute]
public GetPackageHashResponse(MessageResponseCode responseCode, string hash);
    [CompilerGeneratedAttribute]
public string get_Hash();
    [CompilerGeneratedAttribute]
public MessageResponseCode get_ResponseCode();
}
public class NuGet.Protocol.Plugins.GetPackageVersionsRequest : object {
    [CompilerGeneratedAttribute]
private string <PackageId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PackageSourceRepository>k__BackingField;
    [JsonRequiredAttribute]
public string PackageId { get; }
    [JsonRequiredAttribute]
public string PackageSourceRepository { get; }
    [JsonConstructorAttribute]
public GetPackageVersionsRequest(string packageSourceRepository, string packageId);
    [CompilerGeneratedAttribute]
public string get_PackageId();
    [CompilerGeneratedAttribute]
public string get_PackageSourceRepository();
}
public class NuGet.Protocol.Plugins.GetPackageVersionsResponse : object {
    [CompilerGeneratedAttribute]
private MessageResponseCode <ResponseCode>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <Versions>k__BackingField;
    [JsonRequiredAttribute]
public MessageResponseCode ResponseCode { get; }
    public IEnumerable`1<string> Versions { get; }
    [JsonConstructorAttribute]
public GetPackageVersionsResponse(MessageResponseCode responseCode, IEnumerable`1<string> versions);
    [CompilerGeneratedAttribute]
public MessageResponseCode get_ResponseCode();
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_Versions();
}
public class NuGet.Protocol.Plugins.GetServiceIndexRequest : object {
    [CompilerGeneratedAttribute]
private string <PackageSourceRepository>k__BackingField;
    [JsonRequiredAttribute]
public string PackageSourceRepository { get; }
    [JsonConstructorAttribute]
public GetServiceIndexRequest(string packageSourceRepository);
    [CompilerGeneratedAttribute]
public string get_PackageSourceRepository();
}
public class NuGet.Protocol.Plugins.GetServiceIndexRequestHandler : object {
    private bool _isDisposed;
    private IPlugin _plugin;
    private ConcurrentDictionary`2<string, SourceRepository> _repositories;
    public CancellationToken CancellationToken { get; }
    public GetServiceIndexRequestHandler(IPlugin plugin);
    public sealed virtual CancellationToken get_CancellationToken();
    public sealed virtual void Dispose();
    public void AddOrUpdateSourceRepository(SourceRepository sourceRepository);
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.GetServiceIndexRequestHandler/<HandleResponseAsync>d__8")]
public sealed virtual Task HandleResponseAsync(IConnection connection, Message request, IResponseHandler responseHandler, CancellationToken cancellationToken);
}
public class NuGet.Protocol.Plugins.GetServiceIndexResponse : object {
    [CompilerGeneratedAttribute]
private MessageResponseCode <ResponseCode>k__BackingField;
    [CompilerGeneratedAttribute]
private JObject <ServiceIndex>k__BackingField;
    [JsonRequiredAttribute]
public MessageResponseCode ResponseCode { get; }
    public JObject ServiceIndex { get; }
    [JsonConstructorAttribute]
public GetServiceIndexResponse(MessageResponseCode responseCode, JObject serviceIndex);
    [CompilerGeneratedAttribute]
public MessageResponseCode get_ResponseCode();
    [CompilerGeneratedAttribute]
public JObject get_ServiceIndex();
}
public class NuGet.Protocol.Plugins.HandshakeRequest : object {
    [CompilerGeneratedAttribute]
private SemanticVersion <ProtocolVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private SemanticVersion <MinimumProtocolVersion>k__BackingField;
    [JsonRequiredAttribute]
public SemanticVersion ProtocolVersion { get; }
    [JsonRequiredAttribute]
public SemanticVersion MinimumProtocolVersion { get; }
    [JsonConstructorAttribute]
public HandshakeRequest(SemanticVersion protocolVersion, SemanticVersion minimumProtocolVersion);
    [CompilerGeneratedAttribute]
public SemanticVersion get_ProtocolVersion();
    [CompilerGeneratedAttribute]
public SemanticVersion get_MinimumProtocolVersion();
}
public class NuGet.Protocol.Plugins.HandshakeResponse : object {
    [CompilerGeneratedAttribute]
private MessageResponseCode <ResponseCode>k__BackingField;
    [CompilerGeneratedAttribute]
private SemanticVersion <ProtocolVersion>k__BackingField;
    [JsonRequiredAttribute]
public MessageResponseCode ResponseCode { get; }
    public SemanticVersion ProtocolVersion { get; }
    [JsonConstructorAttribute]
public HandshakeResponse(MessageResponseCode responseCode, SemanticVersion protocolVersion);
    [CompilerGeneratedAttribute]
public MessageResponseCode get_ResponseCode();
    [CompilerGeneratedAttribute]
public SemanticVersion get_ProtocolVersion();
}
public interface NuGet.Protocol.Plugins.IConnection {
    public IMessageDispatcher MessageDispatcher { get; }
    public ConnectionOptions Options { get; }
    public SemanticVersion ProtocolVersion { get; }
    [CompilerGeneratedAttribute]
public abstract virtual void add_Faulted(EventHandler`1<ProtocolErrorEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Faulted(EventHandler`1<ProtocolErrorEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_MessageReceived(EventHandler`1<MessageEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_MessageReceived(EventHandler`1<MessageEventArgs> value);
    public abstract virtual IMessageDispatcher get_MessageDispatcher();
    public abstract virtual ConnectionOptions get_Options();
    public abstract virtual SemanticVersion get_ProtocolVersion();
    public abstract virtual void Close();
    public abstract virtual Task SendAsync(Message message, CancellationToken cancellationToken);
    public abstract virtual Task`1<TInbound> SendRequestAndReceiveResponseAsync(MessageMethod method, TOutbound payload, CancellationToken cancellationToken);
}
public interface NuGet.Protocol.Plugins.IIdGenerator {
    public abstract virtual string GenerateUniqueId();
}
public interface NuGet.Protocol.Plugins.IMessageDispatcher {
    public IRequestHandlers RequestHandlers { get; }
    public abstract virtual IRequestHandlers get_RequestHandlers();
    public abstract virtual void Close();
    public abstract virtual Message CreateMessage(MessageType type, MessageMethod method);
    public abstract virtual Message CreateMessage(MessageType type, MessageMethod method, TPayload payload);
    public abstract virtual Task DispatchCancelAsync(Message request, CancellationToken cancellationToken);
    public abstract virtual Task DispatchFaultAsync(Message request, Fault fault, CancellationToken cancellationToken);
    public abstract virtual Task DispatchProgressAsync(Message request, Progress progress, CancellationToken cancellationToken);
    public abstract virtual Task`1<TInbound> DispatchRequestAsync(MessageMethod method, TOutbound payload, CancellationToken cancellationToken);
    public abstract virtual Task DispatchResponseAsync(Message request, TOutbound responsePayload, CancellationToken cancellationToken);
    public abstract virtual void SetConnection(IConnection connection);
}
public class NuGet.Protocol.Plugins.InboundRequestContext : object {
    private CancellationToken _cancellationToken;
    private CancellationTokenSource _cancellationTokenSource;
    private IConnection _connection;
    private bool _isDisposed;
    private IPluginLogger _logger;
    private InboundRequestProcessingHandler _inboundRequestProcessingHandler;
    [CompilerGeneratedAttribute]
private string <RequestId>k__BackingField;
    public string RequestId { get; }
    public InboundRequestContext(IConnection connection, string requestId, CancellationToken cancellationToken);
    internal InboundRequestContext(IConnection connection, string requestId, CancellationToken cancellationToken, InboundRequestProcessingHandler inboundRequestProcessingHandler, IPluginLogger logger);
    [CompilerGeneratedAttribute]
public string get_RequestId();
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.InboundRequestContext/<ProcessResponseAsync>d__11")]
private Task ProcessResponseAsync(IRequestHandler requestHandler, Message request, IResponseHandler responseHandler);
    public sealed virtual void Dispose();
    public void BeginFaultAsync(Message request, Exception exception);
    public void BeginResponseAsync(Message request, IRequestHandler requestHandler, IResponseHandler responseHandler);
    public void Cancel();
}
internal class NuGet.Protocol.Plugins.InboundRequestProcessingHandler : object {
    private ISet`1<MessageMethod> _fastProccessingMethods;
    private Lazy`1<DedicatedAsynchronousProcessingThread> _processingThread;
    private bool _isDisposed;
    public InboundRequestProcessingHandler(IEnumerable`1<MessageMethod> fastProcessingMethods);
    internal void Handle(MessageMethod messageMethod, Func`1<Task> task, CancellationToken cancellationToken);
    public sealed virtual void Dispose();
    private void ThrowIfDisposed();
}
public class NuGet.Protocol.Plugins.InitializeRequest : object {
    [CompilerGeneratedAttribute]
private string <ClientVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Culture>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <RequestTimeout>k__BackingField;
    [JsonRequiredAttribute]
public string ClientVersion { get; }
    [JsonRequiredAttribute]
public string Culture { get; }
    [JsonRequiredAttribute]
public TimeSpan RequestTimeout { get; }
    [JsonConstructorAttribute]
public InitializeRequest(string clientVersion, string culture, TimeSpan requestTimeout);
    [CompilerGeneratedAttribute]
public string get_ClientVersion();
    [CompilerGeneratedAttribute]
public string get_Culture();
    [CompilerGeneratedAttribute]
public TimeSpan get_RequestTimeout();
}
public class NuGet.Protocol.Plugins.InitializeResponse : object {
    [CompilerGeneratedAttribute]
private MessageResponseCode <ResponseCode>k__BackingField;
    [JsonRequiredAttribute]
public MessageResponseCode ResponseCode { get; }
    [JsonConstructorAttribute]
public InitializeResponse(MessageResponseCode responseCode);
    [CompilerGeneratedAttribute]
public MessageResponseCode get_ResponseCode();
}
public interface NuGet.Protocol.Plugins.IPlugin {
    public IConnection Connection { get; }
    public string FilePath { get; }
    public string Id { get; }
    public string Name { get; }
    [CompilerGeneratedAttribute]
public abstract virtual void add_BeforeClose(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_BeforeClose(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_Closed(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Closed(EventHandler value);
    public abstract virtual IConnection get_Connection();
    public abstract virtual string get_FilePath();
    public abstract virtual string get_Id();
    public abstract virtual string get_Name();
    public abstract virtual void Close();
}
public interface NuGet.Protocol.Plugins.IPluginDiscoverer {
    public abstract virtual Task`1<IEnumerable`1<PluginDiscoveryResult>> DiscoverAsync(CancellationToken cancellationToken);
}
public interface NuGet.Protocol.Plugins.IPluginFactory {
    public abstract virtual Task`1<IPlugin> GetOrCreateAsync(string filePath, IEnumerable`1<string> arguments, IRequestHandlers requestHandlers, ConnectionOptions options, CancellationToken sessionCancellationToken);
}
public interface NuGet.Protocol.Plugins.IPluginLogger {
    public bool IsEnabled { get; }
    public DateTimeOffset Now { get; }
    public abstract virtual bool get_IsEnabled();
    public abstract virtual DateTimeOffset get_Now();
    public abstract virtual void Write(IPluginLogMessage message);
}
public interface NuGet.Protocol.Plugins.IPluginLogMessage {
}
public interface NuGet.Protocol.Plugins.IPluginManager {
    public abstract virtual Task`1<IEnumerable`1<PluginCreationResult>> CreatePluginsAsync(SourceRepository source, CancellationToken cancellationToken);
    public abstract virtual Task`1<IEnumerable`1<PluginDiscoveryResult>> FindAvailablePluginsAsync(CancellationToken cancellationToken);
    public abstract virtual Task`1<Tuple`2<bool, PluginCreationResult>> TryGetSourceAgnosticPluginAsync(PluginDiscoveryResult pluginDiscoveryResult, OperationClaim requestedOperationClaim, CancellationToken cancellationToken);
}
public interface NuGet.Protocol.Plugins.IPluginMulticlientUtilities {
    public abstract virtual Task DoOncePerPluginLifetimeAsync(string key, Func`1<Task> taskFunc, CancellationToken cancellationToken);
}
public interface NuGet.Protocol.Plugins.IPluginProcess {
    public Nullable`1<int> ExitCode { get; }
    public Nullable`1<int> Id { get; }
    [CompilerGeneratedAttribute]
public abstract virtual void add_LineRead(EventHandler`1<LineReadEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_LineRead(EventHandler`1<LineReadEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_Exited(EventHandler`1<IPluginProcess> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Exited(EventHandler`1<IPluginProcess> value);
    public abstract virtual Nullable`1<int> get_ExitCode();
    public abstract virtual Nullable`1<int> get_Id();
    public abstract virtual void BeginReadLine();
    public abstract virtual void CancelRead();
    public abstract virtual void Kill();
}
public interface NuGet.Protocol.Plugins.IReceiver {
    [CompilerGeneratedAttribute]
public abstract virtual void add_Faulted(EventHandler`1<ProtocolErrorEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Faulted(EventHandler`1<ProtocolErrorEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_MessageReceived(EventHandler`1<MessageEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_MessageReceived(EventHandler`1<MessageEventArgs> value);
    public abstract virtual void Close();
    public abstract virtual void Connect();
}
public interface NuGet.Protocol.Plugins.IRequestHandler {
    public CancellationToken CancellationToken { get; }
    public abstract virtual CancellationToken get_CancellationToken();
    public abstract virtual Task HandleResponseAsync(IConnection connection, Message request, IResponseHandler responseHandler, CancellationToken cancellationToken);
}
public interface NuGet.Protocol.Plugins.IRequestHandlers {
    public abstract virtual void AddOrUpdate(MessageMethod method, Func`1<IRequestHandler> addHandlerFunc, Func`2<IRequestHandler, IRequestHandler> updateHandlerFunc);
    public abstract virtual bool TryAdd(MessageMethod method, IRequestHandler handler);
    public abstract virtual bool TryGet(MessageMethod method, IRequestHandler& handler);
    public abstract virtual bool TryRemove(MessageMethod method);
}
public interface NuGet.Protocol.Plugins.IResponseHandler {
    public abstract virtual Task SendResponseAsync(Message request, TPayload payload, CancellationToken cancellationToken);
}
public interface NuGet.Protocol.Plugins.ISender {
    public abstract virtual void Close();
    public abstract virtual void Connect();
    public abstract virtual Task SendAsync(Message message, CancellationToken cancellationToken);
}
public static class NuGet.Protocol.Plugins.JsonSerializationUtilities : object {
    [CompilerGeneratedAttribute]
private static JsonSerializer <Serializer>k__BackingField;
    public static JsonSerializer Serializer { get; }
    private static JsonSerializationUtilities();
    [CompilerGeneratedAttribute]
public static JsonSerializer get_Serializer();
    public static T Deserialize(string json);
    public static JObject FromObject(object value);
    public static void Serialize(JsonWriter writer, object value);
    public static T ToObject(JObject jObject);
}
public class NuGet.Protocol.Plugins.LineReadEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private string <Line>k__BackingField;
    public string Line { get; }
    public LineReadEventArgs(string line);
    [CompilerGeneratedAttribute]
public string get_Line();
}
public class NuGet.Protocol.Plugins.LogRequest : object {
    [CompilerGeneratedAttribute]
private LogLevel <LogLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [JsonRequiredAttribute]
public LogLevel LogLevel { get; }
    [JsonRequiredAttribute]
public string Message { get; }
    [JsonConstructorAttribute]
public LogRequest(LogLevel logLevel, string message);
    [CompilerGeneratedAttribute]
public LogLevel get_LogLevel();
    [CompilerGeneratedAttribute]
public string get_Message();
}
public class NuGet.Protocol.Plugins.LogRequestHandler : object {
    private ILogger _logger;
    private LogLevel _logLevel;
    public CancellationToken CancellationToken { get; }
    public LogRequestHandler(ILogger logger);
    public sealed virtual CancellationToken get_CancellationToken();
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.LogRequestHandler/<HandleResponseAsync>d__5")]
public sealed virtual Task HandleResponseAsync(IConnection connection, Message request, IResponseHandler responseHandler, CancellationToken cancellationToken);
    public void SetLogger(ILogger logger);
    public static LogLevel GetLogLevel(ILogger logger);
    private void Log(LogRequest request);
}
public class NuGet.Protocol.Plugins.LogResponse : object {
    [CompilerGeneratedAttribute]
private MessageResponseCode <ResponseCode>k__BackingField;
    [JsonRequiredAttribute]
public MessageResponseCode ResponseCode { get; }
    [JsonConstructorAttribute]
public LogResponse(MessageResponseCode responseCode);
    [CompilerGeneratedAttribute]
public MessageResponseCode get_ResponseCode();
}
public class NuGet.Protocol.Plugins.MachineLogMessage : PluginLogMessage {
    private int _logicalProcessorCount;
    public MachineLogMessage(DateTimeOffset now);
    public virtual string ToString();
}
public class NuGet.Protocol.Plugins.Message : object {
    [CompilerGeneratedAttribute]
private string <RequestId>k__BackingField;
    [CompilerGeneratedAttribute]
private MessageType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private MessageMethod <Method>k__BackingField;
    [CompilerGeneratedAttribute]
private JObject <Payload>k__BackingField;
    [JsonRequiredAttribute]
public string RequestId { get; }
    [JsonRequiredAttribute]
public MessageType Type { get; }
    [JsonRequiredAttribute]
public MessageMethod Method { get; }
    public JObject Payload { get; }
    [JsonConstructorAttribute]
public Message(string requestId, MessageType type, MessageMethod method, JObject payload);
    [CompilerGeneratedAttribute]
public string get_RequestId();
    [CompilerGeneratedAttribute]
public MessageType get_Type();
    [CompilerGeneratedAttribute]
public MessageMethod get_Method();
    [CompilerGeneratedAttribute]
public JObject get_Payload();
}
public class NuGet.Protocol.Plugins.MessageDispatcher : object {
    private IConnection _connection;
    private IIdGenerator _idGenerator;
    private bool _isClosed;
    private bool _isDisposed;
    private ConcurrentDictionary`2<string, InboundRequestContext> _inboundRequestContexts;
    private IPluginLogger _logger;
    private ConcurrentDictionary`2<string, OutboundRequestContext> _outboundRequestContexts;
    private InboundRequestProcessingHandler _inboundRequestProcessingContext;
    [CompilerGeneratedAttribute]
private IRequestHandlers <RequestHandlers>k__BackingField;
    public IRequestHandlers RequestHandlers { get; }
    public MessageDispatcher(IRequestHandlers requestHandlers, IIdGenerator idGenerator);
    internal MessageDispatcher(IRequestHandlers requestHandlers, IIdGenerator idGenerator, InboundRequestProcessingHandler inboundRequestProcessingHandler, IPluginLogger logger);
    [CompilerGeneratedAttribute]
public sealed virtual IRequestHandlers get_RequestHandlers();
    public sealed virtual void Dispose();
    public sealed virtual void Close();
    public sealed virtual Message CreateMessage(MessageType type, MessageMethod method);
    public sealed virtual Message CreateMessage(MessageType type, MessageMethod method, TPayload payload);
    public sealed virtual Task DispatchCancelAsync(Message request, CancellationToken cancellationToken);
    public sealed virtual Task DispatchFaultAsync(Message request, Fault fault, CancellationToken cancellationToken);
    public sealed virtual Task DispatchProgressAsync(Message request, Progress progress, CancellationToken cancellationToken);
    public sealed virtual Task`1<TInbound> DispatchRequestAsync(MessageMethod method, TOutbound payload, CancellationToken cancellationToken);
    public sealed virtual Task DispatchResponseAsync(Message request, TOutbound responsePayload, CancellationToken cancellationToken);
    public sealed virtual void SetConnection(IConnection connection);
    private sealed virtual override Task NuGet.Protocol.Plugins.IResponseHandler.SendResponseAsync(Message request, TPayload payload, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.MessageDispatcher/<DispatchAsync>d__24`1")]
private Task DispatchAsync(IConnection connection, MessageType type, Message request, TOutgoing payload, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.MessageDispatcher/<DispatchCancelAsync>d__25")]
private Task DispatchCancelAsync(IConnection connection, Message request, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.MessageDispatcher/<DispatchFaultAsync>d__26")]
private Task DispatchFaultAsync(IConnection connection, Message request, Fault fault, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.MessageDispatcher/<DispatchProgressAsync>d__27")]
private Task DispatchProgressAsync(IConnection connection, Message request, Progress progress, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.MessageDispatcher/<DispatchWithExistingContextAsync>d__28")]
private Task DispatchWithExistingContextAsync(IConnection connection, Message response, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.MessageDispatcher/<DispatchWithNewContextAsync>d__29`2")]
private Task`1<TIncoming> DispatchWithNewContextAsync(IConnection connection, MessageType type, MessageMethod method, TOutgoing payload, CancellationToken cancellationToken);
    private void OnMessageReceived(object sender, MessageEventArgs e);
    private void HandleInboundCancel(Message message);
    private void HandleInboundFault(Message fault);
    private void HandleInboundRequest(Message message);
    private IRequestHandler GetInboundRequestHandler(MessageMethod method);
    private OutboundRequestContext GetOutboundRequestContext(string requestId);
    private void RemoveInboundRequestContext(string requestId);
    private void RemoveOutboundRequestContext(string requestId);
    private InboundRequestContext CreateInboundRequestContext(Message message, CancellationToken cancellationToken);
    private OutboundRequestContext`1<TIncoming> CreateOutboundRequestContext(Message message, Nullable`1<TimeSpan> timeout, bool isKeepAlive, CancellationToken cancellationToken);
    private static bool GetIsKeepAlive(MessageType type, MessageMethod method);
    private static TimeSpan GetRequestTimeout(IConnection connection, MessageType type, MessageMethod method);
}
public class NuGet.Protocol.Plugins.MessageEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private Message <Message>k__BackingField;
    public Message Message { get; }
    public MessageEventArgs(Message message);
    [CompilerGeneratedAttribute]
public Message get_Message();
}
public enum NuGet.Protocol.Plugins.MessageMethod : Enum {
    public int value__;
    public static MessageMethod None;
    public static MessageMethod Close;
    public static MessageMethod CopyFilesInPackage;
    public static MessageMethod CopyNupkgFile;
    public static MessageMethod GetCredentials;
    public static MessageMethod GetFilesInPackage;
    public static MessageMethod GetOperationClaims;
    public static MessageMethod GetPackageHash;
    public static MessageMethod GetPackageVersions;
    public static MessageMethod GetServiceIndex;
    public static MessageMethod Handshake;
    public static MessageMethod Initialize;
    public static MessageMethod Log;
    public static MessageMethod MonitorNuGetProcessExit;
    public static MessageMethod PrefetchPackage;
    public static MessageMethod SetCredentials;
    public static MessageMethod SetLogLevel;
    public static MessageMethod GetAuthenticationCredentials;
}
public enum NuGet.Protocol.Plugins.MessageResponseCode : Enum {
    public int value__;
    public static MessageResponseCode Success;
    public static MessageResponseCode Error;
    public static MessageResponseCode NotFound;
}
internal enum NuGet.Protocol.Plugins.MessageState : Enum {
    public int value__;
    public static MessageState Sending;
    public static MessageState Sent;
    public static MessageState Received;
    public static MessageState Cancelled;
}
public enum NuGet.Protocol.Plugins.MessageType : Enum {
    public int value__;
    public static MessageType Cancel;
    public static MessageType Fault;
    public static MessageType Progress;
    public static MessageType Request;
    public static MessageType Response;
}
public static class NuGet.Protocol.Plugins.MessageUtilities : object {
    public static Message Create(string requestId, MessageType type, MessageMethod method);
    public static Message Create(string requestId, MessageType type, MessageMethod method, TPayload payload);
    public static TPayload DeserializePayload(Message message);
}
public class NuGet.Protocol.Plugins.MonitorNuGetProcessExitRequest : object {
    [CompilerGeneratedAttribute]
private int <ProcessId>k__BackingField;
    [JsonRequiredAttribute]
public int ProcessId { get; }
    [JsonConstructorAttribute]
public MonitorNuGetProcessExitRequest(int processId);
    [CompilerGeneratedAttribute]
public int get_ProcessId();
}
public class NuGet.Protocol.Plugins.MonitorNuGetProcessExitRequestHandler : object {
    private bool _isDisposed;
    private IPlugin _plugin;
    private ConcurrentDictionary`2<int, Process> _processes;
    public CancellationToken CancellationToken { get; }
    public MonitorNuGetProcessExitRequestHandler(IPlugin plugin);
    public sealed virtual CancellationToken get_CancellationToken();
    public sealed virtual void Dispose();
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.MonitorNuGetProcessExitRequestHandler/<HandleResponseAsync>d__7")]
public sealed virtual Task HandleResponseAsync(IConnection connection, Message request, IResponseHandler responseHandler, CancellationToken cancellationToken);
    private void OnProcessExited(object sender, EventArgs e);
}
public class NuGet.Protocol.Plugins.MonitorNuGetProcessExitResponse : object {
    [CompilerGeneratedAttribute]
private MessageResponseCode <ResponseCode>k__BackingField;
    [JsonRequiredAttribute]
public MessageResponseCode ResponseCode { get; }
    [JsonConstructorAttribute]
public MonitorNuGetProcessExitResponse(MessageResponseCode responseCode);
    [CompilerGeneratedAttribute]
public MessageResponseCode get_ResponseCode();
}
public class NuGet.Protocol.Plugins.NoOpDisposePlugin : object {
    private IPlugin _plugin;
    public IConnection Connection { get; }
    public string FilePath { get; }
    public string Id { get; }
    public string Name { get; }
    public NoOpDisposePlugin(IPlugin plugin);
    public sealed virtual void add_BeforeClose(EventHandler value);
    public sealed virtual void remove_BeforeClose(EventHandler value);
    public sealed virtual void add_Closed(EventHandler value);
    public sealed virtual void remove_Closed(EventHandler value);
    public sealed virtual IConnection get_Connection();
    public sealed virtual string get_FilePath();
    public sealed virtual string get_Id();
    public sealed virtual string get_Name();
    public sealed virtual void Dispose();
    public sealed virtual void Close();
}
public enum NuGet.Protocol.Plugins.OperationClaim : Enum {
    public int value__;
    public static OperationClaim DownloadPackage;
    public static OperationClaim Authentication;
}
public abstract class NuGet.Protocol.Plugins.OutboundRequestContext : object {
    [CompilerGeneratedAttribute]
private CancellationToken <CancellationToken>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RequestId>k__BackingField;
    public CancellationToken CancellationToken { get; protected set; }
    public string RequestId { get; protected set; }
    [CompilerGeneratedAttribute]
public CancellationToken get_CancellationToken();
    [CompilerGeneratedAttribute]
protected void set_CancellationToken(CancellationToken value);
    [CompilerGeneratedAttribute]
public string get_RequestId();
    [CompilerGeneratedAttribute]
protected void set_RequestId(string value);
    public sealed virtual void Dispose();
    protected abstract virtual void Dispose(bool disposing);
    public abstract virtual void HandleCancelResponse();
    public abstract virtual void HandleProgress(Message progress);
    public abstract virtual void HandleResponse(Message response);
    public abstract virtual void HandleFault(Message fault);
}
public class NuGet.Protocol.Plugins.OutboundRequestContext`1 : OutboundRequestContext {
    private CancellationTokenSource _cancellationTokenSource;
    private IConnection _connection;
    private int _isCancellationRequested;
    private bool _isClosed;
    private bool _isDisposed;
    private bool _isKeepAlive;
    private IPluginLogger _logger;
    private Message _request;
    private TaskCompletionSource`1<TResult> _taskCompletionSource;
    private Nullable`1<TimeSpan> _timeout;
    private Timer _timer;
    public Task`1<TResult> CompletionTask { get; }
    public OutboundRequestContext`1(IConnection connection, Message request, Nullable`1<TimeSpan> timeout, bool isKeepAlive, CancellationToken cancellationToken);
    internal OutboundRequestContext`1(IConnection connection, Message request, Nullable`1<TimeSpan> timeout, bool isKeepAlive, CancellationToken cancellationToken, IPluginLogger logger);
    public Task`1<TResult> get_CompletionTask();
    public virtual void HandleCancelResponse();
    public virtual void HandleProgress(Message progress);
    public virtual void HandleResponse(Message response);
    public virtual void HandleFault(Message fault);
    protected virtual void Dispose(bool disposing);
    private void Close();
    private void OnTimeout(object state);
    private void TryCancel();
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.OutboundRequestContext`1/<<TryCancel>b__22_0>d")]
[CompilerGeneratedAttribute]
private Task <TryCancel>b__22_0();
}
public class NuGet.Protocol.Plugins.Plugin : object {
    private bool _isClosed;
    private TimeSpan _idleTimeout;
    private Timer _idleTimer;
    private object _idleTimerLock;
    private bool _isDisposed;
    private bool _isOwnProcess;
    private IPluginProcess _process;
    [CompilerGeneratedAttribute]
private EventHandler BeforeClose;
    [CompilerGeneratedAttribute]
private EventHandler Closed;
    [CompilerGeneratedAttribute]
private EventHandler`1<PluginEventArgs> Exited;
    [CompilerGeneratedAttribute]
private EventHandler`1<FaultedPluginEventArgs> Faulted;
    [CompilerGeneratedAttribute]
private EventHandler`1<PluginEventArgs> Idle;
    [CompilerGeneratedAttribute]
private IConnection <Connection>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public IConnection Connection { get; }
    public string FilePath { get; }
    public string Id { get; }
    public string Name { get; }
    public Plugin(string filePath, IConnection connection, IPluginProcess process, bool isOwnProcess, TimeSpan idleTimeout);
    public Plugin(string filePath, IConnection connection, IPluginProcess process, bool isOwnProcess, TimeSpan idleTimeout, string id);
    [CompilerGeneratedAttribute]
public sealed virtual void add_BeforeClose(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_BeforeClose(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_Closed(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Closed(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_Exited(EventHandler`1<PluginEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_Exited(EventHandler`1<PluginEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_Faulted(EventHandler`1<FaultedPluginEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_Faulted(EventHandler`1<FaultedPluginEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_Idle(EventHandler`1<PluginEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_Idle(EventHandler`1<PluginEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual IConnection get_Connection();
    [CompilerGeneratedAttribute]
public sealed virtual string get_FilePath();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Id();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    public sealed virtual void Dispose();
    public sealed virtual void Close();
    public static string CreateNewId();
    private void FireBeforeClose();
    private void FireClosed();
    private void OnExited(object sender, IPluginProcess pluginProcess);
    private void OnFaulted(object sender, ProtocolErrorEventArgs e);
    private void OnIdleTimer(object state);
    private void OnMessageReceived(object sender, MessageEventArgs e);
}
public class NuGet.Protocol.Plugins.PluginCacheEntry : object {
    [CompilerGeneratedAttribute]
private TimeSpan <MaxAge>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CacheFileName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RootFolder>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NewCacheFileName>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<OperationClaim> <OperationClaims>k__BackingField;
    internal TimeSpan MaxAge { get; internal set; }
    internal string CacheFileName { get; }
    private string RootFolder { get; }
    private string NewCacheFileName { get; }
    public IReadOnlyList`1<OperationClaim> OperationClaims { get; public set; }
    public PluginCacheEntry(string rootCacheFolder, string pluginFilePath, string requestKey);
    [CompilerGeneratedAttribute]
internal TimeSpan get_MaxAge();
    [CompilerGeneratedAttribute]
internal void set_MaxAge(TimeSpan value);
    [CompilerGeneratedAttribute]
internal string get_CacheFileName();
    [CompilerGeneratedAttribute]
private string get_RootFolder();
    [CompilerGeneratedAttribute]
private string get_NewCacheFileName();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<OperationClaim> get_OperationClaims();
    [CompilerGeneratedAttribute]
public void set_OperationClaims(IReadOnlyList`1<OperationClaim> value);
    public void LoadFromFile();
    private void ProcessContent(Stream content);
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.PluginCacheEntry/<UpdateCacheFileAsync>d__20")]
public Task UpdateCacheFileAsync();
}
public static class NuGet.Protocol.Plugins.PluginConstants : object {
    public static TimeSpan CloseTimeout;
    public static TimeSpan IdleTimeout;
    public static IEnumerable`1<string> PluginArguments;
    public static TimeSpan ProgressInterval;
    public static TimeSpan RequestTimeout;
    private static PluginConstants();
}
public class NuGet.Protocol.Plugins.PluginCreationResult : object {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<OperationClaim> <Claims>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    [CompilerGeneratedAttribute]
private IPlugin <Plugin>k__BackingField;
    [CompilerGeneratedAttribute]
private IPluginMulticlientUtilities <PluginMulticlientUtilities>k__BackingField;
    public IReadOnlyList`1<OperationClaim> Claims { get; }
    public string Message { get; }
    public Exception Exception { get; }
    public IPlugin Plugin { get; }
    public IPluginMulticlientUtilities PluginMulticlientUtilities { get; }
    public PluginCreationResult(IPlugin plugin, IPluginMulticlientUtilities utilities, IReadOnlyList`1<OperationClaim> claims);
    public PluginCreationResult(string message);
    public PluginCreationResult(string message, Exception exception);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<OperationClaim> get_Claims();
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public Exception get_Exception();
    [CompilerGeneratedAttribute]
public IPlugin get_Plugin();
    [CompilerGeneratedAttribute]
public IPluginMulticlientUtilities get_PluginMulticlientUtilities();
}
public class NuGet.Protocol.Plugins.PluginDiscoverer : object {
    private bool _isDisposed;
    private List`1<PluginFile> _pluginFiles;
    private string _rawPluginPaths;
    private IEnumerable`1<PluginDiscoveryResult> _results;
    private SemaphoreSlim _semaphore;
    private EmbeddedSignatureVerifier _verifier;
    public PluginDiscoverer(string rawPluginPaths, EmbeddedSignatureVerifier verifier);
    public sealed virtual void Dispose();
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.PluginDiscoverer/<DiscoverAsync>d__8")]
public sealed virtual Task`1<IEnumerable`1<PluginDiscoveryResult>> DiscoverAsync(CancellationToken cancellationToken);
    private List`1<PluginFile> GetPluginFiles(CancellationToken cancellationToken);
    private IEnumerable`1<string> GetPluginFilePaths();
}
public class NuGet.Protocol.Plugins.PluginDiscoveryResult : object {
    [CompilerGeneratedAttribute]
private PluginFile <PluginFile>k__BackingField;
    private string _message;
    public PluginFile PluginFile { get; }
    public string Message { get; }
    public PluginDiscoveryResult(PluginFile pluginFile);
    [CompilerGeneratedAttribute]
public PluginFile get_PluginFile();
    public string get_Message();
}
public static class NuGet.Protocol.Plugins.PluginDiscoveryUtility : object {
    [CompilerGeneratedAttribute]
private static Lazy`1<string> <InternalPluginDiscoveryRoot>k__BackingField;
    private static string NuGetPluginsDirectory;
    public static Lazy`1<string> InternalPluginDiscoveryRoot { get; public set; }
    private static PluginDiscoveryUtility();
    [CompilerGeneratedAttribute]
public static Lazy`1<string> get_InternalPluginDiscoveryRoot();
    [CompilerGeneratedAttribute]
public static void set_InternalPluginDiscoveryRoot(Lazy`1<string> value);
    public static string GetInternalPlugins();
    public static string GetInternalPluginRelativeToMSBuildDirectory(string msbuildDirectoryPath);
    public static string GetNuGetPluginsDirectoryRelativeToNuGetAssembly(string nugetAssemblyPath);
    public static string GetNuGetHomePluginsPath();
    public static IEnumerable`1<string> GetConventionBasedPlugins(IEnumerable`1<string> directories);
}
public class NuGet.Protocol.Plugins.PluginEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private IPlugin <Plugin>k__BackingField;
    public IPlugin Plugin { get; }
    public PluginEventArgs(IPlugin plugin);
    [CompilerGeneratedAttribute]
public IPlugin get_Plugin();
}
public class NuGet.Protocol.Plugins.PluginException : Exception {
    public PluginException(string message);
    public PluginException(string message, Exception innerException);
    private PluginException(SerializationInfo info, StreamingContext context);
}
public class NuGet.Protocol.Plugins.PluginFactory : object {
    private bool _isDisposed;
    private IPluginLogger _logger;
    private TimeSpan _pluginIdleTimeout;
    private ConcurrentDictionary`2<string, Lazy`1<Task`1<IPlugin>>> _plugins;
    public PluginFactory(TimeSpan pluginIdleTimeout);
    public sealed virtual void Dispose();
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.PluginFactory/<GetOrCreateAsync>d__6")]
public sealed virtual Task`1<IPlugin> GetOrCreateAsync(string filePath, IEnumerable`1<string> arguments, IRequestHandlers requestHandlers, ConnectionOptions options, CancellationToken sessionCancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.PluginFactory/<CreatePluginAsync>d__7")]
private Task`1<IPlugin> CreatePluginAsync(string filePath, IEnumerable`1<string> arguments, IRequestHandlers requestHandlers, ConnectionOptions options, CancellationToken sessionCancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.PluginFactory/<CreateFromCurrentProcessAsync>d__8")]
public static Task`1<IPlugin> CreateFromCurrentProcessAsync(IRequestHandlers requestHandlers, ConnectionOptions options, CancellationToken sessionCancellationToken);
    private void Dispose(IPlugin plugin);
    private void OnPluginFaulted(object sender, FaultedPluginEventArgs e);
    private void OnPluginExited(object sender, PluginEventArgs e);
    private void OnPluginIdle(object sender, PluginEventArgs e);
    private void OnPluginProcessExited(IPluginProcess pluginProcess, string pluginId);
    private static void SendCloseRequest(IPlugin plugin);
    private void UnregisterEventHandlers(Plugin plugin);
    private static void WriteCommonLogMessages(IPluginLogger logger);
}
public class NuGet.Protocol.Plugins.PluginFile : object {
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private Lazy`1<PluginFileState> <State>k__BackingField;
    public string Path { get; }
    public Lazy`1<PluginFileState> State { get; }
    public PluginFile(string filePath, Lazy`1<PluginFileState> state);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public Lazy`1<PluginFileState> get_State();
    public virtual string ToString();
}
public enum NuGet.Protocol.Plugins.PluginFileState : Enum {
    public int value__;
    public static PluginFileState Valid;
    public static PluginFileState NotFound;
    public static PluginFileState InvalidFilePath;
    public static PluginFileState InvalidEmbeddedSignature;
}
public class NuGet.Protocol.Plugins.PluginInstanceLogMessage : PluginLogMessage {
    private string _pluginId;
    private Nullable`1<int> _processId;
    private PluginState _state;
    public PluginInstanceLogMessage(DateTimeOffset now, string pluginId, PluginState state);
    public PluginInstanceLogMessage(DateTimeOffset now, string pluginId, PluginState state, Nullable`1<int> processId);
    public virtual string ToString();
}
public class NuGet.Protocol.Plugins.PluginLogger : object {
    private bool _isDisposed;
    private Lazy`1<StreamWriter> _streamWriter;
    private string _logDirectoryPath;
    private DateTimeOffset _startTime;
    private Stopwatch _stopwatch;
    private object _streamWriterLock;
    [CompilerGeneratedAttribute]
private static PluginLogger <DefaultInstance>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsEnabled>k__BackingField;
    public static PluginLogger DefaultInstance { get; }
    public bool IsEnabled { get; }
    public DateTimeOffset Now { get; }
    internal PluginLogger(IEnvironmentVariableReader environmentVariableReader);
    private static PluginLogger();
    [CompilerGeneratedAttribute]
public static PluginLogger get_DefaultInstance();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsEnabled();
    public sealed virtual DateTimeOffset get_Now();
    public sealed virtual void Dispose();
    public sealed virtual void Write(IPluginLogMessage message);
    private StreamWriter CreateStreamWriter(IPluginLogMessage message);
}
public abstract class NuGet.Protocol.Plugins.PluginLogMessage : object {
    private static StringEnumConverter _enumConverter;
    private DateTime _now;
    protected PluginLogMessage(DateTimeOffset now);
    private static PluginLogMessage();
    protected string ToString(string type, JObject message);
}
public class NuGet.Protocol.Plugins.PluginManager : object {
    private static Lazy`1<IPluginManager> _lazy;
    private ConnectionOptions _connectionOptions;
    private Lazy`1<IPluginDiscoverer> _discoverer;
    private bool _isDisposed;
    private IPluginFactory _pluginFactory;
    private ConcurrentDictionary`2<PluginRequestKey, Lazy`1<Task`1<IReadOnlyList`1<OperationClaim>>>> _pluginOperationClaims;
    private ConcurrentDictionary`2<string, Lazy`1<IPluginMulticlientUtilities>> _pluginUtilities;
    private string _rawPluginPaths;
    private static Lazy`1<int> _currentProcessId;
    private Lazy`1<string> _pluginsCacheDirectoryPath;
    [CompilerGeneratedAttribute]
private IEnvironmentVariableReader <EnvironmentVariableReader>k__BackingField;
    public static IPluginManager Instance { get; }
    public IEnvironmentVariableReader EnvironmentVariableReader { get; private set; }
    public PluginManager(IEnvironmentVariableReader reader, Lazy`1<IPluginDiscoverer> pluginDiscoverer, Func`2<TimeSpan, IPluginFactory> pluginFactoryCreator, Lazy`1<string> pluginsCacheDirectoryPath);
    private static PluginManager();
    public static IPluginManager get_Instance();
    [CompilerGeneratedAttribute]
public IEnvironmentVariableReader get_EnvironmentVariableReader();
    [CompilerGeneratedAttribute]
private void set_EnvironmentVariableReader(IEnvironmentVariableReader value);
    public sealed virtual void Dispose();
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.PluginManager/<FindAvailablePluginsAsync>d__19")]
public sealed virtual Task`1<IEnumerable`1<PluginDiscoveryResult>> FindAvailablePluginsAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.PluginManager/<CreatePluginsAsync>d__20")]
public sealed virtual Task`1<IEnumerable`1<PluginCreationResult>> CreatePluginsAsync(SourceRepository source, CancellationToken cancellationToken);
    public sealed virtual Task`1<Tuple`2<bool, PluginCreationResult>> TryGetSourceAgnosticPluginAsync(PluginDiscoveryResult pluginDiscoveryResult, OperationClaim requestedOperationClaim, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.PluginManager/<TryCreatePluginAsync>d__22")]
private Task`1<Tuple`2<bool, PluginCreationResult>> TryCreatePluginAsync(PluginDiscoveryResult result, OperationClaim requestedOperationClaim, PluginRequestKey requestKey, string packageSourceRepository, JObject serviceIndex, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.PluginManager/<PerformOneTimePluginInitializationAsync>d__23")]
private Task`1<Lazy`1<IPluginMulticlientUtilities>> PerformOneTimePluginInitializationAsync(IPlugin plugin, CancellationToken cancellationToken);
    private void Initialize(IEnvironmentVariableReader reader, Lazy`1<IPluginDiscoverer> pluginDiscoverer, Func`2<TimeSpan, IPluginFactory> pluginFactoryCreator, Lazy`1<string> pluginsCacheDirectoryPath);
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.PluginManager/<GetPluginOperationClaimsAsync>d__25")]
private Task`1<IReadOnlyList`1<OperationClaim>> GetPluginOperationClaimsAsync(IPlugin plugin, string packageSourceRepository, JObject serviceIndex, CancellationToken cancellationToken);
    private PluginDiscoverer InitializeDiscoverer();
    private bool IsPluginPossiblyAvailable();
    private void OnPluginClosed(object sender, EventArgs e);
    private static int GetCurrentProcessId();
    private static string GetCurrentCultureName();
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.PluginManager/<InitializePluginAsync>d__31")]
private static Task InitializePluginAsync(IPlugin plugin, TimeSpan requestTimeout, CancellationToken cancellationToken);
}
public class NuGet.Protocol.Plugins.PluginMulticlientUtilities : object {
    private ConcurrentDictionary`2<string, Lazy`1<Task>> _actions;
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.PluginMulticlientUtilities/<DoOncePerPluginLifetimeAsync>d__2")]
public sealed virtual Task DoOncePerPluginLifetimeAsync(string key, Func`1<Task> taskFunc, CancellationToken cancellationToken);
}
public class NuGet.Protocol.Plugins.PluginPackageDownloader : object {
    private Func`2<Exception, Task`1<bool>> _handleExceptionAsync;
    private bool _isDisposed;
    private PackageIdentity _packageIdentity;
    private PluginPackageReader _packageReader;
    private string _packageSourceRepository;
    private IPlugin _plugin;
    public IAsyncPackageContentReader ContentReader { get; }
    public IAsyncPackageCoreReader CoreReader { get; }
    public ISignedPackageReader SignedPackageReader { get; }
    public string Source { get; }
    public PluginPackageDownloader(IPlugin plugin, PackageIdentity packageIdentity, PluginPackageReader packageReader, string packageSourceRepository);
    public sealed virtual IAsyncPackageContentReader get_ContentReader();
    public sealed virtual IAsyncPackageCoreReader get_CoreReader();
    public sealed virtual ISignedPackageReader get_SignedPackageReader();
    public sealed virtual string get_Source();
    public sealed virtual void Dispose();
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.PluginPackageDownloader/<CopyNupkgFileToAsync>d__16")]
public sealed virtual Task`1<bool> CopyNupkgFileToAsync(string destinationFilePath, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.PluginPackageDownloader/<GetPackageHashAsync>d__17")]
public sealed virtual Task`1<string> GetPackageHashAsync(string hashAlgorithm, CancellationToken cancellationToken);
    public sealed virtual void SetExceptionHandler(Func`2<Exception, Task`1<bool>> handleExceptionAsync);
    public sealed virtual void SetThrottle(SemaphoreSlim throttle);
    private void ThrowIfDisposed();
}
public class NuGet.Protocol.Plugins.PluginPackageReader : PackageReaderBase {
    private ConcurrentDictionary`2<string, Lazy`1<Task`1<FileStreamCreator>>> _fileStreams;
    private IEnumerable`1<string> _files;
    private SemaphoreSlim _getFilesSemaphore;
    private SemaphoreSlim _getNuspecReaderSemaphore;
    private bool _isDisposed;
    private NuspecReader _nuspecReader;
    private PackageIdentity _packageIdentity;
    private string _packageSourceRepository;
    private IPlugin _plugin;
    private Lazy`1<string> _tempDirectoryPath;
    public NuspecReader NuspecReader { get; }
    public PluginPackageReader(IPlugin plugin, PackageIdentity packageIdentity, string packageSourceRepository);
    public virtual Stream GetStream(string path);
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.PluginPackageReader/<GetStreamAsync>d__12")]
public virtual Task`1<Stream> GetStreamAsync(string path, CancellationToken cancellationToken);
    public virtual IEnumerable`1<string> GetFiles();
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.PluginPackageReader/<GetFilesAsync>d__14")]
public virtual Task`1<IEnumerable`1<string>> GetFilesAsync(CancellationToken cancellationToken);
    public virtual IEnumerable`1<string> GetFiles(string folder);
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.PluginPackageReader/<GetFilesAsync>d__16")]
public virtual Task`1<IEnumerable`1<string>> GetFilesAsync(string folder, CancellationToken cancellationToken);
    public virtual IEnumerable`1<string> CopyFiles(string destination, IEnumerable`1<string> packageFiles, ExtractPackageFileDelegate extractFile, ILogger logger, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.PluginPackageReader/<CopyFilesAsync>d__18")]
public virtual Task`1<IEnumerable`1<string>> CopyFilesAsync(string destination, IEnumerable`1<string> packageFiles, ExtractPackageFileDelegate extractFile, ILogger logger, CancellationToken cancellationToken);
    public virtual PackageIdentity GetIdentity();
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.PluginPackageReader/<GetIdentityAsync>d__20")]
public virtual Task`1<PackageIdentity> GetIdentityAsync(CancellationToken cancellationToken);
    public virtual NuGetVersion GetMinClientVersion();
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.PluginPackageReader/<GetMinClientVersionAsync>d__22")]
public virtual Task`1<NuGetVersion> GetMinClientVersionAsync(CancellationToken cancellationToken);
    public virtual IReadOnlyList`1<PackageType> GetPackageTypes();
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.PluginPackageReader/<GetPackageTypesAsync>d__24")]
public virtual Task`1<IReadOnlyList`1<PackageType>> GetPackageTypesAsync(CancellationToken cancellationToken);
    public virtual Stream GetNuspec();
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.PluginPackageReader/<GetNuspecAsync>d__26")]
public virtual Task`1<Stream> GetNuspecAsync(CancellationToken cancellationToken);
    public virtual string GetNuspecFile();
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.PluginPackageReader/<GetNuspecFileAsync>d__28")]
public virtual Task`1<string> GetNuspecFileAsync(CancellationToken cancellationToken);
    public virtual NuspecReader get_NuspecReader();
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.PluginPackageReader/<GetNuspecReaderAsync>d__31")]
public virtual Task`1<NuspecReader> GetNuspecReaderAsync(CancellationToken cancellationToken);
    public virtual IEnumerable`1<NuGetFramework> GetSupportedFrameworks();
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.PluginPackageReader/<GetSupportedFrameworksAsync>d__33")]
public virtual Task`1<IEnumerable`1<NuGetFramework>> GetSupportedFrameworksAsync(CancellationToken cancellationToken);
    public virtual IEnumerable`1<FrameworkSpecificGroup> GetFrameworkItems();
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.PluginPackageReader/<GetFrameworkItemsAsync>d__35")]
public virtual Task`1<IEnumerable`1<FrameworkSpecificGroup>> GetFrameworkItemsAsync(CancellationToken cancellationToken);
    public virtual bool IsServiceable();
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.PluginPackageReader/<IsServiceableAsync>d__37")]
public virtual Task`1<bool> IsServiceableAsync(CancellationToken cancellationToken);
    public virtual IEnumerable`1<FrameworkSpecificGroup> GetBuildItems();
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.PluginPackageReader/<GetBuildItemsAsync>d__39")]
public virtual Task`1<IEnumerable`1<FrameworkSpecificGroup>> GetBuildItemsAsync(CancellationToken cancellationToken);
    public virtual IEnumerable`1<FrameworkSpecificGroup> GetToolItems();
    public virtual Task`1<IEnumerable`1<FrameworkSpecificGroup>> GetToolItemsAsync(CancellationToken cancellationToken);
    public virtual IEnumerable`1<FrameworkSpecificGroup> GetContentItems();
    public virtual Task`1<IEnumerable`1<FrameworkSpecificGroup>> GetContentItemsAsync(CancellationToken cancellationToken);
    public virtual IEnumerable`1<FrameworkSpecificGroup> GetItems(string folderName);
    public virtual Task`1<IEnumerable`1<FrameworkSpecificGroup>> GetItemsAsync(string folderName, CancellationToken cancellationToken);
    public virtual IEnumerable`1<PackageDependencyGroup> GetPackageDependencies();
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.PluginPackageReader/<GetPackageDependenciesAsync>d__47")]
public virtual Task`1<IEnumerable`1<PackageDependencyGroup>> GetPackageDependenciesAsync(CancellationToken cancellationToken);
    public virtual IEnumerable`1<FrameworkSpecificGroup> GetLibItems();
    public virtual Task`1<IEnumerable`1<FrameworkSpecificGroup>> GetLibItemsAsync(CancellationToken cancellationToken);
    public virtual IEnumerable`1<FrameworkSpecificGroup> GetReferenceItems();
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.PluginPackageReader/<GetReferenceItemsAsync>d__51")]
public virtual Task`1<IEnumerable`1<FrameworkSpecificGroup>> GetReferenceItemsAsync(CancellationToken cancellationToken);
    public virtual bool GetDevelopmentDependency();
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.PluginPackageReader/<GetDevelopmentDependencyAsync>d__53")]
public virtual Task`1<bool> GetDevelopmentDependencyAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.PluginPackageReader/<CopyNupkgAsync>d__54")]
public virtual Task`1<string> CopyNupkgAsync(string nupkgFilePath, CancellationToken cancellationToken);
    protected virtual void Dispose(bool disposing);
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.PluginPackageReader/<GetFileGroupsAsync>d__56")]
private Task`1<IEnumerable`1<FrameworkSpecificGroup>> GetFileGroupsAsync(string folder, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.PluginPackageReader/<GetStreamInternalAsync>d__57")]
private Task`1<FileStreamCreator> GetStreamInternalAsync(string pathInPackage);
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.PluginPackageReader/<GetFilesInternalAsync>d__58")]
private Task`1<IEnumerable`1<string>> GetFilesInternalAsync(CancellationToken cancellationToken);
    private void CreatePackageDownloadMarkerFile(string nupkgFilePath);
    private static string GetTemporaryDirectoryPath();
    public virtual Task`1<PrimarySignature> GetPrimarySignatureAsync(CancellationToken token);
    public virtual Task`1<bool> IsSignedAsync(CancellationToken token);
    public virtual Task ValidateIntegrityAsync(SignatureContent signatureContent, CancellationToken token);
    public virtual Task`1<Byte[]> GetArchiveHashAsync(HashAlgorithmName hashAlgorithm, CancellationToken token);
    public virtual bool CanVerifySignedPackages(SignedPackageVerifierSettings verifierSettings);
    public virtual string GetContentHash(CancellationToken token, Func`1<string> GetUnsignedPackageHash);
    [CompilerGeneratedAttribute]
private Lazy`1<Task`1<FileStreamCreator>> <GetStreamAsync>b__12_0(string p);
}
public class NuGet.Protocol.Plugins.PluginProcess : object {
    private Nullable`1<int> _exitCode;
    private bool _hasStarted;
    private Nullable`1<int> _id;
    private bool _isDisposed;
    private Process _process;
    private ProcessStartInfo _startInfo;
    [CompilerGeneratedAttribute]
private EventHandler`1<IPluginProcess> Exited;
    [CompilerGeneratedAttribute]
private EventHandler`1<LineReadEventArgs> LineRead;
    public Nullable`1<int> ExitCode { get; }
    public string FilePath { get; }
    public Nullable`1<int> Id { get; }
    public StreamWriter StandardInput { get; }
    public PluginProcess(ProcessStartInfo startInfo);
    [CompilerGeneratedAttribute]
public sealed virtual void add_Exited(EventHandler`1<IPluginProcess> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Exited(EventHandler`1<IPluginProcess> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_LineRead(EventHandler`1<LineReadEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_LineRead(EventHandler`1<LineReadEventArgs> value);
    public sealed virtual Nullable`1<int> get_ExitCode();
    public string get_FilePath();
    public sealed virtual Nullable`1<int> get_Id();
    public StreamWriter get_StandardInput();
    public sealed virtual void Dispose();
    public sealed virtual void BeginReadLine();
    public sealed virtual void CancelRead();
    public sealed virtual void Kill();
    public void Start();
    private void OnOutputDataReceived(object sender, DataReceivedEventArgs e);
    private void OnProcessExited(object sender, EventArgs e);
    private void UpdateExitCodeIfNecessary();
    private void UpdateIdIfNecessary();
}
public enum NuGet.Protocol.Plugins.PluginState : Enum {
    public int value__;
    public static PluginState Started;
    public static PluginState Idle;
    public static PluginState Exited;
    public static PluginState Disposing;
    public static PluginState Disposed;
}
public class NuGet.Protocol.Plugins.PrefetchPackageRequest : object {
    [CompilerGeneratedAttribute]
private string <PackageId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PackageSourceRepository>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PackageVersion>k__BackingField;
    [JsonRequiredAttribute]
public string PackageId { get; }
    [JsonRequiredAttribute]
public string PackageSourceRepository { get; }
    [JsonRequiredAttribute]
public string PackageVersion { get; }
    [JsonConstructorAttribute]
public PrefetchPackageRequest(string packageSourceRepository, string packageId, string packageVersion);
    [CompilerGeneratedAttribute]
public string get_PackageId();
    [CompilerGeneratedAttribute]
public string get_PackageSourceRepository();
    [CompilerGeneratedAttribute]
public string get_PackageVersion();
}
public class NuGet.Protocol.Plugins.PrefetchPackageResponse : object {
    [CompilerGeneratedAttribute]
private MessageResponseCode <ResponseCode>k__BackingField;
    [JsonRequiredAttribute]
public MessageResponseCode ResponseCode { get; }
    [JsonConstructorAttribute]
public PrefetchPackageResponse(MessageResponseCode responseCode);
    [CompilerGeneratedAttribute]
public MessageResponseCode get_ResponseCode();
}
public class NuGet.Protocol.Plugins.ProcessLogMessage : PluginLogMessage {
    private int _processId;
    private string _processName;
    private DateTime _processStartTime;
    public ProcessLogMessage(DateTimeOffset now);
    public virtual string ToString();
}
public class NuGet.Protocol.Plugins.Progress : object {
    [CompilerGeneratedAttribute]
private Nullable`1<double> <Percentage>k__BackingField;
    public Nullable`1<double> Percentage { get; }
    [JsonConstructorAttribute]
public Progress(Nullable`1<double> percentage);
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_Percentage();
    private static bool IsValidPercentage(Nullable`1<double> percentage);
}
public static class NuGet.Protocol.Plugins.ProtocolConstants : object {
    public static SemanticVersion CurrentVersion;
    public static SemanticVersion Version100;
    public static TimeSpan HandshakeTimeout;
    public static TimeSpan MaxTimeout;
    public static TimeSpan MinTimeout;
    public static TimeSpan RequestTimeout;
    private static ProtocolConstants();
}
public class NuGet.Protocol.Plugins.ProtocolErrorEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    [CompilerGeneratedAttribute]
private Message <Message>k__BackingField;
    public Exception Exception { get; }
    public Message Message { get; }
    public ProtocolErrorEventArgs(Exception exception);
    public ProtocolErrorEventArgs(Exception exception, Message message);
    [CompilerGeneratedAttribute]
public Exception get_Exception();
    [CompilerGeneratedAttribute]
public Message get_Message();
}
public class NuGet.Protocol.Plugins.ProtocolException : Exception {
    public ProtocolException(string message);
    public ProtocolException(string message, Exception innerException);
    private ProtocolException(SerializationInfo info, StreamingContext context);
}
public abstract class NuGet.Protocol.Plugins.Receiver : object {
    [CompilerGeneratedAttribute]
private bool <IsClosed>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDisposed>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHandler`1<ProtocolErrorEventArgs> Faulted;
    [CompilerGeneratedAttribute]
private EventHandler`1<MessageEventArgs> MessageReceived;
    protected bool IsClosed { get; private set; }
    protected bool IsDisposed { get; protected set; }
    [CompilerGeneratedAttribute]
protected bool get_IsClosed();
    [CompilerGeneratedAttribute]
private void set_IsClosed(bool value);
    [CompilerGeneratedAttribute]
protected bool get_IsDisposed();
    [CompilerGeneratedAttribute]
protected void set_IsDisposed(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_Faulted(EventHandler`1<ProtocolErrorEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Faulted(EventHandler`1<ProtocolErrorEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_MessageReceived(EventHandler`1<MessageEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_MessageReceived(EventHandler`1<MessageEventArgs> value);
    public virtual void Close();
    public abstract virtual void Connect();
    public sealed virtual void Dispose();
    protected abstract virtual void Dispose(bool disposing);
    protected void FireFaultEvent(Exception exception, Message message);
    protected void FireMessageReceivedEvent(Message message);
    protected void ThrowIfClosed();
    protected void ThrowIfDisposed();
}
public class NuGet.Protocol.Plugins.RequestHandlers : object {
    private ConcurrentDictionary`2<MessageMethod, IRequestHandler> _handlers;
    public sealed virtual void AddOrUpdate(MessageMethod method, Func`1<IRequestHandler> addHandlerFunc, Func`2<IRequestHandler, IRequestHandler> updateHandlerFunc);
    public sealed virtual bool TryAdd(MessageMethod method, IRequestHandler handler);
    public sealed virtual bool TryGet(MessageMethod method, IRequestHandler& handler);
    public sealed virtual bool TryRemove(MessageMethod method);
}
public class NuGet.Protocol.Plugins.RequestIdGenerator : object {
    public sealed virtual string GenerateUniqueId();
}
public class NuGet.Protocol.Plugins.Sender : object {
    private bool _hasConnected;
    private bool _isClosed;
    private bool _isDisposed;
    private object _sendLock;
    private TextWriter _textWriter;
    public Sender(TextWriter writer);
    public sealed virtual void Dispose();
    public sealed virtual void Close();
    public sealed virtual void Connect();
    public sealed virtual Task SendAsync(Message message, CancellationToken cancellationToken);
    private void ThrowIfDisposed();
}
public class NuGet.Protocol.Plugins.SetCredentialsRequest : object {
    [CompilerGeneratedAttribute]
private string <PackageSourceRepository>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Password>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProxyPassword>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProxyUsername>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Username>k__BackingField;
    [JsonRequiredAttribute]
public string PackageSourceRepository { get; }
    public string Password { get; }
    public string ProxyPassword { get; }
    public string ProxyUsername { get; }
    public string Username { get; }
    public SetCredentialsRequest(string packageSourceRepository, string proxyUsername, string proxyPassword, string username, string password);
    [CompilerGeneratedAttribute]
public string get_PackageSourceRepository();
    [CompilerGeneratedAttribute]
public string get_Password();
    [CompilerGeneratedAttribute]
public string get_ProxyPassword();
    [CompilerGeneratedAttribute]
public string get_ProxyUsername();
    [CompilerGeneratedAttribute]
public string get_Username();
}
public class NuGet.Protocol.Plugins.SetCredentialsResponse : object {
    [CompilerGeneratedAttribute]
private MessageResponseCode <ResponseCode>k__BackingField;
    [JsonRequiredAttribute]
public MessageResponseCode ResponseCode { get; }
    [JsonConstructorAttribute]
public SetCredentialsResponse(MessageResponseCode responseCode);
    [CompilerGeneratedAttribute]
public MessageResponseCode get_ResponseCode();
}
public class NuGet.Protocol.Plugins.SetLogLevelRequest : object {
    [CompilerGeneratedAttribute]
private LogLevel <LogLevel>k__BackingField;
    [JsonRequiredAttribute]
public LogLevel LogLevel { get; }
    [JsonConstructorAttribute]
public SetLogLevelRequest(LogLevel logLevel);
    [CompilerGeneratedAttribute]
public LogLevel get_LogLevel();
}
public class NuGet.Protocol.Plugins.SetLogLevelResponse : object {
    [CompilerGeneratedAttribute]
private MessageResponseCode <ResponseCode>k__BackingField;
    [JsonRequiredAttribute]
public MessageResponseCode ResponseCode { get; }
    [JsonConstructorAttribute]
public SetLogLevelResponse(MessageResponseCode responseCode);
    [CompilerGeneratedAttribute]
public MessageResponseCode get_ResponseCode();
}
public class NuGet.Protocol.Plugins.StandardInputReceiver : Receiver {
    private TextReader _reader;
    private CancellationTokenSource _receiveCancellationTokenSource;
    private Task _receiveThread;
    public StandardInputReceiver(TextReader reader);
    protected virtual void Dispose(bool disposing);
    public virtual void Connect();
    private void Receive(object state);
}
public class NuGet.Protocol.Plugins.StandardOutputReceiver : Receiver {
    private bool _hasConnected;
    private IPluginProcess _process;
    public StandardOutputReceiver(IPluginProcess process);
    protected virtual void Dispose(bool disposing);
    public virtual void Close();
    public virtual void Connect();
    private void OnLineRead(object sender, LineReadEventArgs e);
}
public class NuGet.Protocol.Plugins.StopwatchLogMessage : PluginLogMessage {
    private long _frequency;
    public StopwatchLogMessage(DateTimeOffset now, long frequency);
    public virtual string ToString();
}
public class NuGet.Protocol.Plugins.SymmetricHandshake : object {
    private IConnection _connection;
    private HandshakeResponse _handshakeFailedResponse;
    private TimeSpan _handshakeTimeout;
    private bool _isDisposed;
    private SemanticVersion _minimumProtocolVersion;
    private HandshakeRequest _outboundHandshakeRequest;
    private SemanticVersion _protocolVersion;
    private TaskCompletionSource`1<int> _responseSentTaskCompletionSource;
    private CancellationTokenSource _timeoutCancellationTokenSource;
    [CompilerGeneratedAttribute]
private CancellationToken <CancellationToken>k__BackingField;
    public CancellationToken CancellationToken { get; }
    public SymmetricHandshake(IConnection connection, TimeSpan handshakeTimeout, SemanticVersion protocolVersion, SemanticVersion minimumProtocolVersion);
    [CompilerGeneratedAttribute]
public sealed virtual CancellationToken get_CancellationToken();
    public sealed virtual void Dispose();
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.SymmetricHandshake/<HandshakeAsync>d__14")]
public Task`1<SemanticVersion> HandshakeAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.SymmetricHandshake/<HandleResponseAsync>d__15")]
public sealed virtual Task HandleResponseAsync(IConnection connection, Message request, IResponseHandler responseHandler, CancellationToken cancellationToken);
    private bool IsSupportedVersion(SemanticVersion requestedProtocolVersion);
    [CompilerGeneratedAttribute]
private void <.ctor>b__12_0();
    [CompilerGeneratedAttribute]
private bool <HandleResponseAsync>b__15_0(Task task);
}
public class NuGet.Protocol.Plugins.TaskLogMessage : PluginLogMessage {
    private Nullable`1<int> _currentTaskId;
    private MessageMethod _method;
    private string _requestId;
    private TaskState _state;
    private MessageType _type;
    public TaskLogMessage(DateTimeOffset now, string requestId, MessageMethod method, MessageType type, TaskState state);
    public virtual string ToString();
}
public enum NuGet.Protocol.Plugins.TaskState : Enum {
    public int value__;
    public static TaskState Queued;
    public static TaskState Executing;
    public static TaskState Completed;
}
public class NuGet.Protocol.Plugins.ThreadPoolLogMessage : PluginLogMessage {
    private int _maxCompletionPortThreads;
    private int _maxWorkerThreads;
    private int _minCompletionPortThreads;
    private int _minWorkerThreads;
    public ThreadPoolLogMessage(DateTimeOffset now);
    public virtual string ToString();
}
public static class NuGet.Protocol.Plugins.TimeoutUtilities : object {
    public static TimeSpan GetTimeout(string timeoutInSeconds, TimeSpan fallbackTimeout);
    public static bool IsValid(TimeSpan timeout);
}
public class NuGet.Protocol.Plugins.UnixAndMonoPlatformsEmbeddedSignatureVerifier : EmbeddedSignatureVerifier {
    public virtual bool IsValid(string filePath);
}
public class NuGet.Protocol.Plugins.WindowsEmbeddedSignatureVerifier : EmbeddedSignatureVerifier {
    private static int WinVerifyTrust(IntPtr hwnd, Guid pgActionID, WINTRUST_DATA pWVTData);
    public virtual bool IsValid(string filePath);
}
public static class NuGet.Protocol.ProtocolConstants : object {
    public static string ApiKeyHeader;
    public static string ServerWarningHeader;
    public static string SessionId;
    private static ProtocolConstants();
}
public class NuGet.Protocol.Providers.OwnerDetailsUriResourceV3Provider : ResourceProvider {
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("NuGet.Protocol.Providers.OwnerDetailsUriResourceV3Provider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
public class NuGet.Protocol.Providers.VulnerabilityInfoResourceV3Provider : ResourceProvider {
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("NuGet.Protocol.Providers.VulnerabilityInfoResourceV3Provider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
public class NuGet.Protocol.ProxyAuthenticationHandler : DelegatingHandler {
    public static int MaxAuthRetries;
    private static string BasicAuthenticationType;
    private static SemaphoreSlim _credentialPromptLock;
    private HttpClientHandler _clientHandler;
    private ICredentialService _credentialService;
    private IProxyCredentialCache _credentialCache;
    private int _authRetries;
    public ProxyAuthenticationHandler(HttpClientHandler clientHandler, ICredentialService credentialService, IProxyCredentialCache credentialCache);
    private static ProxyAuthenticationHandler();
    [AsyncStateMachineAttribute("NuGet.Protocol.ProxyAuthenticationHandler/<SendAsync>d__8")]
protected virtual Task`1<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken);
    private static bool ProxyAuthenticationRequired(Exception ex);
    private static HttpWebResponse ExtractResponse(Exception ex);
    private static bool IsMonoProxyAuthenticationRequiredError(WebException ex);
    [AsyncStateMachineAttribute("NuGet.Protocol.ProxyAuthenticationHandler/<AcquireCredentialsAsync>d__12")]
private Task`1<bool> AcquireCredentialsAsync(Uri requestUri, Guid cacheVersion, ILogger log, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.ProxyAuthenticationHandler/<PromptForProxyCredentialsAsync>d__13")]
private Task`1<NetworkCredential> PromptForProxyCredentialsAsync(Uri proxyAddress, IWebProxy proxy, ILogger log, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<HttpResponseMessage> <>n__0(HttpRequestMessage request, CancellationToken cancellationToken);
}
[ObsoleteAttribute("Use PackageSearchResource instead (via SourceRepository.GetResourceAsync<PackageSearchResource>")]
public class NuGet.Protocol.RawSearchResourceV3 : object {
    private HttpSource _client;
    private Uri[] _searchEndpoints;
    public RawSearchResourceV3(HttpSource client, IEnumerable`1<Uri> searchEndpoints);
    [AsyncStateMachineAttribute("NuGet.Protocol.RawSearchResourceV3/<SearchPage>d__3")]
[ObsoleteAttribute("Use PackageSearchResource instead (via SourceRepository.GetResourceAsync<PackageSearchResource>")]
public virtual Task`1<JObject> SearchPage(string searchTerm, SearchFilter filters, int skip, int take, ILogger log, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.RawSearchResourceV3/<Search>d__4")]
[ObsoleteAttribute("Use PackageSearchResource instead (via SourceRepository.GetResourceAsync<PackageSearchResource>")]
public virtual Task`1<IEnumerable`1<JObject>> Search(string searchTerm, SearchFilter filters, int skip, int take, ILogger log, CancellationToken cancellationToken);
}
[ObsoleteAttribute("Use PackageSearchResource instead (via SourceRepository.GetResourceAsync<PackageSearchResource>")]
public class NuGet.Protocol.RawSearchResourceV3Provider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.RawSearchResourceV3Provider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
internal class NuGet.Protocol.RegistrationInfo : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludePrerelease>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<PackageInfo> <Packages>k__BackingField;
    public string Id { get; public set; }
    public bool IncludePrerelease { get; public set; }
    public IList`1<PackageInfo> Packages { get; private set; }
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
    [CompilerGeneratedAttribute]
public bool get_IncludePrerelease();
    [CompilerGeneratedAttribute]
public void set_IncludePrerelease(bool value);
    [CompilerGeneratedAttribute]
public IList`1<PackageInfo> get_Packages();
    [CompilerGeneratedAttribute]
private void set_Packages(IList`1<PackageInfo> value);
    public void Add(PackageInfo packageInfo);
    public virtual string ToString();
}
public class NuGet.Protocol.RegistrationResourceV3 : object {
    private HttpSource _client;
    [CompilerGeneratedAttribute]
private Uri <BaseUri>k__BackingField;
    public Uri BaseUri { get; }
    public RegistrationResourceV3(HttpSource client, Uri baseUrl);
    [CompilerGeneratedAttribute]
public Uri get_BaseUri();
    public virtual Uri GetUri(string packageId);
    public virtual Uri GetUri(string id, NuGetVersion version);
    public virtual Uri GetUri(PackageIdentity package);
    [AsyncStateMachineAttribute("NuGet.Protocol.RegistrationResourceV3/<GetPackageMetadata>d__8")]
public virtual Task`1<JObject> GetPackageMetadata(PackageIdentity identity, SourceCacheContext cacheContext, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.RegistrationResourceV3/<GetPackageMetadata>d__9")]
public virtual Task`1<IEnumerable`1<JObject>> GetPackageMetadata(string packageId, bool includePrerelease, bool includeUnlisted, SourceCacheContext cacheContext, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.RegistrationResourceV3/<GetPackageMetadata>d__10")]
public virtual Task`1<IEnumerable`1<JObject>> GetPackageMetadata(string packageId, VersionRange range, bool includePrerelease, bool includeUnlisted, SourceCacheContext cacheContext, ILogger log, CancellationToken token);
    public virtual Task`1<IEnumerable`1<JObject>> GetPackageEntries(string packageId, bool includeUnlisted, SourceCacheContext cacheContext, ILogger log, CancellationToken token);
}
public class NuGet.Protocol.RegistrationResourceV3Provider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.RegistrationResourceV3Provider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
public static class NuGet.Protocol.RegistrationUtility : object {
    public static VersionRange CreateVersionRange(string stringToParse);
    [AsyncStateMachineAttribute("NuGet.Protocol.RegistrationUtility/<LoadRanges>d__1")]
public static Task`1<IEnumerable`1<JObject>> LoadRanges(HttpSource httpSource, Uri registrationUri, string packageId, VersionRange range, SourceCacheContext cacheContext, ILogger log, CancellationToken token);
}
public class NuGet.Protocol.RemotePackageArchiveDownloader : object {
    private SourceCacheContext _cacheContext;
    private string _destinationFilePath;
    private Func`2<Exception, Task`1<bool>> _handleExceptionAsync;
    private bool _isDisposed;
    private ILogger _logger;
    private PackageIdentity _packageIdentity;
    private Lazy`1<PackageArchiveReader> _packageReader;
    private FindPackageByIdResource _resource;
    private SemaphoreSlim _throttle;
    [CompilerGeneratedAttribute]
private string <Source>k__BackingField;
    public IAsyncPackageContentReader ContentReader { get; }
    public IAsyncPackageCoreReader CoreReader { get; }
    public ISignedPackageReader SignedPackageReader { get; }
    public string Source { get; }
    public RemotePackageArchiveDownloader(string source, FindPackageByIdResource resource, PackageIdentity packageIdentity, SourceCacheContext cacheContext, ILogger logger);
    public sealed virtual IAsyncPackageContentReader get_ContentReader();
    public sealed virtual IAsyncPackageCoreReader get_CoreReader();
    public sealed virtual ISignedPackageReader get_SignedPackageReader();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Source();
    public sealed virtual void Dispose();
    [AsyncStateMachineAttribute("NuGet.Protocol.RemotePackageArchiveDownloader/<CopyNupkgFileToAsync>d__20")]
public sealed virtual Task`1<bool> CopyNupkgFileToAsync(string destinationFilePath, CancellationToken cancellationToken);
    public sealed virtual Task`1<string> GetPackageHashAsync(string hashAlgorithm, CancellationToken cancellationToken);
    public sealed virtual void SetExceptionHandler(Func`2<Exception, Task`1<bool>> handleExceptionAsync);
    public sealed virtual void SetThrottle(SemaphoreSlim throttle);
    private PackageArchiveReader GetPackageReader();
    private FileStream GetDestinationStream();
    private void ThrowIfDisposed();
}
public class NuGet.Protocol.RemoteV2FindPackageByIdResource : FindPackageByIdResource {
    private static XName _xnameEntry;
    private static XName _xnameContent;
    private static XName _xnameProperties;
    private static XName _xnameId;
    private static XName _xnameVersion;
    private string _baseUri;
    private HttpSource _httpSource;
    private TaskResultCache`2<string, List`1<PackageInfo>> _packageVersionsCache;
    private FindPackagesByIdNupkgDownloader _nupkgDownloader;
    private V2FeedQueryBuilder _queryBuilder;
    private static string ResourceTypeName;
    private static string ThisTypeName;
    [CompilerGeneratedAttribute]
private PackageSource <PackageSource>k__BackingField;
    public PackageSource PackageSource { get; }
    public RemoteV2FindPackageByIdResource(PackageSource packageSource, HttpSource httpSource);
    private static RemoteV2FindPackageByIdResource();
    [CompilerGeneratedAttribute]
public PackageSource get_PackageSource();
    [AsyncStateMachineAttribute("NuGet.Protocol.RemoteV2FindPackageByIdResource/<GetAllVersionsAsync>d__16")]
public virtual Task`1<IEnumerable`1<NuGetVersion>> GetAllVersionsAsync(string id, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.RemoteV2FindPackageByIdResource/<GetDependencyInfoAsync>d__17")]
public virtual Task`1<FindPackageByIdDependencyInfo> GetDependencyInfoAsync(string id, NuGetVersion version, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.RemoteV2FindPackageByIdResource/<CopyNupkgToStreamAsync>d__18")]
public virtual Task`1<bool> CopyNupkgToStreamAsync(string id, NuGetVersion version, Stream destination, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.RemoteV2FindPackageByIdResource/<GetPackageDownloaderAsync>d__19")]
public virtual Task`1<IPackageDownloader> GetPackageDownloaderAsync(PackageIdentity packageIdentity, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.RemoteV2FindPackageByIdResource/<DoesPackageExistAsync>d__20")]
public virtual Task`1<bool> DoesPackageExistAsync(string id, NuGetVersion version, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.RemoteV2FindPackageByIdResource/<GetPackageInfoAsync>d__21")]
private Task`1<PackageInfo> GetPackageInfoAsync(string id, NuGetVersion version, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.RemoteV2FindPackageByIdResource/<EnsurePackagesAsync>d__22")]
private Task`1<IEnumerable`1<PackageInfo>> EnsurePackagesAsync(string id, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.RemoteV2FindPackageByIdResource/<FindPackagesByIdAsyncCore>d__23")]
private Task`1<List`1<PackageInfo>> FindPackagesByIdAsyncCore(string id, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    private static PackageInfo BuildModel(string id, XElement element);
}
public class NuGet.Protocol.RemoteV2FindPackageByIdResourceProvider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.RemoteV2FindPackageByIdResourceProvider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository sourceRepository, CancellationToken token);
}
public class NuGet.Protocol.RemoteV3FindPackageByIdResource : FindPackageByIdResource {
    private SemaphoreSlim _dependencyInfoSemaphore;
    private TaskResultCache`2<string, IEnumerable`1<RemoteSourceDependencyInfo>> _packageVersionsCache;
    private HttpSource _httpSource;
    private FindPackagesByIdNupkgDownloader _nupkgDownloader;
    private DependencyInfoResource _dependencyInfoResource;
    private static string ResourceTypeName;
    private static string ThisTypeName;
    [CompilerGeneratedAttribute]
private SourceRepository <SourceRepository>k__BackingField;
    public SourceRepository SourceRepository { get; }
    public RemoteV3FindPackageByIdResource(SourceRepository sourceRepository, HttpSource httpSource);
    [CompilerGeneratedAttribute]
public SourceRepository get_SourceRepository();
    [AsyncStateMachineAttribute("NuGet.Protocol.RemoteV3FindPackageByIdResource/<GetAllVersionsAsync>d__11")]
public virtual Task`1<IEnumerable`1<NuGetVersion>> GetAllVersionsAsync(string id, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.RemoteV3FindPackageByIdResource/<GetDependencyInfoAsync>d__12")]
public virtual Task`1<FindPackageByIdDependencyInfo> GetDependencyInfoAsync(string id, NuGetVersion version, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.RemoteV3FindPackageByIdResource/<CopyNupkgToStreamAsync>d__13")]
public virtual Task`1<bool> CopyNupkgToStreamAsync(string id, NuGetVersion version, Stream destination, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.RemoteV3FindPackageByIdResource/<GetPackageDownloaderAsync>d__14")]
public virtual Task`1<IPackageDownloader> GetPackageDownloaderAsync(PackageIdentity packageIdentity, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.RemoteV3FindPackageByIdResource/<DoesPackageExistAsync>d__15")]
public virtual Task`1<bool> DoesPackageExistAsync(string id, NuGetVersion version, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.RemoteV3FindPackageByIdResource/<GetPackageInfoAsync>d__16")]
private Task`1<RemoteSourceDependencyInfo> GetPackageInfoAsync(string id, NuGetVersion version, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    private Task`1<IEnumerable`1<RemoteSourceDependencyInfo>> EnsurePackagesAsync(string id, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.RemoteV3FindPackageByIdResource/<FindPackagesByIdAsyncCore>d__18")]
private Task`1<IEnumerable`1<RemoteSourceDependencyInfo>> FindPackagesByIdAsyncCore(string id, SourceCacheContext sourceCacheContext, ILogger logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.RemoteV3FindPackageByIdResource/<EnsureDependencyProvider>d__19")]
private Task EnsureDependencyProvider(CancellationToken cancellationToken);
}
public class NuGet.Protocol.RemoteV3FindPackageByIdResourceProvider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.RemoteV3FindPackageByIdResourceProvider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository sourceRepository, CancellationToken token);
}
public class NuGet.Protocol.ReportAbuseResourceV3 : object {
    private string _uriTemplate;
    public ReportAbuseResourceV3(string uriTemplate);
    public Uri GetReportAbuseUrl(string id, NuGetVersion version);
    private static bool IsValidUriTemplate(string uriTemplate);
}
public class NuGet.Protocol.ReportAbuseResourceV3Provider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.ReportAbuseResourceV3Provider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
public class NuGet.Protocol.RepositoryCertificateInfo : object {
    [CompilerGeneratedAttribute]
private Fingerprints <Fingerprints>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Subject>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Issuer>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <NotBefore>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <NotAfter>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContentUrl>k__BackingField;
    [JsonPropertyAttribute]
public Fingerprints Fingerprints { get; private set; }
    [JsonPropertyAttribute]
public string Subject { get; private set; }
    [JsonPropertyAttribute]
public string Issuer { get; private set; }
    [JsonPropertyAttribute]
public DateTimeOffset NotBefore { get; private set; }
    [JsonPropertyAttribute]
public DateTimeOffset NotAfter { get; private set; }
    [JsonPropertyAttribute]
public string ContentUrl { get; private set; }
    [CompilerGeneratedAttribute]
public sealed virtual Fingerprints get_Fingerprints();
    [CompilerGeneratedAttribute]
private void set_Fingerprints(Fingerprints value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Subject();
    [CompilerGeneratedAttribute]
private void set_Subject(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Issuer();
    [CompilerGeneratedAttribute]
private void set_Issuer(string value);
    [CompilerGeneratedAttribute]
public sealed virtual DateTimeOffset get_NotBefore();
    [CompilerGeneratedAttribute]
private void set_NotBefore(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public sealed virtual DateTimeOffset get_NotAfter();
    [CompilerGeneratedAttribute]
private void set_NotAfter(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ContentUrl();
    [CompilerGeneratedAttribute]
private void set_ContentUrl(string value);
}
public class NuGet.Protocol.RepositorySignatureResource : object {
    [CompilerGeneratedAttribute]
private string <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllRepositorySigned>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<IRepositoryCertificateInfo> <RepositoryCertificateInfos>k__BackingField;
    public string Source { get; }
    public bool AllRepositorySigned { get; }
    public IEnumerable`1<IRepositoryCertificateInfo> RepositoryCertificateInfos { get; }
    public RepositorySignatureResource(JObject repoSignInformationContent, SourceRepository source);
    public RepositorySignatureResource(bool allRepositorySigned, IEnumerable`1<IRepositoryCertificateInfo> repositoryCertInfos);
    [CompilerGeneratedAttribute]
public string get_Source();
    [CompilerGeneratedAttribute]
public bool get_AllRepositorySigned();
    [CompilerGeneratedAttribute]
public IEnumerable`1<IRepositoryCertificateInfo> get_RepositoryCertificateInfos();
    public void UpdateRepositorySignatureInfo();
}
public class NuGet.Protocol.RepositorySignatureResourceProvider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.RepositorySignatureResourceProvider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.RepositorySignatureResourceProvider/<GetRepositorySignatureResourceAsync>d__2")]
private Task`1<RepositorySignatureResource> GetRepositorySignatureResourceAsync(SourceRepository source, ServiceIndexEntry serviceEntry, ILogger log, CancellationToken token);
    private static string GenerateCacheKey(ServiceIndexEntry serviceEntry);
}
internal static class NuGet.Protocol.ResolverMetadataClient : object {
    [AsyncStateMachineAttribute("NuGet.Protocol.ResolverMetadataClient/<GetDependencies>d__0")]
public static Task`1<IEnumerable`1<RemoteSourceDependencyInfo>> GetDependencies(HttpSource httpClient, Uri registrationUri, string packageId, VersionRange range, SourceCacheContext cacheContext, ILogger log, CancellationToken token);
    private static RemoteSourceDependencyInfo ProcessPackageVersion(JObject packageObj, NuGetVersion version);
    [AsyncStateMachineAttribute("NuGet.Protocol.ResolverMetadataClient/<GetRegistrationInfo>d__2")]
public static Task`1<RegistrationInfo> GetRegistrationInfo(HttpSource httpClient, Uri registrationUri, string packageId, VersionRange range, SourceCacheContext cacheContext, NuGetFramework projectTargetFramework, ILogger log, CancellationToken token);
    private static NuGetFramework GetFramework(JObject dependencyGroupObj);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NuGet.Protocol.Resources.OwnerDetailsUriTemplateResourceV3 : object {
    private string _template;
    private OwnerDetailsUriTemplateResourceV3(string template);
    public static OwnerDetailsUriTemplateResourceV3 CreateOrNull(Uri uriTemplate);
    public Uri GetUri(string owner);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NuGet.Protocol.Resources.VulnerabilityInfoResourceV3 : object {
    private SourceRepository _sourceRepository;
    internal VulnerabilityInfoResourceV3(SourceRepository sourceRepository);
    [AsyncStateMachineAttribute("NuGet.Protocol.Resources.VulnerabilityInfoResourceV3/<GetVulnerabilityFilesAsync>d__2")]
public Task`1<IReadOnlyList`1<V3VulnerabilityIndexEntry>> GetVulnerabilityFilesAsync(SourceCacheContext cacheContext, ILogger log, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.Resources.VulnerabilityInfoResourceV3/<GetVulnerabilityDataAsync>d__3")]
public Task`1<IReadOnlyDictionary`2<string, IReadOnlyList`1<PackageVulnerabilityInfo>>> GetVulnerabilityDataAsync(V3VulnerabilityIndexEntry vulnerabilityPage, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.Resources.VulnerabilityInfoResourceV3/<GetVulnerabilityInfoAsync>d__4")]
public sealed virtual Task`1<GetVulnerabilityInfoResult> GetVulnerabilityInfoAsync(SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    private IReadOnlyList`1<V3VulnerabilityIndexEntry> GetValidIndexEntries(IReadOnlyList`1<V3VulnerabilityIndexEntry> indexEntries, List`1& exceptions);
    private static void AddException(Exception exception, List`1& exceptions);
    [AsyncStateMachineAttribute("NuGet.Protocol.Resources.VulnerabilityInfoResourceV3/<<GetVulnerabilityFilesAsync>g__GetIndexUrlAsync|2_0>d")]
[CompilerGeneratedAttribute]
private Task`1<Uri> <GetVulnerabilityFilesAsync>g__GetIndexUrlAsync|2_0(CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static AggregateException <GetVulnerabilityInfoAsync>g__ToAggregateException|4_0(IEnumerable`1<Exception> exceptions);
}
public class NuGet.Protocol.SafeBoolConverter : JsonConverter {
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public virtual bool CanConvert(Type objectType);
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
}
public class NuGet.Protocol.SafeUriConverter : JsonConverter {
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public virtual bool CanConvert(Type objectType);
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
}
public class NuGet.Protocol.SemanticVersionConverter : JsonConverter {
    public virtual bool CanConvert(Type objectType);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
}
public class NuGet.Protocol.SemaphoreSlimThrottle : object {
    private SemaphoreSlim _semaphore;
    public int CurrentCount { get; }
    public SemaphoreSlimThrottle(SemaphoreSlim semaphore);
    public int get_CurrentCount();
    [AsyncStateMachineAttribute("NuGet.Protocol.SemaphoreSlimThrottle/<WaitAsync>d__4")]
public sealed virtual Task WaitAsync();
    public sealed virtual void Release();
    public static SemaphoreSlimThrottle CreateBinarySemaphore();
    public static SemaphoreSlimThrottle CreateSemaphoreThrottle(int initialCount);
}
public class NuGet.Protocol.ServerWarningLogHandler : DelegatingHandler {
    public ServerWarningLogHandler(HttpClientHandler clientHandler);
    [AsyncStateMachineAttribute("NuGet.Protocol.ServerWarningLogHandler/<SendAsync>d__1")]
protected virtual Task`1<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<HttpResponseMessage> <>n__0(HttpRequestMessage request, CancellationToken cancellationToken);
}
public class NuGet.Protocol.ServiceIndexEntry : object {
    [CompilerGeneratedAttribute]
private Uri <Uri>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private SemanticVersion <ClientVersion>k__BackingField;
    public Uri Uri { get; }
    public string Type { get; }
    public SemanticVersion ClientVersion { get; }
    public ServiceIndexEntry(Uri serviceUri, string serviceType, SemanticVersion clientVersion);
    [CompilerGeneratedAttribute]
public Uri get_Uri();
    [CompilerGeneratedAttribute]
public string get_Type();
    [CompilerGeneratedAttribute]
public SemanticVersion get_ClientVersion();
}
public class NuGet.Protocol.ServiceIndexResourceV3 : object {
    private string _json;
    private IDictionary`2<string, List`1<ServiceIndexEntry>> _index;
    private DateTime _requestTime;
    private static IReadOnlyList`1<ServiceIndexEntry> _emptyEntries;
    private static SemanticVersion _defaultVersion;
    public DateTime RequestTime { get; }
    public IReadOnlyList`1<ServiceIndexEntry> Entries { get; }
    public string Json { get; }
    public ServiceIndexResourceV3(JObject index, DateTime requestTime);
    private static ServiceIndexResourceV3();
    public virtual DateTime get_RequestTime();
    public virtual IReadOnlyList`1<ServiceIndexEntry> get_Entries();
    public virtual string get_Json();
    public virtual IReadOnlyList`1<ServiceIndexEntry> GetServiceEntries(String[] orderedTypes);
    public virtual IReadOnlyList`1<ServiceIndexEntry> GetServiceEntries(NuGetVersion clientVersion, String[] orderedTypes);
    private IReadOnlyList`1<ServiceIndexEntry> GetBestVersionMatchForType(NuGetVersion clientVersion, List`1<ServiceIndexEntry> entries);
    public virtual Uri GetServiceEntryUri(String[] orderedTypes);
    public virtual IReadOnlyList`1<Uri> GetServiceEntryUris(String[] orderedTypes);
    public virtual IReadOnlyList`1<Uri> GetServiceEntryUris(NuGetVersion clientVersion, String[] orderedTypes);
    private static IDictionary`2<string, List`1<ServiceIndexEntry>> MakeLookup(JObject index);
    [IteratorStateMachineAttribute("NuGet.Protocol.ServiceIndexResourceV3/<GetValues>d__19")]
private static IEnumerable`1<string> GetValues(JToken token);
}
public class NuGet.Protocol.ServiceIndexResourceV3Provider : ResourceProvider {
    private static TimeSpan _defaultCacheDuration;
    private ConcurrentDictionary`2<string, ServiceIndexCacheInfo> _cache;
    private SemaphoreSlim _semaphore;
    private EnhancedHttpRetryHelper _enhancedHttpRetryHelper;
    [CompilerGeneratedAttribute]
private TimeSpan <MaxCacheDuration>k__BackingField;
    public TimeSpan MaxCacheDuration { get; protected set; }
    internal ServiceIndexResourceV3Provider(IEnvironmentVariableReader environmentVariableReader);
    private static ServiceIndexResourceV3Provider();
    [CompilerGeneratedAttribute]
public TimeSpan get_MaxCacheDuration();
    [CompilerGeneratedAttribute]
protected void set_MaxCacheDuration(TimeSpan value);
    [AsyncStateMachineAttribute("NuGet.Protocol.ServiceIndexResourceV3Provider/<TryCreate>d__10")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.ServiceIndexResourceV3Provider/<GetServiceIndexResourceV3>d__11")]
private Task`1<ServiceIndexResourceV3> GetServiceIndexResourceV3(SourceRepository source, DateTime utcNow, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.ServiceIndexResourceV3Provider/<ConsumeServiceIndexStreamAsync>d__12")]
private Task`1<ServiceIndexResourceV3> ConsumeServiceIndexStreamAsync(Stream stream, DateTime utcNow, CancellationToken token);
}
public static class NuGet.Protocol.ServiceTypes : object {
    public static string Version200;
    public static string Version300beta;
    public static string Version300rc;
    public static string Version300;
    public static string Version340;
    public static string Version360;
    public static string Versioned;
    public static string Version470;
    public static string Version490;
    public static string Version500;
    public static string Version510;
    internal static string Version670;
    internal static string Version6110;
    public static String[] SearchQueryService;
    public static String[] RegistrationsBaseUrl;
    public static String[] SearchAutocompleteService;
    public static String[] ReportAbuse;
    public static String[] PackageDetailsUriTemplate;
    public static String[] LegacyGallery;
    public static String[] PackagePublish;
    public static String[] PackageBaseAddress;
    public static String[] RepositorySignatures;
    public static String[] SymbolPackagePublish;
    internal static String[] VulnerabilityInfo;
    internal static String[] OwnerDetailsUriTemplate;
    private static ServiceTypes();
}
[ExtensionAttribute]
public static class NuGet.Protocol.StreamExtensions : object {
    public static int BufferSize;
    private static StreamExtensions();
    [AsyncStateMachineAttribute("NuGet.Protocol.StreamExtensions/<CopyToAsync>d__1")]
[ExtensionAttribute]
public static Task CopyToAsync(Stream stream, Stream destination, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.StreamExtensions/<AsJObjectAsync>d__2")]
[ExtensionAttribute]
internal static Task`1<JObject> AsJObjectAsync(Stream stream, CancellationToken token);
    [ExtensionAttribute]
internal static Task`1<Stream> AsSeekableStreamAsync(Stream stream, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.StreamExtensions/<AsSeekableStreamAsync>d__4")]
[ExtensionAttribute]
internal static Task`1<Stream> AsSeekableStreamAsync(Stream stream, bool leaveStreamOpen, CancellationToken token);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "17.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class NuGet.Protocol.Strings : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string AddPackage_ExistingPackageInvalid { get; }
    internal static string AddPackage_PackageAlreadyExists { get; }
    internal static string AddPackage_SuccessfullyAdded { get; }
    internal static string Argument_Cannot_Be_Null_Or_Empty { get; }
    internal static string ArgumentCannotBeNullOrEmpty { get; }
    internal static string DefaultSymbolServer { get; }
    internal static string DeleteCommandCanceled { get; }
    internal static string DeleteCommandConfirm { get; }
    internal static string DeleteCommandDeletedPackage { get; }
    internal static string DeleteCommandDeletingPackage { get; }
    internal static string DeletePackage_NotFound { get; }
    internal static string Error_DownloadTimeout { get; }
    internal static string Http_CredentialsForForbidden { get; }
    internal static string Http_CredentialsForProxy { get; }
    internal static string Http_CredentialsForUnauthorized { get; }
    internal static string Http_RequestLog { get; }
    internal static string Http_ResponseLog { get; }
    internal static string Http_ResponseLogWithRetryAfter { get; }
    internal static string Http_Timeout { get; }
    internal static string InvalidVersionFolder { get; }
    internal static string LiveFeed { get; }
    internal static string LoadFileFromNupkg_FileNotFound { get; }
    internal static string LoadFileFromNupkg_FileTooLarge { get; }
    internal static string LoadFileFromNupkg_UnknownProblemLoadingTheFile { get; }
    internal static string Log_CanceledNupkgDownload { get; }
    internal static string Log_ErrorDownloading { get; }
    internal static string Log_FailedToDownloadPackage { get; }
    internal static string Log_FailedToFetchV2Feed { get; }
    internal static string Log_FailedToFetchV2FeedHttp { get; }
    internal static string Log_FailedToGetNuspecStream { get; }
    internal static string Log_FailedToParseRepoSignInfor { get; }
    internal static string Log_FailedToReadRepositorySignature { get; }
    internal static string Log_FailedToReadServiceIndex { get; }
    internal static string Log_FailedToRetrievePackage { get; }
    internal static string Log_FailedToVerifyRootDirectory { get; }
    internal static string Log_FailedToVerifyValidFile { get; }
    internal static string Log_FileIsCorrupt { get; }
    internal static string Log_InvalidCacheEntry { get; }
    internal static string Log_InvalidNupkgFromUrl { get; }
    internal static string Log_LocalSourceNotExist { get; }
    internal static string Log_RetryingFindPackagesById { get; }
    internal static string Log_RetryingHttp { get; }
    internal static string Log_RetryingRepositorySignature { get; }
    internal static string Log_RetryingServiceIndex { get; }
    internal static string NoApiKeyFound { get; }
    internal static string NuGetLicense_LicenseExpressionVersionTooHigh { get; }
    internal static string NuGetLicenseExpression_NonStandardIdentifier { get; }
    internal static string NupkgPath_Invalid { get; }
    internal static string NupkgPath_InvalidEx { get; }
    internal static string OneOrMoreUrisMustBeSpecified { get; }
    internal static string PackageNotFound { get; }
    internal static string PackageServerEndpoint_NotSupported { get; }
    internal static string Path_Invalid { get; }
    internal static string Path_Invalid_NotFileNotUnc { get; }
    internal static string Plugin_ConnectionAlreadyStarted { get; }
    internal static string Plugin_ConnectionIsClosed { get; }
    internal static string Plugin_DownloadNotSupportedSinceUnsignedNotAllowed { get; }
    internal static string Plugin_Exception { get; }
    internal static string Plugin_FailedOnCreation { get; }
    internal static string Plugin_FailedOperationForPackage { get; }
    internal static string Plugin_FailureQueryingPackageVersions { get; }
    internal static string Plugin_Fault { get; }
    internal static string Plugin_FileNotFound { get; }
    internal static string Plugin_HandshakeFailed { get; }
    internal static string Plugin_HandshakeRequestHandlerAlreadyExists { get; }
    internal static string Plugin_IdleTimeoutMustBeGreaterThanOrEqualToInfiniteTimeSpan { get; }
    internal static string Plugin_InitializationFailed { get; }
    internal static string Plugin_InvalidEmbeddedSignature { get; }
    internal static string Plugin_InvalidMessageType { get; }
    internal static string Plugin_InvalidPluginFilePath { get; }
    internal static string Plugin_NotConnected { get; }
    internal static string Plugin_PackageDownloadFailed { get; }
    internal static string Plugin_ProblemStartingPlugin { get; }
    internal static string Plugin_ProtocolException { get; }
    internal static string Plugin_ProtocolVersionNotSupportedOnError { get; }
    internal static string Plugin_ProtocolVersionOutOfRange { get; }
    internal static string Plugin_RequestContextDoesNotExist { get; }
    internal static string Plugin_RequestHandlerDoesNotExist { get; }
    internal static string Plugin_TimeoutOutOfRange { get; }
    internal static string Plugin_UnrecognizedEnumValue { get; }
    internal static string Plugin_UnrecognizedOperationClaims { get; }
    internal static string Protocol_BadSource { get; }
    internal static string Protocol_duplicateUri { get; }
    internal static string Protocol_InvalidJsonObject { get; }
    internal static string Protocol_InvalidXml { get; }
    internal static string Protocol_MalformedMetadataError { get; }
    internal static string Protocol_MissingSearchService { get; }
    internal static string Protocol_MissingVersion { get; }
    internal static string Protocol_PackageMetadataError { get; }
    internal static string Protocol_Search_LocalSourceNotFound { get; }
    internal static string Protocol_UnsupportedVersion { get; }
    internal static string PushCommandPackagePushed { get; }
    internal static string PushCommandPushingPackage { get; }
    internal static string PushCommandSkipDuplicateAdvertiseDotnetExe { get; }
    internal static string PushCommandSkipDuplicateAdvertiseNuGetExe { get; }
    internal static string PushCommandSkipDuplicateNotImplemented { get; }
    internal static string RepositoryContentUrlMustBeHttps { get; }
    internal static string RepositorySignaturesResourceMustBeHttps { get; }
    internal static string StringCannotBeNullOrEmpty { get; }
    internal static string UnableToFindFile { get; }
    internal static string UnableToParseFolderV3Version { get; }
    internal static string Vulnerability_TooManyPages { get; }
    internal static string VulnerabilityPage_CouldNotLoad { get; }
    internal static string VulnerabilityPage_HasNoName { get; }
    internal static string VulnerabilityPage_NameHasInvalidCharacters { get; }
    internal static string VulnerabilityPage_NameNotUnique { get; }
    internal static string VulnerabilityPage_NameTooLong { get; }
    internal static string VulnerabilityPage_NoUrl { get; }
    internal static string VulnerabilityPage_UrlNotHttp { get; }
    internal static string Warning_HttpServerUsage { get; }
    internal static string Warning_SymbolServerNotConfigured { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_AddPackage_ExistingPackageInvalid();
    internal static string get_AddPackage_PackageAlreadyExists();
    internal static string get_AddPackage_SuccessfullyAdded();
    internal static string get_Argument_Cannot_Be_Null_Or_Empty();
    internal static string get_ArgumentCannotBeNullOrEmpty();
    internal static string get_DefaultSymbolServer();
    internal static string get_DeleteCommandCanceled();
    internal static string get_DeleteCommandConfirm();
    internal static string get_DeleteCommandDeletedPackage();
    internal static string get_DeleteCommandDeletingPackage();
    internal static string get_DeletePackage_NotFound();
    internal static string get_Error_DownloadTimeout();
    internal static string get_Http_CredentialsForForbidden();
    internal static string get_Http_CredentialsForProxy();
    internal static string get_Http_CredentialsForUnauthorized();
    internal static string get_Http_RequestLog();
    internal static string get_Http_ResponseLog();
    internal static string get_Http_ResponseLogWithRetryAfter();
    internal static string get_Http_Timeout();
    internal static string get_InvalidVersionFolder();
    internal static string get_LiveFeed();
    internal static string get_LoadFileFromNupkg_FileNotFound();
    internal static string get_LoadFileFromNupkg_FileTooLarge();
    internal static string get_LoadFileFromNupkg_UnknownProblemLoadingTheFile();
    internal static string get_Log_CanceledNupkgDownload();
    internal static string get_Log_ErrorDownloading();
    internal static string get_Log_FailedToDownloadPackage();
    internal static string get_Log_FailedToFetchV2Feed();
    internal static string get_Log_FailedToFetchV2FeedHttp();
    internal static string get_Log_FailedToGetNuspecStream();
    internal static string get_Log_FailedToParseRepoSignInfor();
    internal static string get_Log_FailedToReadRepositorySignature();
    internal static string get_Log_FailedToReadServiceIndex();
    internal static string get_Log_FailedToRetrievePackage();
    internal static string get_Log_FailedToVerifyRootDirectory();
    internal static string get_Log_FailedToVerifyValidFile();
    internal static string get_Log_FileIsCorrupt();
    internal static string get_Log_InvalidCacheEntry();
    internal static string get_Log_InvalidNupkgFromUrl();
    internal static string get_Log_LocalSourceNotExist();
    internal static string get_Log_RetryingFindPackagesById();
    internal static string get_Log_RetryingHttp();
    internal static string get_Log_RetryingRepositorySignature();
    internal static string get_Log_RetryingServiceIndex();
    internal static string get_NoApiKeyFound();
    internal static string get_NuGetLicense_LicenseExpressionVersionTooHigh();
    internal static string get_NuGetLicenseExpression_NonStandardIdentifier();
    internal static string get_NupkgPath_Invalid();
    internal static string get_NupkgPath_InvalidEx();
    internal static string get_OneOrMoreUrisMustBeSpecified();
    internal static string get_PackageNotFound();
    internal static string get_PackageServerEndpoint_NotSupported();
    internal static string get_Path_Invalid();
    internal static string get_Path_Invalid_NotFileNotUnc();
    internal static string get_Plugin_ConnectionAlreadyStarted();
    internal static string get_Plugin_ConnectionIsClosed();
    internal static string get_Plugin_DownloadNotSupportedSinceUnsignedNotAllowed();
    internal static string get_Plugin_Exception();
    internal static string get_Plugin_FailedOnCreation();
    internal static string get_Plugin_FailedOperationForPackage();
    internal static string get_Plugin_FailureQueryingPackageVersions();
    internal static string get_Plugin_Fault();
    internal static string get_Plugin_FileNotFound();
    internal static string get_Plugin_HandshakeFailed();
    internal static string get_Plugin_HandshakeRequestHandlerAlreadyExists();
    internal static string get_Plugin_IdleTimeoutMustBeGreaterThanOrEqualToInfiniteTimeSpan();
    internal static string get_Plugin_InitializationFailed();
    internal static string get_Plugin_InvalidEmbeddedSignature();
    internal static string get_Plugin_InvalidMessageType();
    internal static string get_Plugin_InvalidPluginFilePath();
    internal static string get_Plugin_NotConnected();
    internal static string get_Plugin_PackageDownloadFailed();
    internal static string get_Plugin_ProblemStartingPlugin();
    internal static string get_Plugin_ProtocolException();
    internal static string get_Plugin_ProtocolVersionNotSupportedOnError();
    internal static string get_Plugin_ProtocolVersionOutOfRange();
    internal static string get_Plugin_RequestContextDoesNotExist();
    internal static string get_Plugin_RequestHandlerDoesNotExist();
    internal static string get_Plugin_TimeoutOutOfRange();
    internal static string get_Plugin_UnrecognizedEnumValue();
    internal static string get_Plugin_UnrecognizedOperationClaims();
    internal static string get_Protocol_BadSource();
    internal static string get_Protocol_duplicateUri();
    internal static string get_Protocol_InvalidJsonObject();
    internal static string get_Protocol_InvalidXml();
    internal static string get_Protocol_MalformedMetadataError();
    internal static string get_Protocol_MissingSearchService();
    internal static string get_Protocol_MissingVersion();
    internal static string get_Protocol_PackageMetadataError();
    internal static string get_Protocol_Search_LocalSourceNotFound();
    internal static string get_Protocol_UnsupportedVersion();
    internal static string get_PushCommandPackagePushed();
    internal static string get_PushCommandPushingPackage();
    internal static string get_PushCommandSkipDuplicateAdvertiseDotnetExe();
    internal static string get_PushCommandSkipDuplicateAdvertiseNuGetExe();
    internal static string get_PushCommandSkipDuplicateNotImplemented();
    internal static string get_RepositoryContentUrlMustBeHttps();
    internal static string get_RepositorySignaturesResourceMustBeHttps();
    internal static string get_StringCannotBeNullOrEmpty();
    internal static string get_UnableToFindFile();
    internal static string get_UnableToParseFolderV3Version();
    internal static string get_Vulnerability_TooManyPages();
    internal static string get_VulnerabilityPage_CouldNotLoad();
    internal static string get_VulnerabilityPage_HasNoName();
    internal static string get_VulnerabilityPage_NameHasInvalidCharacters();
    internal static string get_VulnerabilityPage_NameNotUnique();
    internal static string get_VulnerabilityPage_NameTooLong();
    internal static string get_VulnerabilityPage_NoUrl();
    internal static string get_VulnerabilityPage_UrlNotHttp();
    internal static string get_Warning_HttpServerUsage();
    internal static string get_Warning_SymbolServerNotConfigured();
}
public class NuGet.Protocol.StsAuthenticationHandler : DelegatingHandler {
    private static SemaphoreSlim _credentialPromptLock;
    public static string STSEndPointHeader;
    public static string STSRealmHeader;
    public static string STSTokenHeader;
    private Uri _baseUri;
    private TokenStore _tokenStore;
    private Func`3<string, string, string> _tokenFactory;
    public StsAuthenticationHandler(PackageSource packageSource, TokenStore tokenStore);
    public StsAuthenticationHandler(PackageSource packageSource, TokenStore tokenStore, Func`3<string, string, string> tokenFactory);
    private static StsAuthenticationHandler();
    [AsyncStateMachineAttribute("NuGet.Protocol.StsAuthenticationHandler/<SendAsync>d__9")]
protected virtual Task`1<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken);
    private void PrepareSTSRequest(HttpRequestMessage request);
    public bool TryRetrieveSTSToken(HttpResponseMessage response);
    private static string AcquireSTSToken(string endpoint, string realm);
    private static string GetHeader(HttpResponseMessage response, string header);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<HttpResponseMessage> <>n__0(HttpRequestMessage request, CancellationToken cancellationToken);
}
public class NuGet.Protocol.SymbolPackageUpdateResourceV3Provider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.SymbolPackageUpdateResourceV3Provider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
public static class NuGet.Protocol.TimeoutUtility : object {
    [AsyncStateMachineAttribute("NuGet.Protocol.TimeoutUtility/<StartWithTimeout>d__0`1")]
public static Task`1<T> StartWithTimeout(Func`2<CancellationToken, Task`1<T>> getTask, TimeSpan timeout, string timeoutMessage, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.TimeoutUtility/<StartWithTimeout>d__1")]
public static Task StartWithTimeout(Func`2<CancellationToken, Task> getTask, TimeSpan timeout, string timeoutMessage, CancellationToken token);
}
public class NuGet.Protocol.TokenStore : object {
    private ConcurrentDictionary`2<Uri, string> _tokenCache;
    [CompilerGeneratedAttribute]
private static TokenStore <Instance>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <Version>k__BackingField;
    public static TokenStore Instance { get; }
    public Guid Version { get; private set; }
    private static TokenStore();
    [CompilerGeneratedAttribute]
public static TokenStore get_Instance();
    [CompilerGeneratedAttribute]
public Guid get_Version();
    [CompilerGeneratedAttribute]
private void set_Version(Guid value);
    public string GetToken(Uri sourceUri);
    public void AddToken(Uri sourceUri, string token);
    private void StoreToken(Uri uri, string token);
    private static Uri GetRootUri(Uri uri);
}
internal static class NuGet.Protocol.Trim : object {
    public static void TrimByAllowedVersions(RegistrationInfo registrationInfo, IDictionary`2<string, VersionRange> allowedVersions);
    private static void Execute(RegistrationInfo registrationInfo, KeyValuePair`2<string, VersionRange> allowedVersion);
    private static void Pass1(PackageInfo packageInfo, KeyValuePair`2<string, VersionRange> allowedVersion);
    private static void Pass1(RegistrationInfo registrationInfo, KeyValuePair`2<string, VersionRange> allowedVersion);
    private static void Pass2(PackageInfo packageInfo, Boolean& updated);
    private static void Pass2(RegistrationInfo registrationInfo, Boolean& updated);
    private static bool CheckDependenciesExists(PackageInfo packageInfo);
}
internal static class NuGet.Protocol.Types : object {
    public static Uri PackageSearchResult;
    public static Uri PackageIdentity;
    public static Uri PackageDescription;
    public static Uri PackageLicensing;
    public static Uri PackageDependencies;
    public static Uri DependencyGroup;
    public static Uri Dependency;
    public static Uri Stats;
    private static Types();
}
public class NuGet.Protocol.V2FeedListResource : ListResource {
    private ILegacyFeedCapabilityResource _feedCapabilities;
    private IV2FeedParser _feedParser;
    private string _baseAddress;
    private static int Take;
    public string Source { get; }
    public V2FeedListResource(IV2FeedParser feedParser, ILegacyFeedCapabilityResource feedCapabilities, string baseAddress);
    public virtual string get_Source();
    [AsyncStateMachineAttribute("NuGet.Protocol.V2FeedListResource/<ListAsync>d__7")]
public virtual Task`1<IEnumerableAsync`1<IPackageSearchMetadata>> ListAsync(string searchTerm, bool prerelease, bool allVersions, bool includeDelisted, ILogger logger, CancellationToken token);
}
public class NuGet.Protocol.V2FeedListResourceProvider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.V2FeedListResourceProvider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
public class NuGet.Protocol.V2FeedPackageInfo : PackageIdentity {
    private string _title;
    private string _summary;
    private String[] _authors;
    private string _description;
    private String[] _owners;
    private string _iconUrl;
    private string _licenseUrl;
    private string _projectUrl;
    private string _reportAbuseUrl;
    private string _galleryDetailsUrl;
    private string _tags;
    private string _downloadCount;
    private bool _requireLicenseAcceptance;
    private Nullable`1<DateTimeOffset> _created;
    private Nullable`1<DateTimeOffset> _lastEdited;
    private Nullable`1<DateTimeOffset> _published;
    private string _dependencies;
    private string _downloadUrl;
    private string _packageHash;
    private string _packageHashAlgorithm;
    private NuGetVersion _minClientVersion;
    private static string NullString;
    public string Title { get; }
    public string Summary { get; }
    public string Description { get; }
    public IEnumerable`1<string> Authors { get; }
    public IEnumerable`1<string> Owners { get; }
    public string IconUrl { get; }
    public string LicenseUrl { get; }
    public string ProjectUrl { get; }
    public string DownloadUrl { get; }
    public string ReportAbuseUrl { get; }
    public string GalleryDetailsUrl { get; }
    public string Tags { get; }
    public string DownloadCount { get; }
    public int DownloadCountAsInt { get; }
    public Nullable`1<DateTimeOffset> Created { get; }
    public Nullable`1<DateTimeOffset> LastEdited { get; }
    public Nullable`1<DateTimeOffset> Published { get; }
    public bool IsListed { get; }
    public string Dependencies { get; }
    public IReadOnlyList`1<PackageDependencyGroup> DependencySets { get; }
    public bool RequireLicenseAcceptance { get; }
    public string PackageHash { get; }
    public string PackageHashAlgorithm { get; }
    public NuGetVersion MinClientVersion { get; }
    public V2FeedPackageInfo(PackageIdentity identity, string title, string summary, string description, IEnumerable`1<string> authors, IEnumerable`1<string> owners, string iconUrl, string licenseUrl, string projectUrl, string reportAbuseUrl, string galleryDetailsUrl, string tags, Nullable`1<DateTimeOffset> created, Nullable`1<DateTimeOffset> lastEdited, Nullable`1<DateTimeOffset> published, string dependencies, bool requireLicenseAccept, string downloadUrl, string downloadCount, string packageHash, string packageHashAlgorithm, NuGetVersion minClientVersion);
    public string get_Title();
    public string get_Summary();
    public string get_Description();
    public IEnumerable`1<string> get_Authors();
    public IEnumerable`1<string> get_Owners();
    public string get_IconUrl();
    public string get_LicenseUrl();
    public string get_ProjectUrl();
    public string get_DownloadUrl();
    public string get_ReportAbuseUrl();
    public string get_GalleryDetailsUrl();
    public string get_Tags();
    public string get_DownloadCount();
    public int get_DownloadCountAsInt();
    public Nullable`1<DateTimeOffset> get_Created();
    public Nullable`1<DateTimeOffset> get_LastEdited();
    public Nullable`1<DateTimeOffset> get_Published();
    public bool get_IsListed();
    public string get_Dependencies();
    public IReadOnlyList`1<PackageDependencyGroup> get_DependencySets();
    public bool get_RequireLicenseAcceptance();
    public string get_PackageHash();
    public string get_PackageHashAlgorithm();
    public NuGetVersion get_MinClientVersion();
}
public class NuGet.Protocol.V2FeedPage : object {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<V2FeedPackageInfo> <Items>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NextUri>k__BackingField;
    public IReadOnlyList`1<V2FeedPackageInfo> Items { get; }
    public string NextUri { get; }
    public V2FeedPage(List`1<V2FeedPackageInfo> items, string nextUri);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<V2FeedPackageInfo> get_Items();
    [CompilerGeneratedAttribute]
public string get_NextUri();
}
public class NuGet.Protocol.V2FeedParser : object {
    private static string W3Atom;
    private static string MetadataNS;
    private static string DataServicesNS;
    private static XName _xnameEntry;
    private static XName _xnameTitle;
    private static XName _xnameContent;
    private static XName _xnameLink;
    private static XName _xnameProperties;
    private static XName _xnameId;
    private static XName _xnameVersion;
    private static XName _xnameSummary;
    private static XName _xnameDescription;
    private static XName _xnameIconUrl;
    private static XName _xnameLicenseUrl;
    private static XName _xnameProjectUrl;
    private static XName _xnameTags;
    private static XName _xnameGalleryDetailsUrl;
    private static XName _xnameReportAbuseUrl;
    private static XName _xnameDependencies;
    private static XName _xnameRequireLicenseAcceptance;
    private static XName _xnameDownloadCount;
    private static XName _xnameCreated;
    private static XName _xnameLastEdited;
    private static XName _xnamePublished;
    private static XName _xnameName;
    private static XName _xnameAuthor;
    private static XName _xnamePackageHash;
    private static XName _xnamePackageHashAlgorithm;
    private static XName _xnameMinClientVersion;
    private HttpSource _httpSource;
    private string _baseAddress;
    private V2FeedQueryBuilder _queryBuilder;
    [CompilerGeneratedAttribute]
private string <Source>k__BackingField;
    public string Source { get; private set; }
    public V2FeedParser(HttpSource httpSource, string baseAddress);
    public V2FeedParser(HttpSource httpSource, string baseAddress, string source);
    private static V2FeedParser();
    [CompilerGeneratedAttribute]
public string get_Source();
    [CompilerGeneratedAttribute]
private void set_Source(string value);
    [AsyncStateMachineAttribute("NuGet.Protocol.V2FeedParser/<GetPackage>d__38")]
public Task`1<V2FeedPackageInfo> GetPackage(PackageIdentity package, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.V2FeedParser/<FindPackagesByIdAsync>d__39")]
public Task`1<IReadOnlyList`1<V2FeedPackageInfo>> FindPackagesByIdAsync(string id, bool includeUnlisted, bool includePrerelease, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
    public Task`1<IReadOnlyList`1<V2FeedPackageInfo>> FindPackagesByIdAsync(string id, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.V2FeedParser/<GetPackagesPageAsync>d__41")]
public sealed virtual Task`1<V2FeedPage> GetPackagesPageAsync(string searchTerm, SearchFilter filters, int skip, int take, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.V2FeedParser/<GetSearchPageAsync>d__42")]
public sealed virtual Task`1<V2FeedPage> GetSearchPageAsync(string searchTerm, SearchFilter filters, int skip, int take, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.V2FeedParser/<Search>d__43")]
public Task`1<IReadOnlyList`1<V2FeedPackageInfo>> Search(string searchTerm, SearchFilter filters, int skip, int take, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.V2FeedParser/<DownloadFromUrl>d__44")]
public Task`1<DownloadResourceResult> DownloadFromUrl(PackageIdentity package, Uri downloadUri, PackageDownloadContext downloadContext, string globalPackagesFolder, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.V2FeedParser/<DownloadFromIdentity>d__45")]
public Task`1<DownloadResourceResult> DownloadFromIdentity(PackageIdentity package, PackageDownloadContext downloadContext, string globalPackagesFolder, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
    private IEnumerable`1<V2FeedPackageInfo> ParsePage(XDocument doc, string id, MetadataReferenceCache metadataCache);
    private V2FeedPackageInfo ParsePackage(string id, XElement element, MetadataReferenceCache metadataCache);
    private static string GetString(XElement parent, XName childName);
    private static Nullable`1<DateTimeOffset> GetDate(XElement parent, XName childName);
    [AsyncStateMachineAttribute("NuGet.Protocol.V2FeedParser/<QueryV2FeedAsync>d__50")]
public Task`1<V2FeedPage> QueryV2FeedAsync(string relativeUri, string id, int max, bool ignoreNotFounds, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
    private string GetCacheKey(string relativeUri, int page);
    [AsyncStateMachineAttribute("NuGet.Protocol.V2FeedParser/<LoadXmlAsync>d__52")]
internal Task`1<XDocument> LoadXmlAsync(string uri, string cacheKey, bool ignoreNotFounds, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
    internal static string GetNextUrl(XDocument doc);
    [AsyncStateMachineAttribute("NuGet.Protocol.V2FeedParser/<LoadXmlAsync>d__54")]
internal static Task`1<XDocument> LoadXmlAsync(Stream stream, CancellationToken token);
}
public class NuGet.Protocol.V2FeedQueryBuilder : object {
    private static string IsLatestVersionFilterFlag;
    private static string IsAbsoluteLatestVersionFilterFlag;
    private static string IdProperty;
    private static string SemVerLevel;
    private static string GetSpecificPackageFormat;
    private static string SearchEndpointFormat;
    private static string QueryDelimiter;
    private static string FindPackagesByIdFormat;
    private static string GetPackagesFormat;
    private static string EndpointParenthesis;
    private static string SearchClauseFormat;
    private static string OrFormat;
    private static string AndFormat;
    private static string FilterFormat;
    private static string OrderByFormat;
    private static string SkipFormat;
    private static string TopFormat;
    private static string TagTermFormat;
    private static string FirstParameterFormat;
    private static string ParameterFormat;
    private static string TagsProperty;
    private static String[] _propertiesToSearch;
    private static V2FeedQueryBuilder();
    public string BuildSearchUri(string searchTerm, SearchFilter filters, int skip, int take);
    public string BuildFindPackagesByIdUri(string id);
    public string BuildGetPackageUri(PackageIdentity package);
    public string BuildGetPackagesUri(string searchTerm, SearchFilter filters, Nullable`1<int> skip, Nullable`1<int> take);
    private string BuildTop(Nullable`1<int> top);
    private string BuildSkip(Nullable`1<int> skip);
    private string BuildFilter(string searchTerm, Nullable`1<SearchFilterType> searchFilterType);
    private string BuildOrderBy(Nullable`1<SearchOrderBy> searchOrderBy);
    private string BuildPropertyFilter(Nullable`1<SearchFilterType> searchFilterType);
    private string BuildFieldSearchFilter(string searchTerm);
    private string BuildFieldSearchClause(string term, string property);
    [CompilerGeneratedAttribute]
private string <BuildFieldSearchFilter>b__31_1(string term, string property);
}
public static class NuGet.Protocol.V2FeedUtilities : object {
    public static IPackageSearchMetadata CreatePackageSearchResult(V2FeedPackageInfo package, MetadataReferenceCache metadataCache, SearchFilter filter, V2FeedParser feedParser, ILogger log, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.V2FeedUtilities/<GetVersions>d__1")]
private static Task`1<IEnumerable`1<VersionInfo>> GetVersions(V2FeedPackageInfo package, MetadataReferenceCache metadataCache, SearchFilter filter, V2FeedParser feedParser, ILogger log, CancellationToken cancellationToken);
}
public class NuGet.Protocol.V3FeedListResourceProvider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.V3FeedListResourceProvider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
public class NuGet.Protocol.VersionInfoConverter : JsonConverter {
    public bool CanWrite { get; }
    public virtual bool CanConvert(Type objectType);
    public virtual bool get_CanWrite();
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
}
public class NuGet.Protocol.VersionRangeConverter : JsonConverter {
    public virtual bool CanConvert(Type objectType);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
}
[ExtensionAttribute]
public static class NuGet.Protocol.VisualStudio.FactoryExtensionsVS : object {
    [ExtensionAttribute]
public static SourceRepository GetVisualStudio(RepositoryFactory factory, string source);
    [ExtensionAttribute]
public static SourceRepository GetVisualStudio(RepositoryFactory factory, PackageSource source);
    [IteratorStateMachineAttribute("NuGet.Protocol.VisualStudio.FactoryExtensionsVS/<GetVisualStudio>d__2")]
[ExtensionAttribute]
public static IEnumerable`1<Lazy`1<INuGetResourceProvider>> GetVisualStudio(ProviderFactory factory);
}
public class NuGet.Repositories.LocalPackageInfo : object {
    private Lazy`1<NuspecReader> _nuspec;
    private Lazy`1<IReadOnlyList`1<string>> _files;
    private Lazy`1<string> _sha512;
    private Lazy`1<RuntimeGraph> _runtimeGraph;
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetVersion <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ExpandedPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ManifestPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ZipPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Sha512Path>k__BackingField;
    public string Id { get; }
    public NuGetVersion Version { get; }
    public string ExpandedPath { get; public set; }
    public string ManifestPath { get; }
    public string ZipPath { get; }
    public string Sha512Path { get; }
    public NuspecReader Nuspec { get; }
    public IReadOnlyList`1<string> Files { get; }
    public string Sha512 { get; }
    public RuntimeGraph RuntimeGraph { get; }
    public LocalPackageInfo(string packageId, NuGetVersion version, string path, string manifestPath, string zipPath, string sha512Path, Lazy`1<NuspecReader> nuspec, Lazy`1<IReadOnlyList`1<string>> files, Lazy`1<string> sha512, Lazy`1<RuntimeGraph> runtimeGraph);
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public NuGetVersion get_Version();
    [CompilerGeneratedAttribute]
public string get_ExpandedPath();
    [CompilerGeneratedAttribute]
public void set_ExpandedPath(string value);
    [CompilerGeneratedAttribute]
public string get_ManifestPath();
    [CompilerGeneratedAttribute]
public string get_ZipPath();
    [CompilerGeneratedAttribute]
public string get_Sha512Path();
    public NuspecReader get_Nuspec();
    public IReadOnlyList`1<string> get_Files();
    public string get_Sha512();
    public RuntimeGraph get_RuntimeGraph();
    public virtual string ToString();
}
public class NuGet.Repositories.LocalPackageSourceInfo : object {
    [CompilerGeneratedAttribute]
private NuGetv3LocalRepository <Repository>k__BackingField;
    [CompilerGeneratedAttribute]
private LocalPackageInfo <Package>k__BackingField;
    public NuGetv3LocalRepository Repository { get; }
    public LocalPackageInfo Package { get; }
    public LocalPackageSourceInfo(NuGetv3LocalRepository repository, LocalPackageInfo package);
    [CompilerGeneratedAttribute]
public NuGetv3LocalRepository get_Repository();
    [CompilerGeneratedAttribute]
public LocalPackageInfo get_Package();
}
public class NuGet.Repositories.NuGetv3LocalRepository : object {
    private ConcurrentDictionary`2<string, LocalPackageInfo> _packageCache;
    private ConcurrentDictionary`2<string, List`1<LocalPackageInfo>> _cache;
    private ConcurrentDictionary`2<string, object> _idLocks;
    private LocalPackageFileCache _packageFileCache;
    private bool _isFallbackFolder;
    private bool _updateLastAccessTime;
    [CompilerGeneratedAttribute]
private VersionFolderPathResolver <PathResolver>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RepositoryRoot>k__BackingField;
    public VersionFolderPathResolver PathResolver { get; }
    public string RepositoryRoot { get; }
    public NuGetv3LocalRepository(string path);
    public NuGetv3LocalRepository(string path, LocalPackageFileCache packageFileCache, bool isFallbackFolder);
    public NuGetv3LocalRepository(string path, LocalPackageFileCache packageFileCache, bool isFallbackFolder, bool updateLastAccessTime);
    [CompilerGeneratedAttribute]
public VersionFolderPathResolver get_PathResolver();
    [CompilerGeneratedAttribute]
public string get_RepositoryRoot();
    public bool Exists(string packageId, NuGetVersion version);
    public LocalPackageInfo FindPackage(string packageId, NuGetVersion version);
    public IEnumerable`1<LocalPackageInfo> FindPackagesById(string packageId);
    private List`1<LocalPackageInfo> FindPackagesByIdImpl(string packageId);
    private LocalPackageInfo FindPackageImpl(string packageId, NuGetVersion version);
    private List`1<LocalPackageInfo> GetPackages(string id);
    private LocalPackageInfo GetPackage(string packageId, NuGetVersion version, string path);
    private LocalPackageInfo CreateLocalPackageInfo(string id, NuGetVersion version, string fullVersionDir, string newHashPath, string zipPath);
    public void ClearCacheForIds(IEnumerable`1<string> packageIds);
    private object GetLockObj(string privateId);
    [CompilerGeneratedAttribute]
private List`1<LocalPackageInfo> <FindPackagesByIdImpl>b__18_0(string id);
}
public static class NuGet.Repositories.NuGetv3LocalRepositoryUtility : object {
    public static LocalPackageSourceInfo GetPackage(IReadOnlyList`1<NuGetv3LocalRepository> repositories, string id, NuGetVersion version);
}
internal static class NuGet.Shared.EncodingUtility : object {
    [NullableContextAttribute("1")]
internal static string ToHex(Byte[] bytes, int length);
    private static char ToHexChar(int input);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class NuGet.Shared.EqualityUtility : object {
    [ExtensionAttribute]
internal static bool OrderedEquals(IEnumerable`1<TSource> self, IEnumerable`1<TSource> other, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> orderComparer, IEqualityComparer`1<TSource> sequenceComparer);
    [ExtensionAttribute]
internal static bool OrderedEquals(ICollection`1<TSource> self, ICollection`1<TSource> other, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> orderComparer, IEqualityComparer`1<TSource> sequenceComparer);
    [ExtensionAttribute]
internal static bool OrderedEquals(IList`1<TSource> self, IList`1<TSource> other, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> orderComparer, IEqualityComparer`1<TSource> sequenceComparer);
    [ExtensionAttribute]
internal static bool SequenceEqualWithNullCheck(IEnumerable`1<T> self, IEnumerable`1<T> other, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
internal static bool SequenceEqualWithNullCheck(ICollection`1<T> self, ICollection`1<T> other, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
internal static bool SequenceEqualWithNullCheck(IList`1<T> self, IList`1<T> other, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
internal static bool SetEqualsWithNullCheck(ISet`1<T> self, ISet`1<T> other, IEqualityComparer`1<T> comparer);
    [NullableContextAttribute("1")]
internal static bool DictionaryEquals(IDictionary`2<TKey, TValue> self, IDictionary`2<TKey, TValue> other, Func`3<TValue, TValue, bool> compareValues);
    [NullableContextAttribute("1")]
internal static bool DictionaryOfSequenceEquals(IDictionary`2<TKey, IEnumerable`1<TValue>> self, IDictionary`2<TKey, IEnumerable`1<TValue>> other);
    [NullableContextAttribute("1")]
internal static bool EqualsWithNullCheck(T self, T other);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
internal static bool EqualsFalse(string value);
    private static bool TryIdentityEquals(T self, T other, Boolean& equals);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
internal class NuGet.Shared.HashCodeCombiner : ValueType {
    private static long Seed;
    private long _combinedHash;
    internal int CombinedHash { get; }
    internal int get_CombinedHash();
    private void AddHashCode(int i);
    internal void AddObject(int i);
    internal void AddObject(bool b);
    internal void AddObject(T o, IEqualityComparer`1<T> comparer);
    internal void AddObject(T o);
    [NullableContextAttribute("0")]
internal void AddStruct(Nullable`1<T> o);
    [NullableContextAttribute("0")]
internal void AddStruct(T o);
    [NullableContextAttribute("2")]
internal void AddStringIgnoreCase(string s);
    internal void AddSequence(IEnumerable`1<T> sequence);
    internal void AddSequence(T[] array);
    internal void AddSequence(IList`1<T> list);
    internal void AddSequence(IReadOnlyList`1<T> list);
    internal void AddUnorderedSequence(IEnumerable`1<T> list);
    internal void AddUnorderedSequence(IEnumerable`1<T> list, IEqualityComparer`1<T> comparer);
    internal void AddDictionary(IEnumerable`1<KeyValuePair`2<TKey, TValue>> dictionary);
    internal static int GetHashCode(T1 o1, T2 o2);
    internal static int GetHashCode(T1 o1, T2 o2, T3 o3);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NuGet.SimplePool`1 : object {
    private object _lockObj;
    private Stack`1<T> _values;
    private Func`1<T> _allocate;
    public SimplePool`1(Func`1<T> allocate);
    public T Allocate();
    public void Free(T value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NuGet.StringBuilderPool : object {
    private static int MaxPoolSize;
    private SimplePool`1<StringBuilder> _pool;
    public static StringBuilderPool Shared;
    private static StringBuilderPool();
    public StringBuilder Rent(int minimumCapacity);
    public string ToStringAndReturn(StringBuilder builder);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class NuGet.TaskResult : object {
    [CompilerGeneratedAttribute]
private static Task`1<bool> <True>k__BackingField;
    [CompilerGeneratedAttribute]
private static Task`1<bool> <False>k__BackingField;
    [CompilerGeneratedAttribute]
private static Task`1<int> <Zero>k__BackingField;
    [CompilerGeneratedAttribute]
private static Task`1<int> <One>k__BackingField;
    public static Task`1<bool> True { get; }
    public static Task`1<bool> False { get; }
    public static Task`1<int> Zero { get; }
    public static Task`1<int> One { get; }
    private static TaskResult();
    [CompilerGeneratedAttribute]
public static Task`1<bool> get_True();
    [CompilerGeneratedAttribute]
public static Task`1<bool> get_False();
    public static Task`1<bool> Boolean(bool b);
    [CompilerGeneratedAttribute]
public static Task`1<int> get_Zero();
    [CompilerGeneratedAttribute]
public static Task`1<int> get_One();
    public static Task`1<int> Integer(int i);
    public static Task`1<T> Null();
    public static Task`1<IEnumerable`1<T>> EmptyEnumerable();
    public static Task`1<T[]> EmptyArray();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NuGet.TaskResultCache`2 : object {
    private ConcurrentDictionary`2<TKey, Task`1<TValue>> _cache;
    private ConcurrentDictionary`2<TKey, object> _perTaskLock;
    public TaskResultCache`2(IEqualityComparer`1<TKey> comparer);
    public Task`1<TValue> GetOrAddAsync(TKey key, Func`2<TState, Task`1<TValue>> valueFactory, TState state, CancellationToken cancellationToken);
    public Task`1<TValue> GetOrAddAsync(TKey key, bool refresh, Func`2<TState, Task`1<TValue>> valueFactory, TState state, CancellationToken cancellationToken);
}
internal static class ODataServiceDocumentUtils : object {
    [AsyncStateMachineAttribute("ODataServiceDocumentUtils/<CreateODataServiceDocumentResourceV2>d__0")]
public static Task`1<ODataServiceDocumentResourceV2> CreateODataServiceDocumentResourceV2(string url, HttpSource client, DateTime utcNow, ILogger log, CancellationToken token);
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.AllowNullAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.DisallowNullAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ParameterValue>k__BackingField;
    public bool ParameterValue { get; }
    public DoesNotReturnIfAttribute(bool parameterValue);
    [CompilerGeneratedAttribute]
public bool get_ParameterValue();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.MaybeNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public MaybeNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.MemberNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public String[] Members { get; }
    public MemberNotNullAttribute(string member);
    public MemberNotNullAttribute(String[] members);
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public bool ReturnValue { get; }
    public String[] Members { get; }
    public MemberNotNullWhenAttribute(bool returnValue, string member);
    public MemberNotNullWhenAttribute(bool returnValue, String[] members);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.NotNullAttribute : Attribute {
}
[AttributeUsageAttribute("10368")]
internal class System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; }
    public NotNullIfNotNullAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.NotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public NotNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
