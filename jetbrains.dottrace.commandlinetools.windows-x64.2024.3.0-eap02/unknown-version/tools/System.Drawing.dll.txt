[EditorAttribute("System.Drawing.Design.BitmapEditor, System.Drawing.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor")]
[ComVisibleAttribute("True")]
public class System.Drawing.Bitmap : Image {
    public Bitmap(string filename);
    public Bitmap(string filename, bool useIcm);
    public Bitmap(Type type, string resource);
    public Bitmap(Stream stream);
    public Bitmap(Stream stream, bool useIcm);
    public Bitmap(int width, int height, int stride, PixelFormat format, IntPtr scan0);
    public Bitmap(int width, int height, PixelFormat format);
    public Bitmap(int width, int height);
    public Bitmap(int width, int height, Graphics g);
    public Bitmap(Image original);
    public Bitmap(Image original, int width, int height);
    public Bitmap(Image original, Size newSize);
    public static Bitmap FromHicon(IntPtr hicon);
    public static Bitmap FromResource(IntPtr hinstance, string bitmapName);
    [EditorBrowsableAttribute("2")]
public IntPtr GetHbitmap();
    [EditorBrowsableAttribute("2")]
public IntPtr GetHbitmap(Color background);
    [EditorBrowsableAttribute("2")]
public IntPtr GetHicon();
    public Bitmap Clone(Rectangle rect, PixelFormat format);
    public Bitmap Clone(RectangleF rect, PixelFormat format);
    public void MakeTransparent();
    public void MakeTransparent(Color transparentColor);
    public BitmapData LockBits(Rectangle rect, ImageLockMode flags, PixelFormat format);
    public BitmapData LockBits(Rectangle rect, ImageLockMode flags, PixelFormat format, BitmapData bitmapData);
    public void UnlockBits(BitmapData bitmapdata);
    public Color GetPixel(int x, int y);
    public void SetPixel(int x, int y, Color color);
    public void SetResolution(float xDpi, float yDpi);
}
[AttributeUsageAttribute("1")]
public class System.Drawing.BitmapSuffixInSameAssemblyAttribute : Attribute {
}
[AttributeUsageAttribute("1")]
public class System.Drawing.BitmapSuffixInSatelliteAssemblyAttribute : Attribute {
}
public abstract class System.Drawing.Brush : MarshalByRefObject {
    protected virtual override void Finalize();
    public abstract virtual object Clone();
    protected internal void SetNativeBrush(IntPtr brush);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
public class System.Drawing.Brushes : object {
    public static Brush Transparent { get; }
    public static Brush AliceBlue { get; }
    public static Brush AntiqueWhite { get; }
    public static Brush Aqua { get; }
    public static Brush Aquamarine { get; }
    public static Brush Azure { get; }
    public static Brush Beige { get; }
    public static Brush Bisque { get; }
    public static Brush Black { get; }
    public static Brush BlanchedAlmond { get; }
    public static Brush Blue { get; }
    public static Brush BlueViolet { get; }
    public static Brush Brown { get; }
    public static Brush BurlyWood { get; }
    public static Brush CadetBlue { get; }
    public static Brush Chartreuse { get; }
    public static Brush Chocolate { get; }
    public static Brush Coral { get; }
    public static Brush CornflowerBlue { get; }
    public static Brush Cornsilk { get; }
    public static Brush Crimson { get; }
    public static Brush Cyan { get; }
    public static Brush DarkBlue { get; }
    public static Brush DarkCyan { get; }
    public static Brush DarkGoldenrod { get; }
    public static Brush DarkGray { get; }
    public static Brush DarkGreen { get; }
    public static Brush DarkKhaki { get; }
    public static Brush DarkMagenta { get; }
    public static Brush DarkOliveGreen { get; }
    public static Brush DarkOrange { get; }
    public static Brush DarkOrchid { get; }
    public static Brush DarkRed { get; }
    public static Brush DarkSalmon { get; }
    public static Brush DarkSeaGreen { get; }
    public static Brush DarkSlateBlue { get; }
    public static Brush DarkSlateGray { get; }
    public static Brush DarkTurquoise { get; }
    public static Brush DarkViolet { get; }
    public static Brush DeepPink { get; }
    public static Brush DeepSkyBlue { get; }
    public static Brush DimGray { get; }
    public static Brush DodgerBlue { get; }
    public static Brush Firebrick { get; }
    public static Brush FloralWhite { get; }
    public static Brush ForestGreen { get; }
    public static Brush Fuchsia { get; }
    public static Brush Gainsboro { get; }
    public static Brush GhostWhite { get; }
    public static Brush Gold { get; }
    public static Brush Goldenrod { get; }
    public static Brush Gray { get; }
    public static Brush Green { get; }
    public static Brush GreenYellow { get; }
    public static Brush Honeydew { get; }
    public static Brush HotPink { get; }
    public static Brush IndianRed { get; }
    public static Brush Indigo { get; }
    public static Brush Ivory { get; }
    public static Brush Khaki { get; }
    public static Brush Lavender { get; }
    public static Brush LavenderBlush { get; }
    public static Brush LawnGreen { get; }
    public static Brush LemonChiffon { get; }
    public static Brush LightBlue { get; }
    public static Brush LightCoral { get; }
    public static Brush LightCyan { get; }
    public static Brush LightGoldenrodYellow { get; }
    public static Brush LightGreen { get; }
    public static Brush LightGray { get; }
    public static Brush LightPink { get; }
    public static Brush LightSalmon { get; }
    public static Brush LightSeaGreen { get; }
    public static Brush LightSkyBlue { get; }
    public static Brush LightSlateGray { get; }
    public static Brush LightSteelBlue { get; }
    public static Brush LightYellow { get; }
    public static Brush Lime { get; }
    public static Brush LimeGreen { get; }
    public static Brush Linen { get; }
    public static Brush Magenta { get; }
    public static Brush Maroon { get; }
    public static Brush MediumAquamarine { get; }
    public static Brush MediumBlue { get; }
    public static Brush MediumOrchid { get; }
    public static Brush MediumPurple { get; }
    public static Brush MediumSeaGreen { get; }
    public static Brush MediumSlateBlue { get; }
    public static Brush MediumSpringGreen { get; }
    public static Brush MediumTurquoise { get; }
    public static Brush MediumVioletRed { get; }
    public static Brush MidnightBlue { get; }
    public static Brush MintCream { get; }
    public static Brush MistyRose { get; }
    public static Brush Moccasin { get; }
    public static Brush NavajoWhite { get; }
    public static Brush Navy { get; }
    public static Brush OldLace { get; }
    public static Brush Olive { get; }
    public static Brush OliveDrab { get; }
    public static Brush Orange { get; }
    public static Brush OrangeRed { get; }
    public static Brush Orchid { get; }
    public static Brush PaleGoldenrod { get; }
    public static Brush PaleGreen { get; }
    public static Brush PaleTurquoise { get; }
    public static Brush PaleVioletRed { get; }
    public static Brush PapayaWhip { get; }
    public static Brush PeachPuff { get; }
    public static Brush Peru { get; }
    public static Brush Pink { get; }
    public static Brush Plum { get; }
    public static Brush PowderBlue { get; }
    public static Brush Purple { get; }
    public static Brush Red { get; }
    public static Brush RosyBrown { get; }
    public static Brush RoyalBlue { get; }
    public static Brush SaddleBrown { get; }
    public static Brush Salmon { get; }
    public static Brush SandyBrown { get; }
    public static Brush SeaGreen { get; }
    public static Brush SeaShell { get; }
    public static Brush Sienna { get; }
    public static Brush Silver { get; }
    public static Brush SkyBlue { get; }
    public static Brush SlateBlue { get; }
    public static Brush SlateGray { get; }
    public static Brush Snow { get; }
    public static Brush SpringGreen { get; }
    public static Brush SteelBlue { get; }
    public static Brush Tan { get; }
    public static Brush Teal { get; }
    public static Brush Thistle { get; }
    public static Brush Tomato { get; }
    public static Brush Turquoise { get; }
    public static Brush Violet { get; }
    public static Brush Wheat { get; }
    public static Brush White { get; }
    public static Brush WhiteSmoke { get; }
    public static Brush Yellow { get; }
    public static Brush YellowGreen { get; }
    public static Brush get_Transparent();
    public static Brush get_AliceBlue();
    public static Brush get_AntiqueWhite();
    public static Brush get_Aqua();
    public static Brush get_Aquamarine();
    public static Brush get_Azure();
    public static Brush get_Beige();
    public static Brush get_Bisque();
    public static Brush get_Black();
    public static Brush get_BlanchedAlmond();
    public static Brush get_Blue();
    public static Brush get_BlueViolet();
    public static Brush get_Brown();
    public static Brush get_BurlyWood();
    public static Brush get_CadetBlue();
    public static Brush get_Chartreuse();
    public static Brush get_Chocolate();
    public static Brush get_Coral();
    public static Brush get_CornflowerBlue();
    public static Brush get_Cornsilk();
    public static Brush get_Crimson();
    public static Brush get_Cyan();
    public static Brush get_DarkBlue();
    public static Brush get_DarkCyan();
    public static Brush get_DarkGoldenrod();
    public static Brush get_DarkGray();
    public static Brush get_DarkGreen();
    public static Brush get_DarkKhaki();
    public static Brush get_DarkMagenta();
    public static Brush get_DarkOliveGreen();
    public static Brush get_DarkOrange();
    public static Brush get_DarkOrchid();
    public static Brush get_DarkRed();
    public static Brush get_DarkSalmon();
    public static Brush get_DarkSeaGreen();
    public static Brush get_DarkSlateBlue();
    public static Brush get_DarkSlateGray();
    public static Brush get_DarkTurquoise();
    public static Brush get_DarkViolet();
    public static Brush get_DeepPink();
    public static Brush get_DeepSkyBlue();
    public static Brush get_DimGray();
    public static Brush get_DodgerBlue();
    public static Brush get_Firebrick();
    public static Brush get_FloralWhite();
    public static Brush get_ForestGreen();
    public static Brush get_Fuchsia();
    public static Brush get_Gainsboro();
    public static Brush get_GhostWhite();
    public static Brush get_Gold();
    public static Brush get_Goldenrod();
    public static Brush get_Gray();
    public static Brush get_Green();
    public static Brush get_GreenYellow();
    public static Brush get_Honeydew();
    public static Brush get_HotPink();
    public static Brush get_IndianRed();
    public static Brush get_Indigo();
    public static Brush get_Ivory();
    public static Brush get_Khaki();
    public static Brush get_Lavender();
    public static Brush get_LavenderBlush();
    public static Brush get_LawnGreen();
    public static Brush get_LemonChiffon();
    public static Brush get_LightBlue();
    public static Brush get_LightCoral();
    public static Brush get_LightCyan();
    public static Brush get_LightGoldenrodYellow();
    public static Brush get_LightGreen();
    public static Brush get_LightGray();
    public static Brush get_LightPink();
    public static Brush get_LightSalmon();
    public static Brush get_LightSeaGreen();
    public static Brush get_LightSkyBlue();
    public static Brush get_LightSlateGray();
    public static Brush get_LightSteelBlue();
    public static Brush get_LightYellow();
    public static Brush get_Lime();
    public static Brush get_LimeGreen();
    public static Brush get_Linen();
    public static Brush get_Magenta();
    public static Brush get_Maroon();
    public static Brush get_MediumAquamarine();
    public static Brush get_MediumBlue();
    public static Brush get_MediumOrchid();
    public static Brush get_MediumPurple();
    public static Brush get_MediumSeaGreen();
    public static Brush get_MediumSlateBlue();
    public static Brush get_MediumSpringGreen();
    public static Brush get_MediumTurquoise();
    public static Brush get_MediumVioletRed();
    public static Brush get_MidnightBlue();
    public static Brush get_MintCream();
    public static Brush get_MistyRose();
    public static Brush get_Moccasin();
    public static Brush get_NavajoWhite();
    public static Brush get_Navy();
    public static Brush get_OldLace();
    public static Brush get_Olive();
    public static Brush get_OliveDrab();
    public static Brush get_Orange();
    public static Brush get_OrangeRed();
    public static Brush get_Orchid();
    public static Brush get_PaleGoldenrod();
    public static Brush get_PaleGreen();
    public static Brush get_PaleTurquoise();
    public static Brush get_PaleVioletRed();
    public static Brush get_PapayaWhip();
    public static Brush get_PeachPuff();
    public static Brush get_Peru();
    public static Brush get_Pink();
    public static Brush get_Plum();
    public static Brush get_PowderBlue();
    public static Brush get_Purple();
    public static Brush get_Red();
    public static Brush get_RosyBrown();
    public static Brush get_RoyalBlue();
    public static Brush get_SaddleBrown();
    public static Brush get_Salmon();
    public static Brush get_SandyBrown();
    public static Brush get_SeaGreen();
    public static Brush get_SeaShell();
    public static Brush get_Sienna();
    public static Brush get_Silver();
    public static Brush get_SkyBlue();
    public static Brush get_SlateBlue();
    public static Brush get_SlateGray();
    public static Brush get_Snow();
    public static Brush get_SpringGreen();
    public static Brush get_SteelBlue();
    public static Brush get_Tan();
    public static Brush get_Teal();
    public static Brush get_Thistle();
    public static Brush get_Tomato();
    public static Brush get_Turquoise();
    public static Brush get_Violet();
    public static Brush get_Wheat();
    public static Brush get_White();
    public static Brush get_WhiteSmoke();
    public static Brush get_Yellow();
    public static Brush get_YellowGreen();
}
public class System.Drawing.BufferedGraphics : object {
    public Graphics Graphics { get; }
    public Graphics get_Graphics();
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    public void Render();
    public void Render(Graphics target);
    public void Render(IntPtr targetDC);
}
public class System.Drawing.BufferedGraphicsContext : object {
    public Size MaximumBuffer { get; public set; }
    public Size get_MaximumBuffer();
    public void set_MaximumBuffer(Size value);
    protected virtual override void Finalize();
    public BufferedGraphics Allocate(Graphics targetGraphics, Rectangle targetRectangle);
    public BufferedGraphics Allocate(IntPtr targetDC, Rectangle targetRectangle);
    public sealed virtual void Dispose();
    public void Invalidate();
}
public class System.Drawing.BufferedGraphicsManager : object {
    public static BufferedGraphicsContext Current { get; }
    public static BufferedGraphicsContext get_Current();
}
public class System.Drawing.CharacterRange : ValueType {
    private int first;
    private int length;
    public int First { get; public set; }
    public int Length { get; public set; }
    public CharacterRange(int First, int Length);
    public int get_First();
    public void set_First(int value);
    public int get_Length();
    public void set_Length(int value);
    public static bool op_Equality(CharacterRange cr1, CharacterRange cr2);
    public static bool op_Inequality(CharacterRange cr1, CharacterRange cr2);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[TypeConverterAttribute("System.Drawing.ColorConverter")]
public class System.Drawing.Color : ValueType {
    private long value;
    internal short state;
    internal short knownColor;
    internal string name;
    public static Color Empty;
    public string Name { get; }
    public bool IsKnownColor { get; }
    public bool IsSystemColor { get; }
    public bool IsNamedColor { get; }
    internal long Value { get; internal set; }
    public bool IsEmpty { get; }
    public byte A { get; }
    public byte R { get; }
    public byte G { get; }
    public byte B { get; }
    public static Color Transparent { get; }
    public static Color AliceBlue { get; }
    public static Color AntiqueWhite { get; }
    public static Color Aqua { get; }
    public static Color Aquamarine { get; }
    public static Color Azure { get; }
    public static Color Beige { get; }
    public static Color Bisque { get; }
    public static Color Black { get; }
    public static Color BlanchedAlmond { get; }
    public static Color Blue { get; }
    public static Color BlueViolet { get; }
    public static Color Brown { get; }
    public static Color BurlyWood { get; }
    public static Color CadetBlue { get; }
    public static Color Chartreuse { get; }
    public static Color Chocolate { get; }
    public static Color Coral { get; }
    public static Color CornflowerBlue { get; }
    public static Color Cornsilk { get; }
    public static Color Crimson { get; }
    public static Color Cyan { get; }
    public static Color DarkBlue { get; }
    public static Color DarkCyan { get; }
    public static Color DarkGoldenrod { get; }
    public static Color DarkGray { get; }
    public static Color DarkGreen { get; }
    public static Color DarkKhaki { get; }
    public static Color DarkMagenta { get; }
    public static Color DarkOliveGreen { get; }
    public static Color DarkOrange { get; }
    public static Color DarkOrchid { get; }
    public static Color DarkRed { get; }
    public static Color DarkSalmon { get; }
    public static Color DarkSeaGreen { get; }
    public static Color DarkSlateBlue { get; }
    public static Color DarkSlateGray { get; }
    public static Color DarkTurquoise { get; }
    public static Color DarkViolet { get; }
    public static Color DeepPink { get; }
    public static Color DeepSkyBlue { get; }
    public static Color DimGray { get; }
    public static Color DodgerBlue { get; }
    public static Color Firebrick { get; }
    public static Color FloralWhite { get; }
    public static Color ForestGreen { get; }
    public static Color Fuchsia { get; }
    public static Color Gainsboro { get; }
    public static Color GhostWhite { get; }
    public static Color Gold { get; }
    public static Color Goldenrod { get; }
    public static Color Gray { get; }
    public static Color Green { get; }
    public static Color GreenYellow { get; }
    public static Color Honeydew { get; }
    public static Color HotPink { get; }
    public static Color IndianRed { get; }
    public static Color Indigo { get; }
    public static Color Ivory { get; }
    public static Color Khaki { get; }
    public static Color Lavender { get; }
    public static Color LavenderBlush { get; }
    public static Color LawnGreen { get; }
    public static Color LemonChiffon { get; }
    public static Color LightBlue { get; }
    public static Color LightCoral { get; }
    public static Color LightCyan { get; }
    public static Color LightGoldenrodYellow { get; }
    public static Color LightGreen { get; }
    public static Color LightGray { get; }
    public static Color LightPink { get; }
    public static Color LightSalmon { get; }
    public static Color LightSeaGreen { get; }
    public static Color LightSkyBlue { get; }
    public static Color LightSlateGray { get; }
    public static Color LightSteelBlue { get; }
    public static Color LightYellow { get; }
    public static Color Lime { get; }
    public static Color LimeGreen { get; }
    public static Color Linen { get; }
    public static Color Magenta { get; }
    public static Color Maroon { get; }
    public static Color MediumAquamarine { get; }
    public static Color MediumBlue { get; }
    public static Color MediumOrchid { get; }
    public static Color MediumPurple { get; }
    public static Color MediumSeaGreen { get; }
    public static Color MediumSlateBlue { get; }
    public static Color MediumSpringGreen { get; }
    public static Color MediumTurquoise { get; }
    public static Color MediumVioletRed { get; }
    public static Color MidnightBlue { get; }
    public static Color MintCream { get; }
    public static Color MistyRose { get; }
    public static Color Moccasin { get; }
    public static Color NavajoWhite { get; }
    public static Color Navy { get; }
    public static Color OldLace { get; }
    public static Color Olive { get; }
    public static Color OliveDrab { get; }
    public static Color Orange { get; }
    public static Color OrangeRed { get; }
    public static Color Orchid { get; }
    public static Color PaleGoldenrod { get; }
    public static Color PaleGreen { get; }
    public static Color PaleTurquoise { get; }
    public static Color PaleVioletRed { get; }
    public static Color PapayaWhip { get; }
    public static Color PeachPuff { get; }
    public static Color Peru { get; }
    public static Color Pink { get; }
    public static Color Plum { get; }
    public static Color PowderBlue { get; }
    public static Color Purple { get; }
    public static Color Red { get; }
    public static Color RosyBrown { get; }
    public static Color RoyalBlue { get; }
    public static Color SaddleBrown { get; }
    public static Color Salmon { get; }
    public static Color SandyBrown { get; }
    public static Color SeaGreen { get; }
    public static Color SeaShell { get; }
    public static Color Sienna { get; }
    public static Color Silver { get; }
    public static Color SkyBlue { get; }
    public static Color SlateBlue { get; }
    public static Color SlateGray { get; }
    public static Color Snow { get; }
    public static Color SpringGreen { get; }
    public static Color SteelBlue { get; }
    public static Color Tan { get; }
    public static Color Teal { get; }
    public static Color Thistle { get; }
    public static Color Tomato { get; }
    public static Color Turquoise { get; }
    public static Color Violet { get; }
    public static Color Wheat { get; }
    public static Color White { get; }
    public static Color WhiteSmoke { get; }
    public static Color Yellow { get; }
    public static Color YellowGreen { get; }
    public string get_Name();
    public bool get_IsKnownColor();
    public bool get_IsSystemColor();
    public bool get_IsNamedColor();
    internal long get_Value();
    internal void set_Value(long value);
    public static Color FromArgb(int red, int green, int blue);
    public static Color FromArgb(int alpha, int red, int green, int blue);
    public int ToArgb();
    public static Color FromArgb(int alpha, Color baseColor);
    public static Color FromArgb(int argb);
    public static Color FromKnownColor(KnownColor color);
    public static Color FromName(string name);
    public static bool op_Equality(Color left, Color right);
    public static bool op_Inequality(Color left, Color right);
    public float GetBrightness();
    public float GetSaturation();
    public float GetHue();
    public KnownColor ToKnownColor();
    public bool get_IsEmpty();
    public byte get_A();
    public byte get_R();
    public byte get_G();
    public byte get_B();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    private static void CheckRGBValues(int red, int green, int blue);
    private static ArgumentException CreateColorArgumentException(int value, string color);
    private static void CheckARGBValues(int alpha, int red, int green, int blue);
    public static Color get_Transparent();
    public static Color get_AliceBlue();
    public static Color get_AntiqueWhite();
    public static Color get_Aqua();
    public static Color get_Aquamarine();
    public static Color get_Azure();
    public static Color get_Beige();
    public static Color get_Bisque();
    public static Color get_Black();
    public static Color get_BlanchedAlmond();
    public static Color get_Blue();
    public static Color get_BlueViolet();
    public static Color get_Brown();
    public static Color get_BurlyWood();
    public static Color get_CadetBlue();
    public static Color get_Chartreuse();
    public static Color get_Chocolate();
    public static Color get_Coral();
    public static Color get_CornflowerBlue();
    public static Color get_Cornsilk();
    public static Color get_Crimson();
    public static Color get_Cyan();
    public static Color get_DarkBlue();
    public static Color get_DarkCyan();
    public static Color get_DarkGoldenrod();
    public static Color get_DarkGray();
    public static Color get_DarkGreen();
    public static Color get_DarkKhaki();
    public static Color get_DarkMagenta();
    public static Color get_DarkOliveGreen();
    public static Color get_DarkOrange();
    public static Color get_DarkOrchid();
    public static Color get_DarkRed();
    public static Color get_DarkSalmon();
    public static Color get_DarkSeaGreen();
    public static Color get_DarkSlateBlue();
    public static Color get_DarkSlateGray();
    public static Color get_DarkTurquoise();
    public static Color get_DarkViolet();
    public static Color get_DeepPink();
    public static Color get_DeepSkyBlue();
    public static Color get_DimGray();
    public static Color get_DodgerBlue();
    public static Color get_Firebrick();
    public static Color get_FloralWhite();
    public static Color get_ForestGreen();
    public static Color get_Fuchsia();
    public static Color get_Gainsboro();
    public static Color get_GhostWhite();
    public static Color get_Gold();
    public static Color get_Goldenrod();
    public static Color get_Gray();
    public static Color get_Green();
    public static Color get_GreenYellow();
    public static Color get_Honeydew();
    public static Color get_HotPink();
    public static Color get_IndianRed();
    public static Color get_Indigo();
    public static Color get_Ivory();
    public static Color get_Khaki();
    public static Color get_Lavender();
    public static Color get_LavenderBlush();
    public static Color get_LawnGreen();
    public static Color get_LemonChiffon();
    public static Color get_LightBlue();
    public static Color get_LightCoral();
    public static Color get_LightCyan();
    public static Color get_LightGoldenrodYellow();
    public static Color get_LightGreen();
    public static Color get_LightGray();
    public static Color get_LightPink();
    public static Color get_LightSalmon();
    public static Color get_LightSeaGreen();
    public static Color get_LightSkyBlue();
    public static Color get_LightSlateGray();
    public static Color get_LightSteelBlue();
    public static Color get_LightYellow();
    public static Color get_Lime();
    public static Color get_LimeGreen();
    public static Color get_Linen();
    public static Color get_Magenta();
    public static Color get_Maroon();
    public static Color get_MediumAquamarine();
    public static Color get_MediumBlue();
    public static Color get_MediumOrchid();
    public static Color get_MediumPurple();
    public static Color get_MediumSeaGreen();
    public static Color get_MediumSlateBlue();
    public static Color get_MediumSpringGreen();
    public static Color get_MediumTurquoise();
    public static Color get_MediumVioletRed();
    public static Color get_MidnightBlue();
    public static Color get_MintCream();
    public static Color get_MistyRose();
    public static Color get_Moccasin();
    public static Color get_NavajoWhite();
    public static Color get_Navy();
    public static Color get_OldLace();
    public static Color get_Olive();
    public static Color get_OliveDrab();
    public static Color get_Orange();
    public static Color get_OrangeRed();
    public static Color get_Orchid();
    public static Color get_PaleGoldenrod();
    public static Color get_PaleGreen();
    public static Color get_PaleTurquoise();
    public static Color get_PaleVioletRed();
    public static Color get_PapayaWhip();
    public static Color get_PeachPuff();
    public static Color get_Peru();
    public static Color get_Pink();
    public static Color get_Plum();
    public static Color get_PowderBlue();
    public static Color get_Purple();
    public static Color get_Red();
    public static Color get_RosyBrown();
    public static Color get_RoyalBlue();
    public static Color get_SaddleBrown();
    public static Color get_Salmon();
    public static Color get_SandyBrown();
    public static Color get_SeaGreen();
    public static Color get_SeaShell();
    public static Color get_Sienna();
    public static Color get_Silver();
    public static Color get_SkyBlue();
    public static Color get_SlateBlue();
    public static Color get_SlateGray();
    public static Color get_Snow();
    public static Color get_SpringGreen();
    public static Color get_SteelBlue();
    public static Color get_Tan();
    public static Color get_Teal();
    public static Color get_Thistle();
    public static Color get_Tomato();
    public static Color get_Turquoise();
    public static Color get_Violet();
    public static Color get_Wheat();
    public static Color get_White();
    public static Color get_WhiteSmoke();
    public static Color get_Yellow();
    public static Color get_YellowGreen();
}
public class System.Drawing.ColorConverter : TypeConverter {
    private static StandardValuesCollection cached;
    private static object creatingCached;
    private static ColorConverter();
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    internal static Color StaticConvertFromString(ITypeDescriptorContext context, string s, CultureInfo culture);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
    public virtual StandardValuesCollection GetStandardValues(ITypeDescriptorContext context);
    public virtual bool GetStandardValuesSupported(ITypeDescriptorContext context);
}
public class System.Drawing.ColorTranslator : object {
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static int ToWin32(Color c);
    public static int ToOle(Color c);
    public static Color FromOle(int oleColor);
    public static Color FromWin32(int win32Color);
    public static Color FromHtml(string htmlColor);
    public static string ToHtml(Color c);
}
public class System.Drawing.Configuration.SystemDrawingSection : ConfigurationSection {
    [ConfigurationPropertyAttribute("bitmapSuffix")]
public string BitmapSuffix { get; public set; }
    protected ConfigurationPropertyCollection Properties { get; }
    public string get_BitmapSuffix();
    public void set_BitmapSuffix(string value);
    protected virtual ConfigurationPropertyCollection get_Properties();
}
[EditorAttribute("System.Drawing.Design.ContentAlignmentEditor, System.Drawing.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor")]
public enum System.Drawing.ContentAlignment : Enum {
    public int value__;
    public static ContentAlignment TopLeft;
    public static ContentAlignment TopCenter;
    public static ContentAlignment TopRight;
    public static ContentAlignment MiddleLeft;
    public static ContentAlignment MiddleCenter;
    public static ContentAlignment MiddleRight;
    public static ContentAlignment BottomLeft;
    public static ContentAlignment BottomCenter;
    public static ContentAlignment BottomRight;
}
[ComVisibleAttribute("True")]
public enum System.Drawing.CopyPixelOperation : Enum {
    public int value__;
    public static CopyPixelOperation NoMirrorBitmap;
    public static CopyPixelOperation Blackness;
    public static CopyPixelOperation NotSourceErase;
    public static CopyPixelOperation NotSourceCopy;
    public static CopyPixelOperation SourceErase;
    public static CopyPixelOperation DestinationInvert;
    public static CopyPixelOperation PatInvert;
    public static CopyPixelOperation SourceInvert;
    public static CopyPixelOperation SourceAnd;
    public static CopyPixelOperation MergePaint;
    public static CopyPixelOperation MergeCopy;
    public static CopyPixelOperation SourceCopy;
    public static CopyPixelOperation SourcePaint;
    public static CopyPixelOperation PatCopy;
    public static CopyPixelOperation PatPaint;
    public static CopyPixelOperation Whiteness;
    public static CopyPixelOperation CaptureBlt;
}
[DefaultMemberAttribute("Item")]
public class System.Drawing.Design.CategoryNameCollection : ReadOnlyCollectionBase {
    public string Item { get; }
    public CategoryNameCollection(CategoryNameCollection value);
    public CategoryNameCollection(String[] value);
    public string get_Item(int index);
    public bool Contains(string value);
    public void CopyTo(String[] array, int index);
    public int IndexOf(string value);
}
public interface System.Drawing.Design.IPropertyValueUIService {
    [CompilerGeneratedAttribute]
public abstract virtual void add_PropertyUIValueItemsChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PropertyUIValueItemsChanged(EventHandler value);
    public abstract virtual void AddPropertyValueUIHandler(PropertyValueUIHandler newHandler);
    public abstract virtual PropertyValueUIItem[] GetPropertyUIValueItems(ITypeDescriptorContext context, PropertyDescriptor propDesc);
    public abstract virtual void NotifyPropertyValueUIItemsChanged();
    public abstract virtual void RemovePropertyValueUIHandler(PropertyValueUIHandler newHandler);
}
public interface System.Drawing.Design.IToolboxItemProvider {
    public ToolboxItemCollection Items { get; }
    public abstract virtual ToolboxItemCollection get_Items();
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("4BACD258-DE64-4048-BC4E-FEDBEF9ACB76")]
public interface System.Drawing.Design.IToolboxService {
    public CategoryNameCollection CategoryNames { get; }
    public string SelectedCategory { get; public set; }
    public abstract virtual CategoryNameCollection get_CategoryNames();
    public abstract virtual string get_SelectedCategory();
    public abstract virtual void set_SelectedCategory(string value);
    public abstract virtual void AddCreator(ToolboxItemCreatorCallback creator, string format);
    public abstract virtual void AddCreator(ToolboxItemCreatorCallback creator, string format, IDesignerHost host);
    public abstract virtual void AddLinkedToolboxItem(ToolboxItem toolboxItem, IDesignerHost host);
    public abstract virtual void AddLinkedToolboxItem(ToolboxItem toolboxItem, string category, IDesignerHost host);
    public abstract virtual void AddToolboxItem(ToolboxItem toolboxItem);
    public abstract virtual void AddToolboxItem(ToolboxItem toolboxItem, string category);
    public abstract virtual ToolboxItem DeserializeToolboxItem(object serializedObject);
    public abstract virtual ToolboxItem DeserializeToolboxItem(object serializedObject, IDesignerHost host);
    public abstract virtual ToolboxItem GetSelectedToolboxItem();
    public abstract virtual ToolboxItem GetSelectedToolboxItem(IDesignerHost host);
    public abstract virtual ToolboxItemCollection GetToolboxItems();
    public abstract virtual ToolboxItemCollection GetToolboxItems(IDesignerHost host);
    public abstract virtual ToolboxItemCollection GetToolboxItems(string category);
    public abstract virtual ToolboxItemCollection GetToolboxItems(string category, IDesignerHost host);
    public abstract virtual bool IsSupported(object serializedObject, IDesignerHost host);
    public abstract virtual bool IsSupported(object serializedObject, ICollection filterAttributes);
    public abstract virtual bool IsToolboxItem(object serializedObject);
    public abstract virtual bool IsToolboxItem(object serializedObject, IDesignerHost host);
    public abstract virtual void Refresh();
    public abstract virtual void RemoveCreator(string format);
    public abstract virtual void RemoveCreator(string format, IDesignerHost host);
    public abstract virtual void RemoveToolboxItem(ToolboxItem toolboxItem);
    public abstract virtual void RemoveToolboxItem(ToolboxItem toolboxItem, string category);
    public abstract virtual void SelectedToolboxItemUsed();
    public abstract virtual object SerializeToolboxItem(ToolboxItem toolboxItem);
    public abstract virtual bool SetCursor();
    public abstract virtual void SetSelectedToolboxItem(ToolboxItem toolboxItem);
}
public interface System.Drawing.Design.IToolboxUser {
    public abstract virtual bool GetToolSupported(ToolboxItem tool);
    public abstract virtual void ToolPicked(ToolboxItem tool);
}
public class System.Drawing.Design.PaintValueEventArgs : EventArgs {
    public Rectangle Bounds { get; }
    public ITypeDescriptorContext Context { get; }
    public Graphics Graphics { get; }
    public object Value { get; }
    public PaintValueEventArgs(ITypeDescriptorContext context, object value, Graphics graphics, Rectangle bounds);
    public Rectangle get_Bounds();
    public ITypeDescriptorContext get_Context();
    public Graphics get_Graphics();
    public object get_Value();
}
public class System.Drawing.Design.PropertyValueUIHandler : MulticastDelegate {
    public PropertyValueUIHandler(object object, IntPtr method);
    public virtual void Invoke(ITypeDescriptorContext context, PropertyDescriptor propDesc, ArrayList valueUIItemList);
    public virtual IAsyncResult BeginInvoke(ITypeDescriptorContext context, PropertyDescriptor propDesc, ArrayList valueUIItemList, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Drawing.Design.PropertyValueUIItem : object {
    public Image Image { get; }
    public PropertyValueUIItemInvokeHandler InvokeHandler { get; }
    public string ToolTip { get; }
    public PropertyValueUIItem(Image uiItemImage, PropertyValueUIItemInvokeHandler handler, string tooltip);
    public virtual Image get_Image();
    public virtual PropertyValueUIItemInvokeHandler get_InvokeHandler();
    public virtual string get_ToolTip();
    public virtual void Reset();
}
public class System.Drawing.Design.PropertyValueUIItemInvokeHandler : MulticastDelegate {
    public PropertyValueUIItemInvokeHandler(object object, IntPtr method);
    public virtual void Invoke(ITypeDescriptorContext context, PropertyDescriptor descriptor, PropertyValueUIItem invokedItem);
    public virtual IAsyncResult BeginInvoke(ITypeDescriptorContext context, PropertyDescriptor descriptor, PropertyValueUIItem invokedItem, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Drawing.Design.ToolboxComponentsCreatedEventArgs : EventArgs {
    public IComponent[] Components { get; }
    public ToolboxComponentsCreatedEventArgs(IComponent[] components);
    public IComponent[] get_Components();
}
public class System.Drawing.Design.ToolboxComponentsCreatedEventHandler : MulticastDelegate {
    public ToolboxComponentsCreatedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, ToolboxComponentsCreatedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, ToolboxComponentsCreatedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Drawing.Design.ToolboxComponentsCreatingEventArgs : EventArgs {
    public IDesignerHost DesignerHost { get; }
    public ToolboxComponentsCreatingEventArgs(IDesignerHost host);
    public IDesignerHost get_DesignerHost();
}
public class System.Drawing.Design.ToolboxComponentsCreatingEventHandler : MulticastDelegate {
    public ToolboxComponentsCreatingEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, ToolboxComponentsCreatingEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, ToolboxComponentsCreatingEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Drawing.Design.ToolboxItem : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private ToolboxComponentsCreatedEventHandler ComponentsCreated;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private ToolboxComponentsCreatingEventHandler ComponentsCreating;
    public AssemblyName AssemblyName { get; public set; }
    public AssemblyName[] DependentAssemblies { get; public set; }
    public Bitmap Bitmap { get; public set; }
    public string Company { get; public set; }
    public string ComponentType { get; }
    public string Description { get; public set; }
    public string DisplayName { get; public set; }
    public ICollection Filter { get; public set; }
    public bool IsTransient { get; public set; }
    public bool Locked { get; }
    public IDictionary Properties { get; }
    public string TypeName { get; public set; }
    public string Version { get; }
    public ToolboxItem(Type toolType);
    public AssemblyName get_AssemblyName();
    public void set_AssemblyName(AssemblyName value);
    public AssemblyName[] get_DependentAssemblies();
    public void set_DependentAssemblies(AssemblyName[] value);
    public Bitmap get_Bitmap();
    public void set_Bitmap(Bitmap value);
    public string get_Company();
    public void set_Company(string value);
    public virtual string get_ComponentType();
    public string get_Description();
    public void set_Description(string value);
    public string get_DisplayName();
    public void set_DisplayName(string value);
    public ICollection get_Filter();
    public void set_Filter(ICollection value);
    public bool get_IsTransient();
    public void set_IsTransient(bool value);
    public virtual bool get_Locked();
    public IDictionary get_Properties();
    public string get_TypeName();
    public void set_TypeName(string value);
    public virtual string get_Version();
    [CompilerGeneratedAttribute]
public void add_ComponentsCreated(ToolboxComponentsCreatedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_ComponentsCreated(ToolboxComponentsCreatedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_ComponentsCreating(ToolboxComponentsCreatingEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_ComponentsCreating(ToolboxComponentsCreatingEventHandler value);
    protected void CheckUnlocked();
    public IComponent[] CreateComponents();
    public IComponent[] CreateComponents(IDesignerHost host);
    public IComponent[] CreateComponents(IDesignerHost host, IDictionary defaultValues);
    protected virtual IComponent[] CreateComponentsCore(IDesignerHost host);
    protected virtual IComponent[] CreateComponentsCore(IDesignerHost host, IDictionary defaultValues);
    protected virtual void Deserialize(SerializationInfo info, StreamingContext context);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    protected virtual object FilterPropertyValue(string propertyName, object value);
    public Type GetType(IDesignerHost host);
    protected virtual Type GetType(IDesignerHost host, AssemblyName assemblyName, string typeName, bool reference);
    public virtual void Initialize(Type type);
    public virtual void Lock();
    protected virtual void OnComponentsCreated(ToolboxComponentsCreatedEventArgs args);
    protected virtual void OnComponentsCreating(ToolboxComponentsCreatingEventArgs args);
    protected virtual void Serialize(SerializationInfo info, StreamingContext context);
    public virtual string ToString();
    protected void ValidatePropertyType(string propertyName, object value, Type expectedType, bool allowNull);
    protected virtual object ValidatePropertyValue(string propertyName, object value);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
}
[DefaultMemberAttribute("Item")]
public class System.Drawing.Design.ToolboxItemCollection : ReadOnlyCollectionBase {
    public ToolboxItem Item { get; }
    public ToolboxItemCollection(ToolboxItemCollection value);
    public ToolboxItemCollection(ToolboxItem[] value);
    public ToolboxItem get_Item(int index);
    public bool Contains(ToolboxItem value);
    public void CopyTo(ToolboxItem[] array, int index);
    public int IndexOf(ToolboxItem value);
}
public class System.Drawing.Design.ToolboxItemCreatorCallback : MulticastDelegate {
    public ToolboxItemCreatorCallback(object object, IntPtr method);
    public virtual ToolboxItem Invoke(object serializedObject, string format);
    public virtual IAsyncResult BeginInvoke(object serializedObject, string format, AsyncCallback callback, object object);
    public virtual ToolboxItem EndInvoke(IAsyncResult result);
}
public class System.Drawing.Design.UITypeEditor : object {
    public bool IsDropDownResizable { get; }
    public virtual bool get_IsDropDownResizable();
    public object EditValue(IServiceProvider provider, object value);
    public virtual object EditValue(ITypeDescriptorContext context, IServiceProvider provider, object value);
    public UITypeEditorEditStyle GetEditStyle();
    public bool GetPaintValueSupported();
    public virtual bool GetPaintValueSupported(ITypeDescriptorContext context);
    public virtual UITypeEditorEditStyle GetEditStyle(ITypeDescriptorContext context);
    public void PaintValue(object value, Graphics canvas, Rectangle rectangle);
    public virtual void PaintValue(PaintValueEventArgs e);
}
public enum System.Drawing.Design.UITypeEditorEditStyle : Enum {
    public int value__;
    public static UITypeEditorEditStyle None;
    public static UITypeEditorEditStyle Modal;
    public static UITypeEditorEditStyle DropDown;
}
public class System.Drawing.Drawing2D.AdjustableArrowCap : CustomLineCap {
    public float Height { get; public set; }
    public float Width { get; public set; }
    public float MiddleInset { get; public set; }
    public bool Filled { get; public set; }
    public AdjustableArrowCap(float width, float height);
    public AdjustableArrowCap(float width, float height, bool isFilled);
    public float get_Height();
    public void set_Height(float value);
    public float get_Width();
    public void set_Width(float value);
    public float get_MiddleInset();
    public void set_MiddleInset(float value);
    public bool get_Filled();
    public void set_Filled(bool value);
}
public class System.Drawing.Drawing2D.Blend : object {
    public Single[] Factors { get; public set; }
    public Single[] Positions { get; public set; }
    public Blend(int count);
    public Single[] get_Factors();
    public void set_Factors(Single[] value);
    public Single[] get_Positions();
    public void set_Positions(Single[] value);
}
public class System.Drawing.Drawing2D.ColorBlend : object {
    public Color[] Colors { get; public set; }
    public Single[] Positions { get; public set; }
    public ColorBlend(int count);
    public Color[] get_Colors();
    public void set_Colors(Color[] value);
    public Single[] get_Positions();
    public void set_Positions(Single[] value);
}
public enum System.Drawing.Drawing2D.CombineMode : Enum {
    public int value__;
    public static CombineMode Replace;
    public static CombineMode Intersect;
    public static CombineMode Union;
    public static CombineMode Xor;
    public static CombineMode Exclude;
    public static CombineMode Complement;
}
public enum System.Drawing.Drawing2D.CompositingMode : Enum {
    public int value__;
    public static CompositingMode SourceOver;
    public static CompositingMode SourceCopy;
}
public enum System.Drawing.Drawing2D.CompositingQuality : Enum {
    public int value__;
    public static CompositingQuality Invalid;
    public static CompositingQuality Default;
    public static CompositingQuality HighSpeed;
    public static CompositingQuality HighQuality;
    public static CompositingQuality GammaCorrected;
    public static CompositingQuality AssumeLinear;
}
public enum System.Drawing.Drawing2D.CoordinateSpace : Enum {
    public int value__;
    public static CoordinateSpace World;
    public static CoordinateSpace Page;
    public static CoordinateSpace Device;
}
public class System.Drawing.Drawing2D.CustomLineCap : MarshalByRefObject {
    public LineJoin StrokeJoin { get; public set; }
    public LineCap BaseCap { get; public set; }
    public float BaseInset { get; public set; }
    public float WidthScale { get; public set; }
    public CustomLineCap(GraphicsPath fillPath, GraphicsPath strokePath);
    public CustomLineCap(GraphicsPath fillPath, GraphicsPath strokePath, LineCap baseCap);
    public CustomLineCap(GraphicsPath fillPath, GraphicsPath strokePath, LineCap baseCap, float baseInset);
    public LineJoin get_StrokeJoin();
    public void set_StrokeJoin(LineJoin value);
    public LineCap get_BaseCap();
    public void set_BaseCap(LineCap value);
    public float get_BaseInset();
    public void set_BaseInset(float value);
    public float get_WidthScale();
    public void set_WidthScale(float value);
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public sealed virtual object Clone();
    public void SetStrokeCaps(LineCap startCap, LineCap endCap);
    public void GetStrokeCaps(LineCap& startCap, LineCap& endCap);
}
public enum System.Drawing.Drawing2D.DashCap : Enum {
    public int value__;
    public static DashCap Flat;
    public static DashCap Round;
    public static DashCap Triangle;
}
public enum System.Drawing.Drawing2D.DashStyle : Enum {
    public int value__;
    public static DashStyle Solid;
    public static DashStyle Dash;
    public static DashStyle Dot;
    public static DashStyle DashDot;
    public static DashStyle DashDotDot;
    public static DashStyle Custom;
}
public enum System.Drawing.Drawing2D.FillMode : Enum {
    public int value__;
    public static FillMode Alternate;
    public static FillMode Winding;
}
public enum System.Drawing.Drawing2D.FlushIntention : Enum {
    public int value__;
    public static FlushIntention Flush;
    public static FlushIntention Sync;
}
public class System.Drawing.Drawing2D.GraphicsContainer : MarshalByRefObject {
}
public class System.Drawing.Drawing2D.GraphicsPath : MarshalByRefObject {
    public FillMode FillMode { get; public set; }
    public PathData PathData { get; }
    public int PointCount { get; }
    public Byte[] PathTypes { get; }
    public PointF[] PathPoints { get; }
    public GraphicsPath(FillMode fillMode);
    public GraphicsPath(PointF[] pts, Byte[] types);
    public GraphicsPath(PointF[] pts, Byte[] types, FillMode fillMode);
    public GraphicsPath(Point[] pts, Byte[] types);
    public GraphicsPath(Point[] pts, Byte[] types, FillMode fillMode);
    public FillMode get_FillMode();
    public void set_FillMode(FillMode value);
    public PathData get_PathData();
    public int get_PointCount();
    public Byte[] get_PathTypes();
    public PointF[] get_PathPoints();
    protected virtual override void Finalize();
    public sealed virtual object Clone();
    public sealed virtual void Dispose();
    public void Reset();
    public void StartFigure();
    public void CloseFigure();
    public void CloseAllFigures();
    public void SetMarkers();
    public void ClearMarkers();
    public void Reverse();
    public PointF GetLastPoint();
    public bool IsVisible(float x, float y);
    public bool IsVisible(PointF point);
    public bool IsVisible(float x, float y, Graphics graphics);
    public bool IsVisible(PointF pt, Graphics graphics);
    public bool IsVisible(int x, int y);
    public bool IsVisible(Point point);
    public bool IsVisible(int x, int y, Graphics graphics);
    public bool IsVisible(Point pt, Graphics graphics);
    public bool IsOutlineVisible(float x, float y, Pen pen);
    public bool IsOutlineVisible(PointF point, Pen pen);
    public bool IsOutlineVisible(float x, float y, Pen pen, Graphics graphics);
    public bool IsOutlineVisible(PointF pt, Pen pen, Graphics graphics);
    public bool IsOutlineVisible(int x, int y, Pen pen);
    public bool IsOutlineVisible(Point point, Pen pen);
    public bool IsOutlineVisible(int x, int y, Pen pen, Graphics graphics);
    public bool IsOutlineVisible(Point pt, Pen pen, Graphics graphics);
    public void AddLine(PointF pt1, PointF pt2);
    public void AddLine(float x1, float y1, float x2, float y2);
    public void AddLines(PointF[] points);
    public void AddLine(Point pt1, Point pt2);
    public void AddLine(int x1, int y1, int x2, int y2);
    public void AddLines(Point[] points);
    public void AddArc(RectangleF rect, float startAngle, float sweepAngle);
    public void AddArc(float x, float y, float width, float height, float startAngle, float sweepAngle);
    public void AddArc(Rectangle rect, float startAngle, float sweepAngle);
    public void AddArc(int x, int y, int width, int height, float startAngle, float sweepAngle);
    public void AddBezier(PointF pt1, PointF pt2, PointF pt3, PointF pt4);
    public void AddBezier(float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4);
    public void AddBeziers(PointF[] points);
    public void AddBezier(Point pt1, Point pt2, Point pt3, Point pt4);
    public void AddBezier(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4);
    public void AddBeziers(Point[] points);
    public void AddCurve(PointF[] points);
    public void AddCurve(PointF[] points, float tension);
    public void AddCurve(PointF[] points, int offset, int numberOfSegments, float tension);
    public void AddCurve(Point[] points);
    public void AddCurve(Point[] points, float tension);
    public void AddCurve(Point[] points, int offset, int numberOfSegments, float tension);
    public void AddClosedCurve(PointF[] points);
    public void AddClosedCurve(PointF[] points, float tension);
    public void AddClosedCurve(Point[] points);
    public void AddClosedCurve(Point[] points, float tension);
    public void AddRectangle(RectangleF rect);
    public void AddRectangles(RectangleF[] rects);
    public void AddRectangle(Rectangle rect);
    public void AddRectangles(Rectangle[] rects);
    public void AddEllipse(RectangleF rect);
    public void AddEllipse(float x, float y, float width, float height);
    public void AddEllipse(Rectangle rect);
    public void AddEllipse(int x, int y, int width, int height);
    public void AddPie(Rectangle rect, float startAngle, float sweepAngle);
    public void AddPie(float x, float y, float width, float height, float startAngle, float sweepAngle);
    public void AddPie(int x, int y, int width, int height, float startAngle, float sweepAngle);
    public void AddPolygon(PointF[] points);
    public void AddPolygon(Point[] points);
    public void AddPath(GraphicsPath addingPath, bool connect);
    public void AddString(string s, FontFamily family, int style, float emSize, PointF origin, StringFormat format);
    public void AddString(string s, FontFamily family, int style, float emSize, Point origin, StringFormat format);
    public void AddString(string s, FontFamily family, int style, float emSize, RectangleF layoutRect, StringFormat format);
    public void AddString(string s, FontFamily family, int style, float emSize, Rectangle layoutRect, StringFormat format);
    public void Transform(Matrix matrix);
    public RectangleF GetBounds();
    public RectangleF GetBounds(Matrix matrix);
    public RectangleF GetBounds(Matrix matrix, Pen pen);
    public void Flatten();
    public void Flatten(Matrix matrix);
    public void Flatten(Matrix matrix, float flatness);
    public void Widen(Pen pen);
    public void Widen(Pen pen, Matrix matrix);
    public void Widen(Pen pen, Matrix matrix, float flatness);
    public void Warp(PointF[] destPoints, RectangleF srcRect);
    public void Warp(PointF[] destPoints, RectangleF srcRect, Matrix matrix);
    public void Warp(PointF[] destPoints, RectangleF srcRect, Matrix matrix, WarpMode warpMode);
    public void Warp(PointF[] destPoints, RectangleF srcRect, Matrix matrix, WarpMode warpMode, float flatness);
}
public class System.Drawing.Drawing2D.GraphicsPathIterator : MarshalByRefObject {
    public int Count { get; }
    public int SubpathCount { get; }
    public GraphicsPathIterator(GraphicsPath path);
    public int get_Count();
    public int get_SubpathCount();
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    public int NextSubpath(Int32& startIndex, Int32& endIndex, Boolean& isClosed);
    public int NextSubpath(GraphicsPath path, Boolean& isClosed);
    public int NextPathType(Byte& pathType, Int32& startIndex, Int32& endIndex);
    public int NextMarker(Int32& startIndex, Int32& endIndex);
    public int NextMarker(GraphicsPath path);
    public bool HasCurve();
    public void Rewind();
    public int Enumerate(PointF[]& points, Byte[]& types);
    public int CopyData(PointF[]& points, Byte[]& types, int startIndex, int endIndex);
}
public class System.Drawing.Drawing2D.GraphicsState : MarshalByRefObject {
}
public class System.Drawing.Drawing2D.HatchBrush : Brush {
    public HatchStyle HatchStyle { get; }
    public Color ForegroundColor { get; }
    public Color BackgroundColor { get; }
    public HatchBrush(HatchStyle hatchstyle, Color foreColor);
    public HatchBrush(HatchStyle hatchstyle, Color foreColor, Color backColor);
    public HatchStyle get_HatchStyle();
    public Color get_ForegroundColor();
    public Color get_BackgroundColor();
    public virtual object Clone();
}
public enum System.Drawing.Drawing2D.HatchStyle : Enum {
    public int value__;
    public static HatchStyle Horizontal;
    public static HatchStyle Min;
    public static HatchStyle Vertical;
    public static HatchStyle ForwardDiagonal;
    public static HatchStyle BackwardDiagonal;
    public static HatchStyle Cross;
    public static HatchStyle LargeGrid;
    public static HatchStyle Max;
    public static HatchStyle DiagonalCross;
    public static HatchStyle Percent05;
    public static HatchStyle Percent10;
    public static HatchStyle Percent20;
    public static HatchStyle Percent25;
    public static HatchStyle Percent30;
    public static HatchStyle Percent40;
    public static HatchStyle Percent50;
    public static HatchStyle Percent60;
    public static HatchStyle Percent70;
    public static HatchStyle Percent75;
    public static HatchStyle Percent80;
    public static HatchStyle Percent90;
    public static HatchStyle LightDownwardDiagonal;
    public static HatchStyle LightUpwardDiagonal;
    public static HatchStyle DarkDownwardDiagonal;
    public static HatchStyle DarkUpwardDiagonal;
    public static HatchStyle WideDownwardDiagonal;
    public static HatchStyle WideUpwardDiagonal;
    public static HatchStyle LightVertical;
    public static HatchStyle LightHorizontal;
    public static HatchStyle NarrowVertical;
    public static HatchStyle NarrowHorizontal;
    public static HatchStyle DarkVertical;
    public static HatchStyle DarkHorizontal;
    public static HatchStyle DashedDownwardDiagonal;
    public static HatchStyle DashedUpwardDiagonal;
    public static HatchStyle DashedHorizontal;
    public static HatchStyle DashedVertical;
    public static HatchStyle SmallConfetti;
    public static HatchStyle LargeConfetti;
    public static HatchStyle ZigZag;
    public static HatchStyle Wave;
    public static HatchStyle DiagonalBrick;
    public static HatchStyle HorizontalBrick;
    public static HatchStyle Weave;
    public static HatchStyle Plaid;
    public static HatchStyle Divot;
    public static HatchStyle DottedGrid;
    public static HatchStyle DottedDiamond;
    public static HatchStyle Shingle;
    public static HatchStyle Trellis;
    public static HatchStyle Sphere;
    public static HatchStyle SmallGrid;
    public static HatchStyle SmallCheckerBoard;
    public static HatchStyle LargeCheckerBoard;
    public static HatchStyle OutlinedDiamond;
    public static HatchStyle SolidDiamond;
}
public enum System.Drawing.Drawing2D.InterpolationMode : Enum {
    public int value__;
    public static InterpolationMode Invalid;
    public static InterpolationMode Default;
    public static InterpolationMode Low;
    public static InterpolationMode High;
    public static InterpolationMode Bilinear;
    public static InterpolationMode Bicubic;
    public static InterpolationMode NearestNeighbor;
    public static InterpolationMode HighQualityBilinear;
    public static InterpolationMode HighQualityBicubic;
}
public class System.Drawing.Drawing2D.LinearGradientBrush : Brush {
    public Color[] LinearColors { get; public set; }
    public RectangleF Rectangle { get; }
    public bool GammaCorrection { get; public set; }
    public Blend Blend { get; public set; }
    public ColorBlend InterpolationColors { get; public set; }
    public WrapMode WrapMode { get; public set; }
    public Matrix Transform { get; public set; }
    public LinearGradientBrush(PointF point1, PointF point2, Color color1, Color color2);
    public LinearGradientBrush(Point point1, Point point2, Color color1, Color color2);
    public LinearGradientBrush(RectangleF rect, Color color1, Color color2, LinearGradientMode linearGradientMode);
    public LinearGradientBrush(Rectangle rect, Color color1, Color color2, LinearGradientMode linearGradientMode);
    public LinearGradientBrush(RectangleF rect, Color color1, Color color2, float angle);
    public LinearGradientBrush(RectangleF rect, Color color1, Color color2, float angle, bool isAngleScaleable);
    public LinearGradientBrush(Rectangle rect, Color color1, Color color2, float angle);
    public LinearGradientBrush(Rectangle rect, Color color1, Color color2, float angle, bool isAngleScaleable);
    public Color[] get_LinearColors();
    public void set_LinearColors(Color[] value);
    public RectangleF get_Rectangle();
    public bool get_GammaCorrection();
    public void set_GammaCorrection(bool value);
    public Blend get_Blend();
    public void set_Blend(Blend value);
    public ColorBlend get_InterpolationColors();
    public void set_InterpolationColors(ColorBlend value);
    public WrapMode get_WrapMode();
    public void set_WrapMode(WrapMode value);
    public Matrix get_Transform();
    public void set_Transform(Matrix value);
    public virtual object Clone();
    public void SetSigmaBellShape(float focus);
    public void SetSigmaBellShape(float focus, float scale);
    public void SetBlendTriangularShape(float focus);
    public void SetBlendTriangularShape(float focus, float scale);
    public void ResetTransform();
    public void MultiplyTransform(Matrix matrix);
    public void MultiplyTransform(Matrix matrix, MatrixOrder order);
    public void TranslateTransform(float dx, float dy);
    public void TranslateTransform(float dx, float dy, MatrixOrder order);
    public void ScaleTransform(float sx, float sy);
    public void ScaleTransform(float sx, float sy, MatrixOrder order);
    public void RotateTransform(float angle);
    public void RotateTransform(float angle, MatrixOrder order);
}
public enum System.Drawing.Drawing2D.LinearGradientMode : Enum {
    public int value__;
    public static LinearGradientMode Horizontal;
    public static LinearGradientMode Vertical;
    public static LinearGradientMode ForwardDiagonal;
    public static LinearGradientMode BackwardDiagonal;
}
public enum System.Drawing.Drawing2D.LineCap : Enum {
    public int value__;
    public static LineCap Flat;
    public static LineCap Square;
    public static LineCap Round;
    public static LineCap Triangle;
    public static LineCap NoAnchor;
    public static LineCap SquareAnchor;
    public static LineCap RoundAnchor;
    public static LineCap DiamondAnchor;
    public static LineCap ArrowAnchor;
    public static LineCap AnchorMask;
    public static LineCap Custom;
}
public enum System.Drawing.Drawing2D.LineJoin : Enum {
    public int value__;
    public static LineJoin Miter;
    public static LineJoin Bevel;
    public static LineJoin Round;
    public static LineJoin MiterClipped;
}
public class System.Drawing.Drawing2D.Matrix : MarshalByRefObject {
    public Single[] Elements { get; }
    public float OffsetX { get; }
    public float OffsetY { get; }
    public bool IsInvertible { get; }
    public bool IsIdentity { get; }
    public Matrix(float m11, float m12, float m21, float m22, float dx, float dy);
    public Matrix(RectangleF rect, PointF[] plgpts);
    public Matrix(Rectangle rect, Point[] plgpts);
    public Single[] get_Elements();
    public float get_OffsetX();
    public float get_OffsetY();
    public bool get_IsInvertible();
    public bool get_IsIdentity();
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    public Matrix Clone();
    public void Reset();
    public void Multiply(Matrix matrix);
    public void Multiply(Matrix matrix, MatrixOrder order);
    public void Translate(float offsetX, float offsetY);
    public void Translate(float offsetX, float offsetY, MatrixOrder order);
    public void Scale(float scaleX, float scaleY);
    public void Scale(float scaleX, float scaleY, MatrixOrder order);
    public void Rotate(float angle);
    public void Rotate(float angle, MatrixOrder order);
    public void RotateAt(float angle, PointF point);
    public void RotateAt(float angle, PointF point, MatrixOrder order);
    public void Shear(float shearX, float shearY);
    public void Shear(float shearX, float shearY, MatrixOrder order);
    public void Invert();
    public void TransformPoints(PointF[] pts);
    public void TransformPoints(Point[] pts);
    public void TransformVectors(PointF[] pts);
    public void VectorTransformPoints(Point[] pts);
    public void TransformVectors(Point[] pts);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public enum System.Drawing.Drawing2D.MatrixOrder : Enum {
    public int value__;
    public static MatrixOrder Prepend;
    public static MatrixOrder Append;
}
public class System.Drawing.Drawing2D.PathData : object {
    public PointF[] Points { get; public set; }
    public Byte[] Types { get; public set; }
    public PointF[] get_Points();
    public void set_Points(PointF[] value);
    public Byte[] get_Types();
    public void set_Types(Byte[] value);
}
public class System.Drawing.Drawing2D.PathGradientBrush : Brush {
    public Color CenterColor { get; public set; }
    public Color[] SurroundColors { get; public set; }
    public PointF CenterPoint { get; public set; }
    public RectangleF Rectangle { get; }
    public Blend Blend { get; public set; }
    public ColorBlend InterpolationColors { get; public set; }
    public Matrix Transform { get; public set; }
    public PointF FocusScales { get; public set; }
    public WrapMode WrapMode { get; public set; }
    public PathGradientBrush(PointF[] points);
    public PathGradientBrush(PointF[] points, WrapMode wrapMode);
    public PathGradientBrush(Point[] points);
    public PathGradientBrush(Point[] points, WrapMode wrapMode);
    public PathGradientBrush(GraphicsPath path);
    public Color get_CenterColor();
    public void set_CenterColor(Color value);
    public Color[] get_SurroundColors();
    public void set_SurroundColors(Color[] value);
    public PointF get_CenterPoint();
    public void set_CenterPoint(PointF value);
    public RectangleF get_Rectangle();
    public Blend get_Blend();
    public void set_Blend(Blend value);
    public ColorBlend get_InterpolationColors();
    public void set_InterpolationColors(ColorBlend value);
    public Matrix get_Transform();
    public void set_Transform(Matrix value);
    public PointF get_FocusScales();
    public void set_FocusScales(PointF value);
    public WrapMode get_WrapMode();
    public void set_WrapMode(WrapMode value);
    public virtual object Clone();
    public void SetSigmaBellShape(float focus);
    public void SetSigmaBellShape(float focus, float scale);
    public void SetBlendTriangularShape(float focus);
    public void SetBlendTriangularShape(float focus, float scale);
    public void ResetTransform();
    public void MultiplyTransform(Matrix matrix);
    public void MultiplyTransform(Matrix matrix, MatrixOrder order);
    public void TranslateTransform(float dx, float dy);
    public void TranslateTransform(float dx, float dy, MatrixOrder order);
    public void ScaleTransform(float sx, float sy);
    public void ScaleTransform(float sx, float sy, MatrixOrder order);
    public void RotateTransform(float angle);
    public void RotateTransform(float angle, MatrixOrder order);
}
public enum System.Drawing.Drawing2D.PathPointType : Enum {
    public int value__;
    public static PathPointType Start;
    public static PathPointType Line;
    public static PathPointType Bezier;
    public static PathPointType Bezier3;
    public static PathPointType PathTypeMask;
    public static PathPointType DashMode;
    public static PathPointType PathMarker;
    public static PathPointType CloseSubpath;
}
public enum System.Drawing.Drawing2D.PenAlignment : Enum {
    public int value__;
    public static PenAlignment Center;
    public static PenAlignment Inset;
    public static PenAlignment Outset;
    public static PenAlignment Left;
    public static PenAlignment Right;
}
public enum System.Drawing.Drawing2D.PenType : Enum {
    public int value__;
    public static PenType SolidColor;
    public static PenType HatchFill;
    public static PenType TextureFill;
    public static PenType PathGradient;
    public static PenType LinearGradient;
}
public enum System.Drawing.Drawing2D.PixelOffsetMode : Enum {
    public int value__;
    public static PixelOffsetMode Invalid;
    public static PixelOffsetMode Default;
    public static PixelOffsetMode HighSpeed;
    public static PixelOffsetMode HighQuality;
    public static PixelOffsetMode None;
    public static PixelOffsetMode Half;
}
public enum System.Drawing.Drawing2D.QualityMode : Enum {
    public int value__;
    public static QualityMode Invalid;
    public static QualityMode Default;
    public static QualityMode Low;
    public static QualityMode High;
}
public class System.Drawing.Drawing2D.RegionData : object {
    public Byte[] Data { get; public set; }
    public Byte[] get_Data();
    public void set_Data(Byte[] value);
}
public enum System.Drawing.Drawing2D.SmoothingMode : Enum {
    public int value__;
    public static SmoothingMode Invalid;
    public static SmoothingMode Default;
    public static SmoothingMode HighSpeed;
    public static SmoothingMode HighQuality;
    public static SmoothingMode None;
    public static SmoothingMode AntiAlias;
}
public enum System.Drawing.Drawing2D.WarpMode : Enum {
    public int value__;
    public static WarpMode Perspective;
    public static WarpMode Bilinear;
}
public enum System.Drawing.Drawing2D.WrapMode : Enum {
    public int value__;
    public static WrapMode Tile;
    public static WrapMode TileFlipX;
    public static WrapMode TileFlipY;
    public static WrapMode TileFlipXY;
    public static WrapMode Clamp;
}
[EditorAttribute("System.Drawing.Design.FontEditor, System.Drawing.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor")]
[ComVisibleAttribute("True")]
[TypeConverterAttribute("System.Drawing.FontConverter")]
public class System.Drawing.Font : MarshalByRefObject {
    private string _name;
    private string _familyName;
    private FontFamily _family;
    private float _emSize;
    private FontStyle _style;
    private GraphicsUnit _unit;
    private byte _gdiCharSet;
    private bool _gdiVerticalFont;
    private Font _prototype;
    private FontStyle _newStyle;
    private int _hashCode;
    internal static Font MockInstance;
    [BrowsableAttribute("False")]
public FontFamily FontFamily { get; }
    [DesignerSerializationVisibilityAttribute("0")]
public bool Bold { get; }
    [DesignerSerializationVisibilityAttribute("0")]
public byte GdiCharSet { get; }
    [DesignerSerializationVisibilityAttribute("0")]
public bool GdiVerticalFont { get; }
    [DesignerSerializationVisibilityAttribute("0")]
public bool Italic { get; }
    [TypeConverterAttribute("System.Drawing.FontConverter/FontNameConverter")]
[EditorAttribute("System.Drawing.Design.FontNameEditor, System.Drawing.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor")]
[DesignerSerializationVisibilityAttribute("0")]
public string Name { get; }
    [BrowsableAttribute("False")]
public string OriginalFontName { get; }
    [DesignerSerializationVisibilityAttribute("0")]
public bool Strikeout { get; }
    [DesignerSerializationVisibilityAttribute("0")]
public bool Underline { get; }
    [BrowsableAttribute("False")]
public FontStyle Style { get; }
    public float Size { get; }
    [BrowsableAttribute("False")]
public float SizeInPoints { get; }
    public GraphicsUnit Unit { get; }
    [BrowsableAttribute("False")]
public int Height { get; }
    [BrowsableAttribute("False")]
public bool IsSystemFont { get; }
    [BrowsableAttribute("False")]
public string SystemFontName { get; }
    public Font(Font prototype, FontStyle newStyle);
    public Font(FontFamily family, float emSize, FontStyle style, GraphicsUnit unit);
    public Font(FontFamily family, float emSize, FontStyle style, GraphicsUnit unit, byte gdiCharSet);
    public Font(FontFamily family, float emSize, FontStyle style, GraphicsUnit unit, byte gdiCharSet, bool gdiVerticalFont);
    public Font(string familyName, float emSize, FontStyle style, GraphicsUnit unit, byte gdiCharSet);
    public Font(string familyName, float emSize, FontStyle style, GraphicsUnit unit, byte gdiCharSet, bool gdiVerticalFont);
    public Font(FontFamily family, float emSize, FontStyle style);
    public Font(FontFamily family, float emSize, GraphicsUnit unit);
    public Font(FontFamily family, float emSize);
    public Font(string familyName, float emSize, FontStyle style, GraphicsUnit unit);
    public Font(string familyName, float emSize, FontStyle style);
    public Font(string familyName, float emSize, GraphicsUnit unit);
    public Font(string familyName, float emSize);
    private static Font();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public FontFamily get_FontFamily();
    public bool get_Bold();
    public byte get_GdiCharSet();
    public bool get_GdiVerticalFont();
    public bool get_Italic();
    public string get_Name();
    public string get_OriginalFontName();
    public bool get_Strikeout();
    public bool get_Underline();
    public FontStyle get_Style();
    public float get_Size();
    public float get_SizeInPoints();
    public GraphicsUnit get_Unit();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public int get_Height();
    public bool get_IsSystemFont();
    public string get_SystemFontName();
    protected virtual override void Finalize();
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo si, StreamingContext context);
    public static Font FromHfont(IntPtr hfont);
    public static Font FromLogFont(object lf);
    public static Font FromLogFont(object lf, IntPtr hdc);
    public static Font FromHdc(IntPtr hdc);
    public sealed virtual object Clone();
    public sealed virtual void Dispose();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public void ToLogFont(object logFont);
    public void ToLogFont(object logFont, Graphics graphics);
    public IntPtr ToHfont();
    public float GetHeight(Graphics graphics);
    public float GetHeight();
    public float GetHeight(float dpi);
}
public class System.Drawing.FontConverter : TypeConverter {
    protected virtual override void Finalize();
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
    public virtual object CreateInstance(ITypeDescriptorContext context, IDictionary propertyValues);
    public virtual bool GetCreateInstanceSupported(ITypeDescriptorContext context);
    public virtual PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes);
    public virtual bool GetPropertiesSupported(ITypeDescriptorContext context);
}
public class System.Drawing.FontFamily : MarshalByRefObject {
    public static FontFamily _Default;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private string <Name>k__BackingField;
    public string Name { get; private set; }
    public static FontFamily[] Families { get; }
    public static FontFamily GenericSansSerif { get; }
    public static FontFamily GenericSerif { get; }
    public static FontFamily GenericMonospace { get; }
    public FontFamily(string name);
    public FontFamily(string name, FontCollection fontCollection);
    public FontFamily(GenericFontFamilies genericFamily);
    private static FontFamily();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    public static FontFamily[] get_Families();
    public static FontFamily get_GenericSansSerif();
    public static FontFamily get_GenericSerif();
    public static FontFamily get_GenericMonospace();
    public sealed virtual void Dispose();
    public virtual bool Equals(object obj);
    public virtual string ToString();
    public virtual int GetHashCode();
    public string GetName(int language);
    [ObsoleteAttribute("Do not use method GetFamilies, use property Families instead")]
public static FontFamily[] GetFamilies(Graphics graphics);
    public bool IsStyleAvailable(FontStyle style);
    public int GetEmHeight(FontStyle style);
    public int GetCellAscent(FontStyle style);
    public int GetCellDescent(FontStyle style);
    public int GetLineSpacing(FontStyle style);
}
[FlagsAttribute]
public enum System.Drawing.FontStyle : Enum {
    public int value__;
    public static FontStyle Regular;
    public static FontStyle Bold;
    public static FontStyle Italic;
    public static FontStyle Underline;
    public static FontStyle Strikeout;
}
public class System.Drawing.Graphics : MarshalByRefObject {
    public CompositingMode CompositingMode { get; public set; }
    public Point RenderingOrigin { get; public set; }
    public CompositingQuality CompositingQuality { get; public set; }
    public TextRenderingHint TextRenderingHint { get; public set; }
    public int TextContrast { get; public set; }
    public SmoothingMode SmoothingMode { get; public set; }
    public PixelOffsetMode PixelOffsetMode { get; public set; }
    public InterpolationMode InterpolationMode { get; public set; }
    public Matrix Transform { get; public set; }
    public GraphicsUnit PageUnit { get; public set; }
    public float PageScale { get; public set; }
    public float DpiX { get; }
    public float DpiY { get; }
    public Region Clip { get; public set; }
    public RectangleF ClipBounds { get; }
    public bool IsClipEmpty { get; }
    public RectangleF VisibleClipBounds { get; }
    public bool IsVisibleClipEmpty { get; }
    public CompositingMode get_CompositingMode();
    public void set_CompositingMode(CompositingMode value);
    public Point get_RenderingOrigin();
    public void set_RenderingOrigin(Point value);
    public CompositingQuality get_CompositingQuality();
    public void set_CompositingQuality(CompositingQuality value);
    public TextRenderingHint get_TextRenderingHint();
    public void set_TextRenderingHint(TextRenderingHint value);
    public int get_TextContrast();
    public void set_TextContrast(int value);
    public SmoothingMode get_SmoothingMode();
    public void set_SmoothingMode(SmoothingMode value);
    public PixelOffsetMode get_PixelOffsetMode();
    public void set_PixelOffsetMode(PixelOffsetMode value);
    public InterpolationMode get_InterpolationMode();
    public void set_InterpolationMode(InterpolationMode value);
    public Matrix get_Transform();
    public void set_Transform(Matrix value);
    public GraphicsUnit get_PageUnit();
    public void set_PageUnit(GraphicsUnit value);
    public float get_PageScale();
    public void set_PageScale(float value);
    public float get_DpiX();
    public float get_DpiY();
    public Region get_Clip();
    public void set_Clip(Region value);
    public RectangleF get_ClipBounds();
    public bool get_IsClipEmpty();
    public RectangleF get_VisibleClipBounds();
    public bool get_IsVisibleClipEmpty();
    protected virtual override void Finalize();
    [EditorBrowsableAttribute("2")]
public static Graphics FromHdc(IntPtr hdc);
    [EditorBrowsableAttribute("2")]
public static Graphics FromHdcInternal(IntPtr hdc);
    [EditorBrowsableAttribute("2")]
public static Graphics FromHdc(IntPtr hdc, IntPtr hdevice);
    [EditorBrowsableAttribute("2")]
public static Graphics FromHwnd(IntPtr hwnd);
    [EditorBrowsableAttribute("2")]
public static Graphics FromHwndInternal(IntPtr hwnd);
    public static Graphics FromImage(Image image);
    public sealed virtual IntPtr GetHdc();
    [EditorBrowsableAttribute("2")]
public void ReleaseHdc(IntPtr hdc);
    public sealed virtual void ReleaseHdc();
    [EditorBrowsableAttribute("1")]
public void ReleaseHdcInternal(IntPtr hdc);
    public sealed virtual void Dispose();
    public void Flush();
    public void Flush(FlushIntention intention);
    public void CopyFromScreen(Point upperLeftSource, Point upperLeftDestination, Size blockRegionSize);
    public void CopyFromScreen(int sourceX, int sourceY, int destinationX, int destinationY, Size blockRegionSize);
    public void CopyFromScreen(Point upperLeftSource, Point upperLeftDestination, Size blockRegionSize, CopyPixelOperation copyPixelOperation);
    public void CopyFromScreen(int sourceX, int sourceY, int destinationX, int destinationY, Size blockRegionSize, CopyPixelOperation copyPixelOperation);
    public void ResetTransform();
    public void MultiplyTransform(Matrix matrix);
    public void MultiplyTransform(Matrix matrix, MatrixOrder order);
    public void TranslateTransform(float dx, float dy);
    public void TranslateTransform(float dx, float dy, MatrixOrder order);
    public void ScaleTransform(float sx, float sy);
    public void ScaleTransform(float sx, float sy, MatrixOrder order);
    public void RotateTransform(float angle);
    public void RotateTransform(float angle, MatrixOrder order);
    public void TransformPoints(CoordinateSpace destSpace, CoordinateSpace srcSpace, PointF[] pts);
    public void TransformPoints(CoordinateSpace destSpace, CoordinateSpace srcSpace, Point[] pts);
    public Color GetNearestColor(Color color);
    public void DrawLine(Pen pen, float x1, float y1, float x2, float y2);
    public void DrawLine(Pen pen, PointF pt1, PointF pt2);
    public void DrawLines(Pen pen, PointF[] points);
    public void DrawLine(Pen pen, int x1, int y1, int x2, int y2);
    public void DrawLine(Pen pen, Point pt1, Point pt2);
    public void DrawLines(Pen pen, Point[] points);
    public void DrawArc(Pen pen, float x, float y, float width, float height, float startAngle, float sweepAngle);
    public void DrawArc(Pen pen, RectangleF rect, float startAngle, float sweepAngle);
    public void DrawArc(Pen pen, int x, int y, int width, int height, int startAngle, int sweepAngle);
    public void DrawArc(Pen pen, Rectangle rect, float startAngle, float sweepAngle);
    public void DrawBezier(Pen pen, float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4);
    public void DrawBezier(Pen pen, PointF pt1, PointF pt2, PointF pt3, PointF pt4);
    public void DrawBeziers(Pen pen, PointF[] points);
    public void DrawBezier(Pen pen, Point pt1, Point pt2, Point pt3, Point pt4);
    public void DrawBeziers(Pen pen, Point[] points);
    public void DrawRectangle(Pen pen, Rectangle rect);
    public void DrawRectangle(Pen pen, float x, float y, float width, float height);
    public void DrawRectangle(Pen pen, int x, int y, int width, int height);
    public void DrawRectangles(Pen pen, RectangleF[] rects);
    public void DrawRectangles(Pen pen, Rectangle[] rects);
    public void DrawEllipse(Pen pen, RectangleF rect);
    public void DrawEllipse(Pen pen, float x, float y, float width, float height);
    public void DrawEllipse(Pen pen, Rectangle rect);
    public void DrawEllipse(Pen pen, int x, int y, int width, int height);
    public void DrawPie(Pen pen, RectangleF rect, float startAngle, float sweepAngle);
    public void DrawPie(Pen pen, float x, float y, float width, float height, float startAngle, float sweepAngle);
    public void DrawPie(Pen pen, Rectangle rect, float startAngle, float sweepAngle);
    public void DrawPie(Pen pen, int x, int y, int width, int height, int startAngle, int sweepAngle);
    public void DrawPolygon(Pen pen, PointF[] points);
    public void DrawPolygon(Pen pen, Point[] points);
    public void DrawPath(Pen pen, GraphicsPath path);
    public void DrawCurve(Pen pen, PointF[] points);
    public void DrawCurve(Pen pen, PointF[] points, float tension);
    public void DrawCurve(Pen pen, PointF[] points, int offset, int numberOfSegments);
    public void DrawCurve(Pen pen, PointF[] points, int offset, int numberOfSegments, float tension);
    public void DrawCurve(Pen pen, Point[] points);
    public void DrawCurve(Pen pen, Point[] points, float tension);
    public void DrawCurve(Pen pen, Point[] points, int offset, int numberOfSegments, float tension);
    public void DrawClosedCurve(Pen pen, PointF[] points);
    public void DrawClosedCurve(Pen pen, PointF[] points, float tension, FillMode fillmode);
    public void DrawClosedCurve(Pen pen, Point[] points);
    public void DrawClosedCurve(Pen pen, Point[] points, float tension, FillMode fillmode);
    public void Clear(Color color);
    public void FillRectangle(Brush brush, RectangleF rect);
    public void FillRectangle(Brush brush, float x, float y, float width, float height);
    public void FillRectangle(Brush brush, Rectangle rect);
    public void FillRectangle(Brush brush, int x, int y, int width, int height);
    public void FillRectangles(Brush brush, RectangleF[] rects);
    public void FillRectangles(Brush brush, Rectangle[] rects);
    public void FillPolygon(Brush brush, PointF[] points);
    public void FillPolygon(Brush brush, PointF[] points, FillMode fillMode);
    public void FillPolygon(Brush brush, Point[] points);
    public void FillPolygon(Brush brush, Point[] points, FillMode fillMode);
    public void FillEllipse(Brush brush, RectangleF rect);
    public void FillEllipse(Brush brush, float x, float y, float width, float height);
    public void FillEllipse(Brush brush, Rectangle rect);
    public void FillEllipse(Brush brush, int x, int y, int width, int height);
    public void FillPie(Brush brush, Rectangle rect, float startAngle, float sweepAngle);
    public void FillPie(Brush brush, float x, float y, float width, float height, float startAngle, float sweepAngle);
    public void FillPie(Brush brush, int x, int y, int width, int height, int startAngle, int sweepAngle);
    public void FillPath(Brush brush, GraphicsPath path);
    public void FillClosedCurve(Brush brush, PointF[] points);
    public void FillClosedCurve(Brush brush, PointF[] points, FillMode fillmode);
    public void FillClosedCurve(Brush brush, PointF[] points, FillMode fillmode, float tension);
    public void FillClosedCurve(Brush brush, Point[] points);
    public void FillClosedCurve(Brush brush, Point[] points, FillMode fillmode);
    public void FillClosedCurve(Brush brush, Point[] points, FillMode fillmode, float tension);
    public void FillRegion(Brush brush, Region region);
    public void DrawString(string s, Font font, Brush brush, float x, float y);
    public void DrawString(string s, Font font, Brush brush, PointF point);
    public void DrawString(string s, Font font, Brush brush, float x, float y, StringFormat format);
    public void DrawString(string s, Font font, Brush brush, PointF point, StringFormat format);
    public void DrawString(string s, Font font, Brush brush, RectangleF layoutRectangle);
    public void DrawString(string s, Font font, Brush brush, RectangleF layoutRectangle, StringFormat format);
    public SizeF MeasureString(string text, Font font, SizeF layoutArea, StringFormat stringFormat, Int32& charactersFitted, Int32& linesFilled);
    public SizeF MeasureString(string text, Font font, PointF origin, StringFormat stringFormat);
    public SizeF MeasureString(string text, Font font, SizeF layoutArea);
    public SizeF MeasureString(string text, Font font, SizeF layoutArea, StringFormat stringFormat);
    public SizeF MeasureString(string text, Font font);
    public SizeF MeasureString(string text, Font font, int width);
    public SizeF MeasureString(string text, Font font, int width, StringFormat format);
    public Region[] MeasureCharacterRanges(string text, Font font, RectangleF layoutRect, StringFormat stringFormat);
    public void DrawIcon(Icon icon, int x, int y);
    public void DrawIcon(Icon icon, Rectangle targetRect);
    public void DrawIconUnstretched(Icon icon, Rectangle targetRect);
    public void DrawImage(Image image, PointF point);
    public void DrawImage(Image image, float x, float y);
    public void DrawImage(Image image, RectangleF rect);
    public void DrawImage(Image image, float x, float y, float width, float height);
    public void DrawImage(Image image, Point point);
    public void DrawImage(Image image, int x, int y);
    public void DrawImage(Image image, Rectangle rect);
    public void DrawImage(Image image, int x, int y, int width, int height);
    public void DrawImageUnscaled(Image image, Point point);
    public void DrawImageUnscaled(Image image, int x, int y);
    public void DrawImageUnscaled(Image image, Rectangle rect);
    public void DrawImageUnscaled(Image image, int x, int y, int width, int height);
    public void DrawImageUnscaledAndClipped(Image image, Rectangle rect);
    public void DrawImage(Image image, PointF[] destPoints);
    public void DrawImage(Image image, Point[] destPoints);
    public void DrawImage(Image image, float x, float y, RectangleF srcRect, GraphicsUnit srcUnit);
    public void DrawImage(Image image, int x, int y, Rectangle srcRect, GraphicsUnit srcUnit);
    public void DrawImage(Image image, RectangleF destRect, RectangleF srcRect, GraphicsUnit srcUnit);
    public void DrawImage(Image image, Rectangle destRect, Rectangle srcRect, GraphicsUnit srcUnit);
    public void DrawImage(Image image, PointF[] destPoints, RectangleF srcRect, GraphicsUnit srcUnit);
    public void DrawImage(Image image, PointF[] destPoints, RectangleF srcRect, GraphicsUnit srcUnit, ImageAttributes imageAttr);
    public void DrawImage(Image image, PointF[] destPoints, RectangleF srcRect, GraphicsUnit srcUnit, ImageAttributes imageAttr, DrawImageAbort callback);
    public void DrawImage(Image image, PointF[] destPoints, RectangleF srcRect, GraphicsUnit srcUnit, ImageAttributes imageAttr, DrawImageAbort callback, int callbackData);
    public void DrawImage(Image image, Point[] destPoints, Rectangle srcRect, GraphicsUnit srcUnit);
    public void DrawImage(Image image, Point[] destPoints, Rectangle srcRect, GraphicsUnit srcUnit, ImageAttributes imageAttr);
    public void DrawImage(Image image, Point[] destPoints, Rectangle srcRect, GraphicsUnit srcUnit, ImageAttributes imageAttr, DrawImageAbort callback);
    public void DrawImage(Image image, Point[] destPoints, Rectangle srcRect, GraphicsUnit srcUnit, ImageAttributes imageAttr, DrawImageAbort callback, int callbackData);
    public void DrawImage(Image image, Rectangle destRect, float srcX, float srcY, float srcWidth, float srcHeight, GraphicsUnit srcUnit);
    public void DrawImage(Image image, Rectangle destRect, float srcX, float srcY, float srcWidth, float srcHeight, GraphicsUnit srcUnit, ImageAttributes imageAttrs);
    public void DrawImage(Image image, Rectangle destRect, float srcX, float srcY, float srcWidth, float srcHeight, GraphicsUnit srcUnit, ImageAttributes imageAttrs, DrawImageAbort callback);
    public void DrawImage(Image image, Rectangle destRect, float srcX, float srcY, float srcWidth, float srcHeight, GraphicsUnit srcUnit, ImageAttributes imageAttrs, DrawImageAbort callback, IntPtr callbackData);
    public void DrawImage(Image image, Rectangle destRect, int srcX, int srcY, int srcWidth, int srcHeight, GraphicsUnit srcUnit);
    public void DrawImage(Image image, Rectangle destRect, int srcX, int srcY, int srcWidth, int srcHeight, GraphicsUnit srcUnit, ImageAttributes imageAttr);
    public void DrawImage(Image image, Rectangle destRect, int srcX, int srcY, int srcWidth, int srcHeight, GraphicsUnit srcUnit, ImageAttributes imageAttr, DrawImageAbort callback);
    public void DrawImage(Image image, Rectangle destRect, int srcX, int srcY, int srcWidth, int srcHeight, GraphicsUnit srcUnit, ImageAttributes imageAttrs, DrawImageAbort callback, IntPtr callbackData);
    public void EnumerateMetafile(Metafile metafile, PointF destPoint, EnumerateMetafileProc callback);
    public void EnumerateMetafile(Metafile metafile, PointF destPoint, EnumerateMetafileProc callback, IntPtr callbackData);
    public void EnumerateMetafile(Metafile metafile, PointF destPoint, EnumerateMetafileProc callback, IntPtr callbackData, ImageAttributes imageAttr);
    public void EnumerateMetafile(Metafile metafile, Point destPoint, EnumerateMetafileProc callback);
    public void EnumerateMetafile(Metafile metafile, Point destPoint, EnumerateMetafileProc callback, IntPtr callbackData);
    public void EnumerateMetafile(Metafile metafile, Point destPoint, EnumerateMetafileProc callback, IntPtr callbackData, ImageAttributes imageAttr);
    public void EnumerateMetafile(Metafile metafile, RectangleF destRect, EnumerateMetafileProc callback);
    public void EnumerateMetafile(Metafile metafile, RectangleF destRect, EnumerateMetafileProc callback, IntPtr callbackData);
    public void EnumerateMetafile(Metafile metafile, RectangleF destRect, EnumerateMetafileProc callback, IntPtr callbackData, ImageAttributes imageAttr);
    public void EnumerateMetafile(Metafile metafile, Rectangle destRect, EnumerateMetafileProc callback);
    public void EnumerateMetafile(Metafile metafile, Rectangle destRect, EnumerateMetafileProc callback, IntPtr callbackData);
    public void EnumerateMetafile(Metafile metafile, Rectangle destRect, EnumerateMetafileProc callback, IntPtr callbackData, ImageAttributes imageAttr);
    public void EnumerateMetafile(Metafile metafile, PointF[] destPoints, EnumerateMetafileProc callback);
    public void EnumerateMetafile(Metafile metafile, PointF[] destPoints, EnumerateMetafileProc callback, IntPtr callbackData);
    public void EnumerateMetafile(Metafile metafile, PointF[] destPoints, EnumerateMetafileProc callback, IntPtr callbackData, ImageAttributes imageAttr);
    public void EnumerateMetafile(Metafile metafile, Point[] destPoints, EnumerateMetafileProc callback);
    public void EnumerateMetafile(Metafile metafile, Point[] destPoints, EnumerateMetafileProc callback, IntPtr callbackData);
    public void EnumerateMetafile(Metafile metafile, Point[] destPoints, EnumerateMetafileProc callback, IntPtr callbackData, ImageAttributes imageAttr);
    public void EnumerateMetafile(Metafile metafile, PointF destPoint, RectangleF srcRect, GraphicsUnit srcUnit, EnumerateMetafileProc callback);
    public void EnumerateMetafile(Metafile metafile, PointF destPoint, RectangleF srcRect, GraphicsUnit srcUnit, EnumerateMetafileProc callback, IntPtr callbackData);
    public void EnumerateMetafile(Metafile metafile, PointF destPoint, RectangleF srcRect, GraphicsUnit unit, EnumerateMetafileProc callback, IntPtr callbackData, ImageAttributes imageAttr);
    public void EnumerateMetafile(Metafile metafile, Point destPoint, Rectangle srcRect, GraphicsUnit srcUnit, EnumerateMetafileProc callback);
    public void EnumerateMetafile(Metafile metafile, Point destPoint, Rectangle srcRect, GraphicsUnit srcUnit, EnumerateMetafileProc callback, IntPtr callbackData);
    public void EnumerateMetafile(Metafile metafile, Point destPoint, Rectangle srcRect, GraphicsUnit unit, EnumerateMetafileProc callback, IntPtr callbackData, ImageAttributes imageAttr);
    public void EnumerateMetafile(Metafile metafile, RectangleF destRect, RectangleF srcRect, GraphicsUnit srcUnit, EnumerateMetafileProc callback);
    public void EnumerateMetafile(Metafile metafile, RectangleF destRect, RectangleF srcRect, GraphicsUnit srcUnit, EnumerateMetafileProc callback, IntPtr callbackData);
    public void EnumerateMetafile(Metafile metafile, RectangleF destRect, RectangleF srcRect, GraphicsUnit unit, EnumerateMetafileProc callback, IntPtr callbackData, ImageAttributes imageAttr);
    public void EnumerateMetafile(Metafile metafile, Rectangle destRect, Rectangle srcRect, GraphicsUnit srcUnit, EnumerateMetafileProc callback);
    public void EnumerateMetafile(Metafile metafile, Rectangle destRect, Rectangle srcRect, GraphicsUnit srcUnit, EnumerateMetafileProc callback, IntPtr callbackData);
    public void EnumerateMetafile(Metafile metafile, Rectangle destRect, Rectangle srcRect, GraphicsUnit unit, EnumerateMetafileProc callback, IntPtr callbackData, ImageAttributes imageAttr);
    public void EnumerateMetafile(Metafile metafile, PointF[] destPoints, RectangleF srcRect, GraphicsUnit srcUnit, EnumerateMetafileProc callback);
    public void EnumerateMetafile(Metafile metafile, PointF[] destPoints, RectangleF srcRect, GraphicsUnit srcUnit, EnumerateMetafileProc callback, IntPtr callbackData);
    public void EnumerateMetafile(Metafile metafile, PointF[] destPoints, RectangleF srcRect, GraphicsUnit unit, EnumerateMetafileProc callback, IntPtr callbackData, ImageAttributes imageAttr);
    public void EnumerateMetafile(Metafile metafile, Point[] destPoints, Rectangle srcRect, GraphicsUnit srcUnit, EnumerateMetafileProc callback);
    public void EnumerateMetafile(Metafile metafile, Point[] destPoints, Rectangle srcRect, GraphicsUnit srcUnit, EnumerateMetafileProc callback, IntPtr callbackData);
    public void EnumerateMetafile(Metafile metafile, Point[] destPoints, Rectangle srcRect, GraphicsUnit unit, EnumerateMetafileProc callback, IntPtr callbackData, ImageAttributes imageAttr);
    public void SetClip(Graphics g);
    public void SetClip(Graphics g, CombineMode combineMode);
    public void SetClip(Rectangle rect);
    public void SetClip(Rectangle rect, CombineMode combineMode);
    public void SetClip(RectangleF rect);
    public void SetClip(RectangleF rect, CombineMode combineMode);
    public void SetClip(GraphicsPath path);
    public void SetClip(GraphicsPath path, CombineMode combineMode);
    public void SetClip(Region region, CombineMode combineMode);
    public void IntersectClip(Rectangle rect);
    public void IntersectClip(RectangleF rect);
    public void IntersectClip(Region region);
    public void ExcludeClip(Rectangle rect);
    public void ExcludeClip(Region region);
    public void ResetClip();
    public void TranslateClip(float dx, float dy);
    public void TranslateClip(int dx, int dy);
    [EditorBrowsableAttribute("1")]
public object GetContextInfo();
    public bool IsVisible(int x, int y);
    public bool IsVisible(Point point);
    public bool IsVisible(float x, float y);
    public bool IsVisible(PointF point);
    public bool IsVisible(int x, int y, int width, int height);
    public bool IsVisible(Rectangle rect);
    public bool IsVisible(float x, float y, float width, float height);
    public bool IsVisible(RectangleF rect);
    public GraphicsState Save();
    public void Restore(GraphicsState gstate);
    public GraphicsContainer BeginContainer(RectangleF dstrect, RectangleF srcrect, GraphicsUnit unit);
    public GraphicsContainer BeginContainer();
    public void EndContainer(GraphicsContainer container);
    public GraphicsContainer BeginContainer(Rectangle dstrect, Rectangle srcrect, GraphicsUnit unit);
    public void AddMetafileComment(Byte[] data);
    public static IntPtr GetHalftonePalette();
}
public enum System.Drawing.GraphicsUnit : Enum {
    public int value__;
    public static GraphicsUnit World;
    public static GraphicsUnit Display;
    public static GraphicsUnit Pixel;
    public static GraphicsUnit Point;
    public static GraphicsUnit Inch;
    public static GraphicsUnit Document;
    public static GraphicsUnit Millimeter;
}
[TypeConverterAttribute("System.Drawing.IconConverter")]
public class System.Drawing.Icon : MarshalByRefObject {
    public static Icon _Default;
    [BrowsableAttribute("False")]
public IntPtr Handle { get; }
    [BrowsableAttribute("False")]
public int Height { get; }
    public Size Size { get; }
    [BrowsableAttribute("False")]
public int Width { get; }
    public Icon(string fileName);
    public Icon(string fileName, Size size);
    public Icon(string fileName, int width, int height);
    public Icon(Icon original, Size size);
    public Icon(Icon original, int width, int height);
    public Icon(Type type, string resource);
    public Icon(Stream stream);
    public Icon(Stream stream, Size size);
    public Icon(Stream stream, int width, int height);
    public Icon(SerializationInfo info, StreamingContext context);
    private static Icon();
    public IntPtr get_Handle();
    public int get_Height();
    public Size get_Size();
    public int get_Width();
    public static Icon ExtractAssociatedIcon(string filePath);
    public sealed virtual object Clone();
    public sealed virtual void Dispose();
    public static Icon FromHandle(IntPtr handle);
    public void Save(Stream outputStream);
    public Bitmap ToBitmap();
    public virtual string ToString();
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo si, StreamingContext context);
}
public class System.Drawing.IconConverter : ExpandableObjectConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public interface System.Drawing.IDeviceContext {
    public abstract virtual IntPtr GetHdc();
    public abstract virtual void ReleaseHdc();
}
[ImmutableObjectAttribute("True")]
[ComVisibleAttribute("True")]
[EditorAttribute("System.Drawing.Design.ImageEditor, System.Drawing.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor")]
[TypeConverterAttribute("System.Drawing.ImageConverter")]
public abstract class System.Drawing.Image : MarshalByRefObject {
    [DefaultValueAttribute("")]
[TypeConverterAttribute("System.ComponentModel.StringConverter")]
[LocalizableAttribute("False")]
[BindableAttribute("True")]
public object Tag { get; public set; }
    public SizeF PhysicalDimension { get; }
    public Size Size { get; }
    [DesignerSerializationVisibilityAttribute("0")]
[DefaultValueAttribute("False")]
[BrowsableAttribute("False")]
public int Width { get; }
    [DesignerSerializationVisibilityAttribute("0")]
[BrowsableAttribute("False")]
[DefaultValueAttribute("False")]
public int Height { get; }
    public float HorizontalResolution { get; }
    public float VerticalResolution { get; }
    [BrowsableAttribute("False")]
public int Flags { get; }
    public ImageFormat RawFormat { get; }
    public PixelFormat PixelFormat { get; }
    [BrowsableAttribute("False")]
public ColorPalette Palette { get; public set; }
    [BrowsableAttribute("False")]
public Guid[] FrameDimensionsList { get; }
    [BrowsableAttribute("False")]
public Int32[] PropertyIdList { get; }
    [BrowsableAttribute("False")]
public PropertyItem[] PropertyItems { get; }
    public object get_Tag();
    public void set_Tag(object value);
    public SizeF get_PhysicalDimension();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public Size get_Size();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public int get_Width();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public int get_Height();
    public float get_HorizontalResolution();
    public float get_VerticalResolution();
    public int get_Flags();
    public ImageFormat get_RawFormat();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public PixelFormat get_PixelFormat();
    public ColorPalette get_Palette();
    public void set_Palette(ColorPalette value);
    public Guid[] get_FrameDimensionsList();
    public Int32[] get_PropertyIdList();
    public PropertyItem[] get_PropertyItems();
    protected virtual override void Finalize();
    public static Image FromFile(string filename);
    public static Image FromFile(string filename, bool useEmbeddedColorManagement);
    public static Image FromStream(Stream stream);
    public static Image FromStream(Stream stream, bool useEmbeddedColorManagement);
    public static Image FromStream(Stream stream, bool useEmbeddedColorManagement, bool validateImageData);
    public sealed virtual object Clone();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo si, StreamingContext context);
    public EncoderParameters GetEncoderParameterList(Guid encoder);
    public void Save(string filename);
    public void Save(string filename, ImageFormat format);
    public void Save(string filename, ImageCodecInfo encoder, EncoderParameters encoderParams);
    public void Save(Stream stream, ImageFormat format);
    public void Save(Stream stream, ImageCodecInfo encoder, EncoderParameters encoderParams);
    public void SaveAdd(EncoderParameters encoderParams);
    public void SaveAdd(Image image, EncoderParameters encoderParams);
    public RectangleF GetBounds(GraphicsUnit& pageUnit);
    public Image GetThumbnailImage(int thumbWidth, int thumbHeight, GetThumbnailImageAbort callback, IntPtr callbackData);
    public int GetFrameCount(FrameDimension dimension);
    public int SelectActiveFrame(FrameDimension dimension, int frameIndex);
    public void RotateFlip(RotateFlipType rotateFlipType);
    public PropertyItem GetPropertyItem(int propid);
    public void RemovePropertyItem(int propid);
    public void SetPropertyItem(PropertyItem propitem);
    public static Bitmap FromHbitmap(IntPtr hbitmap);
    public static Bitmap FromHbitmap(IntPtr hbitmap, IntPtr hpalette);
    public static int GetPixelFormatSize(PixelFormat pixfmt);
    public static bool IsAlphaPixelFormat(PixelFormat pixfmt);
    public static bool IsExtendedPixelFormat(PixelFormat pixfmt);
    public static bool IsCanonicalPixelFormat(PixelFormat pixfmt);
}
public class System.Drawing.ImageAnimator : object {
    public static void UpdateFrames(Image image);
    public static void UpdateFrames();
    public static void Animate(Image image, EventHandler onFrameChangedHandler);
    public static bool CanAnimate(Image image);
    public static void StopAnimate(Image image, EventHandler onFrameChangedHandler);
}
public class System.Drawing.ImageConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
    public virtual PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes);
    public virtual bool GetPropertiesSupported(ITypeDescriptorContext context);
}
public class System.Drawing.ImageFormatConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
    public virtual StandardValuesCollection GetStandardValues(ITypeDescriptorContext context);
    public virtual bool GetStandardValuesSupported(ITypeDescriptorContext context);
}
public class System.Drawing.Imaging.BitmapData : object {
    public int Width { get; public set; }
    public int Height { get; public set; }
    public int Stride { get; public set; }
    public PixelFormat PixelFormat { get; public set; }
    public IntPtr Scan0 { get; public set; }
    public int Reserved { get; public set; }
    public int get_Width();
    public void set_Width(int value);
    public int get_Height();
    public void set_Height(int value);
    public int get_Stride();
    public void set_Stride(int value);
    public PixelFormat get_PixelFormat();
    public void set_PixelFormat(PixelFormat value);
    public IntPtr get_Scan0();
    public void set_Scan0(IntPtr value);
    public int get_Reserved();
    public void set_Reserved(int value);
}
public enum System.Drawing.Imaging.ColorAdjustType : Enum {
    public int value__;
    public static ColorAdjustType Default;
    public static ColorAdjustType Bitmap;
    public static ColorAdjustType Brush;
    public static ColorAdjustType Pen;
    public static ColorAdjustType Text;
    public static ColorAdjustType Count;
    public static ColorAdjustType Any;
}
public enum System.Drawing.Imaging.ColorChannelFlag : Enum {
    public int value__;
    public static ColorChannelFlag ColorChannelC;
    public static ColorChannelFlag ColorChannelM;
    public static ColorChannelFlag ColorChannelY;
    public static ColorChannelFlag ColorChannelK;
    public static ColorChannelFlag ColorChannelLast;
}
public class System.Drawing.Imaging.ColorMap : object {
    public Color OldColor { get; public set; }
    public Color NewColor { get; public set; }
    public Color get_OldColor();
    public void set_OldColor(Color value);
    public Color get_NewColor();
    public void set_NewColor(Color value);
}
public enum System.Drawing.Imaging.ColorMapType : Enum {
    public int value__;
    public static ColorMapType Default;
    public static ColorMapType Brush;
}
[DefaultMemberAttribute("Item")]
public class System.Drawing.Imaging.ColorMatrix : object {
    public float Matrix00 { get; public set; }
    public float Matrix01 { get; public set; }
    public float Matrix02 { get; public set; }
    public float Matrix03 { get; public set; }
    public float Matrix04 { get; public set; }
    public float Matrix10 { get; public set; }
    public float Matrix11 { get; public set; }
    public float Matrix12 { get; public set; }
    public float Matrix13 { get; public set; }
    public float Matrix14 { get; public set; }
    public float Matrix20 { get; public set; }
    public float Matrix21 { get; public set; }
    public float Matrix22 { get; public set; }
    public float Matrix23 { get; public set; }
    public float Matrix24 { get; public set; }
    public float Matrix30 { get; public set; }
    public float Matrix31 { get; public set; }
    public float Matrix32 { get; public set; }
    public float Matrix33 { get; public set; }
    public float Matrix34 { get; public set; }
    public float Matrix40 { get; public set; }
    public float Matrix41 { get; public set; }
    public float Matrix42 { get; public set; }
    public float Matrix43 { get; public set; }
    public float Matrix44 { get; public set; }
    public float Item { get; public set; }
    [CLSCompliantAttribute("False")]
public ColorMatrix(Single[][] newColorMatrix);
    public float get_Matrix00();
    public void set_Matrix00(float value);
    public float get_Matrix01();
    public void set_Matrix01(float value);
    public float get_Matrix02();
    public void set_Matrix02(float value);
    public float get_Matrix03();
    public void set_Matrix03(float value);
    public float get_Matrix04();
    public void set_Matrix04(float value);
    public float get_Matrix10();
    public void set_Matrix10(float value);
    public float get_Matrix11();
    public void set_Matrix11(float value);
    public float get_Matrix12();
    public void set_Matrix12(float value);
    public float get_Matrix13();
    public void set_Matrix13(float value);
    public float get_Matrix14();
    public void set_Matrix14(float value);
    public float get_Matrix20();
    public void set_Matrix20(float value);
    public float get_Matrix21();
    public void set_Matrix21(float value);
    public float get_Matrix22();
    public void set_Matrix22(float value);
    public float get_Matrix23();
    public void set_Matrix23(float value);
    public float get_Matrix24();
    public void set_Matrix24(float value);
    public float get_Matrix30();
    public void set_Matrix30(float value);
    public float get_Matrix31();
    public void set_Matrix31(float value);
    public float get_Matrix32();
    public void set_Matrix32(float value);
    public float get_Matrix33();
    public void set_Matrix33(float value);
    public float get_Matrix34();
    public void set_Matrix34(float value);
    public float get_Matrix40();
    public void set_Matrix40(float value);
    public float get_Matrix41();
    public void set_Matrix41(float value);
    public float get_Matrix42();
    public void set_Matrix42(float value);
    public float get_Matrix43();
    public void set_Matrix43(float value);
    public float get_Matrix44();
    public void set_Matrix44(float value);
    public float get_Item(int row, int column);
    public void set_Item(int row, int column, float value);
}
public enum System.Drawing.Imaging.ColorMatrixFlag : Enum {
    public int value__;
    public static ColorMatrixFlag Default;
    public static ColorMatrixFlag SkipGrays;
    public static ColorMatrixFlag AltGrays;
}
public enum System.Drawing.Imaging.ColorMode : Enum {
    public int value__;
    public static ColorMode Argb32Mode;
    public static ColorMode Argb64Mode;
}
public class System.Drawing.Imaging.ColorPalette : object {
    public int Flags { get; }
    public Color[] Entries { get; }
    public int get_Flags();
    public Color[] get_Entries();
}
public enum System.Drawing.Imaging.EmfPlusRecordType : Enum {
    public int value__;
    public static EmfPlusRecordType EmfHeader;
    public static EmfPlusRecordType EmfMin;
    public static EmfPlusRecordType EmfPolyBezier;
    public static EmfPlusRecordType EmfPolygon;
    public static EmfPlusRecordType EmfPolyline;
    public static EmfPlusRecordType EmfPolyBezierTo;
    public static EmfPlusRecordType EmfPolyLineTo;
    public static EmfPlusRecordType EmfPolyPolyline;
    public static EmfPlusRecordType EmfPolyPolygon;
    public static EmfPlusRecordType EmfSetWindowExtEx;
    public static EmfPlusRecordType EmfSetWindowOrgEx;
    public static EmfPlusRecordType EmfSetViewportExtEx;
    public static EmfPlusRecordType EmfSetViewportOrgEx;
    public static EmfPlusRecordType EmfSetBrushOrgEx;
    public static EmfPlusRecordType EmfEof;
    public static EmfPlusRecordType EmfSetPixelV;
    public static EmfPlusRecordType EmfSetMapperFlags;
    public static EmfPlusRecordType EmfSetMapMode;
    public static EmfPlusRecordType EmfSetBkMode;
    public static EmfPlusRecordType EmfSetPolyFillMode;
    public static EmfPlusRecordType EmfSetROP2;
    public static EmfPlusRecordType EmfSetStretchBltMode;
    public static EmfPlusRecordType EmfSetTextAlign;
    public static EmfPlusRecordType EmfSetColorAdjustment;
    public static EmfPlusRecordType EmfSetTextColor;
    public static EmfPlusRecordType EmfSetBkColor;
    public static EmfPlusRecordType EmfOffsetClipRgn;
    public static EmfPlusRecordType EmfMoveToEx;
    public static EmfPlusRecordType EmfSetMetaRgn;
    public static EmfPlusRecordType EmfExcludeClipRect;
    public static EmfPlusRecordType EmfIntersectClipRect;
    public static EmfPlusRecordType EmfScaleViewportExtEx;
    public static EmfPlusRecordType EmfScaleWindowExtEx;
    public static EmfPlusRecordType EmfSaveDC;
    public static EmfPlusRecordType EmfRestoreDC;
    public static EmfPlusRecordType EmfSetWorldTransform;
    public static EmfPlusRecordType EmfModifyWorldTransform;
    public static EmfPlusRecordType EmfSelectObject;
    public static EmfPlusRecordType EmfCreatePen;
    public static EmfPlusRecordType EmfCreateBrushIndirect;
    public static EmfPlusRecordType EmfDeleteObject;
    public static EmfPlusRecordType EmfAngleArc;
    public static EmfPlusRecordType EmfEllipse;
    public static EmfPlusRecordType EmfRectangle;
    public static EmfPlusRecordType EmfRoundRect;
    public static EmfPlusRecordType EmfRoundArc;
    public static EmfPlusRecordType EmfChord;
    public static EmfPlusRecordType EmfPie;
    public static EmfPlusRecordType EmfSelectPalette;
    public static EmfPlusRecordType EmfCreatePalette;
    public static EmfPlusRecordType EmfSetPaletteEntries;
    public static EmfPlusRecordType EmfResizePalette;
    public static EmfPlusRecordType EmfRealizePalette;
    public static EmfPlusRecordType EmfExtFloodFill;
    public static EmfPlusRecordType EmfLineTo;
    public static EmfPlusRecordType EmfArcTo;
    public static EmfPlusRecordType EmfPolyDraw;
    public static EmfPlusRecordType EmfSetArcDirection;
    public static EmfPlusRecordType EmfSetMiterLimit;
    public static EmfPlusRecordType EmfBeginPath;
    public static EmfPlusRecordType EmfEndPath;
    public static EmfPlusRecordType EmfCloseFigure;
    public static EmfPlusRecordType EmfFillPath;
    public static EmfPlusRecordType EmfStrokeAndFillPath;
    public static EmfPlusRecordType EmfStrokePath;
    public static EmfPlusRecordType EmfFlattenPath;
    public static EmfPlusRecordType EmfWidenPath;
    public static EmfPlusRecordType EmfSelectClipPath;
    public static EmfPlusRecordType EmfAbortPath;
    public static EmfPlusRecordType EmfReserved069;
    public static EmfPlusRecordType EmfGdiComment;
    public static EmfPlusRecordType EmfFillRgn;
    public static EmfPlusRecordType EmfFrameRgn;
    public static EmfPlusRecordType EmfInvertRgn;
    public static EmfPlusRecordType EmfPaintRgn;
    public static EmfPlusRecordType EmfExtSelectClipRgn;
    public static EmfPlusRecordType EmfBitBlt;
    public static EmfPlusRecordType EmfStretchBlt;
    public static EmfPlusRecordType EmfMaskBlt;
    public static EmfPlusRecordType EmfPlgBlt;
    public static EmfPlusRecordType EmfSetDIBitsToDevice;
    public static EmfPlusRecordType EmfStretchDIBits;
    public static EmfPlusRecordType EmfExtCreateFontIndirect;
    public static EmfPlusRecordType EmfExtTextOutA;
    public static EmfPlusRecordType EmfExtTextOutW;
    public static EmfPlusRecordType EmfPolyBezier16;
    public static EmfPlusRecordType EmfPolygon16;
    public static EmfPlusRecordType EmfPolyline16;
    public static EmfPlusRecordType EmfPolyBezierTo16;
    public static EmfPlusRecordType EmfPolylineTo16;
    public static EmfPlusRecordType EmfPolyPolyline16;
    public static EmfPlusRecordType EmfPolyPolygon16;
    public static EmfPlusRecordType EmfPolyDraw16;
    public static EmfPlusRecordType EmfCreateMonoBrush;
    public static EmfPlusRecordType EmfCreateDibPatternBrushPt;
    public static EmfPlusRecordType EmfExtCreatePen;
    public static EmfPlusRecordType EmfPolyTextOutA;
    public static EmfPlusRecordType EmfPolyTextOutW;
    public static EmfPlusRecordType EmfSetIcmMode;
    public static EmfPlusRecordType EmfCreateColorSpace;
    public static EmfPlusRecordType EmfSetColorSpace;
    public static EmfPlusRecordType EmfDeleteColorSpace;
    public static EmfPlusRecordType EmfGlsRecord;
    public static EmfPlusRecordType EmfGlsBoundedRecord;
    public static EmfPlusRecordType EmfPixelFormat;
    public static EmfPlusRecordType EmfDrawEscape;
    public static EmfPlusRecordType EmfExtEscape;
    public static EmfPlusRecordType EmfStartDoc;
    public static EmfPlusRecordType EmfSmallTextOut;
    public static EmfPlusRecordType EmfForceUfiMapping;
    public static EmfPlusRecordType EmfNamedEscpae;
    public static EmfPlusRecordType EmfColorCorrectPalette;
    public static EmfPlusRecordType EmfSetIcmProfileA;
    public static EmfPlusRecordType EmfSetIcmProfileW;
    public static EmfPlusRecordType EmfAlphaBlend;
    public static EmfPlusRecordType EmfSetLayout;
    public static EmfPlusRecordType EmfTransparentBlt;
    public static EmfPlusRecordType EmfReserved117;
    public static EmfPlusRecordType EmfGradientFill;
    public static EmfPlusRecordType EmfSetLinkedUfis;
    public static EmfPlusRecordType EmfSetTextJustification;
    public static EmfPlusRecordType EmfColorMatchToTargetW;
    public static EmfPlusRecordType EmfCreateColorSpaceW;
    public static EmfPlusRecordType EmfMax;
    public static EmfPlusRecordType EmfPlusRecordBase;
    public static EmfPlusRecordType Invalid;
    public static EmfPlusRecordType Header;
    public static EmfPlusRecordType Min;
    public static EmfPlusRecordType EndOfFile;
    public static EmfPlusRecordType Comment;
    public static EmfPlusRecordType GetDC;
    public static EmfPlusRecordType MultiFormatStart;
    public static EmfPlusRecordType MultiFormatSection;
    public static EmfPlusRecordType MultiFormatEnd;
    public static EmfPlusRecordType Object;
    public static EmfPlusRecordType Clear;
    public static EmfPlusRecordType FillRects;
    public static EmfPlusRecordType DrawRects;
    public static EmfPlusRecordType FillPolygon;
    public static EmfPlusRecordType DrawLines;
    public static EmfPlusRecordType FillEllipse;
    public static EmfPlusRecordType DrawEllipse;
    public static EmfPlusRecordType FillPie;
    public static EmfPlusRecordType DrawPie;
    public static EmfPlusRecordType DrawArc;
    public static EmfPlusRecordType FillRegion;
    public static EmfPlusRecordType FillPath;
    public static EmfPlusRecordType DrawPath;
    public static EmfPlusRecordType FillClosedCurve;
    public static EmfPlusRecordType DrawClosedCurve;
    public static EmfPlusRecordType DrawCurve;
    public static EmfPlusRecordType DrawBeziers;
    public static EmfPlusRecordType DrawImage;
    public static EmfPlusRecordType DrawImagePoints;
    public static EmfPlusRecordType DrawString;
    public static EmfPlusRecordType SetRenderingOrigin;
    public static EmfPlusRecordType SetAntiAliasMode;
    public static EmfPlusRecordType SetTextRenderingHint;
    public static EmfPlusRecordType SetTextContrast;
    public static EmfPlusRecordType SetInterpolationMode;
    public static EmfPlusRecordType SetPixelOffsetMode;
    public static EmfPlusRecordType SetCompositingMode;
    public static EmfPlusRecordType SetCompositingQuality;
    public static EmfPlusRecordType Save;
    public static EmfPlusRecordType Restore;
    public static EmfPlusRecordType BeginContainer;
    public static EmfPlusRecordType BeginContainerNoParams;
    public static EmfPlusRecordType EndContainer;
    public static EmfPlusRecordType SetWorldTransform;
    public static EmfPlusRecordType ResetWorldTransform;
    public static EmfPlusRecordType MultiplyWorldTransform;
    public static EmfPlusRecordType TranslateWorldTransform;
    public static EmfPlusRecordType ScaleWorldTransform;
    public static EmfPlusRecordType RotateWorldTransform;
    public static EmfPlusRecordType SetPageTransform;
    public static EmfPlusRecordType ResetClip;
    public static EmfPlusRecordType SetClipRect;
    public static EmfPlusRecordType SetClipPath;
    public static EmfPlusRecordType SetClipRegion;
    public static EmfPlusRecordType OffsetClip;
    public static EmfPlusRecordType DrawDriverString;
    public static EmfPlusRecordType Max;
    public static EmfPlusRecordType Total;
    public static EmfPlusRecordType WmfRecordBase;
    public static EmfPlusRecordType WmfSaveDC;
    public static EmfPlusRecordType WmfRealizePalette;
    public static EmfPlusRecordType WmfSetPalEntries;
    public static EmfPlusRecordType WmfCreatePalette;
    public static EmfPlusRecordType WmfSetBkMode;
    public static EmfPlusRecordType WmfSetMapMode;
    public static EmfPlusRecordType WmfSetROP2;
    public static EmfPlusRecordType WmfSetRelAbs;
    public static EmfPlusRecordType WmfSetPolyFillMode;
    public static EmfPlusRecordType WmfSetStretchBltMode;
    public static EmfPlusRecordType WmfSetTextCharExtra;
    public static EmfPlusRecordType WmfRestoreDC;
    public static EmfPlusRecordType WmfInvertRegion;
    public static EmfPlusRecordType WmfPaintRegion;
    public static EmfPlusRecordType WmfSelectClipRegion;
    public static EmfPlusRecordType WmfSelectObject;
    public static EmfPlusRecordType WmfSetTextAlign;
    public static EmfPlusRecordType WmfResizePalette;
    public static EmfPlusRecordType WmfDibCreatePatternBrush;
    public static EmfPlusRecordType WmfSetLayout;
    public static EmfPlusRecordType WmfDeleteObject;
    public static EmfPlusRecordType WmfCreatePatternBrush;
    public static EmfPlusRecordType WmfSetBkColor;
    public static EmfPlusRecordType WmfSetTextColor;
    public static EmfPlusRecordType WmfSetTextJustification;
    public static EmfPlusRecordType WmfSetWindowOrg;
    public static EmfPlusRecordType WmfSetWindowExt;
    public static EmfPlusRecordType WmfSetViewportOrg;
    public static EmfPlusRecordType WmfSetViewportExt;
    public static EmfPlusRecordType WmfOffsetWindowOrg;
    public static EmfPlusRecordType WmfOffsetViewportOrg;
    public static EmfPlusRecordType WmfLineTo;
    public static EmfPlusRecordType WmfMoveTo;
    public static EmfPlusRecordType WmfOffsetCilpRgn;
    public static EmfPlusRecordType WmfFillRegion;
    public static EmfPlusRecordType WmfSetMapperFlags;
    public static EmfPlusRecordType WmfSelectPalette;
    public static EmfPlusRecordType WmfCreatePenIndirect;
    public static EmfPlusRecordType WmfCreateFontIndirect;
    public static EmfPlusRecordType WmfCreateBrushIndirect;
    public static EmfPlusRecordType WmfPolygon;
    public static EmfPlusRecordType WmfPolyline;
    public static EmfPlusRecordType WmfScaleWindowExt;
    public static EmfPlusRecordType WmfScaleViewportExt;
    public static EmfPlusRecordType WmfExcludeClipRect;
    public static EmfPlusRecordType WmfIntersectClipRect;
    public static EmfPlusRecordType WmfEllipse;
    public static EmfPlusRecordType WmfFloodFill;
    public static EmfPlusRecordType WmfRectangle;
    public static EmfPlusRecordType WmfSetPixel;
    public static EmfPlusRecordType WmfFrameRegion;
    public static EmfPlusRecordType WmfAnimatePalette;
    public static EmfPlusRecordType WmfTextOut;
    public static EmfPlusRecordType WmfPolyPolygon;
    public static EmfPlusRecordType WmfExtFloodFill;
    public static EmfPlusRecordType WmfRoundRect;
    public static EmfPlusRecordType WmfPatBlt;
    public static EmfPlusRecordType WmfEscape;
    public static EmfPlusRecordType WmfCreateRegion;
    public static EmfPlusRecordType WmfArc;
    public static EmfPlusRecordType WmfPie;
    public static EmfPlusRecordType WmfChord;
    public static EmfPlusRecordType WmfBitBlt;
    public static EmfPlusRecordType WmfDibBitBlt;
    public static EmfPlusRecordType WmfExtTextOut;
    public static EmfPlusRecordType WmfStretchBlt;
    public static EmfPlusRecordType WmfDibStretchBlt;
    public static EmfPlusRecordType WmfSetDibToDev;
    public static EmfPlusRecordType WmfStretchDib;
}
public enum System.Drawing.Imaging.EmfType : Enum {
    public int value__;
    public static EmfType EmfOnly;
    public static EmfType EmfPlusOnly;
    public static EmfType EmfPlusDual;
}
public class System.Drawing.Imaging.Encoder : object {
    public static Encoder Compression;
    public static Encoder ColorDepth;
    public static Encoder ScanMethod;
    public static Encoder Version;
    public static Encoder RenderMethod;
    public static Encoder Quality;
    public static Encoder Transformation;
    public static Encoder LuminanceTable;
    public static Encoder ChrominanceTable;
    public static Encoder SaveFlag;
    public Guid Guid { get; }
    public Encoder(Guid guid);
    public Guid get_Guid();
}
public class System.Drawing.Imaging.EncoderParameter : object {
    public Encoder Encoder { get; public set; }
    public EncoderParameterValueType Type { get; }
    public EncoderParameterValueType ValueType { get; }
    public int NumberOfValues { get; }
    public EncoderParameter(Encoder encoder, byte value);
    public EncoderParameter(Encoder encoder, byte value, bool undefined);
    public EncoderParameter(Encoder encoder, short value);
    public EncoderParameter(Encoder encoder, long value);
    public EncoderParameter(Encoder encoder, int numerator, int denominator);
    public EncoderParameter(Encoder encoder, long rangebegin, long rangeend);
    public EncoderParameter(Encoder encoder, int numerator1, int demoninator1, int numerator2, int demoninator2);
    public EncoderParameter(Encoder encoder, string value);
    public EncoderParameter(Encoder encoder, Byte[] value);
    public EncoderParameter(Encoder encoder, Byte[] value, bool undefined);
    public EncoderParameter(Encoder encoder, Int16[] value);
    public EncoderParameter(Encoder encoder, Int64[] value);
    public EncoderParameter(Encoder encoder, Int32[] numerator, Int32[] denominator);
    public EncoderParameter(Encoder encoder, Int64[] rangebegin, Int64[] rangeend);
    public EncoderParameter(Encoder encoder, Int32[] numerator1, Int32[] denominator1, Int32[] numerator2, Int32[] denominator2);
    [ObsoleteAttribute("This constructor has been deprecated. Use EncoderParameter(Encoder encoder, int numberValues, EncoderParameterValueType type, IntPtr value) instead.  http://go.microsoft.com/fwlink/?linkid=14202")]
public EncoderParameter(Encoder encoder, int NumberOfValues, int Type, int Value);
    public EncoderParameter(Encoder encoder, int numberValues, EncoderParameterValueType type, IntPtr value);
    public Encoder get_Encoder();
    public void set_Encoder(Encoder value);
    public EncoderParameterValueType get_Type();
    public EncoderParameterValueType get_ValueType();
    public int get_NumberOfValues();
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
}
public class System.Drawing.Imaging.EncoderParameters : object {
    public EncoderParameter[] Param { get; public set; }
    public EncoderParameters(int count);
    public EncoderParameter[] get_Param();
    public void set_Param(EncoderParameter[] value);
    public sealed virtual void Dispose();
}
public enum System.Drawing.Imaging.EncoderParameterValueType : Enum {
    public int value__;
    public static EncoderParameterValueType ValueTypeByte;
    public static EncoderParameterValueType ValueTypeAscii;
    public static EncoderParameterValueType ValueTypeShort;
    public static EncoderParameterValueType ValueTypeLong;
    public static EncoderParameterValueType ValueTypeRational;
    public static EncoderParameterValueType ValueTypeLongRange;
    public static EncoderParameterValueType ValueTypeUndefined;
    public static EncoderParameterValueType ValueTypeRationalRange;
}
public enum System.Drawing.Imaging.EncoderValue : Enum {
    public int value__;
    public static EncoderValue ColorTypeCMYK;
    public static EncoderValue ColorTypeYCCK;
    public static EncoderValue CompressionLZW;
    public static EncoderValue CompressionCCITT3;
    public static EncoderValue CompressionCCITT4;
    public static EncoderValue CompressionRle;
    public static EncoderValue CompressionNone;
    public static EncoderValue ScanMethodInterlaced;
    public static EncoderValue ScanMethodNonInterlaced;
    public static EncoderValue VersionGif87;
    public static EncoderValue VersionGif89;
    public static EncoderValue RenderProgressive;
    public static EncoderValue RenderNonProgressive;
    public static EncoderValue TransformRotate90;
    public static EncoderValue TransformRotate180;
    public static EncoderValue TransformRotate270;
    public static EncoderValue TransformFlipHorizontal;
    public static EncoderValue TransformFlipVertical;
    public static EncoderValue MultiFrame;
    public static EncoderValue LastFrame;
    public static EncoderValue Flush;
    public static EncoderValue FrameDimensionTime;
    public static EncoderValue FrameDimensionResolution;
    public static EncoderValue FrameDimensionPage;
}
public class System.Drawing.Imaging.FrameDimension : object {
    public Guid Guid { get; }
    public static FrameDimension Time { get; }
    public static FrameDimension Resolution { get; }
    public static FrameDimension Page { get; }
    public FrameDimension(Guid guid);
    public Guid get_Guid();
    public static FrameDimension get_Time();
    public static FrameDimension get_Resolution();
    public static FrameDimension get_Page();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class System.Drawing.Imaging.ImageAttributes : object {
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    public sealed virtual object Clone();
    public void SetColorMatrix(ColorMatrix newColorMatrix);
    public void SetColorMatrix(ColorMatrix newColorMatrix, ColorMatrixFlag flags);
    public void SetColorMatrix(ColorMatrix newColorMatrix, ColorMatrixFlag mode, ColorAdjustType type);
    public void ClearColorMatrix();
    public void ClearColorMatrix(ColorAdjustType type);
    public void SetColorMatrices(ColorMatrix newColorMatrix, ColorMatrix grayMatrix);
    public void SetColorMatrices(ColorMatrix newColorMatrix, ColorMatrix grayMatrix, ColorMatrixFlag flags);
    public void SetColorMatrices(ColorMatrix newColorMatrix, ColorMatrix grayMatrix, ColorMatrixFlag mode, ColorAdjustType type);
    public void SetThreshold(float threshold);
    public void SetThreshold(float threshold, ColorAdjustType type);
    public void ClearThreshold();
    public void ClearThreshold(ColorAdjustType type);
    public void SetGamma(float gamma);
    public void SetGamma(float gamma, ColorAdjustType type);
    public void ClearGamma();
    public void ClearGamma(ColorAdjustType type);
    public void SetNoOp();
    public void SetNoOp(ColorAdjustType type);
    public void ClearNoOp();
    public void ClearNoOp(ColorAdjustType type);
    public void SetColorKey(Color colorLow, Color colorHigh);
    public void SetColorKey(Color colorLow, Color colorHigh, ColorAdjustType type);
    public void ClearColorKey();
    public void ClearColorKey(ColorAdjustType type);
    public void SetOutputChannel(ColorChannelFlag flags);
    public void SetOutputChannel(ColorChannelFlag flags, ColorAdjustType type);
    public void ClearOutputChannel();
    public void ClearOutputChannel(ColorAdjustType type);
    public void SetOutputChannelColorProfile(string colorProfileFilename);
    public void SetOutputChannelColorProfile(string colorProfileFilename, ColorAdjustType type);
    public void ClearOutputChannelColorProfile();
    public void ClearOutputChannelColorProfile(ColorAdjustType type);
    public void SetRemapTable(ColorMap[] map);
    public void SetRemapTable(ColorMap[] map, ColorAdjustType type);
    public void ClearRemapTable();
    public void ClearRemapTable(ColorAdjustType type);
    public void SetBrushRemapTable(ColorMap[] map);
    public void ClearBrushRemapTable();
    public void SetWrapMode(WrapMode mode);
    public void SetWrapMode(WrapMode mode, Color color);
    public void SetWrapMode(WrapMode mode, Color color, bool clamp);
    public void GetAdjustedPalette(ColorPalette palette, ColorAdjustType type);
}
[FlagsAttribute]
public enum System.Drawing.Imaging.ImageCodecFlags : Enum {
    public int value__;
    public static ImageCodecFlags Encoder;
    public static ImageCodecFlags Decoder;
    public static ImageCodecFlags SupportBitmap;
    public static ImageCodecFlags SupportVector;
    public static ImageCodecFlags SeekableEncode;
    public static ImageCodecFlags BlockingDecode;
    public static ImageCodecFlags Builtin;
    public static ImageCodecFlags System;
    public static ImageCodecFlags User;
}
public class System.Drawing.Imaging.ImageCodecInfo : object {
    public Guid Clsid { get; public set; }
    public Guid FormatID { get; public set; }
    public string CodecName { get; public set; }
    public string DllName { get; public set; }
    public string FormatDescription { get; public set; }
    public string FilenameExtension { get; public set; }
    public string MimeType { get; public set; }
    public ImageCodecFlags Flags { get; public set; }
    public int Version { get; public set; }
    [CLSCompliantAttribute("False")]
public Byte[][] SignaturePatterns { get; public set; }
    [CLSCompliantAttribute("False")]
public Byte[][] SignatureMasks { get; public set; }
    public Guid get_Clsid();
    public void set_Clsid(Guid value);
    public Guid get_FormatID();
    public void set_FormatID(Guid value);
    public string get_CodecName();
    public void set_CodecName(string value);
    public string get_DllName();
    public void set_DllName(string value);
    public string get_FormatDescription();
    public void set_FormatDescription(string value);
    public string get_FilenameExtension();
    public void set_FilenameExtension(string value);
    public string get_MimeType();
    public void set_MimeType(string value);
    public ImageCodecFlags get_Flags();
    public void set_Flags(ImageCodecFlags value);
    public int get_Version();
    public void set_Version(int value);
    public Byte[][] get_SignaturePatterns();
    public void set_SignaturePatterns(Byte[][] value);
    public Byte[][] get_SignatureMasks();
    public void set_SignatureMasks(Byte[][] value);
    public static ImageCodecInfo[] GetImageDecoders();
    public static ImageCodecInfo[] GetImageEncoders();
}
[FlagsAttribute]
public enum System.Drawing.Imaging.ImageFlags : Enum {
    public int value__;
    public static ImageFlags None;
    public static ImageFlags Scalable;
    public static ImageFlags HasAlpha;
    public static ImageFlags HasTranslucent;
    public static ImageFlags PartiallyScalable;
    public static ImageFlags ColorSpaceRgb;
    public static ImageFlags ColorSpaceCmyk;
    public static ImageFlags ColorSpaceGray;
    public static ImageFlags ColorSpaceYcbcr;
    public static ImageFlags ColorSpaceYcck;
    public static ImageFlags HasRealDpi;
    public static ImageFlags HasRealPixelSize;
    public static ImageFlags ReadOnly;
    public static ImageFlags Caching;
}
[TypeConverterAttribute("System.Drawing.ImageFormatConverter")]
public class System.Drawing.Imaging.ImageFormat : object {
    public Guid Guid { get; }
    public static ImageFormat MemoryBmp { get; }
    public static ImageFormat Bmp { get; }
    public static ImageFormat Emf { get; }
    public static ImageFormat Wmf { get; }
    public static ImageFormat Gif { get; }
    public static ImageFormat Jpeg { get; }
    public static ImageFormat Png { get; }
    public static ImageFormat Tiff { get; }
    public static ImageFormat Exif { get; }
    public static ImageFormat Icon { get; }
    public ImageFormat(Guid guid);
    public Guid get_Guid();
    public static ImageFormat get_MemoryBmp();
    public static ImageFormat get_Bmp();
    public static ImageFormat get_Emf();
    public static ImageFormat get_Wmf();
    public static ImageFormat get_Gif();
    public static ImageFormat get_Jpeg();
    public static ImageFormat get_Png();
    public static ImageFormat get_Tiff();
    public static ImageFormat get_Exif();
    public static ImageFormat get_Icon();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public enum System.Drawing.Imaging.ImageLockMode : Enum {
    public int value__;
    public static ImageLockMode ReadOnly;
    public static ImageLockMode WriteOnly;
    public static ImageLockMode ReadWrite;
    public static ImageLockMode UserInputBuffer;
}
[EditorAttribute("System.Drawing.Design.MetafileEditor, System.Drawing.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor")]
public class System.Drawing.Imaging.Metafile : Image {
    public Metafile(IntPtr hmetafile, WmfPlaceableFileHeader wmfHeader);
    public Metafile(IntPtr hmetafile, WmfPlaceableFileHeader wmfHeader, bool deleteWmf);
    public Metafile(IntPtr henhmetafile, bool deleteEmf);
    public Metafile(string filename);
    public Metafile(Stream stream);
    public Metafile(IntPtr referenceHdc, EmfType emfType);
    public Metafile(IntPtr referenceHdc, EmfType emfType, string description);
    public Metafile(IntPtr referenceHdc, RectangleF frameRect);
    public Metafile(IntPtr referenceHdc, RectangleF frameRect, MetafileFrameUnit frameUnit);
    public Metafile(IntPtr referenceHdc, RectangleF frameRect, MetafileFrameUnit frameUnit, EmfType type);
    public Metafile(IntPtr referenceHdc, RectangleF frameRect, MetafileFrameUnit frameUnit, EmfType type, string description);
    public Metafile(IntPtr referenceHdc, Rectangle frameRect);
    public Metafile(IntPtr referenceHdc, Rectangle frameRect, MetafileFrameUnit frameUnit);
    public Metafile(IntPtr referenceHdc, Rectangle frameRect, MetafileFrameUnit frameUnit, EmfType type);
    public Metafile(IntPtr referenceHdc, Rectangle frameRect, MetafileFrameUnit frameUnit, EmfType type, string desc);
    public Metafile(string fileName, IntPtr referenceHdc);
    public Metafile(string fileName, IntPtr referenceHdc, EmfType type);
    public Metafile(string fileName, IntPtr referenceHdc, EmfType type, string description);
    public Metafile(string fileName, IntPtr referenceHdc, RectangleF frameRect);
    public Metafile(string fileName, IntPtr referenceHdc, RectangleF frameRect, MetafileFrameUnit frameUnit);
    public Metafile(string fileName, IntPtr referenceHdc, RectangleF frameRect, MetafileFrameUnit frameUnit, EmfType type);
    public Metafile(string fileName, IntPtr referenceHdc, RectangleF frameRect, MetafileFrameUnit frameUnit, string desc);
    public Metafile(string fileName, IntPtr referenceHdc, RectangleF frameRect, MetafileFrameUnit frameUnit, EmfType type, string description);
    public Metafile(string fileName, IntPtr referenceHdc, Rectangle frameRect);
    public Metafile(string fileName, IntPtr referenceHdc, Rectangle frameRect, MetafileFrameUnit frameUnit);
    public Metafile(string fileName, IntPtr referenceHdc, Rectangle frameRect, MetafileFrameUnit frameUnit, EmfType type);
    public Metafile(string fileName, IntPtr referenceHdc, Rectangle frameRect, MetafileFrameUnit frameUnit, string description);
    public Metafile(string fileName, IntPtr referenceHdc, Rectangle frameRect, MetafileFrameUnit frameUnit, EmfType type, string description);
    public Metafile(Stream stream, IntPtr referenceHdc);
    public Metafile(Stream stream, IntPtr referenceHdc, EmfType type);
    public Metafile(Stream stream, IntPtr referenceHdc, EmfType type, string description);
    public Metafile(Stream stream, IntPtr referenceHdc, RectangleF frameRect);
    public Metafile(Stream stream, IntPtr referenceHdc, RectangleF frameRect, MetafileFrameUnit frameUnit);
    public Metafile(Stream stream, IntPtr referenceHdc, RectangleF frameRect, MetafileFrameUnit frameUnit, EmfType type);
    public Metafile(Stream stream, IntPtr referenceHdc, RectangleF frameRect, MetafileFrameUnit frameUnit, EmfType type, string description);
    public Metafile(Stream stream, IntPtr referenceHdc, Rectangle frameRect);
    public Metafile(Stream stream, IntPtr referenceHdc, Rectangle frameRect, MetafileFrameUnit frameUnit);
    public Metafile(Stream stream, IntPtr referenceHdc, Rectangle frameRect, MetafileFrameUnit frameUnit, EmfType type);
    public Metafile(Stream stream, IntPtr referenceHdc, Rectangle frameRect, MetafileFrameUnit frameUnit, EmfType type, string description);
    public static MetafileHeader GetMetafileHeader(IntPtr hmetafile, WmfPlaceableFileHeader wmfHeader);
    public static MetafileHeader GetMetafileHeader(IntPtr henhmetafile);
    public static MetafileHeader GetMetafileHeader(string fileName);
    public static MetafileHeader GetMetafileHeader(Stream stream);
    public MetafileHeader GetMetafileHeader();
    public IntPtr GetHenhmetafile();
    public void PlayRecord(EmfPlusRecordType recordType, int flags, int dataSize, Byte[] data);
}
public enum System.Drawing.Imaging.MetafileFrameUnit : Enum {
    public int value__;
    public static MetafileFrameUnit Pixel;
    public static MetafileFrameUnit Point;
    public static MetafileFrameUnit Inch;
    public static MetafileFrameUnit Document;
    public static MetafileFrameUnit Millimeter;
    public static MetafileFrameUnit GdiCompatible;
}
public class System.Drawing.Imaging.MetafileHeader : object {
    public MetafileType Type { get; }
    public int MetafileSize { get; }
    public int Version { get; }
    public float DpiX { get; }
    public float DpiY { get; }
    public Rectangle Bounds { get; }
    public MetaHeader WmfHeader { get; }
    public int EmfPlusHeaderSize { get; }
    public int LogicalDpiX { get; }
    public int LogicalDpiY { get; }
    public MetafileType get_Type();
    public int get_MetafileSize();
    public int get_Version();
    public float get_DpiX();
    public float get_DpiY();
    public Rectangle get_Bounds();
    public MetaHeader get_WmfHeader();
    public int get_EmfPlusHeaderSize();
    public int get_LogicalDpiX();
    public int get_LogicalDpiY();
    public bool IsWmf();
    public bool IsWmfPlaceable();
    public bool IsEmf();
    public bool IsEmfOrEmfPlus();
    public bool IsEmfPlus();
    public bool IsEmfPlusDual();
    public bool IsEmfPlusOnly();
    public bool IsDisplay();
}
public enum System.Drawing.Imaging.MetafileType : Enum {
    public int value__;
    public static MetafileType Invalid;
    public static MetafileType Wmf;
    public static MetafileType WmfPlaceable;
    public static MetafileType Emf;
    public static MetafileType EmfPlusOnly;
    public static MetafileType EmfPlusDual;
}
public class System.Drawing.Imaging.MetaHeader : object {
    public short Type { get; public set; }
    public short HeaderSize { get; public set; }
    public short Version { get; public set; }
    public int Size { get; public set; }
    public short NoObjects { get; public set; }
    public int MaxRecord { get; public set; }
    public short NoParameters { get; public set; }
    public short get_Type();
    public void set_Type(short value);
    public short get_HeaderSize();
    public void set_HeaderSize(short value);
    public short get_Version();
    public void set_Version(short value);
    public int get_Size();
    public void set_Size(int value);
    public short get_NoObjects();
    public void set_NoObjects(short value);
    public int get_MaxRecord();
    public void set_MaxRecord(int value);
    public short get_NoParameters();
    public void set_NoParameters(short value);
}
[FlagsAttribute]
public enum System.Drawing.Imaging.PaletteFlags : Enum {
    public int value__;
    public static PaletteFlags HasAlpha;
    public static PaletteFlags GrayScale;
    public static PaletteFlags Halftone;
}
public enum System.Drawing.Imaging.PixelFormat : Enum {
    public int value__;
    public static PixelFormat DontCare;
    public static PixelFormat Undefined;
    public static PixelFormat Max;
    public static PixelFormat Indexed;
    public static PixelFormat Gdi;
    public static PixelFormat Format16bppRgb555;
    public static PixelFormat Format16bppRgb565;
    public static PixelFormat Format24bppRgb;
    public static PixelFormat Format32bppRgb;
    public static PixelFormat Format1bppIndexed;
    public static PixelFormat Format4bppIndexed;
    public static PixelFormat Format8bppIndexed;
    public static PixelFormat Alpha;
    public static PixelFormat Format16bppArgb1555;
    public static PixelFormat PAlpha;
    public static PixelFormat Format32bppPArgb;
    public static PixelFormat Extended;
    public static PixelFormat Format16bppGrayScale;
    public static PixelFormat Format48bppRgb;
    public static PixelFormat Format64bppPArgb;
    public static PixelFormat Canonical;
    public static PixelFormat Format32bppArgb;
    public static PixelFormat Format64bppArgb;
}
public class System.Drawing.Imaging.PlayRecordCallback : MulticastDelegate {
    public PlayRecordCallback(object object, IntPtr method);
    public virtual void Invoke(EmfPlusRecordType recordType, int flags, int dataSize, IntPtr recordData);
    public virtual IAsyncResult BeginInvoke(EmfPlusRecordType recordType, int flags, int dataSize, IntPtr recordData, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Drawing.Imaging.PropertyItem : object {
    public int Id { get; public set; }
    public int Len { get; public set; }
    public short Type { get; public set; }
    public Byte[] Value { get; public set; }
    public int get_Id();
    public void set_Id(int value);
    public int get_Len();
    public void set_Len(int value);
    public short get_Type();
    public void set_Type(short value);
    public Byte[] get_Value();
    public void set_Value(Byte[] value);
}
public class System.Drawing.Imaging.WmfPlaceableFileHeader : object {
    public int Key { get; public set; }
    public short Hmf { get; public set; }
    public short BboxLeft { get; public set; }
    public short BboxTop { get; public set; }
    public short BboxRight { get; public set; }
    public short BboxBottom { get; public set; }
    public short Inch { get; public set; }
    public int Reserved { get; public set; }
    public short Checksum { get; public set; }
    public int get_Key();
    public void set_Key(int value);
    public short get_Hmf();
    public void set_Hmf(short value);
    public short get_BboxLeft();
    public void set_BboxLeft(short value);
    public short get_BboxTop();
    public void set_BboxTop(short value);
    public short get_BboxRight();
    public void set_BboxRight(short value);
    public short get_BboxBottom();
    public void set_BboxBottom(short value);
    public short get_Inch();
    public void set_Inch(short value);
    public int get_Reserved();
    public void set_Reserved(int value);
    public short get_Checksum();
    public void set_Checksum(short value);
}
public enum System.Drawing.KnownColor : Enum {
    public int value__;
    public static KnownColor ActiveBorder;
    public static KnownColor ActiveCaption;
    public static KnownColor ActiveCaptionText;
    public static KnownColor AppWorkspace;
    public static KnownColor Control;
    public static KnownColor ControlDark;
    public static KnownColor ControlDarkDark;
    public static KnownColor ControlLight;
    public static KnownColor ControlLightLight;
    public static KnownColor ControlText;
    public static KnownColor Desktop;
    public static KnownColor GrayText;
    public static KnownColor Highlight;
    public static KnownColor HighlightText;
    public static KnownColor HotTrack;
    public static KnownColor InactiveBorder;
    public static KnownColor InactiveCaption;
    public static KnownColor InactiveCaptionText;
    public static KnownColor Info;
    public static KnownColor InfoText;
    public static KnownColor Menu;
    public static KnownColor MenuText;
    public static KnownColor ScrollBar;
    public static KnownColor Window;
    public static KnownColor WindowFrame;
    public static KnownColor WindowText;
    public static KnownColor Transparent;
    public static KnownColor AliceBlue;
    public static KnownColor AntiqueWhite;
    public static KnownColor Aqua;
    public static KnownColor Aquamarine;
    public static KnownColor Azure;
    public static KnownColor Beige;
    public static KnownColor Bisque;
    public static KnownColor Black;
    public static KnownColor BlanchedAlmond;
    public static KnownColor Blue;
    public static KnownColor BlueViolet;
    public static KnownColor Brown;
    public static KnownColor BurlyWood;
    public static KnownColor CadetBlue;
    public static KnownColor Chartreuse;
    public static KnownColor Chocolate;
    public static KnownColor Coral;
    public static KnownColor CornflowerBlue;
    public static KnownColor Cornsilk;
    public static KnownColor Crimson;
    public static KnownColor Cyan;
    public static KnownColor DarkBlue;
    public static KnownColor DarkCyan;
    public static KnownColor DarkGoldenrod;
    public static KnownColor DarkGray;
    public static KnownColor DarkGreen;
    public static KnownColor DarkKhaki;
    public static KnownColor DarkMagenta;
    public static KnownColor DarkOliveGreen;
    public static KnownColor DarkOrange;
    public static KnownColor DarkOrchid;
    public static KnownColor DarkRed;
    public static KnownColor DarkSalmon;
    public static KnownColor DarkSeaGreen;
    public static KnownColor DarkSlateBlue;
    public static KnownColor DarkSlateGray;
    public static KnownColor DarkTurquoise;
    public static KnownColor DarkViolet;
    public static KnownColor DeepPink;
    public static KnownColor DeepSkyBlue;
    public static KnownColor DimGray;
    public static KnownColor DodgerBlue;
    public static KnownColor Firebrick;
    public static KnownColor FloralWhite;
    public static KnownColor ForestGreen;
    public static KnownColor Fuchsia;
    public static KnownColor Gainsboro;
    public static KnownColor GhostWhite;
    public static KnownColor Gold;
    public static KnownColor Goldenrod;
    public static KnownColor Gray;
    public static KnownColor Green;
    public static KnownColor GreenYellow;
    public static KnownColor Honeydew;
    public static KnownColor HotPink;
    public static KnownColor IndianRed;
    public static KnownColor Indigo;
    public static KnownColor Ivory;
    public static KnownColor Khaki;
    public static KnownColor Lavender;
    public static KnownColor LavenderBlush;
    public static KnownColor LawnGreen;
    public static KnownColor LemonChiffon;
    public static KnownColor LightBlue;
    public static KnownColor LightCoral;
    public static KnownColor LightCyan;
    public static KnownColor LightGoldenrodYellow;
    public static KnownColor LightGray;
    public static KnownColor LightGreen;
    public static KnownColor LightPink;
    public static KnownColor LightSalmon;
    public static KnownColor LightSeaGreen;
    public static KnownColor LightSkyBlue;
    public static KnownColor LightSlateGray;
    public static KnownColor LightSteelBlue;
    public static KnownColor LightYellow;
    public static KnownColor Lime;
    public static KnownColor LimeGreen;
    public static KnownColor Linen;
    public static KnownColor Magenta;
    public static KnownColor Maroon;
    public static KnownColor MediumAquamarine;
    public static KnownColor MediumBlue;
    public static KnownColor MediumOrchid;
    public static KnownColor MediumPurple;
    public static KnownColor MediumSeaGreen;
    public static KnownColor MediumSlateBlue;
    public static KnownColor MediumSpringGreen;
    public static KnownColor MediumTurquoise;
    public static KnownColor MediumVioletRed;
    public static KnownColor MidnightBlue;
    public static KnownColor MintCream;
    public static KnownColor MistyRose;
    public static KnownColor Moccasin;
    public static KnownColor NavajoWhite;
    public static KnownColor Navy;
    public static KnownColor OldLace;
    public static KnownColor Olive;
    public static KnownColor OliveDrab;
    public static KnownColor Orange;
    public static KnownColor OrangeRed;
    public static KnownColor Orchid;
    public static KnownColor PaleGoldenrod;
    public static KnownColor PaleGreen;
    public static KnownColor PaleTurquoise;
    public static KnownColor PaleVioletRed;
    public static KnownColor PapayaWhip;
    public static KnownColor PeachPuff;
    public static KnownColor Peru;
    public static KnownColor Pink;
    public static KnownColor Plum;
    public static KnownColor PowderBlue;
    public static KnownColor Purple;
    public static KnownColor Red;
    public static KnownColor RosyBrown;
    public static KnownColor RoyalBlue;
    public static KnownColor SaddleBrown;
    public static KnownColor Salmon;
    public static KnownColor SandyBrown;
    public static KnownColor SeaGreen;
    public static KnownColor SeaShell;
    public static KnownColor Sienna;
    public static KnownColor Silver;
    public static KnownColor SkyBlue;
    public static KnownColor SlateBlue;
    public static KnownColor SlateGray;
    public static KnownColor Snow;
    public static KnownColor SpringGreen;
    public static KnownColor SteelBlue;
    public static KnownColor Tan;
    public static KnownColor Teal;
    public static KnownColor Thistle;
    public static KnownColor Tomato;
    public static KnownColor Turquoise;
    public static KnownColor Violet;
    public static KnownColor Wheat;
    public static KnownColor White;
    public static KnownColor WhiteSmoke;
    public static KnownColor Yellow;
    public static KnownColor YellowGreen;
    public static KnownColor ButtonFace;
    public static KnownColor ButtonHighlight;
    public static KnownColor ButtonShadow;
    public static KnownColor GradientActiveCaption;
    public static KnownColor GradientInactiveCaption;
    public static KnownColor MenuBar;
    public static KnownColor MenuHighlight;
}
internal static class System.Drawing.KnownColors : object {
    internal static UInt32[] ArgbValues;
    private static KnownColors();
    public static Color FromKnownColor(KnownColor kc);
    public static string GetName(short kc);
    public static string GetName(KnownColor kc);
    public static Color FindColorMatch(Color c);
    public static void Update(int knownColor, int color);
}
public class System.Drawing.Pen : MarshalByRefObject {
    public float Width { get; public set; }
    public LineCap StartCap { get; public set; }
    public LineCap EndCap { get; public set; }
    public DashCap DashCap { get; public set; }
    public LineJoin LineJoin { get; public set; }
    public CustomLineCap CustomStartCap { get; public set; }
    public CustomLineCap CustomEndCap { get; public set; }
    public float MiterLimit { get; public set; }
    public PenAlignment Alignment { get; public set; }
    public Matrix Transform { get; public set; }
    public PenType PenType { get; }
    public Color Color { get; public set; }
    public Brush Brush { get; public set; }
    public DashStyle DashStyle { get; public set; }
    public float DashOffset { get; public set; }
    public Single[] DashPattern { get; public set; }
    public Single[] CompoundArray { get; public set; }
    public Pen(Color color);
    public Pen(Color color, float width);
    public Pen(Brush brush);
    public Pen(Brush brush, float width);
    public float get_Width();
    public void set_Width(float value);
    public LineCap get_StartCap();
    public void set_StartCap(LineCap value);
    public LineCap get_EndCap();
    public void set_EndCap(LineCap value);
    public DashCap get_DashCap();
    public void set_DashCap(DashCap value);
    public LineJoin get_LineJoin();
    public void set_LineJoin(LineJoin value);
    public CustomLineCap get_CustomStartCap();
    public void set_CustomStartCap(CustomLineCap value);
    public CustomLineCap get_CustomEndCap();
    public void set_CustomEndCap(CustomLineCap value);
    public float get_MiterLimit();
    public void set_MiterLimit(float value);
    public PenAlignment get_Alignment();
    public void set_Alignment(PenAlignment value);
    public Matrix get_Transform();
    public void set_Transform(Matrix value);
    public PenType get_PenType();
    public Color get_Color();
    public void set_Color(Color value);
    public Brush get_Brush();
    public void set_Brush(Brush value);
    public DashStyle get_DashStyle();
    public void set_DashStyle(DashStyle value);
    public float get_DashOffset();
    public void set_DashOffset(float value);
    public Single[] get_DashPattern();
    public void set_DashPattern(Single[] value);
    public Single[] get_CompoundArray();
    public void set_CompoundArray(Single[] value);
    protected virtual override void Finalize();
    public sealed virtual object Clone();
    public sealed virtual void Dispose();
    public void SetLineCap(LineCap startCap, LineCap endCap, DashCap dashCap);
    public void ResetTransform();
    public void MultiplyTransform(Matrix matrix);
    public void MultiplyTransform(Matrix matrix, MatrixOrder order);
    public void TranslateTransform(float dx, float dy);
    public void TranslateTransform(float dx, float dy, MatrixOrder order);
    public void ScaleTransform(float sx, float sy);
    public void ScaleTransform(float sx, float sy, MatrixOrder order);
    public void RotateTransform(float angle);
    public void RotateTransform(float angle, MatrixOrder order);
}
public class System.Drawing.Pens : object {
    public static Pen Transparent { get; }
    public static Pen AliceBlue { get; }
    public static Pen AntiqueWhite { get; }
    public static Pen Aqua { get; }
    public static Pen Aquamarine { get; }
    public static Pen Azure { get; }
    public static Pen Beige { get; }
    public static Pen Bisque { get; }
    public static Pen Black { get; }
    public static Pen BlanchedAlmond { get; }
    public static Pen Blue { get; }
    public static Pen BlueViolet { get; }
    public static Pen Brown { get; }
    public static Pen BurlyWood { get; }
    public static Pen CadetBlue { get; }
    public static Pen Chartreuse { get; }
    public static Pen Chocolate { get; }
    public static Pen Coral { get; }
    public static Pen CornflowerBlue { get; }
    public static Pen Cornsilk { get; }
    public static Pen Crimson { get; }
    public static Pen Cyan { get; }
    public static Pen DarkBlue { get; }
    public static Pen DarkCyan { get; }
    public static Pen DarkGoldenrod { get; }
    public static Pen DarkGray { get; }
    public static Pen DarkGreen { get; }
    public static Pen DarkKhaki { get; }
    public static Pen DarkMagenta { get; }
    public static Pen DarkOliveGreen { get; }
    public static Pen DarkOrange { get; }
    public static Pen DarkOrchid { get; }
    public static Pen DarkRed { get; }
    public static Pen DarkSalmon { get; }
    public static Pen DarkSeaGreen { get; }
    public static Pen DarkSlateBlue { get; }
    public static Pen DarkSlateGray { get; }
    public static Pen DarkTurquoise { get; }
    public static Pen DarkViolet { get; }
    public static Pen DeepPink { get; }
    public static Pen DeepSkyBlue { get; }
    public static Pen DimGray { get; }
    public static Pen DodgerBlue { get; }
    public static Pen Firebrick { get; }
    public static Pen FloralWhite { get; }
    public static Pen ForestGreen { get; }
    public static Pen Fuchsia { get; }
    public static Pen Gainsboro { get; }
    public static Pen GhostWhite { get; }
    public static Pen Gold { get; }
    public static Pen Goldenrod { get; }
    public static Pen Gray { get; }
    public static Pen Green { get; }
    public static Pen GreenYellow { get; }
    public static Pen Honeydew { get; }
    public static Pen HotPink { get; }
    public static Pen IndianRed { get; }
    public static Pen Indigo { get; }
    public static Pen Ivory { get; }
    public static Pen Khaki { get; }
    public static Pen Lavender { get; }
    public static Pen LavenderBlush { get; }
    public static Pen LawnGreen { get; }
    public static Pen LemonChiffon { get; }
    public static Pen LightBlue { get; }
    public static Pen LightCoral { get; }
    public static Pen LightCyan { get; }
    public static Pen LightGoldenrodYellow { get; }
    public static Pen LightGreen { get; }
    public static Pen LightGray { get; }
    public static Pen LightPink { get; }
    public static Pen LightSalmon { get; }
    public static Pen LightSeaGreen { get; }
    public static Pen LightSkyBlue { get; }
    public static Pen LightSlateGray { get; }
    public static Pen LightSteelBlue { get; }
    public static Pen LightYellow { get; }
    public static Pen Lime { get; }
    public static Pen LimeGreen { get; }
    public static Pen Linen { get; }
    public static Pen Magenta { get; }
    public static Pen Maroon { get; }
    public static Pen MediumAquamarine { get; }
    public static Pen MediumBlue { get; }
    public static Pen MediumOrchid { get; }
    public static Pen MediumPurple { get; }
    public static Pen MediumSeaGreen { get; }
    public static Pen MediumSlateBlue { get; }
    public static Pen MediumSpringGreen { get; }
    public static Pen MediumTurquoise { get; }
    public static Pen MediumVioletRed { get; }
    public static Pen MidnightBlue { get; }
    public static Pen MintCream { get; }
    public static Pen MistyRose { get; }
    public static Pen Moccasin { get; }
    public static Pen NavajoWhite { get; }
    public static Pen Navy { get; }
    public static Pen OldLace { get; }
    public static Pen Olive { get; }
    public static Pen OliveDrab { get; }
    public static Pen Orange { get; }
    public static Pen OrangeRed { get; }
    public static Pen Orchid { get; }
    public static Pen PaleGoldenrod { get; }
    public static Pen PaleGreen { get; }
    public static Pen PaleTurquoise { get; }
    public static Pen PaleVioletRed { get; }
    public static Pen PapayaWhip { get; }
    public static Pen PeachPuff { get; }
    public static Pen Peru { get; }
    public static Pen Pink { get; }
    public static Pen Plum { get; }
    public static Pen PowderBlue { get; }
    public static Pen Purple { get; }
    public static Pen Red { get; }
    public static Pen RosyBrown { get; }
    public static Pen RoyalBlue { get; }
    public static Pen SaddleBrown { get; }
    public static Pen Salmon { get; }
    public static Pen SandyBrown { get; }
    public static Pen SeaGreen { get; }
    public static Pen SeaShell { get; }
    public static Pen Sienna { get; }
    public static Pen Silver { get; }
    public static Pen SkyBlue { get; }
    public static Pen SlateBlue { get; }
    public static Pen SlateGray { get; }
    public static Pen Snow { get; }
    public static Pen SpringGreen { get; }
    public static Pen SteelBlue { get; }
    public static Pen Tan { get; }
    public static Pen Teal { get; }
    public static Pen Thistle { get; }
    public static Pen Tomato { get; }
    public static Pen Turquoise { get; }
    public static Pen Violet { get; }
    public static Pen Wheat { get; }
    public static Pen White { get; }
    public static Pen WhiteSmoke { get; }
    public static Pen Yellow { get; }
    public static Pen YellowGreen { get; }
    public static Pen get_Transparent();
    public static Pen get_AliceBlue();
    public static Pen get_AntiqueWhite();
    public static Pen get_Aqua();
    public static Pen get_Aquamarine();
    public static Pen get_Azure();
    public static Pen get_Beige();
    public static Pen get_Bisque();
    public static Pen get_Black();
    public static Pen get_BlanchedAlmond();
    public static Pen get_Blue();
    public static Pen get_BlueViolet();
    public static Pen get_Brown();
    public static Pen get_BurlyWood();
    public static Pen get_CadetBlue();
    public static Pen get_Chartreuse();
    public static Pen get_Chocolate();
    public static Pen get_Coral();
    public static Pen get_CornflowerBlue();
    public static Pen get_Cornsilk();
    public static Pen get_Crimson();
    public static Pen get_Cyan();
    public static Pen get_DarkBlue();
    public static Pen get_DarkCyan();
    public static Pen get_DarkGoldenrod();
    public static Pen get_DarkGray();
    public static Pen get_DarkGreen();
    public static Pen get_DarkKhaki();
    public static Pen get_DarkMagenta();
    public static Pen get_DarkOliveGreen();
    public static Pen get_DarkOrange();
    public static Pen get_DarkOrchid();
    public static Pen get_DarkRed();
    public static Pen get_DarkSalmon();
    public static Pen get_DarkSeaGreen();
    public static Pen get_DarkSlateBlue();
    public static Pen get_DarkSlateGray();
    public static Pen get_DarkTurquoise();
    public static Pen get_DarkViolet();
    public static Pen get_DeepPink();
    public static Pen get_DeepSkyBlue();
    public static Pen get_DimGray();
    public static Pen get_DodgerBlue();
    public static Pen get_Firebrick();
    public static Pen get_FloralWhite();
    public static Pen get_ForestGreen();
    public static Pen get_Fuchsia();
    public static Pen get_Gainsboro();
    public static Pen get_GhostWhite();
    public static Pen get_Gold();
    public static Pen get_Goldenrod();
    public static Pen get_Gray();
    public static Pen get_Green();
    public static Pen get_GreenYellow();
    public static Pen get_Honeydew();
    public static Pen get_HotPink();
    public static Pen get_IndianRed();
    public static Pen get_Indigo();
    public static Pen get_Ivory();
    public static Pen get_Khaki();
    public static Pen get_Lavender();
    public static Pen get_LavenderBlush();
    public static Pen get_LawnGreen();
    public static Pen get_LemonChiffon();
    public static Pen get_LightBlue();
    public static Pen get_LightCoral();
    public static Pen get_LightCyan();
    public static Pen get_LightGoldenrodYellow();
    public static Pen get_LightGreen();
    public static Pen get_LightGray();
    public static Pen get_LightPink();
    public static Pen get_LightSalmon();
    public static Pen get_LightSeaGreen();
    public static Pen get_LightSkyBlue();
    public static Pen get_LightSlateGray();
    public static Pen get_LightSteelBlue();
    public static Pen get_LightYellow();
    public static Pen get_Lime();
    public static Pen get_LimeGreen();
    public static Pen get_Linen();
    public static Pen get_Magenta();
    public static Pen get_Maroon();
    public static Pen get_MediumAquamarine();
    public static Pen get_MediumBlue();
    public static Pen get_MediumOrchid();
    public static Pen get_MediumPurple();
    public static Pen get_MediumSeaGreen();
    public static Pen get_MediumSlateBlue();
    public static Pen get_MediumSpringGreen();
    public static Pen get_MediumTurquoise();
    public static Pen get_MediumVioletRed();
    public static Pen get_MidnightBlue();
    public static Pen get_MintCream();
    public static Pen get_MistyRose();
    public static Pen get_Moccasin();
    public static Pen get_NavajoWhite();
    public static Pen get_Navy();
    public static Pen get_OldLace();
    public static Pen get_Olive();
    public static Pen get_OliveDrab();
    public static Pen get_Orange();
    public static Pen get_OrangeRed();
    public static Pen get_Orchid();
    public static Pen get_PaleGoldenrod();
    public static Pen get_PaleGreen();
    public static Pen get_PaleTurquoise();
    public static Pen get_PaleVioletRed();
    public static Pen get_PapayaWhip();
    public static Pen get_PeachPuff();
    public static Pen get_Peru();
    public static Pen get_Pink();
    public static Pen get_Plum();
    public static Pen get_PowderBlue();
    public static Pen get_Purple();
    public static Pen get_Red();
    public static Pen get_RosyBrown();
    public static Pen get_RoyalBlue();
    public static Pen get_SaddleBrown();
    public static Pen get_Salmon();
    public static Pen get_SandyBrown();
    public static Pen get_SeaGreen();
    public static Pen get_SeaShell();
    public static Pen get_Sienna();
    public static Pen get_Silver();
    public static Pen get_SkyBlue();
    public static Pen get_SlateBlue();
    public static Pen get_SlateGray();
    public static Pen get_Snow();
    public static Pen get_SpringGreen();
    public static Pen get_SteelBlue();
    public static Pen get_Tan();
    public static Pen get_Teal();
    public static Pen get_Thistle();
    public static Pen get_Tomato();
    public static Pen get_Turquoise();
    public static Pen get_Violet();
    public static Pen get_Wheat();
    public static Pen get_White();
    public static Pen get_WhiteSmoke();
    public static Pen get_Yellow();
    public static Pen get_YellowGreen();
}
[ComVisibleAttribute("True")]
public class System.Drawing.Point : ValueType {
    private int x;
    private int y;
    public static Point Empty;
    [BrowsableAttribute("False")]
public bool IsEmpty { get; }
    public int X { get; public set; }
    public int Y { get; public set; }
    public Point(int dw);
    public Point(Size sz);
    public Point(int x, int y);
    public static Point Ceiling(PointF value);
    public static Point Round(PointF value);
    public static Point Truncate(PointF value);
    public static Point op_Addition(Point pt, Size sz);
    public static bool op_Equality(Point left, Point right);
    public static bool op_Inequality(Point left, Point right);
    public static Point op_Subtraction(Point pt, Size sz);
    public static Size op_Explicit(Point p);
    public static PointF op_Implicit(Point p);
    public bool get_IsEmpty();
    public int get_X();
    public void set_X(int value);
    public int get_Y();
    public void set_Y(int value);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public void Offset(int dx, int dy);
    public virtual string ToString();
    public static Point Add(Point pt, Size sz);
    public void Offset(Point p);
    public static Point Subtract(Point pt, Size sz);
}
public class System.Drawing.PointConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
    public virtual object CreateInstance(ITypeDescriptorContext context, IDictionary propertyValues);
    public virtual bool GetCreateInstanceSupported(ITypeDescriptorContext context);
    public virtual PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes);
    public virtual bool GetPropertiesSupported(ITypeDescriptorContext context);
}
[ComVisibleAttribute("True")]
public class System.Drawing.PointF : ValueType {
    public static PointF Empty;
    private float x;
    private float y;
    [BrowsableAttribute("False")]
public bool IsEmpty { get; }
    public float X { get; public set; }
    public float Y { get; public set; }
    public PointF(float x, float y);
    public bool get_IsEmpty();
    public float get_X();
    public void set_X(float value);
    public float get_Y();
    public void set_Y(float value);
    public static PointF op_Addition(PointF pt, Size sz);
    public static PointF op_Subtraction(PointF pt, Size sz);
    public static PointF op_Addition(PointF pt, SizeF sz);
    public static PointF op_Subtraction(PointF pt, SizeF sz);
    public static bool op_Equality(PointF left, PointF right);
    public static bool op_Inequality(PointF left, PointF right);
    public static PointF Add(PointF pt, Size sz);
    public static PointF Subtract(PointF pt, Size sz);
    public static PointF Add(PointF pt, SizeF sz);
    public static PointF Subtract(PointF pt, SizeF sz);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public enum System.Drawing.Printing.Duplex : Enum {
    public int value__;
    public static Duplex Default;
    public static Duplex Simplex;
    public static Duplex Vertical;
    public static Duplex Horizontal;
}
public class System.Drawing.Printing.InvalidPrinterException : SystemException {
    public InvalidPrinterException(PrinterSettings settings);
    protected InvalidPrinterException(SerializationInfo info, StreamingContext context);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[TypeConverterAttribute("System.Drawing.Printing.MarginsConverter")]
public class System.Drawing.Printing.Margins : object {
    public int Left { get; public set; }
    public int Right { get; public set; }
    public int Top { get; public set; }
    public int Bottom { get; public set; }
    public Margins(int left, int right, int top, int bottom);
    public int get_Left();
    public void set_Left(int value);
    public int get_Right();
    public void set_Right(int value);
    public int get_Top();
    public void set_Top(int value);
    public int get_Bottom();
    public void set_Bottom(int value);
    public static bool op_Equality(Margins m1, Margins m2);
    public static bool op_Inequality(Margins m1, Margins m2);
    public sealed virtual object Clone();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class System.Drawing.Printing.MarginsConverter : ExpandableObjectConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
    public virtual object CreateInstance(ITypeDescriptorContext context, IDictionary propertyValues);
    public virtual bool GetCreateInstanceSupported(ITypeDescriptorContext context);
}
public class System.Drawing.Printing.PageSettings : object {
    public Rectangle Bounds { get; }
    public bool Color { get; public set; }
    public float HardMarginX { get; }
    public float HardMarginY { get; }
    public bool Landscape { get; public set; }
    public Margins Margins { get; public set; }
    public PaperSize PaperSize { get; public set; }
    public PaperSource PaperSource { get; public set; }
    public RectangleF PrintableArea { get; }
    public PrinterResolution PrinterResolution { get; public set; }
    public PrinterSettings PrinterSettings { get; public set; }
    public PageSettings(PrinterSettings printerSettings);
    public Rectangle get_Bounds();
    public bool get_Color();
    public void set_Color(bool value);
    public float get_HardMarginX();
    public float get_HardMarginY();
    public bool get_Landscape();
    public void set_Landscape(bool value);
    public Margins get_Margins();
    public void set_Margins(Margins value);
    public PaperSize get_PaperSize();
    public void set_PaperSize(PaperSize value);
    public PaperSource get_PaperSource();
    public void set_PaperSource(PaperSource value);
    public RectangleF get_PrintableArea();
    public PrinterResolution get_PrinterResolution();
    public void set_PrinterResolution(PrinterResolution value);
    public PrinterSettings get_PrinterSettings();
    public void set_PrinterSettings(PrinterSettings value);
    public sealed virtual object Clone();
    public void CopyToHdevmode(IntPtr hdevmode);
    public void SetHdevmode(IntPtr hdevmode);
    public virtual string ToString();
}
public enum System.Drawing.Printing.PaperKind : Enum {
    public int value__;
    public static PaperKind Custom;
    public static PaperKind Letter;
    public static PaperKind LetterSmall;
    public static PaperKind Tabloid;
    public static PaperKind Ledger;
    public static PaperKind Legal;
    public static PaperKind Statement;
    public static PaperKind Executive;
    public static PaperKind A3;
    public static PaperKind A4;
    public static PaperKind A4Small;
    public static PaperKind A5;
    public static PaperKind B4;
    public static PaperKind B5;
    public static PaperKind Folio;
    public static PaperKind Quarto;
    public static PaperKind Standard10x14;
    public static PaperKind Standard11x17;
    public static PaperKind Note;
    public static PaperKind Number9Envelope;
    public static PaperKind Number10Envelope;
    public static PaperKind Number11Envelope;
    public static PaperKind Number12Envelope;
    public static PaperKind Number14Envelope;
    public static PaperKind CSheet;
    public static PaperKind DSheet;
    public static PaperKind ESheet;
    public static PaperKind DLEnvelope;
    public static PaperKind C5Envelope;
    public static PaperKind C3Envelope;
    public static PaperKind C4Envelope;
    public static PaperKind C6Envelope;
    public static PaperKind C65Envelope;
    public static PaperKind B4Envelope;
    public static PaperKind B5Envelope;
    public static PaperKind B6Envelope;
    public static PaperKind ItalyEnvelope;
    public static PaperKind MonarchEnvelope;
    public static PaperKind PersonalEnvelope;
    public static PaperKind USStandardFanfold;
    public static PaperKind GermanStandardFanfold;
    public static PaperKind GermanLegalFanfold;
    public static PaperKind IsoB4;
    public static PaperKind JapanesePostcard;
    public static PaperKind Standard9x11;
    public static PaperKind Standard10x11;
    public static PaperKind Standard15x11;
    public static PaperKind InviteEnvelope;
    public static PaperKind LetterExtra;
    public static PaperKind LegalExtra;
    public static PaperKind TabloidExtra;
    public static PaperKind A4Extra;
    public static PaperKind LetterTransverse;
    public static PaperKind A4Transverse;
    public static PaperKind LetterExtraTransverse;
    public static PaperKind APlus;
    public static PaperKind BPlus;
    public static PaperKind LetterPlus;
    public static PaperKind A4Plus;
    public static PaperKind A5Transverse;
    public static PaperKind B5Transverse;
    public static PaperKind A3Extra;
    public static PaperKind A5Extra;
    public static PaperKind B5Extra;
    public static PaperKind A2;
    public static PaperKind A3Transverse;
    public static PaperKind A3ExtraTransverse;
    public static PaperKind JapaneseDoublePostcard;
    public static PaperKind A6;
    public static PaperKind JapaneseEnvelopeKakuNumber2;
    public static PaperKind JapaneseEnvelopeKakuNumber3;
    public static PaperKind JapaneseEnvelopeChouNumber3;
    public static PaperKind JapaneseEnvelopeChouNumber4;
    public static PaperKind LetterRotated;
    public static PaperKind A3Rotated;
    public static PaperKind A4Rotated;
    public static PaperKind A5Rotated;
    public static PaperKind B4JisRotated;
    public static PaperKind B5JisRotated;
    public static PaperKind JapanesePostcardRotated;
    public static PaperKind JapaneseDoublePostcardRotated;
    public static PaperKind A6Rotated;
    public static PaperKind JapaneseEnvelopeKakuNumber2Rotated;
    public static PaperKind JapaneseEnvelopeKakuNumber3Rotated;
    public static PaperKind JapaneseEnvelopeChouNumber3Rotated;
    public static PaperKind JapaneseEnvelopeChouNumber4Rotated;
    public static PaperKind B6Jis;
    public static PaperKind B6JisRotated;
    public static PaperKind Standard12x11;
    public static PaperKind JapaneseEnvelopeYouNumber4;
    public static PaperKind JapaneseEnvelopeYouNumber4Rotated;
    public static PaperKind Prc16K;
    public static PaperKind Prc32K;
    public static PaperKind Prc32KBig;
    public static PaperKind PrcEnvelopeNumber1;
    public static PaperKind PrcEnvelopeNumber2;
    public static PaperKind PrcEnvelopeNumber3;
    public static PaperKind PrcEnvelopeNumber4;
    public static PaperKind PrcEnvelopeNumber5;
    public static PaperKind PrcEnvelopeNumber6;
    public static PaperKind PrcEnvelopeNumber7;
    public static PaperKind PrcEnvelopeNumber8;
    public static PaperKind PrcEnvelopeNumber9;
    public static PaperKind PrcEnvelopeNumber10;
    public static PaperKind Prc16KRotated;
    public static PaperKind Prc32KRotated;
    public static PaperKind Prc32KBigRotated;
    public static PaperKind PrcEnvelopeNumber1Rotated;
    public static PaperKind PrcEnvelopeNumber2Rotated;
    public static PaperKind PrcEnvelopeNumber3Rotated;
    public static PaperKind PrcEnvelopeNumber4Rotated;
    public static PaperKind PrcEnvelopeNumber5Rotated;
    public static PaperKind PrcEnvelopeNumber6Rotated;
    public static PaperKind PrcEnvelopeNumber7Rotated;
    public static PaperKind PrcEnvelopeNumber8Rotated;
    public static PaperKind PrcEnvelopeNumber9Rotated;
    public static PaperKind PrcEnvelopeNumber10Rotated;
}
public class System.Drawing.Printing.PaperSize : object {
    public int Height { get; public set; }
    public PaperKind Kind { get; }
    public string PaperName { get; public set; }
    public int RawKind { get; public set; }
    public int Width { get; public set; }
    public PaperSize(string name, int width, int height);
    public int get_Height();
    public void set_Height(int value);
    public PaperKind get_Kind();
    public string get_PaperName();
    public void set_PaperName(string value);
    public int get_RawKind();
    public void set_RawKind(int value);
    public int get_Width();
    public void set_Width(int value);
    public virtual string ToString();
}
public class System.Drawing.Printing.PaperSource : object {
    public PaperSourceKind Kind { get; }
    public int RawKind { get; public set; }
    public string SourceName { get; public set; }
    public PaperSourceKind get_Kind();
    public int get_RawKind();
    public void set_RawKind(int value);
    public string get_SourceName();
    public void set_SourceName(string value);
    public virtual string ToString();
}
public enum System.Drawing.Printing.PaperSourceKind : Enum {
    public int value__;
    public static PaperSourceKind Upper;
    public static PaperSourceKind Lower;
    public static PaperSourceKind Middle;
    public static PaperSourceKind Manual;
    public static PaperSourceKind Envelope;
    public static PaperSourceKind ManualFeed;
    public static PaperSourceKind AutomaticFeed;
    public static PaperSourceKind TractorFeed;
    public static PaperSourceKind SmallFormat;
    public static PaperSourceKind LargeFormat;
    public static PaperSourceKind LargeCapacity;
    public static PaperSourceKind Cassette;
    public static PaperSourceKind FormSource;
    public static PaperSourceKind Custom;
}
public class System.Drawing.Printing.PreviewPageInfo : object {
    public Image Image { get; }
    public Size PhysicalSize { get; }
    public PreviewPageInfo(Image image, Size physicalSize);
    public Image get_Image();
    public Size get_PhysicalSize();
}
public class System.Drawing.Printing.PreviewPrintController : PrintController {
    public bool IsPreview { get; }
    public bool UseAntiAlias { get; public set; }
    public virtual bool get_IsPreview();
    public virtual bool get_UseAntiAlias();
    public virtual void set_UseAntiAlias(bool value);
    public virtual void OnStartPrint(PrintDocument document, PrintEventArgs e);
    public virtual Graphics OnStartPage(PrintDocument document, PrintPageEventArgs e);
    public virtual void OnEndPage(PrintDocument document, PrintPageEventArgs e);
    public virtual void OnEndPrint(PrintDocument document, PrintEventArgs e);
    public PreviewPageInfo[] GetPreviewPageInfo();
}
public enum System.Drawing.Printing.PrintAction : Enum {
    public int value__;
    public static PrintAction PrintToFile;
    public static PrintAction PrintToPreview;
    public static PrintAction PrintToPrinter;
}
public abstract class System.Drawing.Printing.PrintController : object {
    public bool IsPreview { get; }
    public virtual bool get_IsPreview();
    public virtual void OnStartPrint(PrintDocument document, PrintEventArgs e);
    public virtual Graphics OnStartPage(PrintDocument document, PrintPageEventArgs e);
    public virtual void OnEndPage(PrintDocument document, PrintPageEventArgs e);
    public virtual void OnEndPrint(PrintDocument document, PrintEventArgs e);
}
[DefaultEventAttribute("PrintPage")]
[ToolboxItemFilterAttribute("System.Drawing.Printing")]
[DefaultPropertyAttribute("DocumentName")]
public class System.Drawing.Printing.PrintDocument : Component {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private PrintEventHandler BeginPrint;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private PrintEventHandler EndPrint;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private PrintPageEventHandler PrintPage;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private QueryPageSettingsEventHandler QueryPageSettings;
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public PageSettings DefaultPageSettings { get; public set; }
    [DefaultValueAttribute("document")]
public string DocumentName { get; public set; }
    [DefaultValueAttribute("False")]
public bool OriginAtMargins { get; public set; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public PrintController PrintController { get; public set; }
    [DesignerSerializationVisibilityAttribute("0")]
[BrowsableAttribute("False")]
public PrinterSettings PrinterSettings { get; public set; }
    public PageSettings get_DefaultPageSettings();
    public void set_DefaultPageSettings(PageSettings value);
    public string get_DocumentName();
    public void set_DocumentName(string value);
    public bool get_OriginAtMargins();
    public void set_OriginAtMargins(bool value);
    public PrintController get_PrintController();
    public void set_PrintController(PrintController value);
    public PrinterSettings get_PrinterSettings();
    public void set_PrinterSettings(PrinterSettings value);
    [CompilerGeneratedAttribute]
public void add_BeginPrint(PrintEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_BeginPrint(PrintEventHandler value);
    [CompilerGeneratedAttribute]
public void add_EndPrint(PrintEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_EndPrint(PrintEventHandler value);
    [CompilerGeneratedAttribute]
public void add_PrintPage(PrintPageEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_PrintPage(PrintPageEventHandler value);
    [CompilerGeneratedAttribute]
public void add_QueryPageSettings(QueryPageSettingsEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_QueryPageSettings(QueryPageSettingsEventHandler value);
    protected virtual void OnBeginPrint(PrintEventArgs e);
    protected virtual void OnEndPrint(PrintEventArgs e);
    protected virtual void OnPrintPage(PrintPageEventArgs e);
    protected virtual void OnQueryPageSettings(QueryPageSettingsEventArgs e);
    public void Print();
    public virtual string ToString();
}
public class System.Drawing.Printing.PrinterResolution : object {
    public PrinterResolutionKind Kind { get; public set; }
    public int X { get; public set; }
    public int Y { get; public set; }
    public PrinterResolutionKind get_Kind();
    public void set_Kind(PrinterResolutionKind value);
    public int get_X();
    public void set_X(int value);
    public int get_Y();
    public void set_Y(int value);
    public virtual string ToString();
}
public enum System.Drawing.Printing.PrinterResolutionKind : Enum {
    public int value__;
    public static PrinterResolutionKind High;
    public static PrinterResolutionKind Medium;
    public static PrinterResolutionKind Low;
    public static PrinterResolutionKind Draft;
    public static PrinterResolutionKind Custom;
}
public class System.Drawing.Printing.PrinterSettings : object {
    public bool CanDuplex { get; }
    public short Copies { get; public set; }
    public bool Collate { get; public set; }
    public PageSettings DefaultPageSettings { get; }
    public Duplex Duplex { get; public set; }
    public int FromPage { get; public set; }
    public static StringCollection InstalledPrinters { get; }
    public bool IsDefaultPrinter { get; }
    public bool IsPlotter { get; }
    public bool IsValid { get; }
    public int LandscapeAngle { get; }
    public int MaximumCopies { get; }
    public int MaximumPage { get; public set; }
    public int MinimumPage { get; public set; }
    public string PrintFileName { get; public set; }
    public PaperSizeCollection PaperSizes { get; }
    public PaperSourceCollection PaperSources { get; }
    public PrintRange PrintRange { get; public set; }
    public bool PrintToFile { get; public set; }
    public string PrinterName { get; public set; }
    public PrinterResolutionCollection PrinterResolutions { get; }
    public bool SupportsColor { get; }
    public int ToPage { get; public set; }
    public bool get_CanDuplex();
    public short get_Copies();
    public void set_Copies(short value);
    public bool get_Collate();
    public void set_Collate(bool value);
    public PageSettings get_DefaultPageSettings();
    public Duplex get_Duplex();
    public void set_Duplex(Duplex value);
    public int get_FromPage();
    public void set_FromPage(int value);
    public static StringCollection get_InstalledPrinters();
    public bool get_IsDefaultPrinter();
    public bool get_IsPlotter();
    public bool get_IsValid();
    public int get_LandscapeAngle();
    public int get_MaximumCopies();
    public int get_MaximumPage();
    public void set_MaximumPage(int value);
    public int get_MinimumPage();
    public void set_MinimumPage(int value);
    public string get_PrintFileName();
    public void set_PrintFileName(string value);
    public PaperSizeCollection get_PaperSizes();
    public PaperSourceCollection get_PaperSources();
    public PrintRange get_PrintRange();
    public void set_PrintRange(PrintRange value);
    public bool get_PrintToFile();
    public void set_PrintToFile(bool value);
    public string get_PrinterName();
    public void set_PrinterName(string value);
    public PrinterResolutionCollection get_PrinterResolutions();
    public bool get_SupportsColor();
    public int get_ToPage();
    public void set_ToPage(int value);
    public bool IsDirectPrintingSupported(ImageFormat imageFormat);
    public bool IsDirectPrintingSupported(Image image);
    public sealed virtual object Clone();
    public Graphics CreateMeasurementGraphics();
    public Graphics CreateMeasurementGraphics(bool honorOriginAtMargins);
    public Graphics CreateMeasurementGraphics(PageSettings pageSettings);
    public Graphics CreateMeasurementGraphics(PageSettings pageSettings, bool honorOriginAtMargins);
    public IntPtr GetHdevmode();
    public IntPtr GetHdevmode(PageSettings pageSettings);
    public IntPtr GetHdevnames();
    public void SetHdevmode(IntPtr hdevmode);
    public void SetHdevnames(IntPtr hdevnames);
    public virtual string ToString();
}
public enum System.Drawing.Printing.PrinterUnit : Enum {
    public int value__;
    public static PrinterUnit Display;
    public static PrinterUnit ThousandthsOfAnInch;
    public static PrinterUnit HundredthsOfAMillimeter;
    public static PrinterUnit TenthsOfAMillimeter;
}
public class System.Drawing.Printing.PrinterUnitConvert : object {
    public static double Convert(double value, PrinterUnit fromUnit, PrinterUnit toUnit);
    public static int Convert(int value, PrinterUnit fromUnit, PrinterUnit toUnit);
    public static Point Convert(Point value, PrinterUnit fromUnit, PrinterUnit toUnit);
    public static Size Convert(Size value, PrinterUnit fromUnit, PrinterUnit toUnit);
    public static Rectangle Convert(Rectangle value, PrinterUnit fromUnit, PrinterUnit toUnit);
    public static Margins Convert(Margins value, PrinterUnit fromUnit, PrinterUnit toUnit);
}
public class System.Drawing.Printing.PrintEventArgs : CancelEventArgs {
    public PrintAction PrintAction { get; }
    public PrintAction get_PrintAction();
}
public class System.Drawing.Printing.PrintEventHandler : MulticastDelegate {
    public PrintEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, PrintEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, PrintEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Drawing.Printing.PrintingPermission : CodeAccessPermission {
    public PrintingPermissionLevel Level { get; public set; }
    public PrintingPermission(PermissionState state);
    public PrintingPermission(PrintingPermissionLevel printingLevel);
    public PrintingPermissionLevel get_Level();
    public void set_Level(PrintingPermissionLevel value);
    public sealed virtual bool IsUnrestricted();
    public virtual bool IsSubsetOf(IPermission target);
    public virtual IPermission Intersect(IPermission target);
    public virtual IPermission Union(IPermission target);
    public virtual IPermission Copy();
    public virtual SecurityElement ToXml();
    public virtual void FromXml(SecurityElement esd);
}
[AttributeUsageAttribute("32767")]
public class System.Drawing.Printing.PrintingPermissionAttribute : CodeAccessSecurityAttribute {
    public PrintingPermissionLevel Level { get; public set; }
    public PrintingPermissionAttribute(SecurityAction action);
    public PrintingPermissionLevel get_Level();
    public void set_Level(PrintingPermissionLevel value);
    public virtual IPermission CreatePermission();
}
public enum System.Drawing.Printing.PrintingPermissionLevel : Enum {
    public int value__;
    public static PrintingPermissionLevel NoPrinting;
    public static PrintingPermissionLevel SafePrinting;
    public static PrintingPermissionLevel DefaultPrinting;
    public static PrintingPermissionLevel AllPrinting;
}
public class System.Drawing.Printing.PrintPageEventArgs : EventArgs {
    public bool Cancel { get; public set; }
    public Graphics Graphics { get; }
    public bool HasMorePages { get; public set; }
    public Rectangle MarginBounds { get; }
    public Rectangle PageBounds { get; }
    public PageSettings PageSettings { get; }
    public PrintPageEventArgs(Graphics graphics, Rectangle marginBounds, Rectangle pageBounds, PageSettings pageSettings);
    public bool get_Cancel();
    public void set_Cancel(bool value);
    public Graphics get_Graphics();
    public bool get_HasMorePages();
    public void set_HasMorePages(bool value);
    public Rectangle get_MarginBounds();
    public Rectangle get_PageBounds();
    public PageSettings get_PageSettings();
}
public class System.Drawing.Printing.PrintPageEventHandler : MulticastDelegate {
    public PrintPageEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, PrintPageEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, PrintPageEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum System.Drawing.Printing.PrintRange : Enum {
    public int value__;
    public static PrintRange AllPages;
    public static PrintRange Selection;
    public static PrintRange SomePages;
    public static PrintRange CurrentPage;
}
public class System.Drawing.Printing.QueryPageSettingsEventArgs : PrintEventArgs {
    public PageSettings PageSettings { get; public set; }
    public QueryPageSettingsEventArgs(PageSettings pageSettings);
    public PageSettings get_PageSettings();
    public void set_PageSettings(PageSettings value);
}
public class System.Drawing.Printing.QueryPageSettingsEventHandler : MulticastDelegate {
    public QueryPageSettingsEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, QueryPageSettingsEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, QueryPageSettingsEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Drawing.Printing.StandardPrintController : PrintController {
    public virtual void OnStartPrint(PrintDocument document, PrintEventArgs e);
    public virtual Graphics OnStartPage(PrintDocument document, PrintPageEventArgs e);
    public virtual void OnEndPage(PrintDocument document, PrintPageEventArgs e);
    public virtual void OnEndPrint(PrintDocument document, PrintEventArgs e);
}
[TypeConverterAttribute("System.Drawing.RectangleConverter")]
[ComVisibleAttribute("True")]
public class System.Drawing.Rectangle : ValueType {
    public static Rectangle Empty;
    private int x;
    private int y;
    private int width;
    private int height;
    [BrowsableAttribute("False")]
public Point Location { get; public set; }
    [BrowsableAttribute("False")]
public Size Size { get; public set; }
    public int X { get; public set; }
    public int Y { get; public set; }
    public int Width { get; public set; }
    public int Height { get; public set; }
    [BrowsableAttribute("False")]
public int Left { get; }
    [BrowsableAttribute("False")]
public int Top { get; }
    [BrowsableAttribute("False")]
public int Right { get; }
    [BrowsableAttribute("False")]
public int Bottom { get; }
    [BrowsableAttribute("False")]
public bool IsEmpty { get; }
    public Rectangle(int x, int y, int width, int height);
    public Rectangle(Point location, Size size);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public Point get_Location();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public void set_Location(Point value);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public Size get_Size();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public void set_Size(Size value);
    public int get_X();
    public void set_X(int value);
    public int get_Y();
    public void set_Y(int value);
    public int get_Width();
    public void set_Width(int value);
    public int get_Height();
    public void set_Height(int value);
    public int get_Left();
    public int get_Top();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public int get_Right();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public int get_Bottom();
    public bool get_IsEmpty();
    public static bool op_Equality(Rectangle left, Rectangle right);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static bool op_Inequality(Rectangle left, Rectangle right);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static Rectangle FromLTRB(int left, int top, int right, int bottom);
    public virtual bool Equals(object obj);
    public static Rectangle Ceiling(RectangleF value);
    public static Rectangle Truncate(RectangleF value);
    public static Rectangle Round(RectangleF value);
    public bool Contains(int x, int y);
    public bool Contains(Point pt);
    public bool Contains(Rectangle rect);
    public virtual int GetHashCode();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public void Inflate(int width, int height);
    public void Inflate(Size size);
    public static Rectangle Inflate(Rectangle rect, int x, int y);
    public void Intersect(Rectangle rect);
    public static Rectangle Intersect(Rectangle a, Rectangle b);
    public bool IntersectsWith(Rectangle rect);
    public static Rectangle Union(Rectangle a, Rectangle b);
    public void Offset(Point pos);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public void Offset(int x, int y);
    public virtual string ToString();
}
public class System.Drawing.RectangleConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
    public virtual object CreateInstance(ITypeDescriptorContext context, IDictionary propertyValues);
    public virtual bool GetCreateInstanceSupported(ITypeDescriptorContext context);
    public virtual PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes);
    public virtual bool GetPropertiesSupported(ITypeDescriptorContext context);
}
public class System.Drawing.RectangleF : ValueType {
    public static RectangleF Empty;
    private float x;
    private float y;
    private float width;
    private float height;
    [BrowsableAttribute("False")]
public PointF Location { get; public set; }
    [BrowsableAttribute("False")]
public SizeF Size { get; public set; }
    public float X { get; public set; }
    public float Y { get; public set; }
    public float Width { get; public set; }
    public float Height { get; public set; }
    [BrowsableAttribute("False")]
public float Left { get; }
    [BrowsableAttribute("False")]
public float Top { get; }
    [BrowsableAttribute("False")]
public float Right { get; }
    [BrowsableAttribute("False")]
public float Bottom { get; }
    [BrowsableAttribute("False")]
public bool IsEmpty { get; }
    public RectangleF(float x, float y, float width, float height);
    public RectangleF(PointF location, SizeF size);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public PointF get_Location();
    public void set_Location(PointF value);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public SizeF get_Size();
    public void set_Size(SizeF value);
    public float get_X();
    public void set_X(float value);
    public float get_Y();
    public void set_Y(float value);
    public float get_Width();
    public void set_Width(float value);
    public float get_Height();
    public void set_Height(float value);
    public float get_Left();
    public float get_Top();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public float get_Right();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public float get_Bottom();
    public bool get_IsEmpty();
    public static RectangleF op_Implicit(Rectangle r);
    public static bool op_Equality(RectangleF left, RectangleF right);
    public static bool op_Inequality(RectangleF left, RectangleF right);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static RectangleF FromLTRB(float left, float top, float right, float bottom);
    public virtual bool Equals(object obj);
    public bool Contains(float x, float y);
    public bool Contains(PointF pt);
    public bool Contains(RectangleF rect);
    public virtual int GetHashCode();
    public void Inflate(float x, float y);
    public void Inflate(SizeF size);
    public static RectangleF Inflate(RectangleF rect, float x, float y);
    public void Intersect(RectangleF rect);
    public static RectangleF Intersect(RectangleF a, RectangleF b);
    public bool IntersectsWith(RectangleF rect);
    public static RectangleF Union(RectangleF a, RectangleF b);
    public void Offset(PointF pos);
    public void Offset(float x, float y);
    public virtual string ToString();
}
public class System.Drawing.Region : MarshalByRefObject {
    public Region(RectangleF rect);
    public Region(Rectangle rect);
    public Region(GraphicsPath path);
    public Region(RegionData rgnData);
    protected virtual override void Finalize();
    public static Region FromHrgn(IntPtr hrgn);
    public Region Clone();
    public sealed virtual void Dispose();
    public void MakeInfinite();
    public void MakeEmpty();
    public void Intersect(RectangleF rect);
    public void Intersect(Rectangle rect);
    public void Intersect(GraphicsPath path);
    public void Intersect(Region region);
    public void ReleaseHrgn(IntPtr regionHandle);
    public void Union(RectangleF rect);
    public void Union(Rectangle rect);
    public void Union(GraphicsPath path);
    public void Union(Region region);
    public void Xor(RectangleF rect);
    public void Xor(Rectangle rect);
    public void Xor(GraphicsPath path);
    public void Xor(Region region);
    public void Exclude(RectangleF rect);
    public void Exclude(Rectangle rect);
    public void Exclude(GraphicsPath path);
    public void Exclude(Region region);
    public void Complement(RectangleF rect);
    public void Complement(Rectangle rect);
    public void Complement(GraphicsPath path);
    public void Complement(Region region);
    public void Translate(float dx, float dy);
    public void Translate(int dx, int dy);
    public void Transform(Matrix matrix);
    public RectangleF GetBounds(Graphics g);
    public IntPtr GetHrgn(Graphics g);
    public bool IsEmpty(Graphics g);
    public bool IsInfinite(Graphics g);
    public bool Equals(Region region, Graphics g);
    public RegionData GetRegionData();
    public bool IsVisible(float x, float y);
    public bool IsVisible(PointF point);
    public bool IsVisible(float x, float y, Graphics g);
    public bool IsVisible(PointF point, Graphics g);
    public bool IsVisible(float x, float y, float width, float height);
    public bool IsVisible(RectangleF rect);
    public bool IsVisible(float x, float y, float width, float height, Graphics g);
    public bool IsVisible(RectangleF rect, Graphics g);
    public bool IsVisible(int x, int y, Graphics g);
    public bool IsVisible(Point point);
    public bool IsVisible(Point point, Graphics g);
    public bool IsVisible(int x, int y, int width, int height);
    public bool IsVisible(Rectangle rect);
    public bool IsVisible(int x, int y, int width, int height, Graphics g);
    public bool IsVisible(Rectangle rect, Graphics g);
    public RectangleF[] GetRegionScans(Matrix matrix);
}
public enum System.Drawing.RotateFlipType : Enum {
    public int value__;
    public static RotateFlipType Rotate180FlipXY;
    public static RotateFlipType RotateNoneFlipNone;
    public static RotateFlipType Rotate270FlipXY;
    public static RotateFlipType Rotate90FlipNone;
    public static RotateFlipType Rotate180FlipNone;
    public static RotateFlipType RotateNoneFlipXY;
    public static RotateFlipType Rotate270FlipNone;
    public static RotateFlipType Rotate90FlipXY;
    public static RotateFlipType Rotate180FlipY;
    public static RotateFlipType RotateNoneFlipX;
    public static RotateFlipType Rotate270FlipY;
    public static RotateFlipType Rotate90FlipX;
    public static RotateFlipType Rotate180FlipX;
    public static RotateFlipType RotateNoneFlipY;
    public static RotateFlipType Rotate270FlipX;
    public static RotateFlipType Rotate90FlipY;
}
[ComVisibleAttribute("True")]
public class System.Drawing.Size : ValueType {
    private int width;
    private int height;
    public static Size Empty;
    [BrowsableAttribute("False")]
public bool IsEmpty { get; }
    public int Width { get; public set; }
    public int Height { get; public set; }
    public Size(Point pt);
    public Size(int width, int height);
    public static Size Ceiling(SizeF value);
    public static Size Round(SizeF value);
    public static Size Truncate(SizeF value);
    public static Size op_Addition(Size sz1, Size sz2);
    public static bool op_Equality(Size sz1, Size sz2);
    public static bool op_Inequality(Size sz1, Size sz2);
    public static Size op_Subtraction(Size sz1, Size sz2);
    public static Point op_Explicit(Size size);
    public static SizeF op_Implicit(Size p);
    public bool get_IsEmpty();
    public int get_Width();
    public void set_Width(int value);
    public int get_Height();
    public void set_Height(int value);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static Size Add(Size sz1, Size sz2);
    public static Size Subtract(Size sz1, Size sz2);
}
public class System.Drawing.SizeConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
    public virtual object CreateInstance(ITypeDescriptorContext context, IDictionary propertyValues);
    public virtual bool GetCreateInstanceSupported(ITypeDescriptorContext context);
    public virtual PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes);
    public virtual bool GetPropertiesSupported(ITypeDescriptorContext context);
}
[ComVisibleAttribute("True")]
[TypeConverterAttribute("System.Drawing.SizeFConverter")]
public class System.Drawing.SizeF : ValueType {
    public static SizeF Empty;
    private float width;
    private float height;
    [BrowsableAttribute("False")]
public bool IsEmpty { get; }
    public float Width { get; public set; }
    public float Height { get; public set; }
    public SizeF(SizeF size);
    public SizeF(PointF pt);
    public SizeF(float width, float height);
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public bool get_IsEmpty();
    public float get_Width();
    public void set_Width(float value);
    public float get_Height();
    public void set_Height(float value);
    public static PointF op_Explicit(SizeF size);
    public static SizeF op_Addition(SizeF sz1, SizeF sz2);
    public static SizeF op_Subtraction(SizeF sz1, SizeF sz2);
    public static bool op_Equality(SizeF sz1, SizeF sz2);
    public static bool op_Inequality(SizeF sz1, SizeF sz2);
    public static SizeF Add(SizeF sz1, SizeF sz2);
    public static SizeF Subtract(SizeF sz1, SizeF sz2);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public PointF ToPointF();
    public Size ToSize();
    public virtual string ToString();
}
public class System.Drawing.SizeFConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
    public virtual object CreateInstance(ITypeDescriptorContext context, IDictionary propertyValues);
    public virtual bool GetCreateInstanceSupported(ITypeDescriptorContext context);
    public virtual PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes);
    public virtual bool GetPropertiesSupported(ITypeDescriptorContext context);
}
public class System.Drawing.SolidBrush : Brush {
    public Color Color { get; public set; }
    public SolidBrush(Color color);
    public Color get_Color();
    public void set_Color(Color value);
    public virtual object Clone();
    protected virtual void Dispose(bool disposing);
}
[AttributeUsageAttribute("32767")]
internal class System.Drawing.SRDescriptionAttribute : DescriptionAttribute {
    public string Description { get; }
    public SRDescriptionAttribute(string description);
    public virtual string get_Description();
}
public enum System.Drawing.StringAlignment : Enum {
    public int value__;
    public static StringAlignment Near;
    public static StringAlignment Center;
    public static StringAlignment Far;
}
public enum System.Drawing.StringDigitSubstitute : Enum {
    public int value__;
    public static StringDigitSubstitute User;
    public static StringDigitSubstitute None;
    public static StringDigitSubstitute National;
    public static StringDigitSubstitute Traditional;
}
public class System.Drawing.StringFormat : MarshalByRefObject {
    public StringFormatFlags FormatFlags { get; public set; }
    public StringAlignment Alignment { get; public set; }
    public StringAlignment LineAlignment { get; public set; }
    public HotkeyPrefix HotkeyPrefix { get; public set; }
    public StringTrimming Trimming { get; public set; }
    public static StringFormat GenericDefault { get; }
    public static StringFormat GenericTypographic { get; }
    public StringDigitSubstitute DigitSubstitutionMethod { get; }
    public int DigitSubstitutionLanguage { get; }
    public StringFormat(StringFormatFlags options);
    public StringFormat(StringFormatFlags options, int language);
    public StringFormat(StringFormat format);
    public StringFormatFlags get_FormatFlags();
    public void set_FormatFlags(StringFormatFlags value);
    public StringAlignment get_Alignment();
    public void set_Alignment(StringAlignment value);
    public StringAlignment get_LineAlignment();
    public void set_LineAlignment(StringAlignment value);
    public HotkeyPrefix get_HotkeyPrefix();
    public void set_HotkeyPrefix(HotkeyPrefix value);
    public StringTrimming get_Trimming();
    public void set_Trimming(StringTrimming value);
    public static StringFormat get_GenericDefault();
    public static StringFormat get_GenericTypographic();
    public StringDigitSubstitute get_DigitSubstitutionMethod();
    public int get_DigitSubstitutionLanguage();
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    public sealed virtual object Clone();
    public void SetMeasurableCharacterRanges(CharacterRange[] ranges);
    public void SetTabStops(float firstTabOffset, Single[] tabStops);
    public Single[] GetTabStops(Single& firstTabOffset);
    public void SetDigitSubstitution(int language, StringDigitSubstitute substitute);
    public virtual string ToString();
}
[FlagsAttribute]
public enum System.Drawing.StringFormatFlags : Enum {
    public int value__;
    public static StringFormatFlags DirectionRightToLeft;
    public static StringFormatFlags DirectionVertical;
    public static StringFormatFlags FitBlackBox;
    public static StringFormatFlags DisplayFormatControl;
    public static StringFormatFlags NoFontFallback;
    public static StringFormatFlags MeasureTrailingSpaces;
    public static StringFormatFlags NoWrap;
    public static StringFormatFlags LineLimit;
    public static StringFormatFlags NoClip;
}
public enum System.Drawing.StringTrimming : Enum {
    public int value__;
    public static StringTrimming None;
    public static StringTrimming Character;
    public static StringTrimming Word;
    public static StringTrimming EllipsisCharacter;
    public static StringTrimming EllipsisWord;
    public static StringTrimming EllipsisPath;
}
public enum System.Drawing.StringUnit : Enum {
    public int value__;
    public static StringUnit World;
    public static StringUnit Display;
    public static StringUnit Pixel;
    public static StringUnit Point;
    public static StringUnit Inch;
    public static StringUnit Document;
    public static StringUnit Millimeter;
    public static StringUnit Em;
}
public class System.Drawing.SystemBrushes : object {
    public static Brush ActiveBorder { get; }
    public static Brush ActiveCaption { get; }
    public static Brush ActiveCaptionText { get; }
    public static Brush AppWorkspace { get; }
    public static Brush ButtonFace { get; }
    public static Brush ButtonHighlight { get; }
    public static Brush ButtonShadow { get; }
    public static Brush Control { get; }
    public static Brush ControlLightLight { get; }
    public static Brush ControlLight { get; }
    public static Brush ControlDark { get; }
    public static Brush ControlDarkDark { get; }
    public static Brush ControlText { get; }
    public static Brush Desktop { get; }
    public static Brush GradientActiveCaption { get; }
    public static Brush GradientInactiveCaption { get; }
    public static Brush GrayText { get; }
    public static Brush Highlight { get; }
    public static Brush HighlightText { get; }
    public static Brush HotTrack { get; }
    public static Brush InactiveCaption { get; }
    public static Brush InactiveBorder { get; }
    public static Brush InactiveCaptionText { get; }
    public static Brush Info { get; }
    public static Brush InfoText { get; }
    public static Brush Menu { get; }
    public static Brush MenuBar { get; }
    public static Brush MenuHighlight { get; }
    public static Brush MenuText { get; }
    public static Brush ScrollBar { get; }
    public static Brush Window { get; }
    public static Brush WindowFrame { get; }
    public static Brush WindowText { get; }
    public static Brush get_ActiveBorder();
    public static Brush get_ActiveCaption();
    public static Brush get_ActiveCaptionText();
    public static Brush get_AppWorkspace();
    public static Brush get_ButtonFace();
    public static Brush get_ButtonHighlight();
    public static Brush get_ButtonShadow();
    public static Brush get_Control();
    public static Brush get_ControlLightLight();
    public static Brush get_ControlLight();
    public static Brush get_ControlDark();
    public static Brush get_ControlDarkDark();
    public static Brush get_ControlText();
    public static Brush get_Desktop();
    public static Brush get_GradientActiveCaption();
    public static Brush get_GradientInactiveCaption();
    public static Brush get_GrayText();
    public static Brush get_Highlight();
    public static Brush get_HighlightText();
    public static Brush get_HotTrack();
    public static Brush get_InactiveCaption();
    public static Brush get_InactiveBorder();
    public static Brush get_InactiveCaptionText();
    public static Brush get_Info();
    public static Brush get_InfoText();
    public static Brush get_Menu();
    public static Brush get_MenuBar();
    public static Brush get_MenuHighlight();
    public static Brush get_MenuText();
    public static Brush get_ScrollBar();
    public static Brush get_Window();
    public static Brush get_WindowFrame();
    public static Brush get_WindowText();
    public static Brush FromSystemColor(Color c);
}
public class System.Drawing.SystemColors : object {
    public static Color ActiveBorder { get; }
    public static Color ActiveCaption { get; }
    public static Color ActiveCaptionText { get; }
    public static Color AppWorkspace { get; }
    public static Color ButtonFace { get; }
    public static Color ButtonHighlight { get; }
    public static Color ButtonShadow { get; }
    public static Color Control { get; }
    public static Color ControlDark { get; }
    public static Color ControlDarkDark { get; }
    public static Color ControlLight { get; }
    public static Color ControlLightLight { get; }
    public static Color ControlText { get; }
    public static Color Desktop { get; }
    public static Color GradientActiveCaption { get; }
    public static Color GradientInactiveCaption { get; }
    public static Color GrayText { get; }
    public static Color Highlight { get; }
    public static Color HighlightText { get; }
    public static Color HotTrack { get; }
    public static Color InactiveBorder { get; }
    public static Color InactiveCaption { get; }
    public static Color InactiveCaptionText { get; }
    public static Color Info { get; }
    public static Color InfoText { get; }
    public static Color Menu { get; }
    public static Color MenuBar { get; }
    public static Color MenuHighlight { get; }
    public static Color MenuText { get; }
    public static Color ScrollBar { get; }
    public static Color Window { get; }
    public static Color WindowFrame { get; }
    public static Color WindowText { get; }
    public static Color get_ActiveBorder();
    public static Color get_ActiveCaption();
    public static Color get_ActiveCaptionText();
    public static Color get_AppWorkspace();
    public static Color get_ButtonFace();
    public static Color get_ButtonHighlight();
    public static Color get_ButtonShadow();
    [TargetedPatchingOptOutAttribute("Performance critical to inline across NGen image boundaries")]
public static Color get_Control();
    public static Color get_ControlDark();
    public static Color get_ControlDarkDark();
    public static Color get_ControlLight();
    public static Color get_ControlLightLight();
    public static Color get_ControlText();
    public static Color get_Desktop();
    public static Color get_GradientActiveCaption();
    public static Color get_GradientInactiveCaption();
    public static Color get_GrayText();
    public static Color get_Highlight();
    public static Color get_HighlightText();
    public static Color get_HotTrack();
    public static Color get_InactiveBorder();
    public static Color get_InactiveCaption();
    public static Color get_InactiveCaptionText();
    public static Color get_Info();
    public static Color get_InfoText();
    public static Color get_Menu();
    public static Color get_MenuBar();
    public static Color get_MenuHighlight();
    public static Color get_MenuText();
    public static Color get_ScrollBar();
    public static Color get_Window();
    public static Color get_WindowFrame();
    public static Color get_WindowText();
}
public class System.Drawing.SystemFonts : object {
    public static Font CaptionFont { get; }
    public static Font SmallCaptionFont { get; }
    public static Font MenuFont { get; }
    public static Font StatusFont { get; }
    public static Font MessageBoxFont { get; }
    public static Font IconTitleFont { get; }
    public static Font DefaultFont { get; }
    public static Font DialogFont { get; }
    public static Font get_CaptionFont();
    public static Font get_SmallCaptionFont();
    public static Font get_MenuFont();
    public static Font get_StatusFont();
    public static Font get_MessageBoxFont();
    public static Font get_IconTitleFont();
    public static Font get_DefaultFont();
    public static Font get_DialogFont();
    public static Font GetFontByName(string systemFontName);
}
public class System.Drawing.SystemIcons : object {
    public static Icon Application { get; }
    public static Icon Asterisk { get; }
    public static Icon Error { get; }
    public static Icon Exclamation { get; }
    public static Icon Hand { get; }
    public static Icon Information { get; }
    public static Icon Question { get; }
    public static Icon Warning { get; }
    public static Icon WinLogo { get; }
    public static Icon Shield { get; }
    public static Icon get_Application();
    public static Icon get_Asterisk();
    public static Icon get_Error();
    public static Icon get_Exclamation();
    public static Icon get_Hand();
    public static Icon get_Information();
    public static Icon get_Question();
    public static Icon get_Warning();
    public static Icon get_WinLogo();
    public static Icon get_Shield();
}
public class System.Drawing.SystemPens : object {
    public static Pen ActiveBorder { get; }
    public static Pen ActiveCaption { get; }
    public static Pen ActiveCaptionText { get; }
    public static Pen AppWorkspace { get; }
    public static Pen ButtonFace { get; }
    public static Pen ButtonHighlight { get; }
    public static Pen ButtonShadow { get; }
    public static Pen Control { get; }
    public static Pen ControlText { get; }
    public static Pen ControlDark { get; }
    public static Pen ControlDarkDark { get; }
    public static Pen ControlLight { get; }
    public static Pen ControlLightLight { get; }
    public static Pen Desktop { get; }
    public static Pen GradientActiveCaption { get; }
    public static Pen GradientInactiveCaption { get; }
    public static Pen GrayText { get; }
    public static Pen Highlight { get; }
    public static Pen HighlightText { get; }
    public static Pen HotTrack { get; }
    public static Pen InactiveBorder { get; }
    public static Pen InactiveCaption { get; }
    public static Pen InactiveCaptionText { get; }
    public static Pen Info { get; }
    public static Pen InfoText { get; }
    public static Pen Menu { get; }
    public static Pen MenuBar { get; }
    public static Pen MenuHighlight { get; }
    public static Pen MenuText { get; }
    public static Pen ScrollBar { get; }
    public static Pen Window { get; }
    public static Pen WindowFrame { get; }
    public static Pen WindowText { get; }
    public static Pen get_ActiveBorder();
    public static Pen get_ActiveCaption();
    public static Pen get_ActiveCaptionText();
    public static Pen get_AppWorkspace();
    public static Pen get_ButtonFace();
    public static Pen get_ButtonHighlight();
    public static Pen get_ButtonShadow();
    public static Pen get_Control();
    public static Pen get_ControlText();
    public static Pen get_ControlDark();
    public static Pen get_ControlDarkDark();
    public static Pen get_ControlLight();
    public static Pen get_ControlLightLight();
    public static Pen get_Desktop();
    public static Pen get_GradientActiveCaption();
    public static Pen get_GradientInactiveCaption();
    public static Pen get_GrayText();
    public static Pen get_Highlight();
    public static Pen get_HighlightText();
    public static Pen get_HotTrack();
    public static Pen get_InactiveBorder();
    public static Pen get_InactiveCaption();
    public static Pen get_InactiveCaptionText();
    public static Pen get_Info();
    public static Pen get_InfoText();
    public static Pen get_Menu();
    public static Pen get_MenuBar();
    public static Pen get_MenuHighlight();
    public static Pen get_MenuText();
    public static Pen get_ScrollBar();
    public static Pen get_Window();
    public static Pen get_WindowFrame();
    public static Pen get_WindowText();
    public static Pen FromSystemColor(Color c);
}
public abstract class System.Drawing.Text.FontCollection : object {
    public FontFamily[] Families { get; }
    public FontFamily[] get_Families();
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
public enum System.Drawing.Text.GenericFontFamilies : Enum {
    public int value__;
    public static GenericFontFamilies Serif;
    public static GenericFontFamilies SansSerif;
    public static GenericFontFamilies Monospace;
}
public enum System.Drawing.Text.HotkeyPrefix : Enum {
    public int value__;
    public static HotkeyPrefix None;
    public static HotkeyPrefix Show;
    public static HotkeyPrefix Hide;
}
public class System.Drawing.Text.InstalledFontCollection : FontCollection {
}
public class System.Drawing.Text.PrivateFontCollection : FontCollection {
    protected virtual void Dispose(bool disposing);
    public void AddFontFile(string filename);
    public void AddMemoryFont(IntPtr memory, int length);
}
public enum System.Drawing.Text.TextRenderingHint : Enum {
    public int value__;
    public static TextRenderingHint SystemDefault;
    public static TextRenderingHint SingleBitPerPixelGridFit;
    public static TextRenderingHint SingleBitPerPixel;
    public static TextRenderingHint AntiAliasGridFit;
    public static TextRenderingHint AntiAlias;
    public static TextRenderingHint ClearTypeGridFit;
}
public class System.Drawing.TextureBrush : Brush {
    public Matrix Transform { get; public set; }
    public WrapMode WrapMode { get; public set; }
    public Image Image { get; }
    public TextureBrush(Image bitmap);
    public TextureBrush(Image image, WrapMode wrapMode);
    public TextureBrush(Image image, WrapMode wrapMode, RectangleF dstRect);
    public TextureBrush(Image image, WrapMode wrapMode, Rectangle dstRect);
    public TextureBrush(Image image, RectangleF dstRect);
    public TextureBrush(Image image, RectangleF dstRect, ImageAttributes imageAttr);
    public TextureBrush(Image image, Rectangle dstRect);
    public TextureBrush(Image image, Rectangle dstRect, ImageAttributes imageAttr);
    public Matrix get_Transform();
    public void set_Transform(Matrix value);
    public WrapMode get_WrapMode();
    public void set_WrapMode(WrapMode value);
    public Image get_Image();
    public virtual object Clone();
    public void ResetTransform();
    public void MultiplyTransform(Matrix matrix);
    public void MultiplyTransform(Matrix matrix, MatrixOrder order);
    public void TranslateTransform(float dx, float dy);
    public void TranslateTransform(float dx, float dy, MatrixOrder order);
    public void ScaleTransform(float sx, float sy);
    public void ScaleTransform(float sx, float sy, MatrixOrder order);
    public void RotateTransform(float angle);
    public void RotateTransform(float angle, MatrixOrder order);
}
[AttributeUsageAttribute("4")]
public class System.Drawing.ToolboxBitmapAttribute : Attribute {
    public static ToolboxBitmapAttribute Default;
    public ToolboxBitmapAttribute(string imageFile);
    public ToolboxBitmapAttribute(Type t);
    public ToolboxBitmapAttribute(Type t, string name);
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
    public Image GetImage(object component);
    public Image GetImage(object component, bool large);
    public Image GetImage(Type type);
    public Image GetImage(Type type, bool large);
    public Image GetImage(Type type, string imgName, bool large);
    public static Image GetImageFromResource(Type t, string imageName, bool large);
}
internal class System.JetBrainsMockNotImplementedException : NotImplementedException {
    private Guid _guid;
    public string Message { get; }
    public JetBrainsMockNotImplementedException(Guid guid);
    public virtual string get_Message();
}
