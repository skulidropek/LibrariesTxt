public class Appccelerate.StateMachine.ActiveStateMachine`2 : object {
    private StateMachine`2<TState, TEvent> stateMachine;
    private LinkedList`1<EventInformation`1<TEvent>> queue;
    private bool initialized;
    private bool pendingInitialization;
    private Task worker;
    private CancellationTokenSource stopToken;
    public bool IsRunning { get; }
    public ActiveStateMachine`2(string name);
    public ActiveStateMachine`2(string name, IFactory`2<TState, TEvent> factory);
    public sealed virtual void add_TransitionDeclined(EventHandler`1<TransitionEventArgs`2<TState, TEvent>> value);
    public sealed virtual void remove_TransitionDeclined(EventHandler`1<TransitionEventArgs`2<TState, TEvent>> value);
    public sealed virtual void add_TransitionExceptionThrown(EventHandler`1<TransitionExceptionEventArgs`2<TState, TEvent>> value);
    public sealed virtual void remove_TransitionExceptionThrown(EventHandler`1<TransitionExceptionEventArgs`2<TState, TEvent>> value);
    public sealed virtual void add_TransitionBegin(EventHandler`1<TransitionEventArgs`2<TState, TEvent>> value);
    public sealed virtual void remove_TransitionBegin(EventHandler`1<TransitionEventArgs`2<TState, TEvent>> value);
    public sealed virtual void add_TransitionCompleted(EventHandler`1<TransitionCompletedEventArgs`2<TState, TEvent>> value);
    public sealed virtual void remove_TransitionCompleted(EventHandler`1<TransitionCompletedEventArgs`2<TState, TEvent>> value);
    public sealed virtual bool get_IsRunning();
    public sealed virtual IEntryActionSyntax`2<TState, TEvent> In(TState state);
    public sealed virtual IHierarchySyntax`1<TState> DefineHierarchyOn(TState superStateId);
    public sealed virtual void Fire(TEvent eventId);
    public sealed virtual void Fire(TEvent eventId, object eventArgument);
    public sealed virtual void FirePriority(TEvent eventId);
    public sealed virtual void FirePriority(TEvent eventId, object eventArgument);
    public sealed virtual void Initialize(TState initialState);
    public sealed virtual void Save(IStateMachineSaver`1<TState> stateMachineSaver);
    public sealed virtual void Load(IStateMachineLoader`1<TState> stateMachineLoader);
    public sealed virtual void Start();
    public sealed virtual void Stop();
    public sealed virtual void AddExtension(IExtension`2<TState, TEvent> extension);
    public sealed virtual void ClearExtensions();
    public sealed virtual void Report(IStateMachineReport`2<TState, TEvent> reportGenerator);
    public virtual string ToString();
    private void ProcessEventQueue(CancellationToken cancellationToken);
    private void InitializeStateMachineIfInitializationIsPending();
    private void CheckThatNotAlreadyInitialized();
    private void CheckThatStateMachineIsInitialized();
    [CompilerGeneratedAttribute]
private void <Start>b__32_0();
    [CompilerGeneratedAttribute]
private void <Start>b__32_1(IExtension`2<TState, TEvent> extension);
    [CompilerGeneratedAttribute]
private void <Stop>b__33_0(IExtension`2<TState, TEvent> extension);
}
public class Appccelerate.StateMachine.EventInformation`1 : object {
    [CompilerGeneratedAttribute]
private TEvent <EventId>k__BackingField;
    [CompilerGeneratedAttribute]
private object <EventArgument>k__BackingField;
    public TEvent EventId { get; private set; }
    public object EventArgument { get; private set; }
    public EventInformation`1(TEvent eventId, object eventArgument);
    [CompilerGeneratedAttribute]
public TEvent get_EventId();
    [CompilerGeneratedAttribute]
private void set_EventId(TEvent value);
    [CompilerGeneratedAttribute]
public object get_EventArgument();
    [CompilerGeneratedAttribute]
private void set_EventArgument(object value);
}
public class Appccelerate.StateMachine.Extensions.ExtensionBase`2 : object {
    public virtual void StartedStateMachine(IStateMachineInformation`2<TState, TEvent> stateMachine);
    public virtual void StoppedStateMachine(IStateMachineInformation`2<TState, TEvent> stateMachine);
    public virtual void EventQueued(IStateMachineInformation`2<TState, TEvent> stateMachine, TEvent eventId, object eventArgument);
    public virtual void EventQueuedWithPriority(IStateMachineInformation`2<TState, TEvent> stateMachine, TEvent eventId, object eventArgument);
    public virtual void SwitchedState(IStateMachineInformation`2<TState, TEvent> stateMachine, IState`2<TState, TEvent> oldState, IState`2<TState, TEvent> newState);
    public virtual void InitializingStateMachine(IStateMachineInformation`2<TState, TEvent> stateMachine, TState& initialState);
    public virtual void InitializedStateMachine(IStateMachineInformation`2<TState, TEvent> stateMachine, TState initialState);
    public virtual void EnteringInitialState(IStateMachineInformation`2<TState, TEvent> stateMachine, TState state);
    public virtual void EnteredInitialState(IStateMachineInformation`2<TState, TEvent> stateMachine, TState state, ITransitionContext`2<TState, TEvent> context);
    public virtual void FiringEvent(IStateMachineInformation`2<TState, TEvent> stateMachine, TEvent& eventId, Object& eventArgument);
    public virtual void FiredEvent(IStateMachineInformation`2<TState, TEvent> stateMachine, ITransitionContext`2<TState, TEvent> context);
    public virtual void HandlingEntryActionException(IStateMachineInformation`2<TState, TEvent> stateMachine, IState`2<TState, TEvent> state, ITransitionContext`2<TState, TEvent> context, Exception& exception);
    public virtual void HandledEntryActionException(IStateMachineInformation`2<TState, TEvent> stateMachine, IState`2<TState, TEvent> state, ITransitionContext`2<TState, TEvent> context, Exception exception);
    public virtual void HandlingExitActionException(IStateMachineInformation`2<TState, TEvent> stateMachine, IState`2<TState, TEvent> state, ITransitionContext`2<TState, TEvent> context, Exception& exception);
    public virtual void HandledExitActionException(IStateMachineInformation`2<TState, TEvent> stateMachine, IState`2<TState, TEvent> state, ITransitionContext`2<TState, TEvent> context, Exception exception);
    public virtual void HandlingGuardException(IStateMachineInformation`2<TState, TEvent> stateMachine, ITransition`2<TState, TEvent> transition, ITransitionContext`2<TState, TEvent> transitionContext, Exception& exception);
    public virtual void HandledGuardException(IStateMachineInformation`2<TState, TEvent> stateMachine, ITransition`2<TState, TEvent> transition, ITransitionContext`2<TState, TEvent> transitionContext, Exception exception);
    public virtual void HandlingTransitionException(IStateMachineInformation`2<TState, TEvent> stateMachine, ITransition`2<TState, TEvent> transition, ITransitionContext`2<TState, TEvent> context, Exception& exception);
    public virtual void HandledTransitionException(IStateMachineInformation`2<TState, TEvent> stateMachine, ITransition`2<TState, TEvent> transition, ITransitionContext`2<TState, TEvent> transitionContext, Exception exception);
    public virtual void SkippedTransition(IStateMachineInformation`2<TState, TEvent> stateMachineInformation, ITransition`2<TState, TEvent> transition, ITransitionContext`2<TState, TEvent> context);
    public virtual void ExecutingTransition(IStateMachineInformation`2<TState, TEvent> stateMachine, ITransition`2<TState, TEvent> transition, ITransitionContext`2<TState, TEvent> transitionContext);
    public virtual void ExecutedTransition(IStateMachineInformation`2<TState, TEvent> stateMachine, ITransition`2<TState, TEvent> transition, ITransitionContext`2<TState, TEvent> transitionContext);
}
[ExtensionAttribute]
internal static class Appccelerate.StateMachine.Guard : object {
    [DebuggerStepThroughAttribute]
public static void AgainstNullArgument(string parameterName, TArgument argument);
    [DebuggerStepThroughAttribute]
public static void AgainstNullArgumentIfNullable(string parameterName, TArgument argument);
    [DebuggerStepThroughAttribute]
public static void AgainstNullArgumentProperty(string parameterName, string propertyName, TProperty argumentProperty);
    [DebuggerStepThroughAttribute]
public static void AgainstNullArgumentPropertyIfNullable(string parameterName, string propertyName, TProperty argumentProperty);
    [ExtensionAttribute]
private static bool IsNullableType(Type type);
}
public enum Appccelerate.StateMachine.HistoryType : Enum {
    public int value__;
    public static HistoryType None;
    public static HistoryType Shallow;
    public static HistoryType Deep;
}
public interface Appccelerate.StateMachine.IStateMachine`2 {
    public bool IsRunning { get; }
    [CompilerGeneratedAttribute]
public abstract virtual void add_TransitionDeclined(EventHandler`1<TransitionEventArgs`2<TState, TEvent>> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_TransitionDeclined(EventHandler`1<TransitionEventArgs`2<TState, TEvent>> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_TransitionExceptionThrown(EventHandler`1<TransitionExceptionEventArgs`2<TState, TEvent>> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_TransitionExceptionThrown(EventHandler`1<TransitionExceptionEventArgs`2<TState, TEvent>> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_TransitionBegin(EventHandler`1<TransitionEventArgs`2<TState, TEvent>> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_TransitionBegin(EventHandler`1<TransitionEventArgs`2<TState, TEvent>> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_TransitionCompleted(EventHandler`1<TransitionCompletedEventArgs`2<TState, TEvent>> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_TransitionCompleted(EventHandler`1<TransitionCompletedEventArgs`2<TState, TEvent>> value);
    public abstract virtual bool get_IsRunning();
    public abstract virtual IEntryActionSyntax`2<TState, TEvent> In(TState state);
    public abstract virtual IHierarchySyntax`1<TState> DefineHierarchyOn(TState superStateId);
    public abstract virtual void Fire(TEvent eventId);
    public abstract virtual void Fire(TEvent eventId, object eventArgument);
    public abstract virtual void FirePriority(TEvent eventId);
    public abstract virtual void FirePriority(TEvent eventId, object eventArgument);
    public abstract virtual void Initialize(TState initialState);
    public abstract virtual void Start();
    public abstract virtual void Stop();
    public abstract virtual void AddExtension(IExtension`2<TState, TEvent> extension);
    public abstract virtual void ClearExtensions();
    public abstract virtual void Report(IStateMachineReport`2<TState, TEvent> reportGenerator);
    public abstract virtual void Save(IStateMachineSaver`1<TState> stateMachineSaver);
    public abstract virtual void Load(IStateMachineLoader`1<TState> stateMachineLoader);
}
public interface Appccelerate.StateMachine.IStateMachineInformation`2 {
    public string Name { get; }
    public TState CurrentStateId { get; }
    public abstract virtual string get_Name();
    public abstract virtual TState get_CurrentStateId();
}
[ExtensionAttribute]
internal static class Appccelerate.StateMachine.ListExtensionMethods : object {
    [ExtensionAttribute]
public static void ForEach(IList`1<T> list, Action`1<T> action);
}
public static class Appccelerate.StateMachine.Machine.ActionHolders.ActionHoldersExceptionMessages : object {
    public static string CannotCastArgumentToActionArgument(object argument, string action);
}
public class Appccelerate.StateMachine.Machine.ActionHolders.ArgumentActionHolder`1 : object {
    private Action`1<T> action;
    public ArgumentActionHolder`1(Action`1<T> action);
    public sealed virtual void Execute(object argument);
    public sealed virtual string Describe();
}
public class Appccelerate.StateMachine.Machine.ActionHolders.ArgumentLessActionHolder : object {
    private Action action;
    public ArgumentLessActionHolder(Action action);
    public sealed virtual void Execute(object argument);
    public sealed virtual string Describe();
}
public interface Appccelerate.StateMachine.Machine.ActionHolders.IActionHolder {
    public abstract virtual void Execute(object argument);
    public abstract virtual string Describe();
}
public class Appccelerate.StateMachine.Machine.ActionHolders.ParametrizedActionHolder`1 : object {
    private Action`1<T> action;
    private T parameter;
    public ParametrizedActionHolder`1(Action`1<T> action, T parameter);
    public sealed virtual void Execute(object argument);
    public sealed virtual string Describe();
}
[DebuggerDisplayAttribute("State = {state} Event = {eventId} EventArguments = {eventArguments}")]
public class Appccelerate.StateMachine.Machine.Contexts.TransitionContext`2 : object {
    private IState`2<TState, TEvent> state;
    private Missable`1<TEvent> eventId;
    private object eventArgument;
    private List`1<Record<TState, TEvent>> records;
    [CompilerGeneratedAttribute]
private INotifier`2<TState, TEvent> <Notifier>k__BackingField;
    public IState`2<TState, TEvent> State { get; }
    public Missable`1<TEvent> EventId { get; }
    public object EventArgument { get; }
    private INotifier`2<TState, TEvent> Notifier { get; private set; }
    public TransitionContext`2(IState`2<TState, TEvent> state, Missable`1<TEvent> eventId, object eventArgument, INotifier`2<TState, TEvent> notifier);
    public sealed virtual IState`2<TState, TEvent> get_State();
    public sealed virtual Missable`1<TEvent> get_EventId();
    public sealed virtual object get_EventArgument();
    [CompilerGeneratedAttribute]
private INotifier`2<TState, TEvent> get_Notifier();
    [CompilerGeneratedAttribute]
private void set_Notifier(INotifier`2<TState, TEvent> value);
    public sealed virtual void OnExceptionThrown(Exception exception);
    public sealed virtual void OnTransitionBegin();
    public sealed virtual void AddRecord(TState stateId, RecordType recordType);
    public sealed virtual string GetRecords();
}
public class Appccelerate.StateMachine.Machine.Events.ContextEventArgs`2 : EventArgs {
    private ITransitionContext`2<TState, TEvent> context;
    protected ITransitionContext`2<TState, TEvent> Context { get; }
    protected ContextEventArgs`2(ITransitionContext`2<TState, TEvent> context);
    protected ITransitionContext`2<TState, TEvent> get_Context();
}
public interface Appccelerate.StateMachine.Machine.Events.IFactory`2 {
    public abstract virtual IState`2<TState, TEvent> CreateState(TState id);
    public abstract virtual ITransition`2<TState, TEvent> CreateTransition();
    public abstract virtual IActionHolder CreateActionHolder(Action action);
    public abstract virtual IActionHolder CreateActionHolder(Action`1<T> action);
    public abstract virtual IActionHolder CreateActionHolder(Action`1<T> action, T parameter);
    public abstract virtual IActionHolder CreateTransitionActionHolder(Action action);
    public abstract virtual IActionHolder CreateTransitionActionHolder(Action`1<T> action);
    public abstract virtual IGuardHolder CreateGuardHolder(Func`1<bool> guard);
    public abstract virtual IGuardHolder CreateGuardHolder(Func`2<T, bool> guard);
    public abstract virtual ITransitionContext`2<TState, TEvent> CreateTransitionContext(IState`2<TState, TEvent> state, Missable`1<TEvent> eventId, object eventArgument, INotifier`2<TState, TEvent> notifier);
    public abstract virtual StateMachineInitializer`2<TState, TEvent> CreateStateMachineInitializer(IState`2<TState, TEvent> initialState, ITransitionContext`2<TState, TEvent> context);
}
public class Appccelerate.StateMachine.Machine.Events.TransitionCompletedEventArgs`2 : TransitionEventArgs`2<TState, TEvent> {
    private TState newStateId;
    public TState NewStateId { get; }
    public TransitionCompletedEventArgs`2(TState newStateId, ITransitionContext`2<TState, TEvent> context);
    public TState get_NewStateId();
}
public class Appccelerate.StateMachine.Machine.Events.TransitionEventArgs`2 : ContextEventArgs`2<TState, TEvent> {
    public TState StateId { get; }
    public TEvent EventId { get; }
    public object EventArgument { get; }
    public TransitionEventArgs`2(ITransitionContext`2<TState, TEvent> context);
    public TState get_StateId();
    public TEvent get_EventId();
    public object get_EventArgument();
    public virtual string ToString();
}
public class Appccelerate.StateMachine.Machine.Events.TransitionExceptionEventArgs`2 : TransitionEventArgs`2<TState, TEvent> {
    private Exception exception;
    public Exception Exception { get; }
    public TransitionExceptionEventArgs`2(ITransitionContext`2<TState, TEvent> context, Exception exception);
    public Exception get_Exception();
}
public static class Appccelerate.StateMachine.Machine.ExceptionMessages : object {
    public static string ValueNotInitialized;
    public static string ValueAlreadyInitialized;
    public static string StateMachineIsAlreadyInitialized;
    public static string StateMachineNotInitialized;
    public static string StateMachineHasNotYetEnteredInitialState;
    public static string OnlyOneTransitionMayHaveNoGuard;
    public static string TransitionWithoutGuardHasToBeLast;
    public static string CannotSetALastActiveStateThatIsNotASubState;
    public static string StateCannotBeItsOwnSuperState(string state);
    public static string CannotSetStateAsASuperStateBecauseASuperStateIsAlreadySet(TState newSuperStateId, IState`2<TState, TEvent> stateAlreadyHavingASuperState);
    public static string TransitionDoesAlreadyExist(ITransition`2<TState, TEvent> transition, IState`2<TState, TEvent> state);
}
public class Appccelerate.StateMachine.Machine.GuardHolders.ArgumentGuardHolder`1 : object {
    private Func`2<T, bool> guard;
    public ArgumentGuardHolder`1(Func`2<T, bool> guard);
    public sealed virtual bool Execute(object argument);
    public sealed virtual string Describe();
}
public class Appccelerate.StateMachine.Machine.GuardHolders.ArgumentLessGuardHolder : object {
    private Func`1<bool> guard;
    public ArgumentLessGuardHolder(Func`1<bool> guard);
    public sealed virtual bool Execute(object argument);
    public sealed virtual string Describe();
}
public static class Appccelerate.StateMachine.Machine.GuardHolders.GuardHoldersExceptionMessages : object {
    public static string CannotCastArgumentToGuardArgument(object argument, string guard);
}
public interface Appccelerate.StateMachine.Machine.GuardHolders.IGuardHolder {
    public abstract virtual bool Execute(object argument);
    public abstract virtual string Describe();
}
public class Appccelerate.StateMachine.Machine.HierarchyBuilder`2 : object {
    private IStateDictionary`2<TState, TEvent> states;
    private IState`2<TState, TEvent> superState;
    public HierarchyBuilder`2(IStateDictionary`2<TState, TEvent> states, TState superStateId);
    public sealed virtual IInitialSubStateSyntax`1<TState> WithHistoryType(HistoryType historyType);
    public sealed virtual ISubStateSyntax`1<TState> WithInitialSubState(TState stateId);
    public sealed virtual ISubStateSyntax`1<TState> WithSubState(TState stateId);
    private void CheckThatStateHasNotAlreadyASuperState(IState`2<TState, TEvent> subState);
}
public interface Appccelerate.StateMachine.Machine.IExtension`2 {
    public abstract virtual void StartedStateMachine(IStateMachineInformation`2<TState, TEvent> stateMachine);
    public abstract virtual void StoppedStateMachine(IStateMachineInformation`2<TState, TEvent> stateMachine);
    public abstract virtual void EventQueued(IStateMachineInformation`2<TState, TEvent> stateMachine, TEvent eventId, object eventArgument);
    public abstract virtual void EventQueuedWithPriority(IStateMachineInformation`2<TState, TEvent> stateMachine, TEvent eventId, object eventArgument);
    public abstract virtual void SwitchedState(IStateMachineInformation`2<TState, TEvent> stateMachine, IState`2<TState, TEvent> oldState, IState`2<TState, TEvent> newState);
    public abstract virtual void InitializingStateMachine(IStateMachineInformation`2<TState, TEvent> stateMachine, TState& initialState);
    public abstract virtual void InitializedStateMachine(IStateMachineInformation`2<TState, TEvent> stateMachine, TState initialState);
    public abstract virtual void EnteringInitialState(IStateMachineInformation`2<TState, TEvent> stateMachine, TState state);
    public abstract virtual void EnteredInitialState(IStateMachineInformation`2<TState, TEvent> stateMachine, TState state, ITransitionContext`2<TState, TEvent> context);
    public abstract virtual void FiringEvent(IStateMachineInformation`2<TState, TEvent> stateMachine, TEvent& eventId, Object& eventArgument);
    public abstract virtual void FiredEvent(IStateMachineInformation`2<TState, TEvent> stateMachine, ITransitionContext`2<TState, TEvent> context);
    public abstract virtual void HandlingEntryActionException(IStateMachineInformation`2<TState, TEvent> stateMachine, IState`2<TState, TEvent> state, ITransitionContext`2<TState, TEvent> context, Exception& exception);
    public abstract virtual void HandledEntryActionException(IStateMachineInformation`2<TState, TEvent> stateMachine, IState`2<TState, TEvent> state, ITransitionContext`2<TState, TEvent> context, Exception exception);
    public abstract virtual void HandlingExitActionException(IStateMachineInformation`2<TState, TEvent> stateMachine, IState`2<TState, TEvent> state, ITransitionContext`2<TState, TEvent> context, Exception& exception);
    public abstract virtual void HandledExitActionException(IStateMachineInformation`2<TState, TEvent> stateMachine, IState`2<TState, TEvent> state, ITransitionContext`2<TState, TEvent> context, Exception exception);
    public abstract virtual void HandlingGuardException(IStateMachineInformation`2<TState, TEvent> stateMachine, ITransition`2<TState, TEvent> transition, ITransitionContext`2<TState, TEvent> transitionContext, Exception& exception);
    public abstract virtual void HandledGuardException(IStateMachineInformation`2<TState, TEvent> stateMachine, ITransition`2<TState, TEvent> transition, ITransitionContext`2<TState, TEvent> transitionContext, Exception exception);
    public abstract virtual void HandlingTransitionException(IStateMachineInformation`2<TState, TEvent> stateMachine, ITransition`2<TState, TEvent> transition, ITransitionContext`2<TState, TEvent> context, Exception& exception);
    public abstract virtual void HandledTransitionException(IStateMachineInformation`2<TState, TEvent> stateMachine, ITransition`2<TState, TEvent> transition, ITransitionContext`2<TState, TEvent> transitionContext, Exception exception);
    public abstract virtual void SkippedTransition(IStateMachineInformation`2<TState, TEvent> stateMachineInformation, ITransition`2<TState, TEvent> transition, ITransitionContext`2<TState, TEvent> context);
    public abstract virtual void ExecutingTransition(IStateMachineInformation`2<TState, TEvent> stateMachineInformation, ITransition`2<TState, TEvent> transition, ITransitionContext`2<TState, TEvent> context);
    public abstract virtual void ExecutedTransition(IStateMachineInformation`2<TState, TEvent> stateMachineInformation, ITransition`2<TState, TEvent> transition, ITransitionContext`2<TState, TEvent> context);
}
public interface Appccelerate.StateMachine.Machine.IExtensionHost`2 {
    public abstract virtual void ForEach(Action`1<IExtension`2<TState, TEvent>> action);
}
public class Appccelerate.StateMachine.Machine.Initializable`1 : object {
    private T value;
    [CompilerGeneratedAttribute]
private bool <IsInitialized>k__BackingField;
    public T Value { get; public set; }
    public bool IsInitialized { get; private set; }
    public T get_Value();
    public void set_Value(T value);
    [CompilerGeneratedAttribute]
public bool get_IsInitialized();
    [CompilerGeneratedAttribute]
private void set_IsInitialized(bool value);
    private void CheckInitialized();
    private void CheckNotAlreadyInitialized();
}
public interface Appccelerate.StateMachine.Machine.INotifier`2 {
    public abstract virtual void OnExceptionThrown(ITransitionContext`2<TState, TEvent> context, Exception exception);
    public abstract virtual void OnTransitionBegin(ITransitionContext`2<TState, TEvent> transitionContext);
}
public interface Appccelerate.StateMachine.Machine.IState`2 {
    public TState Id { get; }
    public IState`2<TState, TEvent> InitialState { get; public set; }
    public IState`2<TState, TEvent> SuperState { get; public set; }
    public ICollection`1<IState`2<TState, TEvent>> SubStates { get; }
    public ITransitionDictionary`2<TState, TEvent> Transitions { get; }
    public int Level { get; public set; }
    public IState`2<TState, TEvent> LastActiveState { get; public set; }
    public IList`1<IActionHolder> EntryActions { get; }
    public IList`1<IActionHolder> ExitActions { get; }
    public HistoryType HistoryType { get; public set; }
    public abstract virtual TState get_Id();
    public abstract virtual IState`2<TState, TEvent> get_InitialState();
    public abstract virtual void set_InitialState(IState`2<TState, TEvent> value);
    public abstract virtual IState`2<TState, TEvent> get_SuperState();
    public abstract virtual void set_SuperState(IState`2<TState, TEvent> value);
    public abstract virtual ICollection`1<IState`2<TState, TEvent>> get_SubStates();
    public abstract virtual ITransitionDictionary`2<TState, TEvent> get_Transitions();
    public abstract virtual int get_Level();
    public abstract virtual void set_Level(int value);
    public abstract virtual IState`2<TState, TEvent> get_LastActiveState();
    public abstract virtual void set_LastActiveState(IState`2<TState, TEvent> value);
    public abstract virtual IList`1<IActionHolder> get_EntryActions();
    public abstract virtual IList`1<IActionHolder> get_ExitActions();
    public abstract virtual HistoryType get_HistoryType();
    public abstract virtual void set_HistoryType(HistoryType value);
    public abstract virtual ITransitionResult`2<TState, TEvent> Fire(ITransitionContext`2<TState, TEvent> context);
    public abstract virtual void Entry(ITransitionContext`2<TState, TEvent> context);
    public abstract virtual void Exit(ITransitionContext`2<TState, TEvent> context);
    public abstract virtual IState`2<TState, TEvent> EnterByHistory(ITransitionContext`2<TState, TEvent> context);
    public abstract virtual IState`2<TState, TEvent> EnterShallow(ITransitionContext`2<TState, TEvent> context);
    public abstract virtual IState`2<TState, TEvent> EnterDeep(ITransitionContext`2<TState, TEvent> context);
    public abstract virtual string ToString();
}
[DefaultMemberAttribute("Item")]
public interface Appccelerate.StateMachine.Machine.IStateDictionary`2 {
    public IState`2<TState, TEvent> Item { get; }
    public abstract virtual IState`2<TState, TEvent> get_Item(TState stateId);
    public abstract virtual IEnumerable`1<IState`2<TState, TEvent>> GetStates();
}
public interface Appccelerate.StateMachine.Machine.IStateMachineReport`2 {
    public abstract virtual void Report(string name, IEnumerable`1<IState`2<TState, TEvent>> states, Initializable`1<TState> initialStateId);
}
public interface Appccelerate.StateMachine.Machine.ITransition`2 {
    public IState`2<TState, TEvent> Source { get; public set; }
    public IState`2<TState, TEvent> Target { get; public set; }
    public ICollection`1<IActionHolder> Actions { get; }
    public IGuardHolder Guard { get; public set; }
    public abstract virtual IState`2<TState, TEvent> get_Source();
    public abstract virtual void set_Source(IState`2<TState, TEvent> value);
    public abstract virtual IState`2<TState, TEvent> get_Target();
    public abstract virtual void set_Target(IState`2<TState, TEvent> value);
    public abstract virtual ICollection`1<IActionHolder> get_Actions();
    public abstract virtual IGuardHolder get_Guard();
    public abstract virtual void set_Guard(IGuardHolder value);
    public abstract virtual ITransitionResult`2<TState, TEvent> Fire(ITransitionContext`2<TState, TEvent> context);
}
public interface Appccelerate.StateMachine.Machine.ITransitionContext`2 {
    public IState`2<TState, TEvent> State { get; }
    public Missable`1<TEvent> EventId { get; }
    public object EventArgument { get; }
    public abstract virtual IState`2<TState, TEvent> get_State();
    public abstract virtual Missable`1<TEvent> get_EventId();
    public abstract virtual object get_EventArgument();
    public abstract virtual void AddRecord(TState stateId, RecordType recordType);
    public abstract virtual string GetRecords();
    public abstract virtual void OnExceptionThrown(Exception exception);
    public abstract virtual void OnTransitionBegin();
}
public interface Appccelerate.StateMachine.Machine.ITransitionDictionary`2 {
    public abstract virtual void Add(TEvent eventId, ITransition`2<TState, TEvent> transition);
    public abstract virtual IEnumerable`1<TransitionInfo`2<TState, TEvent>> GetTransitions();
}
public interface Appccelerate.StateMachine.Machine.ITransitionResult`2 {
    public bool Fired { get; }
    public IState`2<TState, TEvent> NewState { get; }
    public abstract virtual bool get_Fired();
    public abstract virtual IState`2<TState, TEvent> get_NewState();
}
public class Appccelerate.StateMachine.Machine.Missable`1 : object {
    private T value;
    [CompilerGeneratedAttribute]
private bool <IsMissing>k__BackingField;
    public bool IsMissing { get; private set; }
    public T Value { get; private set; }
    public Missable`1(T value);
    [CompilerGeneratedAttribute]
public bool get_IsMissing();
    [CompilerGeneratedAttribute]
private void set_IsMissing(bool value);
    public T get_Value();
    private void set_Value(T value);
}
public class Appccelerate.StateMachine.Machine.Missing : object {
    public static Missing Value;
}
public enum Appccelerate.StateMachine.Machine.RecordType : Enum {
    public int value__;
    public static RecordType Enter;
    public static RecordType Exit;
}
public class Appccelerate.StateMachine.Machine.StandardFactory`2 : object {
    private IStateMachineInformation`2<TState, TEvent> stateMachineInformation;
    private IExtensionHost`2<TState, TEvent> extensionHost;
    public StandardFactory`2(IStateMachineInformation`2<TState, TEvent> stateMachineInformation, IExtensionHost`2<TState, TEvent> extensionHost);
    public virtual IState`2<TState, TEvent> CreateState(TState id);
    public virtual ITransition`2<TState, TEvent> CreateTransition();
    public virtual IActionHolder CreateActionHolder(Action action);
    public virtual IActionHolder CreateActionHolder(Action`1<T> action);
    public virtual IActionHolder CreateActionHolder(Action`1<T> action, T parameter);
    public virtual IActionHolder CreateTransitionActionHolder(Action action);
    public virtual IActionHolder CreateTransitionActionHolder(Action`1<T> action);
    public virtual IGuardHolder CreateGuardHolder(Func`1<bool> guard);
    public virtual IGuardHolder CreateGuardHolder(Func`2<T, bool> guard);
    public virtual ITransitionContext`2<TState, TEvent> CreateTransitionContext(IState`2<TState, TEvent> state, Missable`1<TEvent> eventId, object eventArgument, INotifier`2<TState, TEvent> notifier);
    public virtual StateMachineInitializer`2<TState, TEvent> CreateStateMachineInitializer(IState`2<TState, TEvent> initialState, ITransitionContext`2<TState, TEvent> context);
}
public class Appccelerate.StateMachine.Machine.StateBuilder`2 : object {
    private IState`2<TState, TEvent> state;
    private IStateDictionary`2<TState, TEvent> stateDictionary;
    private IFactory`2<TState, TEvent> factory;
    private ITransition`2<TState, TEvent> currentTransition;
    private TEvent currentEventId;
    public StateBuilder`2(IState`2<TState, TEvent> state, IStateDictionary`2<TState, TEvent> stateDictionary, IFactory`2<TState, TEvent> factory);
    private sealed virtual override IEntryActionSyntax`2<TState, TEvent> Appccelerate.StateMachine.Syntax.IEntryActionSyntax<TState,TEvent>.ExecuteOnEntry(Action action);
    public sealed virtual IEntryActionSyntax`2<TState, TEvent> ExecuteOnEntry(Action`1<T> action);
    private sealed virtual override IEntryActionSyntax`2<TState, TEvent> Appccelerate.StateMachine.Syntax.IEntryActionSyntax<TState,TEvent>.ExecuteOnEntryParametrized(Action`1<T> action, T parameter);
    private sealed virtual override IExitActionSyntax`2<TState, TEvent> Appccelerate.StateMachine.Syntax.IExitActionSyntax<TState,TEvent>.ExecuteOnExit(Action action);
    public sealed virtual IExitActionSyntax`2<TState, TEvent> ExecuteOnExit(Action`1<T> action);
    private sealed virtual override IExitActionSyntax`2<TState, TEvent> Appccelerate.StateMachine.Syntax.IExitActionSyntax<TState,TEvent>.ExecuteOnExitParametrized(Action`1<T> action, T parameter);
    private sealed virtual override IOnSyntax`2<TState, TEvent> Appccelerate.StateMachine.Syntax.IEventSyntax<TState,TEvent>.On(TEvent eventId);
    private void CreateTransition();
    private sealed virtual override IGotoSyntax`2<TState, TEvent> Appccelerate.StateMachine.Syntax.IOnSyntax<TState,TEvent>.Goto(TState target);
    private sealed virtual override IGotoSyntax`2<TState, TEvent> Appccelerate.StateMachine.Syntax.IOtherwiseSyntax<TState,TEvent>.Goto(TState target);
    private sealed virtual override IGotoInIfSyntax`2<TState, TEvent> Appccelerate.StateMachine.Syntax.IIfSyntax<TState,TEvent>.Goto(TState target);
    private sealed virtual override IOtherwiseExecuteSyntax`2<TState, TEvent> Appccelerate.StateMachine.Syntax.IOtherwiseExecuteSyntax<TState,TEvent>.Execute(Action action);
    private sealed virtual override IOtherwiseExecuteSyntax`2<TState, TEvent> Appccelerate.StateMachine.Syntax.IOtherwiseExecuteSyntax<TState,TEvent>.Execute(Action`1<T> action);
    private sealed virtual override IGotoInIfSyntax`2<TState, TEvent> Appccelerate.StateMachine.Syntax.IGotoInIfSyntax<TState,TEvent>.Execute(Action action);
    private sealed virtual override IGotoInIfSyntax`2<TState, TEvent> Appccelerate.StateMachine.Syntax.IGotoInIfSyntax<TState,TEvent>.Execute(Action`1<T> action);
    private sealed virtual override IGotoSyntax`2<TState, TEvent> Appccelerate.StateMachine.Syntax.IGotoSyntax<TState,TEvent>.Execute(Action action);
    private sealed virtual override IGotoSyntax`2<TState, TEvent> Appccelerate.StateMachine.Syntax.IGotoSyntax<TState,TEvent>.Execute(Action`1<T> action);
    private sealed virtual override IIfOrOtherwiseSyntax`2<TState, TEvent> Appccelerate.StateMachine.Syntax.IIfSyntax<TState,TEvent>.Execute(Action action);
    private sealed virtual override IIfOrOtherwiseSyntax`2<TState, TEvent> Appccelerate.StateMachine.Syntax.IIfSyntax<TState,TEvent>.Execute(Action`1<T> action);
    private sealed virtual override IOnExecuteSyntax`2<TState, TEvent> Appccelerate.StateMachine.Syntax.IOnExecuteSyntax<TState,TEvent>.Execute(Action action);
    private sealed virtual override IOnExecuteSyntax`2<TState, TEvent> Appccelerate.StateMachine.Syntax.IOnExecuteSyntax<TState,TEvent>.Execute(Action`1<T> action);
    private sealed virtual override IIfSyntax`2<TState, TEvent> Appccelerate.StateMachine.Syntax.IGotoInIfSyntax<TState,TEvent>.If(Func`2<T, bool> guard);
    private sealed virtual override IIfSyntax`2<TState, TEvent> Appccelerate.StateMachine.Syntax.IGotoInIfSyntax<TState,TEvent>.If(Func`1<bool> guard);
    private sealed virtual override IOtherwiseSyntax`2<TState, TEvent> Appccelerate.StateMachine.Syntax.IGotoInIfSyntax<TState,TEvent>.Otherwise();
    private sealed virtual override IIfOrOtherwiseSyntax`2<TState, TEvent> Appccelerate.StateMachine.Syntax.IIfOrOtherwiseSyntax<TState,TEvent>.Execute(Action action);
    private sealed virtual override IIfOrOtherwiseSyntax`2<TState, TEvent> Appccelerate.StateMachine.Syntax.IIfOrOtherwiseSyntax<TState,TEvent>.Execute(Action`1<T> action);
    private StateBuilder`2<TState, TEvent> ExecuteInternal(Action action);
    private StateBuilder`2<TState, TEvent> ExecuteInternal(Action`1<T> action);
    private sealed virtual override IIfSyntax`2<TState, TEvent> Appccelerate.StateMachine.Syntax.IOnSyntax<TState,TEvent>.If(Func`2<T, bool> guard);
    private sealed virtual override IIfSyntax`2<TState, TEvent> Appccelerate.StateMachine.Syntax.IOnSyntax<TState,TEvent>.If(Func`1<bool> guard);
    private sealed virtual override IIfSyntax`2<TState, TEvent> Appccelerate.StateMachine.Syntax.IIfOrOtherwiseSyntax<TState,TEvent>.If(Func`2<T, bool> guard);
    private sealed virtual override IIfSyntax`2<TState, TEvent> Appccelerate.StateMachine.Syntax.IIfOrOtherwiseSyntax<TState,TEvent>.If(Func`1<bool> guard);
    private sealed virtual override IOtherwiseSyntax`2<TState, TEvent> Appccelerate.StateMachine.Syntax.IIfOrOtherwiseSyntax<TState,TEvent>.Otherwise();
    private void SetGuard(Func`2<T, bool> guard);
    private void SetGuard(Func`1<bool> guard);
    private void SetTargetState(TState target);
    private void CheckGuards();
}
[DefaultMemberAttribute("Item")]
public class Appccelerate.StateMachine.Machine.StateDictionary`2 : object {
    private Dictionary`2<TState, IState`2<TState, TEvent>> dictionary;
    private IFactory`2<TState, TEvent> factory;
    public IState`2<TState, TEvent> Item { get; }
    public StateDictionary`2(IFactory`2<TState, TEvent> factory);
    public sealed virtual IState`2<TState, TEvent> get_Item(TState stateId);
    public sealed virtual IEnumerable`1<IState`2<TState, TEvent>> GetStates();
}
public class Appccelerate.StateMachine.Machine.StateMachine`2 : object {
    private IStateDictionary`2<TState, TEvent> states;
    private IFactory`2<TState, TEvent> factory;
    private Initializable`1<TState> initialStateId;
    private string name;
    private List`1<IExtension`2<TState, TEvent>> extensions;
    private IState`2<TState, TEvent> currentState;
    [CompilerGeneratedAttribute]
private EventHandler`1<TransitionEventArgs`2<TState, TEvent>> TransitionDeclined;
    [CompilerGeneratedAttribute]
private EventHandler`1<TransitionExceptionEventArgs`2<TState, TEvent>> TransitionExceptionThrown;
    [CompilerGeneratedAttribute]
private EventHandler`1<TransitionEventArgs`2<TState, TEvent>> TransitionBegin;
    [CompilerGeneratedAttribute]
private EventHandler`1<TransitionCompletedEventArgs`2<TState, TEvent>> TransitionCompleted;
    public string Name { get; }
    public TState CurrentStateId { get; }
    private IState`2<TState, TEvent> CurrentState { get; private set; }
    public StateMachine`2(string name);
    public StateMachine`2(string name, IFactory`2<TState, TEvent> factory);
    [CompilerGeneratedAttribute]
public void add_TransitionDeclined(EventHandler`1<TransitionEventArgs`2<TState, TEvent>> value);
    [CompilerGeneratedAttribute]
public void remove_TransitionDeclined(EventHandler`1<TransitionEventArgs`2<TState, TEvent>> value);
    [CompilerGeneratedAttribute]
public void add_TransitionExceptionThrown(EventHandler`1<TransitionExceptionEventArgs`2<TState, TEvent>> value);
    [CompilerGeneratedAttribute]
public void remove_TransitionExceptionThrown(EventHandler`1<TransitionExceptionEventArgs`2<TState, TEvent>> value);
    [CompilerGeneratedAttribute]
public void add_TransitionBegin(EventHandler`1<TransitionEventArgs`2<TState, TEvent>> value);
    [CompilerGeneratedAttribute]
public void remove_TransitionBegin(EventHandler`1<TransitionEventArgs`2<TState, TEvent>> value);
    [CompilerGeneratedAttribute]
public void add_TransitionCompleted(EventHandler`1<TransitionCompletedEventArgs`2<TState, TEvent>> value);
    [CompilerGeneratedAttribute]
public void remove_TransitionCompleted(EventHandler`1<TransitionCompletedEventArgs`2<TState, TEvent>> value);
    public sealed virtual string get_Name();
    public sealed virtual TState get_CurrentStateId();
    private IState`2<TState, TEvent> get_CurrentState();
    private void set_CurrentState(IState`2<TState, TEvent> value);
    public void AddExtension(IExtension`2<TState, TEvent> extension);
    public void ClearExtensions();
    public sealed virtual void ForEach(Action`1<IExtension`2<TState, TEvent>> action);
    public IEntryActionSyntax`2<TState, TEvent> In(TState state);
    public void Initialize(TState initialState);
    public void EnterInitialState();
    public void Fire(TEvent eventId);
    public void Fire(TEvent eventId, object eventArgument);
    public IHierarchySyntax`1<TState> DefineHierarchyOn(TState superStateId);
    public sealed virtual void OnExceptionThrown(ITransitionContext`2<TState, TEvent> context, Exception exception);
    public sealed virtual void OnTransitionBegin(ITransitionContext`2<TState, TEvent> transitionContext);
    public virtual string ToString();
    public void Report(IStateMachineReport`2<TState, TEvent> reportGenerator);
    public void Save(IStateMachineSaver`1<TState> stateMachineSaver);
    public void Load(IStateMachineLoader`1<TState> stateMachineLoader);
    private static void RethrowExceptionIfNoHandlerRegistered(Exception exception, EventHandler`1<T> exceptionHandler);
    private void OnTransitionDeclined(ITransitionContext`2<TState, TEvent> transitionContext);
    private void OnTransitionCompleted(ITransitionContext`2<TState, TEvent> transitionContext);
    private void LoadCurrentState(IStateMachineLoader`1<TState> stateMachineLoader);
    private void LoadHistoryStates(IStateMachineLoader`1<TState> stateMachineLoader);
    private void Initialize(IState`2<TState, TEvent> initialState);
    private void EnterInitialState(IState`2<TState, TEvent> initialState, ITransitionContext`2<TState, TEvent> context);
    private void RaiseEvent(EventHandler`1<T> eventHandler, T arguments, ITransitionContext`2<TState, TEvent> context, bool raiseEventOnException);
    private void CheckThatStateMachineIsInitialized();
    private void CheckThatStateMachineIsNotAlreadyInitialized();
    private void CheckThatStateMachineHasEnteredInitialState();
    [CompilerGeneratedAttribute]
private void <EnterInitialState>b__33_0(IExtension`2<TState, TEvent> extension);
}
public class Appccelerate.StateMachine.Machine.StateMachineException : Exception {
    public StateMachineException(string message, Exception innerException);
}
public class Appccelerate.StateMachine.Machine.StateMachineInitializer`2 : object {
    private IState`2<TState, TEvent> initialState;
    private ITransitionContext`2<TState, TEvent> context;
    public StateMachineInitializer`2(IState`2<TState, TEvent> initialState, ITransitionContext`2<TState, TEvent> context);
    public IState`2<TState, TEvent> EnterInitialState();
    private Stack`1<IState`2<TState, TEvent>> TraverseUpTheStateHierarchy();
    private void TraverseDownTheStateHierarchyAndEnterStates(Stack`1<IState`2<TState, TEvent>> stack);
}
public class Appccelerate.StateMachine.Machine.States.State`2 : object {
    private List`1<IState`2<TState, TEvent>> subStates;
    private TransitionDictionary`2<TState, TEvent> transitions;
    private IStateMachineInformation`2<TState, TEvent> stateMachineInformation;
    private IExtensionHost`2<TState, TEvent> extensionHost;
    private int level;
    private IState`2<TState, TEvent> superState;
    private IState`2<TState, TEvent> initialState;
    private HistoryType historyType;
    [CompilerGeneratedAttribute]
private IState`2<TState, TEvent> <LastActiveState>k__BackingField;
    [CompilerGeneratedAttribute]
private TState <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<IActionHolder> <EntryActions>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<IActionHolder> <ExitActions>k__BackingField;
    public IState`2<TState, TEvent> LastActiveState { get; public set; }
    public TState Id { get; private set; }
    public IList`1<IActionHolder> EntryActions { get; private set; }
    public IList`1<IActionHolder> ExitActions { get; private set; }
    public IState`2<TState, TEvent> InitialState { get; public set; }
    public IState`2<TState, TEvent> SuperState { get; public set; }
    public int Level { get; public set; }
    public HistoryType HistoryType { get; public set; }
    public ICollection`1<IState`2<TState, TEvent>> SubStates { get; }
    public ITransitionDictionary`2<TState, TEvent> Transitions { get; }
    public State`2(TState id, IStateMachineInformation`2<TState, TEvent> stateMachineInformation, IExtensionHost`2<TState, TEvent> extensionHost);
    [CompilerGeneratedAttribute]
public sealed virtual IState`2<TState, TEvent> get_LastActiveState();
    [CompilerGeneratedAttribute]
public sealed virtual void set_LastActiveState(IState`2<TState, TEvent> value);
    [CompilerGeneratedAttribute]
public sealed virtual TState get_Id();
    [CompilerGeneratedAttribute]
private void set_Id(TState value);
    [CompilerGeneratedAttribute]
public sealed virtual IList`1<IActionHolder> get_EntryActions();
    [CompilerGeneratedAttribute]
private void set_EntryActions(IList`1<IActionHolder> value);
    [CompilerGeneratedAttribute]
public sealed virtual IList`1<IActionHolder> get_ExitActions();
    [CompilerGeneratedAttribute]
private void set_ExitActions(IList`1<IActionHolder> value);
    public sealed virtual IState`2<TState, TEvent> get_InitialState();
    public sealed virtual void set_InitialState(IState`2<TState, TEvent> value);
    public sealed virtual IState`2<TState, TEvent> get_SuperState();
    public sealed virtual void set_SuperState(IState`2<TState, TEvent> value);
    public sealed virtual int get_Level();
    public sealed virtual void set_Level(int value);
    public sealed virtual HistoryType get_HistoryType();
    public sealed virtual void set_HistoryType(HistoryType value);
    public sealed virtual ICollection`1<IState`2<TState, TEvent>> get_SubStates();
    public sealed virtual ITransitionDictionary`2<TState, TEvent> get_Transitions();
    public sealed virtual ITransitionResult`2<TState, TEvent> Fire(ITransitionContext`2<TState, TEvent> context);
    public sealed virtual void Entry(ITransitionContext`2<TState, TEvent> context);
    public sealed virtual void Exit(ITransitionContext`2<TState, TEvent> context);
    public sealed virtual IState`2<TState, TEvent> EnterByHistory(ITransitionContext`2<TState, TEvent> context);
    public sealed virtual IState`2<TState, TEvent> EnterShallow(ITransitionContext`2<TState, TEvent> context);
    public sealed virtual IState`2<TState, TEvent> EnterDeep(ITransitionContext`2<TState, TEvent> context);
    public virtual string ToString();
    private static void HandleException(Exception exception, ITransitionContext`2<TState, TEvent> context);
    private void SetInitialLevel();
    private void SetLevelOfSubStates();
    private void ExecuteEntryActions(ITransitionContext`2<TState, TEvent> context);
    private void ExecuteEntryAction(IActionHolder actionHolder, ITransitionContext`2<TState, TEvent> context);
    private void HandleEntryActionException(ITransitionContext`2<TState, TEvent> context, Exception exception);
    private void ExecuteExitActions(ITransitionContext`2<TState, TEvent> context);
    private void ExecuteExitAction(IActionHolder actionHolder, ITransitionContext`2<TState, TEvent> context);
    private void HandleExitActionException(ITransitionContext`2<TState, TEvent> context, Exception exception);
    private void SetThisStateAsLastStateOfSuperState();
    private IState`2<TState, TEvent> EnterHistoryDeep(ITransitionContext`2<TState, TEvent> context);
    private IState`2<TState, TEvent> EnterHistoryShallow(ITransitionContext`2<TState, TEvent> context);
    private IState`2<TState, TEvent> EnterHistoryNone(ITransitionContext`2<TState, TEvent> context);
    private void CheckSuperStateIsNotThisInstance(IState`2<TState, TEvent> newSuperState);
    private void CheckInitialStateIsNotThisInstance(IState`2<TState, TEvent> newInitialState);
    private void CheckInitialStateIsASubState(IState`2<TState, TEvent> value);
}
public static class Appccelerate.StateMachine.Machine.States.StatesExceptionMessages : object {
    public static string StateCannotBeItsOwnSuperState(string state);
    public static string StateCannotBeTheInitialSubStateToItself(string state);
    public static string StateCannotBeTheInitialStateOfSuperStateBecauseItIsNotADirectSubState(string state, string superState);
}
public class Appccelerate.StateMachine.Machine.Transitions.Transition`2 : object {
    private List`1<IActionHolder> actions;
    private IExtensionHost`2<TState, TEvent> extensionHost;
    private IStateMachineInformation`2<TState, TEvent> stateMachineInformation;
    [CompilerGeneratedAttribute]
private IState`2<TState, TEvent> <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private IState`2<TState, TEvent> <Target>k__BackingField;
    [CompilerGeneratedAttribute]
private IGuardHolder <Guard>k__BackingField;
    public IState`2<TState, TEvent> Source { get; public set; }
    public IState`2<TState, TEvent> Target { get; public set; }
    public IGuardHolder Guard { get; public set; }
    public ICollection`1<IActionHolder> Actions { get; }
    private bool IsInternalTransition { get; }
    public Transition`2(IStateMachineInformation`2<TState, TEvent> stateMachineInformation, IExtensionHost`2<TState, TEvent> extensionHost);
    [CompilerGeneratedAttribute]
public sealed virtual IState`2<TState, TEvent> get_Source();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Source(IState`2<TState, TEvent> value);
    [CompilerGeneratedAttribute]
public sealed virtual IState`2<TState, TEvent> get_Target();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Target(IState`2<TState, TEvent> value);
    [CompilerGeneratedAttribute]
public sealed virtual IGuardHolder get_Guard();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Guard(IGuardHolder value);
    public sealed virtual ICollection`1<IActionHolder> get_Actions();
    private bool get_IsInternalTransition();
    public sealed virtual ITransitionResult`2<TState, TEvent> Fire(ITransitionContext`2<TState, TEvent> context);
    public virtual string ToString();
    private static void HandleException(Exception exception, ITransitionContext`2<TState, TEvent> context);
    private void Fire(IState`2<TState, TEvent> source, IState`2<TState, TEvent> target, ITransitionContext`2<TState, TEvent> context);
    private bool ShouldFire(ITransitionContext`2<TState, TEvent> context);
    private void PerformActions(ITransitionContext`2<TState, TEvent> context);
    private void UnwindSubStates(ITransitionContext`2<TState, TEvent> context);
}
[DefaultMemberAttribute("Item")]
public class Appccelerate.StateMachine.Machine.Transitions.TransitionDictionary`2 : object {
    private Dictionary`2<TEvent, List`1<ITransition`2<TState, TEvent>>> transitions;
    private IState`2<TState, TEvent> state;
    public ICollection`1<ITransition`2<TState, TEvent>> Item { get; }
    public TransitionDictionary`2(IState`2<TState, TEvent> state);
    public ICollection`1<ITransition`2<TState, TEvent>> get_Item(TEvent eventId);
    public sealed virtual void Add(TEvent eventId, ITransition`2<TState, TEvent> transition);
    public sealed virtual IEnumerable`1<TransitionInfo`2<TState, TEvent>> GetTransitions();
    private void CheckTransitionDoesNotYetExist(ITransition`2<TState, TEvent> transition);
    private void MakeSureEventExistsInTransitionList(TEvent eventId);
    private void GetTransitionsOfEvent(TEvent eventId, List`1<TransitionInfo`2<TState, TEvent>> list);
}
public class Appccelerate.StateMachine.Machine.Transitions.TransitionInfo`2 : object {
    [CompilerGeneratedAttribute]
private TEvent <EventId>k__BackingField;
    [CompilerGeneratedAttribute]
private IState`2<TState, TEvent> <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private IState`2<TState, TEvent> <Target>k__BackingField;
    [CompilerGeneratedAttribute]
private IGuardHolder <Guard>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<IActionHolder> <Actions>k__BackingField;
    public TEvent EventId { get; private set; }
    public IState`2<TState, TEvent> Source { get; private set; }
    public IState`2<TState, TEvent> Target { get; private set; }
    public IGuardHolder Guard { get; private set; }
    public IEnumerable`1<IActionHolder> Actions { get; private set; }
    public TransitionInfo`2(TEvent eventId, IState`2<TState, TEvent> source, IState`2<TState, TEvent> target, IGuardHolder guard, IEnumerable`1<IActionHolder> actions);
    [CompilerGeneratedAttribute]
public TEvent get_EventId();
    [CompilerGeneratedAttribute]
private void set_EventId(TEvent value);
    [CompilerGeneratedAttribute]
public IState`2<TState, TEvent> get_Source();
    [CompilerGeneratedAttribute]
private void set_Source(IState`2<TState, TEvent> value);
    [CompilerGeneratedAttribute]
public IState`2<TState, TEvent> get_Target();
    [CompilerGeneratedAttribute]
private void set_Target(IState`2<TState, TEvent> value);
    [CompilerGeneratedAttribute]
public IGuardHolder get_Guard();
    [CompilerGeneratedAttribute]
private void set_Guard(IGuardHolder value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<IActionHolder> get_Actions();
    [CompilerGeneratedAttribute]
private void set_Actions(IEnumerable`1<IActionHolder> value);
}
public class Appccelerate.StateMachine.Machine.Transitions.TransitionResult`2 : object {
    public static ITransitionResult`2<TState, TEvent> NotFired;
    [CompilerGeneratedAttribute]
private bool <Fired>k__BackingField;
    [CompilerGeneratedAttribute]
private IState`2<TState, TEvent> <NewState>k__BackingField;
    public bool Fired { get; private set; }
    public IState`2<TState, TEvent> NewState { get; private set; }
    public TransitionResult`2(bool fired, IState`2<TState, TEvent> newState);
    private static TransitionResult`2();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_Fired();
    [CompilerGeneratedAttribute]
private void set_Fired(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual IState`2<TState, TEvent> get_NewState();
    [CompilerGeneratedAttribute]
private void set_NewState(IState`2<TState, TEvent> value);
}
public static class Appccelerate.StateMachine.Machine.Transitions.TransitionsExceptionMessages : object {
    public static string TransitionDoesAlreadyExist(ITransition`2<TState, TEvent> transition, IState`2<TState, TEvent> state);
}
public class Appccelerate.StateMachine.PassiveStateMachine`2 : object {
    private StateMachine`2<TState, TEvent> stateMachine;
    private LinkedList`1<EventInformation`1<TEvent>> events;
    private bool initialized;
    private bool executing;
    private bool pendingInitialization;
    [CompilerGeneratedAttribute]
private bool <IsRunning>k__BackingField;
    public bool IsRunning { get; private set; }
    public PassiveStateMachine`2(string name);
    public PassiveStateMachine`2(string name, IFactory`2<TState, TEvent> factory);
    public sealed virtual void add_TransitionDeclined(EventHandler`1<TransitionEventArgs`2<TState, TEvent>> value);
    public sealed virtual void remove_TransitionDeclined(EventHandler`1<TransitionEventArgs`2<TState, TEvent>> value);
    public sealed virtual void add_TransitionExceptionThrown(EventHandler`1<TransitionExceptionEventArgs`2<TState, TEvent>> value);
    public sealed virtual void remove_TransitionExceptionThrown(EventHandler`1<TransitionExceptionEventArgs`2<TState, TEvent>> value);
    public sealed virtual void add_TransitionBegin(EventHandler`1<TransitionEventArgs`2<TState, TEvent>> value);
    public sealed virtual void remove_TransitionBegin(EventHandler`1<TransitionEventArgs`2<TState, TEvent>> value);
    public sealed virtual void add_TransitionCompleted(EventHandler`1<TransitionCompletedEventArgs`2<TState, TEvent>> value);
    public sealed virtual void remove_TransitionCompleted(EventHandler`1<TransitionCompletedEventArgs`2<TState, TEvent>> value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsRunning();
    [CompilerGeneratedAttribute]
private void set_IsRunning(bool value);
    public sealed virtual IEntryActionSyntax`2<TState, TEvent> In(TState state);
    public sealed virtual IHierarchySyntax`1<TState> DefineHierarchyOn(TState superStateId);
    public sealed virtual void Fire(TEvent eventId);
    public sealed virtual void Fire(TEvent eventId, object eventArgument);
    public sealed virtual void FirePriority(TEvent eventId);
    public sealed virtual void FirePriority(TEvent eventId, object eventArgument);
    public sealed virtual void Initialize(TState initialState);
    public sealed virtual void Start();
    public sealed virtual void ClearExtensions();
    public sealed virtual void Report(IStateMachineReport`2<TState, TEvent> reportGenerator);
    public sealed virtual void Stop();
    public sealed virtual void AddExtension(IExtension`2<TState, TEvent> extension);
    public sealed virtual void Save(IStateMachineSaver`1<TState> stateMachineSaver);
    public sealed virtual void Load(IStateMachineLoader`1<TState> stateMachineLoader);
    private void CheckThatNotAlreadyInitialized();
    private void CheckThatStateMachineIsInitialized();
    private void Execute();
    private void ProcessQueuedEvents();
    private void InitializeStateMachineIfInitializationIsPending();
    private EventInformation`1<TEvent> GetNextEventToProcess();
    private void FireEventOnStateMachine(EventInformation`1<TEvent> e);
    [CompilerGeneratedAttribute]
private void <Start>b__31_0(IExtension`2<TState, TEvent> extension);
    [CompilerGeneratedAttribute]
private void <Stop>b__34_0(IExtension`2<TState, TEvent> extension);
}
public interface Appccelerate.StateMachine.Persistence.IStateMachineLoader`1 {
    public abstract virtual Initializable`1<TState> LoadCurrentState();
    public abstract virtual IDictionary`2<TState, TState> LoadHistoryStates();
}
public interface Appccelerate.StateMachine.Persistence.IStateMachineSaver`1 {
    public abstract virtual void SaveCurrentState(Initializable`1<TState> currentStateId);
    public abstract virtual void SaveHistoryStates(IDictionary`2<TState, TState> historyStates);
}
public class Appccelerate.StateMachine.Reports.CsvStateMachineReportGenerator`2 : object {
    private Stream statesStream;
    private Stream transitionsStream;
    public CsvStateMachineReportGenerator`2(Stream statesStream, Stream transitionsStream);
    public sealed virtual void Report(string name, IEnumerable`1<IState`2<TState, TEvent>> states, Initializable`1<TState> initialStateId);
    private void ReportStates(IEnumerable`1<IState`2<TState, TEvent>> states);
    private void ReportTransitions(IEnumerable`1<IState`2<TState, TEvent>> states);
}
public class Appccelerate.StateMachine.Reports.CsvStatesWriter`2 : object {
    private StreamWriter writer;
    public CsvStatesWriter`2(StreamWriter writer);
    public void Write(IEnumerable`1<IState`2<TState, TEvent>> states);
    private void WriteStatesHeader();
    private void ReportState(IState`2<TState, TEvent> state);
}
public class Appccelerate.StateMachine.Reports.CsvTransitionsWriter`2 : object {
    private StreamWriter writer;
    public CsvTransitionsWriter`2(StreamWriter writer);
    public void Write(IEnumerable`1<IState`2<TState, TEvent>> states);
    private void WriteTransitionsHeader();
    private void ReportTransitionsOfState(IState`2<TState, TEvent> state);
    private void ReportTransition(TransitionInfo`2<TState, TEvent> transition);
}
public class Appccelerate.StateMachine.Reports.StateMachineReportGenerator`2 : object {
    [CompilerGeneratedAttribute]
private string <Result>k__BackingField;
    public string Result { get; private set; }
    [CompilerGeneratedAttribute]
public string get_Result();
    [CompilerGeneratedAttribute]
private void set_Result(string value);
    public sealed virtual void Report(string name, IEnumerable`1<IState`2<TState, TEvent>> states, Initializable`1<TState> initialStateId);
    private static void ReportStateNameInitialStateHistoryTypeEntryAndExitAction(StringBuilder report, string indentation, IState`2<TState, TEvent> state);
    private static void ReportTransition(StringBuilder report, string indentation, TransitionInfo`2<TState, TEvent> transition);
    private void ReportState(IState`2<TState, TEvent> state, StringBuilder report, string indentation);
}
public class Appccelerate.StateMachine.Reports.YEdStateMachineReportGenerator`2 : object {
    private static XNamespace N;
    private static XNamespace Xsi;
    private static XNamespace Y;
    private static XNamespace YEd;
    private static XNamespace SchemaLocation;
    private TextWriter textWriter;
    private int edgeId;
    private Initializable`1<TState> initialStateId;
    public YEdStateMachineReportGenerator`2(TextWriter textWriter);
    private static YEdStateMachineReportGenerator`2();
    public sealed virtual void Report(string name, IEnumerable`1<IState`2<TState, TEvent>> states, Initializable`1<TState> initialState);
    private static XElement CreateGraph();
    private static XDocument CreateXmlDocument(XElement graph);
    private static string CreateExitActionsDescription(IState`2<TState, TEvent> state);
    private static string CreateEntryActionDescription(IState`2<TState, TEvent> state);
    private static string CreateGuardDescription(TransitionInfo`2<TState, TEvent> transition);
    private static string CreateActionsDescription(TransitionInfo`2<TState, TEvent> transition);
    private void AddEdges(XElement graph, IEnumerable`1<IState`2<TState, TEvent>> states);
    private void AddEdge(XElement graph, TransitionInfo`2<TState, TEvent> transition);
    private void AddNodes(XElement graph, IEnumerable`1<IState`2<TState, TEvent>> states);
    private void AddNode(XElement graph, IState`2<TState, TEvent> state);
    private bool DetermineWhetherThisIsAnInitialState(IState`2<TState, TEvent> state);
}
public interface Appccelerate.StateMachine.Syntax.IEntryActionSyntax`2 {
    public abstract virtual IEntryActionSyntax`2<TState, TEvent> ExecuteOnEntry(Action action);
    public abstract virtual IEntryActionSyntax`2<TState, TEvent> ExecuteOnEntry(Action`1<T> action);
    public abstract virtual IEntryActionSyntax`2<TState, TEvent> ExecuteOnEntryParametrized(Action`1<T> action, T parameter);
}
public interface Appccelerate.StateMachine.Syntax.IEventSyntax`2 {
    public abstract virtual IOnSyntax`2<TState, TEvent> On(TEvent eventId);
}
public interface Appccelerate.StateMachine.Syntax.IExitActionSyntax`2 {
    public abstract virtual IExitActionSyntax`2<TState, TEvent> ExecuteOnExit(Action action);
    public abstract virtual IExitActionSyntax`2<TState, TEvent> ExecuteOnExit(Action`1<T> action);
    public abstract virtual IExitActionSyntax`2<TState, TEvent> ExecuteOnExitParametrized(Action`1<T> action, T parameter);
}
public interface Appccelerate.StateMachine.Syntax.IGotoInIfSyntax`2 {
    public abstract virtual IIfSyntax`2<TState, TEvent> If(Func`2<T, bool> guard);
    public abstract virtual IIfSyntax`2<TState, TEvent> If(Func`1<bool> guard);
    public abstract virtual IOtherwiseSyntax`2<TState, TEvent> Otherwise();
    public abstract virtual IGotoInIfSyntax`2<TState, TEvent> Execute(Action action);
    public abstract virtual IGotoInIfSyntax`2<TState, TEvent> Execute(Action`1<T> action);
}
public interface Appccelerate.StateMachine.Syntax.IGotoSyntax`2 {
    public abstract virtual IGotoSyntax`2<TState, TEvent> Execute(Action action);
    public abstract virtual IGotoSyntax`2<TState, TEvent> Execute(Action`1<T> action);
}
public interface Appccelerate.StateMachine.Syntax.IHierarchySyntax`1 {
    public abstract virtual IInitialSubStateSyntax`1<TState> WithHistoryType(HistoryType historyType);
}
public interface Appccelerate.StateMachine.Syntax.IIfOrOtherwiseSyntax`2 {
    public abstract virtual IIfSyntax`2<TState, TEvent> If(Func`2<T, bool> guard);
    public abstract virtual IIfSyntax`2<TState, TEvent> If(Func`1<bool> guard);
    public abstract virtual IOtherwiseSyntax`2<TState, TEvent> Otherwise();
    public abstract virtual IIfOrOtherwiseSyntax`2<TState, TEvent> Execute(Action action);
    public abstract virtual IIfOrOtherwiseSyntax`2<TState, TEvent> Execute(Action`1<T> action);
}
public interface Appccelerate.StateMachine.Syntax.IIfSyntax`2 {
    public abstract virtual IGotoInIfSyntax`2<TState, TEvent> Goto(TState target);
    public abstract virtual IIfOrOtherwiseSyntax`2<TState, TEvent> Execute(Action action);
    public abstract virtual IIfOrOtherwiseSyntax`2<TState, TEvent> Execute(Action`1<T> action);
}
public interface Appccelerate.StateMachine.Syntax.IInitialSubStateSyntax`1 {
    public abstract virtual ISubStateSyntax`1<TState> WithInitialSubState(TState stateId);
}
public interface Appccelerate.StateMachine.Syntax.IOnExecuteSyntax`2 {
    public abstract virtual IOnExecuteSyntax`2<TState, TEvent> Execute(Action action);
    public abstract virtual IOnExecuteSyntax`2<TState, TEvent> Execute(Action`1<T> action);
}
public interface Appccelerate.StateMachine.Syntax.IOnSyntax`2 {
    public abstract virtual IGotoSyntax`2<TState, TEvent> Goto(TState target);
    public abstract virtual IIfSyntax`2<TState, TEvent> If(Func`2<T, bool> guard);
    public abstract virtual IIfSyntax`2<TState, TEvent> If(Func`1<bool> guard);
}
public interface Appccelerate.StateMachine.Syntax.IOtherwiseExecuteSyntax`2 {
    public abstract virtual IOtherwiseExecuteSyntax`2<TState, TEvent> Execute(Action action);
    public abstract virtual IOtherwiseExecuteSyntax`2<TState, TEvent> Execute(Action`1<T> action);
}
public interface Appccelerate.StateMachine.Syntax.IOtherwiseSyntax`2 {
    public abstract virtual IGotoSyntax`2<TState, TEvent> Goto(TState target);
}
public interface Appccelerate.StateMachine.Syntax.ISubStateSyntax`1 {
    public abstract virtual ISubStateSyntax`1<TState> WithSubState(TState stateId);
}
[ExtensionAttribute]
public static class Appccelerate.StateMachine.TypeExtensionMethods : object {
    [ExtensionAttribute]
public static string FullNameToString(Type type);
}
